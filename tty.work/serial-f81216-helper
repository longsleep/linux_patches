serial: Add a helper driver for the F81216

From: Bruno <bonbons67@internet.lu>

This is a helper driver to restore the F81216 SuperIO hardware on systems
where the BIOS gets it wrong.

See http://bugzilla.kernel.org/attachment.cgi?id=21784

[Added region request/handling alan@linux.intel.com]

Signed-off-by: Alan Cox <alan@linux.intel.com>
---

 drivers/serial/8250_f81216.c |  311 +++++++++++++++++++++++++++++++++++++++++++
 drivers/serial/Kconfig       |   11 +
 drivers/serial/Makefile      |    1 
 3 files changed, 323 insertions(+)
 create mode 100644 drivers/serial/8250_f81216.c


--- /dev/null
+++ b/drivers/serial/8250_f81216.c
@@ -0,0 +1,311 @@
+/*
+ *  linux/drivers/serial/8250_f81216.c
+ *
+ *  Copyright (C) 2009 Bruno Prémont <bonbons@linux-vserver.org>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/serial_8250.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+
+static int io_base    = 0x4e;
+static int config_key = 0x77;
+
+struct f81216_uart_state {
+	__u16 io_port;
+	__u8  enabled;
+	__u8  irq_channel;
+	__u8  clk_select;
+};
+struct f81216_state {
+	__u8 clk_source;
+	struct f81216_uart_state uart[4];
+};
+
+static struct platform_device *f81216_device;
+
+#define LDN              0x07 /* Register: Logical device select */
+#define DEVICE_ID        0x20 /* Register: Device ID (2 bytes) */
+#define VENDOR_ID        0x23 /* Register: Vendor ID (2 bytes) */
+#define CLK_SRC          0x25 /* Register: Clock source select */
+#define LDN_ENABLE       0x30 /* Register: Device enable */
+#define LDN_IOPORT       0x60 /* Register: I/O Port select (2 bytes) */
+#define LDN_IRQCHAN      0x70 /* Register: IRQ Channel select */
+#define LDN_CLK          0xf0 /* Register: Clock select */
+
+#define F81216_DEVICE_ID 0x0208
+#define F81216_VENDOR_ID 0x1934
+
+static int superio_inb(int reg)
+{
+	outb(reg, io_base);
+	return inb(io_base+1);
+}
+
+static int superio_inw(int reg)
+{
+	int val;
+	outb(reg++, io_base);
+	val = inb(io_base+1) << 8;
+	outb(reg, io_base);
+	val |= inb(io_base+1);
+	return val;
+}
+
+static void superio_outb(int val, int reg)
+{
+	outb(reg, io_base);
+	outb(val, io_base+1);
+}
+
+static void superio_outw(int val, int reg)
+{
+	outb(reg++, io_base);
+	outb((val >> 8) & 0xff, io_base+1);
+	outb(reg, io_base);
+	outb(val & 0xff, io_base+1);
+}
+
+static void superio_enter(void)
+{
+	outb(config_key, io_base);
+	outb(config_key, io_base);
+}
+
+static void superio_exit(void)
+{
+	outb(0xaa, io_base);
+}
+
+static int f81216_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct f81216_state *data = platform_get_drvdata(dev);
+	int i;
+
+	if (!data)
+		return -ENOMEM;
+
+	superio_enter();
+	data->clk_source = superio_inb(CLK_SRC);
+	dev_printk(KERN_DEBUG, &dev->dev, "Chip status: clk=%x\n",
+			data->clk_source);
+	for (i = 0; i < 4; i++) {
+		superio_outb(i, LDN);
+		data->uart[i].enabled     = superio_inb(LDN_ENABLE);
+		data->uart[i].io_port     = superio_inw(LDN_IOPORT);
+		data->uart[i].irq_channel = superio_inb(LDN_IRQCHAN);
+		data->uart[i].clk_select  = superio_inb(LDN_CLK);
+		dev_printk(KERN_DEBUG, &dev->dev, "UART %d status: ioport=%x,"
+				" irqchan=%x, clk=%x, enable=%x\n", i,
+				data->uart[i].io_port,
+				data->uart[i].irq_channel,
+				data->uart[i].clk_select,
+				data->uart[i].enabled);
+	}
+	superio_exit();
+	return 0;
+}
+
+static int f81216_suspend_late(struct platform_device *dev, pm_message_t state)
+{
+	int i;
+
+	superio_enter();
+	dev_printk(KERN_DEBUG, &dev->dev, "Chip status: clk=%x\n",
+			superio_inb(CLK_SRC));
+	for (i = 0; i < 4; i++) {
+		superio_outb(i, LDN);
+		dev_printk(KERN_DEBUG, &dev->dev, "UART %d status: ioport=%x,"
+				" irqchan=%x, clk=%x, enable=%x\n", i,
+				superio_inw(LDN_IOPORT),
+				superio_inb(LDN_IRQCHAN),
+				superio_inb(LDN_CLK),
+				superio_inb(LDN_ENABLE));
+	}
+	superio_exit();
+	return 0;
+}
+
+static void f81216_restoreb(struct platform_device *dev, int ldn, int offset,
+		int value)
+{
+	int v = superio_inb(offset);
+	if (v == value)
+		return;
+
+	if (ldn >= 0)
+		dev_printk(KERN_DEBUG, &dev->dev, "restoring device %d config "
+				"at offset %x (was %x, writing %x)\n",
+				ldn, offset, v, value);
+	else
+		dev_printk(KERN_DEBUG, &dev->dev, "restoring global config "
+				"at offset %x (was %x, writing %x)\n",
+				offset, v, value);
+	superio_outb(value, offset);
+}
+
+static void f81216_restorew(struct platform_device *dev, int ldn, int offset,
+		int value)
+{
+	int v = superio_inw(offset);
+	if (v == value)
+		return;
+
+	if (ldn >= 0)
+		dev_printk(KERN_DEBUG, &dev->dev, "restoring device %d config "
+				"at offset %x (was %x, writing %x)\n",
+				ldn, offset, v, value);
+	else
+		dev_printk(KERN_DEBUG, &dev->dev, "restoring global config "
+				"at offset %x (was %x, writing %x)\n",
+				offset, v, value);
+	superio_outw(value, offset);
+}
+
+static int f81216_resume_early(struct platform_device *dev)
+{
+	int i;
+
+	superio_enter();
+	dev_printk(KERN_DEBUG, &dev->dev, "Chip status: clk=%x\n",
+			superio_inb(CLK_SRC));
+	for (i = 0; i < 4; i++) {
+		superio_outb(i, LDN);
+		dev_printk(KERN_DEBUG, &dev->dev, "UART %d status: ioport=%x,"
+				" irqchan=%x, clk=%x, enable=%x\n", i,
+				superio_inw(LDN_IOPORT),
+				superio_inb(LDN_IRQCHAN),
+				superio_inb(LDN_CLK),
+				superio_inb(LDN_ENABLE));
+	}
+	superio_exit();
+	return 0;
+}
+
+static int f81216_resume(struct platform_device *dev)
+{
+	struct f81216_state *data = platform_get_drvdata(dev);
+	int i;
+
+	superio_enter();
+	f81216_restoreb(dev, -1, CLK_SRC, data->clk_source);
+	for (i = 0; i < 4; i++) {
+		superio_outb(i, LDN);
+		f81216_restoreb(dev, i, LDN_CLK, data->uart[i].clk_select);
+		f81216_restorew(dev, i, LDN_IOPORT, data->uart[i].io_port);
+		f81216_restoreb(dev, i, LDN_IRQCHAN, data->uart[i].irq_channel);
+		f81216_restoreb(dev, i, LDN_ENABLE, data->uart[i].enabled);
+	}
+	superio_exit();
+	return 0;
+}
+
+static struct platform_driver f81216_driver = {
+	.suspend       = f81216_suspend,
+	.suspend_late  = f81216_suspend_late,
+	.resume_early  = f81216_resume_early,
+	.resume        = f81216_resume,
+	.driver        = {
+		.name  = "f81216",
+		.owner = THIS_MODULE,
+	}
+};
+
+static int __init f81216_init(void)
+{
+	int port, i, ret;
+	struct resource res = {
+		.start = io_base,
+		.end = io_base + 0x01,
+		.name = "f81216",
+		.flags = IORESOURCE_IO
+	};
+
+	if (io_base != 0x2e && io_base != 0x4e)
+		return EINVAL;
+	if (config_key != 0x77 && config_key != 0xa0 && config_key != 0x87 &&
+			config_key != 0x67)
+		return EINVAL;
+	if (request_region(io_base, 2, "f81216 probe") == 0)
+		return -EBUSY;
+	/* determine existance of Fintek 81216 chip */
+	superio_enter();
+	if (superio_inw(DEVICE_ID) != F81216_DEVICE_ID)
+		goto out;
+	if (superio_inw(VENDOR_ID) != F81216_VENDOR_ID)
+		goto out;
+
+	/* count enabled ports - to be extended to register our UARTs */
+	for (i = port = 0; i < 4; i++) {
+		superio_outb(i, LDN);
+		if (superio_inb(LDN_ENABLE) == 0x01)
+			port++;
+	}
+	superio_exit();
+	release_region(io_base, 2);
+
+	printk(KERN_INFO "f81216: Found chip with %d UART ports enabled\n",
+			port);
+
+	ret = platform_driver_register(&f81216_driver);
+	if (ret)
+		return ret;
+
+	f81216_device = platform_device_alloc("f81216", -1);
+	if (f81216_device) {
+		platform_set_drvdata(f81216_device, kzalloc(sizeof(struct f81216_state), GFP_KERNEL));
+		if (!platform_get_drvdata(f81216_device))
+			ret = -ENOMEM;
+	} else
+		ret = -ENOMEM;
+	if (ret)
+		goto fail_platform_device_alloc;
+
+	ret = platform_device_add_resources(f81216_device, &res, 1);
+	if (ret)
+		goto fail_platform_device_add;
+
+	ret = platform_device_add(f81216_device);
+	if (ret)
+		goto fail_platform_device_add;
+
+	return 0;
+
+fail_platform_device_add:
+	platform_device_put(f81216_device);
+
+fail_platform_device_alloc:
+	platform_driver_unregister(&f81216_driver);
+	return ret;
+
+out:
+	superio_exit();
+	release_region(io_base, 2);
+	return -ENODEV;
+}
+
+static void __exit f81216_exit(void)
+{
+	platform_device_unregister(f81216_device);
+	platform_driver_unregister(&f81216_driver);
+}
+
+module_init(f81216_init);
+module_exit(f81216_exit);
+
+module_param(io_base, uint, 0444);
+MODULE_PARM_DESC(io_base, "Configuration IO port [0x4e (default) or 0x2e]");
+
+module_param(config_key, uint, 0444);
+MODULE_PARM_DESC(config_key, "Configuration entry key [0x77 (default), "
+	"0xa0, 0x87 or 0x67]");
+
+MODULE_AUTHOR("Bruno Prémont");
+MODULE_DESCRIPTION("8250 serial probe module for F81216 based ports"
+	" (e.g. IEI Kino 690S1)");
+MODULE_LICENSE("GPL");
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -266,6 +266,17 @@ config SERIAL_8250_AU1X00
 	  say Y to this option. The driver can handle up to 4 serial ports,
 	  depending on the SOC. If unsure, say N.
 
+config SERIAL_8250_F81216
+	tristate "Manage suspend and restore of F81216 devices"
+	depends on SERIAL_8250 != n
+	help
+	  Say Y here if you have a board such as the IEI Kino 69OS1 with an
+	  F81216 SuperIO chip which requires Linux to restore the serial port
+	  configuration when you suspend and resume. If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called 8250_f81216.
+
 config SERIAL_8250_RM9K
 	bool "Support for MIPS RM9xxx integrated serial port"
 	depends on SERIAL_8250 != n && SERIAL_RM9000
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_SERIAL_8250_BOCA) += 8250_b
 obj-$(CONFIG_SERIAL_8250_EXAR_ST16C554) += 8250_exar_st16c554.o
 obj-$(CONFIG_SERIAL_8250_HUB6) += 8250_hub6.o
 obj-$(CONFIG_SERIAL_8250_MCA) += 8250_mca.o
+obj-$(CONFIG_SERIAL_8250_F81216) += 8250_f81216.o
 obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
