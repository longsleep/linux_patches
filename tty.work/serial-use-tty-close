serial: use tty_port_close

From: Alan Cox <alan@linux.intel.com>

We can now move to the closing helper but can't yet use the open helper

Signed-off-by: Alan Cox <alan@linux.intel.com>
---

 drivers/serial/serial_core.c |   60 ++++++++----------------------------------
 1 files changed, 11 insertions(+), 49 deletions(-)


diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 4e646c4..6d2290d 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -1277,48 +1277,20 @@ static void uart_close(struct tty_struct *tty, struct file *filp)
 
 	mutex_lock(&port->mutex);
 
-	if (tty_hung_up_p(filp))
+	/* FIXME: We can also migrate to drain_delay here */	
+	if (tty_port_close_start(port, tty, filp) == 0)
 		goto done;
 
-	if ((tty->count == 1) && (port->count != 1)) {
-		/*
-		 * Uh, oh.  tty->count is 1, which means that the tty
-		 * structure will be freed.  port->count should always
-		 * be one in these conditions.  If it's greater than
-		 * one, we've got real problems, since it means the
-		 * serial port won't be shutdown.
-		 */
-		printk(KERN_ERR "uart_close: bad serial port count; tty->count is 1, "
-		       "port->count is %d\n", port->count);
-		port->count = 1;
-	}
-	if (--port->count < 0) {
-		printk(KERN_ERR "uart_close: bad serial port count for %s: %d\n",
-		       tty->name, port->count);
-		port->count = 0;
-	}
-	if (port->count)
-		goto done;
-
-	/*
-	 * Now we wait for the transmit buffer to clear; and we notify
-	 * the line discipline to only process XON/XOFF characters by
-	 * setting tty->closing.
-	 */
-	tty->closing = 1;
-
-	if (port->closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, msecs_to_jiffies(port->closing_wait));
-
 	/*
 	 * At this point, we stop accepting input.  To do this, we
-	 * disable the receive line status interrupts.
+	 * disable the receive line status interrupts. This logic probably
+	 * ultimately belongs in the tty port layer
 	 */
 	if (port->flags & ASYNC_INITIALIZED) {
 		unsigned long flags;
-		spin_lock_irqsave(&port->lock, flags);
+		spin_lock_irqsave(&uport->lock, flags);
 		uport->ops->stop_rx(uport);
-		spin_unlock_irqrestore(&port->lock, flags);
+		spin_unlock_irqrestore(&uport->lock, flags);
 		/*
 		 * Before we drop DTR, make sure the UART transmitter
 		 * has completely drained; this is especially
@@ -1330,24 +1302,14 @@ static void uart_close(struct tty_struct *tty, struct file *filp)
 	uart_shutdown(state);
 	uart_flush_buffer(tty);
 
-	tty_ldisc_flush(tty);
-
-	tty->closing = 0;
+	tty_port_close_end(port, tty);
 	tty_port_tty_set(port, NULL);
 
-	if (port->blocked_open) {
-		if (port->close_delay)
-			msleep_interruptible(port->close_delay);
-	} else if (!uart_console(uport)) {
-		uart_change_pm(state, 3);
-	}
-
-	/*
-	 * Wake up anyone trying to open this port.
+	/* No users waiting - drop the power state
+	   FIXME: should be core tty port code ? 
 	 */
-	clear_bit(ASYNCB_NORMAL_ACTIVE, &port->flags);
-	wake_up_interruptible(&port->open_wait);
-
+	if(port->blocked_open == 0 && !uart_console(uport))
+		uart_change_pm(state, 3);
 done:
 	mutex_unlock(&port->mutex);
 }
