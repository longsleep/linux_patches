tty: clean up the USB open paths

From: Alan Cox <alan@linux.intel.com>

Extract the first time init logic and make it a helper which does its own
clean up

Remove the clean up we can just let ->shutdown handle when the device is
freed up

Signed-off-by: Alan Cox <alan@linux.intel.com>
---

 drivers/usb/serial/usb-serial.c |  126 +++++++++++++++++++++-------------------
 1 file changed, 68 insertions(+), 58 deletions(-)


--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -179,7 +179,59 @@ void usb_serial_put(struct usb_serial *s
 /*****************************************************************************
  * Driver tty interface functions
  *****************************************************************************/
-static int serial_open (struct tty_struct *tty, struct file *filp)
+
+/**
+ *	serial_activate		-	activate a USB serial port
+ *	@tty: the tty being activated
+ *	@port: the USB port being activated
+ *	@filp: File handle
+ *
+ *	Called to activate a USB serial port. The caller must hold port->mutex
+ *
+ *	On exit either
+ *		The port is activated and ASYNC_INITIALIZED is set
+ *		-	a module reference is held
+ *		-	an autopm reference is held
+ *	or
+ *		An error occurred
+ *		-	all references taken are dropped
+ */
+
+static int serial_activate(struct tty_struct *tty, struct usb_serial_port *port)
+{
+	struct usb_serial *serial = port->serial;
+	int retval;
+	/* lock this module before we call it
+	 * this may fail, which means we must bail out,
+	 * safe because we are called with BKL held */
+	if (!try_module_get(serial->type->driver.owner))
+		return -ENODEV;
+
+	mutex_lock(&serial->disc_mutex);
+	if (serial->disconnected)
+		retval = -ENODEV;
+	else
+		retval = usb_autopm_get_interface(serial->interface);
+	if (retval)
+		goto bailout_module_put;
+
+	/* only call the device specific open if this
+	 * is the first time the port is opened */
+	retval = serial->type->open(tty, port);
+	if (retval)
+		goto bailout_interface_put;
+	mutex_unlock(&serial->disc_mutex);
+	set_bit(ASYNCB_INITIALIZED, &port->port.flags);
+	return 0;
+bailout_interface_put:
+	usb_autopm_put_interface(serial->interface);
+bailout_module_put:
+	module_put(serial->type->driver.owner);
+	mutex_unlock(&serial->disc_mutex);
+	return retval;
+}
+
+static int serial_open(struct tty_struct *tty, struct file *filp)
 {
 	struct usb_serial *serial;
 	struct usb_serial_port *port;
@@ -189,12 +241,11 @@ static int serial_open (struct tty_struc
 
 	dbg("%s", __func__);
 
+	tty->driver_data = NULL;
 	/* get the serial object associated with this tty pointer */
 	serial = usb_serial_get_by_index(tty->index);
-	if (!serial) {
-		tty->driver_data = NULL;
+	if (!serial)
 		return -ENODEV;
-	}
 
 	mutex_lock(&serial->disc_mutex);
 	portNumber = tty->index - serial->minor;
@@ -226,53 +277,17 @@ static int serial_open (struct tty_struc
 	/* If the console is attached, the device is already open */
 	if (port->port.count == 1 && !port->console) {
 		first = 1;
-		/* lock this module before we call it
-		 * this may fail, which means we must bail out,
-		 * safe because we are called with BKL held */
-		if (!try_module_get(serial->type->driver.owner)) {
-			retval = -ENODEV;
-			goto bailout_mutex_unlock;
-		}
-
-		mutex_lock(&serial->disc_mutex);
-		if (serial->disconnected)
-			retval = -ENODEV;
-		else
-			retval = usb_autopm_get_interface(serial->interface);
-		if (retval)
-			goto bailout_module_put;
-
-		/* only call the device specific open if this
-		 * is the first time the port is opened */
-		retval = serial->type->open(tty, port);
-		if (retval)
-			goto bailout_interface_put;
-		mutex_unlock(&serial->disc_mutex);
-		set_bit(ASYNCB_INITIALIZED, &port->port.flags);
+		retval = serial_activate(tty, port);
 	}
 	mutex_unlock(&port->mutex);
 	/* Now do the correct tty layer semantics */
 	retval = tty_port_block_til_ready(&port->port, tty, filp);
-	if (retval == 0) {
-		if (!first)
-			usb_serial_put(serial);
-		return 0;
-	}
-	mutex_lock(&port->mutex);
-	if (first == 0)
-		goto bailout_mutex_unlock;
-	/* Undo the initial port actions */
-	mutex_lock(&serial->disc_mutex);
-bailout_interface_put:
-	usb_autopm_put_interface(serial->interface);
-bailout_module_put:
-	mutex_unlock(&serial->disc_mutex);
-	module_put(serial->type->driver.owner);
-bailout_mutex_unlock:
-	port->port.count = 0;
-	tty->driver_data = NULL;
-	tty_port_tty_set(&port->port, NULL);
-	mutex_unlock(&port->mutex);
+	if (!first)
+		usb_serial_put(serial);
+	/* Close will do any needed cleaning up and serial_do_free will
+	   finish the job */
+	return retval;
+
 bailout_port_put:
 	put_device(&port->dev);
 bailout_serial_put:
@@ -281,7 +296,7 @@ bailout_serial_put:
 }
 
 /**
- *	serial_do_down		-	shut down hardware
+ *	serial_shutdown		-	shut down hardware
  *	@port: port to shut down
  *
  *	Shut down a USB port unless it is the console. We never shut down the
@@ -289,8 +304,10 @@ bailout_serial_put:
  *
  *	Don't free any resources at this point
  */
-static void serial_do_down(struct usb_serial_port *port)
+static void serial_shutdown(struct tty_port *tport)
 {
+	struct usb_serial_port *port = container_of(tport,
+				struct usb_serial_port, port);
 	struct usb_serial_driver *drv = port->serial->type;
 
 	/* The console is magical, do not hang up the console hardware
@@ -341,24 +358,16 @@ static void serial_do_free(struct tty_st
 static void serial_close(struct tty_struct *tty, struct file *filp)
 {
 	struct usb_serial_port *port = tty->driver_data;
-
 	if (!port)
 		return;
 
 	dbg("%s - port %d", __func__, port->number);
-
-	if (tty_port_close_start(&port->port, tty, filp) == 0)
-		return;
-	serial_do_down(port);		
-	tty_port_close_end(&port->port, tty);
-	tty_port_tty_set(&port->port, NULL);
-
+	tty_port_close(&port->port, tty, filp);
 }
 
 static void serial_hangup(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty->driver_data;
-	serial_do_down(port);
 	tty_port_hangup(&port->port);
 	/* We must not free port yet - the USB serial layer depends on it's
 	   continued existence */
@@ -713,6 +722,7 @@ static void serial_dtr_rts(struct tty_po
 static const struct tty_port_operations serial_port_ops = {
 	.carrier_raised = serial_carrier_raised,
 	.dtr_rts = serial_dtr_rts,
+	.shutdown = serial_shutdown,
 };
 
 /**
