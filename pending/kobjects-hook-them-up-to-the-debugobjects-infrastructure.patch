From: Greg Kroah-Hartman <gregkh@suse.de>
Subject: kobjects: hook them up to the debugobjects infrastructure

I think this is right, but it's hard to tell...

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 lib/kobject.c |   53 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 53 insertions(+)

--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -18,8 +18,59 @@
 #include <linux/stat.h>
 #include <linux/slab.h>
 #include <linux/kallsyms.h>
+#include <linux/debugobjects.h>
 #include <asm-generic/sections.h>
 
+#ifdef CONFIG_DEBUG_OBJECTS
+static int kobject_fixup_init(void *addr, enum debug_obj_state state)
+{
+	struct kobject *kobj = addr;
+
+	switch (state) {
+	case ODEBUG_STATE_ACTIVE:
+		printk("kobject: '%s' (%p): is being initialized after "
+			"it was already active\n", kobject_name(kobj), kobj);
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static int kobject_fixup_destroy(void *addr, enum debug_obj_state state)
+{
+	struct kobject *kobj = addr;
+
+	switch (state) {
+	case ODEBUG_STATE_ACTIVE:
+		printk("kobject: '%s' (%p): is being destroyed yet it is "
+			"still active\n", kobject_name(kobj), kobj);
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static struct debug_obj_descr kobject_debug_descr = {
+	.name = "kobjects",
+	.fixup_init = kobject_fixup_init,
+	.fixup_destroy = kobject_fixup_destroy,
+};
+
+static void debug_kobject_init(struct kobject *kobj)
+{
+	debug_object_init(kobj, &kobject_debug_descr);
+}
+
+static void debug_kobject_destroy(struct kobject *kobj)
+{
+	debug_object_destroy(kobj, &kobject_debug_descr);
+}
+
+#else
+static inline void debug_kobject_init(struct kobject *kobj) { }
+static inline void debug_kobject_destroy(struct kobject *kobj) { }
+#endif
+
 #ifdef CONFIG_X86_32
 static int ptr_in_range(void *ptr, void *start, void *end)
 {
@@ -202,6 +253,7 @@ static void kobject_init_internal(struct
 {
 	if (!kobj)
 		return;
+	debug_kobject_init(kobj);
 	kref_init(&kobj->kref);
 	INIT_LIST_HEAD(&kobj->entry);
 	kobj->state_in_sysfs = 0;
@@ -599,6 +651,7 @@ static void kobject_cleanup(struct kobje
 	pr_debug("kobject: '%s' (%p): %s\n",
 		 kobject_name(kobj), kobj, __FUNCTION__);
 
+	debug_kobject_destroy(kobj);
 	if (t && !t->release)
 		pr_debug("kobject: '%s' (%p): does not have a release() "
 			 "function, it is broken and must be fixed.\n",
