From fd475839ee6f503b70a681e946845ce2d68c990b Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date: Tue, 19 Jun 2012 16:15:42 -0700
Subject: [PATCH] Staging: add CSR wifi module
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This consists of two modules, the driver, and a "helper" module that is
just a wrapper around common kernel functions.  The wrapper module will
be removed soon, but for now it's needed.

These files were based on the csr-linux-wifi-5.0.3-oss.tar.gz package
provided by CSR and Blue Giga, and is covered under the license
specified in the LICENSE.txt file (basically dual BSD and GPLv2).  The
files were flattened out of the deep directory mess they were originally
in, and a few EXPORT_SYMBOL_GPL() were added in order for everything to
link properly with the helper module setup.

Cc: Mikko Virkkilä <mikko.virkkila@bluegiga.com>
Cc: Lauri Hintsala <Lauri.Hintsala@bluegiga.com>
Cc: Riku Mettälä <riku.mettala@bluegiga.com>
Cc: Veli-Pekka Peltola <veli-pekka.peltola@bluegiga.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

---
 drivers/staging/csr/Kconfig                                         |    2 
 drivers/staging/csr/LICENSE.txt                                     |   39 
 drivers/staging/csr/Makefile                                        |   70 
 drivers/staging/csr/bh.c                                            |  391 
 drivers/staging/csr/csr_formatted_io.c                              |   29 
 drivers/staging/csr/csr_formatted_io.h                              |   25 
 drivers/staging/csr/csr_framework_ext.c                             |  213 
 drivers/staging/csr/csr_framework_ext.h                             |  354 
 drivers/staging/csr/csr_framework_ext_types.h                       |   65 
 drivers/staging/csr/csr_lib.h                                       |  189 
 drivers/staging/csr/csr_log.h                                       |  250 
 drivers/staging/csr/csr_log_configure.h                             |  135 
 drivers/staging/csr/csr_log_text.h                                  |  133 
 drivers/staging/csr/csr_macro.h                                     |  111 
 drivers/staging/csr/csr_msg_transport.h                             |   25 
 drivers/staging/csr/csr_msgconv.c                                   |  324 
 drivers/staging/csr/csr_msgconv.h                                   |  145 
 drivers/staging/csr/csr_panic.c                                     |   22 
 drivers/staging/csr/csr_panic.h                                     |   55 
 drivers/staging/csr/csr_pmem.c                                      |   51 
 drivers/staging/csr/csr_pmem.h                                      |  143 
 drivers/staging/csr/csr_prim_defs.h                                 |   64 
 drivers/staging/csr/csr_result.h                                    |   27 
 drivers/staging/csr/csr_sched.h                                     |  292 
 drivers/staging/csr/csr_sdio.h                                      |  732 +
 drivers/staging/csr/csr_serialize_primitive_types.c                 |  472 
 drivers/staging/csr/csr_time.c                                      |   71 
 drivers/staging/csr/csr_time.h                                      |  205 
 drivers/staging/csr/csr_types.h                                     |   93 
 drivers/staging/csr/csr_unicode.h                                   |  190 
 drivers/staging/csr/csr_utf16.c                                     | 1136 +
 drivers/staging/csr/csr_util.c                                      |  435 
 drivers/staging/csr/csr_util.h                                      |   75 
 drivers/staging/csr/csr_wifi_common.h                               |  109 
 drivers/staging/csr/csr_wifi_fsm.h                                  |  250 
 drivers/staging/csr/csr_wifi_fsm_event.h                            |   51 
 drivers/staging/csr/csr_wifi_fsm_types.h                            |  441 
 drivers/staging/csr/csr_wifi_hip_card.h                             |  114 
 drivers/staging/csr/csr_wifi_hip_card_sdio.c                        | 4128 ++++++
 drivers/staging/csr/csr_wifi_hip_card_sdio.h                        |  702 +
 drivers/staging/csr/csr_wifi_hip_card_sdio_intr.c                   | 2561 +++
 drivers/staging/csr/csr_wifi_hip_card_sdio_mem.c                    | 1713 ++
 drivers/staging/csr/csr_wifi_hip_chiphelper.c                       |  793 +
 drivers/staging/csr/csr_wifi_hip_chiphelper.h                       |  471 
 drivers/staging/csr/csr_wifi_hip_chiphelper_private.h               |  208 
 drivers/staging/csr/csr_wifi_hip_conversions.h                      |   81 
 drivers/staging/csr/csr_wifi_hip_download.c                         |  834 +
 drivers/staging/csr/csr_wifi_hip_dump.c                             |  872 +
 drivers/staging/csr/csr_wifi_hip_packing.c                          | 4804 +++++++
 drivers/staging/csr/csr_wifi_hip_send.c                             |  422 
 drivers/staging/csr/csr_wifi_hip_signals.c                          | 1313 ++
 drivers/staging/csr/csr_wifi_hip_signals.h                          |  137 
 drivers/staging/csr/csr_wifi_hip_sigs.h                             | 1425 ++
 drivers/staging/csr/csr_wifi_hip_ta_sampling.c                      |  535 
 drivers/staging/csr/csr_wifi_hip_ta_sampling.h                      |   75 
 drivers/staging/csr/csr_wifi_hip_udi.c                              |  268 
 drivers/staging/csr/csr_wifi_hip_unifi.h                            |  852 +
 drivers/staging/csr/csr_wifi_hip_unifi_signal_names.c               |   46 
 drivers/staging/csr/csr_wifi_hip_unifi_udi.h                        |   76 
 drivers/staging/csr/csr_wifi_hip_unifihw.h                          |   67 
 drivers/staging/csr/csr_wifi_hip_unifiversion.h                     |   38 
 drivers/staging/csr/csr_wifi_hip_xbv.c                              | 1075 +
 drivers/staging/csr/csr_wifi_hip_xbv.h                              |  127 
 drivers/staging/csr/csr_wifi_hostio_prim.h                          |   27 
 drivers/staging/csr/csr_wifi_lib.h                                  |  113 
 drivers/staging/csr/csr_wifi_msgconv.h                              |   60 
 drivers/staging/csr/csr_wifi_nme_ap_converter_init.h                |   49 
 drivers/staging/csr/csr_wifi_nme_ap_lib.h                           |  526 
 drivers/staging/csr/csr_wifi_nme_ap_prim.h                          |  504 
 drivers/staging/csr/csr_wifi_nme_ap_sef.c                           |   30 
 drivers/staging/csr/csr_wifi_nme_ap_sef.h                           |   31 
 drivers/staging/csr/csr_wifi_nme_ap_serialize.h                     |  105 
 drivers/staging/csr/csr_wifi_nme_converter_init.h                   |   46 
 drivers/staging/csr/csr_wifi_nme_lib.h                              | 1056 +
 drivers/staging/csr/csr_wifi_nme_prim.h                             | 1666 ++
 drivers/staging/csr/csr_wifi_nme_serialize.h                        |  177 
 drivers/staging/csr/csr_wifi_nme_task.h                             |   38 
 drivers/staging/csr/csr_wifi_private_common.h                       |   91 
 drivers/staging/csr/csr_wifi_result.h                               |   36 
 drivers/staging/csr/csr_wifi_router_converter_init.c                |   83 
 drivers/staging/csr/csr_wifi_router_converter_init.h                |   42 
 drivers/staging/csr/csr_wifi_router_ctrl_converter_init.c           |  132 
 drivers/staging/csr/csr_wifi_router_ctrl_converter_init.h           |   42 
 drivers/staging/csr/csr_wifi_router_ctrl_free_downstream_contents.c |   95 
 drivers/staging/csr/csr_wifi_router_ctrl_free_upstream_contents.c   |   81 
 drivers/staging/csr/csr_wifi_router_ctrl_lib.h                      | 1958 +++
 drivers/staging/csr/csr_wifi_router_ctrl_prim.h                     | 2018 +++
 drivers/staging/csr/csr_wifi_router_ctrl_sef.c                      |   43 
 drivers/staging/csr/csr_wifi_router_ctrl_sef.h                      |   56 
 drivers/staging/csr/csr_wifi_router_ctrl_serialize.c                | 2369 +++
 drivers/staging/csr/csr_wifi_router_ctrl_serialize.h                |  323 
 drivers/staging/csr/csr_wifi_router_free_downstream_contents.c      |   54 
 drivers/staging/csr/csr_wifi_router_free_upstream_contents.c        |   54 
 drivers/staging/csr/csr_wifi_router_lib.h                           |  429 
 drivers/staging/csr/csr_wifi_router_prim.h                          |  430 
 drivers/staging/csr/csr_wifi_router_sef.c                           |   19 
 drivers/staging/csr/csr_wifi_router_sef.h                           |   33 
 drivers/staging/csr/csr_wifi_router_serialize.c                     |  422 
 drivers/staging/csr/csr_wifi_router_serialize.h                     |   78 
 drivers/staging/csr/csr_wifi_router_task.h                          |   34 
 drivers/staging/csr/csr_wifi_router_transport.c                     |  210 
 drivers/staging/csr/csr_wifi_serialize_primitive_types.c            |  257 
 drivers/staging/csr/csr_wifi_sme_ap_lib.h                           |  656 +
 drivers/staging/csr/csr_wifi_sme_ap_prim.h                          |  904 +
 drivers/staging/csr/csr_wifi_sme_converter_init.c                   |  201 
 drivers/staging/csr/csr_wifi_sme_converter_init.h                   |   42 
 drivers/staging/csr/csr_wifi_sme_free_downstream_contents.c         |  181 
 drivers/staging/csr/csr_wifi_sme_free_upstream_contents.c           |  276 
 drivers/staging/csr/csr_wifi_sme_lib.h                              | 4282 ++++++
 drivers/staging/csr/csr_wifi_sme_prim.h                             | 6494 ++++++++++
 drivers/staging/csr/csr_wifi_sme_sef.c                              |   85 
 drivers/staging/csr/csr_wifi_sme_sef.h                              |  101 
 drivers/staging/csr/csr_wifi_sme_serialize.c                        | 5756 ++++++++
 drivers/staging/csr/csr_wifi_sme_serialize.h                        |  668 +
 drivers/staging/csr/csr_wifi_sme_task.h                             |   34 
 drivers/staging/csr/csr_wifi_vif_utils.h                            |  108 
 drivers/staging/csr/data_tx.c                                       |   57 
 drivers/staging/csr/drv.c                                           | 2150 +++
 drivers/staging/csr/firmware.c                                      |  398 
 drivers/staging/csr/indications.c                                   |   18 
 drivers/staging/csr/inet.c                                          |  106 
 drivers/staging/csr/init_hw.c                                       |  108 
 drivers/staging/csr/io.c                                            | 1146 +
 drivers/staging/csr/mlme.c                                          |  441 
 drivers/staging/csr/monitor.c                                       |  458 
 drivers/staging/csr/netdev.c                                        | 3902 ++++++
 drivers/staging/csr/os.c                                            |  479 
 drivers/staging/csr/putest.c                                        |  664 +
 drivers/staging/csr/sdio_emb.c                                      |  732 +
 drivers/staging/csr/sdio_events.c                                   |   87 
 drivers/staging/csr/sdio_mmc.c                                      | 1165 +
 drivers/staging/csr/sdio_stubs.c                                    |   82 
 drivers/staging/csr/sdioemb/cspi.h                                  |   62 
 drivers/staging/csr/sdioemb/csr_result.h                            |   16 
 drivers/staging/csr/sdioemb/csr_sdio.h                              |  711 +
 drivers/staging/csr/sdioemb/csr_sdio_lib.h                          |   30 
 drivers/staging/csr/sdioemb/csr_sdio_wdf.h                          |   22 
 drivers/staging/csr/sdioemb/csr_types.h                             |   53 
 drivers/staging/csr/sdioemb/libsdio.h                               |  404 
 drivers/staging/csr/sdioemb/linux.h                                 |   16 
 drivers/staging/csr/sdioemb/sdio.h                                  |  117 
 drivers/staging/csr/sdioemb/sdio_api.h                              |  408 
 drivers/staging/csr/sdioemb/sdio_bt_a.h                             |  143 
 drivers/staging/csr/sdioemb/sdio_cis.h                              |   27 
 drivers/staging/csr/sdioemb/sdio_csr.h                              |  134 
 drivers/staging/csr/sdioemb/slot_api.h                              |  313 
 drivers/staging/csr/sdioemb/slot_imx27.h                            |   86 
 drivers/staging/csr/sdioemb/slot_imx31.h                            |   86 
 drivers/staging/csr/sdioemb/slot_pxa27x.h                           |   70 
 drivers/staging/csr/sdioemb/slot_shc.h                              |  223 
 drivers/staging/csr/sdioemb/slot_ushc.h                             |  133 
 drivers/staging/csr/sdioemb/trace.h                                 |   19 
 drivers/staging/csr/sdioemb/uif.h                                   |   41 
 drivers/staging/csr/sdioemb/version.h                               |   11 
 drivers/staging/csr/sme_blocking.c                                  | 1468 ++
 drivers/staging/csr/sme_mgt.c                                       | 1018 +
 drivers/staging/csr/sme_native.c                                    |  591 
 drivers/staging/csr/sme_sys.c                                       | 2950 ++++
 drivers/staging/csr/sme_userspace.c                                 |  316 
 drivers/staging/csr/sme_userspace.h                                 |   38 
 drivers/staging/csr/sme_wext.c                                      | 3394 +++++
 drivers/staging/csr/ul_int.c                                        |  552 
 drivers/staging/csr/unifi_clients.h                                 |  129 
 drivers/staging/csr/unifi_config.h                                  |   34 
 drivers/staging/csr/unifi_dbg.c                                     |  110 
 drivers/staging/csr/unifi_event.c                                   |  794 +
 drivers/staging/csr/unifi_native.h                                  |  276 
 drivers/staging/csr/unifi_os.h                                      |  137 
 drivers/staging/csr/unifi_pdu_processing.c                          | 3728 +++++
 drivers/staging/csr/unifi_priv.h                                    | 1148 +
 drivers/staging/csr/unifi_sme.c                                     | 1164 +
 drivers/staging/csr/unifi_sme.h                                     |  236 
 drivers/staging/csr/unifi_wext.h                                    |  124 
 drivers/staging/csr/unifiio.h                                       |  400 
 drivers/staging/csr/wext_events.c                                   |  285 
 175 files changed, 98765 insertions(+), 1 deletion(-)

--- a/drivers/staging/csr/Kconfig
+++ b/drivers/staging/csr/Kconfig
@@ -1,6 +1,6 @@
 config CSR_WIFI
 	tristate "CSR wireless driver"
-	depends on PCI
+	depends on PCI && MMC
 	help
 	  Driver for the CSR wireless SDIO device.
 
--- /dev/null
+++ b/drivers/staging/csr/LICENSE.txt
@@ -0,0 +1,39 @@
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+Except as contained in this notice, the names of above-listed
+copyright holders and the names of any contributors shall not be used
+in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
+CONTRIBUTORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+Alternatively, this software may be distributed under the terms of the
+GNU General Public License ("GPL") version 2 as published
+by the Free Software Foundation.
+
+As a special exception, if other files instantiate templates or use
+macros or inline functions from this file, or you compile this file
+and link it with other works to produce a work based on this file,
+this file does not by itself cause the resulting work to be covered by
+the GNU General Public License. However the source code for this file
+must still be made available in accordance with section (3) of the GNU
+General Public License.
+
+This exception does not invalidate any other reasons why a work based
+on this file might be covered by the GNU General Public License.
--- a/drivers/staging/csr/Makefile
+++ b/drivers/staging/csr/Makefile
@@ -1 +1,71 @@
 obj-$(CONFIG_CSR_WIFI)	+= oska/
+
+ccflags-y	:= -DCSR_SME_USERSPACE -DCSR_SUPPORT_SME -DREMOTE_SYS_SAP -DCSR_WIFI_SECURITY_WAPI_ENABLE -DENABLE_SHUTDOWN
+
+obj-$(CONFIG_CSR_WIFI)	+= csr_wifi.o
+obj-$(CONFIG_CSR_WIFI)	+= csr_helper.o
+
+csr_wifi-y :=	bh.o				\
+		data_tx.o			\
+		drv.o				\
+		firmware.o			\
+		indications.o			\
+		inet.o				\
+		init_hw.o			\
+		io.o				\
+		monitor.o			\
+		netdev.o			\
+		os.o				\
+		putest.o			\
+		sdio_events.o			\
+		sdio_mmc.o			\
+		sdio_stubs.o			\
+		sme_blocking.o			\
+		ul_int.o			\
+		unifi_dbg.o			\
+		unifi_event.o			\
+		unifi_pdu_processing.o		\
+		unifi_sme.o			\
+		csr_formatted_io.o		\
+		csr_wifi_hip_card_sdio.o	\
+		csr_wifi_hip_card_sdio_intr.o	\
+		csr_wifi_hip_card_sdio_mem.o	\
+		csr_wifi_hip_chiphelper.o	\
+		csr_wifi_hip_download.o		\
+		csr_wifi_hip_dump.o		\
+		csr_wifi_hip_packing.o		\
+		csr_wifi_hip_send.o		\
+		csr_wifi_hip_signals.o		\
+		csr_wifi_hip_ta_sampling.o	\
+		csr_wifi_hip_udi.o		\
+		csr_wifi_hip_unifi_signal_names.o	\
+		csr_wifi_hip_xbv.o		\
+		csr_wifi_router_ctrl_sef.o	\
+		csr_wifi_router_sef.o		\
+		csr_wifi_router_transport.o	\
+		csr_wifi_sme_sef.o		\
+		csr_wifi_sme_converter_init.o	\
+		csr_wifi_sme_free_downstream_contents.o		\
+		csr_wifi_sme_free_upstream_contents.o		\
+		csr_wifi_sme_serialize.o			\
+		csr_wifi_router_ctrl_converter_init.o		\
+		csr_wifi_router_ctrl_free_downstream_contents.o	\
+		csr_wifi_router_ctrl_free_upstream_contents.o	\
+		csr_wifi_router_ctrl_serialize.o		\
+		csr_wifi_router_converter_init.o		\
+		csr_wifi_router_free_downstream_contents.o	\
+		csr_wifi_router_free_upstream_contents.o	\
+		csr_wifi_router_serialize.o			\
+		sme_mgt.o			\
+		sme_sys.o			\
+		sme_userspace.o
+
+csr_helper-y :=	csr_time.o			\
+		csr_util.o			\
+		csr_framework_ext.o		\
+		csr_pmem.o			\
+		csr_wifi_serialize_primitive_types.o	\
+		csr_serialize_primitive_types.o	\
+		csr_utf16.o			\
+		csr_msgconv.o			\
+		csr_panic.o
--- /dev/null
+++ b/drivers/staging/csr/bh.c
@@ -0,0 +1,391 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     bh.c
+ *
+ * PURPOSE:
+ *      Provides an implementation for the driver bottom-half.
+ *      It is part of the porting exercise in Linux.
+ *
+ * Copyright (C) 2005-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "unifi_priv.h"
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_start_thread
+ *
+ *      Helper function to start a new thread.
+ *
+ *  Arguments:
+ *      priv            Pointer to OS driver structure for the device.
+ *      thread          Pointer to the thread object
+ *      func            The thread function
+ *
+ *  Returns:
+ *      0 on success or else a Linux error code.
+ * ---------------------------------------------------------------------------
+ */
+int
+uf_start_thread(unifi_priv_t *priv, struct uf_thread *thread, int (*func)(void *))
+{
+    if (thread->thread_task != NULL) {
+        unifi_error(priv, "%s thread already started\n", thread->name);
+        return 0;
+    }
+
+    /* Start the kernel thread that handles all h/w accesses. */
+    thread->thread_task = kthread_run(func, priv, "%s", thread->name);
+    if (IS_ERR(thread->thread_task)) {
+        return PTR_ERR(thread->thread_task);
+    }
+
+    /* Module parameter overides the thread priority */
+    if (bh_priority != -1) {
+        if (bh_priority >= 0 && bh_priority <= MAX_RT_PRIO) {
+            struct sched_param param;
+            priv->bh_thread.prio = bh_priority;
+            unifi_trace(priv, UDBG1, "%s thread (RT) priority = %d\n",
+                        thread->name, bh_priority);
+            param.sched_priority = bh_priority;
+            sched_setscheduler(thread->thread_task, SCHED_FIFO, &param);
+        } else if (bh_priority > MAX_RT_PRIO && bh_priority <= MAX_PRIO) {
+            priv->bh_thread.prio = bh_priority;
+            unifi_trace(priv, UDBG1, "%s thread priority = %d\n",
+                        thread->name, PRIO_TO_NICE(bh_priority));
+            set_user_nice(thread->thread_task, PRIO_TO_NICE(bh_priority));
+        } else {
+            priv->bh_thread.prio = DEFAULT_PRIO;
+            unifi_warning(priv, "%s thread unsupported (%d) priority\n",
+                          thread->name, bh_priority);
+        }
+    } else {
+        priv->bh_thread.prio = DEFAULT_PRIO;
+    }
+    unifi_trace(priv, UDBG2, "Started %s thread\n", thread->name);
+
+    return 0;
+} /* uf_start_thread() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_stop_thread
+ *
+ *      Helper function to stop a thread.
+ *
+ *  Arguments:
+ *      priv            Pointer to OS driver structure for the device.
+ *      thread          Pointer to the thread object
+ *
+ *  Returns:
+ *
+ * ---------------------------------------------------------------------------
+ */
+    void
+uf_stop_thread(unifi_priv_t *priv, struct uf_thread *thread)
+{
+    if (!thread->thread_task) {
+        unifi_notice(priv, "%s thread is already stopped\n", thread->name);
+        return;
+    }
+
+    unifi_trace(priv, UDBG2, "Stopping %s thread\n", thread->name);
+
+    kthread_stop(thread->thread_task);
+    thread->thread_task = NULL;
+
+} /* uf_stop_thread() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_wait_for_thread_to_stop
+ *
+ *      Helper function to wait until a thread is stopped.
+ *
+ *  Arguments:
+ *      priv    Pointer to OS driver structure for the device.
+ *
+ *  Returns:
+ *
+ * ---------------------------------------------------------------------------
+ */
+    void
+uf_wait_for_thread_to_stop(unifi_priv_t *priv, struct uf_thread *thread)
+{
+    /*
+     * kthread_stop() cannot handle the thread exiting while
+     * kthread_should_stop() is false, so sleep until kthread_stop()
+     * wakes us up.
+     */
+    unifi_trace(priv, UDBG2, "%s waiting for the stop signal.\n", thread->name);
+    set_current_state(TASK_INTERRUPTIBLE);
+    if (!kthread_should_stop()) {
+        unifi_trace(priv, UDBG2, "%s schedule....\n", thread->name);
+        schedule();
+    }
+
+    thread->thread_task = NULL;
+    unifi_trace(priv, UDBG2, "%s exiting....\n", thread->name);
+} /* uf_wait_for_thread_to_stop() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  handle_bh_error
+ *
+ *      This function reports an error returned from the HIP core bottom-half.
+ *      Normally, implemented during the porting exercise, passing the error
+ *      to the SME using unifi_sys_wifi_off_ind().
+ *      The SME will try to reset the device and go through
+ *      the initialisation of the UniFi.
+ *
+ *  Arguments:
+ *      priv            Pointer to OS driver structure for the device.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+    static void
+handle_bh_error(unifi_priv_t *priv)
+{
+    u8 conf_param = CONFIG_IND_ERROR;
+    CsrUint8 interfaceTag = 0; /* used as a loop counter */
+
+
+    /* Block unifi_run_bh() until the error has been handled. */
+    priv->bh_thread.block_thread = 1;
+
+    /* Consider UniFi to be uninitialised */
+    priv->init_progress = UNIFI_INIT_NONE;
+
+    /* Stop the network traffic */
+    for( interfaceTag =0; interfaceTag <CSR_WIFI_NUM_INTERFACES;interfaceTag ++) {
+        netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+        if (interfacePriv->netdev_registered == 1) {
+            netif_carrier_off(priv->netdev[interfaceTag]);
+        }
+    }
+
+#ifdef CSR_NATIVE_LINUX
+    /* Force any client waiting on an mlme_wait_for_reply() to abort. */
+    uf_abort_mlme(priv);
+
+    /* Cancel any pending workqueue tasks */
+    flush_workqueue(priv->unifi_workqueue);
+
+#endif /* CSR_NATIVE_LINUX */
+
+    unifi_error(priv, "handle_bh_error: fatal error is reported to the SME.\n");
+    /* Notify the clients (SME or unifi_manager) for the error. */
+    ul_log_config_ind(priv, &conf_param, sizeof(u8));
+
+} /* handle_bh_error() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  bh_thread_function
+ *
+ *      All hardware access happens in this thread.
+ *      This means there is no need for locks on the hardware and we don't need
+ *      to worry about reentrancy with the SDIO library.
+ *      Provides and example implementation on how to call unifi_bh(), which
+ *      is part of the HIP core API.
+ *
+ *      It processes the events generated by unifi_run_bh() to serialise calls
+ *      to unifi_bh(). It also demonstrates how the timeout parameter passed in
+ *      and returned from unifi_bh() needs to be handled.
+ *
+ *  Arguments:
+ *      arg             Pointer to OS driver structure for the device.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *      When the bottom half of the driver needs to process signals, events,
+ *      or simply the host status (i.e sleep mode), it invokes unifi_run_bh().
+ *      Since we need all SDIO transaction to be in a single thread, the
+ *      unifi_run_bh() will wake up this thread to process it.
+ *
+ * ---------------------------------------------------------------------------
+ */
+static int
+bh_thread_function(void *arg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)arg;
+    CsrResult csrResult;
+    long ret;
+    CsrUint32 timeout, t;
+    struct uf_thread *this_thread;
+
+    unifi_trace(priv, UDBG2, "bh_thread_function starting\n");
+
+    this_thread = &priv->bh_thread;
+
+    t = timeout = 0;
+    while (!kthread_should_stop()) {
+        /* wait until an error occurs, or we need to process something. */
+        unifi_trace(priv, UDBG3, "bh_thread goes to sleep.\n");
+
+        if (timeout > 0) {
+            /* Convert t in ms to jiffies */
+            t = msecs_to_jiffies(timeout);
+            ret = wait_event_interruptible_timeout(this_thread->wakeup_q,
+                    (this_thread->wakeup_flag && !this_thread->block_thread) ||
+                    kthread_should_stop(),
+                    t);
+            timeout = (ret > 0) ? jiffies_to_msecs(ret) : 0;
+        } else {
+            ret = wait_event_interruptible(this_thread->wakeup_q,
+                    (this_thread->wakeup_flag && !this_thread->block_thread) ||
+                    kthread_should_stop());
+        }
+
+        if (kthread_should_stop()) {
+            unifi_trace(priv, UDBG2, "bh_thread: signalled to exit\n");
+            break;
+        }
+
+        if (ret < 0) {
+            unifi_notice(priv,
+                    "bh_thread: wait_event returned %d, thread will exit\n",
+                    ret);
+            uf_wait_for_thread_to_stop(priv, this_thread);
+            break;
+        }
+
+        this_thread->wakeup_flag = 0;
+
+        unifi_trace(priv, UDBG3, "bh_thread calls unifi_bh().\n");
+
+        CsrSdioClaim(priv->sdio);
+        csrResult = unifi_bh(priv->card, &timeout);
+        if(csrResult != CSR_RESULT_SUCCESS) {
+            if (csrResult == CSR_WIFI_HIP_RESULT_NO_DEVICE) {
+                CsrSdioRelease(priv->sdio);
+                uf_wait_for_thread_to_stop(priv, this_thread);
+                break;
+            }
+            /* Errors must be delivered to the error task */
+            handle_bh_error(priv);
+        }
+        CsrSdioRelease(priv->sdio);
+    }
+
+    /*
+     * I would normally try to call csr_sdio_remove_irq() here to make sure
+     * that we do not get any interrupts while this thread is not running.
+     * However, the MMC/SDIO driver tries to kill its' interrupt thread.
+     * The kernel threads implementation does not allow to kill threads
+     * from a signalled to stop thread.
+     * So, instead call csr_sdio_linux_remove_irq() always after calling
+     * uf_stop_thread() to kill this thread.
+     */
+
+    unifi_trace(priv, UDBG2, "bh_thread exiting....\n");
+    return 0;
+} /* bh_thread_function() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_init_bh
+ *
+ *      Helper function to start the bottom half of the driver.
+ *      All we need to do here is start the I/O bh thread.
+ *
+ *  Arguments:
+ *      priv            Pointer to OS driver structure for the device.
+ *
+ *  Returns:
+ *      0 on success or else a Linux error code.
+ * ---------------------------------------------------------------------------
+ */
+    int
+uf_init_bh(unifi_priv_t *priv)
+{
+    int r;
+
+    /* Enable mlme interface. */
+    priv->io_aborted = 0;
+
+
+    /* Start the BH thread */
+    r = uf_start_thread(priv, &priv->bh_thread, bh_thread_function);
+    if (r) {
+        unifi_error(priv,
+                "uf_init_bh: failed to start the BH thread.\n");
+        return r;
+    }
+
+    /* Allow interrupts */
+    r = csr_sdio_linux_install_irq(priv->sdio);
+    if (r) {
+        unifi_error(priv,
+                "uf_init_bh: failed to install the IRQ.\n");
+
+        uf_stop_thread(priv, &priv->bh_thread);
+    }
+
+    return r;
+} /* uf_init_bh() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_run_bh
+ *
+ *      Part of the HIP core lib API, implemented in the porting exercise.
+ *      The bottom half of the driver calls this function when
+ *      it wants to process anything that requires access to unifi.
+ *      We need to call unifi_bh() which in this implementation is done
+ *      by waking up the I/O thread.
+ *
+ *  Arguments:
+ *      ospriv          Pointer to OS driver structure for the device.
+ *
+ *  Returns:
+ *      0 on success or else a Linux error code.
+ *
+ *  Notes:
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_run_bh(void *ospriv)
+{
+    unifi_priv_t *priv = ospriv;
+
+    /*
+     * If an error has occured, we discard silently all messages from the bh
+     * until the error has been processed and the unifi has been reinitialised.
+     */
+    if (priv->bh_thread.block_thread == 1) {
+        unifi_trace(priv, UDBG3, "unifi_run_bh: discard message.\n");
+        /*
+         * Do not try to acknowledge a pending interrupt here.
+         * This function is called by unifi_send_signal() which in turn can be
+         * running in an atomic or 'disabled irq' level if a signal is sent
+         * from a workqueue task (i.e multicass addresses set).
+         * We can not hold the SDIO lock because it might sleep.
+         */
+        return CSR_RESULT_FAILURE;
+    }
+
+    priv->bh_thread.wakeup_flag = 1;
+    /* wake up I/O thread */
+    wake_up_interruptible(&priv->bh_thread.wakeup_q);
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_run_bh() */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_formatted_io.c
@@ -0,0 +1,29 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+#include "csr_formatted_io.h"
+#include "csr_util.h"
+
+CsrInt32 CsrSnprintf(CsrCharString *dest, CsrSize n, const CsrCharString *fmt, ...)
+{
+    CsrInt32 r;
+    va_list args;
+    va_start(args, fmt);
+    r = CsrVsnprintf(dest, n, fmt, args);
+    va_end(args);
+
+    if (dest && (n > 0))
+    {
+        dest[n - 1] = '\0';
+    }
+
+    return r;
+}
--- /dev/null
+++ b/drivers/staging/csr/csr_formatted_io.h
@@ -0,0 +1,25 @@
+#ifndef CSR_FORMATTED_IO_H__
+#define CSR_FORMATTED_IO_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "csr_types.h"
+
+CsrInt32 CsrSnprintf(CsrCharString *dest, CsrSize n, const CsrCharString *fmt, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_framework_ext.c
@@ -0,0 +1,213 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+#include <linux/slab.h>
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 19)
+#include <linux/freezer.h>
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27)
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+
+#include <linux/bitops.h>
+
+#include "csr_types.h"
+#include "csr_framework_ext.h"
+#include "csr_panic.h"
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMutexCreate
+ *
+ *  DESCRIPTION
+ *      Create a mutex and return a handle to the created mutex.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS           in case of success
+ *          CSR_FE_RESULT_NO_MORE_MUTEXES   in case of out of mutex resources
+ *          CSR_FE_RESULT_INVALID_POINTER   in case the mutexHandle pointer is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrMutexCreate(CsrMutexHandle *mutexHandle)
+{
+    if (mutexHandle == NULL)
+    {
+        return CSR_FE_RESULT_INVALID_POINTER;
+    }
+
+    sema_init(mutexHandle, 1);
+
+    return CSR_RESULT_SUCCESS;
+}
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMutexDestroy
+ *
+ *  DESCRIPTION
+ *      Destroy the previously created mutex.
+ *
+ *  RETURNS
+ *      void
+ *
+ *----------------------------------------------------------------------------*/
+void CsrMutexDestroy(CsrMutexHandle *mutexHandle)
+{
+}
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMutexLock
+ *
+ *  DESCRIPTION
+ *      Lock the mutex refered to by the provided handle.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS           in case of success
+ *          CSR_FE_RESULT_INVALID_HANDLE    in case the mutexHandle is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrMutexLock(CsrMutexHandle *mutexHandle)
+{
+    if (mutexHandle == NULL)
+    {
+        return CSR_FE_RESULT_INVALID_POINTER;
+    }
+
+    if (down_interruptible(mutexHandle))
+    {
+        CsrPanic(CSR_TECH_FW, CSR_PANIC_FW_UNEXPECTED_VALUE, "CsrMutexLock Failed");
+        return CSR_FE_RESULT_INVALID_POINTER;
+    }
+
+    return CSR_RESULT_SUCCESS;
+}
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMutexUnlock
+ *
+ *  DESCRIPTION
+ *      Unlock the mutex refered to by the provided handle.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS           in case of success
+ *          CSR_FE_RESULT_INVALID_HANDLE    in case the mutexHandle is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrMutexUnlock(CsrMutexHandle *mutexHandle)
+{
+    if (mutexHandle == NULL)
+    {
+        return CSR_FE_RESULT_INVALID_POINTER;
+    }
+
+    up(mutexHandle);
+
+    return CSR_RESULT_SUCCESS;
+}
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrThreadSleep
+ *
+ *  DESCRIPTION
+ *      Sleep for a given period.
+ *
+ *  RETURNS
+ *      void
+ *
+ *----------------------------------------------------------------------------*/
+void CsrThreadSleep(CsrUint16 sleepTimeInMs)
+{
+    unsigned long t;
+
+    /* Convert t in ms to jiffies and round up */
+    t = ((sleepTimeInMs * HZ) + 999) / 1000;
+    schedule_timeout_uninterruptible(t);
+}
+EXPORT_SYMBOL_GPL(CsrThreadSleep);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMemCalloc
+ *
+ *  DESCRIPTION
+ *      Allocate dynamic memory of a given size calculated as the
+ *      numberOfElements times the elementSize.
+ *
+ *  RETURNS
+ *      Pointer to allocated memory, or NULL in case of failure.
+ *      Allocated memory is zero initialised.
+ *
+ *----------------------------------------------------------------------------*/
+void *CsrMemCalloc(CsrSize numberOfElements, CsrSize elementSize)
+{
+    void *buf;
+    size_t size;
+
+    size = numberOfElements * elementSize;
+
+    buf = kmalloc(size, GFP_KERNEL);
+    if (buf != NULL)
+    {
+        memset(buf, 0, size);
+    }
+
+    return buf;
+}
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMemAlloc
+ *
+ *  DESCRIPTION
+ *      Allocate dynamic memory of a given size.
+ *
+ *  RETURNS
+ *      Pointer to allocated memory, or NULL in case of failure.
+ *      Allocated memory is not initialised.
+ *
+ *----------------------------------------------------------------------------*/
+void *CsrMemAlloc(CsrSize size)
+{
+    return kmalloc(size, GFP_KERNEL);
+}
+EXPORT_SYMBOL_GPL(CsrMemAlloc);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMemFree
+ *
+ *  DESCRIPTION
+ *      Free dynamic allocated memory.
+ *
+ *  RETURNS
+ *      void
+ *
+ *----------------------------------------------------------------------------*/
+void CsrMemFree(void *pointer)
+{
+    kfree(pointer);
+}
+EXPORT_SYMBOL_GPL(CsrMemFree);
--- /dev/null
+++ b/drivers/staging/csr/csr_framework_ext.h
@@ -0,0 +1,354 @@
+#ifndef CSR_FRAMEWORK_EXT_H__
+#define CSR_FRAMEWORK_EXT_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+#include "csr_result.h"
+#include "csr_framework_ext_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Result codes */
+#define CSR_FE_RESULT_NO_MORE_EVENTS    ((CsrResult) 0x0001)
+#define CSR_FE_RESULT_INVALID_POINTER   ((CsrResult) 0x0002)
+#define CSR_FE_RESULT_INVALID_HANDLE    ((CsrResult) 0x0003)
+#define CSR_FE_RESULT_NO_MORE_MUTEXES   ((CsrResult) 0x0004)
+#define CSR_FE_RESULT_TIMEOUT           ((CsrResult) 0x0005)
+#define CSR_FE_RESULT_NO_MORE_THREADS   ((CsrResult) 0x0006)
+
+/* Thread priorities */
+#define CSR_THREAD_PRIORITY_HIGHEST     ((CsrUint16) 0)
+#define CSR_THREAD_PRIORITY_HIGH        ((CsrUint16) 1)
+#define CSR_THREAD_PRIORITY_NORMAL      ((CsrUint16) 2)
+#define CSR_THREAD_PRIORITY_LOW         ((CsrUint16) 3)
+#define CSR_THREAD_PRIORITY_LOWEST      ((CsrUint16) 4)
+
+#define CSR_EVENT_WAIT_INFINITE         ((CsrUint16) 0xFFFF)
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrEventCreate
+ *
+ *  DESCRIPTION
+ *      Creates an event and returns a handle to the created event.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS          in case of success
+ *          CSR_FE_RESULT_NO_MORE_EVENTS   in case of out of event resources
+ *          CSR_FE_RESULT_INVALID_POINTER  in case the eventHandle pointer is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrEventCreate(CsrEventHandle *eventHandle);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrEventWait
+ *
+ *  DESCRIPTION
+ *      Wait fore one or more of the event bits to be set.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS              in case of success
+ *          CSR_FE_RESULT_TIMEOUT              in case of timeout
+ *          CSR_FE_RESULT_INVALID_HANDLE       in case the eventHandle is invalid
+ *          CSR_FE_RESULT_INVALID_POINTER      in case the eventBits pointer is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrEventWait(CsrEventHandle *eventHandle, CsrUint16 timeoutInMs, CsrUint32 *eventBits);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrEventSet
+ *
+ *  DESCRIPTION
+ *      Set an event.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS              in case of success
+ *          CSR_FE_RESULT_INVALID_HANDLE       in case the eventHandle is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrEventSet(CsrEventHandle *eventHandle, CsrUint32 eventBits);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrEventDestroy
+ *
+ *  DESCRIPTION
+ *      Destroy the event associated.
+ *
+ *  RETURNS
+ *      void
+ *
+ *----------------------------------------------------------------------------*/
+void CsrEventDestroy(CsrEventHandle *eventHandle);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMutexCreate
+ *
+ *  DESCRIPTION
+ *      Create a mutex and return a handle to the created mutex.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS           in case of success
+ *          CSR_FE_RESULT_NO_MORE_MUTEXES   in case of out of mutex resources
+ *          CSR_FE_RESULT_INVALID_POINTER   in case the mutexHandle pointer is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrMutexCreate(CsrMutexHandle *mutexHandle);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMutexLock
+ *
+ *  DESCRIPTION
+ *      Lock the mutex refered to by the provided handle.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS           in case of success
+ *          CSR_FE_RESULT_INVALID_HANDLE    in case the mutexHandle is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrMutexLock(CsrMutexHandle *mutexHandle);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMutexUnlock
+ *
+ *  DESCRIPTION
+ *      Unlock the mutex refered to by the provided handle.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS           in case of success
+ *          CSR_FE_RESULT_INVALID_HANDLE    in case the mutexHandle is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrMutexUnlock(CsrMutexHandle *mutexHandle);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMutexDestroy
+ *
+ *  DESCRIPTION
+ *      Destroy the previously created mutex.
+ *
+ *  RETURNS
+ *      void
+ *
+ *----------------------------------------------------------------------------*/
+void CsrMutexDestroy(CsrMutexHandle *mutexHandle);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrGlobalMutexLock
+ *
+ *  DESCRIPTION
+ *      Lock the global mutex. The global mutex is a single pre-initialised
+ *      shared mutex, spinlock or similar that does not need to be created prior
+ *      to use. The limitation is that there is only one single lock shared
+ *      between all code. Consequently, it must only be used very briefly to
+ *      either protect simple one-time initialisation or to protect the creation
+ *      of a dedicated mutex by calling CsrMutexCreate.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrGlobalMutexLock(void);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrGlobalMutexUnlock
+ *
+ *  DESCRIPTION
+ *      Unlock the global mutex.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrGlobalMutexUnlock(void);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrThreadCreate
+ *
+ *  DESCRIPTION
+ *      Create thread function and return a handle to the created thread.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS           in case of success
+ *          CSR_FE_RESULT_NO_MORE_THREADS   in case of out of thread resources
+ *          CSR_FE_RESULT_INVALID_POINTER   in case one of the supplied pointers is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrThreadCreate(void (*threadFunction)(void *pointer), void *pointer,
+    CsrUint32 stackSize, CsrUint16 priority,
+    const CsrCharString *threadName, CsrThreadHandle *threadHandle);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrThreadGetHandle
+ *
+ *  DESCRIPTION
+ *      Return thread handle of calling thread.
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS             in case of success
+ *          CSR_FE_RESULT_INVALID_POINTER  in case the threadHandle pointer is invalid
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrThreadGetHandle(CsrThreadHandle *threadHandle);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrThreadEqual
+ *
+ *  DESCRIPTION
+ *      Compare thread handles
+ *
+ *  RETURNS
+ *      Possible values:
+ *          CSR_RESULT_SUCCESS             in case thread handles are identical
+ *          CSR_FE_RESULT_INVALID_POINTER  in case either threadHandle pointer is invalid
+ *          CSR_RESULT_FAILURE             otherwise
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrThreadEqual(CsrThreadHandle *threadHandle1, CsrThreadHandle *threadHandle2);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrThreadSleep
+ *
+ *  DESCRIPTION
+ *      Sleep for a given period.
+ *
+ *  RETURNS
+ *      void
+ *
+ *----------------------------------------------------------------------------*/
+void CsrThreadSleep(CsrUint16 sleepTimeInMs);
+
+#ifndef CSR_PMEM_DEBUG_ENABLE
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMemAlloc
+ *
+ *  DESCRIPTION
+ *      Allocate dynamic memory of a given size.
+ *
+ *  RETURNS
+ *      Pointer to allocated memory, or NULL in case of failure.
+ *      Allocated memory is not initialised.
+ *
+ *----------------------------------------------------------------------------*/
+#ifdef CSR_MEM_DEBUG
+void *CsrMemAllocDebug(CsrSize size,
+    const CsrCharString *file, CsrUint32 line);
+#define CsrMemAlloc(sz) CsrMemAllocDebug((sz), __FILE__, __LINE__)
+#else
+void *CsrMemAlloc(CsrSize size);
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMemCalloc
+ *
+ *  DESCRIPTION
+ *      Allocate dynamic memory of a given size calculated as the
+ *      numberOfElements times the elementSize.
+ *
+ *  RETURNS
+ *      Pointer to allocated memory, or NULL in case of failure.
+ *      Allocated memory is zero initialised.
+ *
+ *----------------------------------------------------------------------------*/
+#ifdef CSR_MEM_DEBUG
+void *CsrMemCallocDebug(CsrSize numberOfElements, CsrSize elementSize,
+    const CsrCharString *file, CsrUint32 line);
+#define CsrMemCalloc(cnt, sz) CsrMemAllocDebug((cnt), (sz), __FILE__, __LINE__)
+#else
+void *CsrMemCalloc(CsrSize numberOfElements, CsrSize elementSize);
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMemFree
+ *
+ *  DESCRIPTION
+ *      Free dynamic allocated memory.
+ *
+ *  RETURNS
+ *      void
+ *
+ *----------------------------------------------------------------------------*/
+void CsrMemFree(void *pointer);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMemAllocDma
+ *
+ *  DESCRIPTION
+ *      Allocate dynamic memory suitable for DMA transfers.
+ *
+ *  RETURNS
+ *      Pointer to allocated memory, or NULL in case of failure.
+ *      Allocated memory is not initialised.
+ *
+ *----------------------------------------------------------------------------*/
+#ifdef CSR_MEM_DEBUG
+void *CsrMemAllocDmaDebug(CsrSize size,
+    const CsrCharString *file, CsrUint32 line);
+#define CsrMemAllocDma(sz) CsrMemAllocDmaDebug((sz), __FILE__, __LINE__)
+#else
+void *CsrMemAllocDma(CsrSize size);
+#endif
+
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrMemFreeDma
+ *
+ *  DESCRIPTION
+ *      Free dynamic memory allocated by CsrMemAllocDma.
+ *
+ *  RETURNS
+ *      void
+ *
+ *----------------------------------------------------------------------------*/
+void CsrMemFreeDma(void *pointer);
+#else
+
+#include "csr_pmem.h"
+
+#define CsrMemAlloc(size) CsrPmemDebugAlloc(size, CSR_PMEM_DEBUG_TYPE_MEM_ALLOC, __FILE__, __LINE__)
+
+#define CsrMemCalloc(numberOfElements, elementSize) CsrPmemDebugAlloc((numberOfElements * elementSize), CSR_PMEM_DEBUG_TYPE_MEM_CALLOC, __FILE__, __LINE__)
+
+#define CsrMemFree(ptr) CsrPmemDebugFree(ptr,CSR_PMEM_DEBUG_TYPE_MEM_ALLOC,  __FILE__, __LINE__)
+
+#define CsrMemAllocDma(size) CsrPmemDebugAlloc(size, CSR_PMEM_DEBUG_TYPE_MEM_ALLOC_DMA, __FILE__, __LINE__)
+
+#define CsrMemFreeDma(ptr) CsrPmemDebugFree(ptr, CSR_PMEM_DEBUG_TYPE_MEM_ALLOC_DMA, __FILE__, __LINE__)
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_framework_ext_types.h
@@ -0,0 +1,65 @@
+#ifndef CSR_FRAMEWORK_EXT_TYPES_H__
+#define CSR_FRAMEWORK_EXT_TYPES_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+
+#ifdef __KERNEL__
+#include <linux/kthread.h>
+#include <linux/semaphore.h>
+#else
+#include <pthread.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#ifdef __KERNEL__
+
+struct CsrThread
+{
+    struct task_struct *thread_task;
+    char                name[16];
+};
+
+struct CsrEvent
+{
+    /* wait_queue for waking the kernel thread */
+    wait_queue_head_t wakeup_q;
+    unsigned int      wakeup_flag;
+};
+
+typedef struct CsrEvent CsrEventHandle;
+typedef struct semaphore CsrMutexHandle;
+typedef struct CsrThread CsrThreadHandle;
+
+#else /* __KERNEL __ */
+
+struct CsrEvent
+{
+    pthread_cond_t  event;
+    pthread_mutex_t mutex;
+    CsrUint32       eventBits;
+};
+
+typedef struct CsrEvent CsrEventHandle;
+typedef pthread_mutex_t CsrMutexHandle;
+typedef pthread_t CsrThreadHandle;
+
+#endif /* __KERNEL__ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_lib.h
@@ -0,0 +1,189 @@
+#ifndef CSR_LIB_H__
+#define CSR_LIB_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+    CsrPrim type;
+} CsrEvent;
+
+/*----------------------------------------------------------------------------*
+ *  CsrEvent_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrEvent
+ *
+ *----------------------------------------------------------------------------*/
+CsrEvent *CsrEvent_struct(CsrUint16 primtype, CsrUint16 msgtype);
+
+typedef struct
+{
+    CsrPrim  type;
+    CsrUint8 value;
+} CsrEventCsrUint8;
+
+/*----------------------------------------------------------------------------*
+ *  CsrEventCsrUint8_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrEventCsrUint8
+ *
+ *----------------------------------------------------------------------------*/
+CsrEventCsrUint8 *CsrEventCsrUint8_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrUint8 value);
+
+typedef struct
+{
+    CsrPrim   type;
+    CsrUint16 value;
+} CsrEventCsrUint16;
+
+/*----------------------------------------------------------------------------*
+ *  CsrEventCsrUint16_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrEventCsrUint16
+ *
+ *----------------------------------------------------------------------------*/
+CsrEventCsrUint16 *CsrEventCsrUint16_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrUint16 value);
+
+typedef struct
+{
+    CsrPrim   type;
+    CsrUint16 value1;
+    CsrUint8  value2;
+} CsrEventCsrUint16CsrUint8;
+
+/*----------------------------------------------------------------------------*
+ *  CsrEventCsrUint16CsrUint8_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrEventCsrUint16CsrUint8
+ *
+ *----------------------------------------------------------------------------*/
+CsrEventCsrUint16CsrUint8 *CsrEventCsrUint16CsrUint8_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrUint16 value1, CsrUint8 value2);
+
+typedef struct
+{
+    CsrPrim   type;
+    CsrUint16 value1;
+    CsrUint16 value2;
+} CsrEventCsrUint16CsrUint16;
+
+/*----------------------------------------------------------------------------*
+ *  CsrEventCsrUint16CsrUint16_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrEventCsrUint16CsrUint16
+ *
+ *----------------------------------------------------------------------------*/
+CsrEventCsrUint16CsrUint16 *CsrEventCsrUint16CsrUint16_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrUint16 value1, CsrUint16 value2);
+
+typedef struct
+{
+    CsrPrim   type;
+    CsrUint16 value1;
+    CsrUint32 value2;
+} CsrEventCsrUint16CsrUint32;
+
+/*----------------------------------------------------------------------------*
+ *  CsrEventCsrUint16_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrEventCsrUint16
+ *
+ *----------------------------------------------------------------------------*/
+CsrEventCsrUint16CsrUint32 *CsrEventCsrUint16CsrUint32_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrUint16 value1, CsrUint32 value2);
+
+typedef struct
+{
+    CsrPrim        type;
+    CsrUint16      value1;
+    CsrCharString *value2;
+} CsrEventCsrUint16CsrCharString;
+
+/*----------------------------------------------------------------------------*
+ *  CsrEventCsrUint16CsrCharString_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrEventCsrUint16CsrCharString
+ *
+ *----------------------------------------------------------------------------*/
+CsrEventCsrUint16CsrCharString *CsrEventCsrUint16CsrCharString_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrUint16 value1, CsrCharString *value2);
+
+typedef struct
+{
+    CsrPrim   type;
+    CsrUint32 value;
+} CsrEventCsrUint32;
+
+/*----------------------------------------------------------------------------*
+ *  CsrEventCsrUint32_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrEventCsrUint32
+ *
+ *----------------------------------------------------------------------------*/
+CsrEventCsrUint32 *CsrEventCsrUint32_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrUint32 value);
+
+typedef struct
+{
+    CsrPrim   type;
+    CsrUint32 value1;
+    CsrUint16 value2;
+} CsrEventCsrUint32CsrUint16;
+
+/*----------------------------------------------------------------------------*
+ *  CsrEventCsrUint32CsrUint16_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrEventCsrUint32CsrUint16
+ *
+ *----------------------------------------------------------------------------*/
+CsrEventCsrUint32CsrUint16 *CsrEventCsrUint32CsrUint16_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrUint32 value1, CsrUint32 value2);
+
+typedef struct
+{
+    CsrPrim        type;
+    CsrUint32      value1;
+    CsrCharString *value2;
+} CsrEventCsrUint32CsrCharString;
+
+/*----------------------------------------------------------------------------*
+ *  CsrEventCsrUint32CsrCharString_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrEventCsrUint32CsrCharString
+ *
+ *----------------------------------------------------------------------------*/
+CsrEventCsrUint32CsrCharString *CsrEventCsrUint32CsrCharString_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrUint32 value1, CsrCharString *value2);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_LIB_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_log.h
@@ -0,0 +1,250 @@
+#ifndef CSR_LOG_H__
+#define CSR_LOG_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+#include "csr_sched.h"
+#include "csr_panic.h"
+#include "csr_prim_defs.h"
+#include "csr_msgconv.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Log filtering
+ */
+
+/*----------------------------------------------------*/
+/*  Filtering on environment specific log levels      */
+/*----------------------------------------------------*/
+typedef CsrUint32 CsrLogLevelEnvironment;
+#define CSR_LOG_LEVEL_ENVIRONMENT_OFF          ((CsrLogLevelEnvironment) 0x00000000) /* No environment data/events are logged */
+#define CSR_LOG_LEVEL_ENVIRONMENT_BCI_ACL      ((CsrLogLevelEnvironment) 0x00000001) /* BlueCore Channel Interface HCI Acl data are logged */
+#define CSR_LOG_LEVEL_ENVIRONMENT_BCI_HCI      ((CsrLogLevelEnvironment) 0x00000002) /* BlueCore Channel Interface HCI Cmd/Evt data are logged */
+#define CSR_LOG_LEVEL_ENVIRONMENT_BCI_SCO      ((CsrLogLevelEnvironment) 0x00000004) /* BlueCore Channel Interface HCI Sco data are logged */
+#define CSR_LOG_LEVEL_ENVIRONMENT_BCI_VENDOR   ((CsrLogLevelEnvironment) 0x00000008) /* BlueCore Channel Interface HCI Vendor specific data are logged (This includes BCCMD, HQ, VM etc) */
+#define CSR_LOG_LEVEL_ENVIRONMENT_TRANSPORTS   ((CsrLogLevelEnvironment) 0x00000010) /* Transport protocol data is logged (This includes transport protocols like BCSP, H4 etc.) */
+#define CSR_LOG_LEVEL_ENVIRONMENT_BGINT_REG    ((CsrLogLevelEnvironment) 0x00000020) /* Background Interrupt registration events are logged */
+#define CSR_LOG_LEVEL_ENVIRONMENT_BGINT_UNREG  ((CsrLogLevelEnvironment) 0x00000040) /* Background Interrupt unregistration events are logged */
+#define CSR_LOG_LEVEL_ENVIRONMENT_BGINT_SET    ((CsrLogLevelEnvironment) 0x00000080) /* Background Interrupt set events are logged */
+#define CSR_LOG_LEVEL_ENVIRONMENT_BGINT_START  ((CsrLogLevelEnvironment) 0x00000100) /* Background Interrupt start events are logged */
+#define CSR_LOG_LEVEL_ENVIRONMENT_BGINT_DONE   ((CsrLogLevelEnvironment) 0x00000200) /* Background Interrupt done events are logged */
+#define CSR_LOG_LEVEL_ENVIRONMENT_PROTO        ((CsrLogLevelEnvironment) 0x00000400) /* Transport protocol events are logged */
+#define CSR_LOG_LEVEL_ENVIRONMENT_PROTO_LOC    ((CsrLogLevelEnvironment) 0x00000800) /* The Location where the transport protocol event occured are logged NB: This is a supplement to CSR_LOG_LEVEL_ENVIRONMENT_PROTO, it has no effect without it */
+/* The bit masks between here are reserved for future usage */
+#define CSR_LOG_LEVEL_ENVIRONMENT_ALL          ((CsrLogLevelEnvironment) 0xFFFFFFFF) /* All possible environment data/events are logged WARNING: By using this define the application also accepts future possible environment data/events in the logs */
+
+/*----------------------------------------------------*/
+/*  Filtering on task specific log levels             */
+/*----------------------------------------------------*/
+typedef CsrUint32 CsrLogLevelTask;
+#define CSR_LOG_LEVEL_TASK_OFF                 ((CsrLogLevelTask) 0x00000000) /* No events are logged for this task */
+#define CSR_LOG_LEVEL_TASK_TEXT                ((CsrLogLevelTask) 0x00000001) /* Text strings printed by a task are logged NB: This bit does not affect the CSR_LOG_TEXT_LEVEL interface. This has to be configured separately */
+#define CSR_LOG_LEVEL_TASK_TEXT_LOC            ((CsrLogLevelTask) 0x00000002) /* The locaction where the text string call occured are logged. NB: This is a supplement to CSR_LOG_LEVEL_TASK_TEXT, it has no effect without it */
+#define CSR_LOG_LEVEL_TASK_STATE               ((CsrLogLevelTask) 0x00000004) /* FSM state transitions in a task are logged */
+#define CSR_LOG_LEVEL_TASK_STATE_NAME          ((CsrLogLevelTask) 0x00000008) /* The name of each state in a FSM state transition are logged. NB: This is a supplement to CSR_LOG_LEVEL_TASK_STATE, it has no effect without it */
+#define CSR_LOG_LEVEL_TASK_STATE_LOC           ((CsrLogLevelTask) 0x00000010) /* The location where the FSM state transition occured are logged. NB: This is a supplement to CSR_LOG_LEVEL_TASK_STATE, it has no effect without it */
+#define CSR_LOG_LEVEL_TASK_TASK_SWITCH         ((CsrLogLevelTask) 0x00000020) /* Activation and deactiation of a task are logged */
+#define CSR_LOG_LEVEL_TASK_MESSAGE_PUT         ((CsrLogLevelTask) 0x00000080) /* Message put operations are logged */
+#define CSR_LOG_LEVEL_TASK_MESSAGE_PUT_LOC     ((CsrLogLevelTask) 0x00000100) /* The location where a message was sent are logged. NB: This is a supplement to CSR_LOG_LEVEL_TASK_MESSAGE_PUT, it has no effect without it */
+#define CSR_LOG_LEVEL_TASK_MESSAGE_GET         ((CsrLogLevelTask) 0x00000200) /* Message get operations are logged */
+#define CSR_LOG_LEVEL_TASK_MESSAGE_QUEUE_PUSH  ((CsrLogLevelTask) 0x00000400) /* Message push operations are logged */
+#define CSR_LOG_LEVEL_TASK_MESSAGE_QUEUE_POP   ((CsrLogLevelTask) 0x00000800) /* Message pop operations are logged */
+#define CSR_LOG_LEVEL_TASK_PRIM_ONLY_TYPE      ((CsrLogLevelTask) 0x00001000) /* Only the type of primitives in messages are logged. By default the entire primitive is serialized and logged */
+#define CSR_LOG_LEVEL_TASK_PRIM_APPLY_LIMIT    ((CsrLogLevelTask) 0x00002000) /* An upper limit (defined by CSR_LOG_PRIM_SIZE_UPPER_LIMIT) is applied to how much of a primitive in a message are logged. NB: This limit is only applied if CSR_LOG_LEVEL_TASK_PRIM_ONLY_TYPE is _not_ defined */
+#define CSR_LOG_LEVEL_TASK_TIMER_IN            ((CsrLogLevelTask) 0x00004000) /* TimedEventIn events are logged */
+#define CSR_LOG_LEVEL_TASK_TIMER_IN_LOC        ((CsrLogLevelTask) 0x00008000) /* The location where a timer was started are logged. NB: This is a supplement to CSR_LOG_LEVEL_TASK_TIMER_IN, it has no effect without it */
+#define CSR_LOG_LEVEL_TASK_TIMER_CANCEL        ((CsrLogLevelTask) 0x00010000) /* TimedEventCancel events are logged */
+#define CSR_LOG_LEVEL_TASK_TIMER_CANCEL_LOC    ((CsrLogLevelTask) 0x00020000) /* The location where a timer was cancelled are logged. NB: This is a supplement to CSR_LOG_LEVEL_TASK_TIMER_CANCEL, it has no effect without it */
+#define CSR_LOG_LEVEL_TASK_TIMER_FIRE          ((CsrLogLevelTask) 0x00040000) /* TimedEventFire events are logged */
+#define CSR_LOG_LEVEL_TASK_TIMER_DONE          ((CsrLogLevelTask) 0x00080000) /* TimedEventDone events are logged */
+/* The bit masks between here are reserved for future usage */
+#define CSR_LOG_LEVEL_TASK_ALL                 ((CsrLogLevelTask) 0xFFFFFFFF & ~(CSR_LOG_LEVEL_TASK_PRIM_ONLY_TYPE | CSR_LOG_LEVEL_TASK_PRIM_APPLY_LIMIT)) /* All info possible to log for a task are logged. WARNING: By using this define the application also accepts future possible task data/events in the logs */
+
+CsrBool CsrLogEnvironmentIsFiltered(CsrLogLevelEnvironment level);
+CsrLogLevelTask CsrLogTaskFilterGet(CsrSchedQid taskId);
+CsrBool CsrLogTaskIsFiltered(CsrSchedQid taskId, CsrLogLevelTask level);
+
+/*
+ * Logging stuff
+ */
+#define CSR_LOG_STRINGIFY_REAL(a) #a
+#define CSR_LOG_STRINGIFY(a) CSR_LOG_STRINGIFY_REAL(a)
+
+#ifdef CSR_LOG_ASSERT_ENABLE
+#define CSR_LOG_ASSERT(cond)                        \
+    do {                                                \
+        if (!(cond))                                    \
+        {                                               \
+            CsrCharString *panic_arg = "[" __FILE__ ":" CSR_LOG_STRINGIFY(__LINE__) "] - " CSR_LOG_STRINGIFY(cond); \
+            CsrPanic(CSR_TECH_FW, CSR_PANIC_FW_ASSERTION_FAIL, panic_arg); \
+        }                                               \
+    } while (0)
+#else
+#define CSR_LOG_ASSERT(cond)
+#endif
+
+typedef struct
+{
+    CsrUint16            primitiveType;
+    const CsrCharString *primitiveName;
+    CsrMsgConvMsgEntry  *messageConv; /* Private - do not use */
+} CsrLogPrimitiveInformation;
+
+typedef struct
+{
+    const CsrCharString        *techVer;
+    CsrUint32                   primitiveInfoCount;
+    CsrLogPrimitiveInformation *primitiveInfo;
+} CsrLogTechInformation;
+
+/*---------------------------------*/
+/*  Tech logging */
+/*---------------------------------*/
+typedef CsrUint8 bitmask8_t;
+typedef CsrUint16 bitmask16_t;
+typedef CsrUint32 bitmask32_t;
+
+#ifdef CSR_LOG_ENABLE
+#ifdef CSR_LOG_INCLUDE_FILE_NAME_AND_LINE_NUMBER
+/* DEPRECATED - replaced by csr_log_text.h */
+#define CSR_LOG_TEXT(text) \
+    do { \
+        if (!CsrLogTaskIsFiltered(CsrSchedTaskQueueGet(), CSR_LOG_LEVEL_TASK_TEXT)) \
+        { \
+            CsrLogTaskText(text, __LINE__, __FILE__); \
+        } \
+    } while (0)
+#else
+/* DEPRECATED - replaced by csr_log_text.h */
+#define CSR_LOG_TEXT(text) \
+    do { \
+        if (!CsrLogTaskIsFiltered(CsrSchedTaskQueueGet(), CSR_LOG_LEVEL_TASK_TEXT)) \
+        { \
+            CsrLogTaskText(text, 0, NULL); \
+        } \
+    } while (0)
+#endif
+#else
+#define CSR_LOG_TEXT(text)
+#endif
+
+/* DEPRECATED - replaced by csr_log_text.h */
+void CsrLogTaskText(const CsrCharString *text,
+    CsrUint32 line,
+    const CsrCharString *file);
+
+#define CSR_LOG_STATE_TRANSITION_MASK_FSM_NAME          (0x001)
+#define CSR_LOG_STATE_TRANSITION_MASK_NEXT_STATE        (0x002)
+#define CSR_LOG_STATE_TRANSITION_MASK_NEXT_STATE_STR    (0x004)
+#define CSR_LOG_STATE_TRANSITION_MASK_PREV_STATE        (0x008)
+#define CSR_LOG_STATE_TRANSITION_MASK_PREV_STATE_STR    (0x010)
+#define CSR_LOG_STATE_TRANSITION_MASK_EVENT             (0x020)
+#define CSR_LOG_STATE_TRANSITION_MASK_EVENT_STR         (0x040)
+
+/* DEPRECATED - replaced by csr_log_text.h */
+void CsrLogStateTransition(bitmask16_t mask,
+    CsrUint32 identifier,
+    const CsrCharString *fsm_name,
+    CsrUint32 prev_state,
+    const CsrCharString *prev_state_str,
+    CsrUint32 in_event,
+    const CsrCharString *in_event_str,
+    CsrUint32 next_state,
+    const CsrCharString *next_state_str,
+    CsrUint32 line,
+    const CsrCharString *file);
+
+/*---------------------------------*/
+/*  BSP logging */
+/*---------------------------------*/
+void CsrLogSchedInit(CsrUint8 thread_id);
+void CsrLogSchedDeinit(CsrUint8 thread_id);
+
+void CsrLogSchedStart(CsrUint8 thread_id);
+void CsrLogSchedStop(CsrUint8 thread_id);
+
+void CsrLogInitTask(CsrUint8 thread_id, CsrSchedQid tskid, const CsrCharString *tskName);
+void CsrLogDeinitTask(CsrUint16 task_id);
+
+void CsrLogActivate(CsrSchedQid tskid);
+void CsrLogDeactivate(CsrSchedQid tskid);
+
+#define SYNERGY_SERIALIZER_TYPE_DUMP    (0x000)
+#define SYNERGY_SERIALIZER_TYPE_SER     (0x001)
+
+void CsrLogMessagePut(CsrUint32 line,
+    const CsrCharString *file,
+    CsrSchedQid src_task_id,
+    CsrSchedQid dst_taskid,
+    CsrSchedMsgId msg_id,
+    CsrUint16 prim_type,
+    const void *msg);
+
+void CsrLogMessageGet(CsrSchedQid src_task_id,
+    CsrSchedQid dst_taskid,
+    CsrBool get_res,
+    CsrSchedMsgId msg_id,
+    CsrUint16 prim_type,
+    const void *msg);
+
+void CsrLogTimedEventIn(CsrUint32 line,
+    const CsrCharString *file,
+    CsrSchedQid task_id,
+    CsrSchedTid tid,
+    CsrTime requested_delay,
+    CsrUint16 fniarg,
+    const void *fnvarg);
+
+void CsrLogTimedEventFire(CsrSchedQid task_id,
+    CsrSchedTid tid);
+
+void CsrLogTimedEventDone(CsrSchedQid task_id,
+    CsrSchedTid tid);
+
+void CsrLogTimedEventCancel(CsrUint32 line,
+    const CsrCharString *file,
+    CsrSchedQid task_id,
+    CsrSchedTid tid,
+    CsrBool cancel_res);
+
+void CsrLogBgintRegister(CsrUint8 thread_id,
+    CsrSchedBgint irq,
+    const CsrCharString *callback,
+    const void *ptr);
+void CsrLogBgintUnregister(CsrSchedBgint irq);
+void CsrLogBgintSet(CsrSchedBgint irq);
+void CsrLogBgintServiceStart(CsrSchedBgint irq);
+void CsrLogBgintServiceDone(CsrSchedBgint irq);
+
+void CsrLogExceptionStateEvent(CsrUint16 prim_type,
+    CsrPrim msg_type,
+    CsrUint16 state,
+    CsrUint32 line,
+    const CsrCharString *file);
+void CsrLogExceptionGeneral(CsrUint16 prim_type,
+    CsrUint16 state,
+    const CsrCharString *text,
+    CsrUint32 line,
+    const CsrCharString *file);
+void CsrLogExceptionWarning(CsrUint16 prim_type,
+    CsrUint16 state,
+    const CsrCharString *text,
+    CsrUint32 line,
+    const CsrCharString *file);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_log_configure.h
@@ -0,0 +1,135 @@
+#ifndef CSR_LOG_CONFIGURE_H__
+#define CSR_LOG_CONFIGURE_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+#include "csr_log.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*---------------------------------*/
+/* Log init/deinit                 */
+/*---------------------------------*/
+void CsrLogInit(CsrUint8 size);
+void CsrLogDeinit(void);
+
+/*---------------------------------*/
+/* Log Framework Tech info         */
+/*---------------------------------*/
+void CsrLogTechInfoRegister(void);
+
+/* Set the logging level for the environment outside the scheduler context */
+void CsrLogLevelEnvironmentSet(CsrLogLevelEnvironment environmentLogLevel);
+
+
+/* Set the logging level for all scheduler tasks */
+/* This function call takes precedence over all previous calls to CsrLogLevelTaskSetSpecific() */
+void CsrLogLevelTaskSetAll(CsrLogLevelTask tasksLogLevelMask);
+
+/* Set the logging level for a given Task */
+/* This function can be used as a complement to CsrLogLevelTaskSetAll() to add more _or_ less log from a given task than what is set
+generally with CsrLogLevelTaskSetAll(). */
+void CsrLogLevelTaskSetSpecific(CsrSchedQid taskId, CsrLogLevelTask taskLogLevelMask);
+
+
+/*--------------------------------------------*/
+/*  Filtering on log text warning levels      */
+/*--------------------------------------------*/
+typedef CsrUint32 CsrLogLevelText;
+#define CSR_LOG_LEVEL_TEXT_OFF       ((CsrLogLevelText) 0x0000)
+
+#define CSR_LOG_LEVEL_TEXT_CRITICAL  ((CsrLogLevelText) 0x0001)
+#define CSR_LOG_LEVEL_TEXT_ERROR     ((CsrLogLevelText) 0x0002)
+#define CSR_LOG_LEVEL_TEXT_WARNING   ((CsrLogLevelText) 0x0004)
+#define CSR_LOG_LEVEL_TEXT_INFO      ((CsrLogLevelText) 0x0008)
+#define CSR_LOG_LEVEL_TEXT_DEBUG     ((CsrLogLevelText) 0x0010)
+
+#define CSR_LOG_LEVEL_TEXT_ALL       ((CsrLogLevelText) 0xFFFF)
+
+/* The log text interface is used by both scheduler tasks and components outside the scheduler context.
+ * Therefore a CsrLogTextTaskId is introduced. It is effectively considered as two CsrUint16's. The lower
+ * 16 bits corresponds one2one with the scheduler queueId's (CsrSchedQid) and as such these bits can not be used
+ * by components outside scheduler tasks. The upper 16 bits are allocated for use of components outside the
+ * scheduler like drivers etc. Components in this range is defined independently by each technology. To avoid
+ * clashes the technologies are only allowed to assign values within the same restrictive range as allies to
+ * primitive identifiers. eg. for the framework components outside the scheduler is only allowed to assign
+ * taskId's in the range 0x0600xxxx to 0x06FFxxxx. And so on for other technologies. */
+typedef CsrUint32 CsrLogTextTaskId;
+
+/* Set the text logging level for all Tasks */
+/* This function call takes precedence over all previous calls to CsrLogLevelTextSetTask() and CsrLogLevelTextSetTaskSubOrigin() */
+void CsrLogLevelTextSetAll(CsrLogLevelText warningLevelMask);
+
+/* Set the text logging level for a given Task */
+/* This function call takes precedence over all previous calls to CsrLogLevelTextSetTaskSubOrigin(), but it can be used as a complement to
+ * CsrLogLevelTextSetAll() to add more _or_ less log from a given task than what is set generally with CsrLogLevelTextSetAll(). */
+void CsrLogLevelTextSetTask(CsrLogTextTaskId taskId, CsrLogLevelText warningLevelMask);
+
+/* Set the text logging level for a given tasks subOrigin */
+/* This function can be used as a complement to CsrLogLevelTextSetAll() and CsrLogLevelTextSetTask() to add more _or_ less log from a given
+ * subOrigin within a task than what is set generally with CsrLogLevelTextSetAll() _or_ CsrLogLevelTextSetTask(). */
+void CsrLogLevelTextSetTaskSubOrigin(CsrLogTextTaskId taskId, CsrUint16 subOrigin, CsrLogLevelText warningLevelMask);
+
+/*******************************************************************************
+
+    NAME
+        CsrLogLevelTextSet
+
+    DESCRIPTION
+        Set the text logging level for a given origin and optionally sub origin
+        by name. If either string is NULL or zero length, it is interpreted as
+        all origins and/or all sub origins respectively. If originName is NULL
+        or zero length, subOriginName is ignored.
+
+        Passing NULL or zero length strings in both originName and subOriginName
+        is equivalent to calling CsrLogLevelTextSetAll, and overrides all
+        previous filter configurations for all origins and sub origins.
+
+        Passing NULL or a zero length string in subOriginName overrides all
+        previous filter configurations for all sub origins of the specified
+        origin.
+
+        Note: the supplied strings may be accessed after the function returns
+        and must remain valid and constant until CsrLogDeinit is called.
+
+        Note: when specifying an origin (originName is not NULL and not zero
+        length), this function can only be used for origins that use the
+        csr_log_text_2.h interface for registration and logging. Filtering for
+        origins that use the legacy csr_log_text.h interface must be be
+        configured using the legacy filter configuration functions that accept
+        a CsrLogTextTaskId as origin specifier. However, when not specifying an
+        origin this function also affects origins that have been registered with
+        the legacy csr_log_text.h interface. Furthermore, using this function
+        and the legacy filter configuration functions on the same origin is not
+        allowed.
+
+    PARAMETERS
+        originName - a string containing the name of the origin. Can be NULL or
+            zero length to set the log level for all origins. In this case, the
+            subOriginName parameter will be ignored.
+        subOriginName - a string containing the name of the sub origin. Can be
+            NULL or zero length to set the log level for all sub origins of the
+            specified origin.
+        warningLevelMask - The desired log level for the specified origin(s) and
+            sub origin(s).
+
+*******************************************************************************/
+void CsrLogLevelTextSet(const CsrCharString *originName,
+    const CsrCharString *subOriginName,
+    CsrLogLevelText warningLevelMask);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_log_text.h
@@ -0,0 +1,133 @@
+#ifndef CSR_LOG_TEXT_H__
+#define CSR_LOG_TEXT_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+#include "csr_log_configure.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct CsrLogSubOrigin
+{
+    CsrUint16            subOriginNumber;  /* Id of the given SubOrigin */
+    const CsrCharString *subOriginName;    /* Prefix Text for this SubOrigin */
+} CsrLogSubOrigin;
+
+/* Register a task which is going to use the CSR_LOG_TEXT_XXX interface */
+#ifdef CSR_LOG_ENABLE
+void CsrLogTextRegister(CsrLogTextTaskId taskId, const CsrCharString *taskName, CsrUint16 subOriginsLength, const CsrLogSubOrigin *subOrigins);
+#else
+#define CsrLogTextRegister(taskId, taskName, subOriginsLength, subOrigins)
+#endif
+
+/* CRITICAL: Conditions that are threatening to the integrity/stability of the
+   system as a whole. */
+#if defined(CSR_LOG_ENABLE) && !defined(CSR_LOG_LEVEL_TEXT_CRITICAL_DISABLE)
+void CsrLogTextCritical(CsrLogTextTaskId taskId, CsrUint16 subOrigin, const CsrCharString *formatString, ...);
+void CsrLogTextBufferCritical(CsrLogTextTaskId taskId, CsrUint16 subOrigin, CsrSize bufferLength, const void *buffer, const CsrCharString *formatString, ...);
+#define CSR_LOG_TEXT_CRITICAL(taskId_subOrigin_formatString_varargs) CsrLogTextCritical taskId_subOrigin_formatString_varargs
+#define CSR_LOG_TEXT_CONDITIONAL_CRITICAL(condition, logtextargs) {if (condition) {CSR_LOG_TEXT_CRITICAL(logtextargs);}}
+#define CSR_LOG_TEXT_BUFFER_CRITICAL(taskId_subOrigin_length_buffer_formatString_varargs) CsrLogTextBufferCritical taskId_subOrigin_length_buffer_formatString_varargs
+#define CSR_LOG_TEXT_BUFFER_CONDITIONAL_CRITICAL(condition, logtextbufferargs) {if (condition) {CSR_LOG_TEXT_BUFFER_CRITICAL(logtextbufferargs);}}
+#else
+#define CSR_LOG_TEXT_CRITICAL(taskId_subOrigin_formatString_varargs)
+#define CSR_LOG_TEXT_CONDITIONAL_CRITICAL(condition, logtextargs)
+#define CSR_LOG_TEXT_BUFFER_CRITICAL(taskId_subOrigin_length_buffer_formatString_varargs)
+#define CSR_LOG_TEXT_BUFFER_CONDITIONAL_CRITICAL(condition, logtextbufferargs)
+#endif
+
+/* ERROR: Malfunction of a component rendering it unable to operate correctly,
+   causing lack of functionality but not loss of system integrity/stability. */
+#if defined(CSR_LOG_ENABLE) && !defined(CSR_LOG_LEVEL_TEXT_ERROR_DISABLE)
+void CsrLogTextError(CsrLogTextTaskId taskId, CsrUint16 subOrigin, const CsrCharString *formatString, ...);
+void CsrLogTextBufferError(CsrLogTextTaskId taskId, CsrUint16 subOrigin, CsrSize bufferLength, const void *buffer, const CsrCharString *formatString, ...);
+#define CSR_LOG_TEXT_ERROR(taskId_subOrigin_formatString_varargs) CsrLogTextError taskId_subOrigin_formatString_varargs
+#define CSR_LOG_TEXT_CONDITIONAL_ERROR(condition, logtextargs) {if (condition) {CSR_LOG_TEXT_ERROR(logtextargs);}}
+#define CSR_LOG_TEXT_BUFFER_ERROR(taskId_subOrigin_length_buffer_formatString_varargs) CsrLogTextBufferError taskId_subOrigin_length_buffer_formatString_varargs
+#define CSR_LOG_TEXT_BUFFER_CONDITIONAL_ERROR(condition, logtextbufferargs) {if (condition) {CSR_LOG_TEXT_BUFFER_ERROR(logtextbufferargs);}}
+#else
+#define CSR_LOG_TEXT_ERROR(taskId_subOrigin_formatString_varargs)
+#define CSR_LOG_TEXT_CONDITIONAL_ERROR(condition, logtextargs)
+#define CSR_LOG_TEXT_BUFFER_ERROR(taskId_subOrigin_length_buffer_formatString_varargs)
+#define CSR_LOG_TEXT_BUFFER_CONDITIONAL_ERROR(condition, logtextbufferargs)
+#endif
+
+/* WARNING: Conditions that are unexpected and indicative of possible problems
+   or violations of specifications, where the result of such deviations does not
+   lead to malfunction of the component. */
+#if defined(CSR_LOG_ENABLE) && !defined(CSR_LOG_LEVEL_TEXT_WARNING_DISABLE)
+void CsrLogTextWarning(CsrLogTextTaskId taskId, CsrUint16 subOrigin, const CsrCharString *formatString, ...);
+void CsrLogTextBufferWarning(CsrLogTextTaskId taskId, CsrUint16 subOrigin, CsrSize bufferLength, const void *buffer, const CsrCharString *formatString, ...);
+#define CSR_LOG_TEXT_WARNING(taskId_subOrigin_formatString_varargs) CsrLogTextWarning taskId_subOrigin_formatString_varargs
+#define CSR_LOG_TEXT_CONDITIONAL_WARNING(condition, logtextargs) {if (condition) {CSR_LOG_TEXT_WARNING(logtextargs);}}
+#define CSR_LOG_TEXT_BUFFER_WARNING(taskId_subOrigin_length_buffer_formatString_varargs) CsrLogTextBufferWarning taskId_subOrigin_length_buffer_formatString_varargs
+#define CSR_LOG_TEXT_BUFFER_CONDITIONAL_WARNING(condition, logtextbufferargs) {if (condition) {CSR_LOG_TEXT_BUFFER_WARNING(logtextbufferargs);}}
+#else
+#define CSR_LOG_TEXT_WARNING(taskId_subOrigin_formatString_varargs)
+#define CSR_LOG_TEXT_CONDITIONAL_WARNING(condition, logtextargs)
+#define CSR_LOG_TEXT_BUFFER_WARNING(taskId_subOrigin_length_buffer_formatString_varargs)
+#define CSR_LOG_TEXT_BUFFER_CONDITIONAL_WARNING(condition, logtextbufferargs)
+#endif
+
+/* INFO: Important events that may aid in determining the conditions under which
+   the more severe conditions are encountered. */
+#if defined(CSR_LOG_ENABLE) && !defined(CSR_LOG_LEVEL_TEXT_INFO_DISABLE)
+void CsrLogTextInfo(CsrLogTextTaskId taskId, CsrUint16 subOrigin, const CsrCharString *formatString, ...);
+void CsrLogTextBufferInfo(CsrLogTextTaskId taskId, CsrUint16 subOrigin, CsrSize bufferLength, const void *buffer, const CsrCharString *formatString, ...);
+#define CSR_LOG_TEXT_INFO(taskId_subOrigin_formatString_varargs) CsrLogTextInfo taskId_subOrigin_formatString_varargs
+#define CSR_LOG_TEXT_CONDITIONAL_INFO(condition, logtextargs) {if (condition) {CSR_LOG_TEXT_INFO(logtextargs);}}
+#define CSR_LOG_TEXT_BUFFER_INFO(taskId_subOrigin_length_buffer_formatString_varargs) CsrLogTextBufferInfo taskId_subOrigin_length_buffer_formatString_varargs
+#define CSR_LOG_TEXT_BUFFER_CONDITIONAL_INFO(condition, logtextbufferargs) {if (condition) {CSR_LOG_TEXT_BUFFER_INFO(logtextbufferargs);}}
+#else
+#define CSR_LOG_TEXT_INFO(taskId_subOrigin_formatString_varargs)
+#define CSR_LOG_TEXT_CONDITIONAL_INFO(condition, logtextargs)
+#define CSR_LOG_TEXT_BUFFER_INFO(taskId_subOrigin_length_buffer_formatString_varargs)
+#define CSR_LOG_TEXT_BUFFER_CONDITIONAL_INFO(condition, logtextbufferargs)
+#endif
+
+/* DEBUG: Similar to INFO, but dedicated to events that occur more frequently. */
+#if defined(CSR_LOG_ENABLE) && !defined(CSR_LOG_LEVEL_TEXT_DEBUG_DISABLE)
+void CsrLogTextDebug(CsrLogTextTaskId taskId, CsrUint16 subOrigin, const CsrCharString *formatString, ...);
+void CsrLogTextBufferDebug(CsrLogTextTaskId taskId, CsrUint16 subOrigin, CsrSize bufferLength, const void *buffer, const CsrCharString *formatString, ...);
+#define CSR_LOG_TEXT_DEBUG(taskId_subOrigin_formatString_varargs) CsrLogTextDebug taskId_subOrigin_formatString_varargs
+#define CSR_LOG_TEXT_CONDITIONAL_DEBUG(condition, logtextargs) {if (condition) {CSR_LOG_TEXT_DEBUG(logtextargs);}}
+#define CSR_LOG_TEXT_BUFFER_DEBUG(taskId_subOrigin_length_buffer_formatString_varargs) CsrLogTextBufferDebug taskId_subOrigin_length_buffer_formatString_varargs
+#define CSR_LOG_TEXT_BUFFER_CONDITIONAL_DEBUG(condition, logtextbufferargs) {if (condition) {CSR_LOG_TEXT_BUFFER_DEBUG(logtextbufferargs);}}
+#else
+#define CSR_LOG_TEXT_DEBUG(taskId_subOrigin_formatString_varargs)
+#define CSR_LOG_TEXT_CONDITIONAL_DEBUG(condition, logtextargs)
+#define CSR_LOG_TEXT_BUFFER_DEBUG(taskId_subOrigin_length_buffer_formatString_varargs)
+#define CSR_LOG_TEXT_BUFFER_CONDITIONAL_DEBUG(condition, logtextbufferargs)
+#endif
+
+/* CSR_LOG_TEXT_ASSERT (CRITICAL) */
+#ifdef CSR_LOG_ENABLE
+#define CSR_LOG_TEXT_ASSERT(origin, suborigin, condition) \
+    {if (!(condition)) {CSR_LOG_TEXT_CRITICAL((origin, suborigin, "Assertion \"%s\" failed at %s:%u", #condition, __FILE__, __LINE__));}}
+#else
+#define CSR_LOG_TEXT_ASSERT(origin, suborigin, condition)
+#endif
+
+/* CSR_LOG_TEXT_UNHANDLED_PRIM (CRITICAL) */
+#ifdef CSR_LOG_ENABLE
+#define CSR_LOG_TEXT_UNHANDLED_PRIMITIVE(origin, suborigin, primClass, primType) \
+    CSR_LOG_TEXT_CRITICAL((origin, suborigin, "Unhandled primitive 0x%04X:0x%04X at %s:%u", primClass, primType, __FILE__, __LINE__))
+#else
+#define CSR_LOG_TEXT_UNHANDLED_PRIMITIVE(origin, suborigin, primClass, primType)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_macro.h
@@ -0,0 +1,111 @@
+#ifndef CSR_MACRO_H__
+#define CSR_MACRO_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*------------------------------------------------------------------*/
+/* Bits - intended to operate on CsrUint32 values */
+/*------------------------------------------------------------------*/
+#define CSR_MASK_IS_SET(val, mask) (((val) & (mask)) == (mask))
+#define CSR_MASK_IS_UNSET(val, mask) ((((val) & (mask)) ^ mask) == (mask))
+#define CSR_MASK_SET(val, mask)    ((val) |= (mask))
+#define CSR_MASK_UNSET(val, mask)  ((val) = ((val) ^ (mask)) & (val)) /* Unsets the bits in val that are set in mask */
+#define CSR_BIT_IS_SET(val, bit)   ((CsrBool) ((((val) & (1UL << (bit))) != 0)))
+#define CSR_BIT_SET(val, bit)      ((val) |= (1UL << (bit)))
+#define CSR_BIT_UNSET(val, bit)    ((val) &= ~(1UL << (bit)))
+#define CSR_BIT_TOGGLE(val, bit)   ((val) ^= (1UL << (bit)))
+
+/*------------------------------------------------------------------*/
+/* Endian conversion */
+/*------------------------------------------------------------------*/
+#define CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr)        (((CsrUint16) ((CsrUint8 *) (ptr))[0]) | ((CsrUint16) ((CsrUint8 *) (ptr))[1]) << 8)
+#define CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr)        (((CsrUint32) ((CsrUint8 *) (ptr))[0]) | ((CsrUint32) ((CsrUint8 *) (ptr))[1]) << 8 | \
+                                                       ((CsrUint32) ((CsrUint8 *) (ptr))[2]) << 16 | ((CsrUint32) ((CsrUint8 *) (ptr))[3]) << 24)
+#define CSR_COPY_UINT16_TO_LITTLE_ENDIAN(uint, ptr)    ((CsrUint8 *) (ptr))[0] = ((CsrUint8) ((uint) & 0x00FF)); \
+    ((CsrUint8 *) (ptr))[1] = ((CsrUint8) ((uint) >> 8))
+#define CSR_COPY_UINT32_TO_LITTLE_ENDIAN(uint, ptr)    ((CsrUint8 *) (ptr))[0] = ((CsrUint8) ((uint) & 0x000000FF)); \
+    ((CsrUint8 *) (ptr))[1] = ((CsrUint8) (((uint) >> 8) & 0x000000FF)); \
+    ((CsrUint8 *) (ptr))[2] = ((CsrUint8) (((uint) >> 16) & 0x000000FF)); \
+    ((CsrUint8 *) (ptr))[3] = ((CsrUint8) (((uint) >> 24) & 0x000000FF))
+#define CSR_GET_UINT16_FROM_BIG_ENDIAN(ptr) (((CsrUint16) ((CsrUint8 *) (ptr))[1]) | ((CsrUint16) ((CsrUint8 *) (ptr))[0]) << 8)
+#define CSR_GET_UINT24_FROM_BIG_ENDIAN(ptr) (((CsrUint24) ((CsrUint8 *) (ptr))[2]) | \
+                                             ((CsrUint24) ((CsrUint8 *) (ptr))[1]) << 8 | ((CsrUint24) ((CsrUint8 *) (ptr))[0]) << 16)
+#define CSR_GET_UINT32_FROM_BIG_ENDIAN(ptr) (((CsrUint32) ((CsrUint8 *) (ptr))[3]) | ((CsrUint32) ((CsrUint8 *) (ptr))[2]) << 8 | \
+                                             ((CsrUint32) ((CsrUint8 *) (ptr))[1]) << 16 | ((CsrUint32) ((CsrUint8 *) (ptr))[0]) << 24)
+#define CSR_COPY_UINT16_TO_BIG_ENDIAN(uint, ptr)    ((CsrUint8 *) (ptr))[1] = ((CsrUint8) ((uint) & 0x00FF)); \
+    ((CsrUint8 *) (ptr))[0] = ((CsrUint8) ((uint) >> 8))
+#define CSR_COPY_UINT24_TO_BIG_ENDIAN(uint, ptr)    ((CsrUint8 *) (ptr))[2] = ((CsrUint8) ((uint) & 0x000000FF)); \
+    ((CsrUint8 *) (ptr))[1] = ((CsrUint8) (((uint) >> 8) & 0x000000FF)); \
+    ((CsrUint8 *) (ptr))[0] = ((CsrUint8) (((uint) >> 16) & 0x000000FF))
+#define CSR_COPY_UINT32_TO_BIG_ENDIAN(uint, ptr)    ((CsrUint8 *) (ptr))[3] = ((CsrUint8) ((uint) & 0x000000FF)); \
+    ((CsrUint8 *) (ptr))[2] = ((CsrUint8) (((uint) >> 8) & 0x000000FF)); \
+    ((CsrUint8 *) (ptr))[1] = ((CsrUint8) (((uint) >> 16) & 0x000000FF)); \
+    ((CsrUint8 *) (ptr))[0] = ((CsrUint8) (((uint) >> 24) & 0x000000FF))
+
+/*------------------------------------------------------------------*/
+/* XAP conversion macros */
+/*------------------------------------------------------------------*/
+
+#define CSR_LSB16(a) ((CsrUint8) ((a) & 0x00ff))
+#define CSR_MSB16(b) ((CsrUint8) ((b) >> 8))
+
+#define CSR_CONVERT_8_FROM_XAP(output, input) \
+    (output) = ((CsrUint8) (input));(input) += 2
+
+#define CSR_CONVERT_16_FROM_XAP(output, input) \
+    (output) = (CsrUint16) ((((CsrUint16) (input)[1]) << 8) | \
+                            ((CsrUint16) (input)[0]));(input) += 2
+
+#define CSR_CONVERT_32_FROM_XAP(output, input) \
+    (output) = (((CsrUint32) (input)[1]) << 24) | \
+               (((CsrUint32) (input)[0]) << 16) | \
+               (((CsrUint32) (input)[3]) << 8) | \
+               ((CsrUint32) (input)[2]);input += 4
+
+#define CSR_ADD_UINT8_TO_XAP(output, input) \
+    (output)[0] = (input);  \
+    (output)[1] = 0;(output) += 2
+
+#define CSR_ADD_UINT16_TO_XAP(output, input) \
+    (output)[0] = ((CsrUint8) ((input) & 0x00FF));  \
+    (output)[1] = ((CsrUint8) ((input) >> 8));(output) += 2
+
+#define CSR_ADD_UINT32_TO_XAP(output, input) \
+    (output)[0] = ((CsrUint8) (((input) >> 16) & 0x00FF)); \
+    (output)[1] = ((CsrUint8) ((input) >> 24)); \
+    (output)[2] = ((CsrUint8) ((input) & 0x00FF)); \
+    (output)[3] = ((CsrUint8) (((input) >> 8) & 0x00FF));(output) += 4
+
+/*------------------------------------------------------------------*/
+/* Misc */
+/*------------------------------------------------------------------*/
+#define CSRMAX(a, b)    (((a) > (b)) ? (a) : (b))
+#define CSRMIN(a, b)    (((a) < (b)) ? (a) : (b))
+
+/* Use this macro on unused local variables that cannot be removed (such as
+   unused function parameters). This will quell warnings from certain compilers
+   and static code analysis tools like Lint and Valgrind. */
+#define CSR_UNUSED(x) ((void) (x))
+
+#define CSR_TOUPPER(character)  (((character) >= 'a') && ((character) <= 'z') ? ((character) - 0x20) : (character))
+#define CSR_TOLOWER(character)  (((character) >= 'A') && ((character) <= 'Z') ? ((character) + 0x20) : (character))
+#define CSR_ARRAY_SIZE(x)       (sizeof(x) / sizeof(*(x)))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_msg_transport.h
@@ -0,0 +1,25 @@
+#ifndef CSR_MSG_TRANSPORT_H__
+#define CSR_MSG_TRANSPORT_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CsrMsgTransport
+#define CsrMsgTransport CsrSchedMessagePut
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_MSG_TRANSPORT */
--- /dev/null
+++ b/drivers/staging/csr/csr_msgconv.c
@@ -0,0 +1,324 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include <linux/module.h>
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_panic.h"
+#include "csr_sched.h"
+#include "csr_msgconv.h"
+#include "csr_util.h"
+
+static CsrMsgConvEntry *converter;
+
+CsrMsgConvPrimEntry *CsrMsgConvFind(CsrUint16 primType)
+{
+    CsrMsgConvPrimEntry *ptr = NULL;
+
+    if (converter)
+    {
+        ptr = converter->profile_converters;
+        while (ptr)
+        {
+            if (ptr->primType == primType)
+            {
+                break;
+            }
+            else
+            {
+                ptr = ptr->next;
+            }
+        }
+    }
+
+    return ptr;
+}
+
+static const CsrMsgConvMsgEntry *find_msg_converter(CsrMsgConvPrimEntry *ptr, CsrUint16 msgType)
+{
+    const CsrMsgConvMsgEntry *cv = ptr->conv;
+    if (ptr->lookupFunc)
+    {
+        return (const CsrMsgConvMsgEntry *) ptr->lookupFunc((CsrMsgConvMsgEntry *) cv, msgType);
+    }
+
+    while (cv)
+    {
+        if (cv->serFunc == NULL)
+        {
+            /* We've reached the end of the chain */
+            cv = NULL;
+            break;
+        }
+
+        if (cv->msgType == msgType)
+        {
+            break;
+        }
+        else
+        {
+            cv++;
+        }
+    }
+
+    return cv;
+}
+
+static void *deserialize_data(CsrUint16 primType,
+    CsrSize length,
+    CsrUint8 *data)
+{
+    CsrMsgConvPrimEntry *ptr;
+    CsrUint8 *ret;
+
+    ptr = CsrMsgConvFind(primType);
+
+    if (ptr)
+    {
+        const CsrMsgConvMsgEntry *cv;
+        CsrUint16 msgId = 0;
+        CsrSize offset = 0;
+        CsrUint16Des(&msgId, data, &offset);
+
+        cv = find_msg_converter(ptr, msgId);
+        if (cv)
+        {
+            ret = cv->deserFunc(data, length);
+        }
+        else
+        {
+            ret = NULL;
+        }
+    }
+    else
+    {
+        ret = NULL;
+    }
+
+    return ret;
+}
+
+static CsrSize sizeof_message(CsrUint16 primType, void *msg)
+{
+    CsrMsgConvPrimEntry *ptr = CsrMsgConvFind(primType);
+    CsrSize ret;
+
+    if (ptr)
+    {
+        const CsrMsgConvMsgEntry *cv;
+        CsrUint16 msgId = *(CsrUint16 *) msg;
+
+        cv = find_msg_converter(ptr, msgId);
+        if (cv)
+        {
+            ret = cv->sizeofFunc(msg);
+        }
+        else
+        {
+            ret = 0;
+        }
+    }
+    else
+    {
+        ret = 0;
+    }
+
+    return ret;
+}
+
+static CsrBool free_message(CsrUint16 primType, CsrUint8 *data)
+{
+    CsrMsgConvPrimEntry *ptr;
+    CsrBool ret;
+
+    ptr = CsrMsgConvFind(primType);
+
+    if (ptr)
+    {
+        const CsrMsgConvMsgEntry *cv;
+        CsrUint16 msgId = *(CsrUint16 *) data;
+
+        cv = find_msg_converter(ptr, msgId);
+        if (cv)
+        {
+            cv->freeFunc(data);
+            ret = TRUE;
+        }
+        else
+        {
+            ret = FALSE;
+        }
+    }
+    else
+    {
+        ret = FALSE;
+    }
+
+    return ret;
+}
+
+static CsrUint8 *serialize_message(CsrUint16 primType,
+    void *msg,
+    CsrSize *length,
+    CsrUint8 *buffer)
+{
+    CsrMsgConvPrimEntry *ptr;
+    CsrUint8 *ret;
+
+    ptr = CsrMsgConvFind(primType);
+
+    *length = 0;
+
+    if (ptr)
+    {
+        const CsrMsgConvMsgEntry *cv;
+
+        cv = find_msg_converter(ptr, *(CsrUint16 *) msg);
+        if (cv)
+        {
+            ret = cv->serFunc(buffer, length, msg);
+        }
+        else
+        {
+            ret = NULL;
+        }
+    }
+    else
+    {
+        ret = NULL;
+    }
+
+    return ret;
+}
+
+CsrSize CsrMsgConvSizeof(CsrUint16 primType, void *msg)
+{
+    return sizeof_message(primType, msg);
+}
+
+CsrUint8 *CsrMsgConvSerialize(CsrUint8 *buffer, CsrSize maxBufferOffset, CsrSize *offset, CsrUint16 primType, void *msg)
+{
+    if (converter)
+    {
+        CsrSize serializedLength;
+        CsrUint8 *bufSerialized;
+        CsrUint8 *bufOffset = &buffer[*offset];
+        bufSerialized = converter->serialize_message(primType, msg, &serializedLength, bufOffset);
+        *offset += serializedLength;
+        return bufSerialized;
+    }
+    else
+    {
+        return NULL;
+    }
+}
+
+/* Insert profile converter at head of converter list. */
+void CsrMsgConvInsert(CsrUint16 primType, const CsrMsgConvMsgEntry *ce)
+{
+    CsrMsgConvPrimEntry *pc;
+    pc = CsrMsgConvFind(primType);
+
+    if (pc)
+    {
+        /* Already registered. Do nothing */
+    }
+    else
+    {
+        pc = CsrPmemAlloc(sizeof(*pc));
+        pc->primType = primType;
+        pc->conv = ce;
+        pc->lookupFunc = NULL;
+        pc->next = converter->profile_converters;
+        converter->profile_converters = pc;
+    }
+}
+EXPORT_SYMBOL_GPL(CsrMsgConvInsert);
+
+CsrMsgConvMsgEntry *CsrMsgConvFindEntry(CsrUint16 primType, CsrUint16 msgType)
+{
+    CsrMsgConvPrimEntry *ptr = CsrMsgConvFind(primType);
+    if (ptr)
+    {
+        return (CsrMsgConvMsgEntry *) find_msg_converter(ptr, msgType);
+    }
+    return NULL;
+}
+EXPORT_SYMBOL_GPL(CsrMsgConvFindEntry);
+
+CsrMsgConvMsgEntry *CsrMsgConvFindEntryByMsg(CsrUint16 primType, const void *msg)
+{
+    CsrMsgConvPrimEntry *ptr = CsrMsgConvFind(primType);
+    if (ptr && msg)
+    {
+        CsrUint16 msgType = *((CsrUint16 *) msg);
+        return (CsrMsgConvMsgEntry *) find_msg_converter(ptr, msgType);
+    }
+    return NULL;
+}
+
+void CsrMsgConvCustomLookupRegister(CsrUint16 primType, CsrMsgCustomLookupFunc *lookupFunc)
+{
+    CsrMsgConvPrimEntry *ptr = CsrMsgConvFind(primType);
+    if (ptr)
+    {
+        ptr->lookupFunc = lookupFunc;
+    }
+}
+EXPORT_SYMBOL_GPL(CsrMsgConvCustomLookupRegister);
+
+CsrMsgConvEntry *CsrMsgConvInit(void)
+{
+    if (!converter)
+    {
+        converter = (CsrMsgConvEntry *) CsrPmemAlloc(sizeof(CsrMsgConvEntry));
+
+        converter->profile_converters = NULL;
+        converter->free_message = free_message;
+        converter->sizeof_message = sizeof_message;
+        converter->serialize_message = serialize_message;
+        converter->deserialize_data = deserialize_data;
+    }
+
+    return converter;
+}
+EXPORT_SYMBOL_GPL(CsrMsgConvInit);
+
+CsrMsgConvEntry *CsrMsgConvGet(void)
+{
+    return converter;
+}
+
+#ifdef ENABLE_SHUTDOWN
+void CsrMsgConvDeinit(void)
+{
+    CsrMsgConvPrimEntry *s;
+
+    if (converter == NULL)
+    {
+        return;
+    }
+
+    /* Walk converter list and free elements. */
+    s = converter->profile_converters;
+    while (s)
+    {
+        CsrMsgConvPrimEntry *s_next;
+        s_next = s->next;
+        CsrPmemFree(s);
+        s = s_next;
+    }
+
+    CsrPmemFree(converter);
+    converter = NULL;
+}
+EXPORT_SYMBOL_GPL(CsrMsgConvDeinit);
+
+#endif /* ENABLE_SHUTDOWN */
--- /dev/null
+++ b/drivers/staging/csr/csr_msgconv.h
@@ -0,0 +1,145 @@
+#ifndef CSR_MSGCONV_H__
+#define CSR_MSGCONV_H__
+
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+#include "csr_sched.h"
+#include "csr_unicode.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef CsrSize (CsrMsgSizeofFunc)(void *msg);
+typedef CsrUint8 *(CsrMsgSerializeFunc)(CsrUint8 *buffer, CsrSize *length, void *msg);
+typedef void (CsrMsgFreeFunc)(void *msg);
+typedef void *(CsrMsgDeserializeFunc)(CsrUint8 *buffer, CsrSize length);
+
+/* Converter entry for one message type */
+typedef struct CsrMsgConvMsgEntry
+{
+    CsrUint16              msgType;
+    CsrMsgSizeofFunc      *sizeofFunc;
+    CsrMsgSerializeFunc   *serFunc;
+    CsrMsgDeserializeFunc *deserFunc;
+    CsrMsgFreeFunc        *freeFunc;
+} CsrMsgConvMsgEntry;
+
+/* Optional lookup function */
+typedef CsrMsgConvMsgEntry *(CsrMsgCustomLookupFunc)(CsrMsgConvMsgEntry *ce, CsrUint16 msgType);
+
+/* All converter entries for one specific primitive */
+typedef struct CsrMsgConvPrimEntry
+{
+    CsrUint16                   primType;
+    const CsrMsgConvMsgEntry   *conv;
+    CsrMsgCustomLookupFunc     *lookupFunc;
+    struct CsrMsgConvPrimEntry *next;
+} CsrMsgConvPrimEntry;
+
+typedef struct
+{
+    CsrMsgConvPrimEntry *profile_converters;
+    void *(*deserialize_data)(CsrUint16 primType, CsrSize length, CsrUint8 * data);
+    CsrBool (*free_message)(CsrUint16 primType, CsrUint8 *data);
+    CsrSize (*sizeof_message)(CsrUint16 primType, void *msg);
+    CsrUint8 *(*serialize_message)(CsrUint16 primType, void *msg,
+                                   CsrSize * length,
+                                   CsrUint8 * buffer);
+} CsrMsgConvEntry;
+
+CsrSize CsrMsgConvSizeof(CsrUint16 primType, void *msg);
+CsrUint8 *CsrMsgConvSerialize(CsrUint8 *buffer, CsrSize maxBufferOffset, CsrSize *offset, CsrUint16 primType, void *msg);
+void CsrMsgConvCustomLookupRegister(CsrUint16 primType, CsrMsgCustomLookupFunc *lookupFunc);
+void CsrMsgConvInsert(CsrUint16 primType, const CsrMsgConvMsgEntry *ce);
+CsrMsgConvPrimEntry *CsrMsgConvFind(CsrUint16 primType);
+CsrMsgConvMsgEntry *CsrMsgConvFindEntry(CsrUint16 primType, CsrUint16 msgType);
+CsrMsgConvMsgEntry *CsrMsgConvFindEntryByMsg(CsrUint16 primType, const void *msg);
+CsrMsgConvEntry *CsrMsgConvGet(void);
+CsrMsgConvEntry *CsrMsgConvInit(void);
+#ifdef ENABLE_SHUTDOWN
+void CsrMsgConvDeinit(void);
+#endif /* ENABLE_SHUTDOWN */
+
+/* SHOULD BE INTERNAL TO FRAMEWORK AKA DEPRECATED */
+
+CsrUint32 CsrCharStringSerLen(const CsrCharString *str);
+CsrUint32 CsrUtf8StringSerLen(const CsrUtf8String *str);
+CsrUint32 CsrUtf16StringSerLen(const CsrUtf16String *str);
+
+/* Prototypes for primitive type serializers */
+void CsrUint8Ser(CsrUint8 *buffer, CsrSize *offset, CsrUint8 value);
+void CsrUint16Ser(CsrUint8 *buffer, CsrSize *offset, CsrUint16 value);
+void CsrUint32Ser(CsrUint8 *buffer, CsrSize *offset, CsrUint32 value);
+void CsrMemCpySer(CsrUint8 *buffer, CsrSize *offset, const void *value, CsrSize length);
+void CsrCharStringSer(CsrUint8 *buffer, CsrSize *offset, const CsrCharString *value);
+void CsrUtf8StringSer(CsrUint8 *buffer, CsrSize *offset, const CsrUtf8String *value);
+void CsrUtf16StringSer(CsrUint8 *buffer, CsrSize *offset, const CsrUtf16String *value);
+void CsrVoidPtrSer(CsrUint8 *buffer, CsrSize *offset, void *ptr);
+void CsrSizeSer(CsrUint8 *buffer, CsrSize *offset, CsrSize value);
+
+void CsrUint8Des(CsrUint8 *value, CsrUint8 *buffer, CsrSize *offset);
+void CsrUint16Des(CsrUint16 *value, CsrUint8 *buffer, CsrSize *offset);
+void CsrUint32Des(CsrUint32 *value, CsrUint8 *buffer, CsrSize *offset);
+void CsrMemCpyDes(void *value, CsrUint8 *buffer, CsrSize *offset, CsrSize length);
+void CsrCharStringDes(CsrCharString **value, CsrUint8 *buffer, CsrSize *offset);
+void CsrUtf8StringDes(CsrUtf8String **value, CsrUint8 *buffer, CsrSize *offset);
+void CsrUtf16StringDes(CsrUtf16String **value, CsrUint8 *buffer, CsrSize *offset);
+void CsrVoidPtrDes(void **value, CsrUint8 *buffer, CsrSize *offset);
+void CsrSizeDes(CsrSize *value, CsrUint8 *buffer, CsrSize *offset);
+
+CsrSize CsrEventSizeof(void *msg);
+CsrUint8 *CsrEventSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+void *CsrEventDes(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrEventCsrUint8Sizeof(void *msg);
+CsrUint8 *CsrEventCsrUint8Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void *CsrEventCsrUint8Des(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrEventCsrUint16Sizeof(void *msg);
+CsrUint8 *CsrEventCsrUint16Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void *CsrEventCsrUint16Des(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrEventCsrUint32Sizeof(void *msg);
+CsrUint8 *CsrEventCsrUint32Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void *CsrEventCsrUint32Des(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrEventCsrUint16CsrUint8Sizeof(void *msg);
+CsrUint8 *CsrEventCsrUint16CsrUint8Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void *CsrEventCsrUint16CsrUint8Des(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrEventCsrUint16CsrUint16Sizeof(void *msg);
+CsrUint8 *CsrEventCsrUint16CsrUint16Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void *CsrEventCsrUint16CsrUint16Des(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrEventCsrUint16CsrUint32Sizeof(void *msg);
+CsrUint8 *CsrEventCsrUint16CsrUint32Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void *CsrEventCsrUint16CsrUint32Des(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrEventCsrUint16CsrCharStringSizeof(void *msg);
+CsrUint8 *CsrEventCsrUint16CsrCharStringSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+void *CsrEventCsrUint16CsrCharStringDes(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrEventCsrUint32CsrUint16Sizeof(void *msg);
+CsrUint8 *CsrEventCsrUint32CsrUint16Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void *CsrEventCsrUint32CsrUint16Des(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrEventCsrUint32CsrCharStringSizeof(void *msg);
+CsrUint8 *CsrEventCsrUint32CsrCharStringSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+void *CsrEventCsrUint32CsrCharStringDes(CsrUint8 *buffer, CsrSize length);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_panic.c
@@ -0,0 +1,22 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include "csr_types.h"
+#include "csr_panic.h"
+
+void CsrPanic(CsrUint8 tech, CsrUint16 reason, const char *p)
+{
+    BUG_ON(1);
+}
+EXPORT_SYMBOL_GPL(CsrPanic);
--- /dev/null
+++ b/drivers/staging/csr/csr_panic.h
@@ -0,0 +1,55 @@
+#ifndef CSR_PANIC_H__
+#define CSR_PANIC_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+#include "csr_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Synergy techonology ID definitions */
+#define CSR_TECH_FW     0
+#define CSR_TECH_BT     1
+#define CSR_TECH_WIFI   2
+#define CSR_TECH_GPS    3
+#define CSR_TECH_NFC    4
+
+/* Panic type ID definitions for technology type CSR_TECH_FW */
+#define CSR_PANIC_FW_UNEXPECTED_VALUE        0
+#define CSR_PANIC_FW_HEAP_EXHAUSTION         1
+#define CSR_PANIC_FW_INVALID_PFREE_POINTER   2
+#define CSR_PANIC_FW_EXCEPTION               3
+#define CSR_PANIC_FW_ASSERTION_FAIL          4
+#define CSR_PANIC_FW_NULL_TASK_HANDLER       5
+#define CSR_PANIC_FW_UNKNOWN_TASK            6
+#define CSR_PANIC_FW_QUEUE_ACCESS_VIOLATION  7
+#define CSR_PANIC_FW_TOO_MANY_MESSAGES       8
+#define CSR_PANIC_FW_TOO_MANY_TIMED_EVENTS   9
+#define CSR_PANIC_FW_ABCSP_SYNC_LOST        10
+#define CSR_PANIC_FW_OVERSIZE_ABCSP_PRIM    11
+#define CSR_PANIC_FW_H4_CORRUPTION          12
+#define CSR_PANIC_FW_H4_SYNC_LOST           13
+#define CSR_PANIC_FW_H4_RX_OVERRUN          14
+#define CSR_PANIC_FW_H4_TX_OVERRUN          15
+#define CSR_PANIC_FW_TM_BC_RESTART_FAIL     16
+#define CSR_PANIC_FW_TM_BC_START_FAIL       17
+#define CSR_PANIC_FW_TM_BC_BAD_STATE        18
+#define CSR_PANIC_FW_TM_BC_TRANSPORT_LOST   19
+
+/* Panic interface used by technologies */
+/* DEPRECATED - replaced by csr_log_text.h */
+void CsrPanic(CsrUint8 tech, CsrUint16 reason, const char *p);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_PANIC_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_pmem.c
@@ -0,0 +1,51 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+#include <linux/autoconf.h>
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
+#include <linux/config.h>
+#endif
+
+#include <linux/slab.h>
+
+#include "csr_panic.h"
+#include "csr_pmem.h"
+
+void *CsrPmemAlloc(CsrSize size)
+{
+    void *ret;
+
+    ret = kmalloc(size, GFP_KERNEL);
+    if (!ret)
+    {
+        CsrPanic(CSR_TECH_FW, CSR_PANIC_FW_HEAP_EXHAUSTION,
+            "out of memory");
+    }
+
+    return ret;
+}
+EXPORT_SYMBOL_GPL(CsrPmemAlloc);
+
+void CsrPmemFree(void *ptr)
+{
+    if (ptr == NULL)
+    {
+        return;
+    }
+
+    kfree(ptr);
+}
+EXPORT_SYMBOL_GPL(CsrPmemFree);
--- /dev/null
+++ b/drivers/staging/csr/csr_pmem.h
@@ -0,0 +1,143 @@
+#ifndef CSR_PMEM_H__
+#define CSR_PMEM_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+#include "csr_util.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_PMEM_DEBUG_ENABLE
+/*****************************************************************************
+
+    NAME
+        CsrPmemAlloc
+
+    DESCRIPTION
+        This function will allocate a contiguous block of memory of at least
+        the specified size in bytes and return a pointer to the allocated
+        memory. This function is not allowed to return NULL. A size of 0 is a
+        valid request, and a unique and valid (not NULL) pointer must be
+        returned in this case.
+
+    PARAMETERS
+        size - Size of memory requested. Note that a size of 0 is valid.
+
+    RETURNS
+        Pointer to allocated memory.
+
+*****************************************************************************/
+#ifdef CSR_PMEM_DEBUG
+void *CsrPmemAllocDebug(CsrSize size,
+    const CsrCharString *file, CsrUint32 line);
+#define CsrPmemAlloc(sz) CsrPmemAllocDebug((sz), __FILE__, __LINE__)
+#else
+void *CsrPmemAlloc(CsrSize size);
+#endif
+
+
+/*****************************************************************************
+
+    NAME
+        CsrPmemFree
+
+    DESCRIPTION
+        This function will deallocate a previously allocated block of memory.
+
+    PARAMETERS
+        ptr - Pointer to allocated memory.
+
+*****************************************************************************/
+void CsrPmemFree(void *ptr);
+#endif
+
+/*****************************************************************************
+
+    NAME
+        CsrPmemZalloc
+
+    DESCRIPTION
+        This function is equivalent to CsrPmemAlloc, but the allocated memory
+        is initialised to zero.
+
+    PARAMETERS
+        size - Size of memory requested. Note that a size of 0 is valid.
+
+    RETURNS
+        Pointer to allocated memory.
+
+*****************************************************************************/
+#define CsrPmemZalloc(s) (CsrMemSet(CsrPmemAlloc(s), 0x00, (s)))
+
+
+/*****************************************************************************
+
+    NAME
+        pnew and zpnew
+
+    DESCRIPTIOM
+        Type-safe wrappers for CsrPmemAlloc and CsrPmemZalloc, for allocating
+        single instances of a specified and named type.
+
+    PARAMETERS
+        t - type to allocate.
+
+*****************************************************************************/
+#define pnew(t) ((t *) (CsrPmemAlloc(sizeof(t))))
+#define zpnew(t) ((t *) (CsrPmemZalloc(sizeof(t))))
+
+
+/*----------------------------------------------------------------------------*
+ * Csr Pmem Debug code. Allows custom callbacks on CsrPmemAlloc and CsrPmemFree
+ *----------------------------------------------------------------------------*/
+#ifdef CSR_PMEM_DEBUG_ENABLE
+
+typedef CsrUint8 CsrPmemDebugAllocType;
+#define CSR_PMEM_DEBUG_TYPE_PMEM_ALLOC    1
+#define CSR_PMEM_DEBUG_TYPE_MEM_ALLOC     2
+#define CSR_PMEM_DEBUG_TYPE_MEM_CALLOC    3
+#define CSR_PMEM_DEBUG_TYPE_MEM_ALLOC_DMA 4
+
+typedef void (CsrPmemDebugOnAlloc)(void *ptr, void *userptr, CsrSize size, CsrPmemDebugAllocType type, const CsrCharString* file, CsrUint32 line);
+typedef void (CsrPmemDebugOnFree)(void *ptr, void *userptr, CsrPmemDebugAllocType type, const CsrCharString* file, CsrUint32 line);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrPmemInstallHooks
+ *
+ *  DESCRIPTION
+ *      Install debug hooks for memory allocation
+ *      Use NULL values to uninstall the hooks
+ *      headSize = The number of extra bytes to allocate in the head of the Allocated buffer
+ *      footSize = The number of extra bytes to allocate in the end of the Allocated buffer
+ *
+ *  RETURNS
+ *      void
+ *
+ *----------------------------------------------------------------------------*/
+void CsrPmemDebugInstallHooks(CsrUint8 headSize, CsrUint8 endSize, CsrPmemDebugOnAlloc *onAllocCallback, CsrPmemDebugOnFree *onFreeCallback);
+
+void *CsrPmemDebugAlloc(CsrSize size, CsrPmemDebugAllocType type, const CsrCharString* file, CsrUint32 line);
+#define CsrPmemAlloc(size) CsrPmemDebugAlloc(size, CSR_PMEM_DEBUG_TYPE_PMEM_ALLOC, __FILE__, __LINE__)
+
+void CsrPmemDebugFree(void *ptr, CsrPmemDebugAllocType type, const CsrCharString* file, CsrUint32 line);
+#define CsrPmemFree(ptr) CsrPmemDebugFree(ptr, CSR_PMEM_DEBUG_TYPE_PMEM_ALLOC, __FILE__, __LINE__)
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_prim_defs.h
@@ -0,0 +1,64 @@
+#ifndef CSR_PRIM_DEFS_H__
+#define CSR_PRIM_DEFS_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+#include "csr_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/************************************************************************************
+ * Segmentation of primitives in upstream and downstream segment
+ ************************************************************************************/
+typedef CsrUint16 CsrPrim;
+#define CSR_PRIM_UPSTREAM                   ((CsrPrim) (0x8000))
+
+/************************************************************************************
+ * Primitive definitions for Synergy framework
+ ************************************************************************************/
+#define CSR_SYNERGY_EVENT_CLASS_BASE        ((CsrUint16) (0x0600))
+
+#define CSR_HCI_PRIM                        ((CsrUint16) (0x0000 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_BCCMD_PRIM                      ((CsrUint16) (0x0001 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_HQ_PRIM                         ((CsrUint16) (0x0002 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_VM_PRIM                         ((CsrUint16) (0x0003 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_TM_BLUECORE_PRIM                ((CsrUint16) (0x0004 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_FP_PRIM                         ((CsrUint16) (0x0005 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_IP_SOCKET_PRIM                  ((CsrUint16) (0x0006 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_IP_ETHER_PRIM                   ((CsrUint16) (0x0007 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_IP_IFCONFIG_PRIM                ((CsrUint16) (0x0008 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_IP_INTERNAL_PRIM                ((CsrUint16) (0x0009 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_FSAL_PRIM                       ((CsrUint16) (0x000A | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_DATA_STORE_PRIM                 ((CsrUint16) (0x000B | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_AM_PRIM                         ((CsrUint16) (0x000C | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_TLS_PRIM                        ((CsrUint16) (0x000D | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_DHCP_SERVER_PRIM                ((CsrUint16) (0x000E | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_TFTP_PRIM                       ((CsrUint16) (0x000F | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_DSPM_PRIM                       ((CsrUint16) (0x0010 | CSR_SYNERGY_EVENT_CLASS_BASE))
+#define CSR_TLS_INTERNAL_PRIM               ((CsrUint16) (0x0011 | CSR_SYNERGY_EVENT_CLASS_BASE))
+
+#define NUMBER_OF_CSR_FW_EVENTS             (CSR_DSPM_PRIM - CSR_SYNERGY_EVENT_CLASS_BASE + 1)
+
+#define CSR_SYNERGY_EVENT_CLASS_MISC_BASE   ((CsrUint16) (0x06A0))
+
+#define CSR_UI_PRIM                         ((CsrUint16) (0x0000 | CSR_SYNERGY_EVENT_CLASS_MISC_BASE))
+#define CSR_APP_PRIM                        ((CsrUint16) (0x0001 | CSR_SYNERGY_EVENT_CLASS_MISC_BASE))
+#define CSR_SDIO_PROBE_PRIM                 ((CsrUint16) (0x0002 | CSR_SYNERGY_EVENT_CLASS_MISC_BASE))
+
+#define NUMBER_OF_CSR_FW_MISC_EVENTS        (CSR_SDIO_PROBE_PRIM - CSR_SYNERGY_EVENT_CLASS_MISC_BASE + 1)
+
+#define CSR_ENV_PRIM                        ((CsrUint16) (0x00FF | CSR_SYNERGY_EVENT_CLASS_MISC_BASE))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_PRIM_DEFS_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_result.h
@@ -0,0 +1,27 @@
+#ifndef CSR_RESULT_H__
+#define CSR_RESULT_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef CsrUint16 CsrResult;
+#define CSR_RESULT_SUCCESS  ((CsrResult) 0x0000)
+#define CSR_RESULT_FAILURE  ((CsrResult) 0xFFFF)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_sched.h
@@ -0,0 +1,292 @@
+#ifndef CSR_SCHED_H__
+#define CSR_SCHED_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+#include "csr_types.h"
+#include "csr_time.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* An identifier issued by the scheduler. */
+typedef CsrUint32 CsrSchedIdentifier;
+
+/* A task identifier */
+typedef CsrUint16 CsrSchedTaskId;
+
+/* A queue identifier */
+typedef CsrUint16 CsrSchedQid;
+#define CSR_SCHED_QID_INVALID     ((CsrSchedQid) 0xFFFF)
+
+/* A message identifier */
+typedef CsrSchedIdentifier CsrSchedMsgId;
+
+/* A timer event identifier */
+typedef CsrSchedIdentifier CsrSchedTid;
+#define CSR_SCHED_TID_INVALID     ((CsrSchedTid) 0)
+
+/* Scheduler entry functions share this structure */
+typedef void (*schedEntryFunction_t)(void **inst);
+
+/* Time constants. */
+#define CSR_SCHED_TIME_MAX                ((CsrTime) 0xFFFFFFFF)
+#define CSR_SCHED_MILLISECOND             ((CsrTime) (1000))
+#define CSR_SCHED_SECOND                  ((CsrTime) (1000 * CSR_SCHED_MILLISECOND))
+#define CSR_SCHED_MINUTE                  ((CsrTime) (60 * CSR_SCHED_SECOND))
+
+/* Queue and primitive that identifies the environment */
+#define CSR_SCHED_TASK_ID        0xFFFF
+#define CSR_SCHED_PRIM                   (CSR_SCHED_TASK_ID)
+#define CSR_SCHED_EXCLUDED_MODULE_QUEUE      0xFFFF
+
+/*
+ * Background interrupt definitions
+ */
+typedef CsrUint16 CsrSchedBgint;
+#define CSR_SCHED_BGINT_INVALID ((CsrSchedBgint) 0xFFFF)
+
+typedef void (*CsrSchedBgintHandler)(void *);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSchedBgintReg
+ *
+ *  DESCRIPTION
+ *      Register a background interrupt handler function with the scheduler.
+ *        When CsrSchedBgint() is called from the foreground (e.g. an interrupt
+ *        routine) the registered function is called.
+ *
+ *        If "cb" is null then the interrupt is effectively disabled. If a
+ *        no bgints are available, CSR_SCHED_BGINT_INVALID is returned, otherwise
+ *        a CsrSchedBgint value is returned to be used in subsequent calls to
+ *        CsrSchedBgint().  id is a possibly NULL identifier used for logging
+ *        purposes only.
+ *
+ *  RETURNS
+ *      CsrSchedBgint -- CSR_SCHED_BGINT_INVALID denotes failure to obtain a CsrSchedBgintSet.
+ *
+ *----------------------------------------------------------------------------*/
+CsrSchedBgint CsrSchedBgintReg(CsrSchedBgintHandler cb,
+    void *context,
+    const CsrCharString *id);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSchedBgintUnreg
+ *
+ *  DESCRIPTION
+ *      Unregister a background interrupt handler function.
+ *
+ *      ``irq'' is a background interrupt handle previously obtained
+ *      from a call to CsrSchedBgintReg().
+ *
+ *  RETURNS
+ *      void.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSchedBgintUnreg(CsrSchedBgint bgint);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSchedBgintSet
+ *
+ *  DESCRIPTION
+ *      Set background interrupt.
+ *
+ *  RETURNS
+ *      void.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSchedBgintSet(CsrSchedBgint bgint);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSchedMessagePut
+ *
+ *  DESCRIPTION
+ *      Sends a message consisting of the integer "mi" and the void * pointer
+ *      "mv" to the message queue "q".
+ *
+ *      "mi" and "mv" are neither inspected nor changed by the scheduler - the
+ *      task that owns "q" is expected to make sense of the values. "mv" may
+ *      be null.
+ *
+ *  NOTE
+ *      If "mv" is not null then it will typically be a chunk of CsrPmemAlloc()ed
+ *      memory, though there is no need for it to be so. Tasks should normally
+ *      obey the convention that when a message built with CsrPmemAlloc()ed memory
+ *      is given to CsrSchedMessagePut() then ownership of the memory is ceded to the
+ *      scheduler - and eventually to the recipient task. I.e., the receiver of
+ *      the message will be expected to CsrPmemFree() the message storage.
+ *
+ *  RETURNS
+ *      void.
+ *
+ *----------------------------------------------------------------------------*/
+#if defined(CSR_LOG_ENABLE) && defined(CSR_LOG_INCLUDE_FILE_NAME_AND_LINE_NUMBER)
+void CsrSchedMessagePutStringLog(CsrSchedQid q,
+    CsrUint16 mi,
+    void *mv,
+    CsrUint32 line,
+    const CsrCharString *file);
+#define CsrSchedMessagePut(q, mi, mv) CsrSchedMessagePutStringLog((q), (mi), (mv), __LINE__, __FILE__)
+#else
+void CsrSchedMessagePut(CsrSchedQid q,
+    CsrUint16 mi,
+    void *mv);
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSchedMessageBroadcast
+ *
+ *  DESCRIPTION
+ *      Sends a message to all tasks.
+ *
+ *      The user must supply a "factory function" that is called once
+ *      for every task that exists. The "factory function", msg_build_func,
+ *      must allocate and initialise the message and set the msg_build_ptr
+ *      to point to the message when done.
+ *
+ *  NOTE
+ *      N/A
+ *
+ *  RETURNS
+ *      void
+ *
+ *----------------------------------------------------------------------------*/
+#if defined(CSR_LOG_ENABLE) && defined(CSR_LOG_INCLUDE_FILE_NAME_AND_LINE_NUMBER)
+void CsrSchedMessageBroadcastStringLog(CsrUint16 mi,
+    void *(*msg_build_func)(void *),
+    void *msg_build_ptr,
+    CsrUint32 line,
+    const CsrCharString *file);
+#define CsrSchedMessageBroadcast(mi, fn, ptr) CsrSchedMessageBroadcastStringLog((mi), (fn), (ptr), __LINE__, __FILE__)
+#else
+void CsrSchedMessageBroadcast(CsrUint16 mi,
+    void *(*msg_build_func)(void *),
+    void *msg_build_ptr);
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSchedMessageGet
+ *
+ *  DESCRIPTION
+ *      Obtains a message from the message queue belonging to the calling task.
+ *      The message consists of one or both of a CsrUint16 and a void *.
+ *
+ *  RETURNS
+ *      CsrBool - TRUE if a message has been obtained from the queue, else FALSE.
+ *      If a message is taken from the queue, then "*pmi" and "*pmv" are set to
+ *      the "mi" and "mv" passed to CsrSchedMessagePut() respectively.
+ *
+ *      "pmi" and "pmv" can be null, in which case the corresponding value from
+ *      them message is discarded.
+ *
+ *----------------------------------------------------------------------------*/
+CsrBool CsrSchedMessageGet(CsrUint16 *pmi, void **pmv);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSchedTimerSet
+ *
+ *  DESCRIPTION
+ *      Causes the void function "fn" to be called with the arguments
+ *      "fniarg" and "fnvarg" after "delay" has elapsed.
+ *
+ *      "delay" must be less than half the range of a CsrTime.
+ *
+ *      CsrSchedTimerSet() does nothing with "fniarg" and "fnvarg" except
+ *      deliver them via a call to "fn()".   (Unless CsrSchedTimerCancel()
+ *      is used to prevent delivery.)
+ *
+ *  NOTE
+ *      The function will be called at or after "delay"; the actual delay will
+ *      depend on the timing behaviour of the scheduler's tasks.
+ *
+ *  RETURNS
+ *      CsrSchedTid - A timed event identifier, can be used in CsrSchedTimerCancel().
+ *
+ *----------------------------------------------------------------------------*/
+#if defined(CSR_LOG_ENABLE) && defined(CSR_LOG_INCLUDE_FILE_NAME_AND_LINE_NUMBER)
+CsrSchedTid CsrSchedTimerSetStringLog(CsrTime delay,
+    void (*fn)(CsrUint16 mi, void *mv),
+    CsrUint16 fniarg,
+    void *fnvarg,
+    CsrUint32 line,
+    const CsrCharString *file);
+#define CsrSchedTimerSet(d, fn, fni, fnv) CsrSchedTimerSetStringLog((d), (fn), (fni), (fnv), __LINE__, __FILE__)
+#else
+CsrSchedTid CsrSchedTimerSet(CsrTime delay,
+    void (*fn)(CsrUint16 mi, void *mv),
+    CsrUint16 fniarg,
+    void *fnvarg);
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSchedTimerCancel
+ *
+ *  DESCRIPTION
+ *      Attempts to prevent the timed event with identifier "eventid" from
+ *      occurring.
+ *
+ *  RETURNS
+ *      CsrBool - TRUE if cancelled, FALSE if the event has already occurred.
+ *
+ *----------------------------------------------------------------------------*/
+#if defined(CSR_LOG_ENABLE) && defined(CSR_LOG_INCLUDE_FILE_NAME_AND_LINE_NUMBER)
+CsrBool CsrSchedTimerCancelStringLog(CsrSchedTid eventid,
+    CsrUint16 *pmi,
+    void **pmv,
+    CsrUint32 line,
+    const CsrCharString *file);
+#define CsrSchedTimerCancel(e, pmi, pmv) CsrSchedTimerCancelStringLog((e), (pmi), (pmv), __LINE__, __FILE__)
+#else
+CsrBool CsrSchedTimerCancel(CsrSchedTid eventid,
+    CsrUint16 *pmi,
+    void **pmv);
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSchedTaskQueueGet
+ *
+ *  DESCRIPTION
+ *      Return the queue identifier for the currently running queue
+ *
+ *  RETURNS
+ *      CsrSchedQid - The current task queue identifier, or 0xFFFF if not available.
+ *
+ *----------------------------------------------------------------------------*/
+CsrSchedQid CsrSchedTaskQueueGet(void);
+
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSchedTaskQueueGet
+ *
+ *  DESCRIPTION
+ *      Return the queue identifier for the currently running queue
+ *
+ *  RETURNS
+ *      CsrCharString - The current task queue identifier, or 0xFFFF if not available.
+ *
+ *----------------------------------------------------------------------------*/
+CsrCharString* CsrSchedTaskNameGet(CsrSchedQid );
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_sdio.h
@@ -0,0 +1,732 @@
+#ifndef CSR_SDIO_H__
+#define CSR_SDIO_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+#include "csr_result.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Result Codes */
+#define CSR_SDIO_RESULT_INVALID_VALUE   ((CsrResult) 1) /* Invalid argument value */
+#define CSR_SDIO_RESULT_NO_DEVICE       ((CsrResult) 2) /* The specified device is no longer present */
+#define CSR_SDIO_RESULT_CRC_ERROR       ((CsrResult) 3) /* The transmitted/received data or command response contained a CRC error */
+#define CSR_SDIO_RESULT_TIMEOUT         ((CsrResult) 4) /* No command response or data received from device, or function enable/disable did not succeed within timeout period */
+#define CSR_SDIO_RESULT_NOT_RESET       ((CsrResult) 5) /* The device was not reset */
+
+/* Features (for use in features member of CsrSdioFunction) */
+#define CSR_SDIO_FEATURE_BYTE_MODE                   0x00000001 /* Transfer sizes do not have to be a multiple of block size */
+#define CSR_SDIO_FEATURE_DMA_CAPABLE_MEM_REQUIRED    0x00000002 /* Bulk operations require DMA friendly memory */
+
+/* CsrSdioFunctionId wildcards (for use in CsrSdioFunctionId members) */
+#define CSR_SDIO_ANY_MANF_ID        0xFFFF
+#define CSR_SDIO_ANY_CARD_ID        0xFFFF
+#define CSR_SDIO_ANY_SDIO_FUNCTION  0xFF
+#define CSR_SDIO_ANY_SDIO_INTERFACE 0xFF
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionId
+ *
+ *  DESCRIPTION
+ *      This structure describes one or more functions of a device, based on
+ *      four qualitative measures. The CsrSdioFunctionId wildcard defines can be
+ *      used for making the CsrSdioFunctionId match more than one function.
+ *
+ *  MEMBERS
+ *      manfId - Vendor ID (or CSR_SDIO_ANY_MANF_ID).
+ *      cardId - Device ID (or CSR_SDIO_ANY_CARD_ID).
+ *      sdioFunction - SDIO Function number (or CSR_SDIO_ANY_SDIO_FUNCTION).
+ *      sdioInterface - SDIO Standard Interface Code (or CSR_SDIO_ANY_SDIO_INTERFACE)
+ *
+ *----------------------------------------------------------------------------*/
+typedef struct
+{
+    CsrUint16 manfId;       /* Vendor ID to match or CSR_SDIO_ANY_MANF_ID */
+    CsrUint16 cardId;       /* Device ID to match or CSR_SDIO_ANY_CARD_ID */
+    CsrUint8  sdioFunction; /* SDIO Function number to match or CSR_SDIO_ANY_SDIO_FUNCTION */
+    CsrUint8  sdioInterface; /* SDIO Standard Interface Code to match or CSR_SDIO_ANY_SDIO_INTERFACE */
+} CsrSdioFunctionId;
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunction
+ *
+ *  DESCRIPTION
+ *      This structure represents a single function on a device.
+ *
+ *  MEMBERS
+ *      sdioId - A CsrSdioFunctionId describing this particular function. The
+ *               subfield shall not contain any CsrSdioFunctionId wildcards. The
+ *               subfields shall describe the specific single function
+ *               represented by this structure.
+ *      blockSize - Actual configured block size, or 0 if unconfigured.
+ *      features - Bit mask with any of CSR_SDIO_FEATURE_* set.
+ *      device - Handle of device containing the function. If two functions have
+ *               the same device handle, they reside on the same device.
+ *      driverData - For use by the Function Driver. The SDIO Driver shall not
+ *                   attempt to dereference the pointer.
+ *      priv - For use by the SDIO Driver. The Function Driver shall not attempt
+ *             to dereference the pointer.
+ *
+ *
+ *----------------------------------------------------------------------------*/
+typedef struct
+{
+    CsrSdioFunctionId sdioId;
+    CsrUint16         blockSize; /* Actual configured block size, or 0 if unconfigured */
+    CsrUint32         features; /* Bit mask with any of CSR_SDIO_FEATURE_* set */
+    void             *device; /* Handle of device containing the function */
+    void             *driverData; /* For use by the Function Driver */
+    void             *priv; /* For use by the SDIO Driver */
+} CsrSdioFunction;
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioInsertedCallback, CsrSdioRemovedCallback
+ *
+ *  DESCRIPTION
+ *      CsrSdioInsertedCallback is called when a function becomes available to
+ *      a registered Function Driver that supports the function.
+ *      CsrSdioRemovedCallback is called when a function is no longer available
+ *      to a Function Driver, either because the device has been removed, or the
+ *      Function Driver has been unregistered.
+ *
+ *      NOTE: These functions are implemented by the Function Driver, and are
+ *            passed as function pointers in the CsrSdioFunctionDriver struct.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *----------------------------------------------------------------------------*/
+typedef void (*CsrSdioInsertedCallback)(CsrSdioFunction *function);
+typedef void (*CsrSdioRemovedCallback)(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioInterruptDsrCallback, CsrSdioInterruptCallback
+ *
+ *  DESCRIPTION
+ *      CsrSdioInterruptCallback is called when an interrupt occurs on the
+ *      the device associated with the specified function.
+ *
+ *      NOTE: These functions are implemented by the Function Driver, and are
+ *            passed as function pointers in the CsrSdioFunctionDriver struct.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *  RETURNS (only CsrSdioInterruptCallback)
+ *      A pointer to a CsrSdioInterruptDsrCallback function.
+ *
+ *----------------------------------------------------------------------------*/
+typedef void (*CsrSdioInterruptDsrCallback)(CsrSdioFunction *function);
+typedef CsrSdioInterruptDsrCallback (*CsrSdioInterruptCallback)(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioSuspendCallback, CsrSdioResumeCallback
+ *
+ *  DESCRIPTION
+ *      CsrSdioSuspendCallback is called when the system is preparing to go
+ *      into a suspended state. CsrSdioResumeCallback is called when the system
+ *      has entered an active state again.
+ *
+ *      NOTE: These functions are implemented by the Function Driver, and are
+ *            passed as function pointers in the CsrSdioFunctionDriver struct.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *----------------------------------------------------------------------------*/
+typedef void (*CsrSdioSuspendCallback)(CsrSdioFunction *function);
+typedef void (*CsrSdioResumeCallback)(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioAsyncCallback, CsrSdioAsyncDsrCallback
+ *
+ *  DESCRIPTION
+ *      CsrSdioAsyncCallback is called when an asynchronous operation completes.
+ *
+ *      NOTE: These functions are implemented by the Function Driver, and are
+ *            passed as function pointers in the function calls that initiate
+ *            the operation.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      result - The result of the operation that completed. See the description
+ *               of the initiating function for possible result values.
+ *
+ *  RETURNS (only CsrSdioAsyncCallback)
+ *      A pointer to a CsrSdioAsyncDsrCallback function.
+ *
+ *----------------------------------------------------------------------------*/
+typedef void (*CsrSdioAsyncDsrCallback)(CsrSdioFunction *function, CsrResult result);
+typedef CsrSdioAsyncDsrCallback (*CsrSdioAsyncCallback)(CsrSdioFunction *function, CsrResult result);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionDriver
+ *
+ *  DESCRIPTION
+ *      Structure representing a Function Driver.
+ *
+ *  MEMBERS
+ *      inserted - Callback, see description of CsrSdioInsertedCallback.
+ *      removed - Callback, see description of CsrSdioRemovedCallback.
+ *      intr - Callback, see description of CsrSdioInterruptCallback.
+ *      suspend - Callback, see description of CsrSdioSuspendCallback.
+ *      resume - Callback, see description of CsrSdioResumeCallback.
+ *      ids - Array of CsrSdioFunctionId describing one or more functions that
+ *            are supported by the Function Driver.
+ *      idsCount - Length of the ids array.
+ *      priv - For use by the SDIO Driver. The Function Driver may initialise
+ *             it to NULL, but shall otherwise not access the pointer or attempt
+ *             to dereference it.
+ *
+ *----------------------------------------------------------------------------*/
+typedef struct
+{
+    CsrSdioInsertedCallback  inserted;
+    CsrSdioRemovedCallback   removed;
+    CsrSdioInterruptCallback intr;
+    CsrSdioSuspendCallback   suspend;
+    CsrSdioResumeCallback    resume;
+    CsrSdioFunctionId       *ids;
+    CsrUint8                 idsCount;
+    void                    *priv;          /* For use by the SDIO Driver */
+} CsrSdioFunctionDriver;
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionDriverRegister
+ *
+ *  DESCRIPTION
+ *      Register a Function Driver.
+ *
+ *  PARAMETERS
+ *      functionDriver - Pointer to struct describing the Function Driver.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The Function Driver was successfully
+ *                           registered.
+ *      CSR_RESULT_FAILURE - Unable to register the function driver,
+ *                                because of an unspecified/unknown error. The
+ *                                Function Driver has not been registered.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - The specified Function Driver pointer
+ *                                      does not point at a valid Function
+ *                                      Driver structure, or some of the members
+ *                                      contain invalid entries.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioFunctionDriverRegister(CsrSdioFunctionDriver *functionDriver);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionDriverUnregister
+ *
+ *  DESCRIPTION
+ *      Unregister a previously registered Function Driver.
+ *
+ *  PARAMETERS
+ *      functionDriver - pointer to struct describing the Function Driver.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSdioFunctionDriverUnregister(CsrSdioFunctionDriver *functionDriver);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionEnable, CsrSdioFunctionDisable
+ *
+ *  DESCRIPTION
+ *      Enable/disable the specified function by setting/clearing the
+ *      corresponding bit in the I/O Enable register in function 0, and then
+ *      periodically reading the related bit in the I/O Ready register until it
+ *      is set/clear, limited by an implementation defined timeout.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The specified function was enabled/disabled.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. The state of the
+ *                                  related bit in the I/O Enable register is
+ *                                  undefined.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device, or the related
+ *                                bit in the I/O ready register was not
+ *                                set/cleared within the timeout period.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioFunctionEnable(CsrSdioFunction *function);
+CsrResult CsrSdioFunctionDisable(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioInterruptEnable, CsrSdioInterruptDisable
+ *
+ *  DESCRIPTION
+ *      Enable/disable the interrupt for the specified function by
+ *      setting/clearing the corresponding bit in the INT Enable register in
+ *      function 0.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The specified function was enabled/disabled.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. The state of the
+ *                                  related bit in the INT Enable register is
+ *                                  unchanged.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - The specified function cannot be
+ *                                      enabled/disabled, because it either
+ *                                      does not exist or it is not possible to
+ *                                      individually enable/disable functions.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioInterruptEnable(CsrSdioFunction *function);
+CsrResult CsrSdioInterruptDisable(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioInterruptAcknowledge
+ *
+ *  DESCRIPTION
+ *      Acknowledge that a signalled interrupt has been handled. Shall only
+ *      be called once, and exactly once for each signalled interrupt to the
+ *      corresponding function.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function to which the
+ *                 event was signalled.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSdioInterruptAcknowledge(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioInsertedAcknowledge, CsrSdioRemovedAcknowledge
+ *
+ *  DESCRIPTION
+ *      Acknowledge that a signalled inserted/removed event has been handled.
+ *      Shall only be called once, and exactly once for each signalled event to
+ *      the corresponding function.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function to which the
+ *                 inserted was signalled.
+ *      result (CsrSdioInsertedAcknowledge only)
+ *          CSR_RESULT_SUCCESS - The Function Driver has accepted the
+ *                                    function, and the function is attached to
+ *                                    the Function Driver until the
+ *                                    CsrSdioRemovedCallback is called and
+ *                                    acknowledged.
+ *          CSR_RESULT_FAILURE - Unable to accept the function. The
+ *                                    function is not attached to the Function
+ *                                    Driver, and it may be passed to another
+ *                                    Function Driver which supports the
+ *                                    function.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSdioInsertedAcknowledge(CsrSdioFunction *function, CsrResult result);
+void CsrSdioRemovedAcknowledge(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioSuspendAcknowledge, CsrSdioResumeAcknowledge
+ *
+ *  DESCRIPTION
+ *      Acknowledge that a signalled suspend event has been handled. Shall only
+ *      be called once, and exactly once for each signalled event to the
+ *      corresponding function.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function to which the
+ *                 event was signalled.
+ *      result
+ *          CSR_RESULT_SUCCESS - Successfully suspended/resumed.
+ *          CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSdioSuspendAcknowledge(CsrSdioFunction *function, CsrResult result);
+void CsrSdioResumeAcknowledge(CsrSdioFunction *function, CsrResult result);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioBlockSizeSet
+ *
+ *  DESCRIPTION
+ *      Set the block size to use for the function. The actual configured block
+ *      size shall be the minimum of:
+ *          1) Maximum block size supported by the function.
+ *          2) Maximum block size supported by the host controller.
+ *          3) The block size specified by the blockSize argument.
+ *
+ *      When this function returns, the actual configured block size is
+ *      available in the blockSize member of the function struct.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      blockSize - Block size to use for the function. Valid range is 1 to
+ *                  2048.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The block size register on the chip
+ *                                was updated.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. The configured block
+ *                                  size is undefined.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and the FUNCTION_NUMBER
+ *            bits is set, CSR_SDIO_RESULT_INVALID_VALUE shall be returned.
+ *            If the ERROR bit is set (but not FUNCTION_NUMBER),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *      NOTE: Setting the block size requires two individual operations. The
+ *            implementation shall ignore the OUT_OF_RANGE bit of the SDIO R5
+ *            response for the first operation, as the partially configured
+ *            block size may be out of range, even if the final block size
+ *            (after the second operation) is in the valid range.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioBlockSizeSet(CsrSdioFunction *function, CsrUint16 blockSize);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioMaxBusClockFrequencySet
+ *
+ *  DESCRIPTION
+ *      Set the maximum clock frequency to use for the device associated with
+ *      the specified function. The actual configured clock frequency for the
+ *      device shall be the minimum of:
+ *          1) Maximum clock frequency supported by the device.
+ *          2) Maximum clock frequency supported by the host controller.
+ *          3) Maximum clock frequency specified for any function on the same
+ *             device.
+ *
+ *      If the clock frequency exceeds 25MHz, it is the responsibility of the
+ *      SDIO driver to enable high speed mode on the device, using the standard
+ *      defined procedure, before increasing the frequency beyond the limit.
+ *
+ *      Note that the clock frequency configured affects all functions on the
+ *      same device.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      maxFrequency - The maximum clock frequency for the function in Hertz.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The maximum clock frequency was succesfully
+ *                                set for the function.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *
+ *      NOTE: If the SDIO R5 response is available, and the FUNCTION_NUMBER
+ *            bits is set, CSR_SDIO_RESULT_INVALID_VALUE shall be returned.
+ *            If the ERROR bit is set (but not FUNCTION_NUMBER),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioMaxBusClockFrequencySet(CsrSdioFunction *function, CsrUint32 maxFrequency);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioRead8, CsrSdioWrite8, CsrSdioRead8Async, CsrSdioWrite8Async
+ *
+ *  DESCRIPTION
+ *      Read/write an 8bit value from/to the specified register address.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      address - Register address within the function.
+ *      data - The data to read/write.
+ *      callback - The function to call on operation completion.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The data was successfully read/written.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. No data read/written.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *      NOTE: The CsrSdioRead8Async and CsrSdioWrite8Async functions return
+ *            immediately, and the supplied callback function is called when the
+ *            operation is complete. The result value is given as an argument to
+ *            the callback function.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioRead8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data);
+CsrResult CsrSdioWrite8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data);
+void CsrSdioRead8Async(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data, CsrSdioAsyncCallback callback);
+void CsrSdioWrite8Async(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data, CsrSdioAsyncCallback callback);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioRead16, CsrSdioWrite16, CsrSdioRead16Async, CsrSdioWrite16Async
+ *
+ *  DESCRIPTION
+ *      Read/write a 16bit value from/to the specified register address.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      address - Register address within the function.
+ *      data - The data to read/write.
+ *      callback - The function to call on operation completion.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The data was successfully read/written.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. Data may have been
+ *                                  partially read/written.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *      NOTE: The CsrSdioRead16Async and CsrSdioWrite16Async functions return
+ *            immediately, and the supplied callback function is called when the
+ *            operation is complete. The result value is given as an argument to
+ *            the callback function.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioRead16(CsrSdioFunction *function, CsrUint32 address, CsrUint16 *data);
+CsrResult CsrSdioWrite16(CsrSdioFunction *function, CsrUint32 address, CsrUint16 data);
+void CsrSdioRead16Async(CsrSdioFunction *function, CsrUint32 address, CsrUint16 *data, CsrSdioAsyncCallback callback);
+void CsrSdioWrite16Async(CsrSdioFunction *function, CsrUint32 address, CsrUint16 data, CsrSdioAsyncCallback callback);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioF0Read8, CsrSdioF0Write8, CsrSdioF0Read8Async,
+ *      CsrSdioF0Write8Async
+ *
+ *  DESCRIPTION
+ *      Read/write an 8bit value from/to the specified register address in
+ *      function 0.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      address - Register address within the function.
+ *      data - The data to read/write.
+ *      callback - The function to call on operation completion.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The data was successfully read/written.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. No data read/written.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *      NOTE: The CsrSdioF0Read8Async and CsrSdioF0Write8Async functions return
+ *            immediately, and the supplied callback function is called when the
+ *            operation is complete. The result value is given as an argument to
+ *            the callback function.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioF0Read8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data);
+CsrResult CsrSdioF0Write8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data);
+void CsrSdioF0Read8Async(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data, CsrSdioAsyncCallback callback);
+void CsrSdioF0Write8Async(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data, CsrSdioAsyncCallback callback);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioRead, CsrSdioWrite, CsrSdioReadAsync, CsrSdioWriteAsync
+ *
+ *  DESCRIPTION
+ *      Read/write a specified number of bytes from/to the specified register
+ *      address.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      address - Register address within the function.
+ *      data - The data to read/write.
+ *      length - Number of byte to read/write.
+ *      callback - The function to call on operation completion.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The data was successfully read/written.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. Data may have been
+ *                                  partially read/written.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *      NOTE: The CsrSdioF0Read8Async and CsrSdioF0Write8Async functions return
+ *            immediately, and the supplied callback function is called when the
+ *            operation is complete. The result value is given as an argument to
+ *            the callback function.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioRead(CsrSdioFunction *function, CsrUint32 address, void *data, CsrUint32 length);
+CsrResult CsrSdioWrite(CsrSdioFunction *function, CsrUint32 address, const void *data, CsrUint32 length);
+void CsrSdioReadAsync(CsrSdioFunction *function, CsrUint32 address, void *data, CsrUint32 length, CsrSdioAsyncCallback callback);
+void CsrSdioWriteAsync(CsrSdioFunction *function, CsrUint32 address, const void *data, CsrUint32 length, CsrSdioAsyncCallback callback);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioPowerOn, CsrSdioPowerOff
+ *
+ *  DESCRIPTION
+ *      Power on/off the device.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function that resides on
+ *                 the device to power on/off.
+ *
+ *  RETURNS (only CsrSdioPowerOn)
+ *      CSR_RESULT_SUCCESS - Power was succesfully reapplied and the device
+ *                                has been reinitialised.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured during reinitialisation.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device during
+ *                                reinitialisation.
+ *      CSR_SDIO_RESULT_NOT_RESET - The power was not removed by the
+ *                                  CsrSdioPowerOff call. The state of the
+ *                                  device is unchanged.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioPowerOn(CsrSdioFunction *function);
+void CsrSdioPowerOff(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioHardReset
+ *
+ *  DESCRIPTION
+ *      Perform a hardware reset of the device.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function that resides on
+ *                 the device to hard reset.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - Reset was succesfully performed and the device
+ *                                has been reinitialised.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured during reinitialisation.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device during
+ *                                reinitialisation.
+ *      CSR_SDIO_RESULT_NOT_RESET - The reset was not applied because it is not
+ *                                  supported. The state of the device is
+ *                                  unchanged.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioHardReset(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionActive, CsrSdioFunctionIdle
+ *
+ *  DESCRIPTION
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSdioFunctionActive(CsrSdioFunction *function);
+void CsrSdioFunctionIdle(CsrSdioFunction *function);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_serialize_primitive_types.c
@@ -0,0 +1,472 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include <linux/module.h>
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+#include "csr_msgconv.h"
+#include "csr_util.h"
+#include "csr_pmem.h"
+#include "csr_lib.h"
+
+void CsrUint8Des(CsrUint8 *value, CsrUint8 *buffer, CsrSize *offset)
+{
+    *value = buffer[*offset];
+    *offset += sizeof(*value);
+}
+EXPORT_SYMBOL_GPL(CsrUint8Des);
+
+void CsrUint16Des(CsrUint16 *value, CsrUint8 *buffer, CsrSize *offset)
+{
+    *value = (buffer[*offset + 0] << 0) |
+             (buffer[*offset + 1] << 8);
+    *offset += sizeof(*value);
+}
+EXPORT_SYMBOL_GPL(CsrUint16Des);
+
+void CsrUint32Des(CsrUint32 *value, CsrUint8 *buffer, CsrSize *offset)
+{
+    *value = (buffer[*offset + 0] << 0) |
+             (buffer[*offset + 1] << 8) |
+             (buffer[*offset + 2] << 16) |
+             (buffer[*offset + 3] << 24);
+    *offset += sizeof(*value);
+}
+EXPORT_SYMBOL_GPL(CsrUint32Des);
+
+void CsrMemCpyDes(void *value, CsrUint8 *buffer, CsrSize *offset, CsrSize length)
+{
+    CsrMemCpy(value, &buffer[*offset], length);
+    *offset += length;
+}
+EXPORT_SYMBOL_GPL(CsrMemCpyDes);
+
+void CsrCharStringDes(CsrCharString **value, CsrUint8 *buffer, CsrSize *offset)
+{
+    *value = CsrStrDup((CsrCharString *) &buffer[*offset]);
+    *offset += CsrStrLen(*value) + 1;
+}
+EXPORT_SYMBOL_GPL(CsrCharStringDes);
+
+void CsrUtf8StringDes(CsrUtf8String **value, CsrUint8 *buffer, CsrSize *offset)
+{
+    *value = (CsrUtf8String *) CsrStrDup((CsrCharString *) &buffer[*offset]);
+    *offset += CsrStrLen((CsrCharString *) *value) + 1;
+}
+
+void CsrUtf16StringDes(CsrUtf16String **value, CsrUint8 *buffer, CsrSize *offset)
+{
+    CsrUint32 length, i;
+
+    CsrUint32Des(&length, buffer, offset);
+
+    *value = CsrPmemAlloc(length * sizeof(**value));
+    for (i = 0; i < length; i++)
+    {
+        CsrUint16Des(&(*value)[i], buffer, offset);
+    }
+}
+
+void CsrSizeDes(CsrSize *value, CsrUint8 *buffer, CsrSize *offset)
+{
+    *value = (buffer[*offset + 0] << 0) |
+             (buffer[*offset + 1] << 8) |
+             (buffer[*offset + 2] << 16) |
+             (buffer[*offset + 3] << 24);
+    *offset += sizeof(*value);
+}
+
+void CsrVoidPtrDes(void **value, CsrUint8 *buffer, CsrSize *offset)
+{
+    CsrSizeDes((CsrSize *) value, buffer, offset);
+}
+
+void CsrUint8Ser(CsrUint8 *buffer, CsrSize *offset, CsrUint8 value)
+{
+    buffer[*offset] = value;
+    *offset += sizeof(value);
+}
+EXPORT_SYMBOL_GPL(CsrUint8Ser);
+
+void CsrUint16Ser(CsrUint8 *buffer, CsrSize *offset, CsrUint16 value)
+{
+    buffer[*offset + 0] = (CsrUint8) ((value >> 0) & 0xFF);
+    buffer[*offset + 1] = (CsrUint8) ((value >> 8) & 0xFF);
+    *offset += sizeof(value);
+}
+EXPORT_SYMBOL_GPL(CsrUint16Ser);
+
+void CsrUint32Ser(CsrUint8 *buffer, CsrSize *offset, CsrUint32 value)
+{
+    buffer[*offset + 0] = (CsrUint8) ((value >> 0) & 0xFF);
+    buffer[*offset + 1] = (CsrUint8) ((value >> 8) & 0xFF);
+    buffer[*offset + 2] = (CsrUint8) ((value >> 16) & 0xFF);
+    buffer[*offset + 3] = (CsrUint8) ((value >> 24) & 0xFF);
+    *offset += sizeof(value);
+}
+EXPORT_SYMBOL_GPL(CsrUint32Ser);
+
+void CsrMemCpySer(CsrUint8 *buffer, CsrSize *offset, const void *value, CsrSize length)
+{
+    CsrMemCpy(&buffer[*offset], value, length);
+    *offset += length;
+}
+EXPORT_SYMBOL_GPL(CsrMemCpySer);
+
+void CsrCharStringSer(CsrUint8 *buffer, CsrSize *offset, const CsrCharString *value)
+{
+    if (value)
+    {
+        CsrStrCpy(((CsrCharString *) &buffer[*offset]), value);
+        *offset += CsrStrLen(value) + 1;
+    }
+    else
+    {
+        CsrUint8Ser(buffer, offset, 0);
+    }
+}
+EXPORT_SYMBOL_GPL(CsrCharStringSer);
+
+void CsrUtf8StringSer(CsrUint8 *buffer, CsrSize *offset, const CsrUtf8String *value)
+{
+    CsrCharStringSer(buffer, offset, (CsrCharString *) value);
+}
+
+void CsrUtf16StringSer(CsrUint8 *buffer, CsrSize *offset, const CsrUtf16String *value)
+{
+    if (value)
+    {
+        CsrUint32 length = CsrUtf16StrLen(value) + 1;
+        CsrUint32 i;
+
+        CsrUint32Ser(buffer, offset, length);
+
+        for (i = 0; i < length; i++)
+        {
+            CsrUint16Ser(buffer, offset, (CsrUint16) value[i]);
+        }
+    }
+    else
+    {
+        CsrUint32Ser(buffer, offset, 0);
+    }
+}
+
+void CsrSizeSer(CsrUint8 *buffer, CsrSize *offset, CsrSize value)
+{
+    buffer[*offset + 0] = (CsrUint8) ((value >> 0) & 0xFF);
+    buffer[*offset + 1] = (CsrUint8) ((value >> 8) & 0xFF);
+    buffer[*offset + 2] = (CsrUint8) ((value >> 16) & 0xFF);
+    buffer[*offset + 3] = (CsrUint8) ((value >> 24) & 0xFF);
+    *offset += sizeof(value);
+}
+
+void CsrVoidPtrSer(CsrUint8 *buffer, CsrSize *offset, void *ptr)
+{
+    CsrSizeSer(buffer, offset, (CsrSize) ptr);
+}
+
+CsrUint32 CsrCharStringSerLen(const CsrCharString *str)
+{
+    if (str)
+    {
+        return (CsrUint32) (CsrStrLen(str) + sizeof(*str));
+    }
+    else
+    {
+        return sizeof(*str);
+    }
+}
+
+CsrUint32 CsrUtf8StringSerLen(const CsrUtf8String *str)
+{
+    if (str)
+    {
+        return (CsrUint32) (CsrStrLen((CsrCharString *) str) + sizeof(*str));
+    }
+    else
+    {
+        return sizeof(*str);
+    }
+}
+
+CsrUint32 CsrUtf16StringSerLen(const CsrUtf16String *str)
+{
+    if (str)
+    {
+        /* We always write down the length of the string */
+        return sizeof(CsrUint32) + (CsrUtf16StrLen(str) + 1) * sizeof(*str);
+    }
+    else
+    {
+        return sizeof(CsrUint32);
+    }
+}
+
+CsrSize CsrEventSizeof(void *msg)
+{
+    return 2;
+}
+
+CsrUint8 *CsrEventSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrEvent *primitive = (CsrEvent *) msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    return ptr;
+}
+
+void *CsrEventDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrEvent *primitive = (CsrEvent *) CsrPmemAlloc(sizeof(CsrEvent));
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+
+    return primitive;
+}
+
+CsrSize CsrEventCsrUint8Sizeof(void *msg)
+{
+    return 3;
+}
+
+CsrUint8 *CsrEventCsrUint8Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrEventCsrUint8 *primitive = (CsrEventCsrUint8 *) msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    CsrUint8Ser(ptr, len, primitive->value);
+    return ptr;
+}
+
+void *CsrEventCsrUint8Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrEventCsrUint8 *primitive = (CsrEventCsrUint8 *) CsrPmemAlloc(sizeof(CsrEventCsrUint8));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+    CsrUint8Des(&primitive->value, buffer, &offset);
+
+    return primitive;
+}
+
+CsrSize CsrEventCsrUint16Sizeof(void *msg)
+{
+    return 4;
+}
+
+CsrUint8 *CsrEventCsrUint16Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrEventCsrUint16 *primitive = (CsrEventCsrUint16 *) msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    CsrUint16Ser(ptr, len, primitive->value);
+    return ptr;
+}
+
+void *CsrEventCsrUint16Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrEventCsrUint16 *primitive = (CsrEventCsrUint16 *) CsrPmemAlloc(sizeof(CsrEventCsrUint16));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+    CsrUint16Des(&primitive->value, buffer, &offset);
+
+    return primitive;
+}
+
+CsrSize CsrEventCsrUint32Sizeof(void *msg)
+{
+    return 6;
+}
+
+CsrUint8 *CsrEventCsrUint32Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrEventCsrUint32 *primitive = (CsrEventCsrUint32 *) msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    CsrUint32Ser(ptr, len, primitive->value);
+    return ptr;
+}
+
+void *CsrEventCsrUint32Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrEventCsrUint32 *primitive = (CsrEventCsrUint32 *) CsrPmemAlloc(sizeof(CsrEventCsrUint32));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+    CsrUint32Des(&primitive->value, buffer, &offset);
+
+    return primitive;
+}
+
+CsrSize CsrEventCsrUint16CsrUint8Sizeof(void *msg)
+{
+    return 5;
+}
+
+CsrUint8 *CsrEventCsrUint16CsrUint8Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrEventCsrUint16CsrUint8 *primitive = (CsrEventCsrUint16CsrUint8 *) msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    CsrUint16Ser(ptr, len, primitive->value1);
+    CsrUint8Ser(ptr, len, primitive->value2);
+    return ptr;
+}
+
+void *CsrEventCsrUint16CsrUint8Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrEventCsrUint16CsrUint8 *primitive = (CsrEventCsrUint16CsrUint8 *) CsrPmemAlloc(sizeof(CsrEventCsrUint16CsrUint8));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+    CsrUint16Des(&primitive->value1, buffer, &offset);
+    CsrUint8Des(&primitive->value2, buffer, &offset);
+
+    return primitive;
+}
+
+CsrSize CsrEventCsrUint16CsrUint16Sizeof(void *msg)
+{
+    return 6;
+}
+
+CsrUint8 *CsrEventCsrUint16CsrUint16Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrEventCsrUint16CsrUint16 *primitive = (CsrEventCsrUint16CsrUint16 *) msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    CsrUint16Ser(ptr, len, primitive->value1);
+    CsrUint16Ser(ptr, len, primitive->value2);
+    return ptr;
+}
+
+void *CsrEventCsrUint16CsrUint16Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrEventCsrUint16CsrUint16 *primitive = (CsrEventCsrUint16CsrUint16 *) CsrPmemAlloc(sizeof(CsrEventCsrUint16CsrUint16));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+    CsrUint16Des(&primitive->value1, buffer, &offset);
+    CsrUint16Des(&primitive->value2, buffer, &offset);
+
+    return primitive;
+}
+
+CsrSize CsrEventCsrUint16CsrUint32Sizeof(void *msg)
+{
+    return 8;
+}
+
+CsrUint8 *CsrEventCsrUint16CsrUint32Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrEventCsrUint16CsrUint32 *primitive = (CsrEventCsrUint16CsrUint32 *) msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    CsrUint16Ser(ptr, len, primitive->value1);
+    CsrUint32Ser(ptr, len, primitive->value2);
+    return ptr;
+}
+
+void *CsrEventCsrUint16CsrUint32Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrEventCsrUint16CsrUint32 *primitive = (CsrEventCsrUint16CsrUint32 *) CsrPmemAlloc(sizeof(CsrEventCsrUint16CsrUint32));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+    CsrUint16Des(&primitive->value1, buffer, &offset);
+    CsrUint32Des(&primitive->value2, buffer, &offset);
+
+    return primitive;
+}
+
+CsrSize CsrEventCsrUint16CsrCharStringSizeof(void *msg)
+{
+    CsrEventCsrUint16CsrCharString *primitive = (CsrEventCsrUint16CsrCharString *) msg;
+    return 4 + CsrStrLen(primitive->value2) + 1;
+}
+
+CsrUint8 *CsrEventCsrUint16CsrCharStringSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrEventCsrUint16CsrCharString *primitive = (CsrEventCsrUint16CsrCharString *) msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    CsrUint16Ser(ptr, len, primitive->value1);
+    CsrCharStringSer(ptr, len, primitive->value2);
+    return ptr;
+}
+
+void *CsrEventCsrUint16CsrCharStringDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrEventCsrUint16CsrCharString *primitive = (CsrEventCsrUint16CsrCharString *) CsrPmemAlloc(sizeof(CsrEventCsrUint16CsrCharString));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+    CsrUint16Des(&primitive->value1, buffer, &offset);
+    CsrCharStringDes(&primitive->value2, buffer, &offset);
+
+    return primitive;
+}
+
+CsrSize CsrEventCsrUint32CsrUint16Sizeof(void *msg)
+{
+    return 8;
+}
+
+CsrUint8 *CsrEventCsrUint32CsrUint16Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrEventCsrUint32CsrUint16 *primitive = (CsrEventCsrUint32CsrUint16 *) msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    CsrUint32Ser(ptr, len, primitive->value1);
+    CsrUint16Ser(ptr, len, primitive->value2);
+    return ptr;
+}
+
+void *CsrEventCsrUint32CsrUint16Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrEventCsrUint32CsrUint16 *primitive = (CsrEventCsrUint32CsrUint16 *) CsrPmemAlloc(sizeof(CsrEventCsrUint32CsrUint16));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+    CsrUint32Des(&primitive->value1, buffer, &offset);
+    CsrUint16Des(&primitive->value2, buffer, &offset);
+
+    return primitive;
+}
+
+CsrSize CsrEventCsrUint32CsrCharStringSizeof(void *msg)
+{
+    CsrEventCsrUint32CsrCharString *primitive = (CsrEventCsrUint32CsrCharString *) msg;
+    return 6 + CsrStrLen(primitive->value2) + 1;
+}
+
+CsrUint8 *CsrEventCsrUint32CsrCharStringSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrEventCsrUint32CsrCharString *primitive = (CsrEventCsrUint32CsrCharString *) msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    CsrUint32Ser(ptr, len, primitive->value1);
+    CsrCharStringSer(ptr, len, primitive->value2);
+    return ptr;
+}
+
+void *CsrEventCsrUint32CsrCharStringDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrEventCsrUint32CsrCharString *primitive = (CsrEventCsrUint32CsrCharString *) CsrPmemAlloc(sizeof(CsrEventCsrUint32CsrCharString));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+    CsrUint32Des(&primitive->value1, buffer, &offset);
+    CsrCharStringDes(&primitive->value2, buffer, &offset);
+
+    return primitive;
+}
--- /dev/null
+++ b/drivers/staging/csr/csr_time.c
@@ -0,0 +1,71 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
+#include <linux/autoconf.h>
+#include <linux/config.h>
+#endif
+
+#include <linux/time.h>
+#include <linux/module.h>
+
+#include "csr_types.h"
+#include "csr_time.h"
+
+CsrTime CsrTimeGet(CsrTime *high)
+{
+    struct timespec ts;
+    CsrUint64 time;
+    CsrTime low;
+
+    ts = current_kernel_time();
+    time = (CsrUint64) ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
+
+    if (high != NULL)
+    {
+        *high = (CsrTime) ((time >> 32) & 0xFFFFFFFF);
+    }
+
+    low = (CsrTime) (time & 0xFFFFFFFF);
+
+    return low;
+}
+EXPORT_SYMBOL_GPL(CsrTimeGet);
+
+void CsrTimeUtcGet(CsrTimeUtc *tod, CsrTime *low, CsrTime *high)
+{
+    struct timespec ts;
+    CsrUint64 time;
+
+    ts = current_kernel_time();
+    time = (CsrUint64) ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
+
+    if (high != NULL)
+    {
+        *high = (CsrTime) ((time >> 32) & 0xFFFFFFFF);
+    }
+
+    if (low != NULL)
+    {
+        *low = (CsrTime) (time & 0xFFFFFFFF);
+    }
+
+    if (tod != NULL)
+    {
+        struct timeval tv;
+        do_gettimeofday(&tv);
+        tod->sec = tv.tv_sec;
+        tod->msec = tv.tv_usec / 1000;
+    }
+}
--- /dev/null
+++ b/drivers/staging/csr/csr_time.h
@@ -0,0 +1,205 @@
+#ifndef CSR_TIME_H__
+#define CSR_TIME_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+
+    NAME
+        CsrTime
+
+    DESCRIPTION
+        Type to hold a value describing the current system time, which is a
+        measure of time elapsed since some arbitrarily defined fixed time
+        reference, usually associated with system startup.
+
+*******************************************************************************/
+typedef CsrUint32 CsrTime;
+
+
+/*******************************************************************************
+
+    NAME
+        CsrTimeUtc
+
+    DESCRIPTION
+        Type to hold a value describing a UTC wallclock time expressed in
+        seconds and milliseconds elapsed since midnight January 1st 1970.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint32 sec;
+    CsrUint16 msec;
+} CsrTimeUtc;
+
+
+/*******************************************************************************
+
+    NAME
+        CsrTimeGet
+
+    DESCRIPTION
+        Returns the current system time in a low and a high part. The low part
+        is expressed in microseconds. The high part is incremented when the low
+        part wraps to provide an extended range.
+
+        The caller may provide a NULL pointer as the high parameter. In this case
+        the function just returns the low part and ignores the high parameter.
+
+        Although the time is expressed in microseconds the actual resolution is
+        platform dependent and can be less. It is recommended that the
+        resolution is at least 10 milliseconds.
+
+    PARAMETERS
+        high - Pointer to variable that will receive the high part of the
+               current system time. Passing NULL is valid.
+
+    RETURNS
+        Low part of current system time in microseconds.
+
+*******************************************************************************/
+CsrTime CsrTimeGet(CsrTime *high);
+
+
+/*******************************************************************************
+
+    NAME
+        CsrTimeUtcGet
+
+    DESCRIPTION
+        Get the current system wallclock time, and optionally the current system
+        time in a low and a high part as would have been returned by
+        CsrTimeGet.
+
+        Although CsrTimeUtc is expressed in seconds and milliseconds, the actual
+        resolution is platform dependent, and can be less. It is recommended
+        that the resolution is at least 1 second.
+
+    PARAMETERS
+        tod - Pointer to variable that will receive the current system
+              wallclock time.
+        low - The low part of the current system time in microseconds. Passing
+              NULL is valid.
+        high - The high part of the current system time in microseconds. Passing
+               NULL is valid.
+
+*******************************************************************************/
+void CsrTimeUtcGet(CsrTimeUtc *tod, CsrTime *low, CsrTime *high);
+
+
+/*------------------------------------------------------------------*/
+/* CsrTime Macros */
+/*------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrTimeAdd
+ *
+ *  DESCRIPTION
+ *      Add two time values. Adding the numbers can overflow the range of a
+ *      CsrTime, so the user must be cautious.
+ *
+ *  RETURNS
+ *      CsrTime - the sum of "t1" and "t2".
+ *
+ *----------------------------------------------------------------------------*/
+#define CsrTimeAdd(t1, t2) ((t1) + (t2))
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrTimeSub
+ *
+ *  DESCRIPTION
+ *      Subtract two time values. Subtracting the numbers can provoke an
+ *      underflow, so the user must be cautious.
+ *
+ *  RETURNS
+ *      CsrTime - "t1" - "t2".
+ *
+ *----------------------------------------------------------------------------*/
+#define CsrTimeSub(t1, t2)    ((CsrInt32) (t1) - (CsrInt32) (t2))
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrTimeEq
+ *
+ *  DESCRIPTION
+ *      Compare two time values.
+ *
+ *  RETURNS
+ *      !0 if "t1" equal "t2", else 0.
+ *
+ *----------------------------------------------------------------------------*/
+#define CsrTimeEq(t1, t2) ((t1) == (t2))
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrTimeGt
+ *
+ *  DESCRIPTION
+ *      Compare two time values.
+ *
+ *  RETURNS
+ *      !0 if "t1" is greater than "t2", else 0.
+ *
+ *----------------------------------------------------------------------------*/
+#define CsrTimeGt(t1, t2) (CsrTimeSub((t1), (t2)) > 0)
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrTimeGe
+ *
+ *  DESCRIPTION
+ *      Compare two time values.
+ *
+ *  RETURNS
+ *      !0 if "t1" is greater than, or equal to "t2", else 0.
+ *
+ *----------------------------------------------------------------------------*/
+#define CsrTimeGe(t1, t2) (CsrTimeSub((t1), (t2)) >= 0)
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrTimeLt
+ *
+ *  DESCRIPTION
+ *      Compare two time values.
+ *
+ *  RETURNS
+ *      !0 if "t1" is less than "t2", else 0.
+ *
+ *----------------------------------------------------------------------------*/
+#define CsrTimeLt(t1, t2) (CsrTimeSub((t1), (t2)) < 0)
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrTimeLe
+ *
+ *  DESCRIPTION
+ *      Compare two time values.
+ *
+ *  RETURNS
+ *      !0 if "t1" is less than, or equal to "t2", else 0.
+ *
+ *----------------------------------------------------------------------------*/
+#define CsrTimeLe(t1, t2) (CsrTimeSub((t1), (t2)) <= 0)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_types.h
@@ -0,0 +1,93 @@
+#ifndef CSR_TYPES_H__
+#define CSR_TYPES_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifdef __KERNEL__
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <linux/string.h>
+#else
+#include <stdint.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include <stdarg.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#undef  FALSE
+#define FALSE (0)
+
+#undef  TRUE
+#define TRUE (1)
+
+/* Basic types */
+typedef size_t CsrSize;         /* Return type of sizeof (ISO/IEC 9899:1990 7.1.6) */
+typedef ptrdiff_t CsrPtrdiff;   /* Type of the result of subtracting two pointers (ISO/IEC 9899:1990 7.1.6) */
+typedef uintptr_t CsrUintptr;   /* Unsigned integer large enough to hold any pointer (ISO/IEC 9899:1999 7.18.1.4) */
+#ifdef __KERNEL__
+typedef ptrdiff_t CsrIntptr;    /* intptr_t is not defined in kernel. Use the equivalent ptrdiff_t. */
+#else
+typedef intptr_t CsrIntptr;     /* Signed integer large enough to hold any pointer (ISO/IEC 9899:1999 7.18.1.4) */
+#endif
+
+/* Unsigned fixed width types */
+typedef uint8_t CsrUint8;
+typedef uint16_t CsrUint16;
+typedef uint32_t CsrUint32;
+
+/* Signed fixed width types */
+typedef int8_t CsrInt8;
+typedef int16_t CsrInt16;
+typedef int32_t CsrInt32;
+
+/* Boolean */
+typedef CsrUint8 CsrBool;
+
+/* String types */
+typedef char CsrCharString;
+typedef CsrUint8 CsrUtf8String;
+typedef CsrUint16 CsrUtf16String;   /* 16-bit UTF16 strings */
+typedef CsrUint32 CsrUint24;
+
+/*
+ * 64-bit integers
+ *
+ * Note: If a given compiler does not support 64-bit types, it is
+ * OK to omit these definitions;  32-bit versions of the code using
+ * these types may be available.  Consult the relevant documentation
+ * or the customer support group for information on this.
+ */
+#define CSR_HAVE_64_BIT_INTEGERS
+typedef uint64_t CsrUint64;
+typedef int64_t CsrInt64;
+
+/*
+ * Floating point
+ *
+ * Note: If a given compiler does not support floating point, it is
+ * OK to omit these definitions;  alternative versions of the code using
+ * these types may be available.  Consult the relevant documentation
+ * or the customer support group for information on this.
+ */
+#define CSR_HAVE_FLOATING_POINT
+typedef float CsrFloat;
+typedef double CsrDouble;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_unicode.h
@@ -0,0 +1,190 @@
+#ifndef CSR_UNICODE_H__
+#define CSR_UNICODE_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+CsrUtf16String *CsrUint32ToUtf16String(CsrUint32 number);
+
+CsrUint32 CsrUtf16StringToUint32(const CsrUtf16String *unicodeString);
+CsrUint32 CsrUtf16StrLen(const CsrUtf16String *unicodeString);
+
+CsrUtf8String *CsrUtf16String2Utf8(const CsrUtf16String *source);
+
+CsrUtf16String *CsrUtf82Utf16String(const CsrUtf8String *utf8String);
+
+CsrUtf16String *CsrUtf16StrCpy(CsrUtf16String *target, const CsrUtf16String *source);
+CsrUtf16String *CsrUtf16StringDuplicate(const CsrUtf16String *source);
+
+CsrUint16 CsrUtf16StrICmp(const CsrUtf16String *string1, const CsrUtf16String *string2);
+CsrUint16 CsrUtf16StrNICmp(const CsrUtf16String *string1, const CsrUtf16String *string2, CsrUint32 count);
+
+CsrUtf16String *CsrUtf16MemCpy(CsrUtf16String *dest, const CsrUtf16String *src, CsrUint32 count);
+CsrUtf16String *CsrUtf16ConcatenateTexts(const CsrUtf16String *inputText1, const CsrUtf16String *inputText2,
+    const CsrUtf16String *inputText3, const CsrUtf16String *inputText4);
+
+CsrUtf16String *CsrUtf16String2XML(CsrUtf16String *str);
+CsrUtf16String *CsrXML2Utf16String(CsrUtf16String *str);
+
+CsrInt32 CsrUtf8StrCmp(const CsrUtf8String *string1, const CsrUtf8String *string2);
+CsrInt32 CsrUtf8StrNCmp(const CsrUtf8String *string1, const CsrUtf8String *string2, CsrSize count);
+CsrUint32 CsrUtf8StringLengthInBytes(const CsrUtf8String *string);
+
+/*******************************************************************************
+
+    NAME
+        CsrUtf8StrTruncate
+
+    DESCRIPTION
+        In-place truncate a string on a UTF-8 character boundary by writing a
+        null character somewhere in the range target[count - 3]:target[count].
+
+        Please note that memory passed must be at least of length count + 1, to
+        ensure space for a full length string that is terminated at
+        target[count], in the event that target[count - 1] is the final byte of
+        a UTF-8 character.
+
+    PARAMETERS
+        target - Target string to truncate.
+        count - The desired length, in bytes, of the resulting string. Depending
+                on the contents, the resulting string length will be between
+                count - 3 and count.
+
+    RETURNS
+        Returns target
+
+*******************************************************************************/
+CsrUtf8String *CsrUtf8StrTruncate(CsrUtf8String *target, CsrSize count);
+
+/*******************************************************************************
+
+    NAME
+        CsrUtf8StrCpy
+
+    DESCRIPTION
+        Copies the null terminated UTF-8 string pointed at by source into the
+        memory pointed at by target, including the terminating null character.
+
+        To avoid overflows, the size of the memory pointed at by target shall be
+        long enough to contain the same UTF-8 string as source (including the
+        terminating null character), and should not overlap in memory with
+        source.
+
+    PARAMETERS
+        target - Pointer to the target memory where the content is to be copied.
+        source - UTF-8 string to be copied.
+
+    RETURNS
+        Returns target
+
+*******************************************************************************/
+CsrUtf8String *CsrUtf8StrCpy(CsrUtf8String *target, const CsrUtf8String *source);
+
+/*******************************************************************************
+
+    NAME
+        CsrUtf8StrNCpy
+
+    DESCRIPTION
+        Copies the first count bytes of source to target. If the end of the
+        source UTF-8 string (which is signaled by a null-character) is found
+        before count bytes have been copied, target is padded with null
+        characters until a total of count bytes have been written to it.
+
+        No null-character is implicitly appended to the end of target, so target
+        will only be null-terminated if the length of the UTF-8 string in source
+        is less than count.
+
+    PARAMETERS
+        target - Pointer to the target memory where the content is to be copied.
+        source - UTF-8 string to be copied.
+        count - Maximum number of bytes to be written to target.
+
+    RETURNS
+        Returns target
+
+*******************************************************************************/
+CsrUtf8String *CsrUtf8StrNCpy(CsrUtf8String *target, const CsrUtf8String *source, CsrSize count);
+
+/*******************************************************************************
+
+    NAME
+        CsrUtf8StrNCpyZero
+
+    DESCRIPTION
+        Equivalent to CsrUtf8StrNCpy, but if the length of source is equal to or
+        greater than count the target string is truncated on a UTF-8 character
+        boundary by writing a null character somewhere in the range
+        target[count - 4]:target[count - 1], leaving the target string
+        unconditionally null terminated in all cases.
+
+        Please note that if the length of source is shorter than count, no
+        truncation will be applied, and the target string will be a one to one
+        copy of source.
+
+    PARAMETERS
+        target - Pointer to the target memory where the content is to be copied.
+        source - UTF-8 string to be copied.
+        count - Maximum number of bytes to be written to target.
+
+    RETURNS
+        Returns target
+
+*******************************************************************************/
+CsrUtf8String *CsrUtf8StrNCpyZero(CsrUtf8String *target, const CsrUtf8String *source, CsrSize count);
+
+/*******************************************************************************
+
+    NAME
+        CsrUtf8StrDup
+
+    DESCRIPTION
+        This function will allocate memory and copy the source string into the
+        allocated memory, which is then returned as a duplicate of the original
+        string. The memory returned must be freed by calling CsrPmemFree when
+        the duplicate is no longer needed.
+
+    PARAMETERS
+        source - UTF-8 string to be duplicated.
+
+    RETURNS
+        Returns a duplicate of source.
+
+*******************************************************************************/
+CsrUtf8String *CsrUtf8StrDup(const CsrUtf8String *source);
+
+CsrUtf8String *CsrUtf8StringConcatenateTexts(const CsrUtf8String *inputText1, const CsrUtf8String *inputText2, const CsrUtf8String *inputText3, const CsrUtf8String *inputText4);
+
+/*
+ * UCS2
+ *
+ * D-13157
+ */
+typedef CsrUint8 CsrUcs2String;
+
+CsrSize CsrUcs2ByteStrLen(const CsrUcs2String *ucs2String);
+CsrSize CsrConverterUcs2ByteStrLen(const CsrUcs2String *str);
+
+CsrUint8 *CsrUcs2ByteString2Utf8(const CsrUcs2String *ucs2String);
+CsrUcs2String *CsrUtf82Ucs2ByteString(const CsrUint8 *utf8String);
+
+CsrUint8 *CsrUtf16String2Ucs2ByteString(const CsrUtf16String *source);
+CsrUtf16String *CsrUcs2ByteString2Utf16String(const CsrUint8 *source);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_utf16.c
@@ -0,0 +1,1136 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+#include <linux/module.h>
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_unicode.h"
+#include "csr_util.h"
+
+#define UNI_SUR_HIGH_START   ((CsrUint32) 0xD800)
+#define UNI_SUR_HIGH_END     ((CsrUint32) 0xDBFF)
+#define UNI_SUR_LOW_START    ((CsrUint32) 0xDC00)
+#define UNI_SUR_LOW_END      ((CsrUint32) 0xDFFF)
+#define UNI_REPLACEMENT_CHAR ((CsrUint32) 0xFFFD)
+#define UNI_HALF_SHIFT       ((CsrUint8) 10)  /* used for shifting by 10 bits */
+#define UNI_HALF_BASE        ((CsrUint32) 0x00010000)
+#define UNI_BYTEMASK         ((CsrUint32) 0xBF)
+#define UNI_BYTEMARK         ((CsrUint32) 0x80)
+
+#define CAPITAL(x)    ((x >= 'a') && (x <= 'z') ? ((x) & 0x00DF) : (x))
+
+/*
+*  Index into the table with the first byte to get the number of trailing bytes in a utf-8 character.
+*  -1 if the byte has an invalid value.
+*
+*  Legal sequences are:
+*
+*  byte  1st      2nd      3rd      4th
+*
+*       00-7F
+*       C2-DF    80-BF
+*       E0       A0-BF    80-BF
+*       E1-EC    80-BF    80-BF
+*       ED       80-9F    80-BF
+*       EE-EF    80-BF    80-BF
+*       F0       90-BF    80-BF    80-BF
+*       F1-F3    80-BF    80-BF    80-BF
+*       F4       80-8F    80-BF    80-BF
+*/
+static const CsrInt8 trailingBytesForUtf8[256] =
+{
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                                 /* 0x00 - 0x1F */
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                                 /* 0x20 - 0x3F */
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                                 /* 0x40 - 0x5F */
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                                 /* 0x60 - 0x7F */
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x80 - 0x9F */
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xA0 - 0xBF */
+    -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                               /* 0xC0 - 0xDF */
+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,                      /* 0xE0 - 0xFF */
+};
+
+/* Values to be substracted from a CsrUint32 when converting from UTF8 to UTF16 */
+static const CsrUint32 offsetsFromUtf8[4] =
+{
+    0x00000000, 0x00003080, 0x000E2080, 0x03C82080
+};
+
+/********************************************************************************
+*
+*   Name:           CsrUint32ToUtf16String
+*
+*   Description:    The function converts an 32 bit number to an UTF-16 string
+*                   that is allocated and 0-terminated.
+*
+*   Input:          32 bit number.
+*
+*   Output:         A string of UTF-16 characters.
+*
+*********************************************************************************/
+CsrUtf16String *CsrUint32ToUtf16String(CsrUint32 number)
+{
+    CsrUint16 count, noOfDigits;
+    CsrUtf16String *output;
+    CsrUint32 tempNumber;
+
+    /* calculate the number of digits in the output */
+    tempNumber = number;
+    noOfDigits = 1;
+    while (tempNumber >= 10)
+    {
+        tempNumber = tempNumber / 10;
+        noOfDigits++;
+    }
+
+    output = (CsrUtf16String *) CsrPmemAlloc(sizeof(CsrUtf16String) * (noOfDigits + 1)); /*add space for 0-termination*/
+
+    tempNumber = number;
+    for (count = noOfDigits; count > 0; count--)
+    {
+        output[count - 1] = (CsrUtf16String) ((tempNumber % 10) + '0');
+        tempNumber = tempNumber / 10;
+    }
+    output[noOfDigits] = '\0';
+
+    return output;
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf16StringToUint32
+*
+*   Description:    The function converts an UTF-16 string that is
+*                   0-terminated into a 32 bit number.
+*
+*   Input:          A string of UTF-16 characters containig a number.
+*
+*   Output:         32 bit number.
+*
+*********************************************************************************/
+CsrUint32 CsrUtf16StringToUint32(const CsrUtf16String *unicodeString)
+{
+    CsrUint16 numLen, count;
+    CsrUint32 newNumber = 0;
+
+    numLen = (CsrUint16) CsrUtf16StrLen(unicodeString);
+
+    if ((numLen > 10) || (numLen == 0) || (unicodeString == NULL)) /*CSRMAX number is 4.294.967.295 */
+    {
+        return 0;
+    }
+
+    for (count = 0; count < numLen; count++)
+    {
+        CsrUtf16String input = unicodeString[count];
+        if ((input < 0x30) || (input > 0x39) || ((newNumber == 0x19999999) && (input > 0x35)) || (newNumber > 0x19999999)) /* chars are present or number is too large now causing number to get to large when *10 */
+        {
+            return 0;
+        }
+
+        newNumber = (newNumber * 10) + (input - 0x30);
+    }
+    return newNumber;
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf16MemCpy
+*
+*   Description:    The function copies count number of 16 bit data elements
+*                   from srv to dest.
+*
+*   Input:          A pointer to an unicoded string.
+*
+*   Output:         A pointer to an unicoded string.
+*
+*********************************************************************************/
+CsrUtf16String *CsrUtf16MemCpy(CsrUtf16String *dest, const CsrUtf16String *src, CsrUint32 count)
+{
+    return CsrMemCpy((CsrUint8 *) dest, (CsrUint8 *) src, count * sizeof(CsrUtf16String));
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf16ConcatenateTexts
+*
+*   Description:    The function merge the contents of 4 unicoded input pointers
+*                   into a new string.
+*
+*   Input:          4 unicoded input strings (UTF-16).
+*
+*   Output:         A new unicoded string (UTF-16) containing the combined strings.
+*
+*********************************************************************************/
+CsrUtf16String *CsrUtf16ConcatenateTexts(const CsrUtf16String *inputText1, const CsrUtf16String *inputText2,
+    const CsrUtf16String *inputText3, const CsrUtf16String *inputText4)
+{
+    CsrUtf16String *outputText;
+    CsrUint32 textLen, textLen1, textLen2, textLen3, textLen4;
+
+    textLen1 = CsrUtf16StrLen(inputText1);
+    textLen2 = CsrUtf16StrLen(inputText2);
+    textLen3 = CsrUtf16StrLen(inputText3);
+    textLen4 = CsrUtf16StrLen(inputText4);
+
+    textLen = textLen1 + textLen2 + textLen3 + textLen4;
+
+    if (textLen == 0) /*stop here is all lengths are 0*/
+    {
+        return NULL;
+    }
+
+    outputText = (CsrUtf16String *) CsrPmemAlloc((textLen + 1) * sizeof(CsrUtf16String)); /* add space for 0-termination*/
+
+
+    if (inputText1 != NULL)
+    {
+        CsrUtf16MemCpy(outputText, inputText1, textLen1);
+    }
+
+    if (inputText2 != NULL)
+    {
+        CsrUtf16MemCpy(&(outputText[textLen1]), inputText2, textLen2);
+    }
+
+    if (inputText3 != NULL)
+    {
+        CsrUtf16MemCpy(&(outputText[textLen1 + textLen2]), inputText3, textLen3);
+    }
+
+    if (inputText4 != NULL)
+    {
+        CsrUtf16MemCpy(&(outputText[textLen1 + textLen2 + textLen3]), inputText4, textLen4);
+    }
+
+    outputText[textLen] = '\0';
+
+    return outputText;
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf16StrLen
+*
+*   Description:    The function returns the number of 16 bit elements present
+*                   in the 0-terminated string.
+*
+*   Input:          0-terminated string of 16 bit unicoded characters.
+*
+*   Output:         The number of 16 bit elements in the string.
+*
+*********************************************************************************/
+CsrUint32 CsrUtf16StrLen(const CsrUtf16String *unicodeString)
+{
+    CsrUint32 length;
+
+    length = 0;
+    if (unicodeString != NULL)
+    {
+        while (*unicodeString)
+        {
+            length++;
+            unicodeString++;
+        }
+    }
+    return length;
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf16String2Utf8
+*
+*   Description:    The function decodes an UTF-16 string into an UTF8 byte
+*                   oriented string.
+*
+*   Input:          0-terminated UTF-16 string characters.
+*
+*   Output:         0-terminated string of byte oriented UTF8 coded characters.
+*
+*********************************************************************************/
+CsrUtf8String *CsrUtf16String2Utf8(const CsrUtf16String *source)
+{
+    CsrUtf8String *dest, *destStart = NULL;
+    CsrUint32 i;
+    CsrUint32 ch;
+    CsrUint32 length;
+    CsrUint32 sourceLength;
+    CsrUint8 bytes;
+    CsrBool appendNull = FALSE;
+
+    CsrUint8 firstByteMark[5] = {0x00, 0x00, 0xC0, 0xE0, 0xF0};
+
+    if (!source)
+    {
+        return NULL;
+    }
+
+    length = 0;
+    sourceLength = CsrUtf16StrLen(source) + 1;
+
+    for (i = 0; i < sourceLength; i++)
+    {
+        ch = source[i];
+        if ((ch >= UNI_SUR_HIGH_START) && (ch <= UNI_SUR_HIGH_END)) /* This is a high surrogate */
+        {
+            if (i + 1 < sourceLength) /* The low surrogate is in the source */
+            {
+                CsrUint32 ch2 = source[++i];
+                if ((ch2 >= UNI_SUR_LOW_START) && (ch2 <= UNI_SUR_LOW_END)) /* And it is a legal low surrogate */
+                {
+                    length += 4;
+                }
+                else /* It is not a low surrogate, instead put a Unicode
+                     'REPLACEMENT CHARACTER' (U+FFFD) */
+                {
+                    length += 3;
+                    i--; /* Substract 1 again as the conversion must continue after the ill-formed code unit */
+                }
+            }
+            else /* The low surrogate does not exist, instead put a Unicode
+                 'REPLACEMENT CHARACTER' (U+FFFD), and the null terminated character */
+            {
+                length += 4;
+            }
+        }
+        else if ((ch >= UNI_SUR_LOW_START) && (ch <= UNI_SUR_LOW_END)) /* The value of UTF-16 is not allowed to be in this range, instead put
+             a Unicode 'REPLACEMENT CHARACTER' (U+FFFD) */
+        {
+            length += 3;
+        }
+        else /* Figure out how many bytes that are required */
+        {
+            if (ch < 0x0080)
+            {
+                length++;
+            }
+            else if (ch < 0x0800)
+            {
+                length += 2;
+            }
+            else
+            {
+                length += 3;
+            }
+        }
+    }
+
+    dest = CsrPmemAlloc(length);
+    destStart = dest;
+
+    for (i = 0; i < sourceLength; i++)
+    {
+        ch = source[i];
+        if ((ch >= UNI_SUR_HIGH_START) && (ch <= UNI_SUR_HIGH_END)) /* This is a high surrogate */
+        {
+            if (i + 1 < sourceLength) /* The low surrogate is in the source */
+            {
+                CsrUint32 ch2 = source[++i];
+                if ((ch2 >= UNI_SUR_LOW_START) && (ch2 <= UNI_SUR_LOW_END)) /* And it is a legal low surrogate, convert to UTF-32 */
+                {
+                    ch = ((ch - UNI_SUR_HIGH_START) << UNI_HALF_SHIFT) + (ch2 - UNI_SUR_LOW_START) + UNI_HALF_BASE;
+                }
+                else /* It is not a low surrogate, instead put a Unicode
+                     'REPLACEMENT CHARACTER' (U+FFFD) */
+                {
+                    ch = UNI_REPLACEMENT_CHAR;
+                    i--; /* Substract 1 again as the conversion must continue after the ill-formed code unit */
+                }
+            }
+            else /* The low surrogate does not exist, instead put a Unicode
+                 'REPLACEMENT CHARACTER' (U+FFFD), and the null terminated character */
+            {
+                ch = UNI_REPLACEMENT_CHAR;
+                appendNull = TRUE;
+            }
+        }
+        else if ((ch >= UNI_SUR_LOW_START) && (ch <= UNI_SUR_LOW_END)) /* The value of UTF-16 is not allowed to be in this range, instead put
+             a Unicode 'REPLACEMENT CHARACTER' (U+FFFD) */
+        {
+            ch = UNI_REPLACEMENT_CHAR;
+        }
+
+        /* Figure out how many bytes that are required */
+        if (ch < (CsrUint32) 0x80)
+        {
+            bytes = 1;
+        }
+        else if (ch < (CsrUint32) 0x800)
+        {
+            bytes = 2;
+        }
+        else if (ch < (CsrUint32) 0x10000)
+        {
+            bytes = 3;
+        }
+        else if (ch < (CsrUint32) 0x110000)
+        {
+            bytes = 4;
+        }
+        else
+        {
+            bytes = 3;
+            ch = UNI_REPLACEMENT_CHAR;
+        }
+
+        dest += bytes;
+
+        switch (bytes) /* Convert character to UTF-8. Note: everything falls through. */
+        {
+            case 4:
+            {
+                *--dest = (CsrUint8) ((ch | UNI_BYTEMARK) & UNI_BYTEMASK);
+                ch >>= 6;
+            }
+            /* FALLTHROUGH */
+            case 3:
+            {
+                *--dest = (CsrUint8) ((ch | UNI_BYTEMARK) & UNI_BYTEMASK);
+                ch >>= 6;
+            }
+            /* FALLTHROUGH */
+            case 2:
+            {
+                *--dest = (CsrUint8) ((ch | UNI_BYTEMARK) & UNI_BYTEMASK);
+                ch >>= 6;
+            }
+            /* FALLTHROUGH */
+            case 1:
+            {
+                *--dest = (CsrUint8) (ch | firstByteMark[bytes]);
+            }
+            /* FALLTHROUGH */
+            default:
+            {
+                break;
+            }
+        }
+
+        dest += bytes;
+    }
+
+    if (appendNull) /* Append the \0 character */
+    {
+        *dest = '\0';
+    }
+
+    return destStart;
+}
+
+/*****************************************************************************
+
+    NAME
+        isLegalUtf8
+
+    DESCRIPTION
+        Returns TRUE if the given UFT-8 code unit is legal as defined by the
+        Unicode standard (see Chapter 3: Conformance, Section 3.9: Unicode
+        Encoding Forms, UTF-8).
+
+        This function assumes that the length parameter is unconditionally
+        correct and that the first byte is already validated by looking it up
+        in the trailingBytesForUtf8 array, which also reveals the number of
+        trailing bytes.
+
+        Legal code units are composed of one of the following byte sequences:
+
+        1st      2nd      3rd      4th
+        --------------------------------
+        00-7F
+        C2-DF    80-BF
+        E0       A0-BF    80-BF
+        E1-EC    80-BF    80-BF
+        ED       80-9F    80-BF
+        EE-EF    80-BF    80-BF
+        F0       90-BF    80-BF    80-BF
+        F1-F3    80-BF    80-BF    80-BF
+        F4       80-8F    80-BF    80-BF
+
+        Please note that this function only checks whether the 2nd, 3rd and
+        4th bytes fall into the valid ranges.
+
+    PARAMETERS
+        codeUnit - pointer to the first byte of the byte sequence composing
+            the code unit to test.
+        length - the number of bytes in the code unit. Valid range is 1 to 4.
+
+    RETURNS
+        TRUE if the given code unit is legal.
+
+*****************************************************************************/
+static CsrBool isLegalUtf8(const CsrUtf8String *codeUnit, CsrUint32 length)
+{
+    const CsrUtf8String *srcPtr = codeUnit + length;
+    CsrUint8 byte;
+
+    switch (length) /* Everything falls through except case 1 */
+    {
+        case 4:
+        {
+            byte = *--srcPtr;
+            if ((byte < 0x80) || (byte > 0xBF))
+            {
+                return FALSE;
+            }
+        }
+        /* Fallthrough */
+        case 3:
+        {
+            byte = *--srcPtr;
+            if ((byte < 0x80) || (byte > 0xBF))
+            {
+                return FALSE;
+            }
+        }
+        /* Fallthrough */
+        case 2:
+        {
+            byte = *--srcPtr;
+            if (byte > 0xBF)
+            {
+                return FALSE;
+            }
+
+            switch (*codeUnit) /* No fallthrough */
+            {
+                case 0xE0:
+                {
+                    if (byte < 0xA0)
+                    {
+                        return FALSE;
+                    }
+                    break;
+                }
+                case 0xED:
+                {
+                    if ((byte < 0x80) || (byte > 0x9F))
+                    {
+                        return FALSE;
+                    }
+                    break;
+                }
+                case 0xF0:
+                {
+                    if (byte < 0x90)
+                    {
+                        return FALSE;
+                    }
+                    break;
+                }
+                case 0xF4:
+                {
+                    if ((byte < 0x80) || (byte > 0x8F))
+                    {
+                        return FALSE;
+                    }
+                    break;
+                }
+                default:
+                {
+                    if (byte < 0x80)
+                    {
+                        return FALSE;
+                    }
+                    break;
+                }
+            }
+        }
+        /* Fallthrough */
+        case 1:
+        default:
+            /* The 1st byte and length are assumed correct */
+            break;
+    }
+
+    return TRUE;
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf82Utf16String
+*
+*   Description:    The function decodes an UTF8 byte oriented string into a
+*                   UTF-16string.
+*
+*   Input:          0-terminated string of byte oriented UTF8 coded characters.
+*
+*   Output:         0-terminated string of UTF-16 characters.
+*
+*********************************************************************************/
+CsrUtf16String *CsrUtf82Utf16String(const CsrUtf8String *utf8String)
+{
+    CsrSize i, length = 0;
+    CsrSize sourceLength;
+    CsrUtf16String *dest = NULL;
+    CsrUtf16String *destStart = NULL;
+    CsrInt8 extraBytes2Read;
+
+    if (!utf8String)
+    {
+        return NULL;
+    }
+    sourceLength = CsrStrLen((CsrCharString *) utf8String);
+
+    for (i = 0; i < sourceLength; i++)
+    {
+        extraBytes2Read = trailingBytesForUtf8[utf8String[i]];
+
+        if (extraBytes2Read == -1) /* Illegal byte value, instead put a Unicode 'REPLACEMENT CHARACTER' (U+FFFD) */
+        {
+            length += 1;
+        }
+        else if (i + extraBytes2Read > sourceLength) /* The extra bytes does not exist, instead put a Unicode 'REPLACEMENT
+             CHARACTER' (U+FFFD), and the null terminated character */
+        {
+            length += 2;
+            break;
+        }
+        else if (isLegalUtf8(&utf8String[i], extraBytes2Read + 1) == FALSE) /* It is not a legal utf-8 character, instead put a Unicode 'REPLACEMENT
+             CHARACTER' (U+FFFD) */
+        {
+            length += 1;
+        }
+        else
+        {
+            if (utf8String[i] > 0xEF) /* Needs a high and a low surrogate */
+            {
+                length += 2;
+            }
+            else
+            {
+                length += 1;
+            }
+            i += extraBytes2Read;
+        }
+    }
+
+    /* Create space for the null terminated character */
+    dest = (CsrUtf16String *) CsrPmemAlloc((1 + length) * sizeof(CsrUtf16String));
+    destStart = dest;
+
+    for (i = 0; i < sourceLength; i++)
+    {
+        extraBytes2Read = trailingBytesForUtf8[utf8String[i]];
+
+        if (extraBytes2Read == -1) /* Illegal byte value, instead put a Unicode 'REPLACEMENT CHARACTER' (U+FFFD) */
+        {
+            *dest++ = UNI_REPLACEMENT_CHAR;
+        }
+        else if (i + extraBytes2Read > sourceLength) /* The extra bytes does not exist, instead put a Unicode 'REPLACEMENT
+             CHARACTER' (U+FFFD), and the null terminated character */
+        {
+            *dest++ = UNI_REPLACEMENT_CHAR;
+            *dest++ = '\0';
+            break;
+        }
+        else if (isLegalUtf8(&utf8String[i], extraBytes2Read + 1) == FALSE) /* It is not a legal utf-8 character, instead put a Unicode 'REPLACEMENT
+             CHARACTER' (U+FFFD) */
+        {
+            *dest++ = UNI_REPLACEMENT_CHAR;
+        }
+        else /* It is legal, convert the character to an CsrUint32 */
+        {
+            CsrUint32 ch = 0;
+
+            switch (extraBytes2Read) /* Everything falls through */
+            {
+                case 3:
+                {
+                    ch += utf8String[i];
+                    ch <<= 6;
+                    i++;
+                }
+                /* FALLTHROUGH */
+                case 2:
+                {
+                    ch += utf8String[i];
+                    ch <<= 6;
+                    i++;
+                }
+                /* FALLTHROUGH */
+                case 1:
+                {
+                    ch += utf8String[i];
+                    ch <<= 6;
+                    i++;
+                }
+                /* FALLTHROUGH */
+                case 0:
+                {
+                    ch += utf8String[i];
+                }
+                /* FALLTHROUGH */
+                default:
+                {
+                    break;
+                }
+            }
+
+            ch -= offsetsFromUtf8[extraBytes2Read];
+
+            if (ch <= 0xFFFF) /* Character can be encoded in one CsrUint16 */
+            {
+                *dest++ = (CsrUint16) ch;
+            }
+            else /* The character needs two CsrUint16 */
+            {
+                ch -= UNI_HALF_BASE;
+                *dest++ = (CsrUint16) ((ch >> UNI_HALF_SHIFT) | UNI_SUR_HIGH_START);
+                *dest++ = (CsrUint16) ((ch & 0x03FF) | UNI_SUR_LOW_START);
+            }
+        }
+    }
+
+    destStart[length] = 0x00;
+
+    return destStart;
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf16StrCpy
+*
+*   Description:    The function copies the contents from one UTF-16 string
+*                   to another UTF-16 string.
+*
+*   Input:          0-terminated UTF-16 string.
+*
+*   Output:         0-terminated UTF-16 string.
+*
+*********************************************************************************/
+CsrUtf16String *CsrUtf16StrCpy(CsrUtf16String *target, const CsrUtf16String *source)
+{
+    if (source) /* if source is not NULL*/
+    {
+        CsrMemCpy(target, source, (CsrUtf16StrLen(source) + 1) * sizeof(CsrUtf16String));
+        return target;
+    }
+    else
+    {
+        return NULL;
+    }
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf16StringDuplicate
+*
+*   Description:    The function allocates a new pointer and copies the input to
+*                   the new pointer.
+*
+*   Input:          0-terminated UTF-16 string.
+*
+*   Output:         Allocated variable0-terminated UTF-16 string.
+*
+*********************************************************************************/
+CsrUtf16String *CsrUtf16StringDuplicate(const CsrUtf16String *source)
+{
+    CsrUtf16String *target = NULL;
+    CsrUint32 length;
+
+    if (source) /* if source is not NULL*/
+    {
+        length = (CsrUtf16StrLen(source) + 1) * sizeof(CsrUtf16String);
+        target = (CsrUtf16String *) CsrPmemAlloc(length);
+        CsrMemCpy(target, source, length);
+    }
+    return target;
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf16StrICmp
+*
+*   Description:    The function compares two UTF-16 strings.
+*
+*   Input:          Two 0-terminated UTF-16 string.
+*
+*   Output:         0: if the strings are identical.
+*
+*********************************************************************************/
+CsrUint16 CsrUtf16StrICmp(const CsrUtf16String *string1, const CsrUtf16String *string2)
+{
+    while (*string1 || *string2)
+    {
+        if (CAPITAL(*string1) != CAPITAL(*string2))
+        {
+            return *string1 - *string2;
+        }
+        string1++;
+        string2++;
+    }
+
+    return 0;
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf16StrNICmp
+*
+*   Description:    The function compares upto count number of elements in the
+*                   two UTF-16 string.
+*
+*   Input:          Two 0-terminated UTF-16 string and a maximum
+*                   number of elements to check.
+*
+*   Output:         0: if the strings are identical.
+*
+*********************************************************************************/
+CsrUint16 CsrUtf16StrNICmp(const CsrUtf16String *string1, const CsrUtf16String *string2, CsrUint32 count)
+{
+    while ((*string1 || *string2) && count--)
+    {
+        if (CAPITAL(*string1) != CAPITAL(*string2))
+        {
+            return *string1 - *string2;
+        }
+        string1++;
+        string2++;
+    }
+
+    return 0;
+}
+
+/********************************************************************************
+*
+*   Name:           CsrUtf16String2XML
+*
+*   Description:    The function converts an unicoded string (UTF-16) into an unicoded XML
+*                   string where some special characters are encoded according to
+*                   the XML spec.
+*
+*   Input:          A unicoded string (UTF-16) which is freed.
+*
+*   Output:         A new unicoded string (UTF-16) containing the converted output.
+*
+*********************************************************************************/
+CsrUtf16String *CsrUtf16String2XML(CsrUtf16String *str)
+{
+    CsrUtf16String *scanString;
+    CsrUtf16String *outputString = NULL;
+    CsrUtf16String *resultString = str;
+    CsrUint32 stringLength = 0;
+    CsrBool encodeChars = FALSE;
+
+    scanString = str;
+    if (scanString)
+    {
+        while (*scanString)
+        {
+            if (*scanString == L'&')
+            {
+                stringLength += 5;
+                encodeChars = TRUE;
+            }
+            else if ((*scanString == L'<') || (*scanString == L'>'))
+            {
+                stringLength += 4;
+                encodeChars = TRUE;
+            }
+            else
+            {
+                stringLength++;
+            }
+
+            scanString++;
+        }
+
+        stringLength++;
+
+        if (encodeChars)
+        {
+            resultString = outputString = CsrPmemAlloc(stringLength * sizeof(CsrUtf16String));
+
+            scanString = str;
+
+            while (*scanString)
+            {
+                if (*scanString == L'&')
+                {
+                    *outputString++ = '&';
+                    *outputString++ = 'a';
+                    *outputString++ = 'm';
+                    *outputString++ = 'p';
+                    *outputString++ = ';';
+                }
+                else if (*scanString == L'<')
+                {
+                    *outputString++ = '&';
+                    *outputString++ = 'l';
+                    *outputString++ = 't';
+                    *outputString++ = ';';
+                }
+                else if (*scanString == L'>')
+                {
+                    *outputString++ = '&';
+                    *outputString++ = 'g';
+                    *outputString++ = 't';
+                    *outputString++ = ';';
+                }
+                else
+                {
+                    *outputString++ = *scanString;
+                }
+
+                scanString++;
+            }
+
+            *outputString++ = 0;
+
+            CsrPmemFree(str);
+        }
+    }
+
+    return resultString;
+}
+
+/********************************************************************************
+*
+*   Name:           CsrXML2Utf16String
+*
+*   Description:    The function converts an unicoded XML string into an unicoded
+*                   string (UTF-16) where some special XML characters are decoded according to
+*                   the XML spec.
+*
+*   Input:          A unicoded XML string which is freed.
+*
+*   Output:         A new unicoded pointer containing the decoded output.
+*
+*********************************************************************************/
+CsrUtf16String *CsrXML2Utf16String(CsrUtf16String *str)
+{
+    CsrUtf16String *scanString;
+    CsrUtf16String *outputString = NULL;
+    CsrUtf16String *resultString = str;
+    CsrUint32 stringLength = 0;
+    CsrBool encodeChars = FALSE;
+
+    scanString = str;
+    if (scanString)
+    {
+        while (*scanString)
+        {
+            if (*scanString == (CsrUtf16String) L'&')
+            {
+                scanString++;
+
+                if (!CsrUtf16StrNICmp(scanString, (CsrUtf16String *) L"AMP;", 4))
+                {
+                    scanString += 3;
+                    encodeChars = TRUE;
+                }
+                else if (!CsrUtf16StrNICmp(scanString, (CsrUtf16String *) L"LT;", 3))
+                {
+                    scanString += 2;
+                    encodeChars = TRUE;
+                }
+                else if (!CsrUtf16StrNICmp(scanString, (CsrUtf16String *) L"GT;", 3))
+                {
+                    scanString += 2;
+                    encodeChars = TRUE;
+                }
+                if (!CsrUtf16StrNICmp(scanString, (CsrUtf16String *) L"APOS;", 5))
+                {
+                    scanString += 4;
+                    encodeChars = TRUE;
+                }
+                if (!CsrUtf16StrNICmp(scanString, (CsrUtf16String *) L"QUOT;", 5))
+                {
+                    scanString += 4;
+                    encodeChars = TRUE;
+                }
+                else
+                {
+                    scanString--;
+                }
+            }
+
+            stringLength++;
+            scanString++;
+        }
+
+        stringLength++;
+
+        if (encodeChars)
+        {
+            resultString = outputString = CsrPmemAlloc(stringLength * sizeof(CsrUtf16String));
+
+            scanString = str;
+
+            while (*scanString)
+            {
+                if (*scanString == L'&')
+                {
+                    scanString++;
+
+                    if (!CsrUtf16StrNICmp(scanString, (CsrUtf16String *) L"AMP;", 4))
+                    {
+                        *outputString++ = L'&';
+                        scanString += 3;
+                    }
+                    else if (!CsrUtf16StrNICmp(scanString, (CsrUtf16String *) L"LT;", 3))
+                    {
+                        *outputString++ = L'<';
+                        scanString += 2;
+                    }
+                    else if (!CsrUtf16StrNICmp(scanString, (CsrUtf16String *) L"GT;", 3))
+                    {
+                        *outputString++ = L'>';
+                        scanString += 2;
+                    }
+                    else if (!CsrUtf16StrNICmp(scanString, (CsrUtf16String *) L"APOS;", 5))
+                    {
+                        *outputString++ = L'\'';
+                        scanString += 4;
+                    }
+                    else if (!CsrUtf16StrNICmp(scanString, (CsrUtf16String *) L"QUOT;", 5))
+                    {
+                        *outputString++ = L'\"';
+                        scanString += 4;
+                    }
+                    else
+                    {
+                        *outputString++ = L'&';
+                        scanString--;
+                    }
+                }
+                else
+                {
+                    *outputString++ = *scanString;
+                }
+
+                scanString++;
+            }
+
+            *outputString++ = 0;
+
+            CsrPmemFree(str);
+        }
+    }
+
+    return resultString;
+}
+
+CsrInt32 CsrUtf8StrCmp(const CsrUtf8String *string1, const CsrUtf8String *string2)
+{
+    return CsrStrCmp((const CsrCharString *) string1, (const CsrCharString *) string2);
+}
+
+CsrInt32 CsrUtf8StrNCmp(const CsrUtf8String *string1, const CsrUtf8String *string2, CsrSize count)
+{
+    return CsrStrNCmp((const CsrCharString *) string1, (const CsrCharString *) string2, count);
+}
+
+CsrUint32 CsrUtf8StringLengthInBytes(const CsrUtf8String *string)
+{
+    CsrSize length = 0;
+    if (string)
+    {
+        length = CsrStrLen((const CsrCharString *) string);
+    }
+    return (CsrUint32) length;
+}
+
+CsrUtf8String *CsrUtf8StrCpy(CsrUtf8String *target, const CsrUtf8String *source)
+{
+    return (CsrUtf8String *) CsrStrCpy((CsrCharString *) target, (const CsrCharString *) source);
+}
+
+CsrUtf8String *CsrUtf8StrTruncate(CsrUtf8String *target, CsrSize count)
+{
+    CsrSize lastByte = count - 1;
+
+    target[count] = '\0';
+
+    if (count && (target[lastByte] & 0x80))
+    {
+        /* the last byte contains non-ascii char */
+        if (target[lastByte] & 0x40)
+        {
+            /* multi-byte char starting just before truncation */
+            target[lastByte] = '\0';
+        }
+        else if ((target[lastByte - 1] & 0xE0) == 0xE0)
+        {
+            /* 3-byte char starting 2 bytes before truncation */
+            target[lastByte - 1] = '\0';
+        }
+        else if ((target[lastByte - 2] & 0xF0) == 0xF0)
+        {
+            /* 4-byte char starting 3 bytes before truncation */
+            target[lastByte - 2] = '\0';
+        }
+    }
+
+    return target;
+}
+
+CsrUtf8String *CsrUtf8StrNCpy(CsrUtf8String *target, const CsrUtf8String *source, CsrSize count)
+{
+    return (CsrUtf8String *) CsrStrNCpy((CsrCharString *) target, (const CsrCharString *) source, count);
+}
+
+CsrUtf8String *CsrUtf8StrNCpyZero(CsrUtf8String *target, const CsrUtf8String *source, CsrSize count)
+{
+    CsrStrNCpy((CsrCharString *) target, (const CsrCharString *) source, count);
+    if (target[count - 1] != '\0')
+    {
+        CsrUtf8StrTruncate(target, count - 1);
+    }
+    return target;
+}
+
+CsrUtf8String *CsrUtf8StrDup(const CsrUtf8String *source)
+{
+    return (CsrUtf8String *) CsrStrDup((const CsrCharString *) source);
+}
+
+CsrUtf8String *CsrUtf8StringConcatenateTexts(const CsrUtf8String *inputText1, const CsrUtf8String *inputText2, const CsrUtf8String *inputText3, const CsrUtf8String *inputText4)
+{
+    CsrUtf8String *outputText;
+    CsrUint32 textLen, textLen1, textLen2, textLen3, textLen4;
+
+    textLen1 = CsrUtf8StringLengthInBytes(inputText1);
+    textLen2 = CsrUtf8StringLengthInBytes(inputText2);
+    textLen3 = CsrUtf8StringLengthInBytes(inputText3);
+    textLen4 = CsrUtf8StringLengthInBytes(inputText4);
+
+    textLen = textLen1 + textLen2 + textLen3 + textLen4;
+
+    if (textLen == 0) /*stop here is all lengths are 0*/
+    {
+        return NULL;
+    }
+
+    outputText = (CsrUtf8String *) CsrPmemAlloc((textLen + 1) * sizeof(CsrUtf8String)); /* add space for 0-termination*/
+
+
+    if (inputText1 != NULL)
+    {
+        CsrUtf8StrNCpy(outputText, inputText1, textLen1);
+    }
+
+    if (inputText2 != NULL)
+    {
+        CsrUtf8StrNCpy(&(outputText[textLen1]), inputText2, textLen2);
+    }
+
+    if (inputText3 != NULL)
+    {
+        CsrUtf8StrNCpy(&(outputText[textLen1 + textLen2]), inputText3, textLen3);
+    }
+
+    if (inputText4 != NULL)
+    {
+        CsrUtf8StrNCpy(&(outputText[textLen1 + textLen2 + textLen3]), inputText4, textLen4);
+    }
+
+    outputText[textLen] = '\0';
+
+    return outputText;
+}
--- /dev/null
+++ b/drivers/staging/csr/csr_util.c
@@ -0,0 +1,435 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <stdarg.h>
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_util.h"
+
+/*------------------------------------------------------------------*/
+/* Bits */
+/*------------------------------------------------------------------*/
+
+/* Time proportional with the number of 1's */
+CsrUint8 CsrBitCountSparse(CsrUint32 n)
+{
+    CsrUint8 count = 0;
+
+    while (n)
+    {
+        count++;
+        n &= (n - 1);
+    }
+
+    return count;
+}
+
+/* Time proportional with the number of 0's */
+CsrUint8 CsrBitCountDense(CsrUint32 n)
+{
+    CsrUint8 count = 8 * sizeof(CsrUint32);
+
+    n ^= (CsrUint32) (-1);
+
+    while (n)
+    {
+        count--;
+        n &= (n - 1);
+    }
+
+    return count;
+}
+
+/*------------------------------------------------------------------*/
+/* Base conversion */
+/*------------------------------------------------------------------*/
+CsrBool CsrHexStrToUint8(const CsrCharString *string, CsrUint8 *returnValue)
+{
+    CsrUint16 currentIndex = 0;
+    *returnValue = 0;
+    if ((string[currentIndex] == '0') && (CSR_TOUPPER(string[currentIndex + 1]) == 'X'))
+    {
+        string += 2;
+    }
+    if (((string[currentIndex] >= '0') && (string[currentIndex] <= '9')) || ((CSR_TOUPPER(string[currentIndex]) >= 'A') && (CSR_TOUPPER(string[currentIndex]) <= 'F')))
+    {
+        while (((string[currentIndex] >= '0') && (string[currentIndex] <= '9')) || ((CSR_TOUPPER(string[currentIndex]) >= 'A') && (CSR_TOUPPER(string[currentIndex]) <= 'F')))
+        {
+            *returnValue = (CsrUint8) (*returnValue * 16 + (((string[currentIndex] >= '0') && (string[currentIndex] <= '9')) ? string[currentIndex] - '0' : CSR_TOUPPER(string[currentIndex]) - 'A' + 10));
+            currentIndex++;
+            if (currentIndex >= 2)
+            {
+                break;
+            }
+        }
+        return TRUE;
+    }
+    return FALSE;
+}
+
+CsrBool CsrHexStrToUint16(const CsrCharString *string, CsrUint16 *returnValue)
+{
+    CsrUint16 currentIndex = 0;
+    *returnValue = 0;
+    if ((string[currentIndex] == '0') && (CSR_TOUPPER(string[currentIndex + 1]) == 'X'))
+    {
+        string += 2;
+    }
+    if (((string[currentIndex] >= '0') && (string[currentIndex] <= '9')) || ((CSR_TOUPPER(string[currentIndex]) >= 'A') && (CSR_TOUPPER(string[currentIndex]) <= 'F')))
+    {
+        while (((string[currentIndex] >= '0') && (string[currentIndex] <= '9')) || ((CSR_TOUPPER(string[currentIndex]) >= 'A') && (CSR_TOUPPER(string[currentIndex]) <= 'F')))
+        {
+            *returnValue = (CsrUint16) (*returnValue * 16 + (((string[currentIndex] >= '0') && (string[currentIndex] <= '9')) ? string[currentIndex] - '0' : CSR_TOUPPER(string[currentIndex]) - 'A' + 10));
+            currentIndex++;
+            if (currentIndex >= 4)
+            {
+                break;
+            }
+        }
+        return TRUE;
+    }
+    return FALSE;
+}
+
+CsrBool CsrHexStrToUint32(const CsrCharString *string, CsrUint32 *returnValue)
+{
+    CsrUint16 currentIndex = 0;
+    *returnValue = 0;
+    if ((string[currentIndex] == '0') && (CSR_TOUPPER(string[currentIndex + 1]) == 'X'))
+    {
+        string += 2;
+    }
+    if (((string[currentIndex] >= '0') && (string[currentIndex] <= '9')) || ((CSR_TOUPPER(string[currentIndex]) >= 'A') && (CSR_TOUPPER(string[currentIndex]) <= 'F')))
+    {
+        while (((string[currentIndex] >= '0') && (string[currentIndex] <= '9')) || ((CSR_TOUPPER(string[currentIndex]) >= 'A') && (CSR_TOUPPER(string[currentIndex]) <= 'F')))
+        {
+            *returnValue = *returnValue * 16 + (((string[currentIndex] >= '0') && (string[currentIndex] <= '9')) ? string[currentIndex] - '0' : CSR_TOUPPER(string[currentIndex]) - 'A' + 10);
+            currentIndex++;
+            if (currentIndex >= 8)
+            {
+                break;
+            }
+        }
+        return TRUE;
+    }
+    return FALSE;
+}
+
+CsrUint32 CsrPow(CsrUint32 base, CsrUint32 exponent)
+{
+    if (exponent == 0)
+    {
+        return 1;
+    }
+    else
+    {
+        CsrUint32 i, t = base;
+
+        for (i = 1; i < exponent; i++)
+        {
+            t = t * base;
+        }
+        return t;
+    }
+}
+
+/* Convert signed 32 bit (or less) integer to string */
+#define I2B10_MAX 12
+void CsrIntToBase10(CsrInt32 number, CsrCharString *str)
+{
+    CsrInt32 digit;
+    CsrUint8 index;
+    CsrCharString res[I2B10_MAX];
+    CsrBool foundDigit = FALSE;
+
+    for (digit = 0; digit < I2B10_MAX; digit++)
+    {
+        res[digit] = '\0';
+    }
+
+    /* Catch sign - and deal with positive numbers only afterwards */
+    index = 0;
+    if (number < 0)
+    {
+        res[index++] = '-';
+        number = -1 * number;
+    }
+
+    digit = 1000000000;
+    if (number > 0)
+    {
+        while ((index < I2B10_MAX - 1) && (digit > 0))
+        {
+            /* If the foundDigit flag is TRUE, this routine should be proceeded.
+            Otherwise the number which has '0' digit cannot be converted correctly */
+            if (((number / digit) > 0) || foundDigit)
+            {
+                foundDigit = TRUE; /* set foundDigit flag to TRUE*/
+                res[index++] = (char) ('0' + (number / digit));
+                number = number % digit;
+            }
+
+            digit = digit / 10;
+        }
+    }
+    else
+    {
+        res[index] = (char) '0';
+    }
+
+    CsrStrCpy(str, res);
+}
+
+void CsrUInt16ToHex(CsrUint16 number, CsrCharString *str)
+{
+    CsrUint16 index;
+    CsrUint16 currentValue;
+
+    for (index = 0; index < 4; index++)
+    {
+        currentValue = (CsrUint16) (number & 0x000F);
+        number >>= 4;
+        str[3 - index] = (char) (currentValue > 9 ? currentValue + 55 : currentValue + '0');
+    }
+    str[4] = '\0';
+}
+
+void CsrUInt32ToHex(CsrUint32 number, CsrCharString *str)
+{
+    CsrUint16 index;
+    CsrUint32 currentValue;
+
+    for (index = 0; index < 8; index++)
+    {
+        currentValue = (CsrUint32) (number & 0x0000000F);
+        number >>= 4;
+        str[7 - index] = (char) (currentValue > 9 ? currentValue + 55 : currentValue + '0');
+    }
+    str[8] = '\0';
+}
+
+/*------------------------------------------------------------------*/
+/*  String */
+/*------------------------------------------------------------------*/
+void *CsrMemCpy(void *dest, const void *src, CsrSize count)
+{
+    return memcpy(dest, src, count);
+}
+EXPORT_SYMBOL_GPL(CsrMemCpy);
+
+void *CsrMemSet(void *dest, CsrUint8 c, CsrSize count)
+{
+    return memset(dest, c, count);
+}
+EXPORT_SYMBOL_GPL(CsrMemSet);
+
+void *CsrMemMove(void *dest, const void *src, CsrSize count)
+{
+    return memmove(dest, src, count);
+}
+EXPORT_SYMBOL_GPL(CsrMemMove);
+
+CsrInt32 CsrMemCmp(const void *buf1, const void *buf2, CsrSize count)
+{
+    return memcmp(buf1, buf2, count);
+}
+EXPORT_SYMBOL_GPL(CsrMemCmp);
+
+void *CsrMemDup(const void *buf1, CsrSize count)
+{
+    void *buf2 = NULL;
+
+    if (buf1)
+    {
+        buf2 = CsrPmemAlloc(count);
+        CsrMemCpy(buf2, buf1, count);
+    }
+
+    return buf2;
+}
+
+CsrCharString *CsrStrCpy(CsrCharString *dest, const CsrCharString *src)
+{
+    return strcpy(dest, src);
+}
+
+CsrCharString *CsrStrNCpy(CsrCharString *dest, const CsrCharString *src, CsrSize count)
+{
+    return strncpy(dest, src, count);
+}
+
+CsrCharString *CsrStrCat(CsrCharString *dest, const CsrCharString *src)
+{
+    return strcat(dest, src);
+}
+
+CsrCharString *CsrStrNCat(CsrCharString *dest, const CsrCharString *src, CsrSize count)
+{
+    return strncat(dest, src, count);
+}
+
+CsrCharString *CsrStrStr(const CsrCharString *string1, const CsrCharString *string2)
+{
+    return strstr(string1, string2);
+}
+
+CsrSize CsrStrLen(const CsrCharString *string)
+{
+    return strlen(string);
+}
+EXPORT_SYMBOL_GPL(CsrStrLen);
+
+CsrInt32 CsrStrCmp(const CsrCharString *string1, const CsrCharString *string2)
+{
+    return strcmp(string1, string2);
+}
+
+CsrInt32 CsrStrNCmp(const CsrCharString *string1, const CsrCharString *string2, CsrSize count)
+{
+    return strncmp(string1, string2, count);
+}
+
+CsrCharString *CsrStrChr(const CsrCharString *string, CsrCharString c)
+{
+    return strchr(string, c);
+}
+
+CsrInt32 CsrVsnprintf(CsrCharString *string, CsrSize count, const CsrCharString *format, va_list args)
+{
+    return vsnprintf(string, count, format, args);
+}
+EXPORT_SYMBOL_GPL(CsrVsnprintf);
+
+CsrCharString *CsrStrNCpyZero(CsrCharString *dest,
+    const CsrCharString *src,
+    CsrSize count)
+{
+    CsrStrNCpy(dest, src, count - 1);
+    dest[count - 1] = '\0';
+    return dest;
+}
+
+/* Convert string with base 10 to integer */
+CsrUint32 CsrStrToInt(const CsrCharString *str)
+{
+    CsrInt16 i;
+    CsrUint32 res;
+    CsrUint32 digit;
+
+    res = 0;
+    digit = 1;
+
+    /* Start from the string end */
+    for (i = (CsrUint16) (CsrStrLen(str) - 1); i >= 0; i--)
+    {
+        /* Only convert numbers */
+        if ((str[i] >= '0') && (str[i] <= '9'))
+        {
+            res += digit * (str[i] - '0');
+            digit = digit * 10;
+        }
+    }
+
+    return res;
+}
+
+CsrCharString *CsrStrDup(const CsrCharString *string)
+{
+    CsrCharString *copy;
+    CsrUint32 len;
+
+    copy = NULL;
+    if (string != NULL)
+    {
+        len = CsrStrLen(string) + 1;
+        copy = CsrPmemAlloc(len);
+        CsrMemCpy(copy, string, len);
+    }
+    return copy;
+}
+
+int CsrStrNICmp(const CsrCharString *string1,
+    const CsrCharString *string2,
+    CsrSize count)
+{
+    CsrUint32 index;
+    int returnValue = 0;
+
+    for (index = 0; index < count; index++)
+    {
+        if (CSR_TOUPPER(string1[index]) != CSR_TOUPPER(string2[index]))
+        {
+            if (CSR_TOUPPER(string1[index]) > CSR_TOUPPER(string2[index]))
+            {
+                returnValue = 1;
+            }
+            else
+            {
+                returnValue = -1;
+            }
+            break;
+        }
+        if (string1[index] == '\0')
+        {
+            break;
+        }
+    }
+    return returnValue;
+}
+
+const CsrCharString *CsrGetBaseName(const CsrCharString *file)
+{
+    const CsrCharString *pch;
+    static const CsrCharString dotDir[] = ".";
+
+    if (!file)
+    {
+        return NULL;
+    }
+
+    if (file[0] == '\0')
+    {
+        return dotDir;
+    }
+
+    pch = file + CsrStrLen(file) - 1;
+
+    while (*pch != '\\' && *pch != '/' && *pch != ':')
+    {
+        if (pch == file)
+        {
+            return pch;
+        }
+        --pch;
+    }
+
+    return ++pch;
+}
+
+/*------------------------------------------------------------------*/
+/* Misc */
+/*------------------------------------------------------------------*/
+CsrBool CsrIsSpace(CsrUint8 c)
+{
+    switch (c)
+    {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+            return TRUE;
+        default:
+            return FALSE;
+    }
+}
--- /dev/null
+++ b/drivers/staging/csr/csr_util.h
@@ -0,0 +1,75 @@
+#ifndef CSR_UTIL_H__
+#define CSR_UTIL_H__
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "csr_types.h"
+#include "csr_macro.h"
+
+/*------------------------------------------------------------------*/
+/* Bits - intended to operate on CsrUint32 values */
+/*------------------------------------------------------------------*/
+CsrUint8 CsrBitCountSparse(CsrUint32 n);
+CsrUint8 CsrBitCountDense(CsrUint32 n);
+
+/*------------------------------------------------------------------*/
+/* Base conversion */
+/*------------------------------------------------------------------*/
+CsrBool CsrHexStrToUint8(const CsrCharString *string, CsrUint8 *returnValue);
+CsrBool CsrHexStrToUint16(const CsrCharString *string, CsrUint16 *returnValue);
+CsrBool CsrHexStrToUint32(const CsrCharString *string, CsrUint32 *returnValue);
+CsrUint32 CsrPow(CsrUint32 base, CsrUint32 exponent);
+void CsrIntToBase10(CsrInt32 number, CsrCharString *str);
+void CsrUInt16ToHex(CsrUint16 number, CsrCharString *str);
+void CsrUInt32ToHex(CsrUint32 number, CsrCharString *str);
+
+/*------------------------------------------------------------------*/
+/*  String */
+/*------------------------------------------------------------------*/
+void *CsrMemCpy(void *dest, const void *src, CsrSize count);
+void *CsrMemSet(void *dest, CsrUint8 c, CsrSize count);
+void *CsrMemMove(void *dest, const void *src, CsrSize count);
+CsrInt32 CsrMemCmp(const void *buf1, const void *buf2, CsrSize count);
+void *CsrMemDup(const void *buf1, CsrSize count);
+CsrCharString *CsrStrCpy(CsrCharString *dest, const CsrCharString *src);
+CsrCharString *CsrStrNCpy(CsrCharString *dest, const CsrCharString *src, CsrSize count);
+int CsrStrNICmp(const CsrCharString *string1, const CsrCharString *string2, CsrSize count);
+CsrCharString *CsrStrCat(CsrCharString *dest, const CsrCharString *src);
+CsrCharString *CsrStrNCat(CsrCharString *dest, const CsrCharString *src, CsrSize count);
+CsrCharString *CsrStrStr(const CsrCharString *string1, const CsrCharString *string2);
+CsrSize CsrStrLen(const CsrCharString *string);
+CsrInt32 CsrStrCmp(const CsrCharString *string1, const CsrCharString *string2);
+CsrInt32 CsrStrNCmp(const CsrCharString *string1, const CsrCharString *string2, CsrSize count);
+CsrCharString *CsrStrDup(const CsrCharString *string);
+CsrCharString *CsrStrChr(const CsrCharString *string, CsrCharString c);
+CsrUint32 CsrStrToInt(const CsrCharString *string);
+CsrInt32 CsrVsnprintf(CsrCharString *string, CsrSize count, const CsrCharString *format, va_list args);
+CsrCharString *CsrStrNCpyZero(CsrCharString *dest, const CsrCharString *src, CsrSize count);
+
+/*------------------------------------------------------------------*/
+/* Filename */
+/*------------------------------------------------------------------*/
+const CsrCharString *CsrGetBaseName(const CsrCharString *file);
+
+/*------------------------------------------------------------------*/
+/* Misc */
+/*------------------------------------------------------------------*/
+CsrBool CsrIsSpace(CsrUint8 c);
+#define CsrOffsetOf(st, m)  ((CsrSize) & ((st *) 0)->m)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_common.h
@@ -0,0 +1,109 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifndef CSR_WIFI_COMMON_H__
+#define CSR_WIFI_COMMON_H__
+
+#include "csr_types.h"
+#include "csr_result.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* MAC address */
+typedef struct
+{
+    CsrUint8 a[6];
+} CsrWifiMacAddress;
+
+/* IPv4 address */
+typedef struct
+{
+    CsrUint8 a[4];
+} CsrWifiIp4Address;
+
+/* IPv6 address */
+typedef struct
+{
+    CsrUint8 a[16];
+} CsrWifiIp6Address;
+
+typedef struct
+{
+    CsrUint8 ssid[32];
+    CsrUint8 length;
+} CsrWifiSsid;
+
+/*******************************************************************************
+
+  DESCRIPTION
+    Result values used on the Wifi Interfaces
+
+ VALUES
+    CSR_RESULT_SUCCESS
+                   - The request/procedure succeeded
+    CSR_RESULT_FAILURE
+                   - The request/procedure did not succeed because of an error
+    CSR_WIFI_RESULT_NOT_FOUND
+                   - The request did not succeed because some resource was not
+                     found.
+    CSR_WIFI_RESULT_TIMED_OUT
+                   - The request/procedure did not succeed because of a time out
+    CSR_WIFI_RESULT_CANCELLED
+                   - The request was canceled due to another conflicting
+                     request that was issued before this one was completed
+    CSR_WIFI_RESULT_INVALID_PARAMETER
+                   - The request/procedure did not succeed because it had an
+                     invalid parameter
+    CSR_WIFI_RESULT_NO_ROOM
+                   - The request did not succeed due to a lack of resources,
+                     e.g. out of memory problem.
+    CSR_WIFI_RESULT_UNSUPPORTED
+                   - The request/procedure did not succeed because the feature
+                     is not supported yet
+    CSR_WIFI_RESULT_UNAVAILABLE
+                   - The request cannot be processed at this time
+    CSR_WIFI_RESULT_WIFI_OFF
+                   - The requested action is not available because Wi-Fi is
+                     currently off
+    CSR_WIFI_RESULT_SECURITY_ERROR
+                   - The request/procedure did not succeed because of a security
+                     error
+    CSR_WIFI_RESULT_MIB_SET_FAILURE
+                   - MIB Set Failure: either the MIB OID to be written to does
+                     not exist or the MIB Value is invalid.
+    CSR_WIFI_RESULT_INVALID_INTERFACE_TAG
+                   - The supplied Interface Tag is not valid.
+    CSR_WIFI_RESULT_P2P_NOA_CONFIG_CONFLICT
+                   - The new NOA configuration conflicts with the existing NOA configuration
+                     hence not accepted"
+*******************************************************************************/
+#define CSR_WIFI_RESULT_NOT_FOUND                 ((CsrResult) 0x0001)
+#define CSR_WIFI_RESULT_TIMED_OUT                 ((CsrResult) 0x0002)
+#define CSR_WIFI_RESULT_CANCELLED                 ((CsrResult) 0x0003)
+#define CSR_WIFI_RESULT_INVALID_PARAMETER         ((CsrResult) 0x0004)
+#define CSR_WIFI_RESULT_NO_ROOM                   ((CsrResult) 0x0005)
+#define CSR_WIFI_RESULT_UNSUPPORTED               ((CsrResult) 0x0006)
+#define CSR_WIFI_RESULT_UNAVAILABLE               ((CsrResult) 0x0007)
+#define CSR_WIFI_RESULT_WIFI_OFF                  ((CsrResult) 0x0008)
+#define CSR_WIFI_RESULT_SECURITY_ERROR            ((CsrResult) 0x0009)
+#define CSR_WIFI_RESULT_MIB_SET_FAILURE           ((CsrResult) 0x000A)
+#define CSR_WIFI_RESULT_INVALID_INTERFACE_TAG     ((CsrResult) 0x000B)
+#define CSR_WIFI_RESULT_P2P_NOA_CONFIG_CONFLICT   ((CsrResult) 0x000C)
+
+#define CSR_WIFI_VERSION	"5.0.3.0"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_fsm.h
@@ -0,0 +1,250 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifndef CSR_WIFI_FSM_H
+#define CSR_WIFI_FSM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_prim_defs.h"
+#include "csr_log_text.h"
+#include "csr_wifi_fsm_event.h"
+
+/* including this file for CsrWifiInterfaceMode*/
+#include "csr_wifi_common.h"
+
+#define CSR_WIFI_FSM_ENV       (0xFFFF)
+
+/**
+ * @brief
+ *   Toplevel FSM context data
+ *
+ * @par Description
+ *   Holds ALL FSM static and dynamic data for a FSM
+ */
+typedef struct CsrWifiFsmContext CsrWifiFsmContext;
+
+/**
+ * @brief
+ *   FSM External Wakeup CallbackFunction Pointer
+ *
+ * @par Description
+ *   Defines the external wakeup function for the FSM
+ *   to call when an external event is injected into the systen
+ *
+ * @param[in]    context : External context
+ *
+ * @return
+ *   void
+ */
+typedef void (*CsrWifiFsmExternalWakupCallbackPtr)(void *context);
+
+/**
+ * @brief
+ *   Initialises a top level FSM context
+ *
+ * @par Description
+ *   Initialises the FSM Context to an initial state and allocates
+ *   space for "maxProcesses" number of instances
+ *
+ * @param[in]    osaContext         : OSA context
+ * @param[in]    applicationContext : Internal fsm application context
+ * @param[in]    externalContext    : External context
+ * @param[in]    maxProcesses       : Max processes to allocate room for
+ *
+ * @return
+ *   CsrWifiFsmContext* fsm context
+ */
+extern CsrWifiFsmContext* CsrWifiFsmInit(void *applicationContext, void *externalContext, CsrUint16 maxProcesses, CsrLogTextTaskId loggingTaskId);
+
+/**
+ * @brief
+ *   Resets the FSM's back to first conditions
+ *
+ * @par Description
+ *   This function is used to free any dynamic resources allocated for the
+ *   given context by CsrWifiFsmInit().
+ *   The FSM's reset function is called to cleanup any fsm specific memory
+ *   The reset funtion does NOT need to free the fsm data pointer as
+ *   CsrWifiFsmShutdown() will do it.
+ *   the FSM's init function is call again to reinitialise the FSM context.
+ *   CsrWifiFsmReset() should NEVER be called when CsrWifiFsmExecute() is running.
+ *
+ * @param[in]    context    : FSM context
+ *
+ * @return
+ *   void
+ */
+extern void CsrWifiFsmReset(CsrWifiFsmContext *context);
+
+/**
+ * @brief
+ *   Frees resources allocated by CsrWifiFsmInit
+ *
+ * @par Description
+ *   This function is used to free any dynamic resources allocated for the
+ *   given context by CsrWifiFsmInit(), prior to complete termination of
+ *   the program.
+ *   The FSM's reset function is called to cleanup any fsm specific memory.
+ *   The reset funtion does NOT need to free the fsm data pointer as
+ *   CsrWifiFsmShutdown() will do it.
+ *   CsrWifiFsmShutdown() should NEVER be called when CsrWifiFsmExecute() is running.
+ *
+ * @param[in]    context       : FSM context
+ *
+ * @return
+ *   void
+ */
+extern void CsrWifiFsmShutdown(CsrWifiFsmContext *context);
+
+/**
+ * @brief
+ *   Executes the fsm context
+ *
+ * @par Description
+ *   Executes the FSM context and runs until ALL events in the context are processed.
+ *   When no more events are left to process then CsrWifiFsmExecute() returns to a time
+ *   specifying when to next call the CsrWifiFsmExecute()
+ *   Scheduling, threading, blocking and external event notification are outside
+ *   the scope of the FSM and CsrWifiFsmExecute().
+ *
+ * @param[in]    context  : FSM context
+ *
+ * @return
+ *   CsrUint32    Time in ms until next timeout or 0xFFFFFFFF for no timer set
+ */
+extern CsrUint32 CsrWifiFsmExecute(CsrWifiFsmContext *context);
+
+/**
+ * @brief
+ *   Adds an event to the FSM context's external event queue for processing
+ *
+ * @par Description
+ *   Adds an event to the contexts external queue
+ *   This is thread safe and adds an event to the fsm's external event queue.
+ *
+ * @param[in]    context      : FSM context
+ * @param[in]    event        : event to add to the event queue
+ * @param[in]    source       : source of the event (this can be a synergy task queue or an fsm instance id)
+ * @param[in]    destination  : destination of the event (This can be a fsm instance id or CSR_WIFI_FSM_ENV)
+ * @param[in]    id           : event id
+ *
+ * @return
+ *   void
+ */
+extern void CsrWifiFsmSendEventExternal(CsrWifiFsmContext *context, CsrWifiFsmEvent *event, CsrUint16 source, CsrUint16 destination, CsrPrim primtype, CsrUint16 id);
+
+/**
+ * @brief
+ *   Adds an Alien event to the FSM context's external event queue for processing
+ *
+ * @par Description
+ *   Adds an event to the contexts external queue
+ *   This is thread safe and adds an event to the fsm's external event queue.
+ *
+ * @param[in]    context      : FSM context
+ * @param[in]    event        : event to add to the event queue
+ * @param[in]    source       : source of the event (this can be a synergy task queue or an fsm instance id)
+ * @param[in]    destination  : destination of the event (This can be a fsm instance id or CSR_WIFI_FSM_ENV)
+ * @param[in]    id           : event id
+ */
+#define CsrWifiFsmSendAlienEventExternal(_context, _alienEvent, _source, _destination, _primtype, _id) \
+    { \
+        CsrWifiFsmAlienEvent *_evt = (CsrWifiFsmAlienEvent *)CsrPmemAlloc(sizeof(CsrWifiFsmAlienEvent)); \
+        _evt->alienEvent = _alienEvent; \
+        CsrWifiFsmSendEventExternal(_context, (CsrWifiFsmEvent *)_evt, _source, _destination, _primtype, _id); \
+    }
+
+
+/**
+ * @brief
+ *   Current time of day in ms
+ *
+ * @param[in]    context   : FSM context
+ *
+ * @return
+ *   CsrUint32 32 bit ms tick
+ */
+extern CsrUint32 CsrWifiFsmGetTimeOfDayMs(CsrWifiFsmContext *context);
+
+/**
+ * @brief
+ *   Gets the time until the next FSM timer expiry
+ *
+ * @par Description
+ *   Returns the next timeout time or 0 if no timers are set.
+ *
+ * @param[in]    context    : FSM context
+ *
+ * @return
+ *   CsrUint32    Time in ms until next timeout or 0xFFFFFFFF for no timer set
+ */
+extern CsrUint32 CsrWifiFsmGetNextTimeout(CsrWifiFsmContext *context);
+
+/**
+ * @brief
+ *   Fast forwards the fsm timers by ms Milliseconds
+ *
+ * @param[in]  context : FSM context
+ * @param[in]  ms      : Milliseconds to fast forward by
+ *
+ * @return
+ *   void
+ */
+extern void CsrWifiFsmFastForward(CsrWifiFsmContext *context, CsrUint16 ms);
+
+/**
+ * @brief
+ *   shift the current time of day by ms amount
+ *
+ * @par Description
+ *   usefull to speed up tests where time needs to pass
+ *
+ * @param[in]    context  : FSM context
+ * @param[in]    ms       : ms to adjust time by
+ *
+ * @return
+ *   void
+ */
+extern void CsrWifiFsmTestAdvanceTime(CsrWifiFsmContext *context, CsrUint32 ms);
+
+/**
+ * @brief
+ *    Check if the fsm has events to process
+ *
+ * @param[in]    context    : FSM context
+ *
+ * @return
+ *   CsrBool returns TRUE if there are events for the FSM to process
+ */
+extern CsrBool CsrWifiFsmHasEvents(CsrWifiFsmContext *context);
+
+/**
+ * @brief
+ *   function that installs the contexts wakeup function
+ *
+ * @param[in]    context    : FSM context
+ * @param[in]    callback   : Callback function pointer
+ *
+ * @return
+ *   void
+ */
+extern void CsrWifiFsmInstallWakeupCallback(CsrWifiFsmContext *context, CsrWifiFsmExternalWakupCallbackPtr callback);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_FSM_H */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_fsm_event.h
@@ -0,0 +1,51 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifndef CSR_WIFI_FSM_EVENT_H
+#define CSR_WIFI_FSM_EVENT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+#include "csr_sched.h"
+
+/**
+ * @brief
+ *   FSM event header.
+ *
+ * @par Description
+ *   All events MUST have this struct as the FIRST member.
+ *   The next member is used internally for linked lists
+ */
+typedef struct CsrWifiFsmEvent
+{
+    CsrPrim     type;
+    CsrUint16   primtype;
+    CsrSchedQid destination;
+    CsrSchedQid source;
+
+    /* Private pointer to allow an optimal Event list */
+    /* NOTE: Ignore this pointer.
+     *       Do not waste code initializing OR freeing it.
+     *       The pointer is used internally in the CsrWifiFsm code
+     *       to avoid a second malloc when queuing events.
+     */
+    struct CsrWifiFsmEvent *next;
+} CsrWifiFsmEvent;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_FSM_EVENT_H */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_fsm_types.h
@@ -0,0 +1,441 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifndef CSR_WIFI_FSM_TYPES_H
+#define CSR_WIFI_FSM_TYPES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "csr_types.h"
+#include "csr_util.h"
+#include "csr_pmem.h"
+#include "csr_panic.h"
+#include "csr_sched.h"
+
+#ifdef CSR_WIFI_FSM_MUTEX_ENABLE
+#include "csr_framework_ext.h"
+#endif
+
+#include "csr_wifi_fsm.h"
+
+#define CSR_WIFI_FSM_MAX_TRANSITION_HISTORY 10
+
+/**
+ * @brief
+ *   FSM event list header.
+ *
+ * @par Description
+ *   Singly linked list of events.
+ */
+typedef struct CsrWifiFsmEventList
+{
+    CsrWifiFsmEvent *first;
+    CsrWifiFsmEvent *last;
+} CsrWifiFsmEventList;
+
+
+/**
+ * @brief
+ *   FSM timer id.
+ *
+ * @par Description
+ *   Composite Id made up of the type, dest and a unique id so
+ *   CsrWifiFsmRemoveTimer knows where to look when removing the timer
+ */
+typedef struct CsrWifiFsmTimerId
+{
+    CsrPrim     type;
+    CsrUint16   primtype;
+    CsrSchedQid destination;
+    CsrUint16   uniqueid;
+} CsrWifiFsmTimerId;
+
+/**
+ * @brief
+ *   FSM timer header.
+ *
+ * @par Description
+ *   All timer MUST have this struct as the FIRST member.
+ *   The first members of the structure MUST remain compatable
+ *   with the CsrWifiFsmEvent so that timers are just specialised events
+ */
+typedef struct CsrWifiFsmTimer
+{
+    CsrPrim     type;
+    CsrUint16   primtype;
+    CsrSchedQid destination;
+    CsrSchedQid source;
+
+    /* Private pointer to allow an optimal Event list */
+    struct CsrWifiFsmTimer *next;
+
+    CsrWifiFsmTimerId timerid;
+    CsrUint32         timeoutTimeMs;
+} CsrWifiFsmTimer;
+
+
+/**
+ * @brief
+ *   Fsm Alien Event
+ *
+ * @par Description
+ *   Allows the wrapping of alien events that do not use CsrWifiFsmEvent
+ *   as the first member of the Event struct
+ */
+typedef struct
+{
+    CsrWifiFsmEvent event;
+    void           *alienEvent;
+} CsrWifiFsmAlienEvent;
+
+
+/**
+ * @brief
+ *   FSM timer list header.
+ *
+ * @par Description
+ *   Singly linked list of timers.
+ */
+typedef struct CsrWifiFsmTimerList
+{
+    CsrWifiFsmTimer *first;
+    CsrWifiFsmTimer *last;
+    CsrUint16        nexttimerid;
+} CsrWifiFsmTimerList;
+
+/**
+ * @brief
+ *   Process Entry Function Pointer
+ *
+ * @par Description
+ *   Defines the entry function for a processes.
+ *   Called at process initialisation.
+ *
+ * @param[in]    context : FSM context
+ *
+ * @return
+ *   void
+ */
+typedef void (*CsrWifiFsmProcEntryFnPtr)(CsrWifiFsmContext *context);
+
+/**
+ * @brief
+ *   Process Transition Function Pointer
+ *
+ * @par Description
+ *   Defines a transition function for a processes.
+ *   Called when an event causes a transition on a process
+ *
+ * @param[in]    CsrWifiFsmContext* : FSM context
+ * @param[in]    void* : FSM data (can be NULL)
+ * @param[in]    const CsrWifiFsmEvent*  : event to process
+ *
+ * @return
+ *   void
+ */
+typedef void (*CsrWifiFsmTransitionFnPtr)(CsrWifiFsmContext *context, void *fsmData, const CsrWifiFsmEvent *event);
+
+/**
+ * @brief
+ *   Process reset/shutdown Function Pointer
+ *
+ * @par Description
+ *   Defines the reset/shutdown function for a processes.
+ *   Called to reset or shutdown an fsm.
+ *
+ * @param[in]    context      : FSM context
+ *
+ * @return
+ *   void
+ */
+typedef void (*CsrWifiFsmProcResetFnPtr)(CsrWifiFsmContext *context);
+
+/**
+ * @brief
+ *   FSM Default Destination CallbackFunction Pointer
+ *
+ * @par Description
+ *   Defines the default destination function for the FSM
+ *   to call when an event does not have a valid destination.
+ *   This
+ *
+ * @param[in]    context : External context
+ *
+ * @return
+ *   CsrUint16 a valid destination OR CSR_WIFI_FSM_ENV
+ */
+typedef CsrUint16 (*CsrWifiFsmDestLookupCallbackPtr)(void *context, const CsrWifiFsmEvent *event);
+
+
+#ifdef CSR_WIFI_FSM_DUMP_ENABLE
+/**
+ * @brief
+ *   Trace Dump Function Pointer
+ *
+ * @par Description
+ *   Called when we want to trace the FSM
+ *
+ * @param[in]    context : FSM context
+ * @param[in]    id      : fsm id
+ *
+ * @return
+ *   void
+ */
+typedef void (*CsrWifiFsmDumpFnPtr)(CsrWifiFsmContext *context, void *fsmData);
+#endif
+
+/**
+ * @brief
+ *   Event ID to transition function entry
+ *
+ * @par Description
+ *   Event ID to Transition Entry in a state table.
+ */
+typedef struct
+{
+    CsrUint32                 eventid;
+    CsrWifiFsmTransitionFnPtr transition;
+#ifdef CSR_LOG_ENABLE
+    const CsrCharString *transitionName;
+#endif
+} CsrWifiFsmEventEntry;
+
+/**
+ * @brief
+ *   Single State's Transition Table
+ *
+ * @par Description
+ *   Stores Data for a single State's event to
+ *   transition functions mapping
+ */
+typedef struct
+{
+    const CsrUint8              numEntries;
+    const CsrBool               saveAll;
+    const CsrWifiFsmEventEntry *eventEntryArray; /* array of transition function pointers for state */
+#ifdef CSR_LOG_ENABLE
+    CsrUint16            stateNumber;
+    const CsrCharString *stateName;
+#endif
+} CsrWifiFsmTableEntry;
+
+/**
+ * @brief
+ *   Process State Transtion table
+ *
+ * @par Description
+ *   Stores Data for a processes State to transition table
+ */
+typedef struct
+{
+    CsrUint16                   numStates;         /* number of states    */
+    const CsrWifiFsmTableEntry *aStateEventMatrix; /* state event matrix  */
+} CsrWifiFsmTransitionFunctionTable;
+
+/**
+ * @brief
+ *   Const Process definition
+ *
+ * @par Description
+ *   Constant process specification.
+ *   This is ALL the non dynamic data that defines
+ *   a process.
+ */
+typedef struct
+{
+    const CsrCharString                    *processName;
+    const CsrUint32                         processId;
+    const CsrWifiFsmTransitionFunctionTable transitionTable;
+    const CsrWifiFsmTableEntry              unhandledTransitions;
+    const CsrWifiFsmTableEntry              ignoreFunctions;
+    const CsrWifiFsmProcEntryFnPtr          entryFn;
+    const CsrWifiFsmProcResetFnPtr          resetFn;
+#ifdef CSR_WIFI_FSM_DUMP_ENABLE
+    const CsrWifiFsmDumpFnPtr dumpFn;               /* Called to dump fsm specific trace if not NULL */
+#endif
+} CsrWifiFsmProcessStateMachine;
+
+#ifdef CSR_WIFI_FSM_DUMP_ENABLE
+/**
+ * @brief
+ *   Storage for state transition info
+ */
+typedef struct
+{
+    CsrUint16                 transitionNumber;
+    CsrWifiFsmEvent           event;
+    CsrUint16                 fromState;
+    CsrUint16                 toState;
+    CsrWifiFsmTransitionFnPtr transitionFn;
+    CsrUint16                 transitionCount; /* number consecutive of times this transition was seen */
+#ifdef CSR_LOG_ENABLE
+    const CsrCharString *transitionName;
+#endif
+} CsrWifiFsmTransitionRecord;
+
+/**
+ * @brief
+ *   Storage for the last state X transitions
+ */
+typedef struct
+{
+    CsrUint16                  numTransitions;
+    CsrWifiFsmTransitionRecord records[CSR_WIFI_FSM_MAX_TRANSITION_HISTORY];
+} CsrWifiFsmTransitionRecords;
+#endif
+
+/**
+ * @brief
+ *   Dynamic Process data
+ *
+ * @par Description
+ *   Dynamic process data that is used to keep track of the
+ *   state and data for a process instance
+ */
+typedef struct
+{
+    const CsrWifiFsmProcessStateMachine *fsmInfo;         /* state machine info that is constant regardless of context */
+    CsrUint16                            instanceId;      /* Runtime process id */
+    CsrUint16                            state;           /* Current state */
+    void                                *params;          /* Instance user data */
+    CsrWifiFsmEventList                  savedEventQueue; /* The saved event queue */
+    struct CsrWifiFsmInstanceEntry      *subFsm;          /* Sub Fsm instance data */
+    struct CsrWifiFsmInstanceEntry      *subFsmCaller;    /* The Fsm instance that created the SubFsm and should be used for callbacks*/
+#ifdef CSR_WIFI_FSM_DUMP_ENABLE
+    CsrWifiFsmTransitionRecords transitionRecords;        /* Last X transitions in the FSM */
+#endif
+} CsrWifiFsmInstanceEntry;
+
+/**
+ * @brief
+ *   OnCreate Callback Function Pointer
+ *
+ * @par Description
+ *   Called when an fsm is created.
+ *
+ * @param[in]    extContext : External context
+ * @param[in]    instance : FSM instance
+ *
+ * @return
+ *   void
+ */
+typedef void (*CsrWifiFsmOnCreateFnPtr)(void *extContext, const CsrWifiFsmInstanceEntry *instance);
+
+/**
+ * @brief
+ *   OnTransition Callback Function Pointer
+ *
+ * @par Description
+ *   Called when an event is processed by a fsm
+ *
+ * @param[in]    extContext : External context
+ * @param[in]    eventEntryArray : Entry data
+ * @param[in]    event : Event
+ *
+ * @return
+ *   void
+ */
+typedef void (*CsrWifiFsmOnTransitionFnPtr)(void *extContext, const CsrWifiFsmEventEntry *eventEntryArray, const CsrWifiFsmEvent *event);
+
+/**
+ * @brief
+ *   OnStateChange Callback Function Pointer
+ *
+ * @par Description
+ *   Called when CsrWifiFsmNextState is called
+ *
+ * @param[in]    extContext : External context
+ *
+ * @return
+ *   void
+ */
+typedef void (*CsrWifiFsmOnStateChangeFnPtr)(void *extContext, CsrUint16 nextstate);
+
+/**
+ * @brief
+ *   OnIgnore,OnError or OnInvalid Callback Function Pointer
+ *
+ * @par Description
+ *   Called when an event is processed by a fsm
+ *
+ * @param[in]    extContext : External context
+ * @param[in]    event : Event
+ *
+ * @return
+ *   void
+ */
+typedef void (*CsrWifiFsmOnEventFnPtr)(void *extContext, const CsrWifiFsmEvent *event);
+
+/**
+ * @brief
+ *   Toplevel FSM context data
+ *
+ * @par Description
+ *   Holds ALL FSM static and dynamic data for a FSM
+ */
+struct CsrWifiFsmContext
+{
+    CsrWifiFsmEventList eventQueue;                           /* The internal event queue                     */
+    CsrWifiFsmEventList externalEventQueue;                   /* The external event queue                     */
+#ifdef CSR_WIFI_FSM_MUTEX_ENABLE
+    CsrMutexHandle externalEventQueueLock;                    /* The external event queue mutex               */
+#endif
+    CsrUint32                          timeOffset;            /* Amount to adjust the TimeOfDayMs by          */
+    CsrWifiFsmTimerList                timerQueue;            /* The internal timer queue                     */
+    CsrBool                            useTempSaveList;       /* Should the temp save list be used            */
+    CsrWifiFsmEventList                tempSaveList;          /* The temp save event queue                    */
+    CsrWifiFsmEvent                   *eventForwardedOrSaved; /* The event that was forwarded or Saved        */
+    CsrUint16                          maxProcesses;          /* Size of instanceArray                        */
+    CsrUint16                          numProcesses;          /* Current number allocated in instanceArray    */
+    CsrWifiFsmInstanceEntry           *instanceArray;         /* Array of processes for this component        */
+    CsrWifiFsmInstanceEntry           *ownerInstance;         /* The Process that owns currentInstance (SubFsm support) */
+    CsrWifiFsmInstanceEntry           *currentInstance;       /* Current Process that is executing            */
+    CsrWifiFsmExternalWakupCallbackPtr externalEventFn;       /* External event Callback                      */
+    CsrWifiFsmOnEventFnPtr             appIgnoreCallback;     /* Application Ignore event Callback            */
+    CsrWifiFsmDestLookupCallbackPtr    appEvtDstCallback;     /* Application Lookup event Destination Function*/
+
+    void            *applicationContext;                      /* Internal fsm application context             */
+    void            *externalContext;                         /* External context (set by the user of the fsm)*/
+    CsrLogTextTaskId loggingTaskId;                           /* Task Id to use in any logging output         */
+
+#ifndef CSR_WIFI_FSM_SCHEDULER_DISABLED
+    CsrSchedTid schedTimerId;                                 /* Scheduler TimerId for use in Scheduler Tasks */
+    CsrUint32   schedTimerNexttimeoutMs;                      /* Next timeout time for the current timer      */
+#endif
+
+#ifdef CSR_WIFI_FSM_MUTEX_ENABLE
+#ifdef CSR_WIFI_FSM_TRANSITION_LOCK
+    CsrMutexHandle transitionLock;                     /* Lock when calling transition functions        */
+#endif
+#endif
+
+#ifdef CSR_LOG_ENABLE
+    CsrWifiFsmOnCreateFnPtr      onCreate;             /* Debug Transition Callback                    */
+    CsrWifiFsmOnTransitionFnPtr  onTransition;         /* Debug Transition Callback                    */
+    CsrWifiFsmOnTransitionFnPtr  onUnhandedCallback;   /* Unhanded event Callback                      */
+    CsrWifiFsmOnStateChangeFnPtr onStateChange;        /* Debug State Change Callback                  */
+    CsrWifiFsmOnEventFnPtr       onIgnoreCallback;     /* Ignore event Callback                        */
+    CsrWifiFsmOnEventFnPtr       onSaveCallback;       /* Save event Callback                          */
+    CsrWifiFsmOnEventFnPtr       onErrorCallback;      /* Error event Callback                         */
+    CsrWifiFsmOnEventFnPtr       onInvalidCallback;    /* Invalid event Callback                       */
+#endif
+#ifdef CSR_WIFI_FSM_DUMP_ENABLE
+    CsrUint16 masterTransitionNumber;                  /* Increments on every transition              */
+#endif
+};
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_FSM_TYPES_H */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_card.h
@@ -0,0 +1,114 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ ******************************************************************************
+ * FILE : csr_wifi_hip_card.h
+ *
+ * PURPOSE : Defines abstract interface for hardware specific functions.
+ *           Note, this is a different file from one of the same name in the
+ *           Windows driver.
+ *
+ *****************************************************************************
+ */
+#ifndef __CARD_H__
+#define __CARD_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "csr_wifi_hip_card_sdio.h"
+#include "csr_wifi_hip_signals.h"
+#include "csr_wifi_hip_unifi_udi.h"
+
+
+/*****************************************************************************
+ * CardEnableInt -
+ */
+CsrResult CardEnableInt(card_t *card);
+
+/*****************************************************************************
+ * CardGenInt -
+ */
+CsrResult CardGenInt(card_t *card);
+
+/*****************************************************************************
+ * CardPendingInt -
+ */
+CsrResult CardPendingInt(card_t *card, CsrBool *pintr);
+
+/*****************************************************************************
+ * CardDisableInt -
+ */
+CsrResult CardDisableInt(card_t *card);
+
+/*****************************************************************************
+ * CardClearInt -
+ */
+CsrResult CardClearInt(card_t *card);
+
+/*****************************************************************************
+ * CardDisable -
+ */
+void CardDisable(card_t *card);
+
+/*****************************************************************************
+ * CardIntEnabled -
+ */
+CsrResult CardIntEnabled(card_t *card, CsrBool *enabled);
+
+/*****************************************************************************
+ * CardGetDataSlotSize
+ */
+CsrUint16 CardGetDataSlotSize(card_t *card);
+
+/*****************************************************************************
+ * CardWriteBulkData -
+ */
+CsrResult CardWriteBulkData(card_t *card, card_signal_t *csptr, unifi_TrafficQueue queue);
+
+
+/*****************************************************************************
+ * CardClearFromHostDataSlot -
+ */
+void CardClearFromHostDataSlot(card_t *card, const CsrInt16 aSlotNum);
+
+/*****************************************************************************
+ * CardGetFreeFromHostDataSlots -
+ */
+CsrUint16 CardGetFreeFromHostDataSlots(card_t *card);
+
+CsrUint16 CardAreAllFromHostDataSlotsEmpty(card_t *card);
+
+CsrResult card_start_processor(card_t *card, enum unifi_dbg_processors_select which);
+
+CsrResult card_wait_for_firmware_to_start(card_t *card, CsrUint32 *paddr);
+
+CsrResult unifi_dl_firmware(card_t *card, void *arg);
+CsrResult unifi_dl_patch(card_t *card, void *arg, CsrUint32 boot_ctrl);
+CsrResult unifi_do_loader_op(card_t *card, CsrUint32 op_addr, CsrUint8 opcode);
+void* unifi_dl_fw_read_start(card_t *card, CsrInt8 is_fw);
+
+CsrResult unifi_coredump_handle_request(card_t *card);
+
+CsrResult ConvertCsrSdioToCsrHipResult(card_t *card, CsrResult csrResult);
+#ifdef CSR_WIFI_HIP_DEBUG_OFFLINE
+void unifi_debug_log_to_buf(const CsrCharString *fmt, ...);
+void unifi_debug_string_to_buf(const CsrCharString *str);
+void unifi_debug_hex_to_buf(const CsrCharString *buff, CsrUint16 length);
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CARD_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_card_sdio.c
@@ -0,0 +1,4128 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ * FILE: csr_wifi_hip_card_sdio.c
+ *
+ * PURPOSE: Implementation of the Card API for SDIO.
+ *
+ * NOTES:
+ *      CardInit() is called from the SDIO probe callback when a card is
+ *      inserted. This performs the basic SDIO initialisation, enabling i/o
+ *      etc.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_conversions.h"
+#include "csr_wifi_hip_unifiversion.h"
+#include "csr_wifi_hip_card.h"
+#include "csr_wifi_hip_card_sdio.h"
+#include "csr_wifi_hip_chiphelper.h"
+
+
+/* Time to wait between attempts to read MAILBOX0 */
+#define MAILBOX1_TIMEOUT                10  /* in millisecs */
+#define MAILBOX1_ATTEMPTS               200 /* 2 seconds */
+
+#define MAILBOX2_TIMEOUT                5   /* in millisecs */
+#define MAILBOX2_ATTEMPTS               10  /* 50ms */
+
+#define MAILBOX2_RESET_ATTEMPTS         10
+#define MAILBOX2_RESET_TIMEOUT          5   /* in millisecs */
+
+#define RESET_SETTLE_DELAY              25  /* in millisecs */
+
+static CsrResult card_init_slots(card_t *card);
+static CsrResult card_hw_init(card_t *card);
+static CsrResult firmware_present_in_flash(card_t *card);
+static void bootstrap_chip_hw(card_t *card);
+static CsrResult unifi_reset_hardware(card_t *card);
+static CsrResult unifi_hip_init(card_t *card);
+static CsrResult card_access_panic(card_t *card);
+static CsrResult unifi_read_chip_version(card_t *card);
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_alloc_card
+ *
+ *      Allocate and initialise the card context structure.
+ *
+ *  Arguments:
+ *      sdio            Pointer to SDIO context pointer to pass to low
+ *                      level i/o functions.
+ *      ospriv          Pointer to O/S private struct to pass when calling
+ *                      callbacks to the higher level system.
+ *
+ *  Returns:
+ *      Pointer to card struct, which represents the driver context or
+ *      NULL if the allocation failed.
+ * ---------------------------------------------------------------------------
+ */
+card_t* unifi_alloc_card(CsrSdioFunction *sdio, void *ospriv)
+{
+    card_t *card;
+    CsrUint32 i;
+
+    func_enter();
+
+
+    card = (card_t *)CsrMemAlloc(sizeof(card_t));
+    if (card == NULL)
+    {
+        return NULL;
+    }
+    CsrMemSet(card, 0, sizeof(card_t));
+
+
+    card->sdio_if = sdio;
+    card->ospriv  = ospriv;
+
+    card->unifi_interrupt_seq = 1;
+
+    /* Make these invalid. */
+    card->proc_select = (CsrUint32)(-1);
+    card->dmem_page = (CsrUint32)(-1);
+    card->pmem_page = (CsrUint32)(-1);
+
+    card->bh_reason_host = 0;
+    card->bh_reason_unifi = 0;
+
+    for (i = 0; i < sizeof(card->tx_q_paused_flag) / sizeof(card->tx_q_paused_flag[0]); i++)
+    {
+        card->tx_q_paused_flag[i] = 0;
+    }
+    card->memory_resources_allocated = 0;
+
+    card->low_power_mode = UNIFI_LOW_POWER_DISABLED;
+    card->periodic_wake_mode = UNIFI_PERIODIC_WAKE_HOST_DISABLED;
+
+    card->host_state = UNIFI_HOST_STATE_AWAKE;
+    card->intmode = CSR_WIFI_INTMODE_DEFAULT;
+
+    /*
+     * Memory resources for buffers are allocated when the chip is initialised
+     * because we need configuration information from the firmware.
+     */
+
+    /*
+     * Initialise wait queues and lists
+     */
+    card->fh_command_queue.q_body = card->fh_command_q_body;
+    card->fh_command_queue.q_length = UNIFI_SOFT_COMMAND_Q_LENGTH;
+
+    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+    {
+        card->fh_traffic_queue[i].q_body = card->fh_traffic_q_body[i];
+        card->fh_traffic_queue[i].q_length = UNIFI_SOFT_TRAFFIC_Q_LENGTH;
+    }
+
+
+    /* Initialise mini-coredump pointers in case no coredump buffers
+     * are requested by the OS layer.
+     */
+    card->request_coredump_on_reset = 0;
+    card->dump_next_write = NULL;
+    card->dump_cur_read = NULL;
+    card->dump_buf = NULL;
+
+#ifdef UNIFI_DEBUG
+    /* Determine offset of LSB in pointer for later alignment sanity check.
+     * Synergy integer types have specific widths, which cause compiler
+     * warnings when casting pointer types, e.g. on 64-bit systems.
+     */
+    {
+        CsrUint32 val = 0x01234567;
+
+        if (*((CsrUint8 *)&val) == 0x01)
+        {
+            card->lsb = sizeof(void *) - 1;     /* BE */
+        }
+        else
+        {
+            card->lsb = 0;                      /* LE */
+        }
+    }
+#endif
+    func_exit();
+    return card;
+} /* unifi_alloc_card() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_init_card
+ *
+ *      Reset the hardware and perform HIP initialization
+ *
+ *  Arguments:
+ *      card        Pointer to card struct
+ *
+ *  Returns:
+ *      CsrResult code
+ *      CSR_RESULT_SUCCESS if successful
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_init_card(card_t *card, CsrInt32 led_mask)
+{
+    CsrResult r;
+
+    func_enter();
+
+    if (card == NULL)
+    {
+        func_exit_r(CSR_WIFI_HIP_RESULT_INVALID_VALUE);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    r = unifi_init(card);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        func_exit_r(r);
+        return r;
+    }
+
+    r = unifi_hip_init(card);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        func_exit_r(r);
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to start host protocol.\n");
+        func_exit_r(r);
+        return r;
+    }
+
+    func_exit();
+    return CSR_RESULT_SUCCESS;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_init
+ *
+ *      Init the hardware.
+ *
+ *  Arguments:
+ *      card        Pointer to card struct
+ *
+ *  Returns:
+ *      CsrResult code
+ *      CSR_RESULT_SUCCESS if successful
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_init(card_t *card)
+{
+    CsrResult r;
+    CsrResult csrResult;
+
+    func_enter();
+
+    if (card == NULL)
+    {
+        func_exit_r(CSR_WIFI_HIP_RESULT_INVALID_VALUE);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    /*
+     * Disable the SDIO interrupts while initialising UniFi.
+     * Re-enable them when f/w is running.
+     */
+    csrResult = CsrSdioInterruptDisable(card->sdio_if);
+    if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+    {
+        return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+    }
+
+    /*
+     * UniFi's PLL may start with a slow clock (~ 1 MHz) so initially
+     * set the SDIO bus clock to a similar value or SDIO accesses may
+     * fail.
+     */
+    csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_SAFE_HZ);
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+        func_exit_r(r);
+        return r;
+    }
+    card->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;
+
+    /*
+     * Reset UniFi. Note, this only resets the WLAN function part of the chip,
+     * the SDIO interface is not reset.
+     */
+    unifi_trace(card->ospriv, UDBG1, "Resetting UniFi\n");
+    r = unifi_reset_hardware(card);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to reset UniFi\n");
+        func_exit_r(r);
+        return r;
+    }
+
+    /* Reset the power save mode, to be active until the MLME-reset is complete */
+    r = unifi_configure_low_power_mode(card,
+                                       UNIFI_LOW_POWER_DISABLED, UNIFI_PERIODIC_WAKE_HOST_DISABLED);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to set power save mode\n");
+        func_exit_r(r);
+        return r;
+    }
+
+    /*
+     * Set initial value of page registers.
+     * The page registers will be maintained by unifi_read...() and
+     * unifi_write...().
+     */
+    card->proc_select = (CsrUint32)(-1);
+    card->dmem_page = (CsrUint32)(-1);
+    card->pmem_page = (CsrUint32)(-1);
+    r = unifi_write_direct16(card, ChipHelper_HOST_WINDOW3_PAGE(card->helper) * 2, 0);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to write SHARED_DMEM_PAGE\n");
+        func_exit_r(r);
+        return r;
+    }
+    r = unifi_write_direct16(card, ChipHelper_HOST_WINDOW2_PAGE(card->helper) * 2, 0);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to write PROG_MEM2_PAGE\n");
+        func_exit_r(r);
+        return r;
+    }
+
+    /*
+     * If the driver has reset UniFi due to previous SDIO failure, this may
+     * have been due to a chip watchdog reset. In this case, the driver may
+     * have requested a mini-coredump which needs to be captured now the
+     * SDIO interface is alive.
+     */
+    unifi_coredump_handle_request(card);
+
+    /*
+     * Probe to see if the UniFi has ROM/flash to boot from. CSR6xxx should do.
+     */
+    r = firmware_present_in_flash(card);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r == CSR_WIFI_HIP_RESULT_NOT_FOUND)
+    {
+        unifi_error(card->ospriv, "No firmware found\n");
+    }
+    else if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Probe for Flash failed\n");
+    }
+
+    func_exit_r(r);
+    return r;
+} /* unifi_init() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_download
+ *
+ *      Load the firmware.
+ *
+ *  Arguments:
+ *      card        Pointer to card struct
+ *      led_mask    Loader LED mask
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success
+ *      CsrResult error code on failure.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_download(card_t *card, CsrInt32 led_mask)
+{
+    CsrResult r;
+    void *dlpriv;
+
+    func_enter();
+
+    if (card == NULL)
+    {
+        func_exit_r(CSR_WIFI_HIP_RESULT_INVALID_VALUE);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    /* Set the loader led mask */
+    card->loader_led_mask = led_mask;
+
+    /* Get the firmware file information */
+    unifi_trace(card->ospriv, UDBG1, "downloading firmware...\n");
+
+    dlpriv = unifi_dl_fw_read_start(card, UNIFI_FW_STA);
+    if (dlpriv == NULL)
+    {
+        func_exit_r(CSR_WIFI_HIP_RESULT_NOT_FOUND);
+        return CSR_WIFI_HIP_RESULT_NOT_FOUND;
+    }
+
+    /* Download the firmware. */
+    r = unifi_dl_firmware(card, dlpriv);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to download firmware\n");
+        func_exit_r(r);
+        return r;
+    }
+
+    /* Free the firmware file information. */
+    unifi_fw_read_stop(card->ospriv, dlpriv);
+
+    func_exit();
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_download() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_hip_init
+ *
+ *      This function performs the f/w initialisation sequence as described
+ *      in the Unifi Host Interface Protocol Specification.
+ *      It allocates memory for host-side slot data and signal queues.
+ *
+ *  Arguments:
+ *      card        Pointer to card struct
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success or else a CSR error code
+ *
+ *  Notes:
+ *      The firmware must have been downloaded.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult unifi_hip_init(card_t *card)
+{
+    CsrResult r;
+    CsrResult csrResult;
+
+    func_enter();
+
+    r = card_hw_init(card);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to establish communication with UniFi\n");
+        func_exit_r(r);
+        return r;
+    }
+#ifdef CSR_PRE_ALLOC_NET_DATA
+    /* if there is any preallocated netdata left from the prev session free it now */
+    prealloc_netdata_free(card);
+#endif
+    /*
+     * Allocate memory for host-side slot data and signal queues.
+     * We need the config info read from the firmware to know how much
+     * memory to allocate.
+     */
+    r = card_init_slots(card);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Init slots failed: %d\n", r);
+        func_exit_r(r);
+        return r;
+    }
+
+    unifi_trace(card->ospriv, UDBG2, "Sending first UniFi interrupt\n");
+
+    r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        func_exit_r(r);
+        return r;
+    }
+
+    /* Enable the SDIO interrupts now that the f/w is running. */
+    csrResult = CsrSdioInterruptEnable(card->sdio_if);
+    if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+    {
+        return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+    }
+
+    /* Signal the UniFi to start handling messages */
+    r = CardGenInt(card);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        func_exit_r(r);
+        return r;
+    }
+
+    func_exit();
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_hip_init() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  _build_sdio_config_data
+ *
+ *      Unpack the SDIO configuration information from a buffer read from
+ *      UniFi into a host structure.
+ *      The data is byte-swapped for a big-endian host if necessary by the
+ *      UNPACK... macros.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      cfg_data        Destination structure to unpack into.
+ *      cfg_data_buf    Source buffer to read from. This should be the raw
+ *                      data read from UniFi.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void _build_sdio_config_data(sdio_config_data_t *cfg_data,
+                                    const CsrUint8     *cfg_data_buf)
+{
+    CsrInt16 offset = 0;
+
+    cfg_data->version = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->sdio_ctrl_offset = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->fromhost_sigbuf_handle = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->tohost_sigbuf_handle = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->num_fromhost_sig_frags = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->num_tohost_sig_frags = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->num_fromhost_data_slots = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->num_tohost_data_slots = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->data_slot_size = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->initialised = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->overlay_size = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT32;
+
+    cfg_data->data_slot_round = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->sig_frag_size = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+    offset += SIZEOF_UINT16;
+
+    cfg_data->tohost_signal_padding = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);
+} /* _build_sdio_config_data() */
+
+
+/*
+ * - Function ----------------------------------------------------------------
+ * card_hw_init()
+ *
+ *      Perform the initialisation procedure described in the UniFi Host
+ *      Interface Protocol document (section 3.3.8) and read the run-time
+ *      configuration information from the UniFi. This is stuff like number
+ *      of bulk data slots etc.
+ *
+ *      The card enumeration and SD initialisation has already been done by
+ *      the SDIO library, see card_sdio_init().
+ *
+ *      The initialisation is done when firmware is ready, i.e. this may need
+ *      to be called after a f/w download operation.
+ *
+ *      The initialisation procedure goes like this:
+ *       - Wait for UniFi to start-up by polling SHARED_MAILBOX1
+ *       - Find the symbol table and look up SLT_SDIO_SLOT_CONFIG
+ *       - Read the config structure
+ *       - Check the "SDIO initialised" flag, if not zero do a h/w reset and
+ *         start again
+ *       - Decide the number of bulk data slots to allocate, allocate them and
+ *         set "SDIO initialised" flag (and generate an interrupt) to say so.
+ *
+ * Arguments:
+ *      card        Pointer to card struct
+ *
+ * Returns:
+ *      CSR_RESULT_SUCEESS on success,
+ *      a CSR error code on failure
+ *
+ * Notes:
+ *      All data in the f/w is stored in a little endian format, without any
+ *      padding bytes. Every read from this memory has to be transformed in
+ *      host (cpu specific) format, before it is stored in driver's parameters
+ *      or/and structures. Athough unifi_card_read16() and unifi_read32() do perform
+ *      the convertion internally, unifi_readn() does not.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult card_hw_init(card_t *card)
+{
+    CsrUint32 slut_address;
+    CsrUint16 initialised;
+    CsrUint16 finger_print;
+    symbol_t slut;
+    sdio_config_data_t *cfg_data;
+    CsrUint8 cfg_data_buf[SDIO_CONFIG_DATA_SIZE];
+    CsrResult r;
+    void *dlpriv;
+    CsrInt16 major, minor;
+    CsrInt16 search_4slut_again;
+    CsrResult csrResult;
+
+    func_enter();
+
+    /*
+     * The device revision from the TPLMID_MANF and TPLMID_CARD fields
+     * of the CIS are available as
+     *   card->sdio_if->pDevice->ManfID
+     *   card->sdio_if->pDevice->AppID
+     */
+
+    /*
+     * Run in a loop so we can patch.
+     */
+    do
+    {
+        /* Reset these each time around the loop. */
+        search_4slut_again = 0;
+        cfg_data = NULL;
+
+        r = card_wait_for_firmware_to_start(card, &slut_address);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Firmware hasn't started\n");
+            func_exit_r(r);
+            return r;
+        }
+        unifi_trace(card->ospriv, UDBG4, "SLUT addr 0x%lX\n", slut_address);
+
+        /*
+         * Firmware has started, but doesn't know full clock configuration yet
+         * as some of the information may be in the MIB. Therefore we set an
+         * initial SDIO clock speed, faster than UNIFI_SDIO_CLOCK_SAFE_HZ, for
+         * the patch download and subsequent firmware initialisation, and
+         * full speed UNIFI_SDIO_CLOCK_MAX_HZ will be set once the f/w tells us
+         * that it is ready.
+         */
+        csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_INIT_HZ);
+        if (csrResult != CSR_RESULT_SUCCESS)
+        {
+            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+            func_exit_r(r);
+            return r;
+        }
+        card->sdio_clock_speed = UNIFI_SDIO_CLOCK_INIT_HZ;
+
+        /*
+         * Check the SLUT fingerprint.
+         * The slut_address is a generic pointer so we must use unifi_card_read16().
+         */
+        unifi_trace(card->ospriv, UDBG4, "Looking for SLUT finger print\n");
+        finger_print = 0;
+        r = unifi_card_read16(card, slut_address, &finger_print);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to read SLUT finger print\n");
+            func_exit_r(r);
+            return r;
+        }
+
+        if (finger_print != SLUT_FINGERPRINT)
+        {
+            unifi_error(card->ospriv, "Failed to find Symbol lookup table fingerprint\n");
+            func_exit_r(CSR_RESULT_FAILURE);
+            return CSR_RESULT_FAILURE;
+        }
+
+        /* Symbol table starts imedately after the fingerprint */
+        slut_address += 2;
+
+        /* Search the table until either the end marker is found, or the
+         * loading of patch firmware invalidates the current table.
+         */
+        while (!search_4slut_again)
+        {
+            CsrUint16 s;
+            CsrUint32 l;
+
+            r = unifi_card_read16(card, slut_address, &s);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                func_exit_r(r);
+                return r;
+            }
+            slut_address += 2;
+
+            if (s == CSR_SLT_END)
+            {
+                unifi_trace(card->ospriv, UDBG3, "  found CSR_SLT_END\n");
+                break;
+            }
+
+            r = unifi_read32(card, slut_address, &l);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                func_exit_r(r);
+                return r;
+            }
+            slut_address += 4;
+
+            slut.id = s;
+            slut.obj = l;
+
+            unifi_trace(card->ospriv, UDBG3, "  found SLUT id %02d.%08lx\n", slut.id, slut.obj);
+            switch (slut.id)
+            {
+                case CSR_SLT_SDIO_SLOT_CONFIG:
+                    cfg_data = &card->config_data;
+                    /*
+                     * unifi_card_readn reads n bytes from the card, where data is stored
+                     * in a little endian format, without any padding bytes. So, we
+                     * can not just pass the cfg_data pointer or use the
+                     * sizeof(sdio_config_data_t) since the structure in the host can
+                     * be big endian formatted or have padding bytes for alignment.
+                     * We use a char buffer to read the data from the card.
+                     */
+                    r = unifi_card_readn(card, slut.obj, cfg_data_buf, SDIO_CONFIG_DATA_SIZE);
+                    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+                    {
+                        return r;
+                    }
+                    if (r != CSR_RESULT_SUCCESS)
+                    {
+                        unifi_error(card->ospriv, "Failed to read config data\n");
+                        func_exit_r(r);
+                        return r;
+                    }
+                    /* .. and then we copy the data to the host structure */
+                    _build_sdio_config_data(cfg_data, cfg_data_buf);
+
+                    /* Make sure the from host data slots are what we expect
+                        we reserve 2 for commands and there should be at least
+                        1 left for each access category */
+                    if ((cfg_data->num_fromhost_data_slots < UNIFI_RESERVED_COMMAND_SLOTS)
+                        || (cfg_data->num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS) / UNIFI_NO_OF_TX_QS == 0)
+                    {
+                        unifi_error(card->ospriv, "From host data slots %d\n", cfg_data->num_fromhost_data_slots);
+                        unifi_error(card->ospriv, "need to be (queues * x + 2) (UNIFI_RESERVED_COMMAND_SLOTS for commands)\n");
+                        func_exit_r(CSR_RESULT_FAILURE);
+                        return CSR_RESULT_FAILURE;
+                    }
+
+                    /* Configure SDIO to-block-size padding */
+                    if (card->sdio_io_block_pad)
+                    {
+                    /*
+                     * Firmware limits the maximum padding size via data_slot_round.
+                     * Therefore when padding to whole block sizes, the block size
+                     * must be configured correctly by adjusting CSR_WIFI_HIP_SDIO_BLOCK_SIZE.
+                     */
+                        if (cfg_data->data_slot_round < card->sdio_io_block_size)
+                        {
+                            unifi_error(card->ospriv,
+                                        "Configuration error: Block size of %d exceeds f/w data_slot_round of %d\n",
+                                        card->sdio_io_block_size, cfg_data->data_slot_round);
+                            return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+                        }
+
+                        /*
+                         * To force the To-Host signals to be rounded up to the SDIO block
+                         * size, we need to write the To-Host Signal Padding Fragments
+                         * field of the SDIO configuration in UniFi.
+                         */
+                        if ((card->sdio_io_block_size % cfg_data->sig_frag_size) != 0)
+                        {
+                            unifi_error(card->ospriv, "Configuration error: Can not pad to-host signals.\n");
+                            func_exit_r(CSR_WIFI_HIP_RESULT_INVALID_VALUE);
+                            return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+                        }
+                        cfg_data->tohost_signal_padding = (CsrUint16) (card->sdio_io_block_size / cfg_data->sig_frag_size);
+                        unifi_info(card->ospriv, "SDIO block size %d requires %d padding chunks\n",
+                                   card->sdio_io_block_size, cfg_data->tohost_signal_padding);
+                        r = unifi_card_write16(card, slut.obj + SDIO_TO_HOST_SIG_PADDING_OFFSET, cfg_data->tohost_signal_padding);
+                        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+                        {
+                            return r;
+                        }
+                        if (r != CSR_RESULT_SUCCESS)
+                        {
+                            unifi_error(card->ospriv, "Failed to write To-Host Signal Padding Fragments\n");
+                            func_exit_r(r);
+                            return r;
+                        }
+                    }
+
+                    /* Reconstruct the Generic Pointer address of the
+                     * SDIO Control Data Struct.
+                     */
+                    card->sdio_ctrl_addr = cfg_data->sdio_ctrl_offset | (UNIFI_SH_DMEM << 24);
+                    card->init_flag_addr = slut.obj + SDIO_INIT_FLAG_OFFSET;
+                    break;
+
+                case CSR_SLT_BUILD_ID_NUMBER:
+                {
+                    CsrUint32 n;
+                    r = unifi_read32(card, slut.obj, &n);
+                    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+                    {
+                        return r;
+                    }
+                    if (r != CSR_RESULT_SUCCESS)
+                    {
+                        unifi_error(card->ospriv, "Failed to read build id\n");
+                        func_exit_r(r);
+                        return r;
+                    }
+                    card->build_id = n;
+                }
+                break;
+
+                case CSR_SLT_BUILD_ID_STRING:
+                    r = unifi_readnz(card, slut.obj, card->build_id_string,
+                                     sizeof(card->build_id_string));
+                    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+                    {
+                        return r;
+                    }
+                    if (r != CSR_RESULT_SUCCESS)
+                    {
+                        unifi_error(card->ospriv, "Failed to read build string\n");
+                        func_exit_r(r);
+                        return r;
+                    }
+                    break;
+
+                case CSR_SLT_PERSISTENT_STORE_DB:
+                    break;
+
+                case CSR_SLT_BOOT_LOADER_CONTROL:
+
+                    /* This command copies most of the station firmware
+                     * image from ROM into program RAM.  It also clears
+                     * out the zerod data and sets up the initialised
+                     * data. */
+                    r = unifi_do_loader_op(card, slut.obj + 6, UNIFI_BOOT_LOADER_LOAD_STA);
+                    if (r != CSR_RESULT_SUCCESS)
+                    {
+                        unifi_error(card->ospriv, "Failed to write loader load image command\n");
+                        func_exit_r(r);
+                        return r;
+                    }
+
+                    dlpriv = unifi_dl_fw_read_start(card, UNIFI_FW_STA);
+
+                    /* dlpriv might be NULL, we still need to do the do_loader_op step. */
+                    if (dlpriv != NULL)
+                    {
+                    /* Download the firmware. */
+                        r = unifi_dl_patch(card, dlpriv, slut.obj);
+
+                    /* Free the firmware file information. */
+                        unifi_fw_read_stop(card->ospriv, dlpriv);
+
+                        if (r != CSR_RESULT_SUCCESS)
+                        {
+                            unifi_error(card->ospriv, "Failed to patch firmware\n");
+                            func_exit_r(r);
+                            return r;
+                        }
+                    }
+
+                    /* This command starts the firmware image that we want (the
+                    * station by default) with any patches required applied. */
+                    r = unifi_do_loader_op(card, slut.obj + 6, UNIFI_BOOT_LOADER_RESTART);
+                    if (r != CSR_RESULT_SUCCESS)
+                    {
+                        unifi_error(card->ospriv, "Failed to write loader restart command\n");
+                        func_exit_r(r);
+                        return r;
+                    }
+
+                    /* The now running patch f/w defines a new SLUT data structure -
+                     * the current one is no longer valid. We must drop out of the
+                     * processing loop and enumerate the new SLUT (which may appear
+                     * at a different offset).
+                     */
+                    search_4slut_again = 1;
+                    break;
+
+                case CSR_SLT_PANIC_DATA_PHY:
+                    card->panic_data_phy_addr = slut.obj;
+                    break;
+
+                case CSR_SLT_PANIC_DATA_MAC:
+                    card->panic_data_mac_addr = slut.obj;
+                    break;
+
+                default:
+                    /* do nothing */
+                    break;
+            }
+        } /* while */
+    } while (search_4slut_again);
+
+    /* Did we find the Config Data ? */
+    if (cfg_data == NULL)
+    {
+        unifi_error(card->ospriv, "Failed to find SDIO_SLOT_CONFIG Symbol\n");
+        func_exit_r(CSR_RESULT_FAILURE);
+        return CSR_RESULT_FAILURE;
+    }
+
+    /*
+     * Has ths card already been initialised?
+     * If so, return an error so we do a h/w reset and start again.
+     */
+    r = unifi_card_read16(card, card->init_flag_addr, &initialised);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to read init flag at %08lx\n",
+                    card->init_flag_addr);
+        func_exit_r(r);
+        return r;
+    }
+    if (initialised != 0)
+    {
+        func_exit_r(CSR_RESULT_FAILURE);
+        return CSR_RESULT_FAILURE;
+    }
+
+
+    /*
+     * Now check the UniFi firmware version
+     */
+    major = (cfg_data->version >> 8) & 0xFF;
+    minor = cfg_data->version & 0xFF;
+    unifi_info(card->ospriv, "UniFi f/w protocol version %d.%d (driver %d.%d)\n",
+               major, minor,
+               UNIFI_HIP_MAJOR_VERSION, UNIFI_HIP_MINOR_VERSION);
+
+    unifi_info(card->ospriv, "Firmware build %u: %s\n",
+               card->build_id, card->build_id_string);
+
+    if (major != UNIFI_HIP_MAJOR_VERSION)
+    {
+        unifi_error(card->ospriv, "UniFi f/w protocol major version (%d) is different from driver (v%d.%d)\n",
+                    major, UNIFI_HIP_MAJOR_VERSION, UNIFI_HIP_MINOR_VERSION);
+#ifndef CSR_WIFI_DISABLE_HIP_VERSION_CHECK
+        func_exit_r(CSR_RESULT_FAILURE);
+        return CSR_RESULT_FAILURE;
+#endif
+    }
+    if (minor < UNIFI_HIP_MINOR_VERSION)
+    {
+        unifi_error(card->ospriv, "UniFi f/w protocol version (v%d.%d) is older than minimum required by driver (v%d.%d).\n",
+                    major, minor,
+                    UNIFI_HIP_MAJOR_VERSION, UNIFI_HIP_MINOR_VERSION);
+#ifndef CSR_WIFI_DISABLE_HIP_VERSION_CHECK
+        func_exit_r(CSR_RESULT_FAILURE);
+        return CSR_RESULT_FAILURE;
+#endif
+    }
+
+    /* Read panic codes from a previous firmware panic. If the firmware has
+     * not panicked since power was applied (e.g. power-off hard reset)
+     * the stored panic codes will not be updated.
+     */
+    unifi_read_panic(card);
+
+    func_exit();
+    return CSR_RESULT_SUCCESS;
+} /* card_hw_init() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_wait_for_unifi_to_reset
+ *
+ *      Waits for a reset to complete by polling the WLAN function enable
+ *      bit (which is cleared on reset).
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error code on failure.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult card_wait_for_unifi_to_reset(card_t *card)
+{
+    CsrInt16 i;
+    CsrResult r;
+    CsrUint8 io_enable;
+    CsrResult csrResult;
+
+    func_enter();
+
+    r = CSR_RESULT_SUCCESS;
+    for (i = 0; i < MAILBOX2_ATTEMPTS; i++)
+    {
+        unifi_trace(card->ospriv, UDBG1, "waiting for reset to complete, attempt %d\n", i);
+        if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
+        {
+            /* It's quite likely that this read will timeout for the
+             * first few tries - especially if we have reset via
+             * DBG_RESET.
+             */
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+            unifi_debug_log_to_buf("m0@%02X=", SDIO_IO_READY);
+#endif
+            csrResult = CsrSdioF0Read8(card->sdio_if, SDIO_IO_READY, &io_enable);
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+            if (csrResult != CSR_RESULT_SUCCESS)
+            {
+                unifi_debug_log_to_buf("error=%X\n", csrResult);
+            }
+            else
+            {
+                unifi_debug_log_to_buf("%X\n", io_enable);
+            }
+#endif
+            if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+            {
+                return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+            }
+            r = CSR_RESULT_SUCCESS;
+            if (csrResult != CSR_RESULT_SUCCESS)
+            {
+                r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+            }
+        }
+        else
+        {
+            r = sdio_read_f0(card, SDIO_IO_ENABLE, &io_enable);
+        }
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r == CSR_RESULT_SUCCESS)
+        {
+            CsrUint16 mbox2;
+            CsrInt16 enabled = io_enable & (1 << card->function);
+
+            if (!enabled)
+            {
+                unifi_trace(card->ospriv, UDBG1,
+                            "Reset complete (function %d is disabled) in ~ %u msecs\n",
+                            card->function, i * MAILBOX2_TIMEOUT);
+
+                /* Enable WLAN function and verify MAILBOX2 is zero'd */
+                csrResult = CsrSdioFunctionEnable(card->sdio_if);
+                if (csrResult != CSR_RESULT_SUCCESS)
+                {
+                    r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+                    unifi_error(card->ospriv, "CsrSdioFunctionEnable failed %d\n", r);
+                    break;
+                }
+            }
+
+            r = unifi_read_direct16(card, ChipHelper_SDIO_HIP_HANDSHAKE(card->helper) * 2, &mbox2);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                unifi_error(card->ospriv, "read HIP_HANDSHAKE failed %d\n", r);
+                break;
+            }
+            if (mbox2 != 0)
+            {
+                unifi_error(card->ospriv, "MAILBOX2 non-zero after reset (mbox2 = %04x)\n", mbox2);
+                r = CSR_RESULT_FAILURE;
+            }
+            break;
+        }
+        else
+        {
+            if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
+            {
+                /* We ignore read failures for the first few reads,
+                 * they are probably benign. */
+                if (i > MAILBOX2_ATTEMPTS / 4)
+                {
+                    unifi_trace(card->ospriv, UDBG1, "Failed to read CCCR IO Ready register while polling for reset\n");
+                }
+            }
+            else
+            {
+                unifi_trace(card->ospriv, UDBG1, "Failed to read CCCR IO Enable register while polling for reset\n");
+            }
+        }
+        CsrThreadSleep(MAILBOX2_TIMEOUT);
+    }
+
+    if (r == CSR_RESULT_SUCCESS && i == MAILBOX2_ATTEMPTS)
+    {
+        unifi_trace(card->ospriv, UDBG1, "Timeout waiting for UniFi to complete reset\n");
+        r = CSR_RESULT_FAILURE;
+    }
+
+    func_exit();
+    return r;
+} /* card_wait_for_unifi_to_reset() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_wait_for_unifi_to_disable
+ *
+ *      Waits for the function to become disabled by polling the
+ *      IO_READY bit.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error code on failure.
+ *
+ *  Notes: This function can only be used with
+ *         card->chip_id > SDIO_CARD_ID_UNIFI_2
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult card_wait_for_unifi_to_disable(card_t *card)
+{
+    CsrInt16 i;
+    CsrResult r;
+    CsrUint8 io_enable;
+    CsrResult csrResult;
+
+    func_enter();
+
+    if (card->chip_id <= SDIO_CARD_ID_UNIFI_2)
+    {
+        unifi_error(card->ospriv,
+                    "Function reset method not supported for chip_id=%d\n",
+                    card->chip_id);
+        func_exit();
+        return CSR_RESULT_FAILURE;
+    }
+
+    r = CSR_RESULT_SUCCESS;
+    for (i = 0; i < MAILBOX2_ATTEMPTS; i++)
+    {
+        unifi_trace(card->ospriv, UDBG1, "waiting for disable to complete, attempt %d\n", i);
+
+        /*
+         * It's quite likely that this read will timeout for the
+         * first few tries - especially if we have reset via
+         * DBG_RESET.
+         */
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        unifi_debug_log_to_buf("r0@%02X=", SDIO_IO_READY);
+#endif
+        csrResult = CsrSdioF0Read8(card->sdio_if, SDIO_IO_READY, &io_enable);
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        if (csrResult != CSR_RESULT_SUCCESS)
+        {
+            unifi_debug_log_to_buf("error=%X\n", csrResult);
+        }
+        else
+        {
+            unifi_debug_log_to_buf("%X\n", io_enable);
+        }
+#endif
+        if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+        {
+            return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+        }
+        if (csrResult == CSR_RESULT_SUCCESS)
+        {
+            CsrInt16 enabled = io_enable & (1 << card->function);
+            r = CSR_RESULT_SUCCESS;
+            if (!enabled)
+            {
+                unifi_trace(card->ospriv, UDBG1,
+                            "Disable complete (function %d is disabled) in ~ %u msecs\n",
+                            card->function, i * MAILBOX2_TIMEOUT);
+
+                break;
+            }
+        }
+        else
+        {
+            /*
+             * We ignore read failures for the first few reads,
+             * they are probably benign.
+             */
+            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+            if (i > (MAILBOX2_ATTEMPTS / 4))
+            {
+                unifi_trace(card->ospriv, UDBG1,
+                            "Failed to read CCCR IO Ready register while polling for disable\n");
+            }
+        }
+        CsrThreadSleep(MAILBOX2_TIMEOUT);
+    }
+
+    if ((r == CSR_RESULT_SUCCESS) && (i == MAILBOX2_ATTEMPTS))
+    {
+        unifi_trace(card->ospriv, UDBG1, "Timeout waiting for UniFi to complete disable\n");
+        r = CSR_RESULT_FAILURE;
+    }
+
+    func_exit();
+    return r;
+} /* card_wait_for_unifi_to_reset() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_wait_for_firmware_to_start
+ *
+ *      Polls the MAILBOX1 register for a non-zero value.
+ *      Then reads MAILBOX0 and forms the two values into a 32-bit address
+ *      which is returned to the caller.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      paddr           Pointer to receive the UniFi address formed
+ *                      by concatenating MAILBOX1 and MAILBOX0.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error code on failure.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult card_wait_for_firmware_to_start(card_t *card, CsrUint32 *paddr)
+{
+    CsrInt32 i;
+    CsrUint16 mbox0, mbox1;
+    CsrResult r;
+
+    func_enter();
+
+    /*
+     * Wait for UniFi to initialise its data structures by polling
+     * the SHARED_MAILBOX1 register.
+     * Experience shows this is typically 120ms.
+     */
+    CsrThreadSleep(MAILBOX1_TIMEOUT);
+
+    mbox1 = 0;
+    unifi_trace(card->ospriv, UDBG1, "waiting for MAILBOX1 to be non-zero...\n");
+    for (i = 0; i < MAILBOX1_ATTEMPTS; i++)
+    {
+        r = unifi_read_direct16(card, ChipHelper_MAILBOX1(card->helper) * 2, &mbox1);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            /* These reads can fail if UniFi isn't up yet, so try again */
+            unifi_warning(card->ospriv, "Failed to read UniFi Mailbox1 register\n");
+        }
+
+        if ((r == CSR_RESULT_SUCCESS) && (mbox1 != 0))
+        {
+            unifi_trace(card->ospriv, UDBG1, "MAILBOX1 ready (0x%04X) in %u millisecs\n",
+                        mbox1, i * MAILBOX1_TIMEOUT);
+
+            /* Read the MAILBOX1 again in case we caught the value as it
+             * changed. */
+            r = unifi_read_direct16(card, ChipHelper_MAILBOX1(card->helper) * 2, &mbox1);
+            if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+            {
+                return r;
+            }
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                unifi_error(card->ospriv, "Failed to read UniFi Mailbox1 register for second time\n");
+                func_exit_r(r);
+                return r;
+            }
+            unifi_trace(card->ospriv, UDBG1, "MAILBOX1 value=0x%04X\n", mbox1);
+
+            break;
+        }
+
+        CsrThreadSleep(MAILBOX1_TIMEOUT);
+        if ((i % 100) == 99)
+        {
+            unifi_trace(card->ospriv, UDBG2, "MAILBOX1 not ready (0x%X), still trying...\n", mbox1);
+        }
+    }
+
+    if ((r == CSR_RESULT_SUCCESS) && (mbox1 == 0))
+    {
+        unifi_trace(card->ospriv, UDBG1, "Timeout waiting for firmware to start, Mailbox1 still 0 after %d ms\n",
+                    MAILBOX1_ATTEMPTS * MAILBOX1_TIMEOUT);
+        func_exit_r(CSR_RESULT_FAILURE);
+        return CSR_RESULT_FAILURE;
+    }
+
+
+    /*
+     * Complete the reset handshake by setting MAILBOX2 to 0xFFFF
+     */
+    r = unifi_write_direct16(card, ChipHelper_SDIO_HIP_HANDSHAKE(card->helper) * 2, 0xFFFF);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to write f/w startup handshake to MAILBOX2\n");
+        func_exit_r(r);
+        return r;
+    }
+
+
+    /*
+     * Read the Symbol Look Up Table (SLUT) offset.
+     * Top 16 bits are in mbox1, read the lower 16 bits from mbox0.
+     */
+    mbox0 = 0;
+    r = unifi_read_direct16(card, ChipHelper_MAILBOX0(card->helper) * 2, &mbox0);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to read UniFi Mailbox0 register\n");
+        func_exit_r(r);
+        return r;
+    }
+
+    *paddr = (((CsrUint32)mbox1 << 16) | mbox0);
+
+    func_exit();
+    return CSR_RESULT_SUCCESS;
+} /* card_wait_for_firmware_to_start() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_capture_panic
+ *
+ *      Attempt to capture panic codes from the firmware. This may involve
+ *      warm reset of the chip to regain access following a watchdog reset.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS if panic codes were captured, or none available
+ *      CSR_RESULT_FAILURE if the driver could not access function 1
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_capture_panic(card_t *card)
+{
+    func_enter();
+
+    /* The firmware must have previously initialised to read the panic addresses
+     * from the SLUT
+     */
+    if (!card->panic_data_phy_addr || !card->panic_data_mac_addr)
+    {
+        func_exit();
+        return CSR_RESULT_SUCCESS;
+    }
+
+    /* Ensure we can access function 1 following a panic/watchdog reset */
+    if (card_access_panic(card) == CSR_RESULT_SUCCESS)
+    {
+        /* Read the panic codes */
+        unifi_read_panic(card);
+    }
+    else
+    {
+        unifi_info(card->ospriv, "Unable to read panic codes");
+    }
+
+    func_exit();
+    return CSR_RESULT_SUCCESS;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_access_panic
+ *      Attempt to read the WLAN SDIO function in order to read panic codes
+ *      and perform various reset steps to regain access if the read fails.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS if panic codes can be read
+ *      CSR error code if panic codes can not be read
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult card_access_panic(card_t *card)
+{
+    CsrUint16 data_u16 = 0;
+    CsrInt32 i;
+    CsrResult r, sr;
+
+    func_enter();
+
+    /* A chip version of zero means that the version never got succesfully read
+     * during reset. In this case give up because it will not be possible to
+     * verify the chip version.
+     */
+    if (!card->chip_version)
+    {
+        unifi_info(card->ospriv, "Unknown chip version\n");
+        return CSR_RESULT_FAILURE;
+    }
+
+    /* Ensure chip is awake or access to function 1 will fail */
+    r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "unifi_set_host_state() failed %d\n", r);
+        return CSR_RESULT_FAILURE; /* Card is probably unpowered */
+    }
+    CsrThreadSleep(20);
+
+    for (i = 0; i < 3; i++)
+    {
+        sr = CsrSdioRead16(card->sdio_if, CHIP_HELPER_UNIFI_GBL_CHIP_VERSION * 2, &data_u16);
+        if (sr != CSR_RESULT_SUCCESS || data_u16 != card->chip_version)
+        {
+            unifi_info(card->ospriv, "Failed to read valid chip version sr=%d (0x%04x want 0x%04x) try %d\n",
+                       sr, data_u16, card->chip_version, i);
+
+            /* Set clock speed low */
+            sr = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_SAFE_HZ);
+            if (sr != CSR_RESULT_SUCCESS)
+            {
+                unifi_error(card->ospriv, "CsrSdioMaxBusClockFrequencySet() failed1 %d\n", sr);
+                r = ConvertCsrSdioToCsrHipResult(card, sr);
+            }
+            card->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;
+
+            /* First try re-enabling function in case a f/w watchdog reset disabled it */
+            if (i == 0)
+            {
+                unifi_info(card->ospriv, "Try function enable\n");
+                sr = CsrSdioFunctionEnable(card->sdio_if);
+                if (sr != CSR_RESULT_SUCCESS)
+                {
+                    r = ConvertCsrSdioToCsrHipResult(card, sr);
+                    unifi_error(card->ospriv, "CsrSdioFunctionEnable failed %d (HIP %d)\n", sr, r);
+                }
+                continue;
+            }
+
+            /* Second try, set awake */
+            unifi_info(card->ospriv, "Try set awake\n");
+
+            /* Ensure chip is awake */
+            r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
+            if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+            {
+                return r;
+            }
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                unifi_error(card->ospriv, "unifi_set_host_state() failed2 %d\n", r);
+            }
+
+            /* Set clock speed low in case setting the host state raised it, which
+             * would only happen if host state was previously TORPID
+             */
+            sr = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_SAFE_HZ);
+            if (sr != CSR_RESULT_SUCCESS)
+            {
+                unifi_error(card->ospriv, "CsrSdioMaxBusClockFrequencySet() failed2 %d\n", sr);
+            }
+            card->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;
+
+            if (i == 1)
+            {
+                continue;
+            }
+
+            /* Perform a s/w reset to preserve as much as the card state as possible,
+             * (mainly the preserve RAM). The context will be lost for coredump - but as we
+             * were unable to access the WLAN function for panic, the coredump would have
+             * also failed without a reset.
+             */
+            unifi_info(card->ospriv, "Try s/w reset\n");
+
+            r = unifi_card_hard_reset(card);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                unifi_error(card->ospriv, "unifi_card_hard_reset() failed %d\n", r);
+            }
+        }
+        else
+        {
+            if (i > 0)
+            {
+                unifi_info(card->ospriv, "Read chip version 0x%x after %d retries\n", data_u16, i);
+            }
+            break;
+        }
+    }
+
+    r = ConvertCsrSdioToCsrHipResult(card, sr);
+    func_exit_r(r);
+    return r;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_read_panic
+ *      Reads, saves and prints panic codes stored by the firmware in UniFi's
+ *      preserve RAM by the last panic that occurred since chip was powered.
+ *      Nothing is saved if the panic codes are read as zero.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ * ---------------------------------------------------------------------------
+ */
+void unifi_read_panic(card_t *card)
+{
+    CsrResult r;
+    CsrUint16 p_code, p_arg;
+
+    func_enter();
+
+    /* The firmware must have previously initialised to read the panic addresses
+     * from the SLUT
+     */
+    if (!card->panic_data_phy_addr || !card->panic_data_mac_addr)
+    {
+        return;
+    }
+
+    /* Get the panic data from PHY */
+    r = unifi_card_read16(card, card->panic_data_phy_addr, &p_code);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_phy_addr, r);
+        p_code = 0;
+    }
+    if (p_code)
+    {
+        r = unifi_card_read16(card, card->panic_data_phy_addr + 2, &p_arg);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_phy_addr + 2, r);
+        }
+        unifi_error(card->ospriv, "Last UniFi PHY PANIC %04x arg %04x\n", p_code, p_arg);
+        card->last_phy_panic_code = p_code;
+        card->last_phy_panic_arg = p_arg;
+    }
+
+    /* Get the panic data from MAC */
+    r = unifi_card_read16(card, card->panic_data_mac_addr, &p_code);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_mac_addr, r);
+        p_code = 0;
+    }
+    if (p_code)
+    {
+        r = unifi_card_read16(card, card->panic_data_mac_addr + 2, &p_arg);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_mac_addr + 2, r);
+        }
+        unifi_error(card->ospriv, "Last UniFi MAC PANIC %04x arg %04x\n", p_code, p_arg);
+        card->last_mac_panic_code = p_code;
+        card->last_mac_panic_arg = p_arg;
+    }
+
+    func_exit();
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_allocate_memory_resources
+ *
+ *      Allocates memory for the from-host, to-host bulk data slots,
+ *      soft queue buffers and bulk data buffers.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error code on failure.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult card_allocate_memory_resources(card_t *card)
+{
+    CsrInt16 n, i, k, r;
+    sdio_config_data_t *cfg_data;
+
+    func_enter();
+
+    /* Reset any state carried forward from a previous life */
+    card->fh_command_queue.q_rd_ptr = 0;
+    card->fh_command_queue.q_wr_ptr = 0;
+    CsrSnprintf(card->fh_command_queue.name, UNIFI_QUEUE_NAME_MAX_LENGTH,
+                "fh_cmd_q");
+    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+    {
+        card->fh_traffic_queue[i].q_rd_ptr = 0;
+        card->fh_traffic_queue[i].q_wr_ptr = 0;
+        CsrSnprintf(card->fh_traffic_queue[i].name,
+                    UNIFI_QUEUE_NAME_MAX_LENGTH, "fh_data_q%d", i);
+    }
+#ifndef CSR_WIFI_HIP_TA_DISABLE
+    unifi_ta_sampling_init(card);
+#endif
+    /* Convenience short-cut */
+    cfg_data = &card->config_data;
+
+    /*
+     * Allocate memory for the from-host and to-host signal buffers.
+     */
+    card->fh_buffer.buf = CsrMemAlloc(UNIFI_FH_BUF_SIZE);
+    if (card->fh_buffer.buf == NULL)
+    {
+        unifi_error(card->ospriv, "Failed to allocate memory for F-H signals\n");
+        func_exit_r(CSR_WIFI_HIP_RESULT_NO_MEMORY);
+        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+    }
+    card->fh_buffer.bufsize = UNIFI_FH_BUF_SIZE;
+    card->fh_buffer.ptr = card->fh_buffer.buf;
+    card->fh_buffer.count = 0;
+
+    card->th_buffer.buf = CsrMemAlloc(UNIFI_FH_BUF_SIZE);
+    if (card->th_buffer.buf == NULL)
+    {
+        unifi_error(card->ospriv, "Failed to allocate memory for T-H signals\n");
+        func_exit_r(CSR_WIFI_HIP_RESULT_NO_MEMORY);
+        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+    }
+    card->th_buffer.bufsize = UNIFI_FH_BUF_SIZE;
+    card->th_buffer.ptr = card->th_buffer.buf;
+    card->th_buffer.count = 0;
+
+
+    /*
+     * Allocate memory for the from-host and to-host bulk data slots.
+     * This is done as separate CsrPmemAllocs because lots of smaller
+     * allocations are more likely to succeed than one huge one.
+     */
+
+    /* Allocate memory for the array of pointers */
+    n = cfg_data->num_fromhost_data_slots;
+
+    unifi_trace(card->ospriv, UDBG3, "Alloc from-host resources, %d slots.\n", n);
+    card->from_host_data =
+        (slot_desc_t *)CsrMemAlloc(n * sizeof(slot_desc_t));
+    if (card->from_host_data == NULL)
+    {
+        unifi_error(card->ospriv, "Failed to allocate memory for F-H bulk data array\n");
+        func_exit_r(CSR_WIFI_HIP_RESULT_NO_MEMORY);
+        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+    }
+
+    /* Initialise from-host bulk data slots */
+    for (i = 0; i < n; i++)
+    {
+        UNIFI_INIT_BULK_DATA(&card->from_host_data[i].bd);
+    }
+
+    /* Allocate memory for the array used for slot host tag mapping */
+    card->fh_slot_host_tag_record =
+        (CsrUint32 *)CsrMemAlloc(n * sizeof(CsrUint32));
+
+    if (card->fh_slot_host_tag_record == NULL)
+    {
+        unifi_error(card->ospriv, "Failed to allocate memory for F-H slot host tag mapping array\n");
+        func_exit_r(CSR_WIFI_HIP_RESULT_NO_MEMORY);
+        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+    }
+
+
+    /* Allocate memory for the array of pointers */
+    n = cfg_data->num_tohost_data_slots;
+
+    unifi_trace(card->ospriv, UDBG3, "Alloc to-host resources, %d slots.\n", n);
+    card->to_host_data =
+        (bulk_data_desc_t *)CsrMemAlloc(n * sizeof(bulk_data_desc_t));
+    if (card->to_host_data == NULL)
+    {
+        unifi_error(card->ospriv, "Failed to allocate memory for T-H bulk data array\n");
+        func_exit_r(CSR_WIFI_HIP_RESULT_NO_MEMORY);
+        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+    }
+
+    /* Initialise to-host bulk data slots */
+    for (i = 0; i < n; i++)
+    {
+        UNIFI_INIT_BULK_DATA(&card->to_host_data[i]);
+    }
+
+    /*
+     * Initialise buffers for soft Q
+     */
+    for (i = 0; i < UNIFI_SOFT_COMMAND_Q_LENGTH; i++)
+    {
+        for (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)
+        {
+            UNIFI_INIT_BULK_DATA(&card->fh_command_q_body[i].bulkdata[r]);
+        }
+    }
+
+    for (k = 0; k < UNIFI_NO_OF_TX_QS; k++)
+    {
+        for (i = 0; i < UNIFI_SOFT_TRAFFIC_Q_LENGTH; i++)
+        {
+            for (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)
+            {
+                UNIFI_INIT_BULK_DATA(&card->fh_traffic_q_body[k][i].bulkdata[r]);
+            }
+        }
+    }
+
+    card->memory_resources_allocated = 1;
+
+    func_exit();
+    return CSR_RESULT_SUCCESS;
+} /* card_allocate_memory_resources() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_free_bulk_data
+ *
+ *      Free the data associated to a bulk data structure.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      bulk_data_slot  Pointer to bulk data structure
+ *
+ *  Returns:
+ *      None.
+ *
+ * ---------------------------------------------------------------------------
+ */
+static void unifi_free_bulk_data(card_t *card, bulk_data_desc_t *bulk_data_slot)
+{
+    if (bulk_data_slot->data_length != 0)
+    {
+        unifi_net_data_free(card->ospriv, bulk_data_slot);
+    }
+} /* unifi_free_bulk_data() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_free_memory_resources
+ *
+ *      Frees memory allocated for the from-host, to-host bulk data slots,
+ *      soft queue buffers and bulk data buffers.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void card_free_memory_resources(card_t *card)
+{
+    func_enter();
+
+    unifi_trace(card->ospriv, UDBG1, "Freeing card memory resources.\n");
+
+    /* Clear our internal queues */
+    unifi_cancel_pending_signals(card);
+
+
+    if (card->to_host_data)
+    {
+        CsrMemFree(card->to_host_data);
+        card->to_host_data = NULL;
+    }
+
+    if (card->from_host_data)
+    {
+        CsrMemFree(card->from_host_data);
+        card->from_host_data = NULL;
+    }
+
+    /* free the memory for slot host tag mapping array */
+    if (card->fh_slot_host_tag_record)
+    {
+        CsrMemFree(card->fh_slot_host_tag_record);
+        card->fh_slot_host_tag_record = NULL;
+    }
+
+    if (card->fh_buffer.buf)
+    {
+        CsrMemFree(card->fh_buffer.buf);
+    }
+    card->fh_buffer.ptr = card->fh_buffer.buf = NULL;
+    card->fh_buffer.bufsize = 0;
+    card->fh_buffer.count = 0;
+
+    if (card->th_buffer.buf)
+    {
+        CsrMemFree(card->th_buffer.buf);
+    }
+    card->th_buffer.ptr = card->th_buffer.buf = NULL;
+    card->th_buffer.bufsize = 0;
+    card->th_buffer.count = 0;
+
+
+    card->memory_resources_allocated = 0;
+
+    func_exit();
+} /* card_free_memory_resources() */
+
+
+static void card_init_soft_queues(card_t *card)
+{
+    CsrInt16 i;
+
+    func_enter();
+
+    unifi_trace(card->ospriv, UDBG1, "Initialising internal signal queues.\n");
+    /* Reset any state carried forward from a previous life */
+    card->fh_command_queue.q_rd_ptr = 0;
+    card->fh_command_queue.q_wr_ptr = 0;
+    CsrSnprintf(card->fh_command_queue.name, UNIFI_QUEUE_NAME_MAX_LENGTH,
+                "fh_cmd_q");
+    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+    {
+        card->fh_traffic_queue[i].q_rd_ptr = 0;
+        card->fh_traffic_queue[i].q_wr_ptr = 0;
+        CsrSnprintf(card->fh_traffic_queue[i].name,
+                    UNIFI_QUEUE_NAME_MAX_LENGTH, "fh_data_q%d", i);
+    }
+#ifndef CSR_WIFI_HIP_TA_DISABLE
+    unifi_ta_sampling_init(card);
+#endif
+    func_exit();
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_cancel_pending_signals
+ *
+ *      Free the signals and associated bulk data, pending in the core.
+ *
+ *  Arguments:
+ *      card        Pointer to card struct
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void unifi_cancel_pending_signals(card_t *card)
+{
+    CsrInt16 i, n, r;
+    func_enter();
+
+    unifi_trace(card->ospriv, UDBG1, "Canceling pending signals.\n");
+
+    if (card->to_host_data)
+    {
+        /*
+         * Free any bulk data buffers allocated for the t-h slots
+         * This will clear all buffers that did not make it to
+         * unifi_receive_event() before cancel was request.
+         */
+        n = card->config_data.num_tohost_data_slots;
+        unifi_trace(card->ospriv, UDBG3, "Freeing to-host resources, %d slots.\n", n);
+        for (i = 0; i < n; i++)
+        {
+            unifi_free_bulk_data(card, &card->to_host_data[i]);
+        }
+    }
+
+    /*
+     * If any of the from-host bulk data has reached the card->from_host_data
+     * but not UniFi, we need to free the buffers here.
+     */
+    if (card->from_host_data)
+    {
+        /* Free any bulk data buffers allocated for the f-h slots */
+        n = card->config_data.num_fromhost_data_slots;
+        unifi_trace(card->ospriv, UDBG3, "Freeing from-host resources, %d slots.\n", n);
+        for (i = 0; i < n; i++)
+        {
+            unifi_free_bulk_data(card, &card->from_host_data[i].bd);
+        }
+
+        for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+        {
+            card->dynamic_slot_data.from_host_used_slots[i] = 0;
+            card->dynamic_slot_data.from_host_max_slots[i] = 0;
+            card->dynamic_slot_data.from_host_reserved_slots[i] = 0;
+        }
+    }
+
+    /*
+     * Free any bulk data buffers allocated in the soft queues.
+     * This covers the case where a bulk data pointer has reached the soft queue
+     * but not the card->from_host_data.
+     */
+    unifi_trace(card->ospriv, UDBG3, "Freeing cmd q resources.\n");
+    for (i = 0; i < UNIFI_SOFT_COMMAND_Q_LENGTH; i++)
+    {
+        for (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)
+        {
+            unifi_free_bulk_data(card, &card->fh_command_q_body[i].bulkdata[r]);
+        }
+    }
+
+    unifi_trace(card->ospriv, UDBG3, "Freeing traffic q resources.\n");
+    for (n = 0; n < UNIFI_NO_OF_TX_QS; n++)
+    {
+        for (i = 0; i < UNIFI_SOFT_TRAFFIC_Q_LENGTH; i++)
+        {
+            for (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)
+            {
+                unifi_free_bulk_data(card, &card->fh_traffic_q_body[n][i].bulkdata[r]);
+            }
+        }
+    }
+
+    card_init_soft_queues(card);
+
+    func_exit();
+} /* unifi_cancel_pending_signals() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_free_card
+ *
+ *      Free the memory allocated for the card structure and buffers.
+ *
+ *  Notes:
+ *      The porting layer is responsible for freeing any mini-coredump buffers
+ *      allocated when it called unifi_coredump_init(), by calling
+ *      unifi_coredump_free() before calling this function.
+ *
+ *  Arguments:
+ *      card        Pointer to card struct
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void unifi_free_card(card_t *card)
+{
+    func_enter();
+#ifdef CSR_PRE_ALLOC_NET_DATA
+    prealloc_netdata_free(card);
+#endif
+    /* Free any memory allocated. */
+    card_free_memory_resources(card);
+
+    /* Warn if caller didn't free coredump buffers */
+    if (card->dump_buf)
+    {
+        unifi_error(card->ospriv, "Caller should call unifi_coredump_free()\n");
+        unifi_coredump_free(card); /* free anyway to prevent memory leak */
+    }
+
+    CsrMemFree(card);
+
+    func_exit();
+} /* unifi_free_card() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_init_slots
+ *
+ *      Allocate memory for host-side slot data and signal queues.
+ *
+ * Arguments:
+ *      card            Pointer to card object
+ *
+ * Returns:
+ *      CSR error code.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult card_init_slots(card_t *card)
+{
+    CsrResult r;
+    CsrUint8 i;
+
+    func_enter();
+
+    /* Allocate the buffers we need, only once. */
+    if (card->memory_resources_allocated == 1)
+    {
+        card_free_memory_resources(card);
+    }
+    else
+    {
+        /* Initialise our internal command and traffic queues */
+        card_init_soft_queues(card);
+    }
+
+    r = card_allocate_memory_resources(card);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to allocate card memory resources.\n");
+        card_free_memory_resources(card);
+        func_exit_r(r);
+        return r;
+    }
+
+    if (card->sdio_ctrl_addr == 0)
+    {
+        unifi_error(card->ospriv, "Failed to find config struct!\n");
+        func_exit_r(CSR_WIFI_HIP_RESULT_INVALID_VALUE);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    /*
+     * Set initial counts.
+     */
+
+    card->from_host_data_head = 0;
+
+    /* Get initial signal counts from UniFi, in case it has not been reset. */
+    {
+        CsrUint16 s;
+
+        /* Get the from-host-signals-written count */
+        r = unifi_card_read16(card, card->sdio_ctrl_addr + 0, &s);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to read from-host sig written count\n");
+            func_exit_r(r);
+            return r;
+        }
+        card->from_host_signals_w = (CsrInt16)s;
+
+        /* Get the to-host-signals-written count */
+        r = unifi_card_read16(card, card->sdio_ctrl_addr + 6, &s);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to read to-host sig read count\n");
+            func_exit_r(r);
+            return r;
+        }
+        card->to_host_signals_r = (CsrInt16)s;
+    }
+
+    /* Set Initialised flag. */
+    r = unifi_card_write16(card, card->init_flag_addr, 0x0001);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to write initialised flag\n");
+        func_exit_r(r);
+        return r;
+    }
+
+    /* Dynamic queue reservation */
+    CsrMemSet(&card->dynamic_slot_data, 0, sizeof(card_dynamic_slot_t));
+
+    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+    {
+        card->dynamic_slot_data.from_host_max_slots[i] = card->config_data.num_fromhost_data_slots -
+                                                         UNIFI_RESERVED_COMMAND_SLOTS;
+        card->dynamic_slot_data.queue_stable[i] = FALSE;
+    }
+
+    card->dynamic_slot_data.packets_interval = UNIFI_PACKETS_INTERVAL;
+
+    func_exit();
+    return CSR_RESULT_SUCCESS;
+} /* card_init_slots() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_set_udi_hook
+ *
+ *      Registers the udi hook that reports the sent signals to the core.
+ *
+ *  Arguments:
+ *      card            Pointer to the card context struct
+ *      udi_fn          Pointer to the callback function.
+ *
+ *  Returns:
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE if the card pointer is invalid,
+ *      CSR_RESULT_SUCCESS on success.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_set_udi_hook(card_t *card, udi_func_t udi_fn)
+{
+    if (card == NULL)
+    {
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    if (card->udi_hook == NULL)
+    {
+        card->udi_hook = udi_fn;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_set_udi_hook() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_remove_udi_hook
+ *
+ *      Removes the udi hook that reports the sent signals from the core.
+ *
+ *  Arguments:
+ *      card            Pointer to the card context struct
+ *      udi_fn          Pointer to the callback function.
+ *
+ *  Returns:
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE if the card pointer is invalid,
+ *      CSR_RESULT_SUCCESS on success.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_remove_udi_hook(card_t *card, udi_func_t udi_fn)
+{
+    if (card == NULL)
+    {
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    if (card->udi_hook == udi_fn)
+    {
+        card->udi_hook = NULL;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_remove_udi_hook() */
+
+
+static void CardReassignDynamicReservation(card_t *card)
+{
+    CsrUint8 i;
+
+    func_enter();
+
+    unifi_trace(card->ospriv, UDBG5, "Packets Txed %d %d %d %d\n",
+                card->dynamic_slot_data.packets_txed[0],
+                card->dynamic_slot_data.packets_txed[1],
+                card->dynamic_slot_data.packets_txed[2],
+                card->dynamic_slot_data.packets_txed[3]);
+
+    /* Clear reservation and recalculate max slots */
+    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+    {
+        card->dynamic_slot_data.queue_stable[i] = FALSE;
+        card->dynamic_slot_data.from_host_reserved_slots[i] = 0;
+        card->dynamic_slot_data.from_host_max_slots[i] = card->config_data.num_fromhost_data_slots -
+                                                         UNIFI_RESERVED_COMMAND_SLOTS;
+        card->dynamic_slot_data.packets_txed[i] = 0;
+
+        unifi_trace(card->ospriv, UDBG5, "CardReassignDynamicReservation: queue %d reserved %d Max %d\n", i,
+                    card->dynamic_slot_data.from_host_reserved_slots[i],
+                    card->dynamic_slot_data.from_host_max_slots[i]);
+    }
+
+    card->dynamic_slot_data.total_packets_txed = 0;
+    func_exit();
+}
+
+
+/* Algorithm to dynamically reserve slots. The logic is based mainly on the outstanding queue
+ * length. Slots are reserved for particular queues during an interval and cleared after the interval.
+ * Each queue has three associated variables.. a) used slots - the number of slots currently occupied
+ * by the queue b) reserved slots - number of slots reserved specifically for the queue c) max slots - total
+ * slots that this queue can actually use (may be higher than reserved slots and is dependent on reserved slots
+ * for other queues).
+ * This function is called when there are no slots available for a queue. It checks to see if there are enough
+ * unreserved slots sufficient for this request. If available these slots are reserved for the queue.
+ * If there are not enough unreserved slots, a fair share for each queue is calculated based on the total slots
+ * and the number of active queues (any queue with existing reservation is considered active). Queues needing
+ * less than their fair share are allowed to have the previously reserved slots. The remaining slots are
+ * distributed evenly among queues that need more than the fair share
+ *
+ * A better scheme would take current bandwidth per AC into consideration when reserving slots. An
+ * implementation scheme could consider the relative time/service period for slots in an AC. If the firmware
+ * services other ACs faster than a particular AC (packets wait in the slots longer) then it is fair to reserve
+ * less slots for the AC
+ */
+static void CardCheckDynamicReservation(card_t *card, unifi_TrafficQueue queue)
+{
+    CsrUint16 q_len, active_queues = 0, excess_queue_slots, div_extra_slots,
+              queue_fair_share, reserved_slots = 0, q, excess_need_queues = 0, unmovable_slots = 0;
+    CsrInt32 i;
+    q_t *sigq;
+    CsrUint16 num_data_slots = card->config_data.num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS;
+
+    func_enter();
+
+    /* Calculate the pending queue length */
+    sigq = &card->fh_traffic_queue[queue];
+    q_len = CSR_WIFI_HIP_Q_SLOTS_USED(sigq);
+
+    if (q_len <= card->dynamic_slot_data.from_host_reserved_slots[queue])
+    {
+        unifi_trace(card->ospriv, UDBG5, "queue %d q_len %d already has that many reserved slots, exiting\n", queue, q_len);
+        func_exit();
+        return;
+    }
+
+    /* Upper limit */
+    if (q_len > num_data_slots)
+    {
+        q_len = num_data_slots;
+    }
+
+    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+    {
+        if (i != (CsrInt32)queue)
+        {
+            reserved_slots += card->dynamic_slot_data.from_host_reserved_slots[i];
+        }
+        if ((i == (CsrInt32)queue) || (card->dynamic_slot_data.from_host_reserved_slots[i] > 0))
+        {
+            active_queues++;
+        }
+    }
+
+    unifi_trace(card->ospriv, UDBG5, "CardCheckDynamicReservation: queue %d q_len %d\n", queue, q_len);
+    unifi_trace(card->ospriv, UDBG5, "Active queues %d reserved slots on other queues %d\n",
+                active_queues, reserved_slots);
+
+    if (reserved_slots + q_len <= num_data_slots)
+    {
+        card->dynamic_slot_data.from_host_reserved_slots[queue] = q_len;
+        if (q_len == num_data_slots)
+        {
+            /* This is the common case when just 1 stream is going */
+            card->dynamic_slot_data.queue_stable[queue] = TRUE;
+        }
+    }
+    else
+    {
+        queue_fair_share = num_data_slots / active_queues;
+        unifi_trace(card->ospriv, UDBG5, "queue fair share %d\n", queue_fair_share);
+
+        /* Evenly distribute slots among active queues */
+        /* Find out the queues that need excess of fair share. Also find slots allocated
+         * to queues less than their fair share, these slots cannot be reallocated (unmovable slots) */
+
+        card->dynamic_slot_data.from_host_reserved_slots[queue] = q_len;
+
+        for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+        {
+            if (card->dynamic_slot_data.from_host_reserved_slots[i] > queue_fair_share)
+            {
+                excess_need_queues++;
+            }
+            else
+            {
+                unmovable_slots += card->dynamic_slot_data.from_host_reserved_slots[i];
+            }
+        }
+
+        unifi_trace(card->ospriv, UDBG5, "Excess need queues %d\n", excess_need_queues);
+
+        /* Now find the slots per excess demand queue */
+        excess_queue_slots = (num_data_slots - unmovable_slots) / excess_need_queues;
+        div_extra_slots = (num_data_slots - unmovable_slots) - excess_queue_slots * excess_need_queues;
+        for (i = UNIFI_NO_OF_TX_QS - 1; i >= 0; i--)
+        {
+            if (card->dynamic_slot_data.from_host_reserved_slots[i] > excess_queue_slots)
+            {
+                card->dynamic_slot_data.from_host_reserved_slots[i] = excess_queue_slots;
+                if (div_extra_slots > 0)
+                {
+                    card->dynamic_slot_data.from_host_reserved_slots[i]++;
+                    div_extra_slots--;
+                }
+                /* No more slots will be allocated to this queue during the current interval */
+                card->dynamic_slot_data.queue_stable[i] = TRUE;
+                unifi_trace(card->ospriv, UDBG5, "queue stable %d\n", i);
+            }
+        }
+    }
+
+    /* Redistribute max slots */
+    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+    {
+        reserved_slots = 0;
+        for (q = 0; q < UNIFI_NO_OF_TX_QS; q++)
+        {
+            if (i != q)
+            {
+                reserved_slots += card->dynamic_slot_data.from_host_reserved_slots[q];
+            }
+        }
+
+        card->dynamic_slot_data.from_host_max_slots[i] = num_data_slots - reserved_slots;
+        unifi_trace(card->ospriv, UDBG5, "queue %d reserved %d Max %d\n", i,
+                    card->dynamic_slot_data.from_host_reserved_slots[i],
+                    card->dynamic_slot_data.from_host_max_slots[i]);
+    }
+
+    func_exit();
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CardClearFromHostDataSlot
+ *
+ *      Clear a the given data slot, making it available again.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *      slot            Index of the signal slot to clear.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void CardClearFromHostDataSlot(card_t *card, const CsrInt16 slot)
+{
+    CsrUint8 queue = card->from_host_data[slot].queue;
+    const void *os_data_ptr = card->from_host_data[slot].bd.os_data_ptr;
+
+    func_enter();
+
+    if (card->from_host_data[slot].bd.data_length == 0)
+    {
+        unifi_warning(card->ospriv,
+                      "Surprise: request to clear an already free FH data slot: %d\n",
+                      slot);
+        func_exit();
+        return;
+    }
+
+    if (os_data_ptr == NULL)
+    {
+        unifi_warning(card->ospriv,
+                      "Clearing FH data slot %d: has null payload, len=%d\n",
+                      slot, card->from_host_data[slot].bd.data_length);
+    }
+
+    /* Free card->from_host_data[slot].bd.os_net_ptr here. */
+    /* Mark slot as free by setting length to 0. */
+    unifi_free_bulk_data(card, &card->from_host_data[slot].bd);
+    if (queue < UNIFI_NO_OF_TX_QS)
+    {
+        if (card->dynamic_slot_data.from_host_used_slots[queue] == 0)
+        {
+            unifi_error(card->ospriv, "Goofed up used slots q = %d used slots = %d\n",
+                        queue,
+                        card->dynamic_slot_data.from_host_used_slots[queue]);
+        }
+        else
+        {
+            card->dynamic_slot_data.from_host_used_slots[queue]--;
+        }
+        card->dynamic_slot_data.packets_txed[queue]++;
+        card->dynamic_slot_data.total_packets_txed++;
+        if (card->dynamic_slot_data.total_packets_txed >= card->dynamic_slot_data.packets_interval)
+        {
+            CardReassignDynamicReservation(card);
+        }
+    }
+
+    unifi_trace(card->ospriv, UDBG4, "CardClearFromHostDataSlot: slot %d recycled %p\n", slot, os_data_ptr);
+
+    func_exit();
+} /* CardClearFromHostDataSlot() */
+
+
+CsrUint16 CardGetDataSlotSize(card_t *card)
+{
+    return card->config_data.data_slot_size;
+} /* CardGetDataSlotSize() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CardGetFreeFromHostDataSlots
+ *
+ *      Retrieve the number of from-host bulk data slots available.
+ *
+ *  Arguments:
+ *      card            Pointer to the card context struct
+ *
+ *  Returns:
+ *      Number of free from-host bulk data slots.
+ * ---------------------------------------------------------------------------
+ */
+CsrUint16 CardGetFreeFromHostDataSlots(card_t *card)
+{
+    CsrUint16 i, n = 0;
+
+    func_enter();
+
+    /* First two slots reserved for MLME */
+    for (i = 0; i < card->config_data.num_fromhost_data_slots; i++)
+    {
+        if (card->from_host_data[i].bd.data_length == 0)
+        {
+            /* Free slot */
+            n++;
+        }
+    }
+
+    func_exit();
+    return n;
+} /* CardGetFreeFromHostDataSlots() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CardAreAllFromHostDataSlotsEmpty
+ *
+ *      Returns the state of from-host bulk data slots.
+ *
+ *  Arguments:
+ *      card            Pointer to the card context struct
+ *
+ *  Returns:
+ *      1       The from-host bulk data slots are all empty (available).
+ *      0       Some or all the from-host bulk data slots are in use.
+ * ---------------------------------------------------------------------------
+ */
+CsrUint16 CardAreAllFromHostDataSlotsEmpty(card_t *card)
+{
+    CsrUint16 i;
+
+    for (i = 0; i < card->config_data.num_fromhost_data_slots; i++)
+    {
+        if (card->from_host_data[i].bd.data_length != 0)
+        {
+            return 0;
+        }
+    }
+
+    return 1;
+} /* CardGetFreeFromHostDataSlots() */
+
+
+static CsrResult unifi_identify_hw(card_t *card)
+{
+    func_enter();
+
+    card->chip_id = card->sdio_if->sdioId.cardId;
+    card->function = card->sdio_if->sdioId.sdioFunction;
+    card->sdio_io_block_size = card->sdio_if->blockSize;
+
+    /* If SDIO controller doesn't support byte mode CMD53, pad transfers to block sizes */
+    card->sdio_io_block_pad = (card->sdio_if->features & CSR_SDIO_FEATURE_BYTE_MODE)?FALSE : TRUE;
+
+    /*
+     * Setup the chip helper so that we can access the registers (and
+     * also tell what sub-type of HIP we should use).
+     */
+    card->helper = ChipHelper_GetVersionSdio((CsrUint8)card->chip_id);
+    if (!card->helper)
+    {
+        unifi_error(card->ospriv, "Null ChipHelper\n");
+    }
+
+    unifi_info(card->ospriv, "Chip ID 0x%02X  Function %u  Block Size %u  Name %s(%s)\n",
+               card->chip_id, card->function, card->sdio_io_block_size,
+               ChipHelper_MarketingName(card->helper),
+               ChipHelper_FriendlyName(card->helper));
+
+    func_exit();
+    return CSR_RESULT_SUCCESS;
+} /* unifi_identify_hw() */
+
+
+static CsrResult unifi_prepare_hw(card_t *card)
+{
+    CsrResult r;
+    CsrResult csrResult;
+    enum unifi_host_state old_state = card->host_state;
+
+    func_enter();
+
+    r = unifi_identify_hw(card);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to identify hw\n");
+        func_exit_r(r);
+        return r;
+    }
+
+    unifi_trace(card->ospriv, UDBG1,
+                "%s mode SDIO\n", card->sdio_io_block_pad?"Block" : "Byte");
+    /*
+     * Chip must be a awake or blocks that are asleep may not get
+     * reset.  We can only do this after we have read the chip_id.
+     */
+    r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+
+    if (old_state == UNIFI_HOST_STATE_TORPID)
+    {
+        /* Ensure the initial clock rate is set; if a reset occured when the chip was
+         * TORPID, unifi_set_host_state() may have raised it to MAX.
+         */
+        csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_INIT_HZ);
+        if (csrResult != CSR_RESULT_SUCCESS)
+        {
+            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+            func_exit_r(r);
+            return r;
+        }
+        card->sdio_clock_speed = UNIFI_SDIO_CLOCK_INIT_HZ;
+    }
+
+    /*
+     * The WLAN function must be enabled to access MAILBOX2 and DEBUG_RST
+     * registers.
+     */
+    csrResult = CsrSdioFunctionEnable(card->sdio_if);
+    if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+    {
+        return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+    }
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+        /* Can't enable WLAN function. Try resetting the SDIO block. */
+        unifi_error(card->ospriv, "Failed to re-enable function %d.\n", card->function);
+        func_exit_r(r);
+        return r;
+    }
+
+    /*
+     * Poke some registers to make sure the PLL has started,
+     * otherwise memory accesses are likely to fail.
+     */
+    bootstrap_chip_hw(card);
+
+    /* Try to read the chip version from register. */
+    r = unifi_read_chip_version(card);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        func_exit_r(r);
+        return r;
+    }
+
+    func_exit();
+    return CSR_RESULT_SUCCESS;
+} /* unifi_prepare_hw() */
+
+
+static CsrResult unifi_read_chip_version(card_t *card)
+{
+    CsrUint32 gbl_chip_version;
+    CsrResult r;
+    CsrUint16 ver;
+
+    func_enter();
+
+    gbl_chip_version = ChipHelper_GBL_CHIP_VERSION(card->helper);
+
+    /* Try to read the chip version from register. */
+    if (gbl_chip_version != 0)
+    {
+        r = unifi_read_direct16(card, gbl_chip_version * 2, &ver);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to read GBL_CHIP_VERSION\n");
+            func_exit_r(r);
+            return r;
+        }
+        card->chip_version = ver;
+    }
+    else
+    {
+        unifi_info(card->ospriv, "Unknown Chip ID, cannot locate GBL_CHIP_VERSION\n");
+        r = CSR_RESULT_FAILURE;
+    }
+
+    unifi_info(card->ospriv, "Chip Version 0x%04X\n", card->chip_version);
+
+    func_exit_r(r);
+    return r;
+} /* unifi_read_chip_version() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_reset_hardware
+ *
+ *      Execute the UniFi reset sequence.
+ *
+ *      Note: This may fail if the chip is going TORPID so retry at
+ *      least once.
+ *
+ *  Arguments:
+ *      card - pointer to card context structure
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error otherwise.
+ *
+ *  Notes:
+ *      Some platforms (e.g. Windows Vista) do not allow access to registers
+ *      that are necessary for a software soft reset.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult unifi_reset_hardware(card_t *card)
+{
+    CsrResult r;
+    CsrUint16 new_block_size = UNIFI_IO_BLOCK_SIZE;
+    CsrResult csrResult;
+
+    func_enter();
+
+    /* Errors returned by unifi_prepare_hw() are not critical at this point */
+    r = unifi_prepare_hw(card);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+
+    /* First try SDIO controller reset, which may power cycle the UniFi, assert
+     * its reset line, or not be implemented depending on the platform.
+     */
+    unifi_info(card->ospriv, "Calling CsrSdioHardReset\n");
+    csrResult = CsrSdioHardReset(card->sdio_if);
+    if (csrResult == CSR_RESULT_SUCCESS)
+    {
+        unifi_info(card->ospriv, "CsrSdioHardReset succeeded on reseting UniFi\n");
+        r = unifi_prepare_hw(card);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "unifi_prepare_hw failed after hard reset\n");
+            func_exit_r(r);
+            return r;
+        }
+    }
+    else if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+    {
+        return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+    }
+    else
+    {
+        /* Falling back to software hard reset methods */
+        unifi_info(card->ospriv, "Falling back to software hard reset\n");
+        r = unifi_card_hard_reset(card);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "software hard reset failed\n");
+            func_exit_r(r);
+            return r;
+        }
+
+        /* If we fell back to unifi_card_hard_reset() methods, chip version may
+         * not have been read. (Note in the unlikely event that it is zero,
+         * it will be harmlessly read again)
+         */
+        if (card->chip_version == 0)
+        {
+            r = unifi_read_chip_version(card);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                func_exit_r(r);
+                return r;
+            }
+        }
+    }
+
+#ifdef CSR_WIFI_HIP_SDIO_BLOCK_SIZE
+    new_block_size = CSR_WIFI_HIP_SDIO_BLOCK_SIZE;
+#endif
+
+    /* After hard reset, we need to restore the SDIO block size */
+    csrResult = CsrSdioBlockSizeSet(card->sdio_if, new_block_size);
+    r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+
+    /* Warn if a different block size was achieved by the transport */
+    if (card->sdio_if->blockSize != new_block_size)
+    {
+        unifi_info(card->ospriv,
+                   "Actually got block size %d\n", card->sdio_if->blockSize);
+    }
+
+    /* sdio_io_block_size always needs be updated from the achieved block size,
+     * as it is used by the OS layer to allocate memory in unifi_net_malloc().
+     * Controllers which don't support block mode (e.g. CSPI) will report a
+     * block size of zero.
+     */
+    if (card->sdio_if->blockSize == 0)
+    {
+        unifi_info(card->ospriv, "Block size 0, block mode not available\n");
+
+        /* Set sdio_io_block_size to 1 so that unifi_net_data_malloc() has a
+         * sensible rounding value. Elsewhere padding will already be
+         * disabled because the controller supports byte mode.
+         */
+        card->sdio_io_block_size = 1;
+
+        /* Controller features must declare support for byte mode */
+        if (!(card->sdio_if->features & CSR_SDIO_FEATURE_BYTE_MODE))
+        {
+            unifi_error(card->ospriv, "Requires byte mode\n");
+            r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+        }
+    }
+    else
+    {
+        /* Padding will be enabled if CSR_SDIO_FEATURE_BYTE_MODE isn't set */
+        card->sdio_io_block_size = card->sdio_if->blockSize;
+    }
+
+
+    func_exit_r(r);
+    return r;
+} /* unifi_reset_hardware() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_reset_method_io_enable
+ *
+ *      Issue a hard reset to the hw writing the IO_ENABLE.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *
+ *  Returns:
+ *      0 on success,
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE   if the card was ejected
+ *      CSR_RESULT_FAILURE         if an SDIO error occurred or if a response
+ *                                 was not seen in the expected time
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult card_reset_method_io_enable(card_t *card)
+{
+    CsrResult r;
+    CsrResult csrResult;
+
+    func_enter();
+
+    /*
+     * This resets only function 1, so should be used in
+     * preference to the method below (CSR_FUNC_EN)
+     */
+    unifi_trace(card->ospriv, UDBG1, "Hard reset (IO_ENABLE)\n");
+
+    csrResult = CsrSdioFunctionDisable(card->sdio_if);
+    if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+    {
+        return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+    }
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+        unifi_warning(card->ospriv, "SDIO error writing IO_ENABLE: %d\n", r);
+    }
+    else
+    {
+        /* Delay here to let the reset take affect. */
+        CsrThreadSleep(RESET_SETTLE_DELAY);
+
+        r = card_wait_for_unifi_to_disable(card);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+
+        if (r == CSR_RESULT_SUCCESS)
+        {
+            r = card_wait_for_unifi_to_reset(card);
+            if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+            {
+                return r;
+            }
+        }
+    }
+
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_trace(card->ospriv, UDBG1, "Hard reset (CSR_FUNC_EN)\n");
+
+        r = sdio_write_f0(card, SDIO_CSR_FUNC_EN, 0);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_warning(card->ospriv, "SDIO error writing SDIO_CSR_FUNC_EN: %d\n", r);
+            func_exit_r(r);
+            return r;
+        }
+        else
+        {
+            /* Delay here to let the reset take affect. */
+            CsrThreadSleep(RESET_SETTLE_DELAY);
+
+            r = card_wait_for_unifi_to_reset(card);
+            if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+            {
+                return r;
+            }
+        }
+    }
+
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_warning(card->ospriv, "card_reset_method_io_enable failed to reset UniFi\n");
+    }
+
+    func_exit();
+    return r;
+} /* card_reset_method_io_enable() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_reset_method_dbg_reset
+ *
+ *      Issue a hard reset to the hw writing the DBG_RESET.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS         on success,
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE   if the card was ejected
+ *      CSR_RESULT_FAILURE         if an SDIO error occurred or if a response
+ *                                 was not seen in the expected time
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult card_reset_method_dbg_reset(card_t *card)
+{
+    CsrResult r;
+
+    func_enter();
+
+    /*
+     * Prepare UniFi for h/w reset
+     */
+    if (card->host_state == UNIFI_HOST_STATE_TORPID)
+    {
+        r = unifi_set_host_state(card, UNIFI_HOST_STATE_DROWSY);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to set UNIFI_HOST_STATE_DROWSY\n");
+            func_exit_r(r);
+            return r;
+        }
+        CsrThreadSleep(5);
+    }
+
+    r = unifi_card_stop_processor(card, UNIFI_PROC_BOTH);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Can't stop processors\n");
+        func_exit();
+        return r;
+    }
+
+    unifi_trace(card->ospriv, UDBG1, "Hard reset (DBG_RESET)\n");
+
+    /*
+     * This register write may fail. The debug reset resets
+     * parts of the Function 0 sections of the chip, and
+     * therefore the response cannot be sent back to the host.
+     */
+    r = unifi_write_direct_8_or_16(card, ChipHelper_DBG_RESET(card->helper) * 2, 1);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_warning(card->ospriv, "SDIO error writing DBG_RESET: %d\n", r);
+        func_exit_r(r);
+        return r;
+    }
+
+    /* Delay here to let the reset take affect. */
+    CsrThreadSleep(RESET_SETTLE_DELAY);
+
+    r = card_wait_for_unifi_to_reset(card);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_warning(card->ospriv, "card_reset_method_dbg_reset failed to reset UniFi\n");
+    }
+
+    func_exit();
+    return r;
+} /* card_reset_method_dbg_reset() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_card_hard_reset
+ *
+ *      Issue reset to hardware, by writing to registers on the card.
+ *      Power to the card is preserved.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS         on success,
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE   if the card was ejected
+ *      CSR_RESULT_FAILURE         if an SDIO error occurred or if a response
+ *                                 was not seen in the expected time
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_card_hard_reset(card_t *card)
+{
+    CsrResult r;
+    const struct chip_helper_reset_values *init_data;
+    CsrUint32 chunks;
+
+    func_enter();
+
+    /* Clear cache of page registers */
+    card->proc_select = (CsrUint32)(-1);
+    card->dmem_page = (CsrUint32)(-1);
+    card->pmem_page = (CsrUint32)(-1);
+
+    /*
+     * We need to have a valid card->helper before we use software hard reset.
+     * If unifi_identify_hw() fails to get the card ID, it probably means
+     * that there is no way to talk to the h/w.
+     */
+    r = unifi_identify_hw(card);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "unifi_card_hard_reset failed to identify h/w\n");
+        func_exit();
+        return r;
+    }
+
+    /* Search for some reset code. */
+    chunks = ChipHelper_HostResetSequence(card->helper, &init_data);
+    if (chunks != 0)
+    {
+        unifi_error(card->ospriv,
+                    "Hard reset (Code download) is unsupported\n");
+
+        func_exit_r(CSR_RESULT_FAILURE);
+        return CSR_RESULT_FAILURE;
+    }
+
+    if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
+    {
+        /* The HIP spec considers this a bus-specific reset.
+         * This resets only function 1, so should be used in
+         * preference to the method below (CSR_FUNC_EN)
+         * If this method fails, it means that the f/w is probably
+         * not running. In this case, try the DBG_RESET method.
+         */
+        r = card_reset_method_io_enable(card);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r == CSR_RESULT_SUCCESS)
+        {
+            func_exit();
+            return r;
+        }
+    }
+
+    /* Software hard reset */
+    r = card_reset_method_dbg_reset(card);
+
+    func_exit_r(r);
+    return r;
+} /* unifi_card_hard_reset() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ *  CardGenInt
+ *
+ *      Prod the card.
+ *      This function causes an internal interrupt to be raised in the
+ *      UniFi chip. It is used to signal the firmware that some action has
+ *      been completed.
+ *      The UniFi Host Interface asks that the value used increments for
+ *      debugging purposes.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS         on success,
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE   if the card was ejected
+ *      CSR_RESULT_FAILURE         if an SDIO error occurred or if a response
+ *                                 was not seen in the expected time
+ * ---------------------------------------------------------------------------
+ */
+CsrResult CardGenInt(card_t *card)
+{
+    CsrResult r;
+
+    func_enter();
+
+    if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
+    {
+        r = sdio_write_f0(card, SDIO_CSR_FROM_HOST_SCRATCH0,
+                          (CsrUint8)card->unifi_interrupt_seq);
+    }
+    else
+    {
+        r = unifi_write_direct_8_or_16(card,
+                                       ChipHelper_SHARED_IO_INTERRUPT(card->helper) * 2,
+                                       (CsrUint8)card->unifi_interrupt_seq);
+    }
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "SDIO error writing UNIFI_SHARED_IO_INTERRUPT: %d\n", r);
+        func_exit_r(r);
+        return r;
+    }
+
+    card->unifi_interrupt_seq++;
+
+    func_exit();
+    return CSR_RESULT_SUCCESS;
+} /* CardGenInt() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CardEnableInt
+ *
+ *      Enable the outgoing SDIO interrupt from UniFi to the host.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS            on success,
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
+ *      CSR_RESULT_FAILURE            if an SDIO error occurred,
+ * ---------------------------------------------------------------------------
+ */
+CsrResult CardEnableInt(card_t *card)
+{
+    CsrResult r;
+    CsrUint8 int_enable;
+
+    r = sdio_read_f0(card, SDIO_INT_ENABLE, &int_enable);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "SDIO error reading SDIO_INT_ENABLE\n");
+        return r;
+    }
+
+    int_enable |= (1 << card->function) | UNIFI_SD_INT_ENABLE_IENM;
+
+    r = sdio_write_f0(card, SDIO_INT_ENABLE, int_enable);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "SDIO error writing SDIO_INT_ENABLE\n");
+        return r;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CardEnableInt() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CardDisableInt
+ *
+ *      Disable the outgoing SDIO interrupt from UniFi to the host.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS            on success,
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
+ *      CSR_RESULT_FAILURE            if an SDIO error occurred,
+ * ---------------------------------------------------------------------------
+ */
+CsrResult CardDisableInt(card_t *card)
+{
+    CsrResult r;
+    CsrUint8 int_enable;
+
+    r = sdio_read_f0(card, SDIO_INT_ENABLE, &int_enable);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "SDIO error reading SDIO_INT_ENABLE\n");
+        return r;
+    }
+
+    int_enable &= ~(1 << card->function);
+
+    r = sdio_write_f0(card, SDIO_INT_ENABLE, int_enable);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "SDIO error writing SDIO_INT_ENABLE\n");
+        return r;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CardDisableInt() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CardPendingInt
+ *
+ *      Determine whether UniFi is currently asserting the SDIO interrupt
+ *      request.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *      pintr           Pointer to location to write interrupt status,
+ *                          TRUE if interrupt pending,
+ *                          FALSE if no interrupt pending.
+ *  Returns:
+ *      CSR_RESULT_SUCCESS            interrupt status read successfully
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
+ *      CSR_RESULT_FAILURE            if an SDIO error occurred,
+ * ---------------------------------------------------------------------------
+ */
+CsrResult CardPendingInt(card_t *card, CsrBool *pintr)
+{
+    CsrResult r;
+    CsrUint8 pending;
+
+    *pintr = FALSE;
+
+    r = sdio_read_f0(card, SDIO_INT_PENDING, &pending);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "SDIO error reading SDIO_INT_PENDING\n");
+        return r;
+    }
+
+    *pintr = (pending & (1 << card->function))?TRUE : FALSE;
+
+    return CSR_RESULT_SUCCESS;
+} /* CardPendingInt() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CardClearInt
+ *
+ *      Clear the UniFi SDIO interrupt request.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS          if pending interrupt was cleared, or no pending interrupt.
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE    if the card was ejected
+ *      CSR_RESULT_FAILURE          if an SDIO error occurred,
+ * ---------------------------------------------------------------------------
+ */
+CsrResult CardClearInt(card_t *card)
+{
+    CsrResult r;
+    CsrBool intr;
+
+    if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
+    {
+        /* CardPendingInt() sets intr, if there is a pending interrupt */
+        r = CardPendingInt(card, &intr);
+        if (intr == FALSE)
+        {
+            return r;
+        }
+
+        r = sdio_write_f0(card, SDIO_CSR_HOST_INT_CLEAR, 1);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "SDIO error writing SDIO_CSR_HOST_INT_CLEAR\n");
+        }
+    }
+    else
+    {
+        r = unifi_write_direct_8_or_16(card,
+                                       ChipHelper_SDIO_HOST_INT(card->helper) * 2,
+                                       0);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "SDIO error writing UNIFI_SDIO_HOST_INT\n");
+        }
+    }
+
+    return r;
+} /* CardClearInt() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CardIntEnabled
+ *
+ *      Determine whether UniFi is currently asserting the SDIO interrupt
+ *      request.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *      enabled         Pointer to location to write interrupt enable status,
+ *                          TRUE if interrupts enabled,
+ *                          FALSE if interupts disabled.
+ *
+ *  Returns:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
+ *      CSR_RESULT_FAILURE            if an SDIO error occurred,
+ * ---------------------------------------------------------------------------
+ */
+CsrResult CardIntEnabled(card_t *card, CsrBool *enabled)
+{
+    CsrResult r;
+    CsrUint8 int_enable;
+
+    r = sdio_read_f0(card, SDIO_INT_ENABLE, &int_enable);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "SDIO error reading SDIO_INT_ENABLE\n");
+        return r;
+    }
+
+    *enabled = (int_enable & (1 << card->function))?TRUE : FALSE;
+
+    return CSR_RESULT_SUCCESS;
+} /* CardIntEnabled() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CardWriteBulkData
+ *      Allocate slot in the pending bulkdata arrays and assign it to a signal's
+ *      bulkdata reference. The slot is then ready for UniFi's bulkdata commands
+ *      to transfer the data to/from the host.
+ *
+ *  Arguments:
+ *      card            Pointer to Card object
+ *      csptr           Pending signal pointer, including bulkdata ref
+ *      queue           Traffic queue that this signal is using
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS if a free slot was assigned
+ *      CSR_RESULT_FAILURE if no slot was available
+ * ---------------------------------------------------------------------------
+ */
+CsrResult CardWriteBulkData(card_t *card, card_signal_t *csptr, unifi_TrafficQueue queue)
+{
+    CsrUint16 i, slots[UNIFI_MAX_DATA_REFERENCES], j = 0;
+    CsrUint8 *packed_sigptr, num_slots_required = 0;
+    bulk_data_desc_t *bulkdata = csptr->bulkdata;
+    CsrInt16 h, nslots;
+
+    func_enter();
+
+    /* Count the number of slots required */
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)
+    {
+        if (bulkdata[i].data_length != 0)
+        {
+            num_slots_required++;
+        }
+    }
+
+    /* Get the slot numbers */
+    if (num_slots_required != 0)
+    {
+        /* Last 2 slots for MLME */
+        if (queue == UNIFI_TRAFFIC_Q_MLME)
+        {
+            h = card->config_data.num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS;
+            for (i = 0; i < card->config_data.num_fromhost_data_slots; i++)
+            {
+                if (card->from_host_data[h].bd.data_length == 0)
+                {
+                    /* Free data slot, claim it */
+                    slots[j++] = h;
+                    if (j == num_slots_required)
+                    {
+                        break;
+                    }
+                }
+
+                if (++h >= card->config_data.num_fromhost_data_slots)
+                {
+                    h = 0;
+                }
+            }
+        }
+        else
+        {
+            if (card->dynamic_slot_data.from_host_used_slots[queue]
+                < card->dynamic_slot_data.from_host_max_slots[queue])
+            {
+                /* Data commands get a free slot only after a few checks */
+                nslots = card->config_data.num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS;
+
+                h = card->from_host_data_head;
+
+                for (i = 0; i < nslots; i++)
+                {
+                    if (card->from_host_data[h].bd.data_length == 0)
+                    {
+                        /* Free data slot, claim it */
+                        slots[j++] = h;
+                        if (j == num_slots_required)
+                        {
+                            break;
+                        }
+                    }
+
+                    if (++h >= nslots)
+                    {
+                        h = 0;
+                    }
+                }
+                card->from_host_data_head = h;
+            }
+        }
+
+        /* Required number of slots are not available, bail out */
+        if (j != num_slots_required)
+        {
+            unifi_trace(card->ospriv, UDBG5, "CardWriteBulkData: didn't find free slot/s\n");
+
+            /* If we haven't already reached the stable state we can ask for reservation */
+            if ((queue != UNIFI_TRAFFIC_Q_MLME) && (card->dynamic_slot_data.queue_stable[queue] == FALSE))
+            {
+                CardCheckDynamicReservation(card, queue);
+            }
+
+            for (i = 0; i < card->config_data.num_fromhost_data_slots; i++)
+            {
+                unifi_trace(card->ospriv, UDBG5, "fh data slot %d: %d\n", i, card->from_host_data[i].bd.data_length);
+            }
+            func_exit();
+            return CSR_RESULT_FAILURE;
+        }
+    }
+
+    packed_sigptr = csptr->sigbuf;
+
+    /* Fill in the slots with data */
+    j = 0;
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)
+    {
+        if (bulkdata[i].data_length == 0)
+        {
+            /* Zero-out the DATAREF in the signal */
+            SET_PACKED_DATAREF_SLOT(packed_sigptr, i, 0);
+            SET_PACKED_DATAREF_LEN(packed_sigptr, i, 0);
+        }
+        else
+        {
+            /*
+             * Fill in the slot number in the SIGNAL structure but
+             * preserve the offset already in there
+             */
+            SET_PACKED_DATAREF_SLOT(packed_sigptr, i, slots[j] | (((CsrUint16)packed_sigptr[SIZEOF_SIGNAL_HEADER + (i * SIZEOF_DATAREF) + 1]) << 8));
+            SET_PACKED_DATAREF_LEN(packed_sigptr, i, bulkdata[i].data_length);
+
+            /* Do not copy the data, just store the information to them */
+            card->from_host_data[slots[j]].bd.os_data_ptr = bulkdata[i].os_data_ptr;
+            card->from_host_data[slots[j]].bd.os_net_buf_ptr = bulkdata[i].os_net_buf_ptr;
+            card->from_host_data[slots[j]].bd.data_length = bulkdata[i].data_length;
+            card->from_host_data[slots[j]].bd.net_buf_length = bulkdata[i].net_buf_length;
+            card->from_host_data[slots[j]].queue = queue;
+
+            unifi_trace(card->ospriv, UDBG4, "CardWriteBulkData sig=0x%x, fh slot %d = %p\n",
+                        GET_SIGNAL_ID(packed_sigptr), i, bulkdata[i].os_data_ptr);
+
+            /* Sanity-check that the bulk data desc being assigned to the slot
+             * actually has a payload.
+             */
+            if (!bulkdata[i].os_data_ptr)
+            {
+                unifi_error(card->ospriv, "Assign null os_data_ptr (len=%d) fh slot %d, i=%d, q=%d, sig=0x%x",
+                            bulkdata[i].data_length, slots[j], i, queue, GET_SIGNAL_ID(packed_sigptr));
+            }
+
+            j++;
+            if (queue < UNIFI_NO_OF_TX_QS)
+            {
+                card->dynamic_slot_data.from_host_used_slots[queue]++;
+            }
+        }
+    }
+
+    func_exit();
+
+    return CSR_RESULT_SUCCESS;
+} /*  CardWriteBulkData() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_find_data_slot
+ *
+ *      Dereference references to bulk data slots into pointers to real data.
+ *
+ *  Arguments:
+ *      card            Pointer to the card struct.
+ *      slot            Slot number from a signal structure
+ *
+ *  Returns:
+ *      Pointer to entry in bulk_data_slot array.
+ * ---------------------------------------------------------------------------
+ */
+bulk_data_desc_t* card_find_data_slot(card_t *card, CsrInt16 slot)
+{
+    CsrInt16 sn;
+    bulk_data_desc_t *bd;
+
+    sn = slot & 0x7FFF;
+
+    /* ?? check sanity of slot number ?? */
+
+    if (slot & SLOT_DIR_TO_HOST)
+    {
+        bd = &card->to_host_data[sn];
+    }
+    else
+    {
+        bd = &card->from_host_data[sn].bd;
+    }
+
+    return bd;
+} /* card_find_data_slot() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  firmware_present_in_flash
+ *
+ *      Probe for external Flash that looks like it might contain firmware.
+ *
+ *      If Flash is not present, reads always return 0x0008.
+ *      If Flash is present, but empty, reads return 0xFFFF.
+ *      Anything else is considered to be firmware.
+ *
+ *  Arguments:
+ *      card        Pointer to card struct
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS                 firmware is present in ROM or flash
+ *      CSR_WIFI_HIP_RESULT_NOT_FOUND      firmware is not present in ROM or flash
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
+ *      CSR_RESULT_FAILURE                 if an SDIO error occurred
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult firmware_present_in_flash(card_t *card)
+{
+    CsrResult r;
+    CsrUint16 m1, m5;
+
+    if (ChipHelper_HasRom(card->helper))
+    {
+        return CSR_RESULT_SUCCESS;
+    }
+    if (!ChipHelper_HasFlash(card->helper))
+    {
+        return CSR_WIFI_HIP_RESULT_NOT_FOUND;
+    }
+
+    /*
+     * Examine the Flash locations that are the power-on default reset
+     * vectors of the XAP processors.
+     * These are words 1 and 5 in Flash.
+     */
+    r = unifi_card_read16(card, UNIFI_MAKE_GP(EXT_FLASH, 2), &m1);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+    r = unifi_card_read16(card, UNIFI_MAKE_GP(EXT_FLASH, 10), &m5);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+    /* Check for uninitialised/missing flash */
+    if ((m1 == 0x0008) || (m1 == 0xFFFF) ||
+        (m1 == 0x0004) || (m5 == 0x0004) ||
+        (m5 == 0x0008) || (m5 == 0xFFFF))
+    {
+        return CSR_WIFI_HIP_RESULT_NOT_FOUND;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* firmware_present_in_flash() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  bootstrap_chip_hw
+ *
+ *      Perform chip specific magic to "Get It Working" TM.  This will
+ *      increase speed of PLLs in analogue and maybe enable some
+ *      on-chip regulators.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void bootstrap_chip_hw(card_t *card)
+{
+    const struct chip_helper_init_values *vals;
+    CsrUint32 i, len;
+    void *sdio = card->sdio_if;
+    CsrResult csrResult;
+
+    len = ChipHelper_ClockStartupSequence(card->helper, &vals);
+    if (len != 0)
+    {
+        for (i = 0; i < len; i++)
+        {
+            csrResult = CsrSdioWrite16(sdio, vals[i].addr * 2, vals[i].value);
+            if (csrResult != CSR_RESULT_SUCCESS)
+            {
+                unifi_warning(card->ospriv, "Failed to write bootstrap value %d\n", i);
+                /* Might not be fatal */
+            }
+
+            CsrThreadSleep(1);
+        }
+    }
+} /* bootstrap_chip_hw() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_card_stop_processor
+ *
+ *      Stop the UniFi XAP processors.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      which           One of UNIFI_PROC_MAC, UNIFI_PROC_PHY, UNIFI_PROC_BOTH
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS if successful, or CSR error code
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_card_stop_processor(card_t *card, enum unifi_dbg_processors_select which)
+{
+    CsrResult r = CSR_RESULT_SUCCESS;
+    CsrUint8 status;
+    CsrInt16 retry = 100;
+
+    while (retry--)
+    {
+        /* Select both XAPs */
+        r = unifi_set_proc_select(card, which);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            break;
+        }
+
+        /* Stop processors */
+        r = unifi_write_direct16(card, ChipHelper_DBG_EMU_CMD(card->helper) * 2, 2);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            break;
+        }
+
+        /* Read status */
+        r = unifi_read_direct_8_or_16(card,
+                                      ChipHelper_DBG_HOST_STOP_STATUS(card->helper) * 2,
+                                      &status);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            break;
+        }
+
+        if ((status & 1) == 1)
+        {
+            /* Success! */
+            return CSR_RESULT_SUCCESS;
+        }
+
+        /* Processors didn't stop, try again */
+    }
+
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        /* An SDIO error occurred */
+        unifi_error(card->ospriv, "Failed to stop processors: SDIO error\n");
+    }
+    else
+    {
+        /* If we reach here, we didn't the status in time. */
+        unifi_error(card->ospriv, "Failed to stop processors: timeout waiting for stopped status\n");
+        r = CSR_RESULT_FAILURE;
+    }
+
+    return r;
+} /* unifi_card_stop_processor() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  card_start_processor
+ *
+ *      Start the UniFi XAP processors.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      which           One of UNIFI_PROC_MAC, UNIFI_PROC_PHY, UNIFI_PROC_BOTH
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS or CSR error code
+ * ---------------------------------------------------------------------------
+ */
+CsrResult card_start_processor(card_t *card, enum unifi_dbg_processors_select which)
+{
+    CsrResult r;
+
+    /* Select both XAPs */
+    r = unifi_set_proc_select(card, which);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "unifi_set_proc_select failed: %d.\n", r);
+        return r;
+    }
+
+
+    r = unifi_write_direct_8_or_16(card,
+                                   ChipHelper_DBG_EMU_CMD(card->helper) * 2, 8);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+    r = unifi_write_direct_8_or_16(card,
+                                   ChipHelper_DBG_EMU_CMD(card->helper) * 2, 0);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* card_start_processor() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_set_interrupt_mode
+ *
+ *      Configure the interrupt processing mode used by the HIP
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      mode            Interrupt mode to apply
+ *
+ *  Returns:
+ *      None
+ * ---------------------------------------------------------------------------
+ */
+void unifi_set_interrupt_mode(card_t *card, CsrUint32 mode)
+{
+    if (mode == CSR_WIFI_INTMODE_RUN_BH_ONCE)
+    {
+        unifi_info(card->ospriv, "Scheduled interrupt mode");
+    }
+    card->intmode = mode;
+} /* unifi_set_interrupt_mode() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_start_processors
+ *
+ *      Start all UniFi XAP processors.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error code on error
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_start_processors(card_t *card)
+{
+    return card_start_processor(card, UNIFI_PROC_BOTH);
+} /* unifi_start_processors() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_request_max_sdio_clock
+ *
+ *      Requests that the maximum SDIO clock rate is set at the next suitable
+ *      opportunity (e.g. when the BH next runs, so as not to interfere with
+ *      any current operation).
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      None
+ * ---------------------------------------------------------------------------
+ */
+void unifi_request_max_sdio_clock(card_t *card)
+{
+    card->request_max_clock = 1;
+} /* unifi_request_max_sdio_clock() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_set_host_state
+ *
+ *      Set the host deep-sleep state.
+ *
+ *      If transitioning to TORPID, the SDIO driver will be notified
+ *      that the SD bus will be unused (idle) and conversely, when
+ *      transitioning from TORPID that the bus will be used (active).
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      state           New deep-sleep state.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS            on success
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE      if the card was ejected
+ *      CSR_RESULT_FAILURE            if an SDIO error occurred
+ *
+ *  Notes:
+ *      We need to reduce the SDIO clock speed before trying to wake up the
+ *      chip. Actually, in the implementation below we reduce the clock speed
+ *      not just before we try to wake up the chip, but when we put the chip to
+ *      deep sleep. This means that if the f/w wakes up on its' own, we waste
+ *      a reduce/increace cycle. However, trying to eliminate this overhead is
+ *      proved difficult, as the current state machine in the HIP lib does at
+ *      least a CMD52 to disable the interrupts before we configure the host
+ *      state.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_set_host_state(card_t *card, enum unifi_host_state state)
+{
+    CsrResult r = CSR_RESULT_SUCCESS;
+    CsrResult csrResult;
+    static const CsrCharString *const states[] = {
+        "AWAKE", "DROWSY", "TORPID"
+    };
+    static const CsrUint8 state_csr_host_wakeup[] = {
+        1, 3, 0
+    };
+    static const CsrUint8 state_io_abort[] = {
+        0, 2, 3
+    };
+
+    unifi_trace(card->ospriv, UDBG4, "State %s to %s\n",
+                states[card->host_state], states[state]);
+
+    if (card->host_state == UNIFI_HOST_STATE_TORPID)
+    {
+        CsrSdioFunctionActive(card->sdio_if);
+    }
+
+    /* Write the new state to UniFi. */
+    if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
+    {
+        r = sdio_write_f0(card, SDIO_CSR_HOST_WAKEUP,
+                          (CsrUint8)((card->function << 4) | state_csr_host_wakeup[state]));
+    }
+    else
+    {
+        r = sdio_write_f0(card, SDIO_IO_ABORT, state_io_abort[state]);
+    }
+
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to write UniFi deep sleep state\n");
+    }
+    else
+    {
+        /*
+         * If the chip was in state TORPID then we can now increase
+         * the maximum bus clock speed.
+         */
+        if (card->host_state == UNIFI_HOST_STATE_TORPID)
+        {
+            csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if,
+                                                       UNIFI_SDIO_CLOCK_MAX_HZ);
+            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+            /* Non-fatal error */
+            if (r != CSR_RESULT_SUCCESS && r != CSR_WIFI_HIP_RESULT_NO_DEVICE)
+            {
+                unifi_warning(card->ospriv,
+                              "Failed to increase the SDIO clock speed\n");
+            }
+            else
+            {
+                card->sdio_clock_speed = UNIFI_SDIO_CLOCK_MAX_HZ;
+            }
+        }
+
+        /*
+         * Cache the current state in the card structure to avoid
+         * unnecessary SDIO reads.
+         */
+        card->host_state = state;
+
+        if (state == UNIFI_HOST_STATE_TORPID)
+        {
+            /*
+             * If the chip is now in state TORPID then we must now decrease
+             * the maximum bus clock speed.
+             */
+            csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if,
+                                                       UNIFI_SDIO_CLOCK_SAFE_HZ);
+            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+            if (r != CSR_RESULT_SUCCESS && r != CSR_WIFI_HIP_RESULT_NO_DEVICE)
+            {
+                unifi_warning(card->ospriv,
+                              "Failed to decrease the SDIO clock speed\n");
+            }
+            else
+            {
+                card->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;
+            }
+            CsrSdioFunctionIdle(card->sdio_if);
+        }
+    }
+
+    return r;
+} /* unifi_set_host_state() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_card_info
+ *
+ *      Update the card information data structure
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      card_info       Pointer to info structure to update
+ *
+ *  Returns:
+ *      None
+ * ---------------------------------------------------------------------------
+ */
+void unifi_card_info(card_t *card, card_info_t *card_info)
+{
+    card_info->chip_id = card->chip_id;
+    card_info->chip_version = card->chip_version;
+    card_info->fw_build = card->build_id;
+    card_info->fw_hip_version = card->config_data.version;
+    card_info->sdio_block_size = card->sdio_io_block_size;
+} /* unifi_card_info() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_check_io_status
+ *
+ *      Check UniFi for spontaneous reset and pending interrupt.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      status          Pointer to location to write chip status:
+ *                        0 if UniFi is running, and no interrupt pending
+ *                        1 if UniFi has spontaneously reset
+ *                        2 if there is a pending interrupt
+ *  Returns:
+ *      CSR_RESULT_SUCCESS if OK, or CSR error
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_check_io_status(card_t *card, CsrInt32 *status)
+{
+    CsrUint8 io_en;
+    CsrResult r;
+    CsrBool pending;
+
+    *status = 0;
+
+    r = sdio_read_f0(card, SDIO_IO_ENABLE, &io_en);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to read SDIO_IO_ENABLE to check for spontaneous reset\n");
+        return r;
+    }
+
+    if ((io_en & (1 << card->function)) == 0)
+    {
+        CsrInt32 fw_count;
+        *status = 1;
+        unifi_error(card->ospriv, "UniFi has spontaneously reset.\n");
+
+        /*
+         * These reads are very likely to fail. We want to know if the function is really
+         * disabled or the SDIO driver just returns rubbish.
+         */
+        fw_count = unifi_read_shared_count(card, card->sdio_ctrl_addr + 4);
+        if (fw_count < 0)
+        {
+            unifi_error(card->ospriv, "Failed to read to-host sig written count\n");
+        }
+        else
+        {
+            unifi_error(card->ospriv, "thsw: %u (driver thinks is %u)\n",
+                        fw_count, card->to_host_signals_w);
+        }
+        fw_count = unifi_read_shared_count(card, card->sdio_ctrl_addr + 2);
+        if (fw_count < 0)
+        {
+            unifi_error(card->ospriv, "Failed to read from-host sig read count\n");
+        }
+        else
+        {
+            unifi_error(card->ospriv, "fhsr: %u (driver thinks is %u)\n",
+                        fw_count, card->from_host_signals_r);
+        }
+
+        return r;
+    }
+
+    unifi_info(card->ospriv, "UniFi function %d is enabled.\n", card->function);
+
+    /* See if we missed an SDIO interrupt */
+    r = CardPendingInt(card, &pending);
+    if (pending)
+    {
+        unifi_error(card->ospriv, "There is an unhandled pending interrupt.\n");
+        *status = 2;
+        return r;
+    }
+
+    return r;
+} /* unifi_check_io_status() */
+
+
+void unifi_get_hip_qos_info(card_t *card, unifi_HipQosInfo *hipqosinfo)
+{
+    CsrInt32 count_fhr;
+    CsrInt16 t;
+    CsrUint32 occupied_fh;
+
+    q_t *sigq;
+    CsrUint16 nslots, i;
+
+    CsrMemSet(hipqosinfo, 0, sizeof(unifi_HipQosInfo));
+
+    nslots = card->config_data.num_fromhost_data_slots;
+
+    for (i = 0; i < nslots; i++)
+    {
+        if (card->from_host_data[i].bd.data_length == 0)
+        {
+            hipqosinfo->free_fh_bulkdata_slots++;
+        }
+    }
+
+    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+    {
+        sigq = &card->fh_traffic_queue[i];
+        t = sigq->q_wr_ptr - sigq->q_rd_ptr;
+        if (t < 0)
+        {
+            t += sigq->q_length;
+        }
+        hipqosinfo->free_fh_sig_queue_slots[i] = (sigq->q_length - t) - 1;
+    }
+
+    count_fhr = unifi_read_shared_count(card, card->sdio_ctrl_addr + 2);
+    if (count_fhr < 0)
+    {
+        unifi_error(card->ospriv, "Failed to read from-host sig read count - %d\n", count_fhr);
+        hipqosinfo->free_fh_fw_slots = 0xfa;
+        return;
+    }
+
+    occupied_fh = (card->from_host_signals_w - count_fhr) % 128;
+
+    hipqosinfo->free_fh_fw_slots = (CsrUint16)(card->config_data.num_fromhost_sig_frags - occupied_fh);
+}
+
+
+
+CsrResult ConvertCsrSdioToCsrHipResult(card_t *card, CsrResult csrResult)
+{
+    CsrResult r = CSR_RESULT_FAILURE;
+
+    switch (csrResult)
+    {
+        case CSR_RESULT_SUCCESS:
+            r = CSR_RESULT_SUCCESS;
+            break;
+        /* Timeout errors */
+        case CSR_SDIO_RESULT_TIMEOUT:
+        /* Integrity errors */
+        case CSR_SDIO_RESULT_CRC_ERROR:
+            r = CSR_RESULT_FAILURE;
+            break;
+        case CSR_SDIO_RESULT_NO_DEVICE:
+            r = CSR_WIFI_HIP_RESULT_NO_DEVICE;
+            break;
+        case CSR_SDIO_RESULT_INVALID_VALUE:
+            r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            break;
+        case CSR_RESULT_FAILURE:
+            r = CSR_RESULT_FAILURE;
+            break;
+        default:
+            unifi_warning(card->ospriv, "Unrecognised csrResult error code: %d\n", csrResult);
+            break;
+    }
+
+    return r;
+} /* ConvertCsrSdioToCsrHipResult() */
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_card_sdio.h
@@ -0,0 +1,702 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ *  FILE:     csr_wifi_hip_card_sdio.h
+ *
+ *  PURPOSE:
+ *      Internal header for Card API for SDIO.
+ * ---------------------------------------------------------------------------
+ */
+#ifndef __CARD_SDIO_H__
+#define __CARD_SDIO_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_unifi_udi.h"
+#include "csr_wifi_hip_unifihw.h"
+#include "csr_wifi_hip_unifiversion.h"
+#ifndef CSR_WIFI_HIP_TA_DISABLE
+#include "csr_wifi_hip_ta_sampling.h"
+#endif
+#include "csr_wifi_hip_xbv.h"
+#include "csr_wifi_hip_chiphelper.h"
+
+
+/*
+ *
+ * Configuration items.
+ * Which of these should go in a platform unifi_config.h file?
+ *
+ */
+
+/*
+ * When the traffic queues contain more signals than there is space for on
+ * UniFi, a limiting algorithm comes into play.
+ * If a traffic queue has enough slots free to buffer more traffic from the
+ * network stack, then the following check is applied. The number of free
+ * slots is RESUME_XMIT_THRESHOLD.
+ */
+#define RESUME_XMIT_THRESHOLD           4
+
+
+/*
+ * When reading signals from UniFi, the host processes pending all signals
+ * and then acknowledges them together in a single write to update the
+ * to-host-chunks-read location.
+ * When there is more than one bulk data transfer (e.g. one received data
+ * packet and a request for the payload data of a transmitted packet), the
+ * update can be delayed significantly. This ties up resources on chip.
+ *
+ * To remedy this problem, to-host-chunks-read is updated after processing
+ * a signal if TO_HOST_FLUSH_THRESHOLD bytes of bulk data have been
+ * transferred since the last update.
+ */
+#define TO_HOST_FLUSH_THRESHOLD (500 * 5)
+
+
+/* SDIO Card Common Control Registers */
+#define SDIO_CCCR_SDIO_REVISION     (0x00)
+#define SDIO_SD_SPEC_REVISION       (0x01)
+#define SDIO_IO_ENABLE              (0x02)
+#define SDIO_IO_READY               (0x03)
+#define SDIO_INT_ENABLE             (0x04)
+#define SDIO_INT_PENDING            (0x05)
+#define SDIO_IO_ABORT               (0x06)
+#define SDIO_BUS_IFACE_CONTROL      (0x07)
+#define SDIO_CARD_CAPABILOTY        (0x08)
+#define SDIO_COMMON_CIS_POINTER     (0x09)
+#define SDIO_BUS_SUSPEND            (0x0C)
+#define SDIO_FUNCTION_SELECT        (0x0D)
+#define SDIO_EXEC_FLAGS             (0x0E)
+#define SDIO_READY_FLAGS            (0x0F)
+#define SDIO_FN0_BLOCK_SIZE         (0x10)
+#define SDIO_POWER_CONTROL          (0x12)
+#define SDIO_VENDOR_START           (0xF0)
+
+#define SDIO_CSR_HOST_WAKEUP        (0xf0)
+#define SDIO_CSR_HOST_INT_CLEAR     (0xf1)
+#define SDIO_CSR_FROM_HOST_SCRATCH0 (0xf2)
+#define SDIO_CSR_FROM_HOST_SCRATCH1 (0xf3)
+#define SDIO_CSR_TO_HOST_SCRATCH0   (0xf4)
+#define SDIO_CSR_TO_HOST_SCRATCH1   (0xf5)
+#define SDIO_CSR_FUNC_EN            (0xf6)
+#define SDIO_CSR_CSPI_MODE          (0xf7)
+#define SDIO_CSR_CSPI_STATUS        (0xf8)
+#define SDIO_CSR_CSPI_PADDING       (0xf9)
+
+
+#define UNIFI_SD_INT_ENABLE_IENM 0x0001    /* Master INT Enable */
+
+#ifdef CSR_PRE_ALLOC_NET_DATA
+#define BULK_DATA_PRE_ALLOC_NUM 16
+#endif
+
+/*
+ * Structure to hold configuration information read from UniFi.
+ */
+typedef struct
+{
+    /*
+     * The version of the SDIO signal queues and bulk data pools
+     * configuration structure. The MSB is the major version number, used to
+     * indicate incompatible changes. The LSB gives the minor revision number,
+     * used to indicate changes that maintain backwards compatibility.
+     */
+    CsrUint16 version;
+
+    /*
+     * offset from the start of the shared data memory to the SD IO
+     * control structure.
+     */
+    CsrUint16 sdio_ctrl_offset;
+
+    /* Buffer handle of the from-host signal queue */
+    CsrUint16 fromhost_sigbuf_handle;
+
+    /* Buffer handle of the to-host signal queue */
+    CsrUint16 tohost_sigbuf_handle;
+
+    /*
+     * Maximum number of signal primitive or bulk data command fragments that may be
+     * pending in the to-hw signal queue.
+     */
+    CsrUint16 num_fromhost_sig_frags;
+
+    /*
+     * Number of signal primitive or bulk data command fragments that must be pending
+     * in the to-host signal queue before the host will generate an interrupt
+     * to indicate that it has read a signal. This will usually be the total
+     * capacity of the to-host signal buffer less the size of the largest signal
+     * primitive divided by the signal primitive fragment size, but may be set
+     * to 1 to request interrupts every time that the host read a signal.
+     * Note that the hw may place more signals in the to-host signal queue
+     * than indicated by this field.
+     */
+    CsrUint16 num_tohost_sig_frags;
+
+    /*
+     * Number of to-hw bulk data slots. Slots are numbered from 0 (zero) to
+     * one less than the value in this field
+     */
+    CsrUint16 num_fromhost_data_slots;
+
+    /*
+     * Number of frm-hw bulk data slots. Slots are numbered from 0 (zero) to
+     * one less than the value in this field
+     */
+    CsrUint16 num_tohost_data_slots;
+
+    /*
+     * Size of the bulk data slots (2 octets)
+     * The size of the bulk data slots in octets. This will usually be
+     * the size of the largest MSDU. The value should always be even.
+     */
+    CsrUint16 data_slot_size;
+
+    /*
+     * Indicates that the host has finished the initialisation sequence.
+     * Initialised to 0x0000 by the firmware, and set to 0x0001 by us.
+     */
+    CsrUint16 initialised;
+
+    /* Added by protocol version 0x0001 */
+    CsrUint32 overlay_size;
+
+    /* Added by protocol version 0x0300 */
+    CsrUint16 data_slot_round;
+    CsrUint16 sig_frag_size;
+
+    /* Added by protocol version 0x0500 */
+    CsrUint16 tohost_signal_padding;
+} sdio_config_data_t;
+
+/*
+ * These values may change with versions of the Host Interface Protocol.
+ */
+/*
+ * Size of config info block pointed to by the CSR_SLT_SDIO_SLOT_CONFIG
+ * entry in the f/w symbol table
+ */
+#define SDIO_CONFIG_DATA_SIZE 30
+
+/* Offset of the INIT flag in the config info block. */
+#define SDIO_INIT_FLAG_OFFSET 0x12
+#define SDIO_TO_HOST_SIG_PADDING_OFFSET 0x1C
+
+
+/* Structure for a bulk data transfer command */
+typedef struct
+{
+    CsrUint16 cmd_and_len;   /* bits 12-15 cmd, bits 0-11 len */
+    CsrUint16 data_slot;     /* slot number, perhaps OR'd with SLOT_DIR_TO_HOST */
+    CsrUint16 offset;
+    CsrUint16 buffer_handle;
+} bulk_data_cmd_t;
+
+
+/* Bulk Data signal command values */
+#define SDIO_CMD_SIGNAL                 0x00
+#define SDIO_CMD_TO_HOST_TRANSFER       0x01
+#define SDIO_CMD_TO_HOST_TRANSFER_ACK   0x02 /*deprecated*/
+#define SDIO_CMD_FROM_HOST_TRANSFER     0x03
+#define SDIO_CMD_FROM_HOST_TRANSFER_ACK 0x04 /*deprecated*/
+#define SDIO_CMD_CLEAR_SLOT             0x05
+#define SDIO_CMD_OVERLAY_TRANSFER       0x06
+#define SDIO_CMD_OVERLAY_TRANSFER_ACK   0x07 /*deprecated*/
+#define SDIO_CMD_FROM_HOST_AND_CLEAR    0x08
+#define SDIO_CMD_PADDING                0x0f
+
+#define SLOT_DIR_TO_HOST 0x8000
+
+
+/* Initialise bulkdata slot
+ *  params:
+ *      bulk_data_desc_t *bulk_data_slot
+ */
+#define UNIFI_INIT_BULK_DATA(bulk_data_slot)        \
+    {                                               \
+        (bulk_data_slot)->os_data_ptr = NULL;       \
+        (bulk_data_slot)->data_length = 0;          \
+        (bulk_data_slot)->os_net_buf_ptr = NULL;    \
+        (bulk_data_slot)->net_buf_length = 0;       \
+    }
+
+/*
+ * Structure to contain a SIGNAL datagram.
+ * This is used to build signal queues between the main driver and the
+ * i/o thread.
+ * The fields are:
+ *      sigbuf          Contains the HIP signal is wire-format (i.e. packed,
+ *                      little-endian)
+ *      bulkdata        Contains a copy of any associated bulk data
+ *      signal_length   The size of the signal in the sigbuf
+ */
+typedef struct card_signal
+{
+    CsrUint8 sigbuf[UNIFI_PACKED_SIGBUF_SIZE];
+
+    /* Length of the SIGNAL inside sigbuf */
+    CsrUint16 signal_length;
+
+    bulk_data_desc_t bulkdata[UNIFI_MAX_DATA_REFERENCES];
+} card_signal_t;
+
+
+/*
+ * Control structure for a generic ring buffer.
+ */
+#define UNIFI_QUEUE_NAME_MAX_LENGTH     16
+typedef struct
+{
+    card_signal_t *q_body;
+
+    /* Num elements in queue (capacity is one less than this!) */
+    CsrUint16 q_length;
+
+    CsrUint16 q_wr_ptr;
+    CsrUint16 q_rd_ptr;
+
+    CsrCharString name[UNIFI_QUEUE_NAME_MAX_LENGTH];
+} q_t;
+
+
+#define UNIFI_RESERVED_COMMAND_SLOTS   2
+
+/* Considering approx 500 us per packet giving 0.5 secs */
+#define UNIFI_PACKETS_INTERVAL         1000
+
+/*
+ * Dynamic slot reservation for QoS
+ */
+typedef struct
+{
+    CsrUint16 from_host_used_slots[UNIFI_NO_OF_TX_QS];
+    CsrUint16 from_host_max_slots[UNIFI_NO_OF_TX_QS];
+    CsrUint16 from_host_reserved_slots[UNIFI_NO_OF_TX_QS];
+
+    /* Parameters to determine if a queue was active.
+       If number of packets sent is greater than the threshold
+       for the queue, the queue is considered active and no
+       re reservation is done, it is important not to keep this
+       value too low */
+    /* Packets sent during this interval */
+    CsrUint16 packets_txed[UNIFI_NO_OF_TX_QS];
+    CsrUint16 total_packets_txed;
+
+    /* Number of packets to see if slots need to be reassigned */
+    CsrUint16 packets_interval;
+
+    /* Once a queue reaches a stable state, avoid processing */
+    CsrBool queue_stable[UNIFI_NO_OF_TX_QS];
+} card_dynamic_slot_t;
+
+
+/* These are type-safe and don't write incorrect values to the
+ * structure. */
+
+/* Return queue slots used count
+ *  params:
+ *      const q_t *q
+ *  returns:
+ *      CsrUint16
+ */
+#define CSR_WIFI_HIP_Q_SLOTS_USED(q)     \
+    (((q)->q_wr_ptr - (q)->q_rd_ptr < 0)? \
+     ((q)->q_wr_ptr - (q)->q_rd_ptr + (q)->q_length) : ((q)->q_wr_ptr - (q)->q_rd_ptr))
+
+/* Return queue slots free count
+ *  params:
+ *      const q_t *q
+ *  returns:
+ *      CsrUint16
+ */
+#define CSR_WIFI_HIP_Q_SLOTS_FREE(q)     \
+    ((q)->q_length - CSR_WIFI_HIP_Q_SLOTS_USED((q)) - 1)
+
+/* Return slot signal data pointer
+ *  params:
+ *      const q_t *q
+ *      CsrUint16 slot
+ *  returns:
+ *      card_signal_t *
+ */
+#define CSR_WIFI_HIP_Q_SLOT_DATA(q, slot)    \
+    ((q)->q_body + slot)
+
+/* Return queue next read slot
+ *  params:
+ *      const q_t *q
+ *  returns:
+ *      CsrUint16 slot offset
+ */
+#define CSR_WIFI_HIP_Q_NEXT_R_SLOT(q)    \
+    ((q)->q_rd_ptr)
+
+/* Return queue next write slot
+ *  params:
+ *      const q_t *q
+ *  returns:
+ *      CsrUint16 slot offset
+ */
+#define CSR_WIFI_HIP_Q_NEXT_W_SLOT(q)    \
+    ((q)->q_wr_ptr)
+
+/* Return updated queue pointer wrapped around its length
+ *  params:
+ *      const q_t *q
+ *      CsrUint16 x     amount to add to queue pointer
+ *  returns:
+ *      CsrUint16 wrapped queue pointer
+ */
+#define CSR_WIFI_HIP_Q_WRAP(q, x)    \
+    ((((x) >= (q)->q_length)?((x) % (q)->q_length) : (x)))
+
+/* Advance queue read pointer
+ *  params:
+ *      const q_t *q
+ */
+#define CSR_WIFI_HIP_Q_INC_R(q)  \
+    ((q)->q_rd_ptr = CSR_WIFI_HIP_Q_WRAP((q), (q)->q_rd_ptr + 1))
+
+/* Advance queue write pointer
+ *  params:
+ *      const q_t *q
+ */
+#define CSR_WIFI_HIP_Q_INC_W(q)  \
+    ((q)->q_wr_ptr = CSR_WIFI_HIP_Q_WRAP((q), (q)->q_wr_ptr + 1))
+
+enum unifi_host_state
+{
+    UNIFI_HOST_STATE_AWAKE   = 0,
+    UNIFI_HOST_STATE_DROWSY  = 1,
+    UNIFI_HOST_STATE_TORPID  = 2
+};
+
+typedef struct
+{
+    bulk_data_desc_t   bd;
+    unifi_TrafficQueue queue; /* Used for dynamic slot reservation */
+} slot_desc_t;
+
+/*
+ * Structure describing a UniFi SDIO card.
+ */
+struct card
+{
+    /*
+     * Back pointer for the higher level OS code. This is passed as
+     * an argument to callbacks (e.g. for received data and indications).
+     */
+    void *ospriv;
+
+    /*
+     * mapping of HIP slot to MA-PACKET.req host tag, the
+     * array is indexed by slot numbers and each index stores
+     * information of the last host tag it was used for
+     */
+    CsrUint32 *fh_slot_host_tag_record;
+
+
+    /* Info read from Symbol Table during probe */
+    CsrUint32     build_id;
+    CsrCharString build_id_string[128];
+
+    /* Retrieve from SDIO driver. */
+    CsrUint16 chip_id;
+
+    /* Read from GBL_CHIP_VERSION. */
+    CsrUint16 chip_version;
+
+    /* From the SDIO driver (probably 1) */
+    CsrUint8 function;
+
+    /* This is sused to get the register addresses and things. */
+    ChipDescript *helper;
+
+    /*
+     * Bit mask of PIOs for the loader to waggle during download.
+     * We assume these are connected to LEDs. The main firmware gets
+     * the mask from a MIB entry.
+     */
+    CsrInt32 loader_led_mask;
+
+    /*
+     * Support for flow control. When the from-host queue of signals
+     * is full, we ask the host upper layer to stop sending packets. When
+     * the queue drains we tell it that it can send packets again.
+     * We use this flag to remember the current state.
+     */
+#define card_is_tx_q_paused(card, q)   (card->tx_q_paused_flag[q])
+#define card_tx_q_unpause(card, q)   (card->tx_q_paused_flag[q] = 0)
+#define card_tx_q_pause(card, q)   (card->tx_q_paused_flag[q] = 1)
+
+    CsrUint16 tx_q_paused_flag[UNIFI_TRAFFIC_Q_MAX + 1 + UNIFI_NO_OF_TX_QS]; /* defensive more than big enough */
+
+    /* UDI callback for logging UniFi interactions */
+    udi_func_t udi_hook;
+
+    CsrUint8 bh_reason_host;
+    CsrUint8 bh_reason_unifi;
+
+    /* SDIO clock speed request from OS layer */
+    CsrUint8 request_max_clock;
+
+    /* Last SDIO clock frequency set */
+    CsrUint32 sdio_clock_speed;
+
+    /*
+     * Current host state (copy of value in IOABORT register and
+     * spinlock to protect it.
+     */
+    enum unifi_host_state host_state;
+
+    enum unifi_low_power_mode     low_power_mode;
+    enum unifi_periodic_wake_mode periodic_wake_mode;
+
+    /*
+     * Ring buffer of signal structs for a queue of data packets from
+     * the host.
+     * The queue is empty when fh_data_q_num_rd == fh_data_q_num_wr.
+     * To add a packet to the queue, copy it to index given by
+     * (fh_data_q_num_wr%UNIFI_SOFT_Q_LENGTH) and advance fh_data_q_num_wr.
+     * To take a packet from the queue, copy data from index given by
+     * (fh_data_q_num_rd%UNIFI_SOFT_Q_LENGTH) and advance fh_data_q_num_rd.
+     * fh_data_q_num_rd and fh_data_q_num_rd are both modulo 256.
+     */
+    card_signal_t fh_command_q_body[UNIFI_SOFT_COMMAND_Q_LENGTH];
+    q_t           fh_command_queue;
+
+    card_signal_t fh_traffic_q_body[UNIFI_NO_OF_TX_QS][UNIFI_SOFT_TRAFFIC_Q_LENGTH];
+    q_t           fh_traffic_queue[UNIFI_NO_OF_TX_QS];
+
+    /*
+     * Signal counts from UniFi SDIO Control Data Structure.
+     * These are cached and synchronised with the UniFi before and after
+     * a batch of operations.
+     *
+     * These are the modulo-256 count of signals written to or read from UniFi
+     * The value is incremented for every signal.
+     */
+    CsrInt32 from_host_signals_w;
+    CsrInt32 from_host_signals_r;
+    CsrInt32 to_host_signals_r;
+    CsrInt32 to_host_signals_w;
+
+
+    /* Should specify buffer size as a number of signals */
+    /*
+     * Enough for 10 th and 10 fh data slots:
+     *   1 * 10 * 8 =  80
+     *   2 * 10 * 8 = 160
+     */
+#define UNIFI_FH_BUF_SIZE 1024
+    struct sigbuf
+    {
+        CsrUint8 *buf;     /* buffer area */
+        CsrUint8 *ptr;     /* current pos */
+        CsrUint16 count;   /* signal count */
+        CsrUint16 bufsize;
+    } fh_buffer;
+    struct sigbuf th_buffer;
+
+
+    /*
+     * Field to use for the incrementing value to write to the UniFi
+     * SHARED_IO_INTERRUPT register.
+     * Flag to say we need to generate an interrupt at end of processing.
+     */
+    CsrUint32 unifi_interrupt_seq;
+    CsrUint8  generate_interrupt;
+
+
+    /* Pointers to the bulk data slots */
+    slot_desc_t      *from_host_data;
+    bulk_data_desc_t *to_host_data;
+
+
+    /*
+     * Index of the next (hopefully) free data slot.
+     * This is an optimisation that starts searching at a more likely point
+     * than the beginning.
+     */
+    CsrInt16 from_host_data_head;
+
+    /* Dynamic slot allocation for queues */
+    card_dynamic_slot_t dynamic_slot_data;
+
+    /*
+     * SDIO specific fields
+     */
+
+    /* Interface pointer for the SDIO library */
+    CsrSdioFunction *sdio_if;
+
+    /* Copy of config_data struct from the card */
+    sdio_config_data_t config_data;
+
+    /* SDIO address of the Initialised flag and Control Data struct */
+    CsrUint32 init_flag_addr;
+    CsrUint32 sdio_ctrl_addr;
+
+    /* The last value written to the Shared Data Memory Page register */
+    CsrUint32 proc_select;
+    CsrUint32 dmem_page;
+    CsrUint32 pmem_page;
+
+    /* SDIO traffic counters limited to 32 bits for Synergy compatibility */
+    CsrUint32 sdio_bytes_read;
+    CsrUint32 sdio_bytes_written;
+
+    CsrUint8 memory_resources_allocated;
+
+    /* UniFi SDIO I/O Block size. */
+    CsrUint16 sdio_io_block_size;
+
+    /* Pad transfer sizes to SDIO block boundaries */
+    CsrBool sdio_io_block_pad;
+
+    /* Read from the XBV */
+    struct FWOV fwov;
+
+#ifndef CSR_WIFI_HIP_TA_DISABLE
+    /* TA sampling */
+    ta_data_t ta_sampling;
+#endif
+
+    /* Auto-coredump */
+    CsrInt16             request_coredump_on_reset; /* request coredump on next reset */
+    struct coredump_buf *dump_buf;                  /* root node */
+    struct coredump_buf *dump_next_write;           /* node to fill at next dump */
+    struct coredump_buf *dump_cur_read;             /* valid node to read, or NULL */
+
+#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE
+    struct cmd_profile
+    {
+        CsrUint32 cmd52_count;
+        CsrUint32 cmd53_count;
+        CsrUint32 tx_count;
+        CsrUint32 tx_cfm_count;
+        CsrUint32 rx_count;
+        CsrUint32 bh_count;
+        CsrUint32 process_count;
+        CsrUint32 protocol_count;
+
+        CsrUint32 cmd52_f0_r_count;
+        CsrUint32 cmd52_f0_w_count;
+        CsrUint32 cmd52_r8or16_count;
+        CsrUint32 cmd52_w8or16_count;
+        CsrUint32 cmd52_r16_count;
+        CsrUint32 cmd52_w16_count;
+        CsrUint32 cmd52_r32_count;
+
+        CsrUint32 sdio_cmd_signal;
+        CsrUint32 sdio_cmd_clear_slot;
+        CsrUint32 sdio_cmd_to_host;
+        CsrUint32 sdio_cmd_from_host;
+        CsrUint32 sdio_cmd_from_host_and_clear;
+    } hip_prof;
+    struct cmd_profile cmd_prof;
+#endif
+
+    /* Interrupt processing mode flags */
+    CsrUint32 intmode;
+
+#ifdef UNIFI_DEBUG
+    CsrUint8 lsb;
+#endif
+
+    /* Historic firmware panic codes */
+    CsrUint32 panic_data_phy_addr;
+    CsrUint32 panic_data_mac_addr;
+    CsrUint16 last_phy_panic_code;
+    CsrUint16 last_phy_panic_arg;
+    CsrUint16 last_mac_panic_code;
+    CsrUint16 last_mac_panic_arg;
+#ifdef CSR_PRE_ALLOC_NET_DATA
+    bulk_data_desc_t bulk_data_desc_list[BULK_DATA_PRE_ALLOC_NUM];
+    CsrUint16        prealloc_netdata_r;
+    CsrUint16        prealloc_netdata_w;
+#endif
+}; /* struct card */
+
+
+/* Reset types */
+enum unifi_reset_type
+{
+    UNIFI_COLD_RESET = 1,
+    UNIFI_WARM_RESET = 2
+};
+
+/*
+ * unifi_set_host_state() implements signalling for waking UniFi from
+ * deep sleep. The host indicates to UniFi that it is in one of three states:
+ *   Torpid - host has nothing to send, UniFi can go to sleep.
+ *   Drowsy - host has data to send to UniFi. UniFi will respond with an
+ *            SDIO interrupt. When hosts responds it moves to Awake.
+ *   Awake  - host has data to transfer, UniFi must stay awake.
+ *            When host has finished, it moves to Torpid.
+ */
+CsrResult unifi_set_host_state(card_t *card, enum unifi_host_state state);
+
+
+CsrResult unifi_set_proc_select(card_t *card, enum unifi_dbg_processors_select select);
+CsrInt32 card_read_signal_counts(card_t *card);
+bulk_data_desc_t* card_find_data_slot(card_t *card, CsrInt16 slot);
+
+
+CsrResult unifi_read32(card_t *card, CsrUint32 unifi_addr, CsrUint32 *pdata);
+CsrResult unifi_readnz(card_t *card, CsrUint32 unifi_addr,
+                       void *pdata, CsrUint16 len);
+CsrInt32 unifi_read_shared_count(card_t *card, CsrUint32 addr);
+
+CsrResult unifi_writen(card_t *card, CsrUint32 unifi_addr, void *pdata, CsrUint16 len);
+
+CsrResult unifi_bulk_rw(card_t *card, CsrUint32 handle,
+                        void *pdata, CsrUint32 len, CsrInt16 direction);
+CsrResult unifi_bulk_rw_noretry(card_t *card, CsrUint32 handle,
+                                void *pdata, CsrUint32 len, CsrInt16 direction);
+#define UNIFI_SDIO_READ       0
+#define UNIFI_SDIO_WRITE      1
+
+CsrResult unifi_read_8_or_16(card_t *card, CsrUint32 unifi_addr, CsrUint8 *pdata);
+CsrResult unifi_write_8_or_16(card_t *card, CsrUint32 unifi_addr, CsrUint8 data);
+CsrResult unifi_read_direct_8_or_16(card_t *card, CsrUint32 addr, CsrUint8 *pdata);
+CsrResult unifi_write_direct_8_or_16(card_t *card, CsrUint32 addr, CsrUint8 data);
+
+CsrResult unifi_read_direct16(card_t *card, CsrUint32 addr, CsrUint16 *pdata);
+CsrResult unifi_read_direct32(card_t *card, CsrUint32 addr, CsrUint32 *pdata);
+CsrResult unifi_read_directn(card_t *card, CsrUint32 addr, void *pdata, CsrUint16 len);
+
+CsrResult unifi_write_direct16(card_t *card, CsrUint32 addr, CsrUint16 data);
+CsrResult unifi_write_directn(card_t *card, CsrUint32 addr, void *pdata, CsrUint16 len);
+
+CsrResult sdio_read_f0(card_t *card, CsrUint32 addr, CsrUint8 *pdata);
+CsrResult sdio_write_f0(card_t *card, CsrUint32 addr, CsrUint8 data);
+
+void unifi_read_panic(card_t *card);
+#ifdef CSR_PRE_ALLOC_NET_DATA
+void prealloc_netdata_free(card_t *card);
+CsrResult prealloc_netdata_alloc(card_t *card);
+#endif
+/* For diagnostic use */
+void dump(void *mem, CsrUint16 len);
+void dump16(void *mem, CsrUint16 len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CARD_SDIO_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_card_sdio_intr.c
@@ -0,0 +1,2561 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     csr_wifi_hip_card_sdio_intr.c
+ *
+ *  PURPOSE:
+ *      Interrupt processing for the UniFi SDIO driver.
+ *
+ *      We may need another signal queue of responses to UniFi to hold
+ *      bulk data commands generated by read_to_host_signals().
+ *
+ * ---------------------------------------------------------------------------
+ */
+#undef CSR_WIFI_HIP_NOISY
+
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_conversions.h"
+#include "csr_wifi_hip_card.h"
+#include "csr_wifi_hip_xbv.h"
+
+
+/*
+ * If the SDIO link is idle for this time (in milliseconds),
+ * signal UniFi to go into Deep Sleep.
+ * Valid return value of unifi_bh().
+ */
+#define UNIFI_DEFAULT_HOST_IDLE_TIMEOUT 5
+/*
+ * If the UniFi has not woken up for this time (in milliseconds),
+ * signal the bottom half to take action.
+ * Valid return value of unifi_bh().
+ */
+#define UNIFI_DEFAULT_WAKE_TIMEOUT      1000
+
+
+static CsrResult process_bh(card_t *card);
+static CsrResult handle_host_protocol(card_t *card, CsrBool *processed_something);
+
+static CsrResult flush_fh_buffer(card_t *card);
+
+static CsrResult check_fh_sig_slots(card_t *card, CsrUint16 needed, CsrInt32 *space);
+
+static CsrResult read_to_host_signals(card_t *card, CsrInt32 *processed);
+static CsrResult process_to_host_signals(card_t *card, CsrInt32 *processed);
+
+static CsrResult process_bulk_data_command(card_t *card,
+                                           const CsrUint8 *cmdptr,
+                                           CsrInt16 cmd, CsrUint16 len);
+static CsrResult process_clear_slot_command(card_t         *card,
+                                            const CsrUint8 *cmdptr);
+static CsrResult process_fh_cmd_queue(card_t *card, CsrInt32 *processed);
+static CsrResult process_fh_traffic_queue(card_t *card, CsrInt32 *processed);
+static void restart_packet_flow(card_t *card);
+static CsrResult process_clock_request(card_t *card);
+
+#ifdef CSR_WIFI_HIP_NOISY
+CsrInt16 dump_fh_buf = 0;
+#endif /* CSR_WIFI_HIP_NOISY */
+
+#ifdef CSR_WIFI_HIP_DEBUG_OFFLINE
+
+/*
+ * The unifi_debug_output buffer can be used to debug the HIP behaviour offline
+ * i.e. without using the tracing functions that change the timing.
+ *
+ * Call unifi_debug_log_to_buf() with printf arguments to store a string into
+ * unifi_debug_output. When unifi_debug_buf_dump() is called, the contents of the
+ * buffer are dumped with dump_str() which has to be implemented in the
+ * OS layer, during the porting exercise. The offset printed, holds the
+ * offset where the last character is (always a zero).
+ *
+ */
+
+#define UNIFI_DEBUG_GBUFFER_SIZE       8192
+static CsrCharString unifi_debug_output[UNIFI_DEBUG_GBUFFER_SIZE];
+static CsrCharString *unifi_dbgbuf_ptr = unifi_debug_output;
+static CsrCharString *unifi_dbgbuf_start = unifi_debug_output;
+
+static void append_char(CsrCharString c)
+{
+    /* write char and advance pointer */
+    *unifi_dbgbuf_ptr++ = c;
+    /* wrap pointer at end of buffer */
+    if ((unifi_dbgbuf_ptr - unifi_debug_output) >= UNIFI_DEBUG_GBUFFER_SIZE)
+    {
+        unifi_dbgbuf_ptr = unifi_debug_output;
+    }
+} /* append_char() */
+
+
+void unifi_debug_string_to_buf(const CsrCharString *str)
+{
+    const CsrCharString *p = str;
+    while (*p)
+    {
+        append_char(*p);
+        p++;
+    }
+    /* Update start-of-buffer pointer */
+    unifi_dbgbuf_start = unifi_dbgbuf_ptr + 1;
+    if ((unifi_dbgbuf_start - unifi_debug_output) >= UNIFI_DEBUG_GBUFFER_SIZE)
+    {
+        unifi_dbgbuf_start = unifi_debug_output;
+    }
+}
+
+
+void unifi_debug_log_to_buf(const CsrCharString *fmt, ...)
+{
+#define DEBUG_BUFFER_SIZE       80
+    static CsrCharString s[DEBUG_BUFFER_SIZE];
+    va_list args;
+
+    va_start(args, fmt);
+    CsrVsnprintf(s, DEBUG_BUFFER_SIZE, fmt, args);
+    va_end(args);
+
+    unifi_debug_string_to_buf(s);
+} /* unifi_debug_log_to_buf() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_debug_hex_to_buf
+ *
+ *  puts the contents of the passed buffer into the debug buffer as a hex string
+ *
+ *  Arguments:
+ *      buff         buffer to print as hex
+ *      length       number of chars to print
+ *
+ *  Returns:
+ *      None.
+ *
+ * ---------------------------------------------------------------------------
+ */
+void unifi_debug_hex_to_buf(const CsrCharString *buff, CsrUint16 length)
+{
+    CsrCharString s[5];
+    CsrUint16 i;
+
+    for (i = 0; i < length; i++)
+    {
+        CsrUInt16ToHex(0xff & buff[i], s);
+        unifi_debug_string_to_buf(s);
+    }
+}
+
+
+void unifi_debug_buf_dump(void)
+{
+    CsrInt32 offset = unifi_dbgbuf_ptr - unifi_debug_output;
+
+    unifi_error(NULL, "HIP debug buffer offset=%d\n", offset);
+    dump_str(unifi_debug_output + offset, UNIFI_DEBUG_GBUFFER_SIZE - offset);
+    dump_str(unifi_debug_output, offset);
+} /* unifi_debug_buf_dump() */
+
+
+#endif /* CSR_WIFI_HIP_DEBUG_OFFLINE */
+
+#ifdef CSR_PRE_ALLOC_NET_DATA
+#define NETDATA_PRE_ALLOC_BUF_SIZE 8000
+
+void prealloc_netdata_free(card_t *card)
+{
+    unifi_warning(card->ospriv, "prealloc_netdata_free: IN: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);
+
+    while (card->bulk_data_desc_list[card->prealloc_netdata_r].data_length != 0)
+    {
+        unifi_warning(card->ospriv, "prealloc_netdata_free: r=%d\n", card->prealloc_netdata_r);
+
+        unifi_net_data_free(card->ospriv, &card->bulk_data_desc_list[card->prealloc_netdata_r]);
+        card->prealloc_netdata_r++;
+        card->prealloc_netdata_r %= BULK_DATA_PRE_ALLOC_NUM;
+    }
+    card->prealloc_netdata_r = card->prealloc_netdata_w = 0;
+
+    unifi_warning(card->ospriv, "prealloc_netdata_free: OUT: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);
+}
+
+
+CsrResult prealloc_netdata_alloc(card_t *card)
+{
+    CsrResult r;
+
+    unifi_trace(card->ospriv, UDBG5, "prealloc_netdata_alloc: IN: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);
+
+    while (card->bulk_data_desc_list[card->prealloc_netdata_w].data_length == 0)
+    {
+        r = unifi_net_data_malloc(card->ospriv, &card->bulk_data_desc_list[card->prealloc_netdata_w], NETDATA_PRE_ALLOC_BUF_SIZE);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "prealloc_netdata_alloc: Failed to allocate t-h bulk data\n");
+            return CSR_RESULT_FAILURE;
+        }
+        card->prealloc_netdata_w++;
+        card->prealloc_netdata_w %= BULK_DATA_PRE_ALLOC_NUM;
+    }
+    unifi_trace(card->ospriv, UDBG5, "prealloc_netdata_alloc: OUT: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);
+
+    return CSR_RESULT_SUCCESS;
+}
+
+
+static CsrResult prealloc_netdata_get(card_t *card, bulk_data_desc_t *bulk_data_slot, CsrUint32 size)
+{
+    CsrResult r;
+
+    unifi_trace(card->ospriv, UDBG5, "prealloc_netdata_get: IN: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);
+
+    if (card->bulk_data_desc_list[card->prealloc_netdata_r].data_length == 0)
+    {
+        unifi_error(card->ospriv, "prealloc_netdata_get: data_length = 0\n");
+    }
+
+    if ((size > NETDATA_PRE_ALLOC_BUF_SIZE) || (card->bulk_data_desc_list[card->prealloc_netdata_r].data_length == 0))
+    {
+        unifi_warning(card->ospriv, "prealloc_netdata_get: Calling net_data_malloc\n");
+
+        r = unifi_net_data_malloc(card->ospriv, bulk_data_slot, size);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "prealloc_netdata_get: Failed to allocate t-h bulk data\n");
+            return CSR_RESULT_FAILURE;
+        }
+        return CSR_RESULT_SUCCESS;
+    }
+
+    *bulk_data_slot = card->bulk_data_desc_list[card->prealloc_netdata_r];
+    card->bulk_data_desc_list[card->prealloc_netdata_r].os_data_ptr = NULL;
+    card->bulk_data_desc_list[card->prealloc_netdata_r].os_net_buf_ptr = NULL;
+    card->bulk_data_desc_list[card->prealloc_netdata_r].net_buf_length = 0;
+    card->bulk_data_desc_list[card->prealloc_netdata_r].data_length = 0;
+
+    card->prealloc_netdata_r++;
+    card->prealloc_netdata_r %= BULK_DATA_PRE_ALLOC_NUM;
+
+    unifi_trace(card->ospriv, UDBG5, "prealloc_netdata_get: OUT: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);
+
+    return CSR_RESULT_SUCCESS;
+}
+
+
+#endif
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_sdio_interrupt_handler
+ *
+ *      This function should be called by the OS-dependent code to handle
+ *      an SDIO interrupt from the UniFi.
+ *
+ *  Arguments:
+ *      card            Pointer to card context structure.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes: This function may be called in DRS context. In this case,
+ *         tracing with the unifi_trace(), etc, is not allowed.
+ * ---------------------------------------------------------------------------
+ */
+void unifi_sdio_interrupt_handler(card_t *card)
+{
+    /*
+     * Set the flag to say reason for waking was SDIO interrupt.
+     * Then ask the OS layer to run the unifi_bh to give attention to the UniFi.
+     */
+    card->bh_reason_unifi = 1;
+    unifi_run_bh(card->ospriv);
+} /*  sdio_interrupt_handler() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_configure_low_power_mode
+ *
+ *      This function should be called by the OS-dependent when
+ *      the deep sleep signaling needs to be enabled or disabled.
+ *
+ *  Arguments:
+ *      card            Pointer to card context structure.
+ *      low_power_mode  Disable/Enable the deep sleep signaling
+ *      periodic_wake_mode UniFi wakes host periodically.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success or a CSR error code.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_configure_low_power_mode(card_t                       *card,
+                                         enum unifi_low_power_mode     low_power_mode,
+                                         enum unifi_periodic_wake_mode periodic_wake_mode)
+{
+    card->low_power_mode = low_power_mode;
+    card->periodic_wake_mode = periodic_wake_mode;
+
+    unifi_trace(card->ospriv, UDBG1,
+                "unifi_configure_low_power_mode: new mode = %s, wake_host = %s\n",
+                (low_power_mode == UNIFI_LOW_POWER_DISABLED)?"disabled" : "enabled",
+                (periodic_wake_mode == UNIFI_PERIODIC_WAKE_HOST_DISABLED)?"FALSE" : "TRUE");
+
+    unifi_run_bh(card->ospriv);
+    return CSR_RESULT_SUCCESS;
+} /* unifi_configure_low_power_mode() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_force_low_power_mode
+ *
+ *      This function should be called by the OS-dependent when
+ *      UniFi needs to be set to the low power mode (e.g. on suspend)
+ *
+ *  Arguments:
+ *      card            Pointer to card context structure.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success or a CSR error code.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_force_low_power_mode(card_t *card)
+{
+    if (card->low_power_mode == UNIFI_LOW_POWER_DISABLED)
+    {
+        unifi_error(card->ospriv, "Attempt to set mode to TORPID when lower power mode is disabled\n");
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    return unifi_set_host_state(card, UNIFI_HOST_STATE_TORPID);
+} /* unifi_force_low_power_mode() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_bh
+ *
+ *      This function should be called by the OS-dependent code when
+ *      host and/or UniFi has requested an exchange of messages.
+ *
+ *  Arguments:
+ *      card            Pointer to card context structure.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success or a CSR error code.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_bh(card_t *card, CsrUint32 *remaining)
+{
+    CsrResult r;
+    CsrResult csrResult;
+    CsrBool pending;
+    CsrInt32 iostate, j;
+    const enum unifi_low_power_mode low_power_mode = card->low_power_mode;
+    CsrUint16 data_slots_used = 0;
+
+
+    /* Process request to raise the maximum SDIO clock */
+    r = process_clock_request(card);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Error setting maximum SDIO clock\n");
+        goto exit;
+    }
+
+    /*
+     * Why was the BH thread woken?
+     * If it was an SDIO interrupt, UniFi is awake and we need to process it.
+     * If it was a host process queueing data, then we need to awaken UniFi.
+     *
+     * Priority of flags is top down.
+     *
+     * ----------------------------------------------------------+
+     *    \state|   AWAKE      |    DROWSY      |    TORPID      |
+     * flag\    |              |                |                |
+     * ---------+--------------+----------------+----------------|
+     *          | do the host  | go to AWAKE and| go to AWAKE and|
+     *   unifi  | protocol     | do the host    | do the host    |
+     *          |              | protocol       | protocol       |
+     * ---------+--------------+----------------+----------------|
+     *          | do the host  |                |                |
+     *   host   | protocol     |  do nothing    | go to DROWSY   |
+     *          |              |                |                |
+     * ---------+--------------+----------------+----------------|
+     *          |              |                | should not     |
+     *  timeout | go to TORPID | error, unifi   | occur          |
+     *          |              | didn't wake up | do nothing     |
+     * ----------------------------------------------------------+
+     *
+     * Note that if we end up in the AWAKE state we always do the host protocol.
+     */
+
+    do
+    {
+        /*
+         * When the host state is set to DROWSY, then we can not disable the
+         * interrupts as UniFi can generate an interrupt even when the INT_ENABLE
+         * register has the interrupts disabled. This interrupt will be lost.
+         */
+        if (card->host_state == UNIFI_HOST_STATE_DROWSY || card->host_state == UNIFI_HOST_STATE_TORPID)
+        {
+            CsrUint8 reason_unifi;
+
+            /*
+             * An interrupt may occur while or after we cache the reason.
+             * This interrupt will cause the unifi_bh() to be scheduled again.
+             * Any interrupt that has happened before the register is read
+             * and is considered spurious has to acknowledged.
+             */
+            reason_unifi = card->bh_reason_unifi;
+
+            /*
+             * If an interrupt is received, check if it was a real one,
+             * set the host state to AWAKE and run the BH.
+             */
+            r = CardPendingInt(card, &pending);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                goto exit;
+            }
+
+            if (pending)
+            {
+                unifi_trace(card->ospriv, UDBG5,
+                            "UNIFI_HOST_STATE_%s: Set state to AWAKE.\n",
+                            (card->host_state == UNIFI_HOST_STATE_TORPID)?"TORPID" : "DROWSY");
+
+                r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
+                if (r == CSR_RESULT_SUCCESS)
+                {
+                    (*remaining) = 0;
+                    break;
+                }
+            }
+            else if (reason_unifi)
+            {
+                CsrSdioInterruptAcknowledge(card->sdio_if);
+            }
+
+            /*
+             * If an chip is in TORPID, and the host wants to wake it up,
+             * set the host state to DROWSY and wait for the wake-up interrupt.
+             */
+            if ((card->host_state == UNIFI_HOST_STATE_TORPID) && card->bh_reason_host)
+            {
+                r = unifi_set_host_state(card, UNIFI_HOST_STATE_DROWSY);
+                if (r == CSR_RESULT_SUCCESS)
+                {
+                    /*
+                     * set the timeout value to UNIFI_DEFAULT_WAKE_TIMEOUT
+                     * to capture a wake error.
+                     */
+                    card->bh_reason_host = 0;
+                    (*remaining) = UNIFI_DEFAULT_WAKE_TIMEOUT;
+                    return CSR_RESULT_SUCCESS;
+                }
+
+                goto exit;
+            }
+
+            /*
+             * If the chip is in DROWSY, and the timeout expires,
+             * we need to reset the chip. This should never occur.
+             * (If it does, check that the calling thread set "remaining"
+             * according to the time remaining when unifi_bh() was called).
+             */
+            if ((card->host_state == UNIFI_HOST_STATE_DROWSY) && ((*remaining) == 0))
+            {
+                unifi_error(card->ospriv, "UniFi did not wake up on time...\n");
+
+                /*
+                 * Check if Function1 has gone away or
+                 * if we missed an SDIO interrupt.
+                 */
+                r = unifi_check_io_status(card, &iostate);
+                if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+                {
+                    goto exit;
+                }
+                /* Need to reset and reboot */
+                return CSR_RESULT_FAILURE;
+            }
+        }
+        else
+        {
+            if (card->bh_reason_unifi || card->bh_reason_host)
+            {
+                break;
+            }
+
+            if (((*remaining) == 0) && (low_power_mode == UNIFI_LOW_POWER_ENABLED))
+            {
+                r = unifi_set_host_state(card, UNIFI_HOST_STATE_TORPID);
+                if (r == CSR_RESULT_SUCCESS)
+                {
+                    (*remaining) = 0;
+                    return CSR_RESULT_SUCCESS;
+                }
+
+                goto exit;
+            }
+        }
+
+        /* No need to run the host protocol */
+        return CSR_RESULT_SUCCESS;
+    } while (0);
+
+
+    /* Disable the SDIO interrupts while doing SDIO ops */
+    csrResult = CsrSdioInterruptDisable(card->sdio_if);
+    if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+    {
+        r = CSR_WIFI_HIP_RESULT_NO_DEVICE;
+        goto exit;
+    }
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+        unifi_error(card->ospriv, "Failed to disable SDIO interrupts. unifi_bh queues error.\n");
+        goto exit;
+    }
+
+    /* Now that the interrupts are disabled, ack the interrupt */
+    CsrSdioInterruptAcknowledge(card->sdio_if);
+
+    /* Run the HIP */
+    r = process_bh(card);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        goto exit;
+    }
+
+    /*
+     * If host is now idle, schedule a timer for the delay before we
+     * let UniFi go into deep sleep.
+     * If the timer goes off, we will move to TORPID state.
+     * If UniFi raises an interrupt in the meantime, we will cancel
+     * the timer and start a new one when we become idle.
+     */
+    for (j = 0; j < UNIFI_NO_OF_TX_QS; j++)
+    {
+        data_slots_used += CSR_WIFI_HIP_Q_SLOTS_USED(&card->fh_traffic_queue[j]);
+    }
+
+    if ((low_power_mode == UNIFI_LOW_POWER_ENABLED) && (data_slots_used == 0))
+    {
+#ifndef CSR_WIFI_HIP_TA_DISABLE
+        if (card->ta_sampling.traffic_type != CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_PERIODIC)
+        {
+#endif
+        /* return the UNIFI_DEFAULT_HOST_IDLE_TIMEOUT, so we can go to sleep. */
+        unifi_trace(card->ospriv, UDBG5,
+                    "Traffic is not periodic, set timer for TORPID.\n");
+        (*remaining) = UNIFI_DEFAULT_HOST_IDLE_TIMEOUT;
+#ifndef CSR_WIFI_HIP_TA_DISABLE
+    }
+    else
+    {
+        unifi_trace(card->ospriv, UDBG5,
+                    "Traffic is periodic, set unifi to TORPID immediately.\n");
+        if (CardAreAllFromHostDataSlotsEmpty(card) == 1)
+        {
+            r = unifi_set_host_state(card, UNIFI_HOST_STATE_TORPID);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                goto exit;
+            }
+        }
+    }
+#endif
+    }
+
+    csrResult = CsrSdioInterruptEnable(card->sdio_if);
+    if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+    {
+        r = CSR_WIFI_HIP_RESULT_NO_DEVICE;
+    }
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+        unifi_error(card->ospriv, "Failed to enable SDIO interrupt\n");
+    }
+
+exit:
+
+    unifi_trace(card->ospriv, UDBG4, "New state=%d\n", card->host_state);
+
+    if (r != CSR_RESULT_SUCCESS)
+    {
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        unifi_debug_buf_dump();
+#endif
+        /* If an interrupt has been raised, ack it here */
+        if (card->bh_reason_unifi)
+        {
+            CsrSdioInterruptAcknowledge(card->sdio_if);
+        }
+
+        unifi_error(card->ospriv,
+                    "unifi_bh: state=%d %c, clock=%dkHz, interrupt=%d host=%d, power_save=%s\n",
+                    card->host_state,
+                    (card->host_state == UNIFI_HOST_STATE_AWAKE)?'A' : (card->host_state == UNIFI_HOST_STATE_DROWSY)?'D' : 'T',
+                    card->sdio_clock_speed / 1000,
+                    card->bh_reason_unifi, card->bh_reason_host,
+                    (low_power_mode == UNIFI_LOW_POWER_DISABLED)?"disabled" : "enabled");
+
+        /* Try to capture firmware panic codes */
+        unifi_capture_panic(card);
+
+        /* Ask for a mini-coredump when the driver has reset UniFi */
+        unifi_coredump_request_at_next_reset(card, 1);
+    }
+
+    return r;
+} /* unifi_bh() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  process_clock_request
+ *
+ *      Handle request from the OS layer to increase the SDIO clock speed.
+ *      The fast clock is limited until the firmware has indicated that it has
+ *      completed initialisation to the OS layer.
+ *
+ *  Arguments:
+ *      card            Pointer to card context structure.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success or CSR error code.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult process_clock_request(card_t *card)
+{
+    CsrResult r = CSR_RESULT_SUCCESS;
+    CsrResult csrResult;
+
+    if (!card->request_max_clock)
+    {
+        return CSR_RESULT_SUCCESS;   /* No pending request */
+    }
+
+    /*
+     * The SDIO clock speed request from the OS layer is only acted upon if
+     * the UniFi is awake. If it was in any other state, the clock speed will
+     * transition through SAFE to MAX while the host wakes it up, and the
+     * final speed reached will be UNIFI_SDIO_CLOCK_MAX_HZ.
+     * This assumes that the SME never requests low power mode while the f/w
+     * initialisation takes place.
+     */
+    if (card->host_state == UNIFI_HOST_STATE_AWAKE)
+    {
+        unifi_trace(card->ospriv, UDBG1, "Set SDIO max clock\n");
+        csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_MAX_HZ);
+        if (csrResult != CSR_RESULT_SUCCESS)
+        {
+            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+        }
+        else
+        {
+            card->sdio_clock_speed = UNIFI_SDIO_CLOCK_MAX_HZ;  /* log the new freq */
+        }
+    }
+    else
+    {
+        unifi_trace(card->ospriv, UDBG1, "Will set SDIO max clock after wakeup\n");
+    }
+
+    /* Cancel the request now that it has been acted upon, or is about to be
+     * by the wakeup mechanism
+     */
+    card->request_max_clock = 0;
+
+    return r;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  process_bh
+ *
+ *      Exchange messages with UniFi
+ *
+ *  Arguments:
+ *      card            Pointer to card context structure.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success or CSR error code.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult process_bh(card_t *card)
+{
+    CsrResult r;
+    CsrBool more;
+    more = FALSE;
+
+    /* Process the reasons (interrupt, signals) */
+    do
+    {
+        /*
+         * Run in a while loop, to save clearing the interrupts
+         * every time around the outside loop.
+         */
+        do
+        {
+            /* If configured to run the HIP just once, skip first loop */
+            if (card->intmode & CSR_WIFI_INTMODE_RUN_BH_ONCE)
+            {
+                break;
+            }
+
+            r = handle_host_protocol(card, &more);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+            unifi_debug_log_to_buf("c52=%d c53=%d tx=%d txc=%d rx=%d s=%d t=%d fc=%d\n",
+                                   card->cmd_prof.cmd52_count,
+                                   card->cmd_prof.cmd53_count,
+                                   card->cmd_prof.tx_count,
+                                   card->cmd_prof.tx_cfm_count,
+                                   card->cmd_prof.rx_count,
+                                   card->cmd_prof.sdio_cmd_signal,
+                                   card->cmd_prof.sdio_cmd_to_host,
+                                   card->cmd_prof.sdio_cmd_from_host_and_clear
+                                   );
+
+            card->cmd_prof.cmd52_count = card->cmd_prof.cmd53_count = 0;
+            card->cmd_prof.tx_count = card->cmd_prof.tx_cfm_count = card->cmd_prof.rx_count = 0;
+
+            card->cmd_prof.cmd52_f0_r_count = 0;
+            card->cmd_prof.cmd52_f0_w_count = 0;
+            card->cmd_prof.cmd52_r8or16_count = 0;
+            card->cmd_prof.cmd52_w8or16_count = 0;
+            card->cmd_prof.cmd52_r16_count = 0;
+            card->cmd_prof.cmd52_w16_count = 0;
+            card->cmd_prof.cmd52_r32_count = 0;
+
+            card->cmd_prof.sdio_cmd_signal = 0;
+            card->cmd_prof.sdio_cmd_clear_slot = 0;
+            card->cmd_prof.sdio_cmd_to_host = 0;
+            card->cmd_prof.sdio_cmd_from_host = 0;
+            card->cmd_prof.sdio_cmd_from_host_and_clear = 0;
+#endif
+
+
+        } while (more || card->bh_reason_unifi || card->bh_reason_host);
+
+        /* Acknowledge the h/w interrupt */
+        r = CardClearInt(card);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to acknowledge interrupt.\n");
+            return r;
+        }
+
+        /*
+         * UniFi may have tried to generate an interrupt during the
+         * CardClearInt() was running. So, we need to run the host
+         * protocol again, to check if there are any pending requests.
+         */
+        r = handle_host_protocol(card, &more);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            return r;
+        }
+
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+        unifi_debug_log_to_buf("c52=%d c53=%d tx=%d txc=%d rx=%d s=%d t=%d fc=%d\n",
+                               card->cmd_prof.cmd52_count,
+                               card->cmd_prof.cmd53_count,
+                               card->cmd_prof.tx_count,
+                               card->cmd_prof.tx_cfm_count,
+                               card->cmd_prof.rx_count,
+                               card->cmd_prof.sdio_cmd_signal,
+                               card->cmd_prof.sdio_cmd_to_host,
+                               card->cmd_prof.sdio_cmd_from_host_and_clear
+                               );
+
+        card->cmd_prof.cmd52_count = card->cmd_prof.cmd53_count = 0;
+        card->cmd_prof.tx_count = card->cmd_prof.tx_cfm_count = card->cmd_prof.rx_count = 0;
+
+        card->cmd_prof.cmd52_f0_r_count = 0;
+        card->cmd_prof.cmd52_f0_w_count = 0;
+        card->cmd_prof.cmd52_r8or16_count = 0;
+        card->cmd_prof.cmd52_w8or16_count = 0;
+        card->cmd_prof.cmd52_r16_count = 0;
+        card->cmd_prof.cmd52_w16_count = 0;
+        card->cmd_prof.cmd52_r32_count = 0;
+
+        card->cmd_prof.sdio_cmd_signal = 0;
+        card->cmd_prof.sdio_cmd_clear_slot = 0;
+        card->cmd_prof.sdio_cmd_to_host = 0;
+        card->cmd_prof.sdio_cmd_from_host = 0;
+        card->cmd_prof.sdio_cmd_from_host_and_clear = 0;
+#endif
+        /* If configured to run the HIP just once, work is now done */
+        if (card->intmode & CSR_WIFI_INTMODE_RUN_BH_ONCE)
+        {
+            break;
+        }
+
+    } while (more || card->bh_reason_unifi || card->bh_reason_host);
+
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+    if ((card->intmode & CSR_WIFI_INTMODE_RUN_BH_ONCE) == 0)
+    {
+        unifi_debug_log_to_buf("proc=%d\n",
+                               card->cmd_prof.process_count);
+    }
+#endif
+
+    return CSR_RESULT_SUCCESS;
+} /* process_bh() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  handle_host_protocol
+ *
+ *      This function implements the Host Interface Protocol (HIP) as
+ *      described in the Host Interface Protocol Specification.
+ *
+ *  Arguments:
+ *      card                 Pointer to card context structure.
+ *      processed_something  Pointer to location to update processing status:
+ *                              TRUE when data was transferred
+ *                              FALSE when no data was transferred (queues empty)
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success or CSR error code.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult handle_host_protocol(card_t *card, CsrBool *processed_something)
+{
+    CsrResult r;
+    CsrInt32 done;
+
+    *processed_something = FALSE;
+
+#ifdef CSR_WIFI_HIP_NOISY
+    unifi_error(card->ospriv, "   ========================     \n");
+#endif /* CSR_WIFI_HIP_NOISY */
+
+#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE
+    card->cmd_prof.process_count++;
+#endif
+
+    card->bh_reason_unifi = card->bh_reason_host = 0;
+    card->generate_interrupt = 0;
+
+
+    /*
+     * (Re)fill the T-H signal buffer
+     */
+    r = read_to_host_signals(card, &done);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Error occured reading to-host signals\n");
+        return r;
+    }
+    if (done > 0)
+    {
+        *processed_something = TRUE;
+    }
+
+    /*
+     * Process any to-host signals.
+     * Perform any requested CMD53 transfers here, but just queue any
+     * bulk data command responses.
+     */
+    r = process_to_host_signals(card, &done);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Error occured processing to-host signals\n");
+        return r;
+    }
+
+    /* Now send any signals in the F-H queues */
+    /* Give precedence to the command queue */
+    r = process_fh_cmd_queue(card, &done);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Error occured processing from-host signals\n");
+        return r;
+    }
+    if (done > 0)
+    {
+        *processed_something = TRUE;
+    }
+
+    r = process_fh_traffic_queue(card, &done);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Error occured processing from-host data signals\n");
+        return r;
+    }
+    if (done > 0)
+    {
+        *processed_something = TRUE;
+    }
+
+    /* Flush out the batch of signals to the UniFi. */
+    r = flush_fh_buffer(card);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to copy from-host signals to UniFi\n");
+        return r;
+    }
+
+
+    /*
+     * Send the host interrupt to say the queues have been modified.
+     */
+    if (card->generate_interrupt)
+    {
+        r = CardGenInt(card);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to notify UniFi that queues have been modified.\n");
+            return r;
+        }
+    }
+#ifdef CSR_WIFI_RX_PATH_SPLIT_DONT_USE_WQ
+    unifi_rx_queue_flush(card->ospriv);
+#endif
+    /* See if we can re-enable transmission now */
+    restart_packet_flow(card);
+
+#ifdef CSR_PRE_ALLOC_NET_DATA
+    r = prealloc_netdata_alloc(card);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "prealloc_netdata failed\n");
+        return r;
+    }
+#endif
+
+    /*
+     * Don't put the thread sleep if we just interacted with the chip,
+     * there might be more to do if we look again.
+     */
+    return r;
+} /* handle_host_protocol() */
+
+
+/*
+ *      Rounds the given signal length in bytes to a whole number
+ *      of sig_frag_size.
+ */
+#define GET_CHUNKS_FOR(SIG_FRAG_SIZE, LENGTH) (((LENGTH) + ((SIG_FRAG_SIZE)-1)) / (SIG_FRAG_SIZE))
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  read_to_host_signals
+ *
+ *      Read everything pending in the UniFi TH signal buffer.
+ *      Only do it if the local buffer is empty.
+ *
+ *  Arguments:
+ *      card        Pointer to card context struct
+ *      processed   Number of signals read:
+ *                      0 if there were no signals pending,
+ *                      1 if we read at least one signal
+ *  Returns:
+ *      CSR error code if an error occurred.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult read_to_host_signals(card_t *card, CsrInt32 *processed)
+{
+    CsrInt32 count_thw, count_thr;
+    CsrInt32 unread_chunks, unread_bytes;
+    CsrResult r;
+
+    *processed = 0;
+
+    /* Read any pending signals or bulk data commands */
+    count_thw = unifi_read_shared_count(card, card->sdio_ctrl_addr + 4);
+    if (count_thw < 0)
+    {
+        unifi_error(card->ospriv, "Failed to read to-host sig written count\n");
+        return CSR_RESULT_FAILURE;
+    }
+    card->to_host_signals_w = count_thw; /* diag */
+
+    count_thr = card->to_host_signals_r;
+
+    if (count_thw == count_thr)
+    {
+        return CSR_RESULT_SUCCESS;
+    }
+
+    unread_chunks =
+        (((count_thw - count_thr) + 128) % 128) - card->th_buffer.count;
+
+    if (unread_chunks == 0)
+    {
+        return CSR_RESULT_SUCCESS;
+    }
+
+    unread_bytes = card->config_data.sig_frag_size * unread_chunks;
+
+
+    r = unifi_bulk_rw(card,
+                      card->config_data.tohost_sigbuf_handle,
+                      card->th_buffer.ptr,
+                      unread_bytes,
+                      UNIFI_SDIO_READ);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to read ToHost signal\n");
+        return r;
+    }
+
+    card->th_buffer.ptr += unread_bytes;
+    card->th_buffer.count += (CsrUint16)unread_chunks;
+
+    *processed = 1;
+
+    return CSR_RESULT_SUCCESS;
+} /* read_to_host_signals() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  update_to_host_signals_r
+ *
+ *      Advance the shared-memory count of chunks read from the to-host
+ *      signal buffer.
+ *      Raise a UniFi internal interrupt to tell the firmware that the
+ *      count has changed.
+ *
+ *  Arguments:
+ *      card            Pointer to card context struct
+ *      pending         Number of chunks remaining
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success or CSR error code
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult update_to_host_signals_r(card_t *card, CsrInt16 pending)
+{
+    CsrResult r;
+
+    card->to_host_signals_r =
+        (card->to_host_signals_r + (card->th_buffer.count - pending)) % 128;
+    card->th_buffer.count = pending;
+
+    /* Update the count of signals read */
+    r = unifi_write_8_or_16(card, card->sdio_ctrl_addr + 6,
+                            (CsrUint8)card->to_host_signals_r);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to update to-host signals read\n");
+        return r;
+    }
+
+    r = CardGenInt(card);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to notify UniFi that we processed to-host signals.\n");
+        return r;
+    }
+
+    card->generate_interrupt = 0;
+
+    return CSR_RESULT_SUCCESS;
+} /* update_to_host_signals_r() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  read_unpack_cmd
+ *
+ *      Converts a wire-formatted command to the host bulk_data_cmd_t structure.
+ *
+ *  Arguments:
+ *      ptr             Pointer to the command
+ *      bulk_data_cmd   Pointer to the host structure
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void read_unpack_cmd(const CsrUint8 *ptr, bulk_data_cmd_t *bulk_data_cmd)
+{
+    CsrInt16 index = 0;
+    bulk_data_cmd->cmd_and_len = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+    index += SIZEOF_UINT16;
+    bulk_data_cmd->data_slot = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+    index += SIZEOF_UINT16;
+    bulk_data_cmd->offset = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+    index += SIZEOF_UINT16;
+    bulk_data_cmd->buffer_handle = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+    index += SIZEOF_UINT16;
+} /* read_unpack_cmd */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  process_to_host_signals
+ *
+ *      Read and dispatch signals from the UniFi
+ *
+ *  Arguments:
+ *      card        Pointer to card context struct
+ *      processed   Pointer to location to write processing result:
+ *                      0 if there were no signals pending,
+ *                      1 if we read at least one signal
+ *
+ *  Returns:
+ *      CSR error code if there was an error
+ *
+ *  Notes:
+ *      Since bulk data transfers can take a long time, if we wait until
+ *      all are done before we acknowledge the signals, the UniFi runs out
+ *      of buffer space. Therefore we keep a count of the bytes transferred
+ *      in bulk data commands, and update the to-host-signals-read count
+ *      if we've done a large transfer.
+ *
+ *      All data in the f/w is stored in a little endian format, without any
+ *      padding bytes. Every read from the memory has to be transformed in
+ *      host (cpu specific) format, before we can process it. Therefore we
+ *      use read_unpack_cmd() and read_unpack_signal() to convert the raw data
+ *      contained in the card->th_buffer.buf to host structures.
+ *      Important: UDI clients use wire-formatted structures, so we need to
+ *      indicate all data, as we have read it from the device.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult process_to_host_signals(card_t *card, CsrInt32 *processed)
+{
+    CsrInt16 pending;
+    CsrInt16 remaining;
+    CsrUint8 *bufptr;
+    bulk_data_param_t data_ptrs;
+    CsrInt16 cmd;
+    CsrUint16 sig_len;
+    CsrInt16 i;
+    CsrUint16 chunks_in_buf;
+    CsrUint16 bytes_transferred = 0;
+    CsrResult r = CSR_RESULT_SUCCESS;
+
+    *processed = 0;
+
+    pending = card->th_buffer.count;
+
+    /* Are there new to-host signals? */
+    unifi_trace(card->ospriv, UDBG4, "handling %d to-host chunks\n", pending);
+
+    if (!pending)
+    {
+        return CSR_RESULT_SUCCESS;
+    }
+
+    /*
+     * This is a pointer to the raw data we have read from the f/w.
+     * Can be a signal or a command. Note that we need to convert
+     * it to a host structure before we process it.
+     */
+    bufptr = card->th_buffer.buf;
+
+    while (pending > 0)
+    {
+        CsrInt16 f_flush_count = 0;
+
+        /*
+         * Command and length are common to signal and bulk data msgs.
+         * If command == 0 (i.e. a signal), len is number of bytes
+         * *following* the 2-byte header.
+         */
+        cmd = bufptr[1] >> 4;
+        sig_len = bufptr[0] + ((bufptr[1] & 0x0F) << 8);
+
+#ifdef CSR_WIFI_HIP_NOISY
+        unifi_error(card->ospriv, "Received UniFi msg cmd=%d, len=%d\n",
+                    cmd, sig_len);
+#endif  /* CSR_WIFI_HIP_NOISY */
+
+        if ((sig_len == 0) &&
+            ((cmd != SDIO_CMD_CLEAR_SLOT) && (cmd != SDIO_CMD_PADDING)))
+        {
+            unifi_error(card->ospriv, "incomplete signal or command: has size zero\n");
+            return CSR_RESULT_FAILURE;
+        }
+        /*
+         * Make sure the buffer contains a complete message.
+         * Signals may occupy multiple chunks, bulk-data commands occupy
+         * one chunk.
+         */
+        if (cmd == SDIO_CMD_SIGNAL)
+        {
+            chunks_in_buf = GET_CHUNKS_FOR(card->config_data.sig_frag_size, (CsrUint16)(sig_len + 2));
+        }
+        else
+        {
+            chunks_in_buf = 1;
+        }
+
+        if (chunks_in_buf > (CsrUint16)pending)
+        {
+            unifi_error(card->ospriv, "incomplete signal (0x%x?): need %d chunks, got %d\n",
+                        GET_SIGNAL_ID(bufptr + 2),
+                        chunks_in_buf, pending);
+            unifi_error(card->ospriv, " thsw=%d, thsr=%d\n",
+                        card->to_host_signals_w,
+                        card->to_host_signals_r);
+            return CSR_RESULT_FAILURE;
+        }
+
+
+        switch (cmd)
+        {
+            case SDIO_CMD_SIGNAL:
+                /* This is a signal. Read the rest of it and then handle it. */
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+                card->cmd_prof.sdio_cmd_signal++;
+#endif
+
+                for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)
+                {
+                    /* Retrieve dataRefs[i].DataLength */
+                    CsrUint16 data_len = GET_PACKED_DATAREF_LEN(bufptr + 2, i);
+
+                    /*
+                     * The bulk data length in the signal can not be greater than
+                     * the maximun length allowed by the SDIO config structure.
+                     */
+                    if (data_len > card->config_data.data_slot_size)
+                    {
+                        unifi_error(card->ospriv,
+                                    "Bulk Data length (%d) exceeds Maximum Bulk Data length (%d)\n",
+                                    data_len, card->config_data.data_slot_size);
+                        return CSR_RESULT_FAILURE;
+                    }
+
+                    /*
+                     * Len here might not be the same as the length in the
+                     * bulk data slot.  The slot length will always be even,
+                     * but len could be odd.
+                     */
+                    if (data_len != 0)
+                    {
+                    /* Retrieve dataRefs[i].SlotNumber */
+                        CsrInt16 slot = GET_PACKED_DATAREF_SLOT(bufptr + 2, i);
+
+                        if (slot >= card->config_data.num_tohost_data_slots)
+                        {
+                            unifi_error(card->ospriv, "!!!bad slot number in to-host signal: %d, sig 0x%X\n",
+                                        slot, cmd);
+                            return CSR_RESULT_FAILURE;
+                        }
+
+                        data_ptrs.d[i].os_data_ptr = card->to_host_data[slot].os_data_ptr;
+                        data_ptrs.d[i].os_net_buf_ptr = card->to_host_data[slot].os_net_buf_ptr;
+                        data_ptrs.d[i].net_buf_length = card->to_host_data[slot].net_buf_length;
+                        data_ptrs.d[i].data_length = data_len;
+                    }
+                    else
+                    {
+                        UNIFI_INIT_BULK_DATA(&data_ptrs.d[i]);
+                    }
+                }
+
+            /*
+             * Log the signal to the UDI, before call unifi_receive_event() as
+             * it can modify the bulk data.
+             */
+                if (card->udi_hook)
+                {
+                    (*card->udi_hook)(card->ospriv, bufptr + 2, sig_len,
+                                      &data_ptrs, UDI_LOG_TO_HOST);
+                }
+
+#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE
+                if (GET_SIGNAL_ID(bufptr + 2) == CSR_MA_PACKET_CONFIRM_ID)
+                {
+                    card->cmd_prof.tx_cfm_count++;
+                }
+                else if (GET_SIGNAL_ID(bufptr + 2) == CSR_MA_PACKET_INDICATION_ID)
+                {
+                    if (data_ptrs.d[0].os_data_ptr)
+                    {
+                        if ((*data_ptrs.d[0].os_data_ptr) & 0x08)
+                        {
+                            card->cmd_prof.rx_count++;
+                        }
+                    }
+                }
+#endif
+                /*
+                 * Check if the signal is MA-PACKET.cfm and if so check the status.
+                 * If the status is failure, search through the slot records to find
+                 * if any slots are occupied for this host tag. This can happen if
+                 * f/w has not downloaded the bulkdata and before that itself it has
+                 * signalled the confirm with failure. If it finds a slot with that
+                 * host tag then, it clears the corresponding slot
+                 */
+
+                if (GET_SIGNAL_ID(bufptr + 2) == CSR_MA_PACKET_CONFIRM_ID)
+                {
+                    /* Get host tag and transmission status */
+                    CsrUint32 host_tag = GET_PACKED_MA_PACKET_CONFIRM_HOST_TAG(bufptr + 2);
+                    CsrUint16 status = GET_PACKED_MA_PACKET_CONFIRM_TRANSMISSION_STATUS(bufptr + 2);
+
+                    unifi_trace(card->ospriv, UDBG4, "process_to_host_signals signal ID=%x host Tag=%x status=%x\n",
+                                GET_SIGNAL_ID(bufptr + 2), host_tag, status);
+
+                    /* If transmission status is failure then search through the slot records
+                     * and if for any slot records the clear slot is not done then do it now
+                     */
+
+                    if (status && (card->fh_slot_host_tag_record))
+                    {
+                        CsrUint16 num_fh_slots = card->config_data.num_fromhost_data_slots;
+                        CsrUint16 i = 0;
+
+                        /* search through the list of slot records and match with host tag
+                         * If a slot is not yet cleared then clear the slot from here
+                         */
+                        for (i = 0; i < num_fh_slots; i++)
+                        {
+                            if (card->fh_slot_host_tag_record[i] == host_tag)
+                            {
+                                unifi_trace(card->ospriv, UDBG4, "process_to_host_signals Clear slot=%x host tag=%x\n", i, host_tag);
+                                card->fh_slot_host_tag_record[i] = CSR_WIFI_HIP_RESERVED_HOST_TAG;
+
+                                /* Set length field in from_host_data array to 0 */
+                                CardClearFromHostDataSlot(card, i);
+
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                /* Pass event to OS layer */
+                unifi_receive_event(card->ospriv, bufptr + 2, sig_len, &data_ptrs);
+
+                /* Initialise the to_host data, so it can be re-used. */
+                for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)
+                {
+                /* The slot is only valid if the length is non-zero. */
+                    if (GET_PACKED_DATAREF_LEN(bufptr + 2, i) != 0)
+                    {
+                        CsrInt16 slot = GET_PACKED_DATAREF_SLOT(bufptr + 2, i);
+                        if (slot < card->config_data.num_tohost_data_slots)
+                        {
+                            UNIFI_INIT_BULK_DATA(&card->to_host_data[slot]);
+                        }
+                    }
+                }
+
+#ifndef CSR_WIFI_DEFER_TH_FLUSH
+                /*
+                 * If we have previously transferred a lot of data, ack
+                 * the signals read so far, so f/w can reclaim the buffer
+                 * memory sooner.
+                 */
+                if (bytes_transferred >= TO_HOST_FLUSH_THRESHOLD)
+                {
+                    f_flush_count = 1;
+                }
+#endif
+                break;
+
+
+            case SDIO_CMD_CLEAR_SLOT:
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+                card->cmd_prof.sdio_cmd_clear_slot++;
+#endif
+                /* This is a clear slot command. */
+                if (sig_len != 0)
+                {
+                    unifi_error(card->ospriv, "process_to_host_signals: clear slot, bad data len: 0x%X at offset %d\n",
+                                sig_len, bufptr - card->th_buffer.buf);
+                    return CSR_RESULT_FAILURE;
+                }
+
+                r = process_clear_slot_command(card, bufptr);
+                if (r != CSR_RESULT_SUCCESS)
+                {
+                    unifi_error(card->ospriv, "Failed to process clear slot\n");
+                    return r;
+                }
+                break;
+
+            case SDIO_CMD_TO_HOST_TRANSFER:
+            case SDIO_CMD_FROM_HOST_TRANSFER:
+            case SDIO_CMD_FROM_HOST_AND_CLEAR:
+            case SDIO_CMD_OVERLAY_TRANSFER:
+                /* This is a bulk data command. */
+                if (sig_len & 1)
+                {
+                    unifi_error(card->ospriv, "process_to_host_signals: bulk data, bad data len: 0x%X at offset %d\n",
+                                sig_len, bufptr - card->th_buffer.buf);
+                    return CSR_RESULT_FAILURE;
+                }
+
+                r = process_bulk_data_command(card, bufptr, cmd, sig_len);
+                if (r != CSR_RESULT_SUCCESS)
+                {
+                    unifi_error(card->ospriv, "Failed to process bulk cmd\n");
+                    return r;
+                }
+                /* Count the bytes transferred */
+                bytes_transferred += sig_len;
+
+                if (cmd == SDIO_CMD_FROM_HOST_AND_CLEAR)
+                {
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+                    card->cmd_prof.sdio_cmd_from_host_and_clear++;
+#endif
+#ifndef CSR_WIFI_DEFER_TH_FLUSH
+                    f_flush_count = 1;
+#endif
+                }
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+                else if (cmd == SDIO_CMD_FROM_HOST_TRANSFER)
+                {
+                    card->cmd_prof.sdio_cmd_from_host++;
+                }
+                else if (cmd == SDIO_CMD_TO_HOST_TRANSFER)
+                {
+                    card->cmd_prof.sdio_cmd_to_host++;
+                }
+#endif
+                break;
+
+            case SDIO_CMD_PADDING:
+                break;
+
+            default:
+                unifi_error(card->ospriv, "Unrecognised to-host command: %d\n", cmd);
+                break;
+        }
+
+        bufptr += chunks_in_buf * card->config_data.sig_frag_size;
+        pending -= chunks_in_buf;
+
+        /*
+         * Write out the host signal count when a significant
+         * number of bytes of bulk data have been transferred or
+         * when we have performed a CopyFromHostAndClear.
+         */
+        if (f_flush_count)
+        {
+            r = update_to_host_signals_r(card, pending);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            bytes_transferred = 0;
+        }
+    }
+
+    if (pending)
+    {
+        unifi_warning(card->ospriv, "proc_th_sigs: %d unprocessed\n", pending);
+    }
+
+    /* If we processed any signals, write the updated count to UniFi */
+    if (card->th_buffer.count != pending)
+    {
+        r = update_to_host_signals_r(card, pending);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            return r;
+        }
+    }
+
+    /*
+     * Reset the buffer pointer, copying down any un-processed signals.
+     * This can happen if we enable the optimisation in read_to_host_signals()
+     * that limits the length to whole blocks.
+     */
+    remaining = card->th_buffer.ptr - bufptr;
+    if (remaining < 0)
+    {
+        unifi_error(card->ospriv, "Processing TH signals overran the buffer\n");
+        return CSR_RESULT_FAILURE;
+    }
+    if (remaining > 0)
+    {
+        /* Use a safe copy because source and destination may overlap */
+        CsrUint8 *d = card->th_buffer.buf;
+        CsrUint8 *s = bufptr;
+        CsrInt32 n = remaining;
+        while (n--)
+        {
+            *d++ = *s++;
+        }
+    }
+    card->th_buffer.ptr = card->th_buffer.buf + remaining;
+
+
+    /* If we reach here then we processed something */
+    *processed = 1;
+    return CSR_RESULT_SUCCESS;
+} /* process_to_host_signals() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  process_clear_slot_command
+ *
+ *      Process a clear slot command fom the UniFi.
+ *
+ *  Arguments:
+ *   card       Pointer to card context struct
+ *   bdcmd      Pointer to bulk-data command msg from UniFi
+ *
+ *  Returns:
+ *      0 on success, CSR error code on error
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult process_clear_slot_command(card_t *card, const CsrUint8 *cmdptr)
+{
+    CsrUint16 data_slot;
+    CsrInt16 slot;
+
+    data_slot = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cmdptr + SIZEOF_UINT16);
+
+    unifi_trace(card->ospriv, UDBG4, "Processing clear slot cmd, slot=0x%X\n",
+                data_slot);
+
+    slot = data_slot & 0x7FFF;
+
+#ifdef CSR_WIFI_HIP_NOISY
+    unifi_error(card->ospriv, "CMD clear data slot 0x%04x\n", data_slot);
+#endif /* CSR_WIFI_HIP_NOISY */
+
+    if (data_slot & SLOT_DIR_TO_HOST)
+    {
+        if (slot >= card->config_data.num_tohost_data_slots)
+        {
+            unifi_error(card->ospriv,
+                        "Invalid to-host data slot in SDIO_CMD_CLEAR_SLOT: %d\n",
+                        slot);
+            return CSR_RESULT_FAILURE;
+        }
+        /* clear to-host data slot */
+        unifi_warning(card->ospriv, "Unexpected clear to-host data slot cmd: 0x%04x\n",
+                      data_slot);
+    }
+    else
+    {
+        if (slot >= card->config_data.num_fromhost_data_slots)
+        {
+            unifi_error(card->ospriv,
+                        "Invalid from-host data slot in SDIO_CMD_CLEAR_SLOT: %d\n",
+                        slot);
+            return CSR_RESULT_FAILURE;
+        }
+
+        /*
+         * The driver is the owner to clear all slots now
+         * Ref - comment in process_fh_traffic_queue
+         * so it will just ignore the clear slot command from firmware
+         * and return success
+         */
+        return CSR_RESULT_SUCCESS;
+
+        /* Set length field in from_host_data array to 0 */
+        /* CardClearFromHostDataSlot(card, slot); */
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* process_clear_slot_command() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  process_bulk_data_command
+ *
+ *      Process a bulk data request from the UniFi.
+ *
+ *  Arguments:
+ *   card       Pointer to card context struct
+ *   bdcmd      Pointer to bulk-data command msg from UniFi
+ *   cmd, len   Decoded values of command and length from the msg header
+ *              Cmd will only be one of:
+ *                      SDIO_CMD_TO_HOST_TRANSFER
+ *                      SDIO_CMD_FROM_HOST_TRANSFER
+ *                      SDIO_CMD_FROM_HOST_AND_CLEAR
+ *                      SDIO_CMD_OVERLAY_TRANSFER
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error code on error
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult process_bulk_data_command(card_t *card, const CsrUint8 *cmdptr,
+                                           CsrInt16 cmd, CsrUint16 len)
+{
+    bulk_data_desc_t *bdslot;
+#ifdef CSR_WIFI_ALIGNMENT_WORKAROUND
+    CsrUint8 *host_bulk_data_slot;
+#endif
+    bulk_data_cmd_t bdcmd;
+    CsrInt16 offset;
+    CsrInt16 slot;
+    CsrInt16 dir;
+    CsrResult r;
+
+    read_unpack_cmd(cmdptr, &bdcmd);
+
+    unifi_trace(card->ospriv, UDBG4, "Processing bulk data cmd %d %s, len=%d, slot=0x%X\n",
+                cmd, lookup_bulkcmd_name(cmd), len, bdcmd.data_slot);
+
+    /*
+     * Round up the transfer length if required.
+     * This is useful to force all transfers to be a multiple of the SDIO block
+     * size, so the SDIO driver won't try to use a byte-mode CMD53. These are
+     * broken on some hardware platforms.
+     */
+    if (card->sdio_io_block_pad)
+    {
+        len = (len + card->sdio_io_block_size - 1) & ~(card->sdio_io_block_size - 1);
+        unifi_trace(card->ospriv, UDBG4, "Rounded bulk data length up to %d\n", len);
+    }
+
+    slot = bdcmd.data_slot & 0x7FFF;
+
+    if (cmd == SDIO_CMD_OVERLAY_TRANSFER)
+    {
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;     /* Not used on CSR6xxx */
+    }
+    else
+    {
+        if (bdcmd.data_slot & SLOT_DIR_TO_HOST)
+        {
+            /* Request is for to-host bulk data */
+
+            /* Check sanity of slot number */
+            if (slot >= card->config_data.num_tohost_data_slots)
+            {
+                unifi_error(card->ospriv,
+                            "Invalid to-host data slot in SDIO bulk xfr req: %d\n",
+                            slot);
+                return CSR_RESULT_FAILURE;
+            }
+
+            /* Allocate memory for card->to_host_data[slot] bulk data here. */
+#ifdef CSR_PRE_ALLOC_NET_DATA
+            r = prealloc_netdata_get(card, &card->to_host_data[slot], len);
+#else
+            r = unifi_net_data_malloc(card->ospriv, &card->to_host_data[slot], len);
+#endif
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                unifi_error(card->ospriv, "Failed to allocate t-h bulk data\n");
+                return CSR_RESULT_FAILURE;
+            }
+
+            bdslot = &card->to_host_data[slot];
+
+            /* Make sure that the buffer is 4-bytes aligned */
+            r = unifi_net_dma_align(card->ospriv, bdslot);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                unifi_error(card->ospriv, "Failed to align t-h bulk data buffer for DMA\n");
+                return CSR_RESULT_FAILURE;
+            }
+        }
+        else
+        {
+            /* Request is for from-host bulk data */
+
+            if (slot >= card->config_data.num_fromhost_data_slots)
+            {
+                unifi_error(card->ospriv,
+                            "Invalid from-host data slot in SDIO bulk xfr req: %d\n",
+                            slot);
+                return CSR_RESULT_FAILURE;
+            }
+            bdslot = &card->from_host_data[slot].bd;
+        }
+        offset = bdcmd.offset;
+    }
+    /* Do the transfer */
+    dir = (cmd == SDIO_CMD_TO_HOST_TRANSFER)?
+          UNIFI_SDIO_READ : UNIFI_SDIO_WRITE;
+
+    unifi_trace(card->ospriv, UDBG4,
+                "Bulk %c %s len=%d, handle %d - slot=%d %p+(%d)\n",
+                (dir == UNIFI_SDIO_READ)?'R' : 'W',
+                lookup_bulkcmd_name(cmd),
+                len,
+                bdcmd.buffer_handle,
+                slot, bdslot->os_data_ptr, offset);
+#ifdef CSR_WIFI_HIP_NOISY
+    unifi_error(card->ospriv, "Bulk %s len=%d, handle %d - slot=%d %p+(%d)\n",
+                lookup_bulkcmd_name(cmd),
+                len,
+                bdcmd.buffer_handle,
+                slot, bdslot->os_data_ptr, offset);
+#endif /* CSR_WIFI_HIP_NOISY */
+
+
+    if (bdslot->os_data_ptr == NULL)
+    {
+        unifi_error(card->ospriv, "Null os_data_ptr - Bulk %s handle %d - slot=%d o=(%d)\n",
+                    lookup_bulkcmd_name(cmd),
+                    bdcmd.buffer_handle,
+                    slot,
+                    offset);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+#ifdef CSR_WIFI_ALIGNMENT_WORKAROUND
+    /* if os_data_ptr is not 4-byte aligned, then allocate a new buffer and copy data
+    to new buffer to ensure the address passed to unifi_bulk_rw is 4-byte aligned */
+
+    if (len != 0 && (dir == UNIFI_SDIO_WRITE) && (((CsrIntptr)bdslot->os_data_ptr + offset) & 3))
+    {
+        host_bulk_data_slot = CsrMemAlloc(len);
+
+        if (!host_bulk_data_slot)
+        {
+            unifi_error(card->ospriv, " failed to allocate request_data before unifi_bulk_rw\n");
+            return -1;
+        }
+
+        CsrMemCpy((void *)host_bulk_data_slot,
+                  (void *)(bdslot->os_data_ptr + offset), len);
+
+        r = unifi_bulk_rw(card,
+                          bdcmd.buffer_handle,
+                          (void *)host_bulk_data_slot,
+                          len,
+                          dir);
+    }
+    else
+#endif
+    {
+        r = unifi_bulk_rw(card,
+                          bdcmd.buffer_handle,
+                          (void *)(bdslot->os_data_ptr + offset),
+                          len,
+                          dir);
+    }
+
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv,
+                    "Failed: %s hlen=%d, slen=%d, handle %d - slot=%d %p+0x%X\n",
+                    lookup_bulkcmd_name(cmd),
+                    len,                    /* Header length */
+                    bdslot->data_length,    /* Length stored in slot */
+                    bdcmd.buffer_handle,
+                    slot, bdslot->os_data_ptr, offset);
+        return r;
+    }
+
+    bdslot->data_length = len;
+
+    if (cmd == SDIO_CMD_FROM_HOST_AND_CLEAR)
+    {
+        if (slot >= card->config_data.num_fromhost_data_slots)
+        {
+            unifi_error(card->ospriv,
+                        "Invalid from-host data slot in SDIO_CMD_FROM_HOST_AND_CLEAR: %d\n",
+                        slot);
+            return CSR_RESULT_FAILURE;
+        }
+
+#ifdef CSR_WIFI_ALIGNMENT_WORKAROUND
+        /* moving this check before we clear host data slot */
+        if ((len != 0) && (dir == UNIFI_SDIO_WRITE) && (((CsrIntptr)bdslot->os_data_ptr + offset) & 3))
+        {
+            CsrMemFree(host_bulk_data_slot);
+        }
+#endif
+
+        if (card->fh_slot_host_tag_record)
+        {
+            unifi_trace(card->ospriv, UDBG5, "CopyFromHostAndClearSlot Reset entry for slot=%d\n", slot);
+
+            /* reset the host tag entry for the corresponding slot */
+            card->fh_slot_host_tag_record[slot] = CSR_WIFI_HIP_RESERVED_HOST_TAG;
+        }
+
+
+        /* Set length field in from_host_data array to 0 */
+        CardClearFromHostDataSlot(card, slot);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* process_bulk_data_command() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  check_fh_sig_slots
+ *
+ *      Check whether there are <n> free signal slots available on UniFi.
+ *      This takes into account the signals already batched since the
+ *      from_host_signal counts were last read.
+ *      If the from_host_signal counts indicate not enough space, we read
+ *      the latest count from UniFi to see if some more have been freed.
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS, otherwise CSR error code on error.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult check_fh_sig_slots(card_t *card, CsrUint16 needed, CsrInt32 *space_fh)
+{
+    CsrUint32 count_fhw;
+    CsrUint32 occupied_fh, slots_fh;
+    CsrInt32 count_fhr;
+
+    count_fhw = card->from_host_signals_w;
+    count_fhr = card->from_host_signals_r;
+    slots_fh = card->config_data.num_fromhost_sig_frags;
+
+    /* Only read the space in from-host queue if necessary */
+    occupied_fh = (count_fhw - count_fhr) % 128;
+
+    if (slots_fh < occupied_fh)
+    {
+        *space_fh = 0;
+    }
+    else
+    {
+        *space_fh = slots_fh - occupied_fh;
+    }
+
+    if ((occupied_fh != 0) && (*space_fh < needed))
+    {
+        count_fhr = unifi_read_shared_count(card, card->sdio_ctrl_addr + 2);
+        if (count_fhr < 0)
+        {
+            unifi_error(card->ospriv, "Failed to read from-host sig read count\n");
+            return CSR_RESULT_FAILURE;
+        }
+        card->from_host_signals_r = count_fhr; /* diag */
+
+        occupied_fh = (count_fhw - count_fhr) % 128;
+        *space_fh = slots_fh - occupied_fh;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* check_fh_sig_slots() */
+
+
+/*
+* If we are padding the From-Host signals to the SDIO block size,
+* we need to round up the needed_chunks to the SDIO block size.
+*/
+#define ROUND_UP_NEEDED_CHUNKS(_card, _needed_chunks) \
+    { \
+        CsrUint16 _chunks_per_block; \
+        CsrUint16 _chunks_in_last_block; \
+ \
+        if (_card->sdio_io_block_pad) \
+        { \
+            _chunks_per_block = _card->sdio_io_block_size / _card->config_data.sig_frag_size; \
+            _chunks_in_last_block = _needed_chunks % _chunks_per_block; \
+            if (_chunks_in_last_block != 0) \
+            { \
+                _needed_chunks = _needed_chunks + (_chunks_per_block - _chunks_in_last_block); \
+            } \
+        } \
+    }
+
+
+#define ROUND_UP_SPACE_CHUNKS(_card, _space_chunks) \
+    { \
+        CsrUint16 _chunks_per_block; \
+ \
+        if (_card->sdio_io_block_pad) \
+        { \
+            _chunks_per_block = _card->sdio_io_block_size / _card->config_data.sig_frag_size; \
+            _space_chunks = ((_space_chunks / _chunks_per_block) * _chunks_per_block); \
+        } \
+    }
+
+
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  process_fh_cmd_queue
+ *
+ *      Take one signal off the from-host queue and copy it to the UniFi.
+ *      Does nothing if the UniFi has no slots free.
+ *
+ *  Arguments:
+ *      card       Pointer to card context struct
+ *      processed  Location to write:
+ *                      0 if there is nothing on the queue to process
+ *                      1 if a signal was successfully processed
+ *
+ *  Returns:
+ *      CSR error code if an error occurred.
+ *
+ *  Notes:
+ *      The from-host queue contains signal requests from the network driver
+ *      and any UDI clients interspersed. UDI clients' requests have been stored
+ *      in the from-host queue using the wire-format structures, as they arrive.
+ *      All other requests are stored in the from-host queue using the host
+ *      (cpu specific) structures. We use the is_packed member of the card_signal_t
+ *      structure that describes the queue to make the distiction.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult process_fh_cmd_queue(card_t *card, CsrInt32 *processed)
+{
+    q_t *sigq = &card->fh_command_queue;
+
+    CsrResult r;
+    CsrUint16 pending_sigs;
+    CsrUint16 pending_chunks;
+    CsrUint16 needed_chunks;
+    CsrInt32 space_chunks;
+    CsrUint16 q_index;
+
+    *processed = 0;
+
+    /* Get the number of pending signals. */
+    pending_sigs = CSR_WIFI_HIP_Q_SLOTS_USED(sigq);
+    unifi_trace(card->ospriv, UDBG5, "proc_fh: %d pending\n", pending_sigs);
+    if (pending_sigs == 0)
+    {
+        /* Nothing to do */
+        return CSR_RESULT_SUCCESS;
+    }
+
+    /* Work out how many chunks we have waiting to send */
+    for (pending_chunks = 0, q_index = CSR_WIFI_HIP_Q_NEXT_R_SLOT(sigq);
+         q_index != CSR_WIFI_HIP_Q_NEXT_W_SLOT(sigq);
+         q_index = CSR_WIFI_HIP_Q_WRAP(sigq, q_index + 1))
+    {
+        card_signal_t *csptr = CSR_WIFI_HIP_Q_SLOT_DATA(sigq, q_index);
+
+        /*
+         * Note that GET_CHUNKS_FOR() needs the size of the packed
+         * (wire-formatted) structure
+         */
+        pending_chunks += GET_CHUNKS_FOR(card->config_data.sig_frag_size, (CsrUint16)(csptr->signal_length + 2));
+    }
+
+    /*
+     * Check whether UniFi has space for all the buffered bulk-data
+     * commands and signals as well.
+     */
+    needed_chunks = pending_chunks + card->fh_buffer.count;
+
+    /* Round up to the block size if necessary */
+    ROUND_UP_NEEDED_CHUNKS(card, needed_chunks);
+
+    r = check_fh_sig_slots(card, needed_chunks, &space_chunks);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        /* Error */
+        unifi_error(card->ospriv, "Failed to read fh sig count\n");
+        return r;
+    }
+
+#ifdef CSR_WIFI_HIP_NOISY
+    unifi_error(card->ospriv, "proc_fh: %d chunks free, need %d\n",
+                space_chunks, needed_chunks);
+#endif /* CSR_WIFI_HIP_NOISY */
+
+
+    /*
+     * Coalesce as many from-host signals as possible
+     * into a single block and write using a single CMD53
+     */
+    if (needed_chunks > (CsrUint16)space_chunks)
+    {
+        /* Round up to the block size if necessary */
+        ROUND_UP_SPACE_CHUNKS(card, space_chunks);
+
+        /*
+         * If the f/w has less free chunks than those already pending
+         * return immediately.
+         */
+        if ((CsrUint16)space_chunks <= card->fh_buffer.count)
+        {
+            /*
+             * No room in UniFi for any signals after the buffered bulk
+             * data commands have been sent.
+             */
+            unifi_error(card->ospriv, "not enough room to send signals, need %d chunks, %d free\n",
+                        card->fh_buffer.count, space_chunks);
+            card->generate_interrupt = 1;
+            return CSR_RESULT_SUCCESS;
+        }
+        pending_chunks = (CsrUint16)(space_chunks - card->fh_buffer.count);
+    }
+
+    while (pending_sigs-- && pending_chunks > 0)
+    {
+        card_signal_t *csptr;
+        CsrInt16 i;
+        CsrUint16 sig_chunks, total_length, free_chunks_in_fh_buffer;
+        bulk_data_param_t bulkdata;
+        CsrUint8 *packed_sigptr;
+        CsrUint16 signal_length = 0;
+
+        /* Retrieve the entry at the head of the queue */
+        q_index = CSR_WIFI_HIP_Q_NEXT_R_SLOT(sigq);
+
+        /* Get a pointer to the containing card_signal_t struct */
+        csptr = CSR_WIFI_HIP_Q_SLOT_DATA(sigq, q_index);
+
+        /* Get the new length of the packed signal */
+        signal_length = csptr->signal_length;
+
+        if ((signal_length & 1) || (signal_length > UNIFI_PACKED_SIGBUF_SIZE))
+        {
+            unifi_error(card->ospriv, "process_fh_queue: Bad len: %d\n", signal_length);
+            return CSR_RESULT_FAILURE;
+        }
+
+        /* Need space for 2-byte SDIO protocol header + signal */
+        sig_chunks = GET_CHUNKS_FOR(card->config_data.sig_frag_size, (CsrUint16)(signal_length + 2));
+
+        free_chunks_in_fh_buffer = GET_CHUNKS_FOR(card->config_data.sig_frag_size,
+                                                  (CsrUint16)((card->fh_buffer.buf + UNIFI_FH_BUF_SIZE) - card->fh_buffer.ptr));
+        if (free_chunks_in_fh_buffer < sig_chunks)
+        {
+            /* No more room */
+            unifi_notice(card->ospriv, "proc_fh_cmd_q: no room in fh buffer for 0x%.4X, deferring\n",
+                         (CsrUint16)(GET_SIGNAL_ID(csptr->sigbuf)));
+            break;
+        }
+
+        packed_sigptr = csptr->sigbuf;
+
+        /* Claim and set up a from-host data slot */
+        if (CSR_RESULT_FAILURE == CardWriteBulkData(card, csptr, UNIFI_TRAFFIC_Q_MLME))
+        {
+            unifi_notice(card->ospriv, "proc_fh_cmd_q: no fh data slots for 0x%.4X, deferring\n",
+                         (CsrUint16)(GET_SIGNAL_ID(csptr->sigbuf)));
+            break;
+        }
+
+        for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)
+        {
+            if (csptr->bulkdata[i].data_length == 0)
+            {
+                UNIFI_INIT_BULK_DATA(&bulkdata.d[i]);
+            }
+            else
+            {
+                bulkdata.d[i].os_data_ptr = csptr->bulkdata[i].os_data_ptr;
+                bulkdata.d[i].data_length = csptr->bulkdata[i].data_length;
+            }
+
+            /* Pass the free responsibility to the lower layer. */
+            UNIFI_INIT_BULK_DATA(&csptr->bulkdata[i]);
+        }
+
+        unifi_trace(card->ospriv, UDBG2, "Sending signal 0x%.4X\n",
+                    GET_SIGNAL_ID(packed_sigptr));
+#ifdef CSR_WIFI_HIP_NOISY
+        unifi_error(card->ospriv, "Sending signal 0x%.4X\n",
+                    GET_SIGNAL_ID(packed_sigptr));
+#endif  /* CSR_WIFI_HIP_NOISY */
+
+
+        /* Append packed signal to F-H buffer */
+        total_length = sig_chunks * card->config_data.sig_frag_size;
+
+        card->fh_buffer.ptr[0] = (CsrUint8)(signal_length & 0xff);
+        card->fh_buffer.ptr[1] =
+            (CsrUint8)(((signal_length >> 8) & 0xf) | (SDIO_CMD_SIGNAL << 4));
+
+        CsrMemCpy(card->fh_buffer.ptr + 2, packed_sigptr, signal_length);
+        CsrMemSet(card->fh_buffer.ptr + 2 + signal_length, 0,
+                  total_length - (2 + signal_length));
+
+#ifdef CSR_WIFI_HIP_NOISY
+        unifi_error(card->ospriv, "proc_fh: fh_buffer %d bytes \n",
+                    signal_length + 2);
+        dump(card->fh_buffer.ptr, signal_length + 2);
+        unifi_trace(card->ospriv, UDBG1, " \n");
+#endif  /* CSR_WIFI_HIP_NOISY */
+
+        card->fh_buffer.ptr += total_length;
+        card->fh_buffer.count += sig_chunks;
+
+#ifdef CSR_WIFI_HIP_NOISY
+        unifi_error(card->ospriv, "Added %d to fh buf, len now %d, count %d\n",
+                    signal_length,
+                    card->fh_buffer.ptr - card->fh_buffer.buf,
+                    card->fh_buffer.count);
+#endif  /* CSR_WIFI_HIP_NOISY */
+
+        (*processed)++;
+        pending_chunks -= sig_chunks;
+
+        /* Log the signal to the UDI. */
+        /* UDI will get the packed structure */
+        /* Can not log the unpacked signal, unless we reconstruct it! */
+        if (card->udi_hook)
+        {
+            (*card->udi_hook)(card->ospriv, packed_sigptr, signal_length,
+                              &bulkdata, UDI_LOG_FROM_HOST);
+        }
+
+        /* Remove entry from q */
+        csptr->signal_length = 0;
+        CSR_WIFI_HIP_Q_INC_R(sigq);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* process_fh_cmd_queue() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  process_fh_traffic_queue
+ *
+ *      Take signals off the from-host queue and copy them to the UniFi.
+ *      Does nothing if the UniFi has no slots free.
+ *
+ *  Arguments:
+ *      card       Pointer to card context struct
+ *      sigq       Pointer to the traffic queue
+ *      processed  Pointer to location to write:
+ *                      0 if there is nothing on the queue to process
+ *                      1 if a signal was successfully processed
+ *
+ *  Returns:
+ *      CSR error code if an error occurred.
+ *
+ *  Notes:
+ *      The from-host queue contains signal requests from the network driver
+ *      and any UDI clients interspersed.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult process_fh_traffic_queue(card_t *card, CsrInt32 *processed)
+{
+    q_t *sigq = card->fh_traffic_queue;
+
+    CsrResult r;
+    CsrInt16 n = 0;
+    CsrInt32 q_no;
+    CsrUint16 pending_sigs = 0;
+    CsrUint16 pending_chunks = 0;
+    CsrUint16 needed_chunks;
+    CsrInt32 space_chunks;
+    CsrUint16 q_index;
+    CsrUint32 host_tag = 0;
+    CsrUint16 slot_num = 0;
+
+    *processed = 0;
+
+    /* calculate how many signals are in queues and how many chunks are needed. */
+    for (n = UNIFI_NO_OF_TX_QS - 1; n >= 0; n--)
+    {
+        /* Get the number of pending signals. */
+        pending_sigs += CSR_WIFI_HIP_Q_SLOTS_USED(&sigq[n]);
+        unifi_trace(card->ospriv, UDBG5, "proc_fh%d: %d pending\n", n, pending_sigs);
+
+        /* Work out how many chunks we have waiting to send */
+        for (q_index = CSR_WIFI_HIP_Q_NEXT_R_SLOT(&sigq[n]);
+             q_index != CSR_WIFI_HIP_Q_NEXT_W_SLOT(&sigq[n]);
+             q_index = CSR_WIFI_HIP_Q_WRAP(&sigq[n], q_index + 1))
+        {
+            card_signal_t *csptr = CSR_WIFI_HIP_Q_SLOT_DATA(&sigq[n], q_index);
+
+            /*
+             * Note that GET_CHUNKS_FOR() needs the size of the packed
+             * (wire-formatted) structure
+             */
+            pending_chunks += GET_CHUNKS_FOR(card->config_data.sig_frag_size, (CsrUint16)(csptr->signal_length + 2));
+        }
+    }
+
+    /* If there are no pending signals, just return */
+    if (pending_sigs == 0)
+    {
+        /* Nothing to do */
+        return CSR_RESULT_SUCCESS;
+    }
+
+    /*
+     * Check whether UniFi has space for all the buffered bulk-data
+     * commands and signals as well.
+     */
+    needed_chunks = pending_chunks + card->fh_buffer.count;
+
+    /* Round up to the block size if necessary */
+    ROUND_UP_NEEDED_CHUNKS(card, needed_chunks);
+
+    r = check_fh_sig_slots(card, needed_chunks, &space_chunks);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        /* Error */
+        unifi_error(card->ospriv, "Failed to read fh sig count\n");
+        return r;
+    }
+
+#ifdef CSR_WIFI_HIP_NOISY
+    unifi_error(card->ospriv,
+                "process_fh_traffic_queue: %d chunks free, need %d\n",
+                space_chunks, needed_chunks);
+    read_fhsr(card);            /* debugging only */
+#endif /* CSR_WIFI_HIP_NOISY */
+
+    /* Coalesce as many from-host signals as possible
+       into a single block and write using a single CMD53 */
+    if (needed_chunks > (CsrUint16)space_chunks)
+    {
+        /* Round up to the block size if necessary */
+        ROUND_UP_SPACE_CHUNKS(card, space_chunks);
+
+        if ((CsrUint16)space_chunks <= card->fh_buffer.count)
+        {
+            /*
+             * No room in UniFi for any signals after the buffered bulk
+             * data commands have been sent.
+             */
+            unifi_error(card->ospriv, "not enough room to send signals, need %d chunks, %d free\n",
+                        card->fh_buffer.count, space_chunks);
+            card->generate_interrupt = 1;
+            return 0;
+        }
+
+        pending_chunks = (CsrUint16)space_chunks - card->fh_buffer.count;
+    }
+
+    q_no = UNIFI_NO_OF_TX_QS - 1;
+
+    /*
+     * pending_sigs will be exhausted if there are is no restriction to the pending
+     * signals per queue. pending_chunks may be exhausted if there is a restriction.
+     * q_no check will be exhausted if there is a restriction and our round-robin
+     * algorith fails to fill all chunks.
+     */
+    do
+    {
+        card_signal_t *csptr;
+        CsrUint16 sig_chunks, total_length, free_chunks_in_fh_buffer;
+        bulk_data_param_t bulkdata;
+        CsrUint8 *packed_sigptr;
+        CsrUint16 signal_length = 0;
+
+        /* if this queue is empty go to next one. */
+        if (CSR_WIFI_HIP_Q_SLOTS_USED(&sigq[q_no]) == 0)
+        {
+            q_no--;
+            continue;
+        }
+
+        /* Retrieve the entry at the head of the queue */
+        q_index = CSR_WIFI_HIP_Q_NEXT_R_SLOT(&sigq[q_no]);
+
+        /* Get a pointer to the containing card_signal_t struct */
+        csptr = CSR_WIFI_HIP_Q_SLOT_DATA(&sigq[q_no], q_index);
+
+        /* Get the new length of the packed signal */
+        signal_length = csptr->signal_length;
+
+        if ((signal_length & 1) || (signal_length > UNIFI_PACKED_SIGBUF_SIZE))
+        {
+            unifi_error(card->ospriv, "process_fh_traffic_queue: Bad len: %d\n", signal_length);
+            return CSR_RESULT_FAILURE;
+        }
+
+        /* Need space for 2-byte SDIO protocol header + signal */
+        sig_chunks = GET_CHUNKS_FOR(card->config_data.sig_frag_size, (CsrUint16)(signal_length + 2));
+        free_chunks_in_fh_buffer = GET_CHUNKS_FOR(card->config_data.sig_frag_size,
+                                                  (CsrUint16)((card->fh_buffer.buf + UNIFI_FH_BUF_SIZE) - card->fh_buffer.ptr));
+        if (free_chunks_in_fh_buffer < sig_chunks)
+        {
+            /* No more room */
+            unifi_notice(card->ospriv, "process_fh_traffic_queue: no more chunks.\n");
+            break;
+        }
+
+        packed_sigptr = csptr->sigbuf;
+        /* Claim and set up a from-host data slot */
+        if (CSR_RESULT_FAILURE == CardWriteBulkData(card, csptr, (unifi_TrafficQueue)q_no))
+        {
+            q_no--;
+            continue;
+        }
+
+        /* Sanity check: MA-PACKET.req must have a valid bulk data */
+        if ((csptr->bulkdata[0].data_length == 0) || (csptr->bulkdata[0].os_data_ptr == NULL))
+        {
+            unifi_error(card->ospriv, "MA-PACKET.req with empty bulk data (%d bytes in %p)\n",
+                        csptr->bulkdata[0].data_length, csptr->bulkdata[0].os_data_ptr);
+            dump(packed_sigptr, signal_length);
+            return CSR_RESULT_FAILURE;
+        }
+
+        bulkdata.d[0].os_data_ptr = csptr->bulkdata[0].os_data_ptr;
+        bulkdata.d[0].data_length = csptr->bulkdata[0].data_length;
+        bulkdata.d[0].os_net_buf_ptr = csptr->bulkdata[0].os_net_buf_ptr;
+        bulkdata.d[0].net_buf_length = csptr->bulkdata[0].net_buf_length;
+
+        /* The driver owns clearing of HIP slots for following scenario
+         * - driver has requested a MA-PACKET.req signal
+         * - The f/w after receiving the signal decides it can't send it out due to various reasons
+         * - So the f/w without downloading the bulk data decides to just send a confirmation with fail
+         * - and then sends a clear slot signal to HIP
+         *
+         * But in some cases the clear slot signal never comes and the slot remains --NOT-- freed for ever
+         *
+         * To handle this, HIP will keep the record of host tag for each occupied slot
+         * and then based on status of that Host tag and slot the driver will decide if the slot is
+         * cleared by f/w signal or the slot has to be freed by driver
+         */
+
+        if (card->fh_slot_host_tag_record)
+        {
+            /* Update the f-h slot record for the corresponding host tag */
+            host_tag = GET_PACKED_MA_PACKET_REQUEST_HOST_TAG(packed_sigptr);
+            slot_num = GET_PACKED_DATAREF_SLOT(packed_sigptr, 0) & 0x00FF;
+
+            unifi_trace(card->ospriv, UDBG5,
+                        "process_fh_traffic_queue signal ID =%x fh slot=%x Host tag =%x\n",
+                        GET_SIGNAL_ID(packed_sigptr), slot_num, host_tag);
+            card->fh_slot_host_tag_record[slot_num] = host_tag;
+        }
+        UNIFI_INIT_BULK_DATA(&bulkdata.d[1]);
+        UNIFI_INIT_BULK_DATA(&csptr->bulkdata[0]);
+        UNIFI_INIT_BULK_DATA(&csptr->bulkdata[1]);
+
+#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE
+        if (bulkdata.d[0].os_data_ptr)
+        {
+            if ((*bulkdata.d[0].os_data_ptr) & 0x08)
+            {
+                card->cmd_prof.tx_count++;
+            }
+        }
+#endif
+        unifi_trace(card->ospriv, UDBG3, "Sending signal 0x%.4X\n",
+                    GET_SIGNAL_ID(packed_sigptr));
+#ifdef CSR_WIFI_HIP_NOISY
+        unifi_error(card->ospriv, "Sending signal 0x%.4X\n",
+                    GET_SIGNAL_ID(packed_sigptr));
+#endif  /* CSR_WIFI_HIP_NOISY */
+
+        /* Append packed signal to F-H buffer */
+        total_length = sig_chunks * card->config_data.sig_frag_size;
+
+        card->fh_buffer.ptr[0] = (CsrUint8)(signal_length & 0xff);
+        card->fh_buffer.ptr[1] =
+            (CsrUint8)(((signal_length >> 8) & 0xf) | (SDIO_CMD_SIGNAL << 4));
+
+        CsrMemCpy(card->fh_buffer.ptr + 2, packed_sigptr, signal_length);
+        CsrMemSet(card->fh_buffer.ptr + 2 + signal_length, 0,
+                  total_length - (2 + signal_length));
+
+#ifdef CSR_WIFI_HIP_NOISY
+        unifi_error(card->ospriv, "proc_fh: fh_buffer %d bytes \n",
+                    signal_length + 2);
+        dump(card->fh_buffer.ptr, signal_length + 2);
+        unifi_trace(card->ospriv, UDBG1, " \n");
+#endif  /* CSR_WIFI_HIP_NOISY */
+
+        card->fh_buffer.ptr += total_length;
+        card->fh_buffer.count += sig_chunks;
+
+#ifdef CSR_WIFI_HIP_NOISY
+        unifi_error(card->ospriv, "Added %d to fh buf, len now %d, count %d\n",
+                    signal_length,
+                    card->fh_buffer.ptr - card->fh_buffer.buf,
+                    card->fh_buffer.count);
+#endif  /* CSR_WIFI_HIP_NOISY */
+
+        (*processed)++;
+        pending_sigs--;
+        pending_chunks -= sig_chunks;
+
+        /* Log the signal to the UDI. */
+        /* UDI will get the packed structure */
+        /* Can not log the unpacked signal, unless we reconstruct it! */
+        if (card->udi_hook)
+        {
+            (*card->udi_hook)(card->ospriv, packed_sigptr, signal_length,
+                              &bulkdata, UDI_LOG_FROM_HOST);
+        }
+
+        /* Remove entry from q */
+        csptr->signal_length = 0;
+        /* Note that the traffic queue has only one valid bulk data buffer. */
+        csptr->bulkdata[0].data_length = 0;
+
+        CSR_WIFI_HIP_Q_INC_R(&sigq[q_no]);
+    } while ((pending_sigs > 0) && (pending_chunks > 0) && (q_no >= 0));
+
+    return CSR_RESULT_SUCCESS;
+} /* process_fh_traffic_queue() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  flush_fh_buffer
+ *
+ *      Write out the cache from-hosts signals to the UniFi.
+ *
+ *  Arguments:
+ *      card       Pointer to card context struct
+ *
+ *  Returns:
+ *      CSR error code if an SDIO error occurred.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult flush_fh_buffer(card_t *card)
+{
+    CsrResult r;
+    CsrUint16 len;
+    CsrUint16 sig_units;
+    CsrUint16 data_round;
+    CsrUint16 chunks_in_last_block;
+    CsrUint16 padding_chunks;
+    CsrUint16 i;
+
+    len = card->fh_buffer.ptr - card->fh_buffer.buf;
+
+#ifdef CSR_WIFI_HIP_NOISY
+    unifi_error(card->ospriv, "fh_buffer is at %p, ptr= %p\n",
+                card->fh_buffer.buf, card->fh_buffer.ptr);
+#endif /* CSR_WIFI_HIP_NOISY */
+
+    if (len == 0)
+    {
+        return CSR_RESULT_SUCCESS;
+    }
+
+#ifdef CSR_WIFI_HIP_NOISY
+    if (dump_fh_buf)
+    {
+        dump(card->fh_buffer.buf, len);
+        dump_fh_buf = 0;
+    }
+#endif /* CSR_WIFI_HIP_NOISY */
+
+    if (card->sdio_io_block_pad)
+    {
+        /* Both of these are powers of 2 */
+        sig_units = card->config_data.sig_frag_size;
+        data_round = card->sdio_io_block_size;
+
+        if (data_round > sig_units)
+        {
+            chunks_in_last_block = (len % data_round) / sig_units;
+
+            if (chunks_in_last_block != 0)
+            {
+                padding_chunks = (data_round / sig_units) - chunks_in_last_block;
+
+                CsrMemSet(card->fh_buffer.ptr, 0, padding_chunks * sig_units);
+                for (i = 0; i < padding_chunks; i++)
+                {
+                    card->fh_buffer.ptr[1] = SDIO_CMD_PADDING << 4;
+                    card->fh_buffer.ptr += sig_units;
+                }
+
+                card->fh_buffer.count += padding_chunks;
+                len += padding_chunks * sig_units;
+            }
+        }
+    }
+
+    r = unifi_bulk_rw(card,
+                      card->config_data.fromhost_sigbuf_handle,
+                      card->fh_buffer.buf,
+                      len, UNIFI_SDIO_WRITE);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to write fh signals: %u bytes, error %d\n", len, r);
+        return r;
+    }
+
+    /* Update from-host-signals-written signal count */
+    card->from_host_signals_w =
+        (card->from_host_signals_w + card->fh_buffer.count) % 128u;
+    r = unifi_write_8_or_16(card, card->sdio_ctrl_addr + 0,
+                            (CsrUint8)card->from_host_signals_w);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to write fh signal count %u with error %d\n",
+                    card->from_host_signals_w, r);
+        return r;
+    }
+    card->generate_interrupt = 1;
+
+    /* Reset the fh buffer pointer */
+    card->fh_buffer.ptr = card->fh_buffer.buf;
+    card->fh_buffer.count = 0;
+
+#ifdef CSR_WIFI_HIP_NOISY
+    unifi_error(card->ospriv, "END flush: fh len %d, count %d\n",
+                card->fh_buffer.ptr - card->fh_buffer.buf,
+                card->fh_buffer.count);
+#endif /* CSR_WIFI_HIP_NOISY */
+
+    return CSR_RESULT_SUCCESS;
+} /* flush_fh_buffer() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  restart_packet_flow
+ *
+ *      This function is called before the bottom-half thread sleeps.
+ *      It checks whether both data and signal resources are available and
+ *      then calls the OS-layer function to re-enable packet transmission.
+ *
+ *  Arguments:
+ *      card       Pointer to card context struct
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void restart_packet_flow(card_t *card)
+{
+    CsrUint8 q;
+
+    /*
+     * We only look at the fh_traffic_queue, because that is where packets from
+     * the network stack are placed.
+     */
+    for (q = 0; q <= UNIFI_TRAFFIC_Q_VO; q++)
+    {
+        if (card_is_tx_q_paused(card, q) &&
+            CSR_WIFI_HIP_Q_SLOTS_FREE(&card->fh_traffic_queue[q]) >= RESUME_XMIT_THRESHOLD)
+        {
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+            unifi_debug_log_to_buf("U");
+#endif
+            card_tx_q_unpause(card, q);
+            unifi_restart_xmit(card->ospriv, (unifi_TrafficQueue)q);
+        }
+    }
+} /* restart_packet_flow() */
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_card_sdio_mem.c
@@ -0,0 +1,1713 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ * FILE: csr_wifi_hip_card_sdio_mem.c
+ *
+ * PURPOSE: Implementation of the Card API for SDIO.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_card.h"
+
+#define SDIO_RETRIES    3
+#define CSR_WIFI_HIP_SDIO_TRACE_DATA_LENGTH 16
+
+
+#define retryable_sdio_error(_csrResult) (((_csrResult) == CSR_SDIO_RESULT_CRC_ERROR) || ((_csrResult) == CSR_SDIO_RESULT_TIMEOUT))
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  retrying_read8
+ *  retrying_write8
+ *
+ *      These functions provide the first level of retry for SDIO operations.
+ *      If an SDIO command fails for reason of a response timeout or CRC
+ *      error, it is retried immediately. If three attempts fail we report a
+ *      failure.
+ *      If the command failed for any other reason, the failure is reported
+ *      immediately.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      funcnum         The SDIO function to access.
+ *                      Function 0 is the Card Configuration Register space,
+ *                      function 1/2 is the UniFi register space.
+ *      addr            Address to access
+ *      pdata           Pointer in which to return the value read.
+ *      data            Value to write.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS  on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult retrying_read8(card_t *card, CsrInt16 funcnum, CsrUint32 addr, CsrUint8 *pdata)
+{
+    CsrSdioFunction *sdio = card->sdio_if;
+    CsrResult r = CSR_RESULT_SUCCESS;
+    CsrInt16 retries;
+    CsrResult csrResult = CSR_RESULT_SUCCESS;
+
+    retries = 0;
+    while (retries++ < SDIO_RETRIES)
+    {
+        if (funcnum == 0)
+        {
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+            unifi_debug_log_to_buf("r0@%02X", addr);
+#endif
+            csrResult = CsrSdioF0Read8(sdio, addr, pdata);
+        }
+        else
+        {
+#ifdef CSR_WIFI_TRANSPORT_CSPI
+            unifi_error(card->ospriv,
+                        "retrying_read_f0_8: F1 8-bit reads are not allowed.\n");
+            return CSR_RESULT_FAILURE;
+#else
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+            unifi_debug_log_to_buf("r@%02X", addr);
+#endif
+            csrResult = CsrSdioRead8(sdio, addr, pdata);
+#endif
+        }
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        if (csrResult != CSR_RESULT_SUCCESS)
+        {
+            unifi_debug_log_to_buf("error=%X\n", csrResult);
+        }
+        else
+        {
+            unifi_debug_log_to_buf("=%X\n", *pdata);
+        }
+#endif
+        if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+        {
+            return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+        }
+        /*
+         * Try again for retryable (CRC or TIMEOUT) errors,
+         * break on success or fatal error
+         */
+        if (!retryable_sdio_error(csrResult))
+        {
+#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE
+            card->cmd_prof.cmd52_count++;
+#endif
+            break;
+        }
+        unifi_trace(card->ospriv, UDBG2, "retryable SDIO error reading F%d 0x%lX\n", funcnum, addr);
+    }
+
+    if ((csrResult == CSR_RESULT_SUCCESS) && (retries > 1))
+    {
+        unifi_warning(card->ospriv, "Read succeeded after %d attempts\n", retries);
+    }
+
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to read from UniFi (addr 0x%lX) after %d tries\n",
+                    addr, retries - 1);
+        /* Report any SDIO error as a general i/o error */
+        r = CSR_RESULT_FAILURE;
+    }
+
+    return r;
+} /* retrying_read8() */
+
+
+static CsrResult retrying_write8(card_t *card, CsrInt16 funcnum, CsrUint32 addr, CsrUint8 data)
+{
+    CsrSdioFunction *sdio = card->sdio_if;
+    CsrResult r = CSR_RESULT_SUCCESS;
+    CsrInt16 retries;
+    CsrResult csrResult = CSR_RESULT_SUCCESS;
+
+    retries = 0;
+    while (retries++ < SDIO_RETRIES)
+    {
+        if (funcnum == 0)
+        {
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+            unifi_debug_log_to_buf("w0@%02X=%X", addr, data);
+#endif
+            csrResult = CsrSdioF0Write8(sdio, addr, data);
+        }
+        else
+        {
+#ifdef CSR_WIFI_TRANSPORT_CSPI
+            unifi_error(card->ospriv,
+                        "retrying_write_f0_8: F1 8-bit writes are not allowed.\n");
+            return CSR_RESULT_FAILURE;
+#else
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+            unifi_debug_log_to_buf("w@%02X=%X", addr, data);
+#endif
+            csrResult = CsrSdioWrite8(sdio, addr, data);
+#endif
+        }
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        if (csrResult != CSR_RESULT_SUCCESS)
+        {
+            unifi_debug_log_to_buf(",error=%X", csrResult);
+        }
+        unifi_debug_string_to_buf("\n");
+#endif
+        if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+        {
+            return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+        }
+        /*
+         * Try again for retryable (CRC or TIMEOUT) errors,
+         * break on success or fatal error
+         */
+        if (!retryable_sdio_error(csrResult))
+        {
+#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE
+            card->cmd_prof.cmd52_count++;
+#endif
+            break;
+        }
+        unifi_trace(card->ospriv, UDBG2, "retryable SDIO error writing %02X to F%d 0x%lX\n",
+                    data, funcnum, addr);
+    }
+
+    if ((csrResult == CSR_RESULT_SUCCESS) && (retries > 1))
+    {
+        unifi_warning(card->ospriv, "Write succeeded after %d attempts\n", retries);
+    }
+
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to write to UniFi (addr 0x%lX) after %d tries\n",
+                    addr, retries - 1);
+        /* Report any SDIO error as a general i/o error */
+        r = CSR_RESULT_FAILURE;
+    }
+
+    return r;
+} /* retrying_write8() */
+
+
+static CsrResult retrying_read16(card_t *card, CsrInt16 funcnum,
+                                 CsrUint32 addr, CsrUint16 *pdata)
+{
+    CsrSdioFunction *sdio = card->sdio_if;
+    CsrResult r = CSR_RESULT_SUCCESS;
+    CsrInt16 retries;
+    CsrResult csrResult = CSR_RESULT_SUCCESS;
+
+    retries = 0;
+    while (retries++ < SDIO_RETRIES)
+    {
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        unifi_debug_log_to_buf("r@%02X", addr);
+#endif
+        csrResult = CsrSdioRead16(sdio, addr, pdata);
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        if (csrResult != CSR_RESULT_SUCCESS)
+        {
+            unifi_debug_log_to_buf("error=%X\n", csrResult);
+        }
+        else
+        {
+            unifi_debug_log_to_buf("=%X\n", *pdata);
+        }
+#endif
+        if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+        {
+            return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+        }
+
+        /*
+         * Try again for retryable (CRC or TIMEOUT) errors,
+         * break on success or fatal error
+         */
+        if (!retryable_sdio_error(csrResult))
+        {
+#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE
+            card->cmd_prof.cmd52_count++;
+#endif
+            break;
+        }
+        unifi_trace(card->ospriv, UDBG2, "retryable SDIO error reading F%d 0x%lX\n", funcnum, addr);
+    }
+
+    if ((csrResult == CSR_RESULT_SUCCESS) && (retries > 1))
+    {
+        unifi_warning(card->ospriv, "Read succeeded after %d attempts\n", retries);
+    }
+
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to read from UniFi (addr 0x%lX) after %d tries\n",
+                    addr, retries - 1);
+        /* Report any SDIO error as a general i/o error */
+        r = CSR_RESULT_FAILURE;
+    }
+
+    return r;
+} /* retrying_read16() */
+
+
+static CsrResult retrying_write16(card_t *card, CsrInt16 funcnum,
+                                  CsrUint32 addr, CsrUint16 data)
+{
+    CsrSdioFunction *sdio = card->sdio_if;
+    CsrResult r = CSR_RESULT_SUCCESS;
+    CsrInt16 retries;
+    CsrResult csrResult = CSR_RESULT_SUCCESS;
+
+    retries = 0;
+    while (retries++ < SDIO_RETRIES)
+    {
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        unifi_debug_log_to_buf("w@%02X=%X", addr, data);
+#endif
+        csrResult = CsrSdioWrite16(sdio, addr, data);
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        if (csrResult != CSR_RESULT_SUCCESS)
+        {
+            unifi_debug_log_to_buf(",error=%X", csrResult);
+        }
+        unifi_debug_string_to_buf("\n");
+#endif
+        if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+        {
+            return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+        }
+
+        /*
+         * Try again for retryable (CRC or TIMEOUT) errors,
+         * break on success or fatal error
+         */
+        if (!retryable_sdio_error(csrResult))
+        {
+#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE
+            card->cmd_prof.cmd52_count++;
+#endif
+            break;
+        }
+        unifi_trace(card->ospriv, UDBG2, "retryable SDIO error writing %02X to F%d 0x%lX\n",
+                    data, funcnum, addr);
+    }
+
+    if ((csrResult == CSR_RESULT_SUCCESS) && (retries > 1))
+    {
+        unifi_warning(card->ospriv, "Write succeeded after %d attempts\n", retries);
+    }
+
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to write to UniFi (addr 0x%lX) after %d tries\n",
+                    addr, retries - 1);
+        /* Report any SDIO error as a general i/o error */
+        r = CSR_RESULT_FAILURE;
+    }
+
+    return r;
+} /* retrying_write16() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  sdio_read_f0
+ *
+ *      Reads a byte value from the CCCR (func 0) area of UniFi.
+ *
+ *  Arguments:
+ *      card    Pointer to card structure.
+ *      addr    Address to read from
+ *      pdata   Pointer in which to store the read value.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ * ---------------------------------------------------------------------------
+ */
+CsrResult sdio_read_f0(card_t *card, CsrUint32 addr, CsrUint8 *pdata)
+{
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+    card->cmd_prof.cmd52_f0_r_count++;
+#endif
+    return retrying_read8(card, 0, addr, pdata);
+} /* sdio_read_f0() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  sdio_write_f0
+ *
+ *      Writes a byte value to the CCCR (func 0) area of UniFi.
+ *
+ *  Arguments:
+ *      card    Pointer to card structure.
+ *      addr    Address to read from
+ *      data    Data value to write.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ * ---------------------------------------------------------------------------
+ */
+CsrResult sdio_write_f0(card_t *card, CsrUint32 addr, CsrUint8 data)
+{
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+    card->cmd_prof.cmd52_f0_w_count++;
+#endif
+    return retrying_write8(card, 0, addr, data);
+} /* sdio_write_f0() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * unifi_read_direct_8_or_16
+ *
+ *      Read a 8-bit value from the UniFi SDIO interface.
+ *
+ *  Arguments:
+ *      card    Pointer to card structure.
+ *      addr    Address to read from
+ *      pdata   Pointer in which to return data.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_read_direct_8_or_16(card_t *card, CsrUint32 addr, CsrUint8 *pdata)
+{
+#ifdef CSR_WIFI_TRANSPORT_CSPI
+    CsrUint16 w;
+    CsrResult r;
+
+    r = retrying_read16(card, card->function, addr, &w);
+    *pdata = (CsrUint8)(w & 0xFF);
+    return r;
+#else
+    return retrying_read8(card, card->function, addr, pdata);
+#endif
+} /* unifi_read_direct_8_or_16() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_write_direct_8_or_16
+ *
+ *      Write a byte value to the UniFi SDIO interface.
+ *
+ *  Arguments:
+ *      card    Pointer to card structure.
+ *      addr    Address to write to
+ *      data    Value to write.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error
+ *
+ *  Notes:
+ *      If 8-bit write is used, the even address *must* be written second.
+ *      This is because writes to odd bytes are cached and not committed
+ *      to memory until the preceding even address is written.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_write_direct_8_or_16(card_t *card, CsrUint32 addr, CsrUint8 data)
+{
+    if (addr & 1)
+    {
+        unifi_warning(card->ospriv,
+                      "Warning: Byte write to an odd address (0x%lX) is dangerous\n",
+                      addr);
+    }
+
+#ifdef CSR_WIFI_TRANSPORT_CSPI
+    return retrying_write16(card, card->function, addr, (CsrUint16)data);
+#else
+    return retrying_write8(card, card->function, addr, data);
+#endif
+} /* unifi_write_direct_8_or_16() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_read_direct16
+ *
+ *      Read a 16-bit value from the UniFi SDIO interface.
+ *
+ *  Arguments:
+ *      card    Pointer to card structure.
+ *      addr    Address to read from
+ *      pdata   Pointer in which to return data.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *
+ *  Notes:
+ *      The even address *must* be read first. This is because reads from
+ *      odd bytes are cached and read from memory when the preceding
+ *      even address is read.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_read_direct16(card_t *card, CsrUint32 addr, CsrUint16 *pdata)
+{
+    return retrying_read16(card, card->function, addr, pdata);
+} /* unifi_read_direct16() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_write_direct16
+ *
+ *      Write a 16-bit value to the UniFi SDIO interface.
+ *
+ *  Arguments:
+ *      card    Pointer to card structure.
+ *      addr    Address to write to
+ *      data    Value to write.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *
+ *  Notes:
+ *      The even address *must* be written second. This is because writes to
+ *      odd bytes are cached and not committed to memory until the preceding
+ *      even address is written.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_write_direct16(card_t *card, CsrUint32 addr, CsrUint16 data)
+{
+    return retrying_write16(card, card->function, addr, data);
+} /* unifi_write_direct16() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_read_direct32
+ *
+ *      Read a 32-bit value from the UniFi SDIO interface.
+ *
+ *  Arguments:
+ *      card    Pointer to card structure.
+ *      addr    Address to read from
+ *      pdata   Pointer in which to return data.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_read_direct32(card_t *card, CsrUint32 addr, CsrUint32 *pdata)
+{
+    CsrResult r;
+    CsrUint16 w0, w1;
+
+    r = retrying_read16(card, card->function, addr, &w0);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+    r = retrying_read16(card, card->function, addr + 2, &w1);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+    *pdata = ((CsrUint32)w1 << 16) | (CsrUint32)w0;
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_read_direct32() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_read_directn_match
+ *
+ *      Read multiple 8-bit values from the UniFi SDIO interface,
+ *      stopping when either we have read 'len' bytes or we have read
+ *      a octet equal to 'match'.  If 'match' is not a valid octet
+ *      then this function is the same as 'unifi_read_directn'.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      addr            Start address to read from.
+ *      pdata           Pointer to which to write data.
+ *      len             Maximum umber of bytes to read
+ *      match           The value to stop reading at.
+ *      num             Pointer to buffer to write number of bytes read
+ *
+ *  Returns:
+ *      number of octets read on success, negative error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *
+ *  Notes:
+ *      The even address *must* be read first. This is because reads from
+ *      odd bytes are cached and read from memory when the preceding
+ *      even address is read.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult unifi_read_directn_match(card_t *card, CsrUint32 addr, void *pdata, CsrUint16 len, CsrInt8 m, CsrUint32 *num)
+{
+    CsrResult r;
+    CsrUint32 i;
+    CsrUint8 *cptr;
+    CsrUint16 w;
+
+    *num = 0;
+
+    cptr = (CsrUint8 *)pdata;
+    for (i = 0; i < len; i += 2)
+    {
+        r = retrying_read16(card, card->function, addr, &w);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            return r;
+        }
+
+        *cptr++ = ((CsrUint8)w & 0xFF);
+        if ((m >= 0) && (((CsrInt8)w & 0xFF) == m))
+        {
+            break;
+        }
+
+        if (i + 1 == len)
+        {
+            /* The len is odd. Ignore the last high byte */
+            break;
+        }
+
+        *cptr++ = ((CsrUint8)(w >> 8) & 0xFF);
+        if ((m >= 0) && (((CsrInt8)(w >> 8) & 0xFF) == m))
+        {
+            break;
+        }
+
+        addr += 2;
+    }
+
+    *num = (CsrInt32)(cptr - (CsrUint8 *)pdata);
+    return CSR_RESULT_SUCCESS;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_read_directn
+ *
+ *      Read multiple 8-bit values from the UniFi SDIO interface.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      addr            Start address to read from.
+ *      pdata           Pointer to which to write data.
+ *      len             Number of bytes to read
+ *
+ *  Returns:
+ *      0 on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *
+ *  Notes:
+ *      The even address *must* be read first. This is because reads from
+ *      odd bytes are cached and read from memory when the preceding
+ *      even address is read.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_read_directn(card_t *card, CsrUint32 addr, void *pdata, CsrUint16 len)
+{
+    CsrUint32 num;
+
+    return unifi_read_directn_match(card, addr, pdata, len, -1, &num);
+} /* unifi_read_directn() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_write_directn
+ *
+ *      Write multiple 8-bit values to the UniFi SDIO interface.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      addr            Start address to write to.
+ *      pdata           Source data pointer.
+ *      len             Number of bytes to write, must be even.
+ *
+ *  Returns:
+ *      0 on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *
+ *  Notes:
+ *      The UniFi has a peculiar 16-bit bus architecture. Writes are only
+ *      committed to memory when an even address is accessed. Writes to
+ *      odd addresses are cached and only committed if the next write is
+ *      to the preceding address.
+ *      This means we must write data as pairs of bytes in reverse order.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_write_directn(card_t *card, CsrUint32 addr, void *pdata, CsrUint16 len)
+{
+    CsrResult r;
+    CsrUint8 *cptr;
+    CsrInt16 signed_len;
+
+    cptr = (CsrUint8 *)pdata;
+    signed_len = (CsrInt16)len;
+    while (signed_len > 0)
+    {
+        /* This is UniFi-1 specific code. CSPI not supported so 8-bit write allowed */
+        r = retrying_write16(card, card->function, addr, *cptr);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            return r;
+        }
+
+        cptr += 2;
+        addr += 2;
+        signed_len -= 2;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_write_directn() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  set_dmem_page
+ *  set_pmem_page
+ *
+ *      Set up the page register for the shared data memory window or program
+ *      memory window.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      dmem_addr       UniFi shared-data-memory address to access.
+ *      pmem_addr       UniFi program memory address to access. This includes
+ *                        External FLASH memory at    0x000000
+ *                        Processor program memory at 0x200000
+ *                        External SRAM at memory     0x400000
+ *      paddr           Location to write an SDIO address (24-bit) for
+ *                       use in a unifi_read_direct or unifi_write_direct call.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE card was ejected
+ *      CSR_RESULT_FAILURE an SDIO error occurred
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult set_dmem_page(card_t *card, CsrUint32 dmem_addr, CsrUint32 *paddr)
+{
+    CsrUint16 page, addr;
+    CsrUint32 len;
+    CsrResult r;
+
+    *paddr = 0;
+
+    if (!ChipHelper_DecodeWindow(card->helper,
+                                 CHIP_HELPER_WINDOW_3,
+                                 CHIP_HELPER_WT_SHARED,
+                                 dmem_addr / 2,
+                                 &page, &addr, &len))
+    {
+        unifi_error(card->ospriv, "Failed to decode SHARED_DMEM_PAGE %08lx\n", dmem_addr);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    if (page != card->dmem_page)
+    {
+        unifi_trace(card->ospriv, UDBG6, "setting dmem page=0x%X, addr=0x%lX\n", page, addr);
+
+        /* change page register */
+        r = unifi_write_direct16(card, ChipHelper_HOST_WINDOW3_PAGE(card->helper) * 2, page);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to write SHARED_DMEM_PAGE\n");
+            return r;
+        }
+
+        card->dmem_page = page;
+    }
+
+    *paddr = ((CsrInt32)addr * 2) + (dmem_addr & 1);
+
+    return CSR_RESULT_SUCCESS;
+} /* set_dmem_page() */
+
+
+static CsrResult set_pmem_page(card_t *card, CsrUint32 pmem_addr,
+                               enum chip_helper_window_type mem_type, CsrUint32 *paddr)
+{
+    CsrUint16 page, addr;
+    CsrUint32 len;
+    CsrResult r;
+
+    *paddr = 0;
+
+    if (!ChipHelper_DecodeWindow(card->helper,
+                                 CHIP_HELPER_WINDOW_2,
+                                 mem_type,
+                                 pmem_addr / 2,
+                                 &page, &addr, &len))
+    {
+        unifi_error(card->ospriv, "Failed to decode PROG MEM PAGE %08lx %d\n", pmem_addr, mem_type);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    if (page != card->pmem_page)
+    {
+        unifi_trace(card->ospriv, UDBG6, "setting pmem page=0x%X, addr=0x%lX\n", page, addr);
+
+        /* change page register */
+        r = unifi_write_direct16(card, ChipHelper_HOST_WINDOW2_PAGE(card->helper) * 2, page);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to write PROG MEM PAGE\n");
+            return r;
+        }
+
+        card->pmem_page = page;
+    }
+
+    *paddr = ((CsrInt32)addr * 2) + (pmem_addr & 1);
+
+    return CSR_RESULT_SUCCESS;
+} /* set_pmem_page() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  set_page
+ *
+ *      Sets up the appropriate page register to access the given address.
+ *      Returns the sdio address at which the unifi address can be accessed.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      generic_addr    UniFi internal address to access, in Generic Pointer
+ *                      format, i.e. top byte is space indicator.
+ *      paddr           Location to write page address
+ *                          SDIO address (24-bit) for use in a unifi_read_direct or
+ *                          unifi_write_direct call
+ *
+ *  Returns:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE  the address is invalid
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult set_page(card_t *card, CsrUint32 generic_addr, CsrUint32 *paddr)
+{
+    CsrInt32 space;
+    CsrUint32 addr;
+    CsrResult r = CSR_RESULT_SUCCESS;
+
+    if (!paddr)
+    {
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+    *paddr = 0;
+    space = UNIFI_GP_SPACE(generic_addr);
+    addr = UNIFI_GP_OFFSET(generic_addr);
+    switch (space)
+    {
+        case UNIFI_SH_DMEM:
+            /* Shared Data Memory is accessed via the Shared Data Memory window */
+            r = set_dmem_page(card, addr, paddr);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            break;
+
+        case UNIFI_EXT_FLASH:
+            if (!ChipHelper_HasFlash(card->helper))
+            {
+                unifi_error(card->ospriv, "Bad address space for chip in generic pointer 0x%08lX (helper=0x%x)\n",
+                            generic_addr, card->helper);
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+            /* External FLASH is accessed via the Program Memory window */
+            r = set_pmem_page(card, addr, CHIP_HELPER_WT_FLASH, paddr);
+            break;
+
+        case UNIFI_EXT_SRAM:
+            if (!ChipHelper_HasExtSram(card->helper))
+            {
+                unifi_error(card->ospriv, "Bad address space for chip in generic pointer 0x%08l (helper=0x%x)\n",
+                            generic_addr, card->helper);
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+            /* External SRAM is accessed via the Program Memory window */
+            r = set_pmem_page(card, addr, CHIP_HELPER_WT_EXT_SRAM, paddr);
+            break;
+
+        case UNIFI_REGISTERS:
+            /* Registers are accessed directly */
+            *paddr = addr;
+            break;
+
+        case UNIFI_PHY_DMEM:
+            r = unifi_set_proc_select(card, UNIFI_PROC_PHY);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            *paddr = ChipHelper_DATA_MEMORY_RAM_OFFSET(card->helper) * 2 + addr;
+            break;
+
+        case UNIFI_MAC_DMEM:
+            r = unifi_set_proc_select(card, UNIFI_PROC_MAC);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            *paddr = ChipHelper_DATA_MEMORY_RAM_OFFSET(card->helper) * 2 + addr;
+            break;
+
+        case UNIFI_BT_DMEM:
+            if (!ChipHelper_HasBt(card->helper))
+            {
+                unifi_error(card->ospriv, "Bad address space for chip in generic pointer 0x%08lX (helper=0x%x)\n",
+                            generic_addr, card->helper);
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+            r = unifi_set_proc_select(card, UNIFI_PROC_BT);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            *paddr = ChipHelper_DATA_MEMORY_RAM_OFFSET(card->helper) * 2 + addr;
+            break;
+
+        case UNIFI_PHY_PMEM:
+            r = unifi_set_proc_select(card, UNIFI_PROC_PHY);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            r = set_pmem_page(card, addr, CHIP_HELPER_WT_CODE_RAM, paddr);
+            break;
+
+        case UNIFI_MAC_PMEM:
+            r = unifi_set_proc_select(card, UNIFI_PROC_MAC);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            r = set_pmem_page(card, addr, CHIP_HELPER_WT_CODE_RAM, paddr);
+            break;
+
+        case UNIFI_BT_PMEM:
+            if (!ChipHelper_HasBt(card->helper))
+            {
+                unifi_error(card->ospriv, "Bad address space for chip in generic pointer 0x%08lX (helper=0x%x)\n",
+                            generic_addr, card->helper);
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+            r = unifi_set_proc_select(card, UNIFI_PROC_BT);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            r = set_pmem_page(card, addr, CHIP_HELPER_WT_CODE_RAM, paddr);
+            break;
+
+        case UNIFI_PHY_ROM:
+            if (!ChipHelper_HasRom(card->helper))
+            {
+                unifi_error(card->ospriv, "Bad address space for chip in generic pointer 0x%08lX (helper=0x%x)\n",
+                            generic_addr, card->helper);
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+            r = unifi_set_proc_select(card, UNIFI_PROC_PHY);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            r = set_pmem_page(card, addr, CHIP_HELPER_WT_ROM, paddr);
+            break;
+
+        case UNIFI_MAC_ROM:
+            if (!ChipHelper_HasRom(card->helper))
+            {
+                unifi_error(card->ospriv, "Bad address space for chip in generic pointer 0x%08lX (helper=0x%x)\n",
+                            generic_addr, card->helper);
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+            r = unifi_set_proc_select(card, UNIFI_PROC_MAC);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            r = set_pmem_page(card, addr, CHIP_HELPER_WT_ROM, paddr);
+            break;
+
+        case UNIFI_BT_ROM:
+            if (!ChipHelper_HasRom(card->helper) || !ChipHelper_HasBt(card->helper))
+            {
+                unifi_error(card->ospriv, "Bad address space for chip in generic pointer 0x%08lX (helper=0x%x)\n",
+                            generic_addr, card->helper);
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+            r = unifi_set_proc_select(card, UNIFI_PROC_BT);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                return r;
+            }
+            r = set_pmem_page(card, addr, CHIP_HELPER_WT_ROM, paddr);
+            break;
+
+        default:
+            unifi_error(card->ospriv, "Bad address space %d in generic pointer 0x%08lX (helper=0x%x)\n",
+                        space, generic_addr, card->helper);
+            return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    return r;
+} /* set_page() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_set_proc_select
+ *
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      select          Which XAP core to select
+ *
+ *  Returns:
+ *      0 on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_set_proc_select(card_t *card, enum unifi_dbg_processors_select select)
+{
+    CsrResult r;
+
+    /* Verify the the select value is allowed. */
+    switch (select)
+    {
+        case UNIFI_PROC_MAC:
+        case UNIFI_PROC_PHY:
+        case UNIFI_PROC_BOTH:
+            break;
+
+
+        default:
+            return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    if (card->proc_select != (CsrUint32)select)
+    {
+        r = unifi_write_direct16(card,
+                                 ChipHelper_DBG_HOST_PROC_SELECT(card->helper) * 2,
+                                 (CsrUint8)select);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to write to Proc Select register\n");
+            return r;
+        }
+
+        card->proc_select = (CsrUint32)select;
+    }
+
+    return CSR_RESULT_SUCCESS;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * unifi_read_8_or_16
+ *
+ * Performs a byte read of the given address in shared data memory.
+ * Set up the shared data memory page register as required.
+ *
+ * Arguments:
+ * card Pointer to card structure.
+ * unifi_addr UniFi shared-data-memory address to access.
+ * pdata Pointer to a byte variable for the value read.
+ *
+ * Returns:
+ * CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ * CSR_WIFI_HIP_RESULT_NO_DEVICE card was ejected
+ * CSR_RESULT_FAILURE an SDIO error occurred
+ * CSR_WIFI_HIP_RESULT_INVALID_VALUE a bad generic pointer was specified
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_read_8_or_16(card_t *card, CsrUint32 unifi_addr, CsrUint8 *pdata)
+{
+    CsrUint32 sdio_addr;
+    CsrResult r;
+#ifdef CSR_WIFI_TRANSPORT_CSPI
+    CsrUint16 w;
+#endif
+
+    r = set_page(card, unifi_addr, &sdio_addr);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+    card->cmd_prof.cmd52_r8or16_count++;
+#endif
+#ifdef CSR_WIFI_TRANSPORT_CSPI
+    r = retrying_read16(card, card->function, sdio_addr, &w);
+    *pdata = (CsrUint8)(w & 0xFF);
+    return r;
+#else
+    return retrying_read8(card, card->function, sdio_addr, pdata);
+#endif
+} /* unifi_read_8_or_16() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * unifi_write_8_or_16
+ *
+ * Performs a byte write of the given address in shared data memory.
+ * Set up the shared data memory page register as required.
+ *
+ * Arguments:
+ * card Pointer to card context struct.
+ * unifi_addr UniFi shared-data-memory address to access.
+ * data Value to write.
+ *
+ * Returns:
+ * CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ * CSR_WIFI_HIP_RESULT_NO_DEVICE card was ejected
+ * CSR_RESULT_FAILURE an SDIO error occurred
+ * CSR_WIFI_HIP_RESULT_INVALID_VALUE a bad generic pointer was specified
+ *
+ * Notes:
+ * Beware using unifi_write8() because byte writes are not safe on UniFi.
+ * Writes to odd bytes are cached, writes to even bytes perform a 16-bit
+ * write with the previously cached odd byte.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_write_8_or_16(card_t *card, CsrUint32 unifi_addr, CsrUint8 data)
+{
+    CsrUint32 sdio_addr;
+    CsrResult r;
+#ifdef CSR_WIFI_TRANSPORT_CSPI
+    CsrUint16 w;
+#endif
+
+    r = set_page(card, unifi_addr, &sdio_addr);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+    if (sdio_addr & 1)
+    {
+        unifi_warning(card->ospriv,
+                      "Warning: Byte write to an odd address (0x%lX) is dangerous\n",
+                      sdio_addr);
+    }
+
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+    card->cmd_prof.cmd52_w8or16_count++;
+#endif
+#ifdef CSR_WIFI_TRANSPORT_CSPI
+    w = data;
+    return retrying_write16(card, card->function, sdio_addr, w);
+#else
+    return retrying_write8(card, card->function, sdio_addr, data);
+#endif
+} /* unifi_write_8_or_16() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_card_read16
+ *
+ *      Performs a 16-bit read of the given address in shared data memory.
+ *      Set up the shared data memory page register as required.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      unifi_addr      UniFi shared-data-memory address to access.
+ *      pdata           Pointer to a 16-bit int variable for the value read.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE  a bad generic pointer was specified
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_card_read16(card_t *card, CsrUint32 unifi_addr, CsrUint16 *pdata)
+{
+    CsrUint32 sdio_addr;
+    CsrResult r;
+
+    r = set_page(card, unifi_addr, &sdio_addr);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+    card->cmd_prof.cmd52_r16_count++;
+#endif
+    return unifi_read_direct16(card, sdio_addr, pdata);
+} /* unifi_card_read16() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_card_write16
+ *
+ *      Performs a 16-bit write of the given address in shared data memory.
+ *      Set up the shared data memory page register as required.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      unifi_addr      UniFi shared-data-memory address to access.
+ *      pdata           Pointer to a byte variable for the value write.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE  a bad generic pointer was specified
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_card_write16(card_t *card, CsrUint32 unifi_addr, CsrUint16 data)
+{
+    CsrUint32 sdio_addr;
+    CsrResult r;
+
+    r = set_page(card, unifi_addr, &sdio_addr);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+    card->cmd_prof.cmd52_w16_count++;
+#endif
+    return unifi_write_direct16(card, sdio_addr, data);
+} /* unifi_card_write16() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_read32
+ *
+ *      Performs a 32-bit read of the given address in shared data memory.
+ *      Set up the shared data memory page register as required.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      unifi_addr      UniFi shared-data-memory address to access.
+ *      pdata           Pointer to a int variable for the value read.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE  a bad generic pointer was specified
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_read32(card_t *card, CsrUint32 unifi_addr, CsrUint32 *pdata)
+{
+    CsrUint32 sdio_addr;
+    CsrResult r;
+
+    r = set_page(card, unifi_addr, &sdio_addr);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+    card->cmd_prof.cmd52_r32_count++;
+#endif
+    return unifi_read_direct32(card, sdio_addr, pdata);
+} /* unifi_read32() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_card_readn
+ *  unifi_readnz
+ *
+ *      Read multiple 8-bit values from the UniFi SDIO interface.
+ *      This function interprets the address as a GenericPointer as
+ *      defined in the UniFi Host Interface Protocol Specification.
+ *      The readnz version of this function will stop when it reads a
+ *      zero octet.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      unifi_addr      UniFi shared-data-memory address to access.
+ *      pdata           Pointer to which to write data.
+ *      len             Number of bytes to read
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE  a bad generic pointer was specified
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_readn_match(card_t *card, CsrUint32 unifi_addr, void *pdata, CsrUint16 len, CsrInt8 match)
+{
+    CsrUint32 sdio_addr;
+    CsrResult r;
+    CsrUint32 num;
+
+    r = set_page(card, unifi_addr, &sdio_addr);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+    r = unifi_read_directn_match(card, sdio_addr, pdata, len, match, &num);
+    return r;
+} /* unifi_readn_match() */
+
+
+CsrResult unifi_card_readn(card_t *card, CsrUint32 unifi_addr, void *pdata, CsrUint16 len)
+{
+    return unifi_readn_match(card, unifi_addr, pdata, len, -1);
+} /* unifi_card_readn() */
+
+
+CsrResult unifi_readnz(card_t *card, CsrUint32 unifi_addr, void *pdata, CsrUint16 len)
+{
+    return unifi_readn_match(card, unifi_addr, pdata, len, 0);
+} /* unifi_readnz() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_read_shared_count
+ *
+ *      Read signal count locations, checking for an SDIO error.  The
+ *      signal count locations only contain a valid number if the
+ *      highest bit isn't set.
+ *
+ *  Arguments:
+ *      card            Pointer to card context structure.
+ *      addr            Shared-memory address to read.
+ *
+ *  Returns:
+ *      Value read from memory (0-127) or -1 on error
+ * ---------------------------------------------------------------------------
+ */
+CsrInt32 unifi_read_shared_count(card_t *card, CsrUint32 addr)
+{
+    CsrUint8 b;
+    /* I've increased this count, because I have seen cases where
+     * there were three reads in a row with the top bit set.  I'm not
+     * sure why this might have happened, but I can't see a problem
+     * with increasing this limit.  It's better to take a while to
+     * recover than to fail. */
+#define SHARED_READ_RETRY_LIMIT 10
+    CsrInt32 i;
+
+    /*
+     * Get the to-host-signals-written count.
+     * The top-bit will be set if the firmware was in the process of
+     * changing the value, in which case we read again.
+     */
+    /* Limit the number of repeats so we don't freeze */
+    for (i = 0; i < SHARED_READ_RETRY_LIMIT; i++)
+    {
+        CsrResult r;
+        r = unifi_read_8_or_16(card, addr, &b);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            return -1;
+        }
+        if (!(b & 0x80))
+        {
+            /* There is a chance that the MSB may have contained invalid data
+             * (overflow) at the time it was read. Therefore mask off the MSB.
+             * This avoids a race between driver read and firmware write of the
+             * word, the value we need is in the lower 8 bits anway.
+             */
+            return (CsrInt32)(b & 0xff);
+        }
+    }
+
+    return -1;                  /* this function has changed in WMM mods */
+} /* unifi_read_shared_count() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_writen
+ *
+ *      Write multiple 8-bit values to the UniFi SDIO interface using CMD52
+ *      This function interprets the address as a GenericPointer as
+ *      defined in the UniFi Host Interface Protocol Specification.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      unifi_addr      UniFi shared-data-memory address to access.
+ *      pdata           Pointer to which to write data.
+ *      len             Number of bytes to write
+ *
+ *  Returns:
+ *      0 on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE    an odd length or length too big.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_writen(card_t *card, CsrUint32 unifi_addr, void *pdata, CsrUint16 len)
+{
+    CsrUint32 sdio_addr;
+    CsrResult r;
+
+    r = set_page(card, unifi_addr, &sdio_addr);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+    return unifi_write_directn(card, sdio_addr, pdata, len);
+} /* unifi_writen() */
+
+
+static CsrResult csr_sdio_block_rw(card_t *card, CsrInt16 funcnum,
+                                   CsrUint32 addr, CsrUint8 *pdata,
+                                   CsrUint16 count, CsrInt16 dir_is_write)
+{
+    CsrResult csrResult;
+
+    if (dir_is_write == UNIFI_SDIO_READ)
+    {
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        unifi_debug_log_to_buf("r@%02X#%X=", addr, count);
+#endif
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+        unifi_debug_log_to_buf("R");
+#endif
+        csrResult = CsrSdioRead(card->sdio_if, addr, pdata, count);
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+        unifi_debug_log_to_buf("<");
+#endif
+    }
+    else
+    {
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+        unifi_debug_log_to_buf("w@%02X#%X=", addr, count);
+        unifi_debug_hex_to_buf(pdata, count > CSR_WIFI_HIP_SDIO_TRACE_DATA_LENGTH?CSR_WIFI_HIP_SDIO_TRACE_DATA_LENGTH : count);
+#endif
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+        unifi_debug_log_to_buf("W");
+#endif
+        csrResult = CsrSdioWrite(card->sdio_if, addr, pdata, count);
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+        unifi_debug_log_to_buf(">");
+#endif
+    }
+#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE
+    card->cmd_prof.cmd53_count++;
+#endif
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        unifi_debug_log_to_buf("error=%X", csrResult);
+    }
+    else if (dir_is_write == UNIFI_SDIO_READ)
+    {
+        unifi_debug_hex_to_buf(pdata, count > CSR_WIFI_HIP_SDIO_TRACE_DATA_LENGTH?CSR_WIFI_HIP_SDIO_TRACE_DATA_LENGTH : count);
+    }
+    unifi_debug_string_to_buf("\n");
+#endif
+    return csrResult;  /* CSR SDIO (not HIP) error code */
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_bulk_rw
+ *
+ *      Transfer bulk data to or from the UniFi SDIO interface.
+ *      This function is used to read or write signals and bulk data.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      handle          Value to put in the Register Address field of the CMD53 req.
+ *      data            Pointer to data to write.
+ *      direction       One of UNIFI_SDIO_READ or UNIFI_SDIO_WRITE
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *
+ *  Notes:
+ *      This function uses SDIO CMD53, which is the block transfer mode.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_bulk_rw(card_t *card, CsrUint32 handle, void *pdata,
+                        CsrUint32 len, CsrInt16 direction)
+{
+#define CMD53_RETRIES 3
+    /*
+     * Ideally instead of sleeping, we want to busy wait.
+     * Currently there is no framework API to do this. When it becomes available,
+     * we can use it to busy wait using usecs
+     */
+#define REWIND_RETRIES          15    /* when REWIND_DELAY==1msec, or 250 when REWIND_DELAY==50usecs */
+#define REWIND_POLLING_RETRIES  5
+#define REWIND_DELAY            1     /* msec or 50usecs */
+    CsrResult csrResult;              /* SDIO error code */
+    CsrResult r = CSR_RESULT_SUCCESS; /* HIP error code */
+    CsrInt16 retries = CMD53_RETRIES;
+    CsrInt16 stat_retries;
+    CsrUint8 stat;
+    CsrInt16 dump_read;
+#ifdef UNIFI_DEBUG
+    CsrUint8 *pdata_lsb = ((CsrUint8 *)&pdata) + card->lsb;
+#endif
+#ifdef CSR_WIFI_MAKE_FAKE_CMD53_ERRORS
+    static CsrInt16 fake_error;
+#endif
+
+    dump_read = 0;
+#ifdef UNIFI_DEBUG
+    if (*pdata_lsb & 1)
+    {
+        unifi_notice(card->ospriv, "CD53 request on a unaligned buffer (addr: 0x%X) dir %s-Host\n",
+                     pdata, (direction == UNIFI_SDIO_READ)?"To" : "From");
+        if (direction == UNIFI_SDIO_WRITE)
+        {
+            dump(pdata, (CsrUint16)len);
+        }
+        else
+        {
+            dump_read = 1;
+        }
+    }
+#endif
+
+    /* Defensive checks */
+    if (!pdata)
+    {
+        unifi_error(card->ospriv, "Null pdata for unifi_bulk_rw() len: %d\n", len);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+    if ((len & 1) || (len > 0xffff))
+    {
+        unifi_error(card->ospriv, "Impossible CMD53 length requested: %d\n", len);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    while (1)
+    {
+        csrResult = csr_sdio_block_rw(card, card->function, handle,
+                                      (CsrUint8 *)pdata, (CsrUint16)len,
+                                      direction);
+        if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)
+        {
+            return CSR_WIFI_HIP_RESULT_NO_DEVICE;
+        }
+#ifdef CSR_WIFI_MAKE_FAKE_CMD53_ERRORS
+        if (++fake_error > 100)
+        {
+            fake_error = 90;
+            unifi_warning(card->ospriv, "Faking a CMD53 error,\n");
+            if (csrResult == CSR_RESULT_SUCCESS)
+            {
+                csrResult = CSR_RESULT_FAILURE;
+            }
+        }
+#endif
+        if (csrResult == CSR_RESULT_SUCCESS)
+        {
+            if (dump_read)
+            {
+                dump(pdata, (CsrUint16)len);
+            }
+            break;
+        }
+
+        /*
+         * At this point the SDIO driver should have written the I/O Abort
+         * register to notify UniFi that the command has failed.
+         * UniFi-1 and UniFi-2 (not UF6xxx) use the same register to store the
+         * Deep Sleep State. This means we have to restore the Deep Sleep
+         * State (AWAKE in any case since we can not perform a CD53 in any other
+         * state) by rewriting the I/O Abort register to its previous value.
+         */
+        if (card->chip_id <= SDIO_CARD_ID_UNIFI_2)
+        {
+            unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
+        }
+
+        /* If csr_sdio_block_rw() failed in a non-retryable way, or retries exhausted
+         * then stop retrying
+         */
+        if (!retryable_sdio_error(csrResult))
+        {
+            unifi_error(card->ospriv, "Fatal error in a CMD53 transfer\n");
+            break;
+        }
+
+        /*
+         * These happen from time to time, try again
+         */
+        if (--retries == 0)
+        {
+            break;
+        }
+
+        unifi_trace(card->ospriv, UDBG4,
+                    "Error in a CMD53 transfer, retrying (h:%d,l:%u)...\n",
+                    (CsrInt16)handle & 0xff, len);
+
+        /* The transfer failed, rewind and try again */
+        r = unifi_write_8_or_16(card, card->sdio_ctrl_addr + 8,
+                                (CsrUint8)(handle & 0xff));
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            /*
+             * If we can't even do CMD52 (register read/write) then
+             * stop here.
+             */
+            unifi_error(card->ospriv, "Failed to write REWIND cmd\n");
+            return r;
+        }
+
+        /* Signal the UniFi to look for the rewind request. */
+        r = CardGenInt(card);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            return r;
+        }
+
+        /* Wait for UniFi to acknowledge the rewind */
+        stat_retries = REWIND_RETRIES;
+        while (1)
+        {
+            r = unifi_read_8_or_16(card, card->sdio_ctrl_addr + 8, &stat);
+            if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+            {
+                return r;
+            }
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                unifi_error(card->ospriv, "Failed to read REWIND status\n");
+                return CSR_RESULT_FAILURE;
+            }
+
+            if (stat == 0)
+            {
+                break;
+            }
+            if (--stat_retries == 0)
+            {
+                unifi_error(card->ospriv, "Timeout waiting for REWIND ready\n");
+                return CSR_RESULT_FAILURE;
+            }
+
+            /* Poll for the ack a few times */
+            if (stat_retries < REWIND_RETRIES - REWIND_POLLING_RETRIES)
+            {
+                CsrThreadSleep(REWIND_DELAY);
+            }
+        }
+    }
+
+    /* The call to csr_sdio_block_rw() still failed after retrying */
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Block %s failed after %d retries\n",
+                    (direction == UNIFI_SDIO_READ)?"read" : "write",
+                    CMD53_RETRIES - retries);
+        /* Report any SDIO error as a general i/o error */
+        return CSR_RESULT_FAILURE;
+    }
+
+    /* Collect some stats */
+    if (direction == UNIFI_SDIO_READ)
+    {
+        card->sdio_bytes_read += len;
+    }
+    else
+    {
+        card->sdio_bytes_written += len;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_bulk_rw() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_bulk_rw_noretry
+ *
+ *      Transfer bulk data to or from the UniFi SDIO interface.
+ *      This function is used to read or write signals and bulk data.
+ *
+ *  Arguments:
+ *      card            Pointer to card structure.
+ *      handle          Value to put in the Register Address field of
+ *                      the CMD53 req.
+ *      data            Pointer to data to write.
+ *      direction       One of UNIFI_SDIO_READ or UNIFI_SDIO_WRITE
+ *
+ *  Returns:
+ *      0 on success, non-zero error code on error:
+ *      CSR_WIFI_HIP_RESULT_NO_DEVICE  card was ejected
+ *      CSR_RESULT_FAILURE     an SDIO error occurred
+ *
+ *  Notes:
+ *      This function uses SDIO CMD53, which is the block transfer mode.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_bulk_rw_noretry(card_t *card, CsrUint32 handle, void *pdata,
+                                CsrUint32 len, CsrInt16 direction)
+{
+    CsrResult csrResult;
+
+    csrResult = csr_sdio_block_rw(card, card->function, handle,
+                                  (CsrUint8 *)pdata, (CsrUint16)len, direction);
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Block %s failed\n",
+                    (direction == UNIFI_SDIO_READ)?"read" : "write");
+        return csrResult;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_bulk_rw_noretry() */
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_chiphelper.c
@@ -0,0 +1,793 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+
+#include "csr_wifi_hip_chiphelper_private.h"
+
+#ifndef nelem
+#define nelem(a) (sizeof(a) / sizeof(a[0]))
+#endif
+
+#define counted(foo) { nelem(foo), foo }
+#define null_counted()  { 0, NULL }
+
+/* The init values are a set of register writes that we must
+   perform when we first connect to the chip to get it working.
+   They swicth on the correct clocks and possibly set the host
+   interface as a wkaeup source.  They should not be used if
+   proper HIP opperation is required, but are useful before we
+   do a code download. */
+static const struct chip_helper_init_values init_vals_v1[] = {
+    { 0xFDBB, 0xFFFF },
+    { 0xFDB6, 0x03FF },
+    { 0xFDB1, 0x01E3 },
+    { 0xFDB3, 0x0FFF },
+    { 0xFEE3, 0x08F0 },
+    { 0xFEE7, 0x3C3F },
+    { 0xFEE6, 0x0050 },
+    { 0xFDBA, 0x0000 }
+};
+
+static const struct chip_helper_init_values init_vals_v2[] = {
+    { 0xFDB6, 0x0FFF },
+    { 0xF023, 0x3F3F },
+    { 0xFDB1, 0x01E3 },
+    { 0xFDB3, 0x0FFF },
+    { 0xF003, 0x08F0 },
+    { 0xF007, 0x3C3F },
+    { 0xF006, 0x0050 }
+};
+
+
+static const struct chip_helper_init_values init_vals_v22_v23[] = {
+    { 0xF81C, 0x00FF },
+    /*{ 0x????, 0x???? }, */
+    { 0xF80C, 0x1FFF },
+    { 0xFA25, 0x001F },
+    { 0xF804, 0x00FF },
+    { 0xF802, 0x0FFF },
+    /*{ 0x????, 0x???? },
+      { 0x????, 0x???? },
+      { 0x????, 0x???? }*/
+};
+
+static const CsrUint16 reset_program_a_v1_or_v2[] = {
+    0x0000
+};
+static const CsrUint16 reset_program_b_v1_or_v2[] = {
+    0x0010, 0xFE00, 0xA021, 0xFF00, 0x8111, 0x0009, 0x0CA4, 0x0114,
+    0x0280, 0x04F8, 0xFE00, 0x6F25, 0x06E0, 0x0010, 0xFC00, 0x0121,
+    0xFC00, 0x0225, 0xFE00, 0x7125, 0xFE00, 0x6D11, 0x03F0, 0xFE00,
+    0x6E25, 0x0008, 0x00E0
+};
+
+static const struct chip_helper_reset_values reset_program_v1_or_v2[] =
+{
+    {
+        MAKE_GP(REGISTERS, 0x000C),
+        nelem(reset_program_a_v1_or_v2),
+        reset_program_a_v1_or_v2
+    },
+    {
+        MAKE_GP(MAC_PMEM, 0x000000),
+        nelem(reset_program_b_v1_or_v2),
+        reset_program_b_v1_or_v2
+    }
+};
+
+static const struct chip_map_address_t unifi_map_address_v1_v2[] =
+{
+    { 0xFE9F, 0xFE7B },     /* PM1_BANK_SELECT */
+    { 0xFE9E, 0xFE78 },     /* PM2_BANK_SELECT */
+    { 0xFE9D, 0xFE7E },     /* SHARED_DMEM_PAGE */
+    { 0xFE91, 0xFE90 },     /* PROC_SELECT */
+    { 0xFE8D, 0xFE8C },     /* STOP_STATUS */
+};
+
+static const struct chip_map_address_t unifi_map_address_v22_v23[] =
+{
+    { 0xF8F9, 0xF8AC },     /* GW1_CONFIG */
+    { 0xF8FA, 0xF8AD },     /* GW2_CONFIG */
+    { 0xF8FB, 0xF8AE },     /* GW3_CONFIG */
+    { 0xF830, 0xF81E },     /* PROC_SELECT */
+    { 0xF831, 0xF81F },     /* STOP_STATUS */
+    { 0xF8FC, 0xF8AF },     /* IO_LOG_ADDRESS */
+};
+
+static const struct chip_device_regs_t unifi_device_regs_null =
+{
+    0xFE81,                     /* GBL_CHIP_VERSION */
+    0x0000,                     /* GBL_MISC_ENABLES */
+    0x0000,                     /* DBG_EMU_CMD */
+    {
+        0x0000,                 /* HOST.DBG_PROC_SELECT */
+        0x0000,                 /* HOST.DBG_STOP_STATUS */
+        0x0000,                 /* HOST.WINDOW1_PAGE */
+        0x0000,                 /* HOST.WINDOW2_PAGE */
+        0x0000,                 /* HOST.WINDOW3_PAGE */
+        0x0000                  /* HOST.IO_LOG_ADDR */
+    },
+    {
+        0x0000,                 /* SPI.DBG_PROC_SELECT */
+        0x0000,                 /* SPI.DBG_STOP_STATUS */
+        0x0000,                 /* SPI.WINDOW1_PAGE */
+        0x0000,                 /* SPI.WINDOW2_PAGE */
+        0x0000,                 /* SPI.WINDOW3_PAGE */
+        0x0000                  /* SPI.IO_LOG_ADDR */
+    },
+    0x0000,                     /* DBG_RESET */
+    0x0000,                     /* > DBG_RESET_VALUE */
+    0x0000,                     /* DBG_RESET_WARN */
+    0x0000,                     /* DBG_RESET_WARN_VALUE */
+    0x0000,                     /* DBG_RESET_RESULT */
+    0xFFE9,                     /* XAP_PCH */
+    0xFFEA,                     /* XAP_PCL */
+    0x0000,                     /* PROC_PC_SNOOP */
+    0x0000,                     /* WATCHDOG_DISABLE */
+    0x0000,                     /* MAILBOX0 */
+    0x0000,                     /* MAILBOX1 */
+    0x0000,                     /* MAILBOX2 */
+    0x0000,                     /* MAILBOX3 */
+    0x0000,                     /* SDIO_HOST_INT */
+    0x0000,                     /* SHARED_IO_INTERRUPT */
+    0x0000,                     /* SDIO HIP HANDSHAKE */
+    0x0000                      /* COEX_STATUS */
+};
+
+/* UF105x */
+static const struct chip_device_regs_t unifi_device_regs_v1 =
+{
+    0xFE81,                     /* GBL_CHIP_VERSION */
+    0xFE87,                     /* GBL_MISC_ENABLES */
+    0xFE9C,                     /* DBG_EMU_CMD */
+    {
+        0xFE90,                 /* HOST.DBG_PROC_SELECT */
+        0xFE8C,                 /* HOST.DBG_STOP_STATUS */
+        0xFE7B,                 /* HOST.WINDOW1_PAGE */
+        0xFE78,                 /* HOST.WINDOW2_PAGE */
+        0xFE7E,                 /* HOST.WINDOW3_PAGE */
+        0x0000                  /* HOST.IO_LOG_ADDR */
+    },
+    {
+        0xFE91,                 /* SPI.DBG_PROC_SELECT */
+        0xFE8D,                 /* SPI.DBG_STOP_STATUS */
+        0xFE9F,                 /* SPI.WINDOW1_PAGE */
+        0xFE9E,                 /* SPI.WINDOW2_PAGE */
+        0xFE9D,                 /* SPI.WINDOW3_PAGE */
+        0x0000                  /* SPI.IO_LOG_ADDR */
+    },
+    0xFE92,                     /* DBG_RESET */
+    0x0001,                     /* > DBG_RESET_VALUE */
+    0xFDA0,                     /* DBG_RESET_WARN (HOST_SELECT) */
+    0x0000,                     /* DBG_RESET_WARN_VALUE */
+    0xFE92,                     /* DBG_RESET_RESULT */
+    0xFFE9,                     /* XAP_PCH */
+    0xFFEA,                     /* XAP_PCL */
+    0x0051,                     /* PROC_PC_SNOOP */
+    0xFE70,                     /* WATCHDOG_DISABLE */
+    0xFE6B,                     /* MAILBOX0 */
+    0xFE6A,                     /* MAILBOX1 */
+    0xFE69,                     /* MAILBOX2 */
+    0xFE68,                     /* MAILBOX3 */
+    0xFE67,                     /* SDIO_HOST_INT */
+    0xFE65,                     /* SHARED_IO_INTERRUPT */
+    0xFDE9,                     /* SDIO HIP HANDSHAKE */
+    0x0000                      /* COEX_STATUS */
+};
+
+/* UF2... */
+static const struct chip_device_regs_t unifi_device_regs_v2 =
+{
+    0xFE81,                     /* GBL_CHIP_VERSION */
+    0xFE87,                     /* GBL_MISC_ENABLES */
+    0xFE9C,                     /* DBG_EMU_CMD */
+    {
+        0xFE90,                 /* HOST.DBG_PROC_SELECT */
+        0xFE8C,                 /* HOST.DBG_STOP_STATUS */
+        0xFE7B,                 /* HOST.WINDOW1_PAGE */
+        0xFE78,                 /* HOST.WINDOW2_PAGE */
+        0xFE7E,                 /* HOST.WINDOW3_PAGE */
+        0x0000                  /* HOST.IO_LOG_ADDR */
+    },
+    {
+        0xFE91,                 /* SPI.DBG_PROC_SELECT */
+        0xFE8D,                 /* SPI.DBG_STOP_STATUS */
+        0xFE9F,                 /* SPI.WINDOW1_PAGE */
+        0xFE9E,                 /* SPI.WINDOW2_PAGE */
+        0xFE9D,                 /* SPI.WINDOW3_PAGE */
+        0x0000                  /* SPI.IO_LOG_ADDR */
+    },
+    0xFE92,                     /* DBG_RESET */
+    0x0000,                     /* > DBG_RESET_VALUE */
+    0xFDE9,                     /* DBG_RESET_WARN (TEST_FLASH_DATA - SHARED_MAILBOX2B) */
+    0xFFFF,                     /* DBG_RESET_WARN_VALUE */
+    0xFDE9,                     /* DBG_RESET_RESULT (TEST_FLASH_DATA) */
+    0xFFE9,                     /* XAP_PCH */
+    0xFFEA,                     /* XAP_PCL */
+    0x0051,                     /* PROC_PC_SNOOP */
+    0xFE70,                     /* WATCHDOG_DISABLE */
+    0xFE6B,                     /* MAILBOX0 */
+    0xFE6A,                     /* MAILBOX1 */
+    0xFE69,                     /* MAILBOX2 */
+    0xFE68,                     /* MAILBOX3 */
+    0xFE67,                     /* SDIO_HOST_INT */
+    0xFE65,                     /* SHARED_IO_INTERRUPT */
+    0xFE69,                     /* SDIO HIP HANDSHAKE */
+    0x0000                      /* COEX_STATUS */
+};
+
+/* UF60xx */
+static const struct chip_device_regs_t unifi_device_regs_v22_v23 =
+{
+    0xFE81,                     /* GBL_CHIP_VERSION */
+    0xF84F,                     /* GBL_MISC_ENABLES */
+    0xF81D,                     /* DBG_EMU_CMD */
+    {
+        0xF81E,                 /* HOST.DBG_PROC_SELECT */
+        0xF81F,                 /* HOST.DBG_STOP_STATUS */
+        0xF8AC,                 /* HOST.WINDOW1_PAGE */
+        0xF8AD,                 /* HOST.WINDOW2_PAGE */
+        0xF8AE,                 /* HOST.WINDOW3_PAGE */
+        0xF8AF                  /* HOST.IO_LOG_ADDR */
+    },
+    {
+        0xF830,                 /* SPI.DBG_PROC_SELECT */
+        0xF831,                 /* SPI.DBG_STOP_STATUS */
+        0xF8F9,                 /* SPI.WINDOW1_PAGE */
+        0xF8FA,                 /* SPI.WINDOW2_PAGE */
+        0xF8FB,                 /* SPI.WINDOW3_PAGE */
+        0xF8FC                  /* SPI.IO_LOG_ADDR */
+    },
+    0xF82F,                     /* DBG_RESET */
+    0x0001,                     /* > DBG_RESET_VALUE */
+    0x0000,                     /* DBG_RESET_WARN */
+    0x0000,                     /* DBG_RESET_WARN_VALUE */
+    0xF82F,                     /* DBG_RESET_RESULT */
+    0xFFE9,                     /* XAP_PCH */
+    0xFFEA,                     /* XAP_PCL */
+    0x001B,                     /* PROC_PC_SNOOP */
+    0x0055,                     /* WATCHDOG_DISABLE */
+    0xF84B,                     /* MAILBOX0 */
+    0xF84C,                     /* MAILBOX1 */
+    0xF84D,                     /* MAILBOX2 */
+    0xF84E,                     /* MAILBOX3 */
+    0xF92F,                     /* SDIO_HOST_INT */
+    0xF92B,                     /* SDIO_FROMHOST_SCRTACH0 / SHARED_IO_INTERRUPT */
+    0xF84D,                     /* SDIO HIP HANDSHAKE (MAILBOX2) */
+    0xF9FB                      /* COEX_STATUS */
+};
+
+/* Program memory window on UF105x. */
+static const struct window_shift_info_t prog_window_array_unifi_v1_v2[CHIP_HELPER_WT_COUNT] =
+{
+    { TRUE, 11, 0x0200 }, /* CODE RAM */
+    { TRUE, 11, 0x0000 }, /* FLASH */
+    { TRUE, 11, 0x0400 }, /* External SRAM */
+    { FALSE, 0, 0 },      /* ROM */
+    { FALSE, 0, 0 }       /* SHARED */
+};
+
+/* Shared memory window on UF105x. */
+static const struct window_shift_info_t shared_window_array_unifi_v1_v2[CHIP_HELPER_WT_COUNT] =
+{
+    { FALSE, 0, 0 },      /* CODE RAM */
+    { FALSE, 0, 0 },      /* FLASH */
+    { FALSE, 0, 0 },      /* External SRAM */
+    { FALSE, 0, 0 },      /* ROM */
+    { TRUE, 11, 0x0000 }  /* SHARED */
+};
+
+/* One of the Generic Windows on UF60xx and later. */
+static const struct window_shift_info_t generic_window_array_unifi_v22_v23[CHIP_HELPER_WT_COUNT] =
+{
+    { TRUE, 11, 0x3800 }, /* CODE RAM */
+    { FALSE, 0, 0 },      /* FLASH */
+    { FALSE, 0, 0 },      /* External SRAM */
+    { TRUE, 11, 0x2000 }, /* ROM */
+    { TRUE, 11, 0x0000 }  /* SHARED */
+};
+
+/* The three windows on UF105x. */
+static const struct window_info_t prog1_window_unifi_v1_v2  = { 0x0000, 0x2000, 0x0080, prog_window_array_unifi_v1_v2 };
+static const struct window_info_t prog2_window_unifi_v1_v2  = { 0x2000, 0x2000, 0x0000, prog_window_array_unifi_v1_v2 };
+static const struct window_info_t shared_window_unifi_v1_v2 = { 0x4000, 0x2000, 0x0000, shared_window_array_unifi_v1_v2 };
+
+/* The three windows on UF60xx and later. */
+static const struct window_info_t generic1_window_unifi_v22_v23 = { 0x0000, 0x2000, 0x0080, generic_window_array_unifi_v22_v23 };
+static const struct window_info_t generic2_window_unifi_v22_v23 = { 0x2000, 0x2000, 0x0000, generic_window_array_unifi_v22_v23 };
+static const struct window_info_t generic3_window_unifi_v22_v23 = { 0x4000, 0x2000, 0x0000, generic_window_array_unifi_v22_v23 };
+
+static const struct chip_device_desc_t chip_device_desc_null =
+{
+    { FALSE, 0x0000, 0x0000, 0x00 },
+    "",
+    "",
+    null_counted(),                         /* init */
+    null_counted(),                         /* reset_prog */
+    &unifi_device_regs_null,                /* regs */
+    {
+        FALSE,                              /* has_flash */
+        FALSE,                              /* has_ext_sram */
+        FALSE,                              /* has_rom */
+        FALSE,                              /* has_bt */
+        FALSE,                              /* has_wlan */
+    },
+    null_counted(),
+    /* prog_offset */
+    {
+        0x00000000,
+        0x00000000,
+        0x00000000,
+        0x00000000
+    },
+    /* data_offset */
+    {
+        0x0000                              /* ram */
+    },
+    /* windows */
+    {
+        NULL,
+        NULL,
+        NULL
+    }
+};
+
+static const struct chip_device_desc_t unifi_device_desc_v1 =
+{
+    { FALSE, 0xf0ff, 0x1001, 0x01 },        /* UF105x R01 */
+    "UF105x",
+    "UniFi-1",
+    counted(init_vals_v1),                  /* init */
+    counted(reset_program_v1_or_v2),        /* reset_prog */
+    &unifi_device_regs_v1,                  /* regs */
+    {
+        TRUE,                               /* has_flash    */
+        TRUE,                               /* has_ext_sram */
+        FALSE,                              /* has_rom      */
+        FALSE,                              /* has_bt       */
+        TRUE,                               /* has_wlan */
+    },
+    counted(unifi_map_address_v1_v2),       /* map */
+    /* prog_offset */
+    {
+        0x00100000,                         /* ram */
+        0x00000000,                         /* rom (invalid) */
+        0x00000000,                         /* flash */
+        0x00200000,                         /* ext_ram */
+    },
+    /* data_offset */
+    {
+        0x8000                              /* ram */
+    },
+    /* windows */
+    {
+        &prog1_window_unifi_v1_v2,
+        &prog2_window_unifi_v1_v2,
+        &shared_window_unifi_v1_v2
+    }
+};
+
+static const struct chip_device_desc_t unifi_device_desc_v2 =
+{
+    { FALSE, 0xf0ff, 0x2001, 0x02 },        /* UF2... R02 */
+    "UF2...",
+    "UniFi-2",
+    counted(init_vals_v2),                  /* init */
+    counted(reset_program_v1_or_v2),        /* reset_prog */
+    &unifi_device_regs_v2,                  /* regs */
+    {
+        TRUE,                               /* has_flash    */
+        TRUE,                               /* has_ext_sram */
+        FALSE,                              /* has_rom      */
+        FALSE,                              /* has_bt      */
+        TRUE,                               /* has_wlan */
+    },
+    counted(unifi_map_address_v1_v2),       /* map */
+    /* prog_offset */
+    {
+        0x00100000,                         /* ram */
+        0x00000000,                         /* rom (invalid) */
+        0x00000000,                         /* flash */
+        0x00200000,                         /* ext_ram */
+    },
+    /* data_offset */
+    {
+        0x8000                              /* ram */
+    },
+    /* windows */
+    {
+        &prog1_window_unifi_v1_v2,
+        &prog2_window_unifi_v1_v2,
+        &shared_window_unifi_v1_v2
+    }
+};
+
+static const struct chip_device_desc_t unifi_device_desc_v3 =
+{
+    { FALSE, 0xf0ff, 0x3001, 0x02 },        /* UF2... R03 */
+    "UF2...",
+    "UniFi-3",
+    counted(init_vals_v2),                  /* init */
+    counted(reset_program_v1_or_v2),        /* reset_prog */
+    &unifi_device_regs_v2,                  /* regs */
+    {
+        TRUE,                               /* has_flash    */
+        TRUE,                               /* has_ext_sram */
+        FALSE,                              /* has_rom      */
+        FALSE,                              /* has_bt      */
+        TRUE,                               /* has_wlan */
+    },
+    counted(unifi_map_address_v1_v2),       /* map */
+    /* prog_offset */
+    {
+        0x00100000,                         /* ram */
+        0x00000000,                         /* rom (invalid) */
+        0x00000000,                         /* flash */
+        0x00200000,                         /* ext_ram */
+    },
+    /* data_offset */
+    {
+        0x8000                              /* ram */
+    },
+    /* windows */
+    {
+        &prog1_window_unifi_v1_v2,
+        &prog2_window_unifi_v1_v2,
+        &shared_window_unifi_v1_v2
+    }
+};
+
+static const struct chip_device_desc_t unifi_device_desc_v22 =
+{
+    { FALSE, 0x00ff, 0x0022, 0x07 },        /* UF60xx */
+    "UF60xx",
+    "UniFi-4",
+    counted(init_vals_v22_v23),             /* init */
+    null_counted(),                         /* reset_prog */
+    &unifi_device_regs_v22_v23,             /* regs */
+    {
+        FALSE,                              /* has_flash    */
+        FALSE,                              /* has_ext_sram */
+        TRUE,                               /* has_rom      */
+        FALSE,                              /* has_bt       */
+        TRUE,                               /* has_wlan */
+    },
+    counted(unifi_map_address_v22_v23),     /* map */
+    /* prog_offset */
+    {
+        0x00C00000,                         /* ram */
+        0x00000000,                         /* rom */
+        0x00000000,                         /* flash (invalid) */
+        0x00000000,                         /* ext_ram (invalid) */
+    },
+    /* data_offset */
+    {
+        0x8000                              /* ram */
+    },
+    /* windows */
+    {
+        &generic1_window_unifi_v22_v23,
+        &generic2_window_unifi_v22_v23,
+        &generic3_window_unifi_v22_v23
+    }
+};
+
+static const struct chip_device_desc_t unifi_device_desc_v23 =
+{
+    { FALSE, 0x00ff, 0x0023, 0x08 },        /* UF.... */
+    "UF....",
+    "UF.... (5)",
+    counted(init_vals_v22_v23),             /* init */
+    null_counted(),                         /* reset_prog */
+    &unifi_device_regs_v22_v23,             /* regs */
+    {
+        FALSE,                              /* has_flash    */
+        FALSE,                              /* has_ext_sram */
+        TRUE,                               /* has_rom      */
+        TRUE,                               /* has_bt       */
+        TRUE,                               /* has_wlan */
+    },
+    counted(unifi_map_address_v22_v23),
+    /* prog_offset */
+    {
+        0x00C00000,                         /* ram */
+        0x00000000,                         /* rom */
+        0x00000000,                         /* flash (invalid) */
+        0x00000000,                         /* ext_sram (invalid) */
+    },
+    /* data_offset */
+    {
+        0x8000                              /* ram */
+    },
+    /* windows */
+    {
+        &generic1_window_unifi_v22_v23,
+        &generic2_window_unifi_v22_v23,
+        &generic3_window_unifi_v22_v23
+    }
+};
+
+static const struct chip_device_desc_t hyd_wlan_subsys_desc_v1 =
+{
+    { FALSE, 0x00ff, 0x0044, 0x00 },        /* UF.... */
+    "HYD...",
+    "HYD...    ",
+    counted(init_vals_v22_v23),             /* init */
+    null_counted(),                         /* reset_prog */
+    &unifi_device_regs_v22_v23,             /* regs */
+    {
+        FALSE,                              /* has_flash    */
+        FALSE,                              /* has_ext_sram */
+        TRUE,                               /* has_rom      */
+        FALSE,                              /* has_bt       */
+        TRUE,                               /* has_wlan */
+    },
+    counted(unifi_map_address_v22_v23),
+    /* prog_offset */
+    {
+        0x00C00000,                         /* ram */
+        0x00000000,                         /* rom */
+        0x00000000,                         /* flash (invalid) */
+        0x00000000,                         /* ext_sram (invalid) */
+    },
+    /* data_offset */
+    {
+        0x8000                              /* ram */
+    },
+    /* windows */
+    {
+        &generic1_window_unifi_v22_v23,
+        &generic2_window_unifi_v22_v23,
+        &generic3_window_unifi_v22_v23
+    }
+};
+
+
+/* This is the list of all chips that we know about.  I'm
+   assuming that the order here will be important - we
+   might have multiple entries witrh the same SDIO id for
+   instance.  The first one in this list will be the one
+   that is returned if a search is done on only that id.
+   The client will then have to call GetVersionXXX again
+   but with more detailed info.
+
+   I don't know if we need to signal this up to the client
+   in some way?
+
+   (We get the SDIO id before we know anything else about
+   the chip.  We might not be able to read any of the other
+   registers at first, but we still need to know about the
+   chip). */
+static const struct chip_device_desc_t *chip_ver_to_desc[] =
+{
+    &unifi_device_desc_v1,      /* UF105x R01 */
+    &unifi_device_desc_v2,      /* UF2... R02 */
+    &unifi_device_desc_v3,      /* UF2... R03 */
+    &unifi_device_desc_v22,     /* UF60xx */
+    &unifi_device_desc_v23,     /* UF.... */
+    &hyd_wlan_subsys_desc_v1
+};
+
+ChipDescript* ChipHelper_GetVersionSdio(CsrUint8 sdio_ver)
+{
+    CsrUint32 i;
+
+    for (i = 0; i < nelem(chip_ver_to_desc); i++)
+    {
+        if (chip_ver_to_desc[i]->chip_version.sdio == sdio_ver)
+        {
+            return chip_ver_to_desc[i];
+        }
+    }
+
+    return &chip_device_desc_null;
+}
+
+
+ChipDescript* ChipHelper_GetVersionAny(CsrUint16 from_FF9A, CsrUint16 from_FE81)
+{
+    CsrUint32 i;
+
+    if ((from_FF9A & 0xFF00) != 0)
+    {
+        for (i = 0; i < nelem(chip_ver_to_desc); i++)
+        {
+            if (chip_ver_to_desc[i]->chip_version.pre_bc7 &&
+                ((from_FF9A & chip_ver_to_desc[i]->chip_version.mask) ==
+                 chip_ver_to_desc[i]->chip_version.result))
+            {
+                return chip_ver_to_desc[i];
+            }
+        }
+    }
+    else
+    {
+        for (i = 0; i < nelem(chip_ver_to_desc); i++)
+        {
+            if (!chip_ver_to_desc[i]->chip_version.pre_bc7 &&
+                ((from_FE81 & chip_ver_to_desc[i]->chip_version.mask) ==
+                 chip_ver_to_desc[i]->chip_version.result))
+            {
+                return chip_ver_to_desc[i];
+            }
+        }
+    }
+
+    return &chip_device_desc_null;
+}
+
+
+ChipDescript* ChipHelper_GetVersionUniFi(CsrUint16 ver)
+{
+    return ChipHelper_GetVersionAny(0x0000, ver);
+}
+
+
+ChipDescript* ChipHelper_Null()
+{
+    return &chip_device_desc_null;
+}
+
+
+ChipDescript* ChipHelper_GetVersionBlueCore(enum chip_helper_bluecore_age bc_age, CsrUint16 version)
+{
+    if (bc_age == chip_helper_bluecore_pre_bc7)
+    {
+        return ChipHelper_GetVersionAny(version, 0x0000);
+    }
+    else
+    {
+        return ChipHelper_GetVersionAny(0x0000, version);
+    }
+}
+
+
+/* Expand the DEF0 functions into simple code to return the
+   correct thing.  The DEF1 functions expand to nothing in
+   this X macro expansion. */
+#define CHIP_HELPER_DEF0_C_DEF(ret_type, name, info)            \
+    ret_type ChipHelper_ ## name(ChipDescript * chip_help)           \
+    {                                                               \
+        return chip_help->info;                                     \
+    }
+#define CHIP_HELPER_DEF1_C_DEF(ret_type, name, type1, name1)
+
+CHIP_HELPER_LIST(C_DEF)
+
+/*
+ * Map register addresses between HOST and SPI access.
+ */
+CsrUint16 ChipHelper_MapAddress_SPI2HOST(ChipDescript *chip_help, CsrUint16 addr)
+{
+    CsrUint32 i;
+    for (i = 0; i < chip_help->map.len; i++)
+    {
+        if (chip_help->map.vals[i].spi == addr)
+        {
+            return chip_help->map.vals[i].host;
+        }
+    }
+    return addr;
+}
+
+
+CsrUint16 ChipHelper_MapAddress_HOST2SPI(ChipDescript *chip_help, CsrUint16 addr)
+{
+    CsrUint32 i;
+    for (i = 0; i < chip_help->map.len; i++)
+    {
+        if (chip_help->map.vals[i].host == addr)
+        {
+            return chip_help->map.vals[i].spi;
+        }
+    }
+    return addr;
+}
+
+
+/* The address returned by this function is the start of the
+   window in the address space, that is where we can start
+   accessing data from.  If a section of the window at the
+   start is unusable because something else is cluttering up
+   the address map then that is taken into account and this
+   function returns that address justt past that. */
+CsrUint16 ChipHelper_WINDOW_ADDRESS(ChipDescript                 *chip_help,
+                                    enum chip_helper_window_index window)
+{
+    if (window < CHIP_HELPER_WINDOW_COUNT &&
+        chip_help->windows[window] != NULL)
+    {
+        return chip_help->windows[window]->address + chip_help->windows[window]->blocked;
+    }
+    return 0;
+}
+
+
+/* This returns the size of the window minus any blocked section */
+CsrUint16 ChipHelper_WINDOW_SIZE(ChipDescript                 *chip_help,
+                                 enum chip_helper_window_index window)
+{
+    if (window < CHIP_HELPER_WINDOW_COUNT &&
+        chip_help->windows[window] != NULL)
+    {
+        return chip_help->windows[window]->size - chip_help->windows[window]->blocked;
+    }
+    return 0;
+}
+
+
+/* Get the register writes we should do to make sure that
+   the chip is running with most clocks on. */
+CsrUint32 ChipHelper_ClockStartupSequence(ChipDescript                          *chip_help,
+                                          const struct chip_helper_init_values **val)
+{
+    *val = chip_help->init.vals;
+    return chip_help->init.len;
+}
+
+
+/* Get the set of values tat we should write to the chip to perform a reset. */
+CsrUint32 ChipHelper_HostResetSequence(ChipDescript                           *chip_help,
+                                       const struct chip_helper_reset_values **val)
+{
+    *val = chip_help->reset_prog.vals;
+    return chip_help->reset_prog.len;
+}
+
+
+/* Decode a windowed access to the chip. */
+CsrInt32 ChipHelper_DecodeWindow(ChipDescript *chip_help,
+                                 enum chip_helper_window_index window,
+                                 enum chip_helper_window_type type,
+                                 CsrUint32 offset,
+                                 CsrUint16 *page, CsrUint16 *addr, CsrUint32 *len)
+{
+    const struct window_info_t *win;
+    const struct window_shift_info_t *mode;
+    CsrUint16 of, pg;
+
+    if (window >= CHIP_HELPER_WINDOW_COUNT)
+    {
+        return FALSE;
+    }
+    if ((win = chip_help->windows[window]) == NULL)
+    {
+        return FALSE;
+    }
+    if (type >= CHIP_HELPER_WT_COUNT)
+    {
+        return FALSE;
+    }
+    if ((mode = &win->mode[type]) == NULL)
+    {
+        return FALSE;
+    }
+    if (!mode->allowed)
+    {
+        return FALSE;
+    }
+
+    pg = (CsrUint16)(offset >> mode->page_shift) + mode->page_offset;
+    of = (CsrUint16)(offset & ((1 << mode->page_shift) - 1));
+    /* If 'blocked' is zero this does nothing, else decrease
+       the page register and increase the offset until we aren't
+       in the blocked region of the window. */
+    while (of < win->blocked)
+    {
+        of += 1 << mode->page_shift;
+        pg--;
+    }
+    *page = pg;
+    *addr = win->address + of;
+    *len = win->size - of;
+    return TRUE;
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_chiphelper.h
@@ -0,0 +1,471 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifndef CSR_WIFI_HIP_CHIPHELPER_H__
+#define CSR_WIFI_HIP_CHIPHELPER_H__
+
+
+#include "csr_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The age of the BlueCore chip.  This is probably not useful, if
+   you know the age then you can probably work out the version directly. */
+enum chip_helper_bluecore_age
+{
+    chip_helper_bluecore_pre_bc7,
+    chip_helper_bluecore_bc7_or_later
+};
+
+/* We support up to three windowed regions at the moment.
+   Don't reorder these - they're used to index into an array. */
+enum chip_helper_window_index
+{
+    CHIP_HELPER_WINDOW_1        = 0,
+    CHIP_HELPER_WINDOW_2        = 1,
+    CHIP_HELPER_WINDOW_3        = 2,
+    CHIP_HELPER_WINDOW_COUNT    = 3
+};
+
+/* These are the things that we can access through a window.
+   Don't reorder these - they're used to index into an array. */
+enum chip_helper_window_type
+{
+    CHIP_HELPER_WT_CODE_RAM = 0,
+    CHIP_HELPER_WT_FLASH    = 1,
+    CHIP_HELPER_WT_EXT_SRAM = 2,
+    CHIP_HELPER_WT_ROM      = 3,
+    CHIP_HELPER_WT_SHARED   = 4,
+    CHIP_HELPER_WT_COUNT    = 5
+};
+
+/* Commands to stop and start the XAP */
+enum chip_helper_dbg_emu_cmd_enum
+{
+    CHIP_HELPER_DBG_EMU_CMD_XAP_STEP_MASK   = 0x0001,
+    CHIP_HELPER_DBG_EMU_CMD_XAP_RUN_B_MASK  = 0x0002,
+    CHIP_HELPER_DBG_EMU_CMD_XAP_BRK_MASK    = 0x0004,
+    CHIP_HELPER_DBG_EMU_CMD_XAP_WAKEUP_MASK = 0x0008
+};
+
+/* Bitmasks for Stop and sleep status: DBG_SPI_STOP_STATUS & DBG_HOST_STOP_STATUS */
+enum chip_helper_dbg_stop_status_enum
+{
+    CHIP_HELPER_DBG_STOP_STATUS_NONE_MASK               = 0x0000,
+    CHIP_HELPER_DBG_STOP_STATUS_P0_MASK                 = 0x0001,
+    CHIP_HELPER_DBG_STOP_STATUS_P1_MASK                 = 0x0002,
+    CHIP_HELPER_DBG_STOP_STATUS_P2_MASK                 = 0x0004,
+    CHIP_HELPER_DBG_STOP_STATUS_SLEEP_STATUS_P0_MASK    = 0x0008,
+    CHIP_HELPER_DBG_STOP_STATUS_SLEEP_STATUS_P1_MASK    = 0x0010,
+    CHIP_HELPER_DBG_STOP_STATUS_SLEEP_STATUS_P2_MASK    = 0x0020,
+    /* Legacy names/alias */
+    CHIP_HELPER_DBG_STOP_STATUS_MAC_MASK                = 0x0001,
+    CHIP_HELPER_DBG_STOP_STATUS_PHY_MASK                = 0x0002,
+    CHIP_HELPER_DBG_STOP_STATUS_BT_MASK                 = 0x0004,
+    CHIP_HELPER_DBG_STOP_STATUS_SLEEP_STATUS_MAC_MASK   = 0x0008,
+    CHIP_HELPER_DBG_STOP_STATUS_SLEEP_STATUS_PHY_MASK   = 0x0010,
+    CHIP_HELPER_DBG_STOP_STATUS_SLEEP_STATUS_BT_MASK    = 0x0020
+};
+
+/* Codes to disable the watchdog */
+enum chip_helper_watchdog_disable_enum
+{
+    CHIP_HELPER_WATCHDOG_DISABLE_CODE1 = 0x6734,
+    CHIP_HELPER_WATCHDOG_DISABLE_CODE2 = 0xD6BF,
+    CHIP_HELPER_WATCHDOG_DISABLE_CODE3 = 0xC31E
+};
+
+/* Other bits have changed between versions */
+enum chip_helper_gbl_misc_enum
+{
+    CHIP_HELPER_GBL_MISC_SPI_STOP_OUT_EN_MASK  = 0x0001,
+    CHIP_HELPER_GBL_MISC_MMU_INIT_DONE_MASK    = 0x0004
+};
+
+/* Coex status register, contains interrupt status and reset pullup status.
+ * CHIP_HELPER_COEX_STATUS_RST_PULLS_MSB_MASK can be used to check
+ * for WAPI on R03 chips and later. */
+enum chip_helper_coex_status_mask_enum
+{
+    CHIP_HELPER_COEX_STATUS_RST_PULLS_LSB_MASK   = 0x0001,
+    CHIP_HELPER_COEX_STATUS_RST_PULLS_MSB_MASK   = 0x0008,
+    CHIP_HELPER_COEX_STATUS_WL_FEC_PINS_LSB_MASK = 0x0010,
+    CHIP_HELPER_COEX_STATUS_WL_FEC_PINS_MSB_MASK = 0x0080,
+    CHIP_HELPER_COEX_STATUS_INT_UART_MASK        = 0x0100,
+    CHIP_HELPER_COEX_STATUS_INT_BT_LEG_MASK      = 0x0200
+};
+
+/* How to select the different CPUs */
+enum chip_helper_dbg_proc_sel_enum
+{
+    CHIP_HELPER_DBG_PROC_SEL_MAC  = 0,
+    CHIP_HELPER_DBG_PROC_SEL_PHY  = 1,
+    CHIP_HELPER_DBG_PROC_SEL_BT   = 2,
+    CHIP_HELPER_DBG_PROC_SEL_NONE = 2,
+    CHIP_HELPER_DBG_PROC_SEL_BOTH = 3
+};
+
+/* These are the only registers that we have to know the
+   address of before we know the chip version. */
+enum chip_helper_fixed_registers
+{
+    /* This is the address of GBL_CHIP_VERISON on BC7,
+       UF105x, UF60xx and
+       anything later than that. */
+    CHIP_HELPER_UNIFI_GBL_CHIP_VERSION  = 0xFE81,
+
+    CHIP_HELPER_OLD_BLUECORE_GBL_CHIP_VERSION = 0xFF9A
+
+                                                /* This isn't used at the moment (but might be needed
+                                                to distinguish the BlueCore sub version?) */
+                                                /* CHIP_HELPER_OLD_BLUECORE_ANA_VERSION_ID = 0xFF7D */
+};
+
+/* Address-value pairs for defining initialisation values */
+struct chip_helper_init_values
+{
+    CsrUint16 addr;
+    CsrUint16 value;
+};
+
+/* A block of data that should be written to the device */
+struct chip_helper_reset_values
+{
+    CsrUint32        gp_address;
+    CsrUint32        len;
+    const CsrUint16 *data;
+};
+
+/*
+ * This is the C API.
+ */
+
+/* opaque type */
+typedef const struct chip_device_desc_t ChipDescript;
+
+/* Return a NULL descriptor */
+ChipDescript* ChipHelper_Null(void);
+
+/* This should get the correct version for any CSR chip.
+   The two parameters are what is read from addresses
+   0xFF9A and 0xFE81 (OLD_BLUECORE_GBL_CHIP_VERSION and
+   UNIFI_GBL_CHIP_VERSION).  These should give a unique identity
+   for most (all?) chips.
+
+   FF9A is the old GBL_CHIP_VERSION register.  If the high
+   eight bits are zero then the chip is a new (BC7 +) one
+   and FE81 is the _new_ GBL_CHIP_VERSION register. */
+ChipDescript* ChipHelper_GetVersionAny(CsrUint16 from_FF9A, CsrUint16 from_FE81);
+
+/* The chip is a UniFi, but we don't know which type
+   The parameter is the value of UNIFI_GBL_CHIP_VERSION (0xFE81) */
+ChipDescript* ChipHelper_GetVersionUniFi(CsrUint16 version);
+
+/* This gets the version from the SDIO device id.  This only
+   gives quite a coarse grained version, so we should update once
+   we hav access to the function N registers. */
+ChipDescript* ChipHelper_GetVersionSdio(CsrUint8 sdio_version);
+
+/* The chip is some sort of BlueCore.  If "age" is "pre_bc7" then
+   "version" is what was read from FF9A.  If "age" is bc7_or_later
+   then "version" is read from FE81.  If we don't know if we're pre
+   or post BC7 then we should use "GetVersionAny". */
+ChipDescript* ChipHelper_GetVersionBlueCore(enum chip_helper_bluecore_age age,
+                                            CsrUint16                     version);
+
+/* The main functions of this class are built with an X macro.  This
+   means we can generate the C and C++ versions from the same source
+   without the two diverging.
+
+   The DEF0 functions are simple and take no parameters.  The first
+   parameter to the macro is the return type.  The second parameter
+   is the function name and the third parameter is where to get the
+   info from (this is hidden from the user).
+
+   The DEF1 functions take one parameter. This time the third macro
+   parameter is the type of this parameter, and the fourth macro
+   parameter is the name of the parameter. The bodies of these
+   functions are hand written. */
+#define CHIP_HELPER_LIST(m)                                             \
+    CHIP_HELPER_DEF0(m, (const CsrCharString *, FriendlyName, friendly_name))     \
+    CHIP_HELPER_DEF0(m, (const CsrCharString *, MarketingName, marketing_name))  \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DBG_EMU_CMD, regs->dbg_emu_cmd))       \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DBG_HOST_PROC_SELECT, regs->host.dbg_proc_select)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DBG_HOST_STOP_STATUS, regs->host.dbg_stop_status)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, HOST_WINDOW1_PAGE, regs->host.window1_page)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, HOST_WINDOW2_PAGE, regs->host.window2_page)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, HOST_WINDOW3_PAGE, regs->host.window3_page)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, HOST_IO_LOG_ADDR, regs->host.io_log_addr)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DBG_SPI_PROC_SELECT, regs->spi.dbg_proc_select)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DBG_SPI_STOP_STATUS, regs->spi.dbg_stop_status)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, SPI_WINDOW1_PAGE, regs->spi.window1_page)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, SPI_WINDOW2_PAGE, regs->spi.window2_page)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, SPI_WINDOW3_PAGE, regs->spi.window3_page)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, SPI_IO_LOG_ADDR, regs->spi.io_log_addr)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DBG_RESET, regs->dbg_reset))           \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DBG_RESET_VALUE, regs->dbg_reset_value)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DBG_RESET_WARN, regs->dbg_reset_warn)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DBG_RESET_WARN_VALUE, regs->dbg_reset_warn_value)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DBG_RESET_RESULT, regs->dbg_reset_result)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, WATCHDOG_DISABLE, regs->watchdog_disable)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, PROC_PC_SNOOP, regs->proc_pc_snoop))   \
+    CHIP_HELPER_DEF0(m, (CsrUint16, GBL_CHIP_VERSION, regs->gbl_chip_version)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, GBL_MISC_ENABLES, regs->gbl_misc_enables)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, XAP_PCH, regs->xap_pch))               \
+    CHIP_HELPER_DEF0(m, (CsrUint16, XAP_PCL, regs->xap_pcl))               \
+    CHIP_HELPER_DEF0(m, (CsrUint16, MAILBOX0, regs->mailbox0))             \
+    CHIP_HELPER_DEF0(m, (CsrUint16, MAILBOX1, regs->mailbox1))             \
+    CHIP_HELPER_DEF0(m, (CsrUint16, MAILBOX2, regs->mailbox2))             \
+    CHIP_HELPER_DEF0(m, (CsrUint16, MAILBOX3, regs->mailbox3))             \
+    CHIP_HELPER_DEF0(m, (CsrUint16, SDIO_HIP_HANDSHAKE, regs->sdio_hip_handshake))   \
+    CHIP_HELPER_DEF0(m, (CsrUint16, SDIO_HOST_INT, regs->sdio_host_int))   \
+    CHIP_HELPER_DEF0(m, (CsrUint16, COEX_STATUS, regs->coex_status))       \
+    CHIP_HELPER_DEF0(m, (CsrUint16, SHARED_IO_INTERRUPT, regs->shared_io_interrupt)) \
+    CHIP_HELPER_DEF0(m, (CsrUint32, PROGRAM_MEMORY_RAM_OFFSET, prog_offset.ram)) \
+    CHIP_HELPER_DEF0(m, (CsrUint32, PROGRAM_MEMORY_ROM_OFFSET, prog_offset.rom)) \
+    CHIP_HELPER_DEF0(m, (CsrUint32, PROGRAM_MEMORY_FLASH_OFFSET, prog_offset.flash)) \
+    CHIP_HELPER_DEF0(m, (CsrUint32, PROGRAM_MEMORY_EXT_SRAM_OFFSET, prog_offset.ext_sram)) \
+    CHIP_HELPER_DEF0(m, (CsrUint16, DATA_MEMORY_RAM_OFFSET, data_offset.ram)) \
+    CHIP_HELPER_DEF0(m, (CsrInt32, HasFlash, bools.has_flash))              \
+    CHIP_HELPER_DEF0(m, (CsrInt32, HasExtSram, bools.has_ext_sram))         \
+    CHIP_HELPER_DEF0(m, (CsrInt32, HasRom, bools.has_rom))                  \
+    CHIP_HELPER_DEF0(m, (CsrInt32, HasBt, bools.has_bt))                    \
+    CHIP_HELPER_DEF0(m, (CsrInt32, HasWLan, bools.has_wlan))                \
+    CHIP_HELPER_DEF1(m, (CsrUint16, WINDOW_ADDRESS, enum chip_helper_window_index, window)) \
+    CHIP_HELPER_DEF1(m, (CsrUint16, WINDOW_SIZE, enum chip_helper_window_index, window)) \
+    CHIP_HELPER_DEF1(m, (CsrUint16, MapAddress_SPI2HOST, CsrUint16, addr))          \
+    CHIP_HELPER_DEF1(m, (CsrUint16, MapAddress_HOST2SPI, CsrUint16, addr))          \
+    CHIP_HELPER_DEF1(m, (CsrUint32, ClockStartupSequence, const struct chip_helper_init_values **, val)) \
+    CHIP_HELPER_DEF1(m, (CsrUint32, HostResetSequence, const struct chip_helper_reset_values **, val))
+
+/* Some magic to help the expansion */
+#define CHIP_HELPER_DEF0(a, b) \
+    CHIP_HELPER_DEF0_ ## a b
+#define CHIP_HELPER_DEF1(a, b) \
+    CHIP_HELPER_DEF1_ ## a b
+
+/* Macros so that when we expand the list we get "C" function prototypes. */
+#define CHIP_HELPER_DEF0_C_DEC(ret_type, name, info)    \
+    ret_type ChipHelper_ ## name(ChipDescript * chip_help);
+#define CHIP_HELPER_DEF1_C_DEC(ret_type, name, type1, name1)   \
+    ret_type ChipHelper_ ## name(ChipDescript * chip_help, type1 name1);
+
+CHIP_HELPER_LIST(C_DEC)
+
+/* FriendlyName
+   MarketingName
+
+   These two functions return human readable strings that describe
+   the chip.  FriendlyName returns something that a software engineer
+   at CSR might understand.  MarketingName returns something more like
+   an external name for a CSR chip.
+*/
+/* DBG_EMU_CMD
+   WATCHDOG_DISABLE
+   PROC_PC_SNOOP
+   GBL_CHIP_VERSION
+   XAP_PCH
+   XAP_PCL
+
+   These registers are used to control the XAPs.
+*/
+/* DBG_HOST_PROC_SELECT  DBG_HOST_STOP_STATUS
+   HOST_WINDOW1_PAGE HOST_WINDOW2_PAGE HOST_WINDOW3_PAGE
+   HOST_IO_LOG_ADDR
+   DBG_SPI_PROC_SELECT  DBG_SPI_STOP_STATUS
+   SPI_WINDOW1_PAGE SPI_WINDOW2_PAGE SPI_WINDOW3_PAGE
+   SPI_IO_LOG_ADDR
+
+   These register are used to control the XAPs and the memory
+   windows, normally while debugging the code on chip.  There
+   are two versons of these registers, one for access via SPI
+   and another for access via the host interface.
+*/
+/*  DBG_RESET
+    DBG_RESET_VALUE
+    DBG_RESET_WARN
+    DBG_RESET_WARN_VALUE
+    DBG_RESET_RESULT
+
+    These registers are used to reset the XAP.  This can be
+    quite complex for some chips.  If DBG_RESET_WARN is non
+    zero the DBG_RESET_WARN_VALUE should be written to address
+    DBG_RESET_WARN before the reset is perfeormed.  DBG_RESET_VALUE
+    should then be written to DBG_RESET to make the reset happen.
+    The DBG_RESET_RESULT register should contain 0 if the reset
+    was successful.
+*/
+/*  GBL_MISC_ENABLES
+
+    This register controls some special chip features.  It
+    should be used with care is it changes quite a lot between
+    chip versions.
+*/
+/*  MAILBOX0
+    MAILBOX1
+    MAILBOX2
+    MAILBOX3
+
+    The mailbox registers are for communication between the host
+    and the firmware.  There use is described in part by the host
+    interface protcol specifcation.
+*/
+/*  SDIO_HIP_HANDSHAKE
+
+    This is one of the more important SDIO HIP registers.  On some
+    chips it has the same value as one of the mailbox registers
+    and on other chips it is different.
+*/
+/*  SDIO_HOST_INT
+    SHARED_IO_INTERRUPT
+
+    These registers are used by some versions of the host interface
+    protocol specification.  Their names should probably be changed
+    to hide the registers and to expose the functions more.
+*/
+/*  COEX_STATUS
+
+    Coex status register, contains interrupt status and reset
+    pullup status.  The latter is used to detect WAPI.
+*/
+/*  PROGRAM_MEMORY_RAM_OFFSET
+    PROGRAM_MEMORY_ROM_OFFSET
+    PROGRAM_MEMORY_FLASH_OFFSET
+    PROGRAM_MEMORY_EXT_SRAM_OFFSET
+    DATA_MEMORY_RAM_OFFSET
+
+    These are constants that describe the offset of the different
+    memory types in the two different address spaces.
+*/
+/*  HasFlash HasExtSram HasRom
+    HasBt HasWLan
+
+    These are a set of bools describing the chip.
+*/
+/*  WINDOW_ADDRESS WINDOW_SIZE
+
+    These two functions return the size and address of the windows.
+    The address is the address of the lowest value in the address
+    map that is part of the window and the size is the number of
+    visible words.
+
+    Some of the windows have thier lowest portion covered by
+    registers.  For these windows address is the first address
+    after the registers and size is the siave excluding the part
+    covered by registers.
+*/
+/*  MapAddress_SPI2HOST
+    MapAddress_HOST2SPI
+
+    The debugging interface is duplicated on UniFi and later chips
+    so that there are two versions - one over the SPI interaface and
+    the other over the SDIO interface.  These functions map the
+    registers between these two interfaces.
+*/
+/*  ClockStartupSequence
+
+    This function returns the list of register value pairs that
+    should be forced into UniFi to enable SPI communication.  This
+    set of registers is not needed if the firmware is running, but
+    will be needed if the device is being booted from cold.  These
+    register writes enable the clocks and setup the PLL to a basic
+    working state.  SPI access might be unreliable until these writes
+    have occured (And they may take mulitple goes).
+*/
+/*  HostResetSequence
+
+    This returns a number of chunks of data and generic pointers.
+    All of the XAPs should be stopped.  The data should be written
+    to the generic pointers.  The instruction pointer for the MAC
+    should then be set to the start of program memory and then the
+    MAC should be "go"d.  This will reset the chip in a reliable
+    and orderly manner without resetting the SDIO interface.  It
+    is therefore not needed if the chip is being accessed by the
+    SPI interface (the DBG_RESET_ mechanism can be used instead).
+*/
+
+/* The Decode Window function is more complex.  For the window
+   'window' it tries to return the address and page register
+   value needed to see offset 'offset' of memory type 'type'.
+
+   It return 1 on success and 0 on failure.  'page' is what
+   should be written to the page register.  'addr' is the
+   address in the XAPs 16 address map to read from.  'len'
+   is the length that we can read without having to change
+   the page registers. */
+CsrInt32 ChipHelper_DecodeWindow(ChipDescript *chip_help,
+                                 enum chip_helper_window_index window,
+                                 enum chip_helper_window_type type,
+                                 CsrUint32 offset,
+                                 CsrUint16 *page, CsrUint16 *addr, CsrUint32 *len);
+
+#ifdef __cplusplus
+/* Close the extern "C" */
+}
+
+/*
+ * This is the C++ API.
+ */
+
+class ChipHelper
+{
+public:
+    /* If this constructor is used then a GetVersionXXX function
+       should be called next. */
+    ChipHelper();
+
+    /* copy constructor */
+    ChipHelper(ChipDescript * desc);
+
+    /* The default constructor assume a BC7 / UF105x series chip
+       and that the number given is the value of UNIFI_GBL_CHIP_VERSION
+       (0xFE81) */
+    ChipHelper(CsrUint16 version);
+
+    /* This returns the C interface magic token from a C++ instance. */
+    ChipDescript* GetDescript() const
+    {
+        return m_desc;
+    }
+
+
+    /* Clear out theis class (set it to the null token). */
+    void ClearVersion();
+
+    /* Load this class with data for a specific chip. */
+    void GetVersionAny(CsrUint16 from_FF9A, CsrUint16 from_FE81);
+    void GetVersionUniFi(CsrUint16 version);
+    void GetVersionBlueCore(chip_helper_bluecore_age age, CsrUint16 version);
+    void GetVersionSdio(CsrUint8 sdio_version);
+
+    /* Helpers to build the definitions of the member functions. */
+#define CHIP_HELPER_DEF0_CPP_DEC(ret_type, name, info)    \
+    ret_type name() const;
+#define CHIP_HELPER_DEF1_CPP_DEC(ret_type, name, type1, name1)   \
+    ret_type name(type1 name1) const;
+
+    CHIP_HELPER_LIST(CPP_DEC)
+
+
+    /* The DecodeWindow function, see the description of the C version. */
+    CsrInt32 DecodeWindow(chip_helper_window_index window,
+                          chip_helper_window_type type,
+                          CsrUint32 offset,
+                          CsrUint16 &page, CsrUint16 &addr, CsrUint32 &len) const;
+
+private:
+    ChipDescript *m_desc;
+};
+
+#endif /* __cplusplus */
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_chiphelper_private.h
@@ -0,0 +1,208 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifndef CSR_WIFI_HIP_CHIPHELPER_PRIVATE_H__
+#define CSR_WIFI_HIP_CHIPHELPER_PRIVATE_H__
+
+
+#include "csr_wifi_hip_chiphelper.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* This GP stuff should be somewhere else? */
+
+/* Memory spaces encoded in top byte of Generic Pointer type */
+#define UNIFI_SH_DMEM   0x01    /* Shared Data Memory */
+#define UNIFI_EXT_FLASH 0x02    /* External FLASH */
+#define UNIFI_EXT_SRAM  0x03    /* External SRAM */
+#define UNIFI_REGISTERS 0x04    /* Registers */
+#define UNIFI_PHY_DMEM  0x10    /* PHY Data Memory */
+#define UNIFI_PHY_PMEM  0x11    /* PHY Program Memory */
+#define UNIFI_PHY_ROM   0x12    /* PHY ROM */
+#define UNIFI_MAC_DMEM  0x20    /* MAC Data Memory */
+#define UNIFI_MAC_PMEM  0x21    /* MAC Program Memory */
+#define UNIFI_MAC_ROM   0x22    /* MAC ROM */
+#define UNIFI_BT_DMEM   0x30    /* BT Data Memory */
+#define UNIFI_BT_PMEM   0x31    /* BT Program Memory */
+#define UNIFI_BT_ROM    0x32    /* BT ROM */
+
+#define MAKE_GP(R, O)  (((UNIFI_ ## R) << 24) | (O))
+#define GP_OFFSET(GP)  ((GP) & 0xFFFFFF)
+#define GP_SPACE(GP)   (((GP) >> 24) & 0xFF)
+
+
+/* Address value pairs */
+struct val_array_t
+{
+    CsrUint32                             len;
+    const struct chip_helper_init_values *vals;
+};
+
+/* Just a (counted) CsrUint16 array */
+struct data_array_t
+{
+    CsrUint32        len;
+    const CsrUint16 *vals;
+};
+
+struct reset_prog_t
+{
+    CsrUint32                              len;
+    const struct chip_helper_reset_values *vals;
+};
+
+/* The addresses of registers that are equivalent but on
+   different host transports. */
+struct chip_map_address_t
+{
+    CsrUint16 spi, host;
+};
+
+struct map_array_t
+{
+    CsrUint32                        len;
+    const struct chip_map_address_t *vals;
+};
+
+struct chip_device_regs_per_transport_t
+{
+    CsrUint16 dbg_proc_select;
+    CsrUint16 dbg_stop_status;
+    CsrUint16 window1_page;    /* PROG_PMEM1 or GW1 */
+    CsrUint16 window2_page;    /* PROG_PMEM2 or GW2 */
+    CsrUint16 window3_page;    /* SHARED or GW3 */
+    CsrUint16 io_log_addr;
+};
+
+struct chip_device_regs_t
+{
+    CsrUint16                               gbl_chip_version;
+    CsrUint16                               gbl_misc_enables;
+    CsrUint16                               dbg_emu_cmd;
+    struct chip_device_regs_per_transport_t host;
+    struct chip_device_regs_per_transport_t spi;
+    CsrUint16                               dbg_reset;
+    CsrUint16                               dbg_reset_value;
+    CsrUint16                               dbg_reset_warn;
+    CsrUint16                               dbg_reset_warn_value;
+    CsrUint16                               dbg_reset_result;
+    CsrUint16                               xap_pch;
+    CsrUint16                               xap_pcl;
+    CsrUint16                               proc_pc_snoop;
+    CsrUint16                               watchdog_disable;
+    CsrUint16                               mailbox0;
+    CsrUint16                               mailbox1;
+    CsrUint16                               mailbox2;
+    CsrUint16                               mailbox3;
+    CsrUint16                               sdio_host_int;
+    CsrUint16                               shared_io_interrupt;
+    CsrUint16                               sdio_hip_handshake;
+    CsrUint16                               coex_status; /* Allows WAPI detection */
+};
+
+/* If allowed is false then this window does not provide this
+   type of access.
+   This describes how addresses should be shifted to make the
+   "page" address.  The address is shifted left by 'page_shift'
+   and then has 'page_offset' added.  This value should then be
+   written to the page register. */
+struct window_shift_info_t
+{
+    CsrInt32  allowed;
+    CsrUint32 page_shift;
+    CsrUint16 page_offset;
+};
+
+/* Each window has an address and size.  These are obvious.  It then
+   has a description for each type of memory that might be accessed
+   through it.  There might also be a start to the offset of the window.
+   This means that that number of addresses at the start of the window
+   are unusable. */
+struct window_info_t
+{
+    CsrUint16                         address;
+    CsrUint16                         size;
+    CsrUint16                         blocked;
+    const struct window_shift_info_t *mode;
+};
+
+/* If GBL_CHIP_VERSION and'ed with 'mask' and is equal to 'result'
+   then this is the correct set of info.  If pre_bc7 is true then the
+   address of GBL_CHIP_VERSION is FF9A, else its FE81. */
+struct chip_version_t
+{
+    CsrInt32  pre_bc7;
+    CsrUint16 mask;
+    CsrUint16 result;
+    CsrUint8  sdio;
+};
+
+struct chip_device_desc_t
+{
+    struct chip_version_t chip_version;
+
+    /* This is a text string that a human might find useful (BC02, UF105x) */
+    const CsrCharString *friendly_name;
+    /* This is what we show to customers */
+    const CsrCharString *marketing_name;
+
+    /* Initialisation values to write following a reset */
+    struct val_array_t init;
+
+    /* Binary sequence for hard reset */
+    struct reset_prog_t reset_prog;
+
+    /* The register map */
+    const struct chip_device_regs_t *regs;
+
+    /* Some misc. info on the chip */
+    struct
+    {
+        CsrUint32 has_flash     : 1;
+        CsrUint32 has_ext_sram  : 1;
+        CsrUint32 has_rom       : 1;
+        CsrUint32 has_bt        : 1;
+        CsrUint32 has_wlan      : 1;
+    } bools;
+
+    /* This table is used to remap register addresses depending on what
+       host interface is used.  On the BC7 and later chips there are
+       multiple sets of memory window registers, on for each host
+       interafce (SDIO / SPI).  The correct one is needed. */
+    struct map_array_t map;
+
+    /* The offsets into the program address space of the different types of memory.
+       The RAM offset is probably the most useful. */
+    struct
+    {
+        CsrUint32 ram;
+        CsrUint32 rom;
+        CsrUint32 flash;
+        CsrUint32 ext_sram;
+    } prog_offset;
+
+    /* The offsets into the data address space of interesting things. */
+    struct
+    {
+        CsrUint16 ram;
+        /* maybe add shared / page tables? */
+    } data_offset;
+
+    /* Information on the different windows */
+    const struct window_info_t *windows[CHIP_HELPER_WINDOW_COUNT];
+};
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* CSR_WIFI_HIP_CHIPHELPER_PRIVATE_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_conversions.h
@@ -0,0 +1,81 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ * FILE: csr_wifi_hip_conversions.h
+ *
+ * PURPOSE:
+ *      This header file provides the macros for converting to and from
+ *      wire format.
+ *      These macros *MUST* work for little-endian AND big-endian hosts.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#ifndef __CSR_WIFI_HIP_CONVERSIONS_H__
+#define __CSR_WIFI_HIP_CONVERSIONS_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SIZEOF_UINT16           2
+#define SIZEOF_UINT32           4
+#define SIZEOF_UINT64           8
+
+#define SIZEOF_SIGNAL_HEADER    6
+#define SIZEOF_DATAREF          4
+
+
+/*
+ * Macro to retrieve the signal ID from a wire-format signal.
+ */
+#define GET_SIGNAL_ID(_buf)     CSR_GET_UINT16_FROM_LITTLE_ENDIAN((_buf))
+
+/*
+ * Macros to retrieve and set the DATAREF fields in a packed (i.e. wire-format)
+ * HIP signal.
+ */
+#define GET_PACKED_DATAREF_SLOT(_buf, _ref)                             \
+    CSR_GET_UINT16_FROM_LITTLE_ENDIAN(((_buf) + SIZEOF_SIGNAL_HEADER + ((_ref) * SIZEOF_DATAREF) + 0))
+
+#define GET_PACKED_DATAREF_LEN(_buf, _ref)                              \
+    CSR_GET_UINT16_FROM_LITTLE_ENDIAN(((_buf) + SIZEOF_SIGNAL_HEADER + ((_ref) * SIZEOF_DATAREF) + 2))
+
+#define SET_PACKED_DATAREF_SLOT(_buf, _ref, _slot)                      \
+    CSR_COPY_UINT16_TO_LITTLE_ENDIAN((_slot), ((_buf) + SIZEOF_SIGNAL_HEADER + ((_ref) * SIZEOF_DATAREF) + 0))
+
+#define SET_PACKED_DATAREF_LEN(_buf, _ref, _len)                        \
+    CSR_COPY_UINT16_TO_LITTLE_ENDIAN((_len), ((_buf) + SIZEOF_SIGNAL_HEADER + ((_ref) * SIZEOF_DATAREF) + 2))
+
+#define GET_PACKED_MA_PACKET_REQUEST_FRAME_PRIORITY(_buf)              \
+    CSR_GET_UINT16_FROM_LITTLE_ENDIAN(((_buf) + SIZEOF_SIGNAL_HEADER + UNIFI_MAX_DATA_REFERENCES * SIZEOF_DATAREF + 8))
+
+#define GET_PACKED_MA_PACKET_REQUEST_HOST_TAG(_buf)                     \
+    CSR_GET_UINT32_FROM_LITTLE_ENDIAN(((_buf) + SIZEOF_SIGNAL_HEADER + UNIFI_MAX_DATA_REFERENCES * SIZEOF_DATAREF + 4))
+
+#define GET_PACKED_MA_PACKET_CONFIRM_HOST_TAG(_buf)                     \
+    CSR_GET_UINT32_FROM_LITTLE_ENDIAN(((_buf) + SIZEOF_SIGNAL_HEADER + UNIFI_MAX_DATA_REFERENCES * SIZEOF_DATAREF + 8))
+
+#define GET_PACKED_MA_PACKET_CONFIRM_TRANSMISSION_STATUS(_buf)                     \
+    CSR_GET_UINT16_FROM_LITTLE_ENDIAN(((_buf) + SIZEOF_SIGNAL_HEADER + UNIFI_MAX_DATA_REFERENCES * SIZEOF_DATAREF + 2))
+
+
+CsrInt32 get_packed_struct_size(const CsrUint8 *buf);
+CsrResult read_unpack_signal(const CsrUint8 *ptr, CSR_SIGNAL *sig);
+CsrResult write_pack(const CSR_SIGNAL *sig, CsrUint8 *ptr, CsrUint16 *sig_len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CSR_WIFI_HIP_CONVERSIONS_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_download.c
@@ -0,0 +1,834 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ * FILE: csr_wifi_hip_download.c
+ *
+ * PURPOSE:
+ *      Routines for downloading firmware to UniFi.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_unifiversion.h"
+#include "csr_wifi_hip_card.h"
+#include "csr_wifi_hip_xbv.h"
+
+#undef CSR_WIFI_IGNORE_PATCH_VERSION_MISMATCH
+
+static CsrResult do_patch_download(card_t *card, void *dlpriv,
+                                   xbv1_t *pfwinfo, CsrUint32 boot_ctrl_addr);
+
+static CsrResult do_patch_convert_download(card_t *card,
+                                           void *dlpriv, xbv1_t *pfwinfo);
+
+/*
+ * ---------------------------------------------------------------------------
+ *  _find_in_slut
+ *
+ *      Find the offset of the appropriate object in the SLUT of a card
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      psym            Pointer to symbol object.
+ *                         id set up by caller
+ *                         obj will be set up by this function
+ *      pslut           Pointer to SLUT address, if 0xffffffff then it must be
+ *                         read from the chip.
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success
+ *      Non-zero on error,
+ *      CSR_WIFI_HIP_RESULT_NOT_FOUND if not found
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult _find_in_slut(card_t *card, symbol_t *psym, CsrUint32 *pslut)
+{
+    CsrUint32 slut_address;
+    CsrUint16 finger_print;
+    CsrResult r;
+    CsrResult csrResult;
+
+    /* Get SLUT address */
+    if (*pslut == 0xffffffff)
+    {
+        r = card_wait_for_firmware_to_start(card, &slut_address);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Firmware hasn't started\n");
+            func_exit_r(r);
+            return r;
+        }
+        *pslut = slut_address;
+
+        /*
+         * Firmware has started so set the SDIO bus clock to the initial speed,
+         * faster than UNIFI_SDIO_CLOCK_SAFE_HZ, to speed up the f/w download.
+         */
+        csrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_INIT_HZ);
+        if (csrResult != CSR_RESULT_SUCCESS)
+        {
+            r = ConvertCsrSdioToCsrHipResult(card, csrResult);
+            func_exit_r(r);
+            return r;
+        }
+        card->sdio_clock_speed = UNIFI_SDIO_CLOCK_INIT_HZ;
+    }
+    else
+    {
+        slut_address = *pslut;  /* Use previously discovered address */
+    }
+    unifi_trace(card->ospriv, UDBG4, "SLUT addr: 0x%lX\n", slut_address);
+
+    /*
+     * Check the SLUT fingerprint.
+     * The slut_address is a generic pointer so we must use unifi_card_read16().
+     */
+    unifi_trace(card->ospriv, UDBG4, "Looking for SLUT finger print\n");
+    finger_print = 0;
+    r = unifi_card_read16(card, slut_address, &finger_print);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        return r;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to read SLUT finger print\n");
+        func_exit_r(r);
+        return r;
+    }
+
+    if (finger_print != SLUT_FINGERPRINT)
+    {
+        unifi_error(card->ospriv, "Failed to find SLUT fingerprint\n");
+        func_exit_r(CSR_RESULT_FAILURE);
+        return CSR_RESULT_FAILURE;
+    }
+
+    /* Symbol table starts imedately after the fingerprint */
+    slut_address += 2;
+
+    while (1)
+    {
+        CsrUint16 id;
+        CsrUint32 obj;
+
+        r = unifi_card_read16(card, slut_address, &id);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            func_exit_r(r);
+            return r;
+        }
+        slut_address += 2;
+
+        if (id == CSR_SLT_END)
+        {
+            /* End of table reached: not found */
+            r = CSR_WIFI_HIP_RESULT_RANGE;
+            break;
+        }
+
+        r = unifi_read32(card, slut_address, &obj);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            func_exit_r(r);
+            return r;
+        }
+        slut_address += 4;
+
+        unifi_trace(card->ospriv, UDBG3, "  found SLUT id %02d.%08lx\n", id, obj);
+
+        r = CSR_WIFI_HIP_RESULT_NOT_FOUND;
+        /* Found search term? */
+        if (id == psym->id)
+        {
+            unifi_trace(card->ospriv, UDBG1, " matched SLUT id %02d.%08lx\n", id, obj);
+            psym->obj = obj;
+            r = CSR_RESULT_SUCCESS;
+            break;
+        }
+    }
+
+    func_exit_r(r);
+    return r;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  do_patch_convert_download
+ *
+ *      Download the given firmware image to the UniFi, converting from FWDL
+ *      to PTDL XBV format.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      dlpriv          Pointer to source firmware image
+ *      fwinfo          Pointer to source firmware info struct
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error code on error
+ *
+ *  Notes:
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult do_patch_convert_download(card_t *card, void *dlpriv, xbv1_t *pfwinfo)
+{
+    CsrResult r;
+    CsrUint32 slut_base = 0xffffffff;
+    void *pfw;
+    CsrUint32 psize;
+    symbol_t sym;
+
+    /* Reset the chip to guarantee that the ROM loader is running */
+    r = unifi_init(card);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv,
+                    "do_patch_convert_download: failed to re-init UniFi\n");
+        return r;
+    }
+
+    /* If no unifi_helper is running, the firmware version must be read */
+    if (card->build_id == 0)
+    {
+        CsrUint32 ver = 0;
+        sym.id = CSR_SLT_BUILD_ID_NUMBER;
+        sym.obj = 0; /* To be updated by _find_in_slut() */
+
+        unifi_trace(card->ospriv, UDBG1, "Need f/w version\n");
+
+        /* Find chip build id entry in SLUT */
+        r = _find_in_slut(card, &sym, &slut_base);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to find CSR_SLT_BUILD_ID_NUMBER\n");
+            return CSR_RESULT_FAILURE;
+        }
+
+        /* Read running f/w version */
+        r = unifi_read32(card, sym.obj, &ver);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to read f/w id\n");
+            return CSR_RESULT_FAILURE;
+        }
+        card->build_id = ver;
+    }
+
+    /* Convert the ptest firmware to a patch against the running firmware */
+    pfw = xbv_to_patch(card, unifi_fw_read, dlpriv, pfwinfo, &psize);
+    if (!pfw)
+    {
+        unifi_error(card->ospriv, "Failed to convert f/w to patch");
+        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+    }
+    else
+    {
+        void *desc;
+        sym.id = CSR_SLT_BOOT_LOADER_CONTROL;
+        sym.obj = 0; /* To be updated by _find_in_slut() */
+
+        /* Find boot loader control entry in SLUT */
+        r = _find_in_slut(card, &sym, &slut_base);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to find BOOT_LOADER_CONTROL\n");
+            return CSR_RESULT_FAILURE;
+        }
+
+        r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to wake UniFi\n");
+        }
+
+        /* Get a dlpriv for the patch buffer so that unifi_fw_read() can
+         * access it.
+         */
+        desc = unifi_fw_open_buffer(card->ospriv, pfw, psize);
+        if (!desc)
+        {
+            return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+        }
+
+        /* Download the patch */
+        unifi_info(card->ospriv, "Downloading converted f/w as patch\n");
+        r = unifi_dl_patch(card, desc, sym.obj);
+        CsrMemFree(pfw);
+        unifi_fw_close_buffer(card->ospriv, desc);
+
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Converted patch download failed\n");
+            func_exit_r(r);
+            return r;
+        }
+        else
+        {
+            unifi_trace(card->ospriv, UDBG1, "Converted patch downloaded\n");
+        }
+
+        /* This command starts the firmware */
+        r = unifi_do_loader_op(card, sym.obj + 6, UNIFI_BOOT_LOADER_RESTART);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to write loader restart cmd\n");
+        }
+
+        func_exit_r(r);
+        return r;
+    }
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_dl_firmware
+ *
+ *      Download the given firmware image to the UniFi.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      dlpriv          A context pointer from the calling function to be
+ *                      passed when calling unifi_fw_read().
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success,
+ *      CSR_WIFI_HIP_RESULT_NO_MEMORY         memory allocation failed
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE         error in XBV file
+ *      CSR_RESULT_FAILURE            SDIO error
+ *
+ *  Notes:
+ *      Stops and resets the chip, does the download and runs the new
+ *      firmware.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_dl_firmware(card_t *card, void *dlpriv)
+{
+    xbv1_t *fwinfo;
+    CsrResult r;
+
+    func_enter();
+
+    fwinfo = CsrMemAlloc(sizeof(xbv1_t));
+    if (fwinfo == NULL)
+    {
+        unifi_error(card->ospriv, "Failed to allocate memory for firmware\n");
+        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+    }
+
+    /*
+     * Scan the firmware file to find the TLVs we are interested in.
+     * These are:
+     *   - check we support the file format version in VERF
+     *   - SLTP Symbol Lookup Table Pointer
+     *   - FWDL firmware download segments
+     *   - FWOV firmware overlay segment
+     *   - VMEQ Register probe tests to verify matching h/w
+     */
+    r = xbv1_parse(card, unifi_fw_read, dlpriv, fwinfo);
+    if (r != CSR_RESULT_SUCCESS || fwinfo->mode != xbv_firmware)
+    {
+        unifi_error(card->ospriv, "File type is %s, expected firmware.\n",
+                    fwinfo->mode == xbv_patch?"patch" : "unknown");
+        CsrMemFree(fwinfo);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    /* UF6xxx doesn't accept firmware, only patches. Therefore we convert
+     * the file to patch format with version numbers matching the current
+     * running firmware, and then download via the patch mechanism.
+     * The sole purpose of this is to support production test firmware across
+     * different ROM releases, the test firmware being provided in non-patch
+     * format.
+     */
+    if (card->chip_id > SDIO_CARD_ID_UNIFI_2)
+    {
+        unifi_info(card->ospriv, "Must convert f/w to patch format\n");
+        r = do_patch_convert_download(card, dlpriv, fwinfo);
+    }
+    else
+    {
+        /* Older UniFi chips allowed firmware to be directly loaded onto the
+         * chip, which is no longer supported.
+         */
+        unifi_error(card->ospriv, "Only patch downloading supported\n");
+        r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    CsrMemFree(fwinfo);
+    func_exit_r(r);
+    return r;
+} /* unifi_dl_firmware() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_dl_patch
+ *
+ *      Load the given patch set into UniFi.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      dlpriv          The os specific handle to the firmware file.
+ *      boot_ctrl       The address of the boot loader control structure.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success,
+ *      CSR_WIFI_HIP_RESULT_NO_MEMORY         memory allocation failed
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE         error in XBV file
+ *      CSR_RESULT_FAILURE            SDIO error
+ *
+ *  Notes:
+ *      This ends up telling UniFi to restart.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_dl_patch(card_t *card, void *dlpriv, CsrUint32 boot_ctrl)
+{
+    xbv1_t *fwinfo;
+    CsrResult r;
+
+    func_enter();
+
+    unifi_info(card->ospriv, "unifi_dl_patch %p %08x\n", dlpriv, boot_ctrl);
+
+    fwinfo = CsrMemAlloc(sizeof(xbv1_t));
+    if (fwinfo == NULL)
+    {
+        unifi_error(card->ospriv, "Failed to allocate memory for patches\n");
+        func_exit();
+        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+    }
+
+    /*
+     * Scan the firmware file to find the TLVs we are interested in.
+     * These are:
+     *   - check we support the file format version in VERF
+     *   - FWID The build ID of the ROM that we can patch
+     *   - PTDL patch download segments
+     */
+    r = xbv1_parse(card, unifi_fw_read, dlpriv, fwinfo);
+    if (r != CSR_RESULT_SUCCESS || fwinfo->mode != xbv_patch)
+    {
+        CsrMemFree(fwinfo);
+        unifi_error(card->ospriv, "Failed to read in patch file\n");
+        func_exit();
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    /*
+     * We have to check the build id read from the SLUT against that
+     * for the patch file.  They have to match exactly.
+     *    "card->build_id" == XBV1.PTCH.FWID
+     */
+    if (card->build_id != fwinfo->build_id)
+    {
+        unifi_error(card->ospriv, "Wrong patch file for chip (chip = %lu, file = %lu)\n",
+                    card->build_id, fwinfo->build_id);
+        CsrMemFree(fwinfo);
+#ifndef CSR_WIFI_IGNORE_PATCH_VERSION_MISMATCH
+        func_exit();
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+#else
+        fwinfo = NULL;
+        dlpriv = NULL;
+        return CSR_RESULT_SUCCESS;
+#endif
+    }
+
+    r = do_patch_download(card, dlpriv, fwinfo, boot_ctrl);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to patch image\n");
+    }
+
+    CsrMemFree(fwinfo);
+
+    func_exit_r(r);
+    return r;
+} /* unifi_dl_patch() */
+
+
+void* unifi_dl_fw_read_start(card_t *card, CsrInt8 is_fw)
+{
+    card_info_t card_info;
+
+    unifi_card_info(card, &card_info);
+    unifi_trace(card->ospriv, UDBG5,
+                "id=%d, ver=0x%x, fw_build=%u, fw_hip=0x%x, block_size=%d\n",
+                card_info.chip_id, card_info.chip_version,
+                card_info.fw_build, card_info.fw_hip_version,
+                card_info.sdio_block_size);
+
+    return unifi_fw_read_start(card->ospriv, is_fw, &card_info);
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  safe_read_shared_location
+ *
+ *      Read a shared memory location repeatedly until we get two readings
+ *      the same.
+ *
+ *  Arguments:
+ *      card            Pointer to card context struct.
+ *      unifi_addr      UniFi shared-data-memory address to access.
+ *      pdata           Pointer to a byte variable for the value read.
+ *
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error code on failure
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult safe_read_shared_location(card_t *card, CsrUint32 address, CsrUint8 *pdata)
+{
+    CsrResult r;
+    CsrUint16 limit = 1000;
+    CsrUint8 b, b2;
+
+    *pdata = 0;
+
+    r = unifi_read_8_or_16(card, address, &b);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        return r;
+    }
+
+    while (limit--)
+    {
+        r = unifi_read_8_or_16(card, address, &b2);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            return r;
+        }
+
+        /* When we have a stable value, return it */
+        if (b == b2)
+        {
+            *pdata = b;
+            return CSR_RESULT_SUCCESS;
+        }
+
+        b = b2;
+    }
+
+    return CSR_RESULT_FAILURE;
+} /* safe_read_shared_location() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_do_loader_op
+ *
+ *      Send a loader / boot_loader command to the UniFi and wait for
+ *      it to complete.
+ *
+ *  Arguments:
+ *      card            Pointer to card context struct.
+ *      op_addr         The address of the loader operation control word.
+ *      opcode          The operation to perform.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS    on success
+ *      CSR_RESULT_FAILURE    SDIO error or SDIO/XAP timeout
+ * ---------------------------------------------------------------------------
+ */
+
+/*
+ * Ideally instead of sleeping, we want to busy wait.
+ * Currently there is no framework API to do this. When it becomes available,
+ * we can use it to busy wait using usecs
+ */
+#define OPERATION_TIMEOUT_LOOPS (100)  /* when OPERATION_TIMEOUT_DELAY==1, (500) otherwise */
+#define OPERATION_TIMEOUT_DELAY 1      /* msec, or 200usecs */
+
+CsrResult unifi_do_loader_op(card_t *card, CsrUint32 op_addr, CsrUint8 opcode)
+{
+    CsrResult r;
+    CsrInt16 op_retries;
+
+    unifi_trace(card->ospriv, UDBG4, "Loader cmd 0x%0x -> 0x%08x\n", opcode, op_addr);
+
+    /* Set the Operation command byte to the opcode */
+    r = unifi_write_8_or_16(card, op_addr, opcode);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to write loader copy command\n");
+        return r;
+    }
+
+    /* Wait for Operation command byte to be Idle */
+    /* Typically takes ~100us */
+    op_retries = 0;
+    r = CSR_RESULT_SUCCESS;
+    while (1)
+    {
+        CsrUint8 op;
+
+        /*
+         * Read the memory location until two successive reads give
+         * the same value.
+         * Then handle it.
+         */
+        r = safe_read_shared_location(card, op_addr, &op);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Failed to read loader status\n");
+            break;
+        }
+
+        if (op == UNIFI_LOADER_IDLE)
+        {
+            /* Success */
+            break;
+        }
+
+        if (op != opcode)
+        {
+            unifi_error(card->ospriv, "Error reported by loader: 0x%X\n", op);
+            r = CSR_RESULT_FAILURE;
+            break;
+        }
+
+        /* Allow 500us timeout */
+        if (++op_retries >= OPERATION_TIMEOUT_LOOPS)
+        {
+            unifi_error(card->ospriv, "Timeout waiting for loader to ack transfer\n");
+            /* Stop XAPs to aid post-mortem */
+            r = unifi_card_stop_processor(card, UNIFI_PROC_BOTH);
+            if (r != CSR_RESULT_SUCCESS)
+            {
+                unifi_error(card->ospriv, "Failed to stop UniFi processors\n");
+            }
+            else
+            {
+                r = CSR_RESULT_FAILURE;
+            }
+            break;
+        }
+        CsrThreadSleep(OPERATION_TIMEOUT_DELAY);
+    } /* Loop exits with r != CSR_RESULT_SUCCESS on error */
+
+    return r;
+}     /* unifi_do_loader_op() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  send_ptdl_to_unifi
+ *
+ *      Copy a patch block from userland to the UniFi.
+ *      This function reads data, 2K at a time, from userland and writes
+ *      it to the UniFi.
+ *
+ *  Arguments:
+ *      card            A pointer to the card structure
+ *      dlpriv          The os specific handle for the firmware file
+ *      ptdl            A pointer ot the PTDL block
+ *      handle          The buffer handle to use for the xfer
+ *      op_addr         The address of the loader operation control word
+ *
+ *  Returns:
+ *      Number of bytes sent (Positive) or negative value indicating
+ *      error code:
+ *      CSR_WIFI_HIP_RESULT_NO_MEMORY         memory allocation failed
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE         error in XBV file
+ *      CSR_RESULT_FAILURE            SDIO error
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult send_ptdl_to_unifi(card_t *card, void *dlpriv,
+                                    const struct PTDL *ptdl, CsrUint32 handle,
+                                    CsrUint32 op_addr)
+{
+    CsrUint32 offset;
+    CsrUint8 *buf;
+    CsrInt32 data_len;
+    CsrUint32 write_len;
+    CsrResult r;
+    const CsrUint16 buf_size = 2 * 1024;
+
+    offset = ptdl->dl_offset;
+    data_len = ptdl->dl_size;
+
+    if (data_len > buf_size)
+    {
+        unifi_error(card->ospriv, "PTDL block is too large (%u)\n",
+                    ptdl->dl_size);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    buf = CsrMemAlloc(buf_size);
+    if (buf == NULL)
+    {
+        unifi_error(card->ospriv, "Failed to allocate transfer buffer for firmware download\n");
+        return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+    }
+
+    r = CSR_RESULT_SUCCESS;
+
+    if (unifi_fw_read(card->ospriv, dlpriv, offset, buf, data_len) != data_len)
+    {
+        unifi_error(card->ospriv, "Failed to read from file\n");
+    }
+    else
+    {
+        /* We can always round these if the host wants to */
+        if (card->sdio_io_block_pad)
+        {
+            write_len = (data_len + (card->sdio_io_block_size - 1)) &
+                        ~(card->sdio_io_block_size - 1);
+
+            /* Zero out the rest of the buffer (This isn't needed, but it
+             * makes debugging things later much easier). */
+            CsrMemSet(buf + data_len, 0, write_len - data_len);
+        }
+        else
+        {
+            write_len = data_len;
+        }
+
+        r = unifi_bulk_rw_noretry(card, handle, buf, write_len, UNIFI_SDIO_WRITE);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "CMD53 failed writing %d bytes to handle %ld\n",
+                        data_len, handle);
+        }
+        else
+        {
+            /*
+             * Can change the order of things to overlap read from file
+             * with copy to unifi
+             */
+            r = unifi_do_loader_op(card, op_addr, UNIFI_BOOT_LOADER_PATCH);
+        }
+    }
+
+    CsrMemFree(buf);
+
+    if (r != CSR_RESULT_SUCCESS && r != CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        unifi_error(card->ospriv, "Failed to copy block of %u bytes to UniFi\n",
+                    ptdl->dl_size);
+    }
+
+    return r;
+} /* send_ptdl_to_unifi() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  do_patch_download
+ *
+ *      This function downloads a set of patches to UniFi and then
+ *      causes it to restart.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct.
+ *      dlpriv          A context pointer from the calling function to be
+ *                      used when reading the XBV file.  This can be NULL
+ *                      in which case not patches are applied.
+ *      pfwinfo         Pointer to a fwinfo struct describing the f/w
+ *                      XBV file.
+ *      boot_ctrl_addr  The address of the boot loader control structure.
+ *
+ *  Returns:
+ *      0 on success, or an error code
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE for a bad laoader version number
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult do_patch_download(card_t *card, void *dlpriv, xbv1_t *pfwinfo, CsrUint32 boot_ctrl_addr)
+{
+    CsrResult r;
+    CsrInt32 i;
+    CsrUint16 loader_version;
+    CsrUint16 handle;
+    CsrUint32 total_bytes;
+
+    /*
+     * Read info from the SDIO Loader Control Data Structure
+     */
+    /* Check the loader version */
+    r = unifi_card_read16(card, boot_ctrl_addr, &loader_version);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Patch download: Failed to read loader version\n");
+        return r;
+    }
+    unifi_trace(card->ospriv, UDBG2, "Patch download: boot loader version 0x%04X\n", loader_version);
+    switch (loader_version)
+    {
+        case 0x0000:
+            break;
+
+        default:
+            unifi_error(card->ospriv, "Patch loader version (0x%04X) is not supported by this driver\n",
+                        loader_version);
+            return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    /* Retrieve the handle to use with CMD53 */
+    r = unifi_card_read16(card, boot_ctrl_addr + 4, &handle);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Patch download: Failed to read loader handle\n");
+        return r;
+    }
+
+    /* Set the mask of LEDs to flash */
+    if (card->loader_led_mask)
+    {
+        r = unifi_card_write16(card, boot_ctrl_addr + 2,
+                               (CsrUint16)card->loader_led_mask);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Patch download: Failed to write LED mask\n");
+            return r;
+        }
+    }
+
+    total_bytes = 0;
+
+    /* Copy download data to UniFi memory */
+    for (i = 0; i < pfwinfo->num_ptdl; i++)
+    {
+        unifi_trace(card->ospriv, UDBG3, "Patch download: %d Downloading for %d from offset %d\n",
+                    i,
+                    pfwinfo->ptdl[i].dl_size,
+                    pfwinfo->ptdl[i].dl_offset);
+
+        r = send_ptdl_to_unifi(card, dlpriv, &pfwinfo->ptdl[i],
+                               handle, boot_ctrl_addr + 6);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            return r;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Patch failed after %u bytes\n",
+                        total_bytes);
+            return r;
+        }
+        total_bytes += pfwinfo->ptdl[i].dl_size;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* do_patch_download() */
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_dump.c
@@ -0,0 +1,872 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ * FILE: csr_wifi_hip_dump.c
+ *
+ * PURPOSE:
+ *      Routines for retrieving and buffering core status from the UniFi
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_unifiversion.h"
+#include "csr_wifi_hip_card.h"
+
+/* Locations to capture in dump (XAP words) */
+#define HIP_CDUMP_FIRST_CPUREG      (0xFFE0) /* First CPU register */
+#define HIP_CDUMP_FIRST_LO          (0)      /* Start of low address range */
+#define HIP_CDUMP_FIRST_HI_MAC      (0x3C00) /* Start of MAC high area */
+#define HIP_CDUMP_FIRST_HI_PHY      (0x1C00) /* Start of PHY high area */
+#define HIP_CDUMP_FIRST_SH          (0)      /* Start of shared memory area */
+
+#define HIP_CDUMP_NCPUREGS    (10)           /* No. of 16-bit XAP registers */
+#define HIP_CDUMP_NWORDS_LO   (0x0100)       /* Low area size in 16-bit words */
+#define HIP_CDUMP_NWORDS_HI   (0x0400)       /* High area size in 16-bit words */
+#define HIP_CDUMP_NWORDS_SH   (0x0500)       /* Shared memory area size, 16-bit words */
+
+#define HIP_CDUMP_NUM_ZONES 7                /* Number of UniFi memory areas to capture */
+
+/* Mini-coredump state */
+typedef struct coredump_buf
+{
+    CsrUint16  count;                       /* serial number of dump */
+    CsrTime    timestamp;                   /* host's system time at capture */
+    CsrInt16   requestor;                   /* request: 0=auto dump, 1=manual */
+    CsrUint16  chip_ver;
+    CsrUint32  fw_ver;
+    CsrUint16 *zone[HIP_CDUMP_NUM_ZONES];
+
+    struct coredump_buf *next;              /* circular list */
+    struct coredump_buf *prev;              /* circular list */
+} coredump_buffer;
+
+/* Structure used to describe a zone of chip memory captured by mini-coredump */
+struct coredump_zone
+{
+    unifi_coredump_space_t           space;  /* XAP memory space this zone covers */
+    enum unifi_dbg_processors_select cpu;    /* XAP CPU core selector */
+    CsrUint32                        gp;     /* Generic Pointer to memory zone on XAP */
+    CsrUint16                        offset; /* 16-bit XAP word offset of zone in memory space */
+    CsrUint16                        length; /* Length of zone in XAP words */
+};
+
+static CsrResult unifi_coredump_from_sdio(card_t *card, coredump_buffer *dump_buf);
+static CsrResult unifi_coredump_read_zones(card_t *card, coredump_buffer *dump_buf);
+static CsrResult unifi_coredump_read_zone(card_t *card, CsrUint16 *zone,
+                                          const struct coredump_zone *def);
+static CsrInt32 get_value_from_coredump(const coredump_buffer *dump,
+                                        const unifi_coredump_space_t space, const CsrUint16 offset);
+
+/* Table of chip memory zones we capture on mini-coredump */
+static const struct coredump_zone zonedef_table[HIP_CDUMP_NUM_ZONES] = {
+    { UNIFI_COREDUMP_MAC_REG,  UNIFI_PROC_MAC, UNIFI_MAKE_GP(REGISTERS, HIP_CDUMP_FIRST_CPUREG * 2), HIP_CDUMP_FIRST_CPUREG, HIP_CDUMP_NCPUREGS },
+    { UNIFI_COREDUMP_PHY_REG,  UNIFI_PROC_PHY, UNIFI_MAKE_GP(REGISTERS, HIP_CDUMP_FIRST_CPUREG * 2), HIP_CDUMP_FIRST_CPUREG, HIP_CDUMP_NCPUREGS },
+    { UNIFI_COREDUMP_SH_DMEM,  UNIFI_PROC_INVALID, UNIFI_MAKE_GP(SH_DMEM, HIP_CDUMP_FIRST_SH * 2),   HIP_CDUMP_FIRST_SH,     HIP_CDUMP_NWORDS_SH },
+    { UNIFI_COREDUMP_MAC_DMEM, UNIFI_PROC_MAC, UNIFI_MAKE_GP(MAC_DMEM, HIP_CDUMP_FIRST_LO * 2),      HIP_CDUMP_FIRST_LO,     HIP_CDUMP_NWORDS_LO },
+    { UNIFI_COREDUMP_MAC_DMEM, UNIFI_PROC_MAC, UNIFI_MAKE_GP(MAC_DMEM, HIP_CDUMP_FIRST_HI_MAC * 2),  HIP_CDUMP_FIRST_HI_MAC, HIP_CDUMP_NWORDS_HI },
+    { UNIFI_COREDUMP_PHY_DMEM, UNIFI_PROC_PHY, UNIFI_MAKE_GP(PHY_DMEM, HIP_CDUMP_FIRST_LO * 2),      HIP_CDUMP_FIRST_LO,     HIP_CDUMP_NWORDS_LO },
+    { UNIFI_COREDUMP_PHY_DMEM, UNIFI_PROC_PHY, UNIFI_MAKE_GP(PHY_DMEM, HIP_CDUMP_FIRST_HI_PHY * 2),  HIP_CDUMP_FIRST_HI_PHY, HIP_CDUMP_NWORDS_HI },
+};
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_coredump_request_at_next_reset
+ *
+ *      Request that a mini-coredump is performed when the driver has
+ *      completed resetting the UniFi device.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      enable          If non-zero, sets the request.
+ *                      If zero, cancels any pending request.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS or CSR HIP error code
+ *
+ *  Notes:
+ *      This function is typically called once the driver has detected that
+ *      the UniFi device has become unresponsive due to crash, or internal
+ *      watchdog reset. The driver must reset it to regain communication and,
+ *      immediately after that, the mini-coredump can be captured.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_coredump_request_at_next_reset(card_t *card, CsrInt8 enable)
+{
+    CsrResult r;
+
+    func_enter();
+
+    if (enable)
+    {
+        unifi_trace(card->ospriv, UDBG2, "Mini-coredump requested after reset\n");
+    }
+
+    if (card == NULL)
+    {
+        r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+    else
+    {
+        card->request_coredump_on_reset = enable?1 : 0;
+        r = CSR_RESULT_SUCCESS;
+    }
+
+    func_exit_r(r);
+    return r;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_coredump_handle_request
+ *
+ *      Performs a coredump now, if one was requested, and clears the request.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS or CSR HIP error code
+ *
+ *  Notes:
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_coredump_handle_request(card_t *card)
+{
+    CsrResult r = CSR_RESULT_SUCCESS;
+
+    func_enter();
+
+    if (card == NULL)
+    {
+        r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+    else
+    {
+        if (card->request_coredump_on_reset == 1)
+        {
+            card->request_coredump_on_reset = 0;
+            r = unifi_coredump_capture(card, NULL);
+        }
+    }
+
+    func_exit_r(r);
+    return r;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_coredump_capture
+ *
+ *      Capture the current status of the UniFi device.
+ *      Various registers are buffered for future offline inspection.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      req             Pointer to request struct, or NULL:
+ *                          A coredump requested manually by the user app
+ *                          will have a request struct pointer, an automatic
+ *                          coredump will have a NULL pointer.
+ *  Returns:
+ *      CSR_RESULT_SUCCESS  on success,
+ *      CSR_RESULT_FAILURE  SDIO error
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE  Initialisation not complete
+ *
+ *  Notes:
+ *      The result is a filled entry in the circular buffer of core dumps,
+ *      values from which can be extracted to userland via an ioctl.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_coredump_capture(card_t *card, struct unifi_coredump_req *req)
+{
+    CsrResult r = CSR_RESULT_SUCCESS;
+    static CsrUint16 dump_seq_no = 1;
+    CsrTime time_of_capture;
+
+    func_enter();
+
+    if (card->dump_next_write == NULL)
+    {
+        r = CSR_RESULT_SUCCESS;
+        goto done;
+    }
+
+    /* Reject forced capture before initialisation has happened */
+    if (card->helper == NULL)
+    {
+        r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+        goto done;
+    }
+
+
+    /*
+     * Force a mini-coredump capture right now
+     */
+    time_of_capture = CsrTimeGet(NULL);
+    unifi_info(card->ospriv, "Mini-coredump capture at t=%u\n", time_of_capture);
+
+    /* Wake up the processors so we can talk to them */
+    r = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to wake UniFi\n");
+        goto done;
+    }
+    CsrThreadSleep(20);
+
+    /* Stop both XAPs */
+    unifi_trace(card->ospriv, UDBG4, "Stopping XAPs for coredump capture\n");
+    r = unifi_card_stop_processor(card, UNIFI_PROC_BOTH);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to stop UniFi XAPs\n");
+        goto done;
+    }
+
+    /* Dump core into the next available slot in the circular list */
+    r = unifi_coredump_from_sdio(card, card->dump_next_write);
+    if (r == CSR_RESULT_SUCCESS)
+    {
+        /* Record whether the dump was manual or automatic */
+        card->dump_next_write->requestor = (req?1 : 0);
+        card->dump_next_write->timestamp = time_of_capture;
+        /* Advance to the next buffer */
+        card->dump_next_write->count = dump_seq_no++;
+        card->dump_cur_read = card->dump_next_write;
+        card->dump_next_write = card->dump_next_write->next;
+
+        /* Sequence no. of zero indicates slot not in use, so handle wrap */
+        if (dump_seq_no == 0)
+        {
+            dump_seq_no = 1;
+        }
+
+        unifi_trace(card->ospriv, UDBG3,
+                    "Coredump (%p), SeqNo=%d, cur_read=%p, next_write=%p\n",
+                    req,
+                    card->dump_cur_read->count,
+                    card->dump_cur_read, card->dump_next_write);
+    }
+
+    /* Start both XAPs */
+    unifi_trace(card->ospriv, UDBG4, "Restart XAPs after coredump\n");
+    r = card_start_processor(card, UNIFI_PROC_BOTH);
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Failed to start UniFi XAPs\n");
+        goto done;
+    }
+
+done:
+    func_exit_r(r);
+    return r;
+} /* unifi_coredump_capture() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  get_value_from_coredump
+ *
+ *
+ *
+ *  Arguments:
+ *      dump                Pointer to buffered coredump data
+ *      offset_in_space     XAP memory space to retrieve from the buffer (there
+ *                          may be more than one zone covering the same memory
+ *                          space, but starting from different offsets).
+ *      offset              Offset within the XAP memory space to be retrieved
+ *
+ *  Returns:
+ *      >=0                  Register value on success
+ *      <0                   Register out of range of any captured zones
+ *
+ *  Notes:
+ * ---------------------------------------------------------------------------
+ */
+static CsrInt32 get_value_from_coredump(const coredump_buffer       *dump,
+                                        const unifi_coredump_space_t space,
+                                        const CsrUint16              offset_in_space)
+{
+    CsrInt32 r = -1;
+    CsrUint16 offset_in_zone;
+    CsrUint32 zone_end_offset;
+    CsrInt32 i;
+    const struct coredump_zone *def = &zonedef_table[0];
+
+    /* Search zone def table for a match with the requested memory space */
+    for (i = 0; i < HIP_CDUMP_NUM_ZONES; i++, def++)
+    {
+        if (space == def->space)
+        {
+            zone_end_offset = def->offset + def->length;
+
+            /* Is the space offset contained in this zone? */
+            if (offset_in_space < zone_end_offset &&
+                offset_in_space >= def->offset)
+            {
+                /* Calculate the offset of data within the zone buffer */
+                offset_in_zone = offset_in_space - def->offset;
+                r = (CsrInt32) * (dump->zone[i] + offset_in_zone);
+
+                unifi_trace(NULL, UDBG6,
+                            "sp %d, offs 0x%04x = 0x%04x (in z%d 0x%04x->0x%04x)\n",
+                            space, offset_in_space, r,
+                            i, def->offset, zone_end_offset - 1);
+                break;
+            }
+        }
+    }
+    return r;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_coredump_get_value
+ *
+ *      Retrieve the value of a register buffered from a previous core dump,
+ *      so that it may be reported back to application code.
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      req_reg         Pointer to request parameter partially filled. This
+ *                      function puts in the values retrieved from the dump.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, or:
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE         Null parameter error
+ *      CSR_WIFI_HIP_RESULT_RANGE                 Register out of range
+ *      CSR_WIFI_HIP_RESULT_NOT_FOUND             Dump index not (yet) captured
+ *
+ *  Notes:
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_coredump_get_value(card_t *card, struct unifi_coredump_req *req)
+{
+    CsrResult r;
+    CsrInt32 i = 0;
+    coredump_buffer *find_dump = NULL;
+
+    func_enter();
+
+    if (req == NULL || card == NULL)
+    {
+        r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+        goto done;
+    }
+    req->value = -1;
+    if (card->dump_buf == NULL)
+    {
+        unifi_trace(card->ospriv, UDBG2, "No coredump buffers\n");
+        r = CSR_WIFI_HIP_RESULT_NOT_FOUND;     /* Coredumping disabled */
+        goto done;
+    }
+    if (card->dump_cur_read == NULL)
+    {
+        unifi_trace(card->ospriv, UDBG4, "No coredumps captured\n");
+        r = CSR_WIFI_HIP_RESULT_NOT_FOUND;     /* No coredump yet captured */
+        goto done;
+    }
+
+    /* Find the requested dump buffer */
+    switch (req->index)
+    {
+        case 0:     /* Newest */
+            find_dump = card->dump_cur_read;
+            break;
+        case -1:    /* Oldest: The next used slot forward */
+            for (find_dump = card->dump_cur_read->next;
+                 (find_dump->count == 0) && (find_dump != card->dump_cur_read);
+                 find_dump = card->dump_cur_read->next)
+            {
+            }
+            break;
+        default:    /* Number of steps back from current read position */
+            for (i = 0, find_dump = card->dump_cur_read;
+                 i < req->index;
+                 i++, find_dump = find_dump->prev)
+            {
+                /* Walk the list for the index'th entry, but
+                 * stop when about to wrap. */
+                unifi_trace(card->ospriv, UDBG6,
+                            "%d: %d, @%p, p=%p, n=%p, cr=%p, h=%p\n",
+                            i, find_dump->count, find_dump, find_dump->prev,
+                            find_dump->next, card->dump_cur_read, card->dump_buf);
+                if (find_dump->prev == card->dump_cur_read)
+                {
+                    /* Wrapped but still not found, index out of range */
+                    if (i != req->index)
+                    {
+                        unifi_trace(card->ospriv, UDBG6,
+                                    "Dump index %d not found %d\n", req->index, i);
+                        r = CSR_WIFI_HIP_RESULT_NOT_FOUND;
+                        goto done;
+                    }
+                    break;
+                }
+            }
+            break;
+    }
+
+    /* Check if the slot is actually filled with a core dump */
+    if (find_dump->count == 0)
+    {
+        unifi_trace(card->ospriv, UDBG4, "Not captured %d\n", req->index);
+        r = CSR_WIFI_HIP_RESULT_NOT_FOUND;
+        goto done;
+    }
+
+    unifi_trace(card->ospriv, UDBG6, "Req index %d, found seq %d at step %d\n",
+                req->index, find_dump->count, i);
+
+    /* Find the appropriate entry in the buffer */
+    req->value = get_value_from_coredump(find_dump, req->space, (CsrUint16)req->offset);
+    if (req->value < 0)
+    {
+        r = CSR_WIFI_HIP_RESULT_RANGE;     /* Un-captured register */
+        unifi_trace(card->ospriv, UDBG4,
+                    "Can't read space %d, reg 0x%x from coredump buffer %d\n",
+                    req->space, req->offset, req->index);
+    }
+    else
+    {
+        r = CSR_RESULT_SUCCESS;
+    }
+
+    /* Update the private request structure with the found values */
+    req->chip_ver = find_dump->chip_ver;
+    req->fw_ver = find_dump->fw_ver;
+    req->timestamp = find_dump->timestamp;
+    req->requestor = find_dump->requestor;
+    req->serial = find_dump->count;
+
+done:
+    func_exit_r(r);
+    return r;
+} /* unifi_coredump_get_value() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_coredump_read_zone
+ *
+ *      Captures a UniFi memory zone into a buffer on the host
+ *
+ *  Arguments:
+ *      card          Pointer to card struct
+ *      zonebuf       Pointer to on-host buffer to dump the memory zone into
+ *      def           Pointer to description of the memory zone to read from UniFi.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS                   on success, or:
+ *      CSR_RESULT_FAILURE                   SDIO error
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE         Parameter error
+ *
+ *  Notes:
+ *      It is assumed that the caller has already stopped the XAPs
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult unifi_coredump_read_zone(card_t *card, CsrUint16 *zonebuf, const struct coredump_zone *def)
+{
+    CsrResult r;
+
+    func_enter();
+
+    if (zonebuf == NULL || def == NULL)
+    {
+        r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+        goto done;
+    }
+
+    /* Select XAP CPU if necessary */
+    if (def->cpu != UNIFI_PROC_INVALID)
+    {
+        if (def->cpu != UNIFI_PROC_MAC && def->cpu != UNIFI_PROC_PHY)
+        {
+            r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            goto done;
+        }
+        r = unifi_set_proc_select(card, def->cpu);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            goto done;
+        }
+    }
+
+    unifi_trace(card->ospriv, UDBG4,
+                "Dump sp %d, offs 0x%04x, 0x%04x words @GP=%08x CPU %d\n",
+                def->space, def->offset, def->length, def->gp, def->cpu);
+
+    /* Read on-chip RAM (byte-wise) */
+    r = unifi_card_readn(card, def->gp, zonebuf, (CsrUint16)(def->length * 2));
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        goto done;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Can't read UniFi shared data area\n");
+        goto done;
+    }
+
+done:
+    func_exit_r(r);
+    return r;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_coredump_read_zones
+ *
+ *      Walks through the table of on-chip memory zones defined in zonedef_table,
+ *      and reads each of them from the UniFi chip
+ *
+ *  Arguments:
+ *      card          Pointer to card struct
+ *      dump_buf      Buffer into which register values will be dumped
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS                   on success, or:
+ *      CSR_RESULT_FAILURE                   SDIO error
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE         Parameter error
+ *
+ *  Notes:
+ *      It is assumed that the caller has already stopped the XAPs
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult unifi_coredump_read_zones(card_t *card, coredump_buffer *dump_buf)
+{
+    CsrResult r = CSR_RESULT_SUCCESS;
+    CsrInt32 i;
+
+    func_enter();
+
+    /* Walk the table of coredump zone definitions and read them from the chip */
+    for (i = 0;
+         (i < HIP_CDUMP_NUM_ZONES) && (r == 0);
+         i++)
+    {
+        r = unifi_coredump_read_zone(card, dump_buf->zone[i], &zonedef_table[i]);
+    }
+
+    func_exit_r(r);
+    return r;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_coredump_from_sdio
+ *
+ *      Capture the status of the UniFi processors, over SDIO
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *      reg_buffer      Buffer into which register values will be dumped
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS                   on success, or:
+ *      CSR_RESULT_FAILURE                   SDIO error
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE         Parameter error
+ *
+ *  Notes:
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult unifi_coredump_from_sdio(card_t *card, coredump_buffer *dump_buf)
+{
+    CsrUint16 val;
+    CsrResult r;
+    CsrUint32 sdio_addr;
+
+    func_enter();
+
+    if (dump_buf == NULL)
+    {
+        r = CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+        goto done;
+    }
+
+
+    /* Chip and firmware version */
+    unifi_trace(card->ospriv, UDBG4, "Get chip version\n");
+    sdio_addr = 2 * ChipHelper_GBL_CHIP_VERSION(card->helper);
+    if (sdio_addr != 0)
+    {
+        r = unifi_read_direct16(card, sdio_addr, &val);
+        if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+        {
+            goto done;
+        }
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "Can't read GBL_CHIP_VERSION\n");
+            goto done;
+        }
+    }
+    dump_buf->chip_ver = val;
+    dump_buf->fw_ver = card->build_id;
+
+    unifi_trace(card->ospriv, UDBG4, "chip_ver 0x%04x, fw_ver %u\n",
+                dump_buf->chip_ver, dump_buf->fw_ver);
+
+    /* Capture the memory zones required from UniFi */
+    r = unifi_coredump_read_zones(card, dump_buf);
+    if (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)
+    {
+        goto done;
+    }
+    if (r != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(card->ospriv, "Can't read UniFi memory areas\n");
+        goto done;
+    }
+
+done:
+    func_exit_r(r);
+    return r;
+} /* unifi_coredump_from_sdio() */
+
+
+#ifndef UNIFI_DISABLE_COREDUMP
+/*
+ * ---------------------------------------------------------------------------
+ *  new_coredump_node
+ *
+ *      Allocates a coredump linked-list node, and links it to the previous.
+ *
+ *  Arguments:
+ *      ospriv          OS context
+ *      prevnode        Previous node to link into
+ *
+ *  Returns:
+ *      Pointer to valid coredump_buffer on success
+ *      NULL on memory allocation failure
+ *
+ *  Notes:
+ *      Allocates "all or nothing"
+ * ---------------------------------------------------------------------------
+ */
+static
+coredump_buffer* new_coredump_node(void *ospriv, coredump_buffer *prevnode)
+{
+    coredump_buffer *newnode = NULL;
+    CsrUint16 *newzone = NULL;
+    CsrInt32 i;
+    CsrUint32 zone_size;
+
+    /* Allocate node header */
+    newnode = (coredump_buffer *)CsrMemAlloc(sizeof(coredump_buffer));
+    if (newnode == NULL)
+    {
+        return NULL;
+    }
+    CsrMemSet(newnode, 0, sizeof(coredump_buffer));
+
+    /* Allocate chip memory zone capture buffers */
+    for (i = 0; i < HIP_CDUMP_NUM_ZONES; i++)
+    {
+        zone_size = sizeof(CsrUint16) * zonedef_table[i].length;
+        newzone = (CsrUint16 *)CsrMemAlloc(zone_size);
+        newnode->zone[i] = newzone;
+        if (newzone != NULL)
+        {
+            CsrMemSet(newzone, 0, zone_size);
+        }
+        else
+        {
+            unifi_error(ospriv, "Out of memory on coredump zone %d (%d words)\n",
+                        i, zonedef_table[i].length);
+            break;
+        }
+    }
+
+    /* Clean up if any zone alloc failed */
+    if (newzone == NULL)
+    {
+        for (i = 0; newnode->zone[i] != NULL; i++)
+        {
+            CsrMemFree(newnode->zone[i]);
+            newnode->zone[i] = NULL;
+        }
+    }
+
+    /* Link to previous node */
+    newnode->prev = prevnode;
+    if (prevnode)
+    {
+        prevnode->next = newnode;
+    }
+    newnode->next = NULL;
+
+    return newnode;
+}
+
+
+#endif /* UNIFI_DISABLE_COREDUMP */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_coredump_init
+ *
+ *      Allocates buffers for the automatic SDIO core dump
+ *
+ *  Arguments:
+ *      card                Pointer to card struct
+ *      num_dump_buffers    Number of buffers to reserve for coredumps
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS               on success, or:
+ *      CSR_WIFI_HIP_RESULT_NO_MEMORY         memory allocation failed
+ *
+ *  Notes:
+ *      Allocates space in advance, to be used for the last n coredump buffers
+ *      the intention being that the size is sufficient for at least one dump,
+ *      probably several.
+ *      It's probably advisable to have at least 2 coredump buffers to allow
+ *      one to be enquired with the unifi_coredump tool, while leaving another
+ *      free for capturing.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_coredump_init(card_t *card, CsrUint16 num_dump_buffers)
+{
+#ifndef UNIFI_DISABLE_COREDUMP
+    void *ospriv = card->ospriv;
+    coredump_buffer *prev = NULL;
+    coredump_buffer *newnode = NULL;
+    CsrUint32 i = 0;
+#endif
+
+    func_enter();
+
+    card->request_coredump_on_reset = 0;
+    card->dump_next_write = NULL;
+    card->dump_cur_read = NULL;
+    card->dump_buf = NULL;
+
+#ifndef UNIFI_DISABLE_COREDUMP
+    unifi_trace(ospriv, UDBG1,
+                "Allocate buffers for %d core dumps\n", num_dump_buffers);
+    if (num_dump_buffers == 0)
+    {
+        goto done;
+    }
+
+    /* Root node */
+    card->dump_buf = new_coredump_node(ospriv, NULL);
+    if (card->dump_buf == NULL)
+    {
+        goto fail;
+    }
+    prev = card->dump_buf;
+    newnode = card->dump_buf;
+
+    /* Add each subsequent node at tail */
+    for (i = 1; i < num_dump_buffers; i++)
+    {
+        newnode = new_coredump_node(ospriv, prev);
+        if (newnode == NULL)
+        {
+            goto fail;
+        }
+        prev = newnode;
+    }
+
+    /* Link the first and last nodes to make the list circular */
+    card->dump_buf->prev = newnode;
+    newnode->next = card->dump_buf;
+
+    /* Set initial r/w access pointers */
+    card->dump_next_write = card->dump_buf;
+    card->dump_cur_read = NULL;
+
+    unifi_trace(ospriv, UDBG2, "Core dump configured (%d dumps max)\n", i);
+
+done:
+#endif
+    func_exit();
+    return CSR_RESULT_SUCCESS;
+
+#ifndef UNIFI_DISABLE_COREDUMP
+fail:
+    /* Unwind what we allocated so far */
+    unifi_error(ospriv, "Out of memory allocating core dump node %d\n", i);
+    unifi_coredump_free(card);
+    func_exit();
+    return CSR_WIFI_HIP_RESULT_NO_MEMORY;
+#endif
+} /* unifi_coreump_init() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_coredump_free
+ *
+ *      Free all memory dynamically allocated for core dump
+ *
+ *  Arguments:
+ *      card            Pointer to card struct
+ *
+ *  Returns:
+ *      None
+ *
+ *  Notes:
+ * ---------------------------------------------------------------------------
+ */
+void unifi_coredump_free(card_t *card)
+{
+    void *ospriv = card->ospriv;
+    coredump_buffer *node, *del_node;
+    CsrInt16 i = 0;
+    CsrInt16 j;
+
+    func_enter();
+    unifi_trace(ospriv, UDBG2, "Core dump de-configured\n");
+
+    if (card->dump_buf == NULL)
+    {
+        return;
+    }
+
+    node = card->dump_buf;
+    do
+    {
+        /* Free payload zones */
+        for (j = 0; j < HIP_CDUMP_NUM_ZONES; j++)
+        {
+            if (node->zone[j] != NULL)
+            {
+                CsrMemFree(node->zone[j]);
+                node->zone[j] = NULL;
+            }
+        }
+
+        /* Detach */
+        del_node = node;
+        node = node->next;
+
+        /* Free header */
+        CsrMemFree(del_node);
+        i++;
+    } while ((node != NULL) && (node != card->dump_buf));
+
+    unifi_trace(ospriv, UDBG3, "Freed %d coredump buffers\n", i);
+
+    card->dump_buf = NULL;
+    card->dump_next_write = NULL;
+    card->dump_cur_read = NULL;
+
+    func_exit();
+} /* unifi_coredump_free() */
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_packing.c
@@ -0,0 +1,4804 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_wifi_hip_signals.h"
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_conversions.h"
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  get_packed_struct_size
+ *
+ *      Examine a buffer containing a UniFi signal in wire-format.
+ *      The first two bytes contain the signal ID, decode the signal ID and
+ *      return the size, in  bytes, of the signal, not including any bulk
+ *      data.
+ *
+ *      WARNING: This function is auto-generated, DO NOT EDIT!
+ *
+ *  Arguments:
+ *      buf     Pointer to buffer to decode.
+ *
+ *  Returns:
+ *      0 if the signal ID is not recognised (i.e. zero length),
+ *      otherwise the number of bytes occupied by the signal in the buffer.
+ *      This is useful for stepping past the signal to the object in the buffer.
+ * ---------------------------------------------------------------------------
+ */
+CsrInt32 get_packed_struct_size(const CsrUint8 *buf)
+{
+    CsrInt32 size = 0;
+    CsrUint16 sig_id;
+
+    sig_id = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(buf);
+
+    size += SIZEOF_UINT16;
+    size += SIZEOF_UINT16;
+    size += SIZEOF_UINT16;
+    switch (sig_id)
+    {
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_DEBUG_WORD16_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+        case CSR_DEBUG_GENERIC_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+        case CSR_MA_PACKET_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT64;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+        case CSR_MLME_SET_TIM_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECTED_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_TRIGGERED_GET_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT32;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            break;
+#endif
+        case CSR_DEBUG_GENERIC_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CANCEL_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT32;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MLME_SET_TIM_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_DEBUG_GENERIC_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+        case CSR_MA_PACKET_CANCEL_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT32;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_PACKET_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT32;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_VIF_AVAILABILITY_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLACKOUT_ENDED_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            break;
+#endif
+        case CSR_MA_VIF_AVAILABILITY_RESPONSE_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT32;
+            size += SIZEOF_UINT32;
+            size += SIZEOF_UINT32;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT32;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 32 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_PACKET_ERROR_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT32;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT32;
+            size += SIZEOF_UINT32;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_DEBUG_STRING_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLOCKACK_ERROR_INDICATION_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += 48 / 8;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_PACKET_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT32;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_CONFIRM_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_REQUEST_ID:
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            size += SIZEOF_UINT16;
+            break;
+#endif
+        default:
+            size = 0;
+    }
+    return size;
+} /* get_packed_struct_size() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  read_unpack_signal
+ *
+ *      Unpack a wire-format signal into a host-native structure.
+ *      This function handles any necessary conversions for endianness and
+ *      places no restrictions on packing or alignment for the structure
+ *      definition.
+ *
+ *      WARNING: This function is auto-generated, DO NOT EDIT!
+ *
+ *  Arguments:
+ *      ptr             Signal buffer to unpack.
+ *      sig             Pointer to destination structure to populate.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success,
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE if the ID of signal was not recognised.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult read_unpack_signal(const CsrUint8 *ptr, CSR_SIGNAL *sig)
+{
+    CsrInt32 index = 0;
+
+    sig->SignalPrimitiveHeader.SignalId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+    index += SIZEOF_UINT16;
+
+    sig->SignalPrimitiveHeader.ReceiverProcessId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+    index += SIZEOF_UINT16;
+
+    sig->SignalPrimitiveHeader.SenderProcessId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+    index += SIZEOF_UINT16;
+
+    switch (sig->SignalPrimitiveHeader.SignalId)
+    {
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_CONFIRM_ID:
+            sig->u.MlmeSetPacketFilterConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_CONFIRM_ID:
+            sig->u.MlmeSetkeysConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_CONFIRM_ID:
+            sig->u.MlmeConfigQueueConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM_ID:
+            sig->u.MlmeAddAutonomousScanConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanConfirm.AutonomousScanId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_CONFIRM_ID:
+            sig->u.MlmeAddBlackoutConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutConfirm.BlackoutId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_REQUEST_ID:
+            sig->u.MlmeDelBlackoutRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutRequest.BlackoutId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_CONFIRM_ID:
+            sig->u.MlmeGetKeySequenceConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[0] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[1] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[2] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[3] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[4] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[5] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[6] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[7] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_CONFIRM_ID:
+            sig->u.MlmeSmStartConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_CONFIRM_ID:
+            sig->u.MlmeStopAggregationConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeStopAggregationConfirm.PeerQstaAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeStopAggregationConfirm.UserPriority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationConfirm.Direction = (CSR_DIRECTION) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_REQUEST_ID:
+            sig->u.MlmeDelTspecRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecRequest.UserPriority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecRequest.Direction = (CSR_DIRECTION) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_DEBUG_WORD16_INDICATION_ID:
+            sig->u.DebugWord16Indication.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[0] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[1] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[2] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[3] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[4] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[5] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[6] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[7] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[8] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[9] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[10] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[11] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[12] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[13] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[14] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugWord16Indication.DebugWords[15] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+        case CSR_DEBUG_GENERIC_CONFIRM_ID:
+            sig->u.DebugGenericConfirm.DebugVariable.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.DebugVariable.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.DebugWords[0] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.DebugWords[1] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.DebugWords[2] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.DebugWords[3] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.DebugWords[4] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.DebugWords[5] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.DebugWords[6] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericConfirm.DebugWords[7] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+        case CSR_MA_PACKET_INDICATION_ID:
+            sig->u.MaPacketIndication.Data.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketIndication.Data.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketIndication.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MaPacketIndication.LocalTime.x, &ptr[index], 64 / 8);
+            index += 64 / 8;
+            sig->u.MaPacketIndication.Ifindex = (CSR_IFINTERFACE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketIndication.Channel = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketIndication.ReceptionStatus = (CSR_RECEPTION_STATUS) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketIndication.Rssi = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketIndication.Snr = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketIndication.ReceivedRate = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+        case CSR_MLME_SET_TIM_REQUEST_ID:
+            sig->u.MlmeSetTimRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimRequest.AssociationId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimRequest.TimValue = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECTED_INDICATION_ID:
+            sig->u.MlmeConnectedIndication.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectedIndication.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectedIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectedIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectedIndication.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectedIndication.ConnectionStatus = (CSR_CONNECTION_STATUS) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeConnectedIndication.PeerMacAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_REQUEST_ID:
+            sig->u.MlmeDelRxTriggerRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerRequest.TriggerId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_TRIGGERED_GET_INDICATION_ID:
+            sig->u.MlmeTriggeredGetIndication.MibAttributeValue.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeTriggeredGetIndication.MibAttributeValue.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeTriggeredGetIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeTriggeredGetIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeTriggeredGetIndication.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeTriggeredGetIndication.Status = (CSR_MIB_STATUS) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeTriggeredGetIndication.ErrorIndex = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeTriggeredGetIndication.TriggeredId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_REQUEST_ID:
+            sig->u.MlmeScanRequest.ChannelList.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanRequest.ChannelList.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanRequest.InformationElements.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanRequest.InformationElements.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanRequest.Ifindex = (CSR_IFINTERFACE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanRequest.ScanType = (CSR_SCAN_TYPE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanRequest.ProbeDelay = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            sig->u.MlmeScanRequest.MinChannelTime = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanRequest.MaxChannelTime = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_CONFIRM_ID:
+            sig->u.MlmeDeletekeysConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_REQUEST_ID:
+            sig->u.MlmeGetNextRequest.MibAttribute.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetNextRequest.MibAttribute.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetNextRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetNextRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_CONFIRM_ID:
+            sig->u.MlmeSetChannelConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_REQUEST_ID:
+            sig->u.MlmeStartAggregationRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeStartAggregationRequest.PeerQstaAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeStartAggregationRequest.UserPriority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationRequest.Direction = (CSR_DIRECTION) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationRequest.StartingSequenceNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationRequest.BufferSize = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationRequest.BlockAckTimeout = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_REQUEST_ID:
+            sig->u.MlmeHlSyncRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeHlSyncRequest.GroupAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+        case CSR_DEBUG_GENERIC_REQUEST_ID:
+            sig->u.DebugGenericRequest.DebugVariable.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.DebugVariable.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.DebugWords[0] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.DebugWords[1] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.DebugWords[2] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.DebugWords[3] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.DebugWords[4] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.DebugWords[5] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.DebugWords[6] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericRequest.DebugWords[7] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_CONFIRM_ID:
+            sig->u.MlmeLeaveConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeLeaveConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeLeaveConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeLeaveConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeLeaveConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeLeaveConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_REQUEST_ID:
+            sig->u.MlmeDelTriggeredGetRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetRequest.TriggeredId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST_ID:
+            sig->u.MlmeAddMulticastAddressRequest.Data.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddMulticastAddressRequest.Data.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddMulticastAddressRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddMulticastAddressRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddMulticastAddressRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddMulticastAddressRequest.NumberOfMulticastGroupAddresses = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_REQUEST_ID:
+            sig->u.MlmeResetRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeResetRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeResetRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeResetRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeResetRequest.StaAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeResetRequest.SetDefaultMib = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CANCEL_REQUEST_ID:
+            sig->u.MlmeScanCancelRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanCancelRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanCancelRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanCancelRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanCancelRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_CONFIRM_ID:
+            sig->u.MlmeAddTriggeredGetConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetConfirm.TriggeredId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_REQUEST_ID:
+            sig->u.MlmeSetPacketFilterRequest.InformationElements.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterRequest.InformationElements.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterRequest.PacketFilterMode = (CSR_PACKET_FILTER_MODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetPacketFilterRequest.ArpFilterAddress = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_CONFIRM_ID:
+            sig->u.MlmeDelRxTriggerConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerConfirm.TriggerId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelRxTriggerConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_REQUEST_ID:
+            sig->u.MlmeConnectStatusRequest.InformationElements.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusRequest.InformationElements.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusRequest.ConnectionStatus = (CSR_CONNECTION_STATUS) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeConnectStatusRequest.StaAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeConnectStatusRequest.AssociationId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusRequest.AssociationCapabilityInformation = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_REQUEST_ID:
+            sig->u.MlmeLeaveRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeLeaveRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeLeaveRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeLeaveRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeLeaveRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_REQUEST_ID:
+            sig->u.MlmeConfigQueueRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueRequest.QueueIndex = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueRequest.Aifs = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueRequest.Cwmin = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueRequest.Cwmax = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConfigQueueRequest.TxopLimit = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_CONFIRM_ID:
+            sig->u.MlmeDelTspecConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecConfirm.UserPriority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTspecConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MLME_SET_TIM_CONFIRM_ID:
+            sig->u.MlmeSetTimConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetTimConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_INDICATION_ID:
+            sig->u.MlmeMeasureIndication.MeasurementReportSet.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureIndication.MeasurementReportSet.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureIndication.DialogToken = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_CONFIRM_ID:
+            sig->u.MlmeDelBlackoutConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutConfirm.BlackoutId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelBlackoutConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_CONFIRM_ID:
+            sig->u.MlmeDelTriggeredGetConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelTriggeredGetConfirm.TriggeredId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_DEBUG_GENERIC_INDICATION_ID:
+            sig->u.DebugGenericIndication.DebugVariable.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.DebugVariable.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.DebugWords[0] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.DebugWords[1] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.DebugWords[2] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.DebugWords[3] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.DebugWords[4] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.DebugWords[5] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.DebugWords[6] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugGenericIndication.DebugWords[7] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+        case CSR_MA_PACKET_CANCEL_REQUEST_ID:
+            sig->u.MaPacketCancelRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketCancelRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketCancelRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketCancelRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketCancelRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketCancelRequest.HostTag = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM_ID:
+            sig->u.MlmeModifyBssParameterConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM_ID:
+            sig->u.MlmePauseAutonomousScanConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanConfirm.AutonomousScanId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_PACKET_REQUEST_ID:
+            sig->u.MaPacketRequest.Data.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketRequest.Data.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketRequest.TransmitRate = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketRequest.HostTag = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            sig->u.MaPacketRequest.Priority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MaPacketRequest.Ra.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MaPacketRequest.TransmissionControl = (CSR_TRANSMISSION_CONTROL) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST_ID:
+            sig->u.MlmeModifyBssParameterRequest.Data.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterRequest.Data.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterRequest.BeaconPeriod = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterRequest.DtimPeriod = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeModifyBssParameterRequest.CapabilityInformation = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeModifyBssParameterRequest.Bssid.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeModifyBssParameterRequest.RtsThreshold = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_REQUEST_ID:
+            sig->u.MlmeAddRxTriggerRequest.InformationElements.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerRequest.InformationElements.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerRequest.TriggerId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerRequest.Priority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_VIF_AVAILABILITY_INDICATION_ID:
+            sig->u.MaVifAvailabilityIndication.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaVifAvailabilityIndication.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaVifAvailabilityIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaVifAvailabilityIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaVifAvailabilityIndication.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaVifAvailabilityIndication.Multicast = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_REQUEST_ID:
+            sig->u.MlmeHlSyncCancelRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncCancelRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncCancelRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncCancelRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeHlSyncCancelRequest.GroupAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST_ID:
+            sig->u.MlmeDelAutonomousScanRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanRequest.AutonomousScanId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLACKOUT_ENDED_INDICATION_ID:
+            sig->u.MlmeBlackoutEndedIndication.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeBlackoutEndedIndication.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeBlackoutEndedIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeBlackoutEndedIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeBlackoutEndedIndication.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeBlackoutEndedIndication.BlackoutId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION_ID:
+            sig->u.MlmeAutonomousScanDoneIndication.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAutonomousScanDoneIndication.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAutonomousScanDoneIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAutonomousScanDoneIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAutonomousScanDoneIndication.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAutonomousScanDoneIndication.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAutonomousScanDoneIndication.AutonomousScanId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_REQUEST_ID:
+            sig->u.MlmeGetKeySequenceRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceRequest.KeyId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetKeySequenceRequest.KeyType = (CSR_KEY_TYPE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeGetKeySequenceRequest.Address.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_REQUEST_ID:
+            sig->u.MlmeSetChannelRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelRequest.Ifindex = (CSR_IFINTERFACE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelRequest.Channel = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeSetChannelRequest.Address.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeSetChannelRequest.AvailabilityDuration = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetChannelRequest.AvailabilityInterval = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_CONFIRM_ID:
+            sig->u.MlmeMeasureConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureConfirm.DialogToken = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_REQUEST_ID:
+            sig->u.MlmeAddTriggeredGetRequest.MibAttribute.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetRequest.MibAttribute.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTriggeredGetRequest.TriggeredId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION_ID:
+            sig->u.MlmeAutonomousScanLossIndication.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAutonomousScanLossIndication.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAutonomousScanLossIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAutonomousScanLossIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAutonomousScanLossIndication.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeAutonomousScanLossIndication.Bssid.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+        case CSR_MA_VIF_AVAILABILITY_RESPONSE_ID:
+            sig->u.MaVifAvailabilityResponse.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaVifAvailabilityResponse.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaVifAvailabilityResponse.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaVifAvailabilityResponse.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaVifAvailabilityResponse.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaVifAvailabilityResponse.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_REQUEST_ID:
+            sig->u.MlmeAddTemplateRequest.Data1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateRequest.Data1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateRequest.Data2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateRequest.Data2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateRequest.FrameType = (CSR_FRAME_TYPE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateRequest.MinTransmitRate = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_CONFIRM_ID:
+            sig->u.MlmePowermgtConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_CONFIRM_ID:
+            sig->u.MlmeAddPeriodicConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicConfirm.PeriodicId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_CONFIRM_ID:
+            sig->u.MlmeGetConfirm.MibAttributeValue.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetConfirm.MibAttributeValue.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetConfirm.Status = (CSR_MIB_STATUS) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetConfirm.ErrorIndex = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_CONFIRM_ID:
+            sig->u.MlmeGetNextConfirm.MibAttributeValue.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetNextConfirm.MibAttributeValue.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetNextConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetNextConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetNextConfirm.Status = (CSR_MIB_STATUS) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetNextConfirm.ErrorIndex = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_REQUEST_ID:
+            sig->u.MlmeStopAggregationRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeStopAggregationRequest.PeerQstaAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeStopAggregationRequest.UserPriority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopAggregationRequest.Direction = (CSR_DIRECTION) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_CONFIRM_ID:
+            sig->u.MlmeAddRxTriggerConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerConfirm.TriggerId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddRxTriggerConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_REQUEST_ID:
+            sig->u.MlmeAddBlackoutRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutRequest.BlackoutId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutRequest.BlackoutType = (CSR_BLACKOUT_TYPE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutRequest.BlackoutSource = (CSR_BLACKOUT_SOURCE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddBlackoutRequest.BlackoutStartReference = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            sig->u.MlmeAddBlackoutRequest.BlackoutPeriod = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            sig->u.MlmeAddBlackoutRequest.BlackoutDuration = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            CsrMemCpy(sig->u.MlmeAddBlackoutRequest.PeerStaAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeAddBlackoutRequest.BlackoutCount = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_REQUEST_ID:
+            sig->u.MlmeDeletekeysRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysRequest.KeyId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDeletekeysRequest.KeyType = (CSR_KEY_TYPE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeDeletekeysRequest.Address.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_CONFIRM_ID:
+            sig->u.MlmeResetConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeResetConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeResetConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeResetConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeResetConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CONFIRM_ID:
+            sig->u.MlmeHlSyncConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeHlSyncConfirm.GroupAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeHlSyncConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST_ID:
+            sig->u.MlmeAddAutonomousScanRequest.ChannelList.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanRequest.ChannelList.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanRequest.InformationElements.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanRequest.InformationElements.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanRequest.AutonomousScanId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanRequest.Ifindex = (CSR_IFINTERFACE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanRequest.ChannelStartingFactor = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanRequest.ScanType = (CSR_SCAN_TYPE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanRequest.ProbeDelay = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            sig->u.MlmeAddAutonomousScanRequest.MinChannelTime = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddAutonomousScanRequest.MaxChannelTime = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_REQUEST_ID:
+            sig->u.MlmeSetRequest.MibAttributeValue.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetRequest.MibAttributeValue.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_REQUEST_ID:
+            sig->u.MlmeSmStartRequest.Beacon.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartRequest.Beacon.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartRequest.BssParameters.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartRequest.BssParameters.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartRequest.Ifindex = (CSR_IFINTERFACE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartRequest.Channel = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeSmStartRequest.InterfaceAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            CsrMemCpy(sig->u.MlmeSmStartRequest.Bssid.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeSmStartRequest.BeaconPeriod = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartRequest.DtimPeriod = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSmStartRequest.CapabilityInformation = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_CONFIRM_ID:
+            sig->u.MlmeConnectStatusConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeConnectStatusConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM_ID:
+            sig->u.MlmeDelAutonomousScanConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelAutonomousScanConfirm.AutonomousScanId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_REQUEST_ID:
+            sig->u.MlmeDelPeriodicRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicRequest.PeriodicId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_REQUEST_ID:
+            sig->u.MlmeSetkeysRequest.Key.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.Key.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.Length = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.KeyId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.KeyType = (CSR_KEY_TYPE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeSetkeysRequest.Address.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeSetkeysRequest.SequenceNumber[0] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.SequenceNumber[1] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.SequenceNumber[2] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.SequenceNumber[3] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.SequenceNumber[4] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.SequenceNumber[5] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.SequenceNumber[6] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetkeysRequest.SequenceNumber[7] = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(&sig->u.MlmeSetkeysRequest.CipherSuiteSelector, &ptr[index], 32 / 8);
+            index += 32 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST_ID:
+            sig->u.MlmePauseAutonomousScanRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanRequest.AutonomousScanId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePauseAutonomousScanRequest.Pause = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_REQUEST_ID:
+            sig->u.MlmeGetRequest.MibAttribute.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetRequest.MibAttribute.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeGetRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_REQUEST_ID:
+            sig->u.MlmePowermgtRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtRequest.PowerManagementMode = (CSR_POWER_MANAGEMENT_MODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtRequest.ReceiveDtims = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtRequest.ListenInterval = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmePowermgtRequest.TrafficWindow = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_PACKET_ERROR_INDICATION_ID:
+            sig->u.MaPacketErrorIndication.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketErrorIndication.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketErrorIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketErrorIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketErrorIndication.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MaPacketErrorIndication.PeerQstaAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MaPacketErrorIndication.UserPriority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketErrorIndication.SequenceNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_REQUEST_ID:
+            sig->u.MlmeAddPeriodicRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicRequest.PeriodicId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicRequest.MaximumLatency = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            sig->u.MlmeAddPeriodicRequest.PeriodicSchedulingMode = (CSR_PERIODIC_SCHEDULING_MODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicRequest.WakeHost = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddPeriodicRequest.UserPriority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_REQUEST_ID:
+            sig->u.MlmeAddTspecRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecRequest.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecRequest.UserPriority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecRequest.Direction = (CSR_DIRECTION) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecRequest.PsScheme = (CSR_PS_SCHEME) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecRequest.MediumTime = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecRequest.ServiceStartTime = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            sig->u.MlmeAddTspecRequest.ServiceInterval = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            sig->u.MlmeAddTspecRequest.MinimumDataRate = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM_ID:
+            sig->u.MlmeAddMulticastAddressConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddMulticastAddressConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddMulticastAddressConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddMulticastAddressConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddMulticastAddressConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddMulticastAddressConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_CONFIRM_ID:
+            sig->u.MlmeAddTspecConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecConfirm.UserPriority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTspecConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_CONFIRM_ID:
+            sig->u.MlmeHlSyncCancelConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncCancelConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncCancelConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncCancelConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeHlSyncCancelConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CONFIRM_ID:
+            sig->u.MlmeScanConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeScanConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_DEBUG_STRING_INDICATION_ID:
+            sig->u.DebugStringIndication.DebugMessage.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugStringIndication.DebugMessage.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugStringIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.DebugStringIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_CONFIRM_ID:
+            sig->u.MlmeAddTemplateConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateConfirm.FrameType = (CSR_FRAME_TYPE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeAddTemplateConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLOCKACK_ERROR_INDICATION_ID:
+            sig->u.MlmeBlockackErrorIndication.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeBlockackErrorIndication.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeBlockackErrorIndication.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeBlockackErrorIndication.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeBlockackErrorIndication.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeBlockackErrorIndication.ResultCode = (CSR_REASON_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeBlockackErrorIndication.PeerQstaAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CONFIRM_ID:
+            sig->u.MlmeSetConfirm.MibAttributeValue.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetConfirm.MibAttributeValue.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetConfirm.Status = (CSR_MIB_STATUS) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeSetConfirm.ErrorIndex = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_REQUEST_ID:
+            sig->u.MlmeMeasureRequest.MeasurementRequestSet.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureRequest.MeasurementRequestSet.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeMeasureRequest.DialogToken = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_CONFIRM_ID:
+            sig->u.MlmeStartAggregationConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(sig->u.MlmeStartAggregationConfirm.PeerQstaAddress.x, &ptr[index], 48 / 8);
+            index += 48 / 8;
+            sig->u.MlmeStartAggregationConfirm.UserPriority = (CSR_PRIORITY) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationConfirm.Direction = (CSR_DIRECTION) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStartAggregationConfirm.SequenceNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_CONFIRM_ID:
+            sig->u.MlmeStopMeasureConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopMeasureConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopMeasureConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopMeasureConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopMeasureConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopMeasureConfirm.DialogToken = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_PACKET_CONFIRM_ID:
+            sig->u.MaPacketConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketConfirm.TransmissionStatus = (CSR_TRANSMISSION_STATUS) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketConfirm.RetryCount = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketConfirm.Rate = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MaPacketConfirm.HostTag = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT32;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_CONFIRM_ID:
+            sig->u.MlmeDelPeriodicConfirm.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicConfirm.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicConfirm.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicConfirm.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicConfirm.VirtualInterfaceIdentifier = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicConfirm.PeriodicId = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeDelPeriodicConfirm.ResultCode = (CSR_RESULT_CODE) CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_REQUEST_ID:
+            sig->u.MlmeStopMeasureRequest.Dummydataref1.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopMeasureRequest.Dummydataref1.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopMeasureRequest.Dummydataref2.SlotNumber = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopMeasureRequest.Dummydataref2.DataLength = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            sig->u.MlmeStopMeasureRequest.DialogToken = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+
+        default:
+            return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+    return CSR_RESULT_SUCCESS;
+} /* read_unpack_signal() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  write_pack
+ *
+ *      Convert a signal structure, in host-native format, to the
+ *      little-endian wire format specified in the UniFi Host Interface
+ *      Protocol Specification.
+ *
+ *      WARNING: This function is auto-generated, DO NOT EDIT!
+ *
+ *  Arguments:
+ *      sig             Pointer to signal structure to pack.
+ *      ptr             Destination buffer to pack into.
+ *      sig_len         Returns the length of the packed signal, i.e. the
+ *                      number of bytes written to ptr.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success,
+ *      CSR_WIFI_HIP_RESULT_INVALID_VALUE if the ID of signal was not recognised.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult write_pack(const CSR_SIGNAL *sig, CsrUint8 *ptr, CsrUint16 *sig_len)
+{
+    CsrInt16 index = 0;
+
+    CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->SignalPrimitiveHeader.SignalId, ptr + index);
+    index += SIZEOF_UINT16;
+
+    CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->SignalPrimitiveHeader.ReceiverProcessId, ptr + index);
+    index += SIZEOF_UINT16;
+
+    CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->SignalPrimitiveHeader.SenderProcessId, ptr + index);
+    index += SIZEOF_UINT16;
+
+    switch (sig->SignalPrimitiveHeader.SignalId)
+    {
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanConfirm.AutonomousScanId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutConfirm.BlackoutId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutRequest.BlackoutId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[0], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[1], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[2], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[3], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[4], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[5], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[6], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceConfirm.SequenceNumber[7], ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeStopAggregationConfirm.PeerQstaAddress.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationConfirm.UserPriority, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationConfirm.Direction, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecRequest.UserPriority, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecRequest.Direction, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_DEBUG_WORD16_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[0], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[1], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[2], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[3], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[4], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[5], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[6], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[7], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[8], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[9], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[10], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[11], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[12], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[13], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[14], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugWord16Indication.DebugWords[15], ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+        case CSR_DEBUG_GENERIC_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.DebugVariable.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.DebugVariable.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.DebugWords[0], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.DebugWords[1], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.DebugWords[2], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.DebugWords[3], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.DebugWords[4], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.DebugWords[5], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.DebugWords[6], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericConfirm.DebugWords[7], ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+        case CSR_MA_PACKET_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.Data.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.Data.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MaPacketIndication.LocalTime.x, 64 / 8);
+            index += 64 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.Ifindex, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.Channel, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.ReceptionStatus, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.Rssi, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.Snr, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketIndication.ReceivedRate, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+        case CSR_MLME_SET_TIM_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimRequest.AssociationId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimRequest.TimValue, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECTED_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectedIndication.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectedIndication.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectedIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectedIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectedIndication.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectedIndication.ConnectionStatus, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeConnectedIndication.PeerMacAddress.x, 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerRequest.TriggerId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_TRIGGERED_GET_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeTriggeredGetIndication.MibAttributeValue.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeTriggeredGetIndication.MibAttributeValue.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeTriggeredGetIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeTriggeredGetIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeTriggeredGetIndication.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeTriggeredGetIndication.Status, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeTriggeredGetIndication.ErrorIndex, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeTriggeredGetIndication.TriggeredId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanRequest.ChannelList.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanRequest.ChannelList.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanRequest.InformationElements.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanRequest.InformationElements.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanRequest.Ifindex, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanRequest.ScanType, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MlmeScanRequest.ProbeDelay, ptr + index);
+            index += SIZEOF_UINT32;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanRequest.MinChannelTime, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanRequest.MaxChannelTime, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetNextRequest.MibAttribute.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetNextRequest.MibAttribute.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetNextRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetNextRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeStartAggregationRequest.PeerQstaAddress.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationRequest.UserPriority, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationRequest.Direction, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationRequest.StartingSequenceNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationRequest.BufferSize, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationRequest.BlockAckTimeout, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeHlSyncRequest.GroupAddress.x, 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+        case CSR_DEBUG_GENERIC_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.DebugVariable.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.DebugVariable.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.DebugWords[0], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.DebugWords[1], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.DebugWords[2], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.DebugWords[3], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.DebugWords[4], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.DebugWords[5], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.DebugWords[6], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericRequest.DebugWords[7], ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetRequest.TriggeredId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressRequest.Data.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressRequest.Data.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressRequest.NumberOfMulticastGroupAddresses, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeResetRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeResetRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeResetRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeResetRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeResetRequest.StaAddress.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeResetRequest.SetDefaultMib, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CANCEL_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanCancelRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanCancelRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanCancelRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanCancelRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanCancelRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetConfirm.TriggeredId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterRequest.InformationElements.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterRequest.InformationElements.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterRequest.PacketFilterMode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MlmeSetPacketFilterRequest.ArpFilterAddress, ptr + index);
+            index += SIZEOF_UINT32;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerConfirm.TriggerId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelRxTriggerConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusRequest.InformationElements.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusRequest.InformationElements.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusRequest.ConnectionStatus, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeConnectStatusRequest.StaAddress.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusRequest.AssociationId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusRequest.AssociationCapabilityInformation, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeLeaveRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueRequest.QueueIndex, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueRequest.Aifs, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueRequest.Cwmin, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueRequest.Cwmax, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConfigQueueRequest.TxopLimit, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecConfirm.UserPriority, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTspecConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MLME_SET_TIM_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetTimConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureIndication.MeasurementReportSet.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureIndication.MeasurementReportSet.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureIndication.DialogToken, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutConfirm.BlackoutId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelBlackoutConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelTriggeredGetConfirm.TriggeredId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_DEBUG_GENERIC_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.DebugVariable.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.DebugVariable.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.DebugWords[0], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.DebugWords[1], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.DebugWords[2], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.DebugWords[3], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.DebugWords[4], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.DebugWords[5], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.DebugWords[6], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugGenericIndication.DebugWords[7], ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+        case CSR_MA_PACKET_CANCEL_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketCancelRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketCancelRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketCancelRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketCancelRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketCancelRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MaPacketCancelRequest.HostTag, ptr + index);
+            index += SIZEOF_UINT32;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanConfirm.AutonomousScanId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_PACKET_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketRequest.Data.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketRequest.Data.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketRequest.TransmitRate, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MaPacketRequest.HostTag, ptr + index);
+            index += SIZEOF_UINT32;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketRequest.Priority, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MaPacketRequest.Ra.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketRequest.TransmissionControl, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterRequest.Data.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterRequest.Data.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterRequest.BeaconPeriod, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterRequest.DtimPeriod, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterRequest.CapabilityInformation, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeModifyBssParameterRequest.Bssid.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeModifyBssParameterRequest.RtsThreshold, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerRequest.InformationElements.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerRequest.InformationElements.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerRequest.TriggerId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerRequest.Priority, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_VIF_AVAILABILITY_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityIndication.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityIndication.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityIndication.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityIndication.Multicast, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncCancelRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncCancelRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncCancelRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncCancelRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeHlSyncCancelRequest.GroupAddress.x, 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanRequest.AutonomousScanId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLACKOUT_ENDED_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlackoutEndedIndication.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlackoutEndedIndication.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlackoutEndedIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlackoutEndedIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlackoutEndedIndication.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlackoutEndedIndication.BlackoutId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanDoneIndication.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanDoneIndication.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanDoneIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanDoneIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanDoneIndication.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanDoneIndication.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanDoneIndication.AutonomousScanId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceRequest.KeyId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetKeySequenceRequest.KeyType, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeGetKeySequenceRequest.Address.x, 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelRequest.Ifindex, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelRequest.Channel, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeSetChannelRequest.Address.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelRequest.AvailabilityDuration, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetChannelRequest.AvailabilityInterval, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureConfirm.DialogToken, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetRequest.MibAttribute.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetRequest.MibAttribute.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTriggeredGetRequest.TriggeredId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanLossIndication.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanLossIndication.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanLossIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanLossIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAutonomousScanLossIndication.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeAutonomousScanLossIndication.Bssid.x, 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+        case CSR_MA_VIF_AVAILABILITY_RESPONSE_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityResponse.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityResponse.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityResponse.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityResponse.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityResponse.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaVifAvailabilityResponse.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateRequest.Data1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateRequest.Data1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateRequest.Data2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateRequest.Data2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateRequest.FrameType, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateRequest.MinTransmitRate, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicConfirm.PeriodicId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetConfirm.MibAttributeValue.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetConfirm.MibAttributeValue.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetConfirm.Status, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetConfirm.ErrorIndex, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetNextConfirm.MibAttributeValue.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetNextConfirm.MibAttributeValue.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetNextConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetNextConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetNextConfirm.Status, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetNextConfirm.ErrorIndex, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeStopAggregationRequest.PeerQstaAddress.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationRequest.UserPriority, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopAggregationRequest.Direction, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerConfirm.TriggerId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddRxTriggerConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.BlackoutId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.BlackoutType, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.BlackoutSource, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.BlackoutStartReference, ptr + index);
+            index += SIZEOF_UINT32;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.BlackoutPeriod, ptr + index);
+            index += SIZEOF_UINT32;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.BlackoutDuration, ptr + index);
+            index += SIZEOF_UINT32;
+            CsrMemCpy(ptr + index, sig->u.MlmeAddBlackoutRequest.PeerStaAddress.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddBlackoutRequest.BlackoutCount, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysRequest.KeyId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDeletekeysRequest.KeyType, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeDeletekeysRequest.Address.x, 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeResetConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeResetConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeResetConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeResetConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeResetConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeHlSyncConfirm.GroupAddress.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.ChannelList.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.ChannelList.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.InformationElements.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.InformationElements.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.AutonomousScanId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.Ifindex, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.ChannelStartingFactor, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.ScanType, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.ProbeDelay, ptr + index);
+            index += SIZEOF_UINT32;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.MinChannelTime, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddAutonomousScanRequest.MaxChannelTime, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetRequest.MibAttributeValue.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetRequest.MibAttributeValue.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartRequest.Beacon.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartRequest.Beacon.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartRequest.BssParameters.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartRequest.BssParameters.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartRequest.Ifindex, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartRequest.Channel, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeSmStartRequest.InterfaceAddress.x, 48 / 8);
+            index += 48 / 8;
+            CsrMemCpy(ptr + index, sig->u.MlmeSmStartRequest.Bssid.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartRequest.BeaconPeriod, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartRequest.DtimPeriod, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSmStartRequest.CapabilityInformation, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeConnectStatusConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelAutonomousScanConfirm.AutonomousScanId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicRequest.PeriodicId, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.Key.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.Key.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.Length, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.KeyId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.KeyType, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeSetkeysRequest.Address.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.SequenceNumber[0], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.SequenceNumber[1], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.SequenceNumber[2], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.SequenceNumber[3], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.SequenceNumber[4], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.SequenceNumber[5], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.SequenceNumber[6], ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetkeysRequest.SequenceNumber[7], ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, &sig->u.MlmeSetkeysRequest.CipherSuiteSelector, 32 / 8);
+            index += 32 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanRequest.AutonomousScanId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePauseAutonomousScanRequest.Pause, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetRequest.MibAttribute.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetRequest.MibAttribute.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeGetRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtRequest.PowerManagementMode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtRequest.ReceiveDtims, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtRequest.ListenInterval, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmePowermgtRequest.TrafficWindow, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_PACKET_ERROR_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketErrorIndication.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketErrorIndication.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketErrorIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketErrorIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketErrorIndication.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MaPacketErrorIndication.PeerQstaAddress.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketErrorIndication.UserPriority, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketErrorIndication.SequenceNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicRequest.PeriodicId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicRequest.MaximumLatency, ptr + index);
+            index += SIZEOF_UINT32;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicRequest.PeriodicSchedulingMode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicRequest.WakeHost, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddPeriodicRequest.UserPriority, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.UserPriority, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.Direction, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.PsScheme, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.MediumTime, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.ServiceStartTime, ptr + index);
+            index += SIZEOF_UINT32;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.ServiceInterval, ptr + index);
+            index += SIZEOF_UINT32;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecRequest.MinimumDataRate, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddMulticastAddressConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecConfirm.UserPriority, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTspecConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncCancelConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncCancelConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncCancelConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncCancelConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeHlSyncCancelConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeScanConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_DEBUG_STRING_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugStringIndication.DebugMessage.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugStringIndication.DebugMessage.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugStringIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.DebugStringIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateConfirm.FrameType, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeAddTemplateConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLOCKACK_ERROR_INDICATION_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlockackErrorIndication.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlockackErrorIndication.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlockackErrorIndication.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlockackErrorIndication.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlockackErrorIndication.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeBlockackErrorIndication.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeBlockackErrorIndication.PeerQstaAddress.x, 48 / 8);
+            index += 48 / 8;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetConfirm.MibAttributeValue.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetConfirm.MibAttributeValue.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetConfirm.Status, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeSetConfirm.ErrorIndex, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureRequest.MeasurementRequestSet.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureRequest.MeasurementRequestSet.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeMeasureRequest.DialogToken, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CsrMemCpy(ptr + index, sig->u.MlmeStartAggregationConfirm.PeerQstaAddress.x, 48 / 8);
+            index += 48 / 8;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationConfirm.UserPriority, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationConfirm.Direction, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStartAggregationConfirm.SequenceNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureConfirm.DialogToken, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+        case CSR_MA_PACKET_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketConfirm.TransmissionStatus, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketConfirm.RetryCount, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MaPacketConfirm.Rate, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT32_TO_LITTLE_ENDIAN(sig->u.MaPacketConfirm.HostTag, ptr + index);
+            index += SIZEOF_UINT32;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_CONFIRM_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicConfirm.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicConfirm.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicConfirm.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicConfirm.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicConfirm.VirtualInterfaceIdentifier, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicConfirm.PeriodicId, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeDelPeriodicConfirm.ResultCode, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_REQUEST_ID:
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureRequest.Dummydataref1.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureRequest.Dummydataref1.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureRequest.Dummydataref2.SlotNumber, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureRequest.Dummydataref2.DataLength, ptr + index);
+            index += SIZEOF_UINT16;
+            CSR_COPY_UINT16_TO_LITTLE_ENDIAN(sig->u.MlmeStopMeasureRequest.DialogToken, ptr + index);
+            index += SIZEOF_UINT16;
+            break;
+#endif
+
+        default:
+            return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    *sig_len = index;
+
+    return CSR_RESULT_SUCCESS;
+} /* write_pack() */
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_send.c
@@ -0,0 +1,422 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ***************************************************************************
+ *
+ *  FILE:     csr_wifi_hip_send.c
+ *
+ *  PURPOSE:
+ *      Code for adding a signal request to the from-host queue.
+ *      When the driver bottom-half is run, it will take requests from the
+ *      queue and pass them to the UniFi.
+ *
+ * ***************************************************************************
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_conversions.h"
+#include "csr_wifi_hip_sigs.h"
+#include "csr_wifi_hip_card.h"
+
+unifi_TrafficQueue unifi_frame_priority_to_queue(CSR_PRIORITY priority)
+{
+    switch (priority)
+    {
+        case CSR_QOS_UP0:
+        case CSR_QOS_UP3:
+            return UNIFI_TRAFFIC_Q_BE;
+        case CSR_QOS_UP1:
+        case CSR_QOS_UP2:
+            return UNIFI_TRAFFIC_Q_BK;
+        case CSR_QOS_UP4:
+        case CSR_QOS_UP5:
+            return UNIFI_TRAFFIC_Q_VI;
+        case CSR_QOS_UP6:
+        case CSR_QOS_UP7:
+        case CSR_MANAGEMENT:
+            return UNIFI_TRAFFIC_Q_VO;
+        default:
+            return UNIFI_TRAFFIC_Q_BE;
+    }
+}
+
+
+CSR_PRIORITY unifi_get_default_downgrade_priority(unifi_TrafficQueue queue)
+{
+    switch (queue)
+    {
+        case UNIFI_TRAFFIC_Q_BE:
+            return CSR_QOS_UP0;
+        case UNIFI_TRAFFIC_Q_BK:
+            return CSR_QOS_UP1;
+        case UNIFI_TRAFFIC_Q_VI:
+            return CSR_QOS_UP5;
+        case UNIFI_TRAFFIC_Q_VO:
+            return CSR_QOS_UP6;
+        default:
+            return CSR_QOS_UP0;
+    }
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  send_signal
+ *
+ *      This function queues a signal for sending to UniFi.  It first checks
+ *      that there is space on the fh_signal_queue for another entry, then
+ *      claims any bulk data slots required and copies data into them. Then
+ *      increments the fh_signal_queue write count.
+ *
+ *      The fh_signal_queue is later processed by the driver bottom half
+ *      (in unifi_bh()).
+ *
+ *      This function call unifi_pause_xmit() to pause the flow of data plane
+ *      packets when:
+ *        - the fh_signal_queue ring buffer is full
+ *        - there are less than UNIFI_MAX_DATA_REFERENCES (2) bulk data
+ *          slots available.
+ *
+ *  Arguments:
+ *      card            Pointer to card context structure
+ *      sigptr          Pointer to the signal to write to UniFi.
+ *      siglen          Number of bytes pointer to by sigptr.
+ *      bulkdata        Array of pointers to an associated bulk data.
+ *      sigq            To which from-host queue to add the signal.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success
+ *      CSR_WIFI_HIP_RESULT_NO_SPACE if there were insufficient data slots or
+ *                              no free signal queue entry
+ *
+ * Notes:
+ *      Calls unifi_pause_xmit() when the last slots are used.
+ * ---------------------------------------------------------------------------
+ */
+static CsrResult send_signal(card_t *card, const CsrUint8 *sigptr, CsrUint32 siglen,
+                             const bulk_data_param_t *bulkdata,
+                             q_t *sigq, CsrUint32 priority_q, CsrUint32 run_bh)
+{
+    CsrUint16 i, data_slot_size;
+    card_signal_t *csptr;
+    CsrInt16 qe;
+    CsrResult r;
+    CsrInt16 debug_print = 0;
+
+    data_slot_size = CardGetDataSlotSize(card);
+
+    /* Check that the fh_data_queue has a free slot */
+    if (!CSR_WIFI_HIP_Q_SLOTS_FREE(sigq))
+    {
+        unifi_trace(card->ospriv, UDBG3, "send_signal: %s full\n", sigq->name);
+
+        return CSR_WIFI_HIP_RESULT_NO_SPACE;
+    }
+
+    /*
+     * Now add the signal to the From Host signal queue
+     */
+    /* Get next slot on queue */
+    qe = CSR_WIFI_HIP_Q_NEXT_W_SLOT(sigq);
+    csptr = CSR_WIFI_HIP_Q_SLOT_DATA(sigq, qe);
+
+    /* Make up the card_signal struct */
+    csptr->signal_length = (CsrUint16)siglen;
+    CsrMemCpy((void *)csptr->sigbuf, (void *)sigptr, siglen);
+
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; ++i)
+    {
+        if ((bulkdata != NULL) && (bulkdata->d[i].data_length != 0))
+        {
+            CsrUint32 datalen = bulkdata->d[i].data_length;
+
+            /* Make sure data will fit in a bulk data slot */
+            if (bulkdata->d[i].os_data_ptr == NULL)
+            {
+                unifi_error(card->ospriv, "send_signal - NULL bulkdata[%d]\n", i);
+                debug_print++;
+                csptr->bulkdata[i].data_length = 0;
+            }
+            else
+            {
+                if (datalen > data_slot_size)
+                {
+                    unifi_error(card->ospriv,
+                                "send_signal - Invalid data length %u (@%p), "
+                                "truncating\n",
+                                datalen, bulkdata->d[i].os_data_ptr);
+                    datalen = data_slot_size;
+                    debug_print++;
+                }
+                /* Store the bulk data info in the soft queue. */
+                csptr->bulkdata[i].os_data_ptr = (CsrUint8 *)bulkdata->d[i].os_data_ptr;
+                csptr->bulkdata[i].os_net_buf_ptr = (CsrUint8 *)bulkdata->d[i].os_net_buf_ptr;
+                csptr->bulkdata[i].net_buf_length = bulkdata->d[i].net_buf_length;
+                csptr->bulkdata[i].data_length = datalen;
+            }
+        }
+        else
+        {
+            UNIFI_INIT_BULK_DATA(&csptr->bulkdata[i]);
+        }
+    }
+
+    if (debug_print)
+    {
+        const CsrUint8 *sig = sigptr;
+
+        unifi_error(card->ospriv, "Signal(%d): %02x %02x %02x %02x %02x %02x %02x %02x"
+                    " %02x %02x %02x %02x %02x %02x %02x %02x\n",
+                    siglen,
+                    sig[0], sig[1], sig[2], sig[3],
+                    sig[4], sig[5], sig[6], sig[7],
+                    sig[8], sig[9], sig[10], sig[11],
+                    sig[12], sig[13], sig[14], sig[15]);
+        unifi_error(card->ospriv, "Bulkdata pointer %p(%d), %p(%d)\n",
+                    bulkdata != NULL?bulkdata->d[0].os_data_ptr : NULL,
+                    bulkdata != NULL?bulkdata->d[0].data_length : 0,
+                    bulkdata != NULL?bulkdata->d[1].os_data_ptr : NULL,
+                    bulkdata != NULL?bulkdata->d[1].data_length : 0);
+    }
+
+    /* Advance the written count to say there is a new entry */
+    CSR_WIFI_HIP_Q_INC_W(sigq);
+
+    /*
+     * Set the flag to say reason for waking was a host request.
+     * Then ask the OS layer to run the unifi_bh.
+     */
+    if (run_bh == 1)
+    {
+        card->bh_reason_host = 1;
+        r = unifi_run_bh(card->ospriv);
+        if (r != CSR_RESULT_SUCCESS)
+        {
+            unifi_error(card->ospriv, "failed to run bh.\n");
+            card->bh_reason_host = 0;
+
+            /*
+             * The bulk data buffer will be freed by the caller.
+             * We need to invalidate the description of the bulk data in our
+             * soft queue, to prevent the core freeing the bulk data again later.
+             */
+            for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; ++i)
+            {
+                if (csptr->bulkdata[i].data_length != 0)
+                {
+                    csptr->bulkdata[i].os_data_ptr = csptr->bulkdata[i].os_net_buf_ptr = NULL;
+                    csptr->bulkdata[i].net_buf_length = csptr->bulkdata[i].data_length = 0;
+                }
+            }
+            return r;
+        }
+    }
+    else
+    {
+        unifi_error(card->ospriv, "run_bh=%d, bh not called.\n", run_bh);
+    }
+
+    /*
+     * Have we used up all the fh signal list entries?
+     */
+    if (CSR_WIFI_HIP_Q_SLOTS_FREE(sigq) == 0)
+    {
+        /* We have filled the queue, so stop the upper layer. The command queue
+         * is an exception, as suspending due to that being full could delay
+         * resume/retry until new commands or data are received.
+         */
+        if (sigq != &card->fh_command_queue)
+        {
+            /*
+             * Must call unifi_pause_xmit() *before* setting the paused flag.
+             * (the unifi_pause_xmit call should not be after setting the flag because of the possibility of being interrupted
+             * by the bh thread between our setting the flag and the call to unifi_pause_xmit()
+             * If bh thread then cleared the flag, we would end up paused, but without the flag set)
+             * Instead, setting it afterwards means that if this thread is interrupted by the bh thread
+             * the pause flag is still guaranteed to end up set
+             * However the potential deadlock now is that if bh thread emptied the queue and cleared the flag before this thread's
+             * call to unifi_pause_xmit(), then bh thread may not run again because it will be waiting for
+             * a packet to appear in the queue but nothing ever will because xmit is paused.
+             * So we will end up with the queue paused, and the flag set to say it is paused, but bh never runs to unpause it.
+             * (Note even this bad situation would not persist long in practice, because something else (eg rx, or tx in different queue)
+             * is likely to wake bh thread quite soon)
+             * But to avoid this deadlock completely, after setting the flag we check that there is something left in the queue.
+             * If there is, we know that bh thread has not emptied the queue yet.
+             * Since bh thread checks to unpause the queue *after* taking packets from the queue, we know that it is still going to make at
+             * least one more check to see whether it needs to unpause the queue.  So all is well.
+             * If there are no packets in the queue, then the deadlock described above might happen.  To make sure it does not, we
+             * unpause the queue here. A possible side effect is that unifi_restart_xmit() may (rarely) be called for second time
+             *  unnecessarily, which is harmless
+             */
+
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+            unifi_debug_log_to_buf("P");
+#endif
+            unifi_pause_xmit(card->ospriv, (unifi_TrafficQueue)priority_q);
+            card_tx_q_pause(card, priority_q);
+            if (CSR_WIFI_HIP_Q_SLOTS_USED(sigq) == 0)
+            {
+                card_tx_q_unpause(card, priority_q);
+                unifi_restart_xmit(card->ospriv, (unifi_TrafficQueue) priority_q);
+            }
+        }
+        else
+        {
+            unifi_warning(card->ospriv,
+                          "send_signal: fh_cmd_q full, not pausing (run_bh=%d)\n",
+                          run_bh);
+        }
+    }
+
+    func_exit();
+
+    return CSR_RESULT_SUCCESS;
+} /*  send_signal() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_send_signal
+ *
+ *    Invokes send_signal() to queue a signal in the command or traffic queue
+ *    If sigptr pointer is NULL, it pokes the bh to check if UniFi is responsive.
+ *
+ *  Arguments:
+ *      card        Pointer to card context struct
+ *      sigptr      Pointer to signal from card.
+ *      siglen      Size of the signal
+ *      bulkdata    Pointer to the bulk data of the signal
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success
+ *      CSR_WIFI_HIP_RESULT_NO_SPACE if there were insufficient data slots or no free signal queue entry
+ *
+ *  Notes:
+ *      unifi_send_signal() is used to queue signals, created by the driver,
+ *      to the device. Signals are constructed using the UniFi packed structures.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_send_signal(card_t *card, const CsrUint8 *sigptr, CsrUint32 siglen,
+                            const bulk_data_param_t *bulkdata)
+{
+    q_t *sig_soft_q;
+    CsrUint16 signal_id;
+    CsrResult r;
+    CsrUint32 run_bh;
+    CsrUint32 priority_q;
+
+    /* A NULL signal pointer is a request to check if UniFi is responsive */
+    if (sigptr == NULL)
+    {
+        card->bh_reason_host = 1;
+        return unifi_run_bh(card->ospriv);
+    }
+
+    priority_q = 0;
+    run_bh = 1;
+    signal_id = GET_SIGNAL_ID(sigptr);
+    /*
+     * If the signal is a CSR_MA_PACKET_REQUEST ,
+     * we send it using the traffic soft queue. Else we use the command soft queue.
+     */
+    if (signal_id == CSR_MA_PACKET_REQUEST_ID)
+    {
+        CsrUint16 frame_priority;
+
+        if (card->periodic_wake_mode == UNIFI_PERIODIC_WAKE_HOST_ENABLED)
+        {
+            run_bh = 0;
+        }
+
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)
+        unifi_debug_log_to_buf("D");
+#endif
+        /* Sanity check: MA-PACKET.req must have a valid bulk data */
+        if ((bulkdata->d[0].data_length == 0) || (bulkdata->d[0].os_data_ptr == NULL))
+        {
+            unifi_error(card->ospriv, "MA-PACKET.req with empty bulk data (%d bytes in %p)\n",
+                        bulkdata->d[0].data_length, bulkdata->d[0].os_data_ptr);
+            dump((void *)sigptr, siglen);
+            return CSR_RESULT_FAILURE;
+        }
+
+        /* Map the frame priority to a traffic queue index. */
+        frame_priority = GET_PACKED_MA_PACKET_REQUEST_FRAME_PRIORITY(sigptr);
+        priority_q = unifi_frame_priority_to_queue((CSR_PRIORITY)frame_priority);
+
+        sig_soft_q = &card->fh_traffic_queue[priority_q];
+    }
+    else
+    {
+        sig_soft_q = &card->fh_command_queue;
+    }
+
+    r = send_signal(card, sigptr, siglen, bulkdata, sig_soft_q, priority_q, run_bh);
+    /* On error, the caller must free or requeue bulkdata buffers */
+
+    return r;
+} /* unifi_send_signal() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_send_resources_available
+ *
+ *      Examines whether there is available space to queue
+ *      a signal in the command or traffic queue
+ *
+ *  Arguments:
+ *      card        Pointer to card context struct
+ *      sigptr      Pointer to signal.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS if resources available
+ *      CSR_WIFI_HIP_RESULT_NO_SPACE if there was no free signal queue entry
+ *
+ *  Notes:
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_send_resources_available(card_t *card, const CsrUint8 *sigptr)
+{
+    q_t *sig_soft_q;
+    CsrUint16 signal_id = GET_SIGNAL_ID(sigptr);
+
+    /*
+     * If the signal is a CSR_MA_PACKET_REQUEST ,
+     * we send it using the traffic soft queue. Else we use the command soft queue.
+     */
+    if (signal_id == CSR_MA_PACKET_REQUEST_ID)
+    {
+        CsrUint16 frame_priority;
+        CsrUint32 priority_q;
+
+        /* Map the frame priority to a traffic queue index. */
+        frame_priority = GET_PACKED_MA_PACKET_REQUEST_FRAME_PRIORITY(sigptr);
+        priority_q = unifi_frame_priority_to_queue((CSR_PRIORITY)frame_priority);
+
+        sig_soft_q = &card->fh_traffic_queue[priority_q];
+    }
+    else
+    {
+        sig_soft_q = &card->fh_command_queue;
+    }
+
+    /* Check that the fh_data_queue has a free slot */
+    if (!CSR_WIFI_HIP_Q_SLOTS_FREE(sig_soft_q))
+    {
+        unifi_notice(card->ospriv, "unifi_send_resources_available: %s full\n",
+                     sig_soft_q->name);
+        return CSR_WIFI_HIP_RESULT_NO_SPACE;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_send_resources_available() */
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_signals.c
@@ -0,0 +1,1313 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+
+/* Generated by hip_dd_l_c_gen.pl */
+
+#include "csr_wifi_hip_signals.h"
+
+#include "csr_wifi_hip_unifi.h"
+
+CsrInt32 SigGetSize(const CSR_SIGNAL *aSignal)
+{
+    switch (aSignal->SignalPrimitiveHeader.SignalId)
+    {
+        case CSR_MA_PACKET_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MA_PACKET_REQUEST);
+        case CSR_MA_PACKET_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MA_PACKET_CONFIRM);
+        case CSR_MA_PACKET_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MA_PACKET_INDICATION);
+        case CSR_MA_PACKET_CANCEL_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MA_PACKET_CANCEL_REQUEST);
+        case CSR_MA_VIF_AVAILABILITY_RESPONSE_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MA_VIF_AVAILABILITY_RESPONSE);
+        case CSR_MA_VIF_AVAILABILITY_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MA_VIF_AVAILABILITY_INDICATION);
+        case CSR_MA_PACKET_ERROR_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MA_PACKET_ERROR_INDICATION);
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_RESET_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_RESET_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_GET_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_GET_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SET_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SET_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_GET_NEXT_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_GET_NEXT_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_POWERMGT_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_POWERMGT_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SCAN_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SCAN_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_HL_SYNC_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_HL_SYNC_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_MEASURE_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_MEASURE_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_MEASURE_INDICATION);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SETKEYS_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SETKEYS_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DELETEKEYS_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DELETEKEYS_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECTED_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_CONNECTED_INDICATION);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CANCEL_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SCAN_CANCEL_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_HL_SYNC_CANCEL_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_HL_SYNC_CANCEL_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_PERIODIC_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_PERIODIC_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_PERIODIC_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_PERIODIC_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SET_PACKET_FILTER_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SET_PACKET_FILTER_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_STOP_MEASURE_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_STOP_MEASURE_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_TRIGGERED_GET_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_TRIGGERED_GET_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_TRIGGERED_GET_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_TRIGGERED_GET_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_TRIGGERED_GET_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_TRIGGERED_GET_INDICATION);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_BLACKOUT_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_BLACKOUT_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLACKOUT_ENDED_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_BLACKOUT_ENDED_INDICATION);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_BLACKOUT_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_BLACKOUT_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_RX_TRIGGER_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_RX_TRIGGER_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_RX_TRIGGER_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_RX_TRIGGER_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_CONNECT_STATUS_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_CONNECT_STATUS_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_TEMPLATE_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_TEMPLATE_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_CONFIG_QUEUE_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_CONFIG_QUEUE_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_TSPEC_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_TSPEC_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_TSPEC_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_DEL_TSPEC_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_START_AGGREGATION_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_START_AGGREGATION_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLOCKACK_ERROR_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_BLOCKACK_ERROR_INDICATION);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_STOP_AGGREGATION_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_STOP_AGGREGATION_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SM_START_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SM_START_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_LEAVE_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_LEAVE_CONFIRM);
+#endif
+        case CSR_MLME_SET_TIM_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SET_TIM_REQUEST);
+        case CSR_MLME_SET_TIM_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SET_TIM_CONFIRM);
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_GET_KEY_SEQUENCE_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_GET_KEY_SEQUENCE_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SET_CHANNEL_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_SET_CHANNEL_CONFIRM);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST);
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM);
+#endif
+        case CSR_DEBUG_STRING_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_DEBUG_STRING_INDICATION);
+        case CSR_DEBUG_WORD16_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_DEBUG_WORD16_INDICATION);
+        case CSR_DEBUG_GENERIC_REQUEST_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_DEBUG_GENERIC_REQUEST);
+        case CSR_DEBUG_GENERIC_CONFIRM_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_DEBUG_GENERIC_CONFIRM);
+        case CSR_DEBUG_GENERIC_INDICATION_ID:
+            return CsrOffsetOf(struct CSR_SIGNAL_PRIMITIVE, u) + sizeof(CSR_DEBUG_GENERIC_INDICATION);
+        default:
+            return 0;
+    }
+}
+
+
+CsrInt32 SigGetDataRefs(CSR_SIGNAL *aSignal, CSR_DATAREF **aDataRef)
+{
+    CsrInt32 numRefs = 0;
+
+    switch (aSignal->SignalPrimitiveHeader.SignalId)
+    {
+        case CSR_MA_PACKET_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MaPacketRequest.Data;
+            aDataRef[numRefs++] = &aSignal->u.MaPacketRequest.Dummydataref2;
+            break;
+        case CSR_MA_PACKET_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MaPacketConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MaPacketConfirm.Dummydataref2;
+            break;
+        case CSR_MA_PACKET_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.MaPacketIndication.Data;
+            aDataRef[numRefs++] = &aSignal->u.MaPacketIndication.Dummydataref2;
+            break;
+        case CSR_MA_PACKET_CANCEL_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MaPacketCancelRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MaPacketCancelRequest.Dummydataref2;
+            break;
+        case CSR_MA_VIF_AVAILABILITY_RESPONSE_ID:
+            aDataRef[numRefs++] = &aSignal->u.MaVifAvailabilityResponse.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MaVifAvailabilityResponse.Dummydataref2;
+            break;
+        case CSR_MA_VIF_AVAILABILITY_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.MaVifAvailabilityIndication.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MaVifAvailabilityIndication.Dummydataref2;
+            break;
+        case CSR_MA_PACKET_ERROR_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.MaPacketErrorIndication.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MaPacketErrorIndication.Dummydataref2;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeResetRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeResetRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeResetConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeResetConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetRequest.MibAttribute;
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetConfirm.MibAttributeValue;
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetRequest.MibAttributeValue;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetConfirm.MibAttributeValue;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetNextRequest.MibAttribute;
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetNextRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetNextConfirm.MibAttributeValue;
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetNextConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmePowermgtRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmePowermgtRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmePowermgtConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmePowermgtConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeScanRequest.ChannelList;
+            aDataRef[numRefs++] = &aSignal->u.MlmeScanRequest.InformationElements;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeScanConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeScanConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeHlSyncRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeHlSyncRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeHlSyncConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeHlSyncConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeMeasureRequest.MeasurementRequestSet;
+            aDataRef[numRefs++] = &aSignal->u.MlmeMeasureRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeMeasureConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeMeasureConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeMeasureIndication.MeasurementReportSet;
+            aDataRef[numRefs++] = &aSignal->u.MlmeMeasureIndication.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetkeysRequest.Key;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetkeysRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetkeysConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetkeysConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDeletekeysRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDeletekeysRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDeletekeysConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDeletekeysConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAutonomousScanLossIndication.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAutonomousScanLossIndication.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECTED_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeConnectedIndication.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeConnectedIndication.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CANCEL_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeScanCancelRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeScanCancelRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeHlSyncCancelRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeHlSyncCancelRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeHlSyncCancelConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeHlSyncCancelConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddPeriodicRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddPeriodicRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddPeriodicConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddPeriodicConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelPeriodicRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelPeriodicRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelPeriodicConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelPeriodicConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddAutonomousScanRequest.ChannelList;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddAutonomousScanRequest.InformationElements;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddAutonomousScanConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddAutonomousScanConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelAutonomousScanRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelAutonomousScanRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelAutonomousScanConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelAutonomousScanConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetPacketFilterRequest.InformationElements;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetPacketFilterRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetPacketFilterConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetPacketFilterConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeStopMeasureRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeStopMeasureRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeStopMeasureConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeStopMeasureConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmePauseAutonomousScanRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmePauseAutonomousScanRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmePauseAutonomousScanConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmePauseAutonomousScanConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAutonomousScanDoneIndication.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAutonomousScanDoneIndication.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTriggeredGetRequest.MibAttribute;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTriggeredGetRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTriggeredGetConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTriggeredGetConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelTriggeredGetRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelTriggeredGetRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelTriggeredGetConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelTriggeredGetConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_TRIGGERED_GET_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeTriggeredGetIndication.MibAttributeValue;
+            aDataRef[numRefs++] = &aSignal->u.MlmeTriggeredGetIndication.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddBlackoutRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddBlackoutRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddBlackoutConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddBlackoutConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLACKOUT_ENDED_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeBlackoutEndedIndication.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeBlackoutEndedIndication.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelBlackoutRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelBlackoutRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelBlackoutConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelBlackoutConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddRxTriggerRequest.InformationElements;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddRxTriggerRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddRxTriggerConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddRxTriggerConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelRxTriggerRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelRxTriggerRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelRxTriggerConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelRxTriggerConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeConnectStatusRequest.InformationElements;
+            aDataRef[numRefs++] = &aSignal->u.MlmeConnectStatusRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeConnectStatusConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeConnectStatusConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeModifyBssParameterRequest.Data;
+            aDataRef[numRefs++] = &aSignal->u.MlmeModifyBssParameterRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeModifyBssParameterConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeModifyBssParameterConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTemplateRequest.Data1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTemplateRequest.Data2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTemplateConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTemplateConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeConfigQueueRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeConfigQueueRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeConfigQueueConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeConfigQueueConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTspecRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTspecRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTspecConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddTspecConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelTspecRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelTspecRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelTspecConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeDelTspecConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeStartAggregationRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeStartAggregationRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeStartAggregationConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeStartAggregationConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLOCKACK_ERROR_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeBlockackErrorIndication.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeBlockackErrorIndication.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeStopAggregationRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeStopAggregationRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeStopAggregationConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeStopAggregationConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSmStartRequest.Beacon;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSmStartRequest.BssParameters;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSmStartConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSmStartConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeLeaveRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeLeaveRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeLeaveConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeLeaveConfirm.Dummydataref2;
+            break;
+#endif
+        case CSR_MLME_SET_TIM_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetTimRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetTimRequest.Dummydataref2;
+            break;
+        case CSR_MLME_SET_TIM_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetTimConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetTimConfirm.Dummydataref2;
+            break;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetKeySequenceRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetKeySequenceRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetKeySequenceConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeGetKeySequenceConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetChannelRequest.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetChannelRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetChannelConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeSetChannelConfirm.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddMulticastAddressRequest.Data;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddMulticastAddressRequest.Dummydataref2;
+            break;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddMulticastAddressConfirm.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.MlmeAddMulticastAddressConfirm.Dummydataref2;
+            break;
+#endif
+        case CSR_DEBUG_STRING_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.DebugStringIndication.DebugMessage;
+            aDataRef[numRefs++] = &aSignal->u.DebugStringIndication.Dummydataref2;
+            break;
+        case CSR_DEBUG_WORD16_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.DebugWord16Indication.Dummydataref1;
+            aDataRef[numRefs++] = &aSignal->u.DebugWord16Indication.Dummydataref2;
+            break;
+        case CSR_DEBUG_GENERIC_REQUEST_ID:
+            aDataRef[numRefs++] = &aSignal->u.DebugGenericRequest.DebugVariable;
+            aDataRef[numRefs++] = &aSignal->u.DebugGenericRequest.Dummydataref2;
+            break;
+        case CSR_DEBUG_GENERIC_CONFIRM_ID:
+            aDataRef[numRefs++] = &aSignal->u.DebugGenericConfirm.DebugVariable;
+            aDataRef[numRefs++] = &aSignal->u.DebugGenericConfirm.Dummydataref2;
+            break;
+        case CSR_DEBUG_GENERIC_INDICATION_ID:
+            aDataRef[numRefs++] = &aSignal->u.DebugGenericIndication.DebugVariable;
+            aDataRef[numRefs++] = &aSignal->u.DebugGenericIndication.Dummydataref2;
+            break;
+        default:
+            return 0;
+    }
+    return numRefs;
+}
+
+
+CsrUint32 SigGetFilterPos(CsrUint16 aSigID)
+{
+    switch (aSigID)
+    {
+        case CSR_MA_PACKET_REQUEST_ID:
+            return 0x00000001;
+        case CSR_MA_PACKET_CONFIRM_ID:
+            return 0x00000002;
+        case CSR_MA_PACKET_INDICATION_ID:
+            return 0x00000004;
+        case CSR_MA_PACKET_CANCEL_REQUEST_ID:
+            return 0x00000008;
+        case CSR_MA_VIF_AVAILABILITY_RESPONSE_ID:
+            return 0x00000010;
+        case CSR_MA_VIF_AVAILABILITY_INDICATION_ID:
+            return 0x00000020;
+        case CSR_MA_PACKET_ERROR_INDICATION_ID:
+            return 0x00000040;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_REQUEST_ID:
+            return 0x00000080;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_RESET_CONFIRM_ID:
+            return 0x00000100;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_REQUEST_ID:
+            return 0x00000200;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_CONFIRM_ID:
+            return 0x00000400;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_REQUEST_ID:
+            return 0x00000800;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CONFIRM_ID:
+            return 0x00001000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_REQUEST_ID:
+            return 0x00002000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_NEXT_CONFIRM_ID:
+            return 0x00004000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_REQUEST_ID:
+            return 0x00008000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_POWERMGT_CONFIRM_ID:
+            return 0x00010001;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_REQUEST_ID:
+            return 0x00010002;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CONFIRM_ID:
+            return 0x00010004;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_REQUEST_ID:
+            return 0x00010008;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CONFIRM_ID:
+            return 0x00010010;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_REQUEST_ID:
+            return 0x00010020;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_CONFIRM_ID:
+            return 0x00010040;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MEASURE_INDICATION_ID:
+            return 0x00010080;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_REQUEST_ID:
+            return 0x00010100;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SETKEYS_CONFIRM_ID:
+            return 0x00010200;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_REQUEST_ID:
+            return 0x00010400;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DELETEKEYS_CONFIRM_ID:
+            return 0x00010800;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION_ID:
+            return 0x00011000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECTED_INDICATION_ID:
+            return 0x00012000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SCAN_CANCEL_REQUEST_ID:
+            return 0x00014000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_REQUEST_ID:
+            return 0x00018000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_HL_SYNC_CANCEL_CONFIRM_ID:
+            return 0x00020001;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_REQUEST_ID:
+            return 0x00020002;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_PERIODIC_CONFIRM_ID:
+            return 0x00020004;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_REQUEST_ID:
+            return 0x00020008;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_PERIODIC_CONFIRM_ID:
+            return 0x00020010;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST_ID:
+            return 0x00020020;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM_ID:
+            return 0x00020040;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST_ID:
+            return 0x00020080;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM_ID:
+            return 0x00020100;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_REQUEST_ID:
+            return 0x00020200;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_PACKET_FILTER_CONFIRM_ID:
+            return 0x00020400;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_REQUEST_ID:
+            return 0x00020800;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_MEASURE_CONFIRM_ID:
+            return 0x00021000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST_ID:
+            return 0x00022000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM_ID:
+            return 0x00024000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION_ID:
+            return 0x00028000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_REQUEST_ID:
+            return 0x00030001;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TRIGGERED_GET_CONFIRM_ID:
+            return 0x00030002;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_REQUEST_ID:
+            return 0x00030004;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TRIGGERED_GET_CONFIRM_ID:
+            return 0x00030008;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_TRIGGERED_GET_INDICATION_ID:
+            return 0x00030010;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_REQUEST_ID:
+            return 0x00030020;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_BLACKOUT_CONFIRM_ID:
+            return 0x00030040;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLACKOUT_ENDED_INDICATION_ID:
+            return 0x00030080;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_REQUEST_ID:
+            return 0x00030100;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_BLACKOUT_CONFIRM_ID:
+            return 0x00030200;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_REQUEST_ID:
+            return 0x00030400;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_RX_TRIGGER_CONFIRM_ID:
+            return 0x00030800;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_REQUEST_ID:
+            return 0x00031000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_RX_TRIGGER_CONFIRM_ID:
+            return 0x00032000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_REQUEST_ID:
+            return 0x00034000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONNECT_STATUS_CONFIRM_ID:
+            return 0x00038000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST_ID:
+            return 0x00040001;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM_ID:
+            return 0x00040002;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_REQUEST_ID:
+            return 0x00040004;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TEMPLATE_CONFIRM_ID:
+            return 0x00040008;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_REQUEST_ID:
+            return 0x00040010;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_CONFIG_QUEUE_CONFIRM_ID:
+            return 0x00040020;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_REQUEST_ID:
+            return 0x00040040;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_TSPEC_CONFIRM_ID:
+            return 0x00040080;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_REQUEST_ID:
+            return 0x00040100;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_DEL_TSPEC_CONFIRM_ID:
+            return 0x00040200;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_REQUEST_ID:
+            return 0x00040400;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_START_AGGREGATION_CONFIRM_ID:
+            return 0x00040800;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_BLOCKACK_ERROR_INDICATION_ID:
+            return 0x00041000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_REQUEST_ID:
+            return 0x00042000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_STOP_AGGREGATION_CONFIRM_ID:
+            return 0x00044000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_REQUEST_ID:
+            return 0x00048000;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SM_START_CONFIRM_ID:
+            return 0x00050001;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_REQUEST_ID:
+            return 0x00050002;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_LEAVE_CONFIRM_ID:
+            return 0x00050004;
+#endif
+        case CSR_MLME_SET_TIM_REQUEST_ID:
+            return 0x00050008;
+        case CSR_MLME_SET_TIM_CONFIRM_ID:
+            return 0x00050010;
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_REQUEST_ID:
+            return 0x00050020;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_GET_KEY_SEQUENCE_CONFIRM_ID:
+            return 0x00050040;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_REQUEST_ID:
+            return 0x00050080;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_SET_CHANNEL_CONFIRM_ID:
+            return 0x00050100;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST_ID:
+            return 0x00050200;
+#endif
+#ifdef CSR_WIFI_HIP_FULL_SIGNAL_SET
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM_ID:
+            return 0x00050400;
+#endif
+        case CSR_DEBUG_STRING_INDICATION_ID:
+            return 0x00050800;
+        case CSR_DEBUG_WORD16_INDICATION_ID:
+            return 0x00051000;
+        case CSR_DEBUG_GENERIC_REQUEST_ID:
+            return 0x00052000;
+        case CSR_DEBUG_GENERIC_CONFIRM_ID:
+            return 0x00054000;
+        case CSR_DEBUG_GENERIC_INDICATION_ID:
+            return 0x00058000;
+        default:
+            break;
+    }
+    return 0xffffffff;
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_signals.h
@@ -0,0 +1,137 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ *****************************************************************************
+ *
+ * FILE: csr_wifi_hip_signals.h
+ *
+ * PURPOSE:
+ *      Header file wrapping the auto-generated code in csr_wifi_hip_sigs.h
+ *      and csr_wifi_hip_signals.c -
+ *      csr_wifi_hip_sigs.h provides structures defining UniFi signals and
+ *      csr_wifi_hip_signals.c provides SigGetSize() and SigGetDataRefs().
+ *
+ *****************************************************************************
+ */
+#ifndef __CSR_WIFI_HIP_SIGNALS_H__
+#define __CSR_WIFI_HIP_SIGNALS_H__
+
+#include "csr_types.h"
+#include "csr_wifi_hip_sigs.h"
+
+
+/****************************************************************************/
+/* INFORMATION ELEMENTS */
+/****************************************************************************/
+
+/* Information Element ID's - shouldn't be in here, but nowhere better yet */
+#define IE_SSID_ID                       0
+#define IE_SUPPORTED_RATES_ID            1
+#define IE_FH_PARAM_SET_ID               2
+#define IE_DS_PARAM_SET_ID               3
+#define IE_CF_PARAM_SET_ID               4
+#define IE_TIM_ID                        5
+#define IE_IBSS_PARAM_SET_ID             6
+#define IE_COUNTRY_ID                    7
+#define IE_HOPPING_PATTERN_PARAMS_ID     8
+#define IE_HOPPING_PATTERN_TABLE_ID      9
+#define IE_REQUEST_ID                    10
+#define IE_QBSS_LOAD_ID                  11
+#define IE_EDCA_PARAM_SET_ID             12
+#define IE_TRAFFIC_SPEC_ID               13
+#define IE_TRAFFIC_CLASS_ID              14
+#define IE_SCHEDULE_ID                   15
+#define IE_CHALLENGE_TEXT_ID             16
+#define IE_POWER_CONSTRAINT_ID           32
+#define IE_POWER_CAPABILITY_ID           33
+#define IE_TPC_REQUEST_ID                34
+#define IE_TPC_REPORT_ID                 35
+#define IE_SUPPORTED_CHANNELS_ID         36
+#define IE_CHANNEL_SWITCH_ANNOUNCE_ID    37
+#define IE_MEASUREMENT_REQUEST_ID        38
+#define IE_MEASUREMENT_REPORT_ID         39
+#define IE_QUIET_ID                      40
+#define IE_IBSS_DFS_ID                   41
+#define IE_ERP_INFO_ID                   42
+#define IE_TS_DELAY_ID                   43
+#define IE_TCLAS_PROCESSING_ID           44
+#define IE_QOS_CAPABILITY_ID             46
+#define IE_RSN_ID                        48
+#define IE_EXTENDED_SUPPORTED_RATES_ID   50
+#define IE_AP_CHANNEL_REPORT_ID          52
+#define IE_RCPI_ID                       53
+#define IE_WPA_ID                       221
+
+
+/* The maximum number of data references in a signal structure */
+#define UNIFI_MAX_DATA_REFERENCES 2
+
+/* The space to allow for a wire-format signal structure */
+#define UNIFI_PACKED_SIGBUF_SIZE   64
+
+
+/******************************************************************************/
+/* SIGNAL PARAMETER VALUES */
+/******************************************************************************/
+
+/* ifIndex */
+#define UNIFI_IF_2G4 1
+#define UNIFI_IF_5G  2
+
+/* SendProcessId */
+#define HOST_PROC_ID 0xc000
+
+#define SIG_CAP_ESS             0x0001
+#define SIG_CAP_IBSS            0x0002
+#define SIG_CAP_CF_POLLABLE     0x0004
+#define SIG_CAP_CF_POLL_REQUEST 0x0008
+#define SIG_CAP_PRIVACY         0x0010
+#define SIG_CAP_SHORT_PREAMBLE  0x0020
+#define SIG_CAP_DSSSOFDM        0x2000
+
+/******************************************************************************/
+/* FUNCTION DECLARATIONS */
+/******************************************************************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/******************************************************************************
+ * SigGetNumDataRefs - Retrieve pointers to data-refs from a signal.
+ *
+ * PARAMETERS:
+ *   aSignal  - Pointer to signal to retrieve the data refs of.
+ *   aDataRef - Address of a pointer to the structure that the data refs
+ *              pointers will be stored.
+ *
+ * RETURNS:
+ *   The number of data-refs in the signal.
+ */
+CsrInt32 SigGetDataRefs(CSR_SIGNAL *aSignal, CSR_DATAREF **aDataRef);
+
+/******************************************************************************
+ * SigGetSize - Retrieve the size (in bytes) of a given signal.
+ *
+ * PARAMETERS:
+ *   aSignal  - Pointer to signal to retrieve size of.
+ *
+ * RETURNS:
+ *   The size (in bytes) of the given signal.
+ */
+CsrInt32 SigGetSize(const CSR_SIGNAL *aSignal);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __CSR_WIFI_HIP_SIGNALS_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_sigs.h
@@ -0,0 +1,1425 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+
+/* Generated by hip_dd_l_h_gen.pl */
+
+#ifndef CSR_WIFI_HIP_SIGS_H
+#define CSR_WIFI_HIP_SIGS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef CsrInt16 csr_place_holding_type;
+
+typedef CsrUint16 CSR_ASSOCIATION_ID;
+
+typedef CsrUint16 CSR_AUTONOMOUS_SCAN_ID;
+
+typedef CsrUint16 CSR_BEACON_PERIODS;
+
+typedef CsrUint16 CSR_BLACKOUT_ID;
+
+typedef enum CSR_BLACKOUT_SOURCE
+{
+    CSR_DOT11_LOCAL                               = 0x0000,
+    CSR_DOT11_REMOTE                              = 0x0001,
+    CSR_OTHER_RADIO                               = 0x0002,
+    CSR_NOT_LINKED                                = 0x0004
+} CSR_BLACKOUT_SOURCE;
+
+typedef enum CSR_BLACKOUT_TYPE
+{
+    CSR_LOCAL_DEVICE_ONLY                         = 0x0001,
+    CSR_SPECIFIED_PEER                            = 0x0002,
+    CSR_CURRENT_CHANNEL                           = 0x0004,
+    CSR_P2P                                       = 0x0008
+} CSR_BLACKOUT_TYPE;
+
+typedef enum CSR_BOOT_LOADER_OPERATION
+{
+    CSR_BOOT_LOADER_IDLE                          = 0x00,
+    CSR_BOOT_LOADER_RESTART                       = 0x01,
+    CSR_BOOT_LOADER_PATCH                         = 0x02,
+    CSR_BOOT_LOADER_IMAGE_0                       = 0x10,
+    CSR_BOOT_LOADER_IMAGE_1                       = 0x11,
+    CSR_BOOT_LOADER_IMAGE_2                       = 0x12,
+    CSR_BOOT_LOADER_IMAGE_3                       = 0x13
+} CSR_BOOT_LOADER_OPERATION;
+
+typedef CsrUint16 CSR_CAPABILITY_INFORMATION;
+
+typedef CsrUint16 CSR_CHANNEL_STARTING_FACTOR;
+
+typedef CsrUint32 CSR_CIPHER_SUITE_SELECTOR;
+
+typedef CsrUint32 CSR_CLIENT_TAG;
+
+typedef enum CSR_CONNECTION_STATUS
+{
+    CSR_DISCONNECTED                              = 0x0000,
+    CSR_CONNECTED_AWAKE                           = 0x0001
+} CSR_CONNECTION_STATUS;
+
+typedef CsrInt16 CSR_DECIBELS;
+
+typedef enum CSR_DIRECTION
+{
+    CSR_TRANSMIT                                  = 0x0000,
+    CSR_RECEIVE                                   = 0x0001,
+    CSR_BIDIRECTIONAL                             = 0x0003
+} CSR_DIRECTION;
+
+typedef enum CSR_FRAME_TYPE
+{
+    CSR_RESERVED                                  = 0x0000,
+    CSR_BEACON                                    = 0x0001,
+    CSR_PROBE_RESPONSE                            = 0x0002,
+    CSR_BEACON_AND_PROBE_RESPONSE                 = 0x0003,
+    CSR_PROBE_REQUEST                             = 0x0004
+} CSR_FRAME_TYPE;
+
+typedef CsrUint32 CSR_IPV4_ADDRESS;
+
+typedef enum CSR_IFINTERFACE
+{
+    CSR_INDEX_2G4                                 = 0x0001,
+    CSR_INDEX_5G                                  = 0x0002
+} CSR_IFINTERFACE;
+
+typedef enum CSR_KEY_TYPE
+{
+    CSR_GROUP                                     = 0x0000,
+    CSR_PAIRWISE                                  = 0x0001,
+    CSR_PEER_KEY                                  = 0x0002,
+    CSR_IGTK                                      = 0x0003
+} CSR_KEY_TYPE;
+
+typedef enum CSR_LOADER_OPERATION
+{
+    CSR_LOADER_IDLE                               = 0x0000,
+    CSR_LOADER_COPY                               = 0x0001
+} CSR_LOADER_OPERATION;
+
+typedef struct CSR_MAC_ADDRESS
+{
+    CsrUint8 x[6];
+} CSR_MACADDRESS;
+
+typedef enum CSR_MIB_STATUS
+{
+    CSR_MIB_SUCCESSFUL                            = 0x0000,
+    CSR_MIB_INVALID_PARAMETERS                    = 0x0001,
+    CSR_MIB_WRITE_ONLY                            = 0x0002,
+    CSR_MIB_READ_ONLY                             = 0x0003
+} CSR_MIB_STATUS;
+
+typedef enum CSR_MEMORY_SPACE
+{
+    CSR_NONE                                      = 0x00,
+    CSR_SHARED_DATA_MEMORY                        = 0x01,
+    CSR_EXTERNAL_FLASH_MEMORY                     = 0x02,
+    CSR_EXTERNAL_SRAM                             = 0x03,
+    CSR_REGISTERS                                 = 0x04,
+    CSR_PHY_PROCESSOR_DATA_MEMORY                 = 0x10,
+    CSR_PHY_PROCESSOR_PROGRAM_MEMORY              = 0x11,
+    CSR_PHY_PROCESSOR_ROM                         = 0x12,
+    CSR_MAC_PROCESSOR_DATA_MEMORY                 = 0x20,
+    CSR_MAC_PROCESSOR_PROGRAM_MEMORY              = 0x21,
+    CSR_MAC_PROCESSOR_ROM                         = 0x22,
+    CSR_BT_PROCESSOR_DATA_MEMORY                  = 0x30,
+    CSR_BT_PROCESSOR_PROGRAM_MEMORY               = 0x31,
+    CSR_BT_PROCESSOR_ROM                          = 0x32
+} CSR_MEMORY_SPACE;
+
+typedef CsrUint16 CSR_MICROSECONDS16;
+
+typedef CsrUint32 CSR_MICROSECONDS32;
+
+typedef CsrUint16 CSR_NATURAL16;
+
+typedef enum CSR_PS_SCHEME
+{
+    CSR_LEGACY_PS                                 = 0x0001,
+    CSR_U_APSD                                    = 0x0002,
+    CSR_S_APSD                                    = 0x0004
+} CSR_PS_SCHEME;
+
+typedef enum CSR_PACKET_FILTER_MODE
+{
+    CSR_PFM_OPT_OUT                               = 0x0000,
+    CSR_PFM_OPT_IN                                = 0x0003
+} CSR_PACKET_FILTER_MODE;
+
+typedef CsrUint16 CSR_PERIODIC_ID;
+
+typedef enum CSR_PERIODIC_SCHEDULING_MODE
+{
+    CSR_PSM_PERIODIC_SCHEDULE_PS_POLL             = 0x0001,
+    CSR_PSM_PERIODIC_SCHEDULE_PM_BIT              = 0x0002,
+    CSR_PSM_PERIODIC_SCHEDULE_UAPSD               = 0x0004,
+    CSR_PSM_PERIODIC_SCHEDULE_SAPSD               = 0x0008
+} CSR_PERIODIC_SCHEDULING_MODE;
+
+typedef enum CSR_POWER_MANAGEMENT_MODE
+{
+    CSR_PMM_ACTIVE_MODE                           = 0x0000,
+    CSR_PMM_POWER_SAVE                            = 0x0001,
+    CSR_PMM_FAST_POWER_SAVE                       = 0x0002
+} CSR_POWER_MANAGEMENT_MODE;
+
+typedef enum CSR_PRIORITY
+{
+    CSR_QOS_UP0                                   = 0x0000,
+    CSR_QOS_UP1                                   = 0x0001,
+    CSR_QOS_UP2                                   = 0x0002,
+    CSR_QOS_UP3                                   = 0x0003,
+    CSR_QOS_UP4                                   = 0x0004,
+    CSR_QOS_UP5                                   = 0x0005,
+    CSR_QOS_UP6                                   = 0x0006,
+    CSR_QOS_UP7                                   = 0x0007,
+    CSR_CONTENTION                                = 0x8000,
+    CSR_MANAGEMENT                                = 0x8010
+} CSR_PRIORITY;
+
+typedef enum CSR_REASON_CODE
+{
+    CSR_UNSPECIFIED_REASON                        = 0x0001,
+    CSR_INVALID_INFORMATION_ELEMENT               = 0x000d,
+    CSR_QOS_UNSPECIFIED_REASON                    = 0x0020,
+    CSR_QOS_EXCESSIVE_NOT_ACK                     = 0x0022,
+    CSR_QOS_TXOP_LIMIT_EXCEEDED                   = 0x0023,
+    CSR_QSTA_LEAVING                              = 0x0024,
+    CSR_UNKNOWN_BA                                = 0x0026,
+    CSR_UNKNOWN_TS                                = 0x0026,
+    CSR_TIMEOUT                                   = 0x0027
+} CSR_REASON_CODE;
+
+typedef enum CSR_RECEPTION_STATUS
+{
+    CSR_RX_SUCCESS                                = 0x0000,
+    CSR_RX_FAILURE_UNSPECIFIED                    = 0x0001,
+    CSR_MICHAEL_MIC_ERROR                         = 0x0002,
+    CSR_DECRYPTION_ERROR                          = 0x0003,
+    CSR_NO_TEMPORAL_KEY_AVAILABLE                 = 0x0004,
+    CSR_UNSUPPORTED_MODULATION                    = 0x0011,
+    CSR_BAD_FCS                                   = 0x0012,
+    CSR_BAD_SIGNAL                                = 0x0013
+} CSR_RECEPTION_STATUS;
+
+typedef enum CSR_RESULT_CODE
+{
+    CSR_RC_SUCCESS                                = 0x0000,
+    CSR_RC_UNSPECIFIED_FAILURE                    = 0x0001,
+    CSR_RC_REFUSED                                = 0x0003,
+    CSR_RC_INVALID_PARAMETERS                     = 0x0026,
+    CSR_RC_REJECTED_INVALID_IE                    = 0x0028,
+    CSR_RC_REJECTED_INVALID_GROUP_CIPHER          = 0x0029,
+    CSR_RC_REJECTED_INVALID_PAIRWISE_CIPHER       = 0x002a,
+    CSR_RC_TIMEOUT                                = 0x8000,
+    CSR_RC_TOO_MANY_SIMULTANEOUS_REQUESTS         = 0x8001,
+    CSR_RC_BSS_ALREADY_STARTED_OR_JOINED          = 0x8002,
+    CSR_RC_NOT_SUPPORTED                          = 0x8003,
+    CSR_RC_TRANSMISSION_FAILURE                   = 0x8004,
+    CSR_RC_RESET_REQUIRED_BEFORE_START            = 0x8006,
+    CSR_RC_INSUFFICIENT_RESOURCE                  = 0x8007,
+    CSR_RC_NO_BUFFERED_BROADCAST_MULTICAST_FRAMES = 0x8008,
+    CSR_RC_INVALID_UNICAST_CIPHER                 = 0xf02f,
+    CSR_RC_INVALID_MULTICAST_CIPHER               = 0xf030
+} CSR_RESULT_CODE;
+
+typedef enum CSR_SCAN_TYPE
+{
+    CSR_SC_ACTIVE_SCAN                            = 0x0000,
+    CSR_SC_PASSIVE_SCAN                           = 0x0001
+} CSR_SCAN_TYPE;
+
+typedef enum CSR_SIGNAL_ID
+{
+    CSR_MA_PACKET_REQUEST_ID                      = 0x0110,
+    CSR_MA_PACKET_CONFIRM_ID                      = 0x0111,
+    CSR_MA_PACKET_INDICATION_ID                   = 0x0113,
+    CSR_MA_PACKET_CANCEL_REQUEST_ID               = 0x0114,
+    CSR_MA_VIF_AVAILABILITY_RESPONSE_ID           = 0x0116,
+    CSR_MA_VIF_AVAILABILITY_INDICATION_ID         = 0x0117,
+    CSR_MA_PACKET_ERROR_INDICATION_ID             = 0x011b,
+    CSR_MLME_RESET_REQUEST_ID                     = 0x0200,
+    CSR_MLME_RESET_CONFIRM_ID                     = 0x0201,
+    CSR_MLME_GET_REQUEST_ID                       = 0x0204,
+    CSR_MLME_GET_CONFIRM_ID                       = 0x0205,
+    CSR_MLME_SET_REQUEST_ID                       = 0x0208,
+    CSR_MLME_SET_CONFIRM_ID                       = 0x0209,
+    CSR_MLME_GET_NEXT_REQUEST_ID                  = 0x020c,
+    CSR_MLME_GET_NEXT_CONFIRM_ID                  = 0x020d,
+    CSR_MLME_POWERMGT_REQUEST_ID                  = 0x0210,
+    CSR_MLME_POWERMGT_CONFIRM_ID                  = 0x0211,
+    CSR_MLME_SCAN_REQUEST_ID                      = 0x0214,
+    CSR_MLME_SCAN_CONFIRM_ID                      = 0x0215,
+    CSR_MLME_HL_SYNC_REQUEST_ID                   = 0x0244,
+    CSR_MLME_HL_SYNC_CONFIRM_ID                   = 0x0245,
+    CSR_MLME_MEASURE_REQUEST_ID                   = 0x0258,
+    CSR_MLME_MEASURE_CONFIRM_ID                   = 0x0259,
+    CSR_MLME_MEASURE_INDICATION_ID                = 0x025b,
+    CSR_MLME_SETKEYS_REQUEST_ID                   = 0x0268,
+    CSR_MLME_SETKEYS_CONFIRM_ID                   = 0x0269,
+    CSR_MLME_DELETEKEYS_REQUEST_ID                = 0x026c,
+    CSR_MLME_DELETEKEYS_CONFIRM_ID                = 0x026d,
+    CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION_ID   = 0x0287,
+    CSR_MLME_CONNECTED_INDICATION_ID              = 0x028b,
+    CSR_MLME_SCAN_CANCEL_REQUEST_ID               = 0x028c,
+    CSR_MLME_HL_SYNC_CANCEL_REQUEST_ID            = 0x0298,
+    CSR_MLME_HL_SYNC_CANCEL_CONFIRM_ID            = 0x0299,
+    CSR_MLME_ADD_PERIODIC_REQUEST_ID              = 0x02a0,
+    CSR_MLME_ADD_PERIODIC_CONFIRM_ID              = 0x02a1,
+    CSR_MLME_DEL_PERIODIC_REQUEST_ID              = 0x02a4,
+    CSR_MLME_DEL_PERIODIC_CONFIRM_ID              = 0x02a5,
+    CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST_ID       = 0x02a8,
+    CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM_ID       = 0x02a9,
+    CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST_ID       = 0x02ac,
+    CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM_ID       = 0x02ad,
+    CSR_MLME_SET_PACKET_FILTER_REQUEST_ID         = 0x02b8,
+    CSR_MLME_SET_PACKET_FILTER_CONFIRM_ID         = 0x02b9,
+    CSR_MLME_STOP_MEASURE_REQUEST_ID              = 0x02bc,
+    CSR_MLME_STOP_MEASURE_CONFIRM_ID              = 0x02bd,
+    CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST_ID     = 0x02cc,
+    CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM_ID     = 0x02cd,
+    CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION_ID   = 0x02db,
+    CSR_MLME_ADD_TRIGGERED_GET_REQUEST_ID         = 0x02dc,
+    CSR_MLME_ADD_TRIGGERED_GET_CONFIRM_ID         = 0x02dd,
+    CSR_MLME_DEL_TRIGGERED_GET_REQUEST_ID         = 0x02e0,
+    CSR_MLME_DEL_TRIGGERED_GET_CONFIRM_ID         = 0x02e1,
+    CSR_MLME_TRIGGERED_GET_INDICATION_ID          = 0x02e7,
+    CSR_MLME_ADD_BLACKOUT_REQUEST_ID              = 0x02f8,
+    CSR_MLME_ADD_BLACKOUT_CONFIRM_ID              = 0x02f9,
+    CSR_MLME_BLACKOUT_ENDED_INDICATION_ID         = 0x02fb,
+    CSR_MLME_DEL_BLACKOUT_REQUEST_ID              = 0x02fc,
+    CSR_MLME_DEL_BLACKOUT_CONFIRM_ID              = 0x02fd,
+    CSR_MLME_ADD_RX_TRIGGER_REQUEST_ID            = 0x0304,
+    CSR_MLME_ADD_RX_TRIGGER_CONFIRM_ID            = 0x0305,
+    CSR_MLME_DEL_RX_TRIGGER_REQUEST_ID            = 0x0308,
+    CSR_MLME_DEL_RX_TRIGGER_CONFIRM_ID            = 0x0309,
+    CSR_MLME_CONNECT_STATUS_REQUEST_ID            = 0x0310,
+    CSR_MLME_CONNECT_STATUS_CONFIRM_ID            = 0x0311,
+    CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST_ID      = 0x0314,
+    CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM_ID      = 0x0315,
+    CSR_MLME_ADD_TEMPLATE_REQUEST_ID              = 0x0318,
+    CSR_MLME_ADD_TEMPLATE_CONFIRM_ID              = 0x0319,
+    CSR_MLME_CONFIG_QUEUE_REQUEST_ID              = 0x031c,
+    CSR_MLME_CONFIG_QUEUE_CONFIRM_ID              = 0x031d,
+    CSR_MLME_ADD_TSPEC_REQUEST_ID                 = 0x0320,
+    CSR_MLME_ADD_TSPEC_CONFIRM_ID                 = 0x0321,
+    CSR_MLME_DEL_TSPEC_REQUEST_ID                 = 0x0324,
+    CSR_MLME_DEL_TSPEC_CONFIRM_ID                 = 0x0325,
+    CSR_MLME_START_AGGREGATION_REQUEST_ID         = 0x0328,
+    CSR_MLME_START_AGGREGATION_CONFIRM_ID         = 0x0329,
+    CSR_MLME_BLOCKACK_ERROR_INDICATION_ID         = 0x032b,
+    CSR_MLME_STOP_AGGREGATION_REQUEST_ID          = 0x032c,
+    CSR_MLME_STOP_AGGREGATION_CONFIRM_ID          = 0x032d,
+    CSR_MLME_SM_START_REQUEST_ID                  = 0x0334,
+    CSR_MLME_SM_START_CONFIRM_ID                  = 0x0335,
+    CSR_MLME_LEAVE_REQUEST_ID                     = 0x0338,
+    CSR_MLME_LEAVE_CONFIRM_ID                     = 0x0339,
+    CSR_MLME_SET_TIM_REQUEST_ID                   = 0x033c,
+    CSR_MLME_SET_TIM_CONFIRM_ID                   = 0x033d,
+    CSR_MLME_GET_KEY_SEQUENCE_REQUEST_ID          = 0x0340,
+    CSR_MLME_GET_KEY_SEQUENCE_CONFIRM_ID          = 0x0341,
+    CSR_MLME_SET_CHANNEL_REQUEST_ID               = 0x034c,
+    CSR_MLME_SET_CHANNEL_CONFIRM_ID               = 0x034d,
+    CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST_ID     = 0x040c,
+    CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM_ID     = 0x040d,
+    CSR_DEBUG_STRING_INDICATION_ID                = 0x0803,
+    CSR_DEBUG_WORD16_INDICATION_ID                = 0x0807,
+    CSR_DEBUG_GENERIC_REQUEST_ID                  = 0x0808,
+    CSR_DEBUG_GENERIC_CONFIRM_ID                  = 0x0809,
+    CSR_DEBUG_GENERIC_INDICATION_ID               = 0x080b
+} CSR_SIGNAL_ID;
+
+typedef CsrUint16 CSR_SIMPLE_POINTER;
+
+typedef CsrUint16 CSR_STARTING_SEQUENCE_NUMBER;
+
+typedef enum CSR_SYMBOL_ID
+{
+    CSR_SLT_END                                   = 0x0000,
+    CSR_SLT_PCI_SLOT_CONFIG                       = 0x0001,
+    CSR_SLT_SDIO_SLOT_CONFIG                      = 0x0002,
+    CSR_SLT_BUILD_ID_NUMBER                       = 0x0003,
+    CSR_SLT_BUILD_ID_STRING                       = 0x0004,
+    CSR_SLT_PERSISTENT_STORE_DB                   = 0x0005,
+    CSR_SLT_RESET_VECTOR_PHY                      = 0x0006,
+    CSR_SLT_RESET_VECTOR_MAC                      = 0x0007,
+    CSR_SLT_SDIO_LOADER_CONTROL                   = 0x0008,
+    CSR_SLT_TEST_CMD                              = 0x0009,
+    CSR_SLT_TEST_ALIVE_COUNTER                    = 0x000a,
+    CSR_SLT_TEST_PARAMETERS                       = 0x000b,
+    CSR_SLT_TEST_RESULTS                          = 0x000c,
+    CSR_SLT_TEST_VERSION                          = 0x000d,
+    CSR_SLT_MIB_PSID_RANGES                       = 0x000e,
+    CSR_SLT_KIP_TABLE                             = 0x000f,
+    CSR_SLT_PANIC_DATA_PHY                        = 0x0010,
+    CSR_SLT_PANIC_DATA_MAC                        = 0x0011,
+    CSR_SLT_BOOT_LOADER_CONTROL                   = 0x0012,
+    CSR_SLT_SOFT_MAC                              = 0x0013
+} CSR_SYMBOL_ID;
+
+typedef struct CSR_TSF_TIME
+{
+    CsrUint8 x[8];
+} CSR_TSF_TIME;
+
+typedef CsrUint16 CSR_TIME_UNITS;
+
+typedef enum CSR_TRANSMISSION_CONTROL
+{
+    CSR_TRIGGERED                                 = 0x0001,
+    CSR_END_OF_SERVICE                            = 0x0002,
+    CSR_NO_CONFIRM_REQUIRED                       = 0x0004,
+    CSR_ALLOW_BA                                  = 0x0008
+} CSR_TRANSMISSION_CONTROL;
+
+typedef enum CSR_TRANSMISSION_STATUS
+{
+    CSR_TX_SUCCESSFUL                             = 0x0000,
+    CSR_TX_RETRY_LIMIT                            = 0x0001,
+    CSR_TX_LIFETIME                               = 0x0002,
+    CSR_TX_NO_BSS                                 = 0x0003,
+    CSR_TX_EXCESSIVE_DATA_LENGTH                  = 0x0004,
+    CSR_TX_UNSUPPORTED_PRIORITY                   = 0x0006,
+    CSR_TX_UNAVAILABLE_PRIORITY                   = 0x0007,
+    CSR_TX_UNAVAILABLE_KEY_MAPPING                = 0x000a,
+    CSR_TX_EDCA_TIMEOUT                           = 0x000b,
+    CSR_TX_BLOCK_ACK_TIMEOUT                      = 0x000c,
+    CSR_TX_FAIL_TRANSMISSION_VIF_INTERRUPTED      = 0x000d,
+    CSR_TX_REJECTED_PEER_STATION_SLEEPING         = 0x000e,
+    CSR_TX_REJECTED_DTIM_ENDED                    = 0x000f,
+    CSR_TX_REJECTED_DTIM_STARTED                  = 0x0010
+} CSR_TRANSMISSION_STATUS;
+
+typedef CsrUint16 CSR_TRIGGER_ID;
+
+typedef CsrUint16 CSR_TRIGGERED_ID;
+
+typedef enum CSR_HIP_VERSIONS
+{
+    CSR_HIP_ENG_VERSION                           = 0x0001,
+    CSR_HIP_VERSION                               = 0x0900
+} CSR_HIP_VERSIONS;
+
+typedef CsrUint16 CSR_BUFFER_HANDLE;
+
+typedef CsrUint16 CSR_CHANNEL_NUMBER;
+
+typedef struct CSR_DATA_REFERENCE
+{
+    CsrUint16 SlotNumber;
+    CsrUint16 DataLength;
+} CSR_DATAREF;
+
+typedef CsrUint16 CSR_DIALOG_TOKEN;
+
+typedef struct CSR_GENERIC_POINTER
+{
+    CsrUint24        MemoryOffset;
+    CSR_MEMORY_SPACE MemorySpace;
+} CSR_GENERIC_POINTER;
+
+typedef struct CSR_MLME_CONFIG_QUEUE_CONFIRM
+{
+    CSR_DATAREF     Dummydataref1;
+    CSR_DATAREF     Dummydataref2;
+    CSR_RESULT_CODE ResultCode;
+} CSR_MLME_CONFIG_QUEUE_CONFIRM;
+
+typedef struct CSR_MLME_CONFIG_QUEUE_REQUEST
+{
+    CSR_DATAREF   Dummydataref1;
+    CSR_DATAREF   Dummydataref2;
+    CSR_NATURAL16 QueueIndex;
+    CSR_NATURAL16 Aifs;
+    CSR_NATURAL16 Cwmin;
+    CSR_NATURAL16 Cwmax;
+    CSR_NATURAL16 TxopLimit;
+} CSR_MLME_CONFIG_QUEUE_REQUEST;
+
+typedef struct CSR_MLME_GET_CONFIRM
+{
+    CSR_DATAREF    MibAttributeValue;
+    CSR_DATAREF    Dummydataref2;
+    CSR_MIB_STATUS Status;
+    CSR_NATURAL16  ErrorIndex;
+} CSR_MLME_GET_CONFIRM;
+
+typedef struct CSR_MLME_GET_REQUEST
+{
+    CSR_DATAREF MibAttribute;
+    CSR_DATAREF Dummydataref2;
+} CSR_MLME_GET_REQUEST;
+
+typedef struct CSR_MLME_GET_NEXT_CONFIRM
+{
+    CSR_DATAREF    MibAttributeValue;
+    CSR_DATAREF    Dummydataref2;
+    CSR_MIB_STATUS Status;
+    CSR_NATURAL16  ErrorIndex;
+} CSR_MLME_GET_NEXT_CONFIRM;
+
+typedef struct CSR_MLME_GET_NEXT_REQUEST
+{
+    CSR_DATAREF MibAttribute;
+    CSR_DATAREF Dummydataref2;
+} CSR_MLME_GET_NEXT_REQUEST;
+
+typedef struct CSR_MLME_HL_SYNC_CONFIRM
+{
+    CSR_DATAREF     Dummydataref1;
+    CSR_DATAREF     Dummydataref2;
+    CSR_MACADDRESS  GroupAddress;
+    CSR_RESULT_CODE ResultCode;
+} CSR_MLME_HL_SYNC_CONFIRM;
+
+typedef struct CSR_MLME_HL_SYNC_REQUEST
+{
+    CSR_DATAREF    Dummydataref1;
+    CSR_DATAREF    Dummydataref2;
+    CSR_MACADDRESS GroupAddress;
+} CSR_MLME_HL_SYNC_REQUEST;
+
+typedef struct CSR_MLME_HL_SYNC_CANCEL_CONFIRM
+{
+    CSR_DATAREF     Dummydataref1;
+    CSR_DATAREF     Dummydataref2;
+    CSR_RESULT_CODE ResultCode;
+} CSR_MLME_HL_SYNC_CANCEL_CONFIRM;
+
+typedef struct CSR_MLME_HL_SYNC_CANCEL_REQUEST
+{
+    CSR_DATAREF    Dummydataref1;
+    CSR_DATAREF    Dummydataref2;
+    CSR_MACADDRESS GroupAddress;
+} CSR_MLME_HL_SYNC_CANCEL_REQUEST;
+
+typedef struct CSR_MLME_MEASURE_CONFIRM
+{
+    CSR_DATAREF      Dummydataref1;
+    CSR_DATAREF      Dummydataref2;
+    CSR_RESULT_CODE  ResultCode;
+    CSR_DIALOG_TOKEN DialogToken;
+} CSR_MLME_MEASURE_CONFIRM;
+
+typedef struct CSR_MLME_MEASURE_INDICATION
+{
+    CSR_DATAREF      MeasurementReportSet;
+    CSR_DATAREF      Dummydataref2;
+    CSR_DIALOG_TOKEN DialogToken;
+} CSR_MLME_MEASURE_INDICATION;
+
+typedef struct CSR_MLME_MEASURE_REQUEST
+{
+    CSR_DATAREF      MeasurementRequestSet;
+    CSR_DATAREF      Dummydataref2;
+    CSR_DIALOG_TOKEN DialogToken;
+} CSR_MLME_MEASURE_REQUEST;
+
+typedef struct CSR_MLME_RESET_CONFIRM
+{
+    CSR_DATAREF     Dummydataref1;
+    CSR_DATAREF     Dummydataref2;
+    CSR_RESULT_CODE ResultCode;
+} CSR_MLME_RESET_CONFIRM;
+
+typedef struct CSR_MLME_RESET_REQUEST
+{
+    CSR_DATAREF    Dummydataref1;
+    CSR_DATAREF    Dummydataref2;
+    CSR_MACADDRESS StaAddress;
+    CsrInt16       SetDefaultMib;
+} CSR_MLME_RESET_REQUEST;
+
+typedef struct CSR_MLME_SET_CONFIRM
+{
+    CSR_DATAREF    MibAttributeValue;
+    CSR_DATAREF    Dummydataref2;
+    CSR_MIB_STATUS Status;
+    CSR_NATURAL16  ErrorIndex;
+} CSR_MLME_SET_CONFIRM;
+
+typedef struct CSR_MLME_SET_REQUEST
+{
+    CSR_DATAREF MibAttributeValue;
+    CSR_DATAREF Dummydataref2;
+} CSR_MLME_SET_REQUEST;
+
+typedef struct CSR_MLME_STOP_MEASURE_CONFIRM
+{
+    CSR_DATAREF      Dummydataref1;
+    CSR_DATAREF      Dummydataref2;
+    CSR_RESULT_CODE  ResultCode;
+    CSR_DIALOG_TOKEN DialogToken;
+} CSR_MLME_STOP_MEASURE_CONFIRM;
+
+typedef struct CSR_MLME_STOP_MEASURE_REQUEST
+{
+    CSR_DATAREF      Dummydataref1;
+    CSR_DATAREF      Dummydataref2;
+    CSR_DIALOG_TOKEN DialogToken;
+} CSR_MLME_STOP_MEASURE_REQUEST;
+
+typedef CsrUint16 CSR_PROCESS_ID;
+
+typedef CsrUint16 CSR_RATE;
+
+typedef CsrUint16 CSR_SEQUENCE_NUMBER;
+
+typedef struct CSR_SIGNAL_PRIMITIVE_HEADER
+{
+    CsrInt16       SignalId;
+    CSR_PROCESS_ID ReceiverProcessId;
+    CSR_PROCESS_ID SenderProcessId;
+} CSR_SIGNAL_PRIMITIVE_HEADER;
+
+typedef CsrUint16 CSR_TRAFFIC_WINDOW;
+
+typedef CsrUint16 CSR_VIF_IDENTIFIER;
+
+typedef struct CSR_DEBUG_GENERIC_CONFIRM
+{
+    CSR_DATAREF   DebugVariable;
+    CSR_DATAREF   Dummydataref2;
+    CSR_NATURAL16 DebugWords[8];
+} CSR_DEBUG_GENERIC_CONFIRM;
+
+typedef struct CSR_DEBUG_GENERIC_INDICATION
+{
+    CSR_DATAREF   DebugVariable;
+    CSR_DATAREF   Dummydataref2;
+    CSR_NATURAL16 DebugWords[8];
+} CSR_DEBUG_GENERIC_INDICATION;
+
+typedef struct CSR_DEBUG_GENERIC_REQUEST
+{
+    CSR_DATAREF   DebugVariable;
+    CSR_DATAREF   Dummydataref2;
+    CSR_NATURAL16 DebugWords[8];
+} CSR_DEBUG_GENERIC_REQUEST;
+
+typedef struct CSR_DEBUG_STRING_INDICATION
+{
+    CSR_DATAREF DebugMessage;
+    CSR_DATAREF Dummydataref2;
+} CSR_DEBUG_STRING_INDICATION;
+
+typedef struct CSR_DEBUG_WORD16_INDICATION
+{
+    CSR_DATAREF   Dummydataref1;
+    CSR_DATAREF   Dummydataref2;
+    CSR_NATURAL16 DebugWords[16];
+} CSR_DEBUG_WORD16_INDICATION;
+
+typedef struct CSR_MA_PACKET_CONFIRM
+{
+    CSR_DATAREF             Dummydataref1;
+    CSR_DATAREF             Dummydataref2;
+    CSR_VIF_IDENTIFIER      VirtualInterfaceIdentifier;
+    CSR_TRANSMISSION_STATUS TransmissionStatus;
+    CSR_NATURAL16           RetryCount;
+    CSR_RATE                Rate;
+    CSR_CLIENT_TAG          HostTag;
+} CSR_MA_PACKET_CONFIRM;
+
+typedef struct CSR_MA_PACKET_INDICATION
+{
+    CSR_DATAREF          Data;
+    CSR_DATAREF          Dummydataref2;
+    CSR_VIF_IDENTIFIER   VirtualInterfaceIdentifier;
+    CSR_TSF_TIME         LocalTime;
+    CSR_IFINTERFACE      Ifindex;
+    CSR_CHANNEL_NUMBER   Channel;
+    CSR_RECEPTION_STATUS ReceptionStatus;
+    CSR_DECIBELS         Rssi;
+    CSR_DECIBELS         Snr;
+    CSR_RATE             ReceivedRate;
+} CSR_MA_PACKET_INDICATION;
+
+typedef struct CSR_MA_PACKET_REQUEST
+{
+    CSR_DATAREF              Data;
+    CSR_DATAREF              Dummydataref2;
+    CSR_VIF_IDENTIFIER       VirtualInterfaceIdentifier;
+    CSR_RATE                 TransmitRate;
+    CSR_CLIENT_TAG           HostTag;
+    CSR_PRIORITY             Priority;
+    CSR_MACADDRESS           Ra;
+    CSR_TRANSMISSION_CONTROL TransmissionControl;
+} CSR_MA_PACKET_REQUEST;
+
+typedef struct CSR_MA_PACKET_CANCEL_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_CLIENT_TAG     HostTag;
+} CSR_MA_PACKET_CANCEL_REQUEST;
+
+typedef struct CSR_MA_PACKET_ERROR_INDICATION
+{
+    CSR_DATAREF         Dummydataref1;
+    CSR_DATAREF         Dummydataref2;
+    CSR_VIF_IDENTIFIER  VirtualInterfaceIdentifier;
+    CSR_MACADDRESS      PeerQstaAddress;
+    CSR_PRIORITY        UserPriority;
+    CSR_SEQUENCE_NUMBER SequenceNumber;
+} CSR_MA_PACKET_ERROR_INDICATION;
+
+typedef struct CSR_MA_VIF_AVAILABILITY_INDICATION
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CsrInt16           Multicast;
+} CSR_MA_VIF_AVAILABILITY_INDICATION;
+
+typedef struct CSR_MA_VIF_AVAILABILITY_RESPONSE
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MA_VIF_AVAILABILITY_RESPONSE;
+
+typedef struct CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM
+{
+    CSR_DATAREF            Dummydataref1;
+    CSR_DATAREF            Dummydataref2;
+    CSR_VIF_IDENTIFIER     VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE        ResultCode;
+    CSR_AUTONOMOUS_SCAN_ID AutonomousScanId;
+} CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM;
+
+typedef struct CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST
+{
+    CSR_DATAREF                 ChannelList;
+    CSR_DATAREF                 InformationElements;
+    CSR_VIF_IDENTIFIER          VirtualInterfaceIdentifier;
+    CSR_AUTONOMOUS_SCAN_ID      AutonomousScanId;
+    CSR_IFINTERFACE             Ifindex;
+    CSR_CHANNEL_STARTING_FACTOR ChannelStartingFactor;
+    CSR_SCAN_TYPE               ScanType;
+    CSR_MICROSECONDS32          ProbeDelay;
+    CSR_TIME_UNITS              MinChannelTime;
+    CSR_TIME_UNITS              MaxChannelTime;
+} CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST;
+
+typedef struct CSR_MLME_ADD_BLACKOUT_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_BLACKOUT_ID    BlackoutId;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_ADD_BLACKOUT_CONFIRM;
+
+typedef struct CSR_MLME_ADD_BLACKOUT_REQUEST
+{
+    CSR_DATAREF         Dummydataref1;
+    CSR_DATAREF         Dummydataref2;
+    CSR_VIF_IDENTIFIER  VirtualInterfaceIdentifier;
+    CSR_BLACKOUT_ID     BlackoutId;
+    CSR_BLACKOUT_TYPE   BlackoutType;
+    CSR_BLACKOUT_SOURCE BlackoutSource;
+    CSR_MICROSECONDS32  BlackoutStartReference;
+    CSR_MICROSECONDS32  BlackoutPeriod;
+    CSR_MICROSECONDS32  BlackoutDuration;
+    CSR_MACADDRESS      PeerStaAddress;
+    CSR_NATURAL16       BlackoutCount;
+} CSR_MLME_ADD_BLACKOUT_REQUEST;
+
+typedef struct CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM;
+
+typedef struct CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST
+{
+    CSR_DATAREF        Data;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_NATURAL16      NumberOfMulticastGroupAddresses;
+} CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST;
+
+typedef struct CSR_MLME_ADD_PERIODIC_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_PERIODIC_ID    PeriodicId;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_ADD_PERIODIC_CONFIRM;
+
+typedef struct CSR_MLME_ADD_PERIODIC_REQUEST
+{
+    CSR_DATAREF                  Dummydataref1;
+    CSR_DATAREF                  Dummydataref2;
+    CSR_VIF_IDENTIFIER           VirtualInterfaceIdentifier;
+    CSR_PERIODIC_ID              PeriodicId;
+    CSR_MICROSECONDS32           MaximumLatency;
+    CSR_PERIODIC_SCHEDULING_MODE PeriodicSchedulingMode;
+    CsrInt16                     WakeHost;
+    CSR_PRIORITY                 UserPriority;
+} CSR_MLME_ADD_PERIODIC_REQUEST;
+
+typedef struct CSR_MLME_ADD_RX_TRIGGER_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_TRIGGER_ID     TriggerId;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_ADD_RX_TRIGGER_CONFIRM;
+
+typedef struct CSR_MLME_ADD_RX_TRIGGER_REQUEST
+{
+    CSR_DATAREF        InformationElements;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_TRIGGER_ID     TriggerId;
+    CSR_PRIORITY       Priority;
+} CSR_MLME_ADD_RX_TRIGGER_REQUEST;
+
+typedef struct CSR_MLME_ADD_TEMPLATE_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_FRAME_TYPE     FrameType;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_ADD_TEMPLATE_CONFIRM;
+
+typedef struct CSR_MLME_ADD_TEMPLATE_REQUEST
+{
+    CSR_DATAREF        Data1;
+    CSR_DATAREF        Data2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_FRAME_TYPE     FrameType;
+    CSR_RATE           MinTransmitRate;
+} CSR_MLME_ADD_TEMPLATE_REQUEST;
+
+typedef struct CSR_MLME_ADD_TRIGGERED_GET_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+    CSR_TRIGGERED_ID   TriggeredId;
+} CSR_MLME_ADD_TRIGGERED_GET_CONFIRM;
+
+typedef struct CSR_MLME_ADD_TRIGGERED_GET_REQUEST
+{
+    CSR_DATAREF        MibAttribute;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_TRIGGERED_ID   TriggeredId;
+} CSR_MLME_ADD_TRIGGERED_GET_REQUEST;
+
+typedef struct CSR_MLME_ADD_TSPEC_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_PRIORITY       UserPriority;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_ADD_TSPEC_CONFIRM;
+
+typedef struct CSR_MLME_ADD_TSPEC_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_PRIORITY       UserPriority;
+    CSR_DIRECTION      Direction;
+    CSR_PS_SCHEME      PsScheme;
+    CSR_NATURAL16      MediumTime;
+    CSR_MICROSECONDS32 ServiceStartTime;
+    CSR_MICROSECONDS32 ServiceInterval;
+    CSR_RATE           MinimumDataRate;
+} CSR_MLME_ADD_TSPEC_REQUEST;
+
+typedef struct CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION
+{
+    CSR_DATAREF            Dummydataref1;
+    CSR_DATAREF            Dummydataref2;
+    CSR_VIF_IDENTIFIER     VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE        ResultCode;
+    CSR_AUTONOMOUS_SCAN_ID AutonomousScanId;
+} CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION;
+
+typedef struct CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_MACADDRESS     Bssid;
+} CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION;
+
+typedef struct CSR_MLME_BLACKOUT_ENDED_INDICATION
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_BLACKOUT_ID    BlackoutId;
+} CSR_MLME_BLACKOUT_ENDED_INDICATION;
+
+typedef struct CSR_MLME_BLOCKACK_ERROR_INDICATION
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_REASON_CODE    ResultCode;
+    CSR_MACADDRESS     PeerQstaAddress;
+} CSR_MLME_BLOCKACK_ERROR_INDICATION;
+
+typedef struct CSR_MLME_CONNECTED_INDICATION
+{
+    CSR_DATAREF           Dummydataref1;
+    CSR_DATAREF           Dummydataref2;
+    CSR_VIF_IDENTIFIER    VirtualInterfaceIdentifier;
+    CSR_CONNECTION_STATUS ConnectionStatus;
+    CSR_MACADDRESS        PeerMacAddress;
+} CSR_MLME_CONNECTED_INDICATION;
+
+typedef struct CSR_MLME_CONNECT_STATUS_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_CONNECT_STATUS_CONFIRM;
+
+typedef struct CSR_MLME_CONNECT_STATUS_REQUEST
+{
+    CSR_DATAREF                InformationElements;
+    CSR_DATAREF                Dummydataref2;
+    CSR_VIF_IDENTIFIER         VirtualInterfaceIdentifier;
+    CSR_CONNECTION_STATUS      ConnectionStatus;
+    CSR_MACADDRESS             StaAddress;
+    CSR_ASSOCIATION_ID         AssociationId;
+    CSR_CAPABILITY_INFORMATION AssociationCapabilityInformation;
+} CSR_MLME_CONNECT_STATUS_REQUEST;
+
+typedef struct CSR_MLME_DELETEKEYS_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_DELETEKEYS_CONFIRM;
+
+typedef struct CSR_MLME_DELETEKEYS_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_NATURAL16      KeyId;
+    CSR_KEY_TYPE       KeyType;
+    CSR_MACADDRESS     Address;
+} CSR_MLME_DELETEKEYS_REQUEST;
+
+typedef struct CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM
+{
+    CSR_DATAREF            Dummydataref1;
+    CSR_DATAREF            Dummydataref2;
+    CSR_VIF_IDENTIFIER     VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE        ResultCode;
+    CSR_AUTONOMOUS_SCAN_ID AutonomousScanId;
+} CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM;
+
+typedef struct CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST
+{
+    CSR_DATAREF            Dummydataref1;
+    CSR_DATAREF            Dummydataref2;
+    CSR_VIF_IDENTIFIER     VirtualInterfaceIdentifier;
+    CSR_AUTONOMOUS_SCAN_ID AutonomousScanId;
+} CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST;
+
+typedef struct CSR_MLME_DEL_BLACKOUT_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_BLACKOUT_ID    BlackoutId;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_DEL_BLACKOUT_CONFIRM;
+
+typedef struct CSR_MLME_DEL_BLACKOUT_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_BLACKOUT_ID    BlackoutId;
+} CSR_MLME_DEL_BLACKOUT_REQUEST;
+
+typedef struct CSR_MLME_DEL_PERIODIC_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_PERIODIC_ID    PeriodicId;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_DEL_PERIODIC_CONFIRM;
+
+typedef struct CSR_MLME_DEL_PERIODIC_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_PERIODIC_ID    PeriodicId;
+} CSR_MLME_DEL_PERIODIC_REQUEST;
+
+typedef struct CSR_MLME_DEL_RX_TRIGGER_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_TRIGGER_ID     TriggerId;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_DEL_RX_TRIGGER_CONFIRM;
+
+typedef struct CSR_MLME_DEL_RX_TRIGGER_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_TRIGGER_ID     TriggerId;
+} CSR_MLME_DEL_RX_TRIGGER_REQUEST;
+
+typedef struct CSR_MLME_DEL_TRIGGERED_GET_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+    CSR_TRIGGERED_ID   TriggeredId;
+} CSR_MLME_DEL_TRIGGERED_GET_CONFIRM;
+
+typedef struct CSR_MLME_DEL_TRIGGERED_GET_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_TRIGGERED_ID   TriggeredId;
+} CSR_MLME_DEL_TRIGGERED_GET_REQUEST;
+
+typedef struct CSR_MLME_DEL_TSPEC_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_PRIORITY       UserPriority;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_DEL_TSPEC_CONFIRM;
+
+typedef struct CSR_MLME_DEL_TSPEC_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_PRIORITY       UserPriority;
+    CSR_DIRECTION      Direction;
+} CSR_MLME_DEL_TSPEC_REQUEST;
+
+typedef struct CSR_MLME_GET_KEY_SEQUENCE_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+    CSR_NATURAL16      SequenceNumber[8];
+} CSR_MLME_GET_KEY_SEQUENCE_CONFIRM;
+
+typedef struct CSR_MLME_GET_KEY_SEQUENCE_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_NATURAL16      KeyId;
+    CSR_KEY_TYPE       KeyType;
+    CSR_MACADDRESS     Address;
+} CSR_MLME_GET_KEY_SEQUENCE_REQUEST;
+
+typedef struct CSR_MLME_LEAVE_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_LEAVE_CONFIRM;
+
+typedef struct CSR_MLME_LEAVE_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+} CSR_MLME_LEAVE_REQUEST;
+
+typedef struct CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM;
+
+typedef struct CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST
+{
+    CSR_DATAREF                Data;
+    CSR_DATAREF                Dummydataref2;
+    CSR_VIF_IDENTIFIER         VirtualInterfaceIdentifier;
+    CSR_TIME_UNITS             BeaconPeriod;
+    CSR_BEACON_PERIODS         DtimPeriod;
+    CSR_CAPABILITY_INFORMATION CapabilityInformation;
+    CSR_MACADDRESS             Bssid;
+    CSR_NATURAL16              RtsThreshold;
+} CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST;
+
+typedef struct CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM
+{
+    CSR_DATAREF            Dummydataref1;
+    CSR_DATAREF            Dummydataref2;
+    CSR_VIF_IDENTIFIER     VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE        ResultCode;
+    CSR_AUTONOMOUS_SCAN_ID AutonomousScanId;
+} CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM;
+
+typedef struct CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST
+{
+    CSR_DATAREF            Dummydataref1;
+    CSR_DATAREF            Dummydataref2;
+    CSR_VIF_IDENTIFIER     VirtualInterfaceIdentifier;
+    CSR_AUTONOMOUS_SCAN_ID AutonomousScanId;
+    CsrInt16               Pause;
+} CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST;
+
+typedef struct CSR_MLME_POWERMGT_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_POWERMGT_CONFIRM;
+
+typedef struct CSR_MLME_POWERMGT_REQUEST
+{
+    CSR_DATAREF               Dummydataref1;
+    CSR_DATAREF               Dummydataref2;
+    CSR_VIF_IDENTIFIER        VirtualInterfaceIdentifier;
+    CSR_POWER_MANAGEMENT_MODE PowerManagementMode;
+    CsrInt16                  ReceiveDtims;
+    CSR_BEACON_PERIODS        ListenInterval;
+    CSR_TRAFFIC_WINDOW        TrafficWindow;
+} CSR_MLME_POWERMGT_REQUEST;
+
+typedef struct CSR_MLME_SCAN_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_SCAN_CONFIRM;
+
+typedef struct CSR_MLME_SCAN_REQUEST
+{
+    CSR_DATAREF        ChannelList;
+    CSR_DATAREF        InformationElements;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_IFINTERFACE    Ifindex;
+    CSR_SCAN_TYPE      ScanType;
+    CSR_MICROSECONDS32 ProbeDelay;
+    CSR_TIME_UNITS     MinChannelTime;
+    CSR_TIME_UNITS     MaxChannelTime;
+} CSR_MLME_SCAN_REQUEST;
+
+typedef struct CSR_MLME_SCAN_CANCEL_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+} CSR_MLME_SCAN_CANCEL_REQUEST;
+
+typedef struct CSR_MLME_SETKEYS_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_SETKEYS_CONFIRM;
+
+typedef struct CSR_MLME_SETKEYS_REQUEST
+{
+    CSR_DATAREF               Key;
+    CSR_DATAREF               Dummydataref2;
+    CSR_VIF_IDENTIFIER        VirtualInterfaceIdentifier;
+    CSR_NATURAL16             Length;
+    CSR_NATURAL16             KeyId;
+    CSR_KEY_TYPE              KeyType;
+    CSR_MACADDRESS            Address;
+    CSR_NATURAL16             SequenceNumber[8];
+    CSR_CIPHER_SUITE_SELECTOR CipherSuiteSelector;
+} CSR_MLME_SETKEYS_REQUEST;
+
+typedef struct CSR_MLME_SET_CHANNEL_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_SET_CHANNEL_CONFIRM;
+
+typedef struct CSR_MLME_SET_CHANNEL_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_IFINTERFACE    Ifindex;
+    CSR_CHANNEL_NUMBER Channel;
+    CSR_MACADDRESS     Address;
+    CSR_TIME_UNITS     AvailabilityDuration;
+    CSR_TIME_UNITS     AvailabilityInterval;
+} CSR_MLME_SET_CHANNEL_REQUEST;
+
+typedef struct CSR_MLME_SET_PACKET_FILTER_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_SET_PACKET_FILTER_CONFIRM;
+
+typedef struct CSR_MLME_SET_PACKET_FILTER_REQUEST
+{
+    CSR_DATAREF            InformationElements;
+    CSR_DATAREF            Dummydataref2;
+    CSR_VIF_IDENTIFIER     VirtualInterfaceIdentifier;
+    CSR_PACKET_FILTER_MODE PacketFilterMode;
+    CSR_IPV4_ADDRESS       ArpFilterAddress;
+} CSR_MLME_SET_PACKET_FILTER_REQUEST;
+
+typedef struct CSR_MLME_SET_TIM_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_SET_TIM_CONFIRM;
+
+typedef struct CSR_MLME_SET_TIM_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_ASSOCIATION_ID AssociationId;
+    CsrInt16           TimValue;
+} CSR_MLME_SET_TIM_REQUEST;
+
+typedef struct CSR_MLME_SM_START_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_SM_START_CONFIRM;
+
+typedef struct CSR_MLME_SM_START_REQUEST
+{
+    CSR_DATAREF                Beacon;
+    CSR_DATAREF                BssParameters;
+    CSR_VIF_IDENTIFIER         VirtualInterfaceIdentifier;
+    CSR_IFINTERFACE            Ifindex;
+    CSR_CHANNEL_NUMBER         Channel;
+    CSR_MACADDRESS             InterfaceAddress;
+    CSR_MACADDRESS             Bssid;
+    CSR_TIME_UNITS             BeaconPeriod;
+    CSR_BEACON_PERIODS         DtimPeriod;
+    CSR_CAPABILITY_INFORMATION CapabilityInformation;
+} CSR_MLME_SM_START_REQUEST;
+
+typedef struct CSR_MLME_START_AGGREGATION_CONFIRM
+{
+    CSR_DATAREF         Dummydataref1;
+    CSR_DATAREF         Dummydataref2;
+    CSR_VIF_IDENTIFIER  VirtualInterfaceIdentifier;
+    CSR_MACADDRESS      PeerQstaAddress;
+    CSR_PRIORITY        UserPriority;
+    CSR_DIRECTION       Direction;
+    CSR_RESULT_CODE     ResultCode;
+    CSR_SEQUENCE_NUMBER SequenceNumber;
+} CSR_MLME_START_AGGREGATION_CONFIRM;
+
+typedef struct CSR_MLME_START_AGGREGATION_REQUEST
+{
+    CSR_DATAREF                  Dummydataref1;
+    CSR_DATAREF                  Dummydataref2;
+    CSR_VIF_IDENTIFIER           VirtualInterfaceIdentifier;
+    CSR_MACADDRESS               PeerQstaAddress;
+    CSR_PRIORITY                 UserPriority;
+    CSR_DIRECTION                Direction;
+    CSR_STARTING_SEQUENCE_NUMBER StartingSequenceNumber;
+    CSR_NATURAL16                BufferSize;
+    CSR_TIME_UNITS               BlockAckTimeout;
+} CSR_MLME_START_AGGREGATION_REQUEST;
+
+typedef struct CSR_MLME_STOP_AGGREGATION_CONFIRM
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_MACADDRESS     PeerQstaAddress;
+    CSR_PRIORITY       UserPriority;
+    CSR_DIRECTION      Direction;
+    CSR_RESULT_CODE    ResultCode;
+} CSR_MLME_STOP_AGGREGATION_CONFIRM;
+
+typedef struct CSR_MLME_STOP_AGGREGATION_REQUEST
+{
+    CSR_DATAREF        Dummydataref1;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_MACADDRESS     PeerQstaAddress;
+    CSR_PRIORITY       UserPriority;
+    CSR_DIRECTION      Direction;
+} CSR_MLME_STOP_AGGREGATION_REQUEST;
+
+typedef struct CSR_MLME_TRIGGERED_GET_INDICATION
+{
+    CSR_DATAREF        MibAttributeValue;
+    CSR_DATAREF        Dummydataref2;
+    CSR_VIF_IDENTIFIER VirtualInterfaceIdentifier;
+    CSR_MIB_STATUS     Status;
+    CSR_NATURAL16      ErrorIndex;
+    CSR_TRIGGERED_ID   TriggeredId;
+} CSR_MLME_TRIGGERED_GET_INDICATION;
+
+typedef struct CSR_SIGNAL_PRIMITIVE
+{
+    CSR_SIGNAL_PRIMITIVE_HEADER SignalPrimitiveHeader;
+    union
+    {
+        CSR_MA_PACKET_REQUEST                    MaPacketRequest;
+        CSR_MA_PACKET_CONFIRM                    MaPacketConfirm;
+        CSR_MA_PACKET_INDICATION                 MaPacketIndication;
+        CSR_MA_PACKET_CANCEL_REQUEST             MaPacketCancelRequest;
+        CSR_MA_VIF_AVAILABILITY_RESPONSE         MaVifAvailabilityResponse;
+        CSR_MA_VIF_AVAILABILITY_INDICATION       MaVifAvailabilityIndication;
+        CSR_MA_PACKET_ERROR_INDICATION           MaPacketErrorIndication;
+        CSR_MLME_RESET_REQUEST                   MlmeResetRequest;
+        CSR_MLME_RESET_CONFIRM                   MlmeResetConfirm;
+        CSR_MLME_GET_REQUEST                     MlmeGetRequest;
+        CSR_MLME_GET_CONFIRM                     MlmeGetConfirm;
+        CSR_MLME_SET_REQUEST                     MlmeSetRequest;
+        CSR_MLME_SET_CONFIRM                     MlmeSetConfirm;
+        CSR_MLME_GET_NEXT_REQUEST                MlmeGetNextRequest;
+        CSR_MLME_GET_NEXT_CONFIRM                MlmeGetNextConfirm;
+        CSR_MLME_POWERMGT_REQUEST                MlmePowermgtRequest;
+        CSR_MLME_POWERMGT_CONFIRM                MlmePowermgtConfirm;
+        CSR_MLME_SCAN_REQUEST                    MlmeScanRequest;
+        CSR_MLME_SCAN_CONFIRM                    MlmeScanConfirm;
+        CSR_MLME_HL_SYNC_REQUEST                 MlmeHlSyncRequest;
+        CSR_MLME_HL_SYNC_CONFIRM                 MlmeHlSyncConfirm;
+        CSR_MLME_MEASURE_REQUEST                 MlmeMeasureRequest;
+        CSR_MLME_MEASURE_CONFIRM                 MlmeMeasureConfirm;
+        CSR_MLME_MEASURE_INDICATION              MlmeMeasureIndication;
+        CSR_MLME_SETKEYS_REQUEST                 MlmeSetkeysRequest;
+        CSR_MLME_SETKEYS_CONFIRM                 MlmeSetkeysConfirm;
+        CSR_MLME_DELETEKEYS_REQUEST              MlmeDeletekeysRequest;
+        CSR_MLME_DELETEKEYS_CONFIRM              MlmeDeletekeysConfirm;
+        CSR_MLME_AUTONOMOUS_SCAN_LOSS_INDICATION MlmeAutonomousScanLossIndication;
+        CSR_MLME_CONNECTED_INDICATION            MlmeConnectedIndication;
+        CSR_MLME_SCAN_CANCEL_REQUEST             MlmeScanCancelRequest;
+        CSR_MLME_HL_SYNC_CANCEL_REQUEST          MlmeHlSyncCancelRequest;
+        CSR_MLME_HL_SYNC_CANCEL_CONFIRM          MlmeHlSyncCancelConfirm;
+        CSR_MLME_ADD_PERIODIC_REQUEST            MlmeAddPeriodicRequest;
+        CSR_MLME_ADD_PERIODIC_CONFIRM            MlmeAddPeriodicConfirm;
+        CSR_MLME_DEL_PERIODIC_REQUEST            MlmeDelPeriodicRequest;
+        CSR_MLME_DEL_PERIODIC_CONFIRM            MlmeDelPeriodicConfirm;
+        CSR_MLME_ADD_AUTONOMOUS_SCAN_REQUEST     MlmeAddAutonomousScanRequest;
+        CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM     MlmeAddAutonomousScanConfirm;
+        CSR_MLME_DEL_AUTONOMOUS_SCAN_REQUEST     MlmeDelAutonomousScanRequest;
+        CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM     MlmeDelAutonomousScanConfirm;
+        CSR_MLME_SET_PACKET_FILTER_REQUEST       MlmeSetPacketFilterRequest;
+        CSR_MLME_SET_PACKET_FILTER_CONFIRM       MlmeSetPacketFilterConfirm;
+        CSR_MLME_STOP_MEASURE_REQUEST            MlmeStopMeasureRequest;
+        CSR_MLME_STOP_MEASURE_CONFIRM            MlmeStopMeasureConfirm;
+        CSR_MLME_PAUSE_AUTONOMOUS_SCAN_REQUEST   MlmePauseAutonomousScanRequest;
+        CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM   MlmePauseAutonomousScanConfirm;
+        CSR_MLME_AUTONOMOUS_SCAN_DONE_INDICATION MlmeAutonomousScanDoneIndication;
+        CSR_MLME_ADD_TRIGGERED_GET_REQUEST       MlmeAddTriggeredGetRequest;
+        CSR_MLME_ADD_TRIGGERED_GET_CONFIRM       MlmeAddTriggeredGetConfirm;
+        CSR_MLME_DEL_TRIGGERED_GET_REQUEST       MlmeDelTriggeredGetRequest;
+        CSR_MLME_DEL_TRIGGERED_GET_CONFIRM       MlmeDelTriggeredGetConfirm;
+        CSR_MLME_TRIGGERED_GET_INDICATION        MlmeTriggeredGetIndication;
+        CSR_MLME_ADD_BLACKOUT_REQUEST            MlmeAddBlackoutRequest;
+        CSR_MLME_ADD_BLACKOUT_CONFIRM            MlmeAddBlackoutConfirm;
+        CSR_MLME_BLACKOUT_ENDED_INDICATION       MlmeBlackoutEndedIndication;
+        CSR_MLME_DEL_BLACKOUT_REQUEST            MlmeDelBlackoutRequest;
+        CSR_MLME_DEL_BLACKOUT_CONFIRM            MlmeDelBlackoutConfirm;
+        CSR_MLME_ADD_RX_TRIGGER_REQUEST          MlmeAddRxTriggerRequest;
+        CSR_MLME_ADD_RX_TRIGGER_CONFIRM          MlmeAddRxTriggerConfirm;
+        CSR_MLME_DEL_RX_TRIGGER_REQUEST          MlmeDelRxTriggerRequest;
+        CSR_MLME_DEL_RX_TRIGGER_CONFIRM          MlmeDelRxTriggerConfirm;
+        CSR_MLME_CONNECT_STATUS_REQUEST          MlmeConnectStatusRequest;
+        CSR_MLME_CONNECT_STATUS_CONFIRM          MlmeConnectStatusConfirm;
+        CSR_MLME_MODIFY_BSS_PARAMETER_REQUEST    MlmeModifyBssParameterRequest;
+        CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM    MlmeModifyBssParameterConfirm;
+        CSR_MLME_ADD_TEMPLATE_REQUEST            MlmeAddTemplateRequest;
+        CSR_MLME_ADD_TEMPLATE_CONFIRM            MlmeAddTemplateConfirm;
+        CSR_MLME_CONFIG_QUEUE_REQUEST            MlmeConfigQueueRequest;
+        CSR_MLME_CONFIG_QUEUE_CONFIRM            MlmeConfigQueueConfirm;
+        CSR_MLME_ADD_TSPEC_REQUEST               MlmeAddTspecRequest;
+        CSR_MLME_ADD_TSPEC_CONFIRM               MlmeAddTspecConfirm;
+        CSR_MLME_DEL_TSPEC_REQUEST               MlmeDelTspecRequest;
+        CSR_MLME_DEL_TSPEC_CONFIRM               MlmeDelTspecConfirm;
+        CSR_MLME_START_AGGREGATION_REQUEST       MlmeStartAggregationRequest;
+        CSR_MLME_START_AGGREGATION_CONFIRM       MlmeStartAggregationConfirm;
+        CSR_MLME_BLOCKACK_ERROR_INDICATION       MlmeBlockackErrorIndication;
+        CSR_MLME_STOP_AGGREGATION_REQUEST        MlmeStopAggregationRequest;
+        CSR_MLME_STOP_AGGREGATION_CONFIRM        MlmeStopAggregationConfirm;
+        CSR_MLME_SM_START_REQUEST                MlmeSmStartRequest;
+        CSR_MLME_SM_START_CONFIRM                MlmeSmStartConfirm;
+        CSR_MLME_LEAVE_REQUEST                   MlmeLeaveRequest;
+        CSR_MLME_LEAVE_CONFIRM                   MlmeLeaveConfirm;
+        CSR_MLME_SET_TIM_REQUEST                 MlmeSetTimRequest;
+        CSR_MLME_SET_TIM_CONFIRM                 MlmeSetTimConfirm;
+        CSR_MLME_GET_KEY_SEQUENCE_REQUEST        MlmeGetKeySequenceRequest;
+        CSR_MLME_GET_KEY_SEQUENCE_CONFIRM        MlmeGetKeySequenceConfirm;
+        CSR_MLME_SET_CHANNEL_REQUEST             MlmeSetChannelRequest;
+        CSR_MLME_SET_CHANNEL_CONFIRM             MlmeSetChannelConfirm;
+        CSR_MLME_ADD_MULTICAST_ADDRESS_REQUEST   MlmeAddMulticastAddressRequest;
+        CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM   MlmeAddMulticastAddressConfirm;
+        CSR_DEBUG_STRING_INDICATION              DebugStringIndication;
+        CSR_DEBUG_WORD16_INDICATION              DebugWord16Indication;
+        CSR_DEBUG_GENERIC_REQUEST                DebugGenericRequest;
+        CSR_DEBUG_GENERIC_CONFIRM                DebugGenericConfirm;
+        CSR_DEBUG_GENERIC_INDICATION             DebugGenericIndication;
+    } u;
+} CSR_SIGNAL;
+
+#define SIG_FILTER_SIZE 6
+
+CsrUint32 SigGetFilterPos(CsrUint16 aSigID);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_ta_sampling.c
@@ -0,0 +1,535 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     csr_wifi_hip_ta_sampling.c
+ *
+ *  PURPOSE:
+ *      The traffic analysis sampling module.
+ *      This gathers data which is sent to the SME and used to analyse
+ *      the traffic behaviour.
+ *
+ * Provides:
+ *      unifi_ta_sampling_init - Initialise the internal state
+ *      unifi_ta_sample        - Sampling function, call this for every data packet
+ *
+ * Calls these external functions which must be provided:
+ *      unifi_ta_indicate_sampling - Pass sample data to the SME.
+ *      unifi_ta_indicate_protocol - Report certain data packet types to the SME.
+ * ---------------------------------------------------------------------------
+ */
+
+#include "csr_wifi_hip_card_sdio.h"
+
+/* Maximum number of Tx frames we store each CYCLE_1, for detecting period */
+#define TA_MAX_INTERVALS_IN_C1          100
+
+/* Number of intervals in CYCLE_1 (one second), for detecting periodic */
+/* Must match size of unifi_TrafficStats.intervals - 1 */
+#define TA_INTERVALS_NUM               10
+
+/* Step (in msecs) between intervals, for detecting periodic */
+/* We are only interested in periods up to 100ms, i.e. between beacons */
+/* This is correct for TA_INTERVALS_NUM=10 */
+#define TA_INTERVALS_STEP               10
+
+
+enum ta_frame_identity
+{
+    TA_FRAME_UNKNOWN,
+    TA_FRAME_ETHERNET_UNINTERESTING,
+    TA_FRAME_ETHERNET_INTERESTING
+};
+
+
+#define TA_ETHERNET_TYPE_OFFSET     6
+#define TA_LLC_HEADER_SIZE          8
+#define TA_IP_TYPE_OFFSET           17
+#define TA_UDP_SOURCE_PORT_OFFSET   28
+#define TA_UDP_DEST_PORT_OFFSET     (TA_UDP_SOURCE_PORT_OFFSET + 2)
+#define TA_BOOTP_CLIENT_MAC_ADDR_OFFSET 64
+#define TA_DHCP_MESSAGE_TYPE_OFFSET 278
+#define TA_DHCP_MESSAGE_TYPE_ACK    0x05
+#define TA_PROTO_TYPE_IP            0x0800
+#define TA_PROTO_TYPE_EAP           0x888E
+#define TA_PROTO_TYPE_WAI           0x8864
+#define TA_PROTO_TYPE_ARP           0x0806
+#define TA_IP_TYPE_TCP              0x06
+#define TA_IP_TYPE_UDP              0x11
+#define TA_UDP_PORT_BOOTPC          0x0044
+#define TA_UDP_PORT_BOOTPS          0x0043
+#define TA_EAPOL_TYPE_OFFSET        9
+#define TA_EAPOL_TYPE_START         0x01
+
+static const CsrUint8 snap_802_2[3]   = { 0xAA, 0xAA, 0x03 };
+static const CsrUint8 oui_rfc1042[3]  = { 0x00, 0x00, 0x00 };
+static const CsrUint8 oui_8021h[3]    = { 0x00, 0x00, 0xf8 };
+static const CsrUint8 aironet_snap[5] = { 0x00, 0x40, 0x96, 0x00, 0x00 };
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  ta_detect_protocol
+ *
+ *      Internal only.
+ *      Detects a specific protocol in a frame and indicates a TA event.
+ *
+ *  Arguments:
+ *      ta              The pointer to the TA module.
+ *      direction       The direction of the frame (tx or rx).
+ *      data            Pointer to the structure that contains the data.
+ *
+ *  Returns:
+ *      None
+ * ---------------------------------------------------------------------------
+ */
+static enum ta_frame_identity ta_detect_protocol(card_t *card, CsrWifiRouterCtrlProtocolDirection direction,
+                                                 const bulk_data_desc_t *data,
+                                                 const CsrUint8 *saddr,
+                                                 const CsrUint8 *sta_macaddr)
+{
+    ta_data_t *tad = &card->ta_sampling;
+    CsrUint16 proto;
+    CsrUint16 source_port, dest_port;
+    CsrWifiMacAddress srcAddress;
+
+    if (data->data_length < TA_LLC_HEADER_SIZE)
+    {
+        return TA_FRAME_UNKNOWN;
+    }
+
+    if (CsrMemCmp(data->os_data_ptr, snap_802_2, 3))
+    {
+        return TA_FRAME_UNKNOWN;
+    }
+
+    if (tad->packet_filter & CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_CUSTOM)
+    {
+        /*
+         * Here we would use the custom filter to detect interesting frames.
+         */
+    }
+
+    if (!CsrMemCmp(data->os_data_ptr + 3, oui_rfc1042, 3) ||
+        !CsrMemCmp(data->os_data_ptr + 3, oui_8021h, 3))
+    {
+        proto = (data->os_data_ptr[TA_ETHERNET_TYPE_OFFSET] * 256) +
+                data->os_data_ptr[TA_ETHERNET_TYPE_OFFSET + 1];
+
+        /* The only interesting IP frames are the DHCP */
+        if (proto == TA_PROTO_TYPE_IP)
+        {
+            if (data->data_length > TA_IP_TYPE_OFFSET)
+            {
+                if (tad->packet_filter & CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_CUSTOM)
+                {
+                    ta_l4stats_t *ta_l4stats = &tad->ta_l4stats;
+                    CsrUint8 l4proto = data->os_data_ptr[TA_IP_TYPE_OFFSET];
+
+                    if (l4proto == TA_IP_TYPE_TCP)
+                    {
+                        if (direction == CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_TX)
+                        {
+                            ta_l4stats->txTcpBytesCount += data->data_length;
+                        }
+                        else
+                        {
+                            ta_l4stats->rxTcpBytesCount += data->data_length;
+                        }
+                    }
+                    else if (l4proto == TA_IP_TYPE_UDP)
+                    {
+                        if (direction == CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_TX)
+                        {
+                            ta_l4stats->txUdpBytesCount += data->data_length;
+                        }
+                        else
+                        {
+                            ta_l4stats->rxUdpBytesCount += data->data_length;
+                        }
+                    }
+                }
+
+                /* detect DHCP frames */
+                if (tad->packet_filter & CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_DHCP)
+                {
+                    /* DHCP frames are UDP frames with BOOTP ports */
+                    if (data->os_data_ptr[TA_IP_TYPE_OFFSET] == TA_IP_TYPE_UDP)
+                    {
+                        if (data->data_length > TA_UDP_DEST_PORT_OFFSET)
+                        {
+                            source_port = (data->os_data_ptr[TA_UDP_SOURCE_PORT_OFFSET] * 256) +
+                                          data->os_data_ptr[TA_UDP_SOURCE_PORT_OFFSET + 1];
+                            dest_port = (data->os_data_ptr[TA_UDP_DEST_PORT_OFFSET] * 256) +
+                                        data->os_data_ptr[TA_UDP_DEST_PORT_OFFSET + 1];
+
+                            if (((source_port == TA_UDP_PORT_BOOTPC) && (dest_port == TA_UDP_PORT_BOOTPS)) ||
+                                ((source_port == TA_UDP_PORT_BOOTPS) && (dest_port == TA_UDP_PORT_BOOTPC)))
+                            {
+                                /* The DHCP should have at least a message type (request, ack, nack, etc) */
+                                if (data->data_length > TA_DHCP_MESSAGE_TYPE_OFFSET + 6)
+                                {
+                                    CsrMemCpy(srcAddress.a, saddr, 6);
+
+                                    if (direction == CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_TX)
+                                    {
+                                        unifi_ta_indicate_protocol(card->ospriv,
+                                                                   CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_DHCP,
+                                                                   direction,
+                                                                   &srcAddress);
+                                        return TA_FRAME_ETHERNET_UNINTERESTING;
+                                    }
+
+                                    /* DHCPACK is a special indication */
+                                    if (!CsrMemCmp(data->os_data_ptr + TA_BOOTP_CLIENT_MAC_ADDR_OFFSET, sta_macaddr, 6))
+                                    {
+                                        if (data->os_data_ptr[TA_DHCP_MESSAGE_TYPE_OFFSET] == TA_DHCP_MESSAGE_TYPE_ACK)
+                                        {
+                                            unifi_ta_indicate_protocol(card->ospriv,
+                                                                       CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_DHCP_ACK,
+                                                                       direction,
+                                                                       &srcAddress);
+                                        }
+                                        else
+                                        {
+                                            unifi_ta_indicate_protocol(card->ospriv,
+                                                                       CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_DHCP,
+                                                                       direction,
+                                                                       &srcAddress);
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            return TA_FRAME_ETHERNET_INTERESTING;
+        }
+
+        /* detect protocol type EAPOL or WAI (treated as equivalent here) */
+        if (tad->packet_filter & CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_EAPOL)
+        {
+            if (TA_PROTO_TYPE_EAP == proto || TA_PROTO_TYPE_WAI == proto)
+            {
+                if ((TA_PROTO_TYPE_WAI == proto) || (direction != CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_TX) ||
+                    (data->os_data_ptr[TA_EAPOL_TYPE_OFFSET] == TA_EAPOL_TYPE_START))
+                {
+                    CsrMemCpy(srcAddress.a, saddr, 6);
+                    unifi_ta_indicate_protocol(card->ospriv,
+                                               CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_EAPOL,
+                                               direction, &srcAddress);
+                }
+                return TA_FRAME_ETHERNET_UNINTERESTING;
+            }
+        }
+
+        /* detect protocol type 0x0806 (ARP) */
+        if (tad->packet_filter & CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_ARP)
+        {
+            if (proto == TA_PROTO_TYPE_ARP)
+            {
+                CsrMemCpy(srcAddress.a, saddr, 6);
+                unifi_ta_indicate_protocol(card->ospriv,
+                                           CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_ARP,
+                                           direction, &srcAddress);
+                return TA_FRAME_ETHERNET_UNINTERESTING;
+            }
+        }
+
+        return TA_FRAME_ETHERNET_INTERESTING;
+    }
+    else if (tad->packet_filter & CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_AIRONET)
+    {
+        /* detect Aironet frames */
+        if (!CsrMemCmp(data->os_data_ptr + 3, aironet_snap, 5))
+        {
+            CsrMemCpy(srcAddress.a, saddr, 6);
+            unifi_ta_indicate_protocol(card->ospriv, CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_AIRONET,
+                                       direction, &srcAddress);
+        }
+    }
+
+    return TA_FRAME_ETHERNET_UNINTERESTING;
+} /* ta_detect_protocol() */
+
+
+static void tas_reset_data(ta_data_t *tad)
+{
+    CsrInt16 i;
+
+    for (i = 0; i < (TA_INTERVALS_NUM + 1); i++)
+    {
+        tad->stats.intervals[i] = 0;
+    }
+
+    tad->stats.rxFramesNum = 0;
+    tad->stats.txFramesNum = 0;
+    tad->stats.rxBytesCount = 0;
+    tad->stats.txBytesCount = 0;
+    tad->stats.rxMeanRate = 0;
+
+    tad->rx_sum_rate = 0;
+
+    tad->ta_l4stats.rxTcpBytesCount = 0;
+    tad->ta_l4stats.txTcpBytesCount = 0;
+    tad->ta_l4stats.rxUdpBytesCount = 0;
+    tad->ta_l4stats.txUdpBytesCount = 0;
+} /* tas_reset_data() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  API.
+ *  unifi_ta_sampling_init
+ *
+ *      (Re)Initialise the Traffic Analysis sampling module.
+ *      Resets the counters and timestamps.
+ *
+ *  Arguments:
+ *      tad             Pointer to a ta_data_t structure containing the
+ *                      context for this device instance.
+ *      drv_priv        An opaque pointer that the TA sampling module will
+ *                      pass in call-outs.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void unifi_ta_sampling_init(card_t *card)
+{
+    (void)unifi_ta_configure(card, CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_TYPE_RESET, NULL);
+
+    card->ta_sampling.packet_filter = CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_NONE;
+    card->ta_sampling.traffic_type = CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_OCCASIONAL;
+} /* unifi_ta_sampling_init() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  API.
+ *  unifi_ta_sample
+ *
+ *      Sample a data frame for the TA module.
+ *      This function stores all the useful information it can extract from
+ *      the frame and detects any specific protocols.
+ *
+ *  Arguments:
+ *      tad             The pointer to the TA sampling context struct.
+ *      direction       The direction of the frame (rx, tx)
+ *      data            Pointer to the frame data
+ *      saddr           Source MAC address of frame.
+ *      timestamp       Time (in msecs) that the frame was received.
+ *      rate            Reported data rate for the rx frame (0 for tx frames)
+ *
+ *  Returns:
+ *      None
+ * ---------------------------------------------------------------------------
+ */
+void unifi_ta_sample(card_t                            *card,
+                     CsrWifiRouterCtrlProtocolDirection direction,
+                     const bulk_data_desc_t            *data,
+                     const CsrUint8                    *saddr,
+                     const CsrUint8                    *sta_macaddr,
+                     CsrUint32                          timestamp,
+                     CsrUint16                          rate)
+{
+    ta_data_t *tad = &card->ta_sampling;
+    enum ta_frame_identity identity;
+    CsrUint32 time_delta;
+
+
+
+    /* Step1: Check for specific frames */
+    if (tad->packet_filter != CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_NONE)
+    {
+        identity = ta_detect_protocol(card, direction, data, saddr, sta_macaddr);
+    }
+    else
+    {
+        identity = TA_FRAME_ETHERNET_INTERESTING;
+    }
+
+
+    /* Step2: Update the information in the current record */
+    if (direction == CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_RX)
+    {
+        /* Update the Rx packet count and the throughput count */
+        tad->stats.rxFramesNum++;
+        tad->stats.rxBytesCount += data->data_length;
+
+        /* Accumulate packet Rx rates for later averaging */
+        tad->rx_sum_rate += rate;
+    }
+    else
+    {
+        if (identity == TA_FRAME_ETHERNET_INTERESTING)
+        {
+            /*
+             * Store the period between the last and the current frame.
+             * There is not point storing more than TA_MAX_INTERVALS_IN_C1 periods,
+             * the traffic will be bursty or continuous.
+             */
+            if (tad->stats.txFramesNum < TA_MAX_INTERVALS_IN_C1)
+            {
+                CsrUint32 interval;
+                CsrUint32 index_in_intervals;
+
+                interval = timestamp - tad->tx_last_ts;
+                tad->tx_last_ts = timestamp;
+                index_in_intervals = (interval + TA_INTERVALS_STEP / 2 - 1) / TA_INTERVALS_STEP;
+
+                /* If the interval is interesting, update the t1_intervals count */
+                if (index_in_intervals <= TA_INTERVALS_NUM)
+                {
+                    unifi_trace(card->ospriv, UDBG5,
+                                "unifi_ta_sample: TX interval=%d index=%d\n",
+                                interval, index_in_intervals);
+                    tad->stats.intervals[index_in_intervals]++;
+                }
+            }
+        }
+
+        /* Update the Tx packet count... */
+        tad->stats.txFramesNum++;
+        /* ... and the number of bytes for throughput. */
+        tad->stats.txBytesCount += data->data_length;
+    }
+
+    /*
+     * If more than one second has elapsed since the last report, send
+     * another one.
+     */
+    /* Unsigned subtraction handles wrap-around from 0xFFFFFFFF to 0 */
+    time_delta = timestamp - tad->last_indication_time;
+    if (time_delta >= 1000)
+    {
+        /*
+         * rxFramesNum can be flashed in tas_reset_data() by another thread.
+         * Use a temp to avoid division by zero.
+         */
+        CsrUint32 temp_rxFramesNum;
+        temp_rxFramesNum = tad->stats.rxFramesNum;
+
+        /* Calculate this interval's mean frame Rx rate from the sum */
+        if (temp_rxFramesNum)
+        {
+            tad->stats.rxMeanRate = tad->rx_sum_rate / temp_rxFramesNum;
+        }
+        unifi_trace(card->ospriv, UDBG5,
+                    "unifi_ta_sample: RX fr=%lu, r=%u, sum=%lu, av=%lu\n",
+                    tad->stats.rxFramesNum, rate,
+                    tad->rx_sum_rate, tad->stats.rxMeanRate);
+
+        /*
+         * Send the information collected in the stats struct
+         * to the SME and reset the counters.
+         */
+        if (tad->packet_filter & CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_CUSTOM)
+        {
+            CsrUint32 rxTcpThroughput = tad->ta_l4stats.rxTcpBytesCount / time_delta;
+            CsrUint32 txTcpThroughput = tad->ta_l4stats.txTcpBytesCount / time_delta;
+            CsrUint32 rxUdpThroughput = tad->ta_l4stats.rxUdpBytesCount / time_delta;
+            CsrUint32 txUdpThroughput = tad->ta_l4stats.txUdpBytesCount / time_delta;
+
+            unifi_ta_indicate_l4stats(card->ospriv,
+                                      rxTcpThroughput,
+                                      txTcpThroughput,
+                                      rxUdpThroughput,
+                                      txUdpThroughput
+                                      );
+        }
+        unifi_ta_indicate_sampling(card->ospriv, &tad->stats);
+        tas_reset_data(tad);
+        tad->last_indication_time = timestamp;
+    }
+} /* unifi_ta_sample() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  External API.
+ *  unifi_ta_configure
+ *
+ *      Configures the TA module parameters.
+ *
+ *  Arguments:
+ *      ta              The pointer to the TA module.
+ *      config_type     The type of the configuration request
+ *      config          Pointer to the configuration parameters.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error code otherwise
+ * ---------------------------------------------------------------------------
+ */
+CsrResult unifi_ta_configure(card_t                               *card,
+                             CsrWifiRouterCtrlTrafficConfigType    config_type,
+                             const CsrWifiRouterCtrlTrafficConfig *config)
+{
+    ta_data_t *tad = &card->ta_sampling;
+
+    /* Reinitialise our data when we are reset */
+    if (config_type == CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_TYPE_RESET)
+    {
+        /* Reset the stats to zero */
+        tas_reset_data(tad);
+
+        /* Reset the timer variables */
+        tad->tx_last_ts = 0;
+        tad->last_indication_time = 0;
+
+        return CSR_RESULT_SUCCESS;
+    }
+
+    if (config_type == CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_TYPE_FILTER)
+    {
+        tad->packet_filter = config->packetFilter;
+
+        if (tad->packet_filter & CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_CUSTOM)
+        {
+            tad->custom_filter = config->customFilter;
+        }
+
+        return CSR_RESULT_SUCCESS;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_ta_configure() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  External API.
+ *  unifi_ta_classification
+ *
+ *      Configures the current TA classification.
+ *
+ *  Arguments:
+ *      ta              The pointer to the TA module.
+ *      traffic_type    The classification type
+ *      period          The traffic period if the type is periodic
+ *
+ *  Returns:
+ *      None
+ * ---------------------------------------------------------------------------
+ */
+void unifi_ta_classification(card_t                      *card,
+                             CsrWifiRouterCtrlTrafficType traffic_type,
+                             CsrUint16                    period)
+{
+    unifi_trace(card->ospriv, UDBG3,
+                "Changed current ta classification to: %d\n", traffic_type);
+
+    card->ta_sampling.traffic_type = traffic_type;
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_ta_sampling.h
@@ -0,0 +1,75 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     csr_wifi_hip_ta_sampling.h
+ *
+ *  PURPOSE:
+ *      This file contains Traffic Analysis definitions common to the
+ *      sampling and analysis modules.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#ifndef __TA_SAMPLING_H__
+#define __TA_SAMPLING_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "csr_wifi_hip_unifi.h"
+
+typedef struct ta_l4stats
+{
+    CsrUint32 rxTcpBytesCount;
+    CsrUint32 txTcpBytesCount;
+    CsrUint32 rxUdpBytesCount;
+    CsrUint32 txUdpBytesCount;
+} ta_l4stats_t;
+
+/*
+ * Context structure to preserve state between calls.
+ */
+
+typedef struct ta_data
+{
+    /* Current packet filter configuration */
+    CsrUint16 packet_filter;
+
+    /* Current packet custom filter configuration */
+    CsrWifiRouterCtrlTrafficFilter custom_filter;
+
+    /* The timestamp of the last tx packet processed. */
+    CsrUint32 tx_last_ts;
+
+    /* The timestamp of the last packet processed. */
+    CsrUint32 last_indication_time;
+
+    /* Statistics */
+    CsrWifiRouterCtrlTrafficStats stats;
+
+    /* Current traffic classification */
+    CsrWifiRouterCtrlTrafficType traffic_type;
+
+    /* Sum of packet rx rates for this interval used to calculate mean */
+    CsrUint32    rx_sum_rate;
+    ta_l4stats_t ta_l4stats;
+} ta_data_t;
+
+
+void unifi_ta_sampling_init(card_t *card);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __TA_SAMPLING_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_udi.c
@@ -0,0 +1,268 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     csr_wifi_hip_card_udi.c
+ *
+ *  PURPOSE:
+ *      Maintain a list of callbacks to log UniFi exchanges to one or more
+ *      debug/monitoring client applications.
+ *
+ * NOTES:
+ *      Just call the UDI driver log fn directly for now.
+ *      When done properly, each open() on the UDI device will install
+ *      a log function. We will call all log fns whenever a signal is written
+ *      to or read form the UniFi.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_card.h"
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_print_status
+ *
+ *      Print status info to given character buffer.
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+CsrInt32 unifi_print_status(card_t *card, CsrCharString *str, CsrInt32 *remain)
+{
+    CsrCharString *p = str;
+    sdio_config_data_t *cfg;
+    CsrUint16 i, n;
+    CsrInt32 remaining = *remain;
+    CsrInt32 written;
+#ifdef CSR_UNSAFE_SDIO_ACCESS
+    CsrInt32 iostate;
+    CsrResult r;
+    static const CsrCharString *const states[] = {
+        "AWAKE", "DROWSY", "TORPID"
+    };
+    #define SHARED_READ_RETRY_LIMIT 10
+    CsrUint8 b;
+#endif
+
+    if (remaining <= 0)
+    {
+        return 0;
+    }
+
+    i = n = 0;
+    written = CsrSnprintf(p, remaining, "Chip ID %u\n",
+                          (CsrUint16)card->chip_id);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "Chip Version %04X\n",
+                          card->chip_version);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "HIP v%u.%u\n",
+                          (card->config_data.version >> 8) & 0xFF,
+                          card->config_data.version & 0xFF);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "Build %lu: %s\n",
+                          card->build_id, card->build_id_string);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    cfg = &card->config_data;
+
+    written = CsrSnprintf(p, remaining, "sdio ctrl offset          %u\n",
+                          cfg->sdio_ctrl_offset);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "fromhost sigbuf handle    %u\n",
+                          cfg->fromhost_sigbuf_handle);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "tohost_sigbuf_handle      %u\n",
+                          cfg->tohost_sigbuf_handle);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "num_fromhost_sig_frags    %u\n",
+                          cfg->num_fromhost_sig_frags);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "num_tohost_sig_frags      %u\n",
+                          cfg->num_tohost_sig_frags);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "num_fromhost_data_slots   %u\n",
+                          cfg->num_fromhost_data_slots);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "num_tohost_data_slots     %u\n",
+                          cfg->num_tohost_data_slots);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "data_slot_size            %u\n",
+                          cfg->data_slot_size);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    /* Added by protocol version 0x0001 */
+    written = CsrSnprintf(p, remaining, "overlay_size              %u\n",
+                          (CsrUint16)cfg->overlay_size);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    /* Added by protocol version 0x0300 */
+    written = CsrSnprintf(p, remaining, "data_slot_round           %u\n",
+                          cfg->data_slot_round);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "sig_frag_size             %u\n",
+                          cfg->sig_frag_size);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    /* Added by protocol version 0x0300 */
+    written = CsrSnprintf(p, remaining, "tohost_sig_pad            %u\n",
+                          cfg->tohost_signal_padding);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    written = CsrSnprintf(p, remaining, "\nInternal state:\n");
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    written = CsrSnprintf(p, remaining, "Last PHY PANIC: %04x:%04x\n",
+                          card->last_phy_panic_code, card->last_phy_panic_arg);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "Last MAC PANIC: %04x:%04x\n",
+                          card->last_mac_panic_code, card->last_mac_panic_arg);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    written = CsrSnprintf(p, remaining, "fhsr: %u\n",
+                          (CsrUint16)card->from_host_signals_r);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "fhsw: %u\n",
+                          (CsrUint16)card->from_host_signals_w);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "thsr: %u\n",
+                          (CsrUint16)card->to_host_signals_r);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "thsw: %u\n",
+                          (CsrUint16)card->to_host_signals_w);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining,
+                          "fh buffer contains: %u signals, %u bytes\n",
+                          card->fh_buffer.count,
+                          card->fh_buffer.ptr - card->fh_buffer.buf);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    written = CsrSnprintf(p, remaining, "paused: ");
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    for (i = 0; i < sizeof(card->tx_q_paused_flag) / sizeof(card->tx_q_paused_flag[0]); i++)
+    {
+        written = CsrSnprintf(p, remaining, card->tx_q_paused_flag[i]?"1" : "0");
+        UNIFI_SNPRINTF_RET(p, remaining, written);
+    }
+    written = CsrSnprintf(p, remaining, "\n");
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    written = CsrSnprintf(p, remaining,
+                          "fh command q: %u waiting, %u free of %u:\n",
+                          CSR_WIFI_HIP_Q_SLOTS_USED(&card->fh_command_queue),
+                          CSR_WIFI_HIP_Q_SLOTS_FREE(&card->fh_command_queue),
+                          UNIFI_SOFT_COMMAND_Q_LENGTH);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    for (i = 0; i < UNIFI_NO_OF_TX_QS; i++)
+    {
+        written = CsrSnprintf(p, remaining,
+                              "fh traffic q[%u]: %u waiting, %u free of %u:\n",
+                              i,
+                              CSR_WIFI_HIP_Q_SLOTS_USED(&card->fh_traffic_queue[i]),
+                              CSR_WIFI_HIP_Q_SLOTS_FREE(&card->fh_traffic_queue[i]),
+                              UNIFI_SOFT_TRAFFIC_Q_LENGTH);
+        UNIFI_SNPRINTF_RET(p, remaining, written);
+    }
+
+    written = CsrSnprintf(p, remaining, "fh data slots free: %u\n",
+                          card->from_host_data?CardGetFreeFromHostDataSlots(card) : 0);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+
+    written = CsrSnprintf(p, remaining, "From host data slots:");
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    n = card->config_data.num_fromhost_data_slots;
+    for (i = 0; i < n && card->from_host_data; i++)
+    {
+        written = CsrSnprintf(p, remaining, " %u",
+                              (CsrUint16)card->from_host_data[i].bd.data_length);
+        UNIFI_SNPRINTF_RET(p, remaining, written);
+    }
+    written = CsrSnprintf(p, remaining, "\n");
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    written = CsrSnprintf(p, remaining, "To host data slots:");
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    n = card->config_data.num_tohost_data_slots;
+    for (i = 0; i < n && card->to_host_data; i++)
+    {
+        written = CsrSnprintf(p, remaining, " %u",
+                              (CsrUint16)card->to_host_data[i].data_length);
+        UNIFI_SNPRINTF_RET(p, remaining, written);
+    }
+
+    written = CsrSnprintf(p, remaining, "\n");
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+#ifdef CSR_UNSAFE_SDIO_ACCESS
+    written = CsrSnprintf(p, remaining, "Host State: %s\n", states[card->host_state]);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    r = unifi_check_io_status(card, &iostate);
+    if (iostate == 1)
+    {
+        written = CsrSnprintf(p, remaining, "I/O Check: F1 disabled\n");
+        UNIFI_SNPRINTF_RET(p, remaining, written);
+    }
+    else
+    {
+        if (iostate == 1)
+        {
+            written = CsrSnprintf(p, remaining, "I/O Check: pending interrupt\n");
+            UNIFI_SNPRINTF_RET(p, remaining, written);
+        }
+
+        written = CsrSnprintf(p, remaining, "BH reason interrupt = %d\n",
+                              card->bh_reason_unifi);
+        UNIFI_SNPRINTF_RET(p, remaining, written);
+        written = CsrSnprintf(p, remaining, "BH reason host      = %d\n",
+                              card->bh_reason_host);
+        UNIFI_SNPRINTF_RET(p, remaining, written);
+
+        for (i = 0; i < SHARED_READ_RETRY_LIMIT; i++)
+        {
+            r = unifi_read_8_or_16(card, card->sdio_ctrl_addr + 2, &b);
+            if ((r == CSR_RESULT_SUCCESS) && (!(b & 0x80)))
+            {
+                written = CsrSnprintf(p, remaining, "fhsr: %u (driver thinks is %u)\n",
+                                      b, card->from_host_signals_r);
+                UNIFI_SNPRINTF_RET(p, remaining, written);
+                break;
+            }
+        }
+        iostate = unifi_read_shared_count(card, card->sdio_ctrl_addr + 4);
+        written = CsrSnprintf(p, remaining, "thsw: %u (driver thinks is %u)\n",
+                              iostate, card->to_host_signals_w);
+        UNIFI_SNPRINTF_RET(p, remaining, written);
+    }
+#endif
+
+    written = CsrSnprintf(p, remaining, "\nStats:\n");
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "Total SDIO bytes: R=%lu W=%lu\n",
+                          card->sdio_bytes_read, card->sdio_bytes_written);
+
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+    written = CsrSnprintf(p, remaining, "Interrupts generated on card: %lu\n",
+                          card->unifi_interrupt_seq);
+    UNIFI_SNPRINTF_RET(p, remaining, written);
+
+    *remain = remaining;
+    return (p - str);
+} /* unifi_print_status() */
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_unifi.h
@@ -0,0 +1,852 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ * FILE : csr_wifi_hip_unifi.h
+ *
+ * PURPOSE : Public API for the UniFi HIP core library.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#ifndef __CSR_WIFI_HIP_UNIFI_H__
+#define __CSR_WIFI_HIP_UNIFI_H__ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_HIP_TA_DISABLE
+#include "csr_wifi_router_ctrl_prim.h"
+#include "csr_wifi_router_prim.h"
+#else
+#include "csr_time.h"
+#endif
+
+/* SDIO chip ID numbers */
+
+/* Manufacturer id */
+#define SDIO_MANF_ID_CSR              0x032a
+
+/* Device id */
+#define SDIO_CARD_ID_UNIFI_1          0x0001
+#define SDIO_CARD_ID_UNIFI_2          0x0002
+#define SDIO_CARD_ID_UNIFI_3          0x0007
+#define SDIO_CARD_ID_UNIFI_4          0x0008
+
+/* Function number for WLAN */
+#define SDIO_WLAN_FUNC_ID_UNIFI_1          0x0001
+#define SDIO_WLAN_FUNC_ID_UNIFI_2          0x0001
+#define SDIO_WLAN_FUNC_ID_UNIFI_3          0x0001
+#define SDIO_WLAN_FUNC_ID_UNIFI_4          0x0002
+
+/* Maximum SDIO bus clock supported. */
+#define UNIFI_SDIO_CLOCK_MAX_HZ    50000000  /* Hz */
+
+/*
+ * Initialisation SDIO bus clock.
+ *
+ * The initialisation clock speed should be used from when the chip has been
+ * reset until the first MLME-reset has been received (i.e. during firmware
+ * initialisation), unless UNIFI_SDIO_CLOCK_SAFE_HZ applies.
+ */
+#define UNIFI_SDIO_CLOCK_INIT_HZ    12500000 /* Hz */
+
+/*
+ * Safe SDIO bus clock.
+ *
+ * The safe speed should be used when the chip is in deep sleep or
+ * it's state is unknown (just after reset / power on).
+ */
+#define UNIFI_SDIO_CLOCK_SAFE_HZ    1000000  /* Hz */
+
+/* I/O default block size to use for UniFi. */
+#define UNIFI_IO_BLOCK_SIZE     64
+
+#define UNIFI_WOL_OFF   0
+#define UNIFI_WOL_SDIO  1
+#define UNIFI_WOL_PIO   2
+
+/* The number of Tx traffic queues */
+#define UNIFI_NO_OF_TX_QS              4
+
+#define CSR_WIFI_HIP_RESERVED_HOST_TAG 0xFFFFFFFF
+
+/*
+ * The number of slots in the from-host queues.
+ *
+ * UNIFI_SOFT_TRAFFIC_Q_LENGTH is the number of slots in the traffic queues
+ * and there will be UNIFI_NO_OF_TX_QS of them.
+ * Traffic queues are used for data packets.
+ *
+ * UNIFI_SOFT_COMMAND_Q_LENGTH is the number of slots in the command queue.
+ * The command queue is used for MLME management requests.
+ *
+ * Queues are ring buffers and so must always have 1 unused slot.
+ */
+#define UNIFI_SOFT_TRAFFIC_Q_LENGTH (20 + 1)
+#define UNIFI_SOFT_COMMAND_Q_LENGTH (16 + 1)
+
+#include "csr_types.h"          /* from the synergy porting folder */
+#include "csr_framework_ext.h"  /* from the synergy porting folder */
+#include "csr_sdio.h"           /* from the synergy porting folder */
+#include "csr_pmem.h"           /* from the synergy porting folder */
+#include "csr_util.h"           /* from the synergy porting folder */
+#include "csr_formatted_io.h"   /* from the synergy gsp folder */
+#include "csr_wifi_result.h"
+
+
+/* Traffic queue ordered according to priority
+ * EAPOL/Uncontrolled port Queue should be the last
+ */
+typedef enum
+{
+    UNIFI_TRAFFIC_Q_BK = 0,
+    UNIFI_TRAFFIC_Q_BE,
+    UNIFI_TRAFFIC_Q_VI,
+    UNIFI_TRAFFIC_Q_VO,
+    UNIFI_TRAFFIC_Q_EAPOL,    /* Non existant in HIP */
+    UNIFI_TRAFFIC_Q_MAX,      /* Non existant */
+    UNIFI_TRAFFIC_Q_MLME      /* Non existant */
+} unifi_TrafficQueue;
+
+/*
+ * Structure describing a bulk data slot.
+ * This structure is shared between the HIP core library and the OS
+ * layer. See the definition of unifi_net_data_malloc() for more details.
+ *
+ * The data_length field is used to indicate empty/occupied state.
+ * Needs to be defined before #include "unifi_os.h".
+ */
+typedef struct _bulk_data_desc
+{
+    const CsrUint8 *os_data_ptr;
+    CsrUint32       data_length;
+    const void     *os_net_buf_ptr;
+    CsrUint32       net_buf_length;
+} bulk_data_desc_t;
+
+/* Structure of an entry in the Symbol Look Up Table (SLUT). */
+typedef struct _symbol
+{
+    CsrUint16 id;
+    CsrUint32 obj;
+} symbol_t;
+
+/*
+ * Header files need to be included from the current directory,
+ * the SME library, the synergy framework and the OS layer.
+ * A thin OS layer needs to be implemented in the porting exercise.
+ *
+ * Note that unifi_os.h should be included only in unifi.h
+ */
+
+#include "unifi_os.h"
+
+/*
+ * Contains the HIP core definitions selected in the porting exercise, such as
+ * UNIFI_PAD_BULK_DATA_TO_BLOCK_SIZE and UNIFI_PAD_SIGNALS_TO_BLOCK_SIZE.
+ * Implemented in the OS layer, as part of the porting exersice.
+ */
+#include "unifi_config.h"
+
+#include "csr_wifi_hip_signals.h" /* from this dir */
+
+/*
+ * The card structure is an opaque pointer that is used to pass context
+ * to the upper-edge API functions.
+ */
+typedef struct card card_t;
+
+
+/*
+ * This structure describes all of the bulk data that 'might' be
+ * associated with a signal.
+ */
+typedef struct _bulk_data_param
+{
+    bulk_data_desc_t d[UNIFI_MAX_DATA_REFERENCES];
+} bulk_data_param_t;
+
+
+/*
+ * This structure describes the chip and HIP core lib
+ * information that exposed to the OS layer.
+ */
+typedef struct _card_info
+{
+    CsrUint16 chip_id;
+    CsrUint16 chip_version;
+    CsrUint32 fw_build;
+    CsrUint16 fw_hip_version;
+    CsrUint32 sdio_block_size;
+} card_info_t;
+
+
+/*
+ * Mini-coredump definitions
+ */
+/* Definition of XAP memory ranges used by the mini-coredump system.
+ * Note that, these values are NOT the same as UNIFI_REGISTERS, etc
+ * in unifihw.h which don't allow selection of register areas for each XAP.
+ */
+typedef enum unifi_coredump_space
+{
+    UNIFI_COREDUMP_MAC_REG,
+    UNIFI_COREDUMP_PHY_REG,
+    UNIFI_COREDUMP_SH_DMEM,
+    UNIFI_COREDUMP_MAC_DMEM,
+    UNIFI_COREDUMP_PHY_DMEM,
+    UNIFI_COREDUMP_TRIGGER_MAGIC = 0xFEED
+} unifi_coredump_space_t;
+
+/* Structure used to request a register value from a mini-coredump buffer */
+typedef struct unifi_coredump_req
+{
+    /* From user */
+    CsrInt32               index;       /* 0=newest, -1=oldest */
+    unifi_coredump_space_t space;       /* memory space */
+    CsrUint32              offset;      /* register offset in space */
+    /* From driver */
+    CsrUint32 drv_build;                /* Driver build id */
+    CsrUint32 chip_ver;                 /* Chip version */
+    CsrUint32 fw_ver;                   /* Firmware version */
+    CsrInt32  requestor;                /* Requestor: 0=auto dump, 1=manual */
+    CsrTime   timestamp;                /* time of capture by driver */
+    CsrUint32 serial;                   /* capture serial number */
+    CsrInt32  value;                    /* register value */
+} unifi_coredump_req_t;                 /* mini-coredumped reg value request */
+
+
+/**
+ * @defgroup upperedge Upper edge API
+ *
+ * The following functions are implemented in the HIP core lib.
+ */
+
+/**
+ *
+ * Initialise the HIP core lib.
+ * Note that the OS layer must initialise the SDIO glue layer and obtain
+ * an SDIO function context, prior to this call.
+ *
+ * @param sdiopriv the SDIO function context.
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @return \p card_t the HIP core lib API context.
+ *
+ * @ingroup upperedge
+ */
+card_t* unifi_alloc_card(CsrSdioFunction *sdiopriv, void *ospriv);
+
+
+/**
+ *
+ * Initialise the UniFi chip.
+ *
+ * @param card the HIP core lib API context.
+ *
+ * @param led_mask the led mask to apply to UniFi.
+ *
+ * @return \b 0 if UniFi is initialized.
+ *
+ * @return \b -CSR_EIO if an I/O error occured while initializing UniFi
+ *
+ * @return \b -CSR_ENODEV if the card is no longer present.
+ *
+ * @ingroup upperedge
+ */
+CsrResult unifi_init_card(card_t *card, CsrInt32 led_mask);
+
+/**
+ *
+ * De-Initialise the HIP core lib.
+ *
+ * @param card the HIP core lib API context.
+ *
+ * @ingroup upperedge
+ */
+void unifi_free_card(card_t *card);
+
+/**
+ *
+ * Cancel all the signals pending in the HIP core lib.
+ * Normally used during a system suspend when the power is retained on UniFi.
+ *
+ * @param card the HIP core lib API context.
+ *
+ * @ingroup upperedge
+ */
+void unifi_cancel_pending_signals(card_t *card);
+
+/**
+ *
+ * Send a signal to UniFi.
+ * Normally it is called from unifi_sys_hip_req() and the OS layer
+ * Tx data plane.
+ *
+ * Note that the bulkdata buffers ownership is passed to the HIP core lib.
+ * These buffers must be allocated using unifi_net_data_malloc().
+ *
+ * @param card the HIP core lib API context.
+ *
+ * @param sigptr pointer to the signal.
+ *
+ * @param siglen size of the signal.
+ *
+ * @param bulkdata pointer to the bulk data associated with the signal.
+ *
+ * @return \b 0 signal is sent.
+ *
+ * @return \b -CSR_EIO if an error occured while sending the signal
+ *
+ * @return \b -CSR_ENODEV if the card is no longer present.
+ *
+ * @ingroup upperedge
+ */
+CsrResult unifi_send_signal(card_t *card, const CsrUint8 *sigptr,
+                            CsrUint32 siglen,
+                            const bulk_data_param_t *bulkdata);
+
+/**
+ *
+ * Check if the HIP core lib has resources to send a signal.
+ * Normally there no need to use this function.
+ *
+ * @param card the HIP core lib API context.
+ *
+ * @param sigptr pointer to the signal.
+ *
+ * @return \b 0 if there are resources for the signal.
+ *
+ * @return \b -CSR_ENOSPC if there are not enough resources
+ *
+ * @ingroup upperedge
+ */
+CsrResult unifi_send_resources_available(card_t *card, const CsrUint8 *sigptr);
+
+/**
+ *
+ * Read the UniFi chip and the HIP core lib information.
+ *
+ * @param card the HIP core lib API context.
+ *
+ * @param card_info pointer to save the information.
+ *
+ * @ingroup upperedge
+ */
+void unifi_card_info(card_t *card, card_info_t *card_info);
+
+/**
+ *
+ * Print the UniFi I/O and Interrupt status.
+ * Normally it is used for debug purposes only.
+ *
+ * @param card the HIP core lib API context.
+
+ * @param status buffer for the chip status
+ *
+ * @return \b 0 if the check was performed.
+ *
+ * @return \b -CSR_EIO if an error occured while checking the status.
+ *
+ * @return \b -CSR_ENODEV if the card is no longer present.
+ *
+ * @ingroup upperedge
+ */
+CsrResult unifi_check_io_status(card_t *card, CsrInt32 *status);
+
+
+/**
+ *
+ * Run the HIP core lib Botton-Half.
+ * Whenever the HIP core lib want this function to be called
+ * by the OS layer, it calls unifi_run_bh().
+ *
+ * @param card the HIP core lib API context.
+ *
+ * @param remaining pointer to return the time (in msecs) that this function
+ * should be re-scheduled. A return value of 0 means that no re-scheduling
+ * is required. If unifi_bh() is called before the timeout expires,
+ * the caller must pass in the remaining time.
+ *
+ * @return \b 0 if no error occured.
+ *
+ * @return \b -CSR_ENODEV if the card is no longer present.
+ *
+ * @return \b -CSR_E* if an error occured while running the bottom half.
+ *
+ * @ingroup upperedge
+ */
+CsrResult unifi_bh(card_t *card, CsrUint32 *remaining);
+
+
+/**
+ * UniFi Low Power Mode (Deep Sleep Signaling)
+ *
+ * unifi_low_power_mode defines the UniFi Deep Sleep Signaling status.
+ * Use with unifi_configure_low_power_mode() to enable/disable
+ * the Deep Sleep Signaling.
+ */
+enum unifi_low_power_mode
+{
+    UNIFI_LOW_POWER_DISABLED,
+    UNIFI_LOW_POWER_ENABLED
+};
+
+/**
+ * Periodic Wake Host Mode
+ *
+ * unifi_periodic_wake_mode defines the Periodic Wake Host Mode.
+ * It can only be set to UNIFI_PERIODIC_WAKE_HOST_ENABLED if
+ * low_power_mode == UNIFI_LOW_POWER_ENABLED.
+ */
+enum unifi_periodic_wake_mode
+{
+    UNIFI_PERIODIC_WAKE_HOST_DISABLED,
+    UNIFI_PERIODIC_WAKE_HOST_ENABLED
+};
+
+/**
+ *
+ * Run the HIP core lib Botton-Half.
+ * Whenever the HIP core lib want this function to be called
+ * by the OS layer, it calls unifi_run_bh().
+ *
+ * Typically, the SME is responsible for configuring these parameters,
+ * so unifi_sys_configure_power_mode_req() is usually implemented
+ * as a direct call to unifi_configure_low_power_mode().
+ *
+ * Note: When polling mode is used instead of interrupts,
+ * low_power_mode must never be set to UNIFI_LOW_POWER_ENABLED.
+ *
+ * @param card the HIP core lib API context.
+ *
+ * @param low_power_mode the Low Power Mode.
+ *
+ * @param periodic_wake_mode the Periodic Wake Mode.
+ *
+ * @return \b 0 if no error occured.
+ *
+ * @return \b -CSR_E* if the request failed.
+ *
+ * @ingroup upperedge
+ */
+CsrResult unifi_configure_low_power_mode(card_t                       *card,
+                                         enum unifi_low_power_mode     low_power_mode,
+                                         enum unifi_periodic_wake_mode periodic_wake_mode);
+
+/**
+ *
+ * Forces the UniFi chip to enter a Deep Sleep state.
+ * This is normally called by the OS layer when the platform suspends.
+ *
+ * Note that if the UniFi Low Power Mode is disabled this call fails.
+ *
+ * @param card the HIP core lib API context.
+ *
+ * @return \b 0 if no error occured.
+ *
+ * @return \b -CSR_ENODEV if the card is no longer present.
+ *
+ * @return \b -CSR_E* if the request failed.
+ *
+ * @ingroup upperedge
+ */
+CsrResult unifi_force_low_power_mode(card_t *card);
+
+#ifndef CSR_WIFI_HIP_TA_DISABLE
+/**
+ * Configure the Traffic Analysis sampling
+ *
+ * Enable or disable statistics gathering.
+ * Enable or disable particular packet detection.
+ *
+ * @param card the HIP core context
+ * @param config_type the item to configure
+ * @param config pointer to struct containing config info
+ *
+ * @return \b 0 if configuration was successful
+ *
+ * @return \b -CSR_EINVAL if a parameter had an invalid value
+ *
+ * @ingroup upperedge
+ */
+CsrResult unifi_ta_configure(card_t                               *card,
+                             CsrWifiRouterCtrlTrafficConfigType    config_type,
+                             const CsrWifiRouterCtrlTrafficConfig *config);
+
+/**
+ * Pass a packet for Traffic Analysis sampling
+ *
+ * @param card the HIP core context
+ * @param direction the direction (Rx or Tx) of the frame.
+ * @param data pointer to bulkdata struct containing the packet
+ * @param saddr the source address of the packet
+ * @param sta_macaddr the MAC address of the UniFi chip
+ * @param timestamp the current time in msecs
+ *
+ * @ingroup upperedge
+ */
+void unifi_ta_sample(card_t                            *card,
+                     CsrWifiRouterCtrlProtocolDirection direction,
+                     const bulk_data_desc_t            *data,
+                     const CsrUint8                    *saddr,
+                     const CsrUint8                    *sta_macaddr,
+                     CsrUint32                          timestamp,
+                     CsrUint16                          rate);
+
+/**
+ * Notify the HIP core lib for a detected Traffic Classification.
+ * Typically, the SME is responsible for configuring these parameters,
+ * so unifi_sys_traffic_classification_req() is usually implemented
+ * as a direct call to unifi_ta_classification().
+ *
+ * @param card the HIP core context.
+ * @param traffic_type the detected traffic type.
+ * @param period The detected period of the traffic.
+ *
+ * @ingroup upperedge
+ */
+void unifi_ta_classification(card_t                      *card,
+                             CsrWifiRouterCtrlTrafficType traffic_type,
+                             CsrUint16                    period);
+
+#endif
+/**
+ * Use software to hard reset the chip.
+ * This is a subset of the unifi_init_card() functionality and should
+ * only be used only to reset a paniced chip before a coredump is taken.
+ *
+ * @param card the HIP core context.
+ *
+ * @ingroup upperedge
+ */
+CsrResult unifi_card_hard_reset(card_t *card);
+
+
+CsrResult unifi_card_readn(card_t *card, CsrUint32 unifi_addr, void *pdata, CsrUint16 len);
+CsrResult unifi_card_read16(card_t *card, CsrUint32 unifi_addr, CsrUint16 *pdata);
+CsrResult unifi_card_write16(card_t *card, CsrUint32 unifi_addr, CsrUint16 data);
+
+
+enum unifi_dbg_processors_select
+{
+    UNIFI_PROC_MAC,
+    UNIFI_PROC_PHY,
+    UNIFI_PROC_BT,
+    UNIFI_PROC_BOTH,
+    UNIFI_PROC_INVALID
+};
+
+CsrResult unifi_card_stop_processor(card_t *card, enum unifi_dbg_processors_select which);
+
+/**
+ * Call-outs from the HIP core lib to the OS layer.
+ * The following functions need to be implemented during the porting exercise.
+ */
+
+/**
+ * Selects appropriate queue according to priority
+ * Helps maintain uniformity in queue selection between the HIP
+ * and the OS layers.
+ *
+ * @param priority priority of the packet
+ *
+ * @return \b Traffic queue to which a packet of this priority belongs
+ *
+ * @ingroup upperedge
+ */
+unifi_TrafficQueue
+unifi_frame_priority_to_queue(CSR_PRIORITY priority);
+
+/**
+ * Returns the priority corresponding to a particular Queue when that is used
+ * when downgrading a packet to a lower AC.
+ * Helps maintain uniformity in queue - priority mapping between the HIP
+ * and the OS layers.
+ *
+ * @param queue
+ *
+ * @return \b Highest priority corresponding to this queue
+ *
+ * @ingroup upperedge
+ */
+CSR_PRIORITY unifi_get_default_downgrade_priority(unifi_TrafficQueue queue);
+
+/**
+ *
+ * Flow control callbacks.
+ * unifi_pause_xmit() is called when the HIP core lib does not have any
+ * resources to store data packets. The OS layer needs to pause
+ * the Tx data plane until unifi_restart_xmit() is called.
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @ingroup upperedge
+ */
+void unifi_pause_xmit(void *ospriv, unifi_TrafficQueue queue);
+void unifi_restart_xmit(void *ospriv, unifi_TrafficQueue queue);
+
+/**
+ *
+ * Request to run the Bottom-Half.
+ * The HIP core lib calls this function to request that unifi_bh()
+ * needs to be run by the OS layer. It can be called anytime, i.e.
+ * when the unifi_bh() is running.
+ * Since unifi_bh() is not re-entrant, usually unifi_run_bh() sets
+ * an event to a thread that schedules a call to unifi_bh().
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @ingroup upperedge
+ */
+CsrResult unifi_run_bh(void *ospriv);
+
+/**
+ *
+ * Delivers a signal received from UniFi to the OS layer.
+ * Normally, the data signals should be delivered to the data plane
+ * and all the rest to the SME (unifi_sys_hip_ind()).
+ *
+ * Note that the OS layer is responsible for freeing the bulkdata
+ * buffers, using unifi_net_data_free().
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @param sigptr pointer to the signal.
+ *
+ * @param siglen size of the signal.
+ *
+ * @param bulkdata pointer to the bulk data associated with the signal.
+ *
+ * @ingroup upperedge
+ */
+void unifi_receive_event(void *ospriv,
+                         CsrUint8 *sigdata, CsrUint32 siglen,
+                         const bulk_data_param_t *bulkdata);
+
+
+typedef struct
+{
+    CsrUint16 free_fh_sig_queue_slots[UNIFI_NO_OF_TX_QS];
+    CsrUint16 free_fh_bulkdata_slots;
+    CsrUint16 free_fh_fw_slots;
+} unifi_HipQosInfo;
+
+void unifi_get_hip_qos_info(card_t *card, unifi_HipQosInfo *hipqosinfo);
+
+
+/**
+ * Functions that read a portion of a firmware file.
+ *
+ * Note: If the UniFi chip runs the f/w from ROM, the HIP core may never
+ * call these functions. Also, the HIP core may call these functions even if
+ * a f/w file is not available. In this case, it is safe to fail the request.
+ */
+#define UNIFI_FW_STA    1   /* Identify STA firmware file */
+
+/**
+ *
+ * Ask the OS layer to initialise a read from a f/w file.
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @param is_fw if 0 the request if for the loader file, if 1 the request
+ * is for a f/w file.
+ *
+ * @param info a card_info_t structure containing versions information.
+ * Note that some members of the structure may not be initialised.
+ *
+ * @return \p NULL if the file is not available, or a pointer which contains
+ * OS specific information for the file (typically the contents of the file)
+ * that the HIP core uses when calling unifi_fw_read() and unifi_fw_read_stop()
+ *
+ * @ingroup upperedge
+ */
+void* unifi_fw_read_start(void *ospriv, CsrInt8 is_fw, const card_info_t *info);
+
+/**
+ *
+ * Ask the OS layer to return a portion from a f/w file.
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @param arg the OS pointer returned by unifi_fw_read_start().
+ *
+ * @param offset the offset in the f/w file to read the read from.
+ *
+ * @param buf the buffer to store the returned data.
+ *
+ * @param len the size in bytes of the requested read.
+ *
+ * @ingroup upperedge
+ */
+CsrInt32 unifi_fw_read(void *ospriv, void *arg, CsrUint32 offset, void *buf, CsrUint32 len);
+
+/**
+ *
+ * Ask the OS layer to finish reading from a f/w file.
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @param dlpriv the OS pointer returned by unifi_fw_read_start().
+ *
+ * @ingroup upperedge
+ */
+void unifi_fw_read_stop(void *ospriv, void *dlpriv);
+
+/**
+ *
+ * Ask OS layer for a handle to a dynamically allocated firmware buffer
+ * (primarily intended for production test images which may need conversion)
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @param fwbuf pointer to dynamically allocated buffer
+ *
+ * @param len length of provided buffer in bytes
+ *
+ * @ingroup upperedge
+ */
+void* unifi_fw_open_buffer(void *ospriv, void *fwbuf, CsrUint32 len);
+
+/**
+ *
+ * Release a handle to a dynamically allocated firmware buffer
+ * (primarily intended for production test images which may need conversion)
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @param fwbuf pointer to dynamically allocated buffer
+ *
+ * @ingroup upperedge
+ */
+void unifi_fw_close_buffer(void *ospriv, void *fwbuf);
+
+#ifndef CSR_WIFI_HIP_TA_DISABLE
+/*
+ * Driver must provide these.
+ *
+ * A simple implementation will just call
+ * unifi_sys_traffic_protocol_ind() or unifi_sys_traffic_classification_ind()
+ * respectively. See sme_csr_userspace/sme_userspace.c.
+ */
+/**
+ *
+ * Indicates a detected packet of type packet_type.
+ * Typically, this information is processed by the SME so
+ * unifi_ta_indicate_protocol() needs to schedule a call to
+ * unifi_sys_traffic_protocol_ind().
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @param packet_type the detected packet type.
+ *
+ * @param direction the direction of the packet (Rx, Tx).
+ *
+ * @param src_addr the source address of the packet.
+ *
+ * @ingroup upperedge
+ */
+void unifi_ta_indicate_protocol(void                              *ospriv,
+                                CsrWifiRouterCtrlTrafficPacketType packet_type,
+                                CsrWifiRouterCtrlProtocolDirection direction,
+                                const CsrWifiMacAddress           *src_addr);
+
+/**
+ *
+ * Indicates statistics for the sample data over a period.
+ * Typically, this information is processed by the SME so
+ * unifi_ta_indicate_sampling() needs to schedule a call to
+ * unifi_sys_traffic_sample_ind().
+ *
+ * @param ospriv the OS layer context.
+ *
+ * @param stats the pointer to the structure that contains the statistics.
+ *
+ * @ingroup upperedge
+ */
+void unifi_ta_indicate_sampling(void *ospriv, CsrWifiRouterCtrlTrafficStats *stats);
+void unifi_ta_indicate_l4stats(void     *ospriv,
+                               CsrUint32 rxTcpThroughput,
+                               CsrUint32 txTcpThroughput,
+                               CsrUint32 rxUdpThroughput,
+                               CsrUint32 txUdpThroughput);
+#endif
+
+void unifi_rx_queue_flush(void *ospriv);
+
+/**
+ * Call-out from the SDIO glue layer.
+ *
+ * The glue layer needs to call unifi_sdio_interrupt_handler() every time
+ * an interrupts occurs.
+ *
+ * @param card the HIP core context.
+ *
+ * @ingroup bottomedge
+ */
+void unifi_sdio_interrupt_handler(card_t *card);
+
+
+/* HELPER FUNCTIONS */
+
+/*
+ * unifi_init() and unifi_download() implement a subset of unifi_init_card functionality
+ * that excludes HIP initialization.
+ */
+CsrResult unifi_init(card_t *card);
+CsrResult unifi_download(card_t *card, CsrInt32 led_mask);
+
+/*
+ * unifi_start_processors() ensures both on-chip processors are running
+ */
+CsrResult unifi_start_processors(card_t *card);
+
+CsrResult unifi_capture_panic(card_t *card);
+
+/*
+ * Configure HIP interrupt processing mode
+ */
+#define CSR_WIFI_INTMODE_DEFAULT        0
+#define CSR_WIFI_INTMODE_RUN_BH_ONCE    1       /* Run BH once per interrupt */
+
+void unifi_set_interrupt_mode(card_t *card, CsrUint32 mode);
+
+/*
+ * unifi_request_max_clock() requests that max SDIO clock speed is set at the
+ * next suitable opportunity.
+ */
+void unifi_request_max_sdio_clock(card_t *card);
+
+
+/* Functions to lookup bulk data command names. */
+const CsrCharString* lookup_bulkcmd_name(CsrUint16 id);
+
+/* Function to log HIP's global debug buffer */
+#ifdef CSR_WIFI_HIP_DEBUG_OFFLINE
+void unifi_debug_buf_dump(void);
+#endif
+
+/* Mini-coredump utility functions */
+CsrResult unifi_coredump_get_value(card_t *card, struct unifi_coredump_req *req);
+CsrResult unifi_coredump_capture(card_t *card, struct unifi_coredump_req *req);
+CsrResult unifi_coredump_request_at_next_reset(card_t *card, CsrInt8 enable);
+CsrResult unifi_coredump_init(card_t *card, CsrUint16 num_dump_buffers);
+void unifi_coredump_free(card_t *card);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CSR_WIFI_HIP_UNIFI_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_unifi_signal_names.c
@@ -0,0 +1,46 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include "csr_wifi_hip_unifi.h"
+
+struct sig_name
+{
+    CsrInt16             id;
+    const CsrCharString *name;
+};
+
+static const struct sig_name Unifi_bulkcmd_names[] = {
+    {  0, "SignalCmd" },
+    {  1, "CopyToHost" },
+    {  2, "CopyToHostAck" },
+    {  3, "CopyFromHost" },
+    {  4, "CopyFromHostAck" },
+    {  5, "ClearSlot" },
+    {  6, "CopyOverlay" },
+    {  7, "CopyOverlayAck" },
+    {  8, "CopyFromHostAndClearSlot" },
+    {  15, "Padding" }
+};
+
+const CsrCharString* lookup_bulkcmd_name(CsrUint16 id)
+{
+    if (id < 9)
+    {
+        return Unifi_bulkcmd_names[id].name;
+    }
+    if (id == 15)
+    {
+        return "Padding";
+    }
+
+    return "UNKNOWN";
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_unifi_udi.h
@@ -0,0 +1,76 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     csr_wifi_hip_unifi_udi.h
+ *
+ *  PURPOSE:
+ *      Declarations and definitions for the UniFi Debug Interface.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#ifndef __CSR_WIFI_HIP_UNIFI_UDI_H__
+#define __CSR_WIFI_HIP_UNIFI_UDI_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_signals.h"
+
+
+/*
+ * Support for tracing the wire protocol.
+ */
+enum udi_log_direction
+{
+    UDI_LOG_FROM_HOST   = 0x0000,
+    UDI_LOG_TO_HOST     = 0x0001
+};
+
+typedef void (*udi_func_t)(void *ospriv, CsrUint8 *sigdata,
+                           CsrUint32 signal_len,
+                           const bulk_data_param_t *bulkdata,
+                           enum udi_log_direction dir);
+
+CsrResult unifi_set_udi_hook(card_t *card, udi_func_t udi_fn);
+CsrResult unifi_remove_udi_hook(card_t *card, udi_func_t udi_fn);
+
+
+/*
+ * Function to print current status info to a string.
+ * This is used in the linux /proc interface and might be useful
+ * in other systems.
+ */
+CsrInt32 unifi_print_status(card_t *card, CsrCharString *str, CsrInt32 *remain);
+
+#define UNIFI_SNPRINTF_RET(buf_p, remain, written)                  \
+    do {                                                            \
+        if (written >= remain) {                                    \
+            if (remain >= 2) {                                      \
+                buf_p[remain - 2] = '\n';                           \
+                buf_p[remain - 1] = 0;                              \
+            }                                                       \
+            buf_p += remain;                                        \
+            remain = 0;                                             \
+        } else if (written > 0) {                                   \
+            buf_p += written;                                       \
+            remain -= written;                                      \
+        }                                                           \
+    } while (0)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CSR_WIFI_HIP_UNIFI_UDI_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_unifihw.h
@@ -0,0 +1,67 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ * File: csr_wifi_hip_unifihw.h
+ *
+ *      Definitions of various chip registers, addresses, values etc.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#ifndef __UNIFIHW_H__
+#define __UNIFIHW_H__ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Symbol Look Up Table fingerprint. IDs are in sigs.h */
+#define SLUT_FINGERPRINT        0xD397
+
+
+/* Values of LoaderOperation */
+#define UNIFI_LOADER_IDLE       0x00
+#define UNIFI_LOADER_COPY       0x01
+#define UNIFI_LOADER_ERROR_MASK 0xF0
+
+/* Values of BootLoaderOperation */
+#define UNIFI_BOOT_LOADER_IDLE       0x00
+#define UNIFI_BOOT_LOADER_RESTART    0x01
+#define UNIFI_BOOT_LOADER_PATCH      0x02
+#define UNIFI_BOOT_LOADER_LOAD_STA   0x10
+#define UNIFI_BOOT_LOADER_LOAD_PTEST 0x11
+
+
+/* Memory spaces encoded in top byte of Generic Pointer type */
+#define UNIFI_SH_DMEM   0x01    /* Shared Data Memory */
+#define UNIFI_EXT_FLASH 0x02    /* External FLASH */
+#define UNIFI_EXT_SRAM  0x03    /* External SRAM */
+#define UNIFI_REGISTERS 0x04    /* Registers */
+#define UNIFI_PHY_DMEM  0x10    /* PHY Data Memory */
+#define UNIFI_PHY_PMEM  0x11    /* PHY Program Memory */
+#define UNIFI_PHY_ROM   0x12    /* PHY ROM */
+#define UNIFI_MAC_DMEM  0x20    /* MAC Data Memory */
+#define UNIFI_MAC_PMEM  0x21    /* MAC Program Memory */
+#define UNIFI_MAC_ROM   0x22    /* MAC ROM */
+#define UNIFI_BT_DMEM   0x30    /* BT Data Memory */
+#define UNIFI_BT_PMEM   0x31    /* BT Program Memory */
+#define UNIFI_BT_ROM    0x32    /* BT ROM */
+
+#define UNIFI_MAKE_GP(R, O)  (((UNIFI_ ## R) << 24) | (O))
+#define UNIFI_GP_OFFSET(GP)  ((GP) & 0xFFFFFF)
+#define UNIFI_GP_SPACE(GP)   (((GP) >> 24) & 0xFF)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __UNIFIHW_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_unifiversion.h
@@ -0,0 +1,38 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     unifiversion.h
+ *
+ *  PURPOSE:
+ *      Version information for the portable UniFi driver.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+#ifndef __UNIFIVERSION_H__
+#define __UNIFIVERSION_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The minimum version of Host Interface Protocol required by the driver.
+ */
+#define UNIFI_HIP_MAJOR_VERSION 9
+#define UNIFI_HIP_MINOR_VERSION 1
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __UNIFIVERSION_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_xbv.c
@@ -0,0 +1,1075 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ * FILE: csr_wifi_hip_xbv.c
+ *
+ * PURPOSE:
+ *      Routines for downloading firmware to UniFi.
+ *
+ *      UniFi firmware files use a nested TLV (Tag-Length-Value) format.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+#ifdef CSR_WIFI_XBV_TEST
+/* Standalone test harness */
+#include "unifi_xbv.h"
+#include "csr_wifi_hip_unifihw.h"
+#else
+/* Normal driver build */
+#include "csr_wifi_hip_unifiversion.h"
+#include "csr_wifi_hip_card.h"
+#define DBG_TAG(t)
+#endif
+
+#include "csr_wifi_hip_xbv.h"
+
+#define STREAM_CHECKSUM 0x6d34        /* Sum of uint16s in each patch stream */
+
+/* XBV sizes used in patch conversion
+ */
+#define PTDL_MAX_SIZE 2048            /* Max bytes allowed per PTDL */
+#define PTDL_HDR_SIZE (4 + 2 + 6 + 2) /* sizeof(fw_id, sec_len, patch_cmd, csum) */
+
+/* Struct to represent a buffer for reading firmware file */
+
+typedef struct
+{
+    void      *dlpriv;
+    CsrInt32   ioffset;
+    fwreadfn_t iread;
+} ct_t;
+
+/* Struct to represent a TLV field */
+typedef struct
+{
+    CsrCharString t_name[4];
+    CsrUint32     t_len;
+} tag_t;
+
+
+#define TAG_EQ(i, v)    (((i)[0] == (v)[0]) &&  \
+                         ((i)[1] == (v)[1]) &&  \
+                         ((i)[2] == (v)[2]) &&  \
+                         ((i)[3] == (v)[3]))
+
+/* We create a small stack on the stack that contains an enum
+ * indicating the containing list segments, and the offset at which
+ * those lists end.  This enables a lot more error checking. */
+typedef enum
+{
+    xbv_xbv1,
+    /*xbv_info,*/
+    xbv_fw,
+    xbv_vers,
+    xbv_vand,
+    xbv_ptch,
+    xbv_other
+} xbv_container;
+
+#define XBV_STACK_SIZE 6
+#define XBV_MAX_OFFS   0x7fffffff
+
+typedef struct
+{
+    struct
+    {
+        xbv_container container;
+        CsrInt32      ioffset_end;
+    } s[XBV_STACK_SIZE];
+    CsrUint32 ptr;
+} xbv_stack_t;
+
+static CsrInt32 read_tag(card_t *card, ct_t *ct, tag_t *tag);
+static CsrInt32 read_bytes(card_t *card, ct_t *ct, void *buf, CsrUint32 len);
+static CsrInt32 read_uint(card_t *card, ct_t *ct, CsrUint32 *u, CsrUint32 len);
+static CsrInt32 xbv_check(xbv1_t *fwinfo, const xbv_stack_t *stack,
+                          xbv_mode new_mode, xbv_container old_cont);
+static CsrInt32 xbv_push(xbv1_t *fwinfo, xbv_stack_t *stack,
+                         xbv_mode new_mode, xbv_container old_cont,
+                         xbv_container new_cont, CsrUint32 ioff);
+
+static CsrUint32 write_uint16(void *buf, const CsrUint32 offset,
+                              const CsrUint16 val);
+static CsrUint32 write_uint32(void *buf, const CsrUint32 offset,
+                              const CsrUint32 val);
+static CsrUint32 write_bytes(void *buf, const CsrUint32 offset,
+                             const CsrUint8 *data, const CsrUint32 len);
+static CsrUint32 write_tag(void *buf, const CsrUint32 offset,
+                           const CsrCharString *tag_str);
+static CsrUint32 write_chunk(void *buf, const CsrUint32 offset,
+                             const CsrCharString *tag_str,
+                             const CsrUint32 payload_len);
+static CsrUint16 calc_checksum(void *buf, const CsrUint32 offset,
+                               const CsrUint32 bytes_len);
+static CsrUint32 calc_patch_size(const xbv1_t *fwinfo);
+
+static CsrUint32 write_xbv_header(void *buf, const CsrUint32 offset,
+                                  const CsrUint32 file_payload_length);
+static CsrUint32 write_ptch_header(void *buf, const CsrUint32 offset,
+                                   const CsrUint32 fw_id);
+static CsrUint32 write_patchcmd(void *buf, const CsrUint32 offset,
+                                const CsrUint32 dst_genaddr, const CsrUint16 len);
+static CsrUint32 write_reset_ptdl(void *buf, const CsrUint32 offset,
+                                  const xbv1_t *fwinfo, CsrUint32 fw_id);
+static CsrUint32 write_fwdl_to_ptdl(void *buf, const CsrUint32 offset,
+                                    fwreadfn_t readfn, const struct FWDL *fwdl,
+                                    const void *fw_buf, const CsrUint32 fw_id,
+                                    void *rdbuf);
+
+/*
+ * ---------------------------------------------------------------------------
+ *  parse_xbv1
+ *
+ *      Scan the firmware file to find the TLVs we are interested in.
+ *      Actions performed:
+ *        - check we support the file format version in VERF
+ *      Store these TLVs if we have a firmware image:
+ *        - SLTP Symbol Lookup Table Pointer
+ *        - FWDL firmware download segments
+ *        - FWOL firmware overlay segment
+ *        - VMEQ Register probe tests to verify matching h/w
+ *      Store these TLVs if we have a patch file:
+ *        - FWID the firmware build ID that this file patches
+ *        - PTDL The actual patches
+ *
+ *      The structure pointed to by fwinfo is cleared and
+ *      'fwinfo->mode' is set to 'unknown'.  The 'fwinfo->mode'
+ *      variable is set to 'firmware' or 'patch' once we know which
+ *      sort of XBV file we have.
+ *
+ *  Arguments:
+ *      readfn          Pointer to function to call to read from the file.
+ *      dlpriv          Opaque pointer arg to pass to readfn.
+ *      fwinfo          Pointer to fwinfo struct to fill in.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR error code on failure
+ * ---------------------------------------------------------------------------
+ */
+CsrResult xbv1_parse(card_t *card, fwreadfn_t readfn, void *dlpriv, xbv1_t *fwinfo)
+{
+    ct_t ct;
+    tag_t tag;
+    xbv_stack_t stack;
+
+    ct.dlpriv = dlpriv;
+    ct.ioffset = 0;
+    ct.iread = readfn;
+
+    CsrMemSet(fwinfo, 0, sizeof(xbv1_t));
+    fwinfo->mode = xbv_unknown;
+
+    /* File must start with XBV1 triplet */
+    if (read_tag(card, &ct, &tag) <= 0)
+    {
+        unifi_error(NULL, "File is not UniFi firmware\n");
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    DBG_TAG(tag.t_name);
+
+    if (!TAG_EQ(tag.t_name, "XBV1"))
+    {
+        unifi_error(NULL, "File is not UniFi firmware (%s)\n", tag.t_name);
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    stack.ptr = 0;
+    stack.s[stack.ptr].container = xbv_xbv1;
+    stack.s[stack.ptr].ioffset_end = XBV_MAX_OFFS;
+
+    /* Now scan the file */
+    while (1)
+    {
+        CsrInt32 n;
+
+        n = read_tag(card, &ct, &tag);
+        if (n < 0)
+        {
+            unifi_error(NULL, "No tag\n");
+            return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+        }
+        if (n == 0)
+        {
+            /* End of file */
+            break;
+        }
+
+        DBG_TAG(tag.t_name);
+
+        /* File format version */
+        if (TAG_EQ(tag.t_name, "VERF"))
+        {
+            CsrUint32 version;
+
+            if (xbv_check(fwinfo, &stack, xbv_unknown, xbv_xbv1) ||
+                (tag.t_len != 2) ||
+                read_uint(card, &ct, &version, 2))
+            {
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+            if (version != 0)
+            {
+                unifi_error(NULL, "Unsupported firmware file version: %d.%d\n",
+                            version >> 8, version & 0xFF);
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+        }
+        else if (TAG_EQ(tag.t_name, "LIST"))
+        {
+            CsrCharString name[4];
+            CsrUint32 list_end;
+
+            list_end = ct.ioffset + tag.t_len;
+
+            if (read_bytes(card, &ct, name, 4))
+            {
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+
+            DBG_TAG(name);
+            if (TAG_EQ(name, "FW  "))
+            {
+                if (xbv_push(fwinfo, &stack, xbv_firmware, xbv_xbv1, xbv_fw, list_end))
+                {
+                    return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+                }
+            }
+            else if (TAG_EQ(name, "VERS"))
+            {
+                if (xbv_push(fwinfo, &stack, xbv_firmware, xbv_fw, xbv_vers, list_end) ||
+                    (fwinfo->vers.num_vand != 0))
+                {
+                    return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+                }
+            }
+            else if (TAG_EQ(name, "VAND"))
+            {
+                struct VAND *vand;
+
+                if (xbv_push(fwinfo, &stack, xbv_firmware, xbv_vers, xbv_vand, list_end) ||
+                    (fwinfo->vers.num_vand >= MAX_VAND))
+                {
+                    return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+                }
+
+                /* Get a new VAND */
+                vand = fwinfo->vand + fwinfo->vers.num_vand++;
+
+                /* Fill it in */
+                vand->first = fwinfo->num_vmeq;
+                vand->count = 0;
+            }
+            else if (TAG_EQ(name, "PTCH"))
+            {
+                if (xbv_push(fwinfo, &stack, xbv_patch, xbv_xbv1, xbv_ptch, list_end))
+                {
+                    return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+                }
+            }
+            else
+            {
+                /* Skip over any other lists.  We dont bother to push
+                 * the new list type now as we would only pop it at
+                 * the end of the outer loop. */
+                ct.ioffset += tag.t_len - 4;
+            }
+        }
+        else if (TAG_EQ(tag.t_name, "SLTP"))
+        {
+            CsrUint32 addr;
+
+            if (xbv_check(fwinfo, &stack, xbv_firmware, xbv_fw) ||
+                (tag.t_len != 4) ||
+                (fwinfo->slut_addr != 0) ||
+                read_uint(card, &ct, &addr, 4))
+            {
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+
+            fwinfo->slut_addr = addr;
+        }
+        else if (TAG_EQ(tag.t_name, "FWDL"))
+        {
+            CsrUint32 addr;
+            struct FWDL *fwdl;
+
+            if (xbv_check(fwinfo, &stack, xbv_firmware, xbv_fw) ||
+                (fwinfo->num_fwdl >= MAX_FWDL) ||
+                (read_uint(card, &ct, &addr, 4)))
+            {
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+
+            fwdl = fwinfo->fwdl + fwinfo->num_fwdl++;
+
+            fwdl->dl_size = tag.t_len - 4;
+            fwdl->dl_addr = addr;
+            fwdl->dl_offset = ct.ioffset;
+
+            ct.ioffset += tag.t_len - 4;
+        }
+        else if (TAG_EQ(tag.t_name, "FWOV"))
+        {
+            if (xbv_check(fwinfo, &stack, xbv_firmware, xbv_fw) ||
+                (fwinfo->fwov.dl_size != 0) ||
+                (fwinfo->fwov.dl_offset != 0))
+            {
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+
+            fwinfo->fwov.dl_size = tag.t_len;
+            fwinfo->fwov.dl_offset = ct.ioffset;
+
+            ct.ioffset += tag.t_len;
+        }
+        else if (TAG_EQ(tag.t_name, "VMEQ"))
+        {
+            CsrUint32 temp[3];
+            struct VAND *vand;
+            struct VMEQ *vmeq;
+
+            if (xbv_check(fwinfo, &stack, xbv_firmware, xbv_vand) ||
+                (fwinfo->num_vmeq >= MAX_VMEQ) ||
+                (fwinfo->vers.num_vand == 0) ||
+                (tag.t_len != 8) ||
+                read_uint(card, &ct, &temp[0], 4) ||
+                read_uint(card, &ct, &temp[1], 2) ||
+                read_uint(card, &ct, &temp[2], 2))
+            {
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+
+            /* Get the last VAND */
+            vand = fwinfo->vand + (fwinfo->vers.num_vand - 1);
+
+            /* Get a new VMEQ */
+            vmeq = fwinfo->vmeq + fwinfo->num_vmeq++;
+
+            /* Note that this VAND contains another VMEQ */
+            vand->count++;
+
+            /* Fill in the VMEQ */
+            vmeq->addr = temp[0];
+            vmeq->mask = (CsrUint16)temp[1];
+            vmeq->value = (CsrUint16)temp[2];
+        }
+        else if (TAG_EQ(tag.t_name, "FWID"))
+        {
+            CsrUint32 build_id;
+
+            if (xbv_check(fwinfo, &stack, xbv_patch, xbv_ptch) ||
+                (tag.t_len != 4) ||
+                (fwinfo->build_id != 0) ||
+                read_uint(card, &ct, &build_id, 4))
+            {
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+
+            fwinfo->build_id = build_id;
+        }
+        else if (TAG_EQ(tag.t_name, "PTDL"))
+        {
+            struct PTDL *ptdl;
+
+            if (xbv_check(fwinfo, &stack, xbv_patch, xbv_ptch) ||
+                (fwinfo->num_ptdl >= MAX_PTDL))
+            {
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+
+            /* Allocate a new PTDL */
+            ptdl = fwinfo->ptdl + fwinfo->num_ptdl++;
+
+            ptdl->dl_size = tag.t_len;
+            ptdl->dl_offset = ct.ioffset;
+
+            ct.ioffset += tag.t_len;
+        }
+        else
+        {
+            /*
+             * If we get here it is a tag we are not interested in,
+             * just skip over it.
+             */
+            ct.ioffset += tag.t_len;
+        }
+
+        /* Check to see if we are at the end of the currently stacked
+         * segment.  We could finish more than one list at a time. */
+        while (ct.ioffset >= stack.s[stack.ptr].ioffset_end)
+        {
+            if (ct.ioffset > stack.s[stack.ptr].ioffset_end)
+            {
+                unifi_error(NULL,
+                            "XBV file has overrun stack'd segment %d (%d > %d)\n",
+                            stack.ptr, ct.ioffset, stack.s[stack.ptr].ioffset_end);
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+            if (stack.ptr <= 0)
+            {
+                unifi_error(NULL, "XBV file has underrun stack pointer\n");
+                return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+            }
+            stack.ptr--;
+        }
+    }
+
+    if (stack.ptr != 0)
+    {
+        unifi_error(NULL, "Last list of XBV is not complete.\n");
+        return CSR_WIFI_HIP_RESULT_INVALID_VALUE;
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* xbv1_parse() */
+
+
+/* Check the the XBV file is of a consistant sort (either firmware or
+ * patch) and that we are in the correct containing list type. */
+static CsrInt32 xbv_check(xbv1_t *fwinfo, const xbv_stack_t *stack,
+                          xbv_mode new_mode, xbv_container old_cont)
+{
+    /* If the new file mode is unknown the current packet could be in
+     * either (any) type of XBV file, and we cant make a decission at
+     * this time. */
+    if (new_mode != xbv_unknown)
+    {
+        if (fwinfo->mode == xbv_unknown)
+        {
+            fwinfo->mode = new_mode;
+        }
+        else if (fwinfo->mode != new_mode)
+        {
+            return -1;
+        }
+    }
+    /* If the current stack top doesn't match what we expect then the
+     * file is corrupt. */
+    if (stack->s[stack->ptr].container != old_cont)
+    {
+        return -1;
+    }
+    return 0;
+}
+
+
+/* Make checks as above and then enter a new list */
+static CsrInt32 xbv_push(xbv1_t *fwinfo, xbv_stack_t *stack,
+                         xbv_mode new_mode, xbv_container old_cont,
+                         xbv_container new_cont, CsrUint32 new_ioff)
+{
+    if (xbv_check(fwinfo, stack, new_mode, old_cont))
+    {
+        return -1;
+    }
+
+    /* Check that our stack won't overflow. */
+    if (stack->ptr >= (XBV_STACK_SIZE - 1))
+    {
+        return -1;
+    }
+
+    /* Add the new list element to the top of the stack. */
+    stack->ptr++;
+    stack->s[stack->ptr].container = new_cont;
+    stack->s[stack->ptr].ioffset_end = new_ioff;
+
+    return 0;
+}
+
+
+static CsrUint32 xbv2uint(CsrUint8 *ptr, CsrInt32 len)
+{
+    CsrUint32 u = 0;
+    CsrInt16 i;
+
+    for (i = 0; i < len; i++)
+    {
+        CsrUint32 b;
+        b = ptr[i];
+        u += b << (i * 8);
+    }
+    return u;
+}
+
+
+static CsrInt32 read_tag(card_t *card, ct_t *ct, tag_t *tag)
+{
+    CsrUint8 buf[8];
+    CsrInt32 n;
+
+    n = (*ct->iread)(card->ospriv, ct->dlpriv, ct->ioffset, buf, 8);
+    if (n <= 0)
+    {
+        return n;
+    }
+
+    /* read the tag and length */
+    if (n != 8)
+    {
+        return -1;
+    }
+
+    /* get section tag */
+    CsrMemCpy(tag->t_name, buf, 4);
+
+    /* get section length */
+    tag->t_len = xbv2uint(buf + 4, 4);
+
+    ct->ioffset += 8;
+
+    return 8;
+} /* read_tag() */
+
+
+static CsrInt32 read_bytes(card_t *card, ct_t *ct, void *buf, CsrUint32 len)
+{
+    /* read the tag value */
+    if ((*ct->iread)(card->ospriv, ct->dlpriv, ct->ioffset, buf, len) != (CsrInt32)len)
+    {
+        return -1;
+    }
+
+    ct->ioffset += len;
+
+    return 0;
+} /* read_bytes() */
+
+
+static CsrInt32 read_uint(card_t *card, ct_t *ct, CsrUint32 *u, CsrUint32 len)
+{
+    CsrUint8 buf[4];
+
+    /* Integer cannot be more than 4 bytes */
+    if (len > 4)
+    {
+        return -1;
+    }
+
+    if (read_bytes(card, ct, buf, len))
+    {
+        return -1;
+    }
+
+    *u = xbv2uint(buf, len);
+
+    return 0;
+} /* read_uint() */
+
+
+static CsrUint32 write_uint16(void *buf, const CsrUint32 offset, const CsrUint16 val)
+{
+    CsrUint8 *dst = (CsrUint8 *)buf + offset;
+    *dst++ = (CsrUint8)(val & 0xff); /* LSB first */
+    *dst = (CsrUint8)(val >> 8);
+    return sizeof(CsrUint16);
+}
+
+
+static CsrUint32 write_uint32(void *buf, const CsrUint32 offset, const CsrUint32 val)
+{
+    write_uint16(buf, offset + 0, (CsrUint16)(val & 0xffff));
+    write_uint16(buf, offset + 2, (CsrUint16)(val >> 16));
+    return sizeof(CsrUint32);
+}
+
+
+static CsrUint32 write_bytes(void *buf, const CsrUint32 offset, const CsrUint8 *data, const CsrUint32 len)
+{
+    CsrUint32 i;
+    CsrUint8 *dst = (CsrUint8 *)buf + offset;
+
+    for (i = 0; i < len; i++)
+    {
+        *dst++ = *((CsrUint8 *)data + i);
+    }
+    return len;
+}
+
+
+static CsrUint32 write_tag(void *buf, const CsrUint32 offset, const CsrCharString *tag_str)
+{
+    CsrUint8 *dst = (CsrUint8 *)buf + offset;
+    CsrMemCpy(dst, tag_str, 4);
+    return 4;
+}
+
+
+static CsrUint32 write_chunk(void *buf, const CsrUint32 offset, const CsrCharString *tag_str, const CsrUint32 payload_len)
+{
+    CsrUint32 written = 0;
+    written += write_tag(buf, offset, tag_str);
+    written += write_uint32(buf, written + offset, (CsrUint32)payload_len);
+
+    return written;
+}
+
+
+static CsrUint16 calc_checksum(void *buf, const CsrUint32 offset, const CsrUint32 bytes_len)
+{
+    CsrUint32 i;
+    CsrUint8 *src = (CsrUint8 *)buf + offset;
+    CsrUint16 sum = 0;
+    CsrUint16 val;
+
+    for (i = 0; i < bytes_len / 2; i++)
+    {
+        /* Contents copied to file is LE, host might not be */
+        val = (CsrUint16) * src++;         /* LSB */
+        val += (CsrUint16)(*src++) << 8;   /* MSB */
+        sum += val;
+    }
+
+    /* Total of uint16s in the stream plus the stored check value
+     * should equal STREAM_CHECKSUM when decoded.
+     */
+    return (STREAM_CHECKSUM - sum);
+}
+
+
+#define PTDL_RESET_DATA_SIZE  20  /* Size of reset vectors PTDL */
+
+static CsrUint32 calc_patch_size(const xbv1_t *fwinfo)
+{
+    CsrInt16 i;
+    CsrUint32 size = 0;
+
+    /*
+     * Work out how big an equivalent patch format file must be for this image.
+     * This only needs to be approximate, so long as it's large enough.
+     */
+    if (fwinfo->mode != xbv_firmware)
+    {
+        return 0;
+    }
+
+    /* Payload (which will get put into a series of PTDLs) */
+    for (i = 0; i < fwinfo->num_fwdl; i++)
+    {
+        size += fwinfo->fwdl[i].dl_size;
+    }
+
+    /* Another PTDL at the end containing reset vectors */
+    size += PTDL_RESET_DATA_SIZE;
+
+    /* PTDL headers. Add one for remainder, one for reset vectors */
+    size += ((fwinfo->num_fwdl / PTDL_MAX_SIZE) + 2) * PTDL_HDR_SIZE;
+
+    /* Another 1K sufficient to cover miscellaneous headers */
+    size += 1024;
+
+    return size;
+}
+
+
+static CsrUint32 write_xbv_header(void *buf, const CsrUint32 offset, const CsrUint32 file_payload_length)
+{
+    CsrUint32 written = 0;
+
+    /* The length value given to the XBV chunk is the length of all subsequent
+     * contents of the file, excluding the 8 byte size of the XBV1 header itself
+     * (The added 6 bytes thus accounts for the size of the VERF)
+     */
+    written += write_chunk(buf, offset + written, (CsrCharString *)"XBV1", file_payload_length + 6);
+
+    written += write_chunk(buf, offset + written, (CsrCharString *)"VERF", 2);
+    written += write_uint16(buf,  offset + written, 0);      /* File version */
+
+    return written;
+}
+
+
+static CsrUint32 write_ptch_header(void *buf, const CsrUint32 offset, const CsrUint32 fw_id)
+{
+    CsrUint32 written = 0;
+
+    /* LIST is written with a zero length, to be updated later */
+    written += write_chunk(buf, offset + written, (CsrCharString *)"LIST", 0);
+    written += write_tag(buf, offset + written, (CsrCharString *)"PTCH");        /* List type */
+
+    written += write_chunk(buf, offset + written, (CsrCharString *)"FWID", 4);
+    written += write_uint32(buf, offset + written, fw_id);
+
+
+    return written;
+}
+
+
+#define UF_REGION_PHY  1
+#define UF_REGION_MAC  2
+#define UF_MEMPUT_MAC  0x0000
+#define UF_MEMPUT_PHY  0x1000
+
+static CsrUint32 write_patchcmd(void *buf, const CsrUint32 offset, const CsrUint32 dst_genaddr, const CsrUint16 len)
+{
+    CsrUint32 written = 0;
+    CsrUint32 region = (dst_genaddr >> 28);
+    CsrUint16 cmd_and_len = UF_MEMPUT_MAC;
+
+    if (region == UF_REGION_PHY)
+    {
+        cmd_and_len = UF_MEMPUT_PHY;
+    }
+    else if (region != UF_REGION_MAC)
+    {
+        return 0; /* invalid */
+    }
+
+    /* Write the command and data length */
+    cmd_and_len |= len;
+    written += write_uint16(buf, offset + written, cmd_and_len);
+
+    /* Write the destination generic address */
+    written += write_uint16(buf, offset + written, (CsrUint16)(dst_genaddr >> 16));
+    written += write_uint16(buf, offset + written, (CsrUint16)(dst_genaddr & 0xffff));
+
+    /* The data payload should be appended to the command */
+    return written;
+}
+
+
+static CsrUint32 write_fwdl_to_ptdl(void *buf, const CsrUint32 offset, fwreadfn_t readfn,
+                                    const struct FWDL *fwdl, const void *dlpriv,
+                                    const CsrUint32 fw_id, void *fw_buf)
+{
+    CsrUint32 written = 0;
+    CsrInt16 chunks = 0;
+    CsrUint32 left = fwdl->dl_size;      /* Bytes left in this fwdl */
+    CsrUint32 dl_addr = fwdl->dl_addr;   /* Target address of fwdl image on XAP */
+    CsrUint32 dl_offs = fwdl->dl_offset; /* Offset of fwdl image data in source */
+    CsrUint16 csum;
+    CsrUint32 csum_start_offs;           /* first offset to include in checksum */
+    CsrUint32 sec_data_len;              /* section data byte count */
+    CsrUint32 sec_len;                   /* section data + header byte count */
+
+    /* FWDL maps to one or more PTDLs, as max size for a PTDL is 1K words */
+    while (left)
+    {
+        /* Calculate amount to be transferred */
+        sec_data_len = CSRMIN(left, PTDL_MAX_SIZE - PTDL_HDR_SIZE);
+        sec_len = sec_data_len + PTDL_HDR_SIZE;
+
+        /* Write PTDL header + entire PTDL size */
+        written += write_chunk(buf, offset + written, (CsrCharString *)"PTDL", sec_len);
+        /* bug digest implies 4 bytes of padding here, but that seems wrong */
+
+        /* Checksum starts here */
+        csum_start_offs = offset + written;
+
+        /* Patch-chunk header: fw_id. Note that this is in XAP word order */
+        written += write_uint16(buf, offset + written, (CsrUint16)(fw_id >> 16));
+        written += write_uint16(buf, offset + written, (CsrUint16)(fw_id & 0xffff));
+
+        /* Patch-chunk header: section length in uint16s */
+        written += write_uint16(buf, offset + written, (CsrUint16)(sec_len / 2));
+
+
+        /* Write the appropriate patch command for the data's destination ptr */
+        written += write_patchcmd(buf, offset + written, dl_addr, (CsrUint16)(sec_data_len / 2));
+
+        /* Write the data itself (limited to the max chunk length) */
+        if (readfn(NULL, (void *)dlpriv, dl_offs, fw_buf, sec_data_len) < 0)
+        {
+            return 0;
+        }
+
+        written += write_bytes(buf,
+                               offset + written,
+                               fw_buf,
+                               sec_data_len);
+
+        /* CsrUint16 checksum calculated over data written */
+        csum = calc_checksum(buf, csum_start_offs, written - (csum_start_offs - offset));
+        written += write_uint16(buf, offset + written, csum);
+
+        left -= sec_data_len;
+        dl_addr += sec_data_len;
+        dl_offs += sec_data_len;
+        chunks++;
+    }
+
+    return written;
+}
+
+
+#define SEC_CMD_LEN         ((4 + 2) * 2) /* sizeof(cmd, vector) per XAP */
+#define PTDL_VEC_HDR_SIZE   (4 + 2 + 2)   /* sizeof(fw_id, sec_len, csum) */
+#define UF_MAC_START_VEC    0x00c00000    /* Start address of image on MAC */
+#define UF_PHY_START_VEC    0x00c00000    /* Start address of image on PHY */
+#define UF_MAC_START_CMD    0x6000        /* MAC "Set start address" command */
+#define UF_PHY_START_CMD    0x7000        /* PHY "Set start address" command */
+
+static CsrUint32 write_reset_ptdl(void *buf, const CsrUint32 offset, const xbv1_t *fwinfo, CsrUint32 fw_id)
+{
+    CsrUint32 written = 0;
+    CsrUint16 csum;
+    CsrUint32 csum_start_offs;                 /* first offset to include in checksum */
+    CsrUint32 sec_len;                         /* section data + header byte count */
+
+    sec_len = SEC_CMD_LEN + PTDL_VEC_HDR_SIZE; /* Total section byte length */
+
+    /* Write PTDL header + entire PTDL size */
+    written += write_chunk(buf, offset + written, (CsrCharString *)"PTDL", sec_len);
+
+    /* Checksum starts here */
+    csum_start_offs = offset + written;
+
+    /* Patch-chunk header: fw_id. Note that this is in XAP word order */
+    written += write_uint16(buf, offset + written, (CsrUint16)(fw_id >> 16));
+    written += write_uint16(buf, offset + written, (CsrUint16)(fw_id & 0xffff));
+
+    /* Patch-chunk header: section length in uint16s */
+    written += write_uint16(buf, offset + written, (CsrUint16)(sec_len / 2));
+
+    /*
+     * Restart addresses to be executed on subsequent loader restart command.
+     */
+
+    /* Setup the MAC start address, note word ordering */
+    written += write_uint16(buf, offset + written, UF_MAC_START_CMD);
+    written += write_uint16(buf, offset + written, (UF_MAC_START_VEC >> 16));
+    written += write_uint16(buf, offset + written, (UF_MAC_START_VEC & 0xffff));
+
+    /* Setup the PHY start address, note word ordering */
+    written += write_uint16(buf, offset + written, UF_PHY_START_CMD);
+    written += write_uint16(buf, offset + written, (UF_PHY_START_VEC >> 16));
+    written += write_uint16(buf, offset + written, (UF_PHY_START_VEC & 0xffff));
+
+    /* CsrUint16 checksum calculated over data written */
+    csum = calc_checksum(buf, csum_start_offs, written - (csum_start_offs - offset));
+    written += write_uint16(buf, offset + written, csum);
+
+    return written;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  read_slut
+ *
+ *      desc
+ *
+ *  Arguments:
+ *      readfn          Pointer to function to call to read from the file.
+ *      dlpriv          Opaque pointer arg to pass to readfn.
+ *      addr            Offset into firmware image of SLUT.
+ *      fwinfo          Pointer to fwinfo struct to fill in.
+ *
+ *  Returns:
+ *      Number of SLUT entries in the f/w, or -1 if the image was corrupt.
+ * ---------------------------------------------------------------------------
+ */
+CsrInt32 xbv1_read_slut(card_t *card, fwreadfn_t readfn, void *dlpriv, xbv1_t *fwinfo,
+                        symbol_t *slut, CsrUint32 slut_len)
+{
+    CsrInt16 i;
+    CsrInt32 offset;
+    CsrUint32 magic;
+    CsrUint32 count = 0;
+    ct_t ct;
+
+    if (fwinfo->mode != xbv_firmware)
+    {
+        return -1;
+    }
+
+    /* Find the d/l segment containing the SLUT */
+    /* This relies on the SLUT being entirely contained in one segment */
+    offset = -1;
+    for (i = 0; i < fwinfo->num_fwdl; i++)
+    {
+        if ((fwinfo->slut_addr >= fwinfo->fwdl[i].dl_addr) &&
+            (fwinfo->slut_addr < (fwinfo->fwdl[i].dl_addr + fwinfo->fwdl[i].dl_size)))
+        {
+            offset = fwinfo->fwdl[i].dl_offset +
+                     (fwinfo->slut_addr - fwinfo->fwdl[i].dl_addr);
+        }
+    }
+    if (offset < 0)
+    {
+        return -1;
+    }
+
+    ct.dlpriv = dlpriv;
+    ct.ioffset = offset;
+    ct.iread = readfn;
+
+    if (read_uint(card, &ct, &magic, 2))
+    {
+        return -1;
+    }
+    if (magic != SLUT_FINGERPRINT)
+    {
+        return -1;
+    }
+
+    while (count < slut_len)
+    {
+        CsrUint32 id, obj;
+
+        /* Read Symbol Id */
+        if (read_uint(card, &ct, &id, 2))
+        {
+            return -1;
+        }
+
+        /* Check for end of table marker */
+        if (id == CSR_SLT_END)
+        {
+            break;
+        }
+
+        /* Read Symbol Value */
+        if (read_uint(card, &ct, &obj, 4))
+        {
+            return -1;
+        }
+
+        slut[count].id  = (CsrUint16)id;
+        slut[count].obj = obj;
+        count++;
+    }
+
+    return count;
+} /* read_slut() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  xbv_to_patch
+ *
+ *      Convert (the relevant parts of) a firmware xbv file into a patch xbv
+ *
+ *  Arguments:
+ *      card
+ *      fw_buf - pointer to xbv firmware image
+ *      fwinfo - structure describing the firmware image
+ *      size   - pointer to location into which size of f/w is written.
+ *
+ *  Returns:
+ *      Pointer to firmware image, or NULL on error. Caller must free this
+ *      buffer via CsrMemFree() once it's finished with.
+ *
+ *  Notes:
+ *      The input fw_buf should have been checked via xbv1_parse prior to
+ *      calling this function, so the input image is assumed valid.
+ * ---------------------------------------------------------------------------
+ */
+#define PTCH_LIST_SIZE 16         /* sizeof PTCH+FWID chunk in LIST header */
+
+void* xbv_to_patch(card_t *card, fwreadfn_t readfn,
+                   const void *fw_buf, const xbv1_t *fwinfo, CsrUint32 *size)
+{
+    void *patch_buf = NULL;
+    CsrUint32 patch_buf_size;
+    CsrUint32 payload_offs = 0;           /* Start of XBV payload */
+    CsrInt16 i;
+    CsrUint32 patch_offs = 0;
+    CsrUint32 list_len_offs = 0;          /* Offset of PTDL LIST length parameter */
+    CsrUint32 ptdl_start_offs = 0;        /* Offset of first PTDL chunk */
+    CsrUint32 fw_id;
+    void *rdbuf;
+
+    if (!fw_buf || !fwinfo || !card)
+    {
+        return NULL;
+    }
+
+    if (fwinfo->mode != xbv_firmware)
+    {
+        unifi_error(NULL, "Not a firmware file\n");
+        return NULL;
+    }
+
+    /* Pre-allocate read buffer for chunk conversion */
+    rdbuf = CsrMemAlloc(PTDL_MAX_SIZE);
+    if (!rdbuf)
+    {
+        unifi_error(card, "Couldn't alloc conversion buffer\n");
+        return NULL;
+    }
+
+    /* Loader requires patch file's build ID to match the running firmware's */
+    fw_id = card->build_id;
+
+    /* Firmware XBV1 contains VERF, optional INFO, SLUT(s), FWDL(s)          */
+    /* Other chunks should get skipped.                                      */
+    /* VERF should be sanity-checked against chip version                    */
+
+    /* Patch    XBV1 contains VERF, optional INFO, PTCH                      */
+    /*          PTCH contains FWID, optional INFO, PTDL(s), PTDL(start_vec)  */
+    /* Each FWDL is split into PTDLs (each is 1024 XAP words max)            */
+    /* Each PTDL contains running ROM f/w version, and checksum              */
+    /* MAC/PHY reset addresses (known) are added into a final PTDL           */
+
+    /* The input image has already been parsed, and loaded into fwinfo, so we
+     * can use that to build the output image
+     */
+    patch_buf_size = calc_patch_size(fwinfo);
+
+    patch_buf = (void *)CsrMemAlloc(patch_buf_size);
+    if (!patch_buf)
+    {
+        CsrMemFree(rdbuf);
+        unifi_error(NULL, "Can't malloc buffer for patch conversion\n");
+        return NULL;
+    }
+
+    CsrMemSet(patch_buf, 0xdd, patch_buf_size);
+
+    /* Write XBV + VERF headers */
+    patch_offs += write_xbv_header(patch_buf, patch_offs, 0);
+    payload_offs = patch_offs;
+
+    /* Write patch (LIST) header */
+    list_len_offs = patch_offs + 4;    /* Save LIST.length offset for later update */
+    patch_offs += write_ptch_header(patch_buf, patch_offs, fw_id);
+
+    /* Save start offset of the PTDL chunks */
+    ptdl_start_offs = patch_offs;
+
+    /* Write LIST of firmware PTDL blocks */
+    for (i = 0; i < fwinfo->num_fwdl; i++)
+    {
+        patch_offs += write_fwdl_to_ptdl(patch_buf,
+                                         patch_offs,
+                                         readfn,
+                                         &fwinfo->fwdl[i],
+                                         fw_buf,
+                                         fw_id,
+                                         rdbuf);
+    }
+
+    /* Write restart-vector PTDL last */
+    patch_offs += write_reset_ptdl(patch_buf, patch_offs, fwinfo, fw_id);
+
+    /* Now the length is known, update the LIST.length */
+    write_uint32(patch_buf, list_len_offs,
+                 (patch_offs - ptdl_start_offs) + PTCH_LIST_SIZE);
+
+    /* Re write XBV headers just to fill in the correct file size */
+    write_xbv_header(patch_buf, 0, (patch_offs - payload_offs));
+
+    unifi_trace(card->ospriv, UDBG1, "XBV:PTCH size %u, fw_id %u\n",
+                patch_offs, fw_id);
+    if (size)
+    {
+        *size = patch_offs;
+    }
+    CsrMemFree(rdbuf);
+
+    return patch_buf;
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hip_xbv.h
@@ -0,0 +1,127 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/*
+ * ---------------------------------------------------------------------------
+ * FILE: csr_wifi_hip_xbv.h
+ *
+ * PURPOSE:
+ *      Definitions and declarations for code to read XBV files - the UniFi
+ *      firmware download file format.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#ifndef __XBV_H__
+#define __XBV_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_XBV_TEST
+/* Driver includes */
+#include "csr_wifi_hip_unifi.h"
+#endif
+
+
+struct VMEQ
+{
+    CsrUint32 addr;
+    CsrUint16 mask;
+    CsrUint16 value;
+};
+
+struct VAND
+{
+    CsrUint32 first;
+    CsrUint32 count;
+};
+
+struct VERS
+{
+    CsrUint32 num_vand;
+};
+
+struct FWDL
+{
+    CsrUint32 dl_addr;
+    CsrUint32 dl_size;
+    CsrUint32 dl_offset;
+};
+
+struct FWOV
+{
+    CsrUint32 dl_size;
+    CsrUint32 dl_offset;
+};
+
+struct PTDL
+{
+    CsrUint32 dl_size;
+    CsrUint32 dl_offset;
+};
+
+#define MAX_VMEQ 64
+#define MAX_VAND 64
+#define MAX_FWDL 256
+#define MAX_PTDL 256
+
+/* An XBV1 file can either contain firmware or patches (at the
+ * moment).  The 'mode' member of the xbv1_t structure tells us which
+ * one is the case. */
+typedef enum
+{
+    xbv_unknown,
+    xbv_firmware,
+    xbv_patch
+} xbv_mode;
+
+typedef struct
+{
+    xbv_mode mode;
+
+    /* Parts of a Firmware XBV1 */
+
+    struct VMEQ vmeq[MAX_VMEQ];
+    CsrUint32   num_vmeq;
+    struct VAND vand[MAX_VAND];
+    struct VERS vers;
+
+    CsrUint32 slut_addr;
+
+    /* F/W download image, possibly more than one part */
+    struct FWDL fwdl[MAX_FWDL];
+    CsrInt16    num_fwdl;
+
+    /* F/W overlay image, add r not used */
+    struct FWOV fwov;
+
+    /* Parts of a Patch XBV1 */
+
+    CsrUint32 build_id;
+
+    struct PTDL ptdl[MAX_PTDL];
+    CsrInt16    num_ptdl;
+}  xbv1_t;
+
+
+typedef CsrInt32 (*fwreadfn_t)(void *ospriv, void *dlpriv, CsrUint32 offset, void *buf, CsrUint32 len);
+
+CsrResult xbv1_parse(card_t *card, fwreadfn_t readfn, void *dlpriv, xbv1_t *fwinfo);
+CsrInt32 xbv1_read_slut(card_t *card, fwreadfn_t readfn, void *dlpriv, xbv1_t *fwinfo,
+                        symbol_t *slut, CsrUint32 slut_len);
+void* xbv_to_patch(card_t *card, fwreadfn_t readfn, const void *fw_buf, const xbv1_t *fwinfo,
+                   CsrUint32 *size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __XBV_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_hostio_prim.h
@@ -0,0 +1,27 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+
+#ifndef CSR_WIFI_HOSTIO_H
+#define CSR_WIFI_HOSTIO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define CSR_WIFI_HOSTIO_PRIM 0x0453
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_HOSTIO_H */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_lib.h
@@ -0,0 +1,113 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+#ifndef CSR_WIFI_LIB_H__
+#define CSR_WIFI_LIB_H__
+
+#include "csr_types.h"
+#include "csr_wifi_fsm_event.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiFsmEventInit
+ *
+ *  DESCRIPTION
+ *      Macro to initialise the members of a CsrWifiFsmEvent.
+ *----------------------------------------------------------------------------*/
+#define CsrWifiFsmEventInit(evt, p_primtype, p_msgtype, p_dst, p_src) \
+    (evt)->primtype = p_primtype; \
+    (evt)->type = p_msgtype; \
+    (evt)->destination = p_dst; \
+    (evt)->source = p_src
+
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiEvent_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrWifiEvent
+ *
+ *----------------------------------------------------------------------------*/
+CsrWifiFsmEvent* CsrWifiEvent_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrSchedQid dst, CsrSchedQid src);
+
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint8        value;
+} CsrWifiEventCsrUint8;
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiEventCsrUint8_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrWifiEventCsrUint8
+ *
+ *----------------------------------------------------------------------------*/
+CsrWifiEventCsrUint8* CsrWifiEventCsrUint8_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrSchedQid dst, CsrSchedQid src, CsrUint8 value);
+
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       value;
+} CsrWifiEventCsrUint16;
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiEventCsrUint16_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrWifiEventCsrUint16
+ *
+ *----------------------------------------------------------------------------*/
+CsrWifiEventCsrUint16* CsrWifiEventCsrUint16_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrSchedQid dst, CsrSchedQid src, CsrUint16 value);
+
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint32       value;
+} CsrWifiEventCsrUint32;
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiEventCsrUint32_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrWifiEventCsrUint32
+ *
+ *----------------------------------------------------------------------------*/
+CsrWifiEventCsrUint32* CsrWifiEventCsrUint32_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrSchedQid dst, CsrSchedQid src, CsrUint32 value);
+
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       value16;
+    CsrUint8        value8;
+} CsrWifiEventCsrUint16CsrUint8;
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiEventCsrUint16CsrUint8_struct
+ *
+ *  DESCRIPTION
+ *      Generic message creator.
+ *      Allocates and fills in a message with the signature CsrWifiEventCsrUint16CsrUint8
+ *
+ *----------------------------------------------------------------------------*/
+CsrWifiEventCsrUint16CsrUint8* CsrWifiEventCsrUint16CsrUint8_struct(CsrUint16 primtype, CsrUint16 msgtype, CsrSchedQid dst, CsrSchedQid src, CsrUint16 value16, CsrUint8 value8);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_LIB_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_msgconv.h
@@ -0,0 +1,60 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifndef CSR_WIFI_MSGCONV_H__
+#define CSR_WIFI_MSGCONV_H__
+
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+#include "csr_sched.h"
+#include "csr_unicode.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+void CsrUint16SerBigEndian(CsrUint8 *ptr, CsrSize *len, CsrUint16 v);
+void CsrUint24SerBigEndian(CsrUint8 *ptr, CsrSize *len, CsrUint32 v);
+void CsrUint32SerBigEndian(CsrUint8 *ptr, CsrSize *len, CsrUint32 v);
+
+void CsrUint16DesBigEndian(CsrUint16 *v, CsrUint8 *buffer, CsrSize *offset);
+void CsrUint24DesBigEndian(CsrUint32 *v, CsrUint8 *buffer, CsrSize *offset);
+void CsrUint32DesBigEndian(CsrUint32 *v, CsrUint8 *buffer, CsrSize *offset);
+
+void CsrUint24Ser(CsrUint8 *ptr, CsrSize *len, CsrUint32 v);
+void CsrUint24Des(CsrUint32 *v, CsrUint8 *buffer, CsrSize *offset);
+
+
+CsrSize CsrWifiEventSizeof(void *msg);
+CsrUint8* CsrWifiEventSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+void* CsrWifiEventDes(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrWifiEventCsrUint8Sizeof(void *msg);
+CsrUint8* CsrWifiEventCsrUint8Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void* CsrWifiEventCsrUint8Des(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrWifiEventCsrUint16Sizeof(void *msg);
+CsrUint8* CsrWifiEventCsrUint16Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void* CsrWifiEventCsrUint16Des(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrWifiEventCsrUint32Sizeof(void *msg);
+CsrUint8* CsrWifiEventCsrUint32Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void* CsrWifiEventCsrUint32Des(CsrUint8 *buffer, CsrSize length);
+
+CsrSize CsrWifiEventCsrUint16CsrUint8Sizeof(void *msg);
+CsrUint8* CsrWifiEventCsrUint16CsrUint8Ser(CsrUint8 *ptr, CsrSize *len, void *msg);
+void* CsrWifiEventCsrUint16CsrUint8Des(CsrUint8 *buffer, CsrSize length);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_MSGCONV_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_ap_converter_init.h
@@ -0,0 +1,49 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_NME_AP_CONVERTER_INIT_H__
+#define CSR_WIFI_NME_AP_CONVERTER_INIT_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_NME_ENABLE
+#error CSR_WIFI_NME_ENABLE MUST be defined inorder to use csr_wifi_nme_ap_converter_init.h
+#endif
+#ifndef CSR_WIFI_AP_ENABLE
+#error CSR_WIFI_AP_ENABLE MUST be defined inorder to use csr_wifi_nme_ap_converter_init.h
+#endif
+
+#ifndef EXCLUDE_CSR_WIFI_NME_AP_MODULE
+
+#include "csr_msgconv.h"
+
+#ifdef CSR_LOG_ENABLE
+#include "csr_log.h"
+
+extern const CsrLogPrimitiveInformation* CsrWifiNmeApTechInfoGet(void);
+#endif /* CSR_LOG_ENABLE */
+
+extern void CsrWifiNmeApConverterInit(void);
+
+#else /* EXCLUDE_CSR_WIFI_NME_AP_MODULE */
+
+#define CsrWifiNmeApConverterInit()
+
+#endif /* EXCLUDE_CSR_WIFI_NME_AP_MODULE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_NME_AP_CONVERTER_INIT_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_ap_lib.h
@@ -0,0 +1,526 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_NME_AP_LIB_H__
+#define CSR_WIFI_NME_AP_LIB_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_sched.h"
+#include "csr_util.h"
+#include "csr_msg_transport.h"
+
+#include "csr_wifi_lib.h"
+
+#include "csr_wifi_nme_ap_prim.h"
+#include "csr_wifi_nme_task.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_NME_ENABLE
+#error CSR_WIFI_NME_ENABLE MUST be defined inorder to use csr_wifi_nme_ap_lib.h
+#endif
+#ifndef CSR_WIFI_AP_ENABLE
+#error CSR_WIFI_AP_ENABLE MUST be defined inorder to use csr_wifi_nme_ap_lib.h
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiNmeApFreeUpstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_NME_AP upstream message. Does not
+ *      free the message itself, and can only be used for upstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_NME_AP upstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiNmeApFreeUpstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiNmeApFreeDownstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_NME_AP downstream message. Does not
+ *      free the message itself, and can only be used for downstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_NME_AP downstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiNmeApFreeDownstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ * Enum to string functions
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiNmeApPersCredentialTypeToString(CsrWifiNmeApPersCredentialType value);
+
+
+/*----------------------------------------------------------------------------*
+ * CsrPrim Type toString function.
+ * Converts a message type to the String name of the Message
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiNmeApPrimTypeToString(CsrPrim msgType);
+
+/*----------------------------------------------------------------------------*
+ * Lookup arrays for PrimType name Strings
+ *----------------------------------------------------------------------------*/
+extern const CsrCharString *CsrWifiNmeApUpstreamPrimNames[CSR_WIFI_NME_AP_PRIM_UPSTREAM_COUNT];
+extern const CsrCharString *CsrWifiNmeApDownstreamPrimNames[CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_COUNT];
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApConfigSetReqSend
+
+  DESCRIPTION
+    This primitive passes AP configuration info for NME. This can be sent at
+    any time but will be acted upon when the AP is started again. This
+    information is common to both P2P GO and AP
+
+  PARAMETERS
+    queue       - Message Source Task Queue (Cfm's will be sent to this Queue)
+    apConfig    - AP configuration for the NME.
+    apMacConfig - MAC configuration to be acted on when
+                  CSR_WIFI_NME_AP_START.request is sent.
+
+*******************************************************************************/
+#define CsrWifiNmeApConfigSetReqCreate(msg__, dst__, src__, apConfig__, apMacConfig__) \
+    msg__ = (CsrWifiNmeApConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiNmeApConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_CONFIG_SET_REQ, dst__, src__); \
+    msg__->apConfig = (apConfig__); \
+    msg__->apMacConfig = (apMacConfig__);
+
+#define CsrWifiNmeApConfigSetReqSendTo(dst__, src__, apConfig__, apMacConfig__) \
+    { \
+        CsrWifiNmeApConfigSetReq *msg__; \
+        CsrWifiNmeApConfigSetReqCreate(msg__, dst__, src__, apConfig__, apMacConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApConfigSetReqSend(src__, apConfig__, apMacConfig__) \
+    CsrWifiNmeApConfigSetReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, apConfig__, apMacConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApConfigSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Status of the request.
+
+*******************************************************************************/
+#define CsrWifiNmeApConfigSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiNmeApConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeApConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_CONFIG_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeApConfigSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiNmeApConfigSetCfm *msg__; \
+        CsrWifiNmeApConfigSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApConfigSetCfmSend(dst__, status__) \
+    CsrWifiNmeApConfigSetCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStaRemoveReqSend
+
+  DESCRIPTION
+    This primitive disconnects a connected station. If keepBlocking is set to
+    TRUE, the station with the specified MAC address is not allowed to
+    connect. If the requested station is not already connected,it may be
+    blocked based on keepBlocking parameter.
+
+  PARAMETERS
+    queue         - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    staMacAddress - Mac Address of the station to be disconnected or blocked
+    keepBlocking  - If TRUE, the station is blocked. If FALSE and the station is
+                    connected, disconnect the station. If FALSE and the station
+                    is not connected, no action is taken.
+
+*******************************************************************************/
+#define CsrWifiNmeApStaRemoveReqCreate(msg__, dst__, src__, interfaceTag__, staMacAddress__, keepBlocking__) \
+    msg__ = (CsrWifiNmeApStaRemoveReq *) CsrPmemAlloc(sizeof(CsrWifiNmeApStaRemoveReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_STA_REMOVE_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->staMacAddress = (staMacAddress__); \
+    msg__->keepBlocking = (keepBlocking__);
+
+#define CsrWifiNmeApStaRemoveReqSendTo(dst__, src__, interfaceTag__, staMacAddress__, keepBlocking__) \
+    { \
+        CsrWifiNmeApStaRemoveReq *msg__; \
+        CsrWifiNmeApStaRemoveReqCreate(msg__, dst__, src__, interfaceTag__, staMacAddress__, keepBlocking__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApStaRemoveReqSend(src__, interfaceTag__, staMacAddress__, keepBlocking__) \
+    CsrWifiNmeApStaRemoveReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, interfaceTag__, staMacAddress__, keepBlocking__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStartReqSend
+
+  DESCRIPTION
+    This primitive requests NME to started the AP operation.
+
+  PARAMETERS
+    queue          - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag   - Interface identifier; unique identifier of an interface
+    apType         - AP Type specifies the Legacy AP or P2P GO operation
+    cloakSsid      - Indicates whether the SSID should be cloaked (hidden and
+                     not broadcast in beacon) or not
+    ssid           - Service Set Identifier
+    ifIndex        - Radio interface
+    channel        - Channel number of the channel to use
+    apCredentials  - Security credential configuration.
+    maxConnections - Maximum number of stations/P2P clients allowed
+    p2pGoParam     - P2P specific GO parameters.
+                     NOT USED FOR CURRENT RELEASE
+    wpsEnabled     - Indicates whether WPS should be enabled or not
+
+*******************************************************************************/
+#define CsrWifiNmeApStartReqCreate(msg__, dst__, src__, interfaceTag__, apType__, cloakSsid__, ssid__, ifIndex__, channel__, apCredentials__, maxConnections__, p2pGoParam__, wpsEnabled__) \
+    msg__ = (CsrWifiNmeApStartReq *) CsrPmemAlloc(sizeof(CsrWifiNmeApStartReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_START_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->apType = (apType__); \
+    msg__->cloakSsid = (cloakSsid__); \
+    msg__->ssid = (ssid__); \
+    msg__->ifIndex = (ifIndex__); \
+    msg__->channel = (channel__); \
+    msg__->apCredentials = (apCredentials__); \
+    msg__->maxConnections = (maxConnections__); \
+    msg__->p2pGoParam = (p2pGoParam__); \
+    msg__->wpsEnabled = (wpsEnabled__);
+
+#define CsrWifiNmeApStartReqSendTo(dst__, src__, interfaceTag__, apType__, cloakSsid__, ssid__, ifIndex__, channel__, apCredentials__, maxConnections__, p2pGoParam__, wpsEnabled__) \
+    { \
+        CsrWifiNmeApStartReq *msg__; \
+        CsrWifiNmeApStartReqCreate(msg__, dst__, src__, interfaceTag__, apType__, cloakSsid__, ssid__, ifIndex__, channel__, apCredentials__, maxConnections__, p2pGoParam__, wpsEnabled__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApStartReqSend(src__, interfaceTag__, apType__, cloakSsid__, ssid__, ifIndex__, channel__, apCredentials__, maxConnections__, p2pGoParam__, wpsEnabled__) \
+    CsrWifiNmeApStartReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, interfaceTag__, apType__, cloakSsid__, ssid__, ifIndex__, channel__, apCredentials__, maxConnections__, p2pGoParam__, wpsEnabled__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStartCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of CSR_WIFI_NME_AP_START.request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface identifier; unique identifier of an interface
+    status       - Status of the request.
+    ssid         - Service Set Identifier
+
+*******************************************************************************/
+#define CsrWifiNmeApStartCfmCreate(msg__, dst__, src__, interfaceTag__, status__, ssid__) \
+    msg__ = (CsrWifiNmeApStartCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeApStartCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_START_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->ssid = (ssid__);
+
+#define CsrWifiNmeApStartCfmSendTo(dst__, src__, interfaceTag__, status__, ssid__) \
+    { \
+        CsrWifiNmeApStartCfm *msg__; \
+        CsrWifiNmeApStartCfmCreate(msg__, dst__, src__, interfaceTag__, status__, ssid__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApStartCfmSend(dst__, interfaceTag__, status__, ssid__) \
+    CsrWifiNmeApStartCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, status__, ssid__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStationIndSend
+
+  DESCRIPTION
+    This primitive indicates that a station has joined or a previously joined
+    station has left the BSS/group
+
+  PARAMETERS
+    queue             - Destination Task Queue
+    interfaceTag      - Interface Identifier; unique identifier of an interface
+    mediaStatus       - Indicates whether the station is connected or
+                        disconnected
+    peerMacAddress    - MAC address of the station
+    peerDeviceAddress - P2P Device Address
+
+*******************************************************************************/
+#define CsrWifiNmeApStationIndCreate(msg__, dst__, src__, interfaceTag__, mediaStatus__, peerMacAddress__, peerDeviceAddress__) \
+    msg__ = (CsrWifiNmeApStationInd *) CsrPmemAlloc(sizeof(CsrWifiNmeApStationInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_STATION_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->mediaStatus = (mediaStatus__); \
+    msg__->peerMacAddress = (peerMacAddress__); \
+    msg__->peerDeviceAddress = (peerDeviceAddress__);
+
+#define CsrWifiNmeApStationIndSendTo(dst__, src__, interfaceTag__, mediaStatus__, peerMacAddress__, peerDeviceAddress__) \
+    { \
+        CsrWifiNmeApStationInd *msg__; \
+        CsrWifiNmeApStationIndCreate(msg__, dst__, src__, interfaceTag__, mediaStatus__, peerMacAddress__, peerDeviceAddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApStationIndSend(dst__, interfaceTag__, mediaStatus__, peerMacAddress__, peerDeviceAddress__) \
+    CsrWifiNmeApStationIndSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, mediaStatus__, peerMacAddress__, peerDeviceAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStopReqSend
+
+  DESCRIPTION
+    This primitive requests NME to stop the AP operation.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiNmeApStopReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiNmeApStopReq *) CsrPmemAlloc(sizeof(CsrWifiNmeApStopReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_STOP_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiNmeApStopReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiNmeApStopReq *msg__; \
+        CsrWifiNmeApStopReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApStopReqSend(src__, interfaceTag__) \
+    CsrWifiNmeApStopReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStopIndSend
+
+  DESCRIPTION
+    Indicates that AP operation had stopped because of some unrecoverable
+    error after AP operation was started successfully. NME sends this signal
+    after failing to restart the AP operation internally following an error
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    apType       - Reports AP Type (P2PGO or AP)
+    status       - Error Status
+
+*******************************************************************************/
+#define CsrWifiNmeApStopIndCreate(msg__, dst__, src__, interfaceTag__, apType__, status__) \
+    msg__ = (CsrWifiNmeApStopInd *) CsrPmemAlloc(sizeof(CsrWifiNmeApStopInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_STOP_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->apType = (apType__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeApStopIndSendTo(dst__, src__, interfaceTag__, apType__, status__) \
+    { \
+        CsrWifiNmeApStopInd *msg__; \
+        CsrWifiNmeApStopIndCreate(msg__, dst__, src__, interfaceTag__, apType__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApStopIndSend(dst__, interfaceTag__, apType__, status__) \
+    CsrWifiNmeApStopIndSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, apType__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStopCfmSend
+
+  DESCRIPTION
+    This primitive confirms that the AP operation is stopped. NME shall send
+    this primitive in response to the request even if AP operation has
+    already been stopped
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface identifier; unique identifier of an interface
+    status       - Status of the request.
+
+*******************************************************************************/
+#define CsrWifiNmeApStopCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiNmeApStopCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeApStopCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_STOP_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeApStopCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiNmeApStopCfm *msg__; \
+        CsrWifiNmeApStopCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApStopCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiNmeApStopCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApWmmParamUpdateReqSend
+
+  DESCRIPTION
+    Application uses this primitive to update the WMM parameters
+
+  PARAMETERS
+    queue         - Message Source Task Queue (Cfm's will be sent to this Queue)
+    wmmApParams   - WMM Access point parameters per access category. The array
+                    index corresponds to the ACI
+    wmmApBcParams - WMM station parameters per access category to be advertised
+                    in the beacons and probe response The array index
+                    corresponds to the ACI
+
+*******************************************************************************/
+#define CsrWifiNmeApWmmParamUpdateReqCreate(msg__, dst__, src__, wmmApParams__, wmmApBcParams__) \
+    msg__ = (CsrWifiNmeApWmmParamUpdateReq *) CsrPmemAlloc(sizeof(CsrWifiNmeApWmmParamUpdateReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_WMM_PARAM_UPDATE_REQ, dst__, src__); \
+    CsrMemCpy(msg__->wmmApParams, (wmmApParams__), sizeof(CsrWifiSmeWmmAcParams) * 4); \
+    CsrMemCpy(msg__->wmmApBcParams, (wmmApBcParams__), sizeof(CsrWifiSmeWmmAcParams) * 4);
+
+#define CsrWifiNmeApWmmParamUpdateReqSendTo(dst__, src__, wmmApParams__, wmmApBcParams__) \
+    { \
+        CsrWifiNmeApWmmParamUpdateReq *msg__; \
+        CsrWifiNmeApWmmParamUpdateReqCreate(msg__, dst__, src__, wmmApParams__, wmmApBcParams__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApWmmParamUpdateReqSend(src__, wmmApParams__, wmmApBcParams__) \
+    CsrWifiNmeApWmmParamUpdateReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, wmmApParams__, wmmApBcParams__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApWmmParamUpdateCfmSend
+
+  DESCRIPTION
+    A confirm for for the WMM parameters update
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Status of the request.
+
+*******************************************************************************/
+#define CsrWifiNmeApWmmParamUpdateCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiNmeApWmmParamUpdateCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeApWmmParamUpdateCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_WMM_PARAM_UPDATE_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeApWmmParamUpdateCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiNmeApWmmParamUpdateCfm *msg__; \
+        CsrWifiNmeApWmmParamUpdateCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApWmmParamUpdateCfmSend(dst__, status__) \
+    CsrWifiNmeApWmmParamUpdateCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApWpsRegisterReqSend
+
+  DESCRIPTION
+    This primitive allows the NME to accept the WPS registration from an
+    enrollee. Such registration procedure can be cancelled by sending
+    CSR_WIFI_NME_WPS_CANCEL.request.
+
+  PARAMETERS
+    queue                    - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag             - Interface Identifier; unique identifier of an
+                               interface
+    selectedDevicePasswordId - Selected password type
+    selectedConfigMethod     - Selected WPS configuration method type
+    pin                      - PIN value.
+                               Relevant if selected device password ID is PIN.4
+                               digit pin is passed by sending the pin digits in
+                               pin[0]..pin[3] and rest of the contents filled
+                               with '-'.
+
+*******************************************************************************/
+#define CsrWifiNmeApWpsRegisterReqCreate(msg__, dst__, src__, interfaceTag__, selectedDevicePasswordId__, selectedConfigMethod__, pin__) \
+    msg__ = (CsrWifiNmeApWpsRegisterReq *) CsrPmemAlloc(sizeof(CsrWifiNmeApWpsRegisterReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_WPS_REGISTER_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->selectedDevicePasswordId = (selectedDevicePasswordId__); \
+    msg__->selectedConfigMethod = (selectedConfigMethod__); \
+    CsrMemCpy(msg__->pin, (pin__), sizeof(CsrUint8) * 8);
+
+#define CsrWifiNmeApWpsRegisterReqSendTo(dst__, src__, interfaceTag__, selectedDevicePasswordId__, selectedConfigMethod__, pin__) \
+    { \
+        CsrWifiNmeApWpsRegisterReq *msg__; \
+        CsrWifiNmeApWpsRegisterReqCreate(msg__, dst__, src__, interfaceTag__, selectedDevicePasswordId__, selectedConfigMethod__, pin__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApWpsRegisterReqSend(src__, interfaceTag__, selectedDevicePasswordId__, selectedConfigMethod__, pin__) \
+    CsrWifiNmeApWpsRegisterReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, interfaceTag__, selectedDevicePasswordId__, selectedConfigMethod__, pin__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApWpsRegisterCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of WPS procedure.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface identifier; unique identifier of an interface
+    status       - Status of the request.
+
+*******************************************************************************/
+#define CsrWifiNmeApWpsRegisterCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiNmeApWpsRegisterCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeApWpsRegisterCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_AP_PRIM, CSR_WIFI_NME_AP_WPS_REGISTER_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeApWpsRegisterCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiNmeApWpsRegisterCfm *msg__; \
+        CsrWifiNmeApWpsRegisterCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeApWpsRegisterCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiNmeApWpsRegisterCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, status__)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_NME_AP_LIB_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_ap_prim.h
@@ -0,0 +1,504 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_NME_AP_PRIM_H__
+#define CSR_WIFI_NME_AP_PRIM_H__
+
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+#include "csr_sched.h"
+#include "csr_wifi_common.h"
+#include "csr_result.h"
+#include "csr_wifi_fsm_event.h"
+#include "csr_wifi_sme_ap_prim.h"
+#include "csr_wifi_nme_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_NME_ENABLE
+#error CSR_WIFI_NME_ENABLE MUST be defined inorder to use csr_wifi_nme_ap_prim.h
+#endif
+#ifndef CSR_WIFI_AP_ENABLE
+#error CSR_WIFI_AP_ENABLE MUST be defined inorder to use csr_wifi_nme_ap_prim.h
+#endif
+
+#define CSR_WIFI_NME_AP_PRIM                                            (0x0426)
+
+typedef CsrPrim CsrWifiNmeApPrim;
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApPersCredentialType
+
+  DESCRIPTION
+    NME Credential Types
+
+ VALUES
+    CSR_WIFI_NME_AP_CREDENTIAL_TYPE_PSK
+                   - Use PSK as credential.
+    CSR_WIFI_NME_AP_CREDENTIAL_TYPE_PASSPHRASE
+                   - Use the specified passphrase as credential
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiNmeApPersCredentialType;
+#define CSR_WIFI_NME_AP_CREDENTIAL_TYPE_PSK          ((CsrWifiNmeApPersCredentialType) 0x00)
+#define CSR_WIFI_NME_AP_CREDENTIAL_TYPE_PASSPHRASE   ((CsrWifiNmeApPersCredentialType) 0x01)
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApConfig
+
+  DESCRIPTION
+    Structure holding AP config data.
+
+  MEMBERS
+    apGroupkeyTimeout - Access point group key timeout.
+    apStrictGtkRekey  - Access point strict GTK rekey flag. If set TRUE, the AP
+                        shall rekey GTK every time a connected STA leaves BSS.
+    apGmkTimeout      - Access point GMK timeout
+    apResponseTimeout - Response timeout
+    apRetransLimit    - Max allowed retransmissions
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint16 apGroupkeyTimeout;
+    CsrBool   apStrictGtkRekey;
+    CsrUint16 apGmkTimeout;
+    CsrUint16 apResponseTimeout;
+    CsrUint8  apRetransLimit;
+} CsrWifiNmeApConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApAuthPers
+
+  DESCRIPTION
+
+  MEMBERS
+    authSupport                     - Credential type value (as defined in the
+                                      enumeration type).
+    rsnCapabilities                 - RSN capabilities mask
+    wapiCapabilities                - WAPI capabilities mask
+    pskOrPassphrase                 - Credential type value (as defined in the
+                                      enumeration type).
+    authPers_credentials            - Union containing credentials which depends
+                                      on credentialType parameter.
+    authPers_credentialspsk         -
+    authPers_credentialspassphrase  -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeApAuthSupportMask      authSupport;
+    CsrWifiSmeApRsnCapabilitiesMask  rsnCapabilities;
+    CsrWifiSmeApWapiCapabilitiesMask wapiCapabilities;
+    CsrWifiNmeApPersCredentialType   pskOrPassphrase;
+    union {
+        CsrWifiNmePsk        psk;
+        CsrWifiNmePassphrase passphrase;
+    } authPers_credentials;
+} CsrWifiNmeApAuthPers;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApCredentials
+
+  DESCRIPTION
+    Structure containing the Credentials data.
+
+  MEMBERS
+    authType                     - Authentication type
+    nmeAuthType                  - Authentication parameters
+    nmeAuthTypeopenSystemEmpty   -
+    nmeAuthTypeauthwep           -
+    nmeAuthTypeauthTypePersonal  -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeApAuthType authType;
+    union {
+        CsrWifiSmeEmpty      openSystemEmpty;
+        CsrWifiSmeWepAuth    authwep;
+        CsrWifiNmeApAuthPers authTypePersonal;
+    } nmeAuthType;
+} CsrWifiNmeApCredentials;
+
+
+/* Downstream */
+#define CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_LOWEST            (0x0000)
+
+#define CSR_WIFI_NME_AP_CONFIG_SET_REQ                    ((CsrWifiNmeApPrim) (0x0000 + CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_WPS_REGISTER_REQ                  ((CsrWifiNmeApPrim) (0x0001 + CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_START_REQ                         ((CsrWifiNmeApPrim) (0x0002 + CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_STOP_REQ                          ((CsrWifiNmeApPrim) (0x0003 + CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_WMM_PARAM_UPDATE_REQ              ((CsrWifiNmeApPrim) (0x0004 + CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_STA_REMOVE_REQ                    ((CsrWifiNmeApPrim) (0x0005 + CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_LOWEST))
+
+
+#define CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_HIGHEST           (0x0005 + CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_LOWEST)
+
+/* Upstream */
+#define CSR_WIFI_NME_AP_PRIM_UPSTREAM_LOWEST              (0x0000 + CSR_PRIM_UPSTREAM)
+
+#define CSR_WIFI_NME_AP_CONFIG_SET_CFM                    ((CsrWifiNmeApPrim)(0x0000 + CSR_WIFI_NME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_WPS_REGISTER_CFM                  ((CsrWifiNmeApPrim)(0x0001 + CSR_WIFI_NME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_START_CFM                         ((CsrWifiNmeApPrim)(0x0002 + CSR_WIFI_NME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_STOP_CFM                          ((CsrWifiNmeApPrim)(0x0003 + CSR_WIFI_NME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_STOP_IND                          ((CsrWifiNmeApPrim)(0x0004 + CSR_WIFI_NME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_WMM_PARAM_UPDATE_CFM              ((CsrWifiNmeApPrim)(0x0005 + CSR_WIFI_NME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_AP_STATION_IND                       ((CsrWifiNmeApPrim)(0x0006 + CSR_WIFI_NME_AP_PRIM_UPSTREAM_LOWEST))
+
+#define CSR_WIFI_NME_AP_PRIM_UPSTREAM_HIGHEST             (0x0006 + CSR_WIFI_NME_AP_PRIM_UPSTREAM_LOWEST)
+
+#define CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_COUNT             (CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_HIGHEST + 1 - CSR_WIFI_NME_AP_PRIM_DOWNSTREAM_LOWEST)
+#define CSR_WIFI_NME_AP_PRIM_UPSTREAM_COUNT               (CSR_WIFI_NME_AP_PRIM_UPSTREAM_HIGHEST   + 1 - CSR_WIFI_NME_AP_PRIM_UPSTREAM_LOWEST)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApConfigSetReq
+
+  DESCRIPTION
+    This primitive passes AP configuration info for NME. This can be sent at
+    any time but will be acted upon when the AP is started again. This
+    information is common to both P2P GO and AP
+
+  MEMBERS
+    common      - Common header for use with the CsrWifiFsm Module
+    apConfig    - AP configuration for the NME.
+    apMacConfig - MAC configuration to be acted on when
+                  CSR_WIFI_NME_AP_START.request is sent.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrWifiNmeApConfig    apConfig;
+    CsrWifiSmeApMacConfig apMacConfig;
+} CsrWifiNmeApConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApWpsRegisterReq
+
+  DESCRIPTION
+    This primitive allows the NME to accept the WPS registration from an
+    enrollee. Such registration procedure can be cancelled by sending
+    CSR_WIFI_NME_WPS_CANCEL.request.
+
+  MEMBERS
+    common                   - Common header for use with the CsrWifiFsm Module
+    interfaceTag             - Interface Identifier; unique identifier of an
+                               interface
+    selectedDevicePasswordId - Selected password type
+    selectedConfigMethod     - Selected WPS configuration method type
+    pin                      - PIN value.
+                               Relevant if selected device password ID is PIN.4
+                               digit pin is passed by sending the pin digits in
+                               pin[0]..pin[3] and rest of the contents filled
+                               with '-'.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent         common;
+    CsrUint16               interfaceTag;
+    CsrWifiSmeWpsDpid       selectedDevicePasswordId;
+    CsrWifiSmeWpsConfigType selectedConfigMethod;
+    CsrUint8                pin[8];
+} CsrWifiNmeApWpsRegisterReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStartReq
+
+  DESCRIPTION
+    This primitive requests NME to started the AP operation.
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   - Interface identifier; unique identifier of an interface
+    apType         - AP Type specifies the Legacy AP or P2P GO operation
+    cloakSsid      - Indicates whether the SSID should be cloaked (hidden and
+                     not broadcast in beacon) or not
+    ssid           - Service Set Identifier
+    ifIndex        - Radio interface
+    channel        - Channel number of the channel to use
+    apCredentials  - Security credential configuration.
+    maxConnections - Maximum number of stations/P2P clients allowed
+    p2pGoParam     - P2P specific GO parameters.
+                     NOT USED FOR CURRENT RELEASE
+    wpsEnabled     - Indicates whether WPS should be enabled or not
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent         common;
+    CsrUint16               interfaceTag;
+    CsrWifiSmeApType        apType;
+    CsrBool                 cloakSsid;
+    CsrWifiSsid             ssid;
+    CsrWifiSmeRadioIF       ifIndex;
+    CsrUint8                channel;
+    CsrWifiNmeApCredentials apCredentials;
+    CsrUint8                maxConnections;
+    CsrWifiSmeApP2pGoConfig p2pGoParam;
+    CsrBool                 wpsEnabled;
+} CsrWifiNmeApStartReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStopReq
+
+  DESCRIPTION
+    This primitive requests NME to stop the AP operation.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiNmeApStopReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApWmmParamUpdateReq
+
+  DESCRIPTION
+    Application uses this primitive to update the WMM parameters
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    wmmApParams   - WMM Access point parameters per access category. The array
+                    index corresponds to the ACI
+    wmmApBcParams - WMM station parameters per access category to be advertised
+                    in the beacons and probe response The array index
+                    corresponds to the ACI
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrWifiSmeWmmAcParams wmmApParams[4];
+    CsrWifiSmeWmmAcParams wmmApBcParams[4];
+} CsrWifiNmeApWmmParamUpdateReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStaRemoveReq
+
+  DESCRIPTION
+    This primitive disconnects a connected station. If keepBlocking is set to
+    TRUE, the station with the specified MAC address is not allowed to
+    connect. If the requested station is not already connected,it may be
+    blocked based on keepBlocking parameter.
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    staMacAddress - Mac Address of the station to be disconnected or blocked
+    keepBlocking  - If TRUE, the station is blocked. If FALSE and the station is
+                    connected, disconnect the station. If FALSE and the station
+                    is not connected, no action is taken.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrUint16         interfaceTag;
+    CsrWifiMacAddress staMacAddress;
+    CsrBool           keepBlocking;
+} CsrWifiNmeApStaRemoveReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApConfigSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Status of the request.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiNmeApConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApWpsRegisterCfm
+
+  DESCRIPTION
+    This primitive reports the result of WPS procedure.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface identifier; unique identifier of an interface
+    status       - Status of the request.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiNmeApWpsRegisterCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStartCfm
+
+  DESCRIPTION
+    This primitive reports the result of CSR_WIFI_NME_AP_START.request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface identifier; unique identifier of an interface
+    status       - Status of the request.
+    ssid         - Service Set Identifier
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+    CsrWifiSsid     ssid;
+} CsrWifiNmeApStartCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStopCfm
+
+  DESCRIPTION
+    This primitive confirms that the AP operation is stopped. NME shall send
+    this primitive in response to the request even if AP operation has
+    already been stopped
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface identifier; unique identifier of an interface
+    status       - Status of the request.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiNmeApStopCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStopInd
+
+  DESCRIPTION
+    Indicates that AP operation had stopped because of some unrecoverable
+    error after AP operation was started successfully. NME sends this signal
+    after failing to restart the AP operation internally following an error
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    apType       - Reports AP Type (P2PGO or AP)
+    status       - Error Status
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent  common;
+    CsrUint16        interfaceTag;
+    CsrWifiSmeApType apType;
+    CsrResult        status;
+} CsrWifiNmeApStopInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApWmmParamUpdateCfm
+
+  DESCRIPTION
+    A confirm for for the WMM parameters update
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Status of the request.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiNmeApWmmParamUpdateCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeApStationInd
+
+  DESCRIPTION
+    This primitive indicates that a station has joined or a previously joined
+    station has left the BSS/group
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    interfaceTag      - Interface Identifier; unique identifier of an interface
+    mediaStatus       - Indicates whether the station is connected or
+                        disconnected
+    peerMacAddress    - MAC address of the station
+    peerDeviceAddress - P2P Device Address
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrUint16             interfaceTag;
+    CsrWifiSmeMediaStatus mediaStatus;
+    CsrWifiMacAddress     peerMacAddress;
+    CsrWifiMacAddress     peerDeviceAddress;
+} CsrWifiNmeApStationInd;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_NME_AP_PRIM_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_ap_sef.c
@@ -0,0 +1,30 @@
+/*****************************************************************************
+
+  FILE: csr_wifi_nme_sef.c
+
+  (c) Cambridge Silicon Radio Limited 2010
+
+  Refer to LICENSE.txt included with this source for details
+  on the license terms.
+
+ *****************************************************************************/
+#include "csr_wifi_nme_ap_sef.h"
+#include "unifi_priv.h"
+
+void CsrWifiNmeApUpstreamStateHandlers(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    switch(msg->type) {
+        case CSR_WIFI_NME_AP_START_CFM:
+            CsrWifiNmeApStartCfmHandler(drvpriv, msg);
+            break;
+        case CSR_WIFI_NME_AP_STOP_CFM:
+            CsrWifiNmeApStopCfmHandler(drvpriv, msg);
+            break;
+        case CSR_WIFI_NME_AP_CONFIG_SET_CFM:
+            CsrWifiNmeApConfigSetCfmHandler(drvpriv,msg);
+            break;
+        default:
+	    unifi_error(drvpriv, "CsrWifiNmeApUpstreamStateHandlers: unhandled NME_AP message type 0x%.4X\n",msg->type);
+            break;
+    }
+}
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_ap_sef.h
@@ -0,0 +1,31 @@
+/*****************************************************************************
+    FILE: csr_wifi_nme_sef.h
+    (c) Cambridge Silicon Radio Limited 2010
+
+    Refer to LICENSE.txt included with this source for details
+    on the license terms.
+
+*****************************************************************************/
+#ifndef CSR_WIFI_ROUTER_SEF_CSR_WIFI_NME_H__
+#define CSR_WIFI_ROUTER_SEF_CSR_WIFI_NME_H__
+
+#include "csr_wifi_nme_prim.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void CsrWifiNmeApUpstreamStateHandlers(void* drvpriv, CsrWifiFsmEvent* msg);
+
+
+extern void CsrWifiNmeApConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiNmeApStartCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiNmeApStopCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_SEF_CSR_WIFI_NME_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_ap_serialize.h
@@ -0,0 +1,105 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_NME_AP_SERIALIZE_H__
+#define CSR_WIFI_NME_AP_SERIALIZE_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_wifi_msgconv.h"
+
+#include "csr_wifi_nme_ap_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_NME_ENABLE
+#error CSR_WIFI_NME_ENABLE MUST be defined inorder to use csr_wifi_nme_ap_serialize.h
+#endif
+#ifndef CSR_WIFI_AP_ENABLE
+#error CSR_WIFI_AP_ENABLE MUST be defined inorder to use csr_wifi_nme_ap_serialize.h
+#endif
+
+extern void CsrWifiNmeApPfree(void *ptr);
+
+extern CsrUint8* CsrWifiNmeApConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeApConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeApConfigSetReqSizeof(void *msg);
+extern void CsrWifiNmeApConfigSetReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiNmeApWpsRegisterReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeApWpsRegisterReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeApWpsRegisterReqSizeof(void *msg);
+#define CsrWifiNmeApWpsRegisterReqSerFree CsrWifiNmeApPfree
+
+extern CsrUint8* CsrWifiNmeApStartReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeApStartReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeApStartReqSizeof(void *msg);
+extern void CsrWifiNmeApStartReqSerFree(void *msg);
+
+#define CsrWifiNmeApStopReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiNmeApStopReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiNmeApStopReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiNmeApStopReqSerFree CsrWifiNmeApPfree
+
+extern CsrUint8* CsrWifiNmeApWmmParamUpdateReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeApWmmParamUpdateReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeApWmmParamUpdateReqSizeof(void *msg);
+#define CsrWifiNmeApWmmParamUpdateReqSerFree CsrWifiNmeApPfree
+
+extern CsrUint8* CsrWifiNmeApStaRemoveReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeApStaRemoveReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeApStaRemoveReqSizeof(void *msg);
+#define CsrWifiNmeApStaRemoveReqSerFree CsrWifiNmeApPfree
+
+#define CsrWifiNmeApConfigSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiNmeApConfigSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiNmeApConfigSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiNmeApConfigSetCfmSerFree CsrWifiNmeApPfree
+
+extern CsrUint8* CsrWifiNmeApWpsRegisterCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeApWpsRegisterCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeApWpsRegisterCfmSizeof(void *msg);
+#define CsrWifiNmeApWpsRegisterCfmSerFree CsrWifiNmeApPfree
+
+extern CsrUint8* CsrWifiNmeApStartCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeApStartCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeApStartCfmSizeof(void *msg);
+#define CsrWifiNmeApStartCfmSerFree CsrWifiNmeApPfree
+
+extern CsrUint8* CsrWifiNmeApStopCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeApStopCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeApStopCfmSizeof(void *msg);
+#define CsrWifiNmeApStopCfmSerFree CsrWifiNmeApPfree
+
+extern CsrUint8* CsrWifiNmeApStopIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeApStopIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeApStopIndSizeof(void *msg);
+#define CsrWifiNmeApStopIndSerFree CsrWifiNmeApPfree
+
+#define CsrWifiNmeApWmmParamUpdateCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiNmeApWmmParamUpdateCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiNmeApWmmParamUpdateCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiNmeApWmmParamUpdateCfmSerFree CsrWifiNmeApPfree
+
+extern CsrUint8* CsrWifiNmeApStationIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeApStationIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeApStationIndSizeof(void *msg);
+#define CsrWifiNmeApStationIndSerFree CsrWifiNmeApPfree
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* CSR_WIFI_NME_AP_SERIALIZE_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_converter_init.h
@@ -0,0 +1,46 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_NME_CONVERTER_INIT_H__
+#define CSR_WIFI_NME_CONVERTER_INIT_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_NME_ENABLE
+#error CSR_WIFI_NME_ENABLE MUST be defined inorder to use csr_wifi_nme_converter_init.h
+#endif
+
+#ifndef EXCLUDE_CSR_WIFI_NME_MODULE
+
+#include "csr_msgconv.h"
+
+#ifdef CSR_LOG_ENABLE
+#include "csr_log.h"
+
+extern const CsrLogPrimitiveInformation* CsrWifiNmeTechInfoGet(void);
+#endif /* CSR_LOG_ENABLE */
+
+extern void CsrWifiNmeConverterInit(void);
+
+#else /* EXCLUDE_CSR_WIFI_NME_MODULE */
+
+#define CsrWifiNmeConverterInit()
+
+#endif /* EXCLUDE_CSR_WIFI_NME_MODULE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_NME_CONVERTER_INIT_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_lib.h
@@ -0,0 +1,1056 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_NME_LIB_H__
+#define CSR_WIFI_NME_LIB_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_sched.h"
+#include "csr_util.h"
+#include "csr_msg_transport.h"
+
+#include "csr_wifi_lib.h"
+
+#include "csr_wifi_nme_prim.h"
+#include "csr_wifi_nme_task.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_NME_ENABLE
+#error CSR_WIFI_NME_ENABLE MUST be defined inorder to use csr_wifi_nme_lib.h
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiNmeFreeUpstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_NME upstream message. Does not
+ *      free the message itself, and can only be used for upstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_NME upstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiNmeFreeUpstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiNmeFreeDownstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_NME downstream message. Does not
+ *      free the message itself, and can only be used for downstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_NME downstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiNmeFreeDownstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ * Enum to string functions
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiNmeAuthModeToString(CsrWifiNmeAuthMode value);
+const CsrCharString* CsrWifiNmeBssTypeToString(CsrWifiNmeBssType value);
+const CsrCharString* CsrWifiNmeCcxOptionsMaskToString(CsrWifiNmeCcxOptionsMask value);
+const CsrCharString* CsrWifiNmeConfigActionToString(CsrWifiNmeConfigAction value);
+const CsrCharString* CsrWifiNmeConnectionStatusToString(CsrWifiNmeConnectionStatus value);
+const CsrCharString* CsrWifiNmeCredentialTypeToString(CsrWifiNmeCredentialType value);
+const CsrCharString* CsrWifiNmeEapMethodToString(CsrWifiNmeEapMethod value);
+const CsrCharString* CsrWifiNmeEncryptionToString(CsrWifiNmeEncryption value);
+const CsrCharString* CsrWifiNmeIndicationsToString(CsrWifiNmeIndications value);
+const CsrCharString* CsrWifiNmeSecErrorToString(CsrWifiNmeSecError value);
+const CsrCharString* CsrWifiNmeSimCardTypeToString(CsrWifiNmeSimCardType value);
+const CsrCharString* CsrWifiNmeUmtsAuthResultToString(CsrWifiNmeUmtsAuthResult value);
+const CsrCharString* CsrWifiNmeWmmQosInfoToString(CsrWifiNmeWmmQosInfo value);
+
+
+/*----------------------------------------------------------------------------*
+ * CsrPrim Type toString function.
+ * Converts a message type to the String name of the Message
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiNmePrimTypeToString(CsrPrim msgType);
+
+/*----------------------------------------------------------------------------*
+ * Lookup arrays for PrimType name Strings
+ *----------------------------------------------------------------------------*/
+extern const CsrCharString *CsrWifiNmeUpstreamPrimNames[CSR_WIFI_NME_PRIM_UPSTREAM_COUNT];
+extern const CsrCharString *CsrWifiNmeDownstreamPrimNames[CSR_WIFI_NME_PRIM_DOWNSTREAM_COUNT];
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeConnectionStatusGetReqSend
+
+  DESCRIPTION
+    Requests the current connection status of the NME.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiNmeConnectionStatusGetReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiNmeConnectionStatusGetReq *) CsrPmemAlloc(sizeof(CsrWifiNmeConnectionStatusGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_CONNECTION_STATUS_GET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiNmeConnectionStatusGetReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiNmeConnectionStatusGetReq *msg__; \
+        CsrWifiNmeConnectionStatusGetReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeConnectionStatusGetReqSend(src__, interfaceTag__) \
+    CsrWifiNmeConnectionStatusGetReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeConnectionStatusGetCfmSend
+
+  DESCRIPTION
+    Reports the connection status of the NME.
+
+  PARAMETERS
+    queue            - Destination Task Queue
+    interfaceTag     - Interface Identifier; unique identifier of an interface
+    status           - Indicates the success or otherwise of the requested
+                       operation.
+    connectionStatus - NME current connection status
+
+*******************************************************************************/
+#define CsrWifiNmeConnectionStatusGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, connectionStatus__) \
+    msg__ = (CsrWifiNmeConnectionStatusGetCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeConnectionStatusGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_CONNECTION_STATUS_GET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->connectionStatus = (connectionStatus__);
+
+#define CsrWifiNmeConnectionStatusGetCfmSendTo(dst__, src__, interfaceTag__, status__, connectionStatus__) \
+    { \
+        CsrWifiNmeConnectionStatusGetCfm *msg__; \
+        CsrWifiNmeConnectionStatusGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, connectionStatus__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeConnectionStatusGetCfmSend(dst__, interfaceTag__, status__, connectionStatus__) \
+    CsrWifiNmeConnectionStatusGetCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, status__, connectionStatus__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeEventMaskSetReqSend
+
+  DESCRIPTION
+    The wireless manager application may register with the NME to receive
+    notification of interesting events. Indications will be sent only if the
+    wireless manager explicitly registers to be notified of that event.
+    indMask is a bit mask of values defined in CsrWifiNmeIndicationsMask.
+
+  PARAMETERS
+    queue   - Message Source Task Queue (Cfm's will be sent to this Queue)
+    indMask - Set mask with values from CsrWifiNmeIndications
+
+*******************************************************************************/
+#define CsrWifiNmeEventMaskSetReqCreate(msg__, dst__, src__, indMask__) \
+    msg__ = (CsrWifiNmeEventMaskSetReq *) CsrPmemAlloc(sizeof(CsrWifiNmeEventMaskSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_EVENT_MASK_SET_REQ, dst__, src__); \
+    msg__->indMask = (indMask__);
+
+#define CsrWifiNmeEventMaskSetReqSendTo(dst__, src__, indMask__) \
+    { \
+        CsrWifiNmeEventMaskSetReq *msg__; \
+        CsrWifiNmeEventMaskSetReqCreate(msg__, dst__, src__, indMask__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeEventMaskSetReqSend(src__, indMask__) \
+    CsrWifiNmeEventMaskSetReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, indMask__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeEventMaskSetCfmSend
+
+  DESCRIPTION
+    The NME calls the primitive to report the result of the request
+    primitive.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiNmeEventMaskSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiNmeEventMaskSetCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeEventMaskSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_EVENT_MASK_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeEventMaskSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiNmeEventMaskSetCfm *msg__; \
+        CsrWifiNmeEventMaskSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeEventMaskSetCfmSend(dst__, status__) \
+    CsrWifiNmeEventMaskSetCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileConnectReqSend
+
+  DESCRIPTION
+    Requests the NME to attempt to connect to the specified profile.
+    Overrides any current connection attempt.
+
+  PARAMETERS
+    queue           - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    profileIdentity - Identity (BSSID, SSID) of profile to be connected to.
+                      It must match an existing profile in the NME.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileConnectReqCreate(msg__, dst__, src__, interfaceTag__, profileIdentity__) \
+    msg__ = (CsrWifiNmeProfileConnectReq *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileConnectReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_CONNECT_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->profileIdentity = (profileIdentity__);
+
+#define CsrWifiNmeProfileConnectReqSendTo(dst__, src__, interfaceTag__, profileIdentity__) \
+    { \
+        CsrWifiNmeProfileConnectReq *msg__; \
+        CsrWifiNmeProfileConnectReqCreate(msg__, dst__, src__, interfaceTag__, profileIdentity__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileConnectReqSend(src__, interfaceTag__, profileIdentity__) \
+    CsrWifiNmeProfileConnectReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, interfaceTag__, profileIdentity__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileConnectCfmSend
+
+  DESCRIPTION
+    Reports the status of the NME PROFILE CONNECT REQ. If unsuccessful the
+    connectAttempt parameters contain details of the APs that the NME
+    attempted to connect to before reporting the failure of the request.
+
+  PARAMETERS
+    queue                - Destination Task Queue
+    interfaceTag         - Interface Identifier; unique identifier of an
+                           interface
+    status               - Indicates the success or otherwise of the requested
+                           operation.
+    connectAttemptsCount - This parameter is relevant only if
+                           status!=CSR_WIFI_NME_STATUS_SUCCESS.
+                           Number of connection attempt elements provided with
+                           this primitive
+    connectAttempts      - This parameter is relevant only if
+                           status!=CSR_WIFI_NME_STATUS_SUCCESS.
+                           Points to the list of connection attempt elements
+                           provided with this primitive
+                           Each element of the list provides information about
+                           an AP on which the connection attempt was made and
+                           the error that occurred during the attempt.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileConnectCfmCreate(msg__, dst__, src__, interfaceTag__, status__, connectAttemptsCount__, connectAttempts__) \
+    msg__ = (CsrWifiNmeProfileConnectCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileConnectCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_CONNECT_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->connectAttemptsCount = (connectAttemptsCount__); \
+    msg__->connectAttempts = (connectAttempts__);
+
+#define CsrWifiNmeProfileConnectCfmSendTo(dst__, src__, interfaceTag__, status__, connectAttemptsCount__, connectAttempts__) \
+    { \
+        CsrWifiNmeProfileConnectCfm *msg__; \
+        CsrWifiNmeProfileConnectCfmCreate(msg__, dst__, src__, interfaceTag__, status__, connectAttemptsCount__, connectAttempts__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileConnectCfmSend(dst__, interfaceTag__, status__, connectAttemptsCount__, connectAttempts__) \
+    CsrWifiNmeProfileConnectCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, status__, connectAttemptsCount__, connectAttempts__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileDeleteAllReqSend
+
+  DESCRIPTION
+    Deletes all profiles present in the NME, but does NOT modify the
+    preferred profile list.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiNmeProfileDeleteAllReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiNmeProfileDeleteAllReq *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileDeleteAllReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_DELETE_ALL_REQ, dst__, src__);
+
+#define CsrWifiNmeProfileDeleteAllReqSendTo(dst__, src__) \
+    { \
+        CsrWifiNmeProfileDeleteAllReq *msg__; \
+        CsrWifiNmeProfileDeleteAllReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileDeleteAllReqSend(src__) \
+    CsrWifiNmeProfileDeleteAllReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileDeleteAllCfmSend
+
+  DESCRIPTION
+    Reports the status of the CSR_WIFI_NME_PROFILE_DELETE_ALL_REQ.
+    Returns always CSR_WIFI_NME_STATUS_SUCCESS.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Indicates the success or otherwise of the requested operation, but
+             in this case it always set to success.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileDeleteAllCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiNmeProfileDeleteAllCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileDeleteAllCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_DELETE_ALL_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeProfileDeleteAllCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiNmeProfileDeleteAllCfm *msg__; \
+        CsrWifiNmeProfileDeleteAllCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileDeleteAllCfmSend(dst__, status__) \
+    CsrWifiNmeProfileDeleteAllCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileDeleteReqSend
+
+  DESCRIPTION
+    Will delete the profile with a matching identity, but does NOT modify the
+    preferred profile list.
+
+  PARAMETERS
+    queue           - Message Source Task Queue (Cfm's will be sent to this Queue)
+    profileIdentity - Identity (BSSID, SSID) of profile to be deleted.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileDeleteReqCreate(msg__, dst__, src__, profileIdentity__) \
+    msg__ = (CsrWifiNmeProfileDeleteReq *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileDeleteReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_DELETE_REQ, dst__, src__); \
+    msg__->profileIdentity = (profileIdentity__);
+
+#define CsrWifiNmeProfileDeleteReqSendTo(dst__, src__, profileIdentity__) \
+    { \
+        CsrWifiNmeProfileDeleteReq *msg__; \
+        CsrWifiNmeProfileDeleteReqCreate(msg__, dst__, src__, profileIdentity__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileDeleteReqSend(src__, profileIdentity__) \
+    CsrWifiNmeProfileDeleteReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, profileIdentity__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileDeleteCfmSend
+
+  DESCRIPTION
+    Reports the status of the CSR_WIFI_NME_PROFILE_DELETE_REQ.
+    Returns CSR_WIFI_NME_STATUS_NOT_FOUND if there is no matching profile.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Indicates the success or otherwise of the requested operation.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileDeleteCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiNmeProfileDeleteCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileDeleteCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_DELETE_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeProfileDeleteCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiNmeProfileDeleteCfm *msg__; \
+        CsrWifiNmeProfileDeleteCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileDeleteCfmSend(dst__, status__) \
+    CsrWifiNmeProfileDeleteCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileDisconnectIndSend
+
+  DESCRIPTION
+    Indication generated from the NME (if an application subscribes to
+    receive it) that informs that application that the current profile
+    connection has disconnected. The indication will contain information
+    about APs that it attempted to maintain the connection via i.e. in the
+    case of failed roaming.
+
+  PARAMETERS
+    queue                - Destination Task Queue
+    interfaceTag         - Interface Identifier; unique identifier of an
+                           interface
+    connectAttemptsCount - Number of connection attempt elements provided with
+                           this primitive
+    connectAttempts      - Points to the list of connection attempt elements
+                           provided with this primitive
+                           Each element of the list provides information about
+                           an AP on which the connection attempt was made and
+                           the error occurred during the attempt.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileDisconnectIndCreate(msg__, dst__, src__, interfaceTag__, connectAttemptsCount__, connectAttempts__) \
+    msg__ = (CsrWifiNmeProfileDisconnectInd *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileDisconnectInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_DISCONNECT_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->connectAttemptsCount = (connectAttemptsCount__); \
+    msg__->connectAttempts = (connectAttempts__);
+
+#define CsrWifiNmeProfileDisconnectIndSendTo(dst__, src__, interfaceTag__, connectAttemptsCount__, connectAttempts__) \
+    { \
+        CsrWifiNmeProfileDisconnectInd *msg__; \
+        CsrWifiNmeProfileDisconnectIndCreate(msg__, dst__, src__, interfaceTag__, connectAttemptsCount__, connectAttempts__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileDisconnectIndSend(dst__, interfaceTag__, connectAttemptsCount__, connectAttempts__) \
+    CsrWifiNmeProfileDisconnectIndSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, connectAttemptsCount__, connectAttempts__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileOrderSetReqSend
+
+  DESCRIPTION
+    Defines the preferred order that profiles present in the NME should be
+    used during the NME auto-connect behaviour.
+    If profileIdentitysCount == 0, it removes any existing preferred profile
+    list already present in the NME, effectively disabling the auto-connect
+    behaviour.
+    NOTE: Profile identities that do not match any profile stored in the NME
+    are ignored during the auto-connect procedure.
+    NOTE: during auto-connect the NME will only attempt to join an existing
+    adhoc network and it will never attempt to host an adhoc network; for
+    hosting and adhoc network, use CSR_WIFI_NME_PROFILE_CONNECT_REQ
+
+  PARAMETERS
+    queue                 - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag          - Interface Identifier; unique identifier of an
+                            interface
+    profileIdentitysCount - The number of profiles identities in the list.
+    profileIdentitys      - Points to the list of profile identities.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileOrderSetReqCreate(msg__, dst__, src__, interfaceTag__, profileIdentitysCount__, profileIdentitys__) \
+    msg__ = (CsrWifiNmeProfileOrderSetReq *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileOrderSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_ORDER_SET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->profileIdentitysCount = (profileIdentitysCount__); \
+    msg__->profileIdentitys = (profileIdentitys__);
+
+#define CsrWifiNmeProfileOrderSetReqSendTo(dst__, src__, interfaceTag__, profileIdentitysCount__, profileIdentitys__) \
+    { \
+        CsrWifiNmeProfileOrderSetReq *msg__; \
+        CsrWifiNmeProfileOrderSetReqCreate(msg__, dst__, src__, interfaceTag__, profileIdentitysCount__, profileIdentitys__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileOrderSetReqSend(src__, interfaceTag__, profileIdentitysCount__, profileIdentitys__) \
+    CsrWifiNmeProfileOrderSetReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, interfaceTag__, profileIdentitysCount__, profileIdentitys__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileOrderSetCfmSend
+
+  DESCRIPTION
+    Confirmation to UNIFI_NME_PROFILE_ORDER_SET.request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Indicates the success or otherwise of the requested
+                   operation.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileOrderSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiNmeProfileOrderSetCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileOrderSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_ORDER_SET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeProfileOrderSetCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiNmeProfileOrderSetCfm *msg__; \
+        CsrWifiNmeProfileOrderSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileOrderSetCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiNmeProfileOrderSetCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileSetReqSend
+
+  DESCRIPTION
+    Creates or updates an existing profile in the NME that matches the unique
+    identity of the profile. Each profile is identified by the combination of
+    BSSID and SSID. The profile contains all the required credentials for
+    attempting to connect to the network. Creating or updating a profile via
+    the NME PROFILE SET REQ does NOT add the profile to the preferred profile
+    list within the NME used for the NME auto-connect behaviour.
+
+  PARAMETERS
+    queue   - Message Source Task Queue (Cfm's will be sent to this Queue)
+    profile - Specifies the identity and credentials of the network.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileSetReqCreate(msg__, dst__, src__, profile__) \
+    msg__ = (CsrWifiNmeProfileSetReq *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_SET_REQ, dst__, src__); \
+    msg__->profile = (profile__);
+
+#define CsrWifiNmeProfileSetReqSendTo(dst__, src__, profile__) \
+    { \
+        CsrWifiNmeProfileSetReq *msg__; \
+        CsrWifiNmeProfileSetReqCreate(msg__, dst__, src__, profile__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileSetReqSend(src__, profile__) \
+    CsrWifiNmeProfileSetReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, profile__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileSetCfmSend
+
+  DESCRIPTION
+    Reports the status of the NME PROFILE SET REQ; the request will only fail
+    if the details specified in the profile contains an invalid combination
+    of parameters for example specifying the profile as cloaked but not
+    specifying the SSID. The NME doesn't limit the number of profiles that
+    may be created. The NME assumes that the entity configuring it is aware
+    of the appropriate limits.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Indicates the success or otherwise of the requested operation.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiNmeProfileSetCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeProfileSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiNmeProfileSetCfm *msg__; \
+        CsrWifiNmeProfileSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileSetCfmSend(dst__, status__) \
+    CsrWifiNmeProfileSetCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileUpdateIndSend
+
+  DESCRIPTION
+    Indication generated from the NME (if an application subscribes to
+    receive it) that informs that application that the contained profile has
+    changed.
+    For example, either the credentials EAP-FAST PAC file or the session data
+    within the profile has changed.
+    It is up to the application whether it stores this updated profile or
+    not.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    profile      - The identity and credentials of the network.
+
+*******************************************************************************/
+#define CsrWifiNmeProfileUpdateIndCreate(msg__, dst__, src__, interfaceTag__, profile__) \
+    msg__ = (CsrWifiNmeProfileUpdateInd *) CsrPmemAlloc(sizeof(CsrWifiNmeProfileUpdateInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_PROFILE_UPDATE_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->profile = (profile__);
+
+#define CsrWifiNmeProfileUpdateIndSendTo(dst__, src__, interfaceTag__, profile__) \
+    { \
+        CsrWifiNmeProfileUpdateInd *msg__; \
+        CsrWifiNmeProfileUpdateIndCreate(msg__, dst__, src__, interfaceTag__, profile__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeProfileUpdateIndSend(dst__, interfaceTag__, profile__) \
+    CsrWifiNmeProfileUpdateIndSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, profile__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimGsmAuthIndSend
+
+  DESCRIPTION
+    Indication generated from the NME (if an application subscribes to
+    receive it) that requests the UICC Manager to perform a GSM
+    authentication on behalf of the NME. This indication is generated when
+    the NME is attempting to connect to a profile configured for EAP-SIM. An
+    application MUST register to receive this indication for the NME to
+    support the EAP-SIM credential types. Otherwise the NME has no route to
+    obtain the information from the UICC. EAP-SIM authentication requires 2
+    or 3 GSM authentication rounds and therefore 2 or 3 RANDS (GSM Random
+    Challenges) are included.
+
+  PARAMETERS
+    queue       - Destination Task Queue
+    randsLength - GSM RAND is 16 bytes long hence valid values are 32 (2 RANDS)
+                  or 48 (3 RANDs).
+    rands       - 2 or 3 RANDs values.
+
+*******************************************************************************/
+#define CsrWifiNmeSimGsmAuthIndCreate(msg__, dst__, src__, randsLength__, rands__) \
+    msg__ = (CsrWifiNmeSimGsmAuthInd *) CsrPmemAlloc(sizeof(CsrWifiNmeSimGsmAuthInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_SIM_GSM_AUTH_IND, dst__, src__); \
+    msg__->randsLength = (randsLength__); \
+    msg__->rands = (rands__);
+
+#define CsrWifiNmeSimGsmAuthIndSendTo(dst__, src__, randsLength__, rands__) \
+    { \
+        CsrWifiNmeSimGsmAuthInd *msg__; \
+        CsrWifiNmeSimGsmAuthIndCreate(msg__, dst__, src__, randsLength__, rands__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeSimGsmAuthIndSend(dst__, randsLength__, rands__) \
+    CsrWifiNmeSimGsmAuthIndSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, randsLength__, rands__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimGsmAuthResSend
+
+  DESCRIPTION
+    Response from the application that received the NME SIM GSM AUTH IND. For
+    each GSM authentication round a GSM Ciphering key (Kc) and a signed
+    response (SRES) are produced. Since 2 or 3 GSM authentication rounds are
+    used the 2 or 3 Kc's obtained respectively are combined into one buffer
+    and similarly the 2 or 3 SRES's obtained are combined into another
+    buffer. The order of Kc values (SRES values respectively) in their buffer
+    is the same as that of their corresponding RAND values in the incoming
+    indication.
+
+  PARAMETERS
+    status     - Indicates the outcome of the requested operation:
+                 STATUS_SUCCESS or STATUS_ERROR
+    kcsLength  - Length in Bytes of Kc buffer. Legal values are: 16 or 24.
+    kcs        - Kc buffer holding 2 or 3 Kc values.
+    sresLength - Length in Bytes of SRES buffer. Legal values are: 8 or 12.
+    sres       - SRES buffer holding 2 or 3 SRES values.
+
+*******************************************************************************/
+#define CsrWifiNmeSimGsmAuthResCreate(msg__, dst__, src__, status__, kcsLength__, kcs__, sresLength__, sres__) \
+    msg__ = (CsrWifiNmeSimGsmAuthRes *) CsrPmemAlloc(sizeof(CsrWifiNmeSimGsmAuthRes)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_SIM_GSM_AUTH_RES, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->kcsLength = (kcsLength__); \
+    msg__->kcs = (kcs__); \
+    msg__->sresLength = (sresLength__); \
+    msg__->sres = (sres__);
+
+#define CsrWifiNmeSimGsmAuthResSendTo(dst__, src__, status__, kcsLength__, kcs__, sresLength__, sres__) \
+    { \
+        CsrWifiNmeSimGsmAuthRes *msg__; \
+        CsrWifiNmeSimGsmAuthResCreate(msg__, dst__, src__, status__, kcsLength__, kcs__, sresLength__, sres__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeSimGsmAuthResSend(src__, status__, kcsLength__, kcs__, sresLength__, sres__) \
+    CsrWifiNmeSimGsmAuthResSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, status__, kcsLength__, kcs__, sresLength__, sres__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimImsiGetIndSend
+
+  DESCRIPTION
+    Indication generated from the NME (if an application subscribes to
+    receive it) that requests the IMSI and UICC type from the UICC Manager.
+    This indication is generated when the NME is attempting to connect to a
+    profile configured for EAP-SIM/AKA. An application MUST register to
+    receive this indication for the NME to support the EAP-SIM/AKA credential
+    types. Otherwise the NME has no route to obtain the information from the
+    UICC.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+
+*******************************************************************************/
+#define CsrWifiNmeSimImsiGetIndCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiNmeSimImsiGetInd *) CsrPmemAlloc(sizeof(CsrWifiNmeSimImsiGetInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_SIM_IMSI_GET_IND, dst__, src__);
+
+#define CsrWifiNmeSimImsiGetIndSendTo(dst__, src__) \
+    { \
+        CsrWifiNmeSimImsiGetInd *msg__; \
+        CsrWifiNmeSimImsiGetIndCreate(msg__, dst__, src__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeSimImsiGetIndSend(dst__) \
+    CsrWifiNmeSimImsiGetIndSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimImsiGetResSend
+
+  DESCRIPTION
+    Response from the application that received the NME SIM IMSI GET IND.
+
+  PARAMETERS
+    status   - Indicates the outcome of the requested operation: STATUS_SUCCESS
+               or STATUS_ERROR.
+    imsi     - The value of the IMSI obtained from the UICC.
+    cardType - The UICC type (GSM only (SIM), UMTS only (USIM), Both).
+
+*******************************************************************************/
+#define CsrWifiNmeSimImsiGetResCreate(msg__, dst__, src__, status__, imsi__, cardType__) \
+    msg__ = (CsrWifiNmeSimImsiGetRes *) CsrPmemAlloc(sizeof(CsrWifiNmeSimImsiGetRes)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_SIM_IMSI_GET_RES, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->imsi = (imsi__); \
+    msg__->cardType = (cardType__);
+
+#define CsrWifiNmeSimImsiGetResSendTo(dst__, src__, status__, imsi__, cardType__) \
+    { \
+        CsrWifiNmeSimImsiGetRes *msg__; \
+        CsrWifiNmeSimImsiGetResCreate(msg__, dst__, src__, status__, imsi__, cardType__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeSimImsiGetResSend(src__, status__, imsi__, cardType__) \
+    CsrWifiNmeSimImsiGetResSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, status__, imsi__, cardType__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimUmtsAuthIndSend
+
+  DESCRIPTION
+    Indication generated from the NME (if an application subscribes to
+    receive it) that requests the UICC Manager to perform a UMTS
+    authentication on behalf of the NME. This indication is generated when
+    the NME is attempting to connect to a profile configured for EAP-AKA. An
+    application MUST register to receive this indication for the NME to
+    support the EAP-AKA credential types. Otherwise the NME has no route to
+    obtain the information from the USIM. EAP-AKA requires one UMTS
+    authentication round and therefore only one RAND and one AUTN values are
+    included.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    rand   - UMTS RAND value.
+    autn   - UMTS AUTN value.
+
+*******************************************************************************/
+#define CsrWifiNmeSimUmtsAuthIndCreate(msg__, dst__, src__, rand__, autn__) \
+    msg__ = (CsrWifiNmeSimUmtsAuthInd *) CsrPmemAlloc(sizeof(CsrWifiNmeSimUmtsAuthInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_SIM_UMTS_AUTH_IND, dst__, src__); \
+    CsrMemCpy(msg__->rand, (rand__), sizeof(CsrUint8) * 16); \
+    CsrMemCpy(msg__->autn, (autn__), sizeof(CsrUint8) * 16);
+
+#define CsrWifiNmeSimUmtsAuthIndSendTo(dst__, src__, rand__, autn__) \
+    { \
+        CsrWifiNmeSimUmtsAuthInd *msg__; \
+        CsrWifiNmeSimUmtsAuthIndCreate(msg__, dst__, src__, rand__, autn__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeSimUmtsAuthIndSend(dst__, rand__, autn__) \
+    CsrWifiNmeSimUmtsAuthIndSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, rand__, autn__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimUmtsAuthResSend
+
+  DESCRIPTION
+    Response from the application that received the NME SIM UMTS AUTH IND.
+    The values of umtsCipherKey, umtsIntegrityKey, resParameterLength and
+    resParameter are only meanigful when result = UMTS_AUTH_RESULT_SUCCESS.
+    The value of auts is only meaningful when
+    result=UMTS_AUTH_RESULT_SYNC_FAIL.
+
+  PARAMETERS
+    status             - Indicates the outcome of the requested operation:
+                         STATUS_SUCCESS or STATUS_ERROR.
+    result             - The result of UMTS authentication as performed by the
+                         UICC which could be: Success, Authentication Reject or
+                         Synchronisation Failure. For all these 3 outcomes the
+                         value of status is success.
+    umtsCipherKey      - The UMTS Cipher Key as calculated and returned by the
+                         UICC.
+    umtsIntegrityKey   - The UMTS Integrity Key as calculated and returned by
+                         the UICC.
+    resParameterLength - The length (in bytes) of the RES parameter (min=4; max
+                         = 16).
+    resParameter       - The RES parameter as calculated and returned by the
+                         UICC.
+    auts               - The AUTS parameter as calculated and returned by the
+                         UICC.
+
+*******************************************************************************/
+#define CsrWifiNmeSimUmtsAuthResCreate(msg__, dst__, src__, status__, result__, umtsCipherKey__, umtsIntegrityKey__, resParameterLength__, resParameter__, auts__) \
+    msg__ = (CsrWifiNmeSimUmtsAuthRes *) CsrPmemAlloc(sizeof(CsrWifiNmeSimUmtsAuthRes)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_SIM_UMTS_AUTH_RES, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->result = (result__); \
+    CsrMemCpy(msg__->umtsCipherKey, (umtsCipherKey__), sizeof(CsrUint8) * 16); \
+    CsrMemCpy(msg__->umtsIntegrityKey, (umtsIntegrityKey__), sizeof(CsrUint8) * 16); \
+    msg__->resParameterLength = (resParameterLength__); \
+    msg__->resParameter = (resParameter__); \
+    CsrMemCpy(msg__->auts, (auts__), sizeof(CsrUint8) * 14);
+
+#define CsrWifiNmeSimUmtsAuthResSendTo(dst__, src__, status__, result__, umtsCipherKey__, umtsIntegrityKey__, resParameterLength__, resParameter__, auts__) \
+    { \
+        CsrWifiNmeSimUmtsAuthRes *msg__; \
+        CsrWifiNmeSimUmtsAuthResCreate(msg__, dst__, src__, status__, result__, umtsCipherKey__, umtsIntegrityKey__, resParameterLength__, resParameter__, auts__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeSimUmtsAuthResSend(src__, status__, result__, umtsCipherKey__, umtsIntegrityKey__, resParameterLength__, resParameter__, auts__) \
+    CsrWifiNmeSimUmtsAuthResSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, status__, result__, umtsCipherKey__, umtsIntegrityKey__, resParameterLength__, resParameter__, auts__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsCancelReqSend
+
+  DESCRIPTION
+    Requests the NME to cancel any WPS procedure that it is currently
+    performing. This includes WPS registrar activities started because of
+    CSR_WIFI_NME_AP_REGISTER.request
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiNmeWpsCancelReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiNmeWpsCancelReq *) CsrPmemAlloc(sizeof(CsrWifiNmeWpsCancelReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_WPS_CANCEL_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiNmeWpsCancelReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiNmeWpsCancelReq *msg__; \
+        CsrWifiNmeWpsCancelReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeWpsCancelReqSend(src__, interfaceTag__) \
+    CsrWifiNmeWpsCancelReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsCancelCfmSend
+
+  DESCRIPTION
+    Reports the status of the NME WPS REQ, the request is always SUCCESSFUL.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Only returns CSR_WIFI_NME_STATUS_SUCCESS
+
+*******************************************************************************/
+#define CsrWifiNmeWpsCancelCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiNmeWpsCancelCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeWpsCancelCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_WPS_CANCEL_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeWpsCancelCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiNmeWpsCancelCfm *msg__; \
+        CsrWifiNmeWpsCancelCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeWpsCancelCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiNmeWpsCancelCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsCfmSend
+
+  DESCRIPTION
+    Reports the status of the NME WPS REQ.
+    If CSR_WIFI_NME_STATUS_SUCCESS, the profile parameter contains the
+    identity and credentials of the AP.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Indicates the success or otherwise of the requested
+                   operation.
+    profile      - This parameter is relevant only if
+                   status==CSR_WIFI_NME_STATUS_SUCCESS.
+                   The identity and credentials of the network.
+
+*******************************************************************************/
+#define CsrWifiNmeWpsCfmCreate(msg__, dst__, src__, interfaceTag__, status__, profile__) \
+    msg__ = (CsrWifiNmeWpsCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeWpsCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_WPS_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->profile = (profile__);
+
+#define CsrWifiNmeWpsCfmSendTo(dst__, src__, interfaceTag__, status__, profile__) \
+    { \
+        CsrWifiNmeWpsCfm *msg__; \
+        CsrWifiNmeWpsCfmCreate(msg__, dst__, src__, interfaceTag__, status__, profile__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeWpsCfmSend(dst__, interfaceTag__, status__, profile__) \
+    CsrWifiNmeWpsCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, interfaceTag__, status__, profile__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsConfigSetReqSend
+
+  DESCRIPTION
+    This primitive passes the WPS information for the device to NME. This may
+    be accepted only if no interface is active.
+
+  PARAMETERS
+    queue     - Message Source Task Queue (Cfm's will be sent to this Queue)
+    wpsConfig - WPS config.
+
+*******************************************************************************/
+#define CsrWifiNmeWpsConfigSetReqCreate(msg__, dst__, src__, wpsConfig__) \
+    msg__ = (CsrWifiNmeWpsConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiNmeWpsConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_WPS_CONFIG_SET_REQ, dst__, src__); \
+    msg__->wpsConfig = (wpsConfig__);
+
+#define CsrWifiNmeWpsConfigSetReqSendTo(dst__, src__, wpsConfig__) \
+    { \
+        CsrWifiNmeWpsConfigSetReq *msg__; \
+        CsrWifiNmeWpsConfigSetReqCreate(msg__, dst__, src__, wpsConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeWpsConfigSetReqSend(src__, wpsConfig__) \
+    CsrWifiNmeWpsConfigSetReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, wpsConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsConfigSetCfmSend
+
+  DESCRIPTION
+    Confirm.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Status of the request.
+
+*******************************************************************************/
+#define CsrWifiNmeWpsConfigSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiNmeWpsConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiNmeWpsConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_WPS_CONFIG_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiNmeWpsConfigSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiNmeWpsConfigSetCfm *msg__; \
+        CsrWifiNmeWpsConfigSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeWpsConfigSetCfmSend(dst__, status__) \
+    CsrWifiNmeWpsConfigSetCfmSendTo(dst__, CSR_WIFI_NME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsReqSend
+
+  DESCRIPTION
+    Requests the NME to look for WPS enabled APs and attempt to perform WPS
+    to determine the appropriate security credentials to connect to the AP.
+    If the PIN == '00000000' then 'push button mode' is indicated, otherwise
+    the PIN has to match that of the AP. 4 digit pin is passed by sending the
+    pin digits in pin[0]..pin[3] and rest of the contents filled with '-'.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    pin          - PIN value.
+    ssid         - Service Set identifier
+    bssid        - ID of Basic Service Set for which a WPS connection attempt is
+                   being made.
+
+*******************************************************************************/
+#define CsrWifiNmeWpsReqCreate(msg__, dst__, src__, interfaceTag__, pin__, ssid__, bssid__) \
+    msg__ = (CsrWifiNmeWpsReq *) CsrPmemAlloc(sizeof(CsrWifiNmeWpsReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_NME_PRIM, CSR_WIFI_NME_WPS_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    CsrMemCpy(msg__->pin, (pin__), sizeof(CsrUint8) * 8); \
+    msg__->ssid = (ssid__); \
+    msg__->bssid = (bssid__);
+
+#define CsrWifiNmeWpsReqSendTo(dst__, src__, interfaceTag__, pin__, ssid__, bssid__) \
+    { \
+        CsrWifiNmeWpsReq *msg__; \
+        CsrWifiNmeWpsReqCreate(msg__, dst__, src__, interfaceTag__, pin__, ssid__, bssid__); \
+        CsrMsgTransport(dst__, CSR_WIFI_NME_PRIM, msg__); \
+    }
+
+#define CsrWifiNmeWpsReqSend(src__, interfaceTag__, pin__, ssid__, bssid__) \
+    CsrWifiNmeWpsReqSendTo(CSR_WIFI_NME_IFACEQUEUE, src__, interfaceTag__, pin__, ssid__, bssid__)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_NME_LIB_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_prim.h
@@ -0,0 +1,1666 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_NME_PRIM_H__
+#define CSR_WIFI_NME_PRIM_H__
+
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+#include "csr_sched.h"
+#include "csr_wifi_common.h"
+#include "csr_result.h"
+#include "csr_wifi_fsm_event.h"
+#include "csr_wifi_sme_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_NME_ENABLE
+#error CSR_WIFI_NME_ENABLE MUST be defined inorder to use csr_wifi_nme_prim.h
+#endif
+
+#define CSR_WIFI_NME_PRIM                                               (0x0424)
+
+typedef CsrPrim CsrWifiNmePrim;
+
+typedef void (*CsrWifiNmeFrameFreeFunction)(void *frame);
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeAuthMode
+
+  DESCRIPTION
+    WiFi Authentication Mode
+
+ VALUES
+    CSR_WIFI_NME_AUTH_MODE_80211_OPEN
+                   - Connects to an open system network (i.e. no authentication,
+                     no encryption) or to a WEP enabled network.
+    CSR_WIFI_NME_AUTH_MODE_80211_SHARED
+                   - Connect to a WEP enabled network.
+    CSR_WIFI_NME_AUTH_MODE_8021X_WPA
+                   - Connects to a WPA Enterprise enabled network.
+    CSR_WIFI_NME_AUTH_MODE_8021X_WPAPSK
+                   - Connects to a WPA with Pre-Shared Key enabled network.
+    CSR_WIFI_NME_AUTH_MODE_8021X_WPA2
+                   - Connects to a WPA2 Enterprise enabled network.
+    CSR_WIFI_NME_AUTH_MODE_8021X_WPA2PSK
+                   - Connects to a WPA2 with Pre-Shared Key enabled network.
+    CSR_WIFI_NME_AUTH_MODE_8021X_CCKM
+                   - Connects to a CCKM enabled network.
+    CSR_WIFI_NME_AUTH_MODE_WAPI_WAI
+                   - Connects to a WAPI Enterprise enabled network.
+    CSR_WIFI_NME_AUTH_MODE_WAPI_WAIPSK
+                   - Connects to a WAPI with Pre-Shared Key enabled network.
+    CSR_WIFI_NME_AUTH_MODE_8021X_OTHER1X
+                   - For future use.
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiNmeAuthMode;
+#define CSR_WIFI_NME_AUTH_MODE_80211_OPEN      ((CsrWifiNmeAuthMode) 0x0001)
+#define CSR_WIFI_NME_AUTH_MODE_80211_SHARED    ((CsrWifiNmeAuthMode) 0x0002)
+#define CSR_WIFI_NME_AUTH_MODE_8021X_WPA       ((CsrWifiNmeAuthMode) 0x0004)
+#define CSR_WIFI_NME_AUTH_MODE_8021X_WPAPSK    ((CsrWifiNmeAuthMode) 0x0008)
+#define CSR_WIFI_NME_AUTH_MODE_8021X_WPA2      ((CsrWifiNmeAuthMode) 0x0010)
+#define CSR_WIFI_NME_AUTH_MODE_8021X_WPA2PSK   ((CsrWifiNmeAuthMode) 0x0020)
+#define CSR_WIFI_NME_AUTH_MODE_8021X_CCKM      ((CsrWifiNmeAuthMode) 0x0040)
+#define CSR_WIFI_NME_AUTH_MODE_WAPI_WAI        ((CsrWifiNmeAuthMode) 0x0080)
+#define CSR_WIFI_NME_AUTH_MODE_WAPI_WAIPSK     ((CsrWifiNmeAuthMode) 0x0100)
+#define CSR_WIFI_NME_AUTH_MODE_8021X_OTHER1X   ((CsrWifiNmeAuthMode) 0x0200)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeBssType
+
+  DESCRIPTION
+    Type of BSS
+
+ VALUES
+    CSR_WIFI_NME_BSS_TYPE_INFRASTRUCTURE
+                   - Infrastructure BSS type where access to the network is via
+                     one or several Access Points.
+    CSR_WIFI_NME_BSS_TYPE_ADHOC
+                   - Adhoc or Independent BSS Type where one Station acts as a
+                     host and future stations can join the adhoc network without
+                     needing an access point.
+    CSR_WIFI_NME_BSS_TYPE_RESERVED
+                   - To be in sync with SME.This is not used.
+    CSR_WIFI_NME_BSS_TYPE_P2P
+                   - P2P mode of operation.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiNmeBssType;
+#define CSR_WIFI_NME_BSS_TYPE_INFRASTRUCTURE   ((CsrWifiNmeBssType) 0x00)
+#define CSR_WIFI_NME_BSS_TYPE_ADHOC            ((CsrWifiNmeBssType) 0x01)
+#define CSR_WIFI_NME_BSS_TYPE_RESERVED         ((CsrWifiNmeBssType) 0x02)
+#define CSR_WIFI_NME_BSS_TYPE_P2P              ((CsrWifiNmeBssType) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeCcxOptionsMask
+
+  DESCRIPTION
+    Enumeration type defining possible mask values for setting CCX options.
+
+ VALUES
+    CSR_WIFI_NME_CCX_OPTION_NONE - No CCX option is set.
+    CSR_WIFI_NME_CCX_OPTION_CCKM - CCX option cckm is set.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiNmeCcxOptionsMask;
+#define CSR_WIFI_NME_CCX_OPTION_NONE   ((CsrWifiNmeCcxOptionsMask) 0x00)
+#define CSR_WIFI_NME_CCX_OPTION_CCKM   ((CsrWifiNmeCcxOptionsMask) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeConfigAction
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_PIN_ENTRY_PUSH_BUTTON -
+    CSR_WIFI_PIN_ENTRY_DISPLAY_PIN -
+    CSR_WIFI_PIN_ENTRY_ENTER_PIN   -
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiNmeConfigAction;
+#define CSR_WIFI_PIN_ENTRY_PUSH_BUTTON   ((CsrWifiNmeConfigAction) 0x00)
+#define CSR_WIFI_PIN_ENTRY_DISPLAY_PIN   ((CsrWifiNmeConfigAction) 0x01)
+#define CSR_WIFI_PIN_ENTRY_ENTER_PIN     ((CsrWifiNmeConfigAction) 0x02)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeConnectionStatus
+
+  DESCRIPTION
+    Indicate the NME Connection Status when connecting or when disconnecting
+
+ VALUES
+    CSR_WIFI_NME_CONNECTION_STATUS_CONNECTION_STATUS_DISCONNECTED
+                   - NME is disconnected.
+    CSR_WIFI_NME_CONNECTION_STATUS_CONNECTION_STATUS_CONNECTING
+                   - NME is in the process of connecting.
+    CSR_WIFI_NME_CONNECTION_STATUS_CONNECTION_STATUS_AUTHENTICATING
+                   - NME is in the authentication stage of a connection attempt.
+    CSR_WIFI_NME_CONNECTION_STATUS_CONNECTION_STATUS_CONNECTED
+                   - NME is connected.
+    CSR_WIFI_NME_CONNECTION_STATUS_CONNECTION_STATUS_DISCONNECTING
+                   - NME is in the process of disconnecting.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiNmeConnectionStatus;
+#define CSR_WIFI_NME_CONNECTION_STATUS_CONNECTION_STATUS_DISCONNECTED     ((CsrWifiNmeConnectionStatus) 0x00)
+#define CSR_WIFI_NME_CONNECTION_STATUS_CONNECTION_STATUS_CONNECTING       ((CsrWifiNmeConnectionStatus) 0x01)
+#define CSR_WIFI_NME_CONNECTION_STATUS_CONNECTION_STATUS_AUTHENTICATING   ((CsrWifiNmeConnectionStatus) 0x02)
+#define CSR_WIFI_NME_CONNECTION_STATUS_CONNECTION_STATUS_CONNECTED        ((CsrWifiNmeConnectionStatus) 0x03)
+#define CSR_WIFI_NME_CONNECTION_STATUS_CONNECTION_STATUS_DISCONNECTING    ((CsrWifiNmeConnectionStatus) 0x04)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeCredentialType
+
+  DESCRIPTION
+    NME Credential Types
+
+ VALUES
+    CSR_WIFI_NME_CREDENTIAL_TYPE_OPEN_SYSTEM
+                   - Credential Type Open System.
+    CSR_WIFI_NME_CREDENTIAL_TYPE_WEP64
+                   - Credential Type WEP-64
+    CSR_WIFI_NME_CREDENTIAL_TYPE_WEP128
+                   - Credential Type WEP-128
+    CSR_WIFI_NME_CREDENTIAL_TYPE_WPA_PSK
+                   - Credential Type WPA Pre-Shared Key
+    CSR_WIFI_NME_CREDENTIAL_TYPE_WPA_PASSPHRASE
+                   - Credential Type WPA pass phrase
+    CSR_WIFI_NME_CREDENTIAL_TYPE_WPA2_PSK
+                   - Credential Type WPA2 Pre-Shared Key.
+    CSR_WIFI_NME_CREDENTIAL_TYPE_WPA2_PASSPHRASE
+                   - Credential Type WPA2 pass phrase
+    CSR_WIFI_NME_CREDENTIAL_TYPE_WAPI_PSK
+                   - Credential Type WAPI Pre-Shared Key.
+    CSR_WIFI_NME_CREDENTIAL_TYPE_WAPI_PASSPHRASE
+                   - Credential Type WAPI pass phrase
+    CSR_WIFI_NME_CREDENTIAL_TYPE_WAPI
+                   - Credential Type WAPI certificates
+    CSR_WIFI_NME_CREDENTIAL_TYPE_8021X
+                   - Credential Type 802.1X: the associated type supports
+                     FAST/LEAP/TLS/TTLS/PEAP/etc.
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiNmeCredentialType;
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_OPEN_SYSTEM       ((CsrWifiNmeCredentialType) 0x0000)
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_WEP64             ((CsrWifiNmeCredentialType) 0x0001)
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_WEP128            ((CsrWifiNmeCredentialType) 0x0002)
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_WPA_PSK           ((CsrWifiNmeCredentialType) 0x0003)
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_WPA_PASSPHRASE    ((CsrWifiNmeCredentialType) 0x0004)
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_WPA2_PSK          ((CsrWifiNmeCredentialType) 0x0005)
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_WPA2_PASSPHRASE   ((CsrWifiNmeCredentialType) 0x0006)
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_WAPI_PSK          ((CsrWifiNmeCredentialType) 0x0007)
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_WAPI_PASSPHRASE   ((CsrWifiNmeCredentialType) 0x0008)
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_WAPI              ((CsrWifiNmeCredentialType) 0x0009)
+#define CSR_WIFI_NME_CREDENTIAL_TYPE_8021X             ((CsrWifiNmeCredentialType) 0x000A)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeEapMethod
+
+  DESCRIPTION
+    Outer EAP method with possibly inner method.
+
+ VALUES
+    CSR_WIFI_NME_EAP_METHOD_TLS
+                   - EAP-TLS Method.
+    CSR_WIFI_NME_EAP_METHOD_TTLS_MSCHAPV2
+                   - EAP-TTLS Method with MSCHAPV2.
+    CSR_WIFI_NME_EAP_METHOD_PEAP_GTC
+                   - EAP-PEAP Method with GTC.
+    CSR_WIFI_NME_EAP_METHOD_PEAP_MSCHAPV2
+                   - EAP-PEAP Method with MSCHAPV2.
+    CSR_WIFI_NME_EAP_METHOD_SIM
+                   - EAP-SIM Method.
+    CSR_WIFI_NME_EAP_METHOD_AKA
+                   - EAP-AKA Method.
+    CSR_WIFI_NME_EAP_METHOD_FAST_GTC
+                   - EAP-FAST Method with GTC.
+    CSR_WIFI_NME_EAP_METHOD_FAST_MSCHAPV2
+                   - EAP-FAST Method with MSCHAPV2.
+    CSR_WIFI_NME_EAP_METHOD_LEAP
+                   - EAP-LEAP Method.
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiNmeEapMethod;
+#define CSR_WIFI_NME_EAP_METHOD_TLS             ((CsrWifiNmeEapMethod) 0x0001)
+#define CSR_WIFI_NME_EAP_METHOD_TTLS_MSCHAPV2   ((CsrWifiNmeEapMethod) 0x0002)
+#define CSR_WIFI_NME_EAP_METHOD_PEAP_GTC        ((CsrWifiNmeEapMethod) 0x0004)
+#define CSR_WIFI_NME_EAP_METHOD_PEAP_MSCHAPV2   ((CsrWifiNmeEapMethod) 0x0008)
+#define CSR_WIFI_NME_EAP_METHOD_SIM             ((CsrWifiNmeEapMethod) 0x0010)
+#define CSR_WIFI_NME_EAP_METHOD_AKA             ((CsrWifiNmeEapMethod) 0x0020)
+#define CSR_WIFI_NME_EAP_METHOD_FAST_GTC        ((CsrWifiNmeEapMethod) 0x0040)
+#define CSR_WIFI_NME_EAP_METHOD_FAST_MSCHAPV2   ((CsrWifiNmeEapMethod) 0x0080)
+#define CSR_WIFI_NME_EAP_METHOD_LEAP            ((CsrWifiNmeEapMethod) 0x0100)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeEncryption
+
+  DESCRIPTION
+    WiFi Encryption method
+
+ VALUES
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_NONE
+                   - No encryprion set.
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_WEP40
+                   - 40 bytes WEP key for peer to peer communication.
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_WEP104
+                   - 104 bytes WEP key for peer to peer communication.
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_TKIP
+                   - TKIP key for peer to peer communication.
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_CCMP
+                   - CCMP key for peer to peer communication.
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_SMS4
+                   - SMS4 key for peer to peer communication.
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_WEP40
+                   - 40 bytes WEP key for broadcast messages.
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_WEP104
+                   - 104 bytes WEP key for broadcast messages.
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_TKIP
+                   - TKIP key for broadcast messages.
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_CCMP
+                   - CCMP key for broadcast messages
+    CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_SMS4
+                   - SMS4 key for broadcast messages.
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiNmeEncryption;
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_NONE              ((CsrWifiNmeEncryption) 0x0000)
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_WEP40    ((CsrWifiNmeEncryption) 0x0001)
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_WEP104   ((CsrWifiNmeEncryption) 0x0002)
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_TKIP     ((CsrWifiNmeEncryption) 0x0004)
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_CCMP     ((CsrWifiNmeEncryption) 0x0008)
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_SMS4     ((CsrWifiNmeEncryption) 0x0010)
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_WEP40       ((CsrWifiNmeEncryption) 0x0020)
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_WEP104      ((CsrWifiNmeEncryption) 0x0040)
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_TKIP        ((CsrWifiNmeEncryption) 0x0080)
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_CCMP        ((CsrWifiNmeEncryption) 0x0100)
+#define CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_SMS4        ((CsrWifiNmeEncryption) 0x0200)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeIndications
+
+  DESCRIPTION
+    NME indications
+
+ VALUES
+    CSR_WIFI_NME_INDICATIONS_IND_AP_STATION
+                   - NME AP Station Indication.
+    CSR_WIFI_NME_INDICATIONS_IND_AP_STOP
+                   - NME AP Stop Indication.
+    CSR_WIFI_NME_INDICATIONS_IND_SIM_UMTS_AUTH
+                   - NME UMTS Authentication Indication.
+    CSR_WIFI_NME_INDICATIONS_IND_P2P_GROUP_START
+                   - NME P2P Group Start Indication.
+    CSR_WIFI_NME_INDICATIONS_IND_P2P_GROUP_STATUS
+                   - NME P2P Group Status Indication.
+    CSR_WIFI_NME_INDICATIONS_IND_P2P_GROUP_ROLE
+                   - NME P2P Group Role Indication.
+    CSR_WIFI_NME_INDICATIONS_IND_PROFILE_DISCONNECT
+                   - NME Profile Disconnect Indication.
+    CSR_WIFI_NME_INDICATIONS_IND_PROFILE_UPDATE
+                   - NME Profile Update Indication.
+    CSR_WIFI_NME_INDICATIONS_IND_SIM_IMSI_GET
+                   - NME GET IMSI Indication.
+    CSR_WIFI_NME_INDICATIONS_IND_SIM_GSM_AUTH
+                   - NME GSM Authentication Indication.
+    CSR_WIFI_NME_INDICATIONS_ALL
+                   - Used to register for all available indications
+
+*******************************************************************************/
+typedef CsrUint32 CsrWifiNmeIndications;
+#define CSR_WIFI_NME_INDICATIONS_IND_AP_STATION           ((CsrWifiNmeIndications) 0x00100000)
+#define CSR_WIFI_NME_INDICATIONS_IND_AP_STOP              ((CsrWifiNmeIndications) 0x00200000)
+#define CSR_WIFI_NME_INDICATIONS_IND_SIM_UMTS_AUTH        ((CsrWifiNmeIndications) 0x01000000)
+#define CSR_WIFI_NME_INDICATIONS_IND_P2P_GROUP_START      ((CsrWifiNmeIndications) 0x02000000)
+#define CSR_WIFI_NME_INDICATIONS_IND_P2P_GROUP_STATUS     ((CsrWifiNmeIndications) 0x04000000)
+#define CSR_WIFI_NME_INDICATIONS_IND_P2P_GROUP_ROLE       ((CsrWifiNmeIndications) 0x08000000)
+#define CSR_WIFI_NME_INDICATIONS_IND_PROFILE_DISCONNECT   ((CsrWifiNmeIndications) 0x10000000)
+#define CSR_WIFI_NME_INDICATIONS_IND_PROFILE_UPDATE       ((CsrWifiNmeIndications) 0x20000000)
+#define CSR_WIFI_NME_INDICATIONS_IND_SIM_IMSI_GET         ((CsrWifiNmeIndications) 0x40000000)
+#define CSR_WIFI_NME_INDICATIONS_IND_SIM_GSM_AUTH         ((CsrWifiNmeIndications) 0x80000000)
+#define CSR_WIFI_NME_INDICATIONS_ALL                      ((CsrWifiNmeIndications) 0xFFFFFFFF)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSecError
+
+  DESCRIPTION
+    NME Security Errors
+    place holder for the security library abort reason
+
+ VALUES
+    CSR_WIFI_NME_SEC_ERROR_SEC_ERROR_UNKNOWN
+                   - Unknown Security Error.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiNmeSecError;
+#define CSR_WIFI_NME_SEC_ERROR_SEC_ERROR_UNKNOWN   ((CsrWifiNmeSecError) 0x00)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimCardType
+
+  DESCRIPTION
+    (U)SIM Card (or UICC) types
+
+ VALUES
+    CSR_WIFI_NME_SIM_CARD_TYPE_2G   - 2G SIM card, capable of performing GSM
+                                      authentication only.
+    CSR_WIFI_NME_SIM_CARD_TYPE_3G   - UICC supporting USIM application, capable
+                                      of performing UMTS authentication only.
+    CSR_WIFI_NME_SIM_CARD_TYPE_2G3G - UICC supporting both USIM and SIM
+                                      applications, capable of performing both
+                                      UMTS and GSM authentications.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiNmeSimCardType;
+#define CSR_WIFI_NME_SIM_CARD_TYPE_2G     ((CsrWifiNmeSimCardType) 0x01)
+#define CSR_WIFI_NME_SIM_CARD_TYPE_3G     ((CsrWifiNmeSimCardType) 0x02)
+#define CSR_WIFI_NME_SIM_CARD_TYPE_2G3G   ((CsrWifiNmeSimCardType) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeUmtsAuthResult
+
+  DESCRIPTION
+    Only relevant for UMTS Authentication. It indicates if the UICC has
+    successfully authenticated the network or otherwise.
+
+ VALUES
+    CSR_WIFI_NME_UMTS_AUTH_RESULT_SUCCESS
+                   - Successful outcome from USIM indicating that the card has
+                     successfully authenticated the network.
+    CSR_WIFI_NME_UMTS_AUTH_RESULT_SYNC_FAIL
+                   - Unsuccessful outcome from USIM indicating that the card is
+                     requesting the network to synchronise and re-try again. If
+                     no further request is received an NME timer will expire and
+                     the authentication is aborted.
+    CSR_WIFI_NME_UMTS_AUTH_RESULT_REJECT
+                   - Unsuccessful outcome from USIM indicating that the card has
+                     rejected the network and that the authentication is
+                     aborted.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiNmeUmtsAuthResult;
+#define CSR_WIFI_NME_UMTS_AUTH_RESULT_SUCCESS     ((CsrWifiNmeUmtsAuthResult) 0x00)
+#define CSR_WIFI_NME_UMTS_AUTH_RESULT_SYNC_FAIL   ((CsrWifiNmeUmtsAuthResult) 0x01)
+#define CSR_WIFI_NME_UMTS_AUTH_RESULT_REJECT      ((CsrWifiNmeUmtsAuthResult) 0x02)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWmmQosInfo
+
+  DESCRIPTION
+    Defines bits for the QoS Info octect as defined in the WMM specification.
+    The values of this type are used across the NME/SME/Router API's and they
+    must be kept consistent with the corresponding types in the .xml of the
+    other interfaces
+
+ VALUES
+    CSR_WIFI_NME_WMM_QOS_INFO_AC_MAX_SP_ALL
+                   - WMM AP may deliver all buffered frames.
+    CSR_WIFI_NME_WMM_QOS_INFO_AC_VO
+                   - To enable the triggering and delivery of QoS Voice.
+    CSR_WIFI_NME_WMM_QOS_INFO_AC_VI
+                   - To enable the triggering and delivery of QoS Video.
+    CSR_WIFI_NME_WMM_QOS_INFO_AC_BK
+                   - To enable the triggering and delivery of QoS Background.
+    CSR_WIFI_NME_WMM_QOS_INFO_AC_BE
+                   - To enable the triggering and delivery of QoS Best Effort.
+    CSR_WIFI_NME_WMM_QOS_INFO_AC_MAX_SP_TWO
+                   - WMM AP may deliver a maximum of 2 buffered frames per
+                     Unscheduled Service Period (USP).
+    CSR_WIFI_NME_WMM_QOS_INFO_AC_MAX_SP_FOUR
+                   - WMM AP may deliver a maximum of 4 buffered frames per USP.
+    CSR_WIFI_NME_WMM_QOS_INFO_AC_MAX_SP_SIX
+                   - WMM AP may deliver a maximum of 6 buffered frames per USP.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiNmeWmmQosInfo;
+#define CSR_WIFI_NME_WMM_QOS_INFO_AC_MAX_SP_ALL    ((CsrWifiNmeWmmQosInfo) 0x00)
+#define CSR_WIFI_NME_WMM_QOS_INFO_AC_VO            ((CsrWifiNmeWmmQosInfo) 0x01)
+#define CSR_WIFI_NME_WMM_QOS_INFO_AC_VI            ((CsrWifiNmeWmmQosInfo) 0x02)
+#define CSR_WIFI_NME_WMM_QOS_INFO_AC_BK            ((CsrWifiNmeWmmQosInfo) 0x04)
+#define CSR_WIFI_NME_WMM_QOS_INFO_AC_BE            ((CsrWifiNmeWmmQosInfo) 0x08)
+#define CSR_WIFI_NME_WMM_QOS_INFO_AC_MAX_SP_TWO    ((CsrWifiNmeWmmQosInfo) 0x20)
+#define CSR_WIFI_NME_WMM_QOS_INFO_AC_MAX_SP_FOUR   ((CsrWifiNmeWmmQosInfo) 0x40)
+#define CSR_WIFI_NME_WMM_QOS_INFO_AC_MAX_SP_SIX    ((CsrWifiNmeWmmQosInfo) 0x60)
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeEapMethodMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiNmeEapMethod.
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiNmeEapMethodMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeEncryptionMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiNmeEncryption
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiNmeEncryptionMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeIndicationsMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiNmeIndications
+
+*******************************************************************************/
+typedef CsrUint32 CsrWifiNmeIndicationsMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeNmeIndicationsMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiNmeNmeIndications.
+    Used to overlap the unused portion of the unifi_IndicationsMask For NME
+    specific indications
+
+*******************************************************************************/
+typedef CsrUint32 CsrWifiNmeNmeIndicationsMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWmmQosInfoMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiNmeWmmQosInfo
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiNmeWmmQosInfoMask;
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeEmpty
+
+  DESCRIPTION
+    Empty Structure to indicate that no credentials are available.
+
+  MEMBERS
+    empty  - Only element of the empty structure (always set to 0).
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8 empty;
+} CsrWifiNmeEmpty;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmePassphrase
+
+  DESCRIPTION
+    Structure holding the ASCII Pass Phrase data.
+
+  MEMBERS
+    encryptionMode - Encryption type as defined in CsrWifiSmeEncryption.
+    passphrase     - Pass phrase ASCII value.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint16      encryptionMode;
+    CsrCharString *passphrase;
+} CsrWifiNmePassphrase;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmePsk
+
+  DESCRIPTION
+    Structure holding the Pre-Shared Key data.
+
+  MEMBERS
+    encryptionMode - Encryption type as defined in CsrWifiSmeEncryption.
+    psk            - Pre-Shared Key value.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint16 encryptionMode;
+    CsrUint8  psk[32];
+} CsrWifiNmePsk;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWapiCredentials
+
+  DESCRIPTION
+    Structure holding WAPI credentials data.
+
+  MEMBERS
+    certificateLength   - Length in bytes of the following client certificate.
+    certificate         - The actual client certificate data (if present).
+                          DER/PEM format supported.
+    privateKeyLength    - Length in bytes of the following private key.
+    privateKey          - The actual private key. DER/PEM format.
+    caCertificateLength - Length in bytes of the following certificate authority
+                          certificate.
+    caCertificate       - The actual certificate authority certificate data. If
+                          not supplied the received certificate authority
+                          certificate is assumed to be validate, if present the
+                          received certificate is validated against it. DER/PEM
+                          format supported.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint32 certificateLength;
+    CsrUint8 *certificate;
+    CsrUint16 privateKeyLength;
+    CsrUint8 *privateKey;
+    CsrUint32 caCertificateLength;
+    CsrUint8 *caCertificate;
+} CsrWifiNmeWapiCredentials;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeConnectAttempt
+
+  DESCRIPTION
+    Structure holding Connection attempt data.
+
+  MEMBERS
+    bssid         - Id of Basic Service Set connections attempt have been made
+                    to.
+    status        - Status returned to indicate the success or otherwise of the
+                    connection attempt.
+    securityError - Security error status indicating the nature of the failure
+                    to connect.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiMacAddress  bssid;
+    CsrResult          status;
+    CsrWifiNmeSecError securityError;
+} CsrWifiNmeConnectAttempt;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeEapCredentials
+
+  DESCRIPTION
+    Supports the use of multiple EAP methods via a single structure. The
+    methods required are indicated by the value set in the eapMethodMask
+
+  MEMBERS
+    eapMethodMask
+                   - Bit mask of supported EAP methods
+                     Currently only supports the setting of one bit.
+                     Required for all the EAP methods.
+    authMode
+                   - Bit mask representing the authentication types that may be
+                     supported by a suitable AP. An AP must support at least one
+                     of the authentication types specified to be considered for
+                     connection. Required for all EAP methods.
+    encryptionMode
+                   - Bit mask representing the encryption types that may be
+                     supported by a suitable AP. An AP must support a suitable
+                     mix of the pairwise and group encryption types requested to
+                     be considered for connection. Required for all EAP methods.
+    userName
+                   - User name. Required for all EAP methods except: SIM or AKA.
+    userPassword
+                   - User Password. Required for all EAP methods except: TLS,
+                     SIM or AKA.
+    authServerUserIdentity
+                   - Authentication server user Identity. Required for all EAP
+                     methods except: TLS, SIM, AKA or FAST.
+    clientCertificateLength
+                   - Length in bytes of the following client certificate (if
+                     present). Only required for TLS.
+    clientCertificate
+                   - The actual client certificate data (if present). Only
+                     required for TLS. DER/PEM format supported.
+    certificateAuthorityCertificateLength
+                   - Length in bytes of the following certificate authority
+                     certificate (if present). Optional for TLS, TTLS, PEAP.
+    certificateAuthorityCertificate
+                   - The actual certificate authority certificate data (if
+                     present). If not supplied the received certificate
+                     authority certificate is assumed to be valid, if present
+                     the received certificate is validated against it. Optional
+                     for TLS, TTLS, PEAP. DER/PEM format supported.
+    privateKeyLength
+                   - Length in bytes of the following private key (if present).
+                     Only required for TLS.
+    privateKey
+                   - The actual private key (if present). Only required for TLS.
+                     DER/PEM format, maybe password protected.
+    privateKeyPassword
+                   - Optional password to protect the private key.
+    sessionLength
+                   - Length in bytes of the following session field Supported
+                     for all EAP methods except: SIM or AKA.
+    session
+                   - Session information to support faster re-authentication.
+                     Supported for all EAP methods except: SIM or AKA.
+    allowPacProvisioning
+                   - If TRUE: PAC provisioning is allowed 'over-the_air';
+                     If FALSE: a PAC must be supplied.
+                     Only required for FAST.
+    pacLength
+                   - Length the following PAC field. If allowPacProvisioning is
+                     FALSE then the PAC MUST be supplied (i.e. non-zero). Only
+                     required for FAST.
+    pac
+                   - The actual PAC data. If allowPacProvisioning is FALSE then
+                     the PAC MUST be supplied. Only required for FAST.
+    pacPassword
+                   - Optional password to protect the PAC. Only required for
+                     FAST.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiNmeEapMethodMask  eapMethodMask;
+    CsrWifiSmeAuthModeMask   authMode;
+    CsrWifiNmeEncryptionMask encryptionMode;
+    CsrCharString           *userName;
+    CsrCharString           *userPassword;
+    CsrCharString           *authServerUserIdentity;
+    CsrUint32                clientCertificateLength;
+    CsrUint8                *clientCertificate;
+    CsrUint32                certificateAuthorityCertificateLength;
+    CsrUint8                *certificateAuthorityCertificate;
+    CsrUint16                privateKeyLength;
+    CsrUint8                *privateKey;
+    CsrCharString           *privateKeyPassword;
+    CsrUint32                sessionLength;
+    CsrUint8                *session;
+    CsrBool                  allowPacProvisioning;
+    CsrUint32                pacLength;
+    CsrUint8                *pac;
+    CsrCharString           *pacPassword;
+} CsrWifiNmeEapCredentials;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmePeerConfig
+
+  DESCRIPTION
+    Structure holding Peer Config data.
+
+  MEMBERS
+    p2pDeviceId         -
+    groupCapabilityMask -
+    groupOwnerIntent    -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiMacAddress                p2pDeviceId;
+    CsrWifiSmeP2pGroupCapabilityMask groupCapabilityMask;
+    CsrUint8                         groupOwnerIntent;
+} CsrWifiNmePeerConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileIdentity
+
+  DESCRIPTION
+    The identity of a profile is defined as the unique combination the BSSID
+    and SSID.
+
+  MEMBERS
+    bssid  - ID of Basic Service Set for or the P2pDevice address of the GO for
+             which a connection attempt was made.
+    ssid   - Service Set Id.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiMacAddress bssid;
+    CsrWifiSsid       ssid;
+} CsrWifiNmeProfileIdentity;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWep128Keys
+
+  DESCRIPTION
+    Structure holding WEP Authentication Type and WEP keys that can be used
+    when using WEP128.
+
+  MEMBERS
+    wepAuthType    - Mask to select the WEP authentication type (Open or Shared)
+    selectedWepKey - Index to one of the four keys below indicating the
+                     currently used WEP key.
+    key1           - Value for key number 1.
+    key2           - Value for key number 2.
+    key3           - Value for key number 3.
+    key4           - Value for key number 4.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeAuthModeMask wepAuthType;
+    CsrUint8               selectedWepKey;
+    CsrUint8               key1[13];
+    CsrUint8               key2[13];
+    CsrUint8               key3[13];
+    CsrUint8               key4[13];
+} CsrWifiNmeWep128Keys;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWep64Keys
+
+  DESCRIPTION
+    Structure for holding WEP Authentication Type and WEP keys that can be
+    used when using WEP64.
+
+  MEMBERS
+    wepAuthType    - Mask to select the WEP authentication type (Open or Shared)
+    selectedWepKey - Index to one of the four keys below indicating the
+                     currently used WEP key.
+    key1           - Value for key number 1.
+    key2           - Value for key number 2.
+    key3           - Value for key number 3.
+    key4           - Value for key number 4.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeAuthModeMask wepAuthType;
+    CsrUint8               selectedWepKey;
+    CsrUint8               key1[5];
+    CsrUint8               key2[5];
+    CsrUint8               key3[5];
+    CsrUint8               key4[5];
+} CsrWifiNmeWep64Keys;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeCredentials
+
+  DESCRIPTION
+    Structure containing the Credentials data.
+
+  MEMBERS
+    credentialType            - Credential type value (as defined in the
+                                enumeration type).
+    credential                - Union containing credentials which depends on
+                                credentialType parameter.
+    credentialeap             -
+    credentialwapiPassphrase  -
+    credentialwpa2Passphrase  -
+    credentialwpa2Psk         -
+    credentialwapiPsk         -
+    credentialwpaPassphrase   -
+    credentialwapi            -
+    credentialwep128Key       -
+    credentialwpaPsk          -
+    credentialopenSystem      -
+    credentialwep64Key        -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiNmeCredentialType credentialType;
+    union {
+        CsrWifiNmeEapCredentials  eap;
+        CsrWifiNmePassphrase      wapiPassphrase;
+        CsrWifiNmePassphrase      wpa2Passphrase;
+        CsrWifiNmePsk             wpa2Psk;
+        CsrWifiNmePsk             wapiPsk;
+        CsrWifiNmePassphrase      wpaPassphrase;
+        CsrWifiNmeWapiCredentials wapi;
+        CsrWifiNmeWep128Keys      wep128Key;
+        CsrWifiNmePsk             wpaPsk;
+        CsrWifiNmeEmpty           openSystem;
+        CsrWifiNmeWep64Keys       wep64Key;
+    } credential;
+} CsrWifiNmeCredentials;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfile
+
+  DESCRIPTION
+    Structure containing the Profile data.
+
+  MEMBERS
+    profileIdentity - Profile Identity.
+    wmmQosInfoMask  - Mask for WMM QoS information.
+    bssType         - Type of BSS (Infrastructure or Adhoc).
+    channelNo       - Channel Number.
+    ccxOptionsMask  - Options mask for Cisco Compatible Extentions.
+    cloakedSsid     - Flag to decide whether the SSID is cloaked (not
+                      transmitted) or not.
+    credentials     - Credentials data.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiNmeProfileIdentity profileIdentity;
+    CsrWifiNmeWmmQosInfoMask  wmmQosInfoMask;
+    CsrWifiNmeBssType         bssType;
+    CsrUint8                  channelNo;
+    CsrUint8                  ccxOptionsMask;
+    CsrBool                   cloakedSsid;
+    CsrWifiNmeCredentials     credentials;
+} CsrWifiNmeProfile;
+
+
+/* Downstream */
+#define CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST            (0x0000)
+
+#define CSR_WIFI_NME_PROFILE_SET_REQ                      ((CsrWifiNmePrim) (0x0000 + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_PROFILE_DELETE_REQ                   ((CsrWifiNmePrim) (0x0001 + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_PROFILE_DELETE_ALL_REQ               ((CsrWifiNmePrim) (0x0002 + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_PROFILE_ORDER_SET_REQ                ((CsrWifiNmePrim) (0x0003 + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_PROFILE_CONNECT_REQ                  ((CsrWifiNmePrim) (0x0004 + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_WPS_REQ                              ((CsrWifiNmePrim) (0x0005 + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_WPS_CANCEL_REQ                       ((CsrWifiNmePrim) (0x0006 + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_CONNECTION_STATUS_GET_REQ            ((CsrWifiNmePrim) (0x0007 + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_SIM_IMSI_GET_RES                     ((CsrWifiNmePrim) (0x0008 + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_SIM_GSM_AUTH_RES                     ((CsrWifiNmePrim) (0x0009 + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_SIM_UMTS_AUTH_RES                    ((CsrWifiNmePrim) (0x000A + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_WPS_CONFIG_SET_REQ                   ((CsrWifiNmePrim) (0x000B + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_NME_EVENT_MASK_SET_REQ                   ((CsrWifiNmePrim) (0x000C + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST))
+
+
+#define CSR_WIFI_NME_PRIM_DOWNSTREAM_HIGHEST           (0x000C + CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST)
+
+/* Upstream */
+#define CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST              (0x0000 + CSR_PRIM_UPSTREAM)
+
+#define CSR_WIFI_NME_PROFILE_SET_CFM                      ((CsrWifiNmePrim)(0x0000 + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_PROFILE_DELETE_CFM                   ((CsrWifiNmePrim)(0x0001 + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_PROFILE_DELETE_ALL_CFM               ((CsrWifiNmePrim)(0x0002 + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_PROFILE_ORDER_SET_CFM                ((CsrWifiNmePrim)(0x0003 + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_PROFILE_CONNECT_CFM                  ((CsrWifiNmePrim)(0x0004 + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_WPS_CFM                              ((CsrWifiNmePrim)(0x0005 + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_WPS_CANCEL_CFM                       ((CsrWifiNmePrim)(0x0006 + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_CONNECTION_STATUS_GET_CFM            ((CsrWifiNmePrim)(0x0007 + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_PROFILE_UPDATE_IND                   ((CsrWifiNmePrim)(0x0008 + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_PROFILE_DISCONNECT_IND               ((CsrWifiNmePrim)(0x0009 + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_SIM_IMSI_GET_IND                     ((CsrWifiNmePrim)(0x000A + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_SIM_GSM_AUTH_IND                     ((CsrWifiNmePrim)(0x000B + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_SIM_UMTS_AUTH_IND                    ((CsrWifiNmePrim)(0x000C + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_WPS_CONFIG_SET_CFM                   ((CsrWifiNmePrim)(0x000D + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_NME_EVENT_MASK_SET_CFM                   ((CsrWifiNmePrim)(0x000E + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST))
+
+#define CSR_WIFI_NME_PRIM_UPSTREAM_HIGHEST             (0x000E + CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST)
+
+#define CSR_WIFI_NME_PRIM_DOWNSTREAM_COUNT             (CSR_WIFI_NME_PRIM_DOWNSTREAM_HIGHEST + 1 - CSR_WIFI_NME_PRIM_DOWNSTREAM_LOWEST)
+#define CSR_WIFI_NME_PRIM_UPSTREAM_COUNT               (CSR_WIFI_NME_PRIM_UPSTREAM_HIGHEST   + 1 - CSR_WIFI_NME_PRIM_UPSTREAM_LOWEST)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileSetReq
+
+  DESCRIPTION
+    Creates or updates an existing profile in the NME that matches the unique
+    identity of the profile. Each profile is identified by the combination of
+    BSSID and SSID. The profile contains all the required credentials for
+    attempting to connect to the network. Creating or updating a profile via
+    the NME PROFILE SET REQ does NOT add the profile to the preferred profile
+    list within the NME used for the NME auto-connect behaviour.
+
+  MEMBERS
+    common  - Common header for use with the CsrWifiFsm Module
+    profile - Specifies the identity and credentials of the network.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrWifiNmeProfile profile;
+} CsrWifiNmeProfileSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileDeleteReq
+
+  DESCRIPTION
+    Will delete the profile with a matching identity, but does NOT modify the
+    preferred profile list.
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    profileIdentity - Identity (BSSID, SSID) of profile to be deleted.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrWifiNmeProfileIdentity profileIdentity;
+} CsrWifiNmeProfileDeleteReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileDeleteAllReq
+
+  DESCRIPTION
+    Deletes all profiles present in the NME, but does NOT modify the
+    preferred profile list.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiNmeProfileDeleteAllReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileOrderSetReq
+
+  DESCRIPTION
+    Defines the preferred order that profiles present in the NME should be
+    used during the NME auto-connect behaviour.
+    If profileIdentitysCount == 0, it removes any existing preferred profile
+    list already present in the NME, effectively disabling the auto-connect
+    behaviour.
+    NOTE: Profile identities that do not match any profile stored in the NME
+    are ignored during the auto-connect procedure.
+    NOTE: during auto-connect the NME will only attempt to join an existing
+    adhoc network and it will never attempt to host an adhoc network; for
+    hosting and adhoc network, use CSR_WIFI_NME_PROFILE_CONNECT_REQ
+
+  MEMBERS
+    common                - Common header for use with the CsrWifiFsm Module
+    interfaceTag          - Interface Identifier; unique identifier of an
+                            interface
+    profileIdentitysCount - The number of profiles identities in the list.
+    profileIdentitys      - Points to the list of profile identities.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent            common;
+    CsrUint16                  interfaceTag;
+    CsrUint8                   profileIdentitysCount;
+    CsrWifiNmeProfileIdentity *profileIdentitys;
+} CsrWifiNmeProfileOrderSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileConnectReq
+
+  DESCRIPTION
+    Requests the NME to attempt to connect to the specified profile.
+    Overrides any current connection attempt.
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    profileIdentity - Identity (BSSID, SSID) of profile to be connected to.
+                      It must match an existing profile in the NME.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrWifiNmeProfileIdentity profileIdentity;
+} CsrWifiNmeProfileConnectReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsReq
+
+  DESCRIPTION
+    Requests the NME to look for WPS enabled APs and attempt to perform WPS
+    to determine the appropriate security credentials to connect to the AP.
+    If the PIN == '00000000' then 'push button mode' is indicated, otherwise
+    the PIN has to match that of the AP. 4 digit pin is passed by sending the
+    pin digits in pin[0]..pin[3] and rest of the contents filled with '-'.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    pin          - PIN value.
+    ssid         - Service Set identifier
+    bssid        - ID of Basic Service Set for which a WPS connection attempt is
+                   being made.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrUint16         interfaceTag;
+    CsrUint8          pin[8];
+    CsrWifiSsid       ssid;
+    CsrWifiMacAddress bssid;
+} CsrWifiNmeWpsReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsCancelReq
+
+  DESCRIPTION
+    Requests the NME to cancel any WPS procedure that it is currently
+    performing. This includes WPS registrar activities started because of
+    CSR_WIFI_NME_AP_REGISTER.request
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiNmeWpsCancelReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeConnectionStatusGetReq
+
+  DESCRIPTION
+    Requests the current connection status of the NME.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiNmeConnectionStatusGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimImsiGetRes
+
+  DESCRIPTION
+    Response from the application that received the NME SIM IMSI GET IND.
+
+  MEMBERS
+    common   - Common header for use with the CsrWifiFsm Module
+    status   - Indicates the outcome of the requested operation: STATUS_SUCCESS
+               or STATUS_ERROR.
+    imsi     - The value of the IMSI obtained from the UICC.
+    cardType - The UICC type (GSM only (SIM), UMTS only (USIM), Both).
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrResult             status;
+    CsrCharString        *imsi;
+    CsrWifiNmeSimCardType cardType;
+} CsrWifiNmeSimImsiGetRes;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimGsmAuthRes
+
+  DESCRIPTION
+    Response from the application that received the NME SIM GSM AUTH IND. For
+    each GSM authentication round a GSM Ciphering key (Kc) and a signed
+    response (SRES) are produced. Since 2 or 3 GSM authentication rounds are
+    used the 2 or 3 Kc's obtained respectively are combined into one buffer
+    and similarly the 2 or 3 SRES's obtained are combined into another
+    buffer. The order of Kc values (SRES values respectively) in their buffer
+    is the same as that of their corresponding RAND values in the incoming
+    indication.
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    status     - Indicates the outcome of the requested operation:
+                 STATUS_SUCCESS or STATUS_ERROR
+    kcsLength  - Length in Bytes of Kc buffer. Legal values are: 16 or 24.
+    kcs        - Kc buffer holding 2 or 3 Kc values.
+    sresLength - Length in Bytes of SRES buffer. Legal values are: 8 or 12.
+    sres       - SRES buffer holding 2 or 3 SRES values.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+    CsrUint8        kcsLength;
+    CsrUint8       *kcs;
+    CsrUint8        sresLength;
+    CsrUint8       *sres;
+} CsrWifiNmeSimGsmAuthRes;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimUmtsAuthRes
+
+  DESCRIPTION
+    Response from the application that received the NME SIM UMTS AUTH IND.
+    The values of umtsCipherKey, umtsIntegrityKey, resParameterLength and
+    resParameter are only meanigful when result = UMTS_AUTH_RESULT_SUCCESS.
+    The value of auts is only meaningful when
+    result=UMTS_AUTH_RESULT_SYNC_FAIL.
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    status             - Indicates the outcome of the requested operation:
+                         STATUS_SUCCESS or STATUS_ERROR.
+    result             - The result of UMTS authentication as performed by the
+                         UICC which could be: Success, Authentication Reject or
+                         Synchronisation Failure. For all these 3 outcomes the
+                         value of status is success.
+    umtsCipherKey      - The UMTS Cipher Key as calculated and returned by the
+                         UICC.
+    umtsIntegrityKey   - The UMTS Integrity Key as calculated and returned by
+                         the UICC.
+    resParameterLength - The length (in bytes) of the RES parameter (min=4; max
+                         = 16).
+    resParameter       - The RES parameter as calculated and returned by the
+                         UICC.
+    auts               - The AUTS parameter as calculated and returned by the
+                         UICC.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent          common;
+    CsrResult                status;
+    CsrWifiNmeUmtsAuthResult result;
+    CsrUint8                 umtsCipherKey[16];
+    CsrUint8                 umtsIntegrityKey[16];
+    CsrUint8                 resParameterLength;
+    CsrUint8                *resParameter;
+    CsrUint8                 auts[14];
+} CsrWifiNmeSimUmtsAuthRes;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsConfigSetReq
+
+  DESCRIPTION
+    This primitive passes the WPS information for the device to NME. This may
+    be accepted only if no interface is active.
+
+  MEMBERS
+    common    - Common header for use with the CsrWifiFsm Module
+    wpsConfig - WPS config.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent     common;
+    CsrWifiSmeWpsConfig wpsConfig;
+} CsrWifiNmeWpsConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeEventMaskSetReq
+
+  DESCRIPTION
+    The wireless manager application may register with the NME to receive
+    notification of interesting events. Indications will be sent only if the
+    wireless manager explicitly registers to be notified of that event.
+    indMask is a bit mask of values defined in CsrWifiNmeIndicationsMask.
+
+  MEMBERS
+    common  - Common header for use with the CsrWifiFsm Module
+    indMask - Set mask with values from CsrWifiNmeIndications
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrWifiNmeIndicationsMask indMask;
+} CsrWifiNmeEventMaskSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileSetCfm
+
+  DESCRIPTION
+    Reports the status of the NME PROFILE SET REQ; the request will only fail
+    if the details specified in the profile contains an invalid combination
+    of parameters for example specifying the profile as cloaked but not
+    specifying the SSID. The NME doesn't limit the number of profiles that
+    may be created. The NME assumes that the entity configuring it is aware
+    of the appropriate limits.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Indicates the success or otherwise of the requested operation.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiNmeProfileSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileDeleteCfm
+
+  DESCRIPTION
+    Reports the status of the CSR_WIFI_NME_PROFILE_DELETE_REQ.
+    Returns CSR_WIFI_NME_STATUS_NOT_FOUND if there is no matching profile.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Indicates the success or otherwise of the requested operation.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiNmeProfileDeleteCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileDeleteAllCfm
+
+  DESCRIPTION
+    Reports the status of the CSR_WIFI_NME_PROFILE_DELETE_ALL_REQ.
+    Returns always CSR_WIFI_NME_STATUS_SUCCESS.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Indicates the success or otherwise of the requested operation, but
+             in this case it always set to success.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiNmeProfileDeleteAllCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileOrderSetCfm
+
+  DESCRIPTION
+    Confirmation to UNIFI_NME_PROFILE_ORDER_SET.request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Indicates the success or otherwise of the requested
+                   operation.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiNmeProfileOrderSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileConnectCfm
+
+  DESCRIPTION
+    Reports the status of the NME PROFILE CONNECT REQ. If unsuccessful the
+    connectAttempt parameters contain details of the APs that the NME
+    attempted to connect to before reporting the failure of the request.
+
+  MEMBERS
+    common               - Common header for use with the CsrWifiFsm Module
+    interfaceTag         - Interface Identifier; unique identifier of an
+                           interface
+    status               - Indicates the success or otherwise of the requested
+                           operation.
+    connectAttemptsCount - This parameter is relevant only if
+                           status!=CSR_WIFI_NME_STATUS_SUCCESS.
+                           Number of connection attempt elements provided with
+                           this primitive
+    connectAttempts      - This parameter is relevant only if
+                           status!=CSR_WIFI_NME_STATUS_SUCCESS.
+                           Points to the list of connection attempt elements
+                           provided with this primitive
+                           Each element of the list provides information about
+                           an AP on which the connection attempt was made and
+                           the error that occurred during the attempt.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrResult                 status;
+    CsrUint8                  connectAttemptsCount;
+    CsrWifiNmeConnectAttempt *connectAttempts;
+} CsrWifiNmeProfileConnectCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsCfm
+
+  DESCRIPTION
+    Reports the status of the NME WPS REQ.
+    If CSR_WIFI_NME_STATUS_SUCCESS, the profile parameter contains the
+    identity and credentials of the AP.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Indicates the success or otherwise of the requested
+                   operation.
+    profile      - This parameter is relevant only if
+                   status==CSR_WIFI_NME_STATUS_SUCCESS.
+                   The identity and credentials of the network.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrUint16         interfaceTag;
+    CsrResult         status;
+    CsrWifiNmeProfile profile;
+} CsrWifiNmeWpsCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsCancelCfm
+
+  DESCRIPTION
+    Reports the status of the NME WPS REQ, the request is always SUCCESSFUL.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Only returns CSR_WIFI_NME_STATUS_SUCCESS
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiNmeWpsCancelCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeConnectionStatusGetCfm
+
+  DESCRIPTION
+    Reports the connection status of the NME.
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    interfaceTag     - Interface Identifier; unique identifier of an interface
+    status           - Indicates the success or otherwise of the requested
+                       operation.
+    connectionStatus - NME current connection status
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent            common;
+    CsrUint16                  interfaceTag;
+    CsrResult                  status;
+    CsrWifiNmeConnectionStatus connectionStatus;
+} CsrWifiNmeConnectionStatusGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileUpdateInd
+
+  DESCRIPTION
+    Indication generated from the NME (if an application subscribes to
+    receive it) that informs that application that the contained profile has
+    changed.
+    For example, either the credentials EAP-FAST PAC file or the session data
+    within the profile has changed.
+    It is up to the application whether it stores this updated profile or
+    not.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    profile      - The identity and credentials of the network.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrUint16         interfaceTag;
+    CsrWifiNmeProfile profile;
+} CsrWifiNmeProfileUpdateInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeProfileDisconnectInd
+
+  DESCRIPTION
+    Indication generated from the NME (if an application subscribes to
+    receive it) that informs that application that the current profile
+    connection has disconnected. The indication will contain information
+    about APs that it attempted to maintain the connection via i.e. in the
+    case of failed roaming.
+
+  MEMBERS
+    common               - Common header for use with the CsrWifiFsm Module
+    interfaceTag         - Interface Identifier; unique identifier of an
+                           interface
+    connectAttemptsCount - Number of connection attempt elements provided with
+                           this primitive
+    connectAttempts      - Points to the list of connection attempt elements
+                           provided with this primitive
+                           Each element of the list provides information about
+                           an AP on which the connection attempt was made and
+                           the error occurred during the attempt.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrUint8                  connectAttemptsCount;
+    CsrWifiNmeConnectAttempt *connectAttempts;
+} CsrWifiNmeProfileDisconnectInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimImsiGetInd
+
+  DESCRIPTION
+    Indication generated from the NME (if an application subscribes to
+    receive it) that requests the IMSI and UICC type from the UICC Manager.
+    This indication is generated when the NME is attempting to connect to a
+    profile configured for EAP-SIM/AKA. An application MUST register to
+    receive this indication for the NME to support the EAP-SIM/AKA credential
+    types. Otherwise the NME has no route to obtain the information from the
+    UICC.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiNmeSimImsiGetInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimGsmAuthInd
+
+  DESCRIPTION
+    Indication generated from the NME (if an application subscribes to
+    receive it) that requests the UICC Manager to perform a GSM
+    authentication on behalf of the NME. This indication is generated when
+    the NME is attempting to connect to a profile configured for EAP-SIM. An
+    application MUST register to receive this indication for the NME to
+    support the EAP-SIM credential types. Otherwise the NME has no route to
+    obtain the information from the UICC. EAP-SIM authentication requires 2
+    or 3 GSM authentication rounds and therefore 2 or 3 RANDS (GSM Random
+    Challenges) are included.
+
+  MEMBERS
+    common      - Common header for use with the CsrWifiFsm Module
+    randsLength - GSM RAND is 16 bytes long hence valid values are 32 (2 RANDS)
+                  or 48 (3 RANDs).
+    rands       - 2 or 3 RANDs values.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint8        randsLength;
+    CsrUint8       *rands;
+} CsrWifiNmeSimGsmAuthInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeSimUmtsAuthInd
+
+  DESCRIPTION
+    Indication generated from the NME (if an application subscribes to
+    receive it) that requests the UICC Manager to perform a UMTS
+    authentication on behalf of the NME. This indication is generated when
+    the NME is attempting to connect to a profile configured for EAP-AKA. An
+    application MUST register to receive this indication for the NME to
+    support the EAP-AKA credential types. Otherwise the NME has no route to
+    obtain the information from the USIM. EAP-AKA requires one UMTS
+    authentication round and therefore only one RAND and one AUTN values are
+    included.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    rand   - UMTS RAND value.
+    autn   - UMTS AUTN value.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint8        rand[16];
+    CsrUint8        autn[16];
+} CsrWifiNmeSimUmtsAuthInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeWpsConfigSetCfm
+
+  DESCRIPTION
+    Confirm.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Status of the request.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiNmeWpsConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiNmeEventMaskSetCfm
+
+  DESCRIPTION
+    The NME calls the primitive to report the result of the request
+    primitive.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiNmeEventMaskSetCfm;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_NME_PRIM_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_serialize.h
@@ -0,0 +1,177 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_NME_SERIALIZE_H__
+#define CSR_WIFI_NME_SERIALIZE_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_wifi_msgconv.h"
+
+#include "csr_wifi_nme_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_NME_ENABLE
+#error CSR_WIFI_NME_ENABLE MUST be defined inorder to use csr_wifi_nme_serialize.h
+#endif
+
+extern void CsrWifiNmePfree(void *ptr);
+
+extern CsrUint8* CsrWifiNmeProfileSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeProfileSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeProfileSetReqSizeof(void *msg);
+extern void CsrWifiNmeProfileSetReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiNmeProfileDeleteReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeProfileDeleteReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeProfileDeleteReqSizeof(void *msg);
+#define CsrWifiNmeProfileDeleteReqSerFree CsrWifiNmePfree
+
+#define CsrWifiNmeProfileDeleteAllReqSer CsrWifiEventSer
+#define CsrWifiNmeProfileDeleteAllReqDes CsrWifiEventDes
+#define CsrWifiNmeProfileDeleteAllReqSizeof CsrWifiEventSizeof
+#define CsrWifiNmeProfileDeleteAllReqSerFree CsrWifiNmePfree
+
+extern CsrUint8* CsrWifiNmeProfileOrderSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeProfileOrderSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeProfileOrderSetReqSizeof(void *msg);
+extern void CsrWifiNmeProfileOrderSetReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiNmeProfileConnectReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeProfileConnectReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeProfileConnectReqSizeof(void *msg);
+#define CsrWifiNmeProfileConnectReqSerFree CsrWifiNmePfree
+
+extern CsrUint8* CsrWifiNmeWpsReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeWpsReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeWpsReqSizeof(void *msg);
+#define CsrWifiNmeWpsReqSerFree CsrWifiNmePfree
+
+#define CsrWifiNmeWpsCancelReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiNmeWpsCancelReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiNmeWpsCancelReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiNmeWpsCancelReqSerFree CsrWifiNmePfree
+
+#define CsrWifiNmeConnectionStatusGetReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiNmeConnectionStatusGetReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiNmeConnectionStatusGetReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiNmeConnectionStatusGetReqSerFree CsrWifiNmePfree
+
+extern CsrUint8* CsrWifiNmeSimImsiGetResSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeSimImsiGetResDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeSimImsiGetResSizeof(void *msg);
+extern void CsrWifiNmeSimImsiGetResSerFree(void *msg);
+
+extern CsrUint8* CsrWifiNmeSimGsmAuthResSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeSimGsmAuthResDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeSimGsmAuthResSizeof(void *msg);
+extern void CsrWifiNmeSimGsmAuthResSerFree(void *msg);
+
+extern CsrUint8* CsrWifiNmeSimUmtsAuthResSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeSimUmtsAuthResDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeSimUmtsAuthResSizeof(void *msg);
+extern void CsrWifiNmeSimUmtsAuthResSerFree(void *msg);
+
+extern CsrUint8* CsrWifiNmeWpsConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeWpsConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeWpsConfigSetReqSizeof(void *msg);
+extern void CsrWifiNmeWpsConfigSetReqSerFree(void *msg);
+
+#define CsrWifiNmeEventMaskSetReqSer CsrWifiEventCsrUint32Ser
+#define CsrWifiNmeEventMaskSetReqDes CsrWifiEventCsrUint32Des
+#define CsrWifiNmeEventMaskSetReqSizeof CsrWifiEventCsrUint32Sizeof
+#define CsrWifiNmeEventMaskSetReqSerFree CsrWifiNmePfree
+
+#define CsrWifiNmeProfileSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiNmeProfileSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiNmeProfileSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiNmeProfileSetCfmSerFree CsrWifiNmePfree
+
+#define CsrWifiNmeProfileDeleteCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiNmeProfileDeleteCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiNmeProfileDeleteCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiNmeProfileDeleteCfmSerFree CsrWifiNmePfree
+
+#define CsrWifiNmeProfileDeleteAllCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiNmeProfileDeleteAllCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiNmeProfileDeleteAllCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiNmeProfileDeleteAllCfmSerFree CsrWifiNmePfree
+
+extern CsrUint8* CsrWifiNmeProfileOrderSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeProfileOrderSetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeProfileOrderSetCfmSizeof(void *msg);
+#define CsrWifiNmeProfileOrderSetCfmSerFree CsrWifiNmePfree
+
+extern CsrUint8* CsrWifiNmeProfileConnectCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeProfileConnectCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeProfileConnectCfmSizeof(void *msg);
+extern void CsrWifiNmeProfileConnectCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiNmeWpsCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeWpsCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeWpsCfmSizeof(void *msg);
+extern void CsrWifiNmeWpsCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiNmeWpsCancelCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeWpsCancelCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeWpsCancelCfmSizeof(void *msg);
+#define CsrWifiNmeWpsCancelCfmSerFree CsrWifiNmePfree
+
+extern CsrUint8* CsrWifiNmeConnectionStatusGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeConnectionStatusGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeConnectionStatusGetCfmSizeof(void *msg);
+#define CsrWifiNmeConnectionStatusGetCfmSerFree CsrWifiNmePfree
+
+extern CsrUint8* CsrWifiNmeProfileUpdateIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeProfileUpdateIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeProfileUpdateIndSizeof(void *msg);
+extern void CsrWifiNmeProfileUpdateIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiNmeProfileDisconnectIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeProfileDisconnectIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeProfileDisconnectIndSizeof(void *msg);
+extern void CsrWifiNmeProfileDisconnectIndSerFree(void *msg);
+
+#define CsrWifiNmeSimImsiGetIndSer CsrWifiEventSer
+#define CsrWifiNmeSimImsiGetIndDes CsrWifiEventDes
+#define CsrWifiNmeSimImsiGetIndSizeof CsrWifiEventSizeof
+#define CsrWifiNmeSimImsiGetIndSerFree CsrWifiNmePfree
+
+extern CsrUint8* CsrWifiNmeSimGsmAuthIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeSimGsmAuthIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeSimGsmAuthIndSizeof(void *msg);
+extern void CsrWifiNmeSimGsmAuthIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiNmeSimUmtsAuthIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiNmeSimUmtsAuthIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiNmeSimUmtsAuthIndSizeof(void *msg);
+#define CsrWifiNmeSimUmtsAuthIndSerFree CsrWifiNmePfree
+
+#define CsrWifiNmeWpsConfigSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiNmeWpsConfigSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiNmeWpsConfigSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiNmeWpsConfigSetCfmSerFree CsrWifiNmePfree
+
+#define CsrWifiNmeEventMaskSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiNmeEventMaskSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiNmeEventMaskSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiNmeEventMaskSetCfmSerFree CsrWifiNmePfree
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* CSR_WIFI_NME_SERIALIZE_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_nme_task.h
@@ -0,0 +1,38 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_NME_TASK_H__
+#define CSR_WIFI_NME_TASK_H__
+
+#include "csr_types.h"
+#include "csr_sched.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_NME_ENABLE
+#error CSR_WIFI_NME_ENABLE MUST be defined inorder to use csr_wifi_nme_task.h
+#endif
+
+#define CSR_WIFI_NME_LOG_ID 0x1203FFFF
+extern CsrSchedQid CSR_WIFI_NME_IFACEQUEUE;
+void CsrWifiNmeInit(void **gash);
+void CsrWifiNmeDeinit(void **gash);
+void CsrWifiNmeHandler(void **gash);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_NME_TASK_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_private_common.h
@@ -0,0 +1,91 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifndef CSR_WIFI_PRIVATE_COMMON_H__
+#define CSR_WIFI_PRIVATE_COMMON_H__
+
+#include "csr_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief maximum number of STAs allowed to be connected
+ *
+ * @par Description
+ *   min & max Beacon Interval
+ */
+#define CSR_WIFI_AP_MAX_ASSOC_STA   8
+
+/** Number of only b rates */
+#define CSR_WIFI_SME_AP_MAX_ONLY_B_RATES        4
+
+
+/** Number of mandatory b rates */
+#define CSR_WIFI_SME_AP_MAX_MANDATORY_B_RATES   2
+
+
+/** Number of mandatory bg rates */
+#define CSR_WIFI_SME_AP_MAX_MANDATORY_BG_RATES  4
+
+
+/** Number of bg rates */
+#define CSR_WIFI_SME_AP_MAX_BG_RATES            12
+
+
+/** Number of no b only g rates */
+#define CSR_WIFI_SME_AP_MAX_NO_B_ONLY_G_RATES   8
+
+
+/** Number of mandatory g rates */
+#define CSR_WIFI_SME_AP_MAX_MANDATORY_G_RATES   7
+
+
+/* Number of g mandatory rates */
+#define CSR_WIFI_SME_AP_G_MANDATORY_RATES_NUM   7
+
+
+/* Number of b mandatory rates */
+#define CSR_WIFI_SME_AP_B_MANDATORY_RATES_NUM   2
+
+
+/* Number of b/g mandatory rates */
+#define CSR_WIFI_SME_AP_BG_MANDATORY_RATES_NUM   4
+
+
+/* The maximum allowed length of SSID */
+#define CSR_WIFI_SME_AP_SSID_MAX_LENGTH         32
+
+/* Refer 8.4.2.27 RSN element - we support TKIP, WPA2, WAPI and PSK only, no pmkid, group cipher suite */
+#define CSR_WIFI_SME_RSN_PACKED_SIZE (1 + 1 + 2 + 4 + 2 + 4 * 2 + 2 + 4 * 1 + 2 + 24)
+
+/* Refer 7.3.2.9 (ISO/IEC 8802-11:2006) WAPI element - we support WAPI PSK only, no bkid, group cipher suite */
+#define CSR_WIFI_SME_WAPI_PACKED_SIZE (1 + 1 + 2 + 2 + 4 * 1 + 2 + 4 * 1 + 4 + 2 + 24)
+
+
+/* Common structure for NME and SME to maintain Interface mode*/
+typedef CsrUint8 CsrWifiInterfaceMode;
+#define  CSR_WIFI_MODE_NONE                             ((CsrWifiInterfaceMode) 0xFF)
+#define  CSR_WIFI_MODE_STA                              ((CsrWifiInterfaceMode) 0x00)
+#define  CSR_WIFI_MODE_AP                               ((CsrWifiInterfaceMode) 0x01)
+#define  CSR_WIFI_MODE_P2P_DEVICE                       ((CsrWifiInterfaceMode) 0x02)
+#define  CSR_WIFI_MODE_P2P_CLI                          ((CsrWifiInterfaceMode) 0x03)
+#define  CSR_WIFI_MODE_P2P_GO                           ((CsrWifiInterfaceMode) 0x04)
+#define  CSR_WIFI_MODE_AMP                              ((CsrWifiInterfaceMode) 0x05)
+#define  CSR_WIFI_MODE_WPS_ENROLLEE                     ((CsrWifiInterfaceMode) 0x06)
+#define  CSR_WIFI_MODE_IBSS                             ((CsrWifiInterfaceMode) 0x07)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_result.h
@@ -0,0 +1,36 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifndef CSR_WIFI_RESULT_H__
+#define CSR_WIFI_RESULT_H__
+
+#include "csr_types.h"
+#include "csr_result.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* THIS FILE SHOULD CONTAIN ONLY RESULT CODES */
+
+/* Result Codes */
+#define CSR_WIFI_HIP_RESULT_INVALID_VALUE    ((CsrResult) 1) /* Invalid argument value */
+#define CSR_WIFI_HIP_RESULT_NO_DEVICE        ((CsrResult) 2) /* The specified device is no longer present */
+#define CSR_WIFI_HIP_RESULT_NO_SPACE         ((CsrResult) 3) /* A queue or buffer is full */
+#define CSR_WIFI_HIP_RESULT_NO_MEMORY        ((CsrResult) 4) /* Fatal error, no memory */
+#define CSR_WIFI_HIP_RESULT_RANGE            ((CsrResult) 5) /* Request exceeds the range of a file or a buffer */
+#define CSR_WIFI_HIP_RESULT_NOT_FOUND        ((CsrResult) 6) /* A file (typically a f/w patch) is not found */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_RESULT_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_converter_init.c
@@ -0,0 +1,83 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_msgconv.h"
+#include "csr_pmem.h"
+#include "csr_util.h"
+
+
+#ifdef CSR_LOG_ENABLE
+#include "csr_log.h"
+#endif
+
+#ifndef EXCLUDE_CSR_WIFI_ROUTER_MODULE
+#include "csr_wifi_router_serialize.h"
+#include "csr_wifi_router_prim.h"
+
+static CsrMsgConvMsgEntry csrwifirouter_conv_lut[] = {
+    { CSR_WIFI_ROUTER_MA_PACKET_SUBSCRIBE_REQ, CsrWifiRouterMaPacketSubscribeReqSizeof, CsrWifiRouterMaPacketSubscribeReqSer, CsrWifiRouterMaPacketSubscribeReqDes, CsrWifiRouterMaPacketSubscribeReqSerFree },
+    { CSR_WIFI_ROUTER_MA_PACKET_UNSUBSCRIBE_REQ, CsrWifiRouterMaPacketUnsubscribeReqSizeof, CsrWifiRouterMaPacketUnsubscribeReqSer, CsrWifiRouterMaPacketUnsubscribeReqDes, CsrWifiRouterMaPacketUnsubscribeReqSerFree },
+    { CSR_WIFI_ROUTER_MA_PACKET_REQ, CsrWifiRouterMaPacketReqSizeof, CsrWifiRouterMaPacketReqSer, CsrWifiRouterMaPacketReqDes, CsrWifiRouterMaPacketReqSerFree },
+    { CSR_WIFI_ROUTER_MA_PACKET_RES, CsrWifiRouterMaPacketResSizeof, CsrWifiRouterMaPacketResSer, CsrWifiRouterMaPacketResDes, CsrWifiRouterMaPacketResSerFree },
+    { CSR_WIFI_ROUTER_MA_PACKET_CANCEL_REQ, CsrWifiRouterMaPacketCancelReqSizeof, CsrWifiRouterMaPacketCancelReqSer, CsrWifiRouterMaPacketCancelReqDes, CsrWifiRouterMaPacketCancelReqSerFree },
+    { CSR_WIFI_ROUTER_MA_PACKET_SUBSCRIBE_CFM, CsrWifiRouterMaPacketSubscribeCfmSizeof, CsrWifiRouterMaPacketSubscribeCfmSer, CsrWifiRouterMaPacketSubscribeCfmDes, CsrWifiRouterMaPacketSubscribeCfmSerFree },
+    { CSR_WIFI_ROUTER_MA_PACKET_UNSUBSCRIBE_CFM, CsrWifiRouterMaPacketUnsubscribeCfmSizeof, CsrWifiRouterMaPacketUnsubscribeCfmSer, CsrWifiRouterMaPacketUnsubscribeCfmDes, CsrWifiRouterMaPacketUnsubscribeCfmSerFree },
+    { CSR_WIFI_ROUTER_MA_PACKET_CFM, CsrWifiRouterMaPacketCfmSizeof, CsrWifiRouterMaPacketCfmSer, CsrWifiRouterMaPacketCfmDes, CsrWifiRouterMaPacketCfmSerFree },
+    { CSR_WIFI_ROUTER_MA_PACKET_IND, CsrWifiRouterMaPacketIndSizeof, CsrWifiRouterMaPacketIndSer, CsrWifiRouterMaPacketIndDes, CsrWifiRouterMaPacketIndSerFree },
+
+    { 0, NULL, NULL, NULL, NULL },
+};
+
+CsrMsgConvMsgEntry* CsrWifiRouterConverterLookup(CsrMsgConvMsgEntry *ce, CsrUint16 msgType)
+{
+    if (msgType & CSR_PRIM_UPSTREAM)
+    {
+        CsrUint16 index = (msgType & ~CSR_PRIM_UPSTREAM) + CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_COUNT;
+        if (index < (CSR_WIFI_ROUTER_PRIM_UPSTREAM_COUNT + CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_COUNT) &&
+            csrwifirouter_conv_lut[index].msgType == msgType)
+        {
+            return &csrwifirouter_conv_lut[index];
+        }
+    }
+    else
+    {
+        if (msgType < CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_COUNT &&
+            csrwifirouter_conv_lut[msgType].msgType == msgType)
+        {
+            return &csrwifirouter_conv_lut[msgType];
+        }
+    }
+    return NULL;
+}
+
+
+void CsrWifiRouterConverterInit(void)
+{
+    CsrMsgConvInsert(CSR_WIFI_ROUTER_PRIM, csrwifirouter_conv_lut);
+    CsrMsgConvCustomLookupRegister(CSR_WIFI_ROUTER_PRIM, CsrWifiRouterConverterLookup);
+}
+
+
+#ifdef CSR_LOG_ENABLE
+static const CsrLogPrimitiveInformation csrwifirouter_conv_info = {
+    CSR_WIFI_ROUTER_PRIM,
+    (CsrCharString *)"CSR_WIFI_ROUTER_PRIM",
+    csrwifirouter_conv_lut
+};
+const CsrLogPrimitiveInformation* CsrWifiRouterTechInfoGet(void)
+{
+    return &csrwifirouter_conv_info;
+}
+
+
+#endif /* CSR_LOG_ENABLE */
+#endif /* EXCLUDE_CSR_WIFI_ROUTER_MODULE */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_converter_init.h
@@ -0,0 +1,42 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_ROUTER_CONVERTER_INIT_H__
+#define CSR_WIFI_ROUTER_CONVERTER_INIT_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef EXCLUDE_CSR_WIFI_ROUTER_MODULE
+
+#include "csr_msgconv.h"
+
+#ifdef CSR_LOG_ENABLE
+#include "csr_log.h"
+
+extern const CsrLogPrimitiveInformation* CsrWifiRouterTechInfoGet(void);
+#endif /* CSR_LOG_ENABLE */
+
+extern void CsrWifiRouterConverterInit(void);
+
+#else /* EXCLUDE_CSR_WIFI_ROUTER_MODULE */
+
+#define CsrWifiRouterConverterInit()
+
+#endif /* EXCLUDE_CSR_WIFI_ROUTER_MODULE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_CONVERTER_INIT_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_ctrl_converter_init.c
@@ -0,0 +1,132 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_msgconv.h"
+#include "csr_pmem.h"
+#include "csr_util.h"
+
+
+#ifdef CSR_LOG_ENABLE
+#include "csr_log.h"
+#endif
+
+#ifndef EXCLUDE_CSR_WIFI_ROUTER_CTRL_MODULE
+#include "csr_wifi_router_ctrl_serialize.h"
+#include "csr_wifi_router_ctrl_prim.h"
+
+static CsrMsgConvMsgEntry csrwifirouterctrl_conv_lut[] = {
+    { CSR_WIFI_ROUTER_CTRL_CONFIGURE_POWER_MODE_REQ, CsrWifiRouterCtrlConfigurePowerModeReqSizeof, CsrWifiRouterCtrlConfigurePowerModeReqSer, CsrWifiRouterCtrlConfigurePowerModeReqDes, CsrWifiRouterCtrlConfigurePowerModeReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_HIP_REQ, CsrWifiRouterCtrlHipReqSizeof, CsrWifiRouterCtrlHipReqSer, CsrWifiRouterCtrlHipReqDes, CsrWifiRouterCtrlHipReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_MEDIA_STATUS_REQ, CsrWifiRouterCtrlMediaStatusReqSizeof, CsrWifiRouterCtrlMediaStatusReqSer, CsrWifiRouterCtrlMediaStatusReqDes, CsrWifiRouterCtrlMediaStatusReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_MULTICAST_ADDRESS_RES, CsrWifiRouterCtrlMulticastAddressResSizeof, CsrWifiRouterCtrlMulticastAddressResSer, CsrWifiRouterCtrlMulticastAddressResDes, CsrWifiRouterCtrlMulticastAddressResSerFree },
+    { CSR_WIFI_ROUTER_CTRL_PORT_CONFIGURE_REQ, CsrWifiRouterCtrlPortConfigureReqSizeof, CsrWifiRouterCtrlPortConfigureReqSer, CsrWifiRouterCtrlPortConfigureReqDes, CsrWifiRouterCtrlPortConfigureReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_QOS_CONTROL_REQ, CsrWifiRouterCtrlQosControlReqSizeof, CsrWifiRouterCtrlQosControlReqSer, CsrWifiRouterCtrlQosControlReqDes, CsrWifiRouterCtrlQosControlReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_SUSPEND_RES, CsrWifiRouterCtrlSuspendResSizeof, CsrWifiRouterCtrlSuspendResSer, CsrWifiRouterCtrlSuspendResDes, CsrWifiRouterCtrlSuspendResSerFree },
+    { CSR_WIFI_ROUTER_CTRL_TCLAS_ADD_REQ, CsrWifiRouterCtrlTclasAddReqSizeof, CsrWifiRouterCtrlTclasAddReqSer, CsrWifiRouterCtrlTclasAddReqDes, CsrWifiRouterCtrlTclasAddReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_RESUME_RES, CsrWifiRouterCtrlResumeResSizeof, CsrWifiRouterCtrlResumeResSer, CsrWifiRouterCtrlResumeResDes, CsrWifiRouterCtrlResumeResSerFree },
+    { CSR_WIFI_ROUTER_CTRL_RAW_SDIO_DEINITIALISE_REQ, CsrWifiRouterCtrlRawSdioDeinitialiseReqSizeof, CsrWifiRouterCtrlRawSdioDeinitialiseReqSer, CsrWifiRouterCtrlRawSdioDeinitialiseReqDes, CsrWifiRouterCtrlRawSdioDeinitialiseReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_RAW_SDIO_INITIALISE_REQ, CsrWifiRouterCtrlRawSdioInitialiseReqSizeof, CsrWifiRouterCtrlRawSdioInitialiseReqSer, CsrWifiRouterCtrlRawSdioInitialiseReqDes, CsrWifiRouterCtrlRawSdioInitialiseReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_TCLAS_DEL_REQ, CsrWifiRouterCtrlTclasDelReqSizeof, CsrWifiRouterCtrlTclasDelReqSer, CsrWifiRouterCtrlTclasDelReqDes, CsrWifiRouterCtrlTclasDelReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_TRAFFIC_CLASSIFICATION_REQ, CsrWifiRouterCtrlTrafficClassificationReqSizeof, CsrWifiRouterCtrlTrafficClassificationReqSer, CsrWifiRouterCtrlTrafficClassificationReqDes, CsrWifiRouterCtrlTrafficClassificationReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_REQ, CsrWifiRouterCtrlTrafficConfigReqSizeof, CsrWifiRouterCtrlTrafficConfigReqSer, CsrWifiRouterCtrlTrafficConfigReqDes, CsrWifiRouterCtrlTrafficConfigReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WIFI_OFF_REQ, CsrWifiRouterCtrlWifiOffReqSizeof, CsrWifiRouterCtrlWifiOffReqSer, CsrWifiRouterCtrlWifiOffReqDes, CsrWifiRouterCtrlWifiOffReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WIFI_OFF_RES, CsrWifiRouterCtrlWifiOffResSizeof, CsrWifiRouterCtrlWifiOffResSer, CsrWifiRouterCtrlWifiOffResDes, CsrWifiRouterCtrlWifiOffResSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WIFI_ON_REQ, CsrWifiRouterCtrlWifiOnReqSizeof, CsrWifiRouterCtrlWifiOnReqSer, CsrWifiRouterCtrlWifiOnReqDes, CsrWifiRouterCtrlWifiOnReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WIFI_ON_RES, CsrWifiRouterCtrlWifiOnResSizeof, CsrWifiRouterCtrlWifiOnResSer, CsrWifiRouterCtrlWifiOnResDes, CsrWifiRouterCtrlWifiOnResSerFree },
+    { CSR_WIFI_ROUTER_CTRL_M4_TRANSMIT_REQ, CsrWifiRouterCtrlM4TransmitReqSizeof, CsrWifiRouterCtrlM4TransmitReqSer, CsrWifiRouterCtrlM4TransmitReqDes, CsrWifiRouterCtrlM4TransmitReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_MODE_SET_REQ, CsrWifiRouterCtrlModeSetReqSizeof, CsrWifiRouterCtrlModeSetReqSer, CsrWifiRouterCtrlModeSetReqDes, CsrWifiRouterCtrlModeSetReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_PEER_ADD_REQ, CsrWifiRouterCtrlPeerAddReqSizeof, CsrWifiRouterCtrlPeerAddReqSer, CsrWifiRouterCtrlPeerAddReqDes, CsrWifiRouterCtrlPeerAddReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_PEER_DEL_REQ, CsrWifiRouterCtrlPeerDelReqSizeof, CsrWifiRouterCtrlPeerDelReqSer, CsrWifiRouterCtrlPeerDelReqDes, CsrWifiRouterCtrlPeerDelReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_PEER_UPDATE_REQ, CsrWifiRouterCtrlPeerUpdateReqSizeof, CsrWifiRouterCtrlPeerUpdateReqSer, CsrWifiRouterCtrlPeerUpdateReqDes, CsrWifiRouterCtrlPeerUpdateReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_CAPABILITIES_REQ, CsrWifiRouterCtrlCapabilitiesReqSizeof, CsrWifiRouterCtrlCapabilitiesReqSer, CsrWifiRouterCtrlCapabilitiesReqDes, CsrWifiRouterCtrlCapabilitiesReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ENABLE_REQ, CsrWifiRouterCtrlBlockAckEnableReqSizeof, CsrWifiRouterCtrlBlockAckEnableReqSer, CsrWifiRouterCtrlBlockAckEnableReqDes, CsrWifiRouterCtrlBlockAckEnableReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_DISABLE_REQ, CsrWifiRouterCtrlBlockAckDisableReqSizeof, CsrWifiRouterCtrlBlockAckDisableReqSer, CsrWifiRouterCtrlBlockAckDisableReqDes, CsrWifiRouterCtrlBlockAckDisableReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_REQ, CsrWifiRouterCtrlWapiMulticastReqSizeof, CsrWifiRouterCtrlWapiMulticastReqSer, CsrWifiRouterCtrlWapiMulticastReqDes, CsrWifiRouterCtrlWapiMulticastReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_FILTER_REQ, CsrWifiRouterCtrlWapiMulticastFilterReqSizeof, CsrWifiRouterCtrlWapiMulticastFilterReqSer, CsrWifiRouterCtrlWapiMulticastFilterReqDes, CsrWifiRouterCtrlWapiMulticastFilterReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WAPI_UNICAST_FILTER_REQ, CsrWifiRouterCtrlWapiUnicastFilterReqSizeof, CsrWifiRouterCtrlWapiUnicastFilterReqSer, CsrWifiRouterCtrlWapiUnicastFilterReqDes, CsrWifiRouterCtrlWapiUnicastFilterReqSerFree },
+    { CSR_WIFI_ROUTER_CTRL_HIP_IND, CsrWifiRouterCtrlHipIndSizeof, CsrWifiRouterCtrlHipIndSer, CsrWifiRouterCtrlHipIndDes, CsrWifiRouterCtrlHipIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_MULTICAST_ADDRESS_IND, CsrWifiRouterCtrlMulticastAddressIndSizeof, CsrWifiRouterCtrlMulticastAddressIndSer, CsrWifiRouterCtrlMulticastAddressIndDes, CsrWifiRouterCtrlMulticastAddressIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_PORT_CONFIGURE_CFM, CsrWifiRouterCtrlPortConfigureCfmSizeof, CsrWifiRouterCtrlPortConfigureCfmSer, CsrWifiRouterCtrlPortConfigureCfmDes, CsrWifiRouterCtrlPortConfigureCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_RESUME_IND, CsrWifiRouterCtrlResumeIndSizeof, CsrWifiRouterCtrlResumeIndSer, CsrWifiRouterCtrlResumeIndDes, CsrWifiRouterCtrlResumeIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_SUSPEND_IND, CsrWifiRouterCtrlSuspendIndSizeof, CsrWifiRouterCtrlSuspendIndSer, CsrWifiRouterCtrlSuspendIndDes, CsrWifiRouterCtrlSuspendIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_TCLAS_ADD_CFM, CsrWifiRouterCtrlTclasAddCfmSizeof, CsrWifiRouterCtrlTclasAddCfmSer, CsrWifiRouterCtrlTclasAddCfmDes, CsrWifiRouterCtrlTclasAddCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_RAW_SDIO_DEINITIALISE_CFM, CsrWifiRouterCtrlRawSdioDeinitialiseCfmSizeof, CsrWifiRouterCtrlRawSdioDeinitialiseCfmSer, CsrWifiRouterCtrlRawSdioDeinitialiseCfmDes, CsrWifiRouterCtrlRawSdioDeinitialiseCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_RAW_SDIO_INITIALISE_CFM, CsrWifiRouterCtrlRawSdioInitialiseCfmSizeof, CsrWifiRouterCtrlRawSdioInitialiseCfmSer, CsrWifiRouterCtrlRawSdioInitialiseCfmDes, CsrWifiRouterCtrlRawSdioInitialiseCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_TCLAS_DEL_CFM, CsrWifiRouterCtrlTclasDelCfmSizeof, CsrWifiRouterCtrlTclasDelCfmSer, CsrWifiRouterCtrlTclasDelCfmDes, CsrWifiRouterCtrlTclasDelCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_TRAFFIC_PROTOCOL_IND, CsrWifiRouterCtrlTrafficProtocolIndSizeof, CsrWifiRouterCtrlTrafficProtocolIndSer, CsrWifiRouterCtrlTrafficProtocolIndDes, CsrWifiRouterCtrlTrafficProtocolIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_TRAFFIC_SAMPLE_IND, CsrWifiRouterCtrlTrafficSampleIndSizeof, CsrWifiRouterCtrlTrafficSampleIndSer, CsrWifiRouterCtrlTrafficSampleIndDes, CsrWifiRouterCtrlTrafficSampleIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WIFI_OFF_IND, CsrWifiRouterCtrlWifiOffIndSizeof, CsrWifiRouterCtrlWifiOffIndSer, CsrWifiRouterCtrlWifiOffIndDes, CsrWifiRouterCtrlWifiOffIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WIFI_OFF_CFM, CsrWifiRouterCtrlWifiOffCfmSizeof, CsrWifiRouterCtrlWifiOffCfmSer, CsrWifiRouterCtrlWifiOffCfmDes, CsrWifiRouterCtrlWifiOffCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WIFI_ON_IND, CsrWifiRouterCtrlWifiOnIndSizeof, CsrWifiRouterCtrlWifiOnIndSer, CsrWifiRouterCtrlWifiOnIndDes, CsrWifiRouterCtrlWifiOnIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WIFI_ON_CFM, CsrWifiRouterCtrlWifiOnCfmSizeof, CsrWifiRouterCtrlWifiOnCfmSer, CsrWifiRouterCtrlWifiOnCfmDes, CsrWifiRouterCtrlWifiOnCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_M4_READY_TO_SEND_IND, CsrWifiRouterCtrlM4ReadyToSendIndSizeof, CsrWifiRouterCtrlM4ReadyToSendIndSer, CsrWifiRouterCtrlM4ReadyToSendIndDes, CsrWifiRouterCtrlM4ReadyToSendIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_M4_TRANSMITTED_IND, CsrWifiRouterCtrlM4TransmittedIndSizeof, CsrWifiRouterCtrlM4TransmittedIndSer, CsrWifiRouterCtrlM4TransmittedIndDes, CsrWifiRouterCtrlM4TransmittedIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_MIC_FAILURE_IND, CsrWifiRouterCtrlMicFailureIndSizeof, CsrWifiRouterCtrlMicFailureIndSer, CsrWifiRouterCtrlMicFailureIndDes, CsrWifiRouterCtrlMicFailureIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_CONNECTED_IND, CsrWifiRouterCtrlConnectedIndSizeof, CsrWifiRouterCtrlConnectedIndSer, CsrWifiRouterCtrlConnectedIndDes, CsrWifiRouterCtrlConnectedIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_PEER_ADD_CFM, CsrWifiRouterCtrlPeerAddCfmSizeof, CsrWifiRouterCtrlPeerAddCfmSer, CsrWifiRouterCtrlPeerAddCfmDes, CsrWifiRouterCtrlPeerAddCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_PEER_DEL_CFM, CsrWifiRouterCtrlPeerDelCfmSizeof, CsrWifiRouterCtrlPeerDelCfmSer, CsrWifiRouterCtrlPeerDelCfmDes, CsrWifiRouterCtrlPeerDelCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_UNEXPECTED_FRAME_IND, CsrWifiRouterCtrlUnexpectedFrameIndSizeof, CsrWifiRouterCtrlUnexpectedFrameIndSer, CsrWifiRouterCtrlUnexpectedFrameIndDes, CsrWifiRouterCtrlUnexpectedFrameIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_PEER_UPDATE_CFM, CsrWifiRouterCtrlPeerUpdateCfmSizeof, CsrWifiRouterCtrlPeerUpdateCfmSer, CsrWifiRouterCtrlPeerUpdateCfmDes, CsrWifiRouterCtrlPeerUpdateCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_CAPABILITIES_CFM, CsrWifiRouterCtrlCapabilitiesCfmSizeof, CsrWifiRouterCtrlCapabilitiesCfmSer, CsrWifiRouterCtrlCapabilitiesCfmDes, CsrWifiRouterCtrlCapabilitiesCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ENABLE_CFM, CsrWifiRouterCtrlBlockAckEnableCfmSizeof, CsrWifiRouterCtrlBlockAckEnableCfmSer, CsrWifiRouterCtrlBlockAckEnableCfmDes, CsrWifiRouterCtrlBlockAckEnableCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_DISABLE_CFM, CsrWifiRouterCtrlBlockAckDisableCfmSizeof, CsrWifiRouterCtrlBlockAckDisableCfmSer, CsrWifiRouterCtrlBlockAckDisableCfmDes, CsrWifiRouterCtrlBlockAckDisableCfmSerFree },
+    { CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ERROR_IND, CsrWifiRouterCtrlBlockAckErrorIndSizeof, CsrWifiRouterCtrlBlockAckErrorIndSer, CsrWifiRouterCtrlBlockAckErrorIndDes, CsrWifiRouterCtrlBlockAckErrorIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_STA_INACTIVE_IND, CsrWifiRouterCtrlStaInactiveIndSizeof, CsrWifiRouterCtrlStaInactiveIndSer, CsrWifiRouterCtrlStaInactiveIndDes, CsrWifiRouterCtrlStaInactiveIndSerFree },
+    { CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_IND, CsrWifiRouterCtrlWapiMulticastIndSizeof, CsrWifiRouterCtrlWapiMulticastIndSer, CsrWifiRouterCtrlWapiMulticastIndDes, CsrWifiRouterCtrlWapiMulticastIndSerFree },
+
+    { 0, NULL, NULL, NULL, NULL },
+};
+
+CsrMsgConvMsgEntry* CsrWifiRouterCtrlConverterLookup(CsrMsgConvMsgEntry *ce, CsrUint16 msgType)
+{
+    if (msgType & CSR_PRIM_UPSTREAM)
+    {
+        CsrUint16 index = (msgType & ~CSR_PRIM_UPSTREAM) + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_COUNT;
+        if (index < (CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_COUNT + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_COUNT) &&
+            csrwifirouterctrl_conv_lut[index].msgType == msgType)
+        {
+            return &csrwifirouterctrl_conv_lut[index];
+        }
+    }
+    else
+    {
+        if (msgType < CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_COUNT &&
+            csrwifirouterctrl_conv_lut[msgType].msgType == msgType)
+        {
+            return &csrwifirouterctrl_conv_lut[msgType];
+        }
+    }
+    return NULL;
+}
+
+
+void CsrWifiRouterCtrlConverterInit(void)
+{
+    CsrMsgConvInsert(CSR_WIFI_ROUTER_CTRL_PRIM, csrwifirouterctrl_conv_lut);
+    CsrMsgConvCustomLookupRegister(CSR_WIFI_ROUTER_CTRL_PRIM, CsrWifiRouterCtrlConverterLookup);
+}
+
+
+#ifdef CSR_LOG_ENABLE
+static const CsrLogPrimitiveInformation csrwifirouterctrl_conv_info = {
+    CSR_WIFI_ROUTER_CTRL_PRIM,
+    (CsrCharString *)"CSR_WIFI_ROUTER_CTRL_PRIM",
+    csrwifirouterctrl_conv_lut
+};
+const CsrLogPrimitiveInformation* CsrWifiRouterCtrlTechInfoGet(void)
+{
+    return &csrwifirouterctrl_conv_info;
+}
+
+
+#endif /* CSR_LOG_ENABLE */
+#endif /* EXCLUDE_CSR_WIFI_ROUTER_CTRL_MODULE */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_ctrl_converter_init.h
@@ -0,0 +1,42 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_ROUTER_CTRL_CONVERTER_INIT_H__
+#define CSR_WIFI_ROUTER_CTRL_CONVERTER_INIT_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef EXCLUDE_CSR_WIFI_ROUTER_CTRL_MODULE
+
+#include "csr_msgconv.h"
+
+#ifdef CSR_LOG_ENABLE
+#include "csr_log.h"
+
+extern const CsrLogPrimitiveInformation* CsrWifiRouterCtrlTechInfoGet(void);
+#endif /* CSR_LOG_ENABLE */
+
+extern void CsrWifiRouterCtrlConverterInit(void);
+
+#else /* EXCLUDE_CSR_WIFI_ROUTER_CTRL_MODULE */
+
+#define CsrWifiRouterCtrlConverterInit()
+
+#endif /* EXCLUDE_CSR_WIFI_ROUTER_CTRL_MODULE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_CTRL_CONVERTER_INIT_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_ctrl_free_downstream_contents.c
@@ -0,0 +1,95 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_pmem.h"
+#include "csr_wifi_router_ctrl_prim.h"
+#include "csr_wifi_router_ctrl_lib.h"
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrWifiRouterCtrlFreeDownstreamMessageContents
+ *
+ *  DESCRIPTION
+ *
+ *
+ *  PARAMETERS
+ *      eventClass: only the value CSR_WIFI_ROUTER_CTRL_PRIM will be handled
+ *      message:    the message to free
+ *----------------------------------------------------------------------------*/
+void CsrWifiRouterCtrlFreeDownstreamMessageContents(CsrUint16 eventClass, void *message)
+{
+    if (eventClass != CSR_WIFI_ROUTER_CTRL_PRIM)
+    {
+        return;
+    }
+    if (NULL == message)
+    {
+        return;
+    }
+
+    switch (*((CsrWifiRouterCtrlPrim *) message))
+    {
+        case CSR_WIFI_ROUTER_CTRL_HIP_REQ:
+        {
+            CsrWifiRouterCtrlHipReq *p = (CsrWifiRouterCtrlHipReq *)message;
+            CsrPmemFree(p->mlmeCommand);
+            p->mlmeCommand = NULL;
+            CsrPmemFree(p->dataRef1);
+            p->dataRef1 = NULL;
+            CsrPmemFree(p->dataRef2);
+            p->dataRef2 = NULL;
+            break;
+        }
+        case CSR_WIFI_ROUTER_CTRL_MULTICAST_ADDRESS_RES:
+        {
+            CsrWifiRouterCtrlMulticastAddressRes *p = (CsrWifiRouterCtrlMulticastAddressRes *)message;
+            CsrPmemFree(p->getAddresses);
+            p->getAddresses = NULL;
+            break;
+        }
+        case CSR_WIFI_ROUTER_CTRL_TCLAS_ADD_REQ:
+        {
+            CsrWifiRouterCtrlTclasAddReq *p = (CsrWifiRouterCtrlTclasAddReq *)message;
+            CsrPmemFree(p->tclas);
+            p->tclas = NULL;
+            break;
+        }
+        case CSR_WIFI_ROUTER_CTRL_TCLAS_DEL_REQ:
+        {
+            CsrWifiRouterCtrlTclasDelReq *p = (CsrWifiRouterCtrlTclasDelReq *)message;
+            CsrPmemFree(p->tclas);
+            p->tclas = NULL;
+            break;
+        }
+        case CSR_WIFI_ROUTER_CTRL_WIFI_ON_RES:
+        {
+            CsrWifiRouterCtrlWifiOnRes *p = (CsrWifiRouterCtrlWifiOnRes *)message;
+            CsrPmemFree(p->smeVersions.smeBuild);
+            p->smeVersions.smeBuild = NULL;
+            break;
+        }
+        case CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_REQ:
+        {
+            CsrWifiRouterCtrlWapiMulticastReq *p = (CsrWifiRouterCtrlWapiMulticastReq *)message;
+            CsrPmemFree(p->signal);
+            p->signal = NULL;
+            CsrPmemFree(p->data);
+            p->data = NULL;
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_ctrl_free_upstream_contents.c
@@ -0,0 +1,81 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_pmem.h"
+#include "csr_wifi_router_ctrl_prim.h"
+#include "csr_wifi_router_ctrl_lib.h"
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrWifiRouterCtrlFreeUpstreamMessageContents
+ *
+ *  DESCRIPTION
+ *
+ *
+ *  PARAMETERS
+ *      eventClass: only the value CSR_WIFI_ROUTER_CTRL_PRIM will be handled
+ *      message:    the message to free
+ *----------------------------------------------------------------------------*/
+void CsrWifiRouterCtrlFreeUpstreamMessageContents(CsrUint16 eventClass, void *message)
+{
+    if (eventClass != CSR_WIFI_ROUTER_CTRL_PRIM)
+    {
+        return;
+    }
+    if (NULL == message)
+    {
+        return;
+    }
+
+    switch (*((CsrWifiRouterCtrlPrim *) message))
+    {
+        case CSR_WIFI_ROUTER_CTRL_HIP_IND:
+        {
+            CsrWifiRouterCtrlHipInd *p = (CsrWifiRouterCtrlHipInd *)message;
+            CsrPmemFree(p->mlmeCommand);
+            p->mlmeCommand = NULL;
+            CsrPmemFree(p->dataRef1);
+            p->dataRef1 = NULL;
+            CsrPmemFree(p->dataRef2);
+            p->dataRef2 = NULL;
+            break;
+        }
+        case CSR_WIFI_ROUTER_CTRL_MULTICAST_ADDRESS_IND:
+        {
+            CsrWifiRouterCtrlMulticastAddressInd *p = (CsrWifiRouterCtrlMulticastAddressInd *)message;
+            CsrPmemFree(p->setAddresses);
+            p->setAddresses = NULL;
+            break;
+        }
+        case CSR_WIFI_ROUTER_CTRL_WIFI_ON_IND:
+        {
+            CsrWifiRouterCtrlWifiOnInd *p = (CsrWifiRouterCtrlWifiOnInd *)message;
+            CsrPmemFree(p->versions.routerBuild);
+            p->versions.routerBuild = NULL;
+            break;
+        }
+        case CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_IND:
+        {
+            CsrWifiRouterCtrlWapiMulticastInd *p = (CsrWifiRouterCtrlWapiMulticastInd *)message;
+            CsrPmemFree(p->signal);
+            p->signal = NULL;
+            CsrPmemFree(p->data);
+            p->data = NULL;
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_ctrl_lib.h
@@ -0,0 +1,1958 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_ROUTER_CTRL_LIB_H__
+#define CSR_WIFI_ROUTER_CTRL_LIB_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_sched.h"
+#include "csr_util.h"
+#include "csr_msg_transport.h"
+
+#include "csr_wifi_lib.h"
+
+#include "csr_wifi_router_ctrl_prim.h"
+#include "csr_wifi_router_task.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiRouterCtrlFreeUpstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_ROUTER_CTRL upstream message. Does not
+ *      free the message itself, and can only be used for upstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_ROUTER_CTRL upstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiRouterCtrlFreeUpstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiRouterCtrlFreeDownstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_ROUTER_CTRL downstream message. Does not
+ *      free the message itself, and can only be used for downstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_ROUTER_CTRL downstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiRouterCtrlFreeDownstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ * Enum to string functions
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiRouterCtrlBlockAckRoleToString(CsrWifiRouterCtrlBlockAckRole value);
+const CsrCharString* CsrWifiRouterCtrlControlIndicationToString(CsrWifiRouterCtrlControlIndication value);
+const CsrCharString* CsrWifiRouterCtrlListActionToString(CsrWifiRouterCtrlListAction value);
+const CsrCharString* CsrWifiRouterCtrlLowPowerModeToString(CsrWifiRouterCtrlLowPowerMode value);
+const CsrCharString* CsrWifiRouterCtrlMediaStatusToString(CsrWifiRouterCtrlMediaStatus value);
+const CsrCharString* CsrWifiRouterCtrlModeToString(CsrWifiRouterCtrlMode value);
+const CsrCharString* CsrWifiRouterCtrlPeerStatusToString(CsrWifiRouterCtrlPeerStatus value);
+const CsrCharString* CsrWifiRouterCtrlPortActionToString(CsrWifiRouterCtrlPortAction value);
+const CsrCharString* CsrWifiRouterCtrlPowersaveTypeToString(CsrWifiRouterCtrlPowersaveType value);
+const CsrCharString* CsrWifiRouterCtrlProtocolDirectionToString(CsrWifiRouterCtrlProtocolDirection value);
+const CsrCharString* CsrWifiRouterCtrlQoSControlToString(CsrWifiRouterCtrlQoSControl value);
+const CsrCharString* CsrWifiRouterCtrlQueueConfigToString(CsrWifiRouterCtrlQueueConfig value);
+const CsrCharString* CsrWifiRouterCtrlTrafficConfigTypeToString(CsrWifiRouterCtrlTrafficConfigType value);
+const CsrCharString* CsrWifiRouterCtrlTrafficPacketTypeToString(CsrWifiRouterCtrlTrafficPacketType value);
+const CsrCharString* CsrWifiRouterCtrlTrafficTypeToString(CsrWifiRouterCtrlTrafficType value);
+
+
+/*----------------------------------------------------------------------------*
+ * CsrPrim Type toString function.
+ * Converts a message type to the String name of the Message
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiRouterCtrlPrimTypeToString(CsrPrim msgType);
+
+/*----------------------------------------------------------------------------*
+ * Lookup arrays for PrimType name Strings
+ *----------------------------------------------------------------------------*/
+extern const CsrCharString *CsrWifiRouterCtrlUpstreamPrimNames[CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_COUNT];
+extern const CsrCharString *CsrWifiRouterCtrlDownstreamPrimNames[CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_COUNT];
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckDisableReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue           - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag    -
+    clientData      -
+    macAddress      -
+    trafficStreamID -
+    role            -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlBlockAckDisableReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, macAddress__, trafficStreamID__, role__) \
+    msg__ = (CsrWifiRouterCtrlBlockAckDisableReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlBlockAckDisableReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_DISABLE_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->macAddress = (macAddress__); \
+    msg__->trafficStreamID = (trafficStreamID__); \
+    msg__->role = (role__);
+
+#define CsrWifiRouterCtrlBlockAckDisableReqSendTo(dst__, src__, interfaceTag__, clientData__, macAddress__, trafficStreamID__, role__) \
+    { \
+        CsrWifiRouterCtrlBlockAckDisableReq *msg__; \
+        CsrWifiRouterCtrlBlockAckDisableReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, macAddress__, trafficStreamID__, role__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlBlockAckDisableReqSend(src__, interfaceTag__, clientData__, macAddress__, trafficStreamID__, role__) \
+    CsrWifiRouterCtrlBlockAckDisableReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, macAddress__, trafficStreamID__, role__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckDisableCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlBlockAckDisableCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__) \
+    msg__ = (CsrWifiRouterCtrlBlockAckDisableCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlBlockAckDisableCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_DISABLE_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlBlockAckDisableCfmSendTo(dst__, src__, clientData__, interfaceTag__, status__) \
+    { \
+        CsrWifiRouterCtrlBlockAckDisableCfm *msg__; \
+        CsrWifiRouterCtrlBlockAckDisableCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlBlockAckDisableCfmSend(dst__, clientData__, interfaceTag__, status__) \
+    CsrWifiRouterCtrlBlockAckDisableCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckEnableReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue           - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag    -
+    clientData      -
+    macAddress      -
+    trafficStreamID -
+    role            -
+    bufferSize      -
+    timeout         -
+    ssn             -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlBlockAckEnableReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, macAddress__, trafficStreamID__, role__, bufferSize__, timeout__, ssn__) \
+    msg__ = (CsrWifiRouterCtrlBlockAckEnableReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlBlockAckEnableReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ENABLE_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->macAddress = (macAddress__); \
+    msg__->trafficStreamID = (trafficStreamID__); \
+    msg__->role = (role__); \
+    msg__->bufferSize = (bufferSize__); \
+    msg__->timeout = (timeout__); \
+    msg__->ssn = (ssn__);
+
+#define CsrWifiRouterCtrlBlockAckEnableReqSendTo(dst__, src__, interfaceTag__, clientData__, macAddress__, trafficStreamID__, role__, bufferSize__, timeout__, ssn__) \
+    { \
+        CsrWifiRouterCtrlBlockAckEnableReq *msg__; \
+        CsrWifiRouterCtrlBlockAckEnableReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, macAddress__, trafficStreamID__, role__, bufferSize__, timeout__, ssn__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlBlockAckEnableReqSend(src__, interfaceTag__, clientData__, macAddress__, trafficStreamID__, role__, bufferSize__, timeout__, ssn__) \
+    CsrWifiRouterCtrlBlockAckEnableReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, macAddress__, trafficStreamID__, role__, bufferSize__, timeout__, ssn__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckEnableCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlBlockAckEnableCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__) \
+    msg__ = (CsrWifiRouterCtrlBlockAckEnableCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlBlockAckEnableCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ENABLE_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlBlockAckEnableCfmSendTo(dst__, src__, clientData__, interfaceTag__, status__) \
+    { \
+        CsrWifiRouterCtrlBlockAckEnableCfm *msg__; \
+        CsrWifiRouterCtrlBlockAckEnableCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlBlockAckEnableCfmSend(dst__, clientData__, interfaceTag__, status__) \
+    CsrWifiRouterCtrlBlockAckEnableCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckErrorIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue           - Destination Task Queue
+    clientData      -
+    interfaceTag    -
+    trafficStreamID -
+    peerMacAddress  -
+    status          -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlBlockAckErrorIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, trafficStreamID__, peerMacAddress__, status__) \
+    msg__ = (CsrWifiRouterCtrlBlockAckErrorInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlBlockAckErrorInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ERROR_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->trafficStreamID = (trafficStreamID__); \
+    msg__->peerMacAddress = (peerMacAddress__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlBlockAckErrorIndSendTo(dst__, src__, clientData__, interfaceTag__, trafficStreamID__, peerMacAddress__, status__) \
+    { \
+        CsrWifiRouterCtrlBlockAckErrorInd *msg__; \
+        CsrWifiRouterCtrlBlockAckErrorIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, trafficStreamID__, peerMacAddress__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlBlockAckErrorIndSend(dst__, clientData__, interfaceTag__, trafficStreamID__, peerMacAddress__, status__) \
+    CsrWifiRouterCtrlBlockAckErrorIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, trafficStreamID__, peerMacAddress__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlCapabilitiesReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue      - Message Source Task Queue (Cfm's will be sent to this Queue)
+    clientData -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlCapabilitiesReqCreate(msg__, dst__, src__, clientData__) \
+    msg__ = (CsrWifiRouterCtrlCapabilitiesReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlCapabilitiesReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_CAPABILITIES_REQ, dst__, src__); \
+    msg__->clientData = (clientData__);
+
+#define CsrWifiRouterCtrlCapabilitiesReqSendTo(dst__, src__, clientData__) \
+    { \
+        CsrWifiRouterCtrlCapabilitiesReq *msg__; \
+        CsrWifiRouterCtrlCapabilitiesReqCreate(msg__, dst__, src__, clientData__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlCapabilitiesReqSend(src__, clientData__) \
+    CsrWifiRouterCtrlCapabilitiesReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, clientData__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlCapabilitiesCfmSend
+
+  DESCRIPTION
+    The router sends this primitive to confirm the size of the queues of the
+    HIP.
+
+  PARAMETERS
+    queue            - Destination Task Queue
+    clientData       -
+    commandQueueSize - Size of command queue
+    trafficQueueSize - Size of traffic queue (per AC)
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlCapabilitiesCfmCreate(msg__, dst__, src__, clientData__, commandQueueSize__, trafficQueueSize__) \
+    msg__ = (CsrWifiRouterCtrlCapabilitiesCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlCapabilitiesCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_CAPABILITIES_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->commandQueueSize = (commandQueueSize__); \
+    msg__->trafficQueueSize = (trafficQueueSize__);
+
+#define CsrWifiRouterCtrlCapabilitiesCfmSendTo(dst__, src__, clientData__, commandQueueSize__, trafficQueueSize__) \
+    { \
+        CsrWifiRouterCtrlCapabilitiesCfm *msg__; \
+        CsrWifiRouterCtrlCapabilitiesCfmCreate(msg__, dst__, src__, clientData__, commandQueueSize__, trafficQueueSize__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlCapabilitiesCfmSend(dst__, clientData__, commandQueueSize__, trafficQueueSize__) \
+    CsrWifiRouterCtrlCapabilitiesCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, commandQueueSize__, trafficQueueSize__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlConfigurePowerModeReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue      - Message Source Task Queue (Cfm's will be sent to this Queue)
+    clientData -
+    mode       -
+    wakeHost   -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlConfigurePowerModeReqCreate(msg__, dst__, src__, clientData__, mode__, wakeHost__) \
+    msg__ = (CsrWifiRouterCtrlConfigurePowerModeReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlConfigurePowerModeReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_CONFIGURE_POWER_MODE_REQ, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->mode = (mode__); \
+    msg__->wakeHost = (wakeHost__);
+
+#define CsrWifiRouterCtrlConfigurePowerModeReqSendTo(dst__, src__, clientData__, mode__, wakeHost__) \
+    { \
+        CsrWifiRouterCtrlConfigurePowerModeReq *msg__; \
+        CsrWifiRouterCtrlConfigurePowerModeReqCreate(msg__, dst__, src__, clientData__, mode__, wakeHost__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlConfigurePowerModeReqSend(src__, clientData__, mode__, wakeHost__) \
+    CsrWifiRouterCtrlConfigurePowerModeReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, clientData__, mode__, wakeHost__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlConnectedIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    clientData     -
+    interfaceTag   -
+    peerMacAddress -
+    peerStatus     -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlConnectedIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__, peerStatus__) \
+    msg__ = (CsrWifiRouterCtrlConnectedInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlConnectedInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_CONNECTED_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->peerMacAddress = (peerMacAddress__); \
+    msg__->peerStatus = (peerStatus__);
+
+#define CsrWifiRouterCtrlConnectedIndSendTo(dst__, src__, clientData__, interfaceTag__, peerMacAddress__, peerStatus__) \
+    { \
+        CsrWifiRouterCtrlConnectedInd *msg__; \
+        CsrWifiRouterCtrlConnectedIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__, peerStatus__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlConnectedIndSend(dst__, clientData__, interfaceTag__, peerMacAddress__, peerStatus__) \
+    CsrWifiRouterCtrlConnectedIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, peerMacAddress__, peerStatus__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlHipReqSend
+
+  DESCRIPTION
+    This primitive is used for transferring MLME messages to the HIP.
+
+  PARAMETERS
+    queue             - Message Source Task Queue (Cfm's will be sent to this Queue)
+    mlmeCommandLength - Length of the MLME signal
+    mlmeCommand       - Pointer to the MLME signal
+    dataRef1Length    - Length of the dataRef1 bulk data
+    dataRef1          - Pointer to the bulk data 1
+    dataRef2Length    - Length of the dataRef2 bulk data
+    dataRef2          - Pointer to the bulk data 2
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlHipReqCreate(msg__, dst__, src__, mlmeCommandLength__, mlmeCommand__, dataRef1Length__, dataRef1__, dataRef2Length__, dataRef2__) \
+    msg__ = (CsrWifiRouterCtrlHipReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlHipReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_HIP_REQ, dst__, src__); \
+    msg__->mlmeCommandLength = (mlmeCommandLength__); \
+    msg__->mlmeCommand = (mlmeCommand__); \
+    msg__->dataRef1Length = (dataRef1Length__); \
+    msg__->dataRef1 = (dataRef1__); \
+    msg__->dataRef2Length = (dataRef2Length__); \
+    msg__->dataRef2 = (dataRef2__);
+
+#define CsrWifiRouterCtrlHipReqSendTo(dst__, src__, mlmeCommandLength__, mlmeCommand__, dataRef1Length__, dataRef1__, dataRef2Length__, dataRef2__) \
+    { \
+        CsrWifiRouterCtrlHipReq *msg__; \
+        CsrWifiRouterCtrlHipReqCreate(msg__, dst__, src__, mlmeCommandLength__, mlmeCommand__, dataRef1Length__, dataRef1__, dataRef2Length__, dataRef2__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlHipReqSend(src__, mlmeCommandLength__, mlmeCommand__, dataRef1Length__, dataRef1__, dataRef2Length__, dataRef2__) \
+    CsrWifiRouterCtrlHipReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, mlmeCommandLength__, mlmeCommand__, dataRef1Length__, dataRef1__, dataRef2Length__, dataRef2__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlHipIndSend
+
+  DESCRIPTION
+    This primitive is used for transferring MLME messages from the HIP.
+
+  PARAMETERS
+    queue             - Destination Task Queue
+    mlmeCommandLength - Length of the MLME signal
+    mlmeCommand       - Pointer to the MLME signal
+    dataRef1Length    - Length of the dataRef1 bulk data
+    dataRef1          - Pointer to the bulk data 1
+    dataRef2Length    - Length of the dataRef2 bulk data
+    dataRef2          - Pointer to the bulk data 2
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlHipIndCreate(msg__, dst__, src__, mlmeCommandLength__, mlmeCommand__, dataRef1Length__, dataRef1__, dataRef2Length__, dataRef2__) \
+    msg__ = (CsrWifiRouterCtrlHipInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlHipInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_HIP_IND, dst__, src__); \
+    msg__->mlmeCommandLength = (mlmeCommandLength__); \
+    msg__->mlmeCommand = (mlmeCommand__); \
+    msg__->dataRef1Length = (dataRef1Length__); \
+    msg__->dataRef1 = (dataRef1__); \
+    msg__->dataRef2Length = (dataRef2Length__); \
+    msg__->dataRef2 = (dataRef2__);
+
+#define CsrWifiRouterCtrlHipIndSendTo(dst__, src__, mlmeCommandLength__, mlmeCommand__, dataRef1Length__, dataRef1__, dataRef2Length__, dataRef2__) \
+    { \
+        CsrWifiRouterCtrlHipInd *msg__; \
+        CsrWifiRouterCtrlHipIndCreate(msg__, dst__, src__, mlmeCommandLength__, mlmeCommand__, dataRef1Length__, dataRef1__, dataRef2Length__, dataRef2__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlHipIndSend(dst__, mlmeCommandLength__, mlmeCommand__, dataRef1Length__, dataRef1__, dataRef2Length__, dataRef2__) \
+    CsrWifiRouterCtrlHipIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, mlmeCommandLength__, mlmeCommand__, dataRef1Length__, dataRef1__, dataRef2Length__, dataRef2__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlM4ReadyToSendIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    clientData     -
+    interfaceTag   -
+    peerMacAddress -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlM4ReadyToSendIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__) \
+    msg__ = (CsrWifiRouterCtrlM4ReadyToSendInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlM4ReadyToSendInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_M4_READY_TO_SEND_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->peerMacAddress = (peerMacAddress__);
+
+#define CsrWifiRouterCtrlM4ReadyToSendIndSendTo(dst__, src__, clientData__, interfaceTag__, peerMacAddress__) \
+    { \
+        CsrWifiRouterCtrlM4ReadyToSendInd *msg__; \
+        CsrWifiRouterCtrlM4ReadyToSendIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlM4ReadyToSendIndSend(dst__, clientData__, interfaceTag__, peerMacAddress__) \
+    CsrWifiRouterCtrlM4ReadyToSendIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, peerMacAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlM4TransmitReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag -
+    clientData   -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlM4TransmitReqCreate(msg__, dst__, src__, interfaceTag__, clientData__) \
+    msg__ = (CsrWifiRouterCtrlM4TransmitReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlM4TransmitReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_M4_TRANSMIT_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__);
+
+#define CsrWifiRouterCtrlM4TransmitReqSendTo(dst__, src__, interfaceTag__, clientData__) \
+    { \
+        CsrWifiRouterCtrlM4TransmitReq *msg__; \
+        CsrWifiRouterCtrlM4TransmitReqCreate(msg__, dst__, src__, interfaceTag__, clientData__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlM4TransmitReqSend(src__, interfaceTag__, clientData__) \
+    CsrWifiRouterCtrlM4TransmitReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlM4TransmittedIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    clientData     -
+    interfaceTag   -
+    peerMacAddress -
+    status         -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlM4TransmittedIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__, status__) \
+    msg__ = (CsrWifiRouterCtrlM4TransmittedInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlM4TransmittedInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_M4_TRANSMITTED_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->peerMacAddress = (peerMacAddress__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlM4TransmittedIndSendTo(dst__, src__, clientData__, interfaceTag__, peerMacAddress__, status__) \
+    { \
+        CsrWifiRouterCtrlM4TransmittedInd *msg__; \
+        CsrWifiRouterCtrlM4TransmittedIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlM4TransmittedIndSend(dst__, clientData__, interfaceTag__, peerMacAddress__, status__) \
+    CsrWifiRouterCtrlM4TransmittedIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, peerMacAddress__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlMediaStatusReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag -
+    clientData   -
+    mediaStatus  -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlMediaStatusReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, mediaStatus__) \
+    msg__ = (CsrWifiRouterCtrlMediaStatusReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlMediaStatusReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_MEDIA_STATUS_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->mediaStatus = (mediaStatus__);
+
+#define CsrWifiRouterCtrlMediaStatusReqSendTo(dst__, src__, interfaceTag__, clientData__, mediaStatus__) \
+    { \
+        CsrWifiRouterCtrlMediaStatusReq *msg__; \
+        CsrWifiRouterCtrlMediaStatusReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, mediaStatus__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlMediaStatusReqSend(src__, interfaceTag__, clientData__, mediaStatus__) \
+    CsrWifiRouterCtrlMediaStatusReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, mediaStatus__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlMicFailureIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    clientData     -
+    interfaceTag   -
+    peerMacAddress -
+    unicastPdu     -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlMicFailureIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__, unicastPdu__) \
+    msg__ = (CsrWifiRouterCtrlMicFailureInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlMicFailureInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_MIC_FAILURE_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->peerMacAddress = (peerMacAddress__); \
+    msg__->unicastPdu = (unicastPdu__);
+
+#define CsrWifiRouterCtrlMicFailureIndSendTo(dst__, src__, clientData__, interfaceTag__, peerMacAddress__, unicastPdu__) \
+    { \
+        CsrWifiRouterCtrlMicFailureInd *msg__; \
+        CsrWifiRouterCtrlMicFailureIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__, unicastPdu__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlMicFailureIndSend(dst__, clientData__, interfaceTag__, peerMacAddress__, unicastPdu__) \
+    CsrWifiRouterCtrlMicFailureIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, peerMacAddress__, unicastPdu__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlModeSetReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue               - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag        -
+    clientData          -
+    mode                -
+    bssid               - BSSID of the network the device is going to be a part
+                          of
+    protection          - Set to TRUE if encryption is enabled for the
+                          connection/broadcast frames
+    intraBssDistEnabled - If set to TRUE, intra BSS destribution will be
+                          enabled. If set to FALSE, any unicast PDU which does
+                          not have the RA as the the local MAC address, shall be
+                          ignored. This field is interpreted by the receive if
+                          mode is set to CSR_WIFI_ROUTER_CTRL_MODE_P2PGO
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlModeSetReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, mode__, bssid__, protection__, intraBssDistEnabled__) \
+    msg__ = (CsrWifiRouterCtrlModeSetReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlModeSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_MODE_SET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->mode = (mode__); \
+    msg__->bssid = (bssid__); \
+    msg__->protection = (protection__); \
+    msg__->intraBssDistEnabled = (intraBssDistEnabled__);
+
+#define CsrWifiRouterCtrlModeSetReqSendTo(dst__, src__, interfaceTag__, clientData__, mode__, bssid__, protection__, intraBssDistEnabled__) \
+    { \
+        CsrWifiRouterCtrlModeSetReq *msg__; \
+        CsrWifiRouterCtrlModeSetReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, mode__, bssid__, protection__, intraBssDistEnabled__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlModeSetReqSend(src__, interfaceTag__, clientData__, mode__, bssid__, protection__, intraBssDistEnabled__) \
+    CsrWifiRouterCtrlModeSetReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, mode__, bssid__, protection__, intraBssDistEnabled__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlMulticastAddressIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue             - Destination Task Queue
+    clientData        -
+    interfaceTag      -
+    action            -
+    setAddressesCount -
+    setAddresses      -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlMulticastAddressIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, action__, setAddressesCount__, setAddresses__) \
+    msg__ = (CsrWifiRouterCtrlMulticastAddressInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlMulticastAddressInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_MULTICAST_ADDRESS_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->action = (action__); \
+    msg__->setAddressesCount = (setAddressesCount__); \
+    msg__->setAddresses = (setAddresses__);
+
+#define CsrWifiRouterCtrlMulticastAddressIndSendTo(dst__, src__, clientData__, interfaceTag__, action__, setAddressesCount__, setAddresses__) \
+    { \
+        CsrWifiRouterCtrlMulticastAddressInd *msg__; \
+        CsrWifiRouterCtrlMulticastAddressIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, action__, setAddressesCount__, setAddresses__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlMulticastAddressIndSend(dst__, clientData__, interfaceTag__, action__, setAddressesCount__, setAddresses__) \
+    CsrWifiRouterCtrlMulticastAddressIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, action__, setAddressesCount__, setAddresses__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlMulticastAddressResSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    interfaceTag      -
+    clientData        -
+    status            -
+    action            -
+    getAddressesCount -
+    getAddresses      -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlMulticastAddressResCreate(msg__, dst__, src__, interfaceTag__, clientData__, status__, action__, getAddressesCount__, getAddresses__) \
+    msg__ = (CsrWifiRouterCtrlMulticastAddressRes *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlMulticastAddressRes)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_MULTICAST_ADDRESS_RES, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->status = (status__); \
+    msg__->action = (action__); \
+    msg__->getAddressesCount = (getAddressesCount__); \
+    msg__->getAddresses = (getAddresses__);
+
+#define CsrWifiRouterCtrlMulticastAddressResSendTo(dst__, src__, interfaceTag__, clientData__, status__, action__, getAddressesCount__, getAddresses__) \
+    { \
+        CsrWifiRouterCtrlMulticastAddressRes *msg__; \
+        CsrWifiRouterCtrlMulticastAddressResCreate(msg__, dst__, src__, interfaceTag__, clientData__, status__, action__, getAddressesCount__, getAddresses__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlMulticastAddressResSend(src__, interfaceTag__, clientData__, status__, action__, getAddressesCount__, getAddresses__) \
+    CsrWifiRouterCtrlMulticastAddressResSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, status__, action__, getAddressesCount__, getAddresses__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerAddReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue          - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag   -
+    clientData     -
+    peerMacAddress -
+    associationId  -
+    staInfo        -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlPeerAddReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, peerMacAddress__, associationId__, staInfo__) \
+    msg__ = (CsrWifiRouterCtrlPeerAddReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerAddReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_PEER_ADD_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->peerMacAddress = (peerMacAddress__); \
+    msg__->associationId = (associationId__); \
+    msg__->staInfo = (staInfo__);
+
+#define CsrWifiRouterCtrlPeerAddReqSendTo(dst__, src__, interfaceTag__, clientData__, peerMacAddress__, associationId__, staInfo__) \
+    { \
+        CsrWifiRouterCtrlPeerAddReq *msg__; \
+        CsrWifiRouterCtrlPeerAddReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, peerMacAddress__, associationId__, staInfo__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlPeerAddReqSend(src__, interfaceTag__, clientData__, peerMacAddress__, associationId__, staInfo__) \
+    CsrWifiRouterCtrlPeerAddReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, peerMacAddress__, associationId__, staInfo__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerAddCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue            - Destination Task Queue
+    clientData       -
+    interfaceTag     -
+    peerMacAddress   -
+    peerRecordHandle -
+    status           -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlPeerAddCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__, peerRecordHandle__, status__) \
+    msg__ = (CsrWifiRouterCtrlPeerAddCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerAddCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_PEER_ADD_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->peerMacAddress = (peerMacAddress__); \
+    msg__->peerRecordHandle = (peerRecordHandle__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlPeerAddCfmSendTo(dst__, src__, clientData__, interfaceTag__, peerMacAddress__, peerRecordHandle__, status__) \
+    { \
+        CsrWifiRouterCtrlPeerAddCfm *msg__; \
+        CsrWifiRouterCtrlPeerAddCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__, peerRecordHandle__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlPeerAddCfmSend(dst__, clientData__, interfaceTag__, peerMacAddress__, peerRecordHandle__, status__) \
+    CsrWifiRouterCtrlPeerAddCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, peerMacAddress__, peerRecordHandle__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerDelReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue            - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag     -
+    clientData       -
+    peerRecordHandle -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlPeerDelReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, peerRecordHandle__) \
+    msg__ = (CsrWifiRouterCtrlPeerDelReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerDelReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_PEER_DEL_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->peerRecordHandle = (peerRecordHandle__);
+
+#define CsrWifiRouterCtrlPeerDelReqSendTo(dst__, src__, interfaceTag__, clientData__, peerRecordHandle__) \
+    { \
+        CsrWifiRouterCtrlPeerDelReq *msg__; \
+        CsrWifiRouterCtrlPeerDelReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, peerRecordHandle__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlPeerDelReqSend(src__, interfaceTag__, clientData__, peerRecordHandle__) \
+    CsrWifiRouterCtrlPeerDelReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, peerRecordHandle__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerDelCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlPeerDelCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__) \
+    msg__ = (CsrWifiRouterCtrlPeerDelCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerDelCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_PEER_DEL_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlPeerDelCfmSendTo(dst__, src__, clientData__, interfaceTag__, status__) \
+    { \
+        CsrWifiRouterCtrlPeerDelCfm *msg__; \
+        CsrWifiRouterCtrlPeerDelCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlPeerDelCfmSend(dst__, clientData__, interfaceTag__, status__) \
+    CsrWifiRouterCtrlPeerDelCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerUpdateReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue            - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag     -
+    clientData       -
+    peerRecordHandle -
+    powersaveMode    -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlPeerUpdateReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, peerRecordHandle__, powersaveMode__) \
+    msg__ = (CsrWifiRouterCtrlPeerUpdateReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerUpdateReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_PEER_UPDATE_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->peerRecordHandle = (peerRecordHandle__); \
+    msg__->powersaveMode = (powersaveMode__);
+
+#define CsrWifiRouterCtrlPeerUpdateReqSendTo(dst__, src__, interfaceTag__, clientData__, peerRecordHandle__, powersaveMode__) \
+    { \
+        CsrWifiRouterCtrlPeerUpdateReq *msg__; \
+        CsrWifiRouterCtrlPeerUpdateReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, peerRecordHandle__, powersaveMode__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlPeerUpdateReqSend(src__, interfaceTag__, clientData__, peerRecordHandle__, powersaveMode__) \
+    CsrWifiRouterCtrlPeerUpdateReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, peerRecordHandle__, powersaveMode__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerUpdateCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlPeerUpdateCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__) \
+    msg__ = (CsrWifiRouterCtrlPeerUpdateCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerUpdateCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_PEER_UPDATE_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlPeerUpdateCfmSendTo(dst__, src__, clientData__, interfaceTag__, status__) \
+    { \
+        CsrWifiRouterCtrlPeerUpdateCfm *msg__; \
+        CsrWifiRouterCtrlPeerUpdateCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlPeerUpdateCfmSend(dst__, clientData__, interfaceTag__, status__) \
+    CsrWifiRouterCtrlPeerUpdateCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPortConfigureReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue                  - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag           -
+    clientData             -
+    uncontrolledPortAction -
+    controlledPortAction   -
+    macAddress             -
+    setProtection          -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlPortConfigureReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, uncontrolledPortAction__, controlledPortAction__, macAddress__, setProtection__) \
+    msg__ = (CsrWifiRouterCtrlPortConfigureReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPortConfigureReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_PORT_CONFIGURE_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->uncontrolledPortAction = (uncontrolledPortAction__); \
+    msg__->controlledPortAction = (controlledPortAction__); \
+    msg__->macAddress = (macAddress__); \
+    msg__->setProtection = (setProtection__);
+
+#define CsrWifiRouterCtrlPortConfigureReqSendTo(dst__, src__, interfaceTag__, clientData__, uncontrolledPortAction__, controlledPortAction__, macAddress__, setProtection__) \
+    { \
+        CsrWifiRouterCtrlPortConfigureReq *msg__; \
+        CsrWifiRouterCtrlPortConfigureReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, uncontrolledPortAction__, controlledPortAction__, macAddress__, setProtection__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlPortConfigureReqSend(src__, interfaceTag__, clientData__, uncontrolledPortAction__, controlledPortAction__, macAddress__, setProtection__) \
+    CsrWifiRouterCtrlPortConfigureReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, uncontrolledPortAction__, controlledPortAction__, macAddress__, setProtection__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPortConfigureCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    status       -
+    macAddress   -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlPortConfigureCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__, macAddress__) \
+    msg__ = (CsrWifiRouterCtrlPortConfigureCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPortConfigureCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_PORT_CONFIGURE_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->macAddress = (macAddress__);
+
+#define CsrWifiRouterCtrlPortConfigureCfmSendTo(dst__, src__, clientData__, interfaceTag__, status__, macAddress__) \
+    { \
+        CsrWifiRouterCtrlPortConfigureCfm *msg__; \
+        CsrWifiRouterCtrlPortConfigureCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__, macAddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlPortConfigureCfmSend(dst__, clientData__, interfaceTag__, status__, macAddress__) \
+    CsrWifiRouterCtrlPortConfigureCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, status__, macAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlQosControlReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag -
+    clientData   -
+    control      -
+    queueConfig  -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlQosControlReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, control__, queueConfig__) \
+    msg__ = (CsrWifiRouterCtrlQosControlReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlQosControlReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_QOS_CONTROL_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->control = (control__); \
+    msg__->queueConfig = (queueConfig__);
+
+#define CsrWifiRouterCtrlQosControlReqSendTo(dst__, src__, interfaceTag__, clientData__, control__, queueConfig__) \
+    { \
+        CsrWifiRouterCtrlQosControlReq *msg__; \
+        CsrWifiRouterCtrlQosControlReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, control__, queueConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlQosControlReqSend(src__, interfaceTag__, clientData__, control__, queueConfig__) \
+    CsrWifiRouterCtrlQosControlReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, control__, queueConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlRawSdioDeinitialiseReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue      - Message Source Task Queue (Cfm's will be sent to this Queue)
+    clientData -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlRawSdioDeinitialiseReqCreate(msg__, dst__, src__, clientData__) \
+    msg__ = (CsrWifiRouterCtrlRawSdioDeinitialiseReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlRawSdioDeinitialiseReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_RAW_SDIO_DEINITIALISE_REQ, dst__, src__); \
+    msg__->clientData = (clientData__);
+
+#define CsrWifiRouterCtrlRawSdioDeinitialiseReqSendTo(dst__, src__, clientData__) \
+    { \
+        CsrWifiRouterCtrlRawSdioDeinitialiseReq *msg__; \
+        CsrWifiRouterCtrlRawSdioDeinitialiseReqCreate(msg__, dst__, src__, clientData__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlRawSdioDeinitialiseReqSend(src__, clientData__) \
+    CsrWifiRouterCtrlRawSdioDeinitialiseReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, clientData__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlRawSdioDeinitialiseCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue      - Destination Task Queue
+    clientData -
+    result     -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlRawSdioDeinitialiseCfmCreate(msg__, dst__, src__, clientData__, result__) \
+    msg__ = (CsrWifiRouterCtrlRawSdioDeinitialiseCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlRawSdioDeinitialiseCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_RAW_SDIO_DEINITIALISE_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->result = (result__);
+
+#define CsrWifiRouterCtrlRawSdioDeinitialiseCfmSendTo(dst__, src__, clientData__, result__) \
+    { \
+        CsrWifiRouterCtrlRawSdioDeinitialiseCfm *msg__; \
+        CsrWifiRouterCtrlRawSdioDeinitialiseCfmCreate(msg__, dst__, src__, clientData__, result__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlRawSdioDeinitialiseCfmSend(dst__, clientData__, result__) \
+    CsrWifiRouterCtrlRawSdioDeinitialiseCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, result__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlRawSdioInitialiseReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue      - Message Source Task Queue (Cfm's will be sent to this Queue)
+    clientData -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlRawSdioInitialiseReqCreate(msg__, dst__, src__, clientData__) \
+    msg__ = (CsrWifiRouterCtrlRawSdioInitialiseReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlRawSdioInitialiseReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_RAW_SDIO_INITIALISE_REQ, dst__, src__); \
+    msg__->clientData = (clientData__);
+
+#define CsrWifiRouterCtrlRawSdioInitialiseReqSendTo(dst__, src__, clientData__) \
+    { \
+        CsrWifiRouterCtrlRawSdioInitialiseReq *msg__; \
+        CsrWifiRouterCtrlRawSdioInitialiseReqCreate(msg__, dst__, src__, clientData__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlRawSdioInitialiseReqSend(src__, clientData__) \
+    CsrWifiRouterCtrlRawSdioInitialiseReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, clientData__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlRawSdioInitialiseCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue            - Destination Task Queue
+    clientData       -
+    result           -
+    byteRead         -
+    byteWrite        -
+    firmwareDownload -
+    reset            -
+    coreDumpPrepare  -
+    byteBlockRead    -
+    gpRead16         -
+    gpWrite16        -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlRawSdioInitialiseCfmCreate(msg__, dst__, src__, clientData__, result__, byteRead__, byteWrite__, firmwareDownload__, reset__, coreDumpPrepare__, byteBlockRead__, gpRead16__, gpWrite16__) \
+    msg__ = (CsrWifiRouterCtrlRawSdioInitialiseCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlRawSdioInitialiseCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_RAW_SDIO_INITIALISE_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->result = (result__); \
+    msg__->byteRead = (byteRead__); \
+    msg__->byteWrite = (byteWrite__); \
+    msg__->firmwareDownload = (firmwareDownload__); \
+    msg__->reset = (reset__); \
+    msg__->coreDumpPrepare = (coreDumpPrepare__); \
+    msg__->byteBlockRead = (byteBlockRead__); \
+    msg__->gpRead16 = (gpRead16__); \
+    msg__->gpWrite16 = (gpWrite16__);
+
+#define CsrWifiRouterCtrlRawSdioInitialiseCfmSendTo(dst__, src__, clientData__, result__, byteRead__, byteWrite__, firmwareDownload__, reset__, coreDumpPrepare__, byteBlockRead__, gpRead16__, gpWrite16__) \
+    { \
+        CsrWifiRouterCtrlRawSdioInitialiseCfm *msg__; \
+        CsrWifiRouterCtrlRawSdioInitialiseCfmCreate(msg__, dst__, src__, clientData__, result__, byteRead__, byteWrite__, firmwareDownload__, reset__, coreDumpPrepare__, byteBlockRead__, gpRead16__, gpWrite16__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlRawSdioInitialiseCfmSend(dst__, clientData__, result__, byteRead__, byteWrite__, firmwareDownload__, reset__, coreDumpPrepare__, byteBlockRead__, gpRead16__, gpWrite16__) \
+    CsrWifiRouterCtrlRawSdioInitialiseCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, result__, byteRead__, byteWrite__, firmwareDownload__, reset__, coreDumpPrepare__, byteBlockRead__, gpRead16__, gpWrite16__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlResumeIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue           - Destination Task Queue
+    clientData      -
+    powerMaintained -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlResumeIndCreate(msg__, dst__, src__, clientData__, powerMaintained__) \
+    msg__ = (CsrWifiRouterCtrlResumeInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlResumeInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_RESUME_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->powerMaintained = (powerMaintained__);
+
+#define CsrWifiRouterCtrlResumeIndSendTo(dst__, src__, clientData__, powerMaintained__) \
+    { \
+        CsrWifiRouterCtrlResumeInd *msg__; \
+        CsrWifiRouterCtrlResumeIndCreate(msg__, dst__, src__, clientData__, powerMaintained__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlResumeIndSend(dst__, clientData__, powerMaintained__) \
+    CsrWifiRouterCtrlResumeIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, powerMaintained__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlResumeResSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    clientData -
+    status     -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlResumeResCreate(msg__, dst__, src__, clientData__, status__) \
+    msg__ = (CsrWifiRouterCtrlResumeRes *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlResumeRes)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_RESUME_RES, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlResumeResSendTo(dst__, src__, clientData__, status__) \
+    { \
+        CsrWifiRouterCtrlResumeRes *msg__; \
+        CsrWifiRouterCtrlResumeResCreate(msg__, dst__, src__, clientData__, status__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlResumeResSend(src__, clientData__, status__) \
+    CsrWifiRouterCtrlResumeResSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, clientData__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlStaInactiveIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    staAddress   -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlStaInactiveIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, staAddress__) \
+    msg__ = (CsrWifiRouterCtrlStaInactiveInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlStaInactiveInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_STA_INACTIVE_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->staAddress = (staAddress__);
+
+#define CsrWifiRouterCtrlStaInactiveIndSendTo(dst__, src__, clientData__, interfaceTag__, staAddress__) \
+    { \
+        CsrWifiRouterCtrlStaInactiveInd *msg__; \
+        CsrWifiRouterCtrlStaInactiveIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, staAddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlStaInactiveIndSend(dst__, clientData__, interfaceTag__, staAddress__) \
+    CsrWifiRouterCtrlStaInactiveIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, staAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlSuspendIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue       - Destination Task Queue
+    clientData  -
+    hardSuspend -
+    d3Suspend   -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlSuspendIndCreate(msg__, dst__, src__, clientData__, hardSuspend__, d3Suspend__) \
+    msg__ = (CsrWifiRouterCtrlSuspendInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlSuspendInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_SUSPEND_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->hardSuspend = (hardSuspend__); \
+    msg__->d3Suspend = (d3Suspend__);
+
+#define CsrWifiRouterCtrlSuspendIndSendTo(dst__, src__, clientData__, hardSuspend__, d3Suspend__) \
+    { \
+        CsrWifiRouterCtrlSuspendInd *msg__; \
+        CsrWifiRouterCtrlSuspendIndCreate(msg__, dst__, src__, clientData__, hardSuspend__, d3Suspend__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlSuspendIndSend(dst__, clientData__, hardSuspend__, d3Suspend__) \
+    CsrWifiRouterCtrlSuspendIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, hardSuspend__, d3Suspend__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlSuspendResSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    clientData -
+    status     -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlSuspendResCreate(msg__, dst__, src__, clientData__, status__) \
+    msg__ = (CsrWifiRouterCtrlSuspendRes *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlSuspendRes)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_SUSPEND_RES, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlSuspendResSendTo(dst__, src__, clientData__, status__) \
+    { \
+        CsrWifiRouterCtrlSuspendRes *msg__; \
+        CsrWifiRouterCtrlSuspendResCreate(msg__, dst__, src__, clientData__, status__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlSuspendResSend(src__, clientData__, status__) \
+    CsrWifiRouterCtrlSuspendResSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, clientData__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTclasAddReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag -
+    clientData   -
+    tclasLength  -
+    tclas        -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlTclasAddReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, tclasLength__, tclas__) \
+    msg__ = (CsrWifiRouterCtrlTclasAddReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTclasAddReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_TCLAS_ADD_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->tclasLength = (tclasLength__); \
+    msg__->tclas = (tclas__);
+
+#define CsrWifiRouterCtrlTclasAddReqSendTo(dst__, src__, interfaceTag__, clientData__, tclasLength__, tclas__) \
+    { \
+        CsrWifiRouterCtrlTclasAddReq *msg__; \
+        CsrWifiRouterCtrlTclasAddReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, tclasLength__, tclas__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlTclasAddReqSend(src__, interfaceTag__, clientData__, tclasLength__, tclas__) \
+    CsrWifiRouterCtrlTclasAddReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, tclasLength__, tclas__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTclasAddCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlTclasAddCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__) \
+    msg__ = (CsrWifiRouterCtrlTclasAddCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTclasAddCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_TCLAS_ADD_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlTclasAddCfmSendTo(dst__, src__, clientData__, interfaceTag__, status__) \
+    { \
+        CsrWifiRouterCtrlTclasAddCfm *msg__; \
+        CsrWifiRouterCtrlTclasAddCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlTclasAddCfmSend(dst__, clientData__, interfaceTag__, status__) \
+    CsrWifiRouterCtrlTclasAddCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTclasDelReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag -
+    clientData   -
+    tclasLength  -
+    tclas        -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlTclasDelReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, tclasLength__, tclas__) \
+    msg__ = (CsrWifiRouterCtrlTclasDelReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTclasDelReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_TCLAS_DEL_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->tclasLength = (tclasLength__); \
+    msg__->tclas = (tclas__);
+
+#define CsrWifiRouterCtrlTclasDelReqSendTo(dst__, src__, interfaceTag__, clientData__, tclasLength__, tclas__) \
+    { \
+        CsrWifiRouterCtrlTclasDelReq *msg__; \
+        CsrWifiRouterCtrlTclasDelReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, tclasLength__, tclas__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlTclasDelReqSend(src__, interfaceTag__, clientData__, tclasLength__, tclas__) \
+    CsrWifiRouterCtrlTclasDelReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, tclasLength__, tclas__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTclasDelCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlTclasDelCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__) \
+    msg__ = (CsrWifiRouterCtrlTclasDelCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTclasDelCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_TCLAS_DEL_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlTclasDelCfmSendTo(dst__, src__, clientData__, interfaceTag__, status__) \
+    { \
+        CsrWifiRouterCtrlTclasDelCfm *msg__; \
+        CsrWifiRouterCtrlTclasDelCfmCreate(msg__, dst__, src__, clientData__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlTclasDelCfmSend(dst__, clientData__, interfaceTag__, status__) \
+    CsrWifiRouterCtrlTclasDelCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficClassificationReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag -
+    clientData   -
+    trafficType  -
+    period       -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlTrafficClassificationReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, trafficType__, period__) \
+    msg__ = (CsrWifiRouterCtrlTrafficClassificationReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTrafficClassificationReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_TRAFFIC_CLASSIFICATION_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->trafficType = (trafficType__); \
+    msg__->period = (period__);
+
+#define CsrWifiRouterCtrlTrafficClassificationReqSendTo(dst__, src__, interfaceTag__, clientData__, trafficType__, period__) \
+    { \
+        CsrWifiRouterCtrlTrafficClassificationReq *msg__; \
+        CsrWifiRouterCtrlTrafficClassificationReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, trafficType__, period__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlTrafficClassificationReqSend(src__, interfaceTag__, clientData__, trafficType__, period__) \
+    CsrWifiRouterCtrlTrafficClassificationReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, trafficType__, period__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficConfigReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue             - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag      -
+    clientData        -
+    trafficConfigType -
+    config            -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlTrafficConfigReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, trafficConfigType__, config__) \
+    msg__ = (CsrWifiRouterCtrlTrafficConfigReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTrafficConfigReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->clientData = (clientData__); \
+    msg__->trafficConfigType = (trafficConfigType__); \
+    msg__->config = (config__);
+
+#define CsrWifiRouterCtrlTrafficConfigReqSendTo(dst__, src__, interfaceTag__, clientData__, trafficConfigType__, config__) \
+    { \
+        CsrWifiRouterCtrlTrafficConfigReq *msg__; \
+        CsrWifiRouterCtrlTrafficConfigReqCreate(msg__, dst__, src__, interfaceTag__, clientData__, trafficConfigType__, config__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlTrafficConfigReqSend(src__, interfaceTag__, clientData__, trafficConfigType__, config__) \
+    CsrWifiRouterCtrlTrafficConfigReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, clientData__, trafficConfigType__, config__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficProtocolIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    packetType   -
+    direction    -
+    srcAddress   -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlTrafficProtocolIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, packetType__, direction__, srcAddress__) \
+    msg__ = (CsrWifiRouterCtrlTrafficProtocolInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTrafficProtocolInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_TRAFFIC_PROTOCOL_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->packetType = (packetType__); \
+    msg__->direction = (direction__); \
+    msg__->srcAddress = (srcAddress__);
+
+#define CsrWifiRouterCtrlTrafficProtocolIndSendTo(dst__, src__, clientData__, interfaceTag__, packetType__, direction__, srcAddress__) \
+    { \
+        CsrWifiRouterCtrlTrafficProtocolInd *msg__; \
+        CsrWifiRouterCtrlTrafficProtocolIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, packetType__, direction__, srcAddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlTrafficProtocolIndSend(dst__, clientData__, interfaceTag__, packetType__, direction__, srcAddress__) \
+    CsrWifiRouterCtrlTrafficProtocolIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, packetType__, direction__, srcAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficSampleIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    stats        -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlTrafficSampleIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, stats__) \
+    msg__ = (CsrWifiRouterCtrlTrafficSampleInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTrafficSampleInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_TRAFFIC_SAMPLE_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->stats = (stats__);
+
+#define CsrWifiRouterCtrlTrafficSampleIndSendTo(dst__, src__, clientData__, interfaceTag__, stats__) \
+    { \
+        CsrWifiRouterCtrlTrafficSampleInd *msg__; \
+        CsrWifiRouterCtrlTrafficSampleIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, stats__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlTrafficSampleIndSend(dst__, clientData__, interfaceTag__, stats__) \
+    CsrWifiRouterCtrlTrafficSampleIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, stats__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlUnexpectedFrameIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    clientData     -
+    interfaceTag   -
+    peerMacAddress -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlUnexpectedFrameIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__) \
+    msg__ = (CsrWifiRouterCtrlUnexpectedFrameInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlUnexpectedFrameInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_UNEXPECTED_FRAME_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->peerMacAddress = (peerMacAddress__);
+
+#define CsrWifiRouterCtrlUnexpectedFrameIndSendTo(dst__, src__, clientData__, interfaceTag__, peerMacAddress__) \
+    { \
+        CsrWifiRouterCtrlUnexpectedFrameInd *msg__; \
+        CsrWifiRouterCtrlUnexpectedFrameIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, peerMacAddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlUnexpectedFrameIndSend(dst__, clientData__, interfaceTag__, peerMacAddress__) \
+    CsrWifiRouterCtrlUnexpectedFrameIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, peerMacAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWapiMulticastFilterReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+    status -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWapiMulticastFilterReqCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiRouterCtrlWapiMulticastFilterReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWapiMulticastFilterReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_FILTER_REQ, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlWapiMulticastFilterReqSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiRouterCtrlWapiMulticastFilterReq *msg__; \
+        CsrWifiRouterCtrlWapiMulticastFilterReqCreate(msg__, dst__, src__, status__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWapiMulticastFilterReqSend(src__, status__) \
+    CsrWifiRouterCtrlWapiMulticastFilterReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWapiMulticastReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    signalLength -
+    signal       -
+    dataLength   -
+    data         -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWapiMulticastReqCreate(msg__, dst__, src__, signalLength__, signal__, dataLength__, data__) \
+    msg__ = (CsrWifiRouterCtrlWapiMulticastReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWapiMulticastReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_REQ, dst__, src__); \
+    msg__->signalLength = (signalLength__); \
+    msg__->signal = (signal__); \
+    msg__->dataLength = (dataLength__); \
+    msg__->data = (data__);
+
+#define CsrWifiRouterCtrlWapiMulticastReqSendTo(dst__, src__, signalLength__, signal__, dataLength__, data__) \
+    { \
+        CsrWifiRouterCtrlWapiMulticastReq *msg__; \
+        CsrWifiRouterCtrlWapiMulticastReqCreate(msg__, dst__, src__, signalLength__, signal__, dataLength__, data__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWapiMulticastReqSend(src__, signalLength__, signal__, dataLength__, data__) \
+    CsrWifiRouterCtrlWapiMulticastReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, signalLength__, signal__, dataLength__, data__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWapiMulticastIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    clientData   -
+    interfaceTag -
+    signalLength -
+    signal       -
+    dataLength   -
+    data         -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWapiMulticastIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, signalLength__, signal__, dataLength__, data__) \
+    msg__ = (CsrWifiRouterCtrlWapiMulticastInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWapiMulticastInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->signalLength = (signalLength__); \
+    msg__->signal = (signal__); \
+    msg__->dataLength = (dataLength__); \
+    msg__->data = (data__);
+
+#define CsrWifiRouterCtrlWapiMulticastIndSendTo(dst__, src__, clientData__, interfaceTag__, signalLength__, signal__, dataLength__, data__) \
+    { \
+        CsrWifiRouterCtrlWapiMulticastInd *msg__; \
+        CsrWifiRouterCtrlWapiMulticastIndCreate(msg__, dst__, src__, clientData__, interfaceTag__, signalLength__, signal__, dataLength__, data__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWapiMulticastIndSend(dst__, clientData__, interfaceTag__, signalLength__, signal__, dataLength__, data__) \
+    CsrWifiRouterCtrlWapiMulticastIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, interfaceTag__, signalLength__, signal__, dataLength__, data__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWapiUnicastFilterReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+    status -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWapiUnicastFilterReqCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiRouterCtrlWapiUnicastFilterReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWapiUnicastFilterReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WAPI_UNICAST_FILTER_REQ, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlWapiUnicastFilterReqSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiRouterCtrlWapiUnicastFilterReq *msg__; \
+        CsrWifiRouterCtrlWapiUnicastFilterReqCreate(msg__, dst__, src__, status__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWapiUnicastFilterReqSend(src__, status__) \
+    CsrWifiRouterCtrlWapiUnicastFilterReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOffReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue      - Message Source Task Queue (Cfm's will be sent to this Queue)
+    clientData -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWifiOffReqCreate(msg__, dst__, src__, clientData__) \
+    msg__ = (CsrWifiRouterCtrlWifiOffReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOffReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WIFI_OFF_REQ, dst__, src__); \
+    msg__->clientData = (clientData__);
+
+#define CsrWifiRouterCtrlWifiOffReqSendTo(dst__, src__, clientData__) \
+    { \
+        CsrWifiRouterCtrlWifiOffReq *msg__; \
+        CsrWifiRouterCtrlWifiOffReqCreate(msg__, dst__, src__, clientData__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWifiOffReqSend(src__, clientData__) \
+    CsrWifiRouterCtrlWifiOffReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, clientData__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOffIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue             - Destination Task Queue
+    clientData        -
+    controlIndication -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWifiOffIndCreate(msg__, dst__, src__, clientData__, controlIndication__) \
+    msg__ = (CsrWifiRouterCtrlWifiOffInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOffInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WIFI_OFF_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->controlIndication = (controlIndication__);
+
+#define CsrWifiRouterCtrlWifiOffIndSendTo(dst__, src__, clientData__, controlIndication__) \
+    { \
+        CsrWifiRouterCtrlWifiOffInd *msg__; \
+        CsrWifiRouterCtrlWifiOffIndCreate(msg__, dst__, src__, clientData__, controlIndication__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWifiOffIndSend(dst__, clientData__, controlIndication__) \
+    CsrWifiRouterCtrlWifiOffIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, controlIndication__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOffResSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    clientData -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWifiOffResCreate(msg__, dst__, src__, clientData__) \
+    msg__ = (CsrWifiRouterCtrlWifiOffRes *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOffRes)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WIFI_OFF_RES, dst__, src__); \
+    msg__->clientData = (clientData__);
+
+#define CsrWifiRouterCtrlWifiOffResSendTo(dst__, src__, clientData__) \
+    { \
+        CsrWifiRouterCtrlWifiOffRes *msg__; \
+        CsrWifiRouterCtrlWifiOffResCreate(msg__, dst__, src__, clientData__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWifiOffResSend(src__, clientData__) \
+    CsrWifiRouterCtrlWifiOffResSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, clientData__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOffCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue      - Destination Task Queue
+    clientData -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWifiOffCfmCreate(msg__, dst__, src__, clientData__) \
+    msg__ = (CsrWifiRouterCtrlWifiOffCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOffCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WIFI_OFF_CFM, dst__, src__); \
+    msg__->clientData = (clientData__);
+
+#define CsrWifiRouterCtrlWifiOffCfmSendTo(dst__, src__, clientData__) \
+    { \
+        CsrWifiRouterCtrlWifiOffCfm *msg__; \
+        CsrWifiRouterCtrlWifiOffCfmCreate(msg__, dst__, src__, clientData__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWifiOffCfmSend(dst__, clientData__) \
+    CsrWifiRouterCtrlWifiOffCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOnReqSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue      - Message Source Task Queue (Cfm's will be sent to this Queue)
+    clientData -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWifiOnReqCreate(msg__, dst__, src__, clientData__) \
+    msg__ = (CsrWifiRouterCtrlWifiOnReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOnReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WIFI_ON_REQ, dst__, src__); \
+    msg__->clientData = (clientData__);
+
+#define CsrWifiRouterCtrlWifiOnReqSendTo(dst__, src__, clientData__) \
+    { \
+        CsrWifiRouterCtrlWifiOnReq *msg__; \
+        CsrWifiRouterCtrlWifiOnReqCreate(msg__, dst__, src__, clientData__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWifiOnReqSend(src__, clientData__) \
+    CsrWifiRouterCtrlWifiOnReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, clientData__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOnIndSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue      - Destination Task Queue
+    clientData -
+    status     -
+    versions   -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWifiOnIndCreate(msg__, dst__, src__, clientData__, status__, versions__) \
+    msg__ = (CsrWifiRouterCtrlWifiOnInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOnInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WIFI_ON_IND, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->status = (status__); \
+    msg__->versions = (versions__);
+
+#define CsrWifiRouterCtrlWifiOnIndSendTo(dst__, src__, clientData__, status__, versions__) \
+    { \
+        CsrWifiRouterCtrlWifiOnInd *msg__; \
+        CsrWifiRouterCtrlWifiOnIndCreate(msg__, dst__, src__, clientData__, status__, versions__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWifiOnIndSend(dst__, clientData__, status__, versions__) \
+    CsrWifiRouterCtrlWifiOnIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, status__, versions__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOnResSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    clientData          -
+    status              -
+    numInterfaceAddress -
+    stationMacAddress   - array size 1 MUST match CSR_WIFI_NUM_INTERFACES
+    smeVersions         -
+    scheduledInterrupt  -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWifiOnResCreate(msg__, dst__, src__, clientData__, status__, numInterfaceAddress__, stationMacAddress__, smeVersions__, scheduledInterrupt__) \
+    msg__ = (CsrWifiRouterCtrlWifiOnRes *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOnRes)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WIFI_ON_RES, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->status = (status__); \
+    msg__->numInterfaceAddress = (numInterfaceAddress__); \
+    CsrMemCpy(msg__->stationMacAddress, (stationMacAddress__), sizeof(CsrWifiMacAddress) * 2); \
+    msg__->smeVersions = (smeVersions__); \
+    msg__->scheduledInterrupt = (scheduledInterrupt__);
+
+#define CsrWifiRouterCtrlWifiOnResSendTo(dst__, src__, clientData__, status__, numInterfaceAddress__, stationMacAddress__, smeVersions__, scheduledInterrupt__) \
+    { \
+        CsrWifiRouterCtrlWifiOnRes *msg__; \
+        CsrWifiRouterCtrlWifiOnResCreate(msg__, dst__, src__, clientData__, status__, numInterfaceAddress__, stationMacAddress__, smeVersions__, scheduledInterrupt__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWifiOnResSend(src__, clientData__, status__, numInterfaceAddress__, stationMacAddress__, smeVersions__, scheduledInterrupt__) \
+    CsrWifiRouterCtrlWifiOnResSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, clientData__, status__, numInterfaceAddress__, stationMacAddress__, smeVersions__, scheduledInterrupt__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOnCfmSend
+
+  DESCRIPTION
+
+  PARAMETERS
+    queue      - Destination Task Queue
+    clientData -
+    status     -
+
+*******************************************************************************/
+#define CsrWifiRouterCtrlWifiOnCfmCreate(msg__, dst__, src__, clientData__, status__) \
+    msg__ = (CsrWifiRouterCtrlWifiOnCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOnCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_CTRL_PRIM, CSR_WIFI_ROUTER_CTRL_WIFI_ON_CFM, dst__, src__); \
+    msg__->clientData = (clientData__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterCtrlWifiOnCfmSendTo(dst__, src__, clientData__, status__) \
+    { \
+        CsrWifiRouterCtrlWifiOnCfm *msg__; \
+        CsrWifiRouterCtrlWifiOnCfmCreate(msg__, dst__, src__, clientData__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_CTRL_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterCtrlWifiOnCfmSend(dst__, clientData__, status__) \
+    CsrWifiRouterCtrlWifiOnCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, clientData__, status__)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_CTRL_LIB_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_ctrl_prim.h
@@ -0,0 +1,2018 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_ROUTER_CTRL_PRIM_H__
+#define CSR_WIFI_ROUTER_CTRL_PRIM_H__
+
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+#include "csr_sched.h"
+#include "csr_wifi_common.h"
+#include "csr_result.h"
+#include "csr_wifi_fsm_event.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CSR_WIFI_ROUTER_CTRL_PRIM                                       (0x0401)
+
+typedef CsrPrim CsrWifiRouterCtrlPrim;
+
+typedef CsrResult (*CsrWifiRouterCtrlRawSdioByteWrite)(CsrUint8 func, CsrUint32 address, CsrUint8 data);
+typedef CsrResult (*CsrWifiRouterCtrlRawSdioByteRead)(CsrUint8 func, CsrUint32 address, CsrUint8 *pdata);
+typedef CsrResult (*CsrWifiRouterCtrlRawSdioFirmwareDownload)(CsrUint32 length, const CsrUint8 *pdata);
+typedef CsrResult (*CsrWifiRouterCtrlRawSdioReset)(void);
+typedef CsrResult (*CsrWifiRouterCtrlRawSdioCoreDumpPrepare)(CsrBool suspendSme);
+typedef CsrResult (*CsrWifiRouterCtrlRawSdioByteBlockRead)(CsrUint8 func, CsrUint32 address, CsrUint8 *pdata, CsrUint32 length);
+typedef CsrResult (*CsrWifiRouterCtrlRawSdioGpRead16)(CsrUint8 func, CsrUint32 address, CsrUint16 *pdata);
+typedef CsrResult (*CsrWifiRouterCtrlRawSdioGpWrite16)(CsrUint8 func, CsrUint32 address, CsrUint16 data);
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckRole
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ORIGINATOR
+                   -
+    CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_RECIPIENT
+                   -
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterCtrlBlockAckRole;
+#define CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ORIGINATOR   ((CsrWifiRouterCtrlBlockAckRole) 0x00)
+#define CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_RECIPIENT    ((CsrWifiRouterCtrlBlockAckRole) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlControlIndication
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_CONTROL_INDICATION_ERROR
+                   -
+    CSR_WIFI_ROUTER_CTRL_CONTROL_INDICATION_EXIT
+                   -
+    CSR_WIFI_ROUTER_CTRL_CONTROL_INDICATION_USER_REQUESTED
+                   -
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterCtrlControlIndication;
+#define CSR_WIFI_ROUTER_CTRL_CONTROL_INDICATION_ERROR            ((CsrWifiRouterCtrlControlIndication) 0x01)
+#define CSR_WIFI_ROUTER_CTRL_CONTROL_INDICATION_EXIT             ((CsrWifiRouterCtrlControlIndication) 0x02)
+#define CSR_WIFI_ROUTER_CTRL_CONTROL_INDICATION_USER_REQUESTED   ((CsrWifiRouterCtrlControlIndication) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlListAction
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_LIST_ACTION_GET
+                   -
+    CSR_WIFI_ROUTER_CTRL_LIST_ACTION_ADD
+                   -
+    CSR_WIFI_ROUTER_CTRL_LIST_ACTION_REMOVE
+                   -
+    CSR_WIFI_ROUTER_CTRL_LIST_ACTION_FLUSH
+                   -
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterCtrlListAction;
+#define CSR_WIFI_ROUTER_CTRL_LIST_ACTION_GET      ((CsrWifiRouterCtrlListAction) 0x00)
+#define CSR_WIFI_ROUTER_CTRL_LIST_ACTION_ADD      ((CsrWifiRouterCtrlListAction) 0x01)
+#define CSR_WIFI_ROUTER_CTRL_LIST_ACTION_REMOVE   ((CsrWifiRouterCtrlListAction) 0x02)
+#define CSR_WIFI_ROUTER_CTRL_LIST_ACTION_FLUSH    ((CsrWifiRouterCtrlListAction) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlLowPowerMode
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_LOW_POWER_MODE_DISABLED
+                   -
+    CSR_WIFI_ROUTER_CTRL_LOW_POWER_MODE_ENABLED
+                   -
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiRouterCtrlLowPowerMode;
+#define CSR_WIFI_ROUTER_CTRL_LOW_POWER_MODE_DISABLED   ((CsrWifiRouterCtrlLowPowerMode) 0x0000)
+#define CSR_WIFI_ROUTER_CTRL_LOW_POWER_MODE_ENABLED    ((CsrWifiRouterCtrlLowPowerMode) 0x0001)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlMediaStatus
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_MEDIA_STATUS_CONNECTED
+                   -
+    CSR_WIFI_ROUTER_CTRL_MEDIA_STATUS_DISCONNECTED
+                   -
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterCtrlMediaStatus;
+#define CSR_WIFI_ROUTER_CTRL_MEDIA_STATUS_CONNECTED      ((CsrWifiRouterCtrlMediaStatus) 0x00)
+#define CSR_WIFI_ROUTER_CTRL_MEDIA_STATUS_DISCONNECTED   ((CsrWifiRouterCtrlMediaStatus) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlMode
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_MODE_NONE    -
+    CSR_WIFI_ROUTER_CTRL_MODE_IBSS    -
+    CSR_WIFI_ROUTER_CTRL_MODE_STA     -
+    CSR_WIFI_ROUTER_CTRL_MODE_AP      -
+    CSR_WIFI_ROUTER_CTRL_MODE_MONITOR -
+    CSR_WIFI_ROUTER_CTRL_MODE_AMP     -
+    CSR_WIFI_ROUTER_CTRL_MODE_P2P     -
+    CSR_WIFI_ROUTER_CTRL_MODE_P2PGO   -
+    CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI  -
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterCtrlMode;
+#define CSR_WIFI_ROUTER_CTRL_MODE_NONE      ((CsrWifiRouterCtrlMode) 0x00)
+#define CSR_WIFI_ROUTER_CTRL_MODE_IBSS      ((CsrWifiRouterCtrlMode) 0x01)
+#define CSR_WIFI_ROUTER_CTRL_MODE_STA       ((CsrWifiRouterCtrlMode) 0x02)
+#define CSR_WIFI_ROUTER_CTRL_MODE_AP        ((CsrWifiRouterCtrlMode) 0x03)
+#define CSR_WIFI_ROUTER_CTRL_MODE_MONITOR   ((CsrWifiRouterCtrlMode) 0x04)
+#define CSR_WIFI_ROUTER_CTRL_MODE_AMP       ((CsrWifiRouterCtrlMode) 0x05)
+#define CSR_WIFI_ROUTER_CTRL_MODE_P2P       ((CsrWifiRouterCtrlMode) 0x06)
+#define CSR_WIFI_ROUTER_CTRL_MODE_P2PGO     ((CsrWifiRouterCtrlMode) 0x07)
+#define CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI    ((CsrWifiRouterCtrlMode) 0x08)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerStatus
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE
+                   -
+    CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE
+                   -
+    CSR_WIFI_ROUTER_CTRL_PEER_DISCONNECTED
+                   -
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterCtrlPeerStatus;
+#define CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE       ((CsrWifiRouterCtrlPeerStatus) 0x00)
+#define CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE   ((CsrWifiRouterCtrlPeerStatus) 0x01)
+#define CSR_WIFI_ROUTER_CTRL_PEER_DISCONNECTED           ((CsrWifiRouterCtrlPeerStatus) 0x02)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPortAction
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN
+                   -
+    CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD
+                   -
+    CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_BLOCK
+                   -
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiRouterCtrlPortAction;
+#define CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN             ((CsrWifiRouterCtrlPortAction) 0x0000)
+#define CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD   ((CsrWifiRouterCtrlPortAction) 0x0001)
+#define CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_BLOCK     ((CsrWifiRouterCtrlPortAction) 0x0002)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPowersaveType
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_AC_BK_PS_INFO_PRESENT
+                   - If set, AC BK PS info is present in b4 and b5
+    CSR_WIFI_ROUTER_CTRL_AC_BE_PS_INFO_PRESENT
+                   - If set, AC BE PS info is present in b6 and b7
+    CSR_WIFI_ROUTER_CTRL_AC_VI_PS_INFO_PRESENT
+                   - If set, AC VI PS info is present in b8 and b9
+    CSR_WIFI_ROUTER_CTRL_AC_VO_PS_INFO_PRESENT
+                   - If set, AC VO PS info is present in b10 and b11
+    CSR_WIFI_ROUTER_CTRL_AC_BK_TRIGGER_ENABLED
+                   -
+    CSR_WIFI_ROUTER_CTRL_AC_BK_DELIVERY_ENABLED
+                   -
+    CSR_WIFI_ROUTER_CTRL_AC_BE_TRIGGER_ENABLED
+                   -
+    CSR_WIFI_ROUTER_CTRL_AC_BE_DELIVERY_ENABLED
+                   -
+    CSR_WIFI_ROUTER_CTRL_AC_VI_TRIGGER_ENABLED
+                   -
+    CSR_WIFI_ROUTER_CTRL_AC_VI_DELIVERY_ENABLED
+                   -
+    CSR_WIFI_ROUTER_CTRL_AC_VO_TRIGGER_ENABLED
+                   -
+    CSR_WIFI_ROUTER_CTRL_AC_VO_DELIVERY_ENABLED
+                   -
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiRouterCtrlPowersaveType;
+#define CSR_WIFI_ROUTER_CTRL_AC_BK_PS_INFO_PRESENT    ((CsrWifiRouterCtrlPowersaveType) 0x0001)
+#define CSR_WIFI_ROUTER_CTRL_AC_BE_PS_INFO_PRESENT    ((CsrWifiRouterCtrlPowersaveType) 0x0002)
+#define CSR_WIFI_ROUTER_CTRL_AC_VI_PS_INFO_PRESENT    ((CsrWifiRouterCtrlPowersaveType) 0x0004)
+#define CSR_WIFI_ROUTER_CTRL_AC_VO_PS_INFO_PRESENT    ((CsrWifiRouterCtrlPowersaveType) 0x0008)
+#define CSR_WIFI_ROUTER_CTRL_AC_BK_TRIGGER_ENABLED    ((CsrWifiRouterCtrlPowersaveType) 0x0010)
+#define CSR_WIFI_ROUTER_CTRL_AC_BK_DELIVERY_ENABLED   ((CsrWifiRouterCtrlPowersaveType) 0x0020)
+#define CSR_WIFI_ROUTER_CTRL_AC_BE_TRIGGER_ENABLED    ((CsrWifiRouterCtrlPowersaveType) 0x0040)
+#define CSR_WIFI_ROUTER_CTRL_AC_BE_DELIVERY_ENABLED   ((CsrWifiRouterCtrlPowersaveType) 0x0080)
+#define CSR_WIFI_ROUTER_CTRL_AC_VI_TRIGGER_ENABLED    ((CsrWifiRouterCtrlPowersaveType) 0x0100)
+#define CSR_WIFI_ROUTER_CTRL_AC_VI_DELIVERY_ENABLED   ((CsrWifiRouterCtrlPowersaveType) 0x0200)
+#define CSR_WIFI_ROUTER_CTRL_AC_VO_TRIGGER_ENABLED    ((CsrWifiRouterCtrlPowersaveType) 0x0400)
+#define CSR_WIFI_ROUTER_CTRL_AC_VO_DELIVERY_ENABLED   ((CsrWifiRouterCtrlPowersaveType) 0x0800)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlProtocolDirection
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_RX
+                   -
+    CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_TX
+                   -
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiRouterCtrlProtocolDirection;
+#define CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_RX   ((CsrWifiRouterCtrlProtocolDirection) 0x0000)
+#define CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_TX   ((CsrWifiRouterCtrlProtocolDirection) 0x0001)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlQoSControl
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_QOS_CONTROL_OFF
+                   -
+    CSR_WIFI_ROUTER_CTRL_QOS_CONTROL_WMM_ON
+                   -
+    CSR_WIFI_ROUTER_CTRL_QOS_CONTROL_80211_ON
+                   -
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiRouterCtrlQoSControl;
+#define CSR_WIFI_ROUTER_CTRL_QOS_CONTROL_OFF        ((CsrWifiRouterCtrlQoSControl) 0x0000)
+#define CSR_WIFI_ROUTER_CTRL_QOS_CONTROL_WMM_ON     ((CsrWifiRouterCtrlQoSControl) 0x0001)
+#define CSR_WIFI_ROUTER_CTRL_QOS_CONTROL_80211_ON   ((CsrWifiRouterCtrlQoSControl) 0x0002)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlQueueConfig
+
+  DESCRIPTION
+    Defines which Queues are enabled for use.
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_QUEUE_BE_ENABLE
+                   -
+    CSR_WIFI_ROUTER_CTRL_QUEUE_BK_ENABLE
+                   -
+    CSR_WIFI_ROUTER_CTRL_QUEUE_VI_ENABLE
+                   -
+    CSR_WIFI_ROUTER_CTRL_QUEUE_VO_ENABLE
+                   -
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterCtrlQueueConfig;
+#define CSR_WIFI_ROUTER_CTRL_QUEUE_BE_ENABLE   ((CsrWifiRouterCtrlQueueConfig) 0x01)
+#define CSR_WIFI_ROUTER_CTRL_QUEUE_BK_ENABLE   ((CsrWifiRouterCtrlQueueConfig) 0x02)
+#define CSR_WIFI_ROUTER_CTRL_QUEUE_VI_ENABLE   ((CsrWifiRouterCtrlQueueConfig) 0x04)
+#define CSR_WIFI_ROUTER_CTRL_QUEUE_VO_ENABLE   ((CsrWifiRouterCtrlQueueConfig) 0x08)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficConfigType
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_TYPE_RESET
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_TYPE_FILTER
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_TYPE_CLS
+                   -
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiRouterCtrlTrafficConfigType;
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_TYPE_RESET    ((CsrWifiRouterCtrlTrafficConfigType) 0x0000)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_TYPE_FILTER   ((CsrWifiRouterCtrlTrafficConfigType) 0x0001)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_TYPE_CLS      ((CsrWifiRouterCtrlTrafficConfigType) 0x0002)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficPacketType
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_NONE
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_EAPOL
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_DHCP
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_DHCP_ACK
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_ARP
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_AIRONET
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_CUSTOM
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_ALL
+                   -
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiRouterCtrlTrafficPacketType;
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_NONE       ((CsrWifiRouterCtrlTrafficPacketType) 0x0000)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_EAPOL      ((CsrWifiRouterCtrlTrafficPacketType) 0x0001)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_DHCP       ((CsrWifiRouterCtrlTrafficPacketType) 0x0002)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_DHCP_ACK   ((CsrWifiRouterCtrlTrafficPacketType) 0x0004)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_ARP        ((CsrWifiRouterCtrlTrafficPacketType) 0x0008)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_AIRONET    ((CsrWifiRouterCtrlTrafficPacketType) 0x0010)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_CUSTOM     ((CsrWifiRouterCtrlTrafficPacketType) 0x0020)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_ALL        ((CsrWifiRouterCtrlTrafficPacketType) 0x00FF)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficType
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_OCCASIONAL
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_BURSTY
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_PERIODIC
+                   -
+    CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_CONTINUOUS
+                   -
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterCtrlTrafficType;
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_OCCASIONAL   ((CsrWifiRouterCtrlTrafficType) 0x00)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_BURSTY       ((CsrWifiRouterCtrlTrafficType) 0x01)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_PERIODIC     ((CsrWifiRouterCtrlTrafficType) 0x02)
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_CONTINUOUS   ((CsrWifiRouterCtrlTrafficType) 0x03)
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerRecordHandle
+
+  DESCRIPTION
+
+*******************************************************************************/
+typedef CsrUint32 CsrWifiRouterCtrlPeerRecordHandle;
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPowersaveTypeMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by
+    CsrWifiRouterCtrlPowersaveType
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiRouterCtrlPowersaveTypeMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlQueueConfigMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiRouterCtrlQueueConfig
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterCtrlQueueConfigMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlRequestorInfo
+
+  DESCRIPTION
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiRouterCtrlRequestorInfo;
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficStreamId
+
+  DESCRIPTION
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterCtrlTrafficStreamId;
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlSmeVersions
+
+  DESCRIPTION
+
+  MEMBERS
+    firmwarePatch -
+    smeBuild      -
+    smeHip        -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint32      firmwarePatch;
+    CsrCharString *smeBuild;
+    CsrUint32      smeHip;
+} CsrWifiRouterCtrlSmeVersions;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlStaInfo
+
+  DESCRIPTION
+
+  MEMBERS
+    wmmOrQosEnabled     -
+    powersaveMode       -
+    maxSpLength         -
+    listenIntervalInTus -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrBool                            wmmOrQosEnabled;
+    CsrWifiRouterCtrlPowersaveTypeMask powersaveMode;
+    CsrUint8                           maxSpLength;
+    CsrUint16                          listenIntervalInTus;
+} CsrWifiRouterCtrlStaInfo;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficFilter
+
+  DESCRIPTION
+
+  MEMBERS
+    etherType     -
+    ipType        -
+    udpSourcePort -
+    udpDestPort   -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint32 etherType;
+    CsrUint8  ipType;
+    CsrUint32 udpSourcePort;
+    CsrUint32 udpDestPort;
+} CsrWifiRouterCtrlTrafficFilter;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficStats
+
+  DESCRIPTION
+
+  MEMBERS
+    rxMeanRate   - Mean rx data rate over the interval
+    rxFramesNum  - Keep number of Rx frames per second, for CYCLE_3.
+    txFramesNum  - Keep number of Tx frames per second, for CYCLE_3.
+    rxBytesCount - Keep calculated Rx throughput per second, for CYCLE_2.
+    txBytesCount - Keep calculated Tx throughput per second, for CYCLE_2.
+    intervals    - array size 11 MUST match TA_INTERVALS_NUM
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint32 rxMeanRate;
+    CsrUint32 rxFramesNum;
+    CsrUint32 txFramesNum;
+    CsrUint32 rxBytesCount;
+    CsrUint32 txBytesCount;
+    CsrUint8  intervals[11];
+} CsrWifiRouterCtrlTrafficStats;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlVersions
+
+  DESCRIPTION
+
+  MEMBERS
+    chipId        -
+    chipVersion   -
+    firmwareBuild -
+    firmwareHip   -
+    routerBuild   -
+    routerHip     -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint32      chipId;
+    CsrUint32      chipVersion;
+    CsrUint32      firmwareBuild;
+    CsrUint32      firmwareHip;
+    CsrCharString *routerBuild;
+    CsrUint32      routerHip;
+} CsrWifiRouterCtrlVersions;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficConfig
+
+  DESCRIPTION
+
+  MEMBERS
+    packetFilter -
+    customFilter -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint16                      packetFilter;
+    CsrWifiRouterCtrlTrafficFilter customFilter;
+} CsrWifiRouterCtrlTrafficConfig;
+
+
+/* Downstream */
+#define CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST            (0x0000)
+
+#define CSR_WIFI_ROUTER_CTRL_CONFIGURE_POWER_MODE_REQ     ((CsrWifiRouterCtrlPrim) (0x0000 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_HIP_REQ                      ((CsrWifiRouterCtrlPrim) (0x0001 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_MEDIA_STATUS_REQ             ((CsrWifiRouterCtrlPrim) (0x0002 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_MULTICAST_ADDRESS_RES        ((CsrWifiRouterCtrlPrim) (0x0003 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_PORT_CONFIGURE_REQ           ((CsrWifiRouterCtrlPrim) (0x0004 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_QOS_CONTROL_REQ              ((CsrWifiRouterCtrlPrim) (0x0005 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_SUSPEND_RES                  ((CsrWifiRouterCtrlPrim) (0x0006 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_TCLAS_ADD_REQ                ((CsrWifiRouterCtrlPrim) (0x0007 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_RESUME_RES                   ((CsrWifiRouterCtrlPrim) (0x0008 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_RAW_SDIO_DEINITIALISE_REQ    ((CsrWifiRouterCtrlPrim) (0x0009 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_RAW_SDIO_INITIALISE_REQ      ((CsrWifiRouterCtrlPrim) (0x000A + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_TCLAS_DEL_REQ                ((CsrWifiRouterCtrlPrim) (0x000B + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_CLASSIFICATION_REQ   ((CsrWifiRouterCtrlPrim) (0x000C + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_REQ           ((CsrWifiRouterCtrlPrim) (0x000D + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WIFI_OFF_REQ                 ((CsrWifiRouterCtrlPrim) (0x000E + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WIFI_OFF_RES                 ((CsrWifiRouterCtrlPrim) (0x000F + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WIFI_ON_REQ                  ((CsrWifiRouterCtrlPrim) (0x0010 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WIFI_ON_RES                  ((CsrWifiRouterCtrlPrim) (0x0011 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_M4_TRANSMIT_REQ              ((CsrWifiRouterCtrlPrim) (0x0012 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_MODE_SET_REQ                 ((CsrWifiRouterCtrlPrim) (0x0013 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_PEER_ADD_REQ                 ((CsrWifiRouterCtrlPrim) (0x0014 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_PEER_DEL_REQ                 ((CsrWifiRouterCtrlPrim) (0x0015 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_PEER_UPDATE_REQ              ((CsrWifiRouterCtrlPrim) (0x0016 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_CAPABILITIES_REQ             ((CsrWifiRouterCtrlPrim) (0x0017 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ENABLE_REQ         ((CsrWifiRouterCtrlPrim) (0x0018 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_DISABLE_REQ        ((CsrWifiRouterCtrlPrim) (0x0019 + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_REQ           ((CsrWifiRouterCtrlPrim) (0x001A + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_FILTER_REQ    ((CsrWifiRouterCtrlPrim) (0x001B + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WAPI_UNICAST_FILTER_REQ      ((CsrWifiRouterCtrlPrim) (0x001C + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST))
+
+
+#define CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_HIGHEST           (0x001C + CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST)
+
+/* Upstream */
+#define CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST              (0x0000 + CSR_PRIM_UPSTREAM)
+
+#define CSR_WIFI_ROUTER_CTRL_HIP_IND                      ((CsrWifiRouterCtrlPrim)(0x0000 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_MULTICAST_ADDRESS_IND        ((CsrWifiRouterCtrlPrim)(0x0001 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_PORT_CONFIGURE_CFM           ((CsrWifiRouterCtrlPrim)(0x0002 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_RESUME_IND                   ((CsrWifiRouterCtrlPrim)(0x0003 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_SUSPEND_IND                  ((CsrWifiRouterCtrlPrim)(0x0004 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_TCLAS_ADD_CFM                ((CsrWifiRouterCtrlPrim)(0x0005 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_RAW_SDIO_DEINITIALISE_CFM    ((CsrWifiRouterCtrlPrim)(0x0006 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_RAW_SDIO_INITIALISE_CFM      ((CsrWifiRouterCtrlPrim)(0x0007 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_TCLAS_DEL_CFM                ((CsrWifiRouterCtrlPrim)(0x0008 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_PROTOCOL_IND         ((CsrWifiRouterCtrlPrim)(0x0009 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_TRAFFIC_SAMPLE_IND           ((CsrWifiRouterCtrlPrim)(0x000A + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WIFI_OFF_IND                 ((CsrWifiRouterCtrlPrim)(0x000B + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WIFI_OFF_CFM                 ((CsrWifiRouterCtrlPrim)(0x000C + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WIFI_ON_IND                  ((CsrWifiRouterCtrlPrim)(0x000D + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WIFI_ON_CFM                  ((CsrWifiRouterCtrlPrim)(0x000E + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_M4_READY_TO_SEND_IND         ((CsrWifiRouterCtrlPrim)(0x000F + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_M4_TRANSMITTED_IND           ((CsrWifiRouterCtrlPrim)(0x0010 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_MIC_FAILURE_IND              ((CsrWifiRouterCtrlPrim)(0x0011 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_CONNECTED_IND                ((CsrWifiRouterCtrlPrim)(0x0012 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_PEER_ADD_CFM                 ((CsrWifiRouterCtrlPrim)(0x0013 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_PEER_DEL_CFM                 ((CsrWifiRouterCtrlPrim)(0x0014 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_UNEXPECTED_FRAME_IND         ((CsrWifiRouterCtrlPrim)(0x0015 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_PEER_UPDATE_CFM              ((CsrWifiRouterCtrlPrim)(0x0016 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_CAPABILITIES_CFM             ((CsrWifiRouterCtrlPrim)(0x0017 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ENABLE_CFM         ((CsrWifiRouterCtrlPrim)(0x0018 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_DISABLE_CFM        ((CsrWifiRouterCtrlPrim)(0x0019 + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ERROR_IND          ((CsrWifiRouterCtrlPrim)(0x001A + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_STA_INACTIVE_IND             ((CsrWifiRouterCtrlPrim)(0x001B + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_CTRL_WAPI_MULTICAST_IND           ((CsrWifiRouterCtrlPrim)(0x001C + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST))
+
+#define CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_HIGHEST             (0x001C + CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST)
+
+#define CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_COUNT             (CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_HIGHEST + 1 - CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST)
+#define CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_COUNT               (CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_HIGHEST   + 1 - CSR_WIFI_ROUTER_CTRL_PRIM_UPSTREAM_LOWEST)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlConfigurePowerModeReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+    mode       -
+    wakeHost   -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrWifiRouterCtrlLowPowerMode  mode;
+    CsrBool                        wakeHost;
+} CsrWifiRouterCtrlConfigurePowerModeReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlHipReq
+
+  DESCRIPTION
+    This primitive is used for transferring MLME messages to the HIP.
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    mlmeCommandLength - Length of the MLME signal
+    mlmeCommand       - Pointer to the MLME signal
+    dataRef1Length    - Length of the dataRef1 bulk data
+    dataRef1          - Pointer to the bulk data 1
+    dataRef2Length    - Length of the dataRef2 bulk data
+    dataRef2          - Pointer to the bulk data 2
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       mlmeCommandLength;
+    CsrUint8       *mlmeCommand;
+    CsrUint16       dataRef1Length;
+    CsrUint8       *dataRef1;
+    CsrUint16       dataRef2Length;
+    CsrUint8       *dataRef2;
+} CsrWifiRouterCtrlHipReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlMediaStatusReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    clientData   -
+    mediaStatus  -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrWifiRouterCtrlMediaStatus   mediaStatus;
+} CsrWifiRouterCtrlMediaStatusReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlMulticastAddressRes
+
+  DESCRIPTION
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    interfaceTag      -
+    clientData        -
+    status            -
+    action            -
+    getAddressesCount -
+    getAddresses      -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrResult                      status;
+    CsrWifiRouterCtrlListAction    action;
+    CsrUint8                       getAddressesCount;
+    CsrWifiMacAddress             *getAddresses;
+} CsrWifiRouterCtrlMulticastAddressRes;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPortConfigureReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common                 - Common header for use with the CsrWifiFsm Module
+    interfaceTag           -
+    clientData             -
+    uncontrolledPortAction -
+    controlledPortAction   -
+    macAddress             -
+    setProtection          -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrWifiRouterCtrlPortAction    uncontrolledPortAction;
+    CsrWifiRouterCtrlPortAction    controlledPortAction;
+    CsrWifiMacAddress              macAddress;
+    CsrBool                        setProtection;
+} CsrWifiRouterCtrlPortConfigureReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlQosControlReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    clientData   -
+    control      -
+    queueConfig  -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                  common;
+    CsrUint16                        interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo   clientData;
+    CsrWifiRouterCtrlQoSControl      control;
+    CsrWifiRouterCtrlQueueConfigMask queueConfig;
+} CsrWifiRouterCtrlQosControlReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlSuspendRes
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+    status     -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrResult                      status;
+} CsrWifiRouterCtrlSuspendRes;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTclasAddReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    clientData   -
+    tclasLength  -
+    tclas        -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      tclasLength;
+    CsrUint8                      *tclas;
+} CsrWifiRouterCtrlTclasAddReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlResumeRes
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+    status     -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrResult                      status;
+} CsrWifiRouterCtrlResumeRes;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlRawSdioDeinitialiseReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+} CsrWifiRouterCtrlRawSdioDeinitialiseReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlRawSdioInitialiseReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+} CsrWifiRouterCtrlRawSdioInitialiseReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTclasDelReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    clientData   -
+    tclasLength  -
+    tclas        -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      tclasLength;
+    CsrUint8                      *tclas;
+} CsrWifiRouterCtrlTclasDelReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficClassificationReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    clientData   -
+    trafficType  -
+    period       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrWifiRouterCtrlTrafficType   trafficType;
+    CsrUint16                      period;
+} CsrWifiRouterCtrlTrafficClassificationReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficConfigReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    interfaceTag      -
+    clientData        -
+    trafficConfigType -
+    config            -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                    common;
+    CsrUint16                          interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo     clientData;
+    CsrWifiRouterCtrlTrafficConfigType trafficConfigType;
+    CsrWifiRouterCtrlTrafficConfig     config;
+} CsrWifiRouterCtrlTrafficConfigReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOffReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+} CsrWifiRouterCtrlWifiOffReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOffRes
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+} CsrWifiRouterCtrlWifiOffRes;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOnReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+} CsrWifiRouterCtrlWifiOnReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOnRes
+
+  DESCRIPTION
+
+  MEMBERS
+    common              - Common header for use with the CsrWifiFsm Module
+    clientData          -
+    status              -
+    numInterfaceAddress -
+    stationMacAddress   - array size 1 MUST match CSR_WIFI_NUM_INTERFACES
+    smeVersions         -
+    scheduledInterrupt  -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrResult                      status;
+    CsrUint16                      numInterfaceAddress;
+    CsrWifiMacAddress              stationMacAddress[2];
+    CsrWifiRouterCtrlSmeVersions   smeVersions;
+    CsrBool                        scheduledInterrupt;
+} CsrWifiRouterCtrlWifiOnRes;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlM4TransmitReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    clientData   -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+} CsrWifiRouterCtrlM4TransmitReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlModeSetReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common              - Common header for use with the CsrWifiFsm Module
+    interfaceTag        -
+    clientData          -
+    mode                -
+    bssid               - BSSID of the network the device is going to be a part
+                          of
+    protection          - Set to TRUE if encryption is enabled for the
+                          connection/broadcast frames
+    intraBssDistEnabled - If set to TRUE, intra BSS destribution will be
+                          enabled. If set to FALSE, any unicast PDU which does
+                          not have the RA as the the local MAC address, shall be
+                          ignored. This field is interpreted by the receive if
+                          mode is set to CSR_WIFI_ROUTER_CTRL_MODE_P2PGO
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrWifiRouterCtrlMode          mode;
+    CsrWifiMacAddress              bssid;
+    CsrBool                        protection;
+    CsrBool                        intraBssDistEnabled;
+} CsrWifiRouterCtrlModeSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerAddReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   -
+    clientData     -
+    peerMacAddress -
+    associationId  -
+    staInfo        -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrWifiMacAddress              peerMacAddress;
+    CsrUint16                      associationId;
+    CsrWifiRouterCtrlStaInfo       staInfo;
+} CsrWifiRouterCtrlPeerAddReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerDelReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    interfaceTag     -
+    clientData       -
+    peerRecordHandle -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                   common;
+    CsrUint16                         interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo    clientData;
+    CsrWifiRouterCtrlPeerRecordHandle peerRecordHandle;
+} CsrWifiRouterCtrlPeerDelReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerUpdateReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    interfaceTag     -
+    clientData       -
+    peerRecordHandle -
+    powersaveMode    -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                    common;
+    CsrUint16                          interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo     clientData;
+    CsrWifiRouterCtrlPeerRecordHandle  peerRecordHandle;
+    CsrWifiRouterCtrlPowersaveTypeMask powersaveMode;
+} CsrWifiRouterCtrlPeerUpdateReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlCapabilitiesReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+} CsrWifiRouterCtrlCapabilitiesReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckEnableReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    interfaceTag    -
+    clientData      -
+    macAddress      -
+    trafficStreamID -
+    role            -
+    bufferSize      -
+    timeout         -
+    ssn             -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                  common;
+    CsrUint16                        interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo   clientData;
+    CsrWifiMacAddress                macAddress;
+    CsrWifiRouterCtrlTrafficStreamId trafficStreamID;
+    CsrWifiRouterCtrlBlockAckRole    role;
+    CsrUint16                        bufferSize;
+    CsrUint16                        timeout;
+    CsrUint16                        ssn;
+} CsrWifiRouterCtrlBlockAckEnableReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckDisableReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    interfaceTag    -
+    clientData      -
+    macAddress      -
+    trafficStreamID -
+    role            -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                  common;
+    CsrUint16                        interfaceTag;
+    CsrWifiRouterCtrlRequestorInfo   clientData;
+    CsrWifiMacAddress                macAddress;
+    CsrWifiRouterCtrlTrafficStreamId trafficStreamID;
+    CsrWifiRouterCtrlBlockAckRole    role;
+} CsrWifiRouterCtrlBlockAckDisableReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWapiMulticastReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    signalLength -
+    signal       -
+    dataLength   -
+    data         -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       signalLength;
+    CsrUint8       *signal;
+    CsrUint16       dataLength;
+    CsrUint8       *data;
+} CsrWifiRouterCtrlWapiMulticastReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWapiMulticastFilterReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint8        status;
+} CsrWifiRouterCtrlWapiMulticastFilterReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWapiUnicastFilterReq
+
+  DESCRIPTION
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint8        status;
+} CsrWifiRouterCtrlWapiUnicastFilterReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlHipInd
+
+  DESCRIPTION
+    This primitive is used for transferring MLME messages from the HIP.
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    mlmeCommandLength - Length of the MLME signal
+    mlmeCommand       - Pointer to the MLME signal
+    dataRef1Length    - Length of the dataRef1 bulk data
+    dataRef1          - Pointer to the bulk data 1
+    dataRef2Length    - Length of the dataRef2 bulk data
+    dataRef2          - Pointer to the bulk data 2
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       mlmeCommandLength;
+    CsrUint8       *mlmeCommand;
+    CsrUint16       dataRef1Length;
+    CsrUint8       *dataRef1;
+    CsrUint16       dataRef2Length;
+    CsrUint8       *dataRef2;
+} CsrWifiRouterCtrlHipInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlMulticastAddressInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    clientData        -
+    interfaceTag      -
+    action            -
+    setAddressesCount -
+    setAddresses      -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlListAction    action;
+    CsrUint8                       setAddressesCount;
+    CsrWifiMacAddress             *setAddresses;
+} CsrWifiRouterCtrlMulticastAddressInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPortConfigureCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    status       -
+    macAddress   -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrResult                      status;
+    CsrWifiMacAddress              macAddress;
+} CsrWifiRouterCtrlPortConfigureCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlResumeInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    clientData      -
+    powerMaintained -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrBool                        powerMaintained;
+} CsrWifiRouterCtrlResumeInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlSuspendInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common      - Common header for use with the CsrWifiFsm Module
+    clientData  -
+    hardSuspend -
+    d3Suspend   -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrBool                        hardSuspend;
+    CsrBool                        d3Suspend;
+} CsrWifiRouterCtrlSuspendInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTclasAddCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrResult                      status;
+} CsrWifiRouterCtrlTclasAddCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlRawSdioDeinitialiseCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+    result     -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrResult                      result;
+} CsrWifiRouterCtrlRawSdioDeinitialiseCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlRawSdioInitialiseCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    clientData       -
+    result           -
+    byteRead         -
+    byteWrite        -
+    firmwareDownload -
+    reset            -
+    coreDumpPrepare  -
+    byteBlockRead    -
+    gpRead16         -
+    gpWrite16        -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                          common;
+    CsrWifiRouterCtrlRequestorInfo           clientData;
+    CsrResult                                result;
+    CsrWifiRouterCtrlRawSdioByteRead         byteRead;
+    CsrWifiRouterCtrlRawSdioByteWrite        byteWrite;
+    CsrWifiRouterCtrlRawSdioFirmwareDownload firmwareDownload;
+    CsrWifiRouterCtrlRawSdioReset            reset;
+    CsrWifiRouterCtrlRawSdioCoreDumpPrepare  coreDumpPrepare;
+    CsrWifiRouterCtrlRawSdioByteBlockRead    byteBlockRead;
+    CsrWifiRouterCtrlRawSdioGpRead16         gpRead16;
+    CsrWifiRouterCtrlRawSdioGpWrite16        gpWrite16;
+} CsrWifiRouterCtrlRawSdioInitialiseCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTclasDelCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrResult                      status;
+} CsrWifiRouterCtrlTclasDelCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficProtocolInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    packetType   -
+    direction    -
+    srcAddress   -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                    common;
+    CsrWifiRouterCtrlRequestorInfo     clientData;
+    CsrUint16                          interfaceTag;
+    CsrWifiRouterCtrlTrafficPacketType packetType;
+    CsrWifiRouterCtrlProtocolDirection direction;
+    CsrWifiMacAddress                  srcAddress;
+} CsrWifiRouterCtrlTrafficProtocolInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlTrafficSampleInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    stats        -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrWifiRouterCtrlTrafficStats  stats;
+} CsrWifiRouterCtrlTrafficSampleInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOffInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    clientData        -
+    controlIndication -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                    common;
+    CsrWifiRouterCtrlRequestorInfo     clientData;
+    CsrWifiRouterCtrlControlIndication controlIndication;
+} CsrWifiRouterCtrlWifiOffInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOffCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+} CsrWifiRouterCtrlWifiOffCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOnInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+    status     -
+    versions   -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrResult                      status;
+    CsrWifiRouterCtrlVersions      versions;
+} CsrWifiRouterCtrlWifiOnInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWifiOnCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    clientData -
+    status     -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrResult                      status;
+} CsrWifiRouterCtrlWifiOnCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlM4ReadyToSendInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    clientData     -
+    interfaceTag   -
+    peerMacAddress -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrWifiMacAddress              peerMacAddress;
+} CsrWifiRouterCtrlM4ReadyToSendInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlM4TransmittedInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    clientData     -
+    interfaceTag   -
+    peerMacAddress -
+    status         -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrWifiMacAddress              peerMacAddress;
+    CsrResult                      status;
+} CsrWifiRouterCtrlM4TransmittedInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlMicFailureInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    clientData     -
+    interfaceTag   -
+    peerMacAddress -
+    unicastPdu     -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrWifiMacAddress              peerMacAddress;
+    CsrBool                        unicastPdu;
+} CsrWifiRouterCtrlMicFailureInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlConnectedInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    clientData     -
+    interfaceTag   -
+    peerMacAddress -
+    peerStatus     -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrWifiMacAddress              peerMacAddress;
+    CsrWifiRouterCtrlPeerStatus    peerStatus;
+} CsrWifiRouterCtrlConnectedInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerAddCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    clientData       -
+    interfaceTag     -
+    peerMacAddress   -
+    peerRecordHandle -
+    status           -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                   common;
+    CsrWifiRouterCtrlRequestorInfo    clientData;
+    CsrUint16                         interfaceTag;
+    CsrWifiMacAddress                 peerMacAddress;
+    CsrWifiRouterCtrlPeerRecordHandle peerRecordHandle;
+    CsrResult                         status;
+} CsrWifiRouterCtrlPeerAddCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerDelCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrResult                      status;
+} CsrWifiRouterCtrlPeerDelCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlUnexpectedFrameInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    clientData     -
+    interfaceTag   -
+    peerMacAddress -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrWifiMacAddress              peerMacAddress;
+} CsrWifiRouterCtrlUnexpectedFrameInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlPeerUpdateCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrResult                      status;
+} CsrWifiRouterCtrlPeerUpdateCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlCapabilitiesCfm
+
+  DESCRIPTION
+    The router sends this primitive to confirm the size of the queues of the
+    HIP.
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    clientData       -
+    commandQueueSize - Size of command queue
+    trafficQueueSize - Size of traffic queue (per AC)
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      commandQueueSize;
+    CsrUint16                      trafficQueueSize;
+} CsrWifiRouterCtrlCapabilitiesCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckEnableCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrResult                      status;
+} CsrWifiRouterCtrlBlockAckEnableCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckDisableCfm
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrResult                      status;
+} CsrWifiRouterCtrlBlockAckDisableCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlBlockAckErrorInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    clientData      -
+    interfaceTag    -
+    trafficStreamID -
+    peerMacAddress  -
+    status          -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                  common;
+    CsrWifiRouterCtrlRequestorInfo   clientData;
+    CsrUint16                        interfaceTag;
+    CsrWifiRouterCtrlTrafficStreamId trafficStreamID;
+    CsrWifiMacAddress                peerMacAddress;
+    CsrResult                        status;
+} CsrWifiRouterCtrlBlockAckErrorInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlStaInactiveInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    staAddress   -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrWifiMacAddress              staAddress;
+} CsrWifiRouterCtrlStaInactiveInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterCtrlWapiMulticastInd
+
+  DESCRIPTION
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    clientData   -
+    interfaceTag -
+    signalLength -
+    signal       -
+    dataLength   -
+    data         -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrWifiRouterCtrlRequestorInfo clientData;
+    CsrUint16                      interfaceTag;
+    CsrUint16                      signalLength;
+    CsrUint8                      *signal;
+    CsrUint16                      dataLength;
+    CsrUint8                      *data;
+} CsrWifiRouterCtrlWapiMulticastInd;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_CTRL_PRIM_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_ctrl_sef.c
@@ -0,0 +1,43 @@
+/*****************************************************************************
+
+  (c) Cambridge Silicon Radio Limited 2010
+  Confidential information of CSR
+
+  Refer to LICENSE.txt included with this source for details
+  on the license terms.
+
+ *****************************************************************************/
+#include "csr_wifi_router_ctrl_sef.h"
+
+const CsrWifiRouterCtrlStateHandlerType CsrWifiRouterCtrlDownstreamStateHandlers[CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_COUNT] =
+{
+    /* 0x0000 */ CsrWifiRouterCtrlConfigurePowerModeReqHandler,
+    /* 0x0001 */ CsrWifiRouterCtrlHipReqHandler,
+    /* 0x0002 */ CsrWifiRouterCtrlMediaStatusReqHandler,
+    /* 0x0003 */ CsrWifiRouterCtrlMulticastAddressResHandler,
+    /* 0x0004 */ CsrWifiRouterCtrlPortConfigureReqHandler,
+    /* 0x0005 */ CsrWifiRouterCtrlQosControlReqHandler,
+    /* 0x0006 */ CsrWifiRouterCtrlSuspendResHandler,
+    /* 0x0007 */ CsrWifiRouterCtrlTclasAddReqHandler,
+    /* 0x0008 */ CsrWifiRouterCtrlResumeResHandler,
+    /* 0x0009 */ CsrWifiRouterCtrlRawSdioDeinitialiseReqHandler,
+    /* 0x000A */ CsrWifiRouterCtrlRawSdioInitialiseReqHandler,
+    /* 0x000B */ CsrWifiRouterCtrlTclasDelReqHandler,
+    /* 0x000C */ CsrWifiRouterCtrlTrafficClassificationReqHandler,
+    /* 0x000D */ CsrWifiRouterCtrlTrafficConfigReqHandler,
+    /* 0x000E */ CsrWifiRouterCtrlWifiOffReqHandler,
+    /* 0x000F */ CsrWifiRouterCtrlWifiOffResHandler,
+    /* 0x0010 */ CsrWifiRouterCtrlWifiOnReqHandler,
+    /* 0x0011 */ CsrWifiRouterCtrlWifiOnResHandler,
+    /* 0x0012 */ CsrWifiRouterCtrlM4TransmitReqHandler,
+    /* 0x0013 */ CsrWifiRouterCtrlModeSetReqHandler,
+    /* 0x0014 */ CsrWifiRouterCtrlPeerAddReqHandler,
+    /* 0x0015 */ CsrWifiRouterCtrlPeerDelReqHandler,
+    /* 0x0016 */ CsrWifiRouterCtrlPeerUpdateReqHandler,
+    /* 0x0017 */ CsrWifiRouterCtrlCapabilitiesReqHandler,
+    CsrWifiRouterCtrlBlockAckEnableReqHandler,        /* 0x0018 */
+    CsrWifiRouterCtrlBlockAckDisableReqHandler,       /* 0x0019 */
+    CsrWifiRouterCtrlWapiMulticastReqHandler,         /* 0x001A */
+    CsrWifiRouterCtrlWapiMulticastFilterReqHandler,   /* 0x001B */
+    CsrWifiRouterCtrlWapiUnicastFilterReqHandler,     /* 0x001C */
+};
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_ctrl_sef.h
@@ -0,0 +1,56 @@
+/*****************************************************************************
+
+  (c) Cambridge Silicon Radio Limited 2010
+  Confidential information of CSR
+
+  Refer to LICENSE.txt included with this source for details
+  on the license terms.
+
+ *****************************************************************************/
+#ifndef CSR_WIFI_ROUTER_SEF_CSR_WIFI_ROUTER_CTRL_H__
+#define CSR_WIFI_ROUTER_SEF_CSR_WIFI_ROUTER_CTRL_H__
+
+#include "csr_wifi_router_ctrl_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    typedef void (*CsrWifiRouterCtrlStateHandlerType)(void* drvpriv, CsrWifiFsmEvent* msg);
+
+    extern const CsrWifiRouterCtrlStateHandlerType CsrWifiRouterCtrlDownstreamStateHandlers[CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_COUNT];
+
+    extern void CsrWifiRouterCtrlConfigurePowerModeReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlHipReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlMediaStatusReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlMulticastAddressResHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlPortConfigureReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlQosControlReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlSuspendResHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlTclasAddReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlResumeResHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlRawSdioDeinitialiseReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlRawSdioInitialiseReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlTclasDelReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlTrafficClassificationReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlTrafficConfigReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlWifiOffReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlWifiOffResHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlWifiOnReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlWifiOnResHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlM4TransmitReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlModeSetReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlPeerAddReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlPeerDelReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlPeerUpdateReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlCapabilitiesReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlBlockAckEnableReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlBlockAckDisableReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlWapiMulticastFilterReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlWapiMulticastReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterCtrlWapiUnicastFilterReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_SEF_CSR_WIFI_ROUTER_CTRL_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_ctrl_serialize.c
@@ -0,0 +1,2369 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_pmem.h"
+#include "csr_msgconv.h"
+#include "csr_unicode.h"
+
+
+#include "csr_wifi_router_ctrl_prim.h"
+#include "csr_wifi_router_ctrl_serialize.h"
+
+void CsrWifiRouterCtrlPfree(void *ptr)
+{
+    CsrPmemFree(ptr);
+}
+
+
+CsrSize CsrWifiRouterCtrlConfigurePowerModeReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 8) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrWifiRouterCtrlLowPowerMode primitive->mode */
+    bufferSize += 1; /* CsrBool primitive->wakeHost */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlConfigurePowerModeReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlConfigurePowerModeReq *primitive = (CsrWifiRouterCtrlConfigurePowerModeReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mode);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->wakeHost);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlConfigurePowerModeReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlConfigurePowerModeReq *primitive = (CsrWifiRouterCtrlConfigurePowerModeReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlConfigurePowerModeReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mode, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->wakeHost, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlHipReqSizeof(void *msg)
+{
+    CsrWifiRouterCtrlHipReq *primitive = (CsrWifiRouterCtrlHipReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 12) */
+    bufferSize += 2;                            /* CsrUint16 primitive->mlmeCommandLength */
+    bufferSize += primitive->mlmeCommandLength; /* CsrUint8 primitive->mlmeCommand */
+    bufferSize += 2;                            /* CsrUint16 primitive->dataRef1Length */
+    bufferSize += primitive->dataRef1Length;    /* CsrUint8 primitive->dataRef1 */
+    bufferSize += 2;                            /* CsrUint16 primitive->dataRef2Length */
+    bufferSize += primitive->dataRef2Length;    /* CsrUint8 primitive->dataRef2 */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlHipReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlHipReq *primitive = (CsrWifiRouterCtrlHipReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mlmeCommandLength);
+    if (primitive->mlmeCommandLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->mlmeCommand, ((CsrUint16) (primitive->mlmeCommandLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->dataRef1Length);
+    if (primitive->dataRef1Length)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->dataRef1, ((CsrUint16) (primitive->dataRef1Length)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->dataRef2Length);
+    if (primitive->dataRef2Length)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->dataRef2, ((CsrUint16) (primitive->dataRef2Length)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlHipReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlHipReq *primitive = (CsrWifiRouterCtrlHipReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlHipReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mlmeCommandLength, buffer, &offset);
+    if (primitive->mlmeCommandLength)
+    {
+        primitive->mlmeCommand = (CsrUint8 *)CsrPmemAlloc(primitive->mlmeCommandLength);
+        CsrMemCpyDes(primitive->mlmeCommand, buffer, &offset, ((CsrUint16) (primitive->mlmeCommandLength)));
+    }
+    else
+    {
+        primitive->mlmeCommand = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->dataRef1Length, buffer, &offset);
+    if (primitive->dataRef1Length)
+    {
+        primitive->dataRef1 = (CsrUint8 *)CsrPmemAlloc(primitive->dataRef1Length);
+        CsrMemCpyDes(primitive->dataRef1, buffer, &offset, ((CsrUint16) (primitive->dataRef1Length)));
+    }
+    else
+    {
+        primitive->dataRef1 = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->dataRef2Length, buffer, &offset);
+    if (primitive->dataRef2Length)
+    {
+        primitive->dataRef2 = (CsrUint8 *)CsrPmemAlloc(primitive->dataRef2Length);
+        CsrMemCpyDes(primitive->dataRef2, buffer, &offset, ((CsrUint16) (primitive->dataRef2Length)));
+    }
+    else
+    {
+        primitive->dataRef2 = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiRouterCtrlHipReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterCtrlHipReq *primitive = (CsrWifiRouterCtrlHipReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->mlmeCommand);
+    CsrPmemFree(primitive->dataRef1);
+    CsrPmemFree(primitive->dataRef2);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiRouterCtrlMediaStatusReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 8) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 1; /* CsrWifiRouterCtrlMediaStatus primitive->mediaStatus */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlMediaStatusReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlMediaStatusReq *primitive = (CsrWifiRouterCtrlMediaStatusReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->mediaStatus);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlMediaStatusReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlMediaStatusReq *primitive = (CsrWifiRouterCtrlMediaStatusReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlMediaStatusReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->mediaStatus, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlMulticastAddressResSizeof(void *msg)
+{
+    CsrWifiRouterCtrlMulticastAddressRes *primitive = (CsrWifiRouterCtrlMulticastAddressRes *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 17) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrWifiRouterCtrlListAction primitive->action */
+    bufferSize += 1; /* CsrUint8 primitive->getAddressesCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getAddressesCount; i1++)
+        {
+            bufferSize += 6; /* CsrUint8 primitive->getAddresses[i1].a[6] */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlMulticastAddressResSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlMulticastAddressRes *primitive = (CsrWifiRouterCtrlMulticastAddressRes *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->getAddressesCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getAddressesCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->getAddresses[i1].a, ((CsrUint16) (6)));
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlMulticastAddressResDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlMulticastAddressRes *primitive = (CsrWifiRouterCtrlMulticastAddressRes *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlMulticastAddressRes));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->getAddressesCount, buffer, &offset);
+    primitive->getAddresses = NULL;
+    if (primitive->getAddressesCount)
+    {
+        primitive->getAddresses = (CsrWifiMacAddress *)CsrPmemAlloc(sizeof(CsrWifiMacAddress) * primitive->getAddressesCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getAddressesCount; i1++)
+        {
+            CsrMemCpyDes(primitive->getAddresses[i1].a, buffer, &offset, ((CsrUint16) (6)));
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiRouterCtrlMulticastAddressResSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterCtrlMulticastAddressRes *primitive = (CsrWifiRouterCtrlMulticastAddressRes *) voidPrimitivePointer;
+    CsrPmemFree(primitive->getAddresses);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiRouterCtrlPortConfigureReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 18) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrWifiRouterCtrlPortAction primitive->uncontrolledPortAction */
+    bufferSize += 2; /* CsrWifiRouterCtrlPortAction primitive->controlledPortAction */
+    bufferSize += 6; /* CsrUint8 primitive->macAddress.a[6] */
+    bufferSize += 1; /* CsrBool primitive->setProtection */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlPortConfigureReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlPortConfigureReq *primitive = (CsrWifiRouterCtrlPortConfigureReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->uncontrolledPortAction);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->controlledPortAction);
+    CsrMemCpySer(ptr, len, (const void *) primitive->macAddress.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->setProtection);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlPortConfigureReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlPortConfigureReq *primitive = (CsrWifiRouterCtrlPortConfigureReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPortConfigureReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->uncontrolledPortAction, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->controlledPortAction, buffer, &offset);
+    CsrMemCpyDes(primitive->macAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->setProtection, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlQosControlReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 10) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrWifiRouterCtrlQoSControl primitive->control */
+    bufferSize += 1; /* CsrWifiRouterCtrlQueueConfigMask primitive->queueConfig */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlQosControlReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlQosControlReq *primitive = (CsrWifiRouterCtrlQosControlReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->control);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->queueConfig);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlQosControlReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlQosControlReq *primitive = (CsrWifiRouterCtrlQosControlReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlQosControlReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->control, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->queueConfig, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlSuspendResSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlSuspendResSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlSuspendRes *primitive = (CsrWifiRouterCtrlSuspendRes *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlSuspendResDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlSuspendRes *primitive = (CsrWifiRouterCtrlSuspendRes *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlSuspendRes));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlTclasAddReqSizeof(void *msg)
+{
+    CsrWifiRouterCtrlTclasAddReq *primitive = (CsrWifiRouterCtrlTclasAddReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 10) */
+    bufferSize += 2;                      /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2;                      /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2;                      /* CsrUint16 primitive->tclasLength */
+    bufferSize += primitive->tclasLength; /* CsrUint8 primitive->tclas */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlTclasAddReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlTclasAddReq *primitive = (CsrWifiRouterCtrlTclasAddReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->tclasLength);
+    if (primitive->tclasLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->tclas, ((CsrUint16) (primitive->tclasLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlTclasAddReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlTclasAddReq *primitive = (CsrWifiRouterCtrlTclasAddReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTclasAddReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->tclasLength, buffer, &offset);
+    if (primitive->tclasLength)
+    {
+        primitive->tclas = (CsrUint8 *)CsrPmemAlloc(primitive->tclasLength);
+        CsrMemCpyDes(primitive->tclas, buffer, &offset, ((CsrUint16) (primitive->tclasLength)));
+    }
+    else
+    {
+        primitive->tclas = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiRouterCtrlTclasAddReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterCtrlTclasAddReq *primitive = (CsrWifiRouterCtrlTclasAddReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->tclas);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiRouterCtrlResumeResSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlResumeResSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlResumeRes *primitive = (CsrWifiRouterCtrlResumeRes *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlResumeResDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlResumeRes *primitive = (CsrWifiRouterCtrlResumeRes *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlResumeRes));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlTclasDelReqSizeof(void *msg)
+{
+    CsrWifiRouterCtrlTclasDelReq *primitive = (CsrWifiRouterCtrlTclasDelReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 10) */
+    bufferSize += 2;                      /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2;                      /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2;                      /* CsrUint16 primitive->tclasLength */
+    bufferSize += primitive->tclasLength; /* CsrUint8 primitive->tclas */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlTclasDelReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlTclasDelReq *primitive = (CsrWifiRouterCtrlTclasDelReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->tclasLength);
+    if (primitive->tclasLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->tclas, ((CsrUint16) (primitive->tclasLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlTclasDelReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlTclasDelReq *primitive = (CsrWifiRouterCtrlTclasDelReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTclasDelReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->tclasLength, buffer, &offset);
+    if (primitive->tclasLength)
+    {
+        primitive->tclas = (CsrUint8 *)CsrPmemAlloc(primitive->tclasLength);
+        CsrMemCpyDes(primitive->tclas, buffer, &offset, ((CsrUint16) (primitive->tclasLength)));
+    }
+    else
+    {
+        primitive->tclas = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiRouterCtrlTclasDelReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterCtrlTclasDelReq *primitive = (CsrWifiRouterCtrlTclasDelReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->tclas);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiRouterCtrlTrafficClassificationReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 10) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 1; /* CsrWifiRouterCtrlTrafficType primitive->trafficType */
+    bufferSize += 2; /* CsrUint16 primitive->period */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlTrafficClassificationReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlTrafficClassificationReq *primitive = (CsrWifiRouterCtrlTrafficClassificationReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->trafficType);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->period);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlTrafficClassificationReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlTrafficClassificationReq *primitive = (CsrWifiRouterCtrlTrafficClassificationReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTrafficClassificationReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->trafficType, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->period, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlTrafficConfigReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 24) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrWifiRouterCtrlTrafficConfigType primitive->trafficConfigType */
+    bufferSize += 2; /* CsrUint16 primitive->config.packetFilter */
+    bufferSize += 4; /* CsrUint32 primitive->config.customFilter.etherType */
+    bufferSize += 1; /* CsrUint8 primitive->config.customFilter.ipType */
+    bufferSize += 4; /* CsrUint32 primitive->config.customFilter.udpSourcePort */
+    bufferSize += 4; /* CsrUint32 primitive->config.customFilter.udpDestPort */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlTrafficConfigReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlTrafficConfigReq *primitive = (CsrWifiRouterCtrlTrafficConfigReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->trafficConfigType);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->config.packetFilter);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->config.customFilter.etherType);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->config.customFilter.ipType);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->config.customFilter.udpSourcePort);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->config.customFilter.udpDestPort);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlTrafficConfigReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlTrafficConfigReq *primitive = (CsrWifiRouterCtrlTrafficConfigReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTrafficConfigReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->trafficConfigType, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->config.packetFilter, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->config.customFilter.etherType, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->config.customFilter.ipType, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->config.customFilter.udpSourcePort, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->config.customFilter.udpDestPort, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlWifiOnResSizeof(void *msg)
+{
+    CsrWifiRouterCtrlWifiOnRes *primitive = (CsrWifiRouterCtrlWifiOnRes *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 30) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 2; /* CsrUint16 primitive->numInterfaceAddress */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < 2; i1++)
+        {
+            bufferSize += 6;                                                                            /* CsrUint8 primitive->stationMacAddress[i1].a[6] */
+        }
+    }
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->smeVersions.firmwarePatch */
+    bufferSize += (primitive->smeVersions.smeBuild?CsrStrLen(primitive->smeVersions.smeBuild) : 0) + 1; /* CsrCharString* primitive->smeVersions.smeBuild (0 byte len + 1 for NULL Term) */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->smeVersions.smeHip */
+    bufferSize += 1;                                                                                    /* CsrBool primitive->scheduledInterrupt */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlWifiOnResSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlWifiOnRes *primitive = (CsrWifiRouterCtrlWifiOnRes *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->numInterfaceAddress);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < 2; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->stationMacAddress[i1].a, ((CsrUint16) (6)));
+        }
+    }
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->smeVersions.firmwarePatch);
+    CsrCharStringSer(ptr, len, primitive->smeVersions.smeBuild);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->smeVersions.smeHip);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scheduledInterrupt);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlWifiOnResDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlWifiOnRes *primitive = (CsrWifiRouterCtrlWifiOnRes *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOnRes));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->numInterfaceAddress, buffer, &offset);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < 2; i1++)
+        {
+            CsrMemCpyDes(primitive->stationMacAddress[i1].a, buffer, &offset, ((CsrUint16) (6)));
+        }
+    }
+    CsrUint32Des((CsrUint32 *) &primitive->smeVersions.firmwarePatch, buffer, &offset);
+    CsrCharStringDes(&primitive->smeVersions.smeBuild, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->smeVersions.smeHip, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scheduledInterrupt, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiRouterCtrlWifiOnResSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterCtrlWifiOnRes *primitive = (CsrWifiRouterCtrlWifiOnRes *) voidPrimitivePointer;
+    CsrPmemFree(primitive->smeVersions.smeBuild);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiRouterCtrlM4TransmitReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlM4TransmitReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlM4TransmitReq *primitive = (CsrWifiRouterCtrlM4TransmitReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlM4TransmitReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlM4TransmitReq *primitive = (CsrWifiRouterCtrlM4TransmitReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlM4TransmitReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlModeSetReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 16) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 1; /* CsrWifiRouterCtrlMode primitive->mode */
+    bufferSize += 6; /* CsrUint8 primitive->bssid.a[6] */
+    bufferSize += 1; /* CsrBool primitive->protection */
+    bufferSize += 1; /* CsrBool primitive->intraBssDistEnabled */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlModeSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlModeSetReq *primitive = (CsrWifiRouterCtrlModeSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->mode);
+    CsrMemCpySer(ptr, len, (const void *) primitive->bssid.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->protection);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->intraBssDistEnabled);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlModeSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlModeSetReq *primitive = (CsrWifiRouterCtrlModeSetReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlModeSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->mode, buffer, &offset);
+    CsrMemCpyDes(primitive->bssid.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->protection, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->intraBssDistEnabled, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlPeerAddReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 21) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 6; /* CsrUint8 primitive->peerMacAddress.a[6] */
+    bufferSize += 2; /* CsrUint16 primitive->associationId */
+    bufferSize += 1; /* CsrBool primitive->staInfo.wmmOrQosEnabled */
+    bufferSize += 2; /* CsrWifiRouterCtrlPowersaveTypeMask primitive->staInfo.powersaveMode */
+    bufferSize += 1; /* CsrUint8 primitive->staInfo.maxSpLength */
+    bufferSize += 2; /* CsrUint16 primitive->staInfo.listenIntervalInTus */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlPeerAddReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlPeerAddReq *primitive = (CsrWifiRouterCtrlPeerAddReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrMemCpySer(ptr, len, (const void *) primitive->peerMacAddress.a, ((CsrUint16) (6)));
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->associationId);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->staInfo.wmmOrQosEnabled);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->staInfo.powersaveMode);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->staInfo.maxSpLength);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->staInfo.listenIntervalInTus);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlPeerAddReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlPeerAddReq *primitive = (CsrWifiRouterCtrlPeerAddReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerAddReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrMemCpyDes(primitive->peerMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint16Des((CsrUint16 *) &primitive->associationId, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->staInfo.wmmOrQosEnabled, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->staInfo.powersaveMode, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->staInfo.maxSpLength, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->staInfo.listenIntervalInTus, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlPeerDelReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 11) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 4; /* CsrWifiRouterCtrlPeerRecordHandle primitive->peerRecordHandle */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlPeerDelReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlPeerDelReq *primitive = (CsrWifiRouterCtrlPeerDelReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->peerRecordHandle);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlPeerDelReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlPeerDelReq *primitive = (CsrWifiRouterCtrlPeerDelReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerDelReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->peerRecordHandle, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlPeerUpdateReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 4; /* CsrWifiRouterCtrlPeerRecordHandle primitive->peerRecordHandle */
+    bufferSize += 2; /* CsrWifiRouterCtrlPowersaveTypeMask primitive->powersaveMode */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlPeerUpdateReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlPeerUpdateReq *primitive = (CsrWifiRouterCtrlPeerUpdateReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->peerRecordHandle);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->powersaveMode);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlPeerUpdateReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlPeerUpdateReq *primitive = (CsrWifiRouterCtrlPeerUpdateReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerUpdateReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->peerRecordHandle, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->powersaveMode, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlBlockAckEnableReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 21) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 6; /* CsrUint8 primitive->macAddress.a[6] */
+    bufferSize += 1; /* CsrWifiRouterCtrlTrafficStreamId primitive->trafficStreamID */
+    bufferSize += 1; /* CsrWifiRouterCtrlBlockAckRole primitive->role */
+    bufferSize += 2; /* CsrUint16 primitive->bufferSize */
+    bufferSize += 2; /* CsrUint16 primitive->timeout */
+    bufferSize += 2; /* CsrUint16 primitive->ssn */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlBlockAckEnableReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlBlockAckEnableReq *primitive = (CsrWifiRouterCtrlBlockAckEnableReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrMemCpySer(ptr, len, (const void *) primitive->macAddress.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->trafficStreamID);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->role);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->bufferSize);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->timeout);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->ssn);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlBlockAckEnableReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlBlockAckEnableReq *primitive = (CsrWifiRouterCtrlBlockAckEnableReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlBlockAckEnableReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrMemCpyDes(primitive->macAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->trafficStreamID, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->role, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->bufferSize, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->timeout, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->ssn, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlBlockAckDisableReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 15) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 6; /* CsrUint8 primitive->macAddress.a[6] */
+    bufferSize += 1; /* CsrWifiRouterCtrlTrafficStreamId primitive->trafficStreamID */
+    bufferSize += 1; /* CsrWifiRouterCtrlBlockAckRole primitive->role */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlBlockAckDisableReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlBlockAckDisableReq *primitive = (CsrWifiRouterCtrlBlockAckDisableReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrMemCpySer(ptr, len, (const void *) primitive->macAddress.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->trafficStreamID);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->role);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlBlockAckDisableReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlBlockAckDisableReq *primitive = (CsrWifiRouterCtrlBlockAckDisableReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlBlockAckDisableReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrMemCpyDes(primitive->macAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->trafficStreamID, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->role, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlWapiMulticastReqSizeof(void *msg)
+{
+    CsrWifiRouterCtrlWapiMulticastReq *primitive = (CsrWifiRouterCtrlWapiMulticastReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2;                       /* CsrUint16 primitive->signalLength */
+    bufferSize += primitive->signalLength; /* CsrUint8 primitive->signal */
+    bufferSize += 2;                       /* CsrUint16 primitive->dataLength */
+    bufferSize += primitive->dataLength;   /* CsrUint8 primitive->data */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlWapiMulticastReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlWapiMulticastReq *primitive = (CsrWifiRouterCtrlWapiMulticastReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->signalLength);
+    if (primitive->signalLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->signal, ((CsrUint16) (primitive->signalLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->dataLength);
+    if (primitive->dataLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->data, ((CsrUint16) (primitive->dataLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlWapiMulticastReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlWapiMulticastReq *primitive = (CsrWifiRouterCtrlWapiMulticastReq *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWapiMulticastReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->signalLength, buffer, &offset);
+    if (primitive->signalLength)
+    {
+        primitive->signal = (CsrUint8 *)CsrPmemAlloc(primitive->signalLength);
+        CsrMemCpyDes(primitive->signal, buffer, &offset, ((CsrUint16) (primitive->signalLength)));
+    }
+    else
+    {
+        primitive->signal = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->dataLength, buffer, &offset);
+    if (primitive->dataLength)
+    {
+        primitive->data = (CsrUint8 *)CsrPmemAlloc(primitive->dataLength);
+        CsrMemCpyDes(primitive->data, buffer, &offset, ((CsrUint16) (primitive->dataLength)));
+    }
+    else
+    {
+        primitive->data = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiRouterCtrlWapiMulticastReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterCtrlWapiMulticastReq *primitive = (CsrWifiRouterCtrlWapiMulticastReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->signal);
+    CsrPmemFree(primitive->data);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiRouterCtrlHipIndSizeof(void *msg)
+{
+    CsrWifiRouterCtrlHipInd *primitive = (CsrWifiRouterCtrlHipInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 12) */
+    bufferSize += 2;                            /* CsrUint16 primitive->mlmeCommandLength */
+    bufferSize += primitive->mlmeCommandLength; /* CsrUint8 primitive->mlmeCommand */
+    bufferSize += 2;                            /* CsrUint16 primitive->dataRef1Length */
+    bufferSize += primitive->dataRef1Length;    /* CsrUint8 primitive->dataRef1 */
+    bufferSize += 2;                            /* CsrUint16 primitive->dataRef2Length */
+    bufferSize += primitive->dataRef2Length;    /* CsrUint8 primitive->dataRef2 */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlHipIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlHipInd *primitive = (CsrWifiRouterCtrlHipInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mlmeCommandLength);
+    if (primitive->mlmeCommandLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->mlmeCommand, ((CsrUint16) (primitive->mlmeCommandLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->dataRef1Length);
+    if (primitive->dataRef1Length)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->dataRef1, ((CsrUint16) (primitive->dataRef1Length)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->dataRef2Length);
+    if (primitive->dataRef2Length)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->dataRef2, ((CsrUint16) (primitive->dataRef2Length)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlHipIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlHipInd *primitive = (CsrWifiRouterCtrlHipInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlHipInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mlmeCommandLength, buffer, &offset);
+    if (primitive->mlmeCommandLength)
+    {
+        primitive->mlmeCommand = (CsrUint8 *)CsrPmemAlloc(primitive->mlmeCommandLength);
+        CsrMemCpyDes(primitive->mlmeCommand, buffer, &offset, ((CsrUint16) (primitive->mlmeCommandLength)));
+    }
+    else
+    {
+        primitive->mlmeCommand = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->dataRef1Length, buffer, &offset);
+    if (primitive->dataRef1Length)
+    {
+        primitive->dataRef1 = (CsrUint8 *)CsrPmemAlloc(primitive->dataRef1Length);
+        CsrMemCpyDes(primitive->dataRef1, buffer, &offset, ((CsrUint16) (primitive->dataRef1Length)));
+    }
+    else
+    {
+        primitive->dataRef1 = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->dataRef2Length, buffer, &offset);
+    if (primitive->dataRef2Length)
+    {
+        primitive->dataRef2 = (CsrUint8 *)CsrPmemAlloc(primitive->dataRef2Length);
+        CsrMemCpyDes(primitive->dataRef2, buffer, &offset, ((CsrUint16) (primitive->dataRef2Length)));
+    }
+    else
+    {
+        primitive->dataRef2 = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiRouterCtrlHipIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterCtrlHipInd *primitive = (CsrWifiRouterCtrlHipInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->mlmeCommand);
+    CsrPmemFree(primitive->dataRef1);
+    CsrPmemFree(primitive->dataRef2);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiRouterCtrlMulticastAddressIndSizeof(void *msg)
+{
+    CsrWifiRouterCtrlMulticastAddressInd *primitive = (CsrWifiRouterCtrlMulticastAddressInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 15) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrWifiRouterCtrlListAction primitive->action */
+    bufferSize += 1; /* CsrUint8 primitive->setAddressesCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setAddressesCount; i1++)
+        {
+            bufferSize += 6; /* CsrUint8 primitive->setAddresses[i1].a[6] */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlMulticastAddressIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlMulticastAddressInd *primitive = (CsrWifiRouterCtrlMulticastAddressInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->setAddressesCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setAddressesCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->setAddresses[i1].a, ((CsrUint16) (6)));
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlMulticastAddressIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlMulticastAddressInd *primitive = (CsrWifiRouterCtrlMulticastAddressInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlMulticastAddressInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->setAddressesCount, buffer, &offset);
+    primitive->setAddresses = NULL;
+    if (primitive->setAddressesCount)
+    {
+        primitive->setAddresses = (CsrWifiMacAddress *)CsrPmemAlloc(sizeof(CsrWifiMacAddress) * primitive->setAddressesCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setAddressesCount; i1++)
+        {
+            CsrMemCpyDes(primitive->setAddresses[i1].a, buffer, &offset, ((CsrUint16) (6)));
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiRouterCtrlMulticastAddressIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterCtrlMulticastAddressInd *primitive = (CsrWifiRouterCtrlMulticastAddressInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->setAddresses);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiRouterCtrlPortConfigureCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 15) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 6; /* CsrUint8 primitive->macAddress.a[6] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlPortConfigureCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlPortConfigureCfm *primitive = (CsrWifiRouterCtrlPortConfigureCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrMemCpySer(ptr, len, (const void *) primitive->macAddress.a, ((CsrUint16) (6)));
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlPortConfigureCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlPortConfigureCfm *primitive = (CsrWifiRouterCtrlPortConfigureCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPortConfigureCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrMemCpyDes(primitive->macAddress.a, buffer, &offset, ((CsrUint16) (6)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlSuspendIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 1; /* CsrBool primitive->hardSuspend */
+    bufferSize += 1; /* CsrBool primitive->d3Suspend */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlSuspendIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlSuspendInd *primitive = (CsrWifiRouterCtrlSuspendInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->hardSuspend);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->d3Suspend);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlSuspendIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlSuspendInd *primitive = (CsrWifiRouterCtrlSuspendInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlSuspendInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->hardSuspend, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->d3Suspend, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlTclasAddCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlTclasAddCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlTclasAddCfm *primitive = (CsrWifiRouterCtrlTclasAddCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlTclasAddCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlTclasAddCfm *primitive = (CsrWifiRouterCtrlTclasAddCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTclasAddCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlRawSdioDeinitialiseCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrResult primitive->result */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlRawSdioDeinitialiseCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlRawSdioDeinitialiseCfm *primitive = (CsrWifiRouterCtrlRawSdioDeinitialiseCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlRawSdioDeinitialiseCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlRawSdioDeinitialiseCfm *primitive = (CsrWifiRouterCtrlRawSdioDeinitialiseCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlRawSdioDeinitialiseCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->result, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlRawSdioInitialiseCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 39) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrResult primitive->result */
+    bufferSize += 4; /* CsrWifiRouterCtrlRawSdioByteRead primitive->byteRead */
+    bufferSize += 4; /* CsrWifiRouterCtrlRawSdioByteWrite primitive->byteWrite */
+    bufferSize += 4; /* CsrWifiRouterCtrlRawSdioFirmwareDownload primitive->firmwareDownload */
+    bufferSize += 4; /* CsrWifiRouterCtrlRawSdioReset primitive->reset */
+    bufferSize += 4; /* CsrWifiRouterCtrlRawSdioCoreDumpPrepare primitive->coreDumpPrepare */
+    bufferSize += 4; /* CsrWifiRouterCtrlRawSdioByteBlockRead primitive->byteBlockRead */
+    bufferSize += 4; /* CsrWifiRouterCtrlRawSdioGpRead16 primitive->gpRead16 */
+    bufferSize += 4; /* CsrWifiRouterCtrlRawSdioGpWrite16 primitive->gpWrite16 */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlRawSdioInitialiseCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlRawSdioInitialiseCfm *primitive = (CsrWifiRouterCtrlRawSdioInitialiseCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result);
+    CsrUint32Ser(ptr, len, 0); /* Special for Function Pointers... primitive->byteRead */
+    CsrUint32Ser(ptr, len, 0); /* Special for Function Pointers... primitive->byteWrite */
+    CsrUint32Ser(ptr, len, 0); /* Special for Function Pointers... primitive->firmwareDownload */
+    CsrUint32Ser(ptr, len, 0); /* Special for Function Pointers... primitive->reset */
+    CsrUint32Ser(ptr, len, 0); /* Special for Function Pointers... primitive->coreDumpPrepare */
+    CsrUint32Ser(ptr, len, 0); /* Special for Function Pointers... primitive->byteBlockRead */
+    CsrUint32Ser(ptr, len, 0); /* Special for Function Pointers... primitive->gpRead16 */
+    CsrUint32Ser(ptr, len, 0); /* Special for Function Pointers... primitive->gpWrite16 */
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlRawSdioInitialiseCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlRawSdioInitialiseCfm *primitive = (CsrWifiRouterCtrlRawSdioInitialiseCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlRawSdioInitialiseCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->result, buffer, &offset);
+    primitive->byteRead = NULL;         /* Special for Function Pointers... */
+    offset += 4;
+    primitive->byteWrite = NULL;        /* Special for Function Pointers... */
+    offset += 4;
+    primitive->firmwareDownload = NULL; /* Special for Function Pointers... */
+    offset += 4;
+    primitive->reset = NULL;            /* Special for Function Pointers... */
+    offset += 4;
+    primitive->coreDumpPrepare = NULL;  /* Special for Function Pointers... */
+    offset += 4;
+    primitive->byteBlockRead = NULL;    /* Special for Function Pointers... */
+    offset += 4;
+    primitive->gpRead16 = NULL;         /* Special for Function Pointers... */
+    offset += 4;
+    primitive->gpWrite16 = NULL;        /* Special for Function Pointers... */
+    offset += 4;
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlTclasDelCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlTclasDelCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlTclasDelCfm *primitive = (CsrWifiRouterCtrlTclasDelCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlTclasDelCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlTclasDelCfm *primitive = (CsrWifiRouterCtrlTclasDelCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTclasDelCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlTrafficProtocolIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 17) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrWifiRouterCtrlTrafficPacketType primitive->packetType */
+    bufferSize += 2; /* CsrWifiRouterCtrlProtocolDirection primitive->direction */
+    bufferSize += 6; /* CsrUint8 primitive->srcAddress.a[6] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlTrafficProtocolIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlTrafficProtocolInd *primitive = (CsrWifiRouterCtrlTrafficProtocolInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->packetType);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->direction);
+    CsrMemCpySer(ptr, len, (const void *) primitive->srcAddress.a, ((CsrUint16) (6)));
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlTrafficProtocolIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlTrafficProtocolInd *primitive = (CsrWifiRouterCtrlTrafficProtocolInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTrafficProtocolInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->packetType, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->direction, buffer, &offset);
+    CsrMemCpyDes(primitive->srcAddress.a, buffer, &offset, ((CsrUint16) (6)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlTrafficSampleIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 38) */
+    bufferSize += 2;  /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2;  /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 4;  /* CsrUint32 primitive->stats.rxMeanRate */
+    bufferSize += 4;  /* CsrUint32 primitive->stats.rxFramesNum */
+    bufferSize += 4;  /* CsrUint32 primitive->stats.txFramesNum */
+    bufferSize += 4;  /* CsrUint32 primitive->stats.rxBytesCount */
+    bufferSize += 4;  /* CsrUint32 primitive->stats.txBytesCount */
+    bufferSize += 11; /* CsrUint8 primitive->stats.intervals[11] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlTrafficSampleIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlTrafficSampleInd *primitive = (CsrWifiRouterCtrlTrafficSampleInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->stats.rxMeanRate);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->stats.rxFramesNum);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->stats.txFramesNum);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->stats.rxBytesCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->stats.txBytesCount);
+    CsrMemCpySer(ptr, len, (const void *) primitive->stats.intervals, ((CsrUint16) (11)));
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlTrafficSampleIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlTrafficSampleInd *primitive = (CsrWifiRouterCtrlTrafficSampleInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlTrafficSampleInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->stats.rxMeanRate, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->stats.rxFramesNum, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->stats.txFramesNum, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->stats.rxBytesCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->stats.txBytesCount, buffer, &offset);
+    CsrMemCpyDes(primitive->stats.intervals, buffer, &offset, ((CsrUint16) (11)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlWifiOnIndSizeof(void *msg)
+{
+    CsrWifiRouterCtrlWifiOnInd *primitive = (CsrWifiRouterCtrlWifiOnInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 27) */
+    bufferSize += 2;                                                                                    /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2;                                                                                    /* CsrResult primitive->status */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.chipId */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.chipVersion */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.firmwareBuild */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.firmwareHip */
+    bufferSize += (primitive->versions.routerBuild?CsrStrLen(primitive->versions.routerBuild) : 0) + 1; /* CsrCharString* primitive->versions.routerBuild (0 byte len + 1 for NULL Term) */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.routerHip */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlWifiOnIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlWifiOnInd *primitive = (CsrWifiRouterCtrlWifiOnInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.chipId);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.chipVersion);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.firmwareBuild);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.firmwareHip);
+    CsrCharStringSer(ptr, len, primitive->versions.routerBuild);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.routerHip);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlWifiOnIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlWifiOnInd *primitive = (CsrWifiRouterCtrlWifiOnInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOnInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.chipId, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.chipVersion, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.firmwareBuild, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.firmwareHip, buffer, &offset);
+    CsrCharStringDes(&primitive->versions.routerBuild, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.routerHip, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiRouterCtrlWifiOnIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterCtrlWifiOnInd *primitive = (CsrWifiRouterCtrlWifiOnInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->versions.routerBuild);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiRouterCtrlWifiOnCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlWifiOnCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlWifiOnCfm *primitive = (CsrWifiRouterCtrlWifiOnCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlWifiOnCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlWifiOnCfm *primitive = (CsrWifiRouterCtrlWifiOnCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWifiOnCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlM4ReadyToSendIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 6; /* CsrUint8 primitive->peerMacAddress.a[6] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlM4ReadyToSendIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlM4ReadyToSendInd *primitive = (CsrWifiRouterCtrlM4ReadyToSendInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrMemCpySer(ptr, len, (const void *) primitive->peerMacAddress.a, ((CsrUint16) (6)));
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlM4ReadyToSendIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlM4ReadyToSendInd *primitive = (CsrWifiRouterCtrlM4ReadyToSendInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlM4ReadyToSendInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrMemCpyDes(primitive->peerMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlM4TransmittedIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 15) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 6; /* CsrUint8 primitive->peerMacAddress.a[6] */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlM4TransmittedIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlM4TransmittedInd *primitive = (CsrWifiRouterCtrlM4TransmittedInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrMemCpySer(ptr, len, (const void *) primitive->peerMacAddress.a, ((CsrUint16) (6)));
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlM4TransmittedIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlM4TransmittedInd *primitive = (CsrWifiRouterCtrlM4TransmittedInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlM4TransmittedInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrMemCpyDes(primitive->peerMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlMicFailureIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 14) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 6; /* CsrUint8 primitive->peerMacAddress.a[6] */
+    bufferSize += 1; /* CsrBool primitive->unicastPdu */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlMicFailureIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlMicFailureInd *primitive = (CsrWifiRouterCtrlMicFailureInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrMemCpySer(ptr, len, (const void *) primitive->peerMacAddress.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->unicastPdu);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlMicFailureIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlMicFailureInd *primitive = (CsrWifiRouterCtrlMicFailureInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlMicFailureInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrMemCpyDes(primitive->peerMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->unicastPdu, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlConnectedIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 14) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 6; /* CsrUint8 primitive->peerMacAddress.a[6] */
+    bufferSize += 1; /* CsrWifiRouterCtrlPeerStatus primitive->peerStatus */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlConnectedIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlConnectedInd *primitive = (CsrWifiRouterCtrlConnectedInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrMemCpySer(ptr, len, (const void *) primitive->peerMacAddress.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->peerStatus);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlConnectedIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlConnectedInd *primitive = (CsrWifiRouterCtrlConnectedInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlConnectedInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrMemCpyDes(primitive->peerMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->peerStatus, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlPeerAddCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 19) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 6; /* CsrUint8 primitive->peerMacAddress.a[6] */
+    bufferSize += 4; /* CsrWifiRouterCtrlPeerRecordHandle primitive->peerRecordHandle */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlPeerAddCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlPeerAddCfm *primitive = (CsrWifiRouterCtrlPeerAddCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrMemCpySer(ptr, len, (const void *) primitive->peerMacAddress.a, ((CsrUint16) (6)));
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->peerRecordHandle);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlPeerAddCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlPeerAddCfm *primitive = (CsrWifiRouterCtrlPeerAddCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerAddCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrMemCpyDes(primitive->peerMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint32Des((CsrUint32 *) &primitive->peerRecordHandle, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlPeerDelCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlPeerDelCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlPeerDelCfm *primitive = (CsrWifiRouterCtrlPeerDelCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlPeerDelCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlPeerDelCfm *primitive = (CsrWifiRouterCtrlPeerDelCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerDelCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlUnexpectedFrameIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 6; /* CsrUint8 primitive->peerMacAddress.a[6] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlUnexpectedFrameIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlUnexpectedFrameInd *primitive = (CsrWifiRouterCtrlUnexpectedFrameInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrMemCpySer(ptr, len, (const void *) primitive->peerMacAddress.a, ((CsrUint16) (6)));
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlUnexpectedFrameIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlUnexpectedFrameInd *primitive = (CsrWifiRouterCtrlUnexpectedFrameInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlUnexpectedFrameInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrMemCpyDes(primitive->peerMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlPeerUpdateCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlPeerUpdateCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlPeerUpdateCfm *primitive = (CsrWifiRouterCtrlPeerUpdateCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlPeerUpdateCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlPeerUpdateCfm *primitive = (CsrWifiRouterCtrlPeerUpdateCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlPeerUpdateCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlCapabilitiesCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->commandQueueSize */
+    bufferSize += 2; /* CsrUint16 primitive->trafficQueueSize */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlCapabilitiesCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlCapabilitiesCfm *primitive = (CsrWifiRouterCtrlCapabilitiesCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->commandQueueSize);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->trafficQueueSize);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlCapabilitiesCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlCapabilitiesCfm *primitive = (CsrWifiRouterCtrlCapabilitiesCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlCapabilitiesCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->commandQueueSize, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->trafficQueueSize, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlBlockAckEnableCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlBlockAckEnableCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlBlockAckEnableCfm *primitive = (CsrWifiRouterCtrlBlockAckEnableCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlBlockAckEnableCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlBlockAckEnableCfm *primitive = (CsrWifiRouterCtrlBlockAckEnableCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlBlockAckEnableCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlBlockAckDisableCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlBlockAckDisableCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlBlockAckDisableCfm *primitive = (CsrWifiRouterCtrlBlockAckDisableCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlBlockAckDisableCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlBlockAckDisableCfm *primitive = (CsrWifiRouterCtrlBlockAckDisableCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlBlockAckDisableCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlBlockAckErrorIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 16) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrWifiRouterCtrlTrafficStreamId primitive->trafficStreamID */
+    bufferSize += 6; /* CsrUint8 primitive->peerMacAddress.a[6] */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlBlockAckErrorIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlBlockAckErrorInd *primitive = (CsrWifiRouterCtrlBlockAckErrorInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->trafficStreamID);
+    CsrMemCpySer(ptr, len, (const void *) primitive->peerMacAddress.a, ((CsrUint16) (6)));
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlBlockAckErrorIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlBlockAckErrorInd *primitive = (CsrWifiRouterCtrlBlockAckErrorInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlBlockAckErrorInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->trafficStreamID, buffer, &offset);
+    CsrMemCpyDes(primitive->peerMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlStaInactiveIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 6; /* CsrUint8 primitive->staAddress.a[6] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlStaInactiveIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlStaInactiveInd *primitive = (CsrWifiRouterCtrlStaInactiveInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrMemCpySer(ptr, len, (const void *) primitive->staAddress.a, ((CsrUint16) (6)));
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlStaInactiveIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlStaInactiveInd *primitive = (CsrWifiRouterCtrlStaInactiveInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlStaInactiveInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrMemCpyDes(primitive->staAddress.a, buffer, &offset, ((CsrUint16) (6)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterCtrlWapiMulticastIndSizeof(void *msg)
+{
+    CsrWifiRouterCtrlWapiMulticastInd *primitive = (CsrWifiRouterCtrlWapiMulticastInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2;                       /* CsrWifiRouterCtrlRequestorInfo primitive->clientData */
+    bufferSize += 2;                       /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2;                       /* CsrUint16 primitive->signalLength */
+    bufferSize += primitive->signalLength; /* CsrUint8 primitive->signal */
+    bufferSize += 2;                       /* CsrUint16 primitive->dataLength */
+    bufferSize += primitive->dataLength;   /* CsrUint8 primitive->data */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterCtrlWapiMulticastIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterCtrlWapiMulticastInd *primitive = (CsrWifiRouterCtrlWapiMulticastInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->clientData);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->signalLength);
+    if (primitive->signalLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->signal, ((CsrUint16) (primitive->signalLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->dataLength);
+    if (primitive->dataLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->data, ((CsrUint16) (primitive->dataLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiRouterCtrlWapiMulticastIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterCtrlWapiMulticastInd *primitive = (CsrWifiRouterCtrlWapiMulticastInd *) CsrPmemAlloc(sizeof(CsrWifiRouterCtrlWapiMulticastInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->clientData, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->signalLength, buffer, &offset);
+    if (primitive->signalLength)
+    {
+        primitive->signal = (CsrUint8 *)CsrPmemAlloc(primitive->signalLength);
+        CsrMemCpyDes(primitive->signal, buffer, &offset, ((CsrUint16) (primitive->signalLength)));
+    }
+    else
+    {
+        primitive->signal = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->dataLength, buffer, &offset);
+    if (primitive->dataLength)
+    {
+        primitive->data = (CsrUint8 *)CsrPmemAlloc(primitive->dataLength);
+        CsrMemCpyDes(primitive->data, buffer, &offset, ((CsrUint16) (primitive->dataLength)));
+    }
+    else
+    {
+        primitive->data = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiRouterCtrlWapiMulticastIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterCtrlWapiMulticastInd *primitive = (CsrWifiRouterCtrlWapiMulticastInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->signal);
+    CsrPmemFree(primitive->data);
+    CsrPmemFree(primitive);
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_ctrl_serialize.h
@@ -0,0 +1,323 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_ROUTER_CTRL_SERIALIZE_H__
+#define CSR_WIFI_ROUTER_CTRL_SERIALIZE_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_wifi_msgconv.h"
+
+#include "csr_wifi_router_ctrl_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void CsrWifiRouterCtrlPfree(void *ptr);
+
+extern CsrUint8* CsrWifiRouterCtrlConfigurePowerModeReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlConfigurePowerModeReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlConfigurePowerModeReqSizeof(void *msg);
+#define CsrWifiRouterCtrlConfigurePowerModeReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlHipReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlHipReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlHipReqSizeof(void *msg);
+extern void CsrWifiRouterCtrlHipReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiRouterCtrlMediaStatusReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlMediaStatusReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlMediaStatusReqSizeof(void *msg);
+#define CsrWifiRouterCtrlMediaStatusReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlMulticastAddressResSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlMulticastAddressResDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlMulticastAddressResSizeof(void *msg);
+extern void CsrWifiRouterCtrlMulticastAddressResSerFree(void *msg);
+
+extern CsrUint8* CsrWifiRouterCtrlPortConfigureReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlPortConfigureReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlPortConfigureReqSizeof(void *msg);
+#define CsrWifiRouterCtrlPortConfigureReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlQosControlReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlQosControlReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlQosControlReqSizeof(void *msg);
+#define CsrWifiRouterCtrlQosControlReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlSuspendResSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlSuspendResDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlSuspendResSizeof(void *msg);
+#define CsrWifiRouterCtrlSuspendResSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlTclasAddReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlTclasAddReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlTclasAddReqSizeof(void *msg);
+extern void CsrWifiRouterCtrlTclasAddReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiRouterCtrlResumeResSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlResumeResDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlResumeResSizeof(void *msg);
+#define CsrWifiRouterCtrlResumeResSerFree CsrWifiRouterCtrlPfree
+
+#define CsrWifiRouterCtrlRawSdioDeinitialiseReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiRouterCtrlRawSdioDeinitialiseReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiRouterCtrlRawSdioDeinitialiseReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiRouterCtrlRawSdioDeinitialiseReqSerFree CsrWifiRouterCtrlPfree
+
+#define CsrWifiRouterCtrlRawSdioInitialiseReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiRouterCtrlRawSdioInitialiseReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiRouterCtrlRawSdioInitialiseReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiRouterCtrlRawSdioInitialiseReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlTclasDelReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlTclasDelReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlTclasDelReqSizeof(void *msg);
+extern void CsrWifiRouterCtrlTclasDelReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiRouterCtrlTrafficClassificationReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlTrafficClassificationReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlTrafficClassificationReqSizeof(void *msg);
+#define CsrWifiRouterCtrlTrafficClassificationReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlTrafficConfigReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlTrafficConfigReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlTrafficConfigReqSizeof(void *msg);
+#define CsrWifiRouterCtrlTrafficConfigReqSerFree CsrWifiRouterCtrlPfree
+
+#define CsrWifiRouterCtrlWifiOffReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiRouterCtrlWifiOffReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiRouterCtrlWifiOffReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiRouterCtrlWifiOffReqSerFree CsrWifiRouterCtrlPfree
+
+#define CsrWifiRouterCtrlWifiOffResSer CsrWifiEventCsrUint16Ser
+#define CsrWifiRouterCtrlWifiOffResDes CsrWifiEventCsrUint16Des
+#define CsrWifiRouterCtrlWifiOffResSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiRouterCtrlWifiOffResSerFree CsrWifiRouterCtrlPfree
+
+#define CsrWifiRouterCtrlWifiOnReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiRouterCtrlWifiOnReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiRouterCtrlWifiOnReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiRouterCtrlWifiOnReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlWifiOnResSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlWifiOnResDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlWifiOnResSizeof(void *msg);
+extern void CsrWifiRouterCtrlWifiOnResSerFree(void *msg);
+
+extern CsrUint8* CsrWifiRouterCtrlM4TransmitReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlM4TransmitReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlM4TransmitReqSizeof(void *msg);
+#define CsrWifiRouterCtrlM4TransmitReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlModeSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlModeSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlModeSetReqSizeof(void *msg);
+#define CsrWifiRouterCtrlModeSetReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlPeerAddReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlPeerAddReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlPeerAddReqSizeof(void *msg);
+#define CsrWifiRouterCtrlPeerAddReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlPeerDelReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlPeerDelReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlPeerDelReqSizeof(void *msg);
+#define CsrWifiRouterCtrlPeerDelReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlPeerUpdateReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlPeerUpdateReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlPeerUpdateReqSizeof(void *msg);
+#define CsrWifiRouterCtrlPeerUpdateReqSerFree CsrWifiRouterCtrlPfree
+
+#define CsrWifiRouterCtrlCapabilitiesReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiRouterCtrlCapabilitiesReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiRouterCtrlCapabilitiesReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiRouterCtrlCapabilitiesReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlBlockAckEnableReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlBlockAckEnableReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlBlockAckEnableReqSizeof(void *msg);
+#define CsrWifiRouterCtrlBlockAckEnableReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlBlockAckDisableReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlBlockAckDisableReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlBlockAckDisableReqSizeof(void *msg);
+#define CsrWifiRouterCtrlBlockAckDisableReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlWapiMulticastReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlWapiMulticastReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlWapiMulticastReqSizeof(void *msg);
+extern void CsrWifiRouterCtrlWapiMulticastReqSerFree(void *msg);
+
+#define CsrWifiRouterCtrlWapiMulticastFilterReqSer CsrWifiEventCsrUint8Ser
+#define CsrWifiRouterCtrlWapiMulticastFilterReqDes CsrWifiEventCsrUint8Des
+#define CsrWifiRouterCtrlWapiMulticastFilterReqSizeof CsrWifiEventCsrUint8Sizeof
+#define CsrWifiRouterCtrlWapiMulticastFilterReqSerFree CsrWifiRouterCtrlPfree
+
+#define CsrWifiRouterCtrlWapiUnicastFilterReqSer CsrWifiEventCsrUint8Ser
+#define CsrWifiRouterCtrlWapiUnicastFilterReqDes CsrWifiEventCsrUint8Des
+#define CsrWifiRouterCtrlWapiUnicastFilterReqSizeof CsrWifiEventCsrUint8Sizeof
+#define CsrWifiRouterCtrlWapiUnicastFilterReqSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlHipIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlHipIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlHipIndSizeof(void *msg);
+extern void CsrWifiRouterCtrlHipIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiRouterCtrlMulticastAddressIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlMulticastAddressIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlMulticastAddressIndSizeof(void *msg);
+extern void CsrWifiRouterCtrlMulticastAddressIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiRouterCtrlPortConfigureCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlPortConfigureCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlPortConfigureCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlPortConfigureCfmSerFree CsrWifiRouterCtrlPfree
+
+#define CsrWifiRouterCtrlResumeIndSer CsrWifiEventCsrUint16CsrUint8Ser
+#define CsrWifiRouterCtrlResumeIndDes CsrWifiEventCsrUint16CsrUint8Des
+#define CsrWifiRouterCtrlResumeIndSizeof CsrWifiEventCsrUint16CsrUint8Sizeof
+#define CsrWifiRouterCtrlResumeIndSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlSuspendIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlSuspendIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlSuspendIndSizeof(void *msg);
+#define CsrWifiRouterCtrlSuspendIndSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlTclasAddCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlTclasAddCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlTclasAddCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlTclasAddCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlRawSdioDeinitialiseCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlRawSdioDeinitialiseCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlRawSdioDeinitialiseCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlRawSdioDeinitialiseCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlRawSdioInitialiseCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlRawSdioInitialiseCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlRawSdioInitialiseCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlRawSdioInitialiseCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlTclasDelCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlTclasDelCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlTclasDelCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlTclasDelCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlTrafficProtocolIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlTrafficProtocolIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlTrafficProtocolIndSizeof(void *msg);
+#define CsrWifiRouterCtrlTrafficProtocolIndSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlTrafficSampleIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlTrafficSampleIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlTrafficSampleIndSizeof(void *msg);
+#define CsrWifiRouterCtrlTrafficSampleIndSerFree CsrWifiRouterCtrlPfree
+
+#define CsrWifiRouterCtrlWifiOffIndSer CsrWifiEventCsrUint16CsrUint8Ser
+#define CsrWifiRouterCtrlWifiOffIndDes CsrWifiEventCsrUint16CsrUint8Des
+#define CsrWifiRouterCtrlWifiOffIndSizeof CsrWifiEventCsrUint16CsrUint8Sizeof
+#define CsrWifiRouterCtrlWifiOffIndSerFree CsrWifiRouterCtrlPfree
+
+#define CsrWifiRouterCtrlWifiOffCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiRouterCtrlWifiOffCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiRouterCtrlWifiOffCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiRouterCtrlWifiOffCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlWifiOnIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlWifiOnIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlWifiOnIndSizeof(void *msg);
+extern void CsrWifiRouterCtrlWifiOnIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiRouterCtrlWifiOnCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlWifiOnCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlWifiOnCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlWifiOnCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlM4ReadyToSendIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlM4ReadyToSendIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlM4ReadyToSendIndSizeof(void *msg);
+#define CsrWifiRouterCtrlM4ReadyToSendIndSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlM4TransmittedIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlM4TransmittedIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlM4TransmittedIndSizeof(void *msg);
+#define CsrWifiRouterCtrlM4TransmittedIndSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlMicFailureIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlMicFailureIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlMicFailureIndSizeof(void *msg);
+#define CsrWifiRouterCtrlMicFailureIndSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlConnectedIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlConnectedIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlConnectedIndSizeof(void *msg);
+#define CsrWifiRouterCtrlConnectedIndSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlPeerAddCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlPeerAddCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlPeerAddCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlPeerAddCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlPeerDelCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlPeerDelCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlPeerDelCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlPeerDelCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlUnexpectedFrameIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlUnexpectedFrameIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlUnexpectedFrameIndSizeof(void *msg);
+#define CsrWifiRouterCtrlUnexpectedFrameIndSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlPeerUpdateCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlPeerUpdateCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlPeerUpdateCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlPeerUpdateCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlCapabilitiesCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlCapabilitiesCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlCapabilitiesCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlCapabilitiesCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlBlockAckEnableCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlBlockAckEnableCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlBlockAckEnableCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlBlockAckEnableCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlBlockAckDisableCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlBlockAckDisableCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlBlockAckDisableCfmSizeof(void *msg);
+#define CsrWifiRouterCtrlBlockAckDisableCfmSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlBlockAckErrorIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlBlockAckErrorIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlBlockAckErrorIndSizeof(void *msg);
+#define CsrWifiRouterCtrlBlockAckErrorIndSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlStaInactiveIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlStaInactiveIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlStaInactiveIndSizeof(void *msg);
+#define CsrWifiRouterCtrlStaInactiveIndSerFree CsrWifiRouterCtrlPfree
+
+extern CsrUint8* CsrWifiRouterCtrlWapiMulticastIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterCtrlWapiMulticastIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterCtrlWapiMulticastIndSizeof(void *msg);
+extern void CsrWifiRouterCtrlWapiMulticastIndSerFree(void *msg);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* CSR_WIFI_ROUTER_CTRL_SERIALIZE_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_free_downstream_contents.c
@@ -0,0 +1,54 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_pmem.h"
+#include "csr_wifi_router_prim.h"
+#include "csr_wifi_router_lib.h"
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrWifiRouterFreeDownstreamMessageContents
+ *
+ *  DESCRIPTION
+ *
+ *
+ *  PARAMETERS
+ *      eventClass: only the value CSR_WIFI_ROUTER_PRIM will be handled
+ *      message:    the message to free
+ *----------------------------------------------------------------------------*/
+void CsrWifiRouterFreeDownstreamMessageContents(CsrUint16 eventClass, void *message)
+{
+    if (eventClass != CSR_WIFI_ROUTER_PRIM)
+    {
+        return;
+    }
+    if (NULL == message)
+    {
+        return;
+    }
+
+    switch (*((CsrWifiRouterPrim *) message))
+    {
+        case CSR_WIFI_ROUTER_MA_PACKET_REQ:
+        {
+            CsrWifiRouterMaPacketReq *p = (CsrWifiRouterMaPacketReq *)message;
+            CsrPmemFree(p->frame);
+            p->frame = NULL;
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_free_upstream_contents.c
@@ -0,0 +1,54 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_pmem.h"
+#include "csr_wifi_router_prim.h"
+#include "csr_wifi_router_lib.h"
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrWifiRouterFreeUpstreamMessageContents
+ *
+ *  DESCRIPTION
+ *
+ *
+ *  PARAMETERS
+ *      eventClass: only the value CSR_WIFI_ROUTER_PRIM will be handled
+ *      message:    the message to free
+ *----------------------------------------------------------------------------*/
+void CsrWifiRouterFreeUpstreamMessageContents(CsrUint16 eventClass, void *message)
+{
+    if (eventClass != CSR_WIFI_ROUTER_PRIM)
+    {
+        return;
+    }
+    if (NULL == message)
+    {
+        return;
+    }
+
+    switch (*((CsrWifiRouterPrim *) message))
+    {
+        case CSR_WIFI_ROUTER_MA_PACKET_IND:
+        {
+            CsrWifiRouterMaPacketInd *p = (CsrWifiRouterMaPacketInd *)message;
+            CsrPmemFree(p->frame);
+            p->frame = NULL;
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_lib.h
@@ -0,0 +1,429 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_ROUTER_LIB_H__
+#define CSR_WIFI_ROUTER_LIB_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_sched.h"
+#include "csr_util.h"
+#include "csr_msg_transport.h"
+
+#include "csr_wifi_lib.h"
+
+#include "csr_wifi_router_prim.h"
+#include "csr_wifi_router_task.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiRouterFreeUpstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_ROUTER upstream message. Does not
+ *      free the message itself, and can only be used for upstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_ROUTER upstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiRouterFreeUpstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiRouterFreeDownstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_ROUTER downstream message. Does not
+ *      free the message itself, and can only be used for downstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_ROUTER downstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiRouterFreeDownstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ * Enum to string functions
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiRouterAppTypeToString(CsrWifiRouterAppType value);
+const CsrCharString* CsrWifiRouterEncapsulationToString(CsrWifiRouterEncapsulation value);
+const CsrCharString* CsrWifiRouterOuiToString(CsrWifiRouterOui value);
+const CsrCharString* CsrWifiRouterPriorityToString(CsrWifiRouterPriority value);
+
+
+/*----------------------------------------------------------------------------*
+ * CsrPrim Type toString function.
+ * Converts a message type to the String name of the Message
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiRouterPrimTypeToString(CsrPrim msgType);
+
+/*----------------------------------------------------------------------------*
+ * Lookup arrays for PrimType name Strings
+ *----------------------------------------------------------------------------*/
+extern const CsrCharString *CsrWifiRouterUpstreamPrimNames[CSR_WIFI_ROUTER_PRIM_UPSTREAM_COUNT];
+extern const CsrCharString *CsrWifiRouterDownstreamPrimNames[CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_COUNT];
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketCancelReqSend
+
+  DESCRIPTION
+    This primitive is used to request cancellation of a previously send
+    CsrWifiRouterMaPacketReq.
+    The frame may already have been transmitted so there is no guarantees
+    that the CsrWifiRouterMaPacketCancelReq actually cancels the transmission
+    of the frame in question.
+    If the cancellation fails, the Router will send, if required,
+    CsrWifiRouterMaPacketCfm.
+    If the cancellation succeeds, the Router will not send
+    CsrWifiRouterMaPacketCfm.
+
+  PARAMETERS
+    queue          - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    hostTag        - The hostTag for the frame, which should be cancelled.
+    priority       - Priority of the frame, which should be cancelled
+    peerMacAddress - Destination MAC address of the frame, which should be
+                     cancelled
+
+*******************************************************************************/
+#define CsrWifiRouterMaPacketCancelReqCreate(msg__, dst__, src__, interfaceTag__, hostTag__, priority__, peerMacAddress__) \
+    msg__ = (CsrWifiRouterMaPacketCancelReq *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketCancelReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_PRIM, CSR_WIFI_ROUTER_MA_PACKET_CANCEL_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->hostTag = (hostTag__); \
+    msg__->priority = (priority__); \
+    msg__->peerMacAddress = (peerMacAddress__);
+
+#define CsrWifiRouterMaPacketCancelReqSendTo(dst__, src__, interfaceTag__, hostTag__, priority__, peerMacAddress__) \
+    { \
+        CsrWifiRouterMaPacketCancelReq *msg__; \
+        CsrWifiRouterMaPacketCancelReqCreate(msg__, dst__, src__, interfaceTag__, hostTag__, priority__, peerMacAddress__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterMaPacketCancelReqSend(src__, interfaceTag__, hostTag__, priority__, peerMacAddress__) \
+    CsrWifiRouterMaPacketCancelReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, hostTag__, priority__, peerMacAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketReqSend
+
+  DESCRIPTION
+    A task sends this primitive to transmit a frame.
+
+  PARAMETERS
+    queue              - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag       - Interface Identifier; unique identifier of an interface
+    subscriptionHandle - The handle of the subscription
+    frameLength        - Length of the frame to be sent in bytes
+    frame              - Pointer to the frame to be sent
+    freeFunction       - Pointer to function to be used to free the frame
+    priority           - Priority of the frame, which should be sent
+    hostTag            - An application shall set the bits b31..b28 using one of
+                         the CSR_WIFI_ROUTER_APP_TYPE_* masks. Bits b0..b27 can
+                         be used by the requestor without any restrictions, but
+                         the hostTag shall be unique so the hostTag for
+                         CSR_WIFI_ROUTER_APP _TYPE_OTHER should be constructured
+                         in the following way [ CSR_WIFI_ROUTER_APP_TYPE_OTHER
+                         (4 bits) | SubscriptionHandle (8 bits) | Sequence no.
+                         (20 bits) ]. If the hostTag is not unique, the
+                         behaviour of the system is unpredicatable with respect
+                         to data/management frame transfer.
+    cfmRequested       - Indicates if the requestor needs a confirm for packet
+                         requests sent under this subscription. If set to TRUE,
+                         the router will send a confirm, else it will not send
+                         any confirm
+
+*******************************************************************************/
+#define CsrWifiRouterMaPacketReqCreate(msg__, dst__, src__, interfaceTag__, subscriptionHandle__, frameLength__, frame__, freeFunction__, priority__, hostTag__, cfmRequested__) \
+    msg__ = (CsrWifiRouterMaPacketReq *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_PRIM, CSR_WIFI_ROUTER_MA_PACKET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->subscriptionHandle = (subscriptionHandle__); \
+    msg__->frameLength = (frameLength__); \
+    msg__->frame = (frame__); \
+    msg__->freeFunction = (freeFunction__); \
+    msg__->priority = (priority__); \
+    msg__->hostTag = (hostTag__); \
+    msg__->cfmRequested = (cfmRequested__);
+
+#define CsrWifiRouterMaPacketReqSendTo(dst__, src__, interfaceTag__, subscriptionHandle__, frameLength__, frame__, freeFunction__, priority__, hostTag__, cfmRequested__) \
+    { \
+        CsrWifiRouterMaPacketReq *msg__; \
+        CsrWifiRouterMaPacketReqCreate(msg__, dst__, src__, interfaceTag__, subscriptionHandle__, frameLength__, frame__, freeFunction__, priority__, hostTag__, cfmRequested__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterMaPacketReqSend(src__, interfaceTag__, subscriptionHandle__, frameLength__, frame__, freeFunction__, priority__, hostTag__, cfmRequested__) \
+    CsrWifiRouterMaPacketReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, subscriptionHandle__, frameLength__, frame__, freeFunction__, priority__, hostTag__, cfmRequested__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketIndSend
+
+  DESCRIPTION
+    The router sends the primitive to a subscribed task when it receives a
+    frame matching the subscription.
+
+  PARAMETERS
+    queue              - Destination Task Queue
+    interfaceTag       - Interface Identifier; unique identifier of an interface
+    subscriptionHandle - The handle of the subscription
+    result             - Status of the operation
+    frameLength        - Length of the received frame in bytes
+    frame              - Pointer to the received frame
+    freeFunction       - Pointer to function to be used to free the frame
+    rssi               - Received signal strength indication in dBm
+    snr                - Signal to Noise Ratio
+    rate               - Transmission/Reception rate
+
+*******************************************************************************/
+#define CsrWifiRouterMaPacketIndCreate(msg__, dst__, src__, interfaceTag__, subscriptionHandle__, result__, frameLength__, frame__, freeFunction__, rssi__, snr__, rate__) \
+    msg__ = (CsrWifiRouterMaPacketInd *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_PRIM, CSR_WIFI_ROUTER_MA_PACKET_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->subscriptionHandle = (subscriptionHandle__); \
+    msg__->result = (result__); \
+    msg__->frameLength = (frameLength__); \
+    msg__->frame = (frame__); \
+    msg__->freeFunction = (freeFunction__); \
+    msg__->rssi = (rssi__); \
+    msg__->snr = (snr__); \
+    msg__->rate = (rate__);
+
+#define CsrWifiRouterMaPacketIndSendTo(dst__, src__, interfaceTag__, subscriptionHandle__, result__, frameLength__, frame__, freeFunction__, rssi__, snr__, rate__) \
+    { \
+        CsrWifiRouterMaPacketInd *msg__; \
+        CsrWifiRouterMaPacketIndCreate(msg__, dst__, src__, interfaceTag__, subscriptionHandle__, result__, frameLength__, frame__, freeFunction__, rssi__, snr__, rate__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterMaPacketIndSend(dst__, interfaceTag__, subscriptionHandle__, result__, frameLength__, frame__, freeFunction__, rssi__, snr__, rate__) \
+    CsrWifiRouterMaPacketIndSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, interfaceTag__, subscriptionHandle__, result__, frameLength__, frame__, freeFunction__, rssi__, snr__, rate__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketResSend
+
+  DESCRIPTION
+    A task send this primitive to confirm the reception of the received
+    frame.
+
+  PARAMETERS
+    interfaceTag       - Interface Identifier; unique identifier of an interface
+    subscriptionHandle - The handle of the subscription
+    result             - Status of the operation
+
+*******************************************************************************/
+#define CsrWifiRouterMaPacketResCreate(msg__, dst__, src__, interfaceTag__, subscriptionHandle__, result__) \
+    msg__ = (CsrWifiRouterMaPacketRes *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketRes)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_PRIM, CSR_WIFI_ROUTER_MA_PACKET_RES, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->subscriptionHandle = (subscriptionHandle__); \
+    msg__->result = (result__);
+
+#define CsrWifiRouterMaPacketResSendTo(dst__, src__, interfaceTag__, subscriptionHandle__, result__) \
+    { \
+        CsrWifiRouterMaPacketRes *msg__; \
+        CsrWifiRouterMaPacketResCreate(msg__, dst__, src__, interfaceTag__, subscriptionHandle__, result__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterMaPacketResSend(src__, interfaceTag__, subscriptionHandle__, result__) \
+    CsrWifiRouterMaPacketResSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, subscriptionHandle__, result__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketCfmSend
+
+  DESCRIPTION
+    The router sends the primitive to confirm the result of the transmission
+    of the packet of the corresponding CSR_WIFI_ROUTER MA_PACKET_REQ request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    result       - Status of the operation
+    hostTag      - The hostTrag will match the hostTag sent in the request.
+    rate         - Transmission/Reception rate
+
+*******************************************************************************/
+#define CsrWifiRouterMaPacketCfmCreate(msg__, dst__, src__, interfaceTag__, result__, hostTag__, rate__) \
+    msg__ = (CsrWifiRouterMaPacketCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_PRIM, CSR_WIFI_ROUTER_MA_PACKET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->result = (result__); \
+    msg__->hostTag = (hostTag__); \
+    msg__->rate = (rate__);
+
+#define CsrWifiRouterMaPacketCfmSendTo(dst__, src__, interfaceTag__, result__, hostTag__, rate__) \
+    { \
+        CsrWifiRouterMaPacketCfm *msg__; \
+        CsrWifiRouterMaPacketCfmCreate(msg__, dst__, src__, interfaceTag__, result__, hostTag__, rate__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterMaPacketCfmSend(dst__, interfaceTag__, result__, hostTag__, rate__) \
+    CsrWifiRouterMaPacketCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, interfaceTag__, result__, hostTag__, rate__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketSubscribeReqSend
+
+  DESCRIPTION
+    A task can use this primitive to subscribe for a particular OUI/protocol
+    and transmit and receive frames matching the subscription.
+    NOTE: Multiple subscriptions for a given protocol and OUI will result in
+    the first subscription receiving the data and not the subsequent
+    subscriptions.
+
+  PARAMETERS
+    queue         - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    encapsulation - Specifies the encapsulation type, which will be used for the
+                    subscription
+    protocol      - Together with the OUI, specifies the protocol, which a task
+                    wants to subscribe to
+    oui           - Specifies the OUI for the protocol, which a task wants to
+                    subscribe to
+
+*******************************************************************************/
+#define CsrWifiRouterMaPacketSubscribeReqCreate(msg__, dst__, src__, interfaceTag__, encapsulation__, protocol__, oui__) \
+    msg__ = (CsrWifiRouterMaPacketSubscribeReq *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketSubscribeReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_PRIM, CSR_WIFI_ROUTER_MA_PACKET_SUBSCRIBE_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->encapsulation = (encapsulation__); \
+    msg__->protocol = (protocol__); \
+    msg__->oui = (oui__);
+
+#define CsrWifiRouterMaPacketSubscribeReqSendTo(dst__, src__, interfaceTag__, encapsulation__, protocol__, oui__) \
+    { \
+        CsrWifiRouterMaPacketSubscribeReq *msg__; \
+        CsrWifiRouterMaPacketSubscribeReqCreate(msg__, dst__, src__, interfaceTag__, encapsulation__, protocol__, oui__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterMaPacketSubscribeReqSend(src__, interfaceTag__, encapsulation__, protocol__, oui__) \
+    CsrWifiRouterMaPacketSubscribeReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, encapsulation__, protocol__, oui__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketSubscribeCfmSend
+
+  DESCRIPTION
+    The router sends this primitive to confirm the result of the
+    subscription.
+
+  PARAMETERS
+    queue              - Destination Task Queue
+    interfaceTag       - Interface Identifier; unique identifier of an interface
+    subscriptionHandle - Handle to the subscription
+                         This handle must be used in all subsequent requests
+    status             - Status of the operation
+    allocOffset        - Size of the offset for the frames of the subscription
+
+*******************************************************************************/
+#define CsrWifiRouterMaPacketSubscribeCfmCreate(msg__, dst__, src__, interfaceTag__, subscriptionHandle__, status__, allocOffset__) \
+    msg__ = (CsrWifiRouterMaPacketSubscribeCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketSubscribeCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_PRIM, CSR_WIFI_ROUTER_MA_PACKET_SUBSCRIBE_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->subscriptionHandle = (subscriptionHandle__); \
+    msg__->status = (status__); \
+    msg__->allocOffset = (allocOffset__);
+
+#define CsrWifiRouterMaPacketSubscribeCfmSendTo(dst__, src__, interfaceTag__, subscriptionHandle__, status__, allocOffset__) \
+    { \
+        CsrWifiRouterMaPacketSubscribeCfm *msg__; \
+        CsrWifiRouterMaPacketSubscribeCfmCreate(msg__, dst__, src__, interfaceTag__, subscriptionHandle__, status__, allocOffset__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterMaPacketSubscribeCfmSend(dst__, interfaceTag__, subscriptionHandle__, status__, allocOffset__) \
+    CsrWifiRouterMaPacketSubscribeCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, interfaceTag__, subscriptionHandle__, status__, allocOffset__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketUnsubscribeReqSend
+
+  DESCRIPTION
+    A task sends this primitive to unsubscribe a subscription
+
+  PARAMETERS
+    queue              - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag       - Interface Identifier; unique identifier of an interface
+    subscriptionHandle - The handle of the subscription
+
+*******************************************************************************/
+#define CsrWifiRouterMaPacketUnsubscribeReqCreate(msg__, dst__, src__, interfaceTag__, subscriptionHandle__) \
+    msg__ = (CsrWifiRouterMaPacketUnsubscribeReq *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketUnsubscribeReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_PRIM, CSR_WIFI_ROUTER_MA_PACKET_UNSUBSCRIBE_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->subscriptionHandle = (subscriptionHandle__);
+
+#define CsrWifiRouterMaPacketUnsubscribeReqSendTo(dst__, src__, interfaceTag__, subscriptionHandle__) \
+    { \
+        CsrWifiRouterMaPacketUnsubscribeReq *msg__; \
+        CsrWifiRouterMaPacketUnsubscribeReqCreate(msg__, dst__, src__, interfaceTag__, subscriptionHandle__); \
+        CsrMsgTransport(dst__, CSR_WIFI_ROUTER_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterMaPacketUnsubscribeReqSend(src__, interfaceTag__, subscriptionHandle__) \
+    CsrWifiRouterMaPacketUnsubscribeReqSendTo(CSR_WIFI_ROUTER_IFACEQUEUE, src__, interfaceTag__, subscriptionHandle__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketUnsubscribeCfmSend
+
+  DESCRIPTION
+    The router sends this primitive to confirm the result of the
+    unsubscription.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Status of the operation
+
+*******************************************************************************/
+#define CsrWifiRouterMaPacketUnsubscribeCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiRouterMaPacketUnsubscribeCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketUnsubscribeCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_ROUTER_PRIM, CSR_WIFI_ROUTER_MA_PACKET_UNSUBSCRIBE_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiRouterMaPacketUnsubscribeCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiRouterMaPacketUnsubscribeCfm *msg__; \
+        CsrWifiRouterMaPacketUnsubscribeCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_ROUTER_PRIM, msg__); \
+    }
+
+#define CsrWifiRouterMaPacketUnsubscribeCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiRouterMaPacketUnsubscribeCfmSendTo(dst__, CSR_WIFI_ROUTER_IFACEQUEUE, interfaceTag__, status__)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_LIB_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_prim.h
@@ -0,0 +1,430 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_ROUTER_PRIM_H__
+#define CSR_WIFI_ROUTER_PRIM_H__
+
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+#include "csr_sched.h"
+#include "csr_wifi_common.h"
+#include "csr_result.h"
+#include "csr_wifi_fsm_event.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CSR_WIFI_ROUTER_PRIM                                            (0x0400)
+
+typedef CsrPrim CsrWifiRouterPrim;
+
+typedef void (*CsrWifiRouterFrameFreeFunction)(void *frame);
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterAppType
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_APP_TYPE_SME   -
+    CSR_WIFI_ROUTER_APP_TYPE_PAL   -
+    CSR_WIFI_ROUTER_APP_TYPE_NME   -
+    CSR_WIFI_ROUTER_APP_TYPE_OTHER -
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterAppType;
+#define CSR_WIFI_ROUTER_APP_TYPE_SME     ((CsrWifiRouterAppType) 0x0)
+#define CSR_WIFI_ROUTER_APP_TYPE_PAL     ((CsrWifiRouterAppType) 0x1)
+#define CSR_WIFI_ROUTER_APP_TYPE_NME     ((CsrWifiRouterAppType) 0x2)
+#define CSR_WIFI_ROUTER_APP_TYPE_OTHER   ((CsrWifiRouterAppType) 0x3)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterEncapsulation
+
+  DESCRIPTION
+    Indicates the type of encapsulation used for the subscription
+
+ VALUES
+    CSR_WIFI_ROUTER_ENCAPSULATION_ETHERNET
+                   - Ethernet encapsulation
+    CSR_WIFI_ROUTER_ENCAPSULATION_LLC_SNAP
+                   - LLC/SNAP encapsulation
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiRouterEncapsulation;
+#define CSR_WIFI_ROUTER_ENCAPSULATION_ETHERNET   ((CsrWifiRouterEncapsulation) 0x00)
+#define CSR_WIFI_ROUTER_ENCAPSULATION_LLC_SNAP   ((CsrWifiRouterEncapsulation) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterOui
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_ROUTER_OUI_RFC_1042 -
+    CSR_WIFI_ROUTER_OUI_BT       -
+
+*******************************************************************************/
+typedef CsrUint32 CsrWifiRouterOui;
+#define CSR_WIFI_ROUTER_OUI_RFC_1042   ((CsrWifiRouterOui) 0x000000)
+#define CSR_WIFI_ROUTER_OUI_BT         ((CsrWifiRouterOui) 0x001958)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterPriority
+
+  DESCRIPTION
+    As defined in the IEEE 802.11 standards
+
+ VALUES
+    CSR_WIFI_ROUTER_PRIORITY_QOS_UP0
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_ROUTER_PRIORITY_QOS_UP1
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_ROUTER_PRIORITY_QOS_UP2
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_ROUTER_PRIORITY_QOS_UP3
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_ROUTER_PRIORITY_QOS_UP4
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_ROUTER_PRIORITY_QOS_UP5
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_ROUTER_PRIORITY_QOS_UP6
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_ROUTER_PRIORITY_QOS_UP7
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_ROUTER_PRIORITY_CONTENTION
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_ROUTER_PRIORITY_MANAGEMENT
+                   - See IEEE 802.11 Standard
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiRouterPriority;
+#define CSR_WIFI_ROUTER_PRIORITY_QOS_UP0      ((CsrWifiRouterPriority) 0x0000)
+#define CSR_WIFI_ROUTER_PRIORITY_QOS_UP1      ((CsrWifiRouterPriority) 0x0001)
+#define CSR_WIFI_ROUTER_PRIORITY_QOS_UP2      ((CsrWifiRouterPriority) 0x0002)
+#define CSR_WIFI_ROUTER_PRIORITY_QOS_UP3      ((CsrWifiRouterPriority) 0x0003)
+#define CSR_WIFI_ROUTER_PRIORITY_QOS_UP4      ((CsrWifiRouterPriority) 0x0004)
+#define CSR_WIFI_ROUTER_PRIORITY_QOS_UP5      ((CsrWifiRouterPriority) 0x0005)
+#define CSR_WIFI_ROUTER_PRIORITY_QOS_UP6      ((CsrWifiRouterPriority) 0x0006)
+#define CSR_WIFI_ROUTER_PRIORITY_QOS_UP7      ((CsrWifiRouterPriority) 0x0007)
+#define CSR_WIFI_ROUTER_PRIORITY_CONTENTION   ((CsrWifiRouterPriority) 0x8000)
+#define CSR_WIFI_ROUTER_PRIORITY_MANAGEMENT   ((CsrWifiRouterPriority) 0x8010)
+
+
+/* Downstream */
+#define CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_LOWEST            (0x0000)
+
+#define CSR_WIFI_ROUTER_MA_PACKET_SUBSCRIBE_REQ           ((CsrWifiRouterPrim) (0x0000 + CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_MA_PACKET_UNSUBSCRIBE_REQ         ((CsrWifiRouterPrim) (0x0001 + CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_MA_PACKET_REQ                     ((CsrWifiRouterPrim) (0x0002 + CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_MA_PACKET_RES                     ((CsrWifiRouterPrim) (0x0003 + CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_MA_PACKET_CANCEL_REQ              ((CsrWifiRouterPrim) (0x0004 + CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_LOWEST))
+
+
+#define CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_HIGHEST           (0x0004 + CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_LOWEST)
+
+/* Upstream */
+#define CSR_WIFI_ROUTER_PRIM_UPSTREAM_LOWEST              (0x0000 + CSR_PRIM_UPSTREAM)
+
+#define CSR_WIFI_ROUTER_MA_PACKET_SUBSCRIBE_CFM           ((CsrWifiRouterPrim)(0x0000 + CSR_WIFI_ROUTER_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_MA_PACKET_UNSUBSCRIBE_CFM         ((CsrWifiRouterPrim)(0x0001 + CSR_WIFI_ROUTER_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_MA_PACKET_CFM                     ((CsrWifiRouterPrim)(0x0002 + CSR_WIFI_ROUTER_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_ROUTER_MA_PACKET_IND                     ((CsrWifiRouterPrim)(0x0003 + CSR_WIFI_ROUTER_PRIM_UPSTREAM_LOWEST))
+
+#define CSR_WIFI_ROUTER_PRIM_UPSTREAM_HIGHEST             (0x0003 + CSR_WIFI_ROUTER_PRIM_UPSTREAM_LOWEST)
+
+#define CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_COUNT             (CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_HIGHEST + 1 - CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_LOWEST)
+#define CSR_WIFI_ROUTER_PRIM_UPSTREAM_COUNT               (CSR_WIFI_ROUTER_PRIM_UPSTREAM_HIGHEST   + 1 - CSR_WIFI_ROUTER_PRIM_UPSTREAM_LOWEST)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketSubscribeReq
+
+  DESCRIPTION
+    A task can use this primitive to subscribe for a particular OUI/protocol
+    and transmit and receive frames matching the subscription.
+    NOTE: Multiple subscriptions for a given protocol and OUI will result in
+    the first subscription receiving the data and not the subsequent
+    subscriptions.
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    encapsulation - Specifies the encapsulation type, which will be used for the
+                    subscription
+    protocol      - Together with the OUI, specifies the protocol, which a task
+                    wants to subscribe to
+    oui           - Specifies the OUI for the protocol, which a task wants to
+                    subscribe to
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent            common;
+    CsrUint16                  interfaceTag;
+    CsrWifiRouterEncapsulation encapsulation;
+    CsrUint16                  protocol;
+    CsrUint32                  oui;
+} CsrWifiRouterMaPacketSubscribeReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketUnsubscribeReq
+
+  DESCRIPTION
+    A task sends this primitive to unsubscribe a subscription
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    interfaceTag       - Interface Identifier; unique identifier of an interface
+    subscriptionHandle - The handle of the subscription
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrUint8        subscriptionHandle;
+} CsrWifiRouterMaPacketUnsubscribeReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketReq
+
+  DESCRIPTION
+    A task sends this primitive to transmit a frame.
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    interfaceTag       - Interface Identifier; unique identifier of an interface
+    subscriptionHandle - The handle of the subscription
+    frameLength        - Length of the frame to be sent in bytes
+    frame              - Pointer to the frame to be sent
+    freeFunction       - Pointer to function to be used to free the frame
+    priority           - Priority of the frame, which should be sent
+    hostTag            - An application shall set the bits b31..b28 using one of
+                         the CSR_WIFI_ROUTER_APP_TYPE_* masks. Bits b0..b27 can
+                         be used by the requestor without any restrictions, but
+                         the hostTag shall be unique so the hostTag for
+                         CSR_WIFI_ROUTER_APP _TYPE_OTHER should be constructured
+                         in the following way [ CSR_WIFI_ROUTER_APP_TYPE_OTHER
+                         (4 bits) | SubscriptionHandle (8 bits) | Sequence no.
+                         (20 bits) ]. If the hostTag is not unique, the
+                         behaviour of the system is unpredicatable with respect
+                         to data/management frame transfer.
+    cfmRequested       - Indicates if the requestor needs a confirm for packet
+                         requests sent under this subscription. If set to TRUE,
+                         the router will send a confirm, else it will not send
+                         any confirm
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrUint8                       subscriptionHandle;
+    CsrUint16                      frameLength;
+    CsrUint8                      *frame;
+    CsrWifiRouterFrameFreeFunction freeFunction;
+    CsrWifiRouterPriority          priority;
+    CsrUint32                      hostTag;
+    CsrBool                        cfmRequested;
+} CsrWifiRouterMaPacketReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketRes
+
+  DESCRIPTION
+    A task send this primitive to confirm the reception of the received
+    frame.
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    interfaceTag       - Interface Identifier; unique identifier of an interface
+    subscriptionHandle - The handle of the subscription
+    result             - Status of the operation
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrUint8        subscriptionHandle;
+    CsrResult       result;
+} CsrWifiRouterMaPacketRes;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketCancelReq
+
+  DESCRIPTION
+    This primitive is used to request cancellation of a previously send
+    CsrWifiRouterMaPacketReq.
+    The frame may already have been transmitted so there is no guarantees
+    that the CsrWifiRouterMaPacketCancelReq actually cancels the transmission
+    of the frame in question.
+    If the cancellation fails, the Router will send, if required,
+    CsrWifiRouterMaPacketCfm.
+    If the cancellation succeeds, the Router will not send
+    CsrWifiRouterMaPacketCfm.
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    hostTag        - The hostTag for the frame, which should be cancelled.
+    priority       - Priority of the frame, which should be cancelled
+    peerMacAddress - Destination MAC address of the frame, which should be
+                     cancelled
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrUint16             interfaceTag;
+    CsrUint32             hostTag;
+    CsrWifiRouterPriority priority;
+    CsrWifiMacAddress     peerMacAddress;
+} CsrWifiRouterMaPacketCancelReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketSubscribeCfm
+
+  DESCRIPTION
+    The router sends this primitive to confirm the result of the
+    subscription.
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    interfaceTag       - Interface Identifier; unique identifier of an interface
+    subscriptionHandle - Handle to the subscription
+                         This handle must be used in all subsequent requests
+    status             - Status of the operation
+    allocOffset        - Size of the offset for the frames of the subscription
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrUint8        subscriptionHandle;
+    CsrResult       status;
+    CsrUint16       allocOffset;
+} CsrWifiRouterMaPacketSubscribeCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketUnsubscribeCfm
+
+  DESCRIPTION
+    The router sends this primitive to confirm the result of the
+    unsubscription.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Status of the operation
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiRouterMaPacketUnsubscribeCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketCfm
+
+  DESCRIPTION
+    The router sends the primitive to confirm the result of the transmission
+    of the packet of the corresponding CSR_WIFI_ROUTER MA_PACKET_REQ request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    result       - Status of the operation
+    hostTag      - The hostTrag will match the hostTag sent in the request.
+    rate         - Transmission/Reception rate
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       result;
+    CsrUint32       hostTag;
+    CsrUint16       rate;
+} CsrWifiRouterMaPacketCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiRouterMaPacketInd
+
+  DESCRIPTION
+    The router sends the primitive to a subscribed task when it receives a
+    frame matching the subscription.
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    interfaceTag       - Interface Identifier; unique identifier of an interface
+    subscriptionHandle - The handle of the subscription
+    result             - Status of the operation
+    frameLength        - Length of the received frame in bytes
+    frame              - Pointer to the received frame
+    freeFunction       - Pointer to function to be used to free the frame
+    rssi               - Received signal strength indication in dBm
+    snr                - Signal to Noise Ratio
+    rate               - Transmission/Reception rate
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrUint16                      interfaceTag;
+    CsrUint8                       subscriptionHandle;
+    CsrResult                      result;
+    CsrUint16                      frameLength;
+    CsrUint8                      *frame;
+    CsrWifiRouterFrameFreeFunction freeFunction;
+    CsrInt16                       rssi;
+    CsrInt16                       snr;
+    CsrUint16                      rate;
+} CsrWifiRouterMaPacketInd;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_PRIM_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_sef.c
@@ -0,0 +1,19 @@
+/*****************************************************************************
+
+  (c) Cambridge Silicon Radio Limited 2010
+  Confidential information of CSR
+
+  Refer to LICENSE.txt included with this source for details
+  on the license terms.
+
+ *****************************************************************************/
+#include "csr_wifi_router_sef.h"
+
+const CsrWifiRouterStateHandlerType CsrWifiRouterDownstreamStateHandlers[CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_COUNT] =
+{
+    /* 0x0000 */ CsrWifiRouterMaPacketSubscribeReqHandler,
+    /* 0x0001 */ CsrWifiRouterMaPacketUnsubscribeReqHandler,
+    /* 0x0002 */ CsrWifiRouterMaPacketReqHandler,
+    /* 0x0003 */ CsrWifiRouterMaPacketResHandler,
+    /* 0x0004 */ CsrWifiRouterMaPacketCancelReqHandler,
+};
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_sef.h
@@ -0,0 +1,33 @@
+/*****************************************************************************
+
+  (c) Cambridge Silicon Radio Limited 2010
+  Confidential information of CSR
+
+  Refer to LICENSE.txt included with this source for details
+  on the license terms.
+
+ *****************************************************************************/
+#ifndef CSR_WIFI_ROUTER_SEF_CSR_WIFI_ROUTER_H__
+#define CSR_WIFI_ROUTER_SEF_CSR_WIFI_ROUTER_H__
+
+#include "csr_wifi_router_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    typedef void (*CsrWifiRouterStateHandlerType)(void* drvpriv, CsrWifiFsmEvent* msg);
+
+    extern const CsrWifiRouterStateHandlerType CsrWifiRouterDownstreamStateHandlers[CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_COUNT];
+
+    extern void CsrWifiRouterMaPacketSubscribeReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterMaPacketUnsubscribeReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterMaPacketReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterMaPacketResHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+    extern void CsrWifiRouterMaPacketCancelReqHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_SEF_CSR_WIFI_ROUTER_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_serialize.c
@@ -0,0 +1,422 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_pmem.h"
+#include "csr_msgconv.h"
+#include "csr_unicode.h"
+
+
+#include "csr_wifi_router_prim.h"
+#include "csr_wifi_router_serialize.h"
+
+void CsrWifiRouterPfree(void *ptr)
+{
+    CsrPmemFree(ptr);
+}
+
+
+CsrSize CsrWifiRouterMaPacketSubscribeReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 12) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrWifiRouterEncapsulation primitive->encapsulation */
+    bufferSize += 2; /* CsrUint16 primitive->protocol */
+    bufferSize += 4; /* CsrUint32 primitive->oui */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterMaPacketSubscribeReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterMaPacketSubscribeReq *primitive = (CsrWifiRouterMaPacketSubscribeReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->encapsulation);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->protocol);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->oui);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterMaPacketSubscribeReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterMaPacketSubscribeReq *primitive = (CsrWifiRouterMaPacketSubscribeReq *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketSubscribeReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->encapsulation, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->protocol, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->oui, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterMaPacketReqSizeof(void *msg)
+{
+    CsrWifiRouterMaPacketReq *primitive = (CsrWifiRouterMaPacketReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 20) */
+    bufferSize += 2;                      /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1;                      /* CsrUint8 primitive->subscriptionHandle */
+    bufferSize += 2;                      /* CsrUint16 primitive->frameLength */
+    bufferSize += primitive->frameLength; /* CsrUint8 primitive->frame */
+    bufferSize += 4;                      /* CsrWifiRouterFrameFreeFunction primitive->freeFunction */
+    bufferSize += 2;                      /* CsrWifiRouterPriority primitive->priority */
+    bufferSize += 4;                      /* CsrUint32 primitive->hostTag */
+    bufferSize += 1;                      /* CsrBool primitive->cfmRequested */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterMaPacketReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterMaPacketReq *primitive = (CsrWifiRouterMaPacketReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->subscriptionHandle);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->frameLength);
+    if (primitive->frameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->frame, ((CsrUint16) (primitive->frameLength)));
+    }
+    CsrUint32Ser(ptr, len, 0); /* Special for Function Pointers... primitive->freeFunction */
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->priority);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->hostTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->cfmRequested);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterMaPacketReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterMaPacketReq *primitive = (CsrWifiRouterMaPacketReq *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->subscriptionHandle, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->frameLength, buffer, &offset);
+    if (primitive->frameLength)
+    {
+        primitive->frame = (CsrUint8 *)CsrPmemAlloc(primitive->frameLength);
+        CsrMemCpyDes(primitive->frame, buffer, &offset, ((CsrUint16) (primitive->frameLength)));
+    }
+    else
+    {
+        primitive->frame = NULL;
+    }
+    primitive->freeFunction = NULL; /* Special for Function Pointers... */
+    offset += 4;
+    CsrUint16Des((CsrUint16 *) &primitive->priority, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->hostTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->cfmRequested, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiRouterMaPacketReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterMaPacketReq *primitive = (CsrWifiRouterMaPacketReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->frame);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiRouterMaPacketResSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 8) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrUint8 primitive->subscriptionHandle */
+    bufferSize += 2; /* CsrResult primitive->result */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterMaPacketResSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterMaPacketRes *primitive = (CsrWifiRouterMaPacketRes *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->subscriptionHandle);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterMaPacketResDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterMaPacketRes *primitive = (CsrWifiRouterMaPacketRes *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketRes));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->subscriptionHandle, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->result, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterMaPacketCancelReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 17) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 4; /* CsrUint32 primitive->hostTag */
+    bufferSize += 2; /* CsrWifiRouterPriority primitive->priority */
+    bufferSize += 6; /* CsrUint8 primitive->peerMacAddress.a[6] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterMaPacketCancelReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterMaPacketCancelReq *primitive = (CsrWifiRouterMaPacketCancelReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->hostTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->priority);
+    CsrMemCpySer(ptr, len, (const void *) primitive->peerMacAddress.a, ((CsrUint16) (6)));
+    return(ptr);
+}
+
+
+void* CsrWifiRouterMaPacketCancelReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterMaPacketCancelReq *primitive = (CsrWifiRouterMaPacketCancelReq *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketCancelReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->hostTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->priority, buffer, &offset);
+    CsrMemCpyDes(primitive->peerMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterMaPacketSubscribeCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 10) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrUint8 primitive->subscriptionHandle */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 2; /* CsrUint16 primitive->allocOffset */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterMaPacketSubscribeCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterMaPacketSubscribeCfm *primitive = (CsrWifiRouterMaPacketSubscribeCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->subscriptionHandle);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->allocOffset);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterMaPacketSubscribeCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterMaPacketSubscribeCfm *primitive = (CsrWifiRouterMaPacketSubscribeCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketSubscribeCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->subscriptionHandle, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->allocOffset, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterMaPacketUnsubscribeCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterMaPacketUnsubscribeCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterMaPacketUnsubscribeCfm *primitive = (CsrWifiRouterMaPacketUnsubscribeCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterMaPacketUnsubscribeCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterMaPacketUnsubscribeCfm *primitive = (CsrWifiRouterMaPacketUnsubscribeCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketUnsubscribeCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterMaPacketCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->result */
+    bufferSize += 4; /* CsrUint32 primitive->hostTag */
+    bufferSize += 2; /* CsrUint16 primitive->rate */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterMaPacketCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterMaPacketCfm *primitive = (CsrWifiRouterMaPacketCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->hostTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->rate);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterMaPacketCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterMaPacketCfm *primitive = (CsrWifiRouterMaPacketCfm *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->result, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->hostTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->rate, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiRouterMaPacketIndSizeof(void *msg)
+{
+    CsrWifiRouterMaPacketInd *primitive = (CsrWifiRouterMaPacketInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 21) */
+    bufferSize += 2;                      /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1;                      /* CsrUint8 primitive->subscriptionHandle */
+    bufferSize += 2;                      /* CsrResult primitive->result */
+    bufferSize += 2;                      /* CsrUint16 primitive->frameLength */
+    bufferSize += primitive->frameLength; /* CsrUint8 primitive->frame */
+    bufferSize += 4;                      /* CsrWifiRouterFrameFreeFunction primitive->freeFunction */
+    bufferSize += 2;                      /* CsrInt16 primitive->rssi */
+    bufferSize += 2;                      /* CsrInt16 primitive->snr */
+    bufferSize += 2;                      /* CsrUint16 primitive->rate */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiRouterMaPacketIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiRouterMaPacketInd *primitive = (CsrWifiRouterMaPacketInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->subscriptionHandle);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->frameLength);
+    if (primitive->frameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->frame, ((CsrUint16) (primitive->frameLength)));
+    }
+    CsrUint32Ser(ptr, len, 0); /* Special for Function Pointers... primitive->freeFunction */
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->rssi);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->snr);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->rate);
+    return(ptr);
+}
+
+
+void* CsrWifiRouterMaPacketIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiRouterMaPacketInd *primitive = (CsrWifiRouterMaPacketInd *) CsrPmemAlloc(sizeof(CsrWifiRouterMaPacketInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->subscriptionHandle, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->result, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->frameLength, buffer, &offset);
+    if (primitive->frameLength)
+    {
+        primitive->frame = (CsrUint8 *)CsrPmemAlloc(primitive->frameLength);
+        CsrMemCpyDes(primitive->frame, buffer, &offset, ((CsrUint16) (primitive->frameLength)));
+    }
+    else
+    {
+        primitive->frame = NULL;
+    }
+    primitive->freeFunction = NULL; /* Special for Function Pointers... */
+    offset += 4;
+    CsrUint16Des((CsrUint16 *) &primitive->rssi, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->snr, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->rate, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiRouterMaPacketIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiRouterMaPacketInd *primitive = (CsrWifiRouterMaPacketInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->frame);
+    CsrPmemFree(primitive);
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_serialize.h
@@ -0,0 +1,78 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_ROUTER_SERIALIZE_H__
+#define CSR_WIFI_ROUTER_SERIALIZE_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_wifi_msgconv.h"
+
+#include "csr_wifi_router_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void CsrWifiRouterPfree(void *ptr);
+
+extern CsrUint8* CsrWifiRouterMaPacketSubscribeReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterMaPacketSubscribeReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterMaPacketSubscribeReqSizeof(void *msg);
+#define CsrWifiRouterMaPacketSubscribeReqSerFree CsrWifiRouterPfree
+
+#define CsrWifiRouterMaPacketUnsubscribeReqSer CsrWifiEventCsrUint16CsrUint8Ser
+#define CsrWifiRouterMaPacketUnsubscribeReqDes CsrWifiEventCsrUint16CsrUint8Des
+#define CsrWifiRouterMaPacketUnsubscribeReqSizeof CsrWifiEventCsrUint16CsrUint8Sizeof
+#define CsrWifiRouterMaPacketUnsubscribeReqSerFree CsrWifiRouterPfree
+
+extern CsrUint8* CsrWifiRouterMaPacketReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterMaPacketReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterMaPacketReqSizeof(void *msg);
+extern void CsrWifiRouterMaPacketReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiRouterMaPacketResSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterMaPacketResDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterMaPacketResSizeof(void *msg);
+#define CsrWifiRouterMaPacketResSerFree CsrWifiRouterPfree
+
+extern CsrUint8* CsrWifiRouterMaPacketCancelReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterMaPacketCancelReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterMaPacketCancelReqSizeof(void *msg);
+#define CsrWifiRouterMaPacketCancelReqSerFree CsrWifiRouterPfree
+
+extern CsrUint8* CsrWifiRouterMaPacketSubscribeCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterMaPacketSubscribeCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterMaPacketSubscribeCfmSizeof(void *msg);
+#define CsrWifiRouterMaPacketSubscribeCfmSerFree CsrWifiRouterPfree
+
+extern CsrUint8* CsrWifiRouterMaPacketUnsubscribeCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterMaPacketUnsubscribeCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterMaPacketUnsubscribeCfmSizeof(void *msg);
+#define CsrWifiRouterMaPacketUnsubscribeCfmSerFree CsrWifiRouterPfree
+
+extern CsrUint8* CsrWifiRouterMaPacketCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterMaPacketCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterMaPacketCfmSizeof(void *msg);
+#define CsrWifiRouterMaPacketCfmSerFree CsrWifiRouterPfree
+
+extern CsrUint8* CsrWifiRouterMaPacketIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiRouterMaPacketIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiRouterMaPacketIndSizeof(void *msg);
+extern void CsrWifiRouterMaPacketIndSerFree(void *msg);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* CSR_WIFI_ROUTER_SERIALIZE_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_task.h
@@ -0,0 +1,34 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_ROUTER_TASK_H__
+#define CSR_WIFI_ROUTER_TASK_H__
+
+#include "csr_types.h"
+#include "csr_sched.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CSR_WIFI_ROUTER_LOG_ID 0x1201FFFF
+extern CsrSchedQid CSR_WIFI_ROUTER_IFACEQUEUE;
+void CsrWifiRouterInit(void **gash);
+void CsrWifiRouterDeinit(void **gash);
+void CsrWifiRouterHandler(void **gash);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_TASK_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_router_transport.c
@@ -0,0 +1,210 @@
+/** @file router_transport.c
+ *
+ *
+ * Copyright (C) Cambridge Silicon Radio Ltd 2006-2010. All rights reserved.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ ****************************************************************************/
+
+#include "unifi_priv.h"
+
+#include "csr_types.h"
+#include "csr_sched.h"
+#include "csr_msgconv.h"
+
+#include "sme_userspace.h"
+
+#include "csr_wifi_hostio_prim.h"
+#include "csr_wifi_router_lib.h"
+#include "csr_wifi_router_sef.h"
+#include "csr_wifi_router_converter_init.h"
+#include "csr_wifi_router_ctrl_lib.h"
+#include "csr_wifi_router_ctrl_sef.h"
+#include "csr_wifi_router_ctrl_converter_init.h"
+#include "csr_wifi_sme_prim.h"
+#include "csr_wifi_sme_sef.h"
+#include "csr_wifi_sme_converter_init.h"
+#ifdef CSR_SUPPORT_WEXT
+#ifdef CSR_SUPPORT_WEXT_AP
+#include "csr_wifi_nme_ap_prim.h"
+#include "csr_wifi_nme_ap_sef.h"
+#include "csr_wifi_nme_ap_converter_init.h"
+#endif
+#endif
+
+static unifi_priv_t *drvpriv = NULL;
+void CsrWifiRouterTransportInit(unifi_priv_t *priv)
+{
+    unifi_trace(priv, UDBG1, "CsrWifiRouterTransportInit: \n");
+
+    drvpriv = priv;
+    (void)CsrMsgConvInit();
+    CsrWifiRouterConverterInit();
+    CsrWifiRouterCtrlConverterInit();
+    CsrWifiSmeConverterInit();
+#ifdef CSR_SUPPORT_WEXT
+#ifdef CSR_SUPPORT_WEXT_AP
+    CsrWifiNmeApConverterInit();
+#endif
+#endif
+}
+
+void CsrWifiRouterTransportDeinit(unifi_priv_t *priv)
+{
+    unifi_trace(priv, UDBG1, "CsrWifiRouterTransportDeinit: \n");
+    if (priv == drvpriv)
+    {
+        CsrMsgConvDeinit();
+        drvpriv = NULL;
+    }
+}
+
+void CsrWifiRouterTransportRecv(unifi_priv_t *priv, CsrUint8* buffer, CsrSize bufferLength)
+{
+    CsrMsgConvMsgEntry* msgEntry;
+    CsrUint16 primType;
+    CsrSchedQid src;
+    CsrSchedQid dest;
+    CsrUint16 msgType;
+    CsrSize offset = 0;
+    CsrWifiFsmEvent* msg;
+
+    /* Decode the prim and message type */
+    CsrUint16Des(&primType, buffer, &offset);
+    CsrUint16Des(&src, buffer, &offset);
+    CsrUint16Des(&dest, buffer, &offset);
+    CsrUint16Des(&msgType, buffer, &offset);
+    offset -= 2; /* Adjust as the Deserialise Function will read this as well */
+
+    unifi_trace(priv, UDBG4, "CsrWifiRouterTransportRecv: primType=0x%.4X, msgType=0x%.4X, bufferLength=%d\n",
+                primType, msgType, bufferLength);
+
+    /* Special handling for HOSTIO messages.... */
+    if (primType == CSR_WIFI_HOSTIO_PRIM)
+    {
+        CsrWifiRouterCtrlHipReq req = {{CSR_WIFI_ROUTER_CTRL_HIP_REQ, CSR_WIFI_ROUTER_CTRL_PRIM, dest, src, NULL}, 0, NULL, 0, NULL, 0, NULL};
+
+        req.mlmeCommandLength = bufferLength;
+        req.mlmeCommand = buffer;
+
+        offset += 8;/* Skip the id, src, dest and slot number */
+        CsrUint16Des(&req.dataRef1Length, buffer, &offset);
+        offset += 2; /* Skip the slot number */
+        CsrUint16Des(&req.dataRef2Length, buffer, &offset);
+
+        if (req.dataRef1Length)
+        {
+            CsrUint16 dr1Offset = (bufferLength - req.dataRef2Length) - req.dataRef1Length;
+            req.dataRef1 = &buffer[dr1Offset];
+        }
+
+        if (req.dataRef2Length)
+        {
+            CsrUint16 dr2Offset = bufferLength - req.dataRef2Length;
+            req.dataRef2 = &buffer[dr2Offset];
+        }
+
+        /* Copy the hip data but strip off the prim type */
+        req.mlmeCommandLength -= (req.dataRef1Length + req.dataRef2Length + 6);
+        req.mlmeCommand = &buffer[6];
+
+        CsrWifiRouterCtrlHipReqHandler(priv, &req.common);
+        return;
+    }
+
+    msgEntry = CsrMsgConvFindEntry(primType, msgType);
+    if (!msgEntry)
+    {
+        unifi_error(priv, "CsrWifiRouterTransportDeserialiseAndSend can not process the message. primType=0x%.4X, msgType=0x%.4X\n",
+                    primType, msgType);
+        dump(buffer, bufferLength);
+        return;
+    }
+
+    msg = (CsrWifiFsmEvent*)(msgEntry->deserFunc)(&buffer[offset], bufferLength - offset);
+
+    msg->primtype = primType;
+    msg->type = msgType;
+    msg->source = src;
+    msg->destination = dest;
+
+    switch(primType)
+    {
+    case CSR_WIFI_ROUTER_CTRL_PRIM:
+        CsrWifiRouterCtrlDownstreamStateHandlers[msg->type - CSR_WIFI_ROUTER_CTRL_PRIM_DOWNSTREAM_LOWEST](priv, msg);
+        CsrWifiRouterCtrlFreeDownstreamMessageContents(CSR_WIFI_ROUTER_CTRL_PRIM, msg);
+        break;
+    case CSR_WIFI_ROUTER_PRIM:
+        CsrWifiRouterDownstreamStateHandlers[msg->type - CSR_WIFI_ROUTER_PRIM_DOWNSTREAM_LOWEST](priv, msg);
+        CsrWifiRouterFreeDownstreamMessageContents(CSR_WIFI_ROUTER_PRIM, msg);
+        break;
+        case CSR_WIFI_SME_PRIM:
+            CsrWifiSmeUpstreamStateHandlers[msg->type - CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST](priv, msg);
+            CsrWifiSmeFreeUpstreamMessageContents(CSR_WIFI_SME_PRIM, msg);
+            break;
+#ifdef CSR_SUPPORT_WEXT
+#ifdef CSR_SUPPORT_WEXT_AP
+        case CSR_WIFI_NME_AP_PRIM:
+            CsrWifiNmeApUpstreamStateHandlers(priv, msg);
+            CsrWifiNmeApFreeUpstreamMessageContents(CSR_WIFI_NME_AP_PRIM, msg);
+            break;
+#endif
+#endif
+        default:
+            unifi_error(priv, "CsrWifiRouterTransportDeserialiseAndSend unhandled prim type 0x%.4X\n", primType);
+            break;
+    }
+    CsrPmemFree(msg);
+}
+
+static void CsrWifiRouterTransportSerialiseAndSend(CsrUint16 primType, void* msg)
+{
+    CsrWifiFsmEvent* evt = (CsrWifiFsmEvent*)msg;
+    CsrMsgConvMsgEntry* msgEntry;
+    CsrSize msgSize;
+    CsrSize encodeBufferLen = 0;
+    CsrSize offset = 0;
+    CsrUint8* encodeBuffer;
+
+    unifi_trace(drvpriv, UDBG4, "CsrWifiRouterTransportSerialiseAndSend: primType=0x%.4X, msgType=0x%.4X\n",
+                primType, evt->type);
+
+    msgEntry = CsrMsgConvFindEntry(primType, evt->type);
+    if (!msgEntry)
+    {
+        unifi_error(drvpriv, "CsrWifiRouterTransportSerialiseAndSend can not process the message. primType=0x%.4X, msgType=0x%.4X\n",
+                    primType, evt->type);
+        return;
+    }
+
+    msgSize = 6 + (msgEntry->sizeofFunc)((void*)msg);
+
+    encodeBuffer = CsrPmemAlloc(msgSize);
+
+    /* Encode PrimType */
+    CsrUint16Ser(encodeBuffer, &encodeBufferLen, primType);
+    CsrUint16Ser(encodeBuffer, &encodeBufferLen, evt->source);
+    CsrUint16Ser(encodeBuffer, &encodeBufferLen, evt->destination);
+
+    (void)(msgEntry->serFunc)(&encodeBuffer[encodeBufferLen], &offset, msg);
+    encodeBufferLen += offset;
+
+    uf_sme_queue_message(drvpriv, encodeBuffer, encodeBufferLen);
+
+    /* Do not use msgEntry->freeFunc because the memory is owned by the driver */
+    CsrPmemFree(msg);
+}
+
+#if defined(CSR_LOG_ENABLE) && defined(CSR_LOG_INCLUDE_FILE_NAME_AND_LINE_NUMBER)
+void CsrSchedMessagePutStringLog(CsrSchedQid q, CsrUint16 mi, void *mv, CsrUint32 line, CsrCharString *file)
+#else
+void CsrSchedMessagePut(CsrSchedQid q, CsrUint16 mi, void *mv)
+#endif
+{
+    CsrWifiFsmEvent* evt = (CsrWifiFsmEvent*)mv;
+    evt->destination = q;
+    CsrWifiRouterTransportSerialiseAndSend(mi, mv);
+}
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_serialize_primitive_types.c
@@ -0,0 +1,257 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#include <linux/module.h>
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_util.h"
+#include "csr_msgconv.h"
+#include "csr_wifi_msgconv.h"
+#include "csr_wifi_lib.h"
+
+void CsrUint24Des(CsrUint32 *v, CsrUint8 *buffer, CsrSize *offset)
+{
+    CsrUint32 val;
+
+    val = ((buffer[(*offset) + 2] << 16) |
+           (buffer[(*offset) + 1] << 8) |
+           (buffer[(*offset)]));
+
+    *offset += 3;
+    *v = val;
+}
+
+
+/* Big endian :e.g WSC, TCLAS */
+void CsrUint16DesBigEndian(CsrUint16 *v, CsrUint8 *buffer, CsrSize *offset)
+{
+    CsrUint16 val;
+
+    val = (buffer[(*offset)] << 8) | (buffer[(*offset) + 1]);
+    *offset += 2;
+
+    *v = val;
+}
+
+
+void CsrUint24DesBigEndian(CsrUint32 *v, CsrUint8 *buffer, CsrSize *offset)
+{
+    CsrUint32 val;
+
+    val = ((buffer[(*offset)] << 16) |
+           (buffer[(*offset) + 1] << 8) |
+           (buffer[(*offset) + 2]));
+
+    *offset += 3;
+    *v = val;
+}
+
+
+void CsrUint32DesBigEndian(CsrUint32 *v, CsrUint8 *buffer, CsrSize *offset)
+{
+    CsrUint32 val;
+
+    val = ((buffer[(*offset)] << 24) |
+           (buffer[(*offset) + 1] << 16) |
+           (buffer[(*offset) + 2] << 8) |
+           (buffer[(*offset) + 3]));
+
+    *offset += 4;
+    *v = val;
+}
+
+
+void CsrUint24Ser(CsrUint8 *ptr, CsrSize *len, CsrUint32 v)
+{
+    ptr[(*len) + 2] = (CsrUint8)((v & 0x00ff0000) >> 16);
+    ptr[(*len) + 1] = (CsrUint8)((v & 0x0000ff00) >> 8);
+    ptr[(*len)]     = (CsrUint8)((v & 0x000000ff));
+
+    *len += 3;
+}
+
+
+/* Big endian :e.g WSC, TCLAS */
+void CsrUint16SerBigEndian(CsrUint8 *ptr, CsrSize *len, CsrUint16 v)
+{
+    ptr[(*len)] = (CsrUint8)((v & 0xff00) >> 8);
+    ptr[(*len) + 1] = (CsrUint8)((v & 0x00ff));
+
+    *len += 2;
+}
+
+
+void CsrUint32SerBigEndian(CsrUint8 *ptr, CsrSize *len, CsrUint32 v)
+{
+    ptr[(*len)] = (CsrUint8)((v & 0xff000000) >> 24);
+    ptr[(*len) + 1] = (CsrUint8)((v & 0x00ff0000) >> 16);
+    ptr[(*len) + 2] = (CsrUint8)((v & 0x0000ff00) >> 8);
+    ptr[(*len) + 3] = (CsrUint8)((v & 0x000000ff));
+
+    *len += 4;
+}
+
+
+void CsrUint24SerBigEndian(CsrUint8 *ptr, CsrSize *len, CsrUint32 v)
+{
+    ptr[(*len)] = (CsrUint8)((v & 0x00ff0000) >> 16);
+    ptr[(*len) + 1] = (CsrUint8)((v & 0x0000ff00) >> 8);
+    ptr[(*len) + 2] = (CsrUint8)((v & 0x000000ff));
+
+    *len += 3;
+}
+
+
+CsrSize CsrWifiEventSizeof(void *msg)
+{
+    return 2;
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventSizeof);
+
+CsrUint8* CsrWifiEventSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiFsmEvent *primitive = (CsrWifiFsmEvent *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->type);
+    return(ptr);
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventSer);
+
+void* CsrWifiEventDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiFsmEvent *primitive = (CsrWifiFsmEvent *) CsrPmemAlloc(sizeof(CsrWifiFsmEvent));
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->type, buffer, &offset);
+
+    return primitive;
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventDes);
+
+CsrSize CsrWifiEventCsrUint8Sizeof(void *msg)
+{
+    return 3;
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint8Sizeof);
+
+CsrUint8* CsrWifiEventCsrUint8Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiEventCsrUint8 *primitive = (CsrWifiEventCsrUint8 *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint8Ser(ptr, len, primitive->value);
+    return(ptr);
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint8Ser);
+
+
+void* CsrWifiEventCsrUint8Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiEventCsrUint8 *primitive = (CsrWifiEventCsrUint8 *) CsrPmemAlloc(sizeof(CsrWifiEventCsrUint8));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint8Des(&primitive->value, buffer, &offset);
+
+    return primitive;
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint8Des);
+
+
+CsrSize CsrWifiEventCsrUint16Sizeof(void *msg)
+{
+    return 4;
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint16Sizeof);
+
+
+CsrUint8* CsrWifiEventCsrUint16Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiEventCsrUint16 *primitive = (CsrWifiEventCsrUint16 *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, primitive->value);
+    return(ptr);
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint16Ser);
+
+void* CsrWifiEventCsrUint16Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiEventCsrUint16 *primitive = (CsrWifiEventCsrUint16 *) CsrPmemAlloc(sizeof(CsrWifiEventCsrUint16));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des(&primitive->value, buffer, &offset);
+
+    return primitive;
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint16Des);
+
+
+CsrSize CsrWifiEventCsrUint32Sizeof(void *msg)
+{
+    return 6;
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint32Sizeof);
+
+CsrUint8* CsrWifiEventCsrUint32Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiEventCsrUint32 *primitive = (CsrWifiEventCsrUint32 *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint32Ser(ptr, len, primitive->value);
+    return(ptr);
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint32Ser);
+
+
+void* CsrWifiEventCsrUint32Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiEventCsrUint32 *primitive = (CsrWifiEventCsrUint32 *) CsrPmemAlloc(sizeof(CsrWifiEventCsrUint32));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint32Des(&primitive->value, buffer, &offset);
+
+    return primitive;
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint32Des);
+
+CsrSize CsrWifiEventCsrUint16CsrUint8Sizeof(void *msg)
+{
+    return 5;
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint16CsrUint8Sizeof);
+
+CsrUint8* CsrWifiEventCsrUint16CsrUint8Ser(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiEventCsrUint16CsrUint8 *primitive = (CsrWifiEventCsrUint16CsrUint8 *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, primitive->value16);
+    CsrUint8Ser(ptr, len, primitive->value8);
+    return(ptr);
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint16CsrUint8Ser);
+
+
+void* CsrWifiEventCsrUint16CsrUint8Des(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiEventCsrUint16CsrUint8 *primitive = (CsrWifiEventCsrUint16CsrUint8 *) CsrPmemAlloc(sizeof(CsrWifiEventCsrUint16CsrUint8));
+
+    CsrSize offset = 0;
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des(&primitive->value16, buffer, &offset);
+    CsrUint8Des(&primitive->value8, buffer, &offset);
+
+    return primitive;
+}
+EXPORT_SYMBOL_GPL(CsrWifiEventCsrUint16CsrUint8Des);
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_ap_lib.h
@@ -0,0 +1,656 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_SME_AP_LIB_H__
+#define CSR_WIFI_SME_AP_LIB_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_sched.h"
+#include "csr_util.h"
+#include "csr_msg_transport.h"
+
+#include "csr_wifi_lib.h"
+
+#include "csr_wifi_sme_ap_prim.h"
+#include "csr_wifi_sme_task.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_AP_ENABLE
+#error CSR_WIFI_AP_ENABLE MUST be defined inorder to use csr_wifi_sme_ap_lib.h
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiSmeApFreeUpstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_SME_AP upstream message. Does not
+ *      free the message itself, and can only be used for upstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_SME_AP upstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiSmeApFreeUpstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiSmeApFreeDownstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_SME_AP downstream message. Does not
+ *      free the message itself, and can only be used for downstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_SME_AP downstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiSmeApFreeDownstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ * Enum to string functions
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiSmeApAccessTypeToString(CsrWifiSmeApAccessType value);
+const CsrCharString* CsrWifiSmeApAuthSupportToString(CsrWifiSmeApAuthSupport value);
+const CsrCharString* CsrWifiSmeApAuthTypeToString(CsrWifiSmeApAuthType value);
+const CsrCharString* CsrWifiSmeApPhySupportToString(CsrWifiSmeApPhySupport value);
+const CsrCharString* CsrWifiSmeApTypeToString(CsrWifiSmeApType value);
+
+
+/*----------------------------------------------------------------------------*
+ * CsrPrim Type toString function.
+ * Converts a message type to the String name of the Message
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiSmeApPrimTypeToString(CsrPrim msgType);
+
+/*----------------------------------------------------------------------------*
+ * Lookup arrays for PrimType name Strings
+ *----------------------------------------------------------------------------*/
+extern const CsrCharString *CsrWifiSmeApUpstreamPrimNames[CSR_WIFI_SME_AP_PRIM_UPSTREAM_COUNT];
+extern const CsrCharString *CsrWifiSmeApDownstreamPrimNames[CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_COUNT];
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApBeaconingStartReqSend
+
+  DESCRIPTION
+    This primitive requests the SME to start AP or GO functionality
+
+  PARAMETERS
+    queue           - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag    -
+    initialPresence - Set to 0, if Not in a group fomration phase, set to 1 ,
+                      during group formation phase
+    apType          - apType : Legacy AP or P2PGO
+    cloakSsid       - cloakSsid flag.
+    ssid            - ssid.
+    ifIndex         - Radio Interface
+    channel         - channel.
+    maxConnections  - Maximum Stations + P2PClients allowed
+    apCredentials   - AP security credeitals used to advertise in beacon /probe
+                      response
+    smeApConfig     - AP configuration
+    p2pGoParam      - P2P specific GO parameters. Ignored if it is a leagacy AP
+
+*******************************************************************************/
+#define CsrWifiSmeApBeaconingStartReqCreate(msg__, dst__, src__, interfaceTag__, initialPresence__, apType__, cloakSsid__, ssid__, ifIndex__, channel__, maxConnections__, apCredentials__, smeApConfig__, p2pGoParam__) \
+    msg__ = (CsrWifiSmeApBeaconingStartReq *) CsrPmemAlloc(sizeof(CsrWifiSmeApBeaconingStartReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_BEACONING_START_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->initialPresence = (initialPresence__); \
+    msg__->apType = (apType__); \
+    msg__->cloakSsid = (cloakSsid__); \
+    msg__->ssid = (ssid__); \
+    msg__->ifIndex = (ifIndex__); \
+    msg__->channel = (channel__); \
+    msg__->maxConnections = (maxConnections__); \
+    msg__->apCredentials = (apCredentials__); \
+    msg__->smeApConfig = (smeApConfig__); \
+    msg__->p2pGoParam = (p2pGoParam__);
+
+#define CsrWifiSmeApBeaconingStartReqSendTo(dst__, src__, interfaceTag__, initialPresence__, apType__, cloakSsid__, ssid__, ifIndex__, channel__, maxConnections__, apCredentials__, smeApConfig__, p2pGoParam__) \
+    { \
+        CsrWifiSmeApBeaconingStartReq *msg__; \
+        CsrWifiSmeApBeaconingStartReqCreate(msg__, dst__, src__, interfaceTag__, initialPresence__, apType__, cloakSsid__, ssid__, ifIndex__, channel__, maxConnections__, apCredentials__, smeApConfig__, p2pGoParam__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApBeaconingStartReqSend(src__, interfaceTag__, initialPresence__, apType__, cloakSsid__, ssid__, ifIndex__, channel__, maxConnections__, apCredentials__, smeApConfig__, p2pGoParam__) \
+    CsrWifiSmeApBeaconingStartReqSendTo(CSR_WIFI_SME_IFACEQUEUE, src__, interfaceTag__, initialPresence__, apType__, cloakSsid__, ssid__, ifIndex__, channel__, maxConnections__, apCredentials__, smeApConfig__, p2pGoParam__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApBeaconingStartCfmSend
+
+  DESCRIPTION
+    This primitive confirms the completion of the request along with the
+    status
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag -
+    status       -
+    secIeLength  -
+    secIe        -
+
+*******************************************************************************/
+#define CsrWifiSmeApBeaconingStartCfmCreate(msg__, dst__, src__, interfaceTag__, status__, secIeLength__, secIe__) \
+    msg__ = (CsrWifiSmeApBeaconingStartCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeApBeaconingStartCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_BEACONING_START_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->secIeLength = (secIeLength__); \
+    msg__->secIe = (secIe__);
+
+#define CsrWifiSmeApBeaconingStartCfmSendTo(dst__, src__, interfaceTag__, status__, secIeLength__, secIe__) \
+    { \
+        CsrWifiSmeApBeaconingStartCfm *msg__; \
+        CsrWifiSmeApBeaconingStartCfmCreate(msg__, dst__, src__, interfaceTag__, status__, secIeLength__, secIe__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApBeaconingStartCfmSend(dst__, interfaceTag__, status__, secIeLength__, secIe__) \
+    CsrWifiSmeApBeaconingStartCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, secIeLength__, secIe__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApBeaconingStopReqSend
+
+  DESCRIPTION
+    This primitive requests the SME to STOP AP or P2PGO operation
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag -
+
+*******************************************************************************/
+#define CsrWifiSmeApBeaconingStopReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeApBeaconingStopReq *) CsrPmemAlloc(sizeof(CsrWifiSmeApBeaconingStopReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_BEACONING_STOP_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeApBeaconingStopReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeApBeaconingStopReq *msg__; \
+        CsrWifiSmeApBeaconingStopReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApBeaconingStopReqSend(src__, interfaceTag__) \
+    CsrWifiSmeApBeaconingStopReqSendTo(CSR_WIFI_SME_IFACEQUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApBeaconingStopCfmSend
+
+  DESCRIPTION
+    This primitive confirms AP or P2PGO operation is terminated
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+#define CsrWifiSmeApBeaconingStopCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeApBeaconingStopCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeApBeaconingStopCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_BEACONING_STOP_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeApBeaconingStopCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeApBeaconingStopCfm *msg__; \
+        CsrWifiSmeApBeaconingStopCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApBeaconingStopCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeApBeaconingStopCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApErrorIndSend
+
+  DESCRIPTION
+    This primitve is sent by SME to indicate some error in AP operationi
+    after AP operations were started successfully and continuing the AP
+    operation may lead to undesired behaviour. It is the responsibility of
+    the upper layers to stop AP operation if needed
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Range 0-1
+    apType       -
+    status       - Contains the error status
+
+*******************************************************************************/
+#define CsrWifiSmeApErrorIndCreate(msg__, dst__, src__, interfaceTag__, apType__, status__) \
+    msg__ = (CsrWifiSmeApErrorInd *) CsrPmemAlloc(sizeof(CsrWifiSmeApErrorInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_ERROR_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->apType = (apType__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeApErrorIndSendTo(dst__, src__, interfaceTag__, apType__, status__) \
+    { \
+        CsrWifiSmeApErrorInd *msg__; \
+        CsrWifiSmeApErrorIndCreate(msg__, dst__, src__, interfaceTag__, apType__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApErrorIndSend(dst__, interfaceTag__, apType__, status__) \
+    CsrWifiSmeApErrorIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, apType__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApStaConnectStartIndSend
+
+  DESCRIPTION
+    This primitive indicates that a stations request to join the group/BSS is
+    accepted
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    interfaceTag   -
+    peerMacAddress -
+
+*******************************************************************************/
+#define CsrWifiSmeApStaConnectStartIndCreate(msg__, dst__, src__, interfaceTag__, peerMacAddress__) \
+    msg__ = (CsrWifiSmeApStaConnectStartInd *) CsrPmemAlloc(sizeof(CsrWifiSmeApStaConnectStartInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_STA_CONNECT_START_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->peerMacAddress = (peerMacAddress__);
+
+#define CsrWifiSmeApStaConnectStartIndSendTo(dst__, src__, interfaceTag__, peerMacAddress__) \
+    { \
+        CsrWifiSmeApStaConnectStartInd *msg__; \
+        CsrWifiSmeApStaConnectStartIndCreate(msg__, dst__, src__, interfaceTag__, peerMacAddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApStaConnectStartIndSend(dst__, interfaceTag__, peerMacAddress__) \
+    CsrWifiSmeApStaConnectStartIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, peerMacAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApStaDisconnectReqSend
+
+  DESCRIPTION
+    This primitive tells SME to deauth ot disassociate a particular station
+    within BSS
+
+  PARAMETERS
+    queue          - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag   -
+    deauthReason   -
+    disassocReason -
+    peerMacaddress -
+    keepBlocking   - If TRUE, the station is blocked. If FALSE and the station
+                     is connected, disconnect the station. If FALSE and the
+                     station is not connected, no action is taken.
+
+*******************************************************************************/
+#define CsrWifiSmeApStaDisconnectReqCreate(msg__, dst__, src__, interfaceTag__, deauthReason__, disassocReason__, peerMacaddress__, keepBlocking__) \
+    msg__ = (CsrWifiSmeApStaDisconnectReq *) CsrPmemAlloc(sizeof(CsrWifiSmeApStaDisconnectReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_STA_DISCONNECT_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->deauthReason = (deauthReason__); \
+    msg__->disassocReason = (disassocReason__); \
+    msg__->peerMacaddress = (peerMacaddress__); \
+    msg__->keepBlocking = (keepBlocking__);
+
+#define CsrWifiSmeApStaDisconnectReqSendTo(dst__, src__, interfaceTag__, deauthReason__, disassocReason__, peerMacaddress__, keepBlocking__) \
+    { \
+        CsrWifiSmeApStaDisconnectReq *msg__; \
+        CsrWifiSmeApStaDisconnectReqCreate(msg__, dst__, src__, interfaceTag__, deauthReason__, disassocReason__, peerMacaddress__, keepBlocking__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApStaDisconnectReqSend(src__, interfaceTag__, deauthReason__, disassocReason__, peerMacaddress__, keepBlocking__) \
+    CsrWifiSmeApStaDisconnectReqSendTo(CSR_WIFI_SME_IFACEQUEUE, src__, interfaceTag__, deauthReason__, disassocReason__, peerMacaddress__, keepBlocking__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApStaDisconnectCfmSend
+
+  DESCRIPTION
+    This primitive confirms the station is disconnected
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    interfaceTag   -
+    status         -
+    peerMacaddress -
+
+*******************************************************************************/
+#define CsrWifiSmeApStaDisconnectCfmCreate(msg__, dst__, src__, interfaceTag__, status__, peerMacaddress__) \
+    msg__ = (CsrWifiSmeApStaDisconnectCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeApStaDisconnectCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_STA_DISCONNECT_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->peerMacaddress = (peerMacaddress__);
+
+#define CsrWifiSmeApStaDisconnectCfmSendTo(dst__, src__, interfaceTag__, status__, peerMacaddress__) \
+    { \
+        CsrWifiSmeApStaDisconnectCfm *msg__; \
+        CsrWifiSmeApStaDisconnectCfmCreate(msg__, dst__, src__, interfaceTag__, status__, peerMacaddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApStaDisconnectCfmSend(dst__, interfaceTag__, status__, peerMacaddress__) \
+    CsrWifiSmeApStaDisconnectCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, peerMacaddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApStaNotifyIndSend
+
+  DESCRIPTION
+    This primitive indicates that a station has joined or a previously joined
+    station has left the BSS/group
+
+  PARAMETERS
+    queue             - Destination Task Queue
+    interfaceTag      -
+    mediaStatus       -
+    peerMacAddress    -
+    peerDeviceAddress -
+    disassocReason    -
+    deauthReason      -
+    WpsRegistration   -
+    secIeLength       -
+    secIe             -
+    groupKeyId        -
+    seqNumber         -
+
+*******************************************************************************/
+#define CsrWifiSmeApStaNotifyIndCreate(msg__, dst__, src__, interfaceTag__, mediaStatus__, peerMacAddress__, peerDeviceAddress__, disassocReason__, deauthReason__, WpsRegistration__, secIeLength__, secIe__, groupKeyId__, seqNumber__) \
+    msg__ = (CsrWifiSmeApStaNotifyInd *) CsrPmemAlloc(sizeof(CsrWifiSmeApStaNotifyInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_STA_NOTIFY_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->mediaStatus = (mediaStatus__); \
+    msg__->peerMacAddress = (peerMacAddress__); \
+    msg__->peerDeviceAddress = (peerDeviceAddress__); \
+    msg__->disassocReason = (disassocReason__); \
+    msg__->deauthReason = (deauthReason__); \
+    msg__->WpsRegistration = (WpsRegistration__); \
+    msg__->secIeLength = (secIeLength__); \
+    msg__->secIe = (secIe__); \
+    msg__->groupKeyId = (groupKeyId__); \
+    CsrMemCpy(msg__->seqNumber, (seqNumber__), sizeof(CsrUint16) * 8);
+
+#define CsrWifiSmeApStaNotifyIndSendTo(dst__, src__, interfaceTag__, mediaStatus__, peerMacAddress__, peerDeviceAddress__, disassocReason__, deauthReason__, WpsRegistration__, secIeLength__, secIe__, groupKeyId__, seqNumber__) \
+    { \
+        CsrWifiSmeApStaNotifyInd *msg__; \
+        CsrWifiSmeApStaNotifyIndCreate(msg__, dst__, src__, interfaceTag__, mediaStatus__, peerMacAddress__, peerDeviceAddress__, disassocReason__, deauthReason__, WpsRegistration__, secIeLength__, secIe__, groupKeyId__, seqNumber__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApStaNotifyIndSend(dst__, interfaceTag__, mediaStatus__, peerMacAddress__, peerDeviceAddress__, disassocReason__, deauthReason__, WpsRegistration__, secIeLength__, secIe__, groupKeyId__, seqNumber__) \
+    CsrWifiSmeApStaNotifyIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, mediaStatus__, peerMacAddress__, peerDeviceAddress__, disassocReason__, deauthReason__, WpsRegistration__, secIeLength__, secIe__, groupKeyId__, seqNumber__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWmmParamUpdateReqSend
+
+  DESCRIPTION
+    Application uses this primitive to update the WMM parameters on the fly
+
+  PARAMETERS
+    queue         - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag  -
+    wmmApParams   - WMM parameters to be used for local firmware queue
+                    configuration
+    wmmApBcParams - WMM parameters to be advertised in beacon/probe response
+
+*******************************************************************************/
+#define CsrWifiSmeApWmmParamUpdateReqCreate(msg__, dst__, src__, interfaceTag__, wmmApParams__, wmmApBcParams__) \
+    msg__ = (CsrWifiSmeApWmmParamUpdateReq *) CsrPmemAlloc(sizeof(CsrWifiSmeApWmmParamUpdateReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_WMM_PARAM_UPDATE_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    CsrMemCpy(msg__->wmmApParams, (wmmApParams__), sizeof(CsrWifiSmeWmmAcParams) * 4); \
+    CsrMemCpy(msg__->wmmApBcParams, (wmmApBcParams__), sizeof(CsrWifiSmeWmmAcParams) * 4);
+
+#define CsrWifiSmeApWmmParamUpdateReqSendTo(dst__, src__, interfaceTag__, wmmApParams__, wmmApBcParams__) \
+    { \
+        CsrWifiSmeApWmmParamUpdateReq *msg__; \
+        CsrWifiSmeApWmmParamUpdateReqCreate(msg__, dst__, src__, interfaceTag__, wmmApParams__, wmmApBcParams__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApWmmParamUpdateReqSend(src__, interfaceTag__, wmmApParams__, wmmApBcParams__) \
+    CsrWifiSmeApWmmParamUpdateReqSendTo(CSR_WIFI_SME_IFACEQUEUE, src__, interfaceTag__, wmmApParams__, wmmApBcParams__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWmmParamUpdateCfmSend
+
+  DESCRIPTION
+    A confirm for CSR_WIFI_SME_AP_WMM_PARAM_UPDATE.request
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+#define CsrWifiSmeApWmmParamUpdateCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeApWmmParamUpdateCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeApWmmParamUpdateCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_WMM_PARAM_UPDATE_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeApWmmParamUpdateCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeApWmmParamUpdateCfm *msg__; \
+        CsrWifiSmeApWmmParamUpdateCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApWmmParamUpdateCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeApWmmParamUpdateCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsConfigurationReqSend
+
+  DESCRIPTION
+    This primitive passes the WPS information for the device to SME. This may
+    be accepted only if no interface is active.
+
+  PARAMETERS
+    queue     - Message Source Task Queue (Cfm's will be sent to this Queue)
+    wpsConfig - WPS config.
+
+*******************************************************************************/
+#define CsrWifiSmeApWpsConfigurationReqCreate(msg__, dst__, src__, wpsConfig__) \
+    msg__ = (CsrWifiSmeApWpsConfigurationReq *) CsrPmemAlloc(sizeof(CsrWifiSmeApWpsConfigurationReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_WPS_CONFIGURATION_REQ, dst__, src__); \
+    msg__->wpsConfig = (wpsConfig__);
+
+#define CsrWifiSmeApWpsConfigurationReqSendTo(dst__, src__, wpsConfig__) \
+    { \
+        CsrWifiSmeApWpsConfigurationReq *msg__; \
+        CsrWifiSmeApWpsConfigurationReqCreate(msg__, dst__, src__, wpsConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApWpsConfigurationReqSend(src__, wpsConfig__) \
+    CsrWifiSmeApWpsConfigurationReqSendTo(CSR_WIFI_SME_IFACEQUEUE, src__, wpsConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsConfigurationCfmSend
+
+  DESCRIPTION
+    Confirm.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Status of the request.
+
+*******************************************************************************/
+#define CsrWifiSmeApWpsConfigurationCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeApWpsConfigurationCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeApWpsConfigurationCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_WPS_CONFIGURATION_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeApWpsConfigurationCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeApWpsConfigurationCfm *msg__; \
+        CsrWifiSmeApWpsConfigurationCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApWpsConfigurationCfmSend(dst__, status__) \
+    CsrWifiSmeApWpsConfigurationCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsRegistrationFinishedReqSend
+
+  DESCRIPTION
+    This primitive tells SME that WPS registration procedure has finished
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag -
+
+*******************************************************************************/
+#define CsrWifiSmeApWpsRegistrationFinishedReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeApWpsRegistrationFinishedReq *) CsrPmemAlloc(sizeof(CsrWifiSmeApWpsRegistrationFinishedReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_WPS_REGISTRATION_FINISHED_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeApWpsRegistrationFinishedReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeApWpsRegistrationFinishedReq *msg__; \
+        CsrWifiSmeApWpsRegistrationFinishedReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApWpsRegistrationFinishedReqSend(src__, interfaceTag__) \
+    CsrWifiSmeApWpsRegistrationFinishedReqSendTo(CSR_WIFI_SME_IFACEQUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsRegistrationFinishedCfmSend
+
+  DESCRIPTION
+    A confirm for UNIFI_MGT_AP_WPS_REGISTRATION_FINISHED.request
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+#define CsrWifiSmeApWpsRegistrationFinishedCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeApWpsRegistrationFinishedCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeApWpsRegistrationFinishedCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_WPS_REGISTRATION_FINISHED_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeApWpsRegistrationFinishedCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeApWpsRegistrationFinishedCfm *msg__; \
+        CsrWifiSmeApWpsRegistrationFinishedCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApWpsRegistrationFinishedCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeApWpsRegistrationFinishedCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsRegistrationStartedReqSend
+
+  DESCRIPTION
+    This primitive tells SME that WPS registration procedure has started
+
+  PARAMETERS
+    queue                    - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag             -
+    SelectedDevicePasswordId -
+    SelectedconfigMethod     -
+
+*******************************************************************************/
+#define CsrWifiSmeApWpsRegistrationStartedReqCreate(msg__, dst__, src__, interfaceTag__, SelectedDevicePasswordId__, SelectedconfigMethod__) \
+    msg__ = (CsrWifiSmeApWpsRegistrationStartedReq *) CsrPmemAlloc(sizeof(CsrWifiSmeApWpsRegistrationStartedReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_WPS_REGISTRATION_STARTED_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->SelectedDevicePasswordId = (SelectedDevicePasswordId__); \
+    msg__->SelectedconfigMethod = (SelectedconfigMethod__);
+
+#define CsrWifiSmeApWpsRegistrationStartedReqSendTo(dst__, src__, interfaceTag__, SelectedDevicePasswordId__, SelectedconfigMethod__) \
+    { \
+        CsrWifiSmeApWpsRegistrationStartedReq *msg__; \
+        CsrWifiSmeApWpsRegistrationStartedReqCreate(msg__, dst__, src__, interfaceTag__, SelectedDevicePasswordId__, SelectedconfigMethod__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApWpsRegistrationStartedReqSend(src__, interfaceTag__, SelectedDevicePasswordId__, SelectedconfigMethod__) \
+    CsrWifiSmeApWpsRegistrationStartedReqSendTo(CSR_WIFI_SME_IFACEQUEUE, src__, interfaceTag__, SelectedDevicePasswordId__, SelectedconfigMethod__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsRegistrationStartedCfmSend
+
+  DESCRIPTION
+    A confirm for UNIFI_MGT_AP_WPS_REGISTRATION_STARTED.request
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+#define CsrWifiSmeApWpsRegistrationStartedCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeApWpsRegistrationStartedCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeApWpsRegistrationStartedCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_AP_PRIM, CSR_WIFI_SME_AP_WPS_REGISTRATION_STARTED_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeApWpsRegistrationStartedCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeApWpsRegistrationStartedCfm *msg__; \
+        CsrWifiSmeApWpsRegistrationStartedCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_AP_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeApWpsRegistrationStartedCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeApWpsRegistrationStartedCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_SME_AP_LIB_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_ap_prim.h
@@ -0,0 +1,904 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_SME_AP_PRIM_H__
+#define CSR_WIFI_SME_AP_PRIM_H__
+
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+#include "csr_sched.h"
+#include "csr_wifi_common.h"
+#include "csr_result.h"
+#include "csr_wifi_fsm_event.h"
+#include "csr_wifi_sme_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef CSR_WIFI_AP_ENABLE
+#error CSR_WIFI_AP_ENABLE MUST be defined inorder to use csr_wifi_sme_ap_prim.h
+#endif
+
+#define CSR_WIFI_SME_AP_PRIM                                            (0x0407)
+
+typedef CsrPrim CsrWifiSmeApPrim;
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApAccessType
+
+  DESCRIPTION
+    Allow or deny STAs based on MAC address
+
+ VALUES
+    CSR_WIFI_AP_ACCESS_TYPE_NONE  - None
+    CSR_WIFI_AP_ACCESS_TYPE_ALLOW - Allow only if MAC address is from the list
+    CSR_WIFI_AP_ACCESS_TYPE_DENY  - Disallow if MAC address is from the list
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeApAccessType;
+#define CSR_WIFI_AP_ACCESS_TYPE_NONE    ((CsrWifiSmeApAccessType) 0x00)
+#define CSR_WIFI_AP_ACCESS_TYPE_ALLOW   ((CsrWifiSmeApAccessType) 0x01)
+#define CSR_WIFI_AP_ACCESS_TYPE_DENY    ((CsrWifiSmeApAccessType) 0x02)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApAuthSupport
+
+  DESCRIPTION
+    Define bits for AP authentication support
+
+ VALUES
+    CSR_WIFI_SME_RSN_AUTH_WPAPSK  - RSN WPA-PSK Support
+    CSR_WIFI_SME_RSN_AUTH_WPA2PSK - RSN WPA2-PSK Support
+    CSR_WIFI_SME_AUTH_WAPIPSK     - WAPI-PSK Support
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeApAuthSupport;
+#define CSR_WIFI_SME_RSN_AUTH_WPAPSK    ((CsrWifiSmeApAuthSupport) 0x01)
+#define CSR_WIFI_SME_RSN_AUTH_WPA2PSK   ((CsrWifiSmeApAuthSupport) 0x02)
+#define CSR_WIFI_SME_AUTH_WAPIPSK       ((CsrWifiSmeApAuthSupport) 0x04)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApAuthType
+
+  DESCRIPTION
+    Definition of the SME AP Authentication Options
+
+ VALUES
+    CSR_WIFI_SME_AP_AUTH_TYPE_OPEN_SYSTEM
+                   - Open  authentication
+    CSR_WIFI_SME_AP_AUTH_TYPE_PERSONAL
+                   - Personal authentication using a passphrase or a pre-shared
+                     key.
+    CSR_WIFI_SME_AP_AUTH_TYPE_WEP
+                   - WEP authentication. This can be either open or shared key
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeApAuthType;
+#define CSR_WIFI_SME_AP_AUTH_TYPE_OPEN_SYSTEM   ((CsrWifiSmeApAuthType) 0x00)
+#define CSR_WIFI_SME_AP_AUTH_TYPE_PERSONAL      ((CsrWifiSmeApAuthType) 0x01)
+#define CSR_WIFI_SME_AP_AUTH_TYPE_WEP           ((CsrWifiSmeApAuthType) 0x02)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApPhySupport
+
+  DESCRIPTION
+    Define bits for CsrWifiSmeApPhySupportMask
+
+ VALUES
+    CSR_WIFI_SME_AP_PHY_SUPPORT_A - 802.11a. It is not supported in the current
+                                    release.
+    CSR_WIFI_SME_AP_PHY_SUPPORT_B - 802.11b
+    CSR_WIFI_SME_AP_PHY_SUPPORT_G - 802.11g
+    CSR_WIFI_SME_AP_PHY_SUPPORT_N - 802.11n
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeApPhySupport;
+#define CSR_WIFI_SME_AP_PHY_SUPPORT_A   ((CsrWifiSmeApPhySupport) 0x01)
+#define CSR_WIFI_SME_AP_PHY_SUPPORT_B   ((CsrWifiSmeApPhySupport) 0x02)
+#define CSR_WIFI_SME_AP_PHY_SUPPORT_G   ((CsrWifiSmeApPhySupport) 0x04)
+#define CSR_WIFI_SME_AP_PHY_SUPPORT_N   ((CsrWifiSmeApPhySupport) 0x08)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApType
+
+  DESCRIPTION
+    Definition of AP types
+
+ VALUES
+    CSR_WIFI_AP_TYPE_LEGACY - Legacy AP
+    CSR_WIFI_AP_TYPE_P2P    - P2P Group Owner(GO)
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeApType;
+#define CSR_WIFI_AP_TYPE_LEGACY   ((CsrWifiSmeApType) 0x00)
+#define CSR_WIFI_AP_TYPE_P2P      ((CsrWifiSmeApType) 0x01)
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApAuthSupportMask
+
+  DESCRIPTION
+    See CsrWifiSmeApAuthSupport for bit definitions
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeApAuthSupportMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApPhySupportMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeApPhySupport
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeApPhySupportMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApRsnCapabilities
+
+  DESCRIPTION
+    Set to 0 for the current release
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeApRsnCapabilities;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApRsnCapabilitiesMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeApRsnCapabilities
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeApRsnCapabilitiesMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWapiCapabilities
+
+  DESCRIPTION
+    Ignored by the stack as WAPI is not supported for AP operations in the
+    current release
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeApWapiCapabilities;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWapiCapabilitiesMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeApWapiCapabilities
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeApWapiCapabilitiesMask;
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApHtParams
+
+  DESCRIPTION
+    Structure holding HT parameters
+
+  MEMBERS
+    greenfieldSupported - Indicates if the AP supports Htgreenfield operation
+                          subject to the chip capability. If the chip does not
+                          support Htgreenfield operation, this parameter will be
+                          ignored.
+                          NOTE: if shortGi20MHz is set to TRUE and the chip
+                          supports short GI operation for 20MHz this field will
+                          be be ignored and the AP will not support Htgreenfield
+                          operation.
+                          NOTE: This field is ignored by the Wi-Fi stack for the
+                          current release. It implies that AP does not support
+                          greenfield operation.
+    shortGi20MHz        - Indicates if the AP support short GI operation for
+                          20MHz subject to the chip capability.If the chip does
+                          not support short GI for 20MHz, this parameter is
+                          ignored
+    rxStbc              - Support for STBC for receive. 0 => No support for STBC
+                          , 1=> Use STBC for Rx
+    rifsModeAllowed     - RIFS Mode is allowed to protect overlapping non-HT BSS
+    htProtection        - Deprecated
+    dualCtsProtection   - Dual CTS Protection enabled
+
+*******************************************************************************/
+typedef struct
+{
+    CsrBool  greenfieldSupported;
+    CsrBool  shortGi20MHz;
+    CsrUint8 rxStbc;
+    CsrBool  rifsModeAllowed;
+    CsrUint8 htProtection;
+    CsrBool  dualCtsProtection;
+} CsrWifiSmeApHtParams;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApP2pOperatingChanEntry
+
+  DESCRIPTION
+
+  MEMBERS
+    operatingClass        - Channel operating class
+    operatingChannelCount - Number of channels in this entry
+    operatingChannel      - List of channels
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8  operatingClass;
+    CsrUint8  operatingChannelCount;
+    CsrUint8 *operatingChannel;
+} CsrWifiSmeApP2pOperatingChanEntry;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApP2pOperatingChanList
+
+  DESCRIPTION
+    This structure contains the lists of P2P operating channels
+
+  MEMBERS
+    country               - Country
+    channelEntryListCount - Number of entries
+    channelEntryList      - List of entries
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8                           country[3];
+    CsrUint8                           channelEntryListCount;
+    CsrWifiSmeApP2pOperatingChanEntry *channelEntryList;
+} CsrWifiSmeApP2pOperatingChanList;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApAuthPers
+
+  DESCRIPTION
+
+  MEMBERS
+    authSupport        -
+    encryptionModeMask -
+    rsnCapabilities    -
+    wapiCapabilities   -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeApAuthSupportMask      authSupport;
+    CsrWifiSmeEncryptionMask         encryptionModeMask;
+    CsrWifiSmeApRsnCapabilitiesMask  rsnCapabilities;
+    CsrWifiSmeApWapiCapabilitiesMask wapiCapabilities;
+} CsrWifiSmeApAuthPers;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApMacConfig
+
+  DESCRIPTION
+    Structure holding AP MAC configuration.
+
+  MEMBERS
+    phySupportedBitmap   - Indicates supported physical layers
+    beaconInterval       - Beacon interval in terms of TUs
+    dtimPeriod           - DTIM period in terms of number of beacon intervals
+    maxListenInterval    - Maximum allowed listen interval as number of beacon
+                           intervals
+    supportedRatesCount  - Number of supported rates. Range : 0  to 20
+    supportedRates       - List of supportedRates. A rate is specied in the
+                           units of 500kbps. An entry for a basic rate shall
+                           have the MSB set to 1.
+    preamble             - Preamble to be advertised in beacons and probe
+                           responses
+    shortSlotTimeEnabled - TRUE indicates the AP shall use short slot time if
+                           all the stations use short slot operation.
+    ctsProtectionType    - CTS protection to be used
+    wmmEnabled           - Indicate whether WMM is enabled or not. If set to
+                           FALSE,the WMM parameters shall be ignored by the
+                           receiver.
+    wmmApParams          - WMM parameters to be used for local firmware queue
+                           configuration. Array index corresponds to the ACI.
+    wmmApBcParams        - WMM parameters to be advertised in beacon/probe
+                           response. Array index corresponds to the ACI
+    accessType           - Specifies whether the MAC addresses from the list
+                           should be allowed or denied
+    macAddressListCount  - Number of MAC addresses
+    macAddressList       - List of MAC addresses
+    apHtParams           - AP HT parameters. The stack shall use these
+                           parameters only if phySupportedBitmap indicates
+                           support for IEEE 802.11n
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeApPhySupportMask  phySupportedBitmap;
+    CsrUint16                   beaconInterval;
+    CsrUint8                    dtimPeriod;
+    CsrUint16                   maxListenInterval;
+    CsrUint8                    supportedRatesCount;
+    CsrUint8                    supportedRates[20];
+    CsrWifiSmePreambleType      preamble;
+    CsrBool                     shortSlotTimeEnabled;
+    CsrWifiSmeCtsProtectionType ctsProtectionType;
+    CsrBool                     wmmEnabled;
+    CsrWifiSmeWmmAcParams       wmmApParams[4];
+    CsrWifiSmeWmmAcParams       wmmApBcParams[4];
+    CsrWifiSmeApAccessType      accessType;
+    CsrUint8                    macAddressListCount;
+    CsrWifiMacAddress          *macAddressList;
+    CsrWifiSmeApHtParams        apHtParams;
+} CsrWifiSmeApMacConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApP2pGoConfig
+
+  DESCRIPTION
+
+  MEMBERS
+    groupCapability           - Indicates the P2P group capabilities
+    operatingChanList         - List of operating channels in the order of
+                                decreasing priority. It may contain channel
+                                entry/entries not supported by the wifi stack.
+                                These shall be filtered out by the wifi stack
+    opPsEnabled               - Indicates whether opportunistic power save can
+                                be used.
+                                Note: This parameter is ignored by the WiFi
+                                stack for the current release
+    ctWindow                  - Define Client Traffic window to be used in terms
+                                of number of TUs. Range: 0 to 127.
+                                Note: This parameter is ignored by the WiFi
+                                stack for the current release.
+    noaConfigMethod           - Notice of Absence configuration method.
+                                Note: This parameter is ignored by the WiFi
+                                stack for the current release.
+    allowNoaWithNonP2pDevices - Indicates if NOA should be allowed if non P2P
+                                devices are connected. If allowed the non P2P
+                                devices may suffer in throughput.
+                                Note: This parameter is ignored by the WiFi
+                                stack for the current release.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeP2pGroupCapabilityMask groupCapability;
+    CsrWifiSmeApP2pOperatingChanList operatingChanList;
+    CsrBool                          opPsEnabled;
+    CsrUint8                         ctWindow;
+    CsrWifiSmeP2pNoaConfigMethod     noaConfigMethod;
+    CsrBool                          allowNoaWithNonP2pDevices;
+} CsrWifiSmeApP2pGoConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApCredentials
+
+  DESCRIPTION
+
+  MEMBERS
+    authType                    -
+    smeAuthType                 -
+    smeAuthTypeopenSystemEmpty  -
+    smeAuthTypeauthwep          -
+    smeAuthTypeauthPers         -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeApAuthType authType;
+    union {
+        CsrWifiSmeEmpty      openSystemEmpty;
+        CsrWifiSmeWepAuth    authwep;
+        CsrWifiSmeApAuthPers authPers;
+    } smeAuthType;
+} CsrWifiSmeApCredentials;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApSecConfig
+
+  DESCRIPTION
+
+  MEMBERS
+    apCredentials -
+    wpsEnabled    -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeApCredentials apCredentials;
+    CsrBool                 wpsEnabled;
+} CsrWifiSmeApSecConfig;
+
+
+/* Downstream */
+#define CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_LOWEST            (0x0000)
+
+#define CSR_WIFI_SME_AP_BEACONING_START_REQ               ((CsrWifiSmeApPrim) (0x0000 + CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_BEACONING_STOP_REQ                ((CsrWifiSmeApPrim) (0x0001 + CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_WPS_REGISTRATION_STARTED_REQ      ((CsrWifiSmeApPrim) (0x0002 + CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_WPS_REGISTRATION_FINISHED_REQ     ((CsrWifiSmeApPrim) (0x0003 + CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_WMM_PARAM_UPDATE_REQ              ((CsrWifiSmeApPrim) (0x0004 + CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_STA_DISCONNECT_REQ                ((CsrWifiSmeApPrim) (0x0005 + CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_WPS_CONFIGURATION_REQ             ((CsrWifiSmeApPrim) (0x0006 + CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_LOWEST))
+
+
+#define CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_HIGHEST           (0x0006 + CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_LOWEST)
+
+/* Upstream */
+#define CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST              (0x0000 + CSR_PRIM_UPSTREAM)
+
+#define CSR_WIFI_SME_AP_BEACONING_START_CFM               ((CsrWifiSmeApPrim)(0x0000 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_BEACONING_STOP_CFM                ((CsrWifiSmeApPrim)(0x0001 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_STA_NOTIFY_IND                    ((CsrWifiSmeApPrim)(0x0002 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_STA_CONNECT_START_IND             ((CsrWifiSmeApPrim)(0x0003 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_WPS_REGISTRATION_STARTED_CFM      ((CsrWifiSmeApPrim)(0x0004 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_WPS_REGISTRATION_FINISHED_CFM     ((CsrWifiSmeApPrim)(0x0005 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_WMM_PARAM_UPDATE_CFM              ((CsrWifiSmeApPrim)(0x0006 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_STA_DISCONNECT_CFM                ((CsrWifiSmeApPrim)(0x0007 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_WPS_CONFIGURATION_CFM             ((CsrWifiSmeApPrim)(0x0008 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_AP_ERROR_IND                         ((CsrWifiSmeApPrim)(0x0009 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST))
+
+#define CSR_WIFI_SME_AP_PRIM_UPSTREAM_HIGHEST             (0x0009 + CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST)
+
+#define CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_COUNT             (CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_HIGHEST + 1 - CSR_WIFI_SME_AP_PRIM_DOWNSTREAM_LOWEST)
+#define CSR_WIFI_SME_AP_PRIM_UPSTREAM_COUNT               (CSR_WIFI_SME_AP_PRIM_UPSTREAM_HIGHEST   + 1 - CSR_WIFI_SME_AP_PRIM_UPSTREAM_LOWEST)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApBeaconingStartReq
+
+  DESCRIPTION
+    This primitive requests the SME to start AP or GO functionality
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    interfaceTag    -
+    initialPresence - Set to 0, if Not in a group fomration phase, set to 1 ,
+                      during group formation phase
+    apType          - apType : Legacy AP or P2PGO
+    cloakSsid       - cloakSsid flag.
+    ssid            - ssid.
+    ifIndex         - Radio Interface
+    channel         - channel.
+    maxConnections  - Maximum Stations + P2PClients allowed
+    apCredentials   - AP security credeitals used to advertise in beacon /probe
+                      response
+    smeApConfig     - AP configuration
+    p2pGoParam      - P2P specific GO parameters. Ignored if it is a leagacy AP
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent         common;
+    CsrUint16               interfaceTag;
+    CsrUint8                initialPresence;
+    CsrWifiSmeApType        apType;
+    CsrBool                 cloakSsid;
+    CsrWifiSsid             ssid;
+    CsrWifiSmeRadioIF       ifIndex;
+    CsrUint8                channel;
+    CsrUint8                maxConnections;
+    CsrWifiSmeApSecConfig   apCredentials;
+    CsrWifiSmeApMacConfig   smeApConfig;
+    CsrWifiSmeApP2pGoConfig p2pGoParam;
+} CsrWifiSmeApBeaconingStartReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApBeaconingStopReq
+
+  DESCRIPTION
+    This primitive requests the SME to STOP AP or P2PGO operation
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeApBeaconingStopReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsRegistrationStartedReq
+
+  DESCRIPTION
+    This primitive tells SME that WPS registration procedure has started
+
+  MEMBERS
+    common                   - Common header for use with the CsrWifiFsm Module
+    interfaceTag             -
+    SelectedDevicePasswordId -
+    SelectedconfigMethod     -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent         common;
+    CsrUint16               interfaceTag;
+    CsrWifiSmeWpsDpid       SelectedDevicePasswordId;
+    CsrWifiSmeWpsConfigType SelectedconfigMethod;
+} CsrWifiSmeApWpsRegistrationStartedReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsRegistrationFinishedReq
+
+  DESCRIPTION
+    This primitive tells SME that WPS registration procedure has finished
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeApWpsRegistrationFinishedReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWmmParamUpdateReq
+
+  DESCRIPTION
+    Application uses this primitive to update the WMM parameters on the fly
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    interfaceTag  -
+    wmmApParams   - WMM parameters to be used for local firmware queue
+                    configuration
+    wmmApBcParams - WMM parameters to be advertised in beacon/probe response
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrUint16             interfaceTag;
+    CsrWifiSmeWmmAcParams wmmApParams[4];
+    CsrWifiSmeWmmAcParams wmmApBcParams[4];
+} CsrWifiSmeApWmmParamUpdateReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApStaDisconnectReq
+
+  DESCRIPTION
+    This primitive tells SME to deauth ot disassociate a particular station
+    within BSS
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   -
+    deauthReason   -
+    disassocReason -
+    peerMacaddress -
+    keepBlocking   - If TRUE, the station is blocked. If FALSE and the station
+                     is connected, disconnect the station. If FALSE and the
+                     station is not connected, no action is taken.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrWifiSmeIEEE80211Reason deauthReason;
+    CsrWifiSmeIEEE80211Reason disassocReason;
+    CsrWifiMacAddress         peerMacaddress;
+    CsrBool                   keepBlocking;
+} CsrWifiSmeApStaDisconnectReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsConfigurationReq
+
+  DESCRIPTION
+    This primitive passes the WPS information for the device to SME. This may
+    be accepted only if no interface is active.
+
+  MEMBERS
+    common    - Common header for use with the CsrWifiFsm Module
+    wpsConfig - WPS config.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent     common;
+    CsrWifiSmeWpsConfig wpsConfig;
+} CsrWifiSmeApWpsConfigurationReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApBeaconingStartCfm
+
+  DESCRIPTION
+    This primitive confirms the completion of the request along with the
+    status
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    status       -
+    secIeLength  -
+    secIe        -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+    CsrUint16       secIeLength;
+    CsrUint8       *secIe;
+} CsrWifiSmeApBeaconingStartCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApBeaconingStopCfm
+
+  DESCRIPTION
+    This primitive confirms AP or P2PGO operation is terminated
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeApBeaconingStopCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApStaNotifyInd
+
+  DESCRIPTION
+    This primitive indicates that a station has joined or a previously joined
+    station has left the BSS/group
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    interfaceTag      -
+    mediaStatus       -
+    peerMacAddress    -
+    peerDeviceAddress -
+    disassocReason    -
+    deauthReason      -
+    WpsRegistration   -
+    secIeLength       -
+    secIe             -
+    groupKeyId        -
+    seqNumber         -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrWifiSmeMediaStatus     mediaStatus;
+    CsrWifiMacAddress         peerMacAddress;
+    CsrWifiMacAddress         peerDeviceAddress;
+    CsrWifiSmeIEEE80211Reason disassocReason;
+    CsrWifiSmeIEEE80211Reason deauthReason;
+    CsrWifiSmeWpsRegistration WpsRegistration;
+    CsrUint8                  secIeLength;
+    CsrUint8                 *secIe;
+    CsrUint8                  groupKeyId;
+    CsrUint16                 seqNumber[8];
+} CsrWifiSmeApStaNotifyInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApStaConnectStartInd
+
+  DESCRIPTION
+    This primitive indicates that a stations request to join the group/BSS is
+    accepted
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   -
+    peerMacAddress -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrUint16         interfaceTag;
+    CsrWifiMacAddress peerMacAddress;
+} CsrWifiSmeApStaConnectStartInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsRegistrationStartedCfm
+
+  DESCRIPTION
+    A confirm for UNIFI_MGT_AP_WPS_REGISTRATION_STARTED.request
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeApWpsRegistrationStartedCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsRegistrationFinishedCfm
+
+  DESCRIPTION
+    A confirm for UNIFI_MGT_AP_WPS_REGISTRATION_FINISHED.request
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeApWpsRegistrationFinishedCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWmmParamUpdateCfm
+
+  DESCRIPTION
+    A confirm for CSR_WIFI_SME_AP_WMM_PARAM_UPDATE.request
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag -
+    status       -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeApWmmParamUpdateCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApStaDisconnectCfm
+
+  DESCRIPTION
+    This primitive confirms the station is disconnected
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   -
+    status         -
+    peerMacaddress -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrUint16         interfaceTag;
+    CsrResult         status;
+    CsrWifiMacAddress peerMacaddress;
+} CsrWifiSmeApStaDisconnectCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApWpsConfigurationCfm
+
+  DESCRIPTION
+    Confirm.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Status of the request.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeApWpsConfigurationCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeApErrorInd
+
+  DESCRIPTION
+    This primitve is sent by SME to indicate some error in AP operationi
+    after AP operations were started successfully and continuing the AP
+    operation may lead to undesired behaviour. It is the responsibility of
+    the upper layers to stop AP operation if needed
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Range 0-1
+    apType       -
+    status       - Contains the error status
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent  common;
+    CsrUint16        interfaceTag;
+    CsrWifiSmeApType apType;
+    CsrResult        status;
+} CsrWifiSmeApErrorInd;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_SME_AP_PRIM_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_converter_init.c
@@ -0,0 +1,201 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_msgconv.h"
+#include "csr_pmem.h"
+#include "csr_util.h"
+
+
+#ifdef CSR_LOG_ENABLE
+#include "csr_log.h"
+#endif
+
+#ifndef EXCLUDE_CSR_WIFI_SME_MODULE
+#include "csr_wifi_sme_serialize.h"
+#include "csr_wifi_sme_prim.h"
+
+static CsrMsgConvMsgEntry csrwifisme_conv_lut[] = {
+    { CSR_WIFI_SME_ACTIVATE_REQ, CsrWifiSmeActivateReqSizeof, CsrWifiSmeActivateReqSer, CsrWifiSmeActivateReqDes, CsrWifiSmeActivateReqSerFree },
+    { CSR_WIFI_SME_ADHOC_CONFIG_GET_REQ, CsrWifiSmeAdhocConfigGetReqSizeof, CsrWifiSmeAdhocConfigGetReqSer, CsrWifiSmeAdhocConfigGetReqDes, CsrWifiSmeAdhocConfigGetReqSerFree },
+    { CSR_WIFI_SME_ADHOC_CONFIG_SET_REQ, CsrWifiSmeAdhocConfigSetReqSizeof, CsrWifiSmeAdhocConfigSetReqSer, CsrWifiSmeAdhocConfigSetReqDes, CsrWifiSmeAdhocConfigSetReqSerFree },
+    { CSR_WIFI_SME_BLACKLIST_REQ, CsrWifiSmeBlacklistReqSizeof, CsrWifiSmeBlacklistReqSer, CsrWifiSmeBlacklistReqDes, CsrWifiSmeBlacklistReqSerFree },
+    { CSR_WIFI_SME_CALIBRATION_DATA_GET_REQ, CsrWifiSmeCalibrationDataGetReqSizeof, CsrWifiSmeCalibrationDataGetReqSer, CsrWifiSmeCalibrationDataGetReqDes, CsrWifiSmeCalibrationDataGetReqSerFree },
+    { CSR_WIFI_SME_CALIBRATION_DATA_SET_REQ, CsrWifiSmeCalibrationDataSetReqSizeof, CsrWifiSmeCalibrationDataSetReqSer, CsrWifiSmeCalibrationDataSetReqDes, CsrWifiSmeCalibrationDataSetReqSerFree },
+    { CSR_WIFI_SME_CCX_CONFIG_GET_REQ, CsrWifiSmeCcxConfigGetReqSizeof, CsrWifiSmeCcxConfigGetReqSer, CsrWifiSmeCcxConfigGetReqDes, CsrWifiSmeCcxConfigGetReqSerFree },
+    { CSR_WIFI_SME_CCX_CONFIG_SET_REQ, CsrWifiSmeCcxConfigSetReqSizeof, CsrWifiSmeCcxConfigSetReqSer, CsrWifiSmeCcxConfigSetReqDes, CsrWifiSmeCcxConfigSetReqSerFree },
+    { CSR_WIFI_SME_COEX_CONFIG_GET_REQ, CsrWifiSmeCoexConfigGetReqSizeof, CsrWifiSmeCoexConfigGetReqSer, CsrWifiSmeCoexConfigGetReqDes, CsrWifiSmeCoexConfigGetReqSerFree },
+    { CSR_WIFI_SME_COEX_CONFIG_SET_REQ, CsrWifiSmeCoexConfigSetReqSizeof, CsrWifiSmeCoexConfigSetReqSer, CsrWifiSmeCoexConfigSetReqDes, CsrWifiSmeCoexConfigSetReqSerFree },
+    { CSR_WIFI_SME_COEX_INFO_GET_REQ, CsrWifiSmeCoexInfoGetReqSizeof, CsrWifiSmeCoexInfoGetReqSer, CsrWifiSmeCoexInfoGetReqDes, CsrWifiSmeCoexInfoGetReqSerFree },
+    { CSR_WIFI_SME_CONNECT_REQ, CsrWifiSmeConnectReqSizeof, CsrWifiSmeConnectReqSer, CsrWifiSmeConnectReqDes, CsrWifiSmeConnectReqSerFree },
+    { CSR_WIFI_SME_CONNECTION_CONFIG_GET_REQ, CsrWifiSmeConnectionConfigGetReqSizeof, CsrWifiSmeConnectionConfigGetReqSer, CsrWifiSmeConnectionConfigGetReqDes, CsrWifiSmeConnectionConfigGetReqSerFree },
+    { CSR_WIFI_SME_CONNECTION_INFO_GET_REQ, CsrWifiSmeConnectionInfoGetReqSizeof, CsrWifiSmeConnectionInfoGetReqSer, CsrWifiSmeConnectionInfoGetReqDes, CsrWifiSmeConnectionInfoGetReqSerFree },
+    { CSR_WIFI_SME_CONNECTION_STATS_GET_REQ, CsrWifiSmeConnectionStatsGetReqSizeof, CsrWifiSmeConnectionStatsGetReqSer, CsrWifiSmeConnectionStatsGetReqDes, CsrWifiSmeConnectionStatsGetReqSerFree },
+    { CSR_WIFI_SME_DEACTIVATE_REQ, CsrWifiSmeDeactivateReqSizeof, CsrWifiSmeDeactivateReqSer, CsrWifiSmeDeactivateReqDes, CsrWifiSmeDeactivateReqSerFree },
+    { CSR_WIFI_SME_DISCONNECT_REQ, CsrWifiSmeDisconnectReqSizeof, CsrWifiSmeDisconnectReqSer, CsrWifiSmeDisconnectReqDes, CsrWifiSmeDisconnectReqSerFree },
+    { CSR_WIFI_SME_EVENT_MASK_SET_REQ, CsrWifiSmeEventMaskSetReqSizeof, CsrWifiSmeEventMaskSetReqSer, CsrWifiSmeEventMaskSetReqDes, CsrWifiSmeEventMaskSetReqSerFree },
+    { CSR_WIFI_SME_HOST_CONFIG_GET_REQ, CsrWifiSmeHostConfigGetReqSizeof, CsrWifiSmeHostConfigGetReqSer, CsrWifiSmeHostConfigGetReqDes, CsrWifiSmeHostConfigGetReqSerFree },
+    { CSR_WIFI_SME_HOST_CONFIG_SET_REQ, CsrWifiSmeHostConfigSetReqSizeof, CsrWifiSmeHostConfigSetReqSer, CsrWifiSmeHostConfigSetReqDes, CsrWifiSmeHostConfigSetReqSerFree },
+    { CSR_WIFI_SME_KEY_REQ, CsrWifiSmeKeyReqSizeof, CsrWifiSmeKeyReqSer, CsrWifiSmeKeyReqDes, CsrWifiSmeKeyReqSerFree },
+    { CSR_WIFI_SME_LINK_QUALITY_GET_REQ, CsrWifiSmeLinkQualityGetReqSizeof, CsrWifiSmeLinkQualityGetReqSer, CsrWifiSmeLinkQualityGetReqDes, CsrWifiSmeLinkQualityGetReqSerFree },
+    { CSR_WIFI_SME_MIB_CONFIG_GET_REQ, CsrWifiSmeMibConfigGetReqSizeof, CsrWifiSmeMibConfigGetReqSer, CsrWifiSmeMibConfigGetReqDes, CsrWifiSmeMibConfigGetReqSerFree },
+    { CSR_WIFI_SME_MIB_CONFIG_SET_REQ, CsrWifiSmeMibConfigSetReqSizeof, CsrWifiSmeMibConfigSetReqSer, CsrWifiSmeMibConfigSetReqDes, CsrWifiSmeMibConfigSetReqSerFree },
+    { CSR_WIFI_SME_MIB_GET_NEXT_REQ, CsrWifiSmeMibGetNextReqSizeof, CsrWifiSmeMibGetNextReqSer, CsrWifiSmeMibGetNextReqDes, CsrWifiSmeMibGetNextReqSerFree },
+    { CSR_WIFI_SME_MIB_GET_REQ, CsrWifiSmeMibGetReqSizeof, CsrWifiSmeMibGetReqSer, CsrWifiSmeMibGetReqDes, CsrWifiSmeMibGetReqSerFree },
+    { CSR_WIFI_SME_MIB_SET_REQ, CsrWifiSmeMibSetReqSizeof, CsrWifiSmeMibSetReqSer, CsrWifiSmeMibSetReqDes, CsrWifiSmeMibSetReqSerFree },
+    { CSR_WIFI_SME_MULTICAST_ADDRESS_REQ, CsrWifiSmeMulticastAddressReqSizeof, CsrWifiSmeMulticastAddressReqSer, CsrWifiSmeMulticastAddressReqDes, CsrWifiSmeMulticastAddressReqSerFree },
+    { CSR_WIFI_SME_PACKET_FILTER_SET_REQ, CsrWifiSmePacketFilterSetReqSizeof, CsrWifiSmePacketFilterSetReqSer, CsrWifiSmePacketFilterSetReqDes, CsrWifiSmePacketFilterSetReqSerFree },
+    { CSR_WIFI_SME_PERMANENT_MAC_ADDRESS_GET_REQ, CsrWifiSmePermanentMacAddressGetReqSizeof, CsrWifiSmePermanentMacAddressGetReqSer, CsrWifiSmePermanentMacAddressGetReqDes, CsrWifiSmePermanentMacAddressGetReqSerFree },
+    { CSR_WIFI_SME_PMKID_REQ, CsrWifiSmePmkidReqSizeof, CsrWifiSmePmkidReqSer, CsrWifiSmePmkidReqDes, CsrWifiSmePmkidReqSerFree },
+    { CSR_WIFI_SME_POWER_CONFIG_GET_REQ, CsrWifiSmePowerConfigGetReqSizeof, CsrWifiSmePowerConfigGetReqSer, CsrWifiSmePowerConfigGetReqDes, CsrWifiSmePowerConfigGetReqSerFree },
+    { CSR_WIFI_SME_POWER_CONFIG_SET_REQ, CsrWifiSmePowerConfigSetReqSizeof, CsrWifiSmePowerConfigSetReqSer, CsrWifiSmePowerConfigSetReqDes, CsrWifiSmePowerConfigSetReqSerFree },
+    { CSR_WIFI_SME_REGULATORY_DOMAIN_INFO_GET_REQ, CsrWifiSmeRegulatoryDomainInfoGetReqSizeof, CsrWifiSmeRegulatoryDomainInfoGetReqSer, CsrWifiSmeRegulatoryDomainInfoGetReqDes, CsrWifiSmeRegulatoryDomainInfoGetReqSerFree },
+    { CSR_WIFI_SME_ROAMING_CONFIG_GET_REQ, CsrWifiSmeRoamingConfigGetReqSizeof, CsrWifiSmeRoamingConfigGetReqSer, CsrWifiSmeRoamingConfigGetReqDes, CsrWifiSmeRoamingConfigGetReqSerFree },
+    { CSR_WIFI_SME_ROAMING_CONFIG_SET_REQ, CsrWifiSmeRoamingConfigSetReqSizeof, CsrWifiSmeRoamingConfigSetReqSer, CsrWifiSmeRoamingConfigSetReqDes, CsrWifiSmeRoamingConfigSetReqSerFree },
+    { CSR_WIFI_SME_SCAN_CONFIG_GET_REQ, CsrWifiSmeScanConfigGetReqSizeof, CsrWifiSmeScanConfigGetReqSer, CsrWifiSmeScanConfigGetReqDes, CsrWifiSmeScanConfigGetReqSerFree },
+    { CSR_WIFI_SME_SCAN_CONFIG_SET_REQ, CsrWifiSmeScanConfigSetReqSizeof, CsrWifiSmeScanConfigSetReqSer, CsrWifiSmeScanConfigSetReqDes, CsrWifiSmeScanConfigSetReqSerFree },
+    { CSR_WIFI_SME_SCAN_FULL_REQ, CsrWifiSmeScanFullReqSizeof, CsrWifiSmeScanFullReqSer, CsrWifiSmeScanFullReqDes, CsrWifiSmeScanFullReqSerFree },
+    { CSR_WIFI_SME_SCAN_RESULTS_FLUSH_REQ, CsrWifiSmeScanResultsFlushReqSizeof, CsrWifiSmeScanResultsFlushReqSer, CsrWifiSmeScanResultsFlushReqDes, CsrWifiSmeScanResultsFlushReqSerFree },
+    { CSR_WIFI_SME_SCAN_RESULTS_GET_REQ, CsrWifiSmeScanResultsGetReqSizeof, CsrWifiSmeScanResultsGetReqSer, CsrWifiSmeScanResultsGetReqDes, CsrWifiSmeScanResultsGetReqSerFree },
+    { CSR_WIFI_SME_SME_STA_CONFIG_GET_REQ, CsrWifiSmeSmeStaConfigGetReqSizeof, CsrWifiSmeSmeStaConfigGetReqSer, CsrWifiSmeSmeStaConfigGetReqDes, CsrWifiSmeSmeStaConfigGetReqSerFree },
+    { CSR_WIFI_SME_SME_STA_CONFIG_SET_REQ, CsrWifiSmeSmeStaConfigSetReqSizeof, CsrWifiSmeSmeStaConfigSetReqSer, CsrWifiSmeSmeStaConfigSetReqDes, CsrWifiSmeSmeStaConfigSetReqSerFree },
+    { CSR_WIFI_SME_STATION_MAC_ADDRESS_GET_REQ, CsrWifiSmeStationMacAddressGetReqSizeof, CsrWifiSmeStationMacAddressGetReqSer, CsrWifiSmeStationMacAddressGetReqDes, CsrWifiSmeStationMacAddressGetReqSerFree },
+    { CSR_WIFI_SME_TSPEC_REQ, CsrWifiSmeTspecReqSizeof, CsrWifiSmeTspecReqSer, CsrWifiSmeTspecReqDes, CsrWifiSmeTspecReqSerFree },
+    { CSR_WIFI_SME_VERSIONS_GET_REQ, CsrWifiSmeVersionsGetReqSizeof, CsrWifiSmeVersionsGetReqSer, CsrWifiSmeVersionsGetReqDes, CsrWifiSmeVersionsGetReqSerFree },
+    { CSR_WIFI_SME_WIFI_FLIGHTMODE_REQ, CsrWifiSmeWifiFlightmodeReqSizeof, CsrWifiSmeWifiFlightmodeReqSer, CsrWifiSmeWifiFlightmodeReqDes, CsrWifiSmeWifiFlightmodeReqSerFree },
+    { CSR_WIFI_SME_WIFI_OFF_REQ, CsrWifiSmeWifiOffReqSizeof, CsrWifiSmeWifiOffReqSer, CsrWifiSmeWifiOffReqDes, CsrWifiSmeWifiOffReqSerFree },
+    { CSR_WIFI_SME_WIFI_ON_REQ, CsrWifiSmeWifiOnReqSizeof, CsrWifiSmeWifiOnReqSer, CsrWifiSmeWifiOnReqDes, CsrWifiSmeWifiOnReqSerFree },
+    { CSR_WIFI_SME_CLOAKED_SSIDS_SET_REQ, CsrWifiSmeCloakedSsidsSetReqSizeof, CsrWifiSmeCloakedSsidsSetReqSer, CsrWifiSmeCloakedSsidsSetReqDes, CsrWifiSmeCloakedSsidsSetReqSerFree },
+    { CSR_WIFI_SME_CLOAKED_SSIDS_GET_REQ, CsrWifiSmeCloakedSsidsGetReqSizeof, CsrWifiSmeCloakedSsidsGetReqSer, CsrWifiSmeCloakedSsidsGetReqDes, CsrWifiSmeCloakedSsidsGetReqSerFree },
+    { CSR_WIFI_SME_SME_COMMON_CONFIG_GET_REQ, CsrWifiSmeSmeCommonConfigGetReqSizeof, CsrWifiSmeSmeCommonConfigGetReqSer, CsrWifiSmeSmeCommonConfigGetReqDes, CsrWifiSmeSmeCommonConfigGetReqSerFree },
+    { CSR_WIFI_SME_SME_COMMON_CONFIG_SET_REQ, CsrWifiSmeSmeCommonConfigSetReqSizeof, CsrWifiSmeSmeCommonConfigSetReqSer, CsrWifiSmeSmeCommonConfigSetReqDes, CsrWifiSmeSmeCommonConfigSetReqSerFree },
+    { CSR_WIFI_SME_INTERFACE_CAPABILITY_GET_REQ, CsrWifiSmeInterfaceCapabilityGetReqSizeof, CsrWifiSmeInterfaceCapabilityGetReqSer, CsrWifiSmeInterfaceCapabilityGetReqDes, CsrWifiSmeInterfaceCapabilityGetReqSerFree },
+    { CSR_WIFI_SME_WPS_CONFIGURATION_REQ, CsrWifiSmeWpsConfigurationReqSizeof, CsrWifiSmeWpsConfigurationReqSer, CsrWifiSmeWpsConfigurationReqDes, CsrWifiSmeWpsConfigurationReqSerFree },
+    { CSR_WIFI_SME_ACTIVATE_CFM, CsrWifiSmeActivateCfmSizeof, CsrWifiSmeActivateCfmSer, CsrWifiSmeActivateCfmDes, CsrWifiSmeActivateCfmSerFree },
+    { CSR_WIFI_SME_ADHOC_CONFIG_GET_CFM, CsrWifiSmeAdhocConfigGetCfmSizeof, CsrWifiSmeAdhocConfigGetCfmSer, CsrWifiSmeAdhocConfigGetCfmDes, CsrWifiSmeAdhocConfigGetCfmSerFree },
+    { CSR_WIFI_SME_ADHOC_CONFIG_SET_CFM, CsrWifiSmeAdhocConfigSetCfmSizeof, CsrWifiSmeAdhocConfigSetCfmSer, CsrWifiSmeAdhocConfigSetCfmDes, CsrWifiSmeAdhocConfigSetCfmSerFree },
+    { CSR_WIFI_SME_ASSOCIATION_COMPLETE_IND, CsrWifiSmeAssociationCompleteIndSizeof, CsrWifiSmeAssociationCompleteIndSer, CsrWifiSmeAssociationCompleteIndDes, CsrWifiSmeAssociationCompleteIndSerFree },
+    { CSR_WIFI_SME_ASSOCIATION_START_IND, CsrWifiSmeAssociationStartIndSizeof, CsrWifiSmeAssociationStartIndSer, CsrWifiSmeAssociationStartIndDes, CsrWifiSmeAssociationStartIndSerFree },
+    { CSR_WIFI_SME_BLACKLIST_CFM, CsrWifiSmeBlacklistCfmSizeof, CsrWifiSmeBlacklistCfmSer, CsrWifiSmeBlacklistCfmDes, CsrWifiSmeBlacklistCfmSerFree },
+    { CSR_WIFI_SME_CALIBRATION_DATA_GET_CFM, CsrWifiSmeCalibrationDataGetCfmSizeof, CsrWifiSmeCalibrationDataGetCfmSer, CsrWifiSmeCalibrationDataGetCfmDes, CsrWifiSmeCalibrationDataGetCfmSerFree },
+    { CSR_WIFI_SME_CALIBRATION_DATA_SET_CFM, CsrWifiSmeCalibrationDataSetCfmSizeof, CsrWifiSmeCalibrationDataSetCfmSer, CsrWifiSmeCalibrationDataSetCfmDes, CsrWifiSmeCalibrationDataSetCfmSerFree },
+    { CSR_WIFI_SME_CCX_CONFIG_GET_CFM, CsrWifiSmeCcxConfigGetCfmSizeof, CsrWifiSmeCcxConfigGetCfmSer, CsrWifiSmeCcxConfigGetCfmDes, CsrWifiSmeCcxConfigGetCfmSerFree },
+    { CSR_WIFI_SME_CCX_CONFIG_SET_CFM, CsrWifiSmeCcxConfigSetCfmSizeof, CsrWifiSmeCcxConfigSetCfmSer, CsrWifiSmeCcxConfigSetCfmDes, CsrWifiSmeCcxConfigSetCfmSerFree },
+    { CSR_WIFI_SME_COEX_CONFIG_GET_CFM, CsrWifiSmeCoexConfigGetCfmSizeof, CsrWifiSmeCoexConfigGetCfmSer, CsrWifiSmeCoexConfigGetCfmDes, CsrWifiSmeCoexConfigGetCfmSerFree },
+    { CSR_WIFI_SME_COEX_CONFIG_SET_CFM, CsrWifiSmeCoexConfigSetCfmSizeof, CsrWifiSmeCoexConfigSetCfmSer, CsrWifiSmeCoexConfigSetCfmDes, CsrWifiSmeCoexConfigSetCfmSerFree },
+    { CSR_WIFI_SME_COEX_INFO_GET_CFM, CsrWifiSmeCoexInfoGetCfmSizeof, CsrWifiSmeCoexInfoGetCfmSer, CsrWifiSmeCoexInfoGetCfmDes, CsrWifiSmeCoexInfoGetCfmSerFree },
+    { CSR_WIFI_SME_CONNECT_CFM, CsrWifiSmeConnectCfmSizeof, CsrWifiSmeConnectCfmSer, CsrWifiSmeConnectCfmDes, CsrWifiSmeConnectCfmSerFree },
+    { CSR_WIFI_SME_CONNECTION_CONFIG_GET_CFM, CsrWifiSmeConnectionConfigGetCfmSizeof, CsrWifiSmeConnectionConfigGetCfmSer, CsrWifiSmeConnectionConfigGetCfmDes, CsrWifiSmeConnectionConfigGetCfmSerFree },
+    { CSR_WIFI_SME_CONNECTION_INFO_GET_CFM, CsrWifiSmeConnectionInfoGetCfmSizeof, CsrWifiSmeConnectionInfoGetCfmSer, CsrWifiSmeConnectionInfoGetCfmDes, CsrWifiSmeConnectionInfoGetCfmSerFree },
+    { CSR_WIFI_SME_CONNECTION_QUALITY_IND, CsrWifiSmeConnectionQualityIndSizeof, CsrWifiSmeConnectionQualityIndSer, CsrWifiSmeConnectionQualityIndDes, CsrWifiSmeConnectionQualityIndSerFree },
+    { CSR_WIFI_SME_CONNECTION_STATS_GET_CFM, CsrWifiSmeConnectionStatsGetCfmSizeof, CsrWifiSmeConnectionStatsGetCfmSer, CsrWifiSmeConnectionStatsGetCfmDes, CsrWifiSmeConnectionStatsGetCfmSerFree },
+    { CSR_WIFI_SME_DEACTIVATE_CFM, CsrWifiSmeDeactivateCfmSizeof, CsrWifiSmeDeactivateCfmSer, CsrWifiSmeDeactivateCfmDes, CsrWifiSmeDeactivateCfmSerFree },
+    { CSR_WIFI_SME_DISCONNECT_CFM, CsrWifiSmeDisconnectCfmSizeof, CsrWifiSmeDisconnectCfmSer, CsrWifiSmeDisconnectCfmDes, CsrWifiSmeDisconnectCfmSerFree },
+    { CSR_WIFI_SME_EVENT_MASK_SET_CFM, CsrWifiSmeEventMaskSetCfmSizeof, CsrWifiSmeEventMaskSetCfmSer, CsrWifiSmeEventMaskSetCfmDes, CsrWifiSmeEventMaskSetCfmSerFree },
+    { CSR_WIFI_SME_HOST_CONFIG_GET_CFM, CsrWifiSmeHostConfigGetCfmSizeof, CsrWifiSmeHostConfigGetCfmSer, CsrWifiSmeHostConfigGetCfmDes, CsrWifiSmeHostConfigGetCfmSerFree },
+    { CSR_WIFI_SME_HOST_CONFIG_SET_CFM, CsrWifiSmeHostConfigSetCfmSizeof, CsrWifiSmeHostConfigSetCfmSer, CsrWifiSmeHostConfigSetCfmDes, CsrWifiSmeHostConfigSetCfmSerFree },
+    { CSR_WIFI_SME_IBSS_STATION_IND, CsrWifiSmeIbssStationIndSizeof, CsrWifiSmeIbssStationIndSer, CsrWifiSmeIbssStationIndDes, CsrWifiSmeIbssStationIndSerFree },
+    { CSR_WIFI_SME_KEY_CFM, CsrWifiSmeKeyCfmSizeof, CsrWifiSmeKeyCfmSer, CsrWifiSmeKeyCfmDes, CsrWifiSmeKeyCfmSerFree },
+    { CSR_WIFI_SME_LINK_QUALITY_GET_CFM, CsrWifiSmeLinkQualityGetCfmSizeof, CsrWifiSmeLinkQualityGetCfmSer, CsrWifiSmeLinkQualityGetCfmDes, CsrWifiSmeLinkQualityGetCfmSerFree },
+    { CSR_WIFI_SME_MEDIA_STATUS_IND, CsrWifiSmeMediaStatusIndSizeof, CsrWifiSmeMediaStatusIndSer, CsrWifiSmeMediaStatusIndDes, CsrWifiSmeMediaStatusIndSerFree },
+    { CSR_WIFI_SME_MIB_CONFIG_GET_CFM, CsrWifiSmeMibConfigGetCfmSizeof, CsrWifiSmeMibConfigGetCfmSer, CsrWifiSmeMibConfigGetCfmDes, CsrWifiSmeMibConfigGetCfmSerFree },
+    { CSR_WIFI_SME_MIB_CONFIG_SET_CFM, CsrWifiSmeMibConfigSetCfmSizeof, CsrWifiSmeMibConfigSetCfmSer, CsrWifiSmeMibConfigSetCfmDes, CsrWifiSmeMibConfigSetCfmSerFree },
+    { CSR_WIFI_SME_MIB_GET_CFM, CsrWifiSmeMibGetCfmSizeof, CsrWifiSmeMibGetCfmSer, CsrWifiSmeMibGetCfmDes, CsrWifiSmeMibGetCfmSerFree },
+    { CSR_WIFI_SME_MIB_GET_NEXT_CFM, CsrWifiSmeMibGetNextCfmSizeof, CsrWifiSmeMibGetNextCfmSer, CsrWifiSmeMibGetNextCfmDes, CsrWifiSmeMibGetNextCfmSerFree },
+    { CSR_WIFI_SME_MIB_SET_CFM, CsrWifiSmeMibSetCfmSizeof, CsrWifiSmeMibSetCfmSer, CsrWifiSmeMibSetCfmDes, CsrWifiSmeMibSetCfmSerFree },
+    { CSR_WIFI_SME_MIC_FAILURE_IND, CsrWifiSmeMicFailureIndSizeof, CsrWifiSmeMicFailureIndSer, CsrWifiSmeMicFailureIndDes, CsrWifiSmeMicFailureIndSerFree },
+    { CSR_WIFI_SME_MULTICAST_ADDRESS_CFM, CsrWifiSmeMulticastAddressCfmSizeof, CsrWifiSmeMulticastAddressCfmSer, CsrWifiSmeMulticastAddressCfmDes, CsrWifiSmeMulticastAddressCfmSerFree },
+    { CSR_WIFI_SME_PACKET_FILTER_SET_CFM, CsrWifiSmePacketFilterSetCfmSizeof, CsrWifiSmePacketFilterSetCfmSer, CsrWifiSmePacketFilterSetCfmDes, CsrWifiSmePacketFilterSetCfmSerFree },
+    { CSR_WIFI_SME_PERMANENT_MAC_ADDRESS_GET_CFM, CsrWifiSmePermanentMacAddressGetCfmSizeof, CsrWifiSmePermanentMacAddressGetCfmSer, CsrWifiSmePermanentMacAddressGetCfmDes, CsrWifiSmePermanentMacAddressGetCfmSerFree },
+    { CSR_WIFI_SME_PMKID_CANDIDATE_LIST_IND, CsrWifiSmePmkidCandidateListIndSizeof, CsrWifiSmePmkidCandidateListIndSer, CsrWifiSmePmkidCandidateListIndDes, CsrWifiSmePmkidCandidateListIndSerFree },
+    { CSR_WIFI_SME_PMKID_CFM, CsrWifiSmePmkidCfmSizeof, CsrWifiSmePmkidCfmSer, CsrWifiSmePmkidCfmDes, CsrWifiSmePmkidCfmSerFree },
+    { CSR_WIFI_SME_POWER_CONFIG_GET_CFM, CsrWifiSmePowerConfigGetCfmSizeof, CsrWifiSmePowerConfigGetCfmSer, CsrWifiSmePowerConfigGetCfmDes, CsrWifiSmePowerConfigGetCfmSerFree },
+    { CSR_WIFI_SME_POWER_CONFIG_SET_CFM, CsrWifiSmePowerConfigSetCfmSizeof, CsrWifiSmePowerConfigSetCfmSer, CsrWifiSmePowerConfigSetCfmDes, CsrWifiSmePowerConfigSetCfmSerFree },
+    { CSR_WIFI_SME_REGULATORY_DOMAIN_INFO_GET_CFM, CsrWifiSmeRegulatoryDomainInfoGetCfmSizeof, CsrWifiSmeRegulatoryDomainInfoGetCfmSer, CsrWifiSmeRegulatoryDomainInfoGetCfmDes, CsrWifiSmeRegulatoryDomainInfoGetCfmSerFree },
+    { CSR_WIFI_SME_ROAM_COMPLETE_IND, CsrWifiSmeRoamCompleteIndSizeof, CsrWifiSmeRoamCompleteIndSer, CsrWifiSmeRoamCompleteIndDes, CsrWifiSmeRoamCompleteIndSerFree },
+    { CSR_WIFI_SME_ROAM_START_IND, CsrWifiSmeRoamStartIndSizeof, CsrWifiSmeRoamStartIndSer, CsrWifiSmeRoamStartIndDes, CsrWifiSmeRoamStartIndSerFree },
+    { CSR_WIFI_SME_ROAMING_CONFIG_GET_CFM, CsrWifiSmeRoamingConfigGetCfmSizeof, CsrWifiSmeRoamingConfigGetCfmSer, CsrWifiSmeRoamingConfigGetCfmDes, CsrWifiSmeRoamingConfigGetCfmSerFree },
+    { CSR_WIFI_SME_ROAMING_CONFIG_SET_CFM, CsrWifiSmeRoamingConfigSetCfmSizeof, CsrWifiSmeRoamingConfigSetCfmSer, CsrWifiSmeRoamingConfigSetCfmDes, CsrWifiSmeRoamingConfigSetCfmSerFree },
+    { CSR_WIFI_SME_SCAN_CONFIG_GET_CFM, CsrWifiSmeScanConfigGetCfmSizeof, CsrWifiSmeScanConfigGetCfmSer, CsrWifiSmeScanConfigGetCfmDes, CsrWifiSmeScanConfigGetCfmSerFree },
+    { CSR_WIFI_SME_SCAN_CONFIG_SET_CFM, CsrWifiSmeScanConfigSetCfmSizeof, CsrWifiSmeScanConfigSetCfmSer, CsrWifiSmeScanConfigSetCfmDes, CsrWifiSmeScanConfigSetCfmSerFree },
+    { CSR_WIFI_SME_SCAN_FULL_CFM, CsrWifiSmeScanFullCfmSizeof, CsrWifiSmeScanFullCfmSer, CsrWifiSmeScanFullCfmDes, CsrWifiSmeScanFullCfmSerFree },
+    { CSR_WIFI_SME_SCAN_RESULT_IND, CsrWifiSmeScanResultIndSizeof, CsrWifiSmeScanResultIndSer, CsrWifiSmeScanResultIndDes, CsrWifiSmeScanResultIndSerFree },
+    { CSR_WIFI_SME_SCAN_RESULTS_FLUSH_CFM, CsrWifiSmeScanResultsFlushCfmSizeof, CsrWifiSmeScanResultsFlushCfmSer, CsrWifiSmeScanResultsFlushCfmDes, CsrWifiSmeScanResultsFlushCfmSerFree },
+    { CSR_WIFI_SME_SCAN_RESULTS_GET_CFM, CsrWifiSmeScanResultsGetCfmSizeof, CsrWifiSmeScanResultsGetCfmSer, CsrWifiSmeScanResultsGetCfmDes, CsrWifiSmeScanResultsGetCfmSerFree },
+    { CSR_WIFI_SME_SME_STA_CONFIG_GET_CFM, CsrWifiSmeSmeStaConfigGetCfmSizeof, CsrWifiSmeSmeStaConfigGetCfmSer, CsrWifiSmeSmeStaConfigGetCfmDes, CsrWifiSmeSmeStaConfigGetCfmSerFree },
+    { CSR_WIFI_SME_SME_STA_CONFIG_SET_CFM, CsrWifiSmeSmeStaConfigSetCfmSizeof, CsrWifiSmeSmeStaConfigSetCfmSer, CsrWifiSmeSmeStaConfigSetCfmDes, CsrWifiSmeSmeStaConfigSetCfmSerFree },
+    { CSR_WIFI_SME_STATION_MAC_ADDRESS_GET_CFM, CsrWifiSmeStationMacAddressGetCfmSizeof, CsrWifiSmeStationMacAddressGetCfmSer, CsrWifiSmeStationMacAddressGetCfmDes, CsrWifiSmeStationMacAddressGetCfmSerFree },
+    { CSR_WIFI_SME_TSPEC_IND, CsrWifiSmeTspecIndSizeof, CsrWifiSmeTspecIndSer, CsrWifiSmeTspecIndDes, CsrWifiSmeTspecIndSerFree },
+    { CSR_WIFI_SME_TSPEC_CFM, CsrWifiSmeTspecCfmSizeof, CsrWifiSmeTspecCfmSer, CsrWifiSmeTspecCfmDes, CsrWifiSmeTspecCfmSerFree },
+    { CSR_WIFI_SME_VERSIONS_GET_CFM, CsrWifiSmeVersionsGetCfmSizeof, CsrWifiSmeVersionsGetCfmSer, CsrWifiSmeVersionsGetCfmDes, CsrWifiSmeVersionsGetCfmSerFree },
+    { CSR_WIFI_SME_WIFI_FLIGHTMODE_CFM, CsrWifiSmeWifiFlightmodeCfmSizeof, CsrWifiSmeWifiFlightmodeCfmSer, CsrWifiSmeWifiFlightmodeCfmDes, CsrWifiSmeWifiFlightmodeCfmSerFree },
+    { CSR_WIFI_SME_WIFI_OFF_IND, CsrWifiSmeWifiOffIndSizeof, CsrWifiSmeWifiOffIndSer, CsrWifiSmeWifiOffIndDes, CsrWifiSmeWifiOffIndSerFree },
+    { CSR_WIFI_SME_WIFI_OFF_CFM, CsrWifiSmeWifiOffCfmSizeof, CsrWifiSmeWifiOffCfmSer, CsrWifiSmeWifiOffCfmDes, CsrWifiSmeWifiOffCfmSerFree },
+    { CSR_WIFI_SME_WIFI_ON_CFM, CsrWifiSmeWifiOnCfmSizeof, CsrWifiSmeWifiOnCfmSer, CsrWifiSmeWifiOnCfmDes, CsrWifiSmeWifiOnCfmSerFree },
+    { CSR_WIFI_SME_CLOAKED_SSIDS_SET_CFM, CsrWifiSmeCloakedSsidsSetCfmSizeof, CsrWifiSmeCloakedSsidsSetCfmSer, CsrWifiSmeCloakedSsidsSetCfmDes, CsrWifiSmeCloakedSsidsSetCfmSerFree },
+    { CSR_WIFI_SME_CLOAKED_SSIDS_GET_CFM, CsrWifiSmeCloakedSsidsGetCfmSizeof, CsrWifiSmeCloakedSsidsGetCfmSer, CsrWifiSmeCloakedSsidsGetCfmDes, CsrWifiSmeCloakedSsidsGetCfmSerFree },
+    { CSR_WIFI_SME_WIFI_ON_IND, CsrWifiSmeWifiOnIndSizeof, CsrWifiSmeWifiOnIndSer, CsrWifiSmeWifiOnIndDes, CsrWifiSmeWifiOnIndSerFree },
+    { CSR_WIFI_SME_SME_COMMON_CONFIG_GET_CFM, CsrWifiSmeSmeCommonConfigGetCfmSizeof, CsrWifiSmeSmeCommonConfigGetCfmSer, CsrWifiSmeSmeCommonConfigGetCfmDes, CsrWifiSmeSmeCommonConfigGetCfmSerFree },
+    { CSR_WIFI_SME_SME_COMMON_CONFIG_SET_CFM, CsrWifiSmeSmeCommonConfigSetCfmSizeof, CsrWifiSmeSmeCommonConfigSetCfmSer, CsrWifiSmeSmeCommonConfigSetCfmDes, CsrWifiSmeSmeCommonConfigSetCfmSerFree },
+    { CSR_WIFI_SME_INTERFACE_CAPABILITY_GET_CFM, CsrWifiSmeInterfaceCapabilityGetCfmSizeof, CsrWifiSmeInterfaceCapabilityGetCfmSer, CsrWifiSmeInterfaceCapabilityGetCfmDes, CsrWifiSmeInterfaceCapabilityGetCfmSerFree },
+    { CSR_WIFI_SME_ERROR_IND, CsrWifiSmeErrorIndSizeof, CsrWifiSmeErrorIndSer, CsrWifiSmeErrorIndDes, CsrWifiSmeErrorIndSerFree },
+    { CSR_WIFI_SME_INFO_IND, CsrWifiSmeInfoIndSizeof, CsrWifiSmeInfoIndSer, CsrWifiSmeInfoIndDes, CsrWifiSmeInfoIndSerFree },
+    { CSR_WIFI_SME_CORE_DUMP_IND, CsrWifiSmeCoreDumpIndSizeof, CsrWifiSmeCoreDumpIndSer, CsrWifiSmeCoreDumpIndDes, CsrWifiSmeCoreDumpIndSerFree },
+    { CSR_WIFI_SME_AMP_STATUS_CHANGE_IND, CsrWifiSmeAmpStatusChangeIndSizeof, CsrWifiSmeAmpStatusChangeIndSer, CsrWifiSmeAmpStatusChangeIndDes, CsrWifiSmeAmpStatusChangeIndSerFree },
+    { CSR_WIFI_SME_WPS_CONFIGURATION_CFM, CsrWifiSmeWpsConfigurationCfmSizeof, CsrWifiSmeWpsConfigurationCfmSer, CsrWifiSmeWpsConfigurationCfmDes, CsrWifiSmeWpsConfigurationCfmSerFree },
+
+    { 0, NULL, NULL, NULL, NULL },
+};
+
+CsrMsgConvMsgEntry* CsrWifiSmeConverterLookup(CsrMsgConvMsgEntry *ce, CsrUint16 msgType)
+{
+    if (msgType & CSR_PRIM_UPSTREAM)
+    {
+        CsrUint16 index = (msgType & ~CSR_PRIM_UPSTREAM) + CSR_WIFI_SME_PRIM_DOWNSTREAM_COUNT;
+        if (index < (CSR_WIFI_SME_PRIM_UPSTREAM_COUNT + CSR_WIFI_SME_PRIM_DOWNSTREAM_COUNT) &&
+            csrwifisme_conv_lut[index].msgType == msgType)
+        {
+            return &csrwifisme_conv_lut[index];
+        }
+    }
+    else
+    {
+        if (msgType < CSR_WIFI_SME_PRIM_DOWNSTREAM_COUNT &&
+            csrwifisme_conv_lut[msgType].msgType == msgType)
+        {
+            return &csrwifisme_conv_lut[msgType];
+        }
+    }
+    return NULL;
+}
+
+
+void CsrWifiSmeConverterInit(void)
+{
+    CsrMsgConvInsert(CSR_WIFI_SME_PRIM, csrwifisme_conv_lut);
+    CsrMsgConvCustomLookupRegister(CSR_WIFI_SME_PRIM, CsrWifiSmeConverterLookup);
+}
+
+
+#ifdef CSR_LOG_ENABLE
+static const CsrLogPrimitiveInformation csrwifisme_conv_info = {
+    CSR_WIFI_SME_PRIM,
+    (CsrCharString *)"CSR_WIFI_SME_PRIM",
+    csrwifisme_conv_lut
+};
+const CsrLogPrimitiveInformation* CsrWifiSmeTechInfoGet(void)
+{
+    return &csrwifisme_conv_info;
+}
+
+
+#endif /* CSR_LOG_ENABLE */
+#endif /* EXCLUDE_CSR_WIFI_SME_MODULE */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_converter_init.h
@@ -0,0 +1,42 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_SME_CONVERTER_INIT_H__
+#define CSR_WIFI_SME_CONVERTER_INIT_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef EXCLUDE_CSR_WIFI_SME_MODULE
+
+#include "csr_msgconv.h"
+
+#ifdef CSR_LOG_ENABLE
+#include "csr_log.h"
+
+extern const CsrLogPrimitiveInformation* CsrWifiSmeTechInfoGet(void);
+#endif /* CSR_LOG_ENABLE */
+
+extern void CsrWifiSmeConverterInit(void);
+
+#else /* EXCLUDE_CSR_WIFI_SME_MODULE */
+
+#define CsrWifiSmeConverterInit()
+
+#endif /* EXCLUDE_CSR_WIFI_SME_MODULE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_SME_CONVERTER_INIT_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_free_downstream_contents.c
@@ -0,0 +1,181 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_pmem.h"
+#include "csr_wifi_sme_prim.h"
+#include "csr_wifi_sme_lib.h"
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrWifiSmeFreeDownstreamMessageContents
+ *
+ *  DESCRIPTION
+ *
+ *
+ *  PARAMETERS
+ *      eventClass: only the value CSR_WIFI_SME_PRIM will be handled
+ *      message:    the message to free
+ *----------------------------------------------------------------------------*/
+void CsrWifiSmeFreeDownstreamMessageContents(CsrUint16 eventClass, void *message)
+{
+    if (eventClass != CSR_WIFI_SME_PRIM)
+    {
+        return;
+    }
+    if (NULL == message)
+    {
+        return;
+    }
+
+    switch (*((CsrWifiSmePrim *) message))
+    {
+        case CSR_WIFI_SME_BLACKLIST_REQ:
+        {
+            CsrWifiSmeBlacklistReq *p = (CsrWifiSmeBlacklistReq *)message;
+            CsrPmemFree(p->setAddresses);
+            p->setAddresses = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_CALIBRATION_DATA_SET_REQ:
+        {
+            CsrWifiSmeCalibrationDataSetReq *p = (CsrWifiSmeCalibrationDataSetReq *)message;
+            CsrPmemFree(p->calibrationData);
+            p->calibrationData = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_CONNECT_REQ:
+        {
+            CsrWifiSmeConnectReq *p = (CsrWifiSmeConnectReq *)message;
+            CsrPmemFree(p->connectionConfig.mlmeAssociateReqInformationElements);
+            p->connectionConfig.mlmeAssociateReqInformationElements = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_MIB_GET_NEXT_REQ:
+        {
+            CsrWifiSmeMibGetNextReq *p = (CsrWifiSmeMibGetNextReq *)message;
+            CsrPmemFree(p->mibAttribute);
+            p->mibAttribute = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_MIB_GET_REQ:
+        {
+            CsrWifiSmeMibGetReq *p = (CsrWifiSmeMibGetReq *)message;
+            CsrPmemFree(p->mibAttribute);
+            p->mibAttribute = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_MIB_SET_REQ:
+        {
+            CsrWifiSmeMibSetReq *p = (CsrWifiSmeMibSetReq *)message;
+            CsrPmemFree(p->mibAttribute);
+            p->mibAttribute = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_MULTICAST_ADDRESS_REQ:
+        {
+            CsrWifiSmeMulticastAddressReq *p = (CsrWifiSmeMulticastAddressReq *)message;
+            CsrPmemFree(p->setAddresses);
+            p->setAddresses = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_PACKET_FILTER_SET_REQ:
+        {
+            CsrWifiSmePacketFilterSetReq *p = (CsrWifiSmePacketFilterSetReq *)message;
+            CsrPmemFree(p->filter);
+            p->filter = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_PMKID_REQ:
+        {
+            CsrWifiSmePmkidReq *p = (CsrWifiSmePmkidReq *)message;
+            CsrPmemFree(p->setPmkids);
+            p->setPmkids = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_SCAN_CONFIG_SET_REQ:
+        {
+            CsrWifiSmeScanConfigSetReq *p = (CsrWifiSmeScanConfigSetReq *)message;
+            CsrPmemFree(p->scanConfig.passiveChannelList);
+            p->scanConfig.passiveChannelList = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_SCAN_FULL_REQ:
+        {
+            CsrWifiSmeScanFullReq *p = (CsrWifiSmeScanFullReq *)message;
+            CsrPmemFree(p->ssid);
+            p->ssid = NULL;
+            CsrPmemFree(p->channelList);
+            p->channelList = NULL;
+            CsrPmemFree(p->probeIe);
+            p->probeIe = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_TSPEC_REQ:
+        {
+            CsrWifiSmeTspecReq *p = (CsrWifiSmeTspecReq *)message;
+            CsrPmemFree(p->tspec);
+            p->tspec = NULL;
+            CsrPmemFree(p->tclas);
+            p->tclas = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_WIFI_FLIGHTMODE_REQ:
+        {
+            CsrWifiSmeWifiFlightmodeReq *p = (CsrWifiSmeWifiFlightmodeReq *)message;
+            {
+                CsrUint16 i1;
+                for (i1 = 0; i1 < p->mibFilesCount; i1++)
+                {
+                    CsrPmemFree(p->mibFiles[i1].data);
+                    p->mibFiles[i1].data = NULL;
+                }
+            }
+            CsrPmemFree(p->mibFiles);
+            p->mibFiles = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_WIFI_ON_REQ:
+        {
+            CsrWifiSmeWifiOnReq *p = (CsrWifiSmeWifiOnReq *)message;
+            {
+                CsrUint16 i1;
+                for (i1 = 0; i1 < p->mibFilesCount; i1++)
+                {
+                    CsrPmemFree(p->mibFiles[i1].data);
+                    p->mibFiles[i1].data = NULL;
+                }
+            }
+            CsrPmemFree(p->mibFiles);
+            p->mibFiles = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_CLOAKED_SSIDS_SET_REQ:
+        {
+            CsrWifiSmeCloakedSsidsSetReq *p = (CsrWifiSmeCloakedSsidsSetReq *)message;
+            CsrPmemFree(p->cloakedSsids.cloakedSsids);
+            p->cloakedSsids.cloakedSsids = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_WPS_CONFIGURATION_REQ:
+        {
+            CsrWifiSmeWpsConfigurationReq *p = (CsrWifiSmeWpsConfigurationReq *)message;
+            CsrPmemFree(p->wpsConfig.secondaryDeviceType);
+            p->wpsConfig.secondaryDeviceType = NULL;
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_free_upstream_contents.c
@@ -0,0 +1,276 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_pmem.h"
+#include "csr_wifi_sme_prim.h"
+#include "csr_wifi_sme_lib.h"
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrWifiSmeFreeUpstreamMessageContents
+ *
+ *  DESCRIPTION
+ *
+ *
+ *  PARAMETERS
+ *      eventClass: only the value CSR_WIFI_SME_PRIM will be handled
+ *      message:    the message to free
+ *----------------------------------------------------------------------------*/
+void CsrWifiSmeFreeUpstreamMessageContents(CsrUint16 eventClass, void *message)
+{
+    if (eventClass != CSR_WIFI_SME_PRIM)
+    {
+        return;
+    }
+    if (NULL == message)
+    {
+        return;
+    }
+
+    switch (*((CsrWifiSmePrim *) message))
+    {
+        case CSR_WIFI_SME_ASSOCIATION_COMPLETE_IND:
+        {
+            CsrWifiSmeAssociationCompleteInd *p = (CsrWifiSmeAssociationCompleteInd *)message;
+            CsrPmemFree(p->connectionInfo.beaconFrame);
+            p->connectionInfo.beaconFrame = NULL;
+            CsrPmemFree(p->connectionInfo.associationReqFrame);
+            p->connectionInfo.associationReqFrame = NULL;
+            CsrPmemFree(p->connectionInfo.associationRspFrame);
+            p->connectionInfo.associationRspFrame = NULL;
+            CsrPmemFree(p->connectionInfo.assocScanInfoElements);
+            p->connectionInfo.assocScanInfoElements = NULL;
+            CsrPmemFree(p->connectionInfo.assocReqInfoElements);
+            p->connectionInfo.assocReqInfoElements = NULL;
+            CsrPmemFree(p->connectionInfo.assocRspInfoElements);
+            p->connectionInfo.assocRspInfoElements = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_BLACKLIST_CFM:
+        {
+            CsrWifiSmeBlacklistCfm *p = (CsrWifiSmeBlacklistCfm *)message;
+            CsrPmemFree(p->getAddresses);
+            p->getAddresses = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_CALIBRATION_DATA_GET_CFM:
+        {
+            CsrWifiSmeCalibrationDataGetCfm *p = (CsrWifiSmeCalibrationDataGetCfm *)message;
+            CsrPmemFree(p->calibrationData);
+            p->calibrationData = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_CONNECTION_CONFIG_GET_CFM:
+        {
+            CsrWifiSmeConnectionConfigGetCfm *p = (CsrWifiSmeConnectionConfigGetCfm *)message;
+            CsrPmemFree(p->connectionConfig.mlmeAssociateReqInformationElements);
+            p->connectionConfig.mlmeAssociateReqInformationElements = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_CONNECTION_INFO_GET_CFM:
+        {
+            CsrWifiSmeConnectionInfoGetCfm *p = (CsrWifiSmeConnectionInfoGetCfm *)message;
+            CsrPmemFree(p->connectionInfo.beaconFrame);
+            p->connectionInfo.beaconFrame = NULL;
+            CsrPmemFree(p->connectionInfo.associationReqFrame);
+            p->connectionInfo.associationReqFrame = NULL;
+            CsrPmemFree(p->connectionInfo.associationRspFrame);
+            p->connectionInfo.associationRspFrame = NULL;
+            CsrPmemFree(p->connectionInfo.assocScanInfoElements);
+            p->connectionInfo.assocScanInfoElements = NULL;
+            CsrPmemFree(p->connectionInfo.assocReqInfoElements);
+            p->connectionInfo.assocReqInfoElements = NULL;
+            CsrPmemFree(p->connectionInfo.assocRspInfoElements);
+            p->connectionInfo.assocRspInfoElements = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_MEDIA_STATUS_IND:
+        {
+            CsrWifiSmeMediaStatusInd *p = (CsrWifiSmeMediaStatusInd *)message;
+            CsrPmemFree(p->connectionInfo.beaconFrame);
+            p->connectionInfo.beaconFrame = NULL;
+            CsrPmemFree(p->connectionInfo.associationReqFrame);
+            p->connectionInfo.associationReqFrame = NULL;
+            CsrPmemFree(p->connectionInfo.associationRspFrame);
+            p->connectionInfo.associationRspFrame = NULL;
+            CsrPmemFree(p->connectionInfo.assocScanInfoElements);
+            p->connectionInfo.assocScanInfoElements = NULL;
+            CsrPmemFree(p->connectionInfo.assocReqInfoElements);
+            p->connectionInfo.assocReqInfoElements = NULL;
+            CsrPmemFree(p->connectionInfo.assocRspInfoElements);
+            p->connectionInfo.assocRspInfoElements = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_MIB_GET_CFM:
+        {
+            CsrWifiSmeMibGetCfm *p = (CsrWifiSmeMibGetCfm *)message;
+            CsrPmemFree(p->mibAttribute);
+            p->mibAttribute = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_MIB_GET_NEXT_CFM:
+        {
+            CsrWifiSmeMibGetNextCfm *p = (CsrWifiSmeMibGetNextCfm *)message;
+            CsrPmemFree(p->mibAttribute);
+            p->mibAttribute = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_MULTICAST_ADDRESS_CFM:
+        {
+            CsrWifiSmeMulticastAddressCfm *p = (CsrWifiSmeMulticastAddressCfm *)message;
+            CsrPmemFree(p->getAddresses);
+            p->getAddresses = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_PMKID_CANDIDATE_LIST_IND:
+        {
+            CsrWifiSmePmkidCandidateListInd *p = (CsrWifiSmePmkidCandidateListInd *)message;
+            CsrPmemFree(p->pmkidCandidates);
+            p->pmkidCandidates = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_PMKID_CFM:
+        {
+            CsrWifiSmePmkidCfm *p = (CsrWifiSmePmkidCfm *)message;
+            CsrPmemFree(p->getPmkids);
+            p->getPmkids = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_SCAN_CONFIG_GET_CFM:
+        {
+            CsrWifiSmeScanConfigGetCfm *p = (CsrWifiSmeScanConfigGetCfm *)message;
+            CsrPmemFree(p->scanConfig.passiveChannelList);
+            p->scanConfig.passiveChannelList = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_SCAN_RESULT_IND:
+        {
+            CsrWifiSmeScanResultInd *p = (CsrWifiSmeScanResultInd *)message;
+            CsrPmemFree(p->result.informationElements);
+            p->result.informationElements = NULL;
+            switch (p->result.p2pDeviceRole)
+            {
+                case CSR_WIFI_SME_P2P_ROLE_GO:
+                {
+                    CsrUint16 i4;
+                    for (i4 = 0; i4 < p->result.deviceInfo.groupInfo.p2pClientInfoCount; i4++)
+                    {
+                        CsrPmemFree(p->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType);
+                        p->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType = NULL;
+                    }
+                }
+                    CsrPmemFree(p->result.deviceInfo.groupInfo.p2PClientInfo);
+                    p->result.deviceInfo.groupInfo.p2PClientInfo = NULL;
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_STANDALONE:
+                    CsrPmemFree(p->result.deviceInfo.standalonedevInfo.secDeviceType);
+                    p->result.deviceInfo.standalonedevInfo.secDeviceType = NULL;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        }
+        case CSR_WIFI_SME_SCAN_RESULTS_GET_CFM:
+        {
+            CsrWifiSmeScanResultsGetCfm *p = (CsrWifiSmeScanResultsGetCfm *)message;
+            {
+                CsrUint16 i1;
+                for (i1 = 0; i1 < p->scanResultsCount; i1++)
+                {
+                    CsrPmemFree(p->scanResults[i1].informationElements);
+                    p->scanResults[i1].informationElements = NULL;
+                    switch (p->scanResults[i1].p2pDeviceRole)
+                    {
+                        case CSR_WIFI_SME_P2P_ROLE_GO:
+                        {
+                            CsrUint16 i4;
+                            for (i4 = 0; i4 < p->scanResults[i1].deviceInfo.groupInfo.p2pClientInfoCount; i4++)
+                            {
+                                CsrPmemFree(p->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType);
+                                p->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType = NULL;
+                            }
+                        }
+                            CsrPmemFree(p->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo);
+                            p->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo = NULL;
+                            break;
+                        case CSR_WIFI_SME_P2P_ROLE_STANDALONE:
+                            CsrPmemFree(p->scanResults[i1].deviceInfo.standalonedevInfo.secDeviceType);
+                            p->scanResults[i1].deviceInfo.standalonedevInfo.secDeviceType = NULL;
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+            CsrPmemFree(p->scanResults);
+            p->scanResults = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_TSPEC_IND:
+        {
+            CsrWifiSmeTspecInd *p = (CsrWifiSmeTspecInd *)message;
+            CsrPmemFree(p->tspec);
+            p->tspec = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_TSPEC_CFM:
+        {
+            CsrWifiSmeTspecCfm *p = (CsrWifiSmeTspecCfm *)message;
+            CsrPmemFree(p->tspec);
+            p->tspec = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_VERSIONS_GET_CFM:
+        {
+            CsrWifiSmeVersionsGetCfm *p = (CsrWifiSmeVersionsGetCfm *)message;
+            CsrPmemFree(p->versions.routerBuild);
+            p->versions.routerBuild = NULL;
+            CsrPmemFree(p->versions.smeBuild);
+            p->versions.smeBuild = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_CLOAKED_SSIDS_GET_CFM:
+        {
+            CsrWifiSmeCloakedSsidsGetCfm *p = (CsrWifiSmeCloakedSsidsGetCfm *)message;
+            CsrPmemFree(p->cloakedSsids.cloakedSsids);
+            p->cloakedSsids.cloakedSsids = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_ERROR_IND:
+        {
+            CsrWifiSmeErrorInd *p = (CsrWifiSmeErrorInd *)message;
+            CsrPmemFree(p->errorMessage);
+            p->errorMessage = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_INFO_IND:
+        {
+            CsrWifiSmeInfoInd *p = (CsrWifiSmeInfoInd *)message;
+            CsrPmemFree(p->infoMessage);
+            p->infoMessage = NULL;
+            break;
+        }
+        case CSR_WIFI_SME_CORE_DUMP_IND:
+        {
+            CsrWifiSmeCoreDumpInd *p = (CsrWifiSmeCoreDumpInd *)message;
+            CsrPmemFree(p->data);
+            p->data = NULL;
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_lib.h
@@ -0,0 +1,4282 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_SME_LIB_H__
+#define CSR_WIFI_SME_LIB_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_sched.h"
+#include "csr_util.h"
+#include "csr_msg_transport.h"
+
+#include "csr_wifi_lib.h"
+
+#include "csr_wifi_sme_prim.h"
+#include "csr_wifi_sme_task.h"
+
+
+#ifndef CSR_WIFI_SME_LIB_DESTINATION_QUEUE
+# ifdef CSR_WIFI_NME_ENABLE
+# include "csr_wifi_nme_task.h"
+# define CSR_WIFI_SME_LIB_DESTINATION_QUEUE CSR_WIFI_NME_IFACEQUEUE
+# else
+# define CSR_WIFI_SME_LIB_DESTINATION_QUEUE CSR_WIFI_SME_IFACEQUEUE
+# endif
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiSmeFreeUpstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_SME upstream message. Does not
+ *      free the message itself, and can only be used for upstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_SME upstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiSmeFreeUpstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ *  CsrWifiSmeFreeDownstreamMessageContents
+ *
+ *  DESCRIPTION
+ *      Free the allocated memory in a CSR_WIFI_SME downstream message. Does not
+ *      free the message itself, and can only be used for downstream messages.
+ *
+ *  PARAMETERS
+ *      Deallocates the resources in a CSR_WIFI_SME downstream message
+ *----------------------------------------------------------------------------*/
+void CsrWifiSmeFreeDownstreamMessageContents(CsrUint16 eventClass, void *message);
+
+/*----------------------------------------------------------------------------*
+ * Enum to string functions
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiSme80211NetworkTypeToString(CsrWifiSme80211NetworkType value);
+const CsrCharString* CsrWifiSme80211PrivacyModeToString(CsrWifiSme80211PrivacyMode value);
+const CsrCharString* CsrWifiSme80211dTrustLevelToString(CsrWifiSme80211dTrustLevel value);
+const CsrCharString* CsrWifiSmeAmpStatusToString(CsrWifiSmeAmpStatus value);
+const CsrCharString* CsrWifiSmeAuthModeToString(CsrWifiSmeAuthMode value);
+const CsrCharString* CsrWifiSmeBasicUsabilityToString(CsrWifiSmeBasicUsability value);
+const CsrCharString* CsrWifiSmeBssTypeToString(CsrWifiSmeBssType value);
+const CsrCharString* CsrWifiSmeCoexSchemeToString(CsrWifiSmeCoexScheme value);
+const CsrCharString* CsrWifiSmeControlIndicationToString(CsrWifiSmeControlIndication value);
+const CsrCharString* CsrWifiSmeCtsProtectionTypeToString(CsrWifiSmeCtsProtectionType value);
+const CsrCharString* CsrWifiSmeD3AutoScanModeToString(CsrWifiSmeD3AutoScanMode value);
+const CsrCharString* CsrWifiSmeEncryptionToString(CsrWifiSmeEncryption value);
+const CsrCharString* CsrWifiSmeFirmwareDriverInterfaceToString(CsrWifiSmeFirmwareDriverInterface value);
+const CsrCharString* CsrWifiSmeHostPowerModeToString(CsrWifiSmeHostPowerMode value);
+const CsrCharString* CsrWifiSmeIEEE80211ReasonToString(CsrWifiSmeIEEE80211Reason value);
+const CsrCharString* CsrWifiSmeIEEE80211ResultToString(CsrWifiSmeIEEE80211Result value);
+const CsrCharString* CsrWifiSmeIndicationsToString(CsrWifiSmeIndications value);
+const CsrCharString* CsrWifiSmeKeyTypeToString(CsrWifiSmeKeyType value);
+const CsrCharString* CsrWifiSmeListActionToString(CsrWifiSmeListAction value);
+const CsrCharString* CsrWifiSmeMediaStatusToString(CsrWifiSmeMediaStatus value);
+const CsrCharString* CsrWifiSmeP2pCapabilityToString(CsrWifiSmeP2pCapability value);
+const CsrCharString* CsrWifiSmeP2pGroupCapabilityToString(CsrWifiSmeP2pGroupCapability value);
+const CsrCharString* CsrWifiSmeP2pNoaConfigMethodToString(CsrWifiSmeP2pNoaConfigMethod value);
+const CsrCharString* CsrWifiSmeP2pRoleToString(CsrWifiSmeP2pRole value);
+const CsrCharString* CsrWifiSmeP2pStatusToString(CsrWifiSmeP2pStatus value);
+const CsrCharString* CsrWifiSmePacketFilterModeToString(CsrWifiSmePacketFilterMode value);
+const CsrCharString* CsrWifiSmePowerSaveLevelToString(CsrWifiSmePowerSaveLevel value);
+const CsrCharString* CsrWifiSmePreambleTypeToString(CsrWifiSmePreambleType value);
+const CsrCharString* CsrWifiSmeRadioIFToString(CsrWifiSmeRadioIF value);
+const CsrCharString* CsrWifiSmeRegulatoryDomainToString(CsrWifiSmeRegulatoryDomain value);
+const CsrCharString* CsrWifiSmeRoamReasonToString(CsrWifiSmeRoamReason value);
+const CsrCharString* CsrWifiSmeScanTypeToString(CsrWifiSmeScanType value);
+const CsrCharString* CsrWifiSmeTrafficTypeToString(CsrWifiSmeTrafficType value);
+const CsrCharString* CsrWifiSmeTspecCtrlToString(CsrWifiSmeTspecCtrl value);
+const CsrCharString* CsrWifiSmeTspecResultCodeToString(CsrWifiSmeTspecResultCode value);
+const CsrCharString* CsrWifiSmeWepAuthModeToString(CsrWifiSmeWepAuthMode value);
+const CsrCharString* CsrWifiSmeWepCredentialTypeToString(CsrWifiSmeWepCredentialType value);
+const CsrCharString* CsrWifiSmeWmmModeToString(CsrWifiSmeWmmMode value);
+const CsrCharString* CsrWifiSmeWmmQosInfoToString(CsrWifiSmeWmmQosInfo value);
+const CsrCharString* CsrWifiSmeWpsConfigTypeToString(CsrWifiSmeWpsConfigType value);
+const CsrCharString* CsrWifiSmeWpsDeviceCategoryToString(CsrWifiSmeWpsDeviceCategory value);
+const CsrCharString* CsrWifiSmeWpsDeviceSubCategoryToString(CsrWifiSmeWpsDeviceSubCategory value);
+const CsrCharString* CsrWifiSmeWpsDpidToString(CsrWifiSmeWpsDpid value);
+const CsrCharString* CsrWifiSmeWpsRegistrationToString(CsrWifiSmeWpsRegistration value);
+
+
+/*----------------------------------------------------------------------------*
+ * CsrPrim Type toString function.
+ * Converts a message type to the String name of the Message
+ *----------------------------------------------------------------------------*/
+const CsrCharString* CsrWifiSmePrimTypeToString(CsrPrim msgType);
+
+/*----------------------------------------------------------------------------*
+ * Lookup arrays for PrimType name Strings
+ *----------------------------------------------------------------------------*/
+extern const CsrCharString *CsrWifiSmeUpstreamPrimNames[CSR_WIFI_SME_PRIM_UPSTREAM_COUNT];
+extern const CsrCharString *CsrWifiSmeDownstreamPrimNames[CSR_WIFI_SME_PRIM_DOWNSTREAM_COUNT];
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeActivateReqSend
+
+  DESCRIPTION
+    The WMA sends this primitive to activate the SME.
+    The WMA must activate the SME before it can send any other primitive.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeActivateReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeActivateReq *) CsrPmemAlloc(sizeof(CsrWifiSmeActivateReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ACTIVATE_REQ, dst__, src__);
+
+#define CsrWifiSmeActivateReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeActivateReq *msg__; \
+        CsrWifiSmeActivateReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeActivateReqSend(src__) \
+    CsrWifiSmeActivateReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeActivateCfmSend
+
+  DESCRIPTION
+    The SME sends this primitive when the activation is complete.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeActivateCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeActivateCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeActivateCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ACTIVATE_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeActivateCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeActivateCfm *msg__; \
+        CsrWifiSmeActivateCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeActivateCfmSend(dst__, status__) \
+    CsrWifiSmeActivateCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAdhocConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the adHocConfig parameter.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeAdhocConfigGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeAdhocConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeAdhocConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ADHOC_CONFIG_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeAdhocConfigGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeAdhocConfigGetReq *msg__; \
+        CsrWifiSmeAdhocConfigGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeAdhocConfigGetReqSend(src__) \
+    CsrWifiSmeAdhocConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAdhocConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue       - Destination Task Queue
+    status      - Reports the result of the request
+    adHocConfig - Contains the values used when starting an Ad-hoc (IBSS)
+                  connection.
+
+*******************************************************************************/
+#define CsrWifiSmeAdhocConfigGetCfmCreate(msg__, dst__, src__, status__, adHocConfig__) \
+    msg__ = (CsrWifiSmeAdhocConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeAdhocConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ADHOC_CONFIG_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->adHocConfig = (adHocConfig__);
+
+#define CsrWifiSmeAdhocConfigGetCfmSendTo(dst__, src__, status__, adHocConfig__) \
+    { \
+        CsrWifiSmeAdhocConfigGetCfm *msg__; \
+        CsrWifiSmeAdhocConfigGetCfmCreate(msg__, dst__, src__, status__, adHocConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeAdhocConfigGetCfmSend(dst__, status__, adHocConfig__) \
+    CsrWifiSmeAdhocConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, adHocConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAdhocConfigSetReqSend
+
+  DESCRIPTION
+    This primitive sets the value of the adHocConfig parameter.
+
+  PARAMETERS
+    queue       - Message Source Task Queue (Cfm's will be sent to this Queue)
+    adHocConfig - Sets the values to use when starting an ad hoc network.
+
+*******************************************************************************/
+#define CsrWifiSmeAdhocConfigSetReqCreate(msg__, dst__, src__, adHocConfig__) \
+    msg__ = (CsrWifiSmeAdhocConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeAdhocConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ADHOC_CONFIG_SET_REQ, dst__, src__); \
+    msg__->adHocConfig = (adHocConfig__);
+
+#define CsrWifiSmeAdhocConfigSetReqSendTo(dst__, src__, adHocConfig__) \
+    { \
+        CsrWifiSmeAdhocConfigSetReq *msg__; \
+        CsrWifiSmeAdhocConfigSetReqCreate(msg__, dst__, src__, adHocConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeAdhocConfigSetReqSend(src__, adHocConfig__) \
+    CsrWifiSmeAdhocConfigSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, adHocConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAdhocConfigSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeAdhocConfigSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeAdhocConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeAdhocConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ADHOC_CONFIG_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeAdhocConfigSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeAdhocConfigSetCfm *msg__; \
+        CsrWifiSmeAdhocConfigSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeAdhocConfigSetCfmSend(dst__, status__) \
+    CsrWifiSmeAdhocConfigSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAmpStatusChangeIndSend
+
+  DESCRIPTION
+    Indication of change to AMP activity.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface on which the AMP activity changed.
+    ampStatus    - The new status of AMP activity.Range: {AMP_ACTIVE,
+                   AMP_INACTIVE}.
+
+*******************************************************************************/
+#define CsrWifiSmeAmpStatusChangeIndCreate(msg__, dst__, src__, interfaceTag__, ampStatus__) \
+    msg__ = (CsrWifiSmeAmpStatusChangeInd *) CsrPmemAlloc(sizeof(CsrWifiSmeAmpStatusChangeInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_AMP_STATUS_CHANGE_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->ampStatus = (ampStatus__);
+
+#define CsrWifiSmeAmpStatusChangeIndSendTo(dst__, src__, interfaceTag__, ampStatus__) \
+    { \
+        CsrWifiSmeAmpStatusChangeInd *msg__; \
+        CsrWifiSmeAmpStatusChangeIndCreate(msg__, dst__, src__, interfaceTag__, ampStatus__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeAmpStatusChangeIndSend(dst__, interfaceTag__, ampStatus__) \
+    CsrWifiSmeAmpStatusChangeIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, ampStatus__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAssociationCompleteIndSend
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive it whenever it completes an attempt to associate with an AP. If
+    the association was successful, status will be set to
+    CSR_WIFI_SME_STATUS_SUCCESS, otherwise status and deauthReason shall be
+    set to appropriate error codes.
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    status         - Reports the result of the association procedure
+    connectionInfo - This parameter is relevant only if result is
+                     CSR_WIFI_SME_STATUS_SUCCESS:
+                     it points to the connection information for the new network
+    deauthReason   - This parameter is relevant only if result is not
+                     CSR_WIFI_SME_STATUS_SUCCESS:
+                     if the AP deauthorised the station, it gives the reason of
+                     the deauthorization
+
+*******************************************************************************/
+#define CsrWifiSmeAssociationCompleteIndCreate(msg__, dst__, src__, interfaceTag__, status__, connectionInfo__, deauthReason__) \
+    msg__ = (CsrWifiSmeAssociationCompleteInd *) CsrPmemAlloc(sizeof(CsrWifiSmeAssociationCompleteInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ASSOCIATION_COMPLETE_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->connectionInfo = (connectionInfo__); \
+    msg__->deauthReason = (deauthReason__);
+
+#define CsrWifiSmeAssociationCompleteIndSendTo(dst__, src__, interfaceTag__, status__, connectionInfo__, deauthReason__) \
+    { \
+        CsrWifiSmeAssociationCompleteInd *msg__; \
+        CsrWifiSmeAssociationCompleteIndCreate(msg__, dst__, src__, interfaceTag__, status__, connectionInfo__, deauthReason__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeAssociationCompleteIndSend(dst__, interfaceTag__, status__, connectionInfo__, deauthReason__) \
+    CsrWifiSmeAssociationCompleteIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, connectionInfo__, deauthReason__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAssociationStartIndSend
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive it whenever it begins an attempt to associate with an AP.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    address      - BSSID of the associating network
+    ssid         - Service Set identifier of the associating network
+
+*******************************************************************************/
+#define CsrWifiSmeAssociationStartIndCreate(msg__, dst__, src__, interfaceTag__, address__, ssid__) \
+    msg__ = (CsrWifiSmeAssociationStartInd *) CsrPmemAlloc(sizeof(CsrWifiSmeAssociationStartInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ASSOCIATION_START_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->address = (address__); \
+    msg__->ssid = (ssid__);
+
+#define CsrWifiSmeAssociationStartIndSendTo(dst__, src__, interfaceTag__, address__, ssid__) \
+    { \
+        CsrWifiSmeAssociationStartInd *msg__; \
+        CsrWifiSmeAssociationStartIndCreate(msg__, dst__, src__, interfaceTag__, address__, ssid__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeAssociationStartIndSend(dst__, interfaceTag__, address__, ssid__) \
+    CsrWifiSmeAssociationStartIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, address__, ssid__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeBlacklistReqSend
+
+  DESCRIPTION
+    The wireless manager application should call this primitive to notify the
+    driver of any networks that should not be connected to. The interface
+    allows the wireless manager application to query, add, remove, and flush
+    the BSSIDs that the driver may not connect or roam to.
+    When this primitive adds to the black list the BSSID to which the SME is
+    currently connected, the SME will try to roam, if applicable, to another
+    BSSID in the same ESS; if the roaming procedure fails, the SME will
+    disconnect.
+
+  PARAMETERS
+    queue           - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    action          - The value of the CsrWifiSmeListAction parameter instructs
+                      the driver to modify or provide the list of blacklisted
+                      networks.
+    setAddressCount - Number of BSSIDs sent with this primitive
+    setAddresses    - Pointer to the list of BBSIDs sent with the primitive, set
+                      to NULL if none is sent.
+
+*******************************************************************************/
+#define CsrWifiSmeBlacklistReqCreate(msg__, dst__, src__, interfaceTag__, action__, setAddressCount__, setAddresses__) \
+    msg__ = (CsrWifiSmeBlacklistReq *) CsrPmemAlloc(sizeof(CsrWifiSmeBlacklistReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_BLACKLIST_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->action = (action__); \
+    msg__->setAddressCount = (setAddressCount__); \
+    msg__->setAddresses = (setAddresses__);
+
+#define CsrWifiSmeBlacklistReqSendTo(dst__, src__, interfaceTag__, action__, setAddressCount__, setAddresses__) \
+    { \
+        CsrWifiSmeBlacklistReq *msg__; \
+        CsrWifiSmeBlacklistReqCreate(msg__, dst__, src__, interfaceTag__, action__, setAddressCount__, setAddresses__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeBlacklistReqSend(src__, interfaceTag__, action__, setAddressCount__, setAddresses__) \
+    CsrWifiSmeBlacklistReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, action__, setAddressCount__, setAddresses__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeBlacklistCfmSend
+
+  DESCRIPTION
+    The SME will call this primitive when the action on the blacklist has
+    completed. For a GET action, this primitive also reports the list of
+    BBSIDs in the blacklist.
+
+  PARAMETERS
+    queue           - Destination Task Queue
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    status          - Reports the result of the request
+    action          - Action in the request
+    getAddressCount - This parameter is only relevant if action is
+                      CSR_WIFI_SME_LIST_ACTION_GET:
+                      number of BSSIDs sent with this primitive
+    getAddresses    - Pointer to the list of BBSIDs sent with the primitive, set
+                      to NULL if none is sent.
+
+*******************************************************************************/
+#define CsrWifiSmeBlacklistCfmCreate(msg__, dst__, src__, interfaceTag__, status__, action__, getAddressCount__, getAddresses__) \
+    msg__ = (CsrWifiSmeBlacklistCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeBlacklistCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_BLACKLIST_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->action = (action__); \
+    msg__->getAddressCount = (getAddressCount__); \
+    msg__->getAddresses = (getAddresses__);
+
+#define CsrWifiSmeBlacklistCfmSendTo(dst__, src__, interfaceTag__, status__, action__, getAddressCount__, getAddresses__) \
+    { \
+        CsrWifiSmeBlacklistCfm *msg__; \
+        CsrWifiSmeBlacklistCfmCreate(msg__, dst__, src__, interfaceTag__, status__, action__, getAddressCount__, getAddresses__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeBlacklistCfmSend(dst__, interfaceTag__, status__, action__, getAddressCount__, getAddresses__) \
+    CsrWifiSmeBlacklistCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, action__, getAddressCount__, getAddresses__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCalibrationDataGetReqSend
+
+  DESCRIPTION
+    This primitive retrieves the Wi-Fi radio calibration data.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeCalibrationDataGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeCalibrationDataGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCalibrationDataGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CALIBRATION_DATA_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeCalibrationDataGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeCalibrationDataGetReq *msg__; \
+        CsrWifiSmeCalibrationDataGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCalibrationDataGetReqSend(src__) \
+    CsrWifiSmeCalibrationDataGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCalibrationDataGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue                 - Destination Task Queue
+    status                - Reports the result of the request
+    calibrationDataLength - Number of bytes in the buffer pointed by
+                            calibrationData
+    calibrationData       - Pointer to a buffer of length calibrationDataLength
+                            containing the calibration data
+
+*******************************************************************************/
+#define CsrWifiSmeCalibrationDataGetCfmCreate(msg__, dst__, src__, status__, calibrationDataLength__, calibrationData__) \
+    msg__ = (CsrWifiSmeCalibrationDataGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCalibrationDataGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CALIBRATION_DATA_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->calibrationDataLength = (calibrationDataLength__); \
+    msg__->calibrationData = (calibrationData__);
+
+#define CsrWifiSmeCalibrationDataGetCfmSendTo(dst__, src__, status__, calibrationDataLength__, calibrationData__) \
+    { \
+        CsrWifiSmeCalibrationDataGetCfm *msg__; \
+        CsrWifiSmeCalibrationDataGetCfmCreate(msg__, dst__, src__, status__, calibrationDataLength__, calibrationData__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCalibrationDataGetCfmSend(dst__, status__, calibrationDataLength__, calibrationData__) \
+    CsrWifiSmeCalibrationDataGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, calibrationDataLength__, calibrationData__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCalibrationDataSetReqSend
+
+  DESCRIPTION
+    This primitive sets the Wi-Fi radio calibration data.
+    The usage of the primitive with proper calibration data will avoid
+    time-consuming configuration after power-up.
+
+  PARAMETERS
+    queue                 - Message Source Task Queue (Cfm's will be sent to this Queue)
+    calibrationDataLength - Number of bytes in the buffer pointed by
+                            calibrationData
+    calibrationData       - Pointer to a buffer of length calibrationDataLength
+                            containing the calibration data
+
+*******************************************************************************/
+#define CsrWifiSmeCalibrationDataSetReqCreate(msg__, dst__, src__, calibrationDataLength__, calibrationData__) \
+    msg__ = (CsrWifiSmeCalibrationDataSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCalibrationDataSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CALIBRATION_DATA_SET_REQ, dst__, src__); \
+    msg__->calibrationDataLength = (calibrationDataLength__); \
+    msg__->calibrationData = (calibrationData__);
+
+#define CsrWifiSmeCalibrationDataSetReqSendTo(dst__, src__, calibrationDataLength__, calibrationData__) \
+    { \
+        CsrWifiSmeCalibrationDataSetReq *msg__; \
+        CsrWifiSmeCalibrationDataSetReqCreate(msg__, dst__, src__, calibrationDataLength__, calibrationData__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCalibrationDataSetReqSend(src__, calibrationDataLength__, calibrationData__) \
+    CsrWifiSmeCalibrationDataSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, calibrationDataLength__, calibrationData__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCalibrationDataSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeCalibrationDataSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeCalibrationDataSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCalibrationDataSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CALIBRATION_DATA_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeCalibrationDataSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeCalibrationDataSetCfm *msg__; \
+        CsrWifiSmeCalibrationDataSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCalibrationDataSetCfmSend(dst__, status__) \
+    CsrWifiSmeCalibrationDataSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCcxConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the CcxConfig parameter.
+    CURRENTLY NOT SUPPORTED.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiSmeCcxConfigGetReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeCcxConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCcxConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CCX_CONFIG_GET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeCcxConfigGetReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeCcxConfigGetReq *msg__; \
+        CsrWifiSmeCcxConfigGetReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCcxConfigGetReqSend(src__, interfaceTag__) \
+    CsrWifiSmeCcxConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCcxConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+    ccxConfig    - Currently not supported
+
+*******************************************************************************/
+#define CsrWifiSmeCcxConfigGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, ccxConfig__) \
+    msg__ = (CsrWifiSmeCcxConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCcxConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CCX_CONFIG_GET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->ccxConfig = (ccxConfig__);
+
+#define CsrWifiSmeCcxConfigGetCfmSendTo(dst__, src__, interfaceTag__, status__, ccxConfig__) \
+    { \
+        CsrWifiSmeCcxConfigGetCfm *msg__; \
+        CsrWifiSmeCcxConfigGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, ccxConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCcxConfigGetCfmSend(dst__, interfaceTag__, status__, ccxConfig__) \
+    CsrWifiSmeCcxConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, ccxConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCcxConfigSetReqSend
+
+  DESCRIPTION
+    This primitive sets the value of the CcxConfig parameter.
+    CURRENTLY NOT SUPPORTED.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    ccxConfig    - Currently not supported
+
+*******************************************************************************/
+#define CsrWifiSmeCcxConfigSetReqCreate(msg__, dst__, src__, interfaceTag__, ccxConfig__) \
+    msg__ = (CsrWifiSmeCcxConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCcxConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CCX_CONFIG_SET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->ccxConfig = (ccxConfig__);
+
+#define CsrWifiSmeCcxConfigSetReqSendTo(dst__, src__, interfaceTag__, ccxConfig__) \
+    { \
+        CsrWifiSmeCcxConfigSetReq *msg__; \
+        CsrWifiSmeCcxConfigSetReqCreate(msg__, dst__, src__, interfaceTag__, ccxConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCcxConfigSetReqSend(src__, interfaceTag__, ccxConfig__) \
+    CsrWifiSmeCcxConfigSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, ccxConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCcxConfigSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeCcxConfigSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeCcxConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCcxConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CCX_CONFIG_SET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeCcxConfigSetCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeCcxConfigSetCfm *msg__; \
+        CsrWifiSmeCcxConfigSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCcxConfigSetCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeCcxConfigSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCloakedSsidsGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the CloakedSsids parameter.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeCloakedSsidsGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeCloakedSsidsGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCloakedSsidsGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CLOAKED_SSIDS_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeCloakedSsidsGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeCloakedSsidsGetReq *msg__; \
+        CsrWifiSmeCloakedSsidsGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCloakedSsidsGetReqSend(src__) \
+    CsrWifiSmeCloakedSsidsGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCloakedSsidsGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    status       - Reports the result of the request
+    cloakedSsids - Reports list of cloaked SSIDs that are explicitly scanned for
+                   by the driver
+
+*******************************************************************************/
+#define CsrWifiSmeCloakedSsidsGetCfmCreate(msg__, dst__, src__, status__, cloakedSsids__) \
+    msg__ = (CsrWifiSmeCloakedSsidsGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCloakedSsidsGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CLOAKED_SSIDS_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->cloakedSsids = (cloakedSsids__);
+
+#define CsrWifiSmeCloakedSsidsGetCfmSendTo(dst__, src__, status__, cloakedSsids__) \
+    { \
+        CsrWifiSmeCloakedSsidsGetCfm *msg__; \
+        CsrWifiSmeCloakedSsidsGetCfmCreate(msg__, dst__, src__, status__, cloakedSsids__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCloakedSsidsGetCfmSend(dst__, status__, cloakedSsids__) \
+    CsrWifiSmeCloakedSsidsGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, cloakedSsids__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCloakedSsidsSetReqSend
+
+  DESCRIPTION
+    This primitive sets the list of cloaked SSIDs for which the WMA possesses
+    profiles.
+    When the driver detects a cloaked AP, the SME will explicitly scan for it
+    using the list of cloaked SSIDs provided it, and, if the scan succeeds,
+    it will report the AP to the WMA either via CSR_WIFI_SME_SCAN_RESULT_IND
+    (if registered) or via CSR_WIFI_SCAN_RESULT_GET_CFM.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    cloakedSsids - Sets the list of cloaked SSIDs
+
+*******************************************************************************/
+#define CsrWifiSmeCloakedSsidsSetReqCreate(msg__, dst__, src__, cloakedSsids__) \
+    msg__ = (CsrWifiSmeCloakedSsidsSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCloakedSsidsSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CLOAKED_SSIDS_SET_REQ, dst__, src__); \
+    msg__->cloakedSsids = (cloakedSsids__);
+
+#define CsrWifiSmeCloakedSsidsSetReqSendTo(dst__, src__, cloakedSsids__) \
+    { \
+        CsrWifiSmeCloakedSsidsSetReq *msg__; \
+        CsrWifiSmeCloakedSsidsSetReqCreate(msg__, dst__, src__, cloakedSsids__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCloakedSsidsSetReqSend(src__, cloakedSsids__) \
+    CsrWifiSmeCloakedSsidsSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, cloakedSsids__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCloakedSsidsSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeCloakedSsidsSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeCloakedSsidsSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCloakedSsidsSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CLOAKED_SSIDS_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeCloakedSsidsSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeCloakedSsidsSetCfm *msg__; \
+        CsrWifiSmeCloakedSsidsSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCloakedSsidsSetCfmSend(dst__, status__) \
+    CsrWifiSmeCloakedSsidsSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the CoexConfig parameter.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeCoexConfigGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeCoexConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCoexConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_COEX_CONFIG_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeCoexConfigGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeCoexConfigGetReq *msg__; \
+        CsrWifiSmeCoexConfigGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCoexConfigGetReqSend(src__) \
+    CsrWifiSmeCoexConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue      - Destination Task Queue
+    status     - Reports the result of the request
+    coexConfig - Reports the parameters used to configure the coexistence
+                 behaviour
+
+*******************************************************************************/
+#define CsrWifiSmeCoexConfigGetCfmCreate(msg__, dst__, src__, status__, coexConfig__) \
+    msg__ = (CsrWifiSmeCoexConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCoexConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_COEX_CONFIG_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->coexConfig = (coexConfig__);
+
+#define CsrWifiSmeCoexConfigGetCfmSendTo(dst__, src__, status__, coexConfig__) \
+    { \
+        CsrWifiSmeCoexConfigGetCfm *msg__; \
+        CsrWifiSmeCoexConfigGetCfmCreate(msg__, dst__, src__, status__, coexConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCoexConfigGetCfmSend(dst__, status__, coexConfig__) \
+    CsrWifiSmeCoexConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, coexConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexConfigSetReqSend
+
+  DESCRIPTION
+    This primitive sets the value of the CoexConfig parameter.
+
+  PARAMETERS
+    queue      - Message Source Task Queue (Cfm's will be sent to this Queue)
+    coexConfig - Configures the coexistence behaviour
+
+*******************************************************************************/
+#define CsrWifiSmeCoexConfigSetReqCreate(msg__, dst__, src__, coexConfig__) \
+    msg__ = (CsrWifiSmeCoexConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCoexConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_COEX_CONFIG_SET_REQ, dst__, src__); \
+    msg__->coexConfig = (coexConfig__);
+
+#define CsrWifiSmeCoexConfigSetReqSendTo(dst__, src__, coexConfig__) \
+    { \
+        CsrWifiSmeCoexConfigSetReq *msg__; \
+        CsrWifiSmeCoexConfigSetReqCreate(msg__, dst__, src__, coexConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCoexConfigSetReqSend(src__, coexConfig__) \
+    CsrWifiSmeCoexConfigSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, coexConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexConfigSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeCoexConfigSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeCoexConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCoexConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_COEX_CONFIG_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeCoexConfigSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeCoexConfigSetCfm *msg__; \
+        CsrWifiSmeCoexConfigSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCoexConfigSetCfmSend(dst__, status__) \
+    CsrWifiSmeCoexConfigSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexInfoGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the CoexInfo parameter.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeCoexInfoGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeCoexInfoGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCoexInfoGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_COEX_INFO_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeCoexInfoGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeCoexInfoGetReq *msg__; \
+        CsrWifiSmeCoexInfoGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCoexInfoGetReqSend(src__) \
+    CsrWifiSmeCoexInfoGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexInfoGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue    - Destination Task Queue
+    status   - Reports the result of the request
+    coexInfo - Reports information and state related to coexistence.
+
+*******************************************************************************/
+#define CsrWifiSmeCoexInfoGetCfmCreate(msg__, dst__, src__, status__, coexInfo__) \
+    msg__ = (CsrWifiSmeCoexInfoGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCoexInfoGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_COEX_INFO_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->coexInfo = (coexInfo__);
+
+#define CsrWifiSmeCoexInfoGetCfmSendTo(dst__, src__, status__, coexInfo__) \
+    { \
+        CsrWifiSmeCoexInfoGetCfm *msg__; \
+        CsrWifiSmeCoexInfoGetCfmCreate(msg__, dst__, src__, status__, coexInfo__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCoexInfoGetCfmSend(dst__, status__, coexInfo__) \
+    CsrWifiSmeCoexInfoGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, coexInfo__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectReqSend
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to start the
+    process of joining an 802.11 wireless network or to start an ad hoc
+    network.
+    The structure pointed by connectionConfig contains parameters describing
+    the network to join or, in case of an ad hoc network, to host or join.
+    The SME will select a network, perform the IEEE 802.11 Join, Authenticate
+    and Associate exchanges.
+    The SME selects the networks from the current scan list that match both
+    the SSID and BSSID, however either or both of these may be the wildcard
+    value. Using this rule, the following operations are possible:
+      * To connect to a network by name, specify the SSID and set the BSSID to
+        0xFF 0xFF 0xFF 0xFF 0xFF 0xFF. If there are two or more networks visible,
+        the SME will select the one with the strongest signal.
+      * To connect to a specific network, specify the BSSID. The SSID is
+        optional, but if given it must match the SSID of the network. An empty
+        SSID may be specified by setting the SSID length to zero. Please note
+        that if the BSSID is specified (i.e. not equal to 0xFF 0xFF 0xFF 0xFF
+        0xFF 0xFF), the SME will not attempt to roam if signal conditions become
+        poor, even if there is an alternative AP with an SSID that matches the
+        current network SSID.
+      * To connect to any network matching the other parameters (i.e. security,
+        etc), set the SSID length to zero and set the BSSID to 0xFF 0xFF 0xFF
+        0xFF 0xFF 0xFF. In this case, the SME will order all available networks
+        by their signal strengths and will iterate through this list until it
+        successfully connects.
+    NOTE: Specifying the BSSID will restrict the selection to one specific
+    network. If SSID and BSSID are given, they must both match the network
+    for it to be selected. To select a network based on the SSID only, the
+    wireless manager application must set the BSSID to 0xFF 0xFF 0xFF 0xFF
+    0xFF 0xFF.
+    The SME will try to connect to each network that matches the provided
+    parameters, one by one, until it succeeds or has tried unsuccessfully
+    with all the matching networks.
+    If there is no network that matches the parameters and the request allows
+    to host an ad hoc network, the SME will advertise a new ad hoc network
+    instead.
+    If the SME cannot connect, it will notify the failure in the confirm.
+
+  PARAMETERS
+    queue            - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag     - Interface Identifier; unique identifier of an interface
+    connectionConfig - Describes the candidate network to join or to host.
+
+*******************************************************************************/
+#define CsrWifiSmeConnectReqCreate(msg__, dst__, src__, interfaceTag__, connectionConfig__) \
+    msg__ = (CsrWifiSmeConnectReq *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CONNECT_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->connectionConfig = (connectionConfig__);
+
+#define CsrWifiSmeConnectReqSendTo(dst__, src__, interfaceTag__, connectionConfig__) \
+    { \
+        CsrWifiSmeConnectReq *msg__; \
+        CsrWifiSmeConnectReqCreate(msg__, dst__, src__, interfaceTag__, connectionConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeConnectReqSend(src__, interfaceTag__, connectionConfig__) \
+    CsrWifiSmeConnectReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, connectionConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectCfmSend
+
+  DESCRIPTION
+    The SME calls this primitive when the connection exchange is complete or
+    all connection attempts fail.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request.
+                   CSR_WIFI_SME_STATUS_NOT_FOUND: all attempts by the SME to
+                   locate the requested AP failed
+
+*******************************************************************************/
+#define CsrWifiSmeConnectCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeConnectCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CONNECT_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeConnectCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeConnectCfm *msg__; \
+        CsrWifiSmeConnectCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeConnectCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeConnectCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the ConnectionConfig parameter.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiSmeConnectionConfigGetReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeConnectionConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CONNECTION_CONFIG_GET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeConnectionConfigGetReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeConnectionConfigGetReq *msg__; \
+        CsrWifiSmeConnectionConfigGetReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeConnectionConfigGetReqSend(src__, interfaceTag__) \
+    CsrWifiSmeConnectionConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue            - Destination Task Queue
+    interfaceTag     - Interface Identifier; unique identifier of an interface
+    status           - Reports the result of the request
+    connectionConfig - Parameters used by the SME for selecting a network
+
+*******************************************************************************/
+#define CsrWifiSmeConnectionConfigGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, connectionConfig__) \
+    msg__ = (CsrWifiSmeConnectionConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CONNECTION_CONFIG_GET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->connectionConfig = (connectionConfig__);
+
+#define CsrWifiSmeConnectionConfigGetCfmSendTo(dst__, src__, interfaceTag__, status__, connectionConfig__) \
+    { \
+        CsrWifiSmeConnectionConfigGetCfm *msg__; \
+        CsrWifiSmeConnectionConfigGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, connectionConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeConnectionConfigGetCfmSend(dst__, interfaceTag__, status__, connectionConfig__) \
+    CsrWifiSmeConnectionConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, connectionConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionInfoGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the ConnectionInfo parameter.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiSmeConnectionInfoGetReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeConnectionInfoGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionInfoGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CONNECTION_INFO_GET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeConnectionInfoGetReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeConnectionInfoGetReq *msg__; \
+        CsrWifiSmeConnectionInfoGetReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeConnectionInfoGetReqSend(src__, interfaceTag__) \
+    CsrWifiSmeConnectionInfoGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionInfoGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    status         - Reports the result of the request
+    connectionInfo - Information about the current connection
+
+*******************************************************************************/
+#define CsrWifiSmeConnectionInfoGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, connectionInfo__) \
+    msg__ = (CsrWifiSmeConnectionInfoGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionInfoGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CONNECTION_INFO_GET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->connectionInfo = (connectionInfo__);
+
+#define CsrWifiSmeConnectionInfoGetCfmSendTo(dst__, src__, interfaceTag__, status__, connectionInfo__) \
+    { \
+        CsrWifiSmeConnectionInfoGetCfm *msg__; \
+        CsrWifiSmeConnectionInfoGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, connectionInfo__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeConnectionInfoGetCfmSend(dst__, interfaceTag__, status__, connectionInfo__) \
+    CsrWifiSmeConnectionInfoGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, connectionInfo__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionQualityIndSend
+
+  DESCRIPTION
+    The SME sends this primitive to all the tasks that have registered to
+    receive it whenever the value of the current connection quality
+    parameters change by more than a certain configurable amount.
+    The wireless manager application may configure the trigger thresholds for
+    this indication using the field in smeConfig parameter of
+    CSR_WIFI_SME_SME_CONFIG_SET_REQ.
+    Connection quality messages can be suppressed by setting both thresholds
+    to zero.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    linkQuality  - Indicates the quality of the link
+
+*******************************************************************************/
+#define CsrWifiSmeConnectionQualityIndCreate(msg__, dst__, src__, interfaceTag__, linkQuality__) \
+    msg__ = (CsrWifiSmeConnectionQualityInd *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionQualityInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CONNECTION_QUALITY_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->linkQuality = (linkQuality__);
+
+#define CsrWifiSmeConnectionQualityIndSendTo(dst__, src__, interfaceTag__, linkQuality__) \
+    { \
+        CsrWifiSmeConnectionQualityInd *msg__; \
+        CsrWifiSmeConnectionQualityIndCreate(msg__, dst__, src__, interfaceTag__, linkQuality__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeConnectionQualityIndSend(dst__, interfaceTag__, linkQuality__) \
+    CsrWifiSmeConnectionQualityIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, linkQuality__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionStatsGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the ConnectionStats parameter.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiSmeConnectionStatsGetReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeConnectionStatsGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionStatsGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CONNECTION_STATS_GET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeConnectionStatsGetReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeConnectionStatsGetReq *msg__; \
+        CsrWifiSmeConnectionStatsGetReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeConnectionStatsGetReqSend(src__, interfaceTag__) \
+    CsrWifiSmeConnectionStatsGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionStatsGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue           - Destination Task Queue
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    status          - Reports the result of the request
+    connectionStats - Statistics for current connection.
+
+*******************************************************************************/
+#define CsrWifiSmeConnectionStatsGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, connectionStats__) \
+    msg__ = (CsrWifiSmeConnectionStatsGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionStatsGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CONNECTION_STATS_GET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->connectionStats = (connectionStats__);
+
+#define CsrWifiSmeConnectionStatsGetCfmSendTo(dst__, src__, interfaceTag__, status__, connectionStats__) \
+    { \
+        CsrWifiSmeConnectionStatsGetCfm *msg__; \
+        CsrWifiSmeConnectionStatsGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, connectionStats__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeConnectionStatsGetCfmSend(dst__, interfaceTag__, status__, connectionStats__) \
+    CsrWifiSmeConnectionStatsGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, connectionStats__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoreDumpIndSend
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive Wi-Fi Chip core dump data.
+    The core dump data may be fragmented and sent using more than one
+    indication.
+    To indicate that all the data has been sent, the last indication contains
+    a 'length' of 0 and 'data' of NULL.
+
+  PARAMETERS
+    queue      - Destination Task Queue
+    dataLength - Number of bytes in the buffer pointed to by 'data'
+    data       - Pointer to the buffer containing 'dataLength' bytes of core
+                 dump data
+
+*******************************************************************************/
+#define CsrWifiSmeCoreDumpIndCreate(msg__, dst__, src__, dataLength__, data__) \
+    msg__ = (CsrWifiSmeCoreDumpInd *) CsrPmemAlloc(sizeof(CsrWifiSmeCoreDumpInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_CORE_DUMP_IND, dst__, src__); \
+    msg__->dataLength = (dataLength__); \
+    msg__->data = (data__);
+
+#define CsrWifiSmeCoreDumpIndSendTo(dst__, src__, dataLength__, data__) \
+    { \
+        CsrWifiSmeCoreDumpInd *msg__; \
+        CsrWifiSmeCoreDumpIndCreate(msg__, dst__, src__, dataLength__, data__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeCoreDumpIndSend(dst__, dataLength__, data__) \
+    CsrWifiSmeCoreDumpIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, dataLength__, data__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDeactivateReqSend
+
+  DESCRIPTION
+    The WMA sends this primitive to deactivate the SME.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeDeactivateReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeDeactivateReq *) CsrPmemAlloc(sizeof(CsrWifiSmeDeactivateReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_DEACTIVATE_REQ, dst__, src__);
+
+#define CsrWifiSmeDeactivateReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeDeactivateReq *msg__; \
+        CsrWifiSmeDeactivateReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeDeactivateReqSend(src__) \
+    CsrWifiSmeDeactivateReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDeactivateCfmSend
+
+  DESCRIPTION
+    The SME sends this primitive when the deactivation is complete.
+    The WMA cannot send any more primitives until it actives the SME again
+    sending another CSR_WIFI_SME_ACTIVATE_REQ.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeDeactivateCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeDeactivateCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeDeactivateCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_DEACTIVATE_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeDeactivateCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeDeactivateCfm *msg__; \
+        CsrWifiSmeDeactivateCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeDeactivateCfmSend(dst__, status__) \
+    CsrWifiSmeDeactivateCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDisconnectReqSend
+
+  DESCRIPTION
+    The wireless manager application may disconnect from the current network
+    by calling this primitive
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiSmeDisconnectReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeDisconnectReq *) CsrPmemAlloc(sizeof(CsrWifiSmeDisconnectReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_DISCONNECT_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeDisconnectReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeDisconnectReq *msg__; \
+        CsrWifiSmeDisconnectReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeDisconnectReqSend(src__, interfaceTag__) \
+    CsrWifiSmeDisconnectReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDisconnectCfmSend
+
+  DESCRIPTION
+    On reception of CSR_WIFI_SME_DISCONNECT_REQ the SME will perform a
+    disconnect operation, sending a CsrWifiSmeMediaStatusInd with
+    CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED and then call this primitive when
+    disconnection is complete.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeDisconnectCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeDisconnectCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeDisconnectCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_DISCONNECT_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeDisconnectCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeDisconnectCfm *msg__; \
+        CsrWifiSmeDisconnectCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeDisconnectCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeDisconnectCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeErrorIndSend
+
+  DESCRIPTION
+    Important error message indicating a error of some importance
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    errorMessage - Contains the error message.
+
+*******************************************************************************/
+#define CsrWifiSmeErrorIndCreate(msg__, dst__, src__, errorMessage__) \
+    msg__ = (CsrWifiSmeErrorInd *) CsrPmemAlloc(sizeof(CsrWifiSmeErrorInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ERROR_IND, dst__, src__); \
+    msg__->errorMessage = (errorMessage__);
+
+#define CsrWifiSmeErrorIndSendTo(dst__, src__, errorMessage__) \
+    { \
+        CsrWifiSmeErrorInd *msg__; \
+        CsrWifiSmeErrorIndCreate(msg__, dst__, src__, errorMessage__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeErrorIndSend(dst__, errorMessage__) \
+    CsrWifiSmeErrorIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, errorMessage__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeEventMaskSetReqSend
+
+  DESCRIPTION
+    The wireless manager application may register with the SME to receive
+    notification of interesting events. Indications will be sent only if the
+    wireless manager explicitly registers to be notified of that event.
+    indMask is a bit mask of values defined in CsrWifiSmeIndicationsMask.
+
+  PARAMETERS
+    queue   - Message Source Task Queue (Cfm's will be sent to this Queue)
+    indMask - Set mask with values from CsrWifiSmeIndications
+
+*******************************************************************************/
+#define CsrWifiSmeEventMaskSetReqCreate(msg__, dst__, src__, indMask__) \
+    msg__ = (CsrWifiSmeEventMaskSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeEventMaskSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_EVENT_MASK_SET_REQ, dst__, src__); \
+    msg__->indMask = (indMask__);
+
+#define CsrWifiSmeEventMaskSetReqSendTo(dst__, src__, indMask__) \
+    { \
+        CsrWifiSmeEventMaskSetReq *msg__; \
+        CsrWifiSmeEventMaskSetReqCreate(msg__, dst__, src__, indMask__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeEventMaskSetReqSend(src__, indMask__) \
+    CsrWifiSmeEventMaskSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, indMask__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeEventMaskSetCfmSend
+
+  DESCRIPTION
+    The SME calls the primitive to report the result of the request
+    primitive.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeEventMaskSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeEventMaskSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeEventMaskSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_EVENT_MASK_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeEventMaskSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeEventMaskSetCfm *msg__; \
+        CsrWifiSmeEventMaskSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeEventMaskSetCfmSend(dst__, status__) \
+    CsrWifiSmeEventMaskSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeHostConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the hostConfig parameter.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiSmeHostConfigGetReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeHostConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeHostConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_HOST_CONFIG_GET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeHostConfigGetReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeHostConfigGetReq *msg__; \
+        CsrWifiSmeHostConfigGetReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeHostConfigGetReqSend(src__, interfaceTag__) \
+    CsrWifiSmeHostConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeHostConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+    hostConfig   - Current host power state.
+
+*******************************************************************************/
+#define CsrWifiSmeHostConfigGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, hostConfig__) \
+    msg__ = (CsrWifiSmeHostConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeHostConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_HOST_CONFIG_GET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->hostConfig = (hostConfig__);
+
+#define CsrWifiSmeHostConfigGetCfmSendTo(dst__, src__, interfaceTag__, status__, hostConfig__) \
+    { \
+        CsrWifiSmeHostConfigGetCfm *msg__; \
+        CsrWifiSmeHostConfigGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, hostConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeHostConfigGetCfmSend(dst__, interfaceTag__, status__, hostConfig__) \
+    CsrWifiSmeHostConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, hostConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeHostConfigSetReqSend
+
+  DESCRIPTION
+    This primitive sets the value of the hostConfig parameter.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    hostConfig   - Communicates a change of host power state (for example, on
+                   mains power, on battery power etc) and of the periodicity of
+                   traffic data
+
+*******************************************************************************/
+#define CsrWifiSmeHostConfigSetReqCreate(msg__, dst__, src__, interfaceTag__, hostConfig__) \
+    msg__ = (CsrWifiSmeHostConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeHostConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_HOST_CONFIG_SET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->hostConfig = (hostConfig__);
+
+#define CsrWifiSmeHostConfigSetReqSendTo(dst__, src__, interfaceTag__, hostConfig__) \
+    { \
+        CsrWifiSmeHostConfigSetReq *msg__; \
+        CsrWifiSmeHostConfigSetReqCreate(msg__, dst__, src__, interfaceTag__, hostConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeHostConfigSetReqSend(src__, interfaceTag__, hostConfig__) \
+    CsrWifiSmeHostConfigSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, hostConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeHostConfigSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeHostConfigSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeHostConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeHostConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_HOST_CONFIG_SET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeHostConfigSetCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeHostConfigSetCfm *msg__; \
+        CsrWifiSmeHostConfigSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeHostConfigSetCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeHostConfigSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeIbssStationIndSend
+
+  DESCRIPTION
+    The SME will send this primitive to indicate that a station has joined or
+    left the ad-hoc network.
+
+  PARAMETERS
+    queue       - Destination Task Queue
+    address     - MAC address of the station that has joined or left
+    isconnected - TRUE if the station joined, FALSE if the station left
+
+*******************************************************************************/
+#define CsrWifiSmeIbssStationIndCreate(msg__, dst__, src__, address__, isconnected__) \
+    msg__ = (CsrWifiSmeIbssStationInd *) CsrPmemAlloc(sizeof(CsrWifiSmeIbssStationInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_IBSS_STATION_IND, dst__, src__); \
+    msg__->address = (address__); \
+    msg__->isconnected = (isconnected__);
+
+#define CsrWifiSmeIbssStationIndSendTo(dst__, src__, address__, isconnected__) \
+    { \
+        CsrWifiSmeIbssStationInd *msg__; \
+        CsrWifiSmeIbssStationIndCreate(msg__, dst__, src__, address__, isconnected__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeIbssStationIndSend(dst__, address__, isconnected__) \
+    CsrWifiSmeIbssStationIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, address__, isconnected__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeInfoIndSend
+
+  DESCRIPTION
+    Message indicating a some info about current activity. Mostly of interest
+    in testing but may be useful in the field.
+
+  PARAMETERS
+    queue       - Destination Task Queue
+    infoMessage - Contains the message.
+
+*******************************************************************************/
+#define CsrWifiSmeInfoIndCreate(msg__, dst__, src__, infoMessage__) \
+    msg__ = (CsrWifiSmeInfoInd *) CsrPmemAlloc(sizeof(CsrWifiSmeInfoInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_INFO_IND, dst__, src__); \
+    msg__->infoMessage = (infoMessage__);
+
+#define CsrWifiSmeInfoIndSendTo(dst__, src__, infoMessage__) \
+    { \
+        CsrWifiSmeInfoInd *msg__; \
+        CsrWifiSmeInfoIndCreate(msg__, dst__, src__, infoMessage__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeInfoIndSend(dst__, infoMessage__) \
+    CsrWifiSmeInfoIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, infoMessage__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeInterfaceCapabilityGetReqSend
+
+  DESCRIPTION
+    The Wireless Manager calls this primitive to ask the SME for the
+    capabilities of the supported interfaces
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeInterfaceCapabilityGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeInterfaceCapabilityGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeInterfaceCapabilityGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_INTERFACE_CAPABILITY_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeInterfaceCapabilityGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeInterfaceCapabilityGetReq *msg__; \
+        CsrWifiSmeInterfaceCapabilityGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeInterfaceCapabilityGetReqSend(src__) \
+    CsrWifiSmeInterfaceCapabilityGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeInterfaceCapabilityGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue         - Destination Task Queue
+    status        - Result of the request
+    numInterfaces - Number of the interfaces supported
+    capBitmap     - Points to the list of capabilities bitmaps provided for each
+                    interface.
+                    The bits represent the following capabilities:
+                    -bits 7 to 4-Reserved
+                    -bit 3-AMP
+                    -bit 2-P2P
+                    -bit 1-AP
+                    -bit 0-STA
+
+*******************************************************************************/
+#define CsrWifiSmeInterfaceCapabilityGetCfmCreate(msg__, dst__, src__, status__, numInterfaces__, capBitmap__) \
+    msg__ = (CsrWifiSmeInterfaceCapabilityGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeInterfaceCapabilityGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_INTERFACE_CAPABILITY_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->numInterfaces = (numInterfaces__); \
+    CsrMemCpy(msg__->capBitmap, (capBitmap__), sizeof(CsrUint8) * 2);
+
+#define CsrWifiSmeInterfaceCapabilityGetCfmSendTo(dst__, src__, status__, numInterfaces__, capBitmap__) \
+    { \
+        CsrWifiSmeInterfaceCapabilityGetCfm *msg__; \
+        CsrWifiSmeInterfaceCapabilityGetCfmCreate(msg__, dst__, src__, status__, numInterfaces__, capBitmap__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeInterfaceCapabilityGetCfmSend(dst__, status__, numInterfaces__, capBitmap__) \
+    CsrWifiSmeInterfaceCapabilityGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, numInterfaces__, capBitmap__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeKeyReqSend
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to add or remove
+    keys that the chip should use for encryption of data.
+    The interface allows the wireless manager application to add and remove
+    keys according to the specified action.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    action       - The value of the CsrWifiSmeListAction parameter instructs the
+                   driver to modify or provide the list of keys.
+                   CSR_WIFI_SME_LIST_ACTION_GET is not supported here.
+    key          - Key to be added or removed
+
+*******************************************************************************/
+#define CsrWifiSmeKeyReqCreate(msg__, dst__, src__, interfaceTag__, action__, key__) \
+    msg__ = (CsrWifiSmeKeyReq *) CsrPmemAlloc(sizeof(CsrWifiSmeKeyReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_KEY_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->action = (action__); \
+    msg__->key = (key__);
+
+#define CsrWifiSmeKeyReqSendTo(dst__, src__, interfaceTag__, action__, key__) \
+    { \
+        CsrWifiSmeKeyReq *msg__; \
+        CsrWifiSmeKeyReqCreate(msg__, dst__, src__, interfaceTag__, action__, key__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeKeyReqSend(src__, interfaceTag__, action__, key__) \
+    CsrWifiSmeKeyReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, action__, key__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeKeyCfmSend
+
+  DESCRIPTION
+    The SME calls the primitive to report the result of the request
+    primitive.
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    status         - Reports the result of the request
+    action         - Action in the request
+    keyType        - Type of the key added/deleted
+    peerMacAddress - Peer MAC Address of the key added/deleted
+
+*******************************************************************************/
+#define CsrWifiSmeKeyCfmCreate(msg__, dst__, src__, interfaceTag__, status__, action__, keyType__, peerMacAddress__) \
+    msg__ = (CsrWifiSmeKeyCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeKeyCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_KEY_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->action = (action__); \
+    msg__->keyType = (keyType__); \
+    msg__->peerMacAddress = (peerMacAddress__);
+
+#define CsrWifiSmeKeyCfmSendTo(dst__, src__, interfaceTag__, status__, action__, keyType__, peerMacAddress__) \
+    { \
+        CsrWifiSmeKeyCfm *msg__; \
+        CsrWifiSmeKeyCfmCreate(msg__, dst__, src__, interfaceTag__, status__, action__, keyType__, peerMacAddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeKeyCfmSend(dst__, interfaceTag__, status__, action__, keyType__, peerMacAddress__) \
+    CsrWifiSmeKeyCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, action__, keyType__, peerMacAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeLinkQualityGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the LinkQuality parameter.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiSmeLinkQualityGetReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeLinkQualityGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeLinkQualityGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_LINK_QUALITY_GET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeLinkQualityGetReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeLinkQualityGetReq *msg__; \
+        CsrWifiSmeLinkQualityGetReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeLinkQualityGetReqSend(src__, interfaceTag__) \
+    CsrWifiSmeLinkQualityGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeLinkQualityGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+    linkQuality  - Indicates the quality of the link
+
+*******************************************************************************/
+#define CsrWifiSmeLinkQualityGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, linkQuality__) \
+    msg__ = (CsrWifiSmeLinkQualityGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeLinkQualityGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_LINK_QUALITY_GET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->linkQuality = (linkQuality__);
+
+#define CsrWifiSmeLinkQualityGetCfmSendTo(dst__, src__, interfaceTag__, status__, linkQuality__) \
+    { \
+        CsrWifiSmeLinkQualityGetCfm *msg__; \
+        CsrWifiSmeLinkQualityGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, linkQuality__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeLinkQualityGetCfmSend(dst__, interfaceTag__, status__, linkQuality__) \
+    CsrWifiSmeLinkQualityGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, linkQuality__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMediaStatusIndSend
+
+  DESCRIPTION
+    The SME sends this primitive to all the tasks that have registered to
+    receive it when a network connection is established, lost or has moved to
+    another AP.
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    mediaStatus    - Indicates the media status
+    connectionInfo - This parameter is relevant only if the mediaStatus is
+                     CSR_WIFI_SME_MEDIA_STATUS_CONNECTED:
+                     it points to the connection information for the new network
+    disassocReason - This parameter is relevant only if the mediaStatus is
+                     CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED:
+                     if a disassociation has occurred it gives the reason of the
+                     disassociation
+    deauthReason   - This parameter is relevant only if the mediaStatus is
+                     CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED:
+                     if a deauthentication has occurred it gives the reason of
+                     the deauthentication
+
+*******************************************************************************/
+#define CsrWifiSmeMediaStatusIndCreate(msg__, dst__, src__, interfaceTag__, mediaStatus__, connectionInfo__, disassocReason__, deauthReason__) \
+    msg__ = (CsrWifiSmeMediaStatusInd *) CsrPmemAlloc(sizeof(CsrWifiSmeMediaStatusInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MEDIA_STATUS_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->mediaStatus = (mediaStatus__); \
+    msg__->connectionInfo = (connectionInfo__); \
+    msg__->disassocReason = (disassocReason__); \
+    msg__->deauthReason = (deauthReason__);
+
+#define CsrWifiSmeMediaStatusIndSendTo(dst__, src__, interfaceTag__, mediaStatus__, connectionInfo__, disassocReason__, deauthReason__) \
+    { \
+        CsrWifiSmeMediaStatusInd *msg__; \
+        CsrWifiSmeMediaStatusIndCreate(msg__, dst__, src__, interfaceTag__, mediaStatus__, connectionInfo__, disassocReason__, deauthReason__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMediaStatusIndSend(dst__, interfaceTag__, mediaStatus__, connectionInfo__, disassocReason__, deauthReason__) \
+    CsrWifiSmeMediaStatusIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, mediaStatus__, connectionInfo__, disassocReason__, deauthReason__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the MibConfig parameter.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeMibConfigGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeMibConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMibConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIB_CONFIG_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeMibConfigGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeMibConfigGetReq *msg__; \
+        CsrWifiSmeMibConfigGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMibConfigGetReqSend(src__) \
+    CsrWifiSmeMibConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue     - Destination Task Queue
+    status    - Reports the result of the request
+    mibConfig - Reports various IEEE 802.11 attributes as currently configured
+
+*******************************************************************************/
+#define CsrWifiSmeMibConfigGetCfmCreate(msg__, dst__, src__, status__, mibConfig__) \
+    msg__ = (CsrWifiSmeMibConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeMibConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIB_CONFIG_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->mibConfig = (mibConfig__);
+
+#define CsrWifiSmeMibConfigGetCfmSendTo(dst__, src__, status__, mibConfig__) \
+    { \
+        CsrWifiSmeMibConfigGetCfm *msg__; \
+        CsrWifiSmeMibConfigGetCfmCreate(msg__, dst__, src__, status__, mibConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMibConfigGetCfmSend(dst__, status__, mibConfig__) \
+    CsrWifiSmeMibConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, mibConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibConfigSetReqSend
+
+  DESCRIPTION
+    This primitive sets the value of the MibConfig parameter.
+
+  PARAMETERS
+    queue     - Message Source Task Queue (Cfm's will be sent to this Queue)
+    mibConfig - Conveys the desired value of various IEEE 802.11 attributes as
+                currently configured
+
+*******************************************************************************/
+#define CsrWifiSmeMibConfigSetReqCreate(msg__, dst__, src__, mibConfig__) \
+    msg__ = (CsrWifiSmeMibConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMibConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIB_CONFIG_SET_REQ, dst__, src__); \
+    msg__->mibConfig = (mibConfig__);
+
+#define CsrWifiSmeMibConfigSetReqSendTo(dst__, src__, mibConfig__) \
+    { \
+        CsrWifiSmeMibConfigSetReq *msg__; \
+        CsrWifiSmeMibConfigSetReqCreate(msg__, dst__, src__, mibConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMibConfigSetReqSend(src__, mibConfig__) \
+    CsrWifiSmeMibConfigSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, mibConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibConfigSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeMibConfigSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeMibConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeMibConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIB_CONFIG_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeMibConfigSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeMibConfigSetCfm *msg__; \
+        CsrWifiSmeMibConfigSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMibConfigSetCfmSend(dst__, status__) \
+    CsrWifiSmeMibConfigSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibGetCfmSend
+
+  DESCRIPTION
+    The SME calls this primitive to return the requested MIB variable values.
+
+  PARAMETERS
+    queue              - Destination Task Queue
+    status             - Reports the result of the request
+    mibAttributeLength - Length of mibAttribute
+    mibAttribute       - Points to the VarBind or VarBindList containing the
+                         names and values of the MIB variables requested
+
+*******************************************************************************/
+#define CsrWifiSmeMibGetCfmCreate(msg__, dst__, src__, status__, mibAttributeLength__, mibAttribute__) \
+    msg__ = (CsrWifiSmeMibGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeMibGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIB_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->mibAttributeLength = (mibAttributeLength__); \
+    msg__->mibAttribute = (mibAttribute__);
+
+#define CsrWifiSmeMibGetCfmSendTo(dst__, src__, status__, mibAttributeLength__, mibAttribute__) \
+    { \
+        CsrWifiSmeMibGetCfm *msg__; \
+        CsrWifiSmeMibGetCfmCreate(msg__, dst__, src__, status__, mibAttributeLength__, mibAttribute__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMibGetCfmSend(dst__, status__, mibAttributeLength__, mibAttribute__) \
+    CsrWifiSmeMibGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, mibAttributeLength__, mibAttribute__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibGetNextReqSend
+
+  DESCRIPTION
+    To read a sequence of MIB parameters, for example a table, call this
+    primitive to find the name of the next MIB variable
+
+  PARAMETERS
+    queue              - Message Source Task Queue (Cfm's will be sent to this Queue)
+    mibAttributeLength - Length of mibAttribute
+    mibAttribute       - Points to a VarBind or VarBindList containing the
+                         name(s) of the MIB variable(s) to search from.
+
+*******************************************************************************/
+#define CsrWifiSmeMibGetNextReqCreate(msg__, dst__, src__, mibAttributeLength__, mibAttribute__) \
+    msg__ = (CsrWifiSmeMibGetNextReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMibGetNextReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIB_GET_NEXT_REQ, dst__, src__); \
+    msg__->mibAttributeLength = (mibAttributeLength__); \
+    msg__->mibAttribute = (mibAttribute__);
+
+#define CsrWifiSmeMibGetNextReqSendTo(dst__, src__, mibAttributeLength__, mibAttribute__) \
+    { \
+        CsrWifiSmeMibGetNextReq *msg__; \
+        CsrWifiSmeMibGetNextReqCreate(msg__, dst__, src__, mibAttributeLength__, mibAttribute__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMibGetNextReqSend(src__, mibAttributeLength__, mibAttribute__) \
+    CsrWifiSmeMibGetNextReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, mibAttributeLength__, mibAttribute__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibGetNextCfmSend
+
+  DESCRIPTION
+    The SME calls this primitive to return the requested MIB name(s).
+    The wireless manager application can then read the value of the MIB
+    variable using CSR_WIFI_SME_MIB_GET_REQ, using the names provided.
+
+  PARAMETERS
+    queue              - Destination Task Queue
+    status             - Reports the result of the request
+    mibAttributeLength - Length of mibAttribute
+    mibAttribute       - Points to a VarBind or VarBindList containing the
+                         name(s) of the MIB variable(s) lexicographically
+                         following the name(s) given in the request
+
+*******************************************************************************/
+#define CsrWifiSmeMibGetNextCfmCreate(msg__, dst__, src__, status__, mibAttributeLength__, mibAttribute__) \
+    msg__ = (CsrWifiSmeMibGetNextCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeMibGetNextCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIB_GET_NEXT_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->mibAttributeLength = (mibAttributeLength__); \
+    msg__->mibAttribute = (mibAttribute__);
+
+#define CsrWifiSmeMibGetNextCfmSendTo(dst__, src__, status__, mibAttributeLength__, mibAttribute__) \
+    { \
+        CsrWifiSmeMibGetNextCfm *msg__; \
+        CsrWifiSmeMibGetNextCfmCreate(msg__, dst__, src__, status__, mibAttributeLength__, mibAttribute__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMibGetNextCfmSend(dst__, status__, mibAttributeLength__, mibAttribute__) \
+    CsrWifiSmeMibGetNextCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, mibAttributeLength__, mibAttribute__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibGetReqSend
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to retrieve one or
+    more MIB variables.
+
+  PARAMETERS
+    queue              - Message Source Task Queue (Cfm's will be sent to this Queue)
+    mibAttributeLength - Length of mibAttribute
+    mibAttribute       - Points to the VarBind or VarBindList containing the
+                         names of the MIB variables to be retrieved
+
+*******************************************************************************/
+#define CsrWifiSmeMibGetReqCreate(msg__, dst__, src__, mibAttributeLength__, mibAttribute__) \
+    msg__ = (CsrWifiSmeMibGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMibGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIB_GET_REQ, dst__, src__); \
+    msg__->mibAttributeLength = (mibAttributeLength__); \
+    msg__->mibAttribute = (mibAttribute__);
+
+#define CsrWifiSmeMibGetReqSendTo(dst__, src__, mibAttributeLength__, mibAttribute__) \
+    { \
+        CsrWifiSmeMibGetReq *msg__; \
+        CsrWifiSmeMibGetReqCreate(msg__, dst__, src__, mibAttributeLength__, mibAttribute__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMibGetReqSend(src__, mibAttributeLength__, mibAttribute__) \
+    CsrWifiSmeMibGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, mibAttributeLength__, mibAttribute__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibSetReqSend
+
+  DESCRIPTION
+    The SME provides raw access to the MIB on the chip, which may be used by
+    some configuration or diagnostic utilities, but is not normally needed by
+    the wireless manager application.
+    The MIB access functions use BER encoded names (OID) of the MIB
+    parameters and BER encoded values, as described in the chip Host
+    Interface Protocol Specification.
+    The MIB parameters are described in 'Wi-Fi 5.0.0 Management Information
+    Base Reference Guide'.
+    The wireless manager application calls this primitive to set one or more
+    MIB variables
+
+  PARAMETERS
+    queue              - Message Source Task Queue (Cfm's will be sent to this Queue)
+    mibAttributeLength - Length of mibAttribute
+    mibAttribute       - Points to the VarBind or VarBindList containing the
+                         names and values of the MIB variables to set
+
+*******************************************************************************/
+#define CsrWifiSmeMibSetReqCreate(msg__, dst__, src__, mibAttributeLength__, mibAttribute__) \
+    msg__ = (CsrWifiSmeMibSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMibSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIB_SET_REQ, dst__, src__); \
+    msg__->mibAttributeLength = (mibAttributeLength__); \
+    msg__->mibAttribute = (mibAttribute__);
+
+#define CsrWifiSmeMibSetReqSendTo(dst__, src__, mibAttributeLength__, mibAttribute__) \
+    { \
+        CsrWifiSmeMibSetReq *msg__; \
+        CsrWifiSmeMibSetReqCreate(msg__, dst__, src__, mibAttributeLength__, mibAttribute__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMibSetReqSend(src__, mibAttributeLength__, mibAttribute__) \
+    CsrWifiSmeMibSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, mibAttributeLength__, mibAttribute__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibSetCfmSend
+
+  DESCRIPTION
+    The SME calls the primitive to report the result of the set primitive.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeMibSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeMibSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeMibSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIB_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeMibSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeMibSetCfm *msg__; \
+        CsrWifiSmeMibSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMibSetCfmSend(dst__, status__) \
+    CsrWifiSmeMibSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMicFailureIndSend
+
+  DESCRIPTION
+    The SME sends this primitive to all the tasks that have registered to
+    receive it whenever the chip firmware reports a MIC failure.
+
+  PARAMETERS
+    queue         - Destination Task Queue
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    secondFailure - TRUE if this indication is for a second failure in 60
+                    seconds
+    count         - The number of MIC failure events since the connection was
+                    established
+    address       - MAC address of the transmitter that caused the MIC failure
+    keyType       - Type of key for which the failure occurred
+
+*******************************************************************************/
+#define CsrWifiSmeMicFailureIndCreate(msg__, dst__, src__, interfaceTag__, secondFailure__, count__, address__, keyType__) \
+    msg__ = (CsrWifiSmeMicFailureInd *) CsrPmemAlloc(sizeof(CsrWifiSmeMicFailureInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MIC_FAILURE_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->secondFailure = (secondFailure__); \
+    msg__->count = (count__); \
+    msg__->address = (address__); \
+    msg__->keyType = (keyType__);
+
+#define CsrWifiSmeMicFailureIndSendTo(dst__, src__, interfaceTag__, secondFailure__, count__, address__, keyType__) \
+    { \
+        CsrWifiSmeMicFailureInd *msg__; \
+        CsrWifiSmeMicFailureIndCreate(msg__, dst__, src__, interfaceTag__, secondFailure__, count__, address__, keyType__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMicFailureIndSend(dst__, interfaceTag__, secondFailure__, count__, address__, keyType__) \
+    CsrWifiSmeMicFailureIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, secondFailure__, count__, address__, keyType__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMulticastAddressReqSend
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to specify the
+    multicast addresses which the chip should recognise. The interface allows
+    the wireless manager application to query, add, remove and flush the
+    multicast addresses for the network interface according to the specified
+    action.
+
+  PARAMETERS
+    queue             - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag      - Interface Identifier; unique identifier of an interface
+    action            - The value of the CsrWifiSmeListAction parameter
+                        instructs the driver to modify or provide the list of
+                        MAC addresses.
+    setAddressesCount - Number of MAC addresses sent with the primitive
+    setAddresses      - Pointer to the list of MAC Addresses sent with the
+                        primitive, set to NULL if none is sent.
+
+*******************************************************************************/
+#define CsrWifiSmeMulticastAddressReqCreate(msg__, dst__, src__, interfaceTag__, action__, setAddressesCount__, setAddresses__) \
+    msg__ = (CsrWifiSmeMulticastAddressReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMulticastAddressReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MULTICAST_ADDRESS_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->action = (action__); \
+    msg__->setAddressesCount = (setAddressesCount__); \
+    msg__->setAddresses = (setAddresses__);
+
+#define CsrWifiSmeMulticastAddressReqSendTo(dst__, src__, interfaceTag__, action__, setAddressesCount__, setAddresses__) \
+    { \
+        CsrWifiSmeMulticastAddressReq *msg__; \
+        CsrWifiSmeMulticastAddressReqCreate(msg__, dst__, src__, interfaceTag__, action__, setAddressesCount__, setAddresses__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMulticastAddressReqSend(src__, interfaceTag__, action__, setAddressesCount__, setAddresses__) \
+    CsrWifiSmeMulticastAddressReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, action__, setAddressesCount__, setAddresses__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMulticastAddressCfmSend
+
+  DESCRIPTION
+    The SME will call this primitive when the operation is complete. For a
+    GET action, this primitive reports the current list of MAC addresses.
+
+  PARAMETERS
+    queue             - Destination Task Queue
+    interfaceTag      - Interface Identifier; unique identifier of an interface
+    status            - Reports the result of the request
+    action            - Action in the request
+    getAddressesCount - This parameter is only relevant if action is
+                        CSR_WIFI_SME_LIST_ACTION_GET:
+                        number of MAC addresses sent with the primitive
+    getAddresses      - Pointer to the list of MAC Addresses sent with the
+                        primitive, set to NULL if none is sent.
+
+*******************************************************************************/
+#define CsrWifiSmeMulticastAddressCfmCreate(msg__, dst__, src__, interfaceTag__, status__, action__, getAddressesCount__, getAddresses__) \
+    msg__ = (CsrWifiSmeMulticastAddressCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeMulticastAddressCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_MULTICAST_ADDRESS_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->action = (action__); \
+    msg__->getAddressesCount = (getAddressesCount__); \
+    msg__->getAddresses = (getAddresses__);
+
+#define CsrWifiSmeMulticastAddressCfmSendTo(dst__, src__, interfaceTag__, status__, action__, getAddressesCount__, getAddresses__) \
+    { \
+        CsrWifiSmeMulticastAddressCfm *msg__; \
+        CsrWifiSmeMulticastAddressCfmCreate(msg__, dst__, src__, interfaceTag__, status__, action__, getAddressesCount__, getAddresses__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeMulticastAddressCfmSend(dst__, interfaceTag__, status__, action__, getAddressesCount__, getAddresses__) \
+    CsrWifiSmeMulticastAddressCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, action__, getAddressesCount__, getAddresses__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePacketFilterSetReqSend
+
+  DESCRIPTION
+    The wireless manager application should call this primitive to enable or
+    disable filtering of broadcast packets: uninteresting broadcast packets
+    will be dropped by the Wi-Fi chip, instead of passing them up to the
+    host.
+    This has the advantage of saving power in the host application processor
+    as it removes the need to process unwanted packets.
+    All broadcast packets are filtered according to the filter and the filter
+    mode provided, except ARP packets, which are filtered using
+    arpFilterAddress.
+    Filters are not cumulative: only the parameters specified in the most
+    recent successful request are significant.
+    For more information, see 'UniFi Firmware API Specification'.
+
+  PARAMETERS
+    queue            - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag     - Interface Identifier; unique identifier of an interface
+    filterLength     - Length of the filter in bytes.
+                       filterLength=0 disables the filter previously set
+    filter           - Points to the first byte of the filter provided, if any.
+                       This shall include zero or more instance of the
+                       information elements of one of these types
+                         * Traffic Classification (TCLAS) elements
+                         * WMM-SA TCLAS elements
+    mode             - Specifies whether the filter selects or excludes packets
+                       matching the filter
+    arpFilterAddress - IPv4 address to be used for filtering the ARP packets.
+                         * If the specified address is the IPv4 broadcast address
+                           (255.255.255.255), all ARP packets are reported to the
+                           host,
+                         * If the specified address is NOT the IPv4 broadcast
+                           address, only ARP packets with the specified address in
+                           the Source or Target Protocol Address fields are reported
+                           to the host
+
+*******************************************************************************/
+#define CsrWifiSmePacketFilterSetReqCreate(msg__, dst__, src__, interfaceTag__, filterLength__, filter__, mode__, arpFilterAddress__) \
+    msg__ = (CsrWifiSmePacketFilterSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmePacketFilterSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_PACKET_FILTER_SET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->filterLength = (filterLength__); \
+    msg__->filter = (filter__); \
+    msg__->mode = (mode__); \
+    msg__->arpFilterAddress = (arpFilterAddress__);
+
+#define CsrWifiSmePacketFilterSetReqSendTo(dst__, src__, interfaceTag__, filterLength__, filter__, mode__, arpFilterAddress__) \
+    { \
+        CsrWifiSmePacketFilterSetReq *msg__; \
+        CsrWifiSmePacketFilterSetReqCreate(msg__, dst__, src__, interfaceTag__, filterLength__, filter__, mode__, arpFilterAddress__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePacketFilterSetReqSend(src__, interfaceTag__, filterLength__, filter__, mode__, arpFilterAddress__) \
+    CsrWifiSmePacketFilterSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, filterLength__, filter__, mode__, arpFilterAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePacketFilterSetCfmSend
+
+  DESCRIPTION
+    The SME calls the primitive to report the result of the set primitive.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmePacketFilterSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmePacketFilterSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmePacketFilterSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_PACKET_FILTER_SET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmePacketFilterSetCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmePacketFilterSetCfm *msg__; \
+        CsrWifiSmePacketFilterSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePacketFilterSetCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmePacketFilterSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePermanentMacAddressGetReqSend
+
+  DESCRIPTION
+    This primitive retrieves the MAC address stored in EEPROM
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmePermanentMacAddressGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmePermanentMacAddressGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmePermanentMacAddressGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_PERMANENT_MAC_ADDRESS_GET_REQ, dst__, src__);
+
+#define CsrWifiSmePermanentMacAddressGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmePermanentMacAddressGetReq *msg__; \
+        CsrWifiSmePermanentMacAddressGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePermanentMacAddressGetReqSend(src__) \
+    CsrWifiSmePermanentMacAddressGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePermanentMacAddressGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue               - Destination Task Queue
+    status              - Reports the result of the request
+    permanentMacAddress - MAC address stored in the EEPROM
+
+*******************************************************************************/
+#define CsrWifiSmePermanentMacAddressGetCfmCreate(msg__, dst__, src__, status__, permanentMacAddress__) \
+    msg__ = (CsrWifiSmePermanentMacAddressGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmePermanentMacAddressGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_PERMANENT_MAC_ADDRESS_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->permanentMacAddress = (permanentMacAddress__);
+
+#define CsrWifiSmePermanentMacAddressGetCfmSendTo(dst__, src__, status__, permanentMacAddress__) \
+    { \
+        CsrWifiSmePermanentMacAddressGetCfm *msg__; \
+        CsrWifiSmePermanentMacAddressGetCfmCreate(msg__, dst__, src__, status__, permanentMacAddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePermanentMacAddressGetCfmSend(dst__, status__, permanentMacAddress__) \
+    CsrWifiSmePermanentMacAddressGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, permanentMacAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePmkidCandidateListIndSend
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive it when a new network supporting preauthentication and/or PMK
+    caching is seen.
+
+  PARAMETERS
+    queue                - Destination Task Queue
+    interfaceTag         - Interface Identifier; unique identifier of an
+                           interface
+    pmkidCandidatesCount - Number of PMKID candidates provided
+    pmkidCandidates      - Points to the first PMKID candidate
+
+*******************************************************************************/
+#define CsrWifiSmePmkidCandidateListIndCreate(msg__, dst__, src__, interfaceTag__, pmkidCandidatesCount__, pmkidCandidates__) \
+    msg__ = (CsrWifiSmePmkidCandidateListInd *) CsrPmemAlloc(sizeof(CsrWifiSmePmkidCandidateListInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_PMKID_CANDIDATE_LIST_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->pmkidCandidatesCount = (pmkidCandidatesCount__); \
+    msg__->pmkidCandidates = (pmkidCandidates__);
+
+#define CsrWifiSmePmkidCandidateListIndSendTo(dst__, src__, interfaceTag__, pmkidCandidatesCount__, pmkidCandidates__) \
+    { \
+        CsrWifiSmePmkidCandidateListInd *msg__; \
+        CsrWifiSmePmkidCandidateListIndCreate(msg__, dst__, src__, interfaceTag__, pmkidCandidatesCount__, pmkidCandidates__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePmkidCandidateListIndSend(dst__, interfaceTag__, pmkidCandidatesCount__, pmkidCandidates__) \
+    CsrWifiSmePmkidCandidateListIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, pmkidCandidatesCount__, pmkidCandidates__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePmkidReqSend
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to request an
+    operation on the SME PMKID list.
+    The action argument specifies the operation to perform.
+    When the connection is complete, the wireless manager application may
+    then send and receive EAPOL packets to complete WPA or WPA2
+    authentication if appropriate.
+    The wireless manager application can then pass the resulting encryption
+    keys using this primitive.
+
+  PARAMETERS
+    queue          - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    action         - The value of the CsrWifiSmeListAction parameter instructs
+                     the driver to modify or provide the list of PMKIDs.
+    setPmkidsCount - Number of PMKIDs sent with the primitive
+    setPmkids      - Pointer to the list of PMKIDs sent with the primitive, set
+                     to NULL if none is sent.
+
+*******************************************************************************/
+#define CsrWifiSmePmkidReqCreate(msg__, dst__, src__, interfaceTag__, action__, setPmkidsCount__, setPmkids__) \
+    msg__ = (CsrWifiSmePmkidReq *) CsrPmemAlloc(sizeof(CsrWifiSmePmkidReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_PMKID_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->action = (action__); \
+    msg__->setPmkidsCount = (setPmkidsCount__); \
+    msg__->setPmkids = (setPmkids__);
+
+#define CsrWifiSmePmkidReqSendTo(dst__, src__, interfaceTag__, action__, setPmkidsCount__, setPmkids__) \
+    { \
+        CsrWifiSmePmkidReq *msg__; \
+        CsrWifiSmePmkidReqCreate(msg__, dst__, src__, interfaceTag__, action__, setPmkidsCount__, setPmkids__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePmkidReqSend(src__, interfaceTag__, action__, setPmkidsCount__, setPmkids__) \
+    CsrWifiSmePmkidReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, action__, setPmkidsCount__, setPmkids__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePmkidCfmSend
+
+  DESCRIPTION
+    The SME will call this primitive when the operation is complete. For a
+    GET action, this primitive reports the current list of PMKIDs
+
+  PARAMETERS
+    queue          - Destination Task Queue
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    status         - Reports the result of the request
+    action         - Action in the request
+    getPmkidsCount - This parameter is only relevant if action is
+                     CSR_WIFI_SME_LIST_ACTION_GET:
+                     number of PMKIDs sent with the primitive
+    getPmkids      - Pointer to the list of PMKIDs sent with the primitive, set
+                     to NULL if none is sent.
+
+*******************************************************************************/
+#define CsrWifiSmePmkidCfmCreate(msg__, dst__, src__, interfaceTag__, status__, action__, getPmkidsCount__, getPmkids__) \
+    msg__ = (CsrWifiSmePmkidCfm *) CsrPmemAlloc(sizeof(CsrWifiSmePmkidCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_PMKID_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->action = (action__); \
+    msg__->getPmkidsCount = (getPmkidsCount__); \
+    msg__->getPmkids = (getPmkids__);
+
+#define CsrWifiSmePmkidCfmSendTo(dst__, src__, interfaceTag__, status__, action__, getPmkidsCount__, getPmkids__) \
+    { \
+        CsrWifiSmePmkidCfm *msg__; \
+        CsrWifiSmePmkidCfmCreate(msg__, dst__, src__, interfaceTag__, status__, action__, getPmkidsCount__, getPmkids__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePmkidCfmSend(dst__, interfaceTag__, status__, action__, getPmkidsCount__, getPmkids__) \
+    CsrWifiSmePmkidCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, action__, getPmkidsCount__, getPmkids__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePowerConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the PowerConfig parameter.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmePowerConfigGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmePowerConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmePowerConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_POWER_CONFIG_GET_REQ, dst__, src__);
+
+#define CsrWifiSmePowerConfigGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmePowerConfigGetReq *msg__; \
+        CsrWifiSmePowerConfigGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePowerConfigGetReqSend(src__) \
+    CsrWifiSmePowerConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePowerConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue       - Destination Task Queue
+    status      - Reports the result of the request
+    powerConfig - Returns the current parameters for the power configuration of
+                  the firmware
+
+*******************************************************************************/
+#define CsrWifiSmePowerConfigGetCfmCreate(msg__, dst__, src__, status__, powerConfig__) \
+    msg__ = (CsrWifiSmePowerConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmePowerConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_POWER_CONFIG_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->powerConfig = (powerConfig__);
+
+#define CsrWifiSmePowerConfigGetCfmSendTo(dst__, src__, status__, powerConfig__) \
+    { \
+        CsrWifiSmePowerConfigGetCfm *msg__; \
+        CsrWifiSmePowerConfigGetCfmCreate(msg__, dst__, src__, status__, powerConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePowerConfigGetCfmSend(dst__, status__, powerConfig__) \
+    CsrWifiSmePowerConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, powerConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePowerConfigSetReqSend
+
+  DESCRIPTION
+    This primitive sets the value of the PowerConfig parameter.
+
+  PARAMETERS
+    queue       - Message Source Task Queue (Cfm's will be sent to this Queue)
+    powerConfig - Power saving configuration
+
+*******************************************************************************/
+#define CsrWifiSmePowerConfigSetReqCreate(msg__, dst__, src__, powerConfig__) \
+    msg__ = (CsrWifiSmePowerConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmePowerConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_POWER_CONFIG_SET_REQ, dst__, src__); \
+    msg__->powerConfig = (powerConfig__);
+
+#define CsrWifiSmePowerConfigSetReqSendTo(dst__, src__, powerConfig__) \
+    { \
+        CsrWifiSmePowerConfigSetReq *msg__; \
+        CsrWifiSmePowerConfigSetReqCreate(msg__, dst__, src__, powerConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePowerConfigSetReqSend(src__, powerConfig__) \
+    CsrWifiSmePowerConfigSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, powerConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePowerConfigSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmePowerConfigSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmePowerConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmePowerConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_POWER_CONFIG_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmePowerConfigSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmePowerConfigSetCfm *msg__; \
+        CsrWifiSmePowerConfigSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmePowerConfigSetCfmSend(dst__, status__) \
+    CsrWifiSmePowerConfigSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRegulatoryDomainInfoGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the RegulatoryDomainInfo parameter.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeRegulatoryDomainInfoGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeRegulatoryDomainInfoGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeRegulatoryDomainInfoGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_REGULATORY_DOMAIN_INFO_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeRegulatoryDomainInfoGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeRegulatoryDomainInfoGetReq *msg__; \
+        CsrWifiSmeRegulatoryDomainInfoGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeRegulatoryDomainInfoGetReqSend(src__) \
+    CsrWifiSmeRegulatoryDomainInfoGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRegulatoryDomainInfoGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue      - Destination Task Queue
+    status     - Reports the result of the request
+    regDomInfo - Reports information and state related to regulatory domain
+                 operation.
+
+*******************************************************************************/
+#define CsrWifiSmeRegulatoryDomainInfoGetCfmCreate(msg__, dst__, src__, status__, regDomInfo__) \
+    msg__ = (CsrWifiSmeRegulatoryDomainInfoGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeRegulatoryDomainInfoGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_REGULATORY_DOMAIN_INFO_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->regDomInfo = (regDomInfo__);
+
+#define CsrWifiSmeRegulatoryDomainInfoGetCfmSendTo(dst__, src__, status__, regDomInfo__) \
+    { \
+        CsrWifiSmeRegulatoryDomainInfoGetCfm *msg__; \
+        CsrWifiSmeRegulatoryDomainInfoGetCfmCreate(msg__, dst__, src__, status__, regDomInfo__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeRegulatoryDomainInfoGetCfmSend(dst__, status__, regDomInfo__) \
+    CsrWifiSmeRegulatoryDomainInfoGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, regDomInfo__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamCompleteIndSend
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive it whenever it completes an attempt to roam to an AP. If the roam
+    attempt was successful, status will be set to CSR_WIFI_SME_SUCCESS,
+    otherwise it shall be set to the appropriate error code.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the roaming procedure
+
+*******************************************************************************/
+#define CsrWifiSmeRoamCompleteIndCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeRoamCompleteInd *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamCompleteInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ROAM_COMPLETE_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeRoamCompleteIndSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeRoamCompleteInd *msg__; \
+        CsrWifiSmeRoamCompleteIndCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeRoamCompleteIndSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeRoamCompleteIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamStartIndSend
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive it whenever it begins an attempt to roam to an AP.
+    If the wireless manager application connect request specified the SSID
+    and the BSSID was set to the broadcast address (0xFF 0xFF 0xFF 0xFF 0xFF
+    0xFF), the SME monitors the signal quality and maintains a list of
+    candidates to roam to. When the signal quality of the current connection
+    falls below a threshold, and there is a candidate with better quality,
+    the SME will attempt to the candidate AP.
+    If the roaming procedure succeeds, the SME will also issue a Media
+    Connect indication to inform the wireless manager application of the
+    change.
+    NOTE: to prevent the SME from initiating roaming the WMA must specify the
+    BSSID in the connection request; this forces the SME to connect only to
+    that AP.
+    The wireless manager application can obtain statistics for roaming
+    purposes using CSR_WIFI_SME_CONNECTION_QUALITY_IND and
+    CSR_WIFI_SME_CONNECTION_STATS_GET_REQ.
+    When the wireless manager application wishes to roam to another AP, it
+    must issue a connection request specifying the BSSID of the desired AP.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    roamReason   - Indicates the reason for starting the roaming procedure
+    reason80211  - Indicates the reason for deauthentication or disassociation
+
+*******************************************************************************/
+#define CsrWifiSmeRoamStartIndCreate(msg__, dst__, src__, interfaceTag__, roamReason__, reason80211__) \
+    msg__ = (CsrWifiSmeRoamStartInd *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamStartInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ROAM_START_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->roamReason = (roamReason__); \
+    msg__->reason80211 = (reason80211__);
+
+#define CsrWifiSmeRoamStartIndSendTo(dst__, src__, interfaceTag__, roamReason__, reason80211__) \
+    { \
+        CsrWifiSmeRoamStartInd *msg__; \
+        CsrWifiSmeRoamStartIndCreate(msg__, dst__, src__, interfaceTag__, roamReason__, reason80211__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeRoamStartIndSend(dst__, interfaceTag__, roamReason__, reason80211__) \
+    CsrWifiSmeRoamStartIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, roamReason__, reason80211__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamingConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the RoamingConfig parameter.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiSmeRoamingConfigGetReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeRoamingConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamingConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ROAMING_CONFIG_GET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeRoamingConfigGetReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeRoamingConfigGetReq *msg__; \
+        CsrWifiSmeRoamingConfigGetReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeRoamingConfigGetReqSend(src__, interfaceTag__) \
+    CsrWifiSmeRoamingConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamingConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue         - Destination Task Queue
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    status        - Reports the result of the request
+    roamingConfig - Reports the roaming behaviour of the driver and firmware
+
+*******************************************************************************/
+#define CsrWifiSmeRoamingConfigGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, roamingConfig__) \
+    msg__ = (CsrWifiSmeRoamingConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamingConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ROAMING_CONFIG_GET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->roamingConfig = (roamingConfig__);
+
+#define CsrWifiSmeRoamingConfigGetCfmSendTo(dst__, src__, interfaceTag__, status__, roamingConfig__) \
+    { \
+        CsrWifiSmeRoamingConfigGetCfm *msg__; \
+        CsrWifiSmeRoamingConfigGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, roamingConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeRoamingConfigGetCfmSend(dst__, interfaceTag__, status__, roamingConfig__) \
+    CsrWifiSmeRoamingConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, roamingConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamingConfigSetReqSend
+
+  DESCRIPTION
+    This primitive sets the value of the RoamingConfig parameter.
+
+  PARAMETERS
+    queue         - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    roamingConfig - Desired roaming behaviour values
+
+*******************************************************************************/
+#define CsrWifiSmeRoamingConfigSetReqCreate(msg__, dst__, src__, interfaceTag__, roamingConfig__) \
+    msg__ = (CsrWifiSmeRoamingConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamingConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ROAMING_CONFIG_SET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->roamingConfig = (roamingConfig__);
+
+#define CsrWifiSmeRoamingConfigSetReqSendTo(dst__, src__, interfaceTag__, roamingConfig__) \
+    { \
+        CsrWifiSmeRoamingConfigSetReq *msg__; \
+        CsrWifiSmeRoamingConfigSetReqCreate(msg__, dst__, src__, interfaceTag__, roamingConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeRoamingConfigSetReqSend(src__, interfaceTag__, roamingConfig__) \
+    CsrWifiSmeRoamingConfigSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, roamingConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamingConfigSetCfmSend
+
+  DESCRIPTION
+    This primitive sets the value of the RoamingConfig parameter.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeRoamingConfigSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeRoamingConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamingConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_ROAMING_CONFIG_SET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeRoamingConfigSetCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeRoamingConfigSetCfm *msg__; \
+        CsrWifiSmeRoamingConfigSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeRoamingConfigSetCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeRoamingConfigSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the ScanConfig parameter.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeScanConfigGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeScanConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeScanConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_CONFIG_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeScanConfigGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeScanConfigGetReq *msg__; \
+        CsrWifiSmeScanConfigGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanConfigGetReqSend(src__) \
+    CsrWifiSmeScanConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue      - Destination Task Queue
+    status     - Reports the result of the request
+    scanConfig - Returns the current parameters for the autonomous scanning
+                 behaviour of the firmware
+
+*******************************************************************************/
+#define CsrWifiSmeScanConfigGetCfmCreate(msg__, dst__, src__, status__, scanConfig__) \
+    msg__ = (CsrWifiSmeScanConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeScanConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_CONFIG_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->scanConfig = (scanConfig__);
+
+#define CsrWifiSmeScanConfigGetCfmSendTo(dst__, src__, status__, scanConfig__) \
+    { \
+        CsrWifiSmeScanConfigGetCfm *msg__; \
+        CsrWifiSmeScanConfigGetCfmCreate(msg__, dst__, src__, status__, scanConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanConfigGetCfmSend(dst__, status__, scanConfig__) \
+    CsrWifiSmeScanConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, scanConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanConfigSetReqSend
+
+  DESCRIPTION
+    This primitive sets the value of the ScanConfig parameter.
+    The SME normally configures the firmware to perform autonomous scanning
+    without involving the host.
+    The firmware passes beacon / probe response or indicates loss of beacon
+    on certain changes of state, for example:
+      * A new AP is seen for the first time
+      * An AP is no longer visible
+      * The signal strength of an AP changes by more than a certain amount, as
+        configured by the thresholds in the scanConfig parameter
+    In addition to the autonomous scan, the wireless manager application may
+    request a scan at any time using CSR_WIFI_SME_SCAN_FULL_REQ.
+
+  PARAMETERS
+    queue      - Message Source Task Queue (Cfm's will be sent to this Queue)
+    scanConfig - Reports the configuration for the autonomous scanning behaviour
+                 of the firmware
+
+*******************************************************************************/
+#define CsrWifiSmeScanConfigSetReqCreate(msg__, dst__, src__, scanConfig__) \
+    msg__ = (CsrWifiSmeScanConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeScanConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_CONFIG_SET_REQ, dst__, src__); \
+    msg__->scanConfig = (scanConfig__);
+
+#define CsrWifiSmeScanConfigSetReqSendTo(dst__, src__, scanConfig__) \
+    { \
+        CsrWifiSmeScanConfigSetReq *msg__; \
+        CsrWifiSmeScanConfigSetReqCreate(msg__, dst__, src__, scanConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanConfigSetReqSend(src__, scanConfig__) \
+    CsrWifiSmeScanConfigSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, scanConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanConfigSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeScanConfigSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeScanConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeScanConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_CONFIG_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeScanConfigSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeScanConfigSetCfm *msg__; \
+        CsrWifiSmeScanConfigSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanConfigSetCfmSend(dst__, status__) \
+    CsrWifiSmeScanConfigSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanFullReqSend
+
+  DESCRIPTION
+    The wireless manager application should call this primitive to request a
+    full scan.
+    Channels are scanned actively or passively according to the requirement
+    set by regulatory domain.
+    If the SME receives this primitive while a full scan is going on, the new
+    request is buffered and it will be served after the current full scan is
+    completed.
+
+  PARAMETERS
+    queue            - Message Source Task Queue (Cfm's will be sent to this Queue)
+    ssidCount        - Number of SSIDs provided.
+                       If it is 0, the SME will attempt to detect any network
+    ssid             - Points to the first SSID provided, if any.
+    bssid            - BSS identifier.
+                       If it is equal to FF-FF-FF-FF-FF, the SME will listen for
+                       messages from any BSS.
+                       If it is different from FF-FF-FF-FF-FF and any SSID is
+                       provided, one SSID must match the network of the BSS.
+    forceScan        - Forces the scan even if the SME is in a state which would
+                       normally prevent it (e.g. autonomous scan is running).
+    bssType          - Type of BSS to scan for
+    scanType         - Type of scan to perform
+    channelListCount - Number of channels provided.
+                       If it is 0, the SME will initiate a scan of all the
+                       supported channels that are permitted by the current
+                       regulatory domain.
+    channelList      - Points to the first channel , or NULL if channelListCount
+                       is zero.
+    probeIeLength    - Length of the information element in bytes to be sent
+                       with the probe message.
+    probeIe          - Points to the first byte of the information element to be
+                       sent with the probe message.
+
+*******************************************************************************/
+#define CsrWifiSmeScanFullReqCreate(msg__, dst__, src__, ssidCount__, ssid__, bssid__, forceScan__, bssType__, scanType__, channelListCount__, channelList__, probeIeLength__, probeIe__) \
+    msg__ = (CsrWifiSmeScanFullReq *) CsrPmemAlloc(sizeof(CsrWifiSmeScanFullReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_FULL_REQ, dst__, src__); \
+    msg__->ssidCount = (ssidCount__); \
+    msg__->ssid = (ssid__); \
+    msg__->bssid = (bssid__); \
+    msg__->forceScan = (forceScan__); \
+    msg__->bssType = (bssType__); \
+    msg__->scanType = (scanType__); \
+    msg__->channelListCount = (channelListCount__); \
+    msg__->channelList = (channelList__); \
+    msg__->probeIeLength = (probeIeLength__); \
+    msg__->probeIe = (probeIe__);
+
+#define CsrWifiSmeScanFullReqSendTo(dst__, src__, ssidCount__, ssid__, bssid__, forceScan__, bssType__, scanType__, channelListCount__, channelList__, probeIeLength__, probeIe__) \
+    { \
+        CsrWifiSmeScanFullReq *msg__; \
+        CsrWifiSmeScanFullReqCreate(msg__, dst__, src__, ssidCount__, ssid__, bssid__, forceScan__, bssType__, scanType__, channelListCount__, channelList__, probeIeLength__, probeIe__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanFullReqSend(src__, ssidCount__, ssid__, bssid__, forceScan__, bssType__, scanType__, channelListCount__, channelList__, probeIeLength__, probeIe__) \
+    CsrWifiSmeScanFullReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, ssidCount__, ssid__, bssid__, forceScan__, bssType__, scanType__, channelListCount__, channelList__, probeIeLength__, probeIe__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanFullCfmSend
+
+  DESCRIPTION
+    The SME calls this primitive when the results from the scan are
+    available.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeScanFullCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeScanFullCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeScanFullCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_FULL_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeScanFullCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeScanFullCfm *msg__; \
+        CsrWifiSmeScanFullCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanFullCfmSend(dst__, status__) \
+    CsrWifiSmeScanFullCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResultIndSend
+
+  DESCRIPTION
+    The SME sends this primitive to all the tasks that have registered to
+    receive it whenever a scan indication is received from the firmware.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    result - Points to a buffer containing a scan result.
+
+*******************************************************************************/
+#define CsrWifiSmeScanResultIndCreate(msg__, dst__, src__, result__) \
+    msg__ = (CsrWifiSmeScanResultInd *) CsrPmemAlloc(sizeof(CsrWifiSmeScanResultInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_RESULT_IND, dst__, src__); \
+    msg__->result = (result__);
+
+#define CsrWifiSmeScanResultIndSendTo(dst__, src__, result__) \
+    { \
+        CsrWifiSmeScanResultInd *msg__; \
+        CsrWifiSmeScanResultIndCreate(msg__, dst__, src__, result__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanResultIndSend(dst__, result__) \
+    CsrWifiSmeScanResultIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, result__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResultsFlushReqSend
+
+  DESCRIPTION
+    The Wireless Manager calls this primitive to ask the SME to delete all
+    scan results from its cache, except for the scan result of any currently
+    connected network.
+    As scan results are received by the SME from the firmware, they are
+    cached in the SME memory.
+    Any time the Wireless Manager requests scan results, they are returned
+    from the SME internal cache.
+    For some applications it may be desirable to clear this cache prior to
+    requesting that a scan be performed; this will ensure that the cache then
+    only contains the networks detected in the most recent scan.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeScanResultsFlushReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeScanResultsFlushReq *) CsrPmemAlloc(sizeof(CsrWifiSmeScanResultsFlushReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_RESULTS_FLUSH_REQ, dst__, src__);
+
+#define CsrWifiSmeScanResultsFlushReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeScanResultsFlushReq *msg__; \
+        CsrWifiSmeScanResultsFlushReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanResultsFlushReqSend(src__) \
+    CsrWifiSmeScanResultsFlushReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResultsFlushCfmSend
+
+  DESCRIPTION
+    The SME will call this primitive when the cache has been cleared.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeScanResultsFlushCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeScanResultsFlushCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeScanResultsFlushCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_RESULTS_FLUSH_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeScanResultsFlushCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeScanResultsFlushCfm *msg__; \
+        CsrWifiSmeScanResultsFlushCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanResultsFlushCfmSend(dst__, status__) \
+    CsrWifiSmeScanResultsFlushCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResultsGetReqSend
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to retrieve the
+    current set of scan results, either after receiving a successful
+    CSR_WIFI_SME_SCAN_FULL_CFM, or to get autonomous scan results.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeScanResultsGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeScanResultsGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeScanResultsGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_RESULTS_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeScanResultsGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeScanResultsGetReq *msg__; \
+        CsrWifiSmeScanResultsGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanResultsGetReqSend(src__) \
+    CsrWifiSmeScanResultsGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResultsGetCfmSend
+
+  DESCRIPTION
+    The SME sends this primitive to provide the current set of scan results.
+
+  PARAMETERS
+    queue            - Destination Task Queue
+    status           - Reports the result of the request
+    scanResultsCount - Number of scan results
+    scanResults      - Points to a buffer containing an array of
+                       CsrWifiSmeScanResult structures.
+
+*******************************************************************************/
+#define CsrWifiSmeScanResultsGetCfmCreate(msg__, dst__, src__, status__, scanResultsCount__, scanResults__) \
+    msg__ = (CsrWifiSmeScanResultsGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeScanResultsGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SCAN_RESULTS_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->scanResultsCount = (scanResultsCount__); \
+    msg__->scanResults = (scanResults__);
+
+#define CsrWifiSmeScanResultsGetCfmSendTo(dst__, src__, status__, scanResultsCount__, scanResults__) \
+    { \
+        CsrWifiSmeScanResultsGetCfm *msg__; \
+        CsrWifiSmeScanResultsGetCfmCreate(msg__, dst__, src__, status__, scanResultsCount__, scanResults__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeScanResultsGetCfmSend(dst__, status__, scanResultsCount__, scanResults__) \
+    CsrWifiSmeScanResultsGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, scanResultsCount__, scanResults__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeCommonConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the Sme common parameter.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeSmeCommonConfigGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeSmeCommonConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeCommonConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SME_COMMON_CONFIG_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeSmeCommonConfigGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeSmeCommonConfigGetReq *msg__; \
+        CsrWifiSmeSmeCommonConfigGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeSmeCommonConfigGetReqSend(src__) \
+    CsrWifiSmeSmeCommonConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeCommonConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    status       - Reports the result of the request
+    deviceConfig - Configuration options in the SME
+
+*******************************************************************************/
+#define CsrWifiSmeSmeCommonConfigGetCfmCreate(msg__, dst__, src__, status__, deviceConfig__) \
+    msg__ = (CsrWifiSmeSmeCommonConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeCommonConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SME_COMMON_CONFIG_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->deviceConfig = (deviceConfig__);
+
+#define CsrWifiSmeSmeCommonConfigGetCfmSendTo(dst__, src__, status__, deviceConfig__) \
+    { \
+        CsrWifiSmeSmeCommonConfigGetCfm *msg__; \
+        CsrWifiSmeSmeCommonConfigGetCfmCreate(msg__, dst__, src__, status__, deviceConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeSmeCommonConfigGetCfmSend(dst__, status__, deviceConfig__) \
+    CsrWifiSmeSmeCommonConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, deviceConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeCommonConfigSetReqSend
+
+  DESCRIPTION
+    This primitive sets the value of the Sme common.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    deviceConfig - Configuration options in the SME
+
+*******************************************************************************/
+#define CsrWifiSmeSmeCommonConfigSetReqCreate(msg__, dst__, src__, deviceConfig__) \
+    msg__ = (CsrWifiSmeSmeCommonConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeCommonConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SME_COMMON_CONFIG_SET_REQ, dst__, src__); \
+    msg__->deviceConfig = (deviceConfig__);
+
+#define CsrWifiSmeSmeCommonConfigSetReqSendTo(dst__, src__, deviceConfig__) \
+    { \
+        CsrWifiSmeSmeCommonConfigSetReq *msg__; \
+        CsrWifiSmeSmeCommonConfigSetReqCreate(msg__, dst__, src__, deviceConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeSmeCommonConfigSetReqSend(src__, deviceConfig__) \
+    CsrWifiSmeSmeCommonConfigSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, deviceConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeCommonConfigSetCfmSend
+
+  DESCRIPTION
+    Reports the result of the request
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeSmeCommonConfigSetCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeSmeCommonConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeCommonConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SME_COMMON_CONFIG_SET_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeSmeCommonConfigSetCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeSmeCommonConfigSetCfm *msg__; \
+        CsrWifiSmeSmeCommonConfigSetCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeSmeCommonConfigSetCfmSend(dst__, status__) \
+    CsrWifiSmeSmeCommonConfigSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeStaConfigGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the SmeStaConfig parameter.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+#define CsrWifiSmeSmeStaConfigGetReqCreate(msg__, dst__, src__, interfaceTag__) \
+    msg__ = (CsrWifiSmeSmeStaConfigGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeStaConfigGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SME_STA_CONFIG_GET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__);
+
+#define CsrWifiSmeSmeStaConfigGetReqSendTo(dst__, src__, interfaceTag__) \
+    { \
+        CsrWifiSmeSmeStaConfigGetReq *msg__; \
+        CsrWifiSmeSmeStaConfigGetReqCreate(msg__, dst__, src__, interfaceTag__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeSmeStaConfigGetReqSend(src__, interfaceTag__) \
+    CsrWifiSmeSmeStaConfigGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeStaConfigGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+    smeConfig    - Current SME Station Parameters
+
+*******************************************************************************/
+#define CsrWifiSmeSmeStaConfigGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, smeConfig__) \
+    msg__ = (CsrWifiSmeSmeStaConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeStaConfigGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SME_STA_CONFIG_GET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->smeConfig = (smeConfig__);
+
+#define CsrWifiSmeSmeStaConfigGetCfmSendTo(dst__, src__, interfaceTag__, status__, smeConfig__) \
+    { \
+        CsrWifiSmeSmeStaConfigGetCfm *msg__; \
+        CsrWifiSmeSmeStaConfigGetCfmCreate(msg__, dst__, src__, interfaceTag__, status__, smeConfig__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeSmeStaConfigGetCfmSend(dst__, interfaceTag__, status__, smeConfig__) \
+    CsrWifiSmeSmeStaConfigGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, smeConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeStaConfigSetReqSend
+
+  DESCRIPTION
+    This primitive sets the value of the SmeConfig parameter.
+
+  PARAMETERS
+    queue        - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    smeConfig    - SME Station Parameters to be set
+
+*******************************************************************************/
+#define CsrWifiSmeSmeStaConfigSetReqCreate(msg__, dst__, src__, interfaceTag__, smeConfig__) \
+    msg__ = (CsrWifiSmeSmeStaConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeStaConfigSetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SME_STA_CONFIG_SET_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->smeConfig = (smeConfig__);
+
+#define CsrWifiSmeSmeStaConfigSetReqSendTo(dst__, src__, interfaceTag__, smeConfig__) \
+    { \
+        CsrWifiSmeSmeStaConfigSetReq *msg__; \
+        CsrWifiSmeSmeStaConfigSetReqCreate(msg__, dst__, src__, interfaceTag__, smeConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeSmeStaConfigSetReqSend(src__, interfaceTag__, smeConfig__) \
+    CsrWifiSmeSmeStaConfigSetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, smeConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeStaConfigSetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue        - Destination Task Queue
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeSmeStaConfigSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__) \
+    msg__ = (CsrWifiSmeSmeStaConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeStaConfigSetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_SME_STA_CONFIG_SET_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeSmeStaConfigSetCfmSendTo(dst__, src__, interfaceTag__, status__) \
+    { \
+        CsrWifiSmeSmeStaConfigSetCfm *msg__; \
+        CsrWifiSmeSmeStaConfigSetCfmCreate(msg__, dst__, src__, interfaceTag__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeSmeStaConfigSetCfmSend(dst__, interfaceTag__, status__) \
+    CsrWifiSmeSmeStaConfigSetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeStationMacAddressGetReqSend
+
+  DESCRIPTION
+    This primitives is used to retrieve the current MAC address used by the
+    station.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeStationMacAddressGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeStationMacAddressGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeStationMacAddressGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_STATION_MAC_ADDRESS_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeStationMacAddressGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeStationMacAddressGetReq *msg__; \
+        CsrWifiSmeStationMacAddressGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeStationMacAddressGetReqSend(src__) \
+    CsrWifiSmeStationMacAddressGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeStationMacAddressGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue             - Destination Task Queue
+    status            - Reports the result of the request
+    stationMacAddress - Current MAC address of the station.
+
+*******************************************************************************/
+#define CsrWifiSmeStationMacAddressGetCfmCreate(msg__, dst__, src__, status__, stationMacAddress__) \
+    msg__ = (CsrWifiSmeStationMacAddressGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeStationMacAddressGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_STATION_MAC_ADDRESS_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    CsrMemCpy(msg__->stationMacAddress, (stationMacAddress__), sizeof(CsrWifiMacAddress) * 2);
+
+#define CsrWifiSmeStationMacAddressGetCfmSendTo(dst__, src__, status__, stationMacAddress__) \
+    { \
+        CsrWifiSmeStationMacAddressGetCfm *msg__; \
+        CsrWifiSmeStationMacAddressGetCfmCreate(msg__, dst__, src__, status__, stationMacAddress__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeStationMacAddressGetCfmSend(dst__, status__, stationMacAddress__) \
+    CsrWifiSmeStationMacAddressGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, stationMacAddress__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTspecReqSend
+
+  DESCRIPTION
+    The wireless manager application should call this primitive to use the
+    TSPEC feature.
+    The chip supports the use of TSPECs and TCLAS for the use of IEEE
+    802.11/WMM Quality of Service features.
+    The API allows the wireless manager application to supply a correctly
+    formatted TSPEC and TCLAS pair to the driver.
+    After performing basic validation, the driver negotiates the installation
+    of the TSPEC with the AP as defined by the 802.11 specification.
+    The driver retains all TSPEC and TCLAS pairs until they are specifically
+    removed.
+    It is not compulsory for a TSPEC to have a TCLAS (NULL is used to
+    indicate that no TCLAS is supplied), while a TCLASS always require a
+    TSPEC.
+    The format of the TSPEC element is specified in 'WMM (including WMM Power
+    Save) Specification - Version 1.1' and 'ANSI/IEEE Std 802.11-REVmb/D3.0'.
+    For more information, see 'UniFi Configuring WMM and WMM-PS'.
+
+  PARAMETERS
+    queue         - Message Source Task Queue (Cfm's will be sent to this Queue)
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    action        - Specifies the action to be carried out on the list of TSPECs.
+                    CSR_WIFI_SME_LIST_ACTION_FLUSH is not applicable here.
+    transactionId - Unique Transaction ID for the TSPEC, as assigned by the
+                    driver
+    strict        - If it set to false, allows the SME to perform automatic
+                    TSPEC negotiation
+    ctrlMask      - Additional TSPEC configuration for CCX.
+                    Set mask with values from CsrWifiSmeTspecCtrl.
+                    CURRENTLY NOT SUPPORTED
+    tspecLength   - Length of the TSPEC.
+    tspec         - Points to the first byte of the TSPEC
+    tclasLength   - Length of the TCLAS.
+                    If it is equal to 0, no TCLASS is provided for the TSPEC
+    tclas         - Points to the first byte of the TCLAS, if any.
+
+*******************************************************************************/
+#define CsrWifiSmeTspecReqCreate(msg__, dst__, src__, interfaceTag__, action__, transactionId__, strict__, ctrlMask__, tspecLength__, tspec__, tclasLength__, tclas__) \
+    msg__ = (CsrWifiSmeTspecReq *) CsrPmemAlloc(sizeof(CsrWifiSmeTspecReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_TSPEC_REQ, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->action = (action__); \
+    msg__->transactionId = (transactionId__); \
+    msg__->strict = (strict__); \
+    msg__->ctrlMask = (ctrlMask__); \
+    msg__->tspecLength = (tspecLength__); \
+    msg__->tspec = (tspec__); \
+    msg__->tclasLength = (tclasLength__); \
+    msg__->tclas = (tclas__);
+
+#define CsrWifiSmeTspecReqSendTo(dst__, src__, interfaceTag__, action__, transactionId__, strict__, ctrlMask__, tspecLength__, tspec__, tclasLength__, tclas__) \
+    { \
+        CsrWifiSmeTspecReq *msg__; \
+        CsrWifiSmeTspecReqCreate(msg__, dst__, src__, interfaceTag__, action__, transactionId__, strict__, ctrlMask__, tspecLength__, tspec__, tclasLength__, tclas__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeTspecReqSend(src__, interfaceTag__, action__, transactionId__, strict__, ctrlMask__, tspecLength__, tspec__, tclasLength__, tclas__) \
+    CsrWifiSmeTspecReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, interfaceTag__, action__, transactionId__, strict__, ctrlMask__, tspecLength__, tspec__, tclasLength__, tclas__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTspecIndSend
+
+  DESCRIPTION
+    The SME will send this primitive to all the task that have registered to
+    receive it when a status change in the TSPEC occurs.
+
+  PARAMETERS
+    queue           - Destination Task Queue
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    transactionId   - Unique Transaction ID for the TSPEC, as assigned by the
+                      driver
+    tspecResultCode - Specifies the TSPEC operation requested by the peer
+                      station
+    tspecLength     - Length of the TSPEC.
+    tspec           - Points to the first byte of the TSPEC
+
+*******************************************************************************/
+#define CsrWifiSmeTspecIndCreate(msg__, dst__, src__, interfaceTag__, transactionId__, tspecResultCode__, tspecLength__, tspec__) \
+    msg__ = (CsrWifiSmeTspecInd *) CsrPmemAlloc(sizeof(CsrWifiSmeTspecInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_TSPEC_IND, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->transactionId = (transactionId__); \
+    msg__->tspecResultCode = (tspecResultCode__); \
+    msg__->tspecLength = (tspecLength__); \
+    msg__->tspec = (tspec__);
+
+#define CsrWifiSmeTspecIndSendTo(dst__, src__, interfaceTag__, transactionId__, tspecResultCode__, tspecLength__, tspec__) \
+    { \
+        CsrWifiSmeTspecInd *msg__; \
+        CsrWifiSmeTspecIndCreate(msg__, dst__, src__, interfaceTag__, transactionId__, tspecResultCode__, tspecLength__, tspec__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeTspecIndSend(dst__, interfaceTag__, transactionId__, tspecResultCode__, tspecLength__, tspec__) \
+    CsrWifiSmeTspecIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, transactionId__, tspecResultCode__, tspecLength__, tspec__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTspecCfmSend
+
+  DESCRIPTION
+    The SME calls the primitive to report the result of the TSpec primitive
+    request.
+
+  PARAMETERS
+    queue           - Destination Task Queue
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    status          - Reports the result of the request
+    transactionId   - Unique Transaction ID for the TSPEC, as assigned by the
+                      driver
+    tspecResultCode - Specifies the result of the negotiated TSPEC operation
+    tspecLength     - Length of the TSPEC.
+    tspec           - Points to the first byte of the TSPEC
+
+*******************************************************************************/
+#define CsrWifiSmeTspecCfmCreate(msg__, dst__, src__, interfaceTag__, status__, transactionId__, tspecResultCode__, tspecLength__, tspec__) \
+    msg__ = (CsrWifiSmeTspecCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeTspecCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_TSPEC_CFM, dst__, src__); \
+    msg__->interfaceTag = (interfaceTag__); \
+    msg__->status = (status__); \
+    msg__->transactionId = (transactionId__); \
+    msg__->tspecResultCode = (tspecResultCode__); \
+    msg__->tspecLength = (tspecLength__); \
+    msg__->tspec = (tspec__);
+
+#define CsrWifiSmeTspecCfmSendTo(dst__, src__, interfaceTag__, status__, transactionId__, tspecResultCode__, tspecLength__, tspec__) \
+    { \
+        CsrWifiSmeTspecCfm *msg__; \
+        CsrWifiSmeTspecCfmCreate(msg__, dst__, src__, interfaceTag__, status__, transactionId__, tspecResultCode__, tspecLength__, tspec__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeTspecCfmSend(dst__, interfaceTag__, status__, transactionId__, tspecResultCode__, tspecLength__, tspec__) \
+    CsrWifiSmeTspecCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, interfaceTag__, status__, transactionId__, tspecResultCode__, tspecLength__, tspec__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeVersionsGetReqSend
+
+  DESCRIPTION
+    This primitive gets the value of the Versions parameter.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeVersionsGetReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeVersionsGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeVersionsGetReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_VERSIONS_GET_REQ, dst__, src__);
+
+#define CsrWifiSmeVersionsGetReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeVersionsGetReq *msg__; \
+        CsrWifiSmeVersionsGetReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeVersionsGetReqSend(src__) \
+    CsrWifiSmeVersionsGetReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeVersionsGetCfmSend
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  PARAMETERS
+    queue    - Destination Task Queue
+    status   - Reports the result of the request
+    versions - Version IDs of the product
+
+*******************************************************************************/
+#define CsrWifiSmeVersionsGetCfmCreate(msg__, dst__, src__, status__, versions__) \
+    msg__ = (CsrWifiSmeVersionsGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeVersionsGetCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_VERSIONS_GET_CFM, dst__, src__); \
+    msg__->status = (status__); \
+    msg__->versions = (versions__);
+
+#define CsrWifiSmeVersionsGetCfmSendTo(dst__, src__, status__, versions__) \
+    { \
+        CsrWifiSmeVersionsGetCfm *msg__; \
+        CsrWifiSmeVersionsGetCfmCreate(msg__, dst__, src__, status__, versions__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeVersionsGetCfmSend(dst__, status__, versions__) \
+    CsrWifiSmeVersionsGetCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__, versions__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiFlightmodeReqSend
+
+  DESCRIPTION
+    The wireless manager application may call this primitive on boot-up of
+    the platform to ensure that the chip is placed in a mode that prevents
+    any emission of RF energy.
+    This primitive is an alternative to CSR_WIFI_SME_WIFI_ON_REQ.
+    As in CSR_WIFI_SME_WIFI_ON_REQ, it causes the download of the patch file
+    (if any) and the programming of the initial MIB settings (if supplied by
+    the WMA), but it also ensures that the chip is left in its lowest
+    possible power-mode with the radio subsystems disabled.
+    This feature is useful on platforms where power cannot be removed from
+    the chip (leaving the chip not initialised will cause it to consume more
+    power so calling this function ensures that the chip is initialised into
+    a low power mode but without entering a state where it could emit any RF
+    energy).
+    NOTE: this primitive does not cause the Wi-Fi to change state: Wi-Fi
+    stays conceptually off. Configuration primitives can be sent after
+    CSR_WIFI_SME_WIFI_FLIGHTMODE_REQ and the configuration will be maintained.
+    Requests that require the state of the Wi-Fi to be ON will return
+    CSR_WIFI_SME_STATUS_WIFI_OFF in their confirms.
+
+  PARAMETERS
+    queue         - Message Source Task Queue (Cfm's will be sent to this Queue)
+    address       - Optionally specifies a station MAC address.
+                    In normal use, the manager should set the address to 0xFF
+                    0xFF 0xFF 0xFF 0xFF 0xFF, which will cause the chip to use
+                    the MAC address in the MIB.
+    mibFilesCount - Number of provided data blocks with initial MIB values
+    mibFiles      - Points to the first data block with initial MIB values.
+                    These data blocks are typically the contents of the provided
+                    files ufmib.dat and localmib.dat, available from the host
+                    file system, if they exist.
+                    These files typically contain radio tuning and calibration
+                    values.
+                    More values can be created using the Host Tools.
+
+*******************************************************************************/
+#define CsrWifiSmeWifiFlightmodeReqCreate(msg__, dst__, src__, address__, mibFilesCount__, mibFiles__) \
+    msg__ = (CsrWifiSmeWifiFlightmodeReq *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiFlightmodeReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_WIFI_FLIGHTMODE_REQ, dst__, src__); \
+    msg__->address = (address__); \
+    msg__->mibFilesCount = (mibFilesCount__); \
+    msg__->mibFiles = (mibFiles__);
+
+#define CsrWifiSmeWifiFlightmodeReqSendTo(dst__, src__, address__, mibFilesCount__, mibFiles__) \
+    { \
+        CsrWifiSmeWifiFlightmodeReq *msg__; \
+        CsrWifiSmeWifiFlightmodeReqCreate(msg__, dst__, src__, address__, mibFilesCount__, mibFiles__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeWifiFlightmodeReqSend(src__, address__, mibFilesCount__, mibFiles__) \
+    CsrWifiSmeWifiFlightmodeReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, address__, mibFilesCount__, mibFiles__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiFlightmodeCfmSend
+
+  DESCRIPTION
+    The SME calls this primitive when the chip is initialised for low power
+    mode and with the radio subsystem disabled. To leave flight mode, and
+    enable Wi-Fi, the wireless manager application should call
+    CSR_WIFI_SME_WIFI_ON_REQ.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeWifiFlightmodeCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeWifiFlightmodeCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiFlightmodeCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_WIFI_FLIGHTMODE_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeWifiFlightmodeCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeWifiFlightmodeCfm *msg__; \
+        CsrWifiSmeWifiFlightmodeCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeWifiFlightmodeCfmSend(dst__, status__) \
+    CsrWifiSmeWifiFlightmodeCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOffReqSend
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to turn off the
+    chip, thus saving power when Wi-Fi is not in use.
+
+  PARAMETERS
+    queue  - Message Source Task Queue (Cfm's will be sent to this Queue)
+
+*******************************************************************************/
+#define CsrWifiSmeWifiOffReqCreate(msg__, dst__, src__) \
+    msg__ = (CsrWifiSmeWifiOffReq *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiOffReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_WIFI_OFF_REQ, dst__, src__);
+
+#define CsrWifiSmeWifiOffReqSendTo(dst__, src__) \
+    { \
+        CsrWifiSmeWifiOffReq *msg__; \
+        CsrWifiSmeWifiOffReqCreate(msg__, dst__, src__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeWifiOffReqSend(src__) \
+    CsrWifiSmeWifiOffReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOffIndSend
+
+  DESCRIPTION
+    The SME sends this primitive to all the tasks that have registered to
+    receive it to report that the chip has been turned off.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    reason - Indicates the reason why the Wi-Fi has been switched off.
+
+*******************************************************************************/
+#define CsrWifiSmeWifiOffIndCreate(msg__, dst__, src__, reason__) \
+    msg__ = (CsrWifiSmeWifiOffInd *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiOffInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_WIFI_OFF_IND, dst__, src__); \
+    msg__->reason = (reason__);
+
+#define CsrWifiSmeWifiOffIndSendTo(dst__, src__, reason__) \
+    { \
+        CsrWifiSmeWifiOffInd *msg__; \
+        CsrWifiSmeWifiOffIndCreate(msg__, dst__, src__, reason__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeWifiOffIndSend(dst__, reason__) \
+    CsrWifiSmeWifiOffIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, reason__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOffCfmSend
+
+  DESCRIPTION
+    After receiving CSR_WIFI_SME_WIFI_OFF_REQ, if the chip is connected to a
+    network, the SME will perform a disconnect operation, will send a
+    CSR_WIFI_SME_MEDIA_STATUS_IND with
+    CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED, and then will call
+    CSR_WIFI_SME_WIFI_OFF_CFM when the chip is off.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeWifiOffCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeWifiOffCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiOffCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_WIFI_OFF_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeWifiOffCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeWifiOffCfm *msg__; \
+        CsrWifiSmeWifiOffCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeWifiOffCfmSend(dst__, status__) \
+    CsrWifiSmeWifiOffCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOnReqSend
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to turn on the
+    Wi-Fi chip.
+    If the Wi-Fi chip is currently off, the SME turns the Wi-Fi chip on,
+    downloads the patch file (if any), and programs the initial MIB settings
+    (if supplied by the WMA).
+    The patch file is not provided with the SME API; its downloading is
+    automatic and handled internally by the system.
+    The MIB settings, when provided, override the default values that the
+    firmware loads from EEPROM.
+    If the Wi-Fi chip is already on, the SME takes no action and returns a
+    successful status in the confirm.
+
+  PARAMETERS
+    queue         - Message Source Task Queue (Cfm's will be sent to this Queue)
+    address       - Optionally specifies a station MAC address.
+                    In normal use, the manager should set the address to 0xFF
+                    0xFF 0xFF 0xFF 0xFF 0xFF, which will cause the chip to use
+                    the MAC address in the MIB
+    mibFilesCount - Number of provided data blocks with initial MIB values
+    mibFiles      - Points to the first data block with initial MIB values.
+                    These data blocks are typically the contents of the provided
+                    files ufmib.dat and localmib.dat, available from the host
+                    file system, if they exist.
+                    These files typically contain radio tuning and calibration
+                    values.
+                    More values can be created using the Host Tools.
+
+*******************************************************************************/
+#define CsrWifiSmeWifiOnReqCreate(msg__, dst__, src__, address__, mibFilesCount__, mibFiles__) \
+    msg__ = (CsrWifiSmeWifiOnReq *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiOnReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_WIFI_ON_REQ, dst__, src__); \
+    msg__->address = (address__); \
+    msg__->mibFilesCount = (mibFilesCount__); \
+    msg__->mibFiles = (mibFiles__);
+
+#define CsrWifiSmeWifiOnReqSendTo(dst__, src__, address__, mibFilesCount__, mibFiles__) \
+    { \
+        CsrWifiSmeWifiOnReq *msg__; \
+        CsrWifiSmeWifiOnReqCreate(msg__, dst__, src__, address__, mibFilesCount__, mibFiles__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeWifiOnReqSend(src__, address__, mibFilesCount__, mibFiles__) \
+    CsrWifiSmeWifiOnReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, address__, mibFilesCount__, mibFiles__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOnIndSend
+
+  DESCRIPTION
+    The SME sends this primitive to all tasks that have registered to receive
+    it once the chip becomes available and ready to use.
+
+  PARAMETERS
+    queue   - Destination Task Queue
+    address - Current MAC address
+
+*******************************************************************************/
+#define CsrWifiSmeWifiOnIndCreate(msg__, dst__, src__, address__) \
+    msg__ = (CsrWifiSmeWifiOnInd *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiOnInd)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_WIFI_ON_IND, dst__, src__); \
+    msg__->address = (address__);
+
+#define CsrWifiSmeWifiOnIndSendTo(dst__, src__, address__) \
+    { \
+        CsrWifiSmeWifiOnInd *msg__; \
+        CsrWifiSmeWifiOnIndCreate(msg__, dst__, src__, address__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeWifiOnIndSend(dst__, address__) \
+    CsrWifiSmeWifiOnIndSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, address__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOnCfmSend
+
+  DESCRIPTION
+    The SME sends this primitive to the task that has sent the request once
+    the chip has been initialised and is available for use.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Reports the result of the request
+
+*******************************************************************************/
+#define CsrWifiSmeWifiOnCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeWifiOnCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiOnCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_WIFI_ON_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeWifiOnCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeWifiOnCfm *msg__; \
+        CsrWifiSmeWifiOnCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeWifiOnCfmSend(dst__, status__) \
+    CsrWifiSmeWifiOnCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsConfigurationReqSend
+
+  DESCRIPTION
+    This primitive passes the WPS information for the device to SME. This may
+    be accepted only if no interface is active.
+
+  PARAMETERS
+    queue     - Message Source Task Queue (Cfm's will be sent to this Queue)
+    wpsConfig - WPS config.
+
+*******************************************************************************/
+#define CsrWifiSmeWpsConfigurationReqCreate(msg__, dst__, src__, wpsConfig__) \
+    msg__ = (CsrWifiSmeWpsConfigurationReq *) CsrPmemAlloc(sizeof(CsrWifiSmeWpsConfigurationReq)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_WPS_CONFIGURATION_REQ, dst__, src__); \
+    msg__->wpsConfig = (wpsConfig__);
+
+#define CsrWifiSmeWpsConfigurationReqSendTo(dst__, src__, wpsConfig__) \
+    { \
+        CsrWifiSmeWpsConfigurationReq *msg__; \
+        CsrWifiSmeWpsConfigurationReqCreate(msg__, dst__, src__, wpsConfig__); \
+        CsrMsgTransport(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeWpsConfigurationReqSend(src__, wpsConfig__) \
+    CsrWifiSmeWpsConfigurationReqSendTo(CSR_WIFI_SME_LIB_DESTINATION_QUEUE, src__, wpsConfig__)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsConfigurationCfmSend
+
+  DESCRIPTION
+    Confirm.
+
+  PARAMETERS
+    queue  - Destination Task Queue
+    status - Status of the request.
+
+*******************************************************************************/
+#define CsrWifiSmeWpsConfigurationCfmCreate(msg__, dst__, src__, status__) \
+    msg__ = (CsrWifiSmeWpsConfigurationCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeWpsConfigurationCfm)); \
+    CsrWifiFsmEventInit(&msg__->common, CSR_WIFI_SME_PRIM, CSR_WIFI_SME_WPS_CONFIGURATION_CFM, dst__, src__); \
+    msg__->status = (status__);
+
+#define CsrWifiSmeWpsConfigurationCfmSendTo(dst__, src__, status__) \
+    { \
+        CsrWifiSmeWpsConfigurationCfm *msg__; \
+        CsrWifiSmeWpsConfigurationCfmCreate(msg__, dst__, src__, status__); \
+        CsrSchedMessagePut(dst__, CSR_WIFI_SME_PRIM, msg__); \
+    }
+
+#define CsrWifiSmeWpsConfigurationCfmSend(dst__, status__) \
+    CsrWifiSmeWpsConfigurationCfmSendTo(dst__, CSR_WIFI_SME_IFACEQUEUE, status__)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_SME_LIB_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_prim.h
@@ -0,0 +1,6494 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_SME_PRIM_H__
+#define CSR_WIFI_SME_PRIM_H__
+
+#include "csr_types.h"
+#include "csr_prim_defs.h"
+#include "csr_sched.h"
+#include "csr_wifi_common.h"
+#include "csr_result.h"
+#include "csr_wifi_fsm_event.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CSR_WIFI_SME_PRIM                                               (0x0404)
+
+typedef CsrPrim CsrWifiSmePrim;
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSme80211NetworkType
+
+  DESCRIPTION
+    Indicates the physical layer of the network
+
+ VALUES
+    CSR_WIFI_SME_80211_NETWORK_TYPE_DS
+                   - Direct-sequence spread spectrum
+    CSR_WIFI_SME_80211_NETWORK_TYPE_OFDM24
+                   - Orthogonal Frequency Division Multiplexing at 2.4 GHz
+    CSR_WIFI_SME_80211_NETWORK_TYPE_OFDM5
+                   - Orthogonal Frequency Division Multiplexing at 5 GHz
+    CSR_WIFI_SME_80211_NETWORK_TYPE_AUTO
+                   - Automatic
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSme80211NetworkType;
+#define CSR_WIFI_SME_80211_NETWORK_TYPE_DS       ((CsrWifiSme80211NetworkType) 0x00)
+#define CSR_WIFI_SME_80211_NETWORK_TYPE_OFDM24   ((CsrWifiSme80211NetworkType) 0x01)
+#define CSR_WIFI_SME_80211_NETWORK_TYPE_OFDM5    ((CsrWifiSme80211NetworkType) 0x02)
+#define CSR_WIFI_SME_80211_NETWORK_TYPE_AUTO     ((CsrWifiSme80211NetworkType) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSme80211PrivacyMode
+
+  DESCRIPTION
+    Bits to enable or disable the privacy mode
+
+ VALUES
+    CSR_WIFI_SME_80211_PRIVACY_MODE_DISABLED
+                   - Privacy mode is enabled: use of WEP for confidentiality is
+                     required.
+    CSR_WIFI_SME_80211_PRIVACY_MODE_ENABLED
+                   - Privacy mode is disabled
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSme80211PrivacyMode;
+#define CSR_WIFI_SME_80211_PRIVACY_MODE_DISABLED   ((CsrWifiSme80211PrivacyMode) 0x00)
+#define CSR_WIFI_SME_80211_PRIVACY_MODE_ENABLED    ((CsrWifiSme80211PrivacyMode) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSme80211dTrustLevel
+
+  DESCRIPTION
+    Level of trust for the information coming from the network
+
+ VALUES
+    CSR_WIFI_SME_80211D_TRUST_LEVEL_STRICT
+                   - Start with passive scanning and only accept country IE for
+                     updating channel lists
+    CSR_WIFI_SME_80211D_TRUST_LEVEL_ADJUNCT
+                   - As above plus accept adjunct technology location
+                     information
+    CSR_WIFI_SME_80211D_TRUST_LEVEL_BSS
+                   - As above accept plus receiving channel from infrastructure
+                     networks
+    CSR_WIFI_SME_80211D_TRUST_LEVEL_IBSS
+                   - As above accept plus receiving channel from the ad hoc
+                     networks
+    CSR_WIFI_SME_80211D_TRUST_LEVEL_MIB
+                   - Start with active scanning with list of active channels
+                     from the MIB and accept as above
+    CSR_WIFI_SME_80211D_TRUST_LEVEL_DISABLED
+                   - Start with active scanning with list of active channels
+                     from the MIB and ignore any channel information from the
+                     network
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSme80211dTrustLevel;
+#define CSR_WIFI_SME_80211D_TRUST_LEVEL_STRICT     ((CsrWifiSme80211dTrustLevel) 0x01)
+#define CSR_WIFI_SME_80211D_TRUST_LEVEL_ADJUNCT    ((CsrWifiSme80211dTrustLevel) 0x02)
+#define CSR_WIFI_SME_80211D_TRUST_LEVEL_BSS        ((CsrWifiSme80211dTrustLevel) 0x03)
+#define CSR_WIFI_SME_80211D_TRUST_LEVEL_IBSS       ((CsrWifiSme80211dTrustLevel) 0x04)
+#define CSR_WIFI_SME_80211D_TRUST_LEVEL_MIB        ((CsrWifiSme80211dTrustLevel) 0x05)
+#define CSR_WIFI_SME_80211D_TRUST_LEVEL_DISABLED   ((CsrWifiSme80211dTrustLevel) 0x06)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAmpStatus
+
+  DESCRIPTION
+    AMP Current Status
+
+ VALUES
+    CSR_WIFI_SME_AMP_ACTIVE   - AMP ACTIVE.
+    CSR_WIFI_SME_AMP_INACTIVE - AMP INACTIVE
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeAmpStatus;
+#define CSR_WIFI_SME_AMP_ACTIVE     ((CsrWifiSmeAmpStatus) 0x00)
+#define CSR_WIFI_SME_AMP_INACTIVE   ((CsrWifiSmeAmpStatus) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAuthMode
+
+  DESCRIPTION
+    Define bits for CsrWifiSmeAuthMode
+
+ VALUES
+    CSR_WIFI_SME_AUTH_MODE_80211_OPEN
+                   - Connects to an open system network (i.e. no authentication,
+                     no encryption) or to a WEP enabled network.
+    CSR_WIFI_SME_AUTH_MODE_80211_SHARED
+                   - Connect to a WEP enabled network.
+    CSR_WIFI_SME_AUTH_MODE_8021X_WPA
+                   - Connects to a WPA Enterprise enabled network.
+    CSR_WIFI_SME_AUTH_MODE_8021X_WPAPSK
+                   - Connects to a WPA with Pre-Shared Key enabled network.
+    CSR_WIFI_SME_AUTH_MODE_8021X_WPA2
+                   - Connects to a WPA2 Enterprise enabled network.
+    CSR_WIFI_SME_AUTH_MODE_8021X_WPA2PSK
+                   - Connects to a WPA2 with Pre-Shared Key enabled network.
+    CSR_WIFI_SME_AUTH_MODE_8021X_CCKM
+                   - Connects to a CCKM enabled network.
+    CSR_WIFI_SME_AUTH_MODE_WAPI_WAI
+                   - Connects to a WAPI Enterprise enabled network.
+    CSR_WIFI_SME_AUTH_MODE_WAPI_WAIPSK
+                   - Connects to a WAPI with Pre-Shared Key enabled network.
+    CSR_WIFI_SME_AUTH_MODE_8021X_OTHER1X
+                   - For future use.
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeAuthMode;
+#define CSR_WIFI_SME_AUTH_MODE_80211_OPEN      ((CsrWifiSmeAuthMode) 0x0001)
+#define CSR_WIFI_SME_AUTH_MODE_80211_SHARED    ((CsrWifiSmeAuthMode) 0x0002)
+#define CSR_WIFI_SME_AUTH_MODE_8021X_WPA       ((CsrWifiSmeAuthMode) 0x0004)
+#define CSR_WIFI_SME_AUTH_MODE_8021X_WPAPSK    ((CsrWifiSmeAuthMode) 0x0008)
+#define CSR_WIFI_SME_AUTH_MODE_8021X_WPA2      ((CsrWifiSmeAuthMode) 0x0010)
+#define CSR_WIFI_SME_AUTH_MODE_8021X_WPA2PSK   ((CsrWifiSmeAuthMode) 0x0020)
+#define CSR_WIFI_SME_AUTH_MODE_8021X_CCKM      ((CsrWifiSmeAuthMode) 0x0040)
+#define CSR_WIFI_SME_AUTH_MODE_WAPI_WAI        ((CsrWifiSmeAuthMode) 0x0080)
+#define CSR_WIFI_SME_AUTH_MODE_WAPI_WAIPSK     ((CsrWifiSmeAuthMode) 0x0100)
+#define CSR_WIFI_SME_AUTH_MODE_8021X_OTHER1X   ((CsrWifiSmeAuthMode) 0x0200)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeBasicUsability
+
+  DESCRIPTION
+    Indicates the usability level of a channel
+
+ VALUES
+    CSR_WIFI_SME_BASIC_USABILITY_UNUSABLE
+                   - Not usable; connection not recommended
+    CSR_WIFI_SME_BASIC_USABILITY_POOR
+                   - Poor quality; connect only if nothing better is available
+    CSR_WIFI_SME_BASIC_USABILITY_SATISFACTORY
+                   - Quality is satisfactory
+    CSR_WIFI_SME_BASIC_USABILITY_NOT_CONNECTED
+                   - Not connected
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeBasicUsability;
+#define CSR_WIFI_SME_BASIC_USABILITY_UNUSABLE        ((CsrWifiSmeBasicUsability) 0x00)
+#define CSR_WIFI_SME_BASIC_USABILITY_POOR            ((CsrWifiSmeBasicUsability) 0x01)
+#define CSR_WIFI_SME_BASIC_USABILITY_SATISFACTORY    ((CsrWifiSmeBasicUsability) 0x02)
+#define CSR_WIFI_SME_BASIC_USABILITY_NOT_CONNECTED   ((CsrWifiSmeBasicUsability) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeBssType
+
+  DESCRIPTION
+    Indicates the BSS type
+
+ VALUES
+    CSR_WIFI_SME_BSS_TYPE_INFRASTRUCTURE
+                   - Infrastructure BSS.
+    CSR_WIFI_SME_BSS_TYPE_ADHOC
+                   - Ad hoc or Independent BSS.
+    CSR_WIFI_SME_BSS_TYPE_ANY_BSS
+                   - Specifies any type of BSS
+    CSR_WIFI_SME_BSS_TYPE_P2P
+                   - Specifies P2P
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeBssType;
+#define CSR_WIFI_SME_BSS_TYPE_INFRASTRUCTURE   ((CsrWifiSmeBssType) 0x00)
+#define CSR_WIFI_SME_BSS_TYPE_ADHOC            ((CsrWifiSmeBssType) 0x01)
+#define CSR_WIFI_SME_BSS_TYPE_ANY_BSS          ((CsrWifiSmeBssType) 0x02)
+#define CSR_WIFI_SME_BSS_TYPE_P2P              ((CsrWifiSmeBssType) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexScheme
+
+  DESCRIPTION
+    Options for the coexistence signalling
+    Same as MibValues
+
+ VALUES
+    CSR_WIFI_SME_COEX_SCHEME_DISABLED
+                   - The coexistence signalling is disabled
+    CSR_WIFI_SME_COEX_SCHEME_CSR
+                   - Basic CSR coexistence signalling
+    CSR_WIFI_SME_COEX_SCHEME_CSR_CHANNEL
+                   - Full CSR coexistence signalling
+    CSR_WIFI_SME_COEX_SCHEME_PTA
+                   - Packet Traffic Arbitrator coexistence signalling
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeCoexScheme;
+#define CSR_WIFI_SME_COEX_SCHEME_DISABLED      ((CsrWifiSmeCoexScheme) 0x00)
+#define CSR_WIFI_SME_COEX_SCHEME_CSR           ((CsrWifiSmeCoexScheme) 0x01)
+#define CSR_WIFI_SME_COEX_SCHEME_CSR_CHANNEL   ((CsrWifiSmeCoexScheme) 0x02)
+#define CSR_WIFI_SME_COEX_SCHEME_PTA           ((CsrWifiSmeCoexScheme) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeControlIndication
+
+  DESCRIPTION
+    Indicates the reason why the Wi-Fi has been switched off.
+    The values of this type are used across the NME/SME/Router API's and they
+    must be kept consistent with the corresponding types in the .xml of the
+    ottherinterfaces
+
+ VALUES
+    CSR_WIFI_SME_CONTROL_INDICATION_ERROR
+                   - An unrecoverable error (for example, an unrecoverable SDIO
+                     error) has occurred.
+                     The wireless manager application should reinitialise the
+                     chip by calling CSR_WIFI_SME_WIFI_ON_REQ.
+    CSR_WIFI_SME_CONTROL_INDICATION_EXIT
+                   - The chip became unavailable due to an external action, for
+                     example, when a plug-in card is ejected or the driver is
+                     unloaded.
+    CSR_WIFI_SME_CONTROL_INDICATION_USER_REQUESTED
+                   - The Wi-Fi has been switched off as the wireless manager
+                     application has sent CSR_WIFI_SME_WIFI_OFF_REQ
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeControlIndication;
+#define CSR_WIFI_SME_CONTROL_INDICATION_ERROR            ((CsrWifiSmeControlIndication) 0x01)
+#define CSR_WIFI_SME_CONTROL_INDICATION_EXIT             ((CsrWifiSmeControlIndication) 0x02)
+#define CSR_WIFI_SME_CONTROL_INDICATION_USER_REQUESTED   ((CsrWifiSmeControlIndication) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCtsProtectionType
+
+  DESCRIPTION
+    SME CTS Protection Types
+
+ VALUES
+    CSR_WIFI_SME_CTS_PROTECTION_AUTOMATIC
+                   - AP CTS Protection automatic based on non-ERP station in own
+                     BSS or neighbouring BSS on the same channel based on OLBC.
+                     This requires monitoring of beacons from other APs.
+    CSR_WIFI_SME_CTS_PROTECTION_FORCE_ENABLED
+                   - AP CTS Protection Force enabled
+    CSR_WIFI_SME_CTS_PROTECTION_FORCE_DISABLED
+                   - AP CTS Protection Force disabled.
+    CSR_WIFI_SME_CTS_PROTECTION_AUTOMATIC_NO_OLBC
+                   - AP CTS Protection automatic without considering OLBC but
+                     considering non-ERP station in the own BSS Valid only if AP
+                     is configured to work in 802.11bg or 802.11g mode otherwise
+                     this option specifies the same behaviour as AUTOMATIC
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeCtsProtectionType;
+#define CSR_WIFI_SME_CTS_PROTECTION_AUTOMATIC           ((CsrWifiSmeCtsProtectionType) 0x00)
+#define CSR_WIFI_SME_CTS_PROTECTION_FORCE_ENABLED       ((CsrWifiSmeCtsProtectionType) 0x01)
+#define CSR_WIFI_SME_CTS_PROTECTION_FORCE_DISABLED      ((CsrWifiSmeCtsProtectionType) 0x02)
+#define CSR_WIFI_SME_CTS_PROTECTION_AUTOMATIC_NO_OLBC   ((CsrWifiSmeCtsProtectionType) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeD3AutoScanMode
+
+  DESCRIPTION
+    Autonomous scan status while in D3 suspended period
+
+ VALUES
+    CSR_WIFI_SME_D3AUTO_SCAN_MODE_PSON
+                   - Autonomous scan stays on
+    CSR_WIFI_SME_D3AUTO_SCAN_MODE_PSOFF
+                   - Autonomous scan is switched off
+    CSR_WIFI_SME_D3AUTO_SCAN_MODE_PSAUTO
+                   - Automatically select autoscanning behaviour.
+                     CURRENTLY NOT SUPPORTED
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeD3AutoScanMode;
+#define CSR_WIFI_SME_D3AUTO_SCAN_MODE_PSON     ((CsrWifiSmeD3AutoScanMode) 0x00)
+#define CSR_WIFI_SME_D3AUTO_SCAN_MODE_PSOFF    ((CsrWifiSmeD3AutoScanMode) 0x01)
+#define CSR_WIFI_SME_D3AUTO_SCAN_MODE_PSAUTO   ((CsrWifiSmeD3AutoScanMode) 0x02)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeEncryption
+
+  DESCRIPTION
+    Defines bits for CsrWifiSmeEncryption
+    For a WEP enabled network, the caller must specify the correct
+    combination of flags in the encryptionModeMask.
+
+ VALUES
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_NONE
+                   - No encryption set
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_WEP40
+                   - Selects 40 byte key WEP for unicast communication
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_WEP104
+                   - Selects 104 byte key WEP for unicast communication
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_TKIP
+                   - Selects TKIP for unicast communication
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_CCMP
+                   - Selects CCMP for unicast communication
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_SMS4
+                   - Selects SMS4 for unicast communication
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP40
+                   - Selects 40 byte key WEP for broadcast messages
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP104
+                   - Selects 104 byte key WEP for broadcast messages
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_TKIP
+                   - Selects a TKIP for broadcast messages
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_CCMP
+                   - Selects CCMP for broadcast messages
+    CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_SMS4
+                   - Selects SMS4 for broadcast messages
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeEncryption;
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_NONE              ((CsrWifiSmeEncryption) 0x0000)
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_WEP40    ((CsrWifiSmeEncryption) 0x0001)
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_WEP104   ((CsrWifiSmeEncryption) 0x0002)
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_TKIP     ((CsrWifiSmeEncryption) 0x0004)
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_CCMP     ((CsrWifiSmeEncryption) 0x0008)
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_SMS4     ((CsrWifiSmeEncryption) 0x0010)
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP40       ((CsrWifiSmeEncryption) 0x0020)
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP104      ((CsrWifiSmeEncryption) 0x0040)
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_TKIP        ((CsrWifiSmeEncryption) 0x0080)
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_CCMP        ((CsrWifiSmeEncryption) 0x0100)
+#define CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_SMS4        ((CsrWifiSmeEncryption) 0x0200)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeFirmwareDriverInterface
+
+  DESCRIPTION
+    Type of communication between Host and Firmware
+
+ VALUES
+    CSR_WIFI_SME_FIRMWARE_DRIVER_INTERFACE_UNIT_DATA_INTERFACE
+                   - No preformated header. NOT SUPPORTED in the current release
+    CSR_WIFI_SME_FIRMWARE_DRIVER_INTERFACE_PACKET_INTERFACE
+                   - Preformated IEEE 802.11 header for user plane
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeFirmwareDriverInterface;
+#define CSR_WIFI_SME_FIRMWARE_DRIVER_INTERFACE_UNIT_DATA_INTERFACE   ((CsrWifiSmeFirmwareDriverInterface) 0x00)
+#define CSR_WIFI_SME_FIRMWARE_DRIVER_INTERFACE_PACKET_INTERFACE      ((CsrWifiSmeFirmwareDriverInterface) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeHostPowerMode
+
+  DESCRIPTION
+    Defines the power mode
+
+ VALUES
+    CSR_WIFI_SME_HOST_POWER_MODE_ACTIVE
+                   - Host device is running on external power.
+    CSR_WIFI_SME_HOST_POWER_MODE_POWER_SAVE
+                   - Host device is running on (internal) battery power.
+    CSR_WIFI_SME_HOST_POWER_MODE_FULL_POWER_SAVE
+                   - For future use.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeHostPowerMode;
+#define CSR_WIFI_SME_HOST_POWER_MODE_ACTIVE            ((CsrWifiSmeHostPowerMode) 0x00)
+#define CSR_WIFI_SME_HOST_POWER_MODE_POWER_SAVE        ((CsrWifiSmeHostPowerMode) 0x01)
+#define CSR_WIFI_SME_HOST_POWER_MODE_FULL_POWER_SAVE   ((CsrWifiSmeHostPowerMode) 0x02)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeIEEE80211Reason
+
+  DESCRIPTION
+    As definined in the IEEE 802.11 standards
+
+ VALUES
+    CSR_WIFI_SME_IEEE80211_REASON_SUCCESS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_UNSPECIFIED_REASON
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_AUTHENTICATION_NOT_VALID
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_DEAUTHENTICATED_LEAVE_BSS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_DISASSOCIATED_INACTIVITY
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_AP_OVERLOAD
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_CLASS_2FRAME_ERROR
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_CLASS_3FRAME_ERROR
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_DISASSOCIATED_LEAVE_BSS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_ASSOCIATION_NOT_AUTHENTICATED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_DISASSOCIATED_POWER_CAPABILITY
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_DISASSOCIATED_SUPPORTED_CHANNELS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_INVALID_INFORMATION_ELEMENT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_MICHAEL_MIC_FAILURE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_FOURWAY_HANDSHAKE_TIMEOUT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_GROUP_KEY_UPDATE_TIMEOUT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_HANDSHAKE_ELEMENT_DIFFERENT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_INVALID_GROUP_CIPHER
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_INVALID_PAIRWISE_CIPHER
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_INVALID_AKMP
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_UNSUPPORTED_RSN_IEVERSION
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_INVALID_RSN_IECAPABILITIES
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_DOT1X_AUTH_FAILED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_CIPHER_REJECTED_BY_POLICY
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_SERVICE_CHANGE_PRECLUDES_TS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_QOS_UNSPECIFIED_REASON
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_QOS_INSUFFICIENT_BANDWIDTH
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_QOS_EXCESSIVE_NOT_ACK
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_QOS_TXOPLIMIT_EXCEEDED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_QSTA_LEAVING
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_END_TS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_END_DLS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_END_BA
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_UNKNOWN_TS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_UNKNOWN_BA
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_UNKNOWN_DLS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_TIMEOUT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_STAKEY_MISMATCH
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_UNICAST_KEY_NEGOTIATION_TIMEOUT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_MULTICAST_KEY_ANNOUNCEMENT_TIMEOUT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_INCOMPATIBLE_UNICAST_KEY_NEGOTIATION_IE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_INVALID_MULTICAST_CIPHER
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_INVALID_UNICAST_CIPHER
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_UNSUPPORTED_WAPI_IE_VERSION
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_INVALID_WAPI_CAPABILITY_IE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_REASON_WAI_CERTIFICATE_AUTHENTICATION_FAILED
+                   - See IEEE 802.11 Standard
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeIEEE80211Reason;
+#define CSR_WIFI_SME_IEEE80211_REASON_SUCCESS                                   ((CsrWifiSmeIEEE80211Reason) 0x0000)
+#define CSR_WIFI_SME_IEEE80211_REASON_UNSPECIFIED_REASON                        ((CsrWifiSmeIEEE80211Reason) 0x0001)
+#define CSR_WIFI_SME_IEEE80211_REASON_AUTHENTICATION_NOT_VALID                  ((CsrWifiSmeIEEE80211Reason) 0x0002)
+#define CSR_WIFI_SME_IEEE80211_REASON_DEAUTHENTICATED_LEAVE_BSS                 ((CsrWifiSmeIEEE80211Reason) 0x0003)
+#define CSR_WIFI_SME_IEEE80211_REASON_DISASSOCIATED_INACTIVITY                  ((CsrWifiSmeIEEE80211Reason) 0x0004)
+#define CSR_WIFI_SME_IEEE80211_REASON_AP_OVERLOAD                               ((CsrWifiSmeIEEE80211Reason) 0x0005)
+#define CSR_WIFI_SME_IEEE80211_REASON_CLASS_2FRAME_ERROR                        ((CsrWifiSmeIEEE80211Reason) 0x0006)
+#define CSR_WIFI_SME_IEEE80211_REASON_CLASS_3FRAME_ERROR                        ((CsrWifiSmeIEEE80211Reason) 0x0007)
+#define CSR_WIFI_SME_IEEE80211_REASON_DISASSOCIATED_LEAVE_BSS                   ((CsrWifiSmeIEEE80211Reason) 0x0008)
+#define CSR_WIFI_SME_IEEE80211_REASON_ASSOCIATION_NOT_AUTHENTICATED             ((CsrWifiSmeIEEE80211Reason) 0x0009)
+#define CSR_WIFI_SME_IEEE80211_REASON_DISASSOCIATED_POWER_CAPABILITY            ((CsrWifiSmeIEEE80211Reason) 0x000a)
+#define CSR_WIFI_SME_IEEE80211_REASON_DISASSOCIATED_SUPPORTED_CHANNELS          ((CsrWifiSmeIEEE80211Reason) 0x000b)
+#define CSR_WIFI_SME_IEEE80211_REASON_INVALID_INFORMATION_ELEMENT               ((CsrWifiSmeIEEE80211Reason) 0x000d)
+#define CSR_WIFI_SME_IEEE80211_REASON_MICHAEL_MIC_FAILURE                       ((CsrWifiSmeIEEE80211Reason) 0x000e)
+#define CSR_WIFI_SME_IEEE80211_REASON_FOURWAY_HANDSHAKE_TIMEOUT                 ((CsrWifiSmeIEEE80211Reason) 0x000f)
+#define CSR_WIFI_SME_IEEE80211_REASON_GROUP_KEY_UPDATE_TIMEOUT                  ((CsrWifiSmeIEEE80211Reason) 0x0010)
+#define CSR_WIFI_SME_IEEE80211_REASON_HANDSHAKE_ELEMENT_DIFFERENT               ((CsrWifiSmeIEEE80211Reason) 0x0011)
+#define CSR_WIFI_SME_IEEE80211_REASON_INVALID_GROUP_CIPHER                      ((CsrWifiSmeIEEE80211Reason) 0x0012)
+#define CSR_WIFI_SME_IEEE80211_REASON_INVALID_PAIRWISE_CIPHER                   ((CsrWifiSmeIEEE80211Reason) 0x0013)
+#define CSR_WIFI_SME_IEEE80211_REASON_INVALID_AKMP                              ((CsrWifiSmeIEEE80211Reason) 0x0014)
+#define CSR_WIFI_SME_IEEE80211_REASON_UNSUPPORTED_RSN_IEVERSION                 ((CsrWifiSmeIEEE80211Reason) 0x0015)
+#define CSR_WIFI_SME_IEEE80211_REASON_INVALID_RSN_IECAPABILITIES                ((CsrWifiSmeIEEE80211Reason) 0x0016)
+#define CSR_WIFI_SME_IEEE80211_REASON_DOT1X_AUTH_FAILED                         ((CsrWifiSmeIEEE80211Reason) 0x0017)
+#define CSR_WIFI_SME_IEEE80211_REASON_CIPHER_REJECTED_BY_POLICY                 ((CsrWifiSmeIEEE80211Reason) 0x0018)
+#define CSR_WIFI_SME_IEEE80211_REASON_SERVICE_CHANGE_PRECLUDES_TS               ((CsrWifiSmeIEEE80211Reason) 0x001F)
+#define CSR_WIFI_SME_IEEE80211_REASON_QOS_UNSPECIFIED_REASON                    ((CsrWifiSmeIEEE80211Reason) 0x0020)
+#define CSR_WIFI_SME_IEEE80211_REASON_QOS_INSUFFICIENT_BANDWIDTH                ((CsrWifiSmeIEEE80211Reason) 0x0021)
+#define CSR_WIFI_SME_IEEE80211_REASON_QOS_EXCESSIVE_NOT_ACK                     ((CsrWifiSmeIEEE80211Reason) 0x0022)
+#define CSR_WIFI_SME_IEEE80211_REASON_QOS_TXOPLIMIT_EXCEEDED                    ((CsrWifiSmeIEEE80211Reason) 0x0023)
+#define CSR_WIFI_SME_IEEE80211_REASON_QSTA_LEAVING                              ((CsrWifiSmeIEEE80211Reason) 0x0024)
+#define CSR_WIFI_SME_IEEE80211_REASON_END_TS                                    ((CsrWifiSmeIEEE80211Reason) 0x0025)
+#define CSR_WIFI_SME_IEEE80211_REASON_END_DLS                                   ((CsrWifiSmeIEEE80211Reason) 0x0025)
+#define CSR_WIFI_SME_IEEE80211_REASON_END_BA                                    ((CsrWifiSmeIEEE80211Reason) 0x0025)
+#define CSR_WIFI_SME_IEEE80211_REASON_UNKNOWN_TS                                ((CsrWifiSmeIEEE80211Reason) 0x0026)
+#define CSR_WIFI_SME_IEEE80211_REASON_UNKNOWN_BA                                ((CsrWifiSmeIEEE80211Reason) 0x0026)
+#define CSR_WIFI_SME_IEEE80211_REASON_UNKNOWN_DLS                               ((CsrWifiSmeIEEE80211Reason) 0x0026)
+#define CSR_WIFI_SME_IEEE80211_REASON_TIMEOUT                                   ((CsrWifiSmeIEEE80211Reason) 0x0027)
+#define CSR_WIFI_SME_IEEE80211_REASON_STAKEY_MISMATCH                           ((CsrWifiSmeIEEE80211Reason) 0x002d)
+#define CSR_WIFI_SME_IEEE80211_REASON_UNICAST_KEY_NEGOTIATION_TIMEOUT           ((CsrWifiSmeIEEE80211Reason) 0xf019)
+#define CSR_WIFI_SME_IEEE80211_REASON_MULTICAST_KEY_ANNOUNCEMENT_TIMEOUT        ((CsrWifiSmeIEEE80211Reason) 0xf01a)
+#define CSR_WIFI_SME_IEEE80211_REASON_INCOMPATIBLE_UNICAST_KEY_NEGOTIATION_IE   ((CsrWifiSmeIEEE80211Reason) 0xf01b)
+#define CSR_WIFI_SME_IEEE80211_REASON_INVALID_MULTICAST_CIPHER                  ((CsrWifiSmeIEEE80211Reason) 0xf01c)
+#define CSR_WIFI_SME_IEEE80211_REASON_INVALID_UNICAST_CIPHER                    ((CsrWifiSmeIEEE80211Reason) 0xf01d)
+#define CSR_WIFI_SME_IEEE80211_REASON_UNSUPPORTED_WAPI_IE_VERSION               ((CsrWifiSmeIEEE80211Reason) 0xf01e)
+#define CSR_WIFI_SME_IEEE80211_REASON_INVALID_WAPI_CAPABILITY_IE                ((CsrWifiSmeIEEE80211Reason) 0xf01f)
+#define CSR_WIFI_SME_IEEE80211_REASON_WAI_CERTIFICATE_AUTHENTICATION_FAILED     ((CsrWifiSmeIEEE80211Reason) 0xf020)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeIEEE80211Result
+
+  DESCRIPTION
+    As definined in the IEEE 802.11 standards
+
+ VALUES
+    CSR_WIFI_SME_IEEE80211_RESULT_SUCCESS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_UNSPECIFIED_FAILURE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_CAPABILITIES_MISMATCH
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REASSOCIATION_DENIED_NO_ASSOCIATION
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_EXTERNAL_REASON
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_AUTHENTICATION_MISMATCH
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_INVALID_AUTHENTICATION_SEQUENCE_NUMBER
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_CHALLENGE_FAILURE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_AUTHENTICATION_TIMEOUT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_AP_OUT_OF_MEMORY
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_BASIC_RATES_MISMATCH
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_SHORT_PREAMBLE_REQUIRED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_PBCC_MODULATION_REQUIRED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_CHANNEL_AGILITY_REQUIRED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_SPECTRUM_MANAGEMENT_REQUIRED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_POWER_CAPABILITY_UNACCEPTABLE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_SUPPORTED_CHANNELS_UNACCEPTABLE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_SHORT_SLOT_REQUIRED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_DSSS_OFDMREQUIRED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_NO_HT_SUPPORT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_R0KH_UNREACHABLE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_PCO_TRANSITION_SUPPORT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_ASSOCIATION_REQUEST_REJECTED_TEMPORARILY
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_ROBUST_MANAGEMENT_FRAME_POLICY_VIOLATION
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_FAILURE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_AP_BANDWIDTH_INSUFFICIENT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_POOR_OPERATING_CHANNEL
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_QOS_REQUIRED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_REASON_UNSPECIFIED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_INVALID_PARAMETERS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_WITH_SUGGESTED_TSPEC_CHANGES
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_INVALID_IE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_INVALID_GROUP_CIPHER
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_INVALID_PAIRWISE_CIPHER
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_INVALID_AKMP
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_UNSUPPORTED_RSN_VERSION
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_INVALID_RSN_CAPABILITY
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_SECURITY_POLICY
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_FOR_DELAY_PERIOD
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_NOT_ALLOWED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_NOT_PRESENT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_NOT_QSTA
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_LISTEN_INTERVAL_TOO_LARGE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_INVALID_FT_ACTION_FRAME_COUNT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_INVALID_PMKID
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_INVALID_MDIE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_INVALID_FTIE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_UNSPECIFIED_QOS_FAILURE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_WRONG_POLICY
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_INSUFFICIENT_BANDWIDTH
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_INVALID_TSPEC_PARAMETERS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_TIMEOUT
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_TOO_MANY_SIMULTANEOUS_REQUESTS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_BSS_ALREADY_STARTED_OR_JOINED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_NOT_SUPPORTED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_TRANSMISSION_FAILURE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_NOT_AUTHENTICATED
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_RESET_REQUIRED_BEFORE_START
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_LM_INFO_UNAVAILABLE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_INVALID_UNICAST_CIPHER
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_INVALID_MULTICAST_CIPHER
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_UNSUPPORTED_WAPI_IE_VERSION
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_IEEE80211_RESULT_INVALID_WAPI_CAPABILITY_IE
+                   - See IEEE 802.11 Standard
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeIEEE80211Result;
+#define CSR_WIFI_SME_IEEE80211_RESULT_SUCCESS                                          ((CsrWifiSmeIEEE80211Result) 0x0000)
+#define CSR_WIFI_SME_IEEE80211_RESULT_UNSPECIFIED_FAILURE                              ((CsrWifiSmeIEEE80211Result) 0x0001)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_CAPABILITIES_MISMATCH                    ((CsrWifiSmeIEEE80211Result) 0x000a)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REASSOCIATION_DENIED_NO_ASSOCIATION              ((CsrWifiSmeIEEE80211Result) 0x000b)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_EXTERNAL_REASON                          ((CsrWifiSmeIEEE80211Result) 0x000c)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_AUTHENTICATION_MISMATCH                  ((CsrWifiSmeIEEE80211Result) 0x000d)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_INVALID_AUTHENTICATION_SEQUENCE_NUMBER   ((CsrWifiSmeIEEE80211Result) 0x000e)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_CHALLENGE_FAILURE                        ((CsrWifiSmeIEEE80211Result) 0x000f)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_AUTHENTICATION_TIMEOUT                   ((CsrWifiSmeIEEE80211Result) 0x0010)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_AP_OUT_OF_MEMORY                         ((CsrWifiSmeIEEE80211Result) 0x0011)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_BASIC_RATES_MISMATCH                     ((CsrWifiSmeIEEE80211Result) 0x0012)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_SHORT_PREAMBLE_REQUIRED                  ((CsrWifiSmeIEEE80211Result) 0x0013)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_PBCC_MODULATION_REQUIRED                 ((CsrWifiSmeIEEE80211Result) 0x0014)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_CHANNEL_AGILITY_REQUIRED                 ((CsrWifiSmeIEEE80211Result) 0x0015)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_SPECTRUM_MANAGEMENT_REQUIRED             ((CsrWifiSmeIEEE80211Result) 0x0016)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_POWER_CAPABILITY_UNACCEPTABLE            ((CsrWifiSmeIEEE80211Result) 0x0017)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_SUPPORTED_CHANNELS_UNACCEPTABLE          ((CsrWifiSmeIEEE80211Result) 0x0018)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_SHORT_SLOT_REQUIRED                      ((CsrWifiSmeIEEE80211Result) 0x0019)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_DSSS_OFDMREQUIRED                        ((CsrWifiSmeIEEE80211Result) 0x001a)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_NO_HT_SUPPORT                            ((CsrWifiSmeIEEE80211Result) 0x001b)
+#define CSR_WIFI_SME_IEEE80211_RESULT_R0KH_UNREACHABLE                                 ((CsrWifiSmeIEEE80211Result) 0x001c)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_PCO_TRANSITION_SUPPORT                   ((CsrWifiSmeIEEE80211Result) 0x001d)
+#define CSR_WIFI_SME_IEEE80211_RESULT_ASSOCIATION_REQUEST_REJECTED_TEMPORARILY         ((CsrWifiSmeIEEE80211Result) 0x001e)
+#define CSR_WIFI_SME_IEEE80211_RESULT_ROBUST_MANAGEMENT_FRAME_POLICY_VIOLATION         ((CsrWifiSmeIEEE80211Result) 0x001f)
+#define CSR_WIFI_SME_IEEE80211_RESULT_FAILURE                                          ((CsrWifiSmeIEEE80211Result) 0x0020)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_AP_BANDWIDTH_INSUFFICIENT                ((CsrWifiSmeIEEE80211Result) 0x0021)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_POOR_OPERATING_CHANNEL                   ((CsrWifiSmeIEEE80211Result) 0x0022)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_QOS_REQUIRED                             ((CsrWifiSmeIEEE80211Result) 0x0023)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_REASON_UNSPECIFIED                       ((CsrWifiSmeIEEE80211Result) 0x0025)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED                                          ((CsrWifiSmeIEEE80211Result) 0x0025)
+#define CSR_WIFI_SME_IEEE80211_RESULT_INVALID_PARAMETERS                               ((CsrWifiSmeIEEE80211Result) 0x0026)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_WITH_SUGGESTED_TSPEC_CHANGES            ((CsrWifiSmeIEEE80211Result) 0x0027)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_INVALID_IE                              ((CsrWifiSmeIEEE80211Result) 0x0028)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_INVALID_GROUP_CIPHER                    ((CsrWifiSmeIEEE80211Result) 0x0029)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_INVALID_PAIRWISE_CIPHER                 ((CsrWifiSmeIEEE80211Result) 0x002a)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_INVALID_AKMP                            ((CsrWifiSmeIEEE80211Result) 0x002b)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_UNSUPPORTED_RSN_VERSION                 ((CsrWifiSmeIEEE80211Result) 0x002c)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_INVALID_RSN_CAPABILITY                  ((CsrWifiSmeIEEE80211Result) 0x002d)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_SECURITY_POLICY                         ((CsrWifiSmeIEEE80211Result) 0x002e)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_FOR_DELAY_PERIOD                        ((CsrWifiSmeIEEE80211Result) 0x002f)
+#define CSR_WIFI_SME_IEEE80211_RESULT_NOT_ALLOWED                                      ((CsrWifiSmeIEEE80211Result) 0x0030)
+#define CSR_WIFI_SME_IEEE80211_RESULT_NOT_PRESENT                                      ((CsrWifiSmeIEEE80211Result) 0x0031)
+#define CSR_WIFI_SME_IEEE80211_RESULT_NOT_QSTA                                         ((CsrWifiSmeIEEE80211Result) 0x0032)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REJECTED_LISTEN_INTERVAL_TOO_LARGE               ((CsrWifiSmeIEEE80211Result) 0x0033)
+#define CSR_WIFI_SME_IEEE80211_RESULT_INVALID_FT_ACTION_FRAME_COUNT                    ((CsrWifiSmeIEEE80211Result) 0x0034)
+#define CSR_WIFI_SME_IEEE80211_RESULT_INVALID_PMKID                                    ((CsrWifiSmeIEEE80211Result) 0x0035)
+#define CSR_WIFI_SME_IEEE80211_RESULT_INVALID_MDIE                                     ((CsrWifiSmeIEEE80211Result) 0x0036)
+#define CSR_WIFI_SME_IEEE80211_RESULT_INVALID_FTIE                                     ((CsrWifiSmeIEEE80211Result) 0x0037)
+#define CSR_WIFI_SME_IEEE80211_RESULT_UNSPECIFIED_QOS_FAILURE                          ((CsrWifiSmeIEEE80211Result) 0x00c8)
+#define CSR_WIFI_SME_IEEE80211_RESULT_WRONG_POLICY                                     ((CsrWifiSmeIEEE80211Result) 0x00c9)
+#define CSR_WIFI_SME_IEEE80211_RESULT_INSUFFICIENT_BANDWIDTH                           ((CsrWifiSmeIEEE80211Result) 0x00ca)
+#define CSR_WIFI_SME_IEEE80211_RESULT_INVALID_TSPEC_PARAMETERS                         ((CsrWifiSmeIEEE80211Result) 0x00cb)
+#define CSR_WIFI_SME_IEEE80211_RESULT_TIMEOUT                                          ((CsrWifiSmeIEEE80211Result) 0x8000)
+#define CSR_WIFI_SME_IEEE80211_RESULT_TOO_MANY_SIMULTANEOUS_REQUESTS                   ((CsrWifiSmeIEEE80211Result) 0x8001)
+#define CSR_WIFI_SME_IEEE80211_RESULT_BSS_ALREADY_STARTED_OR_JOINED                    ((CsrWifiSmeIEEE80211Result) 0x8002)
+#define CSR_WIFI_SME_IEEE80211_RESULT_NOT_SUPPORTED                                    ((CsrWifiSmeIEEE80211Result) 0x8003)
+#define CSR_WIFI_SME_IEEE80211_RESULT_TRANSMISSION_FAILURE                             ((CsrWifiSmeIEEE80211Result) 0x8004)
+#define CSR_WIFI_SME_IEEE80211_RESULT_REFUSED_NOT_AUTHENTICATED                        ((CsrWifiSmeIEEE80211Result) 0x8005)
+#define CSR_WIFI_SME_IEEE80211_RESULT_RESET_REQUIRED_BEFORE_START                      ((CsrWifiSmeIEEE80211Result) 0x8006)
+#define CSR_WIFI_SME_IEEE80211_RESULT_LM_INFO_UNAVAILABLE                              ((CsrWifiSmeIEEE80211Result) 0x8007)
+#define CSR_WIFI_SME_IEEE80211_RESULT_INVALID_UNICAST_CIPHER                           ((CsrWifiSmeIEEE80211Result) 0xf02f)
+#define CSR_WIFI_SME_IEEE80211_RESULT_INVALID_MULTICAST_CIPHER                         ((CsrWifiSmeIEEE80211Result) 0xf030)
+#define CSR_WIFI_SME_IEEE80211_RESULT_UNSUPPORTED_WAPI_IE_VERSION                      ((CsrWifiSmeIEEE80211Result) 0xf031)
+#define CSR_WIFI_SME_IEEE80211_RESULT_INVALID_WAPI_CAPABILITY_IE                       ((CsrWifiSmeIEEE80211Result) 0xf032)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeIndications
+
+  DESCRIPTION
+    Defines bits for CsrWifiSmeIndicationsMask
+
+ VALUES
+    CSR_WIFI_SME_INDICATIONS_NONE
+                   - Used to cancel the registrations for receiving indications
+    CSR_WIFI_SME_INDICATIONS_WIFIOFF
+                   - Used to register for CSR_WIFI_SME_WIFI_OFF_IND events
+    CSR_WIFI_SME_INDICATIONS_SCANRESULT
+                   - Used to register for CSR_WIFI_SME_SCAN_RESULT_IND events
+    CSR_WIFI_SME_INDICATIONS_CONNECTIONQUALITY
+                   - Used to register for CSR_WIFI_SME_CONNECTION_QUALITY_IND
+                     events
+    CSR_WIFI_SME_INDICATIONS_MEDIASTATUS
+                   - Used to register for CSR_WIFI_SME_MEDIA_STATUS_IND events
+    CSR_WIFI_SME_INDICATIONS_MICFAILURE
+                   - Used to register for CSR_WIFI_SME_MICFAILURE_IND events
+    CSR_WIFI_SME_INDICATIONS_PMKIDCANDIDATELIST
+                   - Used to register for CSR_WIFI_SME_PMKIDCANDIDATE_LIST_IND
+                     events
+    CSR_WIFI_SME_INDICATIONS_TSPEC
+                   - Used to register for CSR_WIFI_SME_TSPEC_IND events
+    CSR_WIFI_SME_INDICATIONS_ROAMSTART
+                   - Used to register for CSR_WIFI_SME_ROAM_START_IND events
+    CSR_WIFI_SME_INDICATIONS_ROAMCOMPLETE
+                   - Used to register for CSR_WIFI_SME_ROAM_COMPLETE_IND events
+    CSR_WIFI_SME_INDICATIONS_ASSOCIATIONSTART
+                   - Used to register for CSR_WIFI_SME_ASSOCIATION_START_IND
+                     events
+    CSR_WIFI_SME_INDICATIONS_ASSOCIATIONCOMPLETE
+                   - Used to register for CSR_WIFI_SME_ASSOCIATION_COMPLETE_IND
+                     events
+    CSR_WIFI_SME_INDICATIONS_IBSSSTATION
+                   - Used to register for CSR_WIFI_SME_IBSS_STATION_IND events
+    CSR_WIFI_SME_INDICATIONS_WIFION
+                   - Used to register for CSR_WIFI_SME_WIFI_ON_IND events
+    CSR_WIFI_SME_INDICATIONS_ERROR
+                   - Used to register for CSR_WIFI_SME_ERROR_IND events
+    CSR_WIFI_SME_INDICATIONS_INFO
+                   - Used to register for CSR_WIFI_SME_INFO_IND events
+    CSR_WIFI_SME_INDICATIONS_COREDUMP
+                   - Used to register for CSR_WIFI_SME_CORE_DUMP_IND events
+    CSR_WIFI_SME_INDICATIONS_ALL
+                   - Used to register for all available indications
+
+*******************************************************************************/
+typedef CsrUint32 CsrWifiSmeIndications;
+#define CSR_WIFI_SME_INDICATIONS_NONE                  ((CsrWifiSmeIndications) 0x00000000)
+#define CSR_WIFI_SME_INDICATIONS_WIFIOFF               ((CsrWifiSmeIndications) 0x00000001)
+#define CSR_WIFI_SME_INDICATIONS_SCANRESULT            ((CsrWifiSmeIndications) 0x00000002)
+#define CSR_WIFI_SME_INDICATIONS_CONNECTIONQUALITY     ((CsrWifiSmeIndications) 0x00000004)
+#define CSR_WIFI_SME_INDICATIONS_MEDIASTATUS           ((CsrWifiSmeIndications) 0x00000008)
+#define CSR_WIFI_SME_INDICATIONS_MICFAILURE            ((CsrWifiSmeIndications) 0x00000010)
+#define CSR_WIFI_SME_INDICATIONS_PMKIDCANDIDATELIST    ((CsrWifiSmeIndications) 0x00000020)
+#define CSR_WIFI_SME_INDICATIONS_TSPEC                 ((CsrWifiSmeIndications) 0x00000040)
+#define CSR_WIFI_SME_INDICATIONS_ROAMSTART             ((CsrWifiSmeIndications) 0x00000080)
+#define CSR_WIFI_SME_INDICATIONS_ROAMCOMPLETE          ((CsrWifiSmeIndications) 0x00000100)
+#define CSR_WIFI_SME_INDICATIONS_ASSOCIATIONSTART      ((CsrWifiSmeIndications) 0x00000200)
+#define CSR_WIFI_SME_INDICATIONS_ASSOCIATIONCOMPLETE   ((CsrWifiSmeIndications) 0x00000400)
+#define CSR_WIFI_SME_INDICATIONS_IBSSSTATION           ((CsrWifiSmeIndications) 0x00000800)
+#define CSR_WIFI_SME_INDICATIONS_WIFION                ((CsrWifiSmeIndications) 0x00001000)
+#define CSR_WIFI_SME_INDICATIONS_ERROR                 ((CsrWifiSmeIndications) 0x00002000)
+#define CSR_WIFI_SME_INDICATIONS_INFO                  ((CsrWifiSmeIndications) 0x00004000)
+#define CSR_WIFI_SME_INDICATIONS_COREDUMP              ((CsrWifiSmeIndications) 0x00008000)
+#define CSR_WIFI_SME_INDICATIONS_ALL                   ((CsrWifiSmeIndications) 0xFFFFFFFF)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeKeyType
+
+  DESCRIPTION
+    Indicates the type of the key
+
+ VALUES
+    CSR_WIFI_SME_KEY_TYPE_GROUP    - Key for broadcast communication
+    CSR_WIFI_SME_KEY_TYPE_PAIRWISE - Key for unicast communication
+    CSR_WIFI_SME_KEY_TYPE_STAKEY   - Key for direct link communication to
+                                     another station in infrastructure networks
+    CSR_WIFI_SME_KEY_TYPE_IGTK     - Integrity Group Temporal Key
+    CSR_WIFI_SME_KEY_TYPE_CCKM     - Key for Cisco Centralized Key Management
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeKeyType;
+#define CSR_WIFI_SME_KEY_TYPE_GROUP      ((CsrWifiSmeKeyType) 0x00)
+#define CSR_WIFI_SME_KEY_TYPE_PAIRWISE   ((CsrWifiSmeKeyType) 0x01)
+#define CSR_WIFI_SME_KEY_TYPE_STAKEY     ((CsrWifiSmeKeyType) 0x02)
+#define CSR_WIFI_SME_KEY_TYPE_IGTK       ((CsrWifiSmeKeyType) 0x03)
+#define CSR_WIFI_SME_KEY_TYPE_CCKM       ((CsrWifiSmeKeyType) 0x04)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeListAction
+
+  DESCRIPTION
+    Identifies the type of action to be performed on a list of items
+    The values of this type are used across the NME/SME/Router API's and they
+    must be kept consistent with the corresponding types in the .xml of the
+    ottherinterfaces
+
+ VALUES
+    CSR_WIFI_SME_LIST_ACTION_GET    - Retrieve the current list of items
+    CSR_WIFI_SME_LIST_ACTION_ADD    - Add one or more items
+    CSR_WIFI_SME_LIST_ACTION_REMOVE - Remove one or more items
+    CSR_WIFI_SME_LIST_ACTION_FLUSH  - Remove all items
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeListAction;
+#define CSR_WIFI_SME_LIST_ACTION_GET      ((CsrWifiSmeListAction) 0x00)
+#define CSR_WIFI_SME_LIST_ACTION_ADD      ((CsrWifiSmeListAction) 0x01)
+#define CSR_WIFI_SME_LIST_ACTION_REMOVE   ((CsrWifiSmeListAction) 0x02)
+#define CSR_WIFI_SME_LIST_ACTION_FLUSH    ((CsrWifiSmeListAction) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMediaStatus
+
+  DESCRIPTION
+    Indicates the connection status
+    The values of this type are used across the NME/SME/Router API's and they
+    must be kept consistent with the corresponding types in the .xml of the
+    ottherinterfaces
+
+ VALUES
+    CSR_WIFI_SME_MEDIA_STATUS_CONNECTED
+                   - Value CSR_WIFI_SME_MEDIA_STATUS_CONNECTED can happen in two
+                     situations:
+                       * A network connection is established. Specifically, this is
+                         when the MLME_ASSOCIATION completes or the first peer
+                         relationship is established in an IBSS. In a WPA/WPA2
+                         network, this indicates that the stack is ready to perform
+                         the 4-way handshake or 802.1x authentication if CSR NME
+                         security library is not used. If CSR NME security library
+                         is used this indicates, completion of 4way handshake or
+                         802.1x authentication
+                       * The SME roams to another AP on the same ESS
+                     During the AP operation, it indicates that the peer station
+                     is connected to the AP and is ready for data transfer.
+    CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED
+                   - Value CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED can happen in
+                     two situations:
+                       * when the connection to a network is lost and there is no
+                         alternative on the same ESS to roam to
+                       * when a CSR_WIFI_SME_DISCONNECT_REQ request is issued
+                     During AP or P2PGO operation, it indicates that the peer
+                     station has disconnected from the AP
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeMediaStatus;
+#define CSR_WIFI_SME_MEDIA_STATUS_CONNECTED      ((CsrWifiSmeMediaStatus) 0x00)
+#define CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED   ((CsrWifiSmeMediaStatus) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeP2pCapability
+
+  DESCRIPTION
+    Defines P2P Device Capabilities
+
+ VALUES
+    CSR_WIFI_SME_P2P_SERVICE_DISCOVERY_CAPABILITY
+                   - This field is set to 1 if the P2P Device supports Service
+                     Discovery, and to 0 otherwise
+    CSR_WIFI_SME_P2P_CLIENT_DISCOVERABILITY_CAPABILITY
+                   - This field is set to 1 when the P2P Device supports P2P
+                     Client Discoverability, and to 0 otherwise.
+    CSR_WIFI_SME_P2P_CONCURRENT_OPERATION_CAPABILITY
+                   - This field is set to 1 when the P2P Device supports
+                     Concurrent Operation with WLAN, and to 0 otherwise.
+    CSR_WIFI_SME_P2P_MANAGED_DEVICE_CAPABILITY
+                   - This field is set to 1 when the P2P interface of the P2P
+                     Device is capable of being managed by the WLAN
+                     (infrastructure network) based on P2P coexistence
+                     parameters, and to 0 otherwise
+    CSR_WIFI_SME_P2P_INVITAION_CAPABILITY
+                   - This field is set to 1 if the P2P Device is capable of
+                     processing P2P Invitation Procedure signaling, and to 0
+                     otherwise.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeP2pCapability;
+#define CSR_WIFI_SME_P2P_SERVICE_DISCOVERY_CAPABILITY        ((CsrWifiSmeP2pCapability) 0x01)
+#define CSR_WIFI_SME_P2P_CLIENT_DISCOVERABILITY_CAPABILITY   ((CsrWifiSmeP2pCapability) 0x02)
+#define CSR_WIFI_SME_P2P_CONCURRENT_OPERATION_CAPABILITY     ((CsrWifiSmeP2pCapability) 0x04)
+#define CSR_WIFI_SME_P2P_MANAGED_DEVICE_CAPABILITY           ((CsrWifiSmeP2pCapability) 0x08)
+#define CSR_WIFI_SME_P2P_INVITAION_CAPABILITY                ((CsrWifiSmeP2pCapability) 0x20)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeP2pGroupCapability
+
+  DESCRIPTION
+    Define bits for P2P Group Capability
+
+ VALUES
+    CSR_WIFI_P2P_GRP_CAP_GO
+                   - Indicates if the local device has become a GO after GO
+                     negotiation
+    CSR_WIFI_P2P_GRP_CAP_PERSISTENT
+                   - Persistent group
+    CSR_WIFI_P2P_GRP_CAP_INTRABSS_DIST
+                   - Intra-BSS data distribution support
+    CSR_WIFI_P2P_GRP_CAP_CROSS_CONN
+                   - Support of cross connection
+    CSR_WIFI_P2P_GRP_CAP_PERSISTENT_RECONNECT
+                   - Support of persistent reconnect
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeP2pGroupCapability;
+#define CSR_WIFI_P2P_GRP_CAP_GO                     ((CsrWifiSmeP2pGroupCapability) 0x01)
+#define CSR_WIFI_P2P_GRP_CAP_PERSISTENT             ((CsrWifiSmeP2pGroupCapability) 0x02)
+#define CSR_WIFI_P2P_GRP_CAP_INTRABSS_DIST          ((CsrWifiSmeP2pGroupCapability) 0x08)
+#define CSR_WIFI_P2P_GRP_CAP_CROSS_CONN             ((CsrWifiSmeP2pGroupCapability) 0x10)
+#define CSR_WIFI_P2P_GRP_CAP_PERSISTENT_RECONNECT   ((CsrWifiSmeP2pGroupCapability) 0x20)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeP2pNoaConfigMethod
+
+  DESCRIPTION
+    Notice of Absece Configuration
+
+ VALUES
+    CSR_WIFI_P2P_NOA_NONE         - Do not use NOA
+    CSR_WIFI_P2P_NOA_AUTONOMOUS   - NOA based on the traffic analysis
+    CSR_WIFI_P2P_NOA_USER_DEFINED - NOA as specified by the user
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeP2pNoaConfigMethod;
+#define CSR_WIFI_P2P_NOA_NONE           ((CsrWifiSmeP2pNoaConfigMethod) 0x00)
+#define CSR_WIFI_P2P_NOA_AUTONOMOUS     ((CsrWifiSmeP2pNoaConfigMethod) 0x01)
+#define CSR_WIFI_P2P_NOA_USER_DEFINED   ((CsrWifiSmeP2pNoaConfigMethod) 0x02)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeP2pRole
+
+  DESCRIPTION
+    Definition of roles for a P2P Device
+
+ VALUES
+    CSR_WIFI_SME_P2P_ROLE_NONE       - A non-P2PDevice device
+    CSR_WIFI_SME_P2P_ROLE_STANDALONE - A Standalone P2P device
+    CSR_WIFI_SME_P2P_ROLE_GO         - Role Assumed is that of a Group Owner
+                                       within a P2P Group
+    CSR_WIFI_SME_P2P_ROLE_CLI        - Role Assumed is that of a P2P Client
+                                       within a P2P Group
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeP2pRole;
+#define CSR_WIFI_SME_P2P_ROLE_NONE         ((CsrWifiSmeP2pRole) 0x00)
+#define CSR_WIFI_SME_P2P_ROLE_STANDALONE   ((CsrWifiSmeP2pRole) 0x01)
+#define CSR_WIFI_SME_P2P_ROLE_GO           ((CsrWifiSmeP2pRole) 0x02)
+#define CSR_WIFI_SME_P2P_ROLE_CLI          ((CsrWifiSmeP2pRole) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeP2pStatus
+
+  DESCRIPTION
+    This data type enumerates the outcome of P2P procedure
+
+ VALUES
+    CSR_WIFI_SME_P2P_STATUS_SUCCESS
+                   - Success
+    CSR_WIFI_SME_P2P_STATUS_FAIL_INFO_UNAVAILABLE
+                   - Fail; information is currently unavailable
+    CSR_WIFI_SME_P2P_STATUS_FAIL_INCOMPATIBLE_PARAM
+                   - Fail; incompatible parameters
+    CSR_WIFI_SME_P2P_STATUS_FAIL_LIMIT_REACHED
+                   - Fail; limit reached
+    CSR_WIFI_SME_P2P_STATUS_FAIL_INVALID_PARAM
+                   - Fail; invalid parameters
+    CSR_WIFI_SME_P2P_STATUS_FAIL_ACCOMODATE
+                   - Fail; unable to accommodate request
+    CSR_WIFI_SME_P2P_STATUS_FAIL_PREV_ERROR
+                   - Fail; previous protocol error, or disruptive behavior
+    CSR_WIFI_SME_P2P_STATUS_FAIL_COMMON_CHANNELS
+                   - Fail; no common channels
+    CSR_WIFI_SME_P2P_STATUS_FAIL_UNKNOWN_GROUP
+                   - Fail; unknown P2P Group
+    CSR_WIFI_SME_P2P_STATUS_FAIL_GO_INTENT
+                   - Fail: both P2P Devices indicated an Intent of 15 in Group
+                     Owner Negotiation
+    CSR_WIFI_SME_P2P_STATUS_FAIL_PROVISION_METHOD_INCOMPATIBLE
+                   - Fail; incompatible provisioning method
+    CSR_WIFI_SME_P2P_STATUS_FAIL_REJECT
+                   - Fail: rejected by user
+    CSR_WIFI_SME_P2P_STATUS_FAIL_RESERVED
+                   - Fail; Status Reserved
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeP2pStatus;
+#define CSR_WIFI_SME_P2P_STATUS_SUCCESS                              ((CsrWifiSmeP2pStatus) 0x00)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_INFO_UNAVAILABLE                ((CsrWifiSmeP2pStatus) 0x01)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_INCOMPATIBLE_PARAM              ((CsrWifiSmeP2pStatus) 0x02)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_LIMIT_REACHED                   ((CsrWifiSmeP2pStatus) 0x03)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_INVALID_PARAM                   ((CsrWifiSmeP2pStatus) 0x04)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_ACCOMODATE                      ((CsrWifiSmeP2pStatus) 0x05)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_PREV_ERROR                      ((CsrWifiSmeP2pStatus) 0x06)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_COMMON_CHANNELS                 ((CsrWifiSmeP2pStatus) 0x07)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_UNKNOWN_GROUP                   ((CsrWifiSmeP2pStatus) 0x08)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_GO_INTENT                       ((CsrWifiSmeP2pStatus) 0x09)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_PROVISION_METHOD_INCOMPATIBLE   ((CsrWifiSmeP2pStatus) 0x0A)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_REJECT                          ((CsrWifiSmeP2pStatus) 0x0B)
+#define CSR_WIFI_SME_P2P_STATUS_FAIL_RESERVED                        ((CsrWifiSmeP2pStatus) 0xFF)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePacketFilterMode
+
+  DESCRIPTION
+    Options for the filter mode parameter.
+    The Values here match the HIP interface
+
+ VALUES
+    CSR_WIFI_SME_PACKET_FILTER_MODE_OPT_OUT
+                   - Broadcast packets are always reported to the host unless
+                     they match at least one of the specified TCLAS IEs.
+    CSR_WIFI_SME_PACKET_FILTER_MODE_OPT_IN
+                   - Broadcast packets are reported to the host only if they
+                     match at least one of the specified TCLAS IEs.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmePacketFilterMode;
+#define CSR_WIFI_SME_PACKET_FILTER_MODE_OPT_OUT   ((CsrWifiSmePacketFilterMode) 0x00)
+#define CSR_WIFI_SME_PACKET_FILTER_MODE_OPT_IN    ((CsrWifiSmePacketFilterMode) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePowerSaveLevel
+
+  DESCRIPTION
+    Power Save Level options as defined in the IEEE 802.11 standards
+    First 3 values are set to match the mlme PowerManagementMode
+
+ VALUES
+    CSR_WIFI_SME_POWER_SAVE_LEVEL_LOW  - No power save: the driver will remain
+                                         active at all times
+    CSR_WIFI_SME_POWER_SAVE_LEVEL_HIGH - Enter power save after all packets in
+                                         the queues are transmitted and received
+    CSR_WIFI_SME_POWER_SAVE_LEVEL_MED  - Enter power save after all packets in
+                                         the queues are transmitted and received
+                                         and a further configurable delay
+                                         (default 1s) has elapsed
+    CSR_WIFI_SME_POWER_SAVE_LEVEL_AUTO - The SME will decide when to enter power
+                                         save mode according to the traffic
+                                         analysis
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmePowerSaveLevel;
+#define CSR_WIFI_SME_POWER_SAVE_LEVEL_LOW    ((CsrWifiSmePowerSaveLevel) 0x00)
+#define CSR_WIFI_SME_POWER_SAVE_LEVEL_HIGH   ((CsrWifiSmePowerSaveLevel) 0x01)
+#define CSR_WIFI_SME_POWER_SAVE_LEVEL_MED    ((CsrWifiSmePowerSaveLevel) 0x02)
+#define CSR_WIFI_SME_POWER_SAVE_LEVEL_AUTO   ((CsrWifiSmePowerSaveLevel) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePreambleType
+
+  DESCRIPTION
+    SME Preamble Types
+
+ VALUES
+    CSR_WIFI_SME_USE_LONG_PREAMBLE  - Use legacy (long) preamble
+    CSR_WIFI_SME_USE_SHORT_PREAMBLE - Use short PPDU format
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmePreambleType;
+#define CSR_WIFI_SME_USE_LONG_PREAMBLE    ((CsrWifiSmePreambleType) 0x00)
+#define CSR_WIFI_SME_USE_SHORT_PREAMBLE   ((CsrWifiSmePreambleType) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRadioIF
+
+  DESCRIPTION
+    Indicates the frequency
+
+ VALUES
+    CSR_WIFI_SME_RADIO_IF_GHZ_2_4 - Indicates the 2.4 GHZ frequency
+    CSR_WIFI_SME_RADIO_IF_GHZ_5_0 - Future use: currently not supported
+    CSR_WIFI_SME_RADIO_IF_BOTH    - Future use: currently not supported
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeRadioIF;
+#define CSR_WIFI_SME_RADIO_IF_GHZ_2_4   ((CsrWifiSmeRadioIF) 0x01)
+#define CSR_WIFI_SME_RADIO_IF_GHZ_5_0   ((CsrWifiSmeRadioIF) 0x02)
+#define CSR_WIFI_SME_RADIO_IF_BOTH      ((CsrWifiSmeRadioIF) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRegulatoryDomain
+
+  DESCRIPTION
+    Indicates the regulatory domain as defined in IEEE 802.11 standards
+
+ VALUES
+    CSR_WIFI_SME_REGULATORY_DOMAIN_OTHER
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_REGULATORY_DOMAIN_FCC
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_REGULATORY_DOMAIN_IC
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_REGULATORY_DOMAIN_ETSI
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_REGULATORY_DOMAIN_SPAIN
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_REGULATORY_DOMAIN_FRANCE
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_REGULATORY_DOMAIN_JAPAN
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_REGULATORY_DOMAIN_JAPANBIS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_REGULATORY_DOMAIN_CHINA
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_REGULATORY_DOMAIN_CHINABIS
+                   - See IEEE 802.11 Standard
+    CSR_WIFI_SME_REGULATORY_DOMAIN_NONE
+                   - See IEEE 802.11 Standard
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeRegulatoryDomain;
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_OTHER      ((CsrWifiSmeRegulatoryDomain) 0x00)
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_FCC        ((CsrWifiSmeRegulatoryDomain) 0x10)
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_IC         ((CsrWifiSmeRegulatoryDomain) 0x20)
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_ETSI       ((CsrWifiSmeRegulatoryDomain) 0x30)
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_SPAIN      ((CsrWifiSmeRegulatoryDomain) 0x31)
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_FRANCE     ((CsrWifiSmeRegulatoryDomain) 0x32)
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_JAPAN      ((CsrWifiSmeRegulatoryDomain) 0x40)
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_JAPANBIS   ((CsrWifiSmeRegulatoryDomain) 0x41)
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_CHINA      ((CsrWifiSmeRegulatoryDomain) 0x50)
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_CHINABIS   ((CsrWifiSmeRegulatoryDomain) 0x51)
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_NONE       ((CsrWifiSmeRegulatoryDomain) 0xFF)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamReason
+
+  DESCRIPTION
+    Indicates the reason for roaming
+
+ VALUES
+    CSR_WIFI_SME_ROAM_REASON_BEACONLOST
+                   - The station cannot receive the beacon signal any more
+    CSR_WIFI_SME_ROAM_REASON_DISASSOCIATED
+                   - The station has been disassociated
+    CSR_WIFI_SME_ROAM_REASON_DEAUTHENTICATED
+                   - The station has been deauthenticated
+    CSR_WIFI_SME_ROAM_REASON_BETTERAPFOUND
+                   - A better AP has been found
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeRoamReason;
+#define CSR_WIFI_SME_ROAM_REASON_BEACONLOST        ((CsrWifiSmeRoamReason) 0x00)
+#define CSR_WIFI_SME_ROAM_REASON_DISASSOCIATED     ((CsrWifiSmeRoamReason) 0x01)
+#define CSR_WIFI_SME_ROAM_REASON_DEAUTHENTICATED   ((CsrWifiSmeRoamReason) 0x02)
+#define CSR_WIFI_SME_ROAM_REASON_BETTERAPFOUND     ((CsrWifiSmeRoamReason) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanType
+
+  DESCRIPTION
+    Identifies the type of scan to be performed
+
+ VALUES
+    CSR_WIFI_SME_SCAN_TYPE_ALL     - Scan actively or passively according to the
+                                     regulatory domain restrictions
+    CSR_WIFI_SME_SCAN_TYPE_ACTIVE  - Scan actively only: send probes and listen
+                                     for answers
+    CSR_WIFI_SME_SCAN_TYPE_PASSIVE - Scan passively only: listen for beacon
+                                     messages
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeScanType;
+#define CSR_WIFI_SME_SCAN_TYPE_ALL       ((CsrWifiSmeScanType) 0x00)
+#define CSR_WIFI_SME_SCAN_TYPE_ACTIVE    ((CsrWifiSmeScanType) 0x01)
+#define CSR_WIFI_SME_SCAN_TYPE_PASSIVE   ((CsrWifiSmeScanType) 0x02)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTrafficType
+
+  DESCRIPTION
+    Identifies the type of traffic going on on the connection.
+    The values of this type are used across the NME/SME/Router API's and they
+    must be kept consistent with the corresponding types in the .xml of the
+    ottherinterfaces
+
+ VALUES
+    CSR_WIFI_SME_TRAFFIC_TYPE_OCCASIONAL
+                   - During the last 30 seconds there were fewer than 20 packets
+                     per seconds in each second in both directions
+    CSR_WIFI_SME_TRAFFIC_TYPE_BURSTY
+                   - During the last 30 seconds there was at least one second
+                     during which more than 20 packets were received in either
+                     direction
+    CSR_WIFI_SME_TRAFFIC_TYPE_PERIODIC
+                   - During the last 5 seconds there were at least 10 packets
+                     received each second and a defined period for the traffic
+                     can be recognized
+    CSR_WIFI_SME_TRAFFIC_TYPE_CONTINUOUS
+                   - During the last 5 seconds there were at least 20 packets
+                     received each second in either direction
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeTrafficType;
+#define CSR_WIFI_SME_TRAFFIC_TYPE_OCCASIONAL   ((CsrWifiSmeTrafficType) 0x00)
+#define CSR_WIFI_SME_TRAFFIC_TYPE_BURSTY       ((CsrWifiSmeTrafficType) 0x01)
+#define CSR_WIFI_SME_TRAFFIC_TYPE_PERIODIC     ((CsrWifiSmeTrafficType) 0x02)
+#define CSR_WIFI_SME_TRAFFIC_TYPE_CONTINUOUS   ((CsrWifiSmeTrafficType) 0x03)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTspecCtrl
+
+  DESCRIPTION
+    Defines bits for CsrWifiSmeTspecCtrlMask for additional CCX configuration.
+    CURRENTLY NOT SUPPORTED.
+
+ VALUES
+    CSR_WIFI_SME_TSPEC_CTRL_STRICT
+                   - No automatic negotiation
+    CSR_WIFI_SME_TSPEC_CTRL_CCX_SIGNALLING
+                   - Signalling TSPEC
+    CSR_WIFI_SME_TSPEC_CTRL_CCX_VOICE
+                   - Voice traffic TSPEC
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeTspecCtrl;
+#define CSR_WIFI_SME_TSPEC_CTRL_STRICT           ((CsrWifiSmeTspecCtrl) 0x01)
+#define CSR_WIFI_SME_TSPEC_CTRL_CCX_SIGNALLING   ((CsrWifiSmeTspecCtrl) 0x02)
+#define CSR_WIFI_SME_TSPEC_CTRL_CCX_VOICE        ((CsrWifiSmeTspecCtrl) 0x04)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTspecResultCode
+
+  DESCRIPTION
+    Defines the result of the TSPEC exchanges with the AP
+
+ VALUES
+    CSR_WIFI_SME_TSPEC_RESULT_SUCCESS
+                   - TSPEC command has been processed correctly
+    CSR_WIFI_SME_TSPEC_RESULT_UNSPECIFIED_QOS_FAILURE
+                   - The Access Point reported a failure
+    CSR_WIFI_SME_TSPEC_RESULT_FAILURE
+                   - Internal failure in the SME
+    CSR_WIFI_SME_TSPEC_RESULT_INVALID_TSPEC_PARAMETERS
+                   - The TSPEC parameters are invalid
+    CSR_WIFI_SME_TSPEC_RESULT_INVALID_TCLAS_PARAMETERS
+                   - The TCLASS parameters are invalid
+    CSR_WIFI_SME_TSPEC_RESULT_INSUFFICIENT_BANDWIDTH
+                   - As specified by the WMM Spec
+    CSR_WIFI_SME_TSPEC_RESULT_WRONG_POLICY
+                   - As specified by the WMM Spec
+    CSR_WIFI_SME_TSPEC_RESULT_REJECTED_WITH_SUGGESTED_CHANGES
+                   - As specified by the WMM Spec
+    CSR_WIFI_SME_TSPEC_RESULT_TIMEOUT
+                   - The TSPEC negotiation timed out
+    CSR_WIFI_SME_TSPEC_RESULT_NOT_SUPPORTED
+                   - The Access Point does not support the TSPEC
+    CSR_WIFI_SME_TSPEC_RESULT_IE_LENGTH_INCORRECT
+                   - The length of the TSPEC is not correct
+    CSR_WIFI_SME_TSPEC_RESULT_INVALID_TRANSACTION_ID
+                   - The TSPEC transaction id is not in the list
+    CSR_WIFI_SME_TSPEC_RESULT_INSTALLED
+                   - The TSPEC has been installed and it is now active.
+    CSR_WIFI_SME_TSPEC_RESULT_TID_ALREADY_INSTALLED
+                   - The Traffic ID has already been installed
+    CSR_WIFI_SME_TSPEC_RESULT_TSPEC_REMOTELY_DELETED
+                   - The AP has deleted the TSPEC
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeTspecResultCode;
+#define CSR_WIFI_SME_TSPEC_RESULT_SUCCESS                           ((CsrWifiSmeTspecResultCode) 0x00)
+#define CSR_WIFI_SME_TSPEC_RESULT_UNSPECIFIED_QOS_FAILURE           ((CsrWifiSmeTspecResultCode) 0x01)
+#define CSR_WIFI_SME_TSPEC_RESULT_FAILURE                           ((CsrWifiSmeTspecResultCode) 0x02)
+#define CSR_WIFI_SME_TSPEC_RESULT_INVALID_TSPEC_PARAMETERS          ((CsrWifiSmeTspecResultCode) 0x05)
+#define CSR_WIFI_SME_TSPEC_RESULT_INVALID_TCLAS_PARAMETERS          ((CsrWifiSmeTspecResultCode) 0x06)
+#define CSR_WIFI_SME_TSPEC_RESULT_INSUFFICIENT_BANDWIDTH            ((CsrWifiSmeTspecResultCode) 0x07)
+#define CSR_WIFI_SME_TSPEC_RESULT_WRONG_POLICY                      ((CsrWifiSmeTspecResultCode) 0x08)
+#define CSR_WIFI_SME_TSPEC_RESULT_REJECTED_WITH_SUGGESTED_CHANGES   ((CsrWifiSmeTspecResultCode) 0x09)
+#define CSR_WIFI_SME_TSPEC_RESULT_TIMEOUT                           ((CsrWifiSmeTspecResultCode) 0x0D)
+#define CSR_WIFI_SME_TSPEC_RESULT_NOT_SUPPORTED                     ((CsrWifiSmeTspecResultCode) 0x0E)
+#define CSR_WIFI_SME_TSPEC_RESULT_IE_LENGTH_INCORRECT               ((CsrWifiSmeTspecResultCode) 0x10)
+#define CSR_WIFI_SME_TSPEC_RESULT_INVALID_TRANSACTION_ID            ((CsrWifiSmeTspecResultCode) 0x11)
+#define CSR_WIFI_SME_TSPEC_RESULT_INSTALLED                         ((CsrWifiSmeTspecResultCode) 0x12)
+#define CSR_WIFI_SME_TSPEC_RESULT_TID_ALREADY_INSTALLED             ((CsrWifiSmeTspecResultCode) 0x13)
+#define CSR_WIFI_SME_TSPEC_RESULT_TSPEC_REMOTELY_DELETED            ((CsrWifiSmeTspecResultCode) 0x14)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWepAuthMode
+
+  DESCRIPTION
+    Define bits for CsrWifiSmeWepAuthMode
+
+ VALUES
+    CSR_WIFI_SME_WEP_AUTH_MODE_OPEN   - Open-WEP enabled network
+    CSR_WIFI_SME_WEP_AUTH_MODE_SHARED - Shared-key WEP enabled network.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeWepAuthMode;
+#define CSR_WIFI_SME_WEP_AUTH_MODE_OPEN     ((CsrWifiSmeWepAuthMode) 0x00)
+#define CSR_WIFI_SME_WEP_AUTH_MODE_SHARED   ((CsrWifiSmeWepAuthMode) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWepCredentialType
+
+  DESCRIPTION
+    Definition of types of WEP Credentials
+
+ VALUES
+    CSR_WIFI_SME_CREDENTIAL_TYPE_WEP64
+                   - WEP 64 credential
+    CSR_WIFI_SME_CREDENTIAL_TYPE_WEP128
+                   - WEP 128 credential
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeWepCredentialType;
+#define CSR_WIFI_SME_CREDENTIAL_TYPE_WEP64    ((CsrWifiSmeWepCredentialType) 0x00)
+#define CSR_WIFI_SME_CREDENTIAL_TYPE_WEP128   ((CsrWifiSmeWepCredentialType) 0x01)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWmmMode
+
+  DESCRIPTION
+    Defines bits for wmmModeMask: enable/disable WMM features.
+
+ VALUES
+    CSR_WIFI_SME_WMM_MODE_DISABLED   - Disables the WMM features.
+    CSR_WIFI_SME_WMM_MODE_AC_ENABLED - Enables support for WMM-AC.
+    CSR_WIFI_SME_WMM_MODE_PS_ENABLED - Enables support for WMM Power Save.
+    CSR_WIFI_SME_WMM_MODE_SA_ENABLED - Currently not supported
+    CSR_WIFI_SME_WMM_MODE_ENABLED    - Enables support for all currently
+                                       available WMM features.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeWmmMode;
+#define CSR_WIFI_SME_WMM_MODE_DISABLED     ((CsrWifiSmeWmmMode) 0x00)
+#define CSR_WIFI_SME_WMM_MODE_AC_ENABLED   ((CsrWifiSmeWmmMode) 0x01)
+#define CSR_WIFI_SME_WMM_MODE_PS_ENABLED   ((CsrWifiSmeWmmMode) 0x02)
+#define CSR_WIFI_SME_WMM_MODE_SA_ENABLED   ((CsrWifiSmeWmmMode) 0x04)
+#define CSR_WIFI_SME_WMM_MODE_ENABLED      ((CsrWifiSmeWmmMode) 0xFF)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWmmQosInfo
+
+  DESCRIPTION
+    Defines bits for the QoS Info Octect as defined in the WMM specification.
+    The first four values define one bit each that can be set or cleared.
+    Each of the last four values define all the remaining 4 bits and only one
+    of them at the time shall be used.
+    For more information, see 'WMM (including WMM Power Save) Specification -
+    Version 1.1' and 'UniFi Configuring WMM and WMM-PS, Application Note'.
+
+ VALUES
+    CSR_WIFI_SME_WMM_QOS_INFO_AC_MAX_SP_ALL
+                   - WMM AP may deliver all buffered frames
+    CSR_WIFI_SME_WMM_QOS_INFO_AC_VO
+                   - Enable UAPSD(both trigger and delivery) for Voice Access
+                     Category
+    CSR_WIFI_SME_WMM_QOS_INFO_AC_VI
+                   - Enable UAPSD(both trigger and delivery) for  Video Access
+                     Category
+    CSR_WIFI_SME_WMM_QOS_INFO_AC_BK
+                   - Enable UAPSD(both trigger and delivery) for  Background
+                     Access Category
+    CSR_WIFI_SME_WMM_QOS_INFO_AC_BE
+                   - Enable UAPSD(both trigger and delivery) for  Best Effort
+                     Access Category
+    CSR_WIFI_SME_WMM_QOS_INFO_AC_MAX_SP_TWO
+                   - WMM AP may deliver a maximum of 2 buffered frames (MSDUs
+                     and MMPDUs) per USP
+    CSR_WIFI_SME_WMM_QOS_INFO_AC_MAX_SP_FOUR
+                   - WMM AP may deliver a maximum of 4 buffered frames (MSDUs
+                     and MMPDUs) per USP
+    CSR_WIFI_SME_WMM_QOS_INFO_AC_MAX_SP_SIX
+                   - WMM AP may deliver a maximum of 6 buffered frames (MSDUs
+                     and MMPDUs) per USP
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeWmmQosInfo;
+#define CSR_WIFI_SME_WMM_QOS_INFO_AC_MAX_SP_ALL    ((CsrWifiSmeWmmQosInfo) 0x00)
+#define CSR_WIFI_SME_WMM_QOS_INFO_AC_VO            ((CsrWifiSmeWmmQosInfo) 0x01)
+#define CSR_WIFI_SME_WMM_QOS_INFO_AC_VI            ((CsrWifiSmeWmmQosInfo) 0x02)
+#define CSR_WIFI_SME_WMM_QOS_INFO_AC_BK            ((CsrWifiSmeWmmQosInfo) 0x04)
+#define CSR_WIFI_SME_WMM_QOS_INFO_AC_BE            ((CsrWifiSmeWmmQosInfo) 0x08)
+#define CSR_WIFI_SME_WMM_QOS_INFO_AC_MAX_SP_TWO    ((CsrWifiSmeWmmQosInfo) 0x20)
+#define CSR_WIFI_SME_WMM_QOS_INFO_AC_MAX_SP_FOUR   ((CsrWifiSmeWmmQosInfo) 0x40)
+#define CSR_WIFI_SME_WMM_QOS_INFO_AC_MAX_SP_SIX    ((CsrWifiSmeWmmQosInfo) 0x60)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsConfigType
+
+  DESCRIPTION
+    WPS config methods supported/used by a device
+
+ VALUES
+    CSR_WIFI_WPS_CONFIG_LABEL
+                   - Label
+    CSR_WIFI_WPS_CONFIG_DISPLAY
+                   - Display
+    CSR_WIFI_WPS_CONFIG_EXT_NFC
+                   - External NFC : Not supported in this release
+    CSR_WIFI_WPS_CONFIG_INT_NFC
+                   - Internal NFC : Not supported in this release
+    CSR_WIFI_WPS_CONFIG_NFC_IFACE
+                   - NFC interface : Not supported in this release
+    CSR_WIFI_WPS_CONFIG_PBC
+                   - PBC
+    CSR_WIFI_WPS_CONFIG_KEYPAD
+                   - KeyPad
+    CSR_WIFI_WPS_CONFIG_VIRTUAL_PBC
+                   - PBC through software user interface
+    CSR_WIFI_WPS_CONFIG_PHYSICAL_PBC
+                   - Physical PBC
+    CSR_WIFI_WPS_CONFIG_VIRTUAL_DISPLAY
+                   - Virtual Display : via html config page etc
+    CSR_WIFI_WPS_CONFIG_PHYSICAL_DISPLAY
+                   - Physical Display : Attached to the device
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeWpsConfigType;
+#define CSR_WIFI_WPS_CONFIG_LABEL              ((CsrWifiSmeWpsConfigType) 0x0004)
+#define CSR_WIFI_WPS_CONFIG_DISPLAY            ((CsrWifiSmeWpsConfigType) 0x0008)
+#define CSR_WIFI_WPS_CONFIG_EXT_NFC            ((CsrWifiSmeWpsConfigType) 0x0010)
+#define CSR_WIFI_WPS_CONFIG_INT_NFC            ((CsrWifiSmeWpsConfigType) 0x0020)
+#define CSR_WIFI_WPS_CONFIG_NFC_IFACE          ((CsrWifiSmeWpsConfigType) 0x0040)
+#define CSR_WIFI_WPS_CONFIG_PBC                ((CsrWifiSmeWpsConfigType) 0x0080)
+#define CSR_WIFI_WPS_CONFIG_KEYPAD             ((CsrWifiSmeWpsConfigType) 0x0100)
+#define CSR_WIFI_WPS_CONFIG_VIRTUAL_PBC        ((CsrWifiSmeWpsConfigType) 0x0280)
+#define CSR_WIFI_WPS_CONFIG_PHYSICAL_PBC       ((CsrWifiSmeWpsConfigType) 0x0480)
+#define CSR_WIFI_WPS_CONFIG_VIRTUAL_DISPLAY    ((CsrWifiSmeWpsConfigType) 0x2008)
+#define CSR_WIFI_WPS_CONFIG_PHYSICAL_DISPLAY   ((CsrWifiSmeWpsConfigType) 0x4008)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsDeviceCategory
+
+  DESCRIPTION
+    Wps Primary Device Types
+
+ VALUES
+    CSR_WIFI_SME_WPS_CATEGORY_UNSPECIFIED
+                   - Unspecified.
+    CSR_WIFI_SME_WPS_CATEGORY_COMPUTER
+                   - Computer.
+    CSR_WIFI_SME_WPS_CATEGORY_INPUT_DEV
+                   - Input device
+    CSR_WIFI_SME_WPS_CATEGORY_PRT_SCAN_FX_CP
+                   - Printer Scanner Fax Copier etc
+    CSR_WIFI_SME_WPS_CATEGORY_CAMERA
+                   - Camera
+    CSR_WIFI_SME_WPS_CATEGORY_STORAGE
+                   - Storage
+    CSR_WIFI_SME_WPS_CATEGORY_NET_INFRA
+                   - Net Infra
+    CSR_WIFI_SME_WPS_CATEGORY_DISPLAY
+                   - Display
+    CSR_WIFI_SME_WPS_CATEGORY_MULTIMEDIA
+                   - Multimedia
+    CSR_WIFI_SME_WPS_CATEGORY_GAMING
+                   - Gaming.
+    CSR_WIFI_SME_WPS_CATEGORY_TELEPHONE
+                   - Telephone.
+    CSR_WIFI_SME_WPS_CATEGORY_AUDIO
+                   - Audio
+    CSR_WIFI_SME_WPS_CATEOARY_OTHERS
+                   - Others.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeWpsDeviceCategory;
+#define CSR_WIFI_SME_WPS_CATEGORY_UNSPECIFIED      ((CsrWifiSmeWpsDeviceCategory) 0x00)
+#define CSR_WIFI_SME_WPS_CATEGORY_COMPUTER         ((CsrWifiSmeWpsDeviceCategory) 0x01)
+#define CSR_WIFI_SME_WPS_CATEGORY_INPUT_DEV        ((CsrWifiSmeWpsDeviceCategory) 0x02)
+#define CSR_WIFI_SME_WPS_CATEGORY_PRT_SCAN_FX_CP   ((CsrWifiSmeWpsDeviceCategory) 0x03)
+#define CSR_WIFI_SME_WPS_CATEGORY_CAMERA           ((CsrWifiSmeWpsDeviceCategory) 0x04)
+#define CSR_WIFI_SME_WPS_CATEGORY_STORAGE          ((CsrWifiSmeWpsDeviceCategory) 0x05)
+#define CSR_WIFI_SME_WPS_CATEGORY_NET_INFRA        ((CsrWifiSmeWpsDeviceCategory) 0x06)
+#define CSR_WIFI_SME_WPS_CATEGORY_DISPLAY          ((CsrWifiSmeWpsDeviceCategory) 0x07)
+#define CSR_WIFI_SME_WPS_CATEGORY_MULTIMEDIA       ((CsrWifiSmeWpsDeviceCategory) 0x08)
+#define CSR_WIFI_SME_WPS_CATEGORY_GAMING           ((CsrWifiSmeWpsDeviceCategory) 0x09)
+#define CSR_WIFI_SME_WPS_CATEGORY_TELEPHONE        ((CsrWifiSmeWpsDeviceCategory) 0x0A)
+#define CSR_WIFI_SME_WPS_CATEGORY_AUDIO            ((CsrWifiSmeWpsDeviceCategory) 0x0B)
+#define CSR_WIFI_SME_WPS_CATEOARY_OTHERS           ((CsrWifiSmeWpsDeviceCategory) 0xFF)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsDeviceSubCategory
+
+  DESCRIPTION
+    Wps Secondary Device Types
+
+ VALUES
+    CSR_WIFI_SME_WPS_SUB_CATEGORY_UNSPECIFIED
+                   - Unspecied
+    CSR_WIFI_SME_WPS_STORAGE_SUB_CATEGORY_NAS
+                   - Network Associated Storage
+    CSR_WIFI_SME_WPS_PSFC_SUB_CATEGORY_PRNTR
+                   - Printer or print server
+    CSR_WIFI_SME_WPS_TELEPHONE_SUB_CATEGORY_WM
+                   - Windows mobile
+    CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_TUNER
+                   - Audio tuner/receiver
+    CSR_WIFI_SME_WPS_CAMERA_SUB_CATEGORY_DIG_STL
+                   - Digital still camera
+    CSR_WIFI_SME_WPS_NET_INFRA_SUB_CATEGORY_AP
+                   - Access Point
+    CSR_WIFI_SME_WPS_DISPLAY_SUB_CATEGORY_TV
+                   - TV.
+    CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_DAR
+                   - DAR.
+    CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_KEYBD
+                   - Keyboard.
+    CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_PC
+                   - PC.
+    CSR_WIFI_SME_WPS_GAMING_SUB_CATEGORY_XBOX
+                   - Xbox.
+    CSR_WIFI_SME_WPS_PSFC_SUB_CATEGORY_SCNR
+                   - Scanner
+    CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_SERVER
+                   - Server
+    CSR_WIFI_SME_WPS_NET_INFRA_SUB_CATEGORY_ROUTER
+                   - Router
+    CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_PVR
+                   - PVR
+    CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_SPEAKER
+                   - Speaker
+    CSR_WIFI_SME_WPS_TELEPHONE_SUB_CATEGORY_FP_SM
+                   - Feature phone - Single mode
+    CSR_WIFI_SME_WPS_CAMERA_SUB_CATEGORY_VIDEO
+                   - Video camera
+    CSR_WIFI_SME_WPS_DISPLAY_SUB_CATEGORY_PIC_FRM
+                   - Picture frame
+    CSR_WIFI_SME_WPS_GAMING_SUB_CATEGORY_XBOX_360
+                   - Xbox360
+    CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_MOUSE
+                   - Mouse
+    CSR_WIFI_SME_WPS_NET_INFRA_SUB_CATEGORY_SWITCH
+                   - Switch
+    CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_PMP
+                   - Portable music player
+    CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_JOYSTK
+                   - Joy stick
+    CSR_WIFI_SME_WPS_GAMING_SUB_CATEGORY_PLAY_STN
+                   - Play-station
+    CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_MED_CENT
+                   - Media Center
+    CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_MCX
+                   - MCX
+    CSR_WIFI_SME_WPS_TELEPHONE_SUB_CATEGORY_FP_DM
+                   - Feature phone - Dual mode
+    CSR_WIFI_SME_WPS_CAMERA_SUB_CATEGORY_WEB
+                   - Web camera
+    CSR_WIFI_SME_WPS_PSFC_SUB_CATEGORY_FAX
+                   - Fax
+    CSR_WIFI_SME_WPS_DISPLAY_SUB_CATEGORY_PROJECTOR
+                   - Projector
+    CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_TRKBL
+                   - Track Ball
+    CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_ST_BOX
+                   - Set-Top-Box
+    CSR_WIFI_SME_WPS_NET_INFRA_SUB_CATEGORY_GATEWAY
+                   - GateWay.
+    CSR_WIFI_SME_WPS_CAMERA_SUB_CATEGORY_SECURITY
+                   - Security camera
+    CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_ULTRA_MOB_PC
+                   - Ultra mobile PC.
+    CSR_WIFI_SME_WPS_GAMING_SUB_CATEGORY_CONSOLE
+                   - Game console/Game console adapter
+    CSR_WIFI_SME_WPS_PSFC_SUB_CATEGORY_CPR
+                   - Copier
+    CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_HEADSET
+                   - Headset(headphones + microphone)
+    CSR_WIFI_SME_WPS_TELEPHONE_SUB_CATEGORY_SP_SM
+                   - Smart phone - Single mode
+    CSR_WIFI_SME_WPS_DISPLAY_SUB_CATEGORY_MONITOR
+                   - Monitor.
+    CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_GAME_CTRL
+                   - Game control.
+    CSR_WIFI_SME_WPS_PSFC_SUB_CATEGORY_ALL
+                   - All-in-One
+    CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_MEDIA
+                   - Media Server/Media Adapter/Media Extender
+    CSR_WIFI_SME_WPS_TELEPHONE_SUB_CATEGORY_SP_DM
+                   - Smart phone - Dual mode
+    CSR_WIFI_SME_WPS_GAMING_SUB_CATEGORY_PORT_DEV
+                   - Portable gaming device
+    CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_HEADPHONE
+                   - Headphone.
+    CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_NOTEBOOK
+                   - Notebook.
+    CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_REMOTE
+                   - Remote control
+    CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_MIC
+                   - Microphone
+    CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_DESKTOP
+                   - Desktop.
+    CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_VP
+                   - Portable video player
+    CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_MID
+                   - Mobile internet device
+    CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_TOUCH_SCRN
+                   - Touch screen
+    CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_BIOMET_RDR
+                   - Biometric reader
+    CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_NETBOOK
+                   - Netbook
+    CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_BRCD_RDR
+                   - Bar code reader.
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeWpsDeviceSubCategory;
+#define CSR_WIFI_SME_WPS_SUB_CATEGORY_UNSPECIFIED             ((CsrWifiSmeWpsDeviceSubCategory) 0x00)
+#define CSR_WIFI_SME_WPS_STORAGE_SUB_CATEGORY_NAS             ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_PSFC_SUB_CATEGORY_PRNTR              ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_TELEPHONE_SUB_CATEGORY_WM            ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_TUNER             ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_CAMERA_SUB_CATEGORY_DIG_STL          ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_NET_INFRA_SUB_CATEGORY_AP            ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_DISPLAY_SUB_CATEGORY_TV              ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_DAR                  ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_KEYBD         ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_PC             ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_GAMING_SUB_CATEGORY_XBOX             ((CsrWifiSmeWpsDeviceSubCategory) 0x01)
+#define CSR_WIFI_SME_WPS_PSFC_SUB_CATEGORY_SCNR               ((CsrWifiSmeWpsDeviceSubCategory) 0x02)
+#define CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_SERVER         ((CsrWifiSmeWpsDeviceSubCategory) 0x02)
+#define CSR_WIFI_SME_WPS_NET_INFRA_SUB_CATEGORY_ROUTER        ((CsrWifiSmeWpsDeviceSubCategory) 0x02)
+#define CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_PVR                  ((CsrWifiSmeWpsDeviceSubCategory) 0x02)
+#define CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_SPEAKER           ((CsrWifiSmeWpsDeviceSubCategory) 0x02)
+#define CSR_WIFI_SME_WPS_TELEPHONE_SUB_CATEGORY_FP_SM         ((CsrWifiSmeWpsDeviceSubCategory) 0x02)
+#define CSR_WIFI_SME_WPS_CAMERA_SUB_CATEGORY_VIDEO            ((CsrWifiSmeWpsDeviceSubCategory) 0x02)
+#define CSR_WIFI_SME_WPS_DISPLAY_SUB_CATEGORY_PIC_FRM         ((CsrWifiSmeWpsDeviceSubCategory) 0x02)
+#define CSR_WIFI_SME_WPS_GAMING_SUB_CATEGORY_XBOX_360         ((CsrWifiSmeWpsDeviceSubCategory) 0x02)
+#define CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_MOUSE         ((CsrWifiSmeWpsDeviceSubCategory) 0x02)
+#define CSR_WIFI_SME_WPS_NET_INFRA_SUB_CATEGORY_SWITCH        ((CsrWifiSmeWpsDeviceSubCategory) 0x03)
+#define CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_PMP               ((CsrWifiSmeWpsDeviceSubCategory) 0x03)
+#define CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_JOYSTK        ((CsrWifiSmeWpsDeviceSubCategory) 0x03)
+#define CSR_WIFI_SME_WPS_GAMING_SUB_CATEGORY_PLAY_STN         ((CsrWifiSmeWpsDeviceSubCategory) 0x03)
+#define CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_MED_CENT       ((CsrWifiSmeWpsDeviceSubCategory) 0x03)
+#define CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_MCX                  ((CsrWifiSmeWpsDeviceSubCategory) 0x03)
+#define CSR_WIFI_SME_WPS_TELEPHONE_SUB_CATEGORY_FP_DM         ((CsrWifiSmeWpsDeviceSubCategory) 0x03)
+#define CSR_WIFI_SME_WPS_CAMERA_SUB_CATEGORY_WEB              ((CsrWifiSmeWpsDeviceSubCategory) 0x03)
+#define CSR_WIFI_SME_WPS_PSFC_SUB_CATEGORY_FAX                ((CsrWifiSmeWpsDeviceSubCategory) 0x03)
+#define CSR_WIFI_SME_WPS_DISPLAY_SUB_CATEGORY_PROJECTOR       ((CsrWifiSmeWpsDeviceSubCategory) 0x03)
+#define CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_TRKBL         ((CsrWifiSmeWpsDeviceSubCategory) 0x04)
+#define CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_ST_BOX               ((CsrWifiSmeWpsDeviceSubCategory) 0x04)
+#define CSR_WIFI_SME_WPS_NET_INFRA_SUB_CATEGORY_GATEWAY       ((CsrWifiSmeWpsDeviceSubCategory) 0x04)
+#define CSR_WIFI_SME_WPS_CAMERA_SUB_CATEGORY_SECURITY         ((CsrWifiSmeWpsDeviceSubCategory) 0x04)
+#define CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_ULTRA_MOB_PC   ((CsrWifiSmeWpsDeviceSubCategory) 0x04)
+#define CSR_WIFI_SME_WPS_GAMING_SUB_CATEGORY_CONSOLE          ((CsrWifiSmeWpsDeviceSubCategory) 0x04)
+#define CSR_WIFI_SME_WPS_PSFC_SUB_CATEGORY_CPR                ((CsrWifiSmeWpsDeviceSubCategory) 0x04)
+#define CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_HEADSET           ((CsrWifiSmeWpsDeviceSubCategory) 0x04)
+#define CSR_WIFI_SME_WPS_TELEPHONE_SUB_CATEGORY_SP_SM         ((CsrWifiSmeWpsDeviceSubCategory) 0x04)
+#define CSR_WIFI_SME_WPS_DISPLAY_SUB_CATEGORY_MONITOR         ((CsrWifiSmeWpsDeviceSubCategory) 0x04)
+#define CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_GAME_CTRL     ((CsrWifiSmeWpsDeviceSubCategory) 0x05)
+#define CSR_WIFI_SME_WPS_PSFC_SUB_CATEGORY_ALL                ((CsrWifiSmeWpsDeviceSubCategory) 0x05)
+#define CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_MEDIA                ((CsrWifiSmeWpsDeviceSubCategory) 0x05)
+#define CSR_WIFI_SME_WPS_TELEPHONE_SUB_CATEGORY_SP_DM         ((CsrWifiSmeWpsDeviceSubCategory) 0x05)
+#define CSR_WIFI_SME_WPS_GAMING_SUB_CATEGORY_PORT_DEV         ((CsrWifiSmeWpsDeviceSubCategory) 0x05)
+#define CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_HEADPHONE         ((CsrWifiSmeWpsDeviceSubCategory) 0x05)
+#define CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_NOTEBOOK       ((CsrWifiSmeWpsDeviceSubCategory) 0x05)
+#define CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_REMOTE        ((CsrWifiSmeWpsDeviceSubCategory) 0x06)
+#define CSR_WIFI_SME_WPS_AUDIO_SUB_CATEGORY_MIC               ((CsrWifiSmeWpsDeviceSubCategory) 0x06)
+#define CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_DESKTOP        ((CsrWifiSmeWpsDeviceSubCategory) 0x06)
+#define CSR_WIFI_SME_WPS_MM_SUB_CATEGORY_VP                   ((CsrWifiSmeWpsDeviceSubCategory) 0x06)
+#define CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_MID            ((CsrWifiSmeWpsDeviceSubCategory) 0x07)
+#define CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_TOUCH_SCRN    ((CsrWifiSmeWpsDeviceSubCategory) 0x07)
+#define CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_BIOMET_RDR    ((CsrWifiSmeWpsDeviceSubCategory) 0x08)
+#define CSR_WIFI_SME_WPS_COMPUTER_SUB_CATEGORY_NETBOOK        ((CsrWifiSmeWpsDeviceSubCategory) 0x08)
+#define CSR_WIFI_SME_WPS_INPUT_DEV_SUB_CATEGORY_BRCD_RDR      ((CsrWifiSmeWpsDeviceSubCategory) 0x09)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsDpid
+
+  DESCRIPTION
+    Device Password ID for the chosen config method
+
+ VALUES
+    CSR_WIFI_SME_WPS_DPID_PIN       - PIN
+    CSR_WIFI_SME_WPS_DPID_USER      - User specified : Used only during P2P GO
+                                      negotiation procedure
+    CSR_WIFI_SME_WPS_DPID_MACHINE   - Machine specified i: Not used in this
+                                      release
+    CSR_WIFI_SME_WPS_DPID_REKEY     - Rekey : Not used in this release
+    CSR_WIFI_SME_WPS_DPID_PBC       - PBC
+    CSR_WIFI_SME_WPS_DPID_REGISTRAR - Registrar specified : Used only in P2P Go
+                                      negotiation procedure
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeWpsDpid;
+#define CSR_WIFI_SME_WPS_DPID_PIN         ((CsrWifiSmeWpsDpid) 0x0000)
+#define CSR_WIFI_SME_WPS_DPID_USER        ((CsrWifiSmeWpsDpid) 0x0001)
+#define CSR_WIFI_SME_WPS_DPID_MACHINE     ((CsrWifiSmeWpsDpid) 0x0002)
+#define CSR_WIFI_SME_WPS_DPID_REKEY       ((CsrWifiSmeWpsDpid) 0x0003)
+#define CSR_WIFI_SME_WPS_DPID_PBC         ((CsrWifiSmeWpsDpid) 0x0004)
+#define CSR_WIFI_SME_WPS_DPID_REGISTRAR   ((CsrWifiSmeWpsDpid) 0x0005)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsRegistration
+
+  DESCRIPTION
+
+ VALUES
+    CSR_WIFI_SME_WPS_REG_NOT_REQUIRED - No encryption set
+    CSR_WIFI_SME_WPS_REG_REQUIRED     - No encryption set
+    CSR_WIFI_SME_WPS_REG_UNKNOWN      - No encryption set
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeWpsRegistration;
+#define CSR_WIFI_SME_WPS_REG_NOT_REQUIRED   ((CsrWifiSmeWpsRegistration) 0x00)
+#define CSR_WIFI_SME_WPS_REG_REQUIRED       ((CsrWifiSmeWpsRegistration) 0x01)
+#define CSR_WIFI_SME_WPS_REG_UNKNOWN        ((CsrWifiSmeWpsRegistration) 0x02)
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAuthModeMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeAuthMode
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeAuthModeMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeEncryptionMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeEncryption
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeEncryptionMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeIndicationsMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeIndications
+
+*******************************************************************************/
+typedef CsrUint32 CsrWifiSmeIndicationsMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeP2pCapabilityMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeP2pCapability
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeP2pCapabilityMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeP2pGroupCapabilityMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeP2pGroupCapability
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeP2pGroupCapabilityMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTspecCtrlMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeTspecCtrl
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeTspecCtrlMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWmmModeMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeWmmMode
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeWmmModeMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWmmQosInfoMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeWmmQosInfo
+
+*******************************************************************************/
+typedef CsrUint8 CsrWifiSmeWmmQosInfoMask;
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsConfigTypeMask
+
+  DESCRIPTION
+    Mask type for use with the values defined by CsrWifiSmeWpsConfigType
+
+*******************************************************************************/
+typedef CsrUint16 CsrWifiSmeWpsConfigTypeMask;
+
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAdHocConfig
+
+  DESCRIPTION
+    Defines values to use when starting an Ad-hoc (IBSS) network.
+
+  MEMBERS
+    atimWindowTu          - ATIM window specified for IBSS
+    beaconPeriodTu        - Interval between beacon packets
+    joinOnlyAttempts      - Maximum number of attempts to join an ad-hoc network.
+                            The default value is 1.
+                            Set to 0 for infinite attempts.
+    joinAttemptIntervalMs - Time between scans for joining the requested IBSS.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint16 atimWindowTu;
+    CsrUint16 beaconPeriodTu;
+    CsrUint16 joinOnlyAttempts;
+    CsrUint16 joinAttemptIntervalMs;
+} CsrWifiSmeAdHocConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAvailabilityConfig
+
+  DESCRIPTION
+
+  MEMBERS
+    listenChannel        -
+    availabilityDuration -
+    avalabilityPeriod    -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8  listenChannel;
+    CsrUint16 availabilityDuration;
+    CsrUint16 avalabilityPeriod;
+} CsrWifiSmeAvailabilityConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCcxConfig
+
+  DESCRIPTION
+    This type is reserved for future use and should not be used.
+
+  MEMBERS
+    keepAliveTimeMs    - NOT USED
+    apRoamingEnabled   - NOT USED
+    measurementsMask   - NOT USED
+    ccxRadioMgtEnabled - NOT USED
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8 keepAliveTimeMs;
+    CsrBool  apRoamingEnabled;
+    CsrUint8 measurementsMask;
+    CsrBool  ccxRadioMgtEnabled;
+} CsrWifiSmeCcxConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexConfig
+
+  DESCRIPTION
+    Parameters for the coexistence behaviour.
+
+  MEMBERS
+    coexEnableSchemeManagement     - Enables the Coexistence Management Scheme
+    coexPeriodicWakeHost           - If TRUE the firmware wakes up the host
+                                     periodically according to the traffic
+                                     period and latency parameters; the host
+                                     will then send the data to transmit only
+                                     when woken up.
+                                     If FALSE, the firmware does not wake up the
+                                     host and the host will send the data to
+                                     transmit to the firmware whenever there is
+                                     data to transmit
+    coexTrafficBurstyLatencyMs     - Period of awakening for the firmware used
+                                     when bursty traffic is detected
+    coexTrafficContinuousLatencyMs - Period of awakening for the firmware used
+                                     when continuous traffic is detected
+    coexObexBlackoutDurationMs     - Blackout Duration when a Obex Connection is
+                                     used
+    coexObexBlackoutPeriodMs       - Blackout Period when a Obex Connection is
+                                     used
+    coexA2dpBrBlackoutDurationMs   - Blackout Duration when a Basic Rate A2DP
+                                     Connection streaming data
+    coexA2dpBrBlackoutPeriodMs     - Blackout Period when a Basic Rate A2DP
+                                     Connection streaming data
+    coexA2dpEdrBlackoutDurationMs  - Blackout Duration when an Enhanced Data
+                                     Rate A2DP Connection streaming data
+    coexA2dpEdrBlackoutPeriodMs    - Blackout Period when an Enhanced Data Rate
+                                     A2DP Connection streaming data
+    coexPagingBlackoutDurationMs   - Blackout Duration when a BT page is active
+    coexPagingBlackoutPeriodMs     - Blackout Period when a BT page is active
+    coexInquiryBlackoutDurationMs  - Blackout Duration when a BT inquiry is
+                                     active
+    coexInquiryBlackoutPeriodMs    - Blackout Period when a BT inquiry is active
+
+*******************************************************************************/
+typedef struct
+{
+    CsrBool   coexEnableSchemeManagement;
+    CsrBool   coexPeriodicWakeHost;
+    CsrUint16 coexTrafficBurstyLatencyMs;
+    CsrUint16 coexTrafficContinuousLatencyMs;
+    CsrUint16 coexObexBlackoutDurationMs;
+    CsrUint16 coexObexBlackoutPeriodMs;
+    CsrUint16 coexA2dpBrBlackoutDurationMs;
+    CsrUint16 coexA2dpBrBlackoutPeriodMs;
+    CsrUint16 coexA2dpEdrBlackoutDurationMs;
+    CsrUint16 coexA2dpEdrBlackoutPeriodMs;
+    CsrUint16 coexPagingBlackoutDurationMs;
+    CsrUint16 coexPagingBlackoutPeriodMs;
+    CsrUint16 coexInquiryBlackoutDurationMs;
+    CsrUint16 coexInquiryBlackoutPeriodMs;
+} CsrWifiSmeCoexConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionStats
+
+  DESCRIPTION
+    Indicates the statistics of the connection.
+    The dot11 fields are defined in the Annex D of the IEEE 802.11 standard.
+
+  MEMBERS
+    unifiTxDataRate
+                   - The bit rate currently in use for transmissions of unicast
+                     data frames; a data rate in units of 500kbit/s.
+                     On an infrastructure BSS, this is the data rate used in
+                     communicating with the associated access point; if there is
+                     none, an error is returned.
+                     On an IBSS, this is the data rate used for the last
+                     transmission of a unicast data frame to any station in the
+                     IBSS. If no such transmission has been made, an error is
+                     returned.
+    unifiRxDataRate
+                   - As above for receiving data
+    dot11RetryCount
+                   - See IEEE 802.11 Standard
+    dot11MultipleRetryCount
+                   - See IEEE 802.11 Standard
+    dot11AckFailureCount
+                   - See IEEE 802.11 Standard
+    dot11FrameDuplicateCount
+                   - See IEEE 802.11 Standard
+    dot11FcsErrorCount
+                   - See IEEE 802.11 Standard
+    dot11RtsSuccessCount
+                   - See IEEE 802.11 Standard
+    dot11RtsFailureCount
+                   - See IEEE 802.11 Standard
+    dot11FailedCount
+                   - See IEEE 802.11 Standard
+    dot11TransmittedFragmentCount
+                   - See IEEE 802.11 Standard
+    dot11TransmittedFrameCount
+                   - See IEEE 802.11 Standard
+    dot11WepExcludedCount
+                   - See IEEE 802.11 Standard
+    dot11WepIcvErrorCount
+                   - See IEEE 802.11 Standard
+    dot11WepUndecryptableCount
+                   - See IEEE 802.11 Standard
+    dot11MulticastReceivedFrameCount
+                   - See IEEE 802.11 Standard
+    dot11MulticastTransmittedFrameCount
+                   - See IEEE 802.11 Standard
+    dot11ReceivedFragmentCount
+                   - See IEEE 802.11 Standard
+    dot11Rsna4WayHandshakeFailures
+                   - See IEEE 802.11 Standard
+    dot11RsnaTkipCounterMeasuresInvoked
+                   - See IEEE 802.11 Standard
+    dot11RsnaStatsTkipLocalMicFailures
+                   - See IEEE 802.11 Standard
+    dot11RsnaStatsTkipReplays
+                   - See IEEE 802.11 Standard
+    dot11RsnaStatsTkipIcvErrors
+                   - See IEEE 802.11 Standard
+    dot11RsnaStatsCcmpReplays
+                   - See IEEE 802.11 Standard
+    dot11RsnaStatsCcmpDecryptErrors
+                   - See IEEE 802.11 Standard
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8  unifiTxDataRate;
+    CsrUint8  unifiRxDataRate;
+    CsrUint32 dot11RetryCount;
+    CsrUint32 dot11MultipleRetryCount;
+    CsrUint32 dot11AckFailureCount;
+    CsrUint32 dot11FrameDuplicateCount;
+    CsrUint32 dot11FcsErrorCount;
+    CsrUint32 dot11RtsSuccessCount;
+    CsrUint32 dot11RtsFailureCount;
+    CsrUint32 dot11FailedCount;
+    CsrUint32 dot11TransmittedFragmentCount;
+    CsrUint32 dot11TransmittedFrameCount;
+    CsrUint32 dot11WepExcludedCount;
+    CsrUint32 dot11WepIcvErrorCount;
+    CsrUint32 dot11WepUndecryptableCount;
+    CsrUint32 dot11MulticastReceivedFrameCount;
+    CsrUint32 dot11MulticastTransmittedFrameCount;
+    CsrUint32 dot11ReceivedFragmentCount;
+    CsrUint32 dot11Rsna4WayHandshakeFailures;
+    CsrUint32 dot11RsnaTkipCounterMeasuresInvoked;
+    CsrUint32 dot11RsnaStatsTkipLocalMicFailures;
+    CsrUint32 dot11RsnaStatsTkipReplays;
+    CsrUint32 dot11RsnaStatsTkipIcvErrors;
+    CsrUint32 dot11RsnaStatsCcmpReplays;
+    CsrUint32 dot11RsnaStatsCcmpDecryptErrors;
+} CsrWifiSmeConnectionStats;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDataBlock
+
+  DESCRIPTION
+    Holds a generic data block to be passed through the interface
+
+  MEMBERS
+    length - Length of the data block
+    data   - Points to the first byte of the data block
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint16 length;
+    CsrUint8 *data;
+} CsrWifiSmeDataBlock;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeEmpty
+
+  DESCRIPTION
+    Empty Structure to indicate that no parameters are available.
+
+  MEMBERS
+    empty  - Only element of the empty structure (always set to 0).
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8 empty;
+} CsrWifiSmeEmpty;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeLinkQuality
+
+  DESCRIPTION
+    Indicates the quality of the link
+
+  MEMBERS
+    unifiRssi - Indicates the received signal strength indication of the link in
+                dBm
+    unifiSnr  - Indicates the signal to noise ratio of the link in dB
+
+*******************************************************************************/
+typedef struct
+{
+    CsrInt16 unifiRssi;
+    CsrInt16 unifiSnr;
+} CsrWifiSmeLinkQuality;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibConfig
+
+  DESCRIPTION
+    Allows low level configuration in the chip.
+
+  MEMBERS
+    unifiFixMaxTxDataRate       - This attribute is used in combination with
+                                  unifiFixTxDataRate. If it is FALSE, then
+                                  unifiFixTxDataRate specifies a specific data
+                                  rate to use. If it is TRUE, unifiFixTxDataRate
+                                  instead specifies a maximum data rate.
+    unifiFixTxDataRate          - Transmit rate for unicast data.
+                                  See MIB description for more details
+    dot11RtsThreshold           - See IEEE 802.11 Standard
+    dot11FragmentationThreshold - See IEEE 802.11 Standard
+    dot11CurrentTxPowerLevel    - See IEEE 802.11 Standard
+
+*******************************************************************************/
+typedef struct
+{
+    CsrBool   unifiFixMaxTxDataRate;
+    CsrUint8  unifiFixTxDataRate;
+    CsrUint16 dot11RtsThreshold;
+    CsrUint16 dot11FragmentationThreshold;
+    CsrUint16 dot11CurrentTxPowerLevel;
+} CsrWifiSmeMibConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeP2pProfileIdentity
+
+  DESCRIPTION
+    Details to be filled in
+
+  MEMBERS
+    listenChannel        -
+    availabilityDuration -
+    avalabilityPeriod    -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8  listenChannel;
+    CsrUint16 availabilityDuration;
+    CsrUint16 avalabilityPeriod;
+} CsrWifiSmeP2pProfileIdentity;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePmkid
+
+  DESCRIPTION
+    Defines a PMKID association with BSS
+
+  MEMBERS
+    bssid  - BSS identifier
+    pmkid  - PMKID
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiMacAddress bssid;
+    CsrUint8          pmkid[16];
+} CsrWifiSmePmkid;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePmkidCandidate
+
+  DESCRIPTION
+    Information for a PMKID candidate
+
+  MEMBERS
+    bssid          - BSS identifier
+    preAuthAllowed - Indicates whether preauthentication is allowed
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiMacAddress bssid;
+    CsrBool           preAuthAllowed;
+} CsrWifiSmePmkidCandidate;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePmkidList
+
+  DESCRIPTION
+    NOT USED
+    Used in the Sync access API
+
+  MEMBERS
+    pmkidsCount - Number of PMKIDs in the list
+    pmkids      - Points to the first PMKID in the list
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8         pmkidsCount;
+    CsrWifiSmePmkid *pmkids;
+} CsrWifiSmePmkidList;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRegulatoryDomainInfo
+
+  DESCRIPTION
+    Regulatory domain options.
+
+  MEMBERS
+    dot11MultiDomainCapabilityImplemented
+                   - TRUE is the multi domain capability is implemented
+    dot11MultiDomainCapabilityEnabled
+                   - TRUE is the multi domain capability is enabled
+    currentRegulatoryDomain
+                   - Current regulatory domain
+    currentCountryCode
+                   - Current country code as defined by the IEEE 802.11
+                     standards
+
+*******************************************************************************/
+typedef struct
+{
+    CsrBool                    dot11MultiDomainCapabilityImplemented;
+    CsrBool                    dot11MultiDomainCapabilityEnabled;
+    CsrWifiSmeRegulatoryDomain currentRegulatoryDomain;
+    CsrUint8                   currentCountryCode[2];
+} CsrWifiSmeRegulatoryDomainInfo;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamingBandData
+
+  DESCRIPTION
+    Thresholds to define one usability level category for the received signal
+
+  MEMBERS
+    rssiHighThreshold - Received Signal Strength Indication upper bound in dBm
+                        for the usability level
+    rssiLowThreshold  - Received Signal Strength Indication lower bound in dBm
+                        for the usability level
+    snrHighThreshold  - Signal to Noise Ratio upper bound in dB for the
+                        usability level
+    snrLowThreshold   - Signal to Noise Ratio lower bound in dB for the
+                        usability level
+
+*******************************************************************************/
+typedef struct
+{
+    CsrInt16 rssiHighThreshold;
+    CsrInt16 rssiLowThreshold;
+    CsrInt16 snrHighThreshold;
+    CsrInt16 snrLowThreshold;
+} CsrWifiSmeRoamingBandData;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanConfigData
+
+  DESCRIPTION
+    Configures the scanning behaviour of the driver and firmware
+
+  MEMBERS
+    intervalSeconds         - All the channels will be scanned once in this time
+                              interval.
+                              If connected, the channel scans are spread across
+                              the interval.
+                              If disconnected, all the channels will be scanned
+                              together
+    validitySeconds         - How long the scan result are cached
+    minActiveChannelTimeTu  - Minimum time of listening on a channel being
+                              actively scanned before leaving if no probe
+                              responses or beacon frames have been received
+    maxActiveChannelTimeTu  - Maximum time of listening on a channel being
+                              actively scanned
+    minPassiveChannelTimeTu - Minimum time of listening on a channel being
+                              passive scanned before leaving if no beacon frames
+                              have been received
+    maxPassiveChannelTimeTu - Maximum time of listening on a channel being
+                              passively scanned
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint16 intervalSeconds;
+    CsrUint16 validitySeconds;
+    CsrUint16 minActiveChannelTimeTu;
+    CsrUint16 maxActiveChannelTimeTu;
+    CsrUint16 minPassiveChannelTimeTu;
+    CsrUint16 maxPassiveChannelTimeTu;
+} CsrWifiSmeScanConfigData;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeStaConfig
+
+  DESCRIPTION
+    Station configuration options in the SME
+
+  MEMBERS
+    connectionQualityRssiChangeTrigger - Sets the difference of RSSI
+                                         measurements which triggers reports
+                                         from the Firmware
+    connectionQualitySnrChangeTrigger  - Sets the difference of SNR measurements
+                                         which triggers reports from the
+                                         Firmware
+    wmmModeMask                        - Mask containing one or more values from
+                                         CsrWifiSmeWmmMode
+    ifIndex                            - Indicates the band of frequencies used
+    allowUnicastUseGroupCipher         - If TRUE, it allows to use groupwise
+                                         keys if no pairwise key is specified
+    enableOpportunisticKeyCaching      - If TRUE, enables the Opportunistic Key
+                                         Caching feature
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8          connectionQualityRssiChangeTrigger;
+    CsrUint8          connectionQualitySnrChangeTrigger;
+    CsrUint8          wmmModeMask;
+    CsrWifiSmeRadioIF ifIndex;
+    CsrBool           allowUnicastUseGroupCipher;
+    CsrBool           enableOpportunisticKeyCaching;
+} CsrWifiSmeStaConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTsfTime
+
+  DESCRIPTION
+    Time stamp representation
+
+  MEMBERS
+    data   - TSF Bytes
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8 data[8];
+} CsrWifiSmeTsfTime;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeVersions
+
+  DESCRIPTION
+    Reports version information for the chip, the firmware and the driver and
+    the SME.
+
+  MEMBERS
+    chipId        - Chip ID
+    chipVersion   - Chip version ID
+    firmwareBuild - Firmware Rom build number
+    firmwarePatch - Firmware Patch build number (if applicable)
+    firmwareHip   - Firmware HIP protocol version number
+    routerBuild   - Router build number
+    routerHip     - Router HIP protocol version number
+    smeBuild      - SME build number
+    smeHip        - SME HIP protocol version number
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint32      chipId;
+    CsrUint32      chipVersion;
+    CsrUint32      firmwareBuild;
+    CsrUint32      firmwarePatch;
+    CsrUint32      firmwareHip;
+    CsrCharString *routerBuild;
+    CsrUint32      routerHip;
+    CsrCharString *smeBuild;
+    CsrUint32      smeHip;
+} CsrWifiSmeVersions;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWmmAcParams
+
+  DESCRIPTION
+    Structure holding WMM AC params data.
+
+  MEMBERS
+    cwMin                     - Exponent for the calculation of CWmin. Range: 0
+                                to 15
+    cwMax                     - Exponent for the calculation of CWmax. Range: 0
+                                to15
+    aifs                      - Arbitration Inter Frame Spacing in terms of
+                                number of timeslots. Range 2 to 15
+    txopLimit                 - TXOP Limit in the units of 32 microseconds
+    admissionControlMandatory - Indicates whether the admission control is
+                                mandatory or not. Current release does not
+                                support admission control , hence shall be set
+                                to FALSE.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8  cwMin;
+    CsrUint8  cwMax;
+    CsrUint8  aifs;
+    CsrUint16 txopLimit;
+    CsrBool   admissionControlMandatory;
+} CsrWifiSmeWmmAcParams;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsDeviceType
+
+  DESCRIPTION
+    Structure holding AP WPS device type data.
+
+  MEMBERS
+    deviceDetails - category , sub category etc
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8 deviceDetails[8];
+} CsrWifiSmeWpsDeviceType;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsDeviceTypeCommon
+
+  DESCRIPTION
+
+  MEMBERS
+    spportWps  -
+    deviceType -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrBool  spportWps;
+    CsrUint8 deviceType;
+} CsrWifiSmeWpsDeviceTypeCommon;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsInfo
+
+  DESCRIPTION
+
+  MEMBERS
+    version         -
+    configMethods   -
+    devicePassworId -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint16 version;
+    CsrUint16 configMethods;
+    CsrUint16 devicePassworId;
+} CsrWifiSmeWpsInfo;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCloakedSsidConfig
+
+  DESCRIPTION
+    List of cloaked SSIDs .
+
+  MEMBERS
+    cloakedSsidsCount - Number of cloaked SSID
+    cloakedSsids      - Points to the first byte of the first SSID provided
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8     cloakedSsidsCount;
+    CsrWifiSsid *cloakedSsids;
+} CsrWifiSmeCloakedSsidConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexInfo
+
+  DESCRIPTION
+    Information and state related to coexistence.
+
+  MEMBERS
+    hasTrafficData            - TRUE if any Wi-Fi traffic is detected
+    currentTrafficType        - Current type of traffic
+    currentPeriodMs           - Period of the traffic as detected by the traffic
+                                analysis.
+                                If the traffic is not periodic, it is set to 0.
+    currentPowerSave          - Current power save level
+    currentCoexPeriodMs       - Period of awakening for the firmware used when
+                                periodic traffic is detected.
+                                If the traffic is not periodic, it is set to 0.
+    currentCoexLatencyMs      - Period of awakening for the firmware used when
+                                non-periodic traffic is detected
+    hasBtDevice               - TRUE if there is a Bluetooth device connected
+    currentBlackoutDurationUs - Current blackout duration for protecting
+                                Bluetooth
+    currentBlackoutPeriodUs   - Current blackout period
+    currentCoexScheme         - Defines the scheme for the coexistence
+                                signalling
+
+*******************************************************************************/
+typedef struct
+{
+    CsrBool                  hasTrafficData;
+    CsrWifiSmeTrafficType    currentTrafficType;
+    CsrUint16                currentPeriodMs;
+    CsrWifiSmePowerSaveLevel currentPowerSave;
+    CsrUint16                currentCoexPeriodMs;
+    CsrUint16                currentCoexLatencyMs;
+    CsrBool                  hasBtDevice;
+    CsrUint32                currentBlackoutDurationUs;
+    CsrUint32                currentBlackoutPeriodUs;
+    CsrWifiSmeCoexScheme     currentCoexScheme;
+} CsrWifiSmeCoexInfo;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionConfig
+
+  DESCRIPTION
+    Specifies the parameters that the SME should use in selecting a network.
+
+  MEMBERS
+    ssid
+                   - Service Set identifier
+    bssid
+                   - BSS identifier
+    bssType
+                   - Indicates the type of BSS
+    ifIndex
+                   - Indicates the radio interface
+    privacyMode
+                   - Specifies whether the privacy mode is enabled or disabled.
+    authModeMask
+                   - Sets the authentication options that the SME can use while
+                     associating to the AP
+                     Set mask with values from CsrWifiSmeAuthMode
+    encryptionModeMask
+                   - Sets the encryption options that the SME can use while
+                     associating to the AP
+                     Set mask with values from CsrWifiSmeEncryption
+    mlmeAssociateReqInformationElementsLength
+                   - Length in bytes of information elements to be sent in the
+                     Association Request.
+    mlmeAssociateReqInformationElements
+                   - Points to the first byte of the information elements, if
+                     any.
+    wmmQosInfo
+                   - This parameter allows the driver's WMM behaviour to be
+                     configured.
+                     To enable support for WMM, use
+                     CSR_WIFI_SME_SME_CONFIG_SET_REQ with the
+                     CSR_WIFI_SME_WMM_MODE_AC_ENABLED bit set in wmmModeMask
+                     field in smeConfig parameter.
+                     Set mask with values from CsrWifiSmeWmmQosInfo
+    adhocJoinOnly
+                   - This parameter is relevant only if bssType is NOT set to
+                     CSR_WIFI_SME_BSS_TYPE_INFRASTRUCTURE:
+                     if TRUE the SME will only try to join an ad-hoc network if
+                     there is one already established;
+                     if FALSE the SME will try to join an ad-hoc network if
+                     there is one already established or it will try to
+                     establish a new one
+    adhocChannel
+                   - This parameter is relevant only if bssType is NOT set to
+                     CSR_WIFI_SME_BSS_TYPE_INFRASTRUCTURE:
+                     it indicates the channel to use joining an ad hoc network.
+                     Setting this to 0 causes the SME to select a channel from
+                     those permitted in the regulatory domain.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSsid                ssid;
+    CsrWifiMacAddress          bssid;
+    CsrWifiSmeBssType          bssType;
+    CsrWifiSmeRadioIF          ifIndex;
+    CsrWifiSme80211PrivacyMode privacyMode;
+    CsrWifiSmeAuthModeMask     authModeMask;
+    CsrWifiSmeEncryptionMask   encryptionModeMask;
+    CsrUint16                  mlmeAssociateReqInformationElementsLength;
+    CsrUint8                  *mlmeAssociateReqInformationElements;
+    CsrWifiSmeWmmQosInfoMask   wmmQosInfo;
+    CsrBool                    adhocJoinOnly;
+    CsrUint8                   adhocChannel;
+} CsrWifiSmeConnectionConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionInfo
+
+  DESCRIPTION
+    Parameters that the SME should use in selecting a network
+
+  MEMBERS
+    ssid                        - Service set identifier
+    bssid                       - BSS identifier
+    networkType80211            - Physical layer used for the connection
+    channelNumber               - Channel number
+    channelFrequency            - Channel frequency
+    authMode                    - Authentication mode used for the connection
+    pairwiseCipher              - Encryption type for peer to peer communication
+    groupCipher                 - Encryption type for broadcast and multicast
+                                  communication
+    ifIndex                     - Indicates the radio interface
+    atimWindowTu                - ATIM window specified for IBSS
+    beaconPeriodTu              - Interval between beacon packets
+    reassociation               - Indicates whether a reassociation occurred
+    beaconFrameLength           - Indicates the number of bytes of the beacon
+                                  frame
+    beaconFrame                 - Points at the first byte of the beacon frame
+    associationReqFrameLength   - Indicates the number of bytes of the
+                                  association request frame
+    associationReqFrame         - Points at the first byte of the association
+                                  request frame
+    associationRspFrameLength   - Indicates the number of bytes of the
+                                  association response frame
+    associationRspFrame         - Points at the first byte of the association
+                                  response frame
+    assocScanInfoElementsLength - Indicates the number of bytes in the buffer
+                                  pointed by assocScanInfoElements
+    assocScanInfoElements       - Pointer to the buffer containing the
+                                  information elements of the probe response
+                                  received after the probe requests sent before
+                                  attempting to authenticate to the network
+    assocReqCapabilities        - Reports the content of the Capability
+                                  information element as specified in the
+                                  association request.
+    assocReqListenIntervalTu    - Listen Interval specified in the association
+                                  request
+    assocReqApAddress           - AP address to which the association requests
+                                  has been sent
+    assocReqInfoElementsLength  - Indicates the number of bytes of the
+                                  association request information elements
+    assocReqInfoElements        - Points at the first byte of the association
+                                  request information elements
+    assocRspResult              - Result reported in the association response
+    assocRspCapabilityInfo      - Reports the content of the Capability
+                                  information element as received in the
+                                  association response.
+    assocRspAssociationId       - Reports the association ID received in the
+                                  association response.
+    assocRspInfoElementsLength  - Indicates the number of bytes of the
+                                  association response information elements
+    assocRspInfoElements        - Points at the first byte of the association
+                                  response information elements
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSsid                ssid;
+    CsrWifiMacAddress          bssid;
+    CsrWifiSme80211NetworkType networkType80211;
+    CsrUint8                   channelNumber;
+    CsrUint16                  channelFrequency;
+    CsrWifiSmeAuthMode         authMode;
+    CsrWifiSmeEncryption       pairwiseCipher;
+    CsrWifiSmeEncryption       groupCipher;
+    CsrWifiSmeRadioIF          ifIndex;
+    CsrUint16                  atimWindowTu;
+    CsrUint16                  beaconPeriodTu;
+    CsrBool                    reassociation;
+    CsrUint16                  beaconFrameLength;
+    CsrUint8                  *beaconFrame;
+    CsrUint16                  associationReqFrameLength;
+    CsrUint8                  *associationReqFrame;
+    CsrUint16                  associationRspFrameLength;
+    CsrUint8                  *associationRspFrame;
+    CsrUint16                  assocScanInfoElementsLength;
+    CsrUint8                  *assocScanInfoElements;
+    CsrUint16                  assocReqCapabilities;
+    CsrUint16                  assocReqListenIntervalTu;
+    CsrWifiMacAddress          assocReqApAddress;
+    CsrUint16                  assocReqInfoElementsLength;
+    CsrUint8                  *assocReqInfoElements;
+    CsrWifiSmeIEEE80211Result  assocRspResult;
+    CsrUint16                  assocRspCapabilityInfo;
+    CsrUint16                  assocRspAssociationId;
+    CsrUint16                  assocRspInfoElementsLength;
+    CsrUint8                  *assocRspInfoElements;
+} CsrWifiSmeConnectionInfo;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDeviceConfig
+
+  DESCRIPTION
+    General configuration options in the SME
+
+  MEMBERS
+    trustLevel              - Level of trust of the information coming from the
+                              network
+    countryCode             - Country code as specified by IEEE 802.11 standard
+    firmwareDriverInterface - Specifies the type of communication between Host
+                              and Firmware
+    enableStrictDraftN      - If TRUE TKIP is disallowed when connecting to
+                              802.11n enabled access points
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSme80211dTrustLevel        trustLevel;
+    CsrUint8                          countryCode[2];
+    CsrWifiSmeFirmwareDriverInterface firmwareDriverInterface;
+    CsrBool                           enableStrictDraftN;
+} CsrWifiSmeDeviceConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDeviceInfo
+
+  DESCRIPTION
+    P2P Information for a P2P Device
+
+  MEMBERS
+    deviceAddress            - Device Address of the P2P device
+    configMethods            - Supported WPS configuration methods.
+    p2PDeviceCap             - P2P device capabilities
+    primDeviceType           - Primary WPS device type
+    secondaryDeviceTypeCount - Number of secondary device types
+    secDeviceType            - list of secondary WPS device types
+    deviceName               - Device name without up to 32 characters'\0'.
+    deviceNameLength         - Number of characters of the device name
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiMacAddress           deviceAddress;
+    CsrWifiSmeWpsConfigTypeMask configMethods;
+    CsrWifiSmeP2pCapabilityMask p2PDeviceCap;
+    CsrWifiSmeWpsDeviceType     primDeviceType;
+    CsrUint8                    secondaryDeviceTypeCount;
+    CsrWifiSmeWpsDeviceType    *secDeviceType;
+    CsrUint8                    deviceName[32];
+    CsrUint8                    deviceNameLength;
+} CsrWifiSmeDeviceInfo;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDeviceInfoCommon
+
+  DESCRIPTION
+    Structure holding device information.
+
+  MEMBERS
+    p2pDeviceAddress          -
+    primaryDeviceType         -
+    secondaryDeviceTypesCount -
+    secondaryDeviceTypes      -
+    deviceNameLength          -
+    deviceName                -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiMacAddress             p2pDeviceAddress;
+    CsrWifiSmeWpsDeviceTypeCommon primaryDeviceType;
+    CsrUint8                      secondaryDeviceTypesCount;
+    CsrUint8                      secondaryDeviceTypes[10];
+    CsrUint8                      deviceNameLength;
+    CsrUint8                      deviceName[32];
+} CsrWifiSmeDeviceInfoCommon;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeHostConfig
+
+  DESCRIPTION
+    Defines the host power state (for example, on mains power, on battery
+    power etc) and the periodicity of the traffic data.
+
+  MEMBERS
+    powerMode               - The wireless manager application should use the
+                              powerMode parameter to inform the SME of the host
+                              power state.
+    applicationDataPeriodMs - The applicationDataPeriodMs parameter allows a
+                              wireless manager application to inform the SME
+                              that an application is running that generates
+                              periodic network traffic and the period of the
+                              traffic.
+                              An example of such an application is a VoIP client.
+                              The wireless manager application should set
+                              applicationDataPeriodMs to the period in
+                              milliseconds between data packets or zero if no
+                              periodic application is running.
+                              Voip etc 0 = No Periodic Data
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeHostPowerMode powerMode;
+    CsrUint16               applicationDataPeriodMs;
+} CsrWifiSmeHostConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeKey
+
+  DESCRIPTION
+    Information for a key to be used for encryption
+
+  MEMBERS
+    keyType       - Specifies whether the key is a pairwise or group key; it
+                    should be set to CSR_WIFI_SME_GROUP_KEY or
+                    CSR_WIFI_SME_PAIRWISE_KEY, as required.
+    keyIndex      - Specifies which WEP key (0-3) to set; it should be set to 0
+                    for a WPA/WPA2 pairwise key and non-zero for a WPA/WPA2
+                    group key.
+    wepTxKey      - If wepTxKey is TRUE, and the key is a WEP key, the key will
+                    be selected for encrypting transmitted packets.
+                    To select a previously defined key as the transmit
+                    encryption key, set keyIndex to the required key, wepTxKey
+                    to TRUE and the keyLength to 0.
+    keyRsc        - Key Receive Sequence Counter
+    authenticator - If TRUE the WMA will act as authenticator.
+                    CURRENTLY NOT SUPPORTED
+    address       - BSS identifier of the AP
+    keyLength     - Length of the key in bytes
+    key           - Points to the first byte of the key
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeKeyType keyType;
+    CsrUint8          keyIndex;
+    CsrBool           wepTxKey;
+    CsrUint16         keyRsc[8];
+    CsrBool           authenticator;
+    CsrWifiMacAddress address;
+    CsrUint8          keyLength;
+    CsrUint8          key[32];
+} CsrWifiSmeKey;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeP2pClientInfoType
+
+  DESCRIPTION
+    P2P Information for a P2P Client
+
+  MEMBERS
+    p2PClientInterfaceAddress - MAC address of the P2P Client
+    clientDeviceInfo          - Device Information
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiMacAddress    p2PClientInterfaceAddress;
+    CsrWifiSmeDeviceInfo clientDeviceInfo;
+} CsrWifiSmeP2pClientInfoType;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeP2pGroupInfo
+
+  DESCRIPTION
+    P2P Information for a P2P Group
+
+  MEMBERS
+    groupCapability    - P2P group capabilities
+    p2pDeviceAddress   - Device Address of the GO
+    p2pClientInfoCount - Number of P2P Clients that belong to the group.
+    p2PClientInfo      - Pointer to the list containing client information for
+                         each client in the group
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeP2pGroupCapabilityMask groupCapability;
+    CsrWifiMacAddress                p2pDeviceAddress;
+    CsrUint8                         p2pClientInfoCount;
+    CsrWifiSmeP2pClientInfoType     *p2PClientInfo;
+} CsrWifiSmeP2pGroupInfo;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePowerConfig
+
+  DESCRIPTION
+    Configures the power-save behaviour of the driver and firmware.
+
+  MEMBERS
+    powerSaveLevel         - Power Save Level option
+    listenIntervalTu       - Interval for waking to receive beacon frames
+    rxDtims                - If TRUE, wake for DTIM every beacon period, to
+                             allow the reception broadcast packets
+    d3AutoScanMode         - Defines whether the autonomous scanning will be
+                             turned off or will stay on during a D3 suspended
+                             period
+    clientTrafficWindow    - Deprecated
+    opportunisticPowerSave - Deprecated
+    noticeOfAbsence        - Deprecated
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmePowerSaveLevel powerSaveLevel;
+    CsrUint16                listenIntervalTu;
+    CsrBool                  rxDtims;
+    CsrWifiSmeD3AutoScanMode d3AutoScanMode;
+    CsrUint8                 clientTrafficWindow;
+    CsrBool                  opportunisticPowerSave;
+    CsrBool                  noticeOfAbsence;
+} CsrWifiSmePowerConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamingConfig
+
+  DESCRIPTION
+    Configures the roaming behaviour of the driver and firmware
+
+  MEMBERS
+    roamingBands             - Defines the thresholds to determine the usability
+                               level of the current connection.
+                               roamingBands is indexed by the first 3 entries of
+                               the CsrWifiSmeBasicUsability enum
+    disableSmoothRoaming     - Disable the RSSI/SNR triggers from the Firmware
+                               that the SME uses to detect the quality of the
+                               connection.
+                               This implicitly disables disableRoamScans
+    disableRoamScans         - Disables the scanning for the roaming operation
+    reconnectLimit           - Maximum number of times SME may reconnect in the
+                               given interval
+    reconnectLimitIntervalMs - Interval for maximum number of times SME may
+                               reconnect to the same Access Point
+    roamScanCfg              - Scanning behaviour for the specifically aimed at
+                               improving roaming performance.
+                               roamScanCfg is indexed by the first 3 entries of
+                               the CsrWifiSmeBasicUsability enum
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeRoamingBandData roamingBands[3];
+    CsrBool                   disableSmoothRoaming;
+    CsrBool                   disableRoamScans;
+    CsrUint8                  reconnectLimit;
+    CsrUint16                 reconnectLimitIntervalMs;
+    CsrWifiSmeScanConfigData  roamScanCfg[3];
+} CsrWifiSmeRoamingConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanConfig
+
+  DESCRIPTION
+    Parameters for the autonomous scanning behaviour of the system
+
+  MEMBERS
+    scanCfg                 - Scan configuration data.
+                              Indexed by the CsrWifiSmeBasicUsability enum
+    disableAutonomousScans  - Enables or disables the autonomous scan
+    maxResults              - Maximum number of results to be cached in the SME
+    highRssiThreshold       - High received signal strength indication threshold
+                              in dBm for an AP above which the system will
+                              report scan indications
+    lowRssiThreshold        - Low received signal strength indication threshold
+                              in dBm for an AP below which the system will
+                              report scan indications
+    deltaRssiThreshold      - Minimum difference for received signal strength
+                              indication in dBm for an AP which trigger a scan
+                              indication to be sent.
+    highSnrThreshold        - High Signal to Noise Ratio threshold in dB for an
+                              AP above which the system will report scan
+                              indications
+    lowSnrThreshold         - Low Signal to Noise Ratio threshold in dB for an
+                              AP below which the system will report scan
+                              indications
+    deltaSnrThreshold       - Minimum difference for Signal to Noise Ratio in dB
+                              for an AP which trigger a scan indication to be
+                              sent.
+    passiveChannelListCount - Number of channels to be scanned passively.
+    passiveChannelList      - Points to the first channel to be scanned
+                              passively , if any.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeScanConfigData scanCfg[4];
+    CsrBool                  disableAutonomousScans;
+    CsrUint16                maxResults;
+    CsrInt8                  highRssiThreshold;
+    CsrInt8                  lowRssiThreshold;
+    CsrInt8                  deltaRssiThreshold;
+    CsrInt8                  highSnrThreshold;
+    CsrInt8                  lowSnrThreshold;
+    CsrInt8                  deltaSnrThreshold;
+    CsrUint16                passiveChannelListCount;
+    CsrUint8                *passiveChannelList;
+} CsrWifiSmeScanConfig;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResult
+
+  DESCRIPTION
+    This structure defines the scan result for each BSS found
+
+  MEMBERS
+    ssid                         - Service set identifier
+    bssid                        - BSS identifier
+    rssi                         - Received signal strength indication in dBm
+    snr                          - Signal to noise ratio in dB
+    ifIndex                      - Indicates the radio interface
+    beaconPeriodTu               - Interval between beacon frames
+    timeStamp                    - Timestamp in the BSS
+    localTime                    - Timestamp in the Access Point
+    channelFrequency             - Channel frequency
+    capabilityInformation        - Capabilities of the BSS.
+    channelNumber                - Channel number
+    usability                    - Indicates the usability level.
+    bssType                      - Type of BSS.
+    informationElementsLength    - Number of bytes of the information elements
+                                   received as part of the beacon or probe
+                                   response.
+    informationElements          - Points to the first byte of the IEs received
+                                   as part of the beacon or probe response.
+                                   The format of the IEs is as specified in the
+                                   IEEE 802.11 specification.
+    p2pDeviceRole                - Role of the P2P device.
+                                   Relevant only if bssType is
+                                   CSR_WIFI_SME_BSS_TYPE_P2P
+    deviceInfo                   - Union containing P2P device info which
+                                   depends on p2pDeviceRole parameter.
+    deviceInforeservedCli        -
+    deviceInfogroupInfo          -
+    deviceInforeservedNone       -
+    deviceInfostandalonedevInfo  -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSsid              ssid;
+    CsrWifiMacAddress        bssid;
+    CsrInt16                 rssi;
+    CsrInt16                 snr;
+    CsrWifiSmeRadioIF        ifIndex;
+    CsrUint16                beaconPeriodTu;
+    CsrWifiSmeTsfTime        timeStamp;
+    CsrWifiSmeTsfTime        localTime;
+    CsrUint16                channelFrequency;
+    CsrUint16                capabilityInformation;
+    CsrUint8                 channelNumber;
+    CsrWifiSmeBasicUsability usability;
+    CsrWifiSmeBssType        bssType;
+    CsrUint16                informationElementsLength;
+    CsrUint8                *informationElements;
+    CsrWifiSmeP2pRole        p2pDeviceRole;
+    union {
+        CsrWifiSmeEmpty        reservedCli;
+        CsrWifiSmeP2pGroupInfo groupInfo;
+        CsrWifiSmeEmpty        reservedNone;
+        CsrWifiSmeDeviceInfo   standalonedevInfo;
+    } deviceInfo;
+} CsrWifiSmeScanResult;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWep128Keys
+
+  DESCRIPTION
+    Structure holding WEP Authentication Type and WEP keys that can be used
+    when using WEP128.
+
+  MEMBERS
+    wepAuthType    - Mask to select the WEP authentication type (Open or Shared)
+    selectedWepKey - Index to one of the four keys below indicating the
+                     currently used WEP key. Mapping From SME/User -> firmware.
+                     Key 1 -> Index 0. Key 2 -> Index 1. key 3 -> Index 2. Key
+                     4-> Index 3.
+    key1           - Value for key number 1.
+    key2           - Value for key number 2.
+    key3           - Value for key number 3.
+    key4           - Value for key number 4.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeWepAuthMode wepAuthType;
+    CsrUint8              selectedWepKey;
+    CsrUint8              key1[13];
+    CsrUint8              key2[13];
+    CsrUint8              key3[13];
+    CsrUint8              key4[13];
+} CsrWifiSmeWep128Keys;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWep64Keys
+
+  DESCRIPTION
+    Structure holding WEP Authentication Type and WEP keys that can be used
+    when using WEP64.
+
+  MEMBERS
+    wepAuthType    - Mask to select the WEP authentication type (Open or Shared)
+    selectedWepKey - Index to one of the four keys below indicating the
+                     currently used WEP key. Mapping From SME/User -> firmware.
+                     Key 1 -> Index 0. Key 2 -> Index 1. key 3 -> Index 2. Key
+                     4-> Index 3.
+    key1           - Value for key number 1.
+    key2           - Value for key number 2.
+    key3           - Value for key number 3.
+    key4           - Value for key number 4.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeWepAuthMode wepAuthType;
+    CsrUint8              selectedWepKey;
+    CsrUint8              key1[5];
+    CsrUint8              key2[5];
+    CsrUint8              key3[5];
+    CsrUint8              key4[5];
+} CsrWifiSmeWep64Keys;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWepAuth
+
+  DESCRIPTION
+    WEP authentication parameter structure
+
+  MEMBERS
+    wepKeyType               - WEP key try (128 bit or 64 bit)
+    wepCredentials           - Union containing credentials which depends on
+                               wepKeyType parameter.
+    wepCredentialswep128Key  -
+    wepCredentialswep64Key   -
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiSmeWepCredentialType wepKeyType;
+    union {
+        CsrWifiSmeWep128Keys wep128Key;
+        CsrWifiSmeWep64Keys  wep64Key;
+    } wepCredentials;
+} CsrWifiSmeWepAuth;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsConfig
+
+  DESCRIPTION
+    Structure holding AP WPS Config data.
+
+  MEMBERS
+    wpsVersion               - wpsVersion should be 0x10 for WPS1.0h or 0x20 for
+                               WSC2.0
+    uuid                     - uuid.
+    deviceName               - Device name upto 32 characters without '\0'.
+    deviceNameLength         - deviceNameLen.
+    manufacturer             - manufacturer: CSR
+    manufacturerLength       - manufacturerLen.
+    modelName                - modelName Unifi
+    modelNameLength          - modelNameLen.
+    modelNumber              - modelNumber
+    modelNumberLength        - modelNumberLen.
+    serialNumber             - serialNumber
+    primDeviceType           - Primary WPS device type
+    secondaryDeviceTypeCount - Number of secondary device types
+    secondaryDeviceType      - list of secondary WPS device types
+    configMethods            - Supported WPS config methods
+    rfBands                  - RfBands.
+    osVersion                - Os version on which the device is running
+
+*******************************************************************************/
+typedef struct
+{
+    CsrUint8                    wpsVersion;
+    CsrUint8                    uuid[16];
+    CsrUint8                    deviceName[32];
+    CsrUint8                    deviceNameLength;
+    CsrUint8                    manufacturer[64];
+    CsrUint8                    manufacturerLength;
+    CsrUint8                    modelName[32];
+    CsrUint8                    modelNameLength;
+    CsrUint8                    modelNumber[32];
+    CsrUint8                    modelNumberLength;
+    CsrUint8                    serialNumber[32];
+    CsrWifiSmeWpsDeviceType     primDeviceType;
+    CsrUint8                    secondaryDeviceTypeCount;
+    CsrWifiSmeWpsDeviceType    *secondaryDeviceType;
+    CsrWifiSmeWpsConfigTypeMask configMethods;
+    CsrUint8                    rfBands;
+    CsrUint8                    osVersion[4];
+} CsrWifiSmeWpsConfig;
+
+
+/* Downstream */
+#define CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST            (0x0000)
+
+#define CSR_WIFI_SME_ACTIVATE_REQ                         ((CsrWifiSmePrim) (0x0000 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_ADHOC_CONFIG_GET_REQ                 ((CsrWifiSmePrim) (0x0001 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_ADHOC_CONFIG_SET_REQ                 ((CsrWifiSmePrim) (0x0002 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_BLACKLIST_REQ                        ((CsrWifiSmePrim) (0x0003 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_CALIBRATION_DATA_GET_REQ             ((CsrWifiSmePrim) (0x0004 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_CALIBRATION_DATA_SET_REQ             ((CsrWifiSmePrim) (0x0005 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_CCX_CONFIG_GET_REQ                   ((CsrWifiSmePrim) (0x0006 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_CCX_CONFIG_SET_REQ                   ((CsrWifiSmePrim) (0x0007 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_COEX_CONFIG_GET_REQ                  ((CsrWifiSmePrim) (0x0008 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_COEX_CONFIG_SET_REQ                  ((CsrWifiSmePrim) (0x0009 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_COEX_INFO_GET_REQ                    ((CsrWifiSmePrim) (0x000A + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_CONNECT_REQ                          ((CsrWifiSmePrim) (0x000B + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_CONNECTION_CONFIG_GET_REQ            ((CsrWifiSmePrim) (0x000C + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_CONNECTION_INFO_GET_REQ              ((CsrWifiSmePrim) (0x000D + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_CONNECTION_STATS_GET_REQ             ((CsrWifiSmePrim) (0x000E + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_DEACTIVATE_REQ                       ((CsrWifiSmePrim) (0x000F + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_DISCONNECT_REQ                       ((CsrWifiSmePrim) (0x0010 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_EVENT_MASK_SET_REQ                   ((CsrWifiSmePrim) (0x0011 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_HOST_CONFIG_GET_REQ                  ((CsrWifiSmePrim) (0x0012 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_HOST_CONFIG_SET_REQ                  ((CsrWifiSmePrim) (0x0013 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_KEY_REQ                              ((CsrWifiSmePrim) (0x0014 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_LINK_QUALITY_GET_REQ                 ((CsrWifiSmePrim) (0x0015 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIB_CONFIG_GET_REQ                   ((CsrWifiSmePrim) (0x0016 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIB_CONFIG_SET_REQ                   ((CsrWifiSmePrim) (0x0017 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIB_GET_NEXT_REQ                     ((CsrWifiSmePrim) (0x0018 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIB_GET_REQ                          ((CsrWifiSmePrim) (0x0019 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIB_SET_REQ                          ((CsrWifiSmePrim) (0x001A + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_MULTICAST_ADDRESS_REQ                ((CsrWifiSmePrim) (0x001B + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_PACKET_FILTER_SET_REQ                ((CsrWifiSmePrim) (0x001C + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_PERMANENT_MAC_ADDRESS_GET_REQ        ((CsrWifiSmePrim) (0x001D + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_PMKID_REQ                            ((CsrWifiSmePrim) (0x001E + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_POWER_CONFIG_GET_REQ                 ((CsrWifiSmePrim) (0x001F + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_POWER_CONFIG_SET_REQ                 ((CsrWifiSmePrim) (0x0020 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_INFO_GET_REQ       ((CsrWifiSmePrim) (0x0021 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_ROAMING_CONFIG_GET_REQ               ((CsrWifiSmePrim) (0x0022 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_ROAMING_CONFIG_SET_REQ               ((CsrWifiSmePrim) (0x0023 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_CONFIG_GET_REQ                  ((CsrWifiSmePrim) (0x0024 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_CONFIG_SET_REQ                  ((CsrWifiSmePrim) (0x0025 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_FULL_REQ                        ((CsrWifiSmePrim) (0x0026 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_RESULTS_FLUSH_REQ               ((CsrWifiSmePrim) (0x0027 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_RESULTS_GET_REQ                 ((CsrWifiSmePrim) (0x0028 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_SME_STA_CONFIG_GET_REQ               ((CsrWifiSmePrim) (0x0029 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_SME_STA_CONFIG_SET_REQ               ((CsrWifiSmePrim) (0x002A + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_STATION_MAC_ADDRESS_GET_REQ          ((CsrWifiSmePrim) (0x002B + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_TSPEC_REQ                            ((CsrWifiSmePrim) (0x002C + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_VERSIONS_GET_REQ                     ((CsrWifiSmePrim) (0x002D + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_WIFI_FLIGHTMODE_REQ                  ((CsrWifiSmePrim) (0x002E + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_WIFI_OFF_REQ                         ((CsrWifiSmePrim) (0x002F + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_WIFI_ON_REQ                          ((CsrWifiSmePrim) (0x0030 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_CLOAKED_SSIDS_SET_REQ                ((CsrWifiSmePrim) (0x0031 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_CLOAKED_SSIDS_GET_REQ                ((CsrWifiSmePrim) (0x0032 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_SME_COMMON_CONFIG_GET_REQ            ((CsrWifiSmePrim) (0x0033 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_SME_COMMON_CONFIG_SET_REQ            ((CsrWifiSmePrim) (0x0034 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_INTERFACE_CAPABILITY_GET_REQ         ((CsrWifiSmePrim) (0x0035 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+#define CSR_WIFI_SME_WPS_CONFIGURATION_REQ                ((CsrWifiSmePrim) (0x0036 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST))
+
+
+#define CSR_WIFI_SME_PRIM_DOWNSTREAM_HIGHEST           (0x0036 + CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST)
+
+/* Upstream */
+#define CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST              (0x0000 + CSR_PRIM_UPSTREAM)
+
+#define CSR_WIFI_SME_ACTIVATE_CFM                         ((CsrWifiSmePrim)(0x0000 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_ADHOC_CONFIG_GET_CFM                 ((CsrWifiSmePrim)(0x0001 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_ADHOC_CONFIG_SET_CFM                 ((CsrWifiSmePrim)(0x0002 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_ASSOCIATION_COMPLETE_IND             ((CsrWifiSmePrim)(0x0003 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_ASSOCIATION_START_IND                ((CsrWifiSmePrim)(0x0004 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_BLACKLIST_CFM                        ((CsrWifiSmePrim)(0x0005 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CALIBRATION_DATA_GET_CFM             ((CsrWifiSmePrim)(0x0006 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CALIBRATION_DATA_SET_CFM             ((CsrWifiSmePrim)(0x0007 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CCX_CONFIG_GET_CFM                   ((CsrWifiSmePrim)(0x0008 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CCX_CONFIG_SET_CFM                   ((CsrWifiSmePrim)(0x0009 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_COEX_CONFIG_GET_CFM                  ((CsrWifiSmePrim)(0x000A + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_COEX_CONFIG_SET_CFM                  ((CsrWifiSmePrim)(0x000B + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_COEX_INFO_GET_CFM                    ((CsrWifiSmePrim)(0x000C + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CONNECT_CFM                          ((CsrWifiSmePrim)(0x000D + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CONNECTION_CONFIG_GET_CFM            ((CsrWifiSmePrim)(0x000E + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CONNECTION_INFO_GET_CFM              ((CsrWifiSmePrim)(0x000F + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CONNECTION_QUALITY_IND               ((CsrWifiSmePrim)(0x0010 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CONNECTION_STATS_GET_CFM             ((CsrWifiSmePrim)(0x0011 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_DEACTIVATE_CFM                       ((CsrWifiSmePrim)(0x0012 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_DISCONNECT_CFM                       ((CsrWifiSmePrim)(0x0013 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_EVENT_MASK_SET_CFM                   ((CsrWifiSmePrim)(0x0014 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_HOST_CONFIG_GET_CFM                  ((CsrWifiSmePrim)(0x0015 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_HOST_CONFIG_SET_CFM                  ((CsrWifiSmePrim)(0x0016 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_IBSS_STATION_IND                     ((CsrWifiSmePrim)(0x0017 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_KEY_CFM                              ((CsrWifiSmePrim)(0x0018 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_LINK_QUALITY_GET_CFM                 ((CsrWifiSmePrim)(0x0019 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_MEDIA_STATUS_IND                     ((CsrWifiSmePrim)(0x001A + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIB_CONFIG_GET_CFM                   ((CsrWifiSmePrim)(0x001B + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIB_CONFIG_SET_CFM                   ((CsrWifiSmePrim)(0x001C + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIB_GET_CFM                          ((CsrWifiSmePrim)(0x001D + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIB_GET_NEXT_CFM                     ((CsrWifiSmePrim)(0x001E + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIB_SET_CFM                          ((CsrWifiSmePrim)(0x001F + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_MIC_FAILURE_IND                      ((CsrWifiSmePrim)(0x0020 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_MULTICAST_ADDRESS_CFM                ((CsrWifiSmePrim)(0x0021 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_PACKET_FILTER_SET_CFM                ((CsrWifiSmePrim)(0x0022 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_PERMANENT_MAC_ADDRESS_GET_CFM        ((CsrWifiSmePrim)(0x0023 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_PMKID_CANDIDATE_LIST_IND             ((CsrWifiSmePrim)(0x0024 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_PMKID_CFM                            ((CsrWifiSmePrim)(0x0025 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_POWER_CONFIG_GET_CFM                 ((CsrWifiSmePrim)(0x0026 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_POWER_CONFIG_SET_CFM                 ((CsrWifiSmePrim)(0x0027 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_REGULATORY_DOMAIN_INFO_GET_CFM       ((CsrWifiSmePrim)(0x0028 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_ROAM_COMPLETE_IND                    ((CsrWifiSmePrim)(0x0029 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_ROAM_START_IND                       ((CsrWifiSmePrim)(0x002A + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_ROAMING_CONFIG_GET_CFM               ((CsrWifiSmePrim)(0x002B + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_ROAMING_CONFIG_SET_CFM               ((CsrWifiSmePrim)(0x002C + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_CONFIG_GET_CFM                  ((CsrWifiSmePrim)(0x002D + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_CONFIG_SET_CFM                  ((CsrWifiSmePrim)(0x002E + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_FULL_CFM                        ((CsrWifiSmePrim)(0x002F + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_RESULT_IND                      ((CsrWifiSmePrim)(0x0030 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_RESULTS_FLUSH_CFM               ((CsrWifiSmePrim)(0x0031 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_SCAN_RESULTS_GET_CFM                 ((CsrWifiSmePrim)(0x0032 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_SME_STA_CONFIG_GET_CFM               ((CsrWifiSmePrim)(0x0033 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_SME_STA_CONFIG_SET_CFM               ((CsrWifiSmePrim)(0x0034 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_STATION_MAC_ADDRESS_GET_CFM          ((CsrWifiSmePrim)(0x0035 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_TSPEC_IND                            ((CsrWifiSmePrim)(0x0036 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_TSPEC_CFM                            ((CsrWifiSmePrim)(0x0037 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_VERSIONS_GET_CFM                     ((CsrWifiSmePrim)(0x0038 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_WIFI_FLIGHTMODE_CFM                  ((CsrWifiSmePrim)(0x0039 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_WIFI_OFF_IND                         ((CsrWifiSmePrim)(0x003A + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_WIFI_OFF_CFM                         ((CsrWifiSmePrim)(0x003B + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_WIFI_ON_CFM                          ((CsrWifiSmePrim)(0x003C + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CLOAKED_SSIDS_SET_CFM                ((CsrWifiSmePrim)(0x003D + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CLOAKED_SSIDS_GET_CFM                ((CsrWifiSmePrim)(0x003E + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_WIFI_ON_IND                          ((CsrWifiSmePrim)(0x003F + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_SME_COMMON_CONFIG_GET_CFM            ((CsrWifiSmePrim)(0x0040 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_SME_COMMON_CONFIG_SET_CFM            ((CsrWifiSmePrim)(0x0041 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_INTERFACE_CAPABILITY_GET_CFM         ((CsrWifiSmePrim)(0x0042 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_ERROR_IND                            ((CsrWifiSmePrim)(0x0043 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_INFO_IND                             ((CsrWifiSmePrim)(0x0044 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_CORE_DUMP_IND                        ((CsrWifiSmePrim)(0x0045 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_AMP_STATUS_CHANGE_IND                ((CsrWifiSmePrim)(0x0046 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+#define CSR_WIFI_SME_WPS_CONFIGURATION_CFM                ((CsrWifiSmePrim)(0x0047 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST))
+
+#define CSR_WIFI_SME_PRIM_UPSTREAM_HIGHEST             (0x0047 + CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST)
+
+#define CSR_WIFI_SME_PRIM_DOWNSTREAM_COUNT             (CSR_WIFI_SME_PRIM_DOWNSTREAM_HIGHEST + 1 - CSR_WIFI_SME_PRIM_DOWNSTREAM_LOWEST)
+#define CSR_WIFI_SME_PRIM_UPSTREAM_COUNT               (CSR_WIFI_SME_PRIM_UPSTREAM_HIGHEST   + 1 - CSR_WIFI_SME_PRIM_UPSTREAM_LOWEST)
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeActivateReq
+
+  DESCRIPTION
+    The WMA sends this primitive to activate the SME.
+    The WMA must activate the SME before it can send any other primitive.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeActivateReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAdhocConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the adHocConfig parameter.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeAdhocConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAdhocConfigSetReq
+
+  DESCRIPTION
+    This primitive sets the value of the adHocConfig parameter.
+
+  MEMBERS
+    common      - Common header for use with the CsrWifiFsm Module
+    adHocConfig - Sets the values to use when starting an ad hoc network.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrWifiSmeAdHocConfig adHocConfig;
+} CsrWifiSmeAdhocConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeBlacklistReq
+
+  DESCRIPTION
+    The wireless manager application should call this primitive to notify the
+    driver of any networks that should not be connected to. The interface
+    allows the wireless manager application to query, add, remove, and flush
+    the BSSIDs that the driver may not connect or roam to.
+    When this primitive adds to the black list the BSSID to which the SME is
+    currently connected, the SME will try to roam, if applicable, to another
+    BSSID in the same ESS; if the roaming procedure fails, the SME will
+    disconnect.
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    action          - The value of the CsrWifiSmeListAction parameter instructs
+                      the driver to modify or provide the list of blacklisted
+                      networks.
+    setAddressCount - Number of BSSIDs sent with this primitive
+    setAddresses    - Pointer to the list of BBSIDs sent with the primitive, set
+                      to NULL if none is sent.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrUint16            interfaceTag;
+    CsrWifiSmeListAction action;
+    CsrUint8             setAddressCount;
+    CsrWifiMacAddress   *setAddresses;
+} CsrWifiSmeBlacklistReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCalibrationDataGetReq
+
+  DESCRIPTION
+    This primitive retrieves the Wi-Fi radio calibration data.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeCalibrationDataGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCalibrationDataSetReq
+
+  DESCRIPTION
+    This primitive sets the Wi-Fi radio calibration data.
+    The usage of the primitive with proper calibration data will avoid
+    time-consuming configuration after power-up.
+
+  MEMBERS
+    common                - Common header for use with the CsrWifiFsm Module
+    calibrationDataLength - Number of bytes in the buffer pointed by
+                            calibrationData
+    calibrationData       - Pointer to a buffer of length calibrationDataLength
+                            containing the calibration data
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       calibrationDataLength;
+    CsrUint8       *calibrationData;
+} CsrWifiSmeCalibrationDataSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCcxConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the CcxConfig parameter.
+    CURRENTLY NOT SUPPORTED.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeCcxConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCcxConfigSetReq
+
+  DESCRIPTION
+    This primitive sets the value of the CcxConfig parameter.
+    CURRENTLY NOT SUPPORTED.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    ccxConfig    - Currently not supported
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent     common;
+    CsrUint16           interfaceTag;
+    CsrWifiSmeCcxConfig ccxConfig;
+} CsrWifiSmeCcxConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the CoexConfig parameter.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeCoexConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexConfigSetReq
+
+  DESCRIPTION
+    This primitive sets the value of the CoexConfig parameter.
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    coexConfig - Configures the coexistence behaviour
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrWifiSmeCoexConfig coexConfig;
+} CsrWifiSmeCoexConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexInfoGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the CoexInfo parameter.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeCoexInfoGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectReq
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to start the
+    process of joining an 802.11 wireless network or to start an ad hoc
+    network.
+    The structure pointed by connectionConfig contains parameters describing
+    the network to join or, in case of an ad hoc network, to host or join.
+    The SME will select a network, perform the IEEE 802.11 Join, Authenticate
+    and Associate exchanges.
+    The SME selects the networks from the current scan list that match both
+    the SSID and BSSID, however either or both of these may be the wildcard
+    value. Using this rule, the following operations are possible:
+      * To connect to a network by name, specify the SSID and set the BSSID to
+        0xFF 0xFF 0xFF 0xFF 0xFF 0xFF. If there are two or more networks visible,
+        the SME will select the one with the strongest signal.
+      * To connect to a specific network, specify the BSSID. The SSID is
+        optional, but if given it must match the SSID of the network. An empty
+        SSID may be specified by setting the SSID length to zero. Please note
+        that if the BSSID is specified (i.e. not equal to 0xFF 0xFF 0xFF 0xFF
+        0xFF 0xFF), the SME will not attempt to roam if signal conditions become
+        poor, even if there is an alternative AP with an SSID that matches the
+        current network SSID.
+      * To connect to any network matching the other parameters (i.e. security,
+        etc), set the SSID length to zero and set the BSSID to 0xFF 0xFF 0xFF
+        0xFF 0xFF 0xFF. In this case, the SME will order all available networks
+        by their signal strengths and will iterate through this list until it
+        successfully connects.
+    NOTE: Specifying the BSSID will restrict the selection to one specific
+    network. If SSID and BSSID are given, they must both match the network
+    for it to be selected. To select a network based on the SSID only, the
+    wireless manager application must set the BSSID to 0xFF 0xFF 0xFF 0xFF
+    0xFF 0xFF.
+    The SME will try to connect to each network that matches the provided
+    parameters, one by one, until it succeeds or has tried unsuccessfully
+    with all the matching networks.
+    If there is no network that matches the parameters and the request allows
+    to host an ad hoc network, the SME will advertise a new ad hoc network
+    instead.
+    If the SME cannot connect, it will notify the failure in the confirm.
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    interfaceTag     - Interface Identifier; unique identifier of an interface
+    connectionConfig - Describes the candidate network to join or to host.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent            common;
+    CsrUint16                  interfaceTag;
+    CsrWifiSmeConnectionConfig connectionConfig;
+} CsrWifiSmeConnectReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the ConnectionConfig parameter.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeConnectionConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionInfoGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the ConnectionInfo parameter.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeConnectionInfoGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionStatsGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the ConnectionStats parameter.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeConnectionStatsGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDeactivateReq
+
+  DESCRIPTION
+    The WMA sends this primitive to deactivate the SME.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeDeactivateReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDisconnectReq
+
+  DESCRIPTION
+    The wireless manager application may disconnect from the current network
+    by calling this primitive
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeDisconnectReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeEventMaskSetReq
+
+  DESCRIPTION
+    The wireless manager application may register with the SME to receive
+    notification of interesting events. Indications will be sent only if the
+    wireless manager explicitly registers to be notified of that event.
+    indMask is a bit mask of values defined in CsrWifiSmeIndicationsMask.
+
+  MEMBERS
+    common  - Common header for use with the CsrWifiFsm Module
+    indMask - Set mask with values from CsrWifiSmeIndications
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrWifiSmeIndicationsMask indMask;
+} CsrWifiSmeEventMaskSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeHostConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the hostConfig parameter.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeHostConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeHostConfigSetReq
+
+  DESCRIPTION
+    This primitive sets the value of the hostConfig parameter.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    hostConfig   - Communicates a change of host power state (for example, on
+                   mains power, on battery power etc) and of the periodicity of
+                   traffic data
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrUint16            interfaceTag;
+    CsrWifiSmeHostConfig hostConfig;
+} CsrWifiSmeHostConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeKeyReq
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to add or remove
+    keys that the chip should use for encryption of data.
+    The interface allows the wireless manager application to add and remove
+    keys according to the specified action.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    action       - The value of the CsrWifiSmeListAction parameter instructs the
+                   driver to modify or provide the list of keys.
+                   CSR_WIFI_SME_LIST_ACTION_GET is not supported here.
+    key          - Key to be added or removed
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrUint16            interfaceTag;
+    CsrWifiSmeListAction action;
+    CsrWifiSmeKey        key;
+} CsrWifiSmeKeyReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeLinkQualityGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the LinkQuality parameter.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeLinkQualityGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the MibConfig parameter.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeMibConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibConfigSetReq
+
+  DESCRIPTION
+    This primitive sets the value of the MibConfig parameter.
+
+  MEMBERS
+    common    - Common header for use with the CsrWifiFsm Module
+    mibConfig - Conveys the desired value of various IEEE 802.11 attributes as
+                currently configured
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent     common;
+    CsrWifiSmeMibConfig mibConfig;
+} CsrWifiSmeMibConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibGetNextReq
+
+  DESCRIPTION
+    To read a sequence of MIB parameters, for example a table, call this
+    primitive to find the name of the next MIB variable
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    mibAttributeLength - Length of mibAttribute
+    mibAttribute       - Points to a VarBind or VarBindList containing the
+                         name(s) of the MIB variable(s) to search from.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       mibAttributeLength;
+    CsrUint8       *mibAttribute;
+} CsrWifiSmeMibGetNextReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibGetReq
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to retrieve one or
+    more MIB variables.
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    mibAttributeLength - Length of mibAttribute
+    mibAttribute       - Points to the VarBind or VarBindList containing the
+                         names of the MIB variables to be retrieved
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       mibAttributeLength;
+    CsrUint8       *mibAttribute;
+} CsrWifiSmeMibGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibSetReq
+
+  DESCRIPTION
+    The SME provides raw access to the MIB on the chip, which may be used by
+    some configuration or diagnostic utilities, but is not normally needed by
+    the wireless manager application.
+    The MIB access functions use BER encoded names (OID) of the MIB
+    parameters and BER encoded values, as described in the chip Host
+    Interface Protocol Specification.
+    The MIB parameters are described in 'Wi-Fi 5.0.0 Management Information
+    Base Reference Guide'.
+    The wireless manager application calls this primitive to set one or more
+    MIB variables
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    mibAttributeLength - Length of mibAttribute
+    mibAttribute       - Points to the VarBind or VarBindList containing the
+                         names and values of the MIB variables to set
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       mibAttributeLength;
+    CsrUint8       *mibAttribute;
+} CsrWifiSmeMibSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMulticastAddressReq
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to specify the
+    multicast addresses which the chip should recognise. The interface allows
+    the wireless manager application to query, add, remove and flush the
+    multicast addresses for the network interface according to the specified
+    action.
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    interfaceTag      - Interface Identifier; unique identifier of an interface
+    action            - The value of the CsrWifiSmeListAction parameter
+                        instructs the driver to modify or provide the list of
+                        MAC addresses.
+    setAddressesCount - Number of MAC addresses sent with the primitive
+    setAddresses      - Pointer to the list of MAC Addresses sent with the
+                        primitive, set to NULL if none is sent.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrUint16            interfaceTag;
+    CsrWifiSmeListAction action;
+    CsrUint8             setAddressesCount;
+    CsrWifiMacAddress   *setAddresses;
+} CsrWifiSmeMulticastAddressReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePacketFilterSetReq
+
+  DESCRIPTION
+    The wireless manager application should call this primitive to enable or
+    disable filtering of broadcast packets: uninteresting broadcast packets
+    will be dropped by the Wi-Fi chip, instead of passing them up to the
+    host.
+    This has the advantage of saving power in the host application processor
+    as it removes the need to process unwanted packets.
+    All broadcast packets are filtered according to the filter and the filter
+    mode provided, except ARP packets, which are filtered using
+    arpFilterAddress.
+    Filters are not cumulative: only the parameters specified in the most
+    recent successful request are significant.
+    For more information, see 'UniFi Firmware API Specification'.
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    interfaceTag     - Interface Identifier; unique identifier of an interface
+    filterLength     - Length of the filter in bytes.
+                       filterLength=0 disables the filter previously set
+    filter           - Points to the first byte of the filter provided, if any.
+                       This shall include zero or more instance of the
+                       information elements of one of these types
+                         * Traffic Classification (TCLAS) elements
+                         * WMM-SA TCLAS elements
+    mode             - Specifies whether the filter selects or excludes packets
+                       matching the filter
+    arpFilterAddress - IPv4 address to be used for filtering the ARP packets.
+                         * If the specified address is the IPv4 broadcast address
+                           (255.255.255.255), all ARP packets are reported to the
+                           host,
+                         * If the specified address is NOT the IPv4 broadcast
+                           address, only ARP packets with the specified address in
+                           the Source or Target Protocol Address fields are reported
+                           to the host
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent            common;
+    CsrUint16                  interfaceTag;
+    CsrUint16                  filterLength;
+    CsrUint8                  *filter;
+    CsrWifiSmePacketFilterMode mode;
+    CsrWifiIp4Address          arpFilterAddress;
+} CsrWifiSmePacketFilterSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePermanentMacAddressGetReq
+
+  DESCRIPTION
+    This primitive retrieves the MAC address stored in EEPROM
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmePermanentMacAddressGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePmkidReq
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to request an
+    operation on the SME PMKID list.
+    The action argument specifies the operation to perform.
+    When the connection is complete, the wireless manager application may
+    then send and receive EAPOL packets to complete WPA or WPA2
+    authentication if appropriate.
+    The wireless manager application can then pass the resulting encryption
+    keys using this primitive.
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    action         - The value of the CsrWifiSmeListAction parameter instructs
+                     the driver to modify or provide the list of PMKIDs.
+    setPmkidsCount - Number of PMKIDs sent with the primitive
+    setPmkids      - Pointer to the list of PMKIDs sent with the primitive, set
+                     to NULL if none is sent.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrUint16            interfaceTag;
+    CsrWifiSmeListAction action;
+    CsrUint8             setPmkidsCount;
+    CsrWifiSmePmkid     *setPmkids;
+} CsrWifiSmePmkidReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePowerConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the PowerConfig parameter.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmePowerConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePowerConfigSetReq
+
+  DESCRIPTION
+    This primitive sets the value of the PowerConfig parameter.
+
+  MEMBERS
+    common      - Common header for use with the CsrWifiFsm Module
+    powerConfig - Power saving configuration
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrWifiSmePowerConfig powerConfig;
+} CsrWifiSmePowerConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRegulatoryDomainInfoGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the RegulatoryDomainInfo parameter.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeRegulatoryDomainInfoGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamingConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the RoamingConfig parameter.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeRoamingConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamingConfigSetReq
+
+  DESCRIPTION
+    This primitive sets the value of the RoamingConfig parameter.
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    roamingConfig - Desired roaming behaviour values
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent         common;
+    CsrUint16               interfaceTag;
+    CsrWifiSmeRoamingConfig roamingConfig;
+} CsrWifiSmeRoamingConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the ScanConfig parameter.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeScanConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanConfigSetReq
+
+  DESCRIPTION
+    This primitive sets the value of the ScanConfig parameter.
+    The SME normally configures the firmware to perform autonomous scanning
+    without involving the host.
+    The firmware passes beacon / probe response or indicates loss of beacon
+    on certain changes of state, for example:
+      * A new AP is seen for the first time
+      * An AP is no longer visible
+      * The signal strength of an AP changes by more than a certain amount, as
+        configured by the thresholds in the scanConfig parameter
+    In addition to the autonomous scan, the wireless manager application may
+    request a scan at any time using CSR_WIFI_SME_SCAN_FULL_REQ.
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    scanConfig - Reports the configuration for the autonomous scanning behaviour
+                 of the firmware
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrWifiSmeScanConfig scanConfig;
+} CsrWifiSmeScanConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanFullReq
+
+  DESCRIPTION
+    The wireless manager application should call this primitive to request a
+    full scan.
+    Channels are scanned actively or passively according to the requirement
+    set by regulatory domain.
+    If the SME receives this primitive while a full scan is going on, the new
+    request is buffered and it will be served after the current full scan is
+    completed.
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    ssidCount        - Number of SSIDs provided.
+                       If it is 0, the SME will attempt to detect any network
+    ssid             - Points to the first SSID provided, if any.
+    bssid            - BSS identifier.
+                       If it is equal to FF-FF-FF-FF-FF, the SME will listen for
+                       messages from any BSS.
+                       If it is different from FF-FF-FF-FF-FF and any SSID is
+                       provided, one SSID must match the network of the BSS.
+    forceScan        - Forces the scan even if the SME is in a state which would
+                       normally prevent it (e.g. autonomous scan is running).
+    bssType          - Type of BSS to scan for
+    scanType         - Type of scan to perform
+    channelListCount - Number of channels provided.
+                       If it is 0, the SME will initiate a scan of all the
+                       supported channels that are permitted by the current
+                       regulatory domain.
+    channelList      - Points to the first channel , or NULL if channelListCount
+                       is zero.
+    probeIeLength    - Length of the information element in bytes to be sent
+                       with the probe message.
+    probeIe          - Points to the first byte of the information element to be
+                       sent with the probe message.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent    common;
+    CsrUint8           ssidCount;
+    CsrWifiSsid       *ssid;
+    CsrWifiMacAddress  bssid;
+    CsrBool            forceScan;
+    CsrWifiSmeBssType  bssType;
+    CsrWifiSmeScanType scanType;
+    CsrUint16          channelListCount;
+    CsrUint8          *channelList;
+    CsrUint16          probeIeLength;
+    CsrUint8          *probeIe;
+} CsrWifiSmeScanFullReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResultsFlushReq
+
+  DESCRIPTION
+    The Wireless Manager calls this primitive to ask the SME to delete all
+    scan results from its cache, except for the scan result of any currently
+    connected network.
+    As scan results are received by the SME from the firmware, they are
+    cached in the SME memory.
+    Any time the Wireless Manager requests scan results, they are returned
+    from the SME internal cache.
+    For some applications it may be desirable to clear this cache prior to
+    requesting that a scan be performed; this will ensure that the cache then
+    only contains the networks detected in the most recent scan.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeScanResultsFlushReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResultsGetReq
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to retrieve the
+    current set of scan results, either after receiving a successful
+    CSR_WIFI_SME_SCAN_FULL_CFM, or to get autonomous scan results.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeScanResultsGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeStaConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the SmeStaConfig parameter.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+} CsrWifiSmeSmeStaConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeStaConfigSetReq
+
+  DESCRIPTION
+    This primitive sets the value of the SmeConfig parameter.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    smeConfig    - SME Station Parameters to be set
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent     common;
+    CsrUint16           interfaceTag;
+    CsrWifiSmeStaConfig smeConfig;
+} CsrWifiSmeSmeStaConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeStationMacAddressGetReq
+
+  DESCRIPTION
+    This primitives is used to retrieve the current MAC address used by the
+    station.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeStationMacAddressGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTspecReq
+
+  DESCRIPTION
+    The wireless manager application should call this primitive to use the
+    TSPEC feature.
+    The chip supports the use of TSPECs and TCLAS for the use of IEEE
+    802.11/WMM Quality of Service features.
+    The API allows the wireless manager application to supply a correctly
+    formatted TSPEC and TCLAS pair to the driver.
+    After performing basic validation, the driver negotiates the installation
+    of the TSPEC with the AP as defined by the 802.11 specification.
+    The driver retains all TSPEC and TCLAS pairs until they are specifically
+    removed.
+    It is not compulsory for a TSPEC to have a TCLAS (NULL is used to
+    indicate that no TCLAS is supplied), while a TCLASS always require a
+    TSPEC.
+    The format of the TSPEC element is specified in 'WMM (including WMM Power
+    Save) Specification - Version 1.1' and 'ANSI/IEEE Std 802.11-REVmb/D3.0'.
+    For more information, see 'UniFi Configuring WMM and WMM-PS'.
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    action        - Specifies the action to be carried out on the list of TSPECs.
+                    CSR_WIFI_SME_LIST_ACTION_FLUSH is not applicable here.
+    transactionId - Unique Transaction ID for the TSPEC, as assigned by the
+                    driver
+    strict        - If it set to false, allows the SME to perform automatic
+                    TSPEC negotiation
+    ctrlMask      - Additional TSPEC configuration for CCX.
+                    Set mask with values from CsrWifiSmeTspecCtrl.
+                    CURRENTLY NOT SUPPORTED
+    tspecLength   - Length of the TSPEC.
+    tspec         - Points to the first byte of the TSPEC
+    tclasLength   - Length of the TCLAS.
+                    If it is equal to 0, no TCLASS is provided for the TSPEC
+    tclas         - Points to the first byte of the TCLAS, if any.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent         common;
+    CsrUint16               interfaceTag;
+    CsrWifiSmeListAction    action;
+    CsrUint32               transactionId;
+    CsrBool                 strict;
+    CsrWifiSmeTspecCtrlMask ctrlMask;
+    CsrUint16               tspecLength;
+    CsrUint8               *tspec;
+    CsrUint16               tclasLength;
+    CsrUint8               *tclas;
+} CsrWifiSmeTspecReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeVersionsGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the Versions parameter.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeVersionsGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiFlightmodeReq
+
+  DESCRIPTION
+    The wireless manager application may call this primitive on boot-up of
+    the platform to ensure that the chip is placed in a mode that prevents
+    any emission of RF energy.
+    This primitive is an alternative to CSR_WIFI_SME_WIFI_ON_REQ.
+    As in CSR_WIFI_SME_WIFI_ON_REQ, it causes the download of the patch file
+    (if any) and the programming of the initial MIB settings (if supplied by
+    the WMA), but it also ensures that the chip is left in its lowest
+    possible power-mode with the radio subsystems disabled.
+    This feature is useful on platforms where power cannot be removed from
+    the chip (leaving the chip not initialised will cause it to consume more
+    power so calling this function ensures that the chip is initialised into
+    a low power mode but without entering a state where it could emit any RF
+    energy).
+    NOTE: this primitive does not cause the Wi-Fi to change state: Wi-Fi
+    stays conceptually off. Configuration primitives can be sent after
+    CSR_WIFI_SME_WIFI_FLIGHTMODE_REQ and the configuration will be maintained.
+    Requests that require the state of the Wi-Fi to be ON will return
+    CSR_WIFI_SME_STATUS_WIFI_OFF in their confirms.
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    address       - Optionally specifies a station MAC address.
+                    In normal use, the manager should set the address to 0xFF
+                    0xFF 0xFF 0xFF 0xFF 0xFF, which will cause the chip to use
+                    the MAC address in the MIB.
+    mibFilesCount - Number of provided data blocks with initial MIB values
+    mibFiles      - Points to the first data block with initial MIB values.
+                    These data blocks are typically the contents of the provided
+                    files ufmib.dat and localmib.dat, available from the host
+                    file system, if they exist.
+                    These files typically contain radio tuning and calibration
+                    values.
+                    More values can be created using the Host Tools.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrWifiMacAddress    address;
+    CsrUint16            mibFilesCount;
+    CsrWifiSmeDataBlock *mibFiles;
+} CsrWifiSmeWifiFlightmodeReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOffReq
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to turn off the
+    chip, thus saving power when Wi-Fi is not in use.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeWifiOffReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOnReq
+
+  DESCRIPTION
+    The wireless manager application calls this primitive to turn on the
+    Wi-Fi chip.
+    If the Wi-Fi chip is currently off, the SME turns the Wi-Fi chip on,
+    downloads the patch file (if any), and programs the initial MIB settings
+    (if supplied by the WMA).
+    The patch file is not provided with the SME API; its downloading is
+    automatic and handled internally by the system.
+    The MIB settings, when provided, override the default values that the
+    firmware loads from EEPROM.
+    If the Wi-Fi chip is already on, the SME takes no action and returns a
+    successful status in the confirm.
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    address       - Optionally specifies a station MAC address.
+                    In normal use, the manager should set the address to 0xFF
+                    0xFF 0xFF 0xFF 0xFF 0xFF, which will cause the chip to use
+                    the MAC address in the MIB
+    mibFilesCount - Number of provided data blocks with initial MIB values
+    mibFiles      - Points to the first data block with initial MIB values.
+                    These data blocks are typically the contents of the provided
+                    files ufmib.dat and localmib.dat, available from the host
+                    file system, if they exist.
+                    These files typically contain radio tuning and calibration
+                    values.
+                    More values can be created using the Host Tools.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrWifiMacAddress    address;
+    CsrUint16            mibFilesCount;
+    CsrWifiSmeDataBlock *mibFiles;
+} CsrWifiSmeWifiOnReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCloakedSsidsSetReq
+
+  DESCRIPTION
+    This primitive sets the list of cloaked SSIDs for which the WMA possesses
+    profiles.
+    When the driver detects a cloaked AP, the SME will explicitly scan for it
+    using the list of cloaked SSIDs provided it, and, if the scan succeeds,
+    it will report the AP to the WMA either via CSR_WIFI_SME_SCAN_RESULT_IND
+    (if registered) or via CSR_WIFI_SCAN_RESULT_GET_CFM.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    cloakedSsids - Sets the list of cloaked SSIDs
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent             common;
+    CsrWifiSmeCloakedSsidConfig cloakedSsids;
+} CsrWifiSmeCloakedSsidsSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCloakedSsidsGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the CloakedSsids parameter.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeCloakedSsidsGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeCommonConfigGetReq
+
+  DESCRIPTION
+    This primitive gets the value of the Sme common parameter.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeSmeCommonConfigGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeCommonConfigSetReq
+
+  DESCRIPTION
+    This primitive sets the value of the Sme common.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    deviceConfig - Configuration options in the SME
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent        common;
+    CsrWifiSmeDeviceConfig deviceConfig;
+} CsrWifiSmeSmeCommonConfigSetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeInterfaceCapabilityGetReq
+
+  DESCRIPTION
+    The Wireless Manager calls this primitive to ask the SME for the
+    capabilities of the supported interfaces
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+} CsrWifiSmeInterfaceCapabilityGetReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsConfigurationReq
+
+  DESCRIPTION
+    This primitive passes the WPS information for the device to SME. This may
+    be accepted only if no interface is active.
+
+  MEMBERS
+    common    - Common header for use with the CsrWifiFsm Module
+    wpsConfig - WPS config.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent     common;
+    CsrWifiSmeWpsConfig wpsConfig;
+} CsrWifiSmeWpsConfigurationReq;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeActivateCfm
+
+  DESCRIPTION
+    The SME sends this primitive when the activation is complete.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeActivateCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAdhocConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common      - Common header for use with the CsrWifiFsm Module
+    status      - Reports the result of the request
+    adHocConfig - Contains the values used when starting an Ad-hoc (IBSS)
+                  connection.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrResult             status;
+    CsrWifiSmeAdHocConfig adHocConfig;
+} CsrWifiSmeAdhocConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAdhocConfigSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeAdhocConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAssociationCompleteInd
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive it whenever it completes an attempt to associate with an AP. If
+    the association was successful, status will be set to
+    CSR_WIFI_SME_STATUS_SUCCESS, otherwise status and deauthReason shall be
+    set to appropriate error codes.
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    status         - Reports the result of the association procedure
+    connectionInfo - This parameter is relevant only if result is
+                     CSR_WIFI_SME_STATUS_SUCCESS:
+                     it points to the connection information for the new network
+    deauthReason   - This parameter is relevant only if result is not
+                     CSR_WIFI_SME_STATUS_SUCCESS:
+                     if the AP deauthorised the station, it gives the reason of
+                     the deauthorization
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrResult                 status;
+    CsrWifiSmeConnectionInfo  connectionInfo;
+    CsrWifiSmeIEEE80211Reason deauthReason;
+} CsrWifiSmeAssociationCompleteInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAssociationStartInd
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive it whenever it begins an attempt to associate with an AP.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    address      - BSSID of the associating network
+    ssid         - Service Set identifier of the associating network
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrUint16         interfaceTag;
+    CsrWifiMacAddress address;
+    CsrWifiSsid       ssid;
+} CsrWifiSmeAssociationStartInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeBlacklistCfm
+
+  DESCRIPTION
+    The SME will call this primitive when the action on the blacklist has
+    completed. For a GET action, this primitive also reports the list of
+    BBSIDs in the blacklist.
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    status          - Reports the result of the request
+    action          - Action in the request
+    getAddressCount - This parameter is only relevant if action is
+                      CSR_WIFI_SME_LIST_ACTION_GET:
+                      number of BSSIDs sent with this primitive
+    getAddresses    - Pointer to the list of BBSIDs sent with the primitive, set
+                      to NULL if none is sent.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrUint16            interfaceTag;
+    CsrResult            status;
+    CsrWifiSmeListAction action;
+    CsrUint8             getAddressCount;
+    CsrWifiMacAddress   *getAddresses;
+} CsrWifiSmeBlacklistCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCalibrationDataGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common                - Common header for use with the CsrWifiFsm Module
+    status                - Reports the result of the request
+    calibrationDataLength - Number of bytes in the buffer pointed by
+                            calibrationData
+    calibrationData       - Pointer to a buffer of length calibrationDataLength
+                            containing the calibration data
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+    CsrUint16       calibrationDataLength;
+    CsrUint8       *calibrationData;
+} CsrWifiSmeCalibrationDataGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCalibrationDataSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeCalibrationDataSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCcxConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+    ccxConfig    - Currently not supported
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent     common;
+    CsrUint16           interfaceTag;
+    CsrResult           status;
+    CsrWifiSmeCcxConfig ccxConfig;
+} CsrWifiSmeCcxConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCcxConfigSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeCcxConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    status     - Reports the result of the request
+    coexConfig - Reports the parameters used to configure the coexistence
+                 behaviour
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrResult            status;
+    CsrWifiSmeCoexConfig coexConfig;
+} CsrWifiSmeCoexConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexConfigSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeCoexConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoexInfoGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common   - Common header for use with the CsrWifiFsm Module
+    status   - Reports the result of the request
+    coexInfo - Reports information and state related to coexistence.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent    common;
+    CsrResult          status;
+    CsrWifiSmeCoexInfo coexInfo;
+} CsrWifiSmeCoexInfoGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectCfm
+
+  DESCRIPTION
+    The SME calls this primitive when the connection exchange is complete or
+    all connection attempts fail.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request.
+                   CSR_WIFI_SME_STATUS_NOT_FOUND: all attempts by the SME to
+                   locate the requested AP failed
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeConnectCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    interfaceTag     - Interface Identifier; unique identifier of an interface
+    status           - Reports the result of the request
+    connectionConfig - Parameters used by the SME for selecting a network
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent            common;
+    CsrUint16                  interfaceTag;
+    CsrResult                  status;
+    CsrWifiSmeConnectionConfig connectionConfig;
+} CsrWifiSmeConnectionConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionInfoGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    status         - Reports the result of the request
+    connectionInfo - Information about the current connection
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent          common;
+    CsrUint16                interfaceTag;
+    CsrResult                status;
+    CsrWifiSmeConnectionInfo connectionInfo;
+} CsrWifiSmeConnectionInfoGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionQualityInd
+
+  DESCRIPTION
+    The SME sends this primitive to all the tasks that have registered to
+    receive it whenever the value of the current connection quality
+    parameters change by more than a certain configurable amount.
+    The wireless manager application may configure the trigger thresholds for
+    this indication using the field in smeConfig parameter of
+    CSR_WIFI_SME_SME_CONFIG_SET_REQ.
+    Connection quality messages can be suppressed by setting both thresholds
+    to zero.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    linkQuality  - Indicates the quality of the link
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrUint16             interfaceTag;
+    CsrWifiSmeLinkQuality linkQuality;
+} CsrWifiSmeConnectionQualityInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeConnectionStatsGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    status          - Reports the result of the request
+    connectionStats - Statistics for current connection.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrResult                 status;
+    CsrWifiSmeConnectionStats connectionStats;
+} CsrWifiSmeConnectionStatsGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDeactivateCfm
+
+  DESCRIPTION
+    The SME sends this primitive when the deactivation is complete.
+    The WMA cannot send any more primitives until it actives the SME again
+    sending another CSR_WIFI_SME_ACTIVATE_REQ.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeDeactivateCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeDisconnectCfm
+
+  DESCRIPTION
+    On reception of CSR_WIFI_SME_DISCONNECT_REQ the SME will perform a
+    disconnect operation, sending a CsrWifiSmeMediaStatusInd with
+    CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED and then call this primitive when
+    disconnection is complete.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeDisconnectCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeEventMaskSetCfm
+
+  DESCRIPTION
+    The SME calls the primitive to report the result of the request
+    primitive.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeEventMaskSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeHostConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+    hostConfig   - Current host power state.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrUint16            interfaceTag;
+    CsrResult            status;
+    CsrWifiSmeHostConfig hostConfig;
+} CsrWifiSmeHostConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeHostConfigSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeHostConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeIbssStationInd
+
+  DESCRIPTION
+    The SME will send this primitive to indicate that a station has joined or
+    left the ad-hoc network.
+
+  MEMBERS
+    common      - Common header for use with the CsrWifiFsm Module
+    address     - MAC address of the station that has joined or left
+    isconnected - TRUE if the station joined, FALSE if the station left
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrWifiMacAddress address;
+    CsrBool           isconnected;
+} CsrWifiSmeIbssStationInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeKeyCfm
+
+  DESCRIPTION
+    The SME calls the primitive to report the result of the request
+    primitive.
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    status         - Reports the result of the request
+    action         - Action in the request
+    keyType        - Type of the key added/deleted
+    peerMacAddress - Peer MAC Address of the key added/deleted
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrUint16            interfaceTag;
+    CsrResult            status;
+    CsrWifiSmeListAction action;
+    CsrWifiSmeKeyType    keyType;
+    CsrWifiMacAddress    peerMacAddress;
+} CsrWifiSmeKeyCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeLinkQualityGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+    linkQuality  - Indicates the quality of the link
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrUint16             interfaceTag;
+    CsrResult             status;
+    CsrWifiSmeLinkQuality linkQuality;
+} CsrWifiSmeLinkQualityGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMediaStatusInd
+
+  DESCRIPTION
+    The SME sends this primitive to all the tasks that have registered to
+    receive it when a network connection is established, lost or has moved to
+    another AP.
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    mediaStatus    - Indicates the media status
+    connectionInfo - This parameter is relevant only if the mediaStatus is
+                     CSR_WIFI_SME_MEDIA_STATUS_CONNECTED:
+                     it points to the connection information for the new network
+    disassocReason - This parameter is relevant only if the mediaStatus is
+                     CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED:
+                     if a disassociation has occurred it gives the reason of the
+                     disassociation
+    deauthReason   - This parameter is relevant only if the mediaStatus is
+                     CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED:
+                     if a deauthentication has occurred it gives the reason of
+                     the deauthentication
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrWifiSmeMediaStatus     mediaStatus;
+    CsrWifiSmeConnectionInfo  connectionInfo;
+    CsrWifiSmeIEEE80211Reason disassocReason;
+    CsrWifiSmeIEEE80211Reason deauthReason;
+} CsrWifiSmeMediaStatusInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common    - Common header for use with the CsrWifiFsm Module
+    status    - Reports the result of the request
+    mibConfig - Reports various IEEE 802.11 attributes as currently configured
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent     common;
+    CsrResult           status;
+    CsrWifiSmeMibConfig mibConfig;
+} CsrWifiSmeMibConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibConfigSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeMibConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibGetCfm
+
+  DESCRIPTION
+    The SME calls this primitive to return the requested MIB variable values.
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    status             - Reports the result of the request
+    mibAttributeLength - Length of mibAttribute
+    mibAttribute       - Points to the VarBind or VarBindList containing the
+                         names and values of the MIB variables requested
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+    CsrUint16       mibAttributeLength;
+    CsrUint8       *mibAttribute;
+} CsrWifiSmeMibGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibGetNextCfm
+
+  DESCRIPTION
+    The SME calls this primitive to return the requested MIB name(s).
+    The wireless manager application can then read the value of the MIB
+    variable using CSR_WIFI_SME_MIB_GET_REQ, using the names provided.
+
+  MEMBERS
+    common             - Common header for use with the CsrWifiFsm Module
+    status             - Reports the result of the request
+    mibAttributeLength - Length of mibAttribute
+    mibAttribute       - Points to a VarBind or VarBindList containing the
+                         name(s) of the MIB variable(s) lexicographically
+                         following the name(s) given in the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+    CsrUint16       mibAttributeLength;
+    CsrUint8       *mibAttribute;
+} CsrWifiSmeMibGetNextCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMibSetCfm
+
+  DESCRIPTION
+    The SME calls the primitive to report the result of the set primitive.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeMibSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMicFailureInd
+
+  DESCRIPTION
+    The SME sends this primitive to all the tasks that have registered to
+    receive it whenever the chip firmware reports a MIC failure.
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    secondFailure - TRUE if this indication is for a second failure in 60
+                    seconds
+    count         - The number of MIC failure events since the connection was
+                    established
+    address       - MAC address of the transmitter that caused the MIC failure
+    keyType       - Type of key for which the failure occurred
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrUint16         interfaceTag;
+    CsrBool           secondFailure;
+    CsrUint16         count;
+    CsrWifiMacAddress address;
+    CsrWifiSmeKeyType keyType;
+} CsrWifiSmeMicFailureInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeMulticastAddressCfm
+
+  DESCRIPTION
+    The SME will call this primitive when the operation is complete. For a
+    GET action, this primitive reports the current list of MAC addresses.
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    interfaceTag      - Interface Identifier; unique identifier of an interface
+    status            - Reports the result of the request
+    action            - Action in the request
+    getAddressesCount - This parameter is only relevant if action is
+                        CSR_WIFI_SME_LIST_ACTION_GET:
+                        number of MAC addresses sent with the primitive
+    getAddresses      - Pointer to the list of MAC Addresses sent with the
+                        primitive, set to NULL if none is sent.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrUint16            interfaceTag;
+    CsrResult            status;
+    CsrWifiSmeListAction action;
+    CsrUint8             getAddressesCount;
+    CsrWifiMacAddress   *getAddresses;
+} CsrWifiSmeMulticastAddressCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePacketFilterSetCfm
+
+  DESCRIPTION
+    The SME calls the primitive to report the result of the set primitive.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmePacketFilterSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePermanentMacAddressGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common              - Common header for use with the CsrWifiFsm Module
+    status              - Reports the result of the request
+    permanentMacAddress - MAC address stored in the EEPROM
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrResult         status;
+    CsrWifiMacAddress permanentMacAddress;
+} CsrWifiSmePermanentMacAddressGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePmkidCandidateListInd
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive it when a new network supporting preauthentication and/or PMK
+    caching is seen.
+
+  MEMBERS
+    common               - Common header for use with the CsrWifiFsm Module
+    interfaceTag         - Interface Identifier; unique identifier of an
+                           interface
+    pmkidCandidatesCount - Number of PMKID candidates provided
+    pmkidCandidates      - Points to the first PMKID candidate
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrUint8                  pmkidCandidatesCount;
+    CsrWifiSmePmkidCandidate *pmkidCandidates;
+} CsrWifiSmePmkidCandidateListInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePmkidCfm
+
+  DESCRIPTION
+    The SME will call this primitive when the operation is complete. For a
+    GET action, this primitive reports the current list of PMKIDs
+
+  MEMBERS
+    common         - Common header for use with the CsrWifiFsm Module
+    interfaceTag   - Interface Identifier; unique identifier of an interface
+    status         - Reports the result of the request
+    action         - Action in the request
+    getPmkidsCount - This parameter is only relevant if action is
+                     CSR_WIFI_SME_LIST_ACTION_GET:
+                     number of PMKIDs sent with the primitive
+    getPmkids      - Pointer to the list of PMKIDs sent with the primitive, set
+                     to NULL if none is sent.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrUint16            interfaceTag;
+    CsrResult            status;
+    CsrWifiSmeListAction action;
+    CsrUint8             getPmkidsCount;
+    CsrWifiSmePmkid     *getPmkids;
+} CsrWifiSmePmkidCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePowerConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common      - Common header for use with the CsrWifiFsm Module
+    status      - Reports the result of the request
+    powerConfig - Returns the current parameters for the power configuration of
+                  the firmware
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrResult             status;
+    CsrWifiSmePowerConfig powerConfig;
+} CsrWifiSmePowerConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmePowerConfigSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmePowerConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRegulatoryDomainInfoGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    status     - Reports the result of the request
+    regDomInfo - Reports information and state related to regulatory domain
+                 operation.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent                common;
+    CsrResult                      status;
+    CsrWifiSmeRegulatoryDomainInfo regDomInfo;
+} CsrWifiSmeRegulatoryDomainInfoGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamCompleteInd
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive it whenever it completes an attempt to roam to an AP. If the roam
+    attempt was successful, status will be set to CSR_WIFI_SME_SUCCESS,
+    otherwise it shall be set to the appropriate error code.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the roaming procedure
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeRoamCompleteInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamStartInd
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive it whenever it begins an attempt to roam to an AP.
+    If the wireless manager application connect request specified the SSID
+    and the BSSID was set to the broadcast address (0xFF 0xFF 0xFF 0xFF 0xFF
+    0xFF), the SME monitors the signal quality and maintains a list of
+    candidates to roam to. When the signal quality of the current connection
+    falls below a threshold, and there is a candidate with better quality,
+    the SME will attempt to the candidate AP.
+    If the roaming procedure succeeds, the SME will also issue a Media
+    Connect indication to inform the wireless manager application of the
+    change.
+    NOTE: to prevent the SME from initiating roaming the WMA must specify the
+    BSSID in the connection request; this forces the SME to connect only to
+    that AP.
+    The wireless manager application can obtain statistics for roaming
+    purposes using CSR_WIFI_SME_CONNECTION_QUALITY_IND and
+    CSR_WIFI_SME_CONNECTION_STATS_GET_REQ.
+    When the wireless manager application wishes to roam to another AP, it
+    must issue a connection request specifying the BSSID of the desired AP.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    roamReason   - Indicates the reason for starting the roaming procedure
+    reason80211  - Indicates the reason for deauthentication or disassociation
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrWifiSmeRoamReason      roamReason;
+    CsrWifiSmeIEEE80211Reason reason80211;
+} CsrWifiSmeRoamStartInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamingConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    interfaceTag  - Interface Identifier; unique identifier of an interface
+    status        - Reports the result of the request
+    roamingConfig - Reports the roaming behaviour of the driver and firmware
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent         common;
+    CsrUint16               interfaceTag;
+    CsrResult               status;
+    CsrWifiSmeRoamingConfig roamingConfig;
+} CsrWifiSmeRoamingConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeRoamingConfigSetCfm
+
+  DESCRIPTION
+    This primitive sets the value of the RoamingConfig parameter.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeRoamingConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    status     - Reports the result of the request
+    scanConfig - Returns the current parameters for the autonomous scanning
+                 behaviour of the firmware
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrResult            status;
+    CsrWifiSmeScanConfig scanConfig;
+} CsrWifiSmeScanConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanConfigSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeScanConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanFullCfm
+
+  DESCRIPTION
+    The SME calls this primitive when the results from the scan are
+    available.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeScanFullCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResultInd
+
+  DESCRIPTION
+    The SME sends this primitive to all the tasks that have registered to
+    receive it whenever a scan indication is received from the firmware.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    result - Points to a buffer containing a scan result.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent      common;
+    CsrWifiSmeScanResult result;
+} CsrWifiSmeScanResultInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResultsFlushCfm
+
+  DESCRIPTION
+    The SME will call this primitive when the cache has been cleared.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeScanResultsFlushCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeScanResultsGetCfm
+
+  DESCRIPTION
+    The SME sends this primitive to provide the current set of scan results.
+
+  MEMBERS
+    common           - Common header for use with the CsrWifiFsm Module
+    status           - Reports the result of the request
+    scanResultsCount - Number of scan results
+    scanResults      - Points to a buffer containing an array of
+                       CsrWifiSmeScanResult structures.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent       common;
+    CsrResult             status;
+    CsrUint16             scanResultsCount;
+    CsrWifiSmeScanResult *scanResults;
+} CsrWifiSmeScanResultsGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeStaConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+    smeConfig    - Current SME Station Parameters
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent     common;
+    CsrUint16           interfaceTag;
+    CsrResult           status;
+    CsrWifiSmeStaConfig smeConfig;
+} CsrWifiSmeSmeStaConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeStaConfigSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface Identifier; unique identifier of an interface
+    status       - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint16       interfaceTag;
+    CsrResult       status;
+} CsrWifiSmeSmeStaConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeStationMacAddressGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common            - Common header for use with the CsrWifiFsm Module
+    status            - Reports the result of the request
+    stationMacAddress - Current MAC address of the station.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrResult         status;
+    CsrWifiMacAddress stationMacAddress[2];
+} CsrWifiSmeStationMacAddressGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTspecInd
+
+  DESCRIPTION
+    The SME will send this primitive to all the task that have registered to
+    receive it when a status change in the TSPEC occurs.
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    transactionId   - Unique Transaction ID for the TSPEC, as assigned by the
+                      driver
+    tspecResultCode - Specifies the TSPEC operation requested by the peer
+                      station
+    tspecLength     - Length of the TSPEC.
+    tspec           - Points to the first byte of the TSPEC
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrUint32                 transactionId;
+    CsrWifiSmeTspecResultCode tspecResultCode;
+    CsrUint16                 tspecLength;
+    CsrUint8                 *tspec;
+} CsrWifiSmeTspecInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeTspecCfm
+
+  DESCRIPTION
+    The SME calls the primitive to report the result of the TSpec primitive
+    request.
+
+  MEMBERS
+    common          - Common header for use with the CsrWifiFsm Module
+    interfaceTag    - Interface Identifier; unique identifier of an interface
+    status          - Reports the result of the request
+    transactionId   - Unique Transaction ID for the TSPEC, as assigned by the
+                      driver
+    tspecResultCode - Specifies the result of the negotiated TSPEC operation
+    tspecLength     - Length of the TSPEC.
+    tspec           - Points to the first byte of the TSPEC
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent           common;
+    CsrUint16                 interfaceTag;
+    CsrResult                 status;
+    CsrUint32                 transactionId;
+    CsrWifiSmeTspecResultCode tspecResultCode;
+    CsrUint16                 tspecLength;
+    CsrUint8                 *tspec;
+} CsrWifiSmeTspecCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeVersionsGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common   - Common header for use with the CsrWifiFsm Module
+    status   - Reports the result of the request
+    versions - Version IDs of the product
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent    common;
+    CsrResult          status;
+    CsrWifiSmeVersions versions;
+} CsrWifiSmeVersionsGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiFlightmodeCfm
+
+  DESCRIPTION
+    The SME calls this primitive when the chip is initialised for low power
+    mode and with the radio subsystem disabled. To leave flight mode, and
+    enable Wi-Fi, the wireless manager application should call
+    CSR_WIFI_SME_WIFI_ON_REQ.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeWifiFlightmodeCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOffInd
+
+  DESCRIPTION
+    The SME sends this primitive to all the tasks that have registered to
+    receive it to report that the chip has been turned off.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    reason - Indicates the reason why the Wi-Fi has been switched off.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent             common;
+    CsrWifiSmeControlIndication reason;
+} CsrWifiSmeWifiOffInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOffCfm
+
+  DESCRIPTION
+    After receiving CSR_WIFI_SME_WIFI_OFF_REQ, if the chip is connected to a
+    network, the SME will perform a disconnect operation, will send a
+    CSR_WIFI_SME_MEDIA_STATUS_IND with
+    CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED, and then will call
+    CSR_WIFI_SME_WIFI_OFF_CFM when the chip is off.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeWifiOffCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOnCfm
+
+  DESCRIPTION
+    The SME sends this primitive to the task that has sent the request once
+    the chip has been initialised and is available for use.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeWifiOnCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCloakedSsidsSetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeCloakedSsidsSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCloakedSsidsGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    status       - Reports the result of the request
+    cloakedSsids - Reports list of cloaked SSIDs that are explicitly scanned for
+                   by the driver
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent             common;
+    CsrResult                   status;
+    CsrWifiSmeCloakedSsidConfig cloakedSsids;
+} CsrWifiSmeCloakedSsidsGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWifiOnInd
+
+  DESCRIPTION
+    The SME sends this primitive to all tasks that have registered to receive
+    it once the chip becomes available and ready to use.
+
+  MEMBERS
+    common  - Common header for use with the CsrWifiFsm Module
+    address - Current MAC address
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent   common;
+    CsrWifiMacAddress address;
+} CsrWifiSmeWifiOnInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeCommonConfigGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    status       - Reports the result of the request
+    deviceConfig - Configuration options in the SME
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent        common;
+    CsrResult              status;
+    CsrWifiSmeDeviceConfig deviceConfig;
+} CsrWifiSmeSmeCommonConfigGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeSmeCommonConfigSetCfm
+
+  DESCRIPTION
+    Reports the result of the request
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Reports the result of the request
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeSmeCommonConfigSetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeInterfaceCapabilityGetCfm
+
+  DESCRIPTION
+    This primitive reports the result of the request.
+
+  MEMBERS
+    common        - Common header for use with the CsrWifiFsm Module
+    status        - Result of the request
+    numInterfaces - Number of the interfaces supported
+    capBitmap     - Points to the list of capabilities bitmaps provided for each
+                    interface.
+                    The bits represent the following capabilities:
+                    -bits 7 to 4-Reserved
+                    -bit 3-AMP
+                    -bit 2-P2P
+                    -bit 1-AP
+                    -bit 0-STA
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+    CsrUint16       numInterfaces;
+    CsrUint8        capBitmap[2];
+} CsrWifiSmeInterfaceCapabilityGetCfm;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeErrorInd
+
+  DESCRIPTION
+    Important error message indicating a error of some importance
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    errorMessage - Contains the error message.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrCharString  *errorMessage;
+} CsrWifiSmeErrorInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeInfoInd
+
+  DESCRIPTION
+    Message indicating a some info about current activity. Mostly of interest
+    in testing but may be useful in the field.
+
+  MEMBERS
+    common      - Common header for use with the CsrWifiFsm Module
+    infoMessage - Contains the message.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrCharString  *infoMessage;
+} CsrWifiSmeInfoInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeCoreDumpInd
+
+  DESCRIPTION
+    The SME will send this primitive to all the tasks that have registered to
+    receive Wi-Fi Chip core dump data.
+    The core dump data may be fragmented and sent using more than one
+    indication.
+    To indicate that all the data has been sent, the last indication contains
+    a 'length' of 0 and 'data' of NULL.
+
+  MEMBERS
+    common     - Common header for use with the CsrWifiFsm Module
+    dataLength - Number of bytes in the buffer pointed to by 'data'
+    data       - Pointer to the buffer containing 'dataLength' bytes of core
+                 dump data
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrUint32       dataLength;
+    CsrUint8       *data;
+} CsrWifiSmeCoreDumpInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeAmpStatusChangeInd
+
+  DESCRIPTION
+    Indication of change to AMP activity.
+
+  MEMBERS
+    common       - Common header for use with the CsrWifiFsm Module
+    interfaceTag - Interface on which the AMP activity changed.
+    ampStatus    - The new status of AMP activity.Range: {AMP_ACTIVE,
+                   AMP_INACTIVE}.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent     common;
+    CsrUint16           interfaceTag;
+    CsrWifiSmeAmpStatus ampStatus;
+} CsrWifiSmeAmpStatusChangeInd;
+
+/*******************************************************************************
+
+  NAME
+    CsrWifiSmeWpsConfigurationCfm
+
+  DESCRIPTION
+    Confirm.
+
+  MEMBERS
+    common - Common header for use with the CsrWifiFsm Module
+    status - Status of the request.
+
+*******************************************************************************/
+typedef struct
+{
+    CsrWifiFsmEvent common;
+    CsrResult       status;
+} CsrWifiSmeWpsConfigurationCfm;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_SME_PRIM_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_sef.c
@@ -0,0 +1,85 @@
+/*****************************************************************************
+
+  (c) Cambridge Silicon Radio Limited 2010
+  Confidential information of CSR
+
+  Refer to LICENSE.txt included with this source for details
+  on the license terms.
+
+ *****************************************************************************/
+#include "csr_wifi_sme_sef.h"
+
+const CsrWifiSmeStateHandlerType CsrWifiSmeUpstreamStateHandlers[CSR_WIFI_SME_PRIM_UPSTREAM_COUNT] =
+{
+    /* 0x8000 */ CsrWifiSmeActivateCfmHandler,
+    /* 0x8001 */ CsrWifiSmeAdhocConfigGetCfmHandler,
+    /* 0x8002 */ CsrWifiSmeAdhocConfigSetCfmHandler,
+    /* 0x8003 */ CsrWifiSmeAssociationCompleteIndHandler,
+    /* 0x8004 */ CsrWifiSmeAssociationStartIndHandler,
+    /* 0x8005 */ CsrWifiSmeBlacklistCfmHandler,
+    /* 0x8006 */ CsrWifiSmeCalibrationDataGetCfmHandler,
+    /* 0x8007 */ CsrWifiSmeCalibrationDataSetCfmHandler,
+    /* 0x8008 */ CsrWifiSmeCcxConfigGetCfmHandler,
+    /* 0x8009 */ CsrWifiSmeCcxConfigSetCfmHandler,
+    /* 0x800A */ CsrWifiSmeCoexConfigGetCfmHandler,
+    /* 0x800B */ CsrWifiSmeCoexConfigSetCfmHandler,
+    /* 0x800C */ CsrWifiSmeCoexInfoGetCfmHandler,
+    /* 0x800D */ CsrWifiSmeConnectCfmHandler,
+    /* 0x800E */ CsrWifiSmeConnectionConfigGetCfmHandler,
+    /* 0x800F */ CsrWifiSmeConnectionInfoGetCfmHandler,
+    /* 0x8010 */ CsrWifiSmeConnectionQualityIndHandler,
+    /* 0x8011 */ CsrWifiSmeConnectionStatsGetCfmHandler,
+    /* 0x8012 */ CsrWifiSmeDeactivateCfmHandler,
+    /* 0x8013 */ CsrWifiSmeDisconnectCfmHandler,
+    /* 0x8014 */ CsrWifiSmeEventMaskSetCfmHandler,
+    /* 0x8015 */ CsrWifiSmeHostConfigGetCfmHandler,
+    /* 0x8016 */ CsrWifiSmeHostConfigSetCfmHandler,
+    /* 0x8017 */ CsrWifiSmeIbssStationIndHandler,
+    /* 0x8018 */ CsrWifiSmeKeyCfmHandler,
+    /* 0x8019 */ CsrWifiSmeLinkQualityGetCfmHandler,
+    /* 0x801A */ CsrWifiSmeMediaStatusIndHandler,
+    /* 0x801B */ CsrWifiSmeMibConfigGetCfmHandler,
+    /* 0x801C */ CsrWifiSmeMibConfigSetCfmHandler,
+    /* 0x801D */ CsrWifiSmeMibGetCfmHandler,
+    /* 0x801E */ CsrWifiSmeMibGetNextCfmHandler,
+    /* 0x801F */ CsrWifiSmeMibSetCfmHandler,
+    /* 0x8020 */ CsrWifiSmeMicFailureIndHandler,
+    /* 0x8021 */ CsrWifiSmeMulticastAddressCfmHandler,
+    /* 0x8022 */ CsrWifiSmePacketFilterSetCfmHandler,
+    /* 0x8023 */ CsrWifiSmePermanentMacAddressGetCfmHandler,
+    /* 0x8024 */ CsrWifiSmePmkidCandidateListIndHandler,
+    /* 0x8025 */ CsrWifiSmePmkidCfmHandler,
+    /* 0x8026 */ CsrWifiSmePowerConfigGetCfmHandler,
+    /* 0x8027 */ CsrWifiSmePowerConfigSetCfmHandler,
+    /* 0x8028 */ CsrWifiSmeRegulatoryDomainInfoGetCfmHandler,
+    /* 0x8029 */ CsrWifiSmeRoamCompleteIndHandler,
+    /* 0x802A */ CsrWifiSmeRoamStartIndHandler,
+    /* 0x802B */ CsrWifiSmeRoamingConfigGetCfmHandler,
+    /* 0x802C */ CsrWifiSmeRoamingConfigSetCfmHandler,
+    /* 0x802D */ CsrWifiSmeScanConfigGetCfmHandler,
+    /* 0x802E */ CsrWifiSmeScanConfigSetCfmHandler,
+    /* 0x802F */ CsrWifiSmeScanFullCfmHandler,
+    /* 0x8030 */ CsrWifiSmeScanResultIndHandler,
+    /* 0x8031 */ CsrWifiSmeScanResultsFlushCfmHandler,
+    /* 0x8032 */ CsrWifiSmeScanResultsGetCfmHandler,
+    /* 0x8033 */ CsrWifiSmeSmeStaConfigGetCfmHandler,
+    /* 0x8034 */ CsrWifiSmeSmeStaConfigSetCfmHandler,
+    /* 0x8035 */ CsrWifiSmeStationMacAddressGetCfmHandler,
+    /* 0x8036 */ CsrWifiSmeTspecIndHandler,
+    /* 0x8037 */ CsrWifiSmeTspecCfmHandler,
+    /* 0x8038 */ CsrWifiSmeVersionsGetCfmHandler,
+    /* 0x8039 */ CsrWifiSmeWifiFlightmodeCfmHandler,
+    /* 0x803A */ CsrWifiSmeWifiOffIndHandler,
+    /* 0x803B */ CsrWifiSmeWifiOffCfmHandler,
+    /* 0x803C */ CsrWifiSmeWifiOnCfmHandler,
+    /* 0x803D */ CsrWifiSmeCloakedSsidsSetCfmHandler,
+    /* 0x803E */ CsrWifiSmeCloakedSsidsGetCfmHandler,
+    /* 0x803F */ CsrWifiSmeWifiOnIndHandler,
+    /* 0x8040 */ CsrWifiSmeSmeCommonConfigGetCfmHandler,
+    /* 0x8041 */ CsrWifiSmeSmeCommonConfigSetCfmHandler,
+    /* 0x8042 */ CsrWifiSmeGetInterfaceCapabilityCfmHandler,
+    /* 0x8043 */ CsrWifiSmeErrorIndHandler,
+    /* 0x8044 */ CsrWifiSmeInfoIndHandler,
+    /* 0x8045 */ CsrWifiSmeCoreDumpIndHandler,
+    /* 0x8046 */ CsrWifiSmeAmpStatusChangeIndHandler,
+};
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_sef.h
@@ -0,0 +1,101 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2010
+            Confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+#ifndef CSR_WIFI_ROUTER_SEF_CSR_WIFI_SME_H__
+#define CSR_WIFI_ROUTER_SEF_CSR_WIFI_SME_H__
+
+#include "csr_wifi_sme_prim.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void (*CsrWifiSmeStateHandlerType)(void* drvpriv, CsrWifiFsmEvent* msg);
+
+extern const CsrWifiSmeStateHandlerType CsrWifiSmeUpstreamStateHandlers[CSR_WIFI_SME_PRIM_UPSTREAM_COUNT];
+
+
+extern void CsrWifiSmeActivateCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeAdhocConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeAdhocConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeAssociationCompleteIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeAssociationStartIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeBlacklistCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeCalibrationDataGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeCalibrationDataSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeCcxConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeCcxConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeCoexConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeCoexConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeCoexInfoGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeConnectCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeConnectionConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeConnectionInfoGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeConnectionQualityIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeConnectionStatsGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeDeactivateCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeDisconnectCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeEventMaskSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeHostConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeHostConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeIbssStationIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeKeyCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeLinkQualityGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeMediaStatusIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeMibConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeMibConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeMibGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeMibGetNextCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeMibSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeMicFailureIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeMulticastAddressCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmePacketFilterSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmePermanentMacAddressGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmePmkidCandidateListIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmePmkidCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmePowerConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmePowerConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeRegulatoryDomainInfoGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeRoamCompleteIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeRoamStartIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeRoamingConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeRoamingConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeScanConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeScanConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeScanFullCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeScanResultIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeScanResultsFlushCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeScanResultsGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeSmeStaConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeSmeStaConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeStationMacAddressGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeTspecIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeTspecCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeVersionsGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeWifiFlightmodeCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeWifiOffIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeWifiOffCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeWifiOnCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeCloakedSsidsSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeCloakedSsidsGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeWifiOnIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeSmeCommonConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeSmeCommonConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeGetInterfaceCapabilityCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeErrorIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeInfoIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeCoreDumpIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+extern void CsrWifiSmeAmpStatusChangeIndHandler(void* drvpriv, CsrWifiFsmEvent* msg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_ROUTER_SEF_CSR_WIFI_SME_H__ */
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_serialize.c
@@ -0,0 +1,5756 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#include "csr_pmem.h"
+#include "csr_msgconv.h"
+#include "csr_unicode.h"
+
+
+#include "csr_wifi_sme_prim.h"
+#include "csr_wifi_sme_serialize.h"
+
+void CsrWifiSmePfree(void *ptr)
+{
+    CsrPmemFree(ptr);
+}
+
+
+CsrSize CsrWifiSmeAdhocConfigSetReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 11) */
+    bufferSize += 2; /* CsrUint16 primitive->adHocConfig.atimWindowTu */
+    bufferSize += 2; /* CsrUint16 primitive->adHocConfig.beaconPeriodTu */
+    bufferSize += 2; /* CsrUint16 primitive->adHocConfig.joinOnlyAttempts */
+    bufferSize += 2; /* CsrUint16 primitive->adHocConfig.joinAttemptIntervalMs */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeAdhocConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeAdhocConfigSetReq *primitive = (CsrWifiSmeAdhocConfigSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->adHocConfig.atimWindowTu);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->adHocConfig.beaconPeriodTu);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->adHocConfig.joinOnlyAttempts);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->adHocConfig.joinAttemptIntervalMs);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeAdhocConfigSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeAdhocConfigSetReq *primitive = (CsrWifiSmeAdhocConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeAdhocConfigSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->adHocConfig.atimWindowTu, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->adHocConfig.beaconPeriodTu, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->adHocConfig.joinOnlyAttempts, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->adHocConfig.joinAttemptIntervalMs, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeBlacklistReqSizeof(void *msg)
+{
+    CsrWifiSmeBlacklistReq *primitive = (CsrWifiSmeBlacklistReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrWifiSmeListAction primitive->action */
+    bufferSize += 1; /* CsrUint8 primitive->setAddressCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setAddressCount; i1++)
+        {
+            bufferSize += 6; /* CsrUint8 primitive->setAddresses[i1].a[6] */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeBlacklistReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeBlacklistReq *primitive = (CsrWifiSmeBlacklistReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->setAddressCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setAddressCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->setAddresses[i1].a, ((CsrUint16) (6)));
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeBlacklistReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeBlacklistReq *primitive = (CsrWifiSmeBlacklistReq *) CsrPmemAlloc(sizeof(CsrWifiSmeBlacklistReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->setAddressCount, buffer, &offset);
+    primitive->setAddresses = NULL;
+    if (primitive->setAddressCount)
+    {
+        primitive->setAddresses = (CsrWifiMacAddress *)CsrPmemAlloc(sizeof(CsrWifiMacAddress) * primitive->setAddressCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setAddressCount; i1++)
+        {
+            CsrMemCpyDes(primitive->setAddresses[i1].a, buffer, &offset, ((CsrUint16) (6)));
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeBlacklistReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeBlacklistReq *primitive = (CsrWifiSmeBlacklistReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->setAddresses);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeCalibrationDataSetReqSizeof(void *msg)
+{
+    CsrWifiSmeCalibrationDataSetReq *primitive = (CsrWifiSmeCalibrationDataSetReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 6) */
+    bufferSize += 2;                                /* CsrUint16 primitive->calibrationDataLength */
+    bufferSize += primitive->calibrationDataLength; /* CsrUint8 primitive->calibrationData */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCalibrationDataSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCalibrationDataSetReq *primitive = (CsrWifiSmeCalibrationDataSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->calibrationDataLength);
+    if (primitive->calibrationDataLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->calibrationData, ((CsrUint16) (primitive->calibrationDataLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCalibrationDataSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCalibrationDataSetReq *primitive = (CsrWifiSmeCalibrationDataSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCalibrationDataSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->calibrationDataLength, buffer, &offset);
+    if (primitive->calibrationDataLength)
+    {
+        primitive->calibrationData = (CsrUint8 *)CsrPmemAlloc(primitive->calibrationDataLength);
+        CsrMemCpyDes(primitive->calibrationData, buffer, &offset, ((CsrUint16) (primitive->calibrationDataLength)));
+    }
+    else
+    {
+        primitive->calibrationData = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeCalibrationDataSetReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeCalibrationDataSetReq *primitive = (CsrWifiSmeCalibrationDataSetReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->calibrationData);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeCcxConfigSetReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrUint8 primitive->ccxConfig.keepAliveTimeMs */
+    bufferSize += 1; /* CsrBool primitive->ccxConfig.apRoamingEnabled */
+    bufferSize += 1; /* CsrUint8 primitive->ccxConfig.measurementsMask */
+    bufferSize += 1; /* CsrBool primitive->ccxConfig.ccxRadioMgtEnabled */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCcxConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCcxConfigSetReq *primitive = (CsrWifiSmeCcxConfigSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ccxConfig.keepAliveTimeMs);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ccxConfig.apRoamingEnabled);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ccxConfig.measurementsMask);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ccxConfig.ccxRadioMgtEnabled);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCcxConfigSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCcxConfigSetReq *primitive = (CsrWifiSmeCcxConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCcxConfigSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->ccxConfig.keepAliveTimeMs, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->ccxConfig.apRoamingEnabled, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->ccxConfig.measurementsMask, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->ccxConfig.ccxRadioMgtEnabled, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeCoexConfigSetReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 29) */
+    bufferSize += 1; /* CsrBool primitive->coexConfig.coexEnableSchemeManagement */
+    bufferSize += 1; /* CsrBool primitive->coexConfig.coexPeriodicWakeHost */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexTrafficBurstyLatencyMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexTrafficContinuousLatencyMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexObexBlackoutDurationMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexObexBlackoutPeriodMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexA2dpBrBlackoutDurationMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexA2dpBrBlackoutPeriodMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexA2dpEdrBlackoutDurationMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexA2dpEdrBlackoutPeriodMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexPagingBlackoutDurationMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexPagingBlackoutPeriodMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexInquiryBlackoutDurationMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexInquiryBlackoutPeriodMs */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCoexConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCoexConfigSetReq *primitive = (CsrWifiSmeCoexConfigSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->coexConfig.coexEnableSchemeManagement);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->coexConfig.coexPeriodicWakeHost);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexTrafficBurstyLatencyMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexTrafficContinuousLatencyMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexObexBlackoutDurationMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexObexBlackoutPeriodMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexA2dpBrBlackoutDurationMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexA2dpBrBlackoutPeriodMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexA2dpEdrBlackoutDurationMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexA2dpEdrBlackoutPeriodMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexPagingBlackoutDurationMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexPagingBlackoutPeriodMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexInquiryBlackoutDurationMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexInquiryBlackoutPeriodMs);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCoexConfigSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCoexConfigSetReq *primitive = (CsrWifiSmeCoexConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCoexConfigSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->coexConfig.coexEnableSchemeManagement, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->coexConfig.coexPeriodicWakeHost, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexTrafficBurstyLatencyMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexTrafficContinuousLatencyMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexObexBlackoutDurationMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexObexBlackoutPeriodMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexA2dpBrBlackoutDurationMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexA2dpBrBlackoutPeriodMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexA2dpEdrBlackoutDurationMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexA2dpEdrBlackoutPeriodMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexPagingBlackoutDurationMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexPagingBlackoutPeriodMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexInquiryBlackoutDurationMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexInquiryBlackoutPeriodMs, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeConnectReqSizeof(void *msg)
+{
+    CsrWifiSmeConnectReq *primitive = (CsrWifiSmeConnectReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 57) */
+    bufferSize += 2;                                                                     /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 32;                                                                    /* CsrUint8 primitive->connectionConfig.ssid.ssid[32] */
+    bufferSize += 1;                                                                     /* CsrUint8 primitive->connectionConfig.ssid.length */
+    bufferSize += 6;                                                                     /* CsrUint8 primitive->connectionConfig.bssid.a[6] */
+    bufferSize += 1;                                                                     /* CsrWifiSmeBssType primitive->connectionConfig.bssType */
+    bufferSize += 1;                                                                     /* CsrWifiSmeRadioIF primitive->connectionConfig.ifIndex */
+    bufferSize += 1;                                                                     /* CsrWifiSme80211PrivacyMode primitive->connectionConfig.privacyMode */
+    bufferSize += 2;                                                                     /* CsrWifiSmeAuthModeMask primitive->connectionConfig.authModeMask */
+    bufferSize += 2;                                                                     /* CsrWifiSmeEncryptionMask primitive->connectionConfig.encryptionModeMask */
+    bufferSize += 2;                                                                     /* CsrUint16 primitive->connectionConfig.mlmeAssociateReqInformationElementsLength */
+    bufferSize += primitive->connectionConfig.mlmeAssociateReqInformationElementsLength; /* CsrUint8 primitive->connectionConfig.mlmeAssociateReqInformationElements */
+    bufferSize += 1;                                                                     /* CsrWifiSmeWmmQosInfoMask primitive->connectionConfig.wmmQosInfo */
+    bufferSize += 1;                                                                     /* CsrBool primitive->connectionConfig.adhocJoinOnly */
+    bufferSize += 1;                                                                     /* CsrUint8 primitive->connectionConfig.adhocChannel */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeConnectReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeConnectReq *primitive = (CsrWifiSmeConnectReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionConfig.ssid.ssid, ((CsrUint16) (32)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.ssid.length);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionConfig.bssid.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.bssType);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.ifIndex);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.privacyMode);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionConfig.authModeMask);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionConfig.encryptionModeMask);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionConfig.mlmeAssociateReqInformationElementsLength);
+    if (primitive->connectionConfig.mlmeAssociateReqInformationElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionConfig.mlmeAssociateReqInformationElements, ((CsrUint16) (primitive->connectionConfig.mlmeAssociateReqInformationElementsLength)));
+    }
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.wmmQosInfo);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.adhocJoinOnly);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.adhocChannel);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeConnectReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeConnectReq *primitive = (CsrWifiSmeConnectReq *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionConfig.ssid.ssid, buffer, &offset, ((CsrUint16) (32)));
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.ssid.length, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionConfig.bssid.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.bssType, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.ifIndex, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.privacyMode, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionConfig.authModeMask, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionConfig.encryptionModeMask, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionConfig.mlmeAssociateReqInformationElementsLength, buffer, &offset);
+    if (primitive->connectionConfig.mlmeAssociateReqInformationElementsLength)
+    {
+        primitive->connectionConfig.mlmeAssociateReqInformationElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionConfig.mlmeAssociateReqInformationElementsLength);
+        CsrMemCpyDes(primitive->connectionConfig.mlmeAssociateReqInformationElements, buffer, &offset, ((CsrUint16) (primitive->connectionConfig.mlmeAssociateReqInformationElementsLength)));
+    }
+    else
+    {
+        primitive->connectionConfig.mlmeAssociateReqInformationElements = NULL;
+    }
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.wmmQosInfo, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.adhocJoinOnly, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.adhocChannel, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiSmeConnectReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeConnectReq *primitive = (CsrWifiSmeConnectReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->connectionConfig.mlmeAssociateReqInformationElements);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeHostConfigSetReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 8) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrWifiSmeHostPowerMode primitive->hostConfig.powerMode */
+    bufferSize += 2; /* CsrUint16 primitive->hostConfig.applicationDataPeriodMs */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeHostConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeHostConfigSetReq *primitive = (CsrWifiSmeHostConfigSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->hostConfig.powerMode);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->hostConfig.applicationDataPeriodMs);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeHostConfigSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeHostConfigSetReq *primitive = (CsrWifiSmeHostConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeHostConfigSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->hostConfig.powerMode, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->hostConfig.applicationDataPeriodMs, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeKeyReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 65) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrWifiSmeListAction primitive->action */
+    bufferSize += 1; /* CsrWifiSmeKeyType primitive->key.keyType */
+    bufferSize += 1; /* CsrUint8 primitive->key.keyIndex */
+    bufferSize += 1; /* CsrBool primitive->key.wepTxKey */
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 8; i2++)
+        {
+            bufferSize += 2; /* CsrUint16 primitive->key.keyRsc[8] */
+        }
+    }
+    bufferSize += 1;         /* CsrBool primitive->key.authenticator */
+    bufferSize += 6;         /* CsrUint8 primitive->key.address.a[6] */
+    bufferSize += 1;         /* CsrUint8 primitive->key.keyLength */
+    bufferSize += 32;        /* CsrUint8 primitive->key.key[32] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeKeyReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeKeyReq *primitive = (CsrWifiSmeKeyReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->key.keyType);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->key.keyIndex);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->key.wepTxKey);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 8; i2++)
+        {
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->key.keyRsc[i2]);
+        }
+    }
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->key.authenticator);
+    CsrMemCpySer(ptr, len, (const void *) primitive->key.address.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->key.keyLength);
+    CsrMemCpySer(ptr, len, (const void *) primitive->key.key, ((CsrUint16) (32)));
+    return(ptr);
+}
+
+
+void* CsrWifiSmeKeyReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeKeyReq *primitive = (CsrWifiSmeKeyReq *) CsrPmemAlloc(sizeof(CsrWifiSmeKeyReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->key.keyType, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->key.keyIndex, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->key.wepTxKey, buffer, &offset);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 8; i2++)
+        {
+            CsrUint16Des((CsrUint16 *) &primitive->key.keyRsc[i2], buffer, &offset);
+        }
+    }
+    CsrUint8Des((CsrUint8 *) &primitive->key.authenticator, buffer, &offset);
+    CsrMemCpyDes(primitive->key.address.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->key.keyLength, buffer, &offset);
+    CsrMemCpyDes(primitive->key.key, buffer, &offset, ((CsrUint16) (32)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeMibConfigSetReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 11) */
+    bufferSize += 1; /* CsrBool primitive->mibConfig.unifiFixMaxTxDataRate */
+    bufferSize += 1; /* CsrUint8 primitive->mibConfig.unifiFixTxDataRate */
+    bufferSize += 2; /* CsrUint16 primitive->mibConfig.dot11RtsThreshold */
+    bufferSize += 2; /* CsrUint16 primitive->mibConfig.dot11FragmentationThreshold */
+    bufferSize += 2; /* CsrUint16 primitive->mibConfig.dot11CurrentTxPowerLevel */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMibConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMibConfigSetReq *primitive = (CsrWifiSmeMibConfigSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->mibConfig.unifiFixMaxTxDataRate);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->mibConfig.unifiFixTxDataRate);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibConfig.dot11RtsThreshold);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibConfig.dot11FragmentationThreshold);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibConfig.dot11CurrentTxPowerLevel);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMibConfigSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMibConfigSetReq *primitive = (CsrWifiSmeMibConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMibConfigSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->mibConfig.unifiFixMaxTxDataRate, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->mibConfig.unifiFixTxDataRate, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibConfig.dot11RtsThreshold, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibConfig.dot11FragmentationThreshold, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibConfig.dot11CurrentTxPowerLevel, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeMibGetNextReqSizeof(void *msg)
+{
+    CsrWifiSmeMibGetNextReq *primitive = (CsrWifiSmeMibGetNextReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 6) */
+    bufferSize += 2;                             /* CsrUint16 primitive->mibAttributeLength */
+    bufferSize += primitive->mibAttributeLength; /* CsrUint8 primitive->mibAttribute */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMibGetNextReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMibGetNextReq *primitive = (CsrWifiSmeMibGetNextReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibAttributeLength);
+    if (primitive->mibAttributeLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->mibAttribute, ((CsrUint16) (primitive->mibAttributeLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMibGetNextReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMibGetNextReq *primitive = (CsrWifiSmeMibGetNextReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMibGetNextReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibAttributeLength, buffer, &offset);
+    if (primitive->mibAttributeLength)
+    {
+        primitive->mibAttribute = (CsrUint8 *)CsrPmemAlloc(primitive->mibAttributeLength);
+        CsrMemCpyDes(primitive->mibAttribute, buffer, &offset, ((CsrUint16) (primitive->mibAttributeLength)));
+    }
+    else
+    {
+        primitive->mibAttribute = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeMibGetNextReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeMibGetNextReq *primitive = (CsrWifiSmeMibGetNextReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->mibAttribute);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeMibGetReqSizeof(void *msg)
+{
+    CsrWifiSmeMibGetReq *primitive = (CsrWifiSmeMibGetReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 6) */
+    bufferSize += 2;                             /* CsrUint16 primitive->mibAttributeLength */
+    bufferSize += primitive->mibAttributeLength; /* CsrUint8 primitive->mibAttribute */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMibGetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMibGetReq *primitive = (CsrWifiSmeMibGetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibAttributeLength);
+    if (primitive->mibAttributeLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->mibAttribute, ((CsrUint16) (primitive->mibAttributeLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMibGetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMibGetReq *primitive = (CsrWifiSmeMibGetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMibGetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibAttributeLength, buffer, &offset);
+    if (primitive->mibAttributeLength)
+    {
+        primitive->mibAttribute = (CsrUint8 *)CsrPmemAlloc(primitive->mibAttributeLength);
+        CsrMemCpyDes(primitive->mibAttribute, buffer, &offset, ((CsrUint16) (primitive->mibAttributeLength)));
+    }
+    else
+    {
+        primitive->mibAttribute = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeMibGetReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeMibGetReq *primitive = (CsrWifiSmeMibGetReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->mibAttribute);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeMibSetReqSizeof(void *msg)
+{
+    CsrWifiSmeMibSetReq *primitive = (CsrWifiSmeMibSetReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 6) */
+    bufferSize += 2;                             /* CsrUint16 primitive->mibAttributeLength */
+    bufferSize += primitive->mibAttributeLength; /* CsrUint8 primitive->mibAttribute */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMibSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMibSetReq *primitive = (CsrWifiSmeMibSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibAttributeLength);
+    if (primitive->mibAttributeLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->mibAttribute, ((CsrUint16) (primitive->mibAttributeLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMibSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMibSetReq *primitive = (CsrWifiSmeMibSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMibSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibAttributeLength, buffer, &offset);
+    if (primitive->mibAttributeLength)
+    {
+        primitive->mibAttribute = (CsrUint8 *)CsrPmemAlloc(primitive->mibAttributeLength);
+        CsrMemCpyDes(primitive->mibAttribute, buffer, &offset, ((CsrUint16) (primitive->mibAttributeLength)));
+    }
+    else
+    {
+        primitive->mibAttribute = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeMibSetReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeMibSetReq *primitive = (CsrWifiSmeMibSetReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->mibAttribute);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeMulticastAddressReqSizeof(void *msg)
+{
+    CsrWifiSmeMulticastAddressReq *primitive = (CsrWifiSmeMulticastAddressReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrWifiSmeListAction primitive->action */
+    bufferSize += 1; /* CsrUint8 primitive->setAddressesCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setAddressesCount; i1++)
+        {
+            bufferSize += 6; /* CsrUint8 primitive->setAddresses[i1].a[6] */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMulticastAddressReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMulticastAddressReq *primitive = (CsrWifiSmeMulticastAddressReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->setAddressesCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setAddressesCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->setAddresses[i1].a, ((CsrUint16) (6)));
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMulticastAddressReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMulticastAddressReq *primitive = (CsrWifiSmeMulticastAddressReq *) CsrPmemAlloc(sizeof(CsrWifiSmeMulticastAddressReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->setAddressesCount, buffer, &offset);
+    primitive->setAddresses = NULL;
+    if (primitive->setAddressesCount)
+    {
+        primitive->setAddresses = (CsrWifiMacAddress *)CsrPmemAlloc(sizeof(CsrWifiMacAddress) * primitive->setAddressesCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setAddressesCount; i1++)
+        {
+            CsrMemCpyDes(primitive->setAddresses[i1].a, buffer, &offset, ((CsrUint16) (6)));
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeMulticastAddressReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeMulticastAddressReq *primitive = (CsrWifiSmeMulticastAddressReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->setAddresses);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmePacketFilterSetReqSizeof(void *msg)
+{
+    CsrWifiSmePacketFilterSetReq *primitive = (CsrWifiSmePacketFilterSetReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2;                       /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2;                       /* CsrUint16 primitive->filterLength */
+    bufferSize += primitive->filterLength; /* CsrUint8 primitive->filter */
+    bufferSize += 1;                       /* CsrWifiSmePacketFilterMode primitive->mode */
+    bufferSize += 4;                       /* CsrUint8 primitive->arpFilterAddress.a[4] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmePacketFilterSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmePacketFilterSetReq *primitive = (CsrWifiSmePacketFilterSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->filterLength);
+    if (primitive->filterLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->filter, ((CsrUint16) (primitive->filterLength)));
+    }
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->mode);
+    CsrMemCpySer(ptr, len, (const void *) primitive->arpFilterAddress.a, ((CsrUint16) (4)));
+    return(ptr);
+}
+
+
+void* CsrWifiSmePacketFilterSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmePacketFilterSetReq *primitive = (CsrWifiSmePacketFilterSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmePacketFilterSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->filterLength, buffer, &offset);
+    if (primitive->filterLength)
+    {
+        primitive->filter = (CsrUint8 *)CsrPmemAlloc(primitive->filterLength);
+        CsrMemCpyDes(primitive->filter, buffer, &offset, ((CsrUint16) (primitive->filterLength)));
+    }
+    else
+    {
+        primitive->filter = NULL;
+    }
+    CsrUint8Des((CsrUint8 *) &primitive->mode, buffer, &offset);
+    CsrMemCpyDes(primitive->arpFilterAddress.a, buffer, &offset, ((CsrUint16) (4)));
+
+    return primitive;
+}
+
+
+void CsrWifiSmePacketFilterSetReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmePacketFilterSetReq *primitive = (CsrWifiSmePacketFilterSetReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->filter);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmePmkidReqSizeof(void *msg)
+{
+    CsrWifiSmePmkidReq *primitive = (CsrWifiSmePmkidReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 29) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrWifiSmeListAction primitive->action */
+    bufferSize += 1; /* CsrUint8 primitive->setPmkidsCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setPmkidsCount; i1++)
+        {
+            bufferSize += 6;  /* CsrUint8 primitive->setPmkids[i1].bssid.a[6] */
+            bufferSize += 16; /* CsrUint8 primitive->setPmkids[i1].pmkid[16] */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmePmkidReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmePmkidReq *primitive = (CsrWifiSmePmkidReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->setPmkidsCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setPmkidsCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->setPmkids[i1].bssid.a, ((CsrUint16) (6)));
+            CsrMemCpySer(ptr, len, (const void *) primitive->setPmkids[i1].pmkid, ((CsrUint16) (16)));
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmePmkidReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmePmkidReq *primitive = (CsrWifiSmePmkidReq *) CsrPmemAlloc(sizeof(CsrWifiSmePmkidReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->setPmkidsCount, buffer, &offset);
+    primitive->setPmkids = NULL;
+    if (primitive->setPmkidsCount)
+    {
+        primitive->setPmkids = (CsrWifiSmePmkid *)CsrPmemAlloc(sizeof(CsrWifiSmePmkid) * primitive->setPmkidsCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->setPmkidsCount; i1++)
+        {
+            CsrMemCpyDes(primitive->setPmkids[i1].bssid.a, buffer, &offset, ((CsrUint16) (6)));
+            CsrMemCpyDes(primitive->setPmkids[i1].pmkid, buffer, &offset, ((CsrUint16) (16)));
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmePmkidReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmePmkidReq *primitive = (CsrWifiSmePmkidReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->setPmkids);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmePowerConfigSetReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 11) */
+    bufferSize += 1; /* CsrWifiSmePowerSaveLevel primitive->powerConfig.powerSaveLevel */
+    bufferSize += 2; /* CsrUint16 primitive->powerConfig.listenIntervalTu */
+    bufferSize += 1; /* CsrBool primitive->powerConfig.rxDtims */
+    bufferSize += 1; /* CsrWifiSmeD3AutoScanMode primitive->powerConfig.d3AutoScanMode */
+    bufferSize += 1; /* CsrUint8 primitive->powerConfig.clientTrafficWindow */
+    bufferSize += 1; /* CsrBool primitive->powerConfig.opportunisticPowerSave */
+    bufferSize += 1; /* CsrBool primitive->powerConfig.noticeOfAbsence */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmePowerConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmePowerConfigSetReq *primitive = (CsrWifiSmePowerConfigSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.powerSaveLevel);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->powerConfig.listenIntervalTu);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.rxDtims);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.d3AutoScanMode);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.clientTrafficWindow);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.opportunisticPowerSave);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.noticeOfAbsence);
+    return(ptr);
+}
+
+
+void* CsrWifiSmePowerConfigSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmePowerConfigSetReq *primitive = (CsrWifiSmePowerConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmePowerConfigSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.powerSaveLevel, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->powerConfig.listenIntervalTu, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.rxDtims, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.d3AutoScanMode, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.clientTrafficWindow, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.opportunisticPowerSave, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.noticeOfAbsence, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeRoamingConfigSetReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 70) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            bufferSize += 2; /* CsrInt16 primitive->roamingConfig.roamingBands[i2].rssiHighThreshold */
+            bufferSize += 2; /* CsrInt16 primitive->roamingConfig.roamingBands[i2].rssiLowThreshold */
+            bufferSize += 2; /* CsrInt16 primitive->roamingConfig.roamingBands[i2].snrHighThreshold */
+            bufferSize += 2; /* CsrInt16 primitive->roamingConfig.roamingBands[i2].snrLowThreshold */
+        }
+    }
+    bufferSize += 1;         /* CsrBool primitive->roamingConfig.disableSmoothRoaming */
+    bufferSize += 1;         /* CsrBool primitive->roamingConfig.disableRoamScans */
+    bufferSize += 1;         /* CsrUint8 primitive->roamingConfig.reconnectLimit */
+    bufferSize += 2;         /* CsrUint16 primitive->roamingConfig.reconnectLimitIntervalMs */
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].intervalSeconds */
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].validitySeconds */
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].minActiveChannelTimeTu */
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].maxActiveChannelTimeTu */
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].minPassiveChannelTimeTu */
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].maxPassiveChannelTimeTu */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeRoamingConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeRoamingConfigSetReq *primitive = (CsrWifiSmeRoamingConfigSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamingBands[i2].rssiHighThreshold);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamingBands[i2].rssiLowThreshold);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamingBands[i2].snrHighThreshold);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamingBands[i2].snrLowThreshold);
+        }
+    }
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->roamingConfig.disableSmoothRoaming);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->roamingConfig.disableRoamScans);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->roamingConfig.reconnectLimit);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.reconnectLimitIntervalMs);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].intervalSeconds);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].validitySeconds);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].minActiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].maxActiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].minPassiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].maxPassiveChannelTimeTu);
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeRoamingConfigSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeRoamingConfigSetReq *primitive = (CsrWifiSmeRoamingConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamingConfigSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamingBands[i2].rssiHighThreshold, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamingBands[i2].rssiLowThreshold, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamingBands[i2].snrHighThreshold, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamingBands[i2].snrLowThreshold, buffer, &offset);
+        }
+    }
+    CsrUint8Des((CsrUint8 *) &primitive->roamingConfig.disableSmoothRoaming, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->roamingConfig.disableRoamScans, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->roamingConfig.reconnectLimit, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.reconnectLimitIntervalMs, buffer, &offset);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].intervalSeconds, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].validitySeconds, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].minActiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].maxActiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].minPassiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].maxPassiveChannelTimeTu, buffer, &offset);
+        }
+    }
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeScanConfigSetReqSizeof(void *msg)
+{
+    CsrWifiSmeScanConfigSetReq *primitive = (CsrWifiSmeScanConfigSetReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 63) */
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 4; i2++)
+        {
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].intervalSeconds */
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].validitySeconds */
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].minActiveChannelTimeTu */
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].maxActiveChannelTimeTu */
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].minPassiveChannelTimeTu */
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].maxPassiveChannelTimeTu */
+        }
+    }
+    bufferSize += 1;                                             /* CsrBool primitive->scanConfig.disableAutonomousScans */
+    bufferSize += 2;                                             /* CsrUint16 primitive->scanConfig.maxResults */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.highRssiThreshold */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.lowRssiThreshold */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.deltaRssiThreshold */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.highSnrThreshold */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.lowSnrThreshold */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.deltaSnrThreshold */
+    bufferSize += 2;                                             /* CsrUint16 primitive->scanConfig.passiveChannelListCount */
+    bufferSize += primitive->scanConfig.passiveChannelListCount; /* CsrUint8 primitive->scanConfig.passiveChannelList */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeScanConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeScanConfigSetReq *primitive = (CsrWifiSmeScanConfigSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 4; i2++)
+        {
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].intervalSeconds);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].validitySeconds);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].minActiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].maxActiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].minPassiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].maxPassiveChannelTimeTu);
+        }
+    }
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.disableAutonomousScans);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.maxResults);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.highRssiThreshold);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.lowRssiThreshold);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.deltaRssiThreshold);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.highSnrThreshold);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.lowSnrThreshold);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.deltaSnrThreshold);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.passiveChannelListCount);
+    if (primitive->scanConfig.passiveChannelListCount)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->scanConfig.passiveChannelList, ((CsrUint16) (primitive->scanConfig.passiveChannelListCount)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeScanConfigSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeScanConfigSetReq *primitive = (CsrWifiSmeScanConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeScanConfigSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 4; i2++)
+        {
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].intervalSeconds, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].validitySeconds, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].minActiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].maxActiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].minPassiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].maxPassiveChannelTimeTu, buffer, &offset);
+        }
+    }
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.disableAutonomousScans, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->scanConfig.maxResults, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.highRssiThreshold, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.lowRssiThreshold, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.deltaRssiThreshold, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.highSnrThreshold, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.lowSnrThreshold, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.deltaSnrThreshold, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->scanConfig.passiveChannelListCount, buffer, &offset);
+    if (primitive->scanConfig.passiveChannelListCount)
+    {
+        primitive->scanConfig.passiveChannelList = (CsrUint8 *)CsrPmemAlloc(primitive->scanConfig.passiveChannelListCount);
+        CsrMemCpyDes(primitive->scanConfig.passiveChannelList, buffer, &offset, ((CsrUint16) (primitive->scanConfig.passiveChannelListCount)));
+    }
+    else
+    {
+        primitive->scanConfig.passiveChannelList = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeScanConfigSetReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeScanConfigSetReq *primitive = (CsrWifiSmeScanConfigSetReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->scanConfig.passiveChannelList);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeScanFullReqSizeof(void *msg)
+{
+    CsrWifiSmeScanFullReq *primitive = (CsrWifiSmeScanFullReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 52) */
+    bufferSize += 1; /* CsrUint8 primitive->ssidCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->ssidCount; i1++)
+        {
+            bufferSize += 32;                  /* CsrUint8 primitive->ssid[i1].ssid[32] */
+            bufferSize += 1;                   /* CsrUint8 primitive->ssid[i1].length */
+        }
+    }
+    bufferSize += 6;                           /* CsrUint8 primitive->bssid.a[6] */
+    bufferSize += 1;                           /* CsrBool primitive->forceScan */
+    bufferSize += 1;                           /* CsrWifiSmeBssType primitive->bssType */
+    bufferSize += 1;                           /* CsrWifiSmeScanType primitive->scanType */
+    bufferSize += 2;                           /* CsrUint16 primitive->channelListCount */
+    bufferSize += primitive->channelListCount; /* CsrUint8 primitive->channelList */
+    bufferSize += 2;                           /* CsrUint16 primitive->probeIeLength */
+    bufferSize += primitive->probeIeLength;    /* CsrUint8 primitive->probeIe */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeScanFullReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeScanFullReq *primitive = (CsrWifiSmeScanFullReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ssidCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->ssidCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->ssid[i1].ssid, ((CsrUint16) (32)));
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->ssid[i1].length);
+        }
+    }
+    CsrMemCpySer(ptr, len, (const void *) primitive->bssid.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->forceScan);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->bssType);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanType);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->channelListCount);
+    if (primitive->channelListCount)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->channelList, ((CsrUint16) (primitive->channelListCount)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->probeIeLength);
+    if (primitive->probeIeLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->probeIe, ((CsrUint16) (primitive->probeIeLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeScanFullReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeScanFullReq *primitive = (CsrWifiSmeScanFullReq *) CsrPmemAlloc(sizeof(CsrWifiSmeScanFullReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->ssidCount, buffer, &offset);
+    primitive->ssid = NULL;
+    if (primitive->ssidCount)
+    {
+        primitive->ssid = (CsrWifiSsid *)CsrPmemAlloc(sizeof(CsrWifiSsid) * primitive->ssidCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->ssidCount; i1++)
+        {
+            CsrMemCpyDes(primitive->ssid[i1].ssid, buffer, &offset, ((CsrUint16) (32)));
+            CsrUint8Des((CsrUint8 *) &primitive->ssid[i1].length, buffer, &offset);
+        }
+    }
+    CsrMemCpyDes(primitive->bssid.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->forceScan, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->bssType, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanType, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->channelListCount, buffer, &offset);
+    if (primitive->channelListCount)
+    {
+        primitive->channelList = (CsrUint8 *)CsrPmemAlloc(primitive->channelListCount);
+        CsrMemCpyDes(primitive->channelList, buffer, &offset, ((CsrUint16) (primitive->channelListCount)));
+    }
+    else
+    {
+        primitive->channelList = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->probeIeLength, buffer, &offset);
+    if (primitive->probeIeLength)
+    {
+        primitive->probeIe = (CsrUint8 *)CsrPmemAlloc(primitive->probeIeLength);
+        CsrMemCpyDes(primitive->probeIe, buffer, &offset, ((CsrUint16) (primitive->probeIeLength)));
+    }
+    else
+    {
+        primitive->probeIe = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeScanFullReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeScanFullReq *primitive = (CsrWifiSmeScanFullReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->ssid);
+    CsrPmemFree(primitive->channelList);
+    CsrPmemFree(primitive->probeIe);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeSmeStaConfigSetReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 11) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrUint8 primitive->smeConfig.connectionQualityRssiChangeTrigger */
+    bufferSize += 1; /* CsrUint8 primitive->smeConfig.connectionQualitySnrChangeTrigger */
+    bufferSize += 1; /* CsrUint8 primitive->smeConfig.wmmModeMask */
+    bufferSize += 1; /* CsrWifiSmeRadioIF primitive->smeConfig.ifIndex */
+    bufferSize += 1; /* CsrBool primitive->smeConfig.allowUnicastUseGroupCipher */
+    bufferSize += 1; /* CsrBool primitive->smeConfig.enableOpportunisticKeyCaching */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeSmeStaConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeSmeStaConfigSetReq *primitive = (CsrWifiSmeSmeStaConfigSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.connectionQualityRssiChangeTrigger);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.connectionQualitySnrChangeTrigger);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.wmmModeMask);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.ifIndex);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.allowUnicastUseGroupCipher);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.enableOpportunisticKeyCaching);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeSmeStaConfigSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeSmeStaConfigSetReq *primitive = (CsrWifiSmeSmeStaConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeStaConfigSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.connectionQualityRssiChangeTrigger, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.connectionQualitySnrChangeTrigger, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.wmmModeMask, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.ifIndex, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.allowUnicastUseGroupCipher, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.enableOpportunisticKeyCaching, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeTspecReqSizeof(void *msg)
+{
+    CsrWifiSmeTspecReq *primitive = (CsrWifiSmeTspecReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 18) */
+    bufferSize += 2;                      /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1;                      /* CsrWifiSmeListAction primitive->action */
+    bufferSize += 4;                      /* CsrUint32 primitive->transactionId */
+    bufferSize += 1;                      /* CsrBool primitive->strict */
+    bufferSize += 1;                      /* CsrWifiSmeTspecCtrlMask primitive->ctrlMask */
+    bufferSize += 2;                      /* CsrUint16 primitive->tspecLength */
+    bufferSize += primitive->tspecLength; /* CsrUint8 primitive->tspec */
+    bufferSize += 2;                      /* CsrUint16 primitive->tclasLength */
+    bufferSize += primitive->tclasLength; /* CsrUint8 primitive->tclas */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeTspecReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeTspecReq *primitive = (CsrWifiSmeTspecReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->transactionId);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->strict);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ctrlMask);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->tspecLength);
+    if (primitive->tspecLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->tspec, ((CsrUint16) (primitive->tspecLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->tclasLength);
+    if (primitive->tclasLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->tclas, ((CsrUint16) (primitive->tclasLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeTspecReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeTspecReq *primitive = (CsrWifiSmeTspecReq *) CsrPmemAlloc(sizeof(CsrWifiSmeTspecReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->transactionId, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->strict, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->ctrlMask, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->tspecLength, buffer, &offset);
+    if (primitive->tspecLength)
+    {
+        primitive->tspec = (CsrUint8 *)CsrPmemAlloc(primitive->tspecLength);
+        CsrMemCpyDes(primitive->tspec, buffer, &offset, ((CsrUint16) (primitive->tspecLength)));
+    }
+    else
+    {
+        primitive->tspec = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->tclasLength, buffer, &offset);
+    if (primitive->tclasLength)
+    {
+        primitive->tclas = (CsrUint8 *)CsrPmemAlloc(primitive->tclasLength);
+        CsrMemCpyDes(primitive->tclas, buffer, &offset, ((CsrUint16) (primitive->tclasLength)));
+    }
+    else
+    {
+        primitive->tclas = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeTspecReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeTspecReq *primitive = (CsrWifiSmeTspecReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->tspec);
+    CsrPmemFree(primitive->tclas);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeWifiFlightmodeReqSizeof(void *msg)
+{
+    CsrWifiSmeWifiFlightmodeReq *primitive = (CsrWifiSmeWifiFlightmodeReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 14) */
+    bufferSize += 6; /* CsrUint8 primitive->address.a[6] */
+    bufferSize += 2; /* CsrUint16 primitive->mibFilesCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->mibFilesCount; i1++)
+        {
+            bufferSize += 2;                              /* CsrUint16 primitive->mibFiles[i1].length */
+            bufferSize += primitive->mibFiles[i1].length; /* CsrUint8 primitive->mibFiles[i1].data */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeWifiFlightmodeReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeWifiFlightmodeReq *primitive = (CsrWifiSmeWifiFlightmodeReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrMemCpySer(ptr, len, (const void *) primitive->address.a, ((CsrUint16) (6)));
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibFilesCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->mibFilesCount; i1++)
+        {
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibFiles[i1].length);
+            if (primitive->mibFiles[i1].length)
+            {
+                CsrMemCpySer(ptr, len, (const void *) primitive->mibFiles[i1].data, ((CsrUint16) (primitive->mibFiles[i1].length)));
+            }
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeWifiFlightmodeReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeWifiFlightmodeReq *primitive = (CsrWifiSmeWifiFlightmodeReq *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiFlightmodeReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrMemCpyDes(primitive->address.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint16Des((CsrUint16 *) &primitive->mibFilesCount, buffer, &offset);
+    primitive->mibFiles = NULL;
+    if (primitive->mibFilesCount)
+    {
+        primitive->mibFiles = (CsrWifiSmeDataBlock *)CsrPmemAlloc(sizeof(CsrWifiSmeDataBlock) * primitive->mibFilesCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->mibFilesCount; i1++)
+        {
+            CsrUint16Des((CsrUint16 *) &primitive->mibFiles[i1].length, buffer, &offset);
+            if (primitive->mibFiles[i1].length)
+            {
+                primitive->mibFiles[i1].data = (CsrUint8 *)CsrPmemAlloc(primitive->mibFiles[i1].length);
+                CsrMemCpyDes(primitive->mibFiles[i1].data, buffer, &offset, ((CsrUint16) (primitive->mibFiles[i1].length)));
+            }
+            else
+            {
+                primitive->mibFiles[i1].data = NULL;
+            }
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeWifiFlightmodeReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeWifiFlightmodeReq *primitive = (CsrWifiSmeWifiFlightmodeReq *) voidPrimitivePointer;
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->mibFilesCount; i1++)
+        {
+            CsrPmemFree(primitive->mibFiles[i1].data);
+        }
+    }
+    CsrPmemFree(primitive->mibFiles);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeWifiOnReqSizeof(void *msg)
+{
+    CsrWifiSmeWifiOnReq *primitive = (CsrWifiSmeWifiOnReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 14) */
+    bufferSize += 6; /* CsrUint8 primitive->address.a[6] */
+    bufferSize += 2; /* CsrUint16 primitive->mibFilesCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->mibFilesCount; i1++)
+        {
+            bufferSize += 2;                              /* CsrUint16 primitive->mibFiles[i1].length */
+            bufferSize += primitive->mibFiles[i1].length; /* CsrUint8 primitive->mibFiles[i1].data */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeWifiOnReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeWifiOnReq *primitive = (CsrWifiSmeWifiOnReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrMemCpySer(ptr, len, (const void *) primitive->address.a, ((CsrUint16) (6)));
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibFilesCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->mibFilesCount; i1++)
+        {
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibFiles[i1].length);
+            if (primitive->mibFiles[i1].length)
+            {
+                CsrMemCpySer(ptr, len, (const void *) primitive->mibFiles[i1].data, ((CsrUint16) (primitive->mibFiles[i1].length)));
+            }
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeWifiOnReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeWifiOnReq *primitive = (CsrWifiSmeWifiOnReq *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiOnReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrMemCpyDes(primitive->address.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint16Des((CsrUint16 *) &primitive->mibFilesCount, buffer, &offset);
+    primitive->mibFiles = NULL;
+    if (primitive->mibFilesCount)
+    {
+        primitive->mibFiles = (CsrWifiSmeDataBlock *)CsrPmemAlloc(sizeof(CsrWifiSmeDataBlock) * primitive->mibFilesCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->mibFilesCount; i1++)
+        {
+            CsrUint16Des((CsrUint16 *) &primitive->mibFiles[i1].length, buffer, &offset);
+            if (primitive->mibFiles[i1].length)
+            {
+                primitive->mibFiles[i1].data = (CsrUint8 *)CsrPmemAlloc(primitive->mibFiles[i1].length);
+                CsrMemCpyDes(primitive->mibFiles[i1].data, buffer, &offset, ((CsrUint16) (primitive->mibFiles[i1].length)));
+            }
+            else
+            {
+                primitive->mibFiles[i1].data = NULL;
+            }
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeWifiOnReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeWifiOnReq *primitive = (CsrWifiSmeWifiOnReq *) voidPrimitivePointer;
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->mibFilesCount; i1++)
+        {
+            CsrPmemFree(primitive->mibFiles[i1].data);
+        }
+    }
+    CsrPmemFree(primitive->mibFiles);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeCloakedSsidsSetReqSizeof(void *msg)
+{
+    CsrWifiSmeCloakedSsidsSetReq *primitive = (CsrWifiSmeCloakedSsidsSetReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 37) */
+    bufferSize += 1; /* CsrUint8 primitive->cloakedSsids.cloakedSsidsCount */
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < primitive->cloakedSsids.cloakedSsidsCount; i2++)
+        {
+            bufferSize += 32; /* CsrUint8 primitive->cloakedSsids.cloakedSsids[i2].ssid[32] */
+            bufferSize += 1;  /* CsrUint8 primitive->cloakedSsids.cloakedSsids[i2].length */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCloakedSsidsSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCloakedSsidsSetReq *primitive = (CsrWifiSmeCloakedSsidsSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->cloakedSsids.cloakedSsidsCount);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < primitive->cloakedSsids.cloakedSsidsCount; i2++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->cloakedSsids.cloakedSsids[i2].ssid, ((CsrUint16) (32)));
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->cloakedSsids.cloakedSsids[i2].length);
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCloakedSsidsSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCloakedSsidsSetReq *primitive = (CsrWifiSmeCloakedSsidsSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeCloakedSsidsSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->cloakedSsids.cloakedSsidsCount, buffer, &offset);
+    primitive->cloakedSsids.cloakedSsids = NULL;
+    if (primitive->cloakedSsids.cloakedSsidsCount)
+    {
+        primitive->cloakedSsids.cloakedSsids = (CsrWifiSsid *)CsrPmemAlloc(sizeof(CsrWifiSsid) * primitive->cloakedSsids.cloakedSsidsCount);
+    }
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < primitive->cloakedSsids.cloakedSsidsCount; i2++)
+        {
+            CsrMemCpyDes(primitive->cloakedSsids.cloakedSsids[i2].ssid, buffer, &offset, ((CsrUint16) (32)));
+            CsrUint8Des((CsrUint8 *) &primitive->cloakedSsids.cloakedSsids[i2].length, buffer, &offset);
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeCloakedSsidsSetReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeCloakedSsidsSetReq *primitive = (CsrWifiSmeCloakedSsidsSetReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->cloakedSsids.cloakedSsids);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeSmeCommonConfigSetReqSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 8) */
+    bufferSize += 1; /* CsrWifiSme80211dTrustLevel primitive->deviceConfig.trustLevel */
+    bufferSize += 2; /* CsrUint8 primitive->deviceConfig.countryCode[2] */
+    bufferSize += 1; /* CsrWifiSmeFirmwareDriverInterface primitive->deviceConfig.firmwareDriverInterface */
+    bufferSize += 1; /* CsrBool primitive->deviceConfig.enableStrictDraftN */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeSmeCommonConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeSmeCommonConfigSetReq *primitive = (CsrWifiSmeSmeCommonConfigSetReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->deviceConfig.trustLevel);
+    CsrMemCpySer(ptr, len, (const void *) primitive->deviceConfig.countryCode, ((CsrUint16) (2)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->deviceConfig.firmwareDriverInterface);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->deviceConfig.enableStrictDraftN);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeSmeCommonConfigSetReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeSmeCommonConfigSetReq *primitive = (CsrWifiSmeSmeCommonConfigSetReq *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeCommonConfigSetReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->deviceConfig.trustLevel, buffer, &offset);
+    CsrMemCpyDes(primitive->deviceConfig.countryCode, buffer, &offset, ((CsrUint16) (2)));
+    CsrUint8Des((CsrUint8 *) &primitive->deviceConfig.firmwareDriverInterface, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->deviceConfig.enableStrictDraftN, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeWpsConfigurationReqSizeof(void *msg)
+{
+    CsrWifiSmeWpsConfigurationReq *primitive = (CsrWifiSmeWpsConfigurationReq *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 240) */
+    bufferSize += 1;  /* CsrUint8 primitive->wpsConfig.wpsVersion */
+    bufferSize += 16; /* CsrUint8 primitive->wpsConfig.uuid[16] */
+    bufferSize += 32; /* CsrUint8 primitive->wpsConfig.deviceName[32] */
+    bufferSize += 1;  /* CsrUint8 primitive->wpsConfig.deviceNameLength */
+    bufferSize += 64; /* CsrUint8 primitive->wpsConfig.manufacturer[64] */
+    bufferSize += 1;  /* CsrUint8 primitive->wpsConfig.manufacturerLength */
+    bufferSize += 32; /* CsrUint8 primitive->wpsConfig.modelName[32] */
+    bufferSize += 1;  /* CsrUint8 primitive->wpsConfig.modelNameLength */
+    bufferSize += 32; /* CsrUint8 primitive->wpsConfig.modelNumber[32] */
+    bufferSize += 1;  /* CsrUint8 primitive->wpsConfig.modelNumberLength */
+    bufferSize += 32; /* CsrUint8 primitive->wpsConfig.serialNumber[32] */
+    bufferSize += 8;  /* CsrUint8 primitive->wpsConfig.primDeviceType.deviceDetails[8] */
+    bufferSize += 1;  /* CsrUint8 primitive->wpsConfig.secondaryDeviceTypeCount */
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < primitive->wpsConfig.secondaryDeviceTypeCount; i2++)
+        {
+            bufferSize += 8; /* CsrUint8 primitive->wpsConfig.secondaryDeviceType[i2].deviceDetails[8] */
+        }
+    }
+    bufferSize += 2;         /* CsrWifiSmeWpsConfigTypeMask primitive->wpsConfig.configMethods */
+    bufferSize += 1;         /* CsrUint8 primitive->wpsConfig.rfBands */
+    bufferSize += 4;         /* CsrUint8 primitive->wpsConfig.osVersion[4] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeWpsConfigurationReqSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeWpsConfigurationReq *primitive = (CsrWifiSmeWpsConfigurationReq *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->wpsConfig.wpsVersion);
+    CsrMemCpySer(ptr, len, (const void *) primitive->wpsConfig.uuid, ((CsrUint16) (16)));
+    CsrMemCpySer(ptr, len, (const void *) primitive->wpsConfig.deviceName, ((CsrUint16) (32)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->wpsConfig.deviceNameLength);
+    CsrMemCpySer(ptr, len, (const void *) primitive->wpsConfig.manufacturer, ((CsrUint16) (64)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->wpsConfig.manufacturerLength);
+    CsrMemCpySer(ptr, len, (const void *) primitive->wpsConfig.modelName, ((CsrUint16) (32)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->wpsConfig.modelNameLength);
+    CsrMemCpySer(ptr, len, (const void *) primitive->wpsConfig.modelNumber, ((CsrUint16) (32)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->wpsConfig.modelNumberLength);
+    CsrMemCpySer(ptr, len, (const void *) primitive->wpsConfig.serialNumber, ((CsrUint16) (32)));
+    CsrMemCpySer(ptr, len, (const void *) primitive->wpsConfig.primDeviceType.deviceDetails, ((CsrUint16) (8)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->wpsConfig.secondaryDeviceTypeCount);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < primitive->wpsConfig.secondaryDeviceTypeCount; i2++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->wpsConfig.secondaryDeviceType[i2].deviceDetails, ((CsrUint16) (8)));
+        }
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->wpsConfig.configMethods);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->wpsConfig.rfBands);
+    CsrMemCpySer(ptr, len, (const void *) primitive->wpsConfig.osVersion, ((CsrUint16) (4)));
+    return(ptr);
+}
+
+
+void* CsrWifiSmeWpsConfigurationReqDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeWpsConfigurationReq *primitive = (CsrWifiSmeWpsConfigurationReq *) CsrPmemAlloc(sizeof(CsrWifiSmeWpsConfigurationReq));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->wpsConfig.wpsVersion, buffer, &offset);
+    CsrMemCpyDes(primitive->wpsConfig.uuid, buffer, &offset, ((CsrUint16) (16)));
+    CsrMemCpyDes(primitive->wpsConfig.deviceName, buffer, &offset, ((CsrUint16) (32)));
+    CsrUint8Des((CsrUint8 *) &primitive->wpsConfig.deviceNameLength, buffer, &offset);
+    CsrMemCpyDes(primitive->wpsConfig.manufacturer, buffer, &offset, ((CsrUint16) (64)));
+    CsrUint8Des((CsrUint8 *) &primitive->wpsConfig.manufacturerLength, buffer, &offset);
+    CsrMemCpyDes(primitive->wpsConfig.modelName, buffer, &offset, ((CsrUint16) (32)));
+    CsrUint8Des((CsrUint8 *) &primitive->wpsConfig.modelNameLength, buffer, &offset);
+    CsrMemCpyDes(primitive->wpsConfig.modelNumber, buffer, &offset, ((CsrUint16) (32)));
+    CsrUint8Des((CsrUint8 *) &primitive->wpsConfig.modelNumberLength, buffer, &offset);
+    CsrMemCpyDes(primitive->wpsConfig.serialNumber, buffer, &offset, ((CsrUint16) (32)));
+    CsrMemCpyDes(primitive->wpsConfig.primDeviceType.deviceDetails, buffer, &offset, ((CsrUint16) (8)));
+    CsrUint8Des((CsrUint8 *) &primitive->wpsConfig.secondaryDeviceTypeCount, buffer, &offset);
+    primitive->wpsConfig.secondaryDeviceType = NULL;
+    if (primitive->wpsConfig.secondaryDeviceTypeCount)
+    {
+        primitive->wpsConfig.secondaryDeviceType = (CsrWifiSmeWpsDeviceType *)CsrPmemAlloc(sizeof(CsrWifiSmeWpsDeviceType) * primitive->wpsConfig.secondaryDeviceTypeCount);
+    }
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < primitive->wpsConfig.secondaryDeviceTypeCount; i2++)
+        {
+            CsrMemCpyDes(primitive->wpsConfig.secondaryDeviceType[i2].deviceDetails, buffer, &offset, ((CsrUint16) (8)));
+        }
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->wpsConfig.configMethods, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->wpsConfig.rfBands, buffer, &offset);
+    CsrMemCpyDes(primitive->wpsConfig.osVersion, buffer, &offset, ((CsrUint16) (4)));
+
+    return primitive;
+}
+
+
+void CsrWifiSmeWpsConfigurationReqSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeWpsConfigurationReq *primitive = (CsrWifiSmeWpsConfigurationReq *) voidPrimitivePointer;
+    CsrPmemFree(primitive->wpsConfig.secondaryDeviceType);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeAdhocConfigGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 2; /* CsrUint16 primitive->adHocConfig.atimWindowTu */
+    bufferSize += 2; /* CsrUint16 primitive->adHocConfig.beaconPeriodTu */
+    bufferSize += 2; /* CsrUint16 primitive->adHocConfig.joinOnlyAttempts */
+    bufferSize += 2; /* CsrUint16 primitive->adHocConfig.joinAttemptIntervalMs */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeAdhocConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeAdhocConfigGetCfm *primitive = (CsrWifiSmeAdhocConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->adHocConfig.atimWindowTu);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->adHocConfig.beaconPeriodTu);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->adHocConfig.joinOnlyAttempts);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->adHocConfig.joinAttemptIntervalMs);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeAdhocConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeAdhocConfigGetCfm *primitive = (CsrWifiSmeAdhocConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeAdhocConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->adHocConfig.atimWindowTu, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->adHocConfig.beaconPeriodTu, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->adHocConfig.joinOnlyAttempts, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->adHocConfig.joinAttemptIntervalMs, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeAssociationCompleteIndSizeof(void *msg)
+{
+    CsrWifiSmeAssociationCompleteInd *primitive = (CsrWifiSmeAssociationCompleteInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 98) */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2;                                                     /* CsrResult primitive->status */
+    bufferSize += 32;                                                    /* CsrUint8 primitive->connectionInfo.ssid.ssid[32] */
+    bufferSize += 1;                                                     /* CsrUint8 primitive->connectionInfo.ssid.length */
+    bufferSize += 6;                                                     /* CsrUint8 primitive->connectionInfo.bssid.a[6] */
+    bufferSize += 1;                                                     /* CsrWifiSme80211NetworkType primitive->connectionInfo.networkType80211 */
+    bufferSize += 1;                                                     /* CsrUint8 primitive->connectionInfo.channelNumber */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.channelFrequency */
+    bufferSize += 2;                                                     /* CsrWifiSmeAuthMode primitive->connectionInfo.authMode */
+    bufferSize += 2;                                                     /* CsrWifiSmeEncryption primitive->connectionInfo.pairwiseCipher */
+    bufferSize += 2;                                                     /* CsrWifiSmeEncryption primitive->connectionInfo.groupCipher */
+    bufferSize += 1;                                                     /* CsrWifiSmeRadioIF primitive->connectionInfo.ifIndex */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.atimWindowTu */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.beaconPeriodTu */
+    bufferSize += 1;                                                     /* CsrBool primitive->connectionInfo.reassociation */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.beaconFrameLength */
+    bufferSize += primitive->connectionInfo.beaconFrameLength;           /* CsrUint8 primitive->connectionInfo.beaconFrame */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.associationReqFrameLength */
+    bufferSize += primitive->connectionInfo.associationReqFrameLength;   /* CsrUint8 primitive->connectionInfo.associationReqFrame */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.associationRspFrameLength */
+    bufferSize += primitive->connectionInfo.associationRspFrameLength;   /* CsrUint8 primitive->connectionInfo.associationRspFrame */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocScanInfoElementsLength */
+    bufferSize += primitive->connectionInfo.assocScanInfoElementsLength; /* CsrUint8 primitive->connectionInfo.assocScanInfoElements */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocReqCapabilities */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocReqListenIntervalTu */
+    bufferSize += 6;                                                     /* CsrUint8 primitive->connectionInfo.assocReqApAddress.a[6] */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocReqInfoElementsLength */
+    bufferSize += primitive->connectionInfo.assocReqInfoElementsLength;  /* CsrUint8 primitive->connectionInfo.assocReqInfoElements */
+    bufferSize += 2;                                                     /* CsrWifiSmeIEEE80211Result primitive->connectionInfo.assocRspResult */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocRspCapabilityInfo */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocRspAssociationId */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocRspInfoElementsLength */
+    bufferSize += primitive->connectionInfo.assocRspInfoElementsLength;  /* CsrUint8 primitive->connectionInfo.assocRspInfoElements */
+    bufferSize += 2;                                                     /* CsrWifiSmeIEEE80211Reason primitive->deauthReason */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeAssociationCompleteIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeAssociationCompleteInd *primitive = (CsrWifiSmeAssociationCompleteInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.ssid.ssid, ((CsrUint16) (32)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.ssid.length);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.bssid.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.networkType80211);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.channelNumber);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.channelFrequency);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.authMode);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.pairwiseCipher);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.groupCipher);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.ifIndex);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.atimWindowTu);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.beaconPeriodTu);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.reassociation);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.beaconFrameLength);
+    if (primitive->connectionInfo.beaconFrameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.beaconFrame, ((CsrUint16) (primitive->connectionInfo.beaconFrameLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.associationReqFrameLength);
+    if (primitive->connectionInfo.associationReqFrameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.associationReqFrame, ((CsrUint16) (primitive->connectionInfo.associationReqFrameLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.associationRspFrameLength);
+    if (primitive->connectionInfo.associationRspFrameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.associationRspFrame, ((CsrUint16) (primitive->connectionInfo.associationRspFrameLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocScanInfoElementsLength);
+    if (primitive->connectionInfo.assocScanInfoElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocScanInfoElements, ((CsrUint16) (primitive->connectionInfo.assocScanInfoElementsLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocReqCapabilities);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocReqListenIntervalTu);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocReqApAddress.a, ((CsrUint16) (6)));
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocReqInfoElementsLength);
+    if (primitive->connectionInfo.assocReqInfoElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocReqInfoElements, ((CsrUint16) (primitive->connectionInfo.assocReqInfoElementsLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspResult);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspCapabilityInfo);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspAssociationId);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspInfoElementsLength);
+    if (primitive->connectionInfo.assocRspInfoElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocRspInfoElements, ((CsrUint16) (primitive->connectionInfo.assocRspInfoElementsLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->deauthReason);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeAssociationCompleteIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeAssociationCompleteInd *primitive = (CsrWifiSmeAssociationCompleteInd *) CsrPmemAlloc(sizeof(CsrWifiSmeAssociationCompleteInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionInfo.ssid.ssid, buffer, &offset, ((CsrUint16) (32)));
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.ssid.length, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionInfo.bssid.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.networkType80211, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.channelNumber, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.channelFrequency, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.authMode, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.pairwiseCipher, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.groupCipher, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.ifIndex, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.atimWindowTu, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.beaconPeriodTu, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.reassociation, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.beaconFrameLength, buffer, &offset);
+    if (primitive->connectionInfo.beaconFrameLength)
+    {
+        primitive->connectionInfo.beaconFrame = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.beaconFrameLength);
+        CsrMemCpyDes(primitive->connectionInfo.beaconFrame, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.beaconFrameLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.beaconFrame = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.associationReqFrameLength, buffer, &offset);
+    if (primitive->connectionInfo.associationReqFrameLength)
+    {
+        primitive->connectionInfo.associationReqFrame = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.associationReqFrameLength);
+        CsrMemCpyDes(primitive->connectionInfo.associationReqFrame, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.associationReqFrameLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.associationReqFrame = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.associationRspFrameLength, buffer, &offset);
+    if (primitive->connectionInfo.associationRspFrameLength)
+    {
+        primitive->connectionInfo.associationRspFrame = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.associationRspFrameLength);
+        CsrMemCpyDes(primitive->connectionInfo.associationRspFrame, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.associationRspFrameLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.associationRspFrame = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocScanInfoElementsLength, buffer, &offset);
+    if (primitive->connectionInfo.assocScanInfoElementsLength)
+    {
+        primitive->connectionInfo.assocScanInfoElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.assocScanInfoElementsLength);
+        CsrMemCpyDes(primitive->connectionInfo.assocScanInfoElements, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.assocScanInfoElementsLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.assocScanInfoElements = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocReqCapabilities, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocReqListenIntervalTu, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionInfo.assocReqApAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocReqInfoElementsLength, buffer, &offset);
+    if (primitive->connectionInfo.assocReqInfoElementsLength)
+    {
+        primitive->connectionInfo.assocReqInfoElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.assocReqInfoElementsLength);
+        CsrMemCpyDes(primitive->connectionInfo.assocReqInfoElements, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.assocReqInfoElementsLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.assocReqInfoElements = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspResult, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspCapabilityInfo, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspAssociationId, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspInfoElementsLength, buffer, &offset);
+    if (primitive->connectionInfo.assocRspInfoElementsLength)
+    {
+        primitive->connectionInfo.assocRspInfoElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.assocRspInfoElementsLength);
+        CsrMemCpyDes(primitive->connectionInfo.assocRspInfoElements, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.assocRspInfoElementsLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.assocRspInfoElements = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->deauthReason, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiSmeAssociationCompleteIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeAssociationCompleteInd *primitive = (CsrWifiSmeAssociationCompleteInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->connectionInfo.beaconFrame);
+    CsrPmemFree(primitive->connectionInfo.associationReqFrame);
+    CsrPmemFree(primitive->connectionInfo.associationRspFrame);
+    CsrPmemFree(primitive->connectionInfo.assocScanInfoElements);
+    CsrPmemFree(primitive->connectionInfo.assocReqInfoElements);
+    CsrPmemFree(primitive->connectionInfo.assocRspInfoElements);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeAssociationStartIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 44) */
+    bufferSize += 2;  /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 6;  /* CsrUint8 primitive->address.a[6] */
+    bufferSize += 32; /* CsrUint8 primitive->ssid.ssid[32] */
+    bufferSize += 1;  /* CsrUint8 primitive->ssid.length */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeAssociationStartIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeAssociationStartInd *primitive = (CsrWifiSmeAssociationStartInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrMemCpySer(ptr, len, (const void *) primitive->address.a, ((CsrUint16) (6)));
+    CsrMemCpySer(ptr, len, (const void *) primitive->ssid.ssid, ((CsrUint16) (32)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ssid.length);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeAssociationStartIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeAssociationStartInd *primitive = (CsrWifiSmeAssociationStartInd *) CsrPmemAlloc(sizeof(CsrWifiSmeAssociationStartInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrMemCpyDes(primitive->address.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrMemCpyDes(primitive->ssid.ssid, buffer, &offset, ((CsrUint16) (32)));
+    CsrUint8Des((CsrUint8 *) &primitive->ssid.length, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeBlacklistCfmSizeof(void *msg)
+{
+    CsrWifiSmeBlacklistCfm *primitive = (CsrWifiSmeBlacklistCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 15) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrWifiSmeListAction primitive->action */
+    bufferSize += 1; /* CsrUint8 primitive->getAddressCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getAddressCount; i1++)
+        {
+            bufferSize += 6; /* CsrUint8 primitive->getAddresses[i1].a[6] */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeBlacklistCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeBlacklistCfm *primitive = (CsrWifiSmeBlacklistCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->getAddressCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getAddressCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->getAddresses[i1].a, ((CsrUint16) (6)));
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeBlacklistCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeBlacklistCfm *primitive = (CsrWifiSmeBlacklistCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeBlacklistCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->getAddressCount, buffer, &offset);
+    primitive->getAddresses = NULL;
+    if (primitive->getAddressCount)
+    {
+        primitive->getAddresses = (CsrWifiMacAddress *)CsrPmemAlloc(sizeof(CsrWifiMacAddress) * primitive->getAddressCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getAddressCount; i1++)
+        {
+            CsrMemCpyDes(primitive->getAddresses[i1].a, buffer, &offset, ((CsrUint16) (6)));
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeBlacklistCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeBlacklistCfm *primitive = (CsrWifiSmeBlacklistCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->getAddresses);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeCalibrationDataGetCfmSizeof(void *msg)
+{
+    CsrWifiSmeCalibrationDataGetCfm *primitive = (CsrWifiSmeCalibrationDataGetCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 8) */
+    bufferSize += 2;                                /* CsrResult primitive->status */
+    bufferSize += 2;                                /* CsrUint16 primitive->calibrationDataLength */
+    bufferSize += primitive->calibrationDataLength; /* CsrUint8 primitive->calibrationData */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCalibrationDataGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCalibrationDataGetCfm *primitive = (CsrWifiSmeCalibrationDataGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->calibrationDataLength);
+    if (primitive->calibrationDataLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->calibrationData, ((CsrUint16) (primitive->calibrationDataLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCalibrationDataGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCalibrationDataGetCfm *primitive = (CsrWifiSmeCalibrationDataGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCalibrationDataGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->calibrationDataLength, buffer, &offset);
+    if (primitive->calibrationDataLength)
+    {
+        primitive->calibrationData = (CsrUint8 *)CsrPmemAlloc(primitive->calibrationDataLength);
+        CsrMemCpyDes(primitive->calibrationData, buffer, &offset, ((CsrUint16) (primitive->calibrationDataLength)));
+    }
+    else
+    {
+        primitive->calibrationData = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeCalibrationDataGetCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeCalibrationDataGetCfm *primitive = (CsrWifiSmeCalibrationDataGetCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->calibrationData);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeCcxConfigGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 11) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrUint8 primitive->ccxConfig.keepAliveTimeMs */
+    bufferSize += 1; /* CsrBool primitive->ccxConfig.apRoamingEnabled */
+    bufferSize += 1; /* CsrUint8 primitive->ccxConfig.measurementsMask */
+    bufferSize += 1; /* CsrBool primitive->ccxConfig.ccxRadioMgtEnabled */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCcxConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCcxConfigGetCfm *primitive = (CsrWifiSmeCcxConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ccxConfig.keepAliveTimeMs);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ccxConfig.apRoamingEnabled);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ccxConfig.measurementsMask);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->ccxConfig.ccxRadioMgtEnabled);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCcxConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCcxConfigGetCfm *primitive = (CsrWifiSmeCcxConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCcxConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->ccxConfig.keepAliveTimeMs, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->ccxConfig.apRoamingEnabled, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->ccxConfig.measurementsMask, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->ccxConfig.ccxRadioMgtEnabled, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeCcxConfigSetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCcxConfigSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCcxConfigSetCfm *primitive = (CsrWifiSmeCcxConfigSetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCcxConfigSetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCcxConfigSetCfm *primitive = (CsrWifiSmeCcxConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCcxConfigSetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeCoexConfigGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 31) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrBool primitive->coexConfig.coexEnableSchemeManagement */
+    bufferSize += 1; /* CsrBool primitive->coexConfig.coexPeriodicWakeHost */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexTrafficBurstyLatencyMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexTrafficContinuousLatencyMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexObexBlackoutDurationMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexObexBlackoutPeriodMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexA2dpBrBlackoutDurationMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexA2dpBrBlackoutPeriodMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexA2dpEdrBlackoutDurationMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexA2dpEdrBlackoutPeriodMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexPagingBlackoutDurationMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexPagingBlackoutPeriodMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexInquiryBlackoutDurationMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexConfig.coexInquiryBlackoutPeriodMs */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCoexConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCoexConfigGetCfm *primitive = (CsrWifiSmeCoexConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->coexConfig.coexEnableSchemeManagement);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->coexConfig.coexPeriodicWakeHost);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexTrafficBurstyLatencyMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexTrafficContinuousLatencyMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexObexBlackoutDurationMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexObexBlackoutPeriodMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexA2dpBrBlackoutDurationMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexA2dpBrBlackoutPeriodMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexA2dpEdrBlackoutDurationMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexA2dpEdrBlackoutPeriodMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexPagingBlackoutDurationMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexPagingBlackoutPeriodMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexInquiryBlackoutDurationMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexConfig.coexInquiryBlackoutPeriodMs);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCoexConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCoexConfigGetCfm *primitive = (CsrWifiSmeCoexConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCoexConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->coexConfig.coexEnableSchemeManagement, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->coexConfig.coexPeriodicWakeHost, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexTrafficBurstyLatencyMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexTrafficContinuousLatencyMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexObexBlackoutDurationMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexObexBlackoutPeriodMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexA2dpBrBlackoutDurationMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexA2dpBrBlackoutPeriodMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexA2dpEdrBlackoutDurationMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexA2dpEdrBlackoutPeriodMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexPagingBlackoutDurationMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexPagingBlackoutPeriodMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexInquiryBlackoutDurationMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexConfig.coexInquiryBlackoutPeriodMs, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeCoexInfoGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 24) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrBool primitive->coexInfo.hasTrafficData */
+    bufferSize += 1; /* CsrWifiSmeTrafficType primitive->coexInfo.currentTrafficType */
+    bufferSize += 2; /* CsrUint16 primitive->coexInfo.currentPeriodMs */
+    bufferSize += 1; /* CsrWifiSmePowerSaveLevel primitive->coexInfo.currentPowerSave */
+    bufferSize += 2; /* CsrUint16 primitive->coexInfo.currentCoexPeriodMs */
+    bufferSize += 2; /* CsrUint16 primitive->coexInfo.currentCoexLatencyMs */
+    bufferSize += 1; /* CsrBool primitive->coexInfo.hasBtDevice */
+    bufferSize += 4; /* CsrUint32 primitive->coexInfo.currentBlackoutDurationUs */
+    bufferSize += 4; /* CsrUint32 primitive->coexInfo.currentBlackoutPeriodUs */
+    bufferSize += 1; /* CsrWifiSmeCoexScheme primitive->coexInfo.currentCoexScheme */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCoexInfoGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCoexInfoGetCfm *primitive = (CsrWifiSmeCoexInfoGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->coexInfo.hasTrafficData);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->coexInfo.currentTrafficType);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexInfo.currentPeriodMs);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->coexInfo.currentPowerSave);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexInfo.currentCoexPeriodMs);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->coexInfo.currentCoexLatencyMs);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->coexInfo.hasBtDevice);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->coexInfo.currentBlackoutDurationUs);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->coexInfo.currentBlackoutPeriodUs);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->coexInfo.currentCoexScheme);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCoexInfoGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCoexInfoGetCfm *primitive = (CsrWifiSmeCoexInfoGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCoexInfoGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->coexInfo.hasTrafficData, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->coexInfo.currentTrafficType, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexInfo.currentPeriodMs, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->coexInfo.currentPowerSave, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexInfo.currentCoexPeriodMs, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->coexInfo.currentCoexLatencyMs, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->coexInfo.hasBtDevice, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->coexInfo.currentBlackoutDurationUs, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->coexInfo.currentBlackoutPeriodUs, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->coexInfo.currentCoexScheme, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeConnectCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeConnectCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeConnectCfm *primitive = (CsrWifiSmeConnectCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeConnectCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeConnectCfm *primitive = (CsrWifiSmeConnectCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeConnectionConfigGetCfmSizeof(void *msg)
+{
+    CsrWifiSmeConnectionConfigGetCfm *primitive = (CsrWifiSmeConnectionConfigGetCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 59) */
+    bufferSize += 2;                                                                     /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2;                                                                     /* CsrResult primitive->status */
+    bufferSize += 32;                                                                    /* CsrUint8 primitive->connectionConfig.ssid.ssid[32] */
+    bufferSize += 1;                                                                     /* CsrUint8 primitive->connectionConfig.ssid.length */
+    bufferSize += 6;                                                                     /* CsrUint8 primitive->connectionConfig.bssid.a[6] */
+    bufferSize += 1;                                                                     /* CsrWifiSmeBssType primitive->connectionConfig.bssType */
+    bufferSize += 1;                                                                     /* CsrWifiSmeRadioIF primitive->connectionConfig.ifIndex */
+    bufferSize += 1;                                                                     /* CsrWifiSme80211PrivacyMode primitive->connectionConfig.privacyMode */
+    bufferSize += 2;                                                                     /* CsrWifiSmeAuthModeMask primitive->connectionConfig.authModeMask */
+    bufferSize += 2;                                                                     /* CsrWifiSmeEncryptionMask primitive->connectionConfig.encryptionModeMask */
+    bufferSize += 2;                                                                     /* CsrUint16 primitive->connectionConfig.mlmeAssociateReqInformationElementsLength */
+    bufferSize += primitive->connectionConfig.mlmeAssociateReqInformationElementsLength; /* CsrUint8 primitive->connectionConfig.mlmeAssociateReqInformationElements */
+    bufferSize += 1;                                                                     /* CsrWifiSmeWmmQosInfoMask primitive->connectionConfig.wmmQosInfo */
+    bufferSize += 1;                                                                     /* CsrBool primitive->connectionConfig.adhocJoinOnly */
+    bufferSize += 1;                                                                     /* CsrUint8 primitive->connectionConfig.adhocChannel */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeConnectionConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeConnectionConfigGetCfm *primitive = (CsrWifiSmeConnectionConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionConfig.ssid.ssid, ((CsrUint16) (32)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.ssid.length);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionConfig.bssid.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.bssType);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.ifIndex);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.privacyMode);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionConfig.authModeMask);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionConfig.encryptionModeMask);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionConfig.mlmeAssociateReqInformationElementsLength);
+    if (primitive->connectionConfig.mlmeAssociateReqInformationElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionConfig.mlmeAssociateReqInformationElements, ((CsrUint16) (primitive->connectionConfig.mlmeAssociateReqInformationElementsLength)));
+    }
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.wmmQosInfo);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.adhocJoinOnly);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionConfig.adhocChannel);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeConnectionConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeConnectionConfigGetCfm *primitive = (CsrWifiSmeConnectionConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionConfig.ssid.ssid, buffer, &offset, ((CsrUint16) (32)));
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.ssid.length, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionConfig.bssid.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.bssType, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.ifIndex, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.privacyMode, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionConfig.authModeMask, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionConfig.encryptionModeMask, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionConfig.mlmeAssociateReqInformationElementsLength, buffer, &offset);
+    if (primitive->connectionConfig.mlmeAssociateReqInformationElementsLength)
+    {
+        primitive->connectionConfig.mlmeAssociateReqInformationElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionConfig.mlmeAssociateReqInformationElementsLength);
+        CsrMemCpyDes(primitive->connectionConfig.mlmeAssociateReqInformationElements, buffer, &offset, ((CsrUint16) (primitive->connectionConfig.mlmeAssociateReqInformationElementsLength)));
+    }
+    else
+    {
+        primitive->connectionConfig.mlmeAssociateReqInformationElements = NULL;
+    }
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.wmmQosInfo, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.adhocJoinOnly, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionConfig.adhocChannel, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiSmeConnectionConfigGetCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeConnectionConfigGetCfm *primitive = (CsrWifiSmeConnectionConfigGetCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->connectionConfig.mlmeAssociateReqInformationElements);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeConnectionInfoGetCfmSizeof(void *msg)
+{
+    CsrWifiSmeConnectionInfoGetCfm *primitive = (CsrWifiSmeConnectionInfoGetCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 96) */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2;                                                     /* CsrResult primitive->status */
+    bufferSize += 32;                                                    /* CsrUint8 primitive->connectionInfo.ssid.ssid[32] */
+    bufferSize += 1;                                                     /* CsrUint8 primitive->connectionInfo.ssid.length */
+    bufferSize += 6;                                                     /* CsrUint8 primitive->connectionInfo.bssid.a[6] */
+    bufferSize += 1;                                                     /* CsrWifiSme80211NetworkType primitive->connectionInfo.networkType80211 */
+    bufferSize += 1;                                                     /* CsrUint8 primitive->connectionInfo.channelNumber */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.channelFrequency */
+    bufferSize += 2;                                                     /* CsrWifiSmeAuthMode primitive->connectionInfo.authMode */
+    bufferSize += 2;                                                     /* CsrWifiSmeEncryption primitive->connectionInfo.pairwiseCipher */
+    bufferSize += 2;                                                     /* CsrWifiSmeEncryption primitive->connectionInfo.groupCipher */
+    bufferSize += 1;                                                     /* CsrWifiSmeRadioIF primitive->connectionInfo.ifIndex */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.atimWindowTu */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.beaconPeriodTu */
+    bufferSize += 1;                                                     /* CsrBool primitive->connectionInfo.reassociation */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.beaconFrameLength */
+    bufferSize += primitive->connectionInfo.beaconFrameLength;           /* CsrUint8 primitive->connectionInfo.beaconFrame */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.associationReqFrameLength */
+    bufferSize += primitive->connectionInfo.associationReqFrameLength;   /* CsrUint8 primitive->connectionInfo.associationReqFrame */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.associationRspFrameLength */
+    bufferSize += primitive->connectionInfo.associationRspFrameLength;   /* CsrUint8 primitive->connectionInfo.associationRspFrame */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocScanInfoElementsLength */
+    bufferSize += primitive->connectionInfo.assocScanInfoElementsLength; /* CsrUint8 primitive->connectionInfo.assocScanInfoElements */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocReqCapabilities */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocReqListenIntervalTu */
+    bufferSize += 6;                                                     /* CsrUint8 primitive->connectionInfo.assocReqApAddress.a[6] */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocReqInfoElementsLength */
+    bufferSize += primitive->connectionInfo.assocReqInfoElementsLength;  /* CsrUint8 primitive->connectionInfo.assocReqInfoElements */
+    bufferSize += 2;                                                     /* CsrWifiSmeIEEE80211Result primitive->connectionInfo.assocRspResult */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocRspCapabilityInfo */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocRspAssociationId */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocRspInfoElementsLength */
+    bufferSize += primitive->connectionInfo.assocRspInfoElementsLength;  /* CsrUint8 primitive->connectionInfo.assocRspInfoElements */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeConnectionInfoGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeConnectionInfoGetCfm *primitive = (CsrWifiSmeConnectionInfoGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.ssid.ssid, ((CsrUint16) (32)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.ssid.length);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.bssid.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.networkType80211);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.channelNumber);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.channelFrequency);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.authMode);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.pairwiseCipher);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.groupCipher);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.ifIndex);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.atimWindowTu);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.beaconPeriodTu);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.reassociation);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.beaconFrameLength);
+    if (primitive->connectionInfo.beaconFrameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.beaconFrame, ((CsrUint16) (primitive->connectionInfo.beaconFrameLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.associationReqFrameLength);
+    if (primitive->connectionInfo.associationReqFrameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.associationReqFrame, ((CsrUint16) (primitive->connectionInfo.associationReqFrameLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.associationRspFrameLength);
+    if (primitive->connectionInfo.associationRspFrameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.associationRspFrame, ((CsrUint16) (primitive->connectionInfo.associationRspFrameLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocScanInfoElementsLength);
+    if (primitive->connectionInfo.assocScanInfoElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocScanInfoElements, ((CsrUint16) (primitive->connectionInfo.assocScanInfoElementsLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocReqCapabilities);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocReqListenIntervalTu);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocReqApAddress.a, ((CsrUint16) (6)));
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocReqInfoElementsLength);
+    if (primitive->connectionInfo.assocReqInfoElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocReqInfoElements, ((CsrUint16) (primitive->connectionInfo.assocReqInfoElementsLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspResult);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspCapabilityInfo);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspAssociationId);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspInfoElementsLength);
+    if (primitive->connectionInfo.assocRspInfoElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocRspInfoElements, ((CsrUint16) (primitive->connectionInfo.assocRspInfoElementsLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeConnectionInfoGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeConnectionInfoGetCfm *primitive = (CsrWifiSmeConnectionInfoGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionInfoGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionInfo.ssid.ssid, buffer, &offset, ((CsrUint16) (32)));
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.ssid.length, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionInfo.bssid.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.networkType80211, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.channelNumber, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.channelFrequency, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.authMode, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.pairwiseCipher, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.groupCipher, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.ifIndex, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.atimWindowTu, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.beaconPeriodTu, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.reassociation, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.beaconFrameLength, buffer, &offset);
+    if (primitive->connectionInfo.beaconFrameLength)
+    {
+        primitive->connectionInfo.beaconFrame = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.beaconFrameLength);
+        CsrMemCpyDes(primitive->connectionInfo.beaconFrame, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.beaconFrameLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.beaconFrame = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.associationReqFrameLength, buffer, &offset);
+    if (primitive->connectionInfo.associationReqFrameLength)
+    {
+        primitive->connectionInfo.associationReqFrame = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.associationReqFrameLength);
+        CsrMemCpyDes(primitive->connectionInfo.associationReqFrame, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.associationReqFrameLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.associationReqFrame = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.associationRspFrameLength, buffer, &offset);
+    if (primitive->connectionInfo.associationRspFrameLength)
+    {
+        primitive->connectionInfo.associationRspFrame = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.associationRspFrameLength);
+        CsrMemCpyDes(primitive->connectionInfo.associationRspFrame, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.associationRspFrameLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.associationRspFrame = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocScanInfoElementsLength, buffer, &offset);
+    if (primitive->connectionInfo.assocScanInfoElementsLength)
+    {
+        primitive->connectionInfo.assocScanInfoElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.assocScanInfoElementsLength);
+        CsrMemCpyDes(primitive->connectionInfo.assocScanInfoElements, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.assocScanInfoElementsLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.assocScanInfoElements = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocReqCapabilities, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocReqListenIntervalTu, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionInfo.assocReqApAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocReqInfoElementsLength, buffer, &offset);
+    if (primitive->connectionInfo.assocReqInfoElementsLength)
+    {
+        primitive->connectionInfo.assocReqInfoElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.assocReqInfoElementsLength);
+        CsrMemCpyDes(primitive->connectionInfo.assocReqInfoElements, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.assocReqInfoElementsLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.assocReqInfoElements = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspResult, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspCapabilityInfo, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspAssociationId, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspInfoElementsLength, buffer, &offset);
+    if (primitive->connectionInfo.assocRspInfoElementsLength)
+    {
+        primitive->connectionInfo.assocRspInfoElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.assocRspInfoElementsLength);
+        CsrMemCpyDes(primitive->connectionInfo.assocRspInfoElements, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.assocRspInfoElementsLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.assocRspInfoElements = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeConnectionInfoGetCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeConnectionInfoGetCfm *primitive = (CsrWifiSmeConnectionInfoGetCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->connectionInfo.beaconFrame);
+    CsrPmemFree(primitive->connectionInfo.associationReqFrame);
+    CsrPmemFree(primitive->connectionInfo.associationRspFrame);
+    CsrPmemFree(primitive->connectionInfo.assocScanInfoElements);
+    CsrPmemFree(primitive->connectionInfo.assocReqInfoElements);
+    CsrPmemFree(primitive->connectionInfo.assocRspInfoElements);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeConnectionQualityIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrInt16 primitive->linkQuality.unifiRssi */
+    bufferSize += 2; /* CsrInt16 primitive->linkQuality.unifiSnr */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeConnectionQualityIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeConnectionQualityInd *primitive = (CsrWifiSmeConnectionQualityInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->linkQuality.unifiRssi);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->linkQuality.unifiSnr);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeConnectionQualityIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeConnectionQualityInd *primitive = (CsrWifiSmeConnectionQualityInd *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionQualityInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->linkQuality.unifiRssi, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->linkQuality.unifiSnr, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeConnectionStatsGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 101) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrUint8 primitive->connectionStats.unifiTxDataRate */
+    bufferSize += 1; /* CsrUint8 primitive->connectionStats.unifiRxDataRate */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11RetryCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11MultipleRetryCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11AckFailureCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11FrameDuplicateCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11FcsErrorCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11RtsSuccessCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11RtsFailureCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11FailedCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11TransmittedFragmentCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11TransmittedFrameCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11WepExcludedCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11WepIcvErrorCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11WepUndecryptableCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11MulticastReceivedFrameCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11MulticastTransmittedFrameCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11ReceivedFragmentCount */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11Rsna4WayHandshakeFailures */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11RsnaTkipCounterMeasuresInvoked */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11RsnaStatsTkipLocalMicFailures */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11RsnaStatsTkipReplays */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11RsnaStatsTkipIcvErrors */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11RsnaStatsCcmpReplays */
+    bufferSize += 4; /* CsrUint32 primitive->connectionStats.dot11RsnaStatsCcmpDecryptErrors */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeConnectionStatsGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeConnectionStatsGetCfm *primitive = (CsrWifiSmeConnectionStatsGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionStats.unifiTxDataRate);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionStats.unifiRxDataRate);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11RetryCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11MultipleRetryCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11AckFailureCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11FrameDuplicateCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11FcsErrorCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11RtsSuccessCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11RtsFailureCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11FailedCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11TransmittedFragmentCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11TransmittedFrameCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11WepExcludedCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11WepIcvErrorCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11WepUndecryptableCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11MulticastReceivedFrameCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11MulticastTransmittedFrameCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11ReceivedFragmentCount);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11Rsna4WayHandshakeFailures);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11RsnaTkipCounterMeasuresInvoked);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11RsnaStatsTkipLocalMicFailures);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11RsnaStatsTkipReplays);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11RsnaStatsTkipIcvErrors);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11RsnaStatsCcmpReplays);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->connectionStats.dot11RsnaStatsCcmpDecryptErrors);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeConnectionStatsGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeConnectionStatsGetCfm *primitive = (CsrWifiSmeConnectionStatsGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeConnectionStatsGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionStats.unifiTxDataRate, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionStats.unifiRxDataRate, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11RetryCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11MultipleRetryCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11AckFailureCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11FrameDuplicateCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11FcsErrorCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11RtsSuccessCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11RtsFailureCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11FailedCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11TransmittedFragmentCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11TransmittedFrameCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11WepExcludedCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11WepIcvErrorCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11WepUndecryptableCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11MulticastReceivedFrameCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11MulticastTransmittedFrameCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11ReceivedFragmentCount, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11Rsna4WayHandshakeFailures, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11RsnaTkipCounterMeasuresInvoked, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11RsnaStatsTkipLocalMicFailures, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11RsnaStatsTkipReplays, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11RsnaStatsTkipIcvErrors, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11RsnaStatsCcmpReplays, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->connectionStats.dot11RsnaStatsCcmpDecryptErrors, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeDisconnectCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeDisconnectCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeDisconnectCfm *primitive = (CsrWifiSmeDisconnectCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeDisconnectCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeDisconnectCfm *primitive = (CsrWifiSmeDisconnectCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeDisconnectCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeHostConfigGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 10) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrWifiSmeHostPowerMode primitive->hostConfig.powerMode */
+    bufferSize += 2; /* CsrUint16 primitive->hostConfig.applicationDataPeriodMs */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeHostConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeHostConfigGetCfm *primitive = (CsrWifiSmeHostConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->hostConfig.powerMode);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->hostConfig.applicationDataPeriodMs);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeHostConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeHostConfigGetCfm *primitive = (CsrWifiSmeHostConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeHostConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->hostConfig.powerMode, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->hostConfig.applicationDataPeriodMs, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeHostConfigSetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeHostConfigSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeHostConfigSetCfm *primitive = (CsrWifiSmeHostConfigSetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeHostConfigSetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeHostConfigSetCfm *primitive = (CsrWifiSmeHostConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeHostConfigSetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeIbssStationIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 10) */
+    bufferSize += 6; /* CsrUint8 primitive->address.a[6] */
+    bufferSize += 1; /* CsrBool primitive->isconnected */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeIbssStationIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeIbssStationInd *primitive = (CsrWifiSmeIbssStationInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrMemCpySer(ptr, len, (const void *) primitive->address.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->isconnected);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeIbssStationIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeIbssStationInd *primitive = (CsrWifiSmeIbssStationInd *) CsrPmemAlloc(sizeof(CsrWifiSmeIbssStationInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrMemCpyDes(primitive->address.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->isconnected, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeKeyCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 15) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrWifiSmeListAction primitive->action */
+    bufferSize += 1; /* CsrWifiSmeKeyType primitive->keyType */
+    bufferSize += 6; /* CsrUint8 primitive->peerMacAddress.a[6] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeKeyCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeKeyCfm *primitive = (CsrWifiSmeKeyCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->keyType);
+    CsrMemCpySer(ptr, len, (const void *) primitive->peerMacAddress.a, ((CsrUint16) (6)));
+    return(ptr);
+}
+
+
+void* CsrWifiSmeKeyCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeKeyCfm *primitive = (CsrWifiSmeKeyCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeKeyCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->keyType, buffer, &offset);
+    CsrMemCpyDes(primitive->peerMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeLinkQualityGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 11) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 2; /* CsrInt16 primitive->linkQuality.unifiRssi */
+    bufferSize += 2; /* CsrInt16 primitive->linkQuality.unifiSnr */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeLinkQualityGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeLinkQualityGetCfm *primitive = (CsrWifiSmeLinkQualityGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->linkQuality.unifiRssi);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->linkQuality.unifiSnr);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeLinkQualityGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeLinkQualityGetCfm *primitive = (CsrWifiSmeLinkQualityGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeLinkQualityGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->linkQuality.unifiRssi, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->linkQuality.unifiSnr, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeMediaStatusIndSizeof(void *msg)
+{
+    CsrWifiSmeMediaStatusInd *primitive = (CsrWifiSmeMediaStatusInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 99) */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1;                                                     /* CsrWifiSmeMediaStatus primitive->mediaStatus */
+    bufferSize += 32;                                                    /* CsrUint8 primitive->connectionInfo.ssid.ssid[32] */
+    bufferSize += 1;                                                     /* CsrUint8 primitive->connectionInfo.ssid.length */
+    bufferSize += 6;                                                     /* CsrUint8 primitive->connectionInfo.bssid.a[6] */
+    bufferSize += 1;                                                     /* CsrWifiSme80211NetworkType primitive->connectionInfo.networkType80211 */
+    bufferSize += 1;                                                     /* CsrUint8 primitive->connectionInfo.channelNumber */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.channelFrequency */
+    bufferSize += 2;                                                     /* CsrWifiSmeAuthMode primitive->connectionInfo.authMode */
+    bufferSize += 2;                                                     /* CsrWifiSmeEncryption primitive->connectionInfo.pairwiseCipher */
+    bufferSize += 2;                                                     /* CsrWifiSmeEncryption primitive->connectionInfo.groupCipher */
+    bufferSize += 1;                                                     /* CsrWifiSmeRadioIF primitive->connectionInfo.ifIndex */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.atimWindowTu */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.beaconPeriodTu */
+    bufferSize += 1;                                                     /* CsrBool primitive->connectionInfo.reassociation */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.beaconFrameLength */
+    bufferSize += primitive->connectionInfo.beaconFrameLength;           /* CsrUint8 primitive->connectionInfo.beaconFrame */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.associationReqFrameLength */
+    bufferSize += primitive->connectionInfo.associationReqFrameLength;   /* CsrUint8 primitive->connectionInfo.associationReqFrame */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.associationRspFrameLength */
+    bufferSize += primitive->connectionInfo.associationRspFrameLength;   /* CsrUint8 primitive->connectionInfo.associationRspFrame */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocScanInfoElementsLength */
+    bufferSize += primitive->connectionInfo.assocScanInfoElementsLength; /* CsrUint8 primitive->connectionInfo.assocScanInfoElements */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocReqCapabilities */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocReqListenIntervalTu */
+    bufferSize += 6;                                                     /* CsrUint8 primitive->connectionInfo.assocReqApAddress.a[6] */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocReqInfoElementsLength */
+    bufferSize += primitive->connectionInfo.assocReqInfoElementsLength;  /* CsrUint8 primitive->connectionInfo.assocReqInfoElements */
+    bufferSize += 2;                                                     /* CsrWifiSmeIEEE80211Result primitive->connectionInfo.assocRspResult */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocRspCapabilityInfo */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocRspAssociationId */
+    bufferSize += 2;                                                     /* CsrUint16 primitive->connectionInfo.assocRspInfoElementsLength */
+    bufferSize += primitive->connectionInfo.assocRspInfoElementsLength;  /* CsrUint8 primitive->connectionInfo.assocRspInfoElements */
+    bufferSize += 2;                                                     /* CsrWifiSmeIEEE80211Reason primitive->disassocReason */
+    bufferSize += 2;                                                     /* CsrWifiSmeIEEE80211Reason primitive->deauthReason */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMediaStatusIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMediaStatusInd *primitive = (CsrWifiSmeMediaStatusInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->mediaStatus);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.ssid.ssid, ((CsrUint16) (32)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.ssid.length);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.bssid.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.networkType80211);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.channelNumber);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.channelFrequency);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.authMode);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.pairwiseCipher);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.groupCipher);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.ifIndex);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.atimWindowTu);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.beaconPeriodTu);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->connectionInfo.reassociation);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.beaconFrameLength);
+    if (primitive->connectionInfo.beaconFrameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.beaconFrame, ((CsrUint16) (primitive->connectionInfo.beaconFrameLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.associationReqFrameLength);
+    if (primitive->connectionInfo.associationReqFrameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.associationReqFrame, ((CsrUint16) (primitive->connectionInfo.associationReqFrameLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.associationRspFrameLength);
+    if (primitive->connectionInfo.associationRspFrameLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.associationRspFrame, ((CsrUint16) (primitive->connectionInfo.associationRspFrameLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocScanInfoElementsLength);
+    if (primitive->connectionInfo.assocScanInfoElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocScanInfoElements, ((CsrUint16) (primitive->connectionInfo.assocScanInfoElementsLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocReqCapabilities);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocReqListenIntervalTu);
+    CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocReqApAddress.a, ((CsrUint16) (6)));
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocReqInfoElementsLength);
+    if (primitive->connectionInfo.assocReqInfoElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocReqInfoElements, ((CsrUint16) (primitive->connectionInfo.assocReqInfoElementsLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspResult);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspCapabilityInfo);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspAssociationId);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->connectionInfo.assocRspInfoElementsLength);
+    if (primitive->connectionInfo.assocRspInfoElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->connectionInfo.assocRspInfoElements, ((CsrUint16) (primitive->connectionInfo.assocRspInfoElementsLength)));
+    }
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->disassocReason);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->deauthReason);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMediaStatusIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMediaStatusInd *primitive = (CsrWifiSmeMediaStatusInd *) CsrPmemAlloc(sizeof(CsrWifiSmeMediaStatusInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->mediaStatus, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionInfo.ssid.ssid, buffer, &offset, ((CsrUint16) (32)));
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.ssid.length, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionInfo.bssid.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.networkType80211, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.channelNumber, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.channelFrequency, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.authMode, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.pairwiseCipher, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.groupCipher, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.ifIndex, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.atimWindowTu, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.beaconPeriodTu, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->connectionInfo.reassociation, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.beaconFrameLength, buffer, &offset);
+    if (primitive->connectionInfo.beaconFrameLength)
+    {
+        primitive->connectionInfo.beaconFrame = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.beaconFrameLength);
+        CsrMemCpyDes(primitive->connectionInfo.beaconFrame, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.beaconFrameLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.beaconFrame = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.associationReqFrameLength, buffer, &offset);
+    if (primitive->connectionInfo.associationReqFrameLength)
+    {
+        primitive->connectionInfo.associationReqFrame = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.associationReqFrameLength);
+        CsrMemCpyDes(primitive->connectionInfo.associationReqFrame, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.associationReqFrameLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.associationReqFrame = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.associationRspFrameLength, buffer, &offset);
+    if (primitive->connectionInfo.associationRspFrameLength)
+    {
+        primitive->connectionInfo.associationRspFrame = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.associationRspFrameLength);
+        CsrMemCpyDes(primitive->connectionInfo.associationRspFrame, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.associationRspFrameLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.associationRspFrame = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocScanInfoElementsLength, buffer, &offset);
+    if (primitive->connectionInfo.assocScanInfoElementsLength)
+    {
+        primitive->connectionInfo.assocScanInfoElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.assocScanInfoElementsLength);
+        CsrMemCpyDes(primitive->connectionInfo.assocScanInfoElements, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.assocScanInfoElementsLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.assocScanInfoElements = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocReqCapabilities, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocReqListenIntervalTu, buffer, &offset);
+    CsrMemCpyDes(primitive->connectionInfo.assocReqApAddress.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocReqInfoElementsLength, buffer, &offset);
+    if (primitive->connectionInfo.assocReqInfoElementsLength)
+    {
+        primitive->connectionInfo.assocReqInfoElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.assocReqInfoElementsLength);
+        CsrMemCpyDes(primitive->connectionInfo.assocReqInfoElements, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.assocReqInfoElementsLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.assocReqInfoElements = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspResult, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspCapabilityInfo, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspAssociationId, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->connectionInfo.assocRspInfoElementsLength, buffer, &offset);
+    if (primitive->connectionInfo.assocRspInfoElementsLength)
+    {
+        primitive->connectionInfo.assocRspInfoElements = (CsrUint8 *)CsrPmemAlloc(primitive->connectionInfo.assocRspInfoElementsLength);
+        CsrMemCpyDes(primitive->connectionInfo.assocRspInfoElements, buffer, &offset, ((CsrUint16) (primitive->connectionInfo.assocRspInfoElementsLength)));
+    }
+    else
+    {
+        primitive->connectionInfo.assocRspInfoElements = NULL;
+    }
+    CsrUint16Des((CsrUint16 *) &primitive->disassocReason, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->deauthReason, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiSmeMediaStatusIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeMediaStatusInd *primitive = (CsrWifiSmeMediaStatusInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->connectionInfo.beaconFrame);
+    CsrPmemFree(primitive->connectionInfo.associationReqFrame);
+    CsrPmemFree(primitive->connectionInfo.associationRspFrame);
+    CsrPmemFree(primitive->connectionInfo.assocScanInfoElements);
+    CsrPmemFree(primitive->connectionInfo.assocReqInfoElements);
+    CsrPmemFree(primitive->connectionInfo.assocRspInfoElements);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeMibConfigGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrBool primitive->mibConfig.unifiFixMaxTxDataRate */
+    bufferSize += 1; /* CsrUint8 primitive->mibConfig.unifiFixTxDataRate */
+    bufferSize += 2; /* CsrUint16 primitive->mibConfig.dot11RtsThreshold */
+    bufferSize += 2; /* CsrUint16 primitive->mibConfig.dot11FragmentationThreshold */
+    bufferSize += 2; /* CsrUint16 primitive->mibConfig.dot11CurrentTxPowerLevel */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMibConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMibConfigGetCfm *primitive = (CsrWifiSmeMibConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->mibConfig.unifiFixMaxTxDataRate);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->mibConfig.unifiFixTxDataRate);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibConfig.dot11RtsThreshold);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibConfig.dot11FragmentationThreshold);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibConfig.dot11CurrentTxPowerLevel);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMibConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMibConfigGetCfm *primitive = (CsrWifiSmeMibConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeMibConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->mibConfig.unifiFixMaxTxDataRate, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->mibConfig.unifiFixTxDataRate, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibConfig.dot11RtsThreshold, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibConfig.dot11FragmentationThreshold, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibConfig.dot11CurrentTxPowerLevel, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeMibGetCfmSizeof(void *msg)
+{
+    CsrWifiSmeMibGetCfm *primitive = (CsrWifiSmeMibGetCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 8) */
+    bufferSize += 2;                             /* CsrResult primitive->status */
+    bufferSize += 2;                             /* CsrUint16 primitive->mibAttributeLength */
+    bufferSize += primitive->mibAttributeLength; /* CsrUint8 primitive->mibAttribute */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMibGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMibGetCfm *primitive = (CsrWifiSmeMibGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibAttributeLength);
+    if (primitive->mibAttributeLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->mibAttribute, ((CsrUint16) (primitive->mibAttributeLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMibGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMibGetCfm *primitive = (CsrWifiSmeMibGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeMibGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibAttributeLength, buffer, &offset);
+    if (primitive->mibAttributeLength)
+    {
+        primitive->mibAttribute = (CsrUint8 *)CsrPmemAlloc(primitive->mibAttributeLength);
+        CsrMemCpyDes(primitive->mibAttribute, buffer, &offset, ((CsrUint16) (primitive->mibAttributeLength)));
+    }
+    else
+    {
+        primitive->mibAttribute = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeMibGetCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeMibGetCfm *primitive = (CsrWifiSmeMibGetCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->mibAttribute);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeMibGetNextCfmSizeof(void *msg)
+{
+    CsrWifiSmeMibGetNextCfm *primitive = (CsrWifiSmeMibGetNextCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 8) */
+    bufferSize += 2;                             /* CsrResult primitive->status */
+    bufferSize += 2;                             /* CsrUint16 primitive->mibAttributeLength */
+    bufferSize += primitive->mibAttributeLength; /* CsrUint8 primitive->mibAttribute */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMibGetNextCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMibGetNextCfm *primitive = (CsrWifiSmeMibGetNextCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->mibAttributeLength);
+    if (primitive->mibAttributeLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->mibAttribute, ((CsrUint16) (primitive->mibAttributeLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMibGetNextCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMibGetNextCfm *primitive = (CsrWifiSmeMibGetNextCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeMibGetNextCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->mibAttributeLength, buffer, &offset);
+    if (primitive->mibAttributeLength)
+    {
+        primitive->mibAttribute = (CsrUint8 *)CsrPmemAlloc(primitive->mibAttributeLength);
+        CsrMemCpyDes(primitive->mibAttribute, buffer, &offset, ((CsrUint16) (primitive->mibAttributeLength)));
+    }
+    else
+    {
+        primitive->mibAttribute = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeMibGetNextCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeMibGetNextCfm *primitive = (CsrWifiSmeMibGetNextCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->mibAttribute);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeMicFailureIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 15) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrBool primitive->secondFailure */
+    bufferSize += 2; /* CsrUint16 primitive->count */
+    bufferSize += 6; /* CsrUint8 primitive->address.a[6] */
+    bufferSize += 1; /* CsrWifiSmeKeyType primitive->keyType */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMicFailureIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMicFailureInd *primitive = (CsrWifiSmeMicFailureInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->secondFailure);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->count);
+    CsrMemCpySer(ptr, len, (const void *) primitive->address.a, ((CsrUint16) (6)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->keyType);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMicFailureIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMicFailureInd *primitive = (CsrWifiSmeMicFailureInd *) CsrPmemAlloc(sizeof(CsrWifiSmeMicFailureInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->secondFailure, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->count, buffer, &offset);
+    CsrMemCpyDes(primitive->address.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint8Des((CsrUint8 *) &primitive->keyType, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeMulticastAddressCfmSizeof(void *msg)
+{
+    CsrWifiSmeMulticastAddressCfm *primitive = (CsrWifiSmeMulticastAddressCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 15) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrWifiSmeListAction primitive->action */
+    bufferSize += 1; /* CsrUint8 primitive->getAddressesCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getAddressesCount; i1++)
+        {
+            bufferSize += 6; /* CsrUint8 primitive->getAddresses[i1].a[6] */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeMulticastAddressCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeMulticastAddressCfm *primitive = (CsrWifiSmeMulticastAddressCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->getAddressesCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getAddressesCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->getAddresses[i1].a, ((CsrUint16) (6)));
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeMulticastAddressCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeMulticastAddressCfm *primitive = (CsrWifiSmeMulticastAddressCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeMulticastAddressCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->getAddressesCount, buffer, &offset);
+    primitive->getAddresses = NULL;
+    if (primitive->getAddressesCount)
+    {
+        primitive->getAddresses = (CsrWifiMacAddress *)CsrPmemAlloc(sizeof(CsrWifiMacAddress) * primitive->getAddressesCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getAddressesCount; i1++)
+        {
+            CsrMemCpyDes(primitive->getAddresses[i1].a, buffer, &offset, ((CsrUint16) (6)));
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeMulticastAddressCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeMulticastAddressCfm *primitive = (CsrWifiSmeMulticastAddressCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->getAddresses);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmePacketFilterSetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmePacketFilterSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmePacketFilterSetCfm *primitive = (CsrWifiSmePacketFilterSetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiSmePacketFilterSetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmePacketFilterSetCfm *primitive = (CsrWifiSmePacketFilterSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmePacketFilterSetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmePermanentMacAddressGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 11) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 6; /* CsrUint8 primitive->permanentMacAddress.a[6] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmePermanentMacAddressGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmePermanentMacAddressGetCfm *primitive = (CsrWifiSmePermanentMacAddressGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrMemCpySer(ptr, len, (const void *) primitive->permanentMacAddress.a, ((CsrUint16) (6)));
+    return(ptr);
+}
+
+
+void* CsrWifiSmePermanentMacAddressGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmePermanentMacAddressGetCfm *primitive = (CsrWifiSmePermanentMacAddressGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmePermanentMacAddressGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrMemCpyDes(primitive->permanentMacAddress.a, buffer, &offset, ((CsrUint16) (6)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmePmkidCandidateListIndSizeof(void *msg)
+{
+    CsrWifiSmePmkidCandidateListInd *primitive = (CsrWifiSmePmkidCandidateListInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrUint8 primitive->pmkidCandidatesCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->pmkidCandidatesCount; i1++)
+        {
+            bufferSize += 6; /* CsrUint8 primitive->pmkidCandidates[i1].bssid.a[6] */
+            bufferSize += 1; /* CsrBool primitive->pmkidCandidates[i1].preAuthAllowed */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmePmkidCandidateListIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmePmkidCandidateListInd *primitive = (CsrWifiSmePmkidCandidateListInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->pmkidCandidatesCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->pmkidCandidatesCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->pmkidCandidates[i1].bssid.a, ((CsrUint16) (6)));
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->pmkidCandidates[i1].preAuthAllowed);
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmePmkidCandidateListIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmePmkidCandidateListInd *primitive = (CsrWifiSmePmkidCandidateListInd *) CsrPmemAlloc(sizeof(CsrWifiSmePmkidCandidateListInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->pmkidCandidatesCount, buffer, &offset);
+    primitive->pmkidCandidates = NULL;
+    if (primitive->pmkidCandidatesCount)
+    {
+        primitive->pmkidCandidates = (CsrWifiSmePmkidCandidate *)CsrPmemAlloc(sizeof(CsrWifiSmePmkidCandidate) * primitive->pmkidCandidatesCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->pmkidCandidatesCount; i1++)
+        {
+            CsrMemCpyDes(primitive->pmkidCandidates[i1].bssid.a, buffer, &offset, ((CsrUint16) (6)));
+            CsrUint8Des((CsrUint8 *) &primitive->pmkidCandidates[i1].preAuthAllowed, buffer, &offset);
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmePmkidCandidateListIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmePmkidCandidateListInd *primitive = (CsrWifiSmePmkidCandidateListInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->pmkidCandidates);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmePmkidCfmSizeof(void *msg)
+{
+    CsrWifiSmePmkidCfm *primitive = (CsrWifiSmePmkidCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 31) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrWifiSmeListAction primitive->action */
+    bufferSize += 1; /* CsrUint8 primitive->getPmkidsCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getPmkidsCount; i1++)
+        {
+            bufferSize += 6;  /* CsrUint8 primitive->getPmkids[i1].bssid.a[6] */
+            bufferSize += 16; /* CsrUint8 primitive->getPmkids[i1].pmkid[16] */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmePmkidCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmePmkidCfm *primitive = (CsrWifiSmePmkidCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->action);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->getPmkidsCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getPmkidsCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->getPmkids[i1].bssid.a, ((CsrUint16) (6)));
+            CsrMemCpySer(ptr, len, (const void *) primitive->getPmkids[i1].pmkid, ((CsrUint16) (16)));
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmePmkidCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmePmkidCfm *primitive = (CsrWifiSmePmkidCfm *) CsrPmemAlloc(sizeof(CsrWifiSmePmkidCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->action, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->getPmkidsCount, buffer, &offset);
+    primitive->getPmkids = NULL;
+    if (primitive->getPmkidsCount)
+    {
+        primitive->getPmkids = (CsrWifiSmePmkid *)CsrPmemAlloc(sizeof(CsrWifiSmePmkid) * primitive->getPmkidsCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->getPmkidsCount; i1++)
+        {
+            CsrMemCpyDes(primitive->getPmkids[i1].bssid.a, buffer, &offset, ((CsrUint16) (6)));
+            CsrMemCpyDes(primitive->getPmkids[i1].pmkid, buffer, &offset, ((CsrUint16) (16)));
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmePmkidCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmePmkidCfm *primitive = (CsrWifiSmePmkidCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->getPmkids);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmePowerConfigGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrWifiSmePowerSaveLevel primitive->powerConfig.powerSaveLevel */
+    bufferSize += 2; /* CsrUint16 primitive->powerConfig.listenIntervalTu */
+    bufferSize += 1; /* CsrBool primitive->powerConfig.rxDtims */
+    bufferSize += 1; /* CsrWifiSmeD3AutoScanMode primitive->powerConfig.d3AutoScanMode */
+    bufferSize += 1; /* CsrUint8 primitive->powerConfig.clientTrafficWindow */
+    bufferSize += 1; /* CsrBool primitive->powerConfig.opportunisticPowerSave */
+    bufferSize += 1; /* CsrBool primitive->powerConfig.noticeOfAbsence */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmePowerConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmePowerConfigGetCfm *primitive = (CsrWifiSmePowerConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.powerSaveLevel);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->powerConfig.listenIntervalTu);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.rxDtims);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.d3AutoScanMode);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.clientTrafficWindow);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.opportunisticPowerSave);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->powerConfig.noticeOfAbsence);
+    return(ptr);
+}
+
+
+void* CsrWifiSmePowerConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmePowerConfigGetCfm *primitive = (CsrWifiSmePowerConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmePowerConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.powerSaveLevel, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->powerConfig.listenIntervalTu, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.rxDtims, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.d3AutoScanMode, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.clientTrafficWindow, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.opportunisticPowerSave, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->powerConfig.noticeOfAbsence, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeRegulatoryDomainInfoGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 10) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrBool primitive->regDomInfo.dot11MultiDomainCapabilityImplemented */
+    bufferSize += 1; /* CsrBool primitive->regDomInfo.dot11MultiDomainCapabilityEnabled */
+    bufferSize += 1; /* CsrWifiSmeRegulatoryDomain primitive->regDomInfo.currentRegulatoryDomain */
+    bufferSize += 2; /* CsrUint8 primitive->regDomInfo.currentCountryCode[2] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeRegulatoryDomainInfoGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeRegulatoryDomainInfoGetCfm *primitive = (CsrWifiSmeRegulatoryDomainInfoGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->regDomInfo.dot11MultiDomainCapabilityImplemented);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->regDomInfo.dot11MultiDomainCapabilityEnabled);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->regDomInfo.currentRegulatoryDomain);
+    CsrMemCpySer(ptr, len, (const void *) primitive->regDomInfo.currentCountryCode, ((CsrUint16) (2)));
+    return(ptr);
+}
+
+
+void* CsrWifiSmeRegulatoryDomainInfoGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeRegulatoryDomainInfoGetCfm *primitive = (CsrWifiSmeRegulatoryDomainInfoGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeRegulatoryDomainInfoGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->regDomInfo.dot11MultiDomainCapabilityImplemented, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->regDomInfo.dot11MultiDomainCapabilityEnabled, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->regDomInfo.currentRegulatoryDomain, buffer, &offset);
+    CsrMemCpyDes(primitive->regDomInfo.currentCountryCode, buffer, &offset, ((CsrUint16) (2)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeRoamCompleteIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeRoamCompleteIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeRoamCompleteInd *primitive = (CsrWifiSmeRoamCompleteInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeRoamCompleteIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeRoamCompleteInd *primitive = (CsrWifiSmeRoamCompleteInd *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamCompleteInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeRoamStartIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 8) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 1; /* CsrWifiSmeRoamReason primitive->roamReason */
+    bufferSize += 2; /* CsrWifiSmeIEEE80211Reason primitive->reason80211 */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeRoamStartIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeRoamStartInd *primitive = (CsrWifiSmeRoamStartInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->roamReason);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->reason80211);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeRoamStartIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeRoamStartInd *primitive = (CsrWifiSmeRoamStartInd *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamStartInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->roamReason, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->reason80211, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeRoamingConfigGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 72) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            bufferSize += 2; /* CsrInt16 primitive->roamingConfig.roamingBands[i2].rssiHighThreshold */
+            bufferSize += 2; /* CsrInt16 primitive->roamingConfig.roamingBands[i2].rssiLowThreshold */
+            bufferSize += 2; /* CsrInt16 primitive->roamingConfig.roamingBands[i2].snrHighThreshold */
+            bufferSize += 2; /* CsrInt16 primitive->roamingConfig.roamingBands[i2].snrLowThreshold */
+        }
+    }
+    bufferSize += 1;         /* CsrBool primitive->roamingConfig.disableSmoothRoaming */
+    bufferSize += 1;         /* CsrBool primitive->roamingConfig.disableRoamScans */
+    bufferSize += 1;         /* CsrUint8 primitive->roamingConfig.reconnectLimit */
+    bufferSize += 2;         /* CsrUint16 primitive->roamingConfig.reconnectLimitIntervalMs */
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].intervalSeconds */
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].validitySeconds */
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].minActiveChannelTimeTu */
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].maxActiveChannelTimeTu */
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].minPassiveChannelTimeTu */
+            bufferSize += 2; /* CsrUint16 primitive->roamingConfig.roamScanCfg[i2].maxPassiveChannelTimeTu */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeRoamingConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeRoamingConfigGetCfm *primitive = (CsrWifiSmeRoamingConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamingBands[i2].rssiHighThreshold);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamingBands[i2].rssiLowThreshold);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamingBands[i2].snrHighThreshold);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamingBands[i2].snrLowThreshold);
+        }
+    }
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->roamingConfig.disableSmoothRoaming);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->roamingConfig.disableRoamScans);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->roamingConfig.reconnectLimit);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.reconnectLimitIntervalMs);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].intervalSeconds);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].validitySeconds);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].minActiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].maxActiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].minPassiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->roamingConfig.roamScanCfg[i2].maxPassiveChannelTimeTu);
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeRoamingConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeRoamingConfigGetCfm *primitive = (CsrWifiSmeRoamingConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamingConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamingBands[i2].rssiHighThreshold, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamingBands[i2].rssiLowThreshold, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamingBands[i2].snrHighThreshold, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamingBands[i2].snrLowThreshold, buffer, &offset);
+        }
+    }
+    CsrUint8Des((CsrUint8 *) &primitive->roamingConfig.disableSmoothRoaming, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->roamingConfig.disableRoamScans, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->roamingConfig.reconnectLimit, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.reconnectLimitIntervalMs, buffer, &offset);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 3; i2++)
+        {
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].intervalSeconds, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].validitySeconds, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].minActiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].maxActiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].minPassiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->roamingConfig.roamScanCfg[i2].maxPassiveChannelTimeTu, buffer, &offset);
+        }
+    }
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeRoamingConfigSetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeRoamingConfigSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeRoamingConfigSetCfm *primitive = (CsrWifiSmeRoamingConfigSetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeRoamingConfigSetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeRoamingConfigSetCfm *primitive = (CsrWifiSmeRoamingConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeRoamingConfigSetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeScanConfigGetCfmSizeof(void *msg)
+{
+    CsrWifiSmeScanConfigGetCfm *primitive = (CsrWifiSmeScanConfigGetCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 65) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 4; i2++)
+        {
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].intervalSeconds */
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].validitySeconds */
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].minActiveChannelTimeTu */
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].maxActiveChannelTimeTu */
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].minPassiveChannelTimeTu */
+            bufferSize += 2;                                     /* CsrUint16 primitive->scanConfig.scanCfg[i2].maxPassiveChannelTimeTu */
+        }
+    }
+    bufferSize += 1;                                             /* CsrBool primitive->scanConfig.disableAutonomousScans */
+    bufferSize += 2;                                             /* CsrUint16 primitive->scanConfig.maxResults */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.highRssiThreshold */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.lowRssiThreshold */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.deltaRssiThreshold */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.highSnrThreshold */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.lowSnrThreshold */
+    bufferSize += 1;                                             /* CsrInt8 primitive->scanConfig.deltaSnrThreshold */
+    bufferSize += 2;                                             /* CsrUint16 primitive->scanConfig.passiveChannelListCount */
+    bufferSize += primitive->scanConfig.passiveChannelListCount; /* CsrUint8 primitive->scanConfig.passiveChannelList */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeScanConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeScanConfigGetCfm *primitive = (CsrWifiSmeScanConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 4; i2++)
+        {
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].intervalSeconds);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].validitySeconds);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].minActiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].maxActiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].minPassiveChannelTimeTu);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.scanCfg[i2].maxPassiveChannelTimeTu);
+        }
+    }
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.disableAutonomousScans);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.maxResults);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.highRssiThreshold);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.lowRssiThreshold);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.deltaRssiThreshold);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.highSnrThreshold);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.lowSnrThreshold);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanConfig.deltaSnrThreshold);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanConfig.passiveChannelListCount);
+    if (primitive->scanConfig.passiveChannelListCount)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->scanConfig.passiveChannelList, ((CsrUint16) (primitive->scanConfig.passiveChannelListCount)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeScanConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeScanConfigGetCfm *primitive = (CsrWifiSmeScanConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeScanConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < 4; i2++)
+        {
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].intervalSeconds, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].validitySeconds, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].minActiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].maxActiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].minPassiveChannelTimeTu, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanConfig.scanCfg[i2].maxPassiveChannelTimeTu, buffer, &offset);
+        }
+    }
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.disableAutonomousScans, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->scanConfig.maxResults, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.highRssiThreshold, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.lowRssiThreshold, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.deltaRssiThreshold, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.highSnrThreshold, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.lowSnrThreshold, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->scanConfig.deltaSnrThreshold, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->scanConfig.passiveChannelListCount, buffer, &offset);
+    if (primitive->scanConfig.passiveChannelListCount)
+    {
+        primitive->scanConfig.passiveChannelList = (CsrUint8 *)CsrPmemAlloc(primitive->scanConfig.passiveChannelListCount);
+        CsrMemCpyDes(primitive->scanConfig.passiveChannelList, buffer, &offset, ((CsrUint16) (primitive->scanConfig.passiveChannelListCount)));
+    }
+    else
+    {
+        primitive->scanConfig.passiveChannelList = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeScanConfigGetCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeScanConfigGetCfm *primitive = (CsrWifiSmeScanConfigGetCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->scanConfig.passiveChannelList);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeScanResultIndSizeof(void *msg)
+{
+    CsrWifiSmeScanResultInd *primitive = (CsrWifiSmeScanResultInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 149) */
+    bufferSize += 32;                                          /* CsrUint8 primitive->result.ssid.ssid[32] */
+    bufferSize += 1;                                           /* CsrUint8 primitive->result.ssid.length */
+    bufferSize += 6;                                           /* CsrUint8 primitive->result.bssid.a[6] */
+    bufferSize += 2;                                           /* CsrInt16 primitive->result.rssi */
+    bufferSize += 2;                                           /* CsrInt16 primitive->result.snr */
+    bufferSize += 1;                                           /* CsrWifiSmeRadioIF primitive->result.ifIndex */
+    bufferSize += 2;                                           /* CsrUint16 primitive->result.beaconPeriodTu */
+    bufferSize += 8;                                           /* CsrUint8 primitive->result.timeStamp.data[8] */
+    bufferSize += 8;                                           /* CsrUint8 primitive->result.localTime.data[8] */
+    bufferSize += 2;                                           /* CsrUint16 primitive->result.channelFrequency */
+    bufferSize += 2;                                           /* CsrUint16 primitive->result.capabilityInformation */
+    bufferSize += 1;                                           /* CsrUint8 primitive->result.channelNumber */
+    bufferSize += 1;                                           /* CsrWifiSmeBasicUsability primitive->result.usability */
+    bufferSize += 1;                                           /* CsrWifiSmeBssType primitive->result.bssType */
+    bufferSize += 2;                                           /* CsrUint16 primitive->result.informationElementsLength */
+    bufferSize += primitive->result.informationElementsLength; /* CsrUint8 primitive->result.informationElements */
+    bufferSize += 1;                                           /* CsrWifiSmeP2pRole primitive->result.p2pDeviceRole */
+    switch (primitive->result.p2pDeviceRole)
+    {
+        case CSR_WIFI_SME_P2P_ROLE_CLI:
+            bufferSize += 1; /* CsrUint8 primitive->result.deviceInfo.reservedCli.empty */
+            break;
+        case CSR_WIFI_SME_P2P_ROLE_GO:
+            bufferSize += 1; /* CsrWifiSmeP2pGroupCapabilityMask primitive->result.deviceInfo.groupInfo.groupCapability */
+            bufferSize += 6; /* CsrUint8 primitive->result.deviceInfo.groupInfo.p2pDeviceAddress.a[6] */
+            bufferSize += 1; /* CsrUint8 primitive->result.deviceInfo.groupInfo.p2pClientInfoCount */
+            {
+                CsrUint16 i4;
+                for (i4 = 0; i4 < primitive->result.deviceInfo.groupInfo.p2pClientInfoCount; i4++)
+                {
+                    bufferSize += 6; /* CsrUint8 primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].p2PClientInterfaceAddress.a[6] */
+                    bufferSize += 6; /* CsrUint8 primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceAddress.a[6] */
+                    bufferSize += 2; /* CsrWifiSmeWpsConfigTypeMask primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.configMethods */
+                    bufferSize += 1; /* CsrWifiSmeP2pCapabilityMask primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.p2PDeviceCap */
+                    bufferSize += 8; /* CsrUint8 primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.primDeviceType.deviceDetails[8] */
+                    bufferSize += 1; /* CsrUint8 primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount */
+                    {
+                        CsrUint16 i6;
+                        for (i6 = 0; i6 < primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount; i6++)
+                        {
+                            bufferSize += 8; /* CsrUint8 primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType[i6].deviceDetails[8] */
+                        }
+                    }
+                    bufferSize += 32;        /* CsrUint8 primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceName[32] */
+                    bufferSize += 1;         /* CsrUint8 primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceNameLength */
+                }
+            }
+            break;
+        case CSR_WIFI_SME_P2P_ROLE_NONE:
+            bufferSize += 1; /* CsrUint8 primitive->result.deviceInfo.reservedNone.empty */
+            break;
+        case CSR_WIFI_SME_P2P_ROLE_STANDALONE:
+            bufferSize += 6; /* CsrUint8 primitive->result.deviceInfo.standalonedevInfo.deviceAddress.a[6] */
+            bufferSize += 2; /* CsrWifiSmeWpsConfigTypeMask primitive->result.deviceInfo.standalonedevInfo.configMethods */
+            bufferSize += 1; /* CsrWifiSmeP2pCapabilityMask primitive->result.deviceInfo.standalonedevInfo.p2PDeviceCap */
+            bufferSize += 8; /* CsrUint8 primitive->result.deviceInfo.standalonedevInfo.primDeviceType.deviceDetails[8] */
+            bufferSize += 1; /* CsrUint8 primitive->result.deviceInfo.standalonedevInfo.secondaryDeviceTypeCount */
+            {
+                CsrUint16 i4;
+                for (i4 = 0; i4 < primitive->result.deviceInfo.standalonedevInfo.secondaryDeviceTypeCount; i4++)
+                {
+                    bufferSize += 8; /* CsrUint8 primitive->result.deviceInfo.standalonedevInfo.secDeviceType[i4].deviceDetails[8] */
+                }
+            }
+            bufferSize += 32;        /* CsrUint8 primitive->result.deviceInfo.standalonedevInfo.deviceName[32] */
+            bufferSize += 1;         /* CsrUint8 primitive->result.deviceInfo.standalonedevInfo.deviceNameLength */
+            break;
+        default:
+            break;
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeScanResultIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeScanResultInd *primitive = (CsrWifiSmeScanResultInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrMemCpySer(ptr, len, (const void *) primitive->result.ssid.ssid, ((CsrUint16) (32)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.ssid.length);
+    CsrMemCpySer(ptr, len, (const void *) primitive->result.bssid.a, ((CsrUint16) (6)));
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result.rssi);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result.snr);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.ifIndex);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result.beaconPeriodTu);
+    CsrMemCpySer(ptr, len, (const void *) primitive->result.timeStamp.data, ((CsrUint16) (8)));
+    CsrMemCpySer(ptr, len, (const void *) primitive->result.localTime.data, ((CsrUint16) (8)));
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result.channelFrequency);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result.capabilityInformation);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.channelNumber);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.usability);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.bssType);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result.informationElementsLength);
+    if (primitive->result.informationElementsLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->result.informationElements, ((CsrUint16) (primitive->result.informationElementsLength)));
+    }
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.p2pDeviceRole);
+    switch (primitive->result.p2pDeviceRole)
+    {
+        case CSR_WIFI_SME_P2P_ROLE_CLI:
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.deviceInfo.reservedCli.empty);
+            break;
+        case CSR_WIFI_SME_P2P_ROLE_GO:
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.deviceInfo.groupInfo.groupCapability);
+            CsrMemCpySer(ptr, len, (const void *) primitive->result.deviceInfo.groupInfo.p2pDeviceAddress.a, ((CsrUint16) (6)));
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.deviceInfo.groupInfo.p2pClientInfoCount);
+            {
+                CsrUint16 i4;
+                for (i4 = 0; i4 < primitive->result.deviceInfo.groupInfo.p2pClientInfoCount; i4++)
+                {
+                    CsrMemCpySer(ptr, len, (const void *) primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].p2PClientInterfaceAddress.a, ((CsrUint16) (6)));
+                    CsrMemCpySer(ptr, len, (const void *) primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceAddress.a, ((CsrUint16) (6)));
+                    CsrUint16Ser(ptr, len, (CsrUint16) primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.configMethods);
+                    CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.p2PDeviceCap);
+                    CsrMemCpySer(ptr, len, (const void *) primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.primDeviceType.deviceDetails, ((CsrUint16) (8)));
+                    CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount);
+                    {
+                        CsrUint16 i6;
+                        for (i6 = 0; i6 < primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount; i6++)
+                        {
+                            CsrMemCpySer(ptr, len, (const void *) primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType[i6].deviceDetails, ((CsrUint16) (8)));
+                        }
+                    }
+                    CsrMemCpySer(ptr, len, (const void *) primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceName, ((CsrUint16) (32)));
+                    CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceNameLength);
+                }
+            }
+            break;
+        case CSR_WIFI_SME_P2P_ROLE_NONE:
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.deviceInfo.reservedNone.empty);
+            break;
+        case CSR_WIFI_SME_P2P_ROLE_STANDALONE:
+            CsrMemCpySer(ptr, len, (const void *) primitive->result.deviceInfo.standalonedevInfo.deviceAddress.a, ((CsrUint16) (6)));
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->result.deviceInfo.standalonedevInfo.configMethods);
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.deviceInfo.standalonedevInfo.p2PDeviceCap);
+            CsrMemCpySer(ptr, len, (const void *) primitive->result.deviceInfo.standalonedevInfo.primDeviceType.deviceDetails, ((CsrUint16) (8)));
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.deviceInfo.standalonedevInfo.secondaryDeviceTypeCount);
+            {
+                CsrUint16 i4;
+                for (i4 = 0; i4 < primitive->result.deviceInfo.standalonedevInfo.secondaryDeviceTypeCount; i4++)
+                {
+                    CsrMemCpySer(ptr, len, (const void *) primitive->result.deviceInfo.standalonedevInfo.secDeviceType[i4].deviceDetails, ((CsrUint16) (8)));
+                }
+            }
+            CsrMemCpySer(ptr, len, (const void *) primitive->result.deviceInfo.standalonedevInfo.deviceName, ((CsrUint16) (32)));
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->result.deviceInfo.standalonedevInfo.deviceNameLength);
+            break;
+        default:
+            break;
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeScanResultIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeScanResultInd *primitive = (CsrWifiSmeScanResultInd *) CsrPmemAlloc(sizeof(CsrWifiSmeScanResultInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrMemCpyDes(primitive->result.ssid.ssid, buffer, &offset, ((CsrUint16) (32)));
+    CsrUint8Des((CsrUint8 *) &primitive->result.ssid.length, buffer, &offset);
+    CsrMemCpyDes(primitive->result.bssid.a, buffer, &offset, ((CsrUint16) (6)));
+    CsrUint16Des((CsrUint16 *) &primitive->result.rssi, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->result.snr, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->result.ifIndex, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->result.beaconPeriodTu, buffer, &offset);
+    CsrMemCpyDes(primitive->result.timeStamp.data, buffer, &offset, ((CsrUint16) (8)));
+    CsrMemCpyDes(primitive->result.localTime.data, buffer, &offset, ((CsrUint16) (8)));
+    CsrUint16Des((CsrUint16 *) &primitive->result.channelFrequency, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->result.capabilityInformation, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->result.channelNumber, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->result.usability, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->result.bssType, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->result.informationElementsLength, buffer, &offset);
+    if (primitive->result.informationElementsLength)
+    {
+        primitive->result.informationElements = (CsrUint8 *)CsrPmemAlloc(primitive->result.informationElementsLength);
+        CsrMemCpyDes(primitive->result.informationElements, buffer, &offset, ((CsrUint16) (primitive->result.informationElementsLength)));
+    }
+    else
+    {
+        primitive->result.informationElements = NULL;
+    }
+    CsrUint8Des((CsrUint8 *) &primitive->result.p2pDeviceRole, buffer, &offset);
+    switch (primitive->result.p2pDeviceRole)
+    {
+        case CSR_WIFI_SME_P2P_ROLE_CLI:
+            CsrUint8Des((CsrUint8 *) &primitive->result.deviceInfo.reservedCli.empty, buffer, &offset);
+            break;
+        case CSR_WIFI_SME_P2P_ROLE_GO:
+            CsrUint8Des((CsrUint8 *) &primitive->result.deviceInfo.groupInfo.groupCapability, buffer, &offset);
+            CsrMemCpyDes(primitive->result.deviceInfo.groupInfo.p2pDeviceAddress.a, buffer, &offset, ((CsrUint16) (6)));
+            CsrUint8Des((CsrUint8 *) &primitive->result.deviceInfo.groupInfo.p2pClientInfoCount, buffer, &offset);
+            primitive->result.deviceInfo.groupInfo.p2PClientInfo = NULL;
+            if (primitive->result.deviceInfo.groupInfo.p2pClientInfoCount)
+            {
+                primitive->result.deviceInfo.groupInfo.p2PClientInfo = (CsrWifiSmeP2pClientInfoType *)CsrPmemAlloc(sizeof(CsrWifiSmeP2pClientInfoType) * primitive->result.deviceInfo.groupInfo.p2pClientInfoCount);
+            }
+            {
+                CsrUint16 i4;
+                for (i4 = 0; i4 < primitive->result.deviceInfo.groupInfo.p2pClientInfoCount; i4++)
+                {
+                    CsrMemCpyDes(primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].p2PClientInterfaceAddress.a, buffer, &offset, ((CsrUint16) (6)));
+                    CsrMemCpyDes(primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceAddress.a, buffer, &offset, ((CsrUint16) (6)));
+                    CsrUint16Des((CsrUint16 *) &primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.configMethods, buffer, &offset);
+                    CsrUint8Des((CsrUint8 *) &primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.p2PDeviceCap, buffer, &offset);
+                    CsrMemCpyDes(primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.primDeviceType.deviceDetails, buffer, &offset, ((CsrUint16) (8)));
+                    CsrUint8Des((CsrUint8 *) &primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount, buffer, &offset);
+                    primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType = NULL;
+                    if (primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount)
+                    {
+                        primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType = (CsrWifiSmeWpsDeviceType *)CsrPmemAlloc(sizeof(CsrWifiSmeWpsDeviceType) * primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount);
+                    }
+                    {
+                        CsrUint16 i6;
+                        for (i6 = 0; i6 < primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount; i6++)
+                        {
+                            CsrMemCpyDes(primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType[i6].deviceDetails, buffer, &offset, ((CsrUint16) (8)));
+                        }
+                    }
+                    CsrMemCpyDes(primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceName, buffer, &offset, ((CsrUint16) (32)));
+                    CsrUint8Des((CsrUint8 *) &primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceNameLength, buffer, &offset);
+                }
+            }
+            break;
+        case CSR_WIFI_SME_P2P_ROLE_NONE:
+            CsrUint8Des((CsrUint8 *) &primitive->result.deviceInfo.reservedNone.empty, buffer, &offset);
+            break;
+        case CSR_WIFI_SME_P2P_ROLE_STANDALONE:
+            CsrMemCpyDes(primitive->result.deviceInfo.standalonedevInfo.deviceAddress.a, buffer, &offset, ((CsrUint16) (6)));
+            CsrUint16Des((CsrUint16 *) &primitive->result.deviceInfo.standalonedevInfo.configMethods, buffer, &offset);
+            CsrUint8Des((CsrUint8 *) &primitive->result.deviceInfo.standalonedevInfo.p2PDeviceCap, buffer, &offset);
+            CsrMemCpyDes(primitive->result.deviceInfo.standalonedevInfo.primDeviceType.deviceDetails, buffer, &offset, ((CsrUint16) (8)));
+            CsrUint8Des((CsrUint8 *) &primitive->result.deviceInfo.standalonedevInfo.secondaryDeviceTypeCount, buffer, &offset);
+            primitive->result.deviceInfo.standalonedevInfo.secDeviceType = NULL;
+            if (primitive->result.deviceInfo.standalonedevInfo.secondaryDeviceTypeCount)
+            {
+                primitive->result.deviceInfo.standalonedevInfo.secDeviceType = (CsrWifiSmeWpsDeviceType *)CsrPmemAlloc(sizeof(CsrWifiSmeWpsDeviceType) * primitive->result.deviceInfo.standalonedevInfo.secondaryDeviceTypeCount);
+            }
+            {
+                CsrUint16 i4;
+                for (i4 = 0; i4 < primitive->result.deviceInfo.standalonedevInfo.secondaryDeviceTypeCount; i4++)
+                {
+                    CsrMemCpyDes(primitive->result.deviceInfo.standalonedevInfo.secDeviceType[i4].deviceDetails, buffer, &offset, ((CsrUint16) (8)));
+                }
+            }
+            CsrMemCpyDes(primitive->result.deviceInfo.standalonedevInfo.deviceName, buffer, &offset, ((CsrUint16) (32)));
+            CsrUint8Des((CsrUint8 *) &primitive->result.deviceInfo.standalonedevInfo.deviceNameLength, buffer, &offset);
+            break;
+        default:
+            break;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeScanResultIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeScanResultInd *primitive = (CsrWifiSmeScanResultInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->result.informationElements);
+    switch (primitive->result.p2pDeviceRole)
+    {
+        case CSR_WIFI_SME_P2P_ROLE_GO:
+        {
+            CsrUint16 i4;
+            for (i4 = 0; i4 < primitive->result.deviceInfo.groupInfo.p2pClientInfoCount; i4++)
+            {
+                CsrPmemFree(primitive->result.deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType);
+            }
+        }
+            CsrPmemFree(primitive->result.deviceInfo.groupInfo.p2PClientInfo);
+            break;
+        case CSR_WIFI_SME_P2P_ROLE_STANDALONE:
+            CsrPmemFree(primitive->result.deviceInfo.standalonedevInfo.secDeviceType);
+            break;
+        default:
+            break;
+    }
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeScanResultsGetCfmSizeof(void *msg)
+{
+    CsrWifiSmeScanResultsGetCfm *primitive = (CsrWifiSmeScanResultsGetCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 153) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 2; /* CsrUint16 primitive->scanResultsCount */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->scanResultsCount; i1++)
+        {
+            bufferSize += 32;                                                   /* CsrUint8 primitive->scanResults[i1].ssid.ssid[32] */
+            bufferSize += 1;                                                    /* CsrUint8 primitive->scanResults[i1].ssid.length */
+            bufferSize += 6;                                                    /* CsrUint8 primitive->scanResults[i1].bssid.a[6] */
+            bufferSize += 2;                                                    /* CsrInt16 primitive->scanResults[i1].rssi */
+            bufferSize += 2;                                                    /* CsrInt16 primitive->scanResults[i1].snr */
+            bufferSize += 1;                                                    /* CsrWifiSmeRadioIF primitive->scanResults[i1].ifIndex */
+            bufferSize += 2;                                                    /* CsrUint16 primitive->scanResults[i1].beaconPeriodTu */
+            bufferSize += 8;                                                    /* CsrUint8 primitive->scanResults[i1].timeStamp.data[8] */
+            bufferSize += 8;                                                    /* CsrUint8 primitive->scanResults[i1].localTime.data[8] */
+            bufferSize += 2;                                                    /* CsrUint16 primitive->scanResults[i1].channelFrequency */
+            bufferSize += 2;                                                    /* CsrUint16 primitive->scanResults[i1].capabilityInformation */
+            bufferSize += 1;                                                    /* CsrUint8 primitive->scanResults[i1].channelNumber */
+            bufferSize += 1;                                                    /* CsrWifiSmeBasicUsability primitive->scanResults[i1].usability */
+            bufferSize += 1;                                                    /* CsrWifiSmeBssType primitive->scanResults[i1].bssType */
+            bufferSize += 2;                                                    /* CsrUint16 primitive->scanResults[i1].informationElementsLength */
+            bufferSize += primitive->scanResults[i1].informationElementsLength; /* CsrUint8 primitive->scanResults[i1].informationElements */
+            bufferSize += 1;                                                    /* CsrWifiSmeP2pRole primitive->scanResults[i1].p2pDeviceRole */
+            switch (primitive->scanResults[i1].p2pDeviceRole)
+            {
+                case CSR_WIFI_SME_P2P_ROLE_CLI:
+                    bufferSize += 1; /* CsrUint8 primitive->scanResults[i1].deviceInfo.reservedCli.empty */
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_GO:
+                    bufferSize += 1; /* CsrWifiSmeP2pGroupCapabilityMask primitive->scanResults[i1].deviceInfo.groupInfo.groupCapability */
+                    bufferSize += 6; /* CsrUint8 primitive->scanResults[i1].deviceInfo.groupInfo.p2pDeviceAddress.a[6] */
+                    bufferSize += 1; /* CsrUint8 primitive->scanResults[i1].deviceInfo.groupInfo.p2pClientInfoCount */
+                    {
+                        CsrUint16 i4;
+                        for (i4 = 0; i4 < primitive->scanResults[i1].deviceInfo.groupInfo.p2pClientInfoCount; i4++)
+                        {
+                            bufferSize += 6; /* CsrUint8 primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].p2PClientInterfaceAddress.a[6] */
+                            bufferSize += 6; /* CsrUint8 primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceAddress.a[6] */
+                            bufferSize += 2; /* CsrWifiSmeWpsConfigTypeMask primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.configMethods */
+                            bufferSize += 1; /* CsrWifiSmeP2pCapabilityMask primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.p2PDeviceCap */
+                            bufferSize += 8; /* CsrUint8 primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.primDeviceType.deviceDetails[8] */
+                            bufferSize += 1; /* CsrUint8 primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount */
+                            {
+                                CsrUint16 i6;
+                                for (i6 = 0; i6 < primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount; i6++)
+                                {
+                                    bufferSize += 8; /* CsrUint8 primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType[i6].deviceDetails[8] */
+                                }
+                            }
+                            bufferSize += 32;        /* CsrUint8 primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceName[32] */
+                            bufferSize += 1;         /* CsrUint8 primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceNameLength */
+                        }
+                    }
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_NONE:
+                    bufferSize += 1; /* CsrUint8 primitive->scanResults[i1].deviceInfo.reservedNone.empty */
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_STANDALONE:
+                    bufferSize += 6; /* CsrUint8 primitive->scanResults[i1].deviceInfo.standalonedevInfo.deviceAddress.a[6] */
+                    bufferSize += 2; /* CsrWifiSmeWpsConfigTypeMask primitive->scanResults[i1].deviceInfo.standalonedevInfo.configMethods */
+                    bufferSize += 1; /* CsrWifiSmeP2pCapabilityMask primitive->scanResults[i1].deviceInfo.standalonedevInfo.p2PDeviceCap */
+                    bufferSize += 8; /* CsrUint8 primitive->scanResults[i1].deviceInfo.standalonedevInfo.primDeviceType.deviceDetails[8] */
+                    bufferSize += 1; /* CsrUint8 primitive->scanResults[i1].deviceInfo.standalonedevInfo.secondaryDeviceTypeCount */
+                    {
+                        CsrUint16 i4;
+                        for (i4 = 0; i4 < primitive->scanResults[i1].deviceInfo.standalonedevInfo.secondaryDeviceTypeCount; i4++)
+                        {
+                            bufferSize += 8; /* CsrUint8 primitive->scanResults[i1].deviceInfo.standalonedevInfo.secDeviceType[i4].deviceDetails[8] */
+                        }
+                    }
+                    bufferSize += 32;        /* CsrUint8 primitive->scanResults[i1].deviceInfo.standalonedevInfo.deviceName[32] */
+                    bufferSize += 1;         /* CsrUint8 primitive->scanResults[i1].deviceInfo.standalonedevInfo.deviceNameLength */
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeScanResultsGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeScanResultsGetCfm *primitive = (CsrWifiSmeScanResultsGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanResultsCount);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->scanResultsCount; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].ssid.ssid, ((CsrUint16) (32)));
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].ssid.length);
+            CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].bssid.a, ((CsrUint16) (6)));
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanResults[i1].rssi);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanResults[i1].snr);
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].ifIndex);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanResults[i1].beaconPeriodTu);
+            CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].timeStamp.data, ((CsrUint16) (8)));
+            CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].localTime.data, ((CsrUint16) (8)));
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanResults[i1].channelFrequency);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanResults[i1].capabilityInformation);
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].channelNumber);
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].usability);
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].bssType);
+            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanResults[i1].informationElementsLength);
+            if (primitive->scanResults[i1].informationElementsLength)
+            {
+                CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].informationElements, ((CsrUint16) (primitive->scanResults[i1].informationElementsLength)));
+            }
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].p2pDeviceRole);
+            switch (primitive->scanResults[i1].p2pDeviceRole)
+            {
+                case CSR_WIFI_SME_P2P_ROLE_CLI:
+                    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].deviceInfo.reservedCli.empty);
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_GO:
+                    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].deviceInfo.groupInfo.groupCapability);
+                    CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].deviceInfo.groupInfo.p2pDeviceAddress.a, ((CsrUint16) (6)));
+                    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].deviceInfo.groupInfo.p2pClientInfoCount);
+                    {
+                        CsrUint16 i4;
+                        for (i4 = 0; i4 < primitive->scanResults[i1].deviceInfo.groupInfo.p2pClientInfoCount; i4++)
+                        {
+                            CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].p2PClientInterfaceAddress.a, ((CsrUint16) (6)));
+                            CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceAddress.a, ((CsrUint16) (6)));
+                            CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.configMethods);
+                            CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.p2PDeviceCap);
+                            CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.primDeviceType.deviceDetails, ((CsrUint16) (8)));
+                            CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount);
+                            {
+                                CsrUint16 i6;
+                                for (i6 = 0; i6 < primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount; i6++)
+                                {
+                                    CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType[i6].deviceDetails, ((CsrUint16) (8)));
+                                }
+                            }
+                            CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceName, ((CsrUint16) (32)));
+                            CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceNameLength);
+                        }
+                    }
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_NONE:
+                    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].deviceInfo.reservedNone.empty);
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_STANDALONE:
+                    CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].deviceInfo.standalonedevInfo.deviceAddress.a, ((CsrUint16) (6)));
+                    CsrUint16Ser(ptr, len, (CsrUint16) primitive->scanResults[i1].deviceInfo.standalonedevInfo.configMethods);
+                    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].deviceInfo.standalonedevInfo.p2PDeviceCap);
+                    CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].deviceInfo.standalonedevInfo.primDeviceType.deviceDetails, ((CsrUint16) (8)));
+                    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].deviceInfo.standalonedevInfo.secondaryDeviceTypeCount);
+                    {
+                        CsrUint16 i4;
+                        for (i4 = 0; i4 < primitive->scanResults[i1].deviceInfo.standalonedevInfo.secondaryDeviceTypeCount; i4++)
+                        {
+                            CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].deviceInfo.standalonedevInfo.secDeviceType[i4].deviceDetails, ((CsrUint16) (8)));
+                        }
+                    }
+                    CsrMemCpySer(ptr, len, (const void *) primitive->scanResults[i1].deviceInfo.standalonedevInfo.deviceName, ((CsrUint16) (32)));
+                    CsrUint8Ser(ptr, len, (CsrUint8) primitive->scanResults[i1].deviceInfo.standalonedevInfo.deviceNameLength);
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeScanResultsGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeScanResultsGetCfm *primitive = (CsrWifiSmeScanResultsGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeScanResultsGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->scanResultsCount, buffer, &offset);
+    primitive->scanResults = NULL;
+    if (primitive->scanResultsCount)
+    {
+        primitive->scanResults = (CsrWifiSmeScanResult *)CsrPmemAlloc(sizeof(CsrWifiSmeScanResult) * primitive->scanResultsCount);
+    }
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->scanResultsCount; i1++)
+        {
+            CsrMemCpyDes(primitive->scanResults[i1].ssid.ssid, buffer, &offset, ((CsrUint16) (32)));
+            CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].ssid.length, buffer, &offset);
+            CsrMemCpyDes(primitive->scanResults[i1].bssid.a, buffer, &offset, ((CsrUint16) (6)));
+            CsrUint16Des((CsrUint16 *) &primitive->scanResults[i1].rssi, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanResults[i1].snr, buffer, &offset);
+            CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].ifIndex, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanResults[i1].beaconPeriodTu, buffer, &offset);
+            CsrMemCpyDes(primitive->scanResults[i1].timeStamp.data, buffer, &offset, ((CsrUint16) (8)));
+            CsrMemCpyDes(primitive->scanResults[i1].localTime.data, buffer, &offset, ((CsrUint16) (8)));
+            CsrUint16Des((CsrUint16 *) &primitive->scanResults[i1].channelFrequency, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanResults[i1].capabilityInformation, buffer, &offset);
+            CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].channelNumber, buffer, &offset);
+            CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].usability, buffer, &offset);
+            CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].bssType, buffer, &offset);
+            CsrUint16Des((CsrUint16 *) &primitive->scanResults[i1].informationElementsLength, buffer, &offset);
+            if (primitive->scanResults[i1].informationElementsLength)
+            {
+                primitive->scanResults[i1].informationElements = (CsrUint8 *)CsrPmemAlloc(primitive->scanResults[i1].informationElementsLength);
+                CsrMemCpyDes(primitive->scanResults[i1].informationElements, buffer, &offset, ((CsrUint16) (primitive->scanResults[i1].informationElementsLength)));
+            }
+            else
+            {
+                primitive->scanResults[i1].informationElements = NULL;
+            }
+            CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].p2pDeviceRole, buffer, &offset);
+            switch (primitive->scanResults[i1].p2pDeviceRole)
+            {
+                case CSR_WIFI_SME_P2P_ROLE_CLI:
+                    CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].deviceInfo.reservedCli.empty, buffer, &offset);
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_GO:
+                    CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].deviceInfo.groupInfo.groupCapability, buffer, &offset);
+                    CsrMemCpyDes(primitive->scanResults[i1].deviceInfo.groupInfo.p2pDeviceAddress.a, buffer, &offset, ((CsrUint16) (6)));
+                    CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].deviceInfo.groupInfo.p2pClientInfoCount, buffer, &offset);
+                    primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo = NULL;
+                    if (primitive->scanResults[i1].deviceInfo.groupInfo.p2pClientInfoCount)
+                    {
+                        primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo = (CsrWifiSmeP2pClientInfoType *)CsrPmemAlloc(sizeof(CsrWifiSmeP2pClientInfoType) * primitive->scanResults[i1].deviceInfo.groupInfo.p2pClientInfoCount);
+                    }
+                    {
+                        CsrUint16 i4;
+                        for (i4 = 0; i4 < primitive->scanResults[i1].deviceInfo.groupInfo.p2pClientInfoCount; i4++)
+                        {
+                            CsrMemCpyDes(primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].p2PClientInterfaceAddress.a, buffer, &offset, ((CsrUint16) (6)));
+                            CsrMemCpyDes(primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceAddress.a, buffer, &offset, ((CsrUint16) (6)));
+                            CsrUint16Des((CsrUint16 *) &primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.configMethods, buffer, &offset);
+                            CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.p2PDeviceCap, buffer, &offset);
+                            CsrMemCpyDes(primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.primDeviceType.deviceDetails, buffer, &offset, ((CsrUint16) (8)));
+                            CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount, buffer, &offset);
+                            primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType = NULL;
+                            if (primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount)
+                            {
+                                primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType = (CsrWifiSmeWpsDeviceType *)CsrPmemAlloc(sizeof(CsrWifiSmeWpsDeviceType) * primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount);
+                            }
+                            {
+                                CsrUint16 i6;
+                                for (i6 = 0; i6 < primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secondaryDeviceTypeCount; i6++)
+                                {
+                                    CsrMemCpyDes(primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType[i6].deviceDetails, buffer, &offset, ((CsrUint16) (8)));
+                                }
+                            }
+                            CsrMemCpyDes(primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceName, buffer, &offset, ((CsrUint16) (32)));
+                            CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.deviceNameLength, buffer, &offset);
+                        }
+                    }
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_NONE:
+                    CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].deviceInfo.reservedNone.empty, buffer, &offset);
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_STANDALONE:
+                    CsrMemCpyDes(primitive->scanResults[i1].deviceInfo.standalonedevInfo.deviceAddress.a, buffer, &offset, ((CsrUint16) (6)));
+                    CsrUint16Des((CsrUint16 *) &primitive->scanResults[i1].deviceInfo.standalonedevInfo.configMethods, buffer, &offset);
+                    CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].deviceInfo.standalonedevInfo.p2PDeviceCap, buffer, &offset);
+                    CsrMemCpyDes(primitive->scanResults[i1].deviceInfo.standalonedevInfo.primDeviceType.deviceDetails, buffer, &offset, ((CsrUint16) (8)));
+                    CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].deviceInfo.standalonedevInfo.secondaryDeviceTypeCount, buffer, &offset);
+                    primitive->scanResults[i1].deviceInfo.standalonedevInfo.secDeviceType = NULL;
+                    if (primitive->scanResults[i1].deviceInfo.standalonedevInfo.secondaryDeviceTypeCount)
+                    {
+                        primitive->scanResults[i1].deviceInfo.standalonedevInfo.secDeviceType = (CsrWifiSmeWpsDeviceType *)CsrPmemAlloc(sizeof(CsrWifiSmeWpsDeviceType) * primitive->scanResults[i1].deviceInfo.standalonedevInfo.secondaryDeviceTypeCount);
+                    }
+                    {
+                        CsrUint16 i4;
+                        for (i4 = 0; i4 < primitive->scanResults[i1].deviceInfo.standalonedevInfo.secondaryDeviceTypeCount; i4++)
+                        {
+                            CsrMemCpyDes(primitive->scanResults[i1].deviceInfo.standalonedevInfo.secDeviceType[i4].deviceDetails, buffer, &offset, ((CsrUint16) (8)));
+                        }
+                    }
+                    CsrMemCpyDes(primitive->scanResults[i1].deviceInfo.standalonedevInfo.deviceName, buffer, &offset, ((CsrUint16) (32)));
+                    CsrUint8Des((CsrUint8 *) &primitive->scanResults[i1].deviceInfo.standalonedevInfo.deviceNameLength, buffer, &offset);
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeScanResultsGetCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeScanResultsGetCfm *primitive = (CsrWifiSmeScanResultsGetCfm *) voidPrimitivePointer;
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < primitive->scanResultsCount; i1++)
+        {
+            CsrPmemFree(primitive->scanResults[i1].informationElements);
+            switch (primitive->scanResults[i1].p2pDeviceRole)
+            {
+                case CSR_WIFI_SME_P2P_ROLE_GO:
+                {
+                    CsrUint16 i4;
+                    for (i4 = 0; i4 < primitive->scanResults[i1].deviceInfo.groupInfo.p2pClientInfoCount; i4++)
+                    {
+                        CsrPmemFree(primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo[i4].clientDeviceInfo.secDeviceType);
+                    }
+                }
+                    CsrPmemFree(primitive->scanResults[i1].deviceInfo.groupInfo.p2PClientInfo);
+                    break;
+                case CSR_WIFI_SME_P2P_ROLE_STANDALONE:
+                    CsrPmemFree(primitive->scanResults[i1].deviceInfo.standalonedevInfo.secDeviceType);
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+    CsrPmemFree(primitive->scanResults);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeSmeStaConfigGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrUint8 primitive->smeConfig.connectionQualityRssiChangeTrigger */
+    bufferSize += 1; /* CsrUint8 primitive->smeConfig.connectionQualitySnrChangeTrigger */
+    bufferSize += 1; /* CsrUint8 primitive->smeConfig.wmmModeMask */
+    bufferSize += 1; /* CsrWifiSmeRadioIF primitive->smeConfig.ifIndex */
+    bufferSize += 1; /* CsrBool primitive->smeConfig.allowUnicastUseGroupCipher */
+    bufferSize += 1; /* CsrBool primitive->smeConfig.enableOpportunisticKeyCaching */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeSmeStaConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeSmeStaConfigGetCfm *primitive = (CsrWifiSmeSmeStaConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.connectionQualityRssiChangeTrigger);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.connectionQualitySnrChangeTrigger);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.wmmModeMask);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.ifIndex);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.allowUnicastUseGroupCipher);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->smeConfig.enableOpportunisticKeyCaching);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeSmeStaConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeSmeStaConfigGetCfm *primitive = (CsrWifiSmeSmeStaConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeStaConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.connectionQualityRssiChangeTrigger, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.connectionQualitySnrChangeTrigger, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.wmmModeMask, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.ifIndex, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.allowUnicastUseGroupCipher, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->smeConfig.enableOpportunisticKeyCaching, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeSmeStaConfigSetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 7) */
+    bufferSize += 2; /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2; /* CsrResult primitive->status */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeSmeStaConfigSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeSmeStaConfigSetCfm *primitive = (CsrWifiSmeSmeStaConfigSetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeSmeStaConfigSetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeSmeStaConfigSetCfm *primitive = (CsrWifiSmeSmeStaConfigSetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeStaConfigSetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeStationMacAddressGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 17) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < 2; i1++)
+        {
+            bufferSize += 6; /* CsrUint8 primitive->stationMacAddress[i1].a[6] */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeStationMacAddressGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeStationMacAddressGetCfm *primitive = (CsrWifiSmeStationMacAddressGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < 2; i1++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->stationMacAddress[i1].a, ((CsrUint16) (6)));
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeStationMacAddressGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeStationMacAddressGetCfm *primitive = (CsrWifiSmeStationMacAddressGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeStationMacAddressGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    {
+        CsrUint16 i1;
+        for (i1 = 0; i1 < 2; i1++)
+        {
+            CsrMemCpyDes(primitive->stationMacAddress[i1].a, buffer, &offset, ((CsrUint16) (6)));
+        }
+    }
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeTspecIndSizeof(void *msg)
+{
+    CsrWifiSmeTspecInd *primitive = (CsrWifiSmeTspecInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 13) */
+    bufferSize += 2;                      /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 4;                      /* CsrUint32 primitive->transactionId */
+    bufferSize += 1;                      /* CsrWifiSmeTspecResultCode primitive->tspecResultCode */
+    bufferSize += 2;                      /* CsrUint16 primitive->tspecLength */
+    bufferSize += primitive->tspecLength; /* CsrUint8 primitive->tspec */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeTspecIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeTspecInd *primitive = (CsrWifiSmeTspecInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->transactionId);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->tspecResultCode);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->tspecLength);
+    if (primitive->tspecLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->tspec, ((CsrUint16) (primitive->tspecLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeTspecIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeTspecInd *primitive = (CsrWifiSmeTspecInd *) CsrPmemAlloc(sizeof(CsrWifiSmeTspecInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->transactionId, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->tspecResultCode, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->tspecLength, buffer, &offset);
+    if (primitive->tspecLength)
+    {
+        primitive->tspec = (CsrUint8 *)CsrPmemAlloc(primitive->tspecLength);
+        CsrMemCpyDes(primitive->tspec, buffer, &offset, ((CsrUint16) (primitive->tspecLength)));
+    }
+    else
+    {
+        primitive->tspec = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeTspecIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeTspecInd *primitive = (CsrWifiSmeTspecInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->tspec);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeTspecCfmSizeof(void *msg)
+{
+    CsrWifiSmeTspecCfm *primitive = (CsrWifiSmeTspecCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 15) */
+    bufferSize += 2;                      /* CsrUint16 primitive->interfaceTag */
+    bufferSize += 2;                      /* CsrResult primitive->status */
+    bufferSize += 4;                      /* CsrUint32 primitive->transactionId */
+    bufferSize += 1;                      /* CsrWifiSmeTspecResultCode primitive->tspecResultCode */
+    bufferSize += 2;                      /* CsrUint16 primitive->tspecLength */
+    bufferSize += primitive->tspecLength; /* CsrUint8 primitive->tspec */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeTspecCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeTspecCfm *primitive = (CsrWifiSmeTspecCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->interfaceTag);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->transactionId);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->tspecResultCode);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->tspecLength);
+    if (primitive->tspecLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->tspec, ((CsrUint16) (primitive->tspecLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeTspecCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeTspecCfm *primitive = (CsrWifiSmeTspecCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeTspecCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->interfaceTag, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->transactionId, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->tspecResultCode, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->tspecLength, buffer, &offset);
+    if (primitive->tspecLength)
+    {
+        primitive->tspec = (CsrUint8 *)CsrPmemAlloc(primitive->tspecLength);
+        CsrMemCpyDes(primitive->tspec, buffer, &offset, ((CsrUint16) (primitive->tspecLength)));
+    }
+    else
+    {
+        primitive->tspec = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeTspecCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeTspecCfm *primitive = (CsrWifiSmeTspecCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->tspec);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeVersionsGetCfmSizeof(void *msg)
+{
+    CsrWifiSmeVersionsGetCfm *primitive = (CsrWifiSmeVersionsGetCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 33) */
+    bufferSize += 2;                                                                                    /* CsrResult primitive->status */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.chipId */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.chipVersion */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.firmwareBuild */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.firmwarePatch */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.firmwareHip */
+    bufferSize += (primitive->versions.routerBuild?CsrStrLen(primitive->versions.routerBuild) : 0) + 1; /* CsrCharString* primitive->versions.routerBuild (0 byte len + 1 for NULL Term) */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.routerHip */
+    bufferSize += (primitive->versions.smeBuild?CsrStrLen(primitive->versions.smeBuild) : 0) + 1;       /* CsrCharString* primitive->versions.smeBuild (0 byte len + 1 for NULL Term) */
+    bufferSize += 4;                                                                                    /* CsrUint32 primitive->versions.smeHip */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeVersionsGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeVersionsGetCfm *primitive = (CsrWifiSmeVersionsGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.chipId);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.chipVersion);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.firmwareBuild);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.firmwarePatch);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.firmwareHip);
+    CsrCharStringSer(ptr, len, primitive->versions.routerBuild);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.routerHip);
+    CsrCharStringSer(ptr, len, primitive->versions.smeBuild);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->versions.smeHip);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeVersionsGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeVersionsGetCfm *primitive = (CsrWifiSmeVersionsGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeVersionsGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.chipId, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.chipVersion, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.firmwareBuild, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.firmwarePatch, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.firmwareHip, buffer, &offset);
+    CsrCharStringDes(&primitive->versions.routerBuild, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.routerHip, buffer, &offset);
+    CsrCharStringDes(&primitive->versions.smeBuild, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->versions.smeHip, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiSmeVersionsGetCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeVersionsGetCfm *primitive = (CsrWifiSmeVersionsGetCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->versions.routerBuild);
+    CsrPmemFree(primitive->versions.smeBuild);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeCloakedSsidsGetCfmSizeof(void *msg)
+{
+    CsrWifiSmeCloakedSsidsGetCfm *primitive = (CsrWifiSmeCloakedSsidsGetCfm *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 39) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrUint8 primitive->cloakedSsids.cloakedSsidsCount */
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < primitive->cloakedSsids.cloakedSsidsCount; i2++)
+        {
+            bufferSize += 32; /* CsrUint8 primitive->cloakedSsids.cloakedSsids[i2].ssid[32] */
+            bufferSize += 1;  /* CsrUint8 primitive->cloakedSsids.cloakedSsids[i2].length */
+        }
+    }
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCloakedSsidsGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCloakedSsidsGetCfm *primitive = (CsrWifiSmeCloakedSsidsGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->cloakedSsids.cloakedSsidsCount);
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < primitive->cloakedSsids.cloakedSsidsCount; i2++)
+        {
+            CsrMemCpySer(ptr, len, (const void *) primitive->cloakedSsids.cloakedSsids[i2].ssid, ((CsrUint16) (32)));
+            CsrUint8Ser(ptr, len, (CsrUint8) primitive->cloakedSsids.cloakedSsids[i2].length);
+        }
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCloakedSsidsGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCloakedSsidsGetCfm *primitive = (CsrWifiSmeCloakedSsidsGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeCloakedSsidsGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->cloakedSsids.cloakedSsidsCount, buffer, &offset);
+    primitive->cloakedSsids.cloakedSsids = NULL;
+    if (primitive->cloakedSsids.cloakedSsidsCount)
+    {
+        primitive->cloakedSsids.cloakedSsids = (CsrWifiSsid *)CsrPmemAlloc(sizeof(CsrWifiSsid) * primitive->cloakedSsids.cloakedSsidsCount);
+    }
+    {
+        CsrUint16 i2;
+        for (i2 = 0; i2 < primitive->cloakedSsids.cloakedSsidsCount; i2++)
+        {
+            CsrMemCpyDes(primitive->cloakedSsids.cloakedSsids[i2].ssid, buffer, &offset, ((CsrUint16) (32)));
+            CsrUint8Des((CsrUint8 *) &primitive->cloakedSsids.cloakedSsids[i2].length, buffer, &offset);
+        }
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeCloakedSsidsGetCfmSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeCloakedSsidsGetCfm *primitive = (CsrWifiSmeCloakedSsidsGetCfm *) voidPrimitivePointer;
+    CsrPmemFree(primitive->cloakedSsids.cloakedSsids);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeWifiOnIndSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 6; /* CsrUint8 primitive->address.a[6] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeWifiOnIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeWifiOnInd *primitive = (CsrWifiSmeWifiOnInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrMemCpySer(ptr, len, (const void *) primitive->address.a, ((CsrUint16) (6)));
+    return(ptr);
+}
+
+
+void* CsrWifiSmeWifiOnIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeWifiOnInd *primitive = (CsrWifiSmeWifiOnInd *) CsrPmemAlloc(sizeof(CsrWifiSmeWifiOnInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrMemCpyDes(primitive->address.a, buffer, &offset, ((CsrUint16) (6)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeSmeCommonConfigGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 10) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 1; /* CsrWifiSme80211dTrustLevel primitive->deviceConfig.trustLevel */
+    bufferSize += 2; /* CsrUint8 primitive->deviceConfig.countryCode[2] */
+    bufferSize += 1; /* CsrWifiSmeFirmwareDriverInterface primitive->deviceConfig.firmwareDriverInterface */
+    bufferSize += 1; /* CsrBool primitive->deviceConfig.enableStrictDraftN */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeSmeCommonConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeSmeCommonConfigGetCfm *primitive = (CsrWifiSmeSmeCommonConfigGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->deviceConfig.trustLevel);
+    CsrMemCpySer(ptr, len, (const void *) primitive->deviceConfig.countryCode, ((CsrUint16) (2)));
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->deviceConfig.firmwareDriverInterface);
+    CsrUint8Ser(ptr, len, (CsrUint8) primitive->deviceConfig.enableStrictDraftN);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeSmeCommonConfigGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeSmeCommonConfigGetCfm *primitive = (CsrWifiSmeSmeCommonConfigGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeSmeCommonConfigGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->deviceConfig.trustLevel, buffer, &offset);
+    CsrMemCpyDes(primitive->deviceConfig.countryCode, buffer, &offset, ((CsrUint16) (2)));
+    CsrUint8Des((CsrUint8 *) &primitive->deviceConfig.firmwareDriverInterface, buffer, &offset);
+    CsrUint8Des((CsrUint8 *) &primitive->deviceConfig.enableStrictDraftN, buffer, &offset);
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeInterfaceCapabilityGetCfmSizeof(void *msg)
+{
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 9) */
+    bufferSize += 2; /* CsrResult primitive->status */
+    bufferSize += 2; /* CsrUint16 primitive->numInterfaces */
+    bufferSize += 2; /* CsrUint8 primitive->capBitmap[2] */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeInterfaceCapabilityGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeInterfaceCapabilityGetCfm *primitive = (CsrWifiSmeInterfaceCapabilityGetCfm *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->status);
+    CsrUint16Ser(ptr, len, (CsrUint16) primitive->numInterfaces);
+    CsrMemCpySer(ptr, len, (const void *) primitive->capBitmap, ((CsrUint16) (2)));
+    return(ptr);
+}
+
+
+void* CsrWifiSmeInterfaceCapabilityGetCfmDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeInterfaceCapabilityGetCfm *primitive = (CsrWifiSmeInterfaceCapabilityGetCfm *) CsrPmemAlloc(sizeof(CsrWifiSmeInterfaceCapabilityGetCfm));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->status, buffer, &offset);
+    CsrUint16Des((CsrUint16 *) &primitive->numInterfaces, buffer, &offset);
+    CsrMemCpyDes(primitive->capBitmap, buffer, &offset, ((CsrUint16) (2)));
+
+    return primitive;
+}
+
+
+CsrSize CsrWifiSmeErrorIndSizeof(void *msg)
+{
+    CsrWifiSmeErrorInd *primitive = (CsrWifiSmeErrorInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 3) */
+    bufferSize += (primitive->errorMessage?CsrStrLen(primitive->errorMessage) : 0) + 1; /* CsrCharString* primitive->errorMessage (0 byte len + 1 for NULL Term) */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeErrorIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeErrorInd *primitive = (CsrWifiSmeErrorInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrCharStringSer(ptr, len, primitive->errorMessage);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeErrorIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeErrorInd *primitive = (CsrWifiSmeErrorInd *) CsrPmemAlloc(sizeof(CsrWifiSmeErrorInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrCharStringDes(&primitive->errorMessage, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiSmeErrorIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeErrorInd *primitive = (CsrWifiSmeErrorInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->errorMessage);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeInfoIndSizeof(void *msg)
+{
+    CsrWifiSmeInfoInd *primitive = (CsrWifiSmeInfoInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 3) */
+    bufferSize += (primitive->infoMessage?CsrStrLen(primitive->infoMessage) : 0) + 1; /* CsrCharString* primitive->infoMessage (0 byte len + 1 for NULL Term) */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeInfoIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeInfoInd *primitive = (CsrWifiSmeInfoInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrCharStringSer(ptr, len, primitive->infoMessage);
+    return(ptr);
+}
+
+
+void* CsrWifiSmeInfoIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeInfoInd *primitive = (CsrWifiSmeInfoInd *) CsrPmemAlloc(sizeof(CsrWifiSmeInfoInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrCharStringDes(&primitive->infoMessage, buffer, &offset);
+
+    return primitive;
+}
+
+
+void CsrWifiSmeInfoIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeInfoInd *primitive = (CsrWifiSmeInfoInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->infoMessage);
+    CsrPmemFree(primitive);
+}
+
+
+CsrSize CsrWifiSmeCoreDumpIndSizeof(void *msg)
+{
+    CsrWifiSmeCoreDumpInd *primitive = (CsrWifiSmeCoreDumpInd *) msg;
+    CsrSize bufferSize = 2;
+
+    /* Calculate the Size of the Serialised Data. Could be more efficient (Try 8) */
+    bufferSize += 4;                     /* CsrUint32 primitive->dataLength */
+    bufferSize += primitive->dataLength; /* CsrUint8 primitive->data */
+    return bufferSize;
+}
+
+
+CsrUint8* CsrWifiSmeCoreDumpIndSer(CsrUint8 *ptr, CsrSize *len, void *msg)
+{
+    CsrWifiSmeCoreDumpInd *primitive = (CsrWifiSmeCoreDumpInd *)msg;
+    *len = 0;
+    CsrUint16Ser(ptr, len, primitive->common.type);
+    CsrUint32Ser(ptr, len, (CsrUint32) primitive->dataLength);
+    if (primitive->dataLength)
+    {
+        CsrMemCpySer(ptr, len, (const void *) primitive->data, ((CsrUint16) (primitive->dataLength)));
+    }
+    return(ptr);
+}
+
+
+void* CsrWifiSmeCoreDumpIndDes(CsrUint8 *buffer, CsrSize length)
+{
+    CsrWifiSmeCoreDumpInd *primitive = (CsrWifiSmeCoreDumpInd *) CsrPmemAlloc(sizeof(CsrWifiSmeCoreDumpInd));
+    CsrSize offset;
+    offset = 0;
+
+    CsrUint16Des(&primitive->common.type, buffer, &offset);
+    CsrUint32Des((CsrUint32 *) &primitive->dataLength, buffer, &offset);
+    if (primitive->dataLength)
+    {
+        primitive->data = (CsrUint8 *)CsrPmemAlloc(primitive->dataLength);
+        CsrMemCpyDes(primitive->data, buffer, &offset, ((CsrUint16) (primitive->dataLength)));
+    }
+    else
+    {
+        primitive->data = NULL;
+    }
+
+    return primitive;
+}
+
+
+void CsrWifiSmeCoreDumpIndSerFree(void *voidPrimitivePointer)
+{
+    CsrWifiSmeCoreDumpInd *primitive = (CsrWifiSmeCoreDumpInd *) voidPrimitivePointer;
+    CsrPmemFree(primitive->data);
+    CsrPmemFree(primitive);
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_serialize.h
@@ -0,0 +1,668 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_SME_SERIALIZE_H__
+#define CSR_WIFI_SME_SERIALIZE_H__
+
+#include "csr_types.h"
+#include "csr_pmem.h"
+#include "csr_wifi_msgconv.h"
+
+#include "csr_wifi_sme_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void CsrWifiSmePfree(void *ptr);
+
+#define CsrWifiSmeActivateReqSer CsrWifiEventSer
+#define CsrWifiSmeActivateReqDes CsrWifiEventDes
+#define CsrWifiSmeActivateReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeActivateReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeAdhocConfigGetReqSer CsrWifiEventSer
+#define CsrWifiSmeAdhocConfigGetReqDes CsrWifiEventDes
+#define CsrWifiSmeAdhocConfigGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeAdhocConfigGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeAdhocConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeAdhocConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeAdhocConfigSetReqSizeof(void *msg);
+#define CsrWifiSmeAdhocConfigSetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeBlacklistReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeBlacklistReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeBlacklistReqSizeof(void *msg);
+extern void CsrWifiSmeBlacklistReqSerFree(void *msg);
+
+#define CsrWifiSmeCalibrationDataGetReqSer CsrWifiEventSer
+#define CsrWifiSmeCalibrationDataGetReqDes CsrWifiEventDes
+#define CsrWifiSmeCalibrationDataGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeCalibrationDataGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeCalibrationDataSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCalibrationDataSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCalibrationDataSetReqSizeof(void *msg);
+extern void CsrWifiSmeCalibrationDataSetReqSerFree(void *msg);
+
+#define CsrWifiSmeCcxConfigGetReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeCcxConfigGetReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeCcxConfigGetReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeCcxConfigGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeCcxConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCcxConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCcxConfigSetReqSizeof(void *msg);
+#define CsrWifiSmeCcxConfigSetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeCoexConfigGetReqSer CsrWifiEventSer
+#define CsrWifiSmeCoexConfigGetReqDes CsrWifiEventDes
+#define CsrWifiSmeCoexConfigGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeCoexConfigGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeCoexConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCoexConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCoexConfigSetReqSizeof(void *msg);
+#define CsrWifiSmeCoexConfigSetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeCoexInfoGetReqSer CsrWifiEventSer
+#define CsrWifiSmeCoexInfoGetReqDes CsrWifiEventDes
+#define CsrWifiSmeCoexInfoGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeCoexInfoGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeConnectReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeConnectReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeConnectReqSizeof(void *msg);
+extern void CsrWifiSmeConnectReqSerFree(void *msg);
+
+#define CsrWifiSmeConnectionConfigGetReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeConnectionConfigGetReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeConnectionConfigGetReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeConnectionConfigGetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeConnectionInfoGetReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeConnectionInfoGetReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeConnectionInfoGetReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeConnectionInfoGetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeConnectionStatsGetReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeConnectionStatsGetReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeConnectionStatsGetReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeConnectionStatsGetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeDeactivateReqSer CsrWifiEventSer
+#define CsrWifiSmeDeactivateReqDes CsrWifiEventDes
+#define CsrWifiSmeDeactivateReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeDeactivateReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeDisconnectReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeDisconnectReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeDisconnectReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeDisconnectReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeEventMaskSetReqSer CsrWifiEventCsrUint32Ser
+#define CsrWifiSmeEventMaskSetReqDes CsrWifiEventCsrUint32Des
+#define CsrWifiSmeEventMaskSetReqSizeof CsrWifiEventCsrUint32Sizeof
+#define CsrWifiSmeEventMaskSetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeHostConfigGetReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeHostConfigGetReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeHostConfigGetReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeHostConfigGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeHostConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeHostConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeHostConfigSetReqSizeof(void *msg);
+#define CsrWifiSmeHostConfigSetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeKeyReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeKeyReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeKeyReqSizeof(void *msg);
+#define CsrWifiSmeKeyReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeLinkQualityGetReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeLinkQualityGetReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeLinkQualityGetReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeLinkQualityGetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeMibConfigGetReqSer CsrWifiEventSer
+#define CsrWifiSmeMibConfigGetReqDes CsrWifiEventDes
+#define CsrWifiSmeMibConfigGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeMibConfigGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeMibConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMibConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMibConfigSetReqSizeof(void *msg);
+#define CsrWifiSmeMibConfigSetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeMibGetNextReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMibGetNextReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMibGetNextReqSizeof(void *msg);
+extern void CsrWifiSmeMibGetNextReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeMibGetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMibGetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMibGetReqSizeof(void *msg);
+extern void CsrWifiSmeMibGetReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeMibSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMibSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMibSetReqSizeof(void *msg);
+extern void CsrWifiSmeMibSetReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeMulticastAddressReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMulticastAddressReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMulticastAddressReqSizeof(void *msg);
+extern void CsrWifiSmeMulticastAddressReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmePacketFilterSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmePacketFilterSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmePacketFilterSetReqSizeof(void *msg);
+extern void CsrWifiSmePacketFilterSetReqSerFree(void *msg);
+
+#define CsrWifiSmePermanentMacAddressGetReqSer CsrWifiEventSer
+#define CsrWifiSmePermanentMacAddressGetReqDes CsrWifiEventDes
+#define CsrWifiSmePermanentMacAddressGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmePermanentMacAddressGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmePmkidReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmePmkidReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmePmkidReqSizeof(void *msg);
+extern void CsrWifiSmePmkidReqSerFree(void *msg);
+
+#define CsrWifiSmePowerConfigGetReqSer CsrWifiEventSer
+#define CsrWifiSmePowerConfigGetReqDes CsrWifiEventDes
+#define CsrWifiSmePowerConfigGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmePowerConfigGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmePowerConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmePowerConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmePowerConfigSetReqSizeof(void *msg);
+#define CsrWifiSmePowerConfigSetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeRegulatoryDomainInfoGetReqSer CsrWifiEventSer
+#define CsrWifiSmeRegulatoryDomainInfoGetReqDes CsrWifiEventDes
+#define CsrWifiSmeRegulatoryDomainInfoGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeRegulatoryDomainInfoGetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeRoamingConfigGetReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeRoamingConfigGetReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeRoamingConfigGetReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeRoamingConfigGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeRoamingConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeRoamingConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeRoamingConfigSetReqSizeof(void *msg);
+#define CsrWifiSmeRoamingConfigSetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeScanConfigGetReqSer CsrWifiEventSer
+#define CsrWifiSmeScanConfigGetReqDes CsrWifiEventDes
+#define CsrWifiSmeScanConfigGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeScanConfigGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeScanConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeScanConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeScanConfigSetReqSizeof(void *msg);
+extern void CsrWifiSmeScanConfigSetReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeScanFullReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeScanFullReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeScanFullReqSizeof(void *msg);
+extern void CsrWifiSmeScanFullReqSerFree(void *msg);
+
+#define CsrWifiSmeScanResultsFlushReqSer CsrWifiEventSer
+#define CsrWifiSmeScanResultsFlushReqDes CsrWifiEventDes
+#define CsrWifiSmeScanResultsFlushReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeScanResultsFlushReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeScanResultsGetReqSer CsrWifiEventSer
+#define CsrWifiSmeScanResultsGetReqDes CsrWifiEventDes
+#define CsrWifiSmeScanResultsGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeScanResultsGetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeSmeStaConfigGetReqSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeSmeStaConfigGetReqDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeSmeStaConfigGetReqSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeSmeStaConfigGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeSmeStaConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeSmeStaConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeSmeStaConfigSetReqSizeof(void *msg);
+#define CsrWifiSmeSmeStaConfigSetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeStationMacAddressGetReqSer CsrWifiEventSer
+#define CsrWifiSmeStationMacAddressGetReqDes CsrWifiEventDes
+#define CsrWifiSmeStationMacAddressGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeStationMacAddressGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeTspecReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeTspecReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeTspecReqSizeof(void *msg);
+extern void CsrWifiSmeTspecReqSerFree(void *msg);
+
+#define CsrWifiSmeVersionsGetReqSer CsrWifiEventSer
+#define CsrWifiSmeVersionsGetReqDes CsrWifiEventDes
+#define CsrWifiSmeVersionsGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeVersionsGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeWifiFlightmodeReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeWifiFlightmodeReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeWifiFlightmodeReqSizeof(void *msg);
+extern void CsrWifiSmeWifiFlightmodeReqSerFree(void *msg);
+
+#define CsrWifiSmeWifiOffReqSer CsrWifiEventSer
+#define CsrWifiSmeWifiOffReqDes CsrWifiEventDes
+#define CsrWifiSmeWifiOffReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeWifiOffReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeWifiOnReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeWifiOnReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeWifiOnReqSizeof(void *msg);
+extern void CsrWifiSmeWifiOnReqSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeCloakedSsidsSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCloakedSsidsSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCloakedSsidsSetReqSizeof(void *msg);
+extern void CsrWifiSmeCloakedSsidsSetReqSerFree(void *msg);
+
+#define CsrWifiSmeCloakedSsidsGetReqSer CsrWifiEventSer
+#define CsrWifiSmeCloakedSsidsGetReqDes CsrWifiEventDes
+#define CsrWifiSmeCloakedSsidsGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeCloakedSsidsGetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeSmeCommonConfigGetReqSer CsrWifiEventSer
+#define CsrWifiSmeSmeCommonConfigGetReqDes CsrWifiEventDes
+#define CsrWifiSmeSmeCommonConfigGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeSmeCommonConfigGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeSmeCommonConfigSetReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeSmeCommonConfigSetReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeSmeCommonConfigSetReqSizeof(void *msg);
+#define CsrWifiSmeSmeCommonConfigSetReqSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeInterfaceCapabilityGetReqSer CsrWifiEventSer
+#define CsrWifiSmeInterfaceCapabilityGetReqDes CsrWifiEventDes
+#define CsrWifiSmeInterfaceCapabilityGetReqSizeof CsrWifiEventSizeof
+#define CsrWifiSmeInterfaceCapabilityGetReqSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeWpsConfigurationReqSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeWpsConfigurationReqDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeWpsConfigurationReqSizeof(void *msg);
+extern void CsrWifiSmeWpsConfigurationReqSerFree(void *msg);
+
+#define CsrWifiSmeActivateCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeActivateCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeActivateCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeActivateCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeAdhocConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeAdhocConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeAdhocConfigGetCfmSizeof(void *msg);
+#define CsrWifiSmeAdhocConfigGetCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeAdhocConfigSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeAdhocConfigSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeAdhocConfigSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeAdhocConfigSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeAssociationCompleteIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeAssociationCompleteIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeAssociationCompleteIndSizeof(void *msg);
+extern void CsrWifiSmeAssociationCompleteIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeAssociationStartIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeAssociationStartIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeAssociationStartIndSizeof(void *msg);
+#define CsrWifiSmeAssociationStartIndSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeBlacklistCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeBlacklistCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeBlacklistCfmSizeof(void *msg);
+extern void CsrWifiSmeBlacklistCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeCalibrationDataGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCalibrationDataGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCalibrationDataGetCfmSizeof(void *msg);
+extern void CsrWifiSmeCalibrationDataGetCfmSerFree(void *msg);
+
+#define CsrWifiSmeCalibrationDataSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeCalibrationDataSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeCalibrationDataSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeCalibrationDataSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeCcxConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCcxConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCcxConfigGetCfmSizeof(void *msg);
+#define CsrWifiSmeCcxConfigGetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeCcxConfigSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCcxConfigSetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCcxConfigSetCfmSizeof(void *msg);
+#define CsrWifiSmeCcxConfigSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeCoexConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCoexConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCoexConfigGetCfmSizeof(void *msg);
+#define CsrWifiSmeCoexConfigGetCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeCoexConfigSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeCoexConfigSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeCoexConfigSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeCoexConfigSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeCoexInfoGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCoexInfoGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCoexInfoGetCfmSizeof(void *msg);
+#define CsrWifiSmeCoexInfoGetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeConnectCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeConnectCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeConnectCfmSizeof(void *msg);
+#define CsrWifiSmeConnectCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeConnectionConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeConnectionConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeConnectionConfigGetCfmSizeof(void *msg);
+extern void CsrWifiSmeConnectionConfigGetCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeConnectionInfoGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeConnectionInfoGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeConnectionInfoGetCfmSizeof(void *msg);
+extern void CsrWifiSmeConnectionInfoGetCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeConnectionQualityIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeConnectionQualityIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeConnectionQualityIndSizeof(void *msg);
+#define CsrWifiSmeConnectionQualityIndSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeConnectionStatsGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeConnectionStatsGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeConnectionStatsGetCfmSizeof(void *msg);
+#define CsrWifiSmeConnectionStatsGetCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeDeactivateCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeDeactivateCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeDeactivateCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeDeactivateCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeDisconnectCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeDisconnectCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeDisconnectCfmSizeof(void *msg);
+#define CsrWifiSmeDisconnectCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeEventMaskSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeEventMaskSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeEventMaskSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeEventMaskSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeHostConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeHostConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeHostConfigGetCfmSizeof(void *msg);
+#define CsrWifiSmeHostConfigGetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeHostConfigSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeHostConfigSetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeHostConfigSetCfmSizeof(void *msg);
+#define CsrWifiSmeHostConfigSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeIbssStationIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeIbssStationIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeIbssStationIndSizeof(void *msg);
+#define CsrWifiSmeIbssStationIndSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeKeyCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeKeyCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeKeyCfmSizeof(void *msg);
+#define CsrWifiSmeKeyCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeLinkQualityGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeLinkQualityGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeLinkQualityGetCfmSizeof(void *msg);
+#define CsrWifiSmeLinkQualityGetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeMediaStatusIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMediaStatusIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMediaStatusIndSizeof(void *msg);
+extern void CsrWifiSmeMediaStatusIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeMibConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMibConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMibConfigGetCfmSizeof(void *msg);
+#define CsrWifiSmeMibConfigGetCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeMibConfigSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeMibConfigSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeMibConfigSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeMibConfigSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeMibGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMibGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMibGetCfmSizeof(void *msg);
+extern void CsrWifiSmeMibGetCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeMibGetNextCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMibGetNextCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMibGetNextCfmSizeof(void *msg);
+extern void CsrWifiSmeMibGetNextCfmSerFree(void *msg);
+
+#define CsrWifiSmeMibSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeMibSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeMibSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeMibSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeMicFailureIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMicFailureIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMicFailureIndSizeof(void *msg);
+#define CsrWifiSmeMicFailureIndSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeMulticastAddressCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeMulticastAddressCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeMulticastAddressCfmSizeof(void *msg);
+extern void CsrWifiSmeMulticastAddressCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmePacketFilterSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmePacketFilterSetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmePacketFilterSetCfmSizeof(void *msg);
+#define CsrWifiSmePacketFilterSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmePermanentMacAddressGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmePermanentMacAddressGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmePermanentMacAddressGetCfmSizeof(void *msg);
+#define CsrWifiSmePermanentMacAddressGetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmePmkidCandidateListIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmePmkidCandidateListIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmePmkidCandidateListIndSizeof(void *msg);
+extern void CsrWifiSmePmkidCandidateListIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmePmkidCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmePmkidCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmePmkidCfmSizeof(void *msg);
+extern void CsrWifiSmePmkidCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmePowerConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmePowerConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmePowerConfigGetCfmSizeof(void *msg);
+#define CsrWifiSmePowerConfigGetCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmePowerConfigSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmePowerConfigSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmePowerConfigSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmePowerConfigSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeRegulatoryDomainInfoGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeRegulatoryDomainInfoGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeRegulatoryDomainInfoGetCfmSizeof(void *msg);
+#define CsrWifiSmeRegulatoryDomainInfoGetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeRoamCompleteIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeRoamCompleteIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeRoamCompleteIndSizeof(void *msg);
+#define CsrWifiSmeRoamCompleteIndSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeRoamStartIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeRoamStartIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeRoamStartIndSizeof(void *msg);
+#define CsrWifiSmeRoamStartIndSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeRoamingConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeRoamingConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeRoamingConfigGetCfmSizeof(void *msg);
+#define CsrWifiSmeRoamingConfigGetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeRoamingConfigSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeRoamingConfigSetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeRoamingConfigSetCfmSizeof(void *msg);
+#define CsrWifiSmeRoamingConfigSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeScanConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeScanConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeScanConfigGetCfmSizeof(void *msg);
+extern void CsrWifiSmeScanConfigGetCfmSerFree(void *msg);
+
+#define CsrWifiSmeScanConfigSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeScanConfigSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeScanConfigSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeScanConfigSetCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeScanFullCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeScanFullCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeScanFullCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeScanFullCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeScanResultIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeScanResultIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeScanResultIndSizeof(void *msg);
+extern void CsrWifiSmeScanResultIndSerFree(void *msg);
+
+#define CsrWifiSmeScanResultsFlushCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeScanResultsFlushCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeScanResultsFlushCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeScanResultsFlushCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeScanResultsGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeScanResultsGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeScanResultsGetCfmSizeof(void *msg);
+extern void CsrWifiSmeScanResultsGetCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeSmeStaConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeSmeStaConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeSmeStaConfigGetCfmSizeof(void *msg);
+#define CsrWifiSmeSmeStaConfigGetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeSmeStaConfigSetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeSmeStaConfigSetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeSmeStaConfigSetCfmSizeof(void *msg);
+#define CsrWifiSmeSmeStaConfigSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeStationMacAddressGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeStationMacAddressGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeStationMacAddressGetCfmSizeof(void *msg);
+#define CsrWifiSmeStationMacAddressGetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeTspecIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeTspecIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeTspecIndSizeof(void *msg);
+extern void CsrWifiSmeTspecIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeTspecCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeTspecCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeTspecCfmSizeof(void *msg);
+extern void CsrWifiSmeTspecCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeVersionsGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeVersionsGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeVersionsGetCfmSizeof(void *msg);
+extern void CsrWifiSmeVersionsGetCfmSerFree(void *msg);
+
+#define CsrWifiSmeWifiFlightmodeCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeWifiFlightmodeCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeWifiFlightmodeCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeWifiFlightmodeCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeWifiOffIndSer CsrWifiEventCsrUint8Ser
+#define CsrWifiSmeWifiOffIndDes CsrWifiEventCsrUint8Des
+#define CsrWifiSmeWifiOffIndSizeof CsrWifiEventCsrUint8Sizeof
+#define CsrWifiSmeWifiOffIndSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeWifiOffCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeWifiOffCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeWifiOffCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeWifiOffCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeWifiOnCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeWifiOnCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeWifiOnCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeWifiOnCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeCloakedSsidsSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeCloakedSsidsSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeCloakedSsidsSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeCloakedSsidsSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeCloakedSsidsGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCloakedSsidsGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCloakedSsidsGetCfmSizeof(void *msg);
+extern void CsrWifiSmeCloakedSsidsGetCfmSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeWifiOnIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeWifiOnIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeWifiOnIndSizeof(void *msg);
+#define CsrWifiSmeWifiOnIndSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeSmeCommonConfigGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeSmeCommonConfigGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeSmeCommonConfigGetCfmSizeof(void *msg);
+#define CsrWifiSmeSmeCommonConfigGetCfmSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeSmeCommonConfigSetCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeSmeCommonConfigSetCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeSmeCommonConfigSetCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeSmeCommonConfigSetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeInterfaceCapabilityGetCfmSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeInterfaceCapabilityGetCfmDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeInterfaceCapabilityGetCfmSizeof(void *msg);
+#define CsrWifiSmeInterfaceCapabilityGetCfmSerFree CsrWifiSmePfree
+
+extern CsrUint8* CsrWifiSmeErrorIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeErrorIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeErrorIndSizeof(void *msg);
+extern void CsrWifiSmeErrorIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeInfoIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeInfoIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeInfoIndSizeof(void *msg);
+extern void CsrWifiSmeInfoIndSerFree(void *msg);
+
+extern CsrUint8* CsrWifiSmeCoreDumpIndSer(CsrUint8 *ptr, CsrSize *len, void *msg);
+extern void* CsrWifiSmeCoreDumpIndDes(CsrUint8 *buffer, CsrSize len);
+extern CsrSize CsrWifiSmeCoreDumpIndSizeof(void *msg);
+extern void CsrWifiSmeCoreDumpIndSerFree(void *msg);
+
+#define CsrWifiSmeAmpStatusChangeIndSer CsrWifiEventCsrUint16CsrUint8Ser
+#define CsrWifiSmeAmpStatusChangeIndDes CsrWifiEventCsrUint16CsrUint8Des
+#define CsrWifiSmeAmpStatusChangeIndSizeof CsrWifiEventCsrUint16CsrUint8Sizeof
+#define CsrWifiSmeAmpStatusChangeIndSerFree CsrWifiSmePfree
+
+#define CsrWifiSmeWpsConfigurationCfmSer CsrWifiEventCsrUint16Ser
+#define CsrWifiSmeWpsConfigurationCfmDes CsrWifiEventCsrUint16Des
+#define CsrWifiSmeWpsConfigurationCfmSizeof CsrWifiEventCsrUint16Sizeof
+#define CsrWifiSmeWpsConfigurationCfmSerFree CsrWifiSmePfree
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* CSR_WIFI_SME_SERIALIZE_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_sme_task.h
@@ -0,0 +1,34 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+/* Note: this is an auto-generated file. */
+
+#ifndef CSR_WIFI_SME_TASK_H__
+#define CSR_WIFI_SME_TASK_H__
+
+#include "csr_types.h"
+#include "csr_sched.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CSR_WIFI_SME_LOG_ID 0x1202FFFF
+extern CsrSchedQid CSR_WIFI_SME_IFACEQUEUE;
+void CsrWifiSmeInit(void **gash);
+void CsrWifiSmeDeinit(void **gash);
+void CsrWifiSmeHandler(void **gash);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_SME_TASK_H__ */
+
--- /dev/null
+++ b/drivers/staging/csr/csr_wifi_vif_utils.h
@@ -0,0 +1,108 @@
+/*****************************************************************************
+
+            (c) Cambridge Silicon Radio Limited 2011
+            All rights reserved and confidential information of CSR
+
+            Refer to LICENSE.txt included with this source for details
+            on the license terms.
+
+*****************************************************************************/
+
+#ifndef CSR_WIFI_VIF_UTILS_H
+#define CSR_WIFI_VIF_UTILS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* STANDARD INCLUDES ********************************************************/
+
+/* PROJECT INCLUDES *********************************************************/
+/* including this file for CsrWifiInterfaceMode*/
+#include "csr_wifi_private_common.h"
+
+/* MACROS *******************************************************************/
+
+/* Common macros for NME and SME to be used temporarily until SoftMAC changes are made */
+#define CSR_WIFI_NUM_INTERFACES        (CsrUint8)0x1
+#define CSR_WIFI_INTERFACE_IN_USE      (CsrUint16)0x0
+
+/* This is used at places where interface Id isn't available*/
+#define CSR_WIFI_INTERFACE_ZERO        0
+#define CSR_WIFI_INTERFACE_STA         0
+#define CSR_WIFI_INTERFACE_AMP         0
+
+
+#define CSR_WIFI_VIF_UTILS_UNDEFINED_TAG 0xFFFF
+
+/* Extract the Interface Id from the event */
+#define CsrWifiVifUtilsGetVifTagFromEvent(msg) \
+    ((CsrUint16) * ((CsrUint16 *) ((CsrUint8 *) (msg) + sizeof(CsrWifiFsmEvent))))
+
+/* The HPI Vif combines the type and the interface id */
+#define CsrWifiVifUtilsGetVifTagFromHipEvent(msg) \
+    ((msg)->virtualInterfaceIdentifier & 0x00FF)
+
+#define CsrWifiVifUtilsPackHipEventVif(type, interfaceId) \
+    ((CsrUint16)((interfaceId) | ((type) << 8)))
+
+
+/* TYPES DEFINITIONS ********************************************************/
+
+/* GLOBAL VARIABLE DECLARATIONS *********************************************/
+
+/* PUBLIC FUNCTION PROTOTYPES ***********************************************/
+
+/**
+ * @brief
+ *     First checks if the mode is supported capability bitmap of the interface.
+ *     If this succeeds, then checks if running this mode on this interface is allowed.
+ *
+ * @param[in] CsrUint8 : interface capability bitmap
+ * @param[in] CsrUint8* : pointer to the array of current interface modes
+ * @param[in] CsrUint16 : interfaceTag
+ * @param[in] CsrWifiInterfaceMode : mode
+ *
+ * @return
+ *     CsrBool : returns true if the interface is allowed to operate in the mode otherwise false.
+ */
+extern CsrBool CsrWifiVifUtilsCheckCompatibility(CsrUint8             interfaceCapability,
+                                                 CsrUint8            *currentInterfaceModes,
+                                                 CsrUint16            interfaceTag,
+                                                 CsrWifiInterfaceMode mode);
+
+/**
+ * @brief
+ *     Checks if the specified interface is supported.
+ *     NOTE: Only checks that the interface is supported, no checks are made to
+ *     determine whether a supported interface may be made active.
+ *
+ * @param[in] CsrUint16 : interfaceTag
+ *
+ * @return
+ *     CsrBool : returns true if the interface is supported, otherwise false.
+ */
+extern CsrBool CsrWifiVifUtilsIsSupported(CsrUint16 interfaceTag);
+
+#ifdef CSR_LOG_ENABLE
+/**
+ * @brief
+ *     Registers the virtual interface utils logging details.
+ *     Should only be called once at initialisation.
+ *
+ * @param[in/out] None
+ *
+ * @return
+ *     None
+ */
+void CsrWifiVifUtilsLogTextRegister(void);
+#else
+#define CsrWifiVifUtilsLogTextRegister()
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CSR_WIFI_VIF_UTILS_H */
+
--- /dev/null
+++ b/drivers/staging/csr/data_tx.c
@@ -0,0 +1,57 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     data_tx.c
+ *
+ * PURPOSE:
+ *      This file provides functions to send data requests to the UniFi.
+ *
+ * Copyright (C) 2007-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "unifi_priv.h"
+
+int
+uf_verify_m4(unifi_priv_t *priv, const unsigned char *packet, unsigned int length)
+{
+    const unsigned char *p = packet;
+    CsrUint16 keyinfo;
+
+
+    if (length < (4 + 5 + 8 + 32 + 16 + 8 + 8 + 16 + 1 + 8)) {
+        return 1;
+    }
+
+    p += 8;
+    keyinfo = p[5] << 8 | p[6]; /* big-endian */
+    if (
+          (p[0] == 1 || p[0] == 2) /* protocol version 802.1X-2001 (WPA) or -2004 (WPA2) */ &&
+          p[1] == 3 /* EAPOL-Key */ &&
+          /* don't bother checking p[2] p[3] (hh ll, packet body length) */
+          (p[4] == 254 || p[4] == 2) /* descriptor type P802.1i-D3.0 (WPA) or 802.11i-2004 (WPA2) */ &&
+          ((keyinfo & 0x0007) == 1 || (keyinfo & 0x0007) == 2) /* key descriptor version */ &&
+         (keyinfo & ~0x0207U) == 0x0108 && /* key info for 4/4 or 4/2 -- ignore key desc version and sec bit (since varies in WPA 4/4) */
+          (p[4 + 5 + 8 + 32 + 16 + 8 + 8 + 16 + 0] == 0 && /* key data length (2 octets) 0 for 4/4 only */
+           p[4 + 5 + 8 + 32 + 16 + 8 + 8 + 16 + 1] == 0)
+        ) {
+        unifi_trace(priv, UDBG1, "uf_verify_m4: M4 detected \n");
+        return 0;
+    }
+    else
+    {
+        return 1;
+    }
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ *      Data transport signals.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
--- /dev/null
+++ b/drivers/staging/csr/drv.c
@@ -0,0 +1,2150 @@
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     drv.c
+ *
+ *  PURPOSE:
+ *      Conventional device interface for debugging/monitoring of the
+ *      driver and h/w using unicli. This interface is also being used
+ *      by the SME linux implementation and the helper apps.
+ *
+ * Copyright (C) 2005-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+
+
+/*
+ * Porting Notes:
+ * Part of this file contains an example for how to glue the OS layer
+ * with the HIP core lib, the SDIO glue layer, and the SME.
+ *
+ * When the unifi_sdio.ko modules loads, the linux kernel calls unifi_load().
+ * unifi_load() calls uf_sdio_load() which is exported by the SDIO glue
+ * layer. uf_sdio_load() registers this driver with the underlying SDIO driver.
+ * When a card is detected, the SDIO glue layer calls register_unifi_sdio()
+ * to pass the SDIO function context and ask the OS layer to initialise
+ * the card. register_unifi_sdio() allocates all the private data of the OS
+ * layer and calls uf_run_unifihelper() to start the SME. The SME calls
+ * unifi_sys_wifi_on_req() which uses the HIP core lib to initialise the card.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/jiffies.h>
+
+#include "csr_wifi_hip_unifiversion.h"
+#include "unifi_priv.h"
+#include "csr_wifi_hip_conversions.h"
+#include "unifi_native.h"
+
+/* Module parameter variables */
+int buswidth = 0;               /* 0 means use default, values 1,4 */
+int sdio_clock = 50000;         /* kHz */
+int unifi_debug = 0;
+/*
+ * fw_init prevents f/w initialisation on error.
+ * Unless necessary, avoid usage in the CSR_SME_EMB build because it prevents
+ * UniFi initialisation after getting out of suspend and also leaves
+ * UniFi powered when the module unloads.
+ */
+int fw_init[MAX_UNIFI_DEVS] = {-1, -1};
+int use_5g = 0;
+int led_mask = 0;               /* 0x0c00 for dev-pc-1503c, dev-pc-1528a */
+int disable_hw_reset = 0;
+int disable_power_control = 0;
+int enable_wol = UNIFI_WOL_OFF; /* 0 for none, 1 for SDIO IRQ, 2 for PIO */
+#if (defined CSR_SUPPORT_SME) && (defined CSR_SUPPORT_WEXT)
+int tl_80211d = (int)CSR_WIFI_SME_80211D_TRUST_LEVEL_MIB;
+#endif
+int sdio_block_size = -1;      /* Override SDIO block size */
+int sdio_byte_mode = 0;        /* 0 for block mode + padding, 1 for byte mode */
+int coredump_max = CSR_WIFI_HIP_NUM_COREDUMP_BUFFERS;
+int run_bh_once = -1;          /* Set for scheduled interrupt mode, -1 = default */
+int bh_priority = -1;
+
+MODULE_DESCRIPTION("CSR UniFi (SDIO)");
+
+module_param(buswidth,    int, S_IRUGO|S_IWUSR);
+module_param(sdio_clock,  int, S_IRUGO|S_IWUSR);
+module_param(unifi_debug, int, S_IRUGO|S_IWUSR);
+module_param_array(fw_init, int, NULL, S_IRUGO|S_IWUSR);
+module_param(use_5g,      int, S_IRUGO|S_IWUSR);
+module_param(led_mask,    int, S_IRUGO|S_IWUSR);
+module_param(disable_hw_reset,  int, S_IRUGO|S_IWUSR);
+module_param(disable_power_control,  int, S_IRUGO|S_IWUSR);
+module_param(enable_wol,  int, S_IRUGO|S_IWUSR);
+#if (defined CSR_SUPPORT_SME) && (defined CSR_SUPPORT_WEXT)
+module_param(tl_80211d,   int, S_IRUGO|S_IWUSR);
+#endif
+module_param(sdio_block_size, int, S_IRUGO|S_IWUSR);
+module_param(sdio_byte_mode, int, S_IRUGO|S_IWUSR);
+module_param(coredump_max, int, S_IRUGO|S_IWUSR);
+module_param(run_bh_once, int, S_IRUGO|S_IWUSR);
+module_param(bh_priority, int, S_IRUGO|S_IWUSR);
+
+MODULE_PARM_DESC(buswidth, "SDIO bus width (0=default), set 1 for 1-bit or 4 for 4-bit mode");
+MODULE_PARM_DESC(sdio_clock, "SDIO bus frequency in kHz, (default = 50 MHz)");
+MODULE_PARM_DESC(unifi_debug, "Diagnostic reporting level");
+MODULE_PARM_DESC(fw_init, "Set to 0 to prevent f/w initialization on error");
+MODULE_PARM_DESC(use_5g, "Use the 5G (802.11a) radio band");
+MODULE_PARM_DESC(led_mask, "LED mask flags");
+MODULE_PARM_DESC(disable_hw_reset, "Set to 1 to disable hardware reset");
+MODULE_PARM_DESC(disable_power_control, "Set to 1 to disable SDIO power control");
+MODULE_PARM_DESC(enable_wol, "Enable wake-on-wlan function 0=off, 1=SDIO, 2=PIO");
+#if (defined CSR_SUPPORT_SME) && (defined CSR_SUPPORT_WEXT)
+MODULE_PARM_DESC(tl_80211d, "802.11d Trust Level (1-6, default = 5)");
+#endif
+MODULE_PARM_DESC(sdio_block_size, "Set to override SDIO block size");
+MODULE_PARM_DESC(sdio_byte_mode, "Set to 1 for byte mode SDIO");
+MODULE_PARM_DESC(coredump_max, "Number of chip mini-coredump buffers to allocate");
+MODULE_PARM_DESC(run_bh_once, "Run BH only when firmware interrupts");
+MODULE_PARM_DESC(bh_priority, "Modify the BH thread priority");
+
+/* Callback for event logging to UDI clients */
+static void udi_log_event(ul_client_t *client,
+                          const u8 *signal, int signal_len,
+                          const bulk_data_param_t *bulkdata,
+                          int dir);
+
+static void udi_set_log_filter(ul_client_t *pcli,
+                               unifiio_filter_t *udi_filter);
+
+
+/* Mutex to protect access to  priv->sme_cli */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
+DEFINE_SEMAPHORE(udi_mutex);
+#else
+DECLARE_MUTEX(udi_mutex);
+#endif
+
+CsrInt32 CsrHipResultToStatus(CsrResult csrResult)
+{
+    CsrInt32 r = -EIO;
+
+    switch (csrResult)
+    {
+    case CSR_RESULT_SUCCESS:
+        r = 0;
+        break;
+    case CSR_WIFI_HIP_RESULT_RANGE:
+        r = -ERANGE;
+        break;
+    case CSR_WIFI_HIP_RESULT_NO_DEVICE:
+        r = -ENODEV;
+        break;
+    case CSR_WIFI_HIP_RESULT_INVALID_VALUE:
+        r = -EINVAL;
+        break;
+    case CSR_WIFI_HIP_RESULT_NOT_FOUND:
+        r = -ENOENT;
+        break;
+    case CSR_WIFI_HIP_RESULT_NO_SPACE:
+        r = -ENOSPC;
+        break;
+    case CSR_WIFI_HIP_RESULT_NO_MEMORY:
+        r = -ENOMEM;
+        break;
+    case CSR_RESULT_FAILURE:
+        r = -EIO;
+        break;
+    default:
+        /*unifi_warning(card->ospriv, "CsrHipResultToStatus: Unrecognised csrResult error code: %d\n", csrResult);*/
+        r = -EIO;
+    }
+    return r;
+}
+
+
+static const char*
+trace_putest_cmdid(unifi_putest_command_t putest_cmd)
+{
+    switch (putest_cmd)
+    {
+        case UNIFI_PUTEST_START:
+            return "START";
+        case UNIFI_PUTEST_STOP:
+            return "STOP";
+        case UNIFI_PUTEST_SET_SDIO_CLOCK:
+            return "SET CLOCK";
+        case UNIFI_PUTEST_CMD52_READ:
+            return "CMD52R";
+        case UNIFI_PUTEST_CMD52_BLOCK_READ:
+            return "CMD52BR";
+        case UNIFI_PUTEST_CMD52_WRITE:
+            return "CMD52W";
+        case UNIFI_PUTEST_DL_FW:
+            return "D/L FW";
+        case UNIFI_PUTEST_DL_FW_BUFF:
+            return "D/L FW BUFFER";
+        case UNIFI_PUTEST_COREDUMP_PREPARE:
+            return "PREPARE COREDUMP";
+        case UNIFI_PUTEST_GP_READ16:
+            return "GP16R";
+        case UNIFI_PUTEST_GP_WRITE16:
+            return "GP16W";
+        default:
+            return "ERROR: unrecognised command";
+    }
+ }
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_open
+ *  unifi_release
+ *
+ *      Open and release entry points for the UniFi debug driver.
+ *
+ *  Arguments:
+ *      Normal linux driver args.
+ *
+ *  Returns:
+ *      Linux error code.
+ * ---------------------------------------------------------------------------
+ */
+static int
+unifi_open(struct inode *inode, struct file *file)
+{
+    int devno;
+    unifi_priv_t *priv;
+    ul_client_t *udi_cli;
+
+    func_enter();
+
+    devno = MINOR(inode->i_rdev) >> 1;
+
+    /*
+     * Increase the ref_count for the char device clients.
+     * Make sure you call uf_put_instance() to decreace it if
+     * unifi_open returns an error.
+     */
+    priv = uf_get_instance(devno);
+    if (priv == NULL) {
+        unifi_error(NULL, "unifi_open: No device present\n");
+        func_exit();
+        return -ENODEV;
+    }
+
+    /* Register this instance in the client's list. */
+    /* The minor number determines the nature of the client (Unicli or SME). */
+    if (MINOR(inode->i_rdev) & 0x1) {
+        udi_cli = ul_register_client(priv, CLI_USING_WIRE_FORMAT, udi_log_event);
+        if (udi_cli == NULL) {
+            /* Too many clients already using this device */
+            unifi_error(priv, "Too many clients already open\n");
+            uf_put_instance(devno);
+            func_exit();
+            return -ENOSPC;
+        }
+        unifi_trace(priv, UDBG1, "Client is registered to /dev/unifiudi%d\n", devno);
+    } else {
+        /*
+         * Even-numbered device nodes are the control application.
+         * This is the userspace helper containing SME or
+         * unifi_manager.
+         */
+
+        down(&udi_mutex);
+
+#ifdef CSR_SME_USERSPACE
+        /* Check if a config client is already attached */
+        if (priv->sme_cli) {
+            up(&udi_mutex);
+            uf_put_instance(devno);
+
+            unifi_info(priv, "There is already a configuration client using the character device\n");
+            func_exit();
+            return -EBUSY;
+        }
+#endif /* CSR_SME_USERSPACE */
+
+#ifdef CSR_SUPPORT_SME
+        udi_cli = ul_register_client(priv,
+                                     CLI_USING_WIRE_FORMAT | CLI_SME_USERSPACE,
+                                     sme_log_event);
+#else
+        /* Config client for native driver */
+        udi_cli = ul_register_client(priv,
+                                     0,
+                                     sme_native_log_event);
+#endif
+        if (udi_cli == NULL) {
+            /* Too many clients already using this device */
+            up(&udi_mutex);
+            uf_put_instance(devno);
+
+            unifi_error(priv, "Too many clients already open\n");
+            func_exit();
+            return -ENOSPC;
+        }
+
+        /*
+         * Fill-in the pointer to the configuration client.
+         * This is the SME userspace helper or unifi_manager.
+         * Not used in the SME embedded version.
+         */
+        unifi_trace(priv, UDBG1, "SME client (id:%d s:0x%X) is registered\n",
+                    udi_cli->client_id, udi_cli->sender_id);
+        /* Store the SME UniFi Linux Client */
+        if (priv->sme_cli == NULL) {
+            priv->sme_cli = udi_cli;
+        }
+
+        up(&udi_mutex);
+    }
+
+
+    /*
+     * Store the pointer to the client.
+     * All char driver's entry points will pass this pointer.
+     */
+    file->private_data = udi_cli;
+
+    func_exit();
+    return 0;
+} /* unifi_open() */
+
+
+
+static int
+unifi_release(struct inode *inode, struct file *filp)
+{
+    ul_client_t *udi_cli = (void*)filp->private_data;
+    int devno;
+    unifi_priv_t *priv;
+
+    func_enter();
+
+    priv = uf_find_instance(udi_cli->instance);
+    if (!priv) {
+        unifi_error(priv, "unifi_close: instance for device not found\n");
+        return -ENODEV;
+    }
+
+    devno = MINOR(inode->i_rdev) >> 1;
+
+    /* Even device nodes are the config client (i.e. SME or unifi_manager) */
+    if ((MINOR(inode->i_rdev) & 0x1) == 0) {
+
+        if (priv->sme_cli != udi_cli) {
+            unifi_notice(priv, "Surprise closing config device: not the sme client\n");
+        }
+        unifi_notice(priv, "SME client close (unifi%d)\n", devno);
+
+        /*
+         * Clear sme_cli before calling unifi_sys_... so it doesn't try to
+         * queue a reply to the (now gone) SME.
+         */
+        down(&udi_mutex);
+        priv->sme_cli = NULL;
+        up(&udi_mutex);
+
+#ifdef CSR_SME_USERSPACE
+        /* Power-down when config client closes */
+        {
+            CsrWifiRouterCtrlWifiOffReq req = {{CSR_WIFI_ROUTER_CTRL_HIP_REQ, 0, 0, 0, NULL}};
+            CsrWifiRouterCtrlWifiOffReqHandler(priv, &req.common);
+        }
+
+        uf_sme_deinit(priv);
+#endif /* CSR_SME_USERSPACE */
+    } else {
+
+        unifi_trace(priv, UDBG2, "UDI client close (unifiudi%d)\n", devno);
+
+        /* If the pointer matches the logging client, stop logging. */
+        down(&priv->udi_logging_mutex);
+        if (udi_cli == priv->logging_client) {
+            priv->logging_client = NULL;
+        }
+        up(&priv->udi_logging_mutex);
+
+        if (udi_cli == priv->amp_client) {
+            priv->amp_client = NULL;
+        }
+    }
+
+    /* Deregister this instance from the client's list. */
+    ul_deregister_client(udi_cli);
+
+    uf_put_instance(devno);
+
+    return 0;
+} /* unifi_release() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_read
+ *
+ *      The read() driver entry point.
+ *
+ *  Arguments:
+ *      filp        The file descriptor returned by unifi_open()
+ *      p           The user space buffer to copy the read data
+ *      len         The size of the p buffer
+ *      poff
+ *
+ *  Returns:
+ *      number of bytes read or an error code on failure
+ * ---------------------------------------------------------------------------
+ */
+static ssize_t
+unifi_read(struct file *filp, char *p, size_t len, loff_t *poff)
+{
+    ul_client_t *pcli = (void*)filp->private_data;
+    unifi_priv_t *priv;
+    udi_log_t *logptr = NULL;
+    udi_msg_t *msgptr;
+    struct list_head *l;
+    int msglen;
+
+    func_enter();
+
+    priv = uf_find_instance(pcli->instance);
+    if (!priv) {
+        unifi_error(priv, "invalid priv\n");
+        return -ENODEV;
+    }
+
+    if (!pcli->udi_enabled) {
+        unifi_error(priv, "unifi_read: unknown client.");
+        return -EINVAL;
+    }
+
+    if (list_empty(&pcli->udi_log)) {
+        if (filp->f_flags & O_NONBLOCK) {
+            /* Non-blocking - just return if the udi_log is empty */
+            return 0;
+        } else {
+            /* Blocking - wait on the UDI wait queue */
+            if (wait_event_interruptible(pcli->udi_wq,
+                !list_empty(&pcli->udi_log)))
+            {
+                unifi_error(priv, "unifi_read: wait_event_interruptible failed.");
+                return -ERESTARTSYS;
+            }
+        }
+    }
+
+    /* Read entry from list head and remove it from the list */
+    if (down_interruptible(&pcli->udi_sem)) {
+        return -ERESTARTSYS;
+    }
+    l = pcli->udi_log.next;
+    list_del(l);
+    up(&pcli->udi_sem);
+
+    /* Get a pointer to whole struct */
+    logptr = list_entry(l, udi_log_t, q);
+    if (logptr == NULL) {
+        unifi_error(priv, "unifi_read: failed to get event.\n");
+        return -EINVAL;
+    }
+
+    /* Get the real message */
+    msgptr = &logptr->msg;
+    msglen = msgptr->length;
+    if (msglen > len) {
+        printk(KERN_WARNING "truncated read to %d actual msg len is %lu\n", msglen, (long unsigned int)len);
+        msglen = len;
+    }
+
+    /* and pass it to the client (SME or Unicli). */
+    if (copy_to_user(p, msgptr, msglen))
+    {
+        printk(KERN_ERR "Failed to copy UDI log to user\n");
+        kfree(logptr);
+        return -EFAULT;
+    }
+
+    /* It is our resposibility to free the message buffer. */
+    kfree(logptr);
+
+    func_exit_r(msglen);
+    return msglen;
+
+} /* unifi_read() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * udi_send_signal_unpacked
+ *
+ *      Sends an unpacked signal to UniFi.
+ *
+ * Arguments:
+ *      priv            Pointer to private context struct
+ *      data            Pointer to request structure and data to send
+ *      data_len        Length of data in data pointer.
+ *
+ * Returns:
+ *      Number of bytes written, error otherwise.
+ *
+ * Notes:
+ *      All clients that use this function to send a signal to the unifi
+ *      must use the host formatted structures.
+ * ---------------------------------------------------------------------------
+ */
+static int
+udi_send_signal_unpacked(unifi_priv_t *priv, unsigned char* data, uint data_len)
+{
+    CSR_SIGNAL *sigptr = (CSR_SIGNAL*)data;
+    CSR_DATAREF *datarefptr;
+    bulk_data_param_t bulk_data;
+    uint signal_size, i;
+    uint bulk_data_offset = 0;
+    int bytecount, r;
+    CsrResult csrResult;
+
+    /* Number of bytes in the signal */
+    signal_size = SigGetSize(sigptr);
+    if (!signal_size || (signal_size > data_len)) {
+        unifi_error(priv, "unifi_sme_mlme_req - Invalid signal 0x%x size should be %d bytes\n",
+                    sigptr->SignalPrimitiveHeader.SignalId,
+                    signal_size);
+        return -EINVAL;
+    }
+    bytecount = signal_size;
+
+    /* Get a pointer to the information of the first data reference */
+    datarefptr = (CSR_DATAREF*)&sigptr->u;
+
+    /* Initialize the offset in the data buffer, bulk data is right after the signal. */
+    bulk_data_offset = signal_size;
+
+    /* store the references and the size of the bulk data to the bulkdata structure */
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+        /* the length of the bulk data is in the signal */
+        if ((datarefptr+i)->DataLength) {
+            void *dest;
+
+            csrResult = unifi_net_data_malloc(priv, &bulk_data.d[i], (datarefptr+i)->DataLength);
+            if (csrResult != CSR_RESULT_SUCCESS) {
+                unifi_error(priv, "udi_send_signal_unpacked: failed to allocate request_data.\n");
+                return -EIO;
+            }
+
+            dest = (void*)bulk_data.d[i].os_data_ptr;
+            memcpy(dest, data + bulk_data_offset, bulk_data.d[i].data_length);
+        } else {
+            bulk_data.d[i].data_length = 0;
+        }
+
+        bytecount += bulk_data.d[i].data_length;
+        /* advance the offset, to point the next bulk data */
+        bulk_data_offset += bulk_data.d[i].data_length;
+    }
+
+
+    unifi_trace(priv, UDBG3, "SME Send: signal 0x%.4X\n", sigptr->SignalPrimitiveHeader.SignalId);
+
+    /* Send the signal. */
+    r = ul_send_signal_unpacked(priv, sigptr, &bulk_data);
+    if (r < 0) {
+        unifi_error(priv, "udi_send_signal_unpacked: send failed (%d)\n", r);
+        for(i=0;i<UNIFI_MAX_DATA_REFERENCES;i++) {
+            if(bulk_data.d[i].data_length != 0) {
+                unifi_net_data_free(priv, &bulk_data.d[i]);
+            }
+        }
+        func_exit();
+        return -EIO;
+    }
+
+    return bytecount;
+} /* udi_send_signal_unpacked() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * udi_send_signal_raw
+ *
+ *      Sends a packed signal to UniFi.
+ *
+ * Arguments:
+ *      priv            Pointer to private context struct
+ *      buf             Pointer to request structure and data to send
+ *      buflen          Length of data in data pointer.
+ *
+ * Returns:
+ *      Number of bytes written, error otherwise.
+ *
+ * Notes:
+ *      All clients that use this function to send a signal to the unifi
+ *      must use the wire formatted structures.
+ * ---------------------------------------------------------------------------
+ */
+static int
+udi_send_signal_raw(unifi_priv_t *priv, unsigned char *buf, int buflen)
+{
+    int signal_size;
+    int sig_id;
+    bulk_data_param_t data_ptrs;
+    int i, r;
+    unsigned int num_data_refs;
+    int bytecount;
+    CsrResult csrResult;
+
+    func_enter();
+
+    /*
+     * The signal is the first thing in buf, the signal id is the
+     * first 16 bits of the signal.
+     */
+    /* Number of bytes in the signal */
+    sig_id = GET_SIGNAL_ID(buf);
+    signal_size = buflen;
+    signal_size -= GET_PACKED_DATAREF_LEN(buf, 0);
+    signal_size -= GET_PACKED_DATAREF_LEN(buf, 1);
+    if ((signal_size <= 0) || (signal_size > buflen)) {
+        unifi_error(priv, "udi_send_signal_raw - Couldn't find length of signal 0x%x\n",
+                    sig_id);
+        func_exit();
+        return -EINVAL;
+    }
+    unifi_trace(priv, UDBG2, "udi_send_signal_raw: signal 0x%.4X len:%d\n",
+                sig_id, signal_size);
+    /* Zero the data ref arrays */
+    memset(&data_ptrs, 0, sizeof(data_ptrs));
+
+    /*
+     * Find the number of associated bulk data packets.  Scan through
+     * the data refs to check that we have enough data and pick out
+     * pointers to appended bulk data.
+     */
+    num_data_refs = 0;
+    bytecount = signal_size;
+
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; ++i)
+    {
+        unsigned int len = GET_PACKED_DATAREF_LEN(buf, i);
+        unifi_trace(priv, UDBG3, "udi_send_signal_raw: data_ref length = %d\n", len);
+
+        if (len != 0) {
+            void *dest;
+
+            csrResult = unifi_net_data_malloc(priv, &data_ptrs.d[i], len);
+            if (csrResult != CSR_RESULT_SUCCESS) {
+                unifi_error(priv, "udi_send_signal_raw: failed to allocate request_data.\n");
+                return -EIO;
+            }
+
+            dest = (void*)data_ptrs.d[i].os_data_ptr;
+            memcpy(dest, buf + bytecount, len);
+
+            bytecount += len;
+            num_data_refs++;
+        }
+        data_ptrs.d[i].data_length = len;
+    }
+
+    unifi_trace(priv, UDBG3, "Queueing signal 0x%.4X from UDI with %u data refs\n",
+          sig_id,
+          num_data_refs);
+
+    if (bytecount > buflen) {
+        unifi_error(priv, "udi_send_signal_raw: Not enough data (%d instead of %d)\n", buflen, bytecount);
+        func_exit();
+        return -EINVAL;
+    }
+
+    /* Send the signal calling the function that uses the wire-formatted signals. */
+    r = ul_send_signal_raw(priv, buf, signal_size, &data_ptrs);
+    if (r < 0) {
+        unifi_error(priv, "udi_send_signal_raw: send failed (%d)\n", r);
+        func_exit();
+        return -EIO;
+    }
+
+#ifdef CSR_NATIVE_LINUX
+    if (sig_id == CSR_MLME_POWERMGT_REQUEST_ID) {
+        int power_mode = CSR_GET_UINT16_FROM_LITTLE_ENDIAN((buf +
+                                              SIZEOF_SIGNAL_HEADER + (UNIFI_MAX_DATA_REFERENCES*SIZEOF_DATAREF)));
+#ifdef CSR_SUPPORT_WEXT
+        /* Overide the wext power mode to the new value */
+        priv->wext_conf.power_mode = power_mode;
+#endif
+        /* Configure deep sleep signaling */
+        if (power_mode || (priv->interfacePriv[0]->connected == UnifiNotConnected)) {
+            csrResult = unifi_configure_low_power_mode(priv->card,
+                                                   UNIFI_LOW_POWER_ENABLED,
+                                                   UNIFI_PERIODIC_WAKE_HOST_DISABLED);
+        } else {
+            csrResult = unifi_configure_low_power_mode(priv->card,
+                                                   UNIFI_LOW_POWER_DISABLED,
+                                                   UNIFI_PERIODIC_WAKE_HOST_DISABLED);
+        }
+    }
+#endif
+
+    func_exit_r(bytecount);
+
+    return bytecount;
+} /* udi_send_signal_raw */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_write
+ *
+ *      The write() driver entry point.
+ *      A UniFi Debug Interface client such as unicli can write a signal
+ *      plus bulk data to the driver for sending to the UniFi chip.
+ *
+ *      Only one signal may be sent per write operation.
+ *
+ *  Arguments:
+ *      filp        The file descriptor returned by unifi_open()
+ *      p           The user space buffer to get the data from
+ *      len         The size of the p buffer
+ *      poff
+ *
+ *  Returns:
+ *      number of bytes written or an error code on failure
+ * ---------------------------------------------------------------------------
+ */
+static ssize_t
+unifi_write(struct file *filp, const char *p, size_t len, loff_t *poff)
+{
+    ul_client_t *pcli = (ul_client_t*)filp->private_data;
+    unifi_priv_t *priv;
+    unsigned char *buf;
+    unsigned char *bufptr;
+    int remaining;
+    int bytes_written;
+    int r;
+    bulk_data_param_t bulkdata;
+    CsrResult csrResult;
+
+    func_enter();
+
+    priv = uf_find_instance(pcli->instance);
+    if (!priv) {
+        unifi_error(priv, "invalid priv\n");
+        return -ENODEV;
+    }
+
+    unifi_trace(priv, UDBG5, "unifi_write: len = %d\n", len);
+
+    if (!pcli->udi_enabled) {
+        unifi_error(priv, "udi disabled\n");
+        return -EINVAL;
+    }
+
+    /*
+     * AMP client sends only one signal at a time, so we can use
+     * unifi_net_data_malloc to save the extra copy.
+     */
+    if (pcli == priv->amp_client) {
+        int signal_size;
+        int sig_id;
+        unsigned char *signal_buf;
+        char *user_data_buf;
+
+        csrResult = unifi_net_data_malloc(priv, &bulkdata.d[0], len);
+        if (csrResult != CSR_RESULT_SUCCESS) {
+            unifi_error(priv, "unifi_write: failed to allocate request_data.\n");
+            func_exit();
+            return -ENOMEM;
+        }
+
+        user_data_buf = (char*)bulkdata.d[0].os_data_ptr;
+
+        /* Get the data from the AMP client. */
+        if (copy_from_user((void*)user_data_buf, p, len)) {
+            unifi_error(priv, "unifi_write: copy from user failed\n");
+            unifi_net_data_free(priv, &bulkdata.d[0]);
+            func_exit();
+            return -EFAULT;
+        }
+
+        bulkdata.d[1].os_data_ptr = NULL;
+        bulkdata.d[1].data_length = 0;
+
+        /* Number of bytes in the signal */
+        sig_id = GET_SIGNAL_ID(bulkdata.d[0].os_data_ptr);
+        signal_size = len;
+        signal_size -= GET_PACKED_DATAREF_LEN(bulkdata.d[0].os_data_ptr, 0);
+        signal_size -= GET_PACKED_DATAREF_LEN(bulkdata.d[0].os_data_ptr, 1);
+        if ((signal_size <= 0) || (signal_size > len)) {
+            unifi_error(priv, "unifi_write - Couldn't find length of signal 0x%x\n",
+                        sig_id);
+            unifi_net_data_free(priv, &bulkdata.d[0]);
+            func_exit();
+            return -EINVAL;
+        }
+
+        unifi_trace(priv, UDBG2, "unifi_write: signal 0x%.4X len:%d\n",
+                    sig_id, signal_size);
+
+        /* Allocate a buffer for the signal */
+        signal_buf = kmalloc(signal_size, GFP_KERNEL);
+        if (!signal_buf) {
+            unifi_net_data_free(priv, &bulkdata.d[0]);
+            func_exit();
+            return -ENOMEM;
+        }
+
+        /* Get the signal from the os_data_ptr */
+        memcpy(signal_buf, bulkdata.d[0].os_data_ptr, signal_size);
+        signal_buf[5] = (pcli->sender_id >> 8) & 0xff;
+
+        if (signal_size < len) {
+            /* Remove the signal from the os_data_ptr */
+            bulkdata.d[0].data_length -= signal_size;
+            bulkdata.d[0].os_data_ptr += signal_size;
+        } else {
+            bulkdata.d[0].data_length = 0;
+            bulkdata.d[0].os_data_ptr = NULL;
+        }
+
+        /* Send the signal calling the function that uses the wire-formatted signals. */
+        r = ul_send_signal_raw(priv, signal_buf, signal_size, &bulkdata);
+        if (r < 0) {
+            unifi_error(priv, "unifi_write: send failed (%d)\n", r);
+            if (bulkdata.d[0].os_data_ptr != NULL) {
+                unifi_net_data_free(priv, &bulkdata.d[0]);
+            }
+        }
+
+        /* Free the signal buffer and return */
+        kfree(signal_buf);
+        return len;
+    }
+
+    buf = kmalloc(len, GFP_KERNEL);
+    if (!buf) {
+        return -ENOMEM;
+    }
+
+    /* Get the data from the client (SME or Unicli). */
+    if (copy_from_user((void*)buf, p, len)) {
+        unifi_error(priv, "copy from user failed\n");
+        kfree(buf);
+        return -EFAULT;
+    }
+
+    /*
+     * In SME userspace build read() contains a SYS or MGT message.
+     * Note that even though the SME sends one signal at a time, we can not
+     * use unifi_net_data_malloc because in the early stages, before having
+     * initialised the core, it will fail since the I/O block size is unknown.
+     */
+#ifdef CSR_SME_USERSPACE
+    if (pcli->configuration & CLI_SME_USERSPACE) {
+        CsrWifiRouterTransportRecv(priv, buf, len);
+        kfree(buf);
+        return len;
+    }
+#endif
+
+    /* ul_send_signal_raw will  do a sanity check of len against signal content */
+
+    /*
+     * udi_send_signal_raw() and udi_send_signal_unpacked() return the number of bytes consumed.
+     * A write call can pass multiple signal concatenated together.
+     */
+    bytes_written = 0;
+    remaining = len;
+    bufptr = buf;
+    while (remaining > 0)
+    {
+        int r;
+
+        /*
+         * Set the SenderProcessId.
+         * The SignalPrimitiveHeader is the first 3 16-bit words of the signal,
+         * the SenderProcessId is bytes 4,5.
+         * The MSB of the sender ID needs to be set to the client ID.
+         * The LSB is controlled by the SME.
+         */
+        bufptr[5] = (pcli->sender_id >> 8) & 0xff;
+
+        /* use the appropriate interface, depending on the clients' configuration */
+        if (pcli->configuration & CLI_USING_WIRE_FORMAT) {
+            unifi_trace(priv, UDBG1, "unifi_write: call udi_send_signal().\n");
+            r = udi_send_signal_raw(priv, bufptr, remaining);
+        } else {
+            r = udi_send_signal_unpacked(priv, bufptr, remaining);
+        }
+        if (r < 0) {
+            /* Set the return value to the error code */
+            unifi_error(priv, "unifi_write: (udi or sme)_send_signal() returns %d\n", r);
+            bytes_written = r;
+            break;
+        }
+        bufptr += r;
+        remaining -= r;
+        bytes_written += r;
+    }
+
+    kfree(buf);
+
+    func_exit_r(bytes_written);
+
+    return bytes_written;
+} /* unifi_write() */
+
+
+static const char* build_type_to_string(unsigned char build_type)
+{
+    switch (build_type)
+    {
+    case UNIFI_BUILD_NME: return "NME";
+    case UNIFI_BUILD_WEXT: return "WEXT";
+    case UNIFI_BUILD_AP: return "AP";
+    }
+    return "unknown";
+}
+
+
+/*
+ * ----------------------------------------------------------------
+ *  unifi_ioctl
+ *
+ *      Ioctl handler for unifi driver.
+ *
+ * Arguments:
+ *  inodep          Pointer to inode structure.
+ *  filp            Pointer to file structure.
+ *  cmd             Ioctl cmd passed by user.
+ *  arg             Ioctl arg passed by user.
+ *
+ * Returns:
+ *      0 on success, -ve error code on error.
+ * ----------------------------------------------------------------
+ */
+static long
+unifi_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    ul_client_t *pcli = (ul_client_t*)filp->private_data;
+    unifi_priv_t *priv;
+    struct net_device *dev;
+    int r = 0;
+    int int_param, i;
+    u8* buf;
+    CsrResult csrResult;
+#if (defined CSR_SUPPORT_SME)
+    unifi_cfg_command_t cfg_cmd;
+#if (defined CSR_SUPPORT_WEXT)
+    CsrWifiSmeCoexConfig coex_config;
+    unsigned char uchar_param;
+    unsigned char varbind[MAX_VARBIND_LENGTH];
+    int vblen;
+#endif
+#endif
+    unifi_putest_command_t putest_cmd;
+
+    priv = uf_find_instance(pcli->instance);
+    if (!priv) {
+        unifi_error(priv, "ioctl error: unknown instance=%d\n", pcli->instance);
+        r = -ENODEV;
+        goto out;
+    }
+    unifi_trace(priv, UDBG5, "unifi_ioctl: cmd=0x%X, arg=0x%lX\n", cmd, arg);
+
+    switch (cmd) {
+
+      case UNIFI_GET_UDI_ENABLE:
+        unifi_trace(priv, UDBG4, "UniFi Get UDI Enable\n");
+
+        down(&priv->udi_logging_mutex);
+        int_param = (priv->logging_client == NULL) ? 0 : 1;
+        up(&priv->udi_logging_mutex);
+
+        if (put_user(int_param, (int*)arg))
+        {
+            unifi_error(priv, "UNIFI_GET_UDI_ENABLE: Failed to copy to user\n");
+            r = -EFAULT;
+            goto out;
+        }
+        break;
+
+      case UNIFI_SET_UDI_ENABLE:
+        unifi_trace(priv, UDBG4, "UniFi Set UDI Enable\n");
+        if (get_user(int_param, (int*)arg))
+        {
+            unifi_error(priv, "UNIFI_SET_UDI_ENABLE: Failed to copy from user\n");
+            r = -EFAULT;
+            goto out;
+        }
+
+        down(&priv->udi_logging_mutex);
+        if (int_param) {
+            pcli->event_hook = udi_log_event;
+            unifi_set_udi_hook(priv->card, logging_handler);
+            /* Log all signals by default */
+            for (i = 0; i < SIG_FILTER_SIZE; i++) {
+                pcli->signal_filter[i] = 0xFFFF;
+            }
+            priv->logging_client = pcli;
+
+        } else {
+            priv->logging_client = NULL;
+            pcli->event_hook = NULL;
+        }
+        up(&priv->udi_logging_mutex);
+
+        break;
+
+      case UNIFI_SET_MIB:
+        unifi_trace(priv, UDBG4, "UniFi Set MIB\n");
+#if (defined CSR_SUPPORT_SME) && (defined CSR_SUPPORT_WEXT)
+        /* Read first 2 bytes and check length */
+        if (copy_from_user((void*)varbind, (void*)arg, 2)) {
+            unifi_error(priv,
+                        "UNIFI_SET_MIB: Failed to copy in varbind header\n");
+            r = -EFAULT;
+            goto out;
+        }
+        vblen = varbind[1];
+        if ((vblen + 2) > MAX_VARBIND_LENGTH) {
+            unifi_error(priv,
+                        "UNIFI_SET_MIB: Varbind too long (%d, limit %d)\n",
+                        (vblen+2), MAX_VARBIND_LENGTH);
+            r = -EINVAL;
+            goto out;
+        }
+        /* Read rest of varbind */
+        if (copy_from_user((void*)(varbind+2), (void*)(arg+2), vblen)) {
+            unifi_error(priv, "UNIFI_SET_MIB: Failed to copy in varbind\n");
+            r = -EFAULT;
+            goto out;
+        }
+
+        /* send to SME */
+        vblen += 2;
+        r = sme_mgt_mib_set(priv, varbind, vblen);
+        if (r) {
+            goto out;
+        }
+#else
+        unifi_notice(priv, "UNIFI_SET_MIB: Unsupported.\n");
+#endif /* CSR_SUPPORT_WEXT */
+        break;
+
+      case UNIFI_GET_MIB:
+        unifi_trace(priv, UDBG4, "UniFi Get MIB\n");
+#if (defined CSR_SUPPORT_SME) && (defined CSR_SUPPORT_WEXT)
+        /* Read first 2 bytes and check length */
+        if (copy_from_user((void*)varbind, (void*)arg, 2)) {
+            unifi_error(priv, "UNIFI_GET_MIB: Failed to copy in varbind header\n");
+            r = -EFAULT;
+            goto out;
+        }
+        vblen = varbind[1];
+        if ((vblen+2) > MAX_VARBIND_LENGTH) {
+            unifi_error(priv, "UNIFI_GET_MIB: Varbind too long (%d, limit %d)\n",
+                        (vblen+2), MAX_VARBIND_LENGTH);
+            r = -EINVAL;
+            goto out;
+        }
+        /* Read rest of varbind */
+        if (copy_from_user((void*)(varbind+2), (void*)(arg+2), vblen)) {
+            unifi_error(priv, "UNIFI_GET_MIB: Failed to copy in varbind\n");
+            r = -EFAULT;
+            goto out;
+        }
+
+        vblen += 2;
+        r = sme_mgt_mib_get(priv, varbind, &vblen);
+        if (r) {
+            goto out;
+        }
+        /* copy out varbind */
+        if (vblen > MAX_VARBIND_LENGTH) {
+            unifi_error(priv,
+                        "UNIFI_GET_MIB: Varbind result too long (%d, limit %d)\n",
+                        vblen, MAX_VARBIND_LENGTH);
+            r = -EINVAL;
+            goto out;
+        }
+        if (copy_to_user((void*)arg, varbind, vblen)) {
+            r = -EFAULT;
+            goto out;
+        }
+#else
+        unifi_notice(priv, "UNIFI_GET_MIB: Unsupported.\n");
+#endif /* CSR_SUPPORT_WEXT */
+        break;
+
+      case UNIFI_CFG:
+#if (defined CSR_SUPPORT_SME)
+        if (get_user(cfg_cmd, (unifi_cfg_command_t*)arg))
+        {
+            unifi_error(priv, "UNIFI_CFG: Failed to get the command\n");
+            r = -EFAULT;
+            goto out;
+        }
+
+        unifi_trace(priv, UDBG1, "UNIFI_CFG: Command is %d (t=%u) sz=%d\n",
+                    cfg_cmd, jiffies_to_msecs(jiffies), sizeof(unifi_cfg_command_t));
+        switch (cfg_cmd) {
+          case UNIFI_CFG_POWER:
+            r = unifi_cfg_power(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_CFG_POWERSAVE:
+            r = unifi_cfg_power_save(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_CFG_POWERSUPPLY:
+            r = unifi_cfg_power_supply(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_CFG_FILTER:
+            r = unifi_cfg_packet_filters(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_CFG_GET:
+            r = unifi_cfg_get_info(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_CFG_WMM_QOSINFO:
+            r = unifi_cfg_wmm_qos_info(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_CFG_WMM_ADDTS:
+            r = unifi_cfg_wmm_addts(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_CFG_WMM_DELTS:
+            r = unifi_cfg_wmm_delts(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_CFG_STRICT_DRAFT_N:
+            r = unifi_cfg_strict_draft_n(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_CFG_ENABLE_OKC:
+            r = unifi_cfg_enable_okc(priv, (unsigned char*)arg);
+            break;
+#ifdef CSR_SUPPORT_SME
+          case UNIFI_CFG_CORE_DUMP:
+            CsrWifiRouterCtrlWifiOffIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,CSR_WIFI_SME_CONTROL_INDICATION_ERROR);
+            unifi_trace(priv, UDBG2, "UNIFI_CFG_CORE_DUMP: sent wifi off indication\n");
+            break;
+#endif
+#ifdef CSR_SUPPORT_WEXT_AP
+          case UNIFI_CFG_SET_AP_CONFIG:
+            r= unifi_cfg_set_ap_config(priv,(unsigned char*)arg);
+            break;
+#endif
+          default:
+            unifi_error(priv, "UNIFI_CFG: Unknown Command (%d)\n", cfg_cmd);
+            r = -EINVAL;
+            goto out;
+        }
+#endif
+
+        break;
+
+      case UNIFI_PUTEST:
+        if (get_user(putest_cmd, (unifi_putest_command_t*)arg))
+        {
+            unifi_error(priv, "UNIFI_PUTEST: Failed to get the command\n");
+            r = -EFAULT;
+            goto out;
+        }
+
+        unifi_trace(priv, UDBG1, "UNIFI_PUTEST: Command is %s\n",
+                    trace_putest_cmdid(putest_cmd));
+        switch (putest_cmd) {
+          case UNIFI_PUTEST_START:
+            r = unifi_putest_start(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_PUTEST_STOP:
+            r = unifi_putest_stop(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_PUTEST_SET_SDIO_CLOCK:
+            r = unifi_putest_set_sdio_clock(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_PUTEST_CMD52_READ:
+            r = unifi_putest_cmd52_read(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_PUTEST_CMD52_BLOCK_READ:
+            r = unifi_putest_cmd52_block_read(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_PUTEST_CMD52_WRITE:
+            r = unifi_putest_cmd52_write(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_PUTEST_DL_FW:
+            r = unifi_putest_dl_fw(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_PUTEST_DL_FW_BUFF:
+            r = unifi_putest_dl_fw_buff(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_PUTEST_COREDUMP_PREPARE:
+            r = unifi_putest_coredump_prepare(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_PUTEST_GP_READ16:
+            r = unifi_putest_gp_read16(priv, (unsigned char*)arg);
+            break;
+          case UNIFI_PUTEST_GP_WRITE16:
+            r = unifi_putest_gp_write16(priv, (unsigned char*)arg);
+            break;
+          default:
+            unifi_error(priv, "UNIFI_PUTEST: Unknown Command (%d)\n", putest_cmd);
+            r = -EINVAL;
+            goto out;
+        }
+
+        break;
+      case UNIFI_BUILD_TYPE:
+        unifi_trace(priv, UDBG2, "UNIFI_BUILD_TYPE userspace=%s\n", build_type_to_string(*(unsigned char*)arg));
+#ifndef CSR_SUPPORT_WEXT_AP
+        if (UNIFI_BUILD_AP == *(unsigned char*)arg)
+        {
+            unifi_error(priv, "Userspace has AP support, which is incompatible\n");
+        }
+#endif
+
+#ifndef CSR_SUPPORT_WEXT
+        if (UNIFI_BUILD_WEXT == *(unsigned char*)arg)
+        {
+            unifi_error(priv, "Userspace has WEXT support, which is incompatible\n");
+        }
+#endif
+        break;
+      case UNIFI_INIT_HW:
+        unifi_trace(priv, UDBG2, "UNIFI_INIT_HW.\n");
+        priv->init_progress = UNIFI_INIT_NONE;
+
+#if defined(CSR_SUPPORT_WEXT) || defined (CSR_NATIVE_LINUX)
+        /* At this point we are ready to start the SME. */
+        r = sme_mgt_wifi_on(priv);
+        if (r) {
+            goto out;
+        }
+#endif
+
+        break;
+
+      case UNIFI_INIT_NETDEV:
+        {
+            /* get the proper interfaceTagId */
+            CsrUint16 interfaceTag=0;
+            netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+            dev = priv->netdev[interfaceTag];
+            unifi_trace(priv, UDBG2, "UNIFI_INIT_NETDEV.\n");
+
+            if (copy_from_user((void*)dev->dev_addr, (void*)arg, 6)) {
+                r = -EFAULT;
+                goto out;
+            }
+
+            /* Attach the network device to the stack */
+            if (!interfacePriv->netdev_registered)
+            {
+                r = uf_register_netdev(priv,interfaceTag);
+                if (r) {
+                    unifi_error(priv, "Failed to register the network device.\n");
+                    goto out;
+                }
+            }
+
+            /* Apply scheduled interrupt mode, if requested by module param */
+            if (run_bh_once != -1) {
+                unifi_set_interrupt_mode(priv->card, (CsrUint32)run_bh_once);
+            }
+
+            priv->init_progress = UNIFI_INIT_COMPLETED;
+
+            /* Firmware initialisation is complete, so let the SDIO bus
+             * clock be raised when convienent to the core.
+             */
+            unifi_request_max_sdio_clock(priv->card);
+
+#ifdef CSR_SUPPORT_WEXT
+            /* Notify the Android wpa_supplicant that we are ready */
+            wext_send_started_event(priv);
+#endif
+
+            unifi_info(priv, "UniFi ready\n");
+
+#ifdef CSR_NATIVE_SOFTMAC /* For softmac dev, force-enable the network interface rather than wait for a connected-ind */
+            {
+                struct net_device *dev = priv->netdev[interfaceTag];
+#ifdef CSR_SUPPORT_WEXT
+                interfacePriv->wait_netdev_change = TRUE;
+#endif
+                netif_carrier_on(dev);
+            }
+#endif
+        }
+        break;
+      case UNIFI_GET_INIT_STATUS:
+        unifi_trace(priv, UDBG2, "UNIFI_GET_INIT_STATUS.\n");
+        if (put_user(priv->init_progress, (int*)arg))
+        {
+            printk(KERN_ERR "UNIFI_GET_INIT_STATUS: Failed to copy to user\n");
+            r = -EFAULT;
+            goto out;
+        }
+        break;
+
+      case UNIFI_KICK:
+        unifi_trace(priv, UDBG4, "Kick UniFi\n");
+        unifi_sdio_interrupt_handler(priv->card);
+        break;
+
+      case UNIFI_SET_DEBUG:
+        unifi_debug = arg;
+        unifi_trace(priv, UDBG4, "unifi_debug set to %d\n", unifi_debug);
+        break;
+
+      case UNIFI_SET_TRACE:
+        /* no longer supported */
+        r = -EINVAL;
+        break;
+
+
+      case UNIFI_SET_UDI_LOG_MASK:
+        {
+            unifiio_filter_t udi_filter;
+            uint16_t *sig_ids_addr;
+#define UF_MAX_SIG_IDS  128     /* Impose a sensible limit */
+
+            if (copy_from_user((void*)(&udi_filter), (void*)arg, sizeof(udi_filter))) {
+                r = -EFAULT;
+                goto out;
+            }
+            if ((udi_filter.action < UfSigFil_AllOn) ||
+                (udi_filter.action > UfSigFil_SelectOff))
+            {
+                printk(KERN_WARNING
+                       "UNIFI_SET_UDI_LOG_MASK: Bad action value: %d\n",
+                       udi_filter.action);
+                r = -EINVAL;
+                goto out;
+            }
+            /* No signal list for "All" actions */
+            if ((udi_filter.action == UfSigFil_AllOn) ||
+                (udi_filter.action == UfSigFil_AllOff))
+            {
+                udi_filter.num_sig_ids = 0;
+            }
+
+            if (udi_filter.num_sig_ids > UF_MAX_SIG_IDS) {
+                printk(KERN_WARNING
+                       "UNIFI_SET_UDI_LOG_MASK: too many signal ids (%d, max %d)\n",
+                       udi_filter.num_sig_ids, UF_MAX_SIG_IDS);
+                r = -EINVAL;
+                goto out;
+            }
+
+            /* Copy in signal id list if given */
+            if (udi_filter.num_sig_ids > 0) {
+                /* Preserve userspace address of sig_ids array */
+                sig_ids_addr = udi_filter.sig_ids;
+                /* Allocate kernel memory for sig_ids and copy to it */
+                udi_filter.sig_ids =
+                    kmalloc(udi_filter.num_sig_ids * sizeof(uint16_t), GFP_KERNEL);
+                if (!udi_filter.sig_ids) {
+                    r = -ENOMEM;
+                    goto out;
+                }
+                if (copy_from_user((void*)udi_filter.sig_ids,
+                                   (void*)sig_ids_addr,
+                                   udi_filter.num_sig_ids * sizeof(uint16_t)))
+                {
+                    kfree(udi_filter.sig_ids);
+                    r = -EFAULT;
+                    goto out;
+                }
+            }
+
+            udi_set_log_filter(pcli, &udi_filter);
+
+            if (udi_filter.num_sig_ids > 0) {
+                kfree(udi_filter.sig_ids);
+            }
+        }
+        break;
+
+      case UNIFI_SET_AMP_ENABLE:
+        unifi_trace(priv, UDBG4, "UniFi Set AMP Enable\n");
+        if (get_user(int_param, (int*)arg))
+        {
+            unifi_error(priv, "UNIFI_SET_AMP_ENABLE: Failed to copy from user\n");
+            r = -EFAULT;
+            goto out;
+        }
+
+        if (int_param) {
+            priv->amp_client = pcli;
+        } else {
+            priv->amp_client = NULL;
+        }
+
+        int_param = 0;
+        buf = (u8*)&int_param;
+        buf[0] = UNIFI_SOFT_COMMAND_Q_LENGTH - 1;
+        buf[1] = UNIFI_SOFT_TRAFFIC_Q_LENGTH - 1;
+        if (copy_to_user((void*)arg, &int_param, sizeof(int))) {
+            r = -EFAULT;
+            goto out;
+        }
+        break;
+
+      case UNIFI_SET_UDI_SNAP_MASK:
+        {
+            unifiio_snap_filter_t snap_filter;
+
+            if (copy_from_user((void*)(&snap_filter), (void*)arg, sizeof(snap_filter))) {
+                r = -EFAULT;
+                goto out;
+            }
+
+            if (pcli->snap_filter.count) {
+                pcli->snap_filter.count = 0;
+                CsrPmemFree(pcli->snap_filter.protocols);
+            }
+
+            if (snap_filter.count == 0) {
+                break;
+            }
+
+            pcli->snap_filter.protocols = CsrPmemAlloc(snap_filter.count * sizeof(CsrUint16));
+            if (!pcli->snap_filter.protocols) {
+                r = -ENOMEM;
+                goto out;
+            }
+            if (copy_from_user((void*)pcli->snap_filter.protocols,
+                               (void*)snap_filter.protocols,
+                               snap_filter.count * sizeof(CsrUint16)))
+            {
+                CsrPmemFree(pcli->snap_filter.protocols);
+                r = -EFAULT;
+                goto out;
+            }
+
+            pcli->snap_filter.count = snap_filter.count;
+
+        }
+        break;
+
+      case UNIFI_SME_PRESENT:
+        {
+            u8 ind;
+            unifi_trace(priv, UDBG4, "UniFi SME Present IOCTL.\n");
+            if (copy_from_user((void*)(&int_param), (void*)arg, sizeof(int)))
+            {
+                printk(KERN_ERR "UNIFI_SME_PRESENT: Failed to copy from user\n");
+                r = -EFAULT;
+                goto out;
+            }
+
+            priv->sme_is_present = int_param;
+            if (priv->sme_is_present == 1) {
+                ind = CONFIG_SME_PRESENT;
+            } else {
+                ind = CONFIG_SME_NOT_PRESENT;
+            }
+            /* Send an indication to the helper app. */
+            ul_log_config_ind(priv, &ind, sizeof(u8));
+        }
+        break;
+
+      case UNIFI_CFG_PERIOD_TRAFFIC:
+      {
+#if (defined CSR_SUPPORT_SME) && (defined CSR_SUPPORT_WEXT)
+          CsrWifiSmeCoexConfig coexConfig;
+#endif /* CSR_SUPPORT_SME && CSR_SUPPORT_WEXT */
+        unifi_trace(priv, UDBG4, "UniFi Configure Periodic Traffic.\n");
+#if (defined CSR_SUPPORT_SME) && (defined CSR_SUPPORT_WEXT)
+        if (copy_from_user((void*)(&uchar_param), (void*)arg, sizeof(unsigned char))) {
+            unifi_error(priv, "UNIFI_CFG_PERIOD_TRAFFIC: Failed to copy from user\n");
+            r = -EFAULT;
+            goto out;
+        }
+
+        if (uchar_param == 0) {
+            r = sme_mgt_coex_config_get(priv, &coexConfig);
+            if (r) {
+                unifi_error(priv, "UNIFI_CFG_PERIOD_TRAFFIC: Get unifi_CoexInfoValue failed.\n");
+                goto out;
+            }
+            if (copy_to_user((void*)(arg + 1),
+                             (void*)&coexConfig,
+                             sizeof(CsrWifiSmeCoexConfig))) {
+                r = -EFAULT;
+                goto out;
+            }
+            goto out;
+        }
+
+        if (copy_from_user((void*)(&coex_config), (void*)(arg + 1), sizeof(CsrWifiSmeCoexConfig)))
+        {
+            unifi_error(priv, "UNIFI_CFG_PERIOD_TRAFFIC: Failed to copy from user\n");
+            r = -EFAULT;
+            goto out;
+        }
+
+        coexConfig = coex_config;
+        r = sme_mgt_coex_config_set(priv, &coexConfig);
+        if (r) {
+            unifi_error(priv, "UNIFI_CFG_PERIOD_TRAFFIC: Set unifi_CoexInfoValue failed.\n");
+            goto out;
+        }
+
+#endif /* CSR_SUPPORT_SME && CSR_SUPPORT_WEXT */
+        break;
+      }
+      case UNIFI_CFG_UAPSD_TRAFFIC:
+        unifi_trace(priv, UDBG4, "UniFi Configure U-APSD Mask.\n");
+#if (defined CSR_SUPPORT_SME) && (defined CSR_SUPPORT_WEXT)
+        if (copy_from_user((void*)(&uchar_param), (void*)arg, sizeof(unsigned char))) {
+            unifi_error(priv, "UNIFI_CFG_UAPSD_TRAFFIC: Failed to copy from user\n");
+            r = -EFAULT;
+            goto out;
+        }
+        unifi_trace(priv, UDBG4, "New U-APSD Mask: 0x%x\n", uchar_param);
+#endif /* CSR_SUPPORT_SME && CSR_SUPPORT_WEXT */
+        break;
+
+#ifndef UNIFI_DISABLE_COREDUMP
+      case UNIFI_COREDUMP_GET_REG:
+        unifi_trace(priv, UDBG4, "Mini-coredump data request\n");
+        {
+            unifiio_coredump_req_t dump_req;    /* Public OS layer structure */
+            unifi_coredump_req_t priv_req;      /* Private HIP structure */
+
+            if (copy_from_user((void*)(&dump_req), (void*)arg, sizeof(dump_req))) {
+                r = -EFAULT;
+                goto out;
+            }
+            memset(&priv_req, 0, sizeof(priv_req));
+            priv_req.index = dump_req.index;
+            priv_req.offset = dump_req.offset;
+
+            /* Convert OS-layer's XAP memory space ID to HIP's ID in case they differ */
+            switch (dump_req.space) {
+                case UNIFIIO_COREDUMP_MAC_REG: priv_req.space = UNIFI_COREDUMP_MAC_REG; break;
+                case UNIFIIO_COREDUMP_PHY_REG: priv_req.space = UNIFI_COREDUMP_PHY_REG; break;
+                case UNIFIIO_COREDUMP_SH_DMEM: priv_req.space = UNIFI_COREDUMP_SH_DMEM; break;
+                case UNIFIIO_COREDUMP_MAC_DMEM: priv_req.space = UNIFI_COREDUMP_MAC_DMEM; break;
+                case UNIFIIO_COREDUMP_PHY_DMEM: priv_req.space = UNIFI_COREDUMP_PHY_DMEM; break;
+                case UNIFIIO_COREDUMP_TRIGGER_MAGIC: priv_req.space = UNIFI_COREDUMP_TRIGGER_MAGIC; break;
+                default:
+                  r = -EINVAL;
+                  goto out;
+            }
+
+            if (priv_req.space == UNIFI_COREDUMP_TRIGGER_MAGIC) {
+                /* Force a coredump grab now */
+                unifi_trace(priv, UDBG2, "UNIFI_COREDUMP_GET_REG: Force capture\n");
+                csrResult = unifi_coredump_capture(priv->card, &priv_req);
+                r = CsrHipResultToStatus(csrResult);
+                unifi_trace(priv, UDBG5, "UNIFI_COREDUMP_GET_REG: status %d\n", r);
+            } else {
+                /* Retrieve the appropriate register entry */
+                csrResult = unifi_coredump_get_value(priv->card, &priv_req);
+                r = CsrHipResultToStatus(csrResult);
+                if (r) {
+                    unifi_trace(priv, UDBG5, "UNIFI_COREDUMP_GET_REG: Status %d\n", r);
+                    goto out;
+                }
+                /* Update the OS-layer structure with values returned in the private */
+                dump_req.value = priv_req.value;
+                dump_req.timestamp = priv_req.timestamp;
+                dump_req.requestor = priv_req.requestor;
+                dump_req.serial = priv_req.serial;
+                dump_req.chip_ver = priv_req.chip_ver;
+                dump_req.fw_ver = priv_req.fw_ver;
+                dump_req.drv_build = 0;
+
+                unifi_trace(priv, UDBG6,
+                            "Dump: %d (seq %d): V:0x%04x (%d) @0x%02x:%04x = 0x%04x\n",
+                            dump_req.index, dump_req.serial,
+                            dump_req.chip_ver, dump_req.drv_build,
+                            dump_req.space, dump_req.offset, dump_req.value);
+            }
+            if (copy_to_user((void*)arg, (void*)&dump_req, sizeof(dump_req))) {
+                r = -EFAULT;
+                goto out;
+            }
+        }
+        break;
+#endif
+      default:
+        r = -EINVAL;
+    }
+
+out:
+    return (long)r;
+} /* unifi_ioctl() */
+
+
+
+static unsigned int
+unifi_poll(struct file *filp, poll_table *wait)
+{
+    ul_client_t *pcli = (ul_client_t*)filp->private_data;
+    unsigned int mask = 0;
+    int ready;
+
+    func_enter();
+
+    ready = !list_empty(&pcli->udi_log);
+
+    poll_wait(filp, &pcli->udi_wq, wait);
+
+    if (ready) {
+        mask |= POLLIN | POLLRDNORM;    /* readable */
+    }
+
+    func_exit();
+
+    return mask;
+} /* unifi_poll() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  udi_set_log_filter
+ *
+ *      Configure the bit mask that determines which signal primitives are
+ *      passed to the logging process.
+ *
+ *  Arguments:
+ *      pcli            Pointer to the client to configure.
+ *      udi_filter      Pointer to a unifiio_filter_t containing instructions.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *      SigGetFilterPos() returns a 32-bit value that contains an index and a
+ *      mask for accessing a signal_filter array. The top 16 bits specify an
+ *      index into a signal_filter, the bottom 16 bits specify a mask to
+ *      apply.
+ * ---------------------------------------------------------------------------
+ */
+static void
+udi_set_log_filter(ul_client_t *pcli, unifiio_filter_t *udi_filter)
+{
+    CsrUint32 filter_pos;
+    int i;
+
+    if (udi_filter->action == UfSigFil_AllOn)
+    {
+        for (i = 0; i < SIG_FILTER_SIZE; i++) {
+            pcli->signal_filter[i] = 0xFFFF;
+        }
+    }
+    else if (udi_filter->action == UfSigFil_AllOff)
+    {
+        for (i = 0; i < SIG_FILTER_SIZE; i++) {
+            pcli->signal_filter[i] = 0;
+        }
+    }
+    else if (udi_filter->action == UfSigFil_SelectOn)
+    {
+        for (i = 0; i < udi_filter->num_sig_ids; i++) {
+            filter_pos = SigGetFilterPos(udi_filter->sig_ids[i]);
+            if (filter_pos == 0xFFFFFFFF)
+            {
+                printk(KERN_WARNING
+                       "Unrecognised signal id (0x%X) specifed in logging filter\n",
+                       udi_filter->sig_ids[i]);
+            } else {
+                pcli->signal_filter[filter_pos >> 16] |= (filter_pos & 0xFFFF);
+            }
+        }
+    }
+    else if (udi_filter->action == UfSigFil_SelectOff)
+    {
+        for (i = 0; i < udi_filter->num_sig_ids; i++) {
+            filter_pos = SigGetFilterPos(udi_filter->sig_ids[i]);
+            if (filter_pos == 0xFFFFFFFF)
+            {
+                printk(KERN_WARNING
+                       "Unrecognised signal id (0x%X) specifed in logging filter\n",
+                       udi_filter->sig_ids[i]);
+            } else {
+                pcli->signal_filter[filter_pos >> 16] &= ~(filter_pos & 0xFFFF);
+            }
+        }
+    }
+
+} /* udi_set_log_filter() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  udi_log_event
+ *
+ *      Callback function to be registered as the UDI hook callback.
+ *      Copies the signal content into a new udi_log_t struct and adds
+ *      it to the read queue for this UDI client.
+ *
+ *  Arguments:
+ *      pcli            A pointer to the client instance.
+ *      signal          Pointer to the received signal.
+ *      signal_len      Size of the signal structure in bytes.
+ *      bulkdata        Pointers to any associated bulk data.
+ *      dir             Direction of the signal. Zero means from host,
+ *                      non-zero means to host.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+udi_log_event(ul_client_t *pcli,
+              const u8 *signal, int signal_len,
+              const bulk_data_param_t *bulkdata,
+              int dir)
+{
+    udi_log_t *logptr;
+    u8 *p;
+    int i;
+    int total_len;
+    udi_msg_t *msgptr;
+    CsrUint32 filter_pos;
+#ifdef OMNICLI_LINUX_EXTRA_LOG
+    static volatile unsigned int printk_cpu = UINT_MAX;
+    unsigned long long t;
+    unsigned long nanosec_rem;
+    unsigned long n_1000;
+#endif
+
+    func_enter();
+
+    /* Just a sanity check */
+    if ((signal == NULL) || (signal_len <= 0)) {
+        return;
+    }
+
+#ifdef CSR_NATIVE_LINUX
+    uf_native_process_udi_signal(pcli, signal, signal_len, bulkdata, dir);
+#endif
+
+    /*
+     * Apply the logging filter - only report signals that have their
+     * bit set in the filter mask.
+     */
+    filter_pos = SigGetFilterPos(GET_SIGNAL_ID(signal));
+
+    if ((filter_pos != 0xFFFFFFFF) &&
+        ((pcli->signal_filter[filter_pos >> 16] & (filter_pos & 0xFFFF)) == 0))
+    {
+        /* Signal is not wanted by client */
+        return;
+    }
+
+
+    /* Calculate the buffer we need to store signal plus bulk data */
+    total_len = signal_len;
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+        total_len += bulkdata->d[i].data_length;
+    }
+
+    /* Allocate log structure plus actual signal. */
+    logptr = (udi_log_t *)kmalloc(sizeof(udi_log_t) + total_len, GFP_KERNEL);
+
+    if (logptr == NULL) {
+        printk(KERN_ERR
+               "Failed to allocate %lu bytes for a UDI log record\n",
+               (long unsigned int)(sizeof(udi_log_t) + total_len));
+        return;
+    }
+
+    /* Fill in udi_log struct */
+    INIT_LIST_HEAD(&logptr->q);
+    msgptr = &logptr->msg;
+    msgptr->length = sizeof(udi_msg_t) + total_len;
+#ifdef OMNICLI_LINUX_EXTRA_LOG
+    t = cpu_clock(printk_cpu);
+    nanosec_rem = do_div(t, 1000000000);
+    n_1000 = nanosec_rem/1000;
+    msgptr->timestamp = (t <<10 ) | ((unsigned long)(n_1000 >> 10) & 0x3ff);
+#else
+    msgptr->timestamp = jiffies_to_msecs(jiffies);
+#endif
+    msgptr->direction = dir;
+    msgptr->signal_length = signal_len;
+
+    /* Copy signal and bulk data to the log */
+    p = (u8 *)(msgptr + 1);
+    memcpy(p, signal, signal_len);
+    p += signal_len;
+
+    /* Append any bulk data */
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+        int len = bulkdata->d[i].data_length;
+
+        /*
+         * Len here might not be the same as the length in the bulk data slot.
+         * The slot length will always be even, but len could be odd.
+         */
+        if (len > 0) {
+            if (bulkdata->d[i].os_data_ptr) {
+                memcpy(p, bulkdata->d[i].os_data_ptr, len);
+            } else {
+                memset(p, 0, len);
+            }
+            p += len;
+        }
+    }
+
+    /* Add to tail of log queue */
+    if (down_interruptible(&pcli->udi_sem)) {
+        printk(KERN_WARNING "udi_log_event_q: Failed to get udi sem\n");
+        kfree(logptr);
+        func_exit();
+        return;
+    }
+    list_add_tail(&logptr->q, &pcli->udi_log);
+    up(&pcli->udi_sem);
+
+    /* Wake any waiting user process */
+    wake_up_interruptible(&pcli->udi_wq);
+
+    func_exit();
+} /* udi_log_event() */
+
+#ifdef CSR_SME_USERSPACE
+int
+uf_sme_queue_message(unifi_priv_t *priv, u8 *buffer, int length)
+{
+    udi_log_t *logptr;
+    udi_msg_t *msgptr;
+    u8 *p;
+
+    func_enter();
+
+    /* Just a sanity check */
+    if ((buffer == NULL) || (length <= 0)) {
+        return -EINVAL;
+    }
+
+    /* Allocate log structure plus actual signal. */
+    logptr = (udi_log_t *)kmalloc(sizeof(udi_log_t) + length, GFP_ATOMIC);
+    if (logptr == NULL) {
+        unifi_error(priv, "Failed to allocate %d bytes for an SME message\n",
+                    sizeof(udi_log_t) + length);
+                    CsrPmemFree(buffer);
+                    return -ENOMEM;
+    }
+
+    /* Fill in udi_log struct */
+    INIT_LIST_HEAD(&logptr->q);
+    msgptr = &logptr->msg;
+    msgptr->length = sizeof(udi_msg_t) + length;
+    msgptr->signal_length = length;
+
+    /* Copy signal and bulk data to the log */
+    p = (u8 *)(msgptr + 1);
+    memcpy(p, buffer, length);
+
+    /* Add to tail of log queue */
+    down(&udi_mutex);
+    if (priv->sme_cli == NULL) {
+        kfree(logptr);
+        CsrPmemFree(buffer);
+        up(&udi_mutex);
+        unifi_info(priv, "Message for the SME dropped, SME has gone away\n");
+        return 0;
+    }
+
+    down(&priv->sme_cli->udi_sem);
+    list_add_tail(&logptr->q, &priv->sme_cli->udi_log);
+    up(&priv->sme_cli->udi_sem);
+
+    /* Wake any waiting user process */
+    wake_up_interruptible(&priv->sme_cli->udi_wq);
+    up(&udi_mutex);
+
+    /* It is our responsibility to free the buffer allocated in build_packed_*() */
+    CsrPmemFree(buffer);
+
+    func_exit();
+
+    return 0;
+
+} /* uf_sme_queue_message() */
+#endif
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+#define UF_DEVICE_CREATE(_class, _parent, _devno, _priv, _fmt, _args)       \
+    device_create(_class, _parent, _devno, _priv, _fmt, _args)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#define UF_DEVICE_CREATE(_class, _parent, _devno, _priv, _fmt, _args)       \
+    device_create_drvdata(_class, _parent, _devno, _priv, _fmt, _args)
+#else
+#define UF_DEVICE_CREATE(_class, _parent, _devno, _priv, _fmt, _args)       \
+    device_create(_class, _parent, _devno, _fmt, _args)
+#endif
+
+/*
+ ****************************************************************************
+ *
+ *      Driver instantiation
+ *
+ ****************************************************************************
+ */
+static struct file_operations unifi_fops = {
+    .owner      = THIS_MODULE,
+    .open       = unifi_open,
+    .release    = unifi_release,
+    .read       = unifi_read,
+    .write      = unifi_write,
+    .unlocked_ioctl = unifi_ioctl,
+    .poll       = unifi_poll,
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+#define UF_DEVICE_CREATE(_class, _parent, _devno, _priv, _fmt, _args)       \
+    device_create(_class, _parent, _devno, _priv, _fmt, _args)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#define UF_DEVICE_CREATE(_class, _parent, _devno, _priv, _fmt, _args)       \
+    device_create_drvdata(_class, _parent, _devno, _priv, _fmt, _args)
+#else
+#define UF_DEVICE_CREATE(_class, _parent, _devno, _priv, _fmt, _args)       \
+    device_create(_class, _parent, _devno, _fmt, _args)
+#endif
+
+static dev_t unifi_first_devno;
+static struct class *unifi_class;
+
+
+int uf_create_device_nodes(unifi_priv_t *priv, int bus_id)
+{
+    dev_t devno;
+    int r;
+
+    cdev_init(&priv->unifi_cdev, &unifi_fops);
+
+    /* cdev_init() should set the cdev owner, but it does not */
+    priv->unifi_cdev.owner = THIS_MODULE;
+
+    devno = MKDEV(MAJOR(unifi_first_devno),
+                  MINOR(unifi_first_devno) + (bus_id * 2));
+    r = cdev_add(&priv->unifi_cdev, devno, 1);
+    if (r) {
+        return r;
+    }
+
+#ifdef SDIO_EXPORTS_STRUCT_DEVICE
+    if (!UF_DEVICE_CREATE(unifi_class, priv->unifi_device,
+                          devno, priv, "unifi%d", bus_id)) {
+#else
+    priv->unifi_device = UF_DEVICE_CREATE(unifi_class, NULL,
+                                          devno, priv, "unifi%d", bus_id);
+    if (priv->unifi_device == NULL) {
+#endif /* SDIO_EXPORTS_STRUCT_DEVICE */
+
+        cdev_del(&priv->unifi_cdev);
+        return -EINVAL;
+    }
+
+    cdev_init(&priv->unifiudi_cdev, &unifi_fops);
+
+    /* cdev_init() should set the cdev owner, but it does not */
+    priv->unifiudi_cdev.owner = THIS_MODULE;
+
+    devno = MKDEV(MAJOR(unifi_first_devno),
+                  MINOR(unifi_first_devno) + (bus_id * MAX_UNIFI_DEVS) + 1);
+    r = cdev_add(&priv->unifiudi_cdev, devno, 1);
+    if (r) {
+        device_destroy(unifi_class, priv->unifi_cdev.dev);
+        cdev_del(&priv->unifi_cdev);
+        return r;
+    }
+
+    if (!UF_DEVICE_CREATE(unifi_class,
+#ifdef SDIO_EXPORTS_STRUCT_DEVICE
+                          priv->unifi_device,
+#else
+                          NULL,
+#endif /* SDIO_EXPORTS_STRUCT_DEVICE */
+                          devno, priv, "unifiudi%d", bus_id)) {
+        device_destroy(unifi_class, priv->unifi_cdev.dev);
+        cdev_del(&priv->unifiudi_cdev);
+        cdev_del(&priv->unifi_cdev);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+
+void uf_destroy_device_nodes(unifi_priv_t *priv)
+{
+    device_destroy(unifi_class, priv->unifiudi_cdev.dev);
+    device_destroy(unifi_class, priv->unifi_cdev.dev);
+    cdev_del(&priv->unifiudi_cdev);
+    cdev_del(&priv->unifi_cdev);
+}
+
+
+
+/*
+ * ----------------------------------------------------------------
+ *  uf_create_debug_device
+ *
+ *      Allocates device numbers for unifi character device nodes
+ *      and creates a unifi class in sysfs
+ *
+ * Arguments:
+ *  fops          Pointer to the char device operations structure.
+ *
+ * Returns:
+ *      0 on success, -ve error code on error.
+ * ----------------------------------------------------------------
+ */
+static int
+uf_create_debug_device(struct file_operations *fops)
+{
+    int ret;
+
+    /* Allocate two device numbers for each device. */
+    ret = alloc_chrdev_region(&unifi_first_devno, 0, MAX_UNIFI_DEVS*2, UNIFI_NAME);
+    if (ret) {
+        unifi_error(NULL, "Failed to add alloc dev numbers: %d\n", ret);
+        return ret;
+    }
+
+    /* Create a UniFi class */
+    unifi_class = class_create(THIS_MODULE, UNIFI_NAME);
+    if (IS_ERR(unifi_class)) {
+        unifi_error(NULL, "Failed to create UniFi class\n");
+
+        /* Release device numbers */
+        unregister_chrdev_region(unifi_first_devno, MAX_UNIFI_DEVS*2);
+        unifi_first_devno = 0;
+        return -EINVAL;
+    }
+
+    return 0;
+} /* uf_create_debug_device() */
+
+
+/*
+ * ----------------------------------------------------------------
+ *  uf_remove_debug_device
+ *
+ *      Destroys the unifi class and releases the allocated
+ *      device numbers for unifi character device nodes.
+ *
+ * Arguments:
+ *
+ * Returns:
+ * ----------------------------------------------------------------
+ */
+static void
+uf_remove_debug_device(void)
+{
+    /* Destroy the UniFi class */
+    class_destroy(unifi_class);
+
+    /* Release device numbers */
+    unregister_chrdev_region(unifi_first_devno, MAX_UNIFI_DEVS*2);
+    unifi_first_devno = 0;
+
+} /* uf_remove_debug_device() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ *      Module loading.
+ *
+ * ---------------------------------------------------------------------------
+ */
+int __init
+unifi_load(void)
+{
+    int r;
+
+    printk("UniFi SDIO Driver: %s %s %s\n",
+            CSR_WIFI_VERSION,
+           __DATE__, __TIME__);
+
+#ifdef CSR_SME_USERSPACE
+#ifdef CSR_SUPPORT_WEXT
+    printk("CSR SME with WEXT support\n");
+#else
+    printk("CSR SME no WEXT support\n");
+#endif /* CSR_SUPPORT_WEXT */
+#endif /* CSR_SME_USERSPACE */
+
+#ifdef CSR_NATIVE_LINUX
+#ifdef CSR_SUPPORT_WEXT
+#error WEXT unsupported in the native driver
+#endif
+    printk("CSR native no WEXT support\n");
+#endif
+
+    printk("Kernel %d.%d.%d\n",
+           ((LINUX_VERSION_CODE) >> 16) & 0xff,
+           ((LINUX_VERSION_CODE) >> 8) & 0xff,
+           (LINUX_VERSION_CODE) & 0xff);
+    /*
+     * Instantiate the /dev/unifi* device nodes.
+     * We must do this before registering with the SDIO driver because it
+     * will immediately call the "insert" callback if the card is
+     * already present.
+     */
+    r = uf_create_debug_device(&unifi_fops);
+    if (r) {
+        return r;
+    }
+
+    /* Now register with the SDIO driver */
+    r = uf_sdio_load();
+    if (r) {
+        uf_remove_debug_device();
+        return r;
+    }
+
+    if (sdio_block_size > -1) {
+        unifi_info(NULL, "sdio_block_size %d\n", sdio_block_size);
+    }
+
+    if (sdio_byte_mode) {
+        unifi_info(NULL, "sdio_byte_mode\n");
+    }
+
+    if (disable_power_control) {
+        unifi_info(NULL, "disable_power_control\n");
+    }
+
+    if (disable_hw_reset) {
+        unifi_info(NULL, "disable_hw_reset\n");
+    }
+
+    if (enable_wol) {
+        unifi_info(NULL, "enable_wol %d\n", enable_wol);
+    }
+
+    if (run_bh_once != -1) {
+        unifi_info(NULL, "run_bh_once %d\n", run_bh_once);
+    }
+
+    return 0;
+} /* unifi_load() */
+
+
+void __exit
+unifi_unload(void)
+{
+    /* The SDIO remove hook will call unifi_disconnect(). */
+    uf_sdio_unload();
+
+    uf_remove_debug_device();
+
+} /* unifi_unload() */
+
+module_init(unifi_load);
+module_exit(unifi_unload);
+
+MODULE_DESCRIPTION("UniFi Device driver");
+MODULE_AUTHOR("Cambridge Silicon Radio Ltd.");
+MODULE_LICENSE("GPL and additional rights");
--- /dev/null
+++ b/drivers/staging/csr/firmware.c
@@ -0,0 +1,398 @@
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     firmware.c
+ *
+ *  PURPOSE:
+ *      Implements the f/w related HIP core lib API.
+ *      It is part of the porting exercise in Linux.
+ *
+ *      Also, it contains example code for reading the loader and f/w files
+ *      from the userspace and starting the SME in Linux.
+ *
+ * Copyright (C) 2005-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include <linux/kmod.h>
+#include <linux/vmalloc.h>
+#include <linux/firmware.h>
+#include <asm/uaccess.h>
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_unifi_udi.h"
+#include "unifiio.h"
+#include "unifi_priv.h"
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ *      F/W download. Part of the HIP core API
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_fw_read_start
+ *
+ *      Returns a structure to be passed in unifi_fw_read().
+ *      This structure is an OS specific description of the f/w file.
+ *      In the linux implementation it is a buffer with the f/w and its' length.
+ *      The HIP driver calls this functions to request for the loader or
+ *      the firmware file.
+ *      The structure pointer can be freed when unifi_fw_read_stop() is called.
+ *
+ *  Arguments:
+ *      ospriv          Pointer to driver context.
+ *      is_fw           Type of firmware to retrieve
+ *      info            Versions information. Can be used to determine
+ *                      the appropriate f/w file to load.
+ *
+ *  Returns:
+ *      O on success, non-zero otherwise.
+ *
+ * ---------------------------------------------------------------------------
+ */
+void*
+unifi_fw_read_start(void *ospriv, CsrInt8 is_fw, const card_info_t *info)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+    CSR_UNUSED(info);
+
+    func_enter();
+
+    if (is_fw == UNIFI_FW_STA) {
+        /* F/w may have been released after a previous successful download. */
+        if (priv->fw_sta.dl_data == NULL) {
+            unifi_trace(priv, UDBG2, "Attempt reload of sta f/w\n");
+            uf_request_firmware_files(priv, UNIFI_FW_STA);
+        }
+        /* Set up callback struct for readfunc() */
+        if (priv->fw_sta.dl_data != NULL) {
+            func_exit();
+            return &priv->fw_sta;
+        }
+
+    } else {
+        unifi_error(priv, "downloading firmware... unknown request: %d\n", is_fw);
+    }
+
+    func_exit();
+    return NULL;
+} /* unifi_fw_read_start() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_fw_read_stop
+ *
+ *      Called when the HIP driver has finished using the loader or
+ *      the firmware file.
+ *      The firmware buffer may be released now.
+ *
+ *  Arguments:
+ *      ospriv          Pointer to driver context.
+ *      dlpriv          The pointer returned by unifi_fw_read_start()
+ *
+ * ---------------------------------------------------------------------------
+ */
+void
+unifi_fw_read_stop(void *ospriv, void *dlpriv)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+    struct dlpriv *dl_struct = (struct dlpriv *)dlpriv;
+    func_enter();
+
+    if (dl_struct != NULL) {
+        if (dl_struct->dl_data != NULL) {
+            unifi_trace(priv, UDBG2, "Release f/w buffer %p, %d bytes\n",
+                        dl_struct->dl_data, dl_struct->dl_len);
+        }
+        uf_release_firmware(priv, dl_struct);
+    }
+
+    func_exit();
+} /* unifi_fw_read_stop() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_fw_open_buffer
+ *
+ *  Returns a handle for a buffer dynamically allocated by the driver,
+ *  e.g. into which a firmware file may have been converted from another format
+ *  which is the case with some production test images.
+ *
+ *  The handle may then be used by unifi_fw_read() to access the contents of
+ *  the buffer.
+ *
+ *  Arguments:
+ *      ospriv          Pointer to driver context.
+ *      fwbuf           Buffer containing firmware image
+ *      len             Length of buffer in bytes
+ *
+ *  Returns
+ *      Handle for buffer, or NULL on error
+ * ---------------------------------------------------------------------------
+ */
+void *
+unifi_fw_open_buffer(void *ospriv, void *fwbuf, CsrUint32 len)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+    func_enter();
+
+    if (fwbuf == NULL) {
+        func_exit();
+        return NULL;
+    }
+    priv->fw_conv.dl_data = fwbuf;
+    priv->fw_conv.dl_len = len;
+    priv->fw_conv.fw_desc = NULL;   /* No OS f/w resource is associated */
+
+    func_exit();
+    return &priv->fw_conv;
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_fw_close_buffer
+ *
+ *  Releases any handle for a buffer dynamically allocated by the driver,
+ *  e.g. into which a firmware file may have been converted from another format
+ *  which is the case with some production test images.
+ *
+ *
+ *  Arguments:
+ *      ospriv          Pointer to driver context.
+ *      fwbuf           Buffer containing firmware image
+ *
+ *  Returns
+ *      Handle for buffer, or NULL on error
+ * ---------------------------------------------------------------------------
+ */
+void unifi_fw_close_buffer(void *ospriv, void *fwbuf)
+{
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_fw_read
+ *
+ *      The HIP driver calls this function to ask for a part of the loader or
+ *      the firmware file.
+ *
+ *  Arguments:
+ *      ospriv          Pointer to driver context.
+ *      arg             The pointer returned by unifi_fw_read_start().
+ *      offset          The offset in the file to return from.
+ *      buf             A buffer to store the requested data.
+ *      len             The size of the buf and the size of the requested data.
+ *
+ *  Returns
+ *      The number of bytes read from the firmware image, or -ve on error
+ * ---------------------------------------------------------------------------
+ */
+CsrInt32
+unifi_fw_read(void *ospriv, void *arg, CsrUint32 offset, void *buf, CsrUint32 len)
+{
+    const struct dlpriv *dlpriv = arg;
+
+    if (offset >= dlpriv->dl_len) {
+        /* at end of file */
+        return 0;
+    }
+
+    if ((offset + len) > dlpriv->dl_len) {
+        /* attempt to read past end of file */
+        return -1;
+    }
+
+    memcpy(buf, dlpriv->dl_data+offset, len);
+
+    return len;
+
+} /* unifi_fw_read() */
+
+
+
+
+#define UNIFIHELPER_INIT_MODE_SMEEMB    0
+#define UNIFIHELPER_INIT_MODE_SMEUSER   2
+#define UNIFIHELPER_INIT_MODE_NATIVE    1
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_run_unifihelper
+ *
+ *      Ask userspace to send us firmware for download by running
+ *      '/usr/sbin/unififw'.
+ *      The same script starts the SME userspace application.
+ *      Derived from net_run_sbin_hotplug().
+ *
+ *  Arguments:
+ *      priv            Pointer to OS private struct.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+int
+uf_run_unifihelper(unifi_priv_t *priv)
+{
+#ifdef CONFIG_HOTPLUG
+
+#ifdef ANDROID_BUILD
+    char *prog = "/system/bin/unififw";
+#else
+    char *prog = "/usr/sbin/unififw";
+#endif /* ANDROID_BUILD */
+
+    char *argv[6], *envp[4];
+    char inst_str[8];
+    char init_mode[8];
+    int i, r;
+
+#if (defined CSR_SME_USERSPACE) && (!defined CSR_SUPPORT_WEXT)
+    unifi_trace(priv, UDBG1, "SME userspace build: run unifi_helper manually\n");
+    return 0;
+#endif
+
+    unifi_trace(priv, UDBG1, "starting %s\n", prog);
+
+    snprintf(inst_str,   8, "%d", priv->instance);
+#if (defined CSR_SME_USERSPACE)
+    snprintf(init_mode, 8, "%d", UNIFIHELPER_INIT_MODE_SMEUSER);
+#else
+    snprintf(init_mode, 8, "%d", UNIFIHELPER_INIT_MODE_NATIVE);
+#endif /* CSR_SME_USERSPACE */
+
+    i = 0;
+    argv[i++] = prog;
+    argv[i++] = inst_str;
+    argv[i++] = init_mode;
+    argv[i++] = 0;
+    argv[i] = 0;
+    /* Don't add more args without making argv bigger */
+
+    /* minimal command environment */
+    i = 0;
+    envp[i++] = "HOME=/";
+    envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+    envp[i] = 0;
+    /* Don't add more without making envp bigger */
+
+    unifi_trace(priv, UDBG2, "running %s %s %s\n", argv[0], argv[1], argv[2]);
+
+    r = call_usermodehelper(argv[0], argv, envp, 0);
+
+    return r;
+#else
+    unifi_trace(priv, UDBG1, "Can't automatically download firmware because kernel does not have HOTPLUG\n");
+    return -1;
+#endif
+} /* uf_run_unifihelper() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_request_firmware_files
+ *
+ *      Get the firmware files from userspace.
+ *
+ *  Arguments:
+ *      priv            Pointer to OS private struct.
+ *      is_fw           type of firmware to load (UNIFI_FW_STA/LOADER)
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+int uf_request_firmware_files(unifi_priv_t *priv, int is_fw)
+{
+    /* uses the default method to get the firmware */
+    const struct firmware *fw_entry;
+    int postfix;
+#define UNIFI_MAX_FW_PATH_LEN       32
+    char fw_name[UNIFI_MAX_FW_PATH_LEN];
+    int r;
+
+#if (defined CSR_SUPPORT_SME) && (defined CSR_SUPPORT_WEXT)
+    if (priv->mib_data.length) {
+        vfree(priv->mib_data.data);
+        priv->mib_data.data = NULL;
+        priv->mib_data.length = 0;
+    }
+#endif /* CSR_SUPPORT_SME && CSR_SUPPORT_WEXT*/
+
+    postfix = priv->instance;
+
+    if (is_fw == UNIFI_FW_STA) {
+        /* Free kernel buffer and reload */
+        uf_release_firmware(priv, &priv->fw_sta);
+        scnprintf(fw_name, UNIFI_MAX_FW_PATH_LEN, "unifi-sdio-%d/%s",
+                  postfix, "sta.xbv");
+        r = request_firmware(&fw_entry, fw_name, priv->unifi_device);
+        if (r == 0) {
+            priv->fw_sta.dl_data = fw_entry->data;
+            priv->fw_sta.dl_len = fw_entry->size;
+            priv->fw_sta.fw_desc = (void *)fw_entry;
+        } else {
+            unifi_trace(priv, UDBG2, "Firmware file not available\n");
+        }
+    }
+
+    return 0;
+
+} /* uf_request_firmware_files() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_release_firmware_files
+ *
+ *      Release all buffers used to store firmware files
+ *
+ *  Arguments:
+ *      priv            Pointer to OS private struct.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+int uf_release_firmware_files(unifi_priv_t *priv)
+{
+    uf_release_firmware(priv, &priv->fw_sta);
+
+    return 0;
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_release_firmware
+ *
+ *      Release specific buffer used to store firmware
+ *
+ *  Arguments:
+ *      priv            Pointer to OS private struct.
+ *      to_free         Pointer to specific buffer to release
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+int uf_release_firmware(unifi_priv_t *priv, struct dlpriv *to_free)
+{
+    if (to_free != NULL) {
+        if (to_free->fw_desc != NULL) {
+            release_firmware((const struct firmware *)to_free->fw_desc);
+        }
+        to_free->fw_desc = NULL;
+        to_free->dl_data = NULL;
+        to_free->dl_len = 0;
+    }
+    return 0;
+}
--- /dev/null
+++ b/drivers/staging/csr/indications.c
@@ -0,0 +1,18 @@
+/*
+ * ***************************************************************************
+ * FILE:     indications.c
+ *
+ * PURPOSE:
+ *      Callbacks to process signals sent to us by the UniFi chip.
+ *
+ *      This file is linux-specific.
+ *
+ * Copyright (C) 2005-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ***************************************************************************
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "unifi_priv.h"
--- /dev/null
+++ b/drivers/staging/csr/inet.c
@@ -0,0 +1,106 @@
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     inet.c
+ *
+ *  PURPOSE:
+ *      Routines related to IP address changes.
+ *      Optional part of the porting exercise. It uses system network
+ *      handlers to obtain the UniFi IP address and pass it to the SME
+ *      using the unifi_sys_ip_configured_ind().
+ *
+ * Copyright (C) 2008-2009 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include <linux/inetdevice.h>
+#include <linux/notifier.h>
+
+#include "unifi_priv.h"
+#include "csr_wifi_hip_conversions.h"
+
+/*
+ * The inet notifier is global and not per-netdev.  To avoid having a
+ * notifier registered when there are no unifi devices present, it's
+ * registered after the first unifi network device is registered, and
+ * unregistered when the last unifi network device is unregistered.
+ */
+
+static atomic_t inet_notif_refs = ATOMIC_INIT(0);
+
+static int uf_inetaddr_event(struct notifier_block *notif, unsigned long event, void *ifa)
+{
+    struct net_device *ndev;
+    unifi_priv_t *priv;
+    struct in_ifaddr *if_addr;
+    netInterface_priv_t *InterfacePriv = (netInterface_priv_t *)NULL;
+
+    if (!ifa || !((struct in_ifaddr *)ifa)->ifa_dev) {
+        unifi_trace(NULL, UDBG1, "uf_inetaddr_event (%lu) ifa=%p\n", event, ifa);
+        return NOTIFY_DONE;
+    }
+
+    ndev = ((struct in_ifaddr *)ifa)->ifa_dev->dev;
+    InterfacePriv = (netInterface_priv_t*) netdev_priv(ndev);
+
+    /* As the notifier is global, the call may be for a non-UniFi netdev.
+     * Therefore check the netdev_priv to make sure it's a known UniFi one.
+     */
+    if (uf_find_netdev_priv(InterfacePriv) == -1) {
+        unifi_trace(NULL, UDBG1, "uf_inetaddr_event (%lu) ndev=%p, other netdev_priv=%p\n",
+                    event, ndev, InterfacePriv);
+        return NOTIFY_DONE;
+    }
+
+    if (!InterfacePriv->privPtr) {
+        unifi_error(NULL, "uf_inetaddr_event null priv (%lu) ndev=%p, InterfacePriv=%p\n",
+                    event, ndev, InterfacePriv);
+        return NOTIFY_DONE;
+    }
+
+    priv = InterfacePriv->privPtr;
+    if_addr = (struct in_ifaddr *)ifa;
+
+    /* If this event is for a UniFi device, notify the SME that an IP
+     * address has been added or removed. */
+    if (uf_find_priv(priv) != -1) {
+        switch (event) {
+            case NETDEV_UP:
+                unifi_info(priv, "IP address assigned for %s\n", priv->netdev[InterfacePriv->InterfaceTag]->name);
+                priv->sta_ip_address = if_addr->ifa_address;
+#ifdef CSR_SUPPORT_WEXT
+                sme_mgt_packet_filter_set(priv);
+#endif
+                break;
+            case NETDEV_DOWN:
+                unifi_info(priv, "IP address removed for %s\n", priv->netdev[InterfacePriv->InterfaceTag]->name);
+                priv->sta_ip_address = 0xFFFFFFFF;
+#ifdef CSR_SUPPORT_WEXT
+                sme_mgt_packet_filter_set(priv);
+#endif
+                break;
+        }
+    }
+
+    return NOTIFY_DONE;
+}
+
+static struct notifier_block uf_inetaddr_notifier = {
+    .notifier_call = uf_inetaddr_event,
+};
+
+void uf_register_inet_notifier(void)
+{
+    if (atomic_inc_return(&inet_notif_refs) == 1) {
+        register_inetaddr_notifier(&uf_inetaddr_notifier);
+    }
+}
+
+void uf_unregister_inet_notifier(void)
+{
+    if (atomic_dec_return(&inet_notif_refs) == 0) {
+        unregister_inetaddr_notifier(&uf_inetaddr_notifier);
+    }
+}
--- /dev/null
+++ b/drivers/staging/csr/init_hw.c
@@ -0,0 +1,108 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     init_hw.c
+ *
+ * PURPOSE:
+ *      Use the HIP core lib to initialise the UniFi chip.
+ *      It is part of the porting exercise in Linux.
+ *
+ * Copyright (C) 2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "unifi_priv.h"
+
+
+#define MAX_INIT_ATTEMPTS        4
+
+extern int led_mask;
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_init_hw
+ *
+ *      Resets hardware, downloads and initialises f/w.
+ *      This function demonstrates how to use the HIP core lib API
+ *      to implement the SME unifi_sys_wifi_on_req() part of the SYS API.
+ *
+ *      In a simple implementation, all this function needs to do is call
+ *      unifi_init_card() and then unifi_card_info().
+ *      In the Linux implementation, it will retry to initialise UniFi or
+ *      try to debug the reasons if unifi_init_card() returns an error.
+ *
+ *  Arguments:
+ *      ospriv          Pointer to OS driver structure for the device.
+ *
+ *  Returns:
+ *      O on success, non-zero otherwise.
+ *
+ * ---------------------------------------------------------------------------
+ */
+int
+uf_init_hw(unifi_priv_t *priv)
+{
+    int attempts = 0;
+    int priv_instance;
+    CsrResult csrResult = CSR_RESULT_FAILURE;
+
+    priv_instance = uf_find_priv(priv);
+    if (priv_instance == -1) {
+        unifi_warning(priv, "uf_init_hw: Unknown priv instance, will use fw_init[0]\n");
+        priv_instance = 0;
+    }
+
+    while (1) {
+        if (attempts > MAX_INIT_ATTEMPTS) {
+            unifi_error(priv, "Failed to initialise UniFi after %d attempts, "
+                        "giving up.\n",
+                        attempts);
+            break;
+        }
+        attempts++;
+
+        unifi_info(priv, "Initialising UniFi, attempt %d\n", attempts);
+
+        if (fw_init[priv_instance] > 0) {
+            unifi_notice(priv, "f/w init prevented by module parameter\n");
+            break;
+        } else if (fw_init[priv_instance] == 0) {
+            fw_init[priv_instance] ++;
+        }
+
+        /*
+         * Initialise driver core. This will perform a reset of UniFi
+         * internals, but not the SDIO CCCR.
+         */
+        CsrSdioClaim(priv->sdio);
+        csrResult = unifi_init_card(priv->card, led_mask);
+        CsrSdioRelease(priv->sdio);
+
+        if (csrResult == CSR_WIFI_HIP_RESULT_NO_DEVICE) {
+            return CsrHipResultToStatus(csrResult);
+        }
+        if (csrResult == CSR_WIFI_HIP_RESULT_NOT_FOUND) {
+            unifi_error(priv, "Firmware file required, but not found.\n");
+            return CsrHipResultToStatus(csrResult);
+        }
+        if (csrResult != CSR_RESULT_SUCCESS) {
+            /* failed. Reset h/w and try again */
+            unifi_error(priv, "Failed to initialise UniFi chip.\n");
+            continue;
+        }
+
+        /* Get the version information from the lib_hip */
+        unifi_card_info(priv->card, &priv->card_info);
+
+        return CsrHipResultToStatus(csrResult);
+    }
+
+    return CsrHipResultToStatus(csrResult);
+
+} /* uf_init_hw */
+
+
--- /dev/null
+++ b/drivers/staging/csr/io.c
@@ -0,0 +1,1146 @@
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     io.c
+ *
+ *  PURPOSE:
+ *      This file contains routines that the SDIO driver can call when a
+ *      UniFi card is first inserted (or detected) and removed.
+ *
+ *      When used with sdioemb, the udev scripts (at least on Ubuntu) don't
+ *      recognise a UniFi being added to the system. This is because sdioemb
+ *      does not register itself as a device_driver, it uses it's own code
+ *      to handle insert and remove.
+ *      To have Ubuntu recognise UniFi, edit /etc/udev/rules.d/85-ifupdown.rules
+ *      to change this line:
+ *          SUBSYSTEM=="net", DRIVERS=="?*", GOTO="net_start"
+ *      to these:
+ *          #SUBSYSTEM=="net", DRIVERS=="?*", GOTO="net_start"
+ *          SUBSYSTEM=="net", GOTO="net_start"
+ *
+ *      Then you can add a stanza to /etc/network/interfaces like this:
+ *          auto eth1
+ *          iface eth1 inet dhcp
+ *          wpa-conf /etc/wpa_supplicant.conf
+ *      This will then automatically associate when a car dis inserted.
+ *
+ * Copyright (C) 2006-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include <linux/proc_fs.h>
+
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_unifiversion.h"
+#include "csr_wifi_hip_unifi_udi.h"   /* for unifi_print_status() */
+#include "unifiio.h"
+#include "unifi_priv.h"
+
+
+/*
+ * Array of pointers to context structs for unifi devices that are present.
+ * The index in the array corresponds to the wlan interface number
+ * (if "wlan*" is used). If "eth*" is used, the eth* numbers are allocated
+ * after any Ethernet cards.
+ *
+ * The Arasan PCI-SDIO controller card supported by this driver has 2 slots,
+ * hence a max of 2 devices.
+ */
+static unifi_priv_t *Unifi_instances[MAX_UNIFI_DEVS];
+
+/* Array of pointers to netdev objects used by the UniFi driver, as there
+ * are now many per instance. This is used to determine which netdev events
+ * are for UniFi as opposed to other net interfaces.
+ */
+static netInterface_priv_t *Unifi_netdev_instances[MAX_UNIFI_DEVS * CSR_WIFI_NUM_INTERFACES];
+
+/*
+ * Array to hold the status of each unifi device in each slot.
+ * We only process an insert event when In_use[] for the slot is
+ * UNIFI_DEV_NOT_IN_USE. Otherwise, it means that the slot is in use or
+ * we are in the middle of a cleanup (the action on unplug).
+ */
+#define UNIFI_DEV_NOT_IN_USE    0
+#define UNIFI_DEV_IN_USE        1
+#define UNIFI_DEV_CLEANUP       2
+static int In_use[MAX_UNIFI_DEVS];
+/*
+ * Mutex to prevent UDI clients to open the character device before the priv
+ * is created and initialised.
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
+DEFINE_SEMAPHORE(Unifi_instance_mutex);
+#else
+DECLARE_MUTEX(Unifi_instance_mutex);
+#endif
+/*
+ * When the device is removed, unregister waits on Unifi_cleanup_wq
+ * until all the UDI clients release the character device.
+ */
+DECLARE_WAIT_QUEUE_HEAD(Unifi_cleanup_wq);
+
+
+static int uf_read_proc(char *page, char **start, off_t offset, int count,
+                        int *eof, void *data);
+
+#ifdef CSR_WIFI_RX_PATH_SPLIT
+
+static CsrResult signal_buffer_init(unifi_priv_t * priv, int size)
+{
+    int i;
+    func_enter();
+
+    priv->rxSignalBuffer.writePointer =
+    priv->rxSignalBuffer.readPointer = 0;
+    priv->rxSignalBuffer.size = size;
+    /* Allocating Memory for Signal primitive pointer */
+    for(i=0; i<size; i++)
+    {
+         priv->rxSignalBuffer.rx_buff[i].sig_len=0;
+         priv->rxSignalBuffer.rx_buff[i].bufptr = CsrMemAlloc(UNIFI_PACKED_SIGBUF_SIZE);
+         if (priv->rxSignalBuffer.rx_buff[i].bufptr == NULL)
+         {
+             int j;
+             unifi_error(priv,"signal_buffer_init:Failed to Allocate shared memory for T-H signals \n");
+             for(j=0;j<i;j++)
+             {
+                 priv->rxSignalBuffer.rx_buff[j].sig_len=0;
+                 CsrMemFree(priv->rxSignalBuffer.rx_buff[j].bufptr);
+                 priv->rxSignalBuffer.rx_buff[j].bufptr = NULL;
+             }
+             func_exit();
+             return -1;
+         }
+    }
+    func_exit();
+    return 0;
+}
+
+
+static void signal_buffer_free(unifi_priv_t * priv, int size)
+{
+    int i;
+
+    for(i=0; i<size; i++)
+    {
+         priv->rxSignalBuffer.rx_buff[i].sig_len=0;
+         CsrMemFree(priv->rxSignalBuffer.rx_buff[i].bufptr);
+         priv->rxSignalBuffer.rx_buff[i].bufptr = NULL;
+    }
+}
+#endif
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_register_netdev
+ *
+ *      Registers the network interface, installes the qdisc,
+ *      and registers the inet handler.
+ *      In the porting exercise, register the driver to the network
+ *      stack if necessary.
+ *
+ *  Arguments:
+ *      priv          Pointer to driver context.
+ *
+ *  Returns:
+ *      O on success, non-zero otherwise.
+ *
+ *  Notes:
+ *      We will only unregister when the card is ejected, so we must
+ *      only do it once.
+ * ---------------------------------------------------------------------------
+ */
+int
+uf_register_netdev(unifi_priv_t *priv, int interfaceTag)
+{
+    int r;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "uf_register_netdev bad interfaceTag\n");
+        return -EINVAL;
+    }
+
+    /*
+     * Allocates a device number and registers device with the network
+     * stack.
+     */
+    unifi_trace(priv, UDBG5, "uf_register_netdev: netdev %d - 0x%p\n",
+            interfaceTag, priv->netdev[interfaceTag]);
+    r = register_netdev(priv->netdev[interfaceTag]);
+    if (r) {
+        unifi_error(priv, "Failed to register net device\n");
+        return -EINVAL;
+    }
+
+    /* The device is registed */
+    interfacePriv->netdev_registered = 1;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#ifdef CONFIG_NET_SCHED
+    /*
+     * IMPORTANT:
+     * uf_install_qdisc() holds the network device lock, we can not
+     * install the qdisk before the network device is registered.
+     */
+    r = uf_install_qdisc(priv->netdev[interfaceTag]);
+    if (r) {
+        unifi_error(priv, "Failed to install qdisc\n");
+        return r;
+    }
+#endif /* CONFIG_NET_SCHED */
+#endif /* LINUX_VERSION_CODE */
+
+#ifdef CSR_SUPPORT_SME
+    /*
+     * Register the inet handler; it notifies us for changes in the IP address.
+     */
+    uf_register_inet_notifier();
+#endif /* CSR_SUPPORT_SME */
+
+    unifi_notice(priv, "unifi%d is %s\n",
+            priv->instance, priv->netdev[interfaceTag]->name);
+
+    return 0;
+} /* uf_register_netdev */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_unregister_netdev
+ *
+ *      Unregisters the network interface and the inet handler.
+ *
+ *  Arguments:
+ *      priv          Pointer to driver context.
+ *
+ *  Returns:
+ *      None.
+ *
+ * ---------------------------------------------------------------------------
+ */
+void
+uf_unregister_netdev(unifi_priv_t *priv)
+{
+    int i=0;
+
+#ifdef CSR_SUPPORT_SME
+    /* Unregister the inet handler... */
+    uf_unregister_inet_notifier();
+#endif /* CSR_SUPPORT_SME */
+
+    for (i=0; i<CSR_WIFI_NUM_INTERFACES; i++) {
+        netInterface_priv_t *interfacePriv = priv->interfacePriv[i];
+        if (interfacePriv->netdev_registered) {
+            unifi_trace(priv, UDBG5,
+                    "uf_unregister_netdev: netdev %d - 0x%p\n",
+                    i, priv->netdev[i]);
+
+            /* ... and the netdev */
+            unregister_netdev(priv->netdev[i]);
+            interfacePriv->netdev_registered = 0;
+        }
+
+        interfacePriv->interfaceMode = 0;
+
+        /* Enable all queues by default */
+        interfacePriv->queueEnabled[0] = 1;
+        interfacePriv->queueEnabled[1] = 1;
+        interfacePriv->queueEnabled[2] = 1;
+        interfacePriv->queueEnabled[3] = 1;
+    }
+
+    priv->totalInterfaceCount = 0;
+} /* uf_unregister_netdev() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  register_unifi_sdio
+ *
+ *      This function is called from the Probe (or equivalent) method of
+ *      the SDIO driver when a UniFi card is detected.
+ *      We allocate the Linux net_device struct, initialise the HIP core
+ *      lib, create the char device nodes and start the userspace helper
+ *      to initialise the device.
+ *
+ *  Arguments:
+ *      sdio_dev        Pointer to SDIO context handle to use for all
+ *                      SDIO ops.
+ *      bus_id          A small number indicating the SDIO card position on the
+ *                      bus. Typically this is the slot number, e.g. 0, 1 etc.
+ *                      Valid values are 0 to MAX_UNIFI_DEVS-1.
+ *      dev             Pointer to kernel device manager struct.
+ *
+ *  Returns:
+ *      Pointer to the unifi instance, or NULL on error.
+ * ---------------------------------------------------------------------------
+ */
+static unifi_priv_t *
+register_unifi_sdio(CsrSdioFunction *sdio_dev, int bus_id, struct device *dev)
+{
+    unifi_priv_t *priv = NULL;
+    int r = -1;
+    CsrResult csrResult;
+
+    func_enter();
+
+    if ((bus_id < 0) || (bus_id >= MAX_UNIFI_DEVS)) {
+        unifi_error(priv, "register_unifi_sdio: invalid device %d\n",
+                bus_id);
+        return NULL;
+    }
+
+    down(&Unifi_instance_mutex);
+
+    if (In_use[bus_id] != UNIFI_DEV_NOT_IN_USE) {
+        unifi_error(priv, "register_unifi_sdio: device %d is already in use\n",
+                bus_id);
+        goto failed0;
+    }
+
+
+    /* Allocate device private and net_device structs */
+    priv = uf_alloc_netdevice(sdio_dev, bus_id);
+    if (priv == NULL) {
+        unifi_error(priv, "Failed to allocate driver private\n");
+        goto failed0;
+    }
+
+    priv->unifi_device = dev;
+
+    SET_NETDEV_DEV(priv->netdev[0], dev);
+
+    /* We are not ready to send data yet. */
+    netif_carrier_off(priv->netdev[0]);
+
+    /* Allocate driver context. */
+    priv->card = unifi_alloc_card(priv->sdio, priv);
+    if (priv->card == NULL) {
+        unifi_error(priv, "Failed to allocate UniFi driver card struct.\n");
+        goto failed1;
+    }
+
+    if (Unifi_instances[bus_id]) {
+        unifi_error(priv, "Internal error: instance for slot %d is already taken\n",
+                bus_id);
+    }
+    Unifi_instances[bus_id] = priv;
+    In_use[bus_id] = UNIFI_DEV_IN_USE;
+
+    /* Save the netdev_priv for use by the netdev event callback mechanism */
+    Unifi_netdev_instances[bus_id * CSR_WIFI_NUM_INTERFACES] = netdev_priv(priv->netdev[0]);
+
+    /* Initialise the mini-coredump capture buffers */
+    csrResult = unifi_coredump_init(priv->card, (CsrUint16)coredump_max);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "Couldn't allocate mini-coredump buffers\n");
+    }
+
+    /* Create the character device nodes */
+    r = uf_create_device_nodes(priv, bus_id);
+    if (r) {
+        goto failed1;
+    }
+
+    /*
+     * We use the slot number as unifi device index.
+     */
+    snprintf(priv->proc_entry_name, 64, "driver/unifi%d", priv->instance);
+    /*
+     * The following complex casting is in place in order to eliminate 64-bit compilation warning
+     * "cast to/from pointer from/to integer of different size"
+     */
+    if (!create_proc_read_entry(priv->proc_entry_name, 0, 0,
+                uf_read_proc, (void *)(long)priv->instance))
+    {
+        unifi_error(priv, "unifi: can't create /proc/driver/unifi\n");
+    }
+
+    /* Allocate the net_device for interfaces other than 0. */
+    {
+        int i;
+        priv->totalInterfaceCount =0;
+
+        for(i=1;i<CSR_WIFI_NUM_INTERFACES;i++)
+        {
+            if( !uf_alloc_netdevice_for_other_interfaces(priv,i) )
+            {
+                /* error occured while allocating the net_device for interface[i]. The net_device are
+                 * allocated for the interfaces with id<i. Dont worry, all the allocated net_device will
+                 * be releasing chen the control goes to the label failed0.
+                 */
+                unifi_error(priv, "Failed to allocate driver private for interface[%d]\n",i);
+                goto failed0;
+            }
+            else
+            {
+                SET_NETDEV_DEV(priv->netdev[i], dev);
+
+                /* We are not ready to send data yet. */
+                netif_carrier_off(priv->netdev[i]);
+
+                /* Save the netdev_priv for use by the netdev event callback mechanism */
+                Unifi_netdev_instances[bus_id * CSR_WIFI_NUM_INTERFACES + i] = netdev_priv(priv->netdev[i]);
+            }
+        }
+
+        for(i=0;i<CSR_WIFI_NUM_INTERFACES;i++)
+        {
+            netInterface_priv_t *interfacePriv = priv->interfacePriv[i];
+            interfacePriv->netdev_registered=0;
+        }
+    }
+
+#ifdef CSR_WIFI_RX_PATH_SPLIT
+    if (signal_buffer_init(priv, CSR_WIFI_RX_SIGNAL_BUFFER_SIZE))
+    {
+        unifi_error(priv,"Failed to allocate shared memory for T-H signals\n");
+        goto failed2;
+    }
+    priv->rx_workqueue = create_singlethread_workqueue("rx_workq");
+    if (priv->rx_workqueue == NULL) {
+        unifi_error(priv,"create_singlethread_workqueue failed \n");
+        goto failed3;
+    }
+    INIT_WORK(&priv->rx_work_struct, rx_wq_handler);
+#endif
+
+    /* Initialise the SME related threads and parameters */
+    r = uf_sme_init(priv);
+    if (r) {
+        unifi_error(priv, "SME initialisation failed.\n");
+        goto failed4;
+    }
+
+    /*
+     * Run the userspace helper program (unififw) to perform
+     * the device initialisation.
+     */
+    unifi_trace(priv, UDBG1, "run UniFi helper app...\n");
+    r = uf_run_unifihelper(priv);
+    if (r) {
+        unifi_notice(priv, "unable to run UniFi helper app\n");
+        /* Not a fatal error. */
+    }
+
+    up(&Unifi_instance_mutex);
+
+    func_exit();
+    return priv;
+
+failed4:
+#ifdef CSR_WIFI_RX_PATH_SPLIT
+    flush_workqueue(priv->rx_workqueue);
+    destroy_workqueue(priv->rx_workqueue);
+failed3:
+    signal_buffer_free(priv,CSR_WIFI_RX_SIGNAL_BUFFER_SIZE);
+failed2:
+#endif
+    /* Remove the device nodes */
+    uf_destroy_device_nodes(priv);
+failed1:
+    /* Deregister priv->netdev_client */
+    ul_deregister_client(priv->netdev_client);
+
+failed0:
+    if (priv && priv->card) {
+        unifi_coredump_free(priv->card);
+        unifi_free_card(priv->card);
+    }
+    if (priv) {
+        uf_free_netdevice(priv);
+    }
+
+    up(&Unifi_instance_mutex);
+
+    func_exit();
+    return NULL;
+} /* register_unifi_sdio() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  ask_unifi_sdio_cleanup
+ *
+ *      We can not free our private context, until all the char device
+ *      clients have closed the file handles. unregister_unifi_sdio() which
+ *      is called when a card is removed, waits on Unifi_cleanup_wq until
+ *      the reference count becomes zero. It is time to wake it up now.
+ *
+ *  Arguments:
+ *      priv          Pointer to driver context.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void
+ask_unifi_sdio_cleanup(unifi_priv_t *priv)
+{
+    func_enter();
+
+    /*
+     * Now clear the flag that says the old instance is in use.
+     * This is used to prevent a new instance being started before old
+     * one has finshed closing down, for example if bounce makes the card
+     * appear to be ejected and re-inserted quickly.
+     */
+    In_use[priv->instance] = UNIFI_DEV_CLEANUP;
+
+    unifi_trace(NULL, UDBG5, "ask_unifi_sdio_cleanup: wake up cleanup workqueue.\n");
+    wake_up(&Unifi_cleanup_wq);
+
+    func_exit();
+
+} /* ask_unifi_sdio_cleanup() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  cleanup_unifi_sdio
+ *
+ *      Release any resources owned by a unifi instance.
+ *
+ *  Arguments:
+ *      priv          Pointer to the instance to free.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void
+cleanup_unifi_sdio(unifi_priv_t *priv)
+{
+    int priv_instance;
+    int i;
+    static const CsrWifiMacAddress broadcast_address = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};
+
+    func_enter();
+
+    /* Remove the device nodes */
+    uf_destroy_device_nodes(priv);
+
+    /* Mark this device as gone away by NULLing the entry in Unifi_instances */
+    Unifi_instances[priv->instance] = NULL;
+
+    unifi_trace(priv, UDBG5, "cleanup_unifi_sdio: remove_proc_entry\n");
+    /*
+     * Free the children of priv before unifi_free_netdevice() frees
+     * the priv struct
+     */
+    remove_proc_entry(priv->proc_entry_name, 0);
+
+
+    /* Unregister netdev as a client. */
+    if (priv->netdev_client) {
+        unifi_trace(priv, UDBG2, "Netdev client (id:%d s:0x%X) is unregistered\n",
+                priv->netdev_client->client_id, priv->netdev_client->sender_id);
+        ul_deregister_client(priv->netdev_client);
+    }
+
+    /* Destroy the SME related threads and parameters */
+    uf_sme_deinit(priv);
+
+#ifdef CSR_SME_USERSPACE
+    priv->smepriv = NULL;
+#endif
+
+    /* Free any packets left in the Rx queues */
+    for(i=0;i<CSR_WIFI_NUM_INTERFACES;i++)
+    {
+        uf_free_pending_rx_packets(priv, UF_UNCONTROLLED_PORT_Q, broadcast_address,i);
+        uf_free_pending_rx_packets(priv, UF_CONTROLLED_PORT_Q, broadcast_address,i);
+    }
+    /*
+     * We need to free the resources held by the core, which include tx skbs,
+     * otherwise we can not call unregister_netdev().
+     */
+    if (priv->card) {
+        unifi_trace(priv, UDBG5, "cleanup_unifi_sdio: free card\n");
+        unifi_coredump_free(priv->card);
+        unifi_free_card(priv->card);
+        priv->card = NULL;
+    }
+
+    /*
+     * Unregister the network device.
+     * We can not unregister the netdev before we release
+     * all pending packets in the core.
+     */
+    uf_unregister_netdev(priv);
+    priv->totalInterfaceCount = 0;
+
+    /* Clear the table of registered netdev_priv's */
+    for (i = 0; i < CSR_WIFI_NUM_INTERFACES; i++) {
+        Unifi_netdev_instances[priv->instance * CSR_WIFI_NUM_INTERFACES + i] = NULL;
+    }
+
+    unifi_trace(priv, UDBG5, "cleanup_unifi_sdio: uf_free_netdevice\n");
+    /*
+     * When uf_free_netdevice() returns, the priv is invalid
+     * so we need to remember the instance to clear the global flag later.
+     */
+    priv_instance = priv->instance;
+
+#ifdef CSR_WIFI_RX_PATH_SPLIT
+    flush_workqueue(priv->rx_workqueue);
+    destroy_workqueue(priv->rx_workqueue);
+    signal_buffer_free(priv,CSR_WIFI_RX_SIGNAL_BUFFER_SIZE);
+#endif
+
+    /* Priv is freed as part of the net_device */
+    uf_free_netdevice(priv);
+
+    /*
+     * Now clear the flag that says the old instance is in use.
+     * This is used to prevent a new instance being started before old
+     * one has finshed closing down, for example if bounce makes the card
+     * appear to be ejected and re-inserted quickly.
+     */
+    In_use[priv_instance] = UNIFI_DEV_NOT_IN_USE;
+
+    unifi_trace(NULL, UDBG5, "cleanup_unifi_sdio: DONE.\n");
+
+    func_exit();
+
+} /* cleanup_unifi_sdio() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unregister_unifi_sdio
+ *
+ *      Call from SDIO driver when it detects that UniFi has been removed.
+ *
+ *  Arguments:
+ *      bus_id          Number of the card that was ejected.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void
+unregister_unifi_sdio(int bus_id)
+{
+    unifi_priv_t *priv;
+    int interfaceTag=0;
+    u8 reason = CONFIG_IND_EXIT;
+
+    if ((bus_id < 0) || (bus_id >= MAX_UNIFI_DEVS)) {
+        unifi_error(NULL, "unregister_unifi_sdio: invalid device %d\n",
+                bus_id);
+        return;
+    }
+
+    priv = Unifi_instances[bus_id];
+    if (priv == NULL) {
+        unifi_error(priv, "unregister_unifi_sdio: device %d is not registered\n",
+                bus_id);
+        func_exit();
+        return;
+    }
+
+    /* Stop the network traffic before freeing the core. */
+    for(interfaceTag=0;interfaceTag<priv->totalInterfaceCount;interfaceTag++)
+    {
+        netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+        if(interfacePriv->netdev_registered)
+        {
+            netif_carrier_off(priv->netdev[interfaceTag]);
+            UF_NETIF_TX_STOP_ALL_QUEUES(priv->netdev[interfaceTag]);
+        }
+    }
+
+#ifdef CSR_NATIVE_LINUX
+    /*
+     * If the unifi thread was started, signal it to stop.  This
+     * should cause any userspace processes with open unifi device to
+     * close them.
+     */
+    uf_stop_thread(priv, &priv->bh_thread);
+
+    /* Unregister the interrupt handler */
+    if (csr_sdio_linux_remove_irq(priv->sdio)) {
+        unifi_notice(priv,
+                "csr_sdio_linux_remove_irq failed to talk to card.\n");
+    }
+
+    /* Ensure no MLME functions are waiting on a the mlme_event semaphore. */
+    uf_abort_mlme(priv);
+#endif /* CSR_NATIVE_LINUX */
+
+    ul_log_config_ind(priv, &reason, sizeof(u8));
+
+    /* Deregister the UDI hook from the core. */
+    unifi_remove_udi_hook(priv->card, logging_handler);
+
+    uf_put_instance(bus_id);
+
+    /*
+     * Wait until the device is cleaned up. i.e., when all userspace
+     * processes have closed any open unifi devices.
+     */
+    wait_event(Unifi_cleanup_wq, In_use[bus_id] == UNIFI_DEV_CLEANUP);
+    unifi_trace(NULL, UDBG5, "Received clean up event\n");
+
+    /* Now we can free the private context and the char device nodes */
+    cleanup_unifi_sdio(priv);
+
+} /* unregister_unifi_sdio() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_find_instance
+ *
+ *      Find the context structure for a given UniFi device instance.
+ *
+ *  Arguments:
+ *      inst            The instance number to look for.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+unifi_priv_t *
+uf_find_instance(int inst)
+{
+    if ((inst < 0) || (inst >= MAX_UNIFI_DEVS)) {
+        return NULL;
+    }
+    return Unifi_instances[inst];
+} /* uf_find_instance() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_find_priv
+ *
+ *      Find the device instance for a given context structure.
+ *
+ *  Arguments:
+ *      priv            The context structure pointer to look for.
+ *
+ *  Returns:
+ *      index of instance, -1 otherwise.
+ * ---------------------------------------------------------------------------
+ */
+int
+uf_find_priv(unifi_priv_t *priv)
+{
+    int inst;
+
+    if (!priv) {
+        return -1;
+    }
+
+    for (inst = 0; inst < MAX_UNIFI_DEVS; inst++) {
+        if (Unifi_instances[inst] == priv) {
+            return inst;
+        }
+    }
+
+    return -1;
+} /* uf_find_priv() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_find_netdev_priv
+ *
+ *      Find the device instance for a given netdev context structure.
+ *
+ *  Arguments:
+ *      priv            The context structure pointer to look for.
+ *
+ *  Returns:
+ *      index of instance, -1 otherwise.
+ * ---------------------------------------------------------------------------
+ */
+int
+uf_find_netdev_priv(netInterface_priv_t *priv)
+{
+    int inst;
+
+    if (!priv) {
+        return -1;
+    }
+
+    for (inst = 0; inst < MAX_UNIFI_DEVS * CSR_WIFI_NUM_INTERFACES; inst++) {
+        if (Unifi_netdev_instances[inst] == priv) {
+            return inst;
+        }
+    }
+
+    return -1;
+} /* uf_find_netdev_priv() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_get_instance
+ *
+ *      Find the context structure for a given UniFi device instance
+ *      and increment the reference count.
+ *
+ *  Arguments:
+ *      inst            The instance number to look for.
+ *
+ *  Returns:
+ *      Pointer to the instance or NULL if no instance exists.
+ * ---------------------------------------------------------------------------
+ */
+unifi_priv_t *
+uf_get_instance(int inst)
+{
+    unifi_priv_t *priv;
+
+    down(&Unifi_instance_mutex);
+
+    priv = uf_find_instance(inst);
+    if (priv) {
+        priv->ref_count++;
+    }
+
+    up(&Unifi_instance_mutex);
+
+    return priv;
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_put_instance
+ *
+ *      Decrement the context reference count, freeing resources and
+ *      shutting down the driver when the count reaches zero.
+ *
+ *  Arguments:
+ *      inst            The instance number to look for.
+ *
+ *  Returns:
+ *      Pointer to the instance or NULL if no instance exists.
+ * ---------------------------------------------------------------------------
+ */
+void
+uf_put_instance(int inst)
+{
+    unifi_priv_t *priv;
+
+    down(&Unifi_instance_mutex);
+
+    priv = uf_find_instance(inst);
+    if (priv) {
+        priv->ref_count--;
+        if (priv->ref_count == 0) {
+            ask_unifi_sdio_cleanup(priv);
+        }
+    }
+
+    up(&Unifi_instance_mutex);
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_read_proc
+ *
+ *      Read method for driver node in /proc/driver/unifi0
+ *
+ *  Arguments:
+ *      page
+ *      start
+ *      offset
+ *      count
+ *      eof
+ *      data
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+#ifdef CONFIG_PROC_FS
+static int
+uf_read_proc(char *page, char **start, off_t offset, int count,
+        int *eof, void *data)
+{
+#define UNIFI_DEBUG_TXT_BUFFER 8*1024
+    unifi_priv_t *priv;
+    int actual_amount_to_copy;
+    char *p, *orig_p;
+    CsrInt32 remain = UNIFI_DEBUG_TXT_BUFFER;
+    CsrInt32 written;
+    int i;
+
+    /*
+    * The following complex casting is in place in order to eliminate 64-bit compilation warning
+    * "cast to/from pointer from/to integer of different size"
+    */
+    priv = uf_find_instance((int)(long)data);
+    if (!priv) {
+        return 0;
+    }
+
+    p = kmalloc( UNIFI_DEBUG_TXT_BUFFER, GFP_KERNEL );
+
+    orig_p = p;
+
+    written = CsrSnprintf(p, remain, "UniFi SDIO Driver: %s %s %s\n",
+            CSR_WIFI_VERSION, __DATE__, __TIME__);
+    UNIFI_SNPRINTF_RET(p, remain, written);
+#ifdef CSR_SME_USERSPACE
+    written = CsrSnprintf(p, remain, "SME: CSR userspace ");
+    UNIFI_SNPRINTF_RET(p, remain, written);
+#ifdef CSR_SUPPORT_WEXT
+    written = CsrSnprintf(p, remain, "with WEXT support\n");
+#else
+    written = CsrSnprintf(p, remain, "\n");
+#endif /* CSR_SUPPORT_WEXT */
+    UNIFI_SNPRINTF_RET(p, remain, written);
+#endif /* CSR_SME_USERSPACE */
+#ifdef CSR_NATIVE_LINUX
+    written = CsrSnprintf(p, remain, "SME: native\n");
+    UNIFI_SNPRINTF_RET(p, remain, written);
+#endif
+
+#ifdef CSR_SUPPORT_SME
+    written = CsrSnprintf(p, remain,
+            "Firmware (ROM) build:%lu, Patch:%lu\n",
+            priv->card_info.fw_build,
+            priv->sme_versions.firmwarePatch);
+    UNIFI_SNPRINTF_RET(p, remain, written);
+#endif
+    p += unifi_print_status(priv->card, p, &remain);
+
+    written = CsrSnprintf(p, remain, "Last dbg str: %s\n",
+            priv->last_debug_string);
+    UNIFI_SNPRINTF_RET(p, remain, written);
+
+    written = CsrSnprintf(p, remain, "Last dbg16:");
+    UNIFI_SNPRINTF_RET(p, remain, written);
+    for (i = 0; i < 8; i++) {
+        written = CsrSnprintf(p, remain, " %04X",
+                priv->last_debug_word16[i]);
+        UNIFI_SNPRINTF_RET(p, remain, written);
+    }
+    written = CsrSnprintf(p, remain, "\n");
+    UNIFI_SNPRINTF_RET(p, remain, written);
+    written = CsrSnprintf(p, remain, "           ");
+    UNIFI_SNPRINTF_RET(p, remain, written);
+    for (; i < 16; i++) {
+        written = CsrSnprintf(p, remain, " %04X",
+                priv->last_debug_word16[i]);
+        UNIFI_SNPRINTF_RET(p, remain, written);
+    }
+    written = CsrSnprintf(p, remain, "\n");
+    UNIFI_SNPRINTF_RET(p, remain, written);
+    *start = page;
+
+    written = UNIFI_DEBUG_TXT_BUFFER - remain;
+
+    if( offset >= written )
+    {
+        *eof = 1;
+        kfree( orig_p );
+        return(0);
+    }
+
+    if( offset + count > written )
+    {
+        actual_amount_to_copy = written - offset;
+        *eof = 1;
+    }
+    else
+    {
+        actual_amount_to_copy = count;
+    }
+
+    memcpy( page, &(orig_p[offset]), actual_amount_to_copy );
+
+    kfree( orig_p );
+
+    return( actual_amount_to_copy );
+} /* uf_read_proc() */
+#endif
+
+
+
+
+static void
+uf_lx_suspend(CsrSdioFunction *sdio_ctx)
+{
+    unifi_priv_t *priv = sdio_ctx->driverData;
+    unifi_suspend(priv);
+
+    CsrSdioSuspendAcknowledge(sdio_ctx, CSR_RESULT_SUCCESS);
+}
+
+static void
+uf_lx_resume(CsrSdioFunction *sdio_ctx)
+{
+    unifi_priv_t *priv = sdio_ctx->driverData;
+    unifi_resume(priv);
+
+    CsrSdioResumeAcknowledge(sdio_ctx, CSR_RESULT_SUCCESS);
+}
+
+static int active_slot = MAX_UNIFI_DEVS;
+static struct device *os_devices[MAX_UNIFI_DEVS];
+
+void
+uf_add_os_device(int bus_id, struct device *os_device)
+{
+    if ((bus_id < 0) || (bus_id >= MAX_UNIFI_DEVS)) {
+        unifi_error(NULL, "uf_add_os_device: invalid device %d\n",
+                bus_id);
+        return;
+    }
+
+    active_slot = bus_id;
+    os_devices[bus_id] = os_device;
+} /* uf_add_os_device() */
+
+void
+uf_remove_os_device(int bus_id)
+{
+    if ((bus_id < 0) || (bus_id >= MAX_UNIFI_DEVS)) {
+        unifi_error(NULL, "uf_remove_os_device: invalid device %d\n",
+                bus_id);
+        return;
+    }
+
+    active_slot = bus_id;
+    os_devices[bus_id] = NULL;
+} /* uf_remove_os_device() */
+
+static void
+uf_sdio_inserted(CsrSdioFunction *sdio_ctx)
+{
+    unifi_priv_t *priv;
+
+    unifi_trace(NULL, UDBG5, "uf_sdio_inserted(0x%p), slot_id=%d, dev=%p\n",
+            sdio_ctx, active_slot, os_devices[active_slot]);
+
+    priv = register_unifi_sdio(sdio_ctx, active_slot, os_devices[active_slot]);
+    if (priv == NULL) {
+        CsrSdioInsertedAcknowledge(sdio_ctx, CSR_RESULT_FAILURE);
+        return;
+    }
+
+    sdio_ctx->driverData = priv;
+
+    CsrSdioInsertedAcknowledge(sdio_ctx, CSR_RESULT_SUCCESS);
+} /* uf_sdio_inserted() */
+
+
+static void
+uf_sdio_removed(CsrSdioFunction *sdio_ctx)
+{
+    unregister_unifi_sdio(active_slot);
+    CsrSdioRemovedAcknowledge(sdio_ctx);
+} /* uf_sdio_removed() */
+
+
+static void
+uf_sdio_dsr_handler(CsrSdioFunction *sdio_ctx)
+{
+    unifi_priv_t *priv = sdio_ctx->driverData;
+
+    unifi_sdio_interrupt_handler(priv->card);
+} /* uf_sdio_dsr_handler() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_sdio_int_handler
+ *
+ *      Interrupt callback function for SDIO interrupts.
+ *      This is called in kernel context (i.e. not interrupt context).
+ *      We retrieve the unifi context pointer and call the main UniFi
+ *      interrupt handler.
+ *
+ *  Arguments:
+ *      fdev      SDIO context pointer
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static CsrSdioInterruptDsrCallback
+uf_sdio_int_handler(CsrSdioFunction *sdio_ctx)
+{
+    return uf_sdio_dsr_handler;
+} /* uf_sdio_int_handler() */
+
+
+
+
+static CsrSdioFunctionId unifi_ids[] =
+{
+    {
+        .manfId = SDIO_MANF_ID_CSR,
+        .cardId = SDIO_CARD_ID_UNIFI_3,
+        .sdioFunction = SDIO_WLAN_FUNC_ID_UNIFI_3,
+        .sdioInterface = CSR_SDIO_ANY_SDIO_INTERFACE,
+    },
+    {
+        .manfId = SDIO_MANF_ID_CSR,
+        .cardId = SDIO_CARD_ID_UNIFI_4,
+        .sdioFunction = SDIO_WLAN_FUNC_ID_UNIFI_4,
+        .sdioInterface = CSR_SDIO_ANY_SDIO_INTERFACE,
+    }
+};
+
+
+/*
+ * Structure to register with the glue layer.
+ */
+static CsrSdioFunctionDriver unifi_sdioFunction_drv =
+{
+    .inserted = uf_sdio_inserted,
+    .removed = uf_sdio_removed,
+    .intr = uf_sdio_int_handler,
+    .suspend = uf_lx_suspend,
+    .resume = uf_lx_resume,
+
+    .ids = unifi_ids,
+    .idsCount = sizeof(unifi_ids) / sizeof(unifi_ids[0])
+};
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_sdio_load
+ *  uf_sdio_unload
+ *
+ *      These functions are called from the main module load and unload
+ *      functions. They perform the appropriate operations for the monolithic
+ *      driver.
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+int __init
+uf_sdio_load(void)
+{
+    CsrResult csrResult;
+
+    csrResult = CsrSdioFunctionDriverRegister(&unifi_sdioFunction_drv);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(NULL, "Failed to register UniFi SDIO driver: csrResult=%d\n", csrResult);
+        return -EIO;
+    }
+
+    return 0;
+} /* uf_sdio_load() */
+
+
+
+void __exit
+uf_sdio_unload(void)
+{
+    CsrSdioFunctionDriverUnregister(&unifi_sdioFunction_drv);
+} /* uf_sdio_unload() */
+
--- /dev/null
+++ b/drivers/staging/csr/mlme.c
@@ -0,0 +1,441 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     mlme.c
+ *
+ * PURPOSE:
+ *      This file provides functions to send MLME requests to the UniFi.
+ *
+ * Copyright (C) 2007-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "unifi_priv.h"
+
+
+/* The additional time taken by the UniFi to do a scan per channel */
+#define SCAN_STARTUP_TIME       300 /* in millisecs */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * unifi_mlme_wait_for_reply
+ *
+ *      Wait for a reply after sending a signal.
+ *
+ * Arguments:
+ *      priv            Pointer to device private context struct
+ *      ul_client       Pointer to linux client
+ *      sig_reply_id    ID of the expected reply (defined in sigs.h).
+ *      timeout         timeout in ms
+ *
+ * Returns:
+ *      0 on success, -ve POSIX code on error.
+ *
+ * Notes:
+ *      This function waits for a specific (sig_reply_id) signal from UniFi.
+ *      It also match the sequence number of the received (cfm) signal, with
+ *      the latest sequence number of the signal (req) we have sent.
+ *      These two number match be equal.
+ *      Should only be used for waiting xxx.cfm signals and only after
+ *      we have sent the matching xxx.req signal to UniFi.
+ *      If no response is received within the expected time (timeout), we assume
+ *      that the UniFi is busy and return an error.
+ *      If the wait is aborted by a kernel signal arriving, we stop waiting.
+ *      If a response from UniFi is not what we expected, we discard it and
+ *      wait again. This could be a response from an aborted request. If we
+ *      see several bad responses we assume we have lost synchronisation with
+ *      UniFi.
+ * ---------------------------------------------------------------------------
+ */
+static int
+unifi_mlme_wait_for_reply(unifi_priv_t *priv, ul_client_t *pcli, int sig_reply_id, int timeout)
+{
+    int retries = 0;
+    long r;
+    long t = timeout;
+    unsigned int sent_seq_no;
+
+    /* Convert t in ms to jiffies */
+    t = msecs_to_jiffies(t);
+
+    do {
+        /* Wait for the confirm or timeout. */
+        r = wait_event_interruptible_timeout(pcli->udi_wq,
+                                             (pcli->wake_up_wq_id) || (priv->io_aborted == 1),
+                                             t);
+        /* Check for general i/o error */
+        if (priv->io_aborted) {
+            unifi_error(priv, "MLME operation aborted\n");
+            return -EIO;
+        }
+
+        /*
+         * If r=0 the request has timed-out.
+         * If r>0 the request has completed successfully.
+         * If r=-ERESTARTSYS an event (kill signal) has interrupted the wait_event.
+         */
+        if ((r == 0) && (pcli->wake_up_wq_id == 0)) {
+            unifi_error(priv, "mlme_wait: timed-out waiting for 0x%.4X, after %lu msec.\n",
+                        sig_reply_id,  jiffies_to_msecs(t));
+            pcli->wake_up_wq_id = 0;
+            return -ETIMEDOUT;
+        } else if (r == -ERESTARTSYS) {
+            unifi_error(priv, "mlme_wait: waiting for 0x%.4X was aborted.\n", sig_reply_id);
+            pcli->wake_up_wq_id = 0;
+            return -EINTR;
+        } else {
+            /* Get the sequence number of the signal that we previously set. */
+            if (pcli->seq_no != 0) {
+                sent_seq_no = pcli->seq_no - 1;
+            } else {
+                sent_seq_no = 0x0F;
+            }
+
+            unifi_trace(priv, UDBG5, "Received 0x%.4X, seq: (r:%d, s:%d)\n",
+                        pcli->wake_up_wq_id,
+                        pcli->wake_seq_no, sent_seq_no);
+
+            /* The two sequence ids must match. */
+            if (pcli->wake_seq_no == sent_seq_no) {
+                /* and the signal ids must match. */
+                if (sig_reply_id == pcli->wake_up_wq_id) {
+                    /* Found the expected signal */
+                    break;
+                } else {
+                    /* This should never happen ... */
+                    unifi_error(priv, "mlme_wait: mismatching signal id (0x%.4X - exp 0x%.4X) (seq %d)\n",
+                                pcli->wake_up_wq_id,
+                                sig_reply_id,
+                                pcli->wake_seq_no);
+                    pcli->wake_up_wq_id = 0;
+                    return -EIO;
+                }
+            }
+            /* Wait for the next signal. */
+            pcli->wake_up_wq_id = 0;
+
+            retries ++;
+            if (retries >= 3) {
+                unifi_error(priv, "mlme_wait: confirm wait retries exhausted (0x%.4X - exp 0x%.4X)\n",
+                            pcli->wake_up_wq_id,
+                            sig_reply_id);
+                pcli->wake_up_wq_id = 0;
+                return -EIO;
+            }
+        }
+    } while (1);
+
+    pcli->wake_up_wq_id = 0;
+
+    return 0;
+} /* unifi_mlme_wait_for_reply() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * unifi_mlme_blocking_request
+ *
+ *      Send a MLME request signal to UniFi.
+ *
+ * Arguments:
+ *      priv            Pointer to device private context struct
+ *      pcli            Pointer to context of calling process
+ *      sig             Pointer to the signal to send
+ *      data_ptrs       Pointer to the bulk data of the signal
+ *      timeout         The request's timeout.
+ *
+ * Returns:
+ *      0 on success, 802.11 result code on error.
+ * ---------------------------------------------------------------------------
+ */
+int
+unifi_mlme_blocking_request(unifi_priv_t *priv, ul_client_t *pcli,
+                            CSR_SIGNAL *sig, bulk_data_param_t *data_ptrs,
+                            int timeout)
+{
+    int r;
+
+    func_enter();
+
+    if (sig->SignalPrimitiveHeader.SignalId == 0) {
+        unifi_error(priv, "unifi_mlme_blocking_request: Invalid Signal Id (0x%x)\n",
+                    sig->SignalPrimitiveHeader.SignalId);
+        return -EINVAL;
+    }
+
+    down(&priv->mlme_blocking_mutex);
+
+    sig->SignalPrimitiveHeader.ReceiverProcessId = 0;
+    sig->SignalPrimitiveHeader.SenderProcessId = pcli->sender_id | pcli->seq_no;
+
+    unifi_trace(priv, UDBG2, "Send client=%d, S:0x%04X, sig 0x%.4X\n",
+                pcli->client_id,
+                sig->SignalPrimitiveHeader.SenderProcessId,
+                sig->SignalPrimitiveHeader.SignalId);
+    /* Send the signal to UniFi */
+    r = ul_send_signal_unpacked(priv, sig, data_ptrs);
+    if (r) {
+        up(&priv->mlme_blocking_mutex);
+        unifi_error(priv, "Error queueing MLME REQUEST signal\n");
+        return r;
+    }
+
+    unifi_trace(priv, UDBG5, "Send 0x%.4X, seq = %d\n",
+                sig->SignalPrimitiveHeader.SignalId, pcli->seq_no);
+
+    /*
+     * Advance the sequence number of the last sent signal, only
+     * if the signal has been successfully set.
+     */
+    pcli->seq_no++;
+    if (pcli->seq_no > 0x0F) {
+        pcli->seq_no = 0;
+    }
+
+    r = unifi_mlme_wait_for_reply(priv, pcli, (sig->SignalPrimitiveHeader.SignalId + 1), timeout);
+    up(&priv->mlme_blocking_mutex);
+
+    if (r) {
+        unifi_error(priv, "Error waiting for MLME CONFIRM signal\n");
+        return r;
+    }
+
+    func_exit();
+    return 0;
+} /* unifi_mlme_blocking_request() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_mlme_copy_reply_and_wakeup_client
+ *
+ *      Copy the reply signal from UniFi to the client's structure
+ *      and wake up the waiting client.
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+unifi_mlme_copy_reply_and_wakeup_client(ul_client_t *pcli,
+                                        CSR_SIGNAL *signal, int signal_len,
+                                        const bulk_data_param_t *bulkdata)
+{
+    int i;
+
+    /* Copy the signal to the reply */
+    memcpy(pcli->reply_signal, signal, signal_len);
+
+    /* Get the sequence number of the signal that woke us up. */
+    pcli->wake_seq_no = pcli->reply_signal->SignalPrimitiveHeader.ReceiverProcessId & 0x0F;
+
+    /* Append any bulk data */
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+        if (bulkdata->d[i].data_length > 0) {
+            if (bulkdata->d[i].os_data_ptr) {
+                memcpy(pcli->reply_bulkdata[i]->ptr, bulkdata->d[i].os_data_ptr, bulkdata->d[i].data_length);
+                pcli->reply_bulkdata[i]->length = bulkdata->d[i].data_length;
+            } else {
+                pcli->reply_bulkdata[i]->length = 0;
+            }
+        }
+    }
+
+    /* Wake the requesting MLME function. */
+    pcli->wake_up_wq_id = pcli->reply_signal->SignalPrimitiveHeader.SignalId;
+    wake_up_interruptible(&pcli->udi_wq);
+
+} /* unifi_mlme_copy_reply_and_wakeup_client() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_abort_mlme
+ *
+ *      Abort any MLME operation in progress.
+ *      This is used in the error recovery mechanism.
+ *
+ *  Arguments:
+ *      priv          Pointer to driver context.
+ *
+ *  Returns:
+ *      0 on success.
+ * ---------------------------------------------------------------------------
+ */
+int
+uf_abort_mlme(unifi_priv_t *priv)
+{
+    ul_client_t *ul_cli;
+
+    /* Ensure no MLME functions are waiting on a the mlme_event semaphore. */
+    priv->io_aborted = 1;
+
+    ul_cli = priv->netdev_client;
+    if (ul_cli) {
+        wake_up_interruptible(&ul_cli->udi_wq);
+    }
+
+    ul_cli = priv->wext_client;
+    if (ul_cli) {
+        wake_up_interruptible(&ul_cli->udi_wq);
+    }
+
+    return 0;
+} /* uf_abort_mlme() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ *      Human-readable decoding of Reason and Result codes.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+struct mlme_code {
+    const char *name;
+    int id;
+};
+
+static const struct mlme_code Result_codes[] = {
+    { "Success",                             0x0000 },
+    { "Unspecified Failure",                 0x0001 },
+    /* (Reserved)                      0x0002 - 0x0009 */
+    { "Refused Capabilities Mismatch",       0x000A },
+    /* (Reserved)                          0x000B */
+    { "Refused External Reason",             0x000C },
+    /* (Reserved)                      0x000D - 0x0010 */
+    { "Refused AP Out Of Memory",            0x0011 },
+    { "Refused Basic Rates Mismatch",        0x0012 },
+    /* (Reserved)                      0x0013 - 0x001F */
+    { "Failure",                             0x0020 },
+    /* (Reserved)                      0x0021 - 0x0024 */
+    { "Refused Reason Unspecified",          0x0025 },
+    { "Invalid Parameters",                  0x0026 },
+    { "Rejected With Suggested Changes",     0x0027 },
+    /* (Reserved)                      0x0028 - 0x002E */
+    { "Rejected For Delay Period",           0x002F },
+    { "Not Allowed",                         0x0030 },
+    { "Not Present",                         0x0031 },
+    { "Not QSTA",                            0x0032 },
+    /* (Reserved)                      0x0033 - 0x7FFF */
+    { "Timeout",                             0x8000 },
+    { "Too Many Simultaneous Requests",      0x8001 },
+    { "BSS Already Started Or Joined",       0x8002 },
+    { "Not Supported",                       0x8003 },
+    { "Transmission Failure",                0x8004 },
+    { "Refused Not Authenticated",           0x8005 },
+    { "Reset Required Before Start",         0x8006 },
+    { "LM Info Unavailable",                 0x8007 },
+    { NULL, -1 }
+};
+
+static const struct mlme_code Reason_codes[] = {
+    /* (Reserved)                      0x0000 */
+    { "Unspecified Reason",              0x0001 },
+    { "Authentication Not Valid",        0x0002 },
+    { "Deauthenticated Leave BSS",       0x0003 },
+    { "Disassociated Inactivity",        0x0004 },
+    { "AP Overload",                     0x0005 },
+    { "Class2 Frame Error",              0x0006 },
+    { "Class3 Frame Error",              0x0007 },
+    { "Disassociated Leave BSS",         0x0008 },
+    { "Association Not Authenticated",   0x0009 },
+    { "Disassociated Power Capability",  0x000A },
+    { "Disassociated Supported Channels", 0x000B },
+    /* (Reserved)                      0x000C */
+    { "Invalid Information Element",     0x000D },
+    { "Michael MIC Failure",             0x000E },
+    { "Fourway Handshake Timeout",       0x000F },
+    { "Group Key Update Timeout",        0x0010 },
+    { "Handshake Element Different",     0x0011 },
+    { "Invalid Group Cipher",            0x0012 },
+    { "Invalid Pairwise Cipher",         0x0013 },
+    { "Invalid AKMP",                    0x0014 },
+    { "Unsupported RSN IE Version",      0x0015 },
+    { "Invalid RSN IE Capabilities",     0x0016 },
+    { "Dot1X Auth Failed",               0x0017 },
+    { "Cipher Rejected By Policy",       0x0018 },
+    /* (Reserved)                  0x0019 - 0x001F */
+    { "QoS Unspecified Reason",          0x0020 },
+    { "QoS Insufficient Bandwidth",      0x0021 },
+    { "QoS Excessive Not Ack",           0x0022 },
+    { "QoS TXOP Limit Exceeded",         0x0023 },
+    { "QSTA Leaving",                    0x0024 },
+    { "End TS, End DLS, End BA",         0x0025 },
+    { "Unknown TS, Unknown DLS, Unknown BA", 0x0026 },
+    { "Timeout",                         0x0027 },
+    /* (Reserved)                  0x0028 - 0x002C */
+    { "STAKey Mismatch",                 0x002D },
+    { NULL, -1 }
+};
+
+
+static const char *
+lookup_something(const struct mlme_code *n, int id)
+{
+    for (; n->name; n++) {
+        if (n->id == id) {
+            return n->name;
+        }
+    }
+
+    /* not found */
+    return NULL;
+} /* lookup_something() */
+
+
+const char *
+lookup_result_code(int result)
+{
+    static char fallback[16];
+    const char *str;
+
+    str = lookup_something(Result_codes, result);
+
+    if (str == NULL) {
+        snprintf(fallback, 16, "%d", result);
+        str = fallback;
+    }
+
+    return str;
+} /* lookup_result_code() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  lookup_reason
+ *
+ *      Return a description string for a WiFi MLME ReasonCode.
+ *
+ *  Arguments:
+ *      reason          The ReasonCode to interpret.
+ *
+ *  Returns:
+ *      Pointer to description string.
+ * ---------------------------------------------------------------------------
+ */
+const char *
+lookup_reason_code(int reason)
+{
+    static char fallback[16];
+    const char *str;
+
+    str = lookup_something(Reason_codes, reason);
+
+    if (str == NULL) {
+        snprintf(fallback, 16, "%d", reason);
+        str = fallback;
+    }
+
+    return str;
+} /* lookup_reason_code() */
+
--- /dev/null
+++ b/drivers/staging/csr/monitor.c
@@ -0,0 +1,458 @@
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     monitor.c
+ *
+ * Copyright (C) 2006-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+#include "unifi_priv.h"
+
+#ifdef UNIFI_SNIFF_ARPHRD
+
+
+#if (UNIFI_SNIFF_ARPHRD == ARPHRD_IEEE80211_RADIOTAP)
+#include <net/ieee80211_radiotap.h>
+#endif
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW ETH_P_ALL
+#endif
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_start_sniff
+ *
+ *      Start UniFi capture in SNIFF mode, i.e capture everything it hears.
+ *
+ *  Arguments:
+ *      priv            Pointer to device private context struct
+ *
+ *  Returns:
+ *      0 on success or kernel error code
+ * ---------------------------------------------------------------------------
+ */
+int
+uf_start_sniff(unifi_priv_t *priv)
+{
+    ul_client_t *pcli = priv->wext_client;
+    CSR_SIGNAL signal;
+    CSR_MLME_SNIFFJOIN_REQUEST *req = &signal.u.MlmeSniffjoinRequest;
+    int timeout = 1000;
+    int r;
+
+    req->Ifindex = priv->if_index;
+    req->Channel = priv->wext_conf.channel;
+    req->ChannelStartingFactor = 0;
+
+#if 0
+    printk("SniffJoin: Ifindex=%d, Channel=%d, ChannelStartingFactor=%d\n",
+           req->Ifindex,
+           req->Channel,
+           req->ChannelStartingFactor);
+#endif
+
+    signal.SignalPrimitiveHeader.SignalId = CSR_MLME_SNIFFJOIN_REQUEST_ID;
+
+    r = unifi_mlme_blocking_request(priv, pcli, &signal, NULL, timeout);
+    if (r < 0) {
+        unifi_error(priv, "failed to send SNIFFJOIN request, error %d\n", r);
+        return r;
+    }
+
+    r = pcli->reply_signal->u.MlmeSniffjoinConfirm.Resultcode;
+    if (r) {
+        unifi_notice(priv, "SNIFFJOIN request was rejected with result 0x%X (%s)\n",
+                     r, lookup_result_code(r));
+        return -EIO;
+    }
+
+    return 0;
+} /* uf_start_sniff() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * netrx_radiotap
+ *
+ *      Reformat a UniFi SNIFFDATA signal into a radiotap packet.
+ *
+ * Arguments:
+ *      priv            OS private context pointer.
+ *      ind             Pointer to a MA_UNITDATA_INDICATION or
+ *                      DS_UNITDATA_INDICATION indication structure.
+ *
+ * Notes:
+ *      Radiotap header values are all little-endian, UniFi signals will have
+ *      been converted to host-endian.
+ * ---------------------------------------------------------------------------
+ */
+#if (UNIFI_SNIFF_ARPHRD == ARPHRD_IEEE80211_RADIOTAP)
+static void
+netrx_radiotap(unifi_priv_t *priv,
+               const CSR_MA_SNIFFDATA_INDICATION *ind,
+               struct sk_buff *skb_orig)
+{
+    struct net_device *dev = priv->netdev;
+    struct sk_buff *skb = NULL;
+    unsigned char *ptr;
+    unsigned char *base;
+    int ind_data_len = skb_orig->len - 2 - ETH_HLEN;
+    struct unifi_rx_radiotap_header {
+        struct ieee80211_radiotap_header rt_hdr;
+        /* IEEE80211_RADIOTAP_TSFT */
+        u64 rt_tsft;
+        /* IEEE80211_RADIOTAP_FLAGS */
+        u8  rt_flags;
+        /* IEEE80211_RADIOTAP_RATE */
+        u8  rt_rate;
+        /* IEEE80211_RADIOTAP_CHANNEL */
+        u16 rt_chan;
+        u16 rt_chan_flags;
+        /* IEEE80211_RADIOTAP_DBM_ANTSIGNAL */
+        u8  rt_dbm_antsignal;
+        /* IEEE80211_RADIOTAP_DBM_ANTNOISE */
+        u8  rt_dbm_antnoise;
+        /* IEEE80211_RADIOTAP_ANTENNA */
+        u8  rt_antenna;
+
+        /* pad to 4-byte boundary */
+        u8 pad[3];
+    } __attribute__((__packed__));
+
+    struct unifi_rx_radiotap_header *unifi_rt;
+    int signal, noise, snr;
+
+    func_enter();
+
+    if (ind_data_len <= 0) {
+        unifi_error(priv, "Invalid length in CSR_MA_SNIFFDATA_INDICATION.\n");
+        return;
+    }
+
+    /*
+     * Allocate a SKB for the received data packet, including radiotap
+     * header.
+     */
+    skb = dev_alloc_skb(ind_data_len + sizeof(struct unifi_rx_radiotap_header) + 4);
+    if (! skb) {
+        unifi_error(priv, "alloc_skb failed.\n");
+        priv->stats.rx_errors++;
+        return;
+    }
+
+    base = skb->data;
+
+    /* Reserve the radiotap header at the front of skb */
+    unifi_rt = (struct unifi_rx_radiotap_header *)
+        skb_put(skb, sizeof(struct unifi_rx_radiotap_header));
+
+    /* Copy in the 802.11 frame */
+    ptr = skb_put(skb, ind_data_len);
+    memcpy(ptr, skb_orig->data, ind_data_len);
+
+    unifi_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;
+    unifi_rt->rt_hdr.it_pad = 0;	/* always good to zero */
+    unifi_rt->rt_hdr.it_len = sizeof(struct unifi_rx_radiotap_header);
+
+    /* Big bitfield of all the fields we provide in radiotap */
+    unifi_rt->rt_hdr.it_present = 0
+        | (1 << IEEE80211_RADIOTAP_TSFT)
+        | (1 << IEEE80211_RADIOTAP_FLAGS)
+        | (1 << IEEE80211_RADIOTAP_RATE)
+        | (1 << IEEE80211_RADIOTAP_CHANNEL)
+        | (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL)
+        | (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE)
+        | (1 << IEEE80211_RADIOTAP_ANTENNA)
+        ;
+
+
+    /* No flags to set */
+    unifi_rt->rt_tsft = (((u64)ind->Timestamp.x[7]) | (((u64)ind->Timestamp.x[6]) << 8) |
+                         (((u64)ind->Timestamp.x[5]) << 16) | (((u64)ind->Timestamp.x[4]) << 24) |
+                         (((u64)ind->Timestamp.x[3]) << 32) | (((u64)ind->Timestamp.x[2]) << 40) |
+                         (((u64)ind->Timestamp.x[1]) << 48) | (((u64)ind->Timestamp.x[0]) << 56));
+
+    unifi_rt->rt_flags = 0;
+
+    unifi_rt->rt_rate = ind->Rate;
+
+    unifi_rt->rt_chan = cpu_to_le16(ieee80211chan2mhz(priv->wext_conf.channel));
+    unifi_rt->rt_chan_flags = 0;
+
+    /* Convert signal to dBm */
+    signal = (s16)unifi2host_16(ind->Rssi);  /* in dBm */
+    snr    = (s16)unifi2host_16(ind->Snr);   /* in dB */
+    noise  = signal - snr;
+
+    unifi_rt->rt_dbm_antsignal = signal;
+    unifi_rt->rt_dbm_antnoise = noise;
+
+    unifi_rt->rt_antenna = ind->AntennaId;
+
+
+#if 0
+    printk("skb datalen=%d\n", skb->len);
+    dump(skb->data, 48);
+#endif
+
+    skb->dev = dev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+    skb->mac_header = skb->data;
+#else
+    skb->mac.raw = skb->data;
+#endif
+    skb->pkt_type = PACKET_OTHERHOST;
+    skb->protocol = __constant_htons(ETH_P_80211_RAW);
+    memset(skb->cb, 0, sizeof(skb->cb));
+
+    /* Pass up to Linux network stack */
+    netif_rx_ni(skb);
+
+    dev->last_rx = jiffies;
+
+    /* Bump the rx stats */
+    priv->stats.rx_packets++;
+    priv->stats.rx_bytes += ind_data_len;
+
+    func_exit();
+} /* netrx_radiotap() */
+#endif /* RADIOTAP */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * netrx_prism
+ *
+ *      Reformat a UniFi SNIFFDATA signal into a Prism format sniff packet.
+ *
+ * Arguments:
+ *      priv            OS private context pointer.
+ *      ind             Pointer to a MA_UNITDATA_INDICATION or
+ *                      DS_UNITDATA_INDICATION indication structure.
+ *
+ * Notes:
+ *      Radiotap header values are all little-endian, UniFi signals will have
+ *      been converted to host-endian.
+ * ---------------------------------------------------------------------------
+ */
+#if (UNIFI_SNIFF_ARPHRD == ARPHRD_IEEE80211_PRISM)
+static void
+netrx_prism(unifi_priv_t *priv,
+            const CSR_MA_SNIFFDATA_INDICATION *ind,
+            struct sk_buff *skb_orig)
+{
+    struct net_device *dev = priv->netdev;
+    struct sk_buff *skb = NULL;
+    unsigned char *ptr;
+    unsigned char *base;
+    int ind_data_len = skb_orig->len - 2 - ETH_HLEN;
+#define WLANCAP_MAGIC_COOKIE_BASE 0x80211000
+#define WLANCAP_MAGIC_COOKIE_V1 0x80211001
+#define WLANCAP_MAGIC_COOKIE_V2 0x80211002
+    struct avs_header_v1 {
+        uint32  version;
+        uint32  length;
+        uint64  mactime;
+        uint64  hosttime;
+        uint32  phytype;
+        uint32  channel;
+        uint32  datarate;
+        uint32  antenna;
+        uint32  priority;
+        uint32  ssi_type;
+        int32   ssi_signal;
+        int32   ssi_noise;
+        uint32  preamble;
+        uint32  encoding;
+    } *avs;
+    int signal, noise, snr;
+
+    func_enter();
+
+    if (ind_data_len <= 0) {
+        unifi_error(priv, "Invalid length in CSR_MA_SNIFFDATA_INDICATION.\n");
+        return;
+    }
+
+#if 0
+    printk("MA-SINFFDATA.ind: DataLen=%d bytes, TSF %02X %02X %02X %02X %02X %02X %02X %02X, Rate=%d, Antenna=%d\n",
+           ind->Data.DataLength,
+           ind->Timestamp.x[0],
+           ind->Timestamp.x[1],
+           ind->Timestamp.x[2],
+           ind->Timestamp.x[3],
+           ind->Timestamp.x[4],
+           ind->Timestamp.x[5],
+           ind->Timestamp.x[6],
+           ind->Timestamp.x[7],
+           ind->Rate,
+           ind->Antenna);
+
+    printk("payload, len %d\n", length);
+    dump((unsigned char *)payload, 32);
+#endif
+
+    /*
+     * Allocate a SKB for the received data packet, including radiotap
+     * header.
+     */
+    skb = dev_alloc_skb(ind_data_len + sizeof(struct avs_header_v1) + 4);
+    if (! skb) {
+        unifi_error(priv, "alloc_skb failed.\n");
+        priv->stats.rx_errors++;
+        return;
+    }
+
+    base = skb->data;
+
+    /* Reserve the radiotap header at the front of skb */
+    avs = (struct avs_header_v1 *)skb_put(skb, sizeof(struct avs_header_v1));
+
+    /* Copy in the 802.11 frame */
+    ptr = skb_put(skb, ind_data_len);
+    memcpy(ptr, skb_orig->data, ind_data_len);
+
+    /* Convert signal to dBm */
+    signal = 0x10000 - ((s16)unifi2host_16(ind->Rssi));  /* in dBm */
+    snr    = (s16)unifi2host_16(ind->Snr);   /* in dB */
+    noise  = signal - snr;
+
+    avs->version        = htonl(WLANCAP_MAGIC_COOKIE_V1);
+    avs->length         = htonl(sizeof(struct avs_header_v1));
+    avs->mactime        = __cpu_to_be64(ind->Timestamp);
+    avs->hosttime       = __cpu_to_be64(jiffies);
+    avs->phytype        = htonl(9);             /* dss_ofdm_dot11_g */
+    avs->channel        = htonl(priv->wext_conf.channel);
+    avs->datarate       = htonl(ind->Rate * 5);
+    avs->antenna        = htonl(ind->Antenna);
+    avs->priority       = htonl(0);             /* unknown */
+    avs->ssi_type       = htonl(2);             /* dBm */
+    avs->ssi_signal     = htonl(signal);
+    avs->ssi_noise      = htonl(noise);
+    avs->preamble       = htonl(0); /* unknown */
+    avs->encoding       = htonl(0); /* unknown */
+
+
+#if 0
+    printk("skb datalen=%d\n", skb->len);
+    dump(skb->data, 48);
+#endif
+
+    skb->dev = dev;
+    skb->mac.raw = skb->data;
+    skb->pkt_type = PACKET_OTHERHOST;
+    skb->protocol = __constant_htons(ETH_P_80211_RAW);
+    memset(skb->cb, 0, sizeof(skb->cb));
+
+    /* Pass up to Linux network stack */
+    netif_rx_ni(skb);
+
+    dev->last_rx = jiffies;
+
+    /* Bump the rx stats */
+    priv->stats.rx_packets++;
+    priv->stats.rx_bytes += ind_data_len;
+
+    func_exit();
+} /* netrx_prism() */
+#endif /* PRISM */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * ma_sniffdata_ind
+ *
+ *      Reformat a UniFi SNIFFDATA signal into a network
+ *
+ * Arguments:
+ *      ospriv          OS private context pointer.
+ *      ind             Pointer to a MA_UNITDATA_INDICATION or
+ *                      DS_UNITDATA_INDICATION indication structure.
+ *      bulkdata        Pointer to a bulk data structure, describing
+ *                      the data received.
+ *
+ * Notes:
+ *      Radiotap header values are all little-endian, UniFi signals will have
+ *      been converted to host-endian.
+ * ---------------------------------------------------------------------------
+ */
+void
+ma_sniffdata_ind(void *ospriv,
+                 const CSR_MA_SNIFFDATA_INDICATION *ind,
+                 const bulk_data_param_t *bulkdata)
+{
+    unifi_priv_t *priv = ospriv;
+    struct net_device *dev = priv->netdev;
+    struct sk_buff *skb = (struct sk_buff*)bulkdata->d[0].os_net_buf_ptr;
+
+    func_enter();
+
+    if (bulkdata->d[0].data_length == 0) {
+        unifi_warning(priv, "rx: MA-SNIFFDATA indication with zero bulk data\n");
+        func_exit();
+        return;
+    }
+
+    skb->len = bulkdata->d[0].data_length;
+#if 0
+    printk("MA-SNIFFDATA.ind: DataLen=%d bytes, TSF %02X %02X %02X %02X %02X %02X %02X %02X, Rate=%d, Antenna=%d\n",
+           ind->Data.DataLength,
+           ind->Timestamp.x[0],
+           ind->Timestamp.x[1],
+           ind->Timestamp.x[2],
+           ind->Timestamp.x[3],
+           ind->Timestamp.x[4],
+           ind->Timestamp.x[5],
+           ind->Timestamp.x[6],
+           ind->Timestamp.x[7],
+           ind->Rate,
+           ind->AntennaId);
+
+    printk("payload, len %lu\n", bulkdata->d[0].data_length);
+    if (bulkdata->d[0].os_data_ptr && (bulkdata->d[0].data_length >= 32)) {
+        dump((unsigned char *)bulkdata->d[0].os_data_ptr, 32);
+    }
+#endif
+
+    /* We only process data packets if the interface is open */
+    if (unlikely(!netif_running(dev))) {
+        priv->stats.rx_dropped++;
+        priv->wext_conf.wireless_stats.discard.misc++;
+#if 0
+        printk("Dropping packet while interface is not up.\n");
+#endif
+        dev_kfree_skb(skb);
+        return;
+    }
+
+    if (ind->ReceptionStatus) {
+        priv->stats.rx_dropped++;
+        priv->wext_conf.wireless_stats.discard.misc++;
+        printk(KERN_INFO "unifi: Dropping corrupt sniff packet\n");
+        dev_kfree_skb(skb);
+        return;
+    }
+
+#if (UNIFI_SNIFF_ARPHRD == ARPHRD_IEEE80211_PRISM)
+    netrx_prism(priv, ind, skb);
+#endif /* PRISM */
+
+#if (UNIFI_SNIFF_ARPHRD == ARPHRD_IEEE80211_RADIOTAP)
+    netrx_radiotap(priv, ind, skb);
+#endif /* RADIOTAP */
+
+    dev_kfree_skb(skb);
+
+} /* ma_sniffdata_ind() */
+
+
+#endif /* UNIFI_SNIFF_ARPHRD */
+
--- /dev/null
+++ b/drivers/staging/csr/netdev.c
@@ -0,0 +1,3902 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     netdev.c
+ *
+ * PURPOSE:
+ *      This file provides the upper edge interface to the linux netdevice
+ *      and wireless extensions.
+ *      It is part of the porting exercise.
+ *
+ * Copyright (C) 2005-2010 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+
+/*
+ * Porting Notes:
+ * This file implements the data plane of the UniFi linux driver.
+ *
+ * All the Tx packets are passed to the HIP core lib, using the
+ * unifi_send_signal() API. For EAPOL packets use the MLME-EAPOL.req
+ * signal, for all other use the MLME-UNITDATA.req. The unifi_send_signal()
+ * expects the wire-formatted (packed) signal. For convenience, in the OS
+ * layer we only use the native (unpacked) signal structures. The HIP core lib
+ * provides the write_pack() helper function to convert to the packed signal.
+ * The packet is stored in the bulk data of the signal. We do not need to
+ * allocate new memory to store the packet, because unifi_net_data_malloc()
+ * is implemented to return a skb, which is the format of packet in Linux.
+ * The HIP core lib frees the bulk data buffers, so we do not need to do
+ * this in the OS layer.
+ *
+ * All the Rx packets are MLME-UNITDATA.ind signals, passed by the HIP core lib
+ * in unifi_receive_event(). We do not need to allocate an skb and copy the
+ * received packet because the HIP core lib has stored in memory allocated by
+ * unifi_net_data_malloc(). Also, we can perform the 802.11 to Ethernet
+ * translation in-place because we allocate the extra memory allocated in
+ * unifi_net_data_malloc().
+ *
+ * If possible, the porting exercise should appropriately implement
+ * unifi_net_data_malloc() and unifi_net_data_free() to save copies between
+ * network and driver buffers.
+ */
+
+#include <linux/types.h>
+#include <linux/etherdevice.h>
+#include <linux/mutex.h>
+#include <linux/semaphore.h>
+
+#include <linux/vmalloc.h>
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_conversions.h"
+#include "unifi_priv.h"
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+#include <net/iw_handler.h>
+#endif
+#include <net/pkt_sched.h>
+
+
+/* ALLOW_Q_PAUSE: Pre 2.6.28 kernels do not support multiple driver queues (required for QoS).
+ * In order to support QoS in these kernels, multiple queues are implemented in the driver. But since
+ * there is only a single queue in the kernel (leading to multiple queues in the driver) there is no possibility
+ * of stopping a particular queue in the kernel. Stopping the single kernel queue leads to undesirable starvation
+ * of driver queues. One of the proposals is to not stop the kernel queue but to prevent dequeuing from the
+ * 'stopped' driver queue. Allow q pause is an experimental implementation of this scheme for pre 2.6.28 kernels.
+ * When NOT defined, queues are paused locally in the driver and packets are dequeued for transmission only from the
+ * unpaused queues. When Allow q pause is defined the kernel queue is stopped whenever any driver queue is paused.
+ */
+#define ALLOW_Q_PAUSE
+
+#define ieee2host16(n)  __le16_to_cpu(n)
+#define ieee2host32(n)  __le32_to_cpu(n)
+#define host2ieee16(n)  __cpu_to_le16(n)
+#define host2ieee32(n)  __cpu_to_le32(n)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+#ifdef UNIFI_NET_NAME
+#define UF_ALLOC_NETDEV(_dev, _size, _name, _setup, _num_of_queues)     \
+    do {                                                                \
+        static char name[8];                                           \
+        sprintf(name, "%s%s", UNIFI_NET_NAME, _name);                   \
+        _dev = alloc_netdev_mq(_size, name, _setup, _num_of_queues);    \
+    } while (0);
+#else
+#define UF_ALLOC_NETDEV(_dev, _size, _name, _setup, _num_of_queues)     \
+    do {                                                                \
+        _dev = alloc_etherdev_mq(_size, _num_of_queues);                \
+    } while (0);
+#endif /* UNIFI_NET_NAME */
+#else
+#ifdef UNIFI_NET_NAME
+#define UF_ALLOC_NETDEV(_dev, _size, _name, _setup, _num_of_queues)     \
+    do {                                                                \
+        static char name[8];                                           \
+        sprintf(name, "%s%s", UNIFI_NET_NAME, _name);                   \
+        _dev = alloc_netdev(_size, name, _setup);                       \
+    } while (0);
+#else
+#define UF_ALLOC_NETDEV(_dev, _size, _name, _setup, _num_of_queues)     \
+    do {                                                                \
+        _dev = alloc_etherdev(_size);                                   \
+    } while (0);
+#endif /* UNIFI_NET_NAME */
+#endif /* LINUX_VERSION_CODE */
+
+
+/* Wext handler is suported only if CSR_SUPPORT_WEXT is defined */
+#ifdef CSR_SUPPORT_WEXT
+extern struct iw_handler_def unifi_iw_handler_def;
+#endif /* CSR_SUPPORT_WEXT */
+static void check_ba_frame_age_timeout( unifi_priv_t *priv,
+                                            netInterface_priv_t *interfacePriv,
+                                            ba_session_rx_struct *ba_session);
+static void process_ba_frame(unifi_priv_t *priv,
+                             netInterface_priv_t *interfacePriv,
+                             ba_session_rx_struct *ba_session,
+                             frame_desc_struct *frame_desc);
+static void process_ba_complete(unifi_priv_t *priv, netInterface_priv_t *interfacePriv);
+static void process_ma_packet_error_ind(unifi_priv_t *priv, CSR_SIGNAL *signal, bulk_data_param_t *bulkdata);
+static void process_amsdu(unifi_priv_t *priv, CSR_SIGNAL *signal, bulk_data_param_t *bulkdata);
+static int uf_net_open(struct net_device *dev);
+static int uf_net_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+static int uf_net_stop(struct net_device *dev);
+static struct net_device_stats *uf_net_get_stats(struct net_device *dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+static u16 uf_net_select_queue(struct net_device *dev, struct sk_buff *skb);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+static netdev_tx_t uf_net_xmit(struct sk_buff *skb, struct net_device *dev);
+#else
+static int uf_net_xmit(struct sk_buff *skb, struct net_device *dev);
+#ifndef NETDEV_TX_OK
+#define NETDEV_TX_OK        0
+#endif
+#ifndef NETDEV_TX_BUSY
+#define NETDEV_TX_BUSY      1
+#endif
+#endif
+static void uf_set_multicast_list(struct net_device *dev);
+
+
+typedef int (*tx_signal_handler)(unifi_priv_t *priv, struct sk_buff *skb, const struct ethhdr *ehdr, CSR_PRIORITY priority);
+
+#ifdef CONFIG_NET_SCHED
+/*
+ * Queueing Discipline Interface
+ * Only used if kernel is configured with CONFIG_NET_SCHED
+ */
+
+/*
+ * The driver uses the qdisc interface to buffer and control all
+ * outgoing traffic. We create a root qdisc, register our qdisc operations
+ * and later we create two subsiduary pfifo queues for the uncontrolled
+ * and controlled ports.
+ *
+ * The network stack delivers all outgoing packets in our enqueue handler.
+ * There, we classify the packet and decide whether to store it or drop it
+ * (if the controlled port state is set to "discard").
+ * If the packet is enqueued, the network stack call our dequeue handler.
+ * There, we decide whether we can send the packet, delay it or drop it
+ * (the controlled port configuration might have changed meanwhile).
+ * If a packet is dequeued, then the network stack calls our hard_start_xmit
+ * handler where finally we send the packet.
+ *
+ * If the hard_start_xmit handler fails to send the packet, we return
+ * NETDEV_TX_BUSY and the network stack call our requeue handler where
+ * we put the packet back in the same queue in came from.
+ *
+ */
+
+struct uf_sched_data
+{
+    /* Traffic Classifier TBD */
+    struct tcf_proto *filter_list;
+    /* Our two queues */
+    struct Qdisc *queues[UNIFI_TRAFFIC_Q_MAX];
+};
+
+struct uf_tx_packet_data {
+    /* Queue the packet is stored in */
+    unifi_TrafficQueue queue;
+    /* QoS Priority determined when enqueing packet */
+    CSR_PRIORITY priority;
+    /* Debug */
+    unsigned long host_tag;
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+static int uf_qdiscop_enqueue(struct sk_buff *skb, struct Qdisc* qd);
+static int uf_qdiscop_requeue(struct sk_buff *skb, struct Qdisc* qd);
+static struct sk_buff *uf_qdiscop_dequeue(struct Qdisc* qd);
+static void uf_qdiscop_reset(struct Qdisc* qd);
+static void uf_qdiscop_destroy(struct Qdisc* qd);
+static int uf_qdiscop_dump(struct Qdisc *qd, struct sk_buff *skb);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+static int uf_qdiscop_tune(struct Qdisc *qd, struct nlattr *opt);
+static int uf_qdiscop_init(struct Qdisc *qd, struct nlattr *opt);
+#else
+static int uf_qdiscop_tune(struct Qdisc *qd, struct rtattr *opt);
+static int uf_qdiscop_init(struct Qdisc *qd, struct rtattr *opt);
+#endif
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+/* queueing discipline operations */
+static struct Qdisc_ops uf_qdisc_ops =
+{
+    .next = NULL,
+    .cl_ops = NULL,
+    .id = "UniFi Qdisc",
+    .priv_size = sizeof(struct uf_sched_data),
+
+    .enqueue = uf_qdiscop_enqueue,
+    .dequeue = uf_qdiscop_dequeue,
+    .requeue = uf_qdiscop_requeue,
+    .drop = NULL, /* drop not needed since we are always the root qdisc */
+
+    .init = uf_qdiscop_init,
+    .reset = uf_qdiscop_reset,
+    .destroy = uf_qdiscop_destroy,
+    .change = uf_qdiscop_tune,
+
+    .dump = uf_qdiscop_dump,
+};
+#endif /* LINUX_VERSION_CODE */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+#define UF_QDISC_CREATE_DFLT(_dev, _ops, _root)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+#define UF_QDISC_CREATE_DFLT(_dev, _ops, _root)         \
+    qdisc_create_dflt(dev, netdev_get_tx_queue(_dev, 0), _ops, _root)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+#define UF_QDISC_CREATE_DFLT(_dev, _ops, _root)         \
+    qdisc_create_dflt(dev, _ops, _root)
+#else
+#define UF_QDISC_CREATE_DFLT(_dev, _ops, _root)         \
+    qdisc_create_dflt(dev, _ops)
+#endif /* LINUX_VERSION_CODE */
+
+#endif /* CONFIG_NET_SCHED */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static const struct net_device_ops uf_netdev_ops =
+{
+    .ndo_open = uf_net_open,
+    .ndo_stop = uf_net_stop,
+    .ndo_start_xmit = uf_net_xmit,
+    .ndo_do_ioctl = uf_net_ioctl,
+    .ndo_get_stats = uf_net_get_stats, /* called by /proc/net/dev */
+    .ndo_set_rx_mode = uf_set_multicast_list,
+    .ndo_select_queue = uf_net_select_queue,
+};
+#endif
+
+static u8 oui_rfc1042[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
+static u8 oui_8021h[P80211_OUI_LEN]   = { 0x00, 0x00, 0xf8 };
+
+
+/* Callback for event logging to blocking clients */
+static void netdev_mlme_event_handler(ul_client_t  *client,
+                                      const u8 *sig_packed, int sig_len,
+                                      const bulk_data_param_t *bulkdata,
+                                      int dir);
+
+#ifdef CSR_SUPPORT_WEXT
+/* Declare netdev_notifier block which will contain the state change
+ * handler callback function
+ */
+static struct notifier_block uf_netdev_notifier;
+#endif
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_alloc_netdevice
+ *
+ *      Allocate memory for the net_device and device private structs
+ *      for this interface.
+ *      Fill in the fields, but don't register the interface yet.
+ *      We need to configure the UniFi first.
+ *
+ *  Arguments:
+ *      sdio_dev        Pointer to SDIO context handle to use for all
+ *                      SDIO ops.
+ *      bus_id          A small number indicating the SDIO card position on the
+ *                      bus. Typically this is the slot number, e.g. 0, 1 etc.
+ *                      Valid values are 0 to MAX_UNIFI_DEVS-1.
+ *
+ *  Returns:
+ *      Pointer to device private struct.
+ *
+ *  Notes:
+ *      The net_device and device private structs are allocated together
+ *      and should be freed by freeing the net_device pointer.
+ * ---------------------------------------------------------------------------
+ */
+unifi_priv_t *
+uf_alloc_netdevice(CsrSdioFunction *sdio_dev, int bus_id)
+{
+    struct net_device *dev;
+    unifi_priv_t *priv;
+    netInterface_priv_t *interfacePriv;
+#ifdef CSR_SUPPORT_WEXT
+    int rc;
+#endif
+    unsigned char i; /* loop index */
+
+    /*
+     * Allocate netdevice struct, assign name template and
+     * setup as an ethernet device.
+     * The net_device and private structs are zeroed. Ether_setup() then
+     * sets up ethernet handlers and values.
+     * The RedHat 9 redhat-config-network tool doesn't recognise wlan* devices,
+     * so use "eth*" (like other wireless extns drivers).
+     */
+    UF_ALLOC_NETDEV(dev, sizeof(unifi_priv_t)+sizeof(netInterface_priv_t), "%d", ether_setup, UNIFI_TRAFFIC_Q_MAX);
+
+    if (dev == NULL) {
+        return NULL;
+    }
+
+    /* Set up back pointer from priv to netdev */
+    interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    priv = (unifi_priv_t *)(interfacePriv + 1);
+    interfacePriv->privPtr = priv;
+    interfacePriv->InterfaceTag = 0;
+
+
+    /* Initialize all supported netdev interface to be NULL */
+    for(i=0; i<CSR_WIFI_NUM_INTERFACES; i++) {
+        priv->netdev[i] = NULL;
+        priv->interfacePriv[i] = NULL;
+    }
+    priv->netdev[0] = dev;
+    priv->interfacePriv[0] = interfacePriv;
+
+    /* Setup / override net_device fields */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+    dev->netdev_ops = &uf_netdev_ops;
+#else
+    dev->open             = uf_net_open;
+    dev->stop             = uf_net_stop;
+    dev->hard_start_xmit  = uf_net_xmit;
+    dev->do_ioctl         = uf_net_ioctl;
+
+    /* called by /proc/net/dev */
+    dev->get_stats = uf_net_get_stats;
+
+    dev->set_multicast_list = uf_set_multicast_list;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+    dev->select_queue       = uf_net_select_queue;
+#endif
+#endif
+
+#ifdef CSR_SUPPORT_WEXT
+    dev->wireless_handlers = &unifi_iw_handler_def;
+#if IW_HANDLER_VERSION < 6
+    dev->get_wireless_stats = unifi_get_wireless_stats;
+#endif /* IW_HANDLER_VERSION */
+#endif /* CSR_SUPPORT_WEXT */
+
+    /* This gives us enough headroom to add the 802.11 header */
+    dev->needed_headroom = 32;
+
+    /* Use bus_id as instance number */
+    priv->instance = bus_id;
+    /* Store SDIO pointer to pass in the core */
+    priv->sdio = sdio_dev;
+
+    sdio_dev->driverData = (void*)priv;
+    /* Consider UniFi to be uninitialised */
+    priv->init_progress = UNIFI_INIT_NONE;
+
+    priv->prev_queue = 0;
+
+    /*
+     * Initialise the clients structure array.
+     * We do not need protection around ul_init_clients() because
+     * the character device can not be used until uf_alloc_netdevice()
+     * returns and Unifi_instances[bus_id]=priv is set, since unifi_open()
+     * will return -ENODEV.
+     */
+    ul_init_clients(priv);
+
+    /*
+     * Register a new ul client to send the multicast list signals.
+     * Note: priv->instance must be set before calling this.
+     */
+    priv->netdev_client = ul_register_client(priv,
+            0,
+            netdev_mlme_event_handler);
+    if (priv->netdev_client == NULL) {
+        unifi_error(priv,
+                "Failed to register a unifi client for background netdev processing\n");
+        free_netdev(priv->netdev[0]);
+        return NULL;
+    }
+    unifi_trace(priv, UDBG2, "Netdev %p client (id:%d s:0x%X) is registered\n",
+            dev, priv->netdev_client->client_id, priv->netdev_client->sender_id);
+
+    priv->sta_wmm_capabilities = 0;
+
+    priv->wapi_multicast_filter = 0;
+    priv->wapi_unicast_filter = 0;
+    priv->wapi_unicast_queued_pkt_filter = 0;
+
+    /* Enable all queues by default */
+    interfacePriv->queueEnabled[0] = 1;
+    interfacePriv->queueEnabled[1] = 1;
+    interfacePriv->queueEnabled[2] = 1;
+    interfacePriv->queueEnabled[3] = 1;
+
+#ifdef CSR_SUPPORT_SME
+    priv->allPeerDozing = 0;
+#endif
+    /*
+     * Initialise the OS private struct.
+     */
+    /*
+     * Instead of deciding in advance to use 11bg or 11a, we could do a more
+     * clever scan on both radios.
+     */
+    if (use_5g) {
+        priv->if_index = CSR_INDEX_5G;
+        unifi_info(priv, "Using the 802.11a radio\n");
+    } else {
+        priv->if_index = CSR_INDEX_2G4;
+    }
+
+    /* Initialise bh thread structure */
+    priv->bh_thread.thread_task = NULL;
+    priv->bh_thread.block_thread = 1;
+    init_waitqueue_head(&priv->bh_thread.wakeup_q);
+    priv->bh_thread.wakeup_flag = 0;
+    sprintf(priv->bh_thread.name, "uf_bh_thread");
+
+    /* reset the connected state for the interface */
+    interfacePriv->connected = UnifiConnectedUnknown;  /* -1 unknown, 0 no, 1 yes */
+
+#ifdef USE_DRIVER_LOCK
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
+    sema_init(&priv->lock, 1);
+#else
+    init_MUTEX(&priv->lock);
+#endif
+#endif /* USE_DRIVER_LOCK */
+
+    spin_lock_init(&priv->send_signal_lock);
+
+    spin_lock_init(&priv->m4_lock);
+    spin_lock_init(&priv->ba_lock);
+
+#ifdef CSR_SUPPORT_SME
+    spin_lock_init(&priv->staRecord_lock);
+    spin_lock_init(&priv->tx_q_lock);
+#endif
+
+    /* Create the Traffic Analysis workqueue */
+    priv->unifi_workqueue = create_singlethread_workqueue("unifi_workq");
+    if (priv->unifi_workqueue == NULL) {
+        /* Deregister priv->netdev_client */
+        ul_deregister_client(priv->netdev_client);
+        free_netdev(priv->netdev[0]);
+        return NULL;
+    }
+
+#ifdef CSR_SUPPORT_SME
+    /* Create the Multicast Addresses list work structure */
+    INIT_WORK(&priv->multicast_list_task, uf_multicast_list_wq);
+
+    /* Create m4 buffering work structure */
+    INIT_WORK(&interfacePriv->send_m4_ready_task, uf_send_m4_ready_wq);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#ifdef CONFIG_NET_SCHED
+    /* Register the qdisc operations */
+    register_qdisc(&uf_qdisc_ops);
+#endif /* CONFIG_NET_SCHED */
+#endif /* LINUX_VERSION_CODE */
+
+    priv->ref_count = 1;
+
+
+    priv->amp_client = NULL;
+    priv->coredump_mode = 0;
+    priv->ptest_mode = 0;
+    priv->wol_suspend = FALSE;
+    INIT_LIST_HEAD(&interfacePriv->rx_uncontrolled_list);
+    INIT_LIST_HEAD(&interfacePriv->rx_controlled_list);
+    sema_init(&priv->rx_q_sem, 1);
+
+#ifdef CSR_SUPPORT_WEXT
+    interfacePriv->netdev_callback_registered = FALSE;
+    interfacePriv->wait_netdev_change = FALSE;
+    /* Register callback for netdevice state changes */
+    if ((rc = register_netdevice_notifier(&uf_netdev_notifier)) == 0) {
+        interfacePriv->netdev_callback_registered = TRUE;
+    }
+    else {
+        unifi_warning(priv, "Failed to register netdevice notifier : %d %p\n", rc, dev);
+    }
+#endif /* CSR_SUPPORT_WEXT */
+
+    return priv;
+} /* uf_alloc_netdevice() */
+
+/*
+ *---------------------------------------------------------------------------
+ *  uf_alloc_netdevice_for_other_interfaces
+ *
+ *      Allocate memory for the net_device and device private structs
+ *      for this interface.
+ *      Fill in the fields, but don't register the interface yet.
+ *      We need to configure the UniFi first.
+ *
+ *  Arguments:
+ *      interfaceTag   Interface number.
+ *      sdio_dev        Pointer to SDIO context handle to use for all
+ *                      SDIO ops.
+ *      bus_id          A small number indicating the SDIO card position on the
+ *                      bus. Typically this is the slot number, e.g. 0, 1 etc.
+ *                      Valid values are 0 to MAX_UNIFI_DEVS-1.
+ *
+ *  Returns:
+ *      Pointer to device private struct.
+ *
+ *  Notes:
+ *      The device private structure contains the interfaceTag and pointer to the unifi_priv
+ *      structure created allocated by net_device od interface0.
+ *      The net_device and device private structs are allocated together
+ *      and should be freed by freeing the net_device pointer.
+ * ---------------------------------------------------------------------------
+ */
+CsrBool
+uf_alloc_netdevice_for_other_interfaces(unifi_priv_t *priv, CsrUint16 interfaceTag)
+{
+    struct net_device *dev;
+    netInterface_priv_t *interfacePriv;
+
+    /*
+     * Allocate netdevice struct, assign name template and
+     * setup as an ethernet device.
+     * The net_device and private structs are zeroed. Ether_setup() then
+     * sets up ethernet handlers and values.
+     * The RedHat 9 redhat-config-network tool doesn't recognise wlan* devices,
+     * so use "eth*" (like other wireless extns drivers).
+     */
+    UF_ALLOC_NETDEV(dev, sizeof(netInterface_priv_t), "%d", ether_setup, 1);
+    if (dev == NULL) {
+        return FALSE;
+    }
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "uf_alloc_netdevice_for_other_interfaces bad interfaceTag\n");
+        return FALSE;
+    }
+
+    /* Set up back pointer from priv to netdev */
+    interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    interfacePriv->privPtr = priv;
+    interfacePriv->InterfaceTag = interfaceTag;
+    priv->netdev[interfaceTag] = dev;
+    priv->interfacePriv[interfacePriv->InterfaceTag] = interfacePriv;
+
+    /* reset the connected state for the interface */
+    interfacePriv->connected = UnifiConnectedUnknown;  /* -1 unknown, 0 no, 1 yes */
+    INIT_LIST_HEAD(&interfacePriv->rx_uncontrolled_list);
+    INIT_LIST_HEAD(&interfacePriv->rx_controlled_list);
+
+    /* Setup / override net_device fields */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+    dev->netdev_ops = &uf_netdev_ops;
+#else
+    dev->open             = uf_net_open;
+    dev->stop             = uf_net_stop;
+    dev->hard_start_xmit  = uf_net_xmit;
+    dev->do_ioctl         = uf_net_ioctl;
+
+    /* called by /proc/net/dev */
+    dev->get_stats = uf_net_get_stats;
+
+    dev->set_multicast_list = uf_set_multicast_list;
+#endif
+
+#ifdef CSR_SUPPORT_WEXT
+    dev->wireless_handlers = &unifi_iw_handler_def;
+#if IW_HANDLER_VERSION < 6
+    dev->get_wireless_stats = unifi_get_wireless_stats;
+#endif /* IW_HANDLER_VERSION */
+#endif /* CSR_SUPPORT_WEXT */
+    return TRUE;
+} /* uf_alloc_netdevice() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_free_netdevice
+ *
+ *      Unregister the network device and free the memory allocated for it.
+ *      NB This includes the memory for the priv struct.
+ *
+ *  Arguments:
+ *      priv            Device private pointer.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+int
+uf_free_netdevice(unifi_priv_t *priv)
+{
+    int i;
+    unsigned long flags;
+
+    func_enter();
+
+    unifi_trace(priv, UDBG1, "uf_free_netdevice\n");
+
+    if (!priv) {
+        return -EINVAL;
+    }
+
+    /*
+     * Free any buffers used for holding firmware
+     */
+    uf_release_firmware_files(priv);
+
+#if (defined CSR_SUPPORT_SME) && (defined CSR_SUPPORT_WEXT)
+    if (priv->connection_config.mlmeAssociateReqInformationElements) {
+        kfree(priv->connection_config.mlmeAssociateReqInformationElements);
+    }
+    priv->connection_config.mlmeAssociateReqInformationElements = NULL;
+    priv->connection_config.mlmeAssociateReqInformationElementsLength = 0;
+
+    if (priv->mib_data.length) {
+        vfree(priv->mib_data.data);
+    }
+    priv->mib_data.data = NULL;
+    priv->mib_data.length = 0;
+
+#endif /* CSR_SUPPORT_SME && CSR_SUPPORT_WEXT*/
+
+    /* Free any bulkdata buffers allocated for M4 caching */
+    spin_lock_irqsave(&priv->m4_lock, flags);
+    for (i = 0; i < CSR_WIFI_NUM_INTERFACES; i++) {
+        netInterface_priv_t *interfacePriv = priv->interfacePriv[i];
+        if (interfacePriv->m4_bulk_data.data_length > 0) {
+            unifi_trace(priv, UDBG5, "uf_free_netdevice: free M4 bulkdata %d\n", i);
+            unifi_net_data_free(priv, &interfacePriv->m4_bulk_data);
+        }
+    }
+    spin_unlock_irqrestore(&priv->m4_lock, flags);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#ifdef CONFIG_NET_SCHED
+    /* Unregister the qdisc operations */
+    unregister_qdisc(&uf_qdisc_ops);
+#endif /* CONFIG_NET_SCHED */
+#endif /* LINUX_VERSION_CODE */
+
+#ifdef CSR_SUPPORT_WEXT
+    /* Unregister callback for netdevice state changes */
+    unregister_netdevice_notifier(&uf_netdev_notifier);
+#endif /* CSR_SUPPORT_WEXT */
+
+#ifdef CSR_SUPPORT_SME
+    /* Cancel work items and destroy the workqueue */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+    cancel_work_sync(&priv->multicast_list_task);
+#endif
+#endif
+/* Destroy the workqueues. */
+    flush_workqueue(priv->unifi_workqueue);
+    destroy_workqueue(priv->unifi_workqueue);
+
+    /* Free up netdev in reverse order: priv is allocated with netdev[0].
+     * So, netdev[0] should be freed after all other netdevs are freed up
+     */
+    for (i=CSR_WIFI_NUM_INTERFACES-1; i>=0; i--) {
+        /*Free the netdev struct and priv, which are all one lump*/
+        if (priv->netdev[i]) {
+            unifi_error(priv, "uf_free_netdevice: netdev %d %p\n", i, priv->netdev[i]);
+            free_netdev(priv->netdev[i]);
+        }
+    }
+
+    func_exit();
+    return 0;
+} /* uf_free_netdevice() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_net_open
+ *
+ *      Called when userland does "ifconfig wlan0 up".
+ *
+ *  Arguments:
+ *      dev             Device pointer.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static int
+uf_net_open(struct net_device *dev)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+
+    func_enter();
+
+    /* If we haven't finished UniFi initialisation, we can't start */
+    if (priv->init_progress != UNIFI_INIT_COMPLETED) {
+        unifi_warning(priv, "%s: unifi not ready, failing net_open\n", __FUNCTION__);
+        return -EINVAL;
+    }
+
+#if (defined CSR_NATIVE_LINUX) && (defined UNIFI_SNIFF_ARPHRD) && defined(CSR_SUPPORT_WEXT)
+    /*
+     * To sniff, the user must do "iwconfig mode monitor", which sets
+     * priv->wext_conf.mode to IW_MODE_MONITOR.
+     * Then he/she must do "ifconfig ethn up", which calls this fn.
+     * There is no point in starting the sniff with SNIFFJOIN until
+     * this point.
+     */
+    if (priv->wext_conf.mode == IW_MODE_MONITOR) {
+        int err;
+        err = uf_start_sniff(priv);
+        if (err) {
+            return err;
+        }
+        netif_carrier_on(dev);
+    }
+#endif
+
+#ifdef CSR_SUPPORT_WEXT
+    if (interfacePriv->wait_netdev_change) {
+        unifi_trace(priv, UDBG1, "%s: Waiting for NETDEV_CHANGE, assume connected\n",
+                    __FUNCTION__);
+        interfacePriv->connected = UnifiConnected;
+        interfacePriv->wait_netdev_change = FALSE;
+    }
+#endif
+
+    UF_NETIF_TX_START_ALL_QUEUES(dev);
+
+    func_exit();
+    return 0;
+} /* uf_net_open() */
+
+
+static int
+uf_net_stop(struct net_device *dev)
+{
+#if defined(CSR_NATIVE_LINUX) && defined(UNIFI_SNIFF_ARPHRD) && defined(CSR_SUPPORT_WEXT)
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t*)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+
+    func_enter();
+
+    /* Stop sniffing if in Monitor mode */
+    if (priv->wext_conf.mode == IW_MODE_MONITOR) {
+        if (priv->card) {
+            int err;
+            err = unifi_reset_state(priv, dev->dev_addr, 1);
+            if (err) {
+                return err;
+            }
+        }
+    }
+#else
+    func_enter();
+#endif
+
+    UF_NETIF_TX_STOP_ALL_QUEUES(dev);
+
+    func_exit();
+    return 0;
+} /* uf_net_stop() */
+
+
+/* This is called after the WE handlers */
+static int
+uf_net_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+    int rc;
+
+    rc = -EOPNOTSUPP;
+
+    return rc;
+} /* uf_net_ioctl() */
+
+
+
+static struct net_device_stats *
+uf_net_get_stats(struct net_device *dev)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+
+    return &interfacePriv->stats;
+} /* uf_net_get_stats() */
+
+static CSR_PRIORITY uf_get_packet_priority(unifi_priv_t *priv, netInterface_priv_t *interfacePriv, struct sk_buff *skb, const int proto)
+{
+    CSR_PRIORITY priority = CSR_CONTENTION;
+
+    func_enter();
+    priority = (CSR_PRIORITY) (skb->priority >> 5);
+
+    if (priority == CSR_QOS_UP0) { /* 0 */
+
+        unifi_trace(priv, UDBG5, "uf_get_packet_priority: proto = 0x%.4X\n", proto);
+
+        switch (proto) {
+            case 0x0800:        /* IPv4 */
+            case 0x814C:        /* SNMP */
+            case 0x880C:        /* GSMP */
+                priority = (CSR_PRIORITY) (skb->data[1 + ETH_HLEN] >> 5);
+                break;
+
+            case 0x8100:        /* VLAN */
+                priority = (CSR_PRIORITY) (skb->data[0 + ETH_HLEN] >> 5);
+                break;
+
+            case 0x86DD:        /* IPv6 */
+                priority = (CSR_PRIORITY) ((skb->data[0 + ETH_HLEN] & 0x0E) >> 1);
+                break;
+
+            default:
+                priority = CSR_QOS_UP0;
+                break;
+        }
+    }
+
+    /* Check if we are allowed to transmit on this AC. Because of ACM we may have to downgrade to a lower
+     * priority */
+    if (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_STA ||
+        interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI) {
+        unifi_TrafficQueue queue;
+
+        /* Keep trying lower priorities until we find a queue
+         * Priority to queue mapping is 1,2 - BK, 0,3 - BE, 4,5 - VI, 6,7 - VO */
+        queue = unifi_frame_priority_to_queue(priority);
+
+        while (queue > UNIFI_TRAFFIC_Q_BK && !interfacePriv->queueEnabled[queue]) {
+            queue--;
+            priority = unifi_get_default_downgrade_priority(queue);
+        }
+    }
+
+    unifi_trace(priv, UDBG5, "Packet priority = %d\n", priority);
+
+    func_exit();
+    return priority;
+}
+
+/*
+ */
+/*
+ * ---------------------------------------------------------------------------
+ *  get_packet_priority
+ *
+ *  Arguments:
+ *      priv             private data area of functional driver
+ *      skb              socket buffer
+ *      ehdr             ethernet header to fetch protocol
+ *      interfacePriv    For accessing station record database
+ *
+ *
+ *  Returns:
+ *      CSR_PRIORITY.
+ * ---------------------------------------------------------------------------
+ */
+CSR_PRIORITY
+get_packet_priority(unifi_priv_t *priv, struct sk_buff *skb, const struct ethhdr *ehdr, netInterface_priv_t *interfacePriv)
+{
+    CSR_PRIORITY priority = CSR_CONTENTION;
+    const int proto = ntohs(ehdr->h_proto);
+
+    CsrUint8 interfaceMode = interfacePriv->interfaceMode;
+
+    func_enter();
+
+    /* Priority Mapping for all the Modes */
+    switch(interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_STA:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:
+            unifi_trace(priv, UDBG4, "mode is STA \n");
+            if ((priv->sta_wmm_capabilities & QOS_CAPABILITY_WMM_ENABLED) == 1) {
+                priority = uf_get_packet_priority(priv, interfacePriv, skb, proto);
+            } else {
+                priority = CSR_CONTENTION;
+            }
+            break;
+#ifdef CSR_SUPPORT_SME
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+        case CSR_WIFI_ROUTER_CTRL_MODE_IBSS:
+            {
+                CsrWifiRouterCtrlStaInfo_t * dstStaInfo =
+                    CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv,ehdr->h_dest, interfacePriv->InterfaceTag);
+                unifi_trace(priv, UDBG4, "mode is AP \n");
+                if (!(ehdr->h_dest[0] & 0x01) && dstStaInfo && dstStaInfo->wmmOrQosEnabled) {
+                    /* If packet is not Broadcast/multicast */
+                    priority = uf_get_packet_priority(priv, interfacePriv, skb, proto);
+                } else {
+                    /* Since packet destination is not QSTA, set priority to CSR_CONTENTION */
+                    unifi_trace(priv, UDBG4, "Destination is not QSTA or BroadCast/Multicast\n");
+                    priority = CSR_CONTENTION;
+                }
+            }
+            break;
+#endif
+        default:
+            unifi_trace(priv, UDBG3, " mode unknown in %s func, mode=%x\n", __FUNCTION__, interfaceMode);
+    }
+    unifi_trace(priv, UDBG5, "priority = %x\n", priority);
+
+    func_exit();
+    return priority;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_net_select_queue
+ *
+ *      Called by the kernel to select which queue to put the packet in
+ *
+ *  Arguments:
+ *      dev             Device pointer
+ *      skb             Packet
+ *
+ *  Returns:
+ *      Queue index
+ * ---------------------------------------------------------------------------
+ */
+static u16
+uf_net_select_queue(struct net_device *dev, struct sk_buff *skb)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = (unifi_priv_t *)interfacePriv->privPtr;
+    struct ethhdr ehdr;
+    unifi_TrafficQueue queue;
+    int proto;
+    CSR_PRIORITY priority;
+
+    func_enter();
+
+    memcpy(&ehdr, skb->data, ETH_HLEN);
+    proto = ntohs(ehdr.h_proto);
+
+    /* 802.1x - apply controlled/uncontrolled port rules */
+    if ((proto != ETH_P_PAE)
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+            && (proto != ETH_P_WAI)
+#endif
+       ) {
+        /* queues 0 - 3 */
+        priority = get_packet_priority(priv, skb, &ehdr, interfacePriv);
+        queue = unifi_frame_priority_to_queue(priority);
+    } else {
+        /* queue 4 */
+        queue = UNIFI_TRAFFIC_Q_EAPOL;
+    }
+
+
+    func_exit();
+    return (u16)queue;
+} /* uf_net_select_queue() */
+#endif
+
+int
+skb_add_llc_snap(struct net_device *dev, struct sk_buff *skb, int proto)
+{
+    llc_snap_hdr_t *snap;
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int headroom;
+
+    /* get the headroom available in skb */
+    headroom = skb_headroom(skb);
+    /* step 1: classify ether frame, DIX or 802.3? */
+
+    if (proto < 0x600) {
+        /* codes <= 1500 reserved for 802.3 lengths */
+        /* it's 802.3, pass ether payload unchanged,  */
+        unifi_trace(priv, UDBG3, "802.3 len: %d\n", skb->len);
+
+        /*   leave off any PAD octets.  */
+        skb_trim(skb, proto);
+    } else if (proto == ETH_P_8021Q) {
+
+        /* Store the VLAN SNAP (should be 87-65). */
+        u16 vlan_snap = *(u16*)skb->data;
+        /* check for headroom availability before skb_push 14 = (4 + 10) */
+        if (headroom < 14) {
+            unifi_trace(priv, UDBG3, "cant append vlan snap: debug\n");
+            return -1;
+        }
+        /* Add AA-AA-03-00-00-00 */
+        snap = (llc_snap_hdr_t *)skb_push(skb, 4);
+        snap->dsap = snap->ssap = 0xAA;
+        snap->ctrl = 0x03;
+        memcpy(snap->oui, oui_rfc1042, P80211_OUI_LEN);
+
+        /* Add AA-AA-03-00-00-00 */
+        snap = (llc_snap_hdr_t *)skb_push(skb, 10);
+        snap->dsap = snap->ssap = 0xAA;
+        snap->ctrl = 0x03;
+        memcpy(snap->oui, oui_rfc1042, P80211_OUI_LEN);
+
+        /* Add the VLAN specific information */
+        snap->protocol = htons(proto);
+        *(u16*)(snap + 1) = vlan_snap;
+
+    } else
+    {
+        /* it's DIXII, time for some conversion */
+        unifi_trace(priv, UDBG3, "DIXII len: %d\n", skb->len);
+
+        /* check for headroom availability before skb_push */
+        if (headroom < sizeof(llc_snap_hdr_t)) {
+            unifi_trace(priv, UDBG3, "cant append snap: debug\n");
+            return -1;
+        }
+        /* tack on SNAP */
+        snap = (llc_snap_hdr_t *)skb_push(skb, sizeof(llc_snap_hdr_t));
+        snap->dsap = snap->ssap = 0xAA;
+        snap->ctrl = 0x03;
+        /* Use the appropriate OUI. */
+        if ((proto == ETH_P_AARP) || (proto == ETH_P_IPX)) {
+            memcpy(snap->oui, oui_8021h, P80211_OUI_LEN);
+        } else {
+            memcpy(snap->oui, oui_rfc1042, P80211_OUI_LEN);
+        }
+        snap->protocol = htons(proto);
+    }
+
+    return 0;
+} /* skb_add_llc_snap() */
+
+#ifdef CSR_SUPPORT_SME
+static int
+_identify_sme_ma_pkt_ind(unifi_priv_t *priv,
+                         const CsrInt8 *oui, CsrUint16 protocol,
+                         const CSR_SIGNAL *signal,
+                         bulk_data_param_t *bulkdata,
+                         const unsigned char *daddr,
+                         const unsigned char *saddr)
+{
+    CSR_MA_PACKET_INDICATION *pkt_ind = (CSR_MA_PACKET_INDICATION*)&signal->u.MaPacketIndication;
+    int r;
+    CsrUint8 i;
+
+    unifi_trace(priv, UDBG5,
+            "_identify_sme_ma_pkt_ind -->\n");
+    for (i = 0; i < MAX_MA_UNIDATA_IND_FILTERS; i++) {
+        if (priv->sme_unidata_ind_filters[i].in_use) {
+            if (!memcmp(oui, priv->sme_unidata_ind_filters[i].oui, 3) &&
+                    (protocol == priv->sme_unidata_ind_filters[i].protocol)) {
+
+                /* Send to client */
+                if (priv->sme_cli) {
+                    /*
+                     * Pass the packet to the SME, using unifi_sys_ma_unitdata_ind().
+                     * The frame needs to be converted according to the encapsulation.
+                     */
+                    unifi_trace(priv, UDBG1,
+                            "_identify_sme_ma_pkt_ind: handle=%d, encap=%d, proto=%x\n",
+                            i, priv->sme_unidata_ind_filters[i].encapsulation,
+                            priv->sme_unidata_ind_filters[i].protocol);
+                    if (priv->sme_unidata_ind_filters[i].encapsulation == CSR_WIFI_ROUTER_ENCAPSULATION_ETHERNET) {
+                        struct sk_buff *skb;
+                        /* The translation is performed on skb... */
+                        skb = (struct sk_buff*)bulkdata->d[0].os_net_buf_ptr;
+                        skb->len = bulkdata->d[0].data_length;
+
+                        unifi_trace(priv, UDBG1,
+                                "_identify_sme_ma_pkt_ind: skb_80211_to_ether -->\n");
+                        r = skb_80211_to_ether(priv, skb, daddr, saddr,
+                                signal, bulkdata);
+                        unifi_trace(priv, UDBG1,
+                                "_identify_sme_ma_pkt_ind: skb_80211_to_ether <--\n");
+                        if (r) {
+                            return -EINVAL;
+                        }
+
+                        /* ... but we indicate buffer and length */
+                        bulkdata->d[0].os_data_ptr = skb->data;
+                        bulkdata->d[0].data_length = skb->len;
+                    } else {
+                        /* Add the MAC addresses before the SNAP */
+                        bulkdata->d[0].os_data_ptr -= 2*ETH_ALEN;
+                        bulkdata->d[0].data_length += 2*ETH_ALEN;
+                        memcpy((void*)bulkdata->d[0].os_data_ptr, daddr, ETH_ALEN);
+                        memcpy((void*)bulkdata->d[0].os_data_ptr + ETH_ALEN, saddr, ETH_ALEN);
+                    }
+
+                    unifi_trace(priv, UDBG1,
+                            "_identify_sme_ma_pkt_ind: unifi_sys_ma_pkt_ind -->\n");
+                    CsrWifiRouterMaPacketIndSend(priv->sme_unidata_ind_filters[i].appHandle,
+                            (pkt_ind->VirtualInterfaceIdentifier & 0xff),
+                            i,
+                            pkt_ind->ReceptionStatus,
+                            bulkdata->d[0].data_length,
+                            (CsrUint8*)bulkdata->d[0].os_data_ptr,
+                            NULL,
+                            pkt_ind->Rssi,
+                            pkt_ind->Snr,
+                            pkt_ind->ReceivedRate);
+
+
+                    unifi_trace(priv, UDBG1,
+                            "_identify_sme_ma_pkt_ind: unifi_sys_ma_pkt_ind <--\n");
+                }
+
+                return 1;
+            }
+        }
+    }
+
+    return -1;
+}
+#endif /* CSR_SUPPORT_SME */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  skb_80211_to_ether
+ *
+ *      Make sure the received frame is in Ethernet (802.3) form.
+ *      De-encapsulates SNAP if necessary, adds a ethernet header.
+ *      The source buffer should not contain an 802.11 MAC header
+ *
+ *  Arguments:
+ *      payload         Pointer to packet data received from UniFi.
+ *      payload_length  Number of bytes of data received from UniFi.
+ *      daddr           Destination MAC address.
+ *      saddr           Source MAC address.
+ *
+ *  Returns:
+ *      0 on success, -1 if the packet is bad and should be dropped,
+ *      1 if the packet was forwarded to the SME or AMP client.
+ * ---------------------------------------------------------------------------
+ */
+int
+skb_80211_to_ether(unifi_priv_t *priv, struct sk_buff *skb,
+                   const unsigned char *daddr, const unsigned char *saddr,
+                   const CSR_SIGNAL *signal,
+                   bulk_data_param_t *bulkdata)
+{
+    unsigned char *payload;
+    int payload_length;
+    struct ethhdr *eth;
+    llc_snap_hdr_t *snap;
+    int headroom;
+#define UF_VLAN_LLC_HEADER_SIZE     18
+    static const u8 vlan_inner_snap[] = { 0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00 };
+#if defined(CSR_NATIVE_SOFTMAC) && defined(CSR_SUPPORT_SME)
+    const CSR_MA_PACKET_INDICATION *pkt_ind = &signal->u.MaPacketIndication;
+#endif
+
+    if(skb== NULL || daddr == NULL || saddr == NULL){
+        unifi_error(priv,"skb_80211_to_ether: PBC fail\n");
+        return 1;
+    }
+
+    payload = skb->data;
+    payload_length = skb->len;
+
+    snap = (llc_snap_hdr_t *)payload;
+    eth  = (struct ethhdr *)payload;
+
+    /* get the skb headroom size */
+    headroom = skb_headroom(skb);
+
+    /*
+     * Test for the various encodings
+     */
+    if ((payload_length >= sizeof(llc_snap_hdr_t)) &&
+            (snap->dsap == 0xAA) &&
+            (snap->ssap == 0xAA) &&
+            (snap->ctrl == 0x03) &&
+            (snap->oui[0] == 0) &&
+            (snap->oui[1] == 0) &&
+            ((snap->oui[2] == 0) || (snap->oui[2] == 0xF8)))
+    {
+        /* AppleTalk AARP (2) or IPX SNAP */
+        if ((snap->oui[2] == 0) &&
+                ((ntohs(snap->protocol) == ETH_P_AARP) || (ntohs(snap->protocol) == ETH_P_IPX)))
+        {
+            u16 len;
+
+            unifi_trace(priv, UDBG3, "%s len: %d\n",
+                    (ntohs(snap->protocol) == ETH_P_AARP) ? "ETH_P_AARP" : "ETH_P_IPX",
+                    payload_length);
+
+            /* check for headroom availability before skb_push */
+            if (headroom < (2 * ETH_ALEN + 2)) {
+                unifi_warning(priv, "headroom not available to skb_push ether header\n");
+                return -1;
+            }
+
+            /* Add 802.3 header and leave full payload */
+            len = htons(skb->len);
+            memcpy(skb_push(skb, 2), &len, 2);
+            memcpy(skb_push(skb, ETH_ALEN), saddr, ETH_ALEN);
+            memcpy(skb_push(skb, ETH_ALEN), daddr, ETH_ALEN);
+
+            return 0;
+        }
+        /* VLAN-tagged IP */
+        if ((snap->oui[2] == 0) && (ntohs(snap->protocol) == ETH_P_8021Q))
+        {
+            /*
+             * The translation doesn't change the packet length, so is done in-place.
+             *
+             * Example header (from Std 802.11-2007 Annex M):
+             * AA-AA-03-00-00-00-81-00-87-65-AA-AA-03-00-00-00-08-06
+             * -------SNAP-------p1-p1-ll-ll-------SNAP--------p2-p2
+             * dd-dd-dd-dd-dd-dd-aa-aa-aa-aa-aa-aa-p1-p1-ll-ll-p2-p2
+             * dd-dd-dd-dd-dd-dd-aa-aa-aa-aa-aa-aa-81-00-87-65-08-06
+             */
+            u16 vlan_snap;
+
+            if (payload_length < UF_VLAN_LLC_HEADER_SIZE) {
+                unifi_warning(priv, "VLAN SNAP header too short: %d bytes\n", payload_length);
+                return -1;
+            }
+
+            if (memcmp(payload + 10, vlan_inner_snap, 6)) {
+                unifi_warning(priv, "VLAN malformatted SNAP header.\n");
+                return -1;
+            }
+
+            unifi_trace(priv, UDBG3, "VLAN SNAP: %02x-%02x\n", payload[8], payload[9]);
+            unifi_trace(priv, UDBG3, "VLAN len: %d\n", payload_length);
+
+            /* Create the 802.3 header */
+
+            vlan_snap = *((u16*)(payload + 8));
+
+            /* Create LLC header without byte-swapping */
+            eth->h_proto = snap->protocol;
+
+            memcpy(eth->h_dest, daddr, ETH_ALEN);
+            memcpy(eth->h_source, saddr, ETH_ALEN);
+            *(u16*)(eth + 1) = vlan_snap;
+            return 0;
+        }
+
+        /* it's a SNAP + RFC1042 frame */
+        unifi_trace(priv, UDBG3, "SNAP+RFC1042 len: %d\n", payload_length);
+
+        /* chop SNAP+llc header from skb. */
+        skb_pull(skb, sizeof(llc_snap_hdr_t));
+
+        /* Since skb_pull called above to chop snap+llc, no need to check for headroom
+         * availability before skb_push
+         */
+        /* create 802.3 header at beginning of skb. */
+        eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);
+        memcpy(eth->h_dest, daddr, ETH_ALEN);
+        memcpy(eth->h_source, saddr, ETH_ALEN);
+        /* Copy protocol field without byte-swapping */
+        eth->h_proto = snap->protocol;
+    } else {
+        u16 len;
+
+        /* check for headroom availability before skb_push */
+        if (headroom < (2 * ETH_ALEN + 2)) {
+            unifi_warning(priv, "headroom not available to skb_push ether header\n");
+            return -1;
+        }
+        /* Add 802.3 header and leave full payload */
+        len = htons(skb->len);
+        memcpy(skb_push(skb, 2), &len, 2);
+        memcpy(skb_push(skb, ETH_ALEN), saddr, ETH_ALEN);
+        memcpy(skb_push(skb, ETH_ALEN), daddr, ETH_ALEN);
+
+        return 1;
+    }
+
+    return 0;
+} /* skb_80211_to_ether() */
+
+
+static CsrWifiRouterCtrlPortAction verify_port(unifi_priv_t *priv, unsigned char *address, int queue, CsrUint16 interfaceTag)
+{
+#ifdef CSR_NATIVE_LINUX
+#ifdef CSR_SUPPORT_WEXT
+    if (queue == UF_CONTROLLED_PORT_Q) {
+        return priv->wext_conf.block_controlled_port;
+    } else {
+        return CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN;
+    }
+#else
+    return CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN; /* default to open for softmac dev */
+#endif
+#else
+    return uf_sme_port_state(priv, address, queue, interfaceTag);
+#endif
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  prepare_and_add_macheader
+ *
+ *
+ *      These functions adds mac header for packet from netdev
+ *      to UniFi for transmission.
+ *      EAP protocol packets are also appended with Mac header &
+ *      sent using send_ma_pkt_request().
+ *
+ *  Arguments:
+ *      priv            Pointer to device private context struct
+ *      skb             Socket buffer containing data packet to transmit
+ *      newSkb          Socket buffer containing data packet + Mac header if no sufficient headroom in skb
+ *      serviceClass    to append QOS control header in Mac header
+ *      bulkdata        if newSkb allocated then bulkdata updated to send to unifi
+ *      interfaceTag    the interfaceID on which activity going on
+ *      daddr           destination address
+ *      saddr           source address
+ *      protection      protection bit set in framce control of mac header
+ *
+ *  Returns:
+ *      Zero on success or error code.
+ * ---------------------------------------------------------------------------
+ */
+
+int prepare_and_add_macheader(unifi_priv_t *priv, struct sk_buff *skb, struct sk_buff *newSkb,
+                              CSR_PRIORITY priority,
+                              bulk_data_param_t *bulkdata,
+                              CsrUint16 interfaceTag,
+                              const CsrUint8 *daddr,
+                              const CsrUint8 *saddr,
+                              CsrBool protection)
+{
+    CsrUint16 fc = 0;
+    CsrUint8 qc = 0;
+    CsrUint8 macHeaderLengthInBytes = MAC_HEADER_SIZE, *bufPtr = NULL;
+    bulk_data_param_t data_ptrs;
+    CsrResult csrResult;
+    int headroom =0;
+    CsrUint8 direction = 0;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    CsrUint8 *addressOne;
+    CsrBool bQosNull = false;
+
+    if (skb == NULL) {
+        unifi_error(priv,"prepare_and_add_macheader: Invalid SKB reference\n");
+        return -1;
+    }
+
+    /* add a MAC header refer: 7.1.3.1 Frame Control field in P802.11REVmb.book */
+    if (priority != CSR_CONTENTION) {
+        /* EAPOL packets don't go as QOS_DATA */
+        if (priority == CSR_MANAGEMENT) {
+            fc |= cpu_to_le16(IEEE802_11_FC_TYPE_DATA);
+        } else {
+            /* Qos Control Field */
+            macHeaderLengthInBytes += QOS_CONTROL_HEADER_SIZE;
+
+            if (skb->len) {
+
+                fc |= cpu_to_le16(IEEE802_11_FC_TYPE_QOS_DATA);
+            } else {
+                fc |= cpu_to_le16(IEEE802_11_FC_TYPE_QOS_NULL);
+                bQosNull = true;
+            }
+        }
+    } else {
+        if(skb->len == 0) {
+            fc |= cpu_to_le16(IEEE802_11_FC_TYPE_NULL);
+        } else {
+            fc |= cpu_to_le16(IEEE802_11_FC_TYPE_DATA);
+        }
+    }
+
+    switch (interfacePriv->interfaceMode)
+    {
+        case  CSR_WIFI_ROUTER_CTRL_MODE_STA:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:
+            direction = 2;
+            fc |= cpu_to_le16(IEEE802_11_FC_TO_DS_MASK);
+            break;
+        case  CSR_WIFI_ROUTER_CTRL_MODE_IBSS:
+            direction = 0;
+            break;
+        case  CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            direction = 1;
+            fc |= cpu_to_le16(IEEE802_11_FC_FROM_DS_MASK);
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_AMP:
+            if (priority == CSR_MANAGEMENT ) {
+
+                direction = 2;
+                fc |= cpu_to_le16(IEEE802_11_FC_TO_DS_MASK);
+            } else {
+                /* Data frames have to use WDS 4 address frames */
+                direction = 3;
+                fc |= cpu_to_le16(IEEE802_11_FC_TO_DS_MASK | IEEE802_11_FC_FROM_DS_MASK);
+                macHeaderLengthInBytes += 6;
+            }
+            break;
+        default:
+            unifi_warning(priv, "prepare_and_add_macheader: Unknown mode %d\n",
+                          interfacePriv->interfaceMode);
+    }
+
+
+    /* If Sta is QOS & HTC is supported then need to set 'order' bit */
+    /* We don't support HT Control for now */
+
+    if(protection) {
+        fc |= cpu_to_le16(IEEE802_11_FC_PROTECTED_MASK);
+    }
+
+    /* check the skb headroom before pushing mac header */
+    headroom = skb_headroom(skb);
+
+    if (headroom < macHeaderLengthInBytes) {
+        unifi_trace(priv, UDBG5,
+                    "prepare_and_add_macheader: Allocate headroom extra %d bytes\n",
+                    macHeaderLengthInBytes);
+
+        csrResult = unifi_net_data_malloc(priv, &data_ptrs.d[0], skb->len + macHeaderLengthInBytes);
+
+        if (csrResult != CSR_RESULT_SUCCESS) {
+            unifi_error(priv, " failed to allocate request_data. in %s func\n", __FUNCTION__);
+            return -1;
+        }
+        newSkb = (struct sk_buff *)(data_ptrs.d[0].os_net_buf_ptr);
+        newSkb->len = skb->len + macHeaderLengthInBytes;
+
+        memcpy((void*)data_ptrs.d[0].os_data_ptr + macHeaderLengthInBytes,
+                skb->data, skb->len);
+
+        bulkdata->d[0].os_data_ptr = newSkb->data;
+        bulkdata->d[0].os_net_buf_ptr = (unsigned char*)newSkb;
+        bulkdata->d[0].data_length = newSkb->len;
+
+        bufPtr = (CsrUint8*)data_ptrs.d[0].os_data_ptr;
+
+        /* The old skb will not be used again */
+            kfree_skb(skb);
+    } else {
+
+        /* headroom has sufficient size, so will get proper pointer */
+        bufPtr = (CsrUint8*)skb_push(skb, macHeaderLengthInBytes);
+        bulkdata->d[0].os_data_ptr = skb->data;
+        bulkdata->d[0].os_net_buf_ptr = (unsigned char*)skb;
+        bulkdata->d[0].data_length = skb->len;
+    }
+
+    /* Frame the actual MAC header */
+
+    memset(bufPtr, 0, macHeaderLengthInBytes);
+
+    /* copy frameControl field */
+    memcpy(bufPtr, &fc, sizeof(fc));
+    bufPtr += sizeof(fc);
+    macHeaderLengthInBytes -= sizeof(fc);
+
+    /* Duration/ID field which is 2 bytes */
+    bufPtr += 2;
+    macHeaderLengthInBytes -= 2;
+
+    switch(direction)
+    {
+        case 0:
+            /* Its an Ad-Hoc no need to route it through AP */
+            /* Address1: MAC address of the destination from eth header */
+            memcpy(bufPtr, daddr, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+
+            /* Address2: MAC address of the source */
+            memcpy(bufPtr, saddr, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+
+            /* Address3: the BSSID (locally generated in AdHoc (creators Bssid)) */
+            memcpy(bufPtr, &interfacePriv->bssid, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+            break;
+        case 1:
+           /* Address1: MAC address of the actual destination */
+            memcpy(bufPtr, daddr, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+            /* Address2: The MAC address of the AP */
+            memcpy(bufPtr, &interfacePriv->bssid, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+
+            /* Address3: MAC address of the source from eth header */
+            memcpy(bufPtr, saddr, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+            break;
+        case  2:
+            /* Address1: To AP is the MAC address of the AP to which its associated */
+            memcpy(bufPtr, &interfacePriv->bssid, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+
+            /* Address2: MAC address of the source from eth header */
+            memcpy(bufPtr, saddr, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+
+            /* Address3: MAC address of the actual destination on the distribution system */
+            memcpy(bufPtr, daddr, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+            break;
+        case 3:
+            memcpy(bufPtr, &interfacePriv->bssid, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+
+            /* Address2: MAC address of the source from eth header */
+            memcpy(bufPtr, saddr, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+
+            /* Address3: MAC address of the actual destination on the distribution system */
+            memcpy(bufPtr, daddr, ETH_ALEN);
+            bufPtr += ETH_ALEN;
+            macHeaderLengthInBytes -= ETH_ALEN;
+            break;
+        default:
+            unifi_error(priv,"Unknown direction =%d : Not handled now\n",direction);
+            return -1;
+    }
+    /* 2 bytes of frame control field, appended by firmware */
+    bufPtr += 2;
+    macHeaderLengthInBytes -= 2;
+
+    if (3 == direction) {
+        /* Address4: MAC address of the source */
+        memcpy(bufPtr, saddr, ETH_ALEN);
+        bufPtr += ETH_ALEN;
+        macHeaderLengthInBytes -= ETH_ALEN;
+    }
+
+    /* IF Qos Data or Qos Null Data then set QosControl field */
+    if ((priority != CSR_CONTENTION) && (macHeaderLengthInBytes >= QOS_CONTROL_HEADER_SIZE)) {
+
+        if (priority >= 7) {
+            unifi_trace(priv, UDBG1, "data packets priority is more than 7, priority = %x\n", priority);
+            qc |= 7;
+        } else {
+            qc |= priority;
+        }
+        /*assigning address1
+        * Address1 offset taken fromm bufPtr(currently bufPtr pointing to Qos contorl) variable in reverse direction
+        * Address4 don't exit
+        */
+
+        addressOne = bufPtr- ADDRESS_ONE_OFFSET;
+
+        if (addressOne[0] & 0x1) {
+            /* multicast/broadcast frames, no acknowledgement needed */
+            qc |= 1 << 5;
+        }
+        /* non-AP mode only for now */
+        if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_STA ||
+           interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_IBSS ||
+           interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI) {
+           /* In case of STA and IBSS case eosp and txop limit is 0. */
+        } else {
+            if(bQosNull) {
+                qc |= 1 << 4;
+            }
+        }
+
+        /* append Qos control field to mac header */
+        bufPtr[0] = qc;
+        /* txop limit is 0 */
+        bufPtr[1] = 0;
+        macHeaderLengthInBytes -= QOS_CONTROL_HEADER_SIZE;
+    }
+    if (macHeaderLengthInBytes) {
+        unifi_warning(priv, " Mac header not appended properly\n");
+        return -1;
+    }
+    return 0;
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  send_ma_pkt_request
+ *
+ *      These functions send a data packet to UniFi for transmission.
+ *      EAP protocol packets are also sent as send_ma_pkt_request().
+ *
+ *  Arguments:
+ *      priv            Pointer to device private context struct
+ *      skb             Socket buffer containing data packet to transmit
+ *      ehdr            Pointer to Ethernet header within skb.
+ *
+ *  Returns:
+ *      Zero on success or error code.
+ * ---------------------------------------------------------------------------
+ */
+
+static int
+send_ma_pkt_request(unifi_priv_t *priv, struct sk_buff *skb, const struct ethhdr *ehdr, CSR_PRIORITY priority)
+{
+    int r;
+    CsrUint16 i;
+    CsrBool eapolStore = FALSE;
+    struct sk_buff *newSkb = NULL;
+    bulk_data_param_t bulkdata;
+    const int proto = ntohs(ehdr->h_proto);
+    CsrUint16 interfaceTag;
+    CsrWifiMacAddress peerAddress;
+    CSR_TRANSMISSION_CONTROL transmissionControl = CSR_NO_CONFIRM_REQUIRED;
+    CsrInt8 protection;
+    netInterface_priv_t *interfacePriv = NULL;
+
+    unifi_trace(priv, UDBG5, "entering send_ma_pkt_request\n");
+
+    /* Get the interface Tag by means of source Mac address */
+    for (i = 0; i < CSR_WIFI_NUM_INTERFACES; i++) {
+        if (!memcmp(priv->netdev[i]->dev_addr, ehdr->h_source, ETH_ALEN)) {
+            interfaceTag = i;
+            interfacePriv = priv->interfacePriv[interfaceTag];
+            break;
+        }
+    }
+
+    if (interfacePriv == NULL) {
+        /* No match found - error */
+        interfaceTag = 0;
+        interfacePriv = priv->interfacePriv[interfaceTag];
+        unifi_warning(priv, "Mac address not matching ... debugging needed\n");
+        interfacePriv->stats.tx_dropped++;
+        kfree_skb(skb);
+        return -1;
+    }
+
+    /* Add a SNAP header if necessary */
+    if (skb_add_llc_snap(priv->netdev[interfaceTag], skb, proto) != 0) {
+        /* convert failed */
+        unifi_error(priv, "skb_add_llc_snap failed.\n");
+        kfree_skb(skb);
+        return -1;
+    }
+
+    bulkdata.d[0].os_data_ptr = skb->data;
+    bulkdata.d[0].os_net_buf_ptr = (unsigned char*)skb;
+    bulkdata.d[0].net_buf_length = bulkdata.d[0].data_length = skb->len;
+    bulkdata.d[1].os_data_ptr = NULL;
+    bulkdata.d[1].os_net_buf_ptr = NULL;
+    bulkdata.d[1].net_buf_length = bulkdata.d[1].data_length = 0;
+
+#ifdef CSR_SUPPORT_SME
+    /* Notify the TA module for the Tx frame  for non AP/P2PGO mode*/
+    if ((interfacePriv->interfaceMode != CSR_WIFI_ROUTER_CTRL_MODE_AP) &&
+        (interfacePriv->interfaceMode != CSR_WIFI_ROUTER_CTRL_MODE_P2PGO)) {
+        unifi_ta_sample(priv->card, CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_TX,
+                        &bulkdata.d[0], ehdr->h_source,
+                        priv->netdev[interfaceTag]->dev_addr,
+                        jiffies_to_msecs(jiffies),
+                        0);     /* rate is unknown on tx */
+    }
+#endif /* CSR_SUPPORT_SME */
+
+    if ((proto == ETH_P_PAE)
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+            || (proto == ETH_P_WAI)
+#endif
+       )
+    {
+        /* check for m4 detection */
+        if (0 == uf_verify_m4(priv, bulkdata.d[0].os_data_ptr, bulkdata.d[0].data_length)) {
+            eapolStore = TRUE;
+        }
+    }
+
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+    if (proto == ETH_P_WAI)
+     {
+        protection = 0; /*WAI packets always sent unencrypted*/
+     }
+   else
+     {
+#endif
+#ifdef CSR_SUPPORT_SME
+    if ((protection = uf_get_protection_bit_from_interfacemode(priv, interfaceTag, ehdr->h_dest)) < 0) {
+        unifi_warning(priv, "unicast address, but destination not in station record database\n");
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+        return -1;
+    }
+#else
+    protection = 0;
+#endif
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+   }
+#endif
+
+    /* append Mac header for Eapol as well as data packet */
+    if (prepare_and_add_macheader(priv, skb, newSkb, priority, &bulkdata, interfaceTag, ehdr->h_dest, ehdr->h_source, protection)) {
+        unifi_error(priv, "failed to create MAC header\n");
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+        return -1;
+    }
+
+    /* RA adrress must contain the immediate destination MAC address that is similiar to
+     * the Address 1 field of 802.11 Mac header here 4 is: (sizeof(framecontrol) + sizeof (durationID))
+     * which is address 1 field
+     */
+    memcpy(peerAddress.a, ((CsrUint8 *) bulkdata.d[0].os_data_ptr) + 4, ETH_ALEN);
+
+    unifi_trace(priv, UDBG5, "RA[0]=%x, RA[1]=%x, RA[2]=%x, RA[3]=%x, RA[4]=%x, RA[5]=%x\n",
+                peerAddress.a[0],peerAddress.a[1], peerAddress.a[2], peerAddress.a[3],
+                peerAddress.a[4],peerAddress.a[5]);
+
+
+    if ((proto == ETH_P_PAE)
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+            || (proto == ETH_P_WAI)
+#endif
+       )
+    {
+        CSR_SIGNAL signal;
+        CSR_MA_PACKET_REQUEST *req = &signal.u.MaPacketRequest;
+
+        /* initialize signal to zero */
+        memset(&signal, 0, sizeof(CSR_SIGNAL));
+
+        /* Frame MA_PACKET request */
+        signal.SignalPrimitiveHeader.SignalId = CSR_MA_PACKET_REQUEST_ID;
+        signal.SignalPrimitiveHeader.ReceiverProcessId = 0;
+        signal.SignalPrimitiveHeader.SenderProcessId = priv->netdev_client->sender_id;
+
+        transmissionControl = req->TransmissionControl = 0;
+#ifdef CSR_SUPPORT_SME
+        if (eapolStore)
+        {
+            netInterface_priv_t *netpriv = (netInterface_priv_t *)netdev_priv(priv->netdev[interfaceTag]);
+
+            /* Fill the MA-PACKET.req */
+
+            req->Priority = priority;
+            unifi_trace(priv, UDBG3, "Tx Frame with Priority: %x\n", req->Priority);
+
+            /* rate selected by firmware */
+            req->TransmitRate = 0;
+            req->HostTag = CSR_WIFI_EAPOL_M4_HOST_TAG;
+            /* RA address matching with address 1 of Mac header */
+            memcpy(req->Ra.x, ((CsrUint8 *) bulkdata.d[0].os_data_ptr) + 4, ETH_ALEN);
+
+            spin_lock(&priv->m4_lock);
+            /* Store the M4-PACKET.req for later */
+            interfacePriv->m4_signal = signal;
+            interfacePriv->m4_bulk_data.net_buf_length = bulkdata.d[0].net_buf_length;
+            interfacePriv->m4_bulk_data.data_length = bulkdata.d[0].data_length;
+            interfacePriv->m4_bulk_data.os_data_ptr = bulkdata.d[0].os_data_ptr;
+            interfacePriv->m4_bulk_data.os_net_buf_ptr = bulkdata.d[0].os_net_buf_ptr;
+            spin_unlock(&priv->m4_lock);
+
+            /* Signal the workqueue to call CsrWifiRouterCtrlM4ReadyToSendIndSend().
+             * It cannot be called directly from the tx path because it
+             * does a non-atomic kmalloc via the framework's CsrPmemAlloc().
+             */
+            queue_work(priv->unifi_workqueue, &netpriv->send_m4_ready_task);
+
+            return 0;
+        }
+#endif
+    }
+
+    /* Send UniFi msg */
+    /* Here hostTag is been sent as 0xffffffff, its been appended properly while framing MA-Packet request in pdu_processing.c file */
+    r = uf_process_ma_packet_req(priv,
+                                 peerAddress.a,
+                                 0xffffffff,  /* Ask for a new HostTag */
+                                 interfaceTag,
+                                 transmissionControl,
+                                 (CSR_RATE)0,
+                                 priority,
+                                 priv->netdev_client->sender_id,
+                                 &bulkdata);
+
+    if (r) {
+        unifi_trace(priv, UDBG1, "(HIP validation failure) r = %x\n", r);
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+        return -1;
+    }
+
+    unifi_trace(priv, UDBG3, "leaving send_ma_pkt_request, UNITDATA result code = %d\n", r);
+
+    return r;
+} /* send_ma_pkt_request() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_net_xmit
+ *
+ *      This function is called by the higher level stack to transmit an
+ *      ethernet packet.
+ *
+ *  Arguments:
+ *      skb     Ethernet packet to send.
+ *      dev     Pointer to the linux net device.
+ *
+ *  Returns:
+ *      0   on success (packet was consumed, not necessarily transmitted)
+ *      1   if packet was requeued
+ *     -1   on error
+ *
+ *
+ *  Notes:
+ *      The controlled port is handled in the qdisc dequeue handler.
+ * ---------------------------------------------------------------------------
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+static netdev_tx_t
+#else
+static int
+#endif
+uf_net_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct ethhdr ehdr;
+    int proto, port;
+    int result;
+    static tx_signal_handler tx_handler;
+    CSR_PRIORITY priority;
+#if !defined (CONFIG_NET_SCHED) || (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28))
+    CsrWifiRouterCtrlPortAction port_action;
+#endif /* CONFIG_NET_SCHED */
+
+    func_enter();
+
+    unifi_trace(priv, UDBG5, "unifi_net_xmit: skb = %x\n", skb);
+
+    memcpy(&ehdr, skb->data, ETH_HLEN);
+    proto = ntohs(ehdr.h_proto);
+    priority = get_packet_priority(priv, skb, &ehdr, interfacePriv);
+
+    /* All frames are sent as MA-PACKET.req (EAPOL also) */
+    tx_handler = send_ma_pkt_request;
+
+    /* 802.1x - apply controlled/uncontrolled port rules */
+    if ((proto != ETH_P_PAE)
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+            && (proto != ETH_P_WAI)
+#endif
+       ) {
+        port = UF_CONTROLLED_PORT_Q;
+    } else {
+        /* queue 4 */
+        port = UF_UNCONTROLLED_PORT_Q;
+    }
+
+#if defined (CONFIG_NET_SCHED) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28))
+    /* Remove the ethernet header */
+    skb_pull(skb, ETH_HLEN);
+    result = tx_handler(priv, skb, &ehdr, priority);
+#else
+    /* Uncontrolled port rules apply */
+    port_action = verify_port(priv
+        , (((CSR_WIFI_ROUTER_CTRL_MODE_STA == interfacePriv->interfaceMode)||(CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI== interfacePriv->interfaceMode))? interfacePriv->bssid.a: ehdr.h_dest)
+        , port
+        , interfacePriv->InterfaceTag);
+
+    if (port_action == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN) {
+        unifi_trace(priv, UDBG5,
+                    "uf_net_xmit: %s controlled port open\n",
+                    port ? "" : "un");
+        /* Remove the ethernet header */
+        skb_pull(skb, ETH_HLEN);
+        result = tx_handler(priv, skb, &ehdr, priority);
+    } else {
+
+        /* Discard the packet if necessary */
+        unifi_trace(priv, UDBG2,
+                "uf_net_xmit: %s controlled port %s\n",
+                port ? "" : "un", port_action==CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_BLOCK ? "blocked" : "closed");
+        interfacePriv->stats.tx_dropped++;
+        kfree_skb(skb);
+
+        func_exit();
+        return NETDEV_TX_OK;
+    }
+#endif /* CONFIG_NET_SCHED */
+
+    if (result == NETDEV_TX_OK) {
+
+        dev->trans_start = jiffies;
+
+        /*
+         * Should really count tx stats in the UNITDATA.status signal but
+         * that doesn't have the length.
+         */
+        interfacePriv->stats.tx_packets++;
+        /* count only the packet payload */
+        interfacePriv->stats.tx_bytes += skb->len;
+
+    } else if (result < 0) {
+
+        /* Failed to send: fh queue was full, and the skb was discarded.
+         * Return OK to indicate that the buffer was consumed, to stop the
+         * kernel re-transmitting the freed buffer.
+         */
+        interfacePriv->stats.tx_dropped++;
+        unifi_trace(priv, UDBG1, "unifi_net_xmit: (Packet Drop), dropped count = %x\n", interfacePriv->stats.tx_dropped);
+        result = NETDEV_TX_OK;
+    }
+
+    /* The skb will have been freed by send_XXX_request() */
+
+    func_exit();
+    return result;
+} /* uf_net_xmit() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_pause_xmit
+ *  unifi_restart_xmit
+ *
+ *      These functions are called from the UniFi core to control the flow
+ *      of packets from the upper layers.
+ *      unifi_pause_xmit() is called when the internal queue is full and
+ *      should take action to stop unifi_ma_unitdata() being called.
+ *      When the queue has drained, unifi_restart_xmit() will be called to
+ *      re-enable the flow of packets for transmission.
+ *
+ *  Arguments:
+ *      ospriv          OS private context pointer.
+ *
+ *  Returns:
+ *      unifi_pause_xmit() is called from interrupt context.
+ * ---------------------------------------------------------------------------
+ */
+void
+unifi_pause_xmit(void *ospriv, unifi_TrafficQueue queue)
+{
+    unifi_priv_t *priv = ospriv;
+    int i; /* used as a loop counter */
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "Stopping queue %d\n", queue);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+    for(i=0;i<CSR_WIFI_NUM_INTERFACES;i++)
+    {
+        if (netif_running(priv->netdev[i]))
+        {
+            netif_stop_subqueue(priv->netdev[i], (u16)queue);
+        }
+    }
+#else
+#ifdef ALLOW_Q_PAUSE
+    unifi_trace(priv, UDBG2, "Stopping netif\n");
+    /* stop the traffic from all the interfaces. */
+    for(i=0;i<CSR_WIFI_NUM_INTERFACES;i++)
+    {
+        if (netif_running(priv->netdev[i])) {
+            UF_NETIF_TX_STOP_ALL_QUEUES(priv->netdev[i]);
+        }
+    }
+#else
+    if (net_is_tx_q_paused(priv, queue)) {
+        unifi_trace(priv, UDBG2, "Queue already stopped\n");
+        return;
+    }
+    net_tx_q_pause(priv, queue);
+#endif
+#endif
+
+#ifdef CSR_SUPPORT_SME
+    if(queue<=3) {
+        routerStartBuffering(priv,queue);
+        unifi_trace(priv,UDBG2,"Start buffering %d\n", queue);
+     } else {
+        routerStartBuffering(priv,0);
+        unifi_error(priv, "Start buffering %d defaulting to 0\n", queue);
+     }
+#endif
+    func_exit();
+
+} /* unifi_pause_xmit() */
+
+void
+unifi_restart_xmit(void *ospriv, unifi_TrafficQueue queue)
+{
+    unifi_priv_t *priv = ospriv;
+    int i=0; /* used as a loop counter */
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "Waking queue %d\n", queue);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+    for(i=0;i<CSR_WIFI_NUM_INTERFACES;i++)
+    {
+        if (netif_running(priv->netdev[i]))
+        {
+            netif_wake_subqueue(priv->netdev[i], (u16)queue);
+        }
+    }
+#else
+#ifdef ALLOW_Q_PAUSE
+    /* Need to supply queue number depending on Kernel support */
+    /* Resume the traffic from all the interfaces */
+    for(i=0;i<CSR_WIFI_NUM_INTERFACES;i++)
+    {
+        if (netif_running(priv->netdev[i])) {
+            UF_NETIF_TX_WAKE_ALL_QUEUES(priv->netdev[i]);
+        }
+    }
+#else
+    if (!(net_is_tx_q_paused(priv, queue))) {
+        unifi_trace(priv, UDBG2, "Queue already running\n");
+        func_exit();
+        return;
+    }
+    net_tx_q_unpause(priv, queue);
+#endif
+#endif
+
+#ifdef CSR_SUPPORT_SME
+    if(queue <=3) {
+        routerStopBuffering(priv,queue);
+        uf_send_buffered_frames(priv,queue);
+    } else {
+        routerStopBuffering(priv,0);
+        uf_send_buffered_frames(priv,0);
+    }
+#endif
+    func_exit();
+} /* unifi_restart_xmit() */
+
+
+static void
+indicate_rx_skb(unifi_priv_t *priv, CsrUint16 ifTag, CsrUint8* dst_a, CsrUint8* src_a, struct sk_buff *skb, CSR_SIGNAL *signal,
+                bulk_data_param_t *bulkdata)
+{
+    int r, sr = 0;
+    struct net_device *dev;
+
+#ifdef CSR_SUPPORT_SME
+    llc_snap_hdr_t *snap;
+
+    snap = (llc_snap_hdr_t *)skb->data;
+
+    sr = _identify_sme_ma_pkt_ind(priv,
+                                  snap->oui, ntohs(snap->protocol),
+                                  signal,
+                                  bulkdata,
+                                  dst_a, src_a );
+#endif
+
+    /*
+     * Decapsulate any SNAP header and
+     * prepend an ethernet header so that the skb manipulation and ARP
+     * stuff works.
+     */
+    r = skb_80211_to_ether(priv, skb, dst_a, src_a,
+                           signal, bulkdata);
+    if (r == -1) {
+        /* Drop the packet and return */
+        priv->interfacePriv[ifTag]->stats.rx_errors++;
+        priv->interfacePriv[ifTag]->stats.rx_frame_errors++;
+        unifi_net_data_free(priv, &bulkdata->d[0]);
+        unifi_notice(priv, "indicate_rx_skb: Discard unknown frame.\n");
+        func_exit();
+        return;
+    }
+
+    /* Handle the case where packet is sent up through the subscription
+     * API but should not be given to the network stack (AMP PAL case)
+     * LLC header is different from WiFi and the packet has been subscribed for
+     */
+    if (r == 1 && sr == 1) {
+        unifi_net_data_free(priv, &bulkdata->d[0]);
+        unifi_trace(priv, UDBG5, "indicate_rx_skb: Data given to subscription"
+                "API, not being given to kernel\n");
+        func_exit();
+        return;
+    }
+
+    dev = priv->netdev[ifTag];
+    /* Now we look like a regular ethernet frame */
+    /* Fill in SKB meta data */
+    skb->dev = dev;
+    skb->protocol = eth_type_trans(skb, dev);
+    skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+    /* Test for an overlength frame */
+    if (skb->len > (dev->mtu + ETH_HLEN)) {
+        /* A bogus length ethfrm has been encap'd. */
+        /* Is someone trying an oflow attack? */
+        unifi_error(priv, "%s: oversize frame (%d > %d)\n",
+                    dev->name,
+                    skb->len, dev->mtu + ETH_HLEN);
+
+        /* Drop the packet and return */
+        priv->interfacePriv[ifTag]->stats.rx_errors++;
+        priv->interfacePriv[ifTag]->stats.rx_length_errors++;
+        unifi_net_data_free(priv, &bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+
+
+    /* Pass SKB up the stack */
+#ifdef CSR_WIFI_USE_NETIF_RX
+        netif_rx(skb);
+#else
+        netif_rx_ni(skb);
+#endif
+
+    if (dev != NULL) {
+        dev->last_rx = jiffies;
+    }
+
+    /* Bump rx stats */
+    priv->interfacePriv[ifTag]->stats.rx_packets++;
+    priv->interfacePriv[ifTag]->stats.rx_bytes += bulkdata->d[0].data_length;
+
+    func_exit();
+    return;
+}
+
+void
+uf_process_rx_pending_queue(unifi_priv_t *priv, int queue,
+                            CsrWifiMacAddress source_address,
+                            int indicate, CsrUint16 interfaceTag)
+{
+    rx_buffered_packets_t *rx_q_item;
+    struct list_head *rx_list;
+    struct list_head *n;
+    struct list_head *l_h;
+    static const CsrWifiMacAddress broadcast_address = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "uf_process_rx_pending_queue bad interfaceTag\n");
+        return;
+    }
+
+    if (queue == UF_CONTROLLED_PORT_Q) {
+        rx_list = &interfacePriv->rx_controlled_list;
+    } else {
+        rx_list = &interfacePriv->rx_uncontrolled_list;
+    }
+
+    down(&priv->rx_q_sem);
+    list_for_each_safe(l_h, n, rx_list) {
+        rx_q_item = list_entry(l_h, rx_buffered_packets_t, q);
+
+        /* Validate against the source address */
+        if (memcmp(broadcast_address.a, source_address.a, ETH_ALEN) &&
+                memcmp(rx_q_item->sa.a, source_address.a, ETH_ALEN)) {
+
+            unifi_trace(priv, UDBG2,
+                        "uf_process_rx_pending_queue: Skipping sa=%02X%02X%02X%02X%02X%02X skb=%p, bulkdata=%p\n",
+                        rx_q_item->sa.a[0], rx_q_item->sa.a[1],
+                        rx_q_item->sa.a[2], rx_q_item->sa.a[3],
+                        rx_q_item->sa.a[4], rx_q_item->sa.a[5],
+                        rx_q_item->skb, &rx_q_item->bulkdata.d[0]);
+            continue;
+        }
+
+        list_del(l_h);
+
+
+        unifi_trace(priv, UDBG2,
+                    "uf_process_rx_pending_queue: Was Blocked skb=%p, bulkdata=%p\n",
+                    rx_q_item->skb, &rx_q_item->bulkdata);
+
+        if (indicate) {
+            indicate_rx_skb(priv, interfaceTag, rx_q_item->da.a, rx_q_item->sa.a, rx_q_item->skb, &rx_q_item->signal, &rx_q_item->bulkdata);
+        } else {
+            interfacePriv->stats.rx_dropped++;
+            unifi_net_data_free(priv, &rx_q_item->bulkdata.d[0]);
+        }
+
+        /* It is our resposibility to free the Rx structure object. */
+        kfree(rx_q_item);
+    }
+    up(&priv->rx_q_sem);
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_resume_data_plane
+ *
+ *      Is called when the (un)controlled port is set to open,
+ *      to notify the network stack to schedule for transmission
+ *      any packets queued in the qdisk while port was closed and
+ *      indicated to the stack any packets buffered in the Rx queues.
+ *
+ *  Arguments:
+ *      priv        Pointer to device private struct
+ *
+ *  Returns:
+ * ---------------------------------------------------------------------------
+ */
+void
+uf_resume_data_plane(unifi_priv_t *priv, int queue,
+                     CsrWifiMacAddress peer_address,
+                     CsrUint16 interfaceTag)
+{
+#ifdef CSR_SUPPORT_WEXT
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+#endif
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "uf_resume_data_plane bad interfaceTag\n");
+        return;
+    }
+
+    unifi_trace(priv, UDBG2, "Resuming netif\n");
+
+    /*
+     * If we are waiting for the net device to enter the up state, don't
+     * process the rx queue yet as it will be done by the callback when
+     * the device is ready.
+     */
+#ifdef CSR_SUPPORT_WEXT
+    if (!interfacePriv->wait_netdev_change)
+#endif
+    {
+#ifdef CONFIG_NET_SCHED
+        if (netif_running(priv->netdev[interfaceTag])) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+            netif_tx_schedule_all(priv->netdev[interfaceTag]);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+            netif_schedule_queue(netdev_get_tx_queue(priv->netdev[interfaceTag], 0));
+#else
+            netif_schedule(priv->netdev[interfaceTag]);
+#endif /* LINUX_VERSION_CODE */
+        }
+#endif
+        uf_process_rx_pending_queue(priv, queue, peer_address, 1,interfaceTag);
+    }
+} /* uf_resume_data_plane() */
+
+
+void uf_free_pending_rx_packets(unifi_priv_t *priv, int queue, CsrWifiMacAddress peer_address,CsrUint16 interfaceTag)
+{
+    uf_process_rx_pending_queue(priv, queue, peer_address, 0,interfaceTag);
+
+} /* uf_free_pending_rx_packets() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_rx
+ *
+ *      Reformat a UniFi data received packet into a p80211 packet and
+ *      pass it up the protocol stack.
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void
+unifi_rx(unifi_priv_t *priv, CSR_SIGNAL *signal, bulk_data_param_t *bulkdata)
+{
+    CsrUint16 interfaceTag;
+    bulk_data_desc_t *pData;
+    const CSR_MA_PACKET_INDICATION *pkt_ind = &signal->u.MaPacketIndication;
+    struct sk_buff *skb;
+    CsrWifiRouterCtrlPortAction port_action;
+    CsrUint8 dataFrameType;
+    int proto;
+    int queue;
+
+    CsrUint8 da[ETH_ALEN], sa[ETH_ALEN];
+    CsrUint8 toDs, fromDs, frameType, macHeaderLengthInBytes = MAC_HEADER_SIZE;
+    CsrUint16 frameControl;
+    netInterface_priv_t *interfacePriv;
+    struct ethhdr ehdr;
+
+    func_enter();
+
+    interfaceTag = (pkt_ind->VirtualInterfaceIdentifier & 0xff);
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    /* Sanity check that the VIF refers to a sensible interface */
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES)
+    {
+        unifi_error(priv, "%s: MA-PACKET indication with bad interfaceTag %d\n", __FUNCTION__, interfaceTag);
+        unifi_net_data_free(priv,&bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+
+    /* Sanity check that the VIF refers to an allocated netdev */
+    if (!interfacePriv->netdev_registered)
+    {
+        unifi_error(priv, "%s: MA-PACKET indication with unallocated interfaceTag %d\n", __FUNCTION__, interfaceTag);
+        unifi_net_data_free(priv, &bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+
+    if (bulkdata->d[0].data_length == 0) {
+        unifi_warning(priv, "%s: MA-PACKET indication with zero bulk data\n", __FUNCTION__);
+        unifi_net_data_free(priv,&bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+
+
+    skb = (struct sk_buff*)bulkdata->d[0].os_net_buf_ptr;
+    skb->len = bulkdata->d[0].data_length;
+
+    /* Point to the addresses */
+    toDs = (skb->data[1] & 0x01) ? 1 : 0;
+    fromDs = (skb->data[1] & 0x02) ? 1 : 0;
+
+    memcpy(da,(skb->data+4+toDs*12),ETH_ALEN);/* Address1 or 3 */
+    memcpy(sa,(skb->data+10+fromDs*(6+toDs*8)),ETH_ALEN); /* Address2, 3 or 4 */
+
+
+    pData = &bulkdata->d[0];
+    frameControl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(pData->os_data_ptr);
+    frameType = ((frameControl & 0x000C) >> 2);
+
+    dataFrameType =((frameControl & 0x00f0) >> 4);
+    unifi_trace(priv, UDBG6,
+                "%s: Receive Data Frame Type %d \n", __FUNCTION__,dataFrameType);
+
+    switch(dataFrameType)
+    {
+        case QOS_DATA:
+        case QOS_DATA_NULL:
+            /* If both are set then the Address4 exists (only for AP) */
+            if (fromDs && toDs)
+            {
+                /* 6 is the size of Address4 field */
+                macHeaderLengthInBytes += (QOS_CONTROL_HEADER_SIZE + 6);
+            }
+            else
+            {
+                macHeaderLengthInBytes += QOS_CONTROL_HEADER_SIZE;
+            }
+
+            /* If order bit set then HT control field is the part of MAC header */
+            if (frameControl & FRAME_CONTROL_ORDER_BIT)
+                macHeaderLengthInBytes += HT_CONTROL_HEADER_SIZE;
+            break;
+        default:
+            if (fromDs && toDs)
+                macHeaderLengthInBytes += 6;
+    }
+
+    /* Prepare the ethernet header from snap header of skb data */
+    switch(dataFrameType)
+    {
+        case DATA_NULL:
+        case QOS_DATA_NULL:
+            /* This is for only queue info fetching, EAPOL wont come as
+             * null data so the proto is initialized as zero
+             */
+            proto = 0x0;
+            break;
+        default:
+            {
+                llc_snap_hdr_t *snap;
+                /* Fetch a snap header to find protocol (for IPV4/IPV6 packets
+                 * the snap header fetching offset is same)
+                 */
+                snap = (llc_snap_hdr_t *) (skb->data + macHeaderLengthInBytes);
+
+                /* prepare the ethernet header from the snap header & addresses */
+                ehdr.h_proto = snap->protocol;
+                memcpy(ehdr.h_dest, da, ETH_ALEN);
+                memcpy(ehdr.h_source, sa, ETH_ALEN);
+            }
+            proto = ntohs(ehdr.h_proto);
+    }
+    unifi_trace(priv, UDBG3, "in unifi_rx protocol from snap header = 0x%x\n", proto);
+
+    if ((proto != ETH_P_PAE)
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+            && (proto != ETH_P_WAI)
+#endif
+       ) {
+        queue = UF_CONTROLLED_PORT_Q;
+    } else {
+        queue = UF_UNCONTROLLED_PORT_Q;
+    }
+
+    port_action = verify_port(priv, (unsigned char*)sa, queue, interfaceTag);
+    unifi_trace(priv, UDBG3, "in unifi_rx port action is = 0x%x & queue = %x\n", port_action, queue);
+
+#ifdef CSR_SUPPORT_SME
+    /* Notify the TA module for the Rx frame for non P2PGO and AP cases*/
+    if((interfacePriv->interfaceMode != CSR_WIFI_ROUTER_CTRL_MODE_AP) &&
+            (interfacePriv->interfaceMode != CSR_WIFI_ROUTER_CTRL_MODE_P2PGO))
+    {
+        /* Remove MAC header of length(macHeaderLengthInBytes) before sampling */
+        skb_pull(skb, macHeaderLengthInBytes);
+        pData->os_data_ptr = skb->data;
+        pData->data_length -= macHeaderLengthInBytes;
+
+        if (pData->data_length) {
+            unifi_ta_sample(priv->card, CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_RX,
+                            &bulkdata->d[0],
+                            sa, priv->netdev[interfaceTag]->dev_addr,
+                            jiffies_to_msecs(jiffies),
+                            pkt_ind->ReceivedRate);
+        }
+    } else {
+
+        /* AP/P2PGO specific handling here */
+        CsrWifiRouterCtrlStaInfo_t * srcStaInfo =
+            CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv,sa,interfaceTag);
+
+        /* Defensive check only; Source address is already checked in
+        process_ma_packet_ind and we should have a valid source address here */
+
+         if(srcStaInfo == NULL) {
+            CsrWifiMacAddress peerMacAddress;
+            /* Unknown data PDU */
+            memcpy(peerMacAddress.a,sa,ETH_ALEN);
+            unifi_trace(priv, UDBG1, "%s: Unexpected frame from peer = %x:%x:%x:%x:%x:%x\n", __FUNCTION__,
+            sa[0], sa[1],sa[2], sa[3], sa[4],sa[5]);
+            CsrWifiRouterCtrlUnexpectedFrameIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,interfaceTag,peerMacAddress);
+            unifi_net_data_free(priv, &bulkdata->d[0]);
+            func_exit();
+            return;
+        }
+
+       /* For AP GO mode, don't store the PDUs */
+        if (port_action != CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN) {
+            /* Drop the packet and return */
+            CsrWifiMacAddress peerMacAddress;
+            memcpy(peerMacAddress.a,sa,ETH_ALEN);
+            unifi_trace(priv, UDBG3, "%s: Port is not open: unexpected frame from peer = %x:%x:%x:%x:%x:%x\n",
+                        __FUNCTION__, sa[0], sa[1],sa[2], sa[3], sa[4],sa[5]);
+
+            CsrWifiRouterCtrlUnexpectedFrameIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,interfaceTag,peerMacAddress);
+            interfacePriv->stats.rx_dropped++;
+            unifi_net_data_free(priv, &bulkdata->d[0]);
+            unifi_notice(priv, "%s: Dropping packet, proto=0x%04x, %s port\n", __FUNCTION__,
+                         proto, queue ? "Controlled" : "Un-controlled");
+            func_exit();
+            return;
+        }
+
+         /* Qos NULL/Data NULL  are freed here and not processed further */
+        if((dataFrameType == QOS_DATA_NULL) || (dataFrameType == DATA_NULL)){
+            unifi_trace(priv, UDBG5, "%s: Null Frame Received and Freed\n", __FUNCTION__);
+            unifi_net_data_free(priv, &bulkdata->d[0]);
+            func_exit();
+            return;
+        }
+
+        /* Now we have done with MAC header so proceed with the real data part*/
+        /* This function takes care of appropriate routing for AP/P2PGO case*/
+        /* the function hadnles following things
+           2. Routing the PDU to appropriate location
+           3. Error case handling
+           */
+        if(!(uf_ap_process_data_pdu(priv, skb, &ehdr, srcStaInfo,
+             signal,
+             bulkdata,
+             macHeaderLengthInBytes)))
+        {
+            func_exit();
+            return;
+        }
+        unifi_trace(priv, UDBG5, "unifi_rx: no specific AP handling process as normal frame, MAC Header len %d\n",macHeaderLengthInBytes);
+        /* Remove the MAC header for subsequent conversion */
+        skb_pull(skb, macHeaderLengthInBytes);
+        pData->os_data_ptr = skb->data;
+        pData->data_length -= macHeaderLengthInBytes;
+        pData->os_net_buf_ptr = (unsigned char*)skb;
+        pData->net_buf_length = skb->len;
+    }
+#endif /* CSR_SUPPORT_SME */
+
+
+    /* Now that the MAC header is removed, null-data frames have zero length
+     * and can be dropped
+     */
+    if (pData->data_length == 0) {
+        if (((frameControl & 0x00f0) >> 4) != QOS_DATA_NULL &&
+            ((frameControl & 0x00f0) >> 4) != DATA_NULL) {
+            unifi_trace(priv, UDBG1, "Zero length frame, but not null-data %04x\n", frameControl);
+        }
+        unifi_net_data_free(priv, &bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+
+    if (port_action == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD) {
+        /* Drop the packet and return */
+        interfacePriv->stats.rx_dropped++;
+        unifi_net_data_free(priv, &bulkdata->d[0]);
+        unifi_notice(priv, "%s: Dropping packet, proto=0x%04x, %s port\n",
+                     __FUNCTION__, proto, queue ? "controlled" : "uncontrolled");
+        func_exit();
+        return;
+    } else if ( (port_action == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_BLOCK) ||
+                   (interfacePriv->connected != UnifiConnected) ) {
+
+        /* Buffer the packet into the Rx queues */
+        rx_buffered_packets_t *rx_q_item;
+        struct list_head *rx_list;
+
+        rx_q_item = (rx_buffered_packets_t *)kmalloc(sizeof(rx_buffered_packets_t),
+                GFP_KERNEL);
+        if (rx_q_item == NULL) {
+            unifi_error(priv, "%s: Failed to allocate %d bytes for rx packet record\n",
+                        __FUNCTION__, sizeof(rx_buffered_packets_t));
+            interfacePriv->stats.rx_dropped++;
+            unifi_net_data_free(priv, &bulkdata->d[0]);
+            func_exit();
+            return;
+        }
+
+        INIT_LIST_HEAD(&rx_q_item->q);
+        rx_q_item->bulkdata = *bulkdata;
+        rx_q_item->skb = skb;
+        rx_q_item->signal = *signal;
+        memcpy(rx_q_item->sa.a, sa, ETH_ALEN);
+        memcpy(rx_q_item->da.a, da, ETH_ALEN);
+        unifi_trace(priv, UDBG2, "%s: Blocked skb=%p, bulkdata=%p\n",
+                    __FUNCTION__, rx_q_item->skb, &rx_q_item->bulkdata);
+
+        if (queue == UF_CONTROLLED_PORT_Q) {
+            rx_list = &interfacePriv->rx_controlled_list;
+        } else {
+            rx_list = &interfacePriv->rx_uncontrolled_list;
+        }
+
+        /* Add to tail of packets queue */
+        down(&priv->rx_q_sem);
+        list_add_tail(&rx_q_item->q, rx_list);
+        up(&priv->rx_q_sem);
+
+        func_exit();
+        return;
+
+    }
+
+    indicate_rx_skb(priv, interfaceTag, da, sa, skb, signal, bulkdata);
+
+    func_exit();
+
+} /* unifi_rx() */
+
+static void process_ma_packet_cfm(unifi_priv_t *priv, CSR_SIGNAL *signal, bulk_data_param_t *bulkdata)
+{
+    CsrUint16 interfaceTag;
+    const CSR_MA_PACKET_CONFIRM *pkt_cfm = &signal->u.MaPacketConfirm;
+    netInterface_priv_t *interfacePriv;
+
+    func_enter();
+    interfaceTag = (pkt_cfm->VirtualInterfaceIdentifier & 0xff);
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    /* Sanity check that the VIF refers to a sensible interface */
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES)
+    {
+        unifi_error(priv, "%s: MA-PACKET confirm with bad interfaceTag %d\n", __FUNCTION__, interfaceTag);
+        func_exit();
+        return;
+    }
+#ifdef CSR_SUPPORT_SME
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+
+        uf_process_ma_pkt_cfm_for_ap(priv,interfaceTag,pkt_cfm);
+    } else if (interfacePriv->m4_sent && (pkt_cfm->HostTag == interfacePriv->m4_hostTag)) {
+        /* Check if this is a confirm for EAPOL M4 frame and we need to send transmistted ind*/
+        CsrResult result = pkt_cfm->TransmissionStatus == CSR_TX_SUCCESSFUL?CSR_RESULT_SUCCESS:CSR_RESULT_FAILURE;
+        CsrWifiMacAddress peerMacAddress;
+        memcpy(peerMacAddress.a, interfacePriv->m4_signal.u.MaPacketRequest.Ra.x, ETH_ALEN);
+
+        unifi_trace(priv, UDBG1, "%s: Sending M4 Transmit CFM\n", __FUNCTION__);
+        CsrWifiRouterCtrlM4TransmittedIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0,
+                                              interfaceTag,
+                                              peerMacAddress,
+                                              result);
+        interfacePriv->m4_sent = FALSE;
+        interfacePriv->m4_hostTag = 0xffffffff;
+    }
+#endif
+    func_exit();
+    return;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_rx
+ *
+ *      Reformat a UniFi data received packet into a p80211 packet and
+ *      pass it up the protocol stack.
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void process_ma_packet_ind(unifi_priv_t *priv, CSR_SIGNAL *signal, bulk_data_param_t *bulkdata)
+{
+    CsrUint16 interfaceTag;
+    bulk_data_desc_t *pData;
+    CSR_MA_PACKET_INDICATION *pkt_ind = (CSR_MA_PACKET_INDICATION*)&signal->u.MaPacketIndication;
+    struct sk_buff *skb;
+    CsrUint16 frameControl;
+    netInterface_priv_t *interfacePriv;
+    CsrUint8 da[ETH_ALEN], sa[ETH_ALEN];
+    CsrUint8 *bssid = NULL, *ba_addr = NULL;
+    CsrUint8 toDs, fromDs, frameType;
+    CsrUint8 i =0;
+
+#ifdef CSR_SUPPORT_SME
+    CsrUint8 dataFrameType = 0;
+    CsrBool powerSaveChanged = FALSE;
+    CsrUint8 pmBit = 0;
+    CsrWifiRouterCtrlStaInfo_t *srcStaInfo = NULL;
+    CsrUint16 qosControl;
+
+#endif
+
+    func_enter();
+
+    interfaceTag = (pkt_ind->VirtualInterfaceIdentifier & 0xff);
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+
+    /* Sanity check that the VIF refers to a sensible interface */
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES)
+    {
+        unifi_error(priv, "%s: MA-PACKET indication with bad interfaceTag %d\n", __FUNCTION__, interfaceTag);
+        unifi_net_data_free(priv,&bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+
+    /* Sanity check that the VIF refers to an allocated netdev */
+    if (!interfacePriv->netdev_registered)
+    {
+        unifi_error(priv, "%s: MA-PACKET indication with unallocated interfaceTag %d\n", __FUNCTION__, interfaceTag);
+        unifi_net_data_free(priv, &bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+
+    if (bulkdata->d[0].data_length == 0) {
+        unifi_warning(priv, "%s: MA-PACKET indication with zero bulk data\n", __FUNCTION__);
+        unifi_net_data_free(priv,&bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+    /* For monitor mode we need to pass this indication to the registered application
+    handle this seperately*/
+    /* MIC failure is already taken care of so no need to send the PDUs which are not successfully received in non-monitor mode*/
+    if(pkt_ind->ReceptionStatus != CSR_RX_SUCCESS)
+    {
+        unifi_warning(priv, "%s: MA-PACKET indication with status = %d\n",__FUNCTION__, pkt_ind->ReceptionStatus);
+        unifi_net_data_free(priv,&bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+
+
+    skb = (struct sk_buff*)bulkdata->d[0].os_net_buf_ptr;
+    skb->len = bulkdata->d[0].data_length;
+
+    /* Point to the addresses */
+    toDs = (skb->data[1] & 0x01) ? 1 : 0;
+    fromDs = (skb->data[1] & 0x02) ? 1 : 0;
+
+    memcpy(da,(skb->data+4+toDs*12),ETH_ALEN);/* Address1 or 3 */
+    memcpy(sa,(skb->data+10+fromDs*(6+toDs*8)),ETH_ALEN); /* Address2, 3 or 4 */
+
+    /* Find the BSSID, which will be used to match the BA session */
+    if (toDs && fromDs)
+    {
+        unifi_trace(priv, UDBG6, "4 address frame - don't try to find BSSID\n");
+        bssid = NULL;
+    }
+    else
+    {
+        bssid = (CsrUint8 *) (skb->data + 4 + 12 - (fromDs * 6) - (toDs * 12));
+    }
+
+    pData = &bulkdata->d[0];
+    frameControl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(pData->os_data_ptr);
+    frameType = ((frameControl & 0x000C) >> 2);
+
+    unifi_trace(priv, UDBG3, "Rx Frame Type: %d sn: %d\n",frameType,
+         (le16_to_cpu(*((CsrUint16*)(bulkdata->d[0].os_data_ptr + IEEE802_11_SEQUENCE_CONTROL_OFFSET))) >> 4) & 0xfff);
+    if(frameType == IEEE802_11_FRAMETYPE_CONTROL){
+#ifdef CSR_SUPPORT_SME
+        unifi_trace(priv, UDBG6, "%s: Received Control Frame\n", __FUNCTION__);
+
+        if((frameControl & 0x00f0) == 0x00A0){
+            /* This is a PS-POLL request */
+            CsrUint8 pmBit = (frameControl & 0x1000)?0x01:0x00;
+            unifi_trace(priv, UDBG6, "%s: Received PS-POLL Frame\n", __FUNCTION__);
+
+            uf_process_ps_poll(priv,sa,da,pmBit,interfaceTag);
+        }
+        else {
+            unifi_warning(priv, "%s: Non PS-POLL control frame is received\n", __FUNCTION__);
+        }
+#endif
+        unifi_net_data_free(priv,&bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+    if(frameType != IEEE802_11_FRAMETYPE_DATA) {
+        unifi_warning(priv, "%s: Non control Non Data frame is received\n",__FUNCTION__);
+        unifi_net_data_free(priv,&bulkdata->d[0]);
+        func_exit();
+        return;
+    }
+
+#ifdef CSR_SUPPORT_SME
+    if((interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP) ||
+       (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO)){
+
+        srcStaInfo = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv,sa,interfaceTag);
+
+        if(srcStaInfo == NULL) {
+            CsrWifiMacAddress peerMacAddress;
+            /* Unknown data PDU */
+            memcpy(peerMacAddress.a,sa,ETH_ALEN);
+            unifi_trace(priv, UDBG1, "%s: Unexpected frame from peer = %x:%x:%x:%x:%x:%x\n", __FUNCTION__,
+            sa[0], sa[1],sa[2], sa[3], sa[4],sa[5]);
+            CsrWifiRouterCtrlUnexpectedFrameIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,interfaceTag,peerMacAddress);
+            unifi_net_data_free(priv, &bulkdata->d[0]);
+            func_exit();
+            return;
+        }
+
+        /*
+        verify power management bit here so as to ensure host and unifi are always
+        in sync with power management status of peer.
+
+        If we do it later, it may so happen we have stored the frame in BA re-ordering
+        buffer and hence host and unifi are out of sync for power management status
+        */
+
+        pmBit = (frameControl & 0x1000)?0x01:0x00;
+        powerSaveChanged = uf_process_pm_bit_for_peer(priv,srcStaInfo,pmBit,interfaceTag);
+
+        /* Update station last activity time */
+        srcStaInfo->activity_flag = TRUE;
+
+        /* For Qos Frame if PM bit is toggled to indicate the change in power save state then it shall not be
+        considered as Trigger Frame. Enter only if WMM STA and peer is in Power save */
+
+        dataFrameType = ((frameControl & 0x00f0) >> 4);
+
+        if((powerSaveChanged == FALSE)&&(srcStaInfo->wmmOrQosEnabled == TRUE)&&
+        (srcStaInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)){
+
+            if((dataFrameType == QOS_DATA) || (dataFrameType == QOS_DATA_NULL)){
+
+                /*
+                  QoS control field is offset from frame control by 2 (frame control)
+                  + 2 (duration/ID) + 2 (sequence control) + 3*ETH_ALEN or 4*ETH_ALEN
+                */
+                if((frameControl & IEEE802_11_FC_TO_DS_MASK) && (frameControl & IEEE802_11_FC_FROM_DS_MASK)){
+                    qosControl= CSR_GET_UINT16_FROM_LITTLE_ENDIAN(pData->os_data_ptr + 30);
+                }
+                else{
+                    qosControl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(pData->os_data_ptr + 24);
+                }
+
+                if((IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag))){
+                    CSR_PRIORITY priority;
+                    unifi_TrafficQueue priority_q;
+                    priority = (CSR_PRIORITY)(qosControl & IEEE802_11_QC_TID_MASK);
+                    priority_q = unifi_frame_priority_to_queue((CSR_PRIORITY) priority);
+                    if((srcStaInfo->powersaveMode[priority_q]==CSR_WIFI_AC_TRIGGER_ONLY_ENABLED)
+                               ||(srcStaInfo->powersaveMode[priority_q]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED)){
+                        unsigned long lock_flags;
+                        spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+                        srcStaInfo->uapsdSuspended = TRUE;
+                        spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+                        unifi_trace(priv, UDBG3, "%s: qos Trigger Frame received while DTIM Active for staid: 0x%x\n",__FUNCTION__,srcStaInfo->aid);
+                    }
+                }
+                else{
+
+
+                    unifi_trace(priv, UDBG5, "%s: Check if U-APSD operations are triggered for qosControl: 0x%x\n",__FUNCTION__,qosControl);
+                    uf_process_wmm_deliver_ac_uapsd(priv,srcStaInfo,qosControl,interfaceTag);
+                }
+            }
+        }
+    }
+
+#endif
+
+    if( ((frameControl & 0x00f0) >> 4) == QOS_DATA) {
+        CsrUint8 *qos_control_ptr = (CsrUint8*)bulkdata->d[0].os_data_ptr + (((frameControl & IEEE802_11_FC_TO_DS_MASK) && (frameControl & IEEE802_11_FC_FROM_DS_MASK))?30: 24);
+        int tID = *qos_control_ptr & IEEE802_11_QC_TID_MASK; /* using ls octet of qos control */
+        ba_session_rx_struct *ba_session;
+        CsrUint8 ba_session_idx = 0;
+        /* Get the BA originator address */
+        if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+           interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO){
+            ba_addr = sa;
+        }else{
+            ba_addr = bssid;
+        }
+
+        spin_lock(&priv->ba_lock);
+        for (ba_session_idx=0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_RX; ba_session_idx++){
+            ba_session = interfacePriv->ba_session_rx[ba_session_idx];
+            if (ba_session){
+                unifi_trace(priv, UDBG6, "found ba_session=0x%x ba_session_idx=%d", ba_session, ba_session_idx);
+                if ((!memcmp(ba_session->macAddress.a, ba_addr, ETH_ALEN)) && (ba_session->tID == tID)){
+                        frame_desc_struct frame_desc;
+                        frame_desc.bulkdata = *bulkdata;
+                        frame_desc.signal = *signal;
+                        frame_desc.sn = (le16_to_cpu(*((CsrUint16*)(bulkdata->d[0].os_data_ptr + IEEE802_11_SEQUENCE_CONTROL_OFFSET))) >> 4) & 0xfff;
+                        frame_desc.active = TRUE;
+                        unifi_trace(priv, UDBG6, "%s: calling process_ba_frame (session=%d)\n", __FUNCTION__, ba_session_idx);
+                        process_ba_frame(priv, interfacePriv, ba_session, &frame_desc);
+                        spin_unlock(&priv->ba_lock);
+                        process_ba_complete(priv, interfacePriv);
+                        break;
+                }
+            }
+        }
+        if (ba_session_idx == MAX_SUPPORTED_BA_SESSIONS_RX){
+            spin_unlock(&priv->ba_lock);
+            unifi_trace(priv, UDBG6, "%s: calling process_amsdu()", __FUNCTION__);
+            process_amsdu(priv, signal, bulkdata);
+        }
+    } else {
+        unifi_trace(priv, UDBG6, "calling unifi_rx()");
+        unifi_rx(priv, signal, bulkdata);
+    }
+
+    /* check if the frames in reorder buffer has aged, the check
+     * is done after receive processing so that if the missing frame
+     * has arrived in this receive process, then it is handled cleanly.
+     *
+     * And also this code here takes care that timeout check is made for all
+     * the receive indications
+     */
+    spin_lock(&priv->ba_lock);
+    for (i=0; i < MAX_SUPPORTED_BA_SESSIONS_RX; i++){
+        ba_session_rx_struct *ba_session;
+        ba_session = interfacePriv->ba_session_rx[i];
+            if (ba_session){
+                check_ba_frame_age_timeout(priv, interfacePriv, ba_session);
+            }
+    }
+    process_ba_complete(priv, interfacePriv);
+    spin_unlock(&priv->ba_lock);
+
+    func_exit();
+}
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_set_multicast_list
+ *
+ *      This function is called by the higher level stack to set
+ *      a list of multicast rx addresses.
+ *
+ *  Arguments:
+ *      dev             Network Device pointer.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ * ---------------------------------------------------------------------------
+ */
+
+static void
+uf_set_multicast_list(struct net_device *dev)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+
+#ifdef CSR_NATIVE_LINUX
+    unifi_trace(priv, UDBG3, "uf_set_multicast_list unsupported\n");
+    return;
+#else
+
+    u8 *mc_list = interfacePriv->mc_list;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,34)
+    struct netdev_hw_addr *mc_addr;
+    int mc_addr_count;
+#else
+    struct dev_mc_list *p;      /* Pointer to the addresses structure. */
+    int i;
+#endif
+
+    if (priv->init_progress != UNIFI_INIT_COMPLETED) {
+        return;
+    }
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,34)
+    mc_addr_count = netdev_mc_count(dev);
+
+    unifi_trace(priv, UDBG3,
+            "uf_set_multicast_list (count=%d)\n", mc_addr_count);
+
+
+    /* Not enough space? */
+    if (mc_addr_count > UNIFI_MAX_MULTICAST_ADDRESSES) {
+        return;
+    }
+
+    /* Store the list to be processed by the work item. */
+    interfacePriv->mc_list_count = mc_addr_count;
+    netdev_hw_addr_list_for_each(mc_addr, &dev->mc) {
+        memcpy(mc_list, mc_addr->addr, ETH_ALEN);
+        mc_list += ETH_ALEN;
+    }
+
+#else
+    unifi_trace(priv, UDBG3,
+            "uf_set_multicast_list (count=%d)\n", dev->mc_count);
+
+    /* Not enough space? */
+    if (dev->mc_count > UNIFI_MAX_MULTICAST_ADDRESSES) {
+        return;
+    }
+
+    /* Store the list to be processed by the work item. */
+    interfacePriv->mc_list_count = dev->mc_count;
+    p = dev->mc_list;
+    for (i = 0; i < dev->mc_count; i++) {
+        memcpy(mc_list, p->dmi_addr, ETH_ALEN);
+        p = p->next;
+        mc_list += ETH_ALEN;
+    }
+#endif
+
+    /* Send a message to the workqueue */
+    queue_work(priv->unifi_workqueue, &priv->multicast_list_task);
+#endif
+
+} /* uf_set_multicast_list() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  netdev_mlme_event_handler
+ *
+ *      Callback function to be used as the udi_event_callback when registering
+ *      as a netdev client.
+ *      To use it, a client specifies this function as the udi_event_callback
+ *      to ul_register_client(). The signal dispatcher in
+ *      unifi_receive_event() will call this function to deliver a signal.
+ *
+ *  Arguments:
+ *      pcli            Pointer to the client instance.
+ *      signal          Pointer to the received signal.
+ *      signal_len      Size of the signal structure in bytes.
+ *      bulkdata        Pointer to structure containing any associated bulk data.
+ *      dir             Direction of the signal. Zero means from host,
+ *                      non-zero means to host.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void
+netdev_mlme_event_handler(ul_client_t *pcli, const u8 *sig_packed, int sig_len,
+                          const bulk_data_param_t *bulkdata_o, int dir)
+{
+    CSR_SIGNAL signal;
+    unifi_priv_t *priv = uf_find_instance(pcli->instance);
+    int id, r;
+    bulk_data_param_t bulkdata;
+
+    func_enter();
+
+    /* Just a sanity check */
+    if (sig_packed == NULL) {
+        return;
+    }
+
+    /*
+     * This copy is to silence a compiler warning about discarding the
+     * const qualifier.
+     */
+    bulkdata = *bulkdata_o;
+
+    /* Get the unpacked signal */
+    r = read_unpack_signal(sig_packed, &signal);
+    if (r) {
+        /*
+         * The CSR_MLME_CONNECTED_INDICATION_ID has a receiverID=0 so will
+         * fall through this case. It is safe to ignore this signal.
+         */
+        unifi_trace(priv, UDBG1,
+                    "Netdev - Received unknown signal 0x%.4X.\n",
+                    CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sig_packed));
+        return;
+    }
+
+    id = signal.SignalPrimitiveHeader.SignalId;
+    unifi_trace(priv, UDBG3, "Netdev - Process signal 0x%.4X\n", id);
+
+    /*
+     * Take the appropriate action for the signal.
+     */
+    switch (id) {
+        case CSR_MA_PACKET_ERROR_INDICATION_ID:
+            process_ma_packet_error_ind(priv, &signal, &bulkdata);
+            break;
+        case CSR_MA_PACKET_INDICATION_ID:
+            process_ma_packet_ind(priv, &signal, &bulkdata);
+            break;
+        case  CSR_MA_PACKET_CONFIRM_ID:
+            process_ma_packet_cfm(priv, &signal, &bulkdata);
+            break;
+#ifdef CSR_SUPPORT_SME
+        case CSR_MLME_SET_TIM_CONFIRM_ID:
+            /* Handle TIM confirms from FW & set the station record's TIM state appropriately,
+             * In case of failures, tries with max_retransmit limit
+             */
+            uf_handle_tim_cfm(priv, &signal.u.MlmeSetTimConfirm, signal.SignalPrimitiveHeader.ReceiverProcessId);
+            break;
+#endif
+        case CSR_DEBUG_STRING_INDICATION_ID:
+            debug_string_indication(priv, bulkdata.d[0].os_data_ptr, bulkdata.d[0].data_length);
+            break;
+
+        case CSR_DEBUG_WORD16_INDICATION_ID:
+            debug_word16_indication(priv, &signal);
+            break;
+
+        case CSR_DEBUG_GENERIC_CONFIRM_ID:
+        case CSR_DEBUG_GENERIC_INDICATION_ID:
+            debug_generic_indication(priv, &signal);
+            break;
+        default:
+            break;
+    }
+
+    func_exit();
+} /* netdev_mlme_event_handler() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_net_get_name
+ *
+ *      Retrieve the name (e.g. eth1) associated with this network device
+ *
+ *  Arguments:
+ *      dev             Pointer to the network device.
+ *      name            Buffer to write name
+ *      len             Size of buffer in bytes
+ *
+ *  Returns:
+ *      None
+ *
+ *  Notes:
+ * ---------------------------------------------------------------------------
+ */
+void uf_net_get_name(struct net_device *dev, char *name, int len)
+{
+    *name = '\0';
+    if (dev) {
+        strlcpy(name, dev->name, (len > IFNAMSIZ) ? IFNAMSIZ : len);
+    }
+
+} /* uf_net_get_name */
+
+
+
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#ifdef CONFIG_NET_SCHED
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_install_qdisc
+ *
+ *      Creates a root qdisc, registers our qdisc handlers and
+ *      overrides the device's qdisc_sleeping to prevent the system
+ *      from creating a new one for our network device.
+ *
+ *  Arguments:
+ *      dev             Pointer to the network device.
+ *
+ *  Returns:
+ *      0 on success, Linux error code otherwise.
+ *
+ *  Notes:
+ *      This function holds the qdisk lock so it needs to be called
+ *      after registering the network device in uf_register_netdev().
+ *      Also, the qdisc_create_dflt() API has changed in 2.6.20 to
+ *      include the parentid.
+ * ---------------------------------------------------------------------------
+ */
+int uf_install_qdisc(struct net_device *dev)
+{
+    struct Qdisc *qdisc;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+    struct netdev_queue *queue0;
+#endif /* LINUX_VERSION_CODE */
+
+
+    func_enter();
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+    /*
+     * check that there is no qdisc currently attached to device
+     * this ensures that we will be the root qdisc. (I can't find a better
+     * way to test this explicitly)
+     */
+    if (dev->qdisc_sleeping != &noop_qdisc) {
+        func_exit_r(-EFAULT);
+        return -EINVAL;
+    }
+#endif /* LINUX_VERSION_CODE */
+
+    qdisc = UF_QDISC_CREATE_DFLT(dev, &uf_qdisc_ops, TC_H_ROOT);
+    if (!qdisc) {
+        unifi_error(NULL, "%s: qdisc installation failed\n", dev->name);
+        func_exit_r(-EFAULT);
+        return -EFAULT;
+    }
+    unifi_trace(NULL, UDBG5, "%s: parent qdisc=0x%p\n",
+            dev->name, qdisc);
+
+    qdisc->handle = 0x80020000;
+    qdisc->flags = 0x0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+    queue0 = netdev_get_tx_queue(dev, 0);
+    if (queue0 == NULL) {
+        unifi_error(NULL, "%s: netdev_get_tx_queue returned no queue\n",
+                dev->name);
+        func_exit_r(-EFAULT);
+        return -EFAULT;
+    }
+    queue0->qdisc = qdisc;
+    queue0->qdisc_sleeping = qdisc;
+#else
+    qdisc_lock_tree(dev);
+    list_add_tail(&qdisc->list, &dev->qdisc_list);
+    dev->qdisc_sleeping = qdisc;
+    qdisc_unlock_tree(dev);
+#endif /* LINUX_VERSION_CODE */
+
+    func_exit_r(0);
+    return 0;
+
+} /* uf_install_qdisc() */
+
+static int uf_qdiscop_enqueue(struct sk_buff *skb, struct Qdisc* qd)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(qd->dev_queue->dev);
+#else
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(qd->dev);
+#endif /* LINUX_VERSION_CODE */
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct uf_sched_data *q = qdisc_priv(qd);
+    struct uf_tx_packet_data *pkt_data = (struct uf_tx_packet_data *) skb->cb;
+    struct ethhdr ehdr;
+    struct Qdisc *qdisc;
+    int r, proto;
+
+    func_enter();
+
+    memcpy(&ehdr, skb->data, ETH_HLEN);
+    proto = ntohs(ehdr.h_proto);
+
+    /* 802.1x - apply controlled/uncontrolled port rules */
+    if ((proto != ETH_P_PAE)
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+            && (proto != ETH_P_WAI)
+#endif
+       ) {
+        /* queues 0 - 3 */
+        pkt_data->priority = get_packet_priority(priv, skb, &ehdr, interfacePriv);
+        pkt_data->queue = unifi_frame_priority_to_queue(pkt_data->priority);
+    } else {
+        pkt_data->queue = UNIFI_TRAFFIC_Q_EAPOL;
+    }
+
+    qdisc = q->queues[pkt_data->queue];
+    r = qdisc->enqueue(skb, qdisc);
+    if (r == NET_XMIT_SUCCESS) {
+        qd->q.qlen++;
+        qd->bstats.bytes += skb->len;
+        qd->bstats.packets++;
+        func_exit_r(NET_XMIT_SUCCESS);
+        return NET_XMIT_SUCCESS;
+    }
+
+    unifi_error(priv, "uf_qdiscop_enqueue: dropped\n");
+    qd->qstats.drops++;
+
+    func_exit_r(r);
+    return r;
+
+} /* uf_qdiscop_enqueue() */
+
+
+static int uf_qdiscop_requeue(struct sk_buff *skb, struct Qdisc* qd)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t*)netdev_priv(qd->dev_queue->dev);
+#else
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t*)netdev_priv(qd->dev);
+#endif /* LINUX_VERSION_CODE */
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct uf_sched_data *q = qdisc_priv(qd);
+    struct uf_tx_packet_data *pkt_data = (struct uf_tx_packet_data *) skb->cb;
+    struct Qdisc *qdisc;
+    int r;
+
+    func_enter();
+
+    unifi_trace(priv, UDBG5, "uf_qdiscop_requeue: (q=%d), tag=%u\n",
+            pkt_data->queue, pkt_data->host_tag);
+
+    /* we recorded which queue to use earlier! */
+    qdisc = q->queues[pkt_data->queue];
+
+    if ((r = qdisc->ops->requeue(skb, qdisc)) == 0) {
+        qd->q.qlen++;
+        func_exit_r(0);
+        return 0;
+    }
+
+    unifi_error(priv, "uf_qdiscop_requeue: dropped\n");
+    qd->qstats.drops++;
+
+    func_exit_r(r);
+    return r;
+} /* uf_qdiscop_requeue() */
+
+static struct sk_buff *uf_qdiscop_dequeue(struct Qdisc* qd)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(qd->dev_queue->dev);
+#else
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(qd->dev);
+#endif /* LINUX_VERSION_CODE */
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct uf_sched_data *q = qdisc_priv(qd);
+    struct sk_buff *skb;
+    struct Qdisc *qdisc;
+    int queue, i;
+    struct ethhdr ehdr;
+    struct uf_tx_packet_data *pkt_data;
+    CsrWifiRouterCtrlPortAction port_action;
+
+    func_enter();
+
+    /* check all the queues */
+    for (i = UNIFI_TRAFFIC_Q_MAX - 1; i >= 0; i--) {
+
+        if (i != UNIFI_TRAFFIC_Q_EAPOL) {
+            queue = priv->prev_queue;
+            if (++priv->prev_queue >= UNIFI_TRAFFIC_Q_EAPOL) {
+                priv->prev_queue = 0;
+            }
+        } else {
+            queue = i;
+        }
+
+#ifndef ALLOW_Q_PAUSE
+        /* If queue is paused, do not dequeue */
+        if (net_is_tx_q_paused(priv, queue)) {
+            unifi_trace(priv, UDBG5,
+                    "uf_qdiscop_dequeue: tx queue paused (q=%d)\n", queue);
+            continue;
+        }
+#endif
+
+        qdisc = q->queues[queue];
+        skb = qdisc->dequeue(qdisc);
+        if (skb) {
+            /* A packet has been dequeued, decrease the queued packets count */
+            qd->q.qlen--;
+
+            pkt_data = (struct uf_tx_packet_data *) skb->cb;
+
+            /* Check the (un)controlled port status */
+            memcpy(&ehdr, skb->data, ETH_HLEN);
+
+            port_action = verify_port(priv
+                            , (((CSR_WIFI_ROUTER_CTRL_MODE_STA == interfacePriv->interfaceMode) ||(CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI == interfacePriv->interfaceMode))? interfacePriv->bssid.a: ehdr.h_dest)
+                            , (UNIFI_TRAFFIC_Q_EAPOL == queue? UF_UNCONTROLLED_PORT_Q: UF_CONTROLLED_PORT_Q)
+                            , interfacePriv->InterfaceTag);
+
+            /* Dequeue packet if port is open */
+            if (port_action == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN) {
+                unifi_trace(priv, UDBG5,
+                        "uf_qdiscop_dequeue: new (q=%d), tag=%u\n",
+                        queue, pkt_data->host_tag);
+
+                func_exit();
+                return skb;
+            }
+
+            /* Discard or block the packet if necessary */
+            if (port_action == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD) {
+                unifi_trace(priv, UDBG5,
+                        "uf_qdiscop_dequeue: drop (q=%d), tag=%u\n",
+                        queue, pkt_data->host_tag);
+                kfree_skb(skb);
+                break;
+            }
+
+            /* We can not send the packet now, put it back to the queue */
+            if (qdisc->ops->requeue(skb, qdisc) != 0) {
+                unifi_error(priv,
+                        "uf_qdiscop_dequeue: requeue (q=%d) failed, tag=%u, drop it\n",
+                        queue, pkt_data->host_tag);
+
+                /* Requeue failed, drop the packet */
+                kfree_skb(skb);
+                break;
+            }
+            /* We requeued the packet, increase the queued packets count */
+            qd->q.qlen++;
+
+            unifi_trace(priv, UDBG5,
+                    "uf_qdiscop_dequeue: skip (q=%d), tag=%u\n",
+                    queue, pkt_data->host_tag);
+        }
+    }
+
+    func_exit();
+    return NULL;
+} /* uf_qdiscop_dequeue() */
+
+
+static void uf_qdiscop_reset(struct Qdisc* qd)
+{
+    struct uf_sched_data *q = qdisc_priv(qd);
+    int queue;
+    func_enter();
+
+    for (queue = 0; queue < UNIFI_TRAFFIC_Q_MAX; queue++) {
+        qdisc_reset(q->queues[queue]);
+    }
+    qd->q.qlen = 0;
+
+    func_exit();
+} /* uf_qdiscop_reset() */
+
+
+static void uf_qdiscop_destroy(struct Qdisc* qd)
+{
+    struct uf_sched_data *q = qdisc_priv(qd);
+    int queue;
+
+    func_enter();
+
+    for (queue=0; queue < UNIFI_TRAFFIC_Q_MAX; queue++) {
+        qdisc_destroy(q->queues[queue]);
+        q->queues[queue] = &noop_qdisc;
+    }
+
+    func_exit();
+} /* uf_qdiscop_destroy() */
+
+
+/* called whenever parameters are updated on existing qdisc */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+static int uf_qdiscop_tune(struct Qdisc *qd, struct nlattr *opt)
+#else
+static int uf_qdiscop_tune(struct Qdisc *qd, struct rtattr *opt)
+#endif
+{
+    func_enter();
+    func_exit();
+    return 0;
+} /* uf_qdiscop_tune() */
+
+
+/* called during initial creation of qdisc on device */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+static int uf_qdiscop_init(struct Qdisc *qd, struct nlattr *opt)
+#else
+static int uf_qdiscop_init(struct Qdisc *qd, struct rtattr *opt)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+    struct net_device *dev = qd->dev_queue->dev;
+#else
+    struct net_device *dev = qd->dev;
+#endif /* LINUX_VERSION_CODE */
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct uf_sched_data *q = qdisc_priv(qd);
+    int err = 0, i;
+
+    func_enter();
+
+    /* make sure we do not mess with the ingress qdisc */
+    if (qd->flags & TCQ_F_INGRESS) {
+        func_exit();
+        return -EINVAL;
+    }
+
+    /* if options were passed in, set them */
+    if (opt) {
+        err = uf_qdiscop_tune(qd, opt);
+    }
+
+    /* create child queues */
+    for (i = 0; i < UNIFI_TRAFFIC_Q_MAX; i++) {
+        q->queues[i] = UF_QDISC_CREATE_DFLT(dev, &pfifo_qdisc_ops,
+                qd->handle);
+        if (!q->queues[i]) {
+            q->queues[i] = &noop_qdisc;
+            unifi_error(priv, "%s child qdisc %i creation failed\n");
+        }
+
+        unifi_trace(priv, UDBG5, "%s: child qdisc=0x%p\n",
+                dev->name, q->queues[i]);
+    }
+
+    func_exit_r(err);
+    return err;
+} /* uf_qdiscop_init() */
+
+
+static int uf_qdiscop_dump(struct Qdisc *qd, struct sk_buff *skb)
+{
+    func_enter();
+    func_exit_r(skb->len);
+    return skb->len;
+} /* uf_qdiscop_dump() */
+
+#endif /* CONFIG_NET_SCHED */
+#endif /* LINUX_VERSION_CODE */
+
+#ifdef CSR_SUPPORT_WEXT
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_netdev_event
+ *
+ *     Callback function to handle netdev state changes
+ *
+ *  Arguments:
+ *      notif           Pointer to a notifier_block.
+ *      event           Event prompting notification
+ *      ptr             net_device pointer
+ *
+ *  Returns:
+ *      None
+ *
+ *  Notes:
+ *   The event handler is global, and may occur on non-UniFi netdevs.
+ * ---------------------------------------------------------------------------
+ */
+static int
+uf_netdev_event(struct notifier_block *notif, unsigned long event, void* ptr) {
+    struct net_device *netdev = ptr;
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(netdev);
+    unifi_priv_t *priv = NULL;
+    static const CsrWifiMacAddress broadcast_address = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};
+
+    /* Check that the event is for a UniFi netdev. If it's not, the netdev_priv
+     * structure is not safe to use.
+     */
+    if (uf_find_netdev_priv(interfacePriv) == -1) {
+        unifi_trace(NULL, UDBG1, "uf_netdev_event: ignore e=%d, ptr=%p, priv=%p %s\n",
+                    event, ptr, interfacePriv, netdev->name);
+        return 0;
+    }
+
+    switch(event) {
+    case NETDEV_CHANGE:
+        priv = interfacePriv->privPtr;
+        unifi_trace(priv, UDBG1, "NETDEV_CHANGE: %p %s %s waiting for it\n",
+                    ptr,
+                    netdev->name,
+                    interfacePriv->wait_netdev_change ? "" : "not");
+
+        if (interfacePriv->wait_netdev_change) {
+            UF_NETIF_TX_WAKE_ALL_QUEUES(priv->netdev[interfacePriv->InterfaceTag]);
+            interfacePriv->connected = UnifiConnected;
+            interfacePriv->wait_netdev_change = FALSE;
+            /* Note: passing the broadcast address here will allow anyone to attempt to join our adhoc network */
+            uf_process_rx_pending_queue(priv, UF_UNCONTROLLED_PORT_Q, broadcast_address, 1,interfacePriv->InterfaceTag);
+            uf_process_rx_pending_queue(priv, UF_CONTROLLED_PORT_Q, broadcast_address, 1,interfacePriv->InterfaceTag);
+        }
+        break;
+
+    default:
+        break;
+    }
+    return 0;
+}
+
+static struct notifier_block uf_netdev_notifier = {
+    .notifier_call = uf_netdev_event,
+};
+#endif /* CSR_SUPPORT_WEXT */
+
+
+static void
+        process_amsdu(unifi_priv_t *priv, CSR_SIGNAL *signal, bulk_data_param_t *bulkdata)
+{
+    CsrUint32 offset;
+    CsrUint32 length = bulkdata->d[0].data_length;
+    CsrUint32 subframe_length, subframe_body_length, dot11_hdr_size;
+    CsrUint8 *ptr;
+    bulk_data_param_t subframe_bulkdata;
+    CsrUint8 *dot11_hdr_ptr = (CsrUint8*)bulkdata->d[0].os_data_ptr;
+    CsrResult csrResult;
+    CsrUint16 frameControl;
+    CsrUint8 *qos_control_ptr;
+
+    frameControl = le16_to_cpu(*((CsrUint16*)dot11_hdr_ptr));
+    qos_control_ptr = dot11_hdr_ptr + (((frameControl & IEEE802_11_FC_TO_DS_MASK) && (frameControl & IEEE802_11_FC_FROM_DS_MASK))?30: 24);
+    if(!(*qos_control_ptr & IEEE802_11_QC_A_MSDU_PRESENT)) {
+        unifi_trace(priv, UDBG6, "%s: calling unifi_rx()", __FUNCTION__);
+        unifi_rx(priv, signal, bulkdata);
+        return;
+    }
+    *qos_control_ptr &= ~(IEEE802_11_QC_A_MSDU_PRESENT);
+
+    ptr = qos_control_ptr + 2;
+    offset = dot11_hdr_size = ptr - dot11_hdr_ptr;
+
+    while(length > (offset + sizeof(struct ethhdr) + sizeof(llc_snap_hdr_t))) {
+        subframe_body_length = ntohs(((struct ethhdr*)ptr)->h_proto);
+        if(subframe_body_length > IEEE802_11_MAX_DATA_LEN) {
+            unifi_error(priv, "%s: bad subframe_body_length = %d\n", __FUNCTION__, subframe_body_length);
+            break;
+        }
+        subframe_length = sizeof(struct ethhdr) + subframe_body_length;
+        memset(&subframe_bulkdata, 0, sizeof(bulk_data_param_t));
+
+        csrResult = unifi_net_data_malloc(priv, &subframe_bulkdata.d[0], dot11_hdr_size + subframe_body_length);
+
+        if (csrResult != CSR_RESULT_SUCCESS) {
+            unifi_error(priv, "%s: unifi_net_data_malloc failed\n", __FUNCTION__);
+            break;
+        }
+
+        memcpy((CsrUint8*)subframe_bulkdata.d[0].os_data_ptr, dot11_hdr_ptr, dot11_hdr_size);
+
+
+        /* When to DS=0 and from DS=0, address 3 will already have BSSID so no need to re-program */
+        if ((frameControl & IEEE802_11_FC_TO_DS_MASK) && !(frameControl & IEEE802_11_FC_FROM_DS_MASK)){
+                memcpy((CsrUint8*)subframe_bulkdata.d[0].os_data_ptr + IEEE802_11_ADDR3_OFFSET, ((struct ethhdr*)ptr)->h_dest, ETH_ALEN);
+        }
+        else if (!(frameControl & IEEE802_11_FC_TO_DS_MASK) && (frameControl & IEEE802_11_FC_FROM_DS_MASK)){
+                memcpy((CsrUint8*)subframe_bulkdata.d[0].os_data_ptr + IEEE802_11_ADDR3_OFFSET,
+                         ((struct ethhdr*)ptr)->h_source,
+                           ETH_ALEN);
+        }
+
+        memcpy((CsrUint8*)subframe_bulkdata.d[0].os_data_ptr + dot11_hdr_size,
+                ptr + sizeof(struct ethhdr),
+                             subframe_body_length);
+        unifi_trace(priv, UDBG6, "%s: calling unifi_rx. length = %d subframe_length = %d\n", __FUNCTION__, length, subframe_length);
+        unifi_rx(priv, signal, &subframe_bulkdata);
+
+        subframe_length = (subframe_length + 3)&(~0x3);
+        ptr += subframe_length;
+        offset += subframe_length;
+    }
+    unifi_net_data_free(priv, &bulkdata->d[0]);
+}
+
+
+#define SN_TO_INDEX(__ba_session, __sn) (((__sn - __ba_session->start_sn) & 0xFFF) % __ba_session->wind_size)
+
+
+#define ADVANCE_EXPECTED_SN(__ba_session) \
+{ \
+    __ba_session->expected_sn++; \
+    __ba_session->expected_sn &= 0xFFF; \
+}
+
+#define FREE_BUFFER_SLOT(__ba_session, __index) \
+{ \
+    __ba_session->occupied_slots--; \
+    __ba_session->buffer[__index].active = FALSE; \
+    ADVANCE_EXPECTED_SN(__ba_session); \
+}
+
+static void add_frame_to_ba_complete(unifi_priv_t *priv,
+                          netInterface_priv_t *interfacePriv,
+                          frame_desc_struct *frame_desc)
+{
+    interfacePriv->ba_complete[interfacePriv->ba_complete_index] = *frame_desc;
+    interfacePriv->ba_complete_index++;
+}
+
+
+static void update_expected_sn(unifi_priv_t *priv,
+                          netInterface_priv_t *interfacePriv,
+                          ba_session_rx_struct *ba_session,
+                          CsrUint16 sn)
+{
+    int i, j;
+    CsrUint16 gap;
+
+    gap = (sn - ba_session->expected_sn) & 0xFFF;
+    unifi_trace(priv, UDBG6, "%s: proccess the frames up to new_expected_sn = %d gap = %d\n", __FUNCTION__, sn, gap);
+    for(j = 0; j < gap && j < ba_session->wind_size; j++) {
+        i = SN_TO_INDEX(ba_session, ba_session->expected_sn);
+        unifi_trace(priv, UDBG6, "%s: proccess the slot index = %d\n", __FUNCTION__, i);
+        if(ba_session->buffer[i].active) {
+            add_frame_to_ba_complete(priv, interfacePriv, &ba_session->buffer[i]);
+            unifi_trace(priv, UDBG6, "%s: proccess the frame at index = %d expected_sn = %d\n", __FUNCTION__, i, ba_session->expected_sn);
+            FREE_BUFFER_SLOT(ba_session, i);
+        } else {
+            unifi_trace(priv, UDBG6, "%s: empty slot at index = %d\n", __FUNCTION__, i);
+            ADVANCE_EXPECTED_SN(ba_session);
+        }
+    }
+    ba_session->expected_sn = sn;
+}
+
+
+static void complete_ready_sequence(unifi_priv_t *priv,
+                               netInterface_priv_t *interfacePriv,
+                               ba_session_rx_struct *ba_session)
+{
+    int i;
+
+    i = SN_TO_INDEX(ba_session, ba_session->expected_sn);
+    while (ba_session->buffer[i].active) {
+        add_frame_to_ba_complete(priv, interfacePriv, &ba_session->buffer[i]);
+        unifi_trace(priv, UDBG6, "%s: completed stored frame(expected_sn=%d) at i = %d\n", __FUNCTION__, ba_session->expected_sn, i);
+        FREE_BUFFER_SLOT(ba_session, i);
+        i = SN_TO_INDEX(ba_session, ba_session->expected_sn);
+    }
+}
+
+
+void scroll_ba_window(unifi_priv_t *priv,
+                                netInterface_priv_t *interfacePriv,
+                                ba_session_rx_struct *ba_session,
+                                CsrUint16 sn)
+{
+    if(((sn - ba_session->expected_sn) & 0xFFF) <= 2048) {
+        update_expected_sn(priv, interfacePriv, ba_session, sn);
+        complete_ready_sequence(priv, interfacePriv, ba_session);
+    }
+}
+
+
+static int consume_frame_or_get_buffer_index(unifi_priv_t *priv,
+                                            netInterface_priv_t *interfacePriv,
+                                            ba_session_rx_struct *ba_session,
+                                            CsrUint16 sn,
+                                            frame_desc_struct *frame_desc) {
+    int i;
+    CsrUint16 sn_temp;
+
+    if(((sn - ba_session->expected_sn) & 0xFFF) <= 2048) {
+
+        /* once we are in BA window, set the flag for BA trigger */
+        if(!ba_session->trigger_ba_after_ssn){
+            ba_session->trigger_ba_after_ssn = TRUE;
+        }
+
+        sn_temp = ba_session->expected_sn + ba_session->wind_size;
+        unifi_trace(priv, UDBG6, "%s: new frame: sn=%d\n", __FUNCTION__, sn);
+        if(!(((sn - sn_temp) & 0xFFF) > 2048)) {
+            CsrUint16 new_expected_sn;
+            unifi_trace(priv, UDBG6, "%s: frame is out of window\n", __FUNCTION__);
+            sn_temp = (sn - ba_session->wind_size) & 0xFFF;
+            new_expected_sn = (sn_temp + 1) & 0xFFF;
+            update_expected_sn(priv, interfacePriv, ba_session, new_expected_sn);
+        }
+        i = -1;
+        if (sn == ba_session->expected_sn) {
+            unifi_trace(priv, UDBG6, "%s: sn = ba_session->expected_sn = %d\n", __FUNCTION__, sn);
+            ADVANCE_EXPECTED_SN(ba_session);
+            add_frame_to_ba_complete(priv, interfacePriv, frame_desc);
+        } else {
+            i = SN_TO_INDEX(ba_session, sn);
+            unifi_trace(priv, UDBG6, "%s: sn(%d) != ba_session->expected_sn(%d), i = %d\n", __FUNCTION__, sn, ba_session->expected_sn, i);
+            if (ba_session->buffer[i].active) {
+                unifi_trace(priv, UDBG6, "%s: free frame at i = %d\n", __FUNCTION__, i);
+                i = -1;
+                unifi_net_data_free(priv, &frame_desc->bulkdata.d[0]);
+            }
+        }
+    } else {
+        i = -1;
+        if(!ba_session->trigger_ba_after_ssn){
+            unifi_trace(priv, UDBG6, "%s: frame before ssn, pass it up: sn=%d\n", __FUNCTION__, sn);
+            add_frame_to_ba_complete(priv, interfacePriv, frame_desc);
+        }else{
+            unifi_trace(priv, UDBG6, "%s: old frame, drop: sn=%d, expected_sn=%d\n", __FUNCTION__, sn, ba_session->expected_sn);
+            unifi_net_data_free(priv, &frame_desc->bulkdata.d[0]);
+        }
+    }
+    return i;
+}
+
+
+
+static void process_ba_frame(unifi_priv_t *priv,
+                                             netInterface_priv_t *interfacePriv,
+                                             ba_session_rx_struct *ba_session,
+                                             frame_desc_struct *frame_desc)
+{
+    int i;
+    CsrUint16 sn = frame_desc->sn;
+
+    if (ba_session->timeout) {
+        mod_timer(&ba_session->timer, (jiffies + usecs_to_jiffies((ba_session->timeout) * 1024)));
+    }
+    unifi_trace(priv, UDBG6, "%s: got frame(sn=%d)\n", __FUNCTION__, sn);
+
+    i = consume_frame_or_get_buffer_index(priv, interfacePriv, ba_session, sn, frame_desc);
+    if(i >= 0) {
+        unifi_trace(priv, UDBG6, "%s: store frame(sn=%d) at i = %d\n", __FUNCTION__, sn, i);
+        ba_session->buffer[i] = *frame_desc;
+        ba_session->buffer[i].recv_time = CsrTimeGet(NULL);
+        ba_session->occupied_slots++;
+    } else {
+        unifi_trace(priv, UDBG6, "%s: frame consumed - sn = %d\n", __FUNCTION__, sn);
+    }
+    complete_ready_sequence(priv, interfacePriv, ba_session);
+}
+
+
+static void process_ba_complete(unifi_priv_t *priv, netInterface_priv_t *interfacePriv)
+{
+    frame_desc_struct *frame_desc;
+    CsrUint8 i;
+
+    for(i = 0; i < interfacePriv->ba_complete_index; i++) {
+        frame_desc = &interfacePriv->ba_complete[i];
+        unifi_trace(priv, UDBG6, "%s: calling process_amsdu()\n", __FUNCTION__);
+        process_amsdu(priv, &frame_desc->signal, &frame_desc->bulkdata);
+    }
+    interfacePriv->ba_complete_index = 0;
+
+}
+
+
+/* Check if the frames in BA reoder buffer has aged and
+ * if so release the frames to upper processes and move
+ * the window
+ */
+static void check_ba_frame_age_timeout( unifi_priv_t *priv,
+                                        netInterface_priv_t *interfacePriv,
+                                        ba_session_rx_struct *ba_session)
+{
+    CsrTime now;
+    CsrTime age;
+    CsrUint8 i, j;
+    CsrUint16 sn_temp;
+
+    /* gap is started at 1 because we have buffered frames and
+     * hence a minimum gap of 1 exists
+     */
+    CsrUint8 gap=1;
+
+    now = CsrTimeGet(NULL);
+
+    if (ba_session->occupied_slots)
+    {
+        /* expected sequence has not arrived so start searching from next
+         * sequence number until a frame is available and determine the gap.
+         * Check if the frame available has timedout, if so advance the
+         * expected sequence number and release the frames
+         */
+        sn_temp = (ba_session->expected_sn + 1) & 0xFFF;
+
+        for(j = 0; j < ba_session->wind_size; j++)
+        {
+            i = SN_TO_INDEX(ba_session, sn_temp);
+
+            if(ba_session->buffer[i].active)
+            {
+                unifi_trace(priv, UDBG6, "check age at slot index = %d sn = %d recv_time = %u now = %u\n",
+                                        i,
+                                        ba_session->buffer[i].sn,
+                                        ba_session->buffer[i].recv_time,
+                                        now);
+
+                if (ba_session->buffer[i].recv_time > now)
+                {
+                    /* timer wrap */
+                    age = CsrTimeAdd((CsrTime)CsrTimeSub(CSR_SCHED_TIME_MAX, ba_session->buffer[i].recv_time), now);
+                }
+                else
+                {
+                    age = (CsrTime)CsrTimeSub(now, ba_session->buffer[i].recv_time);
+                }
+
+                if (age >= CSR_WIFI_BA_MPDU_FRAME_AGE_TIMEOUT)
+                {
+                    unifi_trace(priv, UDBG2, "release the frame at index = %d gap = %d expected_sn = %d sn = %d\n",
+                                            i,
+                                            gap,
+                                            ba_session->expected_sn,
+                                            ba_session->buffer[i].sn);
+
+                    /* if it has timedout don't wait for missing frames, move the window */
+                    while (gap--)
+                    {
+                        ADVANCE_EXPECTED_SN(ba_session);
+                    }
+                    add_frame_to_ba_complete(priv, interfacePriv, &ba_session->buffer[i]);
+                    FREE_BUFFER_SLOT(ba_session, i);
+                    complete_ready_sequence(priv, interfacePriv, ba_session);
+                }
+                break;
+
+            }
+            else
+            {
+                /* advance temp sequence number and frame gap */
+                sn_temp = (sn_temp + 1) & 0xFFF;
+                gap++;
+            }
+        }
+    }
+}
+
+
+static void process_ma_packet_error_ind(unifi_priv_t *priv, CSR_SIGNAL *signal, bulk_data_param_t *bulkdata)
+{
+    CsrUint16 interfaceTag;
+    const CSR_MA_PACKET_ERROR_INDICATION *pkt_err_ind = &signal->u.MaPacketErrorIndication;
+    netInterface_priv_t *interfacePriv;
+    ba_session_rx_struct *ba_session;
+    CsrUint8 ba_session_idx = 0;
+    CSR_PRIORITY        UserPriority;
+    CSR_SEQUENCE_NUMBER sn;
+
+    func_enter();
+
+    interfaceTag = (pkt_err_ind->VirtualInterfaceIdentifier & 0xff);
+
+
+    /* Sanity check that the VIF refers to a sensible interface */
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES)
+    {
+        unifi_error(priv, "%s: MaPacketErrorIndication indication with bad interfaceTag %d\n", __FUNCTION__, interfaceTag);
+        func_exit();
+        return;
+    }
+
+    interfacePriv = priv->interfacePriv[interfaceTag];
+    UserPriority = pkt_err_ind->UserPriority;
+    if(UserPriority > 15) {
+        unifi_error(priv, "%s: MaPacketErrorIndication indication with bad UserPriority=%d\n", __FUNCTION__, UserPriority);
+        func_exit();
+    }
+    sn = pkt_err_ind->SequenceNumber;
+
+    spin_lock(&priv->ba_lock);
+    /* To find the right ba_session loop through the BA sessions, compare MAC address and tID */
+    for (ba_session_idx=0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_RX; ba_session_idx++){
+        ba_session = interfacePriv->ba_session_rx[ba_session_idx];
+        if (ba_session){
+            if ((!memcmp(ba_session->macAddress.a, pkt_err_ind->PeerQstaAddress.x, ETH_ALEN)) && (ba_session->tID == UserPriority)){
+                if (ba_session->timeout) {
+                    mod_timer(&ba_session->timer, (jiffies + usecs_to_jiffies((ba_session->timeout) * 1024)));
+                }
+                scroll_ba_window(priv, interfacePriv, ba_session, sn);
+                break;
+            }
+        }
+    }
+
+    spin_unlock(&priv->ba_lock);
+    process_ba_complete(priv, interfacePriv);
+    func_exit();
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/os.c
@@ -0,0 +1,479 @@
+/*
+ * ---------------------------------------------------------------------------
+ *  FILE:     os.c
+ *
+ *  PURPOSE:
+ *      Routines to fulfil the OS-abstraction for the HIP lib.
+ *      It is part of the porting exercise.
+ *
+ * Copyright (C) 2005-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+/**
+ * The HIP lib OS abstraction consists of the implementation
+ * of the functions in this file. It is part of the porting exercise.
+ */
+
+#include "unifi_priv.h"
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_net_data_malloc
+ *
+ *      Allocate an OS specific net data buffer of "size" bytes.
+ *      The bulk_data_slot.os_data_ptr must be initialised to point
+ *      to the buffer allocated. The bulk_data_slot.length must be
+ *      initialised to the requested size, zero otherwise.
+ *      The bulk_data_slot.os_net_buf_ptr can be initialised to
+ *      an OS specific pointer to be used in the unifi_net_data_free().
+ *
+ *
+ *  Arguments:
+ *      ospriv              Pointer to device private context struct.
+ *      bulk_data_slot      Pointer to the bulk data structure to initialise.
+ *      size                Size of the buffer to be allocated.
+ *
+ *  Returns:
+ *      CSR_RESULT_SUCCESS on success, CSR_RESULT_FAILURE otherwise.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+unifi_net_data_malloc(void *ospriv, bulk_data_desc_t *bulk_data_slot, unsigned int size)
+{
+    struct sk_buff *skb;
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+    int rounded_length;
+
+    if (priv->card_info.sdio_block_size == 0) {
+        unifi_error(priv, "unifi_net_data_malloc: Invalid SDIO block size\n");
+        return CSR_RESULT_FAILURE;
+    }
+
+    rounded_length = (size + priv->card_info.sdio_block_size - 1) & ~(priv->card_info.sdio_block_size - 1);
+
+    /*
+     * (ETH_HLEN + 2) bytes tailroom for header manipulation
+     * CSR_WIFI_ALIGN_BYTES bytes headroom for alignment manipulation
+     */
+    skb = dev_alloc_skb(rounded_length + 2 + ETH_HLEN + CSR_WIFI_ALIGN_BYTES);
+    if (! skb) {
+        unifi_error(ospriv, "alloc_skb failed.\n");
+        bulk_data_slot->os_net_buf_ptr = NULL;
+        bulk_data_slot->net_buf_length = 0;
+        bulk_data_slot->os_data_ptr = NULL;
+        bulk_data_slot->data_length = 0;
+        return CSR_RESULT_FAILURE;
+    }
+
+    bulk_data_slot->os_net_buf_ptr = (const unsigned char*)skb;
+    bulk_data_slot->net_buf_length = rounded_length + 2 + ETH_HLEN + CSR_WIFI_ALIGN_BYTES;
+    bulk_data_slot->os_data_ptr = (const void*)skb->data;
+    bulk_data_slot->data_length = size;
+
+    return CSR_RESULT_SUCCESS;
+} /* unifi_net_data_malloc() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_net_data_free
+ *
+ *      Free an OS specific net data buffer.
+ *      The bulk_data_slot.length must be initialised to 0.
+ *
+ *
+ *  Arguments:
+ *      ospriv              Pointer to device private context struct.
+ *      bulk_data_slot      Pointer to the bulk data structure that
+ *                          holds the data to be freed.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+unifi_net_data_free(void *ospriv, bulk_data_desc_t *bulk_data_slot)
+{
+    struct sk_buff *skb;
+    CSR_UNUSED(ospriv);
+
+    skb = (struct sk_buff *)bulk_data_slot->os_net_buf_ptr;
+    dev_kfree_skb(skb);
+
+    bulk_data_slot->net_buf_length = 0;
+    bulk_data_slot->data_length = 0;
+    bulk_data_slot->os_data_ptr = bulk_data_slot->os_net_buf_ptr = NULL;
+
+} /* unifi_net_data_free() */
+
+
+/*
+* ---------------------------------------------------------------------------
+*  unifi_net_dma_align
+*
+*      DMA align an OS specific net data buffer.
+*      The buffer must be empty.
+*
+*
+*  Arguments:
+*      ospriv              Pointer to device private context struct.
+*      bulk_data_slot      Pointer to the bulk data structure that
+*                          holds the data to be aligned.
+*
+*  Returns:
+*      None.
+* ---------------------------------------------------------------------------
+*/
+CsrResult
+unifi_net_dma_align(void *ospriv, bulk_data_desc_t *bulk_data_slot)
+{
+    struct sk_buff *skb;
+    unsigned long buf_address;
+    int offset;
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+
+    if ((bulk_data_slot == NULL) || (CSR_WIFI_ALIGN_BYTES == 0)) {
+        return CSR_RESULT_SUCCESS;
+    }
+
+    if ((bulk_data_slot->os_data_ptr == NULL) || (bulk_data_slot->data_length == 0)) {
+        return CSR_RESULT_SUCCESS;
+    }
+
+    buf_address = (unsigned long)(bulk_data_slot->os_data_ptr) & (CSR_WIFI_ALIGN_BYTES - 1);
+
+    unifi_trace(priv, UDBG5,
+                "unifi_net_dma_align: Allign buffer (0x%p) by %d bytes\n",
+                bulk_data_slot->os_data_ptr, buf_address);
+
+    offset = CSR_WIFI_ALIGN_BYTES - buf_address;
+    if (offset < 0) {
+        unifi_error(priv, "unifi_net_dma_align: Failed (offset=%d)\n", offset);
+        return CSR_RESULT_FAILURE;
+    }
+
+    skb = (struct sk_buff*)(bulk_data_slot->os_net_buf_ptr);
+    skb_reserve(skb, offset);
+    bulk_data_slot->os_net_buf_ptr = (const unsigned char*)skb;
+    bulk_data_slot->os_data_ptr = (const void*)(skb->data);
+
+    return CSR_RESULT_SUCCESS;
+
+} /* unifi_net_dma_align() */
+
+#ifdef ANDROID_TIMESTAMP
+static volatile unsigned int printk_cpu = UINT_MAX;
+char tbuf[30];
+
+char* print_time(void )
+{
+    unsigned long long t;
+    unsigned long nanosec_rem;
+
+    t = cpu_clock(printk_cpu);
+    nanosec_rem = do_div(t, 1000000000);
+    sprintf(tbuf, "[%5lu.%06lu] ",
+                    (unsigned long) t,
+                    nanosec_rem / 1000);
+
+    return tbuf;
+}
+#endif
+
+
+/* Module parameters */
+extern int unifi_debug;
+
+#ifdef UNIFI_DEBUG
+#define DEBUG_BUFFER_SIZE       120
+
+#define FORMAT_TRACE(_s, _len, _args, _fmt)             \
+    do {                                                \
+        va_start(_args, _fmt);                          \
+        _len += vsnprintf(&(_s)[_len],                  \
+                         (DEBUG_BUFFER_SIZE - _len),    \
+                         _fmt, _args);                  \
+        va_end(_args);                                  \
+        if (_len >= DEBUG_BUFFER_SIZE) {                \
+            (_s)[DEBUG_BUFFER_SIZE - 2] = '\n';         \
+            (_s)[DEBUG_BUFFER_SIZE - 1] = 0;            \
+        }                                               \
+    } while (0)
+#endif /* UNIFI_DEBUG */
+
+void
+unifi_error(void* ospriv, const char *fmt, ...)
+{
+#ifdef UNIFI_DEBUG
+    unifi_priv_t *priv = (unifi_priv_t*) ospriv;
+    char s[DEBUG_BUFFER_SIZE];
+    va_list args;
+    unsigned int len;
+#ifdef ANDROID_TIMESTAMP
+    if (priv != NULL) {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_ERR "%s unifi%d: ", print_time(), priv->instance);
+    } else {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_ERR "%s unifi: ", print_time());
+    }
+#else
+    if (priv != NULL) {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_ERR "unifi%d: ", priv->instance);
+    } else {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_ERR "unifi: ");
+    }
+#endif /* ANDROID_TIMESTAMP */
+    FORMAT_TRACE(s, len, args, fmt);
+
+    printk("%s", s);
+#endif /* UNIFI_DEBUG */
+}
+
+void
+unifi_warning(void* ospriv, const char *fmt, ...)
+{
+#ifdef UNIFI_DEBUG
+    unifi_priv_t *priv = (unifi_priv_t*) ospriv;
+    char s[DEBUG_BUFFER_SIZE];
+    va_list args;
+    unsigned int len;
+
+#ifdef ANDROID_TIMESTAMP
+    if (priv != NULL) {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_WARNING "%s unifi%d: ", print_time(), priv->instance);
+    } else {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_WARNING "%s unifi: ", print_time());
+    }
+#else
+    if (priv != NULL) {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_WARNING "unifi%d: ", priv->instance);
+    } else {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_WARNING "unifi: ");
+    }
+#endif /* ANDROID_TIMESTAMP */
+
+    FORMAT_TRACE(s, len, args, fmt);
+
+    printk("%s", s);
+#endif /* UNIFI_DEBUG */
+}
+
+
+void
+unifi_notice(void* ospriv, const char *fmt, ...)
+{
+#ifdef UNIFI_DEBUG
+    unifi_priv_t *priv = (unifi_priv_t*) ospriv;
+    char s[DEBUG_BUFFER_SIZE];
+    va_list args;
+    unsigned int len;
+
+#ifdef ANDROID_TIMESTAMP
+    if (priv != NULL) {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_NOTICE "%s unifi%d: ", print_time(), priv->instance);
+    } else {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_NOTICE "%s unifi: ", print_time());
+    }
+#else
+    if (priv != NULL) {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_NOTICE "unifi%d: ", priv->instance);
+    } else {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_NOTICE "unifi: ");
+    }
+#endif /* ANDROID_TIMESTAMP */
+
+    FORMAT_TRACE(s, len, args, fmt);
+
+    printk("%s", s);
+#endif /* UNIFI_DEBUG */
+}
+
+
+void
+unifi_info(void* ospriv, const char *fmt, ...)
+{
+#ifdef UNIFI_DEBUG
+    unifi_priv_t *priv = (unifi_priv_t*) ospriv;
+    char s[DEBUG_BUFFER_SIZE];
+    va_list args;
+    unsigned int len;
+
+#ifdef ANDROID_TIMESTAMP
+    if (priv != NULL) {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_INFO "%s unifi%d: ", print_time(), priv->instance);
+    } else {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_INFO "%s unifi: ", print_time());
+    }
+#else
+    if (priv != NULL) {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_INFO "unifi%d: ", priv->instance);
+    } else {
+        len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_INFO "unifi: ");
+    }
+#endif /* ANDROID_TIMESTAMP */
+
+    FORMAT_TRACE(s, len, args, fmt);
+
+    printk("%s", s);
+#endif /* UNIFI_DEBUG */
+}
+
+/* debugging */
+void
+unifi_trace(void* ospriv, int level, const char *fmt, ...)
+{
+#ifdef UNIFI_DEBUG
+    unifi_priv_t *priv = (unifi_priv_t*) ospriv;
+    char s[DEBUG_BUFFER_SIZE];
+    va_list args;
+    unsigned int len;
+
+    if (unifi_debug >= level) {
+#ifdef ANDROID_TIMESTAMP
+        if (priv != NULL) {
+            len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_ERR "%s unifi%d: ", print_time(), priv->instance);
+        } else {
+            len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_ERR "%s unifi: ", print_time());
+        }
+#else
+        if (priv != NULL) {
+            len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_ERR "unifi%d: ", priv->instance);
+        } else {
+            len = snprintf(s, DEBUG_BUFFER_SIZE, KERN_ERR "unifi: ");
+        }
+#endif /* ANDROID_TIMESTAMP */
+
+        FORMAT_TRACE(s, len, args, fmt);
+
+        printk("%s", s);
+    }
+#endif /* UNIFI_DEBUG */
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *
+ *      Debugging support.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+#ifdef UNIFI_DEBUG
+
+/* Memory dump with level filter controlled by unifi_debug */
+void
+unifi_dump(void *ospriv, int level, const char *msg, void *mem, CsrUint16 len)
+{
+    unifi_priv_t *priv = (unifi_priv_t*) ospriv;
+
+    if (unifi_debug >= level) {
+#ifdef ANDROID_TIMESTAMP
+        if (priv != NULL) {
+            printk(KERN_ERR "%s unifi%d: --- dump: %s ---\n", print_time(), priv->instance, msg ? msg : "");
+        } else {
+            printk(KERN_ERR "%s unifi: --- dump: %s ---\n", print_time(), msg ? msg : "");
+        }
+#else
+        if (priv != NULL) {
+            printk(KERN_ERR "unifi%d: --- dump: %s ---\n", priv->instance, msg ? msg : "");
+        } else {
+            printk(KERN_ERR "unifi: --- dump: %s ---\n", msg ? msg : "");
+        }
+#endif /* ANDROID_TIMESTAMP */
+        dump(mem, len);
+
+        if (priv != NULL) {
+            printk(KERN_ERR "unifi%d: --- end of dump ---\n", priv->instance);
+        } else {
+            printk(KERN_ERR "unifi: --- end of dump ---\n");
+        }
+    }
+}
+
+/* Memory dump that appears all the time, use sparingly */
+void
+dump(void *mem, CsrUint16 len)
+{
+    int i, col = 0;
+    unsigned char *pdata = (unsigned char *)mem;
+#ifdef ANDROID_TIMESTAMP
+    printk("timestamp %s \n", print_time());
+#endif /* ANDROID_TIMESTAMP */
+    if (mem == NULL) {
+        printk("(null dump)\n");
+        return;
+    }
+    for (i = 0; i < len; i++) {
+        if (col == 0) {
+            printk("0x%02X: ", i);
+        }
+
+        printk(" %02X", pdata[i]);
+
+        if (++col == 16) {
+            printk("\n");
+            col = 0;
+        }
+    }
+    if (col) {
+        printk("\n");
+    }
+} /* dump() */
+
+
+void
+dump16(void *mem, CsrUint16 len)
+{
+    int i, col=0;
+    unsigned short *p = (unsigned short *)mem;
+#ifdef ANDROID_TIMESTAMP
+    printk("timestamp %s \n", print_time());
+#endif /* ANDROID_TIMESTAMP */
+    for (i = 0; i < len; i+=2) {
+        if (col == 0) {
+            printk("0x%02X: ", i);
+        }
+
+        printk(" %04X", *p++);
+
+        if (++col == 8) {
+            printk("\n");
+            col = 0;
+        }
+    }
+    if (col) {
+        printk("\n");
+    }
+}
+
+
+#ifdef CSR_WIFI_HIP_DEBUG_OFFLINE
+void
+dump_str(void *mem, CsrUint16 len)
+{
+    int i, col = 0;
+    unsigned char *pdata = (unsigned char *)mem;
+#ifdef ANDROID_TIMESTAMP
+    printk("timestamp %s \n", print_time());
+#endif /* ANDROID_TIMESTAMP */
+    for (i = 0; i < len; i++) {
+        printk("%c", pdata[i]);
+    }
+    if (col) {
+        printk("\n");
+    }
+
+} /* dump_str() */
+#endif /* CSR_ONLY_NOTES */
+
+
+#endif /* UNIFI_DEBUG */
+
+
+/* ---------------------------------------------------------------------------
+ *                              - End -
+ * ------------------------------------------------------------------------- */
--- /dev/null
+++ b/drivers/staging/csr/putest.c
@@ -0,0 +1,664 @@
+/*
+ * ***************************************************************************
+ *  FILE:     putest.c
+ *
+ *  PURPOSE:    putest related functions.
+ *
+ *  Copyright (C) 2008-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ***************************************************************************
+ */
+
+#include <linux/vmalloc.h>
+#include <linux/firmware.h>
+
+#include "unifi_priv.h"
+#include "csr_wifi_hip_chiphelper.h"
+
+#define UNIFI_PROC_BOTH 3
+
+
+int unifi_putest_cmd52_read(unifi_priv_t *priv, unsigned char *arg)
+{
+    struct unifi_putest_cmd52 cmd52_params;
+    CsrUint8 *arg_pos;
+    unsigned int cmd_param_size;
+    int r;
+    CsrResult csrResult;
+    unsigned char ret_buffer[32];
+    CsrUint8 *ret_buffer_pos;
+    CsrUint8 retries;
+
+    arg_pos = (CsrUint8*)(((unifi_putest_command_t*)arg) + 1);
+    if (get_user(cmd_param_size, (int*)arg_pos)) {
+        unifi_error(priv,
+                    "unifi_putest_cmd52_read: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    if (cmd_param_size != sizeof(struct unifi_putest_cmd52)) {
+        unifi_error(priv,
+                    "unifi_putest_cmd52_read: cmd52 struct mismatch\n");
+        return -EINVAL;
+    }
+
+    arg_pos += sizeof(unsigned int);
+    if (copy_from_user(&cmd52_params,
+                       (void*)arg_pos,
+                       sizeof(struct unifi_putest_cmd52))) {
+        unifi_error(priv,
+                    "unifi_putest_cmd52_read: Failed to get the cmd52 params\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG2, "cmd52r: func=%d addr=0x%x ",
+                cmd52_params.funcnum, cmd52_params.addr);
+
+    retries = 3;
+    CsrSdioClaim(priv->sdio);
+    do {
+        if (cmd52_params.funcnum == 0) {
+            csrResult = CsrSdioF0Read8(priv->sdio, cmd52_params.addr, &cmd52_params.data);
+        } else {
+            csrResult = CsrSdioRead8(priv->sdio, cmd52_params.addr, &cmd52_params.data);
+        }
+    } while (--retries && ((csrResult == CSR_SDIO_RESULT_CRC_ERROR) || (csrResult == CSR_SDIO_RESULT_TIMEOUT)));
+    CsrSdioRelease(priv->sdio);
+
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv,
+                    "\nunifi_putest_cmd52_read: Read8() failed (csrResult=0x%x)\n", csrResult);
+        return -EFAULT;
+    }
+    unifi_trace(priv, UDBG2, "data=%d\n", cmd52_params.data);
+
+    /* Copy the info to the out buffer */
+    *(unifi_putest_command_t*)ret_buffer = UNIFI_PUTEST_CMD52_READ;
+    ret_buffer_pos = (CsrUint8*)(((unifi_putest_command_t*)ret_buffer) + 1);
+    *(unsigned int*)ret_buffer_pos = sizeof(struct unifi_putest_cmd52);
+    ret_buffer_pos += sizeof(unsigned int);
+    memcpy(ret_buffer_pos, &cmd52_params, sizeof(struct unifi_putest_cmd52));
+    ret_buffer_pos += sizeof(struct unifi_putest_cmd52);
+
+    r = copy_to_user((void*)arg,
+                     ret_buffer,
+                     ret_buffer_pos - ret_buffer);
+    if (r) {
+        unifi_error(priv,
+                    "unifi_putest_cmd52_read: Failed to return the data\n");
+        return -EFAULT;
+    }
+
+    return 0;
+}
+
+
+int unifi_putest_cmd52_write(unifi_priv_t *priv, unsigned char *arg)
+{
+    struct unifi_putest_cmd52 cmd52_params;
+    CsrUint8 *arg_pos;
+    unsigned int cmd_param_size;
+    CsrResult csrResult;
+    CsrUint8 retries;
+
+    arg_pos = (CsrUint8*)(((unifi_putest_command_t*)arg) + 1);
+    if (get_user(cmd_param_size, (int*)arg_pos)) {
+        unifi_error(priv,
+                    "unifi_putest_cmd52_write: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    if (cmd_param_size != sizeof(struct unifi_putest_cmd52)) {
+        unifi_error(priv,
+                    "unifi_putest_cmd52_write: cmd52 struct mismatch\n");
+        return -EINVAL;
+    }
+
+    arg_pos += sizeof(unsigned int);
+    if (copy_from_user(&cmd52_params,
+                       (void*)(arg_pos),
+                       sizeof(struct unifi_putest_cmd52))) {
+        unifi_error(priv,
+                    "unifi_putest_cmd52_write: Failed to get the cmd52 params\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG2, "cmd52w: func=%d addr=0x%x data=%d\n",
+                cmd52_params.funcnum, cmd52_params.addr, cmd52_params.data);
+
+    retries = 3;
+    CsrSdioClaim(priv->sdio);
+    do {
+        if (cmd52_params.funcnum == 0) {
+            csrResult = CsrSdioF0Write8(priv->sdio, cmd52_params.addr, cmd52_params.data);
+        } else {
+            csrResult = CsrSdioWrite8(priv->sdio, cmd52_params.addr, cmd52_params.data);
+        }
+    } while (--retries && ((csrResult == CSR_SDIO_RESULT_CRC_ERROR) || (csrResult == CSR_SDIO_RESULT_TIMEOUT)));
+    CsrSdioRelease(priv->sdio);
+
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv,
+                    "unifi_putest_cmd52_write: Write8() failed (csrResult=0x%x)\n", csrResult);
+        return -EFAULT;
+    }
+
+    return 0;
+}
+
+int unifi_putest_gp_read16(unifi_priv_t *priv, unsigned char *arg)
+{
+    struct unifi_putest_gp_rw16 gp_r16_params;
+    CsrUint8 *arg_pos;
+    unsigned int cmd_param_size;
+    int r;
+    CsrResult csrResult;
+    unsigned char ret_buffer[32];
+    CsrUint8 *ret_buffer_pos;
+
+    arg_pos = (CsrUint8*)(((unifi_putest_command_t*)arg) + 1);
+    if (get_user(cmd_param_size, (int*)arg_pos)) {
+        unifi_error(priv,
+                    "unifi_putest_gp_read16: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    if (cmd_param_size != sizeof(struct unifi_putest_gp_rw16)) {
+        unifi_error(priv,
+                    "unifi_putest_gp_read16: struct mismatch\n");
+        return -EINVAL;
+    }
+
+    arg_pos += sizeof(unsigned int);
+    if (copy_from_user(&gp_r16_params,
+                       (void*)arg_pos,
+                       sizeof(struct unifi_putest_gp_rw16))) {
+        unifi_error(priv,
+                    "unifi_putest_gp_read16: Failed to get the params\n");
+        return -EFAULT;
+    }
+
+    csrResult = unifi_card_read16(priv->card, gp_r16_params.addr, &gp_r16_params.data);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv,
+                    "unifi_putest_gp_read16: unifi_card_read16() GP=0x%x failed (csrResult=0x%x)\n", gp_r16_params.addr, csrResult);
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG2, "gp_r16: GP=0x%08x, data=0x%04x\n", gp_r16_params.addr, gp_r16_params.data);
+
+    /* Copy the info to the out buffer */
+    *(unifi_putest_command_t*)ret_buffer = UNIFI_PUTEST_GP_READ16;
+    ret_buffer_pos = (CsrUint8*)(((unifi_putest_command_t*)ret_buffer) + 1);
+    *(unsigned int*)ret_buffer_pos = sizeof(struct unifi_putest_gp_rw16);
+    ret_buffer_pos += sizeof(unsigned int);
+    memcpy(ret_buffer_pos, &gp_r16_params, sizeof(struct unifi_putest_gp_rw16));
+    ret_buffer_pos += sizeof(struct unifi_putest_gp_rw16);
+
+    r = copy_to_user((void*)arg,
+                     ret_buffer,
+                     ret_buffer_pos - ret_buffer);
+    if (r) {
+        unifi_error(priv,
+                    "unifi_putest_gp_read16: Failed to return the data\n");
+        return -EFAULT;
+    }
+
+    return 0;
+}
+
+int unifi_putest_gp_write16(unifi_priv_t *priv, unsigned char *arg)
+{
+    struct unifi_putest_gp_rw16 gp_w16_params;
+    CsrUint8 *arg_pos;
+    unsigned int cmd_param_size;
+    CsrResult csrResult;
+
+    arg_pos = (CsrUint8*)(((unifi_putest_command_t*)arg) + 1);
+    if (get_user(cmd_param_size, (int*)arg_pos)) {
+        unifi_error(priv,
+                    "unifi_putest_gp_write16: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    if (cmd_param_size != sizeof(struct unifi_putest_gp_rw16)) {
+        unifi_error(priv,
+                    "unifi_putest_gp_write16: struct mismatch\n");
+        return -EINVAL;
+    }
+
+    arg_pos += sizeof(unsigned int);
+    if (copy_from_user(&gp_w16_params,
+                       (void*)(arg_pos),
+                       sizeof(struct unifi_putest_gp_rw16))) {
+        unifi_error(priv,
+                    "unifi_putest_gp_write16: Failed to get the params\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG2, "gp_w16: GP=0x%08x, data=0x%04x\n", gp_w16_params.addr, gp_w16_params.data);
+
+    csrResult = unifi_card_write16(priv->card, gp_w16_params.addr, gp_w16_params.data);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv,
+                    "unifi_putest_gp_write16: unifi_card_write16() GP=%x failed (csrResult=0x%x)\n", gp_w16_params.addr, csrResult);
+        return -EFAULT;
+    }
+
+    return 0;
+}
+
+int unifi_putest_set_sdio_clock(unifi_priv_t *priv, unsigned char *arg)
+{
+    int sdio_clock_speed;
+    CsrResult csrResult;
+
+    if (get_user(sdio_clock_speed, (int*)(((unifi_putest_command_t*)arg) + 1))) {
+        unifi_error(priv,
+                    "unifi_putest_set_sdio_clock: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG2, "set sdio clock: %d KHz\n", sdio_clock_speed);
+
+    CsrSdioClaim(priv->sdio);
+    csrResult = CsrSdioMaxBusClockFrequencySet(priv->sdio, sdio_clock_speed);
+    CsrSdioRelease(priv->sdio);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv,
+                    "unifi_putest_set_sdio_clock: Set clock failed (csrResult=0x%x)\n", csrResult);
+        return -EFAULT;
+    }
+
+    return 0;
+}
+
+
+int unifi_putest_start(unifi_priv_t *priv, unsigned char *arg)
+{
+    int r;
+    CsrResult csrResult;
+    int already_in_test = priv->ptest_mode;
+
+    /* Ensure that sme_sys_suspend() doesn't power down the chip because:
+     *  1) Power is needed anyway for ptest.
+     *  2) The app code uses the START ioctl as a reset, so it gets called
+     *     multiple times. If the app stops the XAPs, but the power_down/up
+     *     sequence doesn't actually power down the chip, there can be problems
+     *     resetting, because part of the power_up sequence disables function 1
+     */
+    priv->ptest_mode = 1;
+
+    /* Suspend the SME and UniFi */
+    if (priv->sme_cli) {
+        r = sme_sys_suspend(priv);
+        if (r) {
+            unifi_error(priv,
+                        "unifi_putest_start: failed to suspend UniFi\n");
+            return r;
+        }
+    }
+
+    /* Application may have stopped the XAPs, but they are needed for reset */
+    if (already_in_test) {
+        csrResult = unifi_start_processors(priv->card);
+        if (csrResult != CSR_RESULT_SUCCESS) {
+            unifi_error(priv, "Failed to start XAPs. Hard reset required.\n");
+        }
+    } else {
+        /* Ensure chip is powered for the case where there's no unifi_helper */
+        CsrSdioClaim(priv->sdio);
+        csrResult = CsrSdioPowerOn(priv->sdio);
+        CsrSdioRelease(priv->sdio);
+        if (csrResult != CSR_RESULT_SUCCESS) {
+            unifi_error(priv, "CsrSdioPowerOn csrResult = %d\n", csrResult);
+        }
+    }
+
+    csrResult = unifi_init(priv->card);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv,
+                    "unifi_putest_start: failed to init UniFi\n");
+        return CsrHipResultToStatus(csrResult);
+    }
+
+    return 0;
+}
+
+
+int unifi_putest_stop(unifi_priv_t *priv, unsigned char *arg)
+{
+    int r = 0;
+    CsrResult csrResult;
+
+    /* Application may have stopped the XAPs, but they are needed for reset */
+    csrResult = unifi_start_processors(priv->card);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "Failed to start XAPs. Hard reset required.\n");
+    }
+
+    /* PUTEST_STOP is also used to resume the XAPs after SME coredump.
+     * Don't power off the chip, leave that to the normal wifi-off which is
+     * about to carry on. No need to resume the SME either, as it wasn't suspended.
+     */
+    if (priv->coredump_mode) {
+        priv->coredump_mode = 0;
+        return 0;
+    }
+
+    /* At this point function 1 is enabled and the XAPs are running, so it is
+     * safe to let the card power down. Power is restored later, asynchronously,
+     * during the wifi_on requested by the SME.
+     */
+    CsrSdioClaim(priv->sdio);
+    CsrSdioPowerOff(priv->sdio);
+    CsrSdioRelease(priv->sdio);
+
+    /* Resume the SME and UniFi */
+    if (priv->sme_cli) {
+        r = sme_sys_resume(priv);
+        if (r) {
+            unifi_error(priv,
+                        "unifi_putest_stop: failed to resume SME\n");
+        }
+    }
+    priv->ptest_mode = 0;
+
+    return r;
+}
+
+
+int unifi_putest_dl_fw(unifi_priv_t *priv, unsigned char *arg)
+{
+#define UF_PUTEST_MAX_FW_FILE_NAME      16
+#define UNIFI_MAX_FW_PATH_LEN           32
+    unsigned int fw_name_length;
+    unsigned char fw_name[UF_PUTEST_MAX_FW_FILE_NAME+1];
+    unsigned char *name_buffer;
+    int postfix;
+    char fw_path[UNIFI_MAX_FW_PATH_LEN];
+    const struct firmware *fw_entry;
+    struct dlpriv temp_fw_sta;
+    int r;
+    CsrResult csrResult;
+
+    /* Get the f/w file name length */
+    if (get_user(fw_name_length, (unsigned int*)(((unifi_putest_command_t*)arg) + 1))) {
+        unifi_error(priv,
+                    "unifi_putest_dl_fw: Failed to get the length argument\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG2, "unifi_putest_dl_fw: file name size = %d\n", fw_name_length);
+
+    /* Sanity check for the f/w file name length */
+    if (fw_name_length > UF_PUTEST_MAX_FW_FILE_NAME) {
+        unifi_error(priv,
+                    "unifi_putest_dl_fw: F/W file name is too long\n");
+        return -EINVAL;
+    }
+
+    /* Get the f/w file name */
+    name_buffer = ((unsigned char*)arg) + sizeof(unifi_putest_command_t) + sizeof(unsigned int);
+    if (copy_from_user(fw_name, (void*)name_buffer, fw_name_length)) {
+        unifi_error(priv, "unifi_putest_dl_fw: Failed to get the file name\n");
+        return -EFAULT;
+    }
+    fw_name[fw_name_length] = '\0';
+    unifi_trace(priv, UDBG2, "unifi_putest_dl_fw: file = %s\n", fw_name);
+
+    /* Keep the existing f/w to a temp, we need to restore it later */
+    temp_fw_sta = priv->fw_sta;
+
+    /* Get the putest f/w */
+    postfix = priv->instance;
+    scnprintf(fw_path, UNIFI_MAX_FW_PATH_LEN, "unifi-sdio-%d/%s",
+              postfix, fw_name);
+    r = request_firmware(&fw_entry, fw_path, priv->unifi_device);
+    if (r == 0) {
+        priv->fw_sta.fw_desc = (void *)fw_entry;
+        priv->fw_sta.dl_data = fw_entry->data;
+        priv->fw_sta.dl_len = fw_entry->size;
+    } else {
+        unifi_error(priv, "Firmware file not available\n");
+        return -EINVAL;
+    }
+
+    /* Application may have stopped the XAPs, but they are needed for reset */
+    csrResult = unifi_start_processors(priv->card);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "Failed to start XAPs. Hard reset required.\n");
+    }
+
+    /* Download the f/w. On UF6xxx this will cause the f/w file to convert
+     * into patch format and download via the ROM boot loader
+     */
+    csrResult = unifi_download(priv->card, 0x0c00);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv,
+                    "unifi_putest_dl_fw: failed to download the f/w\n");
+        goto free_fw;
+    }
+
+    /* Free the putest f/w... */
+free_fw:
+    uf_release_firmware(priv, &priv->fw_sta);
+    /* ... and restore the original f/w */
+    priv->fw_sta = temp_fw_sta;
+
+    return CsrHipResultToStatus(csrResult);
+}
+
+
+int unifi_putest_dl_fw_buff(unifi_priv_t *priv, unsigned char *arg)
+{
+    unsigned int fw_length;
+    unsigned char *fw_buf = NULL;
+    unsigned char *fw_user_ptr;
+    struct dlpriv temp_fw_sta;
+    CsrResult csrResult;
+
+    /* Get the f/w buffer length */
+    if (get_user(fw_length, (unsigned int*)(((unifi_putest_command_t*)arg) + 1))) {
+        unifi_error(priv,
+                    "unifi_putest_dl_fw_buff: Failed to get the length arg\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG2, "unifi_putest_dl_fw_buff: size = %d\n", fw_length);
+
+    /* Sanity check for the buffer length */
+    if (fw_length == 0 || fw_length > 0xfffffff) {
+        unifi_error(priv,
+                    "unifi_putest_dl_fw_buff: buffer length bad %u\n", fw_length);
+        return -EINVAL;
+    }
+
+    /* Buffer for kernel copy of the f/w image */
+    fw_buf = CsrPmemAlloc(fw_length);
+    if (!fw_buf) {
+        unifi_error(priv, "unifi_putest_dl_fw_buff: malloc fail\n");
+        return -ENOMEM;
+    }
+
+    /* Get the f/w image */
+    fw_user_ptr = ((unsigned char*)arg) + sizeof(unifi_putest_command_t) + sizeof(unsigned int);
+    if (copy_from_user(fw_buf, (void*)fw_user_ptr, fw_length)) {
+        unifi_error(priv, "unifi_putest_dl_fw_buff: Failed to get the buffer\n");
+        CsrPmemFree(fw_buf);
+        return -EFAULT;
+    }
+
+    /* Save the existing f/w to a temp, we need to restore it later */
+    temp_fw_sta = priv->fw_sta;
+
+    /* Setting fw_desc NULL indicates to the core that no f/w file was loaded
+     * via the kernel request_firmware() mechanism. This indicates to the core
+     * that it shouldn't call release_firmware() after the download is done.
+     */
+    priv->fw_sta.fw_desc = NULL;            /* No OS f/w resource */
+    priv->fw_sta.dl_data = fw_buf;
+    priv->fw_sta.dl_len = fw_length;
+
+    /* Application may have stopped the XAPs, but they are needed for reset */
+    csrResult = unifi_start_processors(priv->card);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "Failed to start XAPs. Hard reset required.\n");
+    }
+
+    /* Download the f/w. On UF6xxx this will cause the f/w file to convert
+     * into patch format and download via the ROM boot loader
+     */
+    csrResult = unifi_download(priv->card, 0x0c00);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv,
+                    "unifi_putest_dl_fw_buff: failed to download the f/w\n");
+        goto free_fw;
+    }
+
+free_fw:
+    /* Finished with the putest f/w, so restore the station f/w */
+    priv->fw_sta = temp_fw_sta;
+    CsrPmemFree(fw_buf);
+
+    return CsrHipResultToStatus(csrResult);
+}
+
+
+int unifi_putest_coredump_prepare(unifi_priv_t *priv, unsigned char *arg)
+{
+    CsrUint16 data_u16;
+    CsrInt32 i;
+    CsrResult r;
+
+    unifi_info(priv, "Preparing for SDIO coredump\n");
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE)
+    unifi_debug_buf_dump();
+#endif
+
+    /* Sanity check that userspace hasn't called a PUTEST_START, because that
+     * would have reset UniFi, potentially power cycling it and losing context
+     */
+    if (priv->ptest_mode) {
+        unifi_error(priv, "PUTEST_START shouldn't be used before a coredump\n");
+    }
+
+    /* Flag that the userspace has requested coredump. Even if this preparation
+     * fails, the SME will call PUTEST_STOP to tidy up.
+     */
+    priv->coredump_mode = 1;
+
+    for (i = 0; i < 3; i++) {
+        CsrSdioClaim(priv->sdio);
+        r = CsrSdioRead16(priv->sdio, CHIP_HELPER_UNIFI_GBL_CHIP_VERSION*2, &data_u16);
+        CsrSdioRelease(priv->sdio);
+        if (r != CSR_RESULT_SUCCESS) {
+            unifi_info(priv, "Failed to read chip version! Try %d\n", i);
+
+            /* First try, re-enable function which may have been disabled by f/w panic */
+            if (i == 0) {
+                unifi_info(priv, "Try function enable\n");
+                CsrSdioClaim(priv->sdio);
+                r = CsrSdioFunctionEnable(priv->sdio);
+                CsrSdioRelease(priv->sdio);
+                if (r != CSR_RESULT_SUCCESS) {
+                    unifi_error(priv, "CsrSdioFunctionEnable failed %d\n", r);
+                }
+                continue;
+            }
+
+            /* Subsequent tries, reset */
+
+            /* Set clock speed low */
+            CsrSdioClaim(priv->sdio);
+            r = CsrSdioMaxBusClockFrequencySet(priv->sdio, UNIFI_SDIO_CLOCK_SAFE_HZ);
+            CsrSdioRelease(priv->sdio);
+            if (r != CSR_RESULT_SUCCESS) {
+                unifi_error(priv, "CsrSdioMaxBusClockFrequencySet() failed %d\n", r);
+            }
+
+            /* Card software reset */
+            r = unifi_card_hard_reset(priv->card);
+            if (r != CSR_RESULT_SUCCESS) {
+                unifi_error(priv, "unifi_card_hard_reset() failed %d\n", r);
+            }
+        } else {
+            unifi_info(priv, "Read chip version of 0x%04x\n", data_u16);
+            break;
+        }
+    }
+
+    if (r != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "Failed to prepare chip\n");
+        return -EIO;
+    }
+
+    /* Stop the XAPs for coredump. The PUTEST_STOP must be called, e.g. at
+     * Raw SDIO deinit, to resume them.
+     */
+    r = unifi_card_stop_processor(priv->card, UNIFI_PROC_BOTH);
+    if (r != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "Failed to stop processors\n");
+    }
+
+    return 0;
+}
+
+int unifi_putest_cmd52_block_read(unifi_priv_t *priv, unsigned char *arg)
+{
+    struct unifi_putest_block_cmd52_r block_cmd52;
+    CsrUint8 *arg_pos;
+    unsigned int cmd_param_size;
+    CsrResult r;
+    CsrUint8 *block_local_buffer;
+
+    arg_pos = (CsrUint8*)(((unifi_putest_command_t*)arg) + 1);
+    if (get_user(cmd_param_size, (int*)arg_pos)) {
+        unifi_error(priv,
+                    "cmd52r_block: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    if (cmd_param_size != sizeof(struct unifi_putest_block_cmd52_r)) {
+        unifi_error(priv,
+                    "cmd52r_block: cmd52 struct mismatch\n");
+        return -EINVAL;
+    }
+
+    arg_pos += sizeof(unsigned int);
+    if (copy_from_user(&block_cmd52,
+                       (void*)arg_pos,
+                       sizeof(struct unifi_putest_block_cmd52_r))) {
+        unifi_error(priv,
+                    "cmd52r_block: Failed to get the cmd52 params\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG2, "cmd52r_block: func=%d addr=0x%x len=0x%x ",
+                block_cmd52.funcnum, block_cmd52.addr, block_cmd52.length);
+
+    block_local_buffer = vmalloc(block_cmd52.length);
+    if (block_local_buffer == NULL) {
+        unifi_error(priv, "cmd52r_block: Failed to allocate buffer\n");
+        return -ENOMEM;
+    }
+
+    r = unifi_card_readn(priv->card, block_cmd52.addr, block_local_buffer, block_cmd52.length);
+    if (r != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "cmd52r_block: unifi_readn failed\n");
+        return -EIO;
+    }
+
+    if (copy_to_user((void*)block_cmd52.data,
+                     block_local_buffer,
+                     block_cmd52.length)) {
+        unifi_error(priv,
+                    "cmd52r_block: Failed to return the data\n");
+        return -EFAULT;
+    }
+
+    return 0;
+}
--- /dev/null
+++ b/drivers/staging/csr/sdio_emb.c
@@ -0,0 +1,732 @@
+/*
+ * ---------------------------------------------------------------------------
+ *
+ * FILE: sdio_emb.c
+ *
+ * PURPOSE: Driver instantiation and deletion for SDIO on Linux.
+ *
+ *      This file brings together the SDIO bus interface, the UniFi
+ *      driver core and the Linux net_device stack.
+ *
+ * Copyright (C) 2007-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include <linux/kmod.h>
+#include <linux/init.h>
+#include "csr_wifi_hip_unifi.h"
+#include "unifi_priv.h"
+
+#include "sdioemb/sdio_api.h"
+
+/* The function driver context, i.e the UniFi Driver */
+static CsrSdioFunctionDriver *sdio_func_drv;
+
+
+
+/* sdioemb driver uses POSIX error codes */
+static CsrResult
+ConvertSdioToCsrSdioResult(int r)
+{
+    CsrResult csrResult = CSR_RESULT_FAILURE;
+
+    switch (r) {
+        case 0:
+            csrResult = CSR_RESULT_SUCCESS;
+            break;
+        case -EIO:
+            csrResult = CSR_SDIO_RESULT_CRC_ERROR;
+            break;
+            /* Timeout errors */
+        case -ETIMEDOUT:
+        case -EBUSY:
+            csrResult = CSR_SDIO_RESULT_TIMEOUT;
+            break;
+        case -ENODEV:
+        case -ENOMEDIUM:
+            csrResult = CSR_SDIO_RESULT_NO_DEVICE;
+            break;
+        case -EINVAL:
+            csrResult = CSR_SDIO_RESULT_INVALID_VALUE;
+            break;
+        case -ENOMEM:
+        case -ENOSYS:
+        case -EILSEQ:
+        case -ERANGE:
+        case -ENXIO:
+            csrResult = CSR_RESULT_FAILURE;
+            break;
+        default:
+            unifi_warning(NULL, "Unrecognised SDIO error code: %d\n", r);
+            break;
+    }
+
+    return csrResult;
+}
+
+
+CsrResult
+CsrSdioRead8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int err;
+    err = sdioemb_read8(fdev, address, data);
+    if (err) {
+        return ConvertSdioToCsrSdioResult(err);
+    }
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioRead8() */
+
+CsrResult
+CsrSdioWrite8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int err;
+    err = sdioemb_write8(fdev, address, data);
+    if (err) {
+        return ConvertSdioToCsrSdioResult(err);
+    }
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioWrite8() */
+
+CsrResult
+CsrSdioRead16(CsrSdioFunction *function, CsrUint32 address, CsrUint16 *data)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int r;
+
+    r = sdioemb_read16(fdev, address, data);
+    if (r) {
+        return ConvertSdioToCsrSdioResult(r);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioRead16() */
+
+CsrResult
+CsrSdioWrite16(CsrSdioFunction *function, CsrUint32 address, CsrUint16 data)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int r;
+
+    r = sdioemb_write16(fdev, address, data);
+    if (r) {
+        return ConvertSdioToCsrSdioResult(r);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioWrite16() */
+
+
+CsrResult
+CsrSdioF0Read8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int err;
+    err = sdioemb_f0_read8(fdev, address, data);
+    if (err) {
+        return ConvertSdioToCsrSdioResult(err);
+    }
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioF0Read8() */
+
+
+CsrResult
+CsrSdioF0Write8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int err;
+    err = sdioemb_f0_write8(fdev, address, data);
+    if (err) {
+        return ConvertSdioToCsrSdioResult(err);
+    }
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioF0Write8() */
+
+CsrResult
+CsrSdioRead(CsrSdioFunction *function, CsrUint32 address, void *data, CsrUint32 length)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int err;
+    err = sdioemb_read(fdev, address, data, length);
+    if (err) {
+        return ConvertSdioToCsrSdioResult(err);
+    }
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioRead() */
+
+CsrResult
+CsrSdioWrite(CsrSdioFunction *function, CsrUint32 address, const void *data, CsrUint32 length)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int err;
+    err = sdioemb_write(fdev, address, data, length);
+    if (err) {
+        return ConvertSdioToCsrSdioResult(err);
+    }
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioWrite() */
+
+
+CsrResult
+CsrSdioBlockSizeSet(CsrSdioFunction *function, CsrUint16 blockSize)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int r = 0;
+
+    /* Module parameter overrides */
+    if (sdio_block_size > -1) {
+        blockSize = sdio_block_size;
+    }
+
+    unifi_trace(NULL, UDBG1, "Set SDIO function block size to %d\n",
+            blockSize);
+
+    r = sdioemb_set_block_size(fdev, blockSize);
+    if (r) {
+        unifi_error(NULL, "Error %d setting block size\n", r);
+    }
+
+    /* Determine the achieved block size to report to the core */
+    function->blockSize = fdev->blocksize;
+
+    return ConvertSdioToCsrSdioResult(r);
+} /* CsrSdioBlockSizeSet() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioMaxBusClockFrequencySet
+ *
+ *      Set the maximum SDIO bus clock speed to use.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ *      maxFrequency         maximum clock speed in Hz
+ *
+ *  Returns:
+ *      an error code.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioMaxBusClockFrequencySet(CsrSdioFunction *function, CsrUint32 maxFrequency)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    CsrUint32 max_khz = maxFrequency/1000;
+
+    if (!max_khz || max_khz > sdio_clock) {
+        max_khz = sdio_clock;
+    }
+    unifi_trace(NULL, UDBG1, "Setting SDIO bus clock to %d kHz\n", max_khz);
+    sdioemb_set_max_bus_freq(fdev, 1000 * max_khz);
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioMaxBusClockFrequencySet() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioInterruptEnable
+ *  CsrSdioInterruptDisable
+ *
+ *      Enable or disable the SDIO interrupt.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ *
+ *  Returns:
+ *      Zero on success or a UniFi driver error code.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioInterruptEnable(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int r;
+
+    r = sdioemb_interrupt_enable(fdev);
+    if (r) {
+        return ConvertSdioToCsrSdioResult(r);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioInterruptEnable() */
+
+CsrResult
+CsrSdioInterruptDisable(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int r;
+
+    r = sdioemb_interrupt_disable(fdev);
+    if (r) {
+        return ConvertSdioToCsrSdioResult(r);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioInterruptDisable() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioInterruptAcknowledge
+ *
+ *      Acknowledge an SDIO interrupt.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ *
+ *  Returns:
+ *      Zero on success or a UniFi driver error code.
+ * ---------------------------------------------------------------------------
+ */
+void CsrSdioInterruptAcknowledge(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+
+    sdioemb_interrupt_acknowledge(fdev);
+} /* CsrSdioInterruptAcknowledge() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioFunctionEnable
+ *
+ *      Enable i/o on this function.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ *
+ * Returns:
+ *      UniFi driver error code.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioFunctionEnable(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int r;
+
+    /* Enable UniFi function (the 802.11 part). */
+    r = sdioemb_enable_function(fdev);
+    if (r) {
+        unifi_error(NULL, "Failed to enable SDIO function %d\n", fdev->function);
+        return ConvertSdioToCsrSdioResult(r);
+    }
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioFunctionEnable() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioFunctionDisable
+ *
+ *      Disable i/o on this function.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ *
+ * Returns:
+ *      UniFi driver error code.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioFunctionDisable(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int r;
+
+    /* Disable UniFi function (the 802.11 part). */
+    r = sdioemb_disable_function(fdev);
+    if (r) {
+        unifi_error(NULL, "Failed to disable SDIO function %d\n", fdev->function);
+        return ConvertSdioToCsrSdioResult(r);
+    }
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioFunctionDisable() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioFunctionActive
+ *
+ *      No-op as the bus goes to an active state at the start of every
+ *      command.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ * ---------------------------------------------------------------------------
+ */
+void
+CsrSdioFunctionActive(CsrSdioFunction *function)
+{
+} /* CsrSdioFunctionActive() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioFunctionIdle
+ *
+ *      Set the function as idle.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ * ---------------------------------------------------------------------------
+ */
+void
+CsrSdioFunctionIdle(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+
+    sdioemb_idle_function(fdev);
+} /* CsrSdioFunctionIdle() */
+
+
+CsrResult
+CsrSdioPowerOn(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+
+    if (disable_power_control != 1) {
+        sdioemb_power_on(fdev);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioPowerOn() */
+
+void
+CsrSdioPowerOff(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    if (disable_power_control != 1) {
+        sdioemb_power_off(fdev);
+    }
+} /* CsrSdioPowerOff() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioHardReset
+ *
+ *      Hard Resets UniFi is possible.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ *
+ * Returns:
+ *      1       if the SDIO driver is not capable of doing a hard reset.
+ *      0       if a hard reset was successfully performed.
+ *      -CSR_EIO if an I/O error occured while re-initializing the card.
+ *              This is a fatal, non-recoverable error.
+ *      -CSR_ENODEV if the card is no longer present.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioHardReset(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+    int r;
+
+    /* Hard reset can be disabled by a module parameter */
+    r = 1;
+    if (disable_hw_reset != 1) {
+        r = sdioemb_hard_reset(fdev); /* may return 1 if can't reset */
+        if (r < 0) {
+            return ConvertSdioToCsrSdioResult(r);   /* fatal error */
+        }
+    }
+
+    /* Set the SDIO bus width after a hard reset */
+    if (buswidth == 1) {
+        unifi_info(NULL, "Setting SDIO bus width to 1\n");
+        sdioemb_set_bus_width(fdev, buswidth);
+    } else if (buswidth == 4) {
+        unifi_info(NULL, "Setting SDIO bus width to 4\n");
+        sdioemb_set_bus_width(fdev, buswidth);
+    }
+
+    if(r == 1)
+    {
+        return CSR_SDIO_RESULT_NOT_RESET;
+    }
+
+    return ConvertSdioToCsrSdioResult(r);
+
+} /* CsrSdioHardReset() */
+
+
+int csr_sdio_linux_remove_irq(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+
+    return sdioemb_interrupt_disable(fdev);
+}
+
+int csr_sdio_linux_install_irq(CsrSdioFunction *function)
+{
+    struct sdioemb_dev *fdev = (struct sdioemb_dev *)function->priv;
+
+    return sdioemb_interrupt_enable(fdev);
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_glue_sdio_int_handler
+ *      Card interrupt callback.
+ *
+ * Arguments:
+ *      fdev            SDIO context pointer
+ *
+ * Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void
+uf_glue_sdio_int_handler(struct sdioemb_dev *fdev)
+{
+    CsrSdioFunction *sdio_ctx = fdev->drv_data;
+    CsrSdioInterruptDsrCallback func_dsr_callback;
+
+    /* If the function driver has registered a handler, call it */
+    if (sdio_func_drv && sdio_func_drv->intr) {
+        /* The function driver may return a DSR. */
+        func_dsr_callback = sdio_func_drv->intr(sdio_ctx);
+        /* If it did return a DSR handle, call it */
+        if (func_dsr_callback) {
+            func_dsr_callback(sdio_ctx);
+        }
+    }
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_glue_sdio_probe
+ *
+ *      Card insert callback.
+ *
+ * Arguments:
+ *      fdev            SDIO context pointer
+ *
+ * Returns:
+ *      UniFi driver error code.
+ * ---------------------------------------------------------------------------
+ */
+static int
+uf_glue_sdio_probe(struct sdioemb_dev *fdev)
+{
+    CsrSdioFunction *sdio_ctx;
+
+    unifi_info(NULL, "UniFi card inserted\n");
+
+    /* Allocate context and private in one lump */
+    sdio_ctx = (CsrSdioFunction *)kmalloc(sizeof(CsrSdioFunction),
+                                          GFP_KERNEL);
+    if (sdio_ctx == NULL) {
+        return -ENOMEM;
+    }
+
+
+    sdio_ctx->sdioId.manfId = fdev->vendor_id;
+    sdio_ctx->sdioId.cardId = fdev->device_id;
+    sdio_ctx->sdioId.sdioFunction = fdev->function;
+    sdio_ctx->sdioId.sdioInterface = 0;
+    sdio_ctx->blockSize = fdev->blocksize;
+    sdio_ctx->priv = (void *)fdev;
+    sdio_ctx->features = 0;
+
+    /* Module parameter enables byte mode */
+    if (sdio_byte_mode) {
+        sdio_ctx->features |= CSR_SDIO_FEATURE_BYTE_MODE;
+    }
+
+    /* Set up pointer to func_priv in middle of lump */
+    fdev->drv_data = sdio_ctx;
+
+    /* Always override default SDIO bus clock */
+    unifi_trace(NULL, UDBG1, "Setting SDIO bus clock to %d kHz\n", sdio_clock);
+    sdioemb_set_max_bus_freq(fdev, 1000 * sdio_clock);
+
+    /* Call the main UniFi driver inserted handler */
+    if (sdio_func_drv && sdio_func_drv->inserted) {
+        uf_add_os_device(fdev->slot_id, fdev->os_device);
+        sdio_func_drv->inserted(sdio_ctx);
+    }
+
+    return 0;
+} /* uf_glue_sdio_probe() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_sdio_remove
+ *
+ *      Card removal callback.
+ *
+ * Arguments:
+ *      fdev            SDIO device
+ *
+ * Returns:
+ *      UniFi driver error code.
+ * ---------------------------------------------------------------------------
+ */
+static void
+uf_sdio_remove(struct sdioemb_dev *fdev)
+{
+    CsrSdioFunction *sdio_ctx = fdev->drv_data;
+
+    unifi_info(NULL, "UniFi card removed\n");
+
+    /* Clean up the SDIO function driver */
+    if (sdio_func_drv && sdio_func_drv->removed) {
+        sdio_func_drv->removed(sdio_ctx);
+    }
+
+    kfree(sdio_ctx);
+
+} /* uf_sdio_remove */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_glue_sdio_suspend
+ *
+ *      System suspend callback.
+ *
+ * Arguments:
+ *      fdev            SDIO device
+ *
+ * Returns:
+ *
+ * ---------------------------------------------------------------------------
+ */
+static void
+uf_glue_sdio_suspend(struct sdioemb_dev *fdev)
+{
+    CsrSdioFunction *sdio_ctx = fdev->drv_data;
+
+    unifi_trace(NULL, UDBG3, "Suspending...\n");
+
+    /* Pass event to UniFi Driver. */
+    if (sdio_func_drv && sdio_func_drv->suspend) {
+        sdio_func_drv->suspend(sdio_ctx);
+    }
+
+} /* uf_glue_sdio_suspend() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_glue_sdio_resume
+ *
+ *      System resume callback.
+ *
+ * Arguments:
+ *      fdev            SDIO device
+ *
+ * Returns:
+ *
+ * ---------------------------------------------------------------------------
+ */
+static void
+uf_glue_sdio_resume(struct sdioemb_dev *fdev)
+{
+    CsrSdioFunction *sdio_ctx = fdev->drv_data;
+
+    unifi_trace(NULL, UDBG3, "Resuming...\n");
+
+    /* Pass event to UniFi Driver. */
+    if (sdio_func_drv && sdio_func_drv->resume) {
+        sdio_func_drv->resume(sdio_ctx);
+    }
+} /* uf_glue_sdio_resume() */
+
+
+
+
+static struct sdioemb_func_driver unifi_sdioemb = {
+    .name = "unifi",
+    .id_table = NULL,           /* Filled in when main driver registers */
+
+    .probe  = uf_glue_sdio_probe,
+    .remove = uf_sdio_remove,
+    .card_int_handler = uf_glue_sdio_int_handler,
+    .suspend  = uf_glue_sdio_suspend,
+    .resume = uf_glue_sdio_resume,
+};
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioFunctionDriverRegister
+ *  CsrSdioFunctionDriverUnregister
+ *
+ *      These functions are called from the main module load and unload
+ *      functions. They perform the appropriate operations for the
+ *      SDIOemb driver.
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioFunctionDriverRegister(CsrSdioFunctionDriver *sdio_drv)
+{
+    int r;
+    int i;
+
+    printk("Unifi: Using CSR embedded SDIO driver\n");
+
+    if (sdio_func_drv) {
+        unifi_error(NULL, "sdio_emb: UniFi driver already registered\n");
+        return CSR_SDIO_RESULT_INVALID_VALUE;
+    }
+
+    /* Build ID table to pass to sdioemb */
+    unifi_sdioemb.id_table = CsrPmemAlloc(sizeof(struct sdioemb_id_table) * (sdio_drv->idsCount + 1));
+    if (unifi_sdioemb.id_table == NULL) {
+        unifi_error(NULL, "sdio_emb: Failed to allocate memory for ID table (%d IDs)\n", sdio_drv->idsCount);
+        return CSR_RESULT_FAILURE;
+    }
+    for (i = 0; i < sdio_drv->idsCount; i++) {
+        unifi_sdioemb.id_table[i].vendor_id = sdio_drv->ids[i].manfId;
+        unifi_sdioemb.id_table[i].device_id = sdio_drv->ids[i].cardId;
+        unifi_sdioemb.id_table[i].function  = sdio_drv->ids[i].sdioFunction;
+        unifi_sdioemb.id_table[i].interface = sdio_drv->ids[i].sdioInterface;
+    }
+    unifi_sdioemb.id_table[i].vendor_id = 0;
+    unifi_sdioemb.id_table[i].device_id = 0;
+    unifi_sdioemb.id_table[i].function  = 0;
+    unifi_sdioemb.id_table[i].interface = 0;
+
+    /* Save the registered driver description */
+    sdio_func_drv = sdio_drv;
+
+    /* Register ourself with sdioemb */
+    r = sdioemb_driver_register(&unifi_sdioemb);
+    if (r) {
+        unifi_error(NULL, "Failed to register UniFi SDIO driver: %d\n", r);
+        return ConvertSdioToCsrSdioResult(r);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioFunctionDriverRegister() */
+
+
+void
+CsrSdioFunctionDriverUnregister(CsrSdioFunctionDriver *sdio_drv)
+{
+    sdioemb_driver_unregister(&unifi_sdioemb);
+
+    sdio_func_drv = NULL;
+
+    CsrPmemFree(unifi_sdioemb.id_table);
+    unifi_sdioemb.id_table = NULL;
+} /* CsrSdioFunctionDriverUnregister() */
+
--- /dev/null
+++ b/drivers/staging/csr/sdio_events.c
@@ -0,0 +1,87 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     sdio_events.c
+ *
+ * PURPOSE:
+ *      Process the events received by the SDIO glue layer.
+ *      Optional part of the porting exercise.
+ *
+ * Copyright (C) 2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include "unifi_priv.h"
+
+
+/*
+ * Porting Notes:
+ * There are two ways to support the suspend/resume system events in a driver.
+ * In some operating systems these events are delivered to the OS driver
+ * directly from the system. In this case, the OS driver needs to pass these
+ * events to the API described in the CSR SDIO Abstration API document.
+ * In Linux, and other embedded operating systems, the suspend/resume events
+ * come from the SDIO driver. In this case, simply get these events in the
+ * SDIO glue layer and notify the OS layer.
+ *
+ * In either case, typically, the events are processed by the SME.
+ * Use the unifi_sys_suspend_ind() and unifi_sys_resume_ind() to pass
+ * the events to the SME.
+ */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_suspend
+ *
+ *      Handles a suspend request from the SDIO driver.
+ *
+ *  Arguments:
+ *      ospriv          Pointer to OS driver context.
+ *
+ * ---------------------------------------------------------------------------
+ */
+void unifi_suspend(void *ospriv)
+{
+    unifi_priv_t *priv = ospriv;
+    int interfaceTag=0;
+
+    /* Stop network traffic. */
+    /* need to stop all the netdevices*/
+    for( interfaceTag=0;interfaceTag<CSR_WIFI_NUM_INTERFACES;interfaceTag++)
+    {
+        netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+        if (interfacePriv->netdev_registered == 1)
+        {
+            netif_carrier_off(priv->netdev[interfaceTag]);
+            UF_NETIF_TX_STOP_ALL_QUEUES(priv->netdev[interfaceTag]);
+        }
+    }
+    sme_sys_suspend(priv);
+} /* unifi_suspend() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_resume
+ *
+ *      Handles a resume request from the SDIO driver.
+ *
+ *  Arguments:
+ *      ospriv          Pointer to OS driver context.
+ *
+ * ---------------------------------------------------------------------------
+ */
+void unifi_resume(void *ospriv)
+{
+    unifi_priv_t *priv = ospriv;
+    int r;
+
+    r = sme_sys_resume(priv);
+    if (r) {
+        unifi_error(priv, "Failed to resume UniFi\n");
+    }
+
+} /* unifi_resume() */
+
--- /dev/null
+++ b/drivers/staging/csr/sdio_mmc.c
@@ -0,0 +1,1165 @@
+/*
+ * ---------------------------------------------------------------------------
+ *
+ * FILE: sdio_mmc.c
+ *
+ * PURPOSE: SDIO driver interface for generic MMC stack.
+ *
+ * Copyright (C) 2008-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/gfp.h>
+
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio.h>
+
+#include "unifi_priv.h"
+
+
+static CsrSdioFunctionDriver *sdio_func_drv;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+/*
+ * We need to keep track of the power on/off because we can not call
+ * mmc_power_restore_host() when the card is already powered.
+ * Even then, we need to patch the MMC driver to add a power_restore handler
+ * in the mmc_sdio_ops structure. If the MMC driver is not patched,
+ * mmc_power_save_host() and mmc_power_restore_host() are no-ops.
+ */
+static int card_is_powered = 1;
+#endif /* 2.6.32 */
+
+/* MMC uses ENOMEDIUM to indicate card gone away */
+
+static CsrResult
+ConvertSdioToCsrSdioResult(int r)
+{
+    CsrResult csrResult = CSR_RESULT_FAILURE;
+
+    switch (r) {
+    case 0:
+        csrResult = CSR_RESULT_SUCCESS;
+    break;
+    case -EIO:
+    case -EILSEQ:
+        csrResult = CSR_SDIO_RESULT_CRC_ERROR;
+    break;
+    /* Timeout errors */
+    case -ETIMEDOUT:
+    case -EBUSY:
+        csrResult = CSR_SDIO_RESULT_TIMEOUT;
+    break;
+    case -ENODEV:
+    case -ENOMEDIUM:
+        csrResult = CSR_SDIO_RESULT_NO_DEVICE;
+    break;
+    case -EINVAL:
+        csrResult = CSR_SDIO_RESULT_INVALID_VALUE;
+    break;
+    case -ENOMEM:
+    case -ENOSYS:
+    case -ERANGE:
+    case -ENXIO:
+        csrResult = CSR_RESULT_FAILURE;
+    break;
+    default:
+        unifi_warning(NULL, "Unrecognised SDIO error code: %d\n", r);
+    break;
+    }
+
+    return csrResult;
+}
+
+
+static int
+csr_io_rw_direct(struct mmc_card *card, int write, uint8_t fn,
+                 uint32_t addr, uint8_t in, uint8_t* out)
+{
+    struct mmc_command cmd;
+    int err;
+
+    BUG_ON(!card);
+    BUG_ON(fn > 7);
+
+    memset(&cmd, 0, sizeof(struct mmc_command));
+
+    cmd.opcode = SD_IO_RW_DIRECT;
+    cmd.arg = write ? 0x80000000 : 0x00000000;
+    cmd.arg |= fn << 28;
+    cmd.arg |= (write && out) ? 0x08000000 : 0x00000000;
+    cmd.arg |= addr << 9;
+    cmd.arg |= in;
+    cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;
+
+    err = mmc_wait_for_cmd(card->host, &cmd, 0);
+    if (err)
+        return err;
+
+    /* this function is not exported, so we will need to sort it out here
+     * for now, lets hard code it to sdio */
+    if (0) {
+        /* old arg (mmc_host_is_spi(card->host)) { */
+        /* host driver already reported errors */
+    } else {
+        if (cmd.resp[0] & R5_ERROR) {
+            printk(KERN_ERR "%s: r5 error 0x%02x\n",
+                   __FUNCTION__, cmd.resp[0]);
+            return -EIO;
+        }
+        if (cmd.resp[0] & R5_FUNCTION_NUMBER)
+            return -EINVAL;
+        if (cmd.resp[0] & R5_OUT_OF_RANGE)
+            return -ERANGE;
+    }
+
+    if (out) {
+        if (0) {    /* old argument (mmc_host_is_spi(card->host)) */
+            *out = (cmd.resp[0] >> 8) & 0xFF;
+        }
+        else {
+            *out = cmd.resp[0] & 0xFF;
+        }
+    }
+
+    return CSR_RESULT_SUCCESS;
+}
+
+
+CsrResult
+CsrSdioRead8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err = 0;
+
+    _sdio_claim_host(func);
+    *data = sdio_readb(func, address, &err);
+    _sdio_release_host(func);
+
+    if (err) {
+        func_exit_r(err);
+        return ConvertSdioToCsrSdioResult(err);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioRead8() */
+
+CsrResult
+CsrSdioWrite8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err = 0;
+
+    _sdio_claim_host(func);
+    sdio_writeb(func, data, address, &err);
+    _sdio_release_host(func);
+
+    if (err) {
+        func_exit_r(err);
+        return ConvertSdioToCsrSdioResult(err);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioWrite8() */
+
+CsrResult
+CsrSdioRead16(CsrSdioFunction *function, CsrUint32 address, CsrUint16 *data)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err;
+    uint8_t b0, b1;
+
+    _sdio_claim_host(func);
+    b0 = sdio_readb(func, address, &err);
+    if (err) {
+        _sdio_release_host(func);
+        return ConvertSdioToCsrSdioResult(err);
+    }
+
+    b1 = sdio_readb(func, address+1, &err);
+    if (err) {
+        _sdio_release_host(func);
+        return ConvertSdioToCsrSdioResult(err);
+    }
+    _sdio_release_host(func);
+
+    *data = ((uint16_t)b1 << 8) | b0;
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioRead16() */
+
+
+CsrResult
+CsrSdioWrite16(CsrSdioFunction *function, CsrUint32 address, CsrUint16 data)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err;
+    uint8_t b0, b1;
+
+    _sdio_claim_host(func);
+    b1 = (data >> 8) & 0xFF;
+    sdio_writeb(func, b1, address+1, &err);
+    if (err) {
+        _sdio_release_host(func);
+        return ConvertSdioToCsrSdioResult(err);
+    }
+
+    b0 = data & 0xFF;
+    sdio_writeb(func, b0, address, &err);
+    if (err) {
+        _sdio_release_host(func);
+        return ConvertSdioToCsrSdioResult(err);
+    }
+
+    _sdio_release_host(func);
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioWrite16() */
+
+
+CsrResult
+CsrSdioF0Read8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err = 0;
+
+    _sdio_claim_host(func);
+#ifdef MMC_QUIRK_LENIENT_FN0
+    *data = sdio_f0_readb(func, address, &err);
+#else
+    err = csr_io_rw_direct(func->card, 0, 0, address, 0, data);
+#endif
+    _sdio_release_host(func);
+
+    if (err) {
+        func_exit_r(err);
+        return ConvertSdioToCsrSdioResult(err);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioF0Read8() */
+
+CsrResult
+CsrSdioF0Write8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err = 0;
+
+    _sdio_claim_host(func);
+#ifdef MMC_QUIRK_LENIENT_FN0
+    sdio_f0_writeb(func, data, address, &err);
+#else
+    err = csr_io_rw_direct(func->card, 1, 0, address, data, NULL);
+#endif
+    _sdio_release_host(func);
+
+    if (err) {
+        func_exit_r(err);
+        return ConvertSdioToCsrSdioResult(err);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioF0Write8() */
+
+
+CsrResult
+CsrSdioRead(CsrSdioFunction *function, CsrUint32 address, void *data, CsrUint32 length)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err;
+
+    _sdio_claim_host(func);
+    err = sdio_readsb(func, data, address, length);
+    _sdio_release_host(func);
+
+    if (err) {
+        func_exit_r(err);
+        return ConvertSdioToCsrSdioResult(err);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioRead() */
+
+CsrResult
+CsrSdioWrite(CsrSdioFunction *function, CsrUint32 address, const void *data, CsrUint32 length)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err;
+
+    _sdio_claim_host(func);
+    err = sdio_writesb(func, address, (void*)data, length);
+    _sdio_release_host(func);
+
+    if (err) {
+        func_exit_r(err);
+        return ConvertSdioToCsrSdioResult(err);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioWrite() */
+
+
+static int
+csr_sdio_enable_hs(struct mmc_card *card)
+{
+    int ret;
+    u8 speed;
+
+    if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
+        return 0;
+
+    if (!card->cccr.high_speed)
+        return 0;
+
+    ret = csr_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);
+    if (ret)
+        return ret;
+
+    speed |= SDIO_SPEED_EHS;
+
+    ret = csr_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);
+    if (ret)
+        return ret;
+
+    mmc_card_set_highspeed(card);
+    card->host->ios.timing = MMC_TIMING_SD_HS;
+    card->host->ops->set_ios(card->host, &card->host->ios);
+
+    return 0;
+}
+
+static int
+csr_sdio_disable_hs(struct mmc_card *card)
+{
+    int ret;
+    u8 speed;
+
+    if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
+        return 0;
+
+    if (!card->cccr.high_speed)
+        return 0;
+
+    ret = csr_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);
+    if (ret)
+        return ret;
+
+    speed &= ~SDIO_SPEED_EHS;
+
+    ret = csr_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);
+    if (ret)
+        return ret;
+
+    card->state &= ~MMC_STATE_HIGHSPEED;
+    card->host->ios.timing = MMC_TIMING_LEGACY;
+    card->host->ops->set_ios(card->host, &card->host->ios);
+
+    return 0;
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioMaxBusClockFrequencySet
+ *
+ *      Set the maximum SDIO bus clock speed to use.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ *      maxFrequency         maximum clock speed in Hz
+ *
+ *  Returns:
+ *      an error code.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioMaxBusClockFrequencySet(CsrSdioFunction *function, CsrUint32 maxFrequency)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    struct mmc_host *host = func->card->host;
+    struct mmc_ios *ios = &host->ios;
+    unsigned int max_hz;
+    int err;
+	CsrUint32 max_khz = maxFrequency/1000;
+
+    if (!max_khz || max_khz > sdio_clock) {
+        max_khz = sdio_clock;
+    }
+
+    _sdio_claim_host(func);
+    max_hz = 1000 * max_khz;
+    if (max_hz > host->f_max) {
+        max_hz = host->f_max;
+    }
+
+    if (max_hz > 25000000) {
+        err = csr_sdio_enable_hs(func->card);
+    } else {
+        err = csr_sdio_disable_hs(func->card);
+    }
+    if (err) {
+        printk(KERN_ERR "SDIO warning: Failed to configure SDIO clock mode\n");
+        _sdio_release_host(func);
+		return CSR_RESULT_SUCCESS;
+    }
+
+    ios->clock = max_hz;
+    host->ops->set_ios(host, ios);
+
+    _sdio_release_host(func);
+
+	return CSR_RESULT_SUCCESS;
+} /* CsrSdioMaxBusClockFrequencySet() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioInterruptEnable
+ *  CsrSdioInterruptDisable
+ *
+ *      Enable or disable the SDIO interrupt.
+ *      The driver disables the SDIO interrupt until the i/o thread can
+ *      process it.
+ *      The SDIO interrupt can be disabled by modifying the SDIO_INT_ENABLE
+ *      register in the Card Common Control Register block, but this requires
+ *      two CMD52 operations. A better solution is to mask the interrupt at
+ *      the host controller.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ *
+ *  Returns:
+ *      Zero on success or a UniFi driver error code.
+ *
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioInterruptEnable(CsrSdioFunction *function)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err = 0;
+
+#ifdef CSR_CONFIG_MMC_INT_BYPASS_KSOFTIRQD
+    sdio_unblock_card_irq(func);
+#else
+    _sdio_claim_host(func);
+    /* Write the Int Enable in CCCR block */
+#ifdef MMC_QUIRK_LENIENT_FN0
+    sdio_f0_writeb(func, 0x3, SDIO_CCCR_IENx, &err);
+#else
+    err = csr_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, 0x03, NULL);
+#endif
+    _sdio_release_host(func);
+
+    func_exit();
+    if (err) {
+        return ConvertSdioToCsrSdioResult(err);
+    }
+#endif
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioInterruptEnable() */
+
+CsrResult
+CsrSdioInterruptDisable(CsrSdioFunction *function)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err = 0;
+
+#ifdef CSR_CONFIG_MMC_INT_BYPASS_KSOFTIRQD
+    sdio_block_card_irq(func);
+#else
+    _sdio_claim_host(func);
+    /* Write the Int Enable in CCCR block */
+#ifdef MMC_QUIRK_LENIENT_FN0
+    sdio_f0_writeb(func, 0, SDIO_CCCR_IENx, &err);
+#else
+    err = csr_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, 0x00, NULL);
+#endif
+    _sdio_release_host(func);
+
+    func_exit();
+    if (err) {
+        return ConvertSdioToCsrSdioResult(err);
+    }
+#endif
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioInterruptDisable() */
+
+
+void CsrSdioInterruptAcknowledge(CsrSdioFunction *function)
+{
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioFunctionEnable
+ *
+ *      Enable i/o on function 1.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ *
+ * Returns:
+ *      UniFi driver error code.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioFunctionEnable(CsrSdioFunction *function)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err;
+
+    func_enter();
+
+    /* Enable UniFi function 1 (the 802.11 part). */
+    _sdio_claim_host(func);
+    err = sdio_enable_func(func);
+    _sdio_release_host(func);
+    if (err) {
+        unifi_error(NULL, "Failed to enable SDIO function %d\n", func->num);
+    }
+
+    func_exit();
+    return ConvertSdioToCsrSdioResult(err);
+} /* CsrSdioFunctionEnable() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioFunctionDisable
+ *
+ *      Enable i/o on function 1.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ *
+ * Returns:
+ *      UniFi driver error code.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioFunctionDisable(CsrSdioFunction *function)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int err;
+
+    func_enter();
+
+    /* Disable UniFi function 1 (the 802.11 part). */
+    _sdio_claim_host(func);
+    err = sdio_disable_func(func);
+    _sdio_release_host(func);
+    if (err) {
+        unifi_error(NULL, "Failed to disable SDIO function %d\n", func->num);
+    }
+
+    func_exit();
+    return ConvertSdioToCsrSdioResult(err);
+} /* CsrSdioFunctionDisable() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioFunctionActive
+ *
+ *      No-op as the bus goes to an active state at the start of every
+ *      command.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ * ---------------------------------------------------------------------------
+ */
+void
+CsrSdioFunctionActive(CsrSdioFunction *function)
+{
+} /* CsrSdioFunctionActive() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioFunctionIdle
+ *
+ *      Set the function as idle.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ * ---------------------------------------------------------------------------
+ */
+void
+CsrSdioFunctionIdle(CsrSdioFunction *function)
+{
+} /* CsrSdioFunctionIdle() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioPowerOn
+ *
+ *      Power on UniFi.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioPowerOn(CsrSdioFunction *function)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    struct mmc_host *host = func->card->host;
+
+    _sdio_claim_host(func);
+    if (!card_is_powered) {
+        mmc_power_restore_host(host);
+        card_is_powered = 1;
+    } else {
+        printk(KERN_INFO "SDIO: Skip power on; card is already powered.\n");
+    }
+    _sdio_release_host(func);
+#endif /* 2.6.32 */
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioPowerOn() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioPowerOff
+ *
+ *      Power off UniFi.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ * ---------------------------------------------------------------------------
+ */
+void
+CsrSdioPowerOff(CsrSdioFunction *function)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    struct mmc_host *host = func->card->host;
+
+    _sdio_claim_host(func);
+    if (card_is_powered) {
+        mmc_power_save_host(host);
+        card_is_powered = 0;
+    } else {
+        printk(KERN_INFO "SDIO: Skip power off; card is already powered off.\n");
+    }
+    _sdio_release_host(func);
+#endif /* 2.6.32 */
+} /* CsrSdioPowerOff() */
+
+
+static int
+sdio_set_block_size_ignore_first_error(struct sdio_func *func, unsigned blksz)
+{
+    int ret;
+
+    if (blksz > func->card->host->max_blk_size)
+        return -EINVAL;
+
+    if (blksz == 0) {
+        blksz = min(func->max_blksize, func->card->host->max_blk_size);
+        blksz = min(blksz, 512u);
+    }
+
+    /*
+     * Ignore -ERANGE (OUT_OF_RANGE in R5) on the first byte as
+     * the block size may be invalid until both bytes are written.
+     */
+    ret = csr_io_rw_direct(func->card, 1, 0,
+                           SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE,
+                           blksz & 0xff, NULL);
+    if (ret && ret != -ERANGE)
+        return ret;
+    ret = csr_io_rw_direct(func->card, 1, 0,
+                           SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE + 1,
+                           (blksz >> 8) & 0xff, NULL);
+    if (ret)
+        return ret;
+    func->cur_blksize = blksz;
+
+    return 0;
+}
+
+CsrResult
+CsrSdioBlockSizeSet(CsrSdioFunction *function, CsrUint16 blockSize)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int r = 0;
+
+    /* Module parameter overrides */
+    if (sdio_block_size > -1) {
+        blockSize = sdio_block_size;
+    }
+
+    unifi_trace(NULL, UDBG1, "Set SDIO function block size to %d\n",
+                blockSize);
+
+    _sdio_claim_host(func);
+    r = sdio_set_block_size(func, blockSize);
+    _sdio_release_host(func);
+
+    /*
+     * The MMC driver for kernels prior to 2.6.32 may fail this request
+     * with -ERANGE. In this case use our workaround.
+     */
+    if (r == -ERANGE) {
+        _sdio_claim_host(func);
+        r = sdio_set_block_size_ignore_first_error(func, blockSize);
+        _sdio_release_host(func);
+    }
+    if (r) {
+        unifi_error(NULL, "Error %d setting block size\n", r);
+    }
+
+    /* Determine the achieved block size to pass to the core */
+    function->blockSize = func->cur_blksize;
+
+    return ConvertSdioToCsrSdioResult(r);
+} /* CsrSdioBlockSizeSet() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioHardReset
+ *
+ *      Hard Resets UniFi is possible.
+ *
+ *  Arguments:
+ *      sdio            SDIO context pointer
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioHardReset(CsrSdioFunction *function)
+{
+    return CSR_RESULT_FAILURE;
+} /* CsrSdioHardReset() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_glue_sdio_int_handler
+ *
+ *      Interrupt callback function for SDIO interrupts.
+ *      This is called in kernel context (i.e. not interrupt context).
+ *
+ *  Arguments:
+ *      func      SDIO context pointer
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Note: Called with host already claimed.
+ * ---------------------------------------------------------------------------
+ */
+static void
+uf_glue_sdio_int_handler(struct sdio_func *func)
+{
+    CsrSdioFunction *sdio_ctx;
+    CsrSdioInterruptDsrCallback func_dsr_callback;
+    int r;
+
+    sdio_ctx = sdio_get_drvdata(func);
+    if (!sdio_ctx) {
+        return;
+    }
+#ifndef CSR_CONFIG_MMC_INT_BYPASS_KSOFTIRQD
+    /*
+     * Normally, we are not allowed to do any SDIO commands here.
+     * However, this is called in a thread context and with the SDIO lock
+     * so we disable the interrupts here instead of trying to do complicated
+     * things with the SDIO lock.
+     */
+#ifdef MMC_QUIRK_LENIENT_FN0
+    sdio_f0_writeb(func, 0, SDIO_CCCR_IENx, &r);
+#else
+    r = csr_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, 0x00, NULL);
+#endif
+    if (r) {
+        printk(KERN_ERR "UniFi MMC Int handler: Failed to disable interrupts\n");
+    }
+#endif
+
+    /* If the function driver has registered a handler, call it */
+    if (sdio_func_drv && sdio_func_drv->intr) {
+
+        func_dsr_callback = sdio_func_drv->intr(sdio_ctx);
+
+        /* If interrupt handle returns a DSR handle, call it */
+        if (func_dsr_callback) {
+            func_dsr_callback(sdio_ctx);
+        }
+    }
+
+} /* uf_glue_sdio_int_handler() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  csr_sdio_linux_remove_irq
+ *
+ *      Unregister the interrupt handler.
+ *      This means that the linux layer can not process interrupts any more.
+ *
+ *  Arguments:
+ *      sdio      SDIO context pointer
+ *
+ *  Returns:
+ *      Status of the removal.
+ * ---------------------------------------------------------------------------
+ */
+int
+csr_sdio_linux_remove_irq(CsrSdioFunction *function)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int r;
+
+    sdio_claim_host(func);
+    r = sdio_release_irq(func);
+    sdio_release_host(func);
+
+    return r;
+
+} /* csr_sdio_linux_remove_irq() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  csr_sdio_linux_install_irq
+ *
+ *      Register the interrupt handler.
+ *      This means that the linux layer can process interrupts.
+ *
+ *  Arguments:
+ *      sdio      SDIO context pointer
+ *
+ *  Returns:
+ *      Status of the removal.
+ * ---------------------------------------------------------------------------
+ */
+int
+csr_sdio_linux_install_irq(CsrSdioFunction *function)
+{
+    struct sdio_func *func = (struct sdio_func *)function->priv;
+    int r;
+
+    /* Register our interrupt handle */
+    sdio_claim_host(func);
+    r = sdio_claim_irq(func, uf_glue_sdio_int_handler);
+    sdio_release_host(func);
+
+    /* If the interrupt was installed earlier, is fine */
+    if (r == -EBUSY) {
+        r = 0;
+    }
+
+    return r;
+} /* csr_sdio_linux_install_irq() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_glue_sdio_probe
+ *
+ *      Card insert callback.
+ *
+ * Arguments:
+ *      func            Our (glue layer) context pointer.
+ *
+ * Returns:
+ *      UniFi driver error code.
+ * ---------------------------------------------------------------------------
+ */
+static int
+uf_glue_sdio_probe(struct sdio_func *func,
+                   const struct sdio_device_id *id)
+{
+    int instance;
+    CsrSdioFunction *sdio_ctx;
+
+    func_enter();
+
+    /* First of all claim the SDIO driver */
+    sdio_claim_host(func);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+    /* Assume that the card is already powered */
+    card_is_powered = 1;
+#endif
+
+    /* Assumes one card per host, which is true for SDIO */
+    instance = func->card->host->index;
+    printk("sdio bus_id: %16s - UniFi card 0x%X inserted\n",
+           sdio_func_id(func), instance);
+
+    /* Allocate context */
+    sdio_ctx = (CsrSdioFunction *)kmalloc(sizeof(CsrSdioFunction),
+                                          GFP_KERNEL);
+    if (sdio_ctx == NULL) {
+        sdio_release_host(func);
+        return -ENOMEM;
+    }
+
+    /* Initialise the context */
+    sdio_ctx->sdioId.manfId  = func->vendor;
+    sdio_ctx->sdioId.cardId  = func->device;
+    sdio_ctx->sdioId.sdioFunction  = func->num;
+    sdio_ctx->sdioId.sdioInterface = func->class;
+    sdio_ctx->blockSize = func->cur_blksize;
+    sdio_ctx->priv = (void *)func;
+    sdio_ctx->features = 0;
+
+    /* Module parameter enables byte mode */
+    if (sdio_byte_mode) {
+        sdio_ctx->features |= CSR_SDIO_FEATURE_BYTE_MODE;
+    }
+
+#ifdef MMC_QUIRK_LENIENT_FN0
+    func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
+#endif
+
+    /* Pass context to the SDIO driver */
+    sdio_set_drvdata(func, sdio_ctx);
+
+    /* Register this device with the SDIO function driver */
+    /* Call the main UniFi driver inserted handler */
+    if (sdio_func_drv && sdio_func_drv->inserted) {
+        uf_add_os_device(instance, &func->dev);
+        sdio_func_drv->inserted(sdio_ctx);
+    }
+
+    /* We have finished, so release the SDIO driver */
+    sdio_release_host(func);
+
+    func_exit();
+    return 0;
+} /* uf_glue_sdio_probe() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_glue_sdio_remove
+ *
+ *      Card removal callback.
+ *
+ * Arguments:
+ *      func            Our (glue layer) context pointer.
+ *
+ * Returns:
+ *      UniFi driver error code.
+ * ---------------------------------------------------------------------------
+ */
+static void
+uf_glue_sdio_remove(struct sdio_func *func)
+{
+    CsrSdioFunction *sdio_ctx;
+
+    sdio_ctx = sdio_get_drvdata(func);
+    if (!sdio_ctx) {
+        return;
+    }
+
+    func_enter();
+
+    unifi_info(NULL, "UniFi card removed\n");
+
+    /* Clean up the SDIO function driver */
+    if (sdio_func_drv && sdio_func_drv->removed) {
+        uf_remove_os_device(func->card->host->index);
+        sdio_func_drv->removed(sdio_ctx);
+    }
+
+    kfree(sdio_ctx);
+
+    func_exit();
+
+} /* uf_glue_sdio_remove */
+
+
+/*
+ * SDIO ids *must* be statically declared, so we can't take
+ * them from the list passed in csr_sdio_register_driver().
+ */
+static const struct sdio_device_id unifi_ids[] = {
+    { SDIO_DEVICE(SDIO_MANF_ID_CSR,SDIO_CARD_ID_UNIFI_3) },
+    { SDIO_DEVICE(SDIO_MANF_ID_CSR,SDIO_CARD_ID_UNIFI_4) },
+    { /* end: all zeroes */				},
+};
+
+MODULE_DEVICE_TABLE(sdio, unifi_ids);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#ifdef CONFIG_PM
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_glue_sdio_suspend
+ *
+ *      Card suspend callback.
+ *
+ * Arguments:
+ *      dev            The struct device owned by the MMC driver
+ *
+ * Returns:
+ *      None
+ * ---------------------------------------------------------------------------
+ */
+static int
+uf_glue_sdio_suspend(struct device *dev)
+{
+    struct sdio_func *func;
+    CsrSdioFunction *sdio_ctx;
+
+    func_enter();
+
+    func = dev_to_sdio_func(dev);
+    WARN_ON(!func);
+
+    sdio_ctx = sdio_get_drvdata(func);
+    WARN_ON(!sdio_ctx);
+
+    unifi_trace(NULL, UDBG1, "System Suspend...\n");
+
+    /* Clean up the SDIO function driver */
+    if (sdio_func_drv && sdio_func_drv->suspend) {
+        sdio_func_drv->suspend(sdio_ctx);
+    }
+
+    func_exit();
+    return 0;
+} /* uf_glue_sdio_suspend */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_glue_sdio_resume
+ *
+ *      Card resume callback.
+ *
+ * Arguments:
+ *      dev            The struct device owned by the MMC driver
+ *
+ * Returns:
+ *      None
+ * ---------------------------------------------------------------------------
+ */
+static int
+uf_glue_sdio_resume(struct device *dev)
+{
+    struct sdio_func *func;
+    CsrSdioFunction *sdio_ctx;
+
+    func_enter();
+
+    func = dev_to_sdio_func(dev);
+    WARN_ON(!func);
+
+    sdio_ctx = sdio_get_drvdata(func);
+    WARN_ON(!sdio_ctx);
+
+    unifi_trace(NULL, UDBG1, "System Resume...\n");
+
+    /* Clean up the SDIO function driver */
+    if (sdio_func_drv && sdio_func_drv->resume) {
+        sdio_func_drv->resume(sdio_ctx);
+    }
+
+    func_exit();
+    return 0;
+
+} /* uf_glue_sdio_resume */
+
+static struct dev_pm_ops unifi_pm_ops = {
+    .suspend = uf_glue_sdio_suspend,
+    .resume  = uf_glue_sdio_resume,
+};
+
+#define UNIFI_PM_OPS  (&unifi_pm_ops)
+
+#else
+
+#define UNIFI_PM_OPS  NULL
+
+#endif /* CONFIG_PM */
+#endif /* 2.6.32 */
+
+static struct sdio_driver unifi_driver = {
+    .probe      = uf_glue_sdio_probe,
+    .remove     = uf_glue_sdio_remove,
+    .name       = "unifi",
+    .id_table	= unifi_ids,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+    .drv.pm     = UNIFI_PM_OPS,
+#endif /* 2.6.32 */
+};
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  CsrSdioFunctionDriverRegister
+ *  CsrSdioFunctionDriverUnregister
+ *
+ *      These functions are called from the main module load and unload
+ *      functions. They perform the appropriate operations for the
+ *      linux MMC/SDIO driver.
+ *
+ *  Arguments:
+ *      sdio_drv    Pointer to the function driver's SDIO structure.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+CsrResult
+CsrSdioFunctionDriverRegister(CsrSdioFunctionDriver *sdio_drv)
+{
+    int r;
+
+    printk("UniFi: Using native Linux MMC driver for SDIO.\n");
+
+    if (sdio_func_drv) {
+        unifi_error(NULL, "sdio_mmc: UniFi driver already registered\n");
+        return CSR_SDIO_RESULT_INVALID_VALUE;
+    }
+
+    /* Save the registered driver description */
+    /*
+     * FIXME:
+     * Need a table here to handle a call to register for just one function.
+     * mmc only allows us to register for the whole device
+     */
+    sdio_func_drv = sdio_drv;
+
+    /* Register ourself with mmc_core */
+    r = sdio_register_driver(&unifi_driver);
+    if (r) {
+        printk(KERN_ERR "unifi_sdio: Failed to register UniFi SDIO driver: %d\n", r);
+        return ConvertSdioToCsrSdioResult(r);
+    }
+
+    return CSR_RESULT_SUCCESS;
+} /* CsrSdioFunctionDriverRegister() */
+
+
+
+void
+CsrSdioFunctionDriverUnregister(CsrSdioFunctionDriver *sdio_drv)
+{
+    printk(KERN_INFO "UniFi: unregister from MMC sdio\n");
+    sdio_unregister_driver(&unifi_driver);
+
+    sdio_func_drv = NULL;
+
+} /* CsrSdioFunctionDriverUnregister() */
+
--- /dev/null
+++ b/drivers/staging/csr/sdio_stubs.c
@@ -0,0 +1,82 @@
+/*
+ * Stubs for some of the bottom edge functions.
+ *
+ * These stubs are optional functions in the bottom edge (SDIO driver
+ * interface) API that not all platforms or SDIO drivers may support.
+ *
+ * They're declared as weak symbols so they can be overridden by
+ * simply providing a non-weak declaration.
+ *
+ * Copyright (C) 2007-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ */
+#include "csr_wifi_hip_unifi.h"
+
+void __attribute__((weak)) CsrSdioFunctionIdle(CsrSdioFunction *function)
+{
+}
+
+void __attribute__((weak)) CsrSdioFunctionActive(CsrSdioFunction *function)
+{
+}
+
+CsrResult __attribute__((weak)) CsrSdioPowerOn(CsrSdioFunction *function)
+{
+    return CSR_RESULT_SUCCESS;
+}
+
+void __attribute__((weak)) CsrSdioPowerOff(CsrSdioFunction *function)
+{
+}
+
+CsrResult __attribute__((weak)) CsrSdioHardReset(CsrSdioFunction *function)
+{
+    return CSR_SDIO_RESULT_NOT_RESET;
+}
+
+CsrResult __attribute__((weak)) CsrSdioBlockSizeSet(CsrSdioFunction *function,
+                                                   CsrUint16 blockSize)
+{
+    return CSR_RESULT_SUCCESS;
+}
+
+CsrResult __attribute__((weak)) CsrSdioSuspend(CsrSdioFunction *function)
+{
+    return CSR_RESULT_SUCCESS;
+}
+
+CsrResult __attribute__((weak)) CsrSdioResume(CsrSdioFunction *function)
+{
+    return CSR_RESULT_SUCCESS;
+}
+
+int __attribute__((weak)) csr_sdio_linux_install_irq(CsrSdioFunction *function)
+{
+    return 0;
+}
+
+int __attribute__((weak)) csr_sdio_linux_remove_irq(CsrSdioFunction *function)
+{
+    return 0;
+}
+
+void __attribute__((weak)) CsrSdioInsertedAcknowledge(CsrSdioFunction *function, CsrResult result)
+{
+}
+
+void __attribute__((weak)) CsrSdioRemovedAcknowledge(CsrSdioFunction *function)
+{
+}
+
+void __attribute__((weak)) CsrSdioSuspendAcknowledge(CsrSdioFunction *function, CsrResult result)
+{
+}
+
+void __attribute__((weak)) CsrSdioResumeAcknowledge(CsrSdioFunction *function, CsrResult result)
+{
+}
+
+
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/cspi.h
@@ -0,0 +1,62 @@
+/*
+ * CSPI definitions.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef SDIOEMB_CSPI_H
+#define SDIOEMB_CSPI_H
+
+/**
+ * @addtogroup sdriver
+ *@{*/
+
+#define CSPI_FUNC(f) (f)
+#define CSPI_READ    0x10
+#define CSPI_WRITE   0x20
+#define CSPI_BURST   0x40
+#define CSPI_TYPE_MASK 0x70
+
+/**
+ * CSPI_MODE function 0 register.
+ *
+ * Various CSPI mode settings.
+ *
+ * @see CSPI specification (CS-110124-SP)
+ */
+#define CSPI_MODE 0xf7
+#  define CSPI_MODE_PADDED_WRITE_HDRS      (1 << 7)
+#  define CSPI_MODE_PADDED_READ_HDRS       (1 << 6)
+/**
+ * BigEndianRegisters bit of \ref CSPI_MODE -- enable big-endian CSPI
+ * register reads and writes.
+ *
+ * @warning This bit should never be set as it's not possible to use
+ * this mode without knowledge of which registers are 8 bit and which
+ * are 16 bit.
+ */
+#  define CSPI_MODE_BE_REG                 (1 << 5)
+#  define CSPI_MODE_BE_BURST               (1 << 4)
+#  define CSPI_MODE_INT_ACTIVE_HIGH        (1 << 3)
+#  define CSPI_MODE_INT_ON_ERR             (1 << 2)
+#  define CSPI_MODE_LEN_FIELD_PRESENT      (1 << 1)
+#  define CSPI_MODE_DRV_MISO_ON_RISING_CLK (1 << 0)
+
+#define CSPI_STATUS 0xf8
+
+#define CSPI_PADDING 0xf9
+#  define CSPI_PADDING_REG(p)   ((p) << 0)
+#  define CSPI_PADDING_BURST(p) ((p) << 4)
+
+#define CSPI_PADDING_MAX       15
+#define CSPI_PADDING_REG_DFLT   0
+#define CSPI_PADDING_BURST_DFLT 2
+
+/* cmd byte, 3 byte addr, padding, error byte, data word */
+#define CSPI_REG_TRANSFER_LEN (1 + 3 + CSPI_PADDING_MAX + 1 + 2)
+
+/*@}*/
+
+#endif /* #ifndef SDIOEMB_CSPI_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/csr_result.h
@@ -0,0 +1,16 @@
+/*
+ * Synergy compatible API -- common result codes.
+ *
+ * Copyright (C) 2010 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef CSR_RESULT_H__
+#define CSR_RESULT_H__
+
+typedef CsrUint16 CsrResult;
+#define CSR_RESULT_SUCCESS ((CsrResult) 0x0000)
+#define CSR_RESULT_FAILURE ((CsrResult) 0xffff)
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/csr_sdio.h
@@ -0,0 +1,711 @@
+/*
+ * Synergy compatible API -- SDIO.
+ *
+ * Copyright (C) 2010 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef CSR_SDIO_H__
+#define CSR_SDIO_H__
+
+#include "csr_types.h"
+#include "csr_result.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Result Codes */
+#define CSR_SDIO_RESULT_INVALID_VALUE   ((CsrResult) 1) /* Invalid argument value */
+#define CSR_SDIO_RESULT_NO_DEVICE       ((CsrResult) 2) /* The specified device is no longer present */
+#define CSR_SDIO_RESULT_CRC_ERROR       ((CsrResult) 3) /* The transmitted/received data or command response contained a CRC error */
+#define CSR_SDIO_RESULT_TIMEOUT         ((CsrResult) 4) /* No command response or data received from device, or function enable/disable did not succeed within timeout period */
+#define CSR_SDIO_RESULT_NOT_RESET       ((CsrResult) 5) /* The device was not reset */
+
+/* Features (for use in features member of CsrSdioFunction) */
+#define CSR_SDIO_FEATURE_BYTE_MODE                   0x00000001 /* Transfer sizes do not have to be a multiple of block size */
+#define CSR_SDIO_FEATURE_DMA_CAPABLE_MEM_REQUIRED    0x00000002 /* Bulk operations require DMA friendly memory */
+
+/* CsrSdioFunctionId wildcards (for use in CsrSdioFunctionId members) */
+#define CSR_SDIO_ANY_MANF_ID        0xFFFF
+#define CSR_SDIO_ANY_CARD_ID        0xFFFF
+#define CSR_SDIO_ANY_SDIO_FUNCTION  0xFF
+#define CSR_SDIO_ANY_SDIO_INTERFACE 0xFF
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionId
+ *
+ *  DESCRIPTION
+ *      This structure describes one or more functions of a device, based on
+ *      four qualitative measures. The CsrSdioFunctionId wildcard defines can be
+ *      used for making the CsrSdioFunctionId match more than one function.
+ *
+ *  MEMBERS
+ *      manfId - Vendor ID (or CSR_SDIO_ANY_MANF_ID).
+ *      cardId - Device ID (or CSR_SDIO_ANY_CARD_ID).
+ *      sdioFunction - SDIO Function number (or CSR_SDIO_ANY_SDIO_FUNCTION).
+ *      sdioInterface - SDIO Standard Interface Code (or CSR_SDIO_ANY_SDIO_INTERFACE)
+ *
+ *----------------------------------------------------------------------------*/
+typedef struct
+{
+    CsrUint16 manfId;       /* Vendor ID to match or CSR_SDIO_ANY_MANF_ID */
+    CsrUint16 cardId;       /* Device ID to match or CSR_SDIO_ANY_CARD_ID */
+    CsrUint8 sdioFunction;  /* SDIO Function number to match or CSR_SDIO_ANY_SDIO_FUNCTION */
+    CsrUint8 sdioInterface; /* SDIO Standard Interface Code to match or CSR_SDIO_ANY_SDIO_INTERFACE */
+} CsrSdioFunctionId;
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunction
+ *
+ *  DESCRIPTION
+ *      This structure represents a single function on a device.
+ *
+ *  MEMBERS
+ *      sdioId - A CsrSdioFunctionId describing this particular function. The
+ *               subfield shall not contain any CsrSdioFunctionId wildcards. The
+ *               subfields shall describe the specific single function
+ *               represented by this structure.
+ *      blockSize - Actual configured block size, or 0 if unconfigured.
+ *      features - Bit mask with any of CSR_SDIO_FEATURE_* set.
+ *      driverData - For use by the Function Driver. The SDIO Driver shall not
+ *                   attempt to dereference the pointer.
+ *      priv - For use by the SDIO Driver. The Function Driver shall not attempt
+ *             to dereference the pointer.
+ *
+ *----------------------------------------------------------------------------*/
+typedef struct
+{
+    CsrSdioFunctionId sdioId;
+    CsrUint16 blockSize;    /* Actual configured block size, or 0 if unconfigured */
+    CsrUint32 features;     /* Bit mask with any of CSR_SDIO_FEATURE_* set */
+    void *cardHandle;       /* An opaque handle for this function's card. */
+    void *osDevice;
+    void *driverData;       /* For use by the Function Driver */
+    void *priv;             /* For use by the SDIO Driver */
+} CsrSdioFunction;
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioInsertedCallback, CsrSdioRemovedCallback
+ *
+ *  DESCRIPTION
+ *      CsrSdioInsertedCallback is called when a function becomes available to
+ *      a registered Function Driver that supports the function.
+ *      CsrSdioRemovedCallback is called when a function is no longer available
+ *      to a Function Driver, either because the device has been removed, or the
+ *      Function Driver has been unregistered.
+ *
+ *      NOTE: These functions are implemented by the Function Driver, and are
+ *            passed as function pointers in the CsrSdioFunctionDriver struct.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *----------------------------------------------------------------------------*/
+typedef void (*CsrSdioInsertedCallback)(CsrSdioFunction *function);
+typedef void (*CsrSdioRemovedCallback)(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioInterruptDsrCallback, CsrSdioInterruptCallback
+ *
+ *  DESCRIPTION
+ *      CsrSdioInterruptCallback is called when an interrupt occurs on the
+ *      the device associated with the specified function.
+ *
+ *      NOTE: These functions are implemented by the Function Driver, and are
+ *            passed as function pointers in the CsrSdioFunctionDriver struct.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *  RETURNS (only CsrSdioInterruptCallback)
+ *      A pointer to a CsrSdioInterruptDsrCallback function.
+ *
+ *----------------------------------------------------------------------------*/
+typedef void (*CsrSdioInterruptDsrCallback)(CsrSdioFunction *function);
+typedef CsrSdioInterruptDsrCallback (*CsrSdioInterruptCallback)(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioSuspendCallback, CsrSdioResumeCallback
+ *
+ *  DESCRIPTION
+ *      CsrSdioSuspendCallback is called when the system is preparing to go
+ *      into a suspended state. CsrSdioResumeCallback is called when the system
+ *      has entered an active state again.
+ *
+ *      NOTE: These functions are implemented by the Function Driver, and are
+ *            passed as function pointers in the CsrSdioFunctionDriver struct.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *----------------------------------------------------------------------------*/
+typedef void (*CsrSdioSuspendCallback)(CsrSdioFunction *function);
+typedef void (*CsrSdioResumeCallback)(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioAsyncCallback, CsrSdioAsyncDsrCallback
+ *
+ *  DESCRIPTION
+ *      CsrSdioAsyncCallback is called when an asynchronous operation completes.
+ *
+ *      NOTE: These functions are implemented by the Function Driver, and are
+ *            passed as function pointers in the function calls that initiate
+ *            the operation.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      result - The result of the operation that completed. See the description
+ *               of the initiating function for possible result values.
+ *
+ *  RETURNS (only CsrSdioAsyncCallback)
+ *      A pointer to a CsrSdioAsyncDsrCallback function.
+ *
+ *----------------------------------------------------------------------------*/
+typedef void (*CsrSdioAsyncDsrCallback)(CsrSdioFunction *function, CsrResult result);
+typedef CsrSdioAsyncDsrCallback (*CsrSdioAsyncCallback)(CsrSdioFunction *function, CsrResult result);
+
+typedef struct
+{
+    CsrSdioInsertedCallback     inserted;
+    CsrSdioRemovedCallback      removed;
+    CsrSdioInterruptCallback    intr;
+    CsrSdioSuspendCallback      suspend;
+    CsrSdioResumeCallback       resume;
+    CsrSdioFunctionId           *ids;
+    CsrUint8                    idsCount;
+    void                        *priv;
+} CsrSdioFunctionDriver;
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionDriverRegister
+ *
+ *  DESCRIPTION
+ *      Register a Function Driver.
+ *
+ *  PARAMETERS
+ *      functionDriver - Pointer to struct describing the Function Driver.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The Function Driver was successfully
+ *                           registered.
+ *      CSR_RESULT_FAILURE - Unable to register the function driver,
+ *                                because of an unspecified/unknown error. The
+ *                                Function Driver has not been registered.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - The specified Function Driver pointer
+ *                                      does not point at a valid Function
+ *                                      Driver structure, or some of the members
+ *                                      contain invalid entries.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioFunctionDriverRegister(CsrSdioFunctionDriver *functionDriver);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionDriverUnregister
+ *
+ *  DESCRIPTION
+ *      Unregister a previously registered Function Driver.
+ *
+ *  PARAMETERS
+ *      functionDriver - pointer to struct describing the Function Driver.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSdioFunctionDriverUnregister(CsrSdioFunctionDriver *functionDriver);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionEnable, CsrSdioFunctionDisable
+ *
+ *  DESCRIPTION
+ *      Enable/disable the specified function by setting/clearing the
+ *      corresponding bit in the I/O Enable register in function 0, and then
+ *      periodically reading the related bit in the I/O Ready register until it
+ *      is set/clear, limited by an implementation defined timeout.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The specified function was enabled/disabled.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. The state of the
+ *                                  related bit in the I/O Enable register is
+ *                                  undefined.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device, or the related
+ *                                bit in the I/O ready register was not
+ *                                set/cleared within the timeout period.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioFunctionEnable(CsrSdioFunction *function);
+CsrResult CsrSdioFunctionDisable(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioInterruptEnable, CsrSdioInterruptDisable
+ *
+ *  DESCRIPTION
+ *      Enable/disable the interrupt for the specified function by
+ *      setting/clearing the corresponding bit in the INT Enable register in
+ *      function 0.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The specified function was enabled/disabled.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. The state of the
+ *                                  related bit in the INT Enable register is
+ *                                  unchanged.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - The specified function cannot be
+ *                                      enabled/disabled, because it either
+ *                                      does not exist or it is not possible to
+ *                                      individually enable/disable functions.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioInterruptEnable(CsrSdioFunction *function);
+CsrResult CsrSdioInterruptDisable(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioInterruptAcknowledge
+ *
+ *  DESCRIPTION
+ *      Acknowledge that a signalled interrupt has been handled. Shall only
+ *      be called once, and exactly once for each signalled interrupt to the
+ *      corresponding function.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function to which the
+ *                 event was signalled.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSdioInterruptAcknowledge(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioInsertedAcknowledge, CsrSdioRemovedAcknowledge
+ *
+ *  DESCRIPTION
+ *      Acknowledge that a signalled inserted/removed event has been handled.
+ *      Shall only be called once, and exactly once for each signalled event to
+ *      the corresponding function.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function to which the
+ *                 inserted was signalled.
+ *      result (CsrSdioInsertedAcknowledge only)
+ *          CSR_RESULT_SUCCESS - The Function Driver has accepted the
+ *                                    function, and the function is attached to
+ *                                    the Function Driver until the
+ *                                    CsrSdioRemovedCallback is called and
+ *                                    acknowledged.
+ *          CSR_RESULT_FAILURE - Unable to accept the function. The
+ *                                    function is not attached to the Function
+ *                                    Driver, and it may be passed to another
+ *                                    Function Driver which supports the
+ *                                    function.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSdioInsertedAcknowledge(CsrSdioFunction *function, CsrResult result);
+void CsrSdioRemovedAcknowledge(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioSuspendAcknowledge, CsrSdioResumeAcknowledge
+ *
+ *  DESCRIPTION
+ *      Acknowledge that a signalled suspend event has been handled. Shall only
+ *      be called once, and exactly once for each signalled event to the
+ *      corresponding function.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function to which the
+ *                 event was signalled.
+ *      result
+ *          CSR_RESULT_SUCCESS - Successfully suspended/resumed.
+ *          CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSdioSuspendAcknowledge(CsrSdioFunction *function, CsrResult result);
+void CsrSdioResumeAcknowledge(CsrSdioFunction *function, CsrResult result);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioBlockSizeSet
+ *
+ *  DESCRIPTION
+ *      Set the block size to use for the function. The actual configured block
+ *      size shall be the minimum of:
+ *          1) Maximum block size supported by the function.
+ *          2) Maximum block size supported by the host controller.
+ *          3) The block size specified by the blockSize argument.
+ *
+ *      When this function returns, the actual configured block size is
+ *      available in the blockSize member of the function struct.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      blockSize - Block size to use for the function. Valid range is 1 to
+ *                  2048.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The block size register on the chip
+ *                                was updated.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. The configured block
+ *                                  size is undefined.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and the FUNCTION_NUMBER
+ *            bits is set, CSR_SDIO_RESULT_INVALID_VALUE shall be returned.
+ *            If the ERROR bit is set (but not FUNCTION_NUMBER),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *      NOTE: Setting the block size requires two individual operations. The
+ *            implementation shall ignore the OUT_OF_RANGE bit of the SDIO R5
+ *            response for the first operation, as the partially configured
+ *            block size may be out of range, even if the final block size
+ *            (after the second operation) is in the valid range.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioBlockSizeSet(CsrSdioFunction *function, CsrUint16 blockSize);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioMaxBusClockFrequencySet
+ *
+ *  DESCRIPTION
+ *      Set the maximum clock frequency to use for the device associated with
+ *      the specified function. The actual configured clock frequency for the
+ *      device shall be the minimum of:
+ *          1) Maximum clock frequency supported by the device.
+ *          2) Maximum clock frequency supported by the host controller.
+ *          3) Maximum clock frequency specified for any function on the same
+ *             device.
+ *
+ *      If the clock frequency exceeds 25MHz, it is the responsibility of the
+ *      SDIO driver to enable high speed mode on the device, using the standard
+ *      defined procedure, before increasing the frequency beyond the limit.
+ *
+ *      Note that the clock frequency configured affects all functions on the
+ *      same device.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      maxFrequency - The maximum clock frequency for the function in Hertz.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The maximum clock frequency was succesfully
+ *                                set for the function.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *
+ *      NOTE: If the SDIO R5 response is available, and the FUNCTION_NUMBER
+ *            bits is set, CSR_SDIO_RESULT_INVALID_VALUE shall be returned.
+ *            If the ERROR bit is set (but not FUNCTION_NUMBER),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioMaxBusClockFrequencySet(CsrSdioFunction *function, CsrUint32 maxFrequency);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioRead8, CsrSdioWrite8, CsrSdioRead8Async, CsrSdioWrite8Async
+ *
+ *  DESCRIPTION
+ *      Read/write an 8bit value from/to the specified register address.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      address - Register address within the function.
+ *      data - The data to read/write.
+ *      callback - The function to call on operation completion.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The data was successfully read/written.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. No data read/written.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *      NOTE: The CsrSdioRead8Async and CsrSdioWrite8Async functions return
+ *            immediately, and the supplied callback function is called when the
+ *            operation is complete. The result value is given as an argument to
+ *            the callback function.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioRead8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data);
+CsrResult CsrSdioWrite8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data);
+void CsrSdioRead8Async(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data, CsrSdioAsyncCallback callback);
+void CsrSdioWrite8Async(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data, CsrSdioAsyncCallback callback);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioRead16, CsrSdioWrite16, CsrSdioRead16Async, CsrSdioWrite16Async
+ *
+ *  DESCRIPTION
+ *      Read/write a 16bit value from/to the specified register address.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      address - Register address within the function.
+ *      data - The data to read/write.
+ *      callback - The function to call on operation completion.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The data was successfully read/written.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. Data may have been
+ *                                  partially read/written.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *      NOTE: The CsrSdioRead16Async and CsrSdioWrite16Async functions return
+ *            immediately, and the supplied callback function is called when the
+ *            operation is complete. The result value is given as an argument to
+ *            the callback function.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioRead16(CsrSdioFunction *function, CsrUint32 address, CsrUint16 *data);
+CsrResult CsrSdioWrite16(CsrSdioFunction *function, CsrUint32 address, CsrUint16 data);
+void CsrSdioRead16Async(CsrSdioFunction *function, CsrUint32 address, CsrUint16 *data, CsrSdioAsyncCallback callback);
+void CsrSdioWrite16Async(CsrSdioFunction *function, CsrUint32 address, CsrUint16 data, CsrSdioAsyncCallback callback);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioF0Read8, CsrSdioF0Write8, CsrSdioF0Read8Async,
+ *      CsrSdioF0Write8Async
+ *
+ *  DESCRIPTION
+ *      Read/write an 8bit value from/to the specified register address in
+ *      function 0.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      address - Register address within the function.
+ *      data - The data to read/write.
+ *      callback - The function to call on operation completion.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The data was successfully read/written.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. No data read/written.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *      NOTE: The CsrSdioF0Read8Async and CsrSdioF0Write8Async functions return
+ *            immediately, and the supplied callback function is called when the
+ *            operation is complete. The result value is given as an argument to
+ *            the callback function.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioF0Read8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data);
+CsrResult CsrSdioF0Write8(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data);
+void CsrSdioF0Read8Async(CsrSdioFunction *function, CsrUint32 address, CsrUint8 *data, CsrSdioAsyncCallback callback);
+void CsrSdioF0Write8Async(CsrSdioFunction *function, CsrUint32 address, CsrUint8 data, CsrSdioAsyncCallback callback);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioRead, CsrSdioWrite, CsrSdioReadAsync, CsrSdioWriteAsync
+ *
+ *  DESCRIPTION
+ *      Read/write a specified number of bytes from/to the specified register
+ *      address.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *      address - Register address within the function.
+ *      data - The data to read/write.
+ *      length - Number of byte to read/write.
+ *      callback - The function to call on operation completion.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - The data was successfully read/written.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_INVALID_VALUE - One or more arguments were invalid.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured. Data may have been
+ *                                  partially read/written.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device.
+ *
+ *      NOTE: If the SDIO R5 response is available, and either of the
+ *            FUNCTION_NUMBER or OUT_OF_RANGE bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE shall be returned. If the ERROR bit
+ *            is set (but none of FUNCTION_NUMBER or OUT_OF_RANGE),
+ *            CSR_RESULT_FAILURE shall be returned. The ILLEGAL_COMMAND and
+ *            COM_CRC_ERROR bits shall be ignored.
+ *
+ *            If the CSPI response is available, and any of the
+ *            FUNCTION_DISABLED or CLOCK_DISABLED bits are set,
+ *            CSR_SDIO_RESULT_INVALID_VALUE will be returned.
+ *
+ *      NOTE: The CsrSdioF0Read8Async and CsrSdioF0Write8Async functions return
+ *            immediately, and the supplied callback function is called when the
+ *            operation is complete. The result value is given as an argument to
+ *            the callback function.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioRead(CsrSdioFunction *function, CsrUint32 address, void *data, CsrUint32 length);
+CsrResult CsrSdioWrite(CsrSdioFunction *function, CsrUint32 address, const void *data, CsrUint32 length);
+void CsrSdioReadAsync(CsrSdioFunction *function, CsrUint32 address, void *data, CsrUint32 length, CsrSdioAsyncCallback callback);
+void CsrSdioWriteAsync(CsrSdioFunction *function, CsrUint32 address, const void *data, CsrUint32 length, CsrSdioAsyncCallback callback);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioPowerOn, CsrSdioPowerOff
+ *
+ *  DESCRIPTION
+ *      Power on/off the device.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function that resides on
+ *                 the device to power on/off.
+ *
+ *  RETURNS (only CsrSdioPowerOn)
+ *      CSR_RESULT_SUCCESS - Power was succesfully reapplied and the device
+ *                                has been reinitialised.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured during reinitialisation.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device during
+ *                                reinitialisation.
+ *      CSR_SDIO_RESULT_NOT_RESET - The power was not removed by the
+ *                                  CsrSdioPowerOff call. The state of the
+ *                                  device is unchanged.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioPowerOn(CsrSdioFunction *function);
+void CsrSdioPowerOff(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioHardReset
+ *
+ *  DESCRIPTION
+ *      Perform a hardware reset of the device.
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function that resides on
+ *                 the device to hard reset.
+ *
+ *  RETURNS
+ *      CSR_RESULT_SUCCESS - Reset was succesfully performed and the device
+ *                                has been reinitialised.
+ *      CSR_RESULT_FAILURE - Unspecified/unknown error.
+ *      CSR_SDIO_RESULT_NO_DEVICE - The device does not exist anymore.
+ *      CSR_SDIO_RESULT_CRC_ERROR - A CRC error occured during reinitialisation.
+ *      CSR_SDIO_RESULT_TIMEOUT - No response from the device during
+ *                                reinitialisation.
+ *      CSR_SDIO_RESULT_NOT_RESET - The reset was not applied because it is not
+ *                                  supported. The state of the device is
+ *                                  unchanged.
+ *
+ *----------------------------------------------------------------------------*/
+CsrResult CsrSdioHardReset(CsrSdioFunction *function);
+
+/*----------------------------------------------------------------------------*
+ *  NAME
+ *      CsrSdioFunctionActive, CsrSdioFunctionIdle
+ *
+ *  DESCRIPTION
+ *
+ *  PARAMETERS
+ *      function - Pointer to struct representing the function.
+ *
+ *----------------------------------------------------------------------------*/
+void CsrSdioFunctionActive(CsrSdioFunction *function);
+void CsrSdioFunctionIdle(CsrSdioFunction *function);
+
+void CsrSdioCallbackInhibitEnter(CsrSdioFunction *function);
+void CsrSdioCallbackInhibitLeave(CsrSdioFunction *function);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/csr_sdio_lib.h
@@ -0,0 +1,30 @@
+/*
+ * Synergy compatible API -- SDIO utility library.
+ *
+ * Copyright (C) 2010 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef CSR_SDIO_LIB_H__
+#define CSR_SDIO_LIB_H__
+
+#include <csr_sdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+CsrResult CsrSdioFunctionReenable(CsrSdioFunction *function);
+
+typedef int CsrStatus; /* platform specific */
+#define CSR_STATUS_FAILURE(status) ((status) < 0) /* platform specific */
+
+CsrResult CsrSdioStatusToResult(CsrStatus status);
+CsrStatus CsrSdioResultToStatus(CsrResult result);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* #ifndef CSR_SDIO_LIB_H__ */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/csr_sdio_wdf.h
@@ -0,0 +1,22 @@
+/*
+ * Synergy compatible API -- helpers for Windows Driver Framework drivers.
+ *
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef CSR_SDIO_WDF_H__
+#define CSR_SDIO_WDF_H__
+
+#include <wdf.h>
+
+NTSTATUS CsrSdioWdfDeviceInit(WDFDEVICE device);
+void CsrSdioWdfDeviceCleanup(WDFDEVICE device);
+
+NTSTATUS CsrSdioWdfDeviceAdd(WDFDEVICE device);
+void CsrSdioWdfDeviceDel(WDFDEVICE device);
+
+NTSTATUS CsrSdioWdfDeviceSuspend(WDFDEVICE device);
+NTSTATUS CsrSdioWdfDeviceResume(WDFDEVICE device);
+
+#endif /* #ifndef CSR_SDIO_WDF_H__ */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/csr_types.h
@@ -0,0 +1,53 @@
+/*
+ * Synergy compatible API -- basic types.
+ *
+ * Copyright (C) 2010 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef CSR_TYPES_H__
+#define CSR_TYPES_H__
+
+#include <oska/types.h>
+
+#ifndef FALSE
+#define FALSE false
+#endif
+
+#ifndef TRUE
+#define TRUE true
+#endif
+
+/* Data types */
+
+typedef size_t                  CsrSize;
+
+typedef uint8_t                 CsrUint8;
+typedef uint16_t                CsrUint16;
+typedef uint32_t                CsrUint32;
+
+typedef int8_t                  CsrInt8;
+typedef int16_t                 CsrInt16;
+typedef int32_t                 CsrInt32;
+
+typedef bool                    CsrBool;
+
+typedef char                    CsrCharString;
+typedef unsigned char           CsrUtf8String;
+typedef CsrUint16               CsrUtf16String; /* 16-bit UTF16 strings */
+typedef CsrUint32               CsrUint24;
+
+/*
+ * 64-bit integers
+ *
+ * Note: If a given compiler does not support 64-bit types, it is
+ * OK to omit these definitions;  32-bit versions of the code using
+ * these types may be available.  Consult the relevant documentation
+ * or the customer support group for information on this.
+ */
+#define CSR_HAVE_64_BIT_INTEGERS
+typedef uint64_t    CsrUint64;
+typedef int64_t     CsrInt64;
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/libsdio.h
@@ -0,0 +1,404 @@
+/*
+ * SDIO Userspace Interface library.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef SDIOEMB_LIBSDIO_H
+#define SDIOEMB_LIBSDIO_H
+
+/**
+ * \defgroup libsdio Userspace SDIO library (libsdio)
+ *
+ * \brief \e libsdio is a Linux C library for accessing SDIO cards.
+ *
+ * Use of this library requires several \e sdioemb kernel modules to be
+ * loaded:
+ *   - \c sdio.
+ *   - \c An SDIO slot driver (e.g., \c slot_shc for a standard PCI
+ *     SDIO Host Controller).
+ *   - \c sdio_uif which provides the required character devices
+ *     (/dev/sdio_uif0 for the card in SDIO slot 0 etc.).
+ */
+/*@{*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef WIN32
+#  define LIBSDIOAPI __stdcall
+#else
+#  define LIBSDIOAPI
+#endif
+
+struct sdio_uif;
+
+/**
+ * Handle to an opened SDIO Userspace Interface device.
+ */
+typedef struct sdio_uif *sdio_uif_t;
+
+enum sdio_status {
+    SDIO_SUCCESS   = 0,
+    SDIO_EAGAIN    = -1,
+    SDIO_EINVAL    = -2,
+    SDIO_EIO       = -3,
+    SDIO_ENODEV    = -4,
+    SDIO_ENOMEM    = -5,
+    SDIO_ENOTSUPP  = -6,
+    SDIO_ENXIO     = -7,
+    SDIO_ETIMEDOUT = -8,
+};
+
+/**
+ * Card interrupt handler function.
+ *
+ * @param uif handle to the interrupting device.
+ * @param arg data supplied by the caller of sdio_open().
+ */
+typedef void (LIBSDIOAPI *sdio_int_handler_t)(sdio_uif_t uif, void *arg);
+
+/**
+ * Asynchronous IO completion callback function.
+ *
+ * @param uif    handle to the device that completed the IO operation.
+ * @param arg    data supplied by the caller of the asynchronous IO operation.
+ * @param status status of the IO operation. 0 is success; -EIO,
+ *               -EINVAL, -ETIMEDOUT etc. on an error.
+ */
+typedef void (LIBSDIOAPI *sdio_io_callback_t)(sdio_uif_t uif, void *arg, int status);
+
+/**
+ * Open a SDIO Userspace Interface device and (optionally) register a
+ * card interrupt handler and enable card interrupts.
+ *
+ * Card interrupts are masked before calling int_handler and are
+ * unmasked when int_handler returns (unless sdio_interrupt_mask() is
+ * called).
+ *
+ * @param dev_filename  filename of the device to open.
+ * @param int_handler   card interrupt handler; or NULL if no
+ *                      interrupt handler is required.
+ * @param arg           argument to be passed to the interrupt handler.
+ *
+ * @return handle to the opened device; or NULL on error with errno
+ * set.
+ */
+sdio_uif_t LIBSDIOAPI sdio_open(const char *dev_filename,
+                                sdio_int_handler_t int_handler, void *arg);
+
+/**
+ * Mask the SDIO interrupt.
+ *
+ * Call this in an interrupt handler to allow the processing of
+ * interrupts to be deferred until after the interrupt handler has
+ * returned.
+ *
+ * @note \e Must only be called from within the interrupt handler
+ * registered with sdio_open().
+ *
+ * @param uif device handle.
+ */
+void LIBSDIOAPI sdio_interrupt_mask(sdio_uif_t uif);
+
+/**
+ * Unmask the SDIO interrupt.
+ *
+ * Unmasks the SDIO interrupt if it had previously been masked with
+ * sdio_interrupt_mask().
+ *
+ * @param uif device handle.
+ */
+void LIBSDIOAPI sdio_interrupt_unmask(sdio_uif_t uif);
+
+/**
+ * Close an opened SDIO Userspace Interface device, freeing all
+ * associated resources.
+ *
+ * @param uif handle to the device.
+ */
+void LIBSDIOAPI sdio_close(sdio_uif_t uif);
+
+/**
+ * Return the number of functions the card has.
+ *
+ * @param uif device handle.
+ *
+ * @return number of card functions.
+ */
+int LIBSDIOAPI sdio_num_functions(sdio_uif_t uif);
+
+/**
+ * Set an SDIO bus to 1 bit or 4 bit wide mode.
+ *
+ * The CCCR bus interface control register will be read and rewritten
+ * with the new bus width.
+ *
+ * @param uif       device handle.
+ * @param bus_width bus width (1 or 4).
+ *
+ * @return 0 on success; -ve on error with errno set.
+ *
+ * @note The card capabilities are \e not checked.  The user should
+ * ensure 4 bit mode is not enabled on a card that does not support
+ * it.
+ */
+int LIBSDIOAPI sdio_set_bus_width(sdio_uif_t uif, int bus_width);
+
+/**
+ * Limit the frequency of (or stop) the SD bus clock.
+ *
+ * The frequency cannot be set greater than that supported by the card
+ * or the controller.
+ *
+ * @note Stopping the bus clock while other device drivers are
+ * executing commands may result in those commands not completing
+ * until the bus clock is restarted.
+ *
+ * @param uif      device handle.
+ * @param max_freq maximum frequency (Hz) or 0 to stop the bus clock
+ *                 until the start of the next command.
+ */
+void LIBSDIOAPI sdio_set_max_bus_freq(sdio_uif_t uif, int max_freq);
+
+/**
+ * Return the card's manufacturer (vendor) ID.
+ *
+ * @param uif device handle.
+ *
+ * @return manufacturer ID.
+ */
+uint16_t LIBSDIOAPI sdio_manf_id(sdio_uif_t uif);
+
+/**
+ * Return the card's card (device) ID.
+ *
+ * @param uif device handle.
+ *
+ * @return card ID.
+ */
+uint16_t LIBSDIOAPI sdio_card_id(sdio_uif_t uif);
+
+/**
+ * Return the standard interface code for a function.
+ *
+ * @param uif  device handle.
+ * @param func card function to query.
+ *
+ * @return the standard interface.
+ */
+uint8_t LIBSDIOAPI sdio_std_if(sdio_uif_t uif, int func);
+
+/**
+ * Return a function's maximum supported block size.
+ *
+ * @param uif  device handle.
+ * @param func card function to query.
+ *
+ * @return maximum block size.
+ */
+int LIBSDIOAPI sdio_max_block_size(sdio_uif_t uif, int func);
+
+/**
+ * Return a function's current block size.
+ *
+ * @note This returns the driver's view of the block size and not the
+ * value in the function's block size register.
+ *
+ * @param uif  device handle.
+ * @param func card function to query.
+ *
+ * @return the current block size.
+ */
+int LIBSDIOAPI sdio_block_size(sdio_uif_t uif, int func);
+
+/**
+ * Set a function's block size.
+ *
+ * The function's block size registers will be written if necessary.
+ *
+ * @param uif   device handle.
+ * @param func  function to modify.
+ * @param blksz the new block size; or 0 for the default size.
+ *
+ * @return 0 on success; or -ve on error with errno set.
+ */
+int LIBSDIOAPI sdio_set_block_size(sdio_uif_t uif, int func, int blksz);
+
+/**
+ * Read an 8 bit register.
+ *
+ * @param uif  device handle.
+ * @param func card function.
+ * @param addr register address.
+ * @param data the data read.
+ *
+ * @return 0 on success; or -ve on error with errno set.
+ */
+int LIBSDIOAPI sdio_read8(sdio_uif_t uif, int func, uint32_t addr, uint8_t *data);
+
+/**
+ * Write an 8 bit register.
+ *
+ * @param uif  device handle.
+ * @param func card function.
+ * @param addr register address.
+ * @param data the data to write.
+ *
+ * @return 0 on success; or -ve on error with errno set.
+ */
+int LIBSDIOAPI sdio_write8(sdio_uif_t uif, int func, uint32_t addr, uint8_t data);
+
+/**
+ * Read a buffer from a 8 bit wide register/FIFO.
+ *
+ * The buffer read uses a fixed (not incrementing) address.
+ *
+ * \a block_size \e must be set to the value writted into \a func's
+ * I/O block size FBR register.
+ *
+ * If \a len % \a block_size == 0, a block mode transfer is used; a
+ * byte mode transfer is used if \a len < \a block_size.
+ *
+ * @param uif        device handle.
+ * @param func       card function.
+ * @param addr       register/FIFO address.
+ * @param data       buffer to store the data read.
+ * @param len        length of data to read.
+ * @param block_size block size to use for this transfer.
+ *
+ * @return 0 on success; or -ve on error with errno set.
+ */
+int LIBSDIOAPI sdio_read(sdio_uif_t uif, int func, uint32_t addr, uint8_t *data,
+                      size_t len, int block_size);
+
+/**
+ * Write a buffer to an 8 bit wide register/FIFO.
+ *
+ * The buffer write uses a fixed (not incrementing) address.
+ *
+ * \a block_size \e must be set to the value writted into \a func's
+ * I/O block size FBR register.
+ *
+ * If \a len % \a block_size == 0, a block mode transfer is used; a
+ * byte mode transfer is used if \a len < \a block_size.
+ *
+ * @param uif        device handle.
+ * @param func       card function.
+ * @param addr       register/FIFO address.
+ * @param data       buffer of data to write.
+ * @param len        length of the data to write.
+ * @param block_size block size to use for this transfer.
+ *
+ * @return 0 on success; or -ve on error with errno set.
+ */
+int LIBSDIOAPI sdio_write(sdio_uif_t uif, int func, uint32_t addr, const uint8_t *data,
+                          size_t len, int block_size);
+
+/**
+ * Read an 8 bit register, without waiting for completion.
+ *
+ * @param uif      device handle.
+ * @param func     card function.
+ * @param addr     register address.
+ * @param data     the data read.
+ * @param callback function to be called when the read completes.
+ * @param arg      argument to be passed to callback.
+ *
+ * @return 0 on success; or -ve on error with errno set.
+ */
+int LIBSDIOAPI sdio_read8_async(sdio_uif_t uif, int func, uint32_t addr, uint8_t *data,
+                                sdio_io_callback_t callback, void *arg);
+
+/**
+ * Write an 8 bit register, without waiting for completion.
+ *
+ * @param uif      device handle.
+ * @param func     card function.
+ * @param addr     register address.
+ * @param data     the data to write.
+ * @param callback function to be called when the write completes.
+ * @param arg      argument to be passed to callback.
+ *
+ * @return 0 on success; or -ve on error with errno set.
+ */
+int LIBSDIOAPI sdio_write8_async(sdio_uif_t uif, int func, uint32_t addr, uint8_t data,
+                                 sdio_io_callback_t callback, void *arg);
+
+/**
+ * Read a buffer from a 8 bit wide register/FIFO, without waiting for
+ * completion.
+ *
+ * The buffer read uses a fixed (not incrementing) address.
+ *
+ * \a block_size \e must be set to the value writted into \a func's
+ * I/O block size FBR register.
+ *
+ * If \a len % \a block_size == 0, a block mode transfer is used; a
+ * byte mode transfer is used if \a len < \a block_size.
+ *
+ * @param uif        device handle.
+ * @param func       card function.
+ * @param addr       register/FIFO address.
+ * @param data       buffer to store the data read.
+ * @param len        length of data to read.
+ * @param block_size block size to use for this transfer.
+ * @param callback   function to be called when the read completes.
+ * @param arg        argument to be passed to callback.
+ *
+ * @return 0 on success; or -ve on error with errno set.
+ */
+int LIBSDIOAPI sdio_read_async(sdio_uif_t uif, int func, uint32_t addr, uint8_t *data,
+                               size_t len, int block_size,
+                               sdio_io_callback_t callback, void *arg);
+
+/**
+ * Write a buffer to an 8 bit wide register/FIFO, without waiting for
+ * completion.
+ *
+ * The buffer write uses a fixed (not incrementing) address.
+ *
+ * \a block_size \e must be set to the value writted into \a func's
+ * I/O block size FBR register.
+ *
+ * If \a len % \a block_size == 0, a block mode transfer is used; a
+ * byte mode transfer is used if \a len < \a block_size.
+ *
+ * @param uif        device handle.
+ * @param func       card function.
+ * @param addr       register/FIFO address.
+ * @param data       buffer of data to write.
+ * @param len        length of the data to write.
+ * @param block_size block size to use for this transfer.
+ * @param callback   function to be called when the write completes.
+ * @param arg        argument to be passed to callback.
+ *
+ * @return 0 on success; or -ve on error with errno set.
+ */
+int LIBSDIOAPI sdio_write_async(sdio_uif_t uif, int func, uint32_t addr, const uint8_t *data,
+                                size_t len, int block_size,
+                                sdio_io_callback_t callback, void *arg);
+/**
+ * Force a card removal and reinsertion.
+ *
+ * This will power cycle the card if the slot hardware supports power
+ * control.
+ *
+ * @note The device handle will no longer be valid.
+ *
+ * @param uif device handle.
+ *
+ * @return 0 on success; or -ve on error with errno set.
+ */
+int LIBSDIOAPI sdio_reinsert_card(sdio_uif_t uif);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+/*@}*/
+
+#endif /* #ifndef SDIOEMB_LIBSDIO_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/linux.h
@@ -0,0 +1,16 @@
+/*
+ * Linux helpers for slot drivers.
+ *
+ * Copyright (C) 2009 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef SDIOEMB_LINUX_H
+#define SDIOEMB_LINUX_H
+
+#include <sdioemb/slot_api.h>
+
+int sdioemb_linux_slot_register(struct sdioemb_slot *slot);
+
+#endif /* #ifndef SDIOEMB_LINUX_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/sdio.h
@@ -0,0 +1,117 @@
+/*
+ * Standard SDIO definitions.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef SDIOEMB_SDIO_H
+#define SDIOEMB_SDIO_H
+
+/* Maximum time for VDD to rise to VDD min. */
+#define SDIO_POWER_UP_TIME_MS 250
+
+/* Minimum SD bus clock a card must support (Hz). */
+#define SDIO_CLOCK_FREQ_MIN 400000
+
+/* Maximum clock frequency for normal mode (Hz).
+ *
+ * Although high speed mode should be suitable for all speeds not all
+ * controller/card combinations are capable of meeting the higher
+ * tolerances for (e.g.) clock rise/fall times.  Therefore, default
+ * mode is used where possible for improved compatibility. */
+#define SDIO_CLOCK_FREQ_NORMAL_SPD 25000000
+
+/* Maximum clock frequency for high speed mode (Hz). */
+#define SDIO_CLOCK_FREQ_HIGH_SPD   50000000
+
+#define SDIO_MAX_FUNCTIONS 8 /* incl. F0 */
+
+/* Command argument format. */
+
+#define SDIO_CMD52_ARG_WRITE   0x80000000
+#define SDIO_CMD52_ARG_FUNC(f) ((f) << 28)
+#define SDIO_CMD52_ARG_ADDR(a) ((a) << 9)
+#define SDIO_CMD52_ARG_DATA(d) ((d) << 0)
+
+#define SDIO_CMD53_ARG_WRITE    0x80000000
+#define SDIO_CMD53_ARG_FUNC(f)  ((f) << 28)
+#define SDIO_CMD53_ARG_BLK_MODE 0x08000000
+#define SDIO_CMD53_ARG_ADDR(a)  ((a) << 9)
+#define SDIO_CMD53_ARG_CNT(c)   ((c) << 0)
+
+/* Response format. */
+
+#define SDIO_R5_DATA(r) (((r) >> 0) & 0xff)
+#define SDIO_R5_OUT_OF_RANGE    (1 <<  8)
+#define SDIO_R5_FUNCTION_NUMBER (1 <<  9)
+#define SDIO_R5_ERROR           (1 << 11)
+
+/* Register offsets and bits. */
+
+#define SDIO_OCR_CARD_READY     0x80000000
+#define SDIO_OCR_NUM_FUNCS_MASK 0x70000000
+#define SDIO_OCR_NUM_FUNCS_OFFSET 28
+#define SDIO_OCR_VOLTAGE_3V3    0x00300000 /* 3.2-3.3V & 3.3-3.4V */
+
+#define SDIO_CCCR_SDIO_REV       0x00
+#define SDIO_CCCR_SD_REV         0x01
+#define SDIO_CCCR_IO_EN          0x02
+#define SDIO_CCCR_IO_READY       0x03
+#define SDIO_CCCR_INT_EN         0x04
+#  define SDIO_CCCR_INT_EN_MIE   0x01
+#define SDIO_CCCR_INT_PENDING    0x05
+#define SDIO_CCCR_IO_ABORT       0x06
+#define SDIO_CCCR_BUS_IFACE_CNTL 0x07
+#  define SDIO_CCCR_BUS_IFACE_CNTL_CD_R_DISABLE 0x80
+#  define SDIO_CCCR_BUS_IFACE_CNTL_ECSI         0x20
+#  define SDIO_CCCR_BUS_IFACE_CNTL_4BIT_BUS     0x02
+#define SDIO_CCCR_CARD_CAPS      0x08
+#  define SDIO_CCCR_CARD_CAPS_LSC  0x40
+#  define SDIO_CCCR_CARD_CAPS_4BLS 0x80
+#define SDIO_CCCR_CIS_PTR        0x09
+#define SDIO_CCCR_BUS_SUSPEND    0x0c
+#define SDIO_CCCR_FUNC_SEL       0x0d
+#define SDIO_CCCR_EXEC_FLAGS     0x0e
+#define SDIO_CCCR_READY_FLAGS    0x0f
+#define SDIO_CCCR_F0_BLK_SIZE    0x10
+#define SDIO_CCCR_PWR_CNTL       0x12
+#define SDIO_CCCR_HIGH_SPEED     0x13
+#  define SDIO_CCCR_HIGH_SPEED_SHS 0x01
+#  define SDIO_CCCR_HIGH_SPEED_EHS 0x02
+
+#define SDIO_FBR_REG(f, r) (0x100*(f) + (r))
+
+#define SDIO_FBR_STD_IFACE(f)     SDIO_FBR_REG(f, 0x00)
+#define SDIO_FBR_STD_IFACE_EXT(f) SDIO_FBR_REG(f, 0x01)
+#define SDIO_FBR_CIS_PTR(f)       SDIO_FBR_REG(f, 0x09)
+#define SDIO_FBR_CSA_PTR(f)       SDIO_FBR_REG(f, 0x0c)
+#define SDIO_FBR_CSA_DATA(f)      SDIO_FBR_REG(f, 0x0f)
+#define SDIO_FBR_BLK_SIZE(f)      SDIO_FBR_REG(f, 0x10)
+
+#define SDIO_STD_IFACE_UART      0x01
+#define SDIO_STD_IFACE_BT_TYPE_A 0x02
+#define SDIO_STD_IFACE_BT_TYPE_B 0x03
+#define SDIO_STD_IFACE_GPS       0x04
+#define SDIO_STD_IFACE_CAMERA    0x05
+#define SDIO_STD_IFACE_PHS       0x06
+#define SDIO_STD_IFACE_WLAN      0x07
+#define SDIO_STD_IFACE_BT_TYPE_A_AMP 0x09
+
+/*
+ * Manufacturer and card IDs.
+ */
+#define SDIO_MANF_ID_CSR        0x032a
+
+#define SDIO_CARD_ID_CSR_UNIFI_1        0x0001
+#define SDIO_CARD_ID_CSR_UNIFI_2        0x0002
+#define SDIO_CARD_ID_CSR_BC6            0x0004
+#define SDIO_CARD_ID_CSR_DASH_D00       0x0005
+#define SDIO_CARD_ID_CSR_BC7            0x0006
+#define SDIO_CARD_ID_CSR_CINDERELLA     0x0007
+#define SDIO_CARD_ID_CSR_UNIFI_3        0x0007
+#define SDIO_CARD_ID_CSR_UNIFI_4        0x0008
+#define SDIO_CARD_ID_CSR_DASH           0x0010
+
+#endif /* #ifndef SDIOEMB_SDIO_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/sdio_api.h
@@ -0,0 +1,408 @@
+/*
+ * SDIO device driver API.
+ *
+ * Copyright (C) 2007-2008 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef _SDIO_API_H
+#define _SDIO_API_H
+
+/**
+ * @defgroup fdriver SDIO function driver API
+ *
+ * @brief The SDIO function driver API is used to implement drivers
+ * for SDIO card functions.
+ *
+ * Function drivers register with the SDIO driver core
+ * (sdio_register_driver()), listing which functions it supports and
+ * providing callback functions for card inserts, removes and
+ * interrupts.
+ *
+ * @par \anchor card_io_ops Card I/O operations:
+ *
+ * - \link sdioemb_read8(struct sdioemb_dev *, uint32_t, uint8_t *) sdioemb_read8()\endlink
+ * - \link sdioemb_read16(struct sdioemb_dev *, uint32_t, uint16_t *) sdioemb_read16()\endlink
+ * - \link sdioemb_write8(struct sdioemb_dev *, uint32_t, uint8_t) sdioemb_write8()\endlink
+ * - \link sdioemb_write16(struct sdioemb_dev *, uint32_t, uint16_t) sdioemb_write16()\endlink
+ * - \link sdioemb_f0_read8(struct sdioemb_dev *, uint32_t, uint8_t *) sdioemb_f0_read8()\endlink
+ * - \link sdioemb_f0_write8(struct sdioemb_dev *, uint32_t, uint8_t) sdioemb_f0_write8()\endlink
+ * - \link sdioemb_read(struct sdioemb_dev *, uint32_t, void *, size_t) sdioemb_read()\endlink
+ * - \link sdioemb_write(struct sdioemb_dev *, uint32_t, const void *, size_t) sdioemb_write()\endlink
+ */
+
+struct sdioemb_func_driver;
+struct sdioemb_dev;
+struct sdioemb_dev_priv;
+
+/**
+ * An SDIO device.
+ *
+ * Each SDIO card will have an sdio_dev for each function.
+ *
+ * None of the fields (except for drv_data) should be written.
+ *
+ * @ingroup fdriver
+ */
+struct sdioemb_dev {
+    struct sdioemb_func_driver *driver;        /**< Function driver for this device. */
+    uint16_t                 vendor_id;     /**< Vendor ID of the card. */
+    uint16_t                 device_id;     /**< Device ID of the card. */
+    int                      function;      /**< Function number of this device. */
+    uint8_t                  interface;     /**< SDIO standard interface number. */
+    uint16_t                 max_blocksize; /**< Maximum block size supported. */
+    uint16_t                 blocksize;     /**< Blocksize in use. */
+    int                      slot_id;       /**< ID of the slot this card is inserted into. */
+    void *                   os_device;     /**< Pointer to an OS-specific device structure. */
+    struct sdioemb_dev_priv *priv;          /**< Data private to the SDIO core. */
+    void *                   drv_data;      /**< Data private to the function driver. */
+};
+
+#define SDIOEMB_ANY_ID    0xffff
+#define SDIOEMB_UIF_FUNC  0
+#define SDIOEMB_ANY_FUNC  0xff
+#define SDIOEMB_ANY_IFACE 0xff
+
+/**
+ * An entry for an SDIO device ID table.
+ *
+ * Functions are matched to drivers using any combination of vendor
+ * ID, device ID, function number or standard interface.
+ *
+ * Matching on #function == SDIOEMB_UIF_FUNC is reserved for the SDIO
+ * Userspace Interface driver. Card management drivers can match on
+ * #function == 0, these will be probed before any function drivers.
+ *
+ * @ingroup fdriver
+ */
+struct sdioemb_id_table {
+    uint16_t vendor_id; /**< Vendor ID to match or SDIOEMB_ANY_ID */
+    uint16_t device_id; /**< Device ID to match or SDIOEMB_ANY_ID */
+    int      function;  /**< Function number to match or SDIOEMB_ANY_FUNC */
+    uint8_t  interface; /**< SDIO standard interface to match or SDIOEMB_ANY_IFACE */
+};
+
+/**
+ * A driver for an SDIO function.
+ *
+ * @ingroup fdriver
+ */
+struct sdioemb_func_driver {
+    /**
+     * Driver name used in diagnostics.
+     */
+    const char *name;
+
+    /**
+     * 0 terminated array of functions supported by this device.
+     *
+     * The driver may (for example) match on a number of vendor
+     * ID/device ID/function number triplets or on an SDIO standard
+     * interface.
+     */
+    struct sdioemb_id_table *id_table;
+
+    /**
+     * Called by the core when an inserted card has functions which
+     * match those listed in id_table.
+     *
+     * The driver's implementation should (if required):
+     *
+     *   - perform any additional probing
+     *   - do function specific initialization
+     *   - allocate and register any function/OS specific devices or interfaces.
+     *
+     * Called in: thread context.
+     *
+     * @param fdev the newly inserted device.
+     *
+     * @return 0 on success; -ve on error.
+     */
+    int (*probe)(struct sdioemb_dev *fdev);
+
+    /**
+     * Called by the core when a card is removed.  This is only called
+     * if the probe() call succeeded.
+     *
+     * The driver's implementation should (if required);
+     *
+     *   - do any function specific shutdown.
+     *   - cleanup any data structures created/registers during probe().
+     *
+     * Called in: thread context.
+     *
+     * @param fdev the device being removed.
+     */
+    void (*remove)(struct sdioemb_dev *fdev);
+
+    /**
+     * Called by the core to signal an SDIO interrupt for this card
+     * occurs, if interrupts have been enabled with
+     * sdioemb_interrupt_enable().
+     *
+     * The driver's implementation should signal a thread (or similar)
+     * to actually handle the interrupt as no card I/O may be
+     * performed whilst in interrupt context. When the interrupt is
+     * handled, the driver should call sdioemb_interrupt_acknowledge() to
+     * enable further interrupts to be signalled.
+     *
+     * Called in: interrupt context.
+     *
+     * @param fdev the device which may have raised the interrupt.
+     */
+    void (*card_int_handler)(struct sdioemb_dev *fdev);
+
+    /**
+     * Called by the core to signal a suspend power management
+     * event occured.
+     *
+     * The driver's implementation should (if required)
+     * set the card to a low power mode and return as soon
+     * as possible. After this function returns, the
+     * driver should not start any SDIO commands.
+     *
+     * Called in: thread context.
+     *
+     * @param fdev the device handler.
+     */
+    void (*suspend)(struct sdioemb_dev *fdev);
+
+    /**
+     * Called by the core to signal a resume power management
+     * event occured.
+     *
+     * The driver's implementation should (if required)
+     * initialise the card to an operational mode and return
+     * as soon as possible. If the card has been powered off
+     * during suspend, the driver would have to initialise
+     * the card from scratch (f/w download, h/w initialisation, etc.).
+     *
+     * Called in: thread context.
+     *
+     * @param fdev the device handler.
+     */
+    void (*resume)(struct sdioemb_dev *fdev);
+};
+
+int  sdioemb_driver_register(struct sdioemb_func_driver *fdriver);
+void sdioemb_driver_unregister(struct sdioemb_func_driver *fdriver);
+
+int sdioemb_driver_probe(struct sdioemb_func_driver *fdriver, struct sdioemb_dev *fdev);
+void sdioemb_driver_remove(struct sdioemb_func_driver *fdriver, struct sdioemb_dev *fdev);
+
+/* For backward compatibility. */
+#define sdio_register_driver sdioemb_driver_register
+#define sdio_unregister_driver sdioemb_driver_unregister
+
+int sdioemb_set_block_size(struct sdioemb_dev *fdev, uint16_t blksz);
+void sdioemb_set_max_bus_freq(struct sdioemb_dev *fdev, int max_freq);
+int sdioemb_set_bus_width(struct sdioemb_dev *fdev, int bus_width);
+
+int sdioemb_enable_function(struct sdioemb_dev *fdev);
+int sdioemb_disable_function(struct sdioemb_dev *fdev);
+int sdioemb_reenable_csr_function(struct sdioemb_dev *dev);
+void sdioemb_idle_function(struct sdioemb_dev *fdev);
+
+int sdioemb_read8(struct sdioemb_dev *fdev, uint32_t addr, uint8_t *val);
+int sdioemb_read16(struct sdioemb_dev *fdev, uint32_t addr, uint16_t *val);
+int sdioemb_write8(struct sdioemb_dev *fdev, uint32_t addr, uint8_t val);
+int sdioemb_write16(struct sdioemb_dev *fdev, uint32_t addr, uint16_t val);
+int sdioemb_f0_read8(struct sdioemb_dev *fdev, uint32_t addr, uint8_t *val);
+int sdioemb_f0_write8(struct sdioemb_dev *fdev, uint32_t addr, uint8_t val);
+int sdioemb_read(struct sdioemb_dev *fdev, uint32_t addr, void *data, size_t len);
+int sdioemb_write(struct sdioemb_dev *fdev, uint32_t addr, const void *data, size_t len);
+
+int sdioemb_hard_reset(struct sdioemb_dev *fdev);
+
+void sdioemb_power_on(struct sdioemb_dev *fdev);
+void sdioemb_power_off(struct sdioemb_dev *fdev);
+
+int sdioemb_interrupt_enable(struct sdioemb_dev *fdev);
+int sdioemb_interrupt_disable(struct sdioemb_dev *fdev);
+void sdioemb_interrupt_acknowledge(struct sdioemb_dev *fdev);
+
+int sdioemb_cis_get_tuple(struct sdioemb_dev *fdev, uint8_t tuple,
+                       void *buf, size_t len);
+
+void sdioemb_suspend_function(struct sdioemb_dev *fdev);
+void sdioemb_resume_function(struct sdioemb_dev *fdev);
+
+/**
+ * SDIO command status.
+ *
+ * @ingroup fdriver
+ */
+enum sdioemb_cmd_status {
+    SDIOEMB_CMD_OK          = 0x00, /**< Command successful. */
+
+    SDIOEMB_CMD_ERR_CMD     = 0x01,
+    SDIOEMB_CMD_ERR_DAT     = 0x02,
+
+    SDIOEMB_CMD_ERR_CRC     = 0x10,
+    SDIOEMB_CMD_ERR_TIMEOUT = 0x20,
+    SDIOEMB_CMD_ERR_OTHER   = 0x40,
+
+    SDIOEMB_CMD_ERR_CMD_CRC     = SDIOEMB_CMD_ERR_CMD | SDIOEMB_CMD_ERR_CRC,     /**< Response CRC error. */
+    SDIOEMB_CMD_ERR_CMD_TIMEOUT = SDIOEMB_CMD_ERR_CMD | SDIOEMB_CMD_ERR_TIMEOUT, /**< Response time out. */
+    SDIOEMB_CMD_ERR_CMD_OTHER   = SDIOEMB_CMD_ERR_CMD | SDIOEMB_CMD_ERR_OTHER,   /**< Other response error. */
+    SDIOEMB_CMD_ERR_DAT_CRC     = SDIOEMB_CMD_ERR_DAT | SDIOEMB_CMD_ERR_CRC,     /**< Data CRC error. */
+    SDIOEMB_CMD_ERR_DAT_TIMEOUT = SDIOEMB_CMD_ERR_DAT | SDIOEMB_CMD_ERR_TIMEOUT, /**< Data receive time out. */
+    SDIOEMB_CMD_ERR_DAT_OTHER   = SDIOEMB_CMD_ERR_DAT | SDIOEMB_CMD_ERR_OTHER,   /**< Other data error. */
+
+    SDIOEMB_CMD_ERR_NO_CARD = 0x04, /**< No card present. */
+
+    SDIOEMB_CMD_IN_PROGRESS = 0xff, /**< Command still in progress. */
+};
+
+/**
+ * A response to an SDIO command.
+ *
+ * For R1, R4, R5, and R6 responses only the middle 32 bits of the
+ * response are stored, the leading octet (start and direction bits
+ * and command index) and trailing octet (CRC and stop bit) are
+ * discarded.
+ *
+ * @bug R2 and R3 responses are not used by SDIO and are not
+ * supported.
+ *
+ * @ingroup fdriver
+ */
+union sdioemb_response {
+    uint32_t r1;
+    uint32_t r4;
+    uint32_t r5;
+    uint32_t r6;
+};
+
+/**
+ * SDIO command parameters and response.
+ */
+struct sdioemb_cmd_resp {
+    uint8_t  cmd;                 /**< Command index (0 to 63). */
+    uint32_t arg;                 /**< Command argument. */
+    union sdioemb_response response; /**< Response to the command. Valid
+                                     iff the command has completed and
+                                     (sdio_cmd::status & SDIOEMB_CMD_ERR_CMD) == 0.*/
+};
+
+/**
+ * CSPI command parameters and response.
+ */
+struct cspi_cmd_resp {
+    unsigned cmd : 8;  /**< Command octet (type, and function). */
+    unsigned addr: 24; /**< 24 bit address. */
+    uint16_t val;      /**< Word to write or read from the card (for non-burst commands). */
+    uint8_t  response; /**< Response octet.  Valid iff the command has completed and
+                          (sdio_cmd::status & SDIOEMB_CMD_ERR_CMD) == 0. */
+};
+
+
+/**
+ * An SDIO command, its status and response.
+ *
+ * sdio_cmd is used to submit SDIO commands to a device and return its
+ * status and any response or data.
+ *
+ * @ingroup fdriver
+ */
+struct sdioemb_cmd {
+    /**
+     * The SDIO device which submitted the command.  Set by the
+     * core.
+     */
+    struct sdioemb_dev *owner;
+
+    /**
+     * Called by the core when the command has been completed.
+     *
+     * Called in: interrupt context.
+     *
+     * @param cmd the completed command.
+     */
+    void (*callback)(struct sdioemb_cmd *cmd);
+
+    /**
+     * Set of flags specifying the response type, data transfer
+     * direction and other parameters.
+     *
+     * For SDIO commands set at least one of the response types:
+     *   - #SDIOEMB_CMD_FLAG_RESP_NONE
+     *   - #SDIOEMB_CMD_FLAG_RESP_R1
+     *   - #SDIOEMB_CMD_FLAG_RESP_R1B
+     *   - #SDIOEMB_CMD_FLAG_RESP_R2
+     *   - #SDIOEMB_CMD_FLAG_RESP_R3
+     *   - #SDIOEMB_CMD_FLAG_RESP_R4
+     *   - #SDIOEMB_CMD_FLAG_RESP_R5
+     *   - #SDIOEMB_CMD_FLAG_RESP_R5B
+     *   - #SDIOEMB_CMD_FLAG_RESP_R6
+     *
+     * and any of the additional flags:
+     *   - #SDIOEMB_CMD_FLAG_READ
+     *
+     * For CSPI commands set:
+     *   - #SDIOEMB_CMD_FLAG_CSPI
+     */
+    unsigned flags;
+
+    /**
+     * SDIO command parameters and response.
+     *
+     * Valid only if #SDIOEMB_CMD_FLAG_CSPI is \e not set in #flags.
+     */
+    struct sdioemb_cmd_resp sdio;
+
+    /**
+     * CSPI command parameters and response.
+     *
+     * Valid only if #SDIOEMB_CMD_FLAG_CSPI is set in #flags.
+     */
+    struct cspi_cmd_resp cspi;
+
+    /**
+     * Buffer of data to read or write.
+     *
+     * Must be set to NULL if the command is not a data transfer.
+     */
+    uint8_t *data;
+
+    /**
+     * Length of #data in octets.
+     *
+     * len must be either: less than the device's sdio_dev::blocksize;
+     * or a multiple of the device's sdio_dev::blocksize.
+     */
+    size_t len;
+
+    /**
+     * Status of the command after it has completed.
+     */
+    enum sdioemb_cmd_status status;
+
+    /**
+     * Data private to caller of sdioemb_start_cmd().
+     */
+    void *priv;
+};
+
+/** @addtogroup fdriver
+ *@{*/
+#define SDIOEMB_CMD_FLAG_RESP_NONE 0x00 /**< No response. */
+#define SDIOEMB_CMD_FLAG_RESP_R1   0x01 /**< R1 response. */
+#define SDIOEMB_CMD_FLAG_RESP_R1B  0x02 /**< R1b response. */
+#define SDIOEMB_CMD_FLAG_RESP_R2   0x03 /**< R2 response. */
+#define SDIOEMB_CMD_FLAG_RESP_R3   0x04 /**< R3 response. */
+#define SDIOEMB_CMD_FLAG_RESP_R4   0x05 /**< R4 response. */
+#define SDIOEMB_CMD_FLAG_RESP_R5   0x06 /**< R5 response. */
+#define SDIOEMB_CMD_FLAG_RESP_R5B  0x07 /**< R5b response. */
+#define SDIOEMB_CMD_FLAG_RESP_R6   0x08 /**< R6 response. */
+#define SDIOEMB_CMD_FLAG_RESP_MASK 0xff /**< Mask for response type. */
+#define SDIOEMB_CMD_FLAG_RAW     0x0100 /**< @internal Bypass the command queues. */
+#define SDIOEMB_CMD_FLAG_READ    0x0200 /**< Data transfer is a read, not a write. */
+#define SDIOEMB_CMD_FLAG_CSPI    0x0400 /**< CSPI transfer, not SDIO or SDIO-SPI. */
+#define SDIOEMB_CMD_FLAG_ABORT   0x0800 /**< Data transfer abort command. */
+/*@}*/
+
+int sdioemb_start_cmd(struct sdioemb_dev *fdev, struct sdioemb_cmd *cmd);
+
+#endif /* #ifndef _SDIO_API_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/sdio_bt_a.h
@@ -0,0 +1,143 @@
+/*
+ * SDIO Bluetooth Type-A interface definitions.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef SDIOEMB_SDIO_BT_A_H
+#define SDIOEMB_SDIO_BT_A_H
+
+#include <sdioemb/sdio_csr.h>
+#include <csr_sdio.h>
+
+/*
+ * Standard SDIO function registers for a Bluetooth Type-A interface.
+ */
+#define SDIO_BT_A_RD 0x00
+#define SDIO_BT_A_TD 0x00
+
+#define SDIO_BT_A_RX_PKT_CTRL 0x10
+#  define PC_RRT 0x01
+
+#define SDIO_BT_A_TX_PKT_CTRL 0x11
+#  define PC_WRT 0x01
+
+#define SDIO_BT_A_RETRY_CTRL  0x12
+#  define RTC_STAT 0x01
+#  define RTC_SET  0x01
+
+#define SDIO_BT_A_INTRD       0x13
+#  define INTRD 0x01
+#  define CL_INTRD 0x01
+
+#define SDIO_BT_A_INT_EN      0x14
+#  define EN_INTRD 0x01
+
+#define SDIO_BT_A_BT_MODE     0x20
+#  define MD_STAT 0x01
+
+/*
+ * Length of the Type-A header.
+ *
+ * Packet length (3 octets) plus Service ID (1 octet).
+ */
+#define SDIO_BT_A_HEADER_LEN 4
+
+/*
+ * Maximum length of a Type-A transport packet.
+ *
+ * Type-A header length and maximum length of a HCI packet (65535
+ * octets).
+ */
+#define SDIO_BT_A_PACKET_LEN_MAX 65543
+
+enum sdioemb_bt_a_service_id {
+    SDIO_BT_A_SID_CMD    = 0x01,
+    SDIO_BT_A_SID_ACL    = 0x02,
+    SDIO_BT_A_SID_SCO    = 0x03,
+    SDIO_BT_A_SID_EVT    = 0x04,
+    SDIO_BT_A_SID_VENDOR = 0xfe,
+};
+
+static __inline int sdioemb_bt_a_packet_len(const char *p)
+{
+    return (p[0] & 0xff) | ((p[1] & 0xff) << 8) | ((p[2] & 0xff) << 16);
+}
+
+static __inline int sdioemb_bt_a_service_id(const char *p)
+{
+    return p[3];
+}
+
+/*
+ * Minimum amount to read (including the Type-A header). This allows
+ * short packets (e.g., flow control packets) to be read with a single
+ * command.
+ */
+#define SDIO_BT_A_MIN_READ 32
+
+#define SDIO_BT_A_NAME_LEN 16
+
+struct sdioemb_bt_a_dev {
+    CsrSdioFunction *func;
+    char name[SDIO_BT_A_NAME_LEN];
+    void *drv_data;
+
+    /**
+     * Get a buffer to receive a packet into.
+     *
+     * @param bt the BT device.
+     * @param header a buffer of length #SDIO_BT_A_MIN_READ containing
+     *      (part of) the packet the buffer is for.  It will contain
+     *      the Type-A header and as much of the payload that will
+     *      fit.
+     * @param buffer_min_len the minimum length of buffer required to
+     *     receive the whole packet.  This includes space for padding
+     *     the read to a whole number of blocks (if more than 512
+     *     octets is still to be read).
+     * @param buffer returns the buffer. The packet (including the
+     *     Type-A header will be placed at the beginning of this
+     *     buffer.
+     * @param buffer_handle returns a buffer handle passed to the
+     *     subsequent call of the receive() callback.
+     *
+     * @return 0 if a buffer was provided.
+     * @return -ENOMEM if no buffer could be provided.
+     */
+    int (*get_rx_buffer)(struct sdioemb_bt_a_dev *bt, const uint8_t *header,
+                         size_t buffer_min_len, uint8_t **buffer, void **buffer_handle);
+    void (*receive)(struct sdioemb_bt_a_dev *bt, void *buffer_handle, int status);
+    void (*sleep_state_changed)(struct sdioemb_bt_a_dev *bt);
+
+    enum sdio_sleep_state sleep_state;
+
+    uint8_t  max_tx_retries;
+    uint8_t  max_rx_retries;
+    unsigned needs_read_ack:1;
+    unsigned wait_for_firmware:1;
+
+    unsigned rx_off:1;
+
+    /**
+     * A buffer to read the packet header into before the real buffer
+     * is requested with the get_rx_buffer() callback.
+     *
+     * @internal
+     */
+    uint8_t *header;
+};
+
+int  sdioemb_bt_a_setup(struct sdioemb_bt_a_dev *bt, CsrSdioFunction *func);
+void sdioemb_bt_a_cleanup(struct sdioemb_bt_a_dev *bt);
+int  sdioemb_bt_a_send(struct sdioemb_bt_a_dev *bt, const uint8_t *packet, size_t len);
+void sdioemb_bt_a_handle_interrupt(struct sdioemb_bt_a_dev *bt);
+void sdioemb_bt_a_set_sleep_state(struct sdioemb_bt_a_dev *bt, enum sdio_sleep_state state);
+int  sdioemb_bt_a_check_for_reset(struct sdioemb_bt_a_dev *bt);
+void sdioemb_bt_a_start(struct sdioemb_bt_a_dev *bt);
+void sdioemb_bt_a_stop(struct sdioemb_bt_a_dev *bt);
+void sdioemb_bt_a_rx_on(struct sdioemb_bt_a_dev *bt);
+void sdioemb_bt_a_rx_off(struct sdioemb_bt_a_dev *bt);
+
+#endif /* #ifndef SDIOEMB_SDIO_BT_A_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/sdio_cis.h
@@ -0,0 +1,27 @@
+/*
+ * SDIO CIS definitions.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef _SDIO_CIS_H
+#define _SDIO_CIS_H
+
+#define CISTPL_NULL     0x00
+#define CISTPL_CHECKSUM 0x10
+#define CISTPL_VERS_1   0x15
+#define CISTPL_ALTSTR   0x16
+#define CISTPL_MANFID   0x20
+#  define CISTPL_MANFID_SIZE 0x04
+#define CISTPL_FUNCID   0x21
+#define CISTPL_FUNCE    0x22
+#define CISTPL_SDIO_STD 0x91
+#define CISTPL_SDIO_EXT 0x92
+#define CISTPL_END      0xff
+#define CISTPL_FUNCE  0x22
+#  define CISTPL_FUNCE_00_SIZE 0x04
+#  define CISTPL_FUNCE_01_SIZE 0x2a
+
+#endif /* #ifndef _SDIO_CIS_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/sdio_csr.h
@@ -0,0 +1,134 @@
+/*
+ * CSR specific SDIO registers.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef SDIOEMB_SDIO_CSR_H
+#define SDIOEMB_SDIO_CSR_H
+
+/**
+ * @defgroup registers CSR specific SDIO registers
+ *
+ * Registers at 0xF0 - 0xFF in the CCCR are reserved for vendor
+ * specific registers.  The registers documented here are specific to
+ * following CSR chips:
+ *
+ *   - BlueCore (6 and later)
+ *   - UltraCore
+ *@{
+ */
+
+/**
+ * Interrupt status/host wakeup register.
+ *
+ * This controls a function's deep sleep state.
+ *
+ * @see enum sdio_sleep_state
+ */
+#define SDIO_CSR_SLEEP_STATE 0xf0
+#  define SDIO_CSR_SLEEP_STATE_FUNC(f) ((f) << 4)
+#  define SDIO_CSR_SLEEP_STATE_RDY_INT_EN  0x02
+#  define SDIO_CSR_SLEEP_STATE_WAKE_REQ    0x01
+
+/**
+ * Host interrupt clear register.
+ *
+ * Writing a 1 to bit 0 clears an SDIO interrupt raised by a generic
+ * function.
+ */
+#define SDIO_CSR_HOST_INT 0xf1
+#  define SDIO_CSR_HOST_INT_CL 0x01
+
+/**
+ * From host scratch register 0.
+ *
+ * A read/write register that can be used for signalling between the
+ * host and the chip.
+ *
+ * The usage of this register depends on the version of the chip or
+ * firmware.
+ */
+#define SDIO_CSR_FROM_HOST_SCRATCH0 0xf2
+
+/**
+ * From host scratch register 1.
+ *
+ * @see SDIO_CSR_FROM_HOST_SCRATCH0
+ */
+#define SDIO_CSR_FROM_HOST_SCRATCH1 0xf3
+
+/**
+ * To host scratch register 0.
+ *
+ * A read only register that may be used for signalling between the
+ * chip and the host.
+ *
+ * The usage of this register depends on the version of the chip or
+ * firmware.
+ */
+#define SDIO_CSR_TO_HOST_SCRATCH0 0xf4
+
+/**
+ * To host scratch register 1.
+ *
+ * @see SDIO_CSR_TO_HOST_SCRATCH0
+ */
+#define SDIO_CSR_TO_HOST_SCRATCH1 0xf5
+
+/**
+ * Extended I/O enable.
+ *
+ * Similar to the standard CCCR I/O Enable register, this is used to
+ * detect if an internal reset of a function has occured and
+ * (optionally) reenable it.
+ *
+ * An internal reset is detected by CCCR I/O Enable bit being set and
+ * the corresponding EXT_IO_EN bit being clear.
+ */
+#define SDIO_CSR_EXT_IO_EN 0xf6
+
+/**
+ * Deep sleep states as set via the sleep state register.
+ *
+ * These states are used to control when the chip may go into a deep
+ * sleep (a low power mode).
+ *
+ * Since a chip in deep sleep may not respond to SDIO commands, the
+ * host should ensure that the chip is not in deep sleep before
+ * attempting SDIO commands to functions 1 to 7.
+ *
+ * The available states are:
+ *
+ * AWAKE - chip must not enter deep sleep and should exit deep sleep
+ * if it's currently sleeping.
+ *
+ * TORPID - chip may enter deep sleep.
+ *
+ * DROWSY - a transition state between TORPID and AWAKE.  This is
+ * AWAKE plus the chip asserts an interrupt when the chip is awake.
+ *
+ * @see SDIO_CSR_SLEEP_STATE
+ */
+enum sdio_sleep_state {
+    SLEEP_STATE_AWAKE  = SDIO_CSR_SLEEP_STATE_WAKE_REQ,
+    SLEEP_STATE_DROWSY = SDIO_CSR_SLEEP_STATE_WAKE_REQ | SDIO_CSR_SLEEP_STATE_RDY_INT_EN,
+    SLEEP_STATE_TORPID = 0x00,
+};
+
+/*@}*/
+
+/*
+ * Generic function registers (with byte addresses).
+ */
+
+/*
+ * SDIO_MODE is chip dependant, see the sdio_mode table in sdio_cspi.c
+ * to add support for new chips.
+ */
+#define SDIO_MODE /* chip dependant */
+#  define SDIO_MODE_CSPI_EN 0x40
+
+#endif /* SDIOEMB_SDIO_CSR_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/slot_api.h
@@ -0,0 +1,313 @@
+/*
+ * Slot driver API.
+ *
+ * Copyright (C) 2007-2009 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef _SLOT_API_H
+#define _SLOT_API_H
+
+#include <sdioemb/sdio_api.h>
+
+struct sdioemb_slot;
+
+/**
+ * @defgroup sdriver SDIO slot driver API
+ *
+ * @brief The SDIO slot driver API provides an interface for the SDIO
+ * layer to driver an SDIO slot (socket).
+ *
+ * Slot drivers register with the SDIO layer (sdioemb_slot_register()),
+ * providing functions to starting commands, enabling/disable card
+ * interrupts, card detection and bus power control.
+ *
+ * Functions are provided to notify the SDIO layer when a command has
+ * completed (sdioemb_cmd_complete()) and when an SDIO card interrupt has
+ * occurred (sdioemb_interrupt()).
+ */
+
+#define SDIOEMB_BUS_FREQ_OFF      0
+#define SDIOEMB_BUS_FREQ_DEFAULT -1
+#define SDIOEMB_BUS_FREQ_IDLE    -2
+
+/**
+ * Valid SDIO bus voltage levels.
+ *
+ * @ingroup sdriver
+ */
+enum sdioemb_power {
+    SDIOEMB_POWER_OFF  =   0, /**< Power switched off. */
+    SDIOEMB_POWER_3V3  =  33, /**< Voltage set to 3.3V. */
+};
+
+/**
+ * SDIO slot capabilities.
+ *
+ * @ingroup sdriver
+ */
+struct slot_caps {
+    int max_bus_freq;  /**< Maximum bus frequency (Hz). */
+    int max_bus_width; /**< Maximum bus width supported (1 or 4 data lines). */
+    uint8_t cspi_mode; /**< CSPI_MODE register value (for CSPI capable slots). */
+};
+
+/**
+ * Controller hardware type.
+ *
+ * @ingroup sdriver
+ */
+enum slot_controller_type {
+    SDIOEMB_SLOT_TYPE_SD = 0,   /**< SD/SDIO controller. */
+    SDIOEMB_SLOT_TYPE_SPI,      /**< SPI controller. */
+    SDIOEMB_SLOT_TYPE_SPI_CSPI, /**< SPI controller capable of CSPI. */
+};
+
+/**
+ * Return values from the add_function() notifier.
+ *
+ * @ingroup sdriver
+ */
+enum sdioemb_add_func_status {
+    /**
+     * The core will call sdioemb_add_function().
+     */
+    SDIOEMB_ADD_FUNC_NOW = 0,
+    /**
+     * The slot driver will call sdioemb_add_function() or the
+     * function driver will call sdioemb_driver_probe() directly.
+     */
+    SDIOEMB_ADD_FUNC_DEFERRED = 1,
+};
+
+/**
+ * Slot/card event notifiers.
+ *
+ * A slot driver may be notified when certain slot or card events
+ * occur.
+ *
+ * @ingroup sdriver
+ */
+struct sdioemb_slot_notifiers {
+    /**
+     * This is called when a card function has been enumerated
+     * and initialized but before can be bound to a function driver.
+     *
+     * A slot driver may use this to create an OS-specific object for
+     * the function.  The slot driver must either (a) return
+     * SDIOEMB_ADD_FUNC_NOW; (b) return SDIOEMB_ADD_FUNC_DEFERRED and
+     * call sdioemb_add_function() later on; (c) return
+     * SDIOEMB_ADD_FUNC_DEFERRED and pass the fdev to the function
+     * driver for it to call sdioemb_driver_probe() directly; or (d)
+     * return an error.
+     *
+     * The slot driver may need to get a reference to the fdev with
+     * sdioemb_get_function() if the lifetime of the OS-specific
+     * object extends beyond the subsequent return of the
+     * del_function() callback.
+     *
+     * If this is non-NULL the slot driver must also provide
+     * del_function().
+     *
+     * @param slot the SDIO slot producing the notification.
+     * @param fdev the SDIO function being added.
+     *
+     * @return SDIOEMB_ADD_FUNC_NOW if the function is ready for use.
+     * @return SDIOEMB_ADD_FUNC_DEFERRED if sdioemb_add_function() or
+     *         sdioemb_driver_probe() will be called later.
+     * @return -ve on a error.
+     */
+    int (*add_function)(struct sdioemb_slot *slot, struct sdioemb_dev *fdev);
+
+    /**
+     * This is called when a card function is being removed and after
+     * any function driver has been unbound.
+     *
+     * A slot driver may use this to delete any OS-specific object
+     * created by the add_function() notifier.
+     *
+     * @param slot the SDIO slot producing the notification.
+     * @param fdev the SDIO function being deleted.
+     */
+    void (*del_function)(struct sdioemb_slot *slot, struct sdioemb_dev *fdev);
+};
+
+struct sdioemb_slot_priv;
+
+/**
+ * An SDIO slot driver.
+ *
+ * Allocate and free with sdioemb_slot_alloc() and sdioemb_slot_free().
+ *
+ * @ingroup sdriver
+ */
+struct sdioemb_slot {
+    /**
+     * Name of the slot used in diagnostic messages.
+     *
+     * This would typically include the name of the SDIO controller
+     * and the slot number if the controller has multiple slots.
+     *
+     * This will be set by sdioemb_slot_register() if it is left as an
+     * empty string.
+     */
+    char name[64];
+
+    /**
+     * Controller hardware type.
+     */
+    enum slot_controller_type type;
+
+    /**
+     * Set the SD bus clock frequency.
+     *
+     * The driver's implementation should set the SD bus clock to not
+     * more than \a clk Hz (unless \a clk is equal to
+     * #SDIOEMB_BUS_FREQ_OFF or #SDIOEMB_BUS_FREQ_IDLE).
+     *
+     * If \a clk == SDIOEMB_BUS_FREQ_OFF the clock should be stopped.
+     *
+     * \a clk == SDIOEMB_BUS_FREQ_IDLE indicates that the bus is idle
+     * (currently unused) and the host controller may slow (or stop)
+     * the SD bus clock to save power on the card.  During this idle
+     * state the host controller must be capable of receiving SDIO
+     * interrupts (for certain host controllers this may require
+     * leaving the clock running).
+     *
+     * If \a clk is greater than #SDIO_CLOCK_FREQ_NORMAL_SPD (25 MHz)
+     * subsequent commands should be done with the controller in high
+     * speed mode.
+     *
+     * Called from: interrupt context.
+     *
+     * @param slot  the slot to configure.
+     * @param clk   new SD bus clock frequency in Hz, SDIOEMB_BUS_FREQ_OFF
+     *              or SDIOEMB_BUS_FREQ_IDLE.
+     *
+     * @return The bus frequency actually configured in Hz.
+     */
+    int (*set_bus_freq)(struct sdioemb_slot *slot, int clk);
+
+    /**
+     * Set the SD bus width.
+     *
+     * The driver's implementation should set the width of the SD bus
+     * for all subsequent data transfers to the specified value.
+     *
+     * This may be NULL if the driver sets the bus width when starting
+     * a command, or the driver is for an SDIO-SPI or CSPI controller.
+     *
+     * Called from: thread context.
+     *
+     * @param slot      the slot to configure.
+     * @param bus_width new SD bus width (either 1 or 4).
+     *
+     * @return 0 on success.
+     * @return -ve if a low-level error occured when setting the bus width.
+     */
+    int (*set_bus_width)(struct sdioemb_slot *slot, int bus_width);
+
+    /**
+     * Start an SDIO command.
+     *
+     * The driver's implementation should:
+     *
+     *   - set the controller's bus width to #bus_width,
+     *   - program the controller to start the command.
+     *
+     * Called from: interrupt context.
+     *
+     * @param slot  slot to perform the command.
+     * @param cmd   SDIO command to start.
+     */
+    int (*start_cmd)(struct sdioemb_slot *slot, struct sdioemb_cmd *cmd);
+
+    /**
+     * Detect if a card is inserted into the slot.
+     *
+     * Called from: thread context.
+     *
+     * @param slot slot to check.
+     *
+     * @return non-zero if a card is inserted; 0 otherwise.
+     */
+    int (*card_present)(struct sdioemb_slot *slot);
+
+    /**
+     * Switch on/off the SDIO bus power and set the SDIO bus voltage.
+     *
+     * Called from: thread context.
+     *
+     * @param slot  the slot.
+     * @param power the requested voltage.
+     *
+     * @return 0 on success; -ve on error: -EINVAL - requested voltage
+     * is not supported.
+     */
+    int (*card_power)(struct sdioemb_slot *slot, enum sdioemb_power power);
+
+    /**
+     * Enable (unmask) the SDIO card interrupt on the controller.
+     *
+     * Called from: interrupt context.
+     *
+     * @param slot the slot to enable the interrupt on..
+     */
+    void (*enable_card_int)(struct sdioemb_slot *slot);
+
+    /**
+     * Disable (mask) the SDIO card interrupt on the controller.
+     *
+     * Called from: thread context.
+     *
+     * @param slot the slot to disable the interrupt on.
+     */
+    void (*disable_card_int)(struct sdioemb_slot *slot);
+
+    /**
+     * Perform a hard reset of the card.
+     *
+     * Hard resets can be achieved in two ways:
+     *
+     * -# Power cycle (if the slot has power control).
+     * -# Platform-specific assertion of a card/chip reset line.
+     *
+     * If hard resets are not supported, either return 0 or set
+     * hard_reset to NULL.
+     *
+     * @param slot the slot for the card to reset.
+     *
+     * @return 0 if a hard reset was performed.
+     * @return 1 if hard resets are not supported.
+     */
+    int (*hard_reset)(struct sdioemb_slot *slot);
+
+    struct slot_caps         caps;           /**< Slot capabilities. */
+    int                      clock_freq;     /**< SD bus frequency requested by the SDIO layer. */
+    int                      bus_width;      /**< Bus width requested by the SDIO layer. */
+    struct sdioemb_slot_notifiers notifs;    /**< Slot event notifiers. */
+    int                      cspi_reg_pad;   /**< Padding for CSPI register reads. */
+    int                      cspi_burst_pad; /**< Padding for CSPI burst reads. */
+    struct sdioemb_slot_priv *priv;          /**< Data private to the SDIO layer. */
+    void *                   drv_data;       /**< Data private to the slot driver. */
+};
+
+struct sdioemb_slot *sdioemb_slot_alloc(size_t drv_data_size);
+void sdioemb_slot_free(struct sdioemb_slot *slot);
+int sdioemb_slot_register(struct sdioemb_slot *slot);
+void sdioemb_slot_unregister(struct sdioemb_slot *slot);
+int sdioemb_card_inserted(struct sdioemb_slot *slot);
+void sdioemb_card_removed(struct sdioemb_slot *slot);
+void sdioemb_interrupt(struct sdioemb_slot *slot);
+void sdioemb_cmd_complete(struct sdioemb_slot *slot, struct sdioemb_cmd *cmd);
+
+void sdioemb_suspend(struct sdioemb_slot *slot);
+void sdioemb_resume(struct sdioemb_slot *slot);
+
+void sdioemb_add_function(struct sdioemb_dev *fdev);
+void sdioemb_del_function(struct sdioemb_dev *fdev);
+void sdioemb_get_function(struct sdioemb_dev *fdev);
+void sdioemb_put_function(struct sdioemb_dev *fdev);
+
+#endif /* #ifndef _SLOT_API_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/slot_imx27.h
@@ -0,0 +1,86 @@
+/*
+ * i.MX27 SDHC definitions.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef _SLOT_IMX27_H
+#define _SLOT_IMX27_H
+
+/*
+ * i.MX27 SDHC registers.
+ */
+
+#define SDHC_STR_STP_CLK  0x00
+#  define STR_STP_CLK_MMCSD_RESET 0x0008
+#  define STR_STP_CLK_START_CLK   0x0002
+#  define STR_STP_CLK_STOP_CLK    0x0001
+
+#define SDHC_STATUS       0x04
+#  define STATUS_CARD_PRESENCE    0x8000
+#  define STATUS_SDIO_INT_ACTIVE  0x4000
+#  define STATUS_END_CMD_RESP     0x2000
+#  define STATUS_WRITE_OP_DONE    0x1000
+#  define STATUS_READ_OP_DONE     0x0800
+#  define STATUS_CARD_BUS_CLK_RUN 0x0100
+#  define STATUS_APPL_BUFF_FF     0x0080
+#  define STATUS_APPL_BUFF_FE     0x0040
+#  define STATUS_RESP_CRC_ERR     0x0020
+#  define STATUS_CRC_READ_ERR     0x0008
+#  define STATUS_CRC_WRITE_ERR    0x0004
+#  define STATUS_TIME_OUT_RESP    0x0002
+#  define STATUS_TIME_OUT_READ    0x0001
+#  define STATUS_ERR_CMD_MASK     (STATUS_RESP_CRC_ERR | STATUS_TIME_OUT_RESP)
+#  define STATUS_ERR_DATA_MASK    (STATUS_CRC_READ_ERR | STATUS_CRC_WRITE_ERR | STATUS_TIME_OUT_READ)
+#  define STATUS_ERR_MASK         (STATUS_ERR_CMD_MASK | STATUS_ERR_DATA_MASK)
+
+#define SDHC_CLK_RATE     0x08
+
+#define SDHC_CMD_DAT_CTRL 0x0c /* CMD_DAT_CONT */
+#  define CMD_DAT_CTRL_CMD_RESUME        0x8000
+#  define CMD_DAT_CTRL_CMD_RESP_LONG_OFF 0x1000
+#  define CMD_DAT_CTRL_STOP_READ_WAIT    0x0800
+#  define CMD_DAT_CTRL_START_READ_WAIT   0x0400
+#  define CMD_DAT_CTRL_BUS_WIDTH_4       0x0200
+#  define CMD_DAT_CTRL_INIT              0x0080
+#  define CMD_DAT_CTRL_WRITE             0x0010
+#  define CMD_DAT_CTRL_DATA_ENABLE       0x0008
+#  define CMD_DAT_CTRL_RESP_NONE         0x0000
+#  define CMD_DAT_CTRL_RESP_R1_R5_R6     0x0001
+#  define CMD_DAT_CTRL_RESP_R2           0x0002
+#  define CMD_DAT_CTRL_RESP_R3_R4        0x0003
+
+#define SDHC_RES_TO       0x10
+
+#define SDHC_READ_TO      0x14
+#  define READ_TO_RECOMMENDED 0x2db4
+
+#define SDHC_BLK_LEN      0x18
+
+#define SDHC_NOB          0x1c
+
+#define SDHC_REV_NO       0x20
+
+#define SDHC_INT_CTRL     0x24 /* INT_CNTR */
+#  define INT_CTRL_CARD_INSERTION_EN 0x8000
+#  define INT_CTRL_SDIO_REMOVAL_EN   0x4000
+#  define INT_CTRL_SDIO_IRQ_EN       0x2000
+#  define INT_CTRL_DAT0_EN           0x1000
+#  define INT_CTRL_BUF_READ_EN       0x0010
+#  define INT_CTRL_BUF_WRITE_EN      0x0008
+#  define INT_CTRL_END_CMD_RES       0x0004
+#  define INT_CTRL_WRITE_OP_DONE     0x0002
+#  define INT_CTRL_READ_OP_DONE      0x0001
+#  define INT_CTRL_INT_EN_MASK       0xe01f
+
+#define SDHC_CMD          0x28
+
+#define SDHC_ARG          0x2c
+
+#define SDHC_RES_FIFO     0x34
+
+#define SDHC_BUFFER_ACCESS 0x38
+
+#endif /* #ifndef _SLOT_IMX27_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/slot_imx31.h
@@ -0,0 +1,86 @@
+/*
+ * i.MX31 SDHC definitions.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef _SLOT_IMX31_H
+#define _SLOT_IMX31_H
+
+/*
+ * i.MX31 SDHC registers.
+ */
+
+#define SDHC_STR_STP_CLK  0x00
+#  define STR_STP_CLK_MMCSD_RESET 0x0008
+#  define STR_STP_CLK_START_CLK   0x0002
+#  define STR_STP_CLK_STOP_CLK    0x0001
+
+#define SDHC_STATUS       0x04
+#  define STATUS_CARD_PRESENCE    0x8000
+#  define STATUS_SDIO_INT_ACTIVE  0x4000
+#  define STATUS_END_CMD_RESP     0x2000
+#  define STATUS_WRITE_OP_DONE    0x1000
+#  define STATUS_READ_OP_DONE     0x0800
+#  define STATUS_CARD_BUS_CLK_RUN 0x0100
+#  define STATUS_APPL_BUFF_FF     0x0080
+#  define STATUS_APPL_BUFF_FE     0x0040
+#  define STATUS_RESP_CRC_ERR     0x0020
+#  define STATUS_CRC_READ_ERR     0x0008
+#  define STATUS_CRC_WRITE_ERR    0x0004
+#  define STATUS_TIME_OUT_RESP    0x0002
+#  define STATUS_TIME_OUT_READ    0x0001
+#  define STATUS_ERR_CMD_MASK     (STATUS_RESP_CRC_ERR | STATUS_TIME_OUT_RESP)
+#  define STATUS_ERR_DATA_MASK    (STATUS_CRC_READ_ERR | STATUS_CRC_WRITE_ERR | STATUS_TIME_OUT_READ)
+#  define STATUS_ERR_MASK         (STATUS_ERR_CMD_MASK | STATUS_ERR_DATA_MASK)
+
+#define SDHC_CLK_RATE     0x08
+
+#define SDHC_CMD_DAT_CTRL 0x0c /* CMD_DAT_CONT */
+#  define CMD_DAT_CTRL_CMD_RESUME        0x8000
+#  define CMD_DAT_CTRL_CMD_RESP_LONG_OFF 0x1000
+#  define CMD_DAT_CTRL_STOP_READ_WAIT    0x0800
+#  define CMD_DAT_CTRL_START_READ_WAIT   0x0400
+#  define CMD_DAT_CTRL_BUS_WIDTH_4       0x0200
+#  define CMD_DAT_CTRL_INIT              0x0080
+#  define CMD_DAT_CTRL_WRITE             0x0010
+#  define CMD_DAT_CTRL_DATA_ENABLE       0x0008
+#  define CMD_DAT_CTRL_RESP_NONE         0x0000
+#  define CMD_DAT_CTRL_RESP_R1_R5_R6     0x0001
+#  define CMD_DAT_CTRL_RESP_R2           0x0002
+#  define CMD_DAT_CTRL_RESP_R3_R4        0x0003
+
+#define SDHC_RES_TO       0x10
+
+#define SDHC_READ_TO      0x14
+#  define READ_TO_RECOMMENDED 0x2db4
+
+#define SDHC_BLK_LEN      0x18
+
+#define SDHC_NOB          0x1c
+
+#define SDHC_REV_NO       0x20
+
+#define SDHC_INT_CTRL     0x24 /* INT_CNTR */
+#  define INT_CTRL_CARD_INSERTION_EN 0x8000
+#  define INT_CTRL_SDIO_REMOVAL_EN   0x4000
+#  define INT_CTRL_SDIO_IRQ_EN       0x2000
+#  define INT_CTRL_DAT0_EN           0x1000
+#  define INT_CTRL_BUF_READ_EN       0x0010
+#  define INT_CTRL_BUF_WRITE_EN      0x0008
+#  define INT_CTRL_END_CMD_RES       0x0004
+#  define INT_CTRL_WRITE_OP_DONE     0x0002
+#  define INT_CTRL_READ_OP_DONE      0x0001
+#  define INT_CTRL_INT_EN_MASK       0xe01f
+
+#define SDHC_CMD          0x28
+
+#define SDHC_ARG          0x2c
+
+#define SDHC_RES_FIFO     0x34
+
+#define SDHC_BUFFER_ACCESS 0x38
+
+#endif /* #ifndef _SLOT_IMX31_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/slot_pxa27x.h
@@ -0,0 +1,70 @@
+/*
+ * PXA27x MMC/SD controller definitions.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef _SLOT_PXA27X_H
+#define _SLOT_PXA27X_H
+
+#define PXA27X_MMC_MMCLK_BASE_FREQ 19500000
+#define PXA27X_MMC_FIFO_SIZE 32
+
+#define STOP_CLOCK              (1 << 0)
+#define START_CLOCK             (2 << 0)
+
+#define STAT_END_CMD_RES                (1 << 13)
+#define STAT_PRG_DONE                   (1 << 12)
+#define STAT_DATA_TRAN_DONE             (1 << 11)
+#define STAT_CLK_EN                     (1 << 8)
+#define STAT_RECV_FIFO_FULL             (1 << 7)
+#define STAT_XMIT_FIFO_EMPTY            (1 << 6)
+#define STAT_RES_CRC_ERR                (1 << 5)
+#define STAT_SPI_READ_ERROR_TOKEN       (1 << 4)
+#define STAT_CRC_READ_ERROR             (1 << 3)
+#define STAT_CRC_WRITE_ERROR            (1 << 2)
+#define STAT_TIME_OUT_RESPONSE          (1 << 1)
+#define STAT_READ_TIME_OUT              (1 << 0)
+
+#define SPI_CS_ADDRESS          (1 << 3)
+#define SPI_CS_EN               (1 << 2)
+#define CRC_ON                  (1 << 1)
+#define SPI_EN                  (1 << 0)
+
+#define CMDAT_SDIO_INT_EN       (1 << 11)
+#define CMDAT_STOP_TRAN         (1 << 10)
+#define CMDAT_SD_4DAT           (1 << 8)
+#define CMDAT_DMAEN             (1 << 7)
+#define CMDAT_INIT              (1 << 6)
+#define CMDAT_BUSY              (1 << 5)
+#define CMDAT_STREAM            (1 << 4)        /* 1 = stream */
+#define CMDAT_WRITE             (1 << 3)        /* 1 = write */
+#define CMDAT_DATAEN            (1 << 2)
+#define CMDAT_RESP_NONE         (0 << 0)
+#define CMDAT_RESP_SHORT        (1 << 0)
+#define CMDAT_RESP_R2           (2 << 0)
+#define CMDAT_RESP_R3           (3 << 0)
+
+#define RDTO_MAX                0xffff
+
+#define BUF_PART_FULL           (1 << 0)
+
+#define SDIO_SUSPEND_ACK        (1 << 12)
+#define SDIO_INT                (1 << 11)
+#define RD_STALLED              (1 << 10)
+#define RES_ERR                 (1 << 9)
+#define DAT_ERR                 (1 << 8)
+#define TINT                    (1 << 7)
+#define TXFIFO_WR_REQ           (1 << 6)
+#define RXFIFO_RD_REQ           (1 << 5)
+#define CLK_IS_OFF              (1 << 4)
+#define STOP_CMD                (1 << 3)
+#define END_CMD_RES             (1 << 2)
+#define PRG_DONE                (1 << 1)
+#define DATA_TRAN_DONE          (1 << 0)
+
+#define MMC_I_MASK_ALL          0x00001fff
+
+#endif /* #ifndef _SLOT_PXA27X_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/slot_shc.h
@@ -0,0 +1,223 @@
+/*
+ * Standard Host Controller definitions.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef _SLOT_SHC_H
+#define _SLOT_SHC_H
+
+#include <oska/io.h>
+
+/* SHC registers */
+#define SHC_SYSTEM_ADDRESS  0x00
+
+#define SHC_BLOCK_SIZE      0x04
+#  define SHC_BLOCK_SIZE_DMA_BOUNDARY_4K   (0x0 << 12)
+#  define SHC_BLOCK_SIZE_DMA_BOUNDARY_512K (0x7 << 12)
+
+#define SHC_BLOCK_COUNT     0x06
+#define SHC_ARG             0x08
+
+#define SHC_TRANSFER_MODE   0x0c
+#  define SHC_TRANSFER_MODE_DMA_EN        0x0001
+#  define SHC_TRANSFER_MODE_BLK_CNT_EN    0x0002
+#  define SHC_TRANSFER_MODE_AUTO_CMD12_EN 0x0004
+#  define SHC_TRANSFER_MODE_DATA_READ     0x0010
+#  define SHC_TRANSFER_MODE_MULTI_BLK     0x0020
+
+#define SHC_CMD             0x0e
+#  define SHC_CMD_RESP_NONE     0x0000
+#  define SHC_CMD_RESP_136      0x0001
+#  define SHC_CMD_RESP_48       0x0002
+#  define SHC_CMD_RESP_48B      0x0003
+#  define SHC_CMD_RESP_CRC_CHK  0x0008
+#  define SHC_CMD_RESP_IDX_CHK  0x0010
+#  define SHC_CMD_DATA_PRESENT  0x0020
+#  define SHC_CMD_TYPE_ABORT    (0x3 << 6)
+#  define SHC_CMD_IDX(c)        ((c) << 8)
+
+#define SHC_RESPONSE_0_31   0x10
+
+#define SHC_BUFFER_DATA_PORT    0x20
+
+#define SHC_PRESENT_STATE       0x24
+#  define SHC_PRESENT_STATE_CMD_INHIBIT     0x00000001
+#  define SHC_PRESENT_STATE_DAT_INHIBIT     0x00000002
+#  define SHC_PRESENT_STATE_CARD_PRESENT    0x00010000
+
+#define SHC_HOST_CTRL           0x28
+#  define SHC_HOST_CTRL_LED_ON          0x01
+#  define SHC_HOST_CTRL_4BIT            0x02
+#  define SHC_HOST_CTRL_HIGH_SPD_EN     0x04
+
+
+#define SHC_PWR_CTRL        0x29
+#  define SHC_PWR_CTRL_3V3      0x0e
+#  define SHC_PWR_CTRL_ON       0x01
+
+#define SHC_BLOCK_GAP_CTRL  0x2a
+#define SHC_WAKEUP_CTRL     0x2b
+
+#define SHC_CLOCK_CTRL      0x2c
+#  define SHC_CLOCK_CTRL_INT_CLK_EN     0x01
+#  define SHC_CLOCK_CTRL_INT_CLK_STABLE 0x02
+#  define SHC_CLOCK_CTRL_SD_CLK_EN      0x04
+#  define SHC_CLOCK_CTRL_DIV(d)         (((d) >> 1) << 8) /* divisor must be power of 2 */
+
+#define SHC_TIMEOUT_CTRL    0x2e
+#  define SHC_TIMEOUT_CTRL_MAX          0x0e
+
+#define SHC_SOFTWARE_RST    0x2f
+#  define SHC_SOFTWARE_RST_ALL 0x01
+#  define SHC_SOFTWARE_RST_CMD 0x02
+#  define SHC_SOFTWARE_RST_DAT 0x04
+
+#define SHC_INT_STATUS      0x30
+#define SHC_INT_STATUS_EN   0x34
+#define SHC_INT_SIGNAL_EN   0x38
+#  define SHC_INT_CMD_COMPLETE      0x00000001
+#  define SHC_INT_TRANSFER_COMPLETE 0x00000002
+#  define SHC_INT_BLOCK_GAP         0x00000004
+#  define SHC_INT_DMA               0x00000008
+#  define SHC_INT_WR_BUF_RDY        0x00000010
+#  define SHC_INT_RD_BUF_RDY        0x00000020
+#  define SHC_INT_CARD_INSERTED     0x00000040
+#  define SHC_INT_CARD_REMOVED      0x00000080
+#  define SHC_INT_CARD_INT          0x00000100
+#  define SHC_INT_ERR_ANY           0x00008000
+#  define SHC_INT_ERR_CMD_TIMEOUT   0x00010000
+#  define SHC_INT_ERR_CMD_CRC       0x00020000
+#  define SHC_INT_ERR_CMD_ENDBIT    0x00040000
+#  define SHC_INT_ERR_CMD_INDEX     0x00080000
+#  define SHC_INT_ERR_CMD_ALL       0x000f0000
+#  define SHC_INT_ERR_DAT_TIMEOUT   0x00100000
+#  define SHC_INT_ERR_DAT_CRC       0x00200000
+#  define SHC_INT_ERR_DAT_ENDBIT    0x00400000
+#  define SHC_INT_ERR_DAT_ALL       0x00700000
+#  define SHC_INT_ERR_CURRENT_LIMIT 0x00800000
+#  define SHC_INT_ERR_AUTO_CMD12    0x01000000
+#  define SHC_INT_ERR_ALL           0x01ff0000
+#  define SHC_INT_ALL               0x01ff81ff
+
+#define SHC_AUTO_CMD12_STATUS   0x3c
+
+#define SHC_CAPS                0x40
+#  define SHC_CAPS_TO_BASE_CLK_FREQ(c)  (((c) & 0x00003f00) >> 8)
+#  define SHC_CAPS_PWR_3V3              (1 << 24)
+
+#define SHC_MAX_CURRENT_CAPS    0x4c
+
+/* PCI configuration registers. */
+#define PCI_SHC_SLOT_INFO 0x40
+
+/* Maximum time to wait for a software reset. */
+#define SHC_RESET_TIMEOUT_MS 100 /* ms */
+
+/* Maximum time to wait for internal clock to stabilize */
+#define SHC_INT_CLK_STABLE_TIMEOUT_MS 100
+
+/*
+ * No supported voltages in the capabilities register.
+ *
+ * Workaround: Assume 3.3V is supported.
+ */
+#define SLOT_SHC_QUIRK_NO_VOLTAGE_CAPS (1 << 0)
+
+/*
+ * Commands with an R5B (busy) response do not complete.
+ *
+ * Workaround: Use R5 instead. This will only work if the busy signal
+ * is cleared sufficiently quickly before the next command is started.
+ */
+#define SLOT_SHC_QUIRK_R5B_BROKEN      (1 << 1)
+
+/*
+ * High speed mode doesn't work.
+ *
+ * Workaround: limit maximum bus frequency to 25 MHz.
+ */
+#define SLOT_SHC_QUIRK_HIGH_SPD_BROKEN (1 << 2)
+
+/*
+ * Data timeout (TIMEOUT_CTRL) uses SDCLK and not TMCLK.
+ *
+ * Workaround: set TIMEOUT_CTRL using SDCLK.
+ */
+#define SLOT_SHC_QUIRK_DATA_TIMEOUT_USES_SDCLK (1 << 3)
+
+/*
+ * Controller can only start DMA on dword (32 bit) aligned addresses.
+ *
+ * Workaround: PIO is used on data transfers with a non-dword aligned
+ * address.
+ */
+#define SHC_QUIRK_DMA_NEEDS_DWORD_ALIGNED_ADDR (1 << 4)
+
+/*
+ * Controller is unreliable following multiple transfers
+ *
+ * Workaround: The controller is reset following every command, not just
+ * erroneous ones
+ */
+#define SHC_QUIRK_RESET_EVERY_CMD_COMPLETE (1 << 5)
+
+/*
+ * JMicron JMB381 to JMB385 controllers require some non-standard PCI
+ * config space writes.
+ */
+#define SHC_QUIRK_JMICRON_JMB38X (1 << 6)
+
+/*
+ * Controller can only do DMA if the length is a whole number of
+ * dwords.
+ *
+ * Controller with this quirk probably also need
+ * SHC_QUIRK_DMA_NEEDS_DWORD_ALIGNED_ADDR.
+ *
+ * Workaround: PIO is used on data transfers that don't end on an
+ * aligned address.
+ */
+#define SHC_QUIRK_DMA_NEEDS_DWORD_ALIGNED_LEN (1 << 7)
+
+struct sdioemb_shc {
+    struct sdioemb_slot *slot;
+    void (*enable_int)(struct sdioemb_slot *slot, uint32_t ints);
+    void (*disable_int)(struct sdioemb_slot *slot, uint32_t ints);
+    void (*cmd_complete)(struct sdioemb_slot *slot, struct sdioemb_cmd *cmd);
+    uint32_t quirks;
+    os_io_mem_t addr;
+
+    os_spinlock_t lock;
+    os_timer_t lockup_timer;
+    uint32_t base_clk;
+    struct sdioemb_cmd *current_cmd;
+    uint8_t *data;
+    size_t remaining;
+    size_t block_size;
+};
+
+void sdioemb_shc_init(struct sdioemb_shc *shc);
+void sdioemb_shc_clean_up(struct sdioemb_shc *shc);
+
+int sdioemb_shc_start(struct sdioemb_shc *shc);
+void sdioemb_shc_stop(struct sdioemb_shc *shc);
+
+bool sdioemb_shc_isr(struct sdioemb_shc *shc, uint32_t *int_stat);
+void sdioemb_shc_dsr(struct sdioemb_shc *shc, uint32_t int_stat);
+
+int sdioemb_shc_set_bus_freq(struct sdioemb_shc *shc, int clk);
+int sdioemb_shc_set_bus_width(struct sdioemb_shc *shc, int bus_width);
+int sdioemb_shc_start_cmd(struct sdioemb_shc *shc, struct sdioemb_cmd *cmd,
+                          bool use_dma, uint64_t dma_addr);
+int sdioemb_shc_card_present(struct sdioemb_shc *shc);
+int sdioemb_shc_card_power(struct sdioemb_shc *shc, enum sdioemb_power power);
+void sdioemb_shc_enable_card_int(struct sdioemb_shc *shc);
+void sdioemb_shc_disable_card_int(struct sdioemb_shc *shc);
+int sdioemb_shc_hard_reset(struct sdioemb_shc *shc);
+
+void sdioemb_shc_show_quirks(struct sdioemb_shc *shc);
+
+#endif /* #ifndef _SLOT_SHC_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/slot_ushc.h
@@ -0,0 +1,133 @@
+/*
+ * USB Standard Host Controller definitions.
+ *
+ * Copyright (C) 2010 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef _SLOT_USHC_H
+#define _SLOT_USHC_H
+
+#include <oska/io.h>
+
+enum ushc_request
+{
+    USHC_GET_CAPS  = 0x00,
+    USHC_HOST_CTRL = 0x01,
+    USHC_PWR_CTRL  = 0x02,
+    USHC_CLK_FREQ  = 0x03,
+    USHC_EXEC_CMD  = 0x04,
+    USHC_READ_RESP = 0x05,
+    USHC_RESET     = 0x06
+};
+
+enum ushc_request_recipient
+{
+    USHC_RECIPIENT_DEVICE = 0x00,
+    USHC_RECIPIENT_INTERFACE = 0x01,
+    USHC_RECIPIENT_ENDPOINT = 0x02,
+    USHC_RECIPIENT_OTHER = 0x03
+};
+
+enum ushc_request_direction
+{
+    USHC_HOST_TO_DEVICE = 0x00,
+    USHC_DEVICE_TO_HOST = 0x01
+};
+
+struct sdioemb_ushc
+{
+    struct sdioemb_slot *slot;
+
+    void (*enable_int)(struct sdioemb_slot *slot, uint32_t ints);
+    void (*disable_int)(struct sdioemb_slot *slot, uint32_t ints);
+    void (*cmd_complete)(struct sdioemb_slot *slot, struct sdioemb_cmd *cmd);
+    int  (*set_host_ctrl)(struct sdioemb_slot *slot, uint16_t controler_state);
+    int  (*submit_vendor_request)(struct sdioemb_slot *slot,
+                                  enum ushc_request request,
+                                  enum ushc_request_direction direction,
+                                  enum ushc_request_recipient recipient,
+                                  uint16_t value,
+                                  uint16_t index,
+                                  void* io_buffer,
+                                  uint32_t io_buffer_length);
+    int  (*submit_cbw_request)(struct sdioemb_slot *slot, uint8_t cmd_index, uint16_t block_size, uint32_t cmd_arg);
+    int  (*submit_data_request)(struct sdioemb_slot *slot,
+                                enum ushc_request_direction direction,
+                                void* request_buffer,
+                                uint32_t request_buffer_length);
+    int  (*submit_csw_request)(struct sdioemb_slot *slot);
+
+    os_spinlock_t lock;
+
+    uint32_t base_clock;
+    uint32_t controler_capabilities;
+    uint16_t controler_state;
+    struct sdioemb_cmd* current_cmd;
+
+#define DISCONNECTED    0
+#define INT_EN          1
+#define IGNORE_NEXT_INT 2
+#define STOP            4
+    uint32_t flags;
+
+#define USHC_INT_STATUS_SDIO_INT     (1 << 1)
+#define USHC_INT_STATUS_CARD_PRESENT (1 << 0)
+    uint8_t interrupt_status;
+
+    size_t block_size;
+};
+
+#define USHC_GET_CAPS_VERSION_MASK 0xff
+#define USHC_GET_CAPS_3V3      (1 << 8)
+#define USHC_GET_CAPS_3V0      (1 << 9)
+#define USHC_GET_CAPS_1V8      (1 << 10)
+#define USHC_GET_CAPS_HIGH_SPD (1 << 16)
+
+#define USHC_PWR_CTRL_OFF 0x00
+#define USHC_PWR_CTRL_3V3 0x01
+#define USHC_PWR_CTRL_3V0 0x02
+#define USHC_PWR_CTRL_1V8 0x03
+
+#define USHC_HOST_CTRL_4BIT     (1 << 1)
+#define USHC_HOST_CTRL_HIGH_SPD (1 << 0)
+
+#define USHC_READ_RESP_BUSY        (1 << 4)
+#define USHC_READ_RESP_ERR_TIMEOUT (1 << 3)
+#define USHC_READ_RESP_ERR_CRC     (1 << 2)
+#define USHC_READ_RESP_ERR_DAT     (1 << 1)
+#define USHC_READ_RESP_ERR_CMD     (1 << 0)
+#define USHC_READ_RESP_ERR_MASK    0x0f
+
+void sdioemb_ushc_init(struct sdioemb_ushc* ushc);
+void sdioemb_ushc_clean_up(struct sdioemb_ushc* ushc);
+
+int sdioemb_ushc_start(struct sdioemb_ushc* ushc);
+void sdioemb_ushc_stop(struct sdioemb_ushc* ushc);
+
+bool sdioemb_ushc_isr(struct sdioemb_ushc* ushc, uint8_t int_stat);
+
+int sdioemb_ushc_set_bus_freq(struct sdioemb_ushc* ushc, int clk);
+int sdioemb_ushc_set_bus_width(struct sdioemb_ushc* ushc, int bus_width);
+int sdioemb_ushc_start_cmd(struct sdioemb_ushc* ushc, struct sdioemb_cmd *cmd);
+int sdioemb_ushc_card_present(struct sdioemb_ushc* ushc);
+int sdioemb_ushc_card_power(struct sdioemb_ushc* ushc, enum sdioemb_power power);
+void sdioemb_ushc_enable_card_int(struct sdioemb_ushc* ushc);
+void sdioemb_ushc_disable_card_int(struct sdioemb_ushc* ushc);
+int sdioemb_ushc_hard_reset(struct sdioemb_ushc* ushc);
+
+void sdioemb_ushc_command_complete(struct sdioemb_ushc* ushc, uint8_t status, uint32_t respones);
+
+int ushc_hw_get_caps(struct sdioemb_ushc* ushc);
+static int ushc_hw_set_host_ctrl(struct sdioemb_ushc* ushc, uint16_t mask, uint16_t val);
+static int ushc_hw_submit_vendor_request(struct sdioemb_ushc* ushc,
+                                       enum ushc_request request,
+                                       enum ushc_request_recipient recipient,
+                                       enum ushc_request_direction direction,
+                                       uint16_t value,
+                                       uint16_t index,
+                                       void* io_buffer,
+                                       uint32_t io_buffer_length);
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/trace.h
@@ -0,0 +1,19 @@
+/*
+ * Sdioemb trace messages.
+ *
+ * Copyright (C) 2009 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+
+#ifndef SDIOEMB_TRACE_H
+#define SDIOEMB_TRACE_H
+
+#if defined(__linux__)
+#  define OS_TRACE_PREFIX "sdioemb: "
+#endif
+
+#include <oska/trace.h>
+
+#endif /* #ifndef SDIOEMB_TRACE_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/uif.h
@@ -0,0 +1,41 @@
+/*
+ * Userspace interface to the SDIO Userspace Interface driver.
+ *
+ * Copyright (C) 2007 Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ */
+#ifndef LINUX_SDIOEMB_UIF_H
+#define LINUX_SDIOEMB_UIF_H
+
+enum sdioemb_uif_cmd_type {
+    SDIOEMB_UIF_CMD52_READ, SDIOEMB_UIF_CMD52_WRITE,
+    SDIOEMB_UIF_CMD53_READ, SDIOEMB_UIF_CMD53_WRITE,
+};
+
+struct sdioemb_uif_cmd {
+    enum sdioemb_uif_cmd_type type;
+    int                    function;
+    uint32_t               address;
+    uint8_t *              data;
+    size_t                 len;
+    int                    block_size;
+};
+
+#define SDIOEMB_UIF_IOC_MAGIC 's'
+
+#define SDIOEMB_UIF_IOCQNUMFUNCS  _IO(SDIOEMB_UIF_IOC_MAGIC,   0)
+#define SDIOEMB_UIF_IOCCMD        _IOWR(SDIOEMB_UIF_IOC_MAGIC, 1, struct sdioemb_uif_cmd)
+#define SDIOEMB_UIF_IOCWAITFORINT _IO(SDIOEMB_UIF_IOC_MAGIC,   2)
+#define SDIOEMB_UIF_IOCTBUSWIDTH  _IO(SDIOEMB_UIF_IOC_MAGIC,   3)
+#define SDIOEMB_UIF_IOCREINSERT   _IO(SDIOEMB_UIF_IOC_MAGIC,   4)
+#define SDIOEMB_UIF_IOCTBUSFREQ   _IO(SDIOEMB_UIF_IOC_MAGIC,   5)
+#define SDIOEMB_UIF_IOCQMANFID    _IO(SDIOEMB_UIF_IOC_MAGIC,   6)
+#define SDIOEMB_UIF_IOCQCARDID    _IO(SDIOEMB_UIF_IOC_MAGIC,   7)
+#define SDIOEMB_UIF_IOCQSTDIF     _IO(SDIOEMB_UIF_IOC_MAGIC,   8)
+#define SDIOEMB_UIF_IOCQMAXBLKSZ  _IO(SDIOEMB_UIF_IOC_MAGIC,   9)
+#define SDIOEMB_UIF_IOCQBLKSZ     _IO(SDIOEMB_UIF_IOC_MAGIC,  10)
+#define SDIOEMB_UIF_IOCTBLKSZ     _IO(SDIOEMB_UIF_IOC_MAGIC,  11)
+
+#endif /* #ifndef LINUX_SDIOEMB_UIF_H */
--- /dev/null
+++ b/drivers/staging/csr/sdioemb/version.h
@@ -0,0 +1,11 @@
+/* Autogenerated by the sdioemb release procedure. */
+#ifndef SDIOEMB_VERSION_H
+#define SDIOEMB_VERSION_H
+
+#define SDIOEMB_RELEASE 31
+
+#ifndef SDIOEMB_RELEASE_EXTRA
+#define SDIOEMB_RELEASE_EXTRA ""
+#endif
+
+#endif /* #ifndef SDIOEMB_VERSION_H */
--- /dev/null
+++ b/drivers/staging/csr/sme_blocking.c
@@ -0,0 +1,1468 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     sme_mgt_blocking.c
+ *
+ * PURPOSE:
+ *      This file contains the driver specific implementation of
+ *      the WEXT <==> SME MGT interface for all SME builds that support WEXT.
+ *
+ * Copyright (C) 2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+#include "unifi_priv.h"
+
+
+/*
+ * This file also contains the implementation of the asyncronous
+ * requests to the SME.
+ *
+ * Before calling an asyncronous SME function, we call sme_init_request()
+ * which gets hold of the SME semaphore and updates the request status.
+ * The semaphore makes sure that there is only one pending request to
+ * the SME at a time.
+ *
+ * Now we are ready to call the SME function, but only if
+ * sme_init_request() has returned 0.
+ *
+ * When the SME function returns, we need to wait
+ * for the reply. This is done in sme_wait_for_reply().
+ * If the request times-out, the request status is set to SME_REQUEST_TIMEDOUT
+ * and the sme_wait_for_reply() returns.
+ *
+ * If the SME replies in time, we call sme_complete_request().
+ * There we change the request status to SME_REQUEST_RECEIVED. This will
+ * wake up the process waiting on sme_wait_for_reply().
+ * It is important that we copy the reply data in priv->sme_reply
+ * before calling sme_complete_request().
+ *
+ * Handling the wext requests, we need to block
+ * until the SME sends the response to our request.
+ * We use the sme_init_request() and sme_wait_for_reply()
+ * to implement this behavior in the following functions:
+ * sme_mgt_wifi_on()
+ * sme_mgt_wifi_off()
+ * sme_mgt_scan_full()
+ * sme_mgt_scan_results_get_async()
+ * sme_mgt_connect()
+ * unifi_mgt_media_status_ind()
+ * sme_mgt_disconnect()
+ * sme_mgt_pmkid()
+ * sme_mgt_key()
+ * sme_mgt_mib_get()
+ * sme_mgt_mib_set()
+ * sme_mgt_versions_get()
+ * sme_mgt_set_value()
+ * sme_mgt_get_value()
+ * sme_mgt_set_value_async()
+ * sme_mgt_get_value_async()
+ * sme_mgt_packet_filter_set()
+ * sme_mgt_tspec()
+ */
+
+
+/*
+ * Handling the suspend and resume system events, we need to block
+ * until the SME sends the response to our indication.
+ * We use the sme_init_request() and sme_wait_for_reply()
+ * to implement this behavior in the following functions:
+ * sme_sys_suspend()
+ * sme_sys_resume()
+ */
+
+#define UNIFI_SME_MGT_SHORT_TIMEOUT    10000
+#define UNIFI_SME_MGT_LONG_TIMEOUT     19000
+#define UNIFI_SME_SYS_LONG_TIMEOUT     10000
+
+#ifdef UNIFI_DEBUG
+# define sme_wait_for_reply(priv, t) _sme_wait_for_reply(priv, t, __func__)
+#else
+# define sme_wait_for_reply(priv, t) _sme_wait_for_reply(priv, t, NULL)
+#endif
+
+static int
+sme_init_request(unifi_priv_t *priv)
+{
+    if (priv == NULL) {
+        unifi_error(priv, "sme_init_request: Invalid priv\n");
+        return -EIO;
+    }
+
+    /* Grab the SME semaphore until the reply comes, or timeout */
+    if (down_interruptible(&priv->sme_sem)) {
+        unifi_error(priv, "sme_init_request: Failed to get SME semaphore\n");
+        return -EIO;
+    }
+    priv->sme_reply.request_status = SME_REQUEST_PENDING;
+
+    return 0;
+
+} /* sme_init_request() */
+
+
+void
+uf_sme_complete_request(unifi_priv_t *priv, CsrResult reply_status, const char *func)
+{
+    if (priv == NULL) {
+        unifi_error(priv, "sme_complete_request: Invalid priv\n");
+        return;
+    }
+
+    if (priv->sme_reply.request_status != SME_REQUEST_PENDING) {
+        unifi_notice(priv,
+                    "sme_complete_request: request not pending %s (s:%d)\n",
+                    (func ? func : ""), priv->sme_reply.request_status);
+        return;
+    }
+    priv->sme_reply.request_status = SME_REQUEST_RECEIVED;
+    priv->sme_reply.reply_status = reply_status;
+
+    wake_up_interruptible(&priv->sme_request_wq);
+
+    return;
+}
+
+
+static int
+_sme_wait_for_reply(unifi_priv_t *priv,
+        unsigned long timeout, const char *func)
+{
+    long r;
+
+    unifi_trace(priv, UDBG5, "sme_wait_for_reply: sleep\n");
+    r = wait_event_interruptible_timeout(priv->sme_request_wq,
+                                         (priv->sme_reply.request_status != SME_REQUEST_PENDING),
+                                         msecs_to_jiffies(timeout));
+    unifi_trace(priv, UDBG5, "sme_wait_for_reply: awake\n");
+
+    if (r == -ERESTARTSYS) {
+        /* The thread was killed */
+        up(&priv->sme_sem);
+        return r;
+    }
+    if ((r == 0) && (priv->sme_reply.request_status != SME_REQUEST_RECEIVED)) {
+        unifi_notice(priv, "Timeout waiting for SME to reply (%s s:%d, t:%d)\n",
+                     (func ? func : ""), priv->sme_reply.request_status, timeout);
+
+        priv->sme_reply.request_status = SME_REQUEST_TIMEDOUT;
+
+        /* Release the SME semaphore that was downed in sme_init_request() */
+        up(&priv->sme_sem);
+
+        return -ETIMEDOUT;
+    }
+
+    /* Release the SME semaphore that was downed in sme_init_request() */
+    up(&priv->sme_sem);
+
+    return 0;
+} /* sme_wait_for_reply() */
+
+
+
+
+#ifdef CSR_SUPPORT_WEXT
+int sme_mgt_wifi_on(unifi_priv_t *priv)
+{
+    CsrUint16 numElements;
+    CsrWifiSmeDataBlock* dataList;
+#ifdef CSR_SUPPORT_WEXT_AP
+    int r;
+#endif
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_wifi_on: invalid smepriv\n");
+        return -EIO;
+    }
+
+    if (priv->mib_data.length) {
+        numElements = 1;
+        dataList = &priv->mib_data;
+    } else {
+        numElements = 0;
+        dataList = NULL;
+    }
+    /* Start the SME */
+#ifdef CSR_SUPPORT_WEXT_AP
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+#endif
+    CsrWifiSmeWifiOnReqSend(0, priv->sta_mac_address, numElements, dataList);
+#ifdef CSR_SUPPORT_WEXT_AP
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_LONG_TIMEOUT);
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_wifi_on: unifi_mgt_wifi_oo_req <-- (r=%d, status=%d)\n",
+                r, priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    return 0;
+#endif
+} /* sme_mgt_wifi_on() */
+
+
+int sme_mgt_wifi_off(unifi_priv_t *priv)
+{
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_wifi_off: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    /* Stop the SME */
+    CsrWifiSmeWifiOffReqSend(0);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_LONG_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_wifi_off: unifi_mgt_wifi_off_req <-- (r=%d, status=%d)\n",
+                r, priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+
+} /* sme_mgt_wifi_off */
+
+int sme_mgt_key(unifi_priv_t *priv, CsrWifiSmeKey *sme_key,
+        CsrWifiSmeListAction action)
+{
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_key: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeKeyReqSend(0, CSR_WIFI_INTERFACE_IN_USE, action, *sme_key);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+}
+
+
+int sme_mgt_scan_full(unifi_priv_t *priv,
+        CsrWifiSsid *specific_ssid,
+        int num_channels,
+        unsigned char *channel_list)
+{
+    CsrWifiMacAddress bcastAddress = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }};
+    CsrBool is_active = (num_channels > 0) ? TRUE : FALSE;
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_scan_full: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_scan_full: -->\n");
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    /* If a channel list is provided, do an active scan */
+    if (is_active) {
+        unifi_trace(priv, UDBG1,
+                    "channel list - num_channels: %d, active scan\n",
+                    num_channels);
+    }
+
+    CsrWifiSmeScanFullReqSend(0,
+                              specific_ssid->length?1:0, /* 0 or 1 SSIDS */
+                              specific_ssid,
+                              bcastAddress,
+                              is_active,
+                              CSR_WIFI_SME_BSS_TYPE_ANY_BSS,
+                              CSR_WIFI_SME_SCAN_TYPE_ALL,
+                              (CsrUint16)num_channels, channel_list,
+                              0, NULL);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_LONG_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_scan_full: <-- (status=%d)\n", priv->sme_reply.reply_status);
+    if (priv->sme_reply.reply_status == CSR_WIFI_RESULT_UNAVAILABLE) {
+        return 0; /* initial scan already underway */
+    } else {
+        return convert_sme_error(priv->sme_reply.reply_status);
+    }
+}
+
+
+int sme_mgt_scan_results_get_async(unifi_priv_t *priv,
+        struct iw_request_info *info,
+        char *scan_results,
+        long scan_results_len)
+{
+    CsrUint16 scan_result_list_count;
+    CsrWifiSmeScanResult *scan_result_list;
+    CsrWifiSmeScanResult *scan_result;
+    int r;
+    int i;
+    char *current_ev = scan_results;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_scan_results_get_async: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeScanResultsGetReqSend(0);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_LONG_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    scan_result_list_count = priv->sme_reply.reply_scan_results_count;
+    scan_result_list = priv->sme_reply.reply_scan_results;
+    unifi_trace(priv, UDBG2,
+                "scan_results: Scan returned %d, numElements=%d\n",
+                r, scan_result_list_count);
+
+    /* OK, now we have the scan results */
+    for (i = 0; i < scan_result_list_count; ++i) {
+        scan_result = &scan_result_list[i];
+
+        unifi_trace(priv, UDBG2, "Scan Result: %.*s\n",
+                    scan_result->ssid.length,
+                    scan_result->ssid.ssid);
+
+        r = unifi_translate_scan(priv->netdev[0], info,
+                                 current_ev,
+                                 scan_results + scan_results_len,
+                                 scan_result, i+1);
+
+        if (r < 0) {
+            CsrPmemFree(scan_result_list);
+            priv->sme_reply.reply_scan_results_count = 0;
+            priv->sme_reply.reply_scan_results = NULL;
+            return r;
+        }
+
+        current_ev += r;
+    }
+
+    /*
+     * Free the scan results allocated in unifi_mgt_scan_results_get_cfm()
+     * and invalidate the reply_scan_results to avoid re-using
+     * the freed pointers.
+     */
+    CsrPmemFree(scan_result_list);
+    priv->sme_reply.reply_scan_results_count = 0;
+    priv->sme_reply.reply_scan_results = NULL;
+
+    unifi_trace(priv, UDBG2,
+                "scan_results: Scan translated to %d bytes\n",
+                current_ev - scan_results);
+    return (current_ev - scan_results);
+}
+
+
+int sme_mgt_connect(unifi_priv_t *priv)
+{
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_connect: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG2, "sme_mgt_connect: %.*s\n",
+                priv->connection_config.ssid.length,
+                priv->connection_config.ssid.ssid);
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeConnectReqSend(0, CSR_WIFI_INTERFACE_IN_USE, priv->connection_config);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    if (priv->sme_reply.reply_status) {
+        unifi_trace(priv, UDBG1, "sme_mgt_connect: failed with SME status %d\n",
+                    priv->sme_reply.reply_status);
+    }
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+}
+
+
+int sme_mgt_disconnect(unifi_priv_t *priv)
+{
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_disconnect: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeDisconnectReqSend(0, CSR_WIFI_INTERFACE_IN_USE);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_disconnect: <-- (status=%d)\n", priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+}
+
+
+int sme_mgt_pmkid(unifi_priv_t *priv,
+        CsrWifiSmeListAction action,
+        CsrWifiSmePmkidList *pmkid_list)
+{
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_pmkid: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmePmkidReqSend(0, CSR_WIFI_INTERFACE_IN_USE, action,
+                        pmkid_list->pmkidsCount, pmkid_list->pmkids);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_pmkid: <-- (status=%d)\n", priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+}
+
+
+int sme_mgt_mib_get(unifi_priv_t *priv,
+        unsigned char *varbind, int *length)
+{
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_mib_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    priv->mib_cfm_buffer = varbind;
+    priv->mib_cfm_buffer_length = MAX_VARBIND_LENGTH;
+
+    CsrWifiSmeMibGetReqSend(0, *length, varbind);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        priv->mib_cfm_buffer_length = 0;
+        priv->mib_cfm_buffer = NULL;
+        return r;
+    }
+
+    *length = priv->mib_cfm_buffer_length;
+
+    priv->mib_cfm_buffer_length = 0;
+    priv->mib_cfm_buffer = NULL;
+    unifi_trace(priv, UDBG4, "sme_mgt_mib_get: <-- (status=%d)\n", priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+}
+
+int sme_mgt_mib_set(unifi_priv_t *priv,
+        unsigned char *varbind, int length)
+{
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_mib_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeMibSetReqSend(0, length, varbind);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_mib_set: <-- (status=%d)\n", priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+}
+
+#endif /* CSR_SUPPORT_WEXT */
+
+int sme_mgt_power_config_set(unifi_priv_t *priv, CsrWifiSmePowerConfig *powerConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_set_value_async: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmePowerConfigSetReqSend(0, *powerConfig);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_set_value_async: unifi_mgt_set_value_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_set_value: invalid smepriv\n");
+        return -EIO;
+    }
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtPowerConfigSetReq(priv->smepriv, *powerConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+int sme_mgt_sme_config_set(unifi_priv_t *priv, CsrWifiSmeStaConfig *staConfig, CsrWifiSmeDeviceConfig *deviceConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_sme_config_set: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeSmeStaConfigSetReqSend(0, CSR_WIFI_INTERFACE_IN_USE, *staConfig);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_sme_config_set: CsrWifiSmeSmeStaConfigSetReq <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeSmeCommonConfigSetReqSend(0, *deviceConfig);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_sme_config_set: CsrWifiSmeSmeCommonConfigSetReq <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_sme_config_set: invalid smepriv\n");
+        return -EIO;
+    }
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtSmeConfigSetReq(priv->smepriv, *staConfig);
+    status = CsrWifiSmeMgtDeviceConfigSetReq(priv->smepriv, *deviceConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+#ifdef CSR_SUPPORT_WEXT
+
+int sme_mgt_mib_config_set(unifi_priv_t *priv, CsrWifiSmeMibConfig *mibConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_mib_config_set: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeMibConfigSetReqSend(0, *mibConfig);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_mib_config_set: unifi_mgt_set_mib_config_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_mib_config_set: invalid smepriv\n");
+        return -EIO;
+    }
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtMibConfigSetReq(priv->smepriv, *mibConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+int sme_mgt_coex_config_set(unifi_priv_t *priv, CsrWifiSmeCoexConfig *coexConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_coex_config_set: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeCoexConfigSetReqSend(0, *coexConfig);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_coex_config_set: unifi_mgt_set_mib_config_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_coex_config_set: invalid smepriv\n");
+        return -EIO;
+    }
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtCoexConfigSetReq(priv->smepriv, *coexConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+#endif /* CSR_SUPPORT_WEXT */
+
+int sme_mgt_host_config_set(unifi_priv_t *priv, CsrWifiSmeHostConfig *hostConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_host_config_set: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeHostConfigSetReqSend(0, CSR_WIFI_INTERFACE_IN_USE, *hostConfig);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_host_config_set: unifi_mgt_set_host_config_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_host_config_set: invalid smepriv\n");
+        return -EIO;
+    }
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtHostConfigSetReq(priv->smepriv, *hostConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+#ifdef CSR_SUPPORT_WEXT
+
+int sme_mgt_versions_get(unifi_priv_t *priv, CsrWifiSmeVersions *versions)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_versions_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_versions_get: unifi_mgt_versions_get_req -->\n");
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeVersionsGetReqSend(0);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (versions != NULL) {
+        memcpy((unsigned char*)versions,
+               (unsigned char*)&priv->sme_reply.versions,
+               sizeof(CsrWifiSmeVersions));
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_versions_get: unifi_mgt_versions_get_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtVersionsGetReq(priv->smepriv, versions);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+#endif /* CSR_SUPPORT_WEXT */
+
+int sme_mgt_power_config_get(unifi_priv_t *priv, CsrWifiSmePowerConfig *powerConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_power_config_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_power_config_get: unifi_mgt_power_config_req -->\n");
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmePowerConfigGetReqSend(0);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (powerConfig != NULL) {
+        memcpy((unsigned char*)powerConfig,
+               (unsigned char*)&priv->sme_reply.powerConfig,
+               sizeof(CsrWifiSmePowerConfig));
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_get_versions: unifi_mgt_power_config_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtPowerConfigGetReq(priv->smepriv, powerConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+int sme_mgt_host_config_get(unifi_priv_t *priv, CsrWifiSmeHostConfig *hostConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_host_config_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_host_config_get: unifi_mgt_host_config_get_req -->\n");
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeHostConfigGetReqSend(0, CSR_WIFI_INTERFACE_IN_USE);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (hostConfig != NULL) {
+        memcpy((unsigned char*)hostConfig,
+               (unsigned char*)&priv->sme_reply.hostConfig,
+               sizeof(CsrWifiSmeHostConfig));
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_host_config_get: unifi_mgt_host_config_get_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtHostConfigGetReq(priv->smepriv, hostConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+int sme_mgt_sme_config_get(unifi_priv_t *priv, CsrWifiSmeStaConfig *staConfig, CsrWifiSmeDeviceConfig *deviceConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_sme_config_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_sme_config_get: unifi_mgt_sme_config_get_req -->\n");
+
+    /* Common device config */
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeSmeCommonConfigGetReqSend(0);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (deviceConfig != NULL) {
+        memcpy((unsigned char*)deviceConfig,
+               (unsigned char*)&priv->sme_reply.deviceConfig,
+               sizeof(CsrWifiSmeDeviceConfig));
+    }
+
+    /* STA config */
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeSmeStaConfigGetReqSend(0, CSR_WIFI_INTERFACE_IN_USE);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (staConfig != NULL) {
+        memcpy((unsigned char*)staConfig,
+               (unsigned char*)&priv->sme_reply.staConfig,
+               sizeof(CsrWifiSmeStaConfig));
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_sme_config_get: unifi_mgt_sme_config_get_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtSmeConfigGetReq(priv->smepriv, staConfig);
+    status = CsrWifiSmeMgtDeviceConfigGetReq(priv->smepriv, deviceConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+int sme_mgt_coex_info_get(unifi_priv_t *priv, CsrWifiSmeCoexInfo *coexInfo)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_coex_info_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_coex_info_get: unifi_mgt_coex_info_get_req -->\n");
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeCoexInfoGetReqSend(0);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (coexInfo != NULL) {
+        memcpy((unsigned char*)coexInfo,
+               (unsigned char*)&priv->sme_reply.coexInfo,
+               sizeof(CsrWifiSmeCoexInfo));
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_coex_info_get: unifi_mgt_coex_info_get_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtCoexInfoGetReq(priv->smepriv, coexInfo);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+#ifdef CSR_SUPPORT_WEXT
+
+int sme_mgt_coex_config_get(unifi_priv_t *priv, CsrWifiSmeCoexConfig *coexConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_coex_config_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_coex_config_get: unifi_mgt_coex_config_get_req -->\n");
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeCoexConfigGetReqSend(0);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (coexConfig != NULL) {
+        memcpy((unsigned char*)coexConfig,
+               (unsigned char*)&priv->sme_reply.coexConfig,
+               sizeof(CsrWifiSmeCoexConfig));
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_coex_config_get: unifi_mgt_coex_config_get_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtCoexConfigGetReq(priv->smepriv, coexConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+int sme_mgt_mib_config_get(unifi_priv_t *priv, CsrWifiSmeMibConfig *mibConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_mib_config_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_mib_config_get: unifi_mgt_mib_config_get_req -->\n");
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeMibConfigGetReqSend(0);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (mibConfig != NULL) {
+        memcpy((unsigned char*)mibConfig,
+               (unsigned char*)&priv->sme_reply.mibConfig,
+               sizeof(CsrWifiSmeMibConfig));
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_mib_config_get: unifi_mgt_mib_config_get_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtMibConfigGetReq(priv->smepriv, mibConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+int sme_mgt_connection_info_get(unifi_priv_t *priv, CsrWifiSmeConnectionInfo *connectionInfo)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_connection_info_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_connection_info_get: unifi_mgt_connection_info_get_req -->\n");
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeConnectionInfoGetReqSend(0, CSR_WIFI_INTERFACE_IN_USE);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (connectionInfo != NULL) {
+        memcpy((unsigned char*)connectionInfo,
+               (unsigned char*)&priv->sme_reply.connectionInfo,
+               sizeof(CsrWifiSmeConnectionInfo));
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_connection_info_get: unifi_mgt_connection_info_get_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtConnectionInfoGetReq(priv->smepriv, connectionInfo);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+int sme_mgt_connection_config_get(unifi_priv_t *priv, CsrWifiSmeConnectionConfig *connectionConfig)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_connection_config_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_connection_config_get: unifi_mgt_connection_config_get_req -->\n");
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeConnectionConfigGetReqSend(0, CSR_WIFI_INTERFACE_IN_USE);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (connectionConfig != NULL) {
+        memcpy((unsigned char*)connectionConfig,
+               (unsigned char*)&priv->sme_reply.connectionConfig,
+               sizeof(CsrWifiSmeConnectionConfig));
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_connection_config_get: unifi_mgt_connection_config_get_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtConnectionConfigGetReq(priv->smepriv, connectionConfig);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+int sme_mgt_connection_stats_get(unifi_priv_t *priv, CsrWifiSmeConnectionStats *connectionStats)
+{
+#ifdef CSR_SME_USERSPACE
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_connection_stats_get: invalid smepriv\n");
+        return -EIO;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_connection_stats_get: unifi_mgt_connection_stats_get_req -->\n");
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeConnectionStatsGetReqSend(0, CSR_WIFI_INTERFACE_IN_USE);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    /* store the reply */
+    if (connectionStats != NULL) {
+        memcpy((unsigned char*)connectionStats,
+               (unsigned char*)&priv->sme_reply.connectionStats,
+               sizeof(CsrWifiSmeConnectionStats));
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_mgt_connection_stats_get: unifi_mgt_connection_stats_get_req <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+
+    return convert_sme_error(priv->sme_reply.reply_status);
+#else
+    CsrResult status;
+    CsrWifiSmeMgtClaimSyncAccess(priv->smepriv);
+    status = CsrWifiSmeMgtConnectionStatsGetReq(priv->smepriv, connectionStats);
+    CsrWifiSmeMgtReleaseSyncAccess(priv->smepriv);
+    return convert_sme_error(status);
+#endif
+}
+
+#endif /* CSR_SUPPORT_WEXT */
+
+int sme_mgt_packet_filter_set(unifi_priv_t *priv)
+{
+    CsrWifiIp4Address ipAddress = {{0xFF, 0xFF, 0xFF, 0xFF }};
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_packet_filter_set: invalid smepriv\n");
+        return -EIO;
+    }
+    if (priv->packet_filters.arp_filter) {
+        ipAddress.a[0] = (priv->sta_ip_address      ) & 0xFF;
+        ipAddress.a[1] = (priv->sta_ip_address >>  8) & 0xFF;
+        ipAddress.a[2] = (priv->sta_ip_address >> 16) & 0xFF;
+        ipAddress.a[3] = (priv->sta_ip_address >> 24) & 0xFF;
+    }
+
+    unifi_trace(priv, UDBG5,
+                "sme_mgt_packet_filter_set: IP address %d.%d.%d.%d\n",
+                ipAddress.a[0], ipAddress.a[1],
+                ipAddress.a[2], ipAddress.a[3]);
+
+    /* Doesn't block for a confirm */
+    CsrWifiSmePacketFilterSetReqSend(0, CSR_WIFI_INTERFACE_IN_USE,
+                                     priv->packet_filters.tclas_ies_length,
+                                     priv->filter_tclas_ies,
+                                     priv->packet_filters.filter_mode,
+                                     ipAddress);
+    return 0;
+}
+
+int sme_mgt_tspec(unifi_priv_t *priv, CsrWifiSmeListAction action,
+        CsrUint32 tid, CsrWifiSmeDataBlock *tspec, CsrWifiSmeDataBlock *tclas)
+{
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_mgt_tspec: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiSmeTspecReqSend(0, CSR_WIFI_INTERFACE_IN_USE,
+                           action, tid, TRUE, 0,
+                           tspec->length, tspec->data,
+                           tclas->length, tclas->data);
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4, "sme_mgt_tspec: <-- (status=%d)\n", priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+}
+
+
+
+int sme_sys_suspend(unifi_priv_t *priv)
+{
+    int r;
+    CsrResult csrResult;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_sys_suspend: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    /* For powered suspend, tell the resume's wifi_on() not to reinit UniFi */
+    priv->wol_suspend = (enable_wol == UNIFI_WOL_OFF) ? FALSE : TRUE;
+
+    /* Suspend the SME, which will cause it to power down UniFi */
+    CsrWifiRouterCtrlSuspendIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0, 0, priv->wol_suspend);
+    r = sme_wait_for_reply(priv, UNIFI_SME_SYS_LONG_TIMEOUT);
+    if (r) {
+        /* No reply - forcibly power down in case the request wasn't processed */
+        unifi_notice(priv,
+                     "suspend: SME did not reply %s, ",
+                     priv->ptest_mode ? "leave powered" : "power off UniFi anyway\n");
+
+        /* Leave power on for production test, though */
+        if (!priv->ptest_mode) {
+            /* Put UniFi to deep sleep, in case we can not power it off */
+            CsrSdioClaim(priv->sdio);
+            csrResult = unifi_force_low_power_mode(priv->card);
+
+            /* For WOL, the UniFi must stay powered */
+            if (!priv->wol_suspend) {
+                unifi_trace(priv, UDBG1, "Power off\n");
+                CsrSdioPowerOff(priv->sdio);
+            }
+            CsrSdioRelease(priv->sdio);
+        }
+    }
+
+    if (priv->wol_suspend) {
+        unifi_trace(priv, UDBG1, "UniFi left powered for WOL\n");
+
+        /* For PIO WOL, disable SDIO interrupt to enable PIO mode in the f/w */
+        if (enable_wol == UNIFI_WOL_PIO) {
+            unifi_trace(priv, UDBG1, "Remove IRQ to enable PIO WOL\n");
+            if (csr_sdio_linux_remove_irq(priv->sdio)) {
+                unifi_notice(priv, "WOL csr_sdio_linux_remove_irq failed\n");
+            }
+        }
+    }
+
+    /* Consider UniFi to be uninitialised */
+    priv->init_progress = UNIFI_INIT_NONE;
+
+    unifi_trace(priv, UDBG1, "sme_sys_suspend: <-- (r=%d status=%d)\n", r, priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+}
+
+
+int sme_sys_resume(unifi_priv_t *priv)
+{
+    int r;
+
+    unifi_trace(priv, UDBG1, "sme_sys_resume %s\n", priv->wol_suspend ? "warm" : "");
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_sys_resume: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiRouterCtrlResumeIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0, priv->wol_suspend);
+
+    if (priv->ptest_mode == 1) {
+        r = sme_wait_for_reply(priv, UNIFI_SME_SYS_LONG_TIMEOUT);
+        if (r) {
+            /* No reply - forcibly power down in case the request wasn't processed */
+            unifi_notice(priv,
+                    "resume: SME did not reply, return success anyway\n");
+        }
+    } else {
+
+        /*
+         * We are not going to wait for the reply because the SME might be in
+         * the userspace. In this case the event will reach it when the kernel
+         * resumes. So, release now the SME semaphore that was downed in
+         * sme_init_request().
+         */
+        up(&priv->sme_sem);
+    }
+
+    return 0;
+}
+
+#ifdef CSR_SUPPORT_WEXT_AP
+int sme_ap_stop(unifi_priv_t *priv,CsrUint16 interface_tag)
+{
+    int r;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_ap_stop: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiNmeApStopReqSend(0,interface_tag);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_ap_stop <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+
+}
+
+int sme_ap_start(unifi_priv_t *priv,CsrUint16 interface_tag,
+                 CsrWifiSmeApConfig_t * ap_config)
+{
+    int r;
+    CsrWifiSmeApP2pGoConfig p2p_go_param;
+    memset(&p2p_go_param,0,sizeof(CsrWifiSmeApP2pGoConfig));
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_ap_start: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiNmeApStartReqSend(0,interface_tag,CSR_WIFI_AP_TYPE_LEGACY,FALSE,
+                             ap_config->ssid,1,ap_config->channel,
+                             ap_config->credentials,ap_config->max_connections,
+                             p2p_go_param,FALSE);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+    if (r) {
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4,
+                "sme_ap_start <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+}
+
+int sme_ap_config(unifi_priv_t *priv,
+                  CsrWifiSmeApMacConfig *ap_mac_config,
+                  CsrWifiNmeApConfig *group_security_config)
+{
+    int r;
+    CsrWifiSmeApP2pGoConfig p2p_go_param;
+    memset(&p2p_go_param,0,sizeof(CsrWifiSmeApP2pGoConfig));
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_ap_config: invalid smepriv\n");
+        return -EIO;
+    }
+
+    r = sme_init_request(priv);
+    if (r) {
+        return -EIO;
+    }
+
+    CsrWifiNmeApConfigSetReqSend(0,*group_security_config,
+                                 *ap_mac_config);
+
+    r = sme_wait_for_reply(priv, UNIFI_SME_MGT_SHORT_TIMEOUT);
+
+    unifi_trace(priv, UDBG4,
+                "sme_ap_config <-- (r=%d status=%d)\n",
+                r, priv->sme_reply.reply_status);
+    return convert_sme_error(priv->sme_reply.reply_status);
+}
+#endif
--- /dev/null
+++ b/drivers/staging/csr/sme_mgt.c
@@ -0,0 +1,1018 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     sme_mgt.c
+ *
+ * PURPOSE:
+ *      This file contains the driver specific implementation of
+ *      the SME MGT SAP.
+ *      It is part of the porting exercise.
+ *
+ * Copyright (C) 2008-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+#include "csr_wifi_hip_unifiversion.h"
+#include "unifi_priv.h"
+#include "csr_wifi_hip_conversions.h"
+/*
+ * This file implements the SME MGT API. It contains the following functions:
+ * CsrWifiSmeWifiFlightmodeCfmSend()
+ * CsrWifiSmeWifiOnCfmSend()
+ * CsrWifiSmeWifiOffCfmSend()
+ * CsrWifiSmeWifiOffIndSend()
+ * CsrWifiSmeScanFullCfmSend()
+ * CsrWifiSmeScanResultsGetCfmSend()
+ * CsrWifiSmeScanResultIndSend()
+ * CsrWifiSmeScanResultsFlushCfmSend()
+ * CsrWifiSmeConnectCfmSend()
+ * CsrWifiSmeMediaStatusIndSend()
+ * CsrWifiSmeDisconnectCfmSend()
+ * CsrWifiSmeKeyCfmSend()
+ * CsrWifiSmeMulticastAddressCfmSend()
+ * CsrWifiSmeSetValueCfmSend()
+ * CsrWifiSmeGetValueCfmSend()
+ * CsrWifiSmeMicFailureIndSend()
+ * CsrWifiSmePmkidCfmSend()
+ * CsrWifiSmePmkidCandidateListIndSend()
+ * CsrWifiSmeMibSetCfmSend()
+ * CsrWifiSmeMibGetCfmSend()
+ * CsrWifiSmeMibGetNextCfmSend()
+ * CsrWifiSmeConnectionQualityIndSend()
+ * CsrWifiSmePacketFilterSetCfmSend()
+ * CsrWifiSmeTspecCfmSend()
+ * CsrWifiSmeTspecIndSend()
+ * CsrWifiSmeBlacklistCfmSend()
+ * CsrWifiSmeEventMaskSetCfmSend()
+ * CsrWifiSmeRoamStartIndSend()
+ * CsrWifiSmeRoamCompleteIndSend()
+ * CsrWifiSmeAssociationStartIndSend()
+ * CsrWifiSmeAssociationCompleteIndSend()
+ * CsrWifiSmeIbssStationIndSend()
+ */
+
+
+void CsrWifiSmeMicFailureIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeMicFailureInd* ind = (CsrWifiSmeMicFailureInd*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeMicFailureIndSend: invalid priv\n");
+        return;
+    }
+
+    unifi_trace(priv, UDBG1,
+                "CsrWifiSmeMicFailureIndSend: count=%d, KeyType=%d\n",
+                ind->count, ind->keyType);
+
+    wext_send_michaelmicfailure_event(priv, ind->count, ind->address, ind->keyType, ind->interfaceTag);
+#endif
+}
+
+
+void CsrWifiSmePmkidCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmePmkidCfm* cfm = (CsrWifiSmePmkidCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmePmkidCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    /*
+     * WEXT never does a GET operation the PMKIDs, so we don't need
+     * handle data returned in pmkids.
+     */
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+
+void CsrWifiSmePmkidCandidateListIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmePmkidCandidateListInd* ind = (CsrWifiSmePmkidCandidateListInd*)msg;
+    int i;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "CsrWifiSmePmkidCandidateListIndSend: invalid smepriv\n");
+        return;
+    }
+
+    for (i = 0; i < ind->pmkidCandidatesCount; i++)
+    {
+        wext_send_pmkid_candidate_event(priv, ind->pmkidCandidates[i].bssid, ind->pmkidCandidates[i].preAuthAllowed, ind->interfaceTag);
+    }
+#endif
+}
+
+void CsrWifiSmeScanResultsFlushCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeScanResultsGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeScanResultsGetCfm* cfm = (CsrWifiSmeScanResultsGetCfm*)msg;
+    int bytesRequired = cfm->scanResultsCount * sizeof(CsrWifiSmeScanResult);
+    int i;
+    CsrUint8* current_buff;
+    CsrWifiSmeScanResult* scanCopy;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeScanResultsGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    /* Calc the size of the buffer reuired */
+    for (i = 0; i < cfm->scanResultsCount; ++i) {
+        const CsrWifiSmeScanResult *scan_result = &cfm->scanResults[i];
+        bytesRequired += scan_result->informationElementsLength;
+    }
+
+    /* Take a Copy of the scan Results :-) */
+    scanCopy = CsrPmemAlloc(bytesRequired);
+    memcpy(scanCopy, cfm->scanResults, sizeof(CsrWifiSmeScanResult) * cfm->scanResultsCount);
+
+    /* Take a Copy of the Info Elements AND update the scan result pointers */
+    current_buff = (CsrUint8*)&scanCopy[cfm->scanResultsCount];
+    for (i = 0; i < cfm->scanResultsCount; ++i)
+    {
+        CsrWifiSmeScanResult *scan_result = &scanCopy[i];
+        CsrMemCpy(current_buff, scan_result->informationElements, scan_result->informationElementsLength);
+        scan_result->informationElements = current_buff;
+        current_buff += scan_result->informationElementsLength;
+    }
+
+    priv->sme_reply.reply_scan_results_count = cfm->scanResultsCount;
+    priv->sme_reply.reply_scan_results = scanCopy;
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+
+void CsrWifiSmeScanFullCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeScanFullCfm* cfm = (CsrWifiSmeScanFullCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeScanFullCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+
+void CsrWifiSmeScanResultIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+
+}
+
+
+void CsrWifiSmeConnectCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeConnectCfm* cfm = (CsrWifiSmeConnectCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeConnectCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+
+void CsrWifiSmeDisconnectCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeDisconnectCfm* cfm = (CsrWifiSmeDisconnectCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeDisconnectCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+
+void CsrWifiSmeKeyCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeKeyCfm* cfm = (CsrWifiSmeKeyCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeKeyCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+
+void CsrWifiSmeMulticastAddressCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeMulticastAddressCfm* cfm = (CsrWifiSmeMulticastAddressCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeMulticastAddressCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeWifiFlightmodeCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeWifiFlightmodeCfm* cfm = (CsrWifiSmeWifiFlightmodeCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeWifiFlightmodeCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeWifiOnCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeWifiOnCfm* cfm = (CsrWifiSmeWifiOnCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeWifiOnCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    unifi_trace(priv, UDBG4,
+                "CsrWifiSmeWifiOnCfmSend: wake up status %d\n", cfm->status);
+#ifdef CSR_SUPPORT_WEXT_AP
+    sme_complete_request(priv, cfm->status);
+#endif
+
+#endif
+}
+
+void CsrWifiSmeWifiOffCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeWifiOffCfm* cfm = (CsrWifiSmeWifiOffCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeWifiOffCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+
+void CsrWifiSmeWifiOffIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeWifiOffInd* ind = (CsrWifiSmeWifiOffInd*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiRouterCtrlStoppedReqSend: Invalid ospriv.\n");
+        return;
+    }
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlStoppedReqSend: invalid smepriv\n");
+        return;
+    }
+
+    /*
+     * If the status indicates an error, the SME is in a stopped state.
+     * We need to start it again in order to reinitialise UniFi.
+     */
+    switch (ind->reason) {
+        case CSR_WIFI_SME_CONTROL_INDICATION_ERROR:
+          unifi_trace(priv, UDBG1,
+                      "CsrWifiRouterCtrlStoppedReqSend: Restarting SME (ind:%d)\n",
+                      ind->reason);
+
+          /* On error, restart the SME */
+          sme_mgt_wifi_on(priv);
+          break;
+        case CSR_WIFI_SME_CONTROL_INDICATION_EXIT:
+#ifdef CSR_SUPPORT_WEXT_AP
+          sme_complete_request(priv, 0);
+#endif
+          break;
+        default:
+          break;
+    }
+
+#endif
+}
+
+void CsrWifiSmeVersionsGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeVersionsGetCfm* cfm = (CsrWifiSmeVersionsGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeVersionsGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.versions = cfm->versions;
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmePowerConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmePowerConfigGetCfm* cfm = (CsrWifiSmePowerConfigGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmePowerConfigGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.powerConfig = cfm->powerConfig;
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeHostConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeHostConfigGetCfm* cfm = (CsrWifiSmeHostConfigGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeHostConfigGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.hostConfig = cfm->hostConfig;
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeCoexInfoGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeCoexInfoGetCfm* cfm = (CsrWifiSmeCoexInfoGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeCoexInfoGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.coexInfo = cfm->coexInfo;
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeCoexConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeCoexConfigGetCfm* cfm = (CsrWifiSmeCoexConfigGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeCoexConfigGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.coexConfig = cfm->coexConfig;
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeMibConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeMibConfigGetCfm* cfm = (CsrWifiSmeMibConfigGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeMibConfigGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.mibConfig = cfm->mibConfig;
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeConnectionInfoGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeConnectionInfoGetCfm* cfm = (CsrWifiSmeConnectionInfoGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeConnectionInfoGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.connectionInfo = cfm->connectionInfo;
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeConnectionConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeConnectionConfigGetCfm* cfm = (CsrWifiSmeConnectionConfigGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeConnectionConfigGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.connectionConfig = cfm->connectionConfig;
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeConnectionStatsGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeConnectionStatsGetCfm* cfm = (CsrWifiSmeConnectionStatsGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeConnectionStatsGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.connectionStats = cfm->connectionStats;
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeMibSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeMibSetCfm* cfm = (CsrWifiSmeMibSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeMibSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeMibGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeMibGetCfm* cfm = (CsrWifiSmeMibGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeMibGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    if (cfm->mibAttribute == NULL) {
+        unifi_error(priv, "CsrWifiSmeMibGetCfmSend: Empty reply.\n");
+        sme_complete_request(priv, cfm->status);
+        return;
+    }
+
+    if ((priv->mib_cfm_buffer != NULL) &&
+        (priv->mib_cfm_buffer_length >= cfm->mibAttributeLength)) {
+        memcpy(priv->mib_cfm_buffer, cfm->mibAttribute, cfm->mibAttributeLength);
+        priv->mib_cfm_buffer_length = cfm->mibAttributeLength;
+    } else {
+        unifi_error(priv,
+                    "CsrWifiSmeMibGetCfmSend: No room to store MIB data (have=%d need=%d).\n",
+                    priv->mib_cfm_buffer_length, cfm->mibAttributeLength);
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeMibGetNextCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeMibGetNextCfm* cfm = (CsrWifiSmeMibGetNextCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeMibGetNextCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    /* Need to copy MIB data */
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeConnectionQualityIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeConnectionQualityInd* ind = (CsrWifiSmeConnectionQualityInd*)msg;
+    int signal, noise, snr;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeConnectionQualityIndSend: Invalid ospriv.\n");
+        return;
+    }
+
+    /*
+     * level and noise below are mapped into an unsigned 8 bit number,
+     * ranging from [-192; 63]. The way this is achieved is simply to
+     * add 0x100 onto the number if it is negative,
+     * once clipped to the correct range.
+     */
+    signal = ind->linkQuality.unifiRssi;
+    /* Clip range of snr */
+    snr    = (ind->linkQuality.unifiSnr > 0) ? ind->linkQuality.unifiSnr : 0; /* In dB relative, from 0 - 255 */
+    snr    = (snr < 255) ? snr : 255;
+    noise  = signal - snr;
+
+    /* Clip range of signal */
+    signal = (signal < 63) ? signal : 63;
+    signal = (signal > -192) ? signal : -192;
+
+    /* Clip range of noise */
+    noise = (noise < 63) ? noise : 63;
+    noise = (noise > -192) ? noise : -192;
+
+    /* Make u8 */
+    signal = ( signal < 0 ) ? signal + 0x100 : signal;
+    noise = ( noise < 0 ) ? noise + 0x100 : noise;
+
+    priv->wext_wireless_stats.qual.level   = (u8)signal; /* -192 : 63 */
+    priv->wext_wireless_stats.qual.noise   = (u8)noise;  /* -192 : 63 */
+    priv->wext_wireless_stats.qual.qual    = snr;         /* 0 : 255 */
+    priv->wext_wireless_stats.qual.updated = 0;
+
+#if WIRELESS_EXT > 16
+    priv->wext_wireless_stats.qual.updated |= IW_QUAL_LEVEL_UPDATED |
+                                              IW_QUAL_NOISE_UPDATED |
+                                              IW_QUAL_QUAL_UPDATED;
+#if WIRELESS_EXT > 18
+    priv->wext_wireless_stats.qual.updated |= IW_QUAL_DBM;
+#endif
+#endif
+#endif
+}
+
+void CsrWifiSmePacketFilterSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmePacketFilterSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    /* The packet filter set request does not block for a reply */
+}
+
+void CsrWifiSmeTspecCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeTspecCfm* cfm = (CsrWifiSmeTspecCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeTspecCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeTspecIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeBlacklistCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeEventMaskSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+
+void CsrWifiSmeRoamStartIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeRoamCompleteIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    /* This is called when the association completes, before any 802.1x authentication */
+}
+
+void CsrWifiSmeAssociationStartIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeAssociationCompleteIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeIbssStationIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeWifiOnIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeRestrictedAccessEnableCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeRestrictedAccessDisableCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+
+void CsrWifiSmeAdhocConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeAdhocConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeAdhocConfigSetCfm* cfm = (CsrWifiSmeAdhocConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeCalibrationDataGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeCalibrationDataSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeCalibrationDataSetCfm* cfm = (CsrWifiSmeCalibrationDataSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeCcxConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeCcxConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeCcxConfigSetCfm* cfm = (CsrWifiSmeCcxConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeCloakedSsidsGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeCloakedSsidsSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeCloakedSsidsSetCfm* cfm = (CsrWifiSmeCloakedSsidsSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+
+void CsrWifiSmeCoexConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeCoexConfigSetCfm* cfm = (CsrWifiSmeCoexConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeHostConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeHostConfigSetCfm* cfm = (CsrWifiSmeHostConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeLinkQualityGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+
+void CsrWifiSmeMibConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeMibConfigSetCfm* cfm = (CsrWifiSmeMibConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmePermanentMacAddressGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmePowerConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmePowerConfigSetCfm* cfm = (CsrWifiSmePowerConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeRegulatoryDomainInfoGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeRoamingConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeMediaStatusIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeMediaStatusInd* ind = (CsrWifiSmeMediaStatusInd*)msg;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "CsrWifiSmeMediaStatusIndSend: invalid smepriv\n");
+        return;
+    }
+
+    if (ind->mediaStatus == CSR_WIFI_SME_MEDIA_STATUS_CONNECTED) {
+        /*
+         * Send wireless-extension event up to userland to announce
+         * connection.
+         */
+        wext_send_assoc_event(priv,
+                              (unsigned char *)ind->connectionInfo.bssid.a,
+                              (unsigned char *)ind->connectionInfo.assocReqInfoElements,
+                              ind->connectionInfo.assocReqInfoElementsLength,
+                              (unsigned char *)ind->connectionInfo.assocRspInfoElements,
+                              ind->connectionInfo.assocRspInfoElementsLength,
+                              (unsigned char *)ind->connectionInfo.assocScanInfoElements,
+                              ind->connectionInfo.assocScanInfoElementsLength);
+
+        unifi_trace(priv, UDBG2,
+                    "CsrWifiSmeMediaStatusIndSend: IBSS=%02X:%02X:%02X:%02X:%02X:%02X\n",
+                    ind->connectionInfo.bssid.a[0],
+                    ind->connectionInfo.bssid.a[1],
+                    ind->connectionInfo.bssid.a[2],
+                    ind->connectionInfo.bssid.a[3],
+                    ind->connectionInfo.bssid.a[4],
+                    ind->connectionInfo.bssid.a[5]);
+
+        sme_mgt_packet_filter_set(priv);
+
+    } else  {
+        /*
+         * Send wireless-extension event up to userland to announce
+         * connection lost to a BSS.
+         */
+        wext_send_disassoc_event(priv);
+    }
+#endif
+}
+
+void CsrWifiSmeRoamingConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeRoamingConfigSetCfm* cfm = (CsrWifiSmeRoamingConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeRoamingConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeScanConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeScanConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+#ifdef CSR_SUPPORT_WEXT
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeScanConfigSetCfm* cfm = (CsrWifiSmeScanConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+#endif
+}
+
+void CsrWifiSmeStationMacAddressGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeSmeCommonConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeSmeCommonConfigGetCfm* cfm = (CsrWifiSmeSmeCommonConfigGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeCommonConfigGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.deviceConfig = cfm->deviceConfig;
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeSmeStaConfigGetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeSmeStaConfigGetCfm* cfm = (CsrWifiSmeSmeStaConfigGetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeStaConfigGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    priv->sme_reply.staConfig = cfm->smeConfig;
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeSmeCommonConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeSmeCommonConfigSetCfm* cfm = (CsrWifiSmeSmeCommonConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeCommonConfigGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeSmeStaConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiSmeSmeStaConfigSetCfm* cfm = (CsrWifiSmeSmeStaConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiSmeSmeStaConfigGetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiSmeGetInterfaceCapabilityCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeErrorIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeInfoIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeCoreDumpIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+void CsrWifiSmeAmpStatusChangeIndHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiSmeActivateCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+void CsrWifiSmeDeactivateCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+#ifdef CSR_SUPPORT_WEXT
+#ifdef CSR_SUPPORT_WEXT_AP
+void CsrWifiNmeApStartCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiNmeApStartCfm* cfm = (CsrWifiNmeApStartCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiNmeApStartCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiNmeApStopCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiNmeApStopCfm* cfm = (CsrWifiNmeApStopCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiNmeApStopCfmSend: Invalid ospriv.\n");
+        return;
+    }
+
+    sme_complete_request(priv, cfm->status);
+}
+
+void CsrWifiNmeApConfigSetCfmHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiNmeApConfigSetCfm* cfm = (CsrWifiNmeApConfigSetCfm*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiNmeApConfigSetCfmSend: Invalid ospriv.\n");
+        return;
+    }
+    sme_complete_request(priv, cfm->status);
+}
+#endif
+#endif
--- /dev/null
+++ b/drivers/staging/csr/sme_native.c
@@ -0,0 +1,591 @@
+/*
+ * ***************************************************************************
+ *
+ *  FILE:     sme_native.c
+ *
+ * Copyright (C) 2005-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ***************************************************************************
+ */
+
+#include <linux/netdevice.h>
+
+#include "unifi_priv.h"
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_conversions.h"
+
+static const unsigned char wildcard_address[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+int
+uf_sme_init(unifi_priv_t *priv)
+{
+    func_enter();
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
+    sema_init(&priv->mlme_blocking_mutex, 1);
+#else
+    init_MUTEX(&priv->mlme_blocking_mutex);
+#endif
+
+#ifdef CSR_SUPPORT_WEXT
+    {
+        int r = uf_init_wext_interface(priv);
+        if (r != 0) {
+            func_exit();
+            return r;
+        }
+    }
+#endif
+
+
+
+    func_exit();
+    return 0;
+} /* uf_sme_init() */
+
+
+void
+uf_sme_deinit(unifi_priv_t *priv)
+{
+
+    func_enter();
+
+    /* Free memory allocated for the scan table */
+/*    unifi_clear_scan_table(priv); */
+
+    /* Cancel any pending workqueue tasks */
+    flush_workqueue(priv->unifi_workqueue);
+
+#ifdef CSR_SUPPORT_WEXT
+    uf_deinit_wext_interface(priv);
+#endif
+
+
+    func_exit();
+} /* uf_sme_deinit() */
+
+
+int sme_mgt_wifi_on(unifi_priv_t *priv)
+{
+    int r,i;
+    CsrInt32 csrResult;
+
+    if (priv == NULL) {
+        return -EINVAL;
+    }
+    /* Initialize the interface mode to None */
+    for (i=0; i<CSR_WIFI_NUM_INTERFACES; i++) {
+        priv->interfacePriv[i]->interfaceMode = 0;
+    }
+
+    /* Set up interface mode so that get_packet_priority() can
+     * select the right QOS priority when WMM is enabled.
+     */
+    priv->interfacePriv[0]->interfaceMode = CSR_WIFI_ROUTER_CTRL_MODE_STA;
+
+    r = uf_request_firmware_files(priv, UNIFI_FW_STA);
+    if (r) {
+        unifi_error(priv, "sme_mgt_wifi_on: Failed to get f/w\n");
+        return r;
+    }
+
+    /*
+     * The request to initialise UniFi might come while UniFi is running.
+     * We need to block all I/O activity until the reset completes, otherwise
+     * an SDIO error might occur resulting an indication to the SME which
+     * makes it think that the initialisation has failed.
+     */
+    priv->bh_thread.block_thread = 1;
+
+    /* Power on UniFi */
+    CsrSdioClaim(priv->sdio);
+    csrResult = CsrSdioPowerOn(priv->sdio);
+    CsrSdioRelease(priv->sdio);
+    if(csrResult != CSR_RESULT_SUCCESS && csrResult != CSR_SDIO_RESULT_NOT_RESET) {
+        return -EIO;
+    }
+
+    if (csrResult == CSR_RESULT_SUCCESS) {
+        /* Initialise UniFi hardware */
+        r = uf_init_hw(priv);
+        if (r) {
+            return r;
+        }
+    }
+
+    /* Re-enable the I/O thread */
+    priv->bh_thread.block_thread = 0;
+
+    /* Disable deep sleep signalling during the firmware initialisation, to
+     * prevent the wakeup mechanism raising the SDIO clock beyond INIT before
+     * the first MLME-RESET.ind. It gets re-enabled at the CONNECTED.ind,
+     * immediately after the MLME-RESET.ind
+     */
+    csrResult = unifi_configure_low_power_mode(priv->card,
+                                           UNIFI_LOW_POWER_DISABLED,
+                                           UNIFI_PERIODIC_WAKE_HOST_DISABLED);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_warning(priv,
+                      "sme_mgt_wifi_on: unifi_configure_low_power_mode() returned an error\n");
+    }
+
+
+    /* Start the I/O thread */
+    CsrSdioClaim(priv->sdio);
+    r = uf_init_bh(priv);
+    if (r) {
+        CsrSdioPowerOff(priv->sdio);
+        CsrSdioRelease(priv->sdio);
+        return r;
+    }
+    CsrSdioRelease(priv->sdio);
+
+    priv->init_progress = UNIFI_INIT_FW_DOWNLOADED;
+
+    return 0;
+}
+
+int
+sme_sys_suspend(unifi_priv_t *priv)
+{
+    const int interfaceNum = 0;     /* FIXME */
+    CsrResult csrResult;
+
+    /* Abort any pending requests. */
+    uf_abort_mlme(priv);
+
+    /* Allow our mlme request to go through. */
+    priv->io_aborted = 0;
+
+    /* Send MLME-RESET.req to UniFi. */
+    unifi_reset_state(priv, priv->netdev[interfaceNum]->dev_addr, 0);
+
+    /* Stop the network traffic */
+    netif_carrier_off(priv->netdev[interfaceNum]);
+
+    /* Put UniFi to deep sleep */
+    CsrSdioClaim(priv->sdio);
+    csrResult = unifi_force_low_power_mode(priv->card);
+    CsrSdioRelease(priv->sdio);
+
+    return 0;
+} /* sme_sys_suspend() */
+
+
+int
+sme_sys_resume(unifi_priv_t *priv)
+{
+#ifdef CSR_SUPPORT_WEXT
+    /* Send disconnect event so clients will re-initialise connection. */
+    memset(priv->wext_conf.current_ssid, 0, UNIFI_MAX_SSID_LEN);
+    memset((void*)priv->wext_conf.current_bssid, 0, ETH_ALEN);
+    priv->wext_conf.capability = 0;
+    wext_send_disassoc_event(priv);
+#endif
+    return 0;
+} /* sme_sys_resume() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  sme_native_log_event
+ *
+ *      Callback function to be registered as the SME event callback.
+ *      Copies the signal content into a new udi_log_t struct and adds
+ *      it to the read queue for the SME client.
+ *
+ *  Arguments:
+ *      arg             This is the value given to unifi_add_udi_hook, in
+ *                      this case a pointer to the client instance.
+ *      signal          Pointer to the received signal.
+ *      signal_len      Size of the signal structure in bytes.
+ *      bulkdata        Pointers to any associated bulk data.
+ *      dir             Direction of the signal. Zero means from host,
+ *                      non-zero means to host.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+sme_native_log_event(ul_client_t *pcli,
+                     const u8 *sig_packed, int sig_len,
+                     const bulk_data_param_t *bulkdata,
+                     int dir)
+{
+    unifi_priv_t *priv;
+    udi_log_t *logptr;
+    u8 *p;
+    int i, r;
+    int signal_len;
+    int total_len;
+    udi_msg_t *msgptr;
+    CSR_SIGNAL signal;
+    ul_client_t *client = pcli;
+
+    func_enter();
+
+    if (client == NULL) {
+        unifi_error(NULL, "sme_native_log_event: client has exited\n");
+        return;
+    }
+
+    priv = uf_find_instance(client->instance);
+    if (!priv) {
+        unifi_error(priv, "invalid priv\n");
+        return;
+    }
+
+    /* Just a sanity check */
+    if ((sig_packed == NULL) || (sig_len <= 0)) {
+        return;
+    }
+
+    /* Get the unpacked signal */
+    r = read_unpack_signal(sig_packed, &signal);
+    if (r == 0) {
+        signal_len = SigGetSize(&signal);
+    } else {
+        CsrUint16 receiver_id = CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sig_packed) + sizeof(CsrUint16)) & 0xFF00;
+
+        /* The control indications are 1 byte, pass them to client. */
+        if (sig_len == 1) {
+            unifi_trace(priv, UDBG5,
+                        "Control indication (0x%x) for native SME.\n",
+                        *sig_packed);
+
+            *(u8*)&signal = *sig_packed;
+            signal_len = sig_len;
+        } else if (receiver_id == 0) {
+            /*
+             * Also "unknown" signals with a ReceiverId of 0 are passed to the client
+             * without unpacking. (This is a code size optimisation to allow signals
+             * that the driver not interested in to be dropped from the unpack code).
+             */
+            unifi_trace(priv, UDBG5,
+                        "Signal 0x%.4X with ReceiverId 0 for native SME.\n",
+                        CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sig_packed));
+
+            *(u8*)&signal = *sig_packed;
+            signal_len = sig_len;
+        } else {
+            unifi_error(priv,
+                        "sme_native_log_event - Received unknown signal 0x%.4X.\n",
+                        CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sig_packed));
+            return;
+        }
+    }
+
+    unifi_trace(priv, UDBG3, "sme_native_log_event: signal 0x%.4X for %d\n",
+                signal.SignalPrimitiveHeader.SignalId,
+                client->client_id);
+
+    total_len = signal_len;
+    /* Calculate the buffer we need to store signal plus bulk data */
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+        total_len += bulkdata->d[i].data_length;
+    }
+
+    /* Allocate log structure plus actual signal. */
+    logptr = (udi_log_t *)kmalloc(sizeof(udi_log_t) + total_len, GFP_KERNEL);
+
+    if (logptr == NULL) {
+        unifi_error(priv,
+                    "Failed to allocate %d bytes for a UDI log record\n",
+                    sizeof(udi_log_t) + total_len);
+        return;
+    }
+
+    /* Fill in udi_log struct */
+    INIT_LIST_HEAD(&logptr->q);
+    msgptr = &logptr->msg;
+    msgptr->length = sizeof(udi_msg_t) + total_len;
+    msgptr->timestamp = jiffies_to_msecs(jiffies);
+    msgptr->direction = dir;
+    msgptr->signal_length = signal_len;
+
+    /* Copy signal and bulk data to the log */
+    p = (u8 *)(msgptr + 1);
+    memcpy(p, &signal, signal_len);
+    p += signal_len;
+
+    /* Append any bulk data */
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+        int len = bulkdata->d[i].data_length;
+
+        /*
+         * Len here might not be the same as the length in the bulk data slot.
+         * The slot length will always be even, but len could be odd.
+         */
+        if (len > 0) {
+            if (bulkdata->d[i].os_data_ptr) {
+                memcpy(p, bulkdata->d[i].os_data_ptr, len);
+            } else {
+                memset(p, 0, len);
+            }
+            p += len;
+        }
+    }
+
+    /* Add to tail of log queue */
+    down(&client->udi_sem);
+    list_add_tail(&logptr->q, &client->udi_log);
+    up(&client->udi_sem);
+
+    /* Wake any waiting user process */
+    wake_up_interruptible(&client->udi_wq);
+
+    func_exit();
+
+} /* sme_native_log_event() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_ta_indicate_protocol
+ *
+ *      Report that a packet of a particular type has been seen
+ *
+ *  Arguments:
+ *      drv_priv        The device context pointer passed to ta_init.
+ *      protocol        The protocol type enum value.
+ *      direction       Whether the packet was a tx or rx.
+ *      src_addr        The source MAC address from the data packet.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *      We defer the actual sending to a background workqueue,
+ *      see uf_ta_ind_wq().
+ * ---------------------------------------------------------------------------
+ */
+void
+unifi_ta_indicate_protocol(void *ospriv,
+                           CsrWifiRouterCtrlTrafficPacketType packet_type,
+                           CsrWifiRouterCtrlProtocolDirection direction,
+                           const CsrWifiMacAddress *src_addr)
+{
+
+} /* unifi_ta_indicate_protocol */
+
+/*
+ * ---------------------------------------------------------------------------
+ * unifi_ta_indicate_sampling
+ *
+ *      Send the TA sampling information to the SME.
+ *
+ *  Arguments:
+ *      drv_priv        The device context pointer passed to ta_init.
+ *      stats           The TA sampling data to send.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+unifi_ta_indicate_sampling(void *ospriv, CsrWifiRouterCtrlTrafficStats *stats)
+{
+
+} /* unifi_ta_indicate_sampling() */
+
+
+void
+unifi_ta_indicate_l4stats(void *ospriv,
+                            CsrUint32 rxTcpThroughput,
+                            CsrUint32 txTcpThroughput,
+                            CsrUint32 rxUdpThroughput,
+                            CsrUint32 txUdpThroughput)
+{
+
+} /* unifi_ta_indicate_l4stats() */
+
+/*
+ * ---------------------------------------------------------------------------
+ * uf_native_process_udi_signal
+ *
+ *      Process interesting signals from the UDI interface.
+ *
+ *  Arguments:
+ *      pcli            A pointer to the client instance.
+ *      signal          Pointer to the received signal.
+ *      signal_len      Size of the signal structure in bytes.
+ *      bulkdata        Pointers to any associated bulk data.
+ *      dir             Direction of the signal. Zero means from host,
+ *                      non-zero means to host.
+ *
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+uf_native_process_udi_signal(ul_client_t *pcli,
+                             const u8 *packed_signal, int packed_signal_len,
+                             const bulk_data_param_t *bulkdata, int dir)
+{
+
+} /* uf_native_process_udi_signal() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  sme_native_mlme_event_handler
+ *
+ *      Callback function to be used as the udi_event_callback when registering
+ *      as a client.
+ *      This function implements a blocking request-reply interface for WEXT.
+ *      To use it, a client specifies this function as the udi_event_callback
+ *      to ul_register_client(). The signal dispatcher in
+ *      unifi_receive_event() will call this function to deliver a signal.
+ *
+ *  Arguments:
+ *      pcli            Pointer to the client instance.
+ *      signal          Pointer to the received signal.
+ *      signal_len      Size of the signal structure in bytes.
+ *      bulkdata        Pointer to structure containing any associated bulk data.
+ *      dir             Direction of the signal. Zero means from host,
+ *                      non-zero means to host.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+sme_native_mlme_event_handler(ul_client_t *pcli,
+                              const u8 *sig_packed, int sig_len,
+                              const bulk_data_param_t *bulkdata,
+                              int dir)
+{
+    CSR_SIGNAL signal;
+    int signal_len;
+    unifi_priv_t *priv = uf_find_instance(pcli->instance);
+    int id, r;
+
+    func_enter();
+
+    /* Just a sanity check */
+    if ((sig_packed == NULL) || (sig_len <= 0)) {
+        return;
+    }
+
+    /* Get the unpacked signal */
+    r = read_unpack_signal(sig_packed, &signal);
+    if (r == 0) {
+        signal_len = SigGetSize(&signal);
+    } else {
+        unifi_error(priv,
+                    "sme_native_mlme_event_handler - Received unknown signal 0x%.4X.\n",
+                    CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sig_packed));
+        return;
+    }
+
+    id = signal.SignalPrimitiveHeader.SignalId;
+    unifi_trace(priv, UDBG4, "wext - Process signal 0x%.4X\n", id);
+
+    /*
+     * Take the appropriate action for the signal.
+     */
+    switch (id) {
+        /*
+         * Confirm replies from UniFi.
+         * These all have zero or one CSR_DATAREF member. (FIXME: check this is still true for softmac)
+         */
+        case CSR_MA_PACKET_CONFIRM_ID:
+        case CSR_MLME_RESET_CONFIRM_ID:
+        case CSR_MLME_GET_CONFIRM_ID:
+        case CSR_MLME_SET_CONFIRM_ID:
+        case CSR_MLME_GET_NEXT_CONFIRM_ID:
+        case CSR_MLME_POWERMGT_CONFIRM_ID:
+        case CSR_MLME_SCAN_CONFIRM_ID:
+        case CSR_MLME_HL_SYNC_CONFIRM_ID:
+        case CSR_MLME_MEASURE_CONFIRM_ID:
+        case CSR_MLME_SETKEYS_CONFIRM_ID:
+        case CSR_MLME_DELETEKEYS_CONFIRM_ID:
+        case CSR_MLME_HL_SYNC_CANCEL_CONFIRM_ID:
+        case CSR_MLME_ADD_PERIODIC_CONFIRM_ID:
+        case CSR_MLME_DEL_PERIODIC_CONFIRM_ID:
+        case CSR_MLME_ADD_AUTONOMOUS_SCAN_CONFIRM_ID:
+        case CSR_MLME_DEL_AUTONOMOUS_SCAN_CONFIRM_ID:
+        case CSR_MLME_SET_PACKET_FILTER_CONFIRM_ID:
+        case CSR_MLME_STOP_MEASURE_CONFIRM_ID:
+        case CSR_MLME_PAUSE_AUTONOMOUS_SCAN_CONFIRM_ID:
+        case CSR_MLME_ADD_TRIGGERED_GET_CONFIRM_ID:
+        case CSR_MLME_DEL_TRIGGERED_GET_CONFIRM_ID:
+        case CSR_MLME_ADD_BLACKOUT_CONFIRM_ID:
+        case CSR_MLME_DEL_BLACKOUT_CONFIRM_ID:
+        case CSR_MLME_ADD_RX_TRIGGER_CONFIRM_ID:
+        case CSR_MLME_DEL_RX_TRIGGER_CONFIRM_ID:
+        case CSR_MLME_CONNECT_STATUS_CONFIRM_ID:
+        case CSR_MLME_MODIFY_BSS_PARAMETER_CONFIRM_ID:
+        case CSR_MLME_ADD_TEMPLATE_CONFIRM_ID:
+        case CSR_MLME_CONFIG_QUEUE_CONFIRM_ID:
+        case CSR_MLME_ADD_TSPEC_CONFIRM_ID:
+        case CSR_MLME_DEL_TSPEC_CONFIRM_ID:
+        case CSR_MLME_START_AGGREGATION_CONFIRM_ID:
+        case CSR_MLME_STOP_AGGREGATION_CONFIRM_ID:
+        case CSR_MLME_SM_START_CONFIRM_ID:
+        case CSR_MLME_LEAVE_CONFIRM_ID:
+        case CSR_MLME_SET_TIM_CONFIRM_ID:
+        case CSR_MLME_GET_KEY_SEQUENCE_CONFIRM_ID:
+        case CSR_MLME_SET_CHANNEL_CONFIRM_ID:
+        case CSR_MLME_ADD_MULTICAST_ADDRESS_CONFIRM_ID:
+        case CSR_DEBUG_GENERIC_CONFIRM_ID:
+            unifi_mlme_copy_reply_and_wakeup_client(pcli, &signal, signal_len, bulkdata);
+            break;
+
+        case CSR_MLME_CONNECTED_INDICATION_ID:
+            /* We currently ignore the connected-ind for softmac f/w development */
+            unifi_info(priv, "CSR_MLME_CONNECTED_INDICATION_ID ignored\n");
+            break;
+
+        default:
+            break;
+    }
+
+    func_exit();
+} /* sme_native_mlme_event_handler() */
+
+
+
+/*
+ * -------------------------------------------------------------------------
+ *  unifi_reset_state
+ *
+ *      Ensure that a MAC address has been set.
+ *      Send the MLME-RESET signal.
+ *      This must be called at least once before starting to do any
+ *      network activities (e.g. scan, join etc).
+ *
+ * Arguments:
+ *      priv            Pointer to device private context struct
+ *      macaddr         Pointer to chip MAC address.
+ *                      If this is FF:FF:FF:FF:FF:FF it will be replaced
+ *                      with the MAC address from the chip.
+ *      set_default_mib 1 if the f/w must reset the MIB to the default values
+ *                      0 otherwise
+ *
+ * Returns:
+ *      0 on success, an error code otherwise.
+ * -------------------------------------------------------------------------
+ */
+int
+unifi_reset_state(unifi_priv_t *priv, unsigned char *macaddr,
+                  unsigned char set_default_mib)
+{
+    int r = 0;
+
+    func_enter();
+
+#ifdef CSR_SUPPORT_WEXT
+    /* The reset clears any 802.11 association. */
+    priv->wext_conf.flag_associated = 0;
+#endif
+
+    func_exit();
+    return r;
+} /* unifi_reset_state() */
+
--- /dev/null
+++ b/drivers/staging/csr/sme_sys.c
@@ -0,0 +1,2950 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     sme_sys.c
+ *
+ * PURPOSE:
+ *      Driver specific implementation of the SME SYS SAP.
+ *      It is part of the porting exercise.
+ *
+ * Copyright (C) 2008-2011 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+#include "csr_wifi_hip_unifiversion.h"
+#include "unifi_priv.h"
+#include "csr_wifi_hip_conversions.h"
+#ifdef CSR_SUPPORT_WEXT_AP
+#include "sme_csr/csr_wifi_sme_sef.h"
+#endif
+/*
+ * This file implements the SME SYS API and contains the following functions:
+ * CsrWifiRouterCtrlMediaStatusReqHandler()
+ * CsrWifiRouterCtrlHipReqHandler()
+ * CsrWifiRouterCtrlPortConfigureReqHandler()
+ * CsrWifiRouterCtrlWifiOnReqHandler()
+ * CsrWifiRouterCtrlWifiOffReqHandler()
+ * CsrWifiRouterCtrlSuspendResHandler()
+ * CsrWifiRouterCtrlResumeResHandler()
+ * CsrWifiRouterCtrlQosControlReqHandler()
+ * CsrWifiRouterCtrlConfigurePowerModeReqHandler()
+ * CsrWifiRouterCtrlWifiOnResHandler()
+ * CsrWifiRouterCtrlWifiOffRspHandler()
+ * CsrWifiRouterCtrlMulticastAddressResHandler()
+ * CsrWifiRouterCtrlTrafficConfigReqHandler()
+ * CsrWifiRouterCtrlTrafficClassificationReqHandler()
+ * CsrWifiRouterCtrlTclasAddReqHandler()
+ * CsrWifiRouterCtrlTclasDelReqHandler()
+ * CsrWifiRouterCtrlSetModeReqHandler()
+ * CsrWifiRouterCtrlWapiMulticastFilterReqHandler()
+ * CsrWifiRouterCtrlWapiMulticastReqHandler()
+ * CsrWifiRouterCtrlWapiUnicastFilterReqHandler()
+ */
+
+#ifdef CSR_SUPPORT_SME
+static void check_inactivity_timer_expire_func(unsigned long data);
+void uf_send_disconnected_ind_wq(struct work_struct *work);
+#endif
+
+void send_auto_ma_packet_confirm(unifi_priv_t *priv,
+                                 netInterface_priv_t *interfacePriv,
+                                 struct list_head *buffered_frames_list)
+{
+    tx_buffered_packets_t *buffered_frame_item = NULL;
+    struct list_head *listHead;
+    struct list_head *placeHolder;
+    int client_id;
+
+    CSR_SIGNAL unpacked_signal;
+    CsrUint8 sigbuf[UNIFI_PACKED_SIGBUF_SIZE];
+    CsrUint16 packed_siglen;
+
+
+    list_for_each_safe(listHead, placeHolder, buffered_frames_list)
+    {
+        buffered_frame_item = list_entry(listHead, tx_buffered_packets_t, q);
+
+        if(!buffered_frame_item) {
+            unifi_error(priv, "Entry should exist, otherwise it is a (BUG)\n");
+            continue;
+        }
+
+        if ((interfacePriv->interfaceMode != CSR_WIFI_ROUTER_CTRL_MODE_NONE) &&
+            (priv->wifi_on_state == wifi_on_done))
+        {
+
+            unifi_warning(priv, "Send MA_PACKET_CONFIRM to SenderProcessId = %x for (HostTag = %x TransmissionControl = %x)\n",
+                                 (buffered_frame_item->leSenderProcessId),
+                                 buffered_frame_item->hostTag,
+                                 buffered_frame_item->transmissionControl);
+
+            client_id = buffered_frame_item->leSenderProcessId & 0xFF00;
+
+            if (client_id == priv->sme_cli->sender_id)
+            {
+                /* construct a MA-PACKET.confirm message for SME */
+                memset(&unpacked_signal, 0, sizeof(unpacked_signal));
+                unpacked_signal.SignalPrimitiveHeader.SignalId = CSR_MA_PACKET_CONFIRM_ID;
+                unpacked_signal.SignalPrimitiveHeader.ReceiverProcessId = buffered_frame_item->leSenderProcessId;
+                unpacked_signal.SignalPrimitiveHeader.SenderProcessId = CSR_WIFI_ROUTER_IFACEQUEUE;
+
+                unpacked_signal.u.MaPacketConfirm.VirtualInterfaceIdentifier = uf_get_vif_identifier(interfacePriv->interfaceMode,
+                                                                                                     interfacePriv->InterfaceTag);
+                unpacked_signal.u.MaPacketConfirm.TransmissionStatus = CSR_RESULT_FAILURE;
+                unpacked_signal.u.MaPacketConfirm.RetryCount = 0;
+                unpacked_signal.u.MaPacketConfirm.Rate = buffered_frame_item->rate;
+                unpacked_signal.u.MaPacketConfirm.HostTag = buffered_frame_item->hostTag;
+
+                write_pack(&unpacked_signal, sigbuf, &packed_siglen);
+                unifi_warning(priv, "MA_PACKET_CONFIRM for SME (0x%x, 0x%x, 0x%x, 0x%x)\n",
+                                         unpacked_signal.SignalPrimitiveHeader.ReceiverProcessId,
+                                         unpacked_signal.SignalPrimitiveHeader.SenderProcessId,
+                                         unpacked_signal.u.MaPacketConfirm.VirtualInterfaceIdentifier,
+                                         unpacked_signal.u.MaPacketConfirm.HostTag);
+
+                CsrWifiRouterCtrlHipIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,
+                                            packed_siglen,
+                                            (CsrUint8 *)sigbuf,
+                                            0, NULL,
+                                            0, NULL);
+            }
+            else if((buffered_frame_item->hostTag & 0x80000000))
+            {
+                /* construct a MA-PACKET.confirm message for NME */
+                unifi_warning(priv, "MA_PACKET_CONFIRM for NME (0x%x, 0x%x, 0x%x, 0x%x)\n",
+                                    buffered_frame_item->leSenderProcessId,
+                                    buffered_frame_item->interfaceTag,
+                                    buffered_frame_item->transmissionControl,
+                                    (buffered_frame_item->hostTag & 0x3FFFFFFF));
+
+                CsrWifiRouterMaPacketCfmSend((buffered_frame_item->leSenderProcessId & 0xFF),
+                                            buffered_frame_item->interfaceTag,
+                                            CSR_RESULT_FAILURE,
+                                            (buffered_frame_item->hostTag & 0x3FFFFFFF),
+                                            buffered_frame_item->rate);
+
+            }
+            else
+            {
+                unifi_warning(priv, "Buffered packet dropped without sending a confirm\n");
+            }
+
+        }
+
+        list_del(listHead);
+        kfree(buffered_frame_item);
+        buffered_frame_item = NULL;
+    }
+}
+
+void CsrWifiRouterCtrlMediaStatusReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlMediaStatusReq* req = (CsrWifiRouterCtrlMediaStatusReq*)msg;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[req->interfaceTag];
+    unsigned long flags;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlMediaStatusReqHandler: invalid smepriv\n");
+        return;
+    }
+    if (req->interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "CsrWifiRouterCtrlMediaStatusReqHandler: invalid interfaceTag\n");
+        return;
+    }
+    unifi_trace(priv, UDBG3, "CsrWifiRouterCtrlMediaStatusReqHandler: Mode = %d req->mediaStatus = %d\n",interfacePriv->interfaceMode,req->mediaStatus);
+    if (interfacePriv->interfaceMode != CSR_WIFI_ROUTER_CTRL_MODE_AMP) {
+        bulk_data_desc_t bulk_data;
+
+        bulk_data.data_length = 0;
+
+        spin_lock_irqsave(&priv->m4_lock, flags);
+        if (interfacePriv->m4_bulk_data.data_length > 0) {
+            bulk_data = interfacePriv->m4_bulk_data;
+            interfacePriv->m4_bulk_data.net_buf_length = 0;
+            interfacePriv->m4_bulk_data.data_length = 0;
+            interfacePriv->m4_bulk_data.os_data_ptr = interfacePriv->m4_bulk_data.os_net_buf_ptr = NULL;
+        }
+        spin_unlock_irqrestore(&priv->m4_lock, flags);
+
+        if (bulk_data.data_length != 0) {
+            unifi_trace(priv, UDBG5, "CsrWifiRouterCtrlMediaStatusReqHandler: free M4\n");
+            unifi_net_data_free(priv, &bulk_data);
+        }
+
+        if ((req->mediaStatus == CSR_WIFI_SME_MEDIA_STATUS_CONNECTED) &&
+            (interfacePriv->connected != UnifiConnected)) {
+
+            switch(interfacePriv->interfaceMode){
+                case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+                case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+                    interfacePriv->connected = UnifiConnected;
+                    netif_carrier_on(priv->netdev[req->interfaceTag]);
+#ifdef CSR_SUPPORT_WEXT
+                    wext_send_started_event(priv);
+#endif
+                    unifi_trace(priv, UDBG1,
+                                "CsrWifiRouterCtrlMediaStatusReqHandler: AP/P2PGO setting netif_carrier_on\n");
+                    UF_NETIF_TX_WAKE_ALL_QUEUES(priv->netdev[req->interfaceTag]);
+                    break;
+
+                default:
+#ifdef CSR_SUPPORT_WEXT
+                /* In the WEXT builds (sme and native), the userspace is not ready
+                 * to process any EAPOL or WAPI packets, until it has been informed
+                 * of the NETDEV_CHANGE.
+                 */
+                if (interfacePriv->netdev_callback_registered && (interfacePriv->interfaceMode != CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI)) {
+                    interfacePriv->wait_netdev_change = TRUE;
+                    unifi_trace(priv, UDBG1,
+                                "CsrWifiRouterCtrlMediaStatusReqHandler: waiting for NETDEV_CHANGE\n");
+                    /*
+                     * Carrier can go to on, only after wait_netdev_change is set to TRUE.
+                     * Otherwise there can be a race in uf_netdev_event().
+                     */
+                    netif_carrier_on(priv->netdev[req->interfaceTag]);
+                    unifi_trace(priv, UDBG1,
+                                "CsrWifiRouterCtrlMediaStatusReqHandler: STA/P2PCLI setting netif_carrier_on\n");
+                }
+                else
+#endif
+                {
+                    /* In the NME build, the userspace does not wait for the NETDEV_CHANGE
+                     * so it is ready to process all the EAPOL or WAPI packets.
+                     * At this point, we enable all the Tx queues, and we indicate any packets
+                     * that are queued (and the respective port is opened).
+                     */
+                    static const CsrWifiMacAddress broadcast_address = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};
+                    interfacePriv->connected = UnifiConnected;
+                    unifi_trace(priv, UDBG1,
+                                "CsrWifiRouterMediaStatusReqHandler: UnifiConnected && netif_carrier_on\n");
+                    netif_carrier_on(priv->netdev[req->interfaceTag]);
+                    UF_NETIF_TX_WAKE_ALL_QUEUES(priv->netdev[req->interfaceTag]);
+                    uf_process_rx_pending_queue(priv, UF_UNCONTROLLED_PORT_Q, broadcast_address, 1, interfacePriv->InterfaceTag);
+                    uf_process_rx_pending_queue(priv, UF_CONTROLLED_PORT_Q, broadcast_address, 1, interfacePriv->InterfaceTag);
+                }
+                break;
+            }
+        }
+
+        if (req->mediaStatus == CSR_WIFI_SME_MEDIA_STATUS_DISCONNECTED) {
+#ifdef CSR_SUPPORT_WEXT
+            unifi_trace(priv, UDBG1,
+                        "CsrWifiRouterMediaStatusReqHandler: cancel waiting for NETDEV_CHANGE\n");
+            interfacePriv->wait_netdev_change = FALSE;
+#endif
+            unifi_trace(priv, UDBG1,
+                        "CsrWifiRouterMediaStatusReqHandler: setting netif_carrier_off\n");
+            netif_carrier_off(priv->netdev[req->interfaceTag]);
+#ifdef CSR_SUPPORT_WEXT
+            switch(interfacePriv->interfaceMode){
+                case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+                case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+                     wext_send_started_event(priv);
+                     break;
+                default:
+                     break;
+            }
+#endif
+            interfacePriv->connected = UnifiNotConnected;
+        }
+    } else {
+        /* For AMP, just update the L2 connected flag */
+        if (req->mediaStatus == CSR_WIFI_SME_MEDIA_STATUS_CONNECTED) {
+            unifi_trace(priv, UDBG1, "CsrWifiRouterCtrlMediaStatusReqHandler: AMP connected\n");
+            interfacePriv->connected = UnifiConnected;
+        } else {
+            unifi_trace(priv, UDBG1, "CsrWifiRouterCtrlMediaStatusReqHandler: AMP disconnected\n");
+            interfacePriv->connected = UnifiNotConnected;
+        }
+    }
+}
+
+
+void CsrWifiRouterCtrlHipReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlHipReq* hipreq = (CsrWifiRouterCtrlHipReq*)msg;
+    bulk_data_param_t bulkdata;
+    u8 *signal_ptr;
+    int signal_length;
+    int r=0;
+    void *dest;
+    CsrResult csrResult;
+    CSR_SIGNAL *signal;
+    CsrUint16 interfaceTag = 0;
+    CSR_MA_PACKET_REQUEST *req;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if (priv == NULL) {
+        return;
+    }
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlHipReqHandler: invalid smepriv\n");
+        return;
+    }
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "CsrWifiRouterCtrlHipReqHandler: invalid interfaceTag\n");
+        return;
+    }
+
+    /* Initialize bulkdata to avoid os_net_buf is garbage */
+    memset(&bulkdata, 0, sizeof(bulk_data_param_t));
+
+    signal = (CSR_SIGNAL *)hipreq->mlmeCommand;
+
+    unifi_trace(priv, UDBG4, "CsrWifiRouterCtrlHipReqHandler: 0x04%X ---->\n",
+                *((CsrUint16*)hipreq->mlmeCommand));
+
+    /* Construct the signal. */
+    signal_ptr = (u8*)hipreq->mlmeCommand;
+    signal_length = hipreq->mlmeCommandLength;
+
+    /*
+     * The MSB of the sender ID needs to be set to the client ID.
+     * The LSB is controlled by the SME.
+     */
+    signal_ptr[5] = (priv->sme_cli->sender_id >> 8) & 0xff;
+
+    /* Allocate buffers for the bulk data. */
+    if (hipreq->dataRef1Length) {
+        csrResult = unifi_net_data_malloc(priv, &bulkdata.d[0], hipreq->dataRef1Length);
+        if (csrResult == CSR_RESULT_SUCCESS) {
+            dest = (void*)bulkdata.d[0].os_data_ptr;
+            memcpy(dest, hipreq->dataRef1, hipreq->dataRef1Length);
+            bulkdata.d[0].data_length = hipreq->dataRef1Length;
+        } else {
+            unifi_warning(priv, "signal not sent down, allocation failed in CsrWifiRouterCtrlHipReqHandler\n");
+            return;
+        }
+    } else {
+        bulkdata.d[0].os_data_ptr = NULL;
+        bulkdata.d[0].data_length = 0;
+    }
+    if (hipreq->dataRef2Length) {
+        csrResult = unifi_net_data_malloc(priv, &bulkdata.d[1], hipreq->dataRef2Length);
+        if (csrResult == CSR_RESULT_SUCCESS) {
+            dest = (void*)bulkdata.d[1].os_data_ptr;
+            memcpy(dest, hipreq->dataRef2, hipreq->dataRef2Length);
+            bulkdata.d[1].data_length = hipreq->dataRef2Length;
+        } else {
+            if (bulkdata.d[0].data_length)
+            {
+                unifi_net_data_free(priv, &bulkdata.d[0]);
+            }
+            unifi_warning(priv, "signal not sent down, allocation failed in CsrWifiRouterCtrlHipReqHandler\n");
+            return;
+        }
+    } else {
+        bulkdata.d[1].os_data_ptr = NULL;
+        bulkdata.d[1].data_length = 0;
+    }
+
+    unifi_trace(priv, UDBG3, "SME SEND: Signal 0x%.4X \n",
+                *((CsrUint16*)signal_ptr));
+    if (signal->SignalPrimitiveHeader.SignalId == CSR_MA_PACKET_REQUEST_ID)
+    {
+        CSR_SIGNAL unpacked_signal;
+        read_unpack_signal((u8 *) signal, &unpacked_signal);
+        req = &unpacked_signal.u.MaPacketRequest;
+        interfaceTag = req->VirtualInterfaceIdentifier & 0xff;
+        switch(interfacePriv->interfaceMode)
+        {
+            case CSR_WIFI_ROUTER_CTRL_MODE_NONE:
+                unifi_error(priv, "CsrWifiRouterCtrlHipReqHandler: invalid mode: NONE \n");
+                break;
+            default:
+                unifi_trace(priv, UDBG5, "mode is %x\n", interfacePriv->interfaceMode);
+        }
+        /* While sending ensure that first 2 bits b31 and b30 are 00. These are used for local routing*/
+        r = uf_process_ma_packet_req(priv, req->Ra.x, (req->HostTag & 0x3FFFFFFF), interfaceTag,
+                                     req->TransmissionControl, req->TransmitRate,
+                                     req->Priority, signal->SignalPrimitiveHeader.SenderProcessId,
+                                     &bulkdata);
+        if (r)
+        {
+            if (bulkdata.d[0].data_length)
+            {
+                unifi_net_data_free(priv, &bulkdata.d[0]);
+            }
+            if (bulkdata.d[1].data_length)
+            {
+                unifi_net_data_free(priv, &bulkdata.d[1]);
+            }
+        }
+    } else {
+        /* ul_send_signal_raw frees the bulk data if it fails */
+        r = ul_send_signal_raw(priv, signal_ptr, signal_length, &bulkdata);
+    }
+
+    if (r) {
+        unifi_error(priv,
+                    "CsrWifiRouterCtrlHipReqHandler: Failed to send signal (0x%.4X - %u)\n",
+                    *((CsrUint16*)signal_ptr), r);
+        CsrWifiRouterCtrlWifiOffIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,CSR_WIFI_SME_CONTROL_INDICATION_ERROR);
+    }
+
+    unifi_trace(priv, UDBG4, "CsrWifiRouterCtrlHipReqHandler: <----\n");
+}
+
+#ifdef CSR_WIFI_SEND_GRATUITOUS_ARP
+static void
+uf_send_gratuitous_arp(unifi_priv_t *priv, CsrUint16 interfaceTag)
+{
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    CSR_PRIORITY priority;
+    CSR_SIGNAL signal;
+    bulk_data_param_t bulkdata;
+    CsrResult csrResult;
+    struct sk_buff *skb, *newSkb = NULL;
+    CsrInt8 protection;
+    int r;
+    static const CsrUint8 arp_req[36] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00,
+                                         0x08, 0x06, 0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01,
+                                         0x00, 0x02, 0x5f, 0x20, 0x2f, 0x02,
+                                         0xc0, 0xa8, 0x00, 0x02,
+                                         0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+                                         0xc0, 0xa8, 0x00, 0x02};
+
+    func_enter();
+
+    csrResult = unifi_net_data_malloc(priv, &bulkdata.d[0], sizeof(arp_req));
+    if (csrResult != CSR_RESULT_SUCCESS)
+    {
+        unifi_error(priv, "Failed to allocate bulk data in CsrWifiSmeRoamCompleteIndHandler()\n");
+        return;
+    }
+    skb = (struct sk_buff *)(bulkdata.d[0].os_net_buf_ptr);
+    skb->len = bulkdata.d[0].data_length;
+
+    memcpy(skb->data, arp_req, sizeof(arp_req));
+    /* add MAC and IP address */
+    memcpy(skb->data + 16, priv->netdev[interfaceTag]->dev_addr, ETH_ALEN);
+    skb->data[22] = (priv->sta_ip_address      ) & 0xFF;
+    skb->data[23] = (priv->sta_ip_address >>  8) & 0xFF;
+    skb->data[24] = (priv->sta_ip_address >> 16) & 0xFF;
+    skb->data[25] = (priv->sta_ip_address >> 24) & 0xFF;
+    skb->data[32] = (priv->sta_ip_address      ) & 0xFF;
+    skb->data[33] = (priv->sta_ip_address >>  8) & 0xFF;
+    skb->data[34] = (priv->sta_ip_address >> 16) & 0xFF;
+    skb->data[35] = (priv->sta_ip_address >> 24) & 0xFF;
+
+    bulkdata.d[1].os_data_ptr = NULL;
+    bulkdata.d[1].os_net_buf_ptr = NULL;
+    bulkdata.d[1].net_buf_length = bulkdata.d[1].data_length = 0;
+
+    if ((protection = uf_get_protection_bit_from_interfacemode(priv, interfaceTag, &arp_req[26])) < 0)
+    {
+        unifi_error(priv, "CsrWifiSmeRoamCompleteIndHandler: Failed to determine protection mode\n");
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+        return;
+    }
+
+    if ((priv->sta_wmm_capabilities & QOS_CAPABILITY_WMM_ENABLED) == 1)
+    {
+        priority = CSR_QOS_UP0;
+    }
+    else
+    {
+        priority = CSR_CONTENTION;
+    }
+
+    if (prepare_and_add_macheader(priv, skb, newSkb, priority, &bulkdata,
+                                  interfaceTag, &arp_req[26],
+                                  priv->netdev[interfaceTag]->dev_addr, protection))
+    {
+        unifi_error(priv, "CsrWifiSmeRoamCompleteIndHandler: failed to create MAC header\n");
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+        return;
+    }
+    bulkdata.d[0].os_data_ptr = skb->data;
+    bulkdata.d[0].os_net_buf_ptr = skb;
+    bulkdata.d[0].data_length = skb->len;
+
+    unifi_frame_ma_packet_req(priv, priority, 0, 0xffffffff, interfaceTag,
+                              CSR_NO_CONFIRM_REQUIRED, priv->netdev_client->sender_id,
+                              interfacePriv->bssid.a, &signal);
+
+    r = ul_send_signal_unpacked(priv, &signal, &bulkdata);
+    if (r)
+    {
+        unifi_error(priv, "CsrWifiSmeRoamCompleteIndHandler: failed to send QOS data null packet result: %d\n",r);
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+        return;
+    }
+
+    func_exit();
+
+}
+#endif /* CSR_WIFI_SEND_GRATUITOUS_ARP */
+
+/*
+ * ---------------------------------------------------------------------------
+ * configure_data_port
+ *
+ *      Store the new controlled port configuration.
+ *
+ * Arguments:
+ *      priv            Pointer to device private context struct
+ *      port_cfg        Pointer to the port configuration
+ *
+ * Returns:
+ *      An unifi_ControlledPortAction value.
+ * ---------------------------------------------------------------------------
+ */
+static int
+configure_data_port(unifi_priv_t *priv,
+        CsrWifiRouterCtrlPortAction port_action,
+        const CsrWifiMacAddress *macAddress,
+        const int queue,
+        CsrUint16 interfaceTag)
+{
+    const CsrUint8 broadcast_mac_address[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+    unifi_port_config_t *port;
+    netInterface_priv_t *interfacePriv;
+    int i;
+    const char* controlled_string; /* cosmetic "controlled"/"uncontrolled" for trace */
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "configure_data_port: bad interfaceTag\n");
+        return -EFAULT;
+    }
+
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if (queue == UF_CONTROLLED_PORT_Q) {
+        port = &interfacePriv->controlled_data_port;
+        controlled_string = "controlled";
+    } else {
+        port = &interfacePriv->uncontrolled_data_port;
+        controlled_string = "uncontrolled";
+    }
+
+    unifi_trace(priv, UDBG2, "port config request %02x:%02x:%02x:%02x:%02x:%02x %s with port_action %d.\n",
+                macAddress->a[0], macAddress->a[1], macAddress->a[2],
+                macAddress->a[3], macAddress->a[4], macAddress->a[5],
+                controlled_string, port_action);
+
+
+    /* If the new configuration has the broadcast MAC address or if we are in infrastructure mode then clear the list first and set port overide mode */
+    if ((CSR_WIFI_ROUTER_CTRL_MODE_STA == interfacePriv->interfaceMode ||
+        interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI) ||
+        !memcmp(macAddress->a, broadcast_mac_address, ETH_ALEN)) {
+
+        port->port_cfg[0].port_action = port_action;
+        port->port_cfg[0].mac_address = *macAddress;
+        port->port_cfg[0].in_use = TRUE;
+        port->entries_in_use = 1;
+        port->overide_action = UF_DATA_PORT_OVERIDE;
+
+        unifi_trace(priv, UDBG2, "%s port override on\n",
+                    (queue == UF_CONTROLLED_PORT_Q) ? "Controlled" : "Uncontrolled");
+
+        /* Discard the remaining entries in the port config table */
+        for (i = 1; i < UNIFI_MAX_CONNECTIONS; i++) {
+            port->port_cfg[i].in_use = FALSE;
+        }
+
+        if (port_action == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN) {
+            unifi_trace(priv, UDBG1, "%s port broadcast set to open.\n",
+                        (queue == UF_CONTROLLED_PORT_Q) ? "Controlled" : "Uncontrolled");
+
+            /*
+             * Ask stack to schedule for transmission any packets queued
+             * while controlled port was not open.
+             * Use netif_schedule() instead of netif_wake_queue() because
+             * transmission should be already enabled at this point. If it
+             * is not, probably the interface is down and should remain as is.
+             */
+            uf_resume_data_plane(priv, queue, *macAddress, interfaceTag);
+
+#ifdef CSR_WIFI_SEND_GRATUITOUS_ARP
+            if ((CSR_WIFI_ROUTER_CTRL_MODE_STA == interfacePriv->interfaceMode) &&
+                (queue == UF_CONTROLLED_PORT_Q) && (priv->sta_ip_address != 0xFFFFFFFF))
+            {
+                uf_send_gratuitous_arp(priv, interfaceTag);
+            }
+#endif
+        } else {
+            unifi_trace(priv, UDBG1, "%s port broadcast set to %s.\n",
+                        (queue == UF_CONTROLLED_PORT_Q) ? "Controlled" : "Uncontrolled",
+                        (port_action == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD) ? "discard": "closed");
+
+            /* If port is closed, discard all the pending Rx packets */
+            if (port_action == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD) {
+                uf_free_pending_rx_packets(priv, queue, *macAddress,interfaceTag);
+            }
+        }
+    } else {
+        /* store the new configuration, either in the entry with matching mac address (if already present),
+         * otherwise in a new entry
+         */
+
+        int found_entry_flag;
+        int first_free_slot = -1;
+
+        /* If leaving override mode, free the port entry used for override */
+        if (port->overide_action == UF_DATA_PORT_OVERIDE) {
+            port->port_cfg[0].in_use = FALSE;
+            port->entries_in_use = 0;
+            port->overide_action = UF_DATA_PORT_NOT_OVERIDE;
+
+            unifi_trace(priv, UDBG2, "%s port override off\n",
+                        (queue == UF_CONTROLLED_PORT_Q) ? "Controlled" : "Uncontrolled");
+        }
+
+        found_entry_flag = 0;
+        for (i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {
+            if (port->port_cfg[i].in_use) {
+                if (!memcmp(&port->port_cfg[i].mac_address.a, macAddress->a, ETH_ALEN)) {
+                    /* We've seen this address before, reconfigure it */
+                    port->port_cfg[i].port_action = port_action;
+                    found_entry_flag = 1;
+                    break;
+                }
+            } else if (first_free_slot == -1) {
+                /* Remember the first free slot on the way past so it can be claimed
+                 * if this turns out to be a new MAC address (to save walking the list again).
+                 */
+                first_free_slot = i;
+            }
+        }
+
+        /* At this point we found an existing entry and have updated it, or need to
+         * add a new entry. If all slots are allocated, give up and return an error.
+         */
+        if (!found_entry_flag) {
+            if (first_free_slot == -1) {
+                unifi_error(priv, "no free slot found in port config array (%d used)\n", port->entries_in_use);
+                return -EFAULT;
+            } else {
+                port->entries_in_use++;
+            }
+
+            unifi_trace(priv, UDBG3, "port config index assigned in config_data_port = %d\n", first_free_slot);
+            port->port_cfg[first_free_slot].in_use = TRUE;
+            port->port_cfg[first_free_slot].port_action = port_action;
+            port->port_cfg[first_free_slot].mac_address = *macAddress;
+        }
+
+        if (port_action == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN) {
+            /*
+             * Ask stack to schedule for transmission any packets queued
+             * while controlled port was not open.
+             * Use netif_schedule() instead of netif_wake_queue() because
+             * transmission should be already enabled at this point. If it
+             * is not, probably the interface is down and should remain as is.
+             */
+            uf_resume_data_plane(priv, queue, *macAddress, interfaceTag);
+        }
+
+        /*
+         * If port is closed, discard all the pending Rx packets
+         * coming from the peer station.
+         */
+        if (port_action == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD) {
+            uf_free_pending_rx_packets(priv, queue, *macAddress,interfaceTag);
+        }
+
+        unifi_trace(priv, UDBG2, "port config %02x:%02x:%02x:%02x:%02x:%02x with port_action %d.\n",
+                    *(macAddress->a+0), *(macAddress->a+1), *(macAddress->a+2),
+                    *(macAddress->a+3), *(macAddress->a+4), *(macAddress->a+5),
+                    port_action);
+    }
+    return 0;
+} /* configure_data_port() */
+
+
+void CsrWifiRouterCtrlPortConfigureReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlPortConfigureReq* req = (CsrWifiRouterCtrlPortConfigureReq*)msg;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[req->interfaceTag];
+
+    unifi_trace(priv, UDBG3, "entering CsrWifiRouterCtrlPortConfigureReqHandler\n");
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlPortConfigureReqHandler: invalid smepriv\n");
+        return;
+    }
+
+    /* To update the protection status of the peer/station */
+    switch(interfacePriv->interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_STA:
+	    case CSR_WIFI_ROUTER_CTRL_MODE_AMP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_IBSS:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:
+            /* Since for Unifi as a station, the station record not maintained & interfaceID is
+             * only needed to update the peer protection status
+             */
+            interfacePriv->protect = req->setProtection;
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            {
+                CsrUint8 i;
+                CsrWifiRouterCtrlStaInfo_t *staRecord;
+                /* Ifscontrolled port is open means, The peer has been added to station record
+                 * so that the protection corresponding to the peer is valid in this req
+                 */
+                if (req->controlledPortAction == CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN) {
+                    for(i =0; i < UNIFI_MAX_CONNECTIONS; i++) {
+                        staRecord = (CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[i]);
+                        if (staRecord) {
+                                /* Find the matching station record & set the protection type */
+                                if (!memcmp(req->macAddress.a, staRecord->peerMacAddress.a, ETH_ALEN)) {
+                                        staRecord->protection = req->setProtection;
+                                        break;
+                                }
+                        }
+                    }
+                }
+            }
+            break;
+        default:
+            unifi_trace(priv, UDBG1, "CsrWifiRouterCtrlPortConfigureReqHandler(0x%.4X) Uncaught mode %d\n",
+                        msg->source, interfacePriv->interfaceMode);
+    }
+
+    configure_data_port(priv, req->uncontrolledPortAction, (const CsrWifiMacAddress *)&req->macAddress,
+                        UF_UNCONTROLLED_PORT_Q, req->interfaceTag);
+    configure_data_port(priv, req->controlledPortAction, (const CsrWifiMacAddress *)&req->macAddress,
+                        UF_CONTROLLED_PORT_Q, req->interfaceTag);
+
+    CsrWifiRouterCtrlPortConfigureCfmSend(msg->source,req->clientData,req->interfaceTag,
+                                      CSR_RESULT_SUCCESS, req->macAddress);
+    unifi_trace(priv, UDBG3, "leaving CsrWifiRouterCtrlPortConfigureReqHandler\n");
+}
+
+
+void CsrWifiRouterCtrlWifiOnReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlVersions versions;
+    CsrWifiRouterCtrlWifiOnReq* req = (CsrWifiRouterCtrlWifiOnReq*)msg;
+    int r,i;
+    CsrResult csrResult;
+
+    if (priv == NULL) {
+        return;
+    }
+    for (i=0; i<CSR_WIFI_NUM_INTERFACES; i++) {
+        priv->interfacePriv[i]->interfaceMode = 0;
+    }
+    unifi_trace(priv, UDBG1, "CsrWifiRouterCtrlWifiOnReqHandler(0x%.4X)\n", msg->source);
+
+    /*
+     * The request to initialise UniFi might come while UniFi is running.
+     * We need to block all I/O activity until the reset completes, otherwise
+     * an SDIO error might occur resulting an indication to the SME which
+     * makes it think that the initialisation has failed.
+     */
+    priv->bh_thread.block_thread = 1;
+
+    /* Update the wifi_on state */
+    priv->wifi_on_state = wifi_on_in_progress;
+
+    r = uf_request_firmware_files(priv, UNIFI_FW_STA);
+    if (r) {
+        unifi_error(priv, "CsrWifiRouterCtrlWifiOnReqHandler: Failed to get f/w\n");
+        CsrWifiRouterCtrlWifiOnCfmSend(msg->source, req->clientData, CSR_RESULT_FAILURE);
+        return;
+    }
+
+    /* Power on UniFi (which may not necessarily have been off) */
+    CsrSdioClaim(priv->sdio);
+    csrResult = CsrSdioPowerOn(priv->sdio);
+    CsrSdioRelease(priv->sdio);
+    if (csrResult != CSR_RESULT_SUCCESS && csrResult != CSR_SDIO_RESULT_NOT_RESET) {
+        unifi_error(priv, "CsrWifiRouterCtrlWifiOnReqHandler: Failed to power on UniFi\n");
+        CsrWifiRouterCtrlWifiOnCfmSend(msg->source, req->clientData, CSR_RESULT_FAILURE);
+        return;
+    }
+
+    /* If CsrSdioPowerOn() returns CSR_RESULT_SUCCESS, it means that we need to initialise UniFi */
+    if (csrResult == CSR_RESULT_SUCCESS && !priv->wol_suspend) {
+        /* Initialise UniFi hardware */
+        r = uf_init_hw(priv);
+        if (r) {
+            unifi_error(priv, "CsrWifiRouterCtrlWifiOnReqHandler: Failed to initialise h/w, error %d\n", r);
+            CsrWifiRouterCtrlWifiOnCfmSend(msg->source, req->clientData, CSR_RESULT_FAILURE);
+            return;
+        }
+    } else {
+        unifi_trace(priv, UDBG1, "UniFi already initialised\n");
+    }
+
+    /* Completed handling of wake up from suspend with UniFi powered */
+    priv->wol_suspend = FALSE;
+
+    /* Re-enable the I/O thread */
+    priv->bh_thread.block_thread = 0;
+
+    /*
+     * Start the I/O thread. The thread might be already running.
+     * This fine, just carry on with the request.
+     */
+    r = uf_init_bh(priv);
+    if (r) {
+        CsrSdioClaim(priv->sdio);
+        CsrSdioPowerOff(priv->sdio);
+        CsrSdioRelease(priv->sdio);
+        CsrWifiRouterCtrlWifiOnCfmSend(msg->source, req->clientData, CSR_RESULT_FAILURE);
+        return;
+    }
+
+    /* Get the version information from the core */
+    unifi_card_info(priv->card, &priv->card_info);
+
+    /* Set the sme queue id */
+    priv->CSR_WIFI_SME_IFACEQUEUE = msg->source;
+    CSR_WIFI_SME_IFACEQUEUE = msg->source;
+
+
+    /* Copy to the unifiio_card_info structure. */
+    versions.chipId = priv->card_info.chip_id;
+    versions.chipVersion = priv->card_info.chip_version;
+    versions.firmwareBuild = priv->card_info.fw_build;
+    versions.firmwareHip = priv->card_info.fw_hip_version;
+    versions.routerBuild = (CsrCharString*)CSR_WIFI_VERSION;
+    versions.routerHip = (UNIFI_HIP_MAJOR_VERSION << 8) | UNIFI_HIP_MINOR_VERSION;
+
+    CsrWifiRouterCtrlWifiOnIndSend(msg->source, 0, CSR_RESULT_SUCCESS, versions);
+
+    /* Update the wifi_on state */
+    priv->wifi_on_state = wifi_on_done;
+}
+
+
+/*
+ * wifi_off:
+ *      Common code for CsrWifiRouterCtrlWifiOffReqHandler() and
+ *      CsrWifiRouterCtrlWifiOffRspHandler().
+ */
+static void
+wifi_off(unifi_priv_t *priv)
+{
+    int power_off;
+    int priv_instance;
+    int i;
+    CsrResult csrResult;
+
+    unifi_trace(priv, UDBG1, "wifi_off\n");
+
+    /* Destroy the Traffic Analysis Module */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+    cancel_work_sync(&priv->ta_ind_work.task);
+    cancel_work_sync(&priv->ta_sample_ind_work.task);
+#ifdef CSR_SUPPORT_WEXT
+    cancel_work_sync(&priv->sme_config_task);
+#endif
+
+    /* Cancel pending M4 stuff */
+    for (i = 0; i < CSR_WIFI_NUM_INTERFACES; i++) {
+        if (priv->netdev[i]) {
+            netInterface_priv_t *netpriv = (netInterface_priv_t *) netdev_priv(priv->netdev[i]);
+            cancel_work_sync(&netpriv->send_m4_ready_task);
+        }
+    }
+#endif
+    flush_workqueue(priv->unifi_workqueue);
+
+    /* fw_init parameter can prevent power off UniFi, for debugging */
+    priv_instance = uf_find_priv(priv);
+    if (priv_instance == -1) {
+        unifi_warning(priv,
+                "CsrWifiRouterCtrlStopReqHandler: Unknown priv instance, will power off card.\n");
+        power_off = 1;
+    } else {
+        power_off = (fw_init[priv_instance] > 0) ? 0 : 1;
+    }
+
+    /* Production test mode requires power to the chip, too */
+    if (priv->ptest_mode) {
+        power_off = 0;
+    }
+
+    /* Stop the bh_thread */
+    uf_stop_thread(priv, &priv->bh_thread);
+
+    /* Read the f/w panic codes, if any. Protect against second wifi_off() call,
+     * which may happen if SME requests a wifi_off and closes the char device */
+    if (priv->init_progress != UNIFI_INIT_NONE) {
+        CsrSdioClaim(priv->sdio);
+        unifi_capture_panic(priv->card);
+        CsrSdioRelease(priv->sdio);
+    }
+
+    /* Unregister the interrupt handler */
+    if (csr_sdio_linux_remove_irq(priv->sdio)) {
+        unifi_notice(priv,
+                "csr_sdio_linux_remove_irq failed to talk to card.\n");
+    }
+
+    if (power_off) {
+        unifi_trace(priv, UDBG2,
+                    "Force low power and try to power off\n");
+        /* Put UniFi to deep sleep, in case we can not power it off */
+        CsrSdioClaim(priv->sdio);
+        csrResult = unifi_force_low_power_mode(priv->card);
+        CsrSdioRelease(priv->sdio);
+
+        CsrSdioPowerOff(priv->sdio);
+    }
+
+    /* Consider UniFi to be uninitialised */
+    priv->init_progress = UNIFI_INIT_NONE;
+    priv->wifi_on_state = wifi_on_unspecified;
+
+
+} /* wifi_off() */
+
+
+void CsrWifiRouterCtrlWifiOffReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlWifiOffReq* req = (CsrWifiRouterCtrlWifiOffReq*)msg;
+    int i = 0;
+#ifdef CSR_SUPPORT_WEXT_AP
+    CsrWifiSmeWifiOffCfm cfm;
+#endif
+
+    if (priv == NULL) {
+        return;
+    }
+
+    unifi_trace(priv, UDBG1, "CsrWifiRouterCtrlWifiOffReqHandler(0x%.4X)\n", msg->source);
+
+    /* Stop the network traffic on all interfaces before freeing the core. */
+    for (i=0; i<CSR_WIFI_NUM_INTERFACES; i++) {
+        netInterface_priv_t *interfacePriv = priv->interfacePriv[i];
+        if (interfacePriv->netdev_registered == 1) {
+            netif_carrier_off(priv->netdev[i]);
+            UF_NETIF_TX_STOP_ALL_QUEUES(priv->netdev[i]);
+        }
+        interfacePriv->interfaceMode = 0;
+
+        /* Enable all queues by default */
+        interfacePriv->queueEnabled[0] = 1;
+        interfacePriv->queueEnabled[1] = 1;
+        interfacePriv->queueEnabled[2] = 1;
+        interfacePriv->queueEnabled[3] = 1;
+    }
+    wifi_off(priv);
+
+    CsrWifiRouterCtrlWifiOffCfmSend(msg->source,req->clientData);
+#ifdef CSR_SUPPORT_WEXT_AP
+    /* Router is turned off when WifiOffCfm is received
+     * hence for wext we don't see WifiOffCfm in the wext
+     * files. So just tell the waiting process that
+     * Wifi off is successful
+     */
+    cfm.status =  CSR_RESULT_SUCCESS;
+    CsrWifiSmeWifiOffCfmHandler(priv,(CsrWifiFsmEvent*)(&cfm));
+#endif
+}
+
+
+void CsrWifiRouterCtrlQosControlReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlQosControlReq* req = (CsrWifiRouterCtrlQosControlReq*)msg;
+    netInterface_priv_t *interfacePriv;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlQosControlReqHandler: invalid smepriv\n");
+        return;
+    }
+
+    unifi_trace(priv, UDBG4, "CsrWifiRouterCtrlQosControlReqHandler:scontrol = %d", req->control);
+
+    if (req->interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "CsrWifiRouterCtrlQosControlReqHandler: interfaceID >= CSR_WIFI_NUM_INTERFACES.\n");
+        return;
+    }
+    interfacePriv = priv->interfacePriv[req->interfaceTag];
+
+    if (req->control == CSR_WIFI_ROUTER_CTRL_QOS_CONTROL_WMM_ON) {
+        priv->sta_wmm_capabilities |= QOS_CAPABILITY_WMM_ENABLED;
+        unifi_trace(priv, UDBG1, "WMM enabled\n");
+
+        unifi_trace(priv, UDBG1, "Queue Config %x\n", req->queueConfig);
+
+        interfacePriv->queueEnabled[UNIFI_TRAFFIC_Q_BK] = (req->queueConfig & CSR_WIFI_ROUTER_CTRL_QUEUE_BK_ENABLE)?1:0;
+        interfacePriv->queueEnabled[UNIFI_TRAFFIC_Q_BE] = (req->queueConfig & CSR_WIFI_ROUTER_CTRL_QUEUE_BE_ENABLE)?1:0;
+        interfacePriv->queueEnabled[UNIFI_TRAFFIC_Q_VI] = (req->queueConfig & CSR_WIFI_ROUTER_CTRL_QUEUE_VI_ENABLE)?1:0;
+        interfacePriv->queueEnabled[UNIFI_TRAFFIC_Q_VO] = (req->queueConfig & CSR_WIFI_ROUTER_CTRL_QUEUE_VO_ENABLE)?1:0;
+
+    } else {
+        priv->sta_wmm_capabilities = 0;
+        unifi_trace(priv, UDBG1, "WMM disabled\n");
+    }
+}
+
+
+void CsrWifiRouterCtrlTclasAddReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlTclasAddReq* req = (CsrWifiRouterCtrlTclasAddReq*)msg;
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlTclasAddReqHandler: invalid smepriv\n");
+        return;
+    }
+
+    CsrWifiRouterCtrlTclasAddCfmSend(msg->source, req->clientData, req->interfaceTag , CSR_RESULT_SUCCESS);
+}
+
+void CsrWifiRouterCtrlTclasDelReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlTclasDelReq* req = (CsrWifiRouterCtrlTclasDelReq*)msg;
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlTclasDelReqHandler: invalid smepriv\n");
+        return;
+    }
+
+    CsrWifiRouterCtrlTclasDelCfmSend(msg->source, req->clientData, req->interfaceTag, CSR_RESULT_SUCCESS);
+}
+
+
+void CsrWifiRouterCtrlConfigurePowerModeReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlConfigurePowerModeReq* req = (CsrWifiRouterCtrlConfigurePowerModeReq*)msg;
+    enum unifi_low_power_mode pm;
+    CsrResult csrResult;
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlConfigurePowerModeReqHandler: invalid smepriv\n");
+        return;
+    }
+
+    if (req->mode == CSR_WIFI_ROUTER_CTRL_LOW_POWER_MODE_DISABLED) {
+        pm = UNIFI_LOW_POWER_DISABLED;
+    } else {
+        pm = UNIFI_LOW_POWER_ENABLED;
+    }
+
+    unifi_trace(priv, UDBG2,
+                "CsrWifiRouterCtrlConfigurePowerModeReqHandler (mode=%d, wake=%d)\n",
+                req->mode, req->wakeHost);
+    csrResult = unifi_configure_low_power_mode(priv->card, pm,
+                                               (req->wakeHost ? UNIFI_PERIODIC_WAKE_HOST_ENABLED : UNIFI_PERIODIC_WAKE_HOST_DISABLED));
+}
+
+
+void CsrWifiRouterCtrlWifiOnResHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlWifiOnRes* res = (CsrWifiRouterCtrlWifiOnRes*)msg;
+
+    if (priv == NULL) {
+        unifi_error(NULL, "CsrWifiRouterCtrlWifiOnResHandler: Invalid ospriv.\n");
+        return;
+    }
+
+    unifi_trace(priv, UDBG1,
+                "CsrWifiRouterCtrlWifiOnResHandler: status %d (patch %u)\n", res->status, res->smeVersions.firmwarePatch);
+
+    if (res->smeVersions.firmwarePatch != 0) {
+        unifi_info(priv, "Firmware patch %d\n", res->smeVersions.firmwarePatch);
+    }
+
+    if (res->numInterfaceAddress > CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "WifiOnResHandler bad numInterfaceAddress %d\n", res->numInterfaceAddress);
+        return;
+    }
+
+    /* UniFi is now initialised, complete the init. */
+    if (res->status == CSR_RESULT_SUCCESS)
+    {
+        int i; /* used as a loop counter */
+        CsrUint32 intmode = CSR_WIFI_INTMODE_DEFAULT;
+
+        /* Register the UniFi device with the OS network manager */
+        unifi_trace(priv, UDBG3, "Card Init Completed Successfully\n");
+
+        /* Store the MAC address in the netdev */
+        for(i=0;i<res->numInterfaceAddress;i++)
+        {
+            memcpy(priv->netdev[i]->dev_addr, res->stationMacAddress[i].a, ETH_ALEN);
+        }
+
+        /* Copy version structure into the private versions field */
+        priv->sme_versions = res->smeVersions;
+
+        unifi_trace(priv, UDBG2, "network interfaces count = %d\n",
+                    res->numInterfaceAddress);
+
+        /* Register the netdevs for each interface. */
+        for(i=0;i<res->numInterfaceAddress;i++)
+        {
+            netInterface_priv_t *interfacePriv = priv->interfacePriv[i];
+            if(!interfacePriv->netdev_registered)
+            {
+                int r;
+                unifi_trace(priv, UDBG3, "registering net device %d\n", i);
+                r = uf_register_netdev(priv, i);
+                if (r)
+                {
+                    /* unregister the net_device that are registered in the previous iterations */
+                    uf_unregister_netdev(priv);
+                    unifi_error(priv, "Failed to register the network device.\n");
+                    CsrWifiRouterCtrlWifiOnCfmSend(msg->source, res->clientData, CSR_RESULT_FAILURE);
+                    return;
+                }
+            }
+        }
+        priv->totalInterfaceCount = res->numInterfaceAddress;
+
+        /* If the MIB has selected f/w scheduled interrupt mode, apply it now
+         * but let module param override.
+         */
+        if (run_bh_once != -1) {
+            intmode = (CsrUint32)run_bh_once;
+        } else if (res->scheduledInterrupt) {
+            intmode = CSR_WIFI_INTMODE_RUN_BH_ONCE;
+        }
+        unifi_set_interrupt_mode(priv->card, intmode);
+
+        priv->init_progress = UNIFI_INIT_COMPLETED;
+
+        /* Acknowledge the CsrWifiRouterCtrlWifiOnReq now */
+        CsrWifiRouterCtrlWifiOnCfmSend(msg->source, res->clientData, CSR_RESULT_SUCCESS);
+
+        unifi_info(priv, "UniFi ready\n");
+
+        /* Firmware initialisation is complete, so let the SDIO bus
+         * clock be raised when convienent to the core.
+         */
+        unifi_request_max_sdio_clock(priv->card);
+
+#ifdef CSR_SUPPORT_WEXT
+        /* Notify the Android wpa_supplicant that we are ready */
+        wext_send_started_event(priv);
+
+        queue_work(priv->unifi_workqueue, &priv->sme_config_task);
+#endif
+
+    } else {
+        /* Acknowledge the CsrWifiRouterCtrlWifiOnReq now */
+        CsrWifiRouterCtrlWifiOnCfmSend(msg->source, res->clientData, CSR_RESULT_FAILURE);
+    }
+}
+
+
+void CsrWifiRouterCtrlWifiOffResHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+
+void CsrWifiRouterCtrlMulticastAddressResHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+
+void CsrWifiRouterMaPacketSubscribeReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterMaPacketSubscribeReq* req = (CsrWifiRouterMaPacketSubscribeReq*)msg;
+    CsrUint8 i;
+    CsrResult result;
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterMaPacketSubscribeReqHandler: invalid priv\n");
+        return;
+    }
+
+    /* Look for an unused filter */
+
+    result = CSR_WIFI_RESULT_NO_ROOM;
+    for (i = 0; i < MAX_MA_UNIDATA_IND_FILTERS; i++) {
+
+        if (!priv->sme_unidata_ind_filters[i].in_use) {
+
+            priv->sme_unidata_ind_filters[i].in_use = 1;
+            priv->sme_unidata_ind_filters[i].appHandle = msg->source;
+            priv->sme_unidata_ind_filters[i].encapsulation = req->encapsulation;
+            priv->sme_unidata_ind_filters[i].protocol = req->protocol;
+
+            priv->sme_unidata_ind_filters[i].oui[2] = (CsrUint8)  (req->oui        & 0xFF);
+            priv->sme_unidata_ind_filters[i].oui[1] = (CsrUint8) ((req->oui >>  8) & 0xFF);
+            priv->sme_unidata_ind_filters[i].oui[0] = (CsrUint8) ((req->oui >> 16) & 0xFF);
+
+            result = CSR_RESULT_SUCCESS;
+            break;
+        }
+    }
+
+    unifi_trace(priv, UDBG1,
+                "subscribe_req: encap=%d, handle=%d, result=%d\n",
+                req->encapsulation, i, result);
+    CsrWifiRouterMaPacketSubscribeCfmSend(msg->source,req->interfaceTag, i, result, 0);
+}
+
+
+void CsrWifiRouterMaPacketUnsubscribeReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterMaPacketUnsubscribeReq* req = (CsrWifiRouterMaPacketUnsubscribeReq*)msg;
+    CsrResult result;
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterMaPacketUnsubscribeReqHandler: invalid priv\n");
+        return;
+    }
+
+    result = CSR_WIFI_RESULT_NOT_FOUND;
+
+    if (req->subscriptionHandle < MAX_MA_UNIDATA_IND_FILTERS) {
+        if (priv->sme_unidata_ind_filters[req->subscriptionHandle].in_use) {
+            priv->sme_unidata_ind_filters[req->subscriptionHandle].in_use = 0;
+            result = CSR_RESULT_SUCCESS;
+        } else {
+            result = CSR_WIFI_RESULT_NOT_FOUND;
+        }
+    }
+
+    unifi_trace(priv, UDBG1,
+                "unsubscribe_req: handle=%d, result=%d\n",
+                req->subscriptionHandle, result);
+    CsrWifiRouterMaPacketUnsubscribeCfmSend(msg->source,req->interfaceTag, result);
+}
+
+
+void CsrWifiRouterCtrlCapabilitiesReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlCapabilitiesReq* req = (CsrWifiRouterCtrlCapabilitiesReq*)msg;
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlCapabilitiesReqHandler: invalid priv\n");
+        return;
+    }
+
+    CsrWifiRouterCtrlCapabilitiesCfmSend(msg->source,req->clientData,
+            UNIFI_SOFT_COMMAND_Q_LENGTH - 1,
+            UNIFI_SOFT_TRAFFIC_Q_LENGTH - 1);
+}
+
+
+void CsrWifiRouterCtrlSuspendResHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlSuspendRes* res = (CsrWifiRouterCtrlSuspendRes*)msg;
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlSuspendResHandler: invalid priv\n");
+        return;
+    }
+
+    sme_complete_request(priv, res->status);
+}
+
+
+void CsrWifiRouterCtrlResumeResHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlResumeRes* res = (CsrWifiRouterCtrlResumeRes*)msg;
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlResumeResHandler: invalid priv\n");
+        return;
+    }
+
+    /*
+     * Unless we are in ptest mode, nothing is waiting for the response.
+     * Do not call sme_complete_request(), otherwise the driver
+     * and the SME will be out of step.
+     */
+    if (priv->ptest_mode == 1) {
+        sme_complete_request(priv, res->status);
+    }
+
+}
+
+
+void CsrWifiRouterCtrlTrafficConfigReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlTrafficConfigReq* req = (CsrWifiRouterCtrlTrafficConfigReq*)msg;
+    CsrResult csrResult;
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlTrafficConfigReqHandler: invalid smepriv\n");
+        return;
+    }
+    if (req->trafficConfigType == CSR_WIFI_ROUTER_CTRL_TRAFFIC_CONFIG_TYPE_FILTER)
+    {
+        req->config.packetFilter |= CSR_WIFI_ROUTER_CTRL_TRAFFIC_PACKET_TYPE_CUSTOM;
+    }
+    csrResult = unifi_ta_configure(priv->card, req->trafficConfigType, (const CsrWifiRouterCtrlTrafficConfig *)&req->config);
+}
+
+void CsrWifiRouterCtrlTrafficClassificationReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlTrafficClassificationReq* req = (CsrWifiRouterCtrlTrafficClassificationReq*)msg;
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlTrafficClassificationReqHandler: invalid smepriv\n");
+        return;
+    }
+
+    unifi_ta_classification(priv->card, req->trafficType, req->period);
+}
+
+static int
+_sys_packet_req(unifi_priv_t *priv, const CSR_SIGNAL *signal,
+        CsrUint8 subscriptionHandle,
+        CsrUint16 frameLength, CsrUint8 *frame,
+        int proto)
+{
+    int r;
+    const sme_ma_unidata_ind_filter_t *subs;
+    bulk_data_param_t bulkdata;
+    CSR_MA_PACKET_REQUEST req = signal->u.MaPacketRequest;
+    struct sk_buff *skb, *newSkb = NULL;
+    CsrWifiMacAddress peerMacAddress;
+    CsrResult csrResult;
+    CsrUint16 interfaceTag = req.VirtualInterfaceIdentifier & 0xff;
+    CsrBool eapolStore = FALSE;
+    CsrInt8 protection = 0;
+    netInterface_priv_t *interfacePriv;
+    unsigned long flags;
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "_sys_packet_req: interfaceID >= CSR_WIFI_NUM_INTERFACES.\n");
+        return -EINVAL;
+    }
+    interfacePriv = priv->interfacePriv[interfaceTag];
+    if (!priv->sme_unidata_ind_filters[subscriptionHandle].in_use) {
+        unifi_error(priv, "_sys_packet_req: unknown subscription.\n");
+        return -EINVAL;
+    }
+
+    subs = &priv->sme_unidata_ind_filters[subscriptionHandle];
+    unifi_trace(priv, UDBG1,
+                "_sys_packet_req: handle=%d, subs=%p, encap=%d\n",
+                subscriptionHandle, subs, subs->encapsulation);
+
+    csrResult = unifi_net_data_malloc(priv, &bulkdata.d[0], frameLength);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "_sys_packet_req: failed to allocate bulkdata.\n");
+        return (int)CsrHipResultToStatus(csrResult);
+    }
+
+    /* get the peer Mac address */
+    memcpy(&peerMacAddress, frame, ETH_ALEN);
+
+    /* Determine if we need to add encapsulation header */
+    if (subs->encapsulation == CSR_WIFI_ROUTER_ENCAPSULATION_ETHERNET) {
+        memcpy((void*)bulkdata.d[0].os_data_ptr, frame, frameLength);
+
+        /* The translation is performed on the skb */
+        skb = (struct sk_buff*)bulkdata.d[0].os_net_buf_ptr;
+
+        unifi_trace(priv, UDBG1,
+                    "_sys_packet_req: skb_add_llc_snap -->\n");
+        r = skb_add_llc_snap(priv->netdev[interfaceTag], skb, proto);
+        unifi_trace(priv, UDBG1,
+                    "_sys_packet_req: skb_add_llc_snap <--\n");
+        if (r) {
+            unifi_error(priv,
+                        "_sys_packet_req: failed to translate eth frame.\n");
+            unifi_net_data_free(priv,&bulkdata.d[0]);
+            return r;
+        }
+
+        bulkdata.d[0].data_length = skb->len;
+    } else {
+        /* Crop the MAC addresses from the packet */
+        memcpy((void*)bulkdata.d[0].os_data_ptr, frame + 2*ETH_ALEN, frameLength - 2*ETH_ALEN);
+        bulkdata.d[0].data_length = frameLength - 2*ETH_ALEN;
+        skb = (struct sk_buff*)bulkdata.d[0].os_net_buf_ptr;
+        skb->len = bulkdata.d[0].data_length;
+
+    }
+
+    bulkdata.d[1].os_data_ptr = NULL;
+    bulkdata.d[1].os_net_buf_ptr = NULL;
+    bulkdata.d[1].data_length = 0;
+
+    /* check for m4 detection */
+    if (0 == uf_verify_m4(priv, bulkdata.d[0].os_data_ptr, bulkdata.d[0].data_length)) {
+        eapolStore = TRUE;
+    }
+
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+    if (proto == ETH_P_WAI)
+     {
+        protection = 0; /*WAI packets always sent unencrypted*/
+     }
+   else
+     {
+#endif
+
+#ifdef CSR_SUPPORT_SME
+    if ((protection = uf_get_protection_bit_from_interfacemode(priv, interfaceTag, peerMacAddress.a)) < 0) {
+        unifi_error(priv, "unicast address, but destination not in station record database\n");
+        unifi_net_data_free(priv,&bulkdata.d[0]);
+        return -1;
+    }
+#else
+    protection = 0;
+#endif
+
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+    }
+#endif
+
+    /* add Mac header */
+    if (prepare_and_add_macheader(priv, skb, newSkb, req.Priority, &bulkdata, interfaceTag, frame, frame + ETH_ALEN, protection)) {
+        unifi_error(priv, "failed to create MAC header\n");
+        unifi_net_data_free(priv,&bulkdata.d[0]);
+        return -1;
+    }
+
+    if (eapolStore) {
+        spin_lock_irqsave(&priv->m4_lock, flags);
+        /* Store the EAPOL M4 packet for later */
+        interfacePriv->m4_signal = *signal;
+        interfacePriv->m4_bulk_data.net_buf_length = bulkdata.d[0].net_buf_length;
+        interfacePriv->m4_bulk_data.data_length = bulkdata.d[0].data_length;
+        interfacePriv->m4_bulk_data.os_data_ptr = bulkdata.d[0].os_data_ptr;
+        interfacePriv->m4_bulk_data.os_net_buf_ptr = bulkdata.d[0].os_net_buf_ptr;
+        spin_unlock_irqrestore(&priv->m4_lock, flags);
+        /* Send a signal to SME */
+        unifi_trace(priv, UDBG1, "_sys_packet_req: Sending CsrWifiRouterCtrlM4ReadyToSendInd\n");
+        CsrWifiRouterCtrlM4ReadyToSendIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0, interfaceTag, peerMacAddress);
+        return 0;
+    }
+
+    /* Send the signal to UniFi */
+      /* Set the B31 to 1 for local routing*/
+    r= uf_process_ma_packet_req(priv,  peerMacAddress.a, (req.HostTag | 0x80000000), interfaceTag, 0,
+                                (CSR_RATE)0, req.Priority, signal->SignalPrimitiveHeader.SenderProcessId, &bulkdata);
+    if (r) {
+        unifi_error(priv,
+                    "_sys_packet_req: failed to send signal.\n");
+        unifi_net_data_free(priv,&bulkdata.d[0]);
+        return r;
+    }
+    /* The final CsrWifiRouterMaPacketCfmSend() will called when the actual MA-PACKET.cfm is received from the chip */
+
+    return 0;
+}
+
+void CsrWifiRouterMaPacketReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    int r;
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterMaPacketReq* mareq = (CsrWifiRouterMaPacketReq*)msg;
+    llc_snap_hdr_t *snap;
+    CsrUint16 snap_protocol;
+    CSR_SIGNAL signal;
+    CSR_MA_PACKET_REQUEST *req = &signal.u.MaPacketRequest;
+    CsrWifiRouterCtrlPortAction controlPortaction;
+    CsrUint8 *daddr, *saddr;
+    CsrUint16 interfaceTag = mareq->interfaceTag & 0x00ff;
+    int queue;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if (!mareq->frame || !priv || !priv->smepriv)
+    {
+        unifi_error(priv, "CsrWifiRouterMaPacketReqHandler: invalid frame/priv/priv->smepriv\n");
+        return;
+    }
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "CsrWifiRouterMaPacketReqHandler: interfaceID >= CSR_WIFI_NUM_INTERFACES.\n");
+        return;
+    }
+    /* get a pointer to dest & source Mac address */
+    daddr = mareq->frame;
+    saddr = (mareq->frame + ETH_ALEN);
+    /* point to the proper position of frame, since frame has MAC header */
+    snap = (llc_snap_hdr_t *) (mareq->frame + 2 * ETH_ALEN);
+    snap_protocol = ntohs(snap->protocol);
+    if((snap_protocol == ETH_P_PAE)
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+       || (snap_protocol == ETH_P_WAI)
+#endif
+    )
+    {
+        queue = UF_UNCONTROLLED_PORT_Q;
+    }
+    else
+    {
+        queue = UF_CONTROLLED_PORT_Q;
+    }
+
+    /* Controlled port restrictions apply to the packets */
+    controlPortaction = uf_sme_port_state(priv, daddr, queue, interfaceTag);
+    if (controlPortaction != CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN)
+    {
+        unifi_warning(priv, "CsrWifiRouterMaPacketReqHandler: (%s)controlled port is closed.\n", (queue == UF_CONTROLLED_PORT_Q)?"":"un");
+        if(mareq->cfmRequested)
+        {
+            CsrWifiRouterMaPacketCfmSend(msg->source,
+                                     interfaceTag,
+                                     CSR_RESULT_FAILURE,
+                                     mareq->hostTag, 0);
+        }
+        return;
+    }
+
+    signal.SignalPrimitiveHeader.SignalId = CSR_MA_PACKET_REQUEST_ID;
+    /* Store the appHandle in the LSB of the SenderId. */
+    CSR_COPY_UINT16_TO_LITTLE_ENDIAN(((priv->sme_cli->sender_id & 0xff00) | (unsigned int)msg->source),
+                                     (u8*)&signal.SignalPrimitiveHeader.SenderProcessId);
+    signal.SignalPrimitiveHeader.ReceiverProcessId = 0;
+
+    /* Fill in the MA-PACKET.req signal */
+    memcpy(req->Ra.x, daddr, ETH_ALEN);
+    req->Priority = mareq->priority;
+    req->TransmitRate = 0; /* Let firmware select the rate*/
+    req->VirtualInterfaceIdentifier = uf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag);
+    req->HostTag = mareq->hostTag;
+
+    if(mareq->cfmRequested)
+        req->TransmissionControl = 0;
+    else
+        req->TransmissionControl = CSR_NO_CONFIRM_REQUIRED;
+
+    r = _sys_packet_req(priv, &signal, mareq->subscriptionHandle,
+            mareq->frameLength, mareq->frame, snap_protocol);
+
+#define MAX_RETRY 2
+    if (r && mareq->cfmRequested)
+    {
+        CsrWifiRouterMaPacketCfmSend(msg->source,interfaceTag,
+                                     CSR_RESULT_FAILURE,
+                                     mareq->hostTag, 0);
+    }
+    return;
+}
+
+void CsrWifiRouterMaPacketCancelReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+void CsrWifiRouterCtrlM4TransmitReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlM4TransmitReq* req = (CsrWifiRouterCtrlM4TransmitReq*)msg;
+    int r;
+    bulk_data_param_t bulkdata;
+    netInterface_priv_t *interfacePriv;
+    CSR_SIGNAL m4_signal;
+    unsigned long flags;
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlM4TransmitReqHandler: invalid smepriv\n");
+        return;
+    }
+    if (req->interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "M4TransmitReqHandler: interfaceTag >= CSR_WIFI_NUM_INTERFACES\n");
+        return;
+    }
+
+    interfacePriv = priv->interfacePriv[req->interfaceTag];
+    spin_lock_irqsave(&priv->m4_lock, flags);
+    if (interfacePriv->m4_bulk_data.data_length == 0) {
+        spin_unlock_irqrestore(&priv->m4_lock, flags);
+        unifi_error(priv, "CsrWifiRouterCtrlM4TransmitReqHandler: invalid buffer\n");
+        return;
+    }
+
+    memcpy(&bulkdata.d[0], &interfacePriv->m4_bulk_data, sizeof(bulk_data_desc_t));
+
+    interfacePriv->m4_bulk_data.net_buf_length = 0;
+    interfacePriv->m4_bulk_data.data_length = 0;
+    interfacePriv->m4_bulk_data.os_data_ptr = interfacePriv->m4_bulk_data.os_net_buf_ptr = NULL;
+    m4_signal = interfacePriv->m4_signal;
+    spin_unlock_irqrestore(&priv->m4_lock, flags);
+
+    bulkdata.d[1].os_data_ptr = NULL;
+    bulkdata.d[1].data_length = 0;
+
+    interfacePriv->m4_sent = TRUE;
+    m4_signal.u.MaPacketRequest.HostTag |= 0x80000000;
+    /* Store the hostTag for later varification */
+    interfacePriv->m4_hostTag = m4_signal.u.MaPacketRequest.HostTag;
+    r = ul_send_signal_unpacked(priv, &m4_signal, &bulkdata);
+    unifi_trace(priv, UDBG1,
+                "CsrWifiRouterCtrlM4TransmitReqHandler: sent\n");
+    if (r) {
+        unifi_error(priv,
+                    "CsrWifiRouterCtrlM4TransmitReqHandler: failed to send signal.\n");
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+    }
+}
+
+/* reset the station records when the mode is set as CSR_WIFI_ROUTER_CTRL_MODE_NONE */
+static void CsrWifiRouterCtrlResetStationRecordList(unifi_priv_t *priv, CsrUint16 interfaceTag)
+{
+    CsrUint8 i,j;
+    CsrWifiRouterCtrlStaInfo_t *staInfo=NULL;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    unsigned long lock_flags;
+
+    /* create a list for sending confirms of un-delivered packets */
+    struct list_head send_cfm_list;
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "CsrWifiRouterCtrlResetStationRecordList: bad interfaceTag\n");
+        return;
+    }
+
+    INIT_LIST_HEAD(&send_cfm_list);
+
+    /* Reset the station record to NULL if mode is NONE */
+    for(i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {
+        if ((staInfo=interfacePriv->staInfo[i]) != NULL) {
+            uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                                 &send_cfm_list,
+                                                 &(staInfo->mgtFrames));
+            uf_flush_list(priv,&(staInfo->mgtFrames));
+            for(j=0;j<MAX_ACCESS_CATOGORY;j++){
+                uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                                     &send_cfm_list,
+                                                     &(staInfo->dataPdu[j]));
+                uf_flush_list(priv,&(staInfo->dataPdu[j]));
+            }
+
+            spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+            /* Removing station record information from port config array */
+            memset(staInfo->peerControlledPort, 0, sizeof(unifi_port_cfg_t));
+            staInfo->peerControlledPort->port_action = CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;
+            staInfo->peerControlledPort->in_use = FALSE;
+            interfacePriv->controlled_data_port.entries_in_use--;
+
+            memset(staInfo->peerUnControlledPort, 0, sizeof(unifi_port_cfg_t));
+            staInfo->peerUnControlledPort->port_action = CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;
+            staInfo->peerUnControlledPort->in_use = FALSE;
+            interfacePriv->uncontrolled_data_port.entries_in_use--;
+
+            kfree(interfacePriv->staInfo[i]);
+            interfacePriv->staInfo[i] = NULL;
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+        }
+    }
+    /* after the critical region process the list of frames that requested cfm
+     * and send cfm to requestor one by one
+     */
+    send_auto_ma_packet_confirm(priv, interfacePriv, &send_cfm_list);
+
+#ifdef CSR_SUPPORT_SME
+    /* Interface Independent, no of packet queued, incase of mode is None or AP set to 0 */
+    switch(interfacePriv->interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+        case CSR_WIFI_ROUTER_CTRL_MODE_NONE:
+            if (priv->noOfPktQueuedInDriver) {
+                unifi_warning(priv, "After reset the noOfPktQueuedInDriver = %x\n", priv->noOfPktQueuedInDriver);
+                spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                priv->noOfPktQueuedInDriver = 0;
+                spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+            }
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_IBSS:
+            break;
+        default:
+            unifi_error(priv, "interfacemode is not correct in CsrWifiRouterCtrlResetStationRecordList: debug\n");
+    }
+#endif
+
+    if (((interfacePriv->controlled_data_port.entries_in_use != 0) || (interfacePriv->uncontrolled_data_port.entries_in_use != 0))
+            && (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_NONE)) {
+        /* Print in case if the value of entries goes to -ve/+ve (apart from 0)
+         * we expect the entries should be zero here if mode is set as NONE
+         */
+        unifi_trace(priv, UDBG3, "In %s controlled port entries = %d, uncontrolled port entries = %d\n",
+                   __FUNCTION__, interfacePriv->controlled_data_port.entries_in_use,
+                   interfacePriv->uncontrolled_data_port.entries_in_use);
+    }
+}
+
+void CsrWifiRouterCtrlInterfaceReset(unifi_priv_t *priv, CsrUint16 interfaceTag)
+{
+    netInterface_priv_t *interfacePriv;
+
+    /* create a list for sending confirms of un-delivered packets */
+    struct list_head send_cfm_list;
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "CsrWifiRouterCtrlInterfaceReset: bad interfaceTag\n");
+        return;
+    }
+
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    INIT_LIST_HEAD(&send_cfm_list);
+
+    /* Enable all queues by default */
+    interfacePriv->queueEnabled[0] = 1;
+    interfacePriv->queueEnabled[1] = 1;
+    interfacePriv->queueEnabled[2] = 1;
+    interfacePriv->queueEnabled[3] = 1;
+
+    uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                             &send_cfm_list,
+                                             &(interfacePriv->genericMgtFrames));
+    uf_flush_list(priv,&(interfacePriv->genericMgtFrames));
+
+    uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                             &send_cfm_list,
+                                             &(interfacePriv->genericMulticastOrBroadCastMgtFrames));
+    uf_flush_list(priv,&(interfacePriv->genericMulticastOrBroadCastMgtFrames));
+
+    uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                             &send_cfm_list,
+                                             &(interfacePriv->genericMulticastOrBroadCastFrames));
+
+    uf_flush_list(priv,&(interfacePriv->genericMulticastOrBroadCastFrames));
+    uf_flush_maPktlist(priv,&(interfacePriv->directedMaPktReq));
+
+    /*  process the list of frames that requested cfm
+    and send cfm to requestor one by one */
+    send_auto_ma_packet_confirm(priv, interfacePriv, &send_cfm_list);
+
+    /* Reset the station record to NULL if mode is tried to set as NONE */
+    switch(interfacePriv->interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_STA:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:
+        case CSR_WIFI_ROUTER_CTRL_MODE_MONITOR:
+        case CSR_WIFI_ROUTER_CTRL_MODE_AMP:
+            /* station records not available in these modes */
+            break;
+        default:
+            CsrWifiRouterCtrlResetStationRecordList(priv,interfaceTag);
+    }
+
+    interfacePriv->num_stations_joined = 0;
+    interfacePriv->sta_activity_check_enabled = FALSE;
+}
+
+
+void CsrWifiRouterCtrlModeSetReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlModeSetReq* req = (CsrWifiRouterCtrlModeSetReq*)msg;
+
+    if (priv == NULL)
+    {
+        unifi_error(priv, "CsrWifiRouterCtrlModeSetReqHandler: invalid smepriv\n");
+        return;
+    }
+
+    if (req->interfaceTag < CSR_WIFI_NUM_INTERFACES)
+    {
+        netInterface_priv_t *interfacePriv = priv->interfacePriv[req->interfaceTag];
+
+        unifi_trace(priv, UDBG1, "CsrWifiRouterCtrlModeSetReqHandler: interfacePriv->interfaceMode = %d\n",
+                interfacePriv->interfaceMode);
+
+        /* Cleanup the database first for current existing mode, Then take
+         * care of setting the new mode (Transition seq: AnyMode->NoneMode->newMode)
+         * So for Every mode changes, Database Initialization/cleanup needed
+         */
+        CsrWifiRouterCtrlInterfaceReset(priv,req->interfaceTag);
+
+        interfacePriv->interfaceMode = req->mode;
+        interfacePriv->bssid = req->bssid;
+        /* For modes other than AP/P2PGO, set below member FALSE */
+        interfacePriv->intraBssEnabled = FALSE;
+
+
+        if(req->mode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+           req->mode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+            interfacePriv->protect = req->protection;
+            interfacePriv->dtimActive=FALSE;
+            interfacePriv->multicastPduHostTag = 0xffffffff;
+            /* For AP/P2PGO mode SME sending intraBssDistEnabled
+             * i.e. for AP: intraBssDistEnabled = TRUE, for P2PGO
+             * intraBssDistEnabled = TRUE/FALSE on requirement
+             */
+            interfacePriv->intraBssEnabled = req->intraBssDistEnabled;
+            unifi_trace(priv, UDBG3, "CsrWifiRouterCtrlModeSetReqHandler: IntraBssDisEnabled = %d\n",
+                        req->intraBssDistEnabled);
+        } else if (req->mode == CSR_WIFI_ROUTER_CTRL_MODE_NONE) {
+              netif_carrier_off(priv->netdev[req->interfaceTag]);
+              interfacePriv->connected = UnifiConnectedUnknown;
+        }
+    }
+    else {
+        unifi_error(priv, "CsrWifiRouterCtrlModeSetReqHandler: invalid interfaceTag :%d\n",req->interfaceTag);
+    }
+}
+
+void CsrWifiRouterMaPacketResHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+}
+
+/* delete the station record from the station record data base */
+static int peer_delete_record(unifi_priv_t *priv, CsrWifiRouterCtrlPeerDelReq *req)
+{
+    CsrUint8 j;
+    CsrWifiRouterCtrlStaInfo_t *staInfo = NULL;
+    unifi_port_config_t *controlledPort;
+    unifi_port_config_t *unControlledPort;
+    netInterface_priv_t *interfacePriv;
+    maPktReqList_t *maPktreq;
+    struct list_head *listHeadMaPktreq,*placeHolderMaPktreq;
+
+    CsrUint8 ba_session_idx = 0;
+    ba_session_rx_struct *ba_session_rx = NULL;
+    ba_session_tx_struct *ba_session_tx = NULL;
+
+    /* create a list for sending confirms of un-delivered packets */
+    struct list_head send_cfm_list;
+
+    unsigned long lock_flags;
+
+    if ((req->peerRecordHandle >= UNIFI_MAX_CONNECTIONS) || (req->interfaceTag >= CSR_WIFI_NUM_INTERFACES)) {
+        unifi_error(priv, "handle/interfaceTag is not proper, handle = %d, interfaceTag = %d\n", req->peerRecordHandle, req->interfaceTag);
+        return CSR_RESULT_FAILURE;
+    }
+
+    INIT_LIST_HEAD(&send_cfm_list);
+
+    interfacePriv = priv->interfacePriv[req->interfaceTag];
+    /* remove the station record & make it NULL */
+    if ((staInfo=interfacePriv->staInfo[req->peerRecordHandle])!=NULL) {
+
+        uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                                 &send_cfm_list,
+                                                 &(staInfo->mgtFrames));
+
+        uf_flush_list(priv,&(staInfo->mgtFrames));
+        for(j=0;j<MAX_ACCESS_CATOGORY;j++){
+            uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                                     &send_cfm_list,
+                                                     &(staInfo->dataPdu[j]));
+            uf_flush_list(priv,&(staInfo->dataPdu[j]));
+        }
+
+        /* There may be race condition
+           before getting the ma_packet_cfm from f/w, driver may receive peer del from SME
+        */
+        spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+        list_for_each_safe(listHeadMaPktreq, placeHolderMaPktreq, &interfacePriv->directedMaPktReq) {
+            maPktreq = list_entry(listHeadMaPktreq, maPktReqList_t, q);
+            if(maPktreq->staHandler== staInfo->assignedHandle){
+                dev_kfree_skb(maPktreq->skb);
+                list_del(listHeadMaPktreq);
+                kfree(maPktreq);
+            }
+
+        }
+        spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+
+        spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+        /* clear the port configure array info, for the corresponding peer entry */
+        controlledPort = &interfacePriv->controlled_data_port;
+        unControlledPort = &interfacePriv->uncontrolled_data_port;
+
+        unifi_trace(priv, UDBG1, "peer_delete_record: Peer found handle = %d, port in use: cont(%d), unCont(%d)\n",
+                    req->peerRecordHandle, controlledPort->entries_in_use, unControlledPort->entries_in_use);
+
+        memset(staInfo->peerControlledPort, 0, sizeof(unifi_port_cfg_t));
+        staInfo->peerControlledPort->port_action = CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;
+        staInfo->peerControlledPort->in_use = FALSE;
+        if (controlledPort->entries_in_use) {
+            controlledPort->entries_in_use--;
+        } else {
+            unifi_warning(priv, "number of controlled port entries is zero, trying to decrement: debug\n");
+        }
+
+        memset(staInfo->peerUnControlledPort, 0, sizeof(unifi_port_cfg_t));
+        staInfo->peerUnControlledPort->port_action = CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;
+        staInfo->peerUnControlledPort->in_use = FALSE;
+        if (unControlledPort->entries_in_use) {
+            unControlledPort->entries_in_use--;
+        } else {
+            unifi_warning(priv, "number of uncontrolled port entries is zero, trying to decrement: debug\n");
+        }
+
+        spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+        /* update the TIM with zero */
+        if (interfacePriv->interfaceMode != CSR_WIFI_ROUTER_CTRL_MODE_IBSS &&
+                staInfo->timSet == CSR_WIFI_TIM_SET) {
+            unifi_trace(priv, UDBG3, "peer is deleted so TIM updated to 0, in firmware\n");
+            update_tim(priv,staInfo->aid,0,req->interfaceTag, req->peerRecordHandle);
+        }
+
+
+        /* Stop BA session if it is active, for this peer address all BA sessions
+        (per tID per role) are closed */
+
+        spin_lock(&priv->ba_lock);
+        for(ba_session_idx=0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_RX; ba_session_idx++){
+            ba_session_rx = priv->interfacePriv[req->interfaceTag]->ba_session_rx[ba_session_idx];
+            if(ba_session_rx) {
+                if(!memcmp(ba_session_rx->macAddress.a, staInfo->peerMacAddress.a, ETH_ALEN)){
+                    blockack_session_stop(priv,
+                                        req->interfaceTag,
+                                        CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_RECIPIENT,
+                                        ba_session_rx->tID,
+                                        ba_session_rx->macAddress);
+                }
+            }
+        }
+
+        for(ba_session_idx=0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_TX; ba_session_idx++){
+            ba_session_tx = priv->interfacePriv[req->interfaceTag]->ba_session_tx[ba_session_idx];
+            if(ba_session_tx) {
+                if(!memcmp(ba_session_tx->macAddress.a, staInfo->peerMacAddress.a, ETH_ALEN)){
+                    blockack_session_stop(priv,
+                                        req->interfaceTag,
+                                        CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ORIGINATOR,
+                                        ba_session_tx->tID,
+                                        ba_session_tx->macAddress);
+                }
+            }
+        }
+
+        spin_unlock(&priv->ba_lock);
+
+#ifdef CSR_SUPPORT_SME
+        unifi_trace(priv, UDBG1, "Canceling work queue for STA with AID: %d\n", staInfo->aid);
+        cancel_work_sync(&staInfo->send_disconnected_ind_task);
+#endif
+
+        spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+#ifdef CSR_SUPPORT_SME
+        interfacePriv->num_stations_joined--;
+
+        staInfo->nullDataHostTag = INVALID_HOST_TAG;
+
+        if ((interfacePriv->sta_activity_check_enabled) &&
+            (interfacePriv->num_stations_joined < STA_INACTIVE_DETECTION_TRIGGER_THRESHOLD))
+        {
+            unifi_trace(priv, UDBG1, "STOPPING the Inactivity Timer (num of stations = %d)\n", interfacePriv->num_stations_joined);
+            interfacePriv->sta_activity_check_enabled = FALSE;
+            del_timer_sync(&interfacePriv->sta_activity_check_timer);
+        }
+#endif
+
+        /* Free the station record for corresponding peer */
+        kfree(interfacePriv->staInfo[req->peerRecordHandle]);
+        interfacePriv->staInfo[req->peerRecordHandle] = NULL;
+        spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+
+        /* after the critical region process the list of frames that requested cfm
+        and send cfm to requestor one by one */
+        send_auto_ma_packet_confirm(priv, interfacePriv, &send_cfm_list);
+
+
+    }
+    else
+    {
+        unifi_trace(priv, UDBG3, " peer not found: Delete request Peer handle[%d]\n", req->peerRecordHandle);
+    }
+
+    return CSR_RESULT_SUCCESS;
+}
+
+void CsrWifiRouterCtrlPeerDelReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    CsrWifiRouterCtrlPeerDelReq* req = (CsrWifiRouterCtrlPeerDelReq*)msg;
+    CsrResult status = CSR_RESULT_SUCCESS;
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[req->interfaceTag];
+
+    unifi_trace(priv, UDBG2, "entering CsrWifiRouterCtrlPeerDelReqHandler \n");
+    if (priv == NULL)
+    {
+        unifi_error(priv, "CsrWifiRouterCtrlPeerDelReqHandler: invalid smepriv\n");
+        return;
+    }
+
+    if (req->interfaceTag >= CSR_WIFI_NUM_INTERFACES)
+    {
+        unifi_error(priv, "CsrWifiRouterCtrlPeerDelReqHandler: bad interfaceTag\n");
+        return;
+    }
+
+    switch(interfacePriv->interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_IBSS:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            /* remove the station from station record data base */
+            status = peer_delete_record(priv, req);
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_STA:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:
+        default:
+            /* No station record to maintain in these modes */
+            break;
+    }
+
+    CsrWifiRouterCtrlPeerDelCfmSend(msg->source,req->clientData,req->interfaceTag,status);
+    unifi_trace(priv, UDBG2, "leaving CsrWifiRouterCtrlPeerDelReqHandler \n");
+}
+
+/* Add the new station to the station record data base */
+static int peer_add_new_record(unifi_priv_t *priv,CsrWifiRouterCtrlPeerAddReq *req,CsrUint32 *handle)
+{
+    CsrUint8 i, powerModeTemp = 0;
+    CsrBool freeSlotFound = FALSE;
+    CsrWifiRouterCtrlStaInfo_t *newRecord = NULL;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[req->interfaceTag];
+    CsrTime currentTime, currentTimeHi;
+    unsigned long lock_flags;
+
+    if (req->interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "peer_add_new_record: bad interfaceTag\n");
+        return CSR_RESULT_FAILURE;
+    }
+
+    currentTime = CsrTimeGet(&currentTimeHi);
+
+    for(i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {
+        if(interfacePriv->staInfo[i] == NULL) {
+            /* Slot is empty, so can be used for station record */
+            freeSlotFound = TRUE;
+            *handle = i;
+
+            /* Allocate for the new station record , to avoid race condition would happen between ADD_PEER &
+             * DEL_PEER the allocation made atomic memory rather than kernel memory
+             */
+            newRecord = (CsrWifiRouterCtrlStaInfo_t *) kmalloc(sizeof(CsrWifiRouterCtrlStaInfo_t), GFP_ATOMIC);
+            if (!newRecord) {
+                unifi_error(priv, "failed to allocate the %d bytes of mem for station record\n",
+                            sizeof(CsrWifiRouterCtrlStaInfo_t));
+                return CSR_RESULT_FAILURE;
+            }
+
+            unifi_trace(priv, UDBG1, "peer_add_new_record: handle = %d AID = %d addr = %x:%x:%x:%x:%x:%x LI=%u\n",
+                        *handle, req->associationId, req->peerMacAddress.a[0], req->peerMacAddress.a[1], req->peerMacAddress.a[2],
+                        req->peerMacAddress.a[3], req->peerMacAddress.a[4], req->peerMacAddress.a[5],
+                        req->staInfo.listenIntervalInTus);
+
+            /* disable the preemption until station record updated */
+            spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+
+            interfacePriv->staInfo[i] = newRecord;
+            /* Initialize the record*/
+            memset(newRecord,0,sizeof(CsrWifiRouterCtrlStaInfo_t));
+            /* update the station record */
+            memcpy(newRecord->peerMacAddress.a, req->peerMacAddress.a, ETH_ALEN);
+            newRecord->wmmOrQosEnabled = req->staInfo.wmmOrQosEnabled;
+
+            /* maxSpLength is bit map in qosInfo field, so converting accordingly */
+            newRecord->maxSpLength = req->staInfo.maxSpLength * 2;
+
+            /*Max SP 0 mean any number of packets. since we buffer only 512
+            packets we are hard coding this to zero for the moment */
+
+            if(newRecord->maxSpLength == 0)
+                newRecord->maxSpLength=512;
+
+            newRecord->assignedHandle = i;
+
+             /* copy power save mode of all access catagory (Trigger/Delivery/both enabled/disabled) */
+            powerModeTemp = (CsrUint8) ((req->staInfo.powersaveMode >> 4) & 0xff);
+
+            if(!(req->staInfo.powersaveMode & 0x0001))
+                newRecord->powersaveMode[UNIFI_TRAFFIC_Q_BK]= CSR_WIFI_AC_LEGACY_POWER_SAVE;
+            else
+               newRecord->powersaveMode[UNIFI_TRAFFIC_Q_BK]= powerModeTemp & 0x03;
+
+            if(!(req->staInfo.powersaveMode & 0x0002))
+                newRecord->powersaveMode[UNIFI_TRAFFIC_Q_BE]= CSR_WIFI_AC_LEGACY_POWER_SAVE;
+            else
+               newRecord->powersaveMode[UNIFI_TRAFFIC_Q_BE]= ((powerModeTemp & 0x0C)>> 2);
+
+            if(!(req->staInfo.powersaveMode & 0x0004))
+                newRecord->powersaveMode[UNIFI_TRAFFIC_Q_VI]= CSR_WIFI_AC_LEGACY_POWER_SAVE;
+            else
+               newRecord->powersaveMode[UNIFI_TRAFFIC_Q_VI]= ((powerModeTemp & 0x30)>> 4);
+
+            if(!(req->staInfo.powersaveMode & 0x0008))
+                newRecord->powersaveMode[UNIFI_TRAFFIC_Q_VO]= CSR_WIFI_AC_LEGACY_POWER_SAVE;
+            else
+               newRecord->powersaveMode[UNIFI_TRAFFIC_Q_VO]= ((powerModeTemp & 0xC0)>> 6);
+
+            {
+                CsrUint8 k;
+                for(k=0; k< MAX_ACCESS_CATOGORY ;k++)
+                    unifi_trace(priv, UDBG2, "peer_add_new_record: WMM : %d ,AC %d, powersaveMode %x \n",
+                            req->staInfo.wmmOrQosEnabled,k,newRecord->powersaveMode[k]);
+            }
+
+            unifi_trace(priv, UDBG3, "newRecord->wmmOrQosEnabled : %d , MAX SP : %d\n",
+                    newRecord->wmmOrQosEnabled,newRecord->maxSpLength);
+
+            /* Initialize the mgtFrames & data Pdu list */
+            {
+                CsrUint8 j;
+                INIT_LIST_HEAD(&newRecord->mgtFrames);
+                for(j = 0; j < MAX_ACCESS_CATOGORY; j++) {
+                    INIT_LIST_HEAD(&newRecord->dataPdu[j]);
+                }
+            }
+
+            newRecord->lastActivity = currentTime;
+            newRecord->activity_flag = TRUE;
+
+            /* enable the preemption as station record updated */
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+
+            /* First time port actions are set for the peer with below information */
+            configure_data_port(priv, CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN, &newRecord->peerMacAddress,
+                                UF_UNCONTROLLED_PORT_Q, req->interfaceTag);
+
+            if (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_IBSS) {
+                configure_data_port(priv, CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN, &newRecord->peerMacAddress,
+                                    UF_CONTROLLED_PORT_Q, req->interfaceTag);
+            } else {
+                configure_data_port(priv, CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD, &newRecord->peerMacAddress,
+                                    UF_CONTROLLED_PORT_Q, req->interfaceTag);
+            }
+
+
+            spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+            /* Port status must be already set before calling the Add Peer request */
+            newRecord->peerControlledPort = uf_sme_port_config_handle(priv, newRecord->peerMacAddress.a,
+                                                                      UF_CONTROLLED_PORT_Q, req->interfaceTag);
+            newRecord->peerUnControlledPort = uf_sme_port_config_handle(priv, newRecord->peerMacAddress.a,
+                                                                        UF_UNCONTROLLED_PORT_Q, req->interfaceTag);
+
+            if (!newRecord->peerControlledPort || !newRecord->peerUnControlledPort) {
+                /* enable the preemption as station record failed to update */
+                unifi_warning(priv, "Un/ControlledPort record not found in port configuration array index = %d\n", i);
+                kfree(interfacePriv->staInfo[i]);
+                interfacePriv->staInfo[i] = NULL;
+                spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+                return CSR_RESULT_FAILURE;
+            }
+
+            newRecord->currentPeerState = CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE;
+
+            /* changes done during block ack handling */
+            newRecord->txSuspend = FALSE;
+
+            /*U-APSD related data structure*/
+            newRecord->uapsdActive = FALSE;
+            newRecord->noOfSpFramesSent =0;
+
+            /* The protection bit is updated once the port opens for corresponding peer in
+             * routerPortConfigure request */
+
+            /* update the association ID */
+            newRecord->aid = req->associationId;
+
+#ifdef CSR_SUPPORT_SME
+            interfacePriv->num_stations_joined++;
+            newRecord->interfacePriv = interfacePriv;
+            newRecord->listenIntervalInTus = req->staInfo.listenIntervalInTus;
+            newRecord->nullDataHostTag = INVALID_HOST_TAG;
+
+            INIT_WORK(&newRecord->send_disconnected_ind_task, uf_send_disconnected_ind_wq);
+
+            if(!(interfacePriv->sta_activity_check_enabled) &&
+               (interfacePriv->num_stations_joined >= STA_INACTIVE_DETECTION_TRIGGER_THRESHOLD)){
+                unifi_trace(priv, UDBG1,
+                            "peer_add_new_record: STARTING the Inactivity Timer (num of stations = %d)",
+                            interfacePriv->num_stations_joined);
+
+                interfacePriv->sta_activity_check_enabled = TRUE;
+                interfacePriv->sta_activity_check_timer.function = check_inactivity_timer_expire_func;
+                interfacePriv->sta_activity_check_timer.data = (unsigned long)interfacePriv;
+
+                init_timer(&interfacePriv->sta_activity_check_timer);
+                mod_timer(&interfacePriv->sta_activity_check_timer,
+                          (jiffies + usecs_to_jiffies(STA_INACTIVE_DETECTION_TIMER_INTERVAL * 1000 * 1000)));
+
+            }
+#endif
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+            break;
+        }
+    }
+
+    if(!freeSlotFound) {
+        unifi_error(priv, "Limited connectivity, Free slot not found for station record addition\n");
+        return CSR_RESULT_FAILURE;
+    }
+    return CSR_RESULT_SUCCESS;
+}
+
+#ifdef CSR_SUPPORT_SME
+static void check_inactivity_timer_expire_func(unsigned long data)
+{
+    struct unifi_priv *priv;
+    CsrWifiRouterCtrlStaInfo_t *sta_record = NULL;
+    CsrUint8 i = 0;
+    CsrTime now;
+    CsrTime inactive_time;
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *) data;
+
+    if (!interfacePriv)
+    {
+        return;
+    }
+
+    priv = interfacePriv->privPtr;
+
+    if (interfacePriv->InterfaceTag >= CSR_WIFI_NUM_INTERFACES)
+    {
+        unifi_error(priv, "check_inactivity_timer_expire_func: Invalid interfaceTag\n");
+        return;
+    }
+
+    /* RUN Algorithm to check inactivity for each connected station */
+    now = CsrTimeGet(NULL);
+
+    for(i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {
+        if(interfacePriv->staInfo[i] != NULL) {
+            sta_record = interfacePriv->staInfo[i];
+
+            if (sta_record->activity_flag == TRUE){
+                sta_record->activity_flag = FALSE;
+                sta_record->lastActivity = now;
+                continue;
+            }
+
+            if (sta_record->lastActivity > now)
+            {
+                /* simple timer wrap (for 1 wrap) */
+                inactive_time = CsrTimeAdd((CsrTime)CsrTimeSub(CSR_SCHED_TIME_MAX, sta_record->lastActivity), now);
+            }
+            else
+            {
+                inactive_time = (CsrTime)CsrTimeSub(now, sta_record->lastActivity);
+            }
+
+            if (inactive_time >= STA_INACTIVE_TIMEOUT_VAL)
+            {
+                unifi_trace(priv, UDBG1, "STA is Inactive - AID = %d inactive_time = %d\n",
+                                        sta_record->aid,
+                                        inactive_time);
+
+                /* station is in-active, if it is in active mode send a null frame
+                 * and the station should acknowledge the null frame, if acknowledgement
+                 * is not received throw out the station.
+                 * If the station is in Power Save, update TIM for the station so
+                 * that it wakes up and register some activity through PS-Poll or
+                 * trigger frame.
+                 */
+                 if (sta_record->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE)
+                 {
+                    unifi_trace(priv, UDBG1, "STA power save state - Active, send a NULL frame to check if it is ALIVE\n");
+                    uf_send_nulldata ( priv,
+                                       sta_record->interfacePriv->InterfaceTag,
+                                       sta_record->peerMacAddress.a,
+                                       CSR_CONTENTION,
+                                       sta_record);
+                 }
+                 else if (sta_record->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)
+                 {
+                    if((sta_record->timSet == CSR_WIFI_TIM_SET) ||
+                       (sta_record->timSet == CSR_WIFI_TIM_SETTING))
+                    {
+                        unifi_trace(priv, UDBG1, "STA power save state - PS, TIM is already SET\n");
+
+                        /* If TIM is set and we do not have any activity for
+                         * more than 3 listen intervals then send a disconnected
+                         * indication to SME, to delete the station from station
+                         * record list.
+                         * The inactivity is already more than STA_INACTIVE_TIMEOUT_VAL
+                         * and this check ensures if the listen interval is a larger
+                         * value than STA_INACTIVE_TIMEOUT_VAL.
+                         */
+                         if (inactive_time > (3 * (sta_record->listenIntervalInTus * 1024)))
+                         {
+                            unifi_trace(priv, UDBG1, "STA is inactive for more than 3 listen intervals\n");
+                            queue_work( priv->unifi_workqueue,
+                                        &sta_record->send_disconnected_ind_task);
+                         }
+
+                    }
+                    else
+                    {
+                        unifi_trace(priv, UDBG1, "STA power save state - PS, update TIM to see if it is ALIVE\n");
+                        update_tim(priv,
+                                   sta_record->aid,
+                                   CSR_WIFI_TIM_SET,
+                                   interfacePriv->InterfaceTag,
+                                   sta_record->assignedHandle);
+                    }
+                 }
+            }
+        }
+    }
+
+    /* re-run the timer interrupt */
+    mod_timer(&interfacePriv->sta_activity_check_timer,
+              (jiffies + usecs_to_jiffies(STA_INACTIVE_DETECTION_TIMER_INTERVAL * 1000 * 1000)));
+
+}
+
+
+void uf_send_disconnected_ind_wq(struct work_struct *work)
+{
+
+    CsrWifiRouterCtrlStaInfo_t *staInfo = container_of(work, CsrWifiRouterCtrlStaInfo_t, send_disconnected_ind_task);
+    unifi_priv_t *priv;
+    CsrUint16 interfaceTag;
+    struct list_head send_cfm_list;
+    CsrUint8 j;
+
+    func_enter();
+
+    if(!staInfo) {
+        return;
+    }
+
+    if(!staInfo->interfacePriv) {
+        return;
+    }
+
+    priv = staInfo->interfacePriv->privPtr;
+    interfaceTag =  staInfo->interfacePriv->InterfaceTag;
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "uf_send_disconnected_ind_wq: invalid interfaceTag\n");
+        return;
+    }
+
+    /* The SME/NME may be waiting for confirmation for requested frames to this station.
+     * So loop through buffered frames for this station and if confirmation is
+     * requested, send auto confirmation with failure status. Also flush the frames so
+     * that these are not processed again in PEER_DEL_REQ handler.
+     */
+    INIT_LIST_HEAD(&send_cfm_list);
+
+    uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                             &send_cfm_list,
+                                             &(staInfo->mgtFrames));
+
+    uf_flush_list(priv, &(staInfo->mgtFrames));
+
+    for(j = 0; j < MAX_ACCESS_CATOGORY; j++){
+        uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                                 &send_cfm_list,
+                                                 &(staInfo->dataPdu[j]));
+
+        uf_flush_list(priv,&(staInfo->dataPdu[j]));
+    }
+
+    send_auto_ma_packet_confirm(priv, staInfo->interfacePriv, &send_cfm_list);
+
+    unifi_warning(priv, "uf_send_disconnected_ind_wq: Router Disconnected IND Peer (%x-%x-%x-%x-%x-%x)\n",
+                staInfo->peerMacAddress.a[0],
+                staInfo->peerMacAddress.a[1],
+                staInfo->peerMacAddress.a[2],
+                staInfo->peerMacAddress.a[3],
+                staInfo->peerMacAddress.a[4],
+                staInfo->peerMacAddress.a[5]);
+
+    CsrWifiRouterCtrlConnectedIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,
+                                      0,
+                                      staInfo->interfacePriv->InterfaceTag,
+                                      staInfo->peerMacAddress,
+                                      CSR_WIFI_ROUTER_CTRL_PEER_DISCONNECTED);
+
+
+    return;
+}
+
+
+#endif
+void CsrWifiRouterCtrlPeerAddReqHandler(void* drvpriv,CsrWifiFsmEvent* msg)
+{
+    CsrWifiRouterCtrlPeerAddReq* req = (CsrWifiRouterCtrlPeerAddReq*)msg;
+    CsrResult status = CSR_RESULT_SUCCESS;
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrUint32 handle = 0;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[req->interfaceTag];
+
+    unifi_trace(priv, UDBG2, "entering CsrWifiRouterCtrlPeerAddReqHandler \n");
+    if (priv == NULL)
+    {
+        unifi_error(priv, "CsrWifiRouterCtrlPeerAddReqHandler: invalid smepriv\n");
+        return;
+    }
+
+    if (req->interfaceTag >= CSR_WIFI_NUM_INTERFACES)
+    {
+        unifi_error(priv, "CsrWifiRouterCtrlPeerAddReqHandler: bad interfaceTag\n");
+        return;
+    }
+
+    switch(interfacePriv->interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_IBSS:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            /* Add station record */
+            status = peer_add_new_record(priv,req,&handle);
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_STA:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:
+        default:
+            /* No station record to maintain in these modes */
+            break;
+    }
+
+    CsrWifiRouterCtrlPeerAddCfmSend(msg->source,req->clientData,req->interfaceTag,req->peerMacAddress,handle,status);
+    unifi_trace(priv, UDBG2, "leaving CsrWifiRouterCtrlPeerAddReqHandler \n");
+}
+
+void CsrWifiRouterCtrlPeerUpdateReqHandler(void* drvpriv,CsrWifiFsmEvent* msg)
+{
+    CsrWifiRouterCtrlPeerUpdateReq* req = (CsrWifiRouterCtrlPeerUpdateReq*)msg;
+    CsrResult status = CSR_RESULT_SUCCESS;
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+
+    unifi_trace(priv, UDBG2, "entering CsrWifiRouterCtrlPeerUpdateReqHandler \n");
+    if (priv == NULL)
+    {
+        unifi_error(priv, "CsrWifiRouterCtrlPeerUpdateReqHandler: invalid smepriv\n");
+        return;
+    }
+
+    CsrWifiRouterCtrlPeerUpdateCfmSend(msg->source,req->clientData,req->interfaceTag,status);
+    unifi_trace(priv, UDBG2, "leaving CsrWifiRouterCtrlPeerUpdateReqHandler \n");
+}
+
+
+ void CsrWifiRouterCtrlRawSdioDeinitialiseReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    /* This will never be called as it is intercepted in the Userspace */
+}
+
+void CsrWifiRouterCtrlRawSdioInitialiseReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    /* This will never be called as it is intercepted in the Userspace */
+}
+
+void
+uf_send_ba_err_wq(struct work_struct *work)
+{
+    ba_session_rx_struct *ba_session = container_of(work, ba_session_rx_struct, send_ba_err_task);
+    unifi_priv_t *priv;
+
+    if(!ba_session) {
+        return;
+    }
+
+    if(!ba_session->interfacePriv) {
+        return;
+    }
+
+    priv = ba_session->interfacePriv->privPtr;
+
+    if (ba_session->interfacePriv->InterfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "%s: invalid interfaceTag\n", __FUNCTION__);
+        return;
+    }
+
+    unifi_warning(priv, "%s: Calling CsrWifiRouterCtrlBlockAckErrorIndSend(%d, %d, %d, %d, %x:%x:%x:%x:%x:%x, %d)\n",
+                    __FUNCTION__,
+                    priv->CSR_WIFI_SME_IFACEQUEUE,
+                    0,
+                    ba_session->interfacePriv->InterfaceTag,
+                    ba_session->tID,
+                    ba_session->macAddress.a[0],
+                    ba_session->macAddress.a[1],
+                    ba_session->macAddress.a[2],
+                    ba_session->macAddress.a[3],
+                    ba_session->macAddress.a[4],
+                    ba_session->macAddress.a[5],
+                    CSR_RESULT_SUCCESS
+                 );
+    CsrWifiRouterCtrlBlockAckErrorIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,
+                    0,
+                    ba_session->interfacePriv->InterfaceTag,
+                    ba_session->tID,
+                    ba_session->macAddress,
+                    CSR_RESULT_SUCCESS);
+}
+
+
+static void ba_session_terminate_timer_func(unsigned long data)
+{
+    ba_session_rx_struct *ba_session = (ba_session_rx_struct*)data;
+    struct unifi_priv *priv;
+
+    if(!ba_session) {
+        return;
+    }
+
+    if(!ba_session->interfacePriv) {
+        return;
+    }
+
+    priv = ba_session->interfacePriv->privPtr;
+
+    if (ba_session->interfacePriv->InterfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "%s: invalid interfaceTag\n", __FUNCTION__);
+        return;
+    }
+
+    queue_work(priv->unifi_workqueue, &ba_session->send_ba_err_task);
+}
+
+
+CsrBool blockack_session_stop(unifi_priv_t *priv,
+                                     CsrUint16 interfaceTag,
+                                     CsrWifiRouterCtrlBlockAckRole role,
+                                     CsrUint16 tID,
+                                     CsrWifiMacAddress macAddress)
+{
+    netInterface_priv_t *interfacePriv;
+    ba_session_rx_struct *ba_session_rx = NULL;
+    ba_session_tx_struct *ba_session_tx = NULL;
+    CsrUint8 ba_session_idx = 0;
+    int i;
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "%s: bad interfaceTag = %d\n", __FUNCTION__, interfaceTag);
+        return FALSE;
+    }
+
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if(!interfacePriv) {
+        unifi_error(priv, "%s: bad interfacePriv\n", __FUNCTION__);
+        return FALSE;
+    }
+
+    if(tID > 15) {
+        unifi_error(priv, "%s: bad tID = %d\n", __FUNCTION__, tID);
+        return FALSE;
+    }
+
+    if((role != CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ORIGINATOR) &&
+        (role != CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_RECIPIENT)) {
+        unifi_error(priv, "%s: bad role = %d\n", __FUNCTION__, role);
+        return FALSE;
+        }
+
+    unifi_warning(priv, "%s: stopping ba_session for peer = %02x:%02x:%02x:%02x:%02x:%02x role = %d tID = %d\n", __FUNCTION__,
+                  macAddress.a[0], macAddress.a[1], macAddress.a[2],
+                  macAddress.a[3], macAddress.a[4], macAddress.a[5],
+                  role,
+                  tID);
+
+    /* find out the appropriate ba session (/station /tid /role) for which stop is requested */
+    if (role == CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_RECIPIENT){
+        for (ba_session_idx =0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_RX; ba_session_idx++){
+
+            ba_session_rx = interfacePriv->ba_session_rx[ba_session_idx];
+
+            if(ba_session_rx){
+                if ((!memcmp(ba_session_rx->macAddress.a, macAddress.a, ETH_ALEN)) && (ba_session_rx->tID == tID)){
+                    break;
+                }
+            }
+        }
+
+        if (!ba_session_rx || (ba_session_idx == MAX_SUPPORTED_BA_SESSIONS_RX)) {
+            unifi_error(priv, "%s: bad ba_session for Rx [tID=%d]\n", __FUNCTION__, tID);
+            return FALSE;
+        }
+
+
+        if(ba_session_rx->timeout) {
+            del_timer_sync(&ba_session_rx->timer);
+        }
+        cancel_work_sync(&ba_session_rx->send_ba_err_task);
+        for (i = 0; i < ba_session_rx->wind_size; i++) {
+            if(ba_session_rx->buffer[i].active) {
+                frame_desc_struct *frame_desc = &ba_session_rx->buffer[i];
+                unifi_net_data_free(priv, &frame_desc->bulkdata.d[0]);
+            }
+        }
+        kfree(ba_session_rx->buffer);
+
+        interfacePriv->ba_session_rx[ba_session_idx] = NULL;
+        kfree(ba_session_rx);
+    }else if (role == CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ORIGINATOR){
+        for (ba_session_idx =0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_TX; ba_session_idx++){
+        ba_session_tx = interfacePriv->ba_session_tx[ba_session_idx];
+            if(ba_session_tx){
+                if ((!memcmp(ba_session_tx->macAddress.a, macAddress.a, ETH_ALEN)) && (ba_session_tx->tID == tID)){
+                    break;
+                }
+            }
+        }
+
+        if (!ba_session_tx || (ba_session_idx == MAX_SUPPORTED_BA_SESSIONS_TX)) {
+            unifi_error(priv, "%s: bad ba_session for Tx [tID=%d]\n", __FUNCTION__, tID);
+            return FALSE;
+        }
+        interfacePriv->ba_session_tx[ba_session_idx] = NULL;
+        kfree(ba_session_tx);
+
+    }
+
+    return TRUE;
+}
+
+
+void CsrWifiRouterCtrlBlockAckDisableReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    CsrWifiRouterCtrlBlockAckDisableReq* req = (CsrWifiRouterCtrlBlockAckDisableReq*)msg;
+    CsrBool r;
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+
+    unifi_trace(priv, UDBG6, "%s: in ok\n", __FUNCTION__);
+
+    spin_lock(&priv->ba_lock);
+    r = blockack_session_stop(priv,
+                              req->interfaceTag,
+                              req->role,
+                              req->trafficStreamID,
+                              req->macAddress);
+    spin_unlock(&priv->ba_lock);
+
+    CsrWifiRouterCtrlBlockAckDisableCfmSend(msg->source,
+                                            req->clientData,
+                                            req->interfaceTag,
+                                            r?CSR_RESULT_SUCCESS:CSR_RESULT_FAILURE);
+
+    unifi_trace(priv, UDBG6, "%s: out ok\n", __FUNCTION__);
+}
+
+
+CsrBool blockack_session_start(unifi_priv_t *priv,
+                               CsrUint16 interfaceTag,
+                               CsrUint16 tID,
+                               CsrUint16 timeout,
+                               CsrWifiRouterCtrlBlockAckRole role,
+                               CsrUint16 wind_size,
+                               CsrUint16 start_sn,
+                               CsrWifiMacAddress macAddress
+                              )
+{
+    netInterface_priv_t *interfacePriv;
+    ba_session_rx_struct *ba_session_rx = NULL;
+    ba_session_tx_struct *ba_session_tx = NULL;
+    CsrUint8 ba_session_idx = 0;
+
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "%s: bad interfaceTag = %d\n", __FUNCTION__, interfaceTag);
+        return FALSE;
+    }
+
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if(!interfacePriv) {
+        unifi_error(priv, "%s: bad interfacePriv\n", __FUNCTION__);
+        return FALSE;
+    }
+
+    if(tID > 15)
+    {
+        unifi_error(priv, "%s: bad tID=%d\n", __FUNCTION__, tID);
+        return FALSE;
+    }
+
+    if(wind_size > MAX_BA_WIND_SIZE) {
+        unifi_error(priv, "%s: bad wind_size = %d\n", __FUNCTION__, wind_size);
+        return FALSE;
+    }
+
+    if(role != CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ORIGINATOR &&
+       role != CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_RECIPIENT) {
+        unifi_error(priv, "%s: bad role = %d\n", __FUNCTION__, role);
+        return FALSE;
+    }
+
+    unifi_warning(priv, "%s: ba session with peer= (%02x:%02x:%02x:%02x:%02x:%02x)\n", __FUNCTION__,
+                  macAddress.a[0], macAddress.a[1], macAddress.a[2],
+                  macAddress.a[3], macAddress.a[4], macAddress.a[5]);
+
+    unifi_warning(priv, "%s: ba session for tID=%d timeout=%d role=%d wind_size=%d start_sn=%d\n", __FUNCTION__,
+                  tID,
+                  timeout,
+                  role,
+                  wind_size,
+                  start_sn);
+
+    /* Check if BA session exists for per station, per TID, per role or not.
+    if BA session exists update parameters and if it does not exist
+    create a new BA session */
+    if (role == CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ORIGINATOR){
+        for (ba_session_idx =0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_TX; ba_session_idx++){
+            ba_session_tx = interfacePriv->ba_session_tx[ba_session_idx];
+            if (ba_session_tx) {
+                if ((!memcmp(ba_session_tx->macAddress.a, macAddress.a, ETH_ALEN)) && (ba_session_tx->tID == tID)){
+                    unifi_warning(priv, "%s: ba_session for Tx already exists\n", __FUNCTION__);
+                    return TRUE;
+                }
+            }
+        }
+
+        /* we have to create new ba_session_tx struct */
+         ba_session_tx = NULL;
+
+        /* loop through until an empty BA session slot is there and save the session there */
+        for (ba_session_idx=0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_TX ; ba_session_idx++){
+            if (!(interfacePriv->ba_session_tx[ba_session_idx])){
+                break;
+            }
+        }
+        if (ba_session_idx == MAX_SUPPORTED_BA_SESSIONS_TX){
+            unifi_error(priv, "%s: All ba_session used for Tx, NO free session available\n", __FUNCTION__);
+            return FALSE;
+        }
+
+        /* create and populate the new BA session structure */
+        ba_session_tx = kmalloc(sizeof(ba_session_tx_struct), GFP_KERNEL);
+        if (!ba_session_tx) {
+            unifi_error(priv, "%s: kmalloc failed for ba_session_tx\n", __FUNCTION__);
+            return FALSE;
+        }
+        memset(ba_session_tx, 0, sizeof(ba_session_tx_struct));
+
+        ba_session_tx->interfacePriv = interfacePriv;
+        ba_session_tx->tID = tID;
+        ba_session_tx->macAddress = macAddress;
+
+        interfacePriv->ba_session_tx[ba_session_idx] = ba_session_tx;
+
+    } else if (role == CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_RECIPIENT){
+
+        for (ba_session_idx =0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_RX; ba_session_idx++){
+            ba_session_rx = interfacePriv->ba_session_rx[ba_session_idx];
+            if (ba_session_rx) {
+                if ((!memcmp(ba_session_rx->macAddress.a, macAddress.a, ETH_ALEN)) && (ba_session_rx->tID == tID)){
+                    unifi_warning(priv, "%s: ba_session for Rx[tID = %d] already exists\n", __FUNCTION__, tID);
+
+                    if(ba_session_rx->wind_size == wind_size &&
+                        ba_session_rx->timeout == timeout &&
+                        ba_session_rx->expected_sn == start_sn) {
+                        return TRUE;
+                    }
+
+                    if(ba_session_rx->timeout) {
+                        del_timer_sync(&ba_session_rx->timer);
+                        ba_session_rx->timeout = 0;
+                    }
+
+                    if(ba_session_rx->wind_size != wind_size) {
+                        blockack_session_stop(priv, interfaceTag, role, tID, macAddress);
+                    } else {
+                        if (timeout) {
+                            ba_session_rx->timeout = timeout;
+                            ba_session_rx->timer.function = ba_session_terminate_timer_func;
+                            ba_session_rx->timer.data = (unsigned long)ba_session_rx;
+                            init_timer(&ba_session_rx->timer);
+                            mod_timer(&ba_session_rx->timer, (jiffies + usecs_to_jiffies((ba_session_rx->timeout) * 1024)));
+                        }
+                        return TRUE;
+                    }
+                }
+            }
+        }
+
+        /* we could have a valid BA session pointer here or un-initialized
+        ba session pointer. but in any case we have to create a new session.
+        so re-initialize the ba_session pointer */
+        ba_session_rx = NULL;
+
+        /* loop through until an empty BA session slot is there and save the session there */
+        for (ba_session_idx=0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_RX ; ba_session_idx++){
+            if (!(interfacePriv->ba_session_rx[ba_session_idx])){
+                break;
+            }
+        }
+        if (ba_session_idx == MAX_SUPPORTED_BA_SESSIONS_RX){
+            unifi_error(priv, "%s: All ba_session used for Rx, NO free session available\n", __FUNCTION__);
+            return FALSE;
+        }
+
+
+        ba_session_rx = kmalloc(sizeof(ba_session_rx_struct), GFP_KERNEL);
+        if (!ba_session_rx) {
+            unifi_error(priv, "%s: kmalloc failed for ba_session_rx\n", __FUNCTION__);
+            return FALSE;
+        }
+        memset(ba_session_rx, 0, sizeof(ba_session_rx_struct));
+
+        ba_session_rx->wind_size = wind_size;
+        ba_session_rx->start_sn = ba_session_rx->expected_sn = start_sn;
+        ba_session_rx->trigger_ba_after_ssn = FALSE;
+
+        ba_session_rx->buffer = kmalloc(ba_session_rx->wind_size*sizeof(frame_desc_struct), GFP_KERNEL);
+        if (!ba_session_rx->buffer) {
+            kfree(ba_session_rx);
+            unifi_error(priv, "%s: kmalloc failed for buffer\n", __FUNCTION__);
+            return FALSE;
+        }
+
+        memset(ba_session_rx->buffer, 0, ba_session_rx->wind_size*sizeof(frame_desc_struct));
+
+        INIT_WORK(&ba_session_rx->send_ba_err_task, uf_send_ba_err_wq);
+        if (timeout) {
+            ba_session_rx->timeout = timeout;
+            ba_session_rx->timer.function = ba_session_terminate_timer_func;
+            ba_session_rx->timer.data = (unsigned long)ba_session_rx;
+            init_timer(&ba_session_rx->timer);
+            mod_timer(&ba_session_rx->timer, (jiffies + usecs_to_jiffies((ba_session_rx->timeout) * 1024)));
+        }
+
+        ba_session_rx->interfacePriv = interfacePriv;
+        ba_session_rx->tID = tID;
+        ba_session_rx->macAddress = macAddress;
+
+        interfacePriv->ba_session_rx[ba_session_idx] = ba_session_rx;
+    }
+    return TRUE;
+}
+
+void CsrWifiRouterCtrlBlockAckEnableReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    CsrWifiRouterCtrlBlockAckEnableReq* req = (CsrWifiRouterCtrlBlockAckEnableReq*)msg;
+    CsrBool r;
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+
+    unifi_trace(priv, UDBG6, ">>%s\n", __FUNCTION__);
+    spin_lock(&priv->ba_lock);
+    r = blockack_session_start(priv,
+                               req->interfaceTag,
+                               req->trafficStreamID,
+                               req->timeout,
+                               req->role,
+                               req->bufferSize,
+                               req->ssn,
+                               req->macAddress
+                              );
+    spin_unlock(&priv->ba_lock);
+
+    CsrWifiRouterCtrlBlockAckEnableCfmSend(msg->source,
+                                           req->clientData,
+                                           req->interfaceTag,
+                                           r?CSR_RESULT_SUCCESS:CSR_RESULT_FAILURE);
+    unifi_trace(priv, UDBG6, "<<%s: r=%d\n", __FUNCTION__, r);
+
+}
+
+void CsrWifiRouterCtrlWapiMulticastFilterReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlWapiMulticastFilterReq* req = (CsrWifiRouterCtrlWapiMulticastFilterReq*)msg;
+
+    unifi_trace(priv, UDBG6, ">>%s\n", __FUNCTION__);
+    unifi_trace(priv, UDBG1, "CsrWifiRouterCtrlWapiMulticastFilterReq: req->status = %d\n", req->status);
+
+    /* status 1 - Filter on
+     * status 0 - Filter off */
+    priv->wapi_multicast_filter = req->status;
+
+    unifi_trace(priv, UDBG6, "<<%s\n", __FUNCTION__);
+}
+
+void CsrWifiRouterCtrlWapiUnicastFilterReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlWapiUnicastFilterReq* req = (CsrWifiRouterCtrlWapiUnicastFilterReq*)msg;
+
+    unifi_trace(priv, UDBG6, ">>%s\n", __FUNCTION__);
+    unifi_trace(priv, UDBG1, "CsrWifiRouterCtrlWapiUnicastFilterReq: req->status= %d\n", req->status);
+
+    if ((priv->wapi_unicast_filter == 1) && (req->status == 0)) {
+        /* When we have successfully re-associated and obtained a new unicast key with keyid = 0 */
+		priv->wapi_unicast_queued_pkt_filter = 1;
+	}
+
+    /* status 1 - Filter ON
+     * status 0 - Filter OFF */
+    priv->wapi_unicast_filter = req->status;
+
+    unifi_trace(priv, UDBG6, "<<%s\n", __FUNCTION__);
+}
+
+
+void CsrWifiRouterCtrlWapiMulticastReqHandler(void* drvpriv, CsrWifiFsmEvent* msg)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)drvpriv;
+    CsrWifiRouterCtrlWapiMulticastReq* req =  (CsrWifiRouterCtrlWapiMulticastReq*)msg;
+
+    int client_id, receiver_id;
+    bulk_data_param_t bulkdata;
+    CsrResult res;
+    ul_client_t *client;
+
+    CSR_SIGNAL signal;
+    CSR_MA_PACKET_INDICATION *pkt_ind;
+
+    unifi_trace(priv, UDBG6, ">>%s\n", __FUNCTION__);
+    unifi_trace(priv, UDBG4, "CsrWifiRouterCtrlWapiMulticastReqHandler: \n");
+
+    if (priv == NULL) {
+        unifi_error(priv, "CsrWifiRouterCtrlWapiMulticastReqHandler : invalid priv\n",__FUNCTION__);
+        return;
+    }
+
+    if (priv->smepriv == NULL) {
+         unifi_error(priv, "CsrWifiRouterCtrlWapiMulticastReqHandler : invalid sme priv\n",__FUNCTION__);
+         return;
+    }
+
+    if (req->dataLength == 0 || req->data == NULL) {
+         unifi_error(priv, "CsrWifiRouterCtrlWapiMulticastReqHandler: invalid request\n",__FUNCTION__);
+         return;
+    }
+
+    res = unifi_net_data_malloc(priv, &bulkdata.d[0], req->dataLength);
+    if (res != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "CsrWifiRouterCtrlWapiMulticastReqHandler: Could not allocate net data\n",__FUNCTION__);
+        return;
+    }
+
+    /* This function is expected to be called only when the MIC has been verified by SME to be correct
+     * So reset the reception status to rx_success */
+    res = read_unpack_signal(req->signal, &signal);
+    if (res) {
+	    unifi_error(priv,"CsrWifiRouterCtrlWapiMulticastReqHandler: Received unknown or corrupted signal.\n");
+	    return;
+    }
+    pkt_ind = (CSR_MA_PACKET_INDICATION*) (&((&signal)->u).MaPacketIndication);
+    if (pkt_ind->ReceptionStatus != CSR_MICHAEL_MIC_ERROR) {
+	     unifi_error(priv,"CsrWifiRouterCtrlWapiMulticastReqHandler: Unknown signal with reception status = %d\n",pkt_ind->ReceptionStatus);
+	     return;
+    }
+    else {
+	     unifi_trace(priv, UDBG4,"CsrWifiRouterCtrlWapiMulticastReqHandler: MIC verified , RX_SUCCESS \n",__FUNCTION__);
+	     pkt_ind->ReceptionStatus = CSR_RX_SUCCESS;
+	     write_pack(&signal, req->signal, &(req->signalLength));
+    }
+
+    memcpy((void*)bulkdata.d[0].os_data_ptr, req->data, req->dataLength);
+
+    receiver_id = CSR_GET_UINT16_FROM_LITTLE_ENDIAN((req->signal) + sizeof(CsrInt16)) & 0xFFF0;
+    client_id = (receiver_id & 0x0F00) >> UDI_SENDER_ID_SHIFT;
+
+    client = &priv->ul_clients[client_id];
+
+    if (client && client->event_hook) {
+         unifi_trace(priv, UDBG3,
+                     "CsrWifiRouterCtrlWapiMulticastReqHandler: "
+                     "Sending signal to client %d, (s:0x%X, r:0x%X) - Signal 0x%X \n",
+                     client->client_id, client->sender_id, receiver_id,
+                     CSR_GET_UINT16_FROM_LITTLE_ENDIAN(req->signal));
+
+         client->event_hook(client, req->signal, req->signalLength, &bulkdata, UDI_TO_HOST);
+    }
+    else {
+         unifi_trace(priv, UDBG4, "No client to give the packet to\n");
+         unifi_net_data_free(priv, &bulkdata.d[0]);
+    }
+
+    unifi_trace(priv, UDBG6, "<<%s\n", __FUNCTION__);
+}
--- /dev/null
+++ b/drivers/staging/csr/sme_userspace.c
@@ -0,0 +1,316 @@
+/*
+ *****************************************************************************
+ *
+ * FILE : sme_userspace.c
+ *
+ * PURPOSE : Support functions for userspace SME helper application.
+ *
+ *
+ * Copyright (C) 2008-2011 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ *****************************************************************************
+ */
+
+#include "unifi_priv.h"
+
+/*
+ * Fix Me..... These need to be the correct values...
+ * Dynamic from the user space.
+ */
+CsrSchedQid CSR_WIFI_ROUTER_IFACEQUEUE   = 0xFFFF;
+CsrSchedQid CSR_WIFI_SME_IFACEQUEUE      = 0xFFFF;
+#ifdef CSR_SUPPORT_WEXT_AP
+CsrSchedQid CSR_WIFI_NME_IFACEQUEUE      = 0xFFFF;
+#endif
+int
+uf_sme_init(unifi_priv_t *priv)
+{
+    int i, j;
+
+    CsrWifiRouterTransportInit(priv);
+
+    priv->smepriv = priv;
+
+    init_waitqueue_head(&priv->sme_request_wq);
+
+    priv->filter_tclas_ies = NULL;
+    memset(&priv->packet_filters, 0, sizeof(uf_cfg_bcast_packet_filter_t));
+
+#ifdef CSR_SUPPORT_WEXT
+    priv->ignore_bssid_join = FALSE;
+    priv->mib_data.length = 0;
+
+    uf_sme_wext_set_defaults(priv);
+#endif /* CSR_SUPPORT_WEXT*/
+
+    priv->sta_ip_address = 0xFFFFFFFF;
+
+    priv->wifi_on_state = wifi_on_unspecified;
+
+    sema_init(&priv->sme_sem, 1);
+    memset(&priv->sme_reply, 0, sizeof(sme_reply_t));
+
+    priv->ta_ind_work.in_use = 0;
+    priv->ta_sample_ind_work.in_use = 0;
+
+    priv->CSR_WIFI_SME_IFACEQUEUE = 0xFFFF;
+
+    for (i = 0; i < MAX_MA_UNIDATA_IND_FILTERS; i++) {
+        priv->sme_unidata_ind_filters[i].in_use = 0;
+    }
+
+    /* Create a work queue item for Traffic Analysis indications to SME */
+    INIT_WORK(&priv->ta_ind_work.task, uf_ta_ind_wq);
+    INIT_WORK(&priv->ta_sample_ind_work.task, uf_ta_sample_ind_wq);
+#ifdef CSR_SUPPORT_WEXT
+    INIT_WORK(&priv->sme_config_task, uf_sme_config_wq);
+#endif
+
+    for (i = 0; i < CSR_WIFI_NUM_INTERFACES; i++) {
+        netInterface_priv_t *interfacePriv = priv->interfacePriv[i];
+        interfacePriv->m4_sent = FALSE;
+        interfacePriv->m4_bulk_data.net_buf_length = 0;
+        interfacePriv->m4_bulk_data.data_length = 0;
+        interfacePriv->m4_bulk_data.os_data_ptr = interfacePriv->m4_bulk_data.os_net_buf_ptr = NULL;
+
+        memset(&interfacePriv->controlled_data_port, 0, sizeof(unifi_port_config_t));
+        interfacePriv->controlled_data_port.entries_in_use = 1;
+        interfacePriv->controlled_data_port.port_cfg[0].in_use = TRUE;
+        interfacePriv->controlled_data_port.port_cfg[0].port_action = CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;
+        interfacePriv->controlled_data_port.overide_action = UF_DATA_PORT_OVERIDE;
+
+        memset(&interfacePriv->uncontrolled_data_port, 0, sizeof(unifi_port_config_t));
+        interfacePriv->uncontrolled_data_port.entries_in_use = 1;
+        interfacePriv->uncontrolled_data_port.port_cfg[0].in_use = TRUE;
+        interfacePriv->uncontrolled_data_port.port_cfg[0].port_action = CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;
+        interfacePriv->uncontrolled_data_port.overide_action = UF_DATA_PORT_OVERIDE;
+
+        /* Mark the remainder of the port config table as unallocated */
+        for(j = 1; j < UNIFI_MAX_CONNECTIONS; j++) {
+            interfacePriv->controlled_data_port.port_cfg[j].in_use = FALSE;
+            interfacePriv->controlled_data_port.port_cfg[j].port_action = CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;
+
+            interfacePriv->uncontrolled_data_port.port_cfg[j].in_use = FALSE;
+            interfacePriv->uncontrolled_data_port.port_cfg[j].port_action = CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;
+        }
+
+        /* intializing the lists */
+        INIT_LIST_HEAD(&interfacePriv->genericMgtFrames);
+        INIT_LIST_HEAD(&interfacePriv->genericMulticastOrBroadCastMgtFrames);
+        INIT_LIST_HEAD(&interfacePriv->genericMulticastOrBroadCastFrames);
+        INIT_LIST_HEAD(&interfacePriv->directedMaPktReq);
+
+        for(j = 0; j < UNIFI_MAX_CONNECTIONS; j++) {
+            interfacePriv->staInfo[j] = NULL;
+        }
+
+        interfacePriv->num_stations_joined = 0;
+        interfacePriv->sta_activity_check_enabled = FALSE;
+    }
+
+
+    return 0;
+} /* uf_sme_init() */
+
+
+void
+uf_sme_deinit(unifi_priv_t *priv)
+{
+    int i,j;
+    CsrUint8 ba_session_idx;
+    ba_session_rx_struct *ba_session_rx = NULL;
+    ba_session_tx_struct *ba_session_tx = NULL;
+    CsrWifiRouterCtrlStaInfo_t *staInfo = NULL;
+    netInterface_priv_t *interfacePriv = NULL;
+
+    /* Free any TCLASs previously allocated */
+    if (priv->packet_filters.tclas_ies_length) {
+        priv->packet_filters.tclas_ies_length = 0;
+        CsrPmemFree(priv->filter_tclas_ies);
+        priv->filter_tclas_ies = NULL;
+    }
+
+    for (i = 0; i < MAX_MA_UNIDATA_IND_FILTERS; i++) {
+        priv->sme_unidata_ind_filters[i].in_use = 0;
+    }
+
+    /* Remove all the Peer database, before going down */
+    for (i = 0; i < CSR_WIFI_NUM_INTERFACES; i++) {
+        spin_lock(&priv->ba_lock);
+        for(ba_session_idx=0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_RX; ba_session_idx++){
+            ba_session_rx = priv->interfacePriv[i]->ba_session_rx[ba_session_idx];
+            if(ba_session_rx) {
+                blockack_session_stop(priv,
+                                    i,
+                                    CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_RECIPIENT,
+                                    ba_session_rx->tID,
+                                    ba_session_rx->macAddress);
+            }
+        }
+        for(ba_session_idx=0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_TX; ba_session_idx++){
+            ba_session_tx = priv->interfacePriv[i]->ba_session_tx[ba_session_idx];
+            if(ba_session_tx) {
+                blockack_session_stop(priv,
+                                    i,
+                                    CSR_WIFI_ROUTER_CTRL_BLOCK_ACK_ORIGINATOR,
+                                    ba_session_tx->tID,
+                                    ba_session_tx->macAddress);
+            }
+        }
+
+        spin_unlock(&priv->ba_lock);
+        interfacePriv = priv->interfacePriv[i];
+        if(interfacePriv){
+            for(j = 0; j < UNIFI_MAX_CONNECTIONS; j++) {
+                if ((staInfo=interfacePriv->staInfo[j]) != NULL) {
+                    /* Clear the STA activity parameters before freeing station Record */
+                    unifi_trace(priv, UDBG1, "uf_sme_deinit: Canceling work queue for STA with AID: %d\n", staInfo->aid);
+                    cancel_work_sync(&staInfo->send_disconnected_ind_task);
+                    staInfo->nullDataHostTag = INVALID_HOST_TAG;
+                }
+            }
+            if (interfacePriv->sta_activity_check_enabled){
+                interfacePriv->sta_activity_check_enabled = FALSE;
+                del_timer_sync(&interfacePriv->sta_activity_check_timer);
+            }
+        }
+        CsrWifiRouterCtrlInterfaceReset(priv, i);
+        priv->interfacePriv[i]->interfaceMode = CSR_WIFI_ROUTER_CTRL_MODE_NONE;
+    }
+
+
+} /* uf_sme_deinit() */
+
+
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_ta_indicate_protocol
+ *
+ *      Report that a packet of a particular type has been seen
+ *
+ *  Arguments:
+ *      drv_priv        The device context pointer passed to ta_init.
+ *      protocol        The protocol type enum value.
+ *      direction       Whether the packet was a tx or rx.
+ *      src_addr        The source MAC address from the data packet.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *      We defer the actual sending to a background workqueue,
+ *      see uf_ta_ind_wq().
+ * ---------------------------------------------------------------------------
+ */
+void
+unifi_ta_indicate_protocol(void *ospriv,
+                           CsrWifiRouterCtrlTrafficPacketType packet_type,
+                           CsrWifiRouterCtrlProtocolDirection direction,
+                           const CsrWifiMacAddress *src_addr)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+
+    if (priv->ta_ind_work.in_use) {
+        unifi_warning(priv,
+                "unifi_ta_indicate_protocol: workqueue item still in use, not sending\n");
+        return;
+    }
+
+    if (CSR_WIFI_ROUTER_CTRL_PROTOCOL_DIRECTION_RX == direction)
+    {
+        CsrUint16 interfaceTag = 0;
+        CsrWifiRouterCtrlTrafficProtocolIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,
+                interfaceTag,
+                packet_type,
+                direction,
+                *src_addr);
+    }
+    else
+    {
+        priv->ta_ind_work.packet_type = packet_type;
+        priv->ta_ind_work.direction = direction;
+        priv->ta_ind_work.src_addr = *src_addr;
+
+        queue_work(priv->unifi_workqueue, &priv->ta_ind_work.task);
+    }
+
+} /* unifi_ta_indicate_protocol() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * unifi_ta_indicate_sampling
+ *
+ *      Send the TA sampling information to the SME.
+ *
+ *  Arguments:
+ *      drv_priv        The device context pointer passed to ta_init.
+ *      stats   The TA sampling data to send.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+unifi_ta_indicate_sampling(void *ospriv, CsrWifiRouterCtrlTrafficStats *stats)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+
+    if (!priv) {
+        return;
+    }
+
+    if (priv->ta_sample_ind_work.in_use) {
+        unifi_warning(priv,
+                     "unifi_ta_indicate_sampling: workqueue item still in use, not sending\n");
+        return;
+    }
+
+    priv->ta_sample_ind_work.stats = *stats;
+
+    queue_work(priv->unifi_workqueue, &priv->ta_sample_ind_work.task);
+
+} /* unifi_ta_indicate_sampling() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * unifi_ta_indicate_l4stats
+ *
+ *      Send the TA TCP/UDP throughput information to the driver.
+ *
+ *  Arguments:
+ *    drv_priv        The device context pointer passed to ta_init.
+ *    rxTcpThroughput TCP RX throughput in KiloBytes
+ *    txTcpThroughput TCP TX throughput in KiloBytes
+ *    rxUdpThroughput UDP RX throughput in KiloBytes
+ *    txUdpThroughput UDP TX throughput in KiloBytes
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+unifi_ta_indicate_l4stats(void *ospriv,
+                          CsrUint32 rxTcpThroughput,
+                          CsrUint32 txTcpThroughput,
+                          CsrUint32 rxUdpThroughput,
+                          CsrUint32 txUdpThroughput)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+
+    if (!priv) {
+        return;
+    }
+    /* Save the info. The actual action will be taken in unifi_ta_indicate_sampling() */
+    priv->rxTcpThroughput = rxTcpThroughput;
+    priv->txTcpThroughput = txTcpThroughput;
+    priv->rxUdpThroughput = rxUdpThroughput;
+    priv->txUdpThroughput = txUdpThroughput;
+} /* unifi_ta_indicate_l4stats() */
--- /dev/null
+++ b/drivers/staging/csr/sme_userspace.h
@@ -0,0 +1,38 @@
+/*
+ * ***************************************************************************
+ *  FILE:     sme_userspace.h
+ *
+ *  PURPOSE:    SME related definitions.
+ *
+ *  Copyright (C) 2007-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ***************************************************************************
+ */
+#ifndef __LINUX_SME_USERSPACE_H__
+#define __LINUX_SME_USERSPACE_H__ 1
+
+#include <linux/kernel.h>
+
+int uf_sme_init(unifi_priv_t *priv);
+void uf_sme_deinit(unifi_priv_t *priv);
+int uf_sme_queue_message(unifi_priv_t *priv, u8 *buffer, int length);
+
+
+#include "csr_wifi_router_lib.h"
+#include "csr_wifi_router_sef.h"
+#include "csr_wifi_router_ctrl_lib.h"
+#include "csr_wifi_router_ctrl_sef.h"
+#include "csr_wifi_sme_task.h"
+#ifdef CSR_SUPPORT_WEXT_AP
+#include "csr_wifi_nme_ap_lib.h"
+#endif
+#include "csr_wifi_sme_lib.h"
+
+void CsrWifiRouterTransportInit(unifi_priv_t *priv);
+void CsrWifiRouterTransportRecv(unifi_priv_t *priv, CsrUint8* buffer, CsrSize bufferLength);
+void CsrWifiRouterTransportDeInit(unifi_priv_t *priv);
+
+#endif /* __LINUX_SME_USERSPACE_H__ */
--- /dev/null
+++ b/drivers/staging/csr/sme_wext.c
@@ -0,0 +1,3394 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     sme_wext.c
+ *
+ * PURPOSE:
+ *      Handlers for ioctls from iwconfig.
+ *      These provide the control plane operations.
+ *
+ * Copyright (C) 2007-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include <linux/types.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <asm/uaccess.h>
+#include <linux/ctype.h>
+#include "unifi_priv.h"
+#include <linux/rtnetlink.h>
+
+#define CHECK_INITED(_priv)                             \
+    do {                                                    \
+        if (_priv->init_progress != UNIFI_INIT_COMPLETED) { \
+            unifi_trace(_priv, UDBG2, "%s unifi not ready, failing wext call\n", __FUNCTION__); \
+            return -ENODEV;                                 \
+        }                                                   \
+    } while (0)
+
+/* Workaround for the wpa_supplicant hanging issue */
+#define CSR_WIFI_WEXT_HANG_WORKAROUND
+
+#ifdef CSR_WIFI_WEXT_HANG_WORKAROUND
+# define UF_RTNL_LOCK()    rtnl_lock()
+# define UF_RTNL_UNLOCK()  rtnl_unlock()
+#else
+# define UF_RTNL_LOCK()
+# define UF_RTNL_UNLOCK()
+#endif
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *      Helper functions
+ * ---------------------------------------------------------------------------
+ */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  wext_freq_to_channel
+ *  channel_to_mhz
+ *
+ *      These functions convert between channel number and frequency.
+ *
+ *  Arguments:
+ *      ch      Channel number, as defined in 802.11 specs
+ *      m, e    Mantissa and exponent as provided by wireless extension.
+ *
+ *  Returns:
+ *      channel or frequency (in MHz) value
+ * ---------------------------------------------------------------------------
+ */
+static int
+wext_freq_to_channel(int m, int e)
+{
+    int mhz;
+
+    mhz = m;
+    while (e < 6) {
+        mhz /= 10;
+        e++;
+    }
+    while (e > 6) {
+        mhz *= 10;
+        e--;
+    }
+
+    if (mhz >= 5000) {
+        return ((mhz - 5000) / 5);
+    }
+
+    if (mhz == 2482) {
+        return 14;
+    }
+
+    if (mhz >= 2407) {
+        return ((mhz - 2407) / 5);
+    }
+
+    return 0;
+} /* wext_freq_to_channel() */
+
+static int
+channel_to_mhz(int ch, int dot11a)
+{
+
+    if (ch == 0) return 0;
+    if (ch > 200) return 0;
+
+    /* 5G */
+    if (dot11a) {
+        return (5000 + (5 * ch));
+    }
+
+    /* 2.4G */
+    if (ch == 14) {
+        return 2484;
+    }
+
+    if ((ch < 14) && (ch > 0)) {
+        return (2407 + (5 * ch));
+    }
+
+    return 0;
+}
+#ifdef CSR_SUPPORT_WEXT_AP
+void uf_sme_wext_ap_set_defaults(unifi_priv_t *priv)
+{
+    memcpy(priv->ap_config.ssid.ssid,"defaultssid",sizeof("defaultssid"));
+
+    priv->ap_config.ssid.length = 8;
+    priv->ap_config.channel = 6;
+    priv->ap_config.if_index = 1;
+    priv->ap_config.credentials.authType = 0;
+    priv->ap_config.max_connections=8;
+
+    priv->group_sec_config.apGroupkeyTimeout = 0;
+    priv->group_sec_config.apStrictGtkRekey = 0;
+    priv->group_sec_config.apGmkTimeout = 0;
+    priv->group_sec_config.apResponseTimeout = 100; /* Default*/
+    priv->group_sec_config.apRetransLimit = 3; /* Default*/
+    /* Set default params even if they may not be used*/
+    /* Until Here*/
+
+    priv->ap_mac_config.preamble = CSR_WIFI_SME_USE_LONG_PREAMBLE;
+    priv->ap_mac_config.shortSlotTimeEnabled = FALSE;
+    priv->ap_mac_config.ctsProtectionType=CSR_WIFI_SME_CTS_PROTECTION_AUTOMATIC;
+
+    priv->ap_mac_config.wmmEnabled = TRUE;
+    priv->ap_mac_config.wmmApParams[0].cwMin=4;
+    priv->ap_mac_config.wmmApParams[0].cwMax=10;
+    priv->ap_mac_config.wmmApParams[0].aifs=3;
+    priv->ap_mac_config.wmmApParams[0].txopLimit=0;
+    priv->ap_mac_config.wmmApParams[0].admissionControlMandatory=FALSE;
+    priv->ap_mac_config.wmmApParams[1].cwMin=4;
+    priv->ap_mac_config.wmmApParams[1].cwMax=10;
+    priv->ap_mac_config.wmmApParams[1].aifs=7;
+    priv->ap_mac_config.wmmApParams[1].txopLimit=0;
+    priv->ap_mac_config.wmmApParams[1].admissionControlMandatory=FALSE;
+    priv->ap_mac_config.wmmApParams[2].cwMin=3;
+    priv->ap_mac_config.wmmApParams[2].cwMax=4;
+    priv->ap_mac_config.wmmApParams[2].aifs=1;
+    priv->ap_mac_config.wmmApParams[2].txopLimit=94;
+    priv->ap_mac_config.wmmApParams[2].admissionControlMandatory=FALSE;
+    priv->ap_mac_config.wmmApParams[3].cwMin=2;
+    priv->ap_mac_config.wmmApParams[3].cwMax=3;
+    priv->ap_mac_config.wmmApParams[3].aifs=1;
+    priv->ap_mac_config.wmmApParams[3].txopLimit=47;
+    priv->ap_mac_config.wmmApParams[3].admissionControlMandatory=FALSE;
+
+    priv->ap_mac_config.wmmApBcParams[0].cwMin=4;
+    priv->ap_mac_config.wmmApBcParams[0].cwMax=10;
+    priv->ap_mac_config.wmmApBcParams[0].aifs=3;
+    priv->ap_mac_config.wmmApBcParams[0].txopLimit=0;
+    priv->ap_mac_config.wmmApBcParams[0].admissionControlMandatory=FALSE;
+    priv->ap_mac_config.wmmApBcParams[1].cwMin=4;
+    priv->ap_mac_config.wmmApBcParams[1].cwMax=10;
+    priv->ap_mac_config.wmmApBcParams[1].aifs=7;
+    priv->ap_mac_config.wmmApBcParams[1].txopLimit=0;
+    priv->ap_mac_config.wmmApBcParams[1].admissionControlMandatory=FALSE;
+    priv->ap_mac_config.wmmApBcParams[2].cwMin=3;
+    priv->ap_mac_config.wmmApBcParams[2].cwMax=4;
+    priv->ap_mac_config.wmmApBcParams[2].aifs=2;
+    priv->ap_mac_config.wmmApBcParams[2].txopLimit=94;
+    priv->ap_mac_config.wmmApBcParams[2].admissionControlMandatory=FALSE;
+    priv->ap_mac_config.wmmApBcParams[3].cwMin=2;
+    priv->ap_mac_config.wmmApBcParams[3].cwMax=3;
+    priv->ap_mac_config.wmmApBcParams[3].aifs=2;
+    priv->ap_mac_config.wmmApBcParams[3].txopLimit=47;
+    priv->ap_mac_config.wmmApBcParams[3].admissionControlMandatory=FALSE;
+
+    priv->ap_mac_config.accessType=CSR_WIFI_AP_ACCESS_TYPE_NONE;
+    priv->ap_mac_config.macAddressListCount=0;
+    priv->ap_mac_config.macAddressList=NULL;
+
+    priv->ap_mac_config.apHtParams.rxStbc=1;
+    priv->ap_mac_config.apHtParams.rifsModeAllowed=TRUE;
+    priv->ap_mac_config.apHtParams.greenfieldSupported=FALSE;
+    priv->ap_mac_config.apHtParams.shortGi20MHz=TRUE;
+    priv->ap_mac_config.apHtParams.htProtection=0;
+    priv->ap_mac_config.apHtParams.dualCtsProtection=FALSE;
+
+    priv->ap_mac_config.phySupportedBitmap =
+            (CSR_WIFI_SME_AP_PHY_SUPPORT_B|CSR_WIFI_SME_AP_PHY_SUPPORT_G|CSR_WIFI_SME_AP_PHY_SUPPORT_N);
+    priv->ap_mac_config.beaconInterval= 100;
+    priv->ap_mac_config.dtimPeriod=3;
+    priv->ap_mac_config.maxListenInterval=0x00ff;/* Set it to a large value
+                                                    to enable different types of
+                                                    devices to join us */
+    priv->ap_mac_config.supportedRatesCount =
+           uf_configure_supported_rates(priv->ap_mac_config.supportedRates,priv->ap_mac_config.phySupportedBitmap);
+}
+#endif
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_sme_wext_set_defaults
+ *
+ *      Set up power-on defaults for driver config.
+ *
+ *      Note: The SME Management API *cannot* be used in this function.
+ *
+ *  Arguments:
+ *      priv            Pointer to device private context struct
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+uf_sme_wext_set_defaults(unifi_priv_t *priv)
+{
+    memset(&priv->connection_config, 0, sizeof(CsrWifiSmeConnectionConfig));
+
+    priv->connection_config.bssType = CSR_WIFI_SME_BSS_TYPE_INFRASTRUCTURE;
+    priv->connection_config.authModeMask = CSR_WIFI_SME_AUTH_MODE_80211_OPEN;
+    priv->connection_config.encryptionModeMask = CSR_WIFI_SME_ENCRYPTION_CIPHER_NONE;
+    priv->connection_config.privacyMode = CSR_WIFI_SME_80211_PRIVACY_MODE_DISABLED;
+    priv->connection_config.wmmQosInfo = 0xFF;
+    priv->connection_config.ifIndex = CSR_WIFI_SME_RADIO_IF_BOTH;
+    priv->connection_config.adhocJoinOnly = FALSE;
+    priv->connection_config.adhocChannel = 6;
+
+    priv->wep_tx_key_index = 0;
+
+    priv->wext_wireless_stats.qual.qual = 0;
+    priv->wext_wireless_stats.qual.level = 0;
+    priv->wext_wireless_stats.qual.noise = 0;
+    priv->wext_wireless_stats.qual.updated = 0x70;
+#ifdef CSR_SUPPORT_WEXT_AP
+    /* Initialize the default configuration for AP */
+    uf_sme_wext_ap_set_defaults(priv);
+#endif
+
+
+} /* uf_sme_wext_set_defaults() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *      WEXT methods
+ * ---------------------------------------------------------------------------
+ */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_giwname   - handler for SIOCGIWNAME
+ *  unifi_siwfreq   - handler for SIOCSIWFREQ
+ *  unifi_giwfreq   - handler for SIOCGIWFREQ
+ *  unifi_siwmode   - handler for SIOCSIWMODE
+ *  unifi_giwmode   - handler for SIOCGIWMODE
+ *  unifi_giwrange  - handler for SIOCGIWRANGE
+ *  unifi_siwap     - handler for SIOCSIWAP
+ *  unifi_giwap     - handler for SIOCGIWAP
+ *  unifi_siwscan   - handler for SIOCSIWSCAN
+ *  unifi_giwscan   - handler for SIOCGIWSCAN
+ *  unifi_siwessid  - handler for SIOCSIWESSID
+ *  unifi_giwessid  - handler for SIOCGIWESSID
+ *  unifi_siwencode - handler for SIOCSIWENCODE
+ *  unifi_giwencode - handler for SIOCGIWENCODE
+ *
+ *      Handler functions for IW extensions.
+ *      These are registered via the unifi_iw_handler_def struct below
+ *      and called by the generic IW driver support code.
+ *      See include/net/iw_handler.h.
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static int
+iwprivsdefs(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    int r;
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    CsrWifiSmeMibConfig mibConfig;
+    CsrWifiSmePowerConfig powerConfig;
+
+    unifi_trace(priv, UDBG1, "iwprivs80211defaults: reload defaults\n");
+
+    uf_sme_wext_set_defaults(priv);
+
+    /* Get, modify and set the MIB data */
+    r = sme_mgt_mib_config_get(priv, &mibConfig);
+    if (r) {
+        unifi_error(priv, "iwprivs80211defaults: Get CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+    mibConfig.dot11RtsThreshold = 2347;
+    mibConfig.dot11FragmentationThreshold = 2346;
+    r = sme_mgt_mib_config_set(priv, &mibConfig);
+    if (r) {
+        unifi_error(priv, "iwprivs80211defaults: Set CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+
+    powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_LOW;
+    powerConfig.listenIntervalTu = 100;
+    powerConfig.rxDtims = 1;
+
+    r = sme_mgt_power_config_set(priv, &powerConfig);
+    if (r) {
+        unifi_error(priv, "iwprivs80211defaults: Set unifi_PowerConfigValue failed.\n");
+        return r;
+    }
+
+    return 0;
+} /* iwprivsdefs() */
+
+static int
+iwprivs80211ps(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    int r = 0;
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+
+    int ps_mode = (int)(*extra);
+    CsrWifiSmePowerConfig powerConfig;
+
+    unifi_trace(priv, UDBG1, "iwprivs80211ps: power save mode = %d\n", ps_mode);
+
+    r = sme_mgt_power_config_get(priv, &powerConfig);
+    if (r) {
+        unifi_error(priv, "iwprivs80211ps: Get unifi_PowerConfigValue failed.\n");
+        return r;
+    }
+
+    switch (ps_mode) {
+        case CSR_PMM_ACTIVE_MODE:
+            powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_LOW;
+            break;
+        case CSR_PMM_POWER_SAVE:
+            powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_HIGH;
+            break;
+        case CSR_PMM_FAST_POWER_SAVE:
+            powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_MED;
+            break;
+        default:
+            powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_AUTO;
+            break;
+    }
+
+    r = sme_mgt_power_config_set(priv, &powerConfig);
+    if (r) {
+        unifi_error(priv, "iwprivs80211ps: Set unifi_PowerConfigValue failed.\n");
+    }
+
+    return r;
+}
+
+static int
+iwprivg80211ps(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+
+    CsrWifiSmePowerConfig powerConfig;
+    int r;
+
+    r = sme_mgt_power_config_get(priv, &powerConfig);
+    if (r) {
+        unifi_error(priv, "iwprivg80211ps: Get 802.11 power mode failed.\n");
+        return r;
+    }
+
+    switch (powerConfig.powerSaveLevel) {
+        case CSR_WIFI_SME_POWER_SAVE_LEVEL_LOW:
+            snprintf(extra, IWPRIV_POWER_SAVE_MAX_STRING,
+                     "Power save mode: %d (Active)",
+                     powerConfig.powerSaveLevel);
+            break;
+        case CSR_WIFI_SME_POWER_SAVE_LEVEL_MED:
+            snprintf(extra, IWPRIV_POWER_SAVE_MAX_STRING,
+                     "Power save mode: %d (Fast)",
+                     powerConfig.powerSaveLevel);
+            break;
+        case CSR_WIFI_SME_POWER_SAVE_LEVEL_HIGH:
+            snprintf(extra, IWPRIV_POWER_SAVE_MAX_STRING,
+                     "Power save mode: %d (Full)",
+                     powerConfig.powerSaveLevel);
+            break;
+        case CSR_WIFI_SME_POWER_SAVE_LEVEL_AUTO:
+            snprintf(extra, IWPRIV_POWER_SAVE_MAX_STRING,
+                     "Power save mode: %d (Auto)",
+                     powerConfig.powerSaveLevel);
+            break;
+        default:
+            snprintf(extra, IWPRIV_POWER_SAVE_MAX_STRING,
+                     "Power save mode: %d (Unknown)",
+                     powerConfig.powerSaveLevel);
+            break;
+    }
+
+    wrqu->data.length = strlen(extra) + 1;
+
+    return 0;
+}
+
+static int
+iwprivssmedebug(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    /* No longer supported on the API */
+#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE)
+    unifi_debug_buf_dump();
+#endif
+
+    return 0;
+}
+
+#ifdef CSR_SUPPORT_WEXT_AP
+#define PARAM_TYPE_INT 0
+#define PARAM_TYPE_STRING 1
+#define CSR_WIFI_MAX_SSID_LEN 32
+#define CSR_WIFI_MAX_SEC_LEN 16
+#define CSR_WIFI_MAX_KEY_LEN 65
+
+static int hex_look_up(char x)
+{
+    if(x>='0' && x<='9')
+        return (x-48);
+    if(x>= 'a' && x <= 'f')
+        return (x-87);
+    return -1;
+}
+
+static int power (int a, int b)
+{
+    int i;
+    int num =1;
+    for(i=0;i<b;i++)
+       num *=a;
+    return num;
+}
+
+static int decode_parameter_from_string(unifi_priv_t* priv, char **str_ptr,
+                                        const char *token, int param_type,
+                                        void  *dst, int param_max_len)
+{
+    CsrUint8 int_str[7] = "0";
+    CsrUint32 param_str_len;
+    CsrUint8  *param_str_begin,*param_str_end;
+    CsrUint8  *orig_str = *str_ptr;
+
+    if (!strncmp(*str_ptr, token, strlen(token))) {
+        strsep(str_ptr, "=,");
+        param_str_begin = *str_ptr;
+        strsep(str_ptr, "=,");
+        if (*str_ptr == NULL) {
+            param_str_len = strlen(param_str_begin);
+        } else {
+            param_str_end = *str_ptr-1;
+            param_str_len = param_str_end - param_str_begin;
+        }
+        unifi_trace(priv,UDBG2,"'token:%s', len:%d, ", token, param_str_len);
+        if (param_str_len > param_max_len) {
+            unifi_notice(priv,"extracted param len:%d is > MAX:%d\n",param_str_len, param_max_len);
+            param_str_len = param_max_len;
+        }
+        switch (param_type) {
+            case PARAM_TYPE_INT:
+            {
+                CsrUint32 *pdst_int = dst,num =0;
+                int i,j=0;
+                if (param_str_len > sizeof(int_str)) {
+                    param_str_len = sizeof(int_str);
+                }
+                memcpy(int_str, param_str_begin, param_str_len);
+                for(i = param_str_len; i>0;i--) {
+                    if(int_str[i-1] >= '0' && int_str[i-1] <='9') {
+                        num += ((int_str[i-1]-'0')*power(10,j));
+                        j++;
+                    } else {
+                        unifi_error(priv,"decode_parameter_from_string:not a number %c\n",(int_str[i-1]));
+                        return -1;
+                    }
+                }
+                *pdst_int = num;
+                unifi_trace(priv,UDBG2,"decode_parameter_from_string:decoded int = %d\n",*pdst_int);
+            }
+            break;
+            default:
+                memcpy(dst, param_str_begin, param_str_len);
+                *((char *)dst + param_str_len) = 0;
+                unifi_trace(priv,UDBG2,"decode_parameter_from_string:decoded string = %s\n",(char *)dst);
+            break;
+        }
+    } else {
+        unifi_error(priv,"decode_parameter_from_string: Token:%s not found in %s \n",token,orig_str);
+        return -1;
+    }
+    return 0;
+}
+static int store_ap_advanced_config_from_string(unifi_priv_t *priv, char *param_str)
+{
+    char * str_ptr=param_str;
+    int ret = 0,tmp_var;
+    char phy_mode[6];
+    CsrWifiSmeApMacConfig * ap_mac_config = &priv->ap_mac_config;
+
+    /* Check for BI */
+    ret = decode_parameter_from_string(priv, &str_ptr, "BI=",
+                                       PARAM_TYPE_INT, &tmp_var, 5);
+    if(ret) {
+        unifi_error(priv,"store_ap_advanced_config_from_string: BI not found\n");
+        return -1;
+    }
+    ap_mac_config->beaconInterval = tmp_var;
+    ret = decode_parameter_from_string(priv, &str_ptr, "DTIM_PER=",
+                                        PARAM_TYPE_INT, &tmp_var, 5);
+    if(ret) {
+        unifi_error(priv,"store_ap_advanced_config_from_string: DTIM_PER not found\n");
+        return -1;
+    }
+    ap_mac_config->dtimPeriod = tmp_var;
+    ret = decode_parameter_from_string(priv, &str_ptr, "WMM=",
+                                        PARAM_TYPE_INT, &tmp_var, 5);
+    if(ret) {
+        unifi_error(priv,"store_ap_advanced_config_from_string: WMM not found\n");
+        return -1;
+    }
+    ap_mac_config->wmmEnabled = tmp_var;
+    ret = decode_parameter_from_string(priv, &str_ptr, "PHY=",
+                                        PARAM_TYPE_STRING, phy_mode, 5);
+    if(ret) {
+        unifi_error(priv,"store_ap_advanced_config_from_string: PHY not found\n");
+    } else {
+       if(strstr(phy_mode,"b")){
+           ap_mac_config->phySupportedBitmap = CSR_WIFI_SME_AP_PHY_SUPPORT_B;
+       }
+       if(strstr(phy_mode,"g")) {
+           ap_mac_config->phySupportedBitmap |= CSR_WIFI_SME_AP_PHY_SUPPORT_G;
+       }
+       if(strstr(phy_mode,"n")) {
+           ap_mac_config->phySupportedBitmap |= CSR_WIFI_SME_AP_PHY_SUPPORT_N;
+       }
+       ap_mac_config->supportedRatesCount =
+       uf_configure_supported_rates(ap_mac_config->supportedRates, ap_mac_config->phySupportedBitmap);
+    }
+    return ret;
+}
+
+static int store_ap_config_from_string( unifi_priv_t * priv,char *param_str)
+
+{
+    char *str_ptr = param_str;
+    char sub_cmd[16];
+    char sec[CSR_WIFI_MAX_SEC_LEN];
+    char key[CSR_WIFI_MAX_KEY_LEN];
+    int ret = 0,tmp_var;
+    CsrWifiSmeApConfig_t *ap_config = &priv->ap_config;
+    CsrWifiSmeApMacConfig * ap_mac_config = &priv->ap_mac_config;
+    memset(sub_cmd, 0, sizeof(sub_cmd));
+    if(!strstr(param_str,"END")) {
+        unifi_error(priv,"store_ap_config_from_string:Invalid config string:%s\n",param_str);
+        return -1;
+    }
+    if (decode_parameter_from_string(priv,&str_ptr, "ASCII_CMD=",
+        PARAM_TYPE_STRING, sub_cmd, 6) != 0) {
+         return -1;
+    }
+    if (strncmp(sub_cmd, "AP_CFG", 6)) {
+
+        if(!strncmp(sub_cmd ,"ADVCFG", 6)) {
+           return store_ap_advanced_config_from_string(priv, str_ptr);
+        }
+        unifi_error(priv,"store_ap_config_from_string: sub_cmd:%s != 'AP_CFG or ADVCFG'!\n", sub_cmd);
+        return -1;
+    }
+    memset(ap_config, 0, sizeof(CsrWifiSmeApConfig_t));
+    ret = decode_parameter_from_string(priv,&str_ptr, "SSID=",
+                                       PARAM_TYPE_STRING, ap_config->ssid.ssid,
+                                       CSR_WIFI_MAX_SSID_LEN);
+    if(ret) {
+        unifi_error(priv,"store_ap_config_from_string: SSID not found\n");
+        return -1;
+    }
+    ap_config->ssid.length = strlen(ap_config->ssid.ssid);
+
+    ret = decode_parameter_from_string(priv, &str_ptr, "SEC=",
+                                       PARAM_TYPE_STRING, sec, CSR_WIFI_MAX_SEC_LEN);
+    if(ret) {
+        unifi_error(priv,"store_ap_config_from_string: SEC not found\n");
+        return -1;
+    }
+    ret = decode_parameter_from_string(priv,&str_ptr, "KEY=",
+                         PARAM_TYPE_STRING,  key, CSR_WIFI_MAX_KEY_LEN);
+    if(!strcasecmp(sec,"open")) {
+        unifi_trace(priv,UDBG2,"store_ap_config_from_string: security open");
+        ap_config->credentials.authType = CSR_WIFI_SME_AP_AUTH_TYPE_OPEN_SYSTEM;
+        if(ret) {
+            unifi_notice(priv,"store_ap_config_from_string: KEY not found:fine with Open\n");
+        }
+    }
+    else if(!strcasecmp(sec,"wpa2-psk")) {
+        int i,j=0;
+        CsrWifiNmeApAuthPers *pers =
+                            ((CsrWifiNmeApAuthPers *)&(ap_config->credentials.nmeAuthType.authTypePersonal));
+        CsrUint8 *psk = pers->authPers_credentials.psk.psk;
+
+        unifi_trace(priv,UDBG2,"store_ap_config_from_string: security WPA2");
+        if(ret) {
+            unifi_error(priv,"store_ap_config_from_string: KEY not found for WPA2\n");
+            return -1;
+        }
+        ap_config->credentials.authType = CSR_WIFI_SME_AP_AUTH_TYPE_PERSONAL;
+        pers->authSupport = CSR_WIFI_SME_RSN_AUTH_WPA2PSK;
+        pers->rsnCapabilities =0;
+        pers->wapiCapabilities =0;
+        pers->pskOrPassphrase=CSR_WIFI_NME_AP_CREDENTIAL_TYPE_PSK;
+        pers->authPers_credentials.psk.encryptionMode =
+                 (CSR_WIFI_NME_ENCRYPTION_CIPHER_PAIRWISE_CCMP |CSR_WIFI_NME_ENCRYPTION_CIPHER_GROUP_CCMP) ;
+        for(i=0;i<32;i++){
+           psk[i] = (16*hex_look_up(key[j]))+hex_look_up(key[j+1]);
+           j+=2;
+        }
+
+    } else {
+       unifi_notice(priv,"store_ap_config_from_string: Unknown security: Assuming Open");
+       ap_config->credentials.authType = CSR_WIFI_SME_AP_AUTH_TYPE_OPEN_SYSTEM;
+       return -1;
+    }
+   /* Get the decoded value in a temp int variable to ensure that other fields within the struct
+      which are of type other than int are not over written */
+    ret = decode_parameter_from_string(priv,&str_ptr, "CHANNEL=", PARAM_TYPE_INT, &tmp_var, 5);
+    if(ret)
+        return -1;
+    ap_config->channel = tmp_var;
+    ret = decode_parameter_from_string(priv,&str_ptr, "PREAMBLE=", PARAM_TYPE_INT, &tmp_var, 5);
+    if(ret)
+        return -1;
+    ap_mac_config->preamble = tmp_var;
+    ret = decode_parameter_from_string(priv,&str_ptr, "MAX_SCB=", PARAM_TYPE_INT,  &tmp_var, 5);
+    ap_config->max_connections = tmp_var;
+    return ret;
+}
+
+static int
+iwprivsapstart(struct net_device *dev, struct iw_request_info *info,
+               union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int r;
+
+    unifi_trace(priv, UDBG1, "iwprivsapstart\n" );
+    r = sme_ap_start(priv,interfacePriv->InterfaceTag,&priv->ap_config);
+    if(r) {
+        unifi_error(priv,"iwprivsapstart AP START failed : %d\n",-r);
+    }
+    return r;
+}
+
+static int
+iwprivsapconfig(struct net_device *dev, struct iw_request_info *info,
+                union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    char  *cfg_str = NULL;
+    int r;
+
+    unifi_trace(priv, UDBG1, "iwprivsapconfig\n" );
+    if (wrqu->data.length != 0) {
+        char *str;
+        if (!(cfg_str = kmalloc(wrqu->data.length+1, GFP_KERNEL)))
+        {
+            return -ENOMEM;
+        }
+        if (copy_from_user(cfg_str, wrqu->data.pointer, wrqu->data.length)) {
+            kfree(cfg_str);
+            return -EFAULT;
+        }
+        cfg_str[wrqu->data.length] = 0;
+        unifi_trace(priv,UDBG2,"length:%d\n",wrqu->data.length);
+        unifi_trace(priv,UDBG2,"AP configuration string:%s\n",cfg_str);
+        str = cfg_str;
+       if ((r = store_ap_config_from_string(priv,str))) {
+           unifi_error(priv, "iwprivsapconfig:Failed  to decode the string %d\n",r);
+           kfree(cfg_str);
+           return -EIO;
+
+       }
+    } else {
+        unifi_error(priv,"iwprivsapconfig argument length = 0 \n");
+        return -EIO;
+    }
+    r = sme_ap_config(priv, &priv->ap_mac_config, &priv->group_sec_config);
+    if(r) {
+        unifi_error(priv,"iwprivsapstop AP Config failed : %d\n",-r);
+    } else if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+        interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+        unifi_trace(priv, UDBG1, "iwprivsapconfig: Starting the AP");
+        r = sme_ap_start(priv,interfacePriv->InterfaceTag,&priv->ap_config);
+        if(r) {
+            unifi_error(priv,"iwprivsapstart AP START failed : %d\n",-r);
+        }
+    }
+    kfree(cfg_str);
+    return r;
+}
+
+static int
+iwprivsapstop(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int r;
+    CsrUint16 interface_tag = interfacePriv->InterfaceTag;
+
+    unifi_trace(priv, UDBG1, "iwprivsapstop\n" );
+    r = sme_ap_stop(priv,interface_tag);
+    if(r) {
+        unifi_error(priv,"iwprivsapstop AP STOP failed : %d\n",-r);
+    }
+    return r;
+}
+
+#ifdef ANDROID_BUILD
+static int
+iwprivsapfwreload(struct net_device *dev, struct iw_request_info *info,
+                  union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+
+    unifi_trace(priv, UDBG1, "iwprivsapfwreload\n" );
+    return 0;
+}
+
+static int
+iwprivsstackstart(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    unifi_trace(priv, UDBG1, "iwprivsstackstart\n" );
+    return 0;
+}
+
+static int
+iwprivsstackstop(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int r = 0;
+    CsrUint16 interface_tag = interfacePriv->InterfaceTag;
+
+    unifi_trace(priv, UDBG1, "iwprivsstackstop\n" );
+
+    switch(interfacePriv->interfaceMode) {
+        case CSR_WIFI_ROUTER_CTRL_MODE_STA:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:
+        case CSR_WIFI_ROUTER_CTRL_MODE_IBSS:
+            r = sme_mgt_disconnect(priv);
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            r = sme_ap_stop(priv,interface_tag);
+            break;
+        default :
+            break;
+    }
+
+    if(r) {
+        unifi_error(priv,"iwprivsstackstop Stack stop failed : %d\n",-r);
+    }
+    return 0;
+}
+#endif /* ANDROID_BUILD */
+#endif /* CSR_SUPPORT_WEXT_AP */
+
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+static int
+iwprivsconfwapi(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    CsrUint8 enable;
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    func_enter();
+
+    unifi_trace(priv, UDBG1, "iwprivsconfwapi\n" );
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "iwprivsconfwapi: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+    enable = *(CsrUint8*)(extra);
+
+    if (enable) {
+        priv->connection_config.authModeMask = CSR_WIFI_SME_AUTH_MODE_80211_OPEN;
+        priv->connection_config.authModeMask |= (CSR_WIFI_SME_AUTH_MODE_WAPI_WAIPSK | CSR_WIFI_SME_AUTH_MODE_WAPI_WAI);
+        priv->connection_config.encryptionModeMask |=
+            CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_SMS4 | CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_SMS4;
+    } else {
+        priv->connection_config.authModeMask &= ~(CSR_WIFI_SME_AUTH_MODE_WAPI_WAIPSK | CSR_WIFI_SME_AUTH_MODE_WAPI_WAI);
+        priv->connection_config.encryptionModeMask &=
+            ~(CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_SMS4 | CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_SMS4);
+    }
+
+    func_exit();
+    return 0;
+}
+
+static int
+iwprivswpikey(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    int r = 0, i;
+    CsrWifiSmeKey key;
+    unifiio_wapi_key_t inKey;
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    func_enter();
+
+    unifi_trace(priv, UDBG1, "iwprivswpikey\n" );
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "iwprivswpikey: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+    inKey = *(unifiio_wapi_key_t*)(extra);
+
+    if (inKey.unicastKey) {
+        key.keyType   = CSR_WIFI_SME_KEY_TYPE_PAIRWISE;
+    } else {
+        key.keyType   = CSR_WIFI_SME_KEY_TYPE_GROUP;
+    }
+
+    key.keyIndex  = inKey.keyIndex;
+
+    /* memcpy(key.keyRsc, inKey.keyRsc, 16); */
+    for (i = 0; i < 16; i+= 2)
+    {
+        key.keyRsc[i/2] = inKey.keyRsc[i+1] << 8 | inKey.keyRsc[i];
+    }
+
+    memcpy(key.address.a, inKey.address, 6);
+    key.keyLength = 32;
+    memcpy(key.key, inKey.key, 32);
+    key.authenticator = 0;
+    key.wepTxKey = 0;
+
+    unifi_trace(priv, UDBG1, "keyType = %d, keyIndex = %d, wepTxKey = %d, keyRsc = %x:%x, auth = %d, address = %x:%x, "
+                "keylength = %d, key = %x:%x\n", key.keyType, key.keyIndex, key.wepTxKey,
+                key.keyRsc[0], key.keyRsc[7], key.authenticator,
+                key.address.a[0], key.address.a[5], key.keyLength, key.key[0],
+                key.key[15]);
+
+    r = sme_mgt_key(priv, &key, CSR_WIFI_SME_LIST_ACTION_ADD);
+    if (r) {
+        unifi_error(priv, "SETKEYS request was rejected with result %d\n", r);
+        return convert_sme_error(r);
+    }
+
+    func_exit();
+    return r;
+}
+#endif
+
+
+static int
+unifi_giwname(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    char *name = wrqu->name;
+    unifi_trace(priv, UDBG2, "unifi_giwname\n");
+
+    if (priv->if_index == CSR_INDEX_5G) {
+        strcpy(name, "IEEE 802.11-a");
+    } else {
+        strcpy(name, "IEEE 802.11-bgn");
+    }
+    return 0;
+} /* unifi_giwname() */
+
+
+static int
+unifi_siwfreq(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_freq *freq = (struct iw_freq *)wrqu;
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "unifi_siwfreq\n");
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwfreq: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    /*
+     * Channel is stored in the connection configuration,
+     * and set later when ask for a connection.
+     */
+    if ((freq->e == 0) && (freq->m <= 1000)) {
+        priv->connection_config.adhocChannel = freq->m;
+    } else {
+        priv->connection_config.adhocChannel = wext_freq_to_channel(freq->m, freq->e);
+    }
+
+    func_exit();
+    return 0;
+} /* unifi_siwfreq() */
+
+
+static int
+unifi_giwfreq(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_freq *freq = (struct iw_freq *)wrqu;
+    int err = 0;
+    CsrWifiSmeConnectionInfo connectionInfo;
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "unifi_giwfreq\n");
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_giwfreq: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    UF_RTNL_UNLOCK();
+    err = sme_mgt_connection_info_get(priv, &connectionInfo);
+    UF_RTNL_LOCK();
+
+    freq->m = channel_to_mhz(connectionInfo.channelNumber,
+            (connectionInfo.networkType80211 == CSR_WIFI_SME_RADIO_IF_GHZ_5_0));
+    freq->e = 6;
+
+    func_exit();
+    return convert_sme_error(err);
+} /* unifi_giwfreq() */
+
+
+static int
+unifi_siwmode(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "unifi_siwmode\n");
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwmode: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    switch(wrqu->mode) {
+        case IW_MODE_ADHOC:
+            priv->connection_config.bssType = CSR_WIFI_SME_BSS_TYPE_ADHOC;
+            break;
+        case IW_MODE_INFRA:
+            priv->connection_config.bssType = CSR_WIFI_SME_BSS_TYPE_INFRASTRUCTURE;
+            break;
+        case IW_MODE_AUTO:
+            priv->connection_config.bssType = CSR_WIFI_SME_BSS_TYPE_ANY_BSS;
+            break;
+        default:
+            unifi_notice(priv, "Unknown IW MODE value.\n");
+    }
+
+    /* Clear the SSID and BSSID configuration */
+    priv->connection_config.ssid.length = 0;
+    memset(priv->connection_config.bssid.a, 0xFF, ETH_ALEN);
+
+    func_exit();
+    return 0;
+} /* unifi_siwmode() */
+
+
+
+static int
+unifi_giwmode(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    int r = 0;
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    CsrWifiSmeConnectionConfig connectionConfig;
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "unifi_giwmode\n");
+    CHECK_INITED(priv);
+
+    unifi_trace(priv, UDBG2, "unifi_giwmode: Exisitng mode = 0x%x\n",
+                interfacePriv->interfaceMode);
+    switch(interfacePriv->interfaceMode) {
+        case CSR_WIFI_ROUTER_CTRL_MODE_STA:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:
+           wrqu->mode = IW_MODE_INFRA;
+           break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            wrqu->mode = IW_MODE_MASTER;
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_IBSS:
+            wrqu->mode = IW_MODE_ADHOC;
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2P:
+        case CSR_WIFI_ROUTER_CTRL_MODE_NONE:
+            UF_RTNL_UNLOCK();
+            r = sme_mgt_connection_config_get(priv, &connectionConfig);
+            UF_RTNL_LOCK();
+            if (r == 0) {
+                switch(connectionConfig.bssType) {
+                    case CSR_WIFI_SME_BSS_TYPE_ADHOC:
+                        wrqu->mode = IW_MODE_ADHOC;
+                        break;
+                    case CSR_WIFI_SME_BSS_TYPE_INFRASTRUCTURE:
+                        wrqu->mode = IW_MODE_INFRA;
+                        break;
+                    default:
+                        wrqu->mode = IW_MODE_AUTO;
+                        unifi_notice(priv, "Unknown IW MODE value.\n");
+                }
+            }
+            break;
+        default:
+            wrqu->mode = IW_MODE_AUTO;
+            unifi_notice(priv, "Unknown IW MODE value.\n");
+
+    }
+    unifi_trace(priv, UDBG4, "unifi_giwmode: mode = 0x%x\n", wrqu->mode);
+    func_exit();
+    return r;
+} /* unifi_giwmode() */
+
+
+
+static int
+unifi_giwrange(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    struct iw_point *dwrq = &wrqu->data;
+    struct iw_range *range = (struct iw_range *) extra;
+    int i;
+
+    unifi_trace(NULL, UDBG2, "unifi_giwrange\n");
+
+    dwrq->length = sizeof(struct iw_range);
+    memset(range, 0, sizeof(*range));
+    range->min_nwid = 0x0000;
+    range->max_nwid = 0x0000;
+
+    /*
+     * Don't report the frequency/channel table, then the channel
+     * number returned elsewhere will be printed as a channel number.
+     */
+
+    /* Ranges of values reported in quality structs */
+    range->max_qual.qual  = 40;         /* Max expected qual value */
+    range->max_qual.level = -120;       /* Noise floor in dBm */
+    range->max_qual.noise = -120;       /* Noise floor in dBm */
+
+
+    /* space for IW_MAX_BITRATES (8 up to WE15, 32 later) */
+    i = 0;
+#if WIRELESS_EXT > 15
+    range->bitrate[i++] =   2 * 500000;
+    range->bitrate[i++] =   4 * 500000;
+    range->bitrate[i++] =  11 * 500000;
+    range->bitrate[i++] =  22 * 500000;
+    range->bitrate[i++] =  12 * 500000;
+    range->bitrate[i++] =  18 * 500000;
+    range->bitrate[i++] =  24 * 500000;
+    range->bitrate[i++] =  36 * 500000;
+    range->bitrate[i++] =  48 * 500000;
+    range->bitrate[i++] =  72 * 500000;
+    range->bitrate[i++] =  96 * 500000;
+    range->bitrate[i++] = 108 * 500000;
+#else
+    range->bitrate[i++] =   2 * 500000;
+    range->bitrate[i++] =   4 * 500000;
+    range->bitrate[i++] =  11 * 500000;
+    range->bitrate[i++] =  22 * 500000;
+    range->bitrate[i++] =  24 * 500000;
+    range->bitrate[i++] =  48 * 500000;
+    range->bitrate[i++] =  96 * 500000;
+    range->bitrate[i++] = 108 * 500000;
+#endif /* WIRELESS_EXT < 16 */
+    range->num_bitrates = i;
+
+    range->max_encoding_tokens = NUM_WEPKEYS;
+    range->num_encoding_sizes = 2;
+    range->encoding_size[0] = 5;
+    range->encoding_size[1] = 13;
+
+    range->we_version_source = 20;
+    range->we_version_compiled = WIRELESS_EXT;
+
+    /* Number of channels available in h/w */
+    range->num_channels = 14;
+    /* Number of entries in freq[] array */
+    range->num_frequency = 14;
+    for (i = 0; (i < range->num_frequency) && (i < IW_MAX_FREQUENCIES); i++) {
+        int chan = i + 1;
+        range->freq[i].i = chan;
+        range->freq[i].m = channel_to_mhz(chan, 0);
+        range->freq[i].e = 6;
+    }
+    if ((i+3) < IW_MAX_FREQUENCIES) {
+        range->freq[i].i = 36;
+        range->freq[i].m = channel_to_mhz(36, 1);
+        range->freq[i].e = 6;
+        range->freq[i+1].i = 40;
+        range->freq[i+1].m = channel_to_mhz(40, 1);
+        range->freq[i+1].e = 6;
+        range->freq[i+2].i = 44;
+        range->freq[i+2].m = channel_to_mhz(44, 1);
+        range->freq[i+2].e = 6;
+        range->freq[i+3].i = 48;
+        range->freq[i+3].m = channel_to_mhz(48, 1);
+        range->freq[i+3].e = 6;
+    }
+
+#if WIRELESS_EXT > 16
+    /* Event capability (kernel + driver) */
+    range->event_capa[0] = (IW_EVENT_CAPA_K_0 |
+            IW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |
+            IW_EVENT_CAPA_MASK(SIOCGIWAP) |
+            IW_EVENT_CAPA_MASK(SIOCGIWSCAN));
+    range->event_capa[1] = IW_EVENT_CAPA_K_1;
+    range->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVTXDROP) |
+            IW_EVENT_CAPA_MASK(IWEVCUSTOM) |
+            IW_EVENT_CAPA_MASK(IWEVREGISTERED) |
+            IW_EVENT_CAPA_MASK(IWEVEXPIRED));
+#endif /* WIRELESS_EXT > 16 */
+
+#if WIRELESS_EXT > 17
+    range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
+        IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
+#endif /* WIRELESS_EXT > 17 */
+
+
+    return 0;
+} /* unifi_giwrange() */
+
+
+static int
+unifi_siwap(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int err = 0;
+    const unsigned char zero_bssid[ETH_ALEN] = {0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00};
+
+    func_enter();
+
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwap: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    if (wrqu->ap_addr.sa_family != ARPHRD_ETHER) {
+        return -EINVAL;
+    }
+
+    unifi_trace(priv, UDBG1, "unifi_siwap: asked for %02X:%02X:%02X:%02X:%02X:%02X\n",
+                (u8)wrqu->ap_addr.sa_data[0],
+                (u8)wrqu->ap_addr.sa_data[1],
+                (u8)wrqu->ap_addr.sa_data[2],
+                (u8)wrqu->ap_addr.sa_data[3],
+                (u8)wrqu->ap_addr.sa_data[4],
+                (u8)wrqu->ap_addr.sa_data[5]);
+
+    if (!memcmp(wrqu->ap_addr.sa_data, zero_bssid, ETH_ALEN)) {
+        priv->ignore_bssid_join = FALSE;
+        err = sme_mgt_disconnect(priv);
+        if (err) {
+            unifi_trace(priv, UDBG4, "unifi_siwap: Disconnect failed, status %d\n", err);
+        }
+        return 0;
+    }
+
+    if (priv->ignore_bssid_join) {
+        unifi_trace(priv, UDBG4, "unifi_siwap: ignoring second join\n");
+        priv->ignore_bssid_join = FALSE;
+    } else {
+        memcpy(priv->connection_config.bssid.a, wrqu->ap_addr.sa_data, ETH_ALEN);
+        unifi_trace(priv, UDBG1, "unifi_siwap: Joining %X:%X:%X:%X:%X:%X\n",
+                    priv->connection_config.bssid.a[0],
+                    priv->connection_config.bssid.a[1],
+                    priv->connection_config.bssid.a[2],
+                    priv->connection_config.bssid.a[3],
+                    priv->connection_config.bssid.a[4],
+                    priv->connection_config.bssid.a[5]);
+        err = sme_mgt_connect(priv);
+        if (err) {
+            unifi_error(priv, "unifi_siwap: Join failed, status %d\n", err);
+            func_exit();
+            return convert_sme_error(err);
+        }
+    }
+    func_exit();
+
+    return 0;
+} /* unifi_siwap() */
+
+
+static int
+unifi_giwap(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    CsrWifiSmeConnectionInfo connectionInfo;
+    int r = 0;
+    CsrUint8 *bssid;
+
+    func_enter();
+
+    CHECK_INITED(priv);
+    unifi_trace(priv, UDBG2, "unifi_giwap\n");
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "iwprivswpikey: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_connection_info_get(priv, &connectionInfo);
+    UF_RTNL_LOCK();
+
+    if (r == 0) {
+        bssid = connectionInfo.bssid.a;
+        wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+        unifi_trace(priv, UDBG4,
+                    "unifi_giwap: BSSID = %02X:%02X:%02X:%02X:%02X:%02X\n",
+                    bssid[0], bssid[1], bssid[2],
+                    bssid[3], bssid[4], bssid[5]);
+
+        memcpy(wrqu->ap_addr.sa_data, bssid, ETH_ALEN);
+    } else {
+        memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+    }
+
+    func_exit();
+    return 0;
+} /* unifi_giwap() */
+
+
+static int
+unifi_siwscan(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int scantype;
+    int r;
+    CsrWifiSsid scan_ssid;
+    unsigned char *channel_list = NULL;
+    int chans_good = 0;
+#if WIRELESS_EXT > 17
+    struct iw_point *data = &wrqu->data;
+    struct iw_scan_req *req = (struct iw_scan_req *) extra;
+#endif
+
+    func_enter();
+
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwscan: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    scantype = UNIFI_SCAN_ACTIVE;
+
+#if WIRELESS_EXT > 17
+    /* Providing a valid channel list will force an active scan */
+    if (req) {
+        if ((req->num_channels > 0) && (req->num_channels < IW_MAX_FREQUENCIES)) {
+            channel_list = kmalloc(req->num_channels, GFP_KERNEL);
+            if (channel_list) {
+                int i;
+                for (i = 0; i < req->num_channels; i++) {
+                    /* Convert frequency to channel number */
+                    int ch = wext_freq_to_channel(req->channel_list[i].m,
+                            req->channel_list[i].e);
+                    if (ch) {
+                        channel_list[chans_good++] = ch;
+                    }
+                }
+                unifi_trace(priv, UDBG1,
+                            "SIWSCAN: Scanning %d channels\n", chans_good);
+            } else {
+                /* Fall back to scanning all */
+                unifi_error(priv, "SIWSCAN: Can't alloc channel_list (%d)\n",
+                        req->num_channels);
+            }
+        }
+    }
+
+    if (req && (data->flags & IW_SCAN_THIS_ESSID)) {
+        memcpy(scan_ssid.ssid, req->essid, req->essid_len);
+        scan_ssid.length = req->essid_len;
+        unifi_trace(priv, UDBG1,
+                    "SIWSCAN: Scanning for %.*s\n",
+                    scan_ssid.length, scan_ssid.ssid);
+    } else
+#endif
+    {
+        unifi_trace(priv, UDBG1, "SIWSCAN: Scanning for all APs\n");
+        scan_ssid.length = 0;
+    }
+
+    r = sme_mgt_scan_full(priv, &scan_ssid, chans_good, channel_list);
+    if (r) {
+        unifi_error(priv, "SIWSCAN: Scan returned error %d\n", r);
+    } else {
+        unifi_trace(priv, UDBG1, "SIWSCAN: Scan done\n");
+        wext_send_scan_results_event(priv);
+    }
+
+    if (channel_list) {
+        kfree(channel_list);
+    }
+
+    func_exit();
+    return r;
+
+} /* unifi_siwscan() */
+
+
+static const unsigned char *
+unifi_find_info_element(int id, const unsigned char *info, int len)
+{
+    const unsigned char *ie = info;
+
+    while (len > 1)
+    {
+        int e_id, e_len;
+        e_id = ie[0];
+        e_len = ie[1];
+
+        /* Return if we find a match */
+        if (e_id == id)
+        {
+            return ie;
+        }
+
+        len -= (e_len + 2);
+        ie  += (e_len + 2);
+    }
+
+    return NULL;
+} /* unifi_find_info_element() */
+
+
+/*
+ * Translate scan data returned from the card to a card independent
+ * format that the Wireless Tools will understand - Jean II
+ */
+int
+unifi_translate_scan(struct net_device *dev,
+                     struct iw_request_info *info,
+                     char *current_ev, char *end_buf,
+                     CsrWifiSmeScanResult *scan_data,
+                     int scan_index)
+{
+    struct iw_event iwe;                /* Temporary buffer */
+    unsigned char *info_elems;
+    int info_elem_len;
+    const unsigned char *elem;
+    u16 capabilities;
+    int signal, noise, snr;
+    char *start_buf = current_ev;
+    char *current_val;  /* For rates */
+    int i, r;
+
+    info_elems    = scan_data->informationElements;
+    info_elem_len = scan_data->informationElementsLength;
+
+    if (!scan_data->informationElementsLength || !scan_data->informationElements) {
+        unifi_error(NULL, "*** NULL SCAN IEs ***\n");
+        return -EIO;
+    }
+
+    /* get capinfo bits */
+    capabilities = scan_data->capabilityInformation;
+
+    unifi_trace(NULL, UDBG5, "Capabilities: 0x%x\n", capabilities);
+
+    /* First entry *MUST* be the AP MAC address */
+    memset(&iwe, 0, sizeof(iwe));
+    iwe.cmd = SIOCGIWAP;
+    iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+    memcpy(iwe.u.ap_addr.sa_data, scan_data->bssid.a, ETH_ALEN);
+    iwe.len = IW_EV_ADDR_LEN;
+    r = uf_iwe_stream_add_event(info, start_buf, end_buf, &iwe, IW_EV_ADDR_LEN);
+    if (r < 0) {
+        return r;
+    }
+    start_buf += r;
+
+    /* Other entries will be displayed in the order we give them */
+
+    /* Add the ESSID */
+    /* find SSID in Info Elems */
+    elem = unifi_find_info_element(IE_SSID_ID, info_elems, info_elem_len);
+    if (elem) {
+        int e_len = elem[1];
+        const unsigned char *e_ptr = elem + 2;
+        unsigned char buf[33];
+
+        memset(&iwe, 0, sizeof(iwe));
+        iwe.cmd = SIOCGIWESSID;
+        iwe.u.essid.length = e_len;
+        if (iwe.u.essid.length > 32) {
+            iwe.u.essid.length = 32;
+        }
+        iwe.u.essid.flags = scan_index;
+        memcpy(buf, e_ptr, iwe.u.essid.length);
+        buf[iwe.u.essid.length] = '\0';
+        r = uf_iwe_stream_add_point(info, start_buf, end_buf, &iwe, buf);
+        if (r < 0) {
+            return r;
+        }
+        start_buf += r;
+
+    }
+
+    /* Add mode */
+    memset(&iwe, 0, sizeof(iwe));
+    iwe.cmd = SIOCGIWMODE;
+    if (scan_data->bssType == CSR_WIFI_SME_BSS_TYPE_INFRASTRUCTURE) {
+        iwe.u.mode = IW_MODE_INFRA;
+    } else {
+        iwe.u.mode = IW_MODE_ADHOC;
+    }
+    iwe.len = IW_EV_UINT_LEN;
+    r = uf_iwe_stream_add_event(info, start_buf, end_buf, &iwe, IW_EV_UINT_LEN);
+    if (r < 0) {
+        return r;
+    }
+    start_buf += r;
+
+    /* Add frequency. iwlist will convert to channel using table given in giwrange */
+    memset(&iwe, 0, sizeof(iwe));
+    iwe.cmd = SIOCGIWFREQ;
+    iwe.u.freq.m = scan_data->channelFrequency;
+    iwe.u.freq.e = 6;
+    r = uf_iwe_stream_add_event(info, start_buf, end_buf, &iwe, IW_EV_FREQ_LEN);
+    if (r < 0) {
+        return r;
+    }
+    start_buf += r;
+
+
+    /* Add quality statistics */
+    iwe.cmd = IWEVQUAL;
+    /*
+     * level and noise below are mapped into an unsigned 8 bit number,
+     * ranging from [-192; 63]. The way this is achieved is simply to
+     * add 0x100 onto the number if it is negative,
+     * once clipped to the correct range.
+     */
+    signal = scan_data->rssi; /* This value is in dBm */
+    /* Clip range of snr */
+    snr    = (scan_data->snr > 0) ? scan_data->snr : 0; /* In dB relative, from 0 - 255 */
+    snr    = (snr < 255) ? snr : 255;
+    noise  = signal - snr;
+
+    /* Clip range of signal */
+    signal = (signal < 63) ? signal : 63;
+    signal = (signal > -192) ? signal : -192;
+
+    /* Clip range of noise */
+    noise = (noise < 63) ? noise : 63;
+    noise = (noise > -192) ? noise : -192;
+
+    /* Make u8 */
+    signal = ( signal < 0 ) ? signal + 0x100 : signal;
+    noise = ( noise < 0 ) ? noise + 0x100 : noise;
+
+    iwe.u.qual.level = (u8)signal; /* -192 : 63 */
+    iwe.u.qual.noise = (u8)noise;  /* -192 : 63 */
+    iwe.u.qual.qual = snr;         /* 0 : 255 */
+    iwe.u.qual.updated = 0;
+#if WIRELESS_EXT > 16
+    iwe.u.qual.updated |= IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_UPDATED |
+        IW_QUAL_QUAL_UPDATED;
+#if WIRELESS_EXT > 18
+    iwe.u.qual.updated |= IW_QUAL_DBM;
+#endif
+#endif
+    r = uf_iwe_stream_add_event(info, start_buf, end_buf, &iwe, IW_EV_QUAL_LEN);
+    if (r < 0) {
+        return r;
+    }
+    start_buf += r;
+
+    /* Add encryption capability */
+    iwe.cmd = SIOCGIWENCODE;
+    if (capabilities & SIG_CAP_PRIVACY) {
+        iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+    } else {
+        iwe.u.data.flags = IW_ENCODE_DISABLED;
+    }
+    iwe.u.data.length = 0;
+    iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
+    r = uf_iwe_stream_add_point(info, start_buf, end_buf, &iwe, "");
+    if (r < 0) {
+        return r;
+    }
+    start_buf += r;
+
+
+    /*
+     * Rate : stuffing multiple values in a single event require a bit
+     * more of magic - Jean II
+     */
+    current_val = start_buf + IW_EV_LCP_LEN;
+
+    iwe.cmd = SIOCGIWRATE;
+    /* Those two flags are ignored... */
+    iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+
+    elem = unifi_find_info_element(IE_SUPPORTED_RATES_ID,
+            info_elems, info_elem_len);
+    if (elem) {
+        int e_len = elem[1];
+        const unsigned char *e_ptr = elem + 2;
+
+        /*
+         * Count how many rates we have.
+         * Zero marks the end of the list, if the list is not truncated.
+         */
+        /* Max 8 values */
+        for (i = 0; i < e_len; i++) {
+            if (e_ptr[i] == 0) {
+                break;
+            }
+            /* Bit rate given in 500 kb/s units (+ 0x80) */
+            iwe.u.bitrate.value = ((e_ptr[i] & 0x7f) * 500000);
+            /* Add new value to event */
+            r = uf_iwe_stream_add_value(info, start_buf, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
+            if (r < 0) {
+                return r;
+            }
+            current_val +=r;
+
+        }
+    }
+    elem = unifi_find_info_element(IE_EXTENDED_SUPPORTED_RATES_ID,
+            info_elems, info_elem_len);
+    if (elem) {
+        int e_len = elem[1];
+        const unsigned char *e_ptr = elem + 2;
+
+        /*
+         * Count how many rates we have.
+         * Zero marks the end of the list, if the list is not truncated.
+         */
+        /* Max 8 values */
+        for (i = 0; i < e_len; i++) {
+            if (e_ptr[i] == 0) {
+                break;
+            }
+            /* Bit rate given in 500 kb/s units (+ 0x80) */
+            iwe.u.bitrate.value = ((e_ptr[i] & 0x7f) * 500000);
+            /* Add new value to event */
+            r = uf_iwe_stream_add_value(info, start_buf, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
+            if (r < 0) {
+                return r;
+            }
+            current_val +=r;
+        }
+    }
+    /* Check if we added any rates event */
+    if ((current_val - start_buf) > IW_EV_LCP_LEN) {
+        start_buf = current_val;
+    }
+
+
+#if WIRELESS_EXT > 17
+    memset(&iwe, 0, sizeof(iwe));
+    iwe.cmd = IWEVGENIE;
+    iwe.u.data.length = info_elem_len;
+
+    r = uf_iwe_stream_add_point(info, start_buf, end_buf, &iwe, info_elems);
+    if (r < 0) {
+        return r;
+    }
+
+    start_buf += r;
+#endif /* WE > 17 */
+
+    return (start_buf - current_ev);
+} /* unifi_translate_scan() */
+
+
+
+static int
+unifi_giwscan(struct net_device *dev, struct iw_request_info *info,
+              union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_point *dwrq = &wrqu->data;
+    int r;
+
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_giwscan: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    unifi_trace(priv, UDBG1,
+            "unifi_giwscan: buffer (%d bytes) \n",
+            dwrq->length);
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_scan_results_get_async(priv, info, extra, dwrq->length);
+    UF_RTNL_LOCK();
+    if (r < 0) {
+        unifi_trace(priv, UDBG1,
+                "unifi_giwscan: buffer (%d bytes) not big enough.\n",
+                dwrq->length);
+        return r;
+    }
+
+    dwrq->length = r;
+    dwrq->flags = 0;
+
+    return 0;
+} /* unifi_giwscan() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_siwessid
+ *
+ *      Request to join a network or start and AdHoc.
+ *
+ *  Arguments:
+ *      dev             Pointer to network device struct.
+ *      info            Pointer to broken-out ioctl request.
+ *      data            Pointer to argument data.
+ *      essid           Pointer to string giving name of network to join
+ *                      or start
+ *
+ *  Returns:
+ *      0 on success and everything complete
+ *      -EINPROGRESS to have the higher level call the commit method.
+ * ---------------------------------------------------------------------------
+ */
+static int
+unifi_siwessid(struct net_device *dev, struct iw_request_info *info,
+               struct iw_point *data, char *essid)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int len;
+    int err = 0;
+
+    func_enter();
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwessid: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    len = 0;
+    if (data->flags & 1) {
+        /* Limit length  */
+        len = data->length;
+        if (len > UNIFI_MAX_SSID_LEN) {
+            len = UNIFI_MAX_SSID_LEN;
+        }
+    }
+
+#ifdef UNIFI_DEBUG
+    {
+        char essid_str[UNIFI_MAX_SSID_LEN+1];
+        int i;
+
+        for (i = 0; i < len; i++) {
+            essid_str[i] = (isprint(essid[i]) ? essid[i] : '?');
+        }
+        essid_str[i] = '\0';
+
+        unifi_trace(priv, UDBG1, "unifi_siwessid: asked for '%*s' (%d)\n", len, essid_str, len);
+        unifi_trace(priv, UDBG2, " with authModeMask = %d", priv->connection_config.authModeMask);
+    }
+#endif
+
+    memset(priv->connection_config.bssid.a, 0xFF, ETH_ALEN);
+    if (len) {
+        if (essid[len - 1] == 0) {
+            len --;
+        }
+
+        memcpy(priv->connection_config.ssid.ssid, essid, len);
+        priv->connection_config.ssid.length = len;
+
+    } else {
+        priv->connection_config.ssid.length = 0;
+    }
+
+    UF_RTNL_UNLOCK();
+    err = sme_mgt_connect(priv);
+    UF_RTNL_LOCK();
+    if (err) {
+        unifi_error(priv, "unifi_siwessid: Join failed, status %d\n", err);
+        func_exit();
+        return convert_sme_error(err);
+    }
+
+    func_exit();
+    return 0;
+} /* unifi_siwessid() */
+
+
+static int
+unifi_giwessid(struct net_device *dev, struct iw_request_info *info,
+               union iwreq_data *wrqu, char *essid)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_point *data = &wrqu->essid;
+    CsrWifiSmeConnectionInfo connectionInfo;
+    int r = 0;
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "unifi_giwessid\n");
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_giwessid: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_connection_info_get(priv, &connectionInfo);
+    UF_RTNL_LOCK();
+
+    if (r == 0) {
+        data->length = connectionInfo.ssid.length;
+        strncpy(essid,
+                connectionInfo.ssid.ssid,
+                data->length);
+        data->flags = 1;            /* active */
+
+        unifi_trace(priv, UDBG2, "unifi_giwessid: %.*s\n",
+                data->length, essid);
+    }
+
+    func_exit();
+
+    return 0;
+} /* unifi_giwessid() */
+
+
+static int
+unifi_siwrate(struct net_device *dev, struct iw_request_info *info,
+              union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_param *args = &wrqu->bitrate;
+    CsrWifiSmeMibConfig mibConfig;
+    int r;
+
+    func_enter();
+
+    CHECK_INITED(priv);
+    unifi_trace(priv, UDBG2, "unifi_siwrate\n");
+
+    /*
+     * If args->fixed == 0, value is max rate or -1 for best
+     * If args->fixed == 1, value is rate to set or -1 for best
+     * args->disabled and args->flags are not used in SIOCSIWRATE
+     */
+
+    /* Get, modify and set the MIB data */
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_mib_config_get(priv, &mibConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_siwrate: Get CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+
+    /* Default to auto rate algorithm */
+    /* in 500Kbit/s, 0 means auto */
+    mibConfig.unifiFixTxDataRate = 0;
+
+    if (args->value != -1) {
+        mibConfig.unifiFixTxDataRate = args->value / 500000;
+    }
+
+    /* 1 means rate is a maximum, 2 means rate is a set value */
+    if (args->fixed == 1) {
+        mibConfig.unifiFixMaxTxDataRate = 0;
+    } else {
+        mibConfig.unifiFixMaxTxDataRate = 1;
+    }
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_mib_config_set(priv, &mibConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_siwrate: Set CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+
+    func_exit();
+
+    return 0;
+} /* unifi_siwrate() */
+
+
+
+static int
+unifi_giwrate(struct net_device *dev, struct iw_request_info *info,
+              union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_param *args = &wrqu->bitrate;
+    int r;
+    int bitrate, flag;
+    CsrWifiSmeMibConfig mibConfig;
+    CsrWifiSmeConnectionStats connectionStats;
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "unifi_giwrate\n");
+    CHECK_INITED(priv);
+
+    flag = 0;
+    bitrate = 0;
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_mib_config_get(priv, &mibConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_giwrate: Get CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+
+    bitrate = mibConfig.unifiFixTxDataRate;
+    flag = mibConfig.unifiFixMaxTxDataRate;
+
+    /* Used the value returned by the SME if MIB returns 0 */
+    if (bitrate == 0) {
+        UF_RTNL_UNLOCK();
+        r = sme_mgt_connection_stats_get(priv, &connectionStats);
+        UF_RTNL_LOCK();
+        /* Ignore errors, we may be disconnected */
+        if (r == 0) {
+            bitrate = connectionStats.unifiTxDataRate;
+        }
+    }
+
+    args->value = bitrate * 500000;
+    args->fixed = !flag;
+
+    func_exit();
+
+    return 0;
+} /* unifi_giwrate() */
+
+
+static int
+unifi_siwrts(struct net_device *dev, struct iw_request_info *info,
+             union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int val = wrqu->rts.value;
+    int r = 0;
+    CsrWifiSmeMibConfig mibConfig;
+
+    unifi_trace(priv, UDBG2, "unifi_siwrts\n");
+    CHECK_INITED(priv);
+
+    if (wrqu->rts.disabled) {
+        val = 2347;
+    }
+
+    if ( (val < 0) || (val > 2347) )
+    {
+        return -EINVAL;
+    }
+
+    /* Get, modify and set the MIB data */
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_mib_config_get(priv, &mibConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_siwrts: Get CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+    mibConfig.dot11RtsThreshold = val;
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_mib_config_set(priv, &mibConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_siwrts: Set CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+
+    return 0;
+}
+
+
+static int
+unifi_giwrts(struct net_device *dev, struct iw_request_info *info,
+             union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int r;
+    int rts_thresh;
+    CsrWifiSmeMibConfig mibConfig;
+
+    unifi_trace(priv, UDBG2, "unifi_giwrts\n");
+    CHECK_INITED(priv);
+
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_mib_config_get(priv, &mibConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_giwrts: Get CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+
+    rts_thresh = mibConfig.dot11RtsThreshold;
+    if (rts_thresh > 2347) {
+        rts_thresh = 2347;
+    }
+
+    wrqu->rts.value = rts_thresh;
+    wrqu->rts.disabled = (rts_thresh == 2347);
+    wrqu->rts.fixed = 1;
+
+    return 0;
+}
+
+
+static int
+unifi_siwfrag(struct net_device *dev, struct iw_request_info *info,
+              union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int val = wrqu->frag.value;
+    int r = 0;
+    CsrWifiSmeMibConfig mibConfig;
+
+    unifi_trace(priv, UDBG2, "unifi_siwfrag\n");
+    CHECK_INITED(priv);
+
+    if (wrqu->frag.disabled)
+        val = 2346;
+
+    if ( (val < 256) || (val > 2347) )
+        return -EINVAL;
+
+    /* Get, modify and set the MIB data */
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_mib_config_get(priv, &mibConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_siwfrag: Get CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+    /* Fragmentation Threashold must be even */
+    mibConfig.dot11FragmentationThreshold = (val & ~0x1);
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_mib_config_set(priv, &mibConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_siwfrag: Set CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+
+    return 0;
+}
+
+
+static int
+unifi_giwfrag(struct net_device *dev, struct iw_request_info *info,
+              union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int r;
+    int frag_thresh;
+    CsrWifiSmeMibConfig mibConfig;
+
+    unifi_trace(priv, UDBG2, "unifi_giwfrag\n");
+    CHECK_INITED(priv);
+
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_mib_config_get(priv, &mibConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_giwfrag: Get CsrWifiSmeMibConfigValue failed.\n");
+        return r;
+    }
+
+    frag_thresh = mibConfig.dot11FragmentationThreshold;
+
+    /* Build the return structure */
+    wrqu->frag.value = frag_thresh;
+    wrqu->frag.disabled = (frag_thresh >= 2346);
+    wrqu->frag.fixed = 1;
+
+    return 0;
+}
+
+
+static int
+unifi_siwencode(struct net_device *dev, struct iw_request_info *info,
+                union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_point *erq = &wrqu->encoding;
+    int index;
+    int rc = 0;
+    int privacy = -1;
+    CsrWifiSmeKey sme_key;
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "unifi_siwencode\n");
+
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwencode: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    /*
+     * Key index is encoded in the flags.
+     * 0 - use current default,
+     * 1-4 - if a key value is given set that key
+     *       if not use that key
+     */
+    index = (erq->flags & IW_ENCODE_INDEX);  /* key number, 1-4 */
+    if ((index < 0) || (index > 4)) {
+        unifi_error(priv, "unifi_siwencode: Request to set an invalid key (index:%d)", index);
+        return -EINVAL;
+    }
+
+    /*
+     * Basic checking: do we have a key to set ?
+     * The IW_ENCODE_NOKEY flag is set when no key is present (only change flags),
+     * but older versions rely on sending a key id 1-4.
+     */
+    if (erq->length > 0) {
+
+        /* Check the size of the key */
+        if ((erq->length > LARGE_KEY_SIZE) || (erq->length < SMALL_KEY_SIZE)) {
+            unifi_error(priv, "unifi_siwencode: Request to set an invalid key (length:%d)",
+                        erq->length);
+            return -EINVAL;
+        }
+
+        /* Check the index (none (i.e. 0) means use current) */
+        if ((index < 1) || (index > 4)) {
+            /* If we do not have a previous key, use 1 as default */
+            if (!priv->wep_tx_key_index) {
+                priv->wep_tx_key_index = 1;
+            }
+            index = priv->wep_tx_key_index;
+        }
+
+        /* If we didn't have a key and a valid index is set, we want to remember it*/
+        if (!priv->wep_tx_key_index) {
+            priv->wep_tx_key_index = index;
+        }
+
+        unifi_trace(priv, UDBG1, "Tx key Index is %d\n", priv->wep_tx_key_index);
+
+        privacy = 1;
+
+        /* Check if the key is not marked as invalid */
+        if ((erq->flags & IW_ENCODE_NOKEY) == 0) {
+
+            unifi_trace(priv, UDBG1, "New %s key (len=%d, index=%d)\n",
+                        (priv->wep_tx_key_index == index) ? "tx" : "",
+                        erq->length, index);
+
+            sme_key.wepTxKey = (priv->wep_tx_key_index == index);
+            if (priv->wep_tx_key_index == index) {
+                sme_key.keyType = CSR_WIFI_SME_KEY_TYPE_PAIRWISE;
+            } else {
+                sme_key.keyType = CSR_WIFI_SME_KEY_TYPE_GROUP;
+            }
+            /* Key index is zero based in SME but 1 based in wext */
+            sme_key.keyIndex = (index - 1);
+            sme_key.keyLength = erq->length;
+            sme_key.authenticator = 0;
+            memset(sme_key.address.a, 0xFF, ETH_ALEN);
+            memcpy(sme_key.key, extra, erq->length);
+
+            UF_RTNL_UNLOCK();
+            rc = sme_mgt_key(priv, &sme_key, CSR_WIFI_SME_LIST_ACTION_ADD);
+            UF_RTNL_LOCK();
+            if (rc) {
+                unifi_error(priv, "unifi_siwencode: Set key failed (%d)", rc);
+                return convert_sme_error(rc);
+            }
+
+            /* Store the key to be reported by the SIOCGIWENCODE handler */
+            priv->wep_keys[index - 1].len = erq->length;
+            memcpy(priv->wep_keys[index - 1].key, extra, erq->length);
+        }
+    } else {
+        /*
+         * No additional key data, so it must be a request to change the
+         * active key.
+         */
+        if (index != 0) {
+            unifi_trace(priv, UDBG1, "Tx key Index is %d\n", index - 1);
+
+            /* Store the index to be reported by the SIOCGIWENCODE handler */
+            priv->wep_tx_key_index = index;
+
+            sme_key.wepTxKey = 1;
+            sme_key.keyType = CSR_WIFI_SME_KEY_TYPE_PAIRWISE;
+
+            /* Key index is zero based in SME but 1 based in wext */
+            sme_key.keyIndex = (index - 1);
+            sme_key.keyLength = 0;
+            sme_key.authenticator = 0;
+            UF_RTNL_UNLOCK();
+            rc = sme_mgt_key(priv, &sme_key, CSR_WIFI_SME_LIST_ACTION_ADD);
+            UF_RTNL_LOCK();
+            if (rc) {
+                unifi_error(priv, "unifi_siwencode: Set key failed (%d)", rc);
+                return convert_sme_error(rc);
+            }
+
+            /* Turn on encryption */
+            privacy = 1;
+        }
+    }
+
+    /* Read the flags */
+    if (erq->flags & IW_ENCODE_DISABLED) {
+        /* disable encryption */
+        unifi_trace(priv, UDBG1, "disable WEP encryption\n");
+        privacy = 0;
+
+        priv->wep_tx_key_index = 0;
+
+        unifi_trace(priv, UDBG1, "IW_ENCODE_DISABLED: CSR_WIFI_SME_AUTH_MODE_80211_OPEN\n");
+        priv->connection_config.authModeMask = CSR_WIFI_SME_AUTH_MODE_80211_OPEN;
+    }
+
+    if (erq->flags & IW_ENCODE_RESTRICTED) {
+        /* Use shared key auth */
+        unifi_trace(priv, UDBG1, "IW_ENCODE_RESTRICTED: CSR_WIFI_SME_AUTH_MODE_80211_SHARED\n");
+        priv->connection_config.authModeMask = CSR_WIFI_SME_AUTH_MODE_80211_SHARED;
+
+        /* Turn on encryption */
+        privacy = 1;
+    }
+    if (erq->flags & IW_ENCODE_OPEN) {
+        unifi_trace(priv, UDBG1, "IW_ENCODE_OPEN: CSR_WIFI_SME_AUTH_MODE_80211_OPEN\n");
+        priv->connection_config.authModeMask = CSR_WIFI_SME_AUTH_MODE_80211_OPEN;
+    }
+
+    /* Commit the changes to flags if needed */
+    if (privacy != -1) {
+        priv->connection_config.privacyMode = privacy ? CSR_WIFI_SME_80211_PRIVACY_MODE_ENABLED : CSR_WIFI_SME_80211_PRIVACY_MODE_DISABLED;
+        priv->connection_config.encryptionModeMask = privacy ? (CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_WEP40 |
+                CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_WEP104 |
+                CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP40 |
+                CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP104) :
+            CSR_WIFI_SME_ENCRYPTION_CIPHER_NONE;
+    }
+
+    func_exit_r(rc);
+    return convert_sme_error(rc);
+
+} /* unifi_siwencode() */
+
+
+
+static int
+unifi_giwencode(struct net_device *dev, struct iw_request_info *info,
+                union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_point *erq = &wrqu->encoding;
+
+    unifi_trace(priv, UDBG2, "unifi_giwencode\n");
+
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_giwencode: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    if (priv->connection_config.authModeMask == CSR_WIFI_SME_AUTH_MODE_80211_SHARED) {
+        erq->flags = IW_ENCODE_RESTRICTED;
+    }
+    else {
+        if (priv->connection_config.privacyMode == CSR_WIFI_SME_80211_PRIVACY_MODE_DISABLED) {
+            erq->flags = IW_ENCODE_DISABLED;
+        } else {
+            erq->flags = IW_ENCODE_OPEN;
+        }
+    }
+
+    erq->length = 0;
+
+    if (erq->flags != IW_ENCODE_DISABLED) {
+        int index = priv->wep_tx_key_index;
+
+        if ((index > 0) && (index <= NUM_WEPKEYS)) {
+            erq->flags |= (index & IW_ENCODE_INDEX);
+            erq->length = priv->wep_keys[index - 1].len;
+            memcpy(extra, priv->wep_keys[index - 1].key, erq->length);
+        } else {
+            unifi_notice(priv, "unifi_giwencode: Surprise, do not have a valid key index (%d)\n",
+                         index);
+        }
+    }
+
+    return 0;
+} /* unifi_giwencode() */
+
+
+static int
+unifi_siwpower(struct net_device *dev, struct iw_request_info *info,
+               union iwreq_data *wrqu, char *extra)
+{
+    struct iw_param *args = &wrqu->power;
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int listen_interval, wake_for_dtim;
+    int r = 0;
+    CsrWifiSmePowerConfig powerConfig;
+
+    unifi_trace(priv, UDBG2, "unifi_siwpower\n");
+
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwpower: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_power_config_get(priv, &powerConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_siwpower: Get unifi_PowerConfigValue failed.\n");
+        return r;
+    }
+
+    listen_interval = -1;
+    wake_for_dtim = -1;
+    if (args->disabled) {
+        powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_LOW;
+    }
+    else
+    {
+        powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_HIGH;
+
+        switch (args->flags & IW_POWER_TYPE) {
+            case 0:
+                /* not specified */
+                break;
+            case IW_POWER_PERIOD:
+                listen_interval = args->value / 1000;
+                break;
+            default:
+                return -EINVAL;
+        }
+
+        switch (args->flags & IW_POWER_MODE) {
+            case 0:
+                /* not specified */
+                break;
+            case IW_POWER_UNICAST_R:
+                /* not interested in broadcast packets */
+                wake_for_dtim = 0;
+                break;
+            case IW_POWER_ALL_R:
+                /* yes, we are interested in broadcast packets */
+                wake_for_dtim = 1;
+                break;
+            default:
+                return -EINVAL;
+        }
+    }
+
+    if (listen_interval > 0) {
+        powerConfig.listenIntervalTu = listen_interval;
+        unifi_trace(priv, UDBG4, "unifi_siwpower: new Listen Interval = %d.\n",
+                    powerConfig.listenIntervalTu);
+    }
+
+    if (wake_for_dtim >= 0) {
+        powerConfig.rxDtims = wake_for_dtim;
+    }
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_power_config_set(priv, &powerConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_siwpower: Set unifi_PowerConfigValue failed.\n");
+        return r;
+    }
+
+    return 0;
+} /* unifi_siwpower() */
+
+
+static int
+unifi_giwpower(struct net_device *dev, struct iw_request_info *info,
+               union iwreq_data *wrqu, char *extra)
+{
+    struct iw_param *args = &wrqu->power;
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    CsrWifiSmePowerConfig powerConfig;
+    int r;
+
+    unifi_trace(priv, UDBG2, "unifi_giwpower\n");
+
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_giwpower: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    args->flags = 0;
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_power_config_get(priv, &powerConfig);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "unifi_giwpower: Get unifi_PowerConfigValue failed.\n");
+        return r;
+    }
+
+    unifi_trace(priv, UDBG4, "unifi_giwpower: mode=%d\n",
+                powerConfig.powerSaveLevel);
+
+    args->disabled = (powerConfig.powerSaveLevel == CSR_WIFI_SME_POWER_SAVE_LEVEL_LOW);
+    if (args->disabled) {
+        args->flags = 0;
+        return 0;
+    }
+
+    args->value = powerConfig.listenIntervalTu * 1000;
+    args->flags |= IW_POWER_PERIOD;
+
+    if (powerConfig.rxDtims) {
+        args->flags |= IW_POWER_ALL_R;
+    } else {
+        args->flags |= IW_POWER_UNICAST_R;
+    }
+
+    return 0;
+} /* unifi_giwpower() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_siwcommit - handler for SIOCSIWCOMMIT
+ *
+ *      Apply all the parameters that have been set.
+ *      In practice this means:
+ *       - do a scan
+ *       - join a network or start an AdHoc
+ *       - authenticate and associate.
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static int
+unifi_siwcommit(struct net_device *dev, struct iw_request_info *info,
+                union iwreq_data *wrqu, char *extra)
+{
+    return 0;
+} /* unifi_siwcommit() */
+
+
+
+static int
+unifi_siwmlme(struct net_device *dev, struct iw_request_info *info,
+              union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_mlme *mlme = (struct iw_mlme *)extra;
+    func_enter();
+
+    unifi_trace(priv, UDBG2, "unifi_siwmlme\n");
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwmlme: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    switch (mlme->cmd) {
+        case IW_MLME_DEAUTH:
+        case IW_MLME_DISASSOC:
+            UF_RTNL_UNLOCK();
+            sme_mgt_disconnect(priv);
+            UF_RTNL_LOCK();
+            break;
+        default:
+            func_exit_r(-EOPNOTSUPP);
+            return -EOPNOTSUPP;
+    }
+
+    func_exit();
+    return 0;
+} /* unifi_siwmlme() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_siwgenie
+ *  unifi_giwgenie
+ *
+ *      WPA : Generic IEEE 802.11 information element (e.g., for WPA/RSN/WMM).
+ *      Handlers for SIOCSIWGENIE, SIOCGIWGENIE - set/get generic IE
+ *
+ *      The host program (e.g. wpa_supplicant) uses this call to set the
+ *      additional IEs to accompany the next (Associate?) request.
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ *  Notes:
+ *      From wireless.h:
+ *        This ioctl uses struct iw_point and data buffer that includes IE id
+ *        and len fields. More than one IE may be included in the
+ *        request. Setting the generic IE to empty buffer (len=0) removes the
+ *        generic IE from the driver.
+ * ---------------------------------------------------------------------------
+ */
+static int
+unifi_siwgenie(struct net_device *dev, struct iw_request_info *info,
+               union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int len;
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "unifi_siwgenie\n");
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwgenie: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    if ( priv->connection_config.mlmeAssociateReqInformationElements) {
+        kfree( priv->connection_config.mlmeAssociateReqInformationElements);
+    }
+    priv->connection_config.mlmeAssociateReqInformationElementsLength = 0;
+    priv->connection_config.mlmeAssociateReqInformationElements = NULL;
+
+    len = wrqu->data.length;
+    if (len == 0) {
+        func_exit();
+        return 0;
+    }
+
+    priv->connection_config.mlmeAssociateReqInformationElements = kmalloc(len, GFP_KERNEL);
+    if (priv->connection_config.mlmeAssociateReqInformationElements == NULL) {
+        func_exit();
+        return -ENOMEM;
+    }
+
+    priv->connection_config.mlmeAssociateReqInformationElementsLength = len;
+    memcpy( priv->connection_config.mlmeAssociateReqInformationElements, extra, len);
+
+    func_exit();
+    return 0;
+} /* unifi_siwgenie() */
+
+
+static int
+unifi_giwgenie(struct net_device *dev, struct iw_request_info *info,
+               union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    int len;
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "unifi_giwgenie\n");
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_giwgenie: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    len = priv->connection_config.mlmeAssociateReqInformationElementsLength;
+
+    if (len == 0) {
+        wrqu->data.length = 0;
+        return 0;
+    }
+
+    if (wrqu->data.length < len) {
+        return -E2BIG;
+    }
+
+    wrqu->data.length = len;
+    memcpy(extra, priv->connection_config.mlmeAssociateReqInformationElements, len);
+
+    func_exit();
+    return 0;
+} /* unifi_giwgenie() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_siwauth
+ *  unifi_giwauth
+ *
+ *      Handlers for SIOCSIWAUTH, SIOCGIWAUTH
+ *      Set/get various authentication parameters.
+ *
+ *  Arguments:
+ *
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static int
+_unifi_siwauth(struct net_device *dev, struct iw_request_info *info,
+               union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    CsrWifiSmeAuthModeMask new_auth;
+
+    func_enter();
+    unifi_trace(priv, UDBG2, "unifi_siwauth\n");
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwauth: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    /*
+     * This ioctl is safe to call even when UniFi is powered off.
+     * wpa_supplicant calls it to test whether we support WPA.
+     */
+
+    switch (wrqu->param.flags & IW_AUTH_INDEX) {
+
+        case IW_AUTH_WPA_ENABLED:
+            unifi_trace(priv, UDBG1, "IW_AUTH_WPA_ENABLED: %d\n", wrqu->param.value);
+
+            if (wrqu->param.value == 0) {
+                unifi_trace(priv, UDBG5, "IW_AUTH_WPA_ENABLED: CSR_WIFI_SME_AUTH_MODE_80211_OPEN\n");
+                priv->connection_config.authModeMask = CSR_WIFI_SME_AUTH_MODE_80211_OPEN;
+            }
+            break;
+
+        case IW_AUTH_PRIVACY_INVOKED:
+            unifi_trace(priv, UDBG1, "IW_AUTH_PRIVACY_INVOKED: %d\n", wrqu->param.value);
+
+            priv->connection_config.privacyMode = wrqu->param.value ? CSR_WIFI_SME_80211_PRIVACY_MODE_ENABLED : CSR_WIFI_SME_80211_PRIVACY_MODE_DISABLED;
+            if (wrqu->param.value == CSR_WIFI_SME_80211_PRIVACY_MODE_DISABLED)
+            {
+                priv->connection_config.encryptionModeMask = CSR_WIFI_SME_ENCRYPTION_CIPHER_NONE;
+            }
+            break;
+
+        case IW_AUTH_80211_AUTH_ALG:
+            /*
+               IW_AUTH_ALG_OPEN_SYSTEM      0x00000001
+               IW_AUTH_ALG_SHARED_KEY       0x00000002
+               IW_AUTH_ALG_LEAP             0x00000004
+               */
+            new_auth = 0;
+            if (wrqu->param.value & IW_AUTH_ALG_OPEN_SYSTEM) {
+                unifi_trace(priv, UDBG1, "IW_AUTH_80211_AUTH_ALG: %d (IW_AUTH_ALG_OPEN_SYSTEM)\n", wrqu->param.value);
+                new_auth |= CSR_WIFI_SME_AUTH_MODE_80211_OPEN;
+            }
+            if (wrqu->param.value & IW_AUTH_ALG_SHARED_KEY) {
+                unifi_trace(priv, UDBG1, "IW_AUTH_80211_AUTH_ALG: %d (IW_AUTH_ALG_SHARED_KEY)\n", wrqu->param.value);
+                new_auth |= CSR_WIFI_SME_AUTH_MODE_80211_SHARED;
+            }
+            if (wrqu->param.value & IW_AUTH_ALG_LEAP) {
+                /* Initial exchanges using open-system to set EAP */
+                unifi_trace(priv, UDBG1, "IW_AUTH_80211_AUTH_ALG: %d (IW_AUTH_ALG_LEAP)\n", wrqu->param.value);
+                new_auth |= CSR_WIFI_SME_AUTH_MODE_8021X_OTHER1X;
+            }
+            if (new_auth == 0) {
+                unifi_trace(priv, UDBG1, "IW_AUTH_80211_AUTH_ALG: invalid value %d\n",
+                        wrqu->param.value);
+                return -EINVAL;
+            } else {
+                priv->connection_config.authModeMask = new_auth;
+            }
+            break;
+
+        case IW_AUTH_WPA_VERSION:
+            unifi_trace(priv, UDBG1, "IW_AUTH_WPA_VERSION: %d\n", wrqu->param.value);
+            priv->ignore_bssid_join = TRUE;
+            /*
+               IW_AUTH_WPA_VERSION_DISABLED 0x00000001
+               IW_AUTH_WPA_VERSION_WPA      0x00000002
+               IW_AUTH_WPA_VERSION_WPA2     0x00000004
+               */
+
+            if (!(wrqu->param.value & IW_AUTH_WPA_VERSION_DISABLED)) {
+
+                priv->connection_config.authModeMask = CSR_WIFI_SME_AUTH_MODE_80211_OPEN;
+
+                if (wrqu->param.value & IW_AUTH_WPA_VERSION_WPA) {
+                    unifi_trace(priv, UDBG4, "IW_AUTH_WPA_VERSION: WPA, WPA-PSK\n");
+                    priv->connection_config.authModeMask |= (CSR_WIFI_SME_AUTH_MODE_8021X_WPA | CSR_WIFI_SME_AUTH_MODE_8021X_WPAPSK);
+                }
+                if (wrqu->param.value & IW_AUTH_WPA_VERSION_WPA2) {
+                    unifi_trace(priv, UDBG4, "IW_AUTH_WPA_VERSION: WPA2, WPA2-PSK\n");
+                    priv->connection_config.authModeMask |= (CSR_WIFI_SME_AUTH_MODE_8021X_WPA2 | CSR_WIFI_SME_AUTH_MODE_8021X_WPA2PSK);
+                }
+            }
+            break;
+
+        case IW_AUTH_CIPHER_PAIRWISE:
+            unifi_trace(priv, UDBG1, "IW_AUTH_CIPHER_PAIRWISE: %d\n", wrqu->param.value);
+            /*
+             * one of:
+             IW_AUTH_CIPHER_NONE	0x00000001
+             IW_AUTH_CIPHER_WEP40	0x00000002
+             IW_AUTH_CIPHER_TKIP	0x00000004
+             IW_AUTH_CIPHER_CCMP	0x00000008
+             IW_AUTH_CIPHER_WEP104	0x00000010
+             */
+
+            priv->connection_config.encryptionModeMask = CSR_WIFI_SME_ENCRYPTION_CIPHER_NONE;
+
+            if (wrqu->param.value & IW_AUTH_CIPHER_WEP40) {
+                priv->connection_config.encryptionModeMask |=
+                    CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_WEP40 | CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP40;
+            }
+            if (wrqu->param.value & IW_AUTH_CIPHER_WEP104) {
+                priv->connection_config.encryptionModeMask |=
+                    CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_WEP104 | CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP104;
+            }
+            if (wrqu->param.value & IW_AUTH_CIPHER_TKIP) {
+                priv->connection_config.encryptionModeMask |=
+                    CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_TKIP | CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_TKIP;
+            }
+            if (wrqu->param.value & IW_AUTH_CIPHER_CCMP) {
+                priv->connection_config.encryptionModeMask |=
+                    CSR_WIFI_SME_ENCRYPTION_CIPHER_PAIRWISE_CCMP | CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_CCMP;
+            }
+
+            break;
+
+        case IW_AUTH_CIPHER_GROUP:
+            unifi_trace(priv, UDBG1, "IW_AUTH_CIPHER_GROUP: %d\n", wrqu->param.value);
+            /*
+             * Use the WPA version and the group cipher suite to set the permitted
+             * group key in the MIB. f/w uses this value to validate WPA and RSN IEs
+             * in the probe responses from the desired BSS(ID)
+             */
+
+            priv->connection_config.encryptionModeMask &= ~(CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP40 |
+                    CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP104 |
+                    CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_TKIP |
+                    CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_CCMP);
+            if (wrqu->param.value & IW_AUTH_CIPHER_WEP40) {
+                priv->connection_config.encryptionModeMask |= CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP40;
+            }
+            if (wrqu->param.value & IW_AUTH_CIPHER_WEP104) {
+                priv->connection_config.encryptionModeMask |= CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_WEP104;
+            }
+            if (wrqu->param.value & IW_AUTH_CIPHER_TKIP) {
+                priv->connection_config.encryptionModeMask |= CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_TKIP;
+            }
+            if (wrqu->param.value & IW_AUTH_CIPHER_CCMP) {
+                priv->connection_config.encryptionModeMask |= CSR_WIFI_SME_ENCRYPTION_CIPHER_GROUP_CCMP;
+            }
+
+            break;
+
+        case IW_AUTH_KEY_MGMT:
+            unifi_trace(priv, UDBG1, "IW_AUTH_KEY_MGMT: %d\n", wrqu->param.value);
+            /*
+               IW_AUTH_KEY_MGMT_802_1X 1
+               IW_AUTH_KEY_MGMT_PSK    2
+               */
+            if (priv->connection_config.authModeMask & (CSR_WIFI_SME_AUTH_MODE_8021X_WPA | CSR_WIFI_SME_AUTH_MODE_8021X_WPAPSK)) {
+                /* Check for explicitly set mode. */
+                if (wrqu->param.value == IW_AUTH_KEY_MGMT_802_1X) {
+                    priv->connection_config.authModeMask &= ~CSR_WIFI_SME_AUTH_MODE_8021X_WPAPSK;
+                }
+                if (wrqu->param.value == IW_AUTH_KEY_MGMT_PSK) {
+                    priv->connection_config.authModeMask &= ~CSR_WIFI_SME_AUTH_MODE_8021X_WPA;
+                }
+                unifi_trace(priv, UDBG5, "IW_AUTH_KEY_MGMT: WPA: %d\n",
+                            priv->connection_config.authModeMask);
+            }
+            if (priv->connection_config.authModeMask & (CSR_WIFI_SME_AUTH_MODE_8021X_WPA2 | CSR_WIFI_SME_AUTH_MODE_8021X_WPA2PSK)) {
+                /* Check for explicitly set mode. */
+                if (wrqu->param.value == IW_AUTH_KEY_MGMT_802_1X) {
+                    priv->connection_config.authModeMask &= ~CSR_WIFI_SME_AUTH_MODE_8021X_WPA2PSK;
+                }
+                if (wrqu->param.value == IW_AUTH_KEY_MGMT_PSK) {
+                    priv->connection_config.authModeMask &= ~CSR_WIFI_SME_AUTH_MODE_8021X_WPA2;
+                }
+                unifi_trace(priv, UDBG5, "IW_AUTH_KEY_MGMT: WPA2: %d\n",
+                            priv->connection_config.authModeMask);
+            }
+
+            break;
+        case IW_AUTH_TKIP_COUNTERMEASURES:
+            /*
+             * Set to true at the start of the 60 second backup-off period
+             * following 2 MichaelMIC failures within 60s.
+             */
+            unifi_trace(priv, UDBG1, "IW_AUTH_TKIP_COUNTERMEASURES: %d\n", wrqu->param.value);
+            break;
+
+        case IW_AUTH_DROP_UNENCRYPTED:
+            /*
+             * Set to true on init.
+             * Set to false just before associate if encryption will not be
+             * required.
+             *
+             * Note this is not the same as the 802.1X controlled port
+             */
+            unifi_trace(priv, UDBG1, "IW_AUTH_DROP_UNENCRYPTED: %d\n", wrqu->param.value);
+            break;
+
+        case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+            /*
+             * This is set by wpa_supplicant to allow unencrypted EAPOL messages
+             * even if pairwise keys are set when not using WPA. IEEE 802.1X
+             * specifies that these frames are not encrypted, but WPA encrypts
+             * them when pairwise keys are in use.
+             * I think the UniFi f/w handles this decision for us.
+             */
+            unifi_trace(priv, UDBG1, "IW_AUTH_RX_UNENCRYPTED_EAPOL: %d\n", wrqu->param.value);
+            break;
+
+        case IW_AUTH_ROAMING_CONTROL:
+            unifi_trace(priv, UDBG1, "IW_AUTH_ROAMING_CONTROL: %d\n", wrqu->param.value);
+            break;
+
+        default:
+            unifi_trace(priv, UDBG1, "Unsupported auth param %d to 0x%X\n",
+                        wrqu->param.flags & IW_AUTH_INDEX,
+                        wrqu->param.value);
+            return -EOPNOTSUPP;
+    }
+
+    unifi_trace(priv, UDBG2, "authModeMask = %d", priv->connection_config.authModeMask);
+    func_exit();
+
+    return 0;
+} /* _unifi_siwauth() */
+
+
+static int
+unifi_siwauth(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    int err = 0;
+
+    UF_RTNL_UNLOCK();
+    err = _unifi_siwauth(dev, info, wrqu, extra);
+    UF_RTNL_LOCK();
+
+    return err;
+} /* unifi_siwauth() */
+
+
+static int
+unifi_giwauth(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    unifi_trace(NULL, UDBG2, "unifi_giwauth\n");
+    return -EOPNOTSUPP;
+} /* unifi_giwauth() */
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_siwencodeext
+ *  unifi_giwencodeext
+ *
+ *      Handlers for SIOCSIWENCODEEXT, SIOCGIWENCODEEXT - set/get
+ *      encoding token & mode
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *      For WPA/WPA2 we don't take note of the IW_ENCODE_EXT_SET_TX_KEY flag.
+ *      This flag means "use this key to encode transmissions"; we just
+ *      assume only one key will be set and that is the one to use.
+ * ---------------------------------------------------------------------------
+ */
+static int
+_unifi_siwencodeext(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+    int r = 0;
+    unsigned char *keydata;
+    unsigned char tkip_key[32];
+    int keyid;
+    unsigned char *a = (unsigned char *)ext->addr.sa_data;
+    CsrWifiSmeKey sme_key;
+    CsrWifiSmeKeyType key_type;
+
+    func_enter();
+
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwencodeext: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    unifi_trace(priv, UDBG1, "siwencodeext: flags=0x%X, alg=%d, ext_flags=0x%X, len=%d, index=%d,\n",
+                wrqu->encoding.flags, ext->alg, ext->ext_flags,
+                ext->key_len, (wrqu->encoding.flags & IW_ENCODE_INDEX));
+    unifi_trace(priv, UDBG3, "              addr=%02X:%02X:%02X:%02X:%02X:%02X\n",
+                a[0], a[1], a[2], a[3], a[4], a[5]);
+
+    if ((ext->key_len == 0) && (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)) {
+        /* This means use a different key (given by key_idx) for Tx. */
+        /* NYI */
+        unifi_trace(priv, UDBG1, KERN_ERR "unifi_siwencodeext: NYI should change tx key id here!!\n");
+        return -ENOTSUPP;
+    }
+
+    memset(&sme_key, 0, sizeof(sme_key));
+
+    keydata = (unsigned char *)(ext + 1);
+    keyid = (wrqu->encoding.flags & IW_ENCODE_INDEX);
+
+    /*
+     * Check for request to delete keys for an address.
+     */
+    /* Pick out request for no privacy. */
+    if (ext->alg == IW_ENCODE_ALG_NONE) {
+
+        unifi_trace(priv, UDBG1, "Deleting %s key %d\n",
+                    (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) ? "GROUP" : "PAIRWISE",
+                    keyid);
+
+        if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+            sme_key.keyType = CSR_WIFI_SME_KEY_TYPE_GROUP;
+        } else {
+            sme_key.keyType = CSR_WIFI_SME_KEY_TYPE_PAIRWISE;
+        }
+        sme_key.keyIndex = (keyid - 1);
+        sme_key.keyLength = 0;
+        sme_key.authenticator = 0;
+        memcpy(sme_key.address.a, a, ETH_ALEN);
+        UF_RTNL_UNLOCK();
+        r = sme_mgt_key(priv, &sme_key, CSR_WIFI_SME_LIST_ACTION_REMOVE);
+        UF_RTNL_LOCK();
+        if (r) {
+            unifi_error(priv, "Delete key request was rejected with result %d\n", r);
+            return convert_sme_error(r);
+        }
+
+        return 0;
+    }
+
+    /*
+     * Request is to set a key, not delete
+     */
+
+    /* Pick out WEP and use set_wep_key(). */
+    if (ext->alg == IW_ENCODE_ALG_WEP) {
+        /* WEP-40, WEP-104 */
+
+        /* Check for valid key length */
+        if (!((ext->key_len == 5) || (ext->key_len == 13))) {
+            unifi_trace(priv, UDBG1, KERN_ERR "Invalid length for WEP key: %d\n", ext->key_len);
+            return -EINVAL;
+        }
+
+        unifi_trace(priv, UDBG1, "Setting WEP key %d tx:%d\n",
+                    keyid, ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY);
+
+        if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+            sme_key.wepTxKey = TRUE;
+            sme_key.keyType = CSR_WIFI_SME_KEY_TYPE_PAIRWISE;
+        } else {
+            sme_key.wepTxKey = FALSE;
+            sme_key.keyType = CSR_WIFI_SME_KEY_TYPE_GROUP;
+        }
+        sme_key.keyIndex = (keyid - 1);
+        sme_key.keyLength = ext->key_len;
+        sme_key.authenticator = 0;
+        memset(sme_key.address.a, 0xFF, ETH_ALEN);
+        memcpy(sme_key.key, keydata, ext->key_len);
+        UF_RTNL_UNLOCK();
+        r = sme_mgt_key(priv, &sme_key, CSR_WIFI_SME_LIST_ACTION_ADD);
+        UF_RTNL_LOCK();
+        if (r) {
+            unifi_error(priv, "siwencodeext: Set key failed (%d)", r);
+            return convert_sme_error(r);
+        }
+
+        return 0;
+    }
+
+    /*
+     *
+     * If we reach here, we are dealing with a WPA/WPA2 key
+     *
+     */
+    if (ext->key_len > 32) {
+        return -EINVAL;
+    }
+
+    /*
+     * TKIP keys from wpa_supplicant need swapping.
+     * What about other supplicants (when they come along)?
+     */
+    if ((ext->alg == IW_ENCODE_ALG_TKIP) && (ext->key_len == 32)) {
+        memcpy(tkip_key, keydata, 16);
+        memcpy(tkip_key + 16, keydata + 24, 8);
+        memcpy(tkip_key + 24, keydata + 16, 8);
+        keydata = tkip_key;
+    }
+
+    key_type = (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) ?
+        CSR_WIFI_SME_KEY_TYPE_GROUP : /* Group Key */
+        CSR_WIFI_SME_KEY_TYPE_PAIRWISE; /* Pairwise Key */
+
+    sme_key.keyType = key_type;
+    sme_key.keyIndex = (keyid - 1);
+    sme_key.keyLength = ext->key_len;
+    sme_key.authenticator = 0;
+    memcpy(sme_key.address.a, ext->addr.sa_data, ETH_ALEN);
+    if (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
+
+        unifi_trace(priv, UDBG5, "RSC first 6 bytes = %02X:%02X:%02X:%02X:%02X:%02X\n",
+                    ext->rx_seq[0], ext->rx_seq[1], ext->rx_seq[2], ext->rx_seq[3], ext->rx_seq[4], ext->rx_seq[5]);
+
+        /* memcpy((u8*)(&sme_key.keyRsc), ext->rx_seq, 8); */
+        sme_key.keyRsc[0] = ext->rx_seq[1] << 8 | ext->rx_seq[0];
+        sme_key.keyRsc[1] = ext->rx_seq[3] << 8 | ext->rx_seq[2];
+        sme_key.keyRsc[2] = ext->rx_seq[5] << 8 | ext->rx_seq[4];
+        sme_key.keyRsc[3] = ext->rx_seq[7] << 8 | ext->rx_seq[6];
+
+    }
+
+    memcpy(sme_key.key, keydata, ext->key_len);
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_key(priv, &sme_key, CSR_WIFI_SME_LIST_ACTION_ADD);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "SETKEYS request was rejected with result %d\n", r);
+        return convert_sme_error(r);
+    }
+
+    func_exit();
+    return r;
+} /* _unifi_siwencodeext() */
+
+
+static int
+unifi_siwencodeext(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    int err = 0;
+
+    err = _unifi_siwencodeext(dev, info, wrqu, extra);
+
+    return err;
+} /* unifi_siwencodeext() */
+
+
+static int
+unifi_giwencodeext(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    return -EOPNOTSUPP;
+} /* unifi_giwencodeext() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_siwpmksa
+ *
+ *      SIOCSIWPMKSA - PMKSA cache operation
+ *      The caller passes a pmksa structure:
+ *        - cmd         one of ADD, REMOVE, FLUSH
+ *        - bssid       MAC address
+ *        - pmkid       ID string (16 bytes)
+ *
+ *  Arguments:
+ *      None.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *      This is not needed since we provide a siwgenie method.
+ * ---------------------------------------------------------------------------
+ */
+#define UNIFI_PMKID_KEY_SIZE 16
+static int
+unifi_siwpmksa(struct net_device *dev, struct iw_request_info *info,
+        union iwreq_data *wrqu, char *extra)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+    struct iw_pmksa *pmksa = (struct iw_pmksa *)extra;
+    CsrResult r = 0;
+    CsrWifiSmePmkidList pmkid_list;
+    CsrWifiSmePmkid pmkid;
+    CsrWifiSmeListAction action;
+
+    CHECK_INITED(priv);
+
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+       unifi_error(priv, "unifi_siwpmksa: not permitted in Mode %d\n",
+                                      interfacePriv->interfaceMode);
+       return -EPERM;
+    }
+
+
+    unifi_trace(priv, UDBG1, "SIWPMKSA: cmd %d, %02x:%02x:%02x:%02x:%02x:%02x\n",
+                pmksa->cmd,
+                pmksa->bssid.sa_data[0],
+                pmksa->bssid.sa_data[1],
+                pmksa->bssid.sa_data[2],
+                pmksa->bssid.sa_data[3],
+                pmksa->bssid.sa_data[4],
+                pmksa->bssid.sa_data[5]);
+
+    pmkid_list.pmkids = NULL;
+    switch (pmksa->cmd) {
+      case IW_PMKSA_ADD:
+        pmkid_list.pmkids = &pmkid;
+        action = CSR_WIFI_SME_LIST_ACTION_ADD;
+        pmkid_list.pmkidsCount = 1;
+        memcpy(pmkid.bssid.a, pmksa->bssid.sa_data, ETH_ALEN);
+        memcpy(pmkid.pmkid, pmksa->pmkid, UNIFI_PMKID_KEY_SIZE);
+        break;
+      case IW_PMKSA_REMOVE:
+        pmkid_list.pmkids = &pmkid;
+        action = CSR_WIFI_SME_LIST_ACTION_REMOVE;
+        pmkid_list.pmkidsCount = 1;
+        memcpy(pmkid.bssid.a, pmksa->bssid.sa_data, ETH_ALEN);
+        memcpy(pmkid.pmkid, pmksa->pmkid, UNIFI_PMKID_KEY_SIZE);
+        break;
+      case IW_PMKSA_FLUSH:
+        /* Replace current PMKID's with an empty list */
+        pmkid_list.pmkidsCount = 0;
+        action = CSR_WIFI_SME_LIST_ACTION_FLUSH;
+        break;
+      default:
+        unifi_notice(priv, "SIWPMKSA: Unknown command (0x%x)\n", pmksa->cmd);
+        return -EINVAL;
+    }
+
+    /* Set the Value the pmkid's will have 1 added OR 1 removed OR be cleared at this point */
+    UF_RTNL_UNLOCK();
+    r = sme_mgt_pmkid(priv, action, &pmkid_list);
+    UF_RTNL_LOCK();
+    if (r) {
+        unifi_error(priv, "SIWPMKSA: Set PMKID's Failed.\n");
+    }
+
+    return r;
+
+} /* unifi_siwpmksa() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_get_wireless_stats
+ *
+ *      get_wireless_stats method for Linux wireless extensions.
+ *
+ *  Arguments:
+ *      dev             Pointer to associated netdevice.
+ *
+ *  Returns:
+ *      Pointer to iw_statistics struct.
+ * ---------------------------------------------------------------------------
+ */
+struct iw_statistics *
+unifi_get_wireless_stats(struct net_device *dev)
+{
+    netInterface_priv_t *interfacePriv = (netInterface_priv_t *)netdev_priv(dev);
+    unifi_priv_t *priv = interfacePriv->privPtr;
+
+    if (priv->init_progress != UNIFI_INIT_COMPLETED) {
+        return NULL;
+    }
+
+    return &priv->wext_wireless_stats;
+} /* unifi_get_wireless_stats() */
+
+
+/*
+ * Structures to export the Wireless Handlers
+ */
+
+static const struct iw_priv_args unifi_private_args[] = {
+    /*{ cmd,         set_args,                            get_args, name } */
+    { SIOCIWS80211POWERSAVEPRIV, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1,
+        IW_PRIV_TYPE_NONE, "iwprivs80211ps" },
+    { SIOCIWG80211POWERSAVEPRIV, IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IWPRIV_POWER_SAVE_MAX_STRING, "iwprivg80211ps" },
+    { SIOCIWS80211RELOADDEFAULTSPRIV, IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_NONE, "iwprivsdefs" },
+    { SIOCIWSSMEDEBUGPRIV, IW_PRIV_TYPE_CHAR | IWPRIV_SME_DEBUG_MAX_STRING, IW_PRIV_TYPE_NONE, "iwprivssmedebug" },
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+    { SIOCIWSCONFWAPIPRIV, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1,
+        IW_PRIV_TYPE_NONE, "iwprivsconfwapi" },
+    { SIOCIWSWAPIKEYPRIV, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | sizeof(unifiio_wapi_key_t),
+        IW_PRIV_TYPE_NONE, "iwprivswpikey" },
+#endif
+#ifdef CSR_SUPPORT_WEXT_AP
+    { SIOCIWSAPCFGPRIV, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_NONE, "AP_SET_CFG" },
+    { SIOCIWSAPSTARTPRIV, 0,IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED|IWPRIV_SME_MAX_STRING,"AP_BSS_START" },
+    { SIOCIWSAPSTOPPRIV, IW_PRIV_TYPE_CHAR |IW_PRIV_SIZE_FIXED|0,
+      IW_PRIV_TYPE_CHAR |IW_PRIV_SIZE_FIXED|0, "AP_BSS_STOP" },
+#ifdef ANDROID_BUILD
+    { SIOCIWSFWRELOADPRIV, IW_PRIV_TYPE_CHAR |256,
+      IW_PRIV_TYPE_CHAR |IW_PRIV_SIZE_FIXED|0, "WL_FW_RELOAD" },
+    { SIOCIWSSTACKSTART, 0,
+      IW_PRIV_TYPE_CHAR |IW_PRIV_SIZE_FIXED|IWPRIV_SME_MAX_STRING, "START" },
+    { SIOCIWSSTACKSTOP, 0,
+      IW_PRIV_TYPE_CHAR |IW_PRIV_SIZE_FIXED|IWPRIV_SME_MAX_STRING, "STOP" },
+#endif /* ANDROID_BUILD */
+#endif /* CSR_SUPPORT_WEXT_AP */
+};
+
+static const iw_handler unifi_handler[] =
+{
+    (iw_handler) unifi_siwcommit,           /* SIOCSIWCOMMIT */
+    (iw_handler) unifi_giwname,             /* SIOCGIWNAME */
+    (iw_handler) NULL,                      /* SIOCSIWNWID */
+    (iw_handler) NULL,                      /* SIOCGIWNWID */
+    (iw_handler) unifi_siwfreq,             /* SIOCSIWFREQ */
+    (iw_handler) unifi_giwfreq,             /* SIOCGIWFREQ */
+    (iw_handler) unifi_siwmode,             /* SIOCSIWMODE */
+    (iw_handler) unifi_giwmode,             /* SIOCGIWMODE */
+    (iw_handler) NULL,                      /* SIOCSIWSENS */
+    (iw_handler) NULL,                      /* SIOCGIWSENS */
+    (iw_handler) NULL,                      /* SIOCSIWRANGE */
+    (iw_handler) unifi_giwrange,            /* SIOCGIWRANGE */
+    (iw_handler) NULL,                      /* SIOCSIWPRIV */
+    (iw_handler) NULL,                      /* SIOCGIWPRIV */
+    (iw_handler) NULL,                      /* SIOCSIWSTATS */
+    (iw_handler) NULL,                      /* SIOCGIWSTATS */
+    (iw_handler) NULL,                      /* SIOCSIWSPY */
+    (iw_handler) NULL,                      /* SIOCGIWSPY */
+    (iw_handler) NULL,                      /* SIOCSIWTHRSPY */
+    (iw_handler) NULL,                      /* SIOCGIWTHRSPY */
+    (iw_handler) unifi_siwap,               /* SIOCSIWAP */
+    (iw_handler) unifi_giwap,               /* SIOCGIWAP */
+#if WIRELESS_EXT > 17
+    /* WPA : IEEE 802.11 MLME requests */
+    unifi_siwmlme,              /* SIOCSIWMLME, request MLME operation */
+#else
+    (iw_handler) NULL,                      /* -- hole -- */
+#endif
+    (iw_handler) NULL,                      /* SIOCGIWAPLIST */
+    (iw_handler) unifi_siwscan,             /* SIOCSIWSCAN */
+    (iw_handler) unifi_giwscan,             /* SIOCGIWSCAN */
+    (iw_handler) unifi_siwessid,            /* SIOCSIWESSID */
+    (iw_handler) unifi_giwessid,            /* SIOCGIWESSID */
+    (iw_handler) NULL,                      /* SIOCSIWNICKN */
+    (iw_handler) NULL,                      /* SIOCGIWNICKN */
+    (iw_handler) NULL,                      /* -- hole -- */
+    (iw_handler) NULL,                      /* -- hole -- */
+    unifi_siwrate,                          /* SIOCSIWRATE */
+    unifi_giwrate,                          /* SIOCGIWRATE */
+    unifi_siwrts,                           /* SIOCSIWRTS */
+    unifi_giwrts,                           /* SIOCGIWRTS */
+    unifi_siwfrag,                          /* SIOCSIWFRAG */
+    unifi_giwfrag,                          /* SIOCGIWFRAG */
+    (iw_handler) NULL,                      /* SIOCSIWTXPOW */
+    (iw_handler) NULL,                      /* SIOCGIWTXPOW */
+    (iw_handler) NULL,                      /* SIOCSIWRETRY */
+    (iw_handler) NULL,                      /* SIOCGIWRETRY */
+    unifi_siwencode,                        /* SIOCSIWENCODE */
+    unifi_giwencode,                        /* SIOCGIWENCODE */
+    unifi_siwpower,                         /* SIOCSIWPOWER */
+    unifi_giwpower,                         /* SIOCGIWPOWER */
+#if WIRELESS_EXT > 17
+    (iw_handler) NULL,                      /* -- hole -- */
+    (iw_handler) NULL,                      /* -- hole -- */
+
+    /* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM). */
+    unifi_siwgenie,             /* SIOCSIWGENIE */      /* set generic IE */
+    unifi_giwgenie,             /* SIOCGIWGENIE */      /* get generic IE */
+
+    /* WPA : Authentication mode parameters */
+    unifi_siwauth,              /* SIOCSIWAUTH */       /* set authentication mode params */
+    unifi_giwauth,              /* SIOCGIWAUTH */       /* get authentication mode params */
+
+    /* WPA : Extended version of encoding configuration */
+    unifi_siwencodeext,         /* SIOCSIWENCODEEXT */  /* set encoding token & mode */
+    unifi_giwencodeext,         /* SIOCGIWENCODEEXT */  /* get encoding token & mode */
+
+    /* WPA2 : PMKSA cache management */
+    unifi_siwpmksa,             /* SIOCSIWPMKSA */      /* PMKSA cache operation */
+    (iw_handler) NULL,          /* -- hole -- */
+#endif /* WIRELESS_EXT > 17 */
+};
+
+
+static const iw_handler unifi_private_handler[] =
+{
+    iwprivs80211ps,                 /* SIOCIWFIRSTPRIV */
+    iwprivg80211ps,                 /* SIOCIWFIRSTPRIV + 1 */
+    iwprivsdefs,                    /* SIOCIWFIRSTPRIV + 2 */
+    (iw_handler) NULL,
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+    iwprivsconfwapi,                /* SIOCIWFIRSTPRIV + 4 */
+    (iw_handler) NULL,              /* SIOCIWFIRSTPRIV + 5 */
+    iwprivswpikey,                  /* SIOCIWFIRSTPRIV + 6 */
+#else
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+#endif
+    (iw_handler) NULL,
+    iwprivssmedebug,                /* SIOCIWFIRSTPRIV + 8 */
+#ifdef CSR_SUPPORT_WEXT_AP
+    (iw_handler) NULL,
+    iwprivsapconfig,
+    (iw_handler) NULL,
+    iwprivsapstart,
+    (iw_handler) NULL,
+    iwprivsapstop,
+    (iw_handler) NULL,
+#ifdef ANDROID_BUILD
+    iwprivsapfwreload,
+    (iw_handler) NULL,
+    iwprivsstackstart,
+    (iw_handler) NULL,
+    iwprivsstackstop,
+#else
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+#endif /* ANDROID_BUILD */
+#else
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+    (iw_handler) NULL,
+#endif /* CSR_SUPPORT_WEXT_AP */
+};
+
+struct iw_handler_def unifi_iw_handler_def =
+{
+    .num_standard       = sizeof(unifi_handler) / sizeof(iw_handler),
+    .num_private        = sizeof(unifi_private_handler) / sizeof(iw_handler),
+    .num_private_args   = sizeof(unifi_private_args) / sizeof(struct iw_priv_args),
+    .standard           = (iw_handler *) unifi_handler,
+    .private            = (iw_handler *) unifi_private_handler,
+    .private_args       = (struct iw_priv_args *) unifi_private_args,
+#if IW_HANDLER_VERSION >= 6
+    .get_wireless_stats = unifi_get_wireless_stats,
+#endif
+};
+
+
--- /dev/null
+++ b/drivers/staging/csr/ul_int.c
@@ -0,0 +1,552 @@
+/*
+ * ***************************************************************************
+ *  FILE:     ul_int.c
+ *
+ *  PURPOSE:
+ *      Manage list of client applications using UniFi.
+ *
+ * Copyright (C) 2006-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ***************************************************************************
+ */
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_conversions.h"
+#include "unifi_priv.h"
+#include "unifiio.h"
+#include "unifi_os.h"
+
+static void free_bulkdata_buffers(unifi_priv_t *priv, bulk_data_param_t *bulkdata);
+static void reset_driver_status(unifi_priv_t *priv);
+
+/*
+ * ---------------------------------------------------------------------------
+ *  ul_init_clients
+ *
+ *      Initialise the clients array to empty.
+ *
+ *  Arguments:
+ *      priv            Pointer to device private context struct
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *      This function needs to be called before priv is stored in
+ *      Unifi_instances[].
+ * ---------------------------------------------------------------------------
+ */
+void
+ul_init_clients(unifi_priv_t *priv)
+{
+    int id;
+    ul_client_t *ul_clients;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
+    sema_init(&priv->udi_logging_mutex, 1);
+#else
+    init_MUTEX(&priv->udi_logging_mutex);
+#endif
+    priv->logging_client = NULL;
+
+    ul_clients = priv->ul_clients;
+
+    for (id = 0; id < MAX_UDI_CLIENTS; id++) {
+        memset(&ul_clients[id], 0, sizeof(ul_client_t));
+
+        ul_clients[id].client_id = id;
+        ul_clients[id].sender_id = UDI_SENDER_ID_BASE + (id << UDI_SENDER_ID_SHIFT);
+        ul_clients[id].instance = -1;
+        ul_clients[id].event_hook = NULL;
+
+        INIT_LIST_HEAD(&ul_clients[id].udi_log);
+        init_waitqueue_head(&ul_clients[id].udi_wq);
+        sema_init(&ul_clients[id].udi_sem, 1);
+
+        ul_clients[id].wake_up_wq_id = 0;
+        ul_clients[id].seq_no = 0;
+        ul_clients[id].wake_seq_no = 0;
+        ul_clients[id].snap_filter.count = 0;
+    }
+} /* ul_init_clients() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  ul_register_client
+ *
+ *      This function registers a new ul client.
+ *
+ *  Arguments:
+ *      priv            Pointer to device private context struct
+ *      configuration   Special configuration for the client.
+ *      udi_event_clbk  Callback for receiving event from unifi.
+ *
+ *  Returns:
+ *      0 if a new clients is registered, -1 otherwise.
+ * ---------------------------------------------------------------------------
+ */
+ul_client_t *
+ul_register_client(unifi_priv_t *priv, unsigned int configuration,
+                   udi_event_t udi_event_clbk)
+{
+    unsigned char id, ref;
+    ul_client_t *ul_clients;
+
+    ul_clients = priv->ul_clients;
+
+    /* check for an unused entry */
+    for (id = 0; id < MAX_UDI_CLIENTS; id++) {
+        if (ul_clients[id].udi_enabled == 0) {
+            ul_clients[id].instance = priv->instance;
+            ul_clients[id].udi_enabled = 1;
+            ul_clients[id].configuration = configuration;
+
+            /* Allocate memory for the reply signal.. */
+            ul_clients[id].reply_signal = (CSR_SIGNAL*) CsrPmemAlloc(sizeof(CSR_SIGNAL));
+            if (ul_clients[id].reply_signal == NULL) {
+                unifi_error(priv, "Failed to allocate reply signal for client.\n");
+                return NULL;
+            }
+            /* .. and the bulk data of the reply signal. */
+            for (ref = 0; ref < UNIFI_MAX_DATA_REFERENCES; ref ++) {
+                ul_clients[id].reply_bulkdata[ref] =
+                        (bulk_data_t*) CsrPmemAlloc(sizeof(bulk_data_t));
+                /* If allocation fails, free allocated memory. */
+                if (ul_clients[id].reply_bulkdata[ref] == NULL) {
+                    for (; ref > 0; ref --) {
+                        CsrPmemFree(ul_clients[id].reply_bulkdata[ref - 1]);
+                    }
+                    CsrPmemFree(ul_clients[id].reply_signal);
+                    unifi_error(priv, "Failed to allocate bulk data buffers for client.\n");
+                    return NULL;
+                }
+            }
+
+            /* Set the event callback. */
+            ul_clients[id].event_hook = udi_event_clbk;
+
+            unifi_trace(priv, UDBG2, "UDI %d (0x%x) registered. configuration = 0x%x\n",
+                        id, &ul_clients[id], configuration);
+            return &ul_clients[id];
+        }
+    }
+    return NULL;
+} /* ul_register_client() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  ul_deregister_client
+ *
+ *      This function deregisters a blocking UDI client.
+ *
+ *  Arguments:
+ *      client      Pointer to the client we deregister.
+ *
+ *  Returns:
+ *      0 if a new clients is deregistered.
+ * ---------------------------------------------------------------------------
+ */
+int
+ul_deregister_client(ul_client_t *ul_client)
+{
+    struct list_head *pos, *n;
+    udi_log_t *logptr;
+    unifi_priv_t *priv = uf_find_instance(ul_client->instance);
+    int ref;
+
+    ul_client->instance = -1;
+    ul_client->event_hook = NULL;
+    ul_client->udi_enabled = 0;
+    unifi_trace(priv, UDBG5, "UDI (0x%x) deregistered.\n", ul_client);
+
+    /* Free memory allocated for the reply signal and its bulk data. */
+    CsrPmemFree(ul_client->reply_signal);
+    for (ref = 0; ref < UNIFI_MAX_DATA_REFERENCES; ref ++) {
+        CsrPmemFree(ul_client->reply_bulkdata[ref]);
+    }
+
+    if (ul_client->snap_filter.count) {
+        ul_client->snap_filter.count = 0;
+        CsrPmemFree(ul_client->snap_filter.protocols);
+    }
+
+    /* Free anything pending on the udi_log list */
+    down(&ul_client->udi_sem);
+    list_for_each_safe(pos, n, &ul_client->udi_log)
+    {
+        logptr = list_entry(pos, udi_log_t, q);
+        list_del(pos);
+        kfree(logptr);
+    }
+    up(&ul_client->udi_sem);
+
+    return 0;
+} /* ul_deregister_client() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  logging_handler
+ *
+ *      This function is registered with the driver core.
+ *      It is called every time a UniFi HIP Signal is sent. It iterates over
+ *      the list of processes interested in receiving log events and
+ *      delivers the events to them.
+ *
+ *  Arguments:
+ *      ospriv      Pointer to driver's private data.
+ *      sigdata     Pointer to the packed signal buffer.
+ *      signal_len  Length of the packed signal.
+ *      bulkdata    Pointer to the signal's bulk data.
+ *      dir         Direction of the signal
+ *                  0 = from-host
+ *                  1 = to-host
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+logging_handler(void *ospriv,
+                CsrUint8 *sigdata, CsrUint32 signal_len,
+                const bulk_data_param_t *bulkdata,
+                enum udi_log_direction direction)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+    ul_client_t *client;
+    int dir;
+
+    dir = (direction == UDI_LOG_FROM_HOST) ? UDI_FROM_HOST : UDI_TO_HOST;
+
+    down(&priv->udi_logging_mutex);
+    client = priv->logging_client;
+    if (client != NULL) {
+        client->event_hook(client, sigdata, signal_len,
+                           bulkdata, dir);
+    }
+    up(&priv->udi_logging_mutex);
+
+} /* logging_handler() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  ul_log_config_ind
+ *
+ *      This function uses the client's register callback
+ *      to indicate configuration information e.g core errors.
+ *
+ *  Arguments:
+ *      priv        Pointer to driver's private data.
+ *      conf_param  Pointer to the configuration data.
+ *      len         Length of the configuration data.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+ul_log_config_ind(unifi_priv_t *priv, u8 *conf_param, int len)
+{
+#ifdef CSR_SUPPORT_SME
+    if (priv->smepriv == NULL)
+    {
+        return;
+    }
+    if ((CONFIG_IND_ERROR == (*conf_param)) && (priv->wifi_on_state == wifi_on_in_progress)) {
+        unifi_notice(priv, "ul_log_config_ind: wifi on in progress, suppress error\n");
+    } else {
+        /* wifi_off_ind (error or exit) */
+        CsrWifiRouterCtrlWifiOffIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0, (CsrWifiRouterCtrlControlIndication)(*conf_param));
+    }
+
+#else
+    bulk_data_param_t bulkdata;
+
+    /*
+     * If someone killed unifi_managed before the driver was unloaded
+     * the g_drvpriv pointer is going to be NULL. In this case it is
+     * safe to assume that there is no client to get the indication.
+     */
+    if (!priv) {
+        unifi_notice(NULL, "uf_sme_event_ind: NULL priv\n");
+        return;
+    }
+
+    /* Create a null bulkdata structure. */
+    bulkdata.d[0].data_length = 0;
+    bulkdata.d[1].data_length = 0;
+
+    sme_native_log_event(priv->sme_cli, conf_param, sizeof(CsrUint8),
+                         &bulkdata, UDI_CONFIG_IND);
+
+#endif /* CSR_SUPPORT_SME */
+
+} /* ul_log_config_ind */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  free_bulkdata_buffers
+ *
+ *      Free the bulkdata buffers e.g. after a failed unifi_send_signal().
+ *
+ *  Arguments:
+ *      priv        Pointer to device private struct
+ *      bulkdata    Pointer to bulkdata parameter table
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void
+free_bulkdata_buffers(unifi_priv_t *priv, bulk_data_param_t *bulkdata)
+{
+    int i;
+
+    if (bulkdata) {
+        for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; ++i) {
+            if (bulkdata->d[i].data_length != 0) {
+                unifi_net_data_free(priv, (bulk_data_desc_t *)(&bulkdata->d[i]));
+                /* data_length is now 0 */
+            }
+        }
+    }
+
+} /* free_bulkdata_buffers */
+
+static int
+_align_bulk_data_buffers(unifi_priv_t *priv, CsrUint8 *signal,
+                         bulk_data_param_t *bulkdata)
+{
+    unsigned int i;
+
+    if ((bulkdata == NULL) || (CSR_WIFI_ALIGN_BYTES == 0)) {
+        return 0;
+    }
+
+    for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)
+    {
+        struct sk_buff *skb;
+        /*
+        * The following complex casting is in place in order to eliminate 64-bit compilation warning
+        * "cast to/from pointer from/to integer of different size"
+        */
+        CsrUint32 align_offset = (CsrUint32)(long)(bulkdata->d[i].os_data_ptr) & (CSR_WIFI_ALIGN_BYTES-1);
+        if (align_offset)
+        {
+            skb = (struct sk_buff*)bulkdata->d[i].os_net_buf_ptr;
+            if (skb == NULL) {
+                unifi_warning(priv,
+                              "_align_bulk_data_buffers: Align offset found (%d) but skb is NULL!\n",
+                              align_offset);
+                return -EINVAL;
+            }
+            if (bulkdata->d[i].data_length == 0) {
+                unifi_warning(priv,
+                              "_align_bulk_data_buffers: Align offset found (%d) but length is zero\n",
+                              align_offset);
+                return CSR_RESULT_SUCCESS;
+            }
+            unifi_trace(priv, UDBG5,
+                        "Align f-h buffer (0x%p) by %d bytes (skb->data: 0x%p)\n",
+                        bulkdata->d[i].os_data_ptr, align_offset, skb->data);
+
+
+            /* Check if there is enough headroom... */
+            if (unlikely(skb_headroom(skb) < align_offset))
+            {
+                struct sk_buff *tmp = skb;
+
+                unifi_trace(priv, UDBG5, "Headroom not enough - realloc it\n");
+                skb = skb_realloc_headroom(skb, align_offset);
+                if (skb == NULL) {
+                    unifi_error(priv,
+                                "_align_bulk_data_buffers: skb_realloc_headroom failed - signal is dropped\n");
+                    return -EFAULT;
+                }
+                /* Free the old bulk data only if allocation succeeds */
+                kfree_skb(tmp);
+                /* Bulkdata needs to point to the new skb */
+                bulkdata->d[i].os_net_buf_ptr = (const unsigned char*)skb;
+                bulkdata->d[i].os_data_ptr = (const void*)skb->data;
+            }
+            /* ... before pushing the data to the right alignment offset */
+            skb_push(skb, align_offset);
+
+        }
+        /* The direction bit is zero for the from-host */
+        signal[SIZEOF_SIGNAL_HEADER + (i * SIZEOF_DATAREF) + 1] = align_offset;
+
+    }
+    return 0;
+} /* _align_bulk_data_buffers() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  ul_send_signal_unpacked
+ *
+ *      This function sends a host formatted signal to unifi.
+ *
+ *  Arguments:
+ *      priv        Pointer to driver's private data.
+ *      sigptr      Pointer to the signal.
+ *      bulkdata    Pointer to the signal's bulk data.
+ *
+ *  Returns:
+ *      O on success, error code otherwise.
+ *
+ *  Notes:
+ *  The signals have to be sent in the format described in the host interface
+ *  specification, i.e wire formatted. Certain clients use the host formatted
+ *  structures. The write_pack() transforms the host formatted signal
+ *  into the wired formatted signal. The code is in the core, since the signals
+ *  are defined therefore binded to the host interface specification.
+ * ---------------------------------------------------------------------------
+ */
+int
+ul_send_signal_unpacked(unifi_priv_t *priv, CSR_SIGNAL *sigptr,
+                        bulk_data_param_t *bulkdata)
+{
+    CsrUint8 sigbuf[UNIFI_PACKED_SIGBUF_SIZE];
+    CsrUint16 packed_siglen;
+    CsrResult csrResult;
+    unsigned long lock_flags;
+    int r;
+#ifdef CSR_SUPPORT_SME
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[0];
+    CsrUint32 alignOffset = 0;
+#endif
+
+
+    csrResult = write_pack(sigptr, sigbuf, &packed_siglen);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "Malformed HIP signal in ul_send_signal_unpacked()\n");
+        return CsrHipResultToStatus(csrResult);
+    }
+#ifdef CSR_SUPPORT_SME
+    if (bulkdata != NULL){
+        alignOffset = (CsrUint32)(long)(bulkdata->d[0].os_data_ptr) & (CSR_WIFI_ALIGN_BYTES-1);
+
+    }
+#endif
+    r = _align_bulk_data_buffers(priv, sigbuf, (bulk_data_param_t*)bulkdata);
+    if (r) {
+        return r;
+    }
+
+    spin_lock_irqsave(&priv->send_signal_lock, lock_flags);
+    csrResult = unifi_send_signal(priv->card, sigbuf, packed_siglen, bulkdata);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+  /*      free_bulkdata_buffers(priv, (bulk_data_param_t *)bulkdata); */
+        spin_unlock_irqrestore(&priv->send_signal_lock, lock_flags);
+        return CsrHipResultToStatus(csrResult);
+    }
+#ifdef CSR_SUPPORT_SME
+    if (sigptr->SignalPrimitiveHeader.SignalId == CSR_MA_PACKET_REQUEST_ID) {
+        if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+           interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+
+            uf_store_directed_ma_packet_referenece(priv, bulkdata, sigptr,alignOffset);
+
+        }
+    }
+#endif
+
+    spin_unlock_irqrestore(&priv->send_signal_lock, lock_flags);
+
+    return 0;
+} /* ul_send_signal_unpacked() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  reset_driver_status
+ *
+ *      This function is called from ul_send_signal_raw() when it detects
+ *      that the SME has sent a MLME-RESET request.
+ *
+ *  Arguments:
+ *      priv        Pointer to device private struct
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+static void
+reset_driver_status(unifi_priv_t *priv)
+{
+    priv->sta_wmm_capabilities = 0;
+#ifdef CSR_NATIVE_LINUX
+#ifdef CSR_SUPPORT_WEXT
+    priv->wext_conf.flag_associated = 0;
+    priv->wext_conf.block_controlled_port = CSR_WIFI_ROUTER_PORT_ACTION_8021X_PORT_OPEN;
+    priv->wext_conf.bss_wmm_capabilities = 0;
+    priv->wext_conf.disable_join_on_ssid_set = 0;
+#endif
+#endif
+} /* reset_driver_status() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  ul_send_signal_raw
+ *
+ *      This function sends a wire formatted data signal to unifi.
+ *
+ *  Arguments:
+ *      priv        Pointer to driver's private data.
+ *      sigptr      Pointer to the signal.
+ *      siglen      Length of the signal.
+ *      bulkdata    Pointer to the signal's bulk data.
+ *
+ *  Returns:
+ *      O on success, error code otherwise.
+ * ---------------------------------------------------------------------------
+ */
+int
+ul_send_signal_raw(unifi_priv_t *priv, unsigned char *sigptr, int siglen,
+                   bulk_data_param_t *bulkdata)
+{
+    CsrResult csrResult;
+    unsigned long lock_flags;
+    int r;
+
+    /*
+     * Make sure that the signal is updated with the bulk data
+     * alignment for DMA.
+     */
+    r = _align_bulk_data_buffers(priv, (CsrUint8*)sigptr, bulkdata);
+    if (r) {
+        return r;
+    }
+
+    spin_lock_irqsave(&priv->send_signal_lock, lock_flags);
+    csrResult = unifi_send_signal(priv->card, sigptr, siglen, bulkdata);
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        free_bulkdata_buffers(priv, bulkdata);
+        spin_unlock_irqrestore(&priv->send_signal_lock, lock_flags);
+        return CsrHipResultToStatus(csrResult);
+    }
+    spin_unlock_irqrestore(&priv->send_signal_lock, lock_flags);
+
+    /*
+     * Since this is use by unicli, if we get an MLME reset request
+     * we need to initialize a few status parameters
+     * that the driver uses to make decisions.
+     */
+    if (GET_SIGNAL_ID(sigptr) == CSR_MLME_RESET_REQUEST_ID) {
+        reset_driver_status(priv);
+    }
+
+    return 0;
+} /* ul_send_signal_raw() */
+
+
--- /dev/null
+++ b/drivers/staging/csr/unifi_clients.h
@@ -0,0 +1,129 @@
+/*
+ *****************************************************************************
+ *
+ * FILE : unifi_clients.h
+ *
+ * PURPOSE : Private header file for unifi clients.
+ *
+ *           UDI = UniFi Debug Interface
+ *
+ * Copyright (C) 2005-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ *****************************************************************************
+ */
+#ifndef __LINUX_UNIFI_CLIENTS_H__
+#define __LINUX_UNIFI_CLIENTS_H__ 1
+
+#include <linux/kernel.h>
+
+#define MAX_UDI_CLIENTS 8
+
+/* The start of the range of process ids allocated for ul clients */
+#define UDI_SENDER_ID_BASE      0xC000
+#define UDI_SENDER_ID_SHIFT     8
+
+
+/* Structure to hold a UDI logged signal */
+typedef struct {
+
+    /* List link structure */
+    struct list_head q;
+
+    /* The message that will be passed to the user app */
+    udi_msg_t msg;
+
+    /* Signal body and data follow */
+
+} udi_log_t;
+
+
+
+typedef struct ul_client ul_client_t;
+
+typedef void (*udi_event_t)(ul_client_t *client,
+                            const u8 *sigdata, int signal_len,
+                            const bulk_data_param_t *bulkdata,
+                            int dir);
+
+void logging_handler(void *ospriv,
+                     CsrUint8 *sigdata, CsrUint32 signal_len,
+                     const bulk_data_param_t *bulkdata,
+                     enum udi_log_direction direction);
+
+
+/*
+ * Structure describing a bulk data slot.
+ * The length field is used to indicate empty/occupied state.
+ */
+typedef struct _bulk_data
+{
+    unsigned char ptr[2000];
+    unsigned int length;
+} bulk_data_t;
+
+
+struct ul_client {
+    /* Index of this client in the ul_clients array. */
+    int client_id;
+
+    /* Index of UniFi device to which this client is attached. */
+    int instance;
+
+    /* Flag to say whether this client has been enabled. */
+    int udi_enabled;
+
+    /* Value to use in signal->SenderProcessId */
+    int sender_id;
+
+    /* Configuration flags, e.g blocking, logging, etc. */
+    unsigned int configuration;
+
+    udi_event_t event_hook;
+
+    /* A list to hold signals received from UniFi for reading by read() */
+    struct list_head udi_log;
+
+    /* Semaphore to protect the udi_log list */
+    struct semaphore udi_sem;
+
+    /*
+     * Linux waitqueue to support blocking read and poll.
+     * Logging clients should wait on udi_log. while
+     * blocking clients should wait on wake_up_wq.
+     */
+    wait_queue_head_t udi_wq;
+    CSR_SIGNAL* reply_signal;
+    bulk_data_t* reply_bulkdata[UNIFI_MAX_DATA_REFERENCES];
+
+    CsrUint16 signal_filter[SIG_FILTER_SIZE];
+
+
+    /* ------------------------------------------------------------------- */
+    /* Code below here is used by the sme_native configuration only */
+
+    /* Flag to wake up blocking clients waiting on udi_wq. */
+    int wake_up_wq_id;
+
+    /*
+     * A 0x00 - 0x0F mask to apply in signal->SenderProcessId.
+     * Every time we do a blocking mlme request we increase this value.
+     * The mlme_wait_for_reply() will wait for this sequence number.
+     * Only the MLME blocking functions update this field.
+     */
+    unsigned char seq_no;
+
+    /*
+     * A 0x00 - 0x0F counter, containing the sequence number of
+     * the signal that this client has last received.
+     * Only the MLME blocking functions update this field.
+     */
+    unsigned char wake_seq_no;
+
+    unifiio_snap_filter_t snap_filter;
+}; /* struct ul_client */
+
+
+#endif /* __LINUX_UNIFI_CLIENTS_H__ */
--- /dev/null
+++ b/drivers/staging/csr/unifi_config.h
@@ -0,0 +1,34 @@
+/*
+ * ---------------------------------------------------------------------------
+ *
+ * FILE: unifi_config.h
+ *
+ * PURPOSE:
+ *      This header file provides parameters that configure the operation
+ *      of the driver.
+ *
+ * Copyright (C) 2006-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#ifndef __UNIFI_CONFIG_H__
+#define __UNIFI_CONFIG_H__ 1
+
+/*
+ * Override for the SDIO function block size on this host. When byte mode CMD53s
+ * are not used/supported by the SD host controller, transfers are padded up to
+ * the next block boundary. The 512-byte default on UF6xxx wastes too much space
+ * on the chip, so the block size is reduced to support this configuration.
+ */
+#define CSR_WIFI_HIP_SDIO_BLOCK_SIZE  64
+
+/* Define the number of mini-coredump buffers to allocate at startup. These are
+ * used to record chip status for the last n unexpected resets.
+ */
+#define CSR_WIFI_HIP_NUM_COREDUMP_BUFFERS  5
+
+
+#endif /* __UNIFI_CONFIG_H__ */
--- /dev/null
+++ b/drivers/staging/csr/unifi_dbg.c
@@ -0,0 +1,110 @@
+/*
+ * ***************************************************************************
+ *  FILE:     unifi_dbg.c
+ *
+ *  PURPOSE:
+ *      Handle debug signals received from UniFi.
+ *
+ * Copyright (C) 2007-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ***************************************************************************
+ */
+#include "unifi_priv.h"
+
+/*
+ * ---------------------------------------------------------------------------
+ *  debug_string_indication
+ *  debug_word16_indication
+ *
+ *      Handlers for debug indications.
+ *
+ *  Arguments:
+ *      priv            Pointer to private context structure.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+debug_string_indication(unifi_priv_t *priv, const unsigned char *extra, unsigned int extralen)
+{
+    const unsigned int maxlen = sizeof(priv->last_debug_string) - 1;
+
+    if (extralen > maxlen) {
+        extralen = maxlen;
+    }
+
+    strncpy(priv->last_debug_string, extra, extralen);
+
+    /* Make sure the string is terminated */
+    priv->last_debug_string[extralen] = '\0';
+
+    unifi_info(priv, "unifi debug: %s\n", priv->last_debug_string);
+
+} /* debug_string_indication() */
+
+
+
+void
+debug_word16_indication(unifi_priv_t *priv, const CSR_SIGNAL *sigptr)
+{
+    int i;
+
+    if (priv == NULL) {
+        unifi_info(priv, "Priv is NULL\n");
+        return;
+    }
+
+    for (i = 0; i < 16; i++) {
+        priv->last_debug_word16[i] =
+                sigptr->u.DebugWord16Indication.DebugWords[i];
+    }
+
+    if (priv->last_debug_word16[0] == 0xFA11) {
+        unsigned long ts;
+        ts = (priv->last_debug_word16[6] << 16) | priv->last_debug_word16[5];
+        unifi_info(priv, " %10lu: %s fault %04x, arg %04x (x%d)\n",
+                   ts,
+                   priv->last_debug_word16[3] == 0x8000 ? "MAC" :
+                   priv->last_debug_word16[3] == 0x4000 ? "PHY" :
+                   "???",
+                   priv->last_debug_word16[1],
+                   priv->last_debug_word16[2],
+                   priv->last_debug_word16[4]);
+    }
+    else if (priv->last_debug_word16[0] != 0xDBAC)
+        /* suppress SDL Trace output (note: still available to unicli). */
+    {
+        unifi_info(priv, "unifi debug: %04X %04X %04X %04X %04X %04X %04X %04X\n",
+                   priv->last_debug_word16[0], priv->last_debug_word16[1],
+                   priv->last_debug_word16[2], priv->last_debug_word16[3],
+                   priv->last_debug_word16[4], priv->last_debug_word16[5],
+                   priv->last_debug_word16[6], priv->last_debug_word16[7]);
+        unifi_info(priv, "             %04X %04X %04X %04X %04X %04X %04X %04X\n",
+                   priv->last_debug_word16[8], priv->last_debug_word16[9],
+                   priv->last_debug_word16[10], priv->last_debug_word16[11],
+                   priv->last_debug_word16[12], priv->last_debug_word16[13],
+                   priv->last_debug_word16[14], priv->last_debug_word16[15]);
+    }
+
+} /* debug_word16_indication() */
+
+
+void
+debug_generic_indication(unifi_priv_t *priv, const CSR_SIGNAL *sigptr)
+{
+    unifi_info(priv, "debug: %04X %04X %04X %04X %04X %04X %04X %04X\n",
+               sigptr->u.DebugGenericIndication.DebugWords[0],
+               sigptr->u.DebugGenericIndication.DebugWords[1],
+               sigptr->u.DebugGenericIndication.DebugWords[2],
+               sigptr->u.DebugGenericIndication.DebugWords[3],
+               sigptr->u.DebugGenericIndication.DebugWords[4],
+               sigptr->u.DebugGenericIndication.DebugWords[5],
+               sigptr->u.DebugGenericIndication.DebugWords[6],
+               sigptr->u.DebugGenericIndication.DebugWords[7]);
+
+} /* debug_generic_indication() */
+
--- /dev/null
+++ b/drivers/staging/csr/unifi_event.c
@@ -0,0 +1,794 @@
+/*
+ * ***************************************************************************
+ *  FILE:     unifi_event.c
+ *
+ *  PURPOSE:
+ *      Process the signals received by UniFi.
+ *      It is part of the porting exercise.
+ *
+ * Copyright (C) 2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ***************************************************************************
+ */
+
+
+/*
+ * Porting notes:
+ * The implementation of unifi_receive_event() in Linux is fairly complicated.
+ * The linux driver support multiple userspace applications and several
+ * build configurations, so the received signals are processed by different
+ * processes and multiple times.
+ * In a simple implementation, this function needs to deliver:
+ * - The MLME-UNITDATA.ind signals to the Rx data plane and to the Traffic
+ *   Analysis using unifi_ta_sample().
+ * - The MLME-UNITDATA-STATUS.ind signals to the Tx data plane.
+ * - All the other signals to the SME using unifi_sys_hip_ind().
+ */
+
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_conversions.h"
+#include "unifi_priv.h"
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  send_to_client
+ *
+ *      Helper for unifi_receive_event.
+ *
+ *      This function forwards a signal to one client.
+ *
+ *  Arguments:
+ *      priv        Pointer to driver's private data.
+ *      client      Pointer to the client structure.
+ *      receiver_id The reciever id of the signal.
+ *      sigdata     Pointer to the packed signal buffer.
+ *      siglen      Length of the packed signal.
+ *      bulkdata    Pointer to the signal's bulk data.
+ *
+ *  Returns:
+ *      None.
+ *
+ * ---------------------------------------------------------------------------
+ */
+static void send_to_client(unifi_priv_t *priv, ul_client_t *client,
+        int receiver_id,
+        unsigned char *sigdata, int siglen,
+        const bulk_data_param_t *bulkdata)
+{
+    if (client && client->event_hook) {
+        /*unifi_trace(priv, UDBG3,
+                "Receive: client %d, (s:0x%X, r:0x%X) - Signal 0x%.4X \n",
+                client->client_id, client->sender_id, receiver_id,
+                CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata));*/
+
+        client->event_hook(client, sigdata, siglen, bulkdata, UDI_TO_HOST);
+    }
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  process_pkt_data_ind
+ *
+ *      Dispatcher for received signals.
+ *
+ *      This function receives the 'to host' signals and forwards
+ *      them to the unifi linux clients.
+ *
+ *  Arguments:
+ *      priv         Context
+ *      sigdata      Pointer to the packed signal buffer(Its in form of MA-PACKET.ind).
+ *      bulkdata     Pointer to signal's bulkdata
+ *      freeBulkData Pointer to a flag which gets set if the bulkdata needs to
+ *                   be freed after calling the logging handlers. If it is not
+ *                   set the bulkdata must be freed by the MLME handler or
+ *                   passed to the network stack.
+ *  Returns:
+ *      TRUE if the packet should be routed to the SME etc.
+ *      FALSE if the packet is for the driver or network stack
+ * ---------------------------------------------------------------------------
+ */
+static CsrBool check_routing_pkt_data_ind(unifi_priv_t *priv,
+        CsrUint8 *sigdata,
+        const bulk_data_param_t* bulkdata,
+        CsrBool *freeBulkData,
+        netInterface_priv_t *interfacePriv)
+{
+    CsrUint16  frmCtrl, receptionStatus, frmCtrlSubType;
+    CsrUint8 *macHdrLocation;
+    CsrUint8 interfaceTag;
+    CsrBool isDataFrame;
+    CsrBool isProtocolVerInvalid = FALSE;
+    CsrBool isDataFrameSubTypeNoData = FALSE;
+
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+    static const CsrUint8 wapiProtocolIdSNAPHeader[] = {0x88,0xb4};
+    static const CsrUint8 wapiProtocolIdSNAPHeaderOffset = 6;
+    CsrUint8 *destAddr;
+    CsrUint8 *srcAddr;
+    CsrBool isUnicastPkt = FALSE;
+
+    CsrUint8 llcSnapHeaderOffset = 0;
+
+    destAddr = (CsrUint8 *) bulkdata->d[0].os_data_ptr + MAC_HEADER_ADDR1_OFFSET;
+    srcAddr  = (CsrUint8 *) bulkdata->d[0].os_data_ptr + MAC_HEADER_ADDR2_OFFSET;
+
+    /*Individual/Group bit - Bit 0 of first byte*/
+    isUnicastPkt = (!(destAddr[0] & 0x01)) ? TRUE : FALSE;
+#endif
+
+#define CSR_WIFI_MA_PKT_IND_RECEPTION_STATUS_OFFSET    sizeof(CSR_SIGNAL_PRIMITIVE_HEADER) + 22
+
+    *freeBulkData = FALSE;
+
+    /* Fetch the MAC header location from  MA_PKT_IND packet */
+    macHdrLocation = (CsrUint8 *) bulkdata->d[0].os_data_ptr;
+    /* Fetch the Frame Control value from  MAC header */
+    frmCtrl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(macHdrLocation);
+
+    /* Pull out interface tag from virtual interface identifier */
+    interfaceTag = (CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata + 14)) & 0xff;
+
+    /* check for MIC failure before processing the signal */
+    receptionStatus = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata + CSR_WIFI_MA_PKT_IND_RECEPTION_STATUS_OFFSET);
+
+    /* To discard any spurious MIC failures that could be reported by the firmware */
+    isDataFrame = ((frmCtrl & IEEE80211_FC_TYPE_MASK) == (IEEE802_11_FC_TYPE_DATA & IEEE80211_FC_TYPE_MASK)) ? TRUE : FALSE;
+    /* 0x00 is the only valid protocol version*/
+    isProtocolVerInvalid = (frmCtrl & IEEE80211_FC_PROTO_VERSION_MASK) ? TRUE : FALSE;
+    frmCtrlSubType = (frmCtrl & IEEE80211_FC_SUBTYPE_MASK) >> FRAME_CONTROL_SUBTYPE_FIELD_OFFSET;
+    /*Exclude the no data & reserved sub-types from MIC failure processing*/
+    isDataFrameSubTypeNoData = (((frmCtrlSubType>0x03)&&(frmCtrlSubType<0x08)) || (frmCtrlSubType>0x0B)) ? TRUE : FALSE;
+    if ((receptionStatus == CSR_MICHAEL_MIC_ERROR) &&
+        ((!isDataFrame) || isProtocolVerInvalid || (isDataFrame && isDataFrameSubTypeNoData))) {
+        /* Currently MIC errors are discarded for frames other than data frames. This might need changing when we start
+         * supporting 802.11w (Protected Management frames)
+         */
+        *freeBulkData = TRUE;
+        unifi_trace(priv, UDBG4, "Discarding this frame and ignoring the MIC failure as this is a garbage/non-data/no data frame\n");
+        return FALSE;
+     }
+
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+
+    if (receptionStatus == CSR_MICHAEL_MIC_ERROR) {
+
+        if (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_STA) {
+
+            /* If this MIC ERROR reported by the firmware is either for
+             *    [1] a WAPI Multicast Packet and the Multicast filter has NOT been set (It is set only when group key index (MSKID) = 1 in Group Rekeying)   OR
+             *    [2] a WAPI Unicast Packet and either the CONTROL PORT is open or the WAPI Unicast filter or filter(s) is NOT set
+             * then report a MIC FAILURE indication to the SME.
+             */
+            if ((priv->wapi_multicast_filter == 0) || isUnicastPkt) {
+
+                /*Discard the frame*/
+                *freeBulkData = TRUE;
+                unifi_trace(priv, UDBG4, "Discarding the contents of the frame with MIC failure \n");
+
+                if (isUnicastPkt &&
+                    ((uf_sme_port_state(priv,srcAddr,UF_CONTROLLED_PORT_Q,interfaceTag) != CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN)||
+                    (priv->wapi_unicast_filter) ||
+                    (priv->wapi_unicast_queued_pkt_filter))) {
+
+                    /* Workaround to handle MIC failures reported by the firmware for encrypted packets from the AP
+                     * while we are in the process of re-association induced by unsupported WAPI Unicast key index
+                     *             - Discard the packets with MIC failures "until" we have
+                     *               a. negotiated a key,
+                     *               b. opened the CONTROL PORT and
+                     *               c. the AP has started using the new key
+                     */
+                    unifi_trace(priv, UDBG4, "Ignoring the MIC failure as either a. CONTROL PORT isn't OPEN or b. Unicast filter is set or c. WAPI AP using old key for buffered pkts\n");
+
+                    /*Ignore this MIC failure*/
+                    return FALSE;
+
+                }/*WAPI re-key specific workaround*/
+
+                unifi_trace(priv, UDBG6, "check_routing_pkt_data_ind - MIC FAILURE : interfaceTag %x Src Addr %x:%x:%x:%x:%x:%x\n",
+                            interfaceTag, srcAddr[0], srcAddr[1], srcAddr[2], srcAddr[3], srcAddr[4], srcAddr[5]);
+                unifi_trace(priv, UDBG6, "check_routing_pkt_data_ind - MIC FAILURE : Dest Addr %x:%x:%x:%x:%x:%x\n",
+                            destAddr[0], destAddr[1], destAddr[2], destAddr[3], destAddr[4], destAddr[5]);
+                unifi_trace(priv, UDBG6, "check_routing_pkt_data_ind - MIC FAILURE : Control Port State - 0x%.4X \n",
+                            uf_sme_port_state(priv,srcAddr,UF_CONTROLLED_PORT_Q,interfaceTag));
+
+                unifi_error(priv, "MIC failure in %s\n", __FUNCTION__);
+
+                /*Report the MIC failure to the SME*/
+                return TRUE;
+            }
+        }/* STA mode */
+        else {
+            /* Its AP Mode . Just Return */
+            *freeBulkData = TRUE;
+            unifi_error(priv, "MIC failure in %s\n", __FUNCTION__);
+            return TRUE;
+         } /* AP mode */
+    }/* MIC error */
+#else
+    if (receptionStatus == CSR_MICHAEL_MIC_ERROR) {
+        *freeBulkData = TRUE;
+        unifi_error(priv, "MIC failure in %s\n", __FUNCTION__);
+        return TRUE;
+    }
+#endif /*CSR_WIFI_SECURITY_WAPI_ENABLE*/
+
+    unifi_trace(priv, UDBG4, "frmCtrl = 0x%04x %s\n",
+                frmCtrl,
+                (((frmCtrl & 0x000c)>>FRAME_CONTROL_TYPE_FIELD_OFFSET) == IEEE802_11_FRAMETYPE_MANAGEMENT) ?
+                    "Mgt" : "Ctrl/Data");
+
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+    /* To ignore MIC failures reported due to the WAPI AP using the old key for queued packets before
+     * starting to use the new key negotiated as part of unicast re-keying
+     */
+    if (isUnicastPkt &&
+        (receptionStatus == CSR_RX_SUCCESS) &&
+        (priv->wapi_unicast_queued_pkt_filter==1)) {
+
+        unifi_trace(priv, UDBG6, "check_routing_pkt_data_ind(): WAPI unicast pkt received when the (wapi_unicast_queued_pkt_filter) is set\n");
+
+        if (isDataFrame) {
+            switch(frmCtrl & IEEE80211_FC_SUBTYPE_MASK) {
+                case IEEE802_11_FC_TYPE_QOS_DATA & IEEE80211_FC_SUBTYPE_MASK:
+                    llcSnapHeaderOffset = MAC_HEADER_SIZE + 2;
+                    break;
+                case IEEE802_11_FC_TYPE_QOS_NULL & IEEE80211_FC_SUBTYPE_MASK:
+                case IEEE802_11_FC_TYPE_NULL & IEEE80211_FC_SUBTYPE_MASK:
+                    break;
+                default:
+                    llcSnapHeaderOffset = MAC_HEADER_SIZE;
+            }
+        }
+
+        if (llcSnapHeaderOffset > 0) {
+        	/* QoS data or Data */
+            unifi_trace(priv, UDBG6, "check_routing_pkt_data_ind(): SNAP header found & its offset %d\n",llcSnapHeaderOffset);
+            if (memcmp((CsrUint8 *)(bulkdata->d[0].os_data_ptr+llcSnapHeaderOffset+wapiProtocolIdSNAPHeaderOffset),
+                       wapiProtocolIdSNAPHeader,sizeof(wapiProtocolIdSNAPHeader))) {
+
+            	unifi_trace(priv, UDBG6, "check_routing_pkt_data_ind(): This is a data & NOT a WAI protocol packet\n");
+                /* On the first unicast data pkt that is decrypted successfully after re-keying, reset the filter */
+                priv->wapi_unicast_queued_pkt_filter = 0;
+                unifi_trace(priv, UDBG4, "check_routing_pkt_data_ind(): WAPI AP has started using the new unicast key, no more MIC failures expected (reset filter)\n");
+            }
+            else {
+                unifi_trace(priv, UDBG6, "check_routing_pkt_data_ind(): WAPI - This is a WAI protocol packet\n");
+            }
+        }
+	}
+#endif
+
+
+    switch ((frmCtrl & 0x000c)>>FRAME_CONTROL_TYPE_FIELD_OFFSET) {
+        case IEEE802_11_FRAMETYPE_MANAGEMENT:
+            *freeBulkData = TRUE;       /* Free (after SME handler copies it) */
+
+            /* In P2P device mode, filter the legacy AP beacons here */
+            if((interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2P)&&\
+               ((CSR_WIFI_80211_GET_FRAME_SUBTYPE(macHdrLocation)) == CSR_WIFI_80211_FRAME_SUBTYPE_BEACON)){
+
+                CsrUint8 *pSsid, *pSsidLen;
+                static CsrUint8 P2PWildCardSsid[CSR_WIFI_P2P_WILDCARD_SSID_LENGTH] = {'D', 'I', 'R', 'E', 'C', 'T', '-'};
+
+                pSsidLen = macHdrLocation + MAC_HEADER_SIZE + CSR_WIFI_BEACON_FIXED_LENGTH;
+                pSsid = pSsidLen + 2;
+
+                if(*(pSsidLen + 1) >= CSR_WIFI_P2P_WILDCARD_SSID_LENGTH){
+                    if(memcmp(pSsid, P2PWildCardSsid, CSR_WIFI_P2P_WILDCARD_SSID_LENGTH) == 0){
+                        unifi_trace(priv, UDBG6, "Received a P2P Beacon, pass it to SME\n");
+                        return TRUE;
+                    }
+                }
+                unifi_trace(priv, UDBG6, "Received a Legacy AP beacon in P2P mode, drop it\n");
+                return FALSE;
+            }
+            return TRUE;                /* Route to SME */
+        case IEEE802_11_FRAMETYPE_DATA:
+        case IEEE802_11_FRAMETYPE_CONTROL:
+            *freeBulkData = FALSE;      /* Network stack or MLME handler frees */
+            return FALSE;
+        default:
+            unifi_error(priv, "Unhandled frame type %04x\n", frmCtrl);
+            *freeBulkData = TRUE;       /* Not interested, but must free it */
+            return FALSE;
+    }
+}
+#ifdef CSR_WIFI_RX_PATH_SPLIT
+static CsrBool signal_buffer_is_full(unifi_priv_t* priv)
+{
+    return (((priv->rxSignalBuffer.writePointer + 1)% priv->rxSignalBuffer.size) == (priv->rxSignalBuffer.readPointer));
+
+}
+#endif
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_receive_event
+ *
+ *      Dispatcher for received signals.
+ *
+ *      This function receives the 'to host' signals and forwards
+ *      them to the unifi linux clients.
+ *
+ *  Arguments:
+ *      ospriv      Pointer to driver's private data.
+ *      sigdata     Pointer to the packed signal buffer.
+ *      siglen      Length of the packed signal.
+ *      bulkdata    Pointer to the signal's bulk data.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *  The signals are received in the format described in the host interface
+ *  specification, i.e wire formatted. Certain clients use the same format
+ *  to interpret them and other clients use the host formatted structures.
+ *  Each client has to call read_unpack_signal() to transform the wire
+ *  formatted signal into the host formatted signal, if necessary.
+ *  The code is in the core, since the signals are defined therefore
+ *  binded to the host interface specification.
+ * ---------------------------------------------------------------------------
+ */
+
+
+void
+unifi_receive_event(void *ospriv,
+        CsrUint8 *sigdata, CsrUint32 siglen,
+        const bulk_data_param_t *bulkdata)
+{
+#ifdef CSR_WIFI_RX_PATH_SPLIT
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+    CsrUint8 writePointer;
+    int i;
+    rx_buff_struct_t * rx_buff;
+    func_enter();
+
+    unifi_trace(priv, UDBG5, "unifi_receive_event: "
+            "%04x %04x %04x %04x %04x %04x %04x %04x (%d)\n",
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*0) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*1) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*2) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*3) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*4) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*5) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*6) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*7) & 0xFFFF, siglen);
+    if(signal_buffer_is_full(priv)) {
+        unifi_error(priv,"TO HOST signal queue FULL dropping the PDU\n");
+        for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+            if (bulkdata->d[i].data_length != 0) {
+                unifi_net_data_free(priv, (void *)&bulkdata->d[i]);
+            }
+        }
+        return;
+    }
+    writePointer = priv->rxSignalBuffer.writePointer;
+    rx_buff = &priv->rxSignalBuffer.rx_buff[writePointer];
+    memcpy(rx_buff->bufptr,sigdata,siglen);
+    rx_buff->sig_len = siglen;
+    rx_buff->data_ptrs = *bulkdata;
+    writePointer++;
+    if(writePointer >= priv->rxSignalBuffer.size) {
+        writePointer =0;
+    }
+    unifi_trace(priv, UDBG4, "unifi_receive_event:writePtr = %d\n",priv->rxSignalBuffer.writePointer);
+    priv->rxSignalBuffer.writePointer = writePointer;
+
+#ifndef CSR_WIFI_RX_PATH_SPLIT_DONT_USE_WQ
+    queue_work(priv->rx_workqueue, &priv->rx_work_struct);
+#endif
+
+#else
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+    int i, receiver_id;
+    int client_id;
+    CsrInt16 signal_id;
+    CsrBool pktIndToSme = FALSE, freeBulkData = FALSE;
+
+    func_enter();
+
+    unifi_trace(priv, UDBG5, "unifi_receive_event: "
+            "%04x %04x %04x %04x %04x %04x %04x %04x (%d)\n",
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*0) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*1) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*2) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*3) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*4) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*5) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*6) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*7) & 0xFFFF, siglen);
+
+    receiver_id = CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)) & 0xFF00;
+    client_id = (receiver_id & 0x0F00) >> UDI_SENDER_ID_SHIFT;
+    signal_id = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata);
+
+
+
+    /* check for the type of frame received (checks for 802.11 management frames) */
+    if (signal_id == CSR_MA_PACKET_INDICATION_ID)
+    {
+        CsrUint8 interfaceTag;
+        netInterface_priv_t *interfacePriv;
+
+        /* Pull out interface tag from virtual interface identifier */
+        interfaceTag = (CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata + 14)) & 0xff;
+        interfacePriv = priv->interfacePriv[interfaceTag];
+
+        /* Update activity for this station in case of IBSS */
+#ifdef CSR_SUPPORT_SME
+
+        if (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_IBSS) {
+
+            CsrUint8 *saddr;
+            /* Fetch the source address from  mac header */
+            saddr = (CsrUint8 *) bulkdata->d[0].os_data_ptr + MAC_HEADER_ADDR2_OFFSET;
+            unifi_trace(priv, UDBG5,
+                                    "Updating sta activity in IBSS interfaceTag %x Src Addr %x:%x:%x:%x:%x:%x\n",
+                                    interfaceTag, saddr[0], saddr[1], saddr[2], saddr[3], saddr[4], saddr[5]);
+
+            uf_update_sta_activity(priv, interfaceTag, saddr);
+        }
+#endif
+
+        pktIndToSme = check_routing_pkt_data_ind(priv, sigdata, bulkdata, &freeBulkData, interfacePriv);
+
+        unifi_trace(priv, UDBG6, "RX: packet entry point to driver from HIP,pkt to SME ?(%s) \n", (pktIndToSme)? "YES":"NO");
+    }
+
+    if (pktIndToSme)
+    {
+        /* Management MA_PACKET_IND for SME */
+        if(sigdata != NULL && bulkdata != NULL){
+            send_to_client(priv, priv->sme_cli, receiver_id, sigdata, siglen, bulkdata);
+        }
+        else{
+            unifi_error(priv, "unifi_receive_event: sigdata or Bulkdata is NULL \n");
+        }
+#ifdef CSR_NATIVE_LINUX
+        send_to_client(priv, priv->wext_client,
+                receiver_id,
+                sigdata, siglen, bulkdata);
+#endif
+    }
+    else
+    {
+        /* Signals with ReceiverId==0 are also reported to SME / WEXT,
+         * unless they are data/control MA_PACKET_INDs or VIF_AVAILABILITY_INDs
+         */
+        if (!receiver_id) {
+            if(signal_id == CSR_MA_VIF_AVAILABILITY_INDICATION_ID)
+            {
+                uf_process_ma_vif_availibility_ind(priv, sigdata, siglen);
+            }
+            else if (signal_id != CSR_MA_PACKET_INDICATION_ID)
+            {
+                send_to_client(priv, priv->sme_cli, receiver_id, sigdata, siglen, bulkdata);
+#ifdef CSR_NATIVE_LINUX
+                send_to_client(priv, priv->wext_client,
+                        receiver_id,
+                        sigdata, siglen, bulkdata);
+#endif
+            }
+        }/*if  (receiver_id==0) */
+
+#ifdef CSR_SUPPORT_SME
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+       /* Send a WAPI Multicast Indication to SME if the filter has been set
+        * and this is a multicast data packet
+        */
+       if ((priv->wapi_multicast_filter == 1) && (signal_id == CSR_MA_PACKET_INDICATION_ID)) {
+            CSR_SIGNAL signal;
+            CsrUint8 *destAddr;
+            CsrResult res;
+            CsrUint16 interfaceTag = 0;
+
+            /* Check if it is a multicast packet from the destination address in the MAC header  */
+            res = read_unpack_signal(sigdata, &signal);
+            destAddr = (CsrUint8 *) bulkdata->d[0].os_data_ptr + MAC_HEADER_ADDR1_OFFSET;
+            if (res) {
+                unifi_error(priv, "Received unknown or corrupted signal.\n");
+                return;
+            }
+            /*Individual/Group bit - Bit 0 of first byte*/
+            if (destAddr[0] & 0x01) {
+                unifi_trace(priv, UDBG4, "Received a WAPI multicast packet ind\n");
+
+                CsrWifiRouterCtrlWapiMulticastIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0, interfaceTag, siglen, sigdata, bulkdata->d[0].data_length, (CsrUint8*)bulkdata->d[0].os_data_ptr);
+
+                for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+                    if (bulkdata->d[i].data_length != 0) {
+                        unifi_net_data_free(priv, (void *)&bulkdata->d[i]);
+                    }
+                }
+                func_exit();
+                return;
+            }
+        }
+#endif
+#endif
+
+        /* calls the registered clients handler callback func.
+         * netdev_mlme_event_handler is one of the registered handler used to route
+         * data packet to network stack or AMP/EAPOL related data to SME
+         */
+        /* The freeBulkData check ensures that, it has received a management frame and
+         * the frame needs to be freed here. So not to be passed to netdev handler
+         */
+        if(!freeBulkData){
+            if ((client_id < MAX_UDI_CLIENTS) &&
+                    (&priv->ul_clients[client_id] != priv->logging_client)) {
+                send_to_client(priv, &priv->ul_clients[client_id],
+                        receiver_id,
+                        sigdata, siglen, bulkdata);
+            }
+        }
+    }
+
+    /*
+     * Free bulk data buffers here unless it is a CSR_MA_PACKET_INDICATION
+     */
+    switch (signal_id)
+    {
+#ifdef UNIFI_SNIFF_ARPHRD
+        case CSR_MA_SNIFFDATA_INDICATION_ID:
+#endif
+            break;
+
+        case CSR_MA_PACKET_INDICATION_ID:
+            if (!freeBulkData)
+            {
+                break;
+            }
+            /* FALLS THROUGH... */
+        default:
+            for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+                if (bulkdata->d[i].data_length != 0) {
+                    unifi_net_data_free(priv, (void *)&bulkdata->d[i]);
+                }
+            }
+    }
+#endif
+    func_exit();
+} /* unifi_receive_event() */
+
+#ifdef CSR_WIFI_RX_PATH_SPLIT
+/*
+ * ---------------------------------------------------------------------------
+ *  unifi_receive_event2
+ *
+ *      Dispatcher for received signals.
+ *
+ *      This function receives the 'to host' signals and forwards
+ *      them to the unifi linux clients.
+ *
+ *  Arguments:
+ *      ospriv      Pointer to driver's private data.
+ *      sigdata     Pointer to the packed signal buffer.
+ *      siglen      Length of the packed signal.
+ *      bulkdata    Pointer to the signal's bulk data.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *  The signals are received in the format described in the host interface
+ *  specification, i.e wire formatted. Certain clients use the same format
+ *  to interpret them and other clients use the host formatted structures.
+ *  Each client has to call read_unpack_signal() to transform the wire
+ *  formatted signal into the host formatted signal, if necessary.
+ *  The code is in the core, since the signals are defined therefore
+ *  binded to the host interface specification.
+ * ---------------------------------------------------------------------------
+ */
+static void
+unifi_receive_event2(void *ospriv,
+        CsrUint8 *sigdata, CsrUint32 siglen,
+        const bulk_data_param_t *bulkdata)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+    int i, receiver_id;
+    int client_id;
+    CsrInt16 signal_id;
+    CsrBool pktIndToSme = FALSE, freeBulkData = FALSE;
+
+    func_enter();
+
+    unifi_trace(priv, UDBG5, "unifi_receive_event2: "
+            "%04x %04x %04x %04x %04x %04x %04x %04x (%d)\n",
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*0) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*1) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*2) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*3) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*4) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*5) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*6) & 0xFFFF,
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)*7) & 0xFFFF, siglen);
+
+    receiver_id = CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(CsrInt16)) & 0xFF00;
+    client_id = (receiver_id & 0x0F00) >> UDI_SENDER_ID_SHIFT;
+    signal_id = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata);
+
+
+
+    /* check for the type of frame received (checks for 802.11 management frames) */
+    if (signal_id == CSR_MA_PACKET_INDICATION_ID)
+    {
+        CsrUint8 interfaceTag;
+        netInterface_priv_t *interfacePriv;
+
+        /* Pull out interface tag from virtual interface identifier */
+        interfaceTag = (CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata + 14)) & 0xff;
+        interfacePriv = priv->interfacePriv[interfaceTag];
+
+        /* Update activity for this station in case of IBSS */
+#ifdef CSR_SUPPORT_SME
+
+        if (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_IBSS) {
+
+            CsrUint8 *saddr;
+            /* Fetch the source address from  mac header */
+            saddr = (CsrUint8 *) bulkdata->d[0].os_data_ptr + MAC_HEADER_ADDR2_OFFSET;
+            unifi_trace(priv, UDBG5,
+                                    "Updating sta activity in IBSS interfaceTag %x Src Addr %x:%x:%x:%x:%x:%x\n",
+                                    interfaceTag, saddr[0], saddr[1], saddr[2], saddr[3], saddr[4], saddr[5]);
+
+            uf_update_sta_activity(priv, interfaceTag, saddr);
+        }
+#endif
+
+        pktIndToSme = check_routing_pkt_data_ind(priv, sigdata, bulkdata, &freeBulkData, interfacePriv);
+
+        unifi_trace(priv, UDBG6, "RX: packet entry point to driver from HIP,pkt to SME ?(%s) \n", (pktIndToSme)? "YES":"NO");
+
+    }
+
+    if (pktIndToSme)
+    {
+        /* Management MA_PACKET_IND for SME */
+        if(sigdata != NULL && bulkdata != NULL){
+            send_to_client(priv, priv->sme_cli, receiver_id, sigdata, siglen, bulkdata);
+        }
+        else{
+            unifi_error(priv, "unifi_receive_event2: sigdata or Bulkdata is NULL \n");
+        }
+#ifdef CSR_NATIVE_LINUX
+        send_to_client(priv, priv->wext_client,
+                receiver_id,
+                sigdata, siglen, bulkdata);
+#endif
+    }
+    else
+    {
+        /* Signals with ReceiverId==0 are also reported to SME / WEXT,
+         * unless they are data/control MA_PACKET_INDs or VIF_AVAILABILITY_INDs
+         */
+        if (!receiver_id) {
+            if(signal_id == CSR_MA_VIF_AVAILABILITY_INDICATION_ID)
+            {
+                uf_process_ma_vif_availibility_ind(priv, sigdata, siglen);
+            }
+            else if (signal_id != CSR_MA_PACKET_INDICATION_ID)
+            {
+                send_to_client(priv, priv->sme_cli, receiver_id, sigdata, siglen, bulkdata);
+#ifdef CSR_NATIVE_LINUX
+                send_to_client(priv, priv->wext_client,
+                        receiver_id,
+                        sigdata, siglen, bulkdata);
+#endif
+            }
+        }
+
+#ifdef CSR_SUPPORT_SME
+#ifdef CSR_WIFI_SECURITY_WAPI_ENABLE
+       /* Send a WAPI Multicast Indication to SME if the filter has been set
+        * and this is a multicast data packet
+        */
+       if ((priv->wapi_multicast_filter == 1) && (signal_id == CSR_MA_PACKET_INDICATION_ID)) {
+            CSR_SIGNAL signal;
+            CsrUint8 *destAddr;
+            CsrResult res;
+            CsrUint16 interfaceTag = 0;
+
+            /* Check if it is a multicast packet from the destination address in the MAC header  */
+            res = read_unpack_signal(sigdata, &signal);
+            destAddr = (CsrUint8 *) bulkdata->d[0].os_data_ptr + MAC_HEADER_ADDR1_OFFSET;
+            if (res) {
+                unifi_error(priv, "Received unknown or corrupted signal.\n");
+                return;
+            }
+            /*Individual/Group bit - Bit 0 of first byte*/
+            if (destAddr[0] & 0x01) {
+                unifi_trace(priv, UDBG4, "Received a WAPI multicast packet ind\n");
+
+                CsrWifiRouterCtrlWapiMulticastIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0, interfaceTag, siglen, sigdata, bulkdata->d[0].data_length, (CsrUint8*)bulkdata->d[0].os_data_ptr);
+
+                for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+                    if (bulkdata->d[i].data_length != 0) {
+                        unifi_net_data_free(priv, (void *)&bulkdata->d[i]);
+                    }
+                }
+                func_exit();
+                return;
+            }
+        }
+#endif
+#endif
+
+        /* calls the registered clients handler callback func.
+         * netdev_mlme_event_handler is one of the registered handler used to route
+         * data packet to network stack or AMP/EAPOL related data to SME
+         */
+        /* The freeBulkData check ensures that, it has received a management frame and
+         * the frame needs to be freed here. So not to be passed to netdev handler
+         */
+        if(!freeBulkData){
+            if ((client_id < MAX_UDI_CLIENTS) &&
+                    (&priv->ul_clients[client_id] != priv->logging_client)) {
+                send_to_client(priv, &priv->ul_clients[client_id],
+                        receiver_id,
+                        sigdata, siglen, bulkdata);
+            }
+        }
+    }
+
+    /*
+     * Free bulk data buffers here unless it is a CSR_MA_PACKET_INDICATION
+     */
+    switch (signal_id)
+    {
+#ifdef UNIFI_SNIFF_ARPHRD
+        case CSR_MA_SNIFFDATA_INDICATION_ID:
+#endif
+            break;
+
+        case CSR_MA_PACKET_INDICATION_ID:
+            if (!freeBulkData)
+            {
+                break;
+            }
+            /* FALLS THROUGH... */
+        default:
+            for (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {
+                if (bulkdata->d[i].data_length != 0) {
+                    unifi_net_data_free(priv, (void *)&bulkdata->d[i]);
+                }
+            }
+    }
+
+    func_exit();
+} /* unifi_receive_event2() */
+
+void unifi_rx_queue_flush(void *ospriv)
+{
+    unifi_priv_t *priv = (unifi_priv_t*)ospriv;
+
+    func_enter();
+    unifi_trace(priv, UDBG4, "rx_wq_handler: RdPtr = %d WritePtr =  %d\n",
+                priv->rxSignalBuffer.readPointer,priv->rxSignalBuffer.writePointer);
+    if(priv != NULL) {
+        CsrUint8 readPointer = priv->rxSignalBuffer.readPointer;
+        while(readPointer != priv->rxSignalBuffer.writePointer) {
+             rx_buff_struct_t * buf = &priv->rxSignalBuffer.rx_buff[readPointer];
+             unifi_trace(priv, UDBG6, "rx_wq_handler: RdPtr = %d WritePtr =  %d\n",
+                          readPointer,priv->rxSignalBuffer.writePointer);
+             unifi_receive_event2(priv,buf->bufptr,buf->sig_len,&buf->data_ptrs);
+             readPointer ++;
+             if(readPointer >= priv->rxSignalBuffer.size) {
+                    readPointer = 0;
+             }
+        }
+        priv->rxSignalBuffer.readPointer = readPointer;
+    }
+    func_exit();
+}
+
+void rx_wq_handler(struct work_struct *work)
+{
+    unifi_priv_t *priv = container_of(work,unifi_priv_t,rx_work_struct);
+    unifi_rx_queue_flush(priv);
+}
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/unifi_native.h
@@ -0,0 +1,276 @@
+/*
+ *****************************************************************************
+ *
+ * FILE : unifi_native.h
+ *
+ * PURPOSE : Private header file for unifi driver support to wireless extensions.
+ *
+ *           UDI = UniFi Debug Interface
+ *
+ * Copyright (C) 2005-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ *****************************************************************************
+ */
+#ifndef __LINUX_UNIFI_NATIVE_H__
+#define __LINUX_UNIFI_NATIVE_H__ 1
+
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+
+
+/*
+ *      scan.c wext.c autojoin.c
+ */
+/* Structure to hold results of a scan */
+typedef struct scan_info {
+
+/*    CSR_MLME_SCAN_INDICATION msi; */
+
+    unsigned char *info_elems;
+    int info_elem_length;
+
+} scan_info_t;
+
+
+#define IE_VECTOR_MAXLEN 1024
+
+#ifdef CSR_SUPPORT_WEXT
+/*
+ * Structre to hold the wireless network configuration info.
+ */
+struct wext_config {
+
+    /* Requested channel when setting up an adhoc network */
+    int channel;
+
+    /* wireless extns mode: IW_MODE_AUTO, ADHOC, INFRA, MASTER ... MONITOR */
+    int mode;
+
+    /* The capabilities of the currently joined network */
+    int capability;
+
+    /* The interval between beacons if we create an IBSS */
+    int beacon_period;
+
+    /*
+    * Power-save parameters
+    */
+    /* The listen interval to ask for in Associate req. */
+    int assoc_listen_interval;
+    /* Power-mode to put UniFi into */
+
+    unsigned char desired_ssid[UNIFI_MAX_SSID_LEN];     /* the last ESSID set by SIOCSIWESSID */
+    int power_mode;
+    /* Whether to wake for broadcast packets (using DTIM interval) */
+    int wakeup_for_dtims;
+
+    /* Currently selected WEP Key ID (0..3) */
+    int wep_key_id;
+
+    wep_key_t wep_keys[NUM_WEPKEYS];
+
+/*    CSR_AUTHENTICATION_TYPE auth_type; */
+    int privacy;
+
+    u32 join_failure_timeout;
+    u32 auth_failure_timeout;
+    u32 assoc_failure_timeout;
+
+    unsigned char generic_ie[IE_VECTOR_MAXLEN];
+    int generic_ie_len;
+
+    struct iw_statistics wireless_stats;
+
+
+    /* the ESSID we are currently associated to */
+    unsigned char current_ssid[UNIFI_MAX_SSID_LEN];
+    /* the BSSID we are currently associated to */
+    unsigned char current_bssid[6];
+
+    /*
+    * IW_AUTH_WPA_VERSION_DISABLED 0x00000001
+    * IW_AUTH_WPA_VERSION_WPA      0x00000002
+    * IW_AUTH_WPA_VERSION_WPA2     0x00000004
+    */
+    unsigned char wpa_version;
+
+    /*
+     * cipher selection:
+    * IW_AUTH_CIPHER_NONE	0x00000001
+    * IW_AUTH_CIPHER_WEP40	0x00000002
+    * IW_AUTH_CIPHER_TKIP	0x00000004
+    * IW_AUTH_CIPHER_CCMP	0x00000008
+    * IW_AUTH_CIPHER_WEP104	0x00000010
+    */
+    unsigned char pairwise_cipher_used;
+    unsigned char group_cipher_used;
+
+    unsigned int frag_thresh;
+    unsigned int rts_thresh;
+
+    /* U-APSD value, send with Association Request to WMM Enabled APs */
+    unsigned char wmm_bss_uapsd_mask;
+    /* The WMM capabilities of the selected BSS */
+    unsigned int bss_wmm_capabilities;
+
+    /* Flag to prevent a join when the ssid is set */
+    int disable_join_on_ssid_set;
+
+    /* Scan info */
+#define UNIFI_MAX_SCANS 32
+    scan_info_t scan_list[UNIFI_MAX_SCANS];
+    int num_scan_info;
+
+    /* Flag on whether non-802.1x packets are allowed out */
+    CsrWifiRouterPortAction block_controlled_port;
+
+    /* Flag on whether we have completed an authenticate/associate process */
+    unsigned int flag_associated        : 1;
+}; /* struct wext_config */
+
+#endif /* CSR_SUPPORT_WEXT */
+
+
+/*
+ *      wext.c
+ */
+/*int mlme_set_protection(unifi_priv_t *priv, unsigned char *addr,
+                        CSR_PROTECT_TYPE prot, CSR_KEY_TYPE key_type);
+*/
+
+/*
+ * scan.c
+ */
+/*
+void unifi_scan_indication_handler(unifi_priv_t *priv,
+                                   const CSR_MLME_SCAN_INDICATION *msg,
+                                   const unsigned char *extra,
+                                   unsigned int len);
+*/
+void unifi_clear_scan_table(unifi_priv_t *priv);
+scan_info_t *unifi_get_scan_report(unifi_priv_t *priv, int index);
+
+
+/*
+ * Utility functions
+ */
+const unsigned char *unifi_find_info_element(int id,
+                                             const unsigned char *info,
+                                             int len);
+int unifi_add_info_element(unsigned char *info,
+                           int ie_id,
+                           const unsigned char *ie_data,
+                           int ie_len);
+
+/*
+ *      autojoin.c
+ */
+/* Higher level fns */
+int unifi_autojoin(unifi_priv_t *priv, const char *ssid);
+/*
+int unifi_do_scan(unifi_priv_t *priv, int scantype, CSR_BSS_TYPE bsstype,
+                  const char *ssid, int ssid_len);
+*/
+int unifi_set_powermode(unifi_priv_t *priv);
+int unifi_join_ap(unifi_priv_t *priv, scan_info_t *si);
+int unifi_join_bss(unifi_priv_t *priv, unsigned char *macaddr);
+int unifi_leave(unifi_priv_t *priv);
+unsigned int unifi_get_wmm_bss_capabilities(unifi_priv_t *priv,
+                                            unsigned char *ie_vector,
+                                            int ie_len, int *ap_capabilities);
+
+/*
+ * Status and management.
+ */
+int uf_init_wext_interface(unifi_priv_t *priv);
+void uf_deinit_wext_interface(unifi_priv_t *priv);
+
+/*
+ * Function to reset UniFi's 802.11 state by sending MLME-RESET.req
+ */
+int unifi_reset_state(unifi_priv_t *priv, unsigned char *macaddr, unsigned char set_default_mib);
+
+
+/*
+ *      mlme.c
+ */
+/* Abort an MLME operation - useful in error recovery */
+int uf_abort_mlme(unifi_priv_t *priv);
+
+int unifi_mlme_blocking_request(unifi_priv_t *priv, ul_client_t *pcli,
+                                CSR_SIGNAL *sig, bulk_data_param_t *data_ptrs,
+                                int timeout);
+void unifi_mlme_copy_reply_and_wakeup_client(ul_client_t *pcli,
+                                             CSR_SIGNAL *signal, int signal_len,
+                                             const bulk_data_param_t *bulkdata);
+
+/*
+ * Utility functions
+ */
+const char *lookup_reason_code(int reason);
+const char *lookup_result_code(int result);
+
+
+/*
+ *      sme_native.c
+ */
+int uf_sme_init(unifi_priv_t *priv);
+void uf_sme_deinit(unifi_priv_t *priv);
+int sme_sys_suspend(unifi_priv_t *priv);
+int sme_sys_resume(unifi_priv_t *priv);
+int sme_mgt_wifi_on(unifi_priv_t *priv);
+
+/* Callback for event logging to SME clients (unifi_manager) */
+void sme_native_log_event(ul_client_t *client,
+                          const u8 *sig_packed, int sig_len,
+                          const bulk_data_param_t *bulkdata,
+                          int dir);
+
+void sme_native_mlme_event_handler(ul_client_t *pcli,
+                                   const u8 *sig_packed, int sig_len,
+                                   const bulk_data_param_t *bulkdata,
+                                   int dir);
+
+/* Task to query statistics from the MIB */
+#define UF_SME_STATS_WQ_TIMEOUT     2000    /* in msecs */
+void uf_sme_stats_wq(struct work_struct *work);
+
+void uf_native_process_udi_signal(ul_client_t *pcli,
+                                  const u8 *packed_signal,
+                                  int packed_signal_len,
+                                  const bulk_data_param_t *bulkdata, int dir);
+#if 0
+/*
+ * Choose one of these if available in linux/if_arp.h:
+ *  #define UNIFI_SNIFF_ARPHRD ARPHRD_IEEE80211_RADIOTAP
+ *  #define UNIFI_SNIFF_ARPHRD ARPHRD_IEEE80211_PRISM
+ *
+ * Radiotap is the newer standard for softmac WLAN devices, it works with
+ * Wireshark but not Ethereal (due to a bug in the Ethereal dissector).
+ * Prism is an older (less desirable) format but it does work with Ethereal.
+ */
+#ifdef ARPHRD_IEEE80211_RADIOTAP
+#define UNIFI_SNIFF_ARPHRD ARPHRD_IEEE80211_RADIOTAP
+#else
+#ifdef ARPHRD_IEEE80211_PRISM
+#define UNIFI_SNIFF_ARPHRD ARPHRD_IEEE80211_PRISM
+#endif
+#endif
+#endif
+
+#ifdef UNIFI_SNIFF_ARPHRD
+/*
+ * monitor.c
+ */
+int uf_start_sniff(unifi_priv_t *priv);
+/*
+void ma_sniffdata_ind(void *ospriv,
+                      const CSR_MA_SNIFFDATA_INDICATION *ind,
+                      const bulk_data_param_t *bulkdata);
+*/
+#endif /* ARPHRD_IEEE80211_PRISM */
+
+#endif /* __LINUX_UNIFI_NATIVE_H__ */
--- /dev/null
+++ b/drivers/staging/csr/unifi_os.h
@@ -0,0 +1,137 @@
+/*
+ * ---------------------------------------------------------------------------
+ *
+ * FILE: os_linux/unifi_os.h
+ *
+ * PURPOSE:
+ *      This header file provides the OS-dependent facilities for a linux
+ *      environment.
+ *
+ * Copyright (C) 2005-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#ifndef __UNIFI_OS_LINUX_H__
+#define __UNIFI_OS_LINUX_H__ 1
+
+#include <linux/kernel.h>
+#include <linux/time.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+
+/*
+ * Needed for core/signals.c
+ */
+#include <stddef.h>
+
+
+/* Define INLINE directive*/
+#define INLINE      inline
+
+/* Malloc and free */
+CsrResult unifi_net_data_malloc(void *ospriv, bulk_data_desc_t *bulk_data_slot, unsigned int size);
+void unifi_net_data_free(void *ospriv, bulk_data_desc_t *bulk_data_slot);
+#define CSR_WIFI_ALIGN_BYTES    4
+CsrResult unifi_net_dma_align(void *ospriv, bulk_data_desc_t *bulk_data_slot);
+
+/*
+ * Byte Order
+ * Note that __le*_to_cpu and __cpu_to_le* return an unsigned value!
+ */
+#ifdef __KERNEL__
+#define unifi2host_16(n)	(__le16_to_cpu((n)))
+#define unifi2host_32(n)	(__le32_to_cpu((n)))
+#define host2unifi_16(n)	(__cpu_to_le16((n)))
+#define host2unifi_32(n)	(__cpu_to_le32((n)))
+#endif
+
+/* Module parameters */
+extern int unifi_debug;
+
+/* debugging */
+#ifdef UNIFI_DEBUG
+/*
+ * unifi_debug is a verbosity level for debug messages
+ * UDBG0 msgs are always printed if UNIFI_DEBUG is defined
+ * UDBG1 msgs are printed if UNIFI_DEBUG is defined and unifi_debug > 0
+ * etc.
+ */
+
+#define func_enter()                                    \
+    do {                                                \
+        if (unifi_debug >= 5) {                         \
+            printk("unifi: => %s\n", __FUNCTION__);     \
+        }                                               \
+    } while (0)
+#define func_exit()                                     \
+    do {                                                \
+        if (unifi_debug >= 5) {                         \
+            printk("unifi: <= %s\n", __FUNCTION__);     \
+        }                                               \
+    } while (0)
+#define func_exit_r(_rc)                                        \
+    do {                                                        \
+        if (unifi_debug >= 5) {                                 \
+            printk("unifi: <= %s %d\n", __FUNCTION__, (int)(_rc));   \
+        }                                                       \
+    } while (0)
+
+
+#define ASSERT(cond)                                            \
+    do {                                                            \
+        if (!(cond)) {                                              \
+            printk("Assertion failed in %s at %s:%d: %s\n",         \
+                    __FUNCTION__, __FILE__, __LINE__, #cond);        \
+        }                                                           \
+    } while (0)
+
+
+void unifi_dump(void *ospriv, int lvl, const char *msg, void *mem, CsrUint16 len);
+void dump(void *mem, CsrUint16 len);
+void dump16(void *mem, CsrUint16 len);
+#ifdef CSR_WIFI_HIP_DEBUG_OFFLINE
+void dump_str(void *mem, CsrUint16 len);
+#endif /* CSR_WIFI_HIP_DEBUG_OFFLINE */
+
+#else
+
+/* Stubs */
+#define func_enter()
+#define func_exit()
+#define func_exit_r(_rc)
+
+#define ASSERT(cond)
+
+static inline void unifi_dump(void *ospriv, int lvl, const char *msg, void *mem, CsrUint16 len) {}
+static inline void dump(void *mem, CsrUint16 len) {}
+static inline void dump16(void *mem, CsrUint16 len) {}
+#ifdef CSR_WIFI_HIP_DEBUG_OFFLINE
+static inline void dump_str(void *mem, CsrUint16 len) {}
+#endif /* CSR_WIFI_HIP_DEBUG_OFFLINE */
+
+#endif /* UNIFI_DEBUG */
+
+
+void unifi_error(void* ospriv, const char *fmt, ...);
+void unifi_warning(void* ospriv, const char *fmt, ...);
+void unifi_notice(void* ospriv, const char *fmt, ...);
+void unifi_info(void* ospriv, const char *fmt, ...);
+
+void unifi_trace(void* ospriv, int level, const char *fmt, ...);
+
+/* Different levels of diagnostic detail... */
+#define UDBG0       0   /* always prints in debug build */
+#define UDBG1       1
+#define UDBG2       2
+#define UDBG3       3
+#define UDBG4       4
+#define UDBG5       5
+#define UDBG6       6
+#define UDBG7       7
+
+
+#endif /* __UNIFI_OS_LINUX_H__ */
--- /dev/null
+++ b/drivers/staging/csr/unifi_pdu_processing.c
@@ -0,0 +1,3728 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     unifi_pdu_processing.c
+ *
+ * PURPOSE:
+ *      This file provides the PDU handling functionality before it gets sent to unfi and after
+ *      receiving a PDU from unifi
+ *
+ * Copyright (C) 2010 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+
+
+#include <linux/types.h>
+#include <linux/etherdevice.h>
+#include <linux/vmalloc.h>
+
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_conversions.h"
+#include "csr_time.h"
+#include "unifi_priv.h"
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+#include <net/iw_handler.h>
+#endif
+#include <net/pkt_sched.h>
+
+#ifdef CSR_SUPPORT_SME
+static void _update_buffered_pkt_params_after_alignment(unifi_priv_t *priv, bulk_data_param_t *bulkdata,
+                                                        tx_buffered_packets_t* buffered_pkt)
+{
+
+    struct sk_buff *skb ;
+    CsrUint32 align_offset;
+
+    if (priv == NULL || bulkdata == NULL || buffered_pkt == NULL){
+        return;
+    }
+    skb = (struct sk_buff*)bulkdata->d[0].os_net_buf_ptr;
+    align_offset = (CsrUint32)(long)(bulkdata->d[0].os_data_ptr) & (CSR_WIFI_ALIGN_BYTES-1);
+    if(align_offset){
+        skb_pull(skb,align_offset);
+    }
+    buffered_pkt->bulkdata.os_data_ptr = skb->data;
+    buffered_pkt->bulkdata.data_length = skb->len;
+
+
+}
+#endif
+
+void
+unifi_frame_ma_packet_req(unifi_priv_t *priv, CSR_PRIORITY priority,
+                          CSR_RATE TransmitRate, CSR_CLIENT_TAG hostTag,
+                          CsrUint16 interfaceTag, CSR_TRANSMISSION_CONTROL transmissionControl,
+                          CSR_PROCESS_ID leSenderProcessId, CsrUint8 *peerMacAddress,
+                          CSR_SIGNAL *signal)
+{
+
+    CSR_MA_PACKET_REQUEST *req = &signal->u.MaPacketRequest;
+    netInterface_priv_t *interfacePriv;
+    CsrUint8 ba_session_idx = 0;
+    ba_session_tx_struct *ba_session = NULL;
+    CsrUint8 *ba_addr = NULL;
+
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    UF_TRACE_MAC(priv, UDBG5, "In unifi_frame_ma_packet_req, Frame for Peer:", peerMacAddress);
+    signal->SignalPrimitiveHeader.SignalId = CSR_MA_PACKET_REQUEST_ID;
+    signal->SignalPrimitiveHeader.ReceiverProcessId = 0;
+    signal->SignalPrimitiveHeader.SenderProcessId = leSenderProcessId;
+
+    /* Fill the MA-PACKET.req */
+    req->Priority = priority;
+    unifi_trace(priv, UDBG3, "Tx Frame with Priority: 0x%x\n", req->Priority);
+
+    /* A value of 0 is used for auto selection of rates. But for P2P GO case
+     * for action frames the rate is governed by SME. Hence instead of 0,
+     * the rate is filled in with the value passed here
+     */
+    req->TransmitRate = TransmitRate;
+
+    /* packets from netdev then no confirm required but packets from
+     * Nme/Sme eapol data frames requires the confirmation
+     */
+    req->TransmissionControl = transmissionControl;
+    req->VirtualInterfaceIdentifier =
+           uf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag);
+    memcpy(req->Ra.x, peerMacAddress, ETH_ALEN);
+
+    if (hostTag == 0xffffffff) {
+        req->HostTag = interfacePriv->tag++;
+        req->HostTag |= 0x40000000;
+        unifi_trace(priv, UDBG3, "new host tag assigned = 0x%x\n", req->HostTag);
+        interfacePriv->tag &= 0x0fffffff;
+    } else {
+        req->HostTag = hostTag;
+        unifi_trace(priv, UDBG3, "host tag got from SME  = 0x%x\n", req->HostTag);
+    }
+    /* check if BA session exists for the peer MAC address on same tID */
+    if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+       interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO){
+        ba_addr = peerMacAddress;
+    }else{
+        ba_addr = interfacePriv->bssid.a;
+    }
+    for (ba_session_idx=0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_TX; ba_session_idx++){
+        ba_session = interfacePriv->ba_session_tx[ba_session_idx];
+        if (ba_session){
+           if ((!memcmp(ba_session->macAddress.a, ba_addr, ETH_ALEN)) && (ba_session->tID == priority)){
+                req->TransmissionControl |= CSR_ALLOW_BA;
+                break;
+            }
+        }
+    }
+
+    unifi_trace(priv, UDBG5, "leaving unifi_frame_ma_packet_req\n");
+}
+
+#ifdef CSR_SUPPORT_SME
+
+#define TRANSMISSION_CONTROL_TRIGGER_MASK 0x0001
+#define TRANSMISSION_CONTROL_ESOP_MASK 0x0002
+
+static
+int frame_and_send_queued_pdu(unifi_priv_t* priv,tx_buffered_packets_t* buffered_pkt,
+            CsrWifiRouterCtrlStaInfo_t *staRecord,CsrBool moreData , CsrBool eosp)
+{
+
+    CSR_SIGNAL signal;
+    bulk_data_param_t bulkdata;
+    int result;
+    CsrUint8 toDs, fromDs, macHeaderLengthInBytes = MAC_HEADER_SIZE;
+    CsrUint8 *qc;
+    CsrUint16 *fc = (CsrUint16*)(buffered_pkt->bulkdata.os_data_ptr);
+    unsigned long lock_flags;
+    unifi_trace(priv, UDBG3, "frame_and_send_queued_pdu with moreData: %d , EOSP: %d\n",moreData,eosp);
+    unifi_frame_ma_packet_req(priv, buffered_pkt->priority, buffered_pkt->rate, buffered_pkt->hostTag,
+               buffered_pkt->interfaceTag, buffered_pkt->transmissionControl,
+               buffered_pkt->leSenderProcessId, buffered_pkt->peerMacAddress.a, &signal);
+    bulkdata.d[0].os_data_ptr = buffered_pkt->bulkdata.os_data_ptr;
+    bulkdata.d[0].data_length = buffered_pkt->bulkdata.data_length;
+    bulkdata.d[0].os_net_buf_ptr = buffered_pkt->bulkdata.os_net_buf_ptr;
+    bulkdata.d[0].net_buf_length = buffered_pkt->bulkdata.net_buf_length;
+    bulkdata.d[1].os_data_ptr = NULL;
+    bulkdata.d[1].data_length = 0;
+    bulkdata.d[1].os_net_buf_ptr =0;
+    bulkdata.d[1].net_buf_length =0;
+
+    if(moreData) {
+        *fc |= cpu_to_le16(IEEE802_11_FC_MOREDATA_MASK);
+    } else {
+        *fc &= cpu_to_le16(~IEEE802_11_FC_MOREDATA_MASK);
+    }
+
+    if((staRecord != NULL)&& (staRecord->wmmOrQosEnabled == TRUE))
+    {
+        unifi_trace(priv, UDBG3, "frame_and_send_queued_pdu WMM Enabled: %d \n",staRecord->wmmOrQosEnabled);
+
+        toDs = (*fc & cpu_to_le16(IEEE802_11_FC_TO_DS_MASK))?1 : 0;
+        fromDs = (*fc & cpu_to_le16(IEEE802_11_FC_FROM_DS_MASK))? 1: 0;
+
+        switch(le16_to_cpu(*fc) & IEEE80211_FC_SUBTYPE_MASK)
+        {
+            case IEEE802_11_FC_TYPE_QOS_DATA & IEEE80211_FC_SUBTYPE_MASK:
+            case IEEE802_11_FC_TYPE_QOS_NULL & IEEE80211_FC_SUBTYPE_MASK:
+                /* If both are set then the Address4 exists (only for AP) */
+                if (fromDs && toDs)
+                {
+                    /* 6 is the size of Address4 field */
+                    macHeaderLengthInBytes += (QOS_CONTROL_HEADER_SIZE + 6);
+                }
+                else
+                {
+                    macHeaderLengthInBytes += QOS_CONTROL_HEADER_SIZE;
+                }
+
+                /* If order bit set then HT control field is the part of MAC header */
+                if (*fc & cpu_to_le16(IEEE80211_FC_ORDER_MASK)) {
+                    macHeaderLengthInBytes += HT_CONTROL_HEADER_SIZE;
+                }
+                break;
+            default:
+                if (fromDs && toDs)
+                    macHeaderLengthInBytes += 6;
+             break;
+        }
+
+        if (*fc & cpu_to_le16(IEEE80211_FC_ORDER_MASK)) {
+            qc = (CsrUint8*)(buffered_pkt->bulkdata.os_data_ptr + (macHeaderLengthInBytes-6));
+        } else {
+            qc = (CsrUint8*)(buffered_pkt->bulkdata.os_data_ptr + (macHeaderLengthInBytes-2));
+        }
+
+        *qc = eosp ? *qc | (1 << 4) : *qc & (~(1 << 4));
+    }
+    result = ul_send_signal_unpacked(priv, &signal, &bulkdata);
+    if(result){
+        _update_buffered_pkt_params_after_alignment(priv, &bulkdata,buffered_pkt);
+    }
+
+ /* Decrement the packet counts queued in driver */
+    if (result != -ENOSPC) {
+        /* protect entire counter updation by disabling preemption */
+        if (!priv->noOfPktQueuedInDriver) {
+            unifi_error(priv, "packets queued in driver 0 still decrementing\n");
+        } else {
+            spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+            priv->noOfPktQueuedInDriver--;
+            spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+        }
+        /* Sta Record is available for all unicast (except genericMgt Frames) & in other case its NULL */
+        if (staRecord) {
+            spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+            if (!staRecord->noOfPktQueued) {
+                unifi_error(priv, "packets queued in driver per station is 0 still decrementing\n");
+            } else {
+                staRecord->noOfPktQueued--;
+            }
+            /* if the STA alive probe frame has failed then reset the saved host tag */
+            if (result){
+                if (staRecord->nullDataHostTag == buffered_pkt->hostTag){
+                    staRecord->nullDataHostTag = INVALID_HOST_TAG;
+                }
+            }
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+        }
+
+    }
+    return result;
+}
+#ifdef CSR_SUPPORT_SME
+static
+void set_eosp_transmit_ctrl(unifi_priv_t *priv, struct list_head *txList)
+{
+    /* dequeue the tx data packets from the appropriate queue */
+    tx_buffered_packets_t *tx_q_item = NULL;
+    struct list_head *listHead;
+    struct list_head *placeHolder;
+    unsigned long lock_flags;
+
+
+    unifi_trace(priv, UDBG5, "entering set_eosp_transmit_ctrl\n");
+    /* check for list empty */
+    if (list_empty(txList)) {
+        unifi_warning(priv, "In set_eosp_transmit_ctrl, the list is empty\n");
+        return;
+    }
+
+    /* return the last node , and modify it. */
+
+    spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+    list_for_each_prev_safe(listHead, placeHolder, txList) {
+        tx_q_item = list_entry(listHead, tx_buffered_packets_t, q);
+        tx_q_item->transmissionControl |= TRANSMISSION_CONTROL_ESOP_MASK;
+        tx_q_item->transmissionControl = (tx_q_item->transmissionControl & ~(CSR_NO_CONFIRM_REQUIRED));
+        unifi_trace(priv, UDBG1,
+                "set_eosp_transmit_ctrl Transmission Control = 0x%x hostTag = 0x%x \n",tx_q_item->transmissionControl,tx_q_item->hostTag);
+        unifi_trace(priv,UDBG3,"in set_eosp_transmit_ctrl no.of buffered frames %d\n",priv->noOfPktQueuedInDriver);
+        break;
+    }
+    spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+    unifi_trace(priv, UDBG1,"List Empty %d\n",list_empty(txList));
+    unifi_trace(priv, UDBG5, "leaving set_eosp_transmit_ctrl\n");
+    return;
+}
+
+static
+void send_vif_availibility_rsp(unifi_priv_t *priv,CSR_VIF_IDENTIFIER vif,CSR_RESULT_CODE resultCode)
+{
+    CSR_SIGNAL signal;
+    CSR_MA_VIF_AVAILABILITY_RESPONSE *rsp;
+    bulk_data_param_t *bulkdata = NULL;
+    int r;
+
+    memset(&signal,0,sizeof(CSR_SIGNAL));
+    rsp = &signal.u.MaVifAvailabilityResponse;
+    rsp->VirtualInterfaceIdentifier = vif;
+    rsp->ResultCode = resultCode;
+    signal.SignalPrimitiveHeader.SignalId = CSR_MA_VIF_AVAILABILITY_RESPONSE_ID;
+    signal.SignalPrimitiveHeader.ReceiverProcessId = 0;
+    signal.SignalPrimitiveHeader.SenderProcessId = priv->netdev_client->sender_id;
+
+    /* Send the signal to UniFi */
+    r = ul_send_signal_unpacked(priv, &signal, bulkdata);
+    if(r) {
+        unifi_error(priv,"Availibility response sending failed %x status %d\n",vif,r);
+    }
+}
+#endif
+
+static
+void verify_and_accomodate_tx_packet(unifi_priv_t *priv)
+{
+    tx_buffered_packets_t *tx_q_item;
+    unsigned long lock_flags;
+    struct list_head *listHead, *list;
+    struct list_head *placeHolder;
+    CsrUint8 i, j,eospFramedeleted=0;
+    CsrBool thresholdExcedeDueToBroadcast = TRUE;
+    /* it will be made it interface Specific in the future when multi interfaces are supported ,
+    right now interface 0 is considered */
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[0];
+    CsrWifiRouterCtrlStaInfo_t *staInfo = NULL;
+
+    unifi_trace(priv, UDBG3, "entering verify_and_accomodate_tx_packet\n");
+
+    for(i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {
+        staInfo = interfacePriv->staInfo[i];
+            if (staInfo && (staInfo->noOfPktQueued >= CSR_WIFI_DRIVER_MAX_PKT_QUEUING_THRESHOLD_PER_PEER)) {
+            /* remove the first(oldest) packet from the all the access catogory, since data
+             * packets for station record crossed the threshold limit (64 for AP supporting
+             * 8 peers)
+             */
+            unifi_trace(priv,UDBG3,"number of station pkts queued=  %d for sta id = %d\n", staInfo->noOfPktQueued, staInfo->aid);
+            for(j = 0; j < MAX_ACCESS_CATOGORY; j++) {
+                list = &staInfo->dataPdu[j];
+                spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                list_for_each_safe(listHead, placeHolder, list) {
+                    tx_q_item = list_entry(listHead, tx_buffered_packets_t, q);
+                    list_del(listHead);
+                    thresholdExcedeDueToBroadcast = FALSE;
+                    unifi_net_data_free(priv, &tx_q_item->bulkdata);
+                    kfree(tx_q_item);
+                    tx_q_item = NULL;
+                    if (!priv->noOfPktQueuedInDriver) {
+                        unifi_error(priv, "packets queued in driver 0 still decrementing in %s\n", __FUNCTION__);
+                    } else {
+                        /* protection provided by spinlock */
+                        priv->noOfPktQueuedInDriver--;
+
+                    }
+                    /* Sta Record is available for all unicast (except genericMgt Frames) & in other case its NULL */
+                    if (!staInfo->noOfPktQueued) {
+                        unifi_error(priv, "packets queued in driver per station is 0 still decrementing in %s\n", __FUNCTION__);
+                    } else {
+                        spin_lock(&priv->staRecord_lock);
+                        staInfo->noOfPktQueued--;
+                        spin_unlock(&priv->staRecord_lock);
+                    }
+                    break;
+                }
+                spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+            }
+        }
+    }
+    if (thresholdExcedeDueToBroadcast &&  interfacePriv->noOfbroadcastPktQueued > CSR_WIFI_DRIVER_MINIMUM_BROADCAST_PKT_THRESHOLD ) {
+        /* Remove the packets from genericMulticastOrBroadCastFrames queue
+         * (the max packets in driver is reached due to broadcast/multicast frames)
+         */
+        spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+        list_for_each_safe(listHead, placeHolder, &interfacePriv->genericMulticastOrBroadCastFrames) {
+            tx_q_item = list_entry(listHead, tx_buffered_packets_t, q);
+            if(eospFramedeleted){
+                tx_q_item->transmissionControl |= TRANSMISSION_CONTROL_ESOP_MASK;
+                tx_q_item->transmissionControl = (tx_q_item->transmissionControl & ~(CSR_NO_CONFIRM_REQUIRED));
+                unifi_trace(priv, UDBG1,"updating eosp for next packet hostTag:= 0x%x ",tx_q_item->hostTag);
+                eospFramedeleted =0;
+                break;
+            }
+
+            if(tx_q_item->transmissionControl & TRANSMISSION_CONTROL_ESOP_MASK ){
+               eospFramedeleted = 1;
+            }
+            unifi_trace(priv,UDBG1, "freeing of multicast packets ToC = 0x%x hostTag = 0x%x \n",tx_q_item->transmissionControl,tx_q_item->hostTag);
+            list_del(listHead);
+            unifi_net_data_free(priv, &tx_q_item->bulkdata);
+            kfree(tx_q_item);
+            priv->noOfPktQueuedInDriver--;
+            spin_lock(&priv->staRecord_lock);
+            interfacePriv->noOfbroadcastPktQueued--;
+            spin_unlock(&priv->staRecord_lock);
+            if(!eospFramedeleted){
+                break;
+            }
+        }
+        spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+    }
+    unifi_trace(priv, UDBG3, "leaving verify_and_accomodate_tx_packet\n");
+}
+
+static
+CsrResult enque_tx_data_pdu(unifi_priv_t *priv, bulk_data_param_t *bulkdata,
+                            struct list_head *list, CSR_SIGNAL *signal,
+                            CsrBool requeueOnSamePos)
+{
+
+    /* queue the tx data packets on to appropriate queue */
+    CSR_MA_PACKET_REQUEST *req = &signal->u.MaPacketRequest;
+    tx_buffered_packets_t *tx_q_item;
+    unsigned long lock_flags;
+
+    unifi_trace(priv, UDBG5, "entering enque_tx_data_pdu\n");
+    if(!list) {
+       unifi_error(priv,"List is not specified\n");
+       return CSR_RESULT_FAILURE;
+    }
+
+    /* Removes aged packets & adds the incoming packet */
+    if (priv->noOfPktQueuedInDriver >= CSR_WIFI_DRIVER_SUPPORT_FOR_MAX_PKT_QUEUEING) {
+        unifi_trace(priv,UDBG3,"number of pkts queued=  %d \n", priv->noOfPktQueuedInDriver);
+        verify_and_accomodate_tx_packet(priv);
+    }
+
+
+
+    tx_q_item = (tx_buffered_packets_t *)kmalloc(sizeof(tx_buffered_packets_t), GFP_ATOMIC);
+    if (tx_q_item == NULL) {
+        unifi_error(priv,
+                "Failed to allocate %d bytes for tx packet record\n",
+                sizeof(tx_buffered_packets_t));
+        func_exit();
+        return CSR_RESULT_FAILURE;
+    }
+
+    /* disable the preemption */
+    spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+    INIT_LIST_HEAD(&tx_q_item->q);
+    /* fill the tx_q structure members */
+    tx_q_item->bulkdata.os_data_ptr = bulkdata->d[0].os_data_ptr;
+    tx_q_item->bulkdata.data_length = bulkdata->d[0].data_length;
+    tx_q_item->bulkdata.os_net_buf_ptr = bulkdata->d[0].os_net_buf_ptr;
+    tx_q_item->bulkdata.net_buf_length = bulkdata->d[0].net_buf_length;
+    tx_q_item->interfaceTag = req->VirtualInterfaceIdentifier & 0xff;
+    tx_q_item->hostTag = req->HostTag;
+    tx_q_item->leSenderProcessId = signal->SignalPrimitiveHeader.SenderProcessId;
+    tx_q_item->transmissionControl = req->TransmissionControl;
+    tx_q_item->priority = req->Priority;
+    tx_q_item->rate = req->TransmitRate;
+    memcpy(tx_q_item->peerMacAddress.a, req->Ra.x, ETH_ALEN);
+
+
+
+    if (requeueOnSamePos) {
+        list_add(&tx_q_item->q, list);
+    } else {
+        list_add_tail(&tx_q_item->q, list);
+    }
+
+    /* Count of packet queued in driver */
+    priv->noOfPktQueuedInDriver++;
+    spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+    unifi_trace(priv, UDBG5, "leaving enque_tx_data_pdu\n");
+    return CSR_RESULT_SUCCESS;
+}
+static
+CsrResult enque_direceted_ma_pkt_cfm_data_pdu(unifi_priv_t *priv, bulk_data_param_t *bulkdata,
+                            struct list_head *list, CSR_SIGNAL *signal,
+                            CsrBool requeueOnSamePos)
+{
+
+    /* queue the tx data packets on to appropriate queue */
+    CSR_MA_PACKET_REQUEST *req = &signal->u.MaPacketRequest;
+    tx_buffered_packets_t *tx_q_item;
+
+
+    unifi_trace(priv, UDBG5, "entering enque_tx_data_pdu\n");
+    if(!list  ) {
+       unifi_error(priv,"List is not specified\n");
+       return CSR_RESULT_FAILURE;
+    }
+    if(!requeueOnSamePos && !list->prev){
+       unifi_error(priv,"List prev is NULL so don't requeu it\n");
+       return CSR_RESULT_FAILURE;
+
+    }
+
+
+
+    tx_q_item = (tx_buffered_packets_t *)kmalloc(sizeof(tx_buffered_packets_t), GFP_ATOMIC);
+    if (tx_q_item == NULL) {
+        unifi_error(priv,
+                "Failed to allocate %d bytes for tx packet record\n",
+                sizeof(tx_buffered_packets_t));
+        func_exit();
+        return CSR_RESULT_FAILURE;
+    }
+    /* disable the preemption */
+    INIT_LIST_HEAD(&tx_q_item->q);
+    /* fill the tx_q structure members */
+    tx_q_item->bulkdata.os_data_ptr = bulkdata->d[0].os_data_ptr;
+    tx_q_item->bulkdata.data_length = bulkdata->d[0].data_length;
+    tx_q_item->bulkdata.os_net_buf_ptr = bulkdata->d[0].os_net_buf_ptr;
+    tx_q_item->bulkdata.net_buf_length = bulkdata->d[0].net_buf_length;
+    tx_q_item->interfaceTag = req->VirtualInterfaceIdentifier & 0xff;
+    tx_q_item->hostTag = req->HostTag;
+    tx_q_item->leSenderProcessId = signal->SignalPrimitiveHeader.SenderProcessId;
+    tx_q_item->transmissionControl = req->TransmissionControl;
+    tx_q_item->priority = req->Priority;
+    tx_q_item->rate = req->TransmitRate;
+    memcpy(tx_q_item->peerMacAddress.a, req->Ra.x, ETH_ALEN);
+
+
+
+    if (requeueOnSamePos) {
+        list_add(&tx_q_item->q, list);
+    } else {
+        list_add_tail(&tx_q_item->q, list);
+    }
+
+    /* Count of packet queued in driver */
+    priv->noOfPktQueuedInDriver++;
+    unifi_trace(priv, UDBG5, "leaving enque_tx_data_pdu\n");
+    return CSR_RESULT_SUCCESS;
+}
+
+static void is_all_ac_deliver_enabled_and_moredata(CsrWifiRouterCtrlStaInfo_t *staRecord, CsrUint8 *allDeliveryEnabled, CsrUint8 *dataAvailable)
+{
+    CsrUint8 i;
+    *allDeliveryEnabled = TRUE;
+    for (i = 0 ;i < MAX_ACCESS_CATOGORY; i++) {
+        if (!IS_DELIVERY_ENABLED(staRecord->powersaveMode[i])) {
+            /* One is is not Delivery Enabled */
+            *allDeliveryEnabled = FALSE;
+            break;
+        }
+    }
+    if (*allDeliveryEnabled) {
+        *dataAvailable = (!list_empty(&staRecord->dataPdu[0]) || !list_empty(&staRecord->dataPdu[1])
+                          ||!list_empty(&staRecord->dataPdu[2]) ||!list_empty(&staRecord->dataPdu[3])
+                          ||!list_empty(&staRecord->mgtFrames));
+    }
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_handle_tim_cfm
+ *
+ *
+ *      This function updates tim status in host depending confirm status from firmware
+ *
+ *  Arguments:
+ *      priv            Pointer to device private context struct
+ *      cfm             CSR_MLME_SET_TIM_CONFIRM
+ *      receiverProcessId SenderProcessID to fetch handle & timSet status
+ *
+ * ---------------------------------------------------------------------------
+ */
+void uf_handle_tim_cfm(unifi_priv_t *priv, CSR_MLME_SET_TIM_CONFIRM *cfm, CsrUint16 receiverProcessId)
+{
+    CsrUint8 handle = CSR_WIFI_GET_STATION_HANDLE_FROM_RECEIVER_ID(receiverProcessId);
+    CsrUint8 timSetStatus = CSR_WIFI_GET_TIMSET_STATE_FROM_RECEIVER_ID(receiverProcessId);
+    CsrUint16 interfaceTag = (cfm->VirtualInterfaceIdentifier & 0xff);
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    CsrWifiRouterCtrlStaInfo_t *staRecord = NULL;
+    /* This variable holds what TIM value we wanted to set in firmware */
+    CsrUint16 timSetValue = 0;
+    /* Irrespective of interface the count maintained */
+    static CsrUint8 retryCount = 0;
+    unsigned long lock_flags;
+    unifi_trace(priv, UDBG3, "entering %s, handle = %x, timSetStatus = %x\n", __FUNCTION__, handle, timSetStatus);
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_warning(priv, "bad interfaceTag = %x\n", interfaceTag);
+        return;
+    }
+
+    if ((handle != CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE) && (handle >= UNIFI_MAX_CONNECTIONS)) {
+        unifi_warning(priv, "bad station Handle = %x\n", handle);
+        return;
+    }
+
+    if (handle != CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE) {
+        spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+        if ((staRecord = ((CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[handle]))) == NULL) {
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+            unifi_warning(priv, "uf_handle_tim_cfm: station record is NULL  handle = %x\n", handle);
+            return;
+        }
+       spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+    }
+    switch(timSetStatus)
+    {
+        case CSR_WIFI_TIM_SETTING:
+            timSetValue = CSR_WIFI_TIM_SET;
+            break;
+        case CSR_WIFI_TIM_RESETTING:
+            timSetValue = CSR_WIFI_TIM_RESET;
+            break;
+        default:
+            unifi_warning(priv, "timSet state is %x: Debug\n", timSetStatus);
+            return;
+    }
+
+    /* check TIM confirm for success/failures */
+    switch(cfm->ResultCode)
+    {
+        case CSR_RC_SUCCESS:
+            if (handle != CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE) {
+                /* Unicast frame & station record available */
+                if (timSetStatus == staRecord->timSet) {
+                    staRecord->timSet = timSetValue;
+                    /* fh_cmd_q can also be full at some point of time!,
+                     * resetting count as queue is cleaned by firmware at this point
+                     */
+                    retryCount = 0;
+                    unifi_trace(priv, UDBG2, "tim (%s) successfully in firmware\n", (timSetValue)?"SET":"RESET");
+                } else {
+                    unifi_trace(priv, UDBG3, "receiver processID = %x, success: request & confirm states are not matching in TIM cfm: Debug status = %x, staRecord->timSet = %x, handle = %x\n",
+                                 receiverProcessId, timSetStatus, staRecord->timSet, handle);
+                }
+            } else {
+                /* fh_cmd_q can also be full at some point of time!,
+                 * resetting count as queue is cleaned by firmware at this point
+                 */
+                retryCount = 0;
+                unifi_trace(priv, UDBG3, "tim (%s) successfully for broadcast frame in firmware\n", (timSetValue)?"SET":"RESET");
+            }
+            break;
+        case CSR_RC_INVALID_PARAMETERS:
+        case CSR_RC_INSUFFICIENT_RESOURCE:
+            /* check for max retry limit & send again
+             * MAX_RETRY_LIMIT is not maintained for each set of transactions..Its generic
+             * If failure crosses this Limit, we have to take a call to FIX
+             */
+            if (retryCount > UNIFI_MAX_RETRY_LIMIT) {
+                CsrBool moreData = FALSE;
+                retryCount = 0;
+                /* Because of continuos traffic in fh_cmd_q the tim set request is failing (exceeding retry limit)
+                 * but if we didn't synchronize our timSet varible state with firmware then it can cause below issues
+                 * cond 1. We want to SET tim in firmware if its fails & max retry limit reached
+                 *   -> If host set's the timSet to 1, we wont try to send(as max retry reached) update tim but
+                 *   firmware is not updated with queue(TIM) status so it wont set TIM in beacon finally host start piling
+                 *    up data & wont try to set tim in firmware (This can cause worser performance)
+                 * cond 2. We want to reset tim in firmware it fails & reaches max retry limit
+                 *   -> If host sets the timSet to Zero, it wont try to set a TIM request unless we wont have any packets
+                 *   to be queued, so beacon unnecessarily advertizes the TIM
+                 */
+
+                if(staRecord) {
+                    if(!staRecord->wmmOrQosEnabled) {
+                        moreData = (!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]) ||
+                                !list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]) ||
+                                !list_empty(&staRecord->mgtFrames));
+                    } else {
+                        /* Peer is QSTA */
+                        CsrUint8 allDeliveryEnabled = 0, dataAvailable = 0;
+                        /* Check if all AC's are Delivery Enabled */
+                        is_all_ac_deliver_enabled_and_moredata(staRecord, &allDeliveryEnabled, &dataAvailable);
+                        /*check for more data in non-delivery enabled queues*/
+                        moreData = (uf_is_more_data_for_non_delivery_ac(staRecord) || (allDeliveryEnabled && dataAvailable));
+
+                    }
+                    /* To avoid cond 1 & 2, check internal Queues status, if we have more Data then set RESET the timSet(0),
+                     *  so we are trying to be in sync with firmware & next packets before queuing atleast try to
+                     *  set TIM in firmware otherwise it SET timSet(1)
+                     */
+                    if (moreData) {
+                        staRecord->timSet = CSR_WIFI_TIM_RESET;
+                    } else {
+                        staRecord->timSet = CSR_WIFI_TIM_SET;
+                    }
+                } else {
+                    /* Its a broadcast frames */
+                    moreData = (!list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames) ||
+                               !list_empty(&interfacePriv->genericMulticastOrBroadCastFrames));
+                    if (moreData) {
+                        update_tim(priv, 0, CSR_WIFI_TIM_SET, interfaceTag, 0xFFFFFFFF);
+                    } else {
+                        update_tim(priv, 0, CSR_WIFI_TIM_RESET, interfaceTag, 0xFFFFFFFF);
+                    }
+                }
+
+                unifi_error(priv, "no of error's for TIM setting crossed the Limit: verify\n");
+                return;
+            }
+            retryCount++;
+
+            if (handle != CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE) {
+                if (timSetStatus == staRecord->timSet) {
+                    unifi_warning(priv, "tim request failed, retry for AID = %x\n", staRecord->aid);
+                    update_tim(priv, staRecord->aid, timSetValue, interfaceTag, handle);
+                } else {
+                    unifi_trace(priv, UDBG1, "failure: request & confirm states are not matching in TIM cfm: Debug status = %x, staRecord->timSet = %x\n",
+                                  timSetStatus, staRecord->timSet);
+                }
+            } else {
+                unifi_warning(priv, "tim request failed, retry for broadcast frames\n");
+                update_tim(priv, 0, timSetValue, interfaceTag, 0xFFFFFFFF);
+            }
+            break;
+        default:
+            unifi_warning(priv, "tim update request failed resultcode = %x\n", cfm->ResultCode);
+    }
+    unifi_trace(priv, UDBG2, "leaving %s\n", __FUNCTION__);
+}
+
+/*
+ * ---------------------------------------------------------------------------
+ *  update_tim
+ *
+ *
+ *      This function updates tim status in firmware for AID[1 to UNIFI_MAX_CONNECTIONS] or
+ *       AID[0] for broadcast/multicast packets.
+ *
+ *      NOTE: The LSB (least significant BYTE) of senderId while sending this MLME premitive
+ *       has been modified(utilized) as below
+ *
+ *       SenderID in signal's SignalPrimitiveHeader is 2 byte the lowe byte bitmap is below
+ *
+ *       station handle(6 bits)      timSet Status (2 bits)
+ *       ---------------------       ----------------------
+ *       0  0  0  0  0  0        |       0  0
+ *
+ * timSet Status can be one of below:
+ *
+ * CSR_WIFI_TIM_RESET
+ * CSR_WIFI_TIM_RESETTING
+ * CSR_WIFI_TIM_SET
+ * CSR_WIFI_TIM_SETTING
+ *
+ *  Arguments:
+ *      priv            Pointer to device private context struct
+ *      aid             can be 1 t0 UNIFI_MAX_CONNECTIONS & 0 means multicast/broadcast
+ *      setTim          value SET(1) / RESET(0)
+ *      interfaceTag    the interfaceID on which activity going on
+ *      handle          from  (0 <= handle < UNIFI_MAX_CONNECTIONS)
+ *
+ * ---------------------------------------------------------------------------
+ */
+void update_tim(unifi_priv_t * priv, CsrUint16 aid, CsrUint8 setTim, CsrUint16 interfaceTag, CsrUint32 handle)
+{
+    CSR_SIGNAL signal;
+    CsrInt32 r;
+    CSR_MLME_SET_TIM_REQUEST *req = &signal.u.MlmeSetTimRequest;
+    bulk_data_param_t *bulkdata = NULL;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    CsrUint8 senderIdLsb = 0;
+    CsrWifiRouterCtrlStaInfo_t *staRecord = NULL;
+    CsrUint32 oldTimSetStatus = 0, timSetStatus = 0;
+
+    unifi_trace(priv, UDBG5, "entering the update_tim routine\n");
+
+    if (handle == 0xFFFFFFFF) {
+        handle &= CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE;
+    } else if ((handle != 0xFFFFFFFF) && (handle >= UNIFI_MAX_CONNECTIONS)) {
+        unifi_warning(priv, "bad station Handle = %x\n", handle);
+        return;
+    }
+
+    if (setTim) {
+        timSetStatus =  CSR_WIFI_TIM_SETTING;
+    } else {
+        timSetStatus =  CSR_WIFI_TIM_RESETTING;
+    }
+
+    if (handle != CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE) {
+        if ((staRecord = ((CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[handle]))) == NULL) {
+            unifi_warning(priv, "station record is NULL in  update_tim: handle = %x :debug\n", handle);
+            return;
+        }
+        /* In case of signal sending failed, revert back to old state */
+        oldTimSetStatus = staRecord->timSet;
+        staRecord->timSet = timSetStatus;
+    }
+
+    /* pack senderID LSB */
+    senderIdLsb = CSR_WIFI_PACK_SENDER_ID_LSB_FOR_TIM_REQ(handle,  timSetStatus);
+
+    /* initialize signal to zero */
+    memset(&signal, 0, sizeof(CSR_SIGNAL));
+
+    /* Frame the MLME-SET-TIM request */
+    signal.SignalPrimitiveHeader.SignalId = CSR_MLME_SET_TIM_REQUEST_ID;
+    signal.SignalPrimitiveHeader.ReceiverProcessId = 0;
+    CSR_COPY_UINT16_TO_LITTLE_ENDIAN(((priv->netdev_client->sender_id & 0xff00) | senderIdLsb),
+                   (u8*)&signal.SignalPrimitiveHeader.SenderProcessId);
+
+    /* set The virtual interfaceIdentifier, aid, tim value */
+    req->VirtualInterfaceIdentifier = uf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag);
+    req->AssociationId = aid;
+    req->TimValue = setTim;
+
+
+    unifi_trace(priv, UDBG2, "update_tim:AID %x,senderIdLsb = 0x%x, handle = 0x%x, timSetStatus = %x, sender proceesID = %x \n",
+                aid,senderIdLsb, handle, timSetStatus, signal.SignalPrimitiveHeader.SenderProcessId);
+
+    /* Send the signal to UniFi */
+    r = ul_send_signal_unpacked(priv, &signal, bulkdata);
+    if (r) {
+        /* No need to free bulk data, as TIM request doesn't carries any data */
+        unifi_error(priv, "Error queueing CSR_MLME_SET_TIM_REQUEST signal\n");
+        if (staRecord) {
+            staRecord->timSet = oldTimSetStatus ;
+        }
+    }
+    unifi_trace(priv, UDBG5, "leaving the update_tim routine\n");
+}
+
+static
+void process_peer_active_transition(unifi_priv_t * priv,
+                                    CsrWifiRouterCtrlStaInfo_t *staRecord,
+                                    CsrUint16 interfaceTag)
+{
+    int r,i;
+    CsrBool spaceAvail[4] = {TRUE,TRUE,TRUE,TRUE};
+    tx_buffered_packets_t * buffered_pkt = NULL;
+    unsigned long lock_flags;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    unifi_trace(priv, UDBG5, "entering process_peer_active_transition\n");
+
+    if(IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag)) {
+        /* giving more priority to multicast packets so delaying unicast packets*/
+        unifi_trace(priv,UDBG2," multicast transmission is going on so resume unicast transmission after DTIM over\n");
+        return;
+    }
+    while((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->mgtFrames))) {
+        buffered_pkt->transmissionControl &=
+                     ~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_ESOP_MASK);
+        if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,0,FALSE)) == -ENOSPC) {
+            unifi_trace(priv, UDBG2, "p_p_a_t:(ENOSPC) Mgt Frame queueing \n");
+            /* Enqueue at the head of the queue */
+            spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+            list_add(&buffered_pkt->q, &staRecord->mgtFrames);
+            spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+            priv->pausedStaHandle[3]=(CsrUint8)(staRecord->assignedHandle);
+            spaceAvail[3] = FALSE;
+            break;
+        } else {
+            if(r){
+                unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                /* the PDU failed where we can't do any thing so free the storage */
+                unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+            }
+            kfree(buffered_pkt);
+        }
+    }
+    if (staRecord->txSuspend) {
+        if(staRecord->timSet == CSR_WIFI_TIM_SET) {
+            update_tim(priv,staRecord->aid,0,interfaceTag, staRecord->assignedHandle);
+        }
+        return;
+    }
+    for(i=3;i>=0;i--) {
+        if(!spaceAvail[i])
+            continue;
+        unifi_trace(priv, UDBG6, "p_p_a_t:data pkt sending for AC %d \n",i);
+        while((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->dataPdu[i]))) {
+           buffered_pkt->transmissionControl &=
+                      ~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_ESOP_MASK);
+           if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,0,FALSE)) == -ENOSPC) {
+               /* Clear the trigger bit transmission control*/
+               /* Enqueue at the head of the queue */
+               spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+               list_add(&buffered_pkt->q, &staRecord->dataPdu[i]);
+               spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+               priv->pausedStaHandle[i]=(CsrUint8)(staRecord->assignedHandle);
+               break;
+           } else {
+              if(r){
+                  unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                  /* the PDU failed where we can't do any thing so free the storage */
+                  unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+               }
+              kfree(buffered_pkt);
+           }
+        }
+    }
+    if((staRecord->timSet  == CSR_WIFI_TIM_SET) || (staRecord->timSet == CSR_WIFI_TIM_SETTING)){
+        unifi_trace(priv, UDBG3, "p_p_a_t:resetting tim .....\n");
+        update_tim(priv,staRecord->aid,0,interfaceTag, staRecord->assignedHandle);
+    }
+    unifi_trace(priv, UDBG5, "leaving process_peer_active_transition\n");
+}
+
+
+
+void uf_process_ma_pkt_cfm_for_ap(unifi_priv_t *priv,CsrUint16 interfaceTag, const CSR_MA_PACKET_CONFIRM *pkt_cfm)
+{
+    netInterface_priv_t *interfacePriv;
+    CsrUint8 i;
+    CsrWifiRouterCtrlStaInfo_t *staRecord = NULL;
+    struct list_head *listHeadMaPktreq,*listHeadStaQueue;
+    struct list_head *placeHolderMaPktreq,*placeHolderStaQueue;
+    unsigned long lock_flags;
+    unsigned long lock_flags1;
+    maPktReqList_t *maPktreq = NULL;
+    tx_buffered_packets_t *tx_q_item = NULL;
+    bulk_data_param_t bulkdata;
+    CsrBool entryFound = FALSE;
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+
+    if(pkt_cfm->HostTag == interfacePriv->multicastPduHostTag) {
+         unifi_trace(priv,UDBG2,"CFM for marked Multicast Tag = %x\n",interfacePriv->multicastPduHostTag);
+         interfacePriv->multicastPduHostTag = 0xffffffff;
+         resume_suspended_uapsd(priv,interfaceTag);
+         resume_unicast_buffered_frames(priv,interfaceTag);
+         if(list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames) &&
+              list_empty(&interfacePriv->genericMulticastOrBroadCastFrames)) {
+            unifi_trace(priv,UDBG1,"Resetting multicastTIM");
+            update_tim(priv,0,0,interfaceTag, 0xFFFFFFFF);
+        }
+        return;
+    }
+
+    /* Check if a copy of the same frame (identified by host tag) is queued in driver */
+    spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+    list_for_each_safe(listHeadMaPktreq, placeHolderMaPktreq, &interfacePriv->directedMaPktReq) {
+        maPktreq = list_entry(listHeadMaPktreq, maPktReqList_t, q);
+        if(maPktreq->hostTag == pkt_cfm->HostTag){
+            entryFound = TRUE;
+            break;
+        }
+    }
+    spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+
+    if(entryFound){
+
+        /* Monitor the time difference between the MA-PACKET.req and MA-PACKET.cfm */
+        unsigned long timeout;
+        timeout = (long)jiffies - (long)maPktreq->jiffeTime;
+
+        /* convert into milliseconds */
+        timeout = jiffies_to_msecs(timeout);
+        unifi_trace(priv, UDBG3, "Jiffies Time: Host Tag(%x) --> Req(%u) Cfm(%u) Diff (in ms): %u\n",maPktreq->hostTag,maPktreq->jiffeTime, jiffies, timeout);
+
+        if( (timeout/1000) > 1)
+        {
+             unifi_trace(priv, UDBG1, "Confirm time > 2 Seconds: time = %u Status = %x\n", (timeout/1000), pkt_cfm->TransmissionStatus);
+        }
+
+       if( CSR_TX_LIFETIME == pkt_cfm->TransmissionStatus  ||
+           CSR_TX_BLOCK_ACK_TIMEOUT== pkt_cfm->TransmissionStatus ||
+           CSR_TX_FAIL_TRANSMISSION_VIF_INTERRUPTED== pkt_cfm->TransmissionStatus ||
+           CSR_TX_REJECTED_PEER_STATION_SLEEPING== pkt_cfm->TransmissionStatus ||
+           CSR_TX_REJECTED_DTIM_STARTED== pkt_cfm->TransmissionStatus ){
+
+         CsrWifiRouterCtrlStaInfo_t *staRecord = interfacePriv->staInfo[maPktreq->staHandler];
+         unifi_TrafficQueue priority_q;
+         struct list_head *list;
+         CsrResult result;
+         CSR_MA_PACKET_REQUEST *req = &maPktreq->signal.u.MaPacketRequest;
+         CsrUint16 ii=0;
+         CsrBool locationFound = FALSE;
+         CsrUint8 *sigbuffer;
+
+         sigbuffer = (CsrUint8*)&maPktreq->signal;
+         if(req->Priority == CSR_MANAGEMENT){
+             list = &staRecord->mgtFrames;
+             unifi_trace(priv,UDBG5,"mgmt list priority %d\n",req->Priority);
+         }
+         else{
+             priority_q= unifi_frame_priority_to_queue(req->Priority);
+             list = &staRecord->dataPdu[priority_q];
+             unifi_trace(priv,UDBG5,"data list priority %d\n",req->Priority);
+         }
+
+         spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+         list_for_each_safe(listHeadStaQueue, placeHolderStaQueue, list){
+             tx_q_item = list_entry(listHeadStaQueue, tx_buffered_packets_t, q);
+           COMPARE_HOST_TAG_TO_ENQUEUE(tx_q_item->hostTag ,maPktreq->hostTag)
+
+
+         }
+         if(sigbuffer[SIZEOF_SIGNAL_HEADER + 1]){
+            skb_pull(maPktreq->skb,sigbuffer[SIZEOF_SIGNAL_HEADER + 1]);
+         }
+
+         /* enqueue the failed packet sta queue*/
+         bulkdata.d[0].os_net_buf_ptr= (unsigned char*)maPktreq->skb;
+         bulkdata.d[0].os_data_ptr = maPktreq->skb->data;
+         bulkdata.d[0].data_length = bulkdata.d[0].net_buf_length = maPktreq->skb->len;
+         bulkdata.d[1].os_data_ptr = NULL;
+         bulkdata.d[1].os_net_buf_ptr = NULL;
+         bulkdata.d[1].data_length = bulkdata.d[0].net_buf_length = 0;
+         unifi_trace(priv,UDBG4,"Cfm Fail for HosTag = %x with status %d so requeue it\n",maPktreq->hostTag,pkt_cfm->TransmissionStatus );
+         req->TransmissionControl = 0;
+
+         if(!locationFound){
+
+             if(list_empty(list)){
+                result = enque_direceted_ma_pkt_cfm_data_pdu(priv, &bulkdata, list,&maPktreq->signal,1);
+             }
+             else{
+                  unifi_trace(priv,UDBG4,"did not find location so add to end of list \n");
+                  result = enque_direceted_ma_pkt_cfm_data_pdu(priv, &bulkdata, list,&maPktreq->signal,0);
+             }
+
+
+         }
+
+         else {
+            if(ii > 1){
+                 unifi_trace(priv,UDBG4,"find the location in the middle of list \n");
+                 result = enque_direceted_ma_pkt_cfm_data_pdu(priv, &bulkdata, listHeadStaQueue,&maPktreq->signal,0);
+
+            }
+            else{
+                unifi_trace(priv,UDBG4," add at begining of list \n");
+                result = enque_direceted_ma_pkt_cfm_data_pdu(priv, &bulkdata, list,&maPktreq->signal,1);
+            }
+         }
+
+         spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+
+         /* Increment the counter */
+         spin_lock_irqsave(&priv->staRecord_lock,lock_flags1);
+         staRecord->noOfPktQueued++;
+         spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags1);
+
+
+
+
+         /* after enqueuing update the TIM */
+         if(CSR_RESULT_SUCCESS == result){
+             if(CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE == staRecord->currentPeerState) {
+                if(staRecord->timSet == CSR_WIFI_TIM_RESET || staRecord->timSet == CSR_WIFI_TIM_RESETTING) {
+                    if(!staRecord->wmmOrQosEnabled) {
+                        unifi_trace(priv, UDBG3, "uf_process_ma_pkt_cfm_for_ap :tim set due to unicast pkt & peer in powersave\n");
+                        update_tim(priv,staRecord->aid,1,interfaceTag, staRecord->assignedHandle);
+                    }
+                    else {
+                        /* Check for non delivery enable(i.e trigger enable), all delivery enable & legacy AC for TIM update in firmware */
+                        CsrUint8 allDeliveryEnabled = 0, dataAvailable = 0;
+                        /* Check if all AC's are Delivery Enabled */
+                        is_all_ac_deliver_enabled_and_moredata(staRecord, &allDeliveryEnabled, &dataAvailable);
+                        if (uf_is_more_data_for_non_delivery_ac(staRecord) || (allDeliveryEnabled && dataAvailable)) {
+                            update_tim(priv,staRecord->aid,1,interfaceTag, staRecord->assignedHandle);
+                        }
+                    }
+                }
+             }
+         }
+         else{
+            dev_kfree_skb(maPktreq->skb);
+         }
+       }
+      else
+      {
+        CsrWifiRouterCtrlStaInfo_t *staRecord = interfacePriv->staInfo[maPktreq->staHandler];
+        if (CSR_TX_RETRY_LIMIT == pkt_cfm->TransmissionStatus ||
+            CSR_TX_NO_BSS == pkt_cfm->TransmissionStatus)
+        {
+            if (staRecord->timSet == CSR_WIFI_TIM_RESET || staRecord->timSet == CSR_WIFI_TIM_RESETTING)
+            {
+                unifi_trace(priv, UDBG2, "CFM failed with Retry Limit or No BSS --> update TIM\n");
+                update_tim(priv, staRecord->aid, 1, interfaceTag, staRecord->assignedHandle);
+            }
+        }
+        else if (CSR_TX_SUCCESSFUL == pkt_cfm->TransmissionStatus)
+        {
+            staRecord->activity_flag = TRUE;
+        }
+        unifi_trace(priv, UDBG5, "CFM for HosTag = %x Status = %d, Free SKB reference\n",
+                    maPktreq->hostTag,
+                    pkt_cfm->TransmissionStatus );
+
+        dev_kfree_skb(maPktreq->skb);
+
+      }
+      list_del(listHeadMaPktreq);
+      kfree(maPktreq);
+
+    }else{
+        /* Check if it is a Confirm for null data frame used
+         * for probing station activity
+         */
+        for(i =0; i < UNIFI_MAX_CONNECTIONS; i++) {
+            staRecord = (CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[i]);
+            if (staRecord && (staRecord->nullDataHostTag == pkt_cfm->HostTag)) {
+
+                unifi_trace(priv, UDBG1, "CFM for Inactive probe Null frame (tag = %x, status = %d)\n",
+                                        pkt_cfm->HostTag,
+                                        pkt_cfm->TransmissionStatus
+                                        );
+                staRecord->nullDataHostTag = INVALID_HOST_TAG;
+
+                if(pkt_cfm->TransmissionStatus == CSR_TX_RETRY_LIMIT){
+                    CsrTime now;
+                    CsrTime inactive_time;
+
+                    unifi_trace(priv, UDBG1, "Nulldata to probe STA ALIVE Failed with retry limit\n");
+                    /* Recheck if there is some activity after null data is sent.
+                    *
+                    * If still there is no activity then send a disconnected indication
+                    * to SME to delete the station record.
+                    */
+                    if (staRecord->activity_flag){
+                        return;
+                    }
+                    now = CsrTimeGet(NULL);
+
+                    if (staRecord->lastActivity > now)
+                    {
+                        /* simple timer wrap (for 1 wrap) */
+                        inactive_time = CsrTimeAdd((CsrTime)CsrTimeSub(CSR_SCHED_TIME_MAX, staRecord->lastActivity),
+                                                   now);
+                    }
+                    else
+                    {
+                        inactive_time = (CsrTime)CsrTimeSub(now, staRecord->lastActivity);
+                    }
+
+                    if (inactive_time >= STA_INACTIVE_TIMEOUT_VAL)
+                    {
+                        struct list_head send_cfm_list;
+                        CsrUint8 j;
+
+                        /* The SME/NME may be waiting for confirmation for requested frames to this station.
+                         * Though this is --VERY UNLIKELY-- in case of station in active mode. But still as a
+                         * a defensive check, it loops through buffered frames for this station and if confirmation
+                         * is requested, send auto confirmation with failure status. Also flush the frames so
+                         * that these are not processed again in PEER_DEL_REQ handler.
+                         */
+                        INIT_LIST_HEAD(&send_cfm_list);
+
+                        uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                                                 &send_cfm_list,
+                                                                 &(staRecord->mgtFrames));
+
+                        uf_flush_list(priv, &(staRecord->mgtFrames));
+
+                        for(j = 0; j < MAX_ACCESS_CATOGORY; j++){
+                            uf_prepare_send_cfm_list_for_queued_pkts(priv,
+                                                                     &send_cfm_list,
+                                                                     &(staRecord->dataPdu[j]));
+
+                            uf_flush_list(priv,&(staRecord->dataPdu[j]));
+                        }
+
+                        send_auto_ma_packet_confirm(priv, staRecord->interfacePriv, &send_cfm_list);
+
+
+
+                        unifi_warning(priv, "uf_process_ma_pkt_cfm_for_ap: Router Disconnected IND Peer (%x-%x-%x-%x-%x-%x)\n",
+                                                 staRecord->peerMacAddress.a[0],
+                                                 staRecord->peerMacAddress.a[1],
+                                                 staRecord->peerMacAddress.a[2],
+                                                 staRecord->peerMacAddress.a[3],
+                                                 staRecord->peerMacAddress.a[4],
+                                                 staRecord->peerMacAddress.a[5]);
+
+                        CsrWifiRouterCtrlConnectedIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,
+                                                          0,
+                                                          staRecord->interfacePriv->InterfaceTag,
+                                                          staRecord->peerMacAddress,
+                                                          CSR_WIFI_ROUTER_CTRL_PEER_DISCONNECTED);
+                    }
+
+                }
+                else if (pkt_cfm->TransmissionStatus == CSR_TX_SUCCESSFUL)
+                {
+                     staRecord->activity_flag = TRUE;
+                }
+            }
+        }
+    }
+}
+
+#endif
+CsrUint16 uf_get_vif_identifier (CsrWifiRouterCtrlMode mode, CsrUint16 tag)
+{
+    switch(mode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_STA:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:
+            return (0x02<<8|tag);
+
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            return (0x03<<8|tag);
+
+        case CSR_WIFI_ROUTER_CTRL_MODE_IBSS:
+            return (0x01<<8|tag);
+
+        case CSR_WIFI_ROUTER_CTRL_MODE_MONITOR:
+            return (0x04<<8|tag);
+        case CSR_WIFI_ROUTER_CTRL_MODE_AMP:
+            return (0x05<<8|tag);
+        default:
+            return tag;
+    }
+}
+
+#ifdef CSR_SUPPORT_SME
+
+/*
+ * ---------------------------------------------------------------------------
+ *  update_macheader
+ *
+ *
+ *      These functions updates mac header for intra BSS packet
+ *      routing.
+ *      NOTE: This function always has to be called in rx context which
+ *      is in bh thread context since GFP_KERNEL is used. In soft IRQ/ Interrupt
+ *      context shouldn't be used
+ *
+ *  Arguments:
+ *      priv            Pointer to device private context struct
+ *      skb             Socket buffer containing data packet to transmit
+ *      newSkb          Socket buffer containing data packet + Mac header if no sufficient headroom in skb
+ *      priority        to append QOS control header in Mac header
+ *      bulkdata        if newSkb allocated then bulkdata updated to send to unifi
+ *      interfaceTag    the interfaceID on which activity going on
+ *      macHeaderLengthInBytes no. of bytes of mac header in received frame
+ *      qosDestination  used to append Qos control field
+ *
+ *  Returns:
+ *      Zero on success or -1 on error.
+ * ---------------------------------------------------------------------------
+ */
+
+static int update_macheader(unifi_priv_t *priv, struct sk_buff *skb,
+                            struct sk_buff *newSkb, CSR_PRIORITY *priority,
+                            bulk_data_param_t *bulkdata, CsrUint16 interfaceTag,
+                            CsrUint8 macHeaderLengthInBytes,
+                            CsrUint8 qosDestination)
+{
+
+    CsrUint16 *fc = NULL;
+    CsrUint8 direction = 0, toDs, fromDs;
+    CsrUint8 *bufPtr = NULL;
+    CsrUint8 sa[ETH_ALEN], da[ETH_ALEN];
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    int headroom;
+    CsrUint8 macHeaderBuf[IEEE802_11_DATA_FRAME_MAC_HEADER_SIZE] = {0};
+
+    unifi_trace(priv, UDBG5, "entering the update_macheader function\n");
+
+    /* temporary buffer for the Mac header storage */
+    memcpy(macHeaderBuf, skb->data, macHeaderLengthInBytes);
+
+    /* remove the Macheader from the skb */
+    skb_pull(skb, macHeaderLengthInBytes);
+
+    /* get the skb headroom for skb_push check */
+    headroom = skb_headroom(skb);
+
+    /*  pointer to frame control field */
+    fc = (CsrUint16*) macHeaderBuf;
+
+    toDs = (*fc & cpu_to_le16(IEEE802_11_FC_TO_DS_MASK))?1 : 0;
+    fromDs = (*fc & cpu_to_le16(IEEE802_11_FC_FROM_DS_MASK))? 1: 0;
+    unifi_trace(priv, UDBG5, "In update_macheader function, fromDs = %x, toDs = %x\n", fromDs, toDs);
+    direction = ((fromDs | (toDs << 1)) & 0x3);
+
+    /* Address1 or 3 from the macheader */
+    memcpy(da, macHeaderBuf+4+toDs*12, ETH_ALEN);
+    /* Address2, 3 or 4 from the mac header */
+    memcpy(sa, macHeaderBuf+10+fromDs*(6+toDs*8), ETH_ALEN);
+
+    unifi_trace(priv, UDBG3, "update_macheader:direction = %x\n", direction);
+    /* update the toDs, fromDs & address fields in Mac header */
+    switch(direction)
+    {
+        case 2:
+            /* toDs = 1 & fromDs = 0 , toAp when frames received from peer
+             * while sending this packet to Destination the Mac header changed
+             * as fromDs = 1 & toDs = 0, fromAp
+             */
+            *fc &= cpu_to_le16(~IEEE802_11_FC_TO_DS_MASK);
+            *fc |= cpu_to_le16(IEEE802_11_FC_FROM_DS_MASK);
+            /* Address1: MAC address of the actual destination (4 = 2+2) */
+            memcpy(macHeaderBuf + 4, da, ETH_ALEN);
+            /* Address2: The MAC address of the AP (10 = 2+2+6) */
+            memcpy(macHeaderBuf + 10, &interfacePriv->bssid, ETH_ALEN);
+            /* Address3: MAC address of the actual source from mac header (16 = 2+2+6+6) */
+            memcpy(macHeaderBuf + 16, sa, ETH_ALEN);
+            break;
+        case 3:
+            unifi_trace(priv, UDBG3, "when both the toDs & fromDS set, NOT SUPPORTED\n");
+            break;
+        default:
+            unifi_trace(priv, UDBG3, "problem in decoding packet in update_macheader \n");
+            return -1;
+    }
+
+    /* frameType is Data always, Validation is done before calling this function */
+
+    /* check for the souce station type */
+    switch(le16_to_cpu(*fc) & IEEE80211_FC_SUBTYPE_MASK)
+    {
+        case IEEE802_11_FC_TYPE_QOS_DATA & IEEE80211_FC_SUBTYPE_MASK:
+            /* No need to modify the qos control field */
+            if (!qosDestination) {
+
+                /* If source Sta is QOS enabled & if this bit set, then HTC is supported by
+                 * peer station & htc field present in macHeader
+                 */
+                if (*fc & cpu_to_le16(IEEE80211_FC_ORDER_MASK)) {
+                    /* HT control field present in Mac header
+                     * 6 = sizeof(qosControl) + sizeof(htc)
+                     */
+                    macHeaderLengthInBytes -= 6;
+                } else {
+                    macHeaderLengthInBytes -= 2;
+                }
+                /* Destination STA is non qos so change subtype to DATA */
+                *fc &= cpu_to_le16(~IEEE80211_FC_SUBTYPE_MASK);
+                *fc |= cpu_to_le16(IEEE802_11_FC_TYPE_DATA);
+                /* remove the qos control field & HTC(if present). new macHeaderLengthInBytes is less than old
+                 * macHeaderLengthInBytes so no need to verify skb headroom
+                 */
+                if (headroom < macHeaderLengthInBytes) {
+                    unifi_trace(priv, UDBG1, " sufficient headroom not there to push updated mac header \n");
+                    return -1;
+                }
+                bufPtr = (CsrUint8 *) skb_push(skb, macHeaderLengthInBytes);
+
+                /*  update bulk data os_data_ptr */
+                bulkdata->d[0].os_data_ptr = skb->data;
+                bulkdata->d[0].os_net_buf_ptr = (unsigned char*)skb;
+                bulkdata->d[0].data_length = skb->len;
+
+            } else {
+                /* pointing to QOS control field */
+                CsrUint8 qc;
+                if (*fc & cpu_to_le16(IEEE80211_FC_ORDER_MASK)) {
+                    qc = *((CsrUint8*)(macHeaderBuf + (macHeaderLengthInBytes - 4 - 2)));
+                } else {
+                    qc = *((CsrUint8*)(macHeaderBuf + (macHeaderLengthInBytes - 2)));
+                }
+
+                if ((qc & IEEE802_11_QC_TID_MASK) > 7) {
+                    *priority = 7;
+                } else {
+                    *priority = qc & IEEE802_11_QC_TID_MASK;
+                }
+
+                unifi_trace(priv, UDBG1, "Incoming packet priority from QSTA is %x\n", *priority);
+
+                if (headroom < macHeaderLengthInBytes) {
+                    unifi_trace(priv, UDBG3, " sufficient headroom not there to push updated mac header \n");
+                    return -1;
+                }
+                bufPtr = (CsrUint8 *) skb_push(skb, macHeaderLengthInBytes);
+            }
+            break;
+        default:
+            {
+                bulk_data_param_t data_ptrs;
+                CsrResult csrResult;
+                unifi_trace(priv, UDBG5, "normal Data packet, NO QOS \n");
+
+                *priority = CSR_CONTENTION;
+                if (qosDestination) {
+                    CsrUint8 qc = 0;
+                    unifi_trace(priv, UDBG3, "destination is QOS station \n");
+                    /* prepare the qos control field */
+
+                    qc |= CSR_QOS_UP0;
+
+                    /* no Amsdu is in ap buffer so eosp is left 0 */
+
+                    if (da[0] & 0x1) {
+                        /* multicast/broadcast frames, no acknowledgement needed */
+                        qc |= 1 << 5;
+                    }
+
+                    /* update new Mac header Length with 2 = sizeof(qos control) */
+                    macHeaderLengthInBytes += 2;
+
+                    /* received DATA frame but destiantion is QOS station so update subtype to QOS*/
+                    *fc &= cpu_to_le16(~IEEE80211_FC_SUBTYPE_MASK);
+                    *fc |= cpu_to_le16(IEEE802_11_FC_TYPE_QOS_DATA);
+
+                    /* appendQosControlOffset = macHeaderLengthInBytes - 2, since source sta is not QOS */
+                    macHeaderBuf[macHeaderLengthInBytes - 2] = qc;
+                    /* txopLimit is 0 */
+                    macHeaderBuf[macHeaderLengthInBytes - 1] = 0;
+                    if (headroom < macHeaderLengthInBytes) {
+                        csrResult = unifi_net_data_malloc(priv, &data_ptrs.d[0], skb->len + macHeaderLengthInBytes);
+
+                        if (csrResult != CSR_RESULT_SUCCESS) {
+                            unifi_error(priv, " failed to allocate request_data. in update_macheader func\n");
+                            return -1;
+                        }
+                        newSkb = (struct sk_buff *)(data_ptrs.d[0].os_net_buf_ptr);
+                        newSkb->len = skb->len + macHeaderLengthInBytes;
+
+                        memcpy((void*)data_ptrs.d[0].os_data_ptr + macHeaderLengthInBytes,
+                                skb->data, skb->len);
+
+                        bulkdata->d[0].os_data_ptr = newSkb->data;
+                        bulkdata->d[0].os_net_buf_ptr = (unsigned char*)newSkb;
+                        bulkdata->d[0].data_length = newSkb->len;
+
+                        bufPtr = (CsrUint8*)data_ptrs.d[0].os_data_ptr;
+
+                        /* The old skb will not be used again */
+                        kfree_skb(skb);
+                    } else {
+                        /* skb headroom is sufficient to append Macheader */
+                        bufPtr = (CsrUint8*)skb_push(skb, macHeaderLengthInBytes);
+                        bulkdata->d[0].os_data_ptr = skb->data;
+                        bulkdata->d[0].os_net_buf_ptr = (unsigned char*)skb;
+                        bulkdata->d[0].data_length = skb->len;
+                    }
+                } else {
+                    unifi_trace(priv, UDBG3, "destination is not a QSTA\n");
+                    if (headroom < macHeaderLengthInBytes) {
+                        csrResult = unifi_net_data_malloc(priv, &data_ptrs.d[0], skb->len + macHeaderLengthInBytes);
+
+                        if (csrResult != CSR_RESULT_SUCCESS) {
+                            unifi_error(priv, " failed to allocate request_data. in update_macheader func\n");
+                            return -1;
+                        }
+                        newSkb = (struct sk_buff *)(data_ptrs.d[0].os_net_buf_ptr);
+                        newSkb->len = skb->len + macHeaderLengthInBytes;
+
+                        memcpy((void*)data_ptrs.d[0].os_data_ptr + macHeaderLengthInBytes,
+                                skb->data, skb->len);
+
+                        bulkdata->d[0].os_data_ptr = newSkb->data;
+                        bulkdata->d[0].os_net_buf_ptr = (unsigned char*)newSkb;
+                        bulkdata->d[0].data_length = newSkb->len;
+
+                        bufPtr = (CsrUint8*)data_ptrs.d[0].os_data_ptr;
+
+                        /* The old skb will not be used again */
+                        kfree_skb(skb);
+                    } else {
+                        /* skb headroom is sufficient to append Macheader */
+                        bufPtr = (CsrUint8*)skb_push(skb, macHeaderLengthInBytes);
+                        bulkdata->d[0].os_data_ptr = skb->data;
+                        bulkdata->d[0].os_net_buf_ptr = (unsigned char*)skb;
+                        bulkdata->d[0].data_length = skb->len;
+                    }
+                }
+            }
+    }
+
+    /* prepare the complete skb, by pushing the MAC header to the begining of the skb->data */
+    unifi_trace(priv, UDBG5, "updated Mac Header: %d \n",macHeaderLengthInBytes);
+    memcpy(bufPtr, macHeaderBuf, macHeaderLengthInBytes);
+
+    unifi_trace(priv, UDBG5, "leaving the update_macheader function\n");
+    return 0;
+}
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_ap_process_data_pdu
+ *
+ *
+ *      Takes care of intra BSS admission control & routing packets within BSS
+ *
+ *  Arguments:
+ *      priv            Pointer to device private context struct
+ *      skb             Socket buffer containing data packet to transmit
+ *      ehdr            ethernet header to fetch priority of packet
+ *      srcStaInfo      source stations record for connection verification
+ *      packed_signal
+ *      signal_len
+ *      signal          MA-PACKET.indication signal
+ *      bulkdata        if newSkb allocated then bulkdata updated to send to unifi
+ *      macHeaderLengthInBytes no. of bytes of mac header in received frame
+ *
+ *  Returns:
+ *      Zero on success(ap processing complete) or -1 if packet also have to be sent to NETDEV.
+ * ---------------------------------------------------------------------------
+ */
+int
+uf_ap_process_data_pdu(unifi_priv_t *priv, struct sk_buff *skb,
+                       struct ethhdr *ehdr, CsrWifiRouterCtrlStaInfo_t * srcStaInfo,
+                       const CSR_SIGNAL *signal,
+                       bulk_data_param_t *bulkdata,
+                       CsrUint8 macHeaderLengthInBytes)
+{
+    const CSR_MA_PACKET_INDICATION *ind = &(signal->u.MaPacketIndication);
+    CsrUint16 interfaceTag = (ind->VirtualInterfaceIdentifier & 0x00ff);
+    struct sk_buff *newSkb = NULL;
+    /* pointer to skb or private skb created using skb_copy() */
+    struct sk_buff *skbPtr = skb;
+    CsrBool sendToNetdev = FALSE;
+    CsrBool qosDestination = FALSE;
+    CSR_PRIORITY priority = CSR_CONTENTION;
+    CsrWifiRouterCtrlStaInfo_t *dstStaInfo = NULL;
+    netInterface_priv_t *interfacePriv;
+
+    unifi_trace(priv, UDBG5, "entering  uf_ap_process_data_pdu %d\n",macHeaderLengthInBytes);
+    /* InterfaceTag validation from MA_PACKET.indication */
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_trace(priv, UDBG1, "Interface Tag is Invalid in uf_ap_process_data_pdu\n");
+        unifi_net_data_free(priv, &bulkdata->d[0]);
+        return 0;
+    }
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if((interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) &&
+       (interfacePriv->intraBssEnabled == FALSE)) {
+        unifi_trace(priv, UDBG2, "uf_ap_process_data_pdu:P2P GO intrabssEnabled?= %d\n", interfacePriv->intraBssEnabled);
+
+        /*In P2P GO case, if intraBSS distribution Disabled then don't do IntraBSS routing */
+        /* If destination in our BSS then drop otherwise give packet to netdev */
+        dstStaInfo = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, ehdr->h_dest, interfaceTag);
+        if (dstStaInfo) {
+            unifi_net_data_free(priv, &bulkdata->d[0]);
+            return 0;
+        }
+        /* May be associated P2PCLI trying to send the packets on backbone (Netdev) */
+        return -1;
+    }
+
+    if(!memcmp(ehdr->h_dest, interfacePriv->bssid.a, ETH_ALEN)) {
+        /* This packet will be given to the TCP/IP stack since this packet is for us(AP)
+         * No routing needed */
+        unifi_trace(priv, UDBG4, "destination address is csr_ap\n");
+        return -1;
+    }
+
+    /* fetch the destination record from staion record database */
+    dstStaInfo = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, ehdr->h_dest, interfaceTag);
+
+    /* AP mode processing, & if packet is unicast */
+    if(!dstStaInfo) {
+        if (!(ehdr->h_dest[0] & 0x1)) {
+            /* destination not in station record & its a unicast packet, so pass the packet to network stack */
+            unifi_trace(priv, UDBG3, "unicast frame & destination record not exist, send to netdev proto = %x\n", htons(skb->protocol));
+            return -1;
+        } else {
+            /* packet is multicast/broadcast */
+            /* copy the skb to skbPtr, send skb to netdev & skbPtr to multicast/broad cast list */
+            unifi_trace(priv, UDBG5, "skb_copy, in  uf_ap_process_data_pdu, protocol = %x\n", htons(skb->protocol));
+            skbPtr = skb_copy(skb, GFP_KERNEL);
+            if(skbPtr == NULL) {
+                /* We don't have memory to don't send the frame in BSS*/
+                unifi_notice(priv, "broacast/multicast frame can't be sent in BSS No memeory: proto = %x\n", htons(skb->protocol));
+                return -1;
+            }
+            sendToNetdev = TRUE;
+        }
+    } else {
+
+        /* validate the Peer & Destination Station record */
+        if (uf_process_station_records_for_sending_data(priv, interfaceTag, srcStaInfo, dstStaInfo)) {
+            unifi_notice(priv, "uf_ap_process_data_pdu: station record validation failed \n");
+            interfacePriv->stats.rx_errors++;
+            unifi_net_data_free(priv, &bulkdata->d[0]);
+            return 0;
+        }
+    }
+
+    /* BroadCast packet received and it's been sent as non QOS packets.
+     * Since WMM spec not mandates broadcast/multicast to be sent as QOS data only,
+     * if all Peers are QSTA
+     */
+    if(sendToNetdev) {
+       /* BroadCast packet and it's been sent as non QOS packets */
+        qosDestination = FALSE;
+    } else if(dstStaInfo && (dstStaInfo->wmmOrQosEnabled == TRUE)) {
+          qosDestination = TRUE;
+    }
+
+    unifi_trace(priv, UDBG3, "uf_ap_process_data_pdu QoS destination  = %s\n", (qosDestination)? "TRUE": "FALSE");
+
+    /* packet is allowed to send to unifi, update the Mac header */
+    if (update_macheader(priv, skbPtr, newSkb, &priority, bulkdata, interfaceTag, macHeaderLengthInBytes, qosDestination)) {
+        interfacePriv->stats.rx_errors++;
+        unifi_notice(priv, "(Packet Drop) failed to update the Mac header in uf_ap_process_data_pdu\n");
+        if (sendToNetdev) {
+            /*  Free's the skb_copy(skbPtr) data since packet processing failed */
+            bulkdata->d[0].os_data_ptr = skbPtr->data;
+            bulkdata->d[0].os_net_buf_ptr = (unsigned char*)skbPtr;
+            bulkdata->d[0].data_length = skbPtr->len;
+            unifi_net_data_free(priv, &bulkdata->d[0]);
+        }
+        return -1;
+    }
+
+    unifi_trace(priv, UDBG3, "Mac Header updated...calling uf_process_ma_packet_req \n");
+
+    /* Packet is ready to send to unifi ,transmissionControl = 0x0004, confirmation is not needed for data packets */
+    if (uf_process_ma_packet_req(priv,  ehdr->h_dest, 0xffffffff, interfaceTag, CSR_NO_CONFIRM_REQUIRED, (CSR_RATE)0,priority, priv->netdev_client->sender_id, bulkdata)) {
+        if (sendToNetdev) {
+            unifi_trace(priv, UDBG1, "In uf_ap_process_data_pdu, (Packet Drop) uf_process_ma_packet_req failed. freeing skb_copy data (original data sent to Netdev)\n");
+            /*  Free's the skb_copy(skbPtr) data since packet processing failed */
+            bulkdata->d[0].os_data_ptr = skbPtr->data;
+            bulkdata->d[0].os_net_buf_ptr = (unsigned char*)skbPtr;
+            bulkdata->d[0].data_length = skbPtr->len;
+            unifi_net_data_free(priv, &bulkdata->d[0]);
+        } else {
+            /* This free's the skb data */
+            unifi_trace(priv, UDBG1, "In uf_ap_process_data_pdu, (Packet Drop). Unicast data so freeing original skb \n");
+            unifi_net_data_free(priv, &bulkdata->d[0]);
+        }
+    }
+    unifi_trace(priv, UDBG5, "leaving  uf_ap_process_data_pdu\n");
+
+    if (sendToNetdev) {
+        /* The packet is multicast/broadcast, so after AP processing packet has to
+         * be sent to netdev, if peer port state is open
+        */
+        unifi_trace(priv, UDBG4, "Packet will be routed to NetDev\n");
+        return -1;
+    }
+    /* Ap handled the packet & its a unicast packet, no need to send to netdev */
+    return 0;
+}
+
+#endif
+
+CsrResult uf_process_ma_packet_req(unifi_priv_t *priv,
+                                   CsrUint8 *peerMacAddress,
+                                   CSR_CLIENT_TAG hostTag,
+                                   CsrUint16 interfaceTag,
+                                   CSR_TRANSMISSION_CONTROL transmissionControl,
+                                   CSR_RATE TransmitRate,
+                                   CSR_PRIORITY priority,
+                                   CSR_PROCESS_ID leSenderProcessId,
+                                   bulk_data_param_t *bulkdata)
+{
+    CsrResult status = CSR_RESULT_SUCCESS;
+    CSR_SIGNAL signal;
+    int result;
+#ifdef CSR_SUPPORT_SME
+   CsrWifiRouterCtrlStaInfo_t *staRecord = NULL;
+    const CsrUint8 *macHdrLocation =  bulkdata->d[0].os_data_ptr;
+    CsrWifiPacketType pktType;
+    int frameType = 0;
+    CsrBool queuePacketDozing = FALSE;
+    CsrUint32 priority_q;
+    CsrUint16 frmCtrl;
+    struct list_head * list = NULL; /* List to which buffered PDUs are to be enqueued*/
+    CsrBool setBcTim=FALSE;
+    netInterface_priv_t *interfacePriv;
+    CsrBool requeueOnSamePos = FALSE;
+    CsrUint32 handle = 0xFFFFFFFF;
+    unsigned long lock_flags;
+
+    UF_TRACE_MAC(priv, UDBG5, "entering uf_process_ma_packet_req, peer: ", peerMacAddress);
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "interfaceTag >= CSR_WIFI_NUM_INTERFACES, interfacetag = %d\n", interfaceTag);
+        return CSR_RESULT_FAILURE;
+    }
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+
+    /* fetch the station record for corresponding peer mac address */
+    if ((staRecord = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, peerMacAddress, interfaceTag))) {
+        handle = staRecord->assignedHandle;
+    }
+
+    /* Frame ma-packet.req, this is saved/transmitted depend on queue state */
+    unifi_frame_ma_packet_req(priv, priority, TransmitRate, hostTag,
+                              interfaceTag, transmissionControl, leSenderProcessId,
+                              peerMacAddress, &signal);
+
+   /* Since it's common path between STA & AP mode, in case of STA packet
+     * need not to be queued but in AP case we have to queue PDU's in
+     * different scenarios
+     */
+    switch(interfacePriv->interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            /* For this mode processing done below */
+            break;
+        default:
+            /* In case of STA/IBSS/P2PCLI/AMP, no checks needed send the packet down & return */
+            unifi_trace(priv, UDBG5, "In %s, interface mode is %x \n", __FUNCTION__, interfacePriv->interfaceMode);
+            if (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_NONE) {
+                unifi_warning(priv, "In %s, interface mode NONE \n", __FUNCTION__);
+            }
+            if ((result = ul_send_signal_unpacked(priv, &signal, bulkdata))) {
+                status = CSR_RESULT_FAILURE;
+            }
+            return status;
+    }
+
+    /* -----Only AP/P2pGO mode handling falls below----- */
+
+    /* convert priority to queue */
+    priority_q = unifi_frame_priority_to_queue((CSR_PRIORITY) priority);
+
+    /* check the powersave status of the peer */
+    if (staRecord && (staRecord->currentPeerState ==
+                     CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)) {
+        /* Peer is dozing & packet have to be delivered, so buffer the packet &
+         * update the TIM
+         */
+        queuePacketDozing = TRUE;
+    }
+
+    /* find the type of frame unicast or mulicast/broadcast */
+    if (*peerMacAddress & 0x1) {
+        /* Multicast/broadCast data are always triggered by vif_availability.ind
+         * at the DTIM
+         */
+        pktType = CSR_WIFI_MULTICAST_PDU;
+    } else {
+        pktType = CSR_WIFI_UNICAST_PDU;
+    }
+
+    /* Fetch the frame control field from mac header & check for frame type */
+    frmCtrl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(macHdrLocation);
+
+    /* Processing done according to Frame/Packet type */
+    frameType =  ((frmCtrl & 0x000c) >> FRAME_CONTROL_TYPE_FIELD_OFFSET);
+    switch(frameType)
+    {
+        case IEEE802_11_FRAMETYPE_MANAGEMENT:
+
+            switch(pktType)
+            {
+                case CSR_WIFI_UNICAST_PDU:
+                    unifi_trace(priv, UDBG5, "management unicast PDU in uf_process_ma_packet_req \n");
+                    /* push the packet in to the queue with appropriate mgt list */
+                    if (!staRecord) {
+                        /* push the packet to the unifi if list is empty (if packet lost how to re-enque) */
+                        if (list_empty(&interfacePriv->genericMgtFrames)) {
+#ifdef CSR_SUPPORT_SME
+                            if(!(IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag))) {
+#endif
+
+                            unifi_trace(priv, UDBG3, "genericMgtFrames list is empty uf_process_ma_packet_req \n");
+                            result = ul_send_signal_unpacked(priv, &signal, bulkdata);
+                            /*  reque only on ENOSPC */
+                            if(result == -ENOSPC) {
+                                /* requeue the failed packet to genericMgtFrame with same position */
+                                unifi_trace(priv, UDBG1, "(ENOSPC) Sending genericMgtFrames Failed so buffering\n");
+                                list = &interfacePriv->genericMgtFrames;
+                                requeueOnSamePos = TRUE;
+                            }
+#ifdef CSR_SUPPORT_SME
+                            }else{
+                                list = &interfacePriv->genericMgtFrames;
+                                unifi_trace(priv, UDBG3, "genericMgtFrames queue empty and dtim started\n hosttag is 0x%x,\n",signal.u.MaPacketRequest.HostTag);
+                                update_eosp_to_head_of_broadcast_list_head(priv,interfaceTag);
+                           }
+#endif
+                        } else {
+                            /* Queue the packet to genericMgtFrame of unifi_priv_t data structure */
+                            list = &interfacePriv->genericMgtFrames;
+                            unifi_trace(priv, UDBG2, "genericMgtFrames queue not empty\n");
+                        }
+                    } else {
+                        /* check peer power state */
+                        if (queuePacketDozing || !list_empty(&staRecord->mgtFrames) || IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag)) {
+                            /* peer is in dozing mode, so queue packet in mgt frame list of station record */
+                           /*if multicast traffic is going on, buffer the unicast packets*/
+                            list = &staRecord->mgtFrames;
+
+                            unifi_trace(priv, UDBG1, "staRecord->MgtFrames list empty? = %s, handle = %d, queuePacketDozing = %d\n",
+                                        (list_empty(&staRecord->mgtFrames))? "YES": "NO", staRecord->assignedHandle, queuePacketDozing);
+                            if(IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag)){
+                                update_eosp_to_head_of_broadcast_list_head(priv,interfaceTag);
+                            }
+
+                        } else {
+                            unifi_trace(priv, UDBG5, "staRecord->mgtFrames list is empty uf_process_ma_packet_req \n");
+                            result = ul_send_signal_unpacked(priv, &signal, bulkdata);
+                            if(result == -ENOSPC) {
+                                /* requeue the failed packet to staRecord->mgtFrames with same position */
+                                list = &staRecord->mgtFrames;
+                                requeueOnSamePos = TRUE;
+                                unifi_trace(priv, UDBG1, "(ENOSPC) Sending MgtFrames Failed handle = %d so buffering\n",staRecord->assignedHandle);
+                                priv->pausedStaHandle[0]=(CsrUint8)(staRecord->assignedHandle);
+                            } else if (result) {
+                                status = CSR_RESULT_FAILURE;
+                            }
+                        }
+                    }
+                    break;
+                case CSR_WIFI_MULTICAST_PDU:
+                    unifi_trace(priv, UDBG5, "management multicast/broadcast PDU in uf_process_ma_packet_req 'QUEUE it' \n");
+                    /* Queue the packet to genericMulticastOrBroadCastMgtFrames of unifi_priv_t data structure
+                     * will be sent when we receive VIF AVAILABILITY from firmware as part of DTIM
+                     */
+
+                    list = &interfacePriv->genericMulticastOrBroadCastMgtFrames;
+                    spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+                    interfacePriv->noOfbroadcastPktQueued++;
+                    spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+                    if((interfacePriv->interfaceMode != CSR_WIFI_ROUTER_CTRL_MODE_IBSS) &&
+                            (list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames))) {
+                        setBcTim=TRUE;
+                    }
+                    break;
+                default:
+                    unifi_error(priv, "condition never meets: packet type unrecognized\n");
+            }
+            break;
+        case IEEE802_11_FRAMETYPE_DATA:
+            switch(pktType)
+            {
+                case CSR_WIFI_UNICAST_PDU:
+                    unifi_trace(priv, UDBG5, "data unicast PDU in uf_process_ma_packet_req \n");
+                    /* check peer power state, list status & peer port status */
+                    if(!staRecord) {
+                        unifi_error(priv, "In %s unicast but staRecord = NULL\n", __FUNCTION__);
+                        return CSR_RESULT_FAILURE;
+                    } else if (queuePacketDozing || isRouterBufferEnabled(priv,priority_q)|| !list_empty(&staRecord->dataPdu[priority_q]) || IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag)) {
+                        /* peer is in dozing mode, so queue packet in mgt frame list of station record */
+                        /* if multicast traffic is going on, buffet the unicast packets */
+                        unifi_trace(priv, UDBG2, "Enqueued to staRecord->dataPdu[%d] queuePacketDozing=%d,\
+                                Buffering enabled = %d \n", priority_q,queuePacketDozing,isRouterBufferEnabled(priv,priority_q));
+                        signal.u.MaPacketRequest.TransmissionControl &= ~(CSR_NO_CONFIRM_REQUIRED);
+                        list = &staRecord->dataPdu[priority_q];
+                    } else {
+                        unifi_trace(priv, UDBG5, "staRecord->dataPdu[%d] list is empty uf_process_ma_packet_req \n", priority_q);
+                        signal.u.MaPacketRequest.TransmissionControl &= ~(CSR_NO_CONFIRM_REQUIRED);
+                        /* Pdu allowed to send to unifi */
+                        result = ul_send_signal_unpacked(priv, &signal, bulkdata);
+                        if(result == -ENOSPC) {
+                            /* requeue the failed packet to staRecord->dataPdu[priority_q] with same position */
+                            unifi_trace(priv, UDBG1, "(ENOSPC) Sending Unicast DataPDU to queue %d Failed so buffering\n",priority_q);
+                            requeueOnSamePos = TRUE;
+                            list = &staRecord->dataPdu[priority_q];
+                            priv->pausedStaHandle[priority_q]=(CsrUint8)(staRecord->assignedHandle);
+                            if(!isRouterBufferEnabled(priv,priority_q)) {
+                                unifi_error(priv,"Buffering Not enabled for queue %d \n",priority_q);
+                            }
+                        } else if (result) {
+                            status = CSR_RESULT_FAILURE;
+                        }
+                    }
+                    break;
+                case CSR_WIFI_MULTICAST_PDU:
+                    unifi_trace(priv, UDBG5, "data multicast/broadcast PDU in uf_process_ma_packet_req \n");
+                    /* Queue the packet to genericMulticastOrBroadCastFrames list of unifi_priv_t data structure
+                     * will be sent when we receive VIF AVAILABILITY from firmware as part of DTIM
+                     */
+                    list = &interfacePriv->genericMulticastOrBroadCastFrames;
+                    spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+                    interfacePriv->noOfbroadcastPktQueued++;
+                    spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+                    if(list_empty(&interfacePriv->genericMulticastOrBroadCastFrames)) {
+                        setBcTim = TRUE;
+                    }
+                    break;
+                default:
+                    unifi_error(priv, "condition never meets: packet type un recognized\n");
+            }
+            break;
+        default:
+            unifi_error(priv, "unrecognized frame type\n");
+    }
+    if(list) {
+        status = enque_tx_data_pdu(priv, bulkdata,list, &signal,requeueOnSamePos);
+        /* Record no. of packet queued for each peer */
+        if (staRecord && (pktType == CSR_WIFI_UNICAST_PDU) && (!status)) {
+            spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+            staRecord->noOfPktQueued++;
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+        }
+    }
+    if(setBcTim) {
+        unifi_trace(priv, UDBG3, "tim set due to broadcast pkt\n");
+        update_tim(priv,0,1,interfaceTag, handle);
+    } else if(staRecord && staRecord->currentPeerState ==
+                            CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE) {
+        if(staRecord->timSet == CSR_WIFI_TIM_RESET || staRecord->timSet == CSR_WIFI_TIM_RESETTING) {
+            if(!staRecord->wmmOrQosEnabled) {
+                if(!list_empty(&staRecord->mgtFrames) ||
+                   !list_empty(&staRecord->dataPdu[3]) ||
+                   !list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION])) {
+                    unifi_trace(priv, UDBG3, "tim set due to unicast pkt & peer in powersave\n");
+                    update_tim(priv,staRecord->aid,1,interfaceTag, handle);
+                }
+            } else {
+                /* Check for non delivery enable(i.e trigger enable), all delivery enable & legacy AC for TIM update in firmware */
+                CsrUint8 allDeliveryEnabled = 0, dataAvailable = 0;
+                /* Check if all AC's are Delivery Enabled */
+                is_all_ac_deliver_enabled_and_moredata(staRecord, &allDeliveryEnabled, &dataAvailable);
+                if (uf_is_more_data_for_non_delivery_ac(staRecord) || (allDeliveryEnabled && dataAvailable)) {
+                    update_tim(priv,staRecord->aid,1,interfaceTag, handle);
+                }
+            }
+        }
+    }
+
+    if((list) && (pktType == CSR_WIFI_UNICAST_PDU && !queuePacketDozing) && !(isRouterBufferEnabled(priv,priority_q)) && !(IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag))) {
+        unifi_trace(priv, UDBG2, "buffering cleared for queue = %d So resending buffered frames\n",priority_q);
+        uf_send_buffered_frames(priv, priority_q);
+    }
+    unifi_trace(priv, UDBG5, "leaving uf_process_ma_packet_req \n");
+    return status;
+#else
+#ifdef CSR_NATIVE_LINUX
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "interfaceTag >= CSR_WIFI_NUM_INTERFACES, interfacetag = %d\n", interfaceTag);
+        return CSR_RESULT_FAILURE;
+    }
+    /* Frame ma-packet.req, this is saved/transmitted depend on queue state */
+    unifi_frame_ma_packet_req(priv, priority, TransmitRate, hostTag, interfaceTag,
+            transmissionControl, leSenderProcessId,
+            peerMacAddress, &signal);
+    result = ul_send_signal_unpacked(priv, &signal, bulkdata);
+    if (result) {
+        return CSR_RESULT_FAILURE;
+    }
+#endif
+    return status;
+#endif
+}
+
+#ifdef CSR_SUPPORT_SME
+CsrInt8 uf_get_protection_bit_from_interfacemode(unifi_priv_t *priv, CsrUint16 interfaceTag, const CsrUint8 *daddr)
+{
+    CsrInt8 protection = 0;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    switch(interfacePriv->interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_STA:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:
+        case CSR_WIFI_ROUTER_CTRL_MODE_AMP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_IBSS:
+            protection = interfacePriv->protect;
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            {
+                CsrWifiRouterCtrlStaInfo_t *dstStaInfo = NULL;
+                if (daddr[0] & 0x1) {
+                    unifi_trace(priv, UDBG3, "broadcast/multicast packet in send_ma_pkt_request\n");
+                    /* In this mode, the protect member of priv structure has an information of how
+                     * AP/P2PGO has started, & the member updated in set mode request for AP/P2PGO
+                     */
+                    protection = interfacePriv->protect;
+                } else {
+                    /* fetch the destination record from staion record database */
+                    dstStaInfo = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, daddr, interfaceTag);
+                    if (!dstStaInfo) {
+                        unifi_trace(priv, UDBG3, "peer not found in station record in send_ma_pkt_request\n");
+                        return -1;
+                    }
+                    protection = dstStaInfo->protection;
+                }
+            }
+            break;
+        default:
+            unifi_trace(priv, UDBG2, "mode unknown in send_ma_pkt_request\n");
+    }
+    return protection;
+}
+#endif
+#ifdef CSR_SUPPORT_SME
+CsrUint8 send_multicast_frames(unifi_priv_t *priv, CsrUint16 interfaceTag)
+{
+    int r;
+    tx_buffered_packets_t * buffered_pkt = NULL;
+    CsrBool moreData = FALSE;
+    CsrUint8 pduSent =0;
+    unsigned long lock_flags;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    CsrUint32 hostTag = 0xffffffff;
+
+    func_enter();
+    if(!isRouterBufferEnabled(priv,UNIFI_TRAFFIC_Q_VO)) {
+        while((interfacePriv->dtimActive)&& (buffered_pkt=dequeue_tx_data_pdu(priv,&interfacePriv->genericMulticastOrBroadCastMgtFrames))) {
+            buffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK);
+            moreData = (buffered_pkt->transmissionControl & TRANSMISSION_CONTROL_ESOP_MASK)?FALSE:TRUE;
+
+
+            unifi_trace(priv,UDBG2,"DTIM Occurred for interface:sending Mgt packet %d\n",interfaceTag);
+
+            if((r=frame_and_send_queued_pdu(priv,buffered_pkt,NULL,moreData,FALSE)) == -ENOSPC) {
+               unifi_trace(priv,UDBG1,"frame_and_send_queued_pdu failed with ENOSPC for host tag = %x\n", buffered_pkt->hostTag);
+               /* Enqueue at the head of the queue */
+               spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+               list_add(&buffered_pkt->q, &interfacePriv->genericMulticastOrBroadCastMgtFrames);
+               spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+               break;
+            } else {
+                unifi_trace(priv,UDBG1,"send_multicast_frames: Send genericMulticastOrBroadCastMgtFrames (%x, %x)\n",
+                                        buffered_pkt->hostTag,
+                                        r);
+                if(r) {
+                   unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+                }
+                if(!moreData) {
+
+                    interfacePriv->dtimActive = FALSE;
+                    if(!r) {
+                        hostTag = buffered_pkt->hostTag;
+                        pduSent++;
+                    } else {
+                        send_vif_availibility_rsp(priv,uf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag),CSR_RC_UNSPECIFIED_FAILURE);
+                    }
+                }
+                /* Buffered frame sent successfully */
+                spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+                interfacePriv->noOfbroadcastPktQueued--;
+                spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+                kfree(buffered_pkt);
+           }
+
+        }
+    }
+    if(!isRouterBufferEnabled(priv,UNIFI_TRAFFIC_Q_CONTENTION)) {
+        while((interfacePriv->dtimActive)&& (buffered_pkt=dequeue_tx_data_pdu(priv,&interfacePriv->genericMulticastOrBroadCastFrames))) {
+            buffered_pkt->transmissionControl |= TRANSMISSION_CONTROL_TRIGGER_MASK;
+            moreData = (buffered_pkt->transmissionControl & TRANSMISSION_CONTROL_ESOP_MASK)?FALSE:TRUE;
+
+
+            if((r=frame_and_send_queued_pdu(priv,buffered_pkt,NULL,moreData,FALSE)) == -ENOSPC) {
+                /* Clear the trigger bit transmission control*/
+                buffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK);
+                /* Enqueue at the head of the queue */
+                spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                list_add(&buffered_pkt->q, &interfacePriv->genericMulticastOrBroadCastFrames);
+                spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+                break;
+            } else {
+                if(r) {
+                    unifi_trace(priv,UDBG1,"send_multicast_frames: Send genericMulticastOrBroadCastFrame failed (%x, %x)\n",
+                                            buffered_pkt->hostTag,
+                                            r);
+                    unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+                }
+                if(!moreData) {
+                    interfacePriv->dtimActive = FALSE;
+                    if(!r) {
+                        pduSent ++;
+                        hostTag = buffered_pkt->hostTag;
+                    } else {
+                        send_vif_availibility_rsp(priv,uf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag),CSR_RC_UNSPECIFIED_FAILURE);
+                    }
+                }
+                /* Buffered frame sent successfully */
+                spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+                interfacePriv->noOfbroadcastPktQueued--;
+                spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+                kfree(buffered_pkt);
+            }
+        }
+    }
+    if((interfacePriv->dtimActive == FALSE)) {
+        /* Record the host Tag*/
+        unifi_trace(priv,UDBG2,"send_multicast_frames: Recorded hostTag of EOSP packet: = 0x%x\n",hostTag);
+        interfacePriv->multicastPduHostTag = hostTag;
+    }
+    return pduSent;
+}
+#endif
+void uf_process_ma_vif_availibility_ind(unifi_priv_t *priv,CsrUint8 *sigdata,
+                                        CsrUint32 siglen)
+{
+#ifdef CSR_SUPPORT_SME
+    CSR_SIGNAL signal;
+    CSR_MA_VIF_AVAILABILITY_INDICATION *ind;
+    int r;
+    CsrUint16 interfaceTag;
+    CsrUint8 pduSent =0;
+    CSR_RESULT_CODE resultCode = CSR_RC_SUCCESS;
+    netInterface_priv_t *interfacePriv;
+
+    func_enter();
+    unifi_trace(priv, UDBG3,
+            "uf_process_ma_vif_availibility_ind: Process signal 0x%.4X\n",
+            *((CsrUint16*)sigdata));
+
+    r = read_unpack_signal(sigdata, &signal);
+    if (r) {
+        unifi_error(priv,
+                    "uf_process_ma_vif_availibility_ind: Received unknown signal 0x%.4X.\n",
+                    CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata));
+        func_exit();
+        return;
+    }
+    ind = &signal.u.MaVifAvailabilityIndication;
+    interfaceTag=ind->VirtualInterfaceIdentifier & 0xff;
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "in vif_availability_ind interfaceTag is wrong\n");
+        return;
+    }
+
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if(ind->Multicast) {
+        if(list_empty(&interfacePriv->genericMulticastOrBroadCastFrames) &&
+            list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames)) {
+            /* This condition can occur because of a potential race where the
+               TIM is not yet reset as host is waiting for confirm but it is sent
+               by firmware and DTIM occurs*/
+            unifi_notice(priv,"ma_vif_availibility_ind recevied for multicast but queues are empty%d\n",interfaceTag);
+            send_vif_availibility_rsp(priv,ind->VirtualInterfaceIdentifier,CSR_RC_NO_BUFFERED_BROADCAST_MULTICAST_FRAMES);
+            interfacePriv->dtimActive = FALSE;
+            if(interfacePriv->multicastPduHostTag == 0xffffffff) {
+                unifi_notice(priv,"ma_vif_availibility_ind recevied for multicast but queues are empty%d\n",interfaceTag);
+                /* This may be an extra request in very rare race conditions but it is fine as it would atleast remove the potential lock up */
+                update_tim(priv,0,0,interfaceTag, 0xFFFFFFFF);
+            }
+            return;
+        }
+        if(interfacePriv->dtimActive) {
+            unifi_trace(priv,UDBG2,"DTIM Occurred for already active DTIM interface %d\n",interfaceTag);
+            return;
+        } else {
+            unifi_trace(priv,UDBG2,"DTIM Occurred for interface %d\n",interfaceTag);
+            if(list_empty(&interfacePriv->genericMulticastOrBroadCastFrames)) {
+                set_eosp_transmit_ctrl(priv,&interfacePriv->genericMulticastOrBroadCastMgtFrames);
+            } else {
+                set_eosp_transmit_ctrl(priv,&interfacePriv->genericMulticastOrBroadCastFrames);
+            }
+        }
+        interfacePriv->dtimActive = TRUE;
+        pduSent = send_multicast_frames(priv,interfaceTag);
+    }
+    else {
+        unifi_error(priv,"Interface switching is not supported %d\n",interfaceTag);
+        resultCode = CSR_RC_NOT_SUPPORTED;
+        send_vif_availibility_rsp(priv,ind->VirtualInterfaceIdentifier,CSR_RC_NOT_SUPPORTED);
+    }
+#endif
+}
+#ifdef CSR_SUPPORT_SME
+
+#define  GET_ACTIVE_INTERFACE_TAG(priv) 0
+
+
+void uf_continue_uapsd(unifi_priv_t *priv, CsrWifiRouterCtrlStaInfo_t * staInfo)
+{
+
+    CsrInt8 i;
+
+    func_enter();
+
+    if(((staInfo->powersaveMode[UNIFI_TRAFFIC_Q_VO]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED)||
+         (staInfo->powersaveMode[UNIFI_TRAFFIC_Q_VO]==CSR_WIFI_AC_DELIVERY_ONLY_ENABLE))
+        &&(!list_empty(&staInfo->mgtFrames))){
+
+        unifi_trace(priv, UDBG5, "uf_continue_uapsd : U-APSD ACTIVE and sending buffered mgt frames\n");
+        uf_send_buffered_data_from_delivery_ac(priv, staInfo, UNIFI_TRAFFIC_Q_VO, &staInfo->mgtFrames);
+
+        /*This may happen because U-APSD was completed
+         with previous AC transfer*/
+
+        if(staInfo->uapsdActive == FALSE) {
+           return;
+        }
+    }
+
+    for(i=3;i>=0;i--) {
+
+        if(((staInfo->powersaveMode[i]== CSR_WIFI_AC_DELIVERY_ONLY_ENABLE)
+             ||(staInfo->powersaveMode[i] == CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED))
+             &&(!list_empty(&staInfo->dataPdu[i]))) {
+            unifi_trace(priv, UDBG5, "uf_continue_uapsd : U-APSD ACTIVE and sending buffered  data frames\n");
+            uf_send_buffered_data_from_delivery_ac(priv, staInfo, i, &staInfo->dataPdu[i]);
+        }
+
+        /*This may happen because U-APSD was completed
+          with previous AC transfer*/
+        if (staInfo->uapsdActive == FALSE) {
+            return;
+        }
+    }
+
+    if (staInfo->uapsdActive && !uf_is_more_data_for_delivery_ac(priv, staInfo, TRUE)) {
+        /* If last packet not able to transfer due to ENOSPC & buffer management algorithm
+         * would have removed last packet. Then we wont update staInfo->UapsdActive = FALSE (suppose
+         * to update as we dont have packet to transfer at this USP) because above if loop fails as list is empty &
+         * update of UAPSD activity done in uf_send_buffered_data_from_delivery_ac().
+         * In this situation we send QOS null & mean time update UapsdActive to FALSE here
+         */
+        staInfo->uapsdActive = FALSE;
+        uf_send_qos_null(priv, GET_ACTIVE_INTERFACE_TAG(priv), staInfo->peerMacAddress.a, CSR_QOS_UP0 , staInfo);
+    }
+    func_exit();
+}
+
+
+void uf_send_buffered_data_from_delivery_ac(unifi_priv_t *priv,
+                                            CsrWifiRouterCtrlStaInfo_t * staInfo,
+                                            CsrUint8 queue,
+                                            struct list_head *txList)
+{
+
+    CsrUint16 interfaceTag = GET_ACTIVE_INTERFACE_TAG(priv);
+    tx_buffered_packets_t * buffered_pkt = NULL;
+    unsigned long lock_flags;
+    CsrBool eosp=FALSE;
+    CsrInt8 r =0;
+    CsrBool moreData = FALSE;
+
+    CsrUint8 allDeliveryEnabled = 0, dataAvailable = 0;
+    netInterface_priv_t *interfacePriv;
+    interfacePriv = priv->interfacePriv[interfaceTag];
+    func_enter();
+
+    /*Check U-APSD conditions if not met return from here*/
+    if((staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)&&
+        (staInfo->uapsdActive == TRUE)&&
+        (!IS_DELIVERY_AND_TRIGGER_ENABLED(staInfo->powersaveMode[queue]))){
+
+        unifi_trace(priv,UDBG4,"uf_send_buffered_data_from_queue : U-APSD active. %d :Queue NOT delivery enbaled.return %\n",queue);
+
+        return;
+     }
+
+    while(!isRouterBufferEnabled(priv,queue) &&
+                    ((buffered_pkt=dequeue_tx_data_pdu(priv, txList))!=NULL)){
+        if((IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag))){
+            spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+            staInfo->uapsdSuspended = TRUE;
+            staInfo->uapsdActive = FALSE;
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+            /* re-queueing the packet as DTIM started */
+            spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+            list_add(&buffered_pkt->q,txList);
+            spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+            unifi_trace(priv, UDBG3, "%s: DTIM Active while UAPSD in progress for staId: 0x%x\n",__FUNCTION__,staInfo->aid);
+            break;
+        }
+
+        buffered_pkt->transmissionControl &=
+                 ~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_ESOP_MASK);
+
+
+        if((staInfo->wmmOrQosEnabled == TRUE)&&(staInfo->uapsdActive == TRUE)){
+
+            moreData = uf_is_more_data_for_delivery_ac(priv,staInfo,TRUE);
+
+             buffered_pkt->transmissionControl = TRANSMISSION_CONTROL_TRIGGER_MASK;
+
+            if(staInfo->noOfSpFramesSent == (staInfo->maxSpLength-1)){
+                moreData = FALSE;
+            }
+
+            if(moreData == FALSE){
+                 eosp = TRUE;
+                 staInfo->uapsdActive = FALSE;
+                 staInfo->noOfSpFramesSent = FALSE;
+                 buffered_pkt->transmissionControl =
+                          (TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_ESOP_MASK);
+
+                /* Check if all AC's are Delivery Enabled */
+                is_all_ac_deliver_enabled_and_moredata(staInfo, &allDeliveryEnabled, &dataAvailable);
+                if ((allDeliveryEnabled && !dataAvailable)) {
+                    update_tim(priv,staInfo->aid,0,interfaceTag, staInfo->assignedHandle);
+                }
+                /* check the moer data for non delivery ac and update accordingly */
+                else if(uf_is_more_data_for_non_delivery_ac(staInfo) ) {
+                    update_tim(priv,staInfo->aid,1,interfaceTag, staInfo->assignedHandle);
+                }
+                else if(!uf_is_more_data_for_non_delivery_ac(staInfo) ){
+                     unifi_trace(priv, UDBG3, "more data = NULL, set tim to 0 in uf_send_buffered_data_from_delivery_ac\n");
+                     update_tim(priv,staInfo->aid,0,interfaceTag, staInfo->assignedHandle);
+                }
+
+             }
+        }
+        else
+        {
+          /*Non QoS and non U-APSD.*/
+            eosp = FALSE;
+            moreData = FALSE;
+            unifi_warning(priv,"uf_send_buffered_data_from_delivery_ac :non U-APSD !!! \n");
+        }
+
+        unifi_trace(priv,UDBG2,"uf_send_buffered_data_from_delivery_ac : MoreData:%d, EOSP:%d\n",moreData,eosp);
+
+        if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staInfo,moreData,eosp)) == -ENOSPC) {
+           /* Enqueue at the head of the queue */
+           spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+           list_add(&buffered_pkt->q,txList);
+           spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+           priv->pausedStaHandle[queue]=(CsrUint8)(staInfo->assignedHandle);
+           unifi_notice (priv," U-APSD: PDU sending failed .. no space for queue %d \n",queue);
+           /*Break the loop for this queue.Try for next available Delivery enabled
+           Queue*/
+           break;
+        } else {
+            if(r){
+                /* the PDU failed where we can't do any thing so free the storage */
+                unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+            }
+
+            kfree(buffered_pkt);
+            if(staInfo->uapsdActive == TRUE){
+                    spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+                    staInfo->noOfSpFramesSent = staInfo->noOfSpFramesSent + 1;
+                    if(staInfo->noOfSpFramesSent == staInfo->maxSpLength){
+                        staInfo->uapsdActive = FALSE;
+                        staInfo->noOfSpFramesSent = FALSE;
+                        spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+                        break;
+                    }
+                spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+            }
+        }
+    }
+
+   func_exit();
+
+}
+
+void uf_send_buffered_data_from_ac(unifi_priv_t *priv,
+                                   CsrWifiRouterCtrlStaInfo_t * staInfo,
+                                   CsrUint8 queue,
+                                   struct list_head *txList)
+{
+    tx_buffered_packets_t * buffered_pkt = NULL;
+    unsigned long lock_flags;
+    CsrBool eosp=FALSE;
+    CsrBool moreData = FALSE;
+    CsrInt8 r =0;
+
+    func_enter();
+
+    unifi_trace(priv,UDBG2,"uf_send_buffered_data_from_ac :\n");
+
+    while(!isRouterBufferEnabled(priv,queue) &&
+                    ((buffered_pkt=dequeue_tx_data_pdu(priv, txList))!=NULL)){
+
+        buffered_pkt->transmissionControl &=
+                 ~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_ESOP_MASK);
+
+        unifi_trace(priv,UDBG3,"uf_send_buffered_data_from_ac : MoreData:%d, EOSP:%d\n",moreData,eosp);
+
+        if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staInfo,moreData,eosp)) == -ENOSPC) {
+           /* Enqueue at the head of the queue */
+           spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+           list_add(&buffered_pkt->q,txList);
+           spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+           if(staInfo != NULL){
+              priv->pausedStaHandle[queue]=(CsrUint8)(staInfo->assignedHandle);
+           }
+           unifi_trace(priv,UDBG3," uf_send_buffered_data_from_ac: PDU sending failed .. no space for queue %d \n",queue);
+           } else {
+            if(r){
+                /* the PDU failed where we can't do any thing so free the storage */
+                unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+            }
+            kfree(buffered_pkt);
+      }
+  }
+
+  func_exit();
+
+}
+
+void uf_send_buffered_frames(unifi_priv_t *priv,unifi_TrafficQueue q)
+{
+    CsrUint16 interfaceTag = GET_ACTIVE_INTERFACE_TAG(priv);
+    CsrUint32 startIndex=0,endIndex=0;
+    CsrWifiRouterCtrlStaInfo_t * staInfo = NULL;
+    CsrUint8 queue;
+    CsrBool moreData = FALSE;
+
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if(!((interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP) ||
+        (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO)))
+        return;
+    func_enter();
+
+    queue = (q<=3)?q:0;
+
+    if(interfacePriv->dtimActive) {
+        /* this function updates dtimActive*/
+        send_multicast_frames(priv,interfaceTag);
+        if(!interfacePriv->dtimActive) {
+            moreData = (!list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames) ||
+             !list_empty(&interfacePriv->genericMulticastOrBroadCastFrames));
+            if(!moreData) {
+                update_tim(priv,0,0,interfaceTag, 0XFFFFFFFF);
+            }
+        } else {
+            moreData = (!list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames) ||
+                        !list_empty(&interfacePriv->genericMulticastOrBroadCastFrames));
+           if(!moreData) {
+               /* This should never happen but if it happens, we need a way out */
+               unifi_error(priv,"ERROR: No More Data but DTIM is active sending Response\n");
+               send_vif_availibility_rsp(priv,uf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag),CSR_RC_NO_BUFFERED_BROADCAST_MULTICAST_FRAMES);
+               interfacePriv->dtimActive = FALSE;
+           }
+        }
+        func_exit();
+        return;
+    }
+    if(priv->pausedStaHandle[queue] > 7) {
+        priv->pausedStaHandle[queue] = 0;
+    }
+
+    if(queue == UNIFI_TRAFFIC_Q_VO) {
+
+
+        unifi_trace(priv,UDBG2,"uf_send_buffered_frames : trying mgt from queue=%d\n",queue);
+        for(startIndex= 0; startIndex < UNIFI_MAX_CONNECTIONS;startIndex++) {
+            staInfo =  CsrWifiRouterCtrlGetStationRecordFromHandle(priv,startIndex,interfaceTag);
+            if(!staInfo ) {
+                continue;
+            } else if((staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)
+                       &&(staInfo->uapsdActive == FALSE) ) {
+                continue;
+            }
+
+            if((staInfo != NULL)&&(staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE)
+                               &&(staInfo->uapsdActive == FALSE)){
+                            /*Non-UAPSD case push the management frames out*/
+               if(!list_empty(&staInfo->mgtFrames)){
+                    uf_send_buffered_data_from_ac(priv,staInfo, UNIFI_TRAFFIC_Q_VO, &staInfo->mgtFrames);
+                }
+            }
+            else if((staInfo != NULL)&&(staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)
+                               &&(staInfo->uapsdActive == TRUE)&&(IS_DELIVERY_AND_TRIGGER_ENABLED(staInfo->powersaveMode[UNIFI_TRAFFIC_Q_VO]))){
+
+
+                if(!list_empty(&staInfo->mgtFrames)){
+                    /*UNIFI_TRAFFIC_Q_VO is delivery enabled push the managment frames out*/
+                    uf_send_buffered_data_from_delivery_ac(priv, staInfo, UNIFI_TRAFFIC_Q_VO, &staInfo->mgtFrames);
+
+                }
+            }
+
+            if(isRouterBufferEnabled(priv,queue)) {
+                unifi_notice(priv,"uf_send_buffered_frames : No space Left for queue = %d\n",queue);
+                break;
+            }
+        }
+
+
+        /*push generic management frames out*/
+
+        if(!list_empty(&interfacePriv->genericMgtFrames)){
+
+        unifi_trace(priv,UDBG2,"uf_send_buffered_frames : trying generic mgt from queue=%d\n",queue);
+        uf_send_buffered_data_from_ac(priv,staInfo, UNIFI_TRAFFIC_Q_VO, &interfacePriv->genericMgtFrames);
+
+        }
+
+    }
+
+
+    unifi_trace(priv,UDBG2,"uf_send_buffered_frames : Resume called for Queue=%d\n",queue);
+    unifi_trace(priv,UDBG2,"uf_send_buffered_frames : start=%d end=%d\n",startIndex,endIndex);
+
+    startIndex = priv->pausedStaHandle[queue];
+    endIndex = (startIndex + UNIFI_MAX_CONNECTIONS -1) % UNIFI_MAX_CONNECTIONS;
+
+    while(startIndex != endIndex) {
+        staInfo =  CsrWifiRouterCtrlGetStationRecordFromHandle(priv,startIndex,interfaceTag);
+        if(!staInfo) {
+            startIndex ++;
+            if(startIndex >= UNIFI_MAX_CONNECTIONS){
+                startIndex = 0;
+            }
+            continue;
+        } else if((staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)
+                   &&(staInfo->uapsdActive == FALSE)){
+            startIndex ++;
+            if(startIndex >= UNIFI_MAX_CONNECTIONS){
+                startIndex = 0;
+            }
+            continue;
+        }
+        /* Peer is active or U-APSD is active so send PDUs to the peer */
+        unifi_trace(priv,UDBG2,"uf_send_buffered_frames : trying data from queue=%d\n",queue);
+
+
+        if((staInfo != NULL)&&(staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE)
+                           &&(staInfo->uapsdActive == FALSE)){
+
+           if(!list_empty(&staInfo->dataPdu[queue])){
+
+          /*Non-UAPSD case push the AC frames out*/
+            uf_send_buffered_data_from_ac(priv, staInfo, queue, (&staInfo->dataPdu[queue]));
+           }
+        }
+        else  if((staInfo != NULL)&&(staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)
+                               &&(staInfo->uapsdActive == TRUE)&&(IS_DELIVERY_AND_TRIGGER_ENABLED(staInfo->powersaveMode[queue]))){
+            if(!list_empty(&staInfo->dataPdu[queue])){
+            uf_send_buffered_data_from_delivery_ac(priv, staInfo, queue, &staInfo->dataPdu[queue]);
+            }
+        }
+
+        startIndex ++;
+        if(startIndex >= UNIFI_MAX_CONNECTIONS){
+           startIndex = 0;
+        }
+    }
+    if(isRouterBufferEnabled(priv,queue)) {
+        priv->pausedStaHandle[queue] = endIndex;
+    } else {
+        priv->pausedStaHandle[queue] = 0;
+    }
+
+   /*U-APSD might have stopped because of pause.So restart it if U-APSD
+   was active with any of the station*/
+    for(startIndex= 0; startIndex < UNIFI_MAX_CONNECTIONS;startIndex++) {
+        staInfo =  CsrWifiRouterCtrlGetStationRecordFromHandle(priv,startIndex,interfaceTag);
+        if(!staInfo ) {
+            continue;
+        } else if((staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)
+                   &&(staInfo->uapsdActive == TRUE)) {
+
+            /*U-APSD Still active, it means trigger frame is received,so continue U-APSD by
+            sending data from remaining delivery enabled queues*/
+            uf_continue_uapsd(priv,staInfo);
+        }
+    }
+    func_exit();
+}
+
+CsrBool uf_is_more_data_for_delivery_ac(unifi_priv_t *priv,CsrWifiRouterCtrlStaInfo_t *staRecord,CsrBool mgtCheck)
+{
+    CsrUint8 i;
+
+    for(i=0;i<=3;i++)
+    {
+     if(((staRecord->powersaveMode[i]==CSR_WIFI_AC_DELIVERY_ONLY_ENABLE)
+            ||(staRecord->powersaveMode[i]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED))
+            &&(!list_empty(&staRecord->dataPdu[i]))){
+          unifi_trace(priv,UDBG2,"uf_is_more_data_for_delivery_ac: Data Available \n");
+         return TRUE;
+        }
+    }
+    if((mgtCheck == TRUE)&&(IS_DELIVERY_AND_TRIGGER_ENABLED(staRecord->powersaveMode[UNIFI_TRAFFIC_Q_VO]))
+        &&(!list_empty(&staRecord->mgtFrames))){
+
+        unifi_trace(priv,UDBG2,"uf_is_more_data_for_delivery_ac: Management Data Available \n");
+
+        return TRUE;
+    }
+
+    unifi_trace(priv,UDBG2,"uf_is_more_data_for_delivery_ac: Data NOT Available \n");
+    return FALSE;
+}
+
+CsrBool uf_is_more_data_for_non_delivery_ac(CsrWifiRouterCtrlStaInfo_t *staRecord)
+{
+    CsrUint8 i;
+
+    for(i=0;i<=3;i++)
+    {
+        if(((staRecord->powersaveMode[i]==CSR_WIFI_AC_TRIGGER_ONLY_ENABLED)
+                ||(staRecord->powersaveMode[i]==CSR_WIFI_AC_LEGACY_POWER_SAVE))
+                &&(!list_empty(&staRecord->dataPdu[i]))){
+
+         return TRUE;
+        }
+    }
+
+    if(((staRecord->powersaveMode[UNIFI_TRAFFIC_Q_VO]==CSR_WIFI_AC_TRIGGER_ONLY_ENABLED)
+            ||(staRecord->powersaveMode[UNIFI_TRAFFIC_Q_VO]==CSR_WIFI_AC_LEGACY_POWER_SAVE))
+            &&(!list_empty(&staRecord->mgtFrames))){
+
+     return TRUE;
+    }
+
+
+
+    return FALSE;
+}
+
+
+int uf_process_station_records_for_sending_data(unifi_priv_t *priv,CsrUint16 interfaceTag,
+                                                 CsrWifiRouterCtrlStaInfo_t *srcStaInfo,
+                                                 CsrWifiRouterCtrlStaInfo_t *dstStaInfo)
+{
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    unifi_trace(priv, UDBG5, "entering uf_process_station_records_for_sending_data\n");
+
+    if (srcStaInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_DISCONNECTED) {
+        unifi_error(priv, "Peer State not connected AID = %x, handle = %x, control port state = %x\n",
+                    srcStaInfo->aid, srcStaInfo->assignedHandle, srcStaInfo->peerControlledPort->port_action);
+        return -1;
+    }
+    switch (interfacePriv->interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+            unifi_trace(priv, UDBG5, "mode is AP/P2PGO\n");
+            break;
+        default:
+            unifi_warning(priv, "mode is nor AP neither P2PGO, packet cant be xmit\n");
+            return -1;
+    }
+
+    switch(dstStaInfo->peerControlledPort->port_action)
+    {
+        case CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD:
+        case CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_BLOCK:
+            unifi_trace(priv, UDBG5, "destination port is closed/blocked, discarding the packet\n");
+            return -1;
+        default:
+            unifi_trace(priv, UDBG5, "destination port state is open\n");
+    }
+
+    /* port state is open, destination station record is valid, Power save state is
+     * validated in uf_process_ma_packet_req function
+     */
+    unifi_trace(priv, UDBG5, "leaving uf_process_station_records_for_sending_data\n");
+    return 0;
+}
+
+void uf_process_wmm_deliver_ac_uapsd(unifi_priv_t * priv,
+                                     CsrWifiRouterCtrlStaInfo_t * srcStaInfo,
+                                     CsrUint16 qosControl,
+                                     CsrUint16 interfaceTag)
+{
+
+    CSR_PRIORITY priority;
+    CsrInt8 i;
+    unifi_TrafficQueue priority_q;
+    unsigned long lock_flags;
+
+    func_enter();
+
+    /* start the U-APSD operation only if it not active*/
+    if(srcStaInfo->uapsdActive == FALSE){
+        /*if recceived Frames trigger Frame and Devlivery enabled AC has data
+         then transmit from High priorty delivery enabled AC*/
+
+
+        priority = (CSR_PRIORITY)(qosControl & IEEE802_11_QC_TID_MASK);
+
+        priority_q = unifi_frame_priority_to_queue((CSR_PRIORITY) priority);
+
+      if((srcStaInfo->powersaveMode[priority_q]==CSR_WIFI_AC_TRIGGER_ONLY_ENABLED)
+          ||(srcStaInfo->powersaveMode[priority_q]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED)){
+
+          unifi_trace(priv, UDBG3, "uf_process_wmm_deliver_ac_uapsd starting U-APSD operations\n");
+
+          /*Received Frame is trigger frame*/
+        unifi_trace(priv, UDBG5, "uf_process_wmm_deliver_ac_uapsd : Received Frame is trigger frame %d\n",priority_q);
+
+        if(((srcStaInfo->powersaveMode[UNIFI_TRAFFIC_Q_VO]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED)||
+             (srcStaInfo->powersaveMode[UNIFI_TRAFFIC_Q_VO]==CSR_WIFI_AC_DELIVERY_ONLY_ENABLE))
+            &&(!list_empty(&srcStaInfo->mgtFrames))){
+
+            /*Trigger frame received and Data available in Delivery enabled AC
+            or in Management queue when UNIFI_TRAFFIC_Q_VO is delivery enabled*/
+            spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+            srcStaInfo->uapsdActive = TRUE;
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+
+            unifi_trace(priv, UDBG5, "uf_process_wmm_deliver_ac_uapsd : U-APSD ACTIVE and sending buffered mgt frames\n");
+
+           /* uf_send_buffered_frames(priv, priority_q); */
+            uf_send_buffered_data_from_delivery_ac(priv, srcStaInfo, UNIFI_TRAFFIC_Q_VO, &srcStaInfo->mgtFrames);
+
+
+           /*This may happen because U-APSD was completed
+            with previous AC transfer*/
+
+           if(srcStaInfo->uapsdActive == FALSE){
+              return;
+           }
+
+         }
+
+
+        for(i=3;i>=0;i--){
+
+            if(((srcStaInfo->powersaveMode[i]==CSR_WIFI_AC_DELIVERY_ONLY_ENABLE)
+                ||(srcStaInfo->powersaveMode[i]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED))
+                &&(!list_empty(&srcStaInfo->dataPdu[i]))){
+
+
+                 /*Trigger frame received and Data available in Delivery enabled AC
+                 or in Management queue when UNIFI_TRAFFIC_Q_VO is delivery enabled*/
+                 spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+                 srcStaInfo->uapsdActive = TRUE;
+                 spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+
+                 unifi_trace(priv, UDBG5, "uf_process_wmm_deliver_ac_uapsd : U-APSD ACTIVE and sending buffered  data frames\n");
+
+                 uf_send_buffered_data_from_delivery_ac(priv, srcStaInfo, i, &srcStaInfo->dataPdu[i]);
+
+                 /*This may happen because U-APSD was completed
+                  with previous AC transfer*/
+
+                 if(srcStaInfo->uapsdActive == FALSE){
+                    return;
+                 }
+            }
+
+         }
+         if(srcStaInfo->uapsdActive == FALSE && !(uf_is_more_data_for_delivery_ac(priv,srcStaInfo,TRUE))){
+             unifi_trace(priv, UDBG3, "uf_process_wmm_deliver_ac_uapsd : No buffer frames so sending QOS Null in response of trigger frame\n");
+             uf_send_qos_null(priv,interfaceTag,srcStaInfo->peerMacAddress.a,priority,srcStaInfo);
+         }
+
+      }
+
+  }
+
+  func_exit();
+
+}
+void uf_send_qos_null(unifi_priv_t * priv,CsrUint16 interfaceTag, const CsrUint8 *da,CSR_PRIORITY priority,CsrWifiRouterCtrlStaInfo_t * srcStaInfo)
+{
+    bulk_data_param_t bulkdata;
+    CsrResult csrResult;
+    struct sk_buff *skb, *newSkb = NULL;
+    CsrWifiMacAddress peerAddress;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    CSR_TRANSMISSION_CONTROL transmissionControl = (TRANSMISSION_CONTROL_ESOP_MASK | TRANSMISSION_CONTROL_TRIGGER_MASK);
+    int r;
+    CSR_SIGNAL signal;
+    CsrUint32 priority_q;
+    CSR_RATE transmitRate = 0;
+
+
+    func_enter();
+    /* Send a Null Frame to Peer,
+     * 32= size of mac header  */
+    csrResult = unifi_net_data_malloc(priv, &bulkdata.d[0], MAC_HEADER_SIZE + QOS_CONTROL_HEADER_SIZE);
+
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, " failed to allocate request_data. in uf_send_qos_null func\n");
+        return ;
+    }
+    skb = (struct sk_buff *)(bulkdata.d[0].os_net_buf_ptr);
+    skb->len = 0;
+    bulkdata.d[0].os_data_ptr = skb->data;
+    bulkdata.d[0].os_net_buf_ptr = (unsigned char*)skb;
+    bulkdata.d[0].net_buf_length = bulkdata.d[0].data_length = skb->len;
+    bulkdata.d[1].os_data_ptr = NULL;
+    bulkdata.d[1].os_net_buf_ptr = NULL;
+    bulkdata.d[1].net_buf_length = bulkdata.d[1].data_length = 0;
+
+    /* For null frames protection bit should not be set in MAC header, so passing value 0 below for protection field */
+
+    if (prepare_and_add_macheader(priv, skb, newSkb, priority, &bulkdata, interfaceTag, da, interfacePriv->bssid.a, 0)) {
+        unifi_error(priv, "failed to create MAC header\n");
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+        return;
+    }
+    memcpy(peerAddress.a, ((CsrUint8 *) bulkdata.d[0].os_data_ptr) + 4, ETH_ALEN);
+    /* convert priority to queue */
+    priority_q = unifi_frame_priority_to_queue((CSR_PRIORITY) priority);
+
+    /* Frame ma-packet.req, this is saved/transmitted depend on queue state
+     * send the null frame at data rate of 1 Mb/s for AP or 6 Mb/s for P2PGO
+     */
+    switch (interfacePriv->interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+            transmitRate = 2;
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            transmitRate = 12;
+            break;
+        default:
+            transmitRate = 0;
+    }
+    unifi_frame_ma_packet_req(priv, priority, transmitRate, 0xffffffff, interfaceTag,
+                              transmissionControl, priv->netdev_client->sender_id,
+                              peerAddress.a, &signal);
+
+    r = ul_send_signal_unpacked(priv, &signal, &bulkdata);
+    if(r) {
+        unifi_error(priv, "failed to send QOS data null packet result: %d\n",r);
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+    }
+
+    func_exit();
+    return;
+
+}
+void uf_send_nulldata(unifi_priv_t * priv,CsrUint16 interfaceTag, const CsrUint8 *da,CSR_PRIORITY priority,CsrWifiRouterCtrlStaInfo_t * srcStaInfo)
+{
+    bulk_data_param_t bulkdata;
+    CsrResult csrResult;
+    struct sk_buff *skb, *newSkb = NULL;
+    CsrWifiMacAddress peerAddress;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    CSR_TRANSMISSION_CONTROL transmissionControl = 0;
+    int r;
+    CSR_SIGNAL signal;
+    CsrUint32 priority_q;
+    CSR_RATE transmitRate = 0;
+    CSR_MA_PACKET_REQUEST *req = &signal.u.MaPacketRequest;
+    unsigned long lock_flags;
+
+    func_enter();
+    /* Send a Null Frame to Peer, size = 24 for MAC header */
+    csrResult = unifi_net_data_malloc(priv, &bulkdata.d[0], MAC_HEADER_SIZE);
+
+    if (csrResult != CSR_RESULT_SUCCESS) {
+        unifi_error(priv, "uf_send_nulldata: Failed to allocate memory for NULL frame\n");
+        return ;
+    }
+    skb = (struct sk_buff *)(bulkdata.d[0].os_net_buf_ptr);
+    skb->len = 0;
+    bulkdata.d[0].os_data_ptr = skb->data;
+    bulkdata.d[0].os_net_buf_ptr = (unsigned char*)skb;
+    bulkdata.d[0].net_buf_length = bulkdata.d[0].data_length = skb->len;
+    bulkdata.d[1].os_data_ptr = NULL;
+    bulkdata.d[1].os_net_buf_ptr = NULL;
+    bulkdata.d[1].net_buf_length = bulkdata.d[1].data_length = 0;
+
+    /* For null frames protection bit should not be set in MAC header, so passing value 0 below for protection field */
+    if (prepare_and_add_macheader(priv, skb, newSkb, priority, &bulkdata, interfaceTag, da, interfacePriv->bssid.a, 0)) {
+        unifi_error(priv, "uf_send_nulldata: Failed to create MAC header\n");
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+        return;
+    }
+    memcpy(peerAddress.a, ((CsrUint8 *) bulkdata.d[0].os_data_ptr) + 4, ETH_ALEN);
+    /* convert priority to queue */
+    priority_q = unifi_frame_priority_to_queue((CSR_PRIORITY) priority);
+    transmissionControl &= ~(CSR_NO_CONFIRM_REQUIRED);
+
+    /* Frame ma-packet.req, this is saved/transmitted depend on queue state
+     * send the null frame at data rate of 1 Mb/s for AP or 6 Mb/s for P2PGO
+     */
+    switch (interfacePriv->interfaceMode)
+    {
+        case CSR_WIFI_ROUTER_CTRL_MODE_AP:
+            transmitRate = 2;
+            break;
+        case CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:
+            transmitRate = 12;
+            break;
+        default:
+            transmitRate = 0;
+    }
+    unifi_frame_ma_packet_req(priv, priority, transmitRate, INVALID_HOST_TAG, interfaceTag,
+                              transmissionControl, priv->netdev_client->sender_id,
+                              peerAddress.a, &signal);
+
+    /* Save host tag to check the status on reception of MA packet confirm */
+    srcStaInfo->nullDataHostTag = req->HostTag;
+    unifi_trace(priv, UDBG1, "uf_send_nulldata: STA AID = %d hostTag = %x\n", srcStaInfo->aid, req->HostTag);
+
+    r = ul_send_signal_unpacked(priv, &signal, &bulkdata);
+
+    if(r == -ENOSPC) {
+        unifi_trace(priv, UDBG1, "uf_send_nulldata: ENOSPC Requeue the Null frame\n");
+        enque_tx_data_pdu(priv, &bulkdata, &srcStaInfo->dataPdu[priority_q], &signal, 1);
+        spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+        srcStaInfo->noOfPktQueued++;
+        spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+
+
+    }
+    if(r && r != -ENOSPC){
+        unifi_error(priv, "uf_send_nulldata: Failed to send Null frame Error = %d\n",r);
+        unifi_net_data_free(priv, &bulkdata.d[0]);
+        srcStaInfo->nullDataHostTag = INVALID_HOST_TAG;
+    }
+
+    func_exit();
+    return;
+}
+
+CsrBool uf_check_broadcast_bssid(unifi_priv_t *priv, const bulk_data_param_t *bulkdata)
+{
+    CsrUint8 *bssid = NULL;
+    static const CsrWifiMacAddress broadcast_address = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};
+    CsrUint8 toDs, fromDs;
+
+    toDs = (((bulkdata->d[0].os_data_ptr)[1]) & 0x01) ? 1 : 0;
+    fromDs =(((bulkdata->d[0].os_data_ptr)[1]) & 0x02) ? 1 : 0;
+
+     if (toDs && fromDs)
+    {
+        unifi_trace(priv, UDBG6, "Address 4 present, Don't try to find BSSID\n");
+        bssid = NULL;
+    }
+    else if((toDs == 0) && (fromDs ==0))
+    {
+        /* BSSID is Address 3 */
+        bssid = (CsrUint8 *) (bulkdata->d[0].os_data_ptr + 4 + (2 * ETH_ALEN));
+    }
+    else if(toDs)
+    {
+        /* BSSID is Address 1 */
+        bssid = (CsrUint8 *) (bulkdata->d[0].os_data_ptr + 4);
+    }
+    else if(fromDs)
+    {
+        /* BSSID is Address 2 */
+        bssid = (CsrUint8 *) (bulkdata->d[0].os_data_ptr + 4 + ETH_ALEN);
+    }
+
+    if (memcmp(broadcast_address.a, bssid, ETH_ALEN)== 0)
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+
+CsrBool uf_process_pm_bit_for_peer(unifi_priv_t * priv, CsrWifiRouterCtrlStaInfo_t * srcStaInfo,
+                                CsrUint8 pmBit,CsrUint16 interfaceTag)
+{
+    CsrBool moreData = FALSE;
+    CsrBool powerSaveChanged = FALSE;
+    unsigned long lock_flags;
+
+    unifi_trace(priv, UDBG3, "entering uf_process_pm_bit_for_peer\n");
+    if (pmBit) {
+        priv->allPeerDozing |= (0x01 << (srcStaInfo->assignedHandle));
+    } else {
+        priv->allPeerDozing &= ~(0x01 << (srcStaInfo->assignedHandle));
+    }
+    if(pmBit) {
+        if(srcStaInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE) {
+
+            /* disable the preemption */
+            spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+            srcStaInfo->currentPeerState =CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE;
+            powerSaveChanged = TRUE;
+            /* enable the preemption */
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+        } else {
+            return powerSaveChanged;
+        }
+    } else {
+        if(srcStaInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE) {
+            /* disable the preemption */
+            spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+            srcStaInfo->currentPeerState = CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE;
+            powerSaveChanged = TRUE;
+            /* enable the preemption */
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+        }else {
+            return powerSaveChanged;
+        }
+    }
+
+
+    if(srcStaInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE) {
+        unifi_trace(priv,UDBG3, "Peer with AID = %d is active now\n",srcStaInfo->aid);
+        process_peer_active_transition(priv,srcStaInfo,interfaceTag);
+    } else {
+        unifi_trace(priv,UDBG3, "Peer with AID = %d is in PS Now\n",srcStaInfo->aid);
+        /* Set TIM if needed */
+        if(!srcStaInfo->wmmOrQosEnabled) {
+            moreData = (!list_empty(&srcStaInfo->mgtFrames) ||
+                        !list_empty(&srcStaInfo->dataPdu[UNIFI_TRAFFIC_Q_VO])||
+                        !list_empty(&srcStaInfo->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]));
+            if(moreData && (srcStaInfo->timSet == CSR_WIFI_TIM_RESET)) {
+                unifi_trace(priv, UDBG3, "This condition should not occur\n");
+                update_tim(priv,srcStaInfo->aid,1,interfaceTag, srcStaInfo->assignedHandle);
+            }
+        } else {
+            CsrUint8 allDeliveryEnabled = 0, dataAvailable = 0;
+            unifi_trace(priv, UDBG5, "Qos in AP Mode\n");
+            /* Check if all AC's are Delivery Enabled */
+            is_all_ac_deliver_enabled_and_moredata(srcStaInfo, &allDeliveryEnabled, &dataAvailable);
+            /*check for more data in non-delivery enabled queues*/
+            moreData = (uf_is_more_data_for_non_delivery_ac(srcStaInfo) || (allDeliveryEnabled && dataAvailable));
+
+            if(moreData && (srcStaInfo->timSet == CSR_WIFI_TIM_RESET)) {
+                update_tim(priv,srcStaInfo->aid,1,interfaceTag, srcStaInfo->assignedHandle);
+            }
+        }
+    }
+    unifi_trace(priv, UDBG3, "leaving uf_process_pm_bit_for_peer\n");
+    return powerSaveChanged;
+}
+
+
+
+void uf_process_ps_poll(unifi_priv_t *priv,CsrUint8* sa,CsrUint8* da,CsrUint8 pmBit,CsrUint16 interfaceTag)
+{
+    CsrWifiRouterCtrlStaInfo_t *staRecord =
+    CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, sa, interfaceTag);
+    tx_buffered_packets_t * buffered_pkt = NULL;
+    CsrWifiMacAddress peerMacAddress;
+    unsigned long lock_flags;
+    CsrInt8 r =0;
+    CsrBool moreData = FALSE;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    unifi_trace(priv, UDBG3, "entering uf_process_ps_poll\n");
+    if(!staRecord) {
+        memcpy(peerMacAddress.a,sa,ETH_ALEN);
+        unifi_trace(priv, UDBG3, "In uf_process_ps_poll, sta record not found:unexpected frame addr = %x:%x:%x:%x:%x:%x\n",
+                sa[0], sa[1],sa[2], sa[3], sa[4],sa[5]);
+        CsrWifiRouterCtrlUnexpectedFrameIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,interfaceTag,peerMacAddress);
+        return;
+    }
+
+    uf_process_pm_bit_for_peer(priv,staRecord,pmBit,interfaceTag);
+
+    /* Update station last activity time */
+    staRecord->activity_flag = TRUE;
+
+    /* This should not change the PM bit as PS-POLL has PM bit always set */
+    if(!pmBit) {
+        unifi_notice (priv," PM bit reset in PS-POLL\n");
+        return;
+    }
+
+    if(IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag)) {
+        /* giving more priority to multicast packets so dropping ps-poll*/
+        unifi_notice (priv," multicast transmission is going on so don't take action on PS-POLL\n");
+        return;
+    }
+
+    if(!staRecord->wmmOrQosEnabled) {
+        if((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->mgtFrames))) {
+            buffered_pkt->transmissionControl |= TRANSMISSION_CONTROL_TRIGGER_MASK;
+            moreData = (!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]) ||
+                        !list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]) ||
+                        !list_empty(&staRecord->mgtFrames));
+
+            buffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+            if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {
+                /* Clear the trigger bit transmission control*/
+                buffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+                /* Enqueue at the head of the queue */
+                spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                list_add(&buffered_pkt->q, &staRecord->mgtFrames);
+                spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+                unifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");
+                priv->pausedStaHandle[3]=(CsrUint8)(staRecord->assignedHandle);
+            } else {
+                if(r){
+                    unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                    /* the PDU failed where we can't do any thing so free the storage */
+                    unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+                }
+                kfree(buffered_pkt);
+            }
+        } else if((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]))) {
+            buffered_pkt->transmissionControl |= TRANSMISSION_CONTROL_TRIGGER_MASK;
+            moreData = (!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]) ||
+                        !list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]));
+
+            buffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+            if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {
+                /* Clear the trigger bit transmission control*/
+                buffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+                /* Enqueue at the head of the queue */
+                spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                list_add(&buffered_pkt->q, &staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]);
+                spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+                priv->pausedStaHandle[3]=(CsrUint8)(staRecord->assignedHandle);
+                unifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");
+            } else {
+                if(r){
+                    unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                    /* the PDU failed where we can't do any thing so free the storage */
+                    unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+                }
+                kfree(buffered_pkt);
+            }
+        } else  if((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]))) {
+            buffered_pkt->transmissionControl |= TRANSMISSION_CONTROL_TRIGGER_MASK;
+            moreData = !list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]);
+
+            buffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+            if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {
+                /* Clear the trigger bit transmission control*/
+                buffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+                /* Enqueue at the head of the queue */
+                spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                list_add(&buffered_pkt->q, &staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]);
+                spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+                priv->pausedStaHandle[0]=(CsrUint8)(staRecord->assignedHandle);
+                unifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");
+            } else {
+                if(r){
+                    unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                    /* the PDU failed where we can't do any thing so free the storage */
+                    unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+                }
+                kfree(buffered_pkt);
+            }
+        } else {
+         /* Actually since we have sent an ACK, there
+         * there is no need to send a NULL frame*/
+        }
+        moreData = (!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]) ||
+           !list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]) ||
+            !list_empty(&staRecord->mgtFrames));
+        if(!moreData && (staRecord->timSet == CSR_WIFI_TIM_SET)) {
+            unifi_trace(priv, UDBG3, "more data = NULL, set tim to 0 in uf_process_ps_poll\n");
+            update_tim(priv,staRecord->aid,0,interfaceTag, staRecord->assignedHandle);
+        }
+    } else {
+
+        CsrUint8 allDeliveryEnabled = 0, dataAvailable = 0;
+        unifi_trace(priv, UDBG3,"Qos Support station.Processing PS-Poll\n");
+
+        /*Send Data From Management Frames*/
+        /* Priority orders for delivering the buffered packets are
+         * 1. UNIFI_TRAFFIC_Q_VO, if its non delivery enabled
+         * 2. management frames
+         * 3. Other access catagory frames which are non deliver enable
+         */
+
+        /* Check if all AC's are Delivery Enabled */
+        is_all_ac_deliver_enabled_and_moredata(staRecord, &allDeliveryEnabled, &dataAvailable);
+
+        if (allDeliveryEnabled) {
+            unifi_trace(priv, UDBG3, "uf_process_ps_poll: All ACs are delivery enable so Sending QOS Null in response of Ps-poll\n");
+            uf_send_qos_null(priv,interfaceTag,sa,CSR_QOS_UP0,staRecord);
+            return;
+        }
+
+        if ((!IS_DELIVERY_ENABLED(staRecord->powersaveMode[UNIFI_TRAFFIC_Q_VO])) &&
+                (!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]) || !list_empty(&staRecord->mgtFrames))) {
+            /* UNIFI_TRAFFIC_Q_VO is non delivery enabled, & check for packets are there to send from this AC */
+            if((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]))) {
+                moreData = uf_is_more_data_for_non_delivery_ac(staRecord);
+                buffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+
+                /* Last parameter is EOSP & its false always for PS-POLL processing */
+                if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {
+                    /* Clear the trigger bit transmission control*/
+                    buffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+                    /* Enqueue at the head of the queue */
+                    spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                    list_add(&buffered_pkt->q, &staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]);
+                    spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+                    priv->pausedStaHandle[0]=(CsrUint8)(staRecord->assignedHandle);
+                    unifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");
+                } else {
+                    if(r){
+                        unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                        /* the PDU failed where we can't do any thing so free the storage */
+                        unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+                    }
+                    kfree(buffered_pkt);
+                }
+            } else if ((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->mgtFrames))) {
+                    /* We dont have packets in non delivery enabled UNIFI_TRAFFIC_Q_VO, So we are looking in management
+                     * queue of the station record
+                     */
+                    moreData = uf_is_more_data_for_non_delivery_ac(staRecord);
+                    buffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+
+                    /* Last parameter is EOSP & its false always for PS-POLL processing */
+                    if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {
+                        /* Clear the trigger bit transmission control*/
+                        buffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+                        /* Enqueue at the head of the queue */
+                        spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                        list_add(&buffered_pkt->q, &staRecord->mgtFrames);
+                        spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+                        priv->pausedStaHandle[0]=(CsrUint8)(staRecord->assignedHandle);
+                        unifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");
+                    } else {
+                        if(r){
+                            unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                            /* the PDU failed where we can't do any thing so free the storage */
+                            unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+                        }
+                        kfree(buffered_pkt);
+                    }
+                }
+        } else {
+            CsrInt8 i;
+            /* We dont have buffered packet in UNIFI_TRAFFIC_Q_VO & mangement frame queue (1 & 2 failed), So proceed with 3 condition
+             * UNIFI_TRAFFIC_Q_VO is taken care so start with i index = 2
+             */
+            for(i= 2; i>=0; i--) {
+                if (!IS_DELIVERY_ENABLED(staRecord->powersaveMode[i])) {
+                    /* Send One packet, if queue is NULL then continue */
+                    if((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->dataPdu[i]))) {
+                        moreData = uf_is_more_data_for_non_delivery_ac(staRecord);
+
+                        buffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+
+                        /* Last parameter is EOSP & its false always for PS-POLL processing */
+                        if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {
+                            /* Clear the trigger bit transmission control*/
+                            buffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_ESOP_MASK);
+                            /* Enqueue at the head of the queue */
+                            spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                            list_add(&buffered_pkt->q, &staRecord->dataPdu[i]);
+                            spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+                            priv->pausedStaHandle[0]=(CsrUint8)(staRecord->assignedHandle);
+                            unifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");
+                        } else {
+                            if(r) {
+                                unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                                /* the PDU failed where we can't do any thing so free the storage */
+                                unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+                            }
+                            kfree(buffered_pkt);
+                        }
+                        break;
+                    }
+                }
+            }
+        }
+        /* Check if all AC's are Delivery Enabled */
+        is_all_ac_deliver_enabled_and_moredata(staRecord, &allDeliveryEnabled, &dataAvailable);
+        /*check for more data in non-delivery enabled queues*/
+        moreData = (uf_is_more_data_for_non_delivery_ac(staRecord) || (allDeliveryEnabled && dataAvailable));
+        if(!moreData && (staRecord->timSet == CSR_WIFI_TIM_SET)) {
+            unifi_trace(priv, UDBG3, "more data = NULL, set tim to 0 in uf_process_ps_poll\n");
+            update_tim(priv,staRecord->aid,0,interfaceTag, staRecord->assignedHandle);
+        }
+    }
+
+        unifi_trace(priv, UDBG3, "leaving uf_process_ps_poll\n");
+}
+
+
+
+void add_to_send_cfm_list(unifi_priv_t * priv,
+                          tx_buffered_packets_t *tx_q_item,
+                          struct list_head *frames_need_cfm_list)
+{
+    tx_buffered_packets_t *send_cfm_list_item = NULL;
+
+    send_cfm_list_item = (tx_buffered_packets_t *) kmalloc(sizeof(tx_buffered_packets_t), GFP_ATOMIC);
+
+    if(send_cfm_list_item == NULL){
+        unifi_warning(priv, "%s: Failed to allocate memory for new list item \n");
+        return;
+    }
+
+    INIT_LIST_HEAD(&send_cfm_list_item->q);
+
+    send_cfm_list_item->hostTag = tx_q_item->hostTag;
+    send_cfm_list_item->interfaceTag = tx_q_item->interfaceTag;
+    send_cfm_list_item->transmissionControl = tx_q_item->transmissionControl;
+    send_cfm_list_item->leSenderProcessId = tx_q_item->leSenderProcessId;
+    send_cfm_list_item->rate = tx_q_item->rate;
+    memcpy(send_cfm_list_item->peerMacAddress.a, tx_q_item->peerMacAddress.a, ETH_ALEN);
+    send_cfm_list_item->priority = tx_q_item->priority;
+
+    list_add_tail(&send_cfm_list_item->q, frames_need_cfm_list);
+}
+
+void uf_prepare_send_cfm_list_for_queued_pkts(unifi_priv_t * priv,
+                                                 struct list_head *frames_need_cfm_list,
+                                                 struct list_head * list)
+{
+    tx_buffered_packets_t *tx_q_item = NULL;
+    struct list_head *listHead;
+    struct list_head *placeHolder;
+    unsigned long lock_flags;
+
+    func_enter();
+
+    spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+
+    /* Search through the list and if confirmation required for any frames,
+    add it to the send_cfm list */
+    list_for_each_safe(listHead, placeHolder, list) {
+        tx_q_item = list_entry(listHead, tx_buffered_packets_t, q);
+
+        if(!tx_q_item) {
+            unifi_error(priv, "Entry should exist, otherwise it is a (BUG)\n");
+            continue;
+        }
+
+        /* check if confirmation is requested and if the sender ID
+        is not netdevice client then save the entry in the list for need cfms */
+        if (!(tx_q_item->transmissionControl & CSR_NO_CONFIRM_REQUIRED) &&
+            (tx_q_item->leSenderProcessId != priv->netdev_client->sender_id)){
+             unifi_trace(priv, UDBG1, "%s: SenderProcessID=%x host tag=%x transmission control=%x\n",
+                __FUNCTION__,
+                tx_q_item->leSenderProcessId,
+                tx_q_item->hostTag,
+                tx_q_item->transmissionControl);
+
+             add_to_send_cfm_list(priv, tx_q_item, frames_need_cfm_list);
+        }
+    }
+
+    spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+
+    func_exit();
+}
+
+
+
+void uf_flush_list(unifi_priv_t * priv, struct list_head * list)
+{
+    tx_buffered_packets_t *tx_q_item;
+    struct list_head *listHead;
+    struct list_head *placeHolder;
+    unsigned long lock_flags;
+
+    unifi_trace(priv, UDBG5, "entering the uf_flush_list \n");
+
+    spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+    /* go through list, delete & free memory */
+    list_for_each_safe(listHead, placeHolder, list) {
+        tx_q_item = list_entry(listHead, tx_buffered_packets_t, q);
+
+        if(!tx_q_item) {
+            unifi_error(priv, "entry should exists, otherwise crashes (bug)\n");
+        }
+        unifi_trace(priv, UDBG5,
+                "proccess_tx:  in uf_flush_list peerMacAddress=%02X%02X%02X%02X%02X%02X senderProcessId=%x\n",
+                tx_q_item->peerMacAddress.a[0], tx_q_item->peerMacAddress.a[1],
+                tx_q_item->peerMacAddress.a[2], tx_q_item->peerMacAddress.a[3],
+                tx_q_item->peerMacAddress.a[4], tx_q_item->peerMacAddress.a[5],
+                tx_q_item->leSenderProcessId);
+
+        list_del(listHead);
+        /* free the allocated memory */
+        unifi_net_data_free(priv, &tx_q_item->bulkdata);
+        kfree(tx_q_item);
+        tx_q_item = NULL;
+        if (!priv->noOfPktQueuedInDriver) {
+            unifi_error(priv, "packets queued in driver 0 still decrementing in %s\n", __FUNCTION__);
+        } else {
+            priv->noOfPktQueuedInDriver--;
+        }
+    }
+    spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+}
+void uf_flush_maPktlist(unifi_priv_t * priv, struct list_head * list)
+{
+    struct list_head *listHeadMaPktreq,*placeHolderMaPktreq;
+    maPktReqList_t *maPktreq;
+    unsigned long lock_flags;
+
+    unifi_trace(priv, UDBG5, "entering the uf_flush_maPktlist \n");
+
+    spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+    /* go through list, delete & free memory */
+    list_for_each_safe(listHeadMaPktreq, placeHolderMaPktreq, list) {
+        maPktreq = list_entry(listHeadMaPktreq, maPktReqList_t, q);
+
+        if(!maPktreq) {
+            unifi_error(priv, "entry should exists, otherwise crashes (bug)\n");
+        }
+        /* free the allocated memory */
+        dev_kfree_skb(maPktreq->skb);
+        list_del(listHeadMaPktreq);
+        kfree(maPktreq);
+        maPktreq = NULL;
+
+    }
+    spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+}
+tx_buffered_packets_t *dequeue_tx_data_pdu(unifi_priv_t *priv, struct list_head *txList)
+{
+    /* dequeue the tx data packets from the appropriate queue */
+    tx_buffered_packets_t *tx_q_item = NULL;
+    struct list_head *listHead;
+    struct list_head *placeHolder;
+    unsigned long lock_flags;
+
+    unifi_trace(priv, UDBG5, "entering dequeue_tx_data_pdu\n");
+    /* check for list empty */
+    if (list_empty(txList)) {
+        unifi_trace(priv, UDBG5, "In dequeue_tx_data_pdu, the list is empty\n");
+        return NULL;
+    }
+
+    /* Verification, if packet count is negetive */
+    if (priv->noOfPktQueuedInDriver == 0xFFFF) {
+        unifi_warning(priv, "no packet available in queue: debug");
+        return NULL;
+    }
+
+    /* return first node after header, & delete from the list  && atleast one item exist */
+    spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+    list_for_each_safe(listHead, placeHolder, txList) {
+        tx_q_item = list_entry(listHead, tx_buffered_packets_t, q);
+        list_del(listHead);
+        break;
+    }
+    spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+
+    if (tx_q_item) {
+        unifi_trace(priv, UDBG5,
+                "proccess_tx:  In dequeue_tx_data_pdu peerMacAddress=%02X%02X%02X%02X%02X%02X senderProcessId=%x\n",
+                tx_q_item->peerMacAddress.a[0], tx_q_item->peerMacAddress.a[1],
+                tx_q_item->peerMacAddress.a[2], tx_q_item->peerMacAddress.a[3],
+                tx_q_item->peerMacAddress.a[4], tx_q_item->peerMacAddress.a[5],
+                tx_q_item->leSenderProcessId);
+    }
+
+    unifi_trace(priv, UDBG5, "leaving dequeue_tx_data_pdu\n");
+    return tx_q_item;
+}
+/* generic function to get the station record handler */
+CsrWifiRouterCtrlStaInfo_t *CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(unifi_priv_t *priv,
+        const CsrUint8 *peerMacAddress,
+        CsrUint16 interfaceTag)
+{
+    CsrUint8 i;
+    netInterface_priv_t *interfacePriv;
+    unsigned long lock_flags;
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "interfaceTag is not proper, interfaceTag = %d\n", interfaceTag);
+        return NULL;
+    }
+
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    /* disable the preemption untill station record is fetched */
+    spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+
+    for (i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {
+        if (interfacePriv->staInfo[i]!= NULL) {
+            if (!memcmp(((CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[i]))->peerMacAddress.a, peerMacAddress, ETH_ALEN)) {
+                /* enable the preemption as station record is fetched */
+                spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+                unifi_trace(priv, UDBG5, "peer entry found in station record\n");
+                return ((CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[i]));
+            }
+        }
+    }
+    /* enable the preemption as station record is fetched */
+    spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+    unifi_trace(priv, UDBG5, "peer entry not found in station record\n");
+    return NULL;
+}
+/* generic function to get the station record handler from the handle */
+CsrWifiRouterCtrlStaInfo_t * CsrWifiRouterCtrlGetStationRecordFromHandle(unifi_priv_t *priv,
+                                                                 CsrUint32 handle,
+                                                                 CsrUint16 interfaceTag)
+{
+    netInterface_priv_t *interfacePriv;
+
+    if ((handle >= UNIFI_MAX_CONNECTIONS) || (interfaceTag >= CSR_WIFI_NUM_INTERFACES)) {
+        unifi_error(priv, "handle/interfaceTag is not proper, handle = %d, interfaceTag = %d\n", handle, interfaceTag);
+        return NULL;
+    }
+    interfacePriv = priv->interfacePriv[interfaceTag];
+    return ((CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[handle]));
+}
+
+/* Function to do inactivity */
+void uf_check_inactivity(unifi_priv_t *priv, CsrUint16 interfaceTag, CsrTime currentTime)
+{
+    CsrUint32 i;
+    CsrWifiRouterCtrlStaInfo_t *staInfo;
+    CsrTime elapsedTime;    /* Time in microseconds */
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    CsrWifiMacAddress peerMacAddress;
+    unsigned long lock_flags;
+
+    if (interfacePriv == NULL) {
+        unifi_trace(priv, UDBG3, "uf_check_inactivity: Interface priv is NULL \n");
+        return;
+    }
+
+    spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+    /* Go through the list of stations to check for inactivity */
+    for(i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {
+        staInfo =  CsrWifiRouterCtrlGetStationRecordFromHandle(priv, i, interfaceTag);
+        if(!staInfo ) {
+            continue;
+        }
+
+        unifi_trace(priv, UDBG3, "Running Inactivity handler Time %xus station's last activity %xus\n",
+                currentTime, staInfo->lastActivity);
+
+
+        elapsedTime = (currentTime >= staInfo->lastActivity)?
+                (currentTime - staInfo->lastActivity):
+                (~((CsrUint32)0) - staInfo->lastActivity + currentTime);
+        spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+
+        if (elapsedTime > MAX_INACTIVITY_INTERVAL) {
+            memcpy((CsrUint8*)&peerMacAddress, (CsrUint8*)&staInfo->peerMacAddress, sizeof(CsrWifiMacAddress));
+
+            /* Indicate inactivity for the station */
+            unifi_trace(priv, UDBG3, "Station %x:%x:%x:%x:%x:%x inactive since %xus\n sending Inactive Ind\n",
+                        peerMacAddress.a[0], peerMacAddress.a[1],
+                        peerMacAddress.a[2], peerMacAddress.a[3],
+                        peerMacAddress.a[4], peerMacAddress.a[5],
+                        elapsedTime);
+
+            CsrWifiRouterCtrlStaInactiveIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0, interfaceTag, peerMacAddress);
+        }
+    }
+
+    interfacePriv->last_inactivity_check = currentTime;
+}
+
+/* Function to update activity of a station */
+void uf_update_sta_activity(unifi_priv_t *priv, CsrUint16 interfaceTag, const CsrUint8 *peerMacAddress)
+{
+    CsrTime elapsedTime, currentTime;    /* Time in microseconds */
+    CsrTime timeHi;         /* Not used - Time in microseconds */
+    CsrWifiRouterCtrlStaInfo_t *staInfo;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    unsigned long lock_flags;
+
+    if (interfacePriv == NULL) {
+        unifi_trace(priv, UDBG3, "uf_check_inactivity: Interface priv is NULL \n");
+        return;
+    }
+
+    currentTime = CsrTimeGet(&timeHi);
+
+
+    staInfo = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, peerMacAddress, interfaceTag);
+
+    if (staInfo == NULL) {
+        unifi_trace(priv, UDBG4, "Sta does not exist yet");
+        return;
+    }
+
+    spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+    /* Update activity */
+    staInfo->lastActivity = currentTime;
+
+    /* See if inactivity handler needs to be run
+     * Here it is theoretically possible that the counter may have wrapped around. But
+     * since we just want to know when to run the inactivity handler it does not really matter.
+     * Especially since this is data path it makes sense in keeping it simple and avoiding
+     * 64 bit handling */
+    elapsedTime = (currentTime >= interfacePriv->last_inactivity_check)?
+                    (currentTime - interfacePriv->last_inactivity_check):
+                    (~((CsrUint32)0) - interfacePriv->last_inactivity_check + currentTime);
+
+    spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+
+    /* Check if it is time to run the inactivity handler */
+    if (elapsedTime > INACTIVITY_CHECK_INTERVAL) {
+        uf_check_inactivity(priv, interfaceTag, currentTime);
+    }
+}
+void resume_unicast_buffered_frames(unifi_priv_t *priv, CsrUint16 interfaceTag)
+{
+
+   netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+   CsrUint8 i;
+   int j;
+   tx_buffered_packets_t * buffered_pkt = NULL;
+   CsrBool hipslotFree[4] = {TRUE,TRUE,TRUE,TRUE};
+   int r;
+   unsigned long lock_flags;
+
+   func_enter();
+   while(!isRouterBufferEnabled(priv,3) &&
+                            ((buffered_pkt=dequeue_tx_data_pdu(priv,&interfacePriv->genericMgtFrames))!=NULL)) {
+        buffered_pkt->transmissionControl &=
+                     ~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_ESOP_MASK);
+        if((r=frame_and_send_queued_pdu(priv,buffered_pkt,NULL,0,FALSE)) == -ENOSPC) {
+            /* Enqueue at the head of the queue */
+            spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+            list_add(&buffered_pkt->q, &interfacePriv->genericMgtFrames);
+            spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+            hipslotFree[3]=FALSE;
+            break;
+        }else {
+            if(r){
+                unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                /* the PDU failed where we can't do any thing so free the storage */
+                unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+            }
+            kfree(buffered_pkt);
+        }
+   }
+   for(i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {
+        CsrWifiRouterCtrlStaInfo_t *staInfo = interfacePriv->staInfo[i];
+        if(!hipslotFree[0] && !hipslotFree[1] && !hipslotFree[2] && !hipslotFree[3]) {
+            unifi_trace(priv, UDBG3, "(ENOSPC) in resume_unicast_buffered_frames:: hip slots are full \n");
+            break;
+        }
+        if (staInfo && (staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE)) {
+          while((( TRUE == hipslotFree[3] ) && (buffered_pkt=dequeue_tx_data_pdu(priv, &staInfo->mgtFrames)))) {
+              buffered_pkt->transmissionControl &=
+                           ~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_ESOP_MASK);
+              if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staInfo,0,FALSE)) == -ENOSPC) {
+                  unifi_trace(priv, UDBG3, "(ENOSPC) in resume_unicast_buffered_frames:: hip slots are full for voice queue\n");
+                  /* Enqueue at the head of the queue */
+                  spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                  list_add(&buffered_pkt->q, &staInfo->mgtFrames);
+                  spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+                  priv->pausedStaHandle[3]=(CsrUint8)(staInfo->assignedHandle);
+                  hipslotFree[3] = FALSE;
+                  break;
+              } else {
+                  if(r){
+                      unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                      /* the PDU failed where we can't do any thing so free the storage */
+                      unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+                  }
+                  kfree(buffered_pkt);
+              }
+          }
+
+          for(j=3;j>=0;j--) {
+              if(!hipslotFree[j])
+                  continue;
+
+              while((buffered_pkt=dequeue_tx_data_pdu(priv, &staInfo->dataPdu[j]))) {
+                 buffered_pkt->transmissionControl &=
+                            ~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_ESOP_MASK);
+                 if((r=frame_and_send_queued_pdu(priv,buffered_pkt,staInfo,0,FALSE)) == -ENOSPC) {
+                     /* Enqueue at the head of the queue */
+                     spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+                     list_add(&buffered_pkt->q, &staInfo->dataPdu[j]);
+                     spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+                     priv->pausedStaHandle[j]=(CsrUint8)(staInfo->assignedHandle);
+                     hipslotFree[j]=FALSE;
+                     break;
+                 } else {
+                    if(r){
+                        unifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");
+                        /* the PDU failed where we can't do any thing so free the storage */
+                        unifi_net_data_free(priv, &buffered_pkt->bulkdata);
+                     }
+                    kfree(buffered_pkt);
+                 }
+              }
+          }
+       }
+    }
+    func_exit();
+}
+void update_eosp_to_head_of_broadcast_list_head(unifi_priv_t *priv,CsrUint16 interfaceTag)
+{
+
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    unsigned long lock_flags;
+    struct list_head *listHead;
+    struct list_head *placeHolder;
+    tx_buffered_packets_t *tx_q_item;
+
+    func_enter();
+    if (interfacePriv->noOfbroadcastPktQueued) {
+
+        /* Update the EOSP to the HEAD of b/c list
+         * beacuse we have received any mgmt packet so it should not hold for long time
+         * peer may time out.
+         */
+        spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+        list_for_each_safe(listHead, placeHolder, &interfacePriv->genericMulticastOrBroadCastFrames) {
+            tx_q_item = list_entry(listHead, tx_buffered_packets_t, q);
+            tx_q_item->transmissionControl |= TRANSMISSION_CONTROL_ESOP_MASK;
+            tx_q_item->transmissionControl = (tx_q_item->transmissionControl & ~(CSR_NO_CONFIRM_REQUIRED));
+            unifi_trace(priv, UDBG1,"updating eosp for list Head hostTag:= 0x%x ",tx_q_item->hostTag);
+            break;
+        }
+        spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+    }
+    func_exit();
+}
+void resume_suspended_uapsd(unifi_priv_t* priv,CsrUint16 interfaceTag)
+{
+
+   CsrUint8 startIndex;
+   CsrWifiRouterCtrlStaInfo_t * staInfo = NULL;
+   unsigned long lock_flags;
+   /*U-APSD might have stopped because of multicast. So restart it if U-APSD
+   was active with any of the station*/
+    for(startIndex= 0; startIndex < UNIFI_MAX_CONNECTIONS;startIndex++) {
+        staInfo =  CsrWifiRouterCtrlGetStationRecordFromHandle(priv,startIndex,interfaceTag);
+        if(!staInfo ) {
+            continue;
+        } else if((staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)
+                   &&(staInfo->uapsdSuspended == TRUE)) {
+
+            /*U-APSD Still active, it means trigger frame is received,so continue U-APSD by
+            sending data from remaining delivery enabled queues*/
+            spin_lock_irqsave(&priv->staRecord_lock,lock_flags);
+            staInfo->uapsdActive = TRUE;
+            staInfo->uapsdSuspended = FALSE;
+            spin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);
+            uf_continue_uapsd(priv,staInfo);
+        }
+    }
+
+}
+void uf_store_directed_ma_packet_referenece(unifi_priv_t *priv, bulk_data_param_t *bulkdata,
+                                            CSR_SIGNAL *sigptr, CsrUint32 alignOffset)
+{
+
+    maPktReqList_t *maPktreq = NULL;
+    CSR_MA_PACKET_REQUEST *req = &sigptr->u.MaPacketRequest;
+    CsrWifiRouterCtrlStaInfo_t *staRecord = NULL;
+    CsrUint16 frmCtrl,interfaceTag = 0;
+    const CsrUint8* macHdrLocation;
+    struct sk_buff *skb ;
+    unsigned long lock_flags;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+    CsrUint8 *sigbuffer;
+    CsrUint8 frameType = 0;
+    func_enter();
+
+    if(bulkdata == NULL || (0 == bulkdata->d[0].data_length )){
+      unifi_trace (priv, UDBG3, "uf_store_directed_ma_packet_referenece:bulk data NULL \n");
+      func_exit();
+      return;
+    }
+    macHdrLocation = bulkdata->d[0].os_data_ptr;
+    skb = (struct sk_buff*)bulkdata->d[0].os_net_buf_ptr;
+    /* fectch the frame control value from mac header */
+    frmCtrl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(macHdrLocation);
+
+    /* Processing done according to Frame/Packet type */
+    frameType =  ((frmCtrl & 0x000c) >> FRAME_CONTROL_TYPE_FIELD_OFFSET);
+
+    if( (((frmCtrl & 0xff) == IEEE802_11_FC_TYPE_QOS_NULL) ||
+        ((frmCtrl & 0xff) == IEEE802_11_FC_TYPE_NULL ) ) ||
+        ( IEEE802_11_FRAMETYPE_MANAGEMENT== frameType)){
+
+        /* if packet is NULL or Qos Null no need of retransmit so dont queue it*/
+        unifi_trace (priv, UDBG3, "uf_store_directed_ma_packet_referenece: NULL data Pkt or mgmt\n");
+        func_exit();
+        return;
+    }
+
+    /* fetch the station record for corresponding peer mac address */
+    if ((staRecord = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, req->Ra.x, interfaceTag))) {
+        maPktreq = (maPktReqList_t*)kmalloc(sizeof(maPktReqList_t),GFP_ATOMIC);
+        if(maPktreq == NULL){
+            unifi_error(priv,
+                "uf_store_directed_ma_packet_referenece :: Failed to allocate %d byter for maPktreq\n",
+                sizeof(maPktReqList_t));
+            func_exit();
+            return;
+        }
+    }
+
+    /* staRecord not present that means packet is multicast or generic mgmt so no need to queue it */
+    else{
+        unifi_trace (priv, UDBG3, "uf_store_directed_ma_packet_referenece: multicast pkt \n");
+        func_exit();
+        return ;
+    }
+
+    /* disbale preemption */
+    spin_lock_irqsave(&priv->tx_q_lock,lock_flags);
+    INIT_LIST_HEAD(&maPktreq->q);
+    maPktreq->staHandler = staRecord->assignedHandle;
+    memcpy(&maPktreq->signal,sigptr,sizeof(CSR_SIGNAL_PRIMITIVE_HEADER) + sizeof(CSR_MA_PACKET_REQUEST));
+    sigbuffer = (CsrUint8*)&maPktreq->signal;
+    sigbuffer[SIZEOF_SIGNAL_HEADER + 1] = alignOffset;
+    maPktreq->skb = skb_get(skb);
+    maPktreq->hostTag = req->HostTag;
+    maPktreq->jiffeTime = jiffies;
+    list_add_tail(&maPktreq->q,&interfacePriv->directedMaPktReq);
+
+    spin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);
+    func_exit();
+
+}
+
+#endif
--- /dev/null
+++ b/drivers/staging/csr/unifi_priv.h
@@ -0,0 +1,1148 @@
+/*
+ *****************************************************************************
+ *
+ * FILE : unifi_priv.h
+ *
+ * PURPOSE : Private header file for unifi driver.
+ *
+ *           UDI = UniFi Debug Interface
+ *
+ * Copyright (C) 2005-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ *****************************************************************************
+ */
+#ifndef __LINUX_UNIFI_PRIV_H__
+#define __LINUX_UNIFI_PRIV_H__ 1
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/wireless.h>
+#include <linux/cdev.h>
+#include <linux/kthread.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
+#include <linux/freezer.h>
+#endif
+
+#ifdef CSR_WIFI_SUPPORT_MMC_DRIVER
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio.h>
+#endif /* CSR_WIFI_SUPPORT_MMC_DRIVER */
+
+#include <linux/fs.h>
+
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_unifi_udi.h"
+#include "csr_wifi_router_lib.h"
+#include "unifiio.h"
+#ifndef CSR_WIFI_HIP_TA_DISABLE
+#include "csr_wifi_vif_utils.h"
+#endif
+
+/* Define the unifi_priv_t before include the unifi_native.h */
+struct unifi_priv;
+typedef struct unifi_priv unifi_priv_t;
+#ifdef CSR_SUPPORT_WEXT_AP
+struct CsrWifiSmeApConfig;
+typedef struct CsrWifiSmeApConfig CsrWifiSmeApConfig_t;
+#endif
+#ifdef CSR_SUPPORT_WEXT
+#include "unifi_wext.h"
+#endif
+
+#include "unifi_clients.h"
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#include <linux/workqueue.h>
+
+#undef INIT_WORK
+#define INIT_WORK(_work, _func)                                         \
+    do {                                                                \
+        INIT_LIST_HEAD(&(_work)->entry);                                \
+        (_work)->pending = 0;                                           \
+        PREPARE_WORK((_work), (_func), (_work));                        \
+        init_timer(&(_work)->timer);                                    \
+    } while(0)
+
+#endif  /* Linux kernel < 2.6.20 */
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+#define UF_NETIF_TX_WAKE_ALL_QUEUES(_netdev)    netif_tx_wake_all_queues(_netdev)
+#define UF_NETIF_TX_START_ALL_QUEUES(_netdev)   netif_tx_start_all_queues(_netdev)
+#define UF_NETIF_TX_STOP_ALL_QUEUES(_netdev)    netif_tx_stop_all_queues(_netdev)
+#else
+#define UF_NETIF_TX_WAKE_ALL_QUEUES(_netdev)    netif_wake_queue(_netdev)
+#define UF_NETIF_TX_START_ALL_QUEUES(_netdev)   netif_start_queue(_netdev)
+#define UF_NETIF_TX_STOP_ALL_QUEUES(_netdev)    netif_stop_queue(_netdev)
+#endif  /* Linux kernel >= 2.6.27 */
+
+
+#ifdef CSR_NATIVE_LINUX
+#include "sme_native/unifi_native.h"
+#else
+#include "unifi_sme.h"
+#endif
+
+#undef  COMPARE_HOST_TAG_TO_ENQUEUE
+#define COMPARE_HOST_TAG_TO_ENQUEUE(tx_q_item_hosttag,maPktHostTag)        \
+      if(tx_q_item_hosttag > maPktHostTag){                                \
+        locationFound = TRUE;                                              \
+        ii++;                                                              \
+        break;                                                             \
+    }                                                                      \
+    ii++;                                                                  \
+
+
+/* The device major number to use when registering the udi driver */
+#define UNIFI_NAME      "unifi"
+#define MAX_UNIFI_DEVS  2
+
+/* 802.11 Mac header offsets */
+#define MAC_HEADER_SIZE  24
+#define QOS_CONTROL_HEADER_SIZE 2
+#define HT_CONTROL_HEADER_SIZE  4
+#define QOS_DATA 0x8
+#define QOS_DATA_NULL 0xc
+#define DATA_NULL 0x04
+#define FRAME_CONTROL_ORDER_BIT 0x8000
+#define FRAME_CONTROL_TYPE_FIELD_OFFSET  2
+#define FRAME_CONTROL_SUBTYPE_FIELD_OFFSET  4
+#define IEEE802_11_FRAMETYPE_DATA 0x02
+#define IEEE802_11_FRAMETYPE_CONTROL 0x01
+#define IEEE802_11_FRAMETYPE_MANAGEMENT 0x00
+#define IEEE802_11_FRAMETYPE_RESERVED 0x03
+
+/* octet offset from start of mac header for certain fields */
+#define IEEE802_11_ADDR3_OFFSET 16
+#define IEEE802_11_SEQUENCE_CONTROL_OFFSET 22
+#define IEEE802_11_MAX_DATA_LEN 2304
+
+/* frame control (FC) masks, for frame control as 16 bit integer */
+#define IEEE802_11_FC_TO_DS_MASK 0x100
+#define IEEE802_11_FC_FROM_DS_MASK 0x200
+#define IEEE802_11_FC_MOREDATA_MASK 0x2000
+#define IEEE802_11_FC_PROTECTED_MASK 0x4000
+#define IEEE80211_FC_ORDER_MASK 0x8000
+#define IEEE80211_FC_SUBTYPE_MASK 0x00f0
+#define IEEE80211_FC_TYPE_MASK 0x000c
+#define IEEE80211_FC_PROTO_VERSION_MASK 0x0003
+
+/*  selected type and subtype combinations as in 7.1.3.1 table 1
+    For frame control as 16 bit integer, or for ls octet
+*/
+#define IEEE802_11_FC_TYPE_DATA 0x08
+#define IEEE802_11_FC_TYPE_NULL 0x48
+#define IEEE802_11_FC_TYPE_QOS_NULL 0xc8
+#define IEEE802_11_FC_TYPE_QOS_DATA 0x88
+
+#define IEEE802_11_FC_TYPE_DATA_SUBTYPE_RESERVED 0x0D
+
+/* qos control (QC) masks for qos control as 16 bit integer, or for ls octet */
+#define IEEE802_11_QC_TID_MASK 0x0f
+#define IEEE802_11_QC_A_MSDU_PRESENT 0x80
+
+#define CSR_WIFI_EAPOL_M4_HOST_TAG 0x50000000
+#define IEEE802_11_DATA_FRAME_MAC_HEADER_SIZE 36
+#define MAX_ACCESS_CATOGORY 4
+
+/* Time in us to check for inactivity of stations 5 mins */
+#define INACTIVITY_CHECK_INTERVAL   300000000
+/* Time in us before a station is flagged as inactive */
+#define MAX_INACTIVITY_INTERVAL     300000000
+
+
+/* Define for maximum BA session */
+#define MAX_SUPPORTED_BA_SESSIONS_TX   1
+#define MAX_SUPPORTED_BA_SESSIONS_RX   4
+
+#define MAX_BA_WIND_SIZE 64
+#define MAC_HEADER_ADDR1_OFFSET     4
+#define MAC_HEADER_ADDR2_OFFSET     10
+
+/* Define for age (in us) value for frames in MPDU reorder buffer */
+#define CSR_WIFI_BA_MPDU_FRAME_AGE_TIMEOUT  30000 /* 30 milli seconds */
+
+/* This macro used in prepare_and_add_macheader*/
+#define ADDRESS_ONE_OFFSET 20
+
+/* Defines for STA inactivity detection */
+#define     STA_INACTIVE_DETECTION_TRIGGER_THRESHOLD           1                /* in number of stations */
+#define     STA_INACTIVE_DETECTION_TIMER_INTERVAL              30               /* in seconds */
+#define     STA_INACTIVE_TIMEOUT_VAL                           120*1000*1000    /* 120 seconds */
+
+
+/* Defines used in beacon filtering in case of P2P */
+#define CSR_WIFI_P2P_WILDCARD_SSID_LENGTH        0x7
+#define CSR_WIFI_80211_FRAME_SUBTYPE_BEACON      0x8
+#define CSR_WIFI_BEACON_FIXED_LENGTH             12
+#define CSR_WIFI_FRAME_SUBTYPE_BIT_OFFSET        4
+#define CSR_WIFI_80211_FRAME_SUBTYPE_BIT_MASK    ((CsrUint8)(0xF << CSR_WIFI_FRAME_SUBTYPE_BIT_OFFSET))
+
+#define CSR_WIFI_80211_GET_FRAME_SUBTYPE(frameBuffer) \
+    ((CsrUint8)(((CsrUint8 *)frameBuffer)[0] & CSR_WIFI_80211_FRAME_SUBTYPE_BIT_MASK) >> CSR_WIFI_FRAME_SUBTYPE_BIT_OFFSET)
+
+/* For M4 request received via netdev*/
+
+typedef CsrUint8 CsrWifiPacketType;
+#define CSR_WIFI_UNICAST_PDU   ((CsrWifiPacketType) 0x00)
+#define CSR_WIFI_MULTICAST_PDU ((CsrWifiPacketType) 0x1)
+#define CSR_WIFI_BROADCAST_PDU ((CsrWifiPacketType) 0x2)
+
+#define PRIO_TO_NICE(prio)  ((prio) - MAX_RT_PRIO - 20)
+
+/* Module parameter variables */
+extern int buswidth;
+extern int sdio_clock;
+extern int use_5g;
+extern int disable_hw_reset;
+extern int disable_power_control;
+extern int enable_wol;
+extern int sme_debug;
+extern int fw_init[MAX_UNIFI_DEVS];
+extern int tl_80211d;
+extern int sdio_byte_mode;
+extern int sdio_block_size;
+extern int coredump_max;
+extern int run_bh_once;
+extern int bh_priority;
+
+struct dlpriv {
+    const unsigned char *dl_data;
+    int dl_len;
+    void *fw_desc;
+};
+
+
+struct uf_thread {
+
+    struct task_struct *thread_task;
+
+    /* wait_queue for waking the unifi_thread kernel thread */
+    wait_queue_head_t wakeup_q;
+    unsigned int wakeup_flag;
+
+    /*
+     * Use it to block the I/O thread when
+     * an error occurs or UniFi is reinitialised.
+     */
+    int block_thread;
+
+    char name[16];
+    int prio;
+};
+
+/*
+ * Link list to hold the received packets for the period the port
+ * remains closed.
+ */
+typedef struct rx_buffered_packets {
+    /* List link structure */
+    struct list_head q;
+    /* Packet to indicate when the port reopens */
+    struct sk_buff *skb;
+    /* Bulkdata to free in case the port closes and need to discard the packet */
+    bulk_data_param_t bulkdata;
+    /* The source address of the packet */
+    CsrWifiMacAddress sa;
+    /* The destination address of the packet */
+    CsrWifiMacAddress da;
+    /* Corresponding signal */
+    CSR_SIGNAL signal;
+} rx_buffered_packets_t;
+
+
+typedef CsrUint8 CsrWifiAcPowersaveMode;
+#define CSR_WIFI_AC_TRIGGER_ONLY_ENABLED 0x00
+#define CSR_WIFI_AC_DELIVERY_ONLY_ENABLE 0X01
+#define CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED 0X03
+#define CSR_WIFI_AC_LEGACY_POWER_SAVE 0X02
+
+
+#define IS_DELIVERY_ENABLED(mode) (mode & CSR_WIFI_AC_DELIVERY_ONLY_ENABLE)? 1: 0
+#define IS_DELIVERY_AND_TRIGGER_ENABLED(mode) ((mode & CSR_WIFI_AC_DELIVERY_ONLY_ENABLE)||(mode & CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED))? 1: 0
+#define IS_DTIM_ACTIVE(flag,hostTag) ((flag == TRUE || hostTag != INVALID_HOST_TAG))
+#define INVALID_HOST_TAG 0xFFFFFFFF
+#define UNIFI_TRAFFIC_Q_CONTENTION UNIFI_TRAFFIC_Q_BE
+
+
+
+
+/* Queue to be used for contention priority */
+
+/*
+ * Link list to hold the tx packets for the period the peer
+ * powersave/free slots in unifi
+ */
+typedef struct tx_buffered_packets {
+    /* List link structure */
+    struct list_head q;
+    CsrUint16 interfaceTag;
+    CSR_CLIENT_TAG hostTag;
+    CSR_PROCESS_ID leSenderProcessId;
+    CSR_TRANSMISSION_CONTROL transmissionControl;
+    CSR_RATE rate;
+    /* Bulkdata to free in case the port closes and need to discard the packet */
+    bulk_data_desc_t bulkdata;
+    /* The source address of the packet */
+    CsrWifiMacAddress peerMacAddress;
+    CSR_PRIORITY priority;
+} tx_buffered_packets_t;
+
+/* station record has this data structure */
+typedef struct CsrWifiRouterCtrlStaInfo_t {
+
+    /* Sme sends these parameters */
+    CsrWifiMacAddress peerMacAddress;
+    CsrUint32 assignedHandle;
+    CsrBool wmmOrQosEnabled;
+    CsrWifiAcPowersaveMode powersaveMode[MAX_ACCESS_CATOGORY];
+    CsrUint16 maxSpLength;
+    CsrBool uapsdActive;
+    CsrUint16 noOfSpFramesSent;
+
+    /* Router/Driver database */
+#ifdef CSR_SUPPORT_SME
+    unifi_port_cfg_t *peerControlledPort;
+    unifi_port_cfg_t *peerUnControlledPort;
+
+    /* Inactivity feature parameters */
+    struct netInterface_priv *interfacePriv;
+    struct work_struct send_disconnected_ind_task;
+    CsrBool activity_flag;
+    CsrUint16 listenIntervalInTus;
+    CSR_CLIENT_TAG nullDataHostTag;
+
+    /* Activity timestamps for the station */
+    CsrTime lastActivity;
+
+    /* during m/c transmission sp suspended */
+    CsrBool uapsdSuspended;
+#endif
+    CsrWifiRouterCtrlPeerStatus currentPeerState;
+    struct list_head dataPdu[MAX_ACCESS_CATOGORY];
+    struct list_head mgtFrames;
+    CsrUint8 spStatus;
+    CsrUint8 prevFrmType;
+    CsrUint8 prevFrmAccessCatogory;
+    CsrBool protection;
+    CsrUint16 aid;
+    CsrBool txSuspend;
+    CsrUint8 timSet;
+    /* Dont change the value of below macro for SET & RESET */
+#define CSR_WIFI_TIM_RESET       0
+#define CSR_WIFI_TIM_SET         1
+#define CSR_WIFI_TIM_RESETTING   2
+#define CSR_WIFI_TIM_SETTING     3
+
+    CsrUint16 noOfPktQueued;
+}CsrWifiRouterCtrlStaInfo_t;
+
+#ifdef CSR_SUPPORT_WEXT_AP
+struct CsrWifiSmeApConfig {
+    CsrWifiSsid ssid;
+    CsrUint16 channel;
+    CsrWifiNmeApCredentials credentials;
+    CsrUint8 max_connections;
+    CsrUint8 if_index;
+};
+#endif
+
+#ifdef CSR_WIFI_RX_PATH_SPLIT
+/* This is a test code and may be removed later*/
+#define CSR_WIFI_RX_SIGNAL_BUFFER_SIZE    (60+1)
+
+typedef struct
+{
+    CsrUint8 *bufptr; /* Signal Primitive */
+    bulk_data_param_t data_ptrs; /* Bulk Data pointers */
+    CsrUint16 sig_len;
+}rx_buff_struct_t;
+
+typedef struct
+{
+    CsrUint8 writePointer; /**< write pointer */
+    CsrUint8 readPointer;  /**< read pointer */
+    CsrUint8 size;         /**< size of circular buffer */
+    rx_buff_struct_t rx_buff[CSR_WIFI_RX_SIGNAL_BUFFER_SIZE];    /**< Element of ciruclar buffer */
+} rxCircularBuffer_t;
+
+void rx_wq_handler(struct work_struct *work);
+#endif
+
+struct unifi_priv {
+
+    card_t *card;
+    CsrSdioFunction *sdio;
+
+    /* Index into Unifi_instances[] for this device. */
+    int instance;
+    /* Reference count for this instance */
+    int ref_count;
+
+    /* Firmware images */
+    struct dlpriv fw_sta;
+    struct dlpriv fw_conv;  /* used for conversion of production test image */
+
+    /* Char device related structures */
+    struct cdev unifi_cdev;
+    struct cdev unifiudi_cdev;
+    struct device *unifi_device;
+
+    /* Which wireless interface to use (1 - 2.4GHz, 2 - 5GHz) */
+    CSR_IFINTERFACE if_index;
+
+    /* For multiple interface support */
+    struct net_device *netdev[CSR_WIFI_NUM_INTERFACES];
+    struct netInterface_priv *interfacePriv[CSR_WIFI_NUM_INTERFACES];
+
+    CsrUint8 totalInterfaceCount;
+
+    int prev_queue;
+
+    /* Name of node under /proc */
+    char proc_entry_name[64];
+
+    /*
+     * Flags:
+     *  drop_unencrypted
+     *                - Not used?
+     *  netdev_registered
+     *                - whether the netdev has been registered.
+     */
+    unsigned int drop_unencrypted       : 1;
+
+    /* Our list of unifi linux clients. */
+    ul_client_t ul_clients[MAX_UDI_CLIENTS];
+
+    /* Mutex to protect using the logging hook after UDI client is gone */
+    struct semaphore udi_logging_mutex;
+    /* Pointer to the ul_clients[] array */
+    ul_client_t *logging_client;
+
+    /* A ul_client_t* used to send the netdev related MIB requests. */
+    ul_client_t *netdev_client;
+
+    /* The SME ul_client_t pointer. */
+    ul_client_t *sme_cli;
+
+    /* The AMP ul_client_t pointer. */
+    ul_client_t *amp_client;
+
+    /*
+     * Semaphore for locking the top-half to one user process.
+     * This is necessary to prevent multiple processes calling driver
+     * operations. This can happen because the network driver entry points
+     * can be called from multiple processes.
+     */
+#ifdef USE_DRIVER_LOCK
+    struct semaphore lock;
+#endif /* USE_DRIVER_LOCK */
+
+    /* Flag to say that an operation was aborted */
+    int io_aborted;
+
+    struct uf_thread bh_thread;
+
+#define UNIFI_INIT_NONE         0x00
+#define UNIFI_INIT_IN_PROGRESS  0x01
+#define UNIFI_INIT_FW_DOWNLOADED 0x02
+#define UNIFI_INIT_COMPLETED    0x04
+    unsigned char init_progress;
+
+    int sme_is_present;
+
+    /* The WMM features that UniFi uses in the current BSS */
+    unsigned int sta_wmm_capabilities;
+
+    /* Debug only */
+    char last_debug_string[256];
+    unsigned short last_debug_word16[16];
+
+#ifdef CSR_SUPPORT_SME
+  /* lock to protect the tx queues list */
+    spinlock_t tx_q_lock;
+    CsrUint8 allPeerDozing;
+    CsrUint8 pausedStaHandle[MAX_ACCESS_CATOGORY];
+    /* Max packet the driver can queue, irrespective of interface number */
+    CsrUint16 noOfPktQueuedInDriver;
+#define CSR_WIFI_DRIVER_SUPPORT_FOR_MAX_PKT_QUEUEING 512
+#define CSR_WIFI_DRIVER_MAX_PKT_QUEUING_THRESHOLD_PER_PEER 64
+#define CSR_WIFI_DRIVER_MINIMUM_BROADCAST_PKT_THRESHOLD 3
+
+    CsrBool routerBufferEnable[MAX_ACCESS_CATOGORY];
+    /* lock to protect stainfo members and priv members*/
+    spinlock_t staRecord_lock;
+#endif
+#ifdef CSR_NATIVE_LINUX
+#ifdef CSR_SUPPORT_WEXT
+    /* wireless config */
+    struct wext_config wext_conf;
+#endif
+
+    /* Mutex to protect the MLME blocking requests */
+    struct semaphore mlme_blocking_mutex;
+
+    /* The ul_client that provides the blocking API for WEXT calls */
+    ul_client_t *wext_client;
+
+#endif /* CSR_NATIVE_LINUX */
+
+#ifdef CSR_SUPPORT_SME
+    wait_queue_head_t sme_request_wq;
+    /* Semaphore to protect the SME blocking requests */
+    struct semaphore sme_sem;
+    /* Structure to hold the SME blocking requests data*/
+    sme_reply_t sme_reply;
+
+    /* Structure to hold a traffic protocol indication */
+    struct ta_ind {
+        struct work_struct task;
+        CsrWifiRouterCtrlTrafficPacketType packet_type;
+        CsrWifiRouterCtrlProtocolDirection direction;
+        CsrWifiMacAddress src_addr;
+        int in_use;
+    } ta_ind_work;
+
+    struct ta_sample_ind {
+        struct work_struct task;
+        CsrWifiRouterCtrlTrafficStats stats;
+        int in_use;
+    } ta_sample_ind_work;
+
+    __be32 sta_ip_address;
+    CsrWifiRouterCtrlSmeVersions    sme_versions;
+
+    /*
+     * Flag to reflect state of unifi_sys_wifi_on_*() progress.
+     * This indicates whether we are in an "wifi on" state when we are
+     * allowed to indication errors with unifi_mgt_wifi_off_ind()
+     */
+    enum {
+        wifi_on_unspecified = -1,
+        wifi_on_in_progress = 0,
+        wifi_on_done = 1,
+    } wifi_on_state;
+
+    /* Userspace TaskId for the SME Set when a wifi on req is received */
+    CsrSchedQid CSR_WIFI_SME_IFACEQUEUE;
+
+    struct work_struct multicast_list_task;
+    /*
+     * The SME installs filters to ask for specific MA-UNITDATA.req
+     * to be passed to different SME components.
+     */
+#define MAX_MA_UNIDATA_IND_FILTERS      8
+    sme_ma_unidata_ind_filter_t sme_unidata_ind_filters[MAX_MA_UNIDATA_IND_FILTERS];
+
+/* UNIFI_CFG related parameters */
+    uf_cfg_bcast_packet_filter_t packet_filters;
+    unsigned char *filter_tclas_ies;
+ /* The structure that holds all the connection configuration. */
+    CsrWifiSmeConnectionConfig connection_config;
+#ifdef CSR_SUPPORT_WEXT
+
+    int ignore_bssid_join;
+    struct iw_statistics wext_wireless_stats;
+
+    /* The MIB and MAC address files contents, read from userspace */
+    CsrWifiSmeDataBlock mib_data;
+    CsrWifiMacAddress sta_mac_address;
+
+    int wep_tx_key_index;
+    wep_key_t wep_keys[NUM_WEPKEYS];
+
+
+#ifdef CSR_SUPPORT_WEXT_AP
+    CsrWifiSmeApMacConfig ap_mac_config;
+    CsrWifiNmeApConfig group_sec_config;
+    CsrWifiSmeApConfig_t ap_config;
+#endif
+    struct work_struct sme_config_task;
+
+#endif /* CSR_SUPPORT_WEXT */
+
+#endif /* CSR_SUPPORT_SME */
+
+#ifdef CSR_SME_USERSPACE
+    void *smepriv;
+#endif /* CSR_SME_USERSPACE */
+
+    card_info_t card_info;
+
+    /* Mutex to protect unifi_send_signal() */
+    spinlock_t send_signal_lock;
+
+
+    /*
+     * The workqueue to offload the TA run
+     * and the multicast addresses list set
+     */
+    struct workqueue_struct *unifi_workqueue;
+
+    unsigned char *mib_cfm_buffer;
+    unsigned int mib_cfm_buffer_length;
+
+    int ptest_mode;     /* Set when in production test mode */
+    int coredump_mode;  /* Set when SME has requested a coredump */
+    CsrBool wol_suspend; /* Set when suspending with UniFi powered */
+
+#define UF_UNCONTROLLED_PORT_Q      0
+#define UF_CONTROLLED_PORT_Q        1
+
+    /* Semaphore to protect the rx queues list */
+    struct semaphore rx_q_sem;
+
+    /* Spinlock to protect M4 data */
+    spinlock_t m4_lock;
+    /* Spinlock to protect BA RX data */
+    spinlock_t ba_lock;
+#ifndef ALLOW_Q_PAUSE
+    /* Array to indicate if a particular Tx queue is paused, this may not be
+     * required in a multiqueue implementation since we can directly stop kernel
+     * queues */
+    CsrUint8 tx_q_paused_flag[UNIFI_TRAFFIC_Q_MAX];
+#endif
+
+#ifdef CSR_WIFI_RX_PATH_SPLIT
+    struct workqueue_struct *rx_workqueue;
+    struct work_struct rx_work_struct;
+    rxCircularBuffer_t rxSignalBuffer;
+
+#endif
+
+    CsrUint32 rxTcpThroughput;
+    CsrUint32 txTcpThroughput;
+    CsrUint32 rxUdpThroughput;
+    CsrUint32 txUdpThroughput;
+
+
+    CsrUint8 wapi_multicast_filter;
+    CsrUint8 wapi_unicast_filter;
+    CsrUint8 wapi_unicast_queued_pkt_filter;
+};
+
+typedef struct {
+    CsrUint16 queue_length[4];
+    CsrUint8 os_queue_paused;
+} unifi_OsQosInfo;
+
+
+typedef struct {
+    CsrBool active;
+    bulk_data_param_t bulkdata;
+    CSR_SIGNAL signal;
+    CsrUint16 sn;
+    CsrTime recv_time;
+} frame_desc_struct;
+
+typedef struct {
+    frame_desc_struct *buffer;
+    CsrUint16 wind_size;
+    CsrUint16 occupied_slots;
+    struct timer_list timer;
+    CsrUint16 timeout;
+    CsrUint16 expected_sn;
+    CsrUint16 start_sn;
+    CsrBool   trigger_ba_after_ssn;
+    struct netInterface_priv *interfacePriv;
+    CsrUint16 tID;
+    CsrWifiMacAddress macAddress;
+    struct work_struct send_ba_err_task;
+} ba_session_rx_struct;
+
+
+typedef struct {
+    struct netInterface_priv *interfacePriv;
+    CsrUint16 tID;
+    CsrWifiMacAddress macAddress;
+} ba_session_tx_struct;
+
+typedef struct netInterface_priv
+{
+    CsrUint16 InterfaceTag;
+    struct unifi_priv *privPtr;
+    ba_session_tx_struct *ba_session_tx[MAX_SUPPORTED_BA_SESSIONS_TX];
+    ba_session_rx_struct *ba_session_rx[MAX_SUPPORTED_BA_SESSIONS_RX];
+    frame_desc_struct ba_complete[MAX_BA_WIND_SIZE];
+    CsrUint8 ba_complete_index;
+    CsrUint8 queueEnabled[UNIFI_NO_OF_TX_QS];
+    struct work_struct send_m4_ready_task;
+    struct net_device_stats stats;
+    CsrUint8 interfaceMode;
+    CsrBool protect;
+    CsrWifiMacAddress bssid;
+    /*
+    * Flag to reflect state of CONNECTED indication signal.
+    * This indicates whether we are "joined" an Access Point (i.e. have
+    * nominated an AP and are receiving beacons) but give no indication
+    * of whether we are authenticated and/or associated.
+    */
+    enum {
+        UnifiConnectedUnknown = -1,
+        UnifiNotConnected = 0,
+        UnifiConnected = 1,
+    } connected;
+#ifdef CSR_SUPPORT_WEXT
+    /* Tracks when we are waiting for a netdevice state change callback */
+    CsrBool wait_netdev_change;
+    /* True if we have successfully registered for netdev callbacks */
+    CsrBool netdev_callback_registered;
+#endif /* CSR_SUPPORT_WEXT */
+    unsigned int netdev_registered;
+#define UNIFI_MAX_MULTICAST_ADDRESSES 10
+    /* The multicast addresses list that the thread needs to set. */
+    u8 mc_list[UNIFI_MAX_MULTICAST_ADDRESSES*ETH_ALEN];
+    /* The multicast addresses count that the thread needs to set. */
+    int mc_list_count;
+    CsrUint32 tag;
+#ifdef CSR_SUPPORT_SME
+    /* (un)controlled port configuration */
+    unifi_port_config_t controlled_data_port;
+    unifi_port_config_t uncontrolled_data_port;
+
+    /* station record maintenance related data structures */
+    CsrUint8 num_stations_joined;
+    CsrWifiRouterCtrlStaInfo_t *(staInfo)[UNIFI_MAX_CONNECTIONS];
+    struct list_head genericMgtFrames;
+    struct list_head genericMulticastOrBroadCastFrames;
+    struct list_head genericMulticastOrBroadCastMgtFrames;
+    struct list_head directedMaPktReq;
+
+    /* Timer for detecting station inactivity */
+    struct timer_list sta_activity_check_timer;
+    CsrBool sta_activity_check_enabled;
+
+    /* Timestamp when the last inactivity check was done */
+    CsrTime last_inactivity_check;
+
+    /*number of multicast or borad cast packets  queued*/
+    CsrUint16 noOfbroadcastPktQueued;
+#endif
+    /* A list to hold the buffered uncontrolled port packets */
+    struct list_head rx_uncontrolled_list;
+    /* A list to hold the buffered controlled port packets */
+    struct list_head rx_controlled_list;
+    /* Buffered M4 signal to take care of WPA race condition */
+    CSR_SIGNAL m4_signal;
+    bulk_data_desc_t m4_bulk_data;
+    /* This should be removed and m4_hostTag should be used for checking*/
+    CsrBool m4_sent;
+    CSR_CLIENT_TAG m4_hostTag;
+    CsrBool dtimActive;
+    CsrBool intraBssEnabled;
+    CsrUint32 multicastPduHostTag; /* Used to set the tim after getting
+       a confirm for it */
+} netInterface_priv_t;
+
+typedef struct maPktReqList{
+    struct list_head q;
+    struct sk_buff *skb;
+    CSR_SIGNAL signal;
+    CSR_CLIENT_TAG hostTag;
+    CsrUint32 staHandler;
+    unsigned long jiffeTime;
+}maPktReqList_t;
+
+#ifndef ALLOW_Q_PAUSE
+#define net_is_tx_q_paused(priv, q)   (priv->tx_q_paused_flag[q])
+#define net_tx_q_unpause(priv, q)   (priv->tx_q_paused_flag[q] = 0)
+#define net_tx_q_pause(priv, q)   (priv->tx_q_paused_flag[q] = 1)
+#endif
+
+#ifdef CSR_SUPPORT_SME
+#define routerStartBuffering(priv,queue) priv->routerBufferEnable[(queue)] = TRUE;
+#define routerStopBuffering(priv,queue) priv->routerBufferEnable[(queue)]  = FALSE;
+#define isRouterBufferEnabled(priv,queue) priv->routerBufferEnable[(queue)]
+#endif
+
+#ifdef USE_DRIVER_LOCK
+#define LOCK_DRIVER(_p)         down_interruptible(&(_p)->lock)
+#define UNLOCK_DRIVER(_p)       up(&(_p)->lock)
+#else
+#define LOCK_DRIVER(_p)         (void)(_p); /* as nothing */
+#define UNLOCK_DRIVER(_p)       (void)(_p); /* as nothing */
+#endif /* USE_DRIVER_LOCK */
+
+CsrInt32 CsrHipResultToStatus(CsrResult csrResult);
+
+
+/*
+ * SDIO related functions and callbacks
+ */
+int  uf_sdio_load(void);
+void uf_sdio_unload(void);
+unifi_priv_t *uf_find_instance(int inst);
+int uf_find_priv(unifi_priv_t *priv);
+int uf_find_netdev_priv(netInterface_priv_t *priv);
+unifi_priv_t *uf_get_instance(int inst);
+void uf_put_instance(int inst);
+int csr_sdio_linux_install_irq(CsrSdioFunction *sdio);
+int csr_sdio_linux_remove_irq(CsrSdioFunction *sdio);
+
+void uf_add_os_device(int bus_id, struct device *os_device);
+void uf_remove_os_device(int bus_id);
+
+
+
+/*
+ * Claim/release SDIO
+ *
+ * For multifunction cards, we cannot grub the SDIO lock around the unifi_bh()
+ * as this prevents other functions using SDIO.
+ * Since some of CSR SDIO API is used regardless of trying to lock unifi_bh()
+ * we have followed this scheme:
+ * 1. If a function needs protection only when CSR_WIFI_SINGLE_FUNCTION is defined
+ *    then we call CsrSdioClaim/CsrSdioRelease().
+ * 2. If a function needs protection only when CSR_WIFI_SINGLE_FUNCTION is not defined
+ *    then we call _sdio_claim_host/_sdio_claim_host(). Use of this should be restricted
+ *    to the SDIO glue layer only (e.g. sdio_mmc.c).
+ * 3. If a function needs protection, regardless of the CSR_WIFI_SINGLE_FUNCTION
+ *    then we call directly the sdio_claim_host/sdio_release_host().
+ *    Use of this must be restricted to the SDIO glue layer only (e.g. sdio_mmc.c).
+ *
+ * Note: The _func and function pointers are _not_ the same.
+ * The former is the (struct sdio_func*) context, which restricts the use to the SDIO glue layer.
+ * The latter is the (CsrSdioFunction*) context, which allows calls from all layers.
+ */
+
+#ifdef CSR_WIFI_SUPPORT_MMC_DRIVER
+
+#ifdef CSR_WIFI_SINGLE_FUNCTION
+#define CsrSdioClaim(function)    sdio_claim_host((function)->priv);
+#define CsrSdioRelease(function)  sdio_release_host((function)->priv);
+
+#define _sdio_claim_host(_func)
+#define _sdio_release_host(_func)
+
+#else
+#define CsrSdioClaim(function)
+#define CsrSdioRelease(function)
+
+#define _sdio_claim_host(_func)     sdio_claim_host(_func)
+#define _sdio_release_host(_func)   sdio_release_host(_func)
+
+#endif /* CSR_WIFI_SINGLE_FUNCTION */
+
+#else
+#define _sdio_claim_host(_func)
+#define _sdio_release_host(_func)
+
+#define CsrSdioClaim(function)
+#define CsrSdioRelease(function)
+
+#endif /* CSR_WIFI_SUPPORT_MMC_DRIVER */
+
+
+/*
+ * Functions to allocate and free an ethernet device.
+ */
+unifi_priv_t *uf_alloc_netdevice(CsrSdioFunction *sdio_dev, int bus_id);
+int uf_free_netdevice(unifi_priv_t *priv);
+
+/* Allocating function for other interfaces */
+CsrBool uf_alloc_netdevice_for_other_interfaces(unifi_priv_t *priv, CsrUint16 interfaceTag);
+
+/*
+ * Firmware download related functions.
+ */
+int uf_run_unifihelper(unifi_priv_t *priv);
+int uf_request_firmware_files(unifi_priv_t *priv, int is_fw);
+int uf_release_firmware_files(unifi_priv_t *priv);
+int uf_release_firmware(unifi_priv_t *priv, struct dlpriv *to_free);
+
+/*
+ * Functions to create and delete the device nodes.
+ */
+int uf_create_device_nodes(unifi_priv_t *priv, int bus_id);
+void uf_destroy_device_nodes(unifi_priv_t *priv);
+
+/*
+ * Upper Edge Initialisation functions
+ */
+int uf_init_bh(unifi_priv_t *priv);
+int uf_init_hw(unifi_priv_t *priv);
+
+/* Thread related helper functions */
+int uf_start_thread(unifi_priv_t *priv, struct uf_thread *thread, int (*func)(void *));
+void uf_stop_thread(unifi_priv_t *priv, struct uf_thread *thread);
+void uf_wait_for_thread_to_stop(unifi_priv_t *priv, struct uf_thread *thread);
+
+
+/*
+ * Unifi Linux functions
+ */
+void ul_init_clients(unifi_priv_t *priv);
+
+/* Configuration flags */
+#define CLI_USING_WIRE_FORMAT   0x0002
+#define CLI_SME_USERSPACE       0x0020
+ul_client_t *ul_register_client(unifi_priv_t *priv,
+        unsigned int configuration,
+        udi_event_t udi_event_clbk);
+int ul_deregister_client(ul_client_t *pcli);
+
+int ul_send_signal_unpacked(unifi_priv_t *priv,
+                            CSR_SIGNAL *sigptr,
+                            bulk_data_param_t *bulkdata);
+int ul_send_signal_raw(unifi_priv_t *priv,
+                       unsigned char *sigptr, int siglen,
+                       bulk_data_param_t *bulkdata);
+
+void ul_log_config_ind(unifi_priv_t *priv, u8 *conf_param, int len);
+
+
+/*
+ * Data plane operations
+ */
+/*
+ *      data_tx.c
+ */
+int uf_verify_m4(unifi_priv_t *priv, const unsigned char *packet,
+        unsigned int length);
+
+#ifdef CSR_SUPPORT_SME
+CsrBool uf_check_broadcast_bssid(unifi_priv_t *priv, const bulk_data_param_t *bulkdata);
+CsrBool uf_process_pm_bit_for_peer(unifi_priv_t * priv, CsrWifiRouterCtrlStaInfo_t * srcStaInfo,CsrUint8 pmBit,CsrUint16 interfaceTag);
+void uf_process_ps_poll(unifi_priv_t *priv,CsrUint8* sa,CsrUint8* da,CsrUint8 pmBit,CsrUint16 interfaceTag);
+int uf_ap_process_data_pdu(unifi_priv_t *priv, struct sk_buff *skb,
+                   struct ethhdr *ehdr, CsrWifiRouterCtrlStaInfo_t * srcStaInfo,
+                   const CSR_SIGNAL *signal,
+                   bulk_data_param_t *bulkdata,
+                   CsrUint8 macHeaderLengthInBytes);
+CsrBool uf_is_more_data_for_non_delivery_ac(CsrWifiRouterCtrlStaInfo_t *staRecord);
+CsrBool uf_is_more_data_for_delivery_ac(unifi_priv_t *priv,CsrWifiRouterCtrlStaInfo_t *staRecord,CsrBool mgtCheck);
+void uf_process_wmm_deliver_ac_uapsd (  unifi_priv_t * priv,
+                                        CsrWifiRouterCtrlStaInfo_t * srcStaInfo,
+                                        CsrUint16 qosControl,
+                                        CsrUint16 interfaceTag);
+
+void uf_send_buffered_data_from_ac(unifi_priv_t *priv, CsrWifiRouterCtrlStaInfo_t * staInfo, CsrUint8 queue, struct list_head *txList);
+void uf_send_buffered_data_from_delivery_ac(unifi_priv_t *priv, CsrWifiRouterCtrlStaInfo_t * staInfo, CsrUint8 queue, struct list_head *txList);
+
+void uf_continue_uapsd(unifi_priv_t *priv, CsrWifiRouterCtrlStaInfo_t * staInfo);
+void uf_send_qos_null(unifi_priv_t * priv,CsrUint16 interfaceTag, const CsrUint8 *da,CSR_PRIORITY priority,CsrWifiRouterCtrlStaInfo_t * srcStaInfo);
+void uf_send_nulldata(unifi_priv_t * priv,CsrUint16 interfaceTag, const CsrUint8 *da,CSR_PRIORITY priority,CsrWifiRouterCtrlStaInfo_t * srcStaInfo);
+void uf_store_directed_ma_packet_referenece(unifi_priv_t *priv, bulk_data_param_t *bulkdata,CSR_SIGNAL *sigptr,CsrUint32 alignOffset);
+
+
+
+#endif
+CsrResult uf_process_ma_packet_req(unifi_priv_t *priv,  CsrUint8 *peerMacAddress, CSR_CLIENT_TAG hostTag, CsrUint16 interfaceTag, CSR_TRANSMISSION_CONTROL transmissionControl, CSR_RATE TransmitRate, CSR_PRIORITY priority, CSR_PROCESS_ID senderId, bulk_data_param_t *bulkdata);
+void uf_process_ma_vif_availibility_ind(unifi_priv_t *priv,CsrUint8 *sigdata, CsrUint32 siglen);
+#ifdef CSR_SUPPORT_SME
+void uf_send_buffered_frames(unifi_priv_t *priv,unifi_TrafficQueue queue);
+int uf_process_station_records_for_sending_data(unifi_priv_t *priv,CsrUint16 interfaceTag,
+                                                 CsrWifiRouterCtrlStaInfo_t *srcStaInfo,
+                                                 CsrWifiRouterCtrlStaInfo_t *dstStaInfo);
+void uf_prepare_send_cfm_list_for_queued_pkts(unifi_priv_t * priv,
+                                                 struct list_head *frames_need_cfm_list,
+                                                 struct list_head * list);
+void send_auto_ma_packet_confirm(unifi_priv_t *priv,
+                                 netInterface_priv_t *interfacePriv,
+                                 struct list_head *buffered_frames_list);
+void uf_flush_list(unifi_priv_t * priv, struct list_head * list);
+void uf_flush_maPktlist(unifi_priv_t * priv, struct list_head * list);
+tx_buffered_packets_t *dequeue_tx_data_pdu(unifi_priv_t *priv, struct list_head *txList);
+void resume_unicast_buffered_frames(unifi_priv_t *priv, CsrUint16 interfaceTag);
+void update_eosp_to_head_of_broadcast_list_head(unifi_priv_t *priv,CsrUint16 interfaceTag);
+void resume_suspended_uapsd(unifi_priv_t* priv,CsrUint16 interfaceTag);
+#endif
+/*
+ *      netdev.c
+ */
+
+#ifndef P80211_OUI_LEN
+#define P80211_OUI_LEN  3
+#endif
+typedef struct {
+    u8    dsap;   /* always 0xAA */
+    u8    ssap;   /* always 0xAA */
+    u8    ctrl;   /* always 0x03 */
+    u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+    u16 protocol;
+} __attribute__ ((packed)) llc_snap_hdr_t;
+int skb_add_llc_snap(struct net_device *dev, struct sk_buff *skb, int proto);
+int skb_80211_to_ether(unifi_priv_t *priv, struct sk_buff *skb,
+        const unsigned char *daddr, const unsigned char *saddr,
+        const CSR_SIGNAL *signal,
+        bulk_data_param_t *bulkdata);
+
+const char *result_code_str(int result);
+
+
+/* prepares & appends the Mac header for the payload */
+int prepare_and_add_macheader(unifi_priv_t *priv,
+                              struct sk_buff *skb,
+                              struct sk_buff *newSkb,
+                              CSR_PRIORITY priority,
+                              bulk_data_param_t *bulkdata,
+                              CsrUint16 interfaceTag,
+                              const CsrUint8 *daddr,
+                              const CsrUint8 *saddr,
+                              CsrBool protection);
+CSR_PRIORITY
+get_packet_priority(unifi_priv_t *priv, struct sk_buff *skb, const struct ethhdr *ehdr, netInterface_priv_t *interfacePriv);
+
+void
+unifi_frame_ma_packet_req(unifi_priv_t *priv, CSR_PRIORITY priority,
+                          CSR_RATE TransmitRate, CSR_CLIENT_TAG hostTag,
+                          CsrUint16 interfaceTag, CSR_TRANSMISSION_CONTROL transmissionControl,
+                          CSR_PROCESS_ID leSenderProcessId, CsrUint8 *peerMacAddress,
+                          CSR_SIGNAL *signal);
+
+
+/* Pack the LSB to include station handle & status of tim set */
+#define CSR_WIFI_PACK_SENDER_ID_LSB_FOR_TIM_REQ(handle, timState)  ((handle << 2) | timState)
+/* get the station record handle from the sender ID */
+#define CSR_WIFI_GET_STATION_HANDLE_FROM_RECEIVER_ID(receiverProcessId) (CsrUint8) ((receiverProcessId & 0xff) >> 2)
+/* get the timSet status from the sender ID */
+#define CSR_WIFI_GET_TIMSET_STATE_FROM_RECEIVER_ID(receiverProcessId)  (CsrUint8) (receiverProcessId & 0x03)
+
+/* handle is 6 bits to accomodate in senderId LSB (only 64 station can be associated) */
+#define CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE 0x3F
+
+void update_tim(unifi_priv_t * priv, CsrUint16 aid, CsrUint8 setTim, CsrUint16 interfaceTag, CsrUint32 handle);
+void uf_handle_tim_cfm(unifi_priv_t *priv, CSR_MLME_SET_TIM_CONFIRM *cfm, CsrUint16 senderProcessId);
+
+/* Clear the Peer station Record, in case of wifioff/unexpected card removal */
+void CsrWifiRouterCtrlInterfaceReset(unifi_priv_t *priv, CsrUint16 interfaceTag);
+
+void scroll_ba_window(unifi_priv_t *priv,
+                      netInterface_priv_t *interfacePriv,
+                      ba_session_rx_struct *ba_session,
+                      CsrUint16 sn);
+
+CsrBool blockack_session_stop(unifi_priv_t *priv,
+                              CsrUint16 interfaceTag,
+                              CsrWifiRouterCtrlBlockAckRole role,
+                              CsrUint16 tID,
+                              CsrWifiMacAddress macAddress);
+#ifdef CSR_SUPPORT_SME
+/* Fetch the protection information from interface Mode */
+CsrInt8 uf_get_protection_bit_from_interfacemode(unifi_priv_t *priv, CsrUint16 interfaceTag, const CsrUint8 *daddr);
+#endif
+
+/* Fetch the station record handler from data base for matching Mac address */
+#ifdef CSR_SUPPORT_SME
+CsrWifiRouterCtrlStaInfo_t *CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(unifi_priv_t *priv,
+                                                                                const CsrUint8 *peerMacAddress,
+                                                                                CsrUint16 interfaceTag);
+
+/* Fetch the station record handler from data base for matching handle */
+CsrWifiRouterCtrlStaInfo_t * CsrWifiRouterCtrlGetStationRecordFromHandle(unifi_priv_t *priv,
+                                                                 CsrUint32 handle,
+                                                                 CsrUint16 interfaceTag);
+
+void uf_update_sta_activity(unifi_priv_t *priv, CsrUint16 interfaceTag, const CsrUint8 *peerMacAddress);
+void uf_process_ma_pkt_cfm_for_ap(unifi_priv_t *priv,CsrUint16 interfaceTag, const CSR_MA_PACKET_CONFIRM *pkt_cfm);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+int uf_install_qdisc(struct net_device *dev);
+#endif
+
+void uf_resume_data_plane(unifi_priv_t *priv, int queue,
+                          CsrWifiMacAddress peer_address,
+                          CsrUint16 interfaceTag);
+void uf_free_pending_rx_packets(unifi_priv_t *priv, int queue,
+        CsrWifiMacAddress peer_address,CsrUint16 interfaceTag);
+
+int uf_register_netdev(unifi_priv_t *priv, int numOfInterface);
+void uf_unregister_netdev(unifi_priv_t *priv);
+
+void uf_net_get_name(struct net_device *dev, char *name, int len);
+
+void uf_send_queue_info(unifi_priv_t *priv);
+CsrUint16 uf_get_vif_identifier(CsrWifiRouterCtrlMode mode, CsrUint16 tag);
+
+void uf_process_rx_pending_queue(unifi_priv_t *priv, int queue,
+                                 CsrWifiMacAddress source_address,
+                                 int indicate, CsrUint16 interfaceTag);
+
+/*
+ *      inet.c
+ */
+void uf_register_inet_notifier(void);
+void uf_unregister_inet_notifier(void);
+
+
+/*
+ * Suspend / Resume handlers
+ */
+void unifi_resume(void *ospriv);
+void unifi_suspend(void *ospriv);
+
+
+#define QOS_CAPABILITY_WMM_ENABLED      0x0001
+#define QOS_CAPABILITY_WMM_UAPSD        0x0002
+#define QOS_CAPABILITY_ACM_BE_ENABLED   0x0010
+#define QOS_CAPABILITY_ACM_BK_ENABLED   0x0020
+#define QOS_CAPABILITY_ACM_VI_ENABLED   0x0040
+#define QOS_CAPABILITY_ACM_VO_ENABLED   0x0080
+#define QOS_CAPABILITY_TS_BE_ENABLED    0x0100
+#define QOS_CAPABILITY_TS_BK_ENABLED    0x0200
+#define QOS_CAPABILITY_TS_VI_ENABLED    0x0400
+#define QOS_CAPABILITY_TS_VO_ENABLED    0x0800
+
+
+/* EAPOL PDUS */
+#ifndef ETH_P_PAE
+#define ETH_P_PAE 0x888e
+#endif
+#ifndef ETH_P_WAI
+#define ETH_P_WAI 0x88b4
+#endif
+/*
+ * unifi_dbg.c
+ */
+void debug_string_indication(unifi_priv_t *priv,
+        const unsigned char *extra,
+        unsigned int extralen);
+void debug_word16_indication(unifi_priv_t *priv, const CSR_SIGNAL *sigptr);
+void debug_generic_indication(unifi_priv_t *priv, const CSR_SIGNAL *sigptr);
+
+
+/*
+ * putest.c
+ */
+int unifi_putest_start(unifi_priv_t *priv, unsigned char *arg);
+int unifi_putest_cmd52_block_read(unifi_priv_t *priv, unsigned char *arg);
+int unifi_putest_stop(unifi_priv_t *priv, unsigned char *arg);
+int unifi_putest_set_sdio_clock(unifi_priv_t *priv, unsigned char *arg);
+int unifi_putest_cmd52_read(unifi_priv_t *priv, unsigned char *arg);
+int unifi_putest_coredump_prepare(unifi_priv_t *priv, unsigned char *arg);
+int unifi_putest_cmd52_write(unifi_priv_t *priv, unsigned char *arg);
+int unifi_putest_gp_read16(unifi_priv_t *priv, unsigned char *arg);
+int unifi_putest_gp_write16(unifi_priv_t *priv, unsigned char *arg);
+
+int unifi_putest_dl_fw(unifi_priv_t *priv, unsigned char *arg);
+int unifi_putest_dl_fw_buff(unifi_priv_t *priv, unsigned char *arg);
+
+
+/* Macro for formatting a MAC address with a prefix string */
+#define UF_TRACE_MAC(priv, lvl, msg, addr) \
+        unifi_trace(priv, lvl, \
+                                "%s %02x-%02x-%02x-%02x-%02x-%02x\n", \
+                                msg,    \
+                                *(((CsrUint8 *)addr)+0),  \
+                                *(((CsrUint8 *)addr)+1),  \
+                                *(((CsrUint8 *)addr)+2),  \
+                                *(((CsrUint8 *)addr)+3),  \
+                                *(((CsrUint8 *)addr)+4),  \
+                                *(((CsrUint8 *)addr)+5))
+
+#endif /* __LINUX_UNIFI_PRIV_H__ */
--- /dev/null
+++ b/drivers/staging/csr/unifi_sme.c
@@ -0,0 +1,1164 @@
+/*
+ * ***************************************************************************
+ *  FILE:     unifi_sme.c
+ *
+ *  PURPOSE:    SME related functions.
+ *
+ *  Copyright (C) 2007-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ***************************************************************************
+ */
+
+#include "unifi_priv.h"
+#include "csr_wifi_hip_unifi.h"
+#include "csr_wifi_hip_conversions.h"
+
+
+
+
+    int
+convert_sme_error(CsrResult error)
+{
+    switch (error) {
+        case CSR_RESULT_SUCCESS:
+            return 0;
+        case CSR_RESULT_FAILURE:
+        case CSR_WIFI_RESULT_NOT_FOUND:
+        case CSR_WIFI_RESULT_TIMED_OUT:
+        case CSR_WIFI_RESULT_CANCELLED:
+        case CSR_WIFI_RESULT_UNAVAILABLE:
+            return -EIO;
+        case CSR_WIFI_RESULT_NO_ROOM:
+            return -EBUSY;
+        case CSR_WIFI_RESULT_INVALID_PARAMETER:
+            return -EINVAL;
+        case CSR_WIFI_RESULT_UNSUPPORTED:
+            return -EOPNOTSUPP;
+        default:
+            return -EIO;
+    }
+}
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  sme_log_event
+ *
+ *      Callback function to be registered as the SME event callback.
+ *      Copies the signal content into a new udi_log_t struct and adds
+ *      it to the read queue for the SME client.
+ *
+ *  Arguments:
+ *      arg             This is the value given to unifi_add_udi_hook, in
+ *                      this case a pointer to the client instance.
+ *      signal          Pointer to the received signal.
+ *      signal_len      Size of the signal structure in bytes.
+ *      bulkdata        Pointers to any associated bulk data.
+ *      dir             Direction of the signal. Zero means from host,
+ *                      non-zero means to host.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+    void
+sme_log_event(ul_client_t *pcli,
+        const u8 *signal, int signal_len,
+        const bulk_data_param_t *bulkdata,
+        int dir)
+{
+    unifi_priv_t *priv;
+    CSR_SIGNAL unpacked_signal;
+    CsrWifiSmeDataBlock mlmeCommand;
+    CsrWifiSmeDataBlock dataref1;
+    CsrWifiSmeDataBlock dataref2;
+    CsrResult result = CSR_RESULT_SUCCESS;
+    int r;
+
+    /* Following bits are encoded in hostTag These are there to ensure that hostTags are unique*/
+#define CSR_SME_DATA     0x00000000  /* Frames Sent by SME */
+#define CSR_PAL_DATA     0X10000000  /* Frames Sent by PAL-D*/
+#define CSR_NME_DATA     0x20000000  /* Frames Sent by NME*/
+#define APPLICATION_DATA 0x30000000  /* Frames Sent by Application*/
+
+    func_enter();
+    /* Just a sanity check */
+    if ((signal == NULL) || (signal_len <= 0)) {
+        func_exit();
+        return;
+    }
+
+    priv = uf_find_instance(pcli->instance);
+    if (!priv) {
+        unifi_error(priv, "sme_log_event: invalid priv\n");
+        func_exit();
+        return;
+    }
+
+    if (priv->smepriv == NULL) {
+        unifi_error(priv, "sme_log_event: invalid smepriv\n");
+        func_exit();
+        return;
+    }
+
+    unifi_trace(priv, UDBG3,
+            "sme_log_event: Process signal 0x%.4X\n",
+            CSR_GET_UINT16_FROM_LITTLE_ENDIAN(signal));
+
+
+    /* If the signal is known, then do any filtering required, otherwise it pass it to the SME. */
+    r = read_unpack_signal(signal, &unpacked_signal);
+    if (r == CSR_RESULT_SUCCESS) {
+        if ((unpacked_signal.SignalPrimitiveHeader.SignalId == CSR_DEBUG_STRING_INDICATION_ID) ||
+            (unpacked_signal.SignalPrimitiveHeader.SignalId == CSR_DEBUG_WORD16_INDICATION_ID))
+        {
+            func_exit();
+            return;
+        }
+        if (unpacked_signal.SignalPrimitiveHeader.SignalId == CSR_MA_PACKET_INDICATION_ID)
+        {
+            CsrUint16 frmCtrl;
+            CsrBool unicastPdu = TRUE;
+            CsrUint8 *macHdrLocation;
+            CsrUint8 *raddr = NULL, *taddr = NULL;
+            CsrWifiMacAddress peerMacAddress;
+            /* Check if we need to send CsrWifiRouterCtrlMicFailureInd*/
+            CSR_MA_PACKET_INDICATION *ind = &unpacked_signal.u.MaPacketIndication;
+
+            macHdrLocation = (CsrUint8 *) bulkdata->d[0].os_data_ptr;
+            /* Fetch the frame control value from  mac header */
+            frmCtrl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(macHdrLocation);
+
+            /* Point to the addresses */
+            raddr = macHdrLocation + MAC_HEADER_ADDR1_OFFSET;
+            taddr = macHdrLocation + MAC_HEADER_ADDR2_OFFSET;
+
+            CsrMemCpy(peerMacAddress.a, taddr, ETH_ALEN);
+
+            if(ind->ReceptionStatus == CSR_MICHAEL_MIC_ERROR)
+            {
+                if (*raddr & 0x1)
+                    unicastPdu = FALSE;
+
+                CsrWifiRouterCtrlMicFailureIndSend (priv->CSR_WIFI_SME_IFACEQUEUE, 0,
+                        (ind->VirtualInterfaceIdentifier & 0xff),peerMacAddress,
+                        unicastPdu);
+                return;
+            }
+            else
+            {
+                if(ind->ReceptionStatus == CSR_RX_SUCCESS)
+                {
+                    CsrUint8 pmBit = (frmCtrl & 0x1000)?0x01:0x00;
+                    CsrUint16 interfaceTag = (ind->VirtualInterfaceIdentifier & 0xff);
+                    CsrWifiRouterCtrlStaInfo_t *srcStaInfo =  CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv,taddr,interfaceTag);
+                    if((srcStaInfo != NULL) && (uf_check_broadcast_bssid(priv, bulkdata)== FALSE))
+                    {
+                        uf_process_pm_bit_for_peer(priv,srcStaInfo,pmBit,interfaceTag);
+
+                        /* Update station last activity flag */
+                        srcStaInfo->activity_flag = TRUE;
+                    }
+                }
+            }
+        }
+
+        if (unpacked_signal.SignalPrimitiveHeader.SignalId == CSR_MA_PACKET_CONFIRM_ID)
+        {
+            CSR_MA_PACKET_CONFIRM *cfm = &unpacked_signal.u.MaPacketConfirm;
+            CsrUint16 interfaceTag = (cfm->VirtualInterfaceIdentifier & 0xff);
+            netInterface_priv_t *interfacePriv;
+            CSR_MA_PACKET_REQUEST *req;
+            CsrWifiMacAddress peerMacAddress;
+
+            if (interfaceTag >= CSR_WIFI_NUM_INTERFACES)
+            {
+                unifi_error(priv, "Bad MA_PACKET_CONFIRM interfaceTag %d\n", interfaceTag);
+                func_exit();
+                return;
+            }
+
+            unifi_trace(priv,UDBG1,"MA-PACKET Confirm (%x, %x)\n", cfm->HostTag, cfm->TransmissionStatus);
+
+            interfacePriv = priv->interfacePriv[interfaceTag];
+#ifdef CSR_SUPPORT_SME
+            if(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||
+                 interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {
+
+                if(cfm->HostTag == interfacePriv->multicastPduHostTag){
+                    uf_process_ma_pkt_cfm_for_ap(priv ,interfaceTag, cfm);
+                }
+            }
+#endif
+
+            req = &interfacePriv->m4_signal.u.MaPacketRequest;
+
+            if(cfm->HostTag & 0x80000000)
+            {
+                if (cfm->TransmissionStatus != CSR_TX_SUCCESSFUL)
+                {
+                    result = CSR_RESULT_FAILURE;
+                }
+#ifdef CSR_SUPPORT_SME
+                memcpy(peerMacAddress.a, req->Ra.x, ETH_ALEN);
+                /* Check if this is a confirm for EAPOL M4 frame and we need to send transmistted ind*/
+                if (interfacePriv->m4_sent && (cfm->HostTag == interfacePriv->m4_hostTag))
+                {
+                    unifi_trace(priv, UDBG1, "%s: Sending M4 Transmit CFM\n", __FUNCTION__);
+                    CsrWifiRouterCtrlM4TransmittedIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0,
+                            interfaceTag,
+                            peerMacAddress,
+                            result);
+                    interfacePriv->m4_sent = FALSE;
+                    interfacePriv->m4_hostTag = 0xffffffff;
+                }
+#endif
+                /* If EAPOL was requested via router APIs then send cfm else ignore*/
+                if((cfm->HostTag & 0x80000000) != CSR_WIFI_EAPOL_M4_HOST_TAG) {
+                    CsrWifiRouterMaPacketCfmSend((CsrUint16)signal[2],
+                        cfm->VirtualInterfaceIdentifier,
+                        result,
+                        (cfm->HostTag & 0x3fffffff), cfm->Rate);
+                } else {
+                    unifi_trace(priv, UDBG1, "%s: M4 received from netdevice\n", __FUNCTION__);
+                }
+                func_exit();
+                return;
+            }
+        }
+    }
+
+    mlmeCommand.length = signal_len;
+    mlmeCommand.data = (CsrUint8*)signal;
+
+    dataref1.length = bulkdata->d[0].data_length;
+    if (dataref1.length > 0) {
+        dataref1.data = (CsrUint8 *) bulkdata->d[0].os_data_ptr;
+    } else
+    {
+        dataref1.data = NULL;
+    }
+
+    dataref2.length = bulkdata->d[1].data_length;
+    if (dataref2.length > 0) {
+        dataref2.data = (CsrUint8 *) bulkdata->d[1].os_data_ptr;
+    } else
+    {
+        dataref2.data = NULL;
+    }
+
+    CsrWifiRouterCtrlHipIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, mlmeCommand.length, mlmeCommand.data,
+            dataref1.length, dataref1.data,
+            dataref2.length, dataref2.data);
+
+    func_exit();
+} /* sme_log_event() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ * uf_sme_port_state
+ *
+ *      Return the state of the controlled port.
+ *
+ * Arguments:
+ *      priv            Pointer to device private context struct
+ *      address    Pointer to the destination for tx or sender for rx address
+ *      queue           Controlled or uncontrolled queue
+ *
+ * Returns:
+ *      An unifi_ControlledPortAction value.
+ * ---------------------------------------------------------------------------
+ */
+CsrWifiRouterCtrlPortAction
+uf_sme_port_state(unifi_priv_t *priv, unsigned char *address, int queue, CsrUint16 interfaceTag)
+{
+    int i;
+    unifi_port_config_t *port;
+    netInterface_priv_t *interfacePriv;
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "uf_sme_port_state: bad interfaceTag\n");
+        return CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;
+    }
+
+    interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if (queue == UF_CONTROLLED_PORT_Q) {
+        port = &interfacePriv->controlled_data_port;
+    } else {
+        port = &interfacePriv->uncontrolled_data_port;
+    }
+
+    if (!port->entries_in_use) {
+        unifi_trace(priv, UDBG5, "No port configurations, return Discard.\n");
+        return CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;
+    }
+
+    /* If the port configuration is common for all destinations, return it. */
+    if (port->overide_action == UF_DATA_PORT_OVERIDE) {
+        unifi_trace(priv, UDBG5, "Single port configuration (%d).\n",
+                port->port_cfg[0].port_action);
+        return port->port_cfg[0].port_action;
+    }
+
+    unifi_trace(priv, UDBG5, "Multiple (%d) port configurations.\n", port->entries_in_use);
+
+    /* If multiple configurations exist.. */
+    for (i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {
+        /* .. go through the list and match the destination address. */
+        if (port->port_cfg[i].in_use &&
+            memcmp(address, port->port_cfg[i].mac_address.a, ETH_ALEN) == 0) {
+            /* Return the desired action. */
+            return port->port_cfg[i].port_action;
+        }
+    }
+
+    /* Could not find any information, return Open. */
+    unifi_trace(priv, UDBG5, "port configuration not found, return Open.\n");
+    return CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN;
+} /* uf_sme_port_state() */
+
+/*
+ * ---------------------------------------------------------------------------
+ * uf_sme_port_config_handle
+ *
+ *      Return the port config handle of the controlled/uncontrolled port.
+ *
+ * Arguments:
+ *      priv            Pointer to device private context struct
+ *      address    Pointer to the destination for tx or sender for rx address
+ *      queue           Controlled or uncontrolled queue
+ *
+ * Returns:
+ *      An  unifi_port_cfg_t* .
+ * ---------------------------------------------------------------------------
+ */
+unifi_port_cfg_t*
+uf_sme_port_config_handle(unifi_priv_t *priv, unsigned char *address, int queue, CsrUint16 interfaceTag)
+{
+    int i;
+    unifi_port_config_t *port;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "uf_sme_port_config_handle: bad interfaceTag\n");
+        return NULL;
+    }
+
+    if (queue == UF_CONTROLLED_PORT_Q) {
+        port = &interfacePriv->controlled_data_port;
+    } else {
+        port = &interfacePriv->uncontrolled_data_port;
+    }
+
+    if (!port->entries_in_use) {
+        unifi_trace(priv, UDBG5, "No port configurations, return Discard.\n");
+        return NULL;
+    }
+
+    /* If the port configuration is common for all destinations, return it. */
+    if (port->overide_action == UF_DATA_PORT_OVERIDE) {
+        unifi_trace(priv, UDBG5, "Single port configuration (%d).\n",
+                port->port_cfg[0].port_action);
+        if (address) {
+            unifi_trace(priv, UDBG5, "addr[0] = %x, addr[1] = %x, addr[2] = %x, addr[3] = %x\n", address[0], address[1], address[2], address[3]);
+        }
+        return &port->port_cfg[0];
+    }
+
+    unifi_trace(priv, UDBG5, "Multiple port configurations.\n");
+
+    /* If multiple configurations exist.. */
+    for (i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {
+        /* .. go through the list and match the destination address. */
+        if (port->port_cfg[i].in_use &&
+            memcmp(address, port->port_cfg[i].mac_address.a, ETH_ALEN) == 0) {
+            /* Return the desired action. */
+            return &port->port_cfg[i];
+        }
+    }
+
+    /* Could not find any information, return Open. */
+    unifi_trace(priv, UDBG5, "port configuration not found, returning NULL (debug).\n");
+    return NULL;
+} /* uf_sme_port_config_handle */
+
+void
+uf_multicast_list_wq(struct work_struct *work)
+{
+    unifi_priv_t *priv = container_of(work, unifi_priv_t,
+            multicast_list_task);
+    int i;
+    CsrUint16 interfaceTag = 0;
+    CsrWifiMacAddress* multicast_address_list = NULL;
+    int mc_count;
+    u8 *mc_list;
+    netInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "uf_multicast_list_wq: bad interfaceTag\n");
+        return;
+    }
+
+    unifi_trace(priv, UDBG5,
+            "uf_multicast_list_wq: list count = %d\n",
+            interfacePriv->mc_list_count);
+
+    /* Flush the current list */
+    CsrWifiRouterCtrlMulticastAddressIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0, interfaceTag, CSR_WIFI_SME_LIST_ACTION_FLUSH, 0, NULL);
+
+    mc_count = interfacePriv->mc_list_count;
+    mc_list = interfacePriv->mc_list;
+    /*
+     * Allocate a new list, need to free it later
+     * in unifi_mgt_multicast_address_cfm().
+     */
+    multicast_address_list = CsrPmemAlloc(mc_count * sizeof(CsrWifiMacAddress));
+
+    if (multicast_address_list == NULL) {
+        return;
+    }
+
+    for (i = 0; i < mc_count; i++) {
+        memcpy(multicast_address_list[i].a, mc_list, ETH_ALEN);
+        mc_list += ETH_ALEN;
+    }
+
+    if (priv->smepriv == NULL) {
+        CsrPmemFree(multicast_address_list);
+        return;
+    }
+
+    CsrWifiRouterCtrlMulticastAddressIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,
+            interfaceTag,
+            CSR_WIFI_SME_LIST_ACTION_ADD,
+            mc_count, multicast_address_list);
+
+    /* The SME will take a copy of the addreses*/
+    CsrPmemFree(multicast_address_list);
+}
+
+
+int unifi_cfg_power(unifi_priv_t *priv, unsigned char *arg)
+{
+    unifi_cfg_power_t cfg_power;
+    int rc;
+
+    if (get_user(cfg_power, (unifi_cfg_power_t*)(((unifi_cfg_command_t*)arg) + 1))) {
+        unifi_error(priv, "UNIFI_CFG: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    switch (cfg_power) {
+        case UNIFI_CFG_POWER_OFF:
+            rc = sme_sys_suspend(priv);
+            if (rc) {
+                return rc;
+            }
+            break;
+        case UNIFI_CFG_POWER_ON:
+            rc = sme_sys_resume(priv);
+            if (rc) {
+                return rc;
+            }
+            break;
+        default:
+            unifi_error(priv, "WIFI POWER: Unknown value.\n");
+            return -EINVAL;
+    }
+
+    return 0;
+}
+
+
+int unifi_cfg_power_save(unifi_priv_t *priv, unsigned char *arg)
+{
+    unifi_cfg_powersave_t cfg_power_save;
+    CsrWifiSmePowerConfig powerConfig;
+    int rc;
+
+    if (get_user(cfg_power_save, (unifi_cfg_powersave_t*)(((unifi_cfg_command_t*)arg) + 1))) {
+        unifi_error(priv, "UNIFI_CFG: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    /* Get the coex info from the SME */
+    rc = sme_mgt_power_config_get(priv, &powerConfig);
+    if (rc) {
+        unifi_error(priv, "UNIFI_CFG: Get unifi_PowerConfigValue failed.\n");
+        return rc;
+    }
+
+    switch (cfg_power_save) {
+        case UNIFI_CFG_POWERSAVE_NONE:
+            powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_LOW;
+            break;
+        case UNIFI_CFG_POWERSAVE_FAST:
+            powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_MED;
+            break;
+        case UNIFI_CFG_POWERSAVE_FULL:
+            powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_HIGH;
+            break;
+        case UNIFI_CFG_POWERSAVE_AUTO:
+            powerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_AUTO;
+            break;
+        default:
+            unifi_error(priv, "POWERSAVE: Unknown value.\n");
+            return -EINVAL;
+    }
+
+    rc = sme_mgt_power_config_set(priv, &powerConfig);
+
+    if (rc) {
+        unifi_error(priv, "UNIFI_CFG: Set unifi_PowerConfigValue failed.\n");
+    }
+
+    return rc;
+}
+
+
+int unifi_cfg_power_supply(unifi_priv_t *priv, unsigned char *arg)
+{
+    unifi_cfg_powersupply_t cfg_power_supply;
+    CsrWifiSmeHostConfig hostConfig;
+    int rc;
+
+    if (get_user(cfg_power_supply, (unifi_cfg_powersupply_t*)(((unifi_cfg_command_t*)arg) + 1))) {
+        unifi_error(priv, "UNIFI_CFG: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    /* Get the coex info from the SME */
+    rc = sme_mgt_host_config_get(priv, &hostConfig);
+    if (rc) {
+        unifi_error(priv, "UNIFI_CFG: Get unifi_HostConfigValue failed.\n");
+        return rc;
+    }
+
+    switch (cfg_power_supply) {
+        case UNIFI_CFG_POWERSUPPLY_MAINS:
+            hostConfig.powerMode = CSR_WIFI_SME_HOST_POWER_MODE_ACTIVE;
+            break;
+        case UNIFI_CFG_POWERSUPPLY_BATTERIES:
+            hostConfig.powerMode = CSR_WIFI_SME_HOST_POWER_MODE_POWER_SAVE;
+            break;
+        default:
+            unifi_error(priv, "POWERSUPPLY: Unknown value.\n");
+            return -EINVAL;
+    }
+
+    rc = sme_mgt_host_config_set(priv, &hostConfig);
+    if (rc) {
+        unifi_error(priv, "UNIFI_CFG: Set unifi_HostConfigValue failed.\n");
+    }
+
+    return rc;
+}
+
+
+int unifi_cfg_packet_filters(unifi_priv_t *priv, unsigned char *arg)
+{
+    unsigned char *tclas_buffer;
+    unsigned int tclas_buffer_length;
+    tclas_t *dhcp_tclas;
+    int rc;
+
+    /* Free any TCLASs previously allocated */
+    if (priv->packet_filters.tclas_ies_length) {
+        CsrPmemFree(priv->filter_tclas_ies);
+        priv->filter_tclas_ies = NULL;
+    }
+
+    tclas_buffer = ((unsigned char*)arg) + sizeof(unifi_cfg_command_t) + sizeof(unsigned int);
+    if (copy_from_user(&priv->packet_filters, (void*)tclas_buffer,
+                sizeof(uf_cfg_bcast_packet_filter_t))) {
+        unifi_error(priv, "UNIFI_CFG: Failed to get the filter struct\n");
+        return -EFAULT;
+    }
+
+    tclas_buffer_length = priv->packet_filters.tclas_ies_length;
+
+    /* Allocate TCLASs if necessary */
+    if (priv->packet_filters.dhcp_filter) {
+        priv->packet_filters.tclas_ies_length += sizeof(tclas_t);
+    }
+    if (priv->packet_filters.tclas_ies_length > 0) {
+        priv->filter_tclas_ies = CsrPmemAlloc(priv->packet_filters.tclas_ies_length);
+        if (priv->filter_tclas_ies == NULL) {
+            return -ENOMEM;
+        }
+        if (tclas_buffer_length) {
+            tclas_buffer += sizeof(uf_cfg_bcast_packet_filter_t) - sizeof(unsigned char*);
+            if (copy_from_user(priv->filter_tclas_ies,
+                        tclas_buffer,
+                        tclas_buffer_length)) {
+                unifi_error(priv, "UNIFI_CFG: Failed to get the TCLAS buffer\n");
+                return -EFAULT;
+            }
+        }
+    }
+
+    if(priv->packet_filters.dhcp_filter)
+    {
+        /* Append the DHCP tclas IE */
+        dhcp_tclas = (tclas_t*)(priv->filter_tclas_ies + tclas_buffer_length);
+        memset(dhcp_tclas, 0, sizeof(tclas_t));
+        dhcp_tclas->element_id = 14;
+        dhcp_tclas->length = sizeof(tcpip_clsfr_t) + 1;
+        dhcp_tclas->user_priority = 0;
+        dhcp_tclas->tcp_ip_cls_fr.cls_fr_type = 1;
+        dhcp_tclas->tcp_ip_cls_fr.version = 4;
+        ((CsrUint8*)(&dhcp_tclas->tcp_ip_cls_fr.source_port))[0] = 0x00;
+        ((CsrUint8*)(&dhcp_tclas->tcp_ip_cls_fr.source_port))[1] = 0x44;
+        ((CsrUint8*)(&dhcp_tclas->tcp_ip_cls_fr.dest_port))[0] = 0x00;
+        ((CsrUint8*)(&dhcp_tclas->tcp_ip_cls_fr.dest_port))[1] = 0x43;
+        dhcp_tclas->tcp_ip_cls_fr.protocol = 0x11;
+        dhcp_tclas->tcp_ip_cls_fr.cls_fr_mask = 0x58; //bits: 3,4,6
+    }
+
+    rc = sme_mgt_packet_filter_set(priv);
+
+    return rc;
+}
+
+
+int unifi_cfg_wmm_qos_info(unifi_priv_t *priv, unsigned char *arg)
+{
+    CsrUint8 wmm_qos_info;
+    int rc = 0;
+
+    if (get_user(wmm_qos_info, (CsrUint8*)(((unifi_cfg_command_t*)arg) + 1))) {
+        unifi_error(priv, "UNIFI_CFG: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    /* Store the value in the connection info */
+    priv->connection_config.wmmQosInfo = wmm_qos_info;
+
+    return rc;
+}
+
+
+int unifi_cfg_wmm_addts(unifi_priv_t *priv, unsigned char *arg)
+{
+    CsrUint32 addts_tid;
+    CsrUint8 addts_ie_length;
+    CsrUint8 *addts_ie;
+    CsrUint8 *addts_params;
+    CsrWifiSmeDataBlock tspec;
+    CsrWifiSmeDataBlock tclas;
+    int rc;
+
+    addts_params = (CsrUint8*)(((unifi_cfg_command_t*)arg) + 1);
+    if (get_user(addts_tid, (CsrUint32*)addts_params)) {
+        unifi_error(priv, "unifi_cfg_wmm_addts: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    addts_params += sizeof(CsrUint32);
+    if (get_user(addts_ie_length, (CsrUint8*)addts_params)) {
+        unifi_error(priv, "unifi_cfg_wmm_addts: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG4, "addts: tid = 0x%x ie_length = %d\n",
+            addts_tid, addts_ie_length);
+
+    addts_ie = CsrPmemAlloc(addts_ie_length);
+    if (addts_ie == NULL) {
+        unifi_error(priv,
+                "unifi_cfg_wmm_addts: Failed to malloc %d bytes for addts_ie buffer\n",
+                addts_ie_length);
+        return -ENOMEM;
+    }
+
+    addts_params += sizeof(CsrUint8);
+    rc = copy_from_user(addts_ie, addts_params, addts_ie_length);
+    if (rc) {
+        unifi_error(priv, "unifi_cfg_wmm_addts: Failed to get the addts buffer\n");
+        CsrPmemFree(addts_ie);
+        return -EFAULT;
+    }
+
+    tspec.data = addts_ie;
+    tspec.length = addts_ie_length;
+    tclas.data = NULL;
+    tclas.length = 0;
+
+    rc = sme_mgt_tspec(priv, CSR_WIFI_SME_LIST_ACTION_ADD, addts_tid,
+            &tspec, &tclas);
+
+    CsrPmemFree(addts_ie);
+    return rc;
+}
+
+
+int unifi_cfg_wmm_delts(unifi_priv_t *priv, unsigned char *arg)
+{
+    CsrUint32 delts_tid;
+    CsrUint8 *delts_params;
+    CsrWifiSmeDataBlock tspec;
+    CsrWifiSmeDataBlock tclas;
+    int rc;
+
+    delts_params = (CsrUint8*)(((unifi_cfg_command_t*)arg) + 1);
+    if (get_user(delts_tid, (CsrUint32*)delts_params)) {
+        unifi_error(priv, "unifi_cfg_wmm_delts: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG4, "delts: tid = 0x%x\n", delts_tid);
+
+    tspec.data = tclas.data = NULL;
+    tspec.length = tclas.length = 0;
+
+    rc = sme_mgt_tspec(priv, CSR_WIFI_SME_LIST_ACTION_REMOVE, delts_tid,
+            &tspec, &tclas);
+
+    return rc;
+}
+
+int unifi_cfg_strict_draft_n(unifi_priv_t *priv, unsigned char *arg)
+{
+    CsrBool strict_draft_n;
+    CsrUint8 *strict_draft_n_params;
+    int rc;
+
+    CsrWifiSmeStaConfig  staConfig;
+    CsrWifiSmeDeviceConfig  deviceConfig;
+
+    strict_draft_n_params = (CsrUint8*)(((unifi_cfg_command_t*)arg) + 1);
+    if (get_user(strict_draft_n, (CsrBool*)strict_draft_n_params)) {
+        unifi_error(priv, "unifi_cfg_strict_draft_n: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG4, "strict_draft_n: = %s\n", ((strict_draft_n) ? "yes":"no"));
+
+    rc = sme_mgt_sme_config_get(priv, &staConfig, &deviceConfig);
+
+    if (rc) {
+        unifi_warning(priv, "unifi_cfg_strict_draft_n: Get unifi_SMEConfigValue failed.\n");
+        return -EFAULT;
+    }
+
+    deviceConfig.enableStrictDraftN = strict_draft_n;
+
+    rc = sme_mgt_sme_config_set(priv, &staConfig, &deviceConfig);
+    if (rc) {
+        unifi_warning(priv, "unifi_cfg_strict_draft_n: Set unifi_SMEConfigValue failed.\n");
+        rc = -EFAULT;
+    }
+
+    return rc;
+}
+
+
+int unifi_cfg_enable_okc(unifi_priv_t *priv, unsigned char *arg)
+{
+    CsrBool enable_okc;
+    CsrUint8 *enable_okc_params;
+    int rc;
+
+    CsrWifiSmeStaConfig staConfig;
+    CsrWifiSmeDeviceConfig deviceConfig;
+
+    enable_okc_params = (CsrUint8*)(((unifi_cfg_command_t*)arg) + 1);
+    if (get_user(enable_okc, (CsrBool*)enable_okc_params)) {
+        unifi_error(priv, "unifi_cfg_enable_okc: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    unifi_trace(priv, UDBG4, "enable_okc: = %s\n", ((enable_okc) ? "yes":"no"));
+
+    rc = sme_mgt_sme_config_get(priv, &staConfig, &deviceConfig);
+    if (rc) {
+        unifi_warning(priv, "unifi_cfg_enable_okc: Get unifi_SMEConfigValue failed.\n");
+        return -EFAULT;
+    }
+
+    staConfig.enableOpportunisticKeyCaching = enable_okc;
+
+    rc = sme_mgt_sme_config_set(priv, &staConfig, &deviceConfig);
+    if (rc) {
+        unifi_warning(priv, "unifi_cfg_enable_okc: Set unifi_SMEConfigValue failed.\n");
+        rc = -EFAULT;
+    }
+
+    return rc;
+}
+
+
+int unifi_cfg_get_info(unifi_priv_t *priv, unsigned char *arg)
+{
+    unifi_cfg_get_t get_cmd;
+    char inst_name[IFNAMSIZ];
+    int rc;
+
+    if (get_user(get_cmd, (unifi_cfg_get_t*)(((unifi_cfg_command_t*)arg) + 1))) {
+        unifi_error(priv, "UNIFI_CFG: Failed to get the argument\n");
+        return -EFAULT;
+    }
+
+    switch (get_cmd) {
+        case UNIFI_CFG_GET_COEX:
+            {
+                CsrWifiSmeCoexInfo coexInfo;
+                /* Get the coex info from the SME */
+                rc = sme_mgt_coex_info_get(priv, &coexInfo);
+                if (rc) {
+                    unifi_error(priv, "UNIFI_CFG: Get unifi_CoexInfoValue failed.\n");
+                    return rc;
+                }
+
+                /* Copy the info to the out buffer */
+                if (copy_to_user((void*)arg,
+                            &coexInfo,
+                            sizeof(CsrWifiSmeCoexInfo))) {
+                    unifi_error(priv, "UNIFI_CFG: Failed to copy the coex info\n");
+                    return -EFAULT;
+                }
+                break;
+            }
+        case UNIFI_CFG_GET_POWER_MODE:
+            {
+                CsrWifiSmePowerConfig powerConfig;
+                rc = sme_mgt_power_config_get(priv, &powerConfig);
+                if (rc) {
+                    unifi_error(priv, "UNIFI_CFG: Get unifi_PowerConfigValue failed.\n");
+                    return rc;
+                }
+
+                /* Copy the info to the out buffer */
+                if (copy_to_user((void*)arg,
+                            &powerConfig.powerSaveLevel,
+                            sizeof(CsrWifiSmePowerSaveLevel))) {
+                    unifi_error(priv, "UNIFI_CFG: Failed to copy the power save info\n");
+                    return -EFAULT;
+                }
+                break;
+            }
+        case UNIFI_CFG_GET_POWER_SUPPLY:
+            {
+                CsrWifiSmeHostConfig hostConfig;
+                rc = sme_mgt_host_config_get(priv, &hostConfig);
+                if (rc) {
+                    unifi_error(priv, "UNIFI_CFG: Get unifi_HostConfigValue failed.\n");
+                    return rc;
+                }
+
+                /* Copy the info to the out buffer */
+                if (copy_to_user((void*)arg,
+                            &hostConfig.powerMode,
+                            sizeof(CsrWifiSmeHostPowerMode))) {
+                    unifi_error(priv, "UNIFI_CFG: Failed to copy the host power mode\n");
+                    return -EFAULT;
+                }
+                break;
+            }
+        case UNIFI_CFG_GET_VERSIONS:
+            break;
+        case UNIFI_CFG_GET_INSTANCE:
+            {
+                CsrUint16 InterfaceId=0;
+                uf_net_get_name(priv->netdev[InterfaceId], &inst_name[0], sizeof(inst_name));
+
+                /* Copy the info to the out buffer */
+                if (copy_to_user((void*)arg,
+                            &inst_name[0],
+                            sizeof(inst_name))) {
+                    unifi_error(priv, "UNIFI_CFG: Failed to copy the instance name\n");
+                    return -EFAULT;
+                }
+            }
+            break;
+
+        case UNIFI_CFG_GET_AP_CONFIG:
+            {
+#ifdef CSR_SUPPORT_WEXT_AP
+                uf_cfg_ap_config_t cfg_ap_config;
+                cfg_ap_config.channel = priv->ap_config.channel;
+                cfg_ap_config.beaconInterval = priv->ap_mac_config.beaconInterval;
+                cfg_ap_config.wmmEnabled = priv->ap_mac_config.wmmEnabled;
+                cfg_ap_config.dtimPeriod = priv->ap_mac_config.dtimPeriod;
+                cfg_ap_config.phySupportedBitmap = priv->ap_mac_config.phySupportedBitmap;
+                if (copy_to_user((void*)arg,
+                            &cfg_ap_config,
+                            sizeof(uf_cfg_ap_config_t))) {
+                    unifi_error(priv, "UNIFI_CFG: Failed to copy the AP configuration\n");
+                    return -EFAULT;
+                }
+#else
+                   return -EPERM;
+#endif
+            }
+            break;
+
+
+        default:
+            unifi_error(priv, "unifi_cfg_get_info: Unknown value.\n");
+            return -EINVAL;
+    }
+
+    return 0;
+}
+#ifdef CSR_SUPPORT_WEXT_AP
+int
+ uf_configure_supported_rates(CsrUint8 * supportedRates, CsrUint8 phySupportedBitmap)
+{
+    int i=0;
+    CsrBool b=FALSE, g = FALSE, n = FALSE;
+    b = phySupportedBitmap & CSR_WIFI_SME_AP_PHY_SUPPORT_B;
+    n = phySupportedBitmap & CSR_WIFI_SME_AP_PHY_SUPPORT_N;
+    g = phySupportedBitmap & CSR_WIFI_SME_AP_PHY_SUPPORT_G;
+    if(b || g) {
+        supportedRates[i++]=0x82;
+        supportedRates[i++]=0x84;
+        supportedRates[i++]=0x8b;
+        supportedRates[i++]=0x96;
+    } else if(n) {
+        supportedRates[i++]=0x02;
+        supportedRates[i++]=0x04;
+        supportedRates[i++]=0x0b;
+        supportedRates[i++]=0x16;
+    }
+    if(g) {
+        if(!b) {
+            supportedRates[i++]=0x8c;
+            supportedRates[i++]=0x98;
+            supportedRates[i++]=0xb0;
+        } else {
+            supportedRates[i++]=0x0c;
+            supportedRates[i++]=0x18;
+            supportedRates[i++]=0x30;
+        }
+        supportedRates[i++]=0x48;
+        supportedRates[i++]=0x12;
+        supportedRates[i++]=0x24;
+        supportedRates[i++]=0x60;
+        supportedRates[i++]=0x6c;
+    }
+    return i;
+}
+int unifi_cfg_set_ap_config(unifi_priv_t * priv,unsigned char* arg)
+{
+    uf_cfg_ap_config_t cfg_ap_config;
+    char *buffer;
+
+    buffer = ((unsigned char*)arg) + sizeof(unifi_cfg_command_t) + sizeof(unsigned int);
+    if (copy_from_user(&cfg_ap_config, (void*)buffer,
+                sizeof(uf_cfg_ap_config_t))) {
+        unifi_error(priv, "UNIFI_CFG: Failed to get the ap config struct\n");
+        return -EFAULT;
+    }
+    priv->ap_config.channel = cfg_ap_config.channel;
+    priv->ap_mac_config.dtimPeriod = cfg_ap_config.dtimPeriod;
+    priv->ap_mac_config.beaconInterval = cfg_ap_config.beaconInterval;
+    priv->group_sec_config.apGroupkeyTimeout = cfg_ap_config.groupkeyTimeout;
+    priv->group_sec_config.apStrictGtkRekey = cfg_ap_config.strictGtkRekeyEnabled;
+    priv->group_sec_config.apGmkTimeout = cfg_ap_config.gmkTimeout;
+    priv->group_sec_config.apResponseTimeout = cfg_ap_config.responseTimeout;
+    priv->group_sec_config.apRetransLimit = cfg_ap_config.retransLimit;
+
+    priv->ap_mac_config.shortSlotTimeEnabled = cfg_ap_config.shortSlotTimeEnabled;
+    priv->ap_mac_config.ctsProtectionType=cfg_ap_config.ctsProtectionType;
+
+    priv->ap_mac_config.wmmEnabled = cfg_ap_config.wmmEnabled;
+
+    priv->ap_mac_config.apHtParams.rxStbc=cfg_ap_config.rxStbc;
+    priv->ap_mac_config.apHtParams.rifsModeAllowed=cfg_ap_config.rifsModeAllowed;
+
+    priv->ap_mac_config.phySupportedBitmap = cfg_ap_config.phySupportedBitmap;
+    priv->ap_mac_config.maxListenInterval=cfg_ap_config.maxListenInterval;
+
+    priv->ap_mac_config.supportedRatesCount=     uf_configure_supported_rates(priv->ap_mac_config.supportedRates,priv->ap_mac_config.phySupportedBitmap);
+
+    return 0;
+}
+
+#endif
+#ifdef CSR_SUPPORT_WEXT
+
+    void
+uf_sme_config_wq(struct work_struct *work)
+{
+    CsrWifiSmeStaConfig  staConfig;
+    CsrWifiSmeDeviceConfig  deviceConfig;
+    unifi_priv_t *priv = container_of(work, unifi_priv_t, sme_config_task);
+
+    /* Register to receive indications from the SME */
+    CsrWifiSmeEventMaskSetReqSend(0,
+            CSR_WIFI_SME_INDICATIONS_WIFIOFF | CSR_WIFI_SME_INDICATIONS_CONNECTIONQUALITY |
+            CSR_WIFI_SME_INDICATIONS_MEDIASTATUS | CSR_WIFI_SME_INDICATIONS_MICFAILURE);
+
+    if (sme_mgt_sme_config_get(priv, &staConfig, &deviceConfig)) {
+        unifi_warning(priv, "uf_sme_config_wq: Get unifi_SMEConfigValue failed.\n");
+        return;
+    }
+
+    if (priv->if_index == CSR_INDEX_5G) {
+        staConfig.ifIndex = CSR_WIFI_SME_RADIO_IF_GHZ_5_0;
+    } else {
+        staConfig.ifIndex = CSR_WIFI_SME_RADIO_IF_GHZ_2_4;
+    }
+
+    deviceConfig.trustLevel = (CsrWifiSme80211dTrustLevel)tl_80211d;
+    if (sme_mgt_sme_config_set(priv, &staConfig, &deviceConfig)) {
+        unifi_warning(priv,
+                "SME config for 802.11d Trust Level and Radio Band failed.\n");
+        return;
+    }
+
+} /* uf_sme_config_wq() */
+
+#endif /* CSR_SUPPORT_WEXT */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_ta_ind_wq
+ *
+ *      Deferred work queue function to send Traffic Analysis protocols
+ *      indications to the SME.
+ *      These are done in a deferred work queue for two reasons:
+ *       - the CsrWifiRouterCtrl...Send() functions are not safe for atomic context
+ *       - we want to load the main driver data path as lightly as possible
+ *
+ *      The TA classifications already come from a workqueue.
+ *
+ *  Arguments:
+ *      work    Pointer to work queue item.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+    void
+uf_ta_ind_wq(struct work_struct *work)
+{
+    struct ta_ind *ind = container_of(work, struct ta_ind, task);
+    unifi_priv_t *priv = container_of(ind, unifi_priv_t, ta_ind_work);
+    CsrUint16 interfaceTag = 0;
+
+
+    CsrWifiRouterCtrlTrafficProtocolIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,
+            interfaceTag,
+            ind->packet_type,
+            ind->direction,
+            ind->src_addr);
+    ind->in_use = 0;
+
+} /* uf_ta_ind_wq() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_ta_sample_ind_wq
+ *
+ *      Deferred work queue function to send Traffic Analysis sample
+ *      indications to the SME.
+ *      These are done in a deferred work queue for two reasons:
+ *       - the CsrWifiRouterCtrl...Send() functions are not safe for atomic context
+ *       - we want to load the main driver data path as lightly as possible
+ *
+ *      The TA classifications already come from a workqueue.
+ *
+ *  Arguments:
+ *      work    Pointer to work queue item.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+    void
+uf_ta_sample_ind_wq(struct work_struct *work)
+{
+    struct ta_sample_ind *ind = container_of(work, struct ta_sample_ind, task);
+    unifi_priv_t *priv = container_of(ind, unifi_priv_t, ta_sample_ind_work);
+    CsrUint16 interfaceTag = 0;
+
+     unifi_trace(priv, UDBG5, "rxtcp %d txtcp %d rxudp %d txudp %d prio %d\n",
+        priv->rxTcpThroughput,
+        priv->txTcpThroughput,
+        priv->rxUdpThroughput,
+        priv->txUdpThroughput,
+        priv->bh_thread.prio);
+
+    if(priv->rxTcpThroughput > 1000)
+    {
+        if (bh_priority == -1 && priv->bh_thread.prio != 1)
+        {
+            struct sched_param param;
+            priv->bh_thread.prio = 1;
+            unifi_trace(priv, UDBG1, "%s new thread (RT) priority = %d\n",
+                        priv->bh_thread.name, priv->bh_thread.prio);
+            param.sched_priority = priv->bh_thread.prio;
+            sched_setscheduler(priv->bh_thread.thread_task, SCHED_FIFO, &param);
+        }
+    } else
+    {
+        if (bh_priority == -1 && priv->bh_thread.prio != DEFAULT_PRIO)
+        {
+            struct sched_param param;
+            param.sched_priority = 0;
+            sched_setscheduler(priv->bh_thread.thread_task, SCHED_NORMAL, &param);
+            priv->bh_thread.prio = DEFAULT_PRIO;
+            unifi_trace(priv, UDBG1, "%s new thread priority = %d\n",
+                        priv->bh_thread.name, priv->bh_thread.prio);
+            set_user_nice(priv->bh_thread.thread_task, PRIO_TO_NICE(priv->bh_thread.prio));
+        }
+    }
+
+    CsrWifiRouterCtrlTrafficSampleIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0, interfaceTag, ind->stats);
+
+    ind->in_use = 0;
+
+} /* uf_ta_sample_ind_wq() */
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  uf_send_m4_ready_wq
+ *
+ *      Deferred work queue function to send M4 ReadyToSend inds to the SME.
+ *      These are done in a deferred work queue for two reasons:
+ *       - the CsrWifiRouterCtrl...Send() functions are not safe for atomic context
+ *       - we want to load the main driver data path as lightly as possible
+ *
+ *  Arguments:
+ *      work    Pointer to work queue item.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+void
+uf_send_m4_ready_wq(struct work_struct *work)
+{
+    netInterface_priv_t *InterfacePriv = container_of(work, netInterface_priv_t, send_m4_ready_task);
+    CsrUint16 iface = InterfacePriv->InterfaceTag;
+    unifi_priv_t *priv = InterfacePriv->privPtr;
+    CSR_MA_PACKET_REQUEST *req = &InterfacePriv->m4_signal.u.MaPacketRequest;
+    CsrWifiMacAddress peer;
+    unsigned long flags;
+
+    func_enter();
+
+    /* The peer address was stored in the signal */
+    spin_lock_irqsave(&priv->m4_lock, flags);
+    memcpy(peer.a, req->Ra.x, sizeof(peer.a));
+    spin_unlock_irqrestore(&priv->m4_lock, flags);
+
+    /* Send a signal to SME */
+    CsrWifiRouterCtrlM4ReadyToSendIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0, iface, peer);
+
+    UF_TRACE_MAC(priv, UDBG1, "M4ReadyToSendInd sent for peer", peer.a);
+
+    func_exit();
+
+} /* uf_send_m4_ready_wq() */
+
--- /dev/null
+++ b/drivers/staging/csr/unifi_sme.h
@@ -0,0 +1,236 @@
+/*
+ * ***************************************************************************
+ *  FILE:     unifi_sme.h
+ *
+ *  PURPOSE:    SME related definitions.
+ *
+ *  Copyright (C) 2007-2011 by Cambridge Silicon Radio Ltd.
+ *
+ *  Refer to LICENSE.txt included with this source code for details on
+ *  the license terms.
+ *
+ * ***************************************************************************
+ */
+#ifndef __LINUX_UNIFI_SME_H__
+#define __LINUX_UNIFI_SME_H__ 1
+
+#include <linux/kernel.h>
+
+#ifdef CSR_SME_USERSPACE
+#include "sme_userspace.h"
+#endif
+
+#include "csr_wifi_sme_lib.h"
+
+typedef int unifi_data_port_action;
+
+typedef struct unifi_port_cfg
+{
+    /* TRUE if this port entry is allocated */
+    CsrBool in_use;
+    CsrWifiRouterCtrlPortAction port_action;
+    CsrWifiMacAddress mac_address;
+} unifi_port_cfg_t;
+
+#define UNIFI_MAX_CONNECTIONS           8
+#define UNIFI_MAX_RETRY_LIMIT           5
+#define UF_DATA_PORT_NOT_OVERIDE        0
+#define UF_DATA_PORT_OVERIDE            1
+
+typedef struct unifi_port_config
+{
+    int entries_in_use;
+    int overide_action;
+    unifi_port_cfg_t port_cfg[UNIFI_MAX_CONNECTIONS];
+} unifi_port_config_t;
+
+
+enum sme_request_status {
+    SME_REQUEST_EMPTY,
+    SME_REQUEST_PENDING,
+    SME_REQUEST_RECEIVED,
+    SME_REQUEST_TIMEDOUT,
+};
+
+/* Structure to hold a UDI logged signal */
+typedef struct {
+
+    /* The current status of the request */
+    enum sme_request_status request_status;
+
+    /* The status the SME has passed to us */
+    CsrResult reply_status;
+
+    /* SME's reply to a get request */
+    CsrWifiSmeVersions versions;
+    CsrWifiSmePowerConfig powerConfig;
+    CsrWifiSmeHostConfig hostConfig;
+    CsrWifiSmeStaConfig staConfig;
+    CsrWifiSmeDeviceConfig deviceConfig;
+    CsrWifiSmeCoexInfo coexInfo;
+    CsrWifiSmeCoexConfig coexConfig;
+    CsrWifiSmeMibConfig mibConfig;
+    CsrWifiSmeConnectionInfo connectionInfo;
+    CsrWifiSmeConnectionConfig connectionConfig;
+    CsrWifiSmeConnectionStats connectionStats;
+
+
+    /* SME's reply to a scan request */
+    CsrUint16 reply_scan_results_count;
+    CsrWifiSmeScanResult* reply_scan_results;
+
+} sme_reply_t;
+
+
+typedef struct {
+    CsrUint16 appHandle;
+    CsrWifiRouterEncapsulation encapsulation;
+    CsrUint16 protocol;
+    CsrUint8 oui[3];
+    CsrUint8 in_use;
+} sme_ma_unidata_ind_filter_t;
+
+
+CsrWifiRouterCtrlPortAction uf_sme_port_state(unifi_priv_t *priv,
+                                          unsigned char *address,
+                                          int queue,
+                                          CsrUint16 interfaceTag);
+unifi_port_cfg_t *uf_sme_port_config_handle(unifi_priv_t *priv,
+                                            unsigned char *address,
+                                            int queue,
+                                            CsrUint16 interfaceTag);
+
+
+
+/* Callback for event logging to SME clients */
+void sme_log_event(ul_client_t *client, const u8 *signal, int signal_len,
+                   const bulk_data_param_t *bulkdata, int dir);
+
+/* The workqueue task to the set the multicast addresses list */
+void uf_multicast_list_wq(struct work_struct *work);
+
+/* The workqueue task to execute the TA module */
+void uf_ta_wq(struct work_struct *work);
+
+
+/*
+ * SME blocking helper functions
+ */
+#ifdef UNIFI_DEBUG
+# define sme_complete_request(priv, status)   uf_sme_complete_request(priv, status, __func__)
+#else
+# define sme_complete_request(priv, status)   uf_sme_complete_request(priv, status, NULL)
+#endif
+
+void uf_sme_complete_request(unifi_priv_t *priv, CsrResult reply_status, const char *func);
+
+
+/*
+ * Blocking functions using the SME SYS API.
+ */
+int sme_sys_suspend(unifi_priv_t *priv);
+int sme_sys_resume(unifi_priv_t *priv);
+
+
+/*
+ * Traffic Analysis workqueue jobs
+ */
+void uf_ta_ind_wq(struct work_struct *work);
+void uf_ta_sample_ind_wq(struct work_struct *work);
+
+/*
+ * SME config workqueue job
+ */
+void uf_sme_config_wq(struct work_struct *work);
+
+/*
+ * To send M4 read to send IND
+ */
+void uf_send_m4_ready_wq(struct work_struct *work);
+
+int sme_mgt_power_config_set(unifi_priv_t *priv, CsrWifiSmePowerConfig *powerConfig);
+int sme_mgt_power_config_get(unifi_priv_t *priv, CsrWifiSmePowerConfig *powerConfig);
+int sme_mgt_host_config_set(unifi_priv_t *priv, CsrWifiSmeHostConfig *hostConfig);
+int sme_mgt_host_config_get(unifi_priv_t *priv, CsrWifiSmeHostConfig *hostConfig);
+int sme_mgt_sme_config_set(unifi_priv_t *priv, CsrWifiSmeStaConfig *staConfig, CsrWifiSmeDeviceConfig *deviceConfig);
+int sme_mgt_sme_config_get(unifi_priv_t *priv, CsrWifiSmeStaConfig *staConfig, CsrWifiSmeDeviceConfig *deviceConfig);
+int sme_mgt_coex_info_get(unifi_priv_t *priv, CsrWifiSmeCoexInfo *coexInfo);
+int sme_mgt_packet_filter_set(unifi_priv_t *priv);
+int sme_mgt_tspec(unifi_priv_t *priv, CsrWifiSmeListAction action,
+                  CsrUint32 tid, CsrWifiSmeDataBlock *tspec, CsrWifiSmeDataBlock *tclas);
+
+#ifdef CSR_SUPPORT_WEXT
+/*
+ * Blocking functions using the SME MGT API.
+ */
+int sme_mgt_wifi_on(unifi_priv_t *priv);
+int sme_mgt_wifi_off(unifi_priv_t *priv);
+/*int sme_mgt_set_value_async(unifi_priv_t *priv, unifi_AppValue *app_value);
+int sme_mgt_get_value_async(unifi_priv_t *priv, unifi_AppValue *app_value);
+int sme_mgt_get_value(unifi_priv_t *priv, unifi_AppValue *app_value);
+int sme_mgt_set_value(unifi_priv_t *priv, unifi_AppValue *app_value);
+*/
+int sme_mgt_coex_config_set(unifi_priv_t *priv, CsrWifiSmeCoexConfig *coexConfig);
+int sme_mgt_coex_config_get(unifi_priv_t *priv, CsrWifiSmeCoexConfig *coexConfig);
+int sme_mgt_mib_config_set(unifi_priv_t *priv, CsrWifiSmeMibConfig *mibConfig);
+int sme_mgt_mib_config_get(unifi_priv_t *priv, CsrWifiSmeMibConfig *mibConfig);
+
+int sme_mgt_connection_info_set(unifi_priv_t *priv, CsrWifiSmeConnectionInfo *connectionInfo);
+int sme_mgt_connection_info_get(unifi_priv_t *priv, CsrWifiSmeConnectionInfo *connectionInfo);
+int sme_mgt_connection_config_set(unifi_priv_t *priv, CsrWifiSmeConnectionConfig *connectionConfig);
+int sme_mgt_connection_config_get(unifi_priv_t *priv, CsrWifiSmeConnectionConfig *connectionConfig);
+int sme_mgt_connection_stats_get(unifi_priv_t *priv, CsrWifiSmeConnectionStats *connectionStats);
+
+int sme_mgt_versions_get(unifi_priv_t *priv, CsrWifiSmeVersions *versions);
+
+
+int sme_mgt_scan_full(unifi_priv_t *priv, CsrWifiSsid *specific_ssid,
+                      int num_channels, unsigned char *channel_list);
+int sme_mgt_scan_results_get_async(unifi_priv_t *priv,
+                                   struct iw_request_info *info,
+                                   char *scan_results,
+                                   long scan_results_len);
+int sme_mgt_disconnect(unifi_priv_t *priv);
+int sme_mgt_connect(unifi_priv_t *priv);
+int sme_mgt_key(unifi_priv_t *priv, CsrWifiSmeKey *sme_key,
+                CsrWifiSmeListAction action);
+int sme_mgt_pmkid(unifi_priv_t *priv, CsrWifiSmeListAction action,
+                  CsrWifiSmePmkidList *pmkid_list);
+int sme_mgt_mib_get(unifi_priv_t *priv,
+                    unsigned char *varbind, int *length);
+int sme_mgt_mib_set(unifi_priv_t *priv,
+                    unsigned char *varbind, int length);
+#ifdef CSR_SUPPORT_WEXT_AP
+int sme_ap_start(unifi_priv_t *priv,CsrUint16 interface_tag,CsrWifiSmeApConfig_t *ap_config);
+int sme_ap_stop(unifi_priv_t *priv,CsrUint16 interface_tag);
+int sme_ap_config(unifi_priv_t *priv,CsrWifiSmeApMacConfig *ap_mac_config, CsrWifiNmeApConfig *group_security_config);
+int uf_configure_supported_rates(CsrUint8 * supportedRates, CsrUint8 phySupportedBitmap);
+#endif
+int unifi_translate_scan(struct net_device *dev,
+                         struct iw_request_info *info,
+                         char *current_ev, char *end_buf,
+                         CsrWifiSmeScanResult *scan_data,
+                         int scan_index);
+
+#endif /* CSR_SUPPORT_WEXT */
+
+int unifi_cfg_power(unifi_priv_t *priv, unsigned char *arg);
+int unifi_cfg_power_save(unifi_priv_t *priv, unsigned char *arg);
+int unifi_cfg_power_supply(unifi_priv_t *priv, unsigned char *arg);
+int unifi_cfg_packet_filters(unifi_priv_t *priv, unsigned char *arg);
+int unifi_cfg_wmm_qos_info(unifi_priv_t *priv, unsigned char *arg);
+int unifi_cfg_wmm_addts(unifi_priv_t *priv, unsigned char *arg);
+int unifi_cfg_wmm_delts(unifi_priv_t *priv, unsigned char *arg);
+int unifi_cfg_get_info(unifi_priv_t *priv, unsigned char *arg);
+int unifi_cfg_strict_draft_n(unifi_priv_t *priv, unsigned char *arg);
+int unifi_cfg_enable_okc(unifi_priv_t *priv, unsigned char *arg);
+#ifdef CSR_SUPPORT_WEXT_AP
+int unifi_cfg_set_ap_config(unifi_priv_t * priv,unsigned char* arg);
+#endif
+
+
+
+int convert_sme_error(CsrResult error);
+
+
+#endif /* __LINUX_UNIFI_SME_H__ */
--- /dev/null
+++ b/drivers/staging/csr/unifi_wext.h
@@ -0,0 +1,124 @@
+/*
+ *****************************************************************************
+ *
+ * FILE : unifi_wext.h
+ *
+ * PURPOSE : Private header file for unifi driver support to wireless extensions.
+ *
+ * Copyright (C) 2005-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+*****************************************************************************
+ */
+#ifndef __LINUX_UNIFI_WEXT_H__
+#define __LINUX_UNIFI_WEXT_H__ 1
+
+#include <linux/kernel.h>
+#include <net/iw_handler.h>
+#include "csr_wifi_sme_prim.h"
+
+/*
+ *      wext.c
+ */
+/* A few details needed for WEP (Wireless Equivalent Privacy) */
+#define UNIFI_MAX_KEY_SIZE      16
+#define NUM_WEPKEYS              4
+#define SMALL_KEY_SIZE           5
+#define LARGE_KEY_SIZE          13
+typedef struct wep_key_t {
+    int len;
+    unsigned char key[UNIFI_MAX_KEY_SIZE];  /* 40-bit and 104-bit keys */
+} wep_key_t;
+
+#define UNIFI_SCAN_ACTIVE       0
+#define UNIFI_SCAN_PASSIVE      1
+#define UNIFI_MAX_SSID_LEN      32
+
+#define MAX_WPA_IE_LEN 64
+#define MAX_RSN_IE_LEN 255
+
+/*
+ * Function to register in the netdev to report wireless stats.
+ */
+struct iw_statistics *unifi_get_wireless_stats(struct net_device *dev);
+
+void uf_sme_wext_set_defaults(unifi_priv_t *priv);
+
+
+/*
+ *      wext_events.c
+ */
+/* Functions to generate Wireless Extension events */
+void wext_send_scan_results_event(unifi_priv_t *priv);
+void wext_send_assoc_event(unifi_priv_t *priv, unsigned char *bssid,
+                           unsigned char *req_ie, int req_ie_len,
+                           unsigned char *resp_ie, int resp_ie_len,
+                           unsigned char *scan_ie, unsigned int scan_ie_len);
+void wext_send_disassoc_event(unifi_priv_t *priv);
+void wext_send_michaelmicfailure_event(unifi_priv_t *priv,
+                                       CsrUint16 count, CsrWifiMacAddress address,
+                                       CsrWifiSmeKeyType keyType, CsrUint16 interfaceTag);
+void wext_send_pmkid_candidate_event(unifi_priv_t *priv, CsrWifiMacAddress bssid, CsrBool preauth_allowed, CsrUint16 interfaceTag);
+void wext_send_started_event(unifi_priv_t *priv);
+
+
+static inline int
+uf_iwe_stream_add_point(struct iw_request_info *info, char *start, char *stop,
+                        struct iw_event *piwe, char *extra)
+{
+    char *new_start;
+
+    new_start = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27) || defined (IW_REQUEST_FLAG_COMPAT)
+                                     info,
+#endif
+                                     start, stop, piwe, extra);
+    if (unlikely(new_start == start))
+    {
+        return -E2BIG;
+    }
+
+    return (new_start - start);
+}
+
+
+static inline int
+uf_iwe_stream_add_event(struct iw_request_info *info, char *start, char *stop,
+                        struct iw_event *piwe, int len)
+{
+    char *new_start;
+
+    new_start = iwe_stream_add_event(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27) || defined(IW_REQUEST_FLAG_COMPAT)
+                                     info,
+#endif
+                                     start, stop, piwe, len);
+    if (unlikely(new_start == start)) {
+        return -E2BIG;
+    }
+
+    return (new_start - start);
+}
+
+static inline int
+uf_iwe_stream_add_value(struct iw_request_info *info, char *stream, char *start,
+                        char *stop, struct iw_event *piwe, int len)
+{
+    char *new_start;
+
+    new_start = iwe_stream_add_value(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27) || defined(IW_REQUEST_FLAG_COMPAT)
+                                     info,
+#endif
+                                     stream, start, stop, piwe, len);
+    if (unlikely(new_start == start)) {
+        return -E2BIG;
+    }
+
+    return (new_start - start);
+}
+
+
+#endif /* __LINUX_UNIFI_WEXT_H__ */
--- /dev/null
+++ b/drivers/staging/csr/unifiio.h
@@ -0,0 +1,400 @@
+/*
+ * ---------------------------------------------------------------------------
+ *
+ *  FILE: unifiio.h
+ *
+ *      Public definitions for the UniFi linux driver.
+ *      This is mostly ioctl command values and structs.
+ *
+ *      Include <sys/ioctl.h> or similar before this file
+ *
+ * Copyright (C) 2005-2009 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#ifndef __UNIFIIO_H__
+#define __UNIFIIO_H__
+
+#include <linux/types.h>
+#include "csr_types.h"
+
+#define UNIFI_GET_UDI_ENABLE    _IOR('u',  1, int)
+#define UNIFI_SET_UDI_ENABLE    _IOW('u',  2, int)
+/* Values for UDI_ENABLE */
+#define UDI_ENABLE_DATA         0x1
+#define UDI_ENABLE_CONTROL      0x2
+
+/* MIB set/get. Arg is a pointer to a varbind */
+#define UNIFI_GET_MIB           _IOWR('u',  3, unsigned char *)
+#define UNIFI_SET_MIB           _IOW ('u',  4, unsigned char *)
+#define MAX_VARBIND_LENGTH 127
+
+/* Private IOCTLs */
+#define SIOCIWS80211POWERSAVEPRIV           SIOCIWFIRSTPRIV
+#define SIOCIWG80211POWERSAVEPRIV           SIOCIWFIRSTPRIV + 1
+#define SIOCIWS80211RELOADDEFAULTSPRIV      SIOCIWFIRSTPRIV + 2
+#define SIOCIWSCONFWAPIPRIV                 SIOCIWFIRSTPRIV + 4
+#define SIOCIWSWAPIKEYPRIV                  SIOCIWFIRSTPRIV + 6
+#define SIOCIWSSMEDEBUGPRIV                 SIOCIWFIRSTPRIV + 8
+#define SIOCIWSAPCFGPRIV                    SIOCIWFIRSTPRIV + 10
+#define SIOCIWSAPSTARTPRIV                  SIOCIWFIRSTPRIV + 12
+#define SIOCIWSAPSTOPPRIV                   SIOCIWFIRSTPRIV + 14
+#define SIOCIWSFWRELOADPRIV                 SIOCIWFIRSTPRIV + 16
+#define SIOCIWSSTACKSTART                   SIOCIWFIRSTPRIV + 18
+#define SIOCIWSSTACKSTOP                    SIOCIWFIRSTPRIV + 20
+
+
+
+#define IWPRIV_POWER_SAVE_MAX_STRING 32
+#define IWPRIV_SME_DEBUG_MAX_STRING 32
+#define IWPRIV_SME_MAX_STRING 120
+
+
+/* Private configuration commands */
+#define UNIFI_CFG               _IOWR('u',  5, unsigned char *)
+/*
+ * <------------------  Read/Write Buffer  -------------------->
+ * _____________________________________________________________
+ * |    Cmd    |    Arg    |   ...  Buffer (opt)  ...          |
+ * -------------------------------------------------------------
+ * <-- uint --><-- uint --><-----  unsigned char buffer  ------>
+ *
+ * Cmd:    A unifi_cfg_command_t command.
+ * Arg:    Out:Length     if Cmd==UNIFI_CFG_GET
+ *         In:PowerOnOff  if Cmd==UNIFI_CFG_POWER
+ *         In:PowerMode   if Cmd==UNIFI_CFG_POWERSAVE
+ *         In:Length      if Cmd==UNIFI_CFG_FILTER
+ *         In:WMM Qos Info if Cmd==UNIFI_CFG_WMM_QOS_INFO
+ * Buffer: Out:Data       if Cmd==UNIFI_CFG_GET
+ *         NULL           if Cmd==UNIFI_CFG_POWER
+ *         NULL           if Cmd==UNIFI_CFG_POWERSAVE
+ *         In:Filters     if Cmd==UNIFI_CFG_FILTER
+ *
+ * where Filters is a uf_cfg_bcast_packet_filter_t structure
+ * followed by 0 - n tclas_t structures. The length of the tclas_t
+ * structures is obtained by uf_cfg_bcast_packet_filter_t::tclas_ies_length.
+ */
+
+
+#define UNIFI_PUTEST            _IOWR('u',  6, unsigned char *)
+/*
+ * <------------------  Read/Write Buffer  -------------------->
+ * _____________________________________________________________
+ * |    Cmd    |    Arg    |   ...  Buffer (opt)  ...          |
+ * -------------------------------------------------------------
+ * <-- uint --><-- uint --><-----  unsigned char buffer  ------>
+ *
+ * Cmd:    A unifi_putest_command_t command.
+ * Arg:    N/A                           if Cmd==UNIFI_PUTEST_START
+ *         N/A                           if Cmd==UNIFI_PUTEST_STOP
+ *         In:int (Clock Speed)          if Cmd==UNIFI_PUTEST_SET_SDIO_CLOCK
+ *         In/Out:sizeof(unifi_putest_cmd52) if Cmd==UNIFI_PUTEST_CMD52_READ
+ *         In:sizeof(unifi_putest_cmd52) if Cmd==UNIFI_PUTEST_CMD52_WRITE
+ *         In:uint (f/w file name length) if Cmd==UNIFI_PUTEST_DL_FW
+ * Buffer: NULL                          if Cmd==UNIFI_PUTEST_START
+ *         NULL                          if Cmd==UNIFI_PUTEST_STOP
+ *         NULL                          if Cmd==UNIFI_PUTEST_SET_SDIO_CLOCK
+ *         In/Out:unifi_putest_cmd52     if Cmd==UNIFI_PUTEST_CMD52_READ
+ *         In:unifi_putest_cmd52         if Cmd==UNIFI_PUTEST_CMD52_WRITE
+ *         In:f/w file name              if Cmd==UNIFI_PUTEST_DL_FW
+ */
+
+#define UNIFI_BUILD_TYPE _IOWR('u', 7, unsigned char)
+#define UNIFI_BUILD_NME 1
+#define UNIFI_BUILD_WEXT 2
+#define UNIFI_BUILD_AP 3
+
+/* debugging */
+#define UNIFI_KICK              _IO ('u',  0x10)
+#define UNIFI_SET_DEBUG         _IO ('u',  0x11)
+#define UNIFI_SET_TRACE         _IO ('u',  0x12)
+
+#define UNIFI_GET_INIT_STATUS   _IOR ('u', 0x15, int)
+#define UNIFI_SET_UDI_LOG_MASK  _IOR('u',  0x18, unifiio_filter_t)
+#define UNIFI_SET_UDI_SNAP_MASK _IOW('u',  0x1a, unifiio_snap_filter_t)
+#define UNIFI_SET_AMP_ENABLE    _IOWR('u',  0x1b, int)
+
+#define UNIFI_INIT_HW           _IOR ('u', 0x13, unsigned char)
+#define UNIFI_INIT_NETDEV       _IOW ('u', 0x14, unsigned char[6])
+#define UNIFI_SME_PRESENT       _IOW ('u', 0x19, int)
+
+#define UNIFI_CFG_PERIOD_TRAFFIC _IOW ('u', 0x21, unsigned char *)
+#define UNIFI_CFG_UAPSD_TRAFFIC _IOW ('u', 0x22, unsigned char)
+
+#define UNIFI_COREDUMP_GET_REG  _IOWR('u', 0x23, unifiio_coredump_req_t)
+
+
+/*
+ * Following reset, f/w may only be downloaded using CMD52.
+ * This is slow, so there is a facility to download a secondary
+ * loader first which supports CMD53.
+ * If loader_len is > 0, then loader_data is assumed to point to
+ * a suitable secondary loader that can be used to download the
+ * main image.
+ *
+ * The driver will run the host protocol initialisation sequence
+ * after downloading the image.
+ *
+ * If both lengths are zero, then the f/w is assumed to have been
+ * booted from Flash and the host protocol initialisation sequence
+ * is run.
+ */
+typedef struct {
+
+    /* Number of bytes in the image */
+    int img_len;
+
+    /* Pointer to image data. */
+    unsigned char *img_data;
+
+
+    /* Number of bytes in the loader image */
+    int loader_len;
+
+    /* Pointer to loader image data. */
+    unsigned char *loader_data;
+
+} unifiio_img_t;
+
+
+/* Structure of data read from the unifi device. */
+typedef struct
+{
+    /* Length (in bytes) of entire structure including appended bulk data */
+    int length;
+
+    /* System time (in milliseconds) that signal was transferred */
+    int timestamp;
+
+    /* Direction in which signal was transferred. */
+    int direction;
+#define UDI_FROM_HOST   0
+#define UDI_TO_HOST     1
+#define UDI_CONFIG_IND  2
+
+    /* The length of the signal (in bytes) not including bulk data */
+    int signal_length;
+
+    /* Signal body follows, then any bulk data */
+
+} udi_msg_t;
+
+
+typedef enum
+{
+    UfSigFil_AllOn = 0,         /* Log all signal IDs */
+    UfSigFil_AllOff = 1,        /* Don't log any signal IDs */
+    UfSigFil_SelectOn = 2,      /* Log these signal IDs */
+    UfSigFil_SelectOff = 3      /* Don't log these signal IDs */
+} uf_sigfilter_action_t;
+
+typedef struct {
+
+    /* Number of 16-bit ints in the sig_ids array */
+    int num_sig_ids;
+    /* The action to perform */
+    uf_sigfilter_action_t action;
+    /* List of signal IDs to pass or block */
+    unsigned short *sig_ids;
+
+} unifiio_filter_t;
+
+
+typedef struct {
+    /* Number of 16-bit ints in the protocols array */
+    CsrUint16 count;
+    /* List of protocol ids to pass */
+    CsrUint16 *protocols;
+} unifiio_snap_filter_t;
+
+
+
+typedef enum unifi_putest_command {
+    UNIFI_PUTEST_START,
+    UNIFI_PUTEST_STOP,
+    UNIFI_PUTEST_SET_SDIO_CLOCK,
+    UNIFI_PUTEST_CMD52_READ,
+    UNIFI_PUTEST_CMD52_WRITE,
+    UNIFI_PUTEST_DL_FW,
+    UNIFI_PUTEST_DL_FW_BUFF,
+    UNIFI_PUTEST_CMD52_BLOCK_READ,
+    UNIFI_PUTEST_COREDUMP_PREPARE,
+    UNIFI_PUTEST_GP_READ16,
+    UNIFI_PUTEST_GP_WRITE16
+
+} unifi_putest_command_t;
+
+
+struct unifi_putest_cmd52 {
+    int funcnum;
+    unsigned long addr;
+    unsigned char data;
+};
+
+
+struct unifi_putest_block_cmd52_r {
+    int           funcnum;
+    unsigned long addr;
+    unsigned int  length;
+    unsigned char *data;
+};
+
+struct unifi_putest_gp_rw16 {
+    unsigned long addr;        /* generic address */
+    unsigned short data;
+};
+
+typedef enum unifi_cfg_command {
+    UNIFI_CFG_GET,
+    UNIFI_CFG_POWER,
+    UNIFI_CFG_POWERSAVE,
+    UNIFI_CFG_FILTER,
+    UNIFI_CFG_POWERSUPPLY,
+    UNIFI_CFG_WMM_QOSINFO,
+    UNIFI_CFG_WMM_ADDTS,
+    UNIFI_CFG_WMM_DELTS,
+    UNIFI_CFG_STRICT_DRAFT_N,
+    UNIFI_CFG_ENABLE_OKC,
+    UNIFI_CFG_SET_AP_CONFIG,
+    UNIFI_CFG_CORE_DUMP /* request to take a fw core dump */
+} unifi_cfg_command_t;
+
+typedef enum unifi_cfg_power {
+    UNIFI_CFG_POWER_UNSPECIFIED,
+    UNIFI_CFG_POWER_OFF,
+    UNIFI_CFG_POWER_ON
+} unifi_cfg_power_t;
+
+typedef enum unifi_cfg_powersupply {
+    UNIFI_CFG_POWERSUPPLY_UNSPECIFIED,
+    UNIFI_CFG_POWERSUPPLY_MAINS,
+    UNIFI_CFG_POWERSUPPLY_BATTERIES
+} unifi_cfg_powersupply_t;
+
+typedef enum unifi_cfg_powersave {
+    UNIFI_CFG_POWERSAVE_UNSPECIFIED,
+    UNIFI_CFG_POWERSAVE_NONE,
+    UNIFI_CFG_POWERSAVE_FAST,
+    UNIFI_CFG_POWERSAVE_FULL,
+    UNIFI_CFG_POWERSAVE_AUTO
+} unifi_cfg_powersave_t;
+
+typedef enum unifi_cfg_get {
+    UNIFI_CFG_GET_COEX,
+    UNIFI_CFG_GET_POWER_MODE,
+    UNIFI_CFG_GET_VERSIONS,
+    UNIFI_CFG_GET_POWER_SUPPLY,
+    UNIFI_CFG_GET_INSTANCE,
+    UNIFI_CFG_GET_AP_CONFIG
+} unifi_cfg_get_t;
+
+#define UNIFI_CFG_FILTER_NONE            0x0000
+#define UNIFI_CFG_FILTER_DHCP            0x0001
+#define UNIFI_CFG_FILTER_ARP             0x0002
+#define UNIFI_CFG_FILTER_NBNS            0x0004
+#define UNIFI_CFG_FILTER_NBDS            0x0008
+#define UNIFI_CFG_FILTER_CUPS            0x0010
+#define UNIFI_CFG_FILTER_ALL             0xFFFF
+
+
+typedef struct uf_cfg_bcast_packet_filter
+{
+    unsigned long filter_mode;     //as defined by HIP protocol
+    unsigned char arp_filter;
+    unsigned char dhcp_filter;
+    unsigned long tclas_ies_length; // length of tclas_ies in bytes
+    unsigned char tclas_ies[1];    // variable length depending on above field
+} uf_cfg_bcast_packet_filter_t;
+
+typedef struct uf_cfg_ap_config
+{
+    CsrUint8    phySupportedBitmap;
+    CsrUint8    channel;
+    CsrUint16   beaconInterval;
+    CsrUint8    dtimPeriod;
+    CsrBool     wmmEnabled;
+    CsrUint8    shortSlotTimeEnabled;
+    CsrUint16   groupkeyTimeout;
+    CsrBool     strictGtkRekeyEnabled;
+    CsrUint16   gmkTimeout;
+    CsrUint16   responseTimeout;
+    CsrUint8    retransLimit;
+    CsrUint8    rxStbc;
+    CsrBool     rifsModeAllowed;
+    CsrUint8    dualCtsProtection;
+    CsrUint8    ctsProtectionType;
+    CsrUint16   maxListenInterval;
+}uf_cfg_ap_config_t;
+
+typedef struct tcpic_clsfr
+{
+    __u8 cls_fr_type;
+    __u8 cls_fr_mask;
+    __u8 version;
+    __u8 source_ip_addr[4];
+    __u8 dest_ip_addr[4];
+    __u16 source_port;
+    __u16 dest_port;
+    __u8 dscp;
+    __u8 protocol;
+    __u8 reserved;
+} __attribute__ ((packed)) tcpip_clsfr_t;
+
+typedef struct tclas {
+    __u8 element_id;
+    __u8 length;
+    __u8 user_priority;
+    tcpip_clsfr_t tcp_ip_cls_fr;
+} __attribute__ ((packed)) tclas_t;
+
+
+#define CONFIG_IND_ERROR            0x01
+#define CONFIG_IND_EXIT             0x02
+#define CONFIG_SME_NOT_PRESENT      0x10
+#define CONFIG_SME_PRESENT          0x20
+
+/* WAPI Key */
+typedef struct
+{
+    CsrUint8                          unicastKey;
+    /* If non zero, then unicast key otherwise group key */
+    CsrUint8                          keyIndex;
+    CsrUint8                          keyRsc[16];
+    CsrUint8                          authenticator;
+    /* If non zero, then authenticator otherwise supplicant */
+    CsrUint8                          address[6];
+    CsrUint8                          key[32];
+} unifiio_wapi_key_t;
+
+/* Values describing XAP memory regions captured by the mini-coredump system */
+typedef enum unifiio_coredump_space {
+    UNIFIIO_COREDUMP_MAC_REG,
+    UNIFIIO_COREDUMP_PHY_REG,
+    UNIFIIO_COREDUMP_SH_DMEM,
+    UNIFIIO_COREDUMP_MAC_DMEM,
+    UNIFIIO_COREDUMP_PHY_DMEM,
+    UNIFIIO_COREDUMP_TRIGGER_MAGIC = 0xFEED
+} unifiio_coredump_space_t;
+
+/* Userspace tool uses this structure to retrieve a register value from a
+ * mini-coredump buffer previously saved by the HIP
+ */
+typedef struct unifiio_coredump_req {
+    /* From user */
+    int index;                      /* 0=newest, -1=oldest */
+    unsigned int offset;            /* register offset in space */
+    unifiio_coredump_space_t space; /* memory space */
+    /* Filled by driver */
+    unsigned int drv_build;         /* driver build id */
+    unsigned int chip_ver;          /* chip version */
+    unsigned int fw_ver;            /* firmware version */
+    int requestor;                  /* requestor: 0=auto dump, 1=manual */
+    unsigned int timestamp;         /* time of capture by driver */
+    unsigned int serial;            /* capture serial number */
+    int value;                      /* 16 bit register value, -ve for error */
+} unifiio_coredump_req_t;           /* Core-dumped register value request */
+
+#endif /* __UNIFIIO_H__ */
--- /dev/null
+++ b/drivers/staging/csr/wext_events.c
@@ -0,0 +1,285 @@
+/*
+ * ---------------------------------------------------------------------------
+ * FILE:     wext_events.c
+ *
+ * PURPOSE:
+ *      Code to generate iwevents.
+ *
+ * Copyright (C) 2006-2008 by Cambridge Silicon Radio Ltd.
+ *
+ * Refer to LICENSE.txt included with this source code for details on
+ * the license terms.
+ *
+ * ---------------------------------------------------------------------------
+ */
+#include <linux/types.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include "csr_wifi_hip_unifi.h"
+#include "unifi_priv.h"
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  wext_send_assoc_event
+ *
+ *      Send wireless-extension events up to userland to announce
+ *      successful association with an AP.
+ *
+ *  Arguments:
+ *      priv                    Pointer to driver context.
+ *      bssid                   MAC address of AP we associated with
+ *      req_ie, req_ie_len      IEs in the original request
+ *      resp_ie, resp_ie_len    IEs in the response
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *      This is sent on first successful association, and again if we
+ *      roam to another AP.
+ * ---------------------------------------------------------------------------
+ */
+void
+wext_send_assoc_event(unifi_priv_t *priv, unsigned char *bssid,
+                      unsigned char *req_ie, int req_ie_len,
+                      unsigned char *resp_ie, int resp_ie_len,
+                      unsigned char *scan_ie, unsigned int scan_ie_len)
+{
+#if WIRELESS_EXT > 17
+    union iwreq_data wrqu;
+
+    if (req_ie_len == 0) req_ie = NULL;
+    wrqu.data.length = req_ie_len;
+    wrqu.data.flags = 0;
+    wireless_send_event(priv->netdev[CSR_WIFI_INTERFACE_IN_USE], IWEVASSOCREQIE, &wrqu, req_ie);
+
+    if (resp_ie_len == 0) resp_ie = NULL;
+    wrqu.data.length = resp_ie_len;
+    wrqu.data.flags = 0;
+    wireless_send_event(priv->netdev[CSR_WIFI_INTERFACE_IN_USE], IWEVASSOCRESPIE, &wrqu, resp_ie);
+
+    if (scan_ie_len > 0) {
+        wrqu.data.length = scan_ie_len;
+        wrqu.data.flags = 0;
+        wireless_send_event(priv->netdev[CSR_WIFI_INTERFACE_IN_USE], IWEVGENIE, &wrqu, scan_ie);
+    }
+
+    memcpy(&wrqu.ap_addr.sa_data, bssid, ETH_ALEN);
+    wireless_send_event(priv->netdev[CSR_WIFI_INTERFACE_IN_USE], SIOCGIWAP, &wrqu, NULL);
+#endif
+} /* wext_send_assoc_event() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  wext_send_disassoc_event
+ *
+ *      Send a wireless-extension event up to userland to announce
+ *      that we disassociated from an AP.
+ *
+ *  Arguments:
+ *      priv                    Pointer to driver context.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *      The semantics of wpa_supplicant (the userland SME application) are
+ *      that a SIOCGIWAP event with MAC address of all zero means
+ *      disassociate.
+ * ---------------------------------------------------------------------------
+ */
+void
+wext_send_disassoc_event(unifi_priv_t *priv)
+{
+#if WIRELESS_EXT > 17
+    union iwreq_data wrqu;
+
+    memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+    wireless_send_event(priv->netdev[CSR_WIFI_INTERFACE_IN_USE], SIOCGIWAP, &wrqu, NULL);
+#endif
+} /* wext_send_disassoc_event() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  wext_send_scan_results_event
+ *
+ *      Send wireless-extension events up to userland to announce
+ *      completion of a scan.
+ *
+ *  Arguments:
+ *      priv                    Pointer to driver context.
+ *
+ *  Returns:
+ *      None.
+ *
+ *  Notes:
+ *      This doesn't actually report the results, they are retrieved
+ *      using the SIOCGIWSCAN ioctl command.
+ * ---------------------------------------------------------------------------
+ */
+void
+wext_send_scan_results_event(unifi_priv_t *priv)
+{
+#if WIRELESS_EXT > 17
+    union iwreq_data wrqu;
+
+    wrqu.data.length = 0;
+    wrqu.data.flags = 0;
+    wireless_send_event(priv->netdev[CSR_WIFI_INTERFACE_IN_USE], SIOCGIWSCAN, &wrqu, NULL);
+
+#endif
+} /* wext_send_scan_results_event() */
+
+
+
+/*
+ * ---------------------------------------------------------------------------
+ *  wext_send_michaelmicfailure_event
+ *
+ *      Send wireless-extension events up to userland to announce
+ *      completion of a scan.
+ *
+ *  Arguments:
+ *      priv            Pointer to driver context.
+ *      count, macaddr, key_type, key_idx, tsc
+ *                      Parameters from report from UniFi.
+ *
+ *  Returns:
+ *      None.
+ * ---------------------------------------------------------------------------
+ */
+#if WIRELESS_EXT >= 18
+static inline void
+_send_michaelmicfailure_event(struct net_device *dev,
+                              int count, const unsigned char *macaddr,
+                              int key_type, int key_idx,
+                              unsigned char *tsc)
+{
+    union iwreq_data wrqu;
+    struct iw_michaelmicfailure mmf;
+
+    memset(&mmf, 0, sizeof(mmf));
+
+    mmf.flags = key_idx & IW_MICFAILURE_KEY_ID;
+    if (key_type == CSR_GROUP) {
+        mmf.flags |= IW_MICFAILURE_GROUP;
+    } else {
+        mmf.flags |= IW_MICFAILURE_PAIRWISE;
+    }
+    mmf.flags |= ((count << 5) & IW_MICFAILURE_COUNT);
+
+    mmf.src_addr.sa_family = ARPHRD_ETHER;
+    memcpy(mmf.src_addr.sa_data, macaddr, ETH_ALEN);
+
+    memcpy(mmf.tsc, tsc, IW_ENCODE_SEQ_MAX_SIZE);
+
+    memset(&wrqu, 0, sizeof(wrqu));
+    wrqu.data.length = sizeof(mmf);
+
+    wireless_send_event(dev, IWEVMICHAELMICFAILURE, &wrqu, (char *)&mmf);
+}
+#elif WIRELESS_EXT >= 15
+static inline void
+_send_michaelmicfailure_event(struct net_device *dev,
+                              int count, const unsigned char *macaddr,
+                              int key_type, int key_idx,
+                              unsigned char *tsc)
+{
+    union iwreq_data wrqu;
+    char buf[128];
+
+    sprintf(buf,
+            "MLME-MICHAELMICFAILURE.indication(keyid=%d %scast addr=%02x:%02x:%02x:%02x:%02x:%02x)",
+            key_idx, (key_type == CSR_GROUP) ? "broad" : "uni",
+            macaddr[0], macaddr[1], macaddr[2],
+            macaddr[3], macaddr[4], macaddr[5]);
+    memset(&wrqu, 0, sizeof(wrqu));
+    wrqu.data.length = strlen(buf);
+    wireless_send_event(dev, IWEVCUSTOM, &wrqu, buf);
+}
+#else /* WIRELESS_EXT >= 15 */
+static inline void
+_send_michaelmicfailure_event(struct net_device *dev,
+                              int count, const unsigned char *macaddr,
+                              int key_type, int key_idx,
+                              unsigned char *tsc)
+{
+    /* Not supported before WEXT 15 */
+}
+#endif /* WIRELESS_EXT >= 15 */
+
+
+void
+wext_send_michaelmicfailure_event(unifi_priv_t *priv,
+                                  CsrUint16 count,
+                                  CsrWifiMacAddress address,
+                                  CsrWifiSmeKeyType keyType,
+                                  CsrUint16 interfaceTag)
+{
+    unsigned char tsc[8] = {0};
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "wext_send_michaelmicfailure_event bad interfaceTag\n");
+        return;
+    }
+
+    _send_michaelmicfailure_event(priv->netdev[interfaceTag],
+                                  count,
+                                  address.a,
+                                  keyType,
+                                  0,
+                                  tsc);
+} /* wext_send_michaelmicfailure_event() */
+
+void
+wext_send_pmkid_candidate_event(unifi_priv_t *priv, CsrWifiMacAddress bssid, CsrBool preauth_allowed, CsrUint16 interfaceTag)
+{
+#if WIRELESS_EXT > 17
+    union iwreq_data wrqu;
+    struct iw_pmkid_cand pmkid_cand;
+
+    if (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {
+        unifi_error(priv, "wext_send_pmkid_candidate_event bad interfaceTag\n");
+        return;
+    }
+
+    memset(&pmkid_cand, 0, sizeof(pmkid_cand));
+
+    if (preauth_allowed) {
+        pmkid_cand.flags |= IW_PMKID_CAND_PREAUTH;
+    }
+    pmkid_cand.bssid.sa_family = ARPHRD_ETHER;
+    memcpy(pmkid_cand.bssid.sa_data, bssid.a, ETH_ALEN);
+    /* Used as priority, smaller the number higher the priority, not really used in our case */
+    pmkid_cand.index = 1;
+
+    memset(&wrqu, 0, sizeof(wrqu));
+    wrqu.data.length = sizeof(pmkid_cand);
+
+    wireless_send_event(priv->netdev[interfaceTag], IWEVPMKIDCAND, &wrqu, (char *)&pmkid_cand);
+#endif
+} /* wext_send_pmkid_candidate_event() */
+
+/*
+ * Send a custom WEXT event to say we have completed initialisation
+ * and are now ready for WEXT ioctls. Used by Android wpa_supplicant.
+ */
+void
+wext_send_started_event(unifi_priv_t *priv)
+{
+#if WIRELESS_EXT > 17
+    union iwreq_data wrqu;
+    char data[] = "STARTED";
+
+    wrqu.data.length = sizeof(data);
+    wrqu.data.flags = 0;
+    wireless_send_event(priv->netdev[CSR_WIFI_INTERFACE_IN_USE], IWEVCUSTOM, &wrqu, data);
+#endif
+} /* wext_send_started_event() */
+
