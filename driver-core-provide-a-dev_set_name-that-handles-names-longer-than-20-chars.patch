From kay.sievers@vrfy.org Fri May  2 09:28:44 2008
From: Kay Sievers <kay.sievers@vrfy.org>
Date: Fri, 02 May 2008 06:02:41 +0200
Subject: driver core: provide a dev_set_name() that handles names longer than 20 chars
Message-ID: <1209700961.3100.7.camel@linux.site>

All device names are dynamically allocated now and are set and
read from the kobject, instead of keeping a 20 char long copy
of the string in every struct device.

Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/base/core.c    |   90 +++++++++++++++++++++++++++++++------------------
 include/linux/device.h |   10 +++--
 2 files changed, 64 insertions(+), 36 deletions(-)

--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -110,6 +110,9 @@ static void device_release(struct kobjec
 {
 	struct device *dev = to_dev(kobj);
 
+	/* possibly clean init_name, in case we did not add the device */
+	dev_set_name(dev, NULL);
+
 	if (dev->release)
 		dev->release(dev);
 	else if (dev->type && dev->type->release)
@@ -767,22 +770,6 @@ static void device_remove_class_symlinks
 }
 
 /**
- * dev_set_name - set a device name
- * @dev: device
- * @fmt: format string for the device's name
- */
-int dev_set_name(struct device *dev, const char *fmt, ...)
-{
-	va_list vargs;
-
-	va_start(vargs, fmt);
-	vsnprintf(dev->bus_id, sizeof(dev->bus_id), fmt, vargs);
-	va_end(vargs);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(dev_set_name);
-
-/**
  * device_to_dev_kobj - select a /sys/dev/ directory for the device
  * @dev: device
  *
@@ -830,6 +817,47 @@ static void device_remove_sys_dev_entry(
 	}
 }
 
+static int dev_set_name_vargs(struct device *dev,
+			      const char *fmt, va_list vargs)
+{
+	if (dev->init_name_is_set) {
+		kfree(dev->init_name);
+		dev->init_name_is_set = 0;
+	}
+
+	dev->init_name = NULL;
+
+	if (!fmt)
+		return 0;
+
+	dev->init_name = kvasprintf(GFP_KERNEL, fmt, vargs);
+	if (!dev->init_name)
+		return -ENOMEM;
+
+	dev->init_name_is_set = 1;
+	return 0;
+}
+
+/**
+ * dev_set_name - allocate temporary name for device
+ * @dev: device
+ *
+ * A temporary name is assigned to a device. The memory will be
+ * released with any call to device_add(), after successful
+ * registration the name available from the kobject with dev_name().
+ */
+int dev_set_name(struct device *dev, const char *fmt, ...)
+{
+	va_list vargs;
+	int err;
+
+	va_start(vargs, fmt);
+	err = dev_set_name_vargs(dev, fmt, vargs);
+	va_end(vargs);
+	return err;
+}
+EXPORT_SYMBOL_GPL(dev_set_name);
+
 /**
  * device_add - add device to device hierarchy.
  * @dev: device.
@@ -851,12 +879,7 @@ int device_add(struct device *dev)
 	if (!dev)
 		goto done;
 
-	/* Temporarily support init_name if it is set.
-	 * It will override bus_id for now */
-	if (dev->init_name)
-		dev_set_name(dev, "%s", dev->init_name);
-
-	if (!strlen(dev->bus_id))
+	if (!strlen(dev->init_name))
 		goto done;
 
 	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
@@ -868,12 +891,15 @@ int device_add(struct device *dev)
 	if (parent)
 		set_dev_node(dev, dev_to_node(parent));
 
-	/* first, register with generic layer. */
-	error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev_name(dev));
+	error = kobject_add(&dev->kobj, dev->kobj.parent, "%s", dev->init_name);
+
+	/* possibly free and clear any init_name, so nobody can misuse it */
+	dev_set_name(dev, NULL);
+
 	if (error)
 		goto Error;
 
-	/* notify platform of device entry */
+	/* notify clients of device entry */
 	if (platform_notify)
 		platform_notify(dev);
 
@@ -928,6 +954,7 @@ int device_add(struct device *dev)
 done:
 	put_device(dev);
 	return error;
+
  PMError:
 	bus_remove_device(dev);
  BusError:
@@ -1234,7 +1261,9 @@ struct device *device_create_vargs(struc
 	dev->release = device_create_release;
 	dev_set_drvdata(dev, drvdata);
 
-	vsnprintf(dev->bus_id, BUS_ID_SIZE, fmt, args);
+	retval = dev_set_name_vargs(dev, fmt, args);
+	if (retval)
+		goto error;
 	retval = device_register(dev);
 	if (retval)
 		goto error;
@@ -1242,6 +1271,7 @@ struct device *device_create_vargs(struc
 	return dev;
 
 error:
+	kfree(dev->init_name);
 	kfree(dev);
 	return ERR_PTR(retval);
 }
@@ -1341,19 +1371,15 @@ int device_rename(struct device *dev, ch
 		old_class_name = make_class_name(dev->class->name, &dev->kobj);
 #endif
 
-	old_device_name = kmalloc(BUS_ID_SIZE, GFP_KERNEL);
+	old_device_name = kstrdup(dev_name(dev), GFP_KERNEL);
 	if (!old_device_name) {
 		error = -ENOMEM;
 		goto out;
 	}
-	strlcpy(old_device_name, dev_name(dev), BUS_ID_SIZE);
-	strlcpy(dev->bus_id, new_name, BUS_ID_SIZE);
 
 	error = kobject_rename(&dev->kobj, new_name);
-	if (error) {
-		strlcpy(dev->bus_id, old_device_name, BUS_ID_SIZE);
+	if (error)
 		goto out;
-	}
 
 #ifdef CONFIG_SYSFS_DEPRECATED
 	if (old_class_name) {
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -349,10 +349,10 @@ struct device {
 	struct device		*parent;
 
 	struct kobject kobj;
-	char	bus_id[20];	/* will be removed */
 	const char *init_name;
 	struct device_type	*type;
-	unsigned		uevent_suppress:1;
+	unsigned int		init_name_is_set:1;
+	unsigned int		uevent_suppress:1;
 
 	struct semaphore	sem;	/* semaphore to synchronize calls to
 					 * its driver.
@@ -401,8 +401,10 @@ struct device {
 
 static inline const char *dev_name(struct device *dev)
 {
-	/* will be changed into kobject_name(&dev->kobj) in the near future */
-	return dev->bus_id;
+	/* return sensible value between dev_set_name() and device_add() */
+	if (dev->init_name)
+		return dev->init_name;
+	return kobject_name(&dev->kobj);
 }
 
 extern int dev_set_name(struct device *dev, const char *name, ...)
