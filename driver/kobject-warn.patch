From: gregkh@suse.de
Subject: kobject warning stuff

Good for development, don't push it to mainline as there are too many
false positives.

There are 2 changes in this patch.

First one is to ensure that the kobject is properly initialized _before_
kobject_init() is called.  Yeah, seems funny, right?  Turns out this has
caught a lot of issues where kobject_init() is called twice on the same
object, not a good thing at all.

The second change in that patch tries to enforce the "everything needs a
release() function" rule for kobjects, but it turns out, a lot of static
kobjects trigger this inproperly (struct bus and friends), so that can't
go to mainline, and it only shows up if you enable CONFIG_KOBJECT_DEBUG.


Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 lib/kobject.c |    5 +++++
 1 file changed, 5 insertions(+)

--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -132,6 +132,7 @@ void kobject_init(struct kobject * kobj)
 {
 	if (!kobj)
 		return;
+	WARN_ON(atomic_read(&kobj->kref.refcount));
 	kref_init(&kobj->kref);
 	INIT_LIST_HEAD(&kobj->entry);
 	kobj->kset = kset_get(kobj->kset);
@@ -463,6 +464,10 @@ void kobject_cleanup(struct kobject * ko
 		 * not a statically allocated kobject, so we should be safe to
 		 * free the name */
 		kfree(name);
+	} else {
+		pr_debug("kobject '%s' does not have a release() function, "
+			"if this is not a directory kobject, it is broken "
+			"and must be fixed.\n", name);
 	}
 	if (s)
 		kset_put(s);
