From lkml@lievin.net Fri Nov 30 23:51:27 2007
From: Romain Liévin <lkml@lievin.net>
Date: Sat, 01 Dec 2007 08:51:58 +0100
Subject: tipar: remove obsolete module
To: Greg KH <greg@kroah.com>
Message-ID: <4751129E.5080207@lievin.net>


From: Romain Liévin <lkml@lievin.net>

tipar: remove obsolete module

The tipar character driver was used to implement bit-banging access
to Texas Instruments parallel link cable. A user-land method now 
exists thru PPDEV & PARPORT.

Signed-off-by: Romain Liévin <roms@lpg.ticalc.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 Documentation/tipar.txt |   93 --------
 MAINTAINERS             |    5 
 drivers/char/Kconfig    |   22 -
 drivers/char/tipar.c    |  557 ------------------------------------------------
 include/linux/ticable.h |   44 ---
 5 files changed, 721 deletions(-)

--- a/Documentation/tipar.txt
+++ /dev/null
@@ -1,93 +0,0 @@
-
-		Parallel link cable for Texas Instruments handhelds
-		===================================================
-
-
-Author: Romain Lievin
-Homepage: http://lpg.ticalc.org/prj_tidev/index.html
-
-
-INTRODUCTION:
-
-This is a driver for the very common home-made parallel link cable, a cable 
-designed for connecting TI8x/9x graphing calculators (handhelds) to a computer
-or workstation (Alpha, Sparc). Given that driver is built on parport, the 
-parallel port abstraction layer, this driver is architecture-independent.
-
-It can also be used with another device plugged on the same port (such as a
-ZIP drive). I have a 100MB ZIP and both of them work fine!
-
-If you need more information, please visit the 'TI drivers' homepage at the URL
-above.
-
-WHAT YOU NEED:
-
-A TI calculator and a program capable of communicating with your calculator.
-
-TiLP will work for sure (since I am its developer!). yal92 may be able to use
-it by changing tidev for tipar (may require some hacking...).
-
-HOW TO USE IT:
-
-You must have first compiled parport support (CONFIG_PARPORT_DEV): either 
-compiled in your kernel, either as a module. 
-
-Next, (as root):
-
-       modprobe parport
-       modprobe tipar
-
-If it is not already there (it usually is), create the device:
-
-       mknod /dev/tipar0 c 115 0
-       mknod /dev/tipar1 c 115 1
-       mknod /dev/tipar2 c 115 2
-
-You will have to set permissions on this device to allow you to read/write
-from it:
-
-       chmod 666 /dev/tipar[0..2]
-       
-Now you are ready to run a linking program such as TiLP. Be sure to configure 
-it properly (RTFM).
-       
-MODULE PARAMETERS:
-
-  You can set these with:  modprobe tipar NAME=VALUE
-  There is currently no way to set these on a per-cable basis.
-
-  NAME: timeout
-  TYPE: integer
-  DEFAULT: 15
-  DESC: Timeout value in tenth of seconds. If no data is available once this 
-	time has expired then the driver will return with a timeout error.
-
-  NAME: delay
-  TYPE: integer
-  DEFAULT: 10
-  DESC: Inter-bit delay in micro-seconds. A lower value gives an higher data
-	rate but makes transmission less reliable.
-
-These parameters can be changed at run time by any program via ioctl(2) calls 
-as listed in ./include/linux/ticable.h.
-
-Rather than write 50 pages describing the ioctl() and so on, it is
-perhaps more useful you look at ticables library (dev_link.c) that demonstrates
-how to use them, and demonstrates the features of the driver. This is
-probably a lot more useful to people interested in writing applications
-that will be using this driver.
-
-QUIRKS/BUGS:
-
-None.
-
-HOW TO CONTACT US:
-
-You can email me at roms@lpg.ticalc.org. Please prefix the subject line
-with "TIPAR: " so that I am certain to notice your message.
-You can also mail JB at jb@jblache.org. He packaged these drivers for Debian.
-
-CREDITS:
-
-The code is based on tidev.c & parport.c.
-The driver has been developed independently of Texas Instruments.
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -3699,11 +3699,6 @@ M:	nagar@watson.ibm.com
 L:	linux-kernel@vger.kernel.org
 S:	Maintained
 
-TI PARALLEL LINK CABLE DRIVER
-P:	Romain Lievin
-M:	roms@lpg.ticalc.org
-S:	Maintained
-
 TIPC NETWORK LAYER
 P:	Per Liden
 M:	per.liden@ericsson.com
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -543,28 +543,6 @@ config PPDEV
 
 	  If unsure, say N.
 
-config TIPAR
-	tristate "Texas Instruments parallel link cable support"
-	depends on PARPORT
-	---help---
-	  If you own a Texas Instruments graphing calculator and use a
-	  parallel link cable, then you might be interested in this driver.
-
-	  If you enable this driver, you will be able to communicate with
-	  your calculator through a set of device nodes under /dev. The
-	  main advantage of this driver is that you don't have to be root
-	  to use this precise link cable (depending on the permissions on
-	  the device nodes, though).
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called tipar.
-
-	  If you don't know what a parallel link cable is or what a Texas
-	  Instruments graphing calculator is, then you probably don't need this
-	  driver.
-
-	  If unsure, say N.
-
 config HVC_DRIVER
 	bool
 	help
--- a/drivers/char/tipar.c
+++ /dev/null
@@ -1,557 +0,0 @@
-/* Hey EMACS -*- linux-c -*-
- *
- * tipar - low level driver for handling a parallel link cable designed
- * for Texas Instruments graphing calculators (http://lpg.ticalc.org).
- * A part of the TiLP project.
- *
- * Copyright (C) 2000-2002, Romain Lievin <roms@lpg.ticalc.org>
- * under the terms of the GNU General Public License.
- *
- * Various fixes & clean-up from the Linux Kernel Mailing List
- * (Alan Cox, Richard B. Johnson, Christoph Hellwig).
- */
-
-/* This driver should, in theory, work with any parallel port that has an
- * appropriate low-level driver; all I/O is done through the parport
- * abstraction layer.
- *
- * If this driver is built into the kernel, you can configure it using the
- * kernel command-line.  For example:
- *
- *      tipar=timeout,delay       (set timeout and delay)
- *
- * If the driver is loaded as a module, similar functionality is available
- * using module parameters.  The equivalent of the above commands would be:
- *
- *      # insmod tipar timeout=15 delay=10
- */
-
-/* COMPATIBILITY WITH OLD KERNELS
- *
- * Usually, parallel cables were bound to ports at
- * particular I/O addresses, as follows:
- *
- *      tipar0             0x378
- *      tipar1             0x278
- *      tipar2             0x3bc
- *
- *
- * This driver, by default, binds tipar devices according to parport and
- * the minor number.
- *
- */
-#undef DEBUG				/* change to #define to get debugging
-					 * output - for pr_debug() */
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/fcntl.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <asm/uaccess.h>
-#include <linux/ioport.h>
-#include <asm/io.h>
-#include <linux/bitops.h>
-#include <linux/parport.h>		/* Our code depend on parport */
-#include <linux/device.h>
-
-/*
- * TI definitions
- */
-#include <linux/ticable.h>
-
-/*
- * Version Information
- */
-#define DRIVER_VERSION "1.19"
-#define DRIVER_AUTHOR  "Romain Lievin <roms@lpg.ticalc.org>"
-#define DRIVER_DESC    "Device driver for TI/PC parallel link cables"
-#define DRIVER_LICENSE "GPL"
-
-#define VERSION(ver,rel,seq) (((ver)<<16) | ((rel)<<8) | (seq))
-
-/* ----- global variables --------------------------------------------- */
-
-struct tipar_struct {
-	struct pardevice *dev;	/* Parport device entry */
-};
-
-#define PP_NO 3
-static struct tipar_struct table[PP_NO];
-
-static int delay = IO_DELAY;	/* inter-bit delay in microseconds */
-static int timeout = TIMAXTIME;	/* timeout in tenth of seconds     */
-
-static unsigned int tp_count;	/* tipar count */
-static unsigned long opened;	/* opened devices */
-
-static struct class *tipar_class;
-
-/* --- macros for parport access -------------------------------------- */
-
-#define r_dtr(x)        (parport_read_data(table[(x)].dev->port))
-#define r_str(x)        (parport_read_status(table[(x)].dev->port))
-#define w_ctr(x,y)      (parport_write_control(table[(x)].dev->port, (y)))
-#define w_dtr(x,y)      (parport_write_data(table[(x)].dev->port, (y)))
-
-/* --- setting states on the D-bus with the right timing: ------------- */
-
-static inline void
-outbyte(int value, int minor)
-{
-	w_dtr(minor, value);
-}
-
-static inline int
-inbyte(int minor)
-{
-	return (r_str(minor));
-}
-
-static inline void
-init_ti_parallel(int minor)
-{
-	outbyte(3, minor);
-}
-
-/* ----- global defines ----------------------------------------------- */
-
-#define START(x) { x = jiffies + (HZ * timeout) / 10; }
-#define WAIT(x)  { \
-  if (time_before((x), jiffies)) return -1; \
-  if (need_resched()) schedule(); }
-
-/* ----- D-bus bit-banging functions ---------------------------------- */
-
-/* D-bus protocol (45kbit/s max):
-                    1                 0                      0
-       _______        ______|______    __________|________    __________
-Red  :        ________      |      ____          |        ____
-       _        ____________|________      ______|__________       _____
-White:  ________            |        ______      |          _______
-*/
-
-/* Try to transmit a byte on the specified port (-1 if error). */
-static int
-put_ti_parallel(int minor, unsigned char data)
-{
-	unsigned int bit;
-	unsigned long max;
-
-	for (bit = 0; bit < 8; bit++) {
-		if (data & 1) {
-			outbyte(2, minor);
-			START(max);
-			do {
-				WAIT(max);
-			} while (inbyte(minor) & 0x10);
-
-			outbyte(3, minor);
-			START(max);
-			do {
-				WAIT(max);
-			} while (!(inbyte(minor) & 0x10));
-		} else {
-			outbyte(1, minor);
-			START(max);
-			do {
-				WAIT(max);
-			} while (inbyte(minor) & 0x20);
-
-			outbyte(3, minor);
-			START(max);
-			do {
-				WAIT(max);
-			} while (!(inbyte(minor) & 0x20));
-		}
-
-		data >>= 1;
-		udelay(delay);
-
-		if (need_resched())
-			schedule();
-	}
-
-	return 0;
-}
-
-/* Receive a byte on the specified port or -1 if error. */
-static int
-get_ti_parallel(int minor)
-{
-	unsigned int bit;
-	unsigned char v, data = 0;
-	unsigned long max;
-
-	for (bit = 0; bit < 8; bit++) {
-		START(max);
-		do {
-			WAIT(max);
-		} while ((v = inbyte(minor) & 0x30) == 0x30);
-
-		if (v == 0x10) {
-			data = (data >> 1) | 0x80;
-			outbyte(1, minor);
-			START(max);
-			do {
-				WAIT(max);
-			} while (!(inbyte(minor) & 0x20));
-			outbyte(3, minor);
-		} else {
-			data = data >> 1;
-			outbyte(2, minor);
-			START(max);
-			do {
-				WAIT(max);
-			} while (!(inbyte(minor) & 0x10));
-			outbyte(3, minor);
-		}
-
-		udelay(delay);
-		if (need_resched())
-			schedule();
-	}
-
-	return (int) data;
-}
-
-/* Try to detect a parallel link cable on the specified port */
-static int
-probe_ti_parallel(int minor)
-{
-	int i;
-	int seq[] = { 0x00, 0x20, 0x10, 0x30 };
-	int data;
-
-	for (i = 3; i >= 0; i--) {
-		outbyte(3, minor);
-		outbyte(i, minor);
-		udelay(delay);
-		data = inbyte(minor) & 0x30;
-		pr_debug("tipar: Probing -> %i: 0x%02x 0x%02x\n", i,
-			data, seq[i]);
-		if (data != seq[i]) {
-			outbyte(3, minor);
-			return -1;
-		}
-	}
-
-	outbyte(3, minor);
-	return 0;
-}
-
-/* ----- kernel module functions--------------------------------------- */
-
-static int
-tipar_open(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode) - TIPAR_MINOR;
-
-	if (tp_count == 0 || minor > tp_count - 1)
-		return -ENXIO;
-
-	if (test_and_set_bit(minor, &opened))
-		return -EBUSY;
-
-	if (!table[minor].dev) {
-		printk(KERN_ERR "%s: NULL device for minor %u\n",
-				__FUNCTION__, minor);
-		return -ENXIO;
-	}
-	parport_claim_or_block(table[minor].dev);
-	init_ti_parallel(minor);
-	parport_release(table[minor].dev);
-
-	return nonseekable_open(inode, file);
-}
-
-static int
-tipar_close(struct inode *inode, struct file *file)
-{
-	unsigned int minor = iminor(inode) - TIPAR_MINOR;
-
-	if (minor > tp_count - 1)
-		return -ENXIO;
-
-	clear_bit(minor, &opened);
-
-	return 0;
-}
-
-static ssize_t
-tipar_write (struct file *file, const char __user *buf, size_t count,
-		loff_t * ppos)
-{
-	unsigned int minor = iminor(file->f_path.dentry->d_inode) - TIPAR_MINOR;
-	ssize_t n;
-
-	parport_claim_or_block(table[minor].dev);
-
-	for (n = 0; n < count; n++) {
-		unsigned char b;
-
-		if (get_user(b, buf + n)) {
-			n = -EFAULT;
-			goto out;
-		}
-
-		if (put_ti_parallel(minor, b) == -1) {
-			init_ti_parallel(minor);
-			n = -ETIMEDOUT;
-			goto out;
-		}
-	}
-      out:
-	parport_release(table[minor].dev);
-	return n;
-}
-
-static ssize_t
-tipar_read(struct file *file, char __user *buf, size_t count, loff_t * ppos)
-{
-	int b = 0;
-	unsigned int minor = iminor(file->f_path.dentry->d_inode) - TIPAR_MINOR;
-	ssize_t retval = 0;
-	ssize_t n = 0;
-
-	if (count == 0)
-		return 0;
-
-	parport_claim_or_block(table[minor].dev);
-
-	while (n < count) {
-		b = get_ti_parallel(minor);
-		if (b == -1) {
-			init_ti_parallel(minor);
-			retval = -ETIMEDOUT;
-			goto out;
-		} else {
-			if (put_user(b, buf + n)) {
-				retval = -EFAULT;
-				break;
-			} else
-				retval = ++n;
-		}
-
-		/* Non-blocking mode : try again ! */
-		if (file->f_flags & O_NONBLOCK) {
-			retval = -EAGAIN;
-			goto out;
-		}
-
-		/* Signal pending, try again ! */
-		if (signal_pending(current)) {
-			retval = -ERESTARTSYS;
-			goto out;
-		}
-
-		if (need_resched())
-			schedule();
-	}
-
-      out:
-	parport_release(table[minor].dev);
-	return retval;
-}
-
-static int
-tipar_ioctl(struct inode *inode, struct file *file,
-	    unsigned int cmd, unsigned long arg)
-{
-	int retval = 0;
-
-	switch (cmd) {
-	case IOCTL_TIPAR_DELAY:
-		delay = (int)arg;    //get_user(delay, &arg);
-		break;
-	case IOCTL_TIPAR_TIMEOUT:
-		if (arg != 0)
-                        timeout = (int)arg;
-                else
-                        retval = -EINVAL;
-	  break;
-	default:
-		retval = -ENOTTY;
-		break;
-	}
-
-	return retval;
-}
-
-/* ----- kernel module registering ------------------------------------ */
-
-static const struct file_operations tipar_fops = {
-	.owner = THIS_MODULE,
-	.llseek = no_llseek,
-	.read = tipar_read,
-	.write = tipar_write,
-	.ioctl = tipar_ioctl,
-	.open = tipar_open,
-	.release = tipar_close,
-};
-
-/* --- initialisation code ------------------------------------- */
-
-#ifndef MODULE
-/*      You must set these - there is no sane way to probe for this cable.
- *      You can use 'tipar=timeout,delay' to set these now. */
-static int __init
-tipar_setup(char *str)
-{
-	int ints[3];
-
-	str = get_options(str, ARRAY_SIZE(ints), ints);
-
-	if (ints[0] > 0) {
-		if (ints[1] != 0)
-                        timeout = ints[1];
-                else
-                        printk(KERN_WARNING "tipar: bad timeout value (0), "
-				"using default value instead");
-		if (ints[0] > 1) {
-			delay = ints[2];
-		}
-	}
-
-	return 1;
-}
-#endif
-
-/*
- * Register our module into parport.
- * Pass also 2 callbacks functions to parport: a pre-emptive function and an
- * interrupt handler function (unused).
- * Display a message such "tipar0: using parport0 (polling)".
- */
-static int
-tipar_register(int nr, struct parport *port)
-{
-	int err = 0;
-
-	/* Register our module into parport */
-	table[nr].dev = parport_register_device(port, "tipar",
-						NULL, NULL, NULL, 0,
-						(void *) &table[nr]);
-
-	if (table[nr].dev == NULL) {
-		err = 1;
-		goto out;
-	}
-
-	device_create(tipar_class, port->dev, MKDEV(TIPAR_MAJOR,
-			TIPAR_MINOR + nr), "par%d", nr);
-
-	/* Display informations */
-	pr_info("tipar%d: using %s (%s)\n", nr, port->name, (port->irq ==
-		PARPORT_IRQ_NONE) ? "polling" : "interrupt-driven");
-
-	if (probe_ti_parallel(nr) != -1)
-		pr_info("tipar%d: link cable found\n", nr);
-	else
-		pr_info("tipar%d: link cable not found\n", nr);
-
-	err = 0;
-
-out:
-	return err;
-}
-
-static void
-tipar_attach(struct parport *port)
-{
-	if (tp_count == PP_NO) {
-		pr_info("tipar: ignoring parallel port (max. %d)\n", PP_NO);
-		return;
-	}
-
-	if (!tipar_register(tp_count, port))
-		tp_count++;
-}
-
-static void
-tipar_detach(struct parport *port)
-{
-	/* Nothing to do */
-}
-
-static struct parport_driver tipar_driver = {
-	.name = "tipar",
-	.attach = tipar_attach,
-	.detach = tipar_detach,
-};
-
-static int __init
-tipar_init_module(void)
-{
-	int err = 0;
-
-	pr_info("tipar: parallel link cable driver, version %s\n",
-		DRIVER_VERSION);
-
-	if (register_chrdev(TIPAR_MAJOR, "tipar", &tipar_fops)) {
-		printk(KERN_ERR "tipar: unable to get major %d\n", TIPAR_MAJOR);
-		err = -EIO;
-		goto out;
-	}
-
-	tipar_class = class_create(THIS_MODULE, "ticables");
-	if (IS_ERR(tipar_class)) {
-		err = PTR_ERR(tipar_class);
-		goto out_chrdev;
-	}
-	if (parport_register_driver(&tipar_driver)) {
-		printk(KERN_ERR "tipar: unable to register with parport\n");
-		err = -EIO;
-		goto out_class;
-	}
-
-	err = 0;
-	goto out;
-
-out_class:
-	class_destroy(tipar_class);
-
-out_chrdev:
-	unregister_chrdev(TIPAR_MAJOR, "tipar");
-out:
-	return err;	
-}
-
-static void __exit
-tipar_cleanup_module(void)
-{
-	unsigned int i;
-
-	/* Unregistering module */
-	parport_unregister_driver(&tipar_driver);
-
-	unregister_chrdev(TIPAR_MAJOR, "tipar");
-
-	for (i = 0; i < PP_NO; i++) {
-		if (table[i].dev == NULL)
-			continue;
-		parport_unregister_device(table[i].dev);
-		device_destroy(tipar_class, MKDEV(TIPAR_MAJOR, i));
-	}
-	class_destroy(tipar_class);
-
-	pr_info("tipar: module unloaded\n");
-}
-
-/* --------------------------------------------------------------------- */
-
-__setup("tipar=", tipar_setup);
-module_init(tipar_init_module);
-module_exit(tipar_cleanup_module);
-
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE(DRIVER_LICENSE);
-
-module_param(timeout, int, 0);
-MODULE_PARM_DESC(timeout, "Timeout (default=1.5 seconds)");
-module_param(delay, int, 0);
-MODULE_PARM_DESC(delay, "Inter-bit delay (default=10 microseconds)");
--- a/include/linux/ticable.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/* Hey EMACS -*- linux-c -*-
- *
- * tipar/tiser/tiusb - low level driver for handling link cables
- * designed for Texas Instruments graphing calculators.
- *
- * Copyright (C) 2000-2002, Romain Lievin <roms@lpg.ticalc.org>
- *
- * Redistribution of this file is permitted under the terms of the GNU
- * Public License (GPL)
- */
-
-#ifndef _TICABLE_H 
-#define _TICABLE_H 1
-
-/* Internal default constants for the kernel module */
-#define TIMAXTIME 15      /* 1.5 seconds       */
-#define IO_DELAY  10      /* 10 micro-seconds  */
-
-/* Major & minor number for character devices */
-#define TIPAR_MAJOR  115 /* 0 to 7 */
-#define TIPAR_MINOR    0
-
-#define TISER_MAJOR  115 /* 8 to 15 */
-#define TISER_MINOR    8
-
-#define TIUSB_MAJOR  115  /* 16 to 31 */
-#define TIUSB_MINOR   16
-
-/*
- * Request values for the 'ioctl' function.
- */
-#define IOCTL_TIPAR_DELAY     _IOW('p', 0xa8, int) /* set delay   */
-#define IOCTL_TIPAR_TIMEOUT   _IOW('p', 0xa9, int) /* set timeout */
-
-#define IOCTL_TISER_DELAY     _IOW('p', 0xa0, int) /* set delay   */
-#define IOCTL_TISER_TIMEOUT   _IOW('p', 0xa1, int) /* set timeout */
-
-#define IOCTL_TIUSB_TIMEOUT        _IOW('N', 0x20, int) /* set timeout */
-#define IOCTL_TIUSB_RESET_DEVICE   _IOW('N', 0x21, int) /* reset device */
-#define IOCTL_TIUSB_RESET_PIPES    _IOW('N', 0x22, int) /* reset both pipes*/
-#define IOCTL_TIUSB_GET_MAXPS      _IOR('N', 0x23, int) /* max packet size */
-#define IOCTL_TIUSB_GET_DEVID      _IOR('N', 0x24, int) /* get device type */
-
-#endif /* TICABLE_H */
