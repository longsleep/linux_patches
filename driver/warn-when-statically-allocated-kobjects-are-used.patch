From haveblue@us.ibm.com Thu Mar 16 17:30:46 2006
From: Dave Hansen <haveblue@us.ibm.com>
Subject: warn when statically-allocated kobjects are used
Cc: gregkh@suse.de, Dave Hansen <haveblue@us.ibm.com>
Date: Thu, 16 Mar 2006 17:30:16 -0800
Message-Id: <20060317013016.5C643E69@localhost.localdomain>


One of the top ten sysfs problems is that users use statically
allocated kobjects.  This patch reminds them that this is a
naughty thing.

One _really_ nice thing this patch does, is us the kallsyms
mechanism to print out exactly which symbol is being complained
about:

	The kobject at, or inside 'statickobj.2'@(0xc040d020) is not dynamically allocated.

This patch replaces the previous implementation's use of a
_sdata symbol in favor of using kallsyms_lookup().  If a
kobject's address is a resolvable symbol, then it isn't
dynamically allocated.

The one exception to this is init symbols.  The patch also
checks to see whether __init memory has been freed and if
it has will allow kobjects in those sections.

Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 include/linux/init.h |    1 
 init/main.c          |    9 ++++++++
 lib/kobject.c        |   56 +++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 66 insertions(+)

--- a/include/linux/init.h
+++ b/include/linux/init.h
@@ -86,6 +86,7 @@ extern initcall_t __security_initcall_st
 extern char __initdata boot_command_line[];
 extern char *saved_command_line;
 extern unsigned int reset_devices;
+extern int initmem_now_dynamic;
 
 /* used by init/main.c */
 void setup_arch(char **);
--- a/init/main.c
+++ b/init/main.c
@@ -761,12 +761,21 @@ static void run_init_process(char *init_
 	kernel_execve(init_filename, argv_init, envp_init);
 }
 
+/*
+ * __init/__init_data sections are turned into normal
+ * dynamically allocated memory later in boot.  When
+ * this is 0, the memory is for the __init purposes,
+ * when it it some other value, the memory is dynamic.
+ */
+int initmem_now_dynamic;
+
 /* This is a non __init function. Force it to be noinline otherwise gcc
  * makes it inline to init() and it becomes part of init.text section
  */
 static int noinline init_post(void)
 {
 	free_initmem();
+	initmem_now_dynamic = 1;
 	unlock_kernel();
 	mark_rodata_ro();
 	system_state = SYSTEM_RUNNING;
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -17,6 +17,8 @@
 #include <linux/module.h>
 #include <linux/stat.h>
 #include <linux/slab.h>
+#include <linux/kallsyms.h>
+#include <asm-generic/sections.h>
 
 /**
  *	populate_dir - populate directory with attributes.
@@ -123,6 +125,59 @@ char *kobject_get_path(struct kobject *k
 }
 EXPORT_SYMBOL_GPL(kobject_get_path);
 
+#ifdef CONFIG_X86_32
+static int ptr_in_range(void *ptr, void *start, void *end)
+{
+	/*
+	 * This should hopefully get rid of causing warnings
+	 * if the architecture did not set one of the section
+	 * variables up.
+	 */
+	if (start >= end)
+		return 0;
+
+	if ((ptr >= start) && (ptr < end))
+		return 1;
+	return 0;
+}
+
+void verify_dynamic_kobject_allocation(struct kobject *kobj)
+{
+	char *namebuf;
+	const char *ret;
+
+	namebuf = kzalloc(KSYM_NAME_LEN, GFP_KERNEL);
+	ret = kallsyms_lookup((unsigned long)kobj, NULL, NULL, NULL,
+			namebuf);
+	/*
+	 * This is the X86_32-only part of this function.
+	 * This is here because it is valid to have a kobject
+	 * in an __init section, but only after those
+	 * sections have been freed back to the dynamic pool.
+	 */
+	if (!initmem_now_dynamic &&
+	    ptr_in_range(kobj, __init_begin, __init_end))
+		goto out;
+	if (!ret || !strlen(ret))
+		goto out;
+	pr_debug("---- begin silly warning ----\n");
+	pr_debug("This is a janitorial warning, not a kernel bug.\n");
+#ifdef CONFIG_DEBUG_KOBJECT
+	pr_debug("The kobject at, or inside '%s'@(0x%p) is not dynamically allocated.\n",
+			namebuf, kobj);
+#endif
+	pr_debug("kobjects must be dynamically allocated, not static\n");
+	/* dump_stack(); */
+	pr_debug("---- end silly warning ----\n");
+out:
+	kfree(namebuf);
+}
+#else
+static void verify_dynamic_kobject_allocation(struct kobject *kobj)
+{
+}
+#endif
+
 /**
  *	kobject_init - initialize object.
  *	@kobj:	object in question.
@@ -132,6 +187,7 @@ void kobject_init(struct kobject * kobj)
 	if (!kobj)
 		return;
 	WARN_ON(atomic_read(&kobj->kref.refcount));
+	verify_dynamic_kobject_allocation(kobj);
 	kref_init(&kobj->kref);
 	INIT_LIST_HEAD(&kobj->entry);
 	kobj->kset = kset_get(kobj->kset);
