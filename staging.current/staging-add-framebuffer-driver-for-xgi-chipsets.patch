From apatard@mandriva.com  Tue Jun  1 13:18:40 2010
From: apatard@mandriva.com
Date: Wed, 19 May 2010 10:44:14 +0200
Subject: staging: Add framebuffer driver for XGI chipsets
To: gregkh@suse.de
Cc: greg@kroah.com, Arnaud Patard <apatard@mandriva.com>
Message-ID: <20100519084507.177397958@mandriva.com>


This driver handles XG20, XG21, XG40, XG42 chipsets from XGI. They're
also known as Z7,Z9,Z11 chipsets. It's based on the SiS fb driver but
has been heavily modified by XGI to support their newer chipsets.


Signed-off-by: Arnaud Patard <apatard@mandriva.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/Kconfig             |    2 
 drivers/staging/Makefile            |    1 
 drivers/staging/xgifb/Kconfig       |   11 
 drivers/staging/xgifb/Makefile      |    4 
 drivers/staging/xgifb/TODO          |   15 
 drivers/staging/xgifb/XGI.h         |   10 
 drivers/staging/xgifb/XGI_accel.c   |  596 +
 drivers/staging/xgifb/XGI_accel.h   |  511 +
 drivers/staging/xgifb/XGI_main.h    | 1023 +++
 drivers/staging/xgifb/XGI_main_26.c | 3773 ++++++++++++
 drivers/staging/xgifb/XGIfb.h       |  215 
 drivers/staging/xgifb/osdef.h       |  153 
 drivers/staging/xgifb/vb_def.h      | 1017 +++
 drivers/staging/xgifb/vb_ext.c      | 1370 ++++
 drivers/staging/xgifb/vb_ext.h      |   32 
 drivers/staging/xgifb/vb_init.c     | 3444 +++++++++++
 drivers/staging/xgifb/vb_init.h     |    7 
 drivers/staging/xgifb/vb_setmode.c  |10736 ++++++++++++++++++++++++++++++++++++
 drivers/staging/xgifb/vb_setmode.h  |   40 
 drivers/staging/xgifb/vb_struct.h   |  534 +
 drivers/staging/xgifb/vb_table.h    | 4406 ++++++++++++++
 drivers/staging/xgifb/vb_util.c     |  263 
 drivers/staging/xgifb/vb_util.h     |   15 
 drivers/staging/xgifb/vgatypes.h    |  325 +
 24 files changed, 28503 insertions(+)

--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -141,5 +141,7 @@ source "drivers/staging/ti-st/Kconfig"
 
 source "drivers/staging/adis16255/Kconfig"
 
+source "drivers/staging/xgifb/Kconfig"
+
 endif # !STAGING_EXCLUDE_BUILD
 endif # STAGING
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -51,3 +51,4 @@ obj-$(CONFIG_CRYSTALHD)		+= crystalhd/
 obj-$(CONFIG_CXT1E1)		+= cxt1e1/
 obj-$(CONFIG_TI_ST)		+= ti-st/
 obj-$(CONFIG_ADIS16255)		+= adis16255/
+obj-$(CONFIG_FB_XGI)		+= xgifb/
--- /dev/null
+++ b/drivers/staging/xgifb/Kconfig
@@ -0,0 +1,11 @@
+config FB_XGI
+	tristate "XGI display support"
+	depends on FB && PCI
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This driver supports notebooks with XGI Z7,Z9,Z11 PCI chips.
+	  Say Y if you have such a graphics card.
+	  To compile this driver as a module, choose M here: the
+	  module will be called xgifb.ko
--- /dev/null
+++ b/drivers/staging/xgifb/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_FB_XGI)  += xgifb.o
+
+xgifb-objs := XGI_main_26.o XGI_accel.o vb_init.o vb_setmode.o vb_util.o vb_ext.o
+
--- /dev/null
+++ b/drivers/staging/xgifb/TODO
@@ -0,0 +1,15 @@
+This drivers still need a lot of work. I can list all cleanups to do but it's
+going to be long. So, I'm writing "cleanups" and not the list.
+
+Arnaud
+
+TODO:
+- clean ups
+- fix build warnings when module
+- sort out dup ids with SiS driver
+- remove useless/wrong/unused #ifdef/code/...
+- fix printk usages
+- get rid of non-linux related stuff
+
+Please send patches to:
+Arnaud Patard <apatard@mandriva.com>
--- /dev/null
+++ b/drivers/staging/xgifb/XGI.h
@@ -0,0 +1,10 @@
+#ifndef _XGI_H
+#define _XGI_H
+
+#if 1
+#define TWDEBUG(x)
+#else
+#define TWDEBUG(x) printk(KERN_INFO x "\n");
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/xgifb/XGI_accel.c
@@ -0,0 +1,596 @@
+/*
+ * XGI 300/630/730/540/315/550/650/740 frame buffer driver
+ * for Linux kernels 2.4.x and 2.5.x
+ *
+ * 2D acceleration part
+ *
+ * Based on the X driver's XGI300_accel.c which is
+ *     Copyright Xavier Ducoin <x.ducoin@lectra.com>
+ *     Copyright 2002 by Thomas Winischhofer, Vienna, Austria
+ * and XGI310_accel.c which is
+ *     Copyright 2002 by Thomas Winischhofer, Vienna, Austria
+ *
+ * Author: Thomas Winischhofer <thomas@winischhofer.net>
+ *			(see http://www.winischhofer.net/
+ *			for more information and updates)
+ */
+
+//#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/selection.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/vt_kern.h>
+#include <linux/capability.h>
+#include <linux/fs.h>
+#include <linux/agp_backend.h>
+
+#include <linux/types.h>
+/*
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include <linux/XGIfb.h>
+#else
+#include <video/XGIfb.h>
+#endif
+*/
+#include <asm/io.h>
+
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb24.h>
+#include <video/fbcon-cfb32.h>
+#endif
+
+#include "osdef.h"
+#include "vgatypes.h"
+#include "vb_struct.h"
+#include "XGIfb.h"
+#include "XGI_accel.h"
+
+
+extern struct     video_info xgi_video_info;
+extern int XGIfb_accel;
+
+static const int XGIALUConv[] =
+{
+    0x00,       /* dest = 0;            0,      GXclear,        0 */
+    0x88,       /* dest &= src;         DSa,    GXand,          0x1 */
+    0x44,       /* dest = src & ~dest;  SDna,   GXandReverse,   0x2 */
+    0xCC,       /* dest = src;          S,      GXcopy,         0x3 */
+    0x22,       /* dest &= ~src;        DSna,   GXandInverted,  0x4 */
+    0xAA,       /* dest = dest;         D,      GXnoop,         0x5 */
+    0x66,       /* dest = ^src;         DSx,    GXxor,          0x6 */
+    0xEE,       /* dest |= src;         DSo,    GXor,           0x7 */
+    0x11,       /* dest = ~src & ~dest; DSon,   GXnor,          0x8 */
+    0x99,       /* dest ^= ~src ;       DSxn,   GXequiv,        0x9 */
+    0x55,       /* dest = ~dest;        Dn,     GXInvert,       0xA */
+    0xDD,       /* dest = src|~dest ;   SDno,   GXorReverse,    0xB */
+    0x33,       /* dest = ~src;         Sn,     GXcopyInverted, 0xC */
+    0xBB,       /* dest |= ~src;        DSno,   GXorInverted,   0xD */
+    0x77,       /* dest = ~src|~dest;   DSan,   GXnand,         0xE */
+    0xFF,       /* dest = 0xFF;         1,      GXset,          0xF */
+};
+/* same ROP but with Pattern as Source */
+static const int XGIPatALUConv[] =
+{
+    0x00,       /* dest = 0;            0,      GXclear,        0 */
+    0xA0,       /* dest &= src;         DPa,    GXand,          0x1 */
+    0x50,       /* dest = src & ~dest;  PDna,   GXandReverse,   0x2 */
+    0xF0,       /* dest = src;          P,      GXcopy,         0x3 */
+    0x0A,       /* dest &= ~src;        DPna,   GXandInverted,  0x4 */
+    0xAA,       /* dest = dest;         D,      GXnoop,         0x5 */
+    0x5A,       /* dest = ^src;         DPx,    GXxor,          0x6 */
+    0xFA,       /* dest |= src;         DPo,    GXor,           0x7 */
+    0x05,       /* dest = ~src & ~dest; DPon,   GXnor,          0x8 */
+    0xA5,       /* dest ^= ~src ;       DPxn,   GXequiv,        0x9 */
+    0x55,       /* dest = ~dest;        Dn,     GXInvert,       0xA */
+    0xF5,       /* dest = src|~dest ;   PDno,   GXorReverse,    0xB */
+    0x0F,       /* dest = ~src;         Pn,     GXcopyInverted, 0xC */
+    0xAF,       /* dest |= ~src;        DPno,   GXorInverted,   0xD */
+    0x5F,       /* dest = ~src|~dest;   DPan,   GXnand,         0xE */
+    0xFF,       /* dest = 0xFF;         1,      GXset,          0xF */
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,34)
+static const unsigned char myrops[] = {
+   	3, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
+   };
+#endif
+
+/* 300 series */
+#if 0
+static void
+XGI300Sync(void)
+{
+	XGI300Idle
+}
+#endif
+static void
+XGI310Sync(void)
+{
+	XGI310Idle
+}
+#if 0
+static void
+XGI300SetupForScreenToScreenCopy(int xdir, int ydir, int rop,
+                                unsigned int planemask, int trans_color)
+{
+	XGI300SetupDSTColorDepth(xgi_video_info.DstColor);
+	XGI300SetupSRCPitch(xgi_video_info.video_linelength)
+	XGI300SetupDSTRect(xgi_video_info.video_linelength, 0xFFF)
+
+	if(trans_color != -1) {
+		XGI300SetupROP(0x0A)
+		XGI300SetupSRCTrans(trans_color)
+		XGI300SetupCMDFlag(TRANSPARENT_BITBLT)
+	} else {
+	        XGI300SetupROP(XGIALUConv[rop])
+	}
+	if(xdir > 0) {
+		XGI300SetupCMDFlag(X_INC)
+	}
+	if(ydir > 0) {
+		XGI300SetupCMDFlag(Y_INC)
+	}
+}
+
+static void
+XGI300SubsequentScreenToScreenCopy(int src_x, int src_y, int dst_x, int dst_y,
+                                int width, int height)
+{
+	long srcbase, dstbase;
+
+	srcbase = dstbase = 0;
+	if (src_y >= 2048) {
+		srcbase = xgi_video_info.video_linelength * src_y;
+		src_y = 0;
+	}
+	if (dst_y >= 2048) {
+		dstbase = xgi_video_info.video_linelength * dst_y;
+		dst_y = 0;
+	}
+
+	XGI300SetupSRCBase(srcbase);
+	XGI300SetupDSTBase(dstbase);
+
+	if(!(xgi_video_info.CommandReg & X_INC))  {
+		src_x += width-1;
+		dst_x += width-1;
+	}
+	if(!(xgi_video_info.CommandReg & Y_INC))  {
+		src_y += height-1;
+		dst_y += height-1;
+	}
+	XGI300SetupRect(width, height)
+	XGI300SetupSRCXY(src_x, src_y)
+	XGI300SetupDSTXY(dst_x, dst_y)
+	XGI300DoCMD
+}
+
+static void
+XGI300SetupForSolidFill(int color, int rop, unsigned int planemask)
+{
+	XGI300SetupPATFG(color)
+	XGI300SetupDSTRect(xgi_video_info.video_linelength, 0xFFF)
+	XGI300SetupDSTColorDepth(xgi_video_info.DstColor);
+	XGI300SetupROP(XGIPatALUConv[rop])
+	XGI300SetupCMDFlag(PATFG)
+}
+
+static void
+XGI300SubsequentSolidFillRect(int x, int y, int w, int h)
+{
+	long dstbase;
+
+	dstbase = 0;
+	if(y >= 2048) {
+		dstbase = xgi_video_info.video_linelength * y;
+		y = 0;
+	}
+	XGI300SetupDSTBase(dstbase)
+	XGI300SetupDSTXY(x,y)
+	XGI300SetupRect(w,h)
+	XGI300SetupCMDFlag(X_INC | Y_INC | BITBLT)
+	XGI300DoCMD
+}
+#endif
+/* 310/325 series ------------------------------------------------ */
+
+static void
+XGI310SetupForScreenToScreenCopy(int xdir, int ydir, int rop,
+                                unsigned int planemask, int trans_color)
+{
+	XGI310SetupDSTColorDepth(xgi_video_info.DstColor);
+	XGI310SetupSRCPitch(xgi_video_info.video_linelength)
+	XGI310SetupDSTRect(xgi_video_info.video_linelength, 0xFFF)
+	if (trans_color != -1) {
+		XGI310SetupROP(0x0A)
+		XGI310SetupSRCTrans(trans_color)
+		XGI310SetupCMDFlag(TRANSPARENT_BITBLT)
+	} else {
+	        XGI310SetupROP(XGIALUConv[rop])
+		/* Set command - not needed, both 0 */
+		/* XGISetupCMDFlag(BITBLT | SRCVIDEO) */
+	}
+	XGI310SetupCMDFlag(xgi_video_info.XGI310_AccelDepth)
+	/* TW: The 310/325 series is smart enough to know the direction */
+}
+
+static void
+XGI310SubsequentScreenToScreenCopy(int src_x, int src_y, int dst_x, int dst_y,
+                                int width, int height)
+{
+	long srcbase, dstbase;
+	int mymin, mymax;
+
+	srcbase = dstbase = 0;
+	mymin = min(src_y, dst_y);
+	mymax = max(src_y, dst_y);
+
+	/* Although the chip knows the direction to use
+	 * if the source and destination areas overlap,
+	 * that logic fails if we fiddle with the bitmap
+	 * addresses. Therefore, we check if the source
+	 * and destination blitting areas overlap and
+	 * adapt the bitmap addresses synchronously
+	 * if the coordinates exceed the valid range.
+	 * The the areas do not overlap, we do our
+	 * normal check.
+	 */
+	if((mymax - mymin) < height) {
+	   if((src_y >= 2048) || (dst_y >= 2048)) {
+	      srcbase = xgi_video_info.video_linelength * mymin;
+	      dstbase = xgi_video_info.video_linelength * mymin;
+	      src_y -= mymin;
+	      dst_y -= mymin;
+	   }
+	} else {
+	   if(src_y >= 2048) {
+	      srcbase = xgi_video_info.video_linelength * src_y;
+	      src_y = 0;
+	   }
+	   if(dst_y >= 2048) {
+	      dstbase = xgi_video_info.video_linelength * dst_y;
+	      dst_y = 0;
+	   }
+	}
+
+	XGI310SetupSRCBase(srcbase);
+	XGI310SetupDSTBase(dstbase);
+	XGI310SetupRect(width, height)
+	XGI310SetupSRCXY(src_x, src_y)
+	XGI310SetupDSTXY(dst_x, dst_y)
+	XGI310DoCMD
+}
+
+static void
+XGI310SetupForSolidFill(int color, int rop, unsigned int planemask)
+{
+	XGI310SetupPATFG(color)
+	XGI310SetupDSTRect(xgi_video_info.video_linelength, 0xFFF)
+	XGI310SetupDSTColorDepth(xgi_video_info.DstColor);
+	XGI310SetupROP(XGIPatALUConv[rop])
+	XGI310SetupCMDFlag(PATFG | xgi_video_info.XGI310_AccelDepth)
+}
+
+static void
+XGI310SubsequentSolidFillRect(int x, int y, int w, int h)
+{
+	long dstbase;
+
+	dstbase = 0;
+	if(y >= 2048) {
+		dstbase = xgi_video_info.video_linelength * y;
+		y = 0;
+	}
+	XGI310SetupDSTBase(dstbase)
+	XGI310SetupDSTXY(x,y)
+	XGI310SetupRect(w,h)
+	XGI310SetupCMDFlag(BITBLT)
+	XGI310DoCMD
+}
+
+/* --------------------------------------------------------------------- */
+
+/* The exported routines */
+
+int XGIfb_initaccel(void)
+{
+#ifdef XGIFB_USE_SPINLOCKS
+    spin_lock_init(&xgi_video_info.lockaccel);
+#endif
+    return(0);
+}
+
+void XGIfb_syncaccel(void)
+{
+
+    XGI310Sync();
+
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,34)  /* --- KERNEL 2.5.34 and later --- */
+
+int fbcon_XGI_sync(struct fb_info *info)
+{
+    if(!XGIfb_accel) return 0;
+    CRITFLAGS
+
+    XGI310Sync();
+
+   CRITEND
+   return 0;
+}
+
+void fbcon_XGI_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
+{
+   int col=0;
+   CRITFLAGS
+
+
+   if(!rect->width || !rect->height)
+   	return;
+
+   if(!XGIfb_accel) {
+	cfb_fillrect(info, rect);
+	return;
+   }
+
+   switch(info->var.bits_per_pixel) {
+		case 8: col = rect->color;
+			break;
+		case 16: col = ((u32 *)(info->pseudo_palette))[rect->color];
+			 break;
+		case 32: col = ((u32 *)(info->pseudo_palette))[rect->color];
+			 break;
+	}
+
+
+	   CRITBEGIN
+	   XGI310SetupForSolidFill(col, myrops[rect->rop], 0);
+	   XGI310SubsequentSolidFillRect(rect->dx, rect->dy, rect->width, rect->height);
+	   CRITEND
+	   XGI310Sync();
+
+
+}
+
+void fbcon_XGI_copyarea(struct fb_info *info, const struct fb_copyarea *area)
+{
+   int xdir, ydir;
+   CRITFLAGS
+
+
+   if(!XGIfb_accel) {
+   	cfb_copyarea(info, area);
+	return;
+   }
+
+   if(!area->width || !area->height)
+   	return;
+
+   if(area->sx < area->dx) xdir = 0;
+   else                    xdir = 1;
+   if(area->sy < area->dy) ydir = 0;
+   else                    ydir = 1;
+
+      CRITBEGIN
+      XGI310SetupForScreenToScreenCopy(xdir, ydir, 3, 0, -1);
+      XGI310SubsequentScreenToScreenCopy(area->sx, area->sy, area->dx, area->dy, area->width, area->height);
+      CRITEND
+      XGI310Sync();
+
+}
+
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,33)  /* ------ KERNEL <2.5.34 ------ */
+
+void fbcon_XGI_bmove(struct display *p, int srcy, int srcx,
+			    int dsty, int dstx, int height, int width)
+{
+        int xdir, ydir;
+	CRITFLAGS
+
+	if(!xgi_video_info.accel) {
+	    switch(xgi_video_info.video_bpp) {
+	    case 8:
+#ifdef FBCON_HAS_CFB8
+	       fbcon_cfb8_bmove(p, srcy, srcx, dsty, dstx, height, width);
+#endif
+	       break;
+	    case 16:
+#ifdef FBCON_HAS_CFB16
+	       fbcon_cfb16_bmove(p, srcy, srcx, dsty, dstx, height, width);
+#endif
+	       break;
+	    case 32:
+#ifdef FBCON_HAS_CFB32
+	       fbcon_cfb32_bmove(p, srcy, srcx, dsty, dstx, height, width);
+#endif
+	       break;
+            }
+	    return;
+	}
+
+	srcx *= fontwidth(p);
+	srcy *= fontheight(p);
+	dstx *= fontwidth(p);
+	dsty *= fontheight(p);
+	width *= fontwidth(p);
+	height *= fontheight(p);
+
+	if(srcx < dstx) xdir = 0;
+	else            xdir = 1;
+	if(srcy < dsty) ydir = 0;
+	else            ydir = 1;
+
+
+	   CRITBEGIN
+	   XGI310SetupForScreenToScreenCopy(xdir, ydir, 3, 0, -1);
+	   XGI310SubsequentScreenToScreenCopy(srcx, srcy, dstx, dsty, width, height);
+	   CRITEND
+	   XGI310Sync();
+#if 0
+	   printk(KERN_INFO "XGI_bmove sx %d sy %d dx %d dy %d w %d h %d\n",
+		srcx, srcy, dstx, dsty, width, height);
+#endif
+
+}
+
+
+static void fbcon_XGI_clear(struct vc_data *conp, struct display *p,
+			int srcy, int srcx, int height, int width, int color)
+{
+	CRITFLAGS
+
+	srcx *= fontwidth(p);
+	srcy *= fontheight(p);
+	width *= fontwidth(p);
+	height *= fontheight(p);
+
+
+	   CRITBEGIN
+	   XGI310SetupForSolidFill(color, 3, 0);
+	   XGI310SubsequentSolidFillRect(srcx, srcy, width, height);
+	   CRITEND
+	   XGI310Sync();
+
+}
+
+void fbcon_XGI_clear8(struct vc_data *conp, struct display *p,
+			int srcy, int srcx, int height, int width)
+{
+	u32 bgx;
+
+	if(!xgi_video_info.accel) {
+#ifdef FBCON_HAS_CFB8
+	    fbcon_cfb8_clear(conp, p, srcy, srcx, height, width);
+#endif
+	    return;
+	}
+
+	bgx = attr_bgcol_ec(p, conp);
+	fbcon_XGI_clear(conp, p, srcy, srcx, height, width, bgx);
+}
+
+void fbcon_XGI_clear16(struct vc_data *conp, struct display *p,
+			int srcy, int srcx, int height, int width)
+{
+	u32 bgx;
+	if(!xgi_video_info.accel) {
+#ifdef FBCON_HAS_CFB16
+	    fbcon_cfb16_clear(conp, p, srcy, srcx, height, width);
+#endif
+	    return;
+	}
+
+	bgx = ((u_int16_t*)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+	fbcon_XGI_clear(conp, p, srcy, srcx, height, width, bgx);
+}
+
+void fbcon_XGI_clear32(struct vc_data *conp, struct display *p,
+			int srcy, int srcx, int height, int width)
+{
+	u32 bgx;
+
+	if(!xgi_video_info.accel) {
+#ifdef FBCON_HAS_CFB32
+	    fbcon_cfb32_clear(conp, p, srcy, srcx, height, width);
+#endif
+	    return;
+	}
+
+	bgx = ((u_int32_t*)p->dispsw_data)[attr_bgcol_ec(p, conp)];
+	fbcon_XGI_clear(conp, p, srcy, srcx, height, width, bgx);
+}
+
+void fbcon_XGI_revc(struct display *p, int srcx, int srcy)
+{
+	CRITFLAGS
+
+	if(!xgi_video_info.accel) {
+	    switch(xgi_video_info.video_bpp) {
+	    case 16:
+#ifdef FBCON_HAS_CFB16
+	       fbcon_cfb16_revc(p, srcx, srcy);
+#endif
+	       break;
+	    case 32:
+#ifdef FBCON_HAS_CFB32
+	       fbcon_cfb32_revc(p, srcx, srcy);
+#endif
+	       break;
+            }
+	    return;
+	}
+
+	srcx *= fontwidth(p);
+	srcy *= fontheight(p);
+
+
+	   CRITBEGIN
+	   XGI310SetupForSolidFill(0, 0x0a, 0);
+	   XGI310SubsequentSolidFillRect(srcx, srcy, fontwidth(p), fontheight(p));
+	   CRITEND
+	   XGI310Sync();
+
+}
+
+#ifdef FBCON_HAS_CFB8
+struct display_switch fbcon_XGI8 = {
+	setup:			fbcon_cfb8_setup,
+	bmove:			fbcon_XGI_bmove,
+	clear:			fbcon_XGI_clear8,
+	putc:			fbcon_cfb8_putc,
+	putcs:			fbcon_cfb8_putcs,
+	revc:			fbcon_cfb8_revc,
+	clear_margins:		fbcon_cfb8_clear_margins,
+	fontwidthmask:		FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
+};
+#endif
+#ifdef FBCON_HAS_CFB16
+struct display_switch fbcon_XGI16 = {
+	setup:			fbcon_cfb16_setup,
+	bmove:			fbcon_XGI_bmove,
+	clear:			fbcon_XGI_clear16,
+	putc:			fbcon_cfb16_putc,
+	putcs:			fbcon_cfb16_putcs,
+	revc:			fbcon_XGI_revc,
+	clear_margins:		fbcon_cfb16_clear_margins,
+	fontwidthmask:		FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
+};
+#endif
+#ifdef FBCON_HAS_CFB32
+struct display_switch fbcon_XGI32 = {
+	setup:			fbcon_cfb32_setup,
+	bmove:			fbcon_XGI_bmove,
+	clear:			fbcon_XGI_clear32,
+	putc:			fbcon_cfb32_putc,
+	putcs:			fbcon_cfb32_putcs,
+	revc:			fbcon_XGI_revc,
+	clear_margins:		fbcon_cfb32_clear_margins,
+	fontwidthmask:		FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
+};
+#endif
+
+#endif /* KERNEL VERSION */
+
+
--- /dev/null
+++ b/drivers/staging/xgifb/XGI_accel.h
@@ -0,0 +1,511 @@
+/*
+ * XGI 300/630/730/540/315/550/650/740 frame buffer driver
+ * for Linux kernels 2.4.x and 2.5.x
+ *
+ * 2D acceleration part
+ *
+ * Based on the X driver's XGI300_accel.h which is
+ *     Copyright Xavier Ducoin <x.ducoin@lectra.com>
+ *     Copyright 2002 by Thomas Winischhofer, Vienna, Austria
+ * and XGI310_accel.h which is
+ *     Copyright 2002 by Thomas Winischhofer, Vienna, Austria
+ *
+ * Author:   Thomas Winischhofer <thomas@winischhofer.net>:
+ *			(see http://www.winischhofer.net/
+ *			for more information and updates)
+ */
+
+#ifndef _XGIFB_ACCEL_H
+#define _XGIFB_ACCEL_H
+
+/* Guard accelerator accesses with spin_lock_irqsave? Works well without. */
+#undef XGIFB_USE_SPINLOCKS
+
+#ifdef XGIFB_USE_SPINLOCKS
+#include <linux/spinlock.h>
+#define CRITBEGIN  spin_lock_irqsave(&xgi_video_info.lockaccel), critflags);
+#define CRITEND	   spin_unlock_irqrestore(&xgi_video_info.lockaccel), critflags);
+#define CRITFLAGS  unsigned long critflags;
+#else
+#define CRITBEGIN
+#define CRITEND
+#define CRITFLAGS
+#endif
+
+/* Definitions for the XGI engine communication. */
+
+#define PATREGSIZE      384  /* Pattern register size. 384 bytes @ 0x8300 */
+#define BR(x)   (0x8200 | (x) << 2)
+#define PBR(x)  (0x8300 | (x) << 2)
+
+/* XGI300 engine commands */
+#define BITBLT                  0x00000000  /* Blit */
+#define COLOREXP                0x00000001  /* Color expand */
+#define ENCOLOREXP              0x00000002  /* Enhanced color expand */
+#define MULTIPLE_SCANLINE       0x00000003  /* ? */
+#define LINE                    0x00000004  /* Draw line */
+#define TRAPAZOID_FILL          0x00000005  /* Fill trapezoid */
+#define TRANSPARENT_BITBLT      0x00000006  /* Transparent Blit */
+
+/* Additional engine commands for 310/325 */
+#define ALPHA_BLEND		0x00000007  /* Alpha blend ? */
+#define A3D_FUNCTION		0x00000008  /* 3D command ? */
+#define	CLEAR_Z_BUFFER		0x00000009  /* ? */
+#define GRADIENT_FILL		0x0000000A  /* Gradient fill */
+#define STRETCH_BITBLT		0x0000000B  /* Stretched Blit */
+
+/* source select */
+#define SRCVIDEO                0x00000000  /* source is video RAM */
+#define SRCSYSTEM               0x00000010  /* source is system memory */
+#define SRCCPUBLITBUF           SRCSYSTEM   /* source is CPU-driven BitBuffer (for color expand) */
+#define SRCAGP                  0x00000020  /* source is AGP memory (?) */
+
+/* Pattern flags */
+#define PATFG                   0x00000000  /* foreground color */
+#define PATPATREG               0x00000040  /* pattern in pattern buffer (0x8300) */
+#define PATMONO                 0x00000080  /* mono pattern */
+
+/* blitting direction (300 series only) */
+#define X_INC                   0x00010000
+#define X_DEC                   0x00000000
+#define Y_INC                   0x00020000
+#define Y_DEC                   0x00000000
+
+/* Clipping flags */
+#define NOCLIP                  0x00000000
+#define NOMERGECLIP             0x04000000
+#define CLIPENABLE              0x00040000
+#define CLIPWITHOUTMERGE        0x04040000
+
+/* Transparency */
+#define OPAQUE                  0x00000000
+#define TRANSPARENT             0x00100000
+
+/* ? */
+#define DSTAGP                  0x02000000
+#define DSTVIDEO                0x02000000
+
+/* Line */
+#define LINE_STYLE              0x00800000
+#define NO_RESET_COUNTER        0x00400000
+#define NO_LAST_PIXEL           0x00200000
+
+/* Subfunctions for Color/Enhanced Color Expansion (310/325 only) */
+#define COLOR_TO_MONO		0x00100000
+#define AA_TEXT			0x00200000
+
+/* Some general registers for 310/325 series */
+#define SRC_ADDR		0x8200
+#define SRC_PITCH		0x8204
+#define AGP_BASE		0x8206 /* color-depth dependent value */
+#define SRC_Y			0x8208
+#define SRC_X			0x820A
+#define DST_Y			0x820C
+#define DST_X			0x820E
+#define DST_ADDR		0x8210
+#define DST_PITCH		0x8214
+#define DST_HEIGHT		0x8216
+#define RECT_WIDTH		0x8218
+#define RECT_HEIGHT		0x821A
+#define PAT_FGCOLOR		0x821C
+#define PAT_BGCOLOR		0x8220
+#define SRC_FGCOLOR		0x8224
+#define SRC_BGCOLOR		0x8228
+#define MONO_MASK		0x822C
+#define LEFT_CLIP		0x8234
+#define TOP_CLIP		0x8236
+#define RIGHT_CLIP		0x8238
+#define BOTTOM_CLIP		0x823A
+#define COMMAND_READY		0x823C
+#define FIRE_TRIGGER      	0x8240
+
+#define PATTERN_REG		0x8300  /* 384 bytes pattern buffer */
+
+/* Line registers */
+#define LINE_X0			SRC_Y
+#define LINE_X1			DST_Y
+#define LINE_Y0			SRC_X
+#define LINE_Y1			DST_X
+#define LINE_COUNT		RECT_WIDTH
+#define LINE_STYLE_PERIOD	RECT_HEIGHT
+#define LINE_STYLE_0		MONO_MASK
+#define LINE_STYLE_1		0x8230
+#define LINE_XN			PATTERN_REG
+#define LINE_YN			PATTERN_REG+2
+
+/* Transparent bitblit registers */
+#define TRANS_DST_KEY_HIGH	PAT_FGCOLOR
+#define TRANS_DST_KEY_LOW	PAT_BGCOLOR
+#define TRANS_SRC_KEY_HIGH	SRC_FGCOLOR
+#define TRANS_SRC_KEY_LOW	SRC_BGCOLOR
+
+/* Queue */
+#define Q_BASE_ADDR		0x85C0  /* Base address of software queue (?) */
+#define Q_WRITE_PTR		0x85C4  /* Current write pointer (?) */
+#define Q_READ_PTR		0x85C8  /* Current read pointer (?) */
+#define Q_STATUS		0x85CC  /* queue status */
+
+
+#define MMIO_IN8(base, offset) \
+	*(volatile u8 *)(((u8*)(base)) + (offset))
+#define MMIO_IN16(base, offset) \
+	*(volatile u16 *)(void *)(((u8*)(base)) + (offset))
+#define MMIO_IN32(base, offset) \
+	*(volatile u32 *)(void *)(((u8*)(base)) + (offset))
+#define MMIO_OUT8(base, offset, val) \
+	*(volatile u8 *)(((u8*)(base)) + (offset)) = (val)
+#define MMIO_OUT16(base, offset, val) \
+	*(volatile u16 *)(void *)(((u8*)(base)) + (offset)) = (val)
+#define MMIO_OUT32(base, offset, val) \
+	*(volatile u32 *)(void *)(((u8*)(base)) + (offset)) = (val)
+
+
+
+/* ------------- XGI 300 series -------------- */
+
+/* Macros to do useful things with the XGI BitBLT engine */
+
+/* BR(16) (0x8420):
+
+   bit 31 2D engine: 1 is idle,
+   bit 30 3D engine: 1 is idle,
+   bit 29 Command queue: 1 is empty
+
+   bits 28:24: Current CPU driven BitBlt buffer stage bit[4:0]
+
+   bits 15:0:  Current command queue length
+
+*/
+
+/* TW: BR(16)+2 = 0x8242 */
+
+int     xgiCmdQueLen;
+
+#define XGI300Idle \
+  { \
+  while( (MMIO_IN16(xgi_video_info.mmio_vbase, BR(16)+2) & 0xE000) != 0xE000){}; \
+  while( (MMIO_IN16(xgi_video_info.mmio_vbase, BR(16)+2) & 0xE000) != 0xE000){}; \
+  while( (MMIO_IN16(xgi_video_info.mmio_vbase, BR(16)+2) & 0xE000) != 0xE000){}; \
+  xgiCmdQueLen=MMIO_IN16(xgi_video_info.mmio_vbase, 0x8240); \
+  }
+/* TW: (do three times, because 2D engine seems quite unsure about whether or not it's idle) */
+
+#define XGI300SetupSRCBase(base) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(0), base);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupSRCPitch(pitch) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT16(xgi_video_info.mmio_vbase, BR(1), pitch);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupSRCXY(x,y) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(2), (x)<<16 | (y) );\
+                xgiCmdQueLen --;
+
+#define XGI300SetupDSTBase(base) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(4), base);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupDSTXY(x,y) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(3), (x)<<16 | (y) );\
+                xgiCmdQueLen --;
+
+#define XGI300SetupDSTRect(x,y) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(5), (y)<<16 | (x) );\
+                xgiCmdQueLen --;
+
+#define XGI300SetupDSTColorDepth(bpp) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT16(xgi_video_info.mmio_vbase, BR(1)+2, bpp);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupRect(w,h) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(6), (h)<<16 | (w) );\
+                xgiCmdQueLen --;
+
+#define XGI300SetupPATFG(color) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(7), color);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupPATBG(color) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(8), color);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupSRCFG(color) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(9), color);\
+                xgiCmdQueLen --;
+
+#define XGI300SetupSRCBG(color) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(10), color);\
+                xgiCmdQueLen --;
+
+/* 0x8224 src colorkey high */
+/* 0x8228 src colorkey low */
+/* 0x821c dest colorkey high */
+/* 0x8220 dest colorkey low */
+#define XGI300SetupSRCTrans(color) \
+                if (xgiCmdQueLen <= 1)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, 0x8224, color);\
+		MMIO_OUT32(xgi_video_info.mmio_vbase, 0x8228, color);\
+		xgiCmdQueLen -= 2;
+
+#define XGI300SetupDSTTrans(color) \
+		if (xgiCmdQueLen <= 1)  XGI300Idle;\
+		MMIO_OUT32(xgi_video_info.mmio_vbase, 0x821C, color); \
+		MMIO_OUT32(xgi_video_info.mmio_vbase, 0x8220, color); \
+                xgiCmdQueLen -= 2;
+
+#define XGI300SetupMONOPAT(p0,p1) \
+                if (xgiCmdQueLen <= 1)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(11), p0);\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(12), p1);\
+                xgiCmdQueLen -= 2;
+
+#define XGI300SetupClipLT(left,top) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(13), ((left) & 0xFFFF) | (top)<<16 );\
+                xgiCmdQueLen--;
+
+#define XGI300SetupClipRB(right,bottom) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(14), ((right) & 0xFFFF) | (bottom)<<16 );\
+                xgiCmdQueLen--;
+
+/* General */
+#define XGI300SetupROP(rop) \
+                xgi_video_info.CommandReg = (rop) << 8;
+
+#define XGI300SetupCMDFlag(flags) \
+                xgi_video_info.CommandReg |= (flags);
+
+#define XGI300DoCMD \
+                if (xgiCmdQueLen <= 1)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(15), xgi_video_info.CommandReg); \
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(16), 0);\
+                xgiCmdQueLen -= 2;
+
+/* Line */
+#define XGI300SetupX0Y0(x,y) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(2), (y)<<16 | (x) );\
+                xgiCmdQueLen--;
+
+#define XGI300SetupX1Y1(x,y) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(3), (y)<<16 | (x) );\
+                xgiCmdQueLen--;
+
+#define XGI300SetupLineCount(c) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT16(xgi_video_info.mmio_vbase, BR(6), c);\
+                xgiCmdQueLen--;
+
+#define XGI300SetupStylePeriod(p) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT16(xgi_video_info.mmio_vbase, BR(6)+2, p);\
+                xgiCmdQueLen--;
+
+#define XGI300SetupStyleLow(ls) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(11), ls);\
+                xgiCmdQueLen--;
+
+#define XGI300SetupStyleHigh(ls) \
+                if (xgiCmdQueLen <= 0)  XGI300Idle;\
+                MMIO_OUT32(xgi_video_info.mmio_vbase, BR(12), ls);\
+                xgiCmdQueLen--;
+
+
+
+/* ----------- XGI 310/325 series --------------- */
+
+/* Q_STATUS:
+   bit 31 = 1: All engines idle and all queues empty
+   bit 30 = 1: Hardware Queue (=HW CQ, 2D queue, 3D queue) empty
+   bit 29 = 1: 2D engine is idle
+   bit 28 = 1: 3D engine is idle
+   bit 27 = 1: HW command queue empty
+   bit 26 = 1: 2D queue empty
+   bit 25 = 1: 3D queue empty
+   bit 24 = 1: SW command queue empty
+   bits 23:16: 2D counter 3
+   bits 15:8:  2D counter 2
+   bits 7:0:   2D counter 1
+
+   Where is the command queue length (current amount of commands the queue
+   can accept) on the 310/325 series? (The current implementation is taken
+   from 300 series and certainly wrong...)
+*/
+
+/* TW: FIXME: xgiCmdQueLen is... where....? */
+#define XGI310Idle \
+  { \
+  while( (MMIO_IN16(xgi_video_info.mmio_vbase, Q_STATUS+2) & 0x8000) != 0x8000){}; \
+  while( (MMIO_IN16(xgi_video_info.mmio_vbase, Q_STATUS+2) & 0x8000) != 0x8000){}; \
+  xgiCmdQueLen=MMIO_IN16(xgi_video_info.mmio_vbase, Q_STATUS); \
+  }
+
+#define XGI310SetupSRCBase(base) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, SRC_ADDR, base);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupSRCPitch(pitch) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT16(xgi_video_info.mmio_vbase, SRC_PITCH, pitch);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupSRCXY(x,y) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, SRC_Y, (x)<<16 | (y) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupDSTBase(base) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, DST_ADDR, base);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupDSTXY(x,y) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, DST_Y, (x)<<16 | (y) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupDSTRect(x,y) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, DST_PITCH, (y)<<16 | (x) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupDSTColorDepth(bpp) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT16(xgi_video_info.mmio_vbase, AGP_BASE, bpp);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupRect(w,h) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, RECT_WIDTH, (h)<<16 | (w) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupPATFG(color) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, PAT_FGCOLOR, color);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupPATBG(color) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, PAT_BGCOLOR, color);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupSRCFG(color) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, SRC_FGCOLOR, color);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupSRCBG(color) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, SRC_BGCOLOR, color);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupSRCTrans(color) \
+      if (xgiCmdQueLen <= 1)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, TRANS_SRC_KEY_HIGH, color);\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, TRANS_SRC_KEY_LOW, color);\
+      xgiCmdQueLen -= 2;
+
+#define XGI310SetupDSTTrans(color) \
+      if (xgiCmdQueLen <= 1)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, TRANS_DST_KEY_HIGH, color); \
+      MMIO_OUT32(xgi_video_info.mmio_vbase, TRANS_DST_KEY_LOW, color); \
+      xgiCmdQueLen -= 2;
+
+#define XGI310SetupMONOPAT(p0,p1) \
+      if (xgiCmdQueLen <= 1)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, MONO_MASK, p0);\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, MONO_MASK+4, p1);\
+      xgiCmdQueLen -= 2;
+
+#define XGI310SetupClipLT(left,top) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, LEFT_CLIP, ((left) & 0xFFFF) | (top)<<16 );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupClipRB(right,bottom) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, RIGHT_CLIP, ((right) & 0xFFFF) | (bottom)<<16 );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupROP(rop) \
+      xgi_video_info.CommandReg = (rop) << 8;
+
+#define XGI310SetupCMDFlag(flags) \
+      xgi_video_info.CommandReg |= (flags);
+
+#define XGI310DoCMD \
+      if (xgiCmdQueLen <= 1)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, COMMAND_READY, xgi_video_info.CommandReg); \
+      MMIO_OUT32(xgi_video_info.mmio_vbase, FIRE_TRIGGER, 0); \
+      xgiCmdQueLen -= 2;
+
+#define XGI310SetupX0Y0(x,y) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, LINE_X0, (y)<<16 | (x) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupX1Y1(x,y) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, LINE_X1, (y)<<16 | (x) );\
+      xgiCmdQueLen--;
+
+#define XGI310SetupLineCount(c) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT16(xgi_video_info.mmio_vbase, LINE_COUNT, c);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupStylePeriod(p) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT16(xgi_video_info.mmio_vbase, LINE_STYLE_PERIOD, p);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupStyleLow(ls) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, LINE_STYLE_0, ls);\
+      xgiCmdQueLen--;
+
+#define XGI310SetupStyleHigh(ls) \
+      if (xgiCmdQueLen <= 0)  XGI310Idle;\
+      MMIO_OUT32(xgi_video_info.mmio_vbase, LINE_STYLE_1, ls);\
+      xgiCmdQueLen--;
+
+int  XGIfb_initaccel(void);
+void XGIfb_syncaccel(void);
+
+extern struct video_info xgi_video_info;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,33)
+void fbcon_XGI_bmove(struct display *p, int srcy, int srcx, int dsty,
+                     int dstx, int height, int width);
+void fbcon_XGI_revc(struct display *p, int srcy, int srcx);
+void fbcon_XGI_clear8(struct vc_data *conp, struct display *p, int srcy,
+                      int srcx, int height, int width);
+void fbcon_XGI_clear16(struct vc_data *conp, struct display *p, int srcy,
+                       int srcx, int height, int width);
+void fbcon_XGI_clear32(struct vc_data *conp, struct display *p, int srcy,
+                       int srcx, int height, int width);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,34)
+extern int XGIfb_accel;
+void fbcon_XGI_fillrect(struct fb_info *info, const struct fb_fillrect *rect);
+void fbcon_XGI_copyarea(struct fb_info *info, const struct fb_copyarea *area);
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/staging/xgifb/XGI_main.h
@@ -0,0 +1,1023 @@
+#ifndef _XGIFB_MAIN
+#define _XGIFB_MAIN
+
+
+/* ------------------- Constant Definitions ------------------------- */
+
+
+#include "XGIfb.h"
+#include "vb_struct.h"
+#include "vb_def.h"
+
+//#define LINUXBIOS   /* turn this on when compiling for LINUXBIOS */
+#define AGPOFF     /* default is turn off AGP */
+
+#define XGIFAIL(x) do { printk(x "\n"); return -EINVAL; } while(0)
+
+#define VER_MAJOR                 0
+#define VER_MINOR                 8
+#define VER_LEVEL                 1
+
+#define DRIVER_DESC  "XGI Volari Frame Buffer Module Version 0.8.1"
+
+#ifndef PCI_VENDOR_ID_XG
+#define PCI_VENDOR_ID_XG          0x18CA
+#endif
+
+#ifndef PCI_DEVICE_ID_XG_40
+#define PCI_DEVICE_ID_XG_40      0x040
+#endif
+#ifndef PCI_DEVICE_ID_XG_41
+#define PCI_DEVICE_ID_XG_41      0x041
+#endif
+#ifndef PCI_DEVICE_ID_XG_42
+#define PCI_DEVICE_ID_XG_42      0x042
+#endif
+#ifndef PCI_DEVICE_ID_XG_20
+#define PCI_DEVICE_ID_XG_20      0x020
+#endif
+#ifndef PCI_DEVICE_ID_XG_27
+#define PCI_DEVICE_ID_XG_27      0x027
+#endif
+
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+#define XGI_IOTYPE1 void __iomem
+#define XGI_IOTYPE2 __iomem
+#define XGIINITSTATIC static
+#else
+#define XGI_IOTYPE1 unsigned char
+#define XGI_IOTYPE2
+#define XGIINITSTATIC
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static struct pci_device_id __devinitdata xgifb_pci_table[] = {
+
+	{ PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_20, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_27, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},
+	{ PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_40, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2},
+	{ PCI_VENDOR_ID_XG, PCI_DEVICE_ID_XG_42, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 3},
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, xgifb_pci_table);
+#endif
+/* To be included in fb.h */
+#ifndef FB_ACCEL_XGI_GLAMOUR_2
+#define FB_ACCEL_XGI_GLAMOUR_2  40	/* XGI 315, 650, 740		*/
+#endif
+#ifndef FB_ACCEL_XGI_XABRE
+#define FB_ACCEL_XGI_XABRE      41	/* XGI 330 ("Xabre")		*/
+#endif
+
+#define MAX_ROM_SCAN              0x10000
+
+#define HW_CURSOR_CAP             0x80
+#define TURBO_QUEUE_CAP           0x40
+#define AGP_CMD_QUEUE_CAP         0x20
+#define VM_CMD_QUEUE_CAP          0x10
+#define MMIO_CMD_QUEUE_CAP        0x08
+
+
+
+/* For 315 series */
+
+#define COMMAND_QUEUE_AREA_SIZE   0x80000 /* 512K */
+#define COMMAND_QUEUE_THRESHOLD   0x1F
+
+
+/* TW */
+#define HW_CURSOR_AREA_SIZE_315   0x4000  /* 16K */
+#define HW_CURSOR_AREA_SIZE_300   0x1000  /* 4K */
+
+#define OH_ALLOC_SIZE             4000
+#define SENTINEL                  0x7fffffff
+
+#define SEQ_ADR                   0x14
+#define SEQ_DATA                  0x15
+#define DAC_ADR                   0x18
+#define DAC_DATA                  0x19
+#define CRTC_ADR                  0x24
+#define CRTC_DATA                 0x25
+#define DAC2_ADR                  (0x16-0x30)
+#define DAC2_DATA                 (0x17-0x30)
+#define VB_PART1_ADR              (0x04-0x30)
+#define VB_PART1_DATA             (0x05-0x30)
+#define VB_PART2_ADR              (0x10-0x30)
+#define VB_PART2_DATA             (0x11-0x30)
+#define VB_PART3_ADR              (0x12-0x30)
+#define VB_PART3_DATA             (0x13-0x30)
+#define VB_PART4_ADR              (0x14-0x30)
+#define VB_PART4_DATA             (0x15-0x30)
+
+#define XGISR			  XGI_Pr.P3c4
+#define XGICR                     XGI_Pr.P3d4
+#define XGIDACA                   XGI_Pr.P3c8
+#define XGIDACD                   XGI_Pr.P3c9
+#define XGIPART1                  XGI_Pr.Part1Port
+#define XGIPART2                  XGI_Pr.Part2Port
+#define XGIPART3                  XGI_Pr.Part3Port
+#define XGIPART4                  XGI_Pr.Part4Port
+#define XGIPART5                  XGI_Pr.Part5Port
+#define XGIDAC2A                  XGIPART5
+#define XGIDAC2D                  (XGIPART5 + 1)
+#define XGIMISCR                  (XGI_Pr.RelIO + 0x1c)
+#define XGIINPSTAT		  (XGI_Pr.RelIO + 0x2a)
+
+#define IND_XGI_PASSWORD          0x05  /* SRs */
+#define IND_XGI_COLOR_MODE        0x06
+#define IND_XGI_RAMDAC_CONTROL    0x07
+#define IND_XGI_DRAM_SIZE         0x14
+#define IND_XGI_SCRATCH_REG_16    0x16
+#define IND_XGI_SCRATCH_REG_17    0x17
+#define IND_XGI_SCRATCH_REG_1A    0x1A
+#define IND_XGI_MODULE_ENABLE     0x1E
+#define IND_XGI_PCI_ADDRESS_SET   0x20
+#define IND_XGI_TURBOQUEUE_ADR    0x26
+#define IND_XGI_TURBOQUEUE_SET    0x27
+#define IND_XGI_POWER_ON_TRAP     0x38
+#define IND_XGI_POWER_ON_TRAP2    0x39
+#define IND_XGI_CMDQUEUE_SET      0x26
+#define IND_XGI_CMDQUEUE_THRESHOLD  0x27
+
+#define IND_XGI_SCRATCH_REG_CR30  0x30  /* CRs */
+#define IND_XGI_SCRATCH_REG_CR31  0x31
+#define IND_XGI_SCRATCH_REG_CR32  0x32
+#define IND_XGI_SCRATCH_REG_CR33  0x33
+#define IND_XGI_LCD_PANEL         0x36
+#define IND_XGI_SCRATCH_REG_CR37  0x37
+#define IND_XGI_AGP_IO_PAD        0x48
+
+#define IND_BRI_DRAM_STATUS       0x63 /* PCI config memory size offset */
+
+#define MMIO_QUEUE_PHYBASE        0x85C0
+#define MMIO_QUEUE_WRITEPORT      0x85C4
+#define MMIO_QUEUE_READPORT       0x85C8
+
+#define IND_XGI_CRT2_WRITE_ENABLE_300 0x24
+#define IND_XGI_CRT2_WRITE_ENABLE_315 0x2F
+
+#define XGI_PASSWORD              0x86  /* SR05 */
+#define XGI_INTERLACED_MODE       0x20  /* SR06 */
+#define XGI_8BPP_COLOR_MODE       0x0
+#define XGI_15BPP_COLOR_MODE      0x1
+#define XGI_16BPP_COLOR_MODE      0x2
+#define XGI_32BPP_COLOR_MODE      0x4
+
+#define XGI_DRAM_SIZE_MASK     0xF0  /*SR14 */
+#define XGI_DRAM_SIZE_1MB      0x00
+#define XGI_DRAM_SIZE_2MB      0x01
+#define XGI_DRAM_SIZE_4MB      0x02
+#define XGI_DRAM_SIZE_8MB      0x03
+#define XGI_DRAM_SIZE_16MB     0x04
+#define XGI_DRAM_SIZE_32MB     0x05
+#define XGI_DRAM_SIZE_64MB     0x06
+#define XGI_DRAM_SIZE_128MB    0x07
+#define XGI_DRAM_SIZE_256MB    0x08
+#define XGI_DATA_BUS_MASK      0x02
+#define XGI_DATA_BUS_64        0x00
+#define XGI_DATA_BUS_128       0x01
+#define XGI_DUAL_CHANNEL_MASK  0x0C
+#define XGI_SINGLE_CHANNEL_1_RANK  	0x0
+#define XGI_SINGLE_CHANNEL_2_RANK  	0x1
+#define XGI_ASYM_DDR		  	0x02
+#define XGI_DUAL_CHANNEL_1_RANK    	0x3
+
+#define XGI550_DRAM_SIZE_MASK     0x3F  /* 550/650/740 SR14 */
+#define XGI550_DRAM_SIZE_4MB      0x00
+#define XGI550_DRAM_SIZE_8MB      0x01
+#define XGI550_DRAM_SIZE_16MB     0x03
+#define XGI550_DRAM_SIZE_24MB     0x05
+#define XGI550_DRAM_SIZE_32MB     0x07
+#define XGI550_DRAM_SIZE_64MB     0x0F
+#define XGI550_DRAM_SIZE_96MB     0x17
+#define XGI550_DRAM_SIZE_128MB    0x1F
+#define XGI550_DRAM_SIZE_256MB    0x3F
+
+#define XGI_SCRATCH_REG_1A_MASK   0x10
+
+#define XGI_ENABLE_2D             0x40  /* SR1E */
+
+#define XGI_MEM_MAP_IO_ENABLE     0x01  /* SR20 */
+#define XGI_PCI_ADDR_ENABLE       0x80
+
+#define XGI_AGP_CMDQUEUE_ENABLE   0x80  /* 315/650/740 SR26 */
+#define XGI_VRAM_CMDQUEUE_ENABLE  0x40
+#define XGI_MMIO_CMD_ENABLE       0x20
+#define XGI_CMD_QUEUE_SIZE_512k   0x00
+#define XGI_CMD_QUEUE_SIZE_1M     0x04
+#define XGI_CMD_QUEUE_SIZE_2M     0x08
+#define XGI_CMD_QUEUE_SIZE_4M     0x0C
+#define XGI_CMD_QUEUE_RESET       0x01
+#define XGI_CMD_AUTO_CORR	  0x02
+
+#define XGI_SIMULTANEOUS_VIEW_ENABLE  0x01  /* CR30 */
+#define XGI_MODE_SELECT_CRT2      0x02
+#define XGI_VB_OUTPUT_COMPOSITE   0x04
+#define XGI_VB_OUTPUT_SVIDEO      0x08
+#define XGI_VB_OUTPUT_SCART       0x10
+#define XGI_VB_OUTPUT_LCD         0x20
+#define XGI_VB_OUTPUT_CRT2        0x40
+#define XGI_VB_OUTPUT_HIVISION    0x80
+
+#define XGI_VB_OUTPUT_DISABLE     0x20  /* CR31 */
+#define XGI_DRIVER_MODE           0x40
+
+#define XGI_VB_COMPOSITE          0x01  /* CR32 */
+#define XGI_VB_SVIDEO             0x02
+#define XGI_VB_SCART              0x04
+#define XGI_VB_LCD                0x08
+#define XGI_VB_CRT2               0x10
+#define XGI_CRT1                  0x20
+#define XGI_VB_HIVISION           0x40
+#define XGI_VB_YPBPR                0x80
+#define XGI_VB_TV                 (XGI_VB_COMPOSITE | XGI_VB_SVIDEO | \
+                                   XGI_VB_SCART | XGI_VB_HIVISION|XGI_VB_YPBPR)
+
+#define XGI_EXTERNAL_CHIP_MASK    	   0x0E  /* CR37 */
+#define XGI_EXTERNAL_CHIP_XGI301           0x01  /* in CR37 << 1 ! */
+#define XGI_EXTERNAL_CHIP_LVDS             0x02  /* in CR37 << 1 ! */
+#define XGI_EXTERNAL_CHIP_TRUMPION         0x03  /* in CR37 << 1 ! */
+#define XGI_EXTERNAL_CHIP_LVDS_CHRONTEL    0x04  /* in CR37 << 1 ! */
+#define XGI_EXTERNAL_CHIP_CHRONTEL         0x05  /* in CR37 << 1 ! */
+#define XGI310_EXTERNAL_CHIP_LVDS          0x02  /* in CR37 << 1 ! */
+#define XGI310_EXTERNAL_CHIP_LVDS_CHRONTEL 0x03  /* in CR37 << 1 ! */
+
+#define XGI_AGP_2X                0x20  /* CR48 */
+
+#define BRI_DRAM_SIZE_MASK        0x70  /* PCI bridge config data */
+#define BRI_DRAM_SIZE_2MB         0x00
+#define BRI_DRAM_SIZE_4MB         0x01
+#define BRI_DRAM_SIZE_8MB         0x02
+#define BRI_DRAM_SIZE_16MB        0x03
+#define BRI_DRAM_SIZE_32MB        0x04
+#define BRI_DRAM_SIZE_64MB        0x05
+
+#define HW_DEVICE_EXTENSION	  XGI_HW_DEVICE_INFO
+#define PHW_DEVICE_EXTENSION      PXGI_HW_DEVICE_INFO
+
+#define SR_BUFFER_SIZE            5
+#define CR_BUFFER_SIZE            5
+
+/* Useful macros */
+#define inXGIREG(base)          inb(base)
+#define outXGIREG(base,val)     outb(val,base)
+#define orXGIREG(base,val)      do { \
+                                  unsigned char __Temp = inb(base); \
+                                  outXGIREG(base, __Temp | (val)); \
+                                } while (0)
+#define andXGIREG(base,val)     do { \
+                                  unsigned char __Temp = inb(base); \
+                                  outXGIREG(base, __Temp & (val)); \
+                                } while (0)
+#define inXGIIDXREG(base,idx,var)   do { \
+                                      outb(idx,base); var=inb((base)+1); \
+                                    } while (0)
+#define outXGIIDXREG(base,idx,val)  do { \
+                                      outb(idx,base); outb((val),(base)+1); \
+                                    } while (0)
+#define orXGIIDXREG(base,idx,val)   do { \
+                                      unsigned char __Temp; \
+                                      outb(idx,base);   \
+                                      __Temp = inb((base)+1)|(val); \
+                                      outXGIIDXREG(base,idx,__Temp); \
+                                    } while (0)
+#define andXGIIDXREG(base,idx,and)  do { \
+                                      unsigned char __Temp; \
+                                      outb(idx,base);   \
+                                      __Temp = inb((base)+1)&(and); \
+                                      outXGIIDXREG(base,idx,__Temp); \
+                                    } while (0)
+#define setXGIIDXREG(base,idx,and,or)   do { \
+                                          unsigned char __Temp; \
+                                          outb(idx,base);   \
+                                          __Temp = (inb((base)+1)&(and))|(or); \
+                                          outXGIIDXREG(base,idx,__Temp); \
+                                        } while (0)
+
+/* ------------------- Global Variables ----------------------------- */
+
+/* Fbcon variables */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static struct fb_info* fb_info;
+#else
+static struct fb_info XGI_fb_info;
+#endif
+
+
+static int    video_type = FB_TYPE_PACKED_PIXELS;
+
+static struct fb_var_screeninfo default_var = {
+	.xres		= 0,
+	.yres		= 0,
+	.xres_virtual	= 0,
+	.yres_virtual	= 0,
+	.xoffset	= 0,
+	.yoffset	= 0,
+	.bits_per_pixel	= 0,
+	.grayscale	= 0,
+	.red		= {0, 8, 0},
+	.green		= {0, 8, 0},
+	.blue		= {0, 8, 0},
+	.transp		= {0, 0, 0},
+	.nonstd		= 0,
+	.activate	= FB_ACTIVATE_NOW,
+	.height		= -1,
+	.width		= -1,
+	.accel_flags	= 0,
+	.pixclock	= 0,
+	.left_margin	= 0,
+	.right_margin	= 0,
+	.upper_margin	= 0,
+	.lower_margin	= 0,
+	.hsync_len	= 0,
+	.vsync_len	= 0,
+	.sync		= 0,
+	.vmode		= FB_VMODE_NONINTERLACED,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	.reserved	= {0, 0, 0, 0, 0, 0}
+#endif
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static struct fb_fix_screeninfo XGIfb_fix = {
+	.id		= "XGI",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.xpanstep	= 1,
+	.ypanstep	= 1,
+};
+static char myid[20];
+static u32 pseudo_palette[17];
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static struct display XGI_disp;
+
+static struct display_switch XGIfb_sw;
+
+static struct {
+	u16 blue, green, red, pad;
+} XGI_palette[256];
+
+static union {
+#ifdef FBCON_HAS_CFB16
+	u16 cfb16[16];
+#endif
+#ifdef FBCON_HAS_CFB32
+	u32 cfb32[16];
+#endif
+} XGI_fbcon_cmap;
+
+static int XGIfb_inverse = 0;
+#endif
+
+/* display status */
+static int XGIfb_off = 0;
+static int XGIfb_crt1off = 0;
+static int XGIfb_forcecrt1 = -1;
+static int XGIvga_enabled = 0;
+static int XGIfb_userom = 0;
+//static int XGIfb_useoem = -1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int currcon = 0;
+#endif
+
+/* global flags */
+static int XGIfb_registered;
+static int XGIfb_tvmode = 0;
+static int XGIfb_mem = 0;
+static int XGIfb_pdc = 0;
+static int enable_dstn = 0;
+static int XGIfb_ypan = -1;
+
+
+int 	   XGIfb_accel = 0;
+
+
+static int XGIfb_hwcursor_size = 0;
+static int XGIfb_CRT2_write_enable = 0;
+
+int XGIfb_crt2type  = -1;	/* TW: CRT2 type (for overriding autodetection) */
+int XGIfb_tvplug    = -1;	/* PR: Tv plug type (for overriding autodetection) */
+
+int XGIfb_queuemode = -1; 	/* TW: Use MMIO queue mode by default (310/325 series only) */
+
+unsigned char XGIfb_detectedpdc = 0;
+
+unsigned char XGIfb_detectedlcda = 0xff;
+
+
+
+
+/* TW: For ioctl XGIFB_GET_INFO */
+/* XGIfb_info XGIfbinfo; */
+
+/* TW: Hardware extension; contains data on hardware */
+HW_DEVICE_EXTENSION XGIhw_ext;
+
+/* TW: XGI private structure */
+VB_DEVICE_INFO  XGI_Pr;
+
+/* card parameters */
+static unsigned long XGIfb_mmio_size = 0;
+static u8            XGIfb_caps = 0;
+
+typedef enum _XGI_CMDTYPE {
+	MMIO_CMD = 0,
+	AGP_CMD_QUEUE,
+	VM_CMD_QUEUE,
+} XGI_CMDTYPE;
+
+#define MD_XGI300 1
+#define MD_XGI315 2
+
+/* mode table */
+/* NOT const - will be patched for 1280x960 mode number chaos reasons */
+struct _XGIbios_mode {
+	char name[15];
+	u8 mode_no;
+	u16 vesa_mode_no_1;  /* "XGI defined" VESA mode number */
+	u16 vesa_mode_no_2;  /* Real VESA mode numbers */
+	u16 xres;
+	u16 yres;
+	u16 bpp;
+	u16 rate_idx;
+	u16 cols;
+	u16 rows;
+	u8  chipset;
+} XGIbios_mode[] = {
+#define MODE_INDEX_NONE           0  /* TW: index for mode=none */
+	{"none",         0xFF, 0x0000, 0x0000,    0,    0,  0, 0,   0,  0, MD_XGI300|MD_XGI315},  /* TW: for mode "none" */
+	{"320x240x16",   0x56, 0x0000, 0x0000,  320,  240, 16, 1,  40, 15,           MD_XGI315},
+	{"320x480x8",    0x5A, 0x0000, 0x0000,  320,  480,  8, 1,  40, 30,           MD_XGI315},  /* TW: FSTN */
+	{"320x480x16",   0x5B, 0x0000, 0x0000,  320,  480, 16, 1,  40, 30,           MD_XGI315},  /* TW: FSTN */
+	{"640x480x8",    0x2E, 0x0101, 0x0101,  640,  480,  8, 1,  80, 30, MD_XGI300|MD_XGI315},
+	{"640x480x16",   0x44, 0x0111, 0x0111,  640,  480, 16, 1,  80, 30, MD_XGI300|MD_XGI315},
+	{"640x480x24",   0x62, 0x013a, 0x0112,  640,  480, 32, 1,  80, 30, MD_XGI300|MD_XGI315},  /* TW: That's for people who mix up color- and fb depth */
+	{"640x480x32",   0x62, 0x013a, 0x0112,  640,  480, 32, 1,  80, 30, MD_XGI300|MD_XGI315},
+	{"720x480x8",    0x31, 0x0000, 0x0000,  720,  480,  8, 1,  90, 30, MD_XGI300|MD_XGI315},
+	{"720x480x16",   0x33, 0x0000, 0x0000,  720,  480, 16, 1,  90, 30, MD_XGI300|MD_XGI315},
+	{"720x480x24",   0x35, 0x0000, 0x0000,  720,  480, 32, 1,  90, 30, MD_XGI300|MD_XGI315},
+	{"720x480x32",   0x35, 0x0000, 0x0000,  720,  480, 32, 1,  90, 30, MD_XGI300|MD_XGI315},
+	{"720x576x8",    0x32, 0x0000, 0x0000,  720,  576,  8, 1,  90, 36, MD_XGI300|MD_XGI315},
+	{"720x576x16",   0x34, 0x0000, 0x0000,  720,  576, 16, 1,  90, 36, MD_XGI300|MD_XGI315},
+	{"720x576x24",   0x36, 0x0000, 0x0000,  720,  576, 32, 1,  90, 36, MD_XGI300|MD_XGI315},
+	{"720x576x32",   0x36, 0x0000, 0x0000,  720,  576, 32, 1,  90, 36, MD_XGI300|MD_XGI315},
+	{"800x480x8",    0x70, 0x0000, 0x0000,  800,  480,  8, 1, 100, 30, MD_XGI300|MD_XGI315},
+	{"800x480x16",   0x7a, 0x0000, 0x0000,  800,  480, 16, 1, 100, 30, MD_XGI300|MD_XGI315},
+	{"800x480x24",   0x76, 0x0000, 0x0000,  800,  480, 32, 1, 100, 30, MD_XGI300|MD_XGI315},
+	{"800x480x32",   0x76, 0x0000, 0x0000,  800,  480, 32, 1, 100, 30, MD_XGI300|MD_XGI315},
+#define DEFAULT_MODE              21 /* TW: index for 800x600x8 */
+#define DEFAULT_LCDMODE           21 /* TW: index for 800x600x8 */
+#define DEFAULT_TVMODE            21 /* TW: index for 800x600x8 */
+	{"800x600x8",    0x30, 0x0103, 0x0103,  800,  600,  8, 1, 100, 37, MD_XGI300|MD_XGI315},
+	{"800x600x16",   0x47, 0x0114, 0x0114,  800,  600, 16, 1, 100, 37, MD_XGI300|MD_XGI315},
+	{"800x600x24",   0x63, 0x013b, 0x0115,  800,  600, 32, 1, 100, 37, MD_XGI300|MD_XGI315},
+	{"800x600x32",   0x63, 0x013b, 0x0115,  800,  600, 32, 1, 100, 37, MD_XGI300|MD_XGI315},
+	{"1024x576x8",   0x71, 0x0000, 0x0000, 1024,  576,  8, 1, 128, 36, MD_XGI300|MD_XGI315},
+	{"1024x576x16",  0x74, 0x0000, 0x0000, 1024,  576, 16, 1, 128, 36, MD_XGI300|MD_XGI315},
+	{"1024x576x24",  0x77, 0x0000, 0x0000, 1024,  576, 32, 1, 128, 36, MD_XGI300|MD_XGI315},
+	{"1024x576x32",  0x77, 0x0000, 0x0000, 1024,  576, 32, 1, 128, 36, MD_XGI300|MD_XGI315},
+	{"1024x600x8",   0x20, 0x0000, 0x0000, 1024,  600,  8, 1, 128, 37, MD_XGI300          },  /* TW: 300 series only */
+	{"1024x600x16",  0x21, 0x0000, 0x0000, 1024,  600, 16, 1, 128, 37, MD_XGI300          },
+	{"1024x600x24",  0x22, 0x0000, 0x0000, 1024,  600, 32, 1, 128, 37, MD_XGI300          },
+	{"1024x600x32",  0x22, 0x0000, 0x0000, 1024,  600, 32, 1, 128, 37, MD_XGI300          },
+	{"1024x768x8",   0x38, 0x0105, 0x0105, 1024,  768,  8, 1, 128, 48, MD_XGI300|MD_XGI315},
+	{"1024x768x16",  0x4A, 0x0117, 0x0117, 1024,  768, 16, 1, 128, 48, MD_XGI300|MD_XGI315},
+	{"1024x768x24",  0x64, 0x013c, 0x0118, 1024,  768, 32, 1, 128, 48, MD_XGI300|MD_XGI315},
+	{"1024x768x32",  0x64, 0x013c, 0x0118, 1024,  768, 32, 1, 128, 48, MD_XGI300|MD_XGI315},
+	{"1152x768x8",   0x23, 0x0000, 0x0000, 1152,  768,  8, 1, 144, 48, MD_XGI300          },  /* TW: 300 series only */
+	{"1152x768x16",  0x24, 0x0000, 0x0000, 1152,  768, 16, 1, 144, 48, MD_XGI300          },
+	{"1152x768x24",  0x25, 0x0000, 0x0000, 1152,  768, 32, 1, 144, 48, MD_XGI300          },
+	{"1152x768x32",  0x25, 0x0000, 0x0000, 1152,  768, 32, 1, 144, 48, MD_XGI300          },
+	{"1280x720x8",   0x79, 0x0000, 0x0000, 1280,  720,  8, 1, 160, 45, MD_XGI300|MD_XGI315},
+	{"1280x720x16",  0x75, 0x0000, 0x0000, 1280,  720, 16, 1, 160, 45, MD_XGI300|MD_XGI315},
+	{"1280x720x24",  0x78, 0x0000, 0x0000, 1280,  720, 32, 1, 160, 45, MD_XGI300|MD_XGI315},
+	{"1280x720x32",  0x78, 0x0000, 0x0000, 1280,  720, 32, 1, 160, 45, MD_XGI300|MD_XGI315},
+	{"1280x768x8",   0x23, 0x0000, 0x0000, 1280,  768,  8, 1, 160, 48,           MD_XGI315},  /* TW: 310/325 series only */
+	{"1280x768x16",  0x24, 0x0000, 0x0000, 1280,  768, 16, 1, 160, 48,           MD_XGI315},
+	{"1280x768x24",  0x25, 0x0000, 0x0000, 1280,  768, 32, 1, 160, 48,           MD_XGI315},
+	{"1280x768x32",  0x25, 0x0000, 0x0000, 1280,  768, 32, 1, 160, 48,           MD_XGI315},
+#define MODEINDEX_1280x960 48
+	{"1280x960x8",   0x7C, 0x0000, 0x0000, 1280,  960,  8, 1, 160, 60, MD_XGI300|MD_XGI315},  /* TW: Modenumbers being patched */
+	{"1280x960x16",  0x7D, 0x0000, 0x0000, 1280,  960, 16, 1, 160, 60, MD_XGI300|MD_XGI315},
+	{"1280x960x24",  0x7E, 0x0000, 0x0000, 1280,  960, 32, 1, 160, 60, MD_XGI300|MD_XGI315},
+	{"1280x960x32",  0x7E, 0x0000, 0x0000, 1280,  960, 32, 1, 160, 60, MD_XGI300|MD_XGI315},
+	{"1280x1024x8",  0x3A, 0x0107, 0x0107, 1280, 1024,  8, 1, 160, 64, MD_XGI300|MD_XGI315},
+	{"1280x1024x16", 0x4D, 0x011a, 0x011a, 1280, 1024, 16, 1, 160, 64, MD_XGI300|MD_XGI315},
+	{"1280x1024x24", 0x65, 0x013d, 0x011b, 1280, 1024, 32, 1, 160, 64, MD_XGI300|MD_XGI315},
+	{"1280x1024x32", 0x65, 0x013d, 0x011b, 1280, 1024, 32, 1, 160, 64, MD_XGI300|MD_XGI315},
+	{"1400x1050x8",  0x26, 0x0000, 0x0000, 1400, 1050,  8, 1, 175, 65,           MD_XGI315},  /* TW: 310/325 series only */
+	{"1400x1050x16", 0x27, 0x0000, 0x0000, 1400, 1050, 16, 1, 175, 65,           MD_XGI315},
+	{"1400x1050x24", 0x28, 0x0000, 0x0000, 1400, 1050, 32, 1, 175, 65,           MD_XGI315},
+	{"1400x1050x32", 0x28, 0x0000, 0x0000, 1400, 1050, 32, 1, 175, 65,           MD_XGI315},
+	{"1600x1200x8",  0x3C, 0x0130, 0x011c, 1600, 1200,  8, 1, 200, 75, MD_XGI300|MD_XGI315},
+	{"1600x1200x16", 0x3D, 0x0131, 0x011e, 1600, 1200, 16, 1, 200, 75, MD_XGI300|MD_XGI315},
+	{"1600x1200x24", 0x66, 0x013e, 0x011f, 1600, 1200, 32, 1, 200, 75, MD_XGI300|MD_XGI315},
+	{"1600x1200x32", 0x66, 0x013e, 0x011f, 1600, 1200, 32, 1, 200, 75, MD_XGI300|MD_XGI315},
+	{"1920x1440x8",  0x68, 0x013f, 0x0000, 1920, 1440,  8, 1, 240, 75, MD_XGI300|MD_XGI315},
+	{"1920x1440x16", 0x69, 0x0140, 0x0000, 1920, 1440, 16, 1, 240, 75, MD_XGI300|MD_XGI315},
+	{"1920x1440x24", 0x6B, 0x0141, 0x0000, 1920, 1440, 32, 1, 240, 75, MD_XGI300|MD_XGI315},
+	{"1920x1440x32", 0x6B, 0x0141, 0x0000, 1920, 1440, 32, 1, 240, 75, MD_XGI300|MD_XGI315},
+	{"2048x1536x8",  0x6c, 0x0000, 0x0000, 2048, 1536,  8, 1, 256, 96,           MD_XGI315},  /* TW: 310/325 series only */
+	{"2048x1536x16", 0x6d, 0x0000, 0x0000, 2048, 1536, 16, 1, 256, 96,           MD_XGI315},
+	{"2048x1536x24", 0x6e, 0x0000, 0x0000, 2048, 1536, 32, 1, 256, 96,           MD_XGI315},
+	{"2048x1536x32", 0x6e, 0x0000, 0x0000, 2048, 1536, 32, 1, 256, 96,           MD_XGI315},
+	{"\0", 0x00, 0, 0, 0, 0, 0, 0, 0}
+};
+
+/* mode-related variables */
+#ifdef MODULE
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int xgifb_mode_idx = 1;
+#else
+static int XGIfb_mode_idx = MODE_INDEX_NONE;  /* Don't use a mode by default if we are a module */
+#endif
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int xgifb_mode_idx = -1;               /* Use a default mode if we are inside the kernel */
+#else
+static int XGIfb_mode_idx = -1;
+#endif
+#endif
+u8  XGIfb_mode_no  = 0;
+u8  XGIfb_rate_idx = 0;
+
+/* TW: CR36 evaluation */
+const USHORT XGI300paneltype[] =
+    { LCD_UNKNOWN,   LCD_800x600,  LCD_1024x768,  LCD_1280x1024,
+      LCD_1280x960,  LCD_640x480,  LCD_1024x600,  LCD_1152x768,
+       LCD_1024x768, LCD_1024x768,  LCD_1024x768,
+      LCD_1024x768,  LCD_1024x768, LCD_1024x768,  LCD_1024x768 };
+
+const USHORT XGI310paneltype[] =
+    { LCD_UNKNOWN,   LCD_800x600,  LCD_1024x768,  LCD_1280x1024,
+      LCD_640x480,   LCD_1024x600, LCD_1152x864,  LCD_1280x960,
+      LCD_1152x768,  LCD_1400x1050,LCD_1280x768,  LCD_1600x1200,
+      LCD_1024x768, LCD_1024x768,  LCD_1024x768 };
+
+static const struct _XGI_crt2type {
+	char name[10];
+	int type_no;
+	int tvplug_no;
+} XGI_crt2type[] = {
+	{"NONE", 	0, 		-1},
+	{"LCD",  	DISPTYPE_LCD, 	-1},
+	{"TV",   	DISPTYPE_TV, 	-1},
+	{"VGA",  	DISPTYPE_CRT2, 	-1},
+	{"SVIDEO", 	DISPTYPE_TV, 	TVPLUG_SVIDEO},
+	{"COMPOSITE", 	DISPTYPE_TV, 	TVPLUG_COMPOSITE},
+	{"SCART", 	DISPTYPE_TV, 	TVPLUG_SCART},
+	{"none", 	0, 		-1},
+	{"lcd",  	DISPTYPE_LCD, 	-1},
+	{"tv",   	DISPTYPE_TV, 	-1},
+	{"vga",  	DISPTYPE_CRT2, 	-1},
+	{"svideo", 	DISPTYPE_TV, 	TVPLUG_SVIDEO},
+	{"composite", 	DISPTYPE_TV, 	TVPLUG_COMPOSITE},
+	{"scart", 	DISPTYPE_TV, 	TVPLUG_SCART},
+	{"\0",  	-1, 		-1}
+};
+
+/* Queue mode selection for 310 series */
+static const struct _XGI_queuemode {
+	char name[6];
+	int type_no;
+} XGI_queuemode[] = {
+	{"AGP",  	AGP_CMD_QUEUE},
+	{"VRAM", 	VM_CMD_QUEUE},
+	{"MMIO", 	MMIO_CMD},
+	{"agp",  	AGP_CMD_QUEUE},
+	{"vram", 	VM_CMD_QUEUE},
+	{"mmio", 	MMIO_CMD},
+	{"\0",   	-1}
+};
+
+/* TV standard */
+static const struct _XGI_tvtype {
+	char name[6];
+	int type_no;
+} XGI_tvtype[] = {
+	{"PAL",  	1},
+	{"NTSC", 	2},
+	{"pal", 	1},
+	{"ntsc",  	2},
+	{"\0",   	-1}
+};
+
+static const struct _XGI_vrate {
+	u16 idx;
+	u16 xres;
+	u16 yres;
+	u16 refresh;
+} XGIfb_vrate[] = {
+	{1,  640,  480, 60}, {2,  640,  480,  72}, {3, 640,   480,  75}, {4,  640, 480,  85},
+	{5,  640,  480,100}, {6,  640,  480, 120}, {7, 640,   480, 160}, {8,  640, 480, 200},
+	{1,  720,  480, 60},
+	{1,  720,  576, 58},
+	{1,  800,  480, 60}, {2,  800,  480,  75}, {3, 800,   480,  85},
+        {1,  800,  600,  60}, {2, 800,   600,  72}, {3,  800, 600,  75},
+	{4,  800,  600, 85}, {5,  800,  600, 100}, {6, 800,   600, 120}, {7,  800, 600, 160},
+	{1, 1024,  768,  60}, {2, 1024,  768,  70}, {3, 1024, 768,  75},
+	{4, 1024,  768, 85}, {5, 1024,  768, 100}, {6, 1024,  768, 120},
+	{1, 1024,  576, 60}, {2, 1024,  576,  75}, {3, 1024,  576,  85},
+	{1, 1024,  600, 60},
+	{1, 1152,  768, 60},
+	{1, 1280,  720, 60}, {2, 1280,  720,  75}, {3, 1280,  720,  85},
+	{1, 1280,  768, 60},
+        {1, 1280, 1024,  60}, {2, 1280, 1024,  75}, {3, 1280, 1024,  85},
+	{1, 1280,  960, 70},
+	{1, 1400, 1050, 60},
+	{1, 1600, 1200, 60}, {2, 1600, 1200,  65}, {3, 1600, 1200,  70}, {4, 1600, 1200,  75},
+	{5, 1600, 1200, 85}, {6, 1600, 1200, 100}, {7, 1600, 1200, 120},
+	{1, 1920, 1440, 60}, {2, 1920, 1440,  65}, {3, 1920, 1440,  70}, {4, 1920, 1440,  75},
+	{5, 1920, 1440, 85}, {6, 1920, 1440, 100},
+	{1, 2048, 1536, 60}, {2, 2048, 1536,  65}, {3, 2048, 1536,  70}, {4, 2048, 1536,  75},
+	{5, 2048, 1536, 85},
+	{0, 0, 0, 0}
+};
+
+static const struct _chswtable {
+    int subsysVendor;
+    int subsysCard;
+    char *vendorName;
+    char *cardName;
+} mychswtable[] = {
+        { 0x1631, 0x1002, "Mitachi", "0x1002" },
+	{ 0,      0,      ""       , ""       }
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/* Offscreen layout */
+typedef struct _XGI_GLYINFO {
+	unsigned char ch;
+	int fontwidth;
+	int fontheight;
+	u8 gmask[72];
+	int ngmask;
+} XGI_GLYINFO;
+#endif
+
+typedef struct _XGI_OH {
+	struct _XGI_OH *poh_next;
+	struct _XGI_OH *poh_prev;
+	unsigned long offset;
+	unsigned long size;
+} XGI_OH;
+
+typedef struct _XGI_OHALLOC {
+	struct _XGI_OHALLOC *poha_next;
+	XGI_OH aoh[1];
+} XGI_OHALLOC;
+
+typedef struct _XGI_HEAP {
+	XGI_OH oh_free;
+	XGI_OH oh_used;
+	XGI_OH *poh_freelist;
+	XGI_OHALLOC *poha_chain;
+	unsigned long max_freesize;
+} XGI_HEAP;
+
+static unsigned long XGIfb_hwcursor_vbase;
+
+static unsigned long XGIfb_heap_start;
+static unsigned long XGIfb_heap_end;
+static unsigned long XGIfb_heap_size;
+static XGI_HEAP      XGIfb_heap;
+
+// Eden Chen
+static const struct _XGI_TV_filter {
+	u8 filter[9][4];
+} XGI_TV_filter[] = {
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_0 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_1 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_2 */
+	   {0xF5,0xEE,0x1B,0x44},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xEB,0x04,0x25,0x18},
+	   {0xF1,0x05,0x1F,0x16},
+	   {0xF6,0x06,0x1A,0x14},
+	   {0xFA,0x06,0x16,0x14},
+	   {0x00,0x04,0x10,0x18},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_3 */
+	   {0xF1,0x04,0x1F,0x18},
+	   {0xEE,0x0D,0x22,0x06},
+	   {0xF7,0x06,0x19,0x14},
+	   {0xF4,0x0B,0x1C,0x0A},
+	   {0xFA,0x07,0x16,0x12},
+	   {0xF9,0x0A,0x17,0x0C},
+	   {0x00,0x07,0x10,0x12},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_4 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_5 */
+	   {0xF5,0xEE,0x1B,0x44},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xEB,0x04,0x25,0x18},
+	   {0xF1,0x05,0x1F,0x16},
+	   {0xF6,0x06,0x1A,0x14},
+	   {0xFA,0x06,0x16,0x14},
+	   {0x00,0x04,0x10,0x18},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_6 */
+	   {0xEB,0x04,0x25,0x18},
+	   {0xE7,0x0E,0x29,0x04},
+	   {0xEE,0x0C,0x22,0x08},
+	   {0xF6,0x0B,0x1A,0x0A},
+	   {0xF9,0x0A,0x17,0x0C},
+	   {0xFC,0x0A,0x14,0x0C},
+	   {0x00,0x08,0x10,0x10},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* NTSCFilter_7 */
+	   {0xEC,0x02,0x24,0x1C},
+	   {0xF2,0x04,0x1E,0x18},
+	   {0xEB,0x15,0x25,0xF6},
+	   {0xF4,0x10,0x1C,0x00},
+	   {0xF8,0x0F,0x18,0x02},
+	   {0x00,0x04,0x10,0x18},
+	   {0x01,0x06,0x0F,0x14},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_0 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_1 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_2 */
+	   {0xF5,0xEE,0x1B,0x44},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xF1,0xF7,0x01,0x32},
+	   {0xF5,0xFB,0x1B,0x2A},
+	   {0xF9,0xFF,0x17,0x22},
+	   {0xFB,0x01,0x15,0x1E},
+	   {0x00,0x04,0x10,0x18},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_3 */
+	   {0xF5,0xFB,0x1B,0x2A},
+	   {0xEE,0xFE,0x22,0x24},
+	   {0xF3,0x00,0x1D,0x20},
+	   {0xF9,0x03,0x17,0x1A},
+	   {0xFB,0x02,0x14,0x1E},
+	   {0xFB,0x04,0x15,0x18},
+	   {0x00,0x06,0x10,0x14},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_4 */
+	   {0x00,0xE0,0x10,0x60},
+	   {0x00,0xEE,0x10,0x44},
+	   {0x00,0xF4,0x10,0x38},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0x00,0x00,0x10,0x20},
+	   {0x00,0x04,0x10,0x18},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_5 */
+	   {0xF5,0xEE,0x1B,0x44},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xF1,0xF7,0x1F,0x32},
+	   {0xF5,0xFB,0x1B,0x2A},
+	   {0xF9,0xFF,0x17,0x22},
+	   {0xFB,0x01,0x15,0x1E},
+	   {0x00,0x04,0x10,0x18},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_6 */
+	   {0xF5,0xEE,0x1B,0x2A},
+	   {0xEE,0xFE,0x22,0x24},
+	   {0xF3,0x00,0x1D,0x20},
+	   {0xF9,0x03,0x17,0x1A},
+	   {0xFB,0x02,0x14,0x1E},
+	   {0xFB,0x04,0x15,0x18},
+	   {0x00,0x06,0x10,0x14},
+	   {0xFF,0xFF,0xFF,0xFF} }},
+	{ {{0x00,0x00,0x00,0x40},  /* PALFilter_7 */
+	   {0xF5,0xEE,0x1B,0x44},
+	   {0xF8,0xF4,0x18,0x38},
+	   {0xFC,0xFB,0x14,0x2A},
+	   {0xEB,0x05,0x25,0x16},
+	   {0xF1,0x05,0x1F,0x16},
+	   {0xFA,0x07,0x16,0x12},
+	   {0x00,0x07,0x10,0x12},
+	   {0xFF,0xFF,0xFF,0xFF} }}
+};
+
+static int           filter = -1;
+static unsigned char filter_tb;
+
+
+/* ---------------------- Routine prototypes ------------------------- */
+
+/* Interface used by the world */
+#ifndef MODULE
+XGIINITSTATIC int __init XGIfb_setup(char *options);
+#endif
+
+/* Interface to the low level console driver */
+
+
+
+/* fbdev routines */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+       int	XGIfb_init(void);
+static int      XGIfb_get_fix(struct fb_fix_screeninfo *fix,
+			      int con,
+			      struct fb_info *info);
+static int      XGIfb_get_var(struct fb_var_screeninfo *var,
+			      int con,
+			      struct fb_info *info);
+static int      XGIfb_set_var(struct fb_var_screeninfo *var,
+			      int con,
+			      struct fb_info *info);
+static void     XGIfb_crtc_to_var(struct fb_var_screeninfo *var);
+static int      XGIfb_get_cmap(struct fb_cmap *cmap,
+			       int kspc,
+			       int con,
+			       struct fb_info *info);
+static int      XGIfb_set_cmap(struct fb_cmap *cmap,
+			       int kspc,
+			       int con,
+			       struct fb_info *info);
+static int      XGIfb_update_var(int con,
+				 struct fb_info *info);
+static int      XGIfb_switch(int con,
+			     struct fb_info *info);
+static void     XGIfb_blank(int blank,
+			    struct fb_info *info);
+static void     XGIfb_set_disp(int con,
+			       struct fb_var_screeninfo *var,
+                               struct fb_info *info);
+static int      XGI_getcolreg(unsigned regno, unsigned *red, unsigned *green,
+			      unsigned *blue, unsigned *transp,
+			      struct fb_info *fb_info);
+static void     XGIfb_do_install_cmap(int con,
+                                      struct fb_info *info);
+static void     XGI_get_glyph(struct fb_info *info,
+                              XGI_GLYINFO *gly);
+static int 	XGIfb_mmap(struct fb_info *info, struct file *file,
+		           struct vm_area_struct *vma);
+static int      XGIfb_ioctl(struct inode *inode, struct file *file,
+		       	    unsigned int cmd, unsigned long arg, int con,
+		       	    struct fb_info *info);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+XGIINITSTATIC int __init xgifb_init(void);
+static int      XGIfb_set_par(struct fb_info *info);
+static int      XGIfb_blank(int blank,
+                            struct fb_info *info);
+/*static int 	XGIfb_mmap(struct fb_info *info, struct file *file,
+		           struct vm_area_struct *vma);
+*/
+extern void     fbcon_XGI_fillrect(struct fb_info *info,
+                                   const struct fb_fillrect *rect);
+extern void     fbcon_XGI_copyarea(struct fb_info *info,
+                                   const struct fb_copyarea *area);
+#if 0
+extern void     cfb_imageblit(struct fb_info *info,
+                              const struct fb_image *image);
+#endif
+extern int      fbcon_XGI_sync(struct fb_info *info);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+static int XGIfb_ioctl(struct fb_info *info, unsigned int cmd,
+			    unsigned long arg);
+#else
+static int      XGIfb_ioctl(struct inode *inode,
+	 		    struct file *file,
+		       	    unsigned int cmd,
+			    unsigned long arg,
+		       	    struct fb_info *info);
+#endif
+
+/*
+extern int	XGIfb_mode_rate_to_dclock(VB_DEVICE_INFO *XGI_Pr,
+			      PXGI_HW_DEVICE_INFO HwDeviceExtension,
+			      unsigned char modeno, unsigned char rateindex);
+extern int      XGIfb_mode_rate_to_ddata(VB_DEVICE_INFO *XGI_Pr, PXGI_HW_DEVICE_INFO HwDeviceExtension,
+			 unsigned char modeno, unsigned char rateindex,
+			 unsigned int *left_margin, unsigned int *right_margin,
+			 unsigned int *upper_margin, unsigned int *lower_margin,
+			 unsigned int *hsync_len, unsigned int *vsync_len,
+			 unsigned int *sync, unsigned int *vmode);
+*/
+#endif
+			extern   BOOLEAN  XGI_SearchModeID( USHORT ModeNo,USHORT  *ModeIdIndex, PVB_DEVICE_INFO );
+static int      XGIfb_get_fix(struct fb_fix_screeninfo *fix, int con,
+			      struct fb_info *info);
+
+/* Internal 2D accelerator functions */
+extern int      XGIfb_initaccel(void);
+extern void     XGIfb_syncaccel(void);
+
+/* Internal general routines */
+static void     XGIfb_search_mode(const char *name);
+static int      XGIfb_validate_mode(int modeindex);
+static u8       XGIfb_search_refresh_rate(unsigned int rate);
+static int      XGIfb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			unsigned blue, unsigned transp,
+			struct fb_info *fb_info);
+static int      XGIfb_do_set_var(struct fb_var_screeninfo *var, int isactive,
+		      	struct fb_info *info);
+static void     XGIfb_pre_setmode(void);
+static void     XGIfb_post_setmode(void);
+
+static BOOLEAN  XGIfb_CheckVBRetrace(void);
+static BOOLEAN  XGIfbcheckvretracecrt2(void);
+static BOOLEAN  XGIfbcheckvretracecrt1(void);
+static BOOLEAN  XGIfb_bridgeisslave(void);
+
+struct XGI_memreq {
+	unsigned long offset;
+	unsigned long size;
+};
+
+/* XGI-specific Export functions */
+void            XGI_dispinfo(struct ap_data *rec);
+void            XGI_malloc(struct XGI_memreq *req);
+void            XGI_free(unsigned long base);
+
+/* Internal hardware access routines */
+void            XGIfb_set_reg4(u16 port, unsigned long data);
+u32             XGIfb_get_reg3(u16 port);
+
+/* Chipset-dependent internal routines */
+
+
+static int      XGIfb_get_dram_size(void);
+static void     XGIfb_detect_VB(void);
+static void     XGIfb_get_VB_type(void);
+static int      XGIfb_has_VB(void);
+
+
+/* Internal heap routines */
+static int      XGIfb_heap_init(void);
+static XGI_OH   *XGIfb_poh_new_node(void);
+static XGI_OH   *XGIfb_poh_allocate(unsigned long size);
+static void     XGIfb_delete_node(XGI_OH *poh);
+static void     XGIfb_insert_node(XGI_OH *pohList, XGI_OH *poh);
+static XGI_OH   *XGIfb_poh_free(unsigned long base);
+static void     XGIfb_free_node(XGI_OH *poh);
+
+/* Internal routines to access PCI configuration space */
+BOOLEAN         XGIfb_query_VGA_config_space(PXGI_HW_DEVICE_INFO pXGIhw_ext,
+	          	unsigned long offset, unsigned long set, unsigned long *value);
+//BOOLEAN         XGIfb_query_north_bridge_space(PXGI_HW_DEVICE_INFO pXGIhw_ext,
+//	         	unsigned long offset, unsigned long set, unsigned long *value);
+
+
+/* Routines from init.c/init301.c */
+extern void     InitTo330Pointer(UCHAR,PVB_DEVICE_INFO pVBInfo);
+extern BOOLEAN  XGIInitNew(PXGI_HW_DEVICE_INFO HwDeviceExtension);
+extern BOOLEAN  XGISetModeNew(PXGI_HW_DEVICE_INFO HwDeviceExtension, USHORT ModeNo);
+//extern void     XGI_SetEnableDstn(VB_DEVICE_INFO *XGI_Pr);
+extern void     XGI_LongWait(VB_DEVICE_INFO *XGI_Pr);
+extern USHORT   XGI_GetRatePtrCRT2( PXGI_HW_DEVICE_INFO pXGIHWDE, USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo );
+/* TW: Chrontel TV functions */
+extern USHORT 	XGI_GetCH700x(VB_DEVICE_INFO *XGI_Pr, USHORT tempbx);
+extern void 	XGI_SetCH700x(VB_DEVICE_INFO *XGI_Pr, USHORT tempbx);
+extern USHORT 	XGI_GetCH701x(VB_DEVICE_INFO *XGI_Pr, USHORT tempbx);
+extern void 	XGI_SetCH701x(VB_DEVICE_INFO *XGI_Pr, USHORT tempbx);
+extern void     XGI_SetCH70xxANDOR(VB_DEVICE_INFO *XGI_Pr, USHORT tempax,USHORT tempbh);
+extern void     XGI_DDC2Delay(VB_DEVICE_INFO *XGI_Pr, USHORT delaytime);
+
+/* TW: Sensing routines */
+void            XGI_Sense30x(void);
+int             XGIDoSense(int tempbl, int tempbh, int tempcl, int tempch);
+
+extern XGI21_LVDSCapStruct XGI21_LCDCapList[13];
+#endif
--- /dev/null
+++ b/drivers/staging/xgifb/XGI_main_26.c
@@ -0,0 +1,3773 @@
+/*
+ * XG20, XG21, XG40, XG42 frame buffer device
+ * for Linux kernels  2.5.x, 2.6.x
+ * Base on TW's sis fbdev code.
+ */
+
+//#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/selection.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/vmalloc.h>
+#include <linux/vt_kern.h>
+#include <linux/capability.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+
+#include "osdef.h"
+
+
+#ifndef XGIFB_PAN
+#define XGIFB_PAN
+#endif
+
+#include <asm/io.h>
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+
+#include "XGIfb.h"
+#include "vgatypes.h"
+#include "XGI_main.h"
+#include "vb_util.h"
+
+
+#define Index_CR_GPIO_Reg1 0x48
+#define Index_CR_GPIO_Reg2 0x49
+#define Index_CR_GPIO_Reg3 0x4a
+
+#define GPIOG_EN    (1<<6)
+#define GPIOG_WRITE (1<<6)
+#define GPIOG_READ  (1<<1)
+int XGIfb_GetXG21DefaultLVDSModeIdx(void);
+
+/* -------------------- Macro definitions ---------------------------- */
+
+#undef XGIFBDEBUG
+
+#ifdef XGIFBDEBUG
+#define DPRINTK(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#ifdef XGIFBDEBUG
+static void dumpVGAReg(void)
+{
+    u8 i,reg;
+
+outXGIIDXREG(XGISR, 0x05, 0x86);
+/*
+outXGIIDXREG(XGISR, 0x08, 0x4f);
+outXGIIDXREG(XGISR, 0x0f, 0x20);
+outXGIIDXREG(XGISR, 0x11, 0x4f);
+outXGIIDXREG(XGISR, 0x13, 0x45);
+outXGIIDXREG(XGISR, 0x14, 0x51);
+outXGIIDXREG(XGISR, 0x1e, 0x41);
+outXGIIDXREG(XGISR, 0x1f, 0x0);
+outXGIIDXREG(XGISR, 0x20, 0xa1);
+outXGIIDXREG(XGISR, 0x22, 0xfb);
+outXGIIDXREG(XGISR, 0x26, 0x22);
+outXGIIDXREG(XGISR, 0x3e, 0x07);
+*/
+
+//outXGIIDXREG(XGICR, 0x19, 0x00);
+//outXGIIDXREG(XGICR, 0x1a, 0x3C);
+//outXGIIDXREG(XGICR, 0x22, 0xff);
+//outXGIIDXREG(XGICR, 0x3D, 0x10);
+
+//outXGIIDXREG(XGICR, 0x4a, 0xf3);
+
+//outXGIIDXREG(XGICR, 0x57, 0x0);
+//outXGIIDXREG(XGICR, 0x7a, 0x2c);
+
+//outXGIIDXREG(XGICR, 0x82, 0xcc);
+//outXGIIDXREG(XGICR, 0x8c, 0x0);
+/*
+outXGIIDXREG(XGICR, 0x99, 0x1);
+outXGIIDXREG(XGICR, 0x41, 0x40);
+*/
+
+    for(i=0; i < 0x4f; i++)
+    {
+        inXGIIDXREG(XGISR, i, reg);
+        printk("\no 3c4 %x",i);
+        printk("\ni 3c5 => %x",reg);
+    }
+
+    for(i=0; i < 0xF0; i++)
+    {
+        inXGIIDXREG(XGICR, i, reg);
+        printk("\no 3d4 %x",i);
+        printk("\ni 3d5 => %x",reg);
+    }
+/*
+
+    outXGIIDXREG(XGIPART1,0x2F,1);
+    for(i=1; i < 0x50; i++)
+    {
+        inXGIIDXREG(XGIPART1, i, reg);
+        printk("\no d004 %x",i);
+        printk("\ni d005 => %x",reg);
+    }
+
+    for(i=0; i < 0x50; i++)
+    {
+        inXGIIDXREG(XGIPART2, i, reg);
+        printk("\no d010 %x",i);
+        printk("\ni d011 => %x",reg);
+    }
+    for(i=0; i < 0x50; i++)
+    {
+        inXGIIDXREG(XGIPART3, i, reg);
+        printk("\no d012 %x",i);
+        printk("\ni d013 => %x",reg);
+    }
+    for(i=0; i < 0x50; i++)
+    {
+        inXGIIDXREG(XGIPART4, i, reg);
+        printk("\no d014 %x",i);
+        printk("\ni d015 => %x",reg);
+    }
+*/
+}
+#else
+static inline void dumpVGAReg(void) {}
+#endif
+
+/* data for XGI components */
+struct video_info  xgi_video_info;
+
+
+#if 1
+#define DEBUGPRN(x)
+#else
+#define DEBUGPRN(x) printk(KERN_INFO x "\n");
+#endif
+
+
+/* --------------- Hardware Access Routines -------------------------- */
+
+#ifdef LINUX_KERNEL
+int
+XGIfb_mode_rate_to_dclock(VB_DEVICE_INFO *XGI_Pr, PXGI_HW_DEVICE_INFO HwDeviceExtension,
+			  unsigned char modeno, unsigned char rateindex)
+{
+    USHORT ModeNo = modeno;
+    USHORT ModeIdIndex = 0, ClockIndex = 0;
+    USHORT RefreshRateTableIndex = 0;
+
+    /*ULONG  temp = 0;*/
+    int    Clock;
+    XGI_Pr->ROMAddr  = HwDeviceExtension->pjVirtualRomBase;
+    InitTo330Pointer( HwDeviceExtension->jChipType, XGI_Pr ) ;
+
+    RefreshRateTableIndex = XGI_GetRatePtrCRT2( HwDeviceExtension, ModeNo , ModeIdIndex, XGI_Pr ) ;
+
+/*
+    temp = XGI_SearchModeID( ModeNo , &ModeIdIndex,  XGI_Pr ) ;
+    if(!temp) {
+    	printk(KERN_ERR "Could not find mode %x\n", ModeNo);
+    	return 65000;
+    }
+
+    RefreshRateTableIndex = XGI_Pr->EModeIDTable[ModeIdIndex].REFindex;
+    RefreshRateTableIndex += (rateindex - 1);
+
+*/
+    ClockIndex = XGI_Pr->RefIndex[RefreshRateTableIndex].Ext_CRTVCLK;
+    if(HwDeviceExtension->jChipType < XGI_315H) {
+       ClockIndex &= 0x3F;
+    }
+    Clock = XGI_Pr->VCLKData[ClockIndex].CLOCK * 1000 ;
+
+    return(Clock);
+}
+
+int
+XGIfb_mode_rate_to_ddata(VB_DEVICE_INFO *XGI_Pr, PXGI_HW_DEVICE_INFO HwDeviceExtension,
+			 unsigned char modeno, unsigned char rateindex,
+			 u32 *left_margin, u32 *right_margin,
+			 u32 *upper_margin, u32 *lower_margin,
+			 u32 *hsync_len, u32 *vsync_len,
+			 u32 *sync, u32 *vmode)
+{
+    USHORT ModeNo = modeno;
+    USHORT ModeIdIndex = 0, index = 0;
+    USHORT RefreshRateTableIndex = 0;
+
+    unsigned short VRE, VBE, VRS, VBS, VDE, VT;
+    unsigned short HRE, HBE, HRS, HBS, HDE, HT;
+    unsigned char  sr_data, cr_data, cr_data2;
+    unsigned long cr_data3;
+    int            A, B, C, D, E, F, temp, j;
+    XGI_Pr->ROMAddr  = HwDeviceExtension->pjVirtualRomBase;
+    InitTo330Pointer( HwDeviceExtension->jChipType, XGI_Pr ) ;
+  RefreshRateTableIndex = XGI_GetRatePtrCRT2( HwDeviceExtension, ModeNo , ModeIdIndex, XGI_Pr ) ;
+/*
+    temp = XGI_SearchModeID( ModeNo, &ModeIdIndex, XGI_Pr);
+    if(!temp) return 0;
+
+    RefreshRateTableIndex = XGI_Pr->EModeIDTable[ModeIdIndex].REFindex;
+    RefreshRateTableIndex += (rateindex - 1);
+*/
+    index = XGI_Pr->RefIndex[RefreshRateTableIndex].Ext_CRT1CRTC;
+
+    sr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[5];
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[0];
+
+    /* Horizontal total */
+    HT = (cr_data & 0xff) |
+         ((unsigned short) (sr_data & 0x03) << 8);
+    A = HT + 5;
+
+    /*cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[1];
+
+     Horizontal display enable end
+    HDE = (cr_data & 0xff) |
+          ((unsigned short) (sr_data & 0x0C) << 6);*/
+    HDE = (XGI_Pr->RefIndex[RefreshRateTableIndex].XRes >> 3) -1;
+    E = HDE + 1;
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[3];
+
+    /* Horizontal retrace (=sync) start */
+    HRS = (cr_data & 0xff) |
+          ((unsigned short) (sr_data & 0xC0) << 2);
+    F = HRS - E - 3;
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[1];
+
+    /* Horizontal blank start */
+    HBS = (cr_data & 0xff) |
+          ((unsigned short) (sr_data & 0x30) << 4);
+
+    sr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[6];
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[2];
+
+    cr_data2 = XGI_Pr->XGINEWUB_CRT1Table[index].CR[4];
+
+    /* Horizontal blank end */
+    HBE = (cr_data & 0x1f) |
+          ((unsigned short) (cr_data2 & 0x80) >> 2) |
+	  ((unsigned short) (sr_data & 0x03) << 6);
+
+    /* Horizontal retrace (=sync) end */
+    HRE = (cr_data2 & 0x1f) | ((sr_data & 0x04) << 3);
+
+    temp = HBE - ((E - 1) & 255);
+    B = (temp > 0) ? temp : (temp + 256);
+
+    temp = HRE - ((E + F + 3) & 63);
+    C = (temp > 0) ? temp : (temp + 64);
+
+    D = B - F - C;
+
+    *left_margin = D * 8;
+    *right_margin = F * 8;
+    *hsync_len = C * 8;
+
+    sr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[14];
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[8];
+
+    cr_data2 = XGI_Pr->XGINEWUB_CRT1Table[index].CR[9];
+
+    /* Vertical total */
+    VT = (cr_data & 0xFF) |
+         ((unsigned short) (cr_data2 & 0x01) << 8) |
+	 ((unsigned short)(cr_data2 & 0x20) << 4) |
+	 ((unsigned short) (sr_data & 0x01) << 10);
+    A = VT + 2;
+
+    //cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[10];
+
+    /* Vertical display enable end */
+/*    VDE = (cr_data & 0xff) |
+          ((unsigned short) (cr_data2 & 0x02) << 7) |
+	  ((unsigned short) (cr_data2 & 0x40) << 3) |
+	  ((unsigned short) (sr_data & 0x02) << 9); */
+    VDE = XGI_Pr->RefIndex[RefreshRateTableIndex].YRes  -1;
+    E = VDE + 1;
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[10];
+
+    /* Vertical retrace (=sync) start */
+    VRS = (cr_data & 0xff) |
+          ((unsigned short) (cr_data2 & 0x04) << 6) |
+	  ((unsigned short) (cr_data2 & 0x80) << 2) |
+	  ((unsigned short) (sr_data & 0x08) << 7);
+    F = VRS + 1 - E;
+
+    cr_data =  XGI_Pr->XGINEWUB_CRT1Table[index].CR[12];
+
+    cr_data3 = (XGI_Pr->XGINEWUB_CRT1Table[index].CR[14] & 0x80) << 5;
+
+    /* Vertical blank start */
+    VBS = (cr_data & 0xff) |
+          ((unsigned short) (cr_data2 & 0x08) << 5) |
+	  ((unsigned short) (cr_data3 & 0x20) << 4) |
+	  ((unsigned short) (sr_data & 0x04) << 8);
+
+    cr_data =  XGI_Pr->XGINEWUB_CRT1Table[index].CR[13];
+
+    /* Vertical blank end */
+    VBE = (cr_data & 0xff) |
+          ((unsigned short) (sr_data & 0x10) << 4);
+    temp = VBE - ((E - 1) & 511);
+    B = (temp > 0) ? temp : (temp + 512);
+
+    cr_data = XGI_Pr->XGINEWUB_CRT1Table[index].CR[11];
+
+    /* Vertical retrace (=sync) end */
+    VRE = (cr_data & 0x0f) | ((sr_data & 0x20) >> 1);
+    temp = VRE - ((E + F - 1) & 31);
+    C = (temp > 0) ? temp : (temp + 32);
+
+    D = B - F - C;
+
+    *upper_margin = D;
+    *lower_margin = F;
+    *vsync_len = C;
+
+    if(XGI_Pr->RefIndex[RefreshRateTableIndex].Ext_InfoFlag & 0x8000)
+       *sync &= ~FB_SYNC_VERT_HIGH_ACT;
+    else
+       *sync |= FB_SYNC_VERT_HIGH_ACT;
+
+    if(XGI_Pr->RefIndex[RefreshRateTableIndex].Ext_InfoFlag & 0x4000)
+       *sync &= ~FB_SYNC_HOR_HIGH_ACT;
+    else
+       *sync |= FB_SYNC_HOR_HIGH_ACT;
+
+    *vmode = FB_VMODE_NONINTERLACED;
+    if(XGI_Pr->RefIndex[RefreshRateTableIndex].Ext_InfoFlag & 0x0080)
+       *vmode = FB_VMODE_INTERLACED;
+    else {
+      j = 0;
+      while(XGI_Pr->EModeIDTable[j].Ext_ModeID != 0xff) {
+          if(XGI_Pr->EModeIDTable[j].Ext_ModeID ==
+	                  XGI_Pr->RefIndex[RefreshRateTableIndex].ModeID) {
+              if(XGI_Pr->EModeIDTable[j].Ext_ModeFlag & DoubleScanMode) {
+	      	  *vmode = FB_VMODE_DOUBLE;
+              }
+	      break;
+          }
+	  j++;
+      }
+    }
+
+#if 0  /* That's bullshit, only the resolution needs to be shifted */
+    if((*vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
+       *upper_margin <<= 1;
+       *lower_margin <<= 1;
+       *vsync_len <<= 1;
+    } else if((*vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
+       *upper_margin >>= 1;
+       *lower_margin >>= 1;
+       *vsync_len >>= 1;
+    }
+#endif
+
+    return 1;
+}
+
+#endif
+
+
+
+void XGIRegInit(VB_DEVICE_INFO *XGI_Pr, ULONG BaseAddr)
+{
+   XGI_Pr->RelIO = BaseAddr;
+   XGI_Pr->P3c4 = BaseAddr + 0x14;
+   XGI_Pr->P3d4 = BaseAddr + 0x24;
+   XGI_Pr->P3c0 = BaseAddr + 0x10;
+   XGI_Pr->P3ce = BaseAddr + 0x1e;
+   XGI_Pr->P3c2 = BaseAddr + 0x12;
+   XGI_Pr->P3ca = BaseAddr + 0x1a;
+   XGI_Pr->P3c6 = BaseAddr + 0x16;
+   XGI_Pr->P3c7 = BaseAddr + 0x17;
+   XGI_Pr->P3c8 = BaseAddr + 0x18;
+   XGI_Pr->P3c9 = BaseAddr + 0x19;
+   XGI_Pr->P3da = BaseAddr + 0x2A;
+   XGI_Pr->Part1Port = BaseAddr + XGI_CRT2_PORT_04;   /* Digital video interface registers (LCD) */
+   XGI_Pr->Part2Port = BaseAddr + XGI_CRT2_PORT_10;   /* 301 TV Encoder registers */
+   XGI_Pr->Part3Port = BaseAddr + XGI_CRT2_PORT_12;   /* 301 Macrovision registers */
+   XGI_Pr->Part4Port = BaseAddr + XGI_CRT2_PORT_14;   /* 301 VGA2 (and LCD) registers */
+   XGI_Pr->Part5Port = BaseAddr + XGI_CRT2_PORT_14+2; /* 301 palette address port registers */
+
+}
+
+
+void XGIfb_set_reg4(u16 port, unsigned long data)
+{
+	outl((u32) (data & 0xffffffff), port);
+}
+
+u32 XGIfb_get_reg3(u16 port)
+{
+	u32 data;
+
+	data = inl(port);
+	return (data);
+}
+
+/* ------------ Interface for init & mode switching code ------------- */
+
+BOOLEAN
+XGIfb_query_VGA_config_space(PXGI_HW_DEVICE_INFO pXGIhw_ext,
+	unsigned long offset, unsigned long set, unsigned long *value)
+{
+	static struct pci_dev *pdev = NULL;
+	static unsigned char init = 0, valid_pdev = 0;
+
+	if (!set)
+		DPRINTK("XGIfb: Get VGA offset 0x%lx\n", offset);
+	else
+		DPRINTK("XGIfb: Set offset 0x%lx to 0x%lx\n", offset, *value);
+
+	if (!init) {
+		init = TRUE;
+		pdev = pci_get_device(PCI_VENDOR_ID_XG, xgi_video_info.chip_id, pdev);
+		if (pdev) {
+			valid_pdev = TRUE;
+			pci_dev_put(pdev);
+		}
+	}
+
+	if (!valid_pdev) {
+		printk(KERN_DEBUG "XGIfb: Can't find XGI %d VGA device.\n",
+				xgi_video_info.chip_id);
+		return FALSE;
+	}
+
+	if (set == 0)
+		pci_read_config_dword(pdev, offset, (u32 *)value);
+	else
+		pci_write_config_dword(pdev, offset, (u32)(*value));
+
+	return TRUE;
+}
+
+/*BOOLEAN XGIfb_query_north_bridge_space(PXGI_HW_DEVICE_INFO pXGIhw_ext,
+	unsigned long offset, unsigned long set, unsigned long *value)
+{
+	static struct pci_dev *pdev = NULL;
+	static unsigned char init = 0, valid_pdev = 0;
+	u16 nbridge_id = 0;
+
+	if (!init) {
+		init = TRUE;
+		switch (xgi_video_info.chip) {
+		case XGI_540:
+			nbridge_id = PCI_DEVICE_ID_XG_540;
+			break;
+		case XGI_630:
+			nbridge_id = PCI_DEVICE_ID_XG_630;
+			break;
+		case XGI_730:
+			nbridge_id = PCI_DEVICE_ID_XG_730;
+			break;
+		case XGI_550:
+			nbridge_id = PCI_DEVICE_ID_XG_550;
+			break;
+		case XGI_650:
+			nbridge_id = PCI_DEVICE_ID_XG_650;
+			break;
+		case XGI_740:
+			nbridge_id = PCI_DEVICE_ID_XG_740;
+			break;
+		default:
+			nbridge_id = 0;
+			break;
+		}
+
+		pdev = pci_find_device(PCI_VENDOR_ID_SI, nbridge_id, pdev);
+		if (pdev)
+			valid_pdev = TRUE;
+	}
+
+	if (!valid_pdev) {
+		printk(KERN_DEBUG "XGIfb: Can't find XGI %d North Bridge device.\n",
+				nbridge_id);
+		return FALSE;
+	}
+
+	if (set == 0)
+		pci_read_config_dword(pdev, offset, (u32 *)value);
+	else
+		pci_write_config_dword(pdev, offset, (u32)(*value));
+
+	return TRUE;
+}
+*/
+/* ------------------ Internal helper routines ----------------- */
+
+static void XGIfb_search_mode(const char *name)
+{
+	int i = 0, j = 0, l;
+
+	if(name == NULL) {
+	   printk(KERN_ERR "XGIfb: Internal error, using default mode.\n");
+	   xgifb_mode_idx = DEFAULT_MODE;
+	   if ((xgi_video_info.chip == XG21) && ((xgi_video_info.disp_state & DISPTYPE_DISP2) == DISPTYPE_LCD))
+	   {
+	       xgifb_mode_idx = XGIfb_GetXG21DefaultLVDSModeIdx();
+	   }
+	   return;
+	}
+
+
+        if (!strcmp(name, XGIbios_mode[MODE_INDEX_NONE].name)) {
+	   printk(KERN_ERR "XGIfb: Mode 'none' not supported anymore. Using default.\n");
+	   xgifb_mode_idx = DEFAULT_MODE;
+	   if ((xgi_video_info.chip == XG21) && ((xgi_video_info.disp_state & DISPTYPE_DISP2) == DISPTYPE_LCD))
+	   {
+	       xgifb_mode_idx = XGIfb_GetXG21DefaultLVDSModeIdx();
+	   }
+	   return;
+	}
+
+	while(XGIbios_mode[i].mode_no != 0) {
+		l = min(strlen(name), strlen(XGIbios_mode[i].name));
+		if (!strncmp(name, XGIbios_mode[i].name, l)) {
+			xgifb_mode_idx = i;
+			j = 1;
+			break;
+		}
+		i++;
+	}
+	if(!j) printk(KERN_INFO "XGIfb: Invalid mode '%s'\n", name);
+}
+
+static void XGIfb_search_vesamode(unsigned int vesamode)
+{
+	int i = 0, j = 0;
+
+	if(vesamode == 0) {
+
+		printk(KERN_ERR "XGIfb: Mode 'none' not supported anymore. Using default.\n");
+		xgifb_mode_idx = DEFAULT_MODE;
+		if ((xgi_video_info.chip == XG21) && ((xgi_video_info.disp_state & DISPTYPE_DISP2) == DISPTYPE_LCD))
+		{
+		    xgifb_mode_idx = XGIfb_GetXG21DefaultLVDSModeIdx();
+		}
+		return;
+	}
+
+	vesamode &= 0x1dff;  /* Clean VESA mode number from other flags */
+
+	while(XGIbios_mode[i].mode_no != 0) {
+		if( (XGIbios_mode[i].vesa_mode_no_1 == vesamode) ||
+		    (XGIbios_mode[i].vesa_mode_no_2 == vesamode) ) {
+			xgifb_mode_idx = i;
+			j = 1;
+			break;
+		}
+		i++;
+	}
+	if(!j) printk(KERN_INFO "XGIfb: Invalid VESA mode 0x%x'\n", vesamode);
+}
+
+int XGIfb_GetXG21LVDSData(void)
+{
+    u8 tmp;
+    unsigned char *pData;
+    int i,j,k;
+
+    inXGIIDXREG(XGISR,0x1e,tmp);
+    outXGIIDXREG(XGISR, 0x1e, tmp|4);
+
+    pData = xgi_video_info.mmio_vbase+0x20000;
+    if ((pData[0x0]==0x55) && (pData[0x1]==0xAA) && (pData[0x65] & 0x1))
+    {
+        i = pData[ 0x316 ] | ( pData[ 0x317 ] << 8 );
+        j = pData[ i-1 ] ;
+        if ( j == 0xff )
+        {
+	  j = 1;
+	}
+        k = 0;
+        do
+        {
+                XGI21_LCDCapList[k].LVDS_Capability = pData[ i ] | ( pData[ i + 1 ] << 8 );
+                XGI21_LCDCapList[k].LVDSHT = pData[ i + 2 ] | ( pData[ i + 3 ] << 8 ) ;
+                XGI21_LCDCapList[k].LVDSVT = pData[ i + 4 ] | ( pData[ i + 5 ] << 8 );
+                XGI21_LCDCapList[k].LVDSHDE = pData[ i + 6 ] | ( pData[ i + 7 ] << 8 );
+                XGI21_LCDCapList[k].LVDSVDE = pData[ i + 8 ] | ( pData[ i + 9 ] << 8 );
+                XGI21_LCDCapList[k].LVDSHFP = pData[ i + 10 ] | ( pData[ i + 11 ] << 8 );
+                XGI21_LCDCapList[k].LVDSVFP = pData[ i + 12 ] | ( pData[ i + 13 ] << 8 );
+                XGI21_LCDCapList[k].LVDSHSYNC = pData[ i + 14 ] | ( pData[ i + 15 ] << 8 );
+                XGI21_LCDCapList[k].LVDSVSYNC = pData[ i + 16 ] | ( pData[ i + 17 ] << 8 );
+                XGI21_LCDCapList[k].VCLKData1 = pData[ i + 18 ] ;
+                XGI21_LCDCapList[k].VCLKData2 = pData[ i + 19 ] ;
+                XGI21_LCDCapList[k].PSC_S1 = pData[ i + 20 ] ;
+                XGI21_LCDCapList[k].PSC_S2 = pData[ i + 21 ] ;
+                XGI21_LCDCapList[k].PSC_S3 = pData[ i + 22 ] ;
+                XGI21_LCDCapList[k].PSC_S4 = pData[ i + 23 ] ;
+                XGI21_LCDCapList[k].PSC_S5 = pData[ i + 24 ] ;
+                i += 25;
+                j--;
+                k++;
+        } while ( (j>0) && ( k < (sizeof(XGI21_LCDCapList)/sizeof(XGI21_LVDSCapStruct)) ) );
+        return 1;
+    }
+    return 0;
+}
+
+int XGIfb_GetXG21DefaultLVDSModeIdx(void)
+{
+
+	int found_mode = 0;
+	int XGIfb_mode_idx = 0;
+
+	found_mode = 0;
+	while( (XGIbios_mode[XGIfb_mode_idx].mode_no != 0) &&
+	       (XGIbios_mode[XGIfb_mode_idx].xres <= XGI21_LCDCapList[0].LVDSHDE) )
+	{
+		if( (XGIbios_mode[XGIfb_mode_idx].xres == XGI21_LCDCapList[0].LVDSHDE) &&
+		    (XGIbios_mode[XGIfb_mode_idx].yres == XGI21_LCDCapList[0].LVDSVDE) &&
+		    (XGIbios_mode[XGIfb_mode_idx].bpp == 8))
+		{
+			XGIfb_mode_no = XGIbios_mode[XGIfb_mode_idx].mode_no;
+			found_mode = 1;
+			break;
+		}
+		XGIfb_mode_idx++;
+	}
+        if (!found_mode)
+	  XGIfb_mode_idx = 0;
+
+	return (XGIfb_mode_idx);
+}
+
+
+static int XGIfb_validate_mode(int myindex)
+{
+   u16 xres, yres;
+
+    if (xgi_video_info.chip == XG21)
+    {
+        if ((xgi_video_info.disp_state & DISPTYPE_DISP2) == DISPTYPE_LCD)
+        {
+	    xres = XGI21_LCDCapList[0].LVDSHDE;
+	    yres = XGI21_LCDCapList[0].LVDSVDE;
+	    if(XGIbios_mode[myindex].xres > xres)
+	        return(-1);
+            if(XGIbios_mode[myindex].yres > yres)
+	        return(-1);
+            if ((XGIbios_mode[myindex].xres < xres) && (XGIbios_mode[myindex].yres < yres) )
+	    {
+              if (XGIbios_mode[myindex].bpp > 8)
+	          return(-1);
+	    }
+
+       }
+       return(myindex);
+
+    }
+
+    /* FIXME: for now, all is valid on XG27 */
+    if (xgi_video_info.chip == XG27)
+	    return(myindex);
+
+    if(!(XGIbios_mode[myindex].chipset & MD_XGI315))
+        return(-1);
+
+   switch (xgi_video_info.disp_state & DISPTYPE_DISP2) {
+     case DISPTYPE_LCD:
+	switch (XGIhw_ext.ulCRT2LCDType) {
+	case LCD_640x480:
+		xres =  640; yres =  480;  break;
+	case LCD_800x600:
+		xres =  800; yres =  600;  break;
+        case LCD_1024x600:
+		xres = 1024; yres =  600;  break;
+	case LCD_1024x768:
+	 	xres = 1024; yres =  768;  break;
+	case LCD_1152x768:
+		xres = 1152; yres =  768;  break;
+	case LCD_1280x960:
+	        xres = 1280; yres =  960;  break;
+	case LCD_1280x768:
+		xres = 1280; yres =  768;  break;
+	case LCD_1280x1024:
+		xres = 1280; yres = 1024;  break;
+	case LCD_1400x1050:
+		xres = 1400; yres = 1050;  break;
+	case LCD_1600x1200:
+		xres = 1600; yres = 1200;  break;
+//	case LCD_320x480:				// TW: FSTN
+//		xres =  320; yres =  480;  break;
+	default:
+	        xres =    0; yres =    0;  break;
+	}
+	if(XGIbios_mode[myindex].xres > xres) {
+	        return(-1);
+	}
+        if(XGIbios_mode[myindex].yres > yres) {
+	        return(-1);
+	}
+	if((XGIhw_ext.ulExternalChip == 0x01) ||   // LVDS
+           (XGIhw_ext.ulExternalChip == 0x05))    // LVDS+Chrontel
+	{
+	   switch (XGIbios_mode[myindex].xres) {
+	   	case 512:
+	       		if(XGIbios_mode[myindex].yres != 512) return -1;
+			if(XGIhw_ext.ulCRT2LCDType == LCD_1024x600) return -1;
+	       		break;
+	   	case 640:
+		       	if((XGIbios_mode[myindex].yres != 400) &&
+	           	   (XGIbios_mode[myindex].yres != 480))
+		          	return -1;
+	       		break;
+	   	case 800:
+		       	if(XGIbios_mode[myindex].yres != 600) return -1;
+	       		break;
+	   	case 1024:
+		       	if((XGIbios_mode[myindex].yres != 600) &&
+	           	   (XGIbios_mode[myindex].yres != 768))
+		          	return -1;
+			if((XGIbios_mode[myindex].yres == 600) &&
+			   (XGIhw_ext.ulCRT2LCDType != LCD_1024x600))
+			   	return -1;
+			break;
+		case 1152:
+			if((XGIbios_mode[myindex].yres) != 768) return -1;
+			if(XGIhw_ext.ulCRT2LCDType != LCD_1152x768) return -1;
+			break;
+	   	case 1280:
+		   	if((XGIbios_mode[myindex].yres != 768) &&
+	           	   (XGIbios_mode[myindex].yres != 1024))
+		          	return -1;
+			if((XGIbios_mode[myindex].yres == 768) &&
+			   (XGIhw_ext.ulCRT2LCDType != LCD_1280x768))
+			   	return -1;
+			break;
+	   	case 1400:
+		   	if(XGIbios_mode[myindex].yres != 1050) return -1;
+			break;
+	   	case 1600:
+		   	if(XGIbios_mode[myindex].yres != 1200) return -1;
+			break;
+	   	default:
+		        return -1;
+	   }
+	} else {
+	   switch (XGIbios_mode[myindex].xres) {
+	   	case 512:
+	       		if(XGIbios_mode[myindex].yres != 512) return -1;
+	       		break;
+	   	case 640:
+		       	if((XGIbios_mode[myindex].yres != 400) &&
+	           	   (XGIbios_mode[myindex].yres != 480))
+		          	return -1;
+	       		break;
+	   	case 800:
+		       	if(XGIbios_mode[myindex].yres != 600) return -1;
+	       		break;
+	   	case 1024:
+		       	if(XGIbios_mode[myindex].yres != 768) return -1;
+			break;
+	   	case 1280:
+		   	if((XGIbios_mode[myindex].yres != 960) &&
+	           	   (XGIbios_mode[myindex].yres != 1024))
+		          	return -1;
+			if(XGIbios_mode[myindex].yres == 960) {
+			    if(XGIhw_ext.ulCRT2LCDType == LCD_1400x1050)
+			   	return -1;
+			}
+			break;
+	   	case 1400:
+		   	if(XGIbios_mode[myindex].yres != 1050) return -1;
+			break;
+	   	case 1600:
+		   	if(XGIbios_mode[myindex].yres != 1200) return -1;
+			break;
+	   	default:
+		        return -1;
+	   }
+	}
+	break;
+     case DISPTYPE_TV:
+	switch (XGIbios_mode[myindex].xres) {
+	case 512:
+	case 640:
+	case 800:
+		break;
+	case 720:
+		if (xgi_video_info.TV_type == TVMODE_NTSC) {
+			if (XGIbios_mode[myindex].yres != 480) {
+				return(-1);
+			}
+		} else if (xgi_video_info.TV_type == TVMODE_PAL) {
+			if (XGIbios_mode[myindex].yres != 576) {
+				return(-1);
+			}
+		}
+		// TW: LVDS/CHRONTEL does not support 720
+		if (xgi_video_info.hasVB == HASVB_LVDS_CHRONTEL ||
+					xgi_video_info.hasVB == HASVB_CHRONTEL) {
+				return(-1);
+		}
+		break;
+	case 1024:
+		if (xgi_video_info.TV_type == TVMODE_NTSC) {
+			if(XGIbios_mode[myindex].bpp == 32) {
+			       return(-1);
+			}
+		}
+		// TW: LVDS/CHRONTEL only supports < 800 (1024 on 650/Ch7019)
+		if (xgi_video_info.hasVB == HASVB_LVDS_CHRONTEL ||
+					xgi_video_info.hasVB == HASVB_CHRONTEL) {
+		    if(xgi_video_info.chip < XGI_315H) {
+				return(-1);
+		    }
+		}
+		break;
+	default:
+		return(-1);
+	}
+	break;
+     case DISPTYPE_CRT2:
+        if(XGIbios_mode[myindex].xres > 1280) return -1;
+	break;
+     }
+     return(myindex);
+
+}
+
+static void XGIfb_search_crt2type(const char *name)
+{
+	int i = 0;
+
+	if(name == NULL)
+		return;
+
+	while(XGI_crt2type[i].type_no != -1) {
+		if (!strcmp(name, XGI_crt2type[i].name)) {
+			XGIfb_crt2type = XGI_crt2type[i].type_no;
+			XGIfb_tvplug = XGI_crt2type[i].tvplug_no;
+			break;
+		}
+		i++;
+	}
+	if(XGIfb_crt2type < 0)
+		printk(KERN_INFO "XGIfb: Invalid CRT2 type: %s\n", name);
+}
+
+static void XGIfb_search_queuemode(const char *name)
+{
+	int i = 0;
+
+	if(name == NULL)
+		return;
+
+	while (XGI_queuemode[i].type_no != -1) {
+		if (!strcmp(name, XGI_queuemode[i].name)) {
+			XGIfb_queuemode = XGI_queuemode[i].type_no;
+			break;
+		}
+		i++;
+	}
+	if (XGIfb_queuemode < 0)
+		printk(KERN_INFO "XGIfb: Invalid queuemode type: %s\n", name);
+}
+
+static u8 XGIfb_search_refresh_rate(unsigned int rate)
+{
+	u16 xres, yres;
+	int i = 0;
+
+	xres = XGIbios_mode[xgifb_mode_idx].xres;
+	yres = XGIbios_mode[xgifb_mode_idx].yres;
+
+	XGIfb_rate_idx = 0;
+	while ((XGIfb_vrate[i].idx != 0) && (XGIfb_vrate[i].xres <= xres)) {
+		if ((XGIfb_vrate[i].xres == xres) && (XGIfb_vrate[i].yres == yres)) {
+			if (XGIfb_vrate[i].refresh == rate) {
+				XGIfb_rate_idx = XGIfb_vrate[i].idx;
+				break;
+			} else if (XGIfb_vrate[i].refresh > rate) {
+				if ((XGIfb_vrate[i].refresh - rate) <= 3) {
+					DPRINTK("XGIfb: Adjusting rate from %d up to %d\n",
+						rate, XGIfb_vrate[i].refresh);
+					XGIfb_rate_idx = XGIfb_vrate[i].idx;
+					xgi_video_info.refresh_rate = XGIfb_vrate[i].refresh;
+				} else if (((rate - XGIfb_vrate[i-1].refresh) <= 2)
+						&& (XGIfb_vrate[i].idx != 1)) {
+					DPRINTK("XGIfb: Adjusting rate from %d down to %d\n",
+						rate, XGIfb_vrate[i-1].refresh);
+					XGIfb_rate_idx = XGIfb_vrate[i-1].idx;
+					xgi_video_info.refresh_rate = XGIfb_vrate[i-1].refresh;
+				}
+				break;
+			} else if((rate - XGIfb_vrate[i].refresh) <= 2) {
+				DPRINTK("XGIfb: Adjusting rate from %d down to %d\n",
+						rate, XGIfb_vrate[i].refresh);
+	           		XGIfb_rate_idx = XGIfb_vrate[i].idx;
+		   		break;
+	       		}
+		}
+		i++;
+	}
+	if (XGIfb_rate_idx > 0) {
+		return XGIfb_rate_idx;
+	} else {
+		printk(KERN_INFO
+			"XGIfb: Unsupported rate %d for %dx%d\n", rate, xres, yres);
+		return 0;
+	}
+}
+
+static void XGIfb_search_tvstd(const char *name)
+{
+	int i = 0;
+
+	if(name == NULL)
+		return;
+
+	while (XGI_tvtype[i].type_no != -1) {
+		if (!strcmp(name, XGI_tvtype[i].name)) {
+			XGIfb_tvmode = XGI_tvtype[i].type_no;
+			break;
+		}
+		i++;
+	}
+}
+
+static BOOLEAN XGIfb_bridgeisslave(void)
+{
+   unsigned char usScratchP1_00;
+
+   if(xgi_video_info.hasVB == HASVB_NONE) return FALSE;
+
+   inXGIIDXREG(XGIPART1,0x00,usScratchP1_00);
+   if( (usScratchP1_00 & 0x50) == 0x10)  {
+	   return TRUE;
+   } else {
+           return FALSE;
+   }
+}
+
+static BOOLEAN XGIfbcheckvretracecrt1(void)
+{
+   unsigned char temp;
+
+   inXGIIDXREG(XGICR,0x17,temp);
+   if(!(temp & 0x80)) return FALSE;
+
+
+   inXGIIDXREG(XGISR,0x1f,temp);
+   if(temp & 0xc0) return FALSE;
+
+
+   if(inXGIREG(XGIINPSTAT) & 0x08) return TRUE;
+   else 			   return FALSE;
+}
+
+static BOOLEAN XGIfbcheckvretracecrt2(void)
+{
+   unsigned char temp;
+   if(xgi_video_info.hasVB == HASVB_NONE) return FALSE;
+   inXGIIDXREG(XGIPART1, 0x30, temp);
+   if(temp & 0x02) return FALSE;
+   else 	   return TRUE;
+}
+
+static BOOLEAN XGIfb_CheckVBRetrace(void)
+{
+   if(xgi_video_info.disp_state & DISPTYPE_DISP2) {
+      if(XGIfb_bridgeisslave()) {
+         return(XGIfbcheckvretracecrt1());
+      } else {
+         return(XGIfbcheckvretracecrt2());
+      }
+   }
+   return(XGIfbcheckvretracecrt1());
+}
+
+/* ----------- FBDev related routines for all series ----------- */
+
+
+static void XGIfb_bpp_to_var(struct fb_var_screeninfo *var)
+{
+	switch(var->bits_per_pixel) {
+	   case 8:
+	   	var->red.offset = var->green.offset = var->blue.offset = 0;
+		var->red.length = var->green.length = var->blue.length = 6;
+		xgi_video_info.video_cmap_len = 256;
+		break;
+	   case 16:
+		var->red.offset = 11;
+		var->red.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->blue.offset = 0;
+		var->blue.length = 5;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		xgi_video_info.video_cmap_len = 16;
+		break;
+	   case 32:
+		var->red.offset = 16;
+		var->red.length = 8;
+		var->green.offset = 8;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->transp.offset = 24;
+		var->transp.length = 8;
+		xgi_video_info.video_cmap_len = 16;
+		break;
+	}
+}
+
+
+
+static int XGIfb_do_set_var(struct fb_var_screeninfo *var, int isactive,
+		      struct fb_info *info)
+{
+
+	unsigned int htotal = var->left_margin + var->xres +
+		var->right_margin + var->hsync_len;
+	unsigned int vtotal = var->upper_margin + var->yres +
+		var->lower_margin + var->vsync_len;
+#if defined(__powerpc__)
+	u8 sr_data, cr_data;
+#endif
+	unsigned int drate = 0, hrate = 0;
+	int found_mode = 0;
+	int old_mode;
+//	unsigned char reg,reg1;
+
+	DEBUGPRN("Inside do_set_var");
+//        printk(KERN_DEBUG "XGIfb:var->yres=%d, var->upper_margin=%d, var->lower_margin=%d, var->vsync_len=%d\n", var->yres,var->upper_margin,var->lower_margin,var->vsync_len);
+
+        info->var.xres_virtual = var->xres_virtual;
+        info->var.yres_virtual = var->yres_virtual;
+        info->var.bits_per_pixel = var->bits_per_pixel;
+
+	if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED)
+		vtotal <<= 1;
+	else if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE)
+		vtotal <<= 2;
+	else if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)
+	{
+//		vtotal <<= 1;
+//		var->yres <<= 1;
+	}
+
+	if(!htotal || !vtotal) {
+		DPRINTK("XGIfb: Invalid 'var' information\n");
+		return -EINVAL;
+	}
+        printk(KERN_DEBUG "XGIfb: var->pixclock=%d, htotal=%d, vtotal=%d\n",
+                var->pixclock,htotal,vtotal);
+
+
+
+	if(var->pixclock && htotal && vtotal) {
+		drate = 1000000000 / var->pixclock;
+		hrate = (drate * 1000) / htotal;
+		xgi_video_info.refresh_rate = (unsigned int) (hrate * 2 / vtotal);
+	} else {
+		xgi_video_info.refresh_rate = 60;
+	}
+
+	printk(KERN_DEBUG "XGIfb: Change mode to %dx%dx%d-%dHz\n",
+		var->xres,var->yres,var->bits_per_pixel,xgi_video_info.refresh_rate);
+
+	old_mode = xgifb_mode_idx;
+	xgifb_mode_idx = 0;
+
+	while( (XGIbios_mode[xgifb_mode_idx].mode_no != 0) &&
+	       (XGIbios_mode[xgifb_mode_idx].xres <= var->xres) ) {
+		if( (XGIbios_mode[xgifb_mode_idx].xres == var->xres) &&
+		    (XGIbios_mode[xgifb_mode_idx].yres == var->yres) &&
+		    (XGIbios_mode[xgifb_mode_idx].bpp == var->bits_per_pixel)) {
+			XGIfb_mode_no = XGIbios_mode[xgifb_mode_idx].mode_no;
+			found_mode = 1;
+			break;
+		}
+		xgifb_mode_idx++;
+	}
+
+	if(found_mode)
+		xgifb_mode_idx = XGIfb_validate_mode(xgifb_mode_idx);
+	else
+		xgifb_mode_idx = -1;
+
+       	if(xgifb_mode_idx < 0) {
+		printk(KERN_ERR "XGIfb: Mode %dx%dx%d not supported\n", var->xres,
+		       var->yres, var->bits_per_pixel);
+		xgifb_mode_idx = old_mode;
+		return -EINVAL;
+	}
+
+	if(XGIfb_search_refresh_rate(xgi_video_info.refresh_rate) == 0) {
+		XGIfb_rate_idx = XGIbios_mode[xgifb_mode_idx].rate_idx;
+		xgi_video_info.refresh_rate = 60;
+	}
+
+	if(isactive) {
+
+
+		XGIfb_pre_setmode();
+		if(XGISetModeNew( &XGIhw_ext, XGIfb_mode_no) == 0) {
+			printk(KERN_ERR "XGIfb: Setting mode[0x%x] failed\n", XGIfb_mode_no);
+			return -EINVAL;
+		}
+	info->fix.line_length = ((info->var.xres_virtual * info->var.bits_per_pixel)>>6);
+
+	outXGIIDXREG(XGISR,IND_XGI_PASSWORD,XGI_PASSWORD);
+
+		outXGIIDXREG(XGICR,0x13,(info->fix.line_length & 0x00ff));
+		outXGIIDXREG(XGISR,0x0E,(info->fix.line_length & 0xff00)>>8);
+
+		XGIfb_post_setmode();
+
+		DPRINTK("XGIfb: Set new mode: %dx%dx%d-%d \n",
+			XGIbios_mode[xgifb_mode_idx].xres,
+			XGIbios_mode[xgifb_mode_idx].yres,
+			XGIbios_mode[xgifb_mode_idx].bpp,
+			xgi_video_info.refresh_rate);
+
+		xgi_video_info.video_bpp = XGIbios_mode[xgifb_mode_idx].bpp;
+		xgi_video_info.video_vwidth = info->var.xres_virtual;
+		xgi_video_info.video_width = XGIbios_mode[xgifb_mode_idx].xres;
+		xgi_video_info.video_vheight = info->var.yres_virtual;
+		xgi_video_info.video_height = XGIbios_mode[xgifb_mode_idx].yres;
+		xgi_video_info.org_x = xgi_video_info.org_y = 0;
+		xgi_video_info.video_linelength = info->var.xres_virtual * (xgi_video_info.video_bpp >> 3);
+		xgi_video_info.accel = 0;
+		if(XGIfb_accel) {
+		   xgi_video_info.accel = (var->accel_flags & FB_ACCELF_TEXT) ? -1 : 0;
+		}
+		switch(xgi_video_info.video_bpp)
+		{
+        	case 8:
+           		xgi_video_info.DstColor = 0x0000;
+	    		xgi_video_info.XGI310_AccelDepth = 0x00000000;
+ 			    xgi_video_info.video_cmap_len = 256;
+#if defined(__powerpc__)
+                inXGIIDXREG (XGICR, 0x4D, cr_data);
+                outXGIIDXREG(XGICR, 0x4D, (cr_data & 0xE0));
+#endif
+                break;
+        	case 16:
+            	xgi_video_info.DstColor = 0x8000;
+            	xgi_video_info.XGI310_AccelDepth = 0x00010000;
+#if defined(__powerpc__)
+                inXGIIDXREG (XGICR, 0x4D, cr_data);
+                outXGIIDXREG(XGICR, 0x4D, ((cr_data & 0xE0) | 0x0B));
+#endif
+			    xgi_video_info.video_cmap_len = 16;
+            	break;
+        	case 32:
+            	xgi_video_info.DstColor = 0xC000;
+	    		xgi_video_info.XGI310_AccelDepth = 0x00020000;
+			    xgi_video_info.video_cmap_len = 16;
+#if defined(__powerpc__)
+                inXGIIDXREG (XGICR, 0x4D, cr_data);
+                outXGIIDXREG(XGICR, 0x4D, ((cr_data & 0xE0) | 0x15));
+#endif
+            	break;
+		    default:
+			    xgi_video_info.video_cmap_len = 16;
+		        printk(KERN_ERR "XGIfb: Unsupported depth %d", xgi_video_info.video_bpp);
+			    xgi_video_info.accel = 0;
+			    break;
+    	}
+	}
+	XGIfb_bpp_to_var(var); /*update ARGB info*/
+	DEBUGPRN("End of do_set_var");
+
+	dumpVGAReg();
+	return 0;
+}
+
+#ifdef XGIFB_PAN
+static int XGIfb_pan_var(struct fb_var_screeninfo *var)
+{
+	unsigned int base;
+
+//	printk("Inside pan_var");
+
+	if (var->xoffset > (var->xres_virtual - var->xres)) {
+//	        printk( "Pan: xo: %d xv %d xr %d\n",
+//			var->xoffset, var->xres_virtual, var->xres);
+		return -EINVAL;
+	}
+	if(var->yoffset > (var->yres_virtual - var->yres)) {
+//		printk( "Pan: yo: %d yv %d yr %d\n",
+//			var->yoffset, var->yres_virtual, var->yres);
+		return -EINVAL;
+	}
+        base = var->yoffset * var->xres_virtual + var->xoffset;
+
+        /* calculate base bpp dep. */
+        switch(var->bits_per_pixel) {
+        case 16:
+        	base >>= 1;
+        	break;
+	case 32:
+            	break;
+	case 8:
+        default:
+        	base >>= 2;
+            	break;
+        }
+
+	outXGIIDXREG(XGISR, IND_XGI_PASSWORD, XGI_PASSWORD);
+
+        outXGIIDXREG(XGICR, 0x0D, base & 0xFF);
+	outXGIIDXREG(XGICR, 0x0C, (base >> 8) & 0xFF);
+	outXGIIDXREG(XGISR, 0x0D, (base >> 16) & 0xFF);
+        outXGIIDXREG(XGISR, 0x37, (base >> 24) & 0x03);
+	setXGIIDXREG(XGISR, 0x37, 0xDF, (base >> 21) & 0x04);
+
+        if(xgi_video_info.disp_state & DISPTYPE_DISP2) {
+		orXGIIDXREG(XGIPART1, XGIfb_CRT2_write_enable, 0x01);
+        	outXGIIDXREG(XGIPART1, 0x06, (base & 0xFF));
+        	outXGIIDXREG(XGIPART1, 0x05, ((base >> 8) & 0xFF));
+        	outXGIIDXREG(XGIPART1, 0x04, ((base >> 16) & 0xFF));
+		setXGIIDXREG(XGIPART1, 0x02, 0x7F, ((base >> 24) & 0x01) << 7);
+        }
+//	printk("End of pan_var");
+	return 0;
+}
+#endif
+
+
+void XGI_dispinfo(struct ap_data *rec)
+{
+	rec->minfo.bpp    = xgi_video_info.video_bpp;
+	rec->minfo.xres   = xgi_video_info.video_width;
+	rec->minfo.yres   = xgi_video_info.video_height;
+	rec->minfo.v_xres = xgi_video_info.video_vwidth;
+	rec->minfo.v_yres = xgi_video_info.video_vheight;
+	rec->minfo.org_x  = xgi_video_info.org_x;
+	rec->minfo.org_y  = xgi_video_info.org_y;
+	rec->minfo.vrate  = xgi_video_info.refresh_rate;
+	rec->iobase       = xgi_video_info.vga_base - 0x30;
+	rec->mem_size     = xgi_video_info.video_size;
+	rec->disp_state   = xgi_video_info.disp_state;
+	rec->version      = (VER_MAJOR << 24) | (VER_MINOR << 16) | VER_LEVEL;
+	rec->hasVB        = xgi_video_info.hasVB;
+	rec->TV_type      = xgi_video_info.TV_type;
+	rec->TV_plug      = xgi_video_info.TV_plug;
+	rec->chip         = xgi_video_info.chip;
+}
+
+
+
+
+static int XGIfb_open(struct fb_info *info, int user)
+{
+    return 0;
+}
+
+static int XGIfb_release(struct fb_info *info, int user)
+{
+    return 0;
+}
+
+static int XGIfb_get_cmap_len(const struct fb_var_screeninfo *var)
+{
+	int rc = 16;
+
+	switch(var->bits_per_pixel) {
+	case 8:
+		rc = 256;
+		break;
+	case 16:
+		rc = 16;
+		break;
+	case 32:
+		rc = 16;
+		break;
+	}
+	return rc;
+}
+
+static int XGIfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue,
+                           unsigned transp, struct fb_info *info)
+{
+	if (regno >= XGIfb_get_cmap_len(&info->var))
+		return 1;
+
+	switch (info->var.bits_per_pixel) {
+	case 8:
+	        outXGIREG(XGIDACA, regno);
+		outXGIREG(XGIDACD, (red >> 10));
+		outXGIREG(XGIDACD, (green >> 10));
+		outXGIREG(XGIDACD, (blue >> 10));
+		if (xgi_video_info.disp_state & DISPTYPE_DISP2) {
+		        outXGIREG(XGIDAC2A, regno);
+			outXGIREG(XGIDAC2D, (red >> 8));
+			outXGIREG(XGIDAC2D, (green >> 8));
+			outXGIREG(XGIDAC2D, (blue >> 8));
+		}
+		break;
+	case 16:
+		((u32 *)(info->pseudo_palette))[regno] =
+		    ((red & 0xf800)) | ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);
+		break;
+	case 32:
+		red >>= 8;
+		green >>= 8;
+		blue >>= 8;
+		((u32 *) (info->pseudo_palette))[regno] =
+			(red << 16) | (green << 8) | (blue);
+		break;
+	}
+	return 0;
+}
+
+static int XGIfb_set_par(struct fb_info *info)
+{
+	int err;
+
+//	printk("XGIfb: inside set_par\n");
+        if((err = XGIfb_do_set_var(&info->var, 1, info)))
+		return err;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+	XGIfb_get_fix(&info->fix, info->currcon, info);
+#else
+	XGIfb_get_fix(&info->fix, -1, info);
+#endif
+//	printk("XGIfb:end of set_par\n");
+	return 0;
+}
+
+static int XGIfb_check_var(struct fb_var_screeninfo *var,
+                           struct fb_info *info)
+{
+	unsigned int htotal =
+		var->left_margin + var->xres + var->right_margin +
+		var->hsync_len;
+	unsigned int vtotal = 0;
+	unsigned int drate = 0, hrate = 0;
+	int found_mode = 0;
+	int refresh_rate, search_idx;
+
+	DEBUGPRN("Inside check_var");
+
+	if((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED) {
+		vtotal = var->upper_margin + var->yres + var->lower_margin +
+		         var->vsync_len;
+		vtotal <<= 1;
+	} else if((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
+		vtotal = var->upper_margin + var->yres + var->lower_margin +
+		         var->vsync_len;
+		vtotal <<= 2;
+	} else if((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
+		vtotal = var->upper_margin + (var->yres/2) + var->lower_margin +
+		         var->vsync_len;
+	} else 	vtotal = var->upper_margin + var->yres + var->lower_margin +
+		         var->vsync_len;
+
+	if(!(htotal) || !(vtotal)) {
+		XGIFAIL("XGIfb: no valid timing data");
+	}
+
+
+        if(var->pixclock && htotal && vtotal) {
+                drate = 1000000000 / var->pixclock;
+                hrate = (drate * 1000) / htotal;
+                xgi_video_info.refresh_rate = (unsigned int) (hrate * 2 / vtotal);
+	printk(KERN_DEBUG \
+		"%s: pixclock = %d ,htotal=%d, vtotal=%d\n" \
+		"%s: drate=%d, hrate=%d, refresh_rate=%d\n",
+		__func__,var->pixclock, htotal, vtotal,
+		__func__, drate, hrate, xgi_video_info.refresh_rate);
+        } else {
+                xgi_video_info.refresh_rate = 60;
+        }
+
+/*
+	if((var->pixclock) && (htotal)) {
+	   drate = 1E12 / var->pixclock;
+	   hrate = drate / htotal;
+	   refresh_rate = (unsigned int) (hrate / vtotal * 2 + 0.5);
+	} else refresh_rate = 60;
+*/
+	/* TW: Calculation wrong for 1024x600 - force it to 60Hz */
+	if((var->xres == 1024) && (var->yres == 600)) refresh_rate = 60;
+
+	search_idx = 0;
+	while((XGIbios_mode[search_idx].mode_no != 0) &&
+	       (XGIbios_mode[search_idx].xres <= var->xres) ) {
+	    if((XGIbios_mode[search_idx].xres == var->xres) &&
+	       (XGIbios_mode[search_idx].yres == var->yres) &&
+		    (XGIbios_mode[search_idx].bpp == var->bits_per_pixel)) {
+		        if(XGIfb_validate_mode(search_idx) > 0) {
+		    found_mode = 1;
+		    break;
+	        }
+	    }
+		search_idx++;
+	}
+
+	if(!found_mode) {
+
+		printk(KERN_ERR "XGIfb: %dx%dx%d is no valid mode\n",
+			var->xres, var->yres, var->bits_per_pixel);
+
+                search_idx = 0;
+		while(XGIbios_mode[search_idx].mode_no != 0) {
+
+		   if( (var->xres <= XGIbios_mode[search_idx].xres) &&
+		       (var->yres <= XGIbios_mode[search_idx].yres) &&
+		       (var->bits_per_pixel == XGIbios_mode[search_idx].bpp) ) {
+		          if(XGIfb_validate_mode(search_idx) > 0) {
+			     found_mode = 1;
+			     break;
+			  }
+		   }
+		   search_idx++;
+	        }
+		if(found_mode) {
+			var->xres = XGIbios_mode[search_idx].xres;
+		      	var->yres = XGIbios_mode[search_idx].yres;
+		      	printk(KERN_DEBUG "XGIfb: Adapted to mode %dx%dx%d\n",
+		   		var->xres, var->yres, var->bits_per_pixel);
+
+		} else {
+		   	printk(KERN_ERR "XGIfb: Failed to find similar mode to %dx%dx%d\n",
+				var->xres, var->yres, var->bits_per_pixel);
+		   	return -EINVAL;
+		}
+	}
+
+	/* TW: TODO: Check the refresh rate */
+
+	/* Adapt RGB settings */
+	XGIfb_bpp_to_var(var);
+
+	/* Sanity check for offsets */
+	if (var->xoffset < 0)
+		var->xoffset = 0;
+	if (var->yoffset < 0)
+		var->yoffset = 0;
+
+
+	if(!XGIfb_ypan) {
+		if(var->xres != var->xres_virtual)
+			 var->xres_virtual = var->xres;
+		if(var->yres != var->yres_virtual)
+			var->yres_virtual = var->yres;
+	}/* else {
+	   // TW: Now patch yres_virtual if we use panning
+	   // May I do this?
+	   var->yres_virtual = xgi_video_info.heapstart / (var->xres * (var->bits_per_pixel >> 3));
+	    if(var->yres_virtual <= var->yres) {
+	    	// TW: Paranoia check
+	        var->yres_virtual = var->yres;
+	    }
+	}*/
+
+	/* Truncate offsets to maximum if too high */
+	if (var->xoffset > var->xres_virtual - var->xres)
+		var->xoffset = var->xres_virtual - var->xres - 1;
+
+	if (var->yoffset > var->yres_virtual - var->yres)
+		var->yoffset = var->yres_virtual - var->yres - 1;
+
+	/* Set everything else to 0 */
+	var->red.msb_right =
+	    var->green.msb_right =
+	    var->blue.msb_right =
+	    var->transp.offset = var->transp.length = var->transp.msb_right = 0;
+
+	DEBUGPRN("end of check_var");
+	return 0;
+}
+
+#ifdef XGIFB_PAN
+static int XGIfb_pan_display( struct fb_var_screeninfo *var,
+				 struct fb_info* info)
+{
+	int err;
+
+//	printk("\nInside pan_display:");
+
+	if (var->xoffset > (var->xres_virtual - var->xres))
+		return -EINVAL;
+	if (var->yoffset > (var->yres_virtual - var->yres))
+		return -EINVAL;
+
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset < 0
+		    || var->yoffset >= info->var.yres_virtual
+		    || var->xoffset) return -EINVAL;
+	} else {
+		if (var->xoffset + info->var.xres > info->var.xres_virtual ||
+		    var->yoffset + info->var.yres > info->var.yres_virtual)
+			return -EINVAL;
+	}
+
+	if((err = XGIfb_pan_var(var)) < 0) return err;
+
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+
+//	printk(" End of pan_display");
+	return 0;
+}
+#endif
+
+#if 0
+static int XGIfb_mmap(struct fb_info *info, struct file *file,
+		      struct vm_area_struct *vma)
+{
+	unsigned long start;
+	unsigned long off;
+	u32 len, mmio_off;
+
+	DEBUGPRN("inside mmap");
+	if(vma->vm_pgoff > (~0UL >> PAGE_SHIFT))  return -EINVAL;
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+
+	start = (unsigned long) xgi_video_info.video_base;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + xgi_video_info.video_size);
+	start &= PAGE_MASK;
+#if 0
+	if (off >= len) {
+		off -= len;
+#endif
+	/* By Jake Page: Treat mmap request with offset beyond heapstart
+	 *               as request for mapping the mmio area
+	 */
+	#if 1
+	mmio_off = PAGE_ALIGN((start & ~PAGE_MASK) + xgi_video_info.heapstart);
+	if(off >= mmio_off) {
+		off -= mmio_off;
+		if(info->var.accel_flags) return -EINVAL;
+
+		start = (unsigned long) xgi_video_info.mmio_base;
+		len = PAGE_ALIGN((start & ~PAGE_MASK) + XGIfb_mmio_size);
+	}
+	start &= PAGE_MASK;
+	#endif
+	if((vma->vm_end - vma->vm_start + off) > len)	return -EINVAL;
+
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+	vma->vm_flags |= VM_IO;   /* by Jake Page; is that really needed? */
+
+#if defined(__i386__) || defined(__x86_64__)
+	if (boot_cpu_data.x86 > 3)
+		pgprot_val(vma->vm_page_prot) |= _PAGE_PCD;
+#endif
+	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT, vma->vm_end - vma->vm_start,
+				vma->vm_page_prot))
+		return -EAGAIN;
+
+        DEBUGPRN("end of mmap");
+	return 0;
+}
+#endif
+static int XGIfb_blank(int blank, struct fb_info *info)
+{
+	u8 reg;
+
+	inXGIIDXREG(XGICR, 0x17, reg);
+
+	if(blank > 0)
+		reg &= 0x7f;
+	else
+		reg |= 0x80;
+
+        outXGIIDXREG(XGICR, 0x17, reg);
+	outXGIIDXREG(XGISR, 0x00, 0x01);    /* Synchronous Reset */
+	outXGIIDXREG(XGISR, 0x00, 0x03);    /* End Reset */
+        return(0);
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+static int XGIfb_ioctl(struct fb_info *info, unsigned int cmd,
+			    unsigned long arg)
+#else
+static int XGIfb_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg,
+		       struct fb_info *info)
+#endif
+
+{
+	DEBUGPRN("inside ioctl");
+	switch (cmd) {
+	   case FBIO_ALLOC:
+		if (!capable(CAP_SYS_RAWIO))
+			return -EPERM;
+		XGI_malloc((struct XGI_memreq *) arg);
+		break;
+	   case FBIO_FREE:
+		if (!capable(CAP_SYS_RAWIO))
+			return -EPERM;
+		XGI_free(*(unsigned long *) arg);
+		break;
+	   case FBIOGET_HWCINFO:
+		{
+			unsigned long *hwc_offset = (unsigned long *) arg;
+
+			if (XGIfb_caps & HW_CURSOR_CAP)
+				*hwc_offset = XGIfb_hwcursor_vbase -
+				    (unsigned long) xgi_video_info.video_vbase;
+			else
+				*hwc_offset = 0;
+
+			break;
+		}
+	   case FBIOPUT_MODEINFO:
+		{
+			struct mode_info *x = (struct mode_info *)arg;
+
+			xgi_video_info.video_bpp        = x->bpp;
+			xgi_video_info.video_width      = x->xres;
+			xgi_video_info.video_height     = x->yres;
+			xgi_video_info.video_vwidth     = x->v_xres;
+			xgi_video_info.video_vheight    = x->v_yres;
+			xgi_video_info.org_x            = x->org_x;
+			xgi_video_info.org_y            = x->org_y;
+			xgi_video_info.refresh_rate     = x->vrate;
+			xgi_video_info.video_linelength = xgi_video_info.video_vwidth * (xgi_video_info.video_bpp >> 3);
+			switch(xgi_video_info.video_bpp) {
+        		case 8:
+            			xgi_video_info.DstColor = 0x0000;
+	    			xgi_video_info.XGI310_AccelDepth = 0x00000000;
+				xgi_video_info.video_cmap_len = 256;
+            			break;
+        		case 16:
+            			xgi_video_info.DstColor = 0x8000;
+            			xgi_video_info.XGI310_AccelDepth = 0x00010000;
+				xgi_video_info.video_cmap_len = 16;
+            			break;
+        		case 32:
+            			xgi_video_info.DstColor = 0xC000;
+	    			xgi_video_info.XGI310_AccelDepth = 0x00020000;
+				xgi_video_info.video_cmap_len = 16;
+            			break;
+			default:
+				xgi_video_info.video_cmap_len = 16;
+		       	 	printk(KERN_ERR "XGIfb: Unsupported accel depth %d", xgi_video_info.video_bpp);
+				xgi_video_info.accel = 0;
+				break;
+    			}
+
+			break;
+		}
+	   case FBIOGET_DISPINFO:
+		XGI_dispinfo((struct ap_data *)arg);
+		break;
+	   case XGIFB_GET_INFO:  /* TW: New for communication with X driver */
+	        {
+			XGIfb_info *x = (XGIfb_info *)arg;
+
+			//x->XGIfb_id = XGIFB_ID;
+			x->XGIfb_version = VER_MAJOR;
+			x->XGIfb_revision = VER_MINOR;
+			x->XGIfb_patchlevel = VER_LEVEL;
+			x->chip_id = xgi_video_info.chip_id;
+			x->memory = xgi_video_info.video_size / 1024;
+			x->heapstart = xgi_video_info.heapstart / 1024;
+			x->fbvidmode = XGIfb_mode_no;
+			x->XGIfb_caps = XGIfb_caps;
+			x->XGIfb_tqlen = 512; /* yet unused */
+			x->XGIfb_pcibus = xgi_video_info.pcibus;
+			x->XGIfb_pcislot = xgi_video_info.pcislot;
+			x->XGIfb_pcifunc = xgi_video_info.pcifunc;
+			x->XGIfb_lcdpdc = XGIfb_detectedpdc;
+			x->XGIfb_lcda = XGIfb_detectedlcda;
+	                break;
+		}
+	   case XGIFB_GET_VBRSTATUS:
+	        {
+			unsigned long *vbrstatus = (unsigned long *) arg;
+			if(XGIfb_CheckVBRetrace()) *vbrstatus = 1;
+			else		           *vbrstatus = 0;
+		}
+	   default:
+		return -EINVAL;
+	}
+	DEBUGPRN("end of ioctl");
+	return 0;
+
+}
+
+
+
+/* ----------- FBDev related routines for all series ---------- */
+
+static int XGIfb_get_fix(struct fb_fix_screeninfo *fix, int con,
+			 struct fb_info *info)
+{
+	DEBUGPRN("inside get_fix");
+	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+
+	strcpy(fix->id, myid);
+
+	fix->smem_start = xgi_video_info.video_base;
+
+	fix->smem_len = xgi_video_info.video_size;
+
+
+/*        if((!XGIfb_mem) || (XGIfb_mem > (xgi_video_info.video_size/1024))) {
+	    if (xgi_video_info.video_size > 0x1000000) {
+	        fix->smem_len = 0xD00000;
+	    } else if (xgi_video_info.video_size > 0x800000)
+		fix->smem_len = 0x800000;
+	    else
+		fix->smem_len = 0x400000;
+        } else
+		fix->smem_len = XGIfb_mem * 1024;
+*/
+	fix->type        = video_type;
+	fix->type_aux    = 0;
+	if(xgi_video_info.video_bpp == 8)
+		fix->visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		fix->visual = FB_VISUAL_DIRECTCOLOR;
+	fix->xpanstep    = 0;
+#ifdef XGIFB_PAN
+        if(XGIfb_ypan) 	 fix->ypanstep = 1;
+#endif
+	fix->ywrapstep   = 0;
+	fix->line_length = xgi_video_info.video_linelength;
+	fix->mmio_start  = xgi_video_info.mmio_base;
+	fix->mmio_len    = XGIfb_mmio_size;
+    if(xgi_video_info.chip >= XG40)
+	   fix->accel    = FB_ACCEL_XGI_XABRE;
+	else
+	   fix->accel    = FB_ACCEL_XGI_GLAMOUR_2;
+
+
+	DEBUGPRN("end of get_fix");
+	return 0;
+}
+
+
+static struct fb_ops XGIfb_ops = {
+	.owner        =	THIS_MODULE,
+	.fb_open      = XGIfb_open,
+	.fb_release   = XGIfb_release,
+	.fb_check_var = XGIfb_check_var,
+	.fb_set_par   = XGIfb_set_par,
+	.fb_setcolreg = XGIfb_setcolreg,
+#ifdef XGIFB_PAN
+        .fb_pan_display = XGIfb_pan_display,
+#endif
+        .fb_blank     = XGIfb_blank,
+	.fb_fillrect  = fbcon_XGI_fillrect,
+	.fb_copyarea  = fbcon_XGI_copyarea,
+	.fb_imageblit = cfb_imageblit,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+	.fb_cursor    = soft_cursor,
+#endif
+	.fb_sync      = fbcon_XGI_sync,
+	.fb_ioctl     =	XGIfb_ioctl,
+//	.fb_mmap      =	XGIfb_mmap,
+};
+
+/* ---------------- Chip generation dependent routines ---------------- */
+
+
+/* for XGI 315/550/650/740/330 */
+
+static int XGIfb_get_dram_size(void)
+{
+
+	u8  ChannelNum,tmp;
+	u8  reg = 0;
+
+	/* xorg driver sets 32MB * 1 channel */
+	if (xgi_video_info.chip == XG27)
+		outXGIIDXREG(XGISR, IND_XGI_DRAM_SIZE, 0x51);
+
+	        inXGIIDXREG(XGISR, IND_XGI_DRAM_SIZE, reg);
+		switch ((reg & XGI_DRAM_SIZE_MASK) >> 4) {
+		   case XGI_DRAM_SIZE_1MB:
+			xgi_video_info.video_size = 0x100000;
+			break;
+		   case XGI_DRAM_SIZE_2MB:
+			xgi_video_info.video_size = 0x200000;
+			break;
+		   case XGI_DRAM_SIZE_4MB:
+			xgi_video_info.video_size = 0x400000;
+			break;
+		   case XGI_DRAM_SIZE_8MB:
+			xgi_video_info.video_size = 0x800000;
+			break;
+		   case XGI_DRAM_SIZE_16MB:
+			xgi_video_info.video_size = 0x1000000;
+			break;
+		   case XGI_DRAM_SIZE_32MB:
+			xgi_video_info.video_size = 0x2000000;
+			break;
+		   case XGI_DRAM_SIZE_64MB:
+			xgi_video_info.video_size = 0x4000000;
+			break;
+		   case XGI_DRAM_SIZE_128MB:
+			xgi_video_info.video_size = 0x8000000;
+			break;
+		   case XGI_DRAM_SIZE_256MB:
+			xgi_video_info.video_size = 0x10000000;
+			break;
+		   default:
+			return -1;
+		}
+
+		tmp = (reg & 0x0c) >> 2;
+		switch(xgi_video_info.chip)
+		{
+		    case XG20:
+                    case XG21:
+		    case XG27:
+		        ChannelNum = 1;
+		        break;
+
+		    case XG42:
+		        if(reg & 0x04)
+		            ChannelNum = 2;
+		        else
+		            ChannelNum = 1;
+		        break;
+
+		    case XG45:
+		        if(tmp == 1)
+                    ChannelNum = 2;
+                else
+                if(tmp == 2)
+                    ChannelNum = 3;
+                else
+                if(tmp == 3)
+                    ChannelNum = 4;
+                else
+                    ChannelNum = 1;
+		        break;
+
+		    case XG40:
+		    default:
+                if(tmp == 2)
+                    ChannelNum = 2;
+                else
+                if(tmp == 3)
+                    ChannelNum = 3;
+                else
+                    ChannelNum = 1;
+		        break;
+		}
+
+
+		xgi_video_info.video_size = xgi_video_info.video_size * ChannelNum;
+		//PLiad fixed for benchmarking and fb set
+		//xgi_video_info.video_size = 0x200000;//1024x768x16
+		//xgi_video_info.video_size = 0x1000000;//benchmark
+
+		printk("XGIfb: SR14=%x DramSzie %x ChannelNum %x\n",reg,xgi_video_info.video_size ,ChannelNum );
+		return 0;
+
+}
+
+static void XGIfb_detect_VB(void)
+{
+	u8 cr32, temp=0;
+
+	xgi_video_info.TV_plug = xgi_video_info.TV_type = 0;
+
+        switch(xgi_video_info.hasVB) {
+	  case HASVB_LVDS_CHRONTEL:
+	  case HASVB_CHRONTEL:
+	     break;
+	  case HASVB_301:
+	  case HASVB_302:
+//	     XGI_Sense30x(); //Yi-Lin TV Sense?
+	     break;
+	}
+
+	inXGIIDXREG(XGICR, IND_XGI_SCRATCH_REG_CR32, cr32);
+
+	if ((cr32 & XGI_CRT1) && !XGIfb_crt1off)
+		XGIfb_crt1off = 0;
+	else {
+		if (cr32 & 0x5F)
+			XGIfb_crt1off = 1;
+		else
+			XGIfb_crt1off = 0;
+	}
+
+	if (XGIfb_crt2type != -1)
+		/* TW: Override with option */
+		xgi_video_info.disp_state = XGIfb_crt2type;
+	else if (cr32 & XGI_VB_TV)
+		xgi_video_info.disp_state = DISPTYPE_TV;
+	else if (cr32 & XGI_VB_LCD)
+		xgi_video_info.disp_state = DISPTYPE_LCD;
+	else if (cr32 & XGI_VB_CRT2)
+		xgi_video_info.disp_state = DISPTYPE_CRT2;
+	else
+		xgi_video_info.disp_state = 0;
+
+	if(XGIfb_tvplug != -1)
+		/* PR/TW: Override with option */
+	        xgi_video_info.TV_plug = XGIfb_tvplug;
+	else if (cr32 & XGI_VB_HIVISION) {
+		xgi_video_info.TV_type = TVMODE_HIVISION;
+		xgi_video_info.TV_plug = TVPLUG_SVIDEO;
+	}
+	else if (cr32 & XGI_VB_SVIDEO)
+		xgi_video_info.TV_plug = TVPLUG_SVIDEO;
+	else if (cr32 & XGI_VB_COMPOSITE)
+		xgi_video_info.TV_plug = TVPLUG_COMPOSITE;
+	else if (cr32 & XGI_VB_SCART)
+		xgi_video_info.TV_plug = TVPLUG_SCART;
+
+	if(xgi_video_info.TV_type == 0) {
+	    /* TW: PAL/NTSC changed for 650 */
+	    if((xgi_video_info.chip <= XGI_315PRO) || (xgi_video_info.chip >= XGI_330)) {
+
+                inXGIIDXREG(XGICR, 0x38, temp);
+		if(temp & 0x10)
+			xgi_video_info.TV_type = TVMODE_PAL;
+		else
+			xgi_video_info.TV_type = TVMODE_NTSC;
+
+	    } else {
+
+	        inXGIIDXREG(XGICR, 0x79, temp);
+		if(temp & 0x20)
+			xgi_video_info.TV_type = TVMODE_PAL;
+		else
+			xgi_video_info.TV_type = TVMODE_NTSC;
+	    }
+	}
+
+	/* TW: Copy forceCRT1 option to CRT1off if option is given */
+    	if (XGIfb_forcecrt1 != -1) {
+    		if (XGIfb_forcecrt1) XGIfb_crt1off = 0;
+		else   	             XGIfb_crt1off = 1;
+    	}
+}
+
+static void XGIfb_get_VB_type(void)
+{
+	u8 reg;
+
+	if (!XGIfb_has_VB()) {
+	        inXGIIDXREG(XGICR, IND_XGI_SCRATCH_REG_CR37, reg);
+		switch ((reg & XGI_EXTERNAL_CHIP_MASK) >> 1) {
+	 	   case XGI310_EXTERNAL_CHIP_LVDS:
+			xgi_video_info.hasVB = HASVB_LVDS;
+			break;
+		   case XGI310_EXTERNAL_CHIP_LVDS_CHRONTEL:
+			xgi_video_info.hasVB = HASVB_LVDS_CHRONTEL;
+			break;
+		   default:
+			break;
+		}
+	}
+}
+
+
+static int XGIfb_has_VB(void)
+{
+	u8 vb_chipid;
+
+	inXGIIDXREG(XGIPART4, 0x00, vb_chipid);
+	switch (vb_chipid) {
+	   case 0x01:
+		xgi_video_info.hasVB = HASVB_301;
+		break;
+	   case 0x02:
+		xgi_video_info.hasVB = HASVB_302;
+		break;
+	   default:
+		xgi_video_info.hasVB = HASVB_NONE;
+		return FALSE;
+	}
+	return TRUE;
+}
+
+
+
+/* ------------------ Sensing routines ------------------ */
+
+/* TW: Determine and detect attached devices on XGI30x */
+int
+XGIDoSense(int tempbl, int tempbh, int tempcl, int tempch)
+{
+    int temp,i;
+
+    outXGIIDXREG(XGIPART4,0x11,tempbl);
+    temp = tempbh | tempcl;
+    setXGIIDXREG(XGIPART4,0x10,0xe0,temp);
+    for(i=0; i<10; i++) XGI_LongWait(&XGI_Pr);
+    tempch &= 0x7f;
+    inXGIIDXREG(XGIPART4,0x03,temp);
+    temp ^= 0x0e;
+    temp &= tempch;
+    return(temp);
+}
+
+void
+XGI_Sense30x(void)
+{
+  u8 backupP4_0d;
+  u8 testsvhs_tempbl, testsvhs_tempbh;
+  u8 testsvhs_tempcl, testsvhs_tempch;
+  u8 testcvbs_tempbl, testcvbs_tempbh;
+  u8 testcvbs_tempcl, testcvbs_tempch;
+  u8 testvga2_tempbl, testvga2_tempbh;
+  u8 testvga2_tempcl, testvga2_tempch;
+  int myflag, result;
+
+  inXGIIDXREG(XGIPART4,0x0d,backupP4_0d);
+  outXGIIDXREG(XGIPART4,0x0d,(backupP4_0d | 0x04));
+
+
+
+	testvga2_tempbh = 0x00; testvga2_tempbl = 0xd1;
+        testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xb9;
+	testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xb3;
+	if((XGIhw_ext.ujVBChipID != VB_CHIP_301) &&
+	   (XGIhw_ext.ujVBChipID != VB_CHIP_302)) {
+	      testvga2_tempbh = 0x01; testvga2_tempbl = 0x90;
+	      testsvhs_tempbh = 0x01; testsvhs_tempbl = 0x6b;
+	      testcvbs_tempbh = 0x01; testcvbs_tempbl = 0x74;
+	      if(XGIhw_ext.ujVBChipID == VB_CHIP_301LV ||
+	         XGIhw_ext.ujVBChipID == VB_CHIP_302LV) {
+	         testvga2_tempbh = 0x00; testvga2_tempbl = 0x00;
+	         testsvhs_tempbh = 0x02; testsvhs_tempbl = 0x00;
+	         testcvbs_tempbh = 0x01; testcvbs_tempbl = 0x00;
+	      }
+	}
+	if(XGIhw_ext.ujVBChipID != VB_CHIP_301LV &&
+	   XGIhw_ext.ujVBChipID != VB_CHIP_302LV) {
+	   inXGIIDXREG(XGIPART4,0x01,myflag);
+	   if(myflag & 0x04) {
+	      testvga2_tempbh = 0x00; testvga2_tempbl = 0xfd;
+	      testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xdd;
+	      testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xee;
+	   }
+	}
+	if((XGIhw_ext.ujVBChipID == VB_CHIP_301LV) ||
+	   (XGIhw_ext.ujVBChipID == VB_CHIP_302LV) ) {
+	   testvga2_tempbh = 0x00; testvga2_tempbl = 0x00;
+	   testvga2_tempch = 0x00; testvga2_tempcl = 0x00;
+	   testsvhs_tempch = 0x04; testsvhs_tempcl = 0x08;
+	   testcvbs_tempch = 0x08; testcvbs_tempcl = 0x08;
+	} else {
+	   testvga2_tempch = 0x0e; testvga2_tempcl = 0x08;
+	   testsvhs_tempch = 0x06; testsvhs_tempcl = 0x04;
+	   testcvbs_tempch = 0x08; testcvbs_tempcl = 0x04;
+	}
+
+
+    if(testvga2_tempch || testvga2_tempcl || testvga2_tempbh || testvga2_tempbl) {
+        result = XGIDoSense(testvga2_tempbl, testvga2_tempbh,
+                            testvga2_tempcl, testvga2_tempch);
+ 	if(result) {
+        	printk(KERN_INFO "XGIfb: Detected secondary VGA connection\n");
+		orXGIIDXREG(XGICR, 0x32, 0x10);
+	}
+    }
+
+    result = XGIDoSense(testsvhs_tempbl, testsvhs_tempbh,
+                        testsvhs_tempcl, testsvhs_tempch);
+    if(result) {
+        printk(KERN_INFO "XGIfb: Detected TV connected to SVHS output\n");
+        /* TW: So we can be sure that there IS a SVHS output */
+	xgi_video_info.TV_plug = TVPLUG_SVIDEO;
+	orXGIIDXREG(XGICR, 0x32, 0x02);
+    }
+
+    if(!result) {
+        result = XGIDoSense(testcvbs_tempbl, testcvbs_tempbh,
+	                    testcvbs_tempcl, testcvbs_tempch);
+	if(result) {
+	    printk(KERN_INFO "XGIfb: Detected TV connected to CVBS output\n");
+	    /* TW: So we can be sure that there IS a CVBS output */
+	    xgi_video_info.TV_plug = TVPLUG_COMPOSITE;
+	    orXGIIDXREG(XGICR, 0x32, 0x01);
+	}
+    }
+    XGIDoSense(0, 0, 0, 0);
+
+    outXGIIDXREG(XGIPART4,0x0d,backupP4_0d);
+}
+
+
+
+/* ------------------------ Heap routines -------------------------- */
+
+static int XGIfb_heap_init(void)
+{
+	XGI_OH *poh;
+	u8 temp=0;
+
+	int            agp_enabled = 1;
+	u32            agp_size;
+	unsigned long *cmdq_baseport = 0;
+	unsigned long *read_port = 0;
+	unsigned long *write_port = 0;
+	XGI_CMDTYPE    cmd_type;
+#ifndef AGPOFF
+	struct agp_kern_info  *agp_info;
+	struct agp_memory     *agp;
+	u32            agp_phys;
+#endif
+
+/* TW: The heap start is either set manually using the "mem" parameter, or
+ *     defaults as follows:
+ *     -) If more than 16MB videoRAM available, let our heap start at 12MB.
+ *     -) If more than  8MB videoRAM available, let our heap start at  8MB.
+ *     -) If 4MB or less is available, let it start at 4MB.
+ *     This is for avoiding a clash with X driver which uses the beginning
+ *     of the videoRAM. To limit size of X framebuffer, use Option MaxXFBMem
+ *     in XF86Config-4.
+ *     The heap start can also be specified by parameter "mem" when starting the XGIfb
+ *     driver. XGIfb mem=1024 lets heap starts at 1MB, etc.
+ */
+     if ((!XGIfb_mem) || (XGIfb_mem > (xgi_video_info.video_size/1024))) {
+        if (xgi_video_info.video_size > 0x1000000) {
+	        xgi_video_info.heapstart = 0xD00000;
+	} else if (xgi_video_info.video_size > 0x800000) {
+	        xgi_video_info.heapstart = 0x800000;
+	} else {
+		xgi_video_info.heapstart = 0x400000;
+	}
+     } else {
+           xgi_video_info.heapstart = XGIfb_mem * 1024;
+     }
+     XGIfb_heap_start =
+	       (unsigned long) (xgi_video_info.video_vbase + xgi_video_info.heapstart);
+     printk(KERN_INFO "XGIfb: Memory heap starting at %dK\n",
+     					(int)(xgi_video_info.heapstart / 1024));
+
+     XGIfb_heap_end = (unsigned long) xgi_video_info.video_vbase + xgi_video_info.video_size;
+     XGIfb_heap_size = XGIfb_heap_end - XGIfb_heap_start;
+
+
+
+        /* TW: Now initialize the 310 series' command queue mode.
+	 * On 310/325, there are three queue modes available which
+	 * are chosen by setting bits 7:5 in SR26:
+	 * 1. MMIO queue mode (bit 5, 0x20). The hardware will keep
+	 *    track of the queue, the FIFO, command parsing and so
+	 *    on. This is the one comparable to the 300 series.
+	 * 2. VRAM queue mode (bit 6, 0x40). In this case, one will
+	 *    have to do queue management himself. Register 0x85c4 will
+	 *    hold the location of the next free queue slot, 0x85c8
+	 *    is the "queue read pointer" whose way of working is
+	 *    unknown to me. Anyway, this mode would require a
+	 *    translation of the MMIO commands to some kind of
+	 *    accelerator assembly and writing these commands
+	 *    to the memory location pointed to by 0x85c4.
+	 *    We will not use this, as nobody knows how this
+	 *    "assembly" works, and as it would require a complete
+	 *    re-write of the accelerator code.
+	 * 3. AGP queue mode (bit 7, 0x80). Works as 2., but keeps the
+	 *    queue in AGP memory space.
+	 *
+	 * SR26 bit 4 is called "Bypass H/W queue".
+	 * SR26 bit 1 is called "Enable Command Queue Auto Correction"
+	 * SR26 bit 0 resets the queue
+	 * Size of queue memory is encoded in bits 3:2 like this:
+	 *    00  (0x00)  512K
+	 *    01  (0x04)  1M
+	 *    10  (0x08)  2M
+	 *    11  (0x0C)  4M
+	 * The queue location is to be written to 0x85C0.
+	 *
+         */
+	cmdq_baseport = (unsigned long *)(xgi_video_info.mmio_vbase + MMIO_QUEUE_PHYBASE);
+	write_port    = (unsigned long *)(xgi_video_info.mmio_vbase + MMIO_QUEUE_WRITEPORT);
+	read_port     = (unsigned long *)(xgi_video_info.mmio_vbase + MMIO_QUEUE_READPORT);
+
+	DPRINTK("AGP base: 0x%p, read: 0x%p, write: 0x%p\n", cmdq_baseport, read_port, write_port);
+
+	agp_size  = COMMAND_QUEUE_AREA_SIZE;
+
+#ifndef AGPOFF
+	if (XGIfb_queuemode == AGP_CMD_QUEUE) {
+		agp_info = vmalloc(sizeof(*agp_info));
+		memset((void*)agp_info, 0x00, sizeof(*agp_info));
+		agp_copy_info(agp_info);
+
+		agp_backend_acquire();
+
+		agp = agp_allocate_memory(COMMAND_QUEUE_AREA_SIZE/PAGE_SIZE,
+					  AGP_NORMAL_MEMORY);
+		if (agp == NULL) {
+			DPRINTK("XGIfb: Allocating AGP buffer failed.\n");
+			agp_enabled = 0;
+		} else {
+			if (agp_bind_memory(agp, agp->pg_start) != 0) {
+				DPRINTK("XGIfb: AGP: Failed to bind memory\n");
+				/* TODO: Free AGP memory here */
+				agp_enabled = 0;
+			} else {
+				agp_enable(0);
+			}
+		}
+	}
+#else
+	agp_enabled = 0;
+#endif
+
+	/* TW: Now select the queue mode */
+
+	if ((agp_enabled) && (XGIfb_queuemode == AGP_CMD_QUEUE)) {
+		cmd_type = AGP_CMD_QUEUE;
+		printk(KERN_INFO "XGIfb: Using AGP queue mode\n");
+/*	} else if (XGIfb_heap_size >= COMMAND_QUEUE_AREA_SIZE)  */
+        } else if (XGIfb_queuemode == VM_CMD_QUEUE) {
+		cmd_type = VM_CMD_QUEUE;
+		printk(KERN_INFO "XGIfb: Using VRAM queue mode\n");
+	} else {
+		printk(KERN_INFO "XGIfb: Using MMIO queue mode\n");
+		cmd_type = MMIO_CMD;
+	}
+
+	switch (agp_size) {
+	   case 0x80000:
+		temp = XGI_CMD_QUEUE_SIZE_512k;
+		break;
+	   case 0x100000:
+		temp = XGI_CMD_QUEUE_SIZE_1M;
+		break;
+	   case 0x200000:
+		temp = XGI_CMD_QUEUE_SIZE_2M;
+		break;
+	   case 0x400000:
+		temp = XGI_CMD_QUEUE_SIZE_4M;
+		break;
+	}
+
+	switch (cmd_type) {
+	   case AGP_CMD_QUEUE:
+#ifndef AGPOFF
+		DPRINTK("XGIfb: AGP buffer base = 0x%lx, offset = 0x%x, size = %dK\n",
+			agp_info->aper_base, agp->physical, agp_size/1024);
+
+		agp_phys = agp_info->aper_base + agp->physical;
+
+		outXGIIDXREG(XGICR,  IND_XGI_AGP_IO_PAD, 0);
+		outXGIIDXREG(XGICR,  IND_XGI_AGP_IO_PAD, XGI_AGP_2X);
+
+                outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_THRESHOLD, COMMAND_QUEUE_THRESHOLD);
+
+		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, XGI_CMD_QUEUE_RESET);
+
+		*write_port = *read_port;
+
+		temp |= XGI_AGP_CMDQUEUE_ENABLE;
+		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, temp);
+
+		*cmdq_baseport = agp_phys;
+
+		XGIfb_caps |= AGP_CMD_QUEUE_CAP;
+#endif
+		break;
+
+	   case VM_CMD_QUEUE:
+		XGIfb_heap_end -= COMMAND_QUEUE_AREA_SIZE;
+		XGIfb_heap_size -= COMMAND_QUEUE_AREA_SIZE;
+
+		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_THRESHOLD, COMMAND_QUEUE_THRESHOLD);
+
+		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, XGI_CMD_QUEUE_RESET);
+
+		*write_port = *read_port;
+
+		temp |= XGI_VRAM_CMDQUEUE_ENABLE;
+		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, temp);
+
+		*cmdq_baseport = xgi_video_info.video_size - COMMAND_QUEUE_AREA_SIZE;
+
+		XGIfb_caps |= VM_CMD_QUEUE_CAP;
+
+		DPRINTK("XGIfb: VM Cmd Queue offset = 0x%lx, size is %dK\n",
+			*cmdq_baseport, COMMAND_QUEUE_AREA_SIZE/1024);
+		break;
+
+	   default:  /* MMIO */
+
+//		printk("%s:%d - I'm here\n", __FUNCTION__, __LINE__);
+	   	/* TW: This previously only wrote XGI_MMIO_CMD_ENABLE
+		 * to IND_XGI_CMDQUEUE_SET. I doubt that this is
+		 * enough. Reserve memory in any way.
+		 */
+// FIXME 	   	XGIfb_heap_end -= COMMAND_QUEUE_AREA_SIZE;
+// FIXME 		XGIfb_heap_size -= COMMAND_QUEUE_AREA_SIZE;
+// FIXME
+// FIXME 		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_THRESHOLD, COMMAND_QUEUE_THRESHOLD);
+// FIXME 		outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, XGI_CMD_QUEUE_RESET);
+// FIXME
+// FIXME 		*write_port = *read_port;
+// FIXME
+// FIXME 		/* TW: Set Auto_Correction bit */
+// FIXME 		temp |= (XGI_MMIO_CMD_ENABLE | XGI_CMD_AUTO_CORR);
+// FIXME 		// FIXME outXGIIDXREG(XGISR, IND_XGI_CMDQUEUE_SET, temp);
+// FIXME
+// FIXME 		*cmdq_baseport = xgi_video_info.video_size - COMMAND_QUEUE_AREA_SIZE;
+// FIXME
+// FIXME 		XGIfb_caps |= MMIO_CMD_QUEUE_CAP;
+// FIXME
+// FIXME 		DPRINTK("XGIfb: MMIO Cmd Queue offset = 0x%lx, size is %dK\n",
+// FIXME 			*cmdq_baseport, COMMAND_QUEUE_AREA_SIZE/1024);
+		break;
+	}
+
+
+
+
+     /* TW: Now reserve memory for the HWCursor. It is always located at the very
+            top of the videoRAM, right below the TB memory area (if used). */
+     if (XGIfb_heap_size >= XGIfb_hwcursor_size) {
+		XGIfb_heap_end -= XGIfb_hwcursor_size;
+		XGIfb_heap_size -= XGIfb_hwcursor_size;
+		XGIfb_hwcursor_vbase = XGIfb_heap_end;
+
+		XGIfb_caps |= HW_CURSOR_CAP;
+
+		DPRINTK("XGIfb: Hardware Cursor start at 0x%lx, size is %dK\n",
+			XGIfb_heap_end, XGIfb_hwcursor_size/1024);
+     }
+
+     XGIfb_heap.poha_chain = NULL;
+     XGIfb_heap.poh_freelist = NULL;
+
+     poh = XGIfb_poh_new_node();
+
+     if(poh == NULL)  return 1;
+
+     poh->poh_next = &XGIfb_heap.oh_free;
+     poh->poh_prev = &XGIfb_heap.oh_free;
+     poh->size = XGIfb_heap_end - XGIfb_heap_start + 1;
+     poh->offset = XGIfb_heap_start - (unsigned long) xgi_video_info.video_vbase;
+
+     DPRINTK("XGIfb: Heap start:0x%p, end:0x%p, len=%dk\n",
+		(char *) XGIfb_heap_start, (char *) XGIfb_heap_end,
+		(unsigned int) poh->size / 1024);
+
+     DPRINTK("XGIfb: First Node offset:0x%x, size:%dk\n",
+		(unsigned int) poh->offset, (unsigned int) poh->size / 1024);
+
+     XGIfb_heap.oh_free.poh_next = poh;
+     XGIfb_heap.oh_free.poh_prev = poh;
+     XGIfb_heap.oh_free.size = 0;
+     XGIfb_heap.max_freesize = poh->size;
+
+     XGIfb_heap.oh_used.poh_next = &XGIfb_heap.oh_used;
+     XGIfb_heap.oh_used.poh_prev = &XGIfb_heap.oh_used;
+     XGIfb_heap.oh_used.size = SENTINEL;
+
+     return 0;
+}
+
+static XGI_OH *XGIfb_poh_new_node(void)
+{
+	int           i;
+	unsigned long cOhs;
+	XGI_OHALLOC   *poha;
+	XGI_OH        *poh;
+
+	if (XGIfb_heap.poh_freelist == NULL) {
+		poha = kmalloc(OH_ALLOC_SIZE, GFP_KERNEL);
+		if(!poha) return NULL;
+
+		poha->poha_next = XGIfb_heap.poha_chain;
+		XGIfb_heap.poha_chain = poha;
+
+		cOhs = (OH_ALLOC_SIZE - sizeof(XGI_OHALLOC)) / sizeof(XGI_OH) + 1;
+
+		poh = &poha->aoh[0];
+		for (i = cOhs - 1; i != 0; i--) {
+			poh->poh_next = poh + 1;
+			poh = poh + 1;
+		}
+
+		poh->poh_next = NULL;
+		XGIfb_heap.poh_freelist = &poha->aoh[0];
+	}
+
+	poh = XGIfb_heap.poh_freelist;
+	XGIfb_heap.poh_freelist = poh->poh_next;
+
+	return (poh);
+}
+
+static XGI_OH *XGIfb_poh_allocate(unsigned long size)
+{
+	XGI_OH *pohThis;
+	XGI_OH *pohRoot;
+	int     bAllocated = 0;
+
+	if (size > XGIfb_heap.max_freesize) {
+		DPRINTK("XGIfb: Can't allocate %dk size on offscreen\n",
+			(unsigned int) size / 1024);
+		return (NULL);
+	}
+
+	pohThis = XGIfb_heap.oh_free.poh_next;
+
+	while (pohThis != &XGIfb_heap.oh_free) {
+		if (size <= pohThis->size) {
+			bAllocated = 1;
+			break;
+		}
+		pohThis = pohThis->poh_next;
+	}
+
+	if (!bAllocated) {
+		DPRINTK("XGIfb: Can't allocate %dk size on offscreen\n",
+			(unsigned int) size / 1024);
+		return (NULL);
+	}
+
+	if (size == pohThis->size) {
+		pohRoot = pohThis;
+		XGIfb_delete_node(pohThis);
+	} else {
+		pohRoot = XGIfb_poh_new_node();
+
+		if (pohRoot == NULL) {
+			return (NULL);
+		}
+
+		pohRoot->offset = pohThis->offset;
+		pohRoot->size = size;
+
+		pohThis->offset += size;
+		pohThis->size -= size;
+	}
+
+	XGIfb_heap.max_freesize -= size;
+
+	pohThis = &XGIfb_heap.oh_used;
+	XGIfb_insert_node(pohThis, pohRoot);
+
+	return (pohRoot);
+}
+
+static void XGIfb_delete_node(XGI_OH *poh)
+{
+	XGI_OH *poh_prev;
+	XGI_OH *poh_next;
+
+	poh_prev = poh->poh_prev;
+	poh_next = poh->poh_next;
+
+	poh_prev->poh_next = poh_next;
+	poh_next->poh_prev = poh_prev;
+
+}
+
+static void XGIfb_insert_node(XGI_OH *pohList, XGI_OH *poh)
+{
+	XGI_OH *pohTemp;
+
+	pohTemp = pohList->poh_next;
+
+	pohList->poh_next = poh;
+	pohTemp->poh_prev = poh;
+
+	poh->poh_prev = pohList;
+	poh->poh_next = pohTemp;
+}
+
+static XGI_OH *XGIfb_poh_free(unsigned long base)
+{
+	XGI_OH *pohThis;
+	XGI_OH *poh_freed;
+	XGI_OH *poh_prev;
+	XGI_OH *poh_next;
+	unsigned long ulUpper;
+	unsigned long ulLower;
+	int foundNode = 0;
+
+	poh_freed = XGIfb_heap.oh_used.poh_next;
+
+	while(poh_freed != &XGIfb_heap.oh_used) {
+		if(poh_freed->offset == base) {
+			foundNode = 1;
+			break;
+		}
+
+		poh_freed = poh_freed->poh_next;
+	}
+
+	if (!foundNode)  return (NULL);
+
+	XGIfb_heap.max_freesize += poh_freed->size;
+
+	poh_prev = poh_next = NULL;
+	ulUpper = poh_freed->offset + poh_freed->size;
+	ulLower = poh_freed->offset;
+
+	pohThis = XGIfb_heap.oh_free.poh_next;
+
+	while (pohThis != &XGIfb_heap.oh_free) {
+		if (pohThis->offset == ulUpper) {
+			poh_next = pohThis;
+		}
+			else if ((pohThis->offset + pohThis->size) ==
+				 ulLower) {
+			poh_prev = pohThis;
+		}
+		pohThis = pohThis->poh_next;
+	}
+
+	XGIfb_delete_node(poh_freed);
+
+	if (poh_prev && poh_next) {
+		poh_prev->size += (poh_freed->size + poh_next->size);
+		XGIfb_delete_node(poh_next);
+		XGIfb_free_node(poh_freed);
+		XGIfb_free_node(poh_next);
+		return (poh_prev);
+	}
+
+	if (poh_prev) {
+		poh_prev->size += poh_freed->size;
+		XGIfb_free_node(poh_freed);
+		return (poh_prev);
+	}
+
+	if (poh_next) {
+		poh_next->size += poh_freed->size;
+		poh_next->offset = poh_freed->offset;
+		XGIfb_free_node(poh_freed);
+		return (poh_next);
+	}
+
+	XGIfb_insert_node(&XGIfb_heap.oh_free, poh_freed);
+
+	return (poh_freed);
+}
+
+static void XGIfb_free_node(XGI_OH *poh)
+{
+	if(poh == NULL) return;
+
+	poh->poh_next = XGIfb_heap.poh_freelist;
+	XGIfb_heap.poh_freelist = poh;
+
+}
+
+void XGI_malloc(struct XGI_memreq *req)
+{
+	XGI_OH *poh;
+
+	poh = XGIfb_poh_allocate(req->size);
+
+	if(poh == NULL) {
+		req->offset = 0;
+		req->size = 0;
+		DPRINTK("XGIfb: Video RAM allocation failed\n");
+	} else {
+		DPRINTK("XGIfb: Video RAM allocation succeeded: 0x%p\n",
+			(char *) (poh->offset + (unsigned long) xgi_video_info.video_vbase));
+
+		req->offset = poh->offset;
+		req->size = poh->size;
+	}
+
+}
+
+void XGI_free(unsigned long base)
+{
+	XGI_OH *poh;
+
+	poh = XGIfb_poh_free(base);
+
+	if(poh == NULL) {
+		DPRINTK("XGIfb: XGIfb_poh_free() failed at base 0x%x\n",
+			(unsigned int) base);
+	}
+}
+
+/* --------------------- SetMode routines ------------------------- */
+
+static void XGIfb_pre_setmode(void)
+{
+	u8 cr30 = 0, cr31 = 0;
+
+	inXGIIDXREG(XGICR, 0x31, cr31);
+	cr31 &= ~0x60;
+
+	switch (xgi_video_info.disp_state & DISPTYPE_DISP2) {
+	   case DISPTYPE_CRT2:
+		cr30 = (XGI_VB_OUTPUT_CRT2 | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		cr31 |= XGI_DRIVER_MODE;
+		break;
+	   case DISPTYPE_LCD:
+		cr30  = (XGI_VB_OUTPUT_LCD | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		cr31 |= XGI_DRIVER_MODE;
+		break;
+	   case DISPTYPE_TV:
+		if (xgi_video_info.TV_type == TVMODE_HIVISION)
+			cr30 = (XGI_VB_OUTPUT_HIVISION | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		else if (xgi_video_info.TV_plug == TVPLUG_SVIDEO)
+			cr30 = (XGI_VB_OUTPUT_SVIDEO | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		else if (xgi_video_info.TV_plug == TVPLUG_COMPOSITE)
+			cr30 = (XGI_VB_OUTPUT_COMPOSITE | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		else if (xgi_video_info.TV_plug == TVPLUG_SCART)
+			cr30 = (XGI_VB_OUTPUT_SCART | XGI_SIMULTANEOUS_VIEW_ENABLE);
+		cr31 |= XGI_DRIVER_MODE;
+
+	        if (XGIfb_tvmode == 1 || xgi_video_info.TV_type == TVMODE_PAL)
+			cr31 |= 0x01;
+                else
+                        cr31 &= ~0x01;
+		break;
+	   default:	/* disable CRT2 */
+		cr30 = 0x00;
+		cr31 |= (XGI_DRIVER_MODE | XGI_VB_OUTPUT_DISABLE);
+	}
+
+	outXGIIDXREG(XGICR, IND_XGI_SCRATCH_REG_CR30, cr30);
+	outXGIIDXREG(XGICR, IND_XGI_SCRATCH_REG_CR31, cr31);
+        outXGIIDXREG(XGICR, IND_XGI_SCRATCH_REG_CR33, (XGIfb_rate_idx & 0x0F));
+
+	if(xgi_video_info.accel) XGIfb_syncaccel();
+
+
+}
+
+static void XGIfb_post_setmode(void)
+{
+	u8 reg;
+	BOOLEAN doit = TRUE;
+#if 0	/* TW: Wrong: Is not in MMIO space, but in RAM */
+	/* Backup mode number to MMIO space */
+	if(xgi_video_info.mmio_vbase) {
+	  *(volatile u8 *)(((u8*)xgi_video_info.mmio_vbase) + 0x449) = (unsigned char)XGIfb_mode_no;
+	}
+#endif
+/*	outXGIIDXREG(XGISR,IND_XGI_PASSWORD,XGI_PASSWORD);
+	outXGIIDXREG(XGICR,0x13,0x00);
+	setXGIIDXREG(XGISR,0x0E,0xF0,0x01);
+*test**/
+	if (xgi_video_info.video_bpp == 8) {
+		/* TW: We can't switch off CRT1 on LVDS/Chrontel in 8bpp Modes */
+		if ((xgi_video_info.hasVB == HASVB_LVDS) || (xgi_video_info.hasVB == HASVB_LVDS_CHRONTEL)) {
+			doit = FALSE;
+		}
+		/* TW: We can't switch off CRT1 on 301B-DH in 8bpp Modes if using LCD */
+		if  (xgi_video_info.disp_state & DISPTYPE_LCD)  {
+	        	doit = FALSE;
+	        }
+	}
+
+	/* TW: We can't switch off CRT1 if bridge is in slave mode */
+	if(xgi_video_info.hasVB != HASVB_NONE) {
+		inXGIIDXREG(XGIPART1, 0x00, reg);
+
+
+		if((reg & 0x50) == 0x10) {
+			doit = FALSE;
+		}
+
+	} else XGIfb_crt1off = 0;
+
+	inXGIIDXREG(XGICR, 0x17, reg);
+	if((XGIfb_crt1off) && (doit))
+		reg &= ~0x80;
+	else
+		reg |= 0x80;
+	outXGIIDXREG(XGICR, 0x17, reg);
+
+        andXGIIDXREG(XGISR, IND_XGI_RAMDAC_CONTROL, ~0x04);
+
+	if((xgi_video_info.disp_state & DISPTYPE_TV) && (xgi_video_info.hasVB == HASVB_301)) {
+
+	   inXGIIDXREG(XGIPART4, 0x01, reg);
+
+	   if(reg < 0xB0) {        	/* Set filter for XGI301 */
+
+		switch (xgi_video_info.video_width) {
+		   case 320:
+			filter_tb = (xgi_video_info.TV_type == TVMODE_NTSC) ? 4 : 12;
+			break;
+		   case 640:
+			filter_tb = (xgi_video_info.TV_type == TVMODE_NTSC) ? 5 : 13;
+			break;
+		   case 720:
+			filter_tb = (xgi_video_info.TV_type == TVMODE_NTSC) ? 6 : 14;
+			break;
+		   case 800:
+			filter_tb = (xgi_video_info.TV_type == TVMODE_NTSC) ? 7 : 15;
+			break;
+		   default:
+			filter = -1;
+			break;
+		}
+
+		orXGIIDXREG(XGIPART1, XGIfb_CRT2_write_enable, 0x01);
+
+		if(xgi_video_info.TV_type == TVMODE_NTSC) {
+
+		        andXGIIDXREG(XGIPART2, 0x3a, 0x1f);
+
+			if (xgi_video_info.TV_plug == TVPLUG_SVIDEO) {
+
+			        andXGIIDXREG(XGIPART2, 0x30, 0xdf);
+
+			} else if (xgi_video_info.TV_plug == TVPLUG_COMPOSITE) {
+
+			        orXGIIDXREG(XGIPART2, 0x30, 0x20);
+
+				switch (xgi_video_info.video_width) {
+				case 640:
+				        outXGIIDXREG(XGIPART2, 0x35, 0xEB);
+					outXGIIDXREG(XGIPART2, 0x36, 0x04);
+					outXGIIDXREG(XGIPART2, 0x37, 0x25);
+					outXGIIDXREG(XGIPART2, 0x38, 0x18);
+					break;
+				case 720:
+					outXGIIDXREG(XGIPART2, 0x35, 0xEE);
+					outXGIIDXREG(XGIPART2, 0x36, 0x0C);
+					outXGIIDXREG(XGIPART2, 0x37, 0x22);
+					outXGIIDXREG(XGIPART2, 0x38, 0x08);
+					break;
+				case 800:
+					outXGIIDXREG(XGIPART2, 0x35, 0xEB);
+					outXGIIDXREG(XGIPART2, 0x36, 0x15);
+					outXGIIDXREG(XGIPART2, 0x37, 0x25);
+					outXGIIDXREG(XGIPART2, 0x38, 0xF6);
+					break;
+				}
+			}
+
+		} else if(xgi_video_info.TV_type == TVMODE_PAL) {
+
+			andXGIIDXREG(XGIPART2, 0x3A, 0x1F);
+
+			if (xgi_video_info.TV_plug == TVPLUG_SVIDEO) {
+
+			        andXGIIDXREG(XGIPART2, 0x30, 0xDF);
+
+			} else if (xgi_video_info.TV_plug == TVPLUG_COMPOSITE) {
+
+			        orXGIIDXREG(XGIPART2, 0x30, 0x20);
+
+				switch (xgi_video_info.video_width) {
+				case 640:
+					outXGIIDXREG(XGIPART2, 0x35, 0xF1);
+					outXGIIDXREG(XGIPART2, 0x36, 0xF7);
+					outXGIIDXREG(XGIPART2, 0x37, 0x1F);
+					outXGIIDXREG(XGIPART2, 0x38, 0x32);
+					break;
+				case 720:
+					outXGIIDXREG(XGIPART2, 0x35, 0xF3);
+					outXGIIDXREG(XGIPART2, 0x36, 0x00);
+					outXGIIDXREG(XGIPART2, 0x37, 0x1D);
+					outXGIIDXREG(XGIPART2, 0x38, 0x20);
+					break;
+				case 800:
+					outXGIIDXREG(XGIPART2, 0x35, 0xFC);
+					outXGIIDXREG(XGIPART2, 0x36, 0xFB);
+					outXGIIDXREG(XGIPART2, 0x37, 0x14);
+					outXGIIDXREG(XGIPART2, 0x38, 0x2A);
+					break;
+				}
+			}
+		}
+
+		if ((filter >= 0) && (filter <=7)) {
+			DPRINTK("FilterTable[%d]-%d: %02x %02x %02x %02x\n", filter_tb, filter,
+				XGI_TV_filter[filter_tb].filter[filter][0],
+				XGI_TV_filter[filter_tb].filter[filter][1],
+				XGI_TV_filter[filter_tb].filter[filter][2],
+				XGI_TV_filter[filter_tb].filter[filter][3]
+			);
+			outXGIIDXREG(XGIPART2, 0x35, (XGI_TV_filter[filter_tb].filter[filter][0]));
+			outXGIIDXREG(XGIPART2, 0x36, (XGI_TV_filter[filter_tb].filter[filter][1]));
+			outXGIIDXREG(XGIPART2, 0x37, (XGI_TV_filter[filter_tb].filter[filter][2]));
+			outXGIIDXREG(XGIPART2, 0x38, (XGI_TV_filter[filter_tb].filter[filter][3]));
+		}
+
+	     }
+
+	}
+
+}
+
+#ifndef MODULE
+XGIINITSTATIC int __init XGIfb_setup(char *options)
+{
+	char *this_opt;
+
+
+
+	xgi_video_info.refresh_rate = 0;
+
+        printk(KERN_INFO "XGIfb: Options %s\n", options);
+
+	if (!options || !*options)
+		return 0;
+
+	while((this_opt = strsep(&options, ",")) != NULL) {
+
+		if (!*this_opt)	continue;
+
+		if (!strncmp(this_opt, "mode:", 5)) {
+			XGIfb_search_mode(this_opt + 5);
+		} else if (!strncmp(this_opt, "vesa:", 5)) {
+			XGIfb_search_vesamode(simple_strtoul(this_opt + 5, NULL, 0));
+		} else if (!strncmp(this_opt, "mode:", 5)) {
+			XGIfb_search_mode(this_opt + 5);
+		} else if (!strncmp(this_opt, "vesa:", 5)) {
+			XGIfb_search_vesamode(simple_strtoul(this_opt + 5, NULL, 0));
+		} else if (!strncmp(this_opt, "vrate:", 6)) {
+			xgi_video_info.refresh_rate = simple_strtoul(this_opt + 6, NULL, 0);
+		} else if (!strncmp(this_opt, "rate:", 5)) {
+			xgi_video_info.refresh_rate = simple_strtoul(this_opt + 5, NULL, 0);
+		} else if (!strncmp(this_opt, "off", 3)) {
+			XGIfb_off = 1;
+		} else if (!strncmp(this_opt, "crt1off", 7)) {
+			XGIfb_crt1off = 1;
+		} else if (!strncmp(this_opt, "filter:", 7)) {
+			filter = (int)simple_strtoul(this_opt + 7, NULL, 0);
+		} else if (!strncmp(this_opt, "forcecrt2type:", 14)) {
+			XGIfb_search_crt2type(this_opt + 14);
+		} else if (!strncmp(this_opt, "forcecrt1:", 10)) {
+			XGIfb_forcecrt1 = (int)simple_strtoul(this_opt + 10, NULL, 0);
+                } else if (!strncmp(this_opt, "tvmode:",7)) {
+		        XGIfb_search_tvstd(this_opt + 7);
+                } else if (!strncmp(this_opt, "tvstandard:",11)) {
+			XGIfb_search_tvstd(this_opt + 7);
+                } else if (!strncmp(this_opt, "mem:",4)) {
+		        XGIfb_mem = simple_strtoul(this_opt + 4, NULL, 0);
+                } else if (!strncmp(this_opt, "dstn", 4)) {
+			enable_dstn = 1;
+			/* TW: DSTN overrules forcecrt2type */
+			XGIfb_crt2type = DISPTYPE_LCD;
+		} else if (!strncmp(this_opt, "queuemode:", 10)) {
+			XGIfb_search_queuemode(this_opt + 10);
+		} else if (!strncmp(this_opt, "pdc:", 4)) {
+		        XGIfb_pdc = simple_strtoul(this_opt + 4, NULL, 0);
+		        if(XGIfb_pdc & ~0x3c) {
+			   printk(KERN_INFO "XGIfb: Illegal pdc parameter\n");
+			   XGIfb_pdc = 0;
+		        }
+		} else if (!strncmp(this_opt, "noaccel", 7)) {
+			XGIfb_accel = 0;
+		} else if (!strncmp(this_opt, "noypan", 6)) {
+		        XGIfb_ypan = 0;
+		} else if (!strncmp(this_opt, "userom:", 7)) {
+			XGIfb_userom = (int)simple_strtoul(this_opt + 7, NULL, 0);
+//		} else if (!strncmp(this_opt, "useoem:", 7)) {
+//			XGIfb_useoem = (int)simple_strtoul(this_opt + 7, NULL, 0);
+		} else {
+			XGIfb_search_mode(this_opt);
+//			printk(KERN_INFO "XGIfb: Invalid option %s\n", this_opt);
+		}
+
+		/* TW: Acceleration only with MMIO mode */
+		if((XGIfb_queuemode != -1) && (XGIfb_queuemode != MMIO_CMD)) {
+			XGIfb_ypan = 0;
+			XGIfb_accel = 0;
+		}
+		/* TW: Panning only with acceleration */
+		if(XGIfb_accel == 0) XGIfb_ypan = 0;
+
+	}
+	printk("\nxgifb: outa xgifb_setup 3450");
+	return 0;
+}
+#endif
+
+static unsigned char VBIOS_BUF[65535];
+
+unsigned char* attempt_map_rom(struct pci_dev *dev,void *copy_address)
+{
+    u32 rom_size      = 0;
+    u32 rom_address   = 0;
+    int j;
+
+    /*  Get the size of the expansion rom */
+    pci_write_config_dword(dev, PCI_ROM_ADDRESS, 0xFFFFFFFF);
+    pci_read_config_dword(dev, PCI_ROM_ADDRESS, &rom_size);
+    if ((rom_size & 0x01) == 0)
+    {
+		printk("No ROM\n");
+		return NULL;
+    }
+
+    rom_size &= 0xFFFFF800;
+    rom_size = (~rom_size)+1;
+
+    rom_address = pci_resource_start(dev, 0);
+    if (rom_address == 0 || rom_address == 0xFFFFFFF0)
+    {
+		printk("No suitable rom address found\n"); return NULL;
+    }
+
+    printk("ROM Size is %dK, Address is %x\n", rom_size/1024, rom_address);
+
+    /*  Map ROM */
+    pci_write_config_dword(dev, PCI_ROM_ADDRESS, rom_address | PCI_ROM_ADDRESS_ENABLE);
+
+    /* memcpy(copy_address, rom_address, rom_size); */
+    {
+		unsigned char *virt_addr = ioremap(rom_address, 0x8000000);
+
+		unsigned char *from = (unsigned char *)virt_addr;
+		unsigned char *to = (unsigned char *)copy_address;
+		for (j=0; j<65536 /*rom_size*/; j++) *to++ = *from++;
+	}
+
+	pci_write_config_dword(dev, PCI_ROM_ADDRESS, 0);
+
+    printk("Copy is done\n");
+
+	return copy_address;
+}
+
+int __devinit xgifb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	u16 reg16;
+	u8  reg, reg1;
+        u8 CR48,CR38;
+	if (XGIfb_off)
+		return -ENXIO;
+
+	XGIfb_registered = 0;
+
+	memset(&XGIhw_ext, 0, sizeof(HW_DEVICE_EXTENSION));
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,3))
+	  fb_info = framebuffer_alloc(sizeof(struct fb_info), &pdev->dev);
+	  if(!fb_info) return -ENOMEM;
+#else
+	  XGI_fb_info = kmalloc( sizeof(struct fb_info), GFP_KERNEL);
+	  if(!XGI_fb_info) return -ENOMEM;
+	  memset(XGI_fb_info, 0,  sizeof(struct fb_info));
+#endif
+
+  	xgi_video_info.chip_id = pdev->device;
+	  pci_read_config_byte(pdev, PCI_REVISION_ID,&xgi_video_info.revision_id);
+	  pci_read_config_word(pdev, PCI_COMMAND, &reg16);
+	  XGIhw_ext.jChipRevision = xgi_video_info.revision_id;
+	  XGIvga_enabled = reg16 & 0x01;
+
+	  xgi_video_info.pcibus = pdev->bus->number;
+	  xgi_video_info.pcislot = PCI_SLOT(pdev->devfn);
+	  xgi_video_info.pcifunc = PCI_FUNC(pdev->devfn);
+	  xgi_video_info.subsysvendor = pdev->subsystem_vendor;
+	  xgi_video_info.subsysdevice = pdev->subsystem_device;
+
+	  xgi_video_info.video_base = pci_resource_start(pdev, 0);
+	  xgi_video_info.mmio_base = pci_resource_start(pdev, 1);
+	  XGIfb_mmio_size =  pci_resource_len(pdev, 1);
+	  xgi_video_info.vga_base = pci_resource_start(pdev, 2) + 0x30;
+	  XGIhw_ext.pjIOAddress = (PUCHAR)xgi_video_info.vga_base;
+	  //XGI_Pr.RelIO  = ioremap(pci_resource_start(pdev, 2), 128) + 0x30;
+	  printk("XGIfb: Relocate IO address: %lx [%08lx] \n", (unsigned long)pci_resource_start(pdev, 2), XGI_Pr.RelIO);
+
+	  if (pci_enable_device(pdev))
+	          return -EIO;
+
+    XGIRegInit(&XGI_Pr, (ULONG)XGIhw_ext.pjIOAddress);
+
+    outXGIIDXREG(XGISR, IND_XGI_PASSWORD, XGI_PASSWORD);
+    inXGIIDXREG(XGISR, IND_XGI_PASSWORD, reg1);
+
+    if(reg1 != 0xa1) /*I/O error */
+    {
+         printk("\nXGIfb: I/O error!!!");
+         return  -EIO;
+    }
+
+	switch (xgi_video_info.chip_id) {
+	   case PCI_DEVICE_ID_XG_20:
+		orXGIIDXREG(XGICR, Index_CR_GPIO_Reg3, GPIOG_EN);
+		inXGIIDXREG(XGICR, Index_CR_GPIO_Reg1, CR48);
+		if (CR48&GPIOG_READ)
+			xgi_video_info.chip = XG21;
+		else
+		   	xgi_video_info.chip = XG20;
+		XGIfb_hwcursor_size = HW_CURSOR_AREA_SIZE_315 * 2;
+		XGIfb_CRT2_write_enable = IND_XGI_CRT2_WRITE_ENABLE_315;
+		break;
+	    case PCI_DEVICE_ID_XG_40:
+		xgi_video_info.chip = XG40;
+		XGIfb_hwcursor_size = HW_CURSOR_AREA_SIZE_315 * 2;
+		XGIfb_CRT2_write_enable = IND_XGI_CRT2_WRITE_ENABLE_315;
+		break;
+	    case PCI_DEVICE_ID_XG_41:
+		xgi_video_info.chip = XG41;
+		XGIfb_hwcursor_size = HW_CURSOR_AREA_SIZE_315 * 2;
+		XGIfb_CRT2_write_enable = IND_XGI_CRT2_WRITE_ENABLE_315;
+		break;
+	    case PCI_DEVICE_ID_XG_42:
+		xgi_video_info.chip = XG42;
+		XGIfb_hwcursor_size = HW_CURSOR_AREA_SIZE_315 * 2;
+		XGIfb_CRT2_write_enable = IND_XGI_CRT2_WRITE_ENABLE_315;
+		break;
+	    case PCI_DEVICE_ID_XG_27:
+		xgi_video_info.chip = XG27;
+		XGIfb_hwcursor_size = HW_CURSOR_AREA_SIZE_315 * 2;
+		XGIfb_CRT2_write_enable = IND_XGI_CRT2_WRITE_ENABLE_315;
+		break;
+           default:
+	        return -ENODEV;
+	}
+
+	printk("XGIfb:chipid = %x\n",xgi_video_info.chip);
+	 XGIhw_ext.jChipType = xgi_video_info.chip;
+
+		switch (xgi_video_info.chip) {
+		   case XG40:
+		   case XG41:
+		   case XG42:
+		   case XG45:
+		   case XG20:
+		   case XG21:
+                   case XG27:
+                   XGIhw_ext.bIntegratedMMEnabled = TRUE;
+			break;
+
+		   default:
+			break;
+		}
+
+
+	  XGIhw_ext.pDevice = NULL;
+	  if ((xgi_video_info.chip == XG21) || (XGIfb_userom))
+	  {
+	      XGIhw_ext.pjVirtualRomBase = attempt_map_rom(pdev, VBIOS_BUF);
+
+	      if(XGIhw_ext.pjVirtualRomBase)
+			printk(KERN_INFO "XGIfb: Video ROM found and mapped to %p\n",XGIhw_ext.pjVirtualRomBase);
+		else
+			printk(KERN_INFO "XGIfb: Video ROM not found\n");
+    } else {
+	    	XGIhw_ext.pjVirtualRomBase = NULL;
+		printk(KERN_INFO "XGIfb: Video ROM usage disabled\n");
+    }
+	  XGIhw_ext.pjCustomizedROMImage = NULL;
+	  XGIhw_ext.bSkipDramSizing = 0;
+	  XGIhw_ext.pQueryVGAConfigSpace = &XGIfb_query_VGA_config_space;
+//	XGIhw_ext.pQueryNorthBridgeSpace = &XGIfb_query_north_bridge_space;
+	  strcpy(XGIhw_ext.szVBIOSVer, "0.84");
+
+
+    XGIhw_ext.pSR = vmalloc(sizeof(XGI_DSReg) * SR_BUFFER_SIZE);
+	  if (XGIhw_ext.pSR == NULL)
+	  {
+		    printk(KERN_ERR "XGIfb: Fatal error: Allocating SRReg space failed.\n");
+		    return -ENODEV;
+	  }
+	  XGIhw_ext.pSR[0].jIdx = XGIhw_ext.pSR[0].jVal = 0xFF;
+
+	  XGIhw_ext.pCR = vmalloc(sizeof(XGI_DSReg) * CR_BUFFER_SIZE);
+	  if (XGIhw_ext.pCR == NULL)
+	  {
+	      vfree(XGIhw_ext.pSR);
+		    printk(KERN_ERR "XGIfb: Fatal error: Allocating CRReg space failed.\n");
+		    return -ENODEV;
+	  }
+	  XGIhw_ext.pCR[0].jIdx = XGIhw_ext.pCR[0].jVal = 0xFF;
+
+
+
+
+	if (!XGIvga_enabled)
+	{
+			/* Mapping Max FB Size for 315 Init */
+	    XGIhw_ext.pjVideoMemoryAddress = ioremap(xgi_video_info.video_base, 0x10000000);
+	    if((xgifb_mode_idx < 0) || ((XGIbios_mode[xgifb_mode_idx].mode_no) != 0xFF))
+	    {
+#ifdef LINUXBIOS
+		printk("XGIfb: XGIInit() ...");
+		/* XGIInitNewt for LINUXBIOS only */
+		if(XGIInitNew(&XGIhw_ext))
+		{
+			printk("OK\n");
+		}
+		else
+		{
+		    printk("Fail\n");
+		}
+#endif
+
+		outXGIIDXREG(XGISR, IND_XGI_PASSWORD, XGI_PASSWORD);
+
+
+	    }
+	}
+#ifdef LINUXBIOS
+	else
+	{
+	    XGIhw_ext.pjVideoMemoryAddress = ioremap(xgi_video_info.video_base, 0x10000000);
+	    if((xgifb_mode_idx < 0) || ((XGIbios_mode[xgifb_mode_idx].mode_no) != 0xFF))
+	    {
+
+		outXGIIDXREG(XGISR, IND_XGI_PASSWORD, XGI_PASSWORD);
+
+		// yilin Because no VBIOS DRAM Sizing, Dram size will error.
+		// Set SR13 ,14 temporarily for UDtech
+		outXGIIDXREG(XGISR, 0x13, 0x45);
+		outXGIIDXREG(XGISR, 0x14, 0x51);
+
+
+	    }
+	}
+#endif
+	if (XGIfb_get_dram_size())
+	{
+	    vfree(XGIhw_ext.pSR);
+	    vfree(XGIhw_ext.pCR);
+	    printk(KERN_INFO "XGIfb: Fatal error: Unable to determine RAM size.\n");
+	    return -ENODEV;
+	}
+
+
+
+	  if((xgifb_mode_idx < 0) || ((XGIbios_mode[xgifb_mode_idx].mode_no) != 0xFF))
+	  {
+	       /* Enable PCI_LINEAR_ADDRESSING and MMIO_ENABLE  */
+        orXGIIDXREG(XGISR, IND_XGI_PCI_ADDRESS_SET, (XGI_PCI_ADDR_ENABLE | XGI_MEM_MAP_IO_ENABLE));
+         /* Enable 2D accelerator engine */
+        orXGIIDXREG(XGISR, IND_XGI_MODULE_ENABLE, XGI_ENABLE_2D);
+    }
+
+	  XGIhw_ext.ulVideoMemorySize = xgi_video_info.video_size;
+
+	  if (!request_mem_region(xgi_video_info.video_base, xgi_video_info.video_size, "XGIfb FB"))
+	  {         printk("unable request memory size %x",xgi_video_info.video_size);
+		    printk(KERN_ERR "XGIfb: Fatal error: Unable to reserve frame buffer memory\n");
+		    printk(KERN_ERR "XGIfb: Is there another framebuffer driver active?\n");
+		    vfree(XGIhw_ext.pSR);
+		    vfree(XGIhw_ext.pCR);
+		    return -ENODEV;
+	  }
+
+	  if (!request_mem_region(xgi_video_info.mmio_base, XGIfb_mmio_size, "XGIfb MMIO"))
+	  {
+		    printk(KERN_ERR "XGIfb: Fatal error: Unable to reserve MMIO region\n");
+		    release_mem_region(xgi_video_info.video_base, xgi_video_info.video_size);
+		    vfree(XGIhw_ext.pSR);
+		    vfree(XGIhw_ext.pCR);
+		    return -ENODEV;
+	  }
+
+	  xgi_video_info.video_vbase = XGIhw_ext.pjVideoMemoryAddress =
+		ioremap(xgi_video_info.video_base, xgi_video_info.video_size);
+	  xgi_video_info.mmio_vbase = ioremap(xgi_video_info.mmio_base, XGIfb_mmio_size);
+
+	  printk(KERN_INFO "XGIfb: Framebuffer at 0x%lx, mapped to 0x%p, size %dk\n",
+	      xgi_video_info.video_base, xgi_video_info.video_vbase,xgi_video_info.video_size / 1024);
+
+	  printk(KERN_INFO "XGIfb: MMIO at 0x%lx, mapped to 0x%p, size %ldk\n",
+	      xgi_video_info.mmio_base, xgi_video_info.mmio_vbase,XGIfb_mmio_size / 1024);
+          printk("XGIfb: XGIInitNew() ...");
+	  if(XGIInitNew(&XGIhw_ext))
+	  {
+		  printk("OK\n");
+	  }
+	  else
+	  {
+		printk("Fail\n");
+	  }
+
+	  if(XGIfb_heap_init())
+	  {
+		    printk(KERN_WARNING "XGIfb: Failed to initialize offscreen memory heap\n");
+	  }
+
+
+	  xgi_video_info.mtrr = (unsigned int) 0;
+
+	  if((xgifb_mode_idx < 0) || ((XGIbios_mode[xgifb_mode_idx].mode_no) != 0xFF))
+	  {
+		  xgi_video_info.hasVB = HASVB_NONE;
+        if((xgi_video_info.chip == XG20)||(xgi_video_info.chip == XG27))
+	      xgi_video_info.hasVB = HASVB_NONE;
+        else if(xgi_video_info.chip == XG21) {
+            inXGIIDXREG(XGICR,0x38,CR38);
+            if ((CR38&0xE0) == 0xC0) {
+		    xgi_video_info.disp_state = DISPTYPE_LCD;
+        	    if (!XGIfb_GetXG21LVDSData()) {
+			    int m;
+			    for (m=0; m < sizeof(XGI21_LCDCapList)/sizeof(XGI21_LVDSCapStruct); m++) {
+				    if ((XGI21_LCDCapList[m].LVDSHDE == XGIbios_mode[xgifb_mode_idx].xres) &&
+					(XGI21_LCDCapList[m].LVDSVDE == XGIbios_mode[xgifb_mode_idx].yres)) {
+						XGINew_SetReg1( XGI_Pr.P3d4 , 0x36, m) ;
+				    }
+			    }
+		    }
+            }
+            else if ((CR38&0xE0) == 0x60)
+		xgi_video_info.hasVB = HASVB_CHRONTEL ;
+            else
+		xgi_video_info.hasVB = HASVB_NONE;
+	}
+        else
+		    XGIfb_get_VB_type();
+
+		    XGIhw_ext.ujVBChipID = VB_CHIP_UNKNOWN;
+
+		    XGIhw_ext.ulExternalChip = 0;
+
+		switch (xgi_video_info.hasVB) {
+		case HASVB_301:
+		        inXGIIDXREG(XGIPART4, 0x01, reg);
+			if (reg >= 0xE0) {
+				XGIhw_ext.ujVBChipID = VB_CHIP_302LV;
+				printk(KERN_INFO "XGIfb: XGI302LV bridge detected (revision 0x%02x)\n",reg);
+	  		} else if (reg >= 0xD0) {
+				XGIhw_ext.ujVBChipID = VB_CHIP_301LV;
+				printk(KERN_INFO "XGIfb: XGI301LV bridge detected (revision 0x%02x)\n",reg);
+	  		}
+			/* else if (reg >= 0xB0) {
+				XGIhw_ext.ujVBChipID = VB_CHIP_301B;
+				inXGIIDXREG(XGIPART4,0x23,reg1);
+			       printk("XGIfb: XGI301B bridge detected\n");
+			}*/
+			else {
+				XGIhw_ext.ujVBChipID = VB_CHIP_301;
+				printk("XGIfb: XGI301 bridge detected\n");
+			}
+			break;
+		case HASVB_302:
+		        inXGIIDXREG(XGIPART4, 0x01, reg);
+			if (reg >= 0xE0) {
+				XGIhw_ext.ujVBChipID = VB_CHIP_302LV;
+				printk(KERN_INFO "XGIfb: XGI302LV bridge detected (revision 0x%02x)\n",reg);
+	  		} else if (reg >= 0xD0) {
+				XGIhw_ext.ujVBChipID = VB_CHIP_301LV;
+				printk(KERN_INFO "XGIfb: XGI302LV bridge detected (revision 0x%02x)\n",reg);
+	  		} else if (reg >= 0xB0) {
+				inXGIIDXREG(XGIPART4,0x23,reg1);
+
+			        XGIhw_ext.ujVBChipID = VB_CHIP_302B;
+
+			} else {
+			        XGIhw_ext.ujVBChipID = VB_CHIP_302;
+				printk(KERN_INFO "XGIfb: XGI302 bridge detected\n");
+			}
+			break;
+		case HASVB_LVDS:
+			XGIhw_ext.ulExternalChip = 0x1;
+			printk(KERN_INFO "XGIfb: LVDS transmitter detected\n");
+			break;
+		case HASVB_TRUMPION:
+			XGIhw_ext.ulExternalChip = 0x2;
+			printk(KERN_INFO "XGIfb: Trumpion Zurac LVDS scaler detected\n");
+			break;
+		case HASVB_CHRONTEL:
+			XGIhw_ext.ulExternalChip = 0x4;
+			printk(KERN_INFO "XGIfb: Chrontel TV encoder detected\n");
+			break;
+		case HASVB_LVDS_CHRONTEL:
+			XGIhw_ext.ulExternalChip = 0x5;
+			printk(KERN_INFO "XGIfb: LVDS transmitter and Chrontel TV encoder detected\n");
+			break;
+ 		default:
+			printk(KERN_INFO "XGIfb: No or unknown bridge type detected\n");
+			break;
+		}
+
+		if (xgi_video_info.hasVB != HASVB_NONE) {
+		    XGIfb_detect_VB();
+    }
+
+		if (xgi_video_info.disp_state & DISPTYPE_DISP2) {
+			if (XGIfb_crt1off)
+				xgi_video_info.disp_state |= DISPMODE_SINGLE;
+			else
+				xgi_video_info.disp_state |= (DISPMODE_MIRROR | DISPTYPE_CRT1);
+		} else {
+			xgi_video_info.disp_state = DISPMODE_SINGLE | DISPTYPE_CRT1;
+		}
+
+		if (xgi_video_info.disp_state & DISPTYPE_LCD) {
+		    if (!enable_dstn) {
+		        inXGIIDXREG(XGICR, IND_XGI_LCD_PANEL, reg);
+			    reg &= 0x0f;
+			    XGIhw_ext.ulCRT2LCDType = XGI310paneltype[reg];
+
+		    } else {
+		        // TW: FSTN/DSTN
+			XGIhw_ext.ulCRT2LCDType = LCD_320x480;
+		    }
+		}
+
+		XGIfb_detectedpdc = 0;
+
+	        XGIfb_detectedlcda = 0xff;
+#ifndef LINUXBIOS
+
+                /* TW: Try to find about LCDA */
+
+        if((XGIhw_ext.ujVBChipID == VB_CHIP_302B) ||
+	       (XGIhw_ext.ujVBChipID == VB_CHIP_301LV) ||
+	       (XGIhw_ext.ujVBChipID == VB_CHIP_302LV))
+	    {
+	       int tmp;
+	       inXGIIDXREG(XGICR,0x34,tmp);
+	       if(tmp <= 0x13)
+	       {
+	          // Currently on LCDA? (Some BIOSes leave CR38)
+	          inXGIIDXREG(XGICR,0x38,tmp);
+		      if((tmp & 0x03) == 0x03)
+		      {
+//		          XGI_Pr.XGI_UseLCDA = TRUE;
+		      }else
+		      {
+		     //  Currently on LCDA? (Some newer BIOSes set D0 in CR35)
+		         inXGIIDXREG(XGICR,0x35,tmp);
+		         if(tmp & 0x01)
+		         {
+//		              XGI_Pr.XGI_UseLCDA = TRUE;
+		           }else
+		           {
+		               inXGIIDXREG(XGICR,0x30,tmp);
+		               if(tmp & 0x20)
+		               {
+		                   inXGIIDXREG(XGIPART1,0x13,tmp);
+			               if(tmp & 0x04)
+			               {
+//			                XGI_Pr.XGI_UseLCDA = TRUE;
+			               }
+		               }
+		           }
+		        }
+	         }
+
+        }
+
+
+#endif
+
+		if (xgifb_mode_idx >= 0)
+			xgifb_mode_idx = XGIfb_validate_mode(xgifb_mode_idx);
+
+		if (xgifb_mode_idx < 0) {
+			switch (xgi_video_info.disp_state & DISPTYPE_DISP2) {
+			   case DISPTYPE_LCD:
+				xgifb_mode_idx = DEFAULT_LCDMODE;
+				if (xgi_video_info.chip == XG21)
+				{
+				    xgifb_mode_idx = XGIfb_GetXG21DefaultLVDSModeIdx();
+				}
+				break;
+			   case DISPTYPE_TV:
+				xgifb_mode_idx = DEFAULT_TVMODE;
+				break;
+			   default:
+				xgifb_mode_idx = DEFAULT_MODE;
+				break;
+			}
+		}
+
+		XGIfb_mode_no = XGIbios_mode[xgifb_mode_idx].mode_no;
+
+
+                if( xgi_video_info.refresh_rate == 0)
+		    xgi_video_info.refresh_rate = 60; /*yilin set default refresh rate */
+	        if(XGIfb_search_refresh_rate(xgi_video_info.refresh_rate) == 0)
+                {
+		    XGIfb_rate_idx = XGIbios_mode[xgifb_mode_idx].rate_idx;
+		    xgi_video_info.refresh_rate = 60;
+	        }
+
+		xgi_video_info.video_bpp = XGIbios_mode[xgifb_mode_idx].bpp;
+		xgi_video_info.video_vwidth = xgi_video_info.video_width = XGIbios_mode[xgifb_mode_idx].xres;
+		xgi_video_info.video_vheight = xgi_video_info.video_height = XGIbios_mode[xgifb_mode_idx].yres;
+		xgi_video_info.org_x = xgi_video_info.org_y = 0;
+		xgi_video_info.video_linelength = xgi_video_info.video_width * (xgi_video_info.video_bpp >> 3);
+		switch(xgi_video_info.video_bpp) {
+        	case 8:
+            		xgi_video_info.DstColor = 0x0000;
+	    		xgi_video_info.XGI310_AccelDepth = 0x00000000;
+			xgi_video_info.video_cmap_len = 256;
+            		break;
+        	case 16:
+            		xgi_video_info.DstColor = 0x8000;
+            		xgi_video_info.XGI310_AccelDepth = 0x00010000;
+			xgi_video_info.video_cmap_len = 16;
+            		break;
+        	case 32:
+            		xgi_video_info.DstColor = 0xC000;
+	    		xgi_video_info.XGI310_AccelDepth = 0x00020000;
+			xgi_video_info.video_cmap_len = 16;
+            		break;
+		default:
+			xgi_video_info.video_cmap_len = 16;
+		        printk(KERN_INFO "XGIfb: Unsupported depth %d", xgi_video_info.video_bpp);
+			break;
+    		}
+
+
+
+		printk(KERN_INFO "XGIfb: Default mode is %dx%dx%d (%dHz)\n",
+	       		xgi_video_info.video_width, xgi_video_info.video_height, xgi_video_info.video_bpp,
+			xgi_video_info.refresh_rate);
+
+		default_var.xres = default_var.xres_virtual = xgi_video_info.video_width;
+		default_var.yres = default_var.yres_virtual = xgi_video_info.video_height;
+		default_var.bits_per_pixel = xgi_video_info.video_bpp;
+
+		XGIfb_bpp_to_var(&default_var);
+
+		default_var.pixclock = (u32) (1000000000 /
+				XGIfb_mode_rate_to_dclock(&XGI_Pr, &XGIhw_ext,
+						XGIfb_mode_no, XGIfb_rate_idx));
+
+		if(XGIfb_mode_rate_to_ddata(&XGI_Pr, &XGIhw_ext,
+			 XGIfb_mode_no, XGIfb_rate_idx,
+			 &default_var.left_margin, &default_var.right_margin,
+			 &default_var.upper_margin, &default_var.lower_margin,
+			 &default_var.hsync_len, &default_var.vsync_len,
+			 &default_var.sync, &default_var.vmode)) {
+
+		   if((default_var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
+		      default_var.yres <<= 1;
+		      default_var.yres_virtual <<= 1;
+		   } else if((default_var.vmode	& FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
+		      default_var.pixclock >>= 1;
+		      default_var.yres >>= 1;
+		      default_var.yres_virtual >>= 1;
+		   }
+
+	        }
+
+
+#if 0
+#ifdef XGIFB_PAN
+		if(XGIfb_ypan) {
+	    		default_var.yres_virtual =
+				xgi_video_info.heapstart / (default_var.xres * (default_var.bits_per_pixel >> 3));
+	    		if(default_var.yres_virtual <= default_var.yres) {
+	        		default_var.yres_virtual = default_var.yres;
+	    		}
+		}
+#endif
+#endif
+
+
+		xgi_video_info.accel = 0;
+		if(XGIfb_accel) {
+		   xgi_video_info.accel = -1;
+		   default_var.accel_flags |= FB_ACCELF_TEXT;
+		   XGIfb_initaccel();
+		}
+
+		fb_info->flags = FBINFO_FLAG_DEFAULT;
+		fb_info->var = default_var;
+		fb_info->fix = XGIfb_fix;
+		fb_info->par = &xgi_video_info;
+		fb_info->screen_base = xgi_video_info.video_vbase;
+		fb_info->fbops = &XGIfb_ops;
+		XGIfb_get_fix(&fb_info->fix, -1, fb_info);
+		fb_info->pseudo_palette = pseudo_palette;
+
+		fb_alloc_cmap(&fb_info->cmap, 256 , 0);
+
+
+#ifdef CONFIG_MTRR
+		xgi_video_info.mtrr = mtrr_add((unsigned int) xgi_video_info.video_base,
+				(unsigned int) xgi_video_info.video_size,
+				MTRR_TYPE_WRCOMB, 1);
+		if(xgi_video_info.mtrr) {
+			printk(KERN_INFO "XGIfb: Added MTRRs\n");
+		}
+#endif
+
+		if(register_framebuffer(fb_info) < 0)
+    {
+			return -EINVAL;
+    }
+
+		XGIfb_registered = 1;
+
+		printk(KERN_INFO "XGIfb: Installed XGIFB_GET_INFO ioctl (%x)\n", XGIFB_GET_INFO);
+
+/*		printk(KERN_INFO "XGIfb: 2D acceleration is %s, scrolling mode %s\n",
+		     XGIfb_accel ? "enabled" : "disabled",
+		     XGIfb_ypan  ? "ypan" : "redraw");
+*/
+		printk(KERN_INFO "fb%d: %s frame buffer device, Version %d.%d.%02d\n",
+	       		fb_info->node, myid, VER_MAJOR, VER_MINOR, VER_LEVEL);
+
+
+	}
+
+	dumpVGAReg();
+
+	return 0;
+}
+
+
+/*****************************************************/
+/*                PCI DEVICE HANDLING                */
+/*****************************************************/
+
+static void __devexit xgifb_remove(struct pci_dev *pdev)
+{
+	/* Unregister the framebuffer */
+//	if(xgi_video_info.registered) {
+		unregister_framebuffer(fb_info);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,3))
+		framebuffer_release(fb_info);
+#else
+		kfree(fb_info);
+#endif
+//	}
+
+	pci_set_drvdata(pdev, NULL);
+
+};
+
+static struct pci_driver xgifb_driver = {
+	.name		= "xgifb",
+	.id_table 	= xgifb_pci_table,
+	.probe 		= xgifb_probe,
+	.remove 	= __devexit_p(xgifb_remove)
+};
+
+XGIINITSTATIC int __init xgifb_init(void)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+#ifndef MODULE
+	char *option = NULL;
+
+	if (fb_get_options("xgifb", &option))
+		return -ENODEV;
+	XGIfb_setup(option);
+#endif
+#endif
+	return(pci_register_driver(&xgifb_driver));
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+#ifndef MODULE
+module_init(xgifb_init);
+#endif
+#endif
+
+/*****************************************************/
+/*                      MODULE                       */
+/*****************************************************/
+
+#ifdef MODULE
+
+static char         *mode = NULL;
+static int          vesa = 0;
+static unsigned int rate = 0;
+static unsigned int crt1off = 1;
+static unsigned int mem = 0;
+static char         *forcecrt2type = NULL;
+static int          forcecrt1 = -1;
+static int          pdc = -1;
+static int          pdc1 = -1;
+static int          noaccel = -1;
+static int          noypan  = -1;
+static int	    nomax = -1;
+static int          userom = -1;
+static int          useoem = -1;
+static char         *tvstandard = NULL;
+static int	    nocrt2rate = 0;
+static int          scalelcd = -1;
+static char	    *specialtiming = NULL;
+static int	    lvdshl = -1;
+static int	    tvxposoffset = 0, tvyposoffset = 0;
+#if !defined(__i386__) && !defined(__x86_64__)
+static int	    resetcard = 0;
+static int	    videoram = 0;
+#endif
+
+MODULE_DESCRIPTION("Z7 Z9 Z9S Z11 framebuffer device driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("XGITECH , Others");
+
+
+
+module_param(mem, int, 0);
+module_param(noaccel, int, 0);
+module_param(noypan, int, 0);
+module_param(nomax, int, 0);
+module_param(userom, int, 0);
+module_param(useoem, int, 0);
+module_param(mode, charp, 0);
+module_param(vesa, int, 0);
+module_param(rate, int, 0);
+module_param(forcecrt1, int, 0);
+module_param(forcecrt2type, charp, 0);
+module_param(scalelcd, int, 0);
+module_param(pdc, int, 0);
+module_param(pdc1, int, 0);
+module_param(specialtiming, charp, 0);
+module_param(lvdshl, int, 0);
+module_param(tvstandard, charp, 0);
+module_param(tvxposoffset, int, 0);
+module_param(tvyposoffset, int, 0);
+module_param(filter, int, 0);
+module_param(nocrt2rate, int, 0);
+#if !defined(__i386__) && !defined(__x86_64__)
+module_param(resetcard, int, 0);
+module_param(videoram, int, 0);
+#endif
+
+
+MODULE_PARM_DESC(mem,
+	"\nDetermines the beginning of the video memory heap in KB. This heap is used\n"
+	  "for video RAM management for eg. DRM/DRI. On 300 series, the default depends\n"
+	  "on the amount of video RAM available. If 8MB of video RAM or less is available,\n"
+	  "the heap starts at 4096KB, if between 8 and 16MB are available at 8192KB,\n"
+	  "otherwise at 12288KB. On 315 and Xabre series, the heap size is 32KB by default.\n"
+	  "The value is to be specified without 'KB' and must match the MaxXFBMem setting\n"
+	  "for XFree86 4.x/X.org 6.7 and later.\n");
+
+MODULE_PARM_DESC(noaccel,
+        "\nIf set to anything other than 0, 2D acceleration will be disabled.\n"
+	  "(default: 0)\n");
+
+MODULE_PARM_DESC(noypan,
+        "\nIf set to anything other than 0, y-panning will be disabled and scrolling\n"
+ 	  "will be performed by redrawing the screen. (default: 0)\n");
+
+MODULE_PARM_DESC(nomax,
+        "\nIf y-panning is enabled, xgifb will by default use the entire available video\n"
+	  "memory for the virtual screen in order to optimize scrolling performance. If\n"
+	  "this is set to anything other than 0, xgifb will not do this and thereby \n"
+	  "enable the user to positively specify a virtual Y size of the screen using\n"
+	  "fbset. (default: 0)\n");
+
+
+
+MODULE_PARM_DESC(mode,
+       "\nSelects the desired default display mode in the format XxYxDepth,\n"
+         "eg. 1024x768x16. Other formats supported include XxY-Depth and\n"
+	 "XxY-Depth@Rate. If the parameter is only one (decimal or hexadecimal)\n"
+	 "number, it will be interpreted as a VESA mode number. (default: 800x600x8)\n");
+
+MODULE_PARM_DESC(vesa,
+       "\nSelects the desired default display mode by VESA defined mode number, eg.\n"
+         "0x117 (default: 0x0103)\n");
+
+
+MODULE_PARM_DESC(rate,
+	"\nSelects the desired vertical refresh rate for CRT1 (external VGA) in Hz.\n"
+	  "If the mode is specified in the format XxY-Depth@Rate, this parameter\n"
+	  "will be ignored (default: 60)\n");
+
+MODULE_PARM_DESC(forcecrt1,
+	"\nNormally, the driver autodetects whether or not CRT1 (external VGA) is \n"
+	  "connected. With this option, the detection can be overridden (1=CRT1 ON,\n"
+	  "0=CRT1 OFF) (default: [autodetected])\n");
+
+MODULE_PARM_DESC(forcecrt2type,
+	"\nIf this option is omitted, the driver autodetects CRT2 output devices, such as\n"
+	  "LCD, TV or secondary VGA. With this option, this autodetection can be\n"
+	  "overridden. Possible parameters are LCD, TV, VGA or NONE. NONE disables CRT2.\n"
+	  "On systems with a SiS video bridge, parameters SVIDEO, COMPOSITE or SCART can\n"
+	  "be used instead of TV to override the TV detection. Furthermore, on systems\n"
+	  "with a SiS video bridge, SVIDEO+COMPOSITE, HIVISION, YPBPR480I, YPBPR480P,\n"
+	  "YPBPR720P and YPBPR1080I are understood. However, whether or not these work\n"
+	  "depends on the very hardware in use. (default: [autodetected])\n");
+
+MODULE_PARM_DESC(scalelcd,
+	"\nSetting this to 1 will force the driver to scale the LCD image to the panel's\n"
+	  "native resolution. Setting it to 0 will disable scaling; LVDS panels will\n"
+	  "show black bars around the image, TMDS panels will probably do the scaling\n"
+	  "themselves. Default: 1 on LVDS panels, 0 on TMDS panels\n");
+
+MODULE_PARM_DESC(pdc,
+        "\nThis is for manually selecting the LCD panel delay compensation. The driver\n"
+	  "should detect this correctly in most cases; however, sometimes this is not\n"
+	  "possible. If you see 'small waves' on the LCD, try setting this to 4, 32 or 24\n"
+	  "on a 300 series chipset; 6 on a 315 series chipset. If the problem persists,\n"
+	  "try other values (on 300 series: between 4 and 60 in steps of 4; on 315 series:\n"
+	  "any value from 0 to 31). (default: autodetected, if LCD is active during start)\n");
+
+MODULE_PARM_DESC(pdc1,
+        "\nThis is same as pdc, but for LCD-via CRT1. Hence, this is for the 315/330\n"
+	  "series only. (default: autodetected if LCD is in LCD-via-CRT1 mode during\n"
+	  "startup) - Note: currently, this has no effect because LCD-via-CRT1 is not\n"
+	  "implemented yet.\n");
+
+MODULE_PARM_DESC(specialtiming,
+	"\nPlease refer to documentation for more information on this option.\n");
+
+MODULE_PARM_DESC(lvdshl,
+	"\nPlease refer to documentation for more information on this option.\n");
+
+MODULE_PARM_DESC(tvstandard,
+	"\nThis allows overriding the BIOS default for the TV standard. Valid choices are\n"
+	  "pal, ntsc, palm and paln. (default: [auto; pal or ntsc only])\n");
+
+MODULE_PARM_DESC(tvxposoffset,
+	"\nRelocate TV output horizontally. Possible parameters: -32 through 32.\n"
+	  "Default: 0\n");
+
+MODULE_PARM_DESC(tvyposoffset,
+	"\nRelocate TV output vertically. Possible parameters: -32 through 32.\n"
+	  "Default: 0\n");
+
+MODULE_PARM_DESC(filter,
+	"\nSelects TV flicker filter type (only for systems with a SiS301 video bridge).\n"
+	  "(Possible values 0-7, default: [no filter])\n");
+
+MODULE_PARM_DESC(nocrt2rate,
+	"\nSetting this to 1 will force the driver to use the default refresh rate for\n"
+	  "CRT2 if CRT2 type is VGA. (default: 0, use same rate as CRT1)\n");
+
+
+
+
+int __init xgifb_init_module(void)
+{
+        printk("\nXGIfb_init_module");
+	if(mode)
+		XGIfb_search_mode(mode);
+	else if (vesa != -1)
+		XGIfb_search_vesamode(vesa);
+
+        return(xgifb_init());
+}
+
+static void __exit xgifb_remove_module(void)
+{
+	pci_unregister_driver(&xgifb_driver);
+	printk(KERN_DEBUG "xgifb: Module unloaded\n");
+}
+
+module_init(xgifb_init_module);
+module_exit(xgifb_remove_module);
+
+#endif 	   /*  /MODULE  */
+
+EXPORT_SYMBOL(XGI_malloc);
+EXPORT_SYMBOL(XGI_free);
+
--- /dev/null
+++ b/drivers/staging/xgifb/XGIfb.h
@@ -0,0 +1,215 @@
+#ifndef _LINUX_XGIFB
+#define _LINUX_XGIFB
+#include <linux/spinlock.h>
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+#define DISPTYPE_CRT1       0x00000008L
+#define DISPTYPE_CRT2       0x00000004L
+#define DISPTYPE_LCD        0x00000002L
+#define DISPTYPE_TV         0x00000001L
+#define DISPTYPE_DISP1      DISPTYPE_CRT1
+#define DISPTYPE_DISP2      (DISPTYPE_CRT2 | DISPTYPE_LCD | DISPTYPE_TV)
+#define DISPMODE_SINGLE	    0x00000020L
+#define DISPMODE_MIRROR	    0x00000010L
+#define DISPMODE_DUALVIEW   0x00000040L
+
+#define HASVB_NONE      	0x00
+#define HASVB_301       	0x01
+#define HASVB_LVDS      	0x02
+#define HASVB_TRUMPION  	0x04
+#define HASVB_LVDS_CHRONTEL	0x10
+#define HASVB_302       	0x20
+#define HASVB_303       	0x40
+#define HASVB_CHRONTEL  	0x80
+
+#ifndef XGIFB_ID
+#define XGIFB_ID          0x53495346    /* Identify myself with 'XGIF' */
+#endif
+
+typedef enum _XGI_CHIP_TYPE {
+    XGI_VGALegacy = 0,
+    XGI_300,
+    XGI_630,
+    XGI_730,
+    XGI_540,
+    XGI_315H,
+    XGI_315,
+    XGI_315PRO,
+    XGI_550,
+    XGI_640,
+    XGI_740,
+    XGI_650,
+    XGI_650M,
+    XGI_330 = 16,
+    XGI_660,
+    XGI_661,
+    XGI_760,
+    XG40 = 32,
+    XG41,
+    XG42,
+    XG45,
+    XG20 = 48,
+    XG21,
+    XG27,
+    MAX_XGI_CHIP
+} XGI_CHIP_TYPE;
+
+typedef enum _TVTYPE {
+	TVMODE_NTSC = 0,
+	TVMODE_PAL,
+	TVMODE_HIVISION,
+	TVTYPE_PALM,	// vicki@030226
+    	TVTYPE_PALN,	// vicki@030226
+    	TVTYPE_NTSCJ,	// vicki@030226
+	TVMODE_TOTAL
+} XGI_TV_TYPE;
+
+
+typedef struct _XGIFB_INFO XGIfb_info;
+struct _XGIFB_INFO {
+
+unsigned long XGIfb_id;
+ 	int    chip_id;			/* PCI ID of detected chip */
+	int    memory;			/* video memory in KB which XGIfb manages */
+	int    heapstart;               /* heap start (= XGIfb "mem" argument) in KB */
+	unsigned char fbvidmode;	/* current XGIfb mode */
+
+	unsigned char XGIfb_version;
+	unsigned char XGIfb_revision;
+	unsigned char XGIfb_patchlevel;
+
+	unsigned char XGIfb_caps;	/* XGIfb capabilities */
+
+	int    XGIfb_tqlen;		/* turbo queue length (in KB) */
+
+	unsigned int XGIfb_pcibus;      /* The card's PCI ID */
+	unsigned int XGIfb_pcislot;
+	unsigned int XGIfb_pcifunc;
+
+	unsigned char XGIfb_lcdpdc;	/* PanelDelayCompensation */
+
+	unsigned char XGIfb_lcda;	/* Detected status of LCDA for low res/text modes */
+
+	char reserved[235]; 		/* for future use */
+};
+
+
+
+
+typedef enum _TVPLUGTYPE {	// vicki@030226
+//	TVPLUG_Legacy = 0,
+//	TVPLUG_COMPOSITE,
+//	TVPLUG_SVIDEO,
+//	TVPLUG_SCART,
+//	TVPLUG_TOTAL
+    	TVPLUG_UNKNOWN = 0,
+    	TVPLUG_COMPOSITE = 1,
+    	TVPLUG_SVIDEO = 2,
+    	TVPLUG_COMPOSITE_AND_SVIDEO = 3,
+    	TVPLUG_SCART = 4,
+    	TVPLUG_YPBPR_525i = 5,
+    	TVPLUG_YPBPR_525P = 6,
+    	TVPLUG_YPBPR_750P = 7,
+    	TVPLUG_YPBPR_1080i = 8,
+	TVPLUG_TOTAL
+} XGI_TV_PLUG;
+
+
+struct mode_info {
+	int    bpp;
+	int    xres;
+	int    yres;
+	int    v_xres;
+	int    v_yres;
+	int    org_x;
+	int    org_y;
+	unsigned int  vrate;
+};
+
+struct ap_data {
+	struct mode_info minfo;
+	unsigned long iobase;
+	unsigned int  mem_size;
+	unsigned long disp_state;
+	XGI_CHIP_TYPE chip;
+	unsigned char hasVB;
+	XGI_TV_TYPE TV_type;
+	XGI_TV_PLUG TV_plug;
+	unsigned long version;
+	char reserved[256];
+};
+
+
+
+/*     If changing this, vgatypes.h must also be changed (for X driver)    */
+
+
+/*
+ * NOTE! The ioctl types used to be "size_t" by mistake, but were
+ * really meant to be __u32. Changed to "__u32" even though that
+ * changes the value on 64-bit architectures, because the value
+ * (with a 4-byte size) is also hardwired in vgatypes.h for user
+ * space exports. So "__u32" is actually more compatible, duh!
+ */
+#define XGIFB_GET_INFO	  	_IOR('n',0xF8,__u32)
+#define XGIFB_GET_VBRSTATUS  	_IOR('n',0xF9,__u32)
+
+
+
+struct video_info{
+        int           chip_id;
+        unsigned int  video_size;
+        unsigned long video_base;
+        char  *       video_vbase;
+        unsigned long mmio_base;
+        char  *       mmio_vbase;
+        unsigned long vga_base;
+        unsigned long mtrr;
+        unsigned long heapstart;
+
+        int    video_bpp;
+        int    video_cmap_len;
+        int    video_width;
+        int    video_height;
+        int    video_vwidth;
+        int    video_vheight;
+        int    org_x;
+        int    org_y;
+        int    video_linelength;
+        unsigned int refresh_rate;
+
+        unsigned long disp_state;
+        unsigned char hasVB;
+        unsigned char TV_type;
+        unsigned char TV_plug;
+
+        XGI_CHIP_TYPE chip;
+        unsigned char revision_id;
+
+        unsigned short DstColor;
+        unsigned long  XGI310_AccelDepth;
+        unsigned long  CommandReg;
+
+        spinlock_t     lockaccel;
+
+        unsigned int   pcibus;
+        unsigned int   pcislot;
+        unsigned int   pcifunc;
+
+        int            accel;
+        unsigned short subsysvendor;
+        unsigned short subsysdevice;
+
+        char reserved[236];
+};
+
+
+extern struct video_info xgi_video_info;
+
+#ifdef __KERNEL__
+//extern void xgi_malloc(struct xgi_memreq *req);
+extern void xgi_free(unsigned long base);
+extern void xgi_dispinfo(struct ap_data *rec);
+#endif
+#endif
--- /dev/null
+++ b/drivers/staging/xgifb/osdef.h
@@ -0,0 +1,153 @@
+#ifndef _OSDEF_H_
+#define _OSDEF_H_
+
+/* #define WINCE_HEADER*/
+/*#define WIN2000*/
+/* #define TC */
+#define LINUX_KERNEL
+/* #define LINUX_XF86 */
+
+/**********************************************************************/
+#ifdef LINUX_KERNEL
+//#include <linux/config.h>
+#endif
+
+
+/**********************************************************************/
+#ifdef TC
+#endif
+#ifdef WIN2000
+#endif
+#ifdef WINCE_HEADER
+#endif
+#ifdef LINUX_XF86
+#define LINUX
+#endif
+#ifdef LINUX_KERNEL
+#define LINUX
+#endif
+
+/**********************************************************************/
+#ifdef TC
+#define XGI_SetMemory(MemoryAddress,MemorySize,value) memset(MemoryAddress, value, MemorySize);
+#endif
+#ifdef WIN2000
+#define XGI_SetMemory(MemoryAddress,MemorySize,value) MemFill((PVOID) MemoryAddress,(ULONG) MemorySize,(UCHAR) value);
+#endif
+#ifdef WINCE_HEADER
+#define XGI_SetMemory(MemoryAddress,MemorySize,value) memset(MemoryAddress, value, MemorySize);
+#endif
+#ifdef LINUX_XF86
+#define XGI_SetMemory(MemoryAddress,MemorySize,value) memset(MemoryAddress, value, MemorySize)
+#endif
+#ifdef LINUX_KERNEL
+#define XGI_SetMemory(MemoryAddress,MemorySize,value) memset(MemoryAddress, value, MemorySize)
+#endif
+/**********************************************************************/
+
+/**********************************************************************/
+
+#ifdef TC
+#define XGI_MemoryCopy(Destination,Soruce,Length) memmove(Destination, Soruce, Length);
+#endif
+#ifdef WIN2000
+#define XGI_MemoryCopy(Destination,Soruce,Length)  /*VideoPortMoveMemory((PUCHAR)Destination , Soruce,length);*/
+#endif
+#ifdef WINCE_HEADER
+#define XGI_MemoryCopy(Destination,Soruce,Length) memmove(Destination, Soruce, Length);
+#endif
+#ifdef LINUX_XF86
+#define XGI_MemoryCopy(Destination,Soruce,Length) memcpy(Destination,Soruce,Length)
+#endif
+#ifdef LINUX_KERNEL
+#define XGI_MemoryCopy(Destination,Soruce,Length) memcpy(Destination,Soruce,Length)
+#endif
+
+/**********************************************************************/
+
+#ifdef OutPortByte
+#undef OutPortByte
+#endif /* OutPortByte */
+
+#ifdef OutPortWord
+#undef OutPortWord
+#endif /* OutPortWord */
+
+#ifdef OutPortLong
+#undef OutPortLong
+#endif /* OutPortLong */
+
+#ifdef InPortByte
+#undef InPortByte
+#endif /* InPortByte */
+
+#ifdef InPortWord
+#undef InPortWord
+#endif /* InPortWord */
+
+#ifdef InPortLong
+#undef InPortLong
+#endif /* InPortLong */
+
+/**********************************************************************/
+/*  TC                                                                */
+/**********************************************************************/
+
+#ifdef TC
+#define OutPortByte(p,v) outp((unsigned short)(p),(unsigned char)(v))
+#define OutPortWord(p,v) outp((unsigned short)(p),(unsigned short)(v))
+#define OutPortLong(p,v) outp((unsigned short)(p),(unsigned long)(v))
+#define InPortByte(p)    inp((unsigned short)(p))
+#define InPortWord(p)    inp((unsigned short)(p))
+#define InPortLong(p)    ((inp((unsigned short)(p+2))<<16) | inp((unsigned short)(p)))
+#endif
+
+/**********************************************************************/
+/*  LINUX XF86                                                        */
+/**********************************************************************/
+
+#ifdef LINUX_XF86
+#define OutPortByte(p,v) outb((CARD16)(p),(CARD8)(v))
+#define OutPortWord(p,v) outw((CARD16)(p),(CARD16)(v))
+#define OutPortLong(p,v) outl((CARD16)(p),(CARD32)(v))
+#define InPortByte(p)    inb((CARD16)(p))
+#define InPortWord(p)    inw((CARD16)(p))
+#define InPortLong(p)    inl((CARD16)(p))
+#endif
+
+#ifdef LINUX_KERNEL
+#define OutPortByte(p,v) outb((u8)(v),(p))
+#define OutPortWord(p,v) outw((u16)(v),(p))
+#define OutPortLong(p,v) outl((u32)(v),(p))
+#define InPortByte(p)    inb(p)
+#define InPortWord(p)    inw(p)
+#define InPortLong(p)    inl(p)
+#endif
+
+/**********************************************************************/
+/*  WIN 2000                                                          */
+/**********************************************************************/
+
+#ifdef WIN2000
+#define OutPortByte(p,v) VideoPortWritePortUchar ((PUCHAR) (p), (UCHAR) (v))
+#define OutPortWord(p,v) VideoPortWritePortUshort((PUSHORT) (p), (USHORT) (v))
+#define OutPortLong(p,v) VideoPortWritePortUlong ((PULONG) (p), (ULONG) (v))
+#define InPortByte(p)    VideoPortReadPortUchar  ((PUCHAR) (p))
+#define InPortWord(p)    VideoPortReadPortUshort ((PUSHORT) (p))
+#define InPortLong(p)    VideoPortReadPortUlong  ((PULONG) (p))
+#endif
+
+
+/**********************************************************************/
+/*  WIN CE                                                          */
+/**********************************************************************/
+
+#ifdef WINCE_HEADER
+#define OutPortByte(p,v) WRITE_PORT_UCHAR ((PUCHAR) (p), (UCHAR) (v))
+#define OutPortWord(p,v) WRITE_PORT_USHORT((PUSHORT) (p), (USHORT) (v))
+#define OutPortLong(p,v) WRITE_PORT_ULONG ((PULONG) (p), (ULONG) (v))
+#define InPortByte(p)    READ_PORT_UCHAR  ((PUCHAR) (p))
+#define InPortWord(p)    READ_PORT_USHORT ((PUSHORT) (p))
+#define InPortLong(p)    READ_PORT_ULONG  ((PULONG) (p))
+#endif
+#endif // _OSDEF_H_
--- /dev/null
+++ b/drivers/staging/xgifb/vb_def.h
@@ -0,0 +1,1017 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/xgi/initdef.h,v 1.4 2000/12/02 01:16:17 dawes Exp $ */
+#ifndef _INITDEF_
+#define _INITDEF_
+
+#ifndef NewScratch
+#define NewScratch
+#endif
+/* shampoo */
+#ifdef LINUX_KERNEL
+#define SEQ_ADDRESS_PORT	  0x0014
+#define SEQ_DATA_PORT		  0x0015
+#define MISC_OUTPUT_REG_READ_PORT 0x001C
+#define MISC_OUTPUT_REG_WRITE_PORT 0x0012
+#define GRAPH_DATA_PORT		  0x1F
+#define GRAPH_ADDRESS_PORT	  0x1E
+#define XGI_MASK_DUAL_CHIP	  0x04  /* SR3A */
+#define CRTC_ADDRESS_PORT_COLOR   0x0024
+#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x0013
+#define PCI_COMMAND		0x04
+#endif
+/* ~shampoo */
+
+
+#define VB_XGI301	      0x0001  /*301b*/
+#define VB_XGI301B        0x0002
+#define VB_XGI302B        0x0004
+#define VB_XGI301LV     0x0008 /*301lv*/
+#define VB_XGI302LV     0x0010
+#define VB_XGI301C      0x0020       /* for 301C */
+#define  VB_NoLCD        0x8000
+/*end 301b*/
+
+#define VB_YPbPrInfo     0x07          /*301lv*/
+#define VB_YPbPr525i     0x00
+#define VB_YPbPr525p     0x01
+#define VB_YPbPr750p     0x02
+#define VB_YPbPr1080i    0x03
+
+/* #define CRT1Len 17 */
+#define LVDSCRT1Len             15
+#define CHTVRegDataLen          5
+
+/* #define ModeInfoFlag 0x07 */
+/* #define IsTextMode 0x07 */
+/* #define ModeText 0x00 */
+/* #define ModeCGA 0x01 */
+/* #define ModeEGA 0x02 */
+/* #define ModeVGA 0x03 */
+/* #define Mode15Bpp 0x04 */
+/* #define Mode16Bpp 0x05 */
+/* #define Mode24Bpp 0x06 */
+/* #define Mode32Bpp 0x07 */
+
+/* #define DACInfoFlag 0x18 */
+/* #define MemoryInfoFlag 0x1E0 */
+/* #define MemorySizeShift 0x05 */
+
+#define Charx8Dot               0x0200
+#define LineCompareOff          0x0400
+#define CRT2Mode                0x0800
+#define HalfDCLK                0x1000
+#define NoSupportSimuTV         0x2000
+#define DoubleScanMode          0x8000
+
+#define SupportAllCRT2          0x0078
+#define SupportTV               0x0008
+#define SupportHiVisionTV       0x0010
+#define SupportLCD              0x0020
+#define SupportRAMDAC2          0x0040
+#define NoSupportTV             0x0070
+#define NoSupportHiVisionTV     0x0060
+#define NoSupportLCD            0x0058
+#define SupportCHTV 		0x0800
+#define SupportCRT2in301C       0x0100       /* for 301C */
+#define SupportTV1024           0x0800  /*301b*/
+#define SupportYPbPr            0x1000  /*301lv*/
+#define InterlaceMode           0x0080
+#define SyncPP                  0x0000
+#define SyncPN                  0x4000
+#define SyncNP                  0x8000
+/* #define SyncNN 0xc000 */
+#define ECLKindex0              0x0000
+#define ECLKindex1              0x0100
+#define ECLKindex2              0x0200
+#define ECLKindex3              0x0300
+#define ECLKindex4              0x0400
+
+#define SetSimuScanMode         0x0001
+#define SwitchToCRT2            0x0002
+/* #define SetCRT2ToTV 0x009C */
+#define SetCRT2ToAVIDEO         0x0004
+#define SetCRT2ToSVIDEO         0x0008
+#define SetCRT2ToSCART          0x0010
+#define SetCRT2ToLCD            0x0020
+#define SetCRT2ToRAMDAC         0x0040
+#define SetCRT2ToHiVisionTV     0x0080
+#define SetNTSCTV               0x0000
+/* #define SetPALTV 0x0100 */
+#define SetInSlaveMode          0x0200
+#define SetNotSimuMode          0x0400
+#define SetNotSimuTVMode        0x0400
+#define SetDispDevSwitch        0x0800
+#define LoadDACFlag             0x1000
+#define DisableCRT2Display      0x2000
+#define DriverMode              0x4000
+#define HotKeySwitch            0x8000
+#define SetCHTVOverScan  	0x8000
+/* #define SetCRT2ToLCDA 0x8000 301b */
+#define PanelRGB18Bit           0x0100
+#define PanelRGB24Bit           0x0000
+
+#define TVOverScan              0x10
+#define TVOverScanShift         4
+#define ClearBufferFlag         0x20
+#define EnableDualEdge 		0x01		/*301b*/
+#define SetToLCDA		0x02
+
+#define YPbPrModeInfo           0x38
+/* #define YPbPrMode525i 0x00 */
+/* #define YPbPrMode525p 0x08 */
+/* #define YPbPrMode750p 0x10 */
+/* #define YPbPrMode1080i 0x18 */
+
+#define SetSCARTOutput          0x01
+#define BoardTVType             0x02
+#define  EnablePALMN           0x40
+/* #define ProgrammingCRT2 0x01 */
+/* #define TVSimuMode 0x02 */
+/* #define RPLLDIV2XO 0x04 */
+/* #define LCDVESATiming 0x08 */
+/* #define EnableLVDSDDA 0x10 */
+#define SetDispDevSwitchFlag    0x20
+#define CheckWinDos             0x40
+#define SetJDOSMode             0x80
+
+#define Panel320x480              0x07/*fstn*/
+/* [ycchen] 02/12/03 Modify for Multi-Sync. LCD Support */
+#define PanelResInfo            0x1F	/* CR36 Panel Type/LCDResInfo */
+#define PanelRefInfo            0x60
+#define Panel800x600            0x01
+#define Panel1024x768           0x02
+#define Panel1024x768x75        0x22
+#define Panel1280x1024          0x03
+#define Panel1280x1024x75       0x23
+#define Panel640x480            0x04
+#define Panel1024x600           0x05
+#define Panel1152x864           0x06
+#define Panel1280x960           0x07
+#define Panel1152x768           0x08
+#define Panel1400x1050          0x09
+#define Panel1280x768           0x0A
+#define Panel1600x1200          0x0B
+
+#define PanelRef60Hz            0x00
+#define PanelRef75Hz            0x20
+#define LCDRGB18Bit             0x01
+
+#define ExtChipTrumpion         0x06
+#define ExtChipCH7005           0x08
+#define ExtChipMitacTV          0x0a
+#define LCDNonExpanding         0x10
+#define LCDNonExpandingShift    4
+#define LCDSync                 0x20
+#define LCDSyncBit              0xe0
+#define LCDSyncShift            6
+
+/* #define DDC2DelayTime 300 */
+
+#define CRT2DisplayFlag         0x2000
+/* #define LCDDataLen 8 */
+/* #define HiTVDataLen 12 */
+/* #define TVDataLen 16 */
+/* #define SetPALTV 0x0100 */
+#define HalfDCLK                0x1000
+#define NTSCHT                  1716
+#define NTSCVT                  525
+#define PALHT                   1728
+#define PALVT                   625
+#define StHiTVHT                892
+#define StHiTVVT                1126
+#define StHiTextTVHT            1000
+#define StHiTextTVVT            1126
+#define ExtHiTVHT               2100
+#define ExtHiTVVT               1125
+
+#define St750pTVHT              1716
+#define St750pTVVT               525
+#define Ext750pTVHT             1716
+#define Ext750pTVVT              525
+#define St525pTVHT              1716
+#define St525pTVVT               525
+#define Ext525pTVHT             1716
+#define Ext525pTVVT              525
+#define St525iTVHT              1716
+#define St525iTVVT               525
+#define Ext525iTVHT             1716
+#define Ext525iTVVT              525
+
+#define VCLKStartFreq           25
+#define SoftDramType            0x80
+#define VCLK40                  0x04
+
+#define VCLK162             	0x21
+
+#define LCDRGB18Bit             0x01
+#define LoadDACFlag             0x1000
+#define AfterLockCRT2           0x4000
+#define SetCRT2ToAVIDEO         0x0004
+#define SetCRT2ToSCART          0x0010
+#define Ext2StructSize          5
+
+
+#define YPbPr525iVCLK           0x03B
+#define YPbPr525iVCLK_2         0x03A
+
+#define SwitchToCRT2            0x0002
+/* #define LCDVESATiming 0x08 */
+#define SetSCARTOutput          0x01
+#define AVIDEOSense             0x01
+#define SVIDEOSense             0x02
+#define SCARTSense              0x04
+#define LCDSense                0x08
+#define Monitor1Sense           0x20
+#define Monitor2Sense           0x10
+#define HiTVSense               0x40
+#define BoardTVType             0x02
+#define HotPlugFunction         0x08
+#define StStructSize            0x06
+
+
+#define XGI_CRT2_PORT_00        0x00 - 0x030
+#define XGI_CRT2_PORT_04        0x04 - 0x030
+#define XGI_CRT2_PORT_10        0x10 - 0x30
+#define XGI_CRT2_PORT_12        0x12 - 0x30
+#define XGI_CRT2_PORT_14        0x14 - 0x30
+
+
+#define LCDNonExpanding         0x10
+#define ADR_CRT2PtrData         0x20E
+#define offset_Zurac            0x210
+#define ADR_LVDSDesPtrData      0x212
+#define ADR_LVDSCRT1DataPtr     0x214
+#define ADR_CHTVVCLKPtr         0x216
+#define ADR_CHTVRegDataPtr      0x218
+
+#define LVDSDataLen             6
+/* #define EnableLVDSDDA 0x10 */
+/* #define LVDSDesDataLen 3 */
+#define ActiveNonExpanding      0x40
+#define ActiveNonExpandingShift 6
+/* #define ActivePAL 0x20 */
+#define ActivePALShift          5
+/* #define ModeSwitchStatus 0x0F */
+#define SoftTVType              0x40
+#define SoftSettingAddr         0x52
+#define ModeSettingAddr         0x53
+
+/* #define SelectCRT1Rate 0x4 */
+
+#define _PanelType00             0x00
+#define _PanelType01             0x08
+#define _PanelType02             0x10
+#define _PanelType03             0x18
+#define _PanelType04             0x20
+#define _PanelType05             0x28
+#define _PanelType06             0x30
+#define _PanelType07             0x38
+#define _PanelType08             0x40
+#define _PanelType09             0x48
+#define _PanelType0A             0x50
+#define _PanelType0B             0x58
+#define _PanelType0C             0x60
+#define _PanelType0D             0x68
+#define _PanelType0E             0x70
+#define _PanelType0F             0x78
+
+
+#define PRIMARY_VGA       0     /* 1: XGI is primary vga 0:XGI is secondary vga */
+#define BIOSIDCodeAddr          0x235
+#define OEMUtilIDCodeAddr       0x237
+#define VBModeIDTableAddr       0x239
+#define OEMTVPtrAddr            0x241
+#define PhaseTableAddr          0x243
+#define NTSCFilterTableAddr     0x245
+#define PALFilterTableAddr      0x247
+#define OEMLCDPtr_1Addr         0x249
+#define OEMLCDPtr_2Addr         0x24B
+#define LCDHPosTable_1Addr      0x24D
+#define LCDHPosTable_2Addr      0x24F
+#define LCDVPosTable_1Addr      0x251
+#define LCDVPosTable_2Addr      0x253
+#define OEMLCDPIDTableAddr      0x255
+
+#define VBModeStructSize        5
+#define PhaseTableSize          4
+#define FilterTableSize         4
+#define LCDHPosTableSize        7
+#define LCDVPosTableSize        5
+#define OEMLVDSPIDTableSize     4
+#define LVDSHPosTableSize       4
+#define LVDSVPosTableSize       6
+
+#define VB_ModeID               0
+#define VB_TVTableIndex         1
+#define VB_LCDTableIndex        2
+#define VB_LCDHIndex            3
+#define VB_LCDVIndex            4
+
+#define OEMLCDEnable            0x0001
+#define OEMLCDDelayEnable       0x0002
+#define OEMLCDPOSEnable         0x0004
+#define OEMTVEnable             0x0100
+#define OEMTVDelayEnable        0x0200
+#define OEMTVFlickerEnable      0x0400
+#define OEMTVPhaseEnable        0x0800
+#define OEMTVFilterEnable       0x1000
+
+#define OEMLCDPanelIDSupport    0x0080
+
+/* #define LCDVESATiming 0x0001 //LCD Info CR37 */
+/* #define EnableLVDSDDA 0x0002 */
+#define EnableScalingLCD        0x0008
+#define SetPWDEnable            0x0004
+#define SetLCDtoNonExpanding    0x0010
+/* #define SetLCDPolarity 0x00E0 */
+#define SetLCDDualLink          0x0100
+#define SetLCDLowResolution     0x0200
+#define SetLCDStdMode           0x0400
+#define SetTVStdMode            0x0200
+#define SetTVLowResolution      0x0400
+/* =============================================================
+   for 310
+============================================================== */
+#define SoftDRAMType        0x80
+#define SoftSetting_OFFSET  0x52
+#define SR07_OFFSET  0x7C
+#define SR15_OFFSET  0x7D
+#define SR16_OFFSET  0x81
+#define SR17_OFFSET  0x85
+#define SR19_OFFSET  0x8D
+#define SR1F_OFFSET  0x99
+#define SR21_OFFSET  0x9A
+#define SR22_OFFSET  0x9B
+#define SR23_OFFSET  0x9C
+#define SR24_OFFSET  0x9D
+#define SR25_OFFSET  0x9E
+#define SR31_OFFSET  0x9F
+#define SR32_OFFSET  0xA0
+#define SR33_OFFSET  0xA1
+
+#define CR40_OFFSET  0xA2
+#define SR25_1_OFFSET  0xF6
+#define CR49_OFFSET  0xF7
+
+#define VB310Data_1_2_Offset  0xB6
+#define VB310Data_4_D_Offset  0xB7
+#define VB310Data_4_E_Offset  0xB8
+#define VB310Data_4_10_Offset 0xBB
+
+#define RGBSenseDataOffset    0xBD
+#define YCSenseDataOffset     0xBF
+#define VideoSenseDataOffset  0xC1
+#define OutputSelectOffset    0xF3
+
+#define ECLK_MCLK_DISTANCE  0x14
+#define VBIOSTablePointerStart    0x200
+#define StandTablePtrOffset       VBIOSTablePointerStart+0x02
+#define EModeIDTablePtrOffset     VBIOSTablePointerStart+0x04
+#define CRT1TablePtrOffset        VBIOSTablePointerStart+0x06
+#define ScreenOffsetPtrOffset     VBIOSTablePointerStart+0x08
+#define VCLKDataPtrOffset         VBIOSTablePointerStart+0x0A
+#define MCLKDataPtrOffset         VBIOSTablePointerStart+0x0E
+#define CRT2PtrDataPtrOffset      VBIOSTablePointerStart+0x10
+#define TVAntiFlickPtrOffset      VBIOSTablePointerStart+0x12
+#define TVDelayPtr1Offset         VBIOSTablePointerStart+0x14
+#define TVPhaseIncrPtr1Offset     VBIOSTablePointerStart+0x16
+#define TVYFilterPtr1Offset       VBIOSTablePointerStart+0x18
+#define LCDDelayPtr1Offset        VBIOSTablePointerStart+0x20
+#define TVEdgePtr1Offset          VBIOSTablePointerStart+0x24
+#define CRT2Delay1Offset          VBIOSTablePointerStart+0x28
+#define LCDDataDesOffset     VBIOSTablePointerStart-0x02
+#define LCDDataPtrOffset          VBIOSTablePointerStart+0x2A
+#define LCDDesDataPtrOffset     VBIOSTablePointerStart+0x2C
+#define LCDDataList		VBIOSTablePointerStart+0x22	/* add for GetLCDPtr */
+#define TVDataList		VBIOSTablePointerStart+0x36	/* add for GetTVPtr */
+/*  */
+/* Modify from 310.inc */
+/*  */
+/*  */
+
+
+#define		ShowMsgFlag                  0x20               /* SoftSetting */
+#define		ShowVESAFlag                 0x10
+#define		HotPlugFunction              0x08
+#define		ModeSoftSetting              0x04
+#define		TVSoftSetting                0x02
+#define		LCDSoftSetting               0x01
+
+#define		GatingCRTinLCDA              0x10
+#define		SetHiTVOutput                0x08
+#define		SetYPbPrOutput               0x04
+#define		BoardTVType                  0x02
+#define		SetSCARTOutput               0x01
+
+#define		ModeSettingYPbPr             0x02               /* TVModeSetting, Others as same as CR30 */
+
+/* TVModeSetting same as CR35 */
+
+/* LCDModeSetting same as CR37 */
+
+#define		EnableNewTVFont              0x10               /* MiscCapability */
+
+#define		EnableLCDOutput              0x80               /* LCDCfgSetting */
+
+#define		SoftDRAMType                 0x80               /* DRAMSetting */
+#define		SoftDRAMConfig               0x40
+#define		MosSelDRAMType               0x20
+#define		SDRAM                        000h
+#define		SGRAM                        0x01
+#define		ESDRAM                       0x02
+
+#define		EnableAGPCfgSetting          0x01               /* AGPCfgSetting */
+
+/* ---------------- SetMode Stack */
+#define		CRT1Len                      15
+#define		VCLKLen                      4
+#define		DefThreshold                 0x0100
+#define		ExtRegsSize                  (57+8+37+70+63+28+768+1)/64+1
+
+#define		VGA_XGI315                   0x0001       /* VGA Type Info */
+#define		VGA_SNewis315e                  0x0002       /* 315 series */
+#define		VGA_XGI550                   0x0004
+#define		VGA_XGI640                   0x0008
+#define		VGA_XGI740                   0x0010
+#define		VGA_XGI650                   0x0020
+#define		VGA_XGI650M                  0x0040
+#define		VGA_XGI651                   0x0080
+#define		VGA_XGI340                   0x0001       /* 340 series */
+#define		VGA_XGI330                   0x0001       /* 330 series */
+#define		VGA_XGI660                   0x0001       /* 660 series */
+
+#define		VB_XGI301                    0x0001       /* VB Type Info */
+#define		VB_XGI301B                   0x0002       /* 301 series */
+#define		VB_XGI302B                   0x0004
+#define		VB_NoLCD                     0x8000
+#define		VB_XGI301LV                  0x0008
+#define		VB_XGI302LV                  0x0010
+#define		VB_LVDS_NS                   0x0001       /* 3rd party chip */
+#define		VB_CH7017                    0x0002
+#define         VB_CH7007                    0x0080       /* [Billy] 07/05/03 */
+/* #define VB_LVDS_SI 0x0004 */
+
+#define		ModeInfoFlag                 0x0007
+#define		IsTextMode                   0x0007
+#define		ModeText                     0x0000
+#define		ModeCGA                      0x0001
+#define		ModeEGA                      0x0002       /* 16 colors mode */
+#define		ModeVGA                      0x0003       /* 256 colors mode */
+#define		Mode15Bpp                    0x0004       /* 15 Bpp Color Mode */
+#define		Mode16Bpp                    0x0005       /* 16 Bpp Color Mode */
+#define		Mode24Bpp                    0x0006       /* 24 Bpp Color Mode */
+#define		Mode32Bpp                    0x0007       /* 32 Bpp Color Mode */
+
+#define		DACInfoFlag                  0x0018
+#define		MONODAC                      0x0000
+#define		CGADAC                       0x0008
+#define		EGADAC                       0x0010
+#define		VGADAC                       0x0018
+
+#define		MemoryInfoFlag               0x01e0
+#define		MemorySizeShift              5
+#define		Need1MSize                   0x0000
+#define		Need2MSize                   0x0020
+#define		Need4MSize                   0x0060
+#define		Need8MSize                   0x00e0
+#define		Need16MSize                  0x01e0
+
+#define		Charx8Dot                    0x0200
+#define		LineCompareOff               0x0400
+#define		CRT2Mode                     0x0800
+#define		HalfDCLK                     0x1000
+#define		NoSupportSimuTV              0x2000
+#define		DoubleScanMode               0x8000
+
+/* -------------- Ext_InfoFlag */
+#define		SupportModeInfo              0x0007
+#define		Support256                   0x0003
+#define		Support15Bpp                 0x0004
+#define		Support16Bpp                 0x0005
+#define		Support24Bpp                 0x0006
+#define		Support32Bpp                 0x0007
+
+#define		SupportAllCRT2               0x0078
+#define		SupportTV                    0x0008
+#define		SupportHiVisionTV            0x0010
+#define		SupportLCD                   0x0020
+#define		SupportRAMDAC2               0x0040
+#define		NoSupportTV                  0x0070
+#define		NoSupportHiVisionTV          0x0060
+#define		NoSupportLCD                 0x0058
+#define		SupportTV1024                0x0800       /* 301btest */
+#define		SupportYPbPr                 0x1000       /* 301lv */
+#define		InterlaceMode                0x0080
+#define		SyncPP                       0x0000
+#define		SyncPN                       0x4000
+#define		SyncNP                       0x8000
+#define		SyncNN                       0xC000
+
+/* -------------- SetMode Stack/Scratch */
+#define		SetSimuScanMode              0x0001       /* VBInfo/CR30 & CR31 */
+#define		SwitchToCRT2                 0x0002
+#define		SetCRT2ToTV1                 0x009C
+#define		SetCRT2ToTV                  0x089C
+#define		SetCRT2ToAVIDEO              0x0004
+#define		SetCRT2ToSVIDEO              0x0008
+#define		SetCRT2ToSCART               0x0010
+#define		SetCRT2ToLCD                 0x0020
+#define		SetCRT2ToRAMDAC              0x0040
+#define		SetCRT2ToHiVisionTV          0x0080
+#define		SetCRT2ToLCDA                0x0100
+#define		SetInSlaveMode               0x0200
+#define		SetNotSimuMode               0x0400
+#define		HKEventMode                  0x0800
+#define		SetCRT2ToYPbPr               0x0800
+#define		LoadDACFlag                  0x1000
+#define		DisableCRT2Display           0x2000
+#define		DriverMode                   0x4000
+#define		SetCRT2ToDualEdge            0x8000
+#define		HotKeySwitch                 0x8000
+
+#define		ProgrammingCRT2              0x0001       /* Set Flag */
+#define		EnableVCMode                 0x0002
+#define		SetHKEventMode               0x0004
+#define		ReserveTVOption              0x0008
+#define		DisableRelocateIO            0x0010
+#define		Win9xDOSMode                 0x0020
+#define		JDOSMode                     0x0040
+/* #define SetWin9xforJap 0x0080 // not used now */
+/* #define SetWin9xforKorea 0x0100 // not used now */
+#define		GatingCRT                    0x0800
+#define		DisableChB                   0x1000
+#define		EnableChB                    0x2000
+#define		DisableChA                   0x4000
+#define		EnableChA                    0x8000
+
+#define		SetNTSCTV                    0x0000       /* TV Info */
+#define		SetPALTV                     0x0001
+#define		SetNTSCJ                     0x0002
+#define		SetPALMTV                    0x0004
+#define		SetPALNTV                    0x0008
+#define		SetCHTVUnderScan             0x0000
+/* #define SetCHTVOverScan 0x0010 */
+#define		SetYPbPrMode525i             0x0020
+#define		SetYPbPrMode525p             0x0040
+#define		SetYPbPrMode750p             0x0080
+#define		SetYPbPrMode1080i            0x0100
+#define		SetTVStdMode                 0x0200
+#define		SetTVLowResolution           0x0400
+#define		SetTVSimuMode                0x0800
+#define		TVSimuMode                   0x0800
+#define		RPLLDIV2XO                   0x1000
+#define		NTSC1024x768                 0x2000
+#define		SetTVLockMode                0x4000
+
+#define		LCDVESATiming                0x0001       /* LCD Info/CR37 */
+#define		EnableLVDSDDA                0x0002
+#define		EnableScalingLCD             0x0008
+#define		SetPWDEnable                 0x0004
+#define		SetLCDtoNonExpanding         0x0010
+#define		SetLCDPolarity               0x00e0
+#define		SetLCDDualLink               0x0100
+#define		SetLCDLowResolution          0x0200
+#define		SetLCDStdMode                0x0400
+
+#define		DefaultLCDCap                0x80ea       /* LCD Capability shampoo */
+#define		RLVDSDHL00                   0x0000
+#define		RLVDSDHL01                   0x0001
+#define		RLVDSDHL10                   0x0002       /* default */
+#define		RLVDSDHL11                   0x0003
+#define		EnableLCD24bpp               0x0004       /* default */
+#define		DisableLCD24bpp              0x0000
+#define		RLVDSClkSFT0                 0x0000
+#define		RLVDSClkSFT1                 0x0008       /* default */
+#define		EnableLVDSDCBal              0x0010
+#define		DisableLVDSDCBal             0x0000       /* default */
+#define		SinglePolarity               0x0020       /* default */
+#define		MultiPolarity                0x0000
+#define		LCDPolarity                  0x00c0       /* default: SyncNN */
+#define		LCDSingleLink                0x0000       /* default */
+#define		LCDDualLink                  0x0100
+#define		EnableSpectrum               0x0200
+#define		DisableSpectrum              0x0000       /* default */
+#define		PWDEnable                    0x0400
+#define		PWDDisable                   0x0000       /* default */
+#define		PWMEnable                    0x0800
+#define		PWMDisable                   0x0000       /* default */
+#define		EnableVBCLKDRVLOW            0x4000
+#define		EnableVBCLKDRVHigh           0x0000       /* default */
+#define		EnablePLLSPLOW               0x8000
+#define		EnablePLLSPHigh              0x0000       /* default */
+
+#define		LCDBToA                      0x20               /* LCD SetFlag */
+#define		StLCDBToA                    0x40
+#define		LockLCDBToA                  0x80
+#define 	LCDToFull             	     0x10
+#define		AVIDEOSense                  0x01               /* CR32 */
+#define		SVIDEOSense                  0x02
+#define		SCARTSense                   0x04
+#define		LCDSense                     0x08
+#define		Monitor2Sense                0x10
+#define		Monitor1Sense                0x20
+#define		HiTVSense                    0x40
+
+#ifdef                   NewScratch
+#define		YPbPrSense                   0x80    /* NEW SCRATCH */
+#endif
+
+#define		TVSense                      0xc7
+
+#define		TVOverScan                   0x10               /* CR35 */
+#define		TVOverScanShift              4
+
+#ifdef                   NewScratch
+#define		NTSCMode                     0x00
+#define		PALMode                      0x00
+#define		NTSCJMode                    0x02
+#define		PALMNMode                    0x0c
+#define		YPbPrMode                    0xe0
+#define		YPbPrMode525i                0x00
+#define		YPbPrMode525p                0x20
+#define		YPbPrMode750p                0x40
+#define		YPbPrMode1080i               0x60
+#else                    /* Old Scratch */
+#define		ClearBufferFlag              0x20
+#endif
+
+
+#define		LCDRGB18Bit                  0x01               /* CR37 */
+#define		LCDNonExpanding              0x10
+#define		LCDNonExpandingShift         4
+#define		LCDSync                      0x20
+#define		LCDSyncBit                   0xe0               /* H/V polarity & sync ID */
+#define		LCDSyncShift                 6
+
+#ifdef                   NewScratch
+#define		ScalingLCD                   0x08
+#else                    /* Old Scratch */
+#define		ExtChipType                  0x0e
+#define		ExtChip301                   0x02
+#define		ExtChipLVDS                  0x04
+#define		ExtChipCH7019                0x06
+#define		ScalingLCD                   0x10
+#endif
+
+#define		EnableDualEdge               0x01               /* CR38 */
+#define		SetToLCDA                    0x02
+#ifdef                   NewScratch
+#define		SetYPbPr                     0x04
+#define		DisableChannelA              0x08
+#define		DisableChannelB              0x10
+#define		ExtChipType                  0xe0
+#define		ExtChip301                   0x20
+#define		ExtChipLVDS                  0x40
+#define		ExtChipCH7019                0x60
+#else                    /* Old Scratch */
+#define		YPbPrSense                   0x04
+#define		SetYPbPr                     0x08
+#define		YPbPrMode                    0x30
+#define		YPbPrMode525i                0x00
+#define		YPbPrMode525p                0x10
+#define		YPbPrMode750p                0x20
+#define		YPbPrMode1080i               0x30
+#define		PALMNMode                    0xc0
+#endif
+
+#define		BacklightControlBit          0x01               /* CR3A */
+#define		Win9xforJap                  0x40
+#define		Win9xforKorea                0x80
+
+#define		ForceMDBits                  0x07               /* CR3B */
+#define		ForceMD_JDOS                 0x00
+#define		ForceMD_640x400T             0x01
+#define		ForceMD_640x350T             0x02
+#define		ForceMD_720x400T             0x03
+#define		ForceMD_640x480E             0x04
+#define		ForceMD_640x400E             0x05
+#define		ForceP1Bit                   0x10
+#define		ForceP2Bit                   0x20
+#define		EnableForceMDinBIOS          0x40
+#define		EnableForceMDinDrv           0x80
+
+#ifdef                   NewScratch                      /* New Scratch */
+/* ---------------------- VUMA Information */
+#define		LCDSettingFromCMOS           0x04               /* CR3C */
+#define		TVSettingFromCMOS            0x08
+#define		DisplayDeviceFromCMOS        0x10
+#define		HKSupportInSBIOS             0x20
+#define		OSDSupportInSBIOS            0x40
+#define		DisableLogo                  0x80
+
+/* ---------------------- HK Evnet Definition */
+#define		HKEvent                      0x0f               /* CR3D */
+#define		HK_ModeSwitch                0x01
+#define		HK_Expanding                 0x02
+#define		HK_OverScan                  0x03
+#define		HK_Brightness                0x04
+#define		HK_Contrast                  0x05
+#define		HK_Mute                      0x06
+#define		HK_Volume                    0x07
+#define		ModeSwitchStatus             0xf0
+#define		ActiveCRT1                   0x10
+#define		ActiveLCD                    0x0020
+#define		ActiveTV                     0x40
+#define		ActiveCRT2                   0x80
+
+#define		TVSwitchStatus               0x1f               /* CR3E */
+#define		ActiveAVideo                 0x01
+#define		ActiveSVideo                 0x02
+#define		ActiveSCART                  0x04
+#define		ActiveHiTV                   0x08
+#define		ActiveYPbPr                  0x10
+
+#define		EnableHKEvent                0x01               /* CR3F */
+#define		EnableOSDEvent               0x02
+#define		StartOSDEvent                0x04
+#define		IgnoreHKEvent                0x08
+#define		IgnoreOSDEvent               0x10
+#else                    /* Old Scratch */
+#define		OSD_SBIOS                    0x02       /* SR17 */
+#define		DisableLogo                  0x04
+#define		SelectKDOS                   0x08
+#define		KorWinMode                   0x10
+#define		KorMode3Bit                  0x0020
+#define		PSCCtrlBit                  0x40
+#define		NPSCCtrlBitShift             6
+#define		BlueScreenBit                0x80
+
+#define		HKEvent                      0x0f       /* CR79 */
+#define		HK_ModeSwitch                0x01
+#define		HK_Expanding                 0x02
+#define		HK_OverScan                  0x03
+#define		HK_Brightness                0x04
+#define		HK_Contrast                  0x05
+#define		HK_Mute                      0x06
+#define		HK_Volume                    0x07
+#define		ActivePAL                    0x0020
+#define		ActivePALShift               5
+#define		ActiveNonExpanding           0x40
+#define		ActiveNonExpandingShift      6
+#define		ActiveOverScan               0x80
+#define		ActiveOverScanShift          7
+
+#define		ModeSwitchStatus             0x0b       /* SR15 */
+#define		ActiveCRT1                   0x01
+#define		ActiveLCD                    0x02
+#define		ActiveCRT2                   0x08
+
+#define		TVSwitchStatus               0xf0       /* SR16 */
+#define		TVConfigShift                3
+#define		ActiveTV                     0x01
+#define		ActiveYPbPr                  0x04
+#define		ActiveAVideo                 0x10
+#define		ActiveSVideo                 0x0020
+#define		ActiveSCART                  0x40
+#define		ActiveHiTV                   0x80
+
+#define		EnableHKEvent                0x01       /* CR7A */
+#define		EnableOSDEvent               0x02
+#define		StartOSDEvent                0x04
+#define		CMOSSupport                  0x08
+#define		HotKeySupport                0x10
+#define		IngoreHKOSDEvent             0x20
+#endif
+
+/* //------------- Misc. Definition */
+#define		SelectCRT1Rate               00h
+/* #define SelectCRT2Rate 04h */
+
+#define		DDC1DelayTime                1000
+#ifdef           TRUMPION
+#define		DDC2DelayTime                15
+#else
+#define		DDC2DelayTime                150
+#endif
+
+#define		R_FACTOR                     04Dh
+#define		G_FACTOR                     097h
+#define		B_FACTOR                     01Ch
+/* --------------------------------------------------------- */
+/* translated from asm code 301def.h */
+/*  */
+/* --------------------------------------------------------- */
+#define		LCDDataLen                   8
+#define		HiTVDataLen                  12
+#define		TVDataLen                    12
+#define		LVDSCRT1Len_H                8
+#define		LVDSCRT1Len_V                7
+#define		LVDSDataLen                  6
+#define		LVDSDesDataLen               6
+#define		LCDDesDataLen                6
+#define		LVDSDesDataLen2              8
+#define		LCDDesDataLen2               8
+#define		CHTVRegLen                   16
+#define		CHLVRegLen                   12
+
+#define		StHiTVHT                     892
+#define		StHiTVVT                     1126
+#define		StHiTextTVHT                 1000
+#define		StHiTextTVVT                 1126
+#define		ExtHiTVHT                    2100
+#define		ExtHiTVVT                    1125
+#define		NTSCHT                       1716
+#define		NTSCVT                        525
+#define		NTSC1024x768HT               1908
+#define		NTSC1024x768VT                525
+#define		PALHT                        1728
+#define		PALVT                         625
+
+#define		YPbPrTV525iHT                1716            /* YPbPr */
+#define		YPbPrTV525iVT                 525
+#define		YPbPrTV525pHT                1716
+#define		YPbPrTV525pVT                 525
+#define		YPbPrTV750pHT                1650
+#define		YPbPrTV750pVT                 750
+
+#define		CRT2VCLKSel                  0xc0
+
+#define		CRT2Delay1      	     0x04            /* XGI301 */
+#define		CRT2Delay2      	     0x0A            /* 301B,302 */
+
+
+#define		VCLK25_175           0x00
+#define		VCLK28_322           0x01
+#define		VCLK31_5             0x02
+#define		VCLK36               0x03
+#define		VCLK40               0x04
+#define		VCLK43_163           0x05
+#define		VCLK44_9             0x06
+#define		VCLK49_5             0x07
+#define		VCLK50               0x08
+#define		VCLK52_406           0x09
+#define		VCLK56_25            0x0A
+#define		VCLK65               0x0B
+#define		VCLK67_765           0x0C
+#define		VCLK68_179           0x0D
+#define		VCLK72_852           0x0E
+#define		VCLK75               0x0F
+#define		VCLK75_8             0x10
+#define		VCLK78_75            0x11
+#define		VCLK79_411           0x12
+#define		VCLK83_95            0x13
+#define		VCLK84_8             0x14
+#define		VCLK86_6             0x15
+#define		VCLK94_5             0x16
+#define		VCLK104_998          0x17
+#define		VCLK105_882          0x18
+#define		VCLK108_2            0x19
+#define		VCLK109_175          0x1A
+#define		VCLK113_309          0x1B
+#define		VCLK116_406          0x1C
+#define		VCLK132_258          0x1D
+#define		VCLK135_5            0x1E
+#define		VCLK139_054          0x1F
+#define		VCLK157_5            0x20
+#define		VCLK162              0x21
+#define		VCLK175              0x22
+#define		VCLK189              0x23
+#define		VCLK194_4            0x24
+#define		VCLK202_5            0x25
+#define		VCLK229_5            0x26
+#define		VCLK234              0x27
+#define		VCLK252_699          0x28
+#define		VCLK254_817          0x29
+#define		VCLK265_728          0x2A
+#define		VCLK266_952          0x2B
+#define		VCLK269_655          0x2C
+#define		VCLK272_042          0x2D
+#define		VCLK277_015          0x2E
+#define		VCLK286_359          0x2F
+#define		VCLK291_132          0x30
+#define		VCLK291_766          0x31
+#define		VCLK309_789          0x32
+#define		VCLK315_195          0x33
+#define		VCLK323_586          0x34
+#define		VCLK330_615          0x35
+#define		VCLK332_177          0x36
+#define		VCLK340_477          0x37
+#define		VCLK375_847          0x38
+#define		VCLK388_631          0x39
+#define		VCLK125_999          0x51
+#define		VCLK148_5            0x52
+#define		VCLK178_992          0x54
+#define		VCLK217_325          0x55
+#define		VCLK299_505          0x56
+#define		YPbPr750pVCLK        0x57
+
+#define		TVVCLKDIV2              0x3A
+#define		TVVCLK                  0x3B
+#define		HiTVVCLKDIV2          0x3C
+#define		HiTVVCLK              0x3D
+#define		HiTVSimuVCLK          0x3E
+#define		HiTVTextVCLK          0x3F
+#define		VCLK39_77              0x40
+/* #define YPbPr750pVCLK 0x0F */
+#define		YPbPr525pVCLK           0x3A
+/* #define ;;YPbPr525iVCLK 0x3B */
+/* #define ;;YPbPr525iVCLK_2 0x3A */
+#define		NTSC1024VCLK         0x41
+#define		VCLK25_175_41        0x42                  /* ; ScaleLCD */
+#define		VCLK25_175_42        0x43
+#define		VCLK28_322_43        0x44
+#define		VCLK40_44            0x45
+#define		VCLKQVGA_1           0x46                   /* ; QVGA */
+#define		VCLKQVGA_2           0x47
+#define		VCLKQVGA_3           0x48
+#define		VCLK35_2             0x49                    /* ; 800x480 */
+#define		VCLK122_61           0x4A
+#define		VCLK80_350           0x4B
+#define		VCLK107_385          0x4C
+
+#define		CHTVVCLK30_2         0x50                 /* ;;CHTV */
+#define		CHTVVCLK28_1         0x51
+#define		CHTVVCLK43_6         0x52
+#define		CHTVVCLK26_4         0x53
+#define		CHTVVCLK24_6         0x54
+#define		CHTVVCLK47_8         0x55
+#define		CHTVVCLK31_5         0x56
+#define		CHTVVCLK26_2         0x57
+#define		CHTVVCLK39           0x58
+#define		CHTVVCLK36           0x59
+
+#define		CH7007TVVCLK30_2     0x00                 /* [Billy] 2007/05/18 For CH7007 */
+#define		CH7007TVVCLK28_1     0x01
+#define		CH7007TVVCLK43_6     0x02
+#define		CH7007TVVCLK26_4     0x03
+#define		CH7007TVVCLK24_6     0x04
+#define		CH7007TVVCLK47_8     0x05
+#define		CH7007TVVCLK31_5     0x06
+#define		CH7007TVVCLK26_2     0x07
+#define		CH7007TVVCLK39       0x08
+#define		CH7007TVVCLK36       0x09
+
+#define		RES320x200                   0x00
+#define		RES320x240                   0x01
+#define		RES400x300                   0x02
+#define		RES512x384                   0x03
+#define		RES640x400                   0x04
+#define		RES640x480x60                0x05
+#define		RES640x480x72                0x06
+#define		RES640x480x75                0x07
+#define		RES640x480x85                0x08
+#define		RES640x480x100               0x09
+#define		RES640x480x120               0x0A
+#define		RES640x480x160               0x0B
+#define		RES640x480x200               0x0C
+#define		RES800x600x56                0x0D
+#define		RES800x600x60                0x0E
+#define		RES800x600x72                0x0F
+#define		RES800x600x75                0x10
+#define		RES800x600x85                0x11
+#define		RES800x600x100               0x12
+#define		RES800x600x120               0x13
+#define		RES800x600x160               0x14
+#define		RES1024x768x43               0x15
+#define		RES1024x768x60               0x16
+#define		RES1024x768x70               0x17
+#define		RES1024x768x75               0x18
+#define		RES1024x768x85               0x19
+#define		RES1024x768x100              0x1A
+#define		RES1024x768x120              0x1B
+#define		RES1280x1024x43              0x1C
+#define		RES1280x1024x60              0x1D
+#define		RES1280x1024x75              0x1E
+#define		RES1280x1024x85              0x1F
+#define		RES1600x1200x60              0x20
+#define		RES1600x1200x65              0x21
+#define		RES1600x1200x70              0x22
+#define		RES1600x1200x75              0x23
+#define		RES1600x1200x85              0x24
+#define		RES1600x1200x100             0x25
+#define		RES1600x1200x120             0x26
+#define		RES1920x1440x60              0x27
+#define		RES1920x1440x65              0x28
+#define		RES1920x1440x70              0x29
+#define		RES1920x1440x75              0x2A
+#define		RES1920x1440x85              0x2B
+#define		RES1920x1440x100             0x2C
+#define		RES2048x1536x60              0x2D
+#define		RES2048x1536x65              0x2E
+#define		RES2048x1536x70              0x2F
+#define		RES2048x1536x75              0x30
+#define		RES2048x1536x85              0x31
+#define		RES800x480x60                0x32
+#define		RES800x480x75                0x33
+#define		RES800x480x85                0x34
+#define		RES1024x576x60               0x35
+#define		RES1024x576x75               0x36
+#define		RES1024x576x85               0x37
+#define		RES1280x720x60               0x38
+#define		RES1280x720x75               0x39
+#define		RES1280x720x85               0x3A
+#define		RES1280x960x60               0x3B
+#define		RES720x480x60                0x3C
+#define		RES720x576x56                0x3D
+#define		RES856x480x79I               0x3E
+#define		RES856x480x60                0x3F
+#define		RES1280x768x60               0x40
+#define		RES1400x1050x60              0x41
+#define		RES1152x864x60               0x42
+#define		RES1152x864x75               0x43
+#define		RES1024x768x160              0x44
+#define		RES1280x960x75               0x45
+#define		RES1280x960x85               0x46
+#define		RES1280x960x120              0x47
+
+#define 	LFBDRAMTrap                  0x30
+#endif
--- /dev/null
+++ b/drivers/staging/xgifb/vb_ext.c
@@ -0,0 +1,1370 @@
+#include "osdef.h"
+
+
+
+
+#ifdef WIN2000
+
+#include <dderror.h>
+#include <devioctl.h>
+#include <miniport.h>
+#include <ntddvdeo.h>
+#include <video.h>
+#include "xgiv.h"
+#include "dd_i2c.h"
+#include "tools.h"
+#endif /* WIN2000 */
+
+#ifdef LINUX_XF86
+#include "xf86.h"
+#include "xf86PciInfo.h"
+#include "xgi.h"
+#include "xgi_regs.h"
+#endif
+
+#ifdef LINUX_KERNEL
+#include <linux/version.h>
+#include <asm/io.h>
+#include <linux/types.h>
+#include "XGIfb.h"
+/*#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <video/XGIfb.h>
+#else
+#include <linux/XGIfb.h>
+#endif*/
+#endif
+
+
+
+#include "vb_def.h"
+#include "vgatypes.h"
+#include "vb_struct.h"
+#include "vb_util.h"
+#include "vb_setmode.h"
+#include "vb_ext.h"
+extern   UCHAR XGI330_SoftSetting;
+extern   UCHAR XGI330_OutputSelect;
+extern   USHORT XGI330_RGBSenseData2;
+extern   USHORT XGI330_YCSenseData2;
+extern   USHORT XGI330_VideoSenseData2;
+#ifdef WIN2000
+extern   UCHAR SenseCHTV(PHW_DEVICE_EXTENSION pHWDE);       /* 2007/05/17 Billy */
+#endif
+void     XGI_GetSenseStatus( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo );
+BOOLEAN  XGINew_GetPanelID(PVB_DEVICE_INFO pVBInfo);
+USHORT   XGINew_SenseLCD(PXGI_HW_DEVICE_INFO,PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGINew_GetLCDDDCInfo(PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo);
+void XGISetDPMS( PXGI_HW_DEVICE_INFO pXGIHWDE , ULONG VESA_POWER_STATE ) ;
+BOOLEAN  XGINew_BridgeIsEnable(PXGI_HW_DEVICE_INFO,PVB_DEVICE_INFO pVBInfo );
+BOOLEAN  XGINew_Sense(USHORT tempbx,USHORT tempcx, PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGINew_SenseHiTV( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo ) ;
+
+/**************************************************************
+	Dynamic Sense
+*************************************************************/
+
+void XGI_WaitDisplay(void);
+BOOLEAN XGI_Is301C(PVB_DEVICE_INFO);
+BOOLEAN XGI_Is301LV(PVB_DEVICE_INFO);
+
+#ifdef WIN2000
+UCHAR XGI_SenseLCD(PHW_DEVICE_EXTENSION, PVB_DEVICE_INFO);
+UCHAR XGI_GetLCDDDCInfo(PHW_DEVICE_EXTENSION,PVB_DEVICE_INFO);
+
+extern BOOL bGetDdcInfo(
+PHW_DEVICE_EXTENSION  pHWDE,
+ULONG                 ulWhichOne,
+PUCHAR                pjQueryBuffer,
+ULONG                 ulBufferSize
+   );
+
+#endif
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_Is301B */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_Is301B( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT flag ;
+
+    flag = XGINew_GetReg1( pVBInfo->Part4Port , 0x01 ) ;
+
+    if ( flag > 0x0B0 )
+        return( 0 ) ;	/* 301b */
+    else
+        return( 1 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_Is301C */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_Is301C( PVB_DEVICE_INFO pVBInfo )
+{
+    if ( ( XGINew_GetReg1( pVBInfo->Part4Port , 0x01 ) & 0xF0 ) == 0xC0 )
+        return( 1 ) ;
+
+    if ( XGINew_GetReg1( pVBInfo->Part4Port , 0x01 ) >= 0xD0 )
+    {
+        if ( XGINew_GetReg1( pVBInfo->Part4Port , 0x39 ) == 0xE0 )
+            return( 1 ) ;
+    }
+
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_Is301LV */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_Is301LV( PVB_DEVICE_INFO pVBInfo )
+{
+    if ( XGINew_GetReg1( pVBInfo->Part4Port , 0x01 ) >= 0xD0 )
+    {
+        if ( XGINew_GetReg1( pVBInfo->Part4Port , 0x39 ) == 0xFF )
+        {
+            return( 1 ) ;
+        }
+    }
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_Sense */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_Sense(  USHORT tempbx , USHORT tempcx, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT temp , i , tempch ;
+
+    temp = tempbx & 0xFF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x11 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp |= ( tempcx & 0x00FF ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x10 , ~0x1F , temp ) ;
+
+    for( i = 0 ; i < 10 ; i++ )
+        XGI_LongWait( pVBInfo) ;
+
+    tempch = ( tempcx & 0x7F00 ) >> 8 ;
+    temp = XGINew_GetReg1( pVBInfo->Part4Port , 0x03 ) ;
+    temp = temp ^ ( 0x0E ) ;
+    temp &= tempch ;
+
+    if ( temp > 0 )
+        return( 1 ) ;
+    else
+        return( 0 ) ;
+}
+
+#ifdef WIN2000
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SenseLCD */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGI_SenseLCD( PHW_DEVICE_EXTENSION pHWDE, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax , tempbx , tempcx ;
+    UCHAR SoftSetting = XGI330_SoftSetting ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV ) )
+        return( 1 ) ;
+
+
+    if ( SoftSetting & HotPlugFunction )	/* Hot Plug Detection */
+    {
+        XGINew_SetRegAND( pVBInfo->Part4Port , 0x0F , 0x3F ) ;
+        tempbx = 0 ;
+        tempcx = 0x9010 ;
+        if ( XGINew_Sense( tempbx , tempcx, pVBInfo ) )
+            return( 1 ) ;
+
+        return( 0 ) ;
+    }
+    else	/* Get LCD Info from EDID */
+        return(XGI_GetLCDDDCInfo(pHWDE, pVBInfo));
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLCDDDCInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGI_GetLCDDDCInfo( PHW_DEVICE_EXTENSION pHWDE , PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR tempah , tempbl , tempbh ;
+    USHORT tempbx , temp ;
+    UCHAR pjEDIDBuf[ 256 ] ;
+    ULONG ulBufferSize = 256 ;
+    UCHAR bMASK_OUTPUTSTATE_CRT2LCD = 2 ; /* 0423 shampoo */
+
+    bGetDdcInfo( pHWDE , MASK_OUTPUTSTATE_CRT2LCD , pjEDIDBuf , ulBufferSize ) ;
+    if ( ( *( ( PULONG )pjEDIDBuf ) == 0xFFFFFF00 ) && ( *( ( PULONG )( pjEDIDBuf + 4 ) ) == 0x00FFFFFF ) )
+    {
+        tempah = Panel1024x768 ;
+        tempbl=( *( pjEDIDBuf + 0x3A ) ) & 0xf0 ;
+
+        if ( tempbl != 0x40 )
+        {
+            tempah = Panel1600x1200 ;
+            if ( tempbl != 0x60 )
+            {
+                tempah = Panel1280x1024 ;
+                tempbh = ( *( pjEDIDBuf + 0x3B ) ) ;
+                if ( tempbh != 0x00 )
+                {
+                    tempah = Panel1280x960 ;
+                    if ( tempbh != 0x0C0 )
+                    {
+                        tempbx = ( ( *( pjEDIDBuf + 0x24 ) ) << 8 ) | ( *( pjEDIDBuf + 0x23 ) ) ;
+                        tempah = Panel1280x1024 ;
+                        if ( !( tempbx & 0x0100 ) )
+                        {
+                            tempah = Panel1024x768 ;
+                            if ( !( tempbx & 0x0E00 ) )
+                            {
+                                tempah = Panel1280x1024 ;
+                            }
+                        }
+                    }
+
+                    if ( tempbx & 0x00FF )
+                    {
+                        temp = ScalingLCD ;
+                        XGINew_SetRegOR( pVBInfo->P3d4 , 0x37 , temp ) ;
+                    }
+                }
+            }
+        }
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x36 , ( ~0x07 ) , tempah ) ;
+        tempah = ( ( *( pjEDIDBuf + 0x47 ) ) & 0x06 ) ;		/* Polarity */
+        tempah = ( tempah ^ 0x06 ) << 4 ;
+        tempah |= LCDSync ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x37 , ( ~LCDSyncBit ) , tempah ) ;
+        tempbh= XGINew_GetReg1( pVBInfo->P3d4 , 0x36 ) ;
+        tempbh &= 0x07 ;
+        if ( tempbh == Panel1280x960 )
+            XGINew_SetRegAND( pVBInfo->P3d4 , 0x37 , 0x0E ) ;
+    }
+    else if ( *pjEDIDBuf == 0x20 )
+    {
+        tempah = Panel1024x768 ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x36 , ( ~0x07 ) , tempah ) ;
+    }
+    else
+    {
+        return( 0 ) ;
+    }
+
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DySense */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_DySense( PHW_DEVICE_EXTENSION pHWDE , PUCHAR ujConnectStatus)
+{
+    UCHAR pre_CRD,pre_SR1E , pre_Part2_0 , pre_Part4_D ;
+    USHORT tempax , tempbx , tempcx , pushax , temp ;
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    UCHAR OutputSelect = XGI330_OutputSelect ;
+    PXGI_HW_DEVICE_INFO HwDeviceExtension= pHWDE->pXGIHWDE ;
+    UCHAR   bConnectStatus = 0 ;
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ROMAddr  = pHWDE->pjVirtualRomBase ;
+
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pushax = XGINew_GetReg1( pVBInfo->P3d4 , 0x17 ) ;	/* 0512 Fix Dysense hanged */
+    temp = ( pushax & 0x00FF ) | 0x80 ;
+    XGINew_SetRegOR( pVBInfo->P3d4 , 0x17 , temp ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x05 , 0x86 ) ;
+    /* beginning of dynamic sense CRT1 */
+
+    pVBInfo->IF_DEF_CH7007 = 0;
+    if (pHWDE->bCH7007)
+    {
+    	InitTo330Pointer( pHWDE->pXGIHWDE->jChipType, pVBInfo ) ;
+        HwDeviceExtension->pDevice = (PVOID)pHWDE;
+        pVBInfo->IF_DEF_CH7007 = 1;
+        /* [Billy] 2007/05/14 For CH7007 */
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+           bConnectStatus = SenseCHTV(HwDeviceExtension->pDevice) ; /* 07/05/28 */
+           XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , ~0x03 , (UCHAR)bConnectStatus ) ;
+        }
+    }
+    if(( pHWDE->jChipID >= XG40 ) || ( pHWDE->jChipID >= XG20 ))
+    {
+
+        if ( pHWDE->jChipID >= XG40 )
+    	    XGINew_SetReg1( pVBInfo->P3d4 , 0x57 , 0x4A ) ;	/* write sense pattern 30->4a */
+    	else
+            XGINew_SetReg1( pVBInfo->P3d4 , 0x57 , 0x5F ) ;	/* write sense pattern */
+
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x53 , 0xFF , 0x02 ) ;	/* enable sense DAC */
+        XGI_WaitDisply(pVBInfo) ;
+
+        if(XGINew_GetReg2( pVBInfo->P3c2 ) & 0x10 )
+            bConnectStatus |= Monitor1Sense ;
+
+        XGINew_SetRegAND( pVBInfo->P3d4 , 0x53 , 0xFD ) ;	/* disable sense DAC */
+        XGINew_SetRegAND( pVBInfo->P3d4 , 0x57 , 0x00 ) ;	/* clear sense pattern */
+
+
+        /* ---------- End of dynamic sense CRT1 ----------- */
+
+        /* ---------- beginning of dynamic sense VB ------------ */
+        pre_SR1E = XGINew_GetReg1( pVBInfo->P3c4 , 0x1E ) ;
+        XGINew_SetRegOR( pVBInfo->P3c4 , 0x1E , 0x20 ) ;	/* Enable CRT2,work-a-round for 301B/301LV/302LV */
+        pre_Part2_0 = XGINew_GetReg1( pVBInfo->Part2Port , 0x00 ) ;
+        pre_Part4_D = XGINew_GetReg1( pVBInfo->Part4Port , 0x0D ) ;
+
+        if ( XGI_Is301C( pVBInfo ) )	/* 301C only */
+            XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x0D , ~0x07 , 0x01 ) ;	/* Set Part4 0x0D D[2:0] to 001b */
+
+        /* tempax = 0 ; */
+        if ( !XGI_Is301LV( pVBInfo ) )
+        {
+           tempbx = XGI330_RGBSenseData2 ;
+            tempcx = 0x0E08 ;
+            if(XGINew_Sense( tempbx , tempcx, pVBInfo ) )
+            {
+                bConnectStatus |= Monitor2Sense ;
+                if ( OutputSelect & SetSCARTOutput )
+                {
+                    bConnectStatus ^= ( Monitor2Sense | SCARTSense ) ;
+                }
+            }
+        }
+        if ( XGI_Is301C( pVBInfo ) )	/* 301C only */
+            XGINew_SetRegOR( pVBInfo->Part4Port , 0x0D , 0x04 ) ;	/* Set Part4 0x0D D[2]=1 for dynamic sense */
+
+        if ( ( XGINew_Is301B( pVBInfo ) ) )
+            XGINew_SetRegOR( pVBInfo->Part2Port , 0x00 , 0x0C ) ;    /* ????????? */
+
+	if ( XGINew_SenseHiTV( HwDeviceExtension , pVBInfo) )		/* add by kuku for Dysense HiTV //start */
+	{
+	    bConnectStatus|= YPbPrSense ;
+	}
+	else
+	{
+        tempbx = XGI330_YCSenseData2 ;	/* Y/C Sense Data Ptr */
+        tempcx = 0x0604 ;
+        if ( XGINew_Sense( tempbx , tempcx , pVBInfo) )
+            bConnectStatus |= SVIDEOSense ;
+
+        if ( OutputSelect & BoardTVType )
+        {
+            tempbx = XGI330_VideoSenseData2 ;
+            tempcx = 0x0804 ;
+            if ( XGINew_Sense(tempbx , tempcx, pVBInfo) )
+                bConnectStatus|= AVIDEOSense ;
+        }
+        else
+        {
+            if ( !( bConnectStatus & SVIDEOSense ) )
+            {
+                tempbx = XGI330_VideoSenseData2 ;
+                tempcx = 0x0804 ;
+                if ( XGINew_Sense( tempbx , tempcx, pVBInfo ) )
+                    bConnectStatus |= AVIDEOSense ;
+            }
+        }
+    	} /* end */
+        /* DySenseVBCnt */
+
+        tempbx = 0 ;
+        tempcx = 0 ;
+        XGINew_Sense(tempbx , tempcx, pVBInfo ) ;
+
+        if ( !( bConnectStatus & Monitor2Sense ) )
+        {
+            if ( XGI_SenseLCD( pHWDE , pVBInfo ) )
+                bConnectStatus |= LCDSense ;
+        }
+
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , ~( AVIDEOSense | SVIDEOSense | LCDSense | Monitor2Sense | Monitor1Sense ) , bConnectStatus ) ;
+
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x0D , pre_Part4_D ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x00 , pre_Part2_0 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x1E , pre_SR1E ) ;
+
+        if ( XGI_Is301C( pVBInfo ) )	/* 301C only */
+        {
+            tempax = XGINew_GetReg1( pVBInfo->Part2Port , 0x00 ) ;
+            if ( tempax & 0x20 )
+            {
+                /* Reset VBPro */
+                for( tempcx = 2 ; tempcx > 0 ; tempcx-- )
+                {
+                    tempax ^= 0x20 ;
+                    XGINew_SetReg1( pVBInfo->Part2Port , 0x00 , tempax ) ;
+                }
+            }
+        }
+        /* End of dynamic sense VB */
+    }
+    else
+    {
+        XGI_SenseCRT1(pVBInfo) ;
+        XGI_GetSenseStatus( HwDeviceExtension, pVBInfo ) ;	/* sense CRT2 */
+        bConnectStatus = XGINew_GetReg1( pVBInfo->P3d4 , 0x32 ) ;
+    }
+    temp = pushax & 0x00FF ;		/* 0512 Fix Dysense hanged */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x17 , temp ) ;
+    if ( bConnectStatus )
+    {
+        *ujConnectStatus = bConnectStatus ;
+        return( 1 ) ;
+    }
+    else
+        return( 0 ) ;
+}
+
+#endif /* WIN2000 */
+
+/* --------------------------------------------------------------------- */
+/* Function : XGISetDPMS */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+VOID XGISetDPMS( PXGI_HW_DEVICE_INFO pXGIHWDE , ULONG VESA_POWER_STATE )
+{
+    USHORT ModeNo, ModeIdIndex ;
+    UCHAR  temp ;
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->BaseAddr = (ULONG)pXGIHWDE->pjIOAddress ;
+    pVBInfo->ROMAddr  = pXGIHWDE->pjVirtualRomBase ;
+
+
+    pVBInfo->IF_DEF_LVDS = 0 ;
+    pVBInfo->IF_DEF_CH7005 = 0 ;
+    pVBInfo->IF_DEF_HiVision = 1 ;
+    pVBInfo->IF_DEF_LCDA = 1 ;
+    pVBInfo->IF_DEF_CH7017 = 0 ;
+    pVBInfo->IF_DEF_YPbPr = 1 ;
+    pVBInfo->IF_DEF_CRT2Monitor = 0 ;
+    pVBInfo->IF_DEF_VideoCapture = 0 ;
+    pVBInfo->IF_DEF_ScaleLCD = 0 ;
+    pVBInfo->IF_DEF_OEMUtil = 0 ;
+    pVBInfo->IF_DEF_PWD = 0 ;
+
+    InitTo330Pointer( pXGIHWDE->jChipType,  pVBInfo ) ;
+    ReadVBIOSTablData( pXGIHWDE->jChipType , pVBInfo) ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    if ( pXGIHWDE->jChipType == XG27 )
+    {
+        if ( ( XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) & 0xE0 ) == 0xC0 )
+        {
+          if ( XGINew_GetReg1( pVBInfo->P3d4 , 0x30 ) & 0x20 )
+          {
+            pVBInfo->IF_DEF_LVDS = 1 ;
+          }
+        }
+    }
+
+    if ( pVBInfo->IF_DEF_CH7007 == 0 )
+    {
+        XGINew_SetModeScratch ( pXGIHWDE , pVBInfo ) ;
+    }
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x05 , 0x86 ) ;	/* 1.Openkey */
+    XGI_UnLockCRT2( pXGIHWDE , pVBInfo) ;
+    ModeNo = XGINew_GetReg1( pVBInfo->P3d4 , 0x34 ) ;
+    XGI_SearchModeID( ModeNo , &ModeIdIndex, pVBInfo ) ;
+    XGI_GetVGAType( pXGIHWDE , pVBInfo ) ;
+
+    if ( ( pXGIHWDE->ujVBChipID == VB_CHIP_301 ) || ( pXGIHWDE->ujVBChipID == VB_CHIP_302 ) || ( pVBInfo->IF_DEF_CH7007 == 1 ))
+    {
+        XGI_GetVBType( pVBInfo ) ;
+        XGI_GetVBInfo( ModeNo , ModeIdIndex , pXGIHWDE, pVBInfo ) ;
+        XGI_GetTVInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+        XGI_GetLCDInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    }
+
+    if ( VESA_POWER_STATE == 0x00000400 )
+      XGINew_SetReg1( pVBInfo->Part4Port , 0x31 , ( UCHAR )( XGINew_GetReg1( pVBInfo->Part4Port , 0x31 ) & 0xFE ) ) ;
+    else
+      XGINew_SetReg1( pVBInfo->Part4Port , 0x31 , ( UCHAR )( XGINew_GetReg1( pVBInfo->Part4Port , 0x31 ) | 0x01 ) ) ;
+
+    temp = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x1f ) ;
+    temp &= 0x3f ;
+    switch ( VESA_POWER_STATE )
+    {
+        case 0x00000000: /* on */
+            if ( ( pXGIHWDE->ujVBChipID == VB_CHIP_301 ) || ( pXGIHWDE->ujVBChipID == VB_CHIP_302 ) )
+            {
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x1f , ( UCHAR )( temp | 0x00 ) ) ;
+                XGI_EnableBridge( pXGIHWDE, pVBInfo ) ;
+            }
+            else
+            {
+               if ( pXGIHWDE->jChipType == XG21 )
+               {
+                 if ( pVBInfo->IF_DEF_LVDS == 1 )
+                 {
+                   XGI_XG21BLSignalVDD( 0x01 , 0x01, pVBInfo ) ; /* LVDS VDD on */
+                   XGI_XG21SetPanelDelay( 2,pVBInfo ) ;
+                 }
+               }
+               if ( pXGIHWDE->jChipType == XG27 )
+               {
+                 if ( pVBInfo->IF_DEF_LVDS == 1 )
+                 {
+                   XGI_XG27BLSignalVDD( 0x01 , 0x01, pVBInfo ) ; /* LVDS VDD on */
+                   XGI_XG21SetPanelDelay( 2,pVBInfo ) ;
+                 }
+               }
+               XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x1F , ~0xC0 , 0x00 ) ;
+               XGINew_SetRegAND( pVBInfo->P3c4 , 0x01 , ~0x20 ) ;		/* CRT on */
+
+               if ( pXGIHWDE->jChipType == XG21 )
+               {
+                 temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+                 if ( temp & 0xE0 )
+                 {
+                   XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x09 , ~0x80 , 0x80 ) ;	/* DVO ON */
+                   XGI_SetXG21FPBits( pVBInfo );
+                   XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x20 ) ; 		/* Enable write GPIOF */
+                   /*XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x48 , ~0x20 , 0x20 ) ;*/ 	/* LCD Display ON */
+                 }
+                 XGI_XG21BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* LVDS signal on */
+                 XGI_DisplayOn( pXGIHWDE, pVBInfo );
+               }
+               if ( pXGIHWDE->jChipType == XG27 )
+               {
+                 temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+                 if ( temp & 0xE0 )
+                 {
+                   XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x09 , ~0x80 , 0x80 ) ;	/* DVO ON */
+                   XGI_SetXG27FPBits( pVBInfo );
+                   XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x20 ) ; 		/* Enable write GPIOF */
+                   /*XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x48 , ~0x20 , 0x20 ) ;*/ 	/* LCD Display ON */
+                 }
+                 XGI_XG27BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* LVDS signal on */
+                 XGI_DisplayOn( pXGIHWDE, pVBInfo );
+               }
+            }
+            break ;
+        case 0x00000100: /* standby */
+            if ( pXGIHWDE->jChipType >= XG21 )
+            {
+                XGI_DisplayOff( pXGIHWDE, pVBInfo );
+            }
+
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x1f , ( UCHAR )( temp | 0x40 ) ) ;
+            break ;
+        case 0x00000200: /* suspend */
+            if ( pXGIHWDE->jChipType == XG21 )
+            {
+                XGI_DisplayOff( pXGIHWDE, pVBInfo );
+                XGI_XG21BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* LVDS signal off */
+            }
+            if ( pXGIHWDE->jChipType == XG27 )
+            {
+                XGI_DisplayOff( pXGIHWDE, pVBInfo );
+                XGI_XG27BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* LVDS signal off */
+            }
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x1f , ( UCHAR )( temp | 0x80 ) ) ;
+            break ;
+        case 0x00000400: /* off */
+            if ( (pXGIHWDE->ujVBChipID == VB_CHIP_301 ) || ( pXGIHWDE->ujVBChipID == VB_CHIP_302 ) )
+            {
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x1f , ( UCHAR )( temp | 0xc0 ) ) ;
+                XGI_DisableBridge( pXGIHWDE, pVBInfo ) ;
+            }
+            else
+            {
+               if ( pXGIHWDE->jChipType == XG21 )
+               {
+                 XGI_DisplayOff( pXGIHWDE, pVBInfo );
+
+                 XGI_XG21BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* LVDS signal off */
+
+                 temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+                 if ( temp & 0xE0 )
+                 {
+                   XGINew_SetRegAND( pVBInfo->P3c4 , 0x09 , ~0x80 ) ;		/* DVO Off */
+                   XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x20 ) ; 		/* Enable write GPIOF */
+                   /*XGINew_SetRegAND( pVBInfo->P3d4 , 0x48 , ~0x20 ) ;*/ 		/* LCD Display OFF */
+                 }
+               }
+               if ( pXGIHWDE->jChipType == XG27 )
+               {
+                 XGI_DisplayOff( pXGIHWDE, pVBInfo );
+
+                 XGI_XG27BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* LVDS signal off */
+
+                 temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+                 if ( temp & 0xE0 )
+                 {
+                   XGINew_SetRegAND( pVBInfo->P3c4 , 0x09 , ~0x80 ) ;		/* DVO Off */
+                 }
+               }
+               XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x1F , ~0xC0 , 0xC0 ) ;
+               XGINew_SetRegOR( pVBInfo->P3c4 , 0x01 , 0x20 ) ;		/* CRT Off */
+
+               if ( ( pXGIHWDE->jChipType == XG21 ) && ( pVBInfo->IF_DEF_LVDS == 1 ) )
+               {
+                 XGI_XG21SetPanelDelay( 4,pVBInfo ) ;
+                 XGI_XG21BLSignalVDD( 0x01 , 0x00, pVBInfo ) ; /* LVDS VDD off */
+                 XGI_XG21SetPanelDelay( 5,pVBInfo ) ;
+               }
+               if ( ( pXGIHWDE->jChipType == XG27 ) && ( pVBInfo->IF_DEF_LVDS == 1 ) )
+               {
+                 XGI_XG21SetPanelDelay( 4,pVBInfo ) ;
+                 XGI_XG27BLSignalVDD( 0x01 , 0x00, pVBInfo ) ; /* LVDS VDD off */
+                 XGI_XG21SetPanelDelay( 5,pVBInfo ) ;
+               }
+            }
+            break ;
+
+        default:
+            break ;
+    }
+    XGI_LockCRT2( pXGIHWDE , pVBInfo ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetSenseStatus */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetSenseStatus( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax = 0 , tempbx , tempcx , temp ,
+           P2reg0 = 0 , SenseModeNo = 0 , OutputSelect = *pVBInfo->pOutputSelect ,
+           ModeIdIndex , i ;
+    pVBInfo->BaseAddr = (ULONG)HwDeviceExtension->pjIOAddress ;
+
+    if ( pVBInfo->IF_DEF_LVDS == 1 )
+    {
+        tempax = XGINew_GetReg1( pVBInfo->P3c4 , 0x1A ) ;	/* ynlai 02/27/2002 */
+        tempbx = XGINew_GetReg1( pVBInfo->P3c4 , 0x1B ) ;
+        tempax = ( ( tempax & 0xFE ) >> 1 ) | ( tempbx << 8 ) ;
+        if ( tempax == 0x00 )
+        {		/* Get Panel id from DDC */
+            temp = XGINew_GetLCDDDCInfo( HwDeviceExtension, pVBInfo ) ;
+            if ( temp == 1 )
+            {		/* LCD connect */
+                XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x39 , 0xFF , 0x01 ) ;	/* set CR39 bit0="1" */
+                XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x37 , 0xEF , 0x00 ) ;	/* clean CR37 bit4="0" */
+                temp = LCDSense ;
+            }
+            else
+            {		/* LCD don't connect */
+                temp = 0 ;
+            }
+        }
+        else
+        {
+            XGINew_GetPanelID(pVBInfo) ;
+            temp = LCDSense ;
+        }
+
+        tempbx = ~( LCDSense | AVIDEOSense | SVIDEOSense ) ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , tempbx , temp ) ;
+    }
+    else
+    {		/* for 301 */
+        if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        {	/* for HiVision */
+            tempax = XGINew_GetReg1( pVBInfo->P3c4 , 0x38 ) ;
+            temp = tempax & 0x01 ;
+            tempax = XGINew_GetReg1( pVBInfo->P3c4 , 0x3A ) ;
+            temp = temp | ( tempax & 0x02 ) ;
+            XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , 0xA0 , temp ) ;
+        }
+        else
+        {
+            if ( XGI_BridgeIsOn( pVBInfo ) )
+            {
+                P2reg0 = XGINew_GetReg1( pVBInfo->Part2Port , 0x00 ) ;
+                if ( !XGINew_BridgeIsEnable( HwDeviceExtension, pVBInfo ) )
+                {
+                    SenseModeNo = 0x2e ;
+                    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x30 , 0x41 ) ; */
+                    /* XGISetModeNew( HwDeviceExtension , 0x2e ) ; // ynlai InitMode */
+
+                    temp = XGI_SearchModeID( SenseModeNo , &ModeIdIndex, pVBInfo ) ;
+                    XGI_GetVGAType( HwDeviceExtension , pVBInfo) ;
+                    XGI_GetVBType( pVBInfo ) ;
+                    pVBInfo->SetFlag = 0x00 ;
+                    pVBInfo->ModeType = ModeVGA ;
+                    pVBInfo->VBInfo = SetCRT2ToRAMDAC | LoadDACFlag | SetInSlaveMode ;
+                    XGI_GetLCDInfo( 0x2e , ModeIdIndex, pVBInfo ) ;
+                    XGI_GetTVInfo(  0x2e , ModeIdIndex, pVBInfo ) ;
+                    XGI_EnableBridge( HwDeviceExtension, pVBInfo ) ;
+                    XGI_SetCRT2Group301( SenseModeNo , HwDeviceExtension, pVBInfo ) ;
+                    XGI_SetCRT2ModeRegs( 0x2e , HwDeviceExtension, pVBInfo ) ;
+                    /* XGI_DisableBridge( HwDeviceExtension, pVBInfo ) ; */
+                    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x01 , 0xDF , 0x20 ) ;	/* Display Off 0212 */
+                    for( i = 0 ; i < 20 ; i++ )
+                    {
+                        XGI_LongWait(pVBInfo) ;
+                    }
+                }
+                XGINew_SetReg1( pVBInfo->Part2Port , 0x00 , 0x1c ) ;
+                tempax = 0 ;
+                tempbx = *pVBInfo->pRGBSenseData ;
+
+                if ( !( XGINew_Is301B( pVBInfo ) ) )
+                {
+                    tempbx = *pVBInfo->pRGBSenseData2 ;
+                }
+
+                tempcx = 0x0E08 ;
+                if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                {
+                    if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                    {
+                        tempax |= Monitor2Sense ;
+                    }
+                }
+
+                if ( pVBInfo->VBType & VB_XGI301C)
+                {
+                    XGINew_SetRegOR( pVBInfo->Part4Port , 0x0d , 0x04 ) ;
+                }
+
+		if ( XGINew_SenseHiTV( HwDeviceExtension , pVBInfo) )		/* add by kuku for Multi-adapter sense HiTV */
+		{
+		    tempax |= HiTVSense ;
+                    if ( ( pVBInfo->VBType & VB_XGI301C ) )
+                    {
+                	tempax ^= ( HiTVSense | YPbPrSense ) ;
+                    }
+                }
+
+		if ( !( tempax & ( HiTVSense | YPbPrSense ) ) )		/* start */
+                {
+
+                    tempbx = *pVBInfo->pYCSenseData ;
+
+                    if ( !( XGINew_Is301B(  pVBInfo ) ) )
+                    {
+                      tempbx=*pVBInfo->pYCSenseData2;
+                    }
+
+                    tempcx = 0x0604 ;
+                    if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                    {
+                      if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                      {
+                          tempax |= SVIDEOSense ;
+                      }
+                    }
+
+                    if ( OutputSelect & BoardTVType )
+                    {
+                      tempbx = *pVBInfo->pVideoSenseData ;
+
+                      if ( !( XGINew_Is301B( pVBInfo ) ) )
+                      {
+                          tempbx = *pVBInfo->pVideoSenseData2 ;
+                      }
+
+                      tempcx = 0x0804 ;
+                      if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                      {
+                          if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                          {
+                              tempax |= AVIDEOSense ;
+                          }
+                      }
+                    }
+                    else
+                    {
+                      if ( !( tempax & SVIDEOSense ) )
+                      {
+                        tempbx = *pVBInfo->pVideoSenseData ;
+
+                        if ( !( XGINew_Is301B( pVBInfo ) ) )
+                        {
+                            tempbx=*pVBInfo->pVideoSenseData2;
+                        }
+
+                        tempcx = 0x0804 ;
+                        if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                        {
+                            if ( XGINew_Sense(tempbx , tempcx, pVBInfo ) )
+                            {
+                                tempax |= AVIDEOSense ;
+                            }
+                        }
+                      }
+                    }
+                }
+    	    } /* end */
+            if ( !( tempax & Monitor2Sense ) )
+            {
+                if ( XGINew_SenseLCD( HwDeviceExtension, pVBInfo ) )
+                {
+                    tempax |= LCDSense ;
+                }
+            }
+            tempbx = 0 ;
+            tempcx = 0 ;
+            XGINew_Sense(tempbx , tempcx, pVBInfo ) ;
+
+            XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , ~0xDF , tempax ) ;
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x00 , P2reg0 ) ;
+
+            if ( !( P2reg0 & 0x20 ) )
+            {
+                pVBInfo->VBInfo = DisableCRT2Display ;
+                /* XGI_SetCRT2Group301( SenseModeNo , HwDeviceExtension, pVBInfo ) ; */
+            }
+        }
+    }
+    XGI_DisableBridge( HwDeviceExtension, pVBInfo ) ;		/* shampoo 0226 */
+
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SenseLCD */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGINew_SenseLCD( PXGI_HW_DEVICE_INFO HwDeviceExtension ,PVB_DEVICE_INFO pVBInfo)
+{
+    /* USHORT SoftSetting ; */
+    USHORT temp ;
+
+    if ( ( HwDeviceExtension->jChipType >= XG20 ) || ( HwDeviceExtension->jChipType >= XG40 ) )
+        temp = 0 ;
+    else
+        temp=XGINew_GetPanelID(pVBInfo) ;
+
+    if( !temp )
+        temp = XGINew_GetLCDDDCInfo( HwDeviceExtension, pVBInfo ) ;
+
+    return( temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_GetLCDDDCInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_GetLCDDDCInfo( PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT temp ;
+
+    /* add lcd sense */
+    if ( HwDeviceExtension->ulCRT2LCDType == LCD_UNKNOWN )
+    {
+        return( 0 ) ;
+    }
+    else
+    {
+        temp = ( USHORT )HwDeviceExtension->ulCRT2LCDType ;
+        switch( HwDeviceExtension->ulCRT2LCDType )
+        {
+            case LCD_INVALID:
+            case LCD_800x600:
+            case LCD_1024x768:
+            case LCD_1280x1024:
+                break ;
+
+            case LCD_640x480:
+            case LCD_1024x600:
+            case LCD_1152x864:
+            case LCD_1280x960:
+            case LCD_1152x768:
+                temp = 0 ;
+                break ;
+
+            case LCD_1400x1050:
+            case LCD_1280x768:
+            case LCD_1600x1200:
+                break ;
+
+            case LCD_1920x1440:
+            case LCD_2048x1536:
+                temp = 0 ;
+                break ;
+
+            default:
+                break ;
+        }
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x36 , 0xF0 , temp ) ;
+        return( 1 ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_GetPanelID(PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT PanelTypeTable[ 16 ] = { SyncNN | PanelRGB18Bit | Panel800x600  | _PanelType00 ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType01 ,
+                                    SyncNN | PanelRGB18Bit | Panel800x600  | _PanelType02 ,
+                                    SyncNN | PanelRGB18Bit | Panel640x480  | _PanelType03 ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType04 ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType05 ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType06 ,
+                                    SyncNN | PanelRGB24Bit | Panel1024x768 | _PanelType07 ,
+                                    SyncNN | PanelRGB18Bit | Panel800x600  | _PanelType08 ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType09 ,
+                                    SyncNN | PanelRGB18Bit | Panel800x600  | _PanelType0A ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType0B ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType0C ,
+                                    SyncNN | PanelRGB24Bit | Panel1024x768 | _PanelType0D ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType0E ,
+                                    SyncNN | PanelRGB18Bit | Panel1024x768 | _PanelType0F } ;
+    USHORT tempax , tempbx , temp ;
+    /* USHORT return_flag ; */
+
+    tempax = XGINew_GetReg1( pVBInfo->P3c4 , 0x1A ) ;
+    tempbx = tempax & 0x1E ;
+
+    if ( tempax == 0 )
+        return( 0 ) ;
+    else
+    {
+/*
+        if ( !( tempax & 0x10 ) )
+        {
+            if ( pVBInfo->IF_DEF_LVDS == 1 )
+            {
+                tempbx = 0 ;
+                temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x38 ) ;
+                if ( temp & 0x40 )
+                    tempbx |= 0x08 ;
+                if ( temp & 0x20 )
+                    tempbx |= 0x02 ;
+                if ( temp & 0x01 )
+                    tempbx |= 0x01 ;
+
+                temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x39 ) ;
+                if ( temp & 0x80 )
+                    tempbx |= 0x04 ;
+            }
+            else
+            {
+                return( 0 ) ;
+            }
+        }
+*/
+
+        tempbx = tempbx >> 1 ;
+        temp = tempbx & 0x00F ;
+        XGINew_SetReg1( pVBInfo->P3d4 , 0x36 , temp ) ;
+        tempbx-- ;
+        tempbx = PanelTypeTable[ tempbx ] ;
+
+        temp = ( tempbx & 0xFF00 ) >> 8 ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x37 , ~( LCDSyncBit | LCDRGB18Bit ) , temp ) ;
+        return( 1 ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_BridgeIsEnable */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_BridgeIsEnable( PXGI_HW_DEVICE_INFO HwDeviceExtension ,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT flag ;
+
+    if ( XGI_BridgeIsOn( pVBInfo ) == 0 )
+    {
+        flag = XGINew_GetReg1( pVBInfo->Part1Port , 0x0 ) ;
+
+        if ( flag & 0x050 )
+        {
+            return( 1 ) ;
+        }
+        else
+        {
+            return( 0 ) ;
+        }
+
+    }
+    return( 0 ) ;
+}
+
+/* ------------------------------------------------------ */
+/* Function : XGINew_SenseHiTV */
+/* Input : */
+/* Output : */
+/* Description : */
+/* ------------------------------------------------------ */
+BOOLEAN XGINew_SenseHiTV( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx , tempcx , temp , i , tempch;
+
+    tempbx = *pVBInfo->pYCSenseData2 ;
+
+    tempcx = 0x0604 ;
+
+    temp = tempbx & 0xFF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x11 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp |= ( tempcx & 0x00FF ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x10 , ~0x1F , temp ) ;
+
+    for( i = 0 ; i < 10 ; i++ )
+        XGI_LongWait(pVBInfo) ;
+
+    tempch = ( tempcx & 0xFF00 ) >> 8;
+    temp = XGINew_GetReg1( pVBInfo->Part4Port , 0x03 ) ;
+    temp = temp ^ ( 0x0E ) ;
+    temp &= tempch ;
+
+    if ( temp !=  tempch )
+        return( 0 ) ;
+
+    tempbx = *pVBInfo->pVideoSenseData2 ;
+
+    tempcx = 0x0804 ;
+    temp = tempbx & 0xFF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x11 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp |= ( tempcx & 0x00FF ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x10 , ~0x1F , temp ) ;
+
+    for( i = 0 ; i < 10 ; i++ )
+        XGI_LongWait(pVBInfo) ;
+
+    tempch = ( tempcx & 0xFF00 ) >> 8;
+    temp = XGINew_GetReg1( pVBInfo->Part4Port , 0x03 ) ;
+    temp = temp ^ ( 0x0E ) ;
+    temp &= tempch ;
+
+    if ( temp !=  tempch )
+        return( 0 ) ;
+    else
+    {
+      tempbx = 0x3FF ;
+      tempcx = 0x0804 ;
+      temp = tempbx & 0xFF ;
+      XGINew_SetReg1( pVBInfo->Part4Port , 0x11 , temp ) ;
+      temp = ( tempbx & 0xFF00 ) >> 8 ;
+      temp |= ( tempcx & 0x00FF ) ;
+      XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x10 , ~0x1F , temp ) ;
+
+      for( i = 0 ; i < 10 ; i++ )
+          XGI_LongWait(pVBInfo) ;
+
+      tempch = ( tempcx & 0xFF00 ) >> 8;
+      temp = XGINew_GetReg1( pVBInfo->Part4Port , 0x03 ) ;
+      temp = temp ^ ( 0x0E ) ;
+      temp &= tempch ;
+
+      if ( temp != tempch )
+          return( 1 ) ;
+      else
+	  return( 0 ) ;
+    }
+}
+
+
+
+/*
+;-----------------------------------------------------------------------------
+;       Description: Get Panel support
+;	O/P	   :
+;            BL: Panel ID=81h for no scaler LVDS
+;		     BH: Panel enhanced Mode Count
+;		     CX: Panel H. resolution
+;		     DX: PAnel V. resolution
+;-----------------------------------------------------------------------------
+*/
+void XGI_XG21Fun14Sub70( PVB_DEVICE_INFO pVBInfo , PX86_REGS pBiosArguments )
+{
+
+    USHORT ModeIdIndex;
+    USHORT ModeNo;
+
+    USHORT EModeCount;
+    USHORT lvdstableindex;
+
+    lvdstableindex = XGI_GetLVDSOEMTableIndex( pVBInfo );
+    pBiosArguments->h.bl = 0x81;
+    pBiosArguments->x.cx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE;
+    pBiosArguments->x.dx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE;
+    EModeCount = 0;
+
+    pBiosArguments->x.ax = 0x0014;
+    for( ModeIdIndex = 0 ; ;  ModeIdIndex ++ )
+    {
+        ModeNo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeID;
+        if ( pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeID == 0xFF )
+        {
+            pBiosArguments->h.bh = (UCHAR) EModeCount;
+            return;
+        }
+        if ( !XGI_XG21CheckLVDSMode( ModeNo , ModeIdIndex, pVBInfo) )
+        {
+          continue;
+        }
+        EModeCount++ ;
+    }
+}
+/*(
+;-----------------------------------------------------------------------------
+;
+;       Description: Get Panel mode ID for enhanced mode
+;	I/P	   : BH: EModeIndex ( which < Panel enhanced Mode Count )
+;	O/P	   :
+;            BL: Mode ID
+;		     CX: H. resolution of the assigned by the index
+;		     DX: V. resolution of the assigned by the index
+;
+;-----------------------------------------------------------------------------
+*/
+void XGI_XG21Fun14Sub71( PVB_DEVICE_INFO pVBInfo , PX86_REGS pBiosArguments )
+{
+
+    USHORT EModeCount;
+    USHORT ModeIdIndex,resindex;
+    USHORT ModeNo;
+    USHORT EModeIndex = pBiosArguments->h.bh;
+
+    EModeCount = 0;
+    for( ModeIdIndex = 0 ; ;  ModeIdIndex ++ )
+    {
+        ModeNo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeID;
+        if ( pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeID == 0xFF )
+        {
+            pBiosArguments->x.ax = 0x0114;
+            return;
+        }
+        if ( !XGI_XG21CheckLVDSMode( ModeNo , ModeIdIndex, pVBInfo) )
+        {
+          continue;
+        }
+        if (EModeCount == EModeIndex)
+        {
+            resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+            pBiosArguments->h.bl = (UCHAR) ModeNo;
+            pBiosArguments->x.cx = pVBInfo->ModeResInfo[ resindex ].HTotal ;			  /* xres->ax */
+            pBiosArguments->x.dx = pVBInfo->ModeResInfo[ resindex ].VTotal ;			  /* yres->bx */
+            pBiosArguments->x.ax = 0x0014;
+        }
+        EModeCount++ ;
+
+    }
+
+}
+/*
+;-----------------------------------------------------------------------------
+;
+;       Description: Validate Panel modes ID support
+;	I/P	   :
+;            BL: ModeID
+;	O/P	   :
+;		     CX: H. resolution of the assigned by the index
+;		     DX: V. resolution of the assigned by the index
+;
+;-----------------------------------------------------------------------------
+*/
+void XGI_XG21Fun14Sub72( PVB_DEVICE_INFO pVBInfo , PX86_REGS pBiosArguments )
+{
+    USHORT ModeIdIndex,resindex;
+    USHORT ModeNo;
+
+
+    ModeNo = pBiosArguments->h.bl ;
+    XGI_SearchModeID( ModeNo, &ModeIdIndex, pVBInfo);
+    if ( !XGI_XG21CheckLVDSMode( ModeNo , ModeIdIndex, pVBInfo) )
+    {
+        pBiosArguments->x.cx = 0;
+        pBiosArguments->x.dx = 0;
+        pBiosArguments->x.ax = 0x0114;
+        return;
+    }
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( ModeNo <= 0x13 )
+    {
+        pBiosArguments->x.cx = pVBInfo->StResInfo[ resindex ].HTotal ;
+        pBiosArguments->x.dx = pVBInfo->StResInfo[ resindex ].VTotal ;
+    }
+    else
+    {
+        pBiosArguments->x.cx = pVBInfo->ModeResInfo[ resindex ].HTotal ;			  /* xres->ax */
+        pBiosArguments->x.dx = pVBInfo->ModeResInfo[ resindex ].VTotal ;			  /* yres->bx */
+    }
+
+    pBiosArguments->x.ax = 0x0014;
+
+}
+
+/*
+;-----------------------------------------------------------------------------
+;	Description: Get Customized Panel misc. information support
+;	I/P	   : Select
+;		     to get panel horizontal timing
+;			 to get panel vertical timing
+;			 to get channel clock parameter
+;            to get panel misc information
+;
+;	O/P	   :
+;		     BL: for input Select = 0 ;
+;                       BX: *Value1 = Horizontal total
+;                       CX: *Value2 = Horizontal front porch
+;                       DX: *Value2 = Horizontal sync width
+;		     BL: for input Select = 1 ;
+;                       BX: *Value1 = Vertical total
+;                       CX: *Value2 = Vertical front porch
+;                       DX: *Value2 = Vertical sync width
+;            BL: for input Select = 2 ;
+;                       BX: Value1 = The first CLK parameter
+;                       CX: Value2 = The second CLK parameter
+;		     BL: for input Select = 4 ;
+;                       BX[15]: *Value1 D[15] VESA V. Polarity
+;                       BX[14]: *Value1 D[14] VESA H. Polarity
+;                       BX[7]: *Value1 D[7] Panel V. Polarity
+;                       BX[6]: *Value1 D[6] Panel H. Polarity
+;-----------------------------------------------------------------------------
+*/
+void XGI_XG21Fun14Sub73( PVB_DEVICE_INFO pVBInfo , PX86_REGS pBiosArguments )
+{
+    UCHAR Select;
+
+    USHORT lvdstableindex;
+
+    lvdstableindex = XGI_GetLVDSOEMTableIndex( pVBInfo );
+    Select = pBiosArguments->h.bl;
+
+    switch (Select)
+    {
+        case 0:
+                pBiosArguments->x.bx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHT;
+                pBiosArguments->x.cx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHFP;
+                pBiosArguments->x.dx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHSYNC;
+                break;
+        case 1:
+                pBiosArguments->x.bx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVT;
+                pBiosArguments->x.cx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVFP;
+                pBiosArguments->x.dx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVSYNC;
+                break;
+        case 2:
+                pBiosArguments->x.bx = pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData1;
+                pBiosArguments->x.cx = pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData2;
+                break;
+        case 4:
+                pBiosArguments->x.bx = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDS_Capability;
+                break;
+    }
+
+    pBiosArguments->x.ax = 0x0014;
+}
+
+
+void XGI_XG21Fun14( PXGI_HW_DEVICE_INFO pXGIHWDE, PX86_REGS pBiosArguments)
+{
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+
+    pVBInfo->IF_DEF_LVDS = 0 ;
+    pVBInfo->IF_DEF_CH7005 = 0 ;
+    pVBInfo->IF_DEF_HiVision = 1 ;
+    pVBInfo->IF_DEF_LCDA = 1 ;
+    pVBInfo->IF_DEF_CH7017 = 0 ;
+    pVBInfo->IF_DEF_YPbPr = 1 ;
+    pVBInfo->IF_DEF_CRT2Monitor = 0 ;
+    pVBInfo->IF_DEF_VideoCapture = 0 ;
+    pVBInfo->IF_DEF_ScaleLCD = 0 ;
+    pVBInfo->IF_DEF_OEMUtil = 0 ;
+    pVBInfo->IF_DEF_PWD = 0 ;
+
+    InitTo330Pointer( pXGIHWDE->jChipType,  pVBInfo ) ;
+    ReadVBIOSTablData( pXGIHWDE->jChipType , pVBInfo) ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    switch(pBiosArguments->x.ax)
+    {
+    case 0x1470:
+         XGI_XG21Fun14Sub70( pVBInfo , pBiosArguments ) ;
+         break;
+    case 0x1471:
+         XGI_XG21Fun14Sub71( pVBInfo , pBiosArguments ) ;
+         break;
+    case 0x1472:
+         XGI_XG21Fun14Sub72( pVBInfo , pBiosArguments ) ;
+         break;
+    case 0x1473:
+         XGI_XG21Fun14Sub73( pVBInfo , pBiosArguments ) ;
+         break;
+    }
+}
--- /dev/null
+++ b/drivers/staging/xgifb/vb_ext.h
@@ -0,0 +1,32 @@
+#ifndef  _VBEXT_
+#define  _VBEXT_
+
+struct DWORDREGS {
+    ULONG    Eax, Ebx, Ecx, Edx, Esi, Edi, Ebp;
+};
+
+struct WORDREGS {
+    USHORT    ax, hi_ax, bx, hi_bx, cx, hi_cx, dx, hi_dx, si, hi_si, di ,hi_di, bp, hi_bp;
+};
+
+struct BYTEREGS {
+    UCHAR   al, ah, hi_al, hi_ah, bl, bh, hi_bl, hi_bh, cl, ch, hi_cl, hi_ch, dl, dh, hi_dl, hi_dh;
+};
+
+typedef union   _X86_REGS    {
+    struct  DWORDREGS e;
+    struct  WORDREGS x;
+    struct  BYTEREGS h;
+} X86_REGS, *PX86_REGS;
+
+extern   void     XGI_XG21Fun14( PXGI_HW_DEVICE_INFO pXGIHWDE, PX86_REGS pBiosArguments);
+extern   void     XGISetDPMS( PXGI_HW_DEVICE_INFO pXGIHWDE , ULONG VESA_POWER_STATE ) ;
+extern   void     XGI_GetSenseStatus( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo );
+extern   void     XGINew_SetModeScratch ( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo ) ;
+extern   void 	  ReadVBIOSTablData( UCHAR ChipType , PVB_DEVICE_INFO pVBInfo);
+extern   USHORT   XGINew_SenseLCD(PXGI_HW_DEVICE_INFO,PVB_DEVICE_INFO pVBInfo);
+#ifdef WIN2000
+extern   BOOLEAN  XGI_DySense( PHW_DEVICE_EXTENSION pHWDE , PUCHAR ujConnectStatus );
+#endif /* WIN2000 */
+
+#endif
--- /dev/null
+++ b/drivers/staging/xgifb/vb_init.c
@@ -0,0 +1,3444 @@
+#include "osdef.h"
+#include "vgatypes.h"
+
+
+#ifdef LINUX_KERNEL
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/delay.h> /* udelay */
+#include "XGIfb.h"
+/*#if LINUX_VERSxION_CODE >= KERNEL_VERSION(2,5,0)
+#include <video/XGIfb.h>
+#else
+#include <linux/XGIfb.h>
+#endif */
+#endif
+
+#ifdef WIN2000
+#include <dderror.h>
+#include <devioctl.h>
+#include <miniport.h>
+#include <ntddvdeo.h>
+#include <video.h>
+#include "xgiv.h"
+#include "dd_i2c.h"
+#include "tools.h"
+#endif
+
+#include "vb_def.h"
+#include "vb_struct.h"
+#include "vb_util.h"
+#include "vb_setmode.h"
+#include "vb_init.h"
+#include "vb_ext.h"
+
+#ifdef LINUX_XF86
+#include "xf86.h"
+#include "xf86PciInfo.h"
+#include "xgi.h"
+#include "xgi_regs.h"
+#endif
+
+#ifdef LINUX_KERNEL
+#include <asm/io.h>
+#include <linux/types.h>
+#endif
+
+
+
+
+UCHAR    XGINew_ChannelAB,XGINew_DataBusWidth;
+
+USHORT XGINew_DRAMType[17][5]={{0x0C,0x0A,0x02,0x40,0x39},{0x0D,0x0A,0x01,0x40,0x48},
+                     {0x0C,0x09,0x02,0x20,0x35},{0x0D,0x09,0x01,0x20,0x44},
+                     {0x0C,0x08,0x02,0x10,0x31},{0x0D,0x08,0x01,0x10,0x40},
+                     {0x0C,0x0A,0x01,0x20,0x34},{0x0C,0x09,0x01,0x08,0x32},
+                     {0x0B,0x08,0x02,0x08,0x21},{0x0C,0x08,0x01,0x08,0x30},
+                     {0x0A,0x08,0x02,0x04,0x11},{0x0B,0x0A,0x01,0x10,0x28},
+                     {0x09,0x08,0x02,0x02,0x01},{0x0B,0x09,0x01,0x08,0x24},
+                     {0x0B,0x08,0x01,0x04,0x20},{0x0A,0x08,0x01,0x02,0x10},
+                     {0x09,0x08,0x01,0x01,0x00}};
+
+USHORT XGINew_SDRDRAM_TYPE[13][5]=
+{
+{ 2,12, 9,64,0x35},
+{ 1,13, 9,64,0x44},
+{ 2,12, 8,32,0x31},
+{ 2,11, 9,32,0x25},
+{ 1,12, 9,32,0x34},
+{ 1,13, 8,32,0x40},
+{ 2,11, 8,16,0x21},
+{ 1,12, 8,16,0x30},
+{ 1,11, 9,16,0x24},
+{ 1,11, 8, 8,0x20},
+{ 2, 9, 8, 4,0x01},
+{ 1,10, 8, 4,0x10},
+{ 1, 9, 8, 2,0x00}
+};
+
+USHORT XGINew_DDRDRAM_TYPE[4][5]=
+{
+{ 2,12, 9,64,0x35},
+{ 2,12, 8,32,0x31},
+{ 2,11, 8,16,0x21},
+{ 2, 9, 8, 4,0x01}
+};
+USHORT XGINew_DDRDRAM_TYPE340[4][5]=
+{
+{ 2,13, 9,64,0x45},
+{ 2,12, 9,32,0x35},
+{ 2,12, 8,16,0x31},
+{ 2,11, 8, 8,0x21}
+};
+USHORT XGINew_DDRDRAM_TYPE20[12][5]=
+{
+{ 2,14,11,128,0x5D},
+{ 2,14,10,64,0x59},
+{ 2,13,11,64,0x4D},
+{ 2,14, 9,32,0x55},
+{ 2,13,10,32,0x49},
+{ 2,12,11,32,0x3D},
+{ 2,14, 8,16,0x51},
+{ 2,13, 9,16,0x45},
+{ 2,12,10,16,0x39},
+{ 2,13, 8, 8,0x41},
+{ 2,12, 9, 8,0x35},
+{ 2,12, 8, 4,0x31}
+};
+
+void     XGINew_SetDRAMSize_340(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO);
+void     XGINew_SetDRAMSize_310(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO);
+void     XGINew_SetMemoryClock(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+void     XGINew_SetDRAMModeRegister(PVB_DEVICE_INFO );
+void     XGINew_SetDRAMModeRegister340( PXGI_HW_DEVICE_INFO HwDeviceExtension );
+void 	 XGINew_SetDRAMDefaultRegister340(PXGI_HW_DEVICE_INFO HwDeviceExtension, ULONG, PVB_DEVICE_INFO );
+UCHAR    XGINew_GetXG20DRAMType( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGIInitNew( PXGI_HW_DEVICE_INFO HwDeviceExtension) ;
+
+int      XGINew_DDRSizing340( PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO );
+void     XGINew_DisableRefresh( PXGI_HW_DEVICE_INFO ,PVB_DEVICE_INFO) ;
+void     XGINew_CheckBusWidth_310( PVB_DEVICE_INFO) ;
+int      XGINew_SDRSizing(PVB_DEVICE_INFO);
+int      XGINew_DDRSizing( PVB_DEVICE_INFO );
+void     XGINew_EnableRefresh( PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO);
+int      XGINew_RAMType;                  /*int      ModeIDOffset,StandTable,CRT1Table,ScreenOffset,REFIndex;*/
+ULONG	 UNIROM;			  /* UNIROM */
+BOOLEAN  ChkLFB( PVB_DEVICE_INFO );
+void     XGINew_Delay15us(ULONG);
+void     SetPowerConsume (PXGI_HW_DEVICE_INFO HwDeviceExtension,ULONG XGI_P3d4Port);
+void 	 ReadVBIOSTablData( UCHAR ChipType , PVB_DEVICE_INFO pVBInfo);
+void 	 XGINew_DDR1x_MRS_XG20( ULONG P3c4 , PVB_DEVICE_INFO pVBInfo);
+void     XGINew_SetDRAMModeRegister_XG20( PXGI_HW_DEVICE_INFO HwDeviceExtension );
+void     XGINew_SetDRAMModeRegister_XG27( PXGI_HW_DEVICE_INFO HwDeviceExtension );
+void 	 XGINew_ChkSenseStatus ( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo ) ;
+void     XGINew_SetModeScratch ( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo ) ;
+void     XGINew_GetXG21Sense(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo) ;
+UCHAR    GetXG21FPBits(PVB_DEVICE_INFO pVBInfo);
+void     XGINew_GetXG27Sense(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo) ;
+UCHAR    GetXG27FPBits(PVB_DEVICE_INFO pVBInfo);
+
+#ifdef WIN2000
+/* [Billy] 2007/05/20 For CH7007 */
+extern  UCHAR CH7007TVReg_UNTSC[][8],CH7007TVReg_ONTSC[][8],CH7007TVReg_UPAL[][8],CH7007TVReg_OPAL[][8];
+extern  UCHAR XGI7007_CHTVVCLKUNTSC[],XGI7007_CHTVVCLKONTSC[],XGI7007_CHTVVCLKUPAL[],XGI7007_CHTVVCLKOPAL[];
+#endif
+
+#ifdef LINUX_KERNEL
+void DelayUS(ULONG MicroSeconds)
+{
+	udelay(MicroSeconds);
+}
+#endif
+
+/* --------------------------------------------------------------------- */
+/* Function : XGIInitNew */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGIInitNew( PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    UCHAR   i , temp = 0 , temp1 ;
+     //       VBIOSVersion[ 5 ] ;
+    PUCHAR  volatile pVideoMemory;
+
+    /* ULONG j, k ; */
+
+    PXGI_DSReg pSR ;
+
+    ULONG Temp ;
+
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+
+    pVBInfo->BaseAddr = (ULONG)HwDeviceExtension->pjIOAddress ;
+
+    pVideoMemory = ( PUCHAR )pVBInfo->ROMAddr;
+
+
+//    Newdebugcode( 0x99 ) ;
+
+
+   /* if ( pVBInfo->ROMAddr == 0 ) */
+   /* return( FALSE ) ; */
+
+    if ( pVBInfo->FBAddr == 0 )
+{
+       printk("\n pVBInfo->FBAddr == 0 ");
+       return( FALSE ) ;
+}
+printk("1");
+    if ( pVBInfo->BaseAddr == 0 )
+{
+       printk("\npVBInfo->BaseAddr == 0 ");
+        return( FALSE ) ;
+}
+printk("2");
+
+    XGINew_SetReg3( ( pVBInfo->BaseAddr + 0x12 ) , 0x67 ) ;	/* 3c2 <- 67 ,ynlai */
+
+    pVBInfo->ISXPDOS = 0 ;
+printk("3");
+
+if ( !HwDeviceExtension->bIntegratedMMEnabled )
+{
+        return( FALSE ) ;	/* alan */
+}
+printk("4");
+
+//    XGI_MemoryCopy( VBIOSVersion , HwDeviceExtension->szVBIOSVer , 4 ) ;
+
+ //   VBIOSVersion[ 4 ] = 0x0 ;
+
+    /* 09/07/99 modify by domao */
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+printk("5");
+
+    if ( HwDeviceExtension->jChipType < XG20 )			/* kuku 2004/06/25 */
+    XGI_GetVBType( pVBInfo ) ;         /* Run XGI_GetVBType before InitTo330Pointer */
+
+    InitTo330Pointer( HwDeviceExtension->jChipType,  pVBInfo ) ;
+
+    /* ReadVBIOSData */
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+
+    /* 1.Openkey */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x05 , 0x86 ) ;
+printk("6");
+
+    /* GetXG21Sense (GPIO) */
+    if ( HwDeviceExtension->jChipType == XG21 )
+    {
+    	XGINew_GetXG21Sense(HwDeviceExtension, pVBInfo) ;
+    }
+    if ( HwDeviceExtension->jChipType == XG27 )
+    {
+    	XGINew_GetXG27Sense(HwDeviceExtension, pVBInfo) ;
+    }
+printk("7");
+
+    /* 2.Reset Extended register */
+
+    for( i = 0x06 ; i < 0x20 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3c4 , i , 0 ) ;
+
+    for( i = 0x21 ; i <= 0x27 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3c4 , i , 0 ) ;
+
+    /* for( i = 0x06 ; i <= 0x27 ; i++ ) */
+    /* XGINew_SetReg1( pVBInfo->P3c4 , i , 0 ) ; */
+
+printk("8");
+
+    if(( HwDeviceExtension->jChipType >= XG20 ) || ( HwDeviceExtension->jChipType >= XG40))
+    {
+        for( i = 0x31 ; i <= 0x3B ; i++ )
+            XGINew_SetReg1( pVBInfo->P3c4 , i , 0 ) ;
+    }
+    else
+    {
+        for( i = 0x31 ; i <= 0x3D ; i++ )
+            XGINew_SetReg1( pVBInfo->P3c4 , i , 0 ) ;
+    }
+printk("9");
+
+    if ( HwDeviceExtension->jChipType == XG42 )			/* [Hsuan] 2004/08/20 Auto over driver for XG42 */
+      XGINew_SetReg1( pVBInfo->P3c4 , 0x3B , 0xC0 ) ;
+
+    /* for( i = 0x30 ; i <= 0x3F ; i++ ) */
+    /* XGINew_SetReg1( pVBInfo->P3d4 , i , 0 ) ; */
+
+    for( i = 0x79 ; i <= 0x7C ; i++ )
+        XGINew_SetReg1( pVBInfo->P3d4 , i , 0 ) ;		/* shampoo 0208 */
+
+printk("10");
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+        XGINew_SetReg1( pVBInfo->P3d4 , 0x97 , *pVBInfo->pXGINew_CR97 ) ;
+
+    /* 3.SetMemoryClock
+
+    if ( HwDeviceExtension->jChipType >= XG40 )
+        XGINew_RAMType = ( int )XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo) ;
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+        XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;  */
+
+printk("11");
+
+    /* 4.SetDefExt1Regs begin */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x07 , *pVBInfo->pSR07 ) ;
+    if ( HwDeviceExtension->jChipType == XG27 )
+    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x40 , *pVBInfo->pSR40 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x41 , *pVBInfo->pSR41 ) ;
+    }
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x11 , 0x0F ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1F , *pVBInfo->pSR1F ) ;
+    /* XGINew_SetReg1( pVBInfo->P3c4 , 0x20 , 0x20 ) ; */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x20 , 0xA0 ) ;	/* alan, 2001/6/26 Frame buffer can read/write SR20 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x36 , 0x70 ) ;	/* Hsuan, 2006/01/01 H/W request for slow corner chip */
+    if ( HwDeviceExtension->jChipType == XG27 )         /* Alan 12/07/2006 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x36 , *pVBInfo->pSR36 ) ;
+
+    /* SR11 = 0x0F ; */
+    /* XGINew_SetReg1( pVBInfo->P3c4 , 0x11 , SR11 ) ; */
+
+printk("12");
+
+   if ( HwDeviceExtension->jChipType < XG20 )		/* kuku 2004/06/25 */
+    {
+//    /* Set AGP Rate */
+//    temp1 = XGINew_GetReg1( pVBInfo->P3c4 , 0x3B ) ;
+//    temp1 &= 0x02 ;
+//    if ( temp1 == 0x02 )
+//    {
+//        XGINew_SetReg4( 0xcf8 , 0x80000000 ) ;
+//       ChipsetID = XGINew_GetReg3( 0x0cfc ) ;
+//        XGINew_SetReg4( 0xcf8 , 0x8000002C ) ;
+//        VendorID = XGINew_GetReg3( 0x0cfc ) ;
+//        VendorID &= 0x0000FFFF ;
+//        XGINew_SetReg4( 0xcf8 , 0x8001002C ) ;
+//        GraphicVendorID = XGINew_GetReg3( 0x0cfc ) ;
+//        GraphicVendorID &= 0x0000FFFF;
+//
+//        if ( ChipsetID == 0x7301039 )
+///            XGINew_SetReg1( pVBInfo->P3d4 , 0x5F , 0x09 ) ;
+//
+//        ChipsetID &= 0x0000FFFF ;
+///
+//        if ( ( ChipsetID == 0x700E ) || ( ChipsetID == 0x1022 ) || ( ChipsetID == 0x1106 ) || ( ChipsetID == 0x10DE ) )
+//        {
+//            if ( ChipsetID == 0x1106 )
+//            {
+//                if ( ( VendorID == 0x1019 ) && ( GraphicVendorID == 0x1019 ) )
+//                    XGINew_SetReg1( pVBInfo->P3d4 , 0x5F , 0x0D ) ;
+//                else
+//                    XGINew_SetReg1( pVBInfo->P3d4 , 0x5F , 0x0B ) ;
+//            }
+//            else
+//                XGINew_SetReg1( pVBInfo->P3d4 , 0x5F , 0x0B ) ;
+//        }
+//    }
+
+printk("13");
+
+    if ( HwDeviceExtension->jChipType >= XG40 )
+    {
+        /* Set AGP customize registers (in SetDefAGPRegs) Start */
+        for( i = 0x47 ; i <= 0x4C ; i++ )
+            XGINew_SetReg1( pVBInfo->P3d4 , i , pVBInfo->AGPReg[ i - 0x47 ] ) ;
+
+        for( i = 0x70 ; i <= 0x71 ; i++ )
+            XGINew_SetReg1( pVBInfo->P3d4 , i , pVBInfo->AGPReg[ 6 + i - 0x70 ] ) ;
+
+        for( i = 0x74 ; i <= 0x77 ; i++ )
+            XGINew_SetReg1( pVBInfo->P3d4 , i , pVBInfo->AGPReg[ 8 + i - 0x74 ] ) ;
+        /* Set AGP customize registers (in SetDefAGPRegs) End */
+        /*[Hsuan]2004/12/14 AGP Input Delay Adjustment on 850 */
+//        XGINew_SetReg4( 0xcf8 , 0x80000000 ) ;
+//        ChipsetID = XGINew_GetReg3( 0x0cfc ) ;
+//        if ( ChipsetID == 0x25308086 )
+//            XGINew_SetReg1( pVBInfo->P3d4 , 0x77 , 0xF0 ) ;
+
+        HwDeviceExtension->pQueryVGAConfigSpace( HwDeviceExtension , 0x50 , 0 , &Temp ) ;	/* Get */
+        Temp >>= 20 ;
+        Temp &= 0xF ;
+
+        if ( Temp == 1 )
+            XGINew_SetReg1( pVBInfo->P3d4 , 0x48 , 0x20 ) ;	/* CR48 */
+    }
+printk("14");
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+        XGINew_SetReg1( pVBInfo->P3d4 , 0x49 , pVBInfo->CR49[ 0 ] ) ;
+    }	/* != XG20 */
+
+    /* Set PCI */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x23 , *pVBInfo->pSR23 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x24 , *pVBInfo->pSR24 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x25 , pVBInfo->SR25[ 0 ] ) ;
+printk("15");
+
+    if ( HwDeviceExtension->jChipType < XG20 )		/* kuku 2004/06/25 */
+    {
+    /* Set VB */
+    XGI_UnLockCRT2( HwDeviceExtension, pVBInfo) ;
+    XGINew_SetRegANDOR( pVBInfo->Part0Port , 0x3F , 0xEF , 0x00 ) ;	/* alan, disable VideoCapture */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x00 , 0x00 ) ;
+    temp1 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x7B ) ;		/* chk if BCLK>=100MHz */
+    temp = ( UCHAR )( ( temp1 >> 4 ) & 0x0F ) ;
+
+
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x02 , ( *pVBInfo->pCRT2Data_1_2 ) ) ;
+
+printk("16");
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x2E , 0x08 ) ;	/* use VB */
+    } /* != XG20 */
+
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x27 , 0x1F ) ;
+
+    if ( ( HwDeviceExtension->jChipType == XG42 ) && XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo) != 0 )	/* Not DDR */
+    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , ( *pVBInfo->pSR31 & 0x3F ) | 0x40 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x32 , ( *pVBInfo->pSR32 & 0xFC ) | 0x01 ) ;
+    }
+    else
+    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , *pVBInfo->pSR31 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x32 , *pVBInfo->pSR32 ) ;
+    }
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x33 , *pVBInfo->pSR33 ) ;
+printk("17");
+
+/*
+    if ( HwDeviceExtension->jChipType >= XG40 )
+      SetPowerConsume ( HwDeviceExtension , pVBInfo->P3c4);	*/
+
+    if ( HwDeviceExtension->jChipType < XG20 )		/* kuku 2004/06/25 */
+    {
+    if ( XGI_BridgeIsOn( pVBInfo ) == 1 )
+    {
+        if ( pVBInfo->IF_DEF_LVDS == 0 )
+        {
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x00 , 0x1C ) ;
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x0D , *pVBInfo->pCRT2Data_4_D ) ;
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x0E , *pVBInfo->pCRT2Data_4_E ) ;
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x10 , *pVBInfo->pCRT2Data_4_10 ) ;
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x0F , 0x3F ) ;
+        }
+
+        XGI_LockCRT2( HwDeviceExtension, pVBInfo ) ;
+    }
+    }	/* != XG20 */
+printk("18");
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+        XGINew_SetReg1( pVBInfo->P3d4 , 0x83 , 0x00 ) ;
+printk("181");
+
+    if ( HwDeviceExtension->bSkipSense == FALSE )
+    {
+printk("182");
+
+        XGI_SenseCRT1(pVBInfo) ;
+
+printk("183");
+        /* XGINew_DetectMonitor( HwDeviceExtension ) ; */
+pVBInfo->IF_DEF_CH7007 = 0;
+        if ( ( HwDeviceExtension->jChipType == XG21 ) && (pVBInfo->IF_DEF_CH7007) )
+        {
+printk("184");
+           XGI_GetSenseStatus( HwDeviceExtension , pVBInfo ) ; 	/* sense CRT2 */
+printk("185");
+
+        }
+        if ( HwDeviceExtension->jChipType == XG21 )
+        {
+printk("186");
+
+          XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , ~Monitor1Sense , Monitor1Sense ) ;	/* Z9 default has CRT */
+       	  temp = GetXG21FPBits( pVBInfo ) ;
+          XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x37 , ~0x01, temp ) ;
+printk("187");
+
+          }
+        if ( HwDeviceExtension->jChipType == XG27 )
+        {
+          XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , ~Monitor1Sense , Monitor1Sense ) ;	/* Z9 default has CRT */
+       	  temp = GetXG27FPBits( pVBInfo ) ;
+          XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x37 , ~0x03, temp ) ;
+        }
+    }
+printk("19");
+
+    if ( HwDeviceExtension->jChipType >= XG40 )
+    {
+        if ( HwDeviceExtension->jChipType >= XG40 )
+        {
+          XGINew_RAMType = ( int )XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo ) ;
+         }
+
+        XGINew_SetDRAMDefaultRegister340( HwDeviceExtension ,  pVBInfo->P3d4,  pVBInfo ) ;
+
+        if ( HwDeviceExtension->bSkipDramSizing == TRUE )
+        {
+            pSR = HwDeviceExtension->pSR ;
+            if ( pSR!=NULL )
+            {
+                while( pSR->jIdx != 0xFF )
+                {
+                    XGINew_SetReg1( pVBInfo->P3c4 , pSR->jIdx , pSR->jVal ) ;
+                    pSR++ ;
+                }
+            }
+            /* XGINew_SetDRAMModeRegister340( pVBInfo ) ; */
+        }   	/* SkipDramSizing */
+        else
+        {
+#if 0
+           if ( HwDeviceExtension->jChipType == XG20 )
+            {
+            	XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , pVBInfo->SR15[0][XGINew_RAMType] ) ;
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , pVBInfo->SR15[1][XGINew_RAMType] ) ;
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x20 , 0x20 ) ;
+            }
+            else
+#endif
+{
+printk("20");
+
+               XGINew_SetDRAMSize_340( HwDeviceExtension , pVBInfo) ;
+}
+printk("21");
+
+        }
+    }		/* XG40 */
+
+printk("22");
+
+
+    /* SetDefExt2Regs begin */
+/*
+    AGP = 1 ;
+    temp =( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x3A ) ;
+    temp &= 0x30 ;
+    if ( temp == 0x30 )
+        AGP = 0 ;
+
+    if ( AGP == 0 )
+        *pVBInfo->pSR21 &= 0xEF ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , *pVBInfo->pSR21 ) ;
+    if ( AGP == 1 )
+        *pVBInfo->pSR22 &= 0x20 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x22 , *pVBInfo->pSR22 ) ;
+*/
+
+//    base = 0x80000000 ;
+//    OutPortLong( 0xcf8 , base ) ;
+//    Temp = ( InPortLong( 0xcfc ) & 0xFFFF ) ;
+//    if ( Temp == 0x1039 )
+//    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x22 , ( UCHAR )( ( *pVBInfo->pSR22 ) & 0xFE ) ) ;
+//    }
+//    else
+//    {
+//        XGINew_SetReg1( pVBInfo->P3c4 , 0x22 , *pVBInfo->pSR22 ) ;
+//    }
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , *pVBInfo->pSR21 ) ;
+
+printk("23");
+
+
+    XGINew_ChkSenseStatus ( HwDeviceExtension , pVBInfo ) ;
+    XGINew_SetModeScratch ( HwDeviceExtension , pVBInfo ) ;
+
+printk("24");
+
+
+XGINew_SetReg1( pVBInfo->P3d4 , 0x8c , 0x87);
+XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x31);
+printk("25");
+
+    return( TRUE ) ;
+} /* end of init */
+
+
+
+
+
+/* ============== alan ====================== */
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_GetXG20DRAMType */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGINew_GetXG20DRAMType( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR data, temp ;
+
+    if ( HwDeviceExtension->jChipType < XG20 )
+    {
+        if ( *pVBInfo->pSoftSetting & SoftDRAMType )
+        {
+            data = *pVBInfo->pSoftSetting & 0x07 ;
+            return( data ) ;
+        }
+        else
+        {
+            data = XGINew_GetReg1( pVBInfo->P3c4 , 0x39 ) & 0x02 ;
+
+            if ( data == 0 )
+                data = ( XGINew_GetReg1( pVBInfo->P3c4 , 0x3A ) & 0x02 ) >> 1 ;
+
+            return( data ) ;
+        }
+    }
+    else if ( HwDeviceExtension->jChipType == XG27 )
+    {
+        if ( *pVBInfo->pSoftSetting & SoftDRAMType )
+        {
+            data = *pVBInfo->pSoftSetting & 0x07 ;
+            return( data ) ;
+        }
+        temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x3B ) ;
+
+     	if (( temp & 0x88 )==0x80)		/* SR3B[7][3]MAA15 MAA11 (Power on Trapping) */
+       	  data = 0 ;					/*DDR*/
+        else
+       	  data = 1 ; 					/*DDRII*/
+       	return( data ) ;
+    }
+    else if ( HwDeviceExtension->jChipType == XG21 )
+    {
+        XGINew_SetRegAND( pVBInfo->P3d4 , 0xB4 , ~0x02 ) ;     		/* Independent GPIO control */
+     	DelayUS(800);
+        XGINew_SetRegOR( pVBInfo->P3d4 , 0x4A , 0x80 ) ;		/* Enable GPIOH read */
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;       		/* GPIOF 0:DVI 1:DVO */
+// HOTPLUG_SUPPORT
+// for current XG20 & XG21, GPIOH is floating, driver will fix DDR temporarily
+     	if ( temp & 0x01 )						/* DVI read GPIOH */
+       	  data = 1 ;							/*DDRII*/
+        else
+       	  data = 0 ; 							/*DDR*/
+//~HOTPLUG_SUPPORT
+       	XGINew_SetRegOR( pVBInfo->P3d4 , 0xB4 , 0x02 ) ;
+       	return( data ) ;
+    }
+    else
+    {
+    	data = XGINew_GetReg1( pVBInfo->P3d4 , 0x97 ) & 0x01 ;
+
+    	if ( data == 1 )
+            data ++ ;
+
+    	return( data );
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_Get310DRAMType */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGINew_Get310DRAMType(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR data ;
+
+  /* index = XGINew_GetReg1( pVBInfo->P3c4 , 0x1A ) ; */
+  /* index &= 07 ; */
+
+    if ( *pVBInfo->pSoftSetting & SoftDRAMType )
+        data = *pVBInfo->pSoftSetting & 0x03 ;
+    else
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x3a ) & 0x03 ;
+
+    return( data ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_Delay15us */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+/*
+void XGINew_Delay15us(ULONG ulMicrsoSec)
+{
+}
+*/
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SDR_MRS */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SDR_MRS(  PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT data ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x16 ) ;
+    data &= 0x3F ;          /* SR16 D7=0,D6=0 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;   /* enable mode register set(MRS) low */
+    /* XGINew_Delay15us( 0x100 ) ; */
+    data |= 0x80 ;          /* SR16 D7=1,D6=0 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;   /* enable mode register set(MRS) high */
+    /* XGINew_Delay15us( 0x100 ) ; */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR1x_MRS_340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR1x_MRS_340( ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+    XGINew_SetReg1( P3c4 , 0x18 , 0x01 ) ;
+    XGINew_SetReg1( P3c4 , 0x19 , 0x20 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+    if ( *pVBInfo->pXGINew_DRAMTypeDefinition != 0x0C )	/* Samsung F Die */
+    {
+        DelayUS( 3000 ) ;	/* Delay 67 x 3 Delay15us */
+        XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;
+        XGINew_SetReg1( P3c4 , 0x19 , 0x20 ) ;
+        XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+        XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+    }
+
+    DelayUS( 60 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x01 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , pVBInfo->SR16[ 0 ] ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , pVBInfo->SR16[ 1 ] ) ;
+    DelayUS( 1000 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x03 ) ;
+    DelayUS( 500 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , pVBInfo->SR16[ 2 ] ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , pVBInfo->SR16[ 3 ] ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR2x_MRS_340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR2x_MRS_340( ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x19 , 0x20 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+    DelayUS( 60 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    /* XGINew_SetReg1( P3c4 , 0x18 , 0x31 ) ; */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x01 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+    DelayUS( 1000 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x03 ) ;
+    DelayUS( 500 ) ;
+    /* XGINew_SetReg1( P3c4 , 0x18 , 0x31 ) ; */
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDRII_Bootup_XG27 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDRII_Bootup_XG27( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = P3c4 + 0x10 ;
+    XGINew_RAMType = ( int )XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo ) ;
+    XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+
+   /* Set Double Frequency */
+    /* XGINew_SetReg1( P3d4 , 0x97 , 0x11 ) ; */		/* CR97 */
+    XGINew_SetReg1( P3d4 , 0x97 , *pVBInfo->pXGINew_CR97 ) ;    /* CR97 */
+
+    DelayUS( 200 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;   /* Set SR18 */ //EMRS2
+    XGINew_SetReg1( P3c4 , 0x19 , 0x80 ) ;   /* Set SR19 */
+    XGINew_SetReg1( P3c4 , 0x16 , 0x20 ) ;   /* Set SR16 */
+    DelayUS( 15 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0xA0 ) ;   /* Set SR16 */
+    DelayUS( 15 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;   /* Set SR18 */ //EMRS3
+    XGINew_SetReg1( P3c4 , 0x19 , 0xC0 ) ;   /* Set SR19 */
+    XGINew_SetReg1( P3c4 , 0x16 , 0x20 ) ;   /* Set SR16 */
+    DelayUS( 15 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0xA0 ) ;   /* Set SR16 */
+    DelayUS( 15) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;   /* Set SR18 */ //EMRS1
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;   /* Set SR19 */
+    XGINew_SetReg1( P3c4 , 0x16 , 0x20 ) ;   /* Set SR16 */
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0xA0 ) ;   /* Set SR16 */
+    DelayUS( 15 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;   /* Set SR18 */ //MRS, DLL Enable
+    XGINew_SetReg1( P3c4 , 0x19 , 0x0A ) ;   /* Set SR19 */
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;   /* Set SR16 */
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;   /* Set SR16 */
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;   /* Set SR16 */
+    /* DelayUS( 15 ) ; */
+
+    XGINew_SetReg1( P3c4 , 0x1B , 0x04 ) ;   /* Set SR1B */
+    DelayUS( 60 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;   /* Set SR1B */
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;   /* Set SR18 */ //MRS, DLL Reset
+    XGINew_SetReg1( P3c4 , 0x19 , 0x08 ) ;   /* Set SR19 */
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;   /* Set SR16 */
+
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x83 ) ;   /* Set SR16 */
+    DelayUS( 15 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x80 ) ;   /* Set SR18 */ //MRS, ODT
+    XGINew_SetReg1( P3c4 , 0x19 , 0x46 ) ;   /* Set SR19 */
+    XGINew_SetReg1( P3c4 , 0x16 , 0x20 ) ;   /* Set SR16 */
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0xA0 ) ;   /* Set SR16 */
+    DelayUS( 15 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;   /* Set SR18 */ //EMRS
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;   /* Set SR19 */
+    XGINew_SetReg1( P3c4 , 0x16 , 0x20 ) ;   /* Set SR16 */
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0xA0 ) ;   /* Set SR16 */
+    DelayUS( 15 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x1B , 0x04 ) ;   /* Set SR1B refresh control 000:close; 010:open */
+    DelayUS( 200 ) ;
+
+
+}
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR2_MRS_XG20 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR2_MRS_XG20( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = P3c4 + 0x10 ;
+
+    XGINew_RAMType = ( int )XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo ) ;
+    XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+
+    XGINew_SetReg1( P3d4 , 0x97 , 0x11 ) ;			/* CR97 */
+
+    DelayUS( 200 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS2 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x80 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS3 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0xC0 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+
+   // XGINew_SetReg1( P3c4 , 0x18 , 0x52 ) ;			/* MRS1 */
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;			/* MRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x02 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+
+    DelayUS( 15 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x04 ) ;			/* SR1B */
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;			/* SR1B */
+    DelayUS( 100 ) ;
+
+    //XGINew_SetReg1( P3c4 , 0x18 , 0x52 ) ;			/* MRS2 */
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;			/* MRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x05 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x85 ) ;
+
+    DelayUS( 200 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR2_MRS_XG20 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR2_MRS_XG27( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = P3c4 + 0x10 ;
+
+     XGINew_RAMType = ( int )XGINew_GetXG20DRAMType( HwDeviceExtension , pVBInfo ) ;
+     XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+
+    XGINew_SetReg1( P3d4 , 0x97 , 0x11 ) ;			/* CR97 */
+    DelayUS( 200 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS2 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x80 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x16 , 0x10 ) ;
+    DelayUS( 15 ) ;                          ////06/11/23 XG27 A0 for CKE enable
+    XGINew_SetReg1( P3c4 , 0x16 , 0x90 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS3 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0xC0 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 15 ) ;                          ////06/11/22 XG27 A0
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;			/* EMRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 15 ) ;                          ////06/11/22 XG27 A0
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;			/* MRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x06 ) ;   ////[Billy]06/11/22 DLL Reset for XG27 Hynix DRAM
+
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 15 ) ;                          ////06/11/23 XG27 A0
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+    DelayUS( 30 ) ;                          ////06/11/23 XG27 A0 Start Auto-PreCharge
+    XGINew_SetReg1( P3c4 , 0x1B , 0x04 ) ;			/* SR1B */
+    DelayUS( 60 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;			/* SR1B */
+
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x42 ) ;			/* MRS1 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x04 ) ;   //// DLL without Reset for XG27 Hynix DRAM
+
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x80 );     ////XG27 OCD ON
+    XGINew_SetReg1( P3c4 , 0x19 , 0x46 );
+
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 );
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 );
+
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    DelayUS( 30 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+
+    DelayUS( 15 ) ;                         ////Start Auto-PreCharge
+    XGINew_SetReg1( P3c4 , 0x1B , 0x04 ) ;			/* SR1B */
+    DelayUS( 200 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x03 ) ;			/* SR1B */
+
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR1x_DefaultRegister */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR1x_DefaultRegister( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG Port , PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = Port ,
+           P3c4 = Port - 0x10 ;
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+    {
+        XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+        XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+        XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+        XGINew_SetReg1( P3d4 , 0x86 , pVBInfo->CR40[ 13 ][ XGINew_RAMType ] ) ;	/* CR86 */
+
+        XGINew_SetReg1( P3d4 , 0x98 , 0x01 ) ;
+        XGINew_SetReg1( P3d4 , 0x9A , 0x02 ) ;
+
+        XGINew_DDR1x_MRS_XG20( P3c4 , pVBInfo) ;
+    }
+    else
+    {
+        XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+
+        switch( HwDeviceExtension->jChipType )
+        {
+            case XG41:
+            case XG42:
+                XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+                XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+                XGINew_SetReg1( P3d4 , 0x86 , pVBInfo->CR40[ 13 ][ XGINew_RAMType ] ) ;	/* CR86 */
+                break ;
+            default:
+                XGINew_SetReg1( P3d4 , 0x82 , 0x88 ) ;
+                XGINew_SetReg1( P3d4 , 0x86 , 0x00 ) ;
+                XGINew_GetReg1( P3d4 , 0x86 ) ;				/* Insert read command for delay */
+                XGINew_SetReg1( P3d4 , 0x86 , 0x88 ) ;
+                XGINew_GetReg1( P3d4 , 0x86 ) ;
+                XGINew_SetReg1( P3d4 , 0x86 , pVBInfo->CR40[ 13 ][ XGINew_RAMType ] ) ;
+                XGINew_SetReg1( P3d4 , 0x82 , 0x77 ) ;
+                XGINew_SetReg1( P3d4 , 0x85 , 0x00 ) ;
+                XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+                XGINew_SetReg1( P3d4 , 0x85 , 0x88 ) ;
+                XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+                XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+                XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+                break ;
+        }
+
+        XGINew_SetReg1( P3d4 , 0x97 , 0x00 ) ;
+        XGINew_SetReg1( P3d4 , 0x98 , 0x01 ) ;
+        XGINew_SetReg1( P3d4 , 0x9A , 0x02 ) ;
+        XGINew_DDR1x_MRS_340( P3c4 , pVBInfo ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR2x_DefaultRegister */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR2x_DefaultRegister( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG Port ,PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = Port ,
+           P3c4 = Port - 0x10 ;
+
+    XGINew_SetMemoryClock( HwDeviceExtension , pVBInfo ) ;
+
+    /* 20040906 Hsuan modify CR82, CR85, CR86 for XG42 */
+    switch( HwDeviceExtension->jChipType )
+    {
+       case XG41:
+       case XG42:
+            XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+            XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+            XGINew_SetReg1( P3d4 , 0x86 , pVBInfo->CR40[ 13 ][ XGINew_RAMType ] ) ;	/* CR86 */
+            break ;
+       default:
+         /* keep following setting sequence, each setting in the same reg insert idle */
+         XGINew_SetReg1( P3d4 , 0x82 , 0x88 ) ;
+    	 XGINew_SetReg1( P3d4 , 0x86 , 0x00 ) ;
+    	 XGINew_GetReg1( P3d4 , 0x86 ) ;				/* Insert read command for delay */
+    	 XGINew_SetReg1( P3d4 , 0x86 , 0x88 ) ;
+    	 XGINew_SetReg1( P3d4 , 0x82 , 0x77 ) ;
+    	 XGINew_SetReg1( P3d4 , 0x85 , 0x00 ) ;
+    	 XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+    	 XGINew_SetReg1( P3d4 , 0x85 , 0x88 ) ;
+    	 XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+    	 XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+    	 XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+    }
+    XGINew_SetReg1( P3d4 , 0x97 , 0x11 ) ;
+    if ( HwDeviceExtension->jChipType == XG42 )
+    {
+      XGINew_SetReg1( P3d4 , 0x98 , 0x01 ) ;
+    }
+    else
+    {
+      XGINew_SetReg1( P3d4 , 0x98 , 0x03 ) ;
+    }
+    XGINew_SetReg1( P3d4 , 0x9A , 0x02 ) ;
+
+    XGINew_DDR2x_MRS_340( P3c4 , pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR2_DefaultRegister */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR2_DefaultRegister( PXGI_HW_DEVICE_INFO HwDeviceExtension, ULONG Port , PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG P3d4 = Port ,
+           P3c4 = Port - 0x10 ;
+
+    /* keep following setting sequence, each setting in the same reg insert idle */
+    XGINew_SetReg1( P3d4 , 0x82 , 0x77 ) ;
+    XGINew_SetReg1( P3d4 , 0x86 , 0x00 ) ;
+    XGINew_GetReg1( P3d4 , 0x86 ) ;				/* Insert read command for delay */
+    XGINew_SetReg1( P3d4 , 0x86 , 0x88 ) ;
+    XGINew_GetReg1( P3d4 , 0x86 ) ;				/* Insert read command for delay */
+    XGINew_SetReg1( P3d4 , 0x86 , pVBInfo->CR40[ 13 ][ XGINew_RAMType ] ) ;	/* CR86 */
+    XGINew_SetReg1( P3d4 , 0x82 , 0x77 ) ;
+    XGINew_SetReg1( P3d4 , 0x85 , 0x00 ) ;
+    XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+    XGINew_SetReg1( P3d4 , 0x85 , 0x88 ) ;
+    XGINew_GetReg1( P3d4 , 0x85 ) ;				/* Insert read command for delay */
+    XGINew_SetReg1( P3d4 , 0x85 , pVBInfo->CR40[ 12 ][ XGINew_RAMType ] ) ;	/* CR85 */
+    if ( HwDeviceExtension->jChipType == XG27 )
+      XGINew_SetReg1( P3d4 , 0x82 , pVBInfo->CR40[ 11 ][ XGINew_RAMType ] ) ;	/* CR82 */
+    else
+    XGINew_SetReg1( P3d4 , 0x82 , 0xA8 ) ;	/* CR82 */
+
+    XGINew_SetReg1( P3d4 , 0x98 , 0x01 ) ;
+    XGINew_SetReg1( P3d4 , 0x9A , 0x02 ) ;
+    if ( HwDeviceExtension->jChipType == XG27 )
+       XGINew_DDRII_Bootup_XG27( HwDeviceExtension ,  P3c4 , pVBInfo) ;
+    else
+    XGINew_DDR2_MRS_XG20( HwDeviceExtension , P3c4, pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMDefaultRegister340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMDefaultRegister340( PXGI_HW_DEVICE_INFO HwDeviceExtension ,  ULONG Port , PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR temp , temp1 , temp2 , temp3 ,
+          i , j , k ;
+
+    ULONG P3d4 = Port ,
+           P3c4 = Port - 0x10 ;
+
+    XGINew_SetReg1( P3d4 , 0x6D , pVBInfo->CR40[ 8 ][ XGINew_RAMType ] ) ;
+    XGINew_SetReg1( P3d4 , 0x68 , pVBInfo->CR40[ 5 ][ XGINew_RAMType ] ) ;
+    XGINew_SetReg1( P3d4 , 0x69 , pVBInfo->CR40[ 6 ][ XGINew_RAMType ] ) ;
+    XGINew_SetReg1( P3d4 , 0x6A , pVBInfo->CR40[ 7 ][ XGINew_RAMType ] ) ;
+
+    temp2 = 0 ;
+    for( i = 0 ; i < 4 ; i++ )
+    {
+        temp = pVBInfo->CR6B[ XGINew_RAMType ][ i ] ;        		/* CR6B DQS fine tune delay */
+        for( j = 0 ; j < 4 ; j++ )
+        {
+            temp1 = ( ( temp >> ( 2 * j ) ) & 0x03 ) << 2 ;
+            temp2 |= temp1 ;
+            XGINew_SetReg1( P3d4 , 0x6B , temp2 ) ;
+            XGINew_GetReg1( P3d4 , 0x6B ) ;				/* Insert read command for delay */
+            temp2 &= 0xF0 ;
+            temp2 += 0x10 ;
+        }
+    }
+
+    temp2 = 0 ;
+    for( i = 0 ; i < 4 ; i++ )
+    {
+        temp = pVBInfo->CR6E[ XGINew_RAMType ][ i ] ;        		/* CR6E DQM fine tune delay */
+        for( j = 0 ; j < 4 ; j++ )
+        {
+            temp1 = ( ( temp >> ( 2 * j ) ) & 0x03 ) << 2 ;
+            temp2 |= temp1 ;
+            XGINew_SetReg1( P3d4 , 0x6E , temp2 ) ;
+            XGINew_GetReg1( P3d4 , 0x6E ) ;				/* Insert read command for delay */
+            temp2 &= 0xF0 ;
+            temp2 += 0x10 ;
+        }
+    }
+
+    temp3 = 0 ;
+    for( k = 0 ; k < 4 ; k++ )
+    {
+        XGINew_SetRegANDOR( P3d4 , 0x6E , 0xFC , temp3 ) ;		/* CR6E_D[1:0] select channel */
+        temp2 = 0 ;
+        for( i = 0 ; i < 8 ; i++ )
+        {
+            temp = pVBInfo->CR6F[ XGINew_RAMType ][ 8 * k + i ] ;   	/* CR6F DQ fine tune delay */
+            for( j = 0 ; j < 4 ; j++ )
+            {
+                temp1 = ( temp >> ( 2 * j ) ) & 0x03 ;
+                temp2 |= temp1 ;
+                XGINew_SetReg1( P3d4 , 0x6F , temp2 ) ;
+                XGINew_GetReg1( P3d4 , 0x6F ) ;				/* Insert read command for delay */
+                temp2 &= 0xF8 ;
+                temp2 += 0x08 ;
+            }
+        }
+        temp3 += 0x01 ;
+    }
+
+    XGINew_SetReg1( P3d4 , 0x80 , pVBInfo->CR40[ 9 ][ XGINew_RAMType ] ) ;	/* CR80 */
+    XGINew_SetReg1( P3d4 , 0x81 , pVBInfo->CR40[ 10 ][ XGINew_RAMType ] ) ;	/* CR81 */
+
+    temp2 = 0x80 ;
+    temp = pVBInfo->CR89[ XGINew_RAMType ][ 0 ] ;        		/* CR89 terminator type select */
+    for( j = 0 ; j < 4 ; j++ )
+    {
+        temp1 = ( temp >> ( 2 * j ) ) & 0x03 ;
+        temp2 |= temp1 ;
+        XGINew_SetReg1( P3d4 , 0x89 , temp2 ) ;
+        XGINew_GetReg1( P3d4 , 0x89 ) ;				/* Insert read command for delay */
+        temp2 &= 0xF0 ;
+        temp2 += 0x10 ;
+    }
+
+    temp = pVBInfo->CR89[ XGINew_RAMType ][ 1 ] ;
+    temp1 = temp & 0x03 ;
+    temp2 |= temp1 ;
+    XGINew_SetReg1( P3d4 , 0x89 , temp2 ) ;
+
+    temp = pVBInfo->CR40[ 3 ][ XGINew_RAMType ] ;
+    temp1 = temp & 0x0F ;
+    temp2 = ( temp >> 4 ) & 0x07 ;
+    temp3 = temp & 0x80 ;
+    XGINew_SetReg1( P3d4 , 0x45 , temp1 ) ;	/* CR45 */
+    XGINew_SetReg1( P3d4 , 0x99 , temp2 ) ;	/* CR99 */
+    XGINew_SetRegOR( P3d4 , 0x40 , temp3 ) ;	/* CR40_D[7] */
+    XGINew_SetReg1( P3d4 , 0x41 , pVBInfo->CR40[ 0 ][ XGINew_RAMType ] ) ;	/* CR41 */
+
+    if ( HwDeviceExtension->jChipType == XG27 )
+      XGINew_SetReg1( P3d4 , 0x8F , *pVBInfo->pCR8F ) ;	/* CR8F */
+
+    for( j = 0 ; j <= 6 ; j++ )
+        XGINew_SetReg1( P3d4 , ( 0x90 + j ) , pVBInfo->CR40[ 14 + j ][ XGINew_RAMType ] ) ;	/* CR90 - CR96 */
+
+    for( j = 0 ; j <= 2 ; j++ )
+        XGINew_SetReg1( P3d4 , ( 0xC3 + j ) , pVBInfo->CR40[ 21 + j ][ XGINew_RAMType ] ) ;	/* CRC3 - CRC5 */
+
+    for( j = 0 ; j < 2 ; j++ )
+        XGINew_SetReg1( P3d4 , ( 0x8A + j ) , pVBInfo->CR40[ 1 + j ][ XGINew_RAMType ] ) ;	/* CR8A - CR8B */
+
+    if ( ( HwDeviceExtension->jChipType == XG41 ) || ( HwDeviceExtension->jChipType == XG42 ) )
+        XGINew_SetReg1( P3d4 , 0x8C , 0x87 ) ;
+
+    XGINew_SetReg1( P3d4 , 0x59 , pVBInfo->CR40[ 4 ][ XGINew_RAMType ] ) ;	/* CR59 */
+
+    XGINew_SetReg1( P3d4 , 0x83 , 0x09 ) ;	/* CR83 */
+    XGINew_SetReg1( P3d4 , 0x87 , 0x00 ) ;	/* CR87 */
+    XGINew_SetReg1( P3d4 , 0xCF , *pVBInfo->pCRCF ) ;	/* CRCF */
+    if ( XGINew_RAMType )
+    {
+      //XGINew_SetReg1( P3c4 , 0x17 , 0xC0 ) ;		/* SR17 DDRII */
+      XGINew_SetReg1( P3c4 , 0x17 , 0x80 ) ;		/* SR17 DDRII */
+      if ( HwDeviceExtension->jChipType == XG27 )
+        XGINew_SetReg1( P3c4 , 0x17 , 0x02 ) ;		/* SR17 DDRII */
+
+    }
+    else
+      XGINew_SetReg1( P3c4 , 0x17 , 0x00 ) ;		/* SR17 DDR */
+    XGINew_SetReg1( P3c4 , 0x1A , 0x87 ) ;		/* SR1A */
+
+    temp = XGINew_GetXG20DRAMType( HwDeviceExtension, pVBInfo) ;
+    if( temp == 0 )
+      XGINew_DDR1x_DefaultRegister( HwDeviceExtension, P3d4, pVBInfo ) ;
+    else
+    {
+      XGINew_SetReg1( P3d4 , 0xB0 , 0x80 ) ;		/* DDRII Dual frequency mode */
+      XGINew_DDR2_DefaultRegister( HwDeviceExtension, P3d4, pVBInfo ) ;
+    }
+    XGINew_SetReg1( P3c4 , 0x1B , pVBInfo->SR15[ 3 ][ XGINew_RAMType ] ) ;	/* SR1B */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR_MRS */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR_MRS(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+
+    PUCHAR volatile pVideoMemory = ( PUCHAR )pVBInfo->ROMAddr ;
+
+    /* SR16 <- 1F,DF,2F,AF */
+    /* yriver modified SR16 <- 0F,DF,0F,AF */
+    /* enable DLL of DDR SD/SGRAM , SR16 D4=1 */
+    data = pVideoMemory[ 0xFB ] ;
+    /* data = XGINew_GetReg1( pVBInfo->P3c4 , 0x16 ) ; */
+
+    data &= 0x0F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data |= 0xC0 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data &= 0x0F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data |= 0x80 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data &= 0x0F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data |= 0xD0 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data &= 0x0F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+    data |= 0xA0 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , data ) ;
+/*
+   else {
+     data &= 0x0F;
+     data |= 0x10;
+     XGINew_SetReg1(pVBInfo->P3c4,0x16,data);
+
+     if (!(pVBInfo->SR15[1][XGINew_RAMType] & 0x10))
+     {
+       data &= 0x0F;
+     }
+
+     data |= 0xC0;
+     XGINew_SetReg1(pVBInfo->P3c4,0x16,data);
+
+
+     data &= 0x0F;
+     data |= 0x20;
+     XGINew_SetReg1(pVBInfo->P3c4,0x16,data);
+     if (!(pVBInfo->SR15[1][XGINew_RAMType] & 0x10))
+     {
+       data &= 0x0F;
+     }
+
+     data |= 0x80;
+     XGINew_SetReg1(pVBInfo->P3c4,0x16,data);
+   }
+*/
+}
+
+
+/* check if read cache pointer is correct */
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_VerifyMclk */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_VerifyMclk( PXGI_HW_DEVICE_INFO  HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    PUCHAR pVideoMemory = pVBInfo->FBAddr ;
+    UCHAR i , j ;
+    USHORT Temp , SR21 ;
+
+    pVideoMemory[ 0 ] = 0xaa ; 		/* alan */
+    pVideoMemory[ 16 ] = 0x55 ; 	/* note: PCI read cache is off */
+
+    if ( ( pVideoMemory[ 0 ] != 0xaa ) || ( pVideoMemory[ 16 ] != 0x55 ) )
+    {
+        for( i = 0 , j = 16 ; i < 2 ; i++ , j += 16 )
+        {
+            SR21 = XGINew_GetReg1( pVBInfo->P3c4 , 0x21 ) ;
+            Temp = SR21 & 0xFB ;	/* disable PCI post write buffer empty gating */
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , Temp ) ;
+
+            Temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x3C ) ;
+            Temp |= 0x01 ;		/* MCLK reset */
+
+
+            Temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x3C ) ;
+            Temp &= 0xFE ;		/* MCLK normal operation */
+
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , SR21 ) ;
+
+            pVideoMemory[ 16 + j ] = j ;
+            if ( pVideoMemory[ 16 + j ] == j )
+            {
+                pVideoMemory[ j ] = j ;
+                break ;
+            }
+        }
+    }
+}
+
+
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMSize_340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMSize_340( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT  data ;
+
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+
+    XGISetModeNew( HwDeviceExtension , 0x2e ) ;
+
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x21 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , ( USHORT )( data & 0xDF ) ) ;	/* disable read cache */
+    XGI_DisplayOff( HwDeviceExtension, pVBInfo );
+
+    /*data = XGINew_GetReg1( pVBInfo->P3c4 , 0x1 ) ;*/
+    /*data |= 0x20 ;*/
+    /*XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , data ) ;*/			/* Turn OFF Display */
+    XGINew_DDRSizing340( HwDeviceExtension, pVBInfo ) ;
+    data=XGINew_GetReg1( pVBInfo->P3c4 , 0x21 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , ( USHORT )( data | 0x20 ) ) ;	/* enable read cache */
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMSize_310( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+    pVBInfo->ROMAddr  = HwDeviceExtension->pjVirtualRomBase ,
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+#ifdef XGI301
+    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x30 , 0x40 ) ; */
+#endif
+
+#ifdef XGI302	/* alan,should change value */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x30 , 0x4D ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x31 , 0xc0 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x34 , 0x3F ) ;
+#endif
+
+    XGISetModeNew( HwDeviceExtension , 0x2e ) ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x21 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , ( USHORT )( data & 0xDF ) ) ;	/* disable read cache */
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x1 ) ;
+    data |= 0x20 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , data ) ;		/* Turn OFF Display */
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x16 ) ;
+
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , ( USHORT )( data | 0x0F ) ) ;		/* assume lowest speed DRAM */
+
+    XGINew_SetDRAMModeRegister( pVBInfo ) ;
+    XGINew_DisableRefresh( HwDeviceExtension, pVBInfo ) ;
+    XGINew_CheckBusWidth_310( pVBInfo) ;
+    XGINew_VerifyMclk( HwDeviceExtension, pVBInfo ) ;	/* alan 2000/7/3 */
+
+
+
+    if ( XGINew_Get310DRAMType( pVBInfo ) < 2 )
+    {
+        XGINew_SDRSizing( pVBInfo ) ;
+    }
+    else
+    {
+        XGINew_DDRSizing( pVBInfo) ;
+    }
+
+
+
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x16 , pVBInfo->SR15[ 1 ][ XGINew_RAMType ] ) ;	/* restore SR16 */
+
+    XGINew_EnableRefresh(  HwDeviceExtension, pVBInfo ) ;
+    data=XGINew_GetReg1( pVBInfo->P3c4 ,0x21 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x21 , ( USHORT )( data | 0x20 ) ) ;	/* enable read cache */
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMModeRegister340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+
+void XGINew_SetDRAMModeRegister340( PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+    UCHAR data ;
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+    pVBInfo->BaseAddr = (ULONG)HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ISXPDOS = 0 ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+    if ( HwDeviceExtension->jChipType < XG20 )                  /* kuku 2004/06/25 */
+    XGI_GetVBType( pVBInfo ) ;         /* Run XGI_GetVBType before InitTo330Pointer */
+
+    InitTo330Pointer(HwDeviceExtension->jChipType,pVBInfo);
+
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+
+    if ( XGINew_GetXG20DRAMType( HwDeviceExtension, pVBInfo) == 0 )
+    {
+        data = ( XGINew_GetReg1( pVBInfo->P3c4 , 0x39 ) & 0x02 ) >> 1 ;
+        if ( data == 0x01 )
+            XGINew_DDR2x_MRS_340( pVBInfo->P3c4, pVBInfo ) ;
+        else
+            XGINew_DDR1x_MRS_340( pVBInfo->P3c4, pVBInfo ) ;
+    }
+    else
+        XGINew_DDR2_MRS_XG20( HwDeviceExtension, pVBInfo->P3c4, pVBInfo);
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , 0x03 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMModeRegister */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMModeRegister( PVB_DEVICE_INFO pVBInfo)
+{
+    if ( XGINew_Get310DRAMType( pVBInfo ) < 2 )
+    {
+      XGINew_SDR_MRS(pVBInfo ) ;
+    }
+    else
+    {
+      /* SR16 <- 0F,CF,0F,8F */
+      XGINew_DDR_MRS( pVBInfo ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DisableRefresh */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DisableRefresh( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT  data ;
+
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x1B ) ;
+    data &= 0xF8 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , data ) ;
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_EnableRefresh */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_EnableRefresh( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , pVBInfo->SR15[ 3 ][ XGINew_RAMType ] ) ;	/* SR1B */
+
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DisableChannelInterleaving */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DisableChannelInterleaving( int index , USHORT XGINew_DDRDRAM_TYPE[][ 5 ] , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x15 ) ;
+    data &= 0x1F ;
+
+    switch( XGINew_DDRDRAM_TYPE[ index ][ 3 ] )
+    {
+        case 64:
+            data |= 0 ;
+            break ;
+        case 32:
+            data |= 0x20 ;
+            break ;
+        case 16:
+            data |= 0x40 ;
+            break ;
+        case 4:
+            data |= 0x60 ;
+            break ;
+        default:
+            break ;
+    }
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x15 , data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMSizingType */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMSizingType( int index , USHORT DRAMTYPE_TABLE[][ 5 ] ,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+
+    data = DRAMTYPE_TABLE[ index ][ 4 ] ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x13 , 0x80 , data ) ;
+    DelayUS( 15 ) ;
+   /* should delay 50 ns */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckBusWidth_310 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_CheckBusWidth_310(  PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+    PULONG volatile pVideoMemory ;
+
+    pVideoMemory = (PULONG) pVBInfo->FBAddr;
+
+    if ( XGINew_Get310DRAMType( pVBInfo ) < 2 )
+    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x00 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x12 ) ;
+        /* should delay */
+        XGINew_SDR_MRS( pVBInfo ) ;
+
+        XGINew_ChannelAB = 0 ;
+        XGINew_DataBusWidth = 128 ;
+        pVideoMemory[ 0 ] = 0x01234567L ;
+        pVideoMemory[ 1 ] = 0x456789ABL ;
+        pVideoMemory[ 2 ] = 0x89ABCDEFL ;
+        pVideoMemory[ 3 ] = 0xCDEF0123L ;
+        pVideoMemory[ 4 ] = 0x55555555L ;
+        pVideoMemory[ 5 ] = 0x55555555L ;
+        pVideoMemory[ 6 ] = 0xFFFFFFFFL ;
+        pVideoMemory[ 7 ] = 0xFFFFFFFFL ;
+
+        if ( ( pVideoMemory[ 3 ] != 0xCDEF0123L ) || ( pVideoMemory[ 2 ] != 0x89ABCDEFL ) )
+        {
+            /* ChannelA64Bit */
+            XGINew_DataBusWidth = 64 ;
+            XGINew_ChannelAB = 0 ;
+            data=XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , ( USHORT )( data & 0xFD ) ) ;
+        }
+
+        if ( ( pVideoMemory[ 1 ] != 0x456789ABL ) || ( pVideoMemory[ 0 ] != 0x01234567L ) )
+        {
+            /* ChannelB64Bit */
+            XGINew_DataBusWidth = 64 ;
+            XGINew_ChannelAB = 1 ;
+            data=XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , ( USHORT )( ( data & 0xFD ) | 0x01 ) ) ;
+        }
+
+        return ;
+    }
+    else
+    {
+        /* DDR Dual channel */
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x00 ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x02 ) ;	/* Channel A, 64bit */
+        /* should delay */
+        XGINew_DDR_MRS( pVBInfo ) ;
+
+        XGINew_ChannelAB = 0 ;
+        XGINew_DataBusWidth = 64 ;
+        pVideoMemory[ 0 ] = 0x01234567L ;
+        pVideoMemory[ 1 ] = 0x456789ABL ;
+        pVideoMemory[ 2 ] = 0x89ABCDEFL ;
+        pVideoMemory[ 3 ] = 0xCDEF0123L ;
+        pVideoMemory[ 4 ] = 0x55555555L ;
+        pVideoMemory[ 5 ] = 0x55555555L ;
+        pVideoMemory[ 6 ] = 0xAAAAAAAAL ;
+        pVideoMemory[ 7 ] = 0xAAAAAAAAL ;
+
+        if ( pVideoMemory[ 1 ] == 0x456789ABL )
+        {
+            if ( pVideoMemory[ 0 ] == 0x01234567L )
+            {
+                /* Channel A 64bit */
+                return ;
+            }
+        }
+        else
+        {
+            if ( pVideoMemory[ 0 ] == 0x01234567L )
+            {
+                /* Channel A 32bit */
+                XGINew_DataBusWidth = 32 ;
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x00 ) ;
+                return ;
+            }
+        }
+
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x03 ) ;	/* Channel B, 64bit */
+        XGINew_DDR_MRS( pVBInfo);
+
+        XGINew_ChannelAB = 1 ;
+        XGINew_DataBusWidth = 64 ;
+        pVideoMemory[ 0 ] = 0x01234567L ;
+        pVideoMemory[ 1 ] = 0x456789ABL ;
+        pVideoMemory[ 2 ] = 0x89ABCDEFL ;
+        pVideoMemory[ 3 ] = 0xCDEF0123L ;
+        pVideoMemory[ 4 ] = 0x55555555L ;
+        pVideoMemory[ 5 ] = 0x55555555L ;
+        pVideoMemory[ 6 ] = 0xAAAAAAAAL ;
+        pVideoMemory[ 7 ] = 0xAAAAAAAAL ;
+
+        if ( pVideoMemory[ 1 ] == 0x456789ABL )
+        {
+            /* Channel B 64 */
+            if ( pVideoMemory[ 0 ] == 0x01234567L )
+            {
+                /* Channel B 64bit */
+                return ;
+            }
+            else
+            {
+                /* error */
+            }
+        }
+        else
+        {
+            if ( pVideoMemory[ 0 ] == 0x01234567L )
+            {
+                /* Channel B 32 */
+                XGINew_DataBusWidth = 32 ;
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x01 ) ;
+            }
+            else
+            {
+                /* error */
+            }
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetRank */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_SetRank( int index , UCHAR RankNo , UCHAR XGINew_ChannelAB , USHORT DRAMTYPE_TABLE[][ 5 ] , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+    int RankSize ;
+
+    if ( ( RankNo == 2 ) && ( DRAMTYPE_TABLE[ index ][ 0 ] == 2 ) )
+        return 0 ;
+
+    RankSize = DRAMTYPE_TABLE[ index ][ 3 ] / 2 * XGINew_DataBusWidth / 32 ;
+
+    if ( ( RankNo * RankSize ) <= 128 )
+    {
+        data = 0 ;
+
+        while( ( RankSize >>= 1 ) > 0 )
+        {
+            data += 0x10 ;
+        }
+        data |= ( RankNo - 1 ) << 2 ;
+        data |= ( XGINew_DataBusWidth / 64 ) & 2 ;
+        data |= XGINew_ChannelAB ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , data ) ;
+        /* should delay */
+        XGINew_SDR_MRS( pVBInfo ) ;
+        return( 1 ) ;
+    }
+    else
+        return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDDRChannel */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_SetDDRChannel( int index , UCHAR ChannelNo , UCHAR XGINew_ChannelAB , USHORT DRAMTYPE_TABLE[][ 5 ] , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT  data ;
+    int RankSize ;
+
+    RankSize = DRAMTYPE_TABLE[index][3]/2 * XGINew_DataBusWidth/32;
+    /* RankSize = DRAMTYPE_TABLE[ index ][ 3 ] ; */
+    if ( ChannelNo * RankSize <= 128 )
+    {
+        data = 0 ;
+        while( ( RankSize >>= 1 ) > 0 )
+        {
+            data += 0x10 ;
+        }
+
+        if ( ChannelNo == 2 )
+            data |= 0x0C ;
+
+        data |= ( XGINew_DataBusWidth / 32 ) & 2 ;
+        data |= XGINew_ChannelAB ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , data ) ;
+        /* should delay */
+        XGINew_DDR_MRS( pVBInfo ) ;
+        return( 1 ) ;
+    }
+    else
+        return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckColumn */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckColumn( int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    int i ;
+    ULONG Increment , Position ;
+
+    /* Increment = 1 << ( DRAMTYPE_TABLE[ index ][ 2 ] + XGINew_DataBusWidth / 64 + 1 ) ; */
+    Increment = 1 << ( 10 + XGINew_DataBusWidth / 64 ) ;
+
+    for( i = 0 , Position = 0 ; i < 2 ; i++ )
+    {
+        *( ( PULONG )( pVBInfo->FBAddr + Position ) ) = Position ;
+        Position += Increment ;
+    }
+
+#ifdef WIN2000  /* chiawen for linux solution */
+    DelayUS( 100 ) ;
+#endif
+
+    for( i = 0 , Position = 0 ; i < 2 ; i++ )
+    {
+        /* if ( pVBInfo->FBAddr[ Position ] != Position ) */
+        if ( ( *( PULONG )( pVBInfo->FBAddr + Position ) ) != Position )
+            return( 0 ) ;
+        Position += Increment ;
+    }
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckBanks */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckBanks( int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    int i ;
+    ULONG Increment , Position ;
+
+    Increment = 1 << ( DRAMTYPE_TABLE[ index ][ 2 ] + XGINew_DataBusWidth / 64 + 2 ) ;
+
+    for( i = 0 , Position = 0 ; i < 4 ; i++ )
+    {
+        /* pVBInfo->FBAddr[ Position ] = Position ; */
+        *( ( PULONG )( pVBInfo->FBAddr + Position ) ) = Position ;
+        Position += Increment ;
+    }
+
+    for( i = 0 , Position = 0 ; i < 4 ; i++ )
+    {
+        /* if (pVBInfo->FBAddr[ Position ] != Position ) */
+        if ( ( *( PULONG )( pVBInfo->FBAddr + Position ) ) != Position )
+            return( 0 ) ;
+        Position += Increment ;
+    }
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckRank */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckRank( int RankNo , int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    int i ;
+    ULONG Increment , Position ;
+
+    Increment = 1 << ( DRAMTYPE_TABLE[ index ][ 2 ] + DRAMTYPE_TABLE[ index ][ 1 ] +
+                  DRAMTYPE_TABLE[ index ][ 0 ] + XGINew_DataBusWidth / 64 + RankNo ) ;
+
+    for( i = 0 , Position = 0 ; i < 2 ; i++ )
+    {
+        /* pVBInfo->FBAddr[ Position ] = Position ; */
+        /* *( ( PULONG )( pVBInfo->FBAddr ) ) = Position ; */
+        *( ( PULONG )( pVBInfo->FBAddr + Position ) ) = Position ;
+        Position += Increment ;
+    }
+
+    for( i = 0 , Position = 0 ; i < 2 ; i++ )
+    {
+        /* if ( pVBInfo->FBAddr[ Position ] != Position ) */
+        /* if ( ( *( PULONG )( pVBInfo->FBAddr ) ) != Position ) */
+        if ( ( *( PULONG )( pVBInfo->FBAddr + Position ) ) != Position )
+            return( 0 ) ;
+        Position += Increment ;
+    }
+    return( 1 );
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckDDRRank */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckDDRRank( int RankNo , int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    ULONG Increment , Position ;
+    USHORT data ;
+
+    Increment = 1 << ( DRAMTYPE_TABLE[ index ][ 2 ] + DRAMTYPE_TABLE[ index ][ 1 ] +
+                       DRAMTYPE_TABLE[ index ][ 0 ] + XGINew_DataBusWidth / 64 + RankNo ) ;
+
+    Increment += Increment / 2 ;
+
+    Position = 0;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 0 ) ) = 0x01234567 ;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 1 ) ) = 0x456789AB ;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 2 ) ) = 0x55555555 ;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 3 ) ) = 0x55555555 ;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 4 ) ) = 0xAAAAAAAA ;
+    *( ( PULONG )( pVBInfo->FBAddr + Position + 5 ) ) = 0xAAAAAAAA ;
+
+    if ( ( *( PULONG )( pVBInfo->FBAddr + 1 ) ) == 0x456789AB )
+        return( 1 ) ;
+
+    if ( ( *( PULONG )( pVBInfo->FBAddr + 0 ) ) == 0x01234567 )
+        return( 0 ) ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) ;
+    data &= 0xF3 ;
+    data |= 0x0E ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , data ) ;
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x15 ) ;
+    data += 0x20 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x15 , data ) ;
+
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckRanks */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckRanks( int RankNo , int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    int r ;
+
+    for( r = RankNo ; r >= 1 ; r-- )
+    {
+        if ( !XGINew_CheckRank( r , index , DRAMTYPE_TABLE, pVBInfo ) )
+            return( 0 ) ;
+    }
+
+    if ( !XGINew_CheckBanks( index , DRAMTYPE_TABLE, pVBInfo ) )
+        return( 0 ) ;
+
+    if ( !XGINew_CheckColumn( index , DRAMTYPE_TABLE, pVBInfo ) )
+        return( 0 ) ;
+
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckDDRRanks */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_CheckDDRRanks( int RankNo , int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    int r ;
+
+    for( r = RankNo ; r >= 1 ; r-- )
+    {
+        if ( !XGINew_CheckDDRRank( r , index , DRAMTYPE_TABLE, pVBInfo ) )
+            return( 0 ) ;
+    }
+
+    if ( !XGINew_CheckBanks( index , DRAMTYPE_TABLE, pVBInfo ) )
+        return( 0 ) ;
+
+    if ( !XGINew_CheckColumn( index , DRAMTYPE_TABLE, pVBInfo ) )
+        return( 0 ) ;
+
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_SDRSizing(PVB_DEVICE_INFO pVBInfo)
+{
+    int    i ;
+    UCHAR  j ;
+
+    for( i = 0 ; i < 13 ; i++ )
+    {
+        XGINew_SetDRAMSizingType( i , XGINew_SDRDRAM_TYPE , pVBInfo) ;
+
+        for( j = 2 ; j > 0 ; j-- )
+        {
+            if ( !XGINew_SetRank( i , ( UCHAR )j , XGINew_ChannelAB , XGINew_SDRDRAM_TYPE , pVBInfo) )
+                continue ;
+            else
+            {
+                if ( XGINew_CheckRanks( j , i , XGINew_SDRDRAM_TYPE, pVBInfo) )
+                    return( 1 ) ;
+            }
+        }
+    }
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMSizeReg */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGINew_SetDRAMSizeReg( int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data = 0 , memsize = 0 ;
+    int RankSize ;
+    UCHAR ChannelNo ;
+
+    RankSize = DRAMTYPE_TABLE[ index ][ 3 ] * XGINew_DataBusWidth / 32 ;
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x13 ) ;
+    data &= 0x80 ;
+
+    if ( data == 0x80 )
+        RankSize *= 2 ;
+
+    data = 0 ;
+
+    if( XGINew_ChannelAB == 3 )
+        ChannelNo = 4 ;
+    else
+        ChannelNo = XGINew_ChannelAB ;
+
+    if ( ChannelNo * RankSize <= 256 )
+    {
+        while( ( RankSize >>= 1 ) > 0 )
+        {
+            data += 0x10 ;
+        }
+
+        memsize = data >> 4 ;
+
+        /* [2004/03/25] Vicent, Fix DRAM Sizing Error */
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , ( XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) & 0x0F ) | ( data & 0xF0 ) ) ;
+
+       /* data |= XGINew_ChannelAB << 2 ; */
+       /* data |= ( XGINew_DataBusWidth / 64 ) << 1 ; */
+       /* XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , data ) ; */
+
+        /* should delay */
+        /* XGINew_SetDRAMModeRegister340( pVBInfo ) ; */
+    }
+    return( memsize ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMSize20Reg */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGINew_SetDRAMSize20Reg( int index , USHORT DRAMTYPE_TABLE[][ 5 ], PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data = 0 , memsize = 0 ;
+    int RankSize ;
+    UCHAR ChannelNo ;
+
+    RankSize = DRAMTYPE_TABLE[ index ][ 3 ] * XGINew_DataBusWidth / 8 ;
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x13 ) ;
+    data &= 0x80 ;
+
+    if ( data == 0x80 )
+        RankSize *= 2 ;
+
+    data = 0 ;
+
+    if( XGINew_ChannelAB == 3 )
+        ChannelNo = 4 ;
+    else
+        ChannelNo = XGINew_ChannelAB ;
+
+    if ( ChannelNo * RankSize <= 256 )
+    {
+        while( ( RankSize >>= 1 ) > 0 )
+        {
+            data += 0x10 ;
+        }
+
+        memsize = data >> 4 ;
+
+        /* [2004/03/25] Vicent, Fix DRAM Sizing Error */
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , ( XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) & 0x0F ) | ( data & 0xF0 ) ) ;
+	DelayUS( 15 ) ;
+
+       /* data |= XGINew_ChannelAB << 2 ; */
+       /* data |= ( XGINew_DataBusWidth / 64 ) << 1 ; */
+       /* XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , data ) ; */
+
+        /* should delay */
+        /* XGINew_SetDRAMModeRegister340( pVBInfo ) ; */
+    }
+    return( memsize ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_ReadWriteRest */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_ReadWriteRest( USHORT StopAddr , USHORT StartAddr, PVB_DEVICE_INFO pVBInfo)
+{
+    int i ;
+    ULONG Position = 0 ;
+
+   *( ( PULONG )( pVBInfo->FBAddr + Position ) ) = Position ;
+
+    for( i = StartAddr ; i <= StopAddr ; i++ )
+    {
+        Position = 1 << i ;
+        *( ( PULONG )( pVBInfo->FBAddr + Position ) ) = Position ;
+    }
+
+    DelayUS( 500 ) ;	/* [Vicent] 2004/04/16. Fix #1759 Memory Size error in Multi-Adapter. */
+
+    Position = 0 ;
+
+   if ( ( *( PULONG )( pVBInfo->FBAddr + Position ) ) != Position )
+        return( 0 ) ;
+
+    for( i = StartAddr ; i <= StopAddr ; i++ )
+    {
+        Position = 1 << i ;
+        if ( ( *( PULONG )( pVBInfo->FBAddr + Position ) ) != Position )
+            return( 0 ) ;
+    }
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckFrequence */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGINew_CheckFrequence( PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR data ;
+
+    data = XGINew_GetReg1( pVBInfo->P3d4 , 0x97 ) ;
+
+    if ( ( data & 0x10 ) == 0 )
+    {
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x39 ) ;
+        data = ( data & 0x02 ) >> 1 ;
+        return( data ) ;
+    }
+    else
+        return( data & 0x01 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_CheckChannel */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_CheckChannel( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR data;
+
+    switch( HwDeviceExtension->jChipType )
+    {
+      case XG20:
+      case XG21:
+          data = XGINew_GetReg1( pVBInfo->P3d4 , 0x97 ) ;
+          data = data & 0x01;
+          XGINew_ChannelAB = 1 ;		/* XG20 "JUST" one channel */
+
+          if ( data == 0 )  /* Single_32_16 */
+          {
+
+	      if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x1000000)
+	      {
+
+                XGINew_DataBusWidth = 32 ;	/* 32 bits */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xB1 ) ;  /* 22bit + 2 rank + 32bit */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x52 ) ;
+		DelayUS( 15 ) ;
+
+                if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                    return ;
+
+		if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x800000)
+		{
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x31 ) ;  /* 22bit + 1 rank + 32bit */
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x42 ) ;
+		  DelayUS( 15 ) ;
+
+                  if ( XGINew_ReadWriteRest( 23 , 23 , pVBInfo ) == 1 )
+                      return ;
+                }
+	      }
+
+	      if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x800000)
+	      {
+	        XGINew_DataBusWidth = 16 ;	/* 16 bits */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xB1 ) ;  /* 22bit + 2 rank + 16bit */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x41 ) ;
+		DelayUS( 15 ) ;
+
+                if ( XGINew_ReadWriteRest( 23 , 22 , pVBInfo ) == 1 )
+                    return ;
+                else
+                    XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x31 ) ;
+                    DelayUS( 15 ) ;
+              }
+
+          }
+          else  /* Dual_16_8 */
+          {
+              if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x800000)
+              {
+
+                XGINew_DataBusWidth = 16 ;	/* 16 bits */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xB1 ) ;  /* (0x31:12x8x2) 22bit + 2 rank */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x41 ) ;  /* 0x41:16Mx16 bit*/
+                DelayUS( 15 ) ;
+
+                if ( XGINew_ReadWriteRest( 23 , 22 , pVBInfo ) == 1 )
+                    return ;
+
+		if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x400000)
+		{
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x31 ) ;  /* (0x31:12x8x2) 22bit + 1 rank */
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x31 ) ;  /* 0x31:8Mx16 bit*/
+                  DelayUS( 15 ) ;
+
+                  if ( XGINew_ReadWriteRest( 22 , 22 , pVBInfo ) == 1 )
+                      return ;
+                }
+	      }
+
+
+	      if (( HwDeviceExtension->ulVideoMemorySize - 1 ) > 0x400000)
+	      {
+	        XGINew_DataBusWidth = 8 ;	/* 8 bits */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xB1 ) ;  /* (0x31:12x8x2) 22bit + 2 rank */
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x30 ) ;  /* 0x30:8Mx8 bit*/
+                DelayUS( 15 ) ;
+
+                if ( XGINew_ReadWriteRest( 22 , 21 , pVBInfo ) == 1 )
+                    return ;
+                else
+                    XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x31 ) ;  /* (0x31:12x8x2) 22bit + 1 rank */
+                    DelayUS( 15 ) ;
+              }
+          }
+          break ;
+
+      case XG27:
+          XGINew_DataBusWidth = 16 ;	/* 16 bits */
+          XGINew_ChannelAB = 1 ;		/* Single channel */
+          XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x51 ) ;  /* 32Mx16 bit*/
+          break ;
+      case XG41:
+          if ( XGINew_CheckFrequence(pVBInfo) == 1 )
+          {
+              XGINew_DataBusWidth = 32 ;	/* 32 bits */
+              XGINew_ChannelAB = 3 ;		/* Quad Channel */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x4C ) ;
+
+              if ( XGINew_ReadWriteRest( 25 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 2 ;		/* Dual channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x48 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x49 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 3 ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x3C ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x38 ) ;
+
+              if ( XGINew_ReadWriteRest( 8 , 4 , pVBInfo ) == 1 )
+                  return ;
+              else
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x39 ) ;
+          }
+          else
+          {					/* DDR */
+              XGINew_DataBusWidth = 64 ;	/* 64 bits */
+              XGINew_ChannelAB = 2 ;		/* Dual channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x5A ) ;
+
+              if ( XGINew_ReadWriteRest( 25 , 24 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 1 ;		/* Single channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x52 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x53 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 2 ;		/* Dual channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x4A ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 1 ;		/* Single channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x42 ) ;
+
+              if ( XGINew_ReadWriteRest( 8 , 4 , pVBInfo ) == 1 )
+                  return ;
+              else
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x43 ) ;
+          }
+
+          break ;
+
+      case XG42:
+/*
+      	  XG42 SR14 D[3] Reserve
+      	  	    D[2] = 1, Dual Channel
+      	  	         = 0, Single Channel
+
+      	  It's Different from Other XG40 Series.
+*/
+          if ( XGINew_CheckFrequence(pVBInfo) == 1 )	/* DDRII, DDR2x */
+          {
+              XGINew_DataBusWidth = 32 ;	/* 32 bits */
+              XGINew_ChannelAB = 2 ;		/* 2 Channel */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x44 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x34 ) ;
+              if ( XGINew_ReadWriteRest( 23 , 22 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 1 ;		/* Single Channel */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x40 ) ;
+
+              if ( XGINew_ReadWriteRest( 23 , 22 , pVBInfo ) == 1 )
+                  return ;
+              else
+              {
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x30 ) ;
+              }
+          }
+          else
+          {					/* DDR */
+              XGINew_DataBusWidth = 64 ;	/* 64 bits */
+              XGINew_ChannelAB = 1 ;		/* 1 channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x52 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+              else
+              {
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x42 ) ;
+              }
+          }
+
+          break ;
+
+      default:	/* XG40 */
+
+          if ( XGINew_CheckFrequence(pVBInfo) == 1 )	/* DDRII */
+          {
+              XGINew_DataBusWidth = 32 ;	/* 32 bits */
+              XGINew_ChannelAB = 3 ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x4C ) ;
+
+              if ( XGINew_ReadWriteRest( 25 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_ChannelAB = 2 ;		/* 2 channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x48 ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  return ;
+
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x3C ) ;
+
+              if ( XGINew_ReadWriteRest( 24 , 23 , pVBInfo ) == 1 )
+                  XGINew_ChannelAB = 3 ;	/* 4 channels */
+              else
+              {
+                  XGINew_ChannelAB = 2 ;	/* 2 channels */
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x38 ) ;
+              }
+          }
+          else
+          {					/* DDR */
+              XGINew_DataBusWidth = 64 ;	/* 64 bits */
+              XGINew_ChannelAB = 2 ;		/* 2 channels */
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0xA1 ) ;
+              XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x5A ) ;
+
+              if ( XGINew_ReadWriteRest( 25 , 24 , pVBInfo ) == 1 )
+                  return ;
+              else
+              {
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x13 , 0x21 ) ;
+                  XGINew_SetReg1( pVBInfo->P3c4 , 0x14 , 0x4A ) ;
+              }
+          }
+      	  break ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDRSizing340 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_DDRSizing340( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    int i ;
+    USHORT memsize , addr ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x15 , 0x00 ) ;	/* noninterleaving */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1C , 0x00 ) ;	/* nontiling */
+    XGINew_CheckChannel( HwDeviceExtension, pVBInfo ) ;
+
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+    {
+      for( i = 0 ; i < 12 ; i++ )
+      {
+        XGINew_SetDRAMSizingType( i , XGINew_DDRDRAM_TYPE20, pVBInfo ) ;
+        memsize = XGINew_SetDRAMSize20Reg( i , XGINew_DDRDRAM_TYPE20, pVBInfo ) ;
+        if ( memsize == 0 )
+            continue ;
+
+        addr = memsize + ( XGINew_ChannelAB - 2 ) + 20 ;
+        if ( ( HwDeviceExtension->ulVideoMemorySize - 1 ) < ( ULONG )( 1 << addr ) )
+            continue ;
+
+        if ( XGINew_ReadWriteRest( addr , 5, pVBInfo ) == 1 )
+            return( 1 ) ;
+      }
+    }
+    else
+    {
+      for( i = 0 ; i < 4 ; i++ )
+      {
+    	XGINew_SetDRAMSizingType( i , XGINew_DDRDRAM_TYPE340, pVBInfo ) ;
+        memsize = XGINew_SetDRAMSizeReg( i , XGINew_DDRDRAM_TYPE340, pVBInfo ) ;
+
+        if ( memsize == 0 )
+            continue ;
+
+        addr = memsize + ( XGINew_ChannelAB - 2 ) + 20 ;
+        if ( ( HwDeviceExtension->ulVideoMemorySize - 1 ) < ( ULONG )( 1 << addr ) )
+            continue ;
+
+        if ( XGINew_ReadWriteRest( addr , 9, pVBInfo ) == 1 )
+            return( 1 ) ;
+      }
+    }
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDRSizing */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int XGINew_DDRSizing(PVB_DEVICE_INFO pVBInfo)
+{
+    int    i ;
+    UCHAR  j ;
+
+    for( i = 0 ; i < 4 ; i++ )
+    {
+        XGINew_SetDRAMSizingType( i , XGINew_DDRDRAM_TYPE, pVBInfo ) ;
+        XGINew_DisableChannelInterleaving( i , XGINew_DDRDRAM_TYPE , pVBInfo) ;
+        for( j = 2 ; j > 0 ; j-- )
+        {
+            XGINew_SetDDRChannel( i , j , XGINew_ChannelAB , XGINew_DDRDRAM_TYPE , pVBInfo ) ;
+            if ( !XGINew_SetRank( i , ( UCHAR )j , XGINew_ChannelAB , XGINew_DDRDRAM_TYPE, pVBInfo ) )
+                continue ;
+            else
+            {
+                if ( XGINew_CheckDDRRanks( j , i , XGINew_DDRDRAM_TYPE,  pVBInfo ) )
+                return( 1 ) ;
+            }
+        }
+    }
+    return( 0 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetMemoryClock */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetMemoryClock( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x28 , pVBInfo->MCLKData[ XGINew_RAMType ].SR28 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x29 , pVBInfo->MCLKData[ XGINew_RAMType ].SR29 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2A , pVBInfo->MCLKData[ XGINew_RAMType ].SR2A ) ;
+
+
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , pVBInfo->ECLKData[ XGINew_RAMType ].SR2E ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , pVBInfo->ECLKData[ XGINew_RAMType ].SR2F ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x30 , pVBInfo->ECLKData[ XGINew_RAMType ].SR30 ) ;
+
+    /* [Vicent] 2004/07/07, When XG42 ECLK = MCLK = 207MHz, Set SR32 D[1:0] = 10b */
+    /* [Hsuan] 2004/08/20, Modify SR32 value, when MCLK=207MHZ, ELCK=250MHz, Set SR32 D[1:0] = 10b */
+    if ( HwDeviceExtension->jChipType == XG42 )
+    {
+      if ( ( pVBInfo->MCLKData[ XGINew_RAMType ].SR28 == 0x1C ) && ( pVBInfo->MCLKData[ XGINew_RAMType ].SR29 == 0x01 )
+        && ( ( ( pVBInfo->ECLKData[ XGINew_RAMType ].SR2E == 0x1C ) && ( pVBInfo->ECLKData[ XGINew_RAMType ].SR2F == 0x01 ) )
+        || ( ( pVBInfo->ECLKData[ XGINew_RAMType ].SR2E == 0x22 ) && ( pVBInfo->ECLKData[ XGINew_RAMType ].SR2F == 0x01 ) ) ) )
+      {
+      	XGINew_SetReg1( pVBInfo->P3c4 , 0x32 , ( ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x32 ) & 0xFC ) | 0x02 ) ;
+      }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : ChkLFB */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN ChkLFB( PVB_DEVICE_INFO pVBInfo )
+{
+    if ( LFBDRAMTrap & XGINew_GetReg1( pVBInfo->P3d4 , 0x78 ) )
+        return( TRUE ) ;
+    else
+        return( FALSE );
+}
+
+
+/* --------------------------------------------------------------------- */
+/* input : dx ,valid value : CR or second chip's CR */
+/*  */
+/* SetPowerConsume : */
+/* Description: reduce 40/43 power consumption in first chip or */
+/* in second chip, assume CR A1 D[6]="1" in this case */
+/* output : none */
+/* --------------------------------------------------------------------- */
+void SetPowerConsume ( PXGI_HW_DEVICE_INFO HwDeviceExtension , ULONG XGI_P3d4Port )
+{
+    ULONG   lTemp ;
+    UCHAR   bTemp;
+
+    HwDeviceExtension->pQueryVGAConfigSpace( HwDeviceExtension , 0x08 , 0 , &lTemp ) ; /* Get */
+    if ((lTemp&0xFF)==0)
+    {
+        /* set CR58 D[5]=0 D[3]=0 */
+        XGINew_SetRegAND( XGI_P3d4Port , 0x58 , 0xD7 ) ;
+        bTemp = (UCHAR) XGINew_GetReg1( XGI_P3d4Port , 0xCB ) ;
+    	if (bTemp&0x20)
+    	{
+            if (!(bTemp&0x10))
+            {
+            	XGINew_SetRegANDOR( XGI_P3d4Port , 0x58 , 0xD7 , 0x20 ) ; /* CR58 D[5]=1 D[3]=0 */
+            }
+            else
+            {
+            	XGINew_SetRegANDOR( XGI_P3d4Port , 0x58 , 0xD7 , 0x08 ) ; /* CR58 D[5]=0 D[3]=1 */
+            }
+
+    	}
+
+    }
+}
+
+
+
+#if defined(LINUX_XF86)||defined(LINUX_KERNEL)
+void XGINew_InitVBIOSData(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+
+	/* ULONG ROMAddr = (ULONG)HwDeviceExtension->pjVirtualRomBase; */
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+    pVBInfo->BaseAddr = (ULONG)HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ISXPDOS = 0 ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+    if ( HwDeviceExtension->jChipType < XG20 )                  /* kuku 2004/06/25 */
+    XGI_GetVBType( pVBInfo ) ;         /* Run XGI_GetVBType before InitTo330Pointer */
+
+	switch(HwDeviceExtension->jChipType)
+	{
+	case XG40:
+	case XG41:
+	case XG42:
+	case XG20:
+	case XG21:
+	default:
+		InitTo330Pointer(HwDeviceExtension->jChipType,pVBInfo);
+		return ;
+	}
+
+}
+#endif /* For Linux */
+
+/* --------------------------------------------------------------------- */
+/* Function : ReadVBIOSTablData */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void ReadVBIOSTablData( UCHAR ChipType , PVB_DEVICE_INFO pVBInfo)
+{
+    PUCHAR  volatile pVideoMemory = ( PUCHAR )pVBInfo->ROMAddr ;
+    ULONG   i ;
+    UCHAR   j , k ;
+#if 0
+    ULONG   ii , jj ;
+    i = pVideoMemory[ 0x1CF ] | ( pVideoMemory[ 0x1D0 ] << 8 ) ;		/* UniROM */
+    if ( i != 0 )
+        UNIROM = 1 ;
+
+    ii = 0x90 ;
+    for( jj = 0x00 ; jj < 0x08 ; jj++ )
+    {
+        pVBInfo->MCLKData[ jj ].SR28 = pVideoMemory[ ii ] ;
+        pVBInfo->MCLKData[ jj ].SR29 = pVideoMemory[ ii + 1] ;
+        pVBInfo->MCLKData[ jj ].SR2A = pVideoMemory[ ii + 2] ;
+        pVBInfo->MCLKData[ jj ].CLOCK = pVideoMemory[ ii + 3 ] | ( pVideoMemory[ ii + 4 ] << 8 ) ;
+        ii += 0x05 ;
+    }
+
+    ii = 0xB8 ;
+    for( jj = 0x00 ; jj < 0x08 ; jj++ )
+    {
+        pVBInfo->ECLKData[ jj ].SR2E = pVideoMemory[ ii ] ;
+        pVBInfo->ECLKData[ jj ].SR2F=pVideoMemory[ ii + 1 ] ;
+        pVBInfo->ECLKData[ jj ].SR30= pVideoMemory[ ii + 2 ] ;
+        pVBInfo->ECLKData[ jj ].CLOCK= pVideoMemory[ ii + 3 ] | ( pVideoMemory[ ii + 4 ] << 8 ) ;
+        ii += 0x05 ;
+    }
+
+    /* Volari customize data area start */
+    /* if ( ChipType == XG40 ) */
+    if ( ChipType >= XG40 )
+    {
+        ii = 0xE0 ;
+        for( jj = 0x00 ; jj < 0x03 ; jj++ )
+        {
+            pVBInfo->SR15[ jj ][ 0 ] = pVideoMemory[ ii ] ;		/* SR13, SR14, and SR18 */
+            pVBInfo->SR15[ jj ][ 1 ] = pVideoMemory[ ii + 1 ] ;
+            pVBInfo->SR15[ jj ][ 2 ] = pVideoMemory[ ii + 2 ] ;
+            pVBInfo->SR15[ jj ][ 3 ] = pVideoMemory[ ii + 3 ] ;
+            pVBInfo->SR15[ jj ][ 4 ] = pVideoMemory[ ii + 4 ] ;
+            pVBInfo->SR15[ jj ][ 5 ] = pVideoMemory[ ii + 5 ] ;
+            pVBInfo->SR15[ jj ][ 6 ] = pVideoMemory[ ii + 6 ] ;
+            pVBInfo->SR15[ jj ][ 7 ] = pVideoMemory[ ii + 7 ] ;
+            ii += 0x08 ;
+        }
+        ii = 0x110 ;
+        jj = 0x03 ;
+        pVBInfo->SR15[ jj ][ 0 ] = pVideoMemory[ ii ] ;		/* SR1B */
+        pVBInfo->SR15[ jj ][ 1 ] = pVideoMemory[ ii + 1 ] ;
+        pVBInfo->SR15[ jj ][ 2 ] = pVideoMemory[ ii + 2 ] ;
+        pVBInfo->SR15[ jj ][ 3 ] = pVideoMemory[ ii + 3 ] ;
+        pVBInfo->SR15[ jj ][ 4 ] = pVideoMemory[ ii + 4 ] ;
+        pVBInfo->SR15[ jj ][ 5 ] = pVideoMemory[ ii + 5 ] ;
+        pVBInfo->SR15[ jj ][ 6 ] = pVideoMemory[ ii + 6 ] ;
+        pVBInfo->SR15[ jj ][ 7 ] = pVideoMemory[ ii + 7 ] ;
+
+        *pVBInfo->pSR07 = pVideoMemory[ 0x74 ] ;
+        *pVBInfo->pSR1F = pVideoMemory[ 0x75 ] ;
+        *pVBInfo->pSR21 = pVideoMemory[ 0x76 ] ;
+        *pVBInfo->pSR22 = pVideoMemory[ 0x77 ] ;
+        *pVBInfo->pSR23 = pVideoMemory[ 0x78 ] ;
+        *pVBInfo->pSR24 = pVideoMemory[ 0x79 ] ;
+        pVBInfo->SR25[ 0 ] = pVideoMemory[ 0x7A ] ;
+        *pVBInfo->pSR31 = pVideoMemory[ 0x7B ] ;
+        *pVBInfo->pSR32 = pVideoMemory[ 0x7C ] ;
+        *pVBInfo->pSR33 = pVideoMemory[ 0x7D ] ;
+        ii = 0xF8 ;
+
+        for( jj = 0 ; jj < 3 ; jj++ )
+        {
+            pVBInfo->CR40[ jj ][ 0 ] = pVideoMemory[ ii ] ;
+            pVBInfo->CR40[ jj ][ 1 ] = pVideoMemory[ ii + 1 ] ;
+            pVBInfo->CR40[ jj ][ 2 ] = pVideoMemory[ ii + 2 ] ;
+            pVBInfo->CR40[ jj ][ 3 ] = pVideoMemory[ ii + 3 ] ;
+            pVBInfo->CR40[ jj ][ 4 ] = pVideoMemory[ ii + 4 ] ;
+            pVBInfo->CR40[ jj ][ 5 ] = pVideoMemory[ ii + 5 ] ;
+            pVBInfo->CR40[ jj ][ 6 ] = pVideoMemory[ ii + 6 ] ;
+            pVBInfo->CR40[ jj ][ 7 ] = pVideoMemory[ ii + 7 ] ;
+            ii += 0x08 ;
+        }
+
+        ii = 0x118 ;
+        for( j = 3 ; j < 24 ; j++ )
+        {
+            pVBInfo->CR40[ j ][ 0 ] = pVideoMemory[ ii ] ;
+            pVBInfo->CR40[ j ][ 1 ] = pVideoMemory[ ii + 1 ] ;
+            pVBInfo->CR40[ j ][ 2 ] = pVideoMemory[ ii + 2 ] ;
+            pVBInfo->CR40[ j ][ 3 ] = pVideoMemory[ ii + 3 ] ;
+            pVBInfo->CR40[ j ][ 4 ] = pVideoMemory[ ii + 4 ] ;
+            pVBInfo->CR40[ j ][ 5 ] = pVideoMemory[ ii + 5 ] ;
+            pVBInfo->CR40[ j ][ 6 ] = pVideoMemory[ ii + 6 ] ;
+            pVBInfo->CR40[ j ][ 7 ] = pVideoMemory[ ii + 7 ] ;
+            ii += 0x08 ;
+        }
+
+        i = pVideoMemory[ 0x1C0 ] | ( pVideoMemory[ 0x1C1 ] << 8 ) ;
+
+        for( j = 0 ; j < 8 ; j++ )
+        {
+            for( k = 0 ; k < 4 ; k++ )
+                pVBInfo->CR6B[ j ][ k ] = pVideoMemory[ i + 4 * j + k ] ;
+        }
+
+        i = pVideoMemory[ 0x1C2 ] | ( pVideoMemory[ 0x1C3 ] << 8 ) ;
+
+        for( j = 0 ; j < 8 ; j++ )
+        {
+            for( k = 0 ; k < 4 ; k++ )
+                pVBInfo->CR6E[ j ][ k ] = pVideoMemory[ i + 4 * j + k ] ;
+        }
+
+        i = pVideoMemory[ 0x1C4 ] | ( pVideoMemory[ 0x1C5 ] << 8 ) ;
+        for( j = 0 ; j < 8 ; j++ )
+        {
+            for( k = 0 ; k < 32 ; k++ )
+                pVBInfo->CR6F[ j ][ k ] = pVideoMemory[ i + 32 * j + k ] ;
+        }
+
+        i = pVideoMemory[ 0x1C6 ] | ( pVideoMemory[ 0x1C7 ] << 8 ) ;
+
+        for( j = 0 ; j < 8 ; j++ )
+        {
+            for( k = 0 ; k < 2 ; k++ )
+                pVBInfo->CR89[ j ][ k ] = pVideoMemory[ i + 2 * j + k ] ;
+        }
+
+        i = pVideoMemory[ 0x1C8 ] | ( pVideoMemory[ 0x1C9 ] << 8 ) ;
+        for( j = 0 ; j < 12 ; j++ )
+            pVBInfo->AGPReg[ j ] = pVideoMemory[ i + j ] ;
+
+        i = pVideoMemory[ 0x1CF ] | ( pVideoMemory[ 0x1D0 ] << 8 ) ;
+        for( j = 0 ; j < 4 ; j++ )
+            pVBInfo->SR16[ j ] = pVideoMemory[ i + j ] ;
+
+        if ( ChipType == XG21 )
+        {
+            if (pVideoMemory[ 0x67 ] & 0x80)
+            {
+                *pVBInfo->pDVOSetting = pVideoMemory[ 0x67 ];
+            }
+            if ( (pVideoMemory[ 0x67 ] & 0xC0) == 0xC0 )
+            {
+                *pVBInfo->pCR2E = pVideoMemory[ i + 4 ] ;
+                *pVBInfo->pCR2F = pVideoMemory[ i + 5 ] ;
+                *pVBInfo->pCR46 = pVideoMemory[ i + 6 ] ;
+                *pVBInfo->pCR47 = pVideoMemory[ i + 7 ] ;
+            }
+        }
+
+        if ( ChipType == XG27 )
+        {
+            jj = i+j;
+            for( i = 0 ; i <= 0xB ; i++,jj++ )
+              pVBInfo->pCRD0[i] = pVideoMemory[ jj ] ;
+            for( i = 0x0 ; i <= 0x1 ; i++,jj++ )
+              pVBInfo->pCRDE[i] = pVideoMemory[ jj ] ;
+
+            *pVBInfo->pSR40 = pVideoMemory[ jj ] ;
+            jj++;
+            *pVBInfo->pSR41 = pVideoMemory[ jj ] ;
+
+            if (pVideoMemory[ 0x67 ] & 0x80)
+            {
+                *pVBInfo->pDVOSetting = pVideoMemory[ 0x67 ];
+            }
+            if ( (pVideoMemory[ 0x67 ] & 0xC0) == 0xC0 )
+            {
+                jj++;
+                *pVBInfo->pCR2E = pVideoMemory[ jj ] ;
+                *pVBInfo->pCR2F = pVideoMemory[ jj + 1 ] ;
+                *pVBInfo->pCR46 = pVideoMemory[ jj + 2 ] ;
+                *pVBInfo->pCR47 = pVideoMemory[ jj + 3 ] ;
+            }
+
+        }
+
+        *pVBInfo->pCRCF = pVideoMemory[ 0x1CA ] ;
+        *pVBInfo->pXGINew_DRAMTypeDefinition = pVideoMemory[ 0x1CB ] ;
+        *pVBInfo->pXGINew_I2CDefinition = pVideoMemory[ 0x1D1 ] ;
+        if ( ChipType >= XG20 )
+        {
+           *pVBInfo->pXGINew_CR97 = pVideoMemory[ 0x1D2 ] ;
+           if ( ChipType == XG27 )
+           {
+             *pVBInfo->pSR36 = pVideoMemory[ 0x1D3 ] ;
+             *pVBInfo->pCR8F = pVideoMemory[ 0x1D5 ] ;
+           }
+        }
+
+    }
+#endif
+    /* Volari customize data area end */
+
+    if ( ChipType == XG21 )
+    {
+        pVBInfo->IF_DEF_LVDS = 0 ;
+        if (pVideoMemory[ 0x65 ] & 0x1)
+        {
+            pVBInfo->IF_DEF_LVDS = 1 ;
+            i = pVideoMemory[ 0x316 ] | ( pVideoMemory[ 0x317 ] << 8 );
+            j = pVideoMemory[ i-1 ] ;
+            if ( j != 0xff )
+            {
+              k = 0;
+              do
+              {
+                pVBInfo->XG21_LVDSCapList[k].LVDS_Capability = pVideoMemory[ i ] | ( pVideoMemory[ i + 1 ] << 8 );
+                pVBInfo->XG21_LVDSCapList[k].LVDSHT = pVideoMemory[ i + 2 ] | ( pVideoMemory[ i + 3 ] << 8 ) ;
+                pVBInfo->XG21_LVDSCapList[k].LVDSVT = pVideoMemory[ i + 4 ] | ( pVideoMemory[ i + 5 ] << 8 );
+                pVBInfo->XG21_LVDSCapList[k].LVDSHDE = pVideoMemory[ i + 6 ] | ( pVideoMemory[ i + 7 ] << 8 );
+                pVBInfo->XG21_LVDSCapList[k].LVDSVDE = pVideoMemory[ i + 8 ] | ( pVideoMemory[ i + 9 ] << 8 );
+                pVBInfo->XG21_LVDSCapList[k].LVDSHFP = pVideoMemory[ i + 10 ] | ( pVideoMemory[ i + 11 ] << 8 );
+                pVBInfo->XG21_LVDSCapList[k].LVDSVFP = pVideoMemory[ i + 12 ] | ( pVideoMemory[ i + 13 ] << 8 );
+                pVBInfo->XG21_LVDSCapList[k].LVDSHSYNC = pVideoMemory[ i + 14 ] | ( pVideoMemory[ i + 15 ] << 8 );
+                pVBInfo->XG21_LVDSCapList[k].LVDSVSYNC = pVideoMemory[ i + 16 ] | ( pVideoMemory[ i + 17 ] << 8 );
+                pVBInfo->XG21_LVDSCapList[k].VCLKData1 = pVideoMemory[ i + 18 ] ;
+                pVBInfo->XG21_LVDSCapList[k].VCLKData2 = pVideoMemory[ i + 19 ] ;
+                pVBInfo->XG21_LVDSCapList[k].PSC_S1 = pVideoMemory[ i + 20 ] ;
+                pVBInfo->XG21_LVDSCapList[k].PSC_S2 = pVideoMemory[ i + 21 ] ;
+                pVBInfo->XG21_LVDSCapList[k].PSC_S3 = pVideoMemory[ i + 22 ] ;
+                pVBInfo->XG21_LVDSCapList[k].PSC_S4 = pVideoMemory[ i + 23 ] ;
+                pVBInfo->XG21_LVDSCapList[k].PSC_S5 = pVideoMemory[ i + 24 ] ;
+                i += 25;
+                j--;
+                k++;
+              } while ( (j>0) && ( k < (sizeof(XGI21_LCDCapList)/sizeof(XGI21_LVDSCapStruct)) ) );
+            }
+            else
+            {
+            pVBInfo->XG21_LVDSCapList[0].LVDS_Capability = pVideoMemory[ i ] | ( pVideoMemory[ i + 1 ] << 8 );
+            pVBInfo->XG21_LVDSCapList[0].LVDSHT = pVideoMemory[ i + 2 ] | ( pVideoMemory[ i + 3 ] << 8 ) ;
+            pVBInfo->XG21_LVDSCapList[0].LVDSVT = pVideoMemory[ i + 4 ] | ( pVideoMemory[ i + 5 ] << 8 );
+            pVBInfo->XG21_LVDSCapList[0].LVDSHDE = pVideoMemory[ i + 6 ] | ( pVideoMemory[ i + 7 ] << 8 );
+            pVBInfo->XG21_LVDSCapList[0].LVDSVDE = pVideoMemory[ i + 8 ] | ( pVideoMemory[ i + 9 ] << 8 );
+            pVBInfo->XG21_LVDSCapList[0].LVDSHFP = pVideoMemory[ i + 10 ] | ( pVideoMemory[ i + 11 ] << 8 );
+            pVBInfo->XG21_LVDSCapList[0].LVDSVFP = pVideoMemory[ i + 12 ] | ( pVideoMemory[ i + 13 ] << 8 );
+            pVBInfo->XG21_LVDSCapList[0].LVDSHSYNC = pVideoMemory[ i + 14 ] | ( pVideoMemory[ i + 15 ] << 8 );
+            pVBInfo->XG21_LVDSCapList[0].LVDSVSYNC = pVideoMemory[ i + 16 ] | ( pVideoMemory[ i + 17 ] << 8 );
+            pVBInfo->XG21_LVDSCapList[0].VCLKData1 = pVideoMemory[ i + 18 ] ;
+            pVBInfo->XG21_LVDSCapList[0].VCLKData2 = pVideoMemory[ i + 19 ] ;
+            pVBInfo->XG21_LVDSCapList[0].PSC_S1 = pVideoMemory[ i + 20 ] ;
+            pVBInfo->XG21_LVDSCapList[0].PSC_S2 = pVideoMemory[ i + 21 ] ;
+            pVBInfo->XG21_LVDSCapList[0].PSC_S3 = pVideoMemory[ i + 22 ] ;
+            pVBInfo->XG21_LVDSCapList[0].PSC_S4 = pVideoMemory[ i + 23 ] ;
+            pVBInfo->XG21_LVDSCapList[0].PSC_S5 = pVideoMemory[ i + 24 ] ;
+        }
+        }
+    }
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_DDR1x_MRS_XG20 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_DDR1x_MRS_XG20( ULONG P3c4 , PVB_DEVICE_INFO pVBInfo)
+{
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x01 ) ;
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+    DelayUS( 60 ) ;
+
+    XGINew_SetReg1( P3c4 , 0x18 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x19 , 0x40 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x80 ) ;
+    DelayUS( 60 ) ;
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    /* XGINew_SetReg1( P3c4 , 0x18 , 0x31 ) ; */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x01 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x03 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x83 ) ;
+    DelayUS( 1000 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x03 ) ;
+    DelayUS( 500 ) ;
+    /* XGINew_SetReg1( P3c4 , 0x18 , 0x31 ) ; */
+    XGINew_SetReg1( P3c4 , 0x18 , pVBInfo->SR15[ 2 ][ XGINew_RAMType ] ) ;	/* SR18 */
+    XGINew_SetReg1( P3c4 , 0x19 , 0x00 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x03 ) ;
+    XGINew_SetReg1( P3c4 , 0x16 , 0x83 ) ;
+    XGINew_SetReg1( P3c4 , 0x1B , 0x00 ) ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetDRAMModeRegister_XG20 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetDRAMModeRegister_XG20( PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+    pVBInfo->BaseAddr = (ULONG)HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ISXPDOS = 0 ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    InitTo330Pointer(HwDeviceExtension->jChipType,pVBInfo);
+
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+
+    if ( XGINew_GetXG20DRAMType( HwDeviceExtension, pVBInfo) == 0 )
+        XGINew_DDR1x_MRS_XG20( pVBInfo->P3c4, pVBInfo ) ;
+    else
+        XGINew_DDR2_MRS_XG20( HwDeviceExtension , pVBInfo->P3c4 , pVBInfo ) ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , 0x03 ) ;
+}
+
+void XGINew_SetDRAMModeRegister_XG27( PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+    pVBInfo->BaseAddr = (ULONG)HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ISXPDOS = 0 ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    InitTo330Pointer(HwDeviceExtension->jChipType,pVBInfo);
+
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+
+    if ( XGINew_GetXG20DRAMType( HwDeviceExtension, pVBInfo) == 0 )
+        XGINew_DDR1x_MRS_XG20( pVBInfo->P3c4, pVBInfo ) ;
+    else
+        //XGINew_DDR2_MRS_XG27( HwDeviceExtension , pVBInfo->P3c4 , pVBInfo ) ;
+        XGINew_DDRII_Bootup_XG27( HwDeviceExtension , pVBInfo->P3c4 , pVBInfo) ;
+
+    //XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , 0x03 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , pVBInfo->SR15[ 3 ][ XGINew_RAMType ] ) ;	/* SR1B */
+
+}
+/*
+void XGINew_SetDRAMModeRegister_XG27( PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+#ifndef LINUX_XF86
+    UCHAR data ;
+#endif
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ;
+    pVBInfo->BaseAddr = HwDeviceExtension->pjIOAddress ;
+    pVBInfo->ISXPDOS = 0 ;
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    InitTo330Pointer(HwDeviceExtension->jChipType,pVBInfo);
+
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+
+    if ( XGINew_GetXG20DRAMType( HwDeviceExtension, pVBInfo) == 0 )
+        XGINew_DDR1x_MRS_XG20( pVBInfo->P3c4, pVBInfo ) ;
+    else
+        XGINew_DDR2_MRS_XG27( HwDeviceExtension , pVBInfo->P3c4 , pVBInfo ) ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1B , 0x03 ) ;
+}
+*/
+/* -------------------------------------------------------- */
+/* Function : XGINew_ChkSenseStatus */
+/* Input : */
+/* Output : */
+/* Description : */
+/* -------------------------------------------------------- */
+void XGINew_ChkSenseStatus ( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx=0 , temp , tempcx , CR3CData;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x32 ) ;
+
+    if ( temp & Monitor1Sense )
+    	tempbx |= ActiveCRT1 ;
+    if ( temp & LCDSense )
+    	tempbx |= ActiveLCD ;
+    if ( temp & Monitor2Sense )
+    	tempbx |= ActiveCRT2 ;
+    if ( temp & TVSense )
+    {
+    	tempbx |= ActiveTV ;
+    	if ( temp & AVIDEOSense )
+    	    tempbx |= ( ActiveAVideo << 8 );
+    	if ( temp & SVIDEOSense )
+    	    tempbx |= ( ActiveSVideo << 8 );
+    	if ( temp & SCARTSense )
+    	    tempbx |= ( ActiveSCART << 8 );
+    	if ( temp & HiTVSense )
+    	    tempbx |= ( ActiveHiTV << 8 );
+    	if ( temp & YPbPrSense )
+    	    tempbx |= ( ActiveYPbPr << 8 );
+    }
+
+    tempcx = XGINew_GetReg1( pVBInfo->P3d4 , 0x3d ) ;
+    tempcx |= ( XGINew_GetReg1( pVBInfo->P3d4 , 0x3e ) << 8 ) ;
+
+    if ( tempbx & tempcx )
+    {
+    	CR3CData = XGINew_GetReg1( pVBInfo->P3d4 , 0x3c ) ;
+    	if ( !( CR3CData & DisplayDeviceFromCMOS ) )
+    	{
+    	    tempcx = 0x1FF0 ;
+    	    if ( *pVBInfo->pSoftSetting & ModeSoftSetting )
+    	    {
+    	    	tempbx = 0x1FF0 ;
+    	    }
+    	}
+    }
+    else
+    {
+    	tempcx = 0x1FF0 ;
+    	if ( *pVBInfo->pSoftSetting & ModeSoftSetting )
+    	{
+    	    tempbx = 0x1FF0 ;
+    	}
+    }
+
+    tempbx &= tempcx ;
+    XGINew_SetReg1( pVBInfo->P3d4, 0x3d , ( tempbx & 0x00FF ) ) ;
+    XGINew_SetReg1( pVBInfo->P3d4, 0x3e , ( ( tempbx & 0xFF00 ) >> 8 )) ;
+}
+/* -------------------------------------------------------- */
+/* Function : XGINew_SetModeScratch */
+/* Input : */
+/* Output : */
+/* Description : */
+/* -------------------------------------------------------- */
+void XGINew_SetModeScratch ( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT temp , tempcl = 0 , tempch = 0 , CR31Data , CR38Data;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x3d ) ;
+    temp |= XGINew_GetReg1( pVBInfo->P3d4 , 0x3e ) << 8 ;
+    temp |= ( XGINew_GetReg1( pVBInfo->P3d4 , 0x31 ) & ( DriverMode >> 8) ) << 8 ;
+
+    if ( pVBInfo->IF_DEF_CRT2Monitor == 1)
+    {
+    	if ( temp & ActiveCRT2 )
+    	   tempcl = SetCRT2ToRAMDAC ;
+    }
+
+    if ( temp & ActiveLCD )
+    {
+    	tempcl |= SetCRT2ToLCD ;
+    	if  ( temp & DriverMode )
+    	{
+    	    if ( temp & ActiveTV )
+    	    {
+    	    	tempch = SetToLCDA | EnableDualEdge ;
+    	    	temp ^= SetCRT2ToLCD ;
+
+    	    	if ( ( temp >> 8 ) & ActiveAVideo )
+    	    	    tempcl |= SetCRT2ToAVIDEO ;
+    	    	if ( ( temp >> 8 ) & ActiveSVideo )
+    	    	    tempcl |= SetCRT2ToSVIDEO ;
+    	    	if ( ( temp >> 8 ) & ActiveSCART )
+    	    	    tempcl |= SetCRT2ToSCART ;
+
+    	    	if ( pVBInfo->IF_DEF_HiVision == 1 )
+    	    	{
+    	    	    if ( ( temp >> 8 ) & ActiveHiTV )
+    	    	    tempcl |= SetCRT2ToHiVisionTV ;
+    	    	}
+
+    	    	if ( pVBInfo->IF_DEF_YPbPr == 1 )
+    	    	{
+    	    	    if ( ( temp >> 8 ) & ActiveYPbPr )
+    	    	    tempch |= SetYPbPr ;
+    	    	}
+    	    }
+    	}
+    }
+    else
+    {
+    	if ( ( temp >> 8 ) & ActiveAVideo )
+    	   tempcl |= SetCRT2ToAVIDEO ;
+    	if ( ( temp >> 8 ) & ActiveSVideo )
+  	   tempcl |= SetCRT2ToSVIDEO ;
+    	if ( ( temp >> 8 ) & ActiveSCART )
+   	   tempcl |= SetCRT2ToSCART ;
+
+   	if ( pVBInfo->IF_DEF_HiVision == 1 )
+    	{
+    	   if ( ( temp >> 8 ) & ActiveHiTV )
+    	   tempcl |= SetCRT2ToHiVisionTV ;
+    	}
+
+    	if ( pVBInfo->IF_DEF_YPbPr == 1 )
+    	{
+    	   if ( ( temp >> 8 ) & ActiveYPbPr )
+    	   tempch |= SetYPbPr ;
+    	}
+    }
+
+
+    tempcl |= SetSimuScanMode ;
+    if ( (!( temp & ActiveCRT1 )) && ( ( temp & ActiveLCD ) || ( temp & ActiveTV ) || ( temp & ActiveCRT2 ) ) )
+       tempcl ^= ( SetSimuScanMode | SwitchToCRT2 ) ;
+    if ( ( temp & ActiveLCD ) && ( temp & ActiveTV ) )
+       tempcl ^= ( SetSimuScanMode | SwitchToCRT2 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4, 0x30 , tempcl ) ;
+
+    CR31Data = XGINew_GetReg1( pVBInfo->P3d4 , 0x31 ) ;
+    CR31Data &= ~( SetNotSimuMode >> 8 ) ;
+    if ( !( temp & ActiveCRT1 ) )
+        CR31Data |= ( SetNotSimuMode >> 8 ) ;
+    CR31Data &= ~( DisableCRT2Display >> 8 ) ;
+    if  (!( ( temp & ActiveLCD ) || ( temp & ActiveTV ) || ( temp & ActiveCRT2 ) ) )
+        CR31Data |= ( DisableCRT2Display >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4, 0x31 , CR31Data ) ;
+
+    CR38Data = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+    CR38Data &= ~SetYPbPr ;
+    CR38Data |= tempch ;
+    XGINew_SetReg1( pVBInfo->P3d4, 0x38 , CR38Data ) ;
+
+}
+
+/* -------------------------------------------------------- */
+/* Function : XGINew_GetXG21Sense */
+/* Input : */
+/* Output : */
+/* Description : */
+/* -------------------------------------------------------- */
+void XGINew_GetXG21Sense(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR Temp;
+    PUCHAR  volatile pVideoMemory = ( PUCHAR )pVBInfo->ROMAddr ;
+
+    pVBInfo->IF_DEF_LVDS = 0 ;
+
+#ifdef WIN2000
+   pVBInfo->IF_DEF_CH7007 = 0 ;
+    if ( ( pVideoMemory[ 0x65 ] & 0x02 ) )			/* For XG21 CH7007 */
+    {
+        /* VideoDebugPrint((0, "ReadVBIOSTablData: pVideoMemory[ 0x65 ] =%x\n",pVideoMemory[ 0x65 ])); */
+        pVBInfo->IF_DEF_CH7007 = 1 ;                            /* [Billy] 07/05/03 */
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0x60 ) ; /* CH7007 on chip */
+    }
+    else
+#endif
+#if 1
+    if (( pVideoMemory[ 0x65 ] & 0x01 ) )			/* For XG21 LVDS */
+    {
+        pVBInfo->IF_DEF_LVDS = 1 ;
+        XGINew_SetRegOR( pVBInfo->P3d4 , 0x32 , LCDSense ) ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0xC0 ) ; /* LVDS on chip */
+    }
+    else
+    {
+#endif
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x4A , ~0x03 , 0x03 ) ; /* Enable GPIOA/B read  */
+        Temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) & 0xC0;
+        if ( Temp == 0xC0 )
+        {								/* DVI & DVO GPIOA/B pull high */
+          XGINew_SenseLCD( HwDeviceExtension, pVBInfo ) ;
+          XGINew_SetRegOR( pVBInfo->P3d4 , 0x32 , LCDSense ) ;
+          XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x4A , ~0x20 , 0x20 ) ;   /* Enable read GPIOF */
+          Temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) & 0x04 ;
+          if ( !Temp )
+            XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0x80 ) ; /* TMDS on chip */
+          else
+            XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0xA0 ) ; /* Only DVO on chip */
+          XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x20 ) ;	    /* Disable read GPIOF */
+        }
+#if 1
+    }
+#endif
+}
+
+/* -------------------------------------------------------- */
+/* Function : XGINew_GetXG27Sense */
+/* Input : */
+/* Output : */
+/* Description : */
+/* -------------------------------------------------------- */
+void XGINew_GetXG27Sense(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR Temp,bCR4A;
+
+     pVBInfo->IF_DEF_LVDS = 0 ;
+     bCR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+     XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x4A , ~0x07 , 0x07 ) ; /* Enable GPIOA/B/C read  */
+     Temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) & 0x07;
+     XGINew_SetReg1( pVBInfo->P3d4, 0x4A , bCR4A ) ;
+
+     if ( Temp <= 0x02 )
+     {
+         pVBInfo->IF_DEF_LVDS = 1 ;
+         XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0xC0 ) ; /* LVDS setting */
+         XGINew_SetReg1( pVBInfo->P3d4, 0x30 , 0x21 ) ;
+     }
+     else
+     {
+       XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x38 , ~0xE0 , 0xA0 ) ; /* TMDS/DVO setting */
+     }
+     XGINew_SetRegOR( pVBInfo->P3d4 , 0x32 , LCDSense ) ;
+
+}
+
+UCHAR GetXG21FPBits(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR38,CR4A,temp;
+
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x4A , ~0x10 , 0x10 ) ; /* enable GPIOE read */
+    CR38 = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+    temp =0;
+    if ( ( CR38 & 0xE0 ) > 0x80 )
+    {
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;
+        temp &= 0x08;
+        temp >>= 3;
+    }
+
+    XGINew_SetReg1( pVBInfo->P3d4, 0x4A , CR4A ) ;
+
+    return temp;
+}
+
+UCHAR GetXG27FPBits(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR4A,temp;
+
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x4A , ~0x03 , 0x03 ) ; /* enable GPIOA/B/C read */
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;
+    if ( temp <= 2 )
+    {
+    	temp &= 0x03;
+    }
+    else
+    {
+    	temp = ((temp&0x04)>>1) || ((~temp)&0x01);
+    }
+    XGINew_SetReg1( pVBInfo->P3d4, 0x4A , CR4A ) ;
+
+    return temp;
+}
+
--- /dev/null
+++ b/drivers/staging/xgifb/vb_init.h
@@ -0,0 +1,7 @@
+#ifndef  _VBINIT_
+#define  _VBINIT_
+extern   BOOLEAN    XGIInitNew( PXGI_HW_DEVICE_INFO HwDeviceExtension ) ;
+extern XGI21_LVDSCapStruct  XGI21_LCDCapList[13];
+
+#endif
+
--- /dev/null
+++ b/drivers/staging/xgifb/vb_setmode.c
@@ -0,0 +1,10736 @@
+#include "osdef.h"
+
+#ifdef TC
+#include <stdio.h>
+#include <string.h>
+#include <conio.h>
+#include <dos.h>
+#endif
+
+
+#ifdef LINUX_XF86
+#include "xf86.h"
+#include "xf86PciInfo.h"
+#include "xgi.h"
+#include "xgi_regs.h"
+#endif
+
+#ifdef LINUX_KERNEL
+#include <asm/io.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include "XGIfb.h"
+/*#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <video/XGIfb.h>
+#else
+#include <linux/XGIfb.h>
+#endif*/
+#endif
+
+#ifdef WIN2000
+#include <dderror.h>
+#include <devioctl.h>
+#include <miniport.h>
+#include <ntddvdeo.h>
+#include <video.h>
+
+#include "xgiv.h"
+#include "dd_i2c.h"
+#include "tools.h"
+#endif
+
+#include "vb_def.h"
+#include "vgatypes.h"
+#include "vb_struct.h"
+#include "vb_util.h"
+#include "vb_table.h"
+
+
+
+#define  IndexMask 0xff
+#ifndef XGI_MASK_DUAL_CHIP
+#define XGI_MASK_DUAL_CHIP	  0x04  /* SR3A */
+#endif
+
+
+
+BOOLEAN  XGI_IsLCDDualLink(PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_SetCRT2Group301(USHORT ModeNo, PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_BacklightByDrv(PVB_DEVICE_INFO pVBInfo);
+
+BOOLEAN  XGI_IsLCDON(PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_DisableChISLCD(PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_EnableChISLCD(PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_AjustCRT2Rate(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,USHORT *i, PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_SearchModeID( USHORT ModeNo,USHORT  *ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_GetLCDInfo(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGISetModeNew( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo ) ;
+BOOLEAN  XGI_BridgeIsOn(PVB_DEVICE_INFO pVBInfo);
+UCHAR    XGI_GetModePtr( USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetOffset(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetRatePtrCRT2( PXGI_HW_DEVICE_INFO pXGIHWDE, USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo );
+USHORT   XGI_GetResInfo(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetColorDepth(USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetVGAHT2(PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetVCLK2Ptr(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo);
+void     XGI_VBLongWait(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SaveCRT2Info(USHORT ModeNo, PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetCRT2Data(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetCRT2ResInfo(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_PreSetGroup1(USHORT ModeNo,USHORT ModeIdIndex, PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetGroup1(USHORT ModeNo,USHORT ModeIdIndex, PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetLockRegs(USHORT ModeNo,USHORT ModeIdIndex, PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetLCDRegs(USHORT ModeNo,USHORT ModeIdIndex, PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetGroup2(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetGroup3(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetGroup4(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetGroup5(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void*    XGI_GetLcdPtr(USHORT BX,  USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void*    XGI_GetTVPtr(USHORT BX, USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_FirePWDEnable(PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_EnableGatingCRT(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_DisableGatingCRT(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_SetPanelDelay(USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_SetPanelPower(USHORT tempah,USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_EnablePWD( PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_DisablePWD( PVB_DEVICE_INFO pVBInfo);
+void     XGI_AutoThreshold( PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetTap4Regs( PVB_DEVICE_INFO pVBInfo);
+
+void     XGI_DisplayOn(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo);
+void     XGI_DisplayOff( PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo );
+void     XGI_SetCRT1Group(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetXG21CRTC(USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetXG21LCD(PVB_DEVICE_INFO pVBInfo,USHORT RefreshRateTableIndex,USHORT ModeNo);
+void     XGI_SetXG27CRTC(USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetXG27LCD(PVB_DEVICE_INFO pVBInfo,USHORT RefreshRateTableIndex,USHORT ModeNo);
+void	 XGI_UpdateXG21CRTC(USHORT ModeNo, PVB_DEVICE_INFO pVBInfo, USHORT RefreshRateTableIndex);
+void     XGI_WaitDisply(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SenseCRT1(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetSeqRegs(USHORT ModeNo,USHORT StandTableIndex,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetMiscRegs(USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRTCRegs(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetATTRegs(USHORT ModeNo,USHORT StandTableIndex,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo );
+void     XGI_SetGRCRegs(USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_ClearExt1Regs(PVB_DEVICE_INFO pVBInfo);
+
+void     XGI_SetSync(USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1CRTC(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo,PXGI_HW_DEVICE_INFO HwDeviceExtension);
+void     XGI_SetCRT1Timing_H(PVB_DEVICE_INFO pVBInfo,PXGI_HW_DEVICE_INFO HwDeviceExtension);
+void     XGI_SetCRT1Timing_V(USHORT ModeIdIndex,USHORT ModeNo,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1DE(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1VCLK(USHORT ModeNo,USHORT ModeIdIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1FIFO(USHORT ModeNo,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1ModeRegs(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetVCLKState(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo);
+
+void     XGI_LoadDAC(USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo);
+void     XGI_WriteDAC(USHORT dl, USHORT ah, USHORT al, USHORT dh, PVB_DEVICE_INFO pVBInfo);
+/*void     XGI_ClearBuffer(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,PVB_DEVICE_INFO pVBInfo);*/
+void     XGI_SetLCDAGroup(USHORT ModeNo,USHORT ModeIdIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetLVDSResInfo( USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetLVDSData(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_ModCRT1Regs(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_SetLVDSRegs(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_UpdateModeInfo(PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetVGAType(PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetVBType(PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetVBInfo(USHORT ModeNo,USHORT ModeIdIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_GetTVInfo(USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO  pVBInfo);
+void     XGI_SetCRT2ECLK( USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PVB_DEVICE_INFO  pVBInfo);
+void     InitTo330Pointer(UCHAR,PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetLCDSync(USHORT* HSyncWidth, USHORT* VSyncWidth, PVB_DEVICE_INFO pVBInfo);
+void 	 XGI_DisableBridge(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void  	 XGI_EnableBridge(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT2VCLK(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_OEM310Setting(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetDelayComp(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetLCDCap(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetLCDCap_A(USHORT tempcx,PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetLCDCap_B(USHORT tempcx,PVB_DEVICE_INFO pVBInfo);
+void     SetSpectrum(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetAntiFlicker(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetEdgeEnhance(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetPhaseIncr(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetYFilter(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetTVPtrIndex2(USHORT* tempbx,UCHAR* tempcl,UCHAR* tempch, PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetTVPtrIndex(  PVB_DEVICE_INFO pVBInfo );
+void     XGI_SetCRT2ModeRegs(USHORT ModeNo,PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo );
+void     XGI_CloseCRTC(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo);
+void     XGI_OpenCRTC(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetRAMDAC2DATA(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_UnLockCRT2(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo);
+void     XGI_LockCRT2(PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO pVBInfo);
+void     XGINew_EnableCRT2(PVB_DEVICE_INFO pVBInfo);
+void     XGINew_LCD_Wait_Time(UCHAR DelayTime, PVB_DEVICE_INFO pVBInfo);
+void     XGI_LongWait(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetCRT1Offset( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo );
+void     XGI_GetLCDVCLKPtr(UCHAR* di_0,UCHAR *di_1, PVB_DEVICE_INFO pVBInfo);
+UCHAR    XGI_GetVCLKPtr(USHORT RefreshRateTableIndex,USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+void     XGI_GetVCLKLen(UCHAR tempal,UCHAR* di_0,UCHAR* di_1, PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetLCDCapPtr(PVB_DEVICE_INFO pVBInfo);
+USHORT   XGI_GetLCDCapPtr1(PVB_DEVICE_INFO pVBInfo);
+XGI301C_Tap4TimingStruct* XGI_GetTap4Ptr(USHORT tempcx, PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetXG21FPBits(PVB_DEVICE_INFO pVBInfo);
+void     XGI_SetXG27FPBits(PVB_DEVICE_INFO pVBInfo);
+UCHAR    XGI_XG21GetPSCValue(PVB_DEVICE_INFO pVBInfo);
+UCHAR    XGI_XG27GetPSCValue(PVB_DEVICE_INFO pVBInfo);
+void     XGI_XG21BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+void     XGI_XG27BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+void     XGI_XG21SetPanelDelay(USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+BOOLEAN  XGI_XG21CheckLVDSMode(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo );
+void     XGI_SetXG21LVDSPara(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo );
+void     XGI_SetXG27LVDSPara(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo );
+UCHAR    XGI_SetDefaultVCLK( PVB_DEVICE_INFO pVBInfo );
+
+extern   void 	  ReadVBIOSTablData( UCHAR ChipType , PVB_DEVICE_INFO pVBInfo);
+#ifdef WIN2000
+/* [Billy] 2007/05/17 For CH7007 */
+extern  UCHAR CH7007TVReg_UNTSC[][8],CH7007TVReg_ONTSC[][8],CH7007TVReg_UPAL[][8],CH7007TVReg_OPAL[][8];
+extern  UCHAR CH7007TVCRT1UNTSC_H[][10],CH7007TVCRT1ONTSC_H[][10],CH7007TVCRT1UPAL_H[][10],CH7007TVCRT1OPAL_H[][10] ;
+extern  UCHAR CH7007TVCRT1UNTSC_V[][10],CH7007TVCRT1ONTSC_V[][10],CH7007TVCRT1UPAL_V[][10],CH7007TVCRT1OPAL_V[][10] ;
+extern  UCHAR XGI7007_CHTVVCLKUNTSC[],XGI7007_CHTVVCLKONTSC[],XGI7007_CHTVVCLKUPAL[],XGI7007_CHTVVCLKOPAL[];
+
+extern  BOOLEAN XGI_XG21CheckCH7007TVMode(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo ) ;
+extern  void SetCH7007Regs(PXGI_HW_DEVICE_INFO HwDeviceExtension, USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO  pVBInfo ) ;
+extern  VP_STATUS TurnOnCH7007(PHW_DEVICE_EXTENSION pHWDE) ;
+extern  VP_STATUS TurnOffCH7007(PHW_DEVICE_EXTENSION pHWDE) ;
+extern  BOOLEAN IsCH7007TVMode(PVB_DEVICE_INFO pVBInfo) ;
+#endif
+
+/* USHORT XGINew_flag_clearbuffer; 0: no clear frame buffer 1:clear frame buffer */
+
+
+
+
+
+USHORT XGINew_MDA_DAC[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+               0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+               0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+               0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
+               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+               0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+               0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+               0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F};
+
+USHORT XGINew_CGA_DAC[]={0x00,0x10,0x04,0x14,0x01,0x11,0x09,0x15,
+               0x00,0x10,0x04,0x14,0x01,0x11,0x09,0x15,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F,
+               0x00,0x10,0x04,0x14,0x01,0x11,0x09,0x15,
+               0x00,0x10,0x04,0x14,0x01,0x11,0x09,0x15,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F};
+
+USHORT XGINew_EGA_DAC[]={0x00,0x10,0x04,0x14,0x01,0x11,0x05,0x15,
+               0x20,0x30,0x24,0x34,0x21,0x31,0x25,0x35,
+               0x08,0x18,0x0C,0x1C,0x09,0x19,0x0D,0x1D,
+               0x28,0x38,0x2C,0x3C,0x29,0x39,0x2D,0x3D,
+               0x02,0x12,0x06,0x16,0x03,0x13,0x07,0x17,
+               0x22,0x32,0x26,0x36,0x23,0x33,0x27,0x37,
+               0x0A,0x1A,0x0E,0x1E,0x0B,0x1B,0x0F,0x1F,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F};
+
+USHORT XGINew_VGA_DAC[]={0x00,0x10,0x04,0x14,0x01,0x11,0x09,0x15,
+               0x2A,0x3A,0x2E,0x3E,0x2B,0x3B,0x2F,0x3F,
+               0x00,0x05,0x08,0x0B,0x0E,0x11,0x14,0x18,
+               0x1C,0x20,0x24,0x28,0x2D,0x32,0x38,0x3F,
+
+               0x00,0x10,0x1F,0x2F,0x3F,0x1F,0x27,0x2F,
+               0x37,0x3F,0x2D,0x31,0x36,0x3A,0x3F,0x00,
+               0x07,0x0E,0x15,0x1C,0x0E,0x11,0x15,0x18,
+               0x1C,0x14,0x16,0x18,0x1A,0x1C,0x00,0x04,
+               0x08,0x0C,0x10,0x08,0x0A,0x0C,0x0E,0x10,
+               0x0B,0x0C,0x0D,0x0F,0x10};
+
+
+/* --------------------------------------------------------------------- */
+/* Function : InitTo330Pointer */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void InitTo330Pointer( UCHAR ChipType ,PVB_DEVICE_INFO pVBInfo)
+{
+    pVBInfo->SModeIDTable = (XGI_StStruct *) XGI330_SModeIDTable ;
+    pVBInfo->StandTable = (XGI_StandTableStruct *) XGI330_StandTable ;
+    pVBInfo->EModeIDTable = (XGI_ExtStruct *) XGI330_EModeIDTable ;
+    pVBInfo->RefIndex = (XGI_Ext2Struct *) XGI330_RefIndex ;
+    pVBInfo->XGINEWUB_CRT1Table = (XGI_CRT1TableStruct *) XGI_CRT1Table ;
+
+    /* add for new UNIVGABIOS */
+    /* XGINew_UBLCDDataTable = (XGI_LCDDataTablStruct *) XGI_LCDDataTable ; */
+    /* XGINew_UBTVDataTable = (XGI_TVDataTablStruct *) XGI_TVDataTable ; */
+
+
+    if ( ChipType >= XG40 )
+    {
+        pVBInfo->MCLKData = (XGI_MCLKDataStruct *) XGI340New_MCLKData ;
+        pVBInfo->ECLKData = (XGI_ECLKDataStruct *) XGI340_ECLKData ;
+    }
+    else
+    {
+        pVBInfo->MCLKData = (XGI_MCLKDataStruct *) XGI330New_MCLKData ;
+        pVBInfo->ECLKData = (XGI_ECLKDataStruct *) XGI330_ECLKData ;
+    }
+
+    pVBInfo->VCLKData = (XGI_VCLKDataStruct *) XGI_VCLKData ;
+    pVBInfo->VBVCLKData = (XGI_VBVCLKDataStruct *) XGI_VBVCLKData ;
+    pVBInfo->ScreenOffset = XGI330_ScreenOffset ;
+    pVBInfo->StResInfo = (XGI_StResInfoStruct *) XGI330_StResInfo ;
+    pVBInfo->ModeResInfo = (XGI_ModeResInfoStruct *) XGI330_ModeResInfo ;
+
+    pVBInfo->pOutputSelect = &XGI330_OutputSelect ;
+    pVBInfo->pSoftSetting = &XGI330_SoftSetting ;
+    pVBInfo->pSR07 = &XGI330_SR07 ;
+    pVBInfo->LCDResInfo = 0 ;
+    pVBInfo->LCDTypeInfo = 0 ;
+    pVBInfo->LCDInfo = 0 ;
+    pVBInfo->VBInfo = 0 ;
+    pVBInfo->TVInfo = 0;
+
+
+    pVBInfo->SR15 = XGI340_SR13 ;
+    pVBInfo->CR40 = XGI340_cr41 ;
+    pVBInfo->SR25 = XGI330_sr25 ;
+    pVBInfo->pSR31 = &XGI330_sr31 ;
+    pVBInfo->pSR32 = &XGI330_sr32 ;
+    pVBInfo->CR6B = XGI340_CR6B ;
+    pVBInfo->CR6E = XGI340_CR6E ;
+    pVBInfo->CR6F = XGI340_CR6F ;
+    pVBInfo->CR89 = XGI340_CR89 ;
+    pVBInfo->AGPReg = XGI340_AGPReg ;
+    pVBInfo->SR16 = XGI340_SR16 ;
+    pVBInfo->pCRCF = &XG40_CRCF ;
+    pVBInfo->pXGINew_DRAMTypeDefinition = &XG40_DRAMTypeDefinition ;
+
+
+    pVBInfo->CR49 = XGI330_CR49 ;
+    pVBInfo->pSR1F = &XGI330_SR1F ;
+    pVBInfo->pSR21 = &XGI330_SR21 ;
+    pVBInfo->pSR22 = &XGI330_SR22 ;
+    pVBInfo->pSR23 = &XGI330_SR23 ;
+    pVBInfo->pSR24 = &XGI330_SR24 ;
+    pVBInfo->pSR33 = &XGI330_SR33 ;
+
+
+
+    pVBInfo->pCRT2Data_1_2 = &XGI330_CRT2Data_1_2 ;
+    pVBInfo->pCRT2Data_4_D = &XGI330_CRT2Data_4_D ;
+    pVBInfo->pCRT2Data_4_E = &XGI330_CRT2Data_4_E ;
+    pVBInfo->pCRT2Data_4_10 = &XGI330_CRT2Data_4_10 ;
+    pVBInfo->pRGBSenseData = &XGI330_RGBSenseData ;
+    pVBInfo->pVideoSenseData = &XGI330_VideoSenseData ;
+    pVBInfo->pYCSenseData = &XGI330_YCSenseData ;
+    pVBInfo->pRGBSenseData2 = &XGI330_RGBSenseData2 ;
+    pVBInfo->pVideoSenseData2 = &XGI330_VideoSenseData2 ;
+    pVBInfo->pYCSenseData2 = &XGI330_YCSenseData2 ;
+
+    pVBInfo->NTSCTiming = XGI330_NTSCTiming ;
+    pVBInfo->PALTiming = XGI330_PALTiming ;
+    pVBInfo->HiTVExtTiming = XGI330_HiTVExtTiming ;
+    pVBInfo->HiTVSt1Timing = XGI330_HiTVSt1Timing ;
+    pVBInfo->HiTVSt2Timing = XGI330_HiTVSt2Timing ;
+    pVBInfo->HiTVTextTiming = XGI330_HiTVTextTiming ;
+    pVBInfo->YPbPr750pTiming = XGI330_YPbPr750pTiming ;
+    pVBInfo->YPbPr525pTiming = XGI330_YPbPr525pTiming ;
+    pVBInfo->YPbPr525iTiming = XGI330_YPbPr525iTiming ;
+    pVBInfo->HiTVGroup3Data = XGI330_HiTVGroup3Data ;
+    pVBInfo->HiTVGroup3Simu = XGI330_HiTVGroup3Simu ;
+    pVBInfo->HiTVGroup3Text = XGI330_HiTVGroup3Text ;
+    pVBInfo->Ren525pGroup3 = XGI330_Ren525pGroup3 ;
+    pVBInfo->Ren750pGroup3 = XGI330_Ren750pGroup3 ;
+
+
+    pVBInfo->TimingH = (XGI_TimingHStruct *) XGI_TimingH ;
+    pVBInfo->TimingV = (XGI_TimingVStruct *) XGI_TimingV ;
+    pVBInfo->UpdateCRT1 = (XGI_XG21CRT1Struct *) XGI_UpdateCRT1Table ;
+
+    pVBInfo->CHTVVCLKUNTSC = XGI330_CHTVVCLKUNTSC ;
+    pVBInfo->CHTVVCLKONTSC = XGI330_CHTVVCLKONTSC ;
+    pVBInfo->CHTVVCLKUPAL = XGI330_CHTVVCLKUPAL ;
+    pVBInfo->CHTVVCLKOPAL = XGI330_CHTVVCLKOPAL ;
+
+    /* 310 customization related */
+    if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+        pVBInfo->LCDCapList = XGI_LCDDLCapList ;
+    else
+        pVBInfo->LCDCapList = XGI_LCDCapList ;
+
+    if ( ( ChipType == XG21 ) || ( ChipType == XG27 ) )
+        pVBInfo->XG21_LVDSCapList = XGI21_LCDCapList ;
+
+    pVBInfo->XGI_TVDelayList = XGI301TVDelayList ;
+    pVBInfo->XGI_TVDelayList2 = XGI301TVDelayList2 ;
+
+
+    pVBInfo->pXGINew_I2CDefinition = &XG40_I2CDefinition ;
+
+    if ( ChipType >= XG20 )
+    	pVBInfo->pXGINew_CR97 = &XG20_CR97 ;
+
+    if ( ChipType == XG27 )
+    {
+        pVBInfo->MCLKData = (XGI_MCLKDataStruct *) XGI27New_MCLKData ;
+        pVBInfo->CR40 = XGI27_cr41 ;
+    	pVBInfo->pXGINew_CR97 = &XG27_CR97 ;
+    	pVBInfo->pSR36 = &XG27_SR36 ;
+    	pVBInfo->pCR8F = &XG27_CR8F ;
+    	pVBInfo->pCRD0 = XG27_CRD0 ;
+    	pVBInfo->pCRDE = XG27_CRDE ;
+    	pVBInfo->pSR40 = &XG27_SR40 ;
+    	pVBInfo->pSR41 = &XG27_SR41 ;
+
+    }
+
+    if ( ChipType >= XG20 )
+    {
+    	pVBInfo->pDVOSetting = &XG21_DVOSetting ;
+    	pVBInfo->pCR2E = &XG21_CR2E ;
+    	pVBInfo->pCR2F = &XG21_CR2F ;
+    	pVBInfo->pCR46 = &XG21_CR46 ;
+    	pVBInfo->pCR47 = &XG21_CR47 ;
+    }
+
+}
+
+
+
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGISetModeNew */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGISetModeNew( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo )
+{
+    USHORT ModeIdIndex ;
+        /* PUCHAR pVBInfo->FBAddr = HwDeviceExtension->pjVideoMemoryAddress ; */
+    VB_DEVICE_INFO VBINF;
+    PVB_DEVICE_INFO pVBInfo = &VBINF;
+    pVBInfo->ROMAddr = HwDeviceExtension->pjVirtualRomBase ;
+    pVBInfo->BaseAddr = (ULONG)HwDeviceExtension->pjIOAddress ;
+    pVBInfo->IF_DEF_LVDS = 0 ;
+    pVBInfo->IF_DEF_CH7005 = 0 ;
+    pVBInfo->IF_DEF_LCDA = 1 ;
+    pVBInfo->IF_DEF_CH7017 = 0 ;
+    pVBInfo->IF_DEF_CH7007 = 0 ;                                /* [Billy] 2007/05/14 */
+    pVBInfo->IF_DEF_VideoCapture = 0 ;
+    pVBInfo->IF_DEF_ScaleLCD = 0 ;
+    pVBInfo->IF_DEF_OEMUtil = 0 ;
+    pVBInfo->IF_DEF_PWD = 0 ;
+
+
+    if ( HwDeviceExtension->jChipType >= XG20 )			/* kuku 2004/06/25 */
+    {
+    	pVBInfo->IF_DEF_YPbPr = 0 ;
+        pVBInfo->IF_DEF_HiVision = 0 ;
+        pVBInfo->IF_DEF_CRT2Monitor = 0 ;
+        pVBInfo->VBType = 0 ;  /*set VBType default 0*/
+    }
+    else if ( HwDeviceExtension->jChipType >= XG40 )
+    {
+        pVBInfo->IF_DEF_YPbPr = 1 ;
+        pVBInfo->IF_DEF_HiVision = 1 ;
+        pVBInfo->IF_DEF_CRT2Monitor = 1 ;
+    }
+    else
+    {
+        pVBInfo->IF_DEF_YPbPr = 1 ;
+        pVBInfo->IF_DEF_HiVision = 1 ;
+        pVBInfo->IF_DEF_CRT2Monitor = 0 ;
+    }
+
+    pVBInfo->P3c4 = pVBInfo->BaseAddr + 0x14 ;
+    pVBInfo->P3d4 = pVBInfo->BaseAddr + 0x24 ;
+    pVBInfo->P3c0 = pVBInfo->BaseAddr + 0x10 ;
+    pVBInfo->P3ce = pVBInfo->BaseAddr + 0x1e ;
+    pVBInfo->P3c2 = pVBInfo->BaseAddr + 0x12 ;
+    pVBInfo->P3cc = pVBInfo->BaseAddr + 0x1C ;
+    pVBInfo->P3ca = pVBInfo->BaseAddr + 0x1a ;
+    pVBInfo->P3c6 = pVBInfo->BaseAddr + 0x16 ;
+    pVBInfo->P3c7 = pVBInfo->BaseAddr + 0x17 ;
+    pVBInfo->P3c8 = pVBInfo->BaseAddr + 0x18 ;
+    pVBInfo->P3c9 = pVBInfo->BaseAddr + 0x19 ;
+    pVBInfo->P3da = pVBInfo->BaseAddr + 0x2A ;
+    pVBInfo->Part0Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_00 ;
+    pVBInfo->Part1Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_04 ;
+    pVBInfo->Part2Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_10 ;
+    pVBInfo->Part3Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_12 ;
+    pVBInfo->Part4Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 ;
+    pVBInfo->Part5Port = pVBInfo->BaseAddr + XGI_CRT2_PORT_14 + 2 ;
+
+    if ( HwDeviceExtension->jChipType == XG21 )  /* for x86 Linux, XG21 LVDS */
+    {
+        if ( ( XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) & 0xE0 ) == 0xC0 )
+        {
+            pVBInfo->IF_DEF_LVDS = 1 ;
+        }
+    }
+    if ( HwDeviceExtension->jChipType == XG27 )
+    {
+        if ( ( XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) & 0xE0 ) == 0xC0 )
+        {
+          if ( XGINew_GetReg1( pVBInfo->P3d4 , 0x30 ) & 0x20 )
+          {
+            pVBInfo->IF_DEF_LVDS = 1 ;
+          }
+        }
+    }
+
+    if ( HwDeviceExtension->jChipType < XG20 )			/* kuku 2004/06/25 */
+    XGI_GetVBType( pVBInfo ) ;
+
+    InitTo330Pointer( HwDeviceExtension->jChipType, pVBInfo ) ;
+#ifdef WIN2000
+    ReadVBIOSTablData( HwDeviceExtension->jChipType , pVBInfo) ;
+#endif
+    if ( ModeNo & 0x80 )
+    {
+        ModeNo = ModeNo & 0x7F ;
+/* XGINew_flag_clearbuffer = 0 ; */
+    }
+/*    else
+    {
+        XGINew_flag_clearbuffer = 1 ;
+    }
+*/
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x05 , 0x86 ) ;
+
+    if ( HwDeviceExtension->jChipType < XG20 )			/* kuku 2004/06/25 1.Openkey */
+    XGI_UnLockCRT2( HwDeviceExtension , pVBInfo ) ;
+
+    XGI_SearchModeID( ModeNo , &ModeIdIndex, pVBInfo ) ;
+
+    XGI_GetVGAType(HwDeviceExtension,  pVBInfo) ;
+
+    if ( HwDeviceExtension->jChipType < XG20 )			/* kuku 2004/06/25 */
+    {
+        XGI_GetVBInfo(ModeNo , ModeIdIndex , HwDeviceExtension, pVBInfo ) ;
+        XGI_GetTVInfo(ModeNo , ModeIdIndex, pVBInfo ) ;
+        XGI_GetLCDInfo(ModeNo , ModeIdIndex, pVBInfo ) ;
+        XGI_DisableBridge( HwDeviceExtension,pVBInfo ) ;
+/*        XGI_OpenCRTC( HwDeviceExtension, pVBInfo ) ; */
+
+        if ( pVBInfo->VBInfo & ( SetSimuScanMode | SetCRT2ToLCDA ) )
+        {
+            XGI_SetCRT1Group(HwDeviceExtension , ModeNo , ModeIdIndex, pVBInfo ) ;
+
+            if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+            {
+                XGI_SetLCDAGroup(ModeNo , ModeIdIndex , HwDeviceExtension, pVBInfo ) ;
+            }
+        }
+        else
+        {
+            if ( !( pVBInfo->VBInfo & SwitchToCRT2) )
+            {
+                XGI_SetCRT1Group( HwDeviceExtension , ModeNo , ModeIdIndex, pVBInfo ) ;
+                if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                {
+                    XGI_SetLCDAGroup( ModeNo , ModeIdIndex , HwDeviceExtension, pVBInfo ) ;
+                }
+            }
+        }
+
+        if ( pVBInfo->VBInfo & ( SetSimuScanMode | SwitchToCRT2 ) )
+        {
+            switch( HwDeviceExtension->ujVBChipID )
+            {
+                case VB_CHIP_301:
+                    XGI_SetCRT2Group301( ModeNo , HwDeviceExtension, pVBInfo ) ;		/*add for CRT2 */
+                    break ;
+
+                case VB_CHIP_302:
+                    XGI_SetCRT2Group301(ModeNo , HwDeviceExtension, pVBInfo ) ;		/*add for CRT2 */
+                    break ;
+
+                default:
+                    break ;
+            }
+        }
+
+        XGI_SetCRT2ModeRegs( ModeNo, HwDeviceExtension,pVBInfo ) ;
+        XGI_OEM310Setting( ModeNo, ModeIdIndex,pVBInfo ) ; /*0212*/
+        XGI_CloseCRTC( HwDeviceExtension, pVBInfo ) ;
+        XGI_EnableBridge( HwDeviceExtension ,pVBInfo) ;
+    }	/* !XG20 */
+    else
+    {
+#ifdef WIN2000
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+
+            VideoDebugPrint((0, "XGISetModeNew: pVBIfo->IF_DEF_CH7007==1\n"));
+            pVBInfo->VBType = VB_CH7007 ;
+            XGI_GetVBInfo(ModeNo , ModeIdIndex , HwDeviceExtension, pVBInfo ) ;
+            XGI_GetTVInfo(ModeNo , ModeIdIndex, pVBInfo ) ;
+            XGI_GetLCDInfo(ModeNo , ModeIdIndex, pVBInfo ) ;
+            if( !(XGI_XG21CheckCH7007TVMode(ModeNo, ModeIdIndex, pVBInfo )) )
+            {
+              return FALSE;
+            }
+        }
+#endif
+
+
+        if ( pVBInfo->IF_DEF_LVDS == 1 )
+        {
+            if ( !XGI_XG21CheckLVDSMode(ModeNo , ModeIdIndex, pVBInfo) )
+            {
+              return FALSE;
+            }
+        }
+
+        if ( ModeNo <= 0x13 )
+        {
+            pVBInfo->ModeType = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag & ModeInfoFlag;
+        }
+        else
+        {
+            pVBInfo->ModeType = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag & ModeInfoFlag;
+        }
+
+    	pVBInfo->SetFlag = 0 ;
+        if ( pVBInfo->IF_DEF_CH7007 != 1 )
+        {
+    	    pVBInfo->VBInfo = DisableCRT2Display ;
+        }
+
+
+    	XGI_DisplayOff(HwDeviceExtension, pVBInfo) ;
+
+    	XGI_SetCRT1Group(HwDeviceExtension , ModeNo , ModeIdIndex, pVBInfo ) ;
+
+    	XGI_DisplayOn( HwDeviceExtension, pVBInfo ) ;
+    	/*
+    	if( HwDeviceExtension->jChipType == XG21 )
+    	  XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x09 , ~0x80 , 0x80 ) ;
+    	*/
+    }
+
+
+/*
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+    pVBInfo->ModeType = modeflag&ModeInfoFlag ;
+    pVBInfo->SetFlag = 0x00 ;
+    pVBInfo->VBInfo = DisableCRT2Display ;
+    temp = XGINew_CheckMemorySize(  HwDeviceExtension , ModeNo , ModeIdIndex, pVBInfo ) ;
+
+    if ( temp == 0 )
+        return( 0 ) ;
+
+    XGI_DisplayOff( HwDeviceExtension, pVBInfo) ;
+    XGI_SetCRT1Group( HwDeviceExtension , ModeNo , ModeIdIndex, pVBInfo ) ;
+    XGI_DisplayOn( HwDeviceExtension, pVBInfo) ;
+*/
+
+    XGI_UpdateModeInfo( HwDeviceExtension, pVBInfo ) ;
+
+    if ( HwDeviceExtension->jChipType < XG20 )			/* kuku 2004/06/25 */
+{
+    XGI_LockCRT2( HwDeviceExtension, pVBInfo ) ;
+}
+
+    return( TRUE ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1Group */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1Group( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT StandTableIndex ,
+           RefreshRateTableIndex ,
+           b3CC ,
+           temp ;
+
+    USHORT XGINew_P3cc =  pVBInfo->P3cc;
+
+    /* XGINew_CRT1Mode = ModeNo ; // SaveModeID */
+    StandTableIndex = XGI_GetModePtr( ModeNo , ModeIdIndex, pVBInfo ) ;
+    /* XGI_SetBIOSData(ModeNo , ModeIdIndex ) ; */
+    /* XGI_ClearBankRegs( ModeNo , ModeIdIndex ) ; */
+    XGI_SetSeqRegs( ModeNo , StandTableIndex , ModeIdIndex, pVBInfo ) ;
+    XGI_SetMiscRegs( StandTableIndex,  pVBInfo ) ;
+    XGI_SetCRTCRegs( HwDeviceExtension , StandTableIndex,  pVBInfo) ;
+    XGI_SetATTRegs( ModeNo , StandTableIndex , ModeIdIndex, pVBInfo ) ;
+    XGI_SetGRCRegs(  StandTableIndex, pVBInfo ) ;
+    XGI_ClearExt1Regs(pVBInfo) ;
+
+/* if ( pVBInfo->IF_DEF_ExpLink ) */
+    if ( HwDeviceExtension->jChipType == XG27 )
+    {
+      if ( pVBInfo->IF_DEF_LVDS == 0 )
+      {
+        XGI_SetDefaultVCLK( pVBInfo ) ;
+      }
+    }
+
+    temp = ~ProgrammingCRT2 ;
+    pVBInfo->SetFlag &= temp ;
+    pVBInfo->SelectCRT2Rate = 0 ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->VBInfo & ( SetSimuScanMode | SetCRT2ToLCDA | SetInSlaveMode ) )
+        {
+            pVBInfo->SetFlag |= ProgrammingCRT2 ;
+         }
+    }
+
+    RefreshRateTableIndex = XGI_GetRatePtrCRT2( HwDeviceExtension, ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( RefreshRateTableIndex != 0xFFFF )
+    {
+        XGI_SetSync( RefreshRateTableIndex, pVBInfo ) ;
+        XGI_SetCRT1CRTC( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo, HwDeviceExtension ) ;
+        XGI_SetCRT1DE( HwDeviceExtension , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+        XGI_SetCRT1Offset( ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+        XGI_SetCRT1VCLK( ModeNo , ModeIdIndex , HwDeviceExtension , RefreshRateTableIndex, pVBInfo ) ;
+    }
+
+    if ( ( HwDeviceExtension->jChipType >= XG20 )&&
+         ( HwDeviceExtension->jChipType < XG27 ) ) /* fix H/W DCLK/2 bug */
+    {
+    	if ( ( ModeNo == 0x00 ) | (ModeNo == 0x01) )
+    	{
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , 0x4E) ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , 0xE9) ;
+    	    b3CC =(UCHAR) XGINew_GetReg2(XGINew_P3cc) ;
+    	    XGINew_SetReg3(XGINew_P3cc ,  (b3CC |= 0x0C) ) ;
+    	}
+    	else if ( ( ModeNo == 0x04) | ( ModeNo == 0x05) | ( ModeNo == 0x0D) )
+    	{
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , 0x1B) ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , 0xE3) ;
+    	    b3CC = (UCHAR)XGINew_GetReg2(XGINew_P3cc) ;
+    	    XGINew_SetReg3(XGINew_P3cc ,  (b3CC |= 0x0C) ) ;
+    	}
+    }
+
+    if ( HwDeviceExtension->jChipType >= XG21 )
+    {
+      temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+      if ( temp & 0xA0 )
+      {
+
+        /*XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x20 ) ;*/	/* Enable write GPIOF */
+        /*XGINew_SetRegAND( pVBInfo->P3d4 , 0x48 , ~0x20 ) ;*/ 	/* P. DWN */
+        /* XG21 CRT1 Timing */
+        if ( HwDeviceExtension->jChipType == XG27 )
+          XGI_SetXG27CRTC( ModeNo, ModeIdIndex, RefreshRateTableIndex, pVBInfo );
+        else
+        XGI_SetXG21CRTC( ModeNo, ModeIdIndex, RefreshRateTableIndex, pVBInfo );
+
+        XGI_UpdateXG21CRTC( ModeNo , pVBInfo , RefreshRateTableIndex) ;
+
+        if ( HwDeviceExtension->jChipType == XG27 )
+          XGI_SetXG27LCD( pVBInfo , RefreshRateTableIndex , ModeNo );
+        else
+          XGI_SetXG21LCD( pVBInfo , RefreshRateTableIndex , ModeNo );
+
+        if ( pVBInfo->IF_DEF_LVDS == 1 )
+        {
+          if ( HwDeviceExtension->jChipType == XG27 )
+            XGI_SetXG27LVDSPara(ModeNo,ModeIdIndex, pVBInfo );
+          else
+            XGI_SetXG21LVDSPara(ModeNo,ModeIdIndex, pVBInfo );
+        }
+        /*XGINew_SetRegOR( pVBInfo->P3d4 , 0x48 , 0x20 ) ;*/	/* P. ON */
+      }
+    }
+
+    pVBInfo->SetFlag &= ( ~ProgrammingCRT2 ) ;
+    XGI_SetCRT1FIFO(  ModeNo , HwDeviceExtension,  pVBInfo ) ;
+    XGI_SetCRT1ModeRegs(  HwDeviceExtension , ModeNo , ModeIdIndex , RefreshRateTableIndex , pVBInfo) ;
+
+
+    /* XGI_LoadCharacter(); //dif ifdef TVFont */
+
+    XGI_LoadDAC( ModeNo , ModeIdIndex, pVBInfo ) ;
+    /* XGI_ClearBuffer( HwDeviceExtension , ModeNo, pVBInfo ) ; */
+#ifdef WIN2000
+   if ( pVBInfo->IF_DEF_CH7007 == 1 )  /* [Billy]  2007/05/14  */
+   {
+       VideoDebugPrint((0, "XGI_SetCRT1Group: VBInfo->IF_DEF_CH7007==1\n"));
+       SetCH7007Regs(HwDeviceExtension, ModeNo, ModeIdIndex, RefreshRateTableIndex, pVBInfo ) ; /* 07/05/28 */
+   }
+#endif
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetModePtr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGI_GetModePtr( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR index ;
+
+    if ( ModeNo <= 0x13 )
+        index = pVBInfo->SModeIDTable[ ModeIdIndex ].St_StTableIndex ;
+    else
+    {
+        if ( pVBInfo->ModeType <= 0x02 )
+            index = 0x1B ;	/* 02 -> ModeEGA */
+        else
+            index = 0x0F ;
+    }
+    return( index ) ;		/* Get pVBInfo->StandTable index */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetBIOSData */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+/*UCHAR XGI_SetBIOSData( USHORT ModeNo , USHORT ModeIdIndex )
+{
+    return( 0 ) ;
+}
+*/
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_ClearBankRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+/*UCHAR XGI_ClearBankRegs( USHORT ModeNo , USHORT ModeIdIndex )
+{
+    return( 0 ) ;
+}
+*/
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetSeqRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetSeqRegs(  USHORT ModeNo , USHORT StandTableIndex , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR tempah ,
+          SRdata ;
+
+    USHORT i ,
+           modeflag ;
+
+    if ( ModeNo <= 0x13 )
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    else
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x00 , 0x03 ) ;		/* Set SR0 */
+    tempah=pVBInfo->StandTable[ StandTableIndex ].SR[ 0 ] ;
+
+    i = SetCRT2ToLCDA ;
+    if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+    {
+        tempah |= 0x01 ;
+    }
+    else
+    {
+        if ( pVBInfo->VBInfo & ( SetCRT2ToTV | SetCRT2ToLCD ) )
+        {
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+                tempah |= 0x01 ;
+        }
+    }
+
+    tempah |= 0x20 ;		/* screen off */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , tempah ) ;		/* Set SR1 */
+
+    for( i = 02 ; i <= 04 ; i++ )
+    {
+        SRdata = pVBInfo->StandTable[ StandTableIndex ].SR[ i - 1 ] ;	/* Get SR2,3,4 from file */
+        XGINew_SetReg1( pVBInfo->P3c4 , i , SRdata ) ;				/* Set SR2 3 4 */
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetMiscRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetMiscRegs( USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR Miscdata ;
+
+    Miscdata = pVBInfo->StandTable[ StandTableIndex ].MISC ;	/* Get Misc from file */
+/*
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+        {
+            Miscdata |= 0x0C ;
+        }
+    }
+*/
+
+    XGINew_SetReg3( pVBInfo->P3c2 , Miscdata ) ;		/* Set Misc(3c2) */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRTCRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRTCRegs( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR CRTCdata ;
+    USHORT i ;
+
+    CRTCdata = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    CRTCdata &= 0x7f ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , CRTCdata ) ;		/* Unlock CRTC */
+
+    for( i = 0 ; i <= 0x18 ; i++ )
+    {
+        CRTCdata = pVBInfo->StandTable[ StandTableIndex ].CRTC[ i ] ;	/* Get CRTC from file */
+        XGINew_SetReg1( pVBInfo->P3d4 , i , CRTCdata ) ;				/* Set CRTC( 3d4 ) */
+    }
+/*
+    if ( ( HwDeviceExtension->jChipType == XGI_630 )&& ( HwDeviceExtension->jChipRevision == 0x30 ) )
+    {
+        if ( pVBInfo->VBInfo & SetInSlaveMode )
+        {
+            if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToTV ) )
+            {
+                XGINew_SetReg1( pVBInfo->P3d4 , 0x18 , 0xFE ) ;
+            }
+        }
+    }
+*/
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetATTRegs( USHORT ModeNo , USHORT StandTableIndex , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR ARdata ;
+    USHORT i ,
+           modeflag ;
+
+    if ( ModeNo <= 0x13 )
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    else
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+
+    for( i = 0 ; i <= 0x13 ; i++ )
+    {
+        ARdata = pVBInfo->StandTable[ StandTableIndex ].ATTR[ i ] ;
+        if ( modeflag & Charx8Dot )	/* ifndef Dot9 */
+        {
+            if ( i == 0x13 )
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                    ARdata = 0 ;
+                else
+                {
+                    if ( pVBInfo->VBInfo & ( SetCRT2ToTV | SetCRT2ToLCD ) )
+                    {
+                        if ( pVBInfo->VBInfo & SetInSlaveMode )
+                            ARdata = 0 ;
+                    }
+                }
+            }
+        }
+
+        XGINew_GetReg2( pVBInfo->P3da ) ;			/* reset 3da */
+        XGINew_SetReg3( pVBInfo->P3c0 , i ) ;		/* set index */
+        XGINew_SetReg3( pVBInfo->P3c0 , ARdata ) ;	/* set data */
+    }
+
+    XGINew_GetReg2( pVBInfo->P3da ) ;			/* reset 3da */
+    XGINew_SetReg3( pVBInfo->P3c0 , 0x14 ) ;		/* set index */
+    XGINew_SetReg3( pVBInfo->P3c0 , 0x00 ) ;		/* set data */
+    XGINew_GetReg2( pVBInfo->P3da ) ;			/* Enable Attribute */
+    XGINew_SetReg3( pVBInfo->P3c0 , 0x20 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGRCRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGRCRegs( USHORT StandTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR GRdata ;
+    USHORT i ;
+
+    for( i = 0 ; i <= 0x08 ; i++ )
+    {
+        GRdata = pVBInfo->StandTable[ StandTableIndex ].GRC[ i ] ;	/* Get GR from file */
+        XGINew_SetReg1( pVBInfo->P3ce , i , GRdata ) ;			/* Set GR(3ce) */
+    }
+
+    if ( pVBInfo->ModeType > ModeVGA )
+    {
+        GRdata = ( UCHAR )XGINew_GetReg1( pVBInfo->P3ce , 0x05 ) ;
+        GRdata &= 0xBF ;						/* 256 color disable */
+        XGINew_SetReg1( pVBInfo->P3ce , 0x05 , GRdata ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_ClearExt1Regs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_ClearExt1Regs(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT i ;
+
+    for( i = 0x0A ; i <= 0x0E ; i++ )
+        XGINew_SetReg1( pVBInfo->P3c4 , i , 0x00 ) ;	/* Clear SR0A-SR0E */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetDefaultVCLK */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGI_SetDefaultVCLK( PVB_DEVICE_INFO pVBInfo )
+{
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x31 , ~0x30 , 0x20 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->VCLKData[ 0 ].SR2B ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->VCLKData[ 0 ].SR2C ) ;
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x31 , ~0x30 , 0x10 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->VCLKData[ 1 ].SR2B ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->VCLKData[ 1 ].SR2C ) ;
+
+    XGINew_SetRegAND( pVBInfo->P3c4 , 0x31 , ~0x30 ) ;
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetRatePtrCRT2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetRatePtrCRT2( PXGI_HW_DEVICE_INFO pXGIHWDE, USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    SHORT  LCDRefreshIndex[] = { 0x00 , 0x00 , 0x03 , 0x01 } ,
+           LCDARefreshIndex[] = { 0x00 , 0x00 , 0x03 , 0x01 , 0x01 , 0x01 , 0x01 } ;
+
+    USHORT RefreshRateTableIndex , i ,
+         modeflag , index , temp ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    if ( pVBInfo->IF_DEF_CH7005 == 1 )
+    {
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            if ( modeflag & HalfDCLK )
+                return( 0 ) ;
+        }
+    }
+
+    if ( ModeNo < 0x14 )
+        return( 0xFFFF ) ;
+
+    index = XGINew_GetReg1( pVBInfo->P3d4 , 0x33 ) ;
+    index = index >> pVBInfo->SelectCRT2Rate ;
+    index &= 0x0F ;
+
+    if ( pVBInfo->LCDInfo & LCDNonExpanding )
+        index = 0 ;
+
+    if ( index > 0 )
+        index-- ;
+
+    if ( pVBInfo->SetFlag & ProgrammingCRT2 )
+    {
+        if ( pVBInfo->IF_DEF_CH7005 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            {
+                index = 0 ;
+            }
+        }
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+        {
+            if( pVBInfo->IF_DEF_LVDS == 0 )
+            {
+                if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                    temp = LCDARefreshIndex[ pVBInfo->LCDResInfo & 0x0F ] ;     /* 301b */
+                else
+                    temp = LCDRefreshIndex[ pVBInfo->LCDResInfo & 0x0F ] ;
+
+                if ( index > temp )
+                {
+                    index = temp ;
+                }
+            }
+            else
+            {
+                index = 0 ;
+            }
+        }
+    }
+
+    RefreshRateTableIndex = pVBInfo->EModeIDTable[ ModeIdIndex ].REFindex ;
+    ModeNo = pVBInfo->RefIndex[ RefreshRateTableIndex ].ModeID ;
+    if ( pXGIHWDE->jChipType >= XG20 )  /* for XG20, XG21, XG27 */
+    {
+      /*
+      if ( pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag & XG2xNotSupport )
+      {
+        index++;
+      }
+      */
+      if ( ( pVBInfo->RefIndex[ RefreshRateTableIndex ].XRes == 800 ) &&
+           ( pVBInfo->RefIndex[ RefreshRateTableIndex ].YRes == 600 ) )
+      {
+        index++;
+      }
+/* Alan 10/19/2007; do the similiar adjustment like XGISearchCRT1Rate() */
+      if ( ( pVBInfo->RefIndex[ RefreshRateTableIndex ].XRes == 1024 ) &&
+           ( pVBInfo->RefIndex[ RefreshRateTableIndex ].YRes == 768 ) )
+      {
+        index++;
+      }
+      if ( ( pVBInfo->RefIndex[ RefreshRateTableIndex ].XRes == 1280 ) &&
+           ( pVBInfo->RefIndex[ RefreshRateTableIndex ].YRes == 1024 ) )
+      {
+        index++;
+      }
+    }
+
+    i = 0 ;
+    do
+    {
+        if ( pVBInfo->RefIndex[ RefreshRateTableIndex + i ].ModeID != ModeNo )
+            break ;
+        temp = pVBInfo->RefIndex[ RefreshRateTableIndex + i ].Ext_InfoFlag ;
+        temp &= ModeInfoFlag ;
+        if ( temp < pVBInfo->ModeType )
+            break ;
+        i++ ;
+        index-- ;
+
+    } while( index != 0xFFFF ) ;
+    if ( !( pVBInfo->VBInfo & SetCRT2ToRAMDAC ) )
+    {
+        if ( pVBInfo->VBInfo & SetInSlaveMode )
+        {
+            temp = pVBInfo->RefIndex[ RefreshRateTableIndex + i - 1 ].Ext_InfoFlag ;
+            if ( temp & InterlaceMode )
+            {
+                i++ ;
+            }
+        }
+    }
+    i-- ;
+    if ( ( pVBInfo->SetFlag & ProgrammingCRT2 ) )
+    {
+        temp = XGI_AjustCRT2Rate( ModeNo , ModeIdIndex , RefreshRateTableIndex , &i, pVBInfo) ;
+    }
+    return( RefreshRateTableIndex + i ) ;                /*return(0x01|(temp1<<1));   */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_AjustCRT2Rate */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_AjustCRT2Rate( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex , USHORT *i, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempax ,
+           tempbx ,
+           resinfo ,
+           modeflag ,
+           infoflag ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;	/* si+St_ModeFlag */
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+    tempbx = pVBInfo->RefIndex[ RefreshRateTableIndex + ( *i ) ].ModeID ;
+    tempax = 0 ;
+
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+        {
+            tempax |= SupportRAMDAC2 ;
+
+            if ( pVBInfo->VBType & VB_XGI301C )
+                tempax |= SupportCRT2in301C ;
+        }
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )	/* 301b */
+        {
+            tempax |= SupportLCD ;
+
+            if ( pVBInfo->LCDResInfo != Panel1280x1024 )
+            {
+                if ( pVBInfo->LCDResInfo != Panel1280x960 )
+                {
+                    if ( pVBInfo->LCDInfo & LCDNonExpanding )
+                    {
+                        if ( resinfo >= 9 )
+                        {
+                            tempax = 0 ;
+                            return( 0 ) ;
+                        }
+                    }
+                }
+            }
+        }
+
+        if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )	/* for HiTV */
+        {
+            if ( ( pVBInfo->VBType & VB_XGI301LV ) && ( pVBInfo->VBExtInfo == VB_YPbPr1080i ) )
+            {
+                tempax |= SupportYPbPr ;
+                if ( pVBInfo->VBInfo & SetInSlaveMode )
+                {
+                    if ( resinfo == 4 )
+                        return( 0 ) ;
+
+                    if ( resinfo == 3 )
+                        return( 0 ) ;
+
+                    if ( resinfo > 7 )
+                        return( 0 ) ;
+                }
+            }
+            else
+            {
+                tempax |= SupportHiVisionTV ;
+                if ( pVBInfo->VBInfo & SetInSlaveMode )
+                {
+                    if ( resinfo == 4 )
+                        return( 0 ) ;
+
+                    if ( resinfo == 3 )
+                    {
+                        if ( pVBInfo->SetFlag & TVSimuMode )
+                            return( 0 ) ;
+                    }
+
+                    if ( resinfo > 7 )
+                        return( 0 ) ;
+                }
+            }
+        }
+        else
+        {
+            if ( pVBInfo->VBInfo & ( SetCRT2ToAVIDEO | SetCRT2ToSVIDEO | SetCRT2ToSCART | SetCRT2ToYPbPr | SetCRT2ToHiVisionTV ) )
+            {
+                tempax |= SupportTV ;
+
+                if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                {
+                    tempax |= SupportTV1024 ;
+                }
+
+                if ( !( pVBInfo->VBInfo & SetPALTV ) )
+                {
+                    if ( modeflag & NoSupportSimuTV )
+                    {
+                        if ( pVBInfo->VBInfo & SetInSlaveMode )
+                        {
+                            if ( !( pVBInfo->VBInfo & SetNotSimuMode ) )
+                            {
+                               return( 0 ) ;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    else		/* for LVDS */
+    {
+        if ( pVBInfo->IF_DEF_CH7005 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            {
+                tempax |= SupportCHTV ;
+            }
+        }
+
+        if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+        {
+            tempax |= SupportLCD ;
+
+            if ( resinfo > 0x08 )
+                return( 0 ) ;		/* 1024x768 */
+
+            if ( pVBInfo->LCDResInfo < Panel1024x768 )
+            {
+                if ( resinfo > 0x07 )
+                    return( 0 ) ;	/* 800x600 */
+
+                if ( resinfo == 0x04 )
+                    return( 0 ) ;	/* 512x384 */
+            }
+        }
+    }
+
+    for( ; pVBInfo->RefIndex[ RefreshRateTableIndex + ( *i ) ].ModeID == tempbx ; ( *i )-- )
+    {
+        infoflag = pVBInfo->RefIndex[ RefreshRateTableIndex + ( *i ) ].Ext_InfoFlag ;
+        if ( infoflag & tempax )
+        {
+            return( 1 ) ;
+        }
+        if ( ( *i ) == 0 )
+            break ;
+    }
+
+    for( ( *i ) = 0 ; ; ( *i )++ )
+    {
+        infoflag = pVBInfo->RefIndex[ RefreshRateTableIndex + ( *i ) ].Ext_InfoFlag ;
+        if ( pVBInfo->RefIndex[ RefreshRateTableIndex + ( *i ) ].ModeID != tempbx )
+        {
+            return( 0 ) ;
+        }
+
+        if ( infoflag & tempax )
+        {
+            return( 1 ) ;
+        }
+    }
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetSync */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetSync(USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT sync ,
+           temp ;
+
+    sync = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag >> 8 ;	/* di+0x00 */
+    sync &= 0xC0 ;
+    temp = 0x2F ;
+    temp |= sync ;
+    XGINew_SetReg3( pVBInfo->P3c2 , temp ) ;				/* Set Misc(3c2) */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1CRTC */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1CRTC( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo, PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+    UCHAR  index ,
+           data ;
+
+    USHORT i ;
+
+    index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;	/* Get index */
+    index = index&IndexMask ;
+
+    data =( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    data &= 0x7F ;
+    XGINew_SetReg1(pVBInfo->P3d4,0x11,data);				/* Unlock CRTC */
+
+    for( i = 0 ; i < 8 ; i++ )
+        pVBInfo->TimingH[ 0 ].data[ i ] = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ i ] ;
+
+    for( i = 0 ; i < 7 ; i++ )
+        pVBInfo->TimingV[ 0 ].data[ i ] = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ i + 8 ] ;
+
+    XGI_SetCRT1Timing_H( pVBInfo, HwDeviceExtension ) ;
+
+
+
+    XGI_SetCRT1Timing_V( ModeIdIndex , ModeNo, pVBInfo ) ;
+
+
+    if( pVBInfo->ModeType > 0x03 )
+        XGINew_SetReg1( pVBInfo->P3d4 , 0x14 , 0x4F ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1Timing_H */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1Timing_H( PVB_DEVICE_INFO pVBInfo, PXGI_HW_DEVICE_INFO HwDeviceExtension )
+{
+    UCHAR data , data1, pushax;
+    USHORT i , j ;
+
+    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x51 , 0 ) ; */
+    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x56 , 0 ) ; */
+    /* XGINew_SetRegANDOR( pVBInfo->P3d4 ,0x11 , 0x7f , 0x00 ) ; */
+
+    data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;		/* unlock cr0-7 */
+    data &= 0x7F ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , data ) ;
+
+    data = pVBInfo->TimingH[ 0 ].data[ 0 ] ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0 , data ) ;
+
+    for( i = 0x01 ; i <= 0x04 ; i++ )
+    {
+        data = pVBInfo->TimingH[ 0 ].data[ i ] ;
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 1 ) , data ) ;
+    }
+
+    for( i = 0x05 ; i <= 0x06 ; i++ )
+    {
+        data = pVBInfo->TimingH[ 0 ].data[ i ];
+        XGINew_SetReg1( pVBInfo->P3c4 ,( USHORT )( i + 6 ) , data ) ;
+    }
+
+    j = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x0e ) ;
+    j &= 0x1F ;
+    data = pVBInfo->TimingH[ 0 ].data[ 7 ] ;
+    data &= 0xE0 ;
+    data |= j ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x0e , data ) ;
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+    {
+    	data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x04 ) ;
+    	data = data - 1 ;
+    	XGINew_SetReg1( pVBInfo->P3d4 , 0x04 , data ) ;
+    	data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x05 ) ;
+    	data1 = data ;
+    	data1 &= 0xE0 ;
+    	data &= 0x1F ;
+    	if ( data == 0 )
+    	{
+    	    pushax = data ;
+    	    data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x0c ) ;
+    	    data &= 0xFB ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x0c , data ) ;
+    	    data = pushax ;
+    	}
+    	data = data - 1 ;
+    	data |= data1 ;
+    	XGINew_SetReg1( pVBInfo->P3d4 , 0x05 , data ) ;
+    	data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x0e ) ;
+    	data = data >> 5 ;
+    	data = data + 3 ;
+    	if ( data > 7 )
+    	    data = data - 7 ;
+    	data = data << 5 ;
+    	XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0e , ~0xE0 , data ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1Timing_V */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1Timing_V( USHORT ModeIdIndex , USHORT ModeNo,PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR data ;
+    USHORT i , j ;
+
+    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x51 , 0 ) ; */
+    /* XGINew_SetReg1( pVBInfo->P3d4 , 0x56 , 0 ) ; */
+    /* XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x11 , 0x7f , 0x00 ) ; */
+
+    for( i = 0x00 ; i <= 0x01 ; i++ )
+    {
+        data = pVBInfo->TimingV[ 0 ].data[ i ] ;
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 6 ) , data ) ;
+    }
+
+    for( i = 0x02 ; i <= 0x03 ; i++ )
+    {
+        data = pVBInfo->TimingV[ 0 ].data[ i ] ;
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 0x0e ) , data ) ;
+    }
+
+    for( i = 0x04 ; i <= 0x05 ; i++ )
+    {
+        data = pVBInfo->TimingV[ 0 ].data[ i ] ;
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 0x11 ) , data ) ;
+    }
+
+    j = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x0a ) ;
+    j &= 0xC0 ;
+    data = pVBInfo->TimingV[ 0 ].data[ 6 ] ;
+    data &= 0x3F ;
+    data |= j ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x0a , data ) ;
+
+    data = pVBInfo->TimingV[ 0 ].data[ 6 ] ;
+    data &= 0x80 ;
+    data = data >> 2 ;
+
+    if ( ModeNo <= 0x13 )
+        i = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    else
+        i = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+
+    i &= DoubleScanMode ;
+    if ( i )
+        data |= 0x80 ;
+
+    j = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x09 ) ;
+    j &= 0x5F ;
+    data |= j ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x09 , data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetXG21CRTC */
+/* Input : Stand or enhance CRTC table */
+/* Output : Fill CRT Hsync/Vsync to SR2E/SR2F/SR30/SR33/SR34/SR3F */
+/* Description : Set LCD timing */
+/* --------------------------------------------------------------------- */
+void XGI_SetXG21CRTC(USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo)
+{
+  UCHAR StandTableIndex, index, Tempax, Tempbx, Tempcx, Tempdx ;
+  USHORT Temp1, Temp2, Temp3 ;
+
+  if ( ModeNo <= 0x13 )
+  {
+    StandTableIndex = XGI_GetModePtr( ModeNo , ModeIdIndex, pVBInfo ) ;
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 4 ] ;		/* CR04 HRS */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , Tempax ) ;    		/* SR2E [7:0]->HRS */
+    Tempbx = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 5 ] ;		/* Tempbx: CR05 HRE */
+    Tempbx &= 0x1F ;							/* Tempbx: HRE[4:0] */
+    Tempcx = Tempax ;
+    Tempcx &=  0xE0 ;							/* Tempcx: HRS[7:5] */
+    Tempdx = Tempcx | Tempbx ;						/* Tempdx(HRE): HRS[7:5]HRE[4:0] */
+    if ( Tempbx < ( Tempax & 0x1F ) )					/* IF HRE < HRS */
+      Tempdx |= 0x20 ;							/* Tempdx: HRE = HRE + 0x20 */
+    Tempdx <<= 2 ;							/* Tempdx << 2 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , Tempdx ) ;    		/* SR2F [7:2]->HRE */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , 0xE3 , 00 ) ;
+
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 16 ] ;	/* Tempax: CR16 VRS */
+    Tempbx = Tempax ;							/* Tempbx=Tempax */
+    Tempax &= 0x01 ;							/* Tempax: VRS[0] */
+    XGINew_SetRegOR( pVBInfo->P3c4 , 0x33 , Tempax ) ;   		/* SR33[0]->VRS */
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 7 ] ;		/* Tempax: CR7 VRS */
+    Tempdx = Tempbx >> 1 ;						/* Tempdx: VRS[7:1] */
+    Tempcx = Tempax & 0x04 ;						/* Tempcx: CR7[2] */
+    Tempcx <<= 5 ;							/* Tempcx[7]: VRS[8] */
+    Tempdx |= Tempcx ;							/* Tempdx: VRS[8:1] */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , Tempdx ) ;    		/* SR34[7:0]: VRS[8:1] */
+
+    Temp1 = Tempcx << 1 ;						/* Temp1[8]: VRS[8] UCHAR -> USHORT */
+    Temp1 |= Tempbx ;							/* Temp1[8:0]: VRS[8:0] */
+    Tempax &= 0x80 ;							/* Tempax[7]: CR7[7] */
+    Temp2 = Tempax << 2 ;						/* Temp2[9]: VRS[9] */
+    Temp1 |= Temp2 ;							/* Temp1[9:0]: VRS[9:0] */
+
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 17 ] ;	/* CR16 VRE */
+    Tempax &= 0x0F ;							/* Tempax[3:0]: VRE[3:0] */
+    Temp2 = Temp1 & 0x3F0 ;						/* Temp2[9:4]: VRS[9:4] */
+    Temp2 |= Tempax ;							/* Temp2[9:0]: VRE[9:0] */
+    Temp3 = Temp1 & 0x0F ;						/* Temp3[3:0]: VRS[3:0] */
+    if ( Tempax < Temp3 )						/* VRE[3:0]<VRS[3:0] */
+      Temp2 |= 0x10 ;							/* Temp2: VRE + 0x10 */
+    Temp2 &= 0xFF ;							/* Temp2[7:0]: VRE[7:0] */
+    Tempax = (UCHAR)Temp2 ;						/* Tempax[7:0]: VRE[7:0] */
+    Tempax <<= 2 ;							/* Tempax << 2: VRE[5:0] */
+    Temp1 &= 0x600 ;							/* Temp1[10:9]: VRS[10:9] */
+    Temp1 >>= 9 ;							/* [10:9]->[1:0] */
+    Tempbx = (UCHAR)Temp1 ;						/* Tempbx[1:0]: VRS[10:9] */
+    Tempax |= Tempbx ;							/* VRE[5:0]VRS[10:9] */
+    Tempax &= 0x7F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x3F , Tempax ) ;   		/* SR3F D[7:2]->VRE D[1:0]->VRS */
+  }
+  else
+  {
+    index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 3 ] ;		/* Tempax: CR4 HRS */
+    Tempcx = Tempax ;							/* Tempcx: HRS */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , Tempax ) ;  		        /* SR2E[7:0]->HRS */
+
+    Tempdx = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 5 ] ;		/* SRB */
+    Tempdx &= 0xC0 ;							/* Tempdx[7:6]: SRB[7:6] */
+    Temp1 = Tempdx ;							/* Temp1[7:6]: HRS[9:8] */
+    Temp1 <<= 2 ;							/* Temp1[9:8]: HRS[9:8] */
+    Temp1 |= Tempax ;							/* Temp1[9:0]: HRS[9:0] */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 4 ] ;		/* CR5 HRE */
+    Tempax &= 0x1F ;							/* Tempax[4:0]: HRE[4:0] */
+
+    Tempbx = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 6 ] ;		/* SRC */
+    Tempbx &= 0x04 ;							/* Tempbx[2]: HRE[5] */
+    Tempbx <<= 3 ;							/* Tempbx[5]: HRE[5] */
+    Tempax |= Tempbx ;							/* Tempax[5:0]: HRE[5:0] */
+
+    Temp2 = Temp1 & 0x3C0 ;						/* Temp2[9:6]: HRS[9:6] */
+    Temp2 |= Tempax ;							/* Temp2[9:0]: HRE[9:0] */
+
+    Tempcx &= 0x3F ;							/* Tempcx[5:0]: HRS[5:0] */
+    if( Tempax < Tempcx )						/* HRE < HRS */
+      Temp2 |= 0x40 ;                                                   /* Temp2 + 0x40 */
+
+    Temp2 &= 0xFF ;
+    Tempax = (UCHAR)Temp2 ;						/* Tempax: HRE[7:0] */
+    Tempax <<= 2 ;							/* Tempax[7:2]: HRE[5:0] */
+    Tempdx >>= 6 ;							/* Tempdx[7:6]->[1:0] HRS[9:8] */
+    Tempax |= Tempdx ;							/* HRE[5:0]HRS[9:8] */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , Tempax ) ;    		/* SR2F D[7:2]->HRE, D[1:0]->HRS */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , 0xE3 , 00 ) ;
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 10 ] ;		/* CR10 VRS */
+    Tempbx = Tempax ;							/* Tempbx: VRS */
+    Tempax &= 0x01 ;							/* Tempax[0]: VRS[0] */
+    XGINew_SetRegOR( pVBInfo->P3c4 , 0x33 , Tempax ) ;   		/* SR33[0]->VRS[0] */
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 9 ] ;		/* CR7[2][7] VRE */
+    Tempcx = Tempbx >> 1 ;				   		/* Tempcx[6:0]: VRS[7:1] */
+    Tempdx = Tempax & 0x04 ;						/* Tempdx[2]: CR7[2] */
+    Tempdx <<= 5 ;							/* Tempdx[7]: VRS[8] */
+    Tempcx |= Tempdx ;							/* Tempcx[7:0]: VRS[8:1] */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , Tempcx ) ;   		/* SR34[8:1]->VRS */
+
+    Temp1 = Tempdx ;							/* Temp1[7]: Tempdx[7] */
+    Temp1 <<= 1 ;							/* Temp1[8]: VRS[8] */
+    Temp1 |= Tempbx ;							/* Temp1[8:0]: VRS[8:0] */
+    Tempax &= 0x80 ;
+    Temp2 = Tempax << 2 ;						/* Temp2[9]: VRS[9] */
+    Temp1 |= Temp2 ;							/* Temp1[9:0]: VRS[9:0] */
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 14 ] ;		/* Tempax: SRA */
+    Tempax &= 0x08 ;							/* Tempax[3]: VRS[3] */
+    Temp2 = Tempax ;
+    Temp2 <<= 7 ;							/* Temp2[10]: VRS[10] */
+    Temp1 |= Temp2 ;							/* Temp1[10:0]: VRS[10:0] */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 11 ] ;		/* Tempax: CR11 VRE */
+    Tempax &= 0x0F ;							/* Tempax[3:0]: VRE[3:0] */
+    Tempbx = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 14 ] ;		/* Tempbx: SRA */
+    Tempbx &= 0x20 ;							/* Tempbx[5]: VRE[5] */
+    Tempbx >>= 1 ;							/* Tempbx[4]: VRE[4] */
+    Tempax |= Tempbx ;							/* Tempax[4:0]: VRE[4:0] */
+    Temp2 = Temp1 & 0x7E0 ;						/* Temp2[10:5]: VRS[10:5] */
+    Temp2 |= Tempax ;							/* Temp2[10:5]: VRE[10:5] */
+
+    Temp3 = Temp1 & 0x1F ;						/* Temp3[4:0]: VRS[4:0] */
+    if ( Tempax < Temp3 )						/* VRE < VRS */
+      Temp2 |= 0x20 ;							/* VRE + 0x20 */
+
+    Temp2 &= 0xFF ;
+    Tempax = (UCHAR)Temp2 ;						/* Tempax: VRE[7:0] */
+    Tempax <<= 2 ;							/* Tempax[7:0]; VRE[5:0]00 */
+    Temp1 &= 0x600 ;							/* Temp1[10:9]: VRS[10:9] */
+    Temp1 >>= 9 ;  							/* Temp1[1:0]: VRS[10:9] */
+    Tempbx = (UCHAR)Temp1 ;
+    Tempax |= Tempbx ;							/* Tempax[7:0]: VRE[5:0]VRS[10:9] */
+    Tempax &= 0x7F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x3F , Tempax ) ;   		/* SR3F D[7:2]->VRE D[1:0]->VRS */
+  }
+}
+
+void XGI_SetXG27CRTC(USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo)
+{
+  USHORT StandTableIndex, index, Tempax, Tempbx, Tempcx, Tempdx ;
+
+  if ( ModeNo <= 0x13 )
+  {
+    StandTableIndex = XGI_GetModePtr( ModeNo , ModeIdIndex, pVBInfo ) ;
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 4 ] ;		/* CR04 HRS */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , Tempax ) ;    		/* SR2E [7:0]->HRS */
+    Tempbx = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 5 ] ;		/* Tempbx: CR05 HRE */
+    Tempbx &= 0x1F ;							/* Tempbx: HRE[4:0] */
+    Tempcx = Tempax ;
+    Tempcx &=  0xE0 ;							/* Tempcx: HRS[7:5] */
+    Tempdx = Tempcx | Tempbx ;						/* Tempdx(HRE): HRS[7:5]HRE[4:0] */
+    if ( Tempbx < ( Tempax & 0x1F ) )					/* IF HRE < HRS */
+      Tempdx |= 0x20 ;							/* Tempdx: HRE = HRE + 0x20 */
+    Tempdx <<= 2 ;							/* Tempdx << 2 */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , Tempdx ) ;    		/* SR2F [7:2]->HRE */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , 0xE3 , 00 ) ;
+
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 16 ] ;	/* Tempax: CR10 VRS */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , Tempax ) ;   		/* SR34[7:0]->VRS */
+    Tempcx = Tempax ;							/* Tempcx=Tempax=VRS[7:0] */
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 7 ] ;		/* Tempax[7][2]: CR7[7][2] VRS[9][8] */
+    Tempbx = Tempax ;							/* Tempbx=CR07 */
+    Tempax &= 0x04 ;     						/* Tempax[2]: CR07[2] VRS[8] */
+    Tempax >>= 2;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x01, Tempax ) ;        /* SR35 D[0]->VRS D[8] */
+    Tempcx |= (Tempax << 8) ;					        /* Tempcx[8] |= VRS[8] */
+    Tempcx |= (Tempbx & 0x80)<<2;					/* Tempcx[9] |= VRS[9] */
+
+
+    Tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 17 ] ;	/* CR11 VRE */
+    Tempax &= 0x0F ;							/* Tempax: VRE[3:0] */
+    Tempbx = Tempcx ;							/* Tempbx=Tempcx=VRS[9:0] */
+    Tempbx &= 0x3F0 ;    						/* Tempbx[9:4]: VRS[9:4] */
+    Tempbx |= Tempax ;							/* Tempbx[9:0]: VRE[9:0] */
+    if ( Tempax <= (Tempcx & 0x0F) )					/* VRE[3:0]<=VRS[3:0] */
+      Tempbx |= 0x10 ;							/* Tempbx: VRE + 0x10 */
+    Tempax = (UCHAR)Tempbx & 0xFF;					/* Tempax[7:0]: VRE[7:0] */
+    Tempax <<= 2 ;							/* Tempax << 2: VRE[5:0] */
+    Tempcx = (Tempcx&0x600)>>8;                                         /* Tempcx VRS[10:9] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x3F , ~0xFC, Tempax ) ;        /* SR3F D[7:2]->VRE D[5:0] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x06, Tempcx ) ;	/* SR35 D[2:1]->VRS[10:9] */
+  }
+  else
+  {
+    index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 3 ] ;		/* Tempax: CR4 HRS */
+    Tempbx = Tempax ;							/* Tempbx: HRS[7:0] */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , Tempax ) ;  		        /* SR2E[7:0]->HRS */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 5 ] ;		/* SR0B */
+    Tempax &= 0xC0 ;							/* Tempax[7:6]: SR0B[7:6]: HRS[9:8]*/
+    Tempbx |= (Tempax << 2);					/* Tempbx: HRS[9:0] */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 4 ] ;		/* CR5 HRE */
+    Tempax &= 0x1F ;							/* Tempax[4:0]: HRE[4:0] */
+    Tempcx = Tempax ;							/* Tempcx: HRE[4:0] */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 6 ] ;		/* SRC */
+    Tempax &= 0x04 ;							/* Tempax[2]: HRE[5] */
+    Tempax <<= 3 ;							    /* Tempax[5]: HRE[5] */
+    Tempcx |= Tempax ;							/* Tempcx[5:0]: HRE[5:0] */
+
+    Tempbx = Tempbx & 0x3C0 ;					/* Tempbx[9:6]: HRS[9:6] */
+    Tempbx |= Tempcx ;							/* Tempbx: HRS[9:6]HRE[5:0] */
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 3 ] ;		/* Tempax: CR4 HRS */
+    Tempax &= 0x3F ;							/* Tempax: HRS[5:0] */
+    if( Tempcx <= Tempax )						/* HRE[5:0] < HRS[5:0] */
+      Tempbx += 0x40 ;                          /* Tempbx= Tempbx + 0x40 : HRE[9:0]*/
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 5 ] ;		/* SR0B */
+    Tempax &= 0xC0 ;							/* Tempax[7:6]: SR0B[7:6]: HRS[9:8]*/
+    Tempax >>= 6;                               /* Tempax[1:0]: HRS[9:8]*/
+    Tempax |= ((Tempbx << 2) & 0xFF);           /* Tempax[7:2]: HRE[5:0] */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , Tempax ) ;    		/* SR2F [7:2][1:0]: HRE[5:0]HRS[9:8] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , 0xE3 , 00 ) ;
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 10 ] ;		/* CR10 VRS */
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , Tempax ) ;   		/* SR34[7:0]->VRS[7:0] */
+
+    Tempcx = Tempax ;							/* Tempcx <= VRS[7:0] */
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 9 ] ;		/* CR7[7][2] VRS[9][8] */
+    Tempbx = Tempax ;							/* Tempbx <= CR07[7:0] */
+    Tempax = Tempax & 0x04 ;					/* Tempax[2]: CR7[2]: VRS[8] */
+    Tempax >>= 2 ;							    /* Tempax[0]: VRS[8] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x01 , Tempax ) ;   	/* SR35[0]: VRS[8] */
+    Tempcx |= (Tempax<<8) ;						/* Tempcx <= VRS[8:0] */
+    Tempcx |= ((Tempbx&0x80)<<2) ;				/* Tempcx <= VRS[9:0] */
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 14 ] ;		/* Tempax: SR0A */
+    Tempax &= 0x08;                             /* SR0A[3] VRS[10] */
+    Tempcx |= (Tempax<<7) ;        				/* Tempcx <= VRS[10:0] */
+
+
+    Tempax = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 11 ] ;		/* Tempax: CR11 VRE */
+    Tempax &= 0x0F ;							/* Tempax[3:0]: VRE[3:0] */
+    Tempbx = pVBInfo->XGINEWUB_CRT1Table[ index ].CR[ 14 ] ;		/* Tempbx: SR0A */
+    Tempbx &= 0x20 ;							/* Tempbx[5]: SR0A[5]: VRE[4] */
+    Tempbx >>= 1 ;							    /* Tempbx[4]: VRE[4] */
+    Tempax |= Tempbx ;							/* Tempax[4:0]: VRE[4:0] */
+    Tempbx = Tempcx ;							/* Tempbx: VRS[10:0] */
+    Tempbx &= 0x7E0 ;						    /* Tempbx[10:5]: VRS[10:5] */
+    Tempbx |= Tempax ;							/* Tempbx: VRS[10:5]VRE[4:0] */
+
+    if ( Tempbx <= Tempcx )						/* VRE <= VRS */
+      Tempbx |= 0x20 ;							/* VRE + 0x20 */
+
+    Tempax = (Tempbx<<2) & 0xFF ;					/* Tempax: Tempax[7:0]; VRE[5:0]00 */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x3F , ~0xFC , Tempax ) ;	/* SR3F[7:2]:VRE[5:0] */
+    Tempax = Tempcx >> 8;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x07 , Tempax ) ;	/* SR35[2:0]:VRS[10:8] */
+  }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetXG21LCD */
+/* Input : */
+/* Output : FCLK duty cycle, FCLK delay compensation */
+/* Description : All values set zero */
+/* --------------------------------------------------------------------- */
+void XGI_SetXG21LCD(PVB_DEVICE_INFO pVBInfo,USHORT RefreshRateTableIndex,USHORT ModeNo)
+{
+  USHORT Data , Temp , b3CC ;
+  USHORT XGI_P3cc ;
+
+  XGI_P3cc = pVBInfo->P3cc ;
+
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x2E , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x2F , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x46 , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x47 , 0x00 ) ;
+  if ( ((*pVBInfo->pDVOSetting)&0xC0) == 0xC0 )
+  {
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2E , *pVBInfo->pCR2E ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2F , *pVBInfo->pCR2F ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x46 , *pVBInfo->pCR46 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x47 , *pVBInfo->pCR47 ) ;
+  }
+
+  Temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x37 ) ;
+
+  if ( Temp & 0x01 )
+  {
+    XGINew_SetRegOR( pVBInfo->P3c4 , 0x06 , 0x40 ) ; /* 18 bits FP */
+    XGINew_SetRegOR( pVBInfo->P3c4 , 0x09 , 0x40 ) ;
+  }
+
+  XGINew_SetRegOR( pVBInfo->P3c4 , 0x1E , 0x01 ) ;   /* Negative blank polarity */
+
+  XGINew_SetRegAND( pVBInfo->P3c4 , 0x30 , ~0x20 ) ;
+  XGINew_SetRegAND( pVBInfo->P3c4 , 0x35 , ~0x80 ) ;
+
+  if ( ModeNo <= 0x13 )
+  {
+    b3CC = (UCHAR) XGINew_GetReg2( XGI_P3cc ) ;
+    if ( b3CC & 0x40 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x30 , 0x20 ) ; /* Hsync polarity */
+    if ( b3CC & 0x80 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x35 , 0x80 ) ; /* Vsync polarity */
+  }
+  else
+  {
+    Data = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+    if ( Data & 0x4000 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x30 , 0x20 ) ; /* Hsync polarity */
+    if ( Data & 0x8000 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x35 , 0x80 ) ; /* Vsync polarity */
+  }
+}
+
+void XGI_SetXG27LCD(PVB_DEVICE_INFO pVBInfo,USHORT RefreshRateTableIndex,USHORT ModeNo)
+{
+  USHORT Data , Temp , b3CC ;
+  USHORT XGI_P3cc ;
+
+  XGI_P3cc = pVBInfo->P3cc ;
+
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x2E , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x2F , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x46 , 0x00 ) ;
+  XGINew_SetReg1( pVBInfo->P3d4 , 0x47 , 0x00 ) ;
+
+  Temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x37 ) ;
+  if ( ( Temp & 0x03 ) == 0 )  /* dual 12 */
+  {
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x46 , 0x13 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x47 , 0x13 ) ;
+  }
+
+  if ( ((*pVBInfo->pDVOSetting)&0xC0) == 0xC0 )
+  {
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2E , *pVBInfo->pCR2E ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2F , *pVBInfo->pCR2F ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x46 , *pVBInfo->pCR46 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x47 , *pVBInfo->pCR47 ) ;
+  }
+
+  XGI_SetXG27FPBits(pVBInfo);
+
+  XGINew_SetRegOR( pVBInfo->P3c4 , 0x1E , 0x01 ) ;   /* Negative blank polarity */
+
+  XGINew_SetRegAND( pVBInfo->P3c4 , 0x30 , ~0x20 ) ; /* Hsync polarity */
+  XGINew_SetRegAND( pVBInfo->P3c4 , 0x35 , ~0x80 ) ; /* Vsync polarity */
+
+  if ( ModeNo <= 0x13 )
+  {
+    b3CC = (UCHAR) XGINew_GetReg2( XGI_P3cc ) ;
+    if ( b3CC & 0x40 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x30 , 0x20 ) ; /* Hsync polarity */
+    if ( b3CC & 0x80 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x35 , 0x80 ) ; /* Vsync polarity */
+  }
+  else
+  {
+    Data = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+    if ( Data & 0x4000 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x30 , 0x20 ) ; /* Hsync polarity */
+    if ( Data & 0x8000 )
+      XGINew_SetRegOR( pVBInfo->P3c4 , 0x35 , 0x80 ) ; /* Vsync polarity */
+  }
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_UpdateXG21CRTC */
+/* Input : */
+/* Output : CRT1 CRTC */
+/* Description : Modify CRT1 Hsync/Vsync to fix LCD mode timing */
+/* --------------------------------------------------------------------- */
+void XGI_UpdateXG21CRTC( USHORT ModeNo , PVB_DEVICE_INFO pVBInfo , USHORT RefreshRateTableIndex )
+{
+  int i , index = -1;
+
+  XGINew_SetRegAND( pVBInfo->P3d4 , 0x11 , 0x7F ) ;		/* Unlock CR0~7 */
+  if ( ModeNo <= 0x13 )
+  {
+    for( i = 0 ; i < 12 ; i++ )
+    {
+      if ( ModeNo == pVBInfo->UpdateCRT1[ i ].ModeID )
+        index = i ;
+    }
+  }
+  else
+  {
+    if ( ModeNo == 0x2E && ( pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ==  RES640x480x60 ) )
+      index = 12 ;
+    else if ( ModeNo == 0x2E && ( pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC == RES640x480x72 ) )
+      index = 13 ;
+    else if ( ModeNo == 0x2F )
+      index = 14 ;
+    else if ( ModeNo == 0x50 )
+      index = 15 ;
+    else if ( ModeNo == 0x59 )
+      index = 16 ;
+  }
+
+  if( index != -1 )
+  {
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x02 , pVBInfo->UpdateCRT1[ index ].CR02 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x03 , pVBInfo->UpdateCRT1[ index ].CR03 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x15 , pVBInfo->UpdateCRT1[ index ].CR15 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x16 , pVBInfo->UpdateCRT1[ index ].CR16 ) ;
+  }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1DE */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1DE( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo,USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT resindex ,
+           tempax ,
+           tempbx ,
+           tempcx ,
+           temp ,
+           modeflag ;
+
+    UCHAR data ;
+
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+        tempax = pVBInfo->StResInfo[ resindex ].HTotal ;
+        tempbx = pVBInfo->StResInfo[ resindex ].VTotal ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        tempax = pVBInfo->ModeResInfo[ resindex ].HTotal ;
+        tempbx = pVBInfo->ModeResInfo[ resindex ].VTotal ;
+    }
+
+    if ( modeflag & HalfDCLK )
+        tempax = tempax >> 1 ;
+
+    if ( ModeNo > 0x13 )
+    {
+        if ( modeflag & HalfDCLK )
+            tempax = tempax << 1 ;
+
+        temp = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+
+        if ( temp & InterlaceMode )
+            tempbx = tempbx >> 1 ;
+
+        if ( modeflag & DoubleScanMode )
+            tempbx = tempbx << 1 ;
+    }
+
+    tempcx = 8 ;
+
+    /* if ( !( modeflag & Charx8Dot ) ) */
+    /* tempcx = 9 ; */
+
+    tempax /= tempcx ;
+    tempax -= 1 ;
+    tempbx -= 1 ;
+    tempcx = tempax ;
+    temp = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    data = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    data &= 0x7F ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , data ) ;		/* Unlock CRTC */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x01 , ( USHORT )( tempcx & 0xff ) ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x0b , ~0x0c , ( USHORT )( ( tempcx & 0x0ff00 ) >> 10 ) ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x12 , ( USHORT )( tempbx & 0xff ) ) ;
+    tempax = 0 ;
+    tempbx = tempbx >> 8 ;
+
+    if ( tempbx & 0x01 )
+        tempax |= 0x02 ;
+
+    if ( tempbx & 0x02 )
+        tempax |= 0x40 ;
+
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x42 , tempax ) ;
+    data =( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x07 ) ;
+    data &= 0xFF ;
+    tempax = 0 ;
+
+    if ( tempbx & 0x04 )
+        tempax |= 0x02 ;
+
+    XGINew_SetRegANDOR( pVBInfo->P3d4 ,0x0a , ~0x02 , tempax ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetResInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT 	XGI_GetResInfo(USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT resindex ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        resindex = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ; 	/* si+St_ResInfo */
+    }
+    else
+    {
+        resindex = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;	/* si+Ext_ResInfo */
+    }
+    return( resindex ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1Offset */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1Offset(  USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT temp ,
+           ah ,
+           al ,
+           temp2 ,
+           i ,
+           DisplayUnit ;
+
+    /* GetOffset */
+    temp = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeInfo ;
+    temp = temp >> 8 ;
+    temp = pVBInfo->ScreenOffset[ temp ] ;
+
+    temp2 = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+    temp2 &= InterlaceMode ;
+
+    if ( temp2 )
+        temp = temp << 1;
+
+    temp2 = pVBInfo->ModeType - ModeEGA ;
+
+    switch( temp2 )
+    {
+        case 0:
+            temp2 = 1 ;
+            break ;
+        case 1:
+            temp2 = 2 ;
+            break ;
+        case 2:
+            temp2 = 4 ;
+            break ;
+        case 3:
+            temp2 = 4 ;
+            break ;
+        case 4:
+            temp2 = 6 ;
+            break;
+        case 5:
+            temp2 = 8 ;
+            break ;
+        default:
+            break ;
+    }
+
+    if ( ( ModeNo >= 0x26 ) && ( ModeNo <= 0x28 ) )
+        temp = temp * temp2 + temp2 / 2 ;
+    else
+        temp *= temp2 ;
+
+    /* SetOffset */
+    DisplayUnit = temp ;
+    temp2 = temp ;
+    temp = temp >> 8 ;		/* ah */
+    temp &= 0x0F ;
+    i = XGINew_GetReg1( pVBInfo->P3c4 , 0x0E ) ;
+    i &= 0xF0 ;
+    i |= temp ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x0E , i ) ;
+
+    temp =( UCHAR )temp2 ;
+    temp &= 0xFF ;		/* al */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x13 , temp ) ;
+
+    /* SetDisplayUnit */
+    temp2 = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+    temp2 &= InterlaceMode ;
+    if ( temp2 )
+        DisplayUnit >>= 1 ;
+
+    DisplayUnit = DisplayUnit << 5 ;
+    ah = ( DisplayUnit & 0xff00 ) >> 8 ;
+    al = DisplayUnit & 0x00ff ;
+    if ( al == 0 )
+        ah += 1 ;
+    else
+        ah += 2 ;
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+        if ( ( ModeNo == 0x4A ) | (ModeNo == 0x49 ) )
+            ah -= 1 ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x10 , ah ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1VCLK */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1VCLK( USHORT ModeNo , USHORT ModeIdIndex ,
+                        PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR index , data ;
+    USHORT vclkindex ;
+
+    if ( pVBInfo->IF_DEF_LVDS == 1 )
+    {
+        index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRTVCLK ;
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x31 ) & 0xCF ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , data ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->VCLKData[ index ].SR2B ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->VCLKData[ index ].SR2C ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2D , 0x01 ) ;
+    }
+    else if ( ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) ) && ( pVBInfo->VBInfo & SetCRT2ToLCDA ) )
+    {
+        vclkindex = XGI_GetVCLK2Ptr( ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x31 ) & 0xCF ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , data ) ;
+        data = pVBInfo->VBVCLKData[ vclkindex ].Part4_A ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , data ) ;
+        data = pVBInfo->VBVCLKData[ vclkindex ].Part4_B ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , data ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2D , 0x01 ) ;
+    }
+    else
+    {
+        index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRTVCLK ;
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x31 ) & 0xCF ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , data ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->VCLKData[ index ].SR2B ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->VCLKData[ index ].SR2C ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2D , 0x01 ) ;
+    }
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+    {
+    	if ( pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag & HalfDCLK )
+    	{
+    	data = XGINew_GetReg1( pVBInfo->P3c4 , 0x2B ) ;
+    	XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , data ) ;
+    	data = XGINew_GetReg1( pVBInfo->P3c4 , 0x2C ) ;
+    	index = data ;
+    	index &= 0xE0 ;
+    	data &= 0x1F ;
+    	data = data << 1 ;
+    	data += 1 ;
+    	data |= index ;
+    	XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , data ) ;
+    	}
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1FIFO */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1FIFO( USHORT ModeNo , PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT data ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x3D ) ;
+    data &= 0xfe ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x3D , data ) ;	/* diable auto-threshold */
+
+    if ( ModeNo > 0x13 )
+    {
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x08 , 0x34 ) ;
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x09 ) ;
+        data &= 0xC0 ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x09 , data | 0x30) ;
+        data = XGINew_GetReg1( pVBInfo->P3c4 , 0x3D ) ;
+        data |= 0x01 ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x3D , data ) ;
+    }
+    else
+    {
+        if (HwDeviceExtension->jChipType == XG27)
+        {
+          XGINew_SetReg1( pVBInfo->P3c4 , 0x08 , 0x0E ) ;
+          data = XGINew_GetReg1( pVBInfo->P3c4 , 0x09 ) ;
+          data &= 0xC0 ;
+          XGINew_SetReg1( pVBInfo->P3c4 , 0x09 , data | 0x20 ) ;
+        }
+        else
+        {
+          XGINew_SetReg1( pVBInfo->P3c4 , 0x08 , 0xAE ) ;
+          data = XGINew_GetReg1( pVBInfo->P3c4 , 0x09 ) ;
+          data &= 0xF0 ;
+          XGINew_SetReg1( pVBInfo->P3c4 , 0x09 , data ) ;
+        }
+    }
+
+    if (HwDeviceExtension->jChipType == XG21)
+    {
+        XGI_SetXG21FPBits(pVBInfo);                 /* Fix SR9[7:6] can't read back */
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT1ModeRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT1ModeRegs( PXGI_HW_DEVICE_INFO HwDeviceExtension ,
+                            USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT data ,
+           data2 ,
+           data3 ,
+           infoflag = 0 ,
+           modeflag ,
+           resindex ,
+           xres ;
+
+    if ( ModeNo > 0x13 )
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        infoflag = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+    }
+    else
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;    /* si+St_ModeFlag */
+
+    if ( XGINew_GetReg1( pVBInfo->P3d4 , 0x31 ) & 0x01 )
+      XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x1F , 0x3F , 0x00 ) ;
+
+    if ( ModeNo > 0x13 )
+        data = infoflag ;
+    else
+        data = 0 ;
+
+    data2 = 0 ;
+
+    if ( ModeNo > 0x13 )
+    {
+        if ( pVBInfo->ModeType > 0x02 )
+        {
+            data2 |= 0x02 ;
+            data3 = pVBInfo->ModeType - ModeVGA ;
+            data3 = data3 << 2 ;
+            data2 |= data3 ;
+        }
+    }
+
+    data &= InterlaceMode ;
+
+    if ( data )
+        data2 |= 0x20 ;
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x06 , ~0x3F , data2 ) ;
+    /* XGINew_SetReg1(pVBInfo->P3c4,0x06,data2); */
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( ModeNo <= 0x13 )
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+    else
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;                         /* xres->ax */
+
+    data = 0x0000 ;
+    if ( infoflag & InterlaceMode )
+    {
+        if ( xres == 1024 )
+            data = 0x0035 ;
+        else if ( xres == 1280 )
+            data = 0x0048 ;
+    }
+
+    data2 = data & 0x00FF ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x19 , 0xFF , data2 ) ;
+    data2 = ( data & 0xFF00 ) >> 8 ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x19 , 0xFC , data2 ) ;
+
+    if( modeflag & HalfDCLK )
+        XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x01 , 0xF7 , 0x08 ) ;
+
+    data2 = 0 ;
+
+    if ( modeflag & LineCompareOff )
+        data2 |= 0x08 ;
+
+    if ( ModeNo > 0x13 )
+    {
+        if ( pVBInfo->ModeType == ModeEGA )
+            data2 |= 0x40 ;
+    }
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0F , ~0x48 , data2 ) ;
+    data = 0x60 ;
+    if ( pVBInfo->ModeType != ModeText )
+    {
+        data = data ^ 0x60 ;
+        if ( pVBInfo->ModeType != ModeEGA )
+        {
+            data = data ^ 0xA0 ;
+        }
+    }
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x21 , 0x1F , data ) ;
+
+    XGI_SetVCLKState( HwDeviceExtension , ModeNo , RefreshRateTableIndex, pVBInfo) ;
+
+    /* if(modeflag&HalfDCLK)//030305 fix lowresolution bug */
+    /* if(XGINew_IF_DEF_NEW_LOWRES) */
+    /* XGI_VesaLowResolution(ModeNo,ModeIdIndex);//030305 fix lowresolution bug */
+
+    data=XGINew_GetReg1( pVBInfo->P3d4 , 0x31 ) ;
+
+    if (HwDeviceExtension->jChipType == XG27 )
+    {
+    	if ( data & 0x40 )
+    	    data = 0x2c ;
+    	else
+    	    data = 0x6c ;
+    	XGINew_SetReg1( pVBInfo->P3d4 , 0x52 , data ) ;
+    	XGINew_SetRegOR( pVBInfo->P3d4 , 0x51 , 0x10 ) ;
+    }
+    else
+    if (HwDeviceExtension->jChipType >= XG20 )
+    {
+    	if ( data & 0x40 )
+    	    data = 0x33 ;
+    	else
+    	    data = 0x73 ;
+    	XGINew_SetReg1( pVBInfo->P3d4 , 0x52 , data ) ;
+    	XGINew_SetReg1( pVBInfo->P3d4 , 0x51 , 0x02 ) ;
+    }
+    else
+    {
+    if ( data & 0x40 )
+        data = 0x2c ;
+    else
+        data = 0x6c ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x52 , data ) ;
+    }
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetVCLKState */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetVCLKState(  PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo , USHORT RefreshRateTableIndex,PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT data ,
+           data2 = 0 ;
+    SHORT  VCLK ;
+
+    UCHAR  index ;
+
+    if ( ModeNo <= 0x13 )
+        VCLK = 0 ;
+    else
+    {
+        index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRTVCLK ;
+        index &= IndexMask ;
+        VCLK = pVBInfo->VCLKData[ index ].CLOCK ;
+    }
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x32 ) ;
+    data &= 0xf3 ;
+    if ( VCLK >= 200 )
+        data |= 0x0c ;	/* VCLK > 200 */
+
+    if ( HwDeviceExtension->jChipType >= XG20 )
+        data &= ~0x04 ; /* 2 pixel mode */
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x32 , data ) ;
+
+    if ( HwDeviceExtension->jChipType < XG20 )
+    {
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x1F ) ;
+    data &= 0xE7 ;
+    if ( VCLK < 200 )
+        data |= 0x10 ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1F , data ) ;
+    }
+
+/*  Jong for Adavantech LCD ripple issue
+    if ( ( VCLK >= 0 ) && ( VCLK < 135 ) )
+        data2 = 0x03 ;
+    else if ( ( VCLK >= 135 ) && ( VCLK < 160 ) )
+        data2 = 0x02 ;
+    else if ( ( VCLK >= 160 ) && ( VCLK < 260 ) )
+        data2 = 0x01 ;
+    else if ( VCLK > 260 )
+          data2 = 0x00 ;
+*/
+    data2 = 0x00 ;
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x07 , 0xFC , data2 ) ;
+    if (HwDeviceExtension->jChipType >= XG27 )
+    {
+      XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x40 , 0xFC , data2&0x03 ) ;
+    }
+
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_VesaLowResolution */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+/*void XGI_VesaLowResolution( USHORT ModeNo , USHORT ModeIdIndex ,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT modeflag;
+
+    if ( ModeNo > 0x13 )
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    else
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+
+    if ( ModeNo > 0x13 )
+    {
+        if ( modeflag & DoubleScanMode )
+        {
+            if ( modeflag & HalfDCLK )
+            {
+                if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                {
+                    if ( !( pVBInfo->VBInfo & SetCRT2ToRAMDAC ) )
+                    {
+                        if ( pVBInfo->VBInfo & SetInSlaveMode )
+                        {
+                            XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x01 , 0xf7 , 0x00 ) ;
+                            XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0f , 0x7f , 0x00 ) ;
+                            return ;
+                        }
+                    }
+                }
+                XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0f , 0xff , 0x80 ) ;
+                XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x01 , 0xf7 , 0x00 ) ;
+                return ;
+            }
+        }
+    }
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0f , 0x7f , 0x00 ) ;
+}
+*/
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_LoadDAC */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_LoadDAC( USHORT ModeNo , USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT data , data2 , time ,
+           i  , j , k , m , n , o ,
+           si , di , bx , dl , al , ah , dh ,
+           *table = NULL ;
+
+    if ( ModeNo <= 0x13 )
+        data = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    else
+        data = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+
+    data &= DACInfoFlag ;
+    time = 64 ;
+
+    if ( data == 0x00 )
+        table = XGINew_MDA_DAC ;
+    else if ( data == 0x08 )
+        table = XGINew_CGA_DAC ;
+    else if ( data == 0x10 )
+        table = XGINew_EGA_DAC ;
+    else if ( data == 0x18 )
+    {
+        time = 256 ;
+        table = XGINew_VGA_DAC ;
+    }
+
+    if ( time == 256 )
+        j = 16 ;
+    else
+        j = time ;
+
+    XGINew_SetReg3( pVBInfo->P3c6 , 0xFF ) ;
+    XGINew_SetReg3( pVBInfo->P3c8 , 0x00 ) ;
+
+    for( i = 0 ; i < j ; i++ )
+    {
+        data = table[ i ] ;
+
+        for( k = 0 ; k < 3 ; k++ )
+        {
+            data2 = 0 ;
+
+            if ( data & 0x01 )
+                data2 = 0x2A ;
+
+            if ( data & 0x02 )
+                data2 += 0x15 ;
+
+            XGINew_SetReg3( pVBInfo->P3c9 , data2 ) ;
+            data = data >> 2 ;
+        }
+    }
+
+    if ( time == 256 )
+    {
+        for( i = 16 ; i < 32 ; i++ )
+        {
+            data = table[ i ] ;
+
+            for( k = 0 ; k < 3 ; k++ )
+                XGINew_SetReg3( pVBInfo->P3c9 , data ) ;
+        }
+
+        si = 32 ;
+
+        for( m = 0 ; m < 9 ; m++ )
+        {
+            di = si ;
+            bx = si + 0x04 ;
+            dl = 0 ;
+
+            for( n = 0 ; n < 3 ; n++ )
+            {
+                for( o = 0 ; o < 5 ; o++ )
+                {
+                    dh = table[ si ] ;
+                    ah = table[ di ] ;
+                    al = table[ bx ] ;
+                    si++ ;
+                    XGI_WriteDAC( dl , ah , al , dh, pVBInfo ) ;
+                }
+
+                si -= 2 ;
+
+                for( o = 0 ; o < 3 ; o++ )
+                {
+                    dh = table[ bx ] ;
+                    ah = table[ di ] ;
+                    al = table[ si ] ;
+                    si-- ;
+                    XGI_WriteDAC( dl , ah , al , dh, pVBInfo ) ;
+                }
+
+                dl++ ;
+            }
+
+            si += 5 ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_WriteDAC */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_WriteDAC( USHORT dl , USHORT ah , USHORT al , USHORT dh,PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT temp , bh , bl ;
+
+    bh = ah ;
+    bl = al ;
+
+    if ( dl != 0 )
+    {
+        temp = bh ;
+        bh = dh ;
+        dh = temp ;
+        if ( dl == 1 )
+        {
+            temp = bl ;
+            bl = dh ;
+            dh = temp ;
+        }
+        else
+        {
+            temp = bl ;
+            bl = bh ;
+            bh = temp ;
+        }
+    }
+    XGINew_SetReg3( pVBInfo->P3c9 , ( USHORT )dh ) ;
+    XGINew_SetReg3( pVBInfo->P3c9 , ( USHORT )bh ) ;
+    XGINew_SetReg3( pVBInfo->P3c9 , ( USHORT )bl ) ;
+}
+
+#if 0
+/* --------------------------------------------------------------------- */
+/* Function : XGI_ClearBuffer */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_ClearBuffer( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo, PVB_DEVICE_INFO  pVBInfo)
+{
+    PVOID VideoMemoryAddress = ( PVOID )HwDeviceExtension->pjVideoMemoryAddress ;
+    ULONG AdapterMemorySize  = ( ULONG )HwDeviceExtension->ulVideoMemorySize ;
+    PUSHORT pBuffer ;
+#ifndef LINUX_XF86
+    int i ;
+#endif
+
+    if ( pVBInfo->ModeType >= ModeEGA )
+    {
+        if ( ModeNo > 0x13 )
+        {
+            AdapterMemorySize = 0x40000 ;	/* clear 256k */
+            /* GetDRAMSize( HwDeviceExtension ) ; */
+            XGI_SetMemory( VideoMemoryAddress , AdapterMemorySize , 0 ) ;
+        }
+        else
+        {
+/*
+            pBuffer = VideoMemoryAddress ;
+            for( i = 0 ; i < 0x4000 ; i++ )
+                pBuffer[ i ] = 0x0000 ;
+*/
+        }
+    }
+    else
+    {
+        pBuffer = VideoMemoryAddress ;
+        if ( pVBInfo->ModeType < ModeCGA )
+        {
+/*
+            for ( i = 0 ; i < 0x4000 ; i++ )
+                pBuffer[ i ] = 0x0720 ;
+*/
+        }
+        else
+            XGI_SetMemory( VideoMemoryAddress , 0x8000 , 0 ) ;
+    }
+}
+
+#endif
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLCDAGroup */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetLCDAGroup( USHORT ModeNo , USHORT ModeIdIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT RefreshRateTableIndex ;
+    /* USHORT temp ; */
+
+    /* pVBInfo->SelectCRT2Rate = 0 ; */
+
+    pVBInfo->SetFlag |= ProgrammingCRT2 ;
+    RefreshRateTableIndex = XGI_GetRatePtrCRT2( HwDeviceExtension, ModeNo , ModeIdIndex, pVBInfo ) ;
+    XGI_GetLVDSResInfo(  ModeNo , ModeIdIndex,  pVBInfo ) ;
+    XGI_GetLVDSData( ModeNo , ModeIdIndex , RefreshRateTableIndex,  pVBInfo);
+    XGI_ModCRT1Regs( ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+    XGI_SetLVDSRegs( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetCRT2ECLK( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLVDSResInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetLVDSResInfo( USHORT ModeNo , USHORT ModeIdIndex,PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT resindex , xres , yres , modeflag ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;	/* si+St_ResInfo */
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;	/* si+Ext_ResInfo */
+    }
+
+
+    /* if ( ModeNo > 0x13 ) */
+    /* modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ; */
+    /* else */
+    /* modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ; */
+
+    if ( ModeNo <= 0x13 )
+    {
+        resindex = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;	/* si+St_ResInfo */
+    }
+    else
+    {
+        resindex = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;	/* si+Ext_ResInfo */
+    }
+
+    /* resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ; */
+
+    if ( ModeNo <= 0x13 )
+    {
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->StResInfo[ resindex ].VTotal ;
+    }
+    else
+    {
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->ModeResInfo[ resindex ].VTotal ;
+    }
+    if ( ModeNo > 0x13 )
+    {
+        if ( modeflag & HalfDCLK )
+            xres = xres << 1 ;
+
+        if ( modeflag & DoubleScanMode )
+            yres = yres << 1 ;
+    }
+    /* if ( modeflag & Charx8Dot ) */
+    /* { */
+
+    if ( xres == 720 )
+        xres = 640 ;
+
+    /* } */
+    pVBInfo->VGAHDE = xres ;
+    pVBInfo->HDE = xres ;
+    pVBInfo->VGAVDE = yres ;
+    pVBInfo->VDE = yres ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLVDSData */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetLVDSData(  USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT tempbx ;
+    XGI330_LVDSDataStruct *LCDPtr = NULL ;
+    XGI330_CHTVDataStruct  *TVPtr = NULL ;
+
+    tempbx = 2 ;
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+    {
+        LCDPtr = ( XGI330_LVDSDataStruct * )XGI_GetLcdPtr( tempbx, ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo) ;
+        pVBInfo->VGAHT = LCDPtr->VGAHT ;
+        pVBInfo->VGAVT = LCDPtr->VGAVT ;
+        pVBInfo->HT = LCDPtr->LCDHT ;
+        pVBInfo->VT = LCDPtr->LCDVT ;
+    }
+    if ( pVBInfo->IF_DEF_CH7017 == 1 )
+    {
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            TVPtr = ( XGI330_CHTVDataStruct * )XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+            pVBInfo->VGAHT = TVPtr->VGAHT ;
+            pVBInfo->VGAVT = TVPtr->VGAVT ;
+            pVBInfo->HT = TVPtr->LCDHT ;
+            pVBInfo->VT = TVPtr->LCDVT ;
+        }
+    }
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+    {
+        if ( !( pVBInfo->LCDInfo & ( SetLCDtoNonExpanding | EnableScalingLCD ) ) )
+        {
+            if ( ( pVBInfo->LCDResInfo == Panel1024x768 ) || ( pVBInfo->LCDResInfo == Panel1024x768x75 ) )
+            {
+                pVBInfo->HDE = 1024 ;
+                pVBInfo->VDE = 768 ;
+            }
+            else if ( ( pVBInfo->LCDResInfo == Panel1280x1024 ) || ( pVBInfo->LCDResInfo == Panel1280x1024x75 ) )
+            {
+                pVBInfo->HDE = 1280 ;
+                pVBInfo->VDE = 1024 ;
+            }
+            else if ( pVBInfo->LCDResInfo == Panel1400x1050 )
+            {
+                pVBInfo->HDE = 1400 ;
+                pVBInfo->VDE = 1050 ;
+            }
+            else
+            {
+                pVBInfo->HDE = 1600 ;
+                pVBInfo->VDE = 1200 ;
+            }
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_ModCRT1Regs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_ModCRT1Regs( USHORT ModeNo , USHORT ModeIdIndex ,
+                        USHORT RefreshRateTableIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo )
+{
+    UCHAR index ;
+    USHORT tempbx , i ;
+    XGI_LVDSCRT1HDataStruct  *LCDPtr = NULL ;
+    XGI_LVDSCRT1VDataStruct  *LCDPtr1 =NULL ;
+    /* XGI330_CHTVDataStruct *TVPtr = NULL ; */
+    XGI_CH7007TV_TimingHStruct *CH7007TV_TimingHPtr = NULL;
+    XGI_CH7007TV_TimingVStruct *CH7007TV_TimingVPtr = NULL;
+
+    if( ModeNo <= 0x13 )
+        index = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+    else
+        index = pVBInfo->RefIndex[RefreshRateTableIndex].Ext_CRT2CRTC;
+
+    index= index & IndexMask ;
+
+    if ( ( pVBInfo->IF_DEF_ScaleLCD == 0 ) || ( ( pVBInfo->IF_DEF_ScaleLCD == 1 ) && ( !( pVBInfo->LCDInfo & EnableScalingLCD ) ) ) )
+    {
+        tempbx = 0 ;
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+        {
+            LCDPtr = ( XGI_LVDSCRT1HDataStruct * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+
+            for( i = 0 ; i < 8 ; i++ )
+                pVBInfo->TimingH[ 0 ].data[ i ] = LCDPtr[ 0 ].Reg[ i ] ;
+        }
+
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            {
+                CH7007TV_TimingHPtr = ( XGI_CH7007TV_TimingHStruct *)XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+
+                for( i = 0 ; i < 8 ; i++ )
+                    pVBInfo->TimingH[ 0 ].data[ i ] = CH7007TV_TimingHPtr[ 0 ].data[ i ] ;
+            }
+        }
+
+        /* if ( pVBInfo->IF_DEF_CH7017 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+                TVPtr = ( XGI330_CHTVDataStruct *)XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+        } */
+
+        XGI_SetCRT1Timing_H(pVBInfo,HwDeviceExtension) ;
+
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , CH7007TV_TimingHPtr[ 0 ].data[ 8 ] ) ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x2F , CH7007TV_TimingHPtr[ 0 ].data[ 9 ] ) ;
+        }
+
+        tempbx = 1 ;
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+        {
+            LCDPtr1 = ( XGI_LVDSCRT1VDataStruct * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+            for( i = 0 ; i < 7 ; i++ )
+                pVBInfo->TimingV[ 0 ].data[ i ] = LCDPtr1[ 0 ].Reg[ i ] ;
+        }
+
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            {
+                CH7007TV_TimingVPtr = ( XGI_CH7007TV_TimingVStruct *)XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+
+                for( i = 0 ; i < 7 ; i++ )
+                    pVBInfo->TimingV[ 0 ].data[ i ] = CH7007TV_TimingVPtr[ 0 ].data[ i ] ;
+            }
+        }
+        /* if ( pVBInfo->IF_DEF_CH7017 == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+                TVPtr = ( XGI330_CHTVDataStruct *)XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+        } */
+
+        XGI_SetCRT1Timing_V( ModeIdIndex , ModeNo , pVBInfo) ;
+
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+    	    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x33 , ~0x01 , CH7007TV_TimingVPtr[ 0 ].data[ 7 ]&0x01 ) ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , CH7007TV_TimingVPtr[ 0 ].data[8 ] ) ;
+    	    XGINew_SetReg1( pVBInfo->P3c4 , 0x3F , CH7007TV_TimingVPtr[ 0 ].data[9 ] ) ;
+
+        }
+    }
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLVDSRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetLVDSRegs( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT tempbx , tempax , tempcx , tempdx , push1 , push2 , modeflag ;
+    unsigned long temp , temp1 , temp2 , temp3 , push3 ;
+    XGI330_LCDDataDesStruct  *LCDPtr = NULL ;
+    XGI330_LCDDataDesStruct2  *LCDPtr1 = NULL ;
+
+    if ( ModeNo > 0x13 )
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    else
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+
+    if ( !( pVBInfo->SetFlag & Win9xDOSMode ) )
+    {
+        if ( ( pVBInfo->IF_DEF_CH7017 == 0 ) || ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) )
+        {
+            if ( pVBInfo->IF_DEF_OEMUtil == 1 )
+            {
+    	        tempbx = 8 ;
+    	        LCDPtr = ( XGI330_LCDDataDesStruct * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+            }
+
+            if ( ( pVBInfo->IF_DEF_OEMUtil == 0 ) || ( LCDPtr == 0 ) )
+            {
+                tempbx = 3 ;
+                if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                    LCDPtr1 = ( XGI330_LCDDataDesStruct2 * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+                else
+                    LCDPtr = ( XGI330_LCDDataDesStruct * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+            }
+
+            XGI_GetLCDSync( &tempax , &tempbx ,pVBInfo) ;
+            push1 = tempbx ;
+            push2 = tempax ;
+
+            /* GetLCDResInfo */
+            if ( ( pVBInfo->LCDResInfo == Panel1024x768 ) || ( pVBInfo->LCDResInfo == Panel1024x768x75 ) )
+            {
+                tempax = 1024 ;
+                tempbx = 768 ;
+            }
+            else if ( ( pVBInfo->LCDResInfo == Panel1280x1024 ) || ( pVBInfo->LCDResInfo == Panel1280x1024x75 ) )
+            {
+                tempax = 1280 ;
+                tempbx = 1024 ;
+            }
+            else if ( pVBInfo->LCDResInfo == Panel1400x1050 )
+            {
+                tempax = 1400 ;
+                tempbx = 1050 ;
+            }
+            else
+            {
+                tempax = 1600 ;
+                tempbx = 1200 ;
+            }
+
+            if ( pVBInfo->LCDInfo & SetLCDtoNonExpanding )
+            {
+                pVBInfo->HDE=tempax;
+                pVBInfo->VDE=tempbx;
+                pVBInfo->VGAHDE=tempax;
+                pVBInfo->VGAVDE=tempbx;
+            }
+
+            if ( ( pVBInfo->IF_DEF_ScaleLCD == 1 ) && ( pVBInfo->LCDInfo & EnableScalingLCD ) )
+            {
+                tempax=pVBInfo->HDE;
+                tempbx=pVBInfo->VDE;
+            }
+
+            tempax = pVBInfo->HT ;
+
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempbx = LCDPtr1->LCDHDES ;
+            else
+                tempbx = LCDPtr->LCDHDES ;
+
+            tempcx = pVBInfo->HDE ;
+            tempbx = tempbx & 0x0fff ;
+            tempcx += tempbx ;
+
+            if ( tempcx >= tempax )
+                tempcx -= tempax ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x1A , tempbx & 0x07 ) ;
+
+            tempcx = tempcx >> 3 ;
+            tempbx = tempbx >> 3 ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x16 , ( USHORT )( tempbx & 0xff ) ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x17 , ( USHORT )( tempcx & 0xff ) ) ;
+
+            tempax = pVBInfo->HT ;
+
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempbx = LCDPtr1->LCDHRS ;
+            else
+                tempbx = LCDPtr->LCDHRS ;
+
+            tempcx = push2 ;
+
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempcx = LCDPtr1->LCDHSync ;
+
+            tempcx += tempbx ;
+
+            if ( tempcx >= tempax )
+                tempcx -= tempax ;
+
+            tempax = tempbx & 0x07 ;
+            tempax = tempax >> 5 ;
+            tempcx = tempcx >> 3 ;
+            tempbx = tempbx >> 3 ;
+
+            tempcx &= 0x1f ;
+            tempax |= tempcx ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x15 , tempax ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x14 , ( USHORT )( tempbx & 0xff ) ) ;
+
+            tempax = pVBInfo->VT ;
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempbx = LCDPtr1->LCDVDES ;
+            else
+                tempbx = LCDPtr->LCDVDES ;
+            tempcx = pVBInfo->VDE ;
+
+            tempbx = tempbx & 0x0fff ;
+            tempcx += tempbx ;
+            if ( tempcx >= tempax )
+                tempcx -= tempax ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x1b , ( USHORT )( tempbx & 0xff ) ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x1c , ( USHORT )( tempcx & 0xff ) ) ;
+
+            tempbx = ( tempbx >> 8 ) & 0x07 ;
+            tempcx = ( tempcx >> 8 ) & 0x07 ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x1d , ( USHORT )( ( tempcx << 3 ) | tempbx ) ) ;
+
+            tempax = pVBInfo->VT ;
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempbx = LCDPtr1->LCDVRS ;
+            else
+                tempbx = LCDPtr->LCDVRS ;
+
+            /* tempbx = tempbx >> 4 ; */
+              tempcx = push1 ;
+
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                tempcx = LCDPtr1->LCDVSync ;
+
+            tempcx += tempbx ;
+            if ( tempcx >= tempax )
+                tempcx -= tempax ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x18 , ( USHORT )( tempbx & 0xff ) ) ;
+            XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x19 , ~0x0f , ( USHORT )( tempcx & 0x0f ) ) ;
+
+            tempax = ( ( tempbx >> 8 ) & 0x07 ) << 3 ;
+
+            tempbx = pVBInfo->VGAVDE ;
+            if ( tempbx != pVBInfo->VDE )
+                tempax |= 0x40 ;
+
+            if ( pVBInfo->LCDInfo & EnableLVDSDDA )
+                tempax |= 0x40 ;
+
+            XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x1a , 0x07 , tempax ) ;
+
+            tempcx = pVBInfo->VGAVT ;
+            tempbx = pVBInfo->VDE ;
+            tempax = pVBInfo->VGAVDE ;
+            tempcx -= tempax ;
+
+            temp = tempax ;            /* 0430 ylshieh */
+            temp1 = ( temp << 18 ) / tempbx ;
+
+            tempdx = ( USHORT )( ( temp << 18 ) % tempbx ) ;
+
+            if ( tempdx != 0 )
+            temp1 += 1 ;
+
+            temp2 = temp1 ;
+            push3 = temp2 ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x37 , ( USHORT )( temp2 & 0xff ) ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x36 , ( USHORT )( ( temp2 >> 8 ) & 0xff ) ) ;
+
+            tempbx = ( USHORT )( temp2 >> 16 ) ;
+            tempax = tempbx & 0x03 ;
+
+            tempbx = pVBInfo->VGAVDE ;
+            if ( tempbx == pVBInfo->VDE )
+                tempax |= 0x04 ;
+
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x35 , tempax ) ;
+
+            if ( pVBInfo->VBType & VB_XGI301C )
+            {
+                temp2 = push3 ;
+      	        XGINew_SetReg1( pVBInfo->Part4Port , 0x3c , ( USHORT )( temp2 & 0xff ) ) ;
+      	        XGINew_SetReg1( pVBInfo->Part4Port , 0x3b , ( USHORT )( ( temp2 >> 8 ) & 0xff ) ) ;
+      	        tempbx = ( USHORT )( temp2 >> 16 ) ;
+      	        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x3a , ~0xc0 , ( USHORT )( ( tempbx & 0xff ) << 6 ) ) ;
+
+                tempcx = pVBInfo->VGAVDE ;
+                if ( tempcx == pVBInfo->VDE )
+                    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x30 , ~0x0c , 0x00 ) ;
+                else
+                    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x30 , ~0x0c , 0x08 ) ;
+            }
+
+            tempcx = pVBInfo->VGAHDE ;
+            tempbx = pVBInfo->HDE ;
+
+            temp1 = tempcx << 16 ;
+
+            tempax = ( USHORT )( temp1 / tempbx ) ;
+
+            if ( ( tempbx & 0xffff ) == ( tempcx & 0xffff ) )
+                tempax = 65535 ;
+
+            temp3 = tempax ;
+            temp1 = pVBInfo->VGAHDE << 16 ;
+
+            temp1 /= temp3 ;
+            temp3 = temp3 << 16 ;
+            temp1 -= 1 ;
+
+            temp3 = ( temp3 & 0xffff0000 ) + ( temp1 & 0xffff ) ;
+
+            tempax = ( USHORT )( temp3 & 0xff ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x1f , tempax ) ;
+
+            temp1 = pVBInfo->VGAVDE << 18 ;
+            temp1 = temp1 / push3 ;
+            tempbx = ( USHORT )( temp1 & 0xffff ) ;
+
+            if ( pVBInfo->LCDResInfo == Panel1024x768 )
+                tempbx -= 1 ;
+
+            tempax = ( ( tempbx >> 8 ) & 0xff ) << 3 ;
+            tempax |= ( USHORT )( ( temp3 >> 8 ) & 0x07 ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x20 , ( USHORT )( tempax & 0xff ) ) ;
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x21 , ( USHORT )( tempbx & 0xff ) ) ;
+
+            temp3 = temp3 >> 16 ;
+
+            if ( modeflag & HalfDCLK )
+                temp3 = temp3 >> 1 ;
+
+            XGINew_SetReg1(pVBInfo->Part1Port , 0x22 , ( USHORT )( ( temp3 >> 8 ) & 0xff ) ) ;
+            XGINew_SetReg1(pVBInfo->Part1Port , 0x23 , ( USHORT )( temp3 & 0xff ) ) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2ECLK */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT2ECLK( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO  pVBInfo )
+{
+    UCHAR di_0 , di_1 , tempal ;
+    int i ;
+
+    tempal = XGI_GetVCLKPtr( RefreshRateTableIndex , ModeNo , ModeIdIndex, pVBInfo ) ;
+    XGI_GetVCLKLen( tempal , &di_0 , &di_1, pVBInfo ) ;
+    XGI_GetLCDVCLKPtr( &di_0 , &di_1, pVBInfo ) ;
+
+    for( i = 0 ; i < 4 ; i++ )
+    {
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x31 , ~0x30 , ( USHORT )( 0x10 * i ) ) ;
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2b , di_0 ) ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2c , di_1 ) ;
+        }
+        else if ( ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) ) && ( !( pVBInfo->VBInfo & SetInSlaveMode ) ) )
+        {
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2e , di_0 ) ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2f , di_1 ) ;
+        }
+        else
+        {
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2b , di_0 ) ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x2c , di_1 ) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_UpdateModeInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_UpdateModeInfo( PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT tempcl ,
+           tempch ,
+           temp ,
+           tempbl ,
+           tempax ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        tempcl = 0 ;
+        tempch = 0 ;
+        temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x01 ) ;
+
+        if ( !( temp & 0x20 ) )
+        {
+            temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x17 ) ;
+            if ( temp & 0x80 )
+            {
+                if ( ( HwDeviceExtension->jChipType >= XG20 ) || ( HwDeviceExtension->jChipType >= XG40 ) )
+                    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x53 ) ;
+                else
+                    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x63 ) ;
+
+                if ( !( temp & 0x40 ) )
+                    tempcl |= ActiveCRT1 ;
+            }
+        }
+
+        temp = XGINew_GetReg1( pVBInfo->Part1Port , 0x2e ) ;
+        temp &= 0x0f ;
+
+        if ( !( temp == 0x08 ) )
+        {
+            tempax = XGINew_GetReg1( pVBInfo->Part1Port , 0x13 ) ;	/* Check ChannelA by Part1_13 [2003/10/03] */
+            if ( tempax & 0x04 )
+               	tempcl = tempcl | ActiveLCD ;
+
+            temp &= 0x05 ;
+
+            if ( !( tempcl & ActiveLCD ) )
+            	if ( temp == 0x01 )
+                    tempcl |= ActiveCRT2 ;
+
+            if ( temp == 0x04 )
+                tempcl |= ActiveLCD ;
+
+            if ( temp == 0x05 )
+            {
+                temp = XGINew_GetReg1( pVBInfo->Part2Port , 0x00 ) ;
+
+                if( !( temp & 0x08 ) )
+                    tempch |= ActiveAVideo ;
+
+                if ( !( temp & 0x04 ) )
+                    tempch |= ActiveSVideo ;
+
+                if ( temp & 0x02 )
+                    tempch |= ActiveSCART ;
+
+                if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+                {
+                    if ( temp & 0x01 )
+                        tempch |= ActiveHiTV ;
+                }
+
+                if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+                {
+                    temp = XGINew_GetReg1( pVBInfo->Part2Port , 0x4d ) ;
+
+                    if ( temp & 0x10 )
+                        tempch |= ActiveYPbPr ;
+                }
+
+                if ( tempch != 0 )
+                    tempcl |= ActiveTV ;
+            }
+        }
+
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x3d ) ;
+        if ( tempcl & ActiveLCD )
+        {
+            if ( ( pVBInfo->SetFlag & ReserveTVOption ) )
+            {
+                if ( temp & ActiveTV )
+                    tempcl |= ActiveTV ;
+            }
+        }
+        temp = tempcl ;
+        tempbl = ~ModeSwitchStatus ;
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x3d , tempbl , temp ) ;
+
+        if ( !( pVBInfo->SetFlag & ReserveTVOption ) )
+            XGINew_SetReg1( pVBInfo->P3d4 , 0x3e , tempch ) ;
+    }
+    else
+    {
+        return ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVGAType */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetVGAType( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO  pVBInfo)
+{
+    /*
+    if ( HwDeviceExtension->jChipType >= XG20 )
+    {
+        pVBInfo->Set_VGAType = XG20;
+    }
+    else if ( HwDeviceExtension->jChipType >= XG40 )
+    {
+        pVBInfo->Set_VGAType = VGA_XGI340 ;
+    }
+    */
+    pVBInfo->Set_VGAType = HwDeviceExtension->jChipType;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVBType */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetVBType(PVB_DEVICE_INFO  pVBInfo)
+{
+    USHORT flag , tempbx , tempah ;
+
+    if ( pVBInfo->IF_DEF_CH7007 == 1 )
+    {
+        pVBInfo->VBType = VB_CH7007 ;
+        return;
+    }
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        tempbx = VB_XGI302B ;
+        flag = XGINew_GetReg1( pVBInfo->Part4Port , 0x00 ) ;
+        if ( flag != 0x02 )
+        {
+            tempbx = VB_XGI301 ;
+            flag = XGINew_GetReg1( pVBInfo->Part4Port , 0x01 ) ;
+            if ( flag >= 0xB0 )
+            {
+                tempbx = VB_XGI301B ;
+                if ( flag >= 0xC0 )
+                {
+                    tempbx = VB_XGI301C ;
+                    if ( flag >= 0xD0 )
+                    {
+                        tempbx = VB_XGI301LV ;
+                        if ( flag >= 0xE0 )
+                        {
+                            tempbx = VB_XGI302LV ;
+                            tempah = XGINew_GetReg1( pVBInfo->Part4Port , 0x39 ) ;
+                            if ( tempah != 0xFF )
+                                tempbx = VB_XGI301C ;
+                        }
+                    }
+                }
+
+                if ( tempbx & ( VB_XGI301B | VB_XGI302B ) )
+                {
+                    flag = XGINew_GetReg1( pVBInfo->Part4Port , 0x23 ) ;
+
+                    if ( !( flag & 0x02 ) )
+                        tempbx = tempbx | VB_NoLCD ;
+                }
+            }
+        }
+        pVBInfo->VBType = tempbx ;
+    }
+/*
+    else if ( pVBInfo->IF_DEF_CH7017 == 1 )
+        pVBInfo->VBType = VB_CH7017 ;
+    else  //LVDS
+        pVBInfo->VBType = VB_LVDS_NS ;
+*/
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVBInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetVBInfo( USHORT ModeNo , USHORT ModeIdIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT tempax ,
+           push ,
+           tempbx ,
+           temp ,
+           modeflag ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    pVBInfo->SetFlag = 0 ;
+    pVBInfo->ModeType = modeflag & ModeInfoFlag ;
+    tempbx = 0 ;
+
+    if ( pVBInfo->VBType & 0xFFFF )
+    {
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x30 ) ;           /* Check Display Device */
+        tempbx = tempbx | temp ;
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x31 ) ;
+        push = temp ;
+        push = push << 8 ;
+        tempax = temp << 8 ;
+        tempbx = tempbx | tempax ;
+        temp = ( SetCRT2ToDualEdge | SetCRT2ToYPbPr | SetCRT2ToLCDA | SetInSlaveMode | DisableCRT2Display ) ;
+        temp = 0xFFFF ^ temp ;
+        tempbx &= temp ;
+
+        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ;
+
+        if ( pVBInfo->IF_DEF_LCDA == 1 )
+        {
+
+            if ( ( pVBInfo->Set_VGAType >= XG20 ) || ( pVBInfo->Set_VGAType >= XG40 ))
+            {
+                if ( pVBInfo->IF_DEF_LVDS == 0 )
+                {
+                    /* if ( ( pVBInfo->VBType & VB_XGI302B ) || ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) || ( pVBInfo->VBType & VB_XGI301C ) ) */
+                    if ( pVBInfo->VBType & ( VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                    {
+                        if ( temp & EnableDualEdge )
+                        {
+                            tempbx |= SetCRT2ToDualEdge ;
+
+                            if ( temp & SetToLCDA )
+                                tempbx |= SetCRT2ToLCDA ;
+                        }
+                    }
+                }
+                else if ( pVBInfo->IF_DEF_CH7017 == 1 )
+                {
+                    if ( pVBInfo->VBType & VB_CH7017 )
+                    {
+                        if ( temp & EnableDualEdge )
+                        {
+                            tempbx |= SetCRT2ToDualEdge ;
+
+                            if ( temp & SetToLCDA )
+                                tempbx |= SetCRT2ToLCDA ;
+                        }
+                    }
+                }
+            }
+        }
+
+        if ( pVBInfo->IF_DEF_YPbPr == 1 )
+        {
+            if ( ( ( pVBInfo->IF_DEF_LVDS == 0 ) && ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) || ( pVBInfo->VBType & VB_XGI301C ) ) )
+            || ( ( pVBInfo->IF_DEF_CH7017 == 1 ) && ( pVBInfo->VBType&VB_CH7017 ) ) || ( (pVBInfo->IF_DEF_CH7007 == 1) && (pVBInfo->VBType&VB_CH7007) ) )    /* [Billy] 07/05/04 */
+            {
+                if ( temp & SetYPbPr )	/* temp = CR38 */
+                {
+                    if ( pVBInfo->IF_DEF_HiVision == 1 )
+                    {
+                        temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x35 ) ;  /* shampoo add for new scratch */
+                        temp &= YPbPrMode ;
+                        tempbx |= SetCRT2ToHiVisionTV ;
+
+                        if ( temp != YPbPrMode1080i ) {
+                            tempbx &= ( ~SetCRT2ToHiVisionTV ) ;
+                            tempbx |= SetCRT2ToYPbPr ; }
+                    }
+
+                    /* tempbx |= SetCRT2ToYPbPr ; */
+                }
+            }
+        }
+
+        tempax = push ;  /* restore CR31 */
+
+        if ( pVBInfo->IF_DEF_LVDS == 0 )
+        {
+            if ( pVBInfo->IF_DEF_YPbPr == 1 )
+            {
+                if ( pVBInfo->IF_DEF_HiVision == 1 )
+                    temp = 0x09FC ;
+                else
+                    temp = 0x097C ;
+            }
+            else
+            {
+                if ( pVBInfo->IF_DEF_HiVision == 1 )
+                    temp = 0x01FC ;
+                else
+                    temp = 0x017C ;
+            }
+        }
+        else	/* 3nd party chip */
+        {
+            if ( pVBInfo->IF_DEF_CH7017 == 1 )
+                temp = ( SetCRT2ToTV | SetCRT2ToLCD | SetCRT2ToLCDA ) ;
+            else if ( pVBInfo->IF_DEF_CH7007 == 1 )  /* [Billy] 07/05/03 */
+            {
+                temp = SetCRT2ToTV ;
+            }
+            else
+                temp = SetCRT2ToLCD ;
+        }
+
+        if ( !( tempbx & temp ) )
+        {
+            tempax |= DisableCRT2Display ;
+            tempbx = 0 ;
+        }
+
+        if ( pVBInfo->IF_DEF_LCDA == 1 )	/* Select Display Device */
+        {
+            if ( !( pVBInfo->VBType & VB_NoLCD ) )
+            {
+                if ( tempbx & SetCRT2ToLCDA )
+                {
+                    if ( tempbx & SetSimuScanMode )
+                        tempbx &= ( ~( SetCRT2ToLCD | SetCRT2ToRAMDAC | SwitchToCRT2 ) ) ;
+                    else
+                        tempbx &= ( ~( SetCRT2ToLCD | SetCRT2ToRAMDAC | SetCRT2ToTV | SwitchToCRT2 ) ) ;
+                }
+            }
+        }
+
+        /* shampoo add */
+        if ( !( tempbx & ( SwitchToCRT2 | SetSimuScanMode ) ) )	/* for driver abnormal */
+        {
+            if ( pVBInfo->IF_DEF_CRT2Monitor == 1 )
+            {
+                if ( tempbx & SetCRT2ToRAMDAC )
+                {
+                    tempbx &= ( 0xFF00 | SetCRT2ToRAMDAC | SwitchToCRT2 | SetSimuScanMode ) ;
+                    tempbx &= ( 0x00FF | ( ~SetCRT2ToYPbPr ) ) ;
+                }
+            }
+            else
+                tempbx &= ( ~( SetCRT2ToRAMDAC | SetCRT2ToLCD | SetCRT2ToTV ) ) ;
+        }
+
+        if ( !( pVBInfo->VBType & VB_NoLCD ) )
+        {
+            if ( tempbx & SetCRT2ToLCD )
+            {
+                tempbx &= ( 0xFF00 | SetCRT2ToLCD | SwitchToCRT2 | SetSimuScanMode ) ;
+                tempbx &= ( 0x00FF | ( ~SetCRT2ToYPbPr ) ) ;
+            }
+        }
+
+        if ( tempbx & SetCRT2ToSCART )
+        {
+            tempbx &= ( 0xFF00 | SetCRT2ToSCART | SwitchToCRT2 | SetSimuScanMode ) ;
+            tempbx &= ( 0x00FF | ( ~SetCRT2ToYPbPr ) ) ;
+        }
+
+        if ( pVBInfo->IF_DEF_YPbPr == 1 )
+        {
+            if ( tempbx & SetCRT2ToYPbPr )
+                tempbx &= ( 0xFF00 | SwitchToCRT2 | SetSimuScanMode ) ;
+        }
+
+        if ( pVBInfo->IF_DEF_HiVision == 1 )
+        {
+            if ( tempbx & SetCRT2ToHiVisionTV )
+                tempbx &= ( 0xFF00 | SetCRT2ToHiVisionTV | SwitchToCRT2 | SetSimuScanMode ) ;
+        }
+
+        if ( tempax & DisableCRT2Display )	/* Set Display Device Info */
+        {
+            if ( !( tempbx & ( SwitchToCRT2 | SetSimuScanMode ) ) )
+                tempbx = DisableCRT2Display ;
+        }
+
+        if ( !( tempbx & DisableCRT2Display ) )
+        {
+            if ( ( !( tempbx & DriverMode ) ) || ( !( modeflag & CRT2Mode ) ) )
+            {
+                if ( pVBInfo->IF_DEF_LCDA == 1 )
+      	        {
+                    if ( !( tempbx & SetCRT2ToLCDA ) )
+                        tempbx |= ( SetInSlaveMode | SetSimuScanMode ) ;
+                }
+
+                if ( pVBInfo->IF_DEF_VideoCapture == 1 )
+                {
+                    if ( ( ( HwDeviceExtension->jChipType == XG40 ) && ( pVBInfo->Set_VGAType == XG40 ) )
+                    || ( ( HwDeviceExtension->jChipType == XG41 ) && ( pVBInfo->Set_VGAType == XG41 ) )
+                    || ( ( HwDeviceExtension->jChipType == XG42 ) && ( pVBInfo->Set_VGAType == XG42 ) )
+                    || ( ( HwDeviceExtension->jChipType == XG45 ) && ( pVBInfo->Set_VGAType == XG45 ) ) )
+                    {
+                        if ( ModeNo <= 13 )
+                        {
+                            if ( !( tempbx & SetCRT2ToRAMDAC ) )	/*CRT2 not need to support*/
+                            {
+                                tempbx &= ( 0x00FF | ( ~SetInSlaveMode ) ) ;
+                                pVBInfo->SetFlag |= EnableVCMode ;
+                            }
+                        }
+                    }
+                }
+            }
+
+            /*LCD+TV can't support in slave mode (Force LCDA+TV->LCDB)*/
+            if ( ( tempbx & SetInSlaveMode ) && ( tempbx & SetCRT2ToLCDA ) )
+            {
+                tempbx ^= ( SetCRT2ToLCD | SetCRT2ToLCDA | SetCRT2ToDualEdge ) ;
+                pVBInfo->SetFlag |= ReserveTVOption ;
+            }
+        }
+    }
+
+    pVBInfo->VBInfo = tempbx ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetTVInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetTVInfo( USHORT ModeNo , USHORT ModeIdIndex ,PVB_DEVICE_INFO  pVBInfo )
+{
+    USHORT temp ,
+           tempbx = 0 ,
+           resinfo = 0 ,
+           modeflag ,
+           index1 ;
+
+    tempbx = 0 ;
+    resinfo = 0 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        if ( ModeNo <= 0x13 )
+        {
+            modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;	/* si+St_ModeFlag */
+            resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;	/* si+St_ResInfo */
+        }
+        else
+        {
+            modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+            resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ; /* si+Ext_ResInfo */
+        }
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x35 ) ;
+            tempbx = temp;
+            if ( tempbx & SetPALTV )
+            {
+                tempbx &= ( SetCHTVOverScan | SetPALMTV | SetPALNTV | SetPALTV ) ;
+                if ( tempbx & SetPALMTV )
+                    tempbx &= ~SetPALTV ; /* set to NTSC if PAL-M */
+            }
+            else
+                tempbx &= ( SetCHTVOverScan | SetNTSCJ | SetPALTV ) ;
+/*
+            if ( pVBInfo->IF_DEF_LVDS == 0 )
+            {
+                index1 = XGINew_GetReg1( pVBInfo->P3d4 , 0x38 ) ; //PAL-M/PAL-N Info
+                temp2 = ( index1 & 0xC0 ) >> 5 ; 	        //00:PAL, 01:PAL-M, 10:PAL-N
+                tempbx |= temp2 ;
+                if ( temp2 & 0x02 )          //PAL-M
+                    tempbx &= ( ~SetPALTV ) ;
+            }
+*/
+        }
+
+        if ( pVBInfo->IF_DEF_CH7017 == 1 )
+        {
+            tempbx = XGINew_GetReg1( pVBInfo->P3d4 , 0x35 ) ;
+
+            if ( tempbx & TVOverScan )
+                tempbx |= SetCHTVOverScan ;
+        }
+
+        if ( pVBInfo->IF_DEF_CH7007 == 1 ) /* [Billy] 07/05/04 */
+        {
+            tempbx = XGINew_GetReg1( pVBInfo->P3d4 , 0x35 ) ;
+
+            if ( tempbx & TVOverScan )
+            {
+                tempbx |= SetCHTVOverScan ;
+            }
+        }
+
+
+        if ( pVBInfo->IF_DEF_LVDS == 0 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToSCART )
+                tempbx |= SetPALTV ;
+        }
+
+        if ( pVBInfo->IF_DEF_YPbPr == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+            {
+                index1 = XGINew_GetReg1( pVBInfo->P3d4 , 0x35 ) ;
+                index1 &= YPbPrMode ;
+
+                if ( index1 == YPbPrMode525i )
+                    tempbx |= SetYPbPrMode525i ;
+
+                if ( index1 == YPbPrMode525p )
+                    tempbx = tempbx | SetYPbPrMode525p;
+                if ( index1 == YPbPrMode750p)
+                    tempbx = tempbx | SetYPbPrMode750p;
+            }
+        }
+
+        if ( pVBInfo->IF_DEF_HiVision == 1 )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+            {
+                tempbx = tempbx | SetYPbPrMode1080i | SetPALTV ;
+            }
+        }
+
+        if ( pVBInfo->IF_DEF_LVDS == 0 )
+        {      /* shampoo */
+            if ( ( pVBInfo->VBInfo & SetInSlaveMode ) && ( !( pVBInfo->VBInfo & SetNotSimuMode ) ) )
+                tempbx |= TVSimuMode ;
+
+            if ( !( tempbx & SetPALTV ) && ( modeflag > 13 ) && ( resinfo == 8 ) ) /* NTSC 1024x768, */
+                tempbx |= NTSC1024x768 ;
+
+            tempbx |= RPLLDIV2XO ;
+
+            if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+            {
+                if ( pVBInfo->VBInfo & SetInSlaveMode )
+                    tempbx &=( ~RPLLDIV2XO ) ;
+            }
+            else
+            {
+                if ( tempbx & ( SetYPbPrMode525p | SetYPbPrMode750p ) )
+                    tempbx &= ( ~RPLLDIV2XO ) ;
+                else if ( !( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) ) )
+                {
+                    if ( tempbx & TVSimuMode )
+                        tempbx &= ( ~RPLLDIV2XO ) ;
+                }
+            }
+        }
+    }
+    pVBInfo->TVInfo = tempbx ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLCDInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_GetLCDInfo( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT temp ,
+           tempax ,
+           tempbx ,
+           modeflag ,
+           resinfo = 0 ,
+           LCDIdIndex ;
+
+    pVBInfo->LCDResInfo = 0 ;
+    pVBInfo->LCDTypeInfo = 0 ;
+    pVBInfo->LCDInfo = 0 ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;  /* si+St_ModeFlag // */
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ; /* si+Ext_ResInfo// */
+    }
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x36 ) ; /* Get LCD Res.Info */
+    tempbx = temp & 0x0F ;
+
+    if ( tempbx == 0 )
+        tempbx = Panel1024x768 ; /* default */
+
+    /* LCD75 [2003/8/22] Vicent */
+    if ( ( tempbx == Panel1024x768 ) || ( tempbx == Panel1280x1024 ) )
+    {
+        if ( pVBInfo->VBInfo & DriverMode )
+        {
+            tempax = XGINew_GetReg1( pVBInfo->P3d4 , 0x33 ) ;
+            if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                tempax &= 0x0F ;
+            else
+                tempax = tempax >> 4 ;
+
+            if ( ( resinfo == 6 ) || ( resinfo == 9 ) )
+            {
+                if ( tempax >= 3 )
+      	            tempbx |= PanelRef75Hz ;
+            }
+            else if ( ( resinfo == 7 ) || ( resinfo == 8 ) )
+            {
+      	        if ( tempax >= 4 )
+      	            tempbx |= PanelRef75Hz ;
+            }
+        }
+    }
+
+    pVBInfo->LCDResInfo = tempbx ;
+
+    /* End of LCD75 */
+
+    if( pVBInfo->IF_DEF_OEMUtil == 1 )
+    {
+        pVBInfo->LCDTypeInfo = ( temp & 0xf0 ) >> 4 ;
+    }
+
+    if ( !( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) )
+    {
+        return 0;
+    }
+
+    tempbx = 0 ;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x37 ) ;
+
+    temp &= ( ScalingLCD | LCDNonExpanding | LCDSyncBit | SetPWDEnable ) ;
+
+    if ( ( pVBInfo->IF_DEF_ScaleLCD == 1 ) && ( temp & LCDNonExpanding ) )
+        temp &= ~EnableScalingLCD ;
+
+    tempbx |= temp ;
+
+    LCDIdIndex = XGI_GetLCDCapPtr1(pVBInfo) ;
+
+    tempax = pVBInfo->LCDCapList[ LCDIdIndex ].LCD_Capability ;
+
+    if ( pVBInfo->IF_DEF_LVDS == 0 )	/* shampoo */
+    {
+        if ( ( ( pVBInfo->VBType & VB_XGI302LV ) || ( pVBInfo->VBType & VB_XGI301C ) ) && ( tempax & LCDDualLink ) )
+        {
+            tempbx |= SetLCDDualLink ;
+        }
+    }
+
+    if ( pVBInfo->IF_DEF_CH7017 == 1 )
+    {
+        if ( tempax & LCDDualLink )
+        {
+            tempbx |= SetLCDDualLink ;
+        }
+    }
+
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        if ( ( pVBInfo->LCDResInfo == Panel1400x1050 ) && ( pVBInfo->VBInfo & SetCRT2ToLCD ) && ( ModeNo > 0x13 ) && ( resinfo == 9 ) && ( !( tempbx & EnableScalingLCD ) ) )
+            tempbx |= SetLCDtoNonExpanding ;	/* set to center in 1280x1024 LCDB for Panel1400x1050 */
+    }
+
+/*
+    if ( tempax & LCDBToA )
+    {
+        tempbx |= SetLCDBToA ;
+    }
+*/
+
+    if ( pVBInfo->IF_DEF_ExpLink == 1 )
+    {
+        if ( modeflag & HalfDCLK )
+        {
+            /* if ( !( pVBInfo->LCDInfo&LCDNonExpanding ) ) */
+            if ( !( tempbx & SetLCDtoNonExpanding ) )
+            {
+                tempbx |= EnableLVDSDDA ;
+            }
+            else
+            {
+                if ( ModeNo > 0x13 )
+                {
+                    if ( pVBInfo->LCDResInfo == Panel1024x768 )
+                    {
+                        if ( resinfo == 4 )
+                        {                                /* 512x384  */
+                            tempbx |= EnableLVDSDDA ;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    if ( pVBInfo->VBInfo & SetInSlaveMode )
+    {
+        if ( pVBInfo->VBInfo & SetNotSimuMode )
+        {
+            tempbx |= LCDVESATiming ;
+        }
+    }
+    else
+    {
+        tempbx |= LCDVESATiming ;
+    }
+
+    pVBInfo->LCDInfo = tempbx ;
+
+    if ( pVBInfo->IF_DEF_PWD == 1 )
+    {
+        if ( pVBInfo->LCDInfo & SetPWDEnable )
+        {
+            if ( ( pVBInfo->VBType & VB_XGI302LV ) || ( pVBInfo->VBType & VB_XGI301C ) )
+            {
+                if ( !( tempax & PWDEnable ) )
+                {
+                    pVBInfo->LCDInfo &= ~SetPWDEnable ;
+                }
+            }
+        }
+    }
+
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        if ( tempax & ( LockLCDBToA | StLCDBToA ) )
+        {
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+            {
+                if ( !( tempax & LockLCDBToA ) )
+                {
+                    if ( ModeNo <= 0x13 )
+                    {
+                        pVBInfo->VBInfo &= ~( SetSimuScanMode | SetInSlaveMode | SetCRT2ToLCD ) ;
+                        pVBInfo->VBInfo |= SetCRT2ToLCDA | SetCRT2ToDualEdge ;
+                    }
+                }
+            }
+        }
+    }
+
+/*
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        if ( tempax & ( LockLCDBToA | StLCDBToA ) )
+        {
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+            {
+                if ( !( ( !( tempax & LockLCDBToA ) ) && ( ModeNo > 0x13 ) ) )
+                {
+                    pVBInfo->VBInfo&=~(SetSimuScanMode|SetInSlaveMode|SetCRT2ToLCD);
+                    pVBInfo->VBInfo|=SetCRT2ToLCDA|SetCRT2ToDualEdge;
+                }
+            }
+        }
+    }
+*/
+
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SearchModeID */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_SearchModeID( USHORT ModeNo , USHORT *ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+
+#ifdef TC
+
+    if ( ModeNo <= 5 )
+        ModeNo |= 1 ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->SModeIDTable)/sizeof(XGI_StStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+
+        VGA_INFO = ( PUCHAR )MK_FP( 0 , 0x489 ) ;
+
+        if ( ModeNo == 0x07 )
+        {
+            if ( ( *VGA_INFO & 0x10 ) != 0 )
+                ( *ModeIdIndex )++ ; /* 400 lines */
+            /* else 350 lines */
+        }
+
+        if ( ModeNo <= 3 )
+        {
+            if ( ( *VGA_INFO & 0x80 ) == 0 )
+            {
+                ( *ModeIdIndex )++ ;
+                if ( ( *VGA_INFO & 0x10 ) != 0 )
+                    ( *ModeIdIndex )++ ; /* 400 lines */
+                /* else 350 lines */
+            }
+            /* else 200 lines */
+        }
+    }
+    else
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->EModeIDTable)/sizeof(XGI_ExtStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+    }
+
+
+#endif
+
+#ifdef WIN2000
+
+    if ( ModeNo <= 5 )
+        ModeNo |= 1 ;
+    if ( ModeNo <= 0x13 )
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->SModeIDTable)/sizeof(XGI_StStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+
+        if ( ModeNo == 0x07 )
+            ( *ModeIdIndex )++ ; /* 400 lines */
+
+        if ( ModeNo <=3 )
+            ( *ModeIdIndex ) += 2 ; /* 400 lines */
+        /* else 350 lines */
+    }
+    else
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->EModeIDTable)/sizeof(XGI_ExtStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+    }
+
+#endif
+
+#ifdef LINUX /* chiawen for linux solution */
+
+    if ( ModeNo <= 5 )
+        ModeNo |= 1 ;
+    if ( ModeNo <= 0x13 )
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->SModeIDTable)/sizeof(XGI_StStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->SModeIDTable[ *ModeIdIndex ].St_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+
+        if ( ModeNo == 0x07 )
+            ( *ModeIdIndex )++ ; /* 400 lines */
+
+        if ( ModeNo <= 3 )
+            ( *ModeIdIndex ) += 2 ; /* 400 lines */
+        /* else 350 lines */
+    }
+    else
+    {
+        /* for (*ModeIdIndex=0;*ModeIdIndex<sizeof(pVBInfo->EModeIDTable)/sizeof(XGI_ExtStruct);(*ModeIdIndex)++) */
+        for( *ModeIdIndex = 0 ; ; ( *ModeIdIndex )++ )
+        {
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == ModeNo )
+                break ;
+            if ( pVBInfo->EModeIDTable[ *ModeIdIndex ].Ext_ModeID == 0xFF )
+                return( FALSE ) ;
+        }
+    }
+
+#endif
+
+    return( TRUE ) ;
+}
+
+
+
+
+/* win2000 MM adapter not support standard mode! */
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGINew_CheckMemorySize(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT memorysize ,
+           modeflag ,
+           temp ,
+           temp1 ,
+           tmp ;
+
+/*  if ( ( HwDeviceExtension->jChipType == XGI_650 ) ||
+         ( HwDeviceExtension->jChipType == XGI_650M ) )
+    {
+        return( TRUE ) ;
+    } */
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else  {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    /* ModeType = modeflag&ModeInfoFlag ; // Get mode type */
+
+    memorysize = modeflag & MemoryInfoFlag ;
+    memorysize = memorysize > MemorySizeShift ;
+    memorysize++ ;					/* Get memory size */
+
+    temp = XGINew_GetReg1( pVBInfo->P3c4 , 0x14 ) ;	/* Get DRAM Size */
+    tmp = temp ;
+
+    if ( HwDeviceExtension->jChipType == XG40 )
+    {
+        temp = 1 << ( ( temp & 0x0F0 ) >> 4 ) ;		/* memory size per channel SR14[7:4] */
+        if ( ( tmp & 0x0c ) == 0x0C )			/* Qual channels */
+        {
+            temp <<= 2 ;
+        }
+        else if ( ( tmp & 0x0c ) == 0x08 )		/* Dual channels */
+        {
+            temp <<= 1 ;
+        }
+    }
+    else if ( HwDeviceExtension->jChipType == XG42 )
+    {
+    	temp = 1 << ( ( temp & 0x0F0 ) >> 4 ) ;		/* memory size per channel SR14[7:4] */
+        if ( ( tmp & 0x04 ) == 0x04 )			/* Dual channels */
+        {
+            temp <<= 1 ;
+        }
+    }
+    else if ( HwDeviceExtension->jChipType == XG45 )
+    {
+    	temp = 1 << ( ( temp & 0x0F0 ) >> 4 ) ;		/* memory size per channel SR14[7:4] */
+    	if ( ( tmp & 0x0c ) == 0x0C )			/* Qual channels */
+        {
+            temp <<= 2 ;
+        }
+        else if ( ( tmp & 0x0c ) == 0x08 )		/* triple channels */
+        {
+            temp1 = temp ;
+            temp <<= 1 ;
+            temp += temp1 ;
+        }
+        else if ( ( tmp & 0x0c ) == 0x04 )		/* Dual channels */
+        {
+            temp <<= 1 ;
+        }
+    }
+    if ( temp < memorysize )
+        return( FALSE ) ;
+    else
+        return( TRUE ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_IsLowResolution */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+/*void XGINew_IsLowResolution( USHORT ModeNo , USHORT ModeIdIndex, BOOLEAN XGINew_CheckMemorySize(PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT data ;
+    USHORT ModeFlag ;
+
+    data = XGINew_GetReg1( pVBInfo->P3c4 , 0x0F ) ;
+    data &= 0x7F ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x0F , data ) ;
+
+    if ( ModeNo > 0x13 )
+    {
+        ModeFlag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        if ( ( ModeFlag & HalfDCLK ) && ( ModeFlag & DoubleScanMode ) )
+        {
+            data = XGINew_GetReg1( pVBInfo->P3c4 , 0x0F ) ;
+            data |= 0x80 ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x0F , data ) ;
+            data = XGINew_GetReg1( pVBInfo->P3c4 , 0x01 ) ;
+            data &= 0xF7 ;
+            XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , data ) ;
+        }
+    }
+}
+
+*/
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisplayOn */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_DisplayOn( PXGI_HW_DEVICE_INFO pXGIHWDE , PVB_DEVICE_INFO pVBInfo )
+{
+
+    XGINew_SetRegANDOR(pVBInfo->P3c4,0x01,0xDF,0x00);
+    if ( pXGIHWDE->jChipType == XG21 )
+    {
+       if ( pVBInfo->IF_DEF_LVDS == 1 )
+       {
+         if (!(XGI_XG21GetPSCValue( pVBInfo )&0x1))
+         {
+            XGI_XG21BLSignalVDD( 0x01 , 0x01, pVBInfo ) ; /* LVDS VDD on */
+            XGI_XG21SetPanelDelay( 2,pVBInfo ) ;
+         }
+         if (!(XGI_XG21GetPSCValue( pVBInfo )&0x20))
+         {
+            XGI_XG21BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* LVDS signal on */
+         }
+         XGI_XG21SetPanelDelay( 3,pVBInfo ) ;
+         XGI_XG21BLSignalVDD( 0x02 , 0x02, pVBInfo ) ; /* LVDS backlight on */
+       }
+       else
+       {
+            XGI_XG21BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* DVO/DVI signal on */
+       }
+
+    }
+
+    if (pVBInfo->IF_DEF_CH7007 == 1) /* [Billy] 07/05/23 For CH7007 */
+    {
+#ifdef WIN2000
+       if ( IsCH7007TVMode( pVBInfo ) )
+       {
+           TurnOnCH7007(pXGIHWDE->pDevice) ; /* 07/05/28 */
+       }
+#endif
+
+    }
+
+
+    if ( pXGIHWDE->jChipType == XG27 )
+    {
+       if ( pVBInfo->IF_DEF_LVDS == 1 )
+       {
+         if (!(XGI_XG27GetPSCValue( pVBInfo )&0x1))
+         {
+            XGI_XG27BLSignalVDD( 0x01 , 0x01, pVBInfo ) ; /* LVDS VDD on */
+            XGI_XG21SetPanelDelay( 2,pVBInfo ) ;
+         }
+         if (!(XGI_XG27GetPSCValue( pVBInfo )&0x20))
+         {
+            XGI_XG27BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* LVDS signal on */
+         }
+         XGI_XG21SetPanelDelay( 3,pVBInfo ) ;
+         XGI_XG27BLSignalVDD( 0x02 , 0x02, pVBInfo ) ; /* LVDS backlight on */
+       }
+       else
+       {
+            XGI_XG27BLSignalVDD( 0x20 , 0x20, pVBInfo ) ; /* DVO/DVI signal on */
+       }
+
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisplayOff */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_DisplayOff( PXGI_HW_DEVICE_INFO pXGIHWDE , PVB_DEVICE_INFO pVBInfo )
+{
+
+    if ( pXGIHWDE->jChipType == XG21 )
+    {
+       if ( pVBInfo->IF_DEF_LVDS == 1 )
+       {
+         XGI_XG21BLSignalVDD( 0x02 , 0x00, pVBInfo ) ; /* LVDS backlight off */
+         XGI_XG21SetPanelDelay( 3,pVBInfo ) ;
+       }
+       else
+       {
+            XGI_XG21BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* DVO/DVI signal off */
+       }
+    }
+
+    if (pVBInfo->IF_DEF_CH7007 == 1) /*[Billy] 07/05/23 For CH7007 */
+    {
+       /* if( IsCH7007TVMode( pVBInfo ) == 0 ) */
+       {
+#ifdef WIN2000
+         TurnOffCH7007(pXGIHWDE->pDevice) ;  /* 07/05/28 */
+#endif
+       }
+    }
+
+
+    if ( pXGIHWDE->jChipType == XG27 )
+    {
+       if ((XGI_XG27GetPSCValue( pVBInfo )&0x2))
+       {
+         XGI_XG27BLSignalVDD( 0x02 , 0x00, pVBInfo ) ; /* LVDS backlight off */
+         XGI_XG21SetPanelDelay( 3,pVBInfo ) ;
+       }
+
+       if ( pVBInfo->IF_DEF_LVDS == 0 )
+       {
+            XGI_XG27BLSignalVDD( 0x20 , 0x00, pVBInfo ) ; /* DVO/DVI signal off */
+       }
+    }
+
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x01 , 0xDF , 0x20 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_WaitDisply */
+/* Input : */
+/* Output : */
+/* Description : chiawen for sensecrt1 */
+/* --------------------------------------------------------------------- */
+void XGI_WaitDisply( PVB_DEVICE_INFO pVBInfo )
+{
+    while( ( XGINew_GetReg2( pVBInfo->P3da ) & 0x01 ) )
+        break ;
+
+    while( !( XGINew_GetReg2( pVBInfo->P3da ) & 0x01 ) )
+        break ;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SenseCRT1 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+
+void XGI_SenseCRT1( PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR CRTCData[ 17 ] = { 0x5F , 0x4F , 0x50 , 0x82 , 0x55 , 0x81 ,
+                             0x0B , 0x3E , 0xE9 , 0x0B , 0xDF , 0xE7 ,
+                             0x04 , 0x00 , 0x00 , 0x05 , 0x00 } ;
+
+    UCHAR SR01 = 0 , SR1F = 0 , SR07 = 0 , SR06 = 0 ;
+
+    UCHAR CR17 , CR63 , SR31 ;
+    USHORT temp ;
+    UCHAR DAC_TEST_PARMS[ 3 ] = { 0x0F , 0x0F , 0x0F } ;
+
+    int i ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x05 , 0x86 ) ;
+
+    /* [2004/05/06] Vicent to fix XG42 single LCD sense to CRT+LCD */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x57 , 0x4A ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x53 , ( UCHAR )( XGINew_GetReg1( pVBInfo->P3d4 , 0x53 ) | 0x02 ) ) ;
+
+    SR31 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x31 ) ;
+    CR63 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x63 ) ;
+    SR01 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x01 ) ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , ( UCHAR )( SR01 & 0xDF ) ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x63 , ( UCHAR )( CR63 & 0xBF ) ) ;
+
+    CR17 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x17 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x17 , ( UCHAR )( CR17 | 0x80 ) ) ;
+
+    SR1F = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x1F ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1F , ( UCHAR )( SR1F | 0x04 ) ) ;
+
+    SR07 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x07 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x07 , ( UCHAR )( SR07 & 0xFB ) ) ;
+    SR06 = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x06 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x06 , ( UCHAR )( SR06 & 0xC3 ) ) ;
+
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , 0x00 ) ;
+
+    for( i = 0 ; i < 8 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )i , CRTCData[ i ] ) ;
+
+    for( i = 8 ; i < 11 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 8 ) , CRTCData[ i ] ) ;
+
+    for( i = 11 ; i < 13 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3d4 , ( USHORT )( i + 4 ) , CRTCData[ i ] ) ;
+
+    for( i = 13 ; i < 16 ; i++ )
+        XGINew_SetReg1( pVBInfo->P3c4 , ( USHORT )( i - 3 ) , CRTCData[ i ] ) ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x0E , ( UCHAR )( CRTCData[ 16 ] & 0xE0 ) ) ;
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , 0x00 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , 0x1B ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , 0xE1 ) ;
+
+    XGINew_SetReg3( pVBInfo->P3c8 , 0x00 ) ;
+
+    for( i = 0 ; i < 256 ; i++ )
+    {
+        XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , ( UCHAR )DAC_TEST_PARMS[ 0 ] ) ;
+        XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , ( UCHAR )DAC_TEST_PARMS[ 1 ] ) ;
+        XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , ( UCHAR )DAC_TEST_PARMS[ 2 ] ) ;
+    }
+
+    XGI_VBLongWait( pVBInfo ) ;
+    XGI_VBLongWait( pVBInfo ) ;
+    XGI_VBLongWait( pVBInfo ) ;
+
+    XGINew_LCD_Wait_Time( 0x01 , pVBInfo ) ;
+
+    XGI_WaitDisply( pVBInfo ) ;
+    temp = XGINew_GetReg2( pVBInfo->P3c2 ) ;
+
+    if( temp & 0x10 )
+    {
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , 0xDF , 0x20 ) ;
+    }
+    else
+    {
+        XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x32 , 0xDF , 0x00 ) ;
+    }
+
+    /* alan, avoid display something, set BLACK DAC if not restore DAC */
+    XGINew_SetReg3( pVBInfo->P3c8 , 0x00 ) ;
+
+    for( i = 0 ; i < 256 ; i++ )
+    {
+      XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , 0 ) ;
+      XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , 0 ) ;
+      XGINew_SetReg3( ( pVBInfo->P3c8 + 1 ) , 0 ) ;
+    }
+
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x01 , SR01 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x63 , CR63 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x31 , SR31 ) ;
+
+    /* [2004/05/11] Vicent */
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x53 , ( UCHAR )( XGINew_GetReg1( pVBInfo->P3d4 , 0x53 ) & 0xFD ) ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x1F , ( UCHAR ) SR1F ) ;
+}
+
+
+
+
+
+#ifdef TC
+/* --------------------------------------------------------------------- */
+/* Function : INT1AReturnCode */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+int INT1AReturnCode( union REGS regs )
+{
+    if ( regs.x.cflag )
+    {
+        /* printf( "Error to find pci device!\n" ) ; */
+        return( 1 ) ;
+    }
+
+    switch(regs.h.ah)
+    {
+        case 0: return 0;
+            break ;
+        case 0x81:
+            printf( "Function not support\n" ) ;
+            break ;
+        case 0x83:
+            printf( "bad vendor id\n" ) ;
+            break ;
+        case 0x86:
+            printf( "device not found\n" ) ;
+            break ;
+        case 0x87:
+            printf( "bad register number\n" ) ;
+            break ;
+        case 0x88:
+            printf( "set failed\n" ) ;
+            break ;
+        case 0x89:
+            printf( "buffer too small" ) ;
+            break ;
+        default:
+            break ;
+    }
+    return( 1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : FindPCIIOBase */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+unsigned FindPCIIOBase( unsigned index , unsigned deviceid )
+{
+    union REGS regs ;
+
+    regs.h.ah = 0xb1 ;	/* PCI_FUNCTION_ID */
+    regs.h.al = 0x02 ;	/* FIND_PCI_DEVICE */
+    regs.x.cx = deviceid ;
+    regs.x.dx = 0x1039 ;
+    regs.x.si = index ;	/* find n-th device */
+
+    int86( 0x1A , &regs , &regs ) ;
+
+    if ( INT1AReturnCode( regs ) != 0 )
+        return( 0 ) ;
+
+    /* regs.h.bh bus number */
+    /* regs.h.bl device number */
+    regs.h.ah = 0xb1 ;  /* PCI_FUNCTION_ID */
+    regs.h.al = 0x09 ;  /* READ_CONFIG_WORD */
+    regs.x.cx = deviceid ;
+    regs.x.dx = 0x1039 ;
+    regs.x.di = 0x18 ;  /* register number */
+    int86( 0x1A , &regs , &regs ) ;
+
+    if ( INT1AReturnCode( regs ) != 0 )
+        return( 0 ) ;
+
+    return( regs.x.cx ) ;
+}
+
+#endif
+
+
+
+#ifdef TC
+/* --------------------------------------------------------------------- */
+/* Function : main */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void main(int argc, char *argv[])
+{
+    XGI_HW_DEVICE_INFO HwDeviceExtension ;
+    USHORT temp ;
+    USHORT ModeNo ;
+
+    /* HwDeviceExtension.pjVirtualRomBase =(PUCHAR) MK_FP(0xC000,0); */
+    /* HwDeviceExtension.pjVideoMemoryAddress = (PUCHAR)MK_FP(0xA000,0); */
+
+
+    HwDeviceExtension.pjIOAddress = ( FindPCIIOBase( 0 ,0x6300 ) & 0xFF80 ) + 0x30 ;
+    HwDeviceExtension.jChipType = XGI_340 ;
+
+
+
+    /* HwDeviceExtension.pjIOAddress = ( FindPCIIOBase( 0 , 0x5315 ) & 0xFF80 ) + 0x30 ; */
+
+    HwDeviceExtension.pjIOAddress = ( FindPCIIOBase( 0 , 0x330 ) & 0xFF80 ) + 0x30 ;
+    HwDeviceExtension.jChipType = XGI_340 ;
+
+
+    HwDeviceExtension.ujVBChipID = VB_CHIP_301 ;
+    StrCpy(HwDeviceExtension.szVBIOSVer , "0.84" ) ;
+    HwDeviceExtension.bSkipDramSizing = FALSE ;
+    HwDeviceExtension.ulVideoMemorySize = 0 ;
+
+    if ( argc == 2 )
+    {
+        ModeNo = atoi( argv[ 1 ] ) ;
+    }
+    else
+    {
+        ModeNo = 0x2e ;
+        /* ModeNo = 0x37 ; 1024x768x 4bpp */
+        /* ModeNo = 0x38 ; 1024x768x 8bpp */
+        /* ModeNo = 0x4A ; 1024x768x 16bpp */
+        /* ModeNo = 0x47 ; 800x600x 16bpp */
+    }
+
+    /* XGIInitNew( &HwDeviceExtension ) ; */
+    XGISetModeNew( &HwDeviceExtension , ModeNo ) ;
+}
+#endif
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_WaitDisplay */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_WaitDisplay( PVB_DEVICE_INFO pVBInfo )
+{
+    while( !( XGINew_GetReg2( pVBInfo->P3da ) & 0x01 ) ) ;
+
+    while( XGINew_GetReg2( pVBInfo->P3da ) & 0x01 ) ;
+}
+
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2Group301 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_SetCRT2Group301( USHORT ModeNo , PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx ,
+           ModeIdIndex ,
+           RefreshRateTableIndex ;
+
+    tempbx=pVBInfo->VBInfo ;
+    pVBInfo->SetFlag |= ProgrammingCRT2 ;
+    XGI_SearchModeID( ModeNo , &ModeIdIndex,  pVBInfo ) ;
+    pVBInfo->SelectCRT2Rate = 4 ;
+    RefreshRateTableIndex = XGI_GetRatePtrCRT2( HwDeviceExtension, ModeNo , ModeIdIndex, pVBInfo ) ;
+    XGI_SaveCRT2Info( ModeNo, pVBInfo ) ;
+    XGI_GetCRT2ResInfo( ModeNo , ModeIdIndex, pVBInfo) ;
+    XGI_GetCRT2Data( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_PreSetGroup1( ModeNo , ModeIdIndex , HwDeviceExtension , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetGroup1( ModeNo , ModeIdIndex , HwDeviceExtension , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetLockRegs( ModeNo , ModeIdIndex , HwDeviceExtension , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetGroup2(  ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+    XGI_SetLCDRegs(ModeNo , ModeIdIndex , HwDeviceExtension , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetTap4Regs(pVBInfo) ;
+    XGI_SetGroup3(ModeNo, ModeIdIndex, pVBInfo);
+    XGI_SetGroup4( ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+    XGI_SetCRT2VCLK( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+    XGI_SetGroup5( ModeNo , ModeIdIndex, pVBInfo) ;
+    XGI_AutoThreshold( pVBInfo) ;
+    return 1 ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_AutoThreshold */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_AutoThreshold(  PVB_DEVICE_INFO pVBInfo )
+{
+    if ( !( pVBInfo->SetFlag & Win9xDOSMode ) )
+      XGINew_SetRegOR( pVBInfo->Part1Port , 0x01 , 0x40 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SaveCRT2Info */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SaveCRT2Info( USHORT ModeNo , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT temp1 ,
+           temp2 ;
+
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x34 , ModeNo ) ;  /* reserve CR34 for CRT1 Mode No */
+    temp1 = ( pVBInfo->VBInfo&SetInSlaveMode ) >> 8 ;
+    temp2 = ~( SetInSlaveMode >> 8 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x31 , temp2 , temp1 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetCRT2ResInfo */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetCRT2ResInfo( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT xres ,
+           yres ,
+           modeflag ,
+           resindex ;
+
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo) ;
+    if ( ModeNo <= 0x13 )
+    {
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->StResInfo[ resindex ].VTotal ;
+     /* modeflag = pVBInfo->SModeIDTable[ModeIdIndex].St_ModeFlag; si+St_ResInfo */
+    }
+    else
+    {
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;			/* xres->ax */
+        yres = pVBInfo->ModeResInfo[ resindex ].VTotal ;			/* yres->bx */
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex].Ext_ModeFlag ;		/* si+St_ModeFlag */
+
+/*        if ( pVBInfo->IF_DEF_FSTN )
+        {
+            xres *= 2 ;
+            yres *= 2 ;
+        }
+        else
+        {
+*/
+            if ( modeflag & HalfDCLK )
+                xres *= 2;
+
+            if ( modeflag & DoubleScanMode )
+                yres *= 2 ;
+/* } */
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+    {
+        if ( pVBInfo->IF_DEF_LVDS == 0 )
+        {
+            if ( pVBInfo->LCDResInfo == Panel1600x1200 )
+            {
+                if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+                {
+                    if ( yres == 1024 )
+                        yres = 1056 ;
+	        }
+            }
+
+            if ( pVBInfo->LCDResInfo == Panel1280x1024 )
+            {
+	        if ( yres == 400 )
+	            yres = 405 ;
+	        else if ( yres == 350 )
+	            yres = 360 ;
+
+	        if ( pVBInfo->LCDInfo & LCDVESATiming )
+	        {
+	            if ( yres == 360 )
+	                yres = 375 ;
+	        }
+            }
+
+            if ( pVBInfo->LCDResInfo == Panel1024x768 )
+            {
+	        if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+	        {
+	            if ( !( pVBInfo->LCDInfo & LCDNonExpanding ) )
+	            {
+	                if ( yres == 350 )
+	                    yres = 357 ;
+	                else if ( yres == 400 )
+	                    yres = 420 ;
+	                else if ( yres == 480 )
+	                    yres = 525 ;
+	            }
+                }
+            }
+        }
+
+        if ( xres == 720 )
+            xres = 640 ;
+    }
+
+    pVBInfo->VGAHDE = xres ;
+    pVBInfo->HDE = xres ;
+    pVBInfo->VGAVDE = yres ;
+    pVBInfo->VDE = yres ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_IsLCDDualLink */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_IsLCDDualLink( PVB_DEVICE_INFO pVBInfo )
+{
+
+    if ( ( ( ( pVBInfo->VBInfo & SetCRT2ToLCD ) | SetCRT2ToLCDA ) ) && ( pVBInfo->LCDInfo & SetLCDDualLink ) ) /* shampoo0129 */
+        return ( 1 ) ;
+
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetCRT2Data */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetCRT2Data(  USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempax = 0,
+           tempbx ,
+           modeflag ,
+           resinfo ;
+
+    XGI_LCDDataStruct *LCDPtr = NULL ;
+    XGI_TVDataStruct  *TVPtr = NULL ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;      /* si+St_ResInfo */
+        resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;     /* si+Ext_ResInfo */
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+    }
+
+    pVBInfo->NewFlickerMode = 0 ;
+    pVBInfo->RVBHRS = 50 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+    {
+        XGI_GetRAMDAC2DATA( ModeNo , ModeIdIndex , RefreshRateTableIndex,pVBInfo ) ;
+        return ;
+    }
+
+    tempbx = 4 ;
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+    {
+        LCDPtr = (XGI_LCDDataStruct* )XGI_GetLcdPtr( tempbx, ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+
+        pVBInfo->RVBHCMAX = LCDPtr->RVBHCMAX ;
+        pVBInfo->RVBHCFACT = LCDPtr->RVBHCFACT ;
+        pVBInfo->VGAHT = LCDPtr->VGAHT ;
+        pVBInfo->VGAVT = LCDPtr->VGAVT ;
+        pVBInfo->HT = LCDPtr->LCDHT ;
+        pVBInfo->VT = LCDPtr->LCDVT ;
+
+        if ( pVBInfo->LCDResInfo == Panel1024x768 )
+        {
+            tempax = 1024 ;
+            tempbx = 768 ;
+
+            if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+            {
+                if ( pVBInfo->VGAVDE == 357 )
+                    tempbx = 527 ;
+	        else if ( pVBInfo->VGAVDE == 420 )
+	            tempbx = 620 ;
+	        else if ( pVBInfo->VGAVDE == 525 )
+	            tempbx = 775 ;
+	        else if ( pVBInfo->VGAVDE == 600 )
+	            tempbx = 775 ;
+                /* else if(pVBInfo->VGAVDE==350) tempbx=560; */
+                /* else if(pVBInfo->VGAVDE==400) tempbx=640; */
+	        else
+	          tempbx = 768 ;
+            }
+            else
+                tempbx = 768 ;
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1024x768x75 )
+        {
+            tempax = 1024 ;
+            tempbx = 768 ;
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1280x1024 )
+        {
+            tempax = 1280 ;
+            if ( pVBInfo->VGAVDE == 360 )
+                tempbx = 768 ;
+            else if ( pVBInfo->VGAVDE == 375 )
+                tempbx = 800 ;
+            else if ( pVBInfo->VGAVDE == 405 )
+                tempbx = 864 ;
+            else
+                tempbx = 1024 ;
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1280x1024x75 )
+        {
+            tempax = 1280 ;
+            tempbx = 1024 ;
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1280x960 )
+        {
+            tempax = 1280 ;
+            if ( pVBInfo->VGAVDE == 350 )
+                tempbx = 700 ;
+            else if ( pVBInfo->VGAVDE == 400 )
+                tempbx = 800 ;
+            else if ( pVBInfo->VGAVDE == 1024 )
+                tempbx = 960 ;
+            else
+                tempbx = 960 ;
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1400x1050 )
+        {
+            tempax = 1400 ;
+            tempbx = 1050 ;
+
+            if ( pVBInfo->VGAVDE == 1024 )
+            {
+                tempax = 1280 ;
+                tempbx = 1024 ;
+            }
+        }
+        else if ( pVBInfo->LCDResInfo == Panel1600x1200 )
+        {
+            tempax = 1600 ;
+            tempbx = 1200 ;  /* alan 10/14/2003 */
+            if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+            {
+              if ( pVBInfo->VGAVDE == 350 )
+                tempbx = 875 ;
+              else if ( pVBInfo->VGAVDE == 400 )
+                tempbx = 1000 ;
+            }
+        }
+
+        if ( pVBInfo->LCDInfo & LCDNonExpanding )
+        {
+            tempax = pVBInfo->VGAHDE ;
+            tempbx = pVBInfo->VGAVDE ;
+        }
+
+        pVBInfo->HDE = tempax ;
+        pVBInfo->VDE = tempbx ;
+        return ;
+    }
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToTV ) )
+    {
+        tempbx = 4 ;
+        TVPtr = ( XGI_TVDataStruct * )XGI_GetTVPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+
+        pVBInfo->RVBHCMAX = TVPtr->RVBHCMAX ;
+        pVBInfo->RVBHCFACT = TVPtr->RVBHCFACT ;
+        pVBInfo->VGAHT = TVPtr->VGAHT ;
+        pVBInfo->VGAVT = TVPtr->VGAVT ;
+        pVBInfo->HDE = TVPtr->TVHDE ;
+        pVBInfo->VDE = TVPtr->TVVDE ;
+        pVBInfo->RVBHRS = TVPtr->RVBHRS ;
+        pVBInfo->NewFlickerMode = TVPtr->FlickerMode ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        {
+            if ( resinfo == 0x08 )
+                pVBInfo->NewFlickerMode = 0x40 ;
+            else if ( resinfo == 0x09 )
+                pVBInfo->NewFlickerMode = 0x40 ;
+            else if ( resinfo == 0x12 )
+                pVBInfo->NewFlickerMode = 0x40 ;
+
+            if ( pVBInfo->VGAVDE == 350 )
+                pVBInfo->TVInfo |= TVSimuMode ;
+
+            tempax = ExtHiTVHT ;
+            tempbx = ExtHiTVVT ;
+
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+            {
+	        if ( pVBInfo->TVInfo & TVSimuMode )
+	        {
+	            tempax = StHiTVHT ;
+	            tempbx = StHiTVVT ;
+
+	            if ( !( modeflag & Charx8Dot ) )
+	            {
+	                tempax = StHiTextTVHT ;
+	                tempbx = StHiTextTVVT ;
+	            }
+	        }
+            }
+        }
+        else if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+        {
+            if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+            {
+                tempax = YPbPrTV750pHT ;	/* Ext750pTVHT */
+                tempbx = YPbPrTV750pVT ;	/* Ext750pTVVT */
+            }
+
+            if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+            {
+                tempax = YPbPrTV525pHT ;	/* Ext525pTVHT */
+                tempbx = YPbPrTV525pVT ;	/* Ext525pTVVT */
+            }
+            else if ( pVBInfo->TVInfo & SetYPbPrMode525i )
+            {
+                tempax = YPbPrTV525iHT ;	/* Ext525iTVHT */
+                tempbx = YPbPrTV525iVT ;	/* Ext525iTVVT */
+                if ( pVBInfo->TVInfo & NTSC1024x768 )
+                    tempax = NTSC1024x768HT ;
+            }
+        }
+        else
+        {
+            tempax = PALHT ;
+            tempbx = PALVT ;
+            if ( !( pVBInfo->TVInfo & SetPALTV ) )
+            {
+                tempax = NTSCHT ;
+	        tempbx = NTSCVT ;
+	        if ( pVBInfo->TVInfo & NTSC1024x768 )
+	            tempax = NTSC1024x768HT ;
+            }
+        }
+
+        pVBInfo->HT = tempax ;
+        pVBInfo->VT = tempbx ;
+        return ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2VCLK */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT2VCLK( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR di_0 ,
+          di_1 ,
+          tempal ;
+
+    tempal = XGI_GetVCLKPtr( RefreshRateTableIndex , ModeNo , ModeIdIndex, pVBInfo ) ;
+    XGI_GetVCLKLen( tempal, &di_0 , &di_1, pVBInfo ) ;
+    XGI_GetLCDVCLKPtr( &di_0 , &di_1, pVBInfo ) ;
+
+    if ( pVBInfo->VBType & VB_XGI301 ) /* shampoo 0129 */
+    {				/* 301 */
+        XGINew_SetReg1(pVBInfo->Part4Port , 0x0A , 0x10 ) ;
+        XGINew_SetReg1(pVBInfo->Part4Port , 0x0B , di_1 ) ;
+        XGINew_SetReg1(pVBInfo->Part4Port , 0x0A , di_0 ) ;
+    }
+    else
+    {				/* 301b/302b/301lv/302lv */
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x0A , di_0 ) ;
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x0B , di_1 ) ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x00 , 0x12 ) ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+        XGINew_SetRegOR( pVBInfo->Part4Port , 0x12 , 0x28 ) ;
+    else
+        XGINew_SetRegOR( pVBInfo->Part4Port , 0x12 , 0x08 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GETLCDVCLKPtr */
+/* Input : */
+/* Output : al -> VCLK Index */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetLCDVCLKPtr( UCHAR* di_0 , UCHAR *di_1, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT index ;
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+    {
+        if ( pVBInfo->IF_DEF_ScaleLCD == 1 )
+        {
+            if ( pVBInfo->LCDInfo & EnableScalingLCD )
+                return ;
+        }
+
+        /* index = XGI_GetLCDCapPtr(pVBInfo) ; */
+        index = XGI_GetLCDCapPtr1( pVBInfo) ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+        {	/* LCDB */
+            *di_0 = pVBInfo->LCDCapList[ index ].LCUCHAR_VCLKData1 ;
+            *di_1 = pVBInfo->LCDCapList[ index ].LCUCHAR_VCLKData2 ;
+        }
+        else
+        {	/* LCDA */
+            *di_0 = pVBInfo->LCDCapList[ index ].LCDA_VCLKData1 ;
+            *di_1 = pVBInfo->LCDCapList[ index ].LCDA_VCLKData2 ;
+        }
+    }
+    return ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVCLKPtr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGI_GetVCLKPtr(USHORT RefreshRateTableIndex,USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+
+    USHORT index ,
+           modeflag ;
+#ifndef LINUX_XF86
+    USHORT tempbx ;
+#endif
+
+    UCHAR tempal ;
+    UCHAR *CHTVVCLKPtr = NULL ;
+
+    if ( ModeNo <= 0x13 )
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;      /* si+St_ResInfo */
+    else
+        modeflag = pVBInfo->EModeIDTable[ModeIdIndex].Ext_ModeFlag;    /* si+Ext_ResInfo */
+
+
+    if ( ( pVBInfo->SetFlag & ProgrammingCRT2 ) && ( !( pVBInfo->LCDInfo & EnableScalingLCD ) ) )
+    {   /* {LCDA/LCDB} */
+        index = XGI_GetLCDCapPtr(pVBInfo) ;
+        tempal = pVBInfo->LCDCapList[ index ].LCD_VCLK ;
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+            return tempal ;
+
+	/* {TV} */
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV| VB_XGI302LV| VB_XGI301C ) )
+        {
+            if(pVBInfo->VBInfo&SetCRT2ToHiVisionTV)
+           {
+                tempal = HiTVVCLKDIV2;
+                if(!(pVBInfo->TVInfo & RPLLDIV2XO))
+                    tempal = HiTVVCLK;
+	        if(pVBInfo->TVInfo & TVSimuMode)
+                {
+                    tempal = HiTVSimuVCLK;
+                    if(!(modeflag & Charx8Dot))
+              	        tempal = HiTVTextVCLK;
+
+                 }
+                 return tempal;
+             }
+
+            if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+            {
+                tempal = YPbPr750pVCLK ;
+                return tempal ;
+            }
+
+            if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+            {
+                tempal = YPbPr525pVCLK ;
+                return tempal ;
+            }
+
+            tempal = NTSC1024VCLK ;
+
+            if ( !( pVBInfo->TVInfo & NTSC1024x768 ) )
+            {
+                tempal = TVVCLKDIV2 ;
+                if ( !( pVBInfo->TVInfo & RPLLDIV2XO ) )
+                    tempal = TVVCLK ;
+            }
+
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+                return tempal ;
+        }
+        /*else
+        if((pVBInfo->IF_DEF_CH7017==1)&&(pVBInfo->VBType&VB_CH7017))
+        {
+            if(ModeNo<=0x13)
+                *tempal = pVBInfo->SModeIDTable[ModeIdIndex].St_CRT2CRTC;
+            else
+                *tempal = pVBInfo->RefIndex[RefreshRateTableIndex].Ext_CRT2CRTC;
+            *tempal = *tempal & 0x1F;
+
+            tempbx = 0;
+            if(pVBInfo->TVInfo & SetPALTV)
+                tempbx = tempbx + 2;
+            if(pVBInfo->TVInfo & SetCHTVOverScan)
+                tempbx++;
+            tempbx = tempbx << 1;
+        }  */
+    }	/* {End of VB} */
+
+    if((pVBInfo->IF_DEF_CH7007==1)&&(pVBInfo->VBType&VB_CH7007)) /* [Billy] 07/05/08 CH7007 */
+    {
+       /* VideoDebugPrint((0, "XGI_GetVCLKPtr: pVBInfo->IF_DEF_CH7007==1\n")); */
+       if ( (pVBInfo->VBInfo & SetCRT2ToTV) )
+       {
+           if( ModeNo <= 0x13 )
+           {
+              tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+           }
+           else
+           {
+              tempal = pVBInfo->RefIndex[RefreshRateTableIndex].Ext_CRT2CRTC;
+           }
+
+           tempal = tempal & 0x0F;
+           tempbx = 0;
+
+           if(pVBInfo->TVInfo & SetPALTV)
+           {
+              tempbx = tempbx + 2;
+           }
+           if(pVBInfo->TVInfo & SetCHTVOverScan)
+           {
+              tempbx++;
+           }
+           /** tempbx = tempbx << 1; CH7007 ? **/
+
+/*[Billy]07/05/29 CH7007*/
+           if ( pVBInfo->IF_DEF_CH7007 == 1 )
+           {
+             switch( tempbx )
+             {
+               case 0:
+                   CHTVVCLKPtr = XGI7007_CHTVVCLKUNTSC ;
+                   break ;
+               case 1:
+                   CHTVVCLKPtr = XGI7007_CHTVVCLKONTSC ;
+                   break ;
+               case 2:
+                   CHTVVCLKPtr = XGI7007_CHTVVCLKUPAL ;
+                   break ;
+               case 3:
+                   CHTVVCLKPtr = XGI7007_CHTVVCLKOPAL ;
+                   break ;
+               default:
+                   break ;
+
+             }
+           }
+           /*else
+           {
+            switch( tempbx )
+            {
+               case 0:
+                   CHTVVCLKPtr = pVBInfo->CHTVVCLKUNTSC ;
+                   break ;
+               case 1:
+                   CHTVVCLKPtr = pVBInfo->CHTVVCLKONTSC ;
+                   break ;
+               case 2:
+                   CHTVVCLKPtr = pVBInfo->CHTVVCLKUPAL ;
+                   break ;
+               case 3:
+                   CHTVVCLKPtr = pVBInfo->CHTVVCLKOPAL ;
+                   break ;
+               default:
+                   break ;
+            }
+           }*/
+
+           tempal = CHTVVCLKPtr[ tempal ] ;
+           return tempal ;
+       }
+
+    }
+
+    tempal = ( UCHAR )XGINew_GetReg2( ( pVBInfo->P3ca + 0x02 ) ) ;
+    tempal = tempal >> 2 ;
+    tempal &= 0x03 ;
+
+    if ( ( pVBInfo->LCDInfo & EnableScalingLCD ) && ( modeflag & Charx8Dot ) )  /* for Dot8 Scaling LCD */
+        tempal = tempal ^ tempal ;                   /* ; set to VCLK25MHz always */
+
+    if ( ModeNo <= 0x13 )
+        return tempal ;
+
+    tempal = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRTVCLK ;
+    return tempal ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVCLKLen */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetVCLKLen(UCHAR tempal,UCHAR* di_0,UCHAR* di_1, PVB_DEVICE_INFO pVBInfo)
+{
+    if ( pVBInfo->IF_DEF_CH7007 == 1 ) /* [Billy] 2007/05/16 */
+    {
+       /* VideoDebugPrint((0, "XGI_GetVCLKLen: pVBInfo->IF_DEF_CH7007==1\n")); */
+        *di_0 = ( UCHAR )XGI_CH7007VCLKData[ tempal ].SR2B ;
+        *di_1 = ( UCHAR )XGI_CH7007VCLKData[ tempal ].SR2C ;
+    }
+    else if ( pVBInfo->VBType & ( VB_XGI301 | VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) ) && ( pVBInfo->SetFlag & ProgrammingCRT2 ) )
+        {
+            *di_0 = ( UCHAR )XGI_VBVCLKData[ tempal ].SR2B ;
+            *di_1 = XGI_VBVCLKData[ tempal ].SR2C ;
+        }
+    }
+    else
+    {
+        *di_0 = XGI_VCLKData[ tempal ].SR2B ;
+        *di_1 = XGI_VCLKData[ tempal ].SR2C ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2Offset */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT2Offset( USHORT ModeNo ,
+				   USHORT ModeIdIndex , USHORT RefreshRateTableIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT offset ;
+    UCHAR temp ;
+
+    if ( pVBInfo->VBInfo & SetInSlaveMode )
+    {
+        return ;
+    }
+
+    offset = XGI_GetOffset(  ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+    temp = ( UCHAR )( offset & 0xFF ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , temp ) ;
+    temp =( UCHAR)( ( offset & 0xFF00 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x09 , temp ) ;
+    temp =( UCHAR )( ( ( offset >> 3 ) & 0xFF ) + 1 ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x03 , temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetOffset */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetOffset(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT temp ,
+           colordepth ,
+           modeinfo ,
+           index ,
+           infoflag ,
+           ColorDepth[] = { 0x01 , 0x02 , 0x04 } ;
+
+    modeinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeInfo ;
+    if ( ModeNo <= 0x14 )
+        infoflag = 0 ;
+    else
+        infoflag = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_InfoFlag ;
+
+
+    index = ( modeinfo >> 8 ) & 0xFF ;
+
+    temp = pVBInfo->ScreenOffset[ index ] ;
+
+    if ( infoflag & InterlaceMode )
+    {
+        temp = temp << 1 ;
+    }
+
+    colordepth = XGI_GetColorDepth( ModeNo , ModeIdIndex, pVBInfo ) ;
+
+    if ( ( ModeNo >= 0x7C ) && ( ModeNo <= 0x7E ) )
+    {
+        temp = ModeNo - 0x7C ;
+	colordepth = ColorDepth[ temp ] ;
+	temp = 0x6B ;
+	if ( infoflag & InterlaceMode )
+	{
+            temp = temp << 1 ;
+	}
+	return( temp * colordepth ) ;
+    }
+    else
+        return( temp * colordepth ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2FIFO */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT2FIFO( PVB_DEVICE_INFO pVBInfo)
+{
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x01 , 0x3B ) ;			/* threshold high ,disable auto threshold */
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x02 , ~( 0x3F ) , 0x04 ) ;	/* threshold low default 04h */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_PreSetGroup1 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_PreSetGroup1(USHORT ModeNo , USHORT ModeIdIndex ,PXGI_HW_DEVICE_INFO HwDeviceExtension,
+                       USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempcx = 0 ,
+           CRT1Index = 0 ,
+           resinfo = 0 ;
+
+    if ( ModeNo > 0x13 )
+    {
+        CRT1Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+        CRT1Index &= IndexMask ;
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+    }
+
+    XGI_SetCRT2Offset( ModeNo , ModeIdIndex , RefreshRateTableIndex , HwDeviceExtension, pVBInfo ) ;
+    XGI_SetCRT2FIFO(pVBInfo) ;
+    /* XGI_SetCRT2Sync(ModeNo,RefreshRateTableIndex); */
+
+    for( tempcx = 4 ; tempcx < 7 ; tempcx++ )
+    {
+        XGINew_SetReg1( pVBInfo->Part1Port , tempcx , 0x0 ) ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x50 , 0x00 ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x02 , 0x44 ) ;	/* temp 0206 */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGroup1 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGroup1( USHORT ModeNo , USHORT ModeIdIndex ,
+                            PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT temp = 0 ,
+           tempax = 0 ,
+           tempbx = 0 ,
+           tempcx = 0 ,
+           pushbx = 0 ,
+           CRT1Index = 0 ,
+           modeflag ,
+           resinfo = 0 ;
+
+    if ( ModeNo > 0x13 )
+    {
+        CRT1Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+        CRT1Index &= IndexMask ;
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+    }
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    /* bainy change table name */
+    if ( modeflag & HalfDCLK )
+    {
+        temp = ( pVBInfo->VGAHT / 2 - 1 ) & 0x0FF ;			/* BTVGA2HT 0x08,0x09 */
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , temp ) ;
+        temp = ( ( ( pVBInfo->VGAHT / 2 - 1 ) & 0xFF00 ) >> 8 ) << 4 ;
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x09 , ~0x0F0 , temp ) ;
+        temp = ( pVBInfo->VGAHDE / 2 + 16 ) & 0x0FF ;			/* BTVGA2HDEE 0x0A,0x0C */
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x0A , temp ) ;
+        tempcx = ( ( pVBInfo->VGAHT - pVBInfo->VGAHDE ) / 2 ) >> 2 ;
+        pushbx = pVBInfo->VGAHDE / 2 + 16 ;
+        tempcx = tempcx >> 1 ;
+        tempbx = pushbx + tempcx ;					/* bx BTVGA@HRS 0x0B,0x0C */
+        tempcx += tempbx ;
+
+  	if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+  	{
+            tempbx = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 4 ] ;
+            tempbx |= ( ( pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 14 ] & 0xC0 ) << 2 ) ;
+            tempbx = ( tempbx - 3 ) << 3 ;				/* (VGAHRS-3)*8 */
+            tempcx = pVBInfo->XGINEWUB_CRT1Table[CRT1Index].CR[ 5 ] ;
+            tempcx &= 0x1F ;
+            temp = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 15 ] ;
+            temp = ( temp & 0x04 ) << ( 5 - 2 ) ;			/* VGAHRE D[5] */
+            tempcx = ( ( tempcx | temp ) - 3 ) << 3 ;			/* (VGAHRE-3)*8 */
+        }
+
+        tempbx += 4 ;
+        tempcx += 4 ;
+
+        if ( tempcx > ( pVBInfo->VGAHT / 2 ) )
+            tempcx = pVBInfo->VGAHT / 2 ;
+
+        temp = tempbx & 0x00FF ;
+
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x0B , temp ) ;
+    }
+    else
+    {
+        temp = ( pVBInfo->VGAHT - 1 ) & 0x0FF ;				/* BTVGA2HT 0x08,0x09 */
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , temp ) ;
+        temp = ( ( ( pVBInfo->VGAHT - 1 ) & 0xFF00 ) >> 8 ) << 4 ;
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x09 , ~0x0F0 , temp ) ;
+        temp = ( pVBInfo->VGAHDE + 16 ) & 0x0FF ;				/* BTVGA2HDEE 0x0A,0x0C */
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x0A , temp ) ;
+        tempcx = ( pVBInfo->VGAHT - pVBInfo->VGAHDE ) >> 2 ;		/* cx */
+        pushbx = pVBInfo->VGAHDE + 16 ;
+        tempcx = tempcx >> 1 ;
+        tempbx = pushbx + tempcx ;					/* bx BTVGA@HRS 0x0B,0x0C */
+        tempcx += tempbx ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+        {
+            tempbx = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 3 ] ;
+            tempbx |= ( ( pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 5 ] & 0xC0 ) << 2 ) ;
+            tempbx = ( tempbx - 3 ) << 3 ;				/* (VGAHRS-3)*8 */
+            tempcx = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 4 ] ;
+            tempcx &= 0x1F ;
+            temp = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 6 ] ;
+            temp = ( temp & 0x04 ) << ( 5 - 2 ) ;			/* VGAHRE D[5] */
+            tempcx = ( ( tempcx | temp ) - 3 ) << 3 ;			/* (VGAHRE-3)*8 */
+            tempbx += 16 ;
+            tempcx += 16 ;
+        }
+
+        if ( tempcx > pVBInfo->VGAHT )
+            tempcx = pVBInfo->VGAHT ;
+
+        temp = tempbx & 0x00FF ;
+        XGINew_SetReg1( pVBInfo->Part1Port , 0x0B , temp ) ;
+    }
+
+    tempax = ( tempax & 0x00FF ) | ( tempbx & 0xFF00 ) ;
+    tempbx = pushbx ;
+    tempbx = ( tempbx & 0x00FF ) | ( ( tempbx & 0xFF00 ) << 4 ) ;
+    tempax |= ( tempbx & 0xFF00 ) ;
+    temp = ( tempax & 0xFF00 ) >> 8 ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0C , temp ) ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0D , temp ) ;
+    tempcx = ( pVBInfo->VGAVT - 1 ) ;
+    temp = tempcx & 0x00FF ;
+
+    if ( pVBInfo->IF_DEF_CH7005 == 1 )
+    {
+        if ( pVBInfo->VBInfo & 0x0C )
+        {
+            temp-- ;
+	}
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0E , temp ) ;
+    tempbx = pVBInfo->VGAVDE - 1 ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0F , temp ) ;
+    temp = ( ( tempbx & 0xFF00 ) << 3 ) >> 8 ;
+    temp |= ( ( tempcx & 0xFF00 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x12 , temp ) ;
+
+    tempax = pVBInfo->VGAVDE ;
+    tempbx = pVBInfo->VGAVDE ;
+    tempcx = pVBInfo->VGAVT ;
+    tempbx = ( pVBInfo->VGAVT + pVBInfo->VGAVDE ) >> 1 ;				/* BTVGA2VRS 0x10,0x11 */
+    tempcx = ( ( pVBInfo->VGAVT - pVBInfo->VGAVDE ) >> 4 ) + tempbx + 1 ;		/* BTVGA2VRE 0x11 */
+
+    if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+    {
+        tempbx = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 10 ] ;
+        temp = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 9 ] ;
+
+        if ( temp & 0x04 )
+            tempbx |= 0x0100 ;
+
+        if ( temp & 0x080 )
+            tempbx |= 0x0200 ;
+
+        temp = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 14 ] ;
+
+        if ( temp & 0x08 )
+            tempbx |= 0x0400 ;
+
+        temp = pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 11 ] ;
+        tempcx = ( tempcx & 0xFF00 ) | ( temp & 0x00FF ) ;
+    }
+
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x10 , temp ) ;
+    temp = ( ( tempbx & 0xFF00 ) >> 8 ) << 4 ;
+    temp = ( ( tempcx & 0x000F ) | ( temp ) ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x11 , temp ) ;
+    tempax = 0 ;
+
+    if ( modeflag & DoubleScanMode )
+        tempax |= 0x80 ;
+
+    if ( modeflag & HalfDCLK )
+        tempax |= 0x40 ;
+
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2C , ~0x0C0 , tempax ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLockRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void  XGI_SetLockRegs( USHORT ModeNo , USHORT ModeIdIndex ,
+                                PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT push1 ,
+           push2 ,
+           tempax ,
+           tempbx = 0 ,
+           tempcx ,
+           temp ,
+           resinfo ,
+           modeflag ,
+           CRT1Index ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;	/* si+St_ResInfo */
+        resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;	/* si+Ext_ResInfo */
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+        CRT1Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+        CRT1Index &= IndexMask;
+    }
+
+    if ( !( pVBInfo->VBInfo & SetInSlaveMode ) )
+    {
+        return ;
+    }
+
+    temp = 0xFF ;							/* set MAX HT */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x03 , temp ) ;
+    /* if ( modeflag & Charx8Dot ) tempcx = 0x08 ; */
+    /* else */
+    tempcx=0x08;
+
+    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        modeflag |= Charx8Dot ;
+
+    tempax = pVBInfo->VGAHDE ;						/* 0x04 Horizontal Display End */
+
+    if ( modeflag & HalfDCLK )
+        tempax = tempax >> 1 ;
+
+    tempax = ( tempax / tempcx ) - 1 ;
+    tempbx |= ( ( tempax & 0x00FF ) << 8 ) ;
+    temp = tempax & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x04 , temp ) ;
+
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        if ( !( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) ) )
+            temp += 2 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        {
+            if ( pVBInfo->VBType & VB_XGI301LV )
+            {
+                if ( pVBInfo->VBExtInfo == VB_YPbPr1080i )
+                {
+                    if ( resinfo == 7 )
+                        temp -= 2 ;
+                }
+            }
+            else
+                if ( resinfo == 7 )
+                    temp -= 2 ;
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x05 , temp ) ;			/* 0x05 Horizontal Display Start */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x06 , 0x03 ) ;			/* 0x06 Horizontal Blank end */
+
+    if ( !( pVBInfo->VBInfo & DisableCRT2Display ) )
+    {                            					/* 030226 bainy */
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            tempax = pVBInfo->VGAHT ;
+        else
+            tempax = XGI_GetVGAHT2( pVBInfo) ;
+    }
+
+    if ( tempax >= pVBInfo->VGAHT )
+    {
+        tempax = pVBInfo->VGAHT ;
+    }
+
+    if ( modeflag & HalfDCLK )
+    {
+        tempax = tempax >> 1 ;
+    }
+
+    tempax = ( tempax / tempcx ) - 5 ;
+    tempcx = tempax ;				/* 20030401 0x07 horizontal Retrace Start */
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        temp = ( tempbx & 0x00FF ) - 1 ;
+        if ( !( modeflag & HalfDCLK ) )
+        {
+            temp -= 6 ;
+            if ( pVBInfo->TVInfo & TVSimuMode )
+            {
+                temp -= 4 ;
+                if ( ModeNo > 0x13 )
+                    temp -= 10 ;
+            }
+        }
+    }
+    else
+    {
+        /* tempcx = tempbx & 0x00FF ; */
+        tempbx = ( tempbx & 0xFF00 ) >> 8 ;
+        tempcx = ( tempcx + tempbx ) >> 1 ;
+        temp = ( tempcx & 0x00FF ) + 2 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            temp -= 1 ;
+            if ( !( modeflag & HalfDCLK ) )
+            {
+                if ( ( modeflag & Charx8Dot ) )
+                {
+                    temp += 4 ;
+                    if ( pVBInfo->VGAHDE >= 800 )
+                    {
+                        temp -= 6 ;
+                    }
+                }
+            }
+        }
+        else
+        {
+            if ( !( modeflag & HalfDCLK ) )
+            {
+                temp -= 4 ;
+                if ( pVBInfo->LCDResInfo != Panel1280x960 )
+                {
+                    if( pVBInfo->VGAHDE >= 800 )
+                    {
+                        temp -= 7 ;
+                        if ( pVBInfo->ModeType == ModeEGA )
+                        {
+                            if ( pVBInfo->VGAVDE == 1024 )
+                            {
+                                temp += 15 ;
+                                if ( pVBInfo->LCDResInfo != Panel1280x1024 )
+                                {
+                                    temp += 7 ;
+                                }
+                            }
+                        }
+
+                        if ( pVBInfo->VGAHDE >= 1280 )
+                        {
+                            if ( pVBInfo->LCDResInfo != Panel1280x960 )
+                            {
+                                if ( pVBInfo->LCDInfo & LCDNonExpanding )
+                                {
+                                    temp += 28 ;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , temp ) ;		/* 0x07 Horizontal Retrace Start */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0 ) ;		/* 0x08 Horizontal Retrace End */
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        if ( pVBInfo->TVInfo & TVSimuMode )
+        {
+            if ( ( ModeNo == 0x06 ) || ( ModeNo == 0x10 ) || ( ModeNo == 0x11 ) || ( ModeNo == 0x13 ) || ( ModeNo == 0x0F ) )
+            {
+                XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x5b ) ;
+                XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x03 ) ;
+            }
+
+            if ( ( ModeNo == 0x00 ) || ( ModeNo == 0x01 ) )
+            {
+                if ( pVBInfo->TVInfo & SetNTSCTV )
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x2A ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x61 ) ;
+                }
+                else
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x2A ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x41 ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x0C , 0xF0 ) ;
+                }
+            }
+
+            if ( ( ModeNo == 0x02 ) || ( ModeNo == 0x03 ) || ( ModeNo == 0x07 ) )
+            {
+                if ( pVBInfo->TVInfo & SetNTSCTV )
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x54 ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x00 ) ;
+                }
+                else
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x55 ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x00 ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x0C , 0xF0 ) ;
+                }
+            }
+
+            if ( ( ModeNo == 0x04 ) || ( ModeNo == 0x05 ) || ( ModeNo == 0x0D ) || ( ModeNo == 0x50 ) )
+            {
+                if ( pVBInfo->TVInfo & SetNTSCTV )
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x30 ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x03 ) ;
+                }
+                else
+                {
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x07 , 0x2f ) ;
+                    XGINew_SetReg1( pVBInfo->Part1Port , 0x08 , 0x02 ) ;
+                }
+            }
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x18 , 0x03 ) ;				/* 0x18 SR0B */
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x19 , 0xF0 , 0x00 ) ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x09 , 0xFF ) ;				/* 0x09 Set Max VT */
+
+    tempbx = pVBInfo->VGAVT ;
+    push1 = tempbx ;
+    tempcx = 0x121 ;
+    tempbx = pVBInfo->VGAVDE ;							/* 0x0E Virtical Display End */
+
+    if ( tempbx == 357 )
+        tempbx = 350 ;
+    if ( tempbx == 360 )
+        tempbx =350 ;
+    if ( tempbx == 375 )
+        tempbx = 350 ;
+    if ( tempbx == 405 )
+        tempbx = 400 ;
+    if ( tempbx == 525 )
+        tempbx = 480 ;
+
+    push2 = tempbx ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+    {
+        if ( pVBInfo->LCDResInfo == Panel1024x768 )
+        {
+            if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+            {
+                if ( tempbx == 350 )
+                    tempbx += 5 ;
+		if ( tempbx == 480 )
+		    tempbx += 5 ;
+            }
+        }
+    }
+    tempbx-- ;
+    temp = tempbx & 0x00FF ;
+    tempbx-- ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x10 ,temp ) ;				/* 0x10 vertical Blank Start */
+    tempbx = push2 ;
+    tempbx-- ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0E , temp ) ;
+
+    if ( tempbx & 0x0100 )
+    {
+        tempcx |= 0x0002 ;
+    }
+
+    tempax = 0x000B ;
+
+    if ( modeflag & DoubleScanMode )
+    {
+        tempax |= 0x08000 ;
+    }
+
+    if ( tempbx & 0x0200 )
+    {
+        tempcx |= 0x0040 ;
+    }
+
+    temp = ( tempax & 0xFF00 ) >> 8 ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0B , temp ) ;
+
+    if ( tempbx & 0x0400 )
+    {
+        tempcx |= 0x0600 ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x11 , 0x00 ) ;				/* 0x11 Vertival Blank End */
+
+    tempax = push1 ;
+    tempax -= tempbx ;								/* 0x0C Vertical Retrace Start */
+    tempax = tempax >> 2 ;
+    push1 = tempax ;								/* push ax */
+
+    if ( resinfo != 0x09 )
+    {
+        tempax = tempax << 1 ;
+        tempbx += tempax ;
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        if ( pVBInfo->VBType & VB_XGI301LV )
+        {
+            if ( pVBInfo->TVInfo & SetYPbPrMode1080i )
+                tempbx -= 10 ;
+            else
+            {
+                if ( pVBInfo->TVInfo & TVSimuMode )
+                {
+                    if ( pVBInfo->TVInfo & SetPALTV )
+                    {
+                        if ( pVBInfo->VBType & VB_XGI301LV )
+                        {
+                            if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p | SetYPbPrMode1080i ) ) )
+                                tempbx += 40 ;
+                        }
+                        else
+                            tempbx += 40 ;
+                    }
+                }
+            }
+        }
+        else
+            tempbx -= 10 ;
+    }
+    else
+    {
+        if ( pVBInfo->TVInfo & TVSimuMode )
+        {
+            if ( pVBInfo->TVInfo & SetPALTV )
+            {
+                if ( pVBInfo->VBType & VB_XGI301LV )
+                {
+                    if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p | SetYPbPrMode1080i ) ) )
+                        tempbx += 40 ;
+                }
+                else
+                    tempbx += 40 ;
+            }
+        }
+    }
+    tempax = push1 ;
+    tempax = tempax >> 2 ;
+    tempax++ ;
+    tempax += tempbx ;
+    push1 = tempax ;						/* push ax */
+
+    if ( ( pVBInfo->TVInfo & SetPALTV ) )
+    {
+        if ( tempbx <= 513 )
+        {
+            if ( tempax >= 513 )
+            {
+                tempbx = 513 ;
+            }
+        }
+    }
+
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0C , temp ) ;
+    tempbx-- ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x10 , temp ) ;
+
+    if ( tempbx & 0x0100 )
+    {
+        tempcx |= 0x0008 ;
+    }
+
+    if ( tempbx & 0x0200 )
+    {
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x0B , 0x0FF , 0x20 ) ;
+    }
+
+    tempbx++ ;
+
+    if ( tempbx & 0x0100 )
+    {
+        tempcx |= 0x0004 ;
+    }
+
+    if ( tempbx & 0x0200 )
+    {
+        tempcx |= 0x0080 ;
+    }
+
+    if ( tempbx & 0x0400 )
+    {
+        tempcx |= 0x0C00 ;
+    }
+
+    tempbx = push1 ;						/* pop ax */
+    temp = tempbx & 0x00FF ;
+    temp &= 0x0F ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0D , temp ) ;		/* 0x0D vertical Retrace End */
+
+    if ( tempbx & 0x0010 )
+    {
+        tempcx |= 0x2000 ;
+    }
+
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0A , temp ) ;		/* 0x0A CR07 */
+    temp = ( tempcx & 0x0FF00 ) >> 8 ;
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x17 , temp ) ;		/* 0x17 SR0A */
+    tempax = modeflag ;
+    temp = ( tempax & 0xFF00 ) >> 8 ;
+
+    temp = ( temp >> 1 ) & 0x09 ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        temp |= 0x01 ;
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x16 , temp ) ;			/* 0x16 SR01 */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x0F , 0 ) ;			/* 0x0F CR14 */
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x12 , 0 ) ;			/* 0x12 CR17 */
+
+    if ( pVBInfo->LCDInfo & LCDRGB18Bit )
+        temp = 0x80 ;
+    else
+        temp = 0x00 ;
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x1A , temp ) ;			/* 0x1A SR0E */
+
+    return ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGroup2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGroup2( USHORT ModeNo, USHORT ModeIdIndex, USHORT RefreshRateTableIndex,
+                    PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT i ,
+           j ,
+           tempax ,
+           tempbx ,
+           tempcx ,
+           temp ,
+           push1 ,
+           push2 ,
+           modeflag ,
+           resinfo ,
+           crt2crtc ;
+    UCHAR *TimingPoint ;
+
+    ULONG longtemp ,
+          tempeax ,
+          tempebx ,
+          temp2 ,
+          tempecx ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;		/* si+St_ResInfo */
+        resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;
+        crt2crtc = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;		/* si+Ext_ResInfo */
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+        crt2crtc = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC ;
+    }
+
+    tempax = 0 ;
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToAVIDEO ) )
+        tempax |= 0x0800 ;
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToSVIDEO ) )
+        tempax |= 0x0400 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToSCART )
+        tempax |= 0x0200 ;
+
+    if ( !( pVBInfo->TVInfo & SetPALTV ) )
+        tempax |= 0x1000 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        tempax |= 0x0100 ;
+
+    if ( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) )
+        tempax &= 0xfe00 ;
+
+    tempax = ( tempax & 0xff00 ) >> 8 ;
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x0 , tempax ) ;
+    TimingPoint = pVBInfo->NTSCTiming ;
+
+    if ( pVBInfo->TVInfo & SetPALTV )
+    {
+        TimingPoint = pVBInfo->PALTiming ;
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        TimingPoint = pVBInfo->HiTVExtTiming ;
+
+        if ( pVBInfo->VBInfo & SetInSlaveMode )
+            TimingPoint = pVBInfo->HiTVSt2Timing ;
+
+        if ( pVBInfo->SetFlag & TVSimuMode )
+            TimingPoint = pVBInfo->HiTVSt1Timing ;
+
+        if ( !(modeflag & Charx8Dot) )
+            TimingPoint = pVBInfo->HiTVTextTiming ;
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+    {
+        if ( pVBInfo->TVInfo & SetYPbPrMode525i )
+            TimingPoint = pVBInfo->YPbPr525iTiming ;
+
+        if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+    	    TimingPoint = pVBInfo->YPbPr525pTiming ;
+
+        if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+    	    TimingPoint = pVBInfo->YPbPr750pTiming ;
+    }
+
+    for( i = 0x01 , j = 0 ; i <= 0x2D ; i++ , j++ )
+    {
+        XGINew_SetReg1( pVBInfo->Part2Port , i , TimingPoint[ j ] ) ;
+    }
+
+    for( i = 0x39 ; i <= 0x45 ; i++ , j++ )
+    {
+        XGINew_SetReg1( pVBInfo->Part2Port , i , TimingPoint[ j ] ) ;	/* di->temp2[j] */
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x3A , 0x1F , 0x00 ) ;
+    }
+
+    temp = pVBInfo->NewFlickerMode ;
+    temp &= 0x80 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x0A , 0xFF , temp ) ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        tempax = 950 ;
+
+    if ( pVBInfo->TVInfo & SetPALTV )
+        tempax = 520 ;
+    else
+        tempax = 440 ;
+
+    if ( pVBInfo->VDE <= tempax )
+    {
+        tempax -= pVBInfo->VDE ;
+        tempax = tempax >> 2 ;
+        tempax = ( tempax & 0x00FF ) | ( ( tempax & 0x00FF ) << 8 ) ;
+        push1 = tempax ;
+        temp = ( tempax & 0xFF00 ) >> 8 ;
+        temp += ( USHORT )TimingPoint[ 0 ] ;
+
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            if ( pVBInfo->VBInfo & ( SetCRT2ToAVIDEO | SetCRT2ToSVIDEO | SetCRT2ToSCART | SetCRT2ToYPbPr ) )
+            {
+                tempcx=pVBInfo->VGAHDE;
+                if ( tempcx >= 1024 )
+                {
+                    temp = 0x17 ;		/* NTSC */
+                    if ( pVBInfo->TVInfo & SetPALTV )
+                        temp = 0x19 ;		/* PAL */
+                }
+            }
+        }
+
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x01 , temp ) ;
+        tempax = push1 ;
+        temp = ( tempax & 0xFF00 ) >> 8 ;
+        temp += TimingPoint[ 1 ] ;
+
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            if ( ( pVBInfo->VBInfo & ( SetCRT2ToAVIDEO | SetCRT2ToSVIDEO | SetCRT2ToSCART | SetCRT2ToYPbPr ) ) )
+            {
+                tempcx = pVBInfo->VGAHDE ;
+                if ( tempcx >= 1024 )
+                {
+                    temp = 0x1D ;		/* NTSC */
+                    if ( pVBInfo->TVInfo & SetPALTV )
+                        temp = 0x52 ;		/* PAL */
+                }
+            }
+        }
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x02 , temp ) ;
+    }
+
+    /* 301b */
+    tempcx = pVBInfo->HT ;
+
+    if ( XGI_IsLCDDualLink( pVBInfo ) )
+        tempcx = tempcx >> 1 ;
+
+    tempcx -= 2 ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x1B , temp ) ;
+
+    temp = ( tempcx & 0xFF00 ) >> 8 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x1D , ~0x0F , temp ) ;
+
+    tempcx = pVBInfo->HT >> 1 ;
+    push1 = tempcx ;				/* push cx */
+    tempcx += 7 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        tempcx -= 4 ;
+    }
+
+    temp = tempcx & 0x00FF ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x22 , 0x0F , temp ) ;
+
+    tempbx = TimingPoint[ j ] | ( ( TimingPoint[ j + 1 ] ) << 8 ) ;
+    tempbx += tempcx ;
+    push2 = tempbx ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x24 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR(pVBInfo->Part2Port,0x25,0x0F,temp);
+
+    tempbx=push2;
+    tempbx=tempbx+8;
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        tempbx=tempbx-4;
+        tempcx=tempbx;
+    }
+
+    temp = ( tempbx & 0x00FF ) << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x29 , 0x0F , temp ) ;
+
+    j += 2 ;
+    tempcx += ( TimingPoint[ j ] | ( ( TimingPoint[ j + 1 ] ) << 8 ) ) ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x27 , temp ) ;
+    temp = ( ( tempcx & 0xFF00 ) >> 8 ) << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x28 , 0x0F , temp ) ;
+
+    tempcx += 8 ;
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        tempcx -= 4 ;
+    }
+
+    temp = tempcx & 0xFF ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x2A , 0x0F , temp ) ;
+
+    tempcx = push1 ;					/* pop cx */
+    j += 2 ;
+    temp = TimingPoint[ j ] | ( ( TimingPoint[ j + 1 ] ) << 8 ) ;
+    tempcx -= temp ;
+    temp = tempcx & 0x00FF ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x2D , 0x0F ,temp ) ;
+
+    tempcx -= 11 ;
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToTV ) )
+    {
+        tempax = XGI_GetVGAHT2( pVBInfo) ;
+        tempcx = tempax - 1 ;
+    }
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x2E , temp ) ;
+
+    tempbx = pVBInfo->VDE ;
+
+    if ( pVBInfo->VGAVDE == 360 )
+        tempbx = 746 ;
+    if ( pVBInfo->VGAVDE == 375 )
+        tempbx = 746 ;
+    if ( pVBInfo->VGAVDE == 405 )
+        tempbx = 853 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) ) )
+                tempbx = tempbx >> 1 ;
+        }
+        else
+            tempbx = tempbx >> 1 ;
+    }
+
+    tempbx -= 2 ;
+    temp = tempbx & 0x00FF ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        if ( pVBInfo->VBType & VB_XGI301LV )
+        {
+            if ( pVBInfo->TVInfo & SetYPbPrMode1080i )
+            {
+                if ( pVBInfo->VBInfo & SetInSlaveMode )
+                {
+                    if ( ModeNo == 0x2f )
+                        temp += 1 ;
+                }
+            }
+        }
+        else
+        {
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+            {
+                if ( ModeNo == 0x2f )
+                    temp += 1 ;
+            }
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x2F , temp ) ;
+
+    temp = ( tempcx & 0xFF00 ) >> 8 ;
+    temp |= ( ( tempbx & 0xFF00 ) >> 8 ) << 6 ;
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToHiVisionTV ) )
+    {
+        if ( pVBInfo->VBType & VB_XGI301LV )
+        {
+            if ( pVBInfo->TVInfo & SetYPbPrMode1080i )
+            {
+                temp |= 0x10 ;
+
+                if ( !( pVBInfo->VBInfo & SetCRT2ToSVIDEO ) )
+                    temp |= 0x20 ;
+            }
+        }
+        else
+        {
+            temp |= 0x10 ;
+            if ( !( pVBInfo->VBInfo & SetCRT2ToSVIDEO ) )
+                temp |= 0x20 ;
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x30 , temp ) ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )	/* TV gatingno */
+    {
+        tempbx = pVBInfo->VDE ;
+        tempcx = tempbx - 2 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) ) )
+                tempbx = tempbx >> 1 ;
+        }
+
+        if ( pVBInfo->VBType & ( VB_XGI302LV | VB_XGI301C ) )
+        {
+            temp=0;
+            if( tempcx & 0x0400 )
+                temp |= 0x20 ;
+
+            if ( tempbx & 0x0400 )
+                temp |= 0x40 ;
+
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x10 , temp ) ;
+        }
+
+        temp = ( ( ( tempbx - 3 ) & 0x0300 ) >> 8 ) << 5 ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x46 , temp ) ;
+        temp = ( tempbx - 3 ) & 0x00FF ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x47 , temp ) ;
+    }
+
+    tempbx = tempbx & 0x00FF ;
+
+    if ( !( modeflag & HalfDCLK ) )
+    {
+        tempcx = pVBInfo->VGAHDE ;
+        if ( tempcx >= pVBInfo->HDE )
+        {
+            tempbx |= 0x2000 ;
+            tempax &= 0x00FF ;
+        }
+    }
+
+    tempcx = 0x0101 ;
+
+    if( pVBInfo->VBInfo & SetCRT2ToTV ) { /*301b*/
+        if(pVBInfo->VGAHDE>=1024)
+        {
+	    tempcx=0x1920;
+            if(pVBInfo->VGAHDE>=1280)
+            {
+	        tempcx=0x1420;
+	        tempbx=tempbx&0xDFFF;
+            }
+        }
+    }
+
+    if ( !( tempbx & 0x2000 ) )
+    {
+        if ( modeflag & HalfDCLK )
+        {
+            tempcx = ( tempcx & 0xFF00 ) | ( ( tempcx & 0x00FF ) << 1 ) ;
+	}
+
+        push1 = tempbx ;
+        tempeax = pVBInfo->VGAHDE ;
+        tempebx = ( tempcx & 0xFF00 ) >> 8 ;
+        longtemp = tempeax * tempebx ;
+        tempecx = tempcx & 0x00FF ;
+        longtemp = longtemp / tempecx ;
+
+	/* 301b */
+        tempecx = 8 * 1024 ;
+
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            tempecx = tempecx * 8 ;
+        }
+
+        longtemp = longtemp * tempecx ;
+        tempecx = pVBInfo->HDE ;
+        temp2 = longtemp % tempecx ;
+        tempeax = longtemp / tempecx ;
+        if ( temp2 != 0 )
+        {
+            tempeax += 1 ;
+        }
+
+        tempax = ( USHORT )tempeax ;
+
+	/* 301b */
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            tempcx = ( ( tempax & 0xFF00 ) >> 5 ) >> 8 ;
+        }
+        /* end 301b */
+
+        tempbx = push1 ;
+        tempbx =( USHORT )( ( ( tempeax & 0x0000FF00 ) & 0x1F00 ) | ( tempbx & 0x00FF ) ) ;
+        tempax =( USHORT )( ( ( tempeax & 0x000000FF ) << 8 ) | ( tempax & 0x00FF ) ) ;
+        temp = ( tempax & 0xFF00 ) >> 8 ;
+    }
+    else
+    {
+        temp = ( tempax & 0x00FF ) >> 8 ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x44 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x45 , ~0x03F , temp ) ;
+    temp = tempcx & 0x00FF ;
+
+    if ( tempbx & 0x2000 )
+        temp = 0 ;
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToLCD ) )
+        temp |= 0x18 ;
+
+    XGINew_SetRegANDOR(pVBInfo->Part2Port,0x46,~0x1F,temp);
+    if ( pVBInfo->TVInfo & SetPALTV )
+    {
+        tempbx = 0x0382 ;
+        tempcx = 0x007e ;
+    }
+    else
+    {
+        tempbx = 0x0369 ;
+        tempcx = 0x0061 ;
+    }
+
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x4b , temp ) ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x4c , temp ) ;
+
+    temp = ( ( tempcx & 0xFF00 ) >> 8 ) & 0x03 ;
+    temp = temp << 2 ;
+    temp |= ( ( tempbx & 0xFF00 ) >> 8 ) & 0x03 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+    {
+        temp |= 0x10 ;
+
+        if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+            temp |= 0x20 ;
+
+        if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+            temp |= 0x60 ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x4d , temp ) ;
+    temp=XGINew_GetReg1( pVBInfo->Part2Port , 0x43 ) ;		/* 301b change */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x43 , ( USHORT )( temp - 3 ) ) ;
+
+    if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) ) )
+    {
+        if ( pVBInfo->TVInfo & NTSC1024x768 )
+        {
+            TimingPoint = XGI_NTSC1024AdjTime ;
+            for( i = 0x1c , j = 0 ; i <= 0x30 ; i++ , j++ )
+            {
+                XGINew_SetReg1( pVBInfo->Part2Port , i , TimingPoint[ j ] ) ;
+            }
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x43 , 0x72 ) ;
+        }
+    }
+
+    /* [ycchen] 01/14/03 Modify for 301C PALM Support */
+    if ( pVBInfo->VBType & VB_XGI301C )
+    {
+        if ( pVBInfo->TVInfo & SetPALMTV )
+	    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x4E , ~0x08 , 0x08 ) ;	/* PALM Mode */
+    }
+
+    if ( pVBInfo->TVInfo & SetPALMTV )
+    {
+        tempax = ( UCHAR )XGINew_GetReg1( pVBInfo->Part2Port , 0x01 ) ;
+        tempax-- ;
+        XGINew_SetRegAND( pVBInfo->Part2Port , 0x01 , tempax ) ;
+
+        /* if ( !( pVBInfo->VBType & VB_XGI301C ) ) */
+        XGINew_SetRegAND( pVBInfo->Part2Port , 0x00 , 0xEF ) ;
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+    {
+        if ( !( pVBInfo->VBInfo & SetInSlaveMode ) )
+        {
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x0B , 0x00 ) ;
+        }
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        return ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLCDRegs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void  XGI_SetLCDRegs(USHORT ModeNo,USHORT ModeIdIndex, PXGI_HW_DEVICE_INFO HwDeviceExtension,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT push1 ,
+           push2 ,
+           pushbx ,
+           tempax ,
+           tempbx ,
+           tempcx ,
+           temp ,
+           tempah ,
+           tempbh ,
+           tempch ,
+           resinfo ,
+           modeflag ,
+           CRT1Index ;
+
+    XGI_LCDDesStruct *LCDBDesPtr = NULL ;
+
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;	/* si+St_ResInfo */
+        resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;	/* si+Ext_ResInfo */
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+        CRT1Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+        CRT1Index &= IndexMask ;
+    }
+
+    if ( !( pVBInfo->VBInfo & SetCRT2ToLCD ) )
+    {
+        return ;
+    }
+
+    tempbx = pVBInfo->HDE ;			/* RHACTE=HDE-1 */
+
+    if ( XGI_IsLCDDualLink( pVBInfo ) )
+        tempbx = tempbx >> 1 ;
+
+    tempbx -= 1 ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x2C , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x2B , 0x0F , temp ) ;
+    temp = 0x01 ;
+
+    if ( pVBInfo->LCDResInfo == Panel1280x1024 )
+    {
+        if ( pVBInfo->ModeType == ModeEGA )
+        {
+            if ( pVBInfo->VGAHDE >= 1024 )
+            {
+                temp = 0x02 ;
+                if ( pVBInfo->LCDInfo & LCDVESATiming )
+                    temp = 0x01 ;
+            }
+        }
+    }
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x0B , temp ) ;
+    tempbx = pVBInfo->VDE ;			/* RTVACTEO=(VDE-1)&0xFF */
+    push1 = tempbx ;
+    tempbx-- ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x03 , temp ) ;
+    temp = ( ( tempbx & 0xFF00 ) >> 8 ) & 0x07 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x0C , ~0x07 , temp ) ;
+
+    tempcx = pVBInfo->VT - 1 ;
+    push2 = tempcx + 1 ;
+    temp = tempcx & 0x00FF ;			/* RVTVT=VT-1 */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x19 , temp ) ;
+    temp = ( tempcx & 0xFF00 ) >> 8 ;
+    temp = temp << 5 ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x1A , temp ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x09 , 0xF0 , 0x00 ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x0A , 0xF0 , 0x00 ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x17 , 0xFB , 0x00 ) ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x18 , 0xDF , 0x00 ) ;
+
+    /* Customized LCDB Des no add */
+    tempbx = 5 ;
+    LCDBDesPtr = ( XGI_LCDDesStruct * )XGI_GetLcdPtr( tempbx , ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+    tempah = pVBInfo->LCDResInfo ;
+    tempah &= PanelResInfo ;
+
+    if ( ( tempah == Panel1024x768 ) || ( tempah == Panel1024x768x75 ) )
+    {
+        tempbx = 1024 ;
+        tempcx = 768 ;
+    }
+    else if ( ( tempah == Panel1280x1024 ) || ( tempah == Panel1280x1024x75 ) )
+    {
+        tempbx = 1280 ;
+        tempcx = 1024 ;
+    }
+    else if ( tempah == Panel1400x1050 )
+    {
+        tempbx = 1400 ;
+        tempcx = 1050 ;
+    }
+    else
+    {
+        tempbx = 1600 ;
+        tempcx = 1200 ;
+    }
+
+    if ( pVBInfo->LCDInfo & EnableScalingLCD )
+    {
+        tempbx = pVBInfo->HDE ;
+        tempcx = pVBInfo->VDE ;
+    }
+
+    pushbx = tempbx ;
+    tempax = pVBInfo->VT ;
+    pVBInfo->LCDHDES = LCDBDesPtr->LCDHDES ;
+    pVBInfo->LCDHRS = LCDBDesPtr->LCDHRS ;
+    pVBInfo->LCDVDES = LCDBDesPtr->LCDVDES ;
+    pVBInfo->LCDVRS = LCDBDesPtr->LCDVRS ;
+    tempbx = pVBInfo->LCDVDES ;
+    tempcx += tempbx ;
+
+    if ( tempcx >= tempax )
+        tempcx -= tempax ;	/* lcdvdes */
+
+    temp = tempbx & 0x00FF ;	/* RVEQ1EQ=lcdvdes */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x05 , temp ) ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x06 , temp ) ;
+    tempch = ( ( tempcx & 0xFF00 ) >> 8 ) & 0x07 ;
+    tempbh = ( ( tempbx & 0xFF00 ) >> 8 ) & 0x07 ;
+    tempah = tempch ;
+    tempah = tempah << 3 ;
+    tempah |= tempbh ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x02 , tempah ) ;
+
+    /* getlcdsync() */
+    XGI_GetLCDSync( &tempax , &tempbx,pVBInfo ) ;
+    tempcx = tempbx ;
+    tempax = pVBInfo->VT ;
+    tempbx = pVBInfo->LCDVRS ;
+
+    /* if ( SetLCD_Info & EnableScalingLCD ) */
+    tempcx += tempbx ;
+    if ( tempcx >= tempax )
+        tempcx -= tempax ;
+
+    temp = tempbx & 0x00FF ;	/* RTVACTEE=lcdvrs */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x04 , temp ) ;
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp = temp << 4 ;
+    temp |= ( tempcx & 0x000F ) ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x01 , temp ) ;
+    tempcx = pushbx ;
+    tempax = pVBInfo->HT ;
+    tempbx = pVBInfo->LCDHDES ;
+    tempbx &= 0x0FFF ;
+
+    if ( XGI_IsLCDDualLink(  pVBInfo ) )
+    {
+        tempax = tempax >> 1 ;
+        tempbx = tempbx >> 1 ;
+        tempcx = tempcx >> 1 ;
+    }
+
+    if ( pVBInfo->VBType & VB_XGI302LV )
+        tempbx += 1 ;
+
+    if ( pVBInfo->VBType & VB_XGI301C )  /* tap4 */
+        tempbx += 1 ;
+
+    tempcx += tempbx ;
+
+    if ( tempcx >= tempax )
+        tempcx -= tempax ;
+
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x1F , temp ) ;	/* RHBLKE=lcdhdes */
+    temp = ( ( tempbx & 0xFF00 ) >> 8 ) << 4 ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x20 , temp ) ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x23 , temp ) ;	/* RHEQPLE=lcdhdee */
+    temp = ( tempcx & 0xFF00 ) >> 8 ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x25 , temp ) ;
+
+    /* getlcdsync() */
+    XGI_GetLCDSync( &tempax , &tempbx ,pVBInfo) ;
+    tempcx = tempax ;
+    tempax = pVBInfo->HT ;
+    tempbx = pVBInfo->LCDHRS ;
+    /* if ( SetLCD_Info & EnableScalingLCD) */
+    if ( XGI_IsLCDDualLink( pVBInfo) )
+    {
+        tempax = tempax >> 1 ;
+        tempbx = tempbx >> 1 ;
+        tempcx = tempcx >> 1 ;
+    }
+
+    if ( pVBInfo->VBType & VB_XGI302LV )
+        tempbx += 1 ;
+
+    tempcx += tempbx ;
+
+    if ( tempcx >= tempax )
+        tempcx -= tempax ;
+
+    temp = tempbx & 0x00FF ;	/* RHBURSTS=lcdhrs */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x1C , temp ) ;
+
+    temp = ( tempbx & 0xFF00 ) >> 8 ;
+    temp = temp << 4 ;
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x1D , ~0x0F0 , temp ) ;
+    temp = tempcx & 0x00FF ;	/* RHSYEXP2S=lcdhre */
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x21 , temp ) ;
+
+    if ( !( pVBInfo->LCDInfo & LCDVESATiming ) )
+    {
+        if ( pVBInfo->VGAVDE == 525 )
+        {
+            if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+            {
+                temp = 0xC6 ;
+            }
+            else
+                temp = 0xC4 ;
+
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x2f , temp ) ;
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x30 , 0xB3 ) ;
+        }
+
+        if ( pVBInfo->VGAVDE == 420 )
+        {
+            if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+            {
+                temp = 0x4F ;
+            }
+            else
+                temp = 0x4E ;
+            XGINew_SetReg1( pVBInfo->Part2Port , 0x2f , temp ) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetTap4Ptr */
+/* Input : */
+/* Output : di -> Tap4 Reg. Setting Pointer */
+/* Description : */
+/* --------------------------------------------------------------------- */
+XGI301C_Tap4TimingStruct* XGI_GetTap4Ptr(USHORT tempcx, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax ,
+           tempbx ,
+           i ;
+
+    XGI301C_Tap4TimingStruct *Tap4TimingPtr ;
+
+    if ( tempcx == 0 )
+    {
+        tempax = pVBInfo->VGAHDE ;
+        tempbx = pVBInfo->HDE ;
+    }
+    else
+    {
+        tempax = pVBInfo->VGAVDE ;
+        tempbx = pVBInfo->VDE ;
+    }
+
+    if ( tempax < tempbx )
+        return &EnlargeTap4Timing[ 0 ] ;
+    else if( tempax == tempbx )
+        return &NoScaleTap4Timing[ 0 ] ; 	/* 1:1 */
+    else
+        Tap4TimingPtr = NTSCTap4Timing ; 	/* NTSC */
+
+    if ( pVBInfo->TVInfo & SetPALTV )
+        Tap4TimingPtr = PALTap4Timing ;
+
+
+    if ( pVBInfo->VBInfo & SetCRT2ToYPbPr )
+    {
+        if ( pVBInfo->TVInfo & SetYPbPrMode525i )
+            Tap4TimingPtr = YPbPr525iTap4Timing ;
+        if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+            Tap4TimingPtr = YPbPr525pTap4Timing ;
+        if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+            Tap4TimingPtr = YPbPr750pTap4Timing ;
+    }
+
+    if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+        Tap4TimingPtr = HiTVTap4Timing ;
+
+    i = 0 ;
+    while( Tap4TimingPtr[ i ].DE != 0xFFFF )
+    {
+        if ( Tap4TimingPtr[ i ].DE == tempax )
+            break ;
+        i++ ;
+    }
+    return &Tap4TimingPtr[ i ] ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetTap4Regs */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetTap4Regs( PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT i ,
+           j ;
+
+    XGI301C_Tap4TimingStruct *Tap4TimingPtr ;
+
+    if ( !( pVBInfo->VBType & VB_XGI301C ) )
+        return ;
+
+#ifndef Tap4
+    XGINew_SetRegAND( pVBInfo->Part2Port , 0x4E , 0xEB ) ;	/* Disable Tap4 */
+#else            /* Tap4 Setting */
+
+    Tap4TimingPtr = XGI_GetTap4Ptr( 0 , pVBInfo) ;  /* Set Horizontal Scaling */
+    for( i = 0x80 , j = 0 ; i <= 0xBF ; i++ , j++ )
+        XGINew_SetReg1( pVBInfo->Part2Port , i , Tap4TimingPtr->Reg[ j ] ) ;
+
+    if ( ( pVBInfo->VBInfo & SetCRT2ToTV ) && ( !( pVBInfo->VBInfo & SetCRT2ToHiVisionTV ) ) )
+    {
+        Tap4TimingPtr = XGI_GetTap4Ptr( 1 , pVBInfo);	/* Set Vertical Scaling */
+        for( i = 0xC0 , j = 0 ; i < 0xFF ; i++ , j++ )
+            XGINew_SetReg1( pVBInfo->Part2Port , i , Tap4TimingPtr->Reg[ j ] ) ;
+    }
+
+    if ( ( pVBInfo->VBInfo & SetCRT2ToTV ) && ( !( pVBInfo->VBInfo & SetCRT2ToHiVisionTV ) ) )
+        XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x4E , ~0x14 , 0x04 ) ;	/* Enable V.Scaling */
+    else
+        XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x4E , ~0x14 , 0x10 ) ;	/* Enable H.Scaling */
+#endif
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGroup3 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGroup3(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT i;
+    UCHAR *tempdi;
+    USHORT  modeflag;
+
+    if(ModeNo<=0x13)
+    {
+        modeflag = pVBInfo->SModeIDTable[ModeIdIndex].St_ModeFlag;      /* si+St_ResInfo */
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ModeIdIndex].Ext_ModeFlag;     /* si+Ext_ResInfo */
+    }
+
+
+    XGINew_SetReg1(pVBInfo->Part3Port,0x00,0x00);
+    if(pVBInfo->TVInfo&SetPALTV)
+    {
+        XGINew_SetReg1(pVBInfo->Part3Port,0x13,0xFA);
+        XGINew_SetReg1(pVBInfo->Part3Port,0x14,0xC8);
+    }
+    else
+    {
+        XGINew_SetReg1(pVBInfo->Part3Port,0x13,0xF5);
+        XGINew_SetReg1(pVBInfo->Part3Port,0x14,0xB7);
+    }
+
+    if(!(pVBInfo->VBInfo&SetCRT2ToTV))
+    {
+        return;
+    }
+
+    if(pVBInfo->TVInfo&SetPALMTV)
+    {
+        XGINew_SetReg1(pVBInfo->Part3Port,0x13,0xFA);
+        XGINew_SetReg1(pVBInfo->Part3Port,0x14,0xC8);
+        XGINew_SetReg1(pVBInfo->Part3Port,0x3D,0xA8);
+    }
+
+    if((pVBInfo->VBInfo&SetCRT2ToHiVisionTV)|| (pVBInfo->VBInfo&SetCRT2ToYPbPr))
+    {
+        if(pVBInfo->TVInfo & SetYPbPrMode525i)
+        {
+            return;
+        }
+        tempdi=pVBInfo->HiTVGroup3Data;
+        if(pVBInfo->SetFlag&TVSimuMode)
+        {
+            tempdi=pVBInfo->HiTVGroup3Simu;
+            if(!(modeflag&Charx8Dot))
+            {
+                tempdi=pVBInfo->HiTVGroup3Text;
+            }
+        }
+
+        if(pVBInfo->TVInfo & SetYPbPrMode525p)
+        {
+            tempdi=pVBInfo->Ren525pGroup3;
+        }
+        if(pVBInfo->TVInfo & SetYPbPrMode750p)
+        {
+             tempdi=pVBInfo->Ren750pGroup3;
+        }
+
+        for(i=0;i<=0x3E;i++)
+        {
+            XGINew_SetReg1(pVBInfo->Part3Port,i,tempdi[i]);
+        }
+        if(pVBInfo->VBType&VB_XGI301C)  /* Marcovision */
+        {
+            if(pVBInfo->TVInfo & SetYPbPrMode525p)
+            {
+                XGINew_SetReg1(pVBInfo->Part3Port,0x28,0x3f);
+            }
+        }
+    }
+    return;
+}  /* {end of XGI_SetGroup3} */
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGroup4 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGroup4(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax ,
+           tempcx ,
+           tempbx ,
+           modeflag ,
+           temp ,
+           temp2 ;
+
+    ULONG tempebx ,
+          tempeax ,
+          templong ;
+
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;	/* si+St_ResInfo */
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;	/* si+Ext_ResInfo */
+    }
+
+    temp = pVBInfo->RVBHCFACT ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x13 , temp ) ;
+
+    tempbx = pVBInfo->RVBHCMAX ;
+    temp = tempbx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x14 , temp ) ;
+    temp2 = ( ( tempbx & 0xFF00 ) >> 8 ) << 7 ;
+    tempcx = pVBInfo->VGAHT - 1 ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x16 , temp ) ;
+
+    temp =( ( tempcx & 0xFF00 ) >> 8 ) << 3 ;
+    temp2 |= temp ;
+
+    tempcx = pVBInfo->VGAVT - 1 ;
+    if ( !( pVBInfo->VBInfo & SetCRT2ToTV ) )
+    {
+        tempcx -= 5 ;
+    }
+
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x17 , temp ) ;
+    temp = temp2 | ( ( tempcx & 0xFF00 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x15 , temp ) ;
+    XGINew_SetRegOR( pVBInfo->Part4Port , 0x0D , 0x08 ) ;
+    tempcx = pVBInfo->VBInfo ;
+    tempbx = pVBInfo->VGAHDE ;
+
+    if ( modeflag & HalfDCLK )
+    {
+        tempbx = tempbx >> 1 ;
+    }
+
+    if ( XGI_IsLCDDualLink( pVBInfo ) )
+        tempbx = tempbx >> 1 ;
+
+    if(tempcx&SetCRT2ToHiVisionTV)
+    {
+        temp=0;
+        if(tempbx<=1024)
+            temp=0xA0;
+       if(tempbx == 1280)
+          temp = 0xC0;
+    }
+    else if(tempcx&SetCRT2ToTV)
+    {
+         temp=0xA0;
+         if(tempbx <= 800)
+             temp=0x80;
+    }
+    else
+    {
+	 temp=0x80;
+	 if(pVBInfo->VBInfo&SetCRT2ToLCD)
+	 {
+	     temp=0;
+	     if(tempbx>800)
+	         temp=0x60;
+	 }
+    }
+
+    if ( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) )
+    {
+        temp = 0x00 ;
+        if ( pVBInfo->VGAHDE == 1280 )
+            temp = 0x40 ;
+        if ( pVBInfo->VGAHDE == 1024 )
+	    temp = 0x20 ;
+    }
+    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x0E , ~0xEF , temp ) ;
+
+    tempebx = pVBInfo->VDE ;
+
+    if ( tempcx & SetCRT2ToHiVisionTV )
+    {
+        if ( !( temp & 0xE000 ) )
+            tempbx = tempbx >> 1 ;
+    }
+
+    tempcx = pVBInfo->RVBHRS ;
+    temp = tempcx & 0x00FF ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x18 , temp );
+
+    tempeax = pVBInfo->VGAVDE ;
+    tempcx |= 0x04000 ;
+
+
+    if ( tempeax <= tempebx )
+    {
+        tempcx=(tempcx&(~0x4000));
+        tempeax = pVBInfo->VGAVDE ;
+    }
+    else
+    {
+        tempeax -= tempebx ;
+    }
+
+
+    templong = ( tempeax * 256 * 1024 ) % tempebx ;
+    tempeax = ( tempeax * 256 * 1024 ) / tempebx ;
+    tempebx = tempeax ;
+
+    if ( templong != 0 )
+    {
+        tempebx++ ;
+    }
+
+
+    temp = ( USHORT )( tempebx & 0x000000FF ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x1B , temp ) ;
+
+    temp = ( USHORT )( ( tempebx & 0x0000FF00 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x1A , temp ) ;
+    tempbx = ( USHORT )( tempebx >> 16 ) ;
+    temp = tempbx & 0x00FF ;
+    temp = temp << 4 ;
+    temp |= ( ( tempcx & 0xFF00 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x19 , temp ) ;
+
+    /* 301b */
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        temp = 0x0028 ;
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x1C , temp ) ;
+        tempax = pVBInfo->VGAHDE ;
+        if ( modeflag & HalfDCLK )
+        {
+            tempax = tempax >> 1 ;
+        }
+
+        if ( XGI_IsLCDDualLink( pVBInfo ) )
+            tempax = tempax >> 1 ;
+
+        /* if((pVBInfo->VBInfo&(SetCRT2ToLCD))||((pVBInfo->TVInfo&SetYPbPrMode525p)||(pVBInfo->TVInfo&SetYPbPrMode750p))) { */
+        if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+        {
+            if ( tempax > 800 )
+                tempax -= 800 ;
+        }
+        else
+        {
+            if ( pVBInfo->VGAHDE > 800 )
+            {
+                if ( pVBInfo->VGAHDE == 1024 )
+                    tempax = ( tempax * 25 / 32 ) - 1 ;
+                else
+                    tempax = ( tempax * 20 / 32 ) - 1 ;
+            }
+        }
+        tempax -= 1 ;
+
+/*
+        if ( pVBInfo->VBInfo & ( SetCRT2ToTV | SetCRT2ToHiVisionTV ) )
+        {
+            if ( pVBInfo->VBType & VB_XGI301LV )
+            {
+                if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p | SetYPbPrMode1080i ) ) )
+                {
+                    if ( pVBInfo->VGAHDE > 800 )
+                    {
+                        if ( pVBInfo->VGAHDE == 1024 )
+                            tempax = ( tempax * 25 / 32 ) - 1 ;
+                        else
+                            tempax = ( tempax * 20 / 32 ) - 1 ;
+                    }
+                }
+            }
+            else
+            {
+                if ( pVBInfo->VGAHDE > 800 )
+                {
+                    if ( pVBInfo->VGAHDE == 1024 )
+                        tempax = ( tempax * 25 / 32 ) - 1 ;
+                    else
+                        tempax = ( tempax * 20 / 32 ) - 1 ;
+                }
+            }
+        }
+*/
+
+        temp = ( tempax & 0xFF00 ) >> 8 ;
+        temp = ( ( temp & 0x0003 ) << 4 ) ;
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x1E , temp ) ;
+        temp = ( tempax & 0x00FF ) ;
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x1D , temp ) ;
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToTV | SetCRT2ToHiVisionTV ) )
+        {
+            if ( pVBInfo->VGAHDE > 800 )
+            {
+                XGINew_SetRegOR( pVBInfo->Part4Port , 0x1E , 0x08 ) ;
+            }
+        }
+        temp = 0x0036 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            if ( !( pVBInfo->TVInfo & ( NTSC1024x768 | SetYPbPrMode525p | SetYPbPrMode750p | SetYPbPrMode1080i ) ) )
+            {
+                temp |= 0x0001 ;
+                if ( ( pVBInfo->VBInfo & SetInSlaveMode ) && ( !( pVBInfo->TVInfo & TVSimuMode ) ) )
+                    temp &= ( ~0x0001 ) ;
+            }
+        }
+
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x1F , 0x00C0 , temp ) ;
+        tempbx = pVBInfo->HT ;
+        if ( XGI_IsLCDDualLink( pVBInfo ) )
+            tempbx = tempbx >> 1 ;
+        tempbx = ( tempbx >> 1 ) - 2 ;
+        temp = ( ( tempbx & 0x0700 ) >> 8 ) << 3 ;
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x21 , 0x00C0 , temp ) ;
+        temp = tempbx & 0x00FF ;
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x22 , temp ) ;
+    }
+    /* end 301b */
+
+    if ( pVBInfo->ISXPDOS == 0 )
+        XGI_SetCRT2VCLK( ModeNo , ModeIdIndex , RefreshRateTableIndex, pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetGroup5 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetGroup5( USHORT ModeNo , USHORT ModeIdIndex , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT Pindex ,
+           Pdata ;
+
+    Pindex = pVBInfo->Part5Port ;
+    Pdata = pVBInfo->Part5Port + 1 ;
+    if ( pVBInfo->ModeType == ModeVGA )
+    {
+        if ( !( pVBInfo->VBInfo & ( SetInSlaveMode | LoadDACFlag | CRT2DisplayFlag ) ) )
+        {
+            XGINew_EnableCRT2(pVBInfo) ;
+            /* LoadDAC2(pVBInfo->Part5Port,ModeNo,ModeIdIndex); */
+        }
+    }
+    return ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLcdPtr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void* XGI_GetLcdPtr( USHORT BX , USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT i ,
+           tempdx ,
+           tempcx ,
+           tempbx ,
+           tempal ,
+           modeflag ,
+           table ;
+
+    XGI330_LCDDataTablStruct *tempdi = 0 ;
+
+
+    tempbx = BX;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+        tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        tempal = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC ;
+    }
+
+    tempal = tempal & 0x0f ;
+
+    if ( tempbx <= 1 )		/* ExpLink */
+    {
+        if ( ModeNo <= 0x13 )
+        {
+            tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ; /* find no Ext_CRT2CRTC2 */
+        }
+        else
+        {
+            tempal= pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC ;
+        }
+
+        if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+        {
+            if ( ModeNo <= 0x13 )
+                tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC2 ;
+            else
+                tempal= pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC2 ;
+        }
+
+        if ( tempbx & 0x01 )
+            tempal = ( tempal >> 4 ) ;
+
+        tempal = ( tempal & 0x0f ) ;
+    }
+
+    tempcx = LCDLenList[ tempbx ] ;	/* mov cl,byte ptr cs:LCDLenList[bx] */
+
+    if ( pVBInfo->LCDInfo & EnableScalingLCD )	/* ScaleLCD */
+    {
+        if ( ( tempbx == 5 ) || ( tempbx ) == 7 )
+            tempcx = LCDDesDataLen2 ;
+        else if ( ( tempbx == 3 ) || ( tempbx == 8 ) )
+            tempcx = LVDSDesDataLen2 ;
+    }
+    /* mov di, word ptr cs:LCDDataList[bx] */
+    /* tempdi=pVideoMemory[LCDDataList+tempbx*2]|(pVideoMemory[LCDDataList+tempbx*2+1]<<8); */
+
+    switch( tempbx )
+    {
+        case 0:
+            tempdi = XGI_EPLLCDCRT1Ptr_H ;
+            break ;
+        case 1:
+            tempdi = XGI_EPLLCDCRT1Ptr_V ;
+             break ;
+        case 2:
+            tempdi = XGI_EPLLCDDataPtr ;
+            break ;
+        case 3:
+            tempdi = XGI_EPLLCDDesDataPtr ;
+            break ;
+        case 4:
+            tempdi = XGI_LCDDataTable ;
+            break ;
+        case 5:
+            tempdi = XGI_LCDDesDataTable ;
+            break ;
+        case 6:
+            tempdi = XGI_EPLCHLCDRegPtr ;
+            break ;
+        case 7:
+        case 8:
+        case 9:
+            tempdi = 0 ;
+            break ;
+        default:
+        break ;
+    }
+
+    if ( tempdi == 0x00 )  /* OEMUtil */
+        return 0 ;
+
+    table = tempbx ;
+    i = 0 ;
+
+    while( tempdi[ i ].PANELID != 0xff )
+    {
+        tempdx = pVBInfo->LCDResInfo ;
+        if ( tempbx & 0x0080 )     /* OEMUtil */
+        {
+            tempbx &= ( ~0x0080 ) ;
+            tempdx = pVBInfo->LCDTypeInfo ;
+        }
+
+        if ( pVBInfo->LCDInfo & EnableScalingLCD )
+        tempdx &= ( ~PanelResInfo ) ;
+
+        if ( tempdi[ i ].PANELID == tempdx )
+        {
+            tempbx = tempdi[ i ].MASK ;
+            tempdx = pVBInfo->LCDInfo ;
+
+            if ( ModeNo <= 0x13 )         /* alan 09/10/2003 */
+                tempdx |= SetLCDStdMode ;
+
+            if ( modeflag & HalfDCLK )
+                tempdx |= SetLCDLowResolution ;
+
+            tempbx &= tempdx;
+            if ( tempbx == tempdi[ i ].CAP )
+                break ;
+        }
+        i++ ;
+    }
+
+    if ( table == 0 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_LVDSCRT11024x768_1_H[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_LVDSCRT11024x768_2_H[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_LVDSCRT11280x1024_1_H[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_LVDSCRT11280x1024_2_H[ tempal ] ;
+                break ;
+            case 4:
+                return &XGI_LVDSCRT11400x1050_1_H[ tempal ] ;
+                break ;
+            case 5:
+                return &XGI_LVDSCRT11400x1050_2_H[ tempal ] ;
+                break ;
+            case 6:
+                return &XGI_LVDSCRT11600x1200_1_H[ tempal ] ;
+                break ;
+            case 7:
+                return &XGI_LVDSCRT11024x768_1_Hx75[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_LVDSCRT11024x768_2_Hx75[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_LVDSCRT11280x1024_1_Hx75[ tempal ] ;
+                break ;
+            case 10:
+                return &XGI_LVDSCRT11280x1024_2_Hx75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 1 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_LVDSCRT11024x768_1_V[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_LVDSCRT11024x768_2_V[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_LVDSCRT11280x1024_1_V[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_LVDSCRT11280x1024_2_V[ tempal ] ;
+                break ;
+            case 4:
+                return &XGI_LVDSCRT11400x1050_1_V[ tempal ] ;
+                break ;
+            case 5:
+                return &XGI_LVDSCRT11400x1050_2_V[ tempal ] ;
+                break ;
+            case 6:
+                return &XGI_LVDSCRT11600x1200_1_V[ tempal ] ;
+                break ;
+            case 7:
+                return &XGI_LVDSCRT11024x768_1_Vx75[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_LVDSCRT11024x768_2_Vx75[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_LVDSCRT11280x1024_1_Vx75[ tempal ] ;
+                break ;
+            case 10:
+                return &XGI_LVDSCRT11280x1024_2_Vx75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 2 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_LVDS1024x768Data_1[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_LVDS1024x768Data_2[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_LVDS1280x1024Data_1[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_LVDS1280x1024Data_2[ tempal ] ;
+                break ;
+            case 4:
+                return &XGI_LVDS1400x1050Data_1[ tempal ] ;
+                break ;
+            case 5:
+                return &XGI_LVDS1400x1050Data_2[ tempal ] ;
+                break ;
+            case 6:
+                return &XGI_LVDS1600x1200Data_1[ tempal ] ;
+                break ;
+            case 7:
+                return &XGI_LVDSNoScalingData[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_LVDS1024x768Data_1x75[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_LVDS1024x768Data_2x75[ tempal ] ;
+                break ;
+            case 10:
+                return &XGI_LVDS1280x1024Data_1x75[ tempal ] ;
+                break ;
+            case 11:
+                return &XGI_LVDS1280x1024Data_2x75[ tempal ] ;
+                break ;
+            case 12:
+                return &XGI_LVDSNoScalingDatax75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 3 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_LVDS1024x768Des_1[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_LVDS1024x768Des_3[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_LVDS1024x768Des_2[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_LVDS1280x1024Des_1[ tempal ] ;
+                break ;
+            case 4:
+                return &XGI_LVDS1280x1024Des_2[ tempal ] ;
+                break ;
+            case 5:
+                return &XGI_LVDS1400x1050Des_1[ tempal ] ;
+                break ;
+            case 6:
+                return &XGI_LVDS1400x1050Des_2[ tempal ] ;
+                break ;
+            case 7:
+                return &XGI_LVDS1600x1200Des_1[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_LVDSNoScalingDesData[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_LVDS1024x768Des_1x75[ tempal ] ;
+                break ;
+            case 10:
+                return &XGI_LVDS1024x768Des_3x75[ tempal ] ;
+                break ;
+            case 11:
+                return &XGI_LVDS1024x768Des_2x75[ tempal ] ;
+                break;
+            case 12:
+                return &XGI_LVDS1280x1024Des_1x75[ tempal ] ;
+                break ;
+            case 13:
+                return &XGI_LVDS1280x1024Des_2x75[ tempal ] ;
+                break ;
+            case 14:
+                return &XGI_LVDSNoScalingDesDatax75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 4 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_ExtLCD1024x768Data[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_StLCD1024x768Data[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_CetLCD1024x768Data[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_ExtLCD1280x1024Data[ tempal ] ;
+                break ;
+            case 4:
+                return &XGI_StLCD1280x1024Data[ tempal ] ;
+                break ;
+            case 5:
+                return &XGI_CetLCD1280x1024Data[ tempal ] ;
+                break ;
+            case 6:
+                return &XGI_ExtLCD1400x1050Data[ tempal ] ;
+                break ;
+            case 7:
+                return &XGI_StLCD1400x1050Data[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_CetLCD1400x1050Data[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_ExtLCD1600x1200Data[ tempal ] ;
+                break  ;
+            case 10:
+                return &XGI_StLCD1600x1200Data[ tempal ] ;
+                break ;
+            case 11:
+                return &XGI_NoScalingData[ tempal ] ;
+                break ;
+            case 12:
+                return &XGI_ExtLCD1024x768x75Data[ tempal ] ;
+                break ;
+            case 13:
+                return &XGI_ExtLCD1024x768x75Data[ tempal ] ;
+                break ;
+            case 14:
+                return &XGI_CetLCD1024x768x75Data[ tempal ] ;
+                break ;
+            case 15:
+                 return &XGI_ExtLCD1280x1024x75Data[ tempal ] ;
+                break ;
+            case 16:
+                return &XGI_StLCD1280x1024x75Data[ tempal ] ;
+                break;
+            case 17:
+                return &XGI_CetLCD1280x1024x75Data[ tempal ] ;
+                break;
+            case 18:
+                return &XGI_NoScalingDatax75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 5 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_ExtLCDDes1024x768Data[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_StLCDDes1024x768Data[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_CetLCDDes1024x768Data[ tempal ] ;
+                break ;
+            case 3:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_ExtLCDDLDes1280x1024Data[ tempal ] ;
+                else
+                    return &XGI_ExtLCDDes1280x1024Data[ tempal ] ;
+                break ;
+            case 4:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_StLCDDLDes1280x1024Data[ tempal ] ;
+                else
+                    return &XGI_StLCDDes1280x1024Data[ tempal ] ;
+                break ;
+            case 5:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_CetLCDDLDes1280x1024Data[ tempal ] ;
+                else
+                    return &XGI_CetLCDDes1280x1024Data[ tempal ] ;
+                break ;
+            case 6:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_ExtLCDDLDes1400x1050Data[ tempal ] ;
+                else
+                    return &XGI_ExtLCDDes1400x1050Data[ tempal ] ;
+                break ;
+            case 7:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_StLCDDLDes1400x1050Data[ tempal ] ;
+                else
+                    return &XGI_StLCDDes1400x1050Data[ tempal ] ;
+                break ;
+            case 8:
+                return &XGI_CetLCDDes1400x1050Data[ tempal ] ;
+                break ;
+            case 9:
+                return &XGI_CetLCDDes1400x1050Data2[ tempal ] ;
+                break ;
+            case 10:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_ExtLCDDLDes1600x1200Data[ tempal ] ;
+                else
+                    return &XGI_ExtLCDDes1600x1200Data[ tempal ] ;
+                break ;
+            case 11:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_StLCDDLDes1600x1200Data[ tempal ] ;
+                else
+                    return &XGI_StLCDDes1600x1200Data[ tempal ] ;
+                break ;
+            case 12:
+                return &XGI_NoScalingDesData[ tempal ] ;
+                break;
+            case 13:
+                return &XGI_ExtLCDDes1024x768x75Data[ tempal ] ;
+                break ;
+            case 14:
+                return &XGI_StLCDDes1024x768x75Data[ tempal ] ;
+                break ;
+            case 15:
+                return &XGI_CetLCDDes1024x768x75Data[ tempal ] ;
+                break ;
+            case 16:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_ExtLCDDLDes1280x1024x75Data[ tempal ] ;
+                else
+                    return &XGI_ExtLCDDes1280x1024x75Data[ tempal ] ;
+                break ;
+            case 17:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_StLCDDLDes1280x1024x75Data[ tempal ] ;
+                else
+                    return &XGI_StLCDDes1280x1024x75Data[ tempal ] ;
+                break ;
+            case 18:
+                if ( ( pVBInfo->VBType & VB_XGI301LV ) || ( pVBInfo->VBType & VB_XGI302LV ) )
+                    return &XGI_CetLCDDLDes1280x1024x75Data[ tempal ] ;
+                else
+                    return &XGI_CetLCDDes1280x1024x75Data[ tempal ] ;
+                break ;
+            case 19:
+                return &XGI_NoScalingDesDatax75[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if ( table == 6 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_CH7017LV1024x768[ tempal ] ;
+                break ;
+            case 1:
+                return &XGI_CH7017LV1400x1050[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    return 0 ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetTVPtr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void* XGI_GetTVPtr (USHORT BX,USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT i , tempdx , tempbx , tempal , modeflag , table ;
+    XGI330_TVDataTablStruct *tempdi = 0 ;
+
+    tempbx = BX ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+        tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        tempal = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC ;
+    }
+
+    tempal = tempal & 0x3f ;
+    table = tempbx ;
+
+    switch( tempbx )
+    {
+        case 0:
+            tempdi = 0 ;	/*EPLCHTVCRT1Ptr_H;*/
+            if ( pVBInfo->IF_DEF_CH7007 == 1 )
+            {
+                tempdi = XGI_EPLCHTVCRT1Ptr;
+            }
+            break ;
+        case 1:
+            tempdi = 0 ;	/*EPLCHTVCRT1Ptr_V;*/
+            if ( pVBInfo->IF_DEF_CH7007 == 1 )
+            {
+                tempdi = XGI_EPLCHTVCRT1Ptr;
+            }
+            break ;
+        case 2:
+            tempdi = XGI_EPLCHTVDataPtr ;
+            break ;
+        case 3:
+            tempdi = 0 ;
+            break ;
+        case 4:
+            tempdi = XGI_TVDataTable ;
+            break ;
+        case 5:
+            tempdi = 0 ;
+            break ;
+        case 6:
+            tempdi = XGI_EPLCHTVRegPtr ;
+            break ;
+        default:
+            break ;
+    }
+
+    if ( tempdi == 0x00 )  /* OEMUtil */
+        return( 0 ) ;
+
+    tempdx = pVBInfo->TVInfo ;
+
+    if ( pVBInfo->VBInfo & SetInSlaveMode )
+        tempdx = tempdx | SetTVLockMode ;
+
+    if ( modeflag & HalfDCLK )
+        tempdx = tempdx | SetTVLowResolution ;
+
+    i = 0 ;
+
+    while( tempdi[ i ].MASK != 0xffff )
+    {
+        if ( ( tempdx & tempdi[ i ].MASK ) == tempdi[ i ].CAP )
+            break ;
+        i++ ;
+    }
+
+    if ( table == 0x00 ) /* 07/05/22 */
+    {
+#ifdef WIN2000
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+          switch( tempdi[ i ].DATAPTR )
+          {
+            case 0:
+                return &CH7007TVCRT1UNTSC_H[ tempal ] ;
+                break ;
+            case 1:
+                return &CH7007TVCRT1ONTSC_H[ tempal ] ;
+                break ;
+            case 2:
+                return &CH7007TVCRT1UPAL_H[ tempal ] ;
+                break ;
+            case 3:
+                return &CH7007TVCRT1OPAL_H[ tempal ] ;
+                break ;
+            default:
+                break ;
+          }
+        }
+#endif
+    }
+    else if ( table == 0x01 )
+    {
+#ifdef WIN2000
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+          switch( tempdi[ i ].DATAPTR )
+          {
+            case 0:
+                return &CH7007TVCRT1UNTSC_V[ tempal ] ;
+                break ;
+            case 1:
+                return &CH7007TVCRT1ONTSC_V[ tempal ] ;
+                break ;
+            case 2:
+                return &CH7007TVCRT1UPAL_V[ tempal ] ;
+                break ;
+            case 3:
+                return &CH7007TVCRT1OPAL_V[ tempal ] ;
+                break ;
+            default:
+                break ;
+          }
+        }
+#endif
+    }
+    else if ( table == 0x04 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_ExtPALData[ tempal ] ;
+		break ;
+            case 1:
+                return &XGI_ExtNTSCData[ tempal ] ;
+ 		break ;
+      	    case 2:
+      	   	return &XGI_StPALData[ tempal ] ;
+ 		break ;
+            case 3:
+           	return &XGI_StNTSCData[ tempal ] ;
+ 		break ;
+      	    case 4:
+      	   	return &XGI_ExtHiTVData[ tempal ] ;
+ 		break ;
+      	    case 5:
+      	   	return &XGI_St2HiTVData[ tempal ] ;
+ 		break ;
+      	    case 6:
+      	   	return &XGI_ExtYPbPr525iData[ tempal ] ;
+ 		break ;
+      	    case 7:
+      	   	return &XGI_ExtYPbPr525pData[ tempal ] ;
+ 		break ;
+      	    case 8:
+      	   	return &XGI_ExtYPbPr750pData[ tempal ] ;
+ 		break ;
+      	    case 9:
+      	   	return &XGI_StYPbPr525iData[ tempal ] ;
+ 		break ;
+      	    case 10:
+      	   	return &XGI_StYPbPr525pData[ tempal ] ;
+ 		break ;
+      	    case 11:
+      	   	return &XGI_StYPbPr750pData[ tempal ] ;
+             	break;
+            case 12: 	/* avoid system hang */
+      	   	return &XGI_ExtNTSCData[ tempal ] ;
+             	break ;
+            case 13:
+      	   	return &XGI_St1HiTVData[ tempal ] ;
+             	break ;
+            default:
+                break ;
+        }
+    }
+    else if( table == 0x02 )
+    {
+        switch( tempdi[ i ].DATAPTR )
+        {
+            case 0:
+                return &XGI_CHTVUNTSCData[ tempal ] ;
+                break ;
+            case 1:
+      	        return &XGI_CHTVONTSCData[ tempal ] ;
+                break ;
+            case 2:
+                return &XGI_CHTVUPALData[ tempal ] ;
+                break ;
+            case 3:
+                return &XGI_CHTVOPALData[ tempal ] ;
+                break ;
+            default:
+                break ;
+        }
+    }
+    else if( table == 0x06 )
+    {
+#ifdef WIN2000
+        if ( pVBInfo->IF_DEF_CH7007 == 1 )
+        {
+          /* VideoDebugPrint((0, "XGI_GetTVPtr: pVBInfo->IF_DEF_CH7007==1\n")); */
+          switch( tempdi[ i ].DATAPTR )
+          {
+            case 0:
+                return &CH7007TVReg_UNTSC[ tempal ] ;
+                break ;
+            case 1:
+                return &CH7007TVReg_ONTSC[ tempal ] ;
+                break ;
+            case 2:
+                return &CH7007TVReg_UPAL[ tempal ] ;
+                break ;
+            case 3:
+                return &CH7007TVReg_OPAL[ tempal ] ;
+                break ;
+            default:
+                break ;
+          }
+        }
+        else
+        {
+            switch( tempdi[ i ].DATAPTR )
+            {
+              case 0:
+                return &XGI_CHTVRegUNTSC[ tempal ] ;
+                break ;
+              case 1:
+                return &XGI_CHTVRegONTSC[ tempal ] ;
+                break ;
+              case 2:
+                return &XGI_CHTVRegUPAL[ tempal ] ;
+                break ;
+              case 3:
+                return &XGI_CHTVRegOPAL[ tempal ] ;
+                break ;
+              default:
+                break ;
+            }
+        }
+#endif
+    }
+    return( 0 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_BacklightByDrv */
+/* Input : */
+/* Output : TRUE -> Skip backlight control */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_BacklightByDrv( PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR tempah ;
+
+    tempah = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x3A ) ;
+    if ( tempah & BacklightControlBit )
+        return TRUE ;
+    else
+        return FALSE ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_FirePWDDisable */
+/* Input : */
+/* Output : */
+/* Description : Turn off VDD & Backlight : Fire disable procedure */
+/* --------------------------------------------------------------------- */
+/*
+void XGI_FirePWDDisable( PVB_DEVICE_INFO pVBInfo )
+{
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x26 , 0x00 , 0xFC ) ;
+}
+*/
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_FirePWDEnable */
+/* Input : */
+/* Output : */
+/* Description : Turn on VDD & Backlight : Fire enable procedure */
+/* --------------------------------------------------------------------- */
+void XGI_FirePWDEnable(PVB_DEVICE_INFO pVBInfo )
+{
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x26 , 0x03 , 0xFC ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_EnableGatingCRT */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_EnableGatingCRT(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x63 , 0xBF , 0x40 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisableGatingCRT */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_DisableGatingCRT(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x63 , 0xBF , 0x00 ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetPanelDelay */
+/* Input : */
+/* Output : */
+/* Description : */
+/* I/P : bl : 1 ; T1 : the duration between CPL on and signal on */
+/* : bl : 2 ; T2 : the duration signal on and Vdd on */
+/* : bl : 3 ; T3 : the duration between CPL off and signal off */
+/* : bl : 4 ; T4 : the duration signal off and Vdd off */
+/* --------------------------------------------------------------------- */
+void XGI_SetPanelDelay(USHORT tempbl, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT index ;
+
+    index = XGI_GetLCDCapPtr(pVBInfo) ;
+
+    if ( tempbl == 1 )
+        XGINew_LCD_Wait_Time( pVBInfo->LCDCapList[ index ].PSC_S1, pVBInfo ) ;
+
+    if ( tempbl == 2 )
+        XGINew_LCD_Wait_Time( pVBInfo->LCDCapList[ index ].PSC_S2, pVBInfo ) ;
+
+    if ( tempbl == 3 )
+        XGINew_LCD_Wait_Time( pVBInfo->LCDCapList[ index ].PSC_S3, pVBInfo ) ;
+
+    if ( tempbl == 4 )
+        XGINew_LCD_Wait_Time( pVBInfo->LCDCapList[ index ].PSC_S4, pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetPanelPower */
+/* Input : */
+/* Output : */
+/* Description : */
+/* I/O : ah = 0011b = 03h ; Backlight on, Power on */
+/* = 0111b = 07h ; Backlight on, Power off */
+/* = 1011b = 0Bh ; Backlight off, Power on */
+/* = 1111b = 0Fh ; Backlight off, Power off */
+/* --------------------------------------------------------------------- */
+void XGI_SetPanelPower(USHORT tempah,USHORT tempbl, PVB_DEVICE_INFO pVBInfo)
+{
+    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x26 , tempbl , tempah ) ;
+    else
+        XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x11 , tempbl , tempah ) ;
+}
+
+UCHAR XG21GPIODataTransfer(UCHAR ujDate)
+{
+    UCHAR  ujRet = 0;
+    UCHAR  i = 0;
+
+    for (i=0; i<8; i++)
+	{
+    	ujRet = ujRet << 1;
+	/* ujRet |= GETBITS(ujDate >> i, 0:0); */
+        ujRet |= (ujDate >> i) & 1;
+    }
+
+	return ujRet;
+}
+
+/*----------------------------------------------------------------------------*/
+/* output                                                                     */
+/*      bl[5] : LVDS signal                                                   */
+/*      bl[1] : LVDS backlight                                                */
+/*      bl[0] : LVDS VDD                                                      */
+/*----------------------------------------------------------------------------*/
+UCHAR XGI_XG21GetPSCValue(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR4A,temp;
+
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x23 ) ; /* enable GPIO write */
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;
+
+    temp = XG21GPIODataTransfer(temp);
+    temp &= 0x23;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x4A , CR4A ) ;
+    return temp;
+}
+
+/*----------------------------------------------------------------------------*/
+/* output                                                                     */
+/*      bl[5] : LVDS signal                                                   */
+/*      bl[1] : LVDS backlight                                                */
+/*      bl[0] : LVDS VDD                                                      */
+/*----------------------------------------------------------------------------*/
+UCHAR XGI_XG27GetPSCValue(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR4A,CRB4,temp;
+
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~0x0C ) ; /* enable GPIO write */
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;
+
+    temp &= 0x0C;
+    temp >>= 2;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x4A , CR4A ) ;
+    CRB4 = XGINew_GetReg1( pVBInfo->P3d4 , 0xB4 ) ;
+    temp |= ((CRB4&0x04)<<3);
+    return temp;
+}
+/*----------------------------------------------------------------------------*/
+/* input                                                                      */
+/*      bl[5] : 1;LVDS signal on                                              */
+/*      bl[1] : 1;LVDS backlight on                                           */
+/*      bl[0] : 1:LVDS VDD on                                                 */
+/*      bh: 100000b : clear bit 5, to set bit5                                */
+/*          000010b : clear bit 1, to set bit1                                */
+/*          000001b : clear bit 0, to set bit0                                */
+/*----------------------------------------------------------------------------*/
+void XGI_XG21BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR4A,temp;
+
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    tempbh &= 0x23;
+    tempbl &= 0x23;
+    XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~tempbh ) ; /* enable GPIO write */
+
+    if (tempbh&0x20)
+    {
+      temp = (tempbl>>4)&0x02;
+
+      XGINew_SetRegANDOR( pVBInfo->P3d4 , 0xB4 , ~0x02 , temp) ; /* CR B4[1] */
+
+    }
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x48 ) ;
+
+    temp = XG21GPIODataTransfer(temp);
+    temp &= ~tempbh;
+    temp |= tempbl;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x48 , temp ) ;
+}
+
+void XGI_XG27BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR CR4A,temp;
+    USHORT tempbh0,tempbl0;
+
+    tempbh0 = tempbh;
+    tempbl0 = tempbl;
+    tempbh0 &= 0x20;
+    tempbl0 &= 0x20;
+    tempbh0 >>= 3;
+    tempbl0 >>= 3;
+
+    if (tempbh&0x20)
+    {
+      temp = (tempbl>>4)&0x02;
+
+      XGINew_SetRegANDOR( pVBInfo->P3d4 , 0xB4 , ~0x02 , temp) ; /* CR B4[1] */
+
+    }
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0xB4 , ~tempbh0 , tempbl0 ) ;
+
+    CR4A = XGINew_GetReg1( pVBInfo->P3d4 , 0x4A ) ;
+    tempbh &= 0x03;
+    tempbl &= 0x03;
+    tempbh <<= 2;
+    tempbl <<= 2;                                       /* GPIOC,GPIOD */
+    XGINew_SetRegAND( pVBInfo->P3d4 , 0x4A , ~tempbh ) ; /* enable GPIO write */
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x48 , ~tempbh , tempbl ) ;
+}
+
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetLVDSOEMTableIndex(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT index ;
+
+    index = XGINew_GetReg1( pVBInfo->P3d4 , 0x36 ) ;
+    if (index<sizeof(XGI21_LCDCapList)/sizeof(XGI21_LVDSCapStruct))
+    {
+      return index;
+    }
+    return 0;
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_XG21SetPanelDelay */
+/* Input : */
+/* Output : */
+/* Description : */
+/* I/P : bl : 1 ; T1 : the duration between CPL on and signal on */
+/* : bl : 2 ; T2 : the duration signal on and Vdd on */
+/* : bl : 3 ; T3 : the duration between CPL off and signal off */
+/* : bl : 4 ; T4 : the duration signal off and Vdd off */
+/* --------------------------------------------------------------------- */
+void XGI_XG21SetPanelDelay(USHORT tempbl, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT index ;
+
+    index = XGI_GetLVDSOEMTableIndex( pVBInfo );
+    if ( tempbl == 1 )
+        XGINew_LCD_Wait_Time( pVBInfo->XG21_LVDSCapList[ index ].PSC_S1, pVBInfo ) ;
+
+    if ( tempbl == 2 )
+        XGINew_LCD_Wait_Time( pVBInfo->XG21_LVDSCapList[ index ].PSC_S2, pVBInfo ) ;
+
+    if ( tempbl == 3 )
+        XGINew_LCD_Wait_Time( pVBInfo->XG21_LVDSCapList[ index ].PSC_S3, pVBInfo ) ;
+
+    if ( tempbl == 4 )
+        XGINew_LCD_Wait_Time( pVBInfo->XG21_LVDSCapList[ index ].PSC_S4, pVBInfo ) ;
+}
+
+BOOLEAN XGI_XG21CheckLVDSMode(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT xres ,
+           yres ,
+           colordepth ,
+           modeflag ,
+           resindex ,
+           lvdstableindex;
+
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( ModeNo <= 0x13 )
+    {
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->StResInfo[ resindex ].VTotal ;
+        modeflag = pVBInfo->SModeIDTable[ModeIdIndex].St_ModeFlag;    /* si+St_ResInfo */
+    }
+    else
+    {
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;			  /* xres->ax */
+        yres = pVBInfo->ModeResInfo[ resindex ].VTotal ;			  /* yres->bx */
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex].Ext_ModeFlag ; /* si+St_ModeFlag */
+    }
+
+    if ( !( modeflag & Charx8Dot ) )
+    {
+        xres /= 9;
+        xres *= 8;
+    }
+
+    if ( ModeNo > 0x13 )
+    {
+        if ( ( ModeNo>0x13 ) && ( modeflag & HalfDCLK ) )
+        {
+          xres *=  2 ;
+        }
+        if ( ( ModeNo>0x13 ) && ( modeflag & DoubleScanMode ) )
+        {
+          yres *=  2 ;
+        }
+    }
+
+    lvdstableindex = XGI_GetLVDSOEMTableIndex( pVBInfo );
+    if ( xres > (pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE) )
+      return FALSE;
+
+    if ( yres > (pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE) )
+      return FALSE;
+
+    if ( ModeNo > 0x13 )
+    {
+      if ( ( xres != (pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE) ) ||
+           ( yres != (pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE)) )
+      {
+          colordepth = XGI_GetColorDepth( ModeNo , ModeIdIndex, pVBInfo ) ;
+          if ( colordepth > 2 )
+          {
+            return FALSE;
+          }
+      }
+    }
+    return TRUE;
+}
+
+void XGI_SetXG21FPBits(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR temp;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4  , 0x37 ) ;  /* D[0] 1: 18bit */
+    temp = ( temp & 1 ) << 6;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x06 , ~0x40 , temp ) ;      /* SR06[6] 18bit Dither */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x09 , ~0xc0 , temp | 0x80 ) ;  /* SR09[7] enable FP output, SR09[6] 1: sigle 18bits, 0: dual 12bits */
+
+}
+
+void XGI_SetXG27FPBits(PVB_DEVICE_INFO pVBInfo)
+{
+    UCHAR temp;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4  , 0x37 ) ;  /* D[1:0] 01: 18bit, 00: dual 12, 10: single 24 */
+    temp = ( temp & 3 ) << 6;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x06 , ~0xc0 , temp & 0x80 ) ;  /* SR06[7]0: dual 12/1: single 24 [6] 18bit Dither <= 0 h/w recommend */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x09 , ~0xc0 , temp | 0x80 ) ;  /* SR09[7] enable FP output, SR09[6] 1: sigle 18bits, 0: 24bits */
+
+}
+
+void XGI_SetXG21LVDSPara(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR temp,Miscdata;
+    USHORT xres ,
+           yres ,
+           modeflag ,
+           resindex ,
+           lvdstableindex ;
+    USHORT LVDSHT,LVDSHBS,LVDSHRS,LVDSHRE,LVDSHBE;
+    USHORT LVDSVT,LVDSVBS,LVDSVRS,LVDSVRE,LVDSVBE;
+    USHORT value;
+
+    lvdstableindex = XGI_GetLVDSOEMTableIndex( pVBInfo );
+
+    temp = (UCHAR) ( ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDS_Capability & (LCDPolarity << 8 ) ) >> 8 );
+    temp &= LCDPolarity;
+    Miscdata =(UCHAR) XGINew_GetReg2(pVBInfo->P3cc) ;
+
+    XGINew_SetReg3( pVBInfo->P3c2 , (Miscdata & 0x3F) | temp ) ;
+
+    temp = (UCHAR) ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDS_Capability & LCDPolarity ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x80 , temp&0x80 ) ;      /* SR35[7] FP VSync polarity */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , ~0x20 , (temp&0x40)>>1 ) ;   /* SR30[5] FP HSync polarity */
+
+    XGI_SetXG21FPBits(pVBInfo);
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( ModeNo <= 0x13 )
+    {
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->StResInfo[ resindex ].VTotal ;
+        modeflag = pVBInfo->SModeIDTable[ModeIdIndex].St_ModeFlag;    /* si+St_ResInfo */
+    }
+    else
+    {
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;			  /* xres->ax */
+        yres = pVBInfo->ModeResInfo[ resindex ].VTotal ;			  /* yres->bx */
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex].Ext_ModeFlag ; /* si+St_ModeFlag */
+    }
+
+    if (!( modeflag & Charx8Dot ))
+      xres = xres * 8 / 9;
+
+    LVDSHT = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHT;
+
+    LVDSHBS = xres + ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE - xres ) / 2 ;
+    if ( ( ModeNo<=0x13 ) && ( modeflag & HalfDCLK ) )
+    {
+      LVDSHBS -=  xres/4 ;
+    }
+    if (LVDSHBS > LVDSHT) LVDSHBS -= LVDSHT ;
+
+    LVDSHRS = LVDSHBS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHFP ;
+    if (LVDSHRS > LVDSHT) LVDSHRS -= LVDSHT ;
+
+    LVDSHRE = LVDSHRS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHSYNC ;
+    if (LVDSHRE > LVDSHT) LVDSHRE -= LVDSHT ;
+
+    LVDSHBE = LVDSHBS + LVDSHT - pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE ;
+
+    LVDSVT = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVT;
+
+    LVDSVBS = yres + ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE - yres ) / 2 ;
+    if ( ( ModeNo>0x13 ) && ( modeflag & DoubleScanMode ) )
+    {
+      LVDSVBS +=  yres/2 ;
+    }
+    if (LVDSVBS > LVDSVT) LVDSVBS -= LVDSVT ;
+
+    LVDSVRS = LVDSVBS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVFP ;
+    if (LVDSVRS > LVDSVT) LVDSVRS -= LVDSVT ;
+
+    LVDSVRE = LVDSVRS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVSYNC ;
+    if (LVDSVRE > LVDSVT) LVDSVRE -= LVDSVT ;
+
+    LVDSVBE = LVDSVBS + LVDSVT - pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE ;
+
+    temp = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , temp & 0x7f ) ;		/* Unlock CRTC */
+
+    if (!( modeflag & Charx8Dot ))
+    {
+        XGINew_SetRegOR( pVBInfo->P3c4 , 0x1 , 0x1 ) ;
+    }
+
+    /* HT SR0B[1:0] CR00 */
+    value = ( LVDSHT >> 3 ) - 5;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0x03 , ( value & 0x300 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x0 , (value & 0xFF) ) ;
+
+    /* HBS SR0B[5:4] CR02 */
+    value = ( LVDSHBS >> 3 ) - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0x30 , ( value & 0x300 ) >> 4 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2 , (value & 0xFF) ) ;
+
+    /* HBE SR0C[1:0] CR05[7] CR03[4:0] */
+    value = ( LVDSHBE >> 3 ) - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0C , ~0x03 , ( value & 0xC0 ) >> 6 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x05 , ~0x80 , ( value & 0x20 ) << 2 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x03 , ~0x1F , value & 0x1F ) ;
+
+    /* HRS SR0B[7:6] CR04 */
+    value = ( LVDSHRS >> 3 ) + 2;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0xC0 , ( value & 0x300 ) >> 2 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x4 , (value & 0xFF) ) ;
+
+    /* Panel HRS SR2F[1:0] SR2E[7:0]  */
+    value--;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x2F , ~0x03 , ( value & 0x300 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , (value & 0xFF) ) ;
+
+    /* HRE SR0C[2] CR05[4:0] */
+    value = ( LVDSHRE >> 3 ) + 2;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0C , ~0x04 , ( value & 0x20 ) >> 3 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x05 , ~0x1F , value & 0x1F ) ;
+
+    /* Panel HRE SR2F[7:2]  */
+    value--;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x2F , ~0xFC , value << 2 ) ;
+
+    /* VT SR0A[0] CR07[5][0] CR06 */
+    value = LVDSVT - 2 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x01 , ( value & 0x400 ) >> 10 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x20 , ( value & 0x200 ) >> 4 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x01 , ( value & 0x100 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x06 , (value & 0xFF) ) ;
+
+    /* VBS SR0A[2] CR09[5] CR07[3] CR15 */
+    value = LVDSVBS - 1 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x04 , ( value & 0x400 ) >> 8 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x09 , ~0x20 , ( value & 0x200 ) >> 4 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x08 , ( value & 0x100 ) >> 5 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x15 , (value & 0xFF) ) ;
+
+    /* VBE SR0A[4] CR16 */
+    value = LVDSVBE - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x10 , ( value & 0x100 ) >> 4 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x16 , (value & 0xFF) ) ;
+
+    /* VRS SR0A[3] CR7[7][2] CR10 */
+    value = LVDSVRS - 1 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x08 , ( value & 0x400 ) >> 7 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x80 , ( value & 0x200 ) >> 2 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x04 , ( value & 0x100 ) >> 6 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x10 , (value & 0xFF) ) ;
+
+    /* Panel VRS SR3F[1:0] SR34[7:0] SR33[0] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x3F , ~0x03 , ( value & 0x600 ) >> 9 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , (value >> 1) & 0xFF ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x33 , ~0x01 , value & 0x01 ) ;
+
+    /* VRE SR0A[5] CR11[3:0] */
+    value = LVDSVRE - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x20 , ( value & 0x10 ) << 1 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x11 , ~0x0F , value & 0x0F ) ;
+
+    /* Panel VRE SR3F[7:2] */ /* SR3F[7] has to be 0, h/w bug */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x3F , ~0xFC , ( value << 2 ) & 0x7C ) ;
+
+    for ( temp=0, value = 0; temp < 3; temp++)
+    {
+
+        XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x31 , ~0x30 , value ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData1) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData2) ;
+        value += 0x10;
+    }
+
+    if (!( modeflag & Charx8Dot ))
+    {
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* reset 3da */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x13 ) ;    /* set index */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x00 ) ;    /* set data, panning = 0, shift left 1 dot*/
+
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* Enable Attribute */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x20 ) ;
+
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* reset 3da */
+    }
+
+
+}
+
+/* no shadow case */
+void XGI_SetXG27LVDSPara(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR temp,Miscdata;
+    USHORT xres ,
+           yres ,
+           modeflag ,
+           resindex ,
+           lvdstableindex ;
+    USHORT LVDSHT,LVDSHBS,LVDSHRS,LVDSHRE,LVDSHBE;
+    USHORT LVDSVT,LVDSVBS,LVDSVRS,LVDSVRE,LVDSVBE;
+    USHORT value;
+
+    lvdstableindex = XGI_GetLVDSOEMTableIndex( pVBInfo );
+    temp = (UCHAR) ( ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDS_Capability & (LCDPolarity << 8 ) ) >> 8 );
+    temp &= LCDPolarity;
+    Miscdata =(UCHAR) XGINew_GetReg2(pVBInfo->P3cc) ;
+
+    XGINew_SetReg3( pVBInfo->P3c2 , (Miscdata & 0x3F) | temp ) ;
+
+    temp = (UCHAR) ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDS_Capability & LCDPolarity ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x80 , temp&0x80 ) ;      /* SR35[7] FP VSync polarity */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x30 , ~0x20 , (temp&0x40)>>1 ) ;   /* SR30[5] FP HSync polarity */
+
+    XGI_SetXG27FPBits(pVBInfo);
+    resindex = XGI_GetResInfo( ModeNo , ModeIdIndex, pVBInfo ) ;
+    if ( ModeNo <= 0x13 )
+    {
+        xres = pVBInfo->StResInfo[ resindex ].HTotal ;
+        yres = pVBInfo->StResInfo[ resindex ].VTotal ;
+        modeflag = pVBInfo->SModeIDTable[ModeIdIndex].St_ModeFlag;    /* si+St_ResInfo */
+    }
+    else
+    {
+        xres = pVBInfo->ModeResInfo[ resindex ].HTotal ;			  /* xres->ax */
+        yres = pVBInfo->ModeResInfo[ resindex ].VTotal ;			  /* yres->bx */
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex].Ext_ModeFlag ; /* si+St_ModeFlag */
+    }
+
+    if (!( modeflag & Charx8Dot ))
+      xres = xres * 8 / 9;
+
+    LVDSHT = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHT;
+
+    LVDSHBS = xres + ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE - xres ) / 2 ;
+    if ( ( ModeNo<=0x13 ) && ( modeflag & HalfDCLK ) )
+    {
+      LVDSHBS -=  xres/4 ;
+    }
+    if (LVDSHBS > LVDSHT) LVDSHBS -= LVDSHT ;
+
+    LVDSHRS = LVDSHBS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHFP ;
+    if (LVDSHRS > LVDSHT) LVDSHRS -= LVDSHT ;
+
+    LVDSHRE = LVDSHRS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHSYNC ;
+    if (LVDSHRE > LVDSHT) LVDSHRE -= LVDSHT ;
+
+    LVDSHBE = LVDSHBS + LVDSHT - pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSHDE ;
+
+    LVDSVT = pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVT;
+
+    LVDSVBS = yres + ( pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE - yres ) / 2 ;
+    if ( ( ModeNo>0x13 ) && ( modeflag & DoubleScanMode ) )
+    {
+      LVDSVBS +=  yres/2 ;
+    }
+    if (LVDSVBS > LVDSVT) LVDSVBS -= LVDSVT ;
+
+    LVDSVRS = LVDSVBS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVFP ;
+    if (LVDSVRS > LVDSVT) LVDSVRS -= LVDSVT ;
+
+    LVDSVRE = LVDSVRS + pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVSYNC ;
+    if (LVDSVRE > LVDSVT) LVDSVRE -= LVDSVT ;
+
+    LVDSVBE = LVDSVBS + LVDSVT - pVBInfo->XG21_LVDSCapList[lvdstableindex].LVDSVDE ;
+
+    temp = ( UCHAR )XGINew_GetReg1( pVBInfo->P3d4 , 0x11 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x11 , temp & 0x7f ) ;		/* Unlock CRTC */
+
+    if (!( modeflag & Charx8Dot ))
+    {
+        XGINew_SetRegOR( pVBInfo->P3c4 , 0x1 , 0x1 ) ;
+    }
+
+    /* HT SR0B[1:0] CR00 */
+    value = ( LVDSHT >> 3 ) - 5;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0x03 , ( value & 0x300 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x0 , (value & 0xFF) ) ;
+
+    /* HBS SR0B[5:4] CR02 */
+    value = ( LVDSHBS >> 3 ) - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0x30 , ( value & 0x300 ) >> 4 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x2 , (value & 0xFF) ) ;
+
+    /* HBE SR0C[1:0] CR05[7] CR03[4:0] */
+    value = ( LVDSHBE >> 3 ) - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0C , ~0x03 , ( value & 0xC0 ) >> 6 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x05 , ~0x80 , ( value & 0x20 ) << 2 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x03 , ~0x1F , value & 0x1F ) ;
+
+    /* HRS SR0B[7:6] CR04 */
+    value = ( LVDSHRS >> 3 ) + 2;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0B , ~0xC0 , ( value & 0x300 ) >> 2 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x4 , (value & 0xFF) ) ;
+
+    /* Panel HRS SR2F[1:0] SR2E[7:0]  */
+    value--;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x2F , ~0x03 , ( value & 0x300 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x2E , (value & 0xFF) ) ;
+
+    /* HRE SR0C[2] CR05[4:0] */
+    value = ( LVDSHRE >> 3 ) + 2;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0C , ~0x04 , ( value & 0x20 ) >> 3 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x05 , ~0x1F , value & 0x1F ) ;
+
+    /* Panel HRE SR2F[7:2]  */
+    value--;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x2F , ~0xFC , value << 2 ) ;
+
+    /* VT SR0A[0] CR07[5][0] CR06 */
+    value = LVDSVT - 2 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x01 , ( value & 0x400 ) >> 10 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x20 , ( value & 0x200 ) >> 4 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x01 , ( value & 0x100 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x06 , (value & 0xFF) ) ;
+
+    /* VBS SR0A[2] CR09[5] CR07[3] CR15 */
+    value = LVDSVBS - 1 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x04 , ( value & 0x400 ) >> 8 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x09 , ~0x20 , ( value & 0x200 ) >> 4 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x08 , ( value & 0x100 ) >> 5 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x15 , (value & 0xFF) ) ;
+
+    /* VBE SR0A[4] CR16 */
+    value = LVDSVBE - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x10 , ( value & 0x100 ) >> 4 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x16 , (value & 0xFF) ) ;
+
+    /* VRS SR0A[3] CR7[7][2] CR10 */
+    value = LVDSVRS - 1 ;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x08 , ( value & 0x400 ) >> 7 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x80 , ( value & 0x200 ) >> 2 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x07 , ~0x04 , ( value & 0x100 ) >> 6 ) ;
+    XGINew_SetReg1( pVBInfo->P3d4 , 0x10 , (value & 0xFF) ) ;
+
+    /* Panel VRS SR35[2:0] SR34[7:0] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x35 , ~0x07 , ( value & 0x700 ) >> 8 ) ;
+    XGINew_SetReg1( pVBInfo->P3c4 , 0x34 , value & 0xFF ) ;
+
+    /* VRE SR0A[5] CR11[3:0] */
+    value = LVDSVRE - 1;
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x0A , ~0x20 , ( value & 0x10 ) << 1 ) ;
+    XGINew_SetRegANDOR( pVBInfo->P3d4 , 0x11 , ~0x0F , value & 0x0F ) ;
+
+    /* Panel VRE SR3F[7:2] */
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x3F , ~0xFC , ( value << 2 ) & 0xFC ) ;
+
+    for ( temp=0, value = 0; temp < 3; temp++)
+    {
+
+        XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x31 , ~0x30 , value ) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2B , pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData1) ;
+        XGINew_SetReg1( pVBInfo->P3c4 , 0x2C , pVBInfo->XG21_LVDSCapList[lvdstableindex].VCLKData2) ;
+        value += 0x10;
+    }
+
+    if (!( modeflag & Charx8Dot ))
+    {
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* reset 3da */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x13 ) ;    /* set index */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x00 ) ;    /* set data, panning = 0, shift left 1 dot*/
+
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* Enable Attribute */
+        XGINew_SetReg3( pVBInfo->P3c0 , 0x20 ) ;
+
+        XGINew_GetReg2( pVBInfo->P3da ) ;           /* reset 3da */
+    }
+
+
+}
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_IsLCDON */
+/* Input : */
+/* Output : FALSE : Skip PSC Control */
+/* TRUE: Disable PSC */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_IsLCDON(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax ;
+
+    tempax = pVBInfo->VBInfo ;
+    if ( tempax & SetCRT2ToDualEdge )
+        return FALSE ;
+    else if ( tempax & ( DisableCRT2Display | SwitchToCRT2 | SetSimuScanMode ) )
+        return TRUE ;
+
+    return FALSE ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_EnablePWD */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_EnablePWD(  PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT index ,
+           temp ;
+
+    index = XGI_GetLCDCapPtr(pVBInfo) ;
+    temp = pVBInfo->LCDCapList[ index ].PWD_2B ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x2B , temp ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x2C , pVBInfo->LCDCapList[ index ].PWD_2C ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x2D , pVBInfo->LCDCapList[ index ].PWD_2D ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x2E , pVBInfo->LCDCapList[ index ].PWD_2E ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x2F , pVBInfo->LCDCapList[ index ].PWD_2F ) ;
+    XGINew_SetRegOR( pVBInfo->Part4Port , 0x27 , 0x80 ) ; 	/* enable PWD */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisablePWD */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_DisablePWD( PVB_DEVICE_INFO pVBInfo )
+{
+    XGINew_SetRegAND( pVBInfo->Part4Port , 0x27 , 0x7F ) ;	/* disable PWD */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisableChISLCD */
+/* Input : */
+/* Output : FALSE -> Not LCD Mode */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_DisableChISLCD(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx ,
+           tempah ;
+
+    tempbx = pVBInfo->SetFlag & ( DisableChA | DisableChB ) ;
+    tempah = ~( ( USHORT )XGINew_GetReg1( pVBInfo->Part1Port  , 0x2E ) ) ;
+
+    if ( tempbx & ( EnableChA | DisableChA ) )
+    {
+        if ( !( tempah & 0x08 ) )		/* Chk LCDA Mode */
+            return FALSE ;
+    }
+
+    if ( !( tempbx & ( EnableChB | DisableChB ) ) )
+        return FALSE ;
+
+    if ( tempah & 0x01 )       /* Chk LCDB Mode */
+        return TRUE ;
+
+    return FALSE ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_EnableChISLCD */
+/* Input : */
+/* Output : 0 -> Not LCD mode */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_EnableChISLCD(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx ,
+           tempah ;
+
+
+    tempbx = pVBInfo->SetFlag & ( EnableChA | EnableChB ) ;
+    tempah = ~( ( USHORT )XGINew_GetReg1( pVBInfo->Part1Port , 0x2E ) ) ;
+
+    if ( tempbx & ( EnableChA | DisableChA ) )
+    {
+        if ( !( tempah & 0x08 ) )		/* Chk LCDA Mode */
+            return FALSE ;
+    }
+
+    if ( !( tempbx & ( EnableChB | DisableChB ) ) )
+        return FALSE ;
+
+    if ( tempah & 0x01 )       /* Chk LCDB Mode */
+        return TRUE ;
+
+    return FALSE ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLCDCapPtr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetLCDCapPtr(  PVB_DEVICE_INFO pVBInfo )
+{
+    UCHAR tempal ,
+          tempah ,
+          tempbl ,
+          i ;
+
+    tempah = XGINew_GetReg1( pVBInfo->P3d4 , 0x36 ) ;
+    tempal = tempah & 0x0F ;
+    tempah = tempah & 0xF0 ;
+    i = 0 ;
+    tempbl =  pVBInfo->LCDCapList[ i ].LCD_ID ;
+
+    while( tempbl != 0xFF )
+    {
+        if ( tempbl & 0x80 )   /* OEMUtil */
+        {
+            tempal = tempah ;
+            tempbl = tempbl & ~( 0x80 ) ;
+        }
+
+        if ( tempal == tempbl )
+            break ;
+
+        i++ ;
+
+        tempbl = pVBInfo->LCDCapList[ i ].LCD_ID ;
+    }
+
+    return i ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLCDCapPtr1 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetLCDCapPtr1( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempah ,
+           tempal ,
+           tempbl ,
+           i ;
+
+    tempal = pVBInfo->LCDResInfo ;
+    tempah = pVBInfo->LCDTypeInfo ;
+
+    i = 0 ;
+    tempbl =  pVBInfo->LCDCapList[ i ].LCD_ID;
+
+    while( tempbl != 0xFF )
+    {
+        if ( ( tempbl & 0x80 ) && ( tempbl != 0x80 ) )
+        {
+            tempal = tempah ;
+            tempbl &= ~0x80 ;
+        }
+
+        if ( tempal == tempbl )
+            break ;
+
+        i++ ;
+        tempbl = pVBInfo->LCDCapList[ i ].LCD_ID ;
+    }
+
+    if ( tempbl == 0xFF )
+    {
+        pVBInfo->LCDResInfo = Panel1024x768 ;
+        pVBInfo->LCDTypeInfo = 0 ;
+        i = 0 ;
+    }
+
+    return i ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetLCDSync */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetLCDSync( USHORT* HSyncWidth , USHORT* VSyncWidth, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT Index ;
+
+    Index = XGI_GetLCDCapPtr(pVBInfo) ;
+    *HSyncWidth = pVBInfo->LCDCapList[ Index ].LCD_HSyncWidth ;
+    *VSyncWidth = pVBInfo->LCDCapList[ Index ].LCD_VSyncWidth ;
+
+    return ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_EnableBridge */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_EnableBridge( PXGI_HW_DEVICE_INFO HwDeviceExtension , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbl ,
+           tempah ;
+
+    if ( pVBInfo->SetFlag == Win9xDOSMode )
+    {
+        if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            XGI_DisplayOn( HwDeviceExtension, pVBInfo) ;
+            return ;
+        }
+        else  /* LVDS or CH7017 */
+            return ;
+    }
+
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+    {
+        if ( !XGI_DisableChISLCD(pVBInfo) )
+        {
+            if ( ( XGI_EnableChISLCD(pVBInfo) ) || ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) )
+            {
+                if ( pVBInfo->LCDInfo & SetPWDEnable )
+                {
+                    XGI_EnablePWD( pVBInfo);
+                }
+                else
+                {
+                    pVBInfo->LCDInfo &= ( ~SetPWDEnable ) ;
+                    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                    {
+                        tempbl = 0xFD ;
+                        tempah = 0x02 ;
+                    }
+                    else
+                    {
+                        tempbl = 0xFB ;
+                        tempah = 0x00 ;
+                    }
+
+                    XGI_SetPanelPower( tempah , tempbl, pVBInfo ) ;
+                    XGI_SetPanelDelay( 1,pVBInfo ) ;
+                }
+            }
+        }
+    }	/* Not 340 */
+
+
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( !( pVBInfo->SetFlag & DisableChA ) )
+        {
+            if ( pVBInfo->SetFlag & EnableChA )
+            {
+                XGINew_SetReg1( pVBInfo->Part1Port , 0x1E , 0x20 ) ;  /* Power on */
+            }
+            else
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToDualEdge ) /* SetCRT2ToLCDA ) */
+                {
+                    XGINew_SetReg1(pVBInfo->Part1Port,0x1E,0x20);  /* Power on */
+                }
+            }
+        }
+
+        if ( !( pVBInfo->SetFlag & DisableChB ) )
+        {
+            if ( ( pVBInfo->SetFlag & EnableChB ) || ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToTV | SetCRT2ToRAMDAC ) ) )
+            {
+                tempah = ( UCHAR )XGINew_GetReg1( pVBInfo->P3c4 , 0x32 ) ;
+                tempah &= 0xDF;
+                if ( pVBInfo->VBInfo & SetInSlaveMode )
+                {
+                    if ( !( pVBInfo->VBInfo & SetCRT2ToRAMDAC ) )
+                        tempah |= 0x20 ;
+                }
+                XGINew_SetReg1( pVBInfo->P3c4 , 0x32 , tempah ) ;
+                XGINew_SetRegOR( pVBInfo->P3c4 , 0x1E , 0x20 ) ;
+
+
+                tempah = ( UCHAR )XGINew_GetReg1( pVBInfo->Part1Port , 0x2E ) ;
+
+                if ( !( tempah & 0x80 ) )
+                    XGINew_SetRegOR( pVBInfo->Part1Port , 0x2E , 0x80 ) ;   	/* BVBDOENABLE = 1 */
+
+                XGINew_SetRegAND( pVBInfo->Part1Port , 0x00 , 0x7F ) ;     	/* BScreenOFF = 0 */
+            }
+        }
+
+        if ( ( pVBInfo->SetFlag & ( EnableChA | EnableChB ) ) || ( !( pVBInfo->VBInfo & DisableCRT2Display ) ) )
+        {
+            XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x00 , ~0xE0 , 0x20 ) ;   /* shampoo 0129 */
+            if ( pVBInfo->VBType & ( VB_XGI302LV | VB_XGI301C ) )
+            {
+                if ( !XGI_DisableChISLCD(pVBInfo) )
+                {
+                    if ( XGI_EnableChISLCD( pVBInfo) || ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) )
+                        XGINew_SetRegAND( pVBInfo->Part4Port ,0x2A , 0x7F ) ;  	/* LVDS PLL power on */
+                }
+                XGINew_SetRegAND( pVBInfo->Part4Port , 0x30 , 0x7F ) ;		/* LVDS Driver power on */
+            }
+        }
+
+        tempah = 0x00 ;
+
+        if ( !( pVBInfo->VBInfo & DisableCRT2Display ) )
+        {
+            tempah = 0xc0 ;
+
+            if ( !( pVBInfo->VBInfo & SetSimuScanMode ) )
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                {
+                    if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+                    {
+                        tempah = tempah & 0x40;
+                        if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                            tempah = tempah ^ 0xC0 ;
+
+                        if ( pVBInfo->SetFlag & DisableChB )
+                            tempah &= 0xBF ;
+
+                        if ( pVBInfo->SetFlag & DisableChA )
+                            tempah &= 0x7F ;
+
+                        if ( pVBInfo->SetFlag & EnableChB )
+                            tempah |= 0x40 ;
+
+                        if ( pVBInfo->SetFlag & EnableChA )
+                            tempah |= 0x80 ;
+                    }
+                }
+            }
+        }
+
+        XGINew_SetRegOR( pVBInfo->Part4Port , 0x1F , tempah ) ;          /* EnablePart4_1F */
+
+        if ( pVBInfo->SetFlag & Win9xDOSMode )
+        {
+            XGI_DisplayOn( HwDeviceExtension, pVBInfo) ;
+            return ;
+        }
+
+        if ( !( pVBInfo->SetFlag & DisableChA ) )
+        {
+            XGI_VBLongWait( pVBInfo) ;
+            if ( !( pVBInfo->SetFlag & GatingCRT ) )
+            {
+                XGI_DisableGatingCRT( HwDeviceExtension, pVBInfo ) ;
+                XGI_DisplayOn( HwDeviceExtension, pVBInfo) ;
+                XGI_VBLongWait( pVBInfo) ;
+            }
+        }
+    }	/* 301 */
+    else 	/* LVDS */
+    {
+        if ( pVBInfo->VBInfo & ( SetCRT2ToTV | SetCRT2ToLCD | SetCRT2ToLCDA ) )
+            XGINew_SetRegOR( pVBInfo->Part1Port , 0x1E , 0x20 ) ;      	/* enable CRT2 */
+
+
+
+        tempah = ( UCHAR )XGINew_GetReg1( pVBInfo->Part1Port , 0x2E ) ;
+        if ( !( tempah & 0x80 ) )
+            XGINew_SetRegOR( pVBInfo->Part1Port , 0x2E , 0x80 ) ;	/* BVBDOENABLE = 1 */
+
+        XGINew_SetRegAND(pVBInfo->Part1Port,0x00,0x7F);
+        XGI_DisplayOn( HwDeviceExtension, pVBInfo);
+    } /* End of VB */
+
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+    {
+        if ( !XGI_EnableChISLCD(pVBInfo) )
+        {
+            if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+            {
+                if ( XGI_BacklightByDrv(pVBInfo) )
+                    return ;
+            }
+            else
+                return ;
+        }
+
+        if ( pVBInfo->LCDInfo & SetPWDEnable )
+        {
+            XGI_FirePWDEnable(pVBInfo) ;
+            return ;
+        }
+
+        XGI_SetPanelDelay( 2,pVBInfo ) ;
+
+        if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {
+            tempah = 0x01 ;
+            tempbl = 0xFE ;		/* turn on backlght */
+        }
+        else
+        {
+            tempbl = 0xF7 ;
+            tempah = 0x00 ;
+        }
+        XGI_SetPanelPower( tempah , tempbl , pVBInfo) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_DisableBridge */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_DisableBridge(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempax ,
+           tempbx ,
+           tempah = 0 ,
+           tempbl = 0 ;
+
+    if ( pVBInfo->SetFlag == Win9xDOSMode )
+        return ;
+
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+    {
+        if ( ( !( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) ) || ( XGI_DisableChISLCD(pVBInfo) ) )
+        {
+            if ( !XGI_IsLCDON(pVBInfo) )
+            {
+                if ( pVBInfo->LCDInfo & SetPWDEnable )
+                    XGI_EnablePWD( pVBInfo) ;
+                else
+                {
+                    pVBInfo->LCDInfo &= ~SetPWDEnable ;
+                    XGI_DisablePWD(pVBInfo) ;
+                    if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                    {
+                        tempbx = 0xFE ;  /* not 01h */
+                        tempax = 0 ;
+                    }
+                    else
+                    {
+                        tempbx = 0xF7 ;  /* not 08h */
+                        tempax = 0x08 ;
+                    }
+                    XGI_SetPanelPower( tempax , tempbx , pVBInfo) ;
+                    XGI_SetPanelDelay( 3,pVBInfo ) ;
+                }
+            }	/* end if(!XGI_IsLCDON(pVBInfo)) */
+        }
+    }
+
+/*  if ( CH7017 )
+    {
+        if ( !( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2toLCDA ) ) || ( XGI_DisableChISLCD(pVBInfo) ) )
+        {
+            if ( !XGI_IsLCDON(pVBInfo) )
+            {
+                if ( DISCHARGE )
+                {
+                    tempbx = XGINew_GetCH7005( 0x61 ) ;
+                    if ( tempbx < 0x01 )   //first time we power up
+                        XGINew_SetCH7005( 0x0066 ) ;	//and disable power sequence
+                    else
+                        XGINew_SetCH7005( 0x5f66 ) ; //leave VDD on - disable power
+                }
+            }
+        }
+    }        */
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B| VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        tempah = 0x3F ;
+        if ( !( pVBInfo->VBInfo & ( DisableCRT2Display | SetSimuScanMode ) ) )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+                {
+                    tempah = 0x7F;			/* Disable Channel A */
+                    if ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) )
+                        tempah = 0xBF ;		/* Disable Channel B */
+
+                    if ( pVBInfo->SetFlag & DisableChB )
+                        tempah &= 0xBF ;		/* force to disable Cahnnel */
+
+                    if ( pVBInfo->SetFlag & DisableChA )
+                        tempah &= 0x7F ;		/* Force to disable Channel B */
+                }
+            }
+        }
+
+        XGINew_SetRegAND( pVBInfo->Part4Port , 0x1F , tempah ) ;   /* disable part4_1f */
+
+        if ( pVBInfo->VBType & ( VB_XGI302LV | VB_XGI301C ) )
+        {
+            if ( ( ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) ) || ( XGI_DisableChISLCD(pVBInfo) ) || ( XGI_IsLCDON(pVBInfo) ) )
+                XGINew_SetRegOR( pVBInfo->Part4Port , 0x30 , 0x80 ) ;  /* LVDS Driver power down */
+        }
+
+        if ( ( pVBInfo->SetFlag & DisableChA ) || ( pVBInfo->VBInfo & ( DisableCRT2Display | SetCRT2ToLCDA | SetSimuScanMode ) ) )
+        {
+            if ( pVBInfo->SetFlag & GatingCRT )
+                XGI_EnableGatingCRT( HwDeviceExtension, pVBInfo ) ;
+            XGI_DisplayOff( HwDeviceExtension, pVBInfo) ;
+        }
+
+        if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+        {
+            if ( ( pVBInfo->SetFlag & DisableChA ) || ( pVBInfo->VBInfo & SetCRT2ToLCDA ) )
+                XGINew_SetRegAND( pVBInfo->Part1Port , 0x1e , 0xdf ) ; 	/* Power down */
+        }
+
+        XGINew_SetRegAND( pVBInfo->P3c4 , 0x32 , 0xdf ) ; 		/* disable TV as primary VGA swap */
+
+        if ( ( pVBInfo->VBInfo & ( SetSimuScanMode | SetCRT2ToDualEdge  ) ) )
+            XGINew_SetRegAND(pVBInfo->Part2Port,0x00,0xdf);
+
+        if ( ( pVBInfo->SetFlag & DisableChB ) || ( pVBInfo->VBInfo & ( DisableCRT2Display | SetSimuScanMode ) )
+        || ( ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) ) && ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToLCD | SetCRT2ToTV ) ) ) )
+            XGINew_SetRegOR( pVBInfo->Part1Port , 0x00 , 0x80 ) ; 	/* BScreenOff=1 */
+
+        if ( ( pVBInfo->SetFlag & DisableChB ) || ( pVBInfo->VBInfo & ( DisableCRT2Display | SetSimuScanMode ) )
+        || ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) ) || ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToLCD | SetCRT2ToTV ) ) )
+        {
+            tempah= XGINew_GetReg1( pVBInfo->Part1Port , 0x00 ) ;   	/* save Part1 index 0 */
+            XGINew_SetRegOR( pVBInfo->Part1Port , 0x00 , 0x10 ) ; 	/* BTDAC = 1, avoid VB reset */
+            XGINew_SetRegAND( pVBInfo->Part1Port , 0x1E , 0xDF ) ;	/* disable CRT2 */
+            XGINew_SetReg1( pVBInfo->Part1Port , 0x00 , tempah ) ;	/* restore Part1 index 0 */
+        }
+    }
+    else /* {301} */
+    {
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToTV ) )
+        {
+            XGINew_SetRegOR( pVBInfo->Part1Port , 0x00 , 0x80 ) ; 	/* BScreenOff=1 */
+            XGINew_SetRegAND( pVBInfo->Part1Port , 0x1E , 0xDF ) ;	/* Disable CRT2 */
+            XGINew_SetRegAND( pVBInfo->P3c4 , 0x32 , 0xDF ) ;	/* Disable TV asPrimary VGA swap */
+        }
+
+        if ( pVBInfo->VBInfo & ( DisableCRT2Display | SetCRT2ToLCDA | SetSimuScanMode ) )
+            XGI_DisplayOff( HwDeviceExtension, pVBInfo) ;
+    }
+
+
+
+
+    if ( HwDeviceExtension->jChipType < XG40 )
+    {
+        if ( !( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) ) || ( XGI_DisableChISLCD(pVBInfo) ) || ( XGI_IsLCDON(pVBInfo) ) )
+        {
+            if ( pVBInfo->LCDInfo & SetPWDEnable )
+            {
+                if ( pVBInfo->LCDInfo & SetPWDEnable )
+                    XGI_BacklightByDrv(pVBInfo) ;
+                else
+                {
+                    XGI_SetPanelDelay( 4 ,pVBInfo) ;
+                    if ( pVBInfo->VBType & VB_XGI301LV )
+                    {
+                        tempbl = 0xFD ;
+                        tempah = 0x00 ;
+                    }
+                    else
+                    {
+                        tempbl = 0xFB ;
+                        tempah = 0x04 ;
+                    }
+                }
+            }
+            XGI_SetPanelPower( tempah , tempbl , pVBInfo) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetTVPtrIndex */
+/* Input : */
+/* Output : */
+/* Description : bx 0 : ExtNTSC */
+/* 1 : StNTSC */
+/* 2 : ExtPAL */
+/* 3 : StPAL */
+/* 4 : ExtHiTV */
+/* 5 : StHiTV */
+/* 6 : Ext525i */
+/* 7 : St525i */
+/* 8 : Ext525p */
+/* 9 : St525p */
+/* A : Ext750p */
+/* B : St750p */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetTVPtrIndex(  PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx = 0 ;
+
+    if ( pVBInfo->TVInfo & SetPALTV )
+        tempbx = 2 ;
+    if ( pVBInfo->TVInfo & SetYPbPrMode1080i )
+        tempbx = 4 ;
+    if ( pVBInfo->TVInfo & SetYPbPrMode525i )
+        tempbx = 6 ;
+    if ( pVBInfo->TVInfo & SetYPbPrMode525p )
+        tempbx = 8 ;
+    if ( pVBInfo->TVInfo & SetYPbPrMode750p )
+        tempbx = 10 ;
+    if ( pVBInfo->TVInfo & TVSimuMode )
+        tempbx++ ;
+
+    return tempbx ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_OEM310Setting */
+/* Input : */
+/* Output : */
+/* Description : Customized Param. for 301 */
+/* --------------------------------------------------------------------- */
+void XGI_OEM310Setting( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    if ( pVBInfo->SetFlag & Win9xDOSMode )
+        return ;
+
+    /* GetPart1IO(); */
+    XGI_SetDelayComp(pVBInfo) ;
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+        XGI_SetLCDCap(pVBInfo) ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+    {
+        /* GetPart2IO() */
+        XGI_SetPhaseIncr(pVBInfo) ;
+        XGI_SetYFilter( ModeNo , ModeIdIndex,pVBInfo ) ;
+        XGI_SetAntiFlicker( ModeNo , ModeIdIndex,pVBInfo ) ;
+
+        if ( pVBInfo->VBType&VB_XGI301)
+            XGI_SetEdgeEnhance( ModeNo , ModeIdIndex ,pVBInfo) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetDelayComp */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetDelayComp( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT index ;
+
+    UCHAR  tempah ,
+           tempbl ,
+           tempbh ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA | SetCRT2ToTV | SetCRT2ToRAMDAC ) )
+        {
+            tempbl = 0;
+            tempbh = 0;
+
+            index = XGI_GetTVPtrIndex(pVBInfo ) ;           /* Get TV Delay */
+            tempbl = pVBInfo->XGI_TVDelayList[ index ] ;
+
+            if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                tempbl = pVBInfo->XGI_TVDelayList2[ index ] ;
+
+            if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+                tempbl = tempbl >> 4 ;
+/*
+            if ( pVBInfo->VBInfo & SetCRT2ToRAMDAC )
+                tempbl = CRT2Delay1 ;			// Get CRT2 Delay
+
+            if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+                tempbl = CRT2Delay2 ;
+*/
+            if ( pVBInfo->VBInfo & ( SetCRT2ToLCD | SetCRT2ToLCDA ) )
+            {
+                index = XGI_GetLCDCapPtr(pVBInfo) ; 		/* Get LCD Delay */
+                tempbh=pVBInfo->LCDCapList[ index ].LCD_DelayCompensation ;
+
+                if ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) )
+                     tempbl = tempbh ;
+            }
+
+            tempbl  &= 0x0F ;
+            tempbh  &= 0xF0 ;
+            tempah = XGINew_GetReg1( pVBInfo->Part1Port , 0x2D ) ;
+
+            if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToLCD | SetCRT2ToTV ) )  /* Channel B */
+            {
+                tempah &= 0xF0 ;
+                tempah |= tempbl ;
+            }
+
+            if ( pVBInfo->VBInfo & SetCRT2ToLCDA )		/* Channel A */
+            {
+                tempah &= 0x0F ;
+                tempah |= tempbh ;
+            }
+            XGINew_SetReg1(pVBInfo->Part1Port,0x2D,tempah);
+        }
+    }
+    else if ( pVBInfo->IF_DEF_LVDS == 1 )
+    {
+        tempbl = 0;
+        tempbh = 0;
+        if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+        {
+            tempah = pVBInfo->LCDCapList[ XGI_GetLCDCapPtr(pVBInfo) ].LCD_DelayCompensation ;		/* / Get LCD Delay */
+            tempah &= 0x0f ;
+            tempah = tempah << 4 ;
+            XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2D , 0x0f , tempah ) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLCDCap */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetLCDCap( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempcx ;
+
+    tempcx = pVBInfo->LCDCapList[ XGI_GetLCDCapPtr(pVBInfo) ].LCD_Capability ;
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->VBType & ( VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        {        				/* 301LV/302LV only */
+            /* Set 301LV Capability */
+            XGINew_SetReg1( pVBInfo->Part4Port , 0x24 , ( UCHAR )( tempcx & 0x1F ) ) ;
+	}
+        /* VB Driving */
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x0D , ~( ( EnableVBCLKDRVLOW | EnablePLLSPLOW ) >> 8 ) , ( USHORT )( ( tempcx & ( EnableVBCLKDRVLOW | EnablePLLSPLOW ) ) >> 8 ) ) ;
+    }
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->VBInfo & SetCRT2ToLCD )
+            XGI_SetLCDCap_B( tempcx,pVBInfo ) ;
+        else if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+            XGI_SetLCDCap_A( tempcx,pVBInfo ) ;
+
+        if ( pVBInfo->VBType & ( VB_XGI302LV | VB_XGI301C ) )
+        {
+            if ( tempcx & EnableSpectrum )
+                SetSpectrum( pVBInfo) ;
+        }
+    }
+    else      /* LVDS,CH7017 */
+        XGI_SetLCDCap_A( tempcx, pVBInfo ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLCDCap_A */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetLCDCap_A(USHORT tempcx,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT temp ;
+
+    temp = XGINew_GetReg1( pVBInfo->P3d4 , 0x37 ) ;
+
+    if ( temp & LCDRGB18Bit )
+    {
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x19 , 0x0F , ( USHORT )( 0x20 | ( tempcx & 0x00C0 ) ) ) ; /* Enable Dither */
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x1A , 0x7F , 0x80 ) ;
+    }
+    else
+    {
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x19 , 0x0F , ( USHORT )( 0x30 | ( tempcx & 0x00C0 ) ) ) ;
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x1A , 0x7F , 0x00 ) ;
+    }
+
+/*
+    if ( tempcx & EnableLCD24bpp )	// 24bits
+    {
+        XGINew_SetRegANDOR(pVBInfo->Part1Port,0x19, 0x0F,(USHORT)(0x30|(tempcx&0x00C0)) );
+        XGINew_SetRegANDOR(pVBInfo->Part1Port,0x1A,0x7F,0x00);
+    }
+    else
+    {
+        XGINew_SetRegANDOR(pVBInfo->Part1Port,0x19, 0x0F,(USHORT)(0x20|(tempcx&0x00C0)) );//Enable Dither
+        XGINew_SetRegANDOR(pVBInfo->Part1Port,0x1A,0x7F,0x80);
+    }
+*/
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetLCDCap_B */
+/* Input : cx -> LCD Capability */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetLCDCap_B(USHORT tempcx,PVB_DEVICE_INFO pVBInfo)
+{
+    if ( tempcx & EnableLCD24bpp )	/* 24bits */
+        XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x1A , 0xE0 , ( USHORT )( ( ( tempcx & 0x00ff ) >> 6 ) | 0x0c ) ) ;
+    else
+        XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x1A , 0xE0 , ( USHORT )( ( ( tempcx & 0x00ff ) >> 6 ) | 0x18 ) ) ; /* Enable Dither */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : SetSpectrum */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void SetSpectrum( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT index ;
+
+    index = XGI_GetLCDCapPtr(pVBInfo) ;
+
+    XGINew_SetRegAND( pVBInfo->Part4Port , 0x30 , 0x8F ) ;   /* disable down spectrum D[4] */
+    XGI_LongWait(pVBInfo) ;
+    XGINew_SetRegOR( pVBInfo->Part4Port , 0x30 , 0x20 ) ;	 /* reset spectrum */
+    XGI_LongWait(pVBInfo) ;
+
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x31 , pVBInfo->LCDCapList[ index ].Spectrum_31 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x32 , pVBInfo->LCDCapList[ index ].Spectrum_32 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x33 , pVBInfo->LCDCapList[ index ].Spectrum_33 ) ;
+    XGINew_SetReg1( pVBInfo->Part4Port , 0x34 , pVBInfo->LCDCapList[ index ].Spectrum_34 ) ;
+    XGI_LongWait(pVBInfo) ;
+    XGINew_SetRegOR( pVBInfo->Part4Port , 0x30 , 0x40 ) ; /* enable spectrum */
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetAntiFlicker */
+/* Input : */
+/* Output : */
+/* Description : Set TV Customized Param. */
+/* --------------------------------------------------------------------- */
+void XGI_SetAntiFlicker( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx ,
+           index ;
+
+    UCHAR tempah ;
+
+    if (pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) )
+        return ;
+
+    tempbx = XGI_GetTVPtrIndex(pVBInfo ) ;
+    tempbx &= 0xFE ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        index = pVBInfo->SModeIDTable[ ModeIdIndex ].VB_StTVFlickerIndex ;
+    }
+    else
+    {
+        index = pVBInfo->EModeIDTable[ ModeIdIndex ].VB_ExtTVFlickerIndex ;
+    }
+
+    tempbx += index ;
+    tempah = TVAntiFlickList[ tempbx ] ;
+    tempah = tempah << 4 ;
+
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x0A , 0x8F , tempah ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetEdgeEnhance */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetEdgeEnhance( USHORT ModeNo , USHORT ModeIdIndex , PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx ,
+           index ;
+
+    UCHAR tempah ;
+
+
+    tempbx = XGI_GetTVPtrIndex(pVBInfo ) ;
+    tempbx &= 0xFE ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        index = pVBInfo->SModeIDTable[ ModeIdIndex ].VB_StTVEdgeIndex ;
+    }
+    else
+    {
+        index = pVBInfo->EModeIDTable[ ModeIdIndex ].VB_ExtTVEdgeIndex ;
+    }
+
+    tempbx += index ;
+    tempah = TVEdgeList[ tempbx ] ;
+    tempah = tempah << 5 ;
+
+    XGINew_SetRegANDOR( pVBInfo->Part2Port , 0x3A , 0x1F , tempah ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetPhaseIncr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetPhaseIncr( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx ;
+
+    UCHAR tempcl ,
+          tempch ;
+
+    ULONG tempData ;
+
+    XGI_GetTVPtrIndex2( &tempbx , &tempcl , &tempch, pVBInfo ) ; /* bx, cl, ch */
+    tempData = TVPhaseList[ tempbx ] ;
+
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x31 , ( USHORT )( tempData & 0x000000FF ) ) ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x32 , ( USHORT )( ( tempData & 0x0000FF00 ) >> 8 ) ) ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x33 , ( USHORT )( ( tempData & 0x00FF0000 ) >> 16 ) ) ;
+    XGINew_SetReg1( pVBInfo->Part2Port , 0x34 , ( USHORT )( ( tempData & 0xFF000000 ) >> 24 ) ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetYFilter */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_SetYFilter( USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx ,
+           index ;
+
+    UCHAR tempcl ,
+          tempch ,
+          tempal ,
+          *filterPtr ;
+
+    XGI_GetTVPtrIndex2( &tempbx , &tempcl , &tempch, pVBInfo ) ; /* bx, cl, ch */
+
+    switch( tempbx )
+    {
+        case 0x00:
+        case 0x04:
+            filterPtr = NTSCYFilter1 ;
+            break ;
+
+        case 0x01:
+            filterPtr = PALYFilter1 ;
+            break ;
+
+        case 0x02:
+        case 0x05:
+        case 0x0D:
+            filterPtr = PALMYFilter1 ;
+            break ;
+
+        case 0x03:
+            filterPtr = PALNYFilter1 ;
+            break ;
+
+        case 0x08:
+        case 0x0C:
+            filterPtr = NTSCYFilter2 ;
+            break ;
+
+        case 0x0A:
+            filterPtr = PALMYFilter2 ;
+            break ;
+
+        case 0x0B:
+            filterPtr = PALNYFilter2 ;
+            break ;
+
+        case 0x09:
+            filterPtr = PALYFilter2 ;
+            break ;
+
+        default:
+            return ;
+    }
+
+    if ( ModeNo <= 0x13 )
+        tempal = pVBInfo->SModeIDTable[ ModeIdIndex ].VB_StTVYFilterIndex ;
+    else
+        tempal = pVBInfo->EModeIDTable[ ModeIdIndex ].VB_ExtTVYFilterIndex ;
+
+    if ( tempcl == 0 )
+        index = tempal * 4;
+    else
+        index = tempal * 7;
+
+    if ( ( tempcl == 0 ) && ( tempch == 1 ) )
+    {
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x35 , 0 ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x36 , 0 ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x37 , 0 ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x38 , filterPtr[ index++ ] ) ;
+    }
+    else
+    {
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x35 , filterPtr[ index++ ] ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x36 , filterPtr[ index++ ] ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x37 , filterPtr[ index++ ] ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x38 , filterPtr[ index++ ] ) ;
+    }
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x48 , filterPtr[ index++ ] ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x49 , filterPtr[ index++ ] ) ;
+        XGINew_SetReg1( pVBInfo->Part2Port , 0x4A , filterPtr[ index++ ] ) ;
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetTVPtrIndex2 */
+/* Input : */
+/* Output : bx 0 : NTSC */
+/* 1 : PAL */
+/* 2 : PALM */
+/* 3 : PALN */
+/* 4 : NTSC1024x768 */
+/* 5 : PAL-M 1024x768 */
+/* 6-7: reserved */
+/* cl 0 : YFilter1 */
+/* 1 : YFilter2 */
+/* ch 0 : 301A */
+/* 1 : 301B/302B/301LV/302LV */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetTVPtrIndex2(USHORT* tempbx,UCHAR* tempcl,UCHAR* tempch, PVB_DEVICE_INFO pVBInfo)
+{
+    *tempbx = 0 ;
+    *tempcl = 0 ;
+    *tempch = 0 ;
+
+    if ( pVBInfo->TVInfo & SetPALTV )
+        *tempbx = 1 ;
+
+    if ( pVBInfo->TVInfo & SetPALMTV )
+        *tempbx = 2 ;
+
+    if ( pVBInfo->TVInfo & SetPALNTV )
+        *tempbx = 3 ;
+
+    if ( pVBInfo->TVInfo & NTSC1024x768 )
+    {
+        *tempbx = 4 ;
+        if ( pVBInfo->TVInfo & SetPALMTV )
+            *tempbx = 5 ;
+    }
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( ( !( pVBInfo->VBInfo & SetInSlaveMode ) ) || ( pVBInfo->TVInfo & TVSimuMode ) )
+        {
+            *tempbx += 8 ;
+            *tempcl += 1 ;
+        }
+    }
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+        (*tempch)++ ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_SetCRT2ModeRegs */
+/* Input : */
+/* Output : */
+/* Description : Origin code for crt2group */
+/* --------------------------------------------------------------------- */
+void XGI_SetCRT2ModeRegs(USHORT ModeNo,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbl ;
+    SHORT  tempcl ;
+
+    UCHAR  tempah ;
+
+    /* XGINew_SetReg1( pVBInfo->Part1Port , 0x03 , 0x00 ) ; // fix write part1 index 0 BTDRAM bit Bug */
+    tempah=0;
+    if ( !( pVBInfo->VBInfo & DisableCRT2Display ) )
+    {
+        tempah=XGINew_GetReg1( pVBInfo->Part1Port , 0x00 ) ;
+        tempah &= ~0x10 ;	/* BTRAMDAC */
+        tempah |=  0x40 ;	/* BTRAM */
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToTV | SetCRT2ToLCD ) )
+        {
+            tempah=0x40;	/* BTDRAM */
+            if ( ModeNo > 0x13 )
+            {
+                tempcl = pVBInfo->ModeType ;
+                tempcl -= ModeVGA ;
+                if ( tempcl >= 0 )
+                {
+                    tempah = ( 0x008 >> tempcl ) ;	/* BT Color */
+                    if ( tempah == 0 )
+                        tempah = 1 ;
+                    tempah |= 0x040 ;
+                }
+            }
+            if ( pVBInfo->VBInfo & SetInSlaveMode )
+                tempah ^= 0x50 ;	/* BTDAC */
+        }
+    }
+
+/*	0210 shampoo
+    if ( pVBInfo->VBInfo & DisableCRT2Display )
+    {
+        tempah = 0 ;
+    }
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x00 , tempah ) ;
+    if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToTV | SetCRT2ToLCD ) )
+    {
+        tempcl = pVBInfo->ModeType ;
+        if ( ModeNo > 0x13 )
+        {
+            tempcl -= ModeVGA ;
+            if ( ( tempcl > 0 ) || ( tempcl == 0 ) )
+            {
+                tempah=(0x008>>tempcl) ;
+                if ( tempah == 0 )
+                    tempah = 1 ;
+                tempah |= 0x040;
+            }
+        }
+        else
+        {
+            tempah = 0x040 ;
+        }
+
+        if ( pVBInfo->VBInfo & SetInSlaveMode )
+        {
+            tempah = ( tempah ^ 0x050 ) ;
+        }
+    }
+*/
+
+    XGINew_SetReg1( pVBInfo->Part1Port , 0x00 , tempah ) ;
+    tempah = 0x08 ;
+    tempbl = 0xf0 ;
+
+    if ( pVBInfo->VBInfo & DisableCRT2Display )
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2e , tempbl , tempah ) ;
+    else
+    {
+        tempah = 0x00 ;
+        tempbl = 0xff ;
+
+        if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToTV | SetCRT2ToLCD | SetCRT2ToLCDA ) )
+        {
+            if ( ( pVBInfo->VBInfo & SetCRT2ToLCDA ) && ( !( pVBInfo->VBInfo & SetSimuScanMode ) ) )
+            {
+                tempbl &= 0xf7 ;
+                tempah |= 0x01 ;
+                XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2e , tempbl , tempah ) ;
+            }
+            else
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                {
+                    tempbl &= 0xf7 ;
+                    tempah |= 0x01 ;
+                }
+
+                if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToTV | SetCRT2ToLCD ) )
+                {
+                    tempbl &= 0xf8 ;
+                    tempah = 0x01 ;
+
+                    if ( !( pVBInfo->VBInfo & SetInSlaveMode ) )
+                        tempah |= 0x02 ;
+
+                    if ( !( pVBInfo->VBInfo & SetCRT2ToRAMDAC ) )
+                    {
+                        tempah = tempah ^ 0x05 ;
+                        if ( !( pVBInfo->VBInfo & SetCRT2ToLCD ) )
+                            tempah = tempah ^ 0x01 ;
+                    }
+
+                    if ( !( pVBInfo->VBInfo & SetCRT2ToDualEdge ) )
+                        tempah |= 0x08 ;
+                    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2e , tempbl , tempah ) ;
+                }
+                else
+                    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2e , tempbl , tempah ) ;
+            }
+        }
+        else
+            XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2e , tempbl , tempah ) ;
+    }
+
+    if ( pVBInfo->VBInfo & ( SetCRT2ToRAMDAC | SetCRT2ToTV | SetCRT2ToLCD | SetCRT2ToLCDA ) )
+    {
+        tempah &= ( ~0x08 ) ;
+        if ( ( pVBInfo->ModeType == ModeVGA ) && ( !( pVBInfo->VBInfo & SetInSlaveMode ) ) )
+        {
+            tempah |= 0x010 ;
+        }
+        tempah |= 0x080 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            /* if ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) ) ) */
+            /* { */
+            tempah |= 0x020 ;
+            if ( ModeNo > 0x13 )
+            {
+                if ( pVBInfo->VBInfo & DriverMode )
+                    tempah = tempah ^ 0x20 ;
+            }
+        /* } */
+        }
+
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x0D , ~0x0BF , tempah ) ;
+        tempah = 0 ;
+
+        if ( pVBInfo->LCDInfo & SetLCDDualLink )
+            tempah |= 0x40 ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToTV )
+        {
+            /* if ( ( !( pVBInfo->VBInfo & SetCRT2ToHiVisionTV ) ) && ( !( pVBInfo->TVInfo & ( SetYPbPrMode525p | SetYPbPrMode750p ) ) ) ) */
+            /* { */
+                if ( pVBInfo->TVInfo & RPLLDIV2XO )
+                    tempah |= 0x40 ;
+            /* } */
+        }
+
+        if ( ( pVBInfo->LCDResInfo == Panel1280x1024 ) || ( pVBInfo->LCDResInfo == Panel1280x1024x75 ) )
+            tempah |= 0x80 ;
+
+        if ( pVBInfo->LCDResInfo == Panel1280x960 )
+            tempah |= 0x80 ;
+
+        XGINew_SetReg1( pVBInfo->Part4Port , 0x0C , tempah ) ;
+    }
+
+    if ( pVBInfo->VBType & ( VB_XGI301B | VB_XGI302B | VB_XGI301LV | VB_XGI302LV | VB_XGI301C ) )
+    {
+        tempah = 0 ;
+        tempbl = 0xfb ;
+
+        if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+        {
+            tempbl=0xff;
+            if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+                tempah |= 0x04 ; /* shampoo 0129 */
+        }
+
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x13 , tempbl , tempah ) ;
+        tempah = 0x00 ;
+        tempbl = 0xcf ;
+        if ( !( pVBInfo->VBInfo & DisableCRT2Display ) )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+                tempah |= 0x30 ;
+        }
+
+        XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2c , tempbl , tempah ) ;
+        tempah = 0 ;
+        tempbl = 0x3f ;
+
+        if ( !( pVBInfo->VBInfo & DisableCRT2Display ) )
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToDualEdge )
+                tempah |= 0xc0 ;
+        }
+        XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x21 , tempbl , tempah ) ;
+    }
+
+    tempah = 0 ;
+    tempbl = 0x7f ;
+    if ( !( pVBInfo->VBInfo & SetCRT2ToLCDA ) )
+    {
+        tempbl = 0xff ;
+        if ( !( pVBInfo->VBInfo & SetCRT2ToDualEdge ) )
+            tempah |= 0x80 ;
+    }
+
+    XGINew_SetRegANDOR( pVBInfo->Part4Port , 0x23 , tempbl , tempah ) ;
+
+    if ( pVBInfo->VBType & ( VB_XGI302LV | VB_XGI301C ) )
+    {
+        if ( pVBInfo->LCDInfo & SetLCDDualLink )
+        {
+            XGINew_SetRegOR( pVBInfo->Part4Port , 0x27 , 0x20 ) ;
+            XGINew_SetRegOR( pVBInfo->Part4Port , 0x34 , 0x10 ) ;
+        }
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_CloseCRTC */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_CloseCRTC( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx ;
+
+    tempbx = 0 ;
+
+    if ( pVBInfo->VBInfo & SetCRT2ToLCDA )
+        tempbx = 0x08A0 ;
+
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_OpenCRTC */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_OpenCRTC( PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempbx ;
+
+    tempbx = 0 ;
+
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetRAMDAC2DATA */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_GetRAMDAC2DATA(USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex, PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempax ,
+           tempbx ,
+           temp1 ,
+           temp2 ,
+           modeflag = 0 ,
+           tempcx ,
+           StandTableIndex ,
+           CRT1Index ;
+
+    pVBInfo->RVBHCMAX = 1 ;
+    pVBInfo->RVBHCFACT = 1 ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+        StandTableIndex = XGI_GetModePtr( ModeNo , ModeIdIndex, pVBInfo ) ;
+        tempax = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 0 ] ;
+        tempbx = pVBInfo->StandTable[StandTableIndex ].CRTC[ 6 ] ;
+        temp1 = pVBInfo->StandTable[ StandTableIndex ].CRTC[ 7 ] ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+        CRT1Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT1CRTC ;
+        CRT1Index &= IndexMask ;
+        temp1 = ( USHORT )pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 0 ] ;
+        temp2 = ( USHORT )pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 5 ] ;
+	tempax = ( temp1 & 0xFF ) | ( ( temp2 & 0x03 ) << 8 ) ;
+        tempbx = ( USHORT )pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 8 ] ;
+        tempcx = ( USHORT )pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 14 ] << 8 ;
+	tempcx &= 0x0100 ;
+	tempcx = tempcx << 2 ;
+	tempbx |= tempcx;
+        temp1 = ( USHORT )pVBInfo->XGINEWUB_CRT1Table[ CRT1Index ].CR[ 9 ] ;
+    }
+
+    if ( temp1 & 0x01 )
+        tempbx |= 0x0100 ;
+
+    if ( temp1 & 0x20 )
+        tempbx |= 0x0200 ;
+    tempax += 5 ;
+
+    if ( modeflag & Charx8Dot )
+        tempax *= 8 ;
+    else
+        tempax *= 9 ;
+
+    pVBInfo->VGAHT = tempax ;
+    pVBInfo->HT = tempax ;
+    tempbx++ ;
+    pVBInfo->VGAVT = tempbx ;
+    pVBInfo->VT = tempbx ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetColorDepth */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetColorDepth(USHORT ModeNo , USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT ColorDepth[ 6 ] = { 1 , 2 , 4 , 4 , 6 , 8 } ;
+    SHORT  index ;
+    USHORT modeflag ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;
+    }
+
+    index=(modeflag&ModeInfoFlag)-ModeEGA;
+
+    if ( index < 0 )
+        index = 0 ;
+
+    return( ColorDepth[ index ] ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_UnLockCRT2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_UnLockCRT2( PXGI_HW_DEVICE_INFO HwDeviceExtension,  PVB_DEVICE_INFO pVBInfo )
+{
+
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2f , 0xFF , 0x01 ) ;
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_LockCRT2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_LockCRT2( PXGI_HW_DEVICE_INFO HwDeviceExtension,  PVB_DEVICE_INFO pVBInfo )
+{
+
+    XGINew_SetRegANDOR( pVBInfo->Part1Port , 0x2F , 0xFE , 0x00 ) ;
+
+
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_EnableCRT2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_EnableCRT2( PVB_DEVICE_INFO pVBInfo)
+{
+    XGINew_SetRegANDOR( pVBInfo->P3c4 , 0x1E , 0xFF , 0x20 ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_LCD_Wait_Time(UCHAR DelayTime, PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT i ,
+           j ;
+
+    ULONG temp ,
+          flag ;
+
+    flag = 0 ;
+//printk("XGINew_LCD_Wait_Time");
+//return;
+    for( i = 0 ; i < DelayTime ; i++ )
+    {
+        for( j = 0 ; j < 66 ; j++ )
+        {
+
+            temp =  XGINew_GetReg3( 0x61 ) ;
+
+            //temp &= 0x10000000;
+            temp &= 0x10;
+            if ( temp == flag )
+                continue ;
+
+            flag = temp ;
+        }
+    }
+}
+
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_BridgeIsOn */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+BOOLEAN XGI_BridgeIsOn( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT flag ;
+
+    if ( pVBInfo->IF_DEF_LVDS == 1 )
+    {
+        return( 1 ) ;
+    }
+    else
+    {
+        flag = XGINew_GetReg1( pVBInfo->Part4Port , 0x00 ) ;
+        if ( ( flag == 1 ) || ( flag == 2 ) )
+            return( 1 ) ;	/* 301b */
+        else
+            return( 0 ) ;
+    }
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_LongWait */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_LongWait(PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT i ;
+
+    i = XGINew_GetReg1( pVBInfo->P3c4 , 0x1F ) ;
+
+    if ( !( i & 0xC0 ) )
+    {
+        for( i = 0 ; i < 0xFFFF ; i++ )
+        {
+            if ( !( XGINew_GetReg2( pVBInfo->P3da ) & 0x08 ) )
+                break ;
+        }
+
+        for( i = 0 ; i < 0xFFFF ; i++ )
+        {
+            if ( ( XGINew_GetReg2( pVBInfo->P3da ) & 0x08 ) )
+                break ;
+	}
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_VBLongWait */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGI_VBLongWait( PVB_DEVICE_INFO pVBInfo )
+{
+    USHORT tempal ,
+           temp ,
+           i ,
+           j ;
+return ;
+    if ( !( pVBInfo->VBInfo & SetCRT2ToTV ) )
+    {
+        temp = 0 ;
+        for( i = 0 ; i < 3 ; i++ )
+        {
+            for( j = 0 ; j < 100 ; j++ )
+            {
+                tempal = XGINew_GetReg2( pVBInfo->P3da ) ;
+                if ( temp & 0x01 )
+                {			/* VBWaitMode2 */
+                    if ( ( tempal & 0x08 ) )
+                    {
+                        continue ;
+                    }
+
+                    if ( !( tempal & 0x08 ) )
+                    {
+                        break ;
+                    }
+                }
+                else
+                {			/* VBWaitMode1 */
+                    if ( !( tempal & 0x08 ) )
+                    {
+                        continue ;
+                    }
+
+                    if ( ( tempal & 0x08 ) )
+                    {
+                        break ;
+                    }
+                }
+            }
+            temp = temp ^ 0x01 ;
+        }
+    }
+    else
+    {
+        XGI_LongWait(pVBInfo) ;
+    }
+    return ;
+}
+
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVGAHT2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetVGAHT2( PVB_DEVICE_INFO pVBInfo )
+{
+    ULONG tempax ,
+          tempbx ;
+
+    tempbx = ( ( pVBInfo->VGAVT - pVBInfo->VGAVDE ) * pVBInfo->RVBHCMAX ) & 0xFFFF ;
+    tempax = ( pVBInfo->VT - pVBInfo->VDE ) * pVBInfo->RVBHCFACT ;
+    tempax = ( tempax * pVBInfo->HT ) /tempbx ;
+
+    return( ( USHORT )tempax ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGI_GetVCLK2Ptr */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+USHORT XGI_GetVCLK2Ptr( USHORT ModeNo , USHORT ModeIdIndex , USHORT RefreshRateTableIndex , PXGI_HW_DEVICE_INFO HwDeviceExtension ,PVB_DEVICE_INFO pVBInfo)
+{
+    USHORT tempbx ;
+
+    USHORT LCDXlat1VCLK[ 4 ] = { VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 } ;
+    USHORT LCDXlat2VCLK[ 4 ] = { VCLK108_2 + 5 , VCLK108_2 + 5 , VCLK108_2 + 5 , VCLK108_2 + 5 } ;
+    USHORT LVDSXlat1VCLK[ 4 ] = { VCLK40 , VCLK40 , VCLK40 , VCLK40 } ;
+    USHORT LVDSXlat2VCLK[ 4 ] = { VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 } ;
+    USHORT LVDSXlat3VCLK[ 4 ] = { VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 , VCLK65 + 2 } ;
+
+    USHORT CRT2Index , VCLKIndex ;
+    USHORT modeflag , resinfo ;
+    UCHAR *CHTVVCLKPtr = NULL ;
+
+    if ( ModeNo <= 0x13 )
+    {
+        modeflag = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ModeFlag ;      /* si+St_ResInfo */
+        resinfo = pVBInfo->SModeIDTable[ ModeIdIndex ].St_ResInfo ;
+        CRT2Index = pVBInfo->SModeIDTable[ ModeIdIndex ].St_CRT2CRTC ;
+    }
+    else
+    {
+        modeflag = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_ModeFlag ;     /* si+Ext_ResInfo */
+        resinfo = pVBInfo->EModeIDTable[ ModeIdIndex ].Ext_RESINFO ;
+        CRT2Index = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRT2CRTC ;
+    }
+
+    if ( pVBInfo->IF_DEF_LVDS == 0 )
+    {
+        CRT2Index = CRT2Index >> 6 ;        /*  for LCD */
+        if ( ( ( pVBInfo->VBInfo & SetCRT2ToLCD ) | SetCRT2ToLCDA ) )	 /*301b*/
+        {
+            if ( pVBInfo->LCDResInfo != Panel1024x768 )
+            {
+                VCLKIndex = LCDXlat2VCLK[ CRT2Index ] ;
+            }
+            else
+            {
+                 VCLKIndex = LCDXlat1VCLK[ CRT2Index ] ;
+            }
+        }
+        else	/* for TV */
+        {
+            if ( pVBInfo->VBInfo & SetCRT2ToTV )
+            {
+                if ( pVBInfo->VBInfo & SetCRT2ToHiVisionTV )
+                {
+                    if ( pVBInfo->SetFlag & RPLLDIV2XO )
+                    {
+                        VCLKIndex = HiTVVCLKDIV2 ;
+
+
+                            VCLKIndex += 25 ;
+
+                    }
+                    else
+                    {
+                        VCLKIndex = HiTVVCLK ;
+
+
+                            VCLKIndex += 25 ;
+
+                    }
+
+                    if ( pVBInfo->SetFlag & TVSimuMode )
+                    {
+                        if( modeflag & Charx8Dot )
+                        {
+                            VCLKIndex = HiTVSimuVCLK ;
+
+
+                                VCLKIndex += 25 ;
+
+                        }
+                        else
+                        {
+                            VCLKIndex = HiTVTextVCLK ;
+
+
+                                VCLKIndex += 25 ;
+
+                        }
+                    }
+
+                    if ( pVBInfo->VBType & VB_XGI301LV )	/* 301lv */
+                    {
+                        if ( !( pVBInfo->VBExtInfo == VB_YPbPr1080i ) )
+                        {
+                            VCLKIndex = YPbPr750pVCLK ;
+                            if ( !( pVBInfo->VBExtInfo == VB_YPbPr750p ) )
+                            {
+                                VCLKIndex = YPbPr525pVCLK ;
+                                if ( !( pVBInfo->VBExtInfo == VB_YPbPr525p ) )
+                                {
+                                    VCLKIndex = YPbPr525iVCLK_2 ;
+                                    if ( !( pVBInfo->SetFlag & RPLLDIV2XO ) )
+                                        VCLKIndex = YPbPr525iVCLK ;
+                                }
+                            }
+                        }
+                    }
+                }
+                else
+                {
+                    if ( pVBInfo->VBInfo & SetCRT2ToTV )
+                    {
+                        if ( pVBInfo->SetFlag & RPLLDIV2XO )
+			{
+                            VCLKIndex = TVVCLKDIV2 ;
+
+
+                            VCLKIndex += 25 ;
+
+                        }
+                        else
+                        {
+                            VCLKIndex = TVVCLK ;
+
+
+                            VCLKIndex += 25 ;
+
+                        }
+                    }
+                }
+            }
+            else
+            {	/* for CRT2 */
+                VCLKIndex = ( UCHAR )XGINew_GetReg2( ( pVBInfo->P3ca + 0x02 ) ) ;	/* Port 3cch */
+		VCLKIndex = ( ( VCLKIndex >> 2 ) & 0x03 ) ;
+                if ( ModeNo > 0x13 )
+                {
+                    VCLKIndex = pVBInfo->RefIndex[ RefreshRateTableIndex ].Ext_CRTVCLK ;	/* di+Ext_CRTVCLK */
+                    VCLKIndex &= IndexMask ;
+                }
+            }
+        }
+    }
+    else
+    {		/* LVDS */
+        if ( ModeNo <= 0x13 )
+            VCLKIndex = CRT2Index ;
+	else
+	    VCLKIndex = CRT2Index ;
+
+        if ( pVBInfo->IF_DEF_CH7005 == 1 )
+        {
+            if ( !( pVBInfo->VBInfo & SetCRT2ToLCD ) )
+            {
+                VCLKIndex &= 0x1f ;
+		tempbx = 0 ;
+
+                if ( pVBInfo->VBInfo & SetPALTV )
+                    tempbx += 2 ;
+
+                if ( pVBInfo->VBInfo & SetCHTVOverScan )
+                    tempbx += 1 ;
+
+                switch( tempbx )
+                {
+                    case 0:
+                        CHTVVCLKPtr = pVBInfo->CHTVVCLKUNTSC ;
+                        break ;
+                    case 1:
+                        CHTVVCLKPtr = pVBInfo->CHTVVCLKONTSC ;
+                        break;
+                    case 2:
+                        CHTVVCLKPtr = pVBInfo->CHTVVCLKUPAL ;
+                        break ;
+                    case 3:
+                        CHTVVCLKPtr = pVBInfo->CHTVVCLKOPAL ;
+                        break ;
+                    default:
+                        break ;
+                }
+
+                VCLKIndex = CHTVVCLKPtr[ VCLKIndex ] ;
+            }
+        }
+        else
+        {
+            VCLKIndex = VCLKIndex >> 6 ;
+            if ( ( pVBInfo->LCDResInfo == Panel800x600 ) || ( pVBInfo->LCDResInfo == Panel320x480 ) )
+                VCLKIndex = LVDSXlat1VCLK[ VCLKIndex ] ;
+            else if ( ( pVBInfo->LCDResInfo == Panel1024x768 ) || ( pVBInfo->LCDResInfo == Panel1024x768x75 ) )
+                VCLKIndex = LVDSXlat2VCLK[ VCLKIndex ] ;
+            else
+                VCLKIndex = LVDSXlat3VCLK[ VCLKIndex ] ;
+        }
+    }
+    /* VCLKIndex = VCLKIndex&IndexMask ; */
+
+
+
+    return( VCLKIndex ) ;
+}
+
--- /dev/null
+++ b/drivers/staging/xgifb/vb_setmode.h
@@ -0,0 +1,40 @@
+#ifndef  _VBSETMODE_
+#define  _VBSETMODE_
+
+extern   void     InitTo330Pointer(UCHAR,PVB_DEVICE_INFO);
+extern   void     XGI_UnLockCRT2(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_LockCRT2(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_LongWait( PVB_DEVICE_INFO );
+extern   void     XGI_SetCRT2ModeRegs(USHORT ModeNo,PXGI_HW_DEVICE_INFO,  PVB_DEVICE_INFO  );
+extern   void     XGI_DisableBridge(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void  	  XGI_EnableBridge(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_DisplayOff( PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO );
+extern   void     XGI_DisplayOn( PXGI_HW_DEVICE_INFO, PVB_DEVICE_INFO );
+extern   void     XGI_GetVBType(PVB_DEVICE_INFO);
+extern   void     XGI_SenseCRT1(PVB_DEVICE_INFO );
+extern   void     XGI_GetVGAType(PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_GetVBInfo(USHORT ModeNo,USHORT ModeIdIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_GetTVInfo(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO );
+extern   void     XGI_SetCRT1Offset(USHORT ModeNo,USHORT ModeIdIndex,USHORT RefreshRateTableIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_SetLCDAGroup(USHORT ModeNo,USHORT ModeIdIndex,PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO );
+extern   void     XGI_WaitDisply( PVB_DEVICE_INFO );
+extern   USHORT   XGI_GetResInfo(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo);
+
+extern   BOOLEAN  XGISetModeNew( PXGI_HW_DEVICE_INFO HwDeviceExtension , USHORT ModeNo ) ;
+
+extern   BOOLEAN  XGI_SearchModeID( USHORT ModeNo,USHORT  *ModeIdIndex, PVB_DEVICE_INFO );
+extern   BOOLEAN  XGI_GetLCDInfo(USHORT ModeNo,USHORT ModeIdIndex,PVB_DEVICE_INFO );
+extern   BOOLEAN  XGI_BridgeIsOn( PVB_DEVICE_INFO );
+extern   BOOLEAN  XGI_SetCRT2Group301(USHORT ModeNo, PXGI_HW_DEVICE_INFO HwDeviceExtension, PVB_DEVICE_INFO);
+extern   USHORT   XGI_GetRatePtrCRT2( PXGI_HW_DEVICE_INFO pXGIHWDE, USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO );
+
+extern   void     XGI_SetXG21FPBits(PVB_DEVICE_INFO pVBInfo);
+extern   void     XGI_SetXG27FPBits(PVB_DEVICE_INFO pVBInfo);
+extern   void     XGI_XG21BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+extern   void     XGI_XG27BLSignalVDD(USHORT tempbh,USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+extern   void     XGI_XG21SetPanelDelay(USHORT tempbl, PVB_DEVICE_INFO pVBInfo);
+extern   BOOLEAN  XGI_XG21CheckLVDSMode(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo );
+extern   void     XGI_SetXG21LVDSPara(USHORT ModeNo,USHORT ModeIdIndex, PVB_DEVICE_INFO pVBInfo );
+extern   USHORT XGI_GetLVDSOEMTableIndex(PVB_DEVICE_INFO pVBInfo);
+
+#endif
--- /dev/null
+++ b/drivers/staging/xgifb/vb_struct.h
@@ -0,0 +1,534 @@
+#ifndef _VB_STRUCT_
+#define _VB_STRUCT_
+
+#ifdef _INITNEW_
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+
+
+
+typedef struct _XGI_PanelDelayTblStruct
+{
+ UCHAR timer[2];
+} XGI_PanelDelayTblStruct;
+
+typedef struct _XGI_LCDDataStruct
+{
+ USHORT RVBHCMAX;
+ USHORT RVBHCFACT;
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT LCDHT;
+ USHORT LCDVT;
+} XGI_LCDDataStruct;
+
+
+typedef struct _XGI_LVDSCRT1HDataStruct
+{
+ UCHAR Reg[8];
+} XGI_LVDSCRT1HDataStruct;
+typedef struct _XGI_LVDSCRT1VDataStruct
+{
+ UCHAR Reg[7];
+} XGI_LVDSCRT1VDataStruct;
+
+
+typedef struct _XGI_TVDataStruct
+{
+ USHORT RVBHCMAX;
+ USHORT RVBHCFACT;
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT TVHDE;
+ USHORT TVVDE;
+ USHORT RVBHRS;
+ UCHAR FlickerMode;
+ USHORT HALFRVBHRS;
+ UCHAR RY1COE;
+ UCHAR RY2COE;
+ UCHAR RY3COE;
+ UCHAR RY4COE;
+} XGI_TVDataStruct;
+
+typedef struct _XGI_LVDSDataStruct
+{
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT LCDHT;
+ USHORT LCDVT;
+} XGI_LVDSDataStruct;
+
+typedef struct _XGI_LVDSDesStruct
+{
+ USHORT LCDHDES;
+ USHORT LCDVDES;
+} XGI_LVDSDesStruct;
+
+typedef struct _XGI_LVDSCRT1DataStruct
+{
+ UCHAR CR[15];
+} XGI_LVDSCRT1DataStruct;
+
+/*add for LCDA*/
+
+
+typedef struct _XGI_StStruct
+{
+ UCHAR St_ModeID;
+ USHORT St_ModeFlag;
+ UCHAR St_StTableIndex;
+ UCHAR St_CRT2CRTC;
+ UCHAR St_CRT2CRTC2;
+ UCHAR St_ResInfo;
+ UCHAR VB_StTVFlickerIndex;
+ UCHAR VB_StTVEdgeIndex;
+ UCHAR VB_StTVYFilterIndex;
+} XGI_StStruct;
+
+typedef struct _XGI_StandTableStruct
+{
+ UCHAR CRT_COLS;
+ UCHAR ROWS;
+ UCHAR CHAR_HEIGHT;
+ USHORT CRT_LEN;
+ UCHAR SR[4];
+ UCHAR MISC;
+ UCHAR CRTC[0x19];
+ UCHAR ATTR[0x14];
+ UCHAR GRC[9];
+} XGI_StandTableStruct;
+
+typedef struct _XGI_ExtStruct
+{
+ UCHAR Ext_ModeID;
+ USHORT Ext_ModeFlag;
+ USHORT Ext_ModeInfo;
+ USHORT Ext_Point;
+ USHORT Ext_VESAID;
+ UCHAR Ext_VESAMEMSize;
+ UCHAR Ext_RESINFO;
+ UCHAR VB_ExtTVFlickerIndex;
+ UCHAR VB_ExtTVEdgeIndex;
+ UCHAR VB_ExtTVYFilterIndex;
+ UCHAR REFindex;
+} XGI_ExtStruct;
+
+typedef struct _XGI_Ext2Struct
+{
+ USHORT Ext_InfoFlag;
+ UCHAR Ext_CRT1CRTC;
+ UCHAR Ext_CRTVCLK;
+ UCHAR Ext_CRT2CRTC;
+ UCHAR Ext_CRT2CRTC2;
+ UCHAR  ModeID;
+ USHORT XRes;
+ USHORT YRes;
+ /* USHORT ROM_OFFSET; */
+} XGI_Ext2Struct;
+
+
+typedef struct _XGI_MCLKDataStruct
+{
+ UCHAR SR28,SR29,SR2A;
+ USHORT CLOCK;
+} XGI_MCLKDataStruct;
+
+typedef struct _XGI_ECLKDataStruct
+{
+ UCHAR SR2E,SR2F,SR30;
+ USHORT CLOCK;
+} XGI_ECLKDataStruct;
+
+typedef struct _XGI_VCLKDataStruct
+{
+ UCHAR SR2B,SR2C;
+ USHORT CLOCK;
+} XGI_VCLKDataStruct;
+
+typedef struct _XGI_VBVCLKDataStruct
+{
+ UCHAR Part4_A,Part4_B;
+ USHORT CLOCK;
+} XGI_VBVCLKDataStruct;
+
+typedef struct _XGI_StResInfoStruct
+{
+ USHORT HTotal;
+ USHORT VTotal;
+} XGI_StResInfoStruct;
+
+typedef struct _XGI_ModeResInfoStruct
+{
+ USHORT HTotal;
+ USHORT VTotal;
+ UCHAR  XChar;
+ UCHAR  YChar;
+} XGI_ModeResInfoStruct;
+
+typedef struct _XGI_LCDNBDesStruct
+{
+  UCHAR NB[12];
+} XGI_LCDNBDesStruct;
+ /*add for new UNIVGABIOS*/
+typedef struct _XGI_LCDDesStruct
+{
+ USHORT LCDHDES;
+ USHORT LCDHRS;
+ USHORT LCDVDES;
+ USHORT LCDVRS;
+} XGI_LCDDesStruct;
+
+typedef struct _XGI_LCDDataTablStruct
+{
+ UCHAR  PANELID;
+ USHORT MASK;
+ USHORT CAP;
+ USHORT DATAPTR;
+} XGI_LCDDataTablStruct;
+
+typedef struct _XGI_TVTablDataStruct
+{
+ USHORT MASK;
+ USHORT CAP;
+ USHORT DATAPTR;
+} XGI_TVDataTablStruct;
+
+typedef struct _XGI330_LCDDesDataStruct
+{
+ USHORT LCDHDES;
+ USHORT LCDHRS;
+ USHORT LCDVDES;
+ USHORT LCDVRS;
+} XGI330_LCDDataDesStruct;
+
+
+typedef struct _XGI330_LVDSDataStruct
+{
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT LCDHT;
+ USHORT LCDVT;
+} XGI330_LVDSDataStruct;
+
+typedef struct _XGI330_LCDDesDataStruct2
+{
+ USHORT LCDHDES;
+ USHORT LCDHRS;
+ USHORT LCDVDES;
+ USHORT LCDVRS;
+ USHORT LCDHSync;
+ USHORT LCDVSync;
+} XGI330_LCDDataDesStruct2;
+
+typedef struct _XGI330_LCDDataStruct
+{
+ USHORT RVBHCMAX;
+ USHORT RVBHCFACT;
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT LCDHT;
+ USHORT LCDVT;
+} XGI330_LCDDataStruct;
+
+
+typedef struct _XGI330_TVDataStruct
+{
+ USHORT RVBHCMAX;
+ USHORT RVBHCFACT;
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT TVHDE;
+ USHORT TVVDE;
+ USHORT RVBHRS;
+ UCHAR FlickerMode;
+ USHORT HALFRVBHRS;
+} XGI330_TVDataStruct;
+
+typedef struct _XGI330_LCDDataTablStruct
+{
+ UCHAR  PANELID;
+ USHORT MASK;
+ USHORT CAP;
+ USHORT DATAPTR;
+} XGI330_LCDDataTablStruct;
+
+typedef struct _XGI330_TVDataTablStruct
+{
+ USHORT MASK;
+ USHORT CAP;
+ USHORT DATAPTR;
+} XGI330_TVDataTablStruct;
+
+
+typedef struct _XGI330_CHTVDataStruct
+{
+ USHORT VGAHT;
+ USHORT VGAVT;
+ USHORT LCDHT;
+ USHORT LCDVT;
+} XGI330_CHTVDataStruct;
+
+typedef struct _XGI_TimingHStruct
+{
+  UCHAR data[8];
+} XGI_TimingHStruct;
+
+typedef struct _XGI_TimingVStruct
+{
+  UCHAR data[7];
+} XGI_TimingVStruct;
+
+typedef struct _XGI_CH7007TV_TimingHStruct
+{
+  UCHAR data[10];
+} XGI_CH7007TV_TimingHStruct;
+
+typedef struct _XGI_CH7007TV_TimingVStruct
+{
+  UCHAR data[10];
+} XGI_CH7007TV_TimingVStruct;
+
+typedef struct _XGI_XG21CRT1Struct
+{
+ UCHAR ModeID,CR02,CR03,CR15,CR16;
+} XGI_XG21CRT1Struct;
+
+typedef struct _XGI330_CHTVRegDataStruct
+{
+ UCHAR Reg[16];
+} XGI330_CHTVRegDataStruct;
+
+typedef struct _XGI330_LCDCapStruct
+{
+ 		UCHAR      LCD_ID;
+                USHORT     LCD_Capability;
+                UCHAR      LCD_SetFlag;
+                UCHAR      LCD_DelayCompensation;
+                UCHAR      LCD_HSyncWidth;
+                UCHAR      LCD_VSyncWidth;
+                UCHAR      LCD_VCLK;
+                UCHAR      LCDA_VCLKData1;
+                UCHAR      LCDA_VCLKData2;
+                UCHAR      LCUCHAR_VCLKData1;
+                UCHAR      LCUCHAR_VCLKData2;
+                UCHAR      PSC_S1;
+                UCHAR      PSC_S2;
+                UCHAR      PSC_S3;
+                UCHAR      PSC_S4;
+                UCHAR      PSC_S5;
+                UCHAR      PWD_2B;
+                UCHAR      PWD_2C;
+                UCHAR      PWD_2D;
+                UCHAR      PWD_2E;
+                UCHAR      PWD_2F;
+                UCHAR      Spectrum_31;
+                UCHAR      Spectrum_32;
+                UCHAR      Spectrum_33;
+                UCHAR      Spectrum_34;
+} XGI330_LCDCapStruct;
+
+typedef struct _XGI21_LVDSCapStruct
+{
+                USHORT     LVDS_Capability;
+                USHORT     LVDSHT;
+                USHORT     LVDSVT;
+                USHORT     LVDSHDE;
+                USHORT     LVDSVDE;
+                USHORT     LVDSHFP;
+                USHORT     LVDSVFP;
+                USHORT     LVDSHSYNC;
+                USHORT     LVDSVSYNC;
+                UCHAR      VCLKData1;
+                UCHAR      VCLKData2;
+                UCHAR      PSC_S1;
+                UCHAR      PSC_S2;
+                UCHAR      PSC_S3;
+                UCHAR      PSC_S4;
+                UCHAR      PSC_S5;
+} XGI21_LVDSCapStruct;
+
+typedef struct _XGI_CRT1TableStruct
+{
+  UCHAR CR[16];
+} XGI_CRT1TableStruct;
+
+
+typedef struct _XGI330_VCLKDataStruct
+{
+    UCHAR SR2B,SR2C;
+    USHORT CLOCK;
+} XGI330_VCLKDataStruct;
+
+typedef struct _XGI301C_Tap4TimingStruct
+{
+    USHORT DE;
+    UCHAR  Reg[64];   /* C0-FF */
+} XGI301C_Tap4TimingStruct;
+
+typedef struct _XGI_New_StandTableStruct
+{
+	UCHAR  CRT_COLS;
+	UCHAR  ROWS;
+	UCHAR  CHAR_HEIGHT;
+	USHORT CRT_LEN;
+	UCHAR  SR[4];
+	UCHAR  MISC;
+	UCHAR  CRTC[0x19];
+	UCHAR  ATTR[0x14];
+	UCHAR  GRC[9];
+} XGI_New_StandTableStruct;
+
+typedef UCHAR DRAM8Type[8];
+typedef UCHAR DRAM4Type[4];
+typedef UCHAR DRAM32Type[32];
+typedef UCHAR DRAM2Type[2];
+
+typedef struct _VB_DEVICE_INFO  VB_DEVICE_INFO;
+typedef VB_DEVICE_INFO *	PVB_DEVICE_INFO;
+
+struct _VB_DEVICE_INFO
+{
+    BOOLEAN  ISXPDOS;
+    ULONG   P3c4,P3d4,P3c0,P3ce,P3c2,P3cc;
+    ULONG   P3ca,P3c6,P3c7,P3c8,P3c9,P3da;
+    ULONG   Part0Port,Part1Port,Part2Port;
+    ULONG   Part3Port,Part4Port,Part5Port;
+    USHORT   RVBHCFACT,RVBHCMAX,RVBHRS;
+    USHORT   VGAVT,VGAHT,VGAVDE,VGAHDE;
+    USHORT   VT,HT,VDE,HDE;
+    USHORT   LCDHRS,LCDVRS,LCDHDES,LCDVDES;
+
+    USHORT   ModeType;
+    USHORT   IF_DEF_LVDS,IF_DEF_TRUMPION,IF_DEF_DSTN;/* ,IF_DEF_FSTN; add for dstn */
+    USHORT   IF_DEF_CRT2Monitor,IF_DEF_VideoCapture;
+    USHORT   IF_DEF_LCDA,IF_DEF_CH7017,IF_DEF_YPbPr,IF_DEF_ScaleLCD,IF_DEF_OEMUtil,IF_DEF_PWD;
+    USHORT   IF_DEF_ExpLink;
+    USHORT   IF_DEF_CH7005,IF_DEF_HiVision;
+    USHORT   IF_DEF_CH7007; /* Billy 2007/05/03 */
+    USHORT   LCDResInfo,LCDTypeInfo, VBType;/*301b*/
+    USHORT   VBInfo,TVInfo,LCDInfo, Set_VGAType;
+    USHORT   VBExtInfo;/*301lv*/
+    USHORT   SetFlag;
+    USHORT   NewFlickerMode;
+    USHORT   SelectCRT2Rate;
+
+    PUCHAR ROMAddr;
+    PUCHAR FBAddr;
+    ULONG BaseAddr;
+    ULONG RelIO;
+
+    DRAM4Type  *CR6B;
+    DRAM4Type  *CR6E;
+    DRAM32Type *CR6F;
+    DRAM2Type  *CR89;
+
+    DRAM8Type  *SR15; /* pointer : point to array */
+    DRAM8Type  *CR40;
+    UCHAR  *pSoftSetting;
+    UCHAR  *pOutputSelect;
+
+    USHORT *pRGBSenseData;
+    USHORT *pRGBSenseData2; /*301b*/
+    USHORT *pVideoSenseData;
+    USHORT *pVideoSenseData2;
+    USHORT *pYCSenseData;
+    USHORT *pYCSenseData2;
+
+    UCHAR  *pSR07;
+    UCHAR  *CR49;
+    UCHAR  *pSR1F;
+    UCHAR  *AGPReg;
+    UCHAR  *SR16;
+    UCHAR  *pSR21;
+    UCHAR  *pSR22;
+    UCHAR  *pSR23;
+    UCHAR  *pSR24;
+    UCHAR  *SR25;
+    UCHAR  *pSR31;
+    UCHAR  *pSR32;
+    UCHAR  *pSR33;
+    UCHAR  *pSR36;      /* alan 12/07/2006 */
+    UCHAR  *pCRCF;
+    UCHAR  *pCRD0;      /* alan 12/07/2006 */
+    UCHAR  *pCRDE;      /* alan 12/07/2006 */
+    UCHAR  *pCR8F;      /* alan 12/07/2006 */
+    UCHAR  *pSR40;      /* alan 12/07/2006 */
+    UCHAR  *pSR41;      /* alan 12/07/2006 */
+    UCHAR  *pDVOSetting;
+    UCHAR  *pCR2E;
+    UCHAR  *pCR2F;
+    UCHAR  *pCR46;
+    UCHAR  *pCR47;
+    UCHAR  *pCRT2Data_1_2;
+    UCHAR  *pCRT2Data_4_D;
+    UCHAR  *pCRT2Data_4_E;
+    UCHAR  *pCRT2Data_4_10;
+    XGI_MCLKDataStruct  *MCLKData;
+    XGI_ECLKDataStruct  *ECLKData;
+
+    UCHAR   *XGI_TVDelayList;
+    UCHAR   *XGI_TVDelayList2;
+    UCHAR   *CHTVVCLKUNTSC;
+    UCHAR   *CHTVVCLKONTSC;
+    UCHAR   *CHTVVCLKUPAL;
+    UCHAR   *CHTVVCLKOPAL;
+    UCHAR   *NTSCTiming;
+    UCHAR   *PALTiming;
+    UCHAR   *HiTVExtTiming;
+    UCHAR   *HiTVSt1Timing;
+    UCHAR   *HiTVSt2Timing;
+    UCHAR   *HiTVTextTiming;
+    UCHAR   *YPbPr750pTiming;
+    UCHAR   *YPbPr525pTiming;
+    UCHAR   *YPbPr525iTiming;
+    UCHAR   *HiTVGroup3Data;
+    UCHAR   *HiTVGroup3Simu;
+    UCHAR   *HiTVGroup3Text;
+    UCHAR   *Ren525pGroup3;
+    UCHAR   *Ren750pGroup3;
+    UCHAR   *ScreenOffset;
+    UCHAR   *pXGINew_DRAMTypeDefinition;
+    UCHAR   *pXGINew_I2CDefinition ;
+    UCHAR   *pXGINew_CR97 ;
+
+    XGI330_LCDCapStruct  *LCDCapList;
+    XGI21_LVDSCapStruct  *XG21_LVDSCapList;
+
+    XGI_TimingHStruct  *TimingH;
+    XGI_TimingVStruct  *TimingV;
+
+    XGI_StStruct          *SModeIDTable;
+    XGI_StandTableStruct  *StandTable;
+    XGI_ExtStruct         *EModeIDTable;
+    XGI_Ext2Struct        *RefIndex;
+    /* XGINew_CRT1TableStruct *CRT1Table; */
+    XGI_CRT1TableStruct    *XGINEWUB_CRT1Table;
+    XGI_VCLKDataStruct    *VCLKData;
+    XGI_VBVCLKDataStruct  *VBVCLKData;
+    XGI_StResInfoStruct   *StResInfo;
+    XGI_ModeResInfoStruct *ModeResInfo;
+    XGI_XG21CRT1Struct	  *UpdateCRT1;
+};  /* _VB_DEVICE_INFO */
+
+
+typedef struct
+{
+    USHORT    Horizontal_ACTIVE;
+    USHORT    Horizontal_FP;
+    USHORT    Horizontal_SYNC;
+    USHORT    Horizontal_BP;
+    USHORT    Vertical_ACTIVE;
+    USHORT    Vertical_FP;
+    USHORT    Vertical_SYNC;
+    USHORT    Vertical_BP;
+    double    DCLK;
+    UCHAR     FrameRate;
+    UCHAR     Interlace;
+    USHORT    Margin;
+} TimingInfo;
+
+#define _VB_STRUCT_
+#endif /* _VB_STRUCT_ */
--- /dev/null
+++ b/drivers/staging/xgifb/vb_table.h
@@ -0,0 +1,4406 @@
+#define  Tap4
+
+
+XGI_MCLKDataStruct XGI330New_MCLKData[]=
+{
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166},
+ { 0x7C,0x08,0x80,200},
+ { 0x79,0x06,0x80,250},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300}
+};
+//yilin modify for xgi20
+XGI_MCLKDataStruct XGI340New_MCLKData[]=
+{
+ { 0x16,0x01,0x01,166},
+ { 0x19,0x02,0x01,124},
+ { 0x7C,0x08,0x01,200},
+ { 0x79,0x06,0x01,250},
+ { 0x29,0x01,0x81,301},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166}
+};
+
+XGI_MCLKDataStruct XGI27New_MCLKData[]=
+{
+ { 0x5c,0x23,0x01,166},
+ { 0x19,0x02,0x01,124},
+ { 0x7C,0x08,0x80,200},
+ { 0x79,0x06,0x80,250},
+ { 0x29,0x01,0x81,300},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166}
+};
+
+XGI_ECLKDataStruct XGI330_ECLKData[]=
+{
+ { 0x7c,0x08,0x01,200},
+ { 0x7c,0x08,0x01,200},
+ { 0x7C,0x08,0x80,200},
+ { 0x79,0x06,0x80,250},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300},
+ { 0x29,0x01,0x81,300}
+};
+//yilin modify for xgi20
+XGI_ECLKDataStruct XGI340_ECLKData[]=
+{
+ { 0x5c,0x23,0x01,166},
+ { 0x55,0x84,0x01,123},
+ { 0x7C,0x08,0x01,200},
+ { 0x79,0x06,0x01,250},
+ { 0x29,0x01,0x81,301},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166},
+ { 0x5c,0x23,0x01,166}
+};
+
+
+
+UCHAR XGI340_SR13[4][8]={
+{0x35,0x45,0xb1,0x00,0x00,0x00,0x00,0x00},/* SR13 */
+{0x41,0x51,0x5c,0x00,0x00,0x00,0x00,0x00},/* SR14 */
+{0x31,0x42,0x42,0x00,0x00,0x00,0x00,0x00},/* SR18 */
+{0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00}/* SR1B */
+};
+
+UCHAR XGI340_cr41[24][8]=
+{{0x20,0x50,0x60,0x00,0x00,0x00,0x00,0x00},/* 0 CR41 */
+{0xc4,0x40,0x84,0x00,0x00,0x00,0x00,0x00},/* 1 CR8A */
+{0xc4,0x40,0x84,0x00,0x00,0x00,0x00,0x00},/* 2 CR8B */
+{0xb5,0xa4,0xa4,0x00,0x00,0x00,0x00,0x00},
+{0xf0,0xf0,0xf0,0x00,0x00,0x00,0x00,0x00},
+{0x90,0x90,0x24,0x00,0x00,0x00,0x00,0x00},/* 5 CR68 */
+{0x77,0x77,0x44,0x00,0x00,0x00,0x00,0x00},/* 6 CR69 */
+{0x77,0x77,0x44,0x00,0x00,0x00,0x00,0x00},/* 7 CR6A */
+{0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00},/* 8 CR6D */
+{0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x00},/* 9 CR80 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/* 10 CR81 */
+{0x88,0xa8,0x48,0x00,0x00,0x00,0x00,0x00},/* 11 CR82 */
+{0x44,0x44,0x77,0x00,0x00,0x00,0x00,0x00},/* 12 CR85 */
+{0x48,0x48,0x88,0x00,0x00,0x00,0x00,0x00},/* 13 CR86 */
+{0x54,0x54,0x44,0x00,0x00,0x00,0x00,0x00},/* 14 CR90 */
+{0x54,0x54,0x44,0x00,0x00,0x00,0x00,0x00},/* 15 CR91 */
+{0x0a,0x0a,0x07,0x00,0x00,0x00,0x00,0x00},/* 16 CR92 */
+{0x44,0x44,0x44,0x00,0x00,0x00,0x00,0x00},/* 17 CR93 */
+{0x10,0x10,0x0A,0x00,0x00,0x00,0x00,0x00},/* 18 CR94 */
+{0x11,0x11,0x0a,0x00,0x00,0x00,0x00,0x00},/* 19 CR95 */
+{0x05,0x05,0x05,0x00,0x00,0x00,0x00,0x00},/* 20 CR96 */
+{0xf0,0xf0,0xf0,0x00,0x00,0x00,0x00,0x00},/* 21 CRC3 */
+{0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00},/* 22 CRC4 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}/* 23 CRC5 */
+};
+
+
+UCHAR XGI27_cr41[24][8]=
+{
+{0x20,0x40,0x60,0x00,0x00,0x00,0x00,0x00},/* 0 CR41 */
+{0xC4,0x40,0x84,0x00,0x00,0x00,0x00,0x00},/* 1 CR8A */
+{0xC4,0x40,0x84,0x00,0x00,0x00,0x00,0x00},/* 2 CR8B */
+{0xB5,0x13,0xa4,0x00,0x00,0x00,0x00,0x00},/* 3 CR40[7],CR99[2:0],CR45[3:0]*/
+{0xf0,0xf5,0xf0,0x00,0x00,0x00,0x00,0x00},/* 4 CR59 */
+{0x90,0x90,0x24,0x00,0x00,0x00,0x00,0x00},/* 5 CR68 */
+{0x77,0x67,0x44,0x00,0x00,0x00,0x00,0x00},/* 6 CR69 */
+{0x77,0x77,0x44,0x00,0x00,0x00,0x00,0x00},/* 7 CR6A */
+{0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00},/* 8 CR6D */
+{0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x00},/* 9 CR80 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/* 10 CR81 */
+{0x88,0xcc,0x48,0x00,0x00,0x00,0x00,0x00},/* 11 CR82 */
+{0x44,0x88,0x77,0x00,0x00,0x00,0x00,0x00},/* 12 CR85 */
+{0x48,0x88,0x88,0x00,0x00,0x00,0x00,0x00},/* 13 CR86 */
+{0x54,0x32,0x44,0x00,0x00,0x00,0x00,0x00},/* 14 CR90 */
+{0x54,0x33,0x44,0x00,0x00,0x00,0x00,0x00},/* 15 CR91 */
+{0x0a,0x07,0x07,0x00,0x00,0x00,0x00,0x00},/* 16 CR92 */
+{0x44,0x63,0x44,0x00,0x00,0x00,0x00,0x00},/* 17 CR93 */
+{0x10,0x14,0x0A,0x00,0x00,0x00,0x00,0x00},/* 18 CR94 */
+{0x11,0x0B,0x0C,0x00,0x00,0x00,0x00,0x00},/* 19 CR95 */
+{0x05,0x22,0x05,0x00,0x00,0x00,0x00,0x00},/* 20 CR96 */
+{0xf0,0xf0,0x00,0x00,0x00,0x00,0x00,0x00},/* 21 CRC3 */
+{0x05,0x00,0x02,0x00,0x00,0x00,0x00,0x00},/* 22 CRC4 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}/* 23 CRC5 */
+};
+
+
+#if 0
+UCHAR XGI27_cr41[24][8]=
+{
+{0x20,0x60,0x60,0x00,0x00,0x00,0x00,0x00},/* 0 CR41 */
+{0x04,0x44,0x84,0x00,0x00,0x00,0x00,0x00},/* 1 CR8A */
+{0x04,0x40,0x84,0x00,0x00,0x00,0x00,0x00},/* 2 CR8B */
+{0xb5,0x03,0xa4,0x00,0x00,0x00,0x00,0x00},/* 3 CR40[7],CR99[2:0],CR45[3:0]*/
+{0xf0,0xf5,0xf0,0x00,0x00,0x00,0x00,0x00},/* 4 CR59 */
+{0xa4,0x1C,0x24,0x00,0x00,0x00,0x00,0x00},/* 5 CR68 */
+{0x77,0x77,0x44,0x00,0x00,0x00,0x00,0x00},/* 6 CR69 */
+{0x77,0x77,0x44,0x00,0x00,0x00,0x00,0x00},/* 7 CR6A */
+{0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00},/* 8 CR6D */
+{0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x00},/* 9 CR80 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/* 10 CR81 */
+{0x48,0xa8,0x48,0x00,0x00,0x00,0x00,0x00},/* 11 CR82 */
+{0x77,0x88,0x77,0x00,0x00,0x00,0x00,0x00},/* 12 CR85 */
+{0x88,0x88,0x88,0x00,0x00,0x00,0x00,0x00},/* 13 CR86 */
+{0x44,0x32,0x44,0x00,0x00,0x00,0x00,0x00},/* 14 CR90 */
+{0x44,0x33,0x44,0x00,0x00,0x00,0x00,0x00},/* 15 CR91 */
+{0x07,0x07,0x07,0x00,0x00,0x00,0x00,0x00},/* 16 CR92 */
+{0x44,0x63,0x44,0x00,0x00,0x00,0x00,0x00},/* 17 CR93 */
+{0x0A,0x14,0x0A,0x00,0x00,0x00,0x00,0x00},/* 18 CR94 */
+{0x0C,0x0B,0x0C,0x00,0x00,0x00,0x00,0x00},/* 19 CR95 */
+{0x05,0x22,0x05,0x00,0x00,0x00,0x00,0x00},/* 20 CR96 */
+{0xf0,0xf0,0xf0,0x00,0x00,0x00,0x00,0x00},/* 21 CRC3 */
+{0x03,0x00,0x02,0x00,0x00,0x00,0x00,0x00},/* 22 CRC4 */
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}/* 23 CRC5 */
+};
+#endif
+UCHAR XGI340_CR6B[8][4]={
+{0xaa,0xaa,0xaa,0xaa},
+{0xaa,0xaa,0xaa,0xaa},
+{0xaa,0xaa,0xaa,0xaa},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00}
+};
+
+UCHAR XGI340_CR6E[8][4]={
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00}
+};
+
+UCHAR XGI340_CR6F[8][32]={
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
+};
+
+UCHAR XGI340_CR89[8][2]={
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00},
+{0x00,0x00}
+};
+			 /* CR47,CR48,CR49,CR4A,CR4B,CR4C,CR70,CR71,CR74,CR75,CR76,CR77 */
+UCHAR XGI340_AGPReg[12]={0x28,0x23,0x00,0x20,0x00,0x20,0x00,0x05,0xd0,0x10,0x10,0x00};
+
+UCHAR XGI340_SR16[4]={0x03,0x83,0x03,0x83};
+
+UCHAR XGI330_SR15_1[8][8]={
+{0x0,0x0,0x00,0x00,0x20,0x20,0x00,0x00},
+{0x5,0x15,0x15,0x15,0x15,0x15,0x00,0x00},
+{0xba,0xba,0xba,0xba,0xBA,0xBA,0x00,0x00},
+{0x55,0x57,0x57,0xAB,0xAB,0xAB,0x00,0x00},
+{0x60,0x34,0x34,0x34,0x34,0x34,0x00,0x00},
+{0x0,0x80,0x80,0x80,0x83,0x83,0x00,0x00},
+{0x50,0x50,0x50,0x3C,0x3C,0x3C,0x00,0x00},
+{0x0,0xa5,0xfb,0xf6,0xF6,0xF6,0x00,0x00}
+};
+
+UCHAR XGI330_cr40_1[15][8]={
+{0x66,0x40,0x40,0x28,0x24,0x24,0x00,0x00},
+{0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x0F,0x0F,0x00,0x00},
+{0x00,0xf0,0xf0,0xf0,0xF0,0xF0,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x10,0x10,0x10,0x10,0x20,0x20,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x88,0x88,0x88,0xAA,0xAC,0xAC,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x77,0x77,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0xA2,0x00,0x00,0xA2,0xA2,0x00,0x00},
+};
+
+UCHAR XGI330_sr25[]={0x00,0x0};
+UCHAR XGI330_sr31=0xc0;
+UCHAR XGI330_sr32=0x11;
+UCHAR XGI330_SR33=0x00;
+UCHAR XG40_CRCF=0x13;
+UCHAR XG40_DRAMTypeDefinition=0xFF ;
+
+XGI_StStruct XGI330_SModeIDTable[]=
+{
+ {0x01,0x9208,0x01,0x00,0x10,0x00,0x00,0x01,0x00},
+ {0x01,0x1210,0x14,0x01,0x00,0x01,0x00,0x01,0x00},
+ {0x01,0x1010,0x17,0x02,0x11,0x00,0x00,0x01,0x01},
+ {0x03,0x8208,0x03,0x00,0x14,0x00,0x00,0x01,0x02},
+ {0x03,0x0210,0x16,0x01,0x04,0x01,0x00,0x01,0x02},
+ {0x03,0x0010,0x18,0x02,0x15,0x00,0x00,0x01,0x03},
+ {0x05,0x9209,0x05,0x00,0x10,0x00,0x00,0x00,0x04},
+ {0x06,0x8209,0x06,0x00,0x14,0x00,0x00,0x00,0x05},
+ {0x07,0x0000,0x07,0x03,0x05,0x03,0x00,0x01,0x03},
+ {0x07,0x0000,0x19,0x02,0x15,0x02,0x00,0x01,0x03},
+ {0x0d,0x920a,0x0d,0x00,0x10,0x00,0x00,0x00,0x04},
+ {0x0e,0x820a,0x0e,0x00,0x14,0x00,0x00,0x00,0x05},
+ {0x0f,0x0202,0x11,0x01,0x04,0x01,0x00,0x00,0x05},
+ {0x10,0x0212,0x12,0x01,0x04,0x01,0x00,0x00,0x05},
+ {0x11,0x0212,0x1a,0x04,0x24,0x04,0x00,0x00,0x05},
+ {0x12,0x0212,0x1b,0x04,0x24,0x04,0x00,0x00,0x05},
+ {0x13,0x021b,0x1c,0x00,0x14,0x00,0x00,0x00,0x04},
+ {0x12,0x0010,0x18,0x02,0x24,0x02,0x00,0x00,0x05},/* St_CRT2CRTC2 not sure */
+ {0x12,0x0210,0x18,0x01,0x24,0x01,0x00,0x00,0x05},/* St_CRT2CRTC2 not sure */
+ {0xff,0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
+};
+
+
+XGI_ExtStruct  XGI330_EModeIDTable[]=
+{
+ {0x6a,0x2212,0x0407,0x3a81,0x0102,0x08,0x07,0x00,0x00,0x07,0x0e},
+ {0x2e,0x0a1b,0x0306,0x3a57,0x0101,0x08,0x06,0x00,0x00,0x05,0x06},
+ {0x2f,0x0a1b,0x0305,0x3a50,0x0100,0x08,0x05,0x00,0x00,0x05,0x05},
+ {0x30,0x2a1b,0x0407,0x3a81,0x0103,0x08,0x07,0x00,0x00,0x07,0x0e},
+ {0x31,0x0a1b,0x030d,0x3b85,0x0000,0x08,0x0d,0x00,0x00,0x06,0x3d},
+ {0x32,0x0a1b,0x0a0e,0x3b8c,0x0000,0x08,0x0e,0x00,0x00,0x06,0x3e},
+ {0x33,0x0a1d,0x0a0d,0x3b85,0x0000,0x08,0x0d,0x00,0x00,0x06,0x3d},
+ {0x34,0x2a1d,0x0a0e,0x3b8c,0x0000,0x08,0x0e,0x00,0x00,0x06,0x3e},
+ {0x35,0x0a1f,0x0a0d,0x3b85,0x0000,0x08,0x0d,0x00,0x00,0x06,0x3d},
+ {0x36,0x2a1f,0x0a0e,0x3b8c,0x0000,0x08,0x0e,0x00,0x00,0x06,0x3e},
+ {0x37,0x0212,0x0508,0x3aab,0x0104,0x08,0x08,0x00,0x00,0x00,0x16},
+ {0x38,0x0a1b,0x0508,0x3aab,0x0105,0x08,0x08,0x00,0x00,0x00,0x16},
+ {0x3a,0x0e3b,0x0609,0x3adc,0x0107,0x08,0x09,0x00,0x00,0x00,0x1e},
+ {0x3c,0x0e3b,0x070a,0x3af2,0x0130,0x08,0x0a,0x00,0x00,0x00,0x22},	/* mode 1600x1200 add CRT2MODE [2003/10/07] */
+ {0x3d,0x0e7d,0x070a,0x3af2,0x0131,0x08,0x0a,0x00,0x00,0x00,0x22},	/* mode 1600x1200 add CRT2MODE */
+ {0x40,0x9a1c,0x0000,0x3a34,0x010d,0x08,0x00,0x00,0x00,0x04,0x00},
+ {0x41,0x9a1d,0x0000,0x3a34,0x010e,0x08,0x00,0x00,0x00,0x04,0x00},	/* ModeIdIndex = 0x10 */
+ {0x43,0x0a1c,0x0306,0x3a57,0x0110,0x08,0x06,0x00,0x00,0x05,0x06},
+ {0x44,0x0a1d,0x0306,0x3a57,0x0111,0x08,0x06,0x00,0x00,0x05,0x06},
+ {0x46,0x2a1c,0x0407,0x3a81,0x0113,0x08,0x07,0x00,0x00,0x07,0x0e},
+ {0x47,0x2a1d,0x0407,0x3a81,0x0114,0x08,0x07,0x00,0x00,0x07,0x0e},
+ {0x49,0x0a3c,0x0508,0x3aab,0x0116,0x08,0x08,0x00,0x00,0x00,0x16},
+ {0x4a,0x0a3d,0x0508,0x3aab,0x0117,0x08,0x08,0x00,0x00,0x00,0x16},
+ {0x4c,0x0e7c,0x0609,0x3adc,0x0119,0x08,0x09,0x00,0x00,0x00,0x1e},
+ {0x4d,0x0e7d,0x0609,0x3adc,0x011a,0x08,0x09,0x00,0x00,0x00,0x1e},
+ {0x50,0x9a1b,0x0001,0x3a3b,0x0132,0x08,0x01,0x00,0x00,0x04,0x02},
+ {0x51,0xba1b,0x0103,0x3a42,0x0133,0x08,0x03,0x00,0x00,0x07,0x03},
+ {0x52,0x9a1b,0x0204,0x3a49,0x0134,0x08,0x04,0x00,0x00,0x00,0x04},
+ {0x56,0x9a1d,0x0001,0x3a3b,0x0135,0x08,0x01,0x00,0x00,0x04,0x02},
+ {0x57,0xba1d,0x0103,0x3a42,0x0136,0x08,0x03,0x00,0x00,0x07,0x03},
+ {0x58,0x9a1d,0x0204,0x3a49,0x0137,0x08,0x04,0x00,0x00,0x00,0x04},
+ {0x59,0x9a1b,0x0000,0x3a34,0x0138,0x08,0x00,0x00,0x00,0x04,0x00},
+ {0x5A,0x021b,0x0014,0x3b83,0x0138,0x08,0x01,0x00,0x00,0x04,0x3f},	/* ModeIdIndex = 0x20 */
+ {0x5B,0x0a1d,0x0014,0x3b83,0x0135,0x08,0x01,0x00,0x00,0x04,0x3f},
+ {0x5d,0x0a1d,0x0305,0x3a50,0x0139,0x08,0x05,0x00,0x00,0x07,0x05},
+ {0x62,0x0a3f,0x0306,0x3a57,0x013a,0x08,0x06,0x00,0x00,0x05,0x06},
+ {0x63,0x2a3f,0x0407,0x3a81,0x013b,0x08,0x07,0x00,0x00,0x07,0x0e},
+ {0x64,0x0a7f,0x0508,0x3aab,0x013c,0x08,0x08,0x00,0x00,0x00,0x16},
+ {0x65,0x0eff,0x0609,0x3adc,0x013d,0x08,0x09,0x00,0x00,0x00,0x1e},
+ {0x66,0x0eff,0x070a,0x3af2,0x013e,0x08,0x0a,0x00,0x00,0x00,0x22},	/* mode 1600x1200 add CRT2MODE */
+ {0x68,0x067b,0x080b,0x3b17,0x013f,0x08,0x0b,0x00,0x00,0x00,0x29},
+ {0x69,0x06fd,0x080b,0x3b17,0x0140,0x08,0x0b,0x00,0x00,0x00,0x29},
+ {0x6b,0x07ff,0x080b,0x3b17,0x0141,0x10,0x0b,0x00,0x00,0x00,0x29},
+ {0x6c,0x067b,0x090c,0x3b37,0x0000,0x08,0x0c,0x00,0x00,0x00,0x2f},
+ {0x6d,0x06fd,0x090c,0x3b37,0x0000,0x10,0x0c,0x00,0x00,0x00,0x2f},
+ {0x6e,0x07ff,0x090c,0x3b37,0x0000,0x10,0x0c,0x00,0x00,0x00,0x2f},
+ {0x70,0x2a1b,0x0410,0x3b52,0x0000,0x08,0x10,0x00,0x00,0x07,0x34},
+ {0x71,0x0a1b,0x0511,0x3b63,0x0000,0x08,0x11,0x00,0x00,0x00,0x37},
+ {0x74,0x0a1d,0x0511,0x3b63,0x0000,0x08,0x11,0x00,0x00,0x00,0x37},	/* ModeIdIndex = 0x30 */
+ {0x75,0x0a3d,0x0612,0x3b74,0x0000,0x08,0x12,0x00,0x00,0x00,0x3a},
+ {0x76,0x2a1f,0x0410,0x3b52,0x0000,0x08,0x10,0x00,0x00,0x07,0x34},
+ {0x77,0x0a1f,0x0511,0x3b63,0x0000,0x08,0x11,0x00,0x00,0x00,0x37},
+ {0x78,0x0a3f,0x0612,0x3b74,0x0000,0x08,0x12,0x00,0x00,0x00,0x3a},
+ {0x79,0x0a3b,0x0612,0x3b74,0x0000,0x08,0x12,0x00,0x00,0x00,0x3a},
+ {0x7a,0x2a1d,0x0410,0x3b52,0x0000,0x08,0x10,0x00,0x00,0x07,0x34},
+ {0x7b,0x0e3b,0x060f,0x3ad0,0x0000,0x08,0x0f,0x00,0x00,0x00,0x1d},
+ {0x7c,0x0e7d,0x060f,0x3ad0,0x0000,0x08,0x0f,0x00,0x00,0x00,0x1d},
+ {0x7d,0x0eff,0x060f,0x3ad0,0x0000,0x08,0x0f,0x00,0x00,0x00,0x1d},
+ {0x20,0x0e3b,0x0D16,0x49e0,0x0000,0x08,0x16,0x00,0x00,0x00,0x43},
+ {0x21,0x0e7d,0x0D16,0x49e0,0x0000,0x08,0x16,0x00,0x00,0x00,0x43},
+ {0x22,0x0eff,0x0D16,0x49e0,0x0000,0x08,0x16,0x00,0x00,0x00,0x43},
+ {0x23,0x0e3b,0x0614,0x49d5,0x0000,0x08,0x14,0x00,0x00,0x00,0x41},
+ {0x24,0x0e7d,0x0614,0x49d5,0x0000,0x08,0x14,0x00,0x00,0x00,0x41},
+ {0x25,0x0eff,0x0614,0x49d5,0x0000,0x08,0x14,0x00,0x00,0x00,0x41},
+ {0x26,0x063b,0x0c15,0x49dc,0x0000,0x08,0x15,0x00,0x00,0x00,0x42},	/* ModeIdIndex = 0x40 */
+ {0x27,0x067d,0x0c15,0x49dc,0x0000,0x08,0x15,0x00,0x00,0x00,0x42},
+ {0x28,0x06ff,0x0c15,0x49dc,0x0000,0x08,0x15,0x00,0x00,0x00,0x42},
+ {0xff,0x0000,0x0000,0x0000,0x0000,0x00,0x00,0x00,0x00,0x00,0x00}
+};
+
+XGI_StandTableStruct XGI330_StandTable[]=
+{
+/* MD_0_200 */
+ {
+  0x28,0x18,0x08,0x0800,
+  {0x09,0x03,0x00,0x02},
+  0x63,
+  {0x2d,0x27,0x28,0x90,0x2b,0xa0,0xbf,0x1f,
+   0x00,0xc7,0x06,0x07,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_1_200 */
+ {
+  0x28,0x18,0x08,0x0800,
+  {0x09,0x03,0x00,0x02},
+  0x63,
+  {0x2d,0x27,0x28,0x90,0x2b,0xa0,0xbf,0x1f,
+   0x00,0xc7,0x06,0x07,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_2_200 */
+ {
+  0x50,0x18,0x08,0x1000,
+  {0x01,0x03,0x00,0x02},
+  0x63,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0xc7,0x06,0x07,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_3_200 */
+ {
+  0x50,0x18,0x08,0x1000,
+  {0x01,0x03,0x00,0x02},
+  0x63,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0xc7,0x06,0x07,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_4 */
+ {
+  0x28,0x18,0x08,0x4000,
+  {0x09,0x03,0x00,0x02},
+  0x63,
+  {0x2d,0x27,0x28,0x90,0x2c,0x80,0xbf,0x1f,
+   0x00,0xc1,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x00,0x96,0xb9,0xa2,
+   0xff},
+  {0x00,0x13,0x15,0x17,0x02,0x04,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x01,0x00,0x03,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x30,0x0f,0x00,
+   0xff}
+ },
+/* MD_5 */
+ {
+  0x28,0x18,0x08,0x4000,
+  {0x09,0x03,0x00,0x02},
+  0x63,
+  {0x2d,0x27,0x28,0x90,0x2c,0x80,0xbf,0x1f,
+   0x00,0xc1,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x00,0x96,0xb9,0xa2,
+   0xff},
+  {0x00,0x13,0x15,0x17,0x02,0x04,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x01,0x00,0x03,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x30,0x0f,0x00,
+   0xff}
+ },
+/* MD_6 */
+ {
+  0x50,0x18,0x08,0x4000,
+  {0x01,0x01,0x00,0x06},
+  0x63,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0xc1,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x00,0x96,0xb9,0xc2,
+   0xff},
+  {0x00,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
+   0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
+   0x01,0x00,0x01,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x0d,0x00,
+   0xff}
+ },
+/* MD_7 */
+ {
+  0x50,0x18,0x0e,0x1000,
+  {0x00,0x03,0x00,0x03},
+  0xa6,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x4d,0x0b,0x0c,0x00,0x00,0x00,0x00,
+   0x83,0x85,0x5d,0x28,0x0d,0x63,0xba,0xa3,
+   0xff},
+  {0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
+   0x10,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+   0x0e,0x00,0x0f,0x08},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0a,0x00,
+   0xff}
+ },
+/* MDA_DAC */
+ {
+  0x00,0x00,0x00,0x0000,
+  {0x00,0x00,0x00,0x15},
+  0x15,
+  {0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+   0x15,0x15,0x15,0x15,0x15,0x15,0x3f,0x3f,
+   0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x00,0x00,
+   0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x15,0x15,0x15,
+   0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
+   0x15,0x15,0x15,0x15},
+  {0x15,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
+   0x3f}
+ },
+/* CGA_DAC */
+ {
+  0x00,0x10,0x04,0x0114,
+  {0x11,0x09,0x15,0x00},
+  0x10,
+  {0x04,0x14,0x01,0x11,0x09,0x15,0x2a,0x3a,
+   0x2e,0x3e,0x2b,0x3b,0x2f,0x3f,0x2a,0x3a,
+   0x2e,0x3e,0x2b,0x3b,0x2f,0x3f,0x00,0x10,
+   0x04},
+  {0x14,0x01,0x11,0x09,0x15,0x00,0x10,0x04,
+   0x14,0x01,0x11,0x09,0x15,0x2a,0x3a,0x2e,
+   0x3e,0x2b,0x3b,0x2f},
+  {0x3f,0x2a,0x3a,0x2e,0x3e,0x2b,0x3b,0x2f,
+   0x3f}
+ },
+/* EGA_DAC */
+ {
+  0x00,0x10,0x04,0x0114,
+  {0x11,0x05,0x15,0x20},
+  0x30,
+  {0x24,0x34,0x21,0x31,0x25,0x35,0x08,0x18,
+   0x0c,0x1c,0x09,0x19,0x0d,0x1d,0x28,0x38,
+   0x2c,0x3c,0x29,0x39,0x2d,0x3d,0x02,0x12,
+   0x06},
+  {0x16,0x03,0x13,0x07,0x17,0x22,0x32,0x26,
+   0x36,0x23,0x33,0x27,0x37,0x0a,0x1a,0x0e,
+   0x1e,0x0b,0x1b,0x0f},
+  {0x1f,0x2a,0x3a,0x2e,0x3e,0x2b,0x3b,0x2f,
+   0x3f}
+ },
+/* VGA_DAC */
+ {
+  0x00,0x10,0x04,0x0114,
+  {0x11,0x09,0x15,0x2a},
+  0x3a,
+  {0x2e,0x3e,0x2b,0x3b,0x2f,0x3f,0x00,0x05,
+   0x08,0x0b,0x0e,0x11,0x14,0x18,0x1c,0x20,
+   0x24,0x28,0x2d,0x32,0x38,0x3f,0x00,0x10,
+   0x1f},
+  {0x2f,0x3f,0x1f,0x27,0x2f,0x37,0x3f,0x2d,
+   0x31,0x36,0x3a,0x3f,0x00,0x07,0x0e,0x15,
+   0x1c,0x0e,0x11,0x15},
+  {0x18,0x1c,0x14,0x16,0x18,0x1a,0x1c,0x00,
+   0x04}
+ },
+ {
+  0x08,0x0c,0x10,0x0a08,
+  {0x0c,0x0e,0x10,0x0b},
+  0x0c,
+  {0x0d,0x0f,0x10,0x10,0x01,0x08,0x00,0x00,
+   0x00,0x00,0x01,0x00,0x02,0x02,0x01,0x00,
+   0x04,0x04,0x01,0x00,0x05,0x02,0x05,0x00,
+   0x06},
+  {0x01,0x06,0x05,0x06,0x00,0x08,0x01,0x08,
+   0x00,0x07,0x02,0x07,0x06,0x07,0x00,0x00,
+   0x00,0x00,0x00,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x00}
+ },
+/* MD_D */
+ {
+  0x28,0x18,0x08,0x2000,
+  {0x09,0x0f,0x00,0x06},
+  0x63,
+  {0x2d,0x27,0x28,0x90,0x2c,0x80,0xbf,0x1f,
+   0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x00,0x96,0xb9,0xe3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x01,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0f,
+   0xff}
+ },
+/* MD_E */
+ {
+  0x50,0x18,0x08,0x4000,
+  {0x01,0x0f,0x00,0x06},
+  0x63,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x00,0x96,0xb9,0xe3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
+   0x01,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0f,
+   0xff}
+ },
+/* ExtVGATable */
+ {
+  0x00,0x00,0x00,0x0000,
+  {0x01,0x0f,0x00,0x0e},
+  0x23,
+  {0x5f,0x4f,0x50,0x82,0x54,0x80,0x0b,0x3e,
+   0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
+   0xea,0x8c,0xdf,0x28,0x40,0xe7,0x04,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
+   0x01,0x00,0x00,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,
+   0xff}
+ },
+/* ROM_SAVEPTR */
+ {
+  0x9f,0x3b,0x00,0x00c0,
+  {0x00,0x00,0x00,0x00},
+  0x00,
+  {0x00,0x00,0x00,0x00,0x00,0x00,0xbb,0x3f,
+   0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x00,0x00,0x1a,0x00,0xac,0x3e,0x00,0xc0,
+   0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x00,0x00,0x00,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x00}
+ },
+/* MD_F */
+ {
+  0x50,0x18,0x0e,0x8000,
+  {0x01,0x0f,0x00,0x06},
+  0xa2,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x82,0x84,0x5d,0x28,0x0f,0x63,0xba,0xe3,
+   0xff},
+  {0x00,0x08,0x00,0x00,0x18,0x18,0x00,0x00,
+   0x00,0x08,0x00,0x00,0x00,0x18,0x00,0x00,
+   0x0b,0x00,0x05,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x05,
+   0xff}
+ },
+/* MD_10 */
+ {
+  0x50,0x18,0x0e,0x8000,
+  {0x01,0x0f,0x00,0x06},
+  0xa3,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x82,0x84,0x5d,0x28,0x0f,0x63,0xba,0xe3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x01,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0f,
+   0xff}
+ },
+/* MD_0_350 */
+ {
+  0x28,0x18,0x0e,0x0800,
+  {0x09,0x03,0x00,0x02},
+  0xa3,
+  {0x2d,0x27,0x28,0x90,0x2b,0xb1,0xbf,0x1f,
+   0x00,0x4d,0x0b,0x0c,0x00,0x00,0x00,0x00,
+   0x83,0x85,0x5d,0x14,0x1f,0x63,0xba,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_1_350 */
+ {
+  0x28,0x18,0x0e,0x0800,
+  {0x09,0x03,0x00,0x02},
+  0xa3,
+  {0x2d,0x27,0x28,0x90,0x2b,0xa0,0xbf,0x1f,
+   0x00,0x4d,0x0b,0x0c,0x00,0x00,0x00,0x00,
+   0x83,0x85,0x5d,0x14,0x1f,0x63,0xba,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_2_350 */
+ {
+  0x50,0x18,0x0e,0x1000,
+  {0x01,0x03,0x00,0x02},
+  0xa3,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x4d,0x0b,0x0c,0x00,0x00,0x00,0x00,
+   0x83,0x85,0x5d,0x28,0x1f,0x63,0xba,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_3_350 */
+ {
+  0x50,0x18,0x0e,0x1000,
+  {0x01,0x03,0x00,0x02},
+  0xa3,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x4d,0x0b,0x0c,0x00,0x00,0x00,0x00,
+   0x83,0x85,0x5d,0x28,0x1f,0x63,0xba,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x08,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_0_1_400 */
+ {
+  0x28,0x18,0x10,0x0800,
+  {0x08,0x03,0x00,0x02},
+  0x67,
+  {0x2d,0x27,0x28,0x90,0x2b,0xb1,0xbf,0x1f,
+   0x00,0x4f,0x0d,0x0e,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x14,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x0c,0x00,0x0f,0x08},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_2_3_400 */
+ {
+  0x50,0x18,0x10,0x1000,
+  {0x00,0x03,0x00,0x02},
+  0x67,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x4f,0x0d,0x0e,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x0c,0x00,0x0f,0x08},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,
+   0xff}
+ },
+/* MD_7_400 */
+ {
+  0x50,0x18,0x10,0x1000,
+  {0x00,0x03,0x00,0x02},
+  0x66,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x4f,0x0d,0x0e,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x0f,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
+   0x10,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+   0x0e,0x00,0x0f,0x08},
+  {0x00,0x00,0x00,0x00,0x00,0x10,0x0a,0x00,
+   0xff}
+ },
+/* MD_11 */
+ {
+  0x50,0x1d,0x10,0xa000,
+  {0x01,0x0f,0x00,0x06},
+  0xe3,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0x0b,0x3e,
+   0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
+   0xe9,0x8b,0xdf,0x28,0x00,0xe7,0x04,0xc3,
+   0xff},
+  {0x00,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
+   0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
+   0x01,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x01,
+   0xff}
+ },
+/* ExtEGATable */
+ {
+  0x50,0x1d,0x10,0xa000,
+  {0x01,0x0f,0x00,0x06},
+  0xe3,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0x0b,0x3e,
+   0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
+   0xe9,0x8b,0xdf,0x28,0x00,0xe7,0x04,0xe3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x14,0x07,
+   0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
+   0x01,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0f,
+   0xff}
+ },
+/* MD_13 */
+ {
+  0x28,0x18,0x08,0x2000,
+  {0x01,0x0f,0x00,0x0e},
+  0x63,
+  {0x5f,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,
+   0x00,0x41,0x00,0x00,0x00,0x00,0x00,0x00,
+   0x9c,0x8e,0x8f,0x28,0x40,0x96,0xb9,0xa3,
+   0xff},
+  {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
+   0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
+   0x41,0x00,0x0f,0x00},
+  {0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0f,
+   0xff}
+ }
+};
+
+XGI_TimingHStruct XGI_TimingH[]=
+{{{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}}};
+
+XGI_TimingVStruct XGI_TimingV[]=
+{{{0x00,0x00,0x00,0x00,0x00,0x00,0x00}}};
+
+XGI_XG21CRT1Struct XGI_UpdateCRT1Table[]=
+{
+ {0x01,0x27,0x91,0x8f,0xc0},	/* 00 */
+ {0x03,0x4f,0x83,0x8f,0xc0},	/* 01 */
+ {0x05,0x27,0x91,0x8f,0xc0},	/* 02 */
+ {0x06,0x4f,0x83,0x8f,0xc0},	/* 03 */
+ {0x07,0x4f,0x83,0x8f,0xc0},	/* 04 */
+ {0x0d,0x27,0x91,0x8f,0xc0},	/* 05 */
+ {0x0e,0x4f,0x83,0x8f,0xc0},	/* 06 */
+ {0x0f,0x4f,0x83,0x5d,0xc0},	/* 07 */
+ {0x10,0x4f,0x83,0x5d,0xc0},	/* 08 */
+ {0x11,0x4f,0x83,0xdf,0x0c},	/* 09 */
+ {0x12,0x4f,0x83,0xdf,0x0c},	/* 10 */
+ {0x13,0x4f,0x83,0x8f,0xc0},	/* 11 */
+ {0x2e,0x4f,0x83,0xdf,0x0c},	/* 12 */
+ {0x2e,0x4f,0x87,0xdf,0xc0},	/* 13 */
+ {0x2f,0x4f,0x83,0x8f,0xc0},	/* 14 */
+ {0x50,0x27,0x91,0xdf,0x0c},	/* 15 */
+ {0x59,0x27,0x91,0x8f,0xc0}	/* 16 */
+};
+
+XGI_CRT1TableStruct XGI_CRT1Table[]=
+{
+ {{0x2d,0x28,0x90,0x2c,0x90,0x00,0x04,0x00,
+    0xbf,0x1f,0x9c,0x8e,0x96,0xb9,0x30}}, /* 0x0 */
+ {{0x2d,0x28,0x90,0x2c,0x90,0x00,0x04,0x00,
+    0x0b,0x3e,0xe9,0x8b,0xe7,0x04,0x00}}, /* 0x1 */
+ {{0x3D,0x31,0x81,0x37,0x1F,0x00,0x05,0x00,
+    0x72,0xF0,0x58,0x8C,0x57,0x73,0xA0}}, /* 0x2 */
+ {{0x4F,0x3F,0x93,0x45,0x0D,0x00,0x01,0x00,
+    0x24,0xF5,0x02,0x88,0xFF,0x25,0x90}}, /* 0x3 */
+ {{0x5F,0x50,0x82,0x55,0x81,0x00,0x05,0x00,
+    0xBF,0x1F,0x9C,0x8E,0x96,0xB9,0x30}}, /* 0x4 */
+ {{0x5F,0x50,0x82,0x55,0x81,0x00,0x05,0x00,
+    0x0B,0x3E,0xE9,0x8B,0xE7,0x04,0x00}}, /* 0x5 */
+ {{0x63,0x50,0x86,0x56,0x9B,0x00,0x01,0x00,
+    0x06,0x3E,0xE8,0x8B,0xE7,0xFF,0x10}}, /* 0x6 */
+ {{0x64,0x4F,0x88,0x55,0x9D,0x00,0x01,0x00,
+    0xF2,0x1F,0xE0,0x83,0xDF,0xF3,0x10}}, /* 0x7 */
+ {{0x63,0x4F,0x87,0x5A,0x81,0x00,0x05,0x00,
+    0xFB,0x1F,0xE0,0x83,0xDF,0xFC,0x10}}, /* 0x8 */
+ {{0x65,0x4F,0x89,0x58,0x80,0x00,0x05,0x60,
+    0xFB,0x1F,0xE0,0x83,0xDF,0xFC,0x80}}, /* 0x9 */
+ {{0x65,0x4F,0x89,0x58,0x80,0x00,0x05,0x60,
+    0x01,0x3E,0xE0,0x83,0xDF,0x02,0x80}}, /* 0xa */
+ {{0x67,0x4F,0x8B,0x58,0x81,0x00,0x05,0x60,
+    0x0D,0x3E,0xE0,0x83,0xDF,0x0E,0x90}}, /* 0xb */
+ {{0x65,0x4F,0x89,0x57,0x9F,0x00,0x01,0x00,
+   0xFB,0x1F,0xE6,0x8A,0xDF,0xFC,0x10}}, /* 0xc */
+ {{0x7B,0x63,0x9F,0x6A,0x93,0x00,0x05,0x00,    /* ; 0D (800x600,56Hz) */
+    0x6F,0xF0,0x58,0x8A,0x57,0x70,0xA0}},         /* ; (VCLK 36.0MHz) */
+ {{0x7F,0x63,0x83,0x6C,0x1C,0x00,0x06,0x00,    /* ; 0E (800x600,60Hz) */
+    0x72,0xF0,0x58,0x8C,0x57,0x73,0xA0}},         /* ; (VCLK 40.0MHz) */
+ {{0x7D,0x63,0x81,0x6E,0x1D,0x00,0x06,0x00,    /* ; 0F (800x600,72Hz) */
+    0x98,0xF0,0x7C,0x82,0x57,0x99,0x80}},         /* ; (VCLK 50.0MHz) */
+ {{0x7F,0x63,0x83,0x69,0x13,0x00,0x06,0x00,    /* ; 10 (800x600,75Hz) */
+    0x6F,0xF0,0x58,0x8B,0x57,0x70,0xA0}},         /* ; (VCLK 49.5MHz) */
+ {{0x7E,0x63,0x82,0x6B,0x13,0x00,0x06,0x00,    /* ; 11 (800x600,85Hz) */
+    0x75,0xF0,0x58,0x8B,0x57,0x76,0xA0}},         /* ; (VCLK 56.25MHz) */
+ {{0x81,0x63,0x85,0x6D,0x18,0x00,0x06,0x60,    /* ; 12 (800x600,100Hz) */
+    0x7A,0xF0,0x58,0x8B,0x57,0x7B,0xA0}},         /* ; (VCLK 75.8MHz) */
+ {{0x83,0x63,0x87,0x6E,0x19,0x00,0x06,0x60,    /* ; 13 (800x600,120Hz) */
+    0x81,0xF0,0x58,0x8B,0x57,0x82,0xA0}},         /* ; (VCLK 79.411MHz) */
+ {{0x85,0x63,0x89,0x6F,0x1A,0x00,0x06,0x60,    /* ; 14 (800x600,160Hz) */
+   0x91,0xF0,0x58,0x8B,0x57,0x92,0xA0}},         /* ; (VCLK 105.822MHz) */
+ {{0x99,0x7F,0x9D,0x84,0x1A,0x00,0x02,0x00,
+    0x96,0x1F,0x7F,0x83,0x7F,0x97,0x10}}, /* 0x15 */
+ {{0xA3,0x7F,0x87,0x86,0x97,0x00,0x02,0x00,
+    0x24,0xF5,0x02,0x88,0xFF,0x25,0x90}}, /* 0x16 */
+ {{0xA1,0x7F,0x85,0x86,0x97,0x00,0x02,0x00,
+    0x24,0xF5,0x02,0x88,0xFF,0x25,0x90}}, /* 0x17 */
+ {{0x9F,0x7F,0x83,0x85,0x91,0x00,0x02,0x00,
+    0x1E,0xF5,0x00,0x83,0xFF,0x1F,0x90}}, /* 0x18 */
+ {{0xA7,0x7F,0x8B,0x89,0x95,0x00,0x02,0x00,
+    0x26,0xF5,0x00,0x83,0xFF,0x27,0x90}}, /* 0x19 */
+ {{0xA9,0x7F,0x8D,0x8C,0x9A,0x00,0x02,0x62,
+    0x2C,0xF5,0x00,0x83,0xFF,0x2D,0x14}}, /* 0x1a */
+ {{0xAB,0x7F,0x8F,0x8D,0x9B,0x00,0x02,0x62,
+    0x35,0xF5,0x00,0x83,0xFF,0x36,0x14}}, /* 0x1b */
+ {{0xCF,0x9F,0x93,0xB2,0x01,0x00,0x03,0x00,
+    0x14,0xBA,0x00,0x83,0xFF,0x15,0x00}}, /* 0x1c */
+ {{0xCE,0x9F,0x92,0xA9,0x17,0x00,0x07,0x00,
+    0x28,0x5A,0x00,0x83,0xFF,0x29,0x89}}, /* 0x1d */
+ {{0xCE,0x9F,0x92,0xA5,0x17,0x00,0x07,0x00,
+    0x28,0x5A,0x00,0x83,0xFF,0x29,0x89}}, /* 0x1e */
+ {{0xD3,0x9F,0x97,0xAB,0x1F,0x00,0x07,0x00,
+    0x2E,0x5A,0x00,0x83,0xFF,0x2F,0x89}}, /* 0x1f */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x20 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x21 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x22 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x23 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x24 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x25 */
+ {{0x09,0xC7,0x8D,0xD3,0x0B,0x01,0x04,0x00,
+    0xE0,0x10,0xB0,0x83,0xAF,0xE1,0x2F}}, /* 0x26 */
+ {{0x40,0xEF,0x84,0x03,0x1D,0x41,0x01,0x00,
+    0xDA,0x1F,0xA0,0x83,0x9F,0xDB,0x1F}}, /* 0x27 */
+ {{0x43,0xEF,0x87,0x06,0x00,0x41,0x05,0x62,
+    0xD4,0x1F,0xA0,0x83,0x9F,0xD5,0x9F}}, /* 0x28 */
+ {{0x45,0xEF,0x89,0x07,0x01,0x41,0x05,0x62,
+    0xD9,0x1F,0xA0,0x83,0x9F,0xDA,0x9F}}, /* 0x29 */
+ {{0x40,0xEF,0x84,0x03,0x1D,0x41,0x01,0x00,
+    0xDA,0x1F,0xA0,0x83,0x9F,0xDB,0x1F}}, /* 0x2a */
+ {{0x40,0xEF,0x84,0x03,0x1D,0x41,0x01,0x00,
+    0xDA,0x1F,0xA0,0x83,0x9F,0xDB,0x1F}}, /* 0x2b */
+ {{0x40,0xEF,0x84,0x03,0x1D,0x41,0x01,0x00,
+    0xDA,0x1F,0xA0,0x83,0x9F,0xDB,0x1F}}, /* 0x2c */
+ {{0x59,0xFF,0x9D,0x17,0x13,0x41,0x05,0x44,
+    0x33,0xBA,0x00,0x83,0xFF,0x34,0x0F}}, /* 0x2d */
+ {{0x5B,0xFF,0x9F,0x18,0x14,0x41,0x05,0x44,
+    0x38,0xBA,0x00,0x83,0xFF,0x39,0x0F}}, /* 0x2e */
+ {{0x5B,0xFF,0x9F,0x18,0x14,0x41,0x05,0x44,
+    0x3D,0xBA,0x00,0x83,0xFF,0x3E,0x0F}}, /* 0x2f */
+ {{0x5D,0xFF,0x81,0x19,0x95,0x41,0x05,0x44,
+    0x41,0xBA,0x00,0x84,0xFF,0x42,0x0F}}, /* 0x30 */
+ {{0x55,0xFF,0x99,0x0D,0x0C,0x41,0x05,0x00,
+    0x3E,0xBA,0x00,0x84,0xFF,0x3F,0x0F}}, /* 0x31 */
+ {{0x7F,0x63,0x83,0x6C,0x1C,0x00,0x06,0x00,
+    0x72,0xBA,0x27,0x8B,0xDF,0x73,0x80}}, /* 0x32 */
+ {{0x7F,0x63,0x83,0x69,0x13,0x00,0x06,0x00,
+    0x6F,0xBA,0x26,0x89,0xDF,0x6F,0x80}}, /* 0x33 */
+ {{0x7F,0x63,0x82,0x6B,0x13,0x00,0x06,0x00,
+    0x75,0xBA,0x29,0x8C,0xDF,0x75,0x80}}, /* 0x34 */
+ {{0xA3,0x7F,0x87,0x86,0x97,0x00,0x02,0x00,
+    0x24,0xF1,0xAF,0x85,0x3F,0x25,0xB0}}, /* 0x35 */
+ {{0x9F,0x7F,0x83,0x85,0x91,0x00,0x02,0x00,
+    0x1E,0xF1,0xAD,0x81,0x3F,0x1F,0xB0}}, /* 0x36 */
+ {{0xA7,0x7F,0x88,0x89,0x15,0x00,0x02,0x00,
+    0x26,0xF1,0xB1,0x85,0x3F,0x27,0xB0}}, /* 0x37 */
+ {{0xCE,0x9F,0x92,0xA9,0x17,0x00,0x07,0x00,
+    0x28,0xC4,0x7A,0x8E,0xCF,0x29,0xA1}}, /* 0x38 */
+ {{0xCE,0x9F,0x92,0xA5,0x17,0x00,0x07,0x00,
+    0x28,0xD4,0x7A,0x8E,0xCF,0x29,0xA1}}, /* 0x39 */
+ {{0xD3,0x9F,0x97,0xAB,0x1F,0x00,0x07,0x00,
+    0x2E,0xD4,0x7D,0x81,0xCF,0x2F,0xA1}}, /* 0x3a */
+ {{0xDC,0x9F,0x00,0xAB,0x19,0x00,0x07,0x00,
+    0xE6,0xEF,0xC0,0xC3,0xBF,0xE7,0x90}}, /* 0x3b */
+ {{0x6B,0x59,0x8F,0x5E,0x8C,0x00,0x05,0x00,
+    0x0B,0x3E,0xE9,0x8B,0xE7,0x04,0x00}}, /* 0x3c */
+ {{0x7B,0x63,0x9F,0x6A,0x93,0x00,0x05,0x00,
+    0x6F,0xF0,0x58,0x8A,0x57,0x70,0xA0}}, /* 0x3d */
+ {{0x86,0x6A,0x8a,0x74,0x06,0x00,0x02,0x00,
+    0x8c,0x15,0x4f,0x83,0xef,0x8d,0x30}}, /* 0x3e */
+ {{0x81,0x6A,0x85,0x70,0x00,0x00,0x02,0x00,
+    0x0f,0x3e,0xeb,0x8e,0xdf,0x10,0x00}}, /* 0x3f */
+ {{0xCE,0x9F,0x92,0xA9,0x17,0x00,0x07,0x00,
+    0x20,0xF5,0x03,0x88,0xFF,0x21,0x90}}, /* 0x40 */
+ {{0xE6,0xAE,0x8A,0xBD,0x90,0x00,0x03,0x00,
+    0x3D,0x10,0x1A,0x8D,0x19,0x3E,0x2F}}, /* 0x41 */
+ {{0xB9,0x8F,0x9D,0x9B,0x8A,0x00,0x06,0x00,
+    0x7D,0xFF,0x60,0x83,0x5F,0x7E,0x90}}, /* 0x42 */
+ {{0xC3,0x8F,0x87,0x9B,0x0B,0x00,0x07,0x00,
+    0x82,0xFF,0x60,0x83,0x5F,0x83,0x90}},  /* 0x43 */
+ {{0xAD,0x7F,0x91,0x8E,0x9C,0x00,0x02,0x82,
+    0x49,0xF5,0x00,0x83,0xFF,0x4A,0x90}},  /* 0x44 */
+ {{0xCD,0x9F,0x91,0xA7,0x19,0x00,0x07,0x60,
+    0xE6,0xFF,0xC0,0x83,0xBF,0xE7,0x90}},  /* 0x45 */
+ {{0xD3,0x9F,0x97,0xAB,0x1F,0x00,0x07,0x60,
+    0xF1,0xFF,0xC0,0x83,0xBF,0xF2,0x90}},  /* 0x46 */
+ {{0xD7,0x9F,0x9B,0xAC,0x1E,0x00,0x07,0x00,
+    0x03,0xDE,0xC0,0x84,0xBF,0x04,0x90}}  /* 0x47 */
+};
+
+XGI330_CHTVRegDataStruct XGI_CHTVRegUNTSC[] = {
+                /* Index:000h,001h,002h,004h,003h,005h,006h,007h,008h,015h,01Fh,00Ch,00Dh,00Eh,00Fh,010h */
+                {{      0x4A,0x77,0xBB,0x94,0x84,0x48,0xFE,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 00 (640x200,640x400) */
+                {{      0x4A,0x77,0xBB,0x94,0x84,0x48,0xFE,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 01 (640x350) */
+                {{      0x4A,0x77,0xBB,0x94,0x84,0x48,0xFE,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 02 (720x400) */
+                {{      0x4A,0x77,0xBB,0x94,0x84,0x48,0xFE,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 03 (720x350) */
+                {{      0x6A,0x77,0xBB,0x6E,0x84,0x2E,0x02,0x5A,0x04,0x00,0x80,0x20,0x7E,0x80,0x97,0x00  }},/* 04 (640x480) ;;5/6/02 */
+                {{      0xCF,0x77,0xB7,0xC8,0x84,0x3B,0x02,0x5A,0x04,0x00,0x80,0x19,0x88,0xAE,0xA3,0x00  }},/* 05 (800x600) ;;1/12/02 */
+                {{      0xEE,0x77,0xBB,0x66,0x87,0x32,0x01,0x5A,0x04,0x00,0x80,0x1B,0xD4,0x2F,0x6F,0x00  }}/* 06 (1024x768) ;;5/6/02 */
+          };
+
+XGI330_CHTVRegDataStruct XGI_CHTVRegONTSC[]= {
+                /* Index:000h,001h,002h,004h,003h,005h,006h,007h,008h,015h,01Fh,00Ch,00Dh,00Eh,00Fh,010h */
+                {{      0x49,0x77,0xBB,0x7B,0x84,0x34,0x00,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 00 (640x200,640x400) */
+                {{      0x49,0x77,0xBB,0x7B,0x84,0x34,0x00,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 01 (640x350) */
+                {{      0x49,0x77,0xBB,0x7B,0x84,0x34,0x00,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 02 (720x400) */
+                {{      0x49,0x77,0xBB,0x7B,0x84,0x34,0x00,0x50,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* 03 (720x350) */
+                {{      0x69,0x77,0xBB,0x6E,0x84,0x1E,0x00,0x5A,0x04,0x00,0x80,0x25,0x1A,0x80,0x26,0x00  }},/* 04 (640x480) ;;5/6/02 */
+                {{      0xCE,0x77,0xB7,0xB6,0x83,0x2C,0x02,0x5A,0x04,0x00,0x80,0x1C,0x00,0x82,0x97,0x00  }},/* 05 (800x600) ;;5/6/02 */
+                {{      0xED,0x77,0xBB,0x66,0x8C,0x21,0x02,0x5A,0x04,0x00,0x80,0x1F,0xA0,0x7E,0x73,0x00  }}/* 06 (1024x768) ;;5/6/02 */
+          };
+
+XGI330_CHTVRegDataStruct XGI_CHTVRegUPAL[]=  {
+                /* Index:000h,001h,002h,004h,003h,005h,006h,007h,008h,015h,01Fh,00Ch,00Dh,00Eh,00Fh,010h */
+                {{      0x41,0x7F,0xB7,0x34,0xAD,0x50,0x34,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* ; 00 (640x200,640x400) */
+                {{      0x41,0x7F,0xB7,0x80,0x85,0x50,0x00,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* ; 01 (640x350) */
+                {{      0x41,0x7F,0xB7,0x34,0xAD,0x50,0x34,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* ; 02 (720x400) */
+                {{      0x41,0x7F,0xB7,0x12,0x85,0x50,0x00,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01  }},/* ; 03 (720x350) */
+                {{      0x61,0x7F,0xB7,0x99,0x84,0x35,0x04,0x5A,0x05,0x00,0x80,0x26,0x2A,0x55,0x5D,0x00  }},/* ; 04 (640x480) */
+                {{      0xC3,0x7F,0xB7,0x7A,0x84,0x40,0x02,0x5A,0x05,0x00,0x80,0x1F,0x84,0x3D,0x28,0x00  }},/* ; 05 (800x600) ;;1/12/02 */
+                {{      0xE5,0x7F,0xB7,0x1D,0xA7,0x3E,0x04,0x5A,0x05,0x00,0x80,0x20,0x3E,0xE4,0x22,0x00  }}/* ; 06 (1024x768) ;;1/12/02 */
+	  };
+
+XGI330_CHTVRegDataStruct XGI_CHTVRegOPAL[]={
+                /* Index:000,0x01,0x02,0x04,0x03,0x05,0x06,0x07,0x08,0x15,0x1F,0x0C,0x0D,0x0E,0x0F,0x10h */
+                {{      0x41,0x7F,0xB7,0x36,0xAD,0x50,0x34,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01 }},/* 00 (640x200,640x400) */
+                {{      0x41,0x7F,0xB7,0x86,0x85,0x50,0x00,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01 }},/* 01 (640x350) */
+                {{      0x41,0x7F,0xB7,0x36,0xAD,0x50,0x34,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01 }},/* 02 (720x400) */
+                {{      0x41,0x7F,0xB7,0x86,0x85,0x50,0x00,0x83,0x05,0x00,0x80,0x00,0x00,0x00,0x00,0x01 }},/* 03 (720x350) */
+                {{      0x61,0x7F,0xB7,0x99,0x84,0x35,0x04,0x5A,0x05,0x00,0x80,0x26,0x2A,0x55,0x5D,0x00 }},/* 04 (640x480) */
+                {{      0xC1,0x7F,0xB7,0x4D,0x8C,0x1E,0x31,0x5A,0x05,0x00,0x80,0x26,0x78,0x19,0x34,0x00 }},/* 05 (800x600) ;;1/12/02 */
+                {{      0xE4,0x7F,0xB7,0x1E,0xAF,0x29,0x37,0x5A,0x05,0x00,0x80,0x25,0x8C,0xB2,0x2A,0x00 }}/* 06 (1024x768) ;;1/12/02 */
+	     };
+
+UCHAR XGI_CH7017LV1024x768[]={0x60,0x02,0x00,0x07,0x40,0xED,0xA3,
+                   			0xC8,0xC7,0xAC,0xE0,0x02};
+UCHAR XGI_CH7017LV1400x1050[]={0x60,0x03,0x11,0x00,0x40,0xE3,0xAD,
+                   			0xDB,0xF6,0xAC,0xE0,0x02};
+
+
+/*add for new UNIVGABIOS*/
+XGI330_LCDDataStruct  XGI_StLCD1024x768Data[]=
+{
+ {   62,  25, 800, 546,1344, 806},
+ {   32,  15, 930, 546,1344, 806},
+ {   62,  25, 800, 546,1344, 806}, /* chiawen for dot9 -> dot8 */
+ {  104,  45, 945, 496,1344, 806},
+ {   62,  25, 800, 546,1344, 806},
+ {   31,  18,1008, 624,1344, 806},
+ {    1,   1,1344, 806,1344, 806}
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1024x768Data[]=
+{
+ {   42,  25,1536, 419,1344, 806}, /* { 12, 5, 896, 512,1344, 806}, // alan 09/12/2003 */
+ {   48,  25,1536, 369,1344, 806}, /* { 12, 5, 896, 510,1344, 806}, // alan 09/12/2003 */
+ {   42,  25,1536, 419,1344, 806}, /* { 32, 15,1008, 505,1344, 806}, // alan 09/12/2003 */
+ {   48,  25,1536, 369,1344, 806}, /* { 32, 15,1008, 514,1344, 806}, // alan 09/12/2003 */
+ {   12,   5, 896, 500,1344, 806},
+ {   42,  25,1024, 625,1344, 806},
+ {    1,   1,1344, 806,1344, 806},
+ {   12,   5, 896, 500,1344, 806},
+ {   42,  25,1024, 625,1344, 806},
+ {    1,   1,1344, 806,1344, 806},
+ {   12,   5, 896, 500,1344, 806},
+ {   42,  25,1024, 625,1344, 806},
+ {    1,   1,1344, 806,1344, 806}
+};
+
+/*XGI330_LCDDataStruct  XGI_St2LCD1024x768Data[]=
+{
+ {   62,  25, 800, 546,1344, 806},
+ {   32,  15, 930, 546,1344, 806},
+ {   62,  25, 800, 546,1344, 806},
+ {  104,  45, 945, 496,1344, 806},
+ {   62,  25, 800, 546,1344, 806},
+ {   31,  18,1008, 624,1344, 806},
+ {    1,   1,1344, 806,1344, 806}
+};*/
+
+XGI330_LCDDataStruct  XGI_CetLCD1024x768Data[]=
+{
+	{         1,1,1344,806,1344,806           }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {         1,1,1344,806,1344,806           }, /* 01 (320x350,640x350) */
+        {         1,1,1344,806,1344,806           }, /* 02 (360x400,720x400) */
+        {         1,1,1344,806,1344,806           }, /* 03 (720x350) */
+        {         1,1,1344,806,1344,806           }, /* 04 (640x480x60Hz) */
+        {         1,1,1344,806,1344,806           }, /* 05 (800x600x60Hz) */
+        {         1,1,1344,806,1344,806           }  /* 06 (1024x768x60Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_StLCD1280x1024Data[]=
+{
+ {   22,   5, 800, 510,1650,1088},
+ {   22,   5, 800, 510,1650,1088},
+ {  176,  45, 900, 510,1650,1088},
+ {  176,  45, 900, 510,1650,1088},
+ {   22,   5, 800, 510,1650,1088},
+ {   13,   5,1024, 675,1560,1152},
+ {   16,   9,1266, 804,1688,1072},
+ {    1,   1,1688,1066,1688,1066}
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1280x1024Data[]=
+{
+ {  211,  60,1024, 501,1688,1066},
+ {  211,  60,1024, 508,1688,1066},
+ {  211,  60,1024, 501,1688,1066},
+ {  211,  60,1024, 508,1688,1066},
+ {  211,  60,1024, 500,1688,1066},
+ {  211,  75,1024, 625,1688,1066},
+ {  211, 120,1280, 798,1688,1066},
+ {    1,   1,1688,1066,1688,1066}
+};
+
+XGI330_LCDDataStruct  XGI_St2LCD1280x1024Data[]=
+{
+ {   22,   5, 800, 510,1650,1088},
+ {   22,   5, 800, 510,1650,1088},
+ {  176,  45, 900, 510,1650,1088},
+ {  176,  45, 900, 510,1650,1088},
+ {   22,   5, 800, 510,1650,1088},
+ {   13,   5,1024, 675,1560,1152},
+ {   16,   9,1266, 804,1688,1072},
+ {    1,   1,1688,1066,1688,1066}
+};
+
+XGI330_LCDDataStruct  XGI_CetLCD1280x1024Data[]=
+{
+	{         1,1,1688,1066,1688,1066         }, /* 00 (320x200,320x400,640x200,640x400) */
+        {         1,1,1688,1066,1688,1066         }, /* 01 (320x350,640x350) */
+        {         1,1,1688,1066,1688,1066         }, /* 02 (360x400,720x400) */
+        {         1,1,1688,1066,1688,1066         }, /* 03 (720x350) */
+        {         1,1,1688,1066,1688,1066         }, /* 04 (640x480x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 05 (800x600x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 06 (1024x768x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 07 (1280x1024x60Hz) */
+        {         1,1,1688,1066,1688,1066         } /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_StLCD1400x1050Data[]=
+{
+	{         211,100,2100,408,1688,1066      }, /* 00 (320x200,320x400,640x200,640x400) */
+        {         211,64,1536,358,1688,1066       }, /* 01 (320x350,640x350) */
+        {         211,100,2100,408,1688,1066      }, /* 02 (360x400,720x400) */
+        {         211,64,1536,358,1688,1066       }, /* 03 (720x350) */
+        {         211,48,840,488,1688,1066        }, /* 04 (640x480x60Hz) */
+        {         211,72,1008,609,1688,1066       }, /* 05 (800x600x60Hz) */
+        {         211,128,1400,776,1688,1066      }, /* 06 (1024x768x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 07 (1280x1024x60Hz w/o Scaling) */
+        {         1,1,1688,1066,1688,1066         }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1400x1050Data[]=
+{
+	{         211,100,2100,408,1688,1066      }, /* 00 (320x200,320x400,640x200,640x400) */
+        {         211,64,1536,358,1688,1066       }, /* 01 (320x350,640x350) */
+        {         211,100,2100,408,1688,1066      }, /* 02 (360x400,720x400) */
+        {         211,64,1536,358,1688,1066       }, /* 03 (720x350) */
+        {         211,48,840,488,1688,1066        }, /* 04 (640x480x60Hz) */
+        {         211,72,1008,609,1688,1066       }, /* 05 (800x600x60Hz) */
+        {         211,128,1400,776,1688,1066      }, /* 06 (1024x768x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 07 (1280x1024x60Hz w/o Scaling) */
+        {         1,1,1688,1066,1688,1066         }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1600x1200Data[]=
+{
+        {         4,1,1620,420,2160,1250          }, /* { 3,1,2160,425,2160,1250 }, // 00 (320x200,320x400,640x200,640x400) // alan 10/14/2003 */
+        {         27,7,1920,375,2160,1250         }, /* 01 (320x350,640x350) */
+        {         4,1,1620,420,2160,1250          }, /* { 3,1,2160,425,2160,1250 }, // 02 (360x400,720x400) // alan 10/14/2003 */
+        {         27,7,1920,375,2160,1250         }, /* 03 (720x350) */
+        {         27,4,800,500,2160,1250          }, /* 04 (640x480x60Hz) */
+        {         4,1,1080,625,2160,1250          }, /* 05 (800x600x60Hz) */
+        {         5,2,1350,800,2160,1250          }, /* 06 (1024x768x60Hz) */
+        {         27,16,1500,1064,2160,1250       }, /* 07 (1280x1024x60Hz) */
+        {         9,7,1920,1106,2160,1250         }, /* 08 (1400x1050x60Hz) */
+        {         1,1,2160,1250,2160,1250         }  /* 09 (1600x1200x60Hz) ;302lv */
+};
+
+XGI330_LCDDataStruct  XGI_StLCD1600x1200Data[]=
+{
+        {         27,4,800,500,2160,1250          },/* 00 (320x200,320x400,640x200,640x400) */
+        {         27,4,800,500,2160,1250          },/* 01 (320x350,640x350) */
+        {         27,4,800,500,2160,1250          },/* 02 (360x400,720x400) */
+        {         27,4,800,500,2160,1250          },/* 03 (720x350) */
+        {         27,4,800,500,2160,1250          },/* 04 (320x240,640x480) */
+        {         4,1,1080,625,2160,1250          },/* 05 (400x300,800x600) */
+        {         5,2,1350,800,2160,1250          },/* 06 (512x384,1024x768) */
+        {         135,88,1600,1100,2160,1250      },/* 07 (1280x1024) */
+        {         1,1,1800,1500,2160,1250         },/* 08 (1400x1050) */
+        {         1,1,2160,1250,2160,1250         } /* 09 (1600x1200) */
+};
+
+XGI330_LCDDataStruct  XGI_CetLCD1400x1050Data[]=
+{
+	{         1,1,1688,1066,1688,1066         }, /* 00 (320x200,320x400,640x200,640x400) */
+        {         1,1,1688,1066,1688,1066         }, /* 01 (320x350,640x350) */
+        {         1,1,1688,1066,1688,1066         }, /* 02 (360x400,720x400) */
+        {         1,1,1688,1066,1688,1066         }, /* 03 (720x350) */
+        {         1,1,1688,1066,1688,1066         }, /* 04 (640x480x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 05 (800x600x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 06 (1024x768x60Hz) */
+        {         1,1,1688,1066,1688,1066         }, /* 07 (1280x1024x60Hz) */
+        {         1,1,1688,1066,1688,1066         }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_NoScalingData[]=
+{
+ {    1,   1, 800, 449, 800, 449},
+ {    1,   1, 800, 449, 800, 449},
+ {    1,   1, 900, 449, 900, 449},
+ {    1,   1, 900, 449, 900, 449},
+ {    1,   1, 800, 525, 800, 525},
+ {    1,   1,1056, 628,1056, 628},
+ {    1,   1,1344, 806,1344, 806},
+ {    1,   1,1688,1066,1688,1066}
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1024x768x75Data[]=
+{
+        {42,25,1536,419,1344,806 }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {48,25,1536,369,1344,806 }, /* ; 01 (320x350,640x350) */
+        {42,25,1536,419,1344,806 }, /* ; 02 (360x400,720x400) */
+        {48,25,1536,369,1344,806 }, /* ; 03 (720x350) */
+        {8,5,1312,500,1312,800   }, /* ; 04 (640x480x75Hz) */
+        {41,25,1024,625,1312,800 }, /* ; 05 (800x600x75Hz) */
+        {1,1,1312,800,1312,800   }  /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_StLCD1024x768x75Data[]=
+{
+        {42,25,1536,419,1344,806 }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {48,25,1536,369,1344,806 }, /* ; 01 (320x350,640x350) */
+        {42,25,1536,419,1344,806 }, /* ; 02 (360x400,720x400) */
+        {48,25,1536,369,1344,806 }, /* ; 03 (720x350) */
+        {8,5,1312,500,1312,800   }, /* ; 04 (640x480x75Hz) */
+        {41,25,1024,625,1312,800 }, /* ; 05 (800x600x75Hz) */
+        {1,1,1312,800,1312,800   }  /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_CetLCD1024x768x75Data[]=
+{
+        {1,1,1312,800,1312,800}, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1,1,1312,800,1312,800}, /* ; 01 (320x350,640x350) */
+        {1,1,1312,800,1312,800}, /* ; 02 (360x400,720x400) */
+        {1,1,1312,800,1312,800}, /* ; 03 (720x350) */
+        {1,1,1312,800,1312,800}, /* ; 04 (640x480x75Hz) */
+        {1,1,1312,800,1312,800}, /* ; 05 (800x600x75Hz) */
+        {1,1,1312,800,1312,800} /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_ExtLCD1280x1024x75Data[]=
+{
+        {211,60,1024,501,1688,1066   }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {211,60,1024,508,1688,1066   }, /* ; 01 (320x350,640x350) */
+        {211,60,1024,501,1688,1066   }, /* ; 02 (360x400,720x400) */
+        {211,60,1024,508,1688,1066   }, /* ; 03 (720x350) */
+        {211,45,768,498,1688,1066    }, /* ; 04 (640x480x75Hz) */
+        {211,75,1024,625,1688,1066   }, /* ; 05 (800x600x75Hz) */
+        {211,120,1280,798,1688,1066  }, /* ; 06 (1024x768x75Hz) */
+        {1,1,1688,1066,1688,1066     }  /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_StLCD1280x1024x75Data[]=
+{
+        {211,60,1024,501,1688,1066 }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {211,60,1024,508,1688,1066 }, /* ; 01 (320x350,640x350) */
+        {211,60,1024,501,1688,1066 }, /* ; 02 (360x400,720x400) */
+        {211,60,1024,508,1688,1066 }, /* ; 03 (720x350) */
+        {211,45,768,498,1688,1066  }, /* ; 04 (640x480x75Hz) */
+        {211,75,1024,625,1688,1066 }, /* ; 05 (800x600x75Hz) */
+        {211,120,1280,798,1688,1066}, /* ; 06 (1024x768x75Hz) */
+        {1,1,1688,1066,1688,1066   }  /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_CetLCD1280x1024x75Data[]=
+{
+        {1,1,1688,1066,1688,1066}, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1,1,1688,1066,1688,1066}, /* ; 01 (320x350,640x350) */
+        {1,1,1688,1066,1688,1066}, /* ; 02 (360x400,720x400) */
+        {1,1,1688,1066,1688,1066}, /* ; 03 (720x350) */
+        {1,1,1688,1066,1688,1066}, /* ; 04 (640x480x75Hz) */
+        {1,1,1688,1066,1688,1066}, /* ; 05 (800x600x75Hz) */
+        {1,1,1688,1066,1688,1066}, /* ; 06 (1024x768x75Hz) */
+        {1,1,1688,1066,1688,1066}  /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataStruct  XGI_NoScalingDatax75[]=
+{
+        {1,1,800,449,800,449    }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1,1,800,449,800,449    }, /* ; 01 (320x350,640x350) */
+        {1,1,900,449,900,449    }, /* ; 02 (360x400,720x400) */
+        {1,1,900,449,900,449    }, /* ; 03 (720x350) */
+        {1,1,840,500,840,500    }, /* ; 04 (640x480x75Hz) */
+        {1,1,1056,625,1056,625  }, /* ; 05 (800x600x75Hz) */
+        {1,1,1312,800,1312,800  }, /* ; 06 (1024x768x75Hz) */
+        {1,1,1688,1066,1688,1066}, /* ; 07 (1280x1024x75Hz) */
+        {1,1,1688,1066,1688,1066}, /* ; 08 (1400x1050x75Hz) ;;[ycchen] 12/19/02 */
+        {1,1,2160,1250,2160,1250}, /* ; 09 (1600x1200x75Hz) */
+        {1,1,1688,806,1688,806  }  /* ; 0A (1280x768x75Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1024x768Data[]=
+{
+   {  9,1057,0, 771  }, /* ; 00 (320x200,320x400,640x200,640x400) */
+   {  9,1057,0, 771  }, /* ; 01 (320x350,640x350) */
+   {  9,1057,0, 771  }, /* ; 02 (360x400,720x400) */
+   {  9,1057,0, 771  }, /* ; 03 (720x350) */
+   {  9,1057,0, 771  }, /* ; 04 (640x480x60Hz) */
+   {  9,1057,0, 771  }, /* ; 05 (800x600x60Hz) */
+   {  9,1057,805, 770  }  /* ; 06 (1024x768x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1024x768Data[]=
+{
+        { 9,1057,737,703   }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        { 9,1057,686,651   }, /* ; 01 (320x350,640x350) */
+        { 9,1057,737,703   }, /* ; 02 (360x400,720x400) */
+        { 9,1057,686,651   }, /* ; 03 (720x350) */
+        { 9,1057,776,741   }, /* ; 04 (640x480x60Hz) */
+        { 9,1057, 0 ,771   }, /* ; 05 (800x600x60Hz) */
+        { 9,1057,805,770   }  /* ; 06 (1024x768x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1024x768Data[]=
+{
+       	{      1152,856,622,587   }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {      1152,856,597,562   }, /* ; 01 (320x350,640x350) */
+        {      1152,856,622,587   }, /* ; 02 (360x400,720x400) */
+        {      1152,856,597,562   }, /* ; 03 (720x350) */
+        {      1152,856,662,627   }, /* ; 04 (640x480x60Hz) */
+        {      1232,936,722,687   }, /* ; 05 (800x600x60Hz) */
+        {      0,1048,805,770   }  /* ; 06 (1024x768x60Hz) */
+};
+
+XGI330_LCDDataDesStruct XGI_ExtLCDDLDes1280x1024Data[]=
+{
+        {      18,1346,981,940     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1346,926,865     },/* 01 (320x350,640x350) */
+        {      18,1346,981,940     },/* 02 (360x400,720x400) */
+        {      18,1346,926,865     },/* 03 (720x350) */
+        {      18,1346,0,1025     },/* 04 (640x480x60Hz) */
+        {      18,1346,0,1025     },/* 05 (800x600x60Hz) */
+        {      18,1346,1065,1024     },/* 06 (1024x768x60Hz) */
+        {      18,1346,1065,1024     }/* 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct XGI_StLCDDLDes1280x1024Data[]=
+{
+        {      18,1346,970,907     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1346,917,854     },/* 01 (320x350,640x350) */
+        {      18,1346,970,907     },/* 02 (360x400,720x400) */
+        {      18,1346,917,854     },/* 03 (720x350) */
+        {      18,1346,0,1025     },/* 04 (640x480x60Hz) */
+        {      18,1346,0,1025     },/* 05 (800x600x60Hz) */
+        {      18,1346,1065,1024     },/* 06 (1024x768x60Hz) */
+        {      18,1346,1065,1024     }/* 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDLDes1280x1024Data[]=
+{
+        {      1368,1008,752,711    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1368,1008,729,688    }, /* 01 (320x350,640x350) */
+        {      1368,1008,752,711    }, /* 02 (360x400,720x400) */
+    	{      1368,1008,729,688    }, /* 03 (720x350) */
+        {      1368,1008,794,753    }, /* 04 (640x480x60Hz) */
+        {      1448,1068,854,813    }, /* 05 (800x600x60Hz) */
+        {      1560,1200,938,897    }, /* 06 (1024x768x60Hz) */
+        {      18,1346,1065,1024    }  /* 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1280x1024Data[]=
+{
+        {      9,1337,981,940    }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {      9,1337,926,884    }, /* ; 01 (320x350,640x350) alan, 2003/09/30 */
+        {      9,1337,981,940    }, /* ; 02 (360x400,720x400) */
+        {      9,1337,926,884    }, /* ; 03 (720x350) alan, 2003/09/30 */
+        {      9,1337,0,1025    }, /* ; 04 (640x480x60Hz) */
+        {      9,1337,0,1025    }, /* ; 05 (800x600x60Hz) */
+        {      9,1337,1065,1024    }, /* ; 06 (1024x768x60Hz) */
+        {      9,1337,1065,1024    }  /* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1280x1024Data[]=
+{
+        {      9,1337,970,907    }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {      9,1337,917,854    }, /* ; 01 (320x350,640x350) */
+        {      9,1337,970,907    }, /* ; 02 (360x400,720x400) */
+        {      9,1337,917,854    }, /* ; 03 (720x350) */
+        {      9,1337,0,1025    }, /* ; 04 (640x480x60Hz) */
+        {      9,1337,0,1025    }, /* ; 05 (800x600x60Hz) */
+        {      9,1337,1065,1024    }, /* ; 06 (1024x768x60Hz) */
+        {      9,1337,1065,1024    }  /* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1280x1024Data[]=
+{
+        {      1368,1008,752,711    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1368,1008,729,688    }, /* 01 (320x350,640x350) */
+        {      1368,1008,752,711    }, /* 02 (360x400,720x400) */
+    	{      1368,1008,729,688    }, /* 03 (720x350) */
+        {      1368,1008,794,753    }, /* 04 (640x480x60Hz) */
+        {      1448,1068,854,813    }, /* 05 (800x600x60Hz) */
+        {      1560,1200,938,897    }, /* 06 (1024x768x60Hz) */
+        {      9,1337,1065,1024    }  /* 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDLDes1400x1050Data[]=
+{
+        {      18,1464,0,1051    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1464,0,1051    }, /* 01 (320x350,640x350) */
+        {      18,1464,0,1051    }, /* 02 (360x400,720x400) */
+        {      18,1464,0,1051    }, /* 03 (720x350) */
+        {      18,1464,0,1051    }, /* 04 (640x480x60Hz) */
+        {      18,1464,0,1051    }, /* 05 (800x600x60Hz) */
+        {      18,1464,0,1051    }, /* 06 (1024x768x60Hz) */
+        {      1646,1406,1053,1038    }, /* 07 (1280x1024x60Hz) */
+        {      18,1464,0,1051    }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDLDes1400x1050Data[]=
+{
+        {      18,1464,0,1051    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1464,0,1051    }, /* 01 (320x350,640x350) */
+        {      18,1464,0,1051    }, /* 02 (360x400,720x400) */
+        {      18,1464,0,1051    }, /* 03 (720x350) */
+        {      18,1464,0,1051    }, /* 04 (640x480x60Hz) */
+        {      18,1464,0,1051    }, /* 05 (800x600x60Hz) */
+        {      18,1464,0,1051    }, /* 06 (1024x768x60Hz) */
+        {      1646,1406,1053,1038    }, /* 07 (1280x1024x60Hz) */
+        {      18,1464,0,1051    }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1400x1050Data[]=
+{
+        {      9,1455,0,1051     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      9,1455,0,1051     },/* 01 (320x350,640x350) */
+        {      9,1455,0,1051     },/* 02 (360x400,720x400) */
+        {      9,1455,0,1051     },/* 03 (720x350) */
+        {      9,1455,0,1051     },/* 04 (640x480x60Hz) */
+        {      9,1455,0,1051     },/* 05 (800x600x60Hz) */
+        {      9,1455,0,1051     },/* 06 (1024x768x60Hz) */
+        {      1637,1397,1053,1038     },/* 07 (1280x1024x60Hz) */
+        {      9,1455,0,1051     } /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1400x1050Data[]=
+{
+        {      9,1455,0,1051     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      9,1455,0,1051     },/* 01 (320x350,640x350) */
+        {      9,1455,0,1051     },/* 02 (360x400,720x400) */
+        {      9,1455,0,1051     },/* 03 (720x350) */
+        {      9,1455,0,1051     },/* 04 (640x480x60Hz) */
+        {      9,1455,0,1051     },/* 05 (800x600x60Hz) */
+        {      9,1455,0,1051     },/* 06 (1024x768x60Hz) */
+        {      1637,1397,1053,1038     },/* 07 (1280x1024x60Hz) */
+        {      9,1455,0,1051     } /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1400x1050Data[]=
+{
+        {      1308,1068,781,766    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1308,1068,781,766    }, /* 01 (320x350,640x350) */
+        {      1308,1068,781,766    }, /* 02 (360x400,720x400) */
+        {      1308,1068,781,766    }, /* 03 (720x350) */
+        {      1308,1068,781,766    }, /* 04 (640x480x60Hz) */
+        {      1388,1148,841,826    }, /* 05 (800x600x60Hz) */
+        {      1490,1250,925,910    }, /* 06 (1024x768x60Hz) */
+        {      1646,1406,1053,1038    }, /* 07 (1280x1024x60Hz) */
+        {      18,1464,0,1051    } /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1400x1050Data2[]=
+{
+        {      0,1448,0,1051    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      0,1448,0,1051    }, /* 01 (320x350,640x350) */
+        {      0,1448,0,1051    }, /* 02 (360x400,720x400) */
+        {      0,1448,0,1051    }, /* 03 (720x350) */
+        {      0,1448,0,1051    }  /* 04 (640x480x60Hz) */
+};
+
+
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDLDes1600x1200Data[]=
+{
+	{      18,1682,0,1201    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1682,0,1201    }, /* 01 (320x350,640x350) */
+        {      18,1682,0,1201    }, /* 02 (360x400,720x400) */
+        {      18,1682,0,1201    }, /* 03 (720x350) */
+        {      18,1682,0,1201    }, /* 04 (640x480x60Hz) */
+        {      18,1682,0,1201    }, /* 05 (800x600x60Hz) */
+        {      18,1682,0,1201    }, /* 06 (1024x768x60Hz) */
+        {      18,1682,0,1201    }, /* 07 (1280x1024x60Hz) */
+        {      18,1682,0,1201    }, /* 08 (1400x1050x60Hz) */
+        {      18,1682,0,1201    }  /* 09 (1600x1200x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDLDes1600x1200Data[]=
+{
+        {      18,1682,1150,1101    }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      18,1682,1083,1034    }, /* 01 (320x350,640x350) */
+        {      18,1682,1150,1101    }, /* 02 (360x400,720x400) */
+        {      18,1682,1083,1034    }, /* 03 (720x350) */
+        {      18,1682,0,1201    }, /* 04 (640x480x60Hz) */
+        {      18,1682,0,1201    }, /* 05 (800x600x60Hz) */
+        {      18,1682,0,1201    }, /* 06 (1024x768x60Hz) */
+        {      18,1682,1232,1183    }, /* 07 (1280x1024x60Hz) */
+        {      18,1682,0,1201    }, /* 08 (1400x1050x60Hz) */
+        {      18,1682,0,1201    } /* 09 (1600x1200x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1600x1200Data[]=
+{
+        {      9,1673,0,1201     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      9,1673,0,1201     },/* 01 (320x350,640x350) */
+        {      9,1673,0,1201     },/* 02 (360x400,720x400) */
+        {      9,1673,0,1201     },/* 03 (720x350) */
+        {      9,1673,0,1201     },/* 04 (640x480x60Hz) */
+        {      9,1673,0,1201     },/* 05 (800x600x60Hz) */
+        {      9,1673,0,1201     },/* 06 (1024x768x60Hz) */
+        {      9,1673,0,1201     },/* 07 (1280x1024x60Hz) */
+        {      9,1673,0,1201     },/* 08 (1400x1050x60Hz) */
+        {      9,1673,0,1201     } /* 09 (1600x1200x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1600x1200Data[]=
+{
+	{      9,1673,1150,1101     },/* 00 (320x200,320x400,640x200,640x400) */
+        {      9,1673,1083,1034     },/* 01 (320x350,640x350) */
+        {      9,1673,1150,1101     },/* 02 (360x400,720x400) */
+        {      9,1673,1083,1034     },/* 03 (720x350) */
+        {      9,1673,0,1201     },/* 04 (640x480x60Hz) */
+        {      9,1673,0,1201     },/* 05 (800x600x60Hz) */
+        {      9,1673,0,1201     },/* 06 (1024x768x60Hz) */
+        {      9,1673,1232,1183     },/* 07 (1280x1024x60Hz) */
+        {      9,1673,0,1201     },/* 08 (1400x1050x60Hz) */
+        {      9,1673,0,1201     } /* 09 (1600x1200x60Hz) */
+};
+
+XGI330_LCDDataDesStruct2  XGI_NoScalingDesData[]=
+{
+        {     9,657,448,405,96,2  }, /* 00 (320x200,320x400,640x200,640x400) */
+        {     9,657,448,355,96,2  }, /* 01 (320x350,640x350) */
+        {     9,657,448,405,96,2  }, /* 02 (360x400,720x400) */
+        {     9,657,448,355,96,2  }, /* 03 (720x350) */
+        {     9,657,1,483,96,2  }, /* 04 (640x480x60Hz) */
+        {     9,849,627,600,128,4  }, /* 05 (800x600x60Hz) */
+        {     9,1057,805,770,0136,6  }, /* 06 (1024x768x60Hz) */
+        {     9,1337,0,1025,112,3  }, /* 07 (1280x1024x60Hz) */
+        {     9,1457,0,1051,112,3  }, /* 08 (1400x1050x60Hz) }, //;[ycchen] 12/19/02 */
+        {     9,1673,0,1201,192,3  }, /* 09 (1600x1200x60Hz) */
+        {     9,1337,0,771,112,6  }  /* 0A (1280x768x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1024x768x75Data[]=		/* ;;1024x768x75Hz */
+{
+        {9,1049,0,769},    /* ; 00 (320x200,320x400,640x200,640x400) */
+        {9,1049,0,769},    /* ; 01 (320x350,640x350) */
+        {9,1049,0,769},    /* ; 02 (360x400,720x400) */
+        {9,1049,0,769},    /* ; 03 (720x350) */
+        {9,1049,0,769},    /* ; 04 (640x480x75Hz) */
+        {9,1049,0,769},    /* ; 05 (800x600x75Hz) */
+        {9,1049,0,769}     /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1024x768x75Data[]=
+{
+        {9,1049,0,769},    /* ; 00 (320x200,320x400,640x200,640x400) */
+        {9,1049,0,769},    /* ; 01 (320x350,640x350) */
+        {9,1049,0,769},    /* ; 02 (360x400,720x400) */
+        {9,1049,0,769},    /* ; 03 (720x350) */
+        {9,1049,0,769},    /* ; 04 (640x480x75Hz) */
+        {9,1049,0,769},    /* ; 05 (800x600x75Hz) */
+        {9,1049,0,769}     /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1024x768x75Data[]=	/* ;;1024x768x75Hz */
+{
+        {1152,856,622,587},     /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1152,856,597,562},     /* ; 01 (320x350,640x350) */
+        {1192,896,622,587},     /* ; 02 (360x400,720x400) */
+        {1192,896,597,562},     /* ; 03 (720x350) */
+        {1129,857,656,625},     /* ; 04 (640x480x75Hz) */
+        {1209,937,716,685},     /* ; 05 (800x600x75Hz) */
+        {9,1049,0,769} 	   	/* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDLDes1280x1024x75Data[]=         /* ;;1280x1024x75Hz */
+{
+        {18,1314,0,1025     },/* ; 00 (320x200,320x400,640x200,640x400) */
+        {18,1314,0,1025     },/* ; 01 (320x350,640x350) */
+        {18,1314,0,1025     },/* ; 02 (360x400,720x400) */
+        {18,1314,0,1025     },/* ; 03 (720x350) */
+        {18,1314,0,1025     },/* ; 04 (640x480x60Hz) */
+        {18,1314,0,1025     },/* ; 05 (800x600x60Hz) */
+        {18,1314,0,1025     },/* ; 06 (1024x768x60Hz) */
+        {18,1314,0,1025     }/* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDLDes1280x1024x75Data[]=
+{
+        {18,1314,0,1025     },/* ; 00 (320x200,320x400,640x200,640x400) */
+        {18,1314,0,1025     },/* ; 01 (320x350,640x350) */
+        {18,1314,0,1025     },/* ; 02 (360x400,720x400) */
+        {18,1314,0,1025     },/* ; 03 (720x350) */
+        {18,1314,0,1025     },/* ; 04 (640x480x60Hz) */
+        {18,1314,0,1025     },/* ; 05 (800x600x60Hz) */
+        {18,1314,0,1025     },/* ; 06 (1024x768x60Hz) */
+        {18,1314,0,1025     }/* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDLDes1280x1024x75Data[]=	/* 1280x1024x75Hz */
+{
+        {1368,1008,752,711},    /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1368,1008,729,688},    /* ; 01 (320x350,640x350) */
+        {1408,1048,752,711},    /* ; 02 (360x400,720x400) */
+        {1408,1048,729,688},    /* ; 03 (720x350) */
+        {1377,985,794,753},    /* ; 04 (640x480x75Hz) */
+        {1457,1065,854,813},    /* ; 05 (800x600x75Hz) */
+        {1569,1177,938,897},    /* ; 06 (1024x768x75Hz) */
+        {18,1314,0,1025}     	  /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_ExtLCDDes1280x1024x75Data[]=         /* ;;1280x1024x75Hz */
+{
+	{9,1305,0,1025},/* ; 00 (320x200,320x400,640x200,640x400) */
+        {9,1305,0,1025},/* ; 01 (320x350,640x350) */
+        {9,1305,0,1025},/* ; 02 (360x400,720x400) */
+        {9,1305,0,1025},/* ; 03 (720x350) */
+        {9,1305,0,1025},/* ; 04 (640x480x60Hz) */
+        {9,1305,0,1025},/* ; 05 (800x600x60Hz) */
+        {9,1305,0,1025},/* ; 06 (1024x768x60Hz) */
+        {9,1305,0,1025} /* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_StLCDDes1280x1024x75Data[]=
+{
+	{9,1305,0,1025},/* ; 00 (320x200,320x400,640x200,640x400) */
+        {9,1305,0,1025},/* ; 01 (320x350,640x350) */
+        {9,1305,0,1025},/* ; 02 (360x400,720x400) */
+        {9,1305,0,1025},/* ; 03 (720x350) */
+        {9,1305,0,1025},/* ; 04 (640x480x60Hz) */
+        {9,1305,0,1025},/* ; 05 (800x600x60Hz) */
+        {9,1305,0,1025},/* ; 06 (1024x768x60Hz) */
+        {9,1305,0,1025} /* ; 07 (1280x1024x60Hz) */
+};
+
+XGI330_LCDDataDesStruct  XGI_CetLCDDes1280x1024x75Data[]=	/* 1280x1024x75Hz */
+{
+        {1368,1008,752,711},    /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1368,1008,729,688},    /* ; 01 (320x350,640x350) */
+        {1408,1048,752,711},    /* ; 02 (360x400,720x400) */
+        {1408,1048,729,688},    /* ; 03 (720x350) */
+        {1377,985,794,753},    /* ; 04 (640x480x75Hz) */
+        {1457,1065,854,813},    /* ; 05 (800x600x75Hz) */
+        {1569,1177,938,897},    /* ; 06 (1024x768x75Hz) */
+        {9,1305,0,1025}     	  /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataDesStruct2 XGI_NoScalingDesDatax75[]= /* Scaling LCD 75Hz */
+{
+	{9,657,448,405,96,2},   /* ; 00 (320x200,320x400,640x200,640x400) */
+        {9,657,448,355,96,2},   /* ; 01 (320x350,640x350) */
+        {9,738,448,405,108,2},   /* ; 02 (360x400,720x400) */
+        {9,738,448,355,108,2},   /* ; 03 (720x350) */
+        {9,665,0,481,64,3},   /* ; 04 (640x480x75Hz) */
+        {9,825,0,601,80,3},   /* ; 05 (800x600x75Hz) */
+        {9,1049,0,769,96,3},   /* ; 06 (1024x768x75Hz) */
+        {9,1305,0,1025,144,3},   /* ; 07 (1280x1024x75Hz) */
+        {9,1457,0,1051,112,3},   /* ; 08 (1400x1050x60Hz) ;;[ycchen] 12/19/02 */
+        {9,1673,0,1201,192,3},   /* ; 09 (1600x1200x75Hz) */
+        {9,1337,0,771,112,6}    /* ; 0A (1280x768x60Hz) */
+};
+
+XGI330_TVDataStruct  XGI_StPALData[]=
+{
+ {    1,   1, 864, 525,1270, 400, 100,   0, 760},
+ {    1,   1, 864, 525,1270, 350, 100,   0, 760},
+ {    1,   1, 864, 525,1270, 400,   0,   0, 720},
+ {    1,   1, 864, 525,1270, 350,   0,   0, 720},
+ {    1,   1, 864, 525,1270, 480,  50,   0, 760},
+ {    1,   1, 864, 525,1270, 600,  50,   0,   0}
+};
+
+XGI330_TVDataStruct  XGI_ExtPALData[]=
+{
+ {    2,   1,1080, 463,1270, 500,  50,   0,  50},
+ {   15,   7,1152, 413,1270, 500,  50,   0,  50},
+ {    2,   1,1080, 463,1270, 500,  50,   0,  50},
+ {   15,   7,1152, 413,1270, 500,  50,   0,  50},
+ {    2,   1, 900, 543,1270, 500,   0,   0,  50},
+ {    4,   3,1080, 663,1270, 500, 438,   0, 438},
+ {    1,   1,1125, 831,1270, 500, 686,   0, 686},     /*301b*/
+ {    3,   2,1080, 619,1270, 540, 438,   0, 438}
+};
+
+XGI330_TVDataStruct  XGI_StNTSCData[]=
+{
+ {    1,   1, 858, 525,1270, 400,  50,   0, 760},
+ {    1,   1, 858, 525,1270, 350,  50,   0, 640},
+ {    1,   1, 858, 525,1270, 400,   0,   0, 720},
+ {    1,   1, 858, 525,1270, 350,   0,   0, 720},
+ {    1,   1, 858, 525,1270, 480,   0,   0, 760}
+};
+
+XGI330_TVDataStruct  XGI_ExtNTSCData[]=
+{
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {  143,  80, 836, 523,1270, 420, 224,   0,   0},
+ {  143, 120,1008, 643,1270, 420,   0,   1,   0},
+ {   1,    1,1120, 821,1516, 420,   0,   1,   0}, /*301b*/
+ {    2,   1, 858, 503,1584, 480,   0,   1,   0},
+ {    3,   2,1001, 533,1270, 420,   0,   0,   0}
+};
+
+XGI330_TVDataStruct  XGI_St1HiTVData[]=
+{
+    	{        1,1,892,563,690,800,0,0,0               }, /* 00 (320x200,320x400,640x200,640x400) */
+        {        1,1,892,563,690,700,0,0,0               }, /* 01 (320x350,640x350) */
+        {        1,1,1000,563,785,800,0,0,0              }, /* 02 (360x400,720x400) */
+        {        1,1,1000,563,785,700,0,0,0              }, /* 03 (720x350) */
+        {        1,1,892,563,690,960,0,0,0               }, /* 04 (320x240,640x480) */
+        {        8,5,1050,683,1648,960,0x150,1,0         }  /* 05 (400x300,800x600) */
+};
+
+XGI330_TVDataStruct  XGI_St2HiTVData[]=
+{
+        {        3,1,840,483,1648,960,0x032,0,0          }, /* 00 (320x200,320x400,640x200,640x400) */
+        {        1,1,892,563,690,700,0,0,0               }, /* 01 (320x350,640x350) */
+        {        3,1,840,483,1648,960,0x032,0,0          }, /* 02 (360x400,720x400) */
+        {        1,1,1000,563,785,700,0,0,0              }, /* 03 (720x350) */
+        {        5,2,840,563,1648,960,0x08D,1,0          }, /* 04 (320x240,640x480) */
+        {        8,5,1050,683,1648,960,0x17C,1,0         }  /* 05 (400x300,800x600) */
+
+};
+
+XGI330_TVDataStruct  XGI_ExtHiTVData[]=
+{
+        {        6,1,840,563,1632,960,0,0,0              }, /* 00 (320x200,320x400,640x200,640x400) */
+        {        3,1,960,563,1632,960,0,0,0              }, /* 01 (320x350,640x350) */
+        {        3,1,840,483,1632,960,0,0,0              }, /* 02 (360x400,720x400) */
+        {        3,1,960,563,1632,960,0,0,0              }, /* 03 (720x350) */
+        {        5,1,840,563,1648,960,0x166,1,0          }, /* 04 (320x240,640x480) */
+        {        16,5,1050,683,1648,960,0x143,1,0        }, /* 05 (400x300,800x600) */
+        {        25,12,1260,851,1648,960,0x032,0,0       }, /* 06 (512x384,1024x768) */
+        {        5,4,1575,1124,1648,960,0x128,0,0        }, /* 07 (1280x1024) */
+        {        4,1,1050,563,1548,960,0x143,1,0         }, /* 08 (800x480) */
+        {        5,2,1400,659,1648,960,0x032,0,0         }, /* 09 (1024x576) */
+        {        8,5,1750,803,1648,960,0x128,0,0         }  /* 0A (1280x720) */
+
+};
+
+XGI330_TVDataStruct  XGI_ExtYPbPr525iData[]=
+{
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {  143,  80, 836, 523,1250, 420, 224,   0,   0},
+ {  143, 120,1008, 643,1250, 420,   0,   1,   0},
+ {   1,    1,1120, 821,1516, 420,   0,   1,   0}, /*301b*/
+ {    2,   1, 858, 503,1584, 480,   0,   1,   0},
+ {    3,   2,1001, 533,1250, 420,   0,   0,   0}
+};
+
+XGI330_TVDataStruct  XGI_StYPbPr525iData[]=
+{
+ {    1,   1, 858, 525,1270, 400,  50,   0, 760},
+ {    1,   1, 858, 525,1270, 350,  50,   0, 640},
+ {    1,   1, 858, 525,1270, 400,   0,   0, 720},
+ {    1,   1, 858, 525,1270, 350,   0,   0, 720},
+ {    1,   1, 858, 525,1270, 480,   0,   0, 760},
+};
+
+XGI330_TVDataStruct  XGI_ExtYPbPr525pData[]=
+{
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {    9,  5, 1001, 453,1270, 420, 171,   0, 171},
+ {   12,  5,  858, 403,1270, 420, 171,   0, 171},
+ {  143,  80, 836, 523,1270, 420, 224,   0,   0},
+ {  143, 120,1008, 643,1270, 420,   0,   1,   0},
+ {   1,    1,1120, 821,1516, 420,   0,   1,   0}, /*301b*/
+ {    2,   1, 858, 503,1584, 480,   0,   1,   0},
+ {    3,   2,1001, 533,1270, 420,   0,   0,   0}
+ };
+
+XGI330_TVDataStruct  XGI_StYPbPr525pData[]=
+{
+ {    1,   1,1716, 525,1270, 400,  50,   0, 760},
+ {    1,   1,1716, 525,1270, 350,  50,   0, 640},
+ {    1,   1,1716, 525,1270, 400,   0,   0, 720},
+ {    1,   1,1716, 525,1270, 350,   0,   0, 720},
+ {    1,   1,1716, 525,1270, 480,   0,   0, 760},
+};
+
+XGI330_TVDataStruct  XGI_ExtYPbPr750pData[]=
+{
+ {    3,   1, 935, 470,1130, 680,  50,   0,   0},       /* 00 (320x200,320x400,640x200,640x400) */
+ {   24,   7, 935, 420,1130, 680,  50,   0,   0},       /* 01 (320x350,640x350) */
+ {    3,   1, 935, 470,1130, 680,  50,   0,   0},       /* 02 (360x400,720x400) */
+ {   24,   7, 935, 420,1130, 680,  50,   0,   0},       /* 03 (720x350) */
+ {    2,   1,1100, 590,1130, 640,  50,   0,   0},       /* 04 (320x240,640x480) */
+ {    3,   2,1210, 690,1130, 660,  50,   0,   0},       /* 05 (400x300,800x600) */
+ {    1,   1,1375, 878,1130, 640, 638,   0,   0},       /* 06 (1024x768) */
+ {    2,   1, 858, 503,1130, 480,   0,   1,   0},        /* 07 (720x480) */
+ {    5,   4,1815, 570,1130, 660,  50,   0,   0},
+ {    5,   3,1100, 686,1130, 640,  50,   1,   0},
+ {   10,   9,1320, 830,1130, 640,  50,   0,   0}
+};
+
+XGI330_TVDataStruct  XGI_StYPbPr750pData[]=
+{
+ {    1,   1,1650, 750,1280, 400,  50,   0, 760},
+ {    1,   1,1650, 750,1280, 350,  50,   0, 640},
+ {    1,   1,1650, 750,1280, 400,   0,   0, 720},
+ {    1,   1,1650, 750,1280, 350,   0,   0, 720},
+ {    1,   1,1650, 750,1280, 480,   0,   0, 760},
+};
+
+UCHAR XGI330_NTSCTiming[] = {
+  0x17,0x1d,0x03,0x09,0x05,0x06,0x0c,0x0c,
+  0x94,0x49,0x01,0x0a,0x06,0x0d,0x04,0x0a,
+  0x06,0x14,0x0d,0x04,0x0a,0x00,0x85,0x1b,
+  0x0c,0x50,0x00,0x97,0x00,0xda,0x4a,0x17,
+  0x7d,0x05,0x4b,0x00,0x00,0xe2,0x00,0x02,
+  0x03,0x0a,0x65,0x9d,0x08,0x92,0x8f,0x40,
+  0x60,0x80,0x14,0x90,0x8c,0x60,0x14,0x50,
+  0x00,0x40,0x44,0x00,0xdb,0x02,0x3b,0x00};
+
+UCHAR XGI330_PALTiming[] = {
+  0x21,0x5A,0x35,0x6e,0x04,0x38,0x3d,0x70,
+  0x94,0x49,0x01,0x12,0x06,0x3e,0x35,0x6d,
+  0x06,0x14,0x3e,0x35,0x6d,0x00,0x45,0x2b,
+  0x70,0x50,0x00,0x9b,0x00,0xd9,0x5d,0x17,
+  0x7d,0x05,0x45,0x00,0x00,0xe8,0x00,0x02,
+  0x0d,0x00,0x68,0xb0,0x0b,0x92,0x8f,0x40,
+  0x60,0x80,0x14,0x90,0x8c,0x60,0x14,0x63,
+  0x00,0x40,0x3e,0x00,0xe1,0x02,0x28,0x00};
+
+UCHAR XGI330_HiTVExtTiming[] =
+{
+      0x2D,0x60,0x2C,0x5F,0x08,0x31,0x3A,0x64,
+      0x28,0x02,0x01,0x3D,0x06,0x3E,0x35,0x6D,
+      0x06,0x14,0x3E,0x35,0x6D,0x00,0xC5,0x3F,
+      0x64,0x90,0x33,0x8C,0x18,0x36,0x3E,0x13,
+      0x2A,0xDE,0x2A,0x44,0x40,0x2A,0x44,0x40,
+      0x8E,0x8E,0x82,0x07,0x0B,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x14,0x3D,0x63,0x4F,
+      0x27,0x00,0xfc,0xff,0x6a,0x00
+
+};
+
+UCHAR XGI330_HiTVSt1Timing[] =
+{
+      0x32,0x65,0x2C,0x5F,0x08,0x31,0x3A,0x65,
+      0x28,0x02,0x01,0x3D,0x06,0x3E,0x35,0x6D,
+      0x06,0x14,0x3E,0x35,0x6D,0x00,0xC5,0x3F,
+      0x65,0x90,0x7B,0xA8,0x03,0xF0,0x87,0x03,
+      0x11,0x15,0x11,0xCF,0x10,0x11,0xCF,0x10,
+      0x35,0x35,0x3B,0x69,0x1D,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x04,0x86,0xAF,0x5D,
+      0x0E,0x00,0xfc,0xff,0x2d,0x00
+};
+
+UCHAR XGI330_HiTVSt2Timing[] =
+{
+      0x32,0x65,0x2C,0x5F,0x08,0x31,0x3A,0x64,
+      0x28,0x02,0x01,0x3D,0x06,0x3E,0x35,0x6D,
+      0x06,0x14,0x3E,0x35,0x6D,0x00,0xC5,0x3F,
+      0x64,0x90,0x33,0x8C,0x18,0x36,0x3E,0x13,
+      0x2A,0xDE,0x2A,0x44,0x40,0x2A,0x44,0x40,
+      0x8E,0x8E,0x82,0x07,0x0B,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x14,0x3D,0x63,0x4F,
+      0x27,0x00,0xFC,0xff,0x6a,0x00
+};
+
+UCHAR XGI330_HiTVTextTiming[] =
+{
+      0x32,0x65,0x2C,0x5F,0x08,0x31,0x3A,0x65,
+      0x28,0x02,0x01,0x3D,0x06,0x3E,0x35,0x6D,
+      0x06,0x14,0x3E,0x35,0x6D,0x00,0xC5,0x3F,
+      0x65,0x90,0xE7,0xBC,0x03,0x0C,0x97,0x03,
+      0x14,0x78,0x14,0x08,0x20,0x14,0x08,0x20,
+      0xC8,0xC8,0x3B,0xD2,0x26,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x04,0x96,0x72,0x5C,
+      0x11,0x00,0xFC,0xFF,0x32,0x00
+};
+
+UCHAR XGI330_YPbPr750pTiming[] =
+{
+      0x30,0x1d,0xe8,0x09,0x09,0xed,0x0c,0x0c,
+      0x98,0x0a,0x01,0x0c,0x06,0x0d,0x04,0x0a,
+      0x06,0x14,0x0d,0x04,0x0a,0x00,0x85,0x3f,
+      0xed,0x50,0x70,0x9f,0x16,0x59,0x60,0x13,
+      0x27,0x0b,0x27,0xfc,0x30,0x27,0x1c,0xb0,
+      0x4b,0x4b,0x6f,0x2f,0x63,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x14,0x73,0x00,0x40,
+      0x11,0x00,0xfc,0xff,0x32,0x00
+};
+
+UCHAR XGI330_YPbPr525pTiming[] =
+{
+      0x3E,0x11,0x06,0x09,0x0b,0x0c,0x0c,0x0c,
+      0x98,0x0a,0x01,0x0d,0x06,0x0d,0x04,0x0a,
+      0x06,0x14,0x0d,0x04,0x0a,0x00,0x85,0x3f,
+      0x0c,0x50,0xb2,0x9f,0x16,0x59,0x4f,0x13,
+      0xad,0x11,0xad,0x1d,0x40,0x8a,0x3d,0xb8,
+      0x51,0x5e,0x60,0x49,0x7d,
+      0x92,0x0F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x14,0x4B,0x43,0x41,
+      0x11,0x00,0xFC,0xFF,0x32,0x00
+};
+
+UCHAR XGI330_YPbPr525iTiming[] =
+{
+      0x1B,0x21,0x03,0x09,0x05,0x06,0x0C,0x0C,
+      0x94,0x49,0x01,0x0A,0x06,0x0D,0x04,0x0A,
+      0x06,0x14,0x0D,0x04,0x0A,0x00,0x85,0x1B,
+      0x0C,0x50,0x00,0x97,0x00,0xDA,0x4A,0x17,
+      0x7D,0x05,0x4B,0x00,0x00,0xE2,0x00,0x02,
+      0x03,0x0A,0x65,0x9D,0x08,
+      0x92,0x8F,0x40,0x60,0x80,0x14,0x90,0x8C,
+      0x60,0x14,0x4B,0x00,0x40,
+      0x44,0x00,0xDB,0x02,0x3B,0x00
+
+};
+
+UCHAR XGI330_HiTVGroup3Data[] =
+{
+      0x00,0x1A,0x22,0x63,0x62,0x22,0x08,0x5F,
+      0x05,0x21,0xB2,0xB2,0x55,0x77,0x2A,0xA6,
+      0x25,0x2F,0x47,0xFA,0xC8,0xFF,0x8E,0x20,
+      0x8C,0x6E,0x60,0x2E,0x58,0x48,0x72,0x44,
+      0x56,0x36,0x4F,0x6E,0x3F,0x80,0x00,0x80,
+      0x4F,0x7F,0x03,0xA8,0x7D,0x20,0x1A,0xA9,
+      0x14,0x05,0x03,0x7E,0x64,0x31,0x14,0x75,
+      0x18,0x05,0x18,0x05,0x4C,0xA8,0x01
+};
+
+UCHAR XGI330_HiTVGroup3Simu[] =
+{
+      0x00,0x1A,0x22,0x63,0x62,0x22,0x08,0x95,
+      0xDB,0x20,0xB8,0xB8,0x55,0x47,0x2A,0xA6,
+      0x25,0x2F,0x47,0xFA,0xC8,0xFF,0x8E,0x20,
+      0x8C,0x6E,0x60,0x15,0x26,0xD3,0xE4,0x11,
+      0x56,0x36,0x4F,0x6E,0x3F,0x80,0x00,0x80,
+      0x67,0x36,0x01,0x47,0x0E,0x10,0xBE,0xB4,
+      0x01,0x05,0x03,0x7E,0x65,0x31,0x14,0x75,
+      0x18,0x05,0x18,0x05,0x4C,0xA8,0x01
+};
+
+UCHAR XGI330_HiTVGroup3Text[] =
+{
+      0x00,0x1A,0x22,0x63,0x62,0x22,0x08,0xA7,
+      0xF5,0x20,0xCE,0xCE,0x55,0x47,0x2A,0xA6,
+      0x25,0x2F,0x47,0xFA,0xC8,0xFF,0x8E,0x20,
+      0x8C,0x6E,0x60,0x18,0x2C,0x0C,0x20,0x22,
+      0x56,0x36,0x4F,0x6E,0x3F,0x80,0x00,0x80,
+      0x93,0x3C,0x01,0x50,0x2F,0x10,0xF4,0xCA,
+      0x01,0x05,0x03,0x7E,0x65,0x31,0x14,0x75,
+      0x18,0x05,0x18,0x05,0x4C,0xA8,0x01
+};
+
+UCHAR XGI330_Ren525pGroup3[] =
+{
+  0x00,0x14,0x15,0x25,0x55,0x15,0x0b,0x13,
+  0xB1,0x41,0x62,0x62,0xFF,0xF4,0x45,0xa6,
+  0x25,0x2F,0x67,0xF6,0xbf,0xFF,0x8E,0x20,
+  0xAC,0xDA,0x60,0xFe,0x6A,0x9A,0x06,0x10,
+  0xd1,0x04,0x18,0x0a,0xFF,0x80,0x00,0x80,
+  0x3c,0x77,0x00,0xEF,0xE0,0x10,0xB0,0xE0,
+  0x10,0x4F,0x0F,0x0F,0x05,0x0F,0x08,0x6E,
+  0x1a,0x1F,0x25,0x2a,0x4C,0xAA,0x01
+};
+
+UCHAR XGI330_Ren750pGroup3[] =
+{
+  0x00,0x14,0x15,0x25,0x55,0x15,0x0b,0x7a,
+  0x54,0x41,0xE7,0xE7,0xFF,0xF4,0x45,0xa6,
+  0x25,0x2F,0x67,0xF6,0xbf,0xFF,0x8E,0x20,
+  0xAC,0x6A,0x60,0x2b,0x52,0xCD,0x61,0x10,
+  0x51,0x04,0x18,0x0a,0x1F,0x80,0x00,0x80,
+  0xFF,0xA4,0x04,0x2B,0x94,0x21,0x72,0x94,
+  0x26,0x05,0x01,0x0F,0xed,0x0F,0x0A,0x64,
+  0x18,0x1D,0x23,0x28,0x4C,0xAA,0x01
+};
+
+XGI_PanelDelayTblStruct XGI330_PanelDelayTbl[]=
+{
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}},
+{{0x00,0x00}}
+};
+
+XGI330_LVDSDataStruct  XGI330_LVDS320x480Data_1[]=
+{
+ {848, 433,400,525},
+ {848, 389,400,525},
+ {848, 433,400,525},
+ {848, 389,400,525},
+ {848, 518,400, 525},
+ {1056, 628,400,525},
+ {400, 525,400,525},
+ {800, 449,1000, 644},
+ {800, 525,1000, 635}
+};
+
+XGI330_LVDSDataStruct  XGI330_LVDS800x600Data_1[]=
+{
+ {848, 433,1060, 629},
+ {848, 389,1060, 629},
+ {848, 433,1060, 629},
+ {848, 389,1060, 629},
+ {848, 518,1060, 629},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {800, 449,1000, 644},
+ {800, 525,1000, 635}
+};
+
+XGI330_LVDSDataStruct  XGI330_LVDS800x600Data_2[]=
+{
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {800, 449,1000, 644},
+ {800, 525,1000, 635}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1024x768Data_1[]=
+{
+ { 960 , 438 , 1344 , 806 } ,	/* 00 (320x200,320x400,640x200,640x400) */
+ { 960 , 388 , 1344 , 806 } ,	/* 01 (320x350,640x350) */
+ { 1040, 438 , 1344 , 806 } ,	/* 02 (360x400,720x400) */
+ { 1040, 388 , 1344 , 806 } ,	/* 03 (720x350) */
+ { 960 , 518 , 1344 , 806 } ,	/* 04 (320x240,640x480) */
+ {1120 , 638 , 1344 , 806 } ,	/* 05 (400x300,800x600) */
+ {1344 , 806 , 1344 , 806 }	/* 06 (512x384,1024x768) */
+};
+
+
+XGI330_LVDSDataStruct  XGI_LVDS1024x768Data_2[]=
+{
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {800, 449,1280, 801},
+ {800, 525,1280, 813}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x1024Data_1[]=
+{
+ {1048, 442,1688, 1066},
+ {1048, 392,1688, 1066},
+ {1048, 442,1688, 1066},
+ {1048, 392,1688, 1066},
+ {1048, 522,1688, 1066},
+ {1208, 642,1688, 1066},
+ {1432, 810,1688, 1066},
+ {1688, 1066,1688, 1066}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x1024Data_2[]=
+{
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {800, 449,1280, 801},
+ {800, 525,1280, 813}
+};
+/*
+XGI330_LVDSDataStruct  XGI_LVDS1280x768Data_1[]=
+{
+ {768,438,1408,806},
+ {768,388,1408,806},
+ {768,438,1408,806},
+ {768,388,1408,806},
+ {768,518,1408,806},
+ {928,638,1408,806},
+ {1408,806,1408,806},
+ {1408,806,1408,806},
+ {1408,806,1408,806}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x768Data_2[]=
+{
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806},
+ {1408, 806,1408, 806}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x768NData_1[]=
+{
+ {704, 438,1344, 806},
+ {704, 388,1344, 806},
+ {704, 438,1344, 806},
+ {704, 388,1344, 806},
+ {704, 518,1344, 806},
+ {864, 638,1344, 806},
+ {1088, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x768NData_2[]=
+{
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806},
+ {1344, 806,1344, 806}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x768SData_1[]=
+{
+ {1048,438,1688,806},
+ {1048,388,1688,806},
+ {1148,438,1688,806},
+ {1148,388,1688,806},
+ {1048,518,1688,806},
+ {1208,638,1688,806},
+ {1432,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1280x768SData_2[]=
+{
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806},
+ {1688,806,1688,806}
+};
+*/
+XGI330_LVDSDataStruct  XGI_LVDS1400x1050Data_1[]=
+{
+ {928,416,1688,1066},
+ {928,366,1688,1066},
+ {928,416,1688,1066},
+ {928,366,1688,1066},
+ {928,496,1688,1066},
+ {1088,616,1688,1066},
+ {1312,784,1688,1066},
+ {1568,1040,1688,1066},
+ {1688,1066,1688,1066}
+};
+
+XGI330_LVDSDataStruct  XGI_LVDS1400x1050Data_2[]=
+{
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066},
+ {1688,1066,1688,1066}
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1600x1200Data_1[]=
+{      /* ;;[ycchen] 12/05/02 LCDHTxLCDVT=2048x1320 */
+        {        1088,520,2048,1320      },/* 00 (320x200,320x400,640x200,640x400) */
+        {        1088,470,2048,1320      },/* 01 (320x350,640x350) */
+        {        1088,520,2048,1320      },/* 02 (360x400,720x400) */
+        {        1088,470,2048,1320      },/* 03 (720x350) */
+        {        1088,600,2048,1320      },/* 04 (320x240,640x480) */
+        {        1248,720,2048,1320      },/* 05 (400x300,800x600) */
+        {        1472,888,2048,1320      },/* 06 (512x384,1024x768) */
+        {        1728,1144,2048,1320     },/* 07 (640x512,1280x1024) */
+        {        1848,1170,2048,1320     },/* 08 (1400x1050) */
+        {        2048,1320,2048,1320     } /* 09 (1600x1200) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDSNoScalingData[]=
+{
+        {        800,449,800,449             }, /* 00 (320x200,320x400,640x200,640x400) */
+        {        800,449,800,449             }, /* 01 (320x350,640x350) */
+        {        800,449,800,449             }, /* 02 (360x400,720x400) */
+        {        800,449,800,449             }, /* 03 (720x350) */
+        {        800,525,800,525             }, /* 04 (640x480x60Hz) */
+        {        1056,628,1056,628           }, /* 05 (800x600x60Hz) */
+        {        1344,806,1344,806           }, /* 06 (1024x768x60Hz) */
+        {        1688,1066,1688,1066         }, /* 07 (1280x1024x60Hz) */
+        {        1688,1066,1688,1066         }, /* 08 (1400x1050x60Hz) ;;[ycchen] 12/19/02 */
+        {        2160,1250,2160,1250         }, /* 09 (1600x1200x60Hz) */
+        {        1688,806,1688,806           }  /* 0A (1280x768x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Data_1x75[]=
+{
+	{960,438,1312,800  }, /* 00 (320x200,320x400,640x200,640x400) */
+        {960,388,1312,800  }, /* 01 (320x350,640x350) */
+        {1040,438,1312,800 }, /* 02 (360x400,720x400) */
+        {1040,388,1312,800 }, /* 03 (720x350) */
+        {928,512,1312,800  }, /* 04 (320x240,640x480) */
+        {1088,632,1312,800 }, /* 05 (400x300,800x600) */
+        {1312,800,1312,800 }, /* 06 (512x384,1024x768) */
+};
+
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Data_2x75[]=
+{
+        {1312,800,1312,800}, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1312,800,1312,800}, /* ; 01 (320x350,640x350) */
+        {1312,800,1312,800}, /* ; 02 (360x400,720x400) */
+        {1312,800,1312,800}, /* ; 03 (720x350) */
+        {1312,800,1312,800}, /* ; 04 (320x240,640x480) */
+        {1312,800,1312,800}, /* ; 05 (400x300,800x600) */
+        {1312,800,1312,800}, /* ; 06 (512x384,1024x768) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Data_1x75[]=
+{
+        {1048,442,1688,1066  }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1048,392,1688,1066  }, /* ; 01 (320x350,640x350) */
+        {1128,442,1688,1066  }, /* ; 02 (360x400,720x400) */
+        {1128,392,1688,1066  }, /* ; 03 (720x350) */
+        {1048,522,1688,1066  }, /* ; 04 (320x240,640x480) */
+        {1208,642,1688,1066  }, /* ; 05 (400x300,800x600) */
+        {1432,810,1688,1066  }, /* ; 06 (512x384,1024x768) */
+        {1688,1066,1688,1066 }, /* ; 06; 07 (640x512,1280x1024) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Data_2x75[]=
+{
+        {1688,1066,1688,1066 }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1688,1066,1688,1066 }, /* ; 01 (320x350,640x350) */
+        {1688,1066,1688,1066 }, /* ; 02 (360x400,720x400) */
+        {1688,1066,1688,1066 }, /* ; 03 (720x350) */
+        {1688,1066,1688,1066 }, /* ; 04 (320x240,640x480) */
+        {1688,1066,1688,1066 }, /* ; 05 (400x300,800x600) */
+        {1688,1066,1688,1066 }, /* ; 06 (512x384,1024x768) */
+        {1688,1066,1688,1066 }, /* ; 06; 07 (640x512,1280x1024) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDSNoScalingDatax75[]=
+{
+        {800,449,800,449     }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {800,449,800,449     }, /* ; 01 (320x350,640x350) */
+        {900,449,900,449     }, /* ; 02 (360x400,720x400) */
+        {900,449,900,449     }, /* ; 03 (720x350) */
+        {800,500,800,500     }, /* ; 04 (640x480x75Hz) */
+        {1056,625,1056,625   }, /* ; 05 (800x600x75Hz) */
+        {1312,800,1312,800   }, /* ; 06 (1024x768x75Hz) */
+        {1688,1066,1688,1066 }, /* ; 07 (1280x1024x75Hz) */
+        {1688,1066,1688,1066 }, /* ; 08 (1400x1050x75Hz) ;;[ycchen] 12/19/02 */
+        {2160,1250,2160,1250 }, /* ; 09 (1600x1200x75Hz) */
+        {1688,806,1688,806   }, /* ; 0A (1280x768x75Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_1[]=
+{
+	{      0,1048,   0, 771     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      0,1048,   0, 771     }, /* 01 (320x350,640x350) */
+        {      0,1048,   0, 771     }, /* 02 (360x400,720x400) */
+        {      0,1048,   0, 771     }, /* 03 (720x350) */
+        {      0,1048,   0, 771     }, /* 04 (640x480x60Hz) */
+        {      0,1048,   0, 771     }, /* 05 (800x600x60Hz) */
+        {      0,1048, 805, 770     }  /* 06 (1024x768x60Hz) */
+} ;
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_2[]=
+{
+    	{      1142, 856, 622, 587     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1142, 856, 597, 562     }, /* 01 (320x350,640x350) */
+        {      1142, 856, 622, 587     }, /* 02 (360x400,720x400) */
+        {      1142, 856, 597, 562     }, /* 03 (720x350) */
+        {      1142,1048, 722, 687     }, /* 04 (640x480x60Hz) */
+        {      1232, 936, 722, 687     }, /* 05 (800x600x60Hz) */
+        {         0,1048, 805, 771     }  /* 06 (1024x768x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_3[]=
+{
+    	{       320,  24, 622, 587     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {       320,  24, 597, 562     }, /* 01 (320x350,640x350) */
+        {       320,  24, 622, 587     }, /* 02 (360x400,720x400) */
+        {       320,  24, 597, 562     }, /* 03 (720x350) */
+        {       320,  24, 722, 687     }  /* 04 (640x480x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Des_1[]=
+{
+    	{      0,1328,    0, 1025     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      0,1328,    0, 1025     }, /* 01 (320x350,640x350) */
+        {      0,1328,    0, 1025     }, /* 02 (360x400,720x400) */
+        {      0,1328,    0, 1025     }, /* 03 (720x350) */
+        {      0,1328,    0, 1025     }, /* 04 (640x480x60Hz) */
+        {      0,1328,    0, 1025     }, /* 05 (800x600x60Hz) */
+        {      0,1328,    0, 1025     }, /* 06 (1024x768x60Hz) */
+        {      0,1328, 1065, 1024     }  /* 07 (1280x1024x60Hz) */
+};
+
+ /* The Display setting for DE Mode Panel */
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Des_2[]=
+{
+    	{      1368,1008,752,711     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1368,1008,729,688     }, /* 01 (320x350,640x350) */
+        {      1408,1048,752,711     }, /* 02 (360x400,720x400) */
+        {      1408,1048,729,688     }, /* 03 (720x350) */
+        {      1368,1008,794,753     }, /* 04 (640x480x60Hz) */
+        {      1448,1068,854,813     }, /* 05 (800x600x60Hz) */
+        {      1560,1200,938,897     }, /* 06 (1024x768x60Hz) */
+        {      0000,1328,0,1025     }  /* 07 (1280x1024x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1400x1050Des_1[]=
+{
+    	{      0,1448,0,1051     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      0,1448,0,1051     }, /* 01 (320x350,640x350) */
+        {      0,1448,0,1051     }, /* 02 (360x400,720x400) */
+        {      0,1448,0,1051     }, /* 03 (720x350) */
+        {      0,1448,0,1051     }, /* 04 (640x480x60Hz) */
+        {      0,1448,0,1051     }, /* 05 (800x600x60Hz) */
+        {      0,1448,0,1051     }, /* 06 (1024x768x60Hz) */
+        {      0,1448,0,1051     }, /* 07 (1280x1024x60Hz) */
+        {      0,1448,0,1051     }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1400x1050Des_2[]=
+{
+    	{      1308,1068, 781, 766     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      1308,1068, 781, 766     }, /* 01 (320x350,640x350) */
+        {      1308,1068, 781, 766     }, /* 02 (360x400,720x400) */
+        {      1308,1068, 781, 766     }, /* 03 (720x350) */
+        {      1308,1068, 781, 766     }, /* 04 (640x480x60Hz) */
+        {      1388,1148, 841, 826     }, /* 05 (800x600x60Hz) */
+        {      1490,1250, 925, 910     }, /* 06 (1024x768x60Hz) */
+        {      1608,1368,1053,1038     }, /* 07 (1280x1024x60Hz) */
+        {      0,1448,0,1051     }  /* 08 (1400x1050x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1600x1200Des_1[]=
+{
+    	{      0,1664,0,1201     }, /* 00 (320x200,320x400,640x200,640x400) */
+        {      0,1664,0,1201     }, /* 01 (320x350,640x350) */
+        {      0,1664,0,1201     }, /* 02 (360x400,720x400) */
+        {      0,1664,0,1201     }, /* 03 (720x350) */
+        {      0,1664,0,1201     }, /* 04 (640x480x60Hz) */
+        {      0,1664,0,1201     }, /* 05 (800x600x60Hz) */
+        {      0,1664,0,1201     }, /* 06 (1024x768x60Hz) */
+        {      0,1664,0,1201     }, /* 07 (1280x1024x60Hz) */
+        {      0,1664,0,1201     }, /* 08 (1400x1050x60Hz) */
+        {      0,1664,0,1201     }  /* 09 (1600x1200x60Hz) */
+};
+
+
+
+XGI330_LCDDataDesStruct2  XGI_LVDSNoScalingDesData[]=
+{
+    	{     0, 648, 448, 405,  96,   2   }, /* 00 (320x200,320x400,640x200,640x400) */
+        {     0, 648, 448, 355,  96,   2   }, /* 01 (320x350,640x350) */
+        {     0, 648, 448, 405,  96,   2   }, /* 02 (360x400,720x400) */
+        {     0, 648, 448, 355,  96,   2   }, /* 03 (720x350) */
+        {     0, 648,  1, 483,  96,   2   }, /* 04 (640x480x60Hz) */
+        {     0, 840, 627, 600, 128,   4   }, /* 05 (800x600x60Hz) */
+        {     0,1048, 805, 770, 136,   6   }, /* 06 (1024x768x60Hz) */
+        {     0,1328,0,1025, 112,   3   }, /* 07 (1280x1024x60Hz) */
+        {     0,1438,0,1051, 112,   3   }, /* 08 (1400x1050x60Hz) ;;[ycchen] 12/19/02 */
+        {     0,1664,0,1201, 192,   3   }, /* 09 (1600x1200x60Hz) */
+        {     0,1328,0,0771, 112,   6   }  /* 0A (1280x768x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_1x75[]=			/* ; 1024x768 Full-screen */
+{
+        {0,1040,0,769}, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {0,1040,0,769}, /* ; 01 (320x350,640x350) */
+        {0,1040,0,769}, /* ; 02 (360x400,720x400) */
+        {0,1040,0,769}, /* ; 03 (720x350) */
+        {0,1040,0,769}, /* ; 04 (640x480x75Hz) */
+        {0,1040,0,769}, /* ; 05 (800x600x75Hz) */
+        {0,1040,0,769} /* ; 06 (1024x768x75Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_2x75[]= /* ; 1024x768 center-screen (Enh. Mode) */
+{
+        {1142, 856,622,587 }, /* 00 (320x200,320x400,640x200,640x400) */
+        {1142, 856,597,562 }, /* 01 (320x350,640x350) */
+        {1142, 856,622,587 }, /* 02 (360x400,720x400) */
+        {1142, 856,597,562 }, /* 03 (720x350) */
+        {1142,1048,722,687 }, /* 04 (640x480x60Hz) */
+        {1232, 936,722,687 }, /* 05 (800x600x60Hz) */
+        {   0,1048,805,771 }  /* 06 (1024x768x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1024x768Des_3x75[]= /* ; 1024x768 center-screen (St.Mode) */
+{
+        {320,24,622,587  }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {320,24,597,562  }, /* ; 01 (320x350,640x350) */
+        {320,24,622,587  }, /* ; 02 (360x400,720x400) */
+        {320,24,597,562  }, /* ; 03 (720x350) */
+        {320,24,722,687  } /* ; 04 (640x480x60Hz) */
+};
+
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Des_1x75[]=
+{
+        {0,1296,0,1025}, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {0,1296,0,1025}, /* ; 01 (320x350,640x350) */
+        {0,1296,0,1025}, /* ; 02 (360x400,720x400) */
+        {0,1296,0,1025}, /* ; 03 (720x350) */
+        {0,1296,0,1025}, /* ; 04 (640x480x75Hz) */
+        {0,1296,0,1025}, /* ; 05 (800x600x75Hz) */
+        {0,1296,0,1025}, /* ; 06 (1024x768x75Hz) */
+        {0,1296,0,1025} /* ; 07 (1280x1024x75Hz) */
+};
+
+/* The Display setting for DE Mode Panel */
+XGI330_LVDSDataStruct XGI_LVDS1280x1024Des_2x75[]=   /* [ycchen] 02/18/03 Set DE as default */
+{
+        {1368,976,752,711 }, /* ; 00 (320x200,320x400,640x200,640x400) */
+        {1368,976,729,688 }, /* ; 01 (320x350,640x350) */
+        {1408,976,752,711 }, /* ; 02 (360x400,720x400) */
+        {1408,976,729,688 }, /* ; 03 (720x350) */
+        {1368,976,794,753 }, /* ; 04 (640x480x75Hz) */
+        {1448,1036,854,813}, /* ; 05 (800x600x75Hz) */
+        {1560,1168,938,897}, /* ; 06 (1024x768x75Hz) */
+        {0,1296,0,1025    } /* ; 07 (1280x1024x75Hz) */
+};
+
+XGI330_LCDDataDesStruct2 XGI_LVDSNoScalingDesDatax75[]=  /* Scaling LCD 75Hz */
+{
+       { 0,648,448,405,96,2  }, /* ; 00 (320x200,320x400,640x200,640x400) */
+       { 0,648,448,355,96,2  }, /* ; 01 (320x350,640x350) */
+       { 0,729,448,405,108,2 }, /* ; 02 (360x400,720x400) */
+       { 0,729,448,355,108,2 }, /* ; 03 (720x350) */
+       { 0,656,0,481,64,3    }, /* ; 04 (640x480x75Hz) */
+       { 0,816,0,601,80,3    }, /* ; 05 (800x600x75Hz) */
+       { 0,1040,0,769,96,3   }, /* ; 06 (1024x768x75Hz) */
+       { 0,1296,0,1025,144,3 }, /* ; 07 (1280x1024x75Hz) */
+       { 0,1448,0,1051,112,3 }, /* ; 08 (1400x1050x75Hz) ;;[ycchen] 12/19/02 */
+       { 0,1664,0,1201,192,3 }, /* ; 09 (1600x1200x75Hz) */
+       { 0,1328,0,771,112,6  }  /* ; 0A (1280x768x75Hz) */
+};
+
+XGI330_LVDSDataStruct  XGI330_LVDS640x480Data_1[]=
+{
+ {800, 449, 800, 449},
+ {800, 449, 800, 449},
+ {800, 449, 800, 449},
+ {800, 449, 800, 449},
+ {800, 525, 800, 525},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628},
+ {1056, 628,1056, 628}
+};
+
+XGI330_CHTVDataStruct  XGI_CHTVUNTSCData[]=
+{
+ {840, 600, 840, 600},
+ {840, 600, 840, 600},
+ {840, 600, 840, 600},
+ {840, 600, 840, 600},
+ {784, 600, 784, 600},
+ {1064, 750,1064, 750}
+};
+
+XGI330_CHTVDataStruct  XGI_CHTVONTSCData[]=
+{
+ {840, 525, 840, 525},
+ {840, 525, 840, 525},
+ {840, 525, 840, 525},
+ {840, 525, 840, 525},
+ {784, 525, 784, 525},
+ {1040, 700,1040, 700}
+};
+
+XGI330_CHTVDataStruct  XGI_CHTVUPALData[]=
+{
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {840, 750, 840, 750},
+ {936, 836, 936, 836}
+};
+
+XGI330_CHTVDataStruct  XGI_CHTVOPALData[]=
+{
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {1008, 625,1008, 625},
+ {840, 625, 840, 625},
+ {960, 750, 960, 750}
+};
+
+XGI_LVDSCRT1HDataStruct  XGI_LVDSCRT11024x768_1_H[]=
+{
+	        /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x4B,0x27,0x8F,0x32,0x1B,0x00,0x45,0x00 }}, /* 00 (320x) */
+                {{      0x4B,0x27,0x8F,0x2B,0x03,0x00,0x44,0x00 }}, /* 01 (360x) */
+                {{      0x55,0x31,0x99,0x46,0x1D,0x00,0x55,0x00 }}, /* 02 (400x) */
+                {{      0x63,0x3F,0x87,0x4A,0x93,0x00,0x01,0x00 }}, /* 03 (512x) */
+                {{      0x73,0x4F,0x97,0x55,0x86,0x00,0x05,0x00 }}, /* 04 (640x) */
+                {{      0x73,0x4F,0x97,0x55,0x86,0x00,0x05,0x00 }}, /* 05 (720x) */
+                {{      0x87,0x63,0x8B,0x69,0x1A,0x00,0x26,0x00 }}, /* 06 (800x) */
+                {{      0xA3,0x7F,0x87,0x86,0x97,0x00,0x02,0x00 }} /* 07 (1024x) */
+};
+
+XGI_LVDSCRT1HDataStruct  XGI_LVDSCRT11280x1024_1_H[]=
+{
+		/* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x56,0x27,0x9A,0x30,0x1E,0x00,0x05,0x00 }}, /* 00 (320x) */
+                {{      0x56,0x27,0x9A,0x30,0x1E,0x00,0x05,0x00 }}, /* 01 (360x) */
+                {{      0x60,0x31,0x84,0x3A,0x88,0x00,0x01,0x00 }}, /* 02 (400x) */
+                {{      0x6E,0x3F,0x92,0x48,0x96,0x00,0x01,0x00 }}, /* 03 (512x) */
+                {{      0x7E,0x4F,0x82,0x58,0x06,0x00,0x06,0x00 }}, /* 04 (640x) */
+                {{      0x7E,0x4F,0x82,0x58,0x06,0x00,0x06,0x00 }}, /* 05 (720x) */
+                {{      0x92,0x63,0x96,0x6C,0x1A,0x00,0x06,0x00 }}, /* 06 (800x) */
+                {{      0xAE,0x7F,0x92,0x88,0x96,0x00,0x02,0x00 }}, /* 07 (1024x) */
+                {{      0xCE,0x9F,0x92,0xA8,0x16,0x00,0x07,0x00 }} /* 08 (1280x) */
+};
+
+XGI_LVDSCRT1HDataStruct  XGI_LVDSCRT11024x768_2_H[]=
+{
+		/* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x63,0x27,0x87,0x3B,0x8C,0x00,0x01,0x00 }}, /* 00 (320x) */
+                {{      0x63,0x27,0x87,0x3B,0x8C,0x00,0x01,0x00 }}, /* 01 (360x) */
+                {{      0x63,0x31,0x87,0x3D,0x8E,0x00,0x01,0x00 }}, /* 02 (400x) */
+                {{      0x63,0x3F,0x87,0x45,0x96,0x00,0x01,0x00 }}, /* 03 (512x) */
+                {{      0xA3,0x4F,0x87,0x6E,0x9F,0x00,0x06,0x00 }}, /* 04 (640x) */
+                {{      0xA3,0x4F,0x87,0x6E,0x9F,0x00,0x06,0x00 }}, /* 05 (720x) */
+                {{      0xA3,0x63,0x87,0x78,0x89,0x00,0x02,0x00 }}, /* 06 (800x) */
+                {{      0xA3,0x7F,0x87,0x86,0x97,0x00,0x02,0x00 }} /* 07 (1024x) */
+};
+
+XGI_LVDSCRT1HDataStruct  XGI_LVDSCRT11280x1024_2_H[]=
+{
+                /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x7E,0x3B,0x9A,0x44,0x12,0x00,0x01,0x00 }}, /* 00 (320x) */
+                {{      0x7E,0x3B,0x9A,0x44,0x12,0x00,0x01,0x00 }}, /* 01 (360x) */
+                {{      0x7E,0x40,0x84,0x49,0x91,0x00,0x01,0x00 }}, /* 02 (400x) */
+                {{      0x7E,0x47,0x93,0x50,0x9E,0x00,0x01,0x00 }}, /* 03 (512x) */
+                {{      0xCE,0x77,0x8A,0x80,0x8E,0x00,0x02,0x00 }}, /* 04 (640x) */
+                {{      0xCE,0x77,0x8A,0x80,0x8E,0x00,0x02,0x00 }}, /* 05 (720x) */
+                {{      0xCE,0x81,0x94,0x8A,0x98,0x00,0x02,0x00 }}, /* 06 (800x) */
+                {{      0xCE,0x8F,0x82,0x98,0x06,0x00,0x07,0x00 }}, /* 07 (1024x) */
+                {{      0xCE,0x9F,0x92,0xA8,0x16,0x00,0x07,0x00 }} /* 08 (1280x) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11400x1050_1_H[]=
+{               /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x47,0x27,0x8B,0x2C,0x1A,0x00,0x05,0x00 }}, /* 00 (320x) */
+                {{      0x47,0x27,0x8B,0x30,0x1E,0x00,0x05,0x00 }}, /* 01 (360x) */
+                {{      0x51,0x31,0x95,0x36,0x04,0x00,0x01,0x00 }}, /* 02 (400x) */
+                {{      0x5F,0x3F,0x83,0x44,0x92,0x00,0x01,0x00 }}, /* 03 (512x) */
+                {{      0x6F,0x4F,0x93,0x54,0x82,0x00,0x05,0x00 }}, /* 04 (640x) */
+                {{      0x6F,0x4F,0x93,0x54,0x82,0x00,0x05,0x00 }}, /* 05 (720x) */
+                {{      0x83,0x63,0x87,0x68,0x16,0x00,0x06,0x00 }}, /* 06 (800x) */
+                {{      0x9F,0x7F,0x83,0x84,0x92,0x00,0x02,0x00 }}, /* 07 (1024x) */
+                {{      0xBF,0x9F,0x83,0xA4,0x12,0x00,0x07,0x00 }}, /* 08 (1280x) */
+                {{      0xCE,0xAE,0x92,0xB3,0x01,0x00,0x03,0x00 }} /* 09 (1400x) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11400x1050_2_H[]=
+{               /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x76,0x3F,0x83,0x45,0x8C,0x00,0x41,0x00 }}, /* 00 (320x) */
+                {{      0x76,0x3F,0x83,0x45,0x8C,0x00,0x41,0x00 }}, /* 01 (360x) */
+                {{      0x76,0x31,0x9A,0x48,0x9F,0x00,0x41,0x00 }}, /* 02 (400x) */
+                {{      0x76,0x3F,0x9A,0x4F,0x96,0x00,0x41,0x00 }}, /* 03 (512x) */
+                {{      0xCE,0x7E,0x82,0x87,0x9E,0x00,0x02,0x00 }}, /* 04 (640x) */
+                {{      0xCE,0x7E,0x82,0x87,0x9E,0x00,0x02,0x00 }}, /* 05 (720x) */
+                {{      0xCE,0x63,0x92,0x96,0x04,0x00,0x07,0x00 }}, /* 06 (800x) */
+                {{      0xCE,0x7F,0x92,0xA4,0x12,0x00,0x07,0x00 }}, /* 07 (1024x) */
+                {{      0xCE,0x9F,0x92,0xB4,0x02,0x00,0x03,0x00 }}, /* 08 (1280x) */
+                {{      0xCE,0xAE,0x92,0xBC,0x0A,0x00,0x03,0x00 }} /* 09 (1400x) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11600x1200_1_H[]=
+/* ;302lv channelA [ycchen] 12/05/02 LCDHT=2048 */
+{   /* ; CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+                {{      0x5B,0x27,0x9F,0x32,0x0A,0x00,0x01,0x00 }},/* 00 (320x) */
+                {{      0x5B,0x27,0x9F,0x32,0x0A,0x00,0x01,0x00 }},/* 01 (360x) */
+                {{      0x65,0x31,0x89,0x3C,0x94,0x00,0x01,0x00 }},/* 02 (400x) */
+                {{      0x73,0x3F,0x97,0x4A,0x82,0x00,0x05,0x00 }},/* 03 (512x) */
+                {{      0x83,0x4F,0x87,0x51,0x09,0x00,0x06,0x00 }},/* 04 (640x) */
+		{{      0x83,0x4F,0x87,0x51,0x09,0x00,0x06,0x00 }},/* 05 (720x) */
+		{{      0x97,0x63,0x9B,0x65,0x1D,0x00,0x06,0xF0 }},/* 06 (800x) */
+		{{      0xB3,0x7F,0x97,0x81,0x99,0x00,0x02,0x00 }},/* 07 (1024x) */
+		{{      0xD3,0x9F,0x97,0xA1,0x19,0x00,0x07,0x00 }},/* 08 (1280x) */
+		{{      0xE2,0xAE,0x86,0xB9,0x91,0x00,0x03,0x00 }},/* 09 (1400x) */
+		{{      0xFB,0xC7,0x9F,0xC9,0x81,0x00,0x07,0x00 }} /* 0A (1600x) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11024x768_1_V[]=
+{               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A+CR09(5->7) */
+                {{      0x97,0x1F,0x60,0x87,0x5D,0x83,0x10      }}, /* 00 (x350) */
+                {{      0xB4,0x1F,0x92,0x89,0x8F,0xB5,0x30      }}, /* 01 (x400) */
+                {{      0x04,0x3E,0xE2,0x89,0xDF,0x05,0x00      }}, /* 02 (x480) */
+                {{      0x7C,0xF0,0x5A,0x8F,0x57,0x7D,0xA0      }}, /* 03 (x600) */
+                {{      0x24,0xF5,0x02,0x88,0xFF,0x25,0x90      }} /* 04 (x768) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11024x768_2_V[]=
+{               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+                {{      0x24,0xBB,0x31,0x87,0x5D,0x25,0x30      }}, /* 00 (x350) */
+                {{      0x24,0xBB,0x4A,0x80,0x8F,0x25,0x30      }}, /* 01 (x400) */
+                {{      0x24,0xBB,0x72,0x88,0xDF,0x25,0x30      }}, /* 02 (x480) */
+                {{      0x24,0xF1,0xAE,0x84,0x57,0x25,0xB0      }}, /* 03 (x600) */
+                {{      0x24,0xF5,0x02,0x88,0xFF,0x25,0x90      }} /* 04 (x768) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11280x1024_1_V[]=
+{               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+                {{       0x86,0x1F,0x5E,0x82,0x5D,0x87,0x00     }}, /* 00 (x350) */
+                {{       0xB8,0x1F,0x90,0x84,0x8F,0xB9,0x30     }}, /* 01 (x400) */
+                {{       0x08,0x3E,0xE0,0x84,0xDF,0x09,0x00     }}, /* 02 (x480) */
+                {{       0x80,0xF0,0x58,0x8C,0x57,0x81,0xA0     }}, /* 03 (x600) */
+                {{       0x28,0xF5,0x00,0x84,0xFF,0x29,0x90     }}, /* 04 (x768) */
+                {{       0x28,0x5A,0x13,0x87,0xFF,0x29,0xA9     }} /* 05 (x1024) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11280x1024_2_V[]=
+{               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+                {{      0x28,0xD2,0xAF,0x83,0xAE,0xD8,0xA1      }}, /* 00 (x350) */
+                {{      0x28,0xD2,0xC8,0x8C,0xC7,0xF2,0x81      }}, /* 01 (x400) */
+                {{      0x28,0xD2,0xF0,0x84,0xEF,0x1A,0xB1      }}, /* 02 (x480) */
+                {{      0x28,0xDE,0x2C,0x8F,0x2B,0x56,0x91      }}, /* 03 (x600) */
+                {{      0x28,0xDE,0x80,0x83,0x7F,0xAA,0x91      }}, /* 04 (x768) */
+                {{      0x28,0x5A,0x13,0x87,0xFF,0x29,0xA9      }} /* 05 (x1024) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11400x1050_1_V[]=
+{               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+                {{      0x6C,0x1F,0x60,0x84,0x5D,0x6D,0x10      }}, /* 00 (x350) */
+                {{      0x9E,0x1F,0x93,0x86,0x8F,0x9F,0x30      }}, /* 01 (x400) */
+                {{      0xEE,0x1F,0xE2,0x86,0xDF,0xEF,0x10      }}, /* 02 (x480) */
+                {{      0x66,0xF0,0x5A,0x8e,0x57,0x67,0xA0      }}, /* 03 (x600) */
+                {{      0x0E,0xF5,0x02,0x86,0xFF,0x0F,0x90      }}, /* 04 (x768) */
+                {{      0x0E,0x5A,0x02,0x86,0xFF,0x0F,0x89      }}, /* 05 (x1024) */
+                {{      0x28,0x10,0x1A,0x80,0x19,0x29,0x0F      }} /* 06 (x1050) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11400x1050_2_V[]=
+{              /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+                {{      0x28,0x92,0xB6,0x83,0xB5,0xCF,0x81      }}, /* 00 (x350) */
+                {{      0x28,0x92,0xD5,0x82,0xD4,0xEE,0x81      }}, /* 01 (x400) */
+                {{      0x28,0x92,0xFD,0x8A,0xFC,0x16,0xB1      }}, /* 02 (x480) */
+                {{      0x28,0xD4,0x39,0x86,0x57,0x29,0x81      }}, /* 03 (x600) */
+                {{      0x28,0xD4,0x8D,0x9A,0xFF,0x29,0xA1      }}, /* 04 (x768) */
+                {{      0x28,0x5A,0x0D,0x9A,0xFF,0x29,0xA9      }}, /* 05 (x1024) */
+                {{      0x28,0x10,0x1A,0x87,0x19,0x29,0x8F      }} /* 06 (x1050) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11600x1200_1_V[]=
+{
+               /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A+CR09(5->7) */
+                {{      0xd4,0x1F,0x81,0x84,0x5D,0xd5,0x10      }}, /* 00 (x350) */
+                {{      0x06,0x3e,0xb3,0x86,0x8F,0x07,0x20      }}, /* 01 (x400) */
+                {{      0x56,0xba,0x03,0x86,0xDF,0x57,0x00      }}, /* 02 (x480) */
+                {{      0xce,0xF0,0x7b,0x8e,0x57,0xcf,0xa0      }}, /* 03 (x600) */
+                {{      0x76,0xF5,0x23,0x86,0xFF,0x77,0x90      }}, /* 04 (x768) */
+                {{      0x76,0x5A,0x23,0x86,0xFF,0x77,0x89      }}, /* 05 (x1024) */
+                {{      0x90,0x10,0x1A,0x8E,0x19,0x91,0x2F      }}, /* 06 (x1050) */
+                {{      0x26,0x11,0xd3,0x86,0xaF,0x27,0x3f      }} /* 07 (x1200) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11024x768_1_Hx75[]=
+{ 	/* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+    {{      0x4B,0x27,0x8F,0x32,0x1B,0x00,0x45,0x00 }},/* ; 00 (320x) */
+    {{      0x4B,0x27,0x8F,0x2B,0x03,0x00,0x44,0x00 }},/* ; 01 (360x) */
+    {{      0x55,0x31,0x99,0x46,0x1D,0x00,0x55,0x00 }},/* ; 02 (400x) */
+    {{      0x63,0x3F,0x87,0x4A,0x93,0x00,0x01,0x00 }},/* ; 03 (512x) */
+    {{      0x6F,0x4F,0x93,0x54,0x80,0x00,0x05,0x00 }},/* ; 04 (640x) */
+    {{      0x6F,0x4F,0x93,0x54,0x80,0x00,0x05,0x00 }},/* ; 05 (720x) */
+    {{      0x83,0x63,0x87,0x68,0x14,0x00,0x26,0x00 }},/* ; 06 (800x) */
+    {{      0x9F,0x7F,0x83,0x85,0x91,0x00,0x02,0x00 }} /* ; 07 (1024x) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11024x768_1_Vx75[]=
+{	/* CR06,CR07,CR10,CR11,CR15,CR16,SR0A+CR09(5->7) */
+    {{      0x97,0x1F,0x60,0x87,0x5D,0x83,0x10      }},/* ; 00 (x350) */
+    {{      0xB4,0x1F,0x92,0x89,0x8F,0xB5,0x30      }},/* ; 01 (x400) */
+    {{      0xFE,0x1F,0xE0,0x84,0xDF,0xFF,0x10      }},/* ; 02 (x480) */
+    {{      0x76,0xF0,0x58,0x8C,0x57,0x77,0xA0      }},/* ; 03 (x600) */
+    {{      0x1E,0xF5,0x00,0x83,0xFF,0x1F,0x90      }} /* ; 04 (x768) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11024x768_2_Hx75[]=
+{       /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+    {{      0x63,0x27,0x87,0x3B,0x8C,0x00,0x01,0x00 }},/* ; 00 (320x) */
+    {{      0x63,0x27,0x87,0x3B,0x8C,0x00,0x01,0x00 }},/* ; 01 (360x) */
+    {{      0x63,0x31,0x87,0x3D,0x8E,0x00,0x01,0x00 }},/* ; 02 (400x) */
+    {{      0x63,0x3F,0x87,0x45,0x96,0x00,0x01,0x00 }},/* ; 03 (512x) */
+    {{      0xA3,0x4F,0x87,0x6E,0x9F,0x00,0x06,0x00 }},/* ; 04 (640x) */
+    {{      0xA3,0x4F,0x87,0x6E,0x9F,0x00,0x06,0x00 }},/* ; 05 (720x) */
+    {{      0xA3,0x63,0x87,0x78,0x89,0x00,0x02,0x00 }},/* ; 06 (800x) */
+    {{      0xA3,0x7F,0x87,0x86,0x97,0x00,0x02,0x00 }} /* ; 07 (1024x) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11024x768_2_Vx75[]=
+{       /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+    {{      0x24,0xBB,0x31,0x87,0x5D,0x25,0x30      }},/* ; 00 (x350) */
+    {{      0x24,0xBB,0x4A,0x80,0x8F,0x25,0x30      }},/* ; 01 (x400) */
+    {{      0x24,0xBB,0x72,0x88,0xDF,0x25,0x30      }},/* ; 02 (x480) */
+    {{      0x24,0xF1,0xAE,0x84,0x57,0x25,0xB0      }},/* ; 03 (x600) */
+    {{      0x24,0xF5,0x02,0x88,0xFF,0x25,0x90      }} /* ; 04 (x768) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11280x1024_1_Hx75[]=
+{      /* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+    {{      0x56,0x27,0x9A,0x30,0x1E,0x00,0x05,0x00 }},/* ; 00 (320x) */
+    {{      0x56,0x27,0x9A,0x30,0x1E,0x00,0x05,0x00 }},/* ; 01 (360x) */
+    {{      0x60,0x31,0x84,0x3A,0x88,0x00,0x01,0x00 }},/* ; 02 (400x) */
+    {{      0x6E,0x3F,0x92,0x48,0x96,0x00,0x01,0x00 }},/* ; 03 (512x) */
+    {{      0x7E,0x4F,0x82,0x54,0x06,0x00,0x06,0x00 }},/* ; 04 (640x) */
+    {{      0x7E,0x4F,0x82,0x54,0x06,0x00,0x06,0x00 }},/* ; 05 (720x) */
+    {{      0x92,0x63,0x96,0x68,0x1A,0x00,0x06,0x00 }},/* ; 06 (800x) */
+    {{      0xAE,0x7F,0x92,0x84,0x96,0x00,0x02,0x00 }},/* ; 07 (1024x) */
+    {{      0xCE,0x9F,0x92,0xA5,0x17,0x00,0x07,0x00 }} /* ; 08 (1280x) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11280x1024_1_Vx75[]=
+{	/* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+    {{      0x86,0xD1,0xBC,0x80,0xBB,0xE5,0x00      }},/* ; 00 (x350) */
+    {{      0xB8,0x1F,0x90,0x84,0x8F,0xB9,0x30      }},/* ; 01 (x400) */
+    {{      0x08,0x3E,0xE0,0x84,0xDF,0x09,0x00      }},/* ; 02 (x480) */
+    {{      0x80,0xF0,0x58,0x8C,0x57,0x81,0xA0      }},/* ; 03 (x600) */
+    {{      0x28,0xF5,0x00,0x84,0xFF,0x29,0x90      }},/* ; 04 (x768) */
+    {{      0x28,0x5A,0x13,0x87,0xFF,0x29,0xA9      }} /* ; 05 (x1024) */
+};
+
+XGI_LVDSCRT1HDataStruct XGI_LVDSCRT11280x1024_2_Hx75[]=
+{
+	/* CR00,CR02,CR03,CR04,CR05,SR0B,SR0C,SR0E */
+    {{      0x7E,0x3B,0x9A,0x44,0x12,0x00,0x01,0x00 }},/* ; 00 (320x) */
+    {{      0x7E,0x3B,0x9A,0x44,0x12,0x00,0x01,0x00 }},/* ; 01 (360x) */
+    {{      0x7E,0x40,0x84,0x49,0x91,0x00,0x01,0x00 }},/* ; 02 (400x) */
+    {{      0x7E,0x47,0x93,0x50,0x9E,0x00,0x01,0x00 }},/* ; 03 (512x) */
+    {{      0xCE,0x77,0x8A,0x80,0x8E,0x00,0x02,0x00 }},/* ; 04 (640x) */
+    {{      0xCE,0x77,0x8A,0x80,0x8E,0x00,0x02,0x00 }},/* ; 05 (720x) */
+    {{      0xCE,0x81,0x94,0x8A,0x98,0x00,0x02,0x00 }},/* ; 06 (800x) */
+    {{      0xCE,0x8F,0x82,0x98,0x06,0x00,0x07,0x00 }},/* ; 07 (1024x) */
+    {{      0xCE,0x9F,0x92,0xA8,0x16,0x00,0x07,0x00 }} /* ; 08 (1280x) */
+};
+
+XGI_LVDSCRT1VDataStruct XGI_LVDSCRT11280x1024_2_Vx75[]=
+{
+        /* CR06,CR07,CR10,CR11,CR15,CR16,SR0A */
+     {{     0x28,0xD2,0xAF,0x83,0xAE,0xD8,0xA1     }},/* ; 00 (x350) */
+     {{     0x28,0xD2,0xC8,0x8C,0xC7,0xF2,0x81     }},/* ; 01 (x400) */
+     {{     0x28,0xD2,0xF0,0x84,0xEF,0x1A,0xB1     }},/* ; 02 (x480) */
+     {{     0x28,0xDE,0x2C,0x8F,0x2B,0x56,0x91     }},/* ; 03 (x600) */
+     {{     0x28,0xDE,0x80,0x83,0x7F,0xAA,0x91     }},/* ; 04 (x768) */
+     {{     0x28,0x5A,0x13,0x87,0xFF,0x29,0xA9     }} /* ; 05 (x1024) */
+};
+
+XGI_LVDSCRT1DataStruct  XGI_CHTVCRT1UNTSC[]=
+{
+ {{0x64,0x4f,0x88,0x56,0x9f,0x56,0x3e,
+    0xe8,0x84,0x8f,0x57,0x20,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x56,0x9f,0x56,0x3e,
+    0xd0,0x82,0x5d,0x57,0x00,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x56,0x9f,0x56,0x3e,
+    0xe8,0x84,0x8f,0x57,0x20,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x56,0x9f,0x56,0x3e,
+    0xd0,0x82,0x5d,0x57,0x00,0x00,0x01,0x00 }},
+ {{0x5d,0x4f,0x81,0x53,0x9c,0x56,0xba,
+    0x18,0x84,0xdf,0x57,0x00,0x00,0x01,0x00 }},
+ {{0x80,0x63,0x84,0x6c,0x17,0xec,0xf0,
+   0x90,0x8c,0x57,0xed,0x20,0x00,0x06,0x01 }}
+};
+
+XGI_LVDSCRT1DataStruct  XGI_CHTVCRT1ONTSC[]=
+{
+ {{0x64,0x4f,0x88,0x5a,0x9f,0x0b,0x3e,
+    0xc0,0x84,0x8f,0x0c,0x20,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x5a,0x9f,0x0b,0x3e,
+    0xb0,0x8d,0x5d,0x0c,0x00,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x5a,0x9f,0x0b,0x3e,
+    0xc0,0x84,0x8f,0x0c,0x20,0x00,0x01,0x00 }},
+ {{0x64,0x4f,0x88,0x5a,0x9f,0x0b,0x3e,
+    0xb0,0x8d,0x5d,0x0c,0x00,0x00,0x01,0x00 }},
+ {{0x5d,0x4f,0x81,0x56,0x9c,0x0b,0x3e,
+    0xe8,0x84,0xdf,0x0c,0x00,0x00,0x01,0x00 }},
+ {{0x7d,0x63,0x81,0x6a,0x16,0xba,0xf0,
+   0x7f,0x86,0x57,0xbb,0x00,0x00,0x06,0x01 }}
+};
+
+XGI_LVDSCRT1DataStruct  XGI_CHTVCRT1UPAL[]=
+{
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xf8,0x83,0x8f,0x70,0x20,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xde,0x81,0x5d,0x70,0x00,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xf8,0x83,0x8f,0x70,0x20,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xde,0x81,0x5d,0x70,0x00,0x00,0x05,0x00 }},
+ {{0x64,0x4f,0x88,0x55,0x80,0xec,0xba,
+    0x50,0x84,0xdf,0xed,0x00,0x00,0x05,0x00 }},
+ {{0x70,0x63,0x94,0x68,0x8d,0x42,0xf1,
+   0xc8,0x8c,0x57,0xe9,0x20,0x00,0x05,0x01 }}
+};
+
+XGI_LVDSCRT1DataStruct  XGI_CHTVCRT1OPAL[]=
+{
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xf0,0x83,0x8f,0x70,0x20,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xde,0x81,0x5d,0x70,0x00,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xf0,0x83,0x8f,0x70,0x20,0x00,0x05,0x00 }},
+ {{0x79,0x4f,0x9d,0x5a,0x90,0x6f,0x3e,
+    0xde,0x81,0x5d,0x70,0x00,0x00,0x05,0x00 }},
+ {{0x64,0x4f,0x88,0x55,0x80,0x6f,0xba,
+    0x20,0x83,0xdf,0x70,0x00,0x00,0x05,0x00 }},
+ {{0x73,0x63,0x97,0x69,0x8e,0xec,0xf0,
+   0x90,0x8c,0x57,0xed,0x20,0x00,0x05,0x01 }}
+};
+
+/*add for new UNIVGABIOS*/
+XGI330_LCDDataTablStruct XGI_LCDDataTable[]=
+{
+  {Panel1024x768,0x0019,0x0001,0},  /* XGI_ExtLCD1024x768Data */
+  {Panel1024x768,0x0019,0x0000,1},  /* XGI_StLCD1024x768Data */
+  {Panel1024x768,0x0018,0x0010,2},  /* XGI_CetLCD1024x768Data */
+  {Panel1280x1024,0x0019,0x0001,3},  /* XGI_ExtLCD1280x1024Data */
+  {Panel1280x1024,0x0019,0x0000,4},  /* XGI_StLCD1280x1024Data */
+  {Panel1280x1024,0x0018,0x0010,5},  /* XGI_CetLCD1280x1024Data */
+  {Panel1400x1050,0x0019,0x0001,6},  /* XGI_ExtLCD1400x1050Data */
+  {Panel1400x1050,0x0019,0x0000,7},  /* XGI_StLCD1400x1050Data */
+  {Panel1400x1050,0x0018,0x0010,8},  /* XGI_CetLCD1400x1050Data */
+  {Panel1600x1200,0x0019,0x0001,9},   /* XGI_ExtLCD1600x1200Data */
+  {Panel1600x1200,0x0019,0x0000,10},  /* XGI_StLCD1600x1200Data */
+  {PanelRef60Hz,0x0008,0x0008,11},  	/* XGI_NoScalingData */
+  {Panel1024x768x75,0x0019,0x0001,12}, 	/* XGI_ExtLCD1024x768x75Data */
+  {Panel1024x768x75,0x0019,0x0000,13}, 	/* XGI_StLCD1024x768x75Data */
+  {Panel1024x768x75,0x0018,0x0010,14}, 	/* XGI_CetLCD1024x768x75Data */
+  {Panel1280x1024x75,0x0019,0x0001,15}, /* XGI_ExtLCD1280x1024x75Data */
+  {Panel1280x1024x75,0x0019,0x0000,16}, /* XGI_StLCD1280x1024x75Data */
+  {Panel1280x1024x75,0x0018,0x0010,17}, /* XGI_CetLCD1280x1024x75Data */
+  {PanelRef75Hz,0x0008,0x0008,18},	/* XGI_NoScalingDatax75 */
+  {0xFF,0x0000,0x0000,0}   		/* End of table */
+};
+
+XGI330_LCDDataTablStruct XGI_LCDDesDataTable[]=
+{
+  {Panel1024x768,0x0019,0x0001,0}, /* XGI_ExtLCDDes1024x768Data */
+  {Panel1024x768,0x0019,0x0000,1}, /* XGI_StLCDDes1024x768Data */
+  {Panel1024x768,0x0018,0x0010,2}, /* XGI_CetLCDDes1024x768Data */
+  {Panel1280x1024,0x0019,0x0001,3}, /* XGI_ExtLCDDes1280x1024Data */
+  {Panel1280x1024,0x0019,0x0000,4}, /* XGI_StLCDDes1280x1024Data */
+  {Panel1280x1024,0x0018,0x0010,5}, /* XGI_CetLCDDes1280x1024Data */
+  {Panel1400x1050,0x0019,0x0001,6}, /* XGI_ExtLCDDes1400x1050Data */
+  {Panel1400x1050,0x0019,0x0000,7}, /* XGI_StLCDDes1400x1050Data */
+  {Panel1400x1050,0x0418,0x0010,8}, /* XGI_CetLCDDes1400x1050Data */
+  {Panel1400x1050,0x0418,0x0410,9}, /* XGI_CetLCDDes1400x1050Data2 */
+  {Panel1600x1200,0x0019,0x0001,10}, /* XGI_ExtLCDDes1600x1200Data */
+  {Panel1600x1200,0x0019,0x0000,11}, /* XGI_StLCDDes1600x1200Data */
+  {PanelRef60Hz,0x0008,0x0008,12}, 	/* XGI_NoScalingDesData */
+  {Panel1024x768x75,0x0019,0x0001,13}, 	/* XGI_ExtLCDDes1024x768x75Data */
+  {Panel1024x768x75,0x0019,0x0000,14},	/* XGI_StLCDDes1024x768x75Data */
+  {Panel1024x768x75,0x0018,0x0010,15},  /* XGI_CetLCDDes1024x768x75Data */
+  {Panel1280x1024x75,0x0019,0x0001,16},	/* XGI_ExtLCDDes1280x1024x75Data */
+  {Panel1280x1024x75,0x0019,0x0000,17}, /* XGI_StLCDDes1280x1024x75Data */
+  {Panel1280x1024x75,0x0018,0x0010,18},	/* XGI_CetLCDDes1280x1024x75Data */
+  {PanelRef75Hz,0x0008,0x0008,19},	/* XGI_NoScalingDesDatax75 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_LCDDataTablStruct XGI_EPLLCDCRT1Ptr_H[]=
+{
+  {Panel1024x768,0x0018,0x0000,0}, /* XGI_LVDSCRT11024x768_1_H */
+  {Panel1024x768,0x0018,0x0010,1}, /* XGI_LVDSCRT11024x768_2_H */
+  {Panel1280x1024,0x0018,0x0000,2}, /* XGI_LVDSCRT11280x1024_1_H */
+  {Panel1280x1024,0x0018,0x0010,3}, /* XGI_LVDSCRT11280x1024_2_H */
+  {Panel1400x1050,0x0018,0x0000,4}, /* XGI_LVDSCRT11400x1050_1_H */
+  {Panel1400x1050,0x0018,0x0010,5}, /* XGI_LVDSCRT11400x1050_2_H */
+  {Panel1600x1200,0x0018,0x0000,6},  /* XGI_LVDSCRT11600x1200_1_H */
+  {Panel1024x768x75,0x0018,0x0000,7},	/* XGI_LVDSCRT11024x768_1_Hx75 */
+  {Panel1024x768x75,0x0018,0x0010,8},	/* XGI_LVDSCRT11024x768_2_Hx75 */
+  {Panel1280x1024x75,0x0018,0x0000,9},	/* XGI_LVDSCRT11280x1024_1_Hx75 */
+  {Panel1280x1024x75,0x0018,0x0010,10},	/* XGI_LVDSCRT11280x1024_2_Hx75 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_LCDDataTablStruct XGI_EPLLCDCRT1Ptr_V[]=
+{
+  {Panel1024x768,0x0018,0x0000,0}, /* XGI_LVDSCRT11024x768_1_V */
+  {Panel1024x768,0x0018,0x0010,1}, /* XGI_LVDSCRT11024x768_2_V */
+  {Panel1280x1024,0x0018,0x0000,2}, /* XGI_LVDSCRT11280x1024_1_V */
+  {Panel1280x1024,0x0018,0x0010,3}, /* XGI_LVDSCRT11280x1024_2_V */
+  {Panel1400x1050,0x0018,0x0000,4}, /* XGI_LVDSCRT11400x1050_1_V */
+  {Panel1400x1050,0x0018,0x0010,5}, /* XGI_LVDSCRT11400x1050_2_V */
+  {Panel1600x1200,0x0018,0x0000,6}, /* XGI_LVDSCRT11600x1200_1_V */
+  {Panel1024x768x75,0x0018,0x0000,7},	/* XGI_LVDSCRT11024x768_1_Vx75 */
+  {Panel1024x768x75,0x0018,0x0010,8},	/* XGI_LVDSCRT11024x768_2_Vx75 */
+  {Panel1280x1024x75,0x0018,0x0000,9},	/* XGI_LVDSCRT11280x1024_1_Vx75 */
+  {Panel1280x1024x75,0x0018,0x0010,10},	/* XGI_LVDSCRT11280x1024_2_Vx75 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_LCDDataTablStruct XGI_EPLLCDDataPtr[]=
+{
+  {Panel1024x768,0x0018,0x0000,0}, /* XGI_LVDS1024x768Data_1 */
+  {Panel1024x768,0x0018,0x0010,1}, /* XGI_LVDS1024x768Data_2 */
+  {Panel1280x1024,0x0018,0x0000,2}, /* XGI_LVDS1280x1024Data_1 */
+  {Panel1280x1024,0x0018,0x0010,3}, /* XGI_LVDS1280x1024Data_2 */
+  {Panel1400x1050,0x0018,0x0000,4}, /* XGI_LVDS1400x1050Data_1 */
+  {Panel1400x1050,0x0018,0x0010,5}, /* XGI_LVDS1400x1050Data_2 */
+  {Panel1600x1200,0x0018,0x0000,6}, /* XGI_LVDS1600x1200Data_1 */
+  {PanelRef60Hz,0x0008,0x0008,7}, /* XGI_LVDSNoScalingData */
+  {Panel1024x768x75,0x0018,0x0000,8},	/* XGI_LVDS1024x768Data_1x75 */
+  {Panel1024x768x75,0x0018,0x0010,9},	/* XGI_LVDS1024x768Data_2x75 */
+  {Panel1280x1024x75,0x0018,0x0000,10},	/* XGI_LVDS1280x1024Data_1x75 */
+  {Panel1280x1024x75,0x0018,0x0010,11}, /* XGI_LVDS1280x1024Data_2x75 */
+  {PanelRef75Hz,0x0008,0x0008,12},	/* XGI_LVDSNoScalingDatax75 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_LCDDataTablStruct XGI_EPLLCDDesDataPtr[]=
+{
+  {Panel1024x768,0x0018,0x0000,0}, /* XGI_LVDS1024x768Des_1 */
+  {Panel1024x768,0x0618,0x0410,1}, /* XGI_LVDS1024x768Des_3 */
+  {Panel1024x768,0x0018,0x0010,2}, /* XGI_LVDS1024x768Des_2 */
+  {Panel1280x1024,0x0018,0x0000,3}, /* XGI_LVDS1280x1024Des_1 */
+  {Panel1280x1024,0x0018,0x0010,4}, /* XGI_LVDS1280x1024Des_2 */
+  {Panel1400x1050,0x0018,0x0000,5}, /* XGI_LVDS1400x1050Des_1 */
+  {Panel1400x1050,0x0018,0x0010,6}, /* XGI_LVDS1400x1050Des_2 */
+  {Panel1600x1200,0x0018,0x0000,7}, /* XGI_LVDS1600x1200Des_1 */
+  {PanelRef60Hz,0x0008,0x0008,8}, 	/* XGI_LVDSNoScalingDesData */
+  {Panel1024x768x75,0x0018,0x0000,9},	/* XGI_LVDS1024x768Des_1x75 */
+  {Panel1024x768x75,0x0618,0x0410,10},	/* XGI_LVDS1024x768Des_3x75 */
+  {Panel1024x768x75,0x0018,0x0010,11},	/* XGI_LVDS1024x768Des_2x75 */
+  {Panel1280x1024x75,0x0018,0x0000,12},	/* XGI_LVDS1280x1024Des_1x75 */
+  {Panel1280x1024x75,0x0018,0x0010,13},	/* XGI_LVDS1280x1024Des_2x75 */
+  {PanelRef75Hz,0x0008,0x0008,14},	/* XGI_LVDSNoScalingDesDatax75 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_LCDDataTablStruct XGI_EPLCHLCDRegPtr[]=
+{
+  {Panel1024x768,0x0000,0x0000,0}, /* XGI_CH7017LV1024x768 */
+  {Panel1400x1050,0x0000,0x0000,1}, /* XGI_CH7017LV1400x1050 */
+  {0xFF,0x0000,0x0000,0}
+};
+
+XGI330_TVDataTablStruct XGI_TVDataTable[]=
+{
+ {0x09E1,0x0001,0},	/* XGI_ExtPALData */
+ {0x09E1,0x0000,1},	/* XGI_ExtNTSCData */
+ {0x09E1,0x0801,2},	/* XGI_StPALData */
+ {0x09E1,0x0800,3},	/* XGI_StNTSCData */
+ {0x49E0,0x0100,4},	/* XGI_ExtHiTVData */
+ {0x49E0,0x4100,5},	/* XGI_St2HiTVData */
+ {0x49E0,0x4900,13},	/* XGI_St1HiTVData */
+ {0x09E0,0x0020,6},	/* XGI_ExtYPbPr525iData */
+ {0x09E0,0x0040,7},	/* XGI_ExtYPbPr525pData */
+ {0x09E0,0x0080,8},	/* XGI_ExtYPbPr750pData */
+ {0x09E0,0x0820,9},	/* XGI_StYPbPr525iData */
+ {0x09E0,0x0840,10},	/* XGI_StYPbPr525pData */
+ {0x09E0,0x0880,11}, 	/* XGI_StYPbPr750pData */
+ {0xffff,0x0000,12}  	/* END */
+};
+
+USHORT TVLenList[]=
+{
+   LVDSCRT1Len_H,
+   LVDSCRT1Len_V,
+   LVDSDataLen,
+   0,
+   TVDataLen,
+   0,
+   0,
+   CHTVRegLen
+} ;
+
+/* Chrontel 7017 TV CRT1 Timing List */
+XGI330_TVDataTablStruct XGI_EPLCHTVCRT1Ptr[]=
+{
+  {0x0011,0x0000,0}, /* XGI_CHTVCRT1UNTSC */
+  {0x0011,0x0010,1}, /* XGI_CHTVCRT1ONTSC */
+  {0x0011,0x0001,2}, /* XGI_CHTVCRT1UPAL */
+  {0x0011,0x0011,3}, /* XGI_CHTVCRT1OPAL */
+  {0xFFFF,0x0000,4}
+};
+
+/* ;;Chrontel 7017 TV Timing List */
+XGI330_TVDataTablStruct XGI_EPLCHTVDataPtr[]=
+{
+  {0x0011,0x0000,0}, /* XGI_CHTVUNTSCData */
+  {0x0011,0x0010,1}, /* XGI_CHTVONTSCData */
+  {0x0011,0x0001,2}, /* XGI_CHTVUPALData */
+  {0x0011,0x0011,3}, /* XGI_CHTVOPALData */
+  {0xFFFF,0x0000,4}
+};
+
+/* ;;Chrontel 7017 TV Reg. List */
+XGI330_TVDataTablStruct XGI_EPLCHTVRegPtr[]=
+{
+  {0x0011,0x0000,0}, /* XGI_CHTVRegUNTSC */
+  {0x0011,0x0010,1}, /* XGI_CHTVRegONTSC */
+  {0x0011,0x0001,2}, /* XGI_CHTVRegUPAL */
+  {0x0011,0x0011,3}, /* XGI_CHTVRegOPAL */
+  {0xFFFF,0x0000,4}
+};
+
+USHORT LCDLenList[]=
+{
+   LVDSCRT1Len_H,
+   LVDSCRT1Len_V,
+   LVDSDataLen,
+   LCDDesDataLen,
+   LCDDataLen,
+   LCDDesDataLen,
+   0,
+   LCDDesDataLen,
+   LCDDesDataLen,
+   0
+} ;
+
+XGI330_LCDCapStruct  XGI660_LCDDLCapList[]=  /* 660, Dual link */
+{
+/* LCDCap1024x768 */
+		{Panel1024x768, DefaultLCDCap, 0, 0x014, 0x88, 0x06, VCLK65,
+		 0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024 */
+                {Panel1280x1024, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x053, 0x70, 0x03, VCLK108_2,
+		 0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1400x1050 */
+                {Panel1400x1050, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x053, 0x70, 0x03, VCLK108_2,
+		 0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1600x1200 */
+                {Panel1600x1200, LCDDualLink+DefaultLCDCap, LCDToFull, 0x053, 0xC0, 0x03, VCLK162,
+		 0x43, 0x22, 0x70, 0x24, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1024x768x75 */
+		{Panel1024x768x75, DefaultLCDCap, 0, 0x014, 0x60, 0, VCLK78_75,
+		 0x2B, 0x61, 0x2B, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024x75 */
+                {Panel1280x1024x75, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x053, 0x90, 0x03, VCLK135_5,
+		 0x54, 0x42, 0x4A, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCapDefault */
+                {0xFF, DefaultLCDCap, 0, 0x053, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10}
+};
+
+XGI330_LCDCapStruct  XGI_LCDDLCapList[]=  /* Dual link only */
+{
+/* LCDCap1024x768 */
+		{Panel1024x768, DefaultLCDCap, 0, 0x012, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024 */
+		{Panel1280x1024, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x012, 0x70, 0x03, VCLK108_2,
+		0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1400x1050 */
+		{Panel1400x1050, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x012, 0x70, 0x03, VCLK108_2,
+		 0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1600x1200 */
+		{Panel1600x1200, LCDDualLink+DefaultLCDCap, LCDToFull, 0x012, 0xC0, 0x03, VCLK162,
+		 0x43, 0x22, 0x70, 0x24, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1024x768x75 */
+		{Panel1024x768x75, DefaultLCDCap, 0, 0x012, 0x60, 0, VCLK78_75,
+		 0x2B, 0x61, 0x2B, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024x75 */
+		{Panel1280x1024x75, LCDDualLink+DefaultLCDCap, StLCDBToA, 0x012, 0x90, 0x03, VCLK135_5,
+		 0x54, 0x42, 0x4A, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCapDefault */
+		{0xFF, DefaultLCDCap, 0, 0x012, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10}
+};
+
+XGI330_LCDCapStruct  XGI660_LCDCapList[]=
+{
+/* LCDCap1024x768 */
+                {Panel1024x768, DefaultLCDCap, 0, 0x014, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024 */
+                {Panel1280x1024, DefaultLCDCap, StLCDBToA, 0x053, 0x70, 0x03, VCLK108_2,
+		0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1400x1050 */
+                {Panel1400x1050, DefaultLCDCap, StLCDBToA, 0x053, 0x70, 0x03, VCLK108_2,
+		 0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1600x1200 */
+                {Panel1600x1200, DefaultLCDCap, LCDToFull, 0x053, 0xC0, 0x03, VCLK162,
+		 0x5A, 0x23, 0x5A, 0x23, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1024x768x75 */
+		{Panel1024x768x75, DefaultLCDCap, 0, 0x014, 0x60, 0, VCLK78_75,
+		 0x2B, 0x61, 0x2B, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024x75 */
+                {Panel1280x1024x75,+DefaultLCDCap, StLCDBToA, 0x053, 0x90, 0x03, VCLK135_5,
+		 0x54, 0x42, 0x4A, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCapDefault */
+                {0xFF, DefaultLCDCap, 0, 0x053, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10}
+};
+
+XGI330_LCDCapStruct  XGI_LCDCapList[]=
+{
+/* LCDCap1024x768 */
+		{Panel1024x768, DefaultLCDCap, 0, 0x012, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024 */
+		{Panel1280x1024, DefaultLCDCap, StLCDBToA, 0x012, 0x70, 0x03, VCLK108_2,
+		0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1400x1050 */
+		{Panel1400x1050, DefaultLCDCap, StLCDBToA, 0x012, 0x70, 0x03, VCLK108_2,
+		 0x70, 0x44, 0xF8, 0x2F, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1600x1200 */
+		{Panel1600x1200, DefaultLCDCap, LCDToFull, 0x012, 0xC0, 0x03, VCLK162,
+		 0x5A, 0x23, 0x5A, 0x23, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCap1024x768x75 */
+		{Panel1024x768x75, DefaultLCDCap, 0, 0x012, 0x60, 0, VCLK78_75,
+		 0x2B, 0x61, 0x2B, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10},
+/* LCDCap1280x1024x75 */
+		{Panel1280x1024x75, DefaultLCDCap, StLCDBToA, 0x012, 0x90, 0x03, VCLK135_5,
+		 0x54, 0x42, 0x4A, 0x61, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		 0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x30, 0x10},
+/* LCDCapDefault */
+		{0xFF, DefaultLCDCap, 0, 0x012, 0x88, 0x06, VCLK65,
+		0x6C, 0xC3, 0x35, 0x62, 0x02, 0x14, 0x0A, 0x02, 0x00,
+		0x30, 0x10, 0x5A, 0x10, 0x10, 0x0A, 0xC0, 0x28, 0x10}
+};
+
+XGI21_LVDSCapStruct XGI21_LCDCapList[]=
+{
+    {DisableLCD24bpp + LCDPolarity,
+     2160,1250,1600,1200,  64,  1,  192,   3,
+     0x70,0x24,0x20,0x04,0x0A,0x02,0xC8
+    },
+    {DisableLCD24bpp + LCDPolarity,
+     1688,1066,1280,1024,  48,  1,  112,   3,
+     0x70,0x44,0x20,0x04,0x0A,0x02,0xC8
+    },
+    {DisableLCD24bpp + LCDPolarity + (LCDPolarity << 8),
+     1344, 806,1024, 768,  24,  3,  136,   6,
+     0x6C,0x65,0x20,0x04,0x0A,0x02,0xC8
+    },
+    {DisableLCD24bpp + LCDPolarity,
+     1056, 628, 800, 600,  40,   1, 128,   4,
+     0x42,0xE2,0x20,0x14,0x0A,0x02,0x00
+    },
+    {DisableLCD24bpp + LCDPolarity,
+      928, 525, 800, 480,  40,  13,  48,   3,
+     0x52,0xC5,0x20,0x14,0x0A,0x02,0x00
+    },
+    {DisableLCD24bpp + LCDPolarity + (LCDPolarity << 8),
+      800, 525, 640, 480,  16,  10,  96,   2,
+     0x1B,0xE1,0x20,0x04,0x0A,0x02,0xC8
+    }
+
+};
+
+XGI_Ext2Struct XGI330_RefIndex[]=
+{
+{Support32Bpp + SupportAllCRT2 + SyncPN,			RES320x200,	 VCLK25_175, 0x00,0x10,0x59, 320, 200},/* 00 */
+{Support32Bpp + SupportAllCRT2 + SyncPN,			RES320x200,	 VCLK25_175, 0x00,0x10,0x00, 320, 400},/* 01 */
+{Support32Bpp + SupportAllCRT2 + SyncNN,			RES320x240,	 VCLK25_175, 0x04,0x20,0x50, 320, 240},/* 02 */
+{Support32Bpp + SupportAllCRT2 + SyncPP,			RES400x300,	 VCLK40,     0x05,0x32,0x51, 400, 300},/* 03 */
+{Support32Bpp + NoSupportTV + SyncNN + SupportTV1024,		RES512x384,	 VCLK65,     0x06,0x43,0x52, 512, 384},/* 04 */
+{Support32Bpp + SupportAllCRT2 + SyncPN,			RES640x400,	 VCLK25_175, 0x00,0x14,0x2f, 640, 400},/* 05 */
+{Support32Bpp + SupportAllCRT2 + SyncNN,			RES640x480x60,	 VCLK25_175, 0x04,0x24,0x2e, 640, 480},/* 06 640x480x60Hz (LCD 640x480x60z) */
+{Support32Bpp + NoSupportHiVisionTV + SyncNN,			RES640x480x72,	 VCLK31_5,   0x04,0x24,0x2e, 640, 480},/* 07 640x480x72Hz (LCD 640x480x70Hz) */
+{Support32Bpp + NoSupportHiVisionTV + SyncNN,			RES640x480x75,	 VCLK31_5,   0x47,0x24,0x2e, 640, 480},/* 08 640x480x75Hz (LCD 640x480x75Hz) */
+{Support32Bpp + SupportRAMDAC2 + SyncNN,			RES640x480x85,	 VCLK36,     0x8A,0x24,0x2e, 640, 480},/* 09 640x480x85Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES640x480x100,	 VCLK43_163, 0x00,0x24,0x2e, 640, 480},/* 0a 640x480x100Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES640x480x120,	 VCLK52_406, 0x00,0x24,0x2e, 640, 480},/* 0b 640x480x120Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES640x480x160,	 VCLK72_852, 0x00,0x24,0x2e, 640, 480},/* 0c 640x480x160Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncNN,			RES640x480x200,	 VCLK86_6,   0x00,0x24,0x2e, 640, 480},/* 0d 640x480x200Hz */
+{Support32Bpp + NoSupportLCD + SyncPP,				RES800x600x56,	 VCLK36,     0x05,0x36,0x6a, 800, 600},/* 0e 800x600x56Hz */
+{Support32Bpp + NoSupportTV + SyncPP,				RES800x600x60,	 VCLK40,     0x05,0x36,0x6a, 800, 600},/* 0f 800x600x60Hz (LCD 800x600x60Hz) */
+{Support32Bpp + NoSupportHiVisionTV + SyncPP,			RES800x600x72,	 VCLK50,     0x48,0x36,0x6a, 800, 600},/* 10 800x600x72Hz (LCD 800x600x70Hz) */
+{Support32Bpp + NoSupportHiVisionTV + SyncPP,			RES800x600x75,	 VCLK49_5,   0x8B,0x36,0x6a, 800, 600},/* 11 800x600x75Hz (LCD 800x600x75Hz) */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES800x600x85,	 VCLK56_25,  0x00,0x36,0x6a, 800, 600},/* 12 800x600x85Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES800x600x100,	 VCLK68_179, 0x00,0x36,0x6a, 800, 600},/* 13 800x600x100Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES800x600x120,	 VCLK83_95,  0x00,0x36,0x6a, 800, 600},/* 14 800x600x120Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES800x600x160,	 VCLK116_406,0x00,0x36,0x6a, 800, 600},/* 15 800x600x160Hz */
+{Support32Bpp + InterlaceMode + SyncPP,				RES1024x768x43,	 VCLK44_9,   0x00,0x47,0x37,1024, 768},/* 16 1024x768x43Hz */
+{Support32Bpp + NoSupportTV + SyncNN + SupportTV1024,		RES1024x768x60,	 VCLK65,     0x06,0x47,0x37,1024, 768},/* 17 1024x768x60Hz (LCD 1024x768x60Hz) */
+{Support32Bpp + NoSupportHiVisionTV + SyncNN,			RES1024x768x70,	 VCLK75,     0x49,0x47,0x37,1024, 768},/* 18 1024x768x70Hz (LCD 1024x768x70Hz) */
+{Support32Bpp + NoSupportHiVisionTV + SyncPP,			RES1024x768x75,	 VCLK78_75,  0x00,0x47,0x37,1024, 768},/* 19 1024x768x75Hz (LCD 1024x768x75Hz) */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1024x768x85,	 VCLK94_5,   0x8C,0x47,0x37,1024, 768},/* 1a 1024x768x85Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES1024x768x100, VCLK113_309,0x00,0x47,0x37,1024, 768},/* 1b 1024x768x100Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES1024x768x120, VCLK139_054,0x00,0x47,0x37,1024, 768},/* 1c 1024x768x120Hz */
+{Support32Bpp + SupportLCD + SyncPP,				RES1280x960x60,	 VCLK108_2,  0x08,0x58,0x7b,1280, 960},/* 1d 1280x960x60Hz */
+{Support32Bpp + InterlaceMode + SyncPP,				RES1280x1024x43, VCLK78_75,  0x00,0x58,0x3a,1280,1024},/* 1e 1280x1024x43Hz */
+{Support32Bpp + NoSupportTV + SyncPP,				RES1280x1024x60, VCLK108_2,  0x07,0x58,0x3a,1280,1024},/* 1f 1280x1024x60Hz (LCD 1280x1024x60Hz) */
+{Support32Bpp + NoSupportTV + SyncPP,				RES1280x1024x75, VCLK135_5,  0x00,0x58,0x3a,1280,1024},/* 20 1280x1024x75Hz (LCD 1280x1024x75Hz) */
+{Support32Bpp + SyncPP,						RES1280x1024x85, VCLK157_5,  0x00,0x58,0x3a,1280,1024},/* 21 1280x1024x85Hz */
+{Support32Bpp + SupportLCD + SyncPP + SupportCRT2in301C,	RES1600x1200x60, VCLK162,    0x09,0x7A,0x3c,1600,1200},/* 22 1600x1200x60Hz */
+{Support32Bpp + SyncPP + SupportCRT2in301C,			RES1600x1200x65, VCLK175,    0x00,0x69,0x3c,1600,1200},/* 23 1600x1200x65Hz */
+{Support32Bpp + SyncPP + SupportCRT2in301C,			RES1600x1200x70, VCLK189,    0x00,0x69,0x3c,1600,1200},/* 24 1600x1200x70Hz */
+{Support32Bpp + SyncPP + SupportCRT2in301C,			RES1600x1200x75, VCLK202_5,  0x00,0x69,0x3c,1600,1200},/* 25 1600x1200x75Hz */
+{Support32Bpp + SyncPP,						RES1600x1200x85, VCLK229_5,  0x00,0x69,0x3c,1600,1200},/* 26 1600x1200x85Hz */
+{Support32Bpp + SyncPP,						RES1600x1200x100,VCLK269_655,0x00,0x69,0x3c,1600,1200},/* 27 1600x1200x100Hz */
+{Support32Bpp + SyncPP,						RES1600x1200x120,VCLK323_586,0x00,0x69,0x3c,1600,1200},/* 28 1600x1200x120Hz */
+{Support32Bpp + SupportLCD + SyncNP,				RES1920x1440x60, VCLK234,    0x00,0x00,0x68,1920,1440},/* 29 1920x1440x60Hz */
+{Support32Bpp + SyncPN,						RES1920x1440x65, VCLK254_817,0x00,0x00,0x68,1920,1440},/* 2a 1920x1440x65Hz */
+{Support32Bpp + SyncPN,						RES1920x1440x70, VCLK277_015,0x00,0x00,0x68,1920,1440},/* 2b 1920x1440x70Hz */
+{Support32Bpp + SyncPN,						RES1920x1440x75, VCLK291_132,0x00,0x00,0x68,1920,1440},/* 2c 1920x1440x75Hz */
+{Support32Bpp + SyncPN,						RES1920x1440x85, VCLK330_615,0x00,0x00,0x68,1920,1440},/* 2d 1920x1440x85Hz */
+{Support16Bpp + SyncPN,						RES1920x1440x100,VCLK388_631,0x00,0x00,0x68,1920,1440},/* 2e 1920x1440x100Hz */
+{Support32Bpp + SupportLCD + SyncPN,				RES2048x1536x60, VCLK266_952,0x00,0x00,0x6c,2048,1536},/* 2f 2048x1536x60Hz */
+{Support32Bpp + SyncPN,						RES2048x1536x65, VCLK291_766,0x00,0x00,0x6c,2048,1536},/* 30 2048x1536x65Hz */
+{Support32Bpp + SyncPN,						RES2048x1536x70, VCLK315_195,0x00,0x00,0x6c,2048,1536},/* 31 2048x1536x70Hz */
+{Support32Bpp + SyncPN,						RES2048x1536x75, VCLK340_477,0x00,0x00,0x6c,2048,1536},/* 32 2048x1536x75Hz */
+{Support16Bpp + SyncPN,						RES2048x1536x85, VCLK375_847,0x00,0x00,0x6c,2048,1536},/* 33 2048x1536x85Hz */
+{Support32Bpp + SupportHiVisionTV + SupportRAMDAC2 + SyncPP + SupportYPbPr,	RES800x480x60,	 VCLK39_77,  0x08,0x00,0x70, 800, 480},/* 34 800x480x60Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES800x480x75,	 VCLK49_5,   0x08,0x00,0x70, 800, 480},/* 35 800x480x75Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES800x480x85,	 VCLK56_25,  0x08,0x00,0x70, 800, 480},/* 36 800x480x85Hz */
+{Support32Bpp + SupportHiVisionTV + SupportRAMDAC2 + SyncPP + SupportYPbPr,	RES1024x576x60,	 VCLK65,     0x09,0x00,0x71,1024, 576},/* 37 1024x576x60Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1024x576x75,	 VCLK78_75,  0x09,0x00,0x71,1024, 576},/* 38 1024x576x75Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1024x576x85,	 VCLK94_5,   0x09,0x00,0x71,1024, 576},/* 39 1024x576x85Hz */
+{Support32Bpp + SupportHiVisionTV + SupportRAMDAC2 + SyncPP + SupportYPbPr,	RES1280x720x60,	 VCLK108_2,  0x0A,0x00,0x75,1280, 720},/* 3a 1280x720x60Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1280x720x75,	 VCLK135_5,  0x0A,0x00,0x75,1280, 720},/* 3b 1280x720x75Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1280x720x85,	 VCLK157_5,  0x0A,0x00,0x75,1280, 720},/* 3c 1280x720x85Hz */
+{Support32Bpp + SupportTV + SyncNN,				RES720x480x60,	 VCLK28_322, 0x06,0x00,0x31, 720, 480},/* 3d 720x480x60Hz */
+{Support32Bpp + SupportTV + SyncPP,				RES720x576x56,	 VCLK36,     0x06,0x00,0x32, 720, 576},/* 3e 720x576x56Hz */
+{Support32Bpp + InterlaceMode + NoSupportLCD + SyncPP,		RES856x480x79I,	 VCLK35_2,   0x00,0x00,0x00, 856, 480},/* 3f 856x480x79I */
+{Support32Bpp + NoSupportLCD + SyncNN,				RES856x480x60,	 VCLK35_2,   0x00,0x00,0x00, 856, 480},/* 40 856x480x60Hz */
+{Support32Bpp + NoSupportHiVisionTV + SyncPP,			RES1280x768x60,	 VCLK79_411, 0x08,0x48,0x23,1280, 768},/* 41 1280x768x60Hz */
+{Support32Bpp + NoSupportHiVisionTV + SyncPP,			RES1400x1050x60, VCLK122_61, 0x08,0x69,0x26,1400,1050},/* 42 1400x1050x60Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1152x864x60,	 VCLK80_350, 0x37,0x00,0x20,1152, 864},/* 43 1152x864x60Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPP,			RES1152x864x75,	 VCLK107_385,0x37,0x00,0x20,1152, 864},/* 44 1152x864x75Hz */
+{Support32Bpp + SupportLCD + SupportRAMDAC2 + SyncPP,		RES1280x960x75,	 VCLK125_999,0x3A,0x88,0x7b,1280, 960},/* 45 1280x960x75Hz */
+{Support32Bpp + SupportLCD + SupportRAMDAC2 + SyncPP,		RES1280x960x85,	 VCLK148_5,  0x0A,0x88,0x7b,1280, 960},/* 46 1280x960x85Hz */
+{Support32Bpp + SupportLCD + SupportRAMDAC2 + SyncPP,		RES1280x960x120, VCLK217_325,0x3A,0x88,0x7b,1280, 960},/* 47 1280x960x120Hz */
+{Support32Bpp + SupportRAMDAC2 + SyncPN,			RES1024x768x160, VCLK139_054,0x30,0x47,0x37,1024, 768},/* 48 1024x768x160Hz */
+};
+
+
+
+XGI330_VCLKDataStruct XGI330_VCLKData[]=
+{
+ { 0x1b,0xe1, 25}, /* 0x0 */
+ { 0x4e,0xe4, 28}, /* 0x1 */
+ { 0x57,0xe4, 31}, /* 0x2 */
+ { 0xc3,0xc8, 36}, /* 0x3 */
+ { 0x42,0xe2, 40}, /* 0x4 */
+ { 0xfe,0xcd, 43}, /* 0x5 */
+ { 0x5d,0xc4, 44}, /* 0x6 */
+ { 0x52,0xe2, 49}, /* 0x7 */
+ { 0x53,0xe2, 50}, /* 0x8 */
+ { 0x74,0x67, 52}, /* 0x9 */
+ { 0x6d,0x66, 56}, /* 0xa */
+ { 0x6c,0xc3, 65}, /* 0xb */
+ { 0x46,0x44, 67}, /* 0xc */
+ { 0xb1,0x46, 68}, /* 0xd */
+ { 0xd3,0x4a, 72}, /* 0xe */
+ { 0x29,0x61, 75}, /* 0xf */
+ { 0x6e,0x46, 76}, /* 0x10 */
+ { 0x2b,0x61, 78}, /* 0x11 */
+ { 0x31,0x42, 79}, /* 0x12 */
+ { 0xab,0x44, 83}, /* 0x13 */
+ { 0x46,0x25, 84}, /* 0x14 */
+ { 0x78,0x29, 86}, /* 0x15 */
+ { 0x62,0x44, 94}, /* 0x16 */
+ { 0x2b,0x41,104}, /* 0x17 */
+ { 0x3a,0x23,105}, /* 0x18 */
+ { 0x70,0x44,108}, /* 0x19 */
+ { 0x3c,0x23,109}, /* 0x1a */
+ { 0x5e,0x43,113}, /* 0x1b */
+ { 0xbc,0x44,116}, /* 0x1c */
+ { 0xe0,0x46,132}, /* 0x1d */
+ { 0x54,0x42,135}, /* 0x1e */
+ { 0xea,0x2a,139}, /* 0x1f */
+ { 0x41,0x22,157}, /* 0x20 */
+ { 0x70,0x24,162}, /* 0x21 */
+ { 0x30,0x21,175}, /* 0x22 */
+ { 0x4e,0x22,189}, /* 0x23 */
+ { 0xde,0x26,194}, /* 0x24 */
+ { 0x62,0x06,202}, /* 0x25 */
+ { 0x3f,0x03,229}, /* 0x26 */
+ { 0xb8,0x06,234}, /* 0x27 */
+ { 0x34,0x02,253}, /* 0x28 */
+ { 0x58,0x04,255}, /* 0x29 */
+ { 0x24,0x01,265}, /* 0x2a */
+ { 0x9b,0x02,267}, /* 0x2b */
+ { 0x70,0x05,270}, /* 0x2c */
+ { 0x25,0x01,272}, /* 0x2d */
+ { 0x9c,0x02,277}, /* 0x2e */
+ { 0x27,0x01,286}, /* 0x2f */
+ { 0x3c,0x02,291}, /* 0x30 */
+ { 0xef,0x0a,292}, /* 0x31 */
+ { 0xf6,0x0a,310}, /* 0x32 */
+ { 0x95,0x01,315}, /* 0x33 */
+ { 0xf0,0x09,324}, /* 0x34 */
+ { 0xfe,0x0a,331}, /* 0x35 */
+ { 0xf3,0x09,332}, /* 0x36 */
+ { 0xea,0x08,340}, /* 0x37 */
+ { 0xe8,0x07,376}, /* 0x38 */
+ { 0xde,0x06,389}, /* 0x39 */
+ { 0x52,0x2a, 54}, /* 0x3a */
+ { 0x52,0x6a, 27}, /* 0x3b */
+ { 0x62,0x24, 70}, /* 0x3c */
+ { 0x62,0x64, 70}, /* 0x3d */
+ { 0xa8,0x4c, 30}, /* 0x3e */
+ { 0x20,0x26, 33}, /* 0x3f */
+ { 0x31,0xc2, 39}, /* 0x40 */
+ { 0x60,0x36, 30}, /* 0x41 */
+ { 0x40,0x4A, 28}, /* 0x42 */
+ { 0x9F,0x46, 44}, /* 0x43 */
+ { 0x97,0x2C, 26}, /* 0x44 */
+ { 0x44,0xE4, 25}, /* 0x45 */
+ { 0x7E,0x32, 47}, /* 0x46 */
+ { 0x08,0x24, 31}, /* 0x47 */
+ { 0x97,0x2c, 26}, /* 0x48 */
+ { 0xCE,0x3c, 39}, /* 0x49 */
+ { 0x52,0x4A, 36}, /* 0x4a */
+ { 0x2C,0x61, 95}, /* 0x4b */
+ { 0x78,0x27,108}, /* 0x4c */
+ { 0x66,0x43,123},  /* 0x4d */
+ { 0x2c,0x61, 80},  /* 0x4e */
+ { 0x3b,0x61,108}  /* 0x4f */
+};
+
+XGI_VBVCLKDataStruct XGI330_VBVCLKData[]=
+{
+ { 0x1b,0xe1, 25}, /* 0x0 */
+ { 0x4e,0xe4, 28}, /* 0x1 */
+ { 0x57,0xe4, 31}, /* 0x2 */
+ { 0xc3,0xc8, 36}, /* 0x3 */
+ { 0x42,0x47, 40}, /* 0x4 */
+ { 0xfe,0xcd, 43}, /* 0x5 */
+ { 0x5d,0xc4, 44}, /* 0x6 */
+ { 0x52,0x47, 49}, /* 0x7 */
+ { 0x53,0x47, 50}, /* 0x8 */
+ { 0x74,0x67, 52}, /* 0x9 */
+ { 0x6d,0x66, 56}, /* 0xa */
+ { 0x5a,0x64, 65}, /* 0xb */
+ { 0x46,0x44, 67}, /* 0xc */
+ { 0xb1,0x46, 68}, /* 0xd */
+ { 0xd3,0x4a, 72}, /* 0xe */
+ { 0x29,0x61, 75}, /* 0xf */
+ { 0x6d,0x46, 75}, /* 0x10 */
+ { 0x41,0x43, 78}, /* 0x11 */
+ { 0x31,0x42, 79}, /* 0x12 */
+ { 0xab,0x44, 83}, /* 0x13 */
+ { 0x46,0x25, 84}, /* 0x14 */
+ { 0x78,0x29, 86}, /* 0x15 */
+ { 0x62,0x44, 94}, /* 0x16 */
+ { 0x2b,0x22,104}, /* 0x17 */
+ { 0x49,0x24,105}, /* 0x18 */
+ { 0xf8,0x2f,108}, /* 0x19 */
+ { 0x3c,0x23,109}, /* 0x1a */
+ { 0x5e,0x43,113}, /* 0x1b */
+ { 0xbc,0x44,116}, /* 0x1c */
+ { 0xe0,0x46,132}, /* 0x1d */
+ { 0xd4,0x28,135}, /* 0x1e */
+ { 0xea,0x2a,139}, /* 0x1f */
+ { 0x41,0x22,157}, /* 0x20 */
+ { 0x70,0x24,162}, /* 0x21 */
+ { 0x30,0x21,175}, /* 0x22 */
+ { 0x4e,0x22,189}, /* 0x23 */
+ { 0xde,0x26,194}, /* 0x24 */
+ { 0x70,0x07,202}, /* 0x25 */
+ { 0x3f,0x03,229}, /* 0x26 */
+ { 0xb8,0x06,234}, /* 0x27 */
+ { 0x34,0x02,253}, /* 0x28 */
+ { 0x58,0x04,255}, /* 0x29 */
+ { 0x24,0x01,265}, /* 0x2a */
+ { 0x9b,0x02,267}, /* 0x2b */
+ { 0x70,0x05,270}, /* 0x2c */
+ { 0x25,0x01,272}, /* 0x2d */
+ { 0x9c,0x02,277}, /* 0x2e */
+ { 0x27,0x01,286}, /* 0x2f */
+ { 0x3c,0x02,291}, /* 0x30 */
+ { 0xef,0x0a,292}, /* 0x31 */
+ { 0xf6,0x0a,310}, /* 0x32 */
+ { 0x95,0x01,315}, /* 0x33 */
+ { 0xf0,0x09,324}, /* 0x34 */
+ { 0xfe,0x0a,331}, /* 0x35 */
+ { 0xf3,0x09,332}, /* 0x36 */
+ { 0xea,0x08,340}, /* 0x37 */
+ { 0xe8,0x07,376}, /* 0x38 */
+ { 0xde,0x06,389}, /* 0x39 */
+ { 0x52,0x2a, 54}, /* 0x3a */
+ { 0x52,0x6a, 27}, /* 0x3b */
+ { 0x62,0x24, 70}, /* 0x3c */
+ { 0x62,0x64, 70}, /* 0x3d */
+ { 0xa8,0x4c, 30}, /* 0x3e */
+ { 0x20,0x26, 33}, /* 0x3f */
+ { 0x31,0xc2, 39}, /* 0x40 */
+ { 0x2e,0x48, 25}, /* 0x41 */
+ { 0x24,0x46, 25}, /* 0x42 */
+ { 0x26,0x64, 28}, /* 0x43 */
+ { 0x37,0x64, 40}, /* 0x44 */
+ { 0xa1,0x42,108}, /* 0x45 */
+ { 0x37,0x61,100}, /* 0x46 */
+ { 0x78,0x27,108}, /* 0x47 */
+ { 0x5e,0x64,68},  /* 0x48 chiawen for fuj1280x768*/
+ { 0x70,0x44,108}, /* 0x49 chiawen for 1400x1050*/
+};
+
+UCHAR XGI330_ScreenOffset[]={ 0x14,0x19,0x20,0x28,0x32,0x40,0x50,0x64,0x78,0x80,0x2d,0x35,0x57,0x48 };
+
+XGI_StResInfoStruct XGI330_StResInfo[]=
+{
+ { 640,400},
+ { 640,350},
+ { 720,400},
+ { 720,350},
+ { 640,480}
+};
+
+XGI_ModeResInfoStruct XGI330_ModeResInfo[]=
+{
+ {  320, 200, 8, 8},
+ {  320, 240, 8, 8},
+ {  320, 400, 8, 8},
+ {  400, 300, 8, 8},
+ {  512, 384, 8, 8},
+ {  640, 400, 8,16},
+ {  640, 480, 8,16},
+ {  800, 600, 8,16},
+ { 1024, 768, 8,16},
+ { 1280,1024, 8,16},
+ { 1600,1200, 8,16},
+ { 1920,1440, 8,16},
+ { 2048,1536, 8,16},
+ {  720, 480, 8,16},
+ {  720, 576, 8,16},
+ { 1280, 960, 8,16},
+ {  800, 480, 8,16},
+ { 1024, 576, 8,16},
+ { 1280, 720, 8,16},
+ {  856, 480, 8,16},
+ { 1280, 768, 8,16},
+ { 1400,1050, 8,16},
+ { 1152, 864, 8,16}
+};
+
+UCHAR XGI330_OutputSelect =0x40;
+UCHAR XGI330_SoftSetting = 0x30;
+UCHAR XGI330_SR07=0x18;
+UCHAR XGI330New_SR15[8][8]={
+{0x0,0x4,0x60,0x60},
+{0xf,0xf,0xf,0xf},
+{0xba,0xba,0xba,0xba},
+{0xa9,0xa9,0xac,0xac},
+{0xa0,0xa0,0xa0,0xa8},
+{0x0,0x0,0x2,0x2},
+{0x30,0x30,0x40,0x40},
+{0x0,0xa5,0xfb,0xf6}
+};
+
+UCHAR XGI330New_CR40[5][8]={
+{0x77,0x77,0x44,0x44},
+{0x77,0x77,0x44,0x44},
+{0x0,0x0,0x0,0x0},
+{0x5b,0x5b,0xab,0xab},
+{0x0,0x0,0xf0,0xf8}
+};
+
+UCHAR XGI330_CR49[]={0xaa,0x88};
+UCHAR XGI330_SR1F=0x0;
+UCHAR XGI330_SR21=0xa3;
+UCHAR XGI330_650_SR21=0xa7;
+UCHAR XGI330_SR22=0xfb;
+UCHAR XGI330_SR23=0xf6;
+UCHAR XGI330_SR24=0xd;
+
+UCHAR XGI660_SR21=0xa3;/* 2003.0312 */
+UCHAR XGI660_SR22=0xf3;/* 2003.0312 */
+
+UCHAR XGI330_LVDS_SR32=0x00;   /* ynlai for 650 LVDS */
+UCHAR XGI330_LVDS_SR33=0x00;	/* chiawen for 650 LVDS */
+UCHAR XGI330_650_SR31=0x40;
+UCHAR XGI330_650_SR33=0x04;
+UCHAR XGI330_CRT2Data_1_2 = 0x0;
+UCHAR XGI330_CRT2Data_4_D = 0x0;
+UCHAR XGI330_CRT2Data_4_E = 0x0;
+UCHAR XGI330_CRT2Data_4_10 = 0x80;
+USHORT XGI330_RGBSenseData = 0xd1;
+USHORT XGI330_VideoSenseData = 0xb9;
+USHORT XGI330_YCSenseData = 0xb3;
+USHORT XGI330_RGBSenseData2 = 0x0190;     /*301b*/
+USHORT XGI330_VideoSenseData2 = 0x0110;
+USHORT XGI330_YCSenseData2 = 0x016B;
+UCHAR XGI330_NTSCPhase[] = {0x21,0xed,0x8a,0x8};
+UCHAR XGI330_PALPhase[] = {0x2a,0x5,0xd3,0x0};
+UCHAR XGI330_NTSCPhase2[] = {0x21,0xF0,0x7B,0xD6};/*301b*/
+UCHAR XGI330_PALPhase2[] = {0x2a,0x09,0x86,0xe9};
+UCHAR XGI330_PALMPhase[] = {0x21,0xE4,0x2E,0x9B};   /*palmn*/
+UCHAR XGI330_PALNPhase[] = {0x21,0xF4,0x3E,0xBA};
+UCHAR XG40_I2CDefinition = 0x00 ;
+UCHAR XG20_CR97 = 0x10 ;
+
+UCHAR XG21_DVOSetting = 0x00 ;
+UCHAR XG21_CR2E = 0x00 ;
+UCHAR XG21_CR2F = 0x00 ;
+UCHAR XG21_CR46 = 0x00 ;
+UCHAR XG21_CR47 = 0x00 ;
+
+UCHAR XG27_CR97 = 0xC1 ;
+UCHAR XG27_SR36 = 0x30 ;
+UCHAR XG27_CR8F = 0x0C ;
+UCHAR XG27_CRD0[] = {0,0,0,0,0,0,0,0x82,0x00,0x66,0x01,0x00} ;
+UCHAR XG27_CRDE[] = {0,0} ;
+UCHAR XG27_SR40 = 0x04 ;
+UCHAR XG27_SR41 = 0x00 ;
+
+UCHAR XGI330_CHTVVCLKUNTSC[]={0x00 };
+
+UCHAR XGI330_CHTVVCLKONTSC[]={0x00 };
+
+UCHAR XGI330_CHTVVCLKUPAL[]={0x00 };
+
+UCHAR XGI330_CHTVVCLKOPAL[]={0x00 };
+
+UCHAR XGI7007_CHTVVCLKUNTSC[]={CH7007TVVCLK30_2,
+                               CH7007TVVCLK30_2,
+                               CH7007TVVCLK30_2,
+                               CH7007TVVCLK30_2,
+                               CH7007TVVCLK28_1,
+                               CH7007TVVCLK47_8
+                              };
+
+UCHAR XGI7007_CHTVVCLKONTSC[]={CH7007TVVCLK26_4,
+                               CH7007TVVCLK26_4,
+                               CH7007TVVCLK26_4,
+                               CH7007TVVCLK26_4,
+                               CH7007TVVCLK24_6,
+                               CH7007TVVCLK43_6
+                              };
+
+UCHAR XGI7007_CHTVVCLKUPAL[]={CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK26_2,
+                              CH7007TVVCLK39
+                             };
+
+UCHAR XGI7007_CHTVVCLKOPAL[]={CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK31_5,
+                              CH7007TVVCLK26_2,
+                              CH7007TVVCLK36
+                             };
+
+XGI330_VCLKDataStruct XGI_CH7007VCLKData[]=
+{
+ { 0x60,0x36,30},  /* 0 30.2 MHZ */
+ { 0x40,0x4A,28},  /* 1 28.19 MHZ */
+ { 0x9F,0x46,44},  /* 2 43.6 MHZ */
+ { 0x97,0x2C,26},  /* 3 26.4 MHZ */
+ { 0x44,0xE4,25},  /* 4 24.6 MHZ */
+ { 0x7E,0x32,47},  /* 5 47.832 MHZ */
+ { 0x8A,0x24,31},  /* 6 31.5 MHZ */
+ { 0x97,0x2C,26},  /* 7 26.2 MHZ */
+ { 0xCE,0x3C,39},  /* 8 39 MHZ   */
+ { 0x52,0x4A,36},  /* 9 36 MHZ   */
+ { 0xFF,0x00,0 }   /* End mark      */
+};
+
+XGI330_VCLKDataStruct XGI_VCLKData[]=
+{
+               	/* SR2B,SR2C,SR2D */
+ 		{      0x1B,0xE1,25               },/* 00 (25.175MHz) */
+
+		{      0x4E,0xE4,28               },/* 01 (28.322MHz) */
+
+                {      0x57,0xE4,31               },/* 02 (31.500MHz) */
+
+                {      0xC3,0xC8,36               },/* 03 (36.000MHz) */
+
+                {      0x42,0xE2,40               },/* 04 (40.000MHz) */
+
+                {      0xFE,0xCD,43               },/* 05 (43.163MHz) */
+
+                {      0x5D,0xC4,44               },/* 06 (44.900MHz) */
+
+                {      0x52,0xE2,49               },/* 07 (49.500MHz) */
+
+                {      0x53,0xE2,50               },/* 08 (50.000MHz) */
+
+                {      0x74,0x67,52               },/* 09 (52.406MHz) */
+
+                {      0x6D,0x66,56               },/* 0A (56.250MHz) */
+
+                {      0x6C,0xC3,65               },/* 0B (65.000MHz) */
+
+                {      0x46,0x44,67               },/* 0C (67.765MHz) */
+
+                {      0xB1,0x46,68               },/* 0D (68.179MHz) */
+
+                {      0xD3,0x4A,72               },/* 0E (72.852MHz) */
+
+                {      0x29,0x61,75              },/* 0F (75.000MHz) */
+
+                {      0x6E,0x46,76               },/* 10 (75.800MHz) */
+
+                {      0x2B,0x61,78               },/* 11 (78.750MHz) */
+
+                {      0x31,0x42,79               },/* 12 (79.411MHz) */
+
+                {      0xAB,0x44,83               },/* 13 (83.950MHz) */
+
+                {      0x46,0x25,84               },/* 14 (84.800MHz) */
+
+                {      0x78,0x29,86               },/* 15 (86.600MHz) */
+
+                {      0x62,0x44,94               },/* 16 (94.500MHz) */
+
+                {      0x2B,0x41,104               },/* 17 (104.998MHz) */
+
+                {      0x3A,0x23,105               },/* 18 (105.882MHz) */
+
+                {      0x70,0x44,108               },/* 19 (107.862MHz) */
+
+                {      0x3C,0x23,109               },/* 1A (109.175MHz) */
+
+                {      0x5E,0x43,113              },/* 1B (113.309MHz) */
+
+                {      0xBC,0x44,116              },/* 1C (116.406MHz) */
+
+                {      0xE0,0x46,132              },/* 1D (132.258MHz) */
+
+                {      0x54,0x42,135               },/* 1E (135.500MHz) */
+
+                {      0x9C,0x22,139               },/* 1F (139.275MHz) */
+
+                {      0x41,0x22,157               },/* 20 (157.500MHz) */
+
+                {      0x70,0x24,162               },/* 21 (161.793MHz) */
+
+                {      0x30,0x21,175               },/* 22 (175.000MHz) */
+
+                {      0x4E,0x22,189              },/* 23 (188.520MHz) */
+
+                {      0xDE,0x26,194              },/* 24 (194.400MHz) */
+
+                {      0x62,0x06,202               },/* 25 (202.500MHz) */
+
+                {      0x3F,0x03,229               },/* 26 (229.500MHz) */
+
+                {      0xB8,0x06,234               },/* 27 (233.178MHz) */
+
+                {      0x34,0x02,253               },/* 28 (252.699MHz) */
+
+                {      0x58,0x04,255               },/* 29 (254.817MHz) */
+
+                {      0x24,0x01,265              },/* 2A (265.728MHz) */
+
+                {      0x9B,0x02,267               },/* 2B (266.952MHz) */
+
+                {      0x70,0x05,270               },/* 2C (269.65567MHz) */
+
+                {      0x25,0x01,272               },/* 2D (272.04199MHz) */
+
+                {      0x9C,0x02,277               },/* 2E (277.015MHz) */
+
+                {      0x27,0x01,286               },/* 2F (286.359985MHz) */
+
+                {      0xB3,0x04,291               },/* 30 (291.13266MHz) */
+
+                {      0xBC,0x05,292               },/* 31 (291.766MHz) */
+
+                {      0xF6,0x0A,310               },/* 32 (309.789459MHz) */
+
+                {      0x95,0x01,315               },/* 33 (315.195MHz) */
+
+                {      0xF0,0x09,324               },/* 34 (323.586792MHz) */
+
+                {      0xFE,0x0A,331               },/* 35 (330.615631MHz) */
+
+                {      0xF3,0x09,332              },/* 36 (332.177612MHz) */
+
+                {      0x5E,0x03,340              },/* 37 (340.477MHz) */
+
+                {      0xE8,0x07,376              },/* 38 (375.847504MHz) */
+
+                {      0xDE, 0x06,389             },/* 39 (388.631439MHz) */
+
+                {      0x52,0x2A,54               },/* 3A (54.000MHz) */
+
+                {      0x52,0x6A,27              },/* 3B (27.000MHz) */
+
+                {      0x62,0x24,70               },/* 3C (70.874991MHz) */
+
+                {      0x62,0x64,70               },/* 3D (70.1048912MHz) */
+
+                {      0xA8,0x4C,30               },/* 3E (30.1048912MHz) */
+
+                {      0x20,0x26,33               },/* 3F (33.7499957MHz) */
+
+                {      0x31,0xc2,39               },/* 40 (39.77MHz) */
+
+                {      0x11,0x21,30               },/* 41 (30MHz) }// NTSC 1024X768 */
+
+                {      0x2E,0x48,25               },/* 42 (25.175MHz) }// ScaleLCD */
+
+                {      0x24,0x46,25               },/* 43 (25.175MHz) */
+
+                {      0x26,0x64,28               },/* 44 (28.322MHz) */
+
+                {      0x37,0x64,40               },/* 45 (40.000MHz) */
+
+                {      0xA1,0x42,108               },/* 46 (95.000MHz) }// QVGA */
+
+                {      0x37,0x61,100               },/* 47 (100.00MHz) */
+
+                {      0x78,0x27,108               },/* 48 (108.200MHz) */
+
+                {      0xBF,0xC8,35               },/* 49 (35.2MHz) */
+
+                {      0x66,0x43,123               },/* 4A (122.61Mhz) */
+
+                {      0x2C,0x61,80               },/* 4B (80.350Mhz) */
+
+                {      0x3B,0x61,108               },/* 4C (107.385Mhz) */
+
+
+/*                {      0x60,0x36,30               },// 4D (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 4E (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 4F (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 50 (30.200MHz)   }// CHTV
+
+                {      0x40,0x4A,28               },// 51 (28.190MHz)
+
+                {      0x9F,0x46,44               },// 52 (43.600MHz)
+
+                {      0x97,0x2C,26               },// 53 (26.400MHz)
+
+                {      0x44,0xE4,25               },// 54 (24.600MHz)
+
+                {      0x7E,0x32,47               },// 55 (47.832MHz)
+
+                {      0x8A,0x24,31               },// 56 (31.500MHz)
+
+                {      0x97,0x2C,26               },// 57 (26.200MHz)
+
+                {      0xCE,0x3C,39               },// 58 (39.000MHz)
+
+                {      0x52,0x4A,36               },// 59 (36.000MHz)
+
+*/
+		{      0x69,0x61,191		  }, /* 4D (190.96MHz ) */
+		{      0x4F,0x22,192		  }, /* 4E (192.069MHz) */
+		{      0x28,0x26,322		  }, /* 4F (322.273MHz) */
+		{      0x5C,0x6B,27		  }, /* 50 (27.74HMz) */
+		{      0x57,0x24,126		  }, /* 51 (125.999MHz) */
+		{      0x5C,0x42,148		  }, /* 52 (148.5MHz) */
+		{      0x42,0x61,120		  }, /* 53 (120.839MHz) */
+		{      0x62,0x61,178		  }, /* 54 (178.992MHz) */
+		{      0x59,0x22,217		  }, /* 55 (217.325MHz) */
+		{      0x29,0x01,300		  }, /* 56 (299.505Mhz) */
+		{      0x52,0x63,74		  }, /* 57 (74.25MHz) */
+
+
+                {      0xFF,0x00,0                }/* End mark */
+ }  ;
+
+XGI330_VCLKDataStruct XGI_VBVCLKData[]=
+{
+                {      0x1B,0xE1,25               },/* 00 (25.175MHz) */
+
+                {      0x4E,0xE4,28               },/* 01 (28.322MHz) */
+
+                {      0x57,0xE4,31               },/* 02 (31.500MHz) */
+
+                {      0xC3,0xC8,36               },/* 03 (36.000MHz) */
+
+                {      0x42,0x47,40               },/* 04 (40.000MHz) */
+
+                {      0xFE,0xCD,43               },/* 05 (43.163MHz) */
+
+                {      0x5D,0xC4,44               },/* 06 (44.900MHz) */
+
+                {      0x52,0x47,49               },/* 07 (49.500MHz) */
+
+                {      0x53,0x47,50               },/* 08 (50.000MHz) */
+
+                {      0x74,0x67,52               },/* 09 (52.406MHz) */
+
+                {      0x6D,0x66,56               },/* 0A (56.250MHz) */
+
+                {      0x35,0x62,65               },/* 0B (65.000MHz) */
+
+                {      0x46,0x44,67               },/* 0C (67.765MHz) */
+
+                {      0xB1,0x46,68               },/* 0D (68.179MHz) */
+
+                {      0xD3,0x4A,72               },/* 0E (72.852MHz) */
+
+                {      0x29,0x61,75               },/* 0F (75.000MHz) */
+
+                {      0x6D,0x46,75               },/* 10 (75.800MHz) */
+
+                {      0x41,0x43,78               },/* 11 (78.750MHz) */
+
+                {      0x31,0x42,79               },/* 12 (79.411MHz) */
+
+                {      0xAB,0x44,83               },/* 13 (83.950MHz) */
+
+                {      0x46,0x25,84               },/* 14 (84.800MHz) */
+
+                {      0x78,0x29,86               },/* 15 (86.600MHz) */
+
+                {      0x62,0x44,94               },/* 16 (94.500MHz) */
+
+                {      0x2B,0x22,104               },/* 17 (104.998MHz) */
+
+                {      0x49,0x24,105               },/* 18 (105.882MHz) */
+
+                {      0xF8,0x2F,108               },/* 19 (108.279MHz) */
+
+                {      0x3C,0x23,109               },/* 1A (109.175MHz) */
+
+                {      0x5E,0x43,113               },/* 1B (113.309MHz) */
+
+                {      0xBC,0x44,116               },/* 1C (116.406MHz) */
+
+                {      0xE0,0x46,132               },/* 1D (132.258MHz) */
+
+                {      0xD4,0x28,135               },/* 1E (135.220MHz) */
+
+                {      0xEA,0x2A,139               },/* 1F (139.275MHz) */
+
+                {      0x41,0x22,157               },/* 20 (157.500MHz) */
+
+                {      0x70,0x24,162               },/* 21 (161.793MHz) */
+
+                {      0x30,0x21,175               },/* 22 (175.000MHz) */
+
+                {      0x4E,0x22,189               },/* 23 (188.520MHz) */
+
+                {      0xDE,0x26,194               },/* 24 (194.400MHz) */
+
+                {      0x70,0x07,202               },/* 25 (202.500MHz) */
+
+                {      0x3F,0x03,229               },/* 26 (229.500MHz) */
+
+                {      0xB8,0x06,234               },/* 27 (233.178MHz) */
+
+                {      0x34,0x02,253               },/* 28 (252.699997 MHz) */
+
+                {      0x58,0x04,255               },/* 29 (254.817MHz) */
+
+                {      0x24,0x01,265               },/* 2A (265.728MHz) */
+
+                {      0x9B,0x02,267               },/* 2B (266.952MHz) */
+
+                {      0x70,0x05,270               },/* 2C (269.65567 MHz) */
+
+                {      0x25,0x01,272               },/* 2D (272.041992 MHz) */
+
+                {      0x9C,0x02,277               },/* 2E (277.015MHz) */
+
+                {      0x27,0x01,286               },/* 2F (286.359985 MHz) */
+
+                {      0x3C,0x02,291               },/* 30 (291.132660 MHz) */
+
+                {      0xEF,0x0A,292               },/* 31 (291.766MHz) */
+
+                {      0xF6,0x0A,310               },/* 32 (309.789459 MHz) */
+
+                {      0x95,0x01,315               },/* 33 (315.195MHz) */
+
+                {      0xF0,0x09,324               },/* 34 (323.586792 MHz) */
+
+                {      0xFE,0x0A,331               },/* 35 (330.615631 MHz) */
+
+                {      0xF3,0x09,332               },/* 36 (332.177612 MHz) */
+
+                {      0xEA,0x08,340               },/* 37 (340.477MHz) */
+
+                {      0xE8,0x07,376               },/* 38 (375.847504 MHz) */
+
+                {      0xDE,0x06,389               },/* 39 (388.631439 MHz) */
+
+                {      0x52,0x2A,54                },/* 3A (54.000MHz) */
+
+                {      0x52,0x6A,27                },/* 3B (27.000MHz) */
+
+
+                {      0x62,0x24,70                },/* 3C (70.874991MHz) */
+
+
+                {      0x62,0x64,70                },/* 3D (70.1048912MHz) */
+
+                {      0xA8,0x4C,30                },/* 3E (30.1048912MHz) */
+
+                {      0x20,0x26,33                },/* 3F (33.7499957MHz) */
+
+                {      0x31,0xc2,39                },/* 40 (39.77MHz) */
+
+                {      0x11,0x21,30                },/* 41 (30MHz) }// NTSC 1024X768 */
+
+                {      0x2E,0x48,25                },/* 42 (25.175MHz) }// ScaleLCD */
+
+                {      0x24,0x46,25                },/* 43 (25.175MHz) */
+
+                {      0x26,0x64,28                },/* 44 (28.322MHz) */
+
+                {      0x37,0x64,40                },/* 45 (40.000MHz) */
+
+                {      0xA1,0x42,108               },/* 46 (95.000MHz) }// QVGA */
+
+                {      0x37,0x61,100               },/* 47 (100.00MHz) */
+
+                {      0x78,0x27,108               },/* 48 (108.200MHz) */
+
+                {      0xBF,0xC8,35                },/* 49 (35.2MHz) */
+
+                {      0x66,0x43,123               },/* 4A (122.61Mhz) */
+
+                {      0x2C,0x61,80                },/* 4B (80.350Mhz) */
+
+                {      0x3B,0x61,108               },/* 4C (107.385Mhz) */
+
+/*
+                {      0x60,0x36,30               },// 4D (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 4E (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 4F (30.200MHz)   }// No use
+
+                {      0x60,0x36,30               },// 50 (30.200MHz)   }// CHTV
+
+                {      0x40,0x4A,28               },// 51 (28.190MHz)
+
+                {      0x9F,0x46,44               },// 52 (43.600MHz)
+
+                {      0x97,0x2C,26               },// 53 (26.400MHz)
+
+                {      0x44,0xE4,25               },// 54 (24.600MHz)
+
+                {      0x7E,0x32,47               },// 55 (47.832MHz)
+
+                {      0x8A,0x24,31               },// 56 (31.500MHz)
+
+                {      0x97,0x2C,26               },// 57 (26.200MHz)
+
+                {      0xCE,0x3C,39               },// 58 (39.000MHz)
+
+                {      0x52,0x4A,36               },// 59 (36.000MHz)
+*/
+		{      0x69,0x61,191		  }, /* 4D (190.96MHz ) */
+		{      0x4F,0x22,192		  }, /* 4E (192.069MHz) */
+		{      0x28,0x26,322		  }, /* 4F (322.273MHz) */
+		{      0x5C,0x6B,27		  }, /* 50 (27.74HMz) */
+		{      0x57,0x24,126		  }, /* 51 (125.999MHz) */
+		{      0x5C,0x42,148		  }, /* 52 (148.5MHz) */
+		{      0x42,0x61,120		  }, /* 53 (120.839MHz) */
+		{      0x62,0x61,178		  }, /* 54 (178.992MHz) */
+		{      0x59,0x22,217		  }, /* 55 (217.325MHz) */
+		{      0x29,0x01,300		  }, /* 56 (299.505Mhz) */
+		{      0x52,0x63,74		  }, /* 57 (74.25MHz) */
+
+
+                {      0xFF,0x00,0                }      /* End mark */
+};
+
+UCHAR XGI660_TVDelayList[]=
+{
+          0x44,            /* ; 0 ExtNTSCDelay */
+          0x44,            /* ; 1 StNTSCDelay */
+          0x44,            /* ; 2 ExtPALDelay */
+          0x44,            /* ; 3 StPALDelay */
+          0x44,            /* ; 4 ExtHiTVDelay(1080i) */
+          0x44,            /* ; 5 StHiTVDelay(1080i) */
+          0x44,            /* ; 6 ExtYPbPrDelay(525i) */
+          0x44,            /* ; 7 StYPbPrDealy(525i) */
+          0x44,            /* ; 8 ExtYPbPrDelay(525p) */
+          0x44,            /* ; 9 StYPbPrDealy(525p) */
+          0x44,            /* ; A ExtYPbPrDelay(750p) */
+          0x44             /* ; B StYPbPrDealy(750p) */
+};
+
+UCHAR XGI660_TVDelayList2[]=
+{
+          0x44,           /* ; 0 ExtNTSCDelay */
+          0x44,           /* ; 1 StNTSCDelay */
+          0x44,           /* ; 2 ExtPALDelay */
+          0x44,           /* ; 3 StPALDelay */
+          0x44,           /* ; 4 ExtHiTVDelay */
+          0x44,           /* ; 5 StHiTVDelay */
+          0x44,           /* ; 6 ExtYPbPrDelay(525i) */
+          0x44,           /* ; 7 StYPbPrDealy(525i) */
+          0x44,           /* ; 8 ExtYPbPrDelay(525p) */
+          0x44,           /* ; 9 StYPbPrDealy(525p) */
+          0x44,           /* ; A ExtYPbPrDelay(750p) */
+          0x44            /* ; B StYPbPrDealy(750p) */
+};
+
+UCHAR XGI301TVDelayList[]=
+{
+	0x22,            /* ; 0 ExtNTSCDelay */
+	0x22,            /* ; 1 StNTSCDelay */
+	0x22,            /* ; 2 ExtPALDelay */
+	0x22,            /* ; 3 StPALDelay */
+	0x88,            /* ; 4 ExtHiTVDelay(1080i) */
+	0xBB,            /* ; 5 StHiTVDelay(1080i) */
+	0x22,            /* ; 6 ExtYPbPrDelay(525i) */
+	0x22,            /* ; 7 StYPbPrDealy(525i) */
+	0x22,            /* ; 8 ExtYPbPrDelay(525p) */
+	0x22,            /* ; 9 StYPbPrDealy(525p) */
+	0x22,            /* ; A ExtYPbPrDelay(750p) */
+	0x22            /* B StYPbPrDealy(750p) */
+};
+
+UCHAR XGI301TVDelayList2[]=
+{
+	0x22,           /* ; 0 ExtNTSCDelay */
+	0x22,           /* ; 1 StNTSCDelay */
+	0x22,           /* ; 2 ExtPALDelay */
+	0x22,           /* ; 3 StPALDelay */
+	0x22,           /* ; 4 ExtHiTVDelay */
+	0x22,           /* ; 5 StHiTVDelay */
+	0x22,           /* ; 6 ExtYPbPrDelay(525i) */
+	0x22,           /* ; 7 StYPbPrDealy(525i) */
+	0x22,           /* ; 8 ExtYPbPrDelay(525p) */
+	0x22,           /* ; 9 StYPbPrDealy(525p) */
+	0x22,           /* ; A ExtYPbPrDelay(750p) */
+	0x22            /* ; B StYPbPrDealy(750p) */
+};
+
+
+UCHAR TVAntiFlickList[]=
+{/* NTSCAntiFlicker */
+                      0x04,           /* ; 0 Adaptive */
+                      0x00,           /* ; 1 new anti-flicker ? */
+/* PALAntiFlicker */
+                      0x04,           /* ; 0 Adaptive */
+                      0x08,           /* ; 1 new anti-flicker ? */
+/* HiTVAntiFlicker */
+                      0x04,           /* ; 0 ? */
+                      0x00            /* ; 1 new anti-flicker ? */
+};
+
+
+UCHAR TVEdgeList[]=
+{
+      0x00,            /* ; 0 NTSC No Edge enhance */
+      0x04,            /* ; 1 NTSC Adaptive Edge enhance */
+      0x00,            /* ; 0 PAL No Edge enhance */
+      0x04,            /* ; 1 PAL Adaptive Edge enhance */
+      0x00,            /* ; 0 HiTV */
+      0x00             /* ; 1 HiTV */
+};
+
+ULONG TVPhaseList[]=
+{      0x08BAED21, /* ; 0 NTSC phase */
+       0x00E3052A, /* ; 1 PAL phase */
+       0x9B2EE421, /* ; 2 PAL-M phase */
+       0xBA3EF421, /* ; 3 PAL-N phase */
+       0xA7A28B1E, /* ; 4 NTSC 1024x768 */
+       0xE00A831E, /* ; 5 PAL-M 1024x768 */
+       0x00000000, /* ; 6 reserved */
+       0x00000000, /* ; 7 reserved */
+       0xD67BF021, /* ; 8 NTSC phase */
+       0xE986092A, /* ; 9 PAL phase */
+       0xA4EFE621, /* ; A PAL-M phase */
+       0x4694F621, /* ; B PAL-N phase */
+       0x8BDE711C, /* ; C NTSC 1024x768 */
+       0xE00A831E  /* ; D PAL-M 1024x768 */
+};
+
+UCHAR NTSCYFilter1[]=
+{
+		      0x00,0xF4,0x10,0x38     ,/* 0 : 320x text mode */
+                      0x00,0xF4,0x10,0x38     ,/* 1 : 360x text mode */
+                      0xEB,0x04,0x25,0x18     ,/* 2 : 640x text mode */
+                      0xF1,0x04,0x1F,0x18     ,/* 3 : 720x text mode */
+                      0x00,0xF4,0x10,0x38     ,/* 4 : 320x gra. mode */
+                      0xEB,0x04,0x25,0x18     ,/* 5 : 640x gra. mode */
+                      0xEB,0x15,0x25,0xF6     /* 6 : 800x gra. mode */
+};
+
+UCHAR PALYFilter1[]=
+{
+		      0x00,0xF4,0x10,0x38, /* 0 : 320x text mode */
+                      0x00,0xF4,0x10,0x38     ,/* 1 : 360x text mode */
+                      0xF1,0xF7,0x1F,0x32     ,/* 2 : 640x text mode */
+                      0xF3,0x00,0x1D,0x20     ,/* 3 : 720x text mode */
+                      0x00,0xF4,0x10,0x38     ,/* 4 : 320x gra. mode */
+                      0xF1,0xF7,0x1F,0x32     ,/* 5 : 640x gra. mode */
+                      0xFC,0xFB,0x14,0x2A     /* 6 : 800x gra. mode */
+};
+
+UCHAR PALMYFilter1[]=
+{
+		      0x00,0xF4,0x10,0x38, /* 0 : 320x text mode */
+                      0x00,0xF4,0x10,0x38, /* 1 : 360x text mode */
+                      0xEB,0x04,0x10,0x18, /* 2 : 640x text mode */
+                      0xF7,0x06,0x19,0x14, /* 3 : 720x text mode */
+                      0x00,0xF4,0x10,0x38, /* 4 : 320x gra. mode */
+                      0xEB,0x04,0x25,0x18, /* 5 : 640x gra. mode */
+                      0xEB,0x15,0x25,0xF6, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFF,0xFF  /* End of Table */
+};
+
+UCHAR PALNYFilter1[]=
+{
+		      0x00,0xF4,0x10,0x38, /* 0 : 320x text mode */
+                      0x00,0xF4,0x10,0x38, /* 1 : 360x text mode */
+                      0xEB,0x04,0x10,0x18, /* 2 : 640x text mode */
+                      0xF7,0x06,0x19,0x14, /* 3 : 720x text mode */
+                      0x00,0xF4,0x10,0x38, /* 4 : 320x gra. mode */
+                      0xEB,0x04,0x25,0x18, /* 5 : 640x gra. mode */
+                      0xEB,0x15,0x25,0xF6, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFF,0xFF  /* End of Table */
+};
+
+UCHAR NTSCYFilter2[]=
+{
+		      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 0 : 320x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 1 : 360x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 2 : 640x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 3 : 720x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 4 : 320x gra. mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 5 : 640x gra. mode */
+                      0x01,0x01,0xFC,0xF8,0x08,0x26,0x38, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFC,0x00,0x0F,0x22,0x28  /* 7 : 1024xgra. mode */
+};
+
+UCHAR PALYFilter2[]=
+{
+		      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 0 : 320x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 1 : 360x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 2 : 640x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 3 : 720x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 4 : 320x gra. mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 5 : 640x gra. mode */
+                      0x01,0x01,0xFC,0xF8,0x08,0x26,0x38, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFC,0x00,0x0F,0x22,0x28  /* 7 : 1024xgra. mode */
+};
+
+UCHAR PALMYFilter2[]=
+{
+		      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 0 : 320x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 1 : 360x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 2 : 640x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 3 : 720x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 4 : 320x gra. mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 5 : 640x gra. mode */
+                      0x01,0x01,0xFC,0xF8,0x08,0x26,0x38, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFC,0x00,0x0F,0x22,0x28  /* 7 : 1024xgra. mode */
+};
+
+UCHAR PALNYFilter2[]=
+{
+		      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 0 : 320x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 1 : 360x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 2 : 640x text mode */
+                      0x01,0x02,0xFE,0xF7,0x03,0x27,0x3C, /* 3 : 720x text mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 4 : 320x gra. mode */
+                      0xFF,0x03,0x02,0xF6,0xFC,0x27,0x46, /* 5 : 640x gra. mode */
+                      0x01,0x01,0xFC,0xF8,0x08,0x26,0x38, /* 6 : 800x gra. mode */
+                      0xFF,0xFF,0xFC,0x00,0x0F,0x22,0x28  /* 7 : 1024xgra. mode */
+};
+
+UCHAR XGI_NTSC1024AdjTime[]=
+{
+      0xa7,0x07,0xf2,0x6e,0x17,0x8b,0x73,0x53,
+      0x13,0x40,0x34,0xF4,0x63,0xBB,0xCC,0x7A,
+      0x58,0xe4,0x73,0xd0,0x13
+};
+
+XGI301C_Tap4TimingStruct HiTVTap4Timing[]=
+{
+	{0,{
+	0x00,0x20,0x00,0x00,0x7F,0x20,0x02,0x7F, /* ; C0-C7 */
+	0x7D,0x20,0x04,0x7F,0x7D,0x1F,0x06,0x7E, /* ; C8-CF */
+	0x7C,0x1D,0x09,0x7E,0x7C,0x1B,0x0B,0x7E, /* ; D0-D7 */
+	0x7C,0x19,0x0E,0x7D,0x7C,0x17,0x11,0x7C, /* ; D8-DF */
+	0x7C,0x14,0x14,0x7C,0x7C,0x11,0x17,0x7C, /* ; E0-E7 */
+	0x7D,0x0E,0x19,0x7C,0x7E,0x0B,0x1B,0x7C, /* ; EA-EF */
+	0x7E,0x09,0x1D,0x7C,0x7F,0x06,0x1F,0x7C, /* ; F0-F7 */
+	0x7F,0x04,0x20,0x7D,0x00,0x02,0x20,0x7E  /* ; F8-FF */
+	}
+	}
+};
+
+XGI301C_Tap4TimingStruct EnlargeTap4Timing[]=
+{
+	{0,{
+	0x00,0x20,0x00,0x00,0x7F,0x20,0x02,0x7F, /* ; C0-C7 */
+	0x7D,0x20,0x04,0x7F,0x7D,0x1F,0x06,0x7E, /* ; C8-CF */
+	0x7C,0x1D,0x09,0x7E,0x7C,0x1B,0x0B,0x7E, /* ; D0-D7 */
+	0x7C,0x19,0x0E,0x7D,0x7C,0x17,0x11,0x7C, /* ; D8-DF */
+	0x7C,0x14,0x14,0x7C,0x7C,0x11,0x17,0x7C, /* ; E0-E7 */
+	0x7D,0x0E,0x19,0x7C,0x7E,0x0B,0x1B,0x7C, /* ; EA-EF */
+	0x7E,0x09,0x1D,0x7C,0x7F,0x06,0x1F,0x7C, /* ; F0-F7 */
+	0x7F,0x04,0x20,0x7D,0x00,0x02,0x20,0x7E   /* ; F8-FF */
+	}
+	}
+};
+
+XGI301C_Tap4TimingStruct NoScaleTap4Timing[]=
+{
+	{0,{
+	0x00,0x20,0x00,0x00,0x7F,0x20,0x02,0x7F, /* ; C0-C7 */
+	0x7D,0x20,0x04,0x7F,0x7D,0x1F,0x06,0x7E, /* ; C8-CF */
+	0x7C,0x1D,0x09,0x7E,0x7C,0x1B,0x0B,0x7E, /* ; D0-D7 */
+	0x7C,0x19,0x0E,0x7D,0x7C,0x17,0x11,0x7C, /* ; D8-DF */
+	0x7C,0x14,0x14,0x7C,0x7C,0x11,0x17,0x7C, /* ; E0-E7 */
+	0x7D,0x0E,0x19,0x7C,0x7E,0x0B,0x1B,0x7C, /* ; EA-EF */
+	0x7E,0x09,0x1D,0x7C,0x7F,0x06,0x1F,0x7C, /* ; F0-F7 */
+	0x7F,0x04,0x20,0x7D,0x00,0x02,0x20,0x7E  /* ; F8-FF */
+	}
+	}
+};
+
+XGI301C_Tap4TimingStruct PALTap4Timing[]=
+{
+	{600,  {
+                0x05,0x19,0x05,0x7D,0x03,0x19,0x06,0x7E, /* ; C0-C7 */
+                0x02,0x19,0x08,0x7D,0x01,0x18,0x0A,0x7D, /* ; C8-CF */
+                0x00,0x18,0x0C,0x7C,0x7F,0x17,0x0E,0x7C, /* ; D0-D7 */
+                0x7E,0x16,0x0F,0x7D,0x7E,0x14,0x11,0x7D, /* ; D8-DF */
+                0x7D,0x13,0x13,0x7D,0x7D,0x11,0x14,0x7E, /* ; E0-E7 */
+                0x7D,0x0F,0x16,0x7E,0x7D,0x0E,0x17,0x7E, /* ; EA-EF */
+                0x7D,0x0C,0x18,0x7F,0x7D,0x0A,0x18,0x01, /* ; F0-F7 */
+                0x7D,0x08,0x19,0x02,0x7D,0x06,0x19,0x04  /* ; F8-FF */
+                }
+ 	},
+        {768,	{
+                0x08,0x12,0x08,0x7E,0x07,0x12,0x09,0x7E, /* ; C0-C7 */
+                0x06,0x12,0x0A,0x7E,0x05,0x11,0x0B,0x7F, /* ; C8-CF */
+                0x04,0x11,0x0C,0x7F,0x03,0x11,0x0C,0x00, /* ; D0-D7 */
+                0x03,0x10,0x0D,0x00,0x02,0x0F,0x0E,0x01, /* ; D8-DF */
+                0x01,0x0F,0x0F,0x01,0x01,0x0E,0x0F,0x02, /* ; E0-E7 */
+                0x00,0x0D,0x10,0x03,0x7F,0x0C,0x11,0x04, /* ; EA-EF */
+                0x7F,0x0C,0x11,0x04,0x7F,0x0B,0x11,0x05, /* ; F0-F7 */
+                0x7E,0x0A,0x12,0x06,0x7E,0x09,0x12,0x07  /* ; F8-FF */
+                }
+        },
+        {0xFFFF,
+        	{
+                0x04,0x1A,0x04,0x7E,0x02,0x1B,0x05,0x7E, /* ; C0-C7 */
+                0x01,0x1A,0x07,0x7E,0x00,0x1A,0x09,0x7D, /* ; C8-CF */
+                0x7F,0x19,0x0B,0x7D,0x7E,0x18,0x0D,0x7D, /* ; D0-D7 */
+                0x7D,0x17,0x10,0x7C,0x7D,0x15,0x12,0x7C, /* ; D8-DF */
+                0x7C,0x14,0x14,0x7C,0x7C,0x12,0x15,0x7D, /* ; E0-E7 */
+                0x7C,0x10,0x17,0x7D,0x7C,0x0D,0x18,0x7F, /* ; EA-EF */
+                0x7D,0x0B,0x19,0x7F,0x7D,0x09,0x1A,0x00, /* ; F0-F7 */
+                0x7D,0x07,0x1A,0x02,0x7E,0x05,0x1B,0x02  /* ; F8-FF */
+                }
+        }
+};
+
+XGI301C_Tap4TimingStruct NTSCTap4Timing[]=
+{
+	{480,	{
+              	0x04,0x1A,0x04,0x7E,0x03,0x1A,0x06,0x7D, /* ; C0-C7 */
+              	0x01,0x1A,0x08,0x7D,0x00,0x19,0x0A,0x7D, /* ; C8-CF */
+              	0x7F,0x19,0x0C,0x7C,0x7E,0x18,0x0E,0x7C, /* ; D0-D7 */
+              	0x7E,0x17,0x10,0x7B,0x7D,0x15,0x12,0x7C, /* ; D8-DF */
+              	0x7D,0x13,0x13,0x7D,0x7C,0x12,0x15,0x7D, /* ; E0-E7 */
+              	0x7C,0x10,0x17,0x7D,0x7C,0x0E,0x18,0x7E, /* ; EA-EF */
+              	0x7D,0x0C,0x19,0x7E,0x7D,0x0A,0x19,0x00, /* ; F0-F7 */
+              	0x7D,0x08,0x1A,0x01,0x7E,0x06,0x1A,0x02  /* ; F8-FF */
+        	}
+        },
+        {600,	{
+              	0x07,0x14,0x07,0x7E,0x06,0x14,0x09,0x7D, /* ; C0-C7 */
+              	0x05,0x14,0x0A,0x7D,0x04,0x13,0x0B,0x7E, /* ; C8-CF */
+              	0x03,0x13,0x0C,0x7E,0x02,0x12,0x0D,0x7F, /* ; D0-D7 */
+              	0x01,0x12,0x0E,0x7F,0x01,0x11,0x0F,0x7F, /* ; D8-DF */
+              	0x01,0x10,0x10,0x00,0x7F,0x0F,0x11,0x01, /* ; E0-E7 */
+              	0x7F,0x0E,0x12,0x01,0x7E,0x0D,0x12,0x03, /* ; EA-EF */
+              	0x7E,0x0C,0x13,0x03,0x7E,0x0B,0x13,0x04, /* ; F0-F7 */
+              	0x7E,0x0A,0x14,0x04,0x7D,0x09,0x14,0x06  /* ; F8-FF */
+        	}
+        },
+        {0xFFFF,
+        	{
+              	0x09,0x0F,0x09,0x7F,0x08,0x0F,0x09,0x00, /* ; C0-C7 */
+              	0x07,0x0F,0x0A,0x00,0x06,0x0F,0x0A,0x01, /* ; C8-CF */
+              	0x06,0x0E,0x0B,0x01,0x05,0x0E,0x0B,0x02, /* ; D0-D7 */
+              	0x04,0x0E,0x0C,0x02,0x04,0x0D,0x0C,0x03, /* ; D8-DF */
+              	0x03,0x0D,0x0D,0x03,0x02,0x0C,0x0D,0x05, /* ; E0-E7 */
+              	0x02,0x0C,0x0E,0x04,0x01,0x0B,0x0E,0x06, /* ; EA-EF */
+              	0x01,0x0B,0x0E,0x06,0x00,0x0A,0x0F,0x07, /* ; F0-F7 */
+              	0x00,0x0A,0x0F,0x07,0x00,0x09,0x0F,0x08  /* ; F8-FF */
+        	}
+        }
+};
+
+XGI301C_Tap4TimingStruct YPbPr525pTap4Timing[]=
+{
+	{480,	{
+              	0x04,0x1A,0x04,0x7E,0x03,0x1A,0x06,0x7D, /* ; C0-C7 */
+              	0x01,0x1A,0x08,0x7D,0x00,0x19,0x0A,0x7D, /* ; C8-CF */
+              	0x7F,0x19,0x0C,0x7C,0x7E,0x18,0x0E,0x7C, /* ; D0-D7 */
+              	0x7E,0x17,0x10,0x7B,0x7D,0x15,0x12,0x7C, /* ; D8-DF */
+              	0x7D,0x13,0x13,0x7D,0x7C,0x12,0x15,0x7D, /* ; E0-E7 */
+              	0x7C,0x10,0x17,0x7D,0x7C,0x0E,0x18,0x7E, /* ; EA-EF */
+              	0x7D,0x0C,0x19,0x7E,0x7D,0x0A,0x19,0x00, /* ; F0-F7 */
+              	0x7D,0x08,0x1A,0x01,0x7E,0x06,0x1A,0x02  /* ; F8-FF */
+        	}
+        },
+        {600,	{
+              	0x07,0x14,0x07,0x7E,0x06,0x14,0x09,0x7D, /* ; C0-C7 */
+              	0x05,0x14,0x0A,0x7D,0x04,0x13,0x0B,0x7E, /* ; C8-CF */
+              	0x03,0x13,0x0C,0x7E,0x02,0x12,0x0D,0x7F, /* ; D0-D7 */
+              	0x01,0x12,0x0E,0x7F,0x01,0x11,0x0F,0x7F, /* ; D8-DF */
+              	0x01,0x10,0x10,0x00,0x7F,0x0F,0x11,0x01, /* ; E0-E7 */
+              	0x7F,0x0E,0x12,0x01,0x7E,0x0D,0x12,0x03, /* ; EA-EF */
+              	0x7E,0x0C,0x13,0x03,0x7E,0x0B,0x13,0x04, /* ; F0-F7 */
+              	0x7E,0x0A,0x14,0x04,0x7D,0x09,0x14,0x06  /* ; F8-FF */
+        	}
+        },
+        {0xFFFF,
+        	{
+              	0x09,0x0F,0x09,0x7F,0x08,0x0F,0x09,0x00, /* ; C0-C7 */
+              	0x07,0x0F,0x0A,0x00,0x06,0x0F,0x0A,0x01, /* ; C8-CF */
+              	0x06,0x0E,0x0B,0x01,0x05,0x0E,0x0B,0x02, /* ; D0-D7 */
+              	0x04,0x0E,0x0C,0x02,0x04,0x0D,0x0C,0x03, /* ; D8-DF */
+              	0x03,0x0D,0x0D,0x03,0x02,0x0C,0x0D,0x05, /* ; E0-E7 */
+              	0x02,0x0C,0x0E,0x04,0x01,0x0B,0x0E,0x06, /* ; EA-EF */
+              	0x01,0x0B,0x0E,0x06,0x00,0x0A,0x0F,0x07, /* ; F0-F7 */
+              	0x00,0x0A,0x0F,0x07,0x00,0x09,0x0F,0x08  /* ; F8-FF */
+        	}
+        }
+};
+
+XGI301C_Tap4TimingStruct YPbPr525iTap4Timing[]=
+{
+	{480,	{
+              	0x04,0x1A,0x04,0x7E,0x03,0x1A,0x06,0x7D, /* ; C0-C7 */
+              	0x01,0x1A,0x08,0x7D,0x00,0x19,0x0A,0x7D, /* ; C8-CF */
+              	0x7F,0x19,0x0C,0x7C,0x7E,0x18,0x0E,0x7C, /* ; D0-D7 */
+              	0x7E,0x17,0x10,0x7B,0x7D,0x15,0x12,0x7C, /* ; D8-DF */
+              	0x7D,0x13,0x13,0x7D,0x7C,0x12,0x15,0x7D, /* ; E0-E7 */
+              	0x7C,0x10,0x17,0x7D,0x7C,0x0E,0x18,0x7E, /* ; EA-EF */
+              	0x7D,0x0C,0x19,0x7E,0x7D,0x0A,0x19,0x00, /* ; F0-F7 */
+              	0x7D,0x08,0x1A,0x01,0x7E,0x06,0x1A,0x02  /* ; F8-FF */
+        	}
+        },
+        {600,	{
+              	0x07,0x14,0x07,0x7E,0x06,0x14,0x09,0x7D, /* ; C0-C7 */
+              	0x05,0x14,0x0A,0x7D,0x04,0x13,0x0B,0x7E, /* ; C8-CF */
+              	0x03,0x13,0x0C,0x7E,0x02,0x12,0x0D,0x7F, /* ; D0-D7 */
+              	0x01,0x12,0x0E,0x7F,0x01,0x11,0x0F,0x7F, /* ; D8-DF */
+              	0x01,0x10,0x10,0x00,0x7F,0x0F,0x11,0x01, /* ; E0-E7 */
+              	0x7F,0x0E,0x12,0x01,0x7E,0x0D,0x12,0x03, /* ; EA-EF */
+              	0x7E,0x0C,0x13,0x03,0x7E,0x0B,0x13,0x04, /* ; F0-F7 */
+              	0x7E,0x0A,0x14,0x04,0x7D,0x09,0x14,0x06  /* ; F8-FF */
+        	}
+        },
+        {0xFFFF,
+        	{
+              	0x09,0x0F,0x09,0x7F,0x08,0x0F,0x09,0x00, /* ; C0-C7 */
+              	0x07,0x0F,0x0A,0x00,0x06,0x0F,0x0A,0x01, /* ; C8-CF */
+              	0x06,0x0E,0x0B,0x01,0x05,0x0E,0x0B,0x02, /* ; D0-D7 */
+              	0x04,0x0E,0x0C,0x02,0x04,0x0D,0x0C,0x03, /* ; D8-DF */
+              	0x03,0x0D,0x0D,0x03,0x02,0x0C,0x0D,0x05, /* ; E0-E7 */
+              	0x02,0x0C,0x0E,0x04,0x01,0x0B,0x0E,0x06, /* ; EA-EF */
+              	0x01,0x0B,0x0E,0x06,0x00,0x0A,0x0F,0x07, /* ; F0-F7 */
+              	0x00,0x0A,0x0F,0x07,0x00,0x09,0x0F,0x08  /* ; F8-FF */
+        	}
+        }
+};
+
+XGI301C_Tap4TimingStruct YPbPr750pTap4Timing[]=
+{        {0xFFFF,
+               {
+               0x05,0x19,0x05,0x7D,0x03,0x19,0x06,0x7E, /* ; C0-C7 */
+               0x02,0x19,0x08,0x7D,0x01,0x18,0x0A,0x7D, /* ; C8-CF */
+               0x00,0x18,0x0C,0x7C,0x7F,0x17,0x0E,0x7C, /* ; D0-D7 */
+               0x7E,0x16,0x0F,0x7D,0x7E,0x14,0x11,0x7D, /* ; D8-DF */
+               0x7D,0x13,0x13,0x7D,0x7D,0x11,0x14,0x7E, /* ; E0-E7 */
+               0x7D,0x0F,0x16,0x7E,0x7D,0x0E,0x17,0x7E, /* ; EA-EF */
+               0x7D,0x0C,0x18,0x7F,0x7D,0x0A,0x18,0x01, /* ; F0-F7 */
+               0x7D,0x08,0x19,0x02,0x7D,0x06,0x19,0x04 /* F8-FF */
+               }
+        }
+};
--- /dev/null
+++ b/drivers/staging/xgifb/vb_util.c
@@ -0,0 +1,263 @@
+#include "osdef.h"
+#include "vb_def.h"
+#include "vgatypes.h"
+#include "vb_struct.h"
+
+#ifdef LINUX_KERNEL
+#include "XGIfb.h"
+#include <asm/io.h>
+#include <linux/types.h>
+#endif
+
+#ifdef TC
+#include <stdio.h>
+#include <string.h>
+#include <conio.h>
+#include <dos.h>
+#endif
+
+#ifdef WIN2000
+#include <dderror.h>
+#include <devioctl.h>
+#include <miniport.h>
+#include <ntddvdeo.h>
+#include <video.h>
+
+#include "xgiv.h"
+#include "dd_i2c.h"
+#include "tools.h"
+#endif
+
+#ifdef LINUX_XF86
+#include "xf86.h"
+#include "xf86PciInfo.h"
+#include "xgi.h"
+#include "xgi_regs.h"
+#endif
+
+
+
+
+void XGINew_SetReg1( ULONG , USHORT , USHORT ) ;
+void XGINew_SetReg2( ULONG , USHORT , USHORT ) ;
+void XGINew_SetReg3( ULONG , USHORT ) ;
+void XGINew_SetReg4( ULONG , ULONG ) ;
+UCHAR XGINew_GetReg1( ULONG , USHORT) ;
+UCHAR XGINew_GetReg2( ULONG ) ;
+ULONG XGINew_GetReg3( ULONG ) ;
+void XGINew_ClearDAC( PUCHAR ) ;
+void     XGINew_SetRegANDOR(ULONG Port,USHORT Index,USHORT DataAND,USHORT DataOR);
+void     XGINew_SetRegOR(ULONG Port,USHORT Index,USHORT DataOR);
+void     XGINew_SetRegAND(ULONG Port,USHORT Index,USHORT DataAND);
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetReg1 */
+/* Input : */
+/* Output : */
+/* Description : SR CRTC GR */
+/* --------------------------------------------------------------------- */
+void XGINew_SetReg1( ULONG port , USHORT index , USHORT data )
+{
+#ifdef LINUX_XF86
+    OutPortByte( ( PUCHAR )(ULONG)port , index ) ;
+    OutPortByte( ( PUCHAR )(ULONG)port + 1 , data ) ;
+#else
+    OutPortByte( port , index ) ;
+    OutPortByte( port + 1 , data ) ;
+#endif
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetReg2 */
+/* Input : */
+/* Output : */
+/* Description : AR( 3C0 ) */
+/* --------------------------------------------------------------------- */
+/*void XGINew_SetReg2( ULONG port , USHORT index , USHORT data )
+{
+    InPortByte( ( PUCHAR )port + 0x3da - 0x3c0 ) ;
+    OutPortByte( XGINew_P3c0 , index ) ;
+    OutPortByte( XGINew_P3c0 , data ) ;
+    OutPortByte( XGINew_P3c0 , 0x20 ) ;
+}*/
+
+
+/* --------------------------------------------------------------------- */
+/* Function : */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetReg3( ULONG port , USHORT data )
+{
+    OutPortByte( port , data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetReg4 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetReg4( ULONG port , ULONG data )
+{
+    OutPortLong( port , data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_GetReg1 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGINew_GetReg1( ULONG port , USHORT index )
+{
+    UCHAR data ;
+
+#ifdef LINUX_XF86
+    OutPortByte( ( PUCHAR )(ULONG)port , index ) ;
+    data = InPortByte( ( PUCHAR )(ULONG)port + 1 ) ;
+#else
+    OutPortByte( port , index ) ;
+    data = InPortByte( port + 1 ) ;
+#endif
+
+    return( data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_GetReg2 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+UCHAR XGINew_GetReg2( ULONG port )
+{
+    UCHAR data ;
+
+    data = InPortByte( port ) ;
+
+    return( data ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_GetReg3 */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+ULONG XGINew_GetReg3( ULONG port )
+{
+    ULONG data ;
+
+    data = InPortLong( port ) ;
+
+    return( data ) ;
+}
+
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetRegANDOR */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetRegANDOR( ULONG Port , USHORT Index , USHORT DataAND , USHORT DataOR )
+{
+    USHORT temp ;
+
+    temp = XGINew_GetReg1( Port , Index ) ;		/* XGINew_Part1Port index 02 */
+    temp = ( temp & ( DataAND ) ) | DataOR ;
+    XGINew_SetReg1( Port , Index , temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetRegAND */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetRegAND(ULONG Port,USHORT Index,USHORT DataAND)
+{
+    USHORT temp ;
+
+    temp = XGINew_GetReg1( Port , Index ) ;	/* XGINew_Part1Port index 02 */
+    temp &= DataAND ;
+    XGINew_SetReg1( Port , Index , temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : XGINew_SetRegOR */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void XGINew_SetRegOR( ULONG Port , USHORT Index , USHORT DataOR )
+{
+    USHORT temp ;
+
+    temp = XGINew_GetReg1( Port , Index ) ;	/* XGINew_Part1Port index 02 */
+    temp |= DataOR ;
+    XGINew_SetReg1( Port , Index , temp ) ;
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : NewDelaySecond */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void NewDelaySeconds( int seconds )
+{
+#ifdef WIN2000
+    int j ;
+#endif
+    int i ;
+
+
+    for( i = 0 ; i < seconds ; i++ )
+    {
+#ifdef TC
+        delay( 1000 ) ;
+#endif
+
+#ifdef WIN2000
+
+        for ( j = 0 ; j < 20000 ; j++ )
+            VideoPortStallExecution( 50 ) ;
+#endif
+
+#ifdef WINCE_HEADER
+#endif
+
+#ifdef LINUX_KERNEL
+#endif
+    }
+}
+
+
+/* --------------------------------------------------------------------- */
+/* Function : Newdebugcode */
+/* Input : */
+/* Output : */
+/* Description : */
+/* --------------------------------------------------------------------- */
+void Newdebugcode( UCHAR code )
+{
+//    OutPortByte ( 0x80 , code ) ;
+    /* OutPortByte ( 0x300 , code ) ; */
+    /* NewDelaySeconds( 0x3 ) ; */
+}
+
+
+
--- /dev/null
+++ b/drivers/staging/xgifb/vb_util.h
@@ -0,0 +1,15 @@
+#ifndef _VBUTIL_
+#define _VBUTIL_
+extern   void     NewDelaySeconds( int );
+extern   void     Newdebugcode( UCHAR );
+extern   void     XGINew_SetReg1(ULONG, USHORT, USHORT);
+extern   void     XGINew_SetReg3(ULONG, USHORT);
+extern   UCHAR    XGINew_GetReg1(ULONG, USHORT);
+extern   UCHAR    XGINew_GetReg2(ULONG);
+extern   void     XGINew_SetReg4(ULONG, ULONG);
+extern   ULONG    XGINew_GetReg3(ULONG);
+extern   void     XGINew_SetRegOR(ULONG Port,USHORT Index,USHORT DataOR);
+extern   void     XGINew_SetRegAND(ULONG Port,USHORT Index,USHORT DataAND);
+extern   void     XGINew_SetRegANDOR(ULONG Port,USHORT Index,USHORT DataAND,USHORT DataOR);
+#endif
+
--- /dev/null
+++ b/drivers/staging/xgifb/vgatypes.h
@@ -0,0 +1,325 @@
+
+#ifndef _VGATYPES_
+#define _VGATYPES_
+
+#include "osdef.h"
+
+#ifdef LINUX_XF86
+#include "xf86Version.h"
+#include "xf86Pci.h"
+#endif
+
+#ifdef LINUX_KERNEL  /* We don't want the X driver to depend on kernel source */
+#include <linux/ioctl.h>
+#endif
+
+#ifndef FALSE
+#define FALSE   0
+#endif
+
+#ifndef TRUE
+#define TRUE    1
+#endif
+
+#ifndef NULL
+#define NULL    0
+#endif
+
+#ifndef CHAR
+typedef char CHAR;
+#endif
+
+#ifndef SHORT
+typedef short SHORT;
+#endif
+
+#ifndef LONG
+typedef long  LONG;
+#endif
+
+#ifndef UCHAR
+typedef unsigned char UCHAR;
+#endif
+
+#ifndef USHORT
+typedef unsigned short USHORT;
+#endif
+
+#ifndef ULONG
+typedef unsigned long ULONG;
+#endif
+
+#ifndef PUCHAR
+typedef UCHAR *PUCHAR;
+#endif
+
+#ifndef PUSHORT
+typedef USHORT *PUSHORT;
+#endif
+
+#ifndef PLONGU
+typedef ULONG *PULONG;
+#endif
+
+#ifndef VOID
+typedef void VOID;
+#endif
+
+#ifndef PVOID
+typedef void *PVOID;
+#endif
+
+#ifndef BOOLEAN
+typedef UCHAR BOOLEAN;
+#endif
+/*
+#ifndef bool
+typedef UCHAR bool;
+#endif
+*/
+#ifdef LINUX_KERNEL
+typedef unsigned long XGIIOADDRESS;
+#endif
+
+#ifdef LINUX_XF86
+#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,0,0,0)
+typedef unsigned char IOADDRESS;
+typedef unsigned char XGIIOADDRESS;
+#else
+typedef IOADDRESS XGIIOADDRESS;
+#endif
+#endif
+
+#ifndef VBIOS_VER_MAX_LENGTH
+#define VBIOS_VER_MAX_LENGTH    4
+#endif
+
+#ifndef WIN2000
+
+#ifndef LINUX_KERNEL   /* For the linux kernel, this is defined in xgifb.h */
+#ifndef XGI_CHIP_TYPE
+typedef enum _XGI_CHIP_TYPE {
+    XGI_VGALegacy = 0,
+#ifdef LINUX_XF86
+    XGI_530,
+    XGI_OLD,
+#endif
+    XGI_300,
+    XGI_630,
+    XGI_640,
+    XGI_315H,
+    XGI_315,
+    XGI_315PRO,
+    XGI_550,
+    XGI_650,
+    XGI_650M,
+    XGI_740,
+    XGI_330,
+    XGI_661,
+    XGI_660,
+    XGI_760,
+    XG40 = 32,
+    XG41,
+    XG42,
+    XG45,
+    XG20 = 48,
+    XG21,
+    XG27,
+    MAX_XGI_CHIP
+} XGI_CHIP_TYPE;
+#endif
+#endif
+
+#ifndef XGI_VB_CHIP_TYPE
+typedef enum _XGI_VB_CHIP_TYPE {
+    VB_CHIP_Legacy = 0,
+    VB_CHIP_301,
+    VB_CHIP_301B,
+    VB_CHIP_301LV,
+    VB_CHIP_302,
+    VB_CHIP_302B,
+    VB_CHIP_302LV,
+    VB_CHIP_301C,
+    VB_CHIP_302ELV,
+    VB_CHIP_UNKNOWN, /* other video bridge or no video bridge */
+    MAX_VB_CHIP
+} XGI_VB_CHIP_TYPE;
+#endif
+
+#ifndef XGI_LCD_TYPE
+typedef enum _XGI_LCD_TYPE {
+    LCD_INVALID = 0,
+    LCD_320x480,       /* FSTN, DSTN */
+    LCD_640x480,
+    LCD_640x480_2,     /* FSTN, DSTN */
+    LCD_640x480_3,     /* FSTN, DSTN */
+    LCD_800x600,
+    LCD_848x480,
+    LCD_1024x600,
+    LCD_1024x768,
+    LCD_1152x768,
+    LCD_1152x864,
+    LCD_1280x720,
+    LCD_1280x768,
+    LCD_1280x800,
+    LCD_1280x960,
+    LCD_1280x1024,
+    LCD_1400x1050,
+    LCD_1600x1200,
+    LCD_1680x1050,
+    LCD_1920x1440,
+    LCD_2048x1536,
+    LCD_CUSTOM,
+    LCD_UNKNOWN
+} XGI_LCD_TYPE;
+#endif
+
+#endif   /* not WIN2000 */
+
+#ifndef PXGI_DSReg
+typedef struct _XGI_DSReg
+{
+  UCHAR  jIdx;
+  UCHAR  jVal;
+} XGI_DSReg, *PXGI_DSReg;
+#endif
+
+#ifndef XGI_HW_DEVICE_INFO
+
+typedef struct _XGI_HW_DEVICE_INFO  XGI_HW_DEVICE_INFO, *PXGI_HW_DEVICE_INFO;
+
+typedef BOOLEAN (*PXGI_QUERYSPACE)   (PXGI_HW_DEVICE_INFO, ULONG, ULONG, ULONG *);
+
+struct _XGI_HW_DEVICE_INFO
+{
+    ULONG  ulExternalChip;       /* NO VB or other video bridge*/
+                                 /* if ujVBChipID = VB_CHIP_UNKNOWN, */
+#ifdef LINUX_XF86
+    PCITAG PciTag;		 /* PCI Tag */
+#endif
+
+    PUCHAR  pjVirtualRomBase;    /* ROM image */
+
+    BOOLEAN UseROM;		 /* Use the ROM image if provided */
+
+    PVOID   pDevice;
+
+    PUCHAR  pjVideoMemoryAddress;/* base virtual memory address */
+                                 /* of Linear VGA memory */
+
+    ULONG  ulVideoMemorySize;    /* size, in bytes, of the memory on the board */
+
+    PUCHAR pjIOAddress;          /* base I/O address of VGA ports (0x3B0) */
+
+    PUCHAR pjCustomizedROMImage;
+
+    PUCHAR pj2ndVideoMemoryAddress;
+    ULONG  ul2ndVideoMemorySize;
+
+    PUCHAR pj2ndIOAddress;
+/*#ifndef WIN2000
+    XGIIOADDRESS pjIOAddress;   //  base I/O address of VGA ports (0x3B0)
+#endif */
+    UCHAR  jChipType;            /* Used to Identify Graphics Chip */
+                                 /* defined in the data structure type  */
+                                 /* "XGI_CHIP_TYPE" */
+
+    UCHAR  jChipRevision;        /* Used to Identify Graphics Chip Revision */
+
+    UCHAR  ujVBChipID;           /* the ID of video bridge */
+                                 /* defined in the data structure type */
+                                 /* "XGI_VB_CHIP_TYPE" */
+
+    BOOLEAN    bNewScratch;
+
+    ULONG  ulCRT2LCDType;        /* defined in the data structure type */
+
+    ULONG usExternalChip;       /* NO VB or other video bridge (other than  */
+                                 /*  video bridge) */
+
+    BOOLEAN bIntegratedMMEnabled;/* supporting integration MM enable */
+
+    BOOLEAN bSkipDramSizing;     /* True: Skip video memory sizing. */
+
+    BOOLEAN bSkipSense;
+
+    BOOLEAN bIsPowerSaving;     /* True: XGIInit() is invoked by power management,
+                                   otherwise by 2nd adapter's initialzation */
+
+    PXGI_DSReg  pSR;             /* restore SR registers in initial function. */
+                                 /* end data :(idx, val) =  (FF, FF). */
+                                 /* Note : restore SR registers if  */
+                                 /* bSkipDramSizing = TRUE */
+
+    PXGI_DSReg  pCR;             /* restore CR registers in initial function. */
+                                 /* end data :(idx, val) =  (FF, FF) */
+                                 /* Note : restore cR registers if  */
+                                 /* bSkipDramSizing = TRUE */
+/*
+#endif
+*/
+
+    PXGI_QUERYSPACE  pQueryVGAConfigSpace;
+
+    PXGI_QUERYSPACE  pQueryNorthBridgeSpace;
+
+    UCHAR  szVBIOSVer[VBIOS_VER_MAX_LENGTH];
+
+};
+#endif
+
+/* Addtional IOCTL for communication xgifb <> X driver        */
+/* If changing this, xgifb.h must also be changed (for xgifb) */
+
+#ifdef LINUX_XF86  /* We don't want the X driver to depend on the kernel source */
+
+/* ioctl for identifying and giving some info (esp. memory heap start) */
+#define XGIFB_GET_INFO    0x80046ef8  /* Wow, what a terrible hack... */
+
+/* Structure argument for XGIFB_GET_INFO ioctl  */
+typedef struct _XGIFB_INFO xgifb_info, *pxgifb_info;
+
+struct _XGIFB_INFO {
+	CARD32 	xgifb_id;         	/* for identifying xgifb */
+#ifndef XGIFB_ID
+#define XGIFB_ID	  0x53495346    /* Identify myself with 'XGIF' */
+#endif
+ 	CARD32 	chip_id;		/* PCI ID of detected chip */
+	CARD32	memory;			/* video memory in KB which xgifb manages */
+	CARD32	heapstart;             	/* heap start (= xgifb "mem" argument) in KB */
+	CARD8 	fbvidmode;		/* current xgifb mode */
+
+	CARD8 	xgifb_version;
+	CARD8	xgifb_revision;
+	CARD8 	xgifb_patchlevel;
+
+	CARD8 	xgifb_caps;		/* xgifb's capabilities */
+
+	CARD32 	xgifb_tqlen;		/* turbo queue length (in KB) */
+
+	CARD32 	xgifb_pcibus;      	/* The card's PCI ID */
+	CARD32 	xgifb_pcislot;
+	CARD32 	xgifb_pcifunc;
+
+	CARD8 	xgifb_lcdpdc;
+
+	CARD8	xgifb_lcda;
+
+	CARD32	xgifb_vbflags;
+	CARD32	xgifb_currentvbflags;
+
+	CARD32 	xgifb_scalelcd;
+	CARD32 	xgifb_specialtiming;
+
+	CARD8 	xgifb_haveemi;
+	CARD8 	xgifb_emi30,xgifb_emi31,xgifb_emi32,xgifb_emi33;
+	CARD8 	xgifb_haveemilcd;
+
+	CARD8 	xgifb_lcdpdca;
+
+	CARD8 reserved[212]; 		/* for future use */
+};
+#endif
+
+#endif
+
