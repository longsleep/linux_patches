From desnacked@gmail.com  Fri Dec 18 10:35:59 2009
From: Kadianakis George <desnacked@gmail.com>
Date: Thu, 17 Dec 2009 01:18:08 +0200
Subject: staging: fix rtl8192e compilation errors with mac80211
To: greg@kroah.com
Cc: devel@linuxdriverproject.org, bzolnier@gmail.com
Message-ID: <87iqc633v3.fsf@gmail.com>


From: George Kadianakis <desnacked@gmail.com>

This patch series fixes compilation problems that were caused by
function naming conflicts between the rtl8192e driver and the
mac80211 stack.

Signed-off-by: George Kadianakis <desnacked at gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/rtl8192e/ieee80211.h                   |   12 ++++----
 drivers/staging/rtl8192e/ieee80211/ieee80211.h         |   12 ++++----
 drivers/staging/rtl8192e/ieee80211/ieee80211_module.c  |   10 +++----
 drivers/staging/rtl8192e/ieee80211/ieee80211_rx.c      |    2 -
 drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c |   24 ++++++++---------
 drivers/staging/rtl8192e/ieee80211/ieee80211_tx.c      |    2 -
 drivers/staging/rtl8192e/r8192E_core.c                 |   14 ++++-----
 7 files changed, 38 insertions(+), 38 deletions(-)

--- a/drivers/staging/rtl8192e/ieee80211.h
+++ b/drivers/staging/rtl8192e/ieee80211.h
@@ -303,8 +303,8 @@ enum	_ReasonCode{
 #define ieee80211_rx_mgt		ieee80211_rx_mgt_rsl
 
 #define ieee80211_get_beacon		ieee80211_get_beacon_rsl
-#define ieee80211_wake_queue		ieee80211_wake_queue_rsl
-#define ieee80211_stop_queue		ieee80211_stop_queue_rsl
+#define ieee80211_rtl_wake_queue		ieee80211_rtl_wake_queue_rsl
+#define ieee80211_rtl_stop_queue		ieee80211_rtl_stop_queue_rsl
 #define ieee80211_reset_queue		ieee80211_reset_queue_rsl
 #define ieee80211_softmac_stop_protocol	ieee80211_softmac_stop_protocol_rsl
 #define ieee80211_softmac_start_protocol ieee80211_softmac_start_protocol_rsl
@@ -2435,13 +2435,13 @@ extern int ieee80211_encrypt_fragment(
 	struct sk_buff *frag,
 	int hdr_len);
 
-extern int ieee80211_xmit(struct sk_buff *skb,
+extern int ieee80211_rtl_xmit(struct sk_buff *skb,
 			  struct net_device *dev);
 extern void ieee80211_txb_free(struct ieee80211_txb *);
 
 
 /* ieee80211_rx.c */
-extern int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+extern int ieee80211_rtl_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 			struct ieee80211_rx_stats *rx_stats);
 extern void ieee80211_rx_mgt(struct ieee80211_device *ieee,
 			     struct ieee80211_hdr_4addr *header,
@@ -2502,8 +2502,8 @@ extern void ieee80211_stop_protocol(stru
 extern void ieee80211_softmac_start_protocol(struct ieee80211_device *ieee);
 extern void ieee80211_softmac_stop_protocol(struct ieee80211_device *ieee);
 extern void ieee80211_reset_queue(struct ieee80211_device *ieee);
-extern void ieee80211_wake_queue(struct ieee80211_device *ieee);
-extern void ieee80211_stop_queue(struct ieee80211_device *ieee);
+extern void ieee80211_rtl_wake_queue(struct ieee80211_device *ieee);
+extern void ieee80211_rtl_stop_queue(struct ieee80211_device *ieee);
 extern struct sk_buff *ieee80211_get_beacon(struct ieee80211_device *ieee);
 extern void ieee80211_start_send_beacons(struct ieee80211_device *ieee);
 extern void ieee80211_stop_send_beacons(struct ieee80211_device *ieee);
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211.h
@@ -333,8 +333,8 @@ enum	_ReasonCode{
 #define ieee80211_rx_mgt		ieee80211_rx_mgt_rsl
 
 #define ieee80211_get_beacon		ieee80211_get_beacon_rsl
-#define ieee80211_wake_queue		ieee80211_wake_queue_rsl
-#define ieee80211_stop_queue		ieee80211_stop_queue_rsl
+#define ieee80211_rtl_wake_queue		ieee80211_rtl_wake_queue_rsl
+#define ieee80211_rtl_stop_queue		ieee80211_rtl_stop_queue_rsl
 #define ieee80211_reset_queue		ieee80211_reset_queue_rsl
 #define ieee80211_softmac_stop_protocol	ieee80211_softmac_stop_protocol_rsl
 #define ieee80211_softmac_start_protocol ieee80211_softmac_start_protocol_rsl
@@ -2546,13 +2546,13 @@ extern int ieee80211_encrypt_fragment(
 	struct sk_buff *frag,
 	int hdr_len);
 
-extern int ieee80211_xmit(struct sk_buff *skb,
+extern int ieee80211_rtl_xmit(struct sk_buff *skb,
 			  struct net_device *dev);
 extern void ieee80211_txb_free(struct ieee80211_txb *);
 
 
 /* ieee80211_rx.c */
-extern int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+extern int ieee80211_rtl_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 			struct ieee80211_rx_stats *rx_stats);
 extern void ieee80211_rx_mgt(struct ieee80211_device *ieee,
 			     struct ieee80211_hdr_4addr *header,
@@ -2613,8 +2613,8 @@ extern void ieee80211_stop_protocol(stru
 extern void ieee80211_softmac_start_protocol(struct ieee80211_device *ieee);
 extern void ieee80211_softmac_stop_protocol(struct ieee80211_device *ieee);
 extern void ieee80211_reset_queue(struct ieee80211_device *ieee);
-extern void ieee80211_wake_queue(struct ieee80211_device *ieee);
-extern void ieee80211_stop_queue(struct ieee80211_device *ieee);
+extern void ieee80211_rtl_wake_queue(struct ieee80211_device *ieee);
+extern void ieee80211_rtl_stop_queue(struct ieee80211_device *ieee);
 extern struct sk_buff *ieee80211_get_beacon(struct ieee80211_device *ieee);
 extern void ieee80211_start_send_beacons(struct ieee80211_device *ieee);
 extern void ieee80211_stop_send_beacons(struct ieee80211_device *ieee);
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_module.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_module.c
@@ -119,7 +119,7 @@ struct net_device *alloc_ieee80211(int s
 	ieee = (struct ieee80211_device *)dev->priv;
 #endif
 #if 0
-	dev->hard_start_xmit = ieee80211_xmit;
+	dev->hard_start_xmit = ieee80211_rtl_xmit;
 #endif
 
 	memset(ieee, 0, sizeof(struct ieee80211_device)+sizeof_priv);
@@ -333,7 +333,7 @@ extern void ieee80211_crypto_ccmp_exit(v
 extern int ieee80211_crypto_wep_init(void);
 extern void ieee80211_crypto_wep_exit(void);
 
-int __init ieee80211_init(void)
+int __init ieee80211_rtl_init(void)
 {
 	struct proc_dir_entry *e;
 	int retval;
@@ -389,7 +389,7 @@ int __init ieee80211_init(void)
 	return 0;
 }
 
-void __exit ieee80211_exit(void)
+void __exit ieee80211_rtl_exit(void)
 {
 	if (ieee80211_proc) {
 		remove_proc_entry("debug_level", ieee80211_proc);
@@ -412,8 +412,8 @@ module_param(debug, int, 0444);
 MODULE_PARM_DESC(debug, "debug output mask");
 
 
-//module_exit(ieee80211_exit);
-//module_init(ieee80211_init);
+//module_exit(ieee80211_rtl_exit);
+//module_init(ieee80211_rtl_init);
 #endif
 #endif
 
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_rx.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_rx.c
@@ -923,7 +923,7 @@ u8 parse_subframe(struct sk_buff *skb,
 /* All received frames are sent to this function. @skb contains the frame in
  * IEEE 802.11 format, i.e., in the format it was sent over air.
  * This function is called only as a tasklet (software IRQ). */
-int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+int ieee80211_rtl_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 		 struct ieee80211_rx_stats *rx_stats)
 {
 	struct net_device *dev = ieee->dev;
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c
@@ -684,7 +684,7 @@ void ieee80211_stop_scan(struct ieee8021
 }
 
 /* called with ieee->lock held */
-void ieee80211_start_scan(struct ieee80211_device *ieee)
+void ieee80211_rtl_start_scan(struct ieee80211_device *ieee)
 {
 #ifdef ENABLE_DOT11D
 	if(IS_DOT11D_ENABLE(ieee) )
@@ -1430,7 +1430,7 @@ void ieee80211_associate_step1(struct ie
 	}
 }
 
-void ieee80211_auth_challenge(struct ieee80211_device *ieee, u8 *challenge, int chlen)
+void ieee80211_rtl_auth_challenge(struct ieee80211_device *ieee, u8 *challenge, int chlen)
 {
 	u8 *c;
 	struct sk_buff *skb;
@@ -2262,7 +2262,7 @@ ieee80211_rx_frame_softmac(struct ieee80
 
 								ieee80211_associate_step2(ieee);
 							}else{
-								ieee80211_auth_challenge(ieee, challenge, chlen);
+								ieee80211_rtl_auth_challenge(ieee, challenge, chlen);
 							}
 						}else{
 							ieee->softmac_stats.rx_auth_rs_err++;
@@ -2376,7 +2376,7 @@ void ieee80211_softmac_xmit(struct ieee8
 			 * to check it any more.
 			 * */
 			//printk("error:no descriptor left@queue_index %d\n", queue_index);
-			//ieee80211_stop_queue(ieee);
+			//ieee80211_rtl_stop_queue(ieee);
 #ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
 			skb_queue_tail(&ieee->skb_drv_aggQ[queue_index], txb->fragments[i]);
 #else
@@ -2440,7 +2440,7 @@ void ieee80211_reset_queue(struct ieee80
 
 }
 
-void ieee80211_wake_queue(struct ieee80211_device *ieee)
+void ieee80211_rtl_wake_queue(struct ieee80211_device *ieee)
 {
 
 	unsigned long flags;
@@ -2481,7 +2481,7 @@ exit :
 }
 
 
-void ieee80211_stop_queue(struct ieee80211_device *ieee)
+void ieee80211_rtl_stop_queue(struct ieee80211_device *ieee)
 {
 	//unsigned long flags;
 	//spin_lock_irqsave(&ieee->lock,flags);
@@ -2706,7 +2706,7 @@ void ieee80211_start_bss(struct ieee8021
 
 	if (ieee->state == IEEE80211_NOLINK){
 		ieee->actscanning = true;
-		ieee80211_start_scan(ieee);
+		ieee80211_rtl_start_scan(ieee);
 	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
@@ -2775,7 +2775,7 @@ void ieee80211_associate_retry_wq(struct
 	{
 		ieee->is_roaming= false;
 		ieee->actscanning = true;
-		ieee80211_start_scan(ieee);
+		ieee80211_rtl_start_scan(ieee);
 	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 
@@ -3497,8 +3497,8 @@ void notify_wx_assoc_event(struct ieee80
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 //EXPORT_SYMBOL(ieee80211_get_beacon);
-//EXPORT_SYMBOL(ieee80211_wake_queue);
-//EXPORT_SYMBOL(ieee80211_stop_queue);
+//EXPORT_SYMBOL(ieee80211_rtl_wake_queue);
+//EXPORT_SYMBOL(ieee80211_rtl_stop_queue);
 //EXPORT_SYMBOL(ieee80211_reset_queue);
 //EXPORT_SYMBOL(ieee80211_softmac_stop_protocol);
 //EXPORT_SYMBOL(ieee80211_softmac_start_protocol);
@@ -3518,8 +3518,8 @@ void notify_wx_assoc_event(struct ieee80
 //EXPORT_SYMBOL(ieee80211_start_scan_syncro);
 #else
 EXPORT_SYMBOL_NOVERS(ieee80211_get_beacon);
-EXPORT_SYMBOL_NOVERS(ieee80211_wake_queue);
-EXPORT_SYMBOL_NOVERS(ieee80211_stop_queue);
+EXPORT_SYMBOL_NOVERS(ieee80211_rtl_wake_queue);
+EXPORT_SYMBOL_NOVERS(ieee80211_rtl_stop_queue);
 EXPORT_SYMBOL_NOVERS(ieee80211_reset_queue);
 EXPORT_SYMBOL_NOVERS(ieee80211_softmac_stop_protocol);
 EXPORT_SYMBOL_NOVERS(ieee80211_softmac_start_protocol);
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_tx.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_tx.c
@@ -604,7 +604,7 @@ void ieee80211_query_seqnum(struct ieee8
 	}
 }
 
-int ieee80211_xmit(struct sk_buff *skb, struct net_device *dev)
+int ieee80211_rtl_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
 	struct ieee80211_device *ieee = netdev_priv(dev);
--- a/drivers/staging/rtl8192e/r8192E_core.c
+++ b/drivers/staging/rtl8192e/r8192E_core.c
@@ -5795,7 +5795,7 @@ static void rtl8192_rx(struct net_device
                 stats.fragoffset = 0;
                 stats.ntotalfrag = 1;
 
-                if(!ieee80211_rx(priv->ieee80211, skb, &stats)){
+                if(!ieee80211_rtl_rx(priv->ieee80211, skb, &stats)){
                     dev_kfree_skb_any(skb);
                 } else {
                     priv->stats.rxok++;
@@ -5837,7 +5837,7 @@ static const struct net_device_ops rtl81
 	.ndo_do_ioctl =			rtl8192_ioctl,
 	.ndo_set_multicast_list =	r8192_set_multicast,
 	.ndo_set_mac_address =		r8192_set_mac_adr,
-	.ndo_start_xmit = 		ieee80211_xmit,
+	.ndo_start_xmit = 		ieee80211_rtl_xmit,
 };
 
 /****************************************************************************
@@ -6121,14 +6121,14 @@ static void __devexit rtl8192_pci_discon
 	RT_TRACE(COMP_DOWN, "wlan driver removed\n");
 }
 
-extern int ieee80211_init(void);
-extern void ieee80211_exit(void);
+extern int ieee80211_rtl_init(void);
+extern void ieee80211_rtl_exit(void);
 
 static int __init rtl8192_pci_module_init(void)
 {
 	int retval;
 
-	retval = ieee80211_init();
+	retval = ieee80211_rtl_init();
 	if (retval)
 		return retval;
 
@@ -6153,7 +6153,7 @@ static void __exit rtl8192_pci_module_ex
 
 	RT_TRACE(COMP_DOWN, "Exiting");
 	rtl8192_proc_module_remove();
-	ieee80211_exit();
+	ieee80211_rtl_exit();
 }
 
 //warning message WB
@@ -6313,7 +6313,7 @@ void rtl8192_try_wake_queue(struct net_d
         spin_unlock_irqrestore(&priv->tx_lock,flags);
 
 	if(enough_desc)
-		ieee80211_wake_queue(priv->ieee80211);
+		ieee80211_rtl_wake_queue(priv->ieee80211);
 #endif
 }
 
