From 522434d298fb2e2e9616dd8985bcad0cf7e59199 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Thu, 3 Apr 2008 17:30:53 -0700
Subject: NET: add eth131x driver

This is a driver for the ET1310 network device.

Based on the driver found at https://sourceforge.net/projects/et131x/

TODO:
	- kernel coding style cleanups
	- forward port for latest network driver changes

Cc: Olaf Hartmann <o.hartmann@telovital.com>
Cc: Dean Adams <dadams1969@gmail.com>
Cc: Victor Soriano <vjsoriano@agere.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/net/Kconfig                     |    9 
 drivers/net/Makefile                    |    1 
 drivers/net/et131x/ET1310_address_map.h | 3216 ++++++++++++++++++++++++++++++++
 drivers/net/et131x/ET1310_common.h      |   97 
 drivers/net/et131x/ET1310_eeprom.c      |  710 +++++++
 drivers/net/et131x/ET1310_eeprom.h      |  127 +
 drivers/net/et131x/ET1310_jagcore.c     |  642 ++++++
 drivers/net/et131x/ET1310_jagcore.h     |  180 +
 drivers/net/et131x/ET1310_mac.c         | 1247 ++++++++++++
 drivers/net/et131x/ET1310_mac.h         |  140 +
 drivers/net/et131x/ET1310_phy.c         | 2728 +++++++++++++++++++++++++++
 drivers/net/et131x/ET1310_phy.h         | 1228 ++++++++++++
 drivers/net/et131x/ET1310_pm.c          | 1723 +++++++++++++++++
 drivers/net/et131x/ET1310_pm.h          |  216 ++
 drivers/net/et131x/ET1310_rx.c          | 2046 ++++++++++++++++++++
 drivers/net/et131x/ET1310_rx.h          |  488 ++++
 drivers/net/et131x/ET1310_tx.c          | 2084 ++++++++++++++++++++
 drivers/net/et131x/ET1310_tx.h          |  354 +++
 drivers/net/et131x/Makefile             |   17 
 drivers/net/et131x/et131x_adapter.h     |  508 +++++
 drivers/net/et131x/et131x_config.c      |  383 +++
 drivers/net/et131x/et131x_config.h      |   99 
 drivers/net/et131x/et131x_debug.c       |  328 +++
 drivers/net/et131x/et131x_debug.h       |  276 ++
 drivers/net/et131x/et131x_defs.h        |  206 ++
 drivers/net/et131x/et131x_initpci.c     | 1836 ++++++++++++++++++
 drivers/net/et131x/et131x_initpci.h     |  103 +
 drivers/net/et131x/et131x_isr.c         |  656 ++++++
 drivers/net/et131x/et131x_isr.h         |   95 
 drivers/net/et131x/et131x_main.c        |  258 ++
 drivers/net/et131x/et131x_netdev.c      | 1624 ++++++++++++++++
 drivers/net/et131x/et131x_netdev.h      |   91 
 drivers/net/et131x/et131x_supp.c        |  440 ++++
 drivers/net/et131x/et131x_supp.h        |  133 +
 drivers/net/et131x/et131x_version.h     |  124 +
 35 files changed, 24413 insertions(+)

--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -1749,6 +1749,15 @@ config SC92031
 	  To compile this driver as a module, choose M here: the module
 	  will be called sc92031.  This is recommended.
 
+config ET131X
+       tristate "et131x network driver"
+       depends on NET_PCI && PCI
+       help
+         This driver supports the eth131x ethernet card.
+
+         To compile this driver as a module, choose M here: the module
+         will be called et131x.  This is recommended.
+
 config CPMAC
 	tristate "TI AR7 CPMAC Ethernet support (EXPERIMENTAL)"
 	depends on NET_ETHERNET && EXPERIMENTAL && AR7 && BROKEN
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -222,6 +222,7 @@ obj-$(CONFIG_PASEMI_MAC) += pasemi_mac.o
 obj-$(CONFIG_MLX4_CORE) += mlx4/
 obj-$(CONFIG_ENC28J60) += enc28j60.o
 obj-$(CONFIG_SLICOSS) += slicoss/
+obj-$(CONFIG_ET131X) += et131x/
 
 obj-$(CONFIG_MACB) += macb.o
 
--- /dev/null
+++ b/drivers/net/et131x/ET1310_address_map.h
@@ -0,0 +1,3216 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_address_map.h - Contains the register mapping for the ET1310
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/10/28 18:43:43 $
+     $Revision: 1.8 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef _ET1310_ADDRESS_MAP_H_
+#define _ET1310_ADDRESS_MAP_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************
+   some typedefs for compiler
+ *****************************************************************************/
+typedef s8  INT8,   *PINT8;
+typedef s16 INT16,  *PINT16;
+typedef s32 INT32,  *PINT32;
+typedef s64 INT64,  *PINT64;
+
+typedef u8  UINT8,  *PUINT8;
+typedef u16 UINT16, *PUINT16;
+typedef u32 UINT32, *PUINT32;
+typedef u64 UINT64, *PUINT64;
+
+typedef u8  UCHAR,  *PUCHAR;
+
+
+
+
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                START OF GLOBAL REGISTER ADDRESS MAP                 ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+/******************************************************************************
+   structure for tx queue start address reg in global address map
+   located at address 0x0000
+ *****************************************************************************/
+typedef union _TXQ_START_ADDR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:22;                           //bits 10-31
+        UINT32 txq_start:10;                        //bits 0-9
+    #else
+        UINT32 txq_start:10;                        //bits 0-9
+        UINT32 unused:22;                           //bits 10-31
+    #endif
+    } bits;
+}
+TXQ_START_ADDR_t, *PTXQ_START_ADDR_t;
+
+
+/******************************************************************************
+   structure for tx queue end address reg in global address map
+   located at address 0x0004
+ *****************************************************************************/
+typedef union _TXQ_END_ADDR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:22;                           //bits 10-31
+        UINT32 txq_end:10;                          //bits 0-9
+    #else
+        UINT32 txq_end:10;                          //bits 0-9
+        UINT32 unused:22;                           //bits 10-31
+    #endif
+    } bits;
+}
+TXQ_END_ADDR_t, *PTXQ_END_ADDR_t;
+
+
+/******************************************************************************
+   structure for rx queue start address reg in global address map
+   located at address 0x0008
+ *****************************************************************************/
+typedef union _RXQ_START_ADDR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:22;                           //bits 10-31
+        UINT32 rxq_start_addr:10;                   //bits 0-9
+    #else
+        UINT32 rxq_start_addr:10;                   //bits 0-9
+        UINT32 unused:22;                           //bits 10-31
+    #endif
+    } bits;
+}
+RXQ_START_ADDR_t, *PRXQ_START_ADDR_t;
+
+
+/******************************************************************************
+   structure for rx queue end address reg in global address map
+   located at address 0x000C
+ *****************************************************************************/
+typedef union _RXQ_END_ADDR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:22;                           //bits 10-31
+        UINT32 rxq_end_addr:10;                     //bits 0-9
+    #else
+        UINT32 rxq_end_addr:10;                     //bits 0-9
+        UINT32 unused:22;                           //bits 10-31
+    #endif
+    } bits;
+}
+RXQ_END_ADDR_t, *PRXQ_END_ADDR_t;
+
+
+/******************************************************************************
+   structure for power management control status reg in global address map
+   located at address 0x0010
+ *****************************************************************************/
+typedef union _PM_CSR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:22;                           //bits 10-31
+        UINT32 pm_jagcore_rx_rdy:1;                 //bit 9
+        UINT32 pm_jagcore_tx_rdy:1;                 //bit 8
+        UINT32 pm_phy_lped_en:1;                    //bit 7
+        UINT32 pm_phy_sw_coma:1;                    //bit 6
+        UINT32 pm_rxclk_gate:1;                     //bit 5
+        UINT32 pm_txclk_gate:1;                     //bit 4
+        UINT32 pm_sysclk_gate:1;                    //bit 3
+        UINT32 pm_jagcore_rx_en:1;                  //bit 2
+        UINT32 pm_jagcore_tx_en:1;                  //bit 1
+        UINT32 pm_gigephy_en:1;                     //bit 0
+    #else
+        UINT32 pm_gigephy_en:1;                     //bit 0
+        UINT32 pm_jagcore_tx_en:1;                  //bit 1
+        UINT32 pm_jagcore_rx_en:1;                  //bit 2
+        UINT32 pm_sysclk_gate:1;                    //bit 3
+        UINT32 pm_txclk_gate:1;                     //bit 4
+        UINT32 pm_rxclk_gate:1;                     //bit 5
+        UINT32 pm_phy_sw_coma:1;                    //bit 6
+        UINT32 pm_phy_lped_en:1;                    //bit 7
+        UINT32 pm_jagcore_tx_rdy:1;                 //bit 8
+        UINT32 pm_jagcore_rx_rdy:1;                 //bit 9
+        UINT32 unused:22;                           //bits 10-31
+    #endif
+    } bits;
+}
+PM_CSR_t, *PPM_CSR_t;
+
+
+/******************************************************************************
+   structure for interrupt status reg in global address map
+   located at address 0x0018
+ *****************************************************************************/
+typedef union _INT_STATUS_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused5:11;                          //bits 21-31
+        UINT32 slv_timeout:1;                       //bit 20
+        UINT32 mac_stat_interrupt:1;                //bit 19
+        UINT32 rxmac_interrupt:1;                   //bit 18
+        UINT32 txmac_interrupt:1;                   //bit 17
+        UINT32 phy_interrupt:1;                     //bit 16
+        UINT32 wake_on_lan:1;                       //bit 15
+        UINT32 watchdog_interrupt:1;                //bit 14
+        UINT32 unused4:4;                           //bits 10-13
+        UINT32 rxdma_err:1;                         //bit 9
+        UINT32 rxdma_pkt_stat_ring_low:1;           //bit 8
+        UINT32 rxdma_fb_ring1_low:1;                //bit 7
+        UINT32 rxdma_fb_ring0_low:1;                //bit 6
+        UINT32 rxdma_xfr_done:1;                    //bit 5
+        UINT32 txdma_err:1;                         //bit 4
+        UINT32 txdma_isr:1;                         //bit 3
+        UINT32 unused3:1;                           //bit 2
+        UINT32 unused2:1;                           //bit 1
+        UINT32 unused1:1;                           //bit 0
+    #else
+        UINT32 unused1:1;                           //bit 0
+        UINT32 unused2:1;                           //bit 1
+        UINT32 unused3:1;                           //bit 2
+        UINT32 txdma_isr:1;                         //bit 3
+        UINT32 txdma_err:1;                         //bit 4
+        UINT32 rxdma_xfr_done:1;                    //bit 5
+        UINT32 rxdma_fb_ring0_low:1;                //bit 6
+        UINT32 rxdma_fb_ring1_low:1;                //bit 7
+        UINT32 rxdma_pkt_stat_ring_low:1;           //bit 8
+        UINT32 rxdma_err:1;                         //bit 9
+        UINT32 unused4:4;                           //bits 10-13
+        UINT32 watchdog_interrupt:1;                //bit 14
+        UINT32 wake_on_lan:1;                       //bit 15
+        UINT32 phy_interrupt:1;                     //bit 16
+        UINT32 txmac_interrupt:1;                   //bit 17
+        UINT32 rxmac_interrupt:1;                   //bit 18
+        UINT32 mac_stat_interrupt:1;                //bit 19
+        UINT32 slv_timeout:1;                       //bit 20
+        UINT32 unused5:11;                          //bits 21-31
+    #endif
+    } bits;
+}
+INT_STATUS_t, *PINT_STATUS_t;
+
+
+/******************************************************************************
+   structure for interrupt mask reg in global address map
+   located at address 0x001C
+ *****************************************************************************/
+typedef union _INT_MASK_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused5:11;                          //bits 21-31
+        UINT32 slv_timeout:1;                       //bit 20
+        UINT32 mac_stat_interrupt:1;                //bit 19
+        UINT32 rxmac_interrupt:1;                   //bit 18
+        UINT32 txmac_interrupt:1;                   //bit 17
+        UINT32 phy_interrupt:1;                     //bit 16
+        UINT32 wake_on_lan:1;                       //bit 15
+        UINT32 unused4:5;                           //bits 10-14
+        UINT32 rxdma_err:1;                         //bit 9
+        UINT32 rxdma_pkt_stat_ring_low:1;           //bit 8
+        UINT32 rxdma_fb_ring1_low:1;                //bit 7
+        UINT32 rxdma_fb_ring0_low:1;                //bit 6
+        UINT32 rxdma_xfr_done:1;                    //bit 5
+        UINT32 txdma_err:1;                         //bit 4
+        UINT32 txdma_isr:1;                         //bit 3
+        UINT32 unused3:1;                           //bit 2
+        UINT32 unused2:1;                           //bit 1
+        UINT32 unused1:1;                           //bit 0
+    #else
+        UINT32 unused1:1;                           //bit 0
+        UINT32 unused2:1;                           //bit 1
+        UINT32 unused3:1;                           //bit 2
+        UINT32 txdma_isr:1;                         //bit 3
+        UINT32 txdma_err:1;                         //bit 4
+        UINT32 rxdma_xfr_done:1;                    //bit 5
+        UINT32 rxdma_fb_ring0_low:1;                //bit 6
+        UINT32 rxdma_fb_ring1_low:1;                //bit 7
+        UINT32 rxdma_pkt_stat_ring_low:1;           //bit 8
+        UINT32 rxdma_err:1;                         //bit 9
+        UINT32 unused4:5;                           //bits 10-14
+        UINT32 wake_on_lan:1;                       //bit 15
+        UINT32 phy_interrupt:1;                     //bit 16
+        UINT32 txmac_interrupt:1;                   //bit 17
+        UINT32 rxmac_interrupt:1;                   //bit 18
+        UINT32 mac_stat_interrupt:1;                //bit 19
+        UINT32 slv_timeout:1;                       //bit 20
+        UINT32 unused5:11;                          //bits 21-31
+    #endif
+    } bits;
+}
+INT_MASK_t, *PINT_MASK_t;
+
+
+/******************************************************************************
+   structure for interrupt alias clear mask reg in global address map
+   located at address 0x0020
+ *****************************************************************************/
+typedef union _INT_ALIAS_CLR_EN_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused5:11;                          //bits 21-31
+        UINT32 slv_timeout:1;                       //bit 20
+        UINT32 mac_stat_interrupt:1;                //bit 19
+        UINT32 rxmac_interrupt:1;                   //bit 18
+        UINT32 txmac_interrupt:1;                   //bit 17
+        UINT32 phy_interrupt:1;                     //bit 16
+        UINT32 wake_on_lan:1;                       //bit 15
+        UINT32 watchdog_interrupt:1;                //bit 14
+        UINT32 unused4:4;                           //bits 10-13
+        UINT32 rxdma_err:1;                         //bit 9
+        UINT32 rxdma_pkt_stat_ring_low:1;           //bit 8
+        UINT32 rxdma_fb_ring1_low:1;                //bit 7
+        UINT32 rxdma_fb_ring0_low:1;                //bit 6
+        UINT32 rxdma_xfr_done:1;                    //bit 5
+        UINT32 txdma_err:1;                         //bit 4
+        UINT32 txdma_isr:1;                         //bit 3
+        UINT32 unused3:1;                           //bit 2
+        UINT32 unused2:1;                           //bit 1
+        UINT32 unused1:1;                           //bit 0
+    #else
+        UINT32 unused1:1;                           //bit 0
+        UINT32 unused2:1;                           //bit 1
+        UINT32 unused3:1;                           //bit 2
+        UINT32 txdma_isr:1;                         //bit 3
+        UINT32 txdma_err:1;                         //bit 4
+        UINT32 rxdma_xfr_done:1;                    //bit 5
+        UINT32 rxdma_fb_ring0_low:1;                //bit 6
+        UINT32 rxdma_fb_ring1_low:1;                //bit 7
+        UINT32 rxdma_pkt_stat_ring_low:1;           //bit 8
+        UINT32 rxdma_err:1;                         //bit 9
+        UINT32 unused4:4;                           //bits 10-13
+        UINT32 watchdog_interrupt:1;                //bit 14
+        UINT32 wake_on_lan:1;                       //bit 15
+        UINT32 phy_interrupt:1;                     //bit 16
+        UINT32 txmac_interrupt:1;                   //bit 17
+        UINT32 rxmac_interrupt:1;                   //bit 18
+        UINT32 mac_stat_interrupt:1;                //bit 19
+        UINT32 slv_timeout:1;                       //bit 20
+        UINT32 unused5:11;                          //bits 21-31
+    #endif
+    } bits;
+}
+INT_ALIAS_CLR_EN_t, *PINT_ALIAS_CLR_EN_t;
+
+
+/******************************************************************************
+   structure for interrupt status alias reg in global address map
+   located at address 0x0024
+ *****************************************************************************/
+typedef union _INT_STATUS_ALIAS_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused5:11;                          //bits 21-31
+        UINT32 slv_timeout:1;                       //bit 20
+        UINT32 mac_stat_interrupt:1;                //bit 19
+        UINT32 rxmac_interrupt:1;                   //bit 18
+        UINT32 txmac_interrupt:1;                   //bit 17
+        UINT32 phy_interrupt:1;                     //bit 16
+        UINT32 wake_on_lan:1;                       //bit 15
+        UINT32 watchdog_interrupt:1;                //bit 14
+        UINT32 unused4:4;                           //bits 10-13
+        UINT32 rxdma_err:1;                         //bit 9
+        UINT32 rxdma_pkt_stat_ring_low:1;           //bit 8
+        UINT32 rxdma_fb_ring1_low:1;                //bit 7
+        UINT32 rxdma_fb_ring0_low:1;                //bit 6
+        UINT32 rxdma_xfr_done:1;                    //bit 5
+        UINT32 txdma_err:1;                         //bit 4
+        UINT32 txdma_isr:1;                         //bit 3
+        UINT32 unused3:1;                           //bit 2
+        UINT32 unused2:1;                           //bit 1
+        UINT32 unused1:1;                           //bit 0
+    #else
+        UINT32 unused1:1;                           //bit 0
+        UINT32 unused2:1;                           //bit 1
+        UINT32 unused3:1;                           //bit 2
+        UINT32 txdma_isr:1;                         //bit 3
+        UINT32 txdma_err:1;                         //bit 4
+        UINT32 rxdma_xfr_done:1;                    //bit 5
+        UINT32 rxdma_fb_ring0_low:1;                //bit 6
+        UINT32 rxdma_fb_ring1_low:1;                //bit 7
+        UINT32 rxdma_pkt_stat_ring_low:1;           //bit 8
+        UINT32 rxdma_err:1;                         //bit 9
+        UINT32 unused4:4;                           //bits 10-13
+        UINT32 watchdog_interrupt:1;                //bit 14
+        UINT32 wake_on_lan:1;                       //bit 15
+        UINT32 phy_interrupt:1;                     //bit 16
+        UINT32 txmac_interrupt:1;                   //bit 17
+        UINT32 rxmac_interrupt:1;                   //bit 18
+        UINT32 mac_stat_interrupt:1;                //bit 19
+        UINT32 slv_timeout:1;                       //bit 20
+        UINT32 unused5:11;                          //bits 21-31
+    #endif
+    } bits;
+}
+INT_STATUS_ALIAS_t, *PINT_STATUS_ALIAS_t;
+
+
+/******************************************************************************
+   structure for software reset reg in global address map
+   located at address 0x0028
+ *****************************************************************************/
+typedef union _SW_RESET_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 selfclr_disable:1;                   //bit 31
+        UINT32 unused:24;                           //bits 7-30
+        UINT32 mmc_sw_reset:1;                      //bit 6
+        UINT32 mac_stat_sw_reset:1;                 //bit 5
+        UINT32 mac_sw_reset:1;                      //bit 4
+        UINT32 rxmac_sw_reset:1;                    //bit 3
+        UINT32 txmac_sw_reset:1;                    //bit 2
+        UINT32 rxdma_sw_reset:1;                    //bit 1
+        UINT32 txdma_sw_reset:1;                    //bit 0
+    #else
+        UINT32 txdma_sw_reset:1;                    //bit 0
+        UINT32 rxdma_sw_reset:1;                    //bit 1
+        UINT32 txmac_sw_reset:1;                    //bit 2
+        UINT32 rxmac_sw_reset:1;                    //bit 3
+        UINT32 mac_sw_reset:1;                      //bit 4
+        UINT32 mac_stat_sw_reset:1;                 //bit 5
+        UINT32 mmc_sw_reset:1;                      //bit 6
+        UINT32 unused:24;                           //bits 7-30
+        UINT32 selfclr_disable:1;                   //bit 31
+    #endif
+    } bits;
+}
+SW_RESET_t, *PSW_RESET_t;
+
+
+/******************************************************************************
+   structure for SLV Timer reg in global address map
+   located at address 0x002C
+ *****************************************************************************/
+typedef union _SLV_TIMER_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:8;                            //bits 24-31
+        UINT32 timer_ini:24;                        //bits 0-23
+    #else
+        UINT32 timer_ini:24;                        //bits 0-23
+        UINT32 unused:8;                            //bits 24-31
+    #endif
+    } bits;
+}
+SLV_TIMER_t, *PSLV_TIMER_t;
+
+
+/******************************************************************************
+   structure for MSI Configuration reg in global address map
+   located at address 0x0030
+ *****************************************************************************/
+typedef union _MSI_CONFIG_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused1:13;                          //bits 19-31
+        UINT32 msi_tc:3;                            //bits 16-18
+        UINT32 unused2:11;                          //bits 5-15
+        UINT32 msi_vector:5;                        //bits 0-4
+    #else
+        UINT32 msi_vector:5;                        //bits 0-4
+        UINT32 unused2:11;                          //bits 5-15
+        UINT32 msi_tc:3;                            //bits 16-18
+        UINT32 unused1:13;                          //bits 19-31
+    #endif
+    } bits;
+}
+MSI_CONFIG_t, *PMSI_CONFIG_t;
+
+
+/******************************************************************************
+   structure for Loopback reg in global address map
+   located at address 0x0034
+ *****************************************************************************/
+typedef union _LOOPBACK_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:30;                           //bits 2-31
+        UINT32 dma_loopback:1;                      //bit 1
+        UINT32 mac_loopback:1;                      //bit 0
+    #else
+        UINT32 mac_loopback:1;                      //bit 0
+        UINT32 dma_loopback:1;                      //bit 1
+        UINT32 unused:30;                           //bits 2-31
+    #endif
+    } bits;
+}
+LOOPBACK_t, *PLOOPBACK_t;
+
+
+/******************************************************************************
+   GLOBAL Module of JAGCore Address Mapping
+   Located at address 0x0000
+ *****************************************************************************/
+typedef struct _GLOBAL_t
+{                                                   //Location:
+    TXQ_START_ADDR_t    txq_start_addr;             //  0x0000
+    TXQ_END_ADDR_t      txq_end_addr;               //  0x0004
+    RXQ_START_ADDR_t    rxq_start_addr;             //  0x0008
+    RXQ_END_ADDR_t      rxq_end_addr;               //  0x000C
+    PM_CSR_t            pm_csr;                     //  0x0010
+    UINT32              unused;                     //  0x0014
+    INT_STATUS_t        int_status;                 //  0x0018
+    INT_MASK_t          int_mask;                   //  0x001C
+    INT_ALIAS_CLR_EN_t  int_alias_clr_en;           //  0x0020
+    INT_STATUS_ALIAS_t  int_status_alias;           //  0x0024
+    SW_RESET_t          sw_reset;                   //  0x0028
+    SLV_TIMER_t         slv_timer;                  //  0x002C
+    MSI_CONFIG_t        msi_config;                 //  0x0030
+    LOOPBACK_t          loopback;                   //  0x0034
+    UINT32              watchdog_timer;             //  0x0038
+}
+GLOBAL_t, *PGLOBAL_t;
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                 END OF GLOBAL REGISTER ADDRESS MAP                  ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+
+
+
+
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                 START OF TXDMA REGISTER ADDRESS MAP                 ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+/******************************************************************************
+   structure for txdma control status reg in txdma address map
+   located at address 0x1000
+ *****************************************************************************/
+typedef union _TXDMA_CSR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused2:19;                          //bits 13-31
+        UINT32 traffic_class:4;                     //bits 9-12
+        UINT32 sngl_epkt_mode:1;                    //bit 8
+        UINT32 cache_thrshld:4;                     //bits 4-7
+        UINT32 unused1:2;                           //bits 2-3
+        UINT32 drop_TLP_disable:1;                  //bit 1
+        UINT32 halt:1;                              //bit 0
+    #else
+        UINT32 halt:1;                              //bit 0
+        UINT32 drop_TLP_disable:1;                  //bit 1
+        UINT32 unused1:2;                           //bits 2-3
+        UINT32 cache_thrshld:4;                     //bits 4-7
+        UINT32 sngl_epkt_mode:1;                    //bit 8
+        UINT32 traffic_class:4;                     //bits 9-12
+        UINT32 unused2:19;                          //bits 13-31
+    #endif
+    } bits;
+}
+TXDMA_CSR_t, *PTXDMA_CSR_t;
+
+
+/******************************************************************************
+   structure for txdma packet ring base address hi reg in txdma address map
+   located at address 0x1004
+ *****************************************************************************/
+typedef struct _TXDMA_PR_BASE_HI_t
+{
+    UINT32 addr_hi;                                 //bits 0-31
+}
+TXDMA_PR_BASE_HI_t, *PTXDMA_PR_BASE_HI_t;
+
+
+/******************************************************************************
+   structure for txdma packet ring base address low reg in txdma address map
+   located at address 0x1008
+ *****************************************************************************/
+typedef struct _TXDMA_PR_BASE_LO_t
+{
+    UINT32 addr_lo;                                 //bits 0-31
+}
+TXDMA_PR_BASE_LO_t, *PTXDMA_PR_BASE_LO_t;
+
+
+/******************************************************************************
+   structure for txdma packet ring number of descriptor reg in txdma address
+   map.  Located at address 0x100C
+ *****************************************************************************/
+typedef union _TXDMA_PR_NUM_DES_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:22;                           //bits 10-31
+        UINT32 pr_ndes:10;                          //bits 0-9
+    #else
+        UINT32 pr_ndes:10;                          //bits 0-9
+        UINT32 unused:22;                           //bits 10-31
+    #endif
+    } bits;
+}
+TXDMA_PR_NUM_DES_t, *PTXDMA_PR_NUM_DES_t;
+
+
+/******************************************************************************
+   structure for txdma tx queue write address reg in txdma address map
+   located at address 0x1010
+ *****************************************************************************/
+typedef  union _TXDMA_TXQ_WR_ADDR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 txq_wr_wrap:1;                       //bit 10
+        UINT32 txq_wr:10;                           //bits 0-9
+    #else
+        UINT32 txq_wr:10;                           //bits 0-9
+        UINT32 txq_wr_wrap:1;                       //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+TXDMA_TXQ_WR_ADDR_t, *PTXDMA_TXQ_WR_ADDR_t;
+
+
+/******************************************************************************
+   structure for txdma tx queue write address external reg in txdma address map
+   located at address 0x1014
+ *****************************************************************************/
+typedef union _TXDMA_TXQ_WR_ADDR_EXT_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 txq_wr_ext_wrap:1;                   //bit 10
+        UINT32 txq_wr_ext:10;                       //bits 0-9
+    #else
+        UINT32 txq_wr_ext:10;                       //bits 0-9
+        UINT32 txq_wr_ext_wrap:1;                   //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+TXDMA_TXQ_WR_ADDR_EXT_t, *PTXDMA_TXQ_WR_ADDR_EXT_t;
+
+
+/******************************************************************************
+   structure for txdma tx queue read address reg in txdma address map
+   located at address 0x1018
+ *****************************************************************************/
+typedef union _TXDMA_TXQ_RD_ADDR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 txq_rd_wrap:1;                       //bit 10
+        UINT32 txq_rd:10;                           //bits 0-9
+    #else
+        UINT32 txq_rd:10;                           //bits 0-9
+        UINT32 txq_rd_wrap:1;                       //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+TXDMA_TXQ_RD_ADDR_t, *PTXDMA_TXQ_RD_ADDR_t;
+
+
+/******************************************************************************
+   structure for txdma status writeback address hi reg in txdma address map
+   located at address 0x101C
+ *****************************************************************************/
+typedef struct _TXDMA_DMA_WB_ADDR_HI_t
+{
+    UINT32 addr_hi;                              //bits 0-31
+}
+TXDMA_DMA_WB_ADDR_HI_t, *PTXDMA_DMA_WB_ADDR_HI_t;
+
+
+/******************************************************************************
+   structure for txdma status writeback address lo reg in txdma address map
+   located at address 0x1020
+ *****************************************************************************/
+typedef struct _TXDMA_DMA_WB_ADDR_LO_t
+{
+    UINT32 addr_lo;                              //bits 0-31
+}
+TXDMA_DMA_WB_ADDR_LO_t, *PTXDMA_DMA_WB_ADDR_LO_t;
+
+
+/******************************************************************************
+   structure for txdma service request reg in txdma address map
+   located at address 0x1024
+ *****************************************************************************/
+typedef union _TXDMA_SERVICE_REQUEST_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 serv_req_wrap:1;                     //bit 10
+        UINT32 serv_req:10;                         //bits 0-9
+    #else
+        UINT32 serv_req:10;                         //bits 0-9
+        UINT32 serv_req_wrap:1;                     //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+TXDMA_SERVICE_REQUEST_t, *PTXDMA_SERVICE_REQUEST_t;
+
+
+/******************************************************************************
+   structure for txdma service complete reg in txdma address map
+   located at address 0x1028
+ *****************************************************************************/
+typedef union _TXDMA_SERVICE_COMPLETE_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 serv_cpl_wrap:1;                     //bit 10
+        UINT32 serv_cpl:10;                         //bits 0-9
+    #else
+        UINT32 serv_cpl:10;                         //bits 0-9
+        UINT32 serv_cpl_wrap:1;                     //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+TXDMA_SERVICE_COMPLETE_t, *PTXDMA_SERVICE_COMPLETE_t;
+
+
+/******************************************************************************
+   structure for txdma tx descriptor cache read index reg in txdma address map
+   located at address 0x102C
+ *****************************************************************************/
+typedef union _TXDMA_CACHE_RD_INDEX_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:27;                           //bits 5-31
+        UINT32 rdi_wrap:1;                          //bit 4
+        UINT32 rdi:4;                               //bit 0-3
+    #else
+        UINT32 rdi:4;                               //bits 0-3
+        UINT32 rdi_wrap:1;                          //bit 4
+        UINT32 unused:27;                           //bits 5-31
+    #endif
+    } bits;
+}
+TXDMA_CACHE_RD_INDEX_t, *PTXDMA_CACHE_RD_INDEX_t;
+
+
+/******************************************************************************
+   structure for txdma tx descriptor cache write index reg in txdma address map
+   located at address 0x1030
+ *****************************************************************************/
+typedef union _TXDMA_CACHE_WR_INDEX_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:27;                           //bits 5-31
+        UINT32 wri_wrap:1;                          //bit 4
+        UINT32 wri:4;                               //bit 0-3
+    #else
+        UINT32 wri:4;                               //bits 0-3
+        UINT32 wri_wrap:1;                          //bit 4
+        UINT32 unused:27;                           //bits 5-31
+    #endif
+    } bits;
+}
+TXDMA_CACHE_WR_INDEX_t, *PTXDMA_CACHE_WR_INDEX_t;
+
+
+/******************************************************************************
+   structure for txdma error reg in txdma address map
+   located at address 0x1034
+ *****************************************************************************/
+typedef union _TXDMA_ERROR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused3:22;                          //bits 10-31
+        UINT32 WrbkRewind:1;                        //bit 9
+        UINT32 WrbkResend:1;                        //bit 8
+        UINT32 unused2:2;                           //bits 6-7
+        UINT32 DescrRewind:1;                       //bit 5
+        UINT32 DescrResend:1;                       //bit 4
+        UINT32 unused1:2;                           //bits 2-3
+        UINT32 PyldRewind:1;                        //bit 1
+        UINT32 PyldResend:1;                        //bit 0
+    #else
+        UINT32 PyldResend:1;                        //bit 0
+        UINT32 PyldRewind:1;                        //bit 1
+        UINT32 unused1:2;                           //bits 2-3
+        UINT32 DescrResend:1;                       //bit 4
+        UINT32 DescrRewind:1;                       //bit 5
+        UINT32 unused2:2;                           //bits 6-7
+        UINT32 WrbkResend:1;                        //bit 8
+        UINT32 WrbkRewind:1;                        //bit 9
+        UINT32 unused3:22;                          //bits 10-31
+    #endif
+    } bits;
+}
+TXDMA_ERROR_t, *PTXDMA_ERROR_t;
+
+
+/******************************************************************************
+   Tx DMA Module of JAGCore Address Mapping
+   Located at address 0x1000
+ *****************************************************************************/
+typedef struct _TXDMA_t
+{                                                   //Location:
+    TXDMA_CSR_t                 csr;                //  0x1000
+    TXDMA_PR_BASE_HI_t          pr_base_hi;         //  0x1004
+    TXDMA_PR_BASE_LO_t          pr_base_lo;         //  0x1008
+    TXDMA_PR_NUM_DES_t          pr_num_des;         //  0x100C
+    TXDMA_TXQ_WR_ADDR_t         txq_wr_addr;        //  0x1010
+    TXDMA_TXQ_WR_ADDR_EXT_t     txq_wr_addr_ext;    //  0x1014
+    TXDMA_TXQ_RD_ADDR_t         txq_rd_addr;        //  0x1018
+    TXDMA_DMA_WB_ADDR_HI_t      dma_wb_base_hi;     //  0x101C
+    TXDMA_DMA_WB_ADDR_LO_t      dma_wb_base_lo;     //  0x1020
+    TXDMA_SERVICE_REQUEST_t     service_request;    //  0x1024
+    TXDMA_SERVICE_COMPLETE_t    service_complete;   //  0x1028
+    TXDMA_CACHE_RD_INDEX_t      cache_rd_index;     //  0x102C
+    TXDMA_CACHE_WR_INDEX_t      cache_wr_index;     //  0x1030
+    TXDMA_ERROR_t               TxDmaError;         //  0x1034
+    UINT32                      DescAbortCount;     //  0x1038
+    UINT32                      PayloadAbortCnt;    //  0x103c
+    UINT32                      WriteBackAbortCnt;  //  0x1040
+    UINT32                      DescTimeoutCnt;     //  0x1044
+    UINT32                      PayloadTimeoutCnt;  //  0x1048
+    UINT32                      WriteBackTimeoutCnt;//  0x104c
+    UINT32                      DescErrorCount;     //  0x1050
+    UINT32                      PayloadErrorCnt;    //  0x1054
+    UINT32                      WriteBackErrorCnt;  //  0x1058
+    UINT32                      DroppedTLPCount;    //  0x105c
+    TXDMA_SERVICE_COMPLETE_t    NewServiceComplete; //  0x1060
+    UINT32                      EthernetPacketCount;//  0x1064
+}
+TXDMA_t, *PTXDMA_t;
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                  END OF TXDMA REGISTER ADDRESS MAP                  ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+
+
+
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                 START OF RXDMA REGISTER ADDRESS MAP                 ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+/******************************************************************************
+   structure for control status reg in rxdma address map
+   Located at address 0x2000
+ *****************************************************************************/
+typedef union _RXDMA_CSR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused2:14;                          //bits 18-31
+        UINT32 halt_status:1;                       //bit 17
+        UINT32 pkt_done_flush:1;                    //bit 16
+        UINT32 pkt_drop_disable:1;                  //bit 15
+        UINT32 unused1:1;                           //bit 14
+        UINT32 fbr1_enable:1;                       //bit 13
+        UINT32 fbr1_size:2;                         //bits 11-12
+        UINT32 fbr0_enable:1;                       //bit 10
+        UINT32 fbr0_size:2;                         //bits 8-9
+        UINT32 dma_big_endian:1;                    //bit 7
+        UINT32 pkt_big_endian:1;                    //bit 6
+        UINT32 psr_big_endian:1;                    //bit 5
+        UINT32 fbr_big_endian:1;                    //bit 4
+        UINT32 tc:3;                                //bits 1-3
+        UINT32 halt:1;                              //bit 0
+    #else
+        UINT32 halt:1;                              //bit 0
+        UINT32 tc:3;                                //bits 1-3
+        UINT32 fbr_big_endian:1;                    //bit 4
+        UINT32 psr_big_endian:1;                    //bit 5
+        UINT32 pkt_big_endian:1;                    //bit 6
+        UINT32 dma_big_endian:1;                    //bit 7
+        UINT32 fbr0_size:2;                         //bits 8-9
+        UINT32 fbr0_enable:1;                       //bit 10
+        UINT32 fbr1_size:2;                         //bits 11-12
+        UINT32 fbr1_enable:1;                       //bit 13
+        UINT32 unused1:1;                           //bit 14
+        UINT32 pkt_drop_disable:1;                  //bit 15
+        UINT32 pkt_done_flush:1;                    //bit 16
+        UINT32 halt_status:1;                       //bit 17
+        UINT32 unused2:14;                          //bits 18-31
+    #endif
+    } bits;
+}
+RXDMA_CSR_t, *PRXDMA_CSR_t;
+
+
+/******************************************************************************
+   structure for dma writeback lo reg in rxdma address map
+   located at address 0x2004
+ *****************************************************************************/
+typedef struct _RXDMA_DMA_WB_BASE_LO_t
+{
+    UINT32 addr_lo;                                 //bits 0-31
+}
+RXDMA_DMA_WB_BASE_LO_t, *PRXDMA_DMA_WB_BASE_LO_t;
+
+
+/******************************************************************************
+   structure for dma writeback hi reg in rxdma address map
+   located at address 0x2008
+ *****************************************************************************/
+typedef struct _RXDMA_DMA_WB_BASE_HI_t
+{
+    UINT32 addr_hi;                                 //bits 0-31
+}
+RXDMA_DMA_WB_BASE_HI_t, *PRXDMA_DMA_WB_BASE_HI_t;
+
+
+/******************************************************************************
+   structure for number of packets done reg in rxdma address map
+   located at address 0x200C
+ *****************************************************************************/
+typedef union _RXDMA_NUM_PKT_DONE_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:24;                           //bits 8-31
+        UINT32 num_done:8;                          //bits 0-7
+    #else
+        UINT32 num_done:8;                          //bits 0-7
+        UINT32 unused:24;                           //bits 8-31
+    #endif
+    } bits;
+}
+RXDMA_NUM_PKT_DONE_t, *PRXDMA_NUM_PKT_DONE_t;
+
+
+/******************************************************************************
+   structure for max packet time reg in rxdma address map
+   located at address 0x2010
+ *****************************************************************************/
+typedef union _RXDMA_MAX_PKT_TIME_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:14;                           //bits 18-31
+        UINT32 time_done:18;                        //bits 0-17
+    #else
+        UINT32 time_done:18;                        //bits 0-17
+        UINT32 unused:14;                           //bits 18-31
+    #endif
+    } bits;
+}
+RXDMA_MAX_PKT_TIME_t, *PRXDMA_MAX_PKT_TIME_t;
+
+
+/******************************************************************************
+   structure for rx queue read address reg in rxdma address map
+   located at address 0x2014
+ *****************************************************************************/
+typedef union _RXDMA_RXQ_RD_ADDR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 rxq_rd_wrap:1;                       //bit 10
+        UINT32 rxq_rd:10;                           //bits 0-9
+    #else
+        UINT32 rxq_rd:10;                           //bits 0-9
+        UINT32 rxq_rd_wrap:1;                       //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+RXDMA_RXQ_RD_ADDR_t, *PRXDMA_RXQ_RD_ADDR_t;
+
+
+/******************************************************************************
+   structure for rx queue read address external reg in rxdma address map
+   located at address 0x2018
+ *****************************************************************************/
+typedef union _RXDMA_RXQ_RD_ADDR_EXT_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 rxq_rd_ext_wrap:1;                   //bit 10
+        UINT32 rxq_rd_ext:10;                       //bits 0-9
+    #else
+        UINT32 rxq_rd_ext:10;                       //bits 0-9
+        UINT32 rxq_rd_ext_wrap:1;                   //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+RXDMA_RXQ_RD_ADDR_EXT_t, *PRXDMA_RXQ_RD_ADDR_EXT_t;
+
+
+/******************************************************************************
+   structure for rx queue write address reg in rxdma address map
+   located at address 0x201C
+ *****************************************************************************/
+typedef union _RXDMA_RXQ_WR_ADDR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 rxq_wr_wrap:1;                       //bit 10
+        UINT32 rxq_wr:10;                           //bits 0-9
+    #else
+        UINT32 rxq_wr:10;                           //bits 0-9
+        UINT32 rxq_wr_wrap:1;                       //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+RXDMA_RXQ_WR_ADDR_t, *PRXDMA_RXQ_WR_ADDR_t;
+
+
+/******************************************************************************
+   structure for packet status ring base address lo reg in rxdma address map
+   located at address 0x2020
+ *****************************************************************************/
+typedef struct _RXDMA_PSR_BASE_LO_t
+{
+    UINT32 addr_lo;                                 //bits 0-31
+}
+RXDMA_PSR_BASE_LO_t, *PRXDMA_PSR_BASE_LO_t;
+
+
+/******************************************************************************
+   structure for packet status ring base address hi reg in rxdma address map
+   located at address 0x2024
+ *****************************************************************************/
+typedef struct _RXDMA_PSR_BASE_HI_t
+{
+    UINT32 addr_hi;                                  //bits 0-31
+}
+RXDMA_PSR_BASE_HI_t, *PRXDMA_PSR_BASE_HI_t;
+
+
+/******************************************************************************
+   structure for packet status ring number of descriptors reg in rxdma address
+   map.  Located at address 0x2028
+ *****************************************************************************/
+typedef union _RXDMA_PSR_NUM_DES_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:20;                           //bits 12-31
+        UINT32 psr_ndes:12;                         //bit 0-11
+    #else
+        UINT32 psr_ndes:12;                         //bit 0-11
+        UINT32 unused:20;                           //bits 12-31
+    #endif
+    } bits;
+}
+RXDMA_PSR_NUM_DES_t, *PRXDMA_PSR_NUM_DES_t;
+
+
+/******************************************************************************
+   structure for packet status ring available offset reg in rxdma address map
+   located at address 0x202C
+ *****************************************************************************/
+typedef union _RXDMA_PSR_AVAIL_OFFSET_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:19;                           //bits 13-31
+        UINT32 psr_avail_wrap:1;                    //bit 12
+        UINT32 psr_avail:12;                        //bit 0-11
+    #else
+        UINT32 psr_avail:12;                        //bit 0-11
+        UINT32 psr_avail_wrap:1;                    //bit 12
+        UINT32 unused:19;                           //bits 13-31
+    #endif
+    } bits;
+}
+RXDMA_PSR_AVAIL_OFFSET_t, *PRXDMA_PSR_AVAIL_OFFSET_t;
+
+
+/******************************************************************************
+   structure for packet status ring full offset reg in rxdma address map
+   located at address 0x2030
+ *****************************************************************************/
+typedef union _RXDMA_PSR_FULL_OFFSET_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:19;                           //bits 13-31
+        UINT32 psr_full_wrap:1;                     //bit 12
+        UINT32 psr_full:12;                         //bit 0-11
+    #else
+        UINT32 psr_full:12;                         //bit 0-11
+        UINT32 psr_full_wrap:1;                     //bit 12
+        UINT32 unused:19;                           //bits 13-31
+    #endif
+    } bits;
+}
+RXDMA_PSR_FULL_OFFSET_t, *PRXDMA_PSR_FULL_OFFSET_t;
+
+
+/******************************************************************************
+   structure for packet status ring access index reg in rxdma address map
+   located at address 0x2034
+ *****************************************************************************/
+typedef union _RXDMA_PSR_ACCESS_INDEX_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:27;                           //bits 5-31
+        UINT32 psr_ai:5;                            //bits 0-4
+    #else
+        UINT32 psr_ai:5;                            //bits 0-4
+        UINT32 unused:27;                           //bits 5-31
+    #endif
+    } bits;
+}
+RXDMA_PSR_ACCESS_INDEX_t, *PRXDMA_PSR_ACCESS_INDEX_t;
+
+
+/******************************************************************************
+   structure for packet status ring minimum descriptors reg in rxdma address
+   map.  Located at address 0x2038
+ *****************************************************************************/
+typedef union _RXDMA_PSR_MIN_DES_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:20;                           //bits 12-31
+        UINT32 psr_min:12;                          //bits 0-11
+    #else
+        UINT32 psr_min:12;                          //bits 0-11
+        UINT32 unused:20;                           //bits 12-31
+    #endif
+    } bits;
+}
+RXDMA_PSR_MIN_DES_t, *PRXDMA_PSR_MIN_DES_t;
+
+
+/******************************************************************************
+   structure for free buffer ring base lo address reg in rxdma address map
+   located at address 0x203C
+ *****************************************************************************/
+typedef struct _RXDMA_FBR_BASE_LO_t
+{
+    UINT32 addr_lo;                                 //bits 0-31
+}
+RXDMA_FBR_BASE_LO_t, *PRXDMA_FBR_BASE_LO_t;
+
+
+/******************************************************************************
+   structure for free buffer ring base hi address reg in rxdma address map
+   located at address 0x2040
+ *****************************************************************************/
+typedef struct _RXDMA_FBR_BASE_HI_t
+{
+    UINT32 addr_hi;                                 //bits 0-31
+}
+RXDMA_FBR_BASE_HI_t, *PRXDMA_FBR_BASE_HI_t;
+
+
+/******************************************************************************
+   structure for free buffer ring number of descriptors reg in rxdma address
+   map.  Located at address 0x2044
+ *****************************************************************************/
+typedef union _RXDMA_FBR_NUM_DES_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:22;                           //bits 10-31
+        UINT32 fbr_ndesc:10;                        //bits 0-9
+    #else
+        UINT32 fbr_ndesc:10;                        //bits 0-9
+        UINT32 unused:22;                           //bits 10-31
+    #endif
+    } bits;
+}
+RXDMA_FBR_NUM_DES_t, *PRXDMA_FBR_NUM_DES_t;
+
+
+/******************************************************************************
+   structure for free buffer ring 0 available offset reg in rxdma address map
+   located at address 0x2048
+ *****************************************************************************/
+typedef union _RXDMA_FBR_AVAIL_OFFSET_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 fbr_avail_wrap:1;                    //bit 10
+        UINT32 fbr_avail:10;                        //bit 0-9
+    #else
+        UINT32 fbr_avail:10;                        //bit 0-9
+        UINT32 fbr_avail_wrap:1;                    //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+RXDMA_FBR_AVAIL_OFFSET_t, *PRXDMA_FBR_AVAIL_OFFSET_t;
+
+
+/******************************************************************************
+   structure for free buffer ring 0 full offset reg in rxdma address map
+   located at address 0x204C
+ *****************************************************************************/
+typedef union _RXDMA_FBR_FULL_OFFSET_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 fbr_full_wrap:1;                     //bit 10
+        UINT32 fbr_full:10;                         //bit 0-9
+    #else
+        UINT32 fbr_full:10;                         //bit 0-9
+        UINT32 fbr_full_wrap:1;                     //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+RXDMA_FBR_FULL_OFFSET_t, *PRXDMA_FBR_FULL_OFFSET_t;
+
+
+/******************************************************************************
+   structure for free buffer cache 0 full offset reg in rxdma address map
+   located at address 0x2050
+ *****************************************************************************/
+typedef union _RXDMA_FBC_RD_INDEX_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:27;                           //bits 5-31
+        UINT32 fbc_rdi:5;                          //bit 0-4
+    #else
+        UINT32 fbc_rdi:5;                          //bit 0-4
+        UINT32 unused:27;                           //bits 5-31
+    #endif
+    } bits;
+}
+RXDMA_FBC_RD_INDEX_t, *PRXDMA_FBC_RD_INDEX_t;
+
+
+/******************************************************************************
+   structure for free buffer ring 0 minimum descriptor reg in rxdma address map
+   located at address 0x2054
+ *****************************************************************************/
+typedef union _RXDMA_FBR_MIN_DES_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:22;                           //bits 10-31
+        UINT32 fbr_min:10;                          //bits 0-9
+    #else
+        UINT32 fbr_min:10;                          //bits 0-9
+        UINT32 unused:22;                           //bits 10-31
+    #endif
+    } bits;
+}
+RXDMA_FBR_MIN_DES_t, *PRXDMA_FBR_MIN_DES_t;
+
+
+/******************************************************************************
+   structure for free buffer ring 1 base address lo reg in rxdma address map
+   located at address 0x2058 - 0x205C
+   Defined earlier (RXDMA_FBR_BASE_LO_t and RXDMA_FBR_BASE_HI_t)
+ *****************************************************************************/
+
+/******************************************************************************
+   structure for free buffer ring 1 number of descriptors reg in rxdma address
+   map.  Located at address 0x2060
+   Defined earlier (RXDMA_FBR_NUM_DES_t)
+ *****************************************************************************/
+
+/******************************************************************************
+   structure for free buffer ring 1 available offset reg in rxdma address map
+   located at address 0x2064
+   Defined Earlier (RXDMA_FBR_AVAIL_OFFSET_t)
+ *****************************************************************************/
+
+/******************************************************************************
+   structure for free buffer ring 1 full offset reg in rxdma address map
+   located at address 0x2068
+   Defined Earlier (RXDMA_FBR_FULL_OFFSET_t)
+ *****************************************************************************/
+
+/******************************************************************************
+   structure for free buffer cache 1 read index reg in rxdma address map
+   located at address 0x206C
+   Defined Earlier (RXDMA_FBC_RD_INDEX_t)
+ *****************************************************************************/
+
+/******************************************************************************
+   structure for free buffer ring 1 minimum descriptor reg in rxdma address map
+   located at address 0x2070
+   Defined Earlier (RXDMA_FBR_MIN_DES_t)
+ *****************************************************************************/
+
+
+/******************************************************************************
+   Rx DMA Module of JAGCore Address Mapping
+   Located at address 0x2000
+ *****************************************************************************/
+typedef struct _RXDMA_t
+{                                                   //Location:
+    RXDMA_CSR_t                 csr;                //  0x2000
+    RXDMA_DMA_WB_BASE_LO_t      dma_wb_base_lo;     //  0x2004
+    RXDMA_DMA_WB_BASE_HI_t      dma_wb_base_hi;     //  0x2008
+    RXDMA_NUM_PKT_DONE_t        num_pkt_done;       //  0x200C
+    RXDMA_MAX_PKT_TIME_t        max_pkt_time;       //  0x2010
+    RXDMA_RXQ_RD_ADDR_t         rxq_rd_addr;        //  0x2014
+    RXDMA_RXQ_RD_ADDR_EXT_t     rxq_rd_addr_ext;    //  0x2018
+    RXDMA_RXQ_WR_ADDR_t         rxq_wr_addr;        //  0x201C
+    RXDMA_PSR_BASE_LO_t         psr_base_lo;        //  0x2020
+    RXDMA_PSR_BASE_HI_t         psr_base_hi;        //  0x2024
+    RXDMA_PSR_NUM_DES_t         psr_num_des;        //  0x2028
+    RXDMA_PSR_AVAIL_OFFSET_t    psr_avail_offset;   //  0x202C
+    RXDMA_PSR_FULL_OFFSET_t     psr_full_offset;    //  0x2030
+    RXDMA_PSR_ACCESS_INDEX_t    psr_access_index;   //  0x2034
+    RXDMA_PSR_MIN_DES_t         psr_min_des;        //  0x2038
+    RXDMA_FBR_BASE_LO_t         fbr0_base_lo;       //  0x203C
+    RXDMA_FBR_BASE_HI_t         fbr0_base_hi;       //  0x2040
+    RXDMA_FBR_NUM_DES_t         fbr0_num_des;       //  0x2044
+    RXDMA_FBR_AVAIL_OFFSET_t    fbr0_avail_offset;  //  0x2048
+    RXDMA_FBR_FULL_OFFSET_t     fbr0_full_offset;   //  0x204C
+    RXDMA_FBC_RD_INDEX_t        fbr0_rd_index;      //  0x2050
+    RXDMA_FBR_MIN_DES_t         fbr0_min_des;       //  0x2054
+    RXDMA_FBR_BASE_LO_t         fbr1_base_lo;       //  0x2058
+    RXDMA_FBR_BASE_HI_t         fbr1_base_hi;       //  0x205C
+    RXDMA_FBR_NUM_DES_t         fbr1_num_des;       //  0x2060
+    RXDMA_FBR_AVAIL_OFFSET_t    fbr1_avail_offset;  //  0x2064
+    RXDMA_FBR_FULL_OFFSET_t     fbr1_full_offset;   //  0x2068
+    RXDMA_FBC_RD_INDEX_t        fbr1_rd_index;      //  0x206C
+    RXDMA_FBR_MIN_DES_t         fbr1_min_des;       //  0x2070
+}
+RXDMA_t, *PRXDMA_t;
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                  END OF RXDMA REGISTER ADDRESS MAP                  ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+
+
+
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                 START OF TXMAC REGISTER ADDRESS MAP                 ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+/******************************************************************************
+   structure for control reg in txmac address map
+   located at address 0x3000
+ *****************************************************************************/
+typedef union _TXMAC_CTL_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:24;                           //bits 8-31
+        UINT32 cklseg_diable:1;                     //bit 7
+        UINT32 ckbcnt_disable:1;                    //bit 6
+        UINT32 cksegnum:1;                          //bit 5
+        UINT32 async_disable:1;                     //bit 4
+        UINT32 fc_disable:1;                        //bit 3
+        UINT32 mcif_disable:1;                      //bit 2
+        UINT32 mif_disable:1;                       //bit 1
+        UINT32 txmac_en:1;                          //bit 0
+    #else
+        UINT32 txmac_en:1;                          //bit 0
+        UINT32 mif_disable:1;                       //bit 1 mac interface
+        UINT32 mcif_disable:1;                      //bit 2 memory controller interface
+        UINT32 fc_disable:1;                        //bit 3
+        UINT32 async_disable:1;                     //bit 4
+        UINT32 cksegnum:1;                          //bit 5
+        UINT32 ckbcnt_disable:1;                    //bit 6
+        UINT32 cklseg_diable:1;                     //bit 7
+        UINT32 unused:24;                           //bits 8-31
+    #endif
+    } bits;
+}
+TXMAC_CTL_t, *PTXMAC_CTL_t;
+
+
+/******************************************************************************
+   structure for shadow pointer reg in txmac address map
+   located at address 0x3004
+ *****************************************************************************/
+typedef union _TXMAC_SHADOW_PTR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved2:5;                         //bits 27-31
+        UINT32 txq_rd_ptr:11;                       //bits 16-26
+        UINT32 reserved:5;                          //bits 11-15
+        UINT32 txq_wr_ptr:11;                       //bits 0-10
+    #else
+        UINT32 txq_wr_ptr:11;                       //bits 0-10
+        UINT32 reserved:5;                          //bits 11-15
+        UINT32 txq_rd_ptr:11;                       //bits 16-26
+        UINT32 reserved2:5;                         //bits 27-31
+    #endif
+    } bits;
+}
+TXMAC_SHADOW_PTR_t, *PTXMAC_SHADOW_PTR_t;
+
+
+/******************************************************************************
+   structure for error count reg in txmac address map
+   located at address 0x3008
+ *****************************************************************************/
+typedef union _TXMAC_ERR_CNT_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:20;                           //bits 12-31
+        UINT32 reserved:4;                          //bits 8-11
+        UINT32 txq_underrun:4;                      //bits 4-7
+        UINT32 fifo_underrun:4;                     //bits 0-3
+    #else
+        UINT32 fifo_underrun:4;                     //bits 0-3
+        UINT32 txq_underrun:4;                      //bits 4-7
+        UINT32 reserved:4;                          //bits 8-11
+        UINT32 unused:20;                           //bits 12-31
+    #endif
+    } bits;
+} TXMAC_ERR_CNT_t, *PTXMAC_ERR_CNT_t;
+
+
+/******************************************************************************
+   structure for max fill reg in txmac address map
+   located at address 0x300C
+ *****************************************************************************/
+typedef union _TXMAC_MAX_FILL_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:20;                           //bits 12-31
+        UINT32 max_fill:12;                         //bits 0-11
+    #else
+        UINT32 max_fill:12;                         //bits 0-11
+        UINT32 unused:20;                           //bits 12-31
+    #endif
+    } bits;
+}
+TXMAC_MAX_FILL_t, *PTXMAC_MAX_FILL_t;
+
+
+/******************************************************************************
+   structure for cf parameter reg in txmac address map
+   located at address 0x3010
+ *****************************************************************************/
+typedef union _TXMAC_CF_PARAM_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 cfep:16;                             //bits 16-31
+        UINT32 cfpt:16;                             //bits 0-15
+    #else
+        UINT32 cfpt:16;                             //bits 0-15
+        UINT32 cfep:16;                             //bits 16-31
+    #endif
+    } bits;
+}
+TXMAC_CF_PARAM_t, *PTXMAC_CF_PARAM_t;
+
+
+/******************************************************************************
+   structure for tx test reg in txmac address map
+   located at address 0x3014
+ *****************************************************************************/
+typedef union _TXMAC_TXTEST_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused2:15;                          //bits 17-31
+        UINT32 reserved1:1;                         //bit 16
+        UINT32 txtest_en:1;                         //bit 15
+        UINT32 unused1:4;                           //bits 11-14
+        UINT32 txqtest_ptr:11;                      //bits 0-11
+    #else
+        UINT32 txqtest_ptr:11;                      //bits 0-10
+        UINT32 unused1:4;                           //bits 11-14
+        UINT32 txtest_en:1;                         //bit 15
+        UINT32 reserved1:1;                         //bit 16
+        UINT32 unused2:15;                          //bits 17-31
+    #endif
+    } bits;
+}
+TXMAC_TXTEST_t, *PTXMAC_TXTEST_t;
+
+
+/******************************************************************************
+   structure for error reg in txmac address map
+   located at address 0x3018
+ *****************************************************************************/
+typedef union _TXMAC_ERR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused2:23;                          //bits 9-31
+        UINT32 fifo_underrun:1;                     //bit 8
+        UINT32 unused1:2;                           //bits 6-7
+        UINT32 ctrl2_err:1;                         //bit 5
+        UINT32 txq_underrun:1;                      //bit 4
+        UINT32 bcnt_err:1;                          //bit 3
+        UINT32 lseg_err:1;                          //bit 2
+        UINT32 segnum_err:1;                        //bit 1
+        UINT32 seg0_err:1;                          //bit 0
+    #else
+        UINT32 seg0_err:1;                          //bit 0
+        UINT32 segnum_err:1;                        //bit 1
+        UINT32 lseg_err:1;                          //bit 2
+        UINT32 bcnt_err:1;                          //bit 3
+        UINT32 txq_underrun:1;                      //bit 4
+        UINT32 ctrl2_err:1;                         //bit 5
+        UINT32 unused1:2;                           //bits 6-7
+        UINT32 fifo_underrun:1;                     //bit 8
+        UINT32 unused2:23;                          //bits 9-31
+    #endif
+    } bits;
+}
+TXMAC_ERR_t, *PTXMAC_ERR_t;
+
+
+/******************************************************************************
+   structure for error interrupt reg in txmac address map
+   located at address 0x301C
+ *****************************************************************************/
+typedef union _TXMAC_ERR_INT_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused2:23;                          //bits 9-31
+        UINT32 fifo_underrun:1;                     //bit 8
+        UINT32 unused1:2;                           //bits 6-7
+        UINT32 ctrl2_err:1;                         //bit 5
+        UINT32 txq_underrun:1;                      //bit 4
+        UINT32 bcnt_err:1;                          //bit 3
+        UINT32 lseg_err:1;                          //bit 2
+        UINT32 segnum_err:1;                        //bit 1
+        UINT32 seg0_err:1;                          //bit 0
+    #else
+        UINT32 seg0_err:1;                          //bit 0
+        UINT32 segnum_err:1;                        //bit 1
+        UINT32 lseg_err:1;                          //bit 2
+        UINT32 bcnt_err:1;                          //bit 3
+        UINT32 txq_underrun:1;                      //bit 4
+        UINT32 ctrl2_err:1;                         //bit 5
+        UINT32 unused1:2;                           //bits 6-7
+        UINT32 fifo_underrun:1;                     //bit 8
+        UINT32 unused2:23;                          //bits 9-31
+    #endif
+    } bits;
+}
+TXMAC_ERR_INT_t, *PTXMAC_ERR_INT_t;
+
+
+/******************************************************************************
+   structure for error interrupt reg in txmac address map
+   located at address 0x3020
+ *****************************************************************************/
+typedef union _TXMAC_CP_CTRL_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:30;                           //bits 2-31
+        UINT32 bp_req:1;                            //bit 1
+        UINT32 bp_xonxoff:1;                        //bit 0
+    #else
+        UINT32 bp_xonxoff:1;                        //bit 0
+        UINT32 bp_req:1;                            //bit 1
+        UINT32 unused:30;                           //bits 2-31
+    #endif
+    } bits;
+}
+TXMAC_BP_CTRL_t, *PTXMAC_BP_CTRL_t;
+
+
+/******************************************************************************
+   Tx MAC Module of JAGCore Address Mapping
+ *****************************************************************************/
+typedef struct _TXMAC_t
+{                                                   //Location:
+    TXMAC_CTL_t             ctl;                    //  0x3000
+    TXMAC_SHADOW_PTR_t      shadow_ptr;             //  0x3004
+    TXMAC_ERR_CNT_t         err_cnt;                //  0x3008
+    TXMAC_MAX_FILL_t        max_fill;               //  0x300C
+    TXMAC_CF_PARAM_t        cf_param;               //  0x3010
+    TXMAC_TXTEST_t          tx_test;                //  0x3014
+    TXMAC_ERR_t             err;                    //  0x3018
+    TXMAC_ERR_INT_t         err_int;                //  0x301C
+    TXMAC_BP_CTRL_t         bp_ctrl;                //  0x3020
+}
+TXMAC_t, *PTXMAC_t;
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                  END OF TXMAC REGISTER ADDRESS MAP                  ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+
+
+
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                 START OF RXMAC REGISTER ADDRESS MAP                 ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+/******************************************************************************
+   structure for rxmac control reg in rxmac address map
+   located at address 0x4000
+ *****************************************************************************/
+typedef union _RXMAC_CTRL_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:25;                         //bits 7-31
+        UINT32 rxmac_int_disable:1;                 //bit 6
+        UINT32 async_disable:1;                     //bit 5
+        UINT32 mif_disable:1;                       //bit 4
+        UINT32 wol_disable:1;                       //bit 3
+        UINT32 pkt_filter_disable:1;                //bit 2
+        UINT32 mcif_disable:1;                      //bit 1
+        UINT32 rxmac_en:1;                          //bit 0
+    #else
+        UINT32 rxmac_en:1;                          //bit 0
+        UINT32 mcif_disable:1;                      //bit 1
+        UINT32 pkt_filter_disable:1;                //bit 2
+        UINT32 wol_disable:1;                       //bit 3
+        UINT32 mif_disable:1;                       //bit 4
+        UINT32 async_disable:1;                     //bit 5
+        UINT32 rxmac_int_disable:1;                 //bit 6
+        UINT32 reserved:25;                         //bits 7-31
+    #endif
+    } bits;
+}
+RXMAC_CTRL_t, *PRXMAC_CTRL_t;
+
+
+/******************************************************************************
+   structure for Wake On Lan Control and CRC 0 reg in rxmac address map
+   located at address 0x4004
+ *****************************************************************************/
+typedef union _RXMAC_WOL_CTL_CRC0_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 crc0:16;                             //bits 16-31
+        UINT32 reserve:4;                           //bits 12-15
+        UINT32 ignore_pp:1;                         //bit 11
+        UINT32 ignore_mp:1;                         //bit 10
+        UINT32 clr_intr:1;                          //bit 9
+        UINT32 ignore_link_chg:1;                   //bit 8
+        UINT32 ignore_uni:1;                        //bit 7
+        UINT32 ignore_multi:1;                      //bit 6
+        UINT32 ignore_broad:1;                      //bit 5
+        UINT32 valid_crc4:1;                        //bit 4
+        UINT32 valid_crc3:1;                        //bit 3
+        UINT32 valid_crc2:1;                        //bit 2
+        UINT32 valid_crc1:1;                        //bit 1
+        UINT32 valid_crc0:1;                        //bit 0
+    #else
+        UINT32 valid_crc0:1;                        //bit 0
+        UINT32 valid_crc1:1;                        //bit 1
+        UINT32 valid_crc2:1;                        //bit 2
+        UINT32 valid_crc3:1;                        //bit 3
+        UINT32 valid_crc4:1;                        //bit 4
+        UINT32 ignore_broad:1;                      //bit 5
+        UINT32 ignore_multi:1;                      //bit 6
+        UINT32 ignore_uni:1;                        //bit 7
+        UINT32 ignore_link_chg:1;                   //bit 8
+        UINT32 clr_intr:1;                          //bit 9
+        UINT32 ignore_mp:1;                         //bit 10
+        UINT32 ignore_pp:1;                         //bit 11
+        UINT32 reserve:4;                           //bits 12-15
+        UINT32 crc0:16;                             //bits 16-31
+    #endif
+    } bits;
+}
+RXMAC_WOL_CTL_CRC0_t, *PRXMAC_WOL_CTL_CRC0_t;
+
+
+/******************************************************************************
+   structure for CRC 1 and CRC 2 reg in rxmac address map
+   located at address 0x4008
+ *****************************************************************************/
+typedef union _RXMAC_WOL_CRC12_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 crc2:16;                             //bits 16-31
+        UINT32 crc1:16;                             //bits 0-15
+    #else
+        UINT32 crc1:16;                             //bits 0-15
+        UINT32 crc2:16;                             //bits 16-31
+    #endif
+    } bits;
+}
+RXMAC_WOL_CRC12_t, *PRXMAC_WOL_CRC12_t;
+
+
+/******************************************************************************
+   structure for CRC 3 and CRC 4 reg in rxmac address map
+   located at address 0x400C
+ *****************************************************************************/
+typedef union _RXMAC_WOL_CRC34_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 crc4:16;                             //bits 16-31
+        UINT32 crc3:16;                             //bits 0-15
+    #else
+        UINT32 crc3:16;                             //bits 0-15
+        UINT32 crc4:16;                             //bits 16-31
+    #endif
+    } bits;
+}
+RXMAC_WOL_CRC34_t, *PRXMAC_WOL_CRC34_t;
+
+
+/******************************************************************************
+   structure for Wake On Lan Source Address Lo reg in rxmac address map
+   located at address 0x4010
+ *****************************************************************************/
+typedef union _RXMAC_WOL_SA_LO_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 sa3:8;                               //bits 24-31
+        UINT32 sa4:8;                               //bits 16-23
+        UINT32 sa5:8;                               //bits 8-15
+        UINT32 sa6:8;                               //bits 0-7
+    #else
+        UINT32 sa6:8;                               //bits 0-7
+        UINT32 sa5:8;                               //bits 8-15
+        UINT32 sa4:8;                               //bits 16-23
+        UINT32 sa3:8;                               //bits 24-31
+    #endif
+    } bits;
+}
+RXMAC_WOL_SA_LO_t, *PRXMAC_WOL_SA_LO_t;
+
+
+/******************************************************************************
+   structure for Wake On Lan Source Address Hi reg in rxmac address map
+   located at address 0x4014
+ *****************************************************************************/
+typedef union _RXMAC_WOL_SA_HI_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:16;                         //bits 16-31
+        UINT32 sa1:8;                               //bits 8-15
+        UINT32 sa2:8;                               //bits 0-7
+    #else
+        UINT32 sa2:8;                               //bits 0-7
+        UINT32 sa1:8;                               //bits 8-15
+        UINT32 reserved:16;                         //bits 16-31
+    #endif
+    } bits;
+}
+RXMAC_WOL_SA_HI_t, *PRXMAC_WOL_SA_HI_t;
+
+
+/******************************************************************************
+   structure for Wake On Lan mask reg in rxmac address map
+   located at address 0x4018 - 0x4064
+ *****************************************************************************/
+typedef struct _RXMAC_WOL_MASK_t
+{
+    UINT32 mask;                                    //bits 0-31
+}
+RXMAC_WOL_MASK_t, *PRXMAC_WOL_MASK_t;
+
+
+/******************************************************************************
+   structure for Unicast Paket Filter Address 1 reg in rxmac address map
+   located at address 0x4068
+ *****************************************************************************/
+typedef union _RXMAC_UNI_PF_ADDR1_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 addr1_3:8;                           //bits 24-31
+        UINT32 addr1_4:8;                           //bits 16-23
+        UINT32 addr1_5:8;                           //bits 8-15
+        UINT32 addr1_6:8;                           //bits 0-7
+    #else
+        UINT32 addr1_6:8;                           //bits 0-7
+        UINT32 addr1_5:8;                           //bits 8-15
+        UINT32 addr1_4:8;                           //bits 16-23
+        UINT32 addr1_3:8;                           //bits 24-31
+    #endif
+    } bits;
+}
+RXMAC_UNI_PF_ADDR1_t, *PRXMAC_UNI_PF_ADDR1_t;
+
+
+/******************************************************************************
+   structure for Unicast Paket Filter Address 2 reg in rxmac address map
+   located at address 0x406C
+ *****************************************************************************/
+typedef union _RXMAC_UNI_PF_ADDR2_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 addr2_3:8;                           //bits 24-31
+        UINT32 addr2_4:8;                           //bits 16-23
+        UINT32 addr2_5:8;                           //bits 8-15
+        UINT32 addr2_6:8;                           //bits 0-7
+    #else
+        UINT32 addr2_6:8;                           //bits 0-7
+        UINT32 addr2_5:8;                           //bits 8-15
+        UINT32 addr2_4:8;                           //bits 16-23
+        UINT32 addr2_3:8;                           //bits 24-31
+    #endif
+    } bits;
+}
+RXMAC_UNI_PF_ADDR2_t, *PRXMAC_UNI_PF_ADDR2_t;
+
+
+/******************************************************************************
+   structure for Unicast Paket Filter Address 1 & 2 reg in rxmac address map
+   located at address 0x4070
+ *****************************************************************************/
+typedef union _RXMAC_UNI_PF_ADDR3_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 addr2_1:8;                           //bits 24-31
+        UINT32 addr2_2:8;                           //bits 16-23
+        UINT32 addr1_1:8;                           //bits 8-15
+        UINT32 addr1_2:8;                           //bits 0-7
+    #else
+        UINT32 addr1_2:8;                           //bits 0-7
+        UINT32 addr1_1:8;                           //bits 8-15
+        UINT32 addr2_2:8;                           //bits 16-23
+        UINT32 addr2_1:8;                           //bits 24-31
+    #endif
+    } bits;
+}
+RXMAC_UNI_PF_ADDR3_t, *PRXMAC_UNI_PF_ADDR3_t;
+
+
+/******************************************************************************
+   structure for Multicast Hash reg in rxmac address map
+   located at address 0x4074 - 0x4080
+ *****************************************************************************/
+typedef struct _RXMAC_MULTI_HASH_t
+{
+    UINT32 hash;                                    //bits 0-31
+}
+RXMAC_MULTI_HASH_t, *PRXMAC_MULTI_HASH_t;
+
+
+/******************************************************************************
+   structure for Packet Filter Control reg in rxmac address map
+   located at address 0x4084
+ *****************************************************************************/
+typedef union _RXMAC_PF_CTRL_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused2:9;                           //bits 23-31
+        UINT32 min_pkt_size:7;                      //bits 16-22
+        UINT32 unused1:12;                          //bits 4-15
+        UINT32 filter_frag_en:1;                    //bit 3
+        UINT32 filter_uni_en:1;                     //bit 2
+        UINT32 filter_multi_en:1;                   //bit 1
+        UINT32 filter_broad_en:1;                   //bit 0
+    #else
+        UINT32 filter_broad_en:1;                   //bit 0
+        UINT32 filter_multi_en:1;                   //bit 1
+        UINT32 filter_uni_en:1;                     //bit 2
+        UINT32 filter_frag_en:1;                    //bit 3
+        UINT32 unused1:12;                          //bits 4-15
+        UINT32 min_pkt_size:7;                      //bits 16-22
+        UINT32 unused2:9;                           //bits 23-31
+    #endif
+    } bits;
+}
+RXMAC_PF_CTRL_t, *PRXMAC_PF_CTRL_t;
+
+
+/******************************************************************************
+   structure for Memory Controller Interface Control Max Segment reg in rxmac
+   address map.  Located at address 0x4088
+ *****************************************************************************/
+typedef union _RXMAC_MCIF_CTRL_MAX_SEG_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:22;                         //bits 10-31
+        UINT32 max_size:8;                          //bits 2-9
+        UINT32 fc_en:1;                             //bit 1
+        UINT32 seg_en:1;                            //bit 0
+    #else
+        UINT32 seg_en:1;                            //bit 0
+        UINT32 fc_en:1;                             //bit 1
+        UINT32 max_size:8;                          //bits 2-9
+        UINT32 reserved:22;                         //bits 10-31
+    #endif
+    } bits;
+}
+RXMAC_MCIF_CTRL_MAX_SEG_t, *PRXMAC_MCIF_CTRL_MAX_SEG_t;
+
+
+/******************************************************************************
+   structure for Memory Controller Interface Water Mark reg in rxmac address
+   map.  Located at address 0x408C
+ *****************************************************************************/
+typedef union _RXMAC_MCIF_WATER_MARK_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved2:6;                         //bits 26-31
+        UINT32 mark_hi:10;                          //bits 16-25
+        UINT32 reserved1:6;                         //bits 10-15
+        UINT32 mark_lo:10;                          //bits 0-9
+    #else
+        UINT32 mark_lo:10;                          //bits 0-9
+        UINT32 reserved1:6;                         //bits 10-15
+        UINT32 mark_hi:10;                          //bits 16-25
+        UINT32 reserved2:6;                         //bits 26-31
+    #endif
+    } bits;
+}
+RXMAC_MCIF_WATER_MARK_t, *PRXMAC_MCIF_WATER_MARK_t;
+
+
+/******************************************************************************
+   structure for Rx Queue Dialog reg in rxmac address map.
+   located at address 0x4090
+ *****************************************************************************/
+typedef union _RXMAC_RXQ_DIAG_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved2:6;                         //bits 26-31
+        UINT32 rd_ptr:10;                           //bits 16-25
+        UINT32 reserved1:6;                         //bits 10-15
+        UINT32 wr_ptr:10;                           //bits 0-9
+    #else
+        UINT32 wr_ptr:10;                           //bits 0-9
+        UINT32 reserved1:6;                         //bits 10-15
+        UINT32 rd_ptr:10;                           //bits 16-25
+        UINT32 reserved2:6;                         //bits 26-31
+    #endif
+    } bits;
+}
+RXMAC_RXQ_DIAG_t, *PRXMAC_RXQ_DIAG_t;
+
+
+/******************************************************************************
+   structure for space availiable reg in rxmac address map.
+   located at address 0x4094
+ *****************************************************************************/
+typedef union _RXMAC_SPACE_AVAIL_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved2:15;                        //bits 17-31
+        UINT32 space_avail_en:1;                    //bit 16
+        UINT32 reserved1:6;                         //bits 10-15
+        UINT32 space_avail:10;                      //bits 0-9
+    #else
+        UINT32 space_avail:10;                      //bits 0-9
+        UINT32 reserved1:6;                         //bits 10-15
+        UINT32 space_avail_en:1;                    //bit 16
+        UINT32 reserved2:15;                        //bits 17-31
+    #endif
+    } bits;
+}
+RXMAC_SPACE_AVAIL_t, *PRXMAC_SPACE_AVAIL_t;
+
+
+/******************************************************************************
+   structure for management interface reg in rxmac address map.
+   located at address 0x4098
+ *****************************************************************************/
+typedef union _RXMAC_MIF_CTL_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserve:14;                          //bits 18-31
+        UINT32 drop_pkt_en:1;                       //bit 17
+        UINT32 drop_pkt_mask:17;                    //bits 0-16
+    #else
+        UINT32 drop_pkt_mask:17;                    //bits 0-16
+        UINT32 drop_pkt_en:1;                       //bit 17
+        UINT32 reserve:14;                          //bits 18-31
+    #endif
+    } bits;
+}
+RXMAC_MIF_CTL_t, *PRXMAC_MIF_CTL_t;
+
+
+/******************************************************************************
+   structure for Error reg in rxmac address map.
+   located at address 0x409C
+ *****************************************************************************/
+typedef union _RXMAC_ERROR_REG_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserve:28;                          //bits 4-31
+        UINT32 mif:1;                               //bit 3
+        UINT32 async:1;                             //bit 2
+        UINT32 pkt_filter:1;                        //bit 1
+        UINT32 mcif:1;                              //bit 0
+    #else
+        UINT32 mcif:1;                              //bit 0
+        UINT32 pkt_filter:1;                        //bit 1
+        UINT32 async:1;                             //bit 2
+        UINT32 mif:1;                               //bit 3
+        UINT32 reserve:28;                          //bits 4-31
+    #endif
+    } bits;
+}
+RXMAC_ERROR_REG_t, *PRXMAC_ERROR_REG_t;
+
+
+/******************************************************************************
+   Rx MAC Module of JAGCore Address Mapping
+ *****************************************************************************/
+typedef struct _RXMAC_t
+{                                                   //Location:
+    RXMAC_CTRL_t                ctrl;               //  0x4000
+    RXMAC_WOL_CTL_CRC0_t        crc0;               //  0x4004
+    RXMAC_WOL_CRC12_t           crc12;              //  0x4008
+    RXMAC_WOL_CRC34_t           crc34;              //  0x400C
+    RXMAC_WOL_SA_LO_t           sa_lo;              //  0x4010
+    RXMAC_WOL_SA_HI_t           sa_hi;              //  0x4014
+    RXMAC_WOL_MASK_t            mask0_word0;        //  0x4018
+    RXMAC_WOL_MASK_t            mask0_word1;        //  0x401C
+    RXMAC_WOL_MASK_t            mask0_word2;        //  0x4020
+    RXMAC_WOL_MASK_t            mask0_word3;        //  0x4024
+    RXMAC_WOL_MASK_t            mask1_word0;        //  0x4028
+    RXMAC_WOL_MASK_t            mask1_word1;        //  0x402C
+    RXMAC_WOL_MASK_t            mask1_word2;        //  0x4030
+    RXMAC_WOL_MASK_t            mask1_word3;        //  0x4034
+    RXMAC_WOL_MASK_t            mask2_word0;        //  0x4038
+    RXMAC_WOL_MASK_t            mask2_word1;        //  0x403C
+    RXMAC_WOL_MASK_t            mask2_word2;        //  0x4040
+    RXMAC_WOL_MASK_t            mask2_word3;        //  0x4044
+    RXMAC_WOL_MASK_t            mask3_word0;        //  0x4048
+    RXMAC_WOL_MASK_t            mask3_word1;        //  0x404C
+    RXMAC_WOL_MASK_t            mask3_word2;        //  0x4050
+    RXMAC_WOL_MASK_t            mask3_word3;        //  0x4054
+    RXMAC_WOL_MASK_t            mask4_word0;        //  0x4058
+    RXMAC_WOL_MASK_t            mask4_word1;        //  0x405C
+    RXMAC_WOL_MASK_t            mask4_word2;        //  0x4060
+    RXMAC_WOL_MASK_t            mask4_word3;        //  0x4064
+    RXMAC_UNI_PF_ADDR1_t        uni_pf_addr1;       //  0x4068
+    RXMAC_UNI_PF_ADDR2_t        uni_pf_addr2;       //  0x406C
+    RXMAC_UNI_PF_ADDR3_t        uni_pf_addr3;       //  0x4070
+    RXMAC_MULTI_HASH_t          multi_hash1;        //  0x4074
+    RXMAC_MULTI_HASH_t          multi_hash2;        //  0x4078
+    RXMAC_MULTI_HASH_t          multi_hash3;        //  0x407C
+    RXMAC_MULTI_HASH_t          multi_hash4;        //  0x4080
+    RXMAC_PF_CTRL_t             pf_ctrl;            //  0x4084
+    RXMAC_MCIF_CTRL_MAX_SEG_t   mcif_ctrl_max_seg;  //  0x4088
+    RXMAC_MCIF_WATER_MARK_t     mcif_water_mark;    //  0x408C
+    RXMAC_RXQ_DIAG_t            rxq_diag;           //  0x4090
+    RXMAC_SPACE_AVAIL_t         space_avail;        //  0x4094
+
+    RXMAC_MIF_CTL_t             mif_ctrl;           //  0x4098
+    RXMAC_ERROR_REG_t           err_reg;            //  0x409C
+}
+RXMAC_t, *PRXMAC_t;
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                  END OF TXMAC REGISTER ADDRESS MAP                  ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+
+
+
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                  START OF MAC REGISTER ADDRESS MAP                  ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+/******************************************************************************
+   structure for configuration #1 reg in mac address map.
+   located at address 0x5000
+ *****************************************************************************/
+typedef union _MAC_CFG1_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 soft_reset:1;                        //bit 31
+        UINT32 sim_reset:1;                         //bit 30
+        UINT32 reserved3:10;                        //bits 20-29
+        UINT32 reset_rx_mc:1;                       //bit 19
+        UINT32 reset_tx_mc:1;                       //bit 18
+        UINT32 reset_rx_fun:1;                      //bit 17
+        UINT32 reset_tx_fun:1;                      //bit 16
+        UINT32 reserved2:7;                         //bits 9-15
+        UINT32 loop_back:1;                         //bit 8
+        UINT32 reserved1:2;                         //bits 6-7
+        UINT32 rx_flow:1;                           //bit 5
+        UINT32 tx_flow:1;                           //bit 4
+        UINT32 syncd_rx_en:1;                       //bit 3
+        UINT32 rx_enable:1;                         //bit 2
+        UINT32 syncd_tx_en:1;                       //bit 1
+        UINT32 tx_enable:1;                         //bit 0
+    #else
+        UINT32 tx_enable:1;                         //bit 0
+        UINT32 syncd_tx_en:1;                       //bit 1
+        UINT32 rx_enable:1;                         //bit 2
+        UINT32 syncd_rx_en:1;                       //bit 3
+        UINT32 tx_flow:1;                           //bit 4
+        UINT32 rx_flow:1;                           //bit 5
+        UINT32 reserved1:2;                         //bits 6-7
+        UINT32 loop_back:1;                         //bit 8
+        UINT32 reserved2:7;                         //bits 9-15
+        UINT32 reset_tx_fun:1;                      //bit 16
+        UINT32 reset_rx_fun:1;                      //bit 17
+        UINT32 reset_tx_mc:1;                       //bit 18
+        UINT32 reset_rx_mc:1;                       //bit 19
+        UINT32 reserved3:10;                        //bits 20-29
+        UINT32 sim_reset:1;                         //bit 30
+        UINT32 soft_reset:1;                        //bit 31
+    #endif
+    } bits;
+}
+MAC_CFG1_t, *PMAC_CFG1_t;
+
+
+/******************************************************************************
+   structure for configuration #2 reg in mac address map.
+   located at address 0x5004
+ *****************************************************************************/
+typedef union _MAC_CFG2_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved3:16;                        //bits 16-31
+        UINT32 preamble_len:4;                      //bits 12-15
+        UINT32 reserved2:2;                         //bits 10-11
+        UINT32 if_mode:2;                           //bits 8-9
+        UINT32 reserved1:2;                         //bits 6-7
+        UINT32 huge_frame:1;                        //bit 5
+        UINT32 len_check:1;                         //bit 4
+        UINT32 undefined:1;                         //bit 3
+        UINT32 pad_crc:1;                           //bit 2
+        UINT32 crc_enable:1;                        //bit 1
+        UINT32 full_duplex:1;                       //bit 0
+    #else
+        UINT32 full_duplex:1;                       //bit 0
+        UINT32 crc_enable:1;                        //bit 1
+        UINT32 pad_crc:1;                           //bit 2
+        UINT32 undefined:1;                         //bit 3
+        UINT32 len_check:1;                         //bit 4
+        UINT32 huge_frame:1;                        //bit 5
+        UINT32 reserved1:2;                         //bits 6-7
+        UINT32 if_mode:2;                           //bits 8-9
+        UINT32 reserved2:2;                         //bits 10-11
+        UINT32 preamble_len:4;                      //bits 12-15
+        UINT32 reserved3:16;                        //bits 16-31
+    #endif
+    } bits;
+}
+MAC_CFG2_t, *PMAC_CFG2_t;
+
+
+/******************************************************************************
+   structure for Interpacket gap reg in mac address map.
+   located at address 0x5008
+ *****************************************************************************/
+typedef union _MAC_IPG_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:1;                          //bit 31
+        UINT32 non_B2B_ipg_1:7;                     //bits 24-30
+        UINT32 undefined2:1;                        //bit 23
+        UINT32 non_B2B_ipg_2:7;                     //bits 16-22
+        UINT32 min_ifg_enforce:8;                   //bits 8-15
+        UINT32 undefined1:1;                        //bit 7
+        UINT32 B2B_ipg:7;                           //bits 0-6
+    #else
+        UINT32 B2B_ipg:7;                           //bits 0-6
+        UINT32 undefined1:1;                        //bit 7
+        UINT32 min_ifg_enforce:8;                   //bits 8-15
+        UINT32 non_B2B_ipg_2:7;                     //bits 16-22
+        UINT32 undefined2:1;                        //bit 23
+        UINT32 non_B2B_ipg_1:7;                     //bits 24-30
+        UINT32 reserved:1;                          //bit 31
+    #endif
+    } bits;
+}
+MAC_IPG_t, *PMAC_IPG_t;
+
+
+/******************************************************************************
+   structure for half duplex reg in mac address map.
+   located at address 0x500C
+ *****************************************************************************/
+typedef union _MAC_HFDP_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved2:8;                         //bits 24-31
+        UINT32 alt_beb_trunc:4;                     //bits 23-20
+        UINT32 alt_beb_enable:1;                    //bit 19
+        UINT32 bp_no_backoff:1;                     //bit 18
+        UINT32 no_backoff:1;                        //bit 17
+        UINT32 excess_defer:1;                      //bit 16
+        UINT32 rexmit_max:4;                        //bits 12-15
+        UINT32 reserved1:2;                         //bits 10-11
+        UINT32 coll_window:10;                      //bits 0-9
+    #else
+        UINT32 coll_window:10;                      //bits 0-9
+        UINT32 reserved1:2;                         //bits 10-11
+        UINT32 rexmit_max:4;                        //bits 12-15
+        UINT32 excess_defer:1;                      //bit 16
+        UINT32 no_backoff:1;                        //bit 17
+        UINT32 bp_no_backoff:1;                     //bit 18
+        UINT32 alt_beb_enable:1;                    //bit 19
+        UINT32 alt_beb_trunc:4;                     //bits 23-20
+        UINT32 reserved2:8;                         //bits 24-31
+    #endif
+    } bits;
+}
+MAC_HFDP_t, *PMAC_HFDP_t;
+
+
+/******************************************************************************
+   structure for Maximum Frame Length reg in mac address map.
+   located at address 0x5010
+ *****************************************************************************/
+typedef union _MAC_MAX_FM_LEN_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:16;                         //bits 16-31
+        UINT32 max_len:16;                          //bits 0-15
+    #else
+        UINT32 max_len:16;                          //bits 0-15
+        UINT32 reserved:16;                         //bits 16-31
+    #endif
+    } bits;
+}
+MAC_MAX_FM_LEN_t, *PMAC_MAX_FM_LEN_t;
+
+
+/******************************************************************************
+   structure for Reserve 1 reg in mac address map.
+   located at address 0x5014 - 0x5018
+ *****************************************************************************/
+typedef struct _MAC_RSV_t
+{
+    UINT32 value;                                   //bits 0-31
+}
+MAC_RSV_t, *PMAC_RSV_t;
+
+
+/******************************************************************************
+   structure for Test reg in mac address map.
+   located at address 0x501C
+ *****************************************************************************/
+typedef union _MAC_TEST_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:29;                           //bits 3-31
+        UINT32 mac_test:3;                          //bits 0-2
+    #else
+        UINT32 mac_test:3;                          //bits 0-2
+        UINT32 unused:29;                           //bits 3-31
+    #endif
+    } bits;
+}
+MAC_TEST_t, *PMAC_TEST_t;
+
+
+/******************************************************************************
+   structure for MII Management Configuration reg in mac address map.
+   located at address 0x5020
+ *****************************************************************************/
+typedef union _MII_MGMT_CFG_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reset_mii_mgmt:1;                    //bit 31
+        UINT32 reserved:25;                         //bits 6-30
+        UINT32 scan_auto_incremt:1;                 //bit 5
+        UINT32 preamble_suppress:1;                 //bit 4
+        UINT32 undefined:1;                         //bit 3
+        UINT32 mgmt_clk_reset:3;                    //bits 0-2
+    #else
+        UINT32 mgmt_clk_reset:3;                    //bits 0-2
+        UINT32 undefined:1;                         //bit 3
+        UINT32 preamble_suppress:1;                 //bit 4
+        UINT32 scan_auto_incremt:1;                 //bit 5
+        UINT32 reserved:25;                         //bits 6-30
+        UINT32 reset_mii_mgmt:1;                    //bit 31
+    #endif
+    } bits;
+}
+MII_MGMT_CFG_t, *PMII_MGMT_CFG_t;
+
+
+/******************************************************************************
+   structure for MII Management Command reg in mac address map.
+   located at address 0x5024
+ *****************************************************************************/
+typedef union _MII_MGMT_CMD_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:30;                         //bits 2-31
+        UINT32 scan_cycle:1;                        //bit 1
+        UINT32 read_cycle:1;                        //bit 0
+    #else
+        UINT32 read_cycle:1;                        //bit 0
+        UINT32 scan_cycle:1;                        //bit 1
+        UINT32 reserved:30;                         //bits 2-31
+    #endif
+    } bits;
+}
+MII_MGMT_CMD_t, *PMII_MGMT_CMD_t;
+
+
+/******************************************************************************
+   structure for MII Management Address reg in mac address map.
+   located at address 0x5028
+ *****************************************************************************/
+typedef union _MII_MGMT_ADDR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved2:19;                        //bit 13-31
+        UINT32 phy_addr:5;                          //bits 8-12
+        UINT32 reserved1:3;                         //bits 5-7
+        UINT32 reg_addr:5;                          //bits 0-4
+    #else
+        UINT32 reg_addr:5;                          //bits 0-4
+        UINT32 reserved1:3;                         //bits 5-7
+        UINT32 phy_addr:5;                          //bits 8-12
+        UINT32 reserved2:19;                        //bit 13-31
+    #endif
+    } bits;
+}
+MII_MGMT_ADDR_t, *PMII_MGMT_ADDR_t;
+
+
+/******************************************************************************
+   structure for MII Management Control reg in mac address map.
+   located at address 0x502C
+ *****************************************************************************/
+typedef union _MII_MGMT_CTRL_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:16;                         //bits 16-31
+        UINT32 phy_ctrl:16;                         //bits 0-15
+    #else
+        UINT32 phy_ctrl:16;                         //bits 0-15
+        UINT32 reserved:16;                         //bits 16-31
+    #endif
+    } bits;
+}
+MII_MGMT_CTRL_t, *PMII_MGMT_CTRL_t;
+
+
+/******************************************************************************
+   structure for MII Management Status reg in mac address map.
+   located at address 0x5030
+ *****************************************************************************/
+typedef union _MII_MGMT_STAT_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:16;                         //bits 16-31
+        UINT32 phy_stat:16;                         //bits 0-15
+    #else
+        UINT32 phy_stat:16;                         //bits 0-15
+        UINT32 reserved:16;                         //bits 16-31
+    #endif
+    } bits;
+}
+MII_MGMT_STAT_t, *PMII_MGMT_STAT_t;
+
+
+/******************************************************************************
+   structure for MII Management Indicators reg in mac address map.
+   located at address 0x5034
+ *****************************************************************************/
+typedef union _MII_MGMT_INDICATOR_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:29;                         //bits 3-31
+        UINT32 not_valid:1;                         //bit 2
+        UINT32 scanning:1;                          //bit 1
+        UINT32 busy:1;                              //bit 0
+    #else
+        UINT32 busy:1;                              //bit 0
+        UINT32 scanning:1;                          //bit 1
+        UINT32 not_valid:1;                         //bit 2
+        UINT32 reserved:29;                         //bits 3-31
+    #endif
+    } bits;
+}
+MII_MGMT_INDICATOR_t, *PMII_MGMT_INDICATOR_t;
+
+
+/******************************************************************************
+   structure for Interface Control reg in mac address map.
+   located at address 0x5038
+ *****************************************************************************/
+typedef union _MAC_IF_CTRL_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reset_if_module:1;                   //bit 31
+        UINT32 reserved4:3;                         //bit 28-30
+        UINT32 tbi_mode:1;                          //bit 27
+        UINT32 ghd_mode:1;                          //bit 26
+        UINT32 lhd_mode:1;                          //bit 25
+        UINT32 phy_mode:1;                          //bit 24
+        UINT32 reset_per_mii:1;                     //bit 23
+        UINT32 reserved3:6;                         //bits 17-22
+        UINT32 speed:1;                             //bit 16
+        UINT32 reset_pe100x:1;                      //bit 15
+        UINT32 reserved2:4;                         //bits 11-14
+        UINT32 force_quiet:1;                       //bit 10
+        UINT32 no_cipher:1;                         //bit 9
+        UINT32 disable_link_fail:1;                 //bit 8
+        UINT32 reset_gpsi:1;                        //bit 7
+        UINT32 reserved1:6;                         //bits 1-6
+        UINT32 enab_jab_protect:1;                  //bit 0
+    #else
+        UINT32 enab_jab_protect:1;                  //bit 0
+        UINT32 reserved1:6;                         //bits 1-6
+        UINT32 reset_gpsi:1;                        //bit 7
+        UINT32 disable_link_fail:1;                 //bit 8
+        UINT32 no_cipher:1;                         //bit 9
+        UINT32 force_quiet:1;                       //bit 10
+        UINT32 reserved2:4;                         //bits 11-14
+        UINT32 reset_pe100x:1;                      //bit 15
+        UINT32 speed:1;                             //bit 16
+        UINT32 reserved3:6;                         //bits 17-22
+        UINT32 reset_per_mii:1;                     //bit 23
+        UINT32 phy_mode:1;                          //bit 24
+        UINT32 lhd_mode:1;                          //bit 25
+        UINT32 ghd_mode:1;                          //bit 26
+        UINT32 tbi_mode:1;                          //bit 27
+        UINT32 reserved4:3;                         //bit 28-30
+        UINT32 reset_if_module:1;                   //bit 31
+    #endif
+    } bits;
+}
+MAC_IF_CTRL_t, *PMAC_IF_CTRL_t;
+
+
+/******************************************************************************
+   structure for Interface Status reg in mac address map.
+   located at address 0x503C
+ *****************************************************************************/
+typedef union _MAC_IF_STAT_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:22;                         //bits 10-31
+        UINT32 excess_defer:1;                      //bit 9
+        UINT32 clash:1;                             //bit 8
+        UINT32 phy_jabber:1;                        //bit 7
+        UINT32 phy_link_ok:1;                       //bit 6
+        UINT32 phy_full_duplex:1;                   //bit 5
+        UINT32 phy_speed:1;                         //bit 4
+        UINT32 pe100x_link_fail:1;                  //bit 3
+        UINT32 pe10t_loss_carrie:1;                 //bit 2
+        UINT32 pe10t_sqe_error:1;                   //bit 1
+        UINT32 pe10t_jabber:1;                      //bit 0
+    #else
+        UINT32 pe10t_jabber:1;                      //bit 0
+        UINT32 pe10t_sqe_error:1;                   //bit 1
+        UINT32 pe10t_loss_carrie:1;                 //bit 2
+        UINT32 pe100x_link_fail:1;                  //bit 3
+        UINT32 phy_speed:1;                         //bit 4
+        UINT32 phy_full_duplex:1;                   //bit 5
+        UINT32 phy_link_ok:1;                       //bit 6
+        UINT32 phy_jabber:1;                        //bit 7
+        UINT32 clash:1;                             //bit 8
+        UINT32 excess_defer:1;                      //bit 9
+        UINT32 reserved:22;                         //bits 10-31
+    #endif
+    } bits;
+}
+MAC_IF_STAT_t, *PMAC_IF_STAT_t;
+
+
+/******************************************************************************
+   structure for Mac Station Address, Part 1 reg in mac address map.
+   located at address 0x5040
+ *****************************************************************************/
+typedef union _MAC_STATION_ADDR1_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 Octet6:8;                            //bits 24-31
+        UINT32 Octet5:8;                            //bits 16-23
+        UINT32 Octet4:8;                            //bits 8-15
+        UINT32 Octet3:8;                            //bits 0-7
+    #else
+        UINT32 Octet3:8;                            //bits 0-7
+        UINT32 Octet4:8;                            //bits 8-15
+        UINT32 Octet5:8;                            //bits 16-23
+        UINT32 Octet6:8;                            //bits 24-31
+    #endif
+    } bits;
+}
+MAC_STATION_ADDR1_t, *PMAC_STATION_ADDR1_t;
+
+
+/******************************************************************************
+   structure for Mac Station Address, Part 2 reg in mac address map.
+   located at address 0x5044
+ *****************************************************************************/
+typedef union _MAC_STATION_ADDR2_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 Octet2:8;                            //bits 24-31
+        UINT32 Octet1:8;                            //bits 16-23
+        UINT32 reserved:16;                         //bits 0-15
+    #else
+        UINT32 reserved:16;                         //bit 0-15
+        UINT32 Octet1:8;                            //bits 16-23
+        UINT32 Octet2:8;                            //bits 24-31
+    #endif
+    } bits;
+}
+MAC_STATION_ADDR2_t, *PMAC_STATION_ADDR2_t;
+
+
+/******************************************************************************
+   MAC Module of JAGCore Address Mapping
+ *****************************************************************************/
+typedef struct _MAC_t
+{                                                   //Location:
+    MAC_CFG1_t                  cfg1;               //  0x5000
+    MAC_CFG2_t                  cfg2;               //  0x5004
+    MAC_IPG_t                   ipg;                //  0x5008
+    MAC_HFDP_t                  hfdp;               //  0x500C
+    MAC_MAX_FM_LEN_t            max_fm_len;         //  0x5010
+    MAC_RSV_t                   rsv1;               //  0x5014
+    MAC_RSV_t                   rsv2;               //  0x5018
+    MAC_TEST_t                  mac_test;           //  0x501C
+    MII_MGMT_CFG_t              mii_mgmt_cfg;       //  0x5020
+    MII_MGMT_CMD_t              mii_mgmt_cmd;       //  0x5024
+    MII_MGMT_ADDR_t             mii_mgmt_addr;      //  0x5028
+    MII_MGMT_CTRL_t             mii_mgmt_ctrl;      //  0x502C
+    MII_MGMT_STAT_t             mii_mgmt_stat;      //  0x5030
+    MII_MGMT_INDICATOR_t        mii_mgmt_indicator; //  0x5034
+    MAC_IF_CTRL_t               if_ctrl;            //  0x5038
+    MAC_IF_STAT_t               if_stat;            //  0x503C
+    MAC_STATION_ADDR1_t         station_addr_1;     //  0x5040
+    MAC_STATION_ADDR2_t         station_addr_2;     //  0x5044
+}
+MAC_t, *PMAC_t;
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                   END OF MAC REGISTER ADDRESS MAP                   ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+
+
+
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                START OF MAC STAT REGISTER ADDRESS MAP               ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+/******************************************************************************
+   structure for Carry Register One and it's Mask Register reg located in mac
+   stat address map address 0x6130 and 0x6138.
+ *****************************************************************************/
+typedef union _MAC_STAT_REG_1_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 tr64:1;                              //bit 31
+        UINT32 tr127:1;                             //bit 30
+        UINT32 tr255:1;                             //bit 29
+        UINT32 tr511:1;                             //bit 28
+        UINT32 tr1k:1;                              //bit 27
+        UINT32 trmax:1;                             //bit 26
+        UINT32 trmgv:1;                             //bit 25
+        UINT32 unused:8;                            //bits 17-24
+        UINT32 rbyt:1;                             //bit 16
+        UINT32 rpkt:1;                             //bit 15
+        UINT32 rfcs:1;                             //bit 14
+        UINT32 rmca:1;                             //bit 13
+        UINT32 rbca:1;                             //bit 12
+        UINT32 rxcf:1;                             //bit 11
+        UINT32 rxpf:1;                             //bit 10
+        UINT32 rxuo:1;                             //bit 9
+        UINT32 raln:1;                             //bit 8
+        UINT32 rflr:1;                             //bit 7
+        UINT32 rcde:1;                             //bit 6
+        UINT32 rcse:1;                             //bit 5
+        UINT32 rund:1;                             //bit 4
+        UINT32 rovr:1;                             //bit 3
+        UINT32 rfrg:1;                             //bit 2
+        UINT32 rjbr:1;                             //bit 1
+        UINT32 rdrp:1;                             //bit 0
+    #else
+        UINT32 rdrp:1;                             //bit 0
+        UINT32 rjbr:1;                             //bit 1
+        UINT32 rfrg:1;                             //bit 2
+        UINT32 rovr:1;                             //bit 3
+        UINT32 rund:1;                             //bit 4
+        UINT32 rcse:1;                             //bit 5
+        UINT32 rcde:1;                             //bit 6
+        UINT32 rflr:1;                             //bit 7
+        UINT32 raln:1;                             //bit 8
+        UINT32 rxuo:1;                             //bit 9
+        UINT32 rxpf:1;                             //bit 10
+        UINT32 rxcf:1;                             //bit 11
+        UINT32 rbca:1;                             //bit 12
+        UINT32 rmca:1;                             //bit 13
+        UINT32 rfcs:1;                             //bit 14
+        UINT32 rpkt:1;                             //bit 15
+        UINT32 rbyt:1;                             //bit 16
+        UINT32 unused:8;                            //bits 17-24
+        UINT32 trmgv:1;                             //bit 25
+        UINT32 trmax:1;                             //bit 26
+        UINT32 tr1k:1;                              //bit 27
+        UINT32 tr511:1;                             //bit 28
+        UINT32 tr255:1;                             //bit 29
+        UINT32 tr127:1;                             //bit 30
+        UINT32 tr64:1;                              //bit 31
+    #endif
+    } bits;
+}
+MAC_STAT_REG_1_t, *PMAC_STAT_REG_1_t;
+
+
+/******************************************************************************
+   structure for Carry Register Two Mask Register reg in mac stat address map.
+   located at address 0x613C
+ *****************************************************************************/
+typedef union _MAC_STAT_REG_2_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:12;                           //bit 20-31
+        UINT32 tjbr:1;                             //bit 19
+        UINT32 tfcs:1;                             //bit 18
+        UINT32 txcf:1;                             //bit 17
+        UINT32 tovr:1;                             //bit 16
+        UINT32 tund:1;                             //bit 15
+        UINT32 tfrg:1;                             //bit 14
+        UINT32 tbyt:1;                             //bit 13
+        UINT32 tpkt:1;                             //bit 12
+        UINT32 tmca:1;                             //bit 11
+        UINT32 tbca:1;                             //bit 10
+        UINT32 txpf:1;                             //bit 9
+        UINT32 tdfr:1;                             //bit 8
+        UINT32 tedf:1;                             //bit 7
+        UINT32 tscl:1;                             //bit 6
+        UINT32 tmcl:1;                             //bit 5
+        UINT32 tlcl:1;                             //bit 4
+        UINT32 txcl:1;                             //bit 3
+        UINT32 tncl:1;                             //bit 2
+        UINT32 tpfh:1;                             //bit 1
+        UINT32 tdrp:1;                             //bit 0
+    #else
+        UINT32 tdrp:1;                             //bit 0
+        UINT32 tpfh:1;                             //bit 1
+        UINT32 tncl:1;                             //bit 2
+        UINT32 txcl:1;                             //bit 3
+        UINT32 tlcl:1;                             //bit 4
+        UINT32 tmcl:1;                             //bit 5
+        UINT32 tscl:1;                             //bit 6
+        UINT32 tedf:1;                             //bit 7
+        UINT32 tdfr:1;                             //bit 8
+        UINT32 txpf:1;                             //bit 9
+        UINT32 tbca:1;                             //bit 10
+        UINT32 tmca:1;                             //bit 11
+        UINT32 tpkt:1;                             //bit 12
+        UINT32 tbyt:1;                             //bit 13
+        UINT32 tfrg:1;                             //bit 14
+        UINT32 tund:1;                             //bit 15
+        UINT32 tovr:1;                             //bit 16
+        UINT32 txcf:1;                             //bit 17
+        UINT32 tfcs:1;                             //bit 18
+        UINT32 tjbr:1;                             //bit 19
+        UINT32 unused:12;                         //bit 20-31
+    #endif
+    } bits;
+}
+MAC_STAT_REG_2_t, *PMAC_STAT_REG_2_t;
+
+
+
+
+/******************************************************************************
+   MAC STATS Module of JAGCore Address Mapping
+ *****************************************************************************/
+typedef struct _MAC_STAT_t
+{                                                   //Location:
+    UINT32 pad[32];                                 //  0x6000 - 607C
+
+    //Tx/Rx 0-64 Byte Frame Counter
+    UINT32 TR64;                                    //  0x6080
+
+    //Tx/Rx 65-127 Byte Frame Counter
+    UINT32 TR127;                                   //  0x6084
+
+    //Tx/Rx 128-255 Byte Frame Counter
+    UINT32 TR255;                                   //  0x6088
+
+    //Tx/Rx 256-511 Byte Frame Counter
+    UINT32 TR511;                                   //  0x608C
+
+    //Tx/Rx 512-1023 Byte Frame Counter
+    UINT32 TR1K;                                    //  0x6090
+
+    //Tx/Rx 1024-1518 Byte Frame Counter
+    UINT32 TRMax;                                   //  0x6094
+
+    //Tx/Rx 1519-1522 Byte Good VLAN Frame Count
+    UINT32 TRMgv;                                   //  0x6098
+
+    //Rx Byte Counter
+    UINT32 RByt;                                    //  0x609C
+
+    //Rx Packet Counter
+    UINT32 RPkt;                                    //  0x60A0
+
+    //Rx FCS Error Counter
+    UINT32 RFcs;                                    //  0x60A4
+
+    //Rx Multicast Packet Counter
+    UINT32 RMca;                                    //  0x60A8
+
+    //Rx Broadcast Packet Counter
+    UINT32 RBca;                                    //  0x60AC
+
+    //Rx Control Frame Packet Counter
+    UINT32 RxCf;                                    //  0x60B0
+
+    //Rx Pause Frame Packet Counter
+    UINT32 RxPf;                                    //  0x60B4
+
+    //Rx Unknown OP Code Counter
+    UINT32 RxUo;                                    //  0x60B8
+
+    //Rx Alignment Error Counter
+    UINT32 RAln;                                    //  0x60BC
+
+    //Rx Frame Length Error Counter
+    UINT32 RFlr;                                    //  0x60C0
+
+    //Rx Code Error Counter
+    UINT32 RCde;                                    //  0x60C4
+
+    //Rx Carrier Sense Error Counter
+    UINT32 RCse;                                    //  0x60C8
+
+    //Rx Undersize Packet Counter
+    UINT32 RUnd;                                    //  0x60CC
+
+    //Rx Oversize Packet Counter
+    UINT32 ROvr;                                    //  0x60D0
+
+    //Rx Fragment Counter
+    UINT32 RFrg;                                    //  0x60D4
+
+    //Rx Jabber Counter
+    UINT32 RJbr;                                    //  0x60D8
+
+    //Rx Drop
+    UINT32 RDrp;                                    //  0x60DC
+
+    //Tx Byte Counter
+    UINT32 TByt;                                    //  0x60E0
+
+    //Tx Packet Counter
+    UINT32 TPkt;                                    //  0x60E4
+
+    //Tx Multicast Packet Counter
+    UINT32 TMca;                                    //  0x60E8
+
+    //Tx Broadcast Packet Counter
+    UINT32 TBca;                                    //  0x60EC
+
+    //Tx Pause Control Frame Counter
+    UINT32 TxPf;                                    //  0x60F0
+
+    //Tx Deferral Packet Counter
+    UINT32 TDfr;                                    //  0x60F4
+
+    //Tx Excessive Deferral Packet Counter
+    UINT32 TEdf;                                    //  0x60F8
+
+    //Tx Single Collision Packet Counter
+    UINT32 TScl;                                    //  0x60FC
+
+    //Tx Multiple Collision Packet Counter
+    UINT32 TMcl;                                    //  0x6100
+
+    //Tx Late Collision Packet Counter
+    UINT32 TLcl;                                    //  0x6104
+
+    //Tx Excessive Collision Packet Counter
+    UINT32 TXcl;                                    //  0x6108
+
+    //Tx Total Collision Packet Counter
+    UINT32 TNcl;                                    //  0x610C
+
+    //Tx Pause Frame Honored Counter
+    UINT32 TPfh;                                    //  0x6110
+
+    //Tx Drop Frame Counter
+    UINT32 TDrp;                                    //  0x6114
+
+    //Tx Jabber Frame Counter
+    UINT32 TJbr;                                    //  0x6118
+
+    //Tx FCS Error Counter
+    UINT32 TFcs;                                    //  0x611C
+
+    //Tx Control Frame Counter
+    UINT32 TxCf;                                    //  0x6120
+
+    //Tx Oversize Frame Counter
+    UINT32 TOvr;                                    //  0x6124
+
+    //Tx Undersize Frame Counter
+    UINT32 TUnd;                                    //  0x6128
+
+    //Tx Fragments Frame Counter
+    UINT32 TFrg;                                    //  0x612C
+
+    //Carry Register One Register
+    MAC_STAT_REG_1_t Carry1;                        //  0x6130
+
+    //Carry Register Two Register
+    MAC_STAT_REG_2_t Carry2;                           //  0x6134
+
+    //Carry Register One Mask Register
+    MAC_STAT_REG_1_t Carry1M;                       //  0x6138
+
+    //Carry Register Two Mask Register
+    MAC_STAT_REG_2_t Carry2M;                       //  0x613C
+}
+MAC_STAT_t, *PMAC_STAT_t;
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                END OF MAC STAT REGISTER ADDRESS MAP                 ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+
+
+
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                  START OF MMC REGISTER ADDRESS MAP                  ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+/******************************************************************************
+   structure for Main Memory Controller Control reg in mmc address map.
+   located at address 0x7000
+ *****************************************************************************/
+typedef union _MMC_CTRL_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:25;                         //bits 7-31
+        UINT32 force_ce:1;                          //bit 6
+        UINT32 rxdma_disable:1;                     //bit 5
+        UINT32 txdma_disable:1;                     //bit 4
+        UINT32 txmac_disable:1;                     //bit 3
+        UINT32 rxmac_disable:1;                     //bit 2
+        UINT32 arb_disable:1;                       //bit 1
+        UINT32 mmc_enable:1;                        //bit 0
+    #else
+        UINT32 mmc_enable:1;                        //bit 0
+        UINT32 arb_disable:1;                       //bit 1
+        UINT32 rxmac_disable:1;                     //bit 2
+        UINT32 txmac_disable:1;                     //bit 3
+        UINT32 txdma_disable:1;                     //bit 4
+        UINT32 rxdma_disable:1;                     //bit 5
+        UINT32 force_ce:1;                          //bit 6
+        UINT32 reserved:25;                         //bits 7-31
+    #endif
+    } bits;
+}
+MMC_CTRL_t, *PMMC_CTRL_t;
+
+
+/******************************************************************************
+   structure for Main Memory Controller Host Memory Access Address reg in mmc
+   address map.  Located at address 0x7004
+ *****************************************************************************/
+typedef union _MMC_SRAM_ACCESS_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 byte_enable:16;                      //bits 16-31
+        UINT32 reserved2:2;                         //bits 14-15
+        UINT32 req_addr:10;                         //bits 4-13
+        UINT32 reserved1:1;                         //bit 3
+        UINT32 is_ctrl_word:1;                      //bit 2
+        UINT32 wr_access:1;                         //bit 1
+        UINT32 req_access:1;                        //bit 0
+    #else
+        UINT32 req_access:1;                        //bit 0
+        UINT32 wr_access:1;                         //bit 1
+        UINT32 is_ctrl_word:1;                      //bit 2
+        UINT32 reserved1:1;                         //bit 3
+        UINT32 req_addr:10;                         //bits 4-13
+        UINT32 reserved2:2;                         //bits 14-15
+        UINT32 byte_enable:16;                      //bits 16-31
+    #endif
+    } bits;
+}
+MMC_SRAM_ACCESS_t, *PMMC_SRAM_ACCESS_t;
+
+
+/******************************************************************************
+   structure for Main Memory Controller Host Memory Access Data reg in mmc
+   address map.  Located at address 0x7008 - 0x7014
+ *****************************************************************************/
+typedef struct _MMC_SRAM_WORD_t
+{
+    UINT32 data;                                    //bits 0-31
+} MMC_SRAM_WORD_t, *PMMC_SRAM_WORD_t;
+
+
+/******************************************************************************
+   Memory Control Module of JAGCore Address Mapping
+ *****************************************************************************/
+typedef struct _MMC_t
+{                                                   //Location:
+    MMC_CTRL_t          mmc_ctrl;                   //  0x7000
+    MMC_SRAM_ACCESS_t   sram_access;                //  0x7004
+    MMC_SRAM_WORD_t     sram_word1;                 //  0x7008
+    MMC_SRAM_WORD_t     sram_word2;                 //  0x700C
+    MMC_SRAM_WORD_t     sram_word3;                 //  0x7010
+    MMC_SRAM_WORD_t     sram_word4;                 //  0x7014
+}
+MMC_t, *PMMC_t;
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                   END OF MMC REGISTER ADDRESS MAP                   ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+
+
+
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                START OF EXP ROM REGISTER ADDRESS MAP                ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+/******************************************************************************
+   Expansion ROM Module of JAGCore Address Mapping
+ *****************************************************************************/
+
+/* Take this out until it is not empty */
+#if 0
+typedef struct _EXP_ROM_t
+{
+
+}
+EXP_ROM_t, *PEXP_ROM_t;
+#endif
+/*===========================================================================*/
+/*===========================================================================*/
+/*===                 END OF EXP ROM REGISTER ADDRESS MAP                 ===*/
+/*===========================================================================*/
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   JAGCore Address Mapping
+ *****************************************************************************/
+typedef struct _ADDRESS_MAP_t
+{
+    GLOBAL_t    global;
+    UCHAR       unused_global[4096 - sizeof (GLOBAL_t)];    //unused section of global address map
+    TXDMA_t     txdma;
+    UCHAR       unused_txdma[4096 - sizeof (TXDMA_t)];     //unused section of txdma address map
+    RXDMA_t     rxdma;
+    UCHAR       unused_rxdma[4096 - sizeof (RXDMA_t)];     //unused section of rxdma address map
+    TXMAC_t     txmac;
+    UCHAR       unused_txmac[4096 - sizeof (TXMAC_t)];     //unused section of txmac address map
+    RXMAC_t     rxmac;
+    UCHAR       unused_rxmac[4096 - sizeof (RXMAC_t)];     //unused section of rxmac address map
+    MAC_t       mac;
+    UCHAR       unused_mac[4096 - sizeof (MAC_t)];       //unused section of mac address map
+    MAC_STAT_t  macStat;
+    UCHAR       unused_mac_stat[4096 - sizeof (MAC_STAT_t)];  //unused section of mac stat address map
+    MMC_t       mmc;
+    UCHAR       unused_mmc[4096 - sizeof (MMC_t)];       //unused section of mmc address map
+    UCHAR       unused_[1015808];       //unused section of address map
+
+/* Take this out until it is not empty */
+#if 0
+    EXP_ROM_t   exp_rom;
+#endif
+
+    UCHAR       unused_exp_rom[4096];   //MGS-size TBD
+    UCHAR       unused__[524288];       //unused section of address map
+}
+ADDRESS_MAP_t, *PADDRESS_MAP_t;
+/*===========================================================================*/
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* _ET1310_ADDRESS_MAP_H_ */
--- /dev/null
+++ b/drivers/net/et131x/ET1310_common.h
@@ -0,0 +1,97 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310.h - Common defines, structs, enums, prototypes, etc.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:10 $
+     $Revision: 1.5 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET1310_COMMON_H__
+#define __ET1310_COMMON_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+
+/******************************************************************************
+   INCLUDES
+ *****************************************************************************/
+#include "ET1310_address_map.h"
+
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __ET1310_COMMON_H__ */
--- /dev/null
+++ b/drivers/net/et131x/ET1310_eeprom.c
@@ -0,0 +1,710 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_eeprom.c - Code used to access the device's EEPROM
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2006/01/18 22:18:33 $
+     $Revision: 1.6 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+#include "ET1310_eeprom.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_initpci.h"
+#include "et131x_isr.h"
+
+#include "ET1310_tx.h"
+
+
+
+
+/******************************************************************************
+   EEPROM Defines
+ *****************************************************************************/
+/* LBCIF Register Groups (addressed via 32-bit offsets) */
+#define LBCIF_DWORD0_GROUP_OFFSET       0xAC
+#define LBCIF_DWORD1_GROUP_OFFSET       0xB0
+
+/* LBCIF Registers (addressed via 8-bit offsets) */
+#define LBCIF_ADDRESS_REGISTER_OFFSET   0xAC
+#define LBCIF_DATA_REGISTER_OFFSET      0xB0
+#define LBCIF_CONTROL_REGISTER_OFFSET   0xB1
+#define LBCIF_STATUS_REGISTER_OFFSET    0xB2
+
+/* LBCIF Control Register Bits */
+#define LBCIF_CONTROL_SEQUENTIAL_READ   0x01
+#define LBCIF_CONTROL_PAGE_WRITE        0x02
+#define LBCIF_CONTROL_UNUSED1           0x04
+#define LBCIF_CONTROL_EEPROM_RELOAD     0x08
+#define LBCIF_CONTROL_UNUSED2           0x10
+#define LBCIF_CONTROL_TWO_BYTE_ADDR     0x20
+#define LBCIF_CONTROL_I2C_WRITE         0x40
+#define LBCIF_CONTROL_LBCIF_ENABLE      0x80
+
+/* LBCIF Status Register Bits */
+#define LBCIF_STATUS_PHY_QUEUE_AVAIL    0x01
+#define LBCIF_STATUS_I2C_IDLE           0x02
+#define LBCIF_STATUS_ACK_ERROR          0x04
+#define LBCIF_STATUS_GENERAL_ERROR      0x08
+#define LBCIF_STATUS_UNUSED             0x30
+#define LBCIF_STATUS_CHECKSUM_ERROR     0x40
+#define LBCIF_STATUS_EEPROM_PRESENT     0x80
+
+/* Miscellaneous Constraints */
+#define MAX_NUM_REGISTER_POLLS          1000
+#define MAX_NUM_WRITE_RETRIES           2
+
+
+
+
+/******************************************************************************
+   Define macros that allow individual register values to be extracted from a
+   DWORD1 register grouping
+ *****************************************************************************/
+#define EXTRACT_DATA_REGISTER(x)    (UCHAR)(x & 0xFF)
+#define EXTRACT_STATUS_REGISTER(x)  (UCHAR)((x >> 16) & 0xFF)
+#define EXTRACT_CONTROL_REG(x)      (UCHAR)((x >> 8) & 0xFF)
+
+
+
+
+static INT32 LbcifWriteByte( ET131X_ADAPTER *pAdapter, UINT32 unOffset, UCHAR bByte )
+{
+    return EEPROM_access( pAdapter, WRITE, unOffset, 8, &bByte );
+}
+
+
+static INT32 LbcifReadDword( ET131X_ADAPTER *pAdapter, UINT32 unOffset, PUINT32 punData )
+{
+    return EEPROM_access( pAdapter, READ, unOffset, 32, punData );
+}
+
+
+static INT32 LbcifWriteDword( ET131X_ADAPTER *pAdapter,UINT32 unOffset, UINT32 unData )
+{
+    return EEPROM_access( pAdapter, WRITE, unOffset, 32, &unData );
+}
+
+
+
+
+/******************************************************************************
+   ROUTINE :  EepromWriteByte
+ ******************************************************************************
+
+   DESCRIPTION       : Write a byte to the ET1310's EEPROM
+
+   PARAMETERS        : pAdapter         - pointer to our private adapter structure
+                       unAddress        - the address to write
+                       bData            - the value to write
+                       unEepronId       - the ID of the EEPROM
+                       unAddressingMode - how the EEPROM is to be accessed
+
+   RETURNS           : SUCCESS or FAILURE
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+INT32 EepromWriteByte( ET131X_ADAPTER *pAdapter, UINT32 unAddress, UCHAR bData,
+                       UINT32 unEepromId, UINT32 unAddressingMode )
+{
+    INT32  nIndex;
+    INT32  nRetries;
+    INT32  nError = FALSE;
+    INT32  nI2CWriteActive = 0;
+    INT32  nWriteSuccessful = 0;
+    UCHAR  bControl;
+    UCHAR  bStatus = 0;
+    UINT32 unDword1 = 0;
+
+    UINT32 unData = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    /**************************************************************************
+       The following excerpt is from "Serial EEPROM HW Design Specification"
+       Version 0.92 (9/20/2004):
+
+       Single Byte Writes
+
+       For an EEPROM, an I2C single byte write is defined as a START
+       condition followed by the device address, EEPROM address, one byte
+       of data and a STOP condition.  The STOP condition will trigger the
+       EEPROM's internally timed write cycle to the nonvolatile memory.
+       All inputs are disabled during this write cycle and the EEPROM will
+       not respond to any access until the internal write is complete.
+       The steps to execute a single byte write are as follows:
+
+       1. Check LBCIF Status Register for bits 6 & 3:2 all equal to 0 and
+          bits 7,1:0 both equal to 1, at least once after reset. Subsequent
+          operations need only to check that bits 1:0 are equal to 1 prior
+          to starting a single byte write.
+
+       2. Write to the LBCIF Control Register:  bit 7=1, bit 6=1, bit 3=0,
+          and bits 1:0 both =0.  Bit 5 should be set according to the type
+          of EEPROM being accessed (1=two byte addressing, 0=one byte
+          addressing).
+
+       3. Write the address to the LBCIF Address Register.
+
+       4. Write the data to the LBCIF Data Register (the I2C write will
+          begin).
+
+       5. Monitor bit 1:0 of the LBCIF Status Register.  When bits 1:0 are
+          both equal to 1, the I2C write has completed and the internal
+          write cycle of the EEPROM is about to start. (bits 1:0 = 01 is a
+          legal state while waiting from both equal to 1, but bits 1:0 = 10
+          is invalid and implies that something is broken).
+
+       6. Check bit 3 of the LBCIF Status Register.  If  equal to 1, an
+           error has occurred.
+
+       7. Check bit 2 of the LBCIF Status Register.  If equal to 1 an ACK
+          error has occurred on the address phase of the write.  This could
+          be due to an actual hardware failure or the EEPROM may still be in
+          its internal write cycle from a previous write.  This write oper-
+          ation was ignored and must be repeated later.
+
+       8. Set bit 6 of the LBCIF Control Register = 0. If another write is
+          required, go to step 1.
+     *************************************************************************/
+
+
+    /**************************************************************************
+       Step 1:
+     *************************************************************************/
+    for( nIndex = 0; nIndex < MAX_NUM_REGISTER_POLLS; nIndex++)
+    {
+        /**********************************************************************
+           Read registers grouped in DWORD1
+         *********************************************************************/
+        if( LbcifReadDword( pAdapter, LBCIF_DWORD1_GROUP_OFFSET, &unDword1 ))
+        {
+            nError = 1;
+            break;
+        }
+
+        bStatus = EXTRACT_STATUS_REGISTER( unDword1 );
+
+        if( bStatus & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
+            bStatus & LBCIF_STATUS_I2C_IDLE )
+        {
+            /******************************************************************
+               bits 1:0 are equal to 1
+             *****************************************************************/
+            break;
+        }
+    }
+
+    if( nError || ( nIndex >= MAX_NUM_REGISTER_POLLS ))
+    {
+        return( FAILURE );
+    }
+
+
+    /**************************************************************************
+       Step 2:
+     *************************************************************************/
+    bControl  = 0;
+    bControl |= LBCIF_CONTROL_LBCIF_ENABLE | LBCIF_CONTROL_I2C_WRITE;
+
+    if( unAddressingMode == DUAL_BYTE )
+    {
+        bControl |= LBCIF_CONTROL_TWO_BYTE_ADDR;
+    }
+
+    if( LbcifWriteByte( pAdapter, LBCIF_CONTROL_REGISTER_OFFSET, bControl ))
+    {
+        return( FAILURE );
+    }
+
+    nI2CWriteActive = 1;
+
+
+    /**************************************************************************
+       Prepare EEPROM address for Step 3
+     *************************************************************************/
+    unAddress |= ( unAddressingMode == DUAL_BYTE ) ?
+                 ( unEepromId << 16 ) : ( unEepromId << 8 );
+
+    for( nRetries = 0; nRetries < MAX_NUM_WRITE_RETRIES; nRetries++ )
+    {
+        /**********************************************************************
+           Step 3:
+         *********************************************************************/
+        if( LbcifWriteDword( pAdapter, LBCIF_ADDRESS_REGISTER_OFFSET, unAddress ))
+        {
+            break;
+        }
+
+        /**********************************************************************
+           Step 4:
+         *********************************************************************/
+        if( LbcifWriteByte( pAdapter, LBCIF_DATA_REGISTER_OFFSET, bData ))
+        {
+            break;
+        }
+
+        /**********************************************************************
+           Step 5:
+         *********************************************************************/
+        for( nIndex = 0; nIndex < MAX_NUM_REGISTER_POLLS; nIndex++ )
+        {
+            /******************************************************************
+               Read registers grouped in DWORD1
+             *****************************************************************/
+            if( LbcifReadDword( pAdapter, LBCIF_DWORD1_GROUP_OFFSET,
+                                &unDword1 ))
+            {
+                nError = 1;
+                break;
+            }
+
+            bStatus = EXTRACT_STATUS_REGISTER( unDword1 );
+
+            if( bStatus & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
+                bStatus & LBCIF_STATUS_I2C_IDLE )
+            {
+                /**************************************************************
+                   I2C write complete
+                 *************************************************************/
+                break;
+            }
+        }
+
+        if( nError || ( nIndex >= MAX_NUM_REGISTER_POLLS ))
+        {
+            break;
+        }
+
+
+        /**********************************************************************
+           Step 6:  Don't break here if we are revision 1, this is so we do a
+                    blind write for load bug.
+         *********************************************************************/
+        if( bStatus & LBCIF_STATUS_GENERAL_ERROR && pAdapter->RevisionID == 0 )
+        {
+            break;
+        }
+
+
+        /**********************************************************************
+           Step 7:
+         *********************************************************************/
+        if( bStatus & LBCIF_STATUS_ACK_ERROR )
+        {
+            /******************************************************************
+               This could be due to an actual hardware failure or the EEPROM
+               may still be in its internal write cycle from a previous write.
+               This write operation was ignored and must be repeated later.
+             *****************************************************************/
+            udelay( 10 );
+            continue;
+        }
+
+        nWriteSuccessful = 1;
+        break;
+    }
+
+
+    /**************************************************************************
+       Step 8:
+     *************************************************************************/
+    udelay( 10 );
+    nIndex = 0;
+    while( nI2CWriteActive )
+    {
+        bControl &= ~LBCIF_CONTROL_I2C_WRITE;
+
+        if( LbcifWriteByte( pAdapter, LBCIF_CONTROL_REGISTER_OFFSET, bControl ))
+        {
+            nWriteSuccessful = 0;
+        }
+
+        /* Do read until internal ACK_ERROR goes away meaning write completed */
+        for( ;; )
+        {
+            /* unAddress */
+            LbcifWriteDword( pAdapter, LBCIF_ADDRESS_REGISTER_OFFSET, unAddress );
+
+            for( ;; )
+            {
+                LbcifReadDword( pAdapter, LBCIF_DATA_REGISTER_OFFSET, &unData );
+
+                if( unData & 0x00010000 )
+                {
+                    break;
+                }
+            }
+
+            if(( unData & 0x00040000 ) == 0x0 )
+            {
+                break;
+            }
+        }
+
+        bControl = EXTRACT_CONTROL_REG( unData );
+
+        if( bControl != 0xC0 || nIndex == 10000 )
+        {
+            break;
+        }
+
+        nIndex++;
+    }
+
+    return(( nWriteSuccessful ) ? SUCCESS : FAILURE );
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  EepromReadByte
+ ******************************************************************************
+
+   DESCRIPTION       : Read a byte from the ET1310's EEPROM
+
+   PARAMETERS        : pAdapter         - pointer to our private adapter structure
+                       unAddress        - the address from which to read
+                       pbData           - a pointer to a byte in which to store the
+                                          value of the read
+                       unEepronId       - the ID of the EEPROM
+                       unAddressingMode - how the EEPROM is to be accessed
+
+   RETURNS           : SUCCESS or FAILURE
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+INT32 EepromReadByte( ET131X_ADAPTER *pAdapter, UINT32 unAddress, PUCHAR pbData,
+                      UINT32 unEepromId, UINT32 unAddressingMode )
+{
+    INT32  nIndex;
+    INT32  nError          = 0;
+    INT32  nReadSuccessful = 0;
+    UCHAR  bControl;
+    UCHAR  bStatus         = 0;
+    UINT32 unDword1        = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    /**************************************************************************
+       The following excerpt is from "Serial EEPROM HW Design Specification"
+       Version 0.92 (9/20/2004):
+
+       Single Byte Reads
+
+       A single byte read is similar to the single byte write, with the
+       exception of the data flow:
+
+       1. Check LBCIF Status Register for bits 6 & 3:2 all equal to 0 and
+          bits 7,1:0 both equal to 1, at least once after reset. Subsequent
+          operations need only to check that bits 1:0 are equal to 1 prior
+          to starting a single byte read.
+
+       2. Write to the LBCIF Control Register:  bit 7=1, bit 6=0, bit 3=0,
+          and bits 1:0 both =0.  Bit 5 should be set according to the type
+          of EEPROM being accessed (1=two byte addressing, 0=one byte addr-
+          essing).
+
+       3. Write the address to the LBCIF Address Register (I2C read will
+          begin).
+
+       4. Monitor bit 0 of the LBCIF Status Register.  When =1, I2C read is
+          complete. (if bit 1 =1 and bit 0 stays =0, a hardware failure has
+          occurred).
+
+       5. Check bit 2 of the LBCIF Status Register.  If =1, then an error has
+          occurred.  The data that has been returned from the PHY may be
+          invalid.
+
+       6. Regardless of error status, read data byte from LBCIF Data Register.
+          If another byte is required, go to step 1.
+     *************************************************************************/
+
+
+    /**************************************************************************
+       Step 1:
+     *************************************************************************/
+    for( nIndex = 0; nIndex < MAX_NUM_REGISTER_POLLS; nIndex++)
+    {
+        /**********************************************************************
+           Read registers grouped in DWORD1
+         *********************************************************************/
+        if( LbcifReadDword( pAdapter, LBCIF_DWORD1_GROUP_OFFSET, &unDword1 ))
+        {
+            nError = 1;
+            break;
+        }
+
+        bStatus = EXTRACT_STATUS_REGISTER( unDword1 );
+
+        if( bStatus & LBCIF_STATUS_PHY_QUEUE_AVAIL &&
+            bStatus & LBCIF_STATUS_I2C_IDLE )
+        {
+            /******************************************************************
+               bits 1:0 are equal to 1
+             *****************************************************************/
+            break;
+        }
+    }
+
+    if( nError || ( nIndex >= MAX_NUM_REGISTER_POLLS ))
+    {
+        return( FAILURE );
+    }
+
+
+    /**************************************************************************
+       Step 2:
+     *************************************************************************/
+    bControl  = 0;
+    bControl |= LBCIF_CONTROL_LBCIF_ENABLE;
+
+    if( unAddressingMode == DUAL_BYTE )
+    {
+        bControl |= LBCIF_CONTROL_TWO_BYTE_ADDR;
+    }
+
+    if( LbcifWriteByte( pAdapter, LBCIF_CONTROL_REGISTER_OFFSET, bControl ))
+    {
+        return( FAILURE );
+    }
+
+
+    /**************************************************************************
+       Step 3:
+     *************************************************************************/
+    unAddress |= ( unAddressingMode == DUAL_BYTE ) ?
+                 ( unEepromId << 16 ) : ( unEepromId << 8 );
+
+    if( LbcifWriteDword( pAdapter, LBCIF_ADDRESS_REGISTER_OFFSET, unAddress ))
+    {
+        return( FAILURE );
+    }
+
+
+    /**************************************************************************
+       Step 4:
+     *************************************************************************/
+    for( nIndex = 0; nIndex < MAX_NUM_REGISTER_POLLS; nIndex++ )
+    {
+        /**********************************************************************
+           Read registers grouped in DWORD1
+         *********************************************************************/
+        if( LbcifReadDword( pAdapter, LBCIF_DWORD1_GROUP_OFFSET, &unDword1 ))
+        {
+            nError = 1;
+            break;
+        }
+
+        bStatus = EXTRACT_STATUS_REGISTER( unDword1 );
+
+        if( bStatus & LBCIF_STATUS_PHY_QUEUE_AVAIL
+            && bStatus & LBCIF_STATUS_I2C_IDLE )
+        {
+            /******************************************************************
+               I2C read complete
+             *****************************************************************/
+            break;
+        }
+    }
+
+    if( nError || ( nIndex >= MAX_NUM_REGISTER_POLLS ))
+    {
+        return( FAILURE );
+    }
+
+
+    /**************************************************************************
+       Step 5:
+     *************************************************************************/
+    nReadSuccessful = ( bStatus & LBCIF_STATUS_ACK_ERROR ) ? 0 : 1;
+
+
+    /**************************************************************************
+       Step 6:
+     *************************************************************************/
+    *pbData = EXTRACT_DATA_REGISTER( unDword1 );
+
+    return( nReadSuccessful ) ? SUCCESS : FAILURE;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  EEPROM_access
+ ******************************************************************************
+
+   DESCRIPTION       :
+         Performs a read or write of a given data width at a specified offset
+         from EEPROM
+
+   PARAMETERS        :
+         pAdapter    - [in] pointer to the adapter structure
+         bAccessFlag - [in] A flag indicating what type of transaction
+                            READ/WRITE
+         unOffset    - [in] Specifies the offset within the EEPROM
+         bWidth      - [in] Defines the width (in bits) of the requested
+                            access.  Valid values are 8 or 32.
+         pData       - [in/out] Pointer to a buffer that contains the data
+                                requested by or resulting from the transaction
+                                specified by 'bAccessFlag'.
+                                Method in which this parameter is processed
+                                (de-referenced) is determined by the value of
+                                'bWidth', i.e. 8-bit or 32-bit read/write
+                                accesses.
+
+   RETURNS           :
+        result from PCI Config space access
+
+   REUSE INFORMATION :
+        YES
+
+ *****************************************************************************/
+UINT32 EEPROM_access( ET131X_ADAPTER *pAdapter, UCHAR bAccessFlag,
+                      UINT32 unOffset, UCHAR bWidth, void *pData )
+{
+	UINT32 ulResult;
+    /*-----------------------------------------------------------------------*/
+
+    if( bAccessFlag == WRITE )
+    {
+        /**********************************************************************
+           we are doing a write
+         *********************************************************************/
+        ulResult = pci_slot_information_write( pAdapter->pdev,
+                                               unOffset,
+                                               pData,
+                                               ( bWidth / 8 ));
+    }
+    else
+    {
+        /**********************************************************************
+           do the read read
+         *********************************************************************/
+        ulResult = pci_slot_information_read( pAdapter->pdev,
+                                              unOffset,
+                                              pData,
+                                              ( bWidth / 8 ));
+    }
+	if( ulResult != 0 )
+	{
+		return( 0 );
+	}
+	else
+	{
+		return( ulResult );
+	}
+}
+/*===========================================================================*/
--- /dev/null
+++ b/drivers/net/et131x/ET1310_eeprom.h
@@ -0,0 +1,127 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_eeprom.h - Defines, structs, enums, prototypes, etc. used for EEPROM
+ *                   access routines
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:10 $
+     $Revision: 1.4 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET1310_EEPROM_H__
+#define __ET1310_EEPROM_H__
+
+
+
+
+/******************************************************************************
+   INCLUDES
+ *****************************************************************************/
+#include "ET1310_common.h"
+
+
+#ifndef SUCCESS
+    #define SUCCESS         0
+    #define FAILURE         1
+#endif
+
+#ifndef READ
+    #define READ            0
+    #define WRITE           1
+#endif
+
+#ifndef SINGLE_BYTE
+    #define SINGLE_BYTE     0
+    #define DUAL_BYTE       1
+#endif
+
+
+
+
+/******************************************************************************
+   Forward declaration of the private adapter structure
+ *****************************************************************************/
+struct et131x_adapter;
+
+
+
+
+UINT32 EEPROM_access( struct et131x_adapter *pAdapter, UCHAR bAccessFlag,
+                      UINT32 unOffset, UCHAR bWidth, void *pData );
+
+INT32  EepromWriteByte( struct et131x_adapter *pAdapter, UINT32 unAddress,
+                        UCHAR bData, UINT32 unEepromId, UINT32 unAddressingMode );
+
+INT32  EepromReadByte( struct et131x_adapter *pAdapter, UINT32 unAddress,
+                       PUCHAR pbData, UINT32 unEepromId, UINT32 unAddressingMode );
+
+
+
+
+#endif /* _ET1310_EEPROM_H_ */
--- /dev/null
+++ b/drivers/net/et131x/ET1310_jagcore.c
@@ -0,0 +1,642 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_jagcore.c - All code pertaining to the ET1301/ET131x's JAGcore
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/10/28 18:43:44 $
+     $Revision: 1.9 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_initpci.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   ROUTINE:  ConfigGlobalRegs
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to configure the global registers on the JAGCore
+
+   PARAMETERS :
+        pAdpater - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void ConfigGlobalRegs( ET131X_ADAPTER *pAdapter )
+{
+    PGLOBAL_t pGbl;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "ConfigGlobalRegs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+        Map a local pointer to the global section of the JAGCore
+     *************************************************************************/
+    pGbl = &pAdapter->CSRAddress->global;
+
+    if( pAdapter->RegistryPhyLoopbk == FALSE )
+    {
+        if( pAdapter->RegistryJumboPacket < 2048 )
+        {
+            /******************************************************************
+                Tx / RxDMA and Tx/Rx MAC interfaces have a 1k word block of RAM
+                that the driver can split between Tx and Rx as it desires.  Our
+                default is to split it 50/50:
+             *****************************************************************/
+            pGbl->rxq_start_addr.value = 0;
+            pGbl->rxq_end_addr.value   = pAdapter->RegistryRxMemEnd;
+            pGbl->txq_start_addr.value = pGbl->rxq_end_addr.bits.rxq_end_addr + 1;
+            pGbl->txq_end_addr.value   = INTERNAL_MEM_SIZE - 1;
+        }
+        else if( pAdapter->RegistryJumboPacket < 8192 )
+        {
+            /******************************************************************
+                For jumbo packets > 2k in length, but < 8k, split 50-50.
+             *****************************************************************/
+            pGbl->rxq_start_addr.value = 0;
+            pGbl->rxq_end_addr.value   = INTERNAL_MEM_RX_OFFSET;
+            pGbl->txq_start_addr.value = INTERNAL_MEM_RX_OFFSET + 1;
+            pGbl->txq_end_addr.value   = INTERNAL_MEM_SIZE - 1;
+        }
+        else
+        {
+            /******************************************************************
+                9216 is the only packet size greater than 8k that is available.
+                The Tx buffer has to be big enough for one whole packet on the
+                Tx side.  We'll make the Tx 9408, and give the rest to Rx
+             *****************************************************************/
+            pGbl->rxq_start_addr.value = 0x0000;
+            pGbl->rxq_end_addr.value   = 0x01b3;
+            pGbl->txq_start_addr.value = 0x01b4;
+            pGbl->txq_end_addr.value   = INTERNAL_MEM_SIZE - 1;
+        }
+
+        /**********************************************************************
+            Initialize the loopback register.  Disable all loopbacks.
+         *********************************************************************/
+        pGbl->loopback.value       = 0x0;
+    }
+    else
+    {
+        /**************************************************************************
+            For PHY Line loopback, the memory is configured as if Tx and Rx both
+            have all the memory.  This is because the RxMAC will write data into
+            the space, and the TxMAC will read it out.
+        *************************************************************************/
+        pGbl->rxq_start_addr.value = 0;
+        pGbl->rxq_end_addr.value   = INTERNAL_MEM_SIZE - 1;
+        pGbl->txq_start_addr.value = 0;
+        pGbl->txq_end_addr.value   = INTERNAL_MEM_SIZE - 1;
+
+        /**************************************************************************
+            Initialize the loopback register (MAC loopback).
+         *************************************************************************/
+        pGbl->loopback.value       = 0x1;
+    }
+
+    /**************************************************************************
+       MSI Register
+     *************************************************************************/
+    pGbl->msi_config.value     = 0x0;
+
+
+    /**************************************************************************
+       By default, disable the watchdog timer.  It will be enabled when
+       a packet is queued.
+     *************************************************************************/
+    pGbl->watchdog_timer     = 0;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  ConfigMMCRegs
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to configure the main memory registers in the JAGCore
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void ConfigMMCRegs( ET131X_ADAPTER *pAdapter )
+{
+    MMC_CTRL_t  mmc_ctrl = {0};
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "ConfigMMCRegs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       All we need to do is initialize the Memory Control Register
+     *************************************************************************/
+    mmc_ctrl.bits.force_ce        = 0x0;
+    mmc_ctrl.bits.rxdma_disable   = 0x0;
+    mmc_ctrl.bits.txdma_disable   = 0x0;
+    mmc_ctrl.bits.txmac_disable   = 0x0;
+    mmc_ctrl.bits.rxmac_disable   = 0x0;
+    mmc_ctrl.bits.arb_disable     = 0x0;
+    mmc_ctrl.bits.mmc_enable      = 0x1;
+
+    pAdapter->CSRAddress->mmc.mmc_ctrl.value = mmc_ctrl.value;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_enable_interrupts
+ ******************************************************************************
+
+   DESCRIPTION       : Enable interupts on the ET131x
+
+   PARAMETERS        : adapter - a pointer to our private adapter structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_enable_interrupts( ET131X_ADAPTER *adapter )
+{
+    UINT32 MaskValue;
+
+
+    /**************************************************************************
+       Enable all global interrupts
+     *************************************************************************/
+    if(( adapter->FlowControl == TxOnly ) ||
+       ( adapter->FlowControl == Both ))
+    {
+        MaskValue = INT_MASK_ENABLE;
+    }
+    else
+    {
+        MaskValue = INT_MASK_ENABLE_NO_FLOW;
+    }
+
+    if( adapter->DriverNoPhyAccess )
+    {
+        MaskValue |= 0x10000;
+    }
+
+    adapter->CachedMaskValue.value = MaskValue;
+    adapter->CSRAddress->global.int_mask.value = MaskValue;
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_disable_interrupts
+ ******************************************************************************
+
+   DESCRIPTION       : Enable interrupts on the ET131x
+
+   PARAMETERS        : adapter - a pointer to our private adapter structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+
+void et131x_disable_interrupts( ET131X_ADAPTER *adapter )
+{
+    /**************************************************************************
+       Disable all global interrupts
+     *************************************************************************/
+    adapter->CachedMaskValue.value             = INT_MASK_DISABLE;
+    adapter->CSRAddress->global.int_mask.value = INT_MASK_DISABLE;
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  NICGetRegs
+ ******************************************************************************
+
+   DESCRIPTION:
+        function used to get register data
+
+   PARAMETERS :
+        pAdapter         - pointer to our adapter structure
+        InfoBuf          - pointer to data struct containing registers to get
+        ulBytesAvailable -
+        ulInfoLen -
+
+   RETURN     :
+        NONE
+
+ *****************************************************************************/
+void * et131x_get_regs( ET131X_ADAPTER *pAdapter, void *InfoBuf,
+                        PUINT32 ulBytesAvailable, PUINT32 ulInfoLen )
+{
+    INT32   nRegCount;
+    PINT8   pJCBase;
+    INT32   x;
+    PUINT32 pReg;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_get_regs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    memset( (void *)&pAdapter->JagCoreRegs, 0, sizeof( JAGCORE_ACCESS_REGS ));
+
+
+    /**************************************************************************
+       Get the user supplied data
+     *************************************************************************/
+    pAdapter->JagCoreRegs = *(PJAGCORE_ACCESS_REGS)InfoBuf;
+    nRegCount             = pAdapter->JagCoreRegs.nRegCount;
+
+    pJCBase = (PINT8)&pAdapter->CSRAddress->global;
+
+    for( x = 0; x < nRegCount; x++ )
+    {
+        pReg = (PUINT32)( pJCBase+pAdapter->JagCoreRegs.nOffsets[x] );
+
+        pAdapter->JagCoreRegs.nData[x] = *pReg;
+    }
+
+    *ulBytesAvailable = sizeof( JAGCORE_ACCESS_REGS );
+    *ulInfoLen        = sizeof( JAGCORE_ACCESS_REGS );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return( (void *)&pAdapter->JagCoreRegs );
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_set_regs
+ ******************************************************************************
+
+   DESCRIPTION:
+        function used to set register data
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+        InfoBuf  - pointer to data struct containing register offset and data
+                   to set
+   RETURN     :
+        N/A
+
+ *****************************************************************************/
+void et131x_set_regs( ET131X_ADAPTER *pAdapter, void *InfoBuf )
+{
+    INT32   nRegCount;
+    PINT8   pJCBase;
+    INT32   x;
+    PUINT32 pReg;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_set_regs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    memset( (void *)&pAdapter->JagCoreRegs, 0, sizeof( JAGCORE_ACCESS_REGS ));
+
+
+    /**************************************************************************
+       Get the user supplied data
+     *************************************************************************/
+    pAdapter->JagCoreRegs = *(PJAGCORE_ACCESS_REGS)InfoBuf;
+
+    nRegCount = pAdapter->JagCoreRegs.nRegCount;
+
+    pJCBase = (PINT8)&pAdapter->CSRAddress->global;
+
+    for( x = 0; x < nRegCount; x++ )
+    {
+         pReg = (PUINT32)(pJCBase+pAdapter->JagCoreRegs.nOffsets[x]);
+        *pReg = pAdapter->JagCoreRegs.nData[x];
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  GetPciCfgRegs
+ ******************************************************************************
+
+   DESCRIPTION:
+        function used to get register data
+
+   PARAMETERS :
+        pAdapter         - pointer to our adapter structure
+        InfoBuf          - pointer to data struct containing registers to get
+        ulBytesAvailable -
+        ulInfoLen -
+
+   RETURN     :
+        NONE
+
+ *****************************************************************************/
+void * GetPciCfgRegs( ET131X_ADAPTER *pAdapter, void * InfoBuf,
+                      PUINT32 ulBytesAvailable, PUINT32 ulInfoLen )
+{
+    INT32   nRegCount;
+    UINT32  ByteLength = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "GetPciCfgRegs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Get the user supplied data
+     *************************************************************************/
+    pAdapter->PciCfgRegs  = *(PPCI_CFG_SPACE_REGS)InfoBuf;
+    nRegCount             = pAdapter->PciCfgRegs.nRegCount;
+
+
+	/**************************************************************************
+       Support for 8,16,32 bit widths
+     *************************************************************************/
+	ByteLength = pAdapter->PciCfgRegs.nDataWidth/8;
+
+    pci_slot_information_read( pAdapter->pdev,
+                               pAdapter->PciCfgRegs.nOffsets[0],
+                               (UINT8 *)&pAdapter->PciCfgRegs.nData,
+                               ByteLength * nRegCount );
+
+   *ulBytesAvailable = sizeof( PCI_CFG_SPACE_REGS );
+   *ulInfoLen        = sizeof( PCI_CFG_SPACE_REGS );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+	return( (void *)&pAdapter->PciCfgRegs );
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  SetPciCfgRegs
+ ******************************************************************************
+
+   DESCRIPTION:
+        function used to set register data
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+        InfoBuf  - pointer to data struct containing register offset and data
+                   to set
+   RETURN     :
+        N/A
+
+ *****************************************************************************/
+void SetPciCfgRegs( ET131X_ADAPTER *pAdapter, void * InfoBuf )
+{
+    INT32  nRegCount;
+    INT32  x;
+    UINT32 ByteLength = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "SetPciCfgRegs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+	memset( (void *)&pAdapter->PciCfgRegs, 0, sizeof( PCI_CFG_SPACE_REGS ));
+
+
+    /**************************************************************************
+       Get the user supplied data
+     *************************************************************************/
+	pAdapter->PciCfgRegs = *(PPCI_CFG_SPACE_REGS)InfoBuf;
+
+	nRegCount = pAdapter->PciCfgRegs.nRegCount;
+	ByteLength = pAdapter->PciCfgRegs.nDataWidth/8;
+
+	for( x = 0; x < nRegCount; x++ )
+	{
+        pci_slot_information_write( pAdapter->pdev,
+                                    pAdapter->PciCfgRegs.nOffsets[x],
+                                    (UINT8 *)&pAdapter->PciCfgRegs.nData[x * ByteLength],
+                                    ByteLength );
+	}
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  MemTest
+ ******************************************************************************
+
+   DESCRIPTION:
+        function used to test rx/tx queue memory at 0x0 and 0x200
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURN     :
+        TRUE or FALSE
+
+ *****************************************************************************/
+BOOL_t MemTest( ET131X_ADAPTER *pAdapter, UINT32 addr )
+{
+    UINT32 data;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "MemTest" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    // Read initial value
+    pAdapter->CSRAddress->mmc.sram_access.value = 1;
+    data = pAdapter->CSRAddress->mmc.sram_word1.data;
+
+
+    // Write test value
+    pAdapter->CSRAddress->mmc.sram_word1.data = 0xdeadbeef;
+    pAdapter->CSRAddress->mmc.sram_access.value = 0xf003;
+
+
+    // Read back test value
+    pAdapter->CSRAddress->mmc.sram_access.bits.req_access  = 1;
+    if ( pAdapter->CSRAddress->mmc.sram_word1.data != 0xdeadbeef )
+    {
+        DBG_LEAVE( et131x_dbginfo );
+        return FALSE;
+    }
+
+    // Restore initial value
+    pAdapter->CSRAddress->mmc.sram_word1.data = data;
+    pAdapter->CSRAddress->mmc.sram_access.value = 0xf003;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return TRUE;
+}
+/*===========================================================================*/
--- /dev/null
+++ b/drivers/net/et131x/ET1310_jagcore.h
@@ -0,0 +1,180 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_jagcore.h - Defines, structs, enums, prototypes, etc. pertaining to
+ *                    the JAGCore
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/10/28 18:43:44 $
+     $Revision: 1.7 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET1310_JAGCORE_H__
+#define __ET1310_JAGCORE_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+
+/******************************************************************************
+   INCLUDES
+ *****************************************************************************/
+#include "ET1310_common.h"
+
+
+
+
+/******************************************************************************
+   CONSTANTS FOR JAGCORE
+ *****************************************************************************/
+#define INTERNAL_MEM_SIZE       0x400  //1024 of internal memory
+#define INTERNAL_MEM_RX_OFFSET  0x1FF  //50%   Tx, 50%   Rx
+
+#define REGS_MAX_ARRAY          4096
+
+
+
+
+/******************************************************************************
+    For interrupts, normal running is:
+        rxdma_xfr_done, phy_interrupt, mac_stat_interrupt,
+        watchdog_interrupt & txdma_xfer_done
+
+    In both cases, when flow control is enabled for either Tx or bi-direction,
+    we additional enable rx_fbr0_low and rx_fbr1_low, so we know when the
+    buffer rings are running low.
+ *****************************************************************************/
+#define INT_MASK_DISABLE            0xffffffff
+
+// NOTE: Masking out MAC_STAT Interrupt for now...
+//#define INT_MASK_ENABLE             0xfff6bf17
+//#define INT_MASK_ENABLE_NO_FLOW     0xfff6bfd7
+#define INT_MASK_ENABLE             0xfffebf17
+#define INT_MASK_ENABLE_NO_FLOW     0xfffebfd7
+
+
+
+
+/******************************************************************************
+   DATA STRUCTURES FOR DIRECT REGISTER ACCESS
+ *****************************************************************************/
+typedef struct
+{
+    u8  bReadWrite;
+    u32 nRegCount;
+    u32 nData [REGS_MAX_ARRAY];
+    u32 nOffsets [REGS_MAX_ARRAY];
+} JAGCORE_ACCESS_REGS, *PJAGCORE_ACCESS_REGS;
+
+
+typedef struct
+{
+    u8  bReadWrite;
+    u32 nDataWidth;
+    u32 nRegCount;
+    u32 nOffsets [REGS_MAX_ARRAY];
+    u32 nData [REGS_MAX_ARRAY];
+} PCI_CFG_SPACE_REGS, *PPCI_CFG_SPACE_REGS;
+
+
+
+
+/******************************************************************************
+   Forward declaration of the private adapter structure
+ *****************************************************************************/
+struct et131x_adapter;
+
+
+
+
+/******************************************************************************
+   PROTOTYPES
+ *****************************************************************************/
+void ConfigGlobalRegs(struct et131x_adapter *pAdapter );
+
+void ConfigMMCRegs( struct et131x_adapter *pAdapter );
+
+void et131x_enable_interrupts( struct et131x_adapter *adapter );
+
+void et131x_disable_interrupts( struct et131x_adapter *adapter );
+
+void * et131x_get_regs( struct et131x_adapter *pAdapter, void *InfoBuf,
+                        PUINT32 ulBytesAvailable, PUINT32 ulInfoLen );
+
+void et131x_set_regs( struct et131x_adapter *pAdapter, void *InfoBuf );
+
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __ET1310_JAGCORE_H__ */
--- /dev/null
+++ b/drivers/net/et131x/ET1310_mac.c
@@ -0,0 +1,1247 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_mac.c - All code and routines pertaining to the MAC
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/10/28 18:43:44 $
+     $Revision: 1.11 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+#include "ET1310_mac.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_initpci.h"
+#include "et131x_supp.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   ROUTINE:  ConfigMacRegs1
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to configure the first part of MAC regs to a known initialized
+        state
+
+   PARAMETERS :
+        pAdpater - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void ConfigMACRegs1( ET131X_ADAPTER *pAdapter )
+{
+    PMAC_t              pMac;
+    MAC_STATION_ADDR1_t station1;
+    MAC_STATION_ADDR2_t station2;
+    MAC_IPG_t           ipg;
+    MAC_HFDP_t          hfdp;
+    MII_MGMT_CFG_t      mii_mgmt_cfg;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "ConfigMACRegs1" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Let's get our pointer to the MAC regs
+     *************************************************************************/
+    pMac = &pAdapter->CSRAddress->mac;
+
+
+    /**************************************************************************
+       First we need to reset everything.  Write to MAC configuration register
+       1 to perform reset.
+     *************************************************************************/
+    pMac->cfg1.value = 0xC00F0000;
+
+
+    /**************************************************************************
+       Next lets configure the MAC Inter-packet gap register
+     *************************************************************************/
+    ipg.bits.non_B2B_ipg_1        = 0x38; //58d
+    ipg.bits.non_B2B_ipg_2        = 0x58; //88d
+    ipg.bits.min_ifg_enforce      = 0x50; //80d
+    ipg.bits.B2B_ipg              = 0x60; //96d
+
+    pMac->ipg.value = ipg.value;
+
+
+    /**************************************************************************
+       Next lets configure the MAC Half Duplex register
+     *************************************************************************/
+    hfdp.bits.alt_beb_trunc       = 0xA;
+    hfdp.bits.alt_beb_enable      = 0x0;
+    hfdp.bits.bp_no_backoff       = 0x0;
+    hfdp.bits.no_backoff          = 0x0;
+    hfdp.bits.excess_defer        = 0x1;
+    hfdp.bits.rexmit_max          = 0xF;
+    hfdp.bits.coll_window         = 0x37; //55d
+
+    pMac->hfdp.value = hfdp.value;
+
+
+    /**************************************************************************
+       Next lets configure the MAC Interface Control register
+     *************************************************************************/
+    pMac->if_ctrl.value = 0x0;
+
+
+    /**************************************************************************
+       Let's move on to setting up the mii managment configuration
+     *************************************************************************/
+    mii_mgmt_cfg.bits.reset_mii_mgmt    = 0;
+    mii_mgmt_cfg.bits.scan_auto_incremt = 0;
+    mii_mgmt_cfg.bits.preamble_suppress = 0;
+    mii_mgmt_cfg.bits.mgmt_clk_reset    = 0x7;
+
+    pMac->mii_mgmt_cfg.value = mii_mgmt_cfg.value;
+
+
+    /**************************************************************************
+       Next lets configure the MAC Station Address register.  These values are
+       read from the EEPROM during initialization and stored in the adapter
+       structure.  We write what is stored in the adapter structure to the MAC
+       Station Address registers high and low.  This station address is used
+       for generating and checking pause control packets.
+     *************************************************************************/
+    station2.bits.Octet1    = pAdapter->CurrentAddress[0];
+    station2.bits.Octet2    = pAdapter->CurrentAddress[1];
+    station1.bits.Octet3    = pAdapter->CurrentAddress[2];
+    station1.bits.Octet4    = pAdapter->CurrentAddress[3];
+    station1.bits.Octet5    = pAdapter->CurrentAddress[4];
+    station1.bits.Octet6    = pAdapter->CurrentAddress[5];
+
+    pMac->station_addr_1.value = station1.value;
+    pMac->station_addr_2.value = station2.value;
+
+
+    /**************************************************************************
+       Max ethernet packet in bytes that will passed by the mac without being
+       truncated.  Allow the MAC to pass 8 more than our max packet size.  This
+       is 4 for the Ethernet CRC and 4 for the VLAN ID.
+
+       Packets larger than (RegistryJumboPacket) that do not contain a VLAN
+       ID will be dropped by the Rx function.
+     *************************************************************************/
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+    pMac->max_fm_len.value = pAdapter->RegistryJumboPacket + 8;
+#else
+    pMac->max_fm_len.value = pAdapter->RegistryJumboPacket + 4;
+#endif
+
+
+    /**************************************************************************
+       clear out MAC config reset
+     *************************************************************************/
+    pAdapter->CSRAddress->mac.cfg1.value = 0x0;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  ConfigMacRegs2
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to configure the second part of MAC regs to a known initialized
+        state
+
+   PARAMETERS :
+        pAdpater - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void ConfigMACRegs2( ET131X_ADAPTER *pAdapter )
+{
+    INT32         delay = 0;
+    PMAC_t        pMac;
+    MAC_CFG1_t    cfg1;
+    MAC_CFG2_t    cfg2;
+    MAC_IF_CTRL_t ifctrl;
+    TXMAC_CTL_t   ctl = pAdapter->CSRAddress->txmac.ctl;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "ConfigMACRegs2" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Let's get our pointer to the MAC regs
+     *************************************************************************/
+    pMac = &pAdapter->CSRAddress->mac;
+
+    cfg1.value   = pMac->cfg1.value;
+    cfg2.value   = pMac->cfg2.value;
+    ifctrl.value = pMac->if_ctrl.value;
+
+    if( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS )
+    {
+        cfg2.bits.if_mode    = 0x2;
+        ifctrl.bits.phy_mode = 0x0;
+    }
+    else
+    {
+        cfg2.bits.if_mode    = 0x1;
+        ifctrl.bits.phy_mode = 0x1;
+    }
+
+
+    /**************************************************************************
+       We need to enable Rx/Tx
+     *************************************************************************/
+    cfg1.bits.rx_enable	    = 0x1;
+    cfg1.bits.tx_enable	    = 0x1;
+
+
+    /**************************************************************************
+       Set up flow control
+     *************************************************************************/
+    cfg1.bits.tx_flow	    = 0x1;
+
+    if( ( pAdapter->FlowControl == RxOnly ) ||
+        ( pAdapter->FlowControl == Both ))
+    {
+        cfg1.bits.rx_flow	    = 0x1;
+    }
+    else
+    {
+        cfg1.bits.rx_flow	    = 0x0;
+    }
+
+
+    /**************************************************************************
+       Initialize loop back to off
+     *************************************************************************/
+    cfg1.bits.loop_back	    = 0;
+
+    pAdapter->CSRAddress->mac.cfg1.value = cfg1.value;
+
+
+    /**************************************************************************
+       Now we need to initialize the MAC Configuration 2 register
+     *************************************************************************/
+    cfg2.bits.preamble_len        = 0x7;
+    cfg2.bits.huge_frame          = 0x0;
+    /* LENGTH FIELD CHECKING bit4: Set this bit to cause the MAC to check the
+     * frame’s length field to ensure it matches the actual data field length. Clear this bit if no
+     * length field checking is desired. Its default is ‘0’.
+     */
+    cfg2.bits.len_check           = 0x1;
+
+    if ( pAdapter->RegistryPhyLoopbk == FALSE )
+    {
+        cfg2.bits.pad_crc         = 0x1;
+        cfg2.bits.crc_enable      = 0x1;
+    }
+    else
+    {
+        cfg2.bits.pad_crc         = 0;
+        cfg2.bits.crc_enable      = 0;
+    }
+
+
+    /**************************************************************************
+       1 – full duplex, 0 – half-duplex
+     *************************************************************************/
+    cfg2.bits.full_duplex	        = pAdapter->uiDuplexMode;
+    ifctrl.bits.ghd_mode            = !pAdapter->uiDuplexMode;
+
+    pAdapter->CSRAddress->mac.if_ctrl = ifctrl;
+    pAdapter->CSRAddress->mac.cfg2.value = cfg2.value;
+
+    do
+    {
+        udelay( 10 );
+        delay++;
+    } while(( !pAdapter->CSRAddress->mac.cfg1.bits.syncd_rx_en ||
+              !pAdapter->CSRAddress->mac.cfg1.bits.syncd_tx_en ) &&
+              ( delay < 100 ));
+
+    if( delay == 100 )
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "Syncd bits did not respond correctly cfg1 word 0x%08x\n",
+                   pAdapter->CSRAddress->mac.cfg1.value );
+    }
+
+    DBG_TRACE( et131x_dbginfo,
+               "Speed %d, Dup %d, CFG1 0x%08x, CFG2 0x%08x, if_ctrl 0x%08x\n",
+               pAdapter->uiLinkSpeed, pAdapter->uiDuplexMode,
+               pAdapter->CSRAddress->mac.cfg1.value,
+               pAdapter->CSRAddress->mac.cfg2.value,
+               pAdapter->CSRAddress->mac.if_ctrl.value );
+
+
+    /**************************************************************************
+       Enable TXMAC
+     *************************************************************************/
+    ctl.bits.txmac_en   = 0x1;
+    ctl.bits.fc_disable = 0x1;
+    pAdapter->CSRAddress->txmac.ctl = ctl;
+
+
+    /**************************************************************************
+       Ready to start the RXDMA/TXDMA engine
+     *************************************************************************/
+    if( !MP_TEST_FLAG( pAdapter, fMP_ADAPTER_LOWER_POWER ))
+    {
+        et131x_rx_dma_enable( pAdapter );
+        et131x_tx_dma_enable( pAdapter );
+    }
+    else
+    {
+        DBG_WARNING( et131x_dbginfo,
+                     "Didn't enable Rx/Tx due to low-power mode\n" );
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  ConfigRxMacRegs
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to configure the RX MAC registers in the JAGCore
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void ConfigRxMacRegs( ET131X_ADAPTER *pAdapter )
+{
+    PRXMAC_t                  pRxMac;
+    RXMAC_WOL_SA_LO_t         sa_lo;
+    RXMAC_WOL_SA_HI_t         sa_hi;
+    RXMAC_PF_CTRL_t           pf_ctrl = {0};
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "ConfigRxMacRegs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Let's get a local pointer to the RX MAC Registers
+     *************************************************************************/
+    pRxMac = &pAdapter->CSRAddress->rxmac;
+
+
+    /**************************************************************************
+       Disable the MAC while it is being configured (also disable WOL)
+     *************************************************************************/
+    pRxMac->ctrl.value = 0x8;
+
+
+    /**************************************************************************
+       Initialize WOL to disabled.
+     *************************************************************************/
+
+    pRxMac->crc0.value      = 0x0;
+    pRxMac->crc12.value     = 0x0000;
+    pRxMac->crc34.value     = 0x0000;
+
+
+    /**************************************************************************
+        We need to set the WOL mask0 – mask4 next.  We initialize it to its
+        default Values of 0x00000000 because there are not WOL masks as of
+        this time.
+     *************************************************************************/
+    pRxMac->mask0_word0.mask                = 0x00000000;
+    pRxMac->mask0_word1.mask                = 0x00000000;
+    pRxMac->mask0_word2.mask                = 0x00000000;
+    pRxMac->mask0_word3.mask                = 0x00000000;
+
+    pRxMac->mask1_word0.mask                = 0x00000000;
+    pRxMac->mask1_word1.mask                = 0x00000000;
+    pRxMac->mask1_word2.mask                = 0x00000000;
+    pRxMac->mask1_word3.mask                = 0x00000000;
+
+    pRxMac->mask2_word0.mask                = 0x00000000;
+    pRxMac->mask2_word1.mask                = 0x00000000;
+    pRxMac->mask2_word2.mask                = 0x00000000;
+    pRxMac->mask2_word3.mask                = 0x00000000;
+
+    pRxMac->mask3_word0.mask                = 0x00000000;
+    pRxMac->mask3_word1.mask                = 0x00000000;
+    pRxMac->mask3_word2.mask                = 0x00000000;
+    pRxMac->mask3_word3.mask                = 0x00000000;
+
+    pRxMac->mask4_word0.mask                = 0x00000000;
+    pRxMac->mask4_word1.mask                = 0x00000000;
+    pRxMac->mask4_word2.mask                = 0x00000000;
+    pRxMac->mask4_word3.mask                = 0x00000000;
+
+
+    /**************************************************************************
+       Lets setup the WOL Source Address
+     *************************************************************************/
+    sa_lo.bits.sa3                  = pAdapter->CurrentAddress[2];
+    sa_lo.bits.sa4                  = pAdapter->CurrentAddress[3];
+    sa_lo.bits.sa5                  = pAdapter->CurrentAddress[4];
+    sa_lo.bits.sa6                  = pAdapter->CurrentAddress[5];
+    pRxMac->sa_lo.value = sa_lo.value;
+
+    sa_hi.bits.sa1                  = pAdapter->CurrentAddress[0];
+    sa_hi.bits.sa2                  = pAdapter->CurrentAddress[1];
+    pRxMac->sa_hi.value = sa_hi.value;
+
+
+    /**************************************************************************
+       Disable all Packet Filtering
+     *************************************************************************/
+    pRxMac->pf_ctrl.value = 0;
+
+
+    /**************************************************************************
+       Let's initialize the Unicast Packet filtering address
+     *************************************************************************/
+    if( pAdapter->PacketFilter & ET131X_PACKET_TYPE_DIRECTED )
+    {
+        SetupDeviceForUnicast( pAdapter );
+        pf_ctrl.bits.filter_uni_en = 1;
+    }
+    else
+    {
+        pRxMac->uni_pf_addr1.value       = 0x00000000;
+        pRxMac->uni_pf_addr2.value       = 0x00000000;
+        pRxMac->uni_pf_addr3.value       = 0x00000000;
+    }
+
+
+    /**************************************************************************
+       Let's initialize the Multicast hash
+     *************************************************************************/
+    if( pAdapter->PacketFilter & ET131X_PACKET_TYPE_ALL_MULTICAST )
+    {
+        pf_ctrl.bits.filter_multi_en = 0;
+    }
+    else
+    {
+        pf_ctrl.bits.filter_multi_en = 1;
+        SetupDeviceForMulticast( pAdapter );
+    }
+
+
+    /**************************************************************************
+       Runt packet filtering.  Didn't work in version A silicon.
+     *************************************************************************/
+    pf_ctrl.bits.min_pkt_size   = NIC_MIN_PACKET_SIZE + 4;
+    pf_ctrl.bits.filter_frag_en = 1;
+
+    if( pAdapter->RegistryJumboPacket > 8192 )
+    {
+        RXMAC_MCIF_CTRL_MAX_SEG_t mcif_ctrl_max_seg;
+
+
+        /**********************************************************************
+            In order to transmit jumbo packets greater than 8k, the FIFO
+            between RxMAC and RxDMA needs to be reduced in size to (16k -
+            Jumbo packet size).  In order to implement this, we must use
+            "cut through" mode in the RxMAC, which chops packets down into
+            segments which are (max_size * 16).  In this case we selected
+            256 bytes, since this is the size of the PCI-Express TLP's that
+            the 1310 uses.
+         *********************************************************************/
+        mcif_ctrl_max_seg.bits.seg_en   = 0x1;
+        mcif_ctrl_max_seg.bits.fc_en    = 0x0;
+        mcif_ctrl_max_seg.bits.max_size = 0x10;
+
+        pRxMac->mcif_ctrl_max_seg.value = mcif_ctrl_max_seg.value;
+    }
+    else
+    {
+        pRxMac->mcif_ctrl_max_seg.value = 0x0;
+    }
+
+
+    /**************************************************************************
+       Initialize the MCIF water marks
+     *************************************************************************/
+    pRxMac->mcif_water_mark.value    = 0x0;
+
+
+    /**************************************************************************
+       Initialize the MIF control
+     *************************************************************************/
+    pRxMac->mif_ctrl.value     = 0x0;
+
+
+    /**************************************************************************
+       Initialize the Space Available Register
+     *************************************************************************/
+    pRxMac->space_avail.value    = 0x0;
+
+    /* Initialize the the mif_ctrl register
+     * bit 3  - Receive code error. One or more nibbles were signaled as errors
+                during the reception of the packet.  Clear this bit in Gigabit,
+                set it in 100Mbit.  This was derived experimentally at UNH.
+     * bit 4  - Receive CRC error. The packet’s CRC did not match the
+                internally generated CRC.
+     * bit 5  - Receive length check error. Indicates that frame length field
+                value in the packet does not match the actual data byte length
+                and is not a type field.
+     * bit 16 - Receive frame truncated.
+     * bit 17 - Drop packet enable
+     */
+    if( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_100MBPS )
+    {
+        pRxMac->mif_ctrl.value = 0x30038;
+    }
+    else
+    {
+        pRxMac->mif_ctrl.value = 0x30030;
+    }
+
+
+    /**************************************************************************
+       Finally we initialize RxMac to be enabled & WOL disabled.  Packet filter
+       is always enabled since it is where the runt packets are supposed to be
+       dropped.  For version A silicon, runt packet dropping doesn't work, so
+       it is disabled in the pf_ctrl register, but we still leave the packet
+       filter on.
+     *************************************************************************/
+    pRxMac->pf_ctrl = pf_ctrl;
+    pRxMac->ctrl.value = 0x9;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  ConfigTxMacRegs
+ ******************************************************************************
+
+   DESCRIPTION:
+        used to configure the TX MAC registers of the JAGCore
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void ConfigTxMacRegs( ET131X_ADAPTER *pAdapter )
+{
+    PTXMAC_t pTxMac;
+    TXMAC_CF_PARAM_t Local;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "ConfigTxMacRegs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Let's get the pointer to tx mac section of regs
+     *************************************************************************/
+    pTxMac = &pAdapter->CSRAddress->txmac;
+
+
+    /**************************************************************************
+       We need to update the Control Frame Parameters
+       cfpt - control frame pause timer set to 64 (0x40)
+       cfep - control frame extended pause timer set to 0x0
+     *************************************************************************/
+    if( pAdapter->FlowControl == None )
+    {
+        pTxMac->cf_param.value  = 0x0;
+    }
+    else
+    {
+        Local.bits.cfpt = 0x40;
+        Local.bits.cfep = 0x0;
+        pTxMac->cf_param.value  = Local.value;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  ConfigMacStatRegs
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to configure the MAC STAT section of the JAGCore
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void ConfigMacStatRegs( ET131X_ADAPTER *pAdapter )
+{
+    PMAC_STAT_t pDevMacStat;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "ConfigMacStatRegs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    pDevMacStat = &pAdapter->CSRAddress->macStat;
+
+
+    /**************************************************************************
+       Next we need to initialize all the MAC_STAT registers to zero on the
+       device.
+     *************************************************************************/
+    pDevMacStat->RFcs = 0x0;
+    pDevMacStat->RAln = 0x0;
+    pDevMacStat->RFlr = 0x0;
+    pDevMacStat->RDrp = 0x0;
+    pDevMacStat->RCde = 0x0;
+    pDevMacStat->ROvr = 0x0;
+    pDevMacStat->RFrg = 0x0;
+
+    pDevMacStat->TScl = 0x0;
+    pDevMacStat->TDfr = 0x0;
+    pDevMacStat->TMcl = 0x0;
+    pDevMacStat->TLcl = 0x0;
+    pDevMacStat->TNcl = 0x0;
+    pDevMacStat->TOvr = 0x0;
+    pDevMacStat->TUnd = 0x0;
+
+
+    /***************************************************************************
+       Unmask any counters that we want to track the overflow of.  Initially
+       this will be all counters.  It may become clear later that we do not
+       need to track all counters.
+     **************************************************************************/
+    {
+        MAC_STAT_REG_1_t Carry1M = {0xffffffff};
+
+        Carry1M.bits.rdrp         = 0x0;
+        Carry1M.bits.rjbr         = 0x1;
+        Carry1M.bits.rfrg         = 0x0;
+        Carry1M.bits.rovr         = 0x0;
+        Carry1M.bits.rund         = 0x1;
+        Carry1M.bits.rcse         = 0x1;
+        Carry1M.bits.rcde         = 0x0;
+        Carry1M.bits.rflr         = 0x0;
+        Carry1M.bits.raln         = 0x0;
+        Carry1M.bits.rxuo         = 0x1;
+        Carry1M.bits.rxpf         = 0x1;
+        Carry1M.bits.rxcf         = 0x1;
+        Carry1M.bits.rbca         = 0x1;
+        Carry1M.bits.rmca         = 0x1;
+        Carry1M.bits.rfcs         = 0x0;
+        Carry1M.bits.rpkt         = 0x1;
+        Carry1M.bits.rbyt         = 0x1;
+        Carry1M.bits.trmgv        = 0x1;
+        Carry1M.bits.trmax        = 0x1;
+        Carry1M.bits.tr1k         = 0x1;
+        Carry1M.bits.tr511        = 0x1;
+        Carry1M.bits.tr255        = 0x1;
+        Carry1M.bits.tr127        = 0x1;
+        Carry1M.bits.tr64         = 0x1;
+
+        pDevMacStat->Carry1M = Carry1M;
+    }
+
+    {
+        MAC_STAT_REG_2_t Carry2M = {0xffffffff};
+
+        Carry2M.bits.tdrp         = 0x1;
+        Carry2M.bits.tpfh         = 0x1;
+        Carry2M.bits.tncl         = 0x0;
+        Carry2M.bits.txcl         = 0x1;
+        Carry2M.bits.tlcl         = 0x0;
+        Carry2M.bits.tmcl         = 0x0;
+        Carry2M.bits.tscl         = 0x0;
+        Carry2M.bits.tedf         = 0x1;
+        Carry2M.bits.tdfr         = 0x0;
+        Carry2M.bits.txpf         = 0x1;
+        Carry2M.bits.tbca         = 0x1;
+        Carry2M.bits.tmca         = 0x1;
+        Carry2M.bits.tpkt         = 0x1;
+        Carry2M.bits.tbyt         = 0x1;
+        Carry2M.bits.tfrg         = 0x1;
+        Carry2M.bits.tund         = 0x0;
+        Carry2M.bits.tovr         = 0x0;
+        Carry2M.bits.txcf         = 0x1;
+        Carry2M.bits.tfcs         = 0x1;
+        Carry2M.bits.tjbr         = 0x1;
+
+        pDevMacStat->Carry2M = Carry2M;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  ConfigFlowControl
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to configure the MAC STAT section of the JAGCore
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void ConfigFlowControl( ET131X_ADAPTER *pAdapter )
+{
+    if( pAdapter->uiDuplexMode == 0 )
+    {
+        pAdapter->FlowControl = None;
+    }
+    else
+    {
+        char RemotePause, RemoteAsyncPause;
+
+        ET1310_PhyAccessMiBit( pAdapter,
+                               TRUEPHY_BIT_READ, 5, 10, &RemotePause );
+        ET1310_PhyAccessMiBit( pAdapter,
+                               TRUEPHY_BIT_READ, 5, 11, &RemoteAsyncPause );
+
+        if(( RemotePause == TRUEPHY_BIT_SET ) &&
+           ( RemoteAsyncPause == TRUEPHY_BIT_SET ))
+        {
+            pAdapter->FlowControl = pAdapter->RegistryFlowControl;
+        }
+        else if(( RemotePause      == TRUEPHY_BIT_SET ) &&
+                ( RemoteAsyncPause == TRUEPHY_BIT_CLEAR ))
+        {
+            if( pAdapter->RegistryFlowControl == Both )
+            {
+                pAdapter->FlowControl = Both;
+            }
+            else
+            {
+                pAdapter->FlowControl = None;
+            }
+        }
+        else if(( RemotePause      == TRUEPHY_BIT_CLEAR ) &&
+                ( RemoteAsyncPause == TRUEPHY_BIT_CLEAR ))
+        {
+            pAdapter->FlowControl = None;
+        }
+        else /* if (( RemotePause      == TRUEPHY_CLEAR_BIT ) &&
+                    ( RemoteAsyncPause == TRUEPHY_SET_BIT )) */
+        {
+            if( pAdapter->RegistryFlowControl == Both )
+            {
+                pAdapter->FlowControl = RxOnly;
+            }
+            else
+            {
+                pAdapter->FlowControl = None;
+            }
+        }
+    }
+}
+/*===========================================================================*/
+
+
+
+
+
+
+/******************************************************************************
+   ROUTINE:  UpdateMacStatHostCounters
+ ******************************************************************************
+
+   DESCRIPTION:
+        used to update the local copy of the statistics held in the adapter
+        structure
+
+   PARAMETERS :
+        pAdapter - pointer to the adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void UpdateMacStatHostCounters( ET131X_ADAPTER *pAdapter )
+{
+    PMAC_STAT_t pDevMacStat;
+    /*-----------------------------------------------------------------------*/
+
+
+    /**************************************************************************
+       Get a local pointer to the adapter macstat regs and update stats
+     *************************************************************************/
+    pDevMacStat = &pAdapter->CSRAddress->macStat;
+
+    pAdapter->Stats.collisions              += pDevMacStat->TNcl;
+    pAdapter->Stats.first_collision         += pDevMacStat->TScl;
+    pAdapter->Stats.tx_deferred             += pDevMacStat->TDfr;
+    pAdapter->Stats.excessive_collisions    += pDevMacStat->TMcl;
+    pAdapter->Stats.late_collisions         += pDevMacStat->TLcl;
+    pAdapter->Stats.tx_uflo                 += pDevMacStat->TUnd;
+    pAdapter->Stats.max_pkt_error           += pDevMacStat->TOvr;
+
+    pAdapter->Stats.alignment_err           += pDevMacStat->RAln;
+    pAdapter->Stats.crc_err                 += pDevMacStat->RCde;
+    pAdapter->Stats.norcvbuf                += pDevMacStat->RDrp;
+    pAdapter->Stats.rx_ov_flow              += pDevMacStat->ROvr;
+    pAdapter->Stats.code_violations         += pDevMacStat->RFcs;
+    pAdapter->Stats.length_err              += pDevMacStat->RFlr;
+
+    pAdapter->Stats.other_errors            += pDevMacStat->RFrg;
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+
+/******************************************************************************
+   ROUTINE:  HandleMacStatInterrupt
+ ******************************************************************************
+
+   DESCRIPTION:
+        One of the MACSTAT counters has wrapped.  Update the local copy of
+        the statistics held in the adapter structure, checking the "wrap"
+        bit for each counter.
+
+   PARAMETERS :
+        pAdapter - pointer to the adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void HandleMacStatInterrupt( ET131X_ADAPTER *pAdapter )
+{
+    MAC_STAT_REG_1_t Carry1;
+    MAC_STAT_REG_2_t Carry2;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "HandleMacStatInterrupt" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Read the interrupt bits from the register(s).  These are Clear On Write.
+     *************************************************************************/
+    Carry1 = pAdapter->CSRAddress->macStat.Carry1;
+    Carry2 = pAdapter->CSRAddress->macStat.Carry2;
+
+    pAdapter->CSRAddress->macStat.Carry1 = Carry1;
+    pAdapter->CSRAddress->macStat.Carry2 = Carry2;
+
+
+    /**************************************************************************
+       We need to do update the host copy of all the MAC_STAT counters.  For
+       each counter, check it's overflow bit.  If the overflow bit is set, then
+       increment the host version of the count by one complete revolution of the
+       counter.  This routine is called when the counter block indicates that
+       one of the counters has wrapped.
+     *************************************************************************/
+    if( Carry1.bits.rfcs )
+    {
+        pAdapter->Stats.code_violations += COUNTER_WRAP_16_BIT;
+    }
+
+    if( Carry1.bits.raln )
+    {
+        pAdapter->Stats.alignment_err += COUNTER_WRAP_12_BIT;
+    }
+
+    if( Carry1.bits.rflr )
+    {
+        pAdapter->Stats.length_err += COUNTER_WRAP_16_BIT;
+    }
+
+    if( Carry1.bits.rfrg )
+    {
+        pAdapter->Stats.other_errors += COUNTER_WRAP_16_BIT;
+    }
+
+    if( Carry1.bits.rcde )
+    {
+        pAdapter->Stats.crc_err += COUNTER_WRAP_16_BIT;
+    }
+
+    if( Carry1.bits.rovr )
+    {
+        pAdapter->Stats.rx_ov_flow += COUNTER_WRAP_16_BIT;
+    }
+
+    if( Carry1.bits.rdrp )
+    {
+        pAdapter->Stats.norcvbuf += COUNTER_WRAP_16_BIT;
+    }
+
+    if( Carry2.bits.tovr )
+    {
+        pAdapter->Stats.max_pkt_error += COUNTER_WRAP_12_BIT;
+    }
+
+    if( Carry2.bits.tund )
+    {
+        pAdapter->Stats.tx_uflo += COUNTER_WRAP_12_BIT;
+    }
+
+    if( Carry2.bits.tscl )
+    {
+        pAdapter->Stats.first_collision += COUNTER_WRAP_12_BIT;
+    }
+
+    if( Carry2.bits.tdfr )
+    {
+        pAdapter->Stats.tx_deferred += COUNTER_WRAP_12_BIT;
+    }
+
+    if( Carry2.bits.tmcl )
+    {
+        pAdapter->Stats.excessive_collisions += COUNTER_WRAP_12_BIT;
+    }
+
+    if( Carry2.bits.tlcl )
+    {
+        pAdapter->Stats.late_collisions += COUNTER_WRAP_12_BIT;
+    }
+
+    if( Carry2.bits.tncl )
+    {
+        pAdapter->Stats.collisions += COUNTER_WRAP_12_BIT;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  SetupDeviceForMulticast
+ ******************************************************************************
+
+   DESCRIPTION       :
+        Use to set the ET1310 to do multicast filtering
+
+   PARAMETERS        :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS           :
+        NONE
+
+   REUSE INFORMATION :
+        NONE
+
+ *****************************************************************************/
+void SetupDeviceForMulticast( ET131X_ADAPTER *pAdapter )
+{
+    UINT32             nIndex;
+    UINT32             result;
+    RXMAC_MULTI_HASH_t hash1 = {0};
+    RXMAC_MULTI_HASH_t hash2 = {0};
+    RXMAC_MULTI_HASH_t hash3 = {0};
+    RXMAC_MULTI_HASH_t hash4 = {0};
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "SetupDeviceForMulticast" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       If ET131X_PACKET_TYPE_MULTICAST is specified, then we provision the
+       multi-cast LIST.  If it is NOT specified, (and "ALL" is not specified)
+       then we should pass NO multi-cast addresses to the driver.
+     *************************************************************************/
+    if( pAdapter->PacketFilter & ET131X_PACKET_TYPE_MULTICAST )
+    {
+        DBG_VERBOSE( et131x_dbginfo, "MULTICAST flag is set, MCCount: %d\n",
+                     pAdapter->MCAddressCount );
+
+
+        /**********************************************************************
+           Loop through our multicast array and set up the device
+        **********************************************************************/
+        for( nIndex = 0; nIndex < pAdapter->MCAddressCount; nIndex++ )
+        {
+            DBG_VERBOSE( et131x_dbginfo,
+                         "MCList[%d]: %02x:%02x:%02x:%02x:%02x:%02x\n",
+                         nIndex,
+                         pAdapter->MCList[nIndex][0],
+                         pAdapter->MCList[nIndex][1],
+                         pAdapter->MCList[nIndex][2],
+                         pAdapter->MCList[nIndex][3],
+                         pAdapter->MCList[nIndex][4],
+                         pAdapter->MCList[nIndex][5] );
+
+            result = et131x_calc_enet_crc( pAdapter->MCList[nIndex], 6 );
+
+            result = ( result & 0x3F800000 ) >> 23;
+
+            if( result < 32 )
+            {
+                hash1.hash |= ( 1 << result );
+            }
+            else if(( 31 < result ) && ( result < 64 ))
+            {
+                result -= 32;
+                hash2.hash |= ( 1 << result );
+            }
+            else if(( 63 < result ) && ( result < 96 ))
+            {
+                result -= 64;
+                hash3.hash |= ( 1 << result );
+            }
+            else
+            {
+                result -= 96;
+                hash4.hash |= ( 1 << result );
+            }
+        }
+    }
+
+
+    /**************************************************************************
+       Write out the new hash to the device
+     *************************************************************************/
+    if( pAdapter->CSRAddress->global.pm_csr.bits.pm_phy_sw_coma == 0 )
+    {
+    pAdapter->CSRAddress->rxmac.multi_hash1.hash = hash1.hash;
+    pAdapter->CSRAddress->rxmac.multi_hash2.hash = hash2.hash;
+    pAdapter->CSRAddress->rxmac.multi_hash3.hash = hash3.hash;
+    pAdapter->CSRAddress->rxmac.multi_hash4.hash = hash4.hash;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  SetupDeviceForUnicast
+ ******************************************************************************
+
+   DESCRIPTION       :
+        Use to set the ET1310 to do unicast filtering
+
+   PARAMETERS        :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS           :
+        NONE
+
+   REUSE INFORMATION :
+        NONE
+
+ *****************************************************************************/
+void SetupDeviceForUnicast( ET131X_ADAPTER *pAdapter )
+{
+    RXMAC_UNI_PF_ADDR1_t uni_pf1;
+    RXMAC_UNI_PF_ADDR2_t uni_pf2;
+    RXMAC_UNI_PF_ADDR3_t uni_pf3;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "SetupDeviceForUnicast" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Set up unicast packet filter reg 3 to be the first two octets of the
+       MAC address for both address
+     *************************************************************************/
+    /**************************************************************************
+       Set up unicast packet filter reg 2 to be the octets 2 - 5 of the
+       MAC address for second address
+     *************************************************************************/
+    /**************************************************************************
+       Set up unicast packet filter reg 3 to be the octets 2 - 5 of the
+       MAC address for first address
+     *************************************************************************/
+    uni_pf3.bits.addr1_1 = pAdapter->CurrentAddress[0];
+    uni_pf3.bits.addr1_2 = pAdapter->CurrentAddress[1];
+    uni_pf3.bits.addr2_1 = pAdapter->CurrentAddress[0];
+    uni_pf3.bits.addr2_2 = pAdapter->CurrentAddress[1];
+
+    uni_pf2.bits.addr2_3 = pAdapter->CurrentAddress[2];
+    uni_pf2.bits.addr2_4 = pAdapter->CurrentAddress[3];
+    uni_pf2.bits.addr2_5 = pAdapter->CurrentAddress[4];
+    uni_pf2.bits.addr2_6 = pAdapter->CurrentAddress[5];
+
+    uni_pf1.bits.addr1_3 = pAdapter->CurrentAddress[2];
+    uni_pf1.bits.addr1_4 = pAdapter->CurrentAddress[3];
+    uni_pf1.bits.addr1_5 = pAdapter->CurrentAddress[4];
+    uni_pf1.bits.addr1_6 = pAdapter->CurrentAddress[5];
+
+    if( pAdapter->CSRAddress->global.pm_csr.bits.pm_phy_sw_coma == 0 )
+    {
+        pAdapter->CSRAddress->rxmac.uni_pf_addr1 = uni_pf1;
+        pAdapter->CSRAddress->rxmac.uni_pf_addr2 = uni_pf2;
+        pAdapter->CSRAddress->rxmac.uni_pf_addr3 = uni_pf3;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
--- /dev/null
+++ b/drivers/net/et131x/ET1310_mac.h
@@ -0,0 +1,140 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_mac.h -  Defines, structs, enums, prototypes, etc. pertaining to the
+ *                 MAC.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:11 $
+     $Revision: 1.5 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef _ET1310_MAC_H_
+#define _ET1310_MAC_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+
+/******************************************************************************
+   INCLUDES
+ *****************************************************************************/
+#include "ET1310_common.h"
+
+
+
+
+/******************************************************************************
+   MACSTAT #defines
+ *****************************************************************************/
+#define COUNTER_WRAP_28_BIT 0x10000000
+#define COUNTER_WRAP_22_BIT 0x400000
+#define COUNTER_WRAP_16_BIT 0x10000
+#define COUNTER_WRAP_12_BIT 0x1000
+
+#define COUNTER_MASK_28_BIT (COUNTER_WRAP_28_BIT - 1)
+#define COUNTER_MASK_22_BIT (COUNTER_WRAP_22_BIT - 1)
+#define COUNTER_MASK_16_BIT (COUNTER_WRAP_16_BIT - 1)
+#define COUNTER_MASK_12_BIT (COUNTER_WRAP_12_BIT - 1)
+
+#define UPDATE_COUNTER(HostCnt,DevCnt) \
+    HostCnt = HostCnt + DevCnt;
+
+
+
+
+/******************************************************************************
+   Forward declaration of the private adapter structure
+ *****************************************************************************/
+struct et131x_adapter;
+
+
+/******************************************************************************
+   PROTOTYPES
+ *****************************************************************************/
+void ConfigMACRegs1( struct et131x_adapter *pAdapter );
+void ConfigMACRegs2( struct et131x_adapter *pAdapter );
+void ConfigRxMacRegs( struct et131x_adapter *pAdapter );
+void ConfigTxMacRegs( struct et131x_adapter *pAdapter );
+void ConfigMacStatRegs( struct et131x_adapter *pAdapter );
+void ConfigFlowControl( struct et131x_adapter *pAdapter );
+void UpdateMacStatHostCounters( struct et131x_adapter *pAdapter );
+void HandleMacStatInterrupt( struct et131x_adapter *pAdapter );
+void SetupDeviceForMulticast( struct et131x_adapter *pAdapter );
+void SetupDeviceForUnicast( struct et131x_adapter *pAdapter );
+
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* _ET1310_MAC_H_ */
--- /dev/null
+++ b/drivers/net/et131x/ET1310_phy.c
@@ -0,0 +1,2728 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_phy.c - Routines for configuring and accessing the PHY
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2006/01/20 21:29:44 $
+     $Revision: 1.13 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_netdev.h"
+#include "et131x_initpci.h"
+
+#include "ET1310_address_map.h"
+#include "ET1310_jagcore.h"
+#include "ET1310_tx.h"
+#include "ET1310_rx.h"
+#include "ET1310_mac.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   Prototypes for functions with local scope
+ *****************************************************************************/
+int et131x_xcvr_init( ET131X_ADAPTER *adapter );
+
+
+
+
+/******************************************************************************
+   ROUTINE :  MiRead
+ ******************************************************************************
+
+   DESCRIPTION       : Used to read from the PHY through the MII Interface on
+                       the MAC.
+
+   PARAMETERS        : adapter  - pointer to our private adapter structure
+                       xcvrAddr - the address of the transciever
+                       xcvrReg  - the register to read
+                       value    - pointer to a 16-bit value in which the value
+                                  will be stored.
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int MiRead( ET131X_ADAPTER *adapter, UINT8 xcvrAddr, UINT8 xcvrReg, UINT16 *value )
+{
+    int                 status = 0;
+	UINT32              delay;
+    MII_MGMT_ADDR_t     miiAddr;
+    MII_MGMT_CMD_t      miiCmd;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "MiRead" );
+
+
+    /**************************************************************************
+       Save a local copy of the registers we are dealing with so we can set
+       them back
+     *************************************************************************/
+    miiAddr.value = adapter->CSRAddress->mac.mii_mgmt_addr.value;
+    miiCmd.value  = adapter->CSRAddress->mac.mii_mgmt_cmd.value;
+
+
+    /**************************************************************************
+        Stop the current operation
+     *************************************************************************/
+    adapter->CSRAddress->mac.mii_mgmt_cmd.value = 0x0;
+
+
+    /**************************************************************************
+        Set up the register we need to read from on the correct PHY
+     *************************************************************************/
+    {
+        MII_MGMT_ADDR_t mii_mgmt_addr = {0};
+
+        mii_mgmt_addr.bits.phy_addr = xcvrAddr;
+        mii_mgmt_addr.bits.reg_addr = xcvrReg;
+
+        adapter->CSRAddress->mac.mii_mgmt_addr = mii_mgmt_addr;
+    }
+
+
+    /**************************************************************************
+        Kick the read cycle off
+     *************************************************************************/
+    delay = 0;
+
+    adapter->CSRAddress->mac.mii_mgmt_cmd.value = 0x1;
+
+    do
+    {
+        udelay( 50 );
+        delay++;
+    } while(( adapter->CSRAddress->mac.mii_mgmt_indicator.bits.not_valid ||
+              adapter->CSRAddress->mac.mii_mgmt_indicator.bits.busy ) &&
+            ( delay < 50 ));
+
+
+    /**************************************************************************
+        If we hit the max delay, we could not read the register
+     *************************************************************************/
+	if( delay >= 50 )
+    {
+        DBG_WARNING( et131x_dbginfo, "xcvrReg 0x%08x could not be read\n", xcvrReg );
+        DBG_WARNING( et131x_dbginfo, "status is  0x%08x\n",
+                     adapter->CSRAddress->mac.mii_mgmt_indicator.value );
+
+        status = -EIO;
+    }
+
+
+    /**************************************************************************
+       If we hit here we were able to read the register and we need to return
+       the value to the caller
+     *************************************************************************/
+    *value = (UINT16)adapter->CSRAddress->mac.mii_mgmt_stat.bits.phy_stat;
+
+
+    /**************************************************************************
+        Stop the read operation
+     *************************************************************************/
+    adapter->CSRAddress->mac.mii_mgmt_cmd.value = 0x0;
+
+    DBG_VERBOSE( et131x_dbginfo, "  xcvr_addr = 0x%02x, "
+					             "xcvr_reg  = 0x%02x, "
+					             "value     = 0x%04x.\n",
+					             xcvrAddr, xcvrReg, *value );
+
+
+    /**************************************************************************
+       set the registers we touched back to the state at which we entered
+       this function
+     *************************************************************************/
+    adapter->CSRAddress->mac.mii_mgmt_addr.value = miiAddr.value;
+    adapter->CSRAddress->mac.mii_mgmt_cmd.value  = miiCmd.value;
+
+
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  MiWrite
+ ******************************************************************************
+
+   DESCRIPTION       : Used to write to a PHY register through the MII
+                       interface of the MAC. Updated for the ET1310.
+
+   PARAMETERS        : adapter  - pointer to our private adapter structure
+                       xcvrAddr - the address of the transciever
+                       xcvrReg  - the register to read
+                       value    - 16-bit value to write
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int MiWrite( ET131X_ADAPTER *adapter, UINT8 xcvrAddr, UINT8 xcvrReg, UINT16 value )
+{
+    int             status = 0;
+	UINT32          delay;
+    MII_MGMT_ADDR_t miiAddr;
+    MII_MGMT_CMD_t  miiCmd;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "MiWrite" );
+
+
+    /**************************************************************************
+       Save a local copy of the registers we are dealing with so we can set
+       them back
+     *************************************************************************/
+    miiAddr.value = adapter->CSRAddress->mac.mii_mgmt_addr.value;
+    miiCmd.value  = adapter->CSRAddress->mac.mii_mgmt_cmd.value;
+
+
+    /**************************************************************************
+       Stop the current operation
+     *************************************************************************/
+    adapter->CSRAddress->mac.mii_mgmt_cmd.value = 0x0;
+
+
+    /**************************************************************************
+       Set up the register we need to write to on the correct PHY
+     *************************************************************************/
+    {
+        MII_MGMT_ADDR_t mii_mgmt_addr = {0};
+
+        mii_mgmt_addr.bits.phy_addr = xcvrAddr;
+        mii_mgmt_addr.bits.reg_addr = xcvrReg;
+
+        adapter->CSRAddress->mac.mii_mgmt_addr = mii_mgmt_addr;
+    }
+
+
+    /**************************************************************************
+       Add the value to write to the registers to the mac
+     *************************************************************************/
+    adapter->CSRAddress->mac.mii_mgmt_ctrl.value = value;
+    delay = 0;
+
+    do
+    {
+        udelay( 50 );
+        delay++;
+    } while(( adapter->CSRAddress->mac.mii_mgmt_indicator.bits.busy ) &&
+            ( delay < 100 ));
+
+
+    /**************************************************************************
+       If we hit the max delay, we could not write the register
+     *************************************************************************/
+	if( delay == 100 )
+    {
+        UINT16 TempValue;
+
+        DBG_WARNING( et131x_dbginfo, "xcvrReg 0x%08x could not be written",
+                     xcvrReg );
+        DBG_WARNING( et131x_dbginfo, "status is  0x%08x\n",
+                     adapter->CSRAddress->mac.mii_mgmt_indicator.value );
+        DBG_WARNING( et131x_dbginfo, "command is  0x%08x\n",
+                     adapter->CSRAddress->mac.mii_mgmt_cmd.value );
+
+        MiRead( adapter, xcvrAddr, xcvrReg, &TempValue );
+
+        status = -EIO;
+    }
+
+
+    /**************************************************************************
+       Stop the write operation
+     *************************************************************************/
+    adapter->CSRAddress->mac.mii_mgmt_cmd.value = 0x0;
+
+
+    /**************************************************************************
+       set the registers we touched back to the state at which we entered
+       this function
+     *************************************************************************/
+    adapter->CSRAddress->mac.mii_mgmt_addr.value = miiAddr.value;
+    adapter->CSRAddress->mac.mii_mgmt_cmd.value  = miiCmd.value;
+
+
+    DBG_VERBOSE( et131x_dbginfo, " xcvr_addr = 0x%02x, "
+					             "xcvr_reg  = 0x%02x, "
+					             "value     = 0x%04x.\n",
+					             xcvrAddr, xcvrReg, value );
+
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_xcvr_find
+ ******************************************************************************
+
+   DESCRIPTION       : Used to find the PHY ID
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_xcvr_find( ET131X_ADAPTER *adapter )
+{
+    int           status = -ENODEV;
+    UINT8         xcvr_addr;
+	MI_IDR1_t     idr1;
+	MI_IDR2_t     idr2;
+	UINT32        xcvr_id;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_xcvr_find" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       We need to get xcvr id and address we just get the first one
+     *************************************************************************/
+    for( xcvr_addr = 0; xcvr_addr < 32; xcvr_addr++ )
+    {
+        /**********************************************************************
+           Read the ID from the PHY
+         *********************************************************************/
+        MiRead( adapter, xcvr_addr, (u8)offsetof(MI_REGS_t, idr1), &idr1.value );
+        MiRead( adapter, xcvr_addr, (u8)offsetof(MI_REGS_t, idr2), &idr2.value );
+
+        xcvr_id = (UINT32)(( idr1.value << 16 ) | idr2.value );
+
+        if(( idr1.value != 0) && ( idr1.value != 0xffff ))
+        {
+            DBG_TRACE( et131x_dbginfo, "Xcvr addr: 0x%02x\tXcvr_id: 0x%08x\n",
+                       xcvr_addr, xcvr_id );
+
+            adapter->Stats.xcvr_id   = xcvr_id;
+            adapter->Stats.xcvr_addr = (UINT32)xcvr_addr;
+
+            status = 0;
+            break;
+        }
+	}
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_setphy_normal
+ ******************************************************************************
+
+   DESCRIPTION       : Used by Power Management to force the PHY into 10 Base T
+                       half-duplex mode, when going to D3 in WOL mode. Also
+                       used during initialization to set the PHY for normal
+                       operation.
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_setphy_normal( ET131X_ADAPTER *adapter )
+{
+    int status;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_setphy_normal" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Make sure the PHY is powered up
+     *************************************************************************/
+    ET1310_PhyPowerDown( adapter, 0 );
+    status = et131x_xcvr_init( adapter );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_xcvr_init
+ ******************************************************************************
+
+   DESCRIPTION       : Used to init the phy if we are setting it into force mode
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_xcvr_init( ET131X_ADAPTER *adapter )
+{
+    int         status = 0;
+    MI_IMR_t    imr;
+    MI_ISR_t    isr;
+    MI_LCR2_t   lcr2;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_xcvr_init" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+        Zero out the adapter structure variable representing BMSR
+     *************************************************************************/
+    adapter->Bmsr.value = 0;
+
+    MiRead( adapter, (UINT8)adapter->Stats.xcvr_addr,
+            (UINT8)offsetof( MI_REGS_t, isr ), &isr.value );
+
+    MiRead( adapter, (UINT8)adapter->Stats.xcvr_addr,
+            (UINT8)offsetof( MI_REGS_t, imr ), &imr.value );
+
+
+    /**************************************************************************
+       Set the link status interrupt only.  Bad behavior when link status and
+       auto neg are set, we run into a nested interrupt problem
+     *************************************************************************/
+    imr.bits.int_en         = 0x1;
+    imr.bits.link_status    = 0x1;
+    imr.bits.autoneg_status = 0x1;
+
+    MiWrite( adapter, (UINT8)adapter->Stats.xcvr_addr,
+             (UINT8)offsetof( MI_REGS_t, imr ), imr.value );
+
+
+    /**************************************************************************
+       Set the LED behavior such that LED 1 indicates speed (off = 10Mbits,
+       blink = 100Mbits, on = 1000Mbits) and LED 2 indicates link and
+       activity (on for link, blink off for activity).
+
+       NOTE: Some customizations have been added here for specific vendors;
+       The LED behavior is now determined by vendor data in the EEPROM. However,
+       the above description is the default.
+     *************************************************************************/
+    if(( adapter->eepromData[1] & 0x4 ) == 0 )
+    {
+        MiRead( adapter, (UINT8)adapter->Stats.xcvr_addr,
+                (UINT8)offsetof( MI_REGS_t, lcr2 ), &lcr2.value );
+
+        if(( adapter->eepromData[1] & 0x8 ) == 0 )
+        {
+            lcr2.bits.led_tx_rx = 0x3;
+        }
+        else
+        {
+            lcr2.bits.led_tx_rx = 0x4;
+        }
+
+        lcr2.bits.led_link = 0xa;
+
+        MiWrite( adapter, (UINT8)adapter->Stats.xcvr_addr,
+                (UINT8)offsetof( MI_REGS_t, lcr2 ), lcr2.value );
+    }
+
+
+    /**************************************************************************
+       Determine if we need to go into a force mode and set it
+     *************************************************************************/
+    if( adapter->AiForceSpeed == 0 && adapter->AiForceDpx == 0 )
+    {
+        if(( adapter->RegistryFlowControl == TxOnly ) ||
+            ( adapter->RegistryFlowControl == Both ))
+        {
+            ET1310_PhyAccessMiBit( adapter,
+                                    TRUEPHY_BIT_SET, 4, 11, NULL );
+        }
+        else
+        {
+            ET1310_PhyAccessMiBit( adapter,
+                                    TRUEPHY_BIT_CLEAR, 4, 11, NULL );
+        }
+
+        if( adapter->RegistryFlowControl == Both )
+        {
+            ET1310_PhyAccessMiBit( adapter,
+                                    TRUEPHY_BIT_SET, 4, 10, NULL );
+        }
+        else
+        {
+            ET1310_PhyAccessMiBit( adapter,
+                                    TRUEPHY_BIT_CLEAR, 4, 10, NULL );
+        }
+
+
+        /**********************************************************************
+           Set the phy to autonegotiation
+         *********************************************************************/
+        ET1310_PhyAutoNeg( adapter, TRUE );
+
+
+        /* NOTE - Do we need this? */
+        ET1310_PhyAccessMiBit( adapter,
+                               TRUEPHY_BIT_SET, 0, 9, NULL );
+
+        DBG_LEAVE( et131x_dbginfo );
+        return status;
+    }
+    else
+    {
+        ET1310_PhyAutoNeg( adapter, FALSE );
+
+        /**********************************************************************
+           Set to the correct force mode.
+         *********************************************************************/
+        if( adapter->AiForceDpx != 1 )
+        {
+            if(( adapter->RegistryFlowControl == TxOnly ) ||
+               ( adapter->RegistryFlowControl == Both ))
+            {
+                ET1310_PhyAccessMiBit( adapter,
+                                       TRUEPHY_BIT_SET, 4, 11, NULL );
+            }
+            else
+            {
+                ET1310_PhyAccessMiBit( adapter,
+                                       TRUEPHY_BIT_CLEAR, 4, 11, NULL );
+            }
+
+            if( adapter->RegistryFlowControl == Both )
+            {
+                ET1310_PhyAccessMiBit( adapter,
+                                       TRUEPHY_BIT_SET, 4, 10, NULL );
+            }
+            else
+            {
+                ET1310_PhyAccessMiBit( adapter,
+                                       TRUEPHY_BIT_CLEAR, 4, 10, NULL );
+            }
+        }
+        else
+        {
+            ET1310_PhyAccessMiBit( adapter,
+                                   TRUEPHY_BIT_CLEAR, 4, 10, NULL );
+            ET1310_PhyAccessMiBit( adapter,
+                                   TRUEPHY_BIT_CLEAR, 4, 11, NULL );
+        }
+
+        switch( adapter->AiForceSpeed )
+        {
+        case 10:
+            if( adapter->AiForceDpx == 1 )
+            {
+                TPAL_SetPhy10HalfDuplex( adapter );
+            }
+            else if( adapter->AiForceDpx == 2 )
+            {
+                TPAL_SetPhy10FullDuplex( adapter );
+            }
+            else
+            {
+                TPAL_SetPhy10Force( adapter );
+            }
+            break;
+
+        case 100:
+            if( adapter->AiForceDpx == 1 )
+            {
+                TPAL_SetPhy100HalfDuplex( adapter );
+            }
+            else if( adapter->AiForceDpx == 2 )
+            {
+                TPAL_SetPhy100FullDuplex( adapter );
+            }
+            else
+            {
+                TPAL_SetPhy100Force( adapter );
+            }
+            break;
+
+        case 1000:
+            TPAL_SetPhy1000FullDuplex( adapter );
+            break;
+        }
+
+
+        DBG_LEAVE( et131x_dbginfo );
+        return status;
+    }
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_Mii_check
+ ******************************************************************************
+
+ DESCRIPTION:
+    used to
+
+ PARAMETERS :
+    pAdapter - pointer to our adapter
+    bmsr   -
+
+ RETURNS    :
+    Nothing
+
+ *****************************************************************************/
+void et131x_Mii_check( ET131X_ADAPTER *pAdapter,
+                       MI_BMSR_t bmsr,
+                       MI_BMSR_t bmsr_ints )
+{
+    UCHAR    ucLinkStatus;
+    INT32    nAutoNegStatus;
+    INT32    nSpeed;
+    INT32    nDuplex;
+    INT32    nMdiMdix;
+    INT32    nMasterSlave;
+    INT32    nPolarity;
+    unsigned long lockflags;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_Mii_check" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    if( bmsr_ints.bits.link_status )
+	{
+		if( bmsr.bits.link_status )
+		{
+            pAdapter->PoMgmt.TransPhyComaModeOnBoot = 20;
+
+
+            /******************************************************************
+               Update our state variables and indicate the connected state
+             *****************************************************************/
+            spin_lock_irqsave( &pAdapter->Lock, lockflags );
+
+            pAdapter->MediaState = NETIF_STATUS_MEDIA_CONNECT;
+            MP_CLEAR_FLAG( pAdapter, fMP_ADAPTER_LINK_DETECTION );
+
+            spin_unlock_irqrestore( &pAdapter->Lock, lockflags );
+
+            if( pAdapter->RegistryPhyLoopbk == FALSE )
+            {
+                /**************************************************************
+                    Don't indicate state if we're in loopback mode
+                 *************************************************************/
+                netif_indicate_status( pAdapter->netdev, pAdapter->MediaState );
+            }
+		}
+		else
+		{
+            DBG_WARNING( et131x_dbginfo, "Link down cable problem\n" );
+
+            if( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_10MBPS )
+            {
+                // NOTE - Is there a way to query this without TruePHY?
+                //if( TRU_QueryCoreType ( pAdapter->hTruePhy, 0 ) == EMI_TRUEPHY_A13O )
+                {
+                    UINT16 Register18;
+
+                    MiRead( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                                                           0x12, &Register18 );
+                    MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                                                      0x12, Register18 | 0x4 );
+                    MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                                                   0x10, Register18 | 0x8402 );
+                    MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                                                      0x11, Register18 | 511 );
+                    MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                                                            0x12, Register18 );
+                }
+            }
+
+            /******************************************************************
+                For the first N seconds of life, we are in "link detection"
+                When we are in this state, we should only report "connected".
+                When the LinkDetection Timer expires, we can report
+                disconnected (handled in the LinkDetectionDPC).
+             *****************************************************************/
+            if(( MP_IS_FLAG_CLEAR( pAdapter, fMP_ADAPTER_LINK_DETECTION )) ||
+               ( pAdapter->MediaState == NETIF_STATUS_MEDIA_DISCONNECT ))
+            {
+                spin_lock_irqsave( &pAdapter->Lock, lockflags );
+                pAdapter->MediaState = NETIF_STATUS_MEDIA_DISCONNECT;
+                spin_unlock_irqrestore( &pAdapter->Lock, lockflags );
+
+                /**************************************************************
+                   Only indicate state if we're in loopback mode
+                 *************************************************************/
+                if( pAdapter->RegistryPhyLoopbk == FALSE )
+                {
+                    netif_indicate_status( pAdapter->netdev, pAdapter->MediaState );
+                }
+            }
+
+            pAdapter->uiLinkSpeed  = 0;
+            pAdapter->uiDuplexMode = 0;
+
+
+			/******************************************************************
+			   Free the packets being actively sent & stopped
+			 *****************************************************************/
+			et131x_free_busy_send_packets( pAdapter );
+
+
+            /******************************************************************
+			   Re-initialize the send structures
+			 *****************************************************************/
+			et131x_init_send( pAdapter );
+
+
+			/******************************************************************
+			   Reset the RFD list and re-start RU
+			 *****************************************************************/
+			et131x_reset_recv( pAdapter );
+
+
+			/******************************************************************
+			   Bring the device back to the state it was during init prior
+               to autonegotiation being complete.  This way, when we get the
+               auto-neg complete interrupt, we can complete init by calling
+               ConfigMacREGS2.
+			 *****************************************************************/
+			et131x_soft_reset( pAdapter );
+
+
+            /******************************************************************
+               Setup ET1310 as per the documentation
+             *****************************************************************/
+            et131x_adapter_setup( pAdapter );
+
+
+            /******************************************************************
+               Setup the PHY into coma mode until the cable is plugged back in
+             *****************************************************************/
+            if( pAdapter->RegistryPhyComa == 1 )
+            {
+                EnablePhyComa( pAdapter );
+            }
+		}
+	}
+
+    if( bmsr_ints.bits.auto_neg_complete ||
+        (( pAdapter->AiForceDpx == 3 ) && ( bmsr_ints.bits.link_status )))
+    {
+        if( bmsr.bits.auto_neg_complete  ||
+           ( pAdapter->AiForceDpx == 3 ))
+        {
+            ET1310_PhyLinkStatus( pAdapter,
+                                  &ucLinkStatus,
+                                  &nAutoNegStatus,
+                                  &nSpeed,
+                                  &nDuplex,
+                                  &nMdiMdix,
+                                  &nMasterSlave,
+                                  &nPolarity );
+
+
+            pAdapter->uiLinkSpeed  = nSpeed;
+            pAdapter->uiDuplexMode = nDuplex;
+
+            DBG_TRACE( et131x_dbginfo,
+                       "pAdapter->uiLinkSpeed 0x%04x, pAdapter->uiDuplex 0x%08x\n",
+                       pAdapter->uiLinkSpeed, pAdapter->uiDuplexMode );
+
+            pAdapter->PoMgmt.TransPhyComaModeOnBoot = 20;
+
+            if( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_10MBPS )
+            {
+                // NOTE - Is there a way to query this without TruePHY?
+                //if( TRU_QueryCoreType ( pAdapter->hTruePhy, 0 ) == EMI_TRUEPHY_A13O )
+                {
+                    UINT16 Register18;
+
+                    MiRead( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                                                           0x12, &Register18 );
+                    MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                                                      0x12, Register18 | 0x4 );
+                    MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                                                   0x10, Register18 | 0x8402 );
+                    MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                                                      0x11, Register18 | 511 );
+                    MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                                                            0x12, Register18 );
+                }
+            }
+
+            ConfigFlowControl( pAdapter );
+
+
+            if(( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS ) &&
+                ( pAdapter->RegistryJumboPacket > 2048 ))
+
+            {
+                ET1310_PhyAndOrReg( pAdapter, 0x16, 0xcfff, 0x2000 );
+            }
+
+            SetRxDmaTimer( pAdapter );
+            ConfigMACRegs2( pAdapter );
+        }
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  TPAL_MiAccessRegs
+ ******************************************************************************
+
+   DESCRIPTION       : Used to perform a single or series of MI Register
+                       transactions on the specified PHY
+
+   PARAMETERS        : hPlatform      - handle to platform resources
+                       nPhyId         - logical PHY ID (if >= 0) or
+                                        logical PHY group ID (if <0)
+                       pbyAccessFlags - Pointer to a list of flags, which
+                                        specify the transaction type associated
+                                        with each register contained in the
+                                        'pbyRegisters' array.  Valid values:
+                                            TRUEPHY_READ
+                                            TRUEPHY_WRITE
+                                            TRUEPHY_MASK
+                                        If a logical PHY Group ID is specified
+                                        in 'nPhyId', the value of these flags
+                                        must be TRUEPHY_WRITE
+                       pbyRegisters   - Pointer to a list of MI registers
+                                        addressess (0-31), one of each register
+                                        specified by 'nRegCount'
+                       pwData         - Pointer to a buffer that contains the
+                                        data required by or resulting from each
+                                        transaction, the contents of which are
+                                        dependent upon the 'pbyAccessFlags'
+                                        parameter. Specifically:
+
+                                        If 'pbyAccessFlags[i]' is TRUEPHY_READ,
+                                        the contents of the register specified
+                                        by 'pbyRegisters[i]' is read and stored
+                                        in 'pwData[i]'.
+
+                                        If 'pbyAccessFlags[i]' is TRUEPHY_WRITE,
+                                        the contents of 'pwData[i]' is written
+                                        to the register specified by
+                                        'pbyRegisters[i]'.
+
+                                        If 'pbyAccessFlags[i]' is TRUEPHY_MASK,
+                                        the contents of the register specified
+                                        by 'pbyRegisters[i]' is read and stored
+                                        in 'pwData [i]', which is then
+                                        logically AND'ed with the contents of
+                                        'pwAndMasks[i]' and logically OR'ed
+                                        with the contents of 'pwOrMasks[i]'
+                                        before it is written back to the
+                                        register specified by 'pbyRegisters[i]'
+
+                                        This allows the calling function to
+                                        interleave a register read, logical
+                                        and/or, and write operation within a
+                                        single transaction.
+
+                        pwAndMasks    - Pointer to buffer containing AND masks,
+                                        which is required if the corresponding
+                                        transaction type is TRUEPHY_MASK;
+                                        otherwise, this parameter is ignored.
+                        pwOrMasks     - Pointer to buffer containing OR masks,
+                                        which is required if the corresponding
+                                        transaction type is TRUEPHY_MASK;
+                                        otherwise, this parameter is ignored.
+                        nRegCount     - Specifies the number of register
+                                        transactions to be performed.
+
+   RETURNS           :  TRUEPHY_SUCCESS
+                        TRUEPHY_FAILURE
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+INT32 TPAL_MiAccessRegs( TPAL_HANDLE hPlatform,
+                         INT32       nPhyId,
+                         PUCHAR      pbyAccessFlags,
+                         PUCHAR      pbyRegisters,
+                         PUINT16     pwData,
+                         PUINT16     pwAndMasks,
+                         PUINT16     pwOrMasks,
+                         INT32       nRegCount )
+{
+    INT32           nStatus   = TRUEPHY_FAILURE;
+    INT32           index;
+    INT16           wTemp;
+    UINT8           xcvrAddr;
+    ET131X_ADAPTER *pAdapter  = hPlatform;
+    unsigned long   lockflags;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "TPAL_MiAccessRegs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Validate Input parameters.  We are not worried about nPhyId because we
+       can only access the one we control
+     *************************************************************************/
+    if( pbyAccessFlags != NULL && pwData != NULL )
+    {
+        /**********************************************************************
+           Convert nPhyId into a PHY physical address(nPhyAddress)
+         *********************************************************************/
+
+
+        /**********************************************************************
+           Convert nPhyId into a MI bus address (nBusAddress).
+
+           NOTE: This is only needed for platforms that support multiple MI
+                 buses
+         *********************************************************************/
+
+
+        /**********************************************************************
+           Get the xcvr addr for all transactions to go to
+         *********************************************************************/
+        xcvrAddr = (UINT8)pAdapter->Stats.xcvr_addr;
+
+
+        /**********************************************************************
+           Go through all registers performing specific transaction indicated
+           in the corresponding pbyAccessFlags array.
+         *********************************************************************/
+        for( index = 0; index < nRegCount; index++ )
+        {
+            /******************************************************************
+               Validate MI register
+             *****************************************************************/
+            if( pbyRegisters[index] > 31 )
+            {
+                break;
+            }
+
+
+            /******************************************************************
+               Is this a read?
+             *****************************************************************/
+            if( pbyAccessFlags[index] == TRUEPHY_READ )
+            {
+                /**************************************************************
+                   Group reads are not allowed
+                 *************************************************************/
+                if( nPhyId < 0 )
+                {
+                    break;
+                }
+
+
+                /**************************************************************
+                   Make sure we acquire the spin lock
+                 *************************************************************/
+                spin_lock_irqsave( &pAdapter->PHYLock, lockflags );
+
+
+                /**************************************************************
+                   Let's perform the read operation
+                 *************************************************************/
+                MiRead( pAdapter, xcvrAddr, pbyRegisters[index],
+                        (PUINT16)&pwData[index] );
+
+                spin_unlock_irqrestore( &pAdapter->PHYLock, lockflags );
+
+            }
+            else if( pbyAccessFlags[index] == TRUEPHY_WRITE )
+            {
+                /**************************************************************
+                   Make sure we acquire the spin lock
+                 *************************************************************/
+                spin_lock_irqsave( &pAdapter->PHYLock, lockflags );
+
+
+                /**************************************************************
+                   Let's perform the write operation
+                 *************************************************************/
+                MiWrite( pAdapter, xcvrAddr, pbyRegisters[index],
+                         (UINT16)pwData[index] );
+
+                spin_unlock_irqrestore( &pAdapter->PHYLock, lockflags );
+            }
+            else if( pbyAccessFlags[index] == TRUEPHY_MASK )
+            {
+                /**************************************************************
+                   Group masks are not allowed
+                 *************************************************************/
+                if( nPhyId < 0 )
+                {
+                    break;
+                }
+
+                /**************************************************************
+                   Pointer to AND and OR masks must not be NULL
+                 *************************************************************/
+                if(( pwOrMasks == NULL ) || ( pwAndMasks == NULL ))
+                {
+                    break;
+                }
+
+                /**************************************************************
+                   Make sure we acquire the spin lock
+                 *************************************************************/
+                spin_lock_irqsave( &pAdapter->PHYLock, lockflags );
+
+
+                /**************************************************************
+                   Perform read
+                 *************************************************************/
+                MiRead( pAdapter, xcvrAddr, pbyRegisters[index],
+                        (PUINT16)&pwData[index] );
+
+
+                /**************************************************************
+                   Perform and/or masks and write it back
+                 *************************************************************/
+                wTemp = (( pwData[index] & pwAndMasks[index] ) |
+                           pwOrMasks[index] );
+
+                MiWrite( pAdapter, xcvrAddr, pbyRegisters[index],
+                         (UINT16)wTemp );
+
+                spin_unlock_irqrestore( &pAdapter->PHYLock, lockflags );
+            }
+            else
+            {
+                /**************************************************************
+                   Invalid transaction type, just break out of the loop
+                 *************************************************************/
+                break;
+            }
+        }//end for loop
+
+        /**********************************************************************
+           If we completed all the transactions, indicate success
+         *********************************************************************/
+        if( index == nRegCount )
+        {
+            nStatus = TRUEPHY_SUCCESS;
+        }
+    }//end if
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return nStatus;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  TPAL_PlatformExit
+ ******************************************************************************
+
+   DESCRIPTION       : Used to exit the TRUEPHY library which will de-allocate
+                       any system resources allocated.
+
+   PARAMETERS        : hPlatform - handle to the platform resources
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+
+void TPAL_PlatformExit( TRUEPHY_OSAL_HANDLE hPlatform )
+{
+    DBG_FUNC( "TPAL_PlatformExit" );
+    DBG_ENTER( et131x_dbginfo );
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+////                         OS Specific Functions                         ////
+///////////////////////////////////////////////////////////////////////////////
+/******************************************************************************
+   ROUTINE :  TPAL_AllocMem
+ ******************************************************************************
+
+   DESCRIPTION       : Used so the TRUEPHY library can allocate memory
+
+   PARAMETERS        : ulNumBytes - number of bytes to allocate
+
+   RETURNS           : pointer to allocated memory block on success, or
+                       NULL on failure
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void * TPAL_AllocMem( TRUEPHY_OSAL_HANDLE hPlatform, u_long ulNumBytes )
+{
+    void     *pBuffer = NULL;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "TPAL_AllocMem" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    pBuffer = kmalloc( ulNumBytes, GFP_ATOMIC );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return pBuffer;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  TPAL_FreeMem
+ ******************************************************************************
+
+   DESCRIPTION       : Used to free a previously allocated block of memory
+
+   PARAMETERS        : pMemBlock - the pointer to the buffer to free
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void TPAL_FreeMem( TRUEPHY_OSAL_HANDLE hPlatform, void *pMemBlock )
+{
+    DBG_FUNC( "TPAL_FreeMem" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    kfree( pMemBlock );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_Sleep
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to delay execution for a specified number of milliseconds
+
+   PARAMETERS :
+        ulMsec - Number of milliseconds to delay.  This parameter can be zero
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void TPAL_Sleep( TRUEPHY_OSAL_HANDLE hPlatform, u_long ulMsec )
+{
+    DBG_FUNC( "TPAL_Sleep" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    mdelay( ulMsec );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_GetSystemUpTime
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to get the numberr of milliseconds that have elapsed since the
+        system was started
+
+   PARAMETERS :
+        NONE
+
+   RETURNS    :
+        number of milliseconds since system was started
+
+ *****************************************************************************/
+u_long TPAL_GetSystemUpTime( TRUEPHY_OSAL_HANDLE hPlatform )
+{
+    UINT32 uptime;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "TPAL_GetSystemUpTime" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    uptime = 10 * jiffies / HZ;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return uptime;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_GetLinkStatusInfo
+ ******************************************************************************
+
+   DESCRIPTION:
+        used to determine what link speed and duplex the phy is set to
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void TPAL_GetLinkStatusInfo( ET131X_ADAPTER *pAdapter )
+{
+    UINT32 index = 0;
+    INT32  MdiMdix;
+    INT32  MasterSlave;
+    INT32  Polarity;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "TPAL_GetLinkStatusInfo" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Get the link status information from the phy.  Loop until the
+       autonegstatus is complete or link status is up.
+
+       If looping for 50 uSec, break out, we have a problem
+     *************************************************************************/
+    do
+    {
+        ET1310_PhyLinkStatus( pAdapter,
+                                  &pAdapter->ucLinkStatus,
+                                  &pAdapter->uiAutoNegStatus,
+                                  &pAdapter->uiLinkSpeed,
+                                  &pAdapter->uiDuplexMode,
+                                  &MdiMdix,
+                                  &MasterSlave,
+                                  &Polarity );
+
+        DBG_VERBOSE( et131x_dbginfo,
+                     "uiAutoNegStatus 0x%08x ucLinkStatus 0x%04x\n "
+                     "uiLinkSpeed 0x%04x, uiDuplexMode 0x%08x\n",
+                     pAdapter->uiAutoNegStatus,
+                     pAdapter->ucLinkStatus,
+                     pAdapter->uiLinkSpeed,
+                     pAdapter->uiDuplexMode );
+
+        udelay( 100 );
+        index++;
+
+        if( index == 10000 )
+        {
+            /******************************************************************
+               We hit our limit, we need to set a variable so during power
+               management we know to try 100/half
+             *****************************************************************/
+            pAdapter->PoMgmt.Failed10Half = TRUE;
+            break;
+        }
+    } while( pAdapter->uiAutoNegStatus != TRUEPHY_ANEG_COMPLETE  ||
+             pAdapter->ucLinkStatus == 0 );
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_SetPhy10HalfDuplex
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to force the phy into 10 Base T Half Duplex mode.  Also sets the
+        MAC so it is syncd up properly
+
+   PARAMETERS :
+        pAdapter - pointer to the adapter structure
+
+   RETURNS    :
+        TRUEPHY_SUCCESS - if everything goes according to plan
+        TRUEPHY_FALIURE  -if something goes wrong
+
+ *****************************************************************************/
+INT32 TPAL_SetPhy10HalfDuplex( ET131X_ADAPTER *pAdapter )
+{
+    INT32   returnValue = TRUEPHY_SUCCESS;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "TPAL_SetPhy10HalfDuplex" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Power down PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 1 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power down the PHY\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+    /**************************************************************************
+       First we need to turn off all other advertisement
+     *************************************************************************/
+    ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not turn off advertisement of 1000 BaseT\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+    ET1310_PhyAdvertise100BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not turn off advertisement of 100 BaseT "
+                   "for forcing 10 BaseT Half Duplex\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+        Set our advertise values accordingly
+     *************************************************************************/
+    ET1310_PhyAdvertise10BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_HALF );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not set Advertise of 10 Half\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+    /**************************************************************************
+       Power up PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 0 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power up the PHY\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return returnValue ;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_SetPhy10FullDuplex
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to force the phy into 10 Base T Full Duplex mode.  Also sets the
+        MAC so it is syncd up properly
+
+   PARAMETERS :
+        pAdapter - pointer to the adapter structure
+
+   RETURNS    :
+        TRUEPHY_SUCCESS - if everything goes according to plan
+        TRUEPHY_FALIURE  -if somethign goes wrong during the procedures
+
+ *****************************************************************************/
+INT32 TPAL_SetPhy10FullDuplex( ET131X_ADAPTER *pAdapter )
+{
+    INT32   returnValue = TRUEPHY_SUCCESS;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "TPAL_SetPhy10FullDuplex" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Power down PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 1 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power down the PHY\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+        First we need to turn off all other advertisement
+     *************************************************************************/
+    ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not turn off advertisement of 1000 BaseT "
+                   "for Forcing 10 BaseT Full Duplex\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+    ET1310_PhyAdvertise100BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not turn off advertisement of 100 BaseT "
+                   "for Forcing 10 BaseT Full Duplex\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+        Set our advertise values accordingly
+     *************************************************************************/
+    ET1310_PhyAdvertise10BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_FULL );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not set Advertise of 10 Full\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+       Power up PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 0 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power up the phy\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return returnValue;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_SetPhy10Force
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to force the phy into 10 Base T Full Duplex mode WITHOUT using
+        autonegotiation.
+
+   PARAMETERS :
+        pAdapter - pointer to the adapter structure
+
+   RETURNS    :
+
+ *****************************************************************************/
+void TPAL_SetPhy10Force( ET131X_ADAPTER *pAdapter )
+{
+    DBG_FUNC( "TPAL_SetPhy10Force" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Power down PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 1 );
+
+
+    /**************************************************************************
+       Disable autoneg
+     *************************************************************************/
+    ET1310_PhyAutoNeg( pAdapter, FALSE );
+
+
+    /**************************************************************************
+       Disable all advertisement
+     *************************************************************************/
+    ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    ET1310_PhyAdvertise10BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    ET1310_PhyAdvertise100BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+
+    /**************************************************************************
+       Force 10 Mbps
+     *************************************************************************/
+    ET1310_PhySpeedSelect( pAdapter, TRUEPHY_SPEED_10MBPS );
+
+
+    /**************************************************************************
+       Force Full duplex
+     *************************************************************************/
+    ET1310_PhyDuplexMode( pAdapter, TRUEPHY_DUPLEX_FULL );
+
+
+    /**************************************************************************
+       Power up PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 0 );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_SetPhy100HalfDuplex
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to force the phy into 100 Base T Half Duplex mode.  Also sets the
+        MAC so it is syncd up properly
+
+   PARAMETERS :
+        pAdapter - pointer to the adapter structure
+
+   RETURNS    :
+        TRUEPHY_SUCCESS - if everything goes according to plan
+        TRUEPHY_FALIURE  -if somethign goes wrong during the procedures
+
+ *****************************************************************************/
+INT32 TPAL_SetPhy100HalfDuplex( ET131X_ADAPTER *pAdapter )
+{
+    INT32   returnValue = TRUEPHY_SUCCESS;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "TPAL_SetPhy100HalfDuplex" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Power down PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 1 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+
+        DBG_ERROR( et131x_dbginfo, "Could not power down the PHY\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return( returnValue );
+    }
+
+
+    /**************************************************************************
+        first we need to turn off all other advertisement
+     *************************************************************************/
+    ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not turn off advertisement of 1000 BaseT "
+                   "for Forcing 100 BaseT Half Duplex\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+    ET1310_PhyAdvertise10BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not turn off advertisement of 10 BaseT "
+                   "for Forcing 100 BaseT Half Duplex\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+        Set our advertise values accordingly
+     *************************************************************************/
+    ET1310_PhyAdvertise100BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_HALF );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not set Advertise of 100 Half\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /* Set speed */
+    ET1310_PhySpeedSelect( pAdapter, TRUEPHY_SPEED_100MBPS );
+
+
+    /**************************************************************************
+       Power up PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 0 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power up the PHY\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return returnValue;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_SetPhy100FullDuplex
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to force the phy into 100 Base T Full Duplex mode.  Also sets the
+        MAC so it is syncd up properly
+
+   PARAMETERS :
+        pAdapter - pointer to the adapter structure
+
+   RETURNS    :
+        TRUEPHY_SUCCESS - if everything goes according to plan
+        TRUEPHY_FALIURE  -if somethign goes wrong during the procedures
+
+ *****************************************************************************/
+INT32 TPAL_SetPhy100FullDuplex( ET131X_ADAPTER *pAdapter )
+{
+    INT32   returnValue = TRUEPHY_SUCCESS;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "TPAL_SetPhy100FullDuplex" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Power down PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 1 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power down PHY\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+        First we need to turn off all other advertisement
+     *************************************************************************/
+    ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not turn off advertisement of 1000 BaseT "
+                   "for Forcing 100 BaseT Full Duplex\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+    ET1310_PhyAdvertise10BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not turn off advertisement of 10 BaseT "
+                             "for Forcing 100 BaseT Full Duplex\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+        Set our advertise values accordingly
+     *************************************************************************/
+    ET1310_PhyAdvertise100BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_FULL );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not set Advertise of 100 Full\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+       Power up PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 0 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power up PHY\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return returnValue;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_SetPhy100Force
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to force the phy into 100 Base T Full Duplex mode WITHOUT using
+        autonegotiation.
+
+   PARAMETERS :
+        pAdapter - pointer to the adapter structure
+
+   RETURNS    :
+
+ *****************************************************************************/
+void TPAL_SetPhy100Force( ET131X_ADAPTER *pAdapter )
+{
+    DBG_FUNC( "TPAL_SetPhy100Force" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Power down PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 1 );
+
+
+    /**************************************************************************
+       Disable autoneg
+     *************************************************************************/
+    ET1310_PhyAutoNeg( pAdapter, FALSE );
+
+
+    /**************************************************************************
+       Disable all advertisement
+     *************************************************************************/
+    ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+
+    ET1310_PhyAdvertise10BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+
+    ET1310_PhyAdvertise100BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+
+    /**************************************************************************
+       Force 100 Mbps
+     *************************************************************************/
+    ET1310_PhySpeedSelect( pAdapter, TRUEPHY_SPEED_100MBPS );
+
+
+    /**************************************************************************
+       Force Full duplex
+     *************************************************************************/
+    ET1310_PhyDuplexMode( pAdapter, TRUEPHY_DUPLEX_FULL );
+
+
+    /**************************************************************************
+       Power up PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 0 );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_SetPhy1000FullDuplex
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to force the phy into 1000 Base T Full Duplex mode.  Also sets the
+        MAC so it is syncd up properly
+
+   PARAMETERS :
+        pAdapter - pointer to the adapter structure
+
+   RETURNS    :
+        TRUEPHY_SUCCESS - if everything goes according to plan
+        TRUEPHY_FALIURE  -if somethign goes wrong during the procedures
+
+ *****************************************************************************/
+INT32 TPAL_SetPhy1000FullDuplex( ET131X_ADAPTER *pAdapter )
+{
+    INT32   returnValue = TRUEPHY_SUCCESS;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "TPAL_SetPhy1000FullDuplex" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Power down PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 1 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power down phy\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+        first we need to turn off all other advertisement
+     *************************************************************************/
+    ET1310_PhyAdvertise100BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not turn off advertisement of 100 BaseT "
+                   "for Forcing 1000 BaseT Full Duplex\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+    ET1310_PhyAdvertise10BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not turn off advertisement of 10 BaseT "
+                   "for Forcing 1000 BaseT Full Duplex\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+        set our advertise values accordingly
+     *************************************************************************/
+    ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_FULL );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not set Advertise of 1000 Full\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+       power up PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 0 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power up PHY\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+    DBG_LEAVE( et131x_dbginfo );
+    return returnValue;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  TPAL_SetPhyAutoNeg
+ ******************************************************************************
+
+   DESCRIPTION:
+        Used to set phy to autonegotiation mode.
+
+   PARAMETERS :
+        pAdapter - pointer to the adapter structure
+
+   RETURNS    :
+        TRUEPHY_SUCCESS - if everything goes according to plan
+        TRUEPHY_FALIURE  -if somethign goes wrong during the procedures
+
+ *****************************************************************************/
+INT32 TPAL_SetPhyAutoNeg( ET131X_ADAPTER *pAdapter )
+{
+    INT32   returnValue = TRUEPHY_SUCCESS;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "TPAL_SetPhyAutoNeg" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Power down PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 1 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power down phy\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+        Turn on advertisement of all capabilities
+     *************************************************************************/
+    ET1310_PhyAdvertise10BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_BOTH );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not Turn on Advertisement of 10 BaseT "
+                   "from Setting to Auto Negotiation\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+    ET1310_PhyAdvertise100BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_BOTH );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not Turn on Advertisement of 100 BaseT "
+                   "from Setting to Auto Negotiation\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+    if( pAdapter->DeviceID != ET131X_PCI_DEVICE_ID_FAST )
+    {
+        ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_FULL );
+    }
+    else
+    {
+        ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+    }
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not Turn on Advertisement of 1000 BaseT "
+                   "from Setting to Auto Negotiation\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    /**************************************************************************
+       Make sure auto-neg is ON (it is disabled in FORCE modes)
+     *************************************************************************/
+    ET1310_PhyAutoNeg( pAdapter, TRUE );
+
+
+    /**************************************************************************
+       Power up PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 0 );
+
+    if( returnValue == TRUEPHY_FAILURE )
+    {
+        /**********************************************************************
+           HANDLE ERROR HERE
+         *********************************************************************/
+        DBG_ERROR( et131x_dbginfo, "Could not power up phy\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return returnValue;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return returnValue;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+*******************************************************************************
+
+  The routines which follow provide low-level access to the PHY, and are used
+  primarily by the routines above (although there are a few places elsewhere in
+  the driver where this level of access is required).
+
+*******************************************************************************
+******************************************************************************/
+
+static UINT16  ConfigPhy[25][2] =
+{
+    /* Reg      Value      Register */
+    /* Addr                         */
+    {0x880B,    0x0926}, /* AfeIfCreg4B1000Msbs */
+    {0x880C,    0x0926}, /* AfeIfCreg4B100Msbs */
+    {0x880D,    0x0926}, /* AfeIfCreg4B10Msbs */
+
+    {0x880E,    0xB4D3}, /* AfeIfCreg4B1000Lsbs */
+    {0x880F,    0xB4D3}, /* AfeIfCreg4B100Lsbs */
+    {0x8810,    0xB4D3}, /* AfeIfCreg4B10Lsbs */
+
+    {0x8805,    0xB03E}, /* AfeIfCreg3B1000Msbs */
+    {0x8806,    0xB03E}, /* AfeIfCreg3B100Msbs */
+    {0x8807,    0xFF00}, /* AfeIfCreg3B10Msbs */
+
+    {0x8808,    0xE090}, /* AfeIfCreg3B1000Lsbs */
+    {0x8809,    0xE110}, /* AfeIfCreg3B100Lsbs */
+    {0x880A,    0x0000}, /* AfeIfCreg3B10Lsbs */
+
+    {0x300D,    1     }, /* DisableNorm */
+
+    {0x280C,    0x0180}, /* LinkHoldEnd */
+
+    {0x1C21,    0x0002}, /* AlphaM */
+
+    {0x3821,    6     }, /* FfeLkgTx0 */
+    {0x381D,    1     }, /* FfeLkg1g4 */
+    {0x381E,    1     }, /* FfeLkg1g5 */
+    {0x381F,    1     }, /* FfeLkg1g6 */
+    {0x3820,    1     }, /* FfeLkg1g7 */
+
+    {0x8402,    0x01F0}, /* Btinact */
+    {0x800E,    20    }, /* LftrainTime */
+    {0x800F,    24    }, /* DvguardTime */
+    {0x8010,    46    }, /* IdlguardTime */
+
+    {0,         0     }
+
+};
+//
+// condensed version of the phy initialization routine
+//
+void ET1310_PhyInit( ET131X_ADAPTER *pAdapter )
+{
+    UINT16  usData, usIndex;
+
+
+    if( pAdapter == NULL )
+    {
+        return;
+    }
+
+
+    // get the identity (again ?)
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_ID_1, &usData );
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_ID_2, &usData );
+
+    // what does this do/achieve ?
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_MPHY_CONTROL_REG, &usData );   // should read 0002
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_MPHY_CONTROL_REG, 0x0006 );
+
+    // read modem register 0402, should I do something with the return data ?
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_INDEX_REG, 0x0402 );
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_DATA_REG, &usData );
+
+    // what does this do/achieve ?
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_MPHY_CONTROL_REG, 0x0002 );
+
+    // get the identity (again ?)
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_ID_1, &usData );
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_ID_2, &usData );
+
+    // what does this achieve ?
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_MPHY_CONTROL_REG, &usData );   // should read 0002
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_MPHY_CONTROL_REG, 0x0006 );
+
+    // read modem register 0402, should I do something with the return data ?
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_INDEX_REG, 0x0402 );
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_DATA_REG, &usData );
+
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_MPHY_CONTROL_REG, 0x0002 );
+
+    // what does this achieve (should return 0x1040)
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, &usData );
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_MPHY_CONTROL_REG, &usData );   // should read 0002
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, 0x1840 );
+
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_MPHY_CONTROL_REG, 0x0007 );
+
+    // here the writing of the array starts....
+    usIndex = 0;
+    while( ConfigPhy[usIndex][0] != 0x0000 )
+    {
+        // write value
+        MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_INDEX_REG, ConfigPhy[usIndex][0] );
+        MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_DATA_REG, ConfigPhy[usIndex][1] );
+
+        // read it back
+        MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_INDEX_REG, ConfigPhy[usIndex][0] );
+        MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_DATA_REG, &usData );
+
+        // do a check on the value read back ?
+        usIndex++;
+    }
+    // here the writing of the array ends...
+
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, &usData );   // 0x1840
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_MPHY_CONTROL_REG, &usData );   // should read 0007
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, 0x1040 );
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_MPHY_CONTROL_REG, 0x0002 );
+
+    return;
+
+}
+
+
+
+
+void ET1310_PhyReset( ET131X_ADAPTER *pAdapter )
+{
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, 0x8000 );
+    return;
+}
+
+
+
+
+void ET1310_PhyPowerDown( ET131X_ADAPTER *pAdapter, BOOL_t down )
+{
+    UINT16  usData;
+
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, &usData );
+
+    if( down == FALSE )
+    {
+        // Power UP
+        usData &= ~0x0800;
+        MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, usData );
+    }
+    else
+    {
+        // Power DOWN
+        usData |= 0x0800;
+        MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, usData );
+    }
+
+    return;
+}
+
+
+void ET1310_PhyAutoNeg( ET131X_ADAPTER *pAdapter, BOOL_t enable )
+{
+    UINT16 usData;
+
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, &usData );
+
+    if( enable == TRUE )
+    {
+        // Autonegotiation ON
+        usData |= 0x1000;
+        MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, usData );
+    }
+    else
+    {
+        // Autonegotiation OFF
+        usData &= ~0x1000;
+        MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, usData );
+    }
+
+    return;
+}
+
+void ET1310_PhyDuplexMode( ET131X_ADAPTER *pAdapter, UINT16 duplex )
+{
+    UINT16 usData;
+
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, &usData );
+
+    if( duplex == TRUEPHY_DUPLEX_FULL )
+    {
+        // Set Full Duplex
+        usData |= 0x100;
+        MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, usData );
+    }
+    else
+    {
+        // Set Half Duplex
+        usData &= ~0x100;
+        MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, usData );
+    }
+
+    return;
+}
+
+
+void ET1310_PhySpeedSelect( ET131X_ADAPTER *pAdapter, UINT16 speed )
+{
+    UINT16 usData;
+
+    // Read the PHY control register
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, &usData );
+
+    // Clear all Speed settings (Bits 6, 13)
+    usData &= ~0x2040;
+
+    // Reset the speed bits based on user selection
+    switch( speed )
+    {
+    case TRUEPHY_SPEED_10MBPS:
+        // Bits already cleared above, do nothing
+        break;
+
+    case TRUEPHY_SPEED_100MBPS:
+        // 100M == Set bit 13
+        usData |= 0x2000;
+        break;
+
+    case TRUEPHY_SPEED_1000MBPS:
+    default:
+        usData |= 0x0040;
+        break;
+    }
+
+    // Write back the new speed
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, usData );
+
+    return;
+}
+
+
+void ET1310_PhyAdvertise1000BaseT( ET131X_ADAPTER *pAdapter, UINT16 duplex )
+{
+    UINT16 usData;
+
+    // Read the PHY 1000 Base-T Control Register
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_1000_CONTROL, &usData );
+
+    // Clear Bits 8,9
+    usData &= ~0x0300;
+
+    switch( duplex )
+    {
+    case TRUEPHY_ADV_DUPLEX_NONE:
+        // Duplex already cleared, do nothing
+        break;
+
+    case TRUEPHY_ADV_DUPLEX_FULL:
+        // Set Bit 9
+        usData |= 0x0200;
+        break;
+
+    case TRUEPHY_ADV_DUPLEX_HALF:
+        // Set Bit 8
+        usData |= 0x0100;
+        break;
+
+    case TRUEPHY_ADV_DUPLEX_BOTH:
+    default:
+        usData |= 0x0300;
+        break;
+    }
+
+    // Write back advertisement
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_1000_CONTROL, usData );
+
+    return;
+}
+
+
+void ET1310_PhyAdvertise100BaseT( ET131X_ADAPTER *pAdapter, UINT16 duplex )
+{
+    UINT16 usData;
+
+    // Read the Autonegotiation Register (10/100)
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_AUTO_ADVERTISEMENT, &usData );
+
+    // Clear bits 7,8
+    usData &= ~0x0180;
+
+    switch( duplex )
+    {
+    case TRUEPHY_ADV_DUPLEX_NONE:
+        // Duplex already cleared, do nothing
+        break;
+
+    case TRUEPHY_ADV_DUPLEX_FULL:
+        // Set Bit 8
+        usData |= 0x0100;
+        break;
+
+    case TRUEPHY_ADV_DUPLEX_HALF:
+        // Set Bit 7
+        usData |= 0x0080;
+        break;
+
+    case TRUEPHY_ADV_DUPLEX_BOTH:
+    default:
+        // Set Bits 7,8
+        usData |= 0x0180;
+        break;
+    }
+
+    // Write back advertisement
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_AUTO_ADVERTISEMENT, usData );
+
+    return;
+}
+
+
+void ET1310_PhyAdvertise10BaseT( ET131X_ADAPTER *pAdapter, UINT16 duplex )
+{
+    UINT16 usData;
+
+    // Read the Autonegotiation Register (10/100)
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_AUTO_ADVERTISEMENT, &usData );
+
+    // Clear bits 5,6
+    usData &= ~0x0060;
+
+    switch( duplex )
+    {
+    case TRUEPHY_ADV_DUPLEX_NONE:
+        // Duplex already cleared, do nothing
+        break;
+
+    case TRUEPHY_ADV_DUPLEX_FULL:
+        // Set Bit 6
+        usData |= 0x0040;
+        break;
+
+    case TRUEPHY_ADV_DUPLEX_HALF:
+        // Set Bit 5
+        usData |= 0x0020;
+        break;
+
+    case TRUEPHY_ADV_DUPLEX_BOTH:
+    default:
+        // Set Bits 5,6
+        usData |= 0x0060;
+        break;
+    }
+
+    // Write back advertisement
+    MiWrite( pAdapter, pAdapter->Stats.xcvr_addr, PHY_AUTO_ADVERTISEMENT, usData );
+
+    return;
+}
+
+
+
+
+void ET1310_PhyLinkStatus( ET131X_ADAPTER *pAdapter,
+                           UCHAR  *ucLinkStatus,
+                           UINT32 *uiAutoNeg,
+                           UINT32 *uiLinkSpeed,
+                           UINT32 *uiDuplexMode,
+                           UINT32 *uiMdiMdix,
+                           UINT32 *uiMasterSlave,
+                           UINT32 *uiPolarity )
+{
+    UINT16 usMiStatus     = 0;
+    UINT16 us1000BaseT    = 0;
+    UINT16 usVmiPhyStatus = 0;
+    UINT16 usControl      = 0;
+
+
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_STATUS, &usMiStatus );
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_1000_STATUS, &us1000BaseT );
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_PHY_STATUS, &usVmiPhyStatus );
+    MiRead( pAdapter, pAdapter->Stats.xcvr_addr, PHY_CONTROL, &usControl );
+
+    if( ucLinkStatus )
+    {
+        *ucLinkStatus  = (unsigned char)(( usVmiPhyStatus & 0x0040 ) ? 1 : 0 );
+    }
+
+    if( uiAutoNeg )
+    {
+        *uiAutoNeg     = ( usControl & 0x1000 ) ? (( usVmiPhyStatus & 0x0020 ) ? TRUEPHY_ANEG_COMPLETE : TRUEPHY_ANEG_NOT_COMPLETE ) : TRUEPHY_ANEG_DISABLED;
+    }
+
+    if( uiLinkSpeed )
+    {
+        *uiLinkSpeed   = ( usVmiPhyStatus & 0x0300 ) >> 8;
+    }
+
+    if( uiDuplexMode )
+    {
+        *uiDuplexMode  = ( usVmiPhyStatus & 0x0080 ) >> 7;
+    }
+
+    if( uiMdiMdix )
+    {
+        /* NOTE: Need to complete this */
+        *uiMdiMdix     = 0;
+    }
+
+    if( uiMasterSlave )
+    {
+        *uiMasterSlave = ( us1000BaseT & 0x4000 ) ? TRUEPHY_CFG_MASTER : TRUEPHY_CFG_SLAVE;
+    }
+
+    if( uiPolarity )
+    {
+        *uiPolarity    = ( usVmiPhyStatus & 0x0400 ) ? TRUEPHY_POLARITY_INVERTED : TRUEPHY_POLARITY_NORMAL;
+    }
+
+    return;
+}
+
+
+void ET1310_PhyAndOrReg( ET131X_ADAPTER *pAdapter,
+                         UINT16 regnum,
+                         UINT16 andMask,
+                         UINT16 orMask )
+{
+    UINT16 reg;
+
+    // Read the requested register
+    MiRead( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+            regnum, &reg );
+
+    // Apply the AND mask
+    reg &= andMask;
+
+    // Apply the OR mask
+    reg |= orMask;
+
+    // Write the value back to the register
+    MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+             regnum, reg );
+
+    return;
+}
+
+
+void ET1310_PhyAccessMiBit( ET131X_ADAPTER *pAdapter,
+                            UINT16 action,
+                            UINT16 regnum,
+                            UINT16 bitnum,
+                            UINT8 *value )
+{
+    UINT16 reg;
+    UINT16 mask = 0;
+
+    // Create a mask to isolate the requested bit
+    mask = 0x0001 << bitnum;
+
+    // Read the requested register
+    MiRead( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+            regnum, &reg );
+
+    switch( action )
+    {
+    case TRUEPHY_BIT_READ:
+        if( value != NULL )
+        {
+            *value = ( reg & mask ) >> bitnum;
+        }
+
+        break;
+
+    case TRUEPHY_BIT_SET:
+        reg |= mask;
+        MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr, regnum, reg );
+        break;
+
+    case TRUEPHY_BIT_CLEAR:
+        reg &= ~mask;
+        MiWrite( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr, regnum, reg );
+        break;
+
+    default:
+        break;
+    }
+
+    return;
+}
+
--- /dev/null
+++ b/drivers/net/et131x/ET1310_phy.h
@@ -0,0 +1,1228 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_phy.h - Defines, structs, enums, prototypes, etc. pertaining to the
+ *                PHY.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2006/01/18 22:18:33 $
+     $Revision: 1.10 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef _ET1310_PHY_H_
+#define _ET1310_PHY_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+
+/******************************************************************************
+   INCLUDES
+ *****************************************************************************/
+#include "ET1310_common.h"
+
+
+
+
+#define TRUEPHY_SUCCESS 0
+#define TRUEPHY_FAILURE 1
+typedef void    *TRUEPHY_HANDLE;
+typedef void    *TRUEPHY_PLATFORM_HANDLE;
+typedef void    *TRUEPHY_OSAL_HANDLE;
+
+
+
+
+/******************************************************************************
+   CONSTANTS for PHY Register
+ *****************************************************************************/
+/* MI Register Addresses */
+#define MI_CONTROL_REG                      0
+#define MI_STATUS_REG                       1
+#define MI_PHY_IDENTIFIER_1_REG             2
+#define MI_PHY_IDENTIFIER_2_REG             3
+#define MI_AUTONEG_ADVERTISEMENT_REG        4
+#define MI_AUTONEG_LINK_PARTNER_ABILITY_REG 5
+#define MI_AUTONEG_EXPANSION_REG            6
+#define MI_AUTONEG_NEXT_PAGE_TRANSMIT_REG   7
+#define MI_LINK_PARTNER_NEXT_PAGE_REG       8
+#define MI_1000BASET_CONTROL_REG            9
+#define MI_1000BASET_STATUS_REG             10
+#define MI_RESERVED11_REG                   11
+#define MI_RESERVED12_REG                   12
+#define MI_RESERVED13_REG                   13
+#define MI_RESERVED14_REG                   14
+#define MI_EXTENDED_STATUS_REG              15
+
+/* VMI Register Addresses */
+#define VMI_RESERVED16_REG                  16
+#define VMI_RESERVED17_REG                  17
+#define VMI_RESERVED18_REG                  18
+#define VMI_LOOPBACK_CONTROL_REG            19
+#define VMI_RESERVED20_REG                  20
+#define VMI_MI_CONTROL_REG                  21
+#define VMI_PHY_CONFIGURATION_REG           22
+#define VMI_PHY_CONTROL_REG                 23
+#define VMI_INTERRUPT_MASK_REG              24
+#define VMI_INTERRUPT_STATUS_REG            25
+#define VMI_PHY_STATUS_REG                  26
+#define VMI_LED_CONTROL_1_REG               27
+#define VMI_LED_CONTROL_2_REG               28
+#define VMI_RESERVED29_REG                  29
+#define VMI_RESERVED30_REG                  30
+#define VMI_RESERVED31_REG                  31
+
+
+
+
+/******************************************************************************
+   PHY Register Mapping(MI) Management Interface Regs
+ *****************************************************************************/
+typedef struct _MI_REGS_t
+{
+    UCHAR bmcr;         // Basic mode control reg(Reg 0x00)
+    UCHAR bmsr;         // Basic mode status reg(Reg 0x01)
+    UCHAR idr1;         // Phy identifier reg 1(Reg 0x02)
+    UCHAR idr2;         // Phy identifier reg 2(Reg 0x03)
+    UCHAR anar;         // Auto-Negotiation advertisement(Reg 0x04)
+    UCHAR anlpar;       // Auto-Negotiation link Partner Ability(Reg 0x05)
+    UCHAR aner;         // Auto-Negotiation expansion reg(Reg 0x06)
+    UCHAR annptr;       // Auto-Negotiation next page transmit reg(Reg 0x07)
+    UCHAR lpnpr;        // link partner next page reg(Reg 0x08)
+    UCHAR gcr;          // Gigabit basic mode control reg(Reg 0x09)
+    UCHAR gsr;          // Gigabit basic mode status reg(Reg 0x0A)
+    UCHAR mi_res1[4];   // Future use by MI working group(Reg 0x0B - 0x0E)
+    UCHAR esr;          // Extended status reg(Reg 0x0F)
+    UCHAR mi_res2[3];   // Future use by MI working group(Reg 0x10 - 0x12)
+    UCHAR loop_ctl;     // Loopback Control Reg(Reg 0x13)
+    UCHAR mi_res3;      // Future use by MI working group(Reg 0x14)
+    UCHAR mcr;          // MI Control Reg(Reg 0x15)
+    UCHAR pcr;          // Configuration Reg(Reg 0x16)
+    UCHAR phy_ctl;      // PHY Control Reg(Reg 0x17)
+    UCHAR imr;          // Interrupt Mask Reg(Reg 0x18)
+    UCHAR isr;          // Interrupt Status Reg(Reg 0x19)
+    UCHAR psr;          // PHY Status Reg(Reg 0x1A)
+    UCHAR lcr1;         // LED Control 1 Reg(Reg 0x1B)
+    UCHAR lcr2;         // LED Control 2 Reg(Reg 0x1C)
+    UCHAR mi_res4[3];   // Future use by MI working group(Reg 0x1D - 0x1F)
+}
+MI_REGS_t, *PMI_REGS_t;
+
+
+
+
+/******************************************************************************
+   MI Register 0: Basic mode control register
+ *****************************************************************************/
+typedef union _MI_BMCR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 reset:1;                             //bit 15
+        UINT16 loopback:1;                          //bit 14
+        UINT16 speed_sel:1;                         //bit 13
+        UINT16 enable_autoneg:1;                    //bit 12
+        UINT16 power_down:1;                        //bit 11
+        UINT16 isolate:1;                           //bit 10
+        UINT16 restart_autoneg:1;                   //bit 9
+        UINT16 duplex_mode:1;                       //bit 8
+        UINT16 col_test:1;                          //bit 7
+        UINT16 speed_1000_sel:1;                    //bit 6
+        UINT16 res1:6;                              //bits 0-5
+    #else
+        UINT16 res1:6;                              //bits 0-5
+        UINT16 speed_1000_sel:1;                    //bit 6
+        UINT16 col_test:1;                          //bit 7
+        UINT16 duplex_mode:1;                       //bit 8
+        UINT16 restart_autoneg:1;                   //bit 9
+        UINT16 isolate:1;                           //bit 10
+        UINT16 power_down:1;                        //bit 11
+        UINT16 enable_autoneg:1;                    //bit 12
+        UINT16 speed_sel:1;                         //bit 13
+        UINT16 loopback:1;                          //bit 14
+        UINT16 reset:1;                             //bit 15
+    #endif
+    } bits;
+}
+MI_BMCR_t, *PMI_BMCR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 1:  Basic mode status register
+ *****************************************************************************/
+typedef union _MI_BMSR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 link_100T4:1;                        //bit 15
+        UINT16 link_100fdx:1;                       //bit 14
+        UINT16 link_100hdx:1;                       //bit 13
+        UINT16 link_10fdx:1;                        //bit 12
+        UINT16 link_10hdx:1;                        //bit 11
+        UINT16 link_100T2fdx:1;                     //bit 10
+        UINT16 link_100T2hdx:1;                     //bit 9
+        UINT16 extend_status:1;                     //bit 8
+        UINT16 res1:1;                              //bit 7
+        UINT16 preamble_supress:1;                  //bit 6
+        UINT16 auto_neg_complete:1;                 //bit 5
+        UINT16 remote_fault:1;                      //bit 4
+        UINT16 auto_neg_able:1;                     //bit 3
+        UINT16 link_status:1;                       //bit 2
+        UINT16 jabber_detect:1;                     //bit 1
+        UINT16 ext_cap:1;                           //bit 0
+    #else
+        UINT16 ext_cap:1;                           //bit 0
+        UINT16 jabber_detect:1;                     //bit 1
+        UINT16 link_status:1;                       //bit 2
+        UINT16 auto_neg_able:1;                     //bit 3
+        UINT16 remote_fault:1;                      //bit 4
+        UINT16 auto_neg_complete:1;                 //bit 5
+        UINT16 preamble_supress:1;                  //bit 6
+        UINT16 res1:1;                              //bit 7
+        UINT16 extend_status:1;                     //bit 8
+        UINT16 link_100T2hdx:1;                     //bit 9
+        UINT16 link_100T2fdx:1;                     //bit 10
+        UINT16 link_10hdx:1;                        //bit 11
+        UINT16 link_10fdx:1;                        //bit 12
+        UINT16 link_100hdx:1;                       //bit 13
+        UINT16 link_100fdx:1;                       //bit 14
+        UINT16 link_100T4:1;                        //bit 15
+    #endif
+    } bits;
+}
+MI_BMSR_t, *PMI_BMSR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 2: Physical Identifier 1
+ *****************************************************************************/
+typedef union _MI_IDR1_t
+{
+    UINT16 value;
+    struct
+    {
+        UINT16 ieee_address:16;                     //0x0282 default(bits 0-15)
+    } bits;
+}
+MI_IDR1_t, *PMI_IDR1_t;
+
+
+
+
+/******************************************************************************
+   MI Register 3: Physical Identifier 2
+ *****************************************************************************/
+typedef union _MI_IDR2_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 ieee_address:6;                      //111100 default(bits 10-15)
+        UINT16 model_no:6;                          //000001 default(bits 4-9)
+        UINT16 rev_no:4;                            //0010   default(bits 0-3)
+    #else
+        UINT16 rev_no:4;                            //0010   default(bits 0-3)
+        UINT16 model_no:6;                          //000001 default(bits 4-9)
+        UINT16 ieee_address:6;                      //111100 default(bits 10-15)
+    #endif
+    } bits;
+}
+MI_IDR2_t, *PMI_IDR2_t;
+
+
+
+
+/******************************************************************************
+   MI Register 4: Auto-negotiation advertisement register
+ *****************************************************************************/
+typedef union _MI_ANAR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 np_indication:1;                     //bit 15
+        UINT16 res2:1;                              //bit 14
+        UINT16 remote_fault:1;                      //bit 13
+        UINT16 res1:1;                              //bit 12
+        UINT16 cap_asmpause:1;                      //bit 11
+        UINT16 cap_pause:1;                         //bit 10
+        UINT16 cap_100T4:1;                         //bit 9
+        UINT16 cap_100fdx:1;                        //bit 8
+        UINT16 cap_100hdx:1;                        //bit 7
+        UINT16 cap_10fdx:1;                         //bit 6
+        UINT16 cap_10hdx:1;                         //bit 5
+        UINT16 selector:5;                          //bits 0-4
+    #else
+        UINT16 selector:5;                          //bits 0-4
+        UINT16 cap_10hdx:1;                         //bit 5
+        UINT16 cap_10fdx:1;                         //bit 6
+        UINT16 cap_100hdx:1;                        //bit 7
+        UINT16 cap_100fdx:1;                        //bit 8
+        UINT16 cap_100T4:1;                         //bit 9
+        UINT16 cap_pause:1;                         //bit 10
+        UINT16 cap_asmpause:1;                      //bit 11
+        UINT16 res1:1;                              //bit 12
+        UINT16 remote_fault:1;                      //bit 13
+        UINT16 res2:1;                              //bit 14
+        UINT16 np_indication:1;                     //bit 15
+    #endif
+    } bits;
+}
+MI_ANAR_t, *PMI_ANAR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 5: Auto-negotiation link partner advertisement register
+ *****************************************************************************/
+typedef struct _MI_ANLPAR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 np_indication:1;                     //bit 15
+        UINT16 acknowledge:1;                       //bit 14
+        UINT16 remote_fault:1;                      //bit 13
+        UINT16 res1:1;                              //bit 12
+        UINT16 cap_asmpause:1;                      //bit 11
+        UINT16 cap_pause:1;                         //bit 10
+        UINT16 cap_100T4:1;                         //bit 9
+        UINT16 cap_100fdx:1;                        //bit 8
+        UINT16 cap_100hdx:1;                        //bit 7
+        UINT16 cap_10fdx:1;                         //bit 6
+        UINT16 cap_10hdx:1;                         //bit 5
+        UINT16 selector:5;                          //bits 0-4
+    #else
+        UINT16 selector:5;                          //bits 0-4
+        UINT16 cap_10hdx:1;                         //bit 5
+        UINT16 cap_10fdx:1;                         //bit 6
+        UINT16 cap_100hdx:1;                        //bit 7
+        UINT16 cap_100fdx:1;                        //bit 8
+        UINT16 cap_100T4:1;                         //bit 9
+        UINT16 cap_pause:1;                         //bit 10
+        UINT16 cap_asmpause:1;                      //bit 11
+        UINT16 res1:1;                              //bit 12
+        UINT16 remote_fault:1;                      //bit 13
+        UINT16 acknowledge:1;                       //bit 14
+        UINT16 np_indication:1;                     //bit 15
+    #endif
+    } bits;
+}
+MI_ANLPAR_t, *PMI_ANLPAR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 6: Auto-negotiation expansion register
+ *****************************************************************************/
+typedef union _MI_ANER_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 res:11;                              //bits 5-15
+        UINT16 pdf:1;                               //bit 4
+        UINT16 lp_np_able:1;                        //bit 3
+        UINT16 np_able:1;                           //bit 2
+        UINT16 page_rx:1;                           //bit 1
+        UINT16 lp_an_able:1;                        //bit 0
+    #else
+        UINT16 lp_an_able:1;                        //bit 0
+        UINT16 page_rx:1;                           //bit 1
+        UINT16 np_able:1;                           //bit 2
+        UINT16 lp_np_able:1;                        //bit 3
+        UINT16 pdf:1;                               //bit 4
+        UINT16 res:11;                              //bits 5-15
+    #endif
+    } bits;
+}
+MI_ANER_t, *PMI_ANER_t;
+
+
+
+
+/******************************************************************************
+   MI Register 7: Auto-negotiation next page transmit reg(0x07)
+ *****************************************************************************/
+typedef union _MI_ANNPTR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 np:1;                                //bit 15
+        UINT16 res1:1;                              //bit 14
+        UINT16 msg_page:1;                          //bit 13
+        UINT16 ack2:1;                              //bit 12
+        UINT16 toggle:1;                            //bit 11
+        UINT16 msg:11;                              //bits 0-10
+    #else
+        UINT16 msg:11;                              //bits 0-10
+        UINT16 toggle:1;                            //bit 11
+        UINT16 ack2:1;                              //bit 12
+        UINT16 msg_page:1;                          //bit 13
+        UINT16 res1:1;                              //bit 14
+        UINT16 np:1;                                //bit 15
+    #endif
+    } bits;
+}
+MI_ANNPTR_t, *PMI_ANNPTR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 8: Link Partner Next Page Reg(0x08)
+ *****************************************************************************/
+typedef union _MI_LPNPR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 np:1;                                //bit 15
+        UINT16 ack:1;                               //bit 14
+        UINT16 msg_page:1;                          //bit 13
+        UINT16 ack2:1;                              //bit 12
+        UINT16 toggle:1;                            //bit 11
+        UINT16 msg:11;                              //bits 0-10
+    #else
+        UINT16 msg:11;                              //bits 0-10
+        UINT16 toggle:1;                            //bit 11
+        UINT16 ack2:1;                              //bit 12
+        UINT16 msg_page:1;                          //bit 13
+        UINT16 ack:1;                               //bit 14
+        UINT16 np:1;                                //bit 15
+    #endif
+    } bits;
+}
+MI_LPNPR_t, *PMI_LPNPR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 9: 1000BaseT Control Reg(0x09)
+ *****************************************************************************/
+typedef union _MI_GCR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 test_mode:3;                         //bits 13-15
+        UINT16 ms_config_en:1;                      //bit 12
+        UINT16 ms_value:1;                          //bit 11
+        UINT16 port_type:1;                         //bit 10
+        UINT16 link_1000fdx:1;                      //bit 9
+        UINT16 link_1000hdx:1;                      //bit 8
+        UINT16 res:8;                               //bit 0-7
+    #else
+        UINT16 res:8;                               //bit 0-7
+        UINT16 link_1000hdx:1;                      //bit 8
+        UINT16 link_1000fdx:1;                      //bit 9
+        UINT16 port_type:1;                         //bit 10
+        UINT16 ms_value:1;                          //bit 11
+        UINT16 ms_config_en:1;                      //bit 12
+        UINT16 test_mode:3;                         //bits 13-15
+    #endif
+    } bits;
+}
+MI_GCR_t, *PMI_GCR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 10: 1000BaseT Status Reg(0x0A)
+ *****************************************************************************/
+typedef union _MI_GSR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 ms_config_fault:1;                   //bit 15
+        UINT16 ms_resolve:1;                        //bit 14
+        UINT16 local_rx_status:1;                   //bit 13
+        UINT16 remote_rx_status:1;                  //bit 12
+        UINT16 link_1000fdx:1;                      //bit 11
+        UINT16 link_1000hdx:1;                      //bit 10
+        UINT16 res:2;                               //bits 8-9
+        UINT16 idle_err_cnt:8;                      //bits 0-7
+    #else
+        UINT16 idle_err_cnt:8;                      //bits 0-7
+        UINT16 res:2;                               //bits 8-9
+        UINT16 link_1000hdx:1;                      //bit 10
+        UINT16 link_1000fdx:1;                      //bit 11
+        UINT16 remote_rx_status:1;                  //bit 12
+        UINT16 local_rx_status:1;                   //bit 13
+        UINT16 ms_resolve:1;                        //bit 14
+        UINT16 ms_config_fault:1;                   //bit 15
+    #endif
+    } bits;
+}
+MI_GSR_t, *PMI_GSR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 11 - 14: Reserved Regs(0x0B - 0x0E)
+ *****************************************************************************/
+typedef union _MI_RES_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 res15:1;                             //bit 15
+        UINT16 res14:1;                             //bit 14
+        UINT16 res13:1;                             //bit 13
+        UINT16 res12:1;                             //bit 12
+        UINT16 res11:1;                             //bit 11
+        UINT16 res10:1;                             //bit 10
+        UINT16 res9:1;                              //bit 9
+        UINT16 res8:1;                              //bit 8
+        UINT16 res7:1;                              //bit 7
+        UINT16 res6:1;                              //bit 6
+        UINT16 res5:1;                              //bit 5
+        UINT16 res4:1;                              //bit 4
+        UINT16 res3:1;                              //bit 3
+        UINT16 res2:1;                              //bit 2
+        UINT16 res1:1;                              //bit 1
+        UINT16 res0:1;                              //bit 0
+    #else
+        UINT16 res0:1;                              //bit 0
+        UINT16 res1:1;                              //bit 1
+        UINT16 res2:1;                              //bit 2
+        UINT16 res3:1;                              //bit 3
+        UINT16 res4:1;                              //bit 4
+        UINT16 res5:1;                              //bit 5
+        UINT16 res6:1;                              //bit 6
+        UINT16 res7:1;                              //bit 7
+        UINT16 res8:1;                              //bit 8
+        UINT16 res9:1;                              //bit 9
+        UINT16 res10:1;                             //bit 10
+        UINT16 res11:1;                             //bit 11
+        UINT16 res12:1;                             //bit 12
+        UINT16 res13:1;                             //bit 13
+        UINT16 res14:1;                             //bit 14
+        UINT16 res15:1;                             //bit 15
+    #endif
+    } bits;
+}
+MI_RES_t, *PMI_RES_t;
+
+
+
+
+/******************************************************************************
+   MI Register 15: Extended status Reg(0x0F)
+ *****************************************************************************/
+typedef union _MI_ESR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 link_1000Xfdx:1;                     //bit 15
+        UINT16 link_1000Xhdx:1;                     //bit 14
+        UINT16 link_1000fdx:1;                      //bit 13
+        UINT16 link_1000hdx:1;                      //bit 12
+        UINT16 res:12;                              //bit 0-11
+    #else
+        UINT16 res:12;                              //bit 0-11
+        UINT16 link_1000hdx:1;                      //bit 12
+        UINT16 link_1000fdx:1;                      //bit 13
+        UINT16 link_1000Xhdx:1;                     //bit 14
+        UINT16 link_1000Xfdx:1;                     //bit 15
+    #endif
+    } bits;
+}
+MI_ESR_t, *PMI_ESR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 16 - 18: Reserved Reg(0x10-0x12)
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   MI Register 19: Loopback Control Reg(0x13)
+ *****************************************************************************/
+typedef union _MI_LCR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 mii_en:1;                            //bit 15
+        UINT16 pcs_en:1;                            //bit 14
+        UINT16 pmd_en:1;                            //bit 13
+        UINT16 all_digital_en:1;                    //bit 12
+        UINT16 replica_en:1;                        //bit 11
+        UINT16 line_driver_en:1;                    //bit 10
+        UINT16 res:10;                              //bit 0-9
+    #else
+        UINT16 res:10;                              //bit 0-9
+        UINT16 line_driver_en:1;                    //bit 10
+        UINT16 replica_en:1;                        //bit 11
+        UINT16 all_digital_en:1;                    //bit 12
+        UINT16 pmd_en:1;                            //bit 13
+        UINT16 pcs_en:1;                            //bit 14
+        UINT16 mii_en:1;                            //bit 15
+    #endif
+    } bits;
+}
+MI_LCR_t, *PMI_LCR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 20: Reserved Reg(0x14)
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   MI Register 21: Management Interface Control Reg(0x15)
+ *****************************************************************************/
+typedef union _MI_MICR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 res1:5;                              //bits 11-15
+        UINT16 mi_error_count:7;                    //bits 4-10
+        UINT16 res2:1;                              //bit 3
+        UINT16 ignore_10g_fr:1;                     //bit 2
+        UINT16 res3:1;                              //bit 1
+        UINT16 preamble_supress_en:1;               //bit 0
+    #else
+        UINT16 preamble_supress_en:1;               //bit 0
+        UINT16 res3:1;                              //bit 1
+        UINT16 ignore_10g_fr:1;                     //bit 2
+        UINT16 res2:1;                              //bit 3
+        UINT16 mi_error_count:7;                    //bits 4-10
+        UINT16 res1:5;                              //bits 11-15
+    #endif
+    } bits;
+}
+MI_MICR_t, *PMI_MICR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 22: PHY Configuration Reg(0x16)
+ *****************************************************************************/
+typedef union _MI_PHY_CONFIG_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 crs_tx_en:1;                         //bit 15
+        UINT16 res1:1;                              //bit 14
+        UINT16 tx_fifo_depth:2;                     //bits 12-13
+        UINT16 speed_downshift:2;                   //bits 10-11
+        UINT16 pbi_detect:1;                        //bit 9
+        UINT16 tbi_rate:1;                          //bit 8
+        UINT16 alternate_np:1;                      //bit 7
+        UINT16 group_mdio_en:1;                     //bit 6
+        UINT16 tx_clock_en:1;                       //bit 5
+        UINT16 sys_clock_en:1;                      //bit 4
+        UINT16 res2:1;                              //bit 3
+        UINT16 mac_if_mode:3;                       //bits 0-2
+    #else
+        UINT16 mac_if_mode:3;                       //bits 0-2
+        UINT16 res2:1;                              //bit 3
+        UINT16 sys_clock_en:1;                      //bit 4
+        UINT16 tx_clock_en:1;                       //bit 5
+        UINT16 group_mdio_en:1;                     //bit 6
+        UINT16 alternate_np:1;                      //bit 7
+        UINT16 tbi_rate:1;                          //bit 8
+        UINT16 pbi_detect:1;                        //bit 9
+        UINT16 speed_downshift:2;                   //bits 10-11
+        UINT16 tx_fifo_depth:2;                     //bits 12-13
+        UINT16 res1:1;                              //bit 14
+        UINT16 crs_tx_en:1;                         //bit 15
+    #endif
+    } bits;
+}
+MI_PHY_CONFIG_t, *PMI_PHY_CONFIG_t;
+
+
+
+
+/******************************************************************************
+   MI Register 23: PHY CONTROL Reg(0x17)
+ *****************************************************************************/
+typedef union _MI_PHY_CONTROL_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 res1:1;                              //bit 15
+        UINT16 tdr_en:1;                            //bit 14
+        UINT16 res2:1;                              //bit 13
+        UINT16 downshift_attempts:2;                //bits 11-12
+        UINT16 res3:5;                              //bit 6-10
+        UINT16 jabber_10baseT:1;                    //bit 5
+        UINT16 sqe_10baseT:1;                       //bit 4
+        UINT16 tp_loopback_10baseT:1;               //bit 3
+        UINT16 preamble_gen_en:1;                   //bit 2
+        UINT16 res4:1;                              //bit 1
+        UINT16 force_int:1;                         //bit 0
+    #else
+        UINT16 force_int:1;                         //bit 0
+        UINT16 res4:1;                              //bit 1
+        UINT16 preamble_gen_en:1;                   //bit 2
+        UINT16 tp_loopback_10baseT:1;               //bit 3
+        UINT16 sqe_10baseT:1;                       //bit 4
+        UINT16 jabber_10baseT:1;                    //bit 5
+        UINT16 res3:5;                              //bit 6-10
+        UINT16 downshift_attempts:2;                //bits 11-12
+        UINT16 res2:1;                              //bit 13
+        UINT16 tdr_en:1;                            //bit 14
+        UINT16 res1:1;                              //bit 15
+    #endif
+    } bits;
+}
+MI_PHY_CONTROL_t, *PMI_PHY_CONTROL_t;
+
+
+
+
+/******************************************************************************
+   MI Register 24: Interrupt Mask Reg(0x18)
+ *****************************************************************************/
+typedef union _MI_IMR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 res1:6;                              //bits 10-15
+        UINT16 mdio_sync_lost:1;                    //bit 9
+        UINT16 autoneg_status:1;                    //bit 8
+        UINT16 hi_bit_err:1;                        //bit 7
+        UINT16 np_rx:1;                             //bit 6
+        UINT16 err_counter_full:1;                  //bit 5
+        UINT16 fifo_over_underflow:1;               //bit 4
+        UINT16 rx_status:1;                         //bit 3
+        UINT16 link_status:1;                       //bit 2
+        UINT16 automatic_speed:1;                   //bit 1
+        UINT16 int_en:1;                            //bit 0
+    #else
+        UINT16 int_en:1;                            //bit 0
+        UINT16 automatic_speed:1;                   //bit 1
+        UINT16 link_status:1;                       //bit 2
+        UINT16 rx_status:1;                         //bit 3
+        UINT16 fifo_over_underflow:1;               //bit 4
+        UINT16 err_counter_full:1;                  //bit 5
+        UINT16 np_rx:1;                             //bit 6
+        UINT16 hi_bit_err:1;                        //bit 7
+        UINT16 autoneg_status:1;                    //bit 8
+        UINT16 mdio_sync_lost:1;                    //bit 9
+        UINT16 res1:6;                              //bits 10-15
+    #endif
+    } bits;
+}
+MI_IMR_t, *PMI_IMR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 25: Interrupt Status Reg(0x19)
+ *****************************************************************************/
+typedef union _MI_ISR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 res1:6;                              //bits 10-15
+        UINT16 mdio_sync_lost:1;                    //bit 9
+        UINT16 autoneg_status:1;                    //bit 8
+        UINT16 hi_bit_err:1;                        //bit 7
+        UINT16 np_rx:1;                             //bit 6
+        UINT16 err_counter_full:1;                  //bit 5
+        UINT16 fifo_over_underflow:1;               //bit 4
+        UINT16 rx_status:1;                         //bit 3
+        UINT16 link_status:1;                       //bit 2
+        UINT16 automatic_speed:1;                   //bit 1
+        UINT16 int_en:1;                            //bit 0
+    #else
+        UINT16 int_en:1;                            //bit 0
+        UINT16 automatic_speed:1;                   //bit 1
+        UINT16 link_status:1;                       //bit 2
+        UINT16 rx_status:1;                         //bit 3
+        UINT16 fifo_over_underflow:1;               //bit 4
+        UINT16 err_counter_full:1;                  //bit 5
+        UINT16 np_rx:1;                             //bit 6
+        UINT16 hi_bit_err:1;                        //bit 7
+        UINT16 autoneg_status:1;                    //bit 8
+        UINT16 mdio_sync_lost:1;                    //bit 9
+        UINT16 res1:6;                              //bits 10-15
+    #endif
+    } bits;
+}
+MI_ISR_t, *PMI_ISR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 26: PHY Status Reg(0x1A)
+ *****************************************************************************/
+typedef union _MI_PSR_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 res1:1;                              //bit 15
+        UINT16 autoneg_fault:2;                     //bit 13-14
+        UINT16 autoneg_status:1;                    //bit 12
+        UINT16 mdi_x_status:1;                      //bit 11
+        UINT16 polarity_status:1;                   //bit 10
+        UINT16 speed_status:2;                      //bits 8-9
+        UINT16 duplex_status:1;                     //bit 7
+        UINT16 link_status:1;                       //bit 6
+        UINT16 tx_status:1;                         //bit 5
+        UINT16 rx_status:1;                         //bit 4
+        UINT16 collision_status:1;                  //bit 3
+        UINT16 autoneg_en:1;                        //bit 2
+        UINT16 pause_en:1;                          //bit 1
+        UINT16 asymmetric_dir:1;                    //bit 0
+    #else
+        UINT16 asymmetric_dir:1;                    //bit 0
+        UINT16 pause_en:1;                          //bit 1
+        UINT16 autoneg_en:1;                        //bit 2
+        UINT16 collision_status:1;                  //bit 3
+        UINT16 rx_status:1;                         //bit 4
+        UINT16 tx_status:1;                         //bit 5
+        UINT16 link_status:1;                       //bit 6
+        UINT16 duplex_status:1;                     //bit 7
+        UINT16 speed_status:2;                      //bits 8-9
+        UINT16 polarity_status:1;                   //bit 10
+        UINT16 mdi_x_status:1;                      //bit 11
+        UINT16 autoneg_status:1;                    //bit 12
+        UINT16 autoneg_fault:2;                     //bit 13-14
+        UINT16 res1:1;                              //bit 15
+    #endif
+    } bits;
+}
+MI_PSR_t, *PMI_PSR_t;
+
+
+
+
+/******************************************************************************
+   MI Register 27: LED Control Reg 1(0x1B)
+ *****************************************************************************/
+typedef union _MI_LCR1_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 res1:2;                              //bits 14-15
+        UINT16 led_dup_indicate:2;                  //bits 12-13
+        UINT16 led_10baseT:2;                       //bits 10-11
+        UINT16 led_collision:2;                     //bits 8-9
+        UINT16 res2:2;                              //bits 6-7
+        UINT16 res3:2;                              //bits 4-5
+        UINT16 pulse_dur:2;                         //bits 2-3
+        UINT16 pulse_stretch1:1;                    //bit 1
+        UINT16 pulse_stretch0:1;                    //bit 0
+    #else
+        UINT16 pulse_stretch0:1;                    //bit 0
+        UINT16 pulse_stretch1:1;                    //bit 1
+        UINT16 pulse_dur:2;                         //bits 2-3
+        UINT16 res3:2;                              //bits 4-5
+        UINT16 res2:2;                              //bits 6-7
+        UINT16 led_collision:2;                     //bits 8-9
+        UINT16 led_10baseT:2;                       //bits 10-11
+        UINT16 led_dup_indicate:2;                  //bits 12-13
+        UINT16 res1:2;                              //bits 14-15
+    #endif
+    } bits;
+}
+MI_LCR1_t, *PMI_LCR1_t;
+
+
+
+
+/******************************************************************************
+   MI Register 28: LED Control Reg 2(0x1C)
+ *****************************************************************************/
+typedef union _MI_LCR2_t
+{
+    UINT16 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT16 led_link:4;                          //bits 12-15
+        UINT16 led_tx_rx:4;                         //bits 8-11
+        UINT16 led_100BaseTX:4;                     //bits 4-7
+        UINT16 led_1000BaseT:4;                     //bits 0-3
+    #else
+        UINT16 led_1000BaseT:4;                     //bits 0-3
+        UINT16 led_100BaseTX:4;                     //bits 4-7
+        UINT16 led_tx_rx:4;                         //bits 8-11
+        UINT16 led_link:4;                          //bits 12-15
+    #endif
+    } bits;
+}
+MI_LCR2_t, *PMI_LCR2_t;
+
+
+
+
+/******************************************************************************
+   MI Register 29 - 31: Reserved Reg(0x1D - 0x1E)
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   TruePHY headers
+ *****************************************************************************/
+typedef struct _TRUEPHY_ACCESS_MI_REGS_
+{
+    TRUEPHY_HANDLE hTruePhy;
+    INT32          nPhyId;
+    UCHAR          bReadWrite;
+    PUCHAR         pbyRegs;
+    PUCHAR         pwData;
+    INT32          nRegCount;
+}
+TRUEPHY_ACCESS_MI_REGS, *PTRUEPHY_ACCESS_MI_REGS;
+
+
+
+
+/******************************************************************************
+   TruePHY headers
+ *****************************************************************************/
+typedef struct _TAG_TPAL_ACCESS_MI_REGS_
+{
+    UINT32      nPhyId;
+    UCHAR       bReadWrite;
+    UINT32      nRegCount;
+    UINT16      Data[4096];
+    UCHAR       Regs[4096];
+} TPAL_ACCESS_MI_REGS, *PTPAL_ACCESS_MI_REGS;
+
+
+
+
+/******************************************************************************
+   Required TruePHY PROTOTYPES
+ *****************************************************************************/
+/******************************************************************************
+   TYPE DEFINITIONS
+ *****************************************************************************/
+typedef TRUEPHY_HANDLE TPAL_HANDLE;
+
+
+/******************************************************************************
+   Forward declaration of the private adapter structure
+ *****************************************************************************/
+struct et131x_adapter;
+
+
+///////////////////////////////////////////////////////////////////////////////
+////                  TruePHY Platform Specific Functions                  ////
+///////////////////////////////////////////////////////////////////////////////
+//TRUEPHY_HANDLE TPAL_PlatformInit( void *                      pPlatformInfo,
+//                                  PTRUEPHY_PLATFORM_FUNCTIONS pPlatFunctions );
+
+INT32          TPAL_MiAccessRegs( TPAL_HANDLE hPlatform,
+                                  INT32       nPhyId,
+                                  PUCHAR      pbyAccessFlags,
+                                  PUCHAR      pbyRegisters,
+                                  PUINT16     pwData,
+                                  PUINT16     pwAndMasks,
+                                  PUINT16     pwOrMasks,
+                                  INT32       nRegCount );
+
+void           TPAL_PlatformExit( TRUEPHY_PLATFORM_HANDLE hPlatform );
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+////                         OS Specific Functions                         ////
+///////////////////////////////////////////////////////////////////////////////
+void  *TPAL_AllocMem( TRUEPHY_PLATFORM_HANDLE hPlatform, u_long ulNumBytes );
+void   TPAL_FreeMem( TRUEPHY_PLATFORM_HANDLE hPlatform, void *pMemBlock );
+void   TPAL_Sleep( TRUEPHY_PLATFORM_HANDLE hPlatform, u_long ulMsec );
+u_long TPAL_GetSystemUpTime( TRUEPHY_PLATFORM_HANDLE hPlatform );
+void   TPAL_GetLinkStatusInfo( struct et131x_adapter *adapter );
+
+INT32 TPAL_SetPhy10HalfDuplex( struct et131x_adapter *adapter );
+INT32 TPAL_SetPhy10FullDuplex( struct et131x_adapter *adapter );
+void  TPAL_SetPhy10Force( struct et131x_adapter * pAdapter );
+INT32 TPAL_SetPhy100HalfDuplex( struct et131x_adapter *adapter );
+INT32 TPAL_SetPhy100FullDuplex( struct et131x_adapter *adapter );
+void  TPAL_SetPhy100Force( struct et131x_adapter * pAdapter );
+INT32 TPAL_SetPhy1000FullDuplex( struct et131x_adapter *adapter);
+INT32 TPAL_SetPhyAutoNeg( struct et131x_adapter *adapter );
+
+
+
+
+/******************************************************************************
+   PROTOTYPES for ET1310_phy.c
+ *****************************************************************************/
+int et131x_xcvr_find( struct et131x_adapter *adapter );
+
+int et131x_setphy_normal( struct et131x_adapter *adapter );
+INT32 et131x_xcvr_init( struct et131x_adapter *adapter );
+
+INT32 MiRead( struct et131x_adapter *adapter,
+              UINT8 xcvrAddr,
+              UINT8 xcvrReg,
+              UINT16 *value );
+
+INT32 MiWrite( struct et131x_adapter *adapter,
+               UINT8 xcvrAddr,
+               UINT8 xcvReg,
+               UINT16 value );
+
+void et131x_Mii_check( struct et131x_adapter *pAdapter,
+                       MI_BMSR_t bmsr,
+                       MI_BMSR_t bmsr_ints );
+
+
+
+
+/******************************************************************************
+   This last is not strictly required (the driver could call the TPAL
+   version instead), but this sets the adapter up correctly, and calls the
+   access routine indirectly.  This protects the driver from changes in TPAL.
+ *****************************************************************************/
+void SetPhy_10BaseTHalfDuplex( struct et131x_adapter *adapter );
+
+
+
+
+/******************************************************************************
+   Defines for PHY access routines
+ *****************************************************************************/
+// Define bit operation flags
+#define TRUEPHY_BIT_CLEAR               0
+#define TRUEPHY_BIT_SET                 1
+#define TRUEPHY_BIT_READ                2
+
+// Define read/write operation flags
+#ifndef TRUEPHY_READ
+#define TRUEPHY_READ                    0
+#define TRUEPHY_WRITE                   1
+#define TRUEPHY_MASK                    2
+#endif
+
+// Define speeds
+#define TRUEPHY_SPEED_10MBPS            0
+#define TRUEPHY_SPEED_100MBPS           1
+#define TRUEPHY_SPEED_1000MBPS          2
+
+// Define duplex modes
+#define TRUEPHY_DUPLEX_HALF             0
+#define TRUEPHY_DUPLEX_FULL             1
+
+// Define master/slave configuration values
+#define TRUEPHY_CFG_SLAVE               0
+#define TRUEPHY_CFG_MASTER              1
+
+// Define MDI/MDI-X settings
+#define TRUEPHY_MDI                     0
+#define TRUEPHY_MDIX                    1
+#define TRUEPHY_AUTO_MDI_MDIX           2
+
+// Define 10Base-T link polarities
+#define TRUEPHY_POLARITY_NORMAL         0
+#define TRUEPHY_POLARITY_INVERTED       1
+
+// Define auto-negotiation results
+#define TRUEPHY_ANEG_NOT_COMPLETE       0
+#define TRUEPHY_ANEG_COMPLETE           1
+#define TRUEPHY_ANEG_DISABLED           2
+
+/* Define duplex advertisment flags */
+#define TRUEPHY_ADV_DUPLEX_NONE         0x00
+#define TRUEPHY_ADV_DUPLEX_FULL         0x01
+#define TRUEPHY_ADV_DUPLEX_HALF         0x02
+#define TRUEPHY_ADV_DUPLEX_BOTH     \
+    (TRUEPHY_ADV_DUPLEX_FULL | TRUEPHY_ADV_DUPLEX_HALF)
+
+#define PHY_CONTROL                0x00     //#define TRU_MI_CONTROL_REGISTER                 0
+#define PHY_STATUS                 0x01     //#define TRU_MI_STATUS_REGISTER                  1
+#define PHY_ID_1                   0x02     //#define TRU_MI_PHY_IDENTIFIER_1_REGISTER        2
+#define PHY_ID_2                   0x03     //#define TRU_MI_PHY_IDENTIFIER_2_REGISTER        3
+#define PHY_AUTO_ADVERTISEMENT     0x04     //#define TRU_MI_ADVERTISEMENT_REGISTER           4
+#define PHY_AUTO_LINK_PARTNER      0x05     //#define TRU_MI_LINK_PARTNER_ABILITY_REGISTER    5
+#define PHY_AUTO_EXPANSION         0x06     //#define TRU_MI_EXPANSION_REGISTER               6
+#define PHY_AUTO_NEXT_PAGE_TX      0x07     //#define TRU_MI_NEXT_PAGE_TRANSMIT_REGISTER      7
+#define PHY_LINK_PARTNER_NEXT_PAGE 0x08     //#define TRU_MI_LINK_PARTNER_NEXT_PAGE_REGISTER  8
+#define PHY_1000_CONTROL           0x09     //#define TRU_MI_1000BASET_CONTROL_REGISTER       9
+#define PHY_1000_STATUS            0x0A     //#define TRU_MI_1000BASET_STATUS_REGISTER        10
+
+
+#define PHY_EXTENDED_STATUS        0x0F     //#define TRU_MI_EXTENDED_STATUS_REGISTER         15
+
+// some defines for modem registers that seem to be 'reserved'
+#define PHY_INDEX_REG              0x10
+#define PHY_DATA_REG               0x11
+
+#define PHY_MPHY_CONTROL_REG       0x12     //#define TRU_VMI_MPHY_CONTROL_REGISTER           18
+
+#define PHY_LOOPBACK_CONTROL       0x13     //#define TRU_VMI_LOOPBACK_CONTROL_1_REGISTER     19
+                                            //#define TRU_VMI_LOOPBACK_CONTROL_2_REGISTER     20
+#define PHY_REGISTER_MGMT_CONTROL  0x15     //#define TRU_VMI_MI_SEQ_CONTROL_REGISTER         21
+#define PHY_CONFIG                 0x16     //#define TRU_VMI_CONFIGURATION_REGISTER          22
+#define PHY_PHY_CONTROL            0x17     //#define TRU_VMI_PHY_CONTROL_REGISTER            23
+#define PHY_INTERRUPT_MASK         0x18     //#define TRU_VMI_INTERRUPT_MASK_REGISTER         24
+#define PHY_INTERRUPT_STATUS       0x19     //#define TRU_VMI_INTERRUPT_STATUS_REGISTER       25
+#define PHY_PHY_STATUS             0x1A     //#define TRU_VMI_PHY_STATUS_REGISTER             26
+#define PHY_LED_1                  0x1B     //#define TRU_VMI_LED_CONTROL_1_REGISTER          27
+#define PHY_LED_2                  0x1C     //#define TRU_VMI_LED_CONTROL_2_REGISTER          28
+                                            //#define TRU_VMI_LINK_CONTROL_REGISTER           29
+                                            //#define TRU_VMI_TIMING_CONTROL_REGISTER
+
+
+
+
+/******************************************************************************
+   Prototypes for PHY access routines
+ *****************************************************************************/
+void ET1310_PhyInit( struct et131x_adapter *pAdapter );
+void ET1310_PhyReset( struct et131x_adapter *pAdapter );
+void ET1310_PhyPowerDown( struct et131x_adapter *pAdapter, BOOL_t down );
+void ET1310_PhyAutoNeg( struct et131x_adapter *pAdapter, BOOL_t enable );
+void ET1310_PhyDuplexMode( struct et131x_adapter *pAdapter, UINT16 duplex );
+void ET1310_PhySpeedSelect( struct et131x_adapter *pAdapter, UINT16 speed );
+void ET1310_PhyAdvertise1000BaseT( struct et131x_adapter *pAdapter, UINT16 duplex );
+void ET1310_PhyAdvertise100BaseT( struct et131x_adapter *pAdapter, UINT16 duplex );
+void ET1310_PhyAdvertise10BaseT( struct et131x_adapter *pAdapter, UINT16 duplex );
+void ET1310_PhyLinkStatus( struct et131x_adapter *pAdapter,
+                           UCHAR  *ucLinkStatus,
+                           UINT32 *uiAutoNeg,
+                           UINT32 *uiLinkSpeed,
+                           UINT32 *uiDuplexMode,
+                           UINT32 *uiMdiMdix,
+                           UINT32 *uiMasterSlave,
+                           UINT32 *uiPolarity );
+void ET1310_PhyAndOrReg( struct et131x_adapter *pAdapter,
+                         UINT16 regnum,
+                         UINT16 andMask,
+                         UINT16 orMask );
+void ET1310_PhyAccessMiBit( struct et131x_adapter *pAdapter,
+                            UINT16 action,
+                            UINT16 regnum,
+                            UINT16 bitnum,
+                            UINT8 *value );
+
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* _ET1310_PHY_H_ */
--- /dev/null
+++ b/drivers/net/et131x/ET1310_pm.c
@@ -0,0 +1,1723 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_pm.c - All power management related code (not completely implemented)
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2006/01/20 21:29:44 $
+     $Revision: 1.8 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+#include "ET1310_mac.h"
+#include "ET1310_rx.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_initpci.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   ROUTINE:  CalculateCCITCRC16
+ ******************************************************************************
+   DESCRIPTION:
+        This routine calculates the CCIT CRC-16 value required for power
+        management.
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+UINT16 CalculateCCITCRC16( PUCHAR Pattern, PUCHAR Mask, UINT32 MaskSize )
+{
+    UINT32      i, j, k, HitBit;
+    UINT16      RemainderCRC = 0xFFFF;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "CalculateCCITCRC16" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       There is one bit in the mask for every byte in the pattern.  Therefore,
+       this first loop (the "i" loop) iterates over every byte in the mask,
+       the inner "j" loop iterates over every bit in each byte.  If that bit
+       in the mask is clear, then we skip over this byte of packet date (the
+       "continue").
+     *************************************************************************/
+    for( i = 0; i < MaskSize; i++ )
+    {
+        for( j = 0; j < 8; j++ )
+        {
+            if(( Mask[i] & ( 1 << j )) == 0 )
+            {
+                continue;
+            }
+
+            /******************************************************************
+                Following 10 lines iterates over every bit in this byte of the
+                pattern, and applies the CRC-16 calculation as defined by CCIT.
+                It could be optimized using a look-up-table, but this function
+                will be called infrequently, so the memory overhead of
+                optimization can be avoided.
+             *****************************************************************/
+            for( k = 0; k < 8; k++ )
+            {
+                HitBit = (( RemainderCRC >> 15 ) & 1 );
+                HitBit ^= ( Pattern[(i*8)+j] >> k ) & 1;
+
+                RemainderCRC <<= 1;
+
+                if( HitBit )
+                {
+                    RemainderCRC ^= CRC16_POLY;
+                }
+            }
+        }
+    }
+
+    DBG_LEAVE( et131x_dbginfo );
+    return( RemainderCRC );
+}
+
+/*===========================================================================*/
+
+
+
+#if 0
+/******************************************************************************
+   ROUTINE:  MPSetPowerD0
+ ******************************************************************************
+   DESCRIPTION:
+        Used to set the power state to D0, Updated for the ET1310
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+VOID MPSetPowerD0( IN PMP_ADAPTER pAdapter )
+{
+    UINT32                  uPmCsr;
+    NDIS_DEVICE_POWER_STATE ComingBackFrom;
+    PM_CSR_t                pm_csr = pAdapter->CSRAddress->global.pm_csr;
+    RXMAC_CTRL_t            ctrl;
+    MI_ISR_t                isr;
+    MI_BMSR_t               Bmsr, BmsrInts;
+    UINT32                  delay = 0;
+
+    /*-----------------------------------------------------------------------*/
+
+    DBGPRINT( MP_TRACE, ( "----> MPSetPowerD0\n" ));
+
+    /**************************************************************************
+       Archive the power-state we are returning from, and then set the
+       "current" power state back to fully operational
+     *************************************************************************/
+    ComingBackFrom              = pAdapter->PoMgmt.PowerState;
+    pAdapter->PoMgmt.PowerState = NdisDeviceStateD0;
+
+
+    /**********************************************************************
+        Allow disabling of Non-Maskable Interrupts in I/O space, to
+        support validation.
+        *********************************************************************/
+    if( pAdapter->RegistryNMIDisable )
+    {
+        UCHAR RegisterVal;
+
+        NdisRawReadPortUchar( ET1310_NMI_DISABLE, &RegisterVal );
+
+        RegisterVal &= 0xf3;
+
+        if( pAdapter->RegistryNMIDisable == 2 )
+        {
+            RegisterVal |= 0xc;
+        }
+
+        NdisRawWritePortUchar( ET1310_NMI_DISABLE, RegisterVal );
+    }
+
+    {
+        UCHAR read_size_reg;
+
+        /******************************************************************
+            Change the max read size to 2k
+         *****************************************************************/
+        NdisReadPciSlotInformation( pAdapter->AdapterHandle,
+                                    0,          // not used
+                                    0x51,
+                                    (PVOID)&read_size_reg,
+                                    sizeof( UCHAR ));
+
+        read_size_reg &= 0x8f;
+        read_size_reg |= 0x40;
+
+        NdisWritePciSlotInformation( pAdapter->AdapterHandle,
+                                     0,
+                                     0x51,
+                                     &read_size_reg,
+                                     sizeof( UCHAR ));
+    }
+
+
+    /**************************************************************************
+       Sample read of pmcsr to aid validation.  Will be catured by PCI-e
+       analyzer
+     *************************************************************************/
+    NdisReadPciSlotInformation( pAdapter->AdapterHandle,
+                            0,  // Slot no.  Reserved.  Ndis ignores.
+                            ET1310_PCI_PM_CSR,
+                            (PVOID)&uPmCsr,
+                            sizeof( UINT32 ));
+
+    /**************************************************************************
+       we now need to set the JAGCore gating control registers for this power
+       state.  Bypass this for nonwake device since in that case the JAGCore
+	   and gigE PHY have been reset
+
+       This is only supposeto be for wake mode, when in non-wake mode, the
+       device enters L1 which causes a reset of the jagcore which basically
+       clears the PM_STATE.  But due to issue with system not staying in L1 the
+       hardware reset is not happening.  So we take care of it here.
+     *************************************************************************/
+    if( TRUE ) //pAdapter->PoMgmt.WOLEnabled )
+    {
+		pm_csr.bits.pm_gigephy_en  = 0;
+        pm_csr.bits.pm_jagcore_rx_en = 0;
+        pm_csr.bits.pm_jagcore_tx_en = 0;
+        pm_csr.bits.pm_phy_lped_en  = 0;
+        pm_csr.bits.pm_phy_sw_coma  = 0;
+
+        /**********************************************************************
+           enable clock first
+         *********************************************************************/
+		pm_csr.bits.pm_sysclk_gate = 1;
+		pm_csr.bits.pm_txclk_gate  = 1;
+		pm_csr.bits.pm_rxclk_gate  = 1;
+
+		/**********************************************************************
+           tx_en and rx_en should remain the same as in power down
+         *********************************************************************/
+		pAdapter->CSRAddress->global.pm_csr = pm_csr;
+
+		/**********************************************************************
+		   poll the PMSTATE until JAGCore is in normal state
+		 *********************************************************************/
+        while(( pAdapter->CSRAddress->global.pm_csr.bits.pm_jagcore_rx_rdy != 0 ) &&
+              ( pAdapter->CSRAddress->global.pm_csr.bits.pm_jagcore_tx_rdy != 0 ) &&
+              ( delay < 100 ))
+		{
+			NdisStallExecution( 10 );
+            delay++;
+		}
+
+        if( delay >= 100 )
+        {
+            pm_csr = pAdapter->CSRAddress->global.pm_csr;
+
+            pm_csr.bits.pm_jagcore_rx_en = 0;
+            pm_csr.bits.pm_jagcore_tx_en = 0;
+            pAdapter->CSRAddress->global.pm_csr.value = pm_csr.value;
+        }
+	}
+
+	/**************************************************************************
+	   now lets set up JAGcore pm control for D0
+	 *************************************************************************/
+	pm_csr.bits.pm_gigephy_en  = 0;
+
+    pm_csr.bits.pm_jagcore_rx_en = pAdapter->PoMgmt.rx_en;
+    pm_csr.bits.pm_jagcore_tx_en = pAdapter->PoMgmt.tx_en;
+
+	pAdapter->CSRAddress->global.pm_csr = pm_csr;
+
+    /**************************************************************************
+		we also need to read and clear the phy_interrupt register in case of
+        wakeup on link status change
+	*************************************************************************/
+    MiRead( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+            (UINT8)offsetof( MI_REGS_t, isr ), &isr.value );
+
+    /**************************************************************************
+       disable WOL
+     *************************************************************************/
+    ctrl   = pAdapter->CSRAddress->rxmac.ctrl;
+
+    ctrl.bits.wol_disable   = 1;
+    ctrl.bits.mif_disable   = 0;
+    ctrl.bits.async_disable = 0;
+
+    pAdapter->CSRAddress->rxmac.ctrl = ctrl;
+
+	/**************************************************************************
+       Set the power state to 0 (d0), and flip the PME status pin.  Clear the
+       PME Enable pin, if it were set.
+     *************************************************************************/
+    uPmCsr = 0x00008000;
+    NdisWritePciSlotInformation( pAdapter->AdapterHandle,
+                                 0, // Slot no.  Reserved.  Ndis ignores.
+                                 ET1310_PCI_PM_CSR,
+                                 &uPmCsr,
+                                 sizeof( UINT32 ));
+
+    /**************************************************************************
+       When the adapter is placed in D3 wake, it is set in 10 Base-T
+       half-duplex mode.  However, we archived the speed and duplex settings
+       that were current prior to that, so restore them now and then tell
+       the phy to do it's thing.
+     *************************************************************************/
+    if(( ComingBackFrom == NdisDeviceStateD3 ) ||
+       ( ComingBackFrom == NdisDeviceStateD1 && !pAdapter->PoMgmt.WOLEnabledByCurrentState ))
+    {
+        pAdapter->AiForceSpeed = pAdapter->PoMgmt.PowerDownSpeed;
+        pAdapter->AiForceDpx   = pAdapter->PoMgmt.PowerDownDuplex;
+
+        /**********************************************************************
+		    Re-initialize the send structures
+         **********************************************************************/
+	    MPInitSend( pAdapter );
+
+	    /**********************************************************************
+		    Reset the RFD list and re-start RU
+         *********************************************************************/
+	    NICResetRecv( pAdapter );
+
+	    /**********************************************************************
+		    Bring the device back to the state it was during init prior
+            to autonegotiation being complete.  This way, when we get the
+            auto-neg complete interrupt, we can complete init by calling
+            ConfigMacREGS2.
+         *********************************************************************/
+	    HwSoftwareReset( pAdapter );
+
+        /**********************************************************************
+            setup et1310 as per the documentation
+         *********************************************************************/
+        NICSetAdapterUp( pAdapter );
+    }
+
+    /**************************************************************************
+        Allow Tx to restart
+     *************************************************************************/
+    MP_CLEAR_FLAG( pAdapter, fMP_ADAPTER_LOWER_POWER );
+
+    /**************************************************************************
+       Check to see if the link status bit is set in the BMSR register, if it
+       is not, this means we had a cable pull when at a lower power state and
+       need to indicate that we are disconnected to NDIS
+     *************************************************************************/
+    MiRead( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+            (UINT8)offsetof( MI_REGS_t, bmsr ), &Bmsr.value );
+
+    if( !Bmsr.bits.link_status )
+    {
+
+        pAdapter->Bmsr.value = Bmsr.value;
+
+        NdisAcquireSpinLock( &pAdapter->Lock );
+        MP_SET_FLAG( pAdapter, fMP_ADAPTER_LINK_DETECTION );
+        pAdapter->MediaState = 0;
+
+        NdisReleaseSpinLock( &pAdapter->Lock );
+
+        // get timer going again...
+        NdisMSetPeriodicTimer( &pAdapter->PeriodicTimer,
+                               TX_ERROR_PERIOD );
+
+        // setup for possible disconnect
+        NdisMSetTimer( &pAdapter->LinkDetectionTimer,
+                               LINK_DETECTION_TIMER );
+
+        pAdapter->bLinkTimerActive = TRUE;
+
+        if( pAdapter->RegistryPhyComa )
+        {
+            MPSetPhyComa( pAdapter );
+        }
+        /**********************************************************************
+           In the case of link-in before sleep, link-out after sleep, we need
+           to re-start the start-of-day timer so that we eventually flop
+           into PhyComa.  In this case, the above state change gets overwritten
+           since we get a PHY interrupt almost straight away, and PHY interrupt
+           handling pulls us out of PHY coma mode.
+         *********************************************************************/
+        pAdapter->PoMgmt.TransPhyComaModeOnBoot = 0;
+    }
+
+    /**************************************************************************
+       we need to enable interrupts
+     *************************************************************************/
+    NdisMSynchronizeWithInterrupt( &pAdapter->Interrupt,
+                                (PVOID)NICEnableInterrupts,
+                                pAdapter );
+
+    DBGPRINT( MP_TRACE, ( "<---- MPSetPowerD0\n" ));
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  MPSetLowPower
+ ******************************************************************************
+   DESCRIPTION:
+        This routine is called when the adapter receives a SetPower to any
+        state other than d0.  Most of the common stuff for setting to a lower
+        power state should be handled in here.
+
+   PARAMETERS :
+        pAdapter   - pointer to our adapter structure
+        PowerState - NewPowerState
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+VOID MPSetLowPower( IN PMP_ADAPTER pAdapter,
+                    IN NDIS_DEVICE_POWER_STATE PowerState )
+{
+    PM_CSR_t     GlobalPmCSR;
+    RXMAC_CTRL_t ctrl;
+    MI_ISR_t     isr;
+    MI_BMSR_t    lBmsr;
+    BOOLEAN     bDummy;
+    /*-----------------------------------------------------------------------*/
+
+    /**************************************************************************
+       if we are in coma mode when we get this request, we need to disable it
+     *************************************************************************/
+    if( pAdapter->CSRAddress->global.pm_csr.bits.pm_phy_sw_coma == 1 )
+    {
+        /**********************************************************************
+           check to see if we are in coma mode and if so, disable it because
+           we will not be able to read phy values until we are out.
+         *********************************************************************/
+        MPDisablePhyComa( pAdapter );
+    }
+
+    /**************************************************************************
+        interrupts will be queued until after this routine completes.  May as
+        well disable them now, since we do not want any of the queued interrupts.
+     *************************************************************************/
+    NdisMSynchronizeWithInterrupt( &pAdapter->Interrupt,
+                                (PVOID)NICDisableInterrupts,
+                                pAdapter );
+
+    /**************************************************************************
+       Set the adapter power state to requested, lower state
+     *************************************************************************/
+    pAdapter->PoMgmt.PowerState = PowerState;
+
+    /**************************************************************************
+       Cancel timers - start them again when power restored
+     *************************************************************************/
+    NdisMCancelTimer( &pAdapter->PeriodicTimer, &bDummy );
+
+    if( pAdapter->bLinkTimerActive == TRUE ){
+        NdisMCancelTimer( &pAdapter->LinkDetectionTimer, &bDummy );
+    }
+
+    /**************************************************************************
+       Save the GbE PHY speed and duplex modes
+
+       Need to restore this for: D1 nonwake, D3 wake and nonwake modes
+	 *************************************************************************/
+	pAdapter->PoMgmt.PowerDownSpeed  = pAdapter->AiForceSpeed;
+    pAdapter->PoMgmt.PowerDownDuplex = pAdapter->AiForceDpx;
+
+    NdisAcquireSpinLock( &pAdapter->SendHWLock );
+
+    /**************************************************************************
+       Stop sending packets.
+     *************************************************************************/
+    MP_SET_FLAG( pAdapter, fMP_ADAPTER_LOWER_POWER );
+
+    NdisReleaseSpinLock( &pAdapter->SendHWLock );
+
+    /**************************************************************************
+		Free the packets being actively sent & stopped
+    **************************************************************************/
+	MpFreeBusySendPackets( pAdapter );
+
+    /**************************************************************************
+       Save Rx/Tx enable condition.  Used during restore to D0 state.
+     *************************************************************************/
+    pAdapter->PoMgmt.tx_en = pAdapter->CSRAddress->global.pm_csr.bits.pm_jagcore_tx_en;
+    pAdapter->PoMgmt.rx_en = pAdapter->CSRAddress->global.pm_csr.bits.pm_jagcore_rx_en;
+
+    /**************************************************************************
+       set the JAGCore gating control registers for this power state
+     *************************************************************************/
+    GlobalPmCSR = pAdapter->CSRAddress->global.pm_csr;
+
+    if( pAdapter->PoMgmt.WOLEnabledByCurrentState )
+    {
+        GlobalPmCSR.bits.pm_gigephy_en = 0;
+    }
+    else
+    {
+        GlobalPmCSR.bits.pm_gigephy_en = 1;
+    }
+
+    /**************************************************************************
+       only exercise the PM state machine when the link is up
+     *************************************************************************/
+	if( pAdapter->Bmsr.bits.link_status )
+	{
+        GlobalPmCSR.bits.pm_jagcore_tx_en = 1;
+        GlobalPmCSR.bits.pm_jagcore_rx_en = 1;
+
+	}
+    pAdapter->CSRAddress->global.pm_csr = GlobalPmCSR;
+
+    ctrl = pAdapter->CSRAddress->rxmac.ctrl;
+
+    /**************************************************************************
+       only exercise the PM state machine when the link is up
+     *************************************************************************/
+	if( pAdapter->Bmsr.bits.link_status )
+	{
+        /**********************************************************************
+           disable MIF so power state can transition
+         *********************************************************************/
+        ctrl.bits.mif_disable            = 1;
+	    pAdapter->CSRAddress->rxmac.ctrl = ctrl;
+
+        while(( pAdapter->CSRAddress->global.pm_csr.bits.pm_jagcore_rx_rdy != 1 )
+           && ( pAdapter->CSRAddress->global.pm_csr.bits.pm_jagcore_tx_rdy != 1 ))
+		{
+			NdisStallExecution( 10 );
+		}
+	}
+
+    /**************************************************************************
+        Stop hardware from receiving packets - Set the RU to idle
+     *************************************************************************/
+    NICRxDmaDisable( pAdapter );
+
+    /**************************************************************************
+        Wait for outstanding Receive packets
+     *************************************************************************/
+    while( MP_GET_RCV_REF( pAdapter ) != 0 )
+    {
+        /**********************************************************************
+            Sleep for 2 Ms;
+         *********************************************************************/
+        NdisStallExecution( 2000 );
+    }
+
+    /**************************************************************************
+       D3Wake only - set the MAC and Phy to 10BaseT half-duplex operation.
+       Archive the current settings in the pAdapter structure so we can
+       restore them when done.
+     *************************************************************************/
+    if(( PowerState == NdisDeviceStateD3 ) && pAdapter->PoMgmt.WOLEnabledByCurrentState &&
+        pAdapter->Bmsr.bits.link_status )
+    {
+        /**********************************************************************
+           initialize variable for testing if we failed to go to specific link
+         *********************************************************************/
+        pAdapter->PoMgmt.Failed10Half = FALSE;
+
+        /**********************************************************************
+           set the phy properly
+         *********************************************************************/
+        pAdapter->AiForceSpeed = 10;
+        pAdapter->AiForceDpx   = 1;
+
+        TPAL_SetPhy10HalfDuplex( pAdapter );
+
+        /**********************************************************************
+           get the link status here, we need to wait until the link comes back
+           after reconfiguring it.
+         *********************************************************************/
+        TPAL_GetLinkStatusInfo( pAdapter );
+
+        if( pAdapter->PoMgmt.Failed10Half )
+        {
+            /******************************************************************
+               re-initialize variable for testing if we failed to go to
+               specific link speed
+             *****************************************************************/
+            pAdapter->PoMgmt.Failed10Half = FALSE;
+
+            /******************************************************************
+               set the phy properly
+             *****************************************************************/
+            pAdapter->AiForceSpeed = 100;
+            pAdapter->AiForceDpx   = 1;
+
+            TPAL_SetPhy100HalfDuplex( pAdapter );
+
+            /******************************************************************
+               get the link status here, we need to wait until the link comes
+               back after reconfiguring it.
+             *****************************************************************/
+            TPAL_GetLinkStatusInfo( pAdapter );
+        }
+
+        // SetRxDmaTimer( pAdapter );
+        ConfigMACRegs2( pAdapter );
+    }
+
+    if( pAdapter->PoMgmt.WOLEnabledByCurrentState )
+    {
+        RXMAC_WOL_CTL_CRC0_t    rxmac_ctl_crc0 = pAdapter->CSRAddress->rxmac.crc0;
+        RXMAC_WOL_CRC12_t       crc12;
+        RXMAC_WOL_CRC34_t       crc34;
+        ULONG               ulResult;
+        UINT32              SerdesPhyControl;
+        UINT                    mask;
+
+        ulResult = NdisReadPciSlotInformation( pAdapter->AdapterHandle,
+                                    0,          // not used
+                                    ET1310_PCI_PHY_INDEX_REG,
+                                    (PVOID)&SerdesPhyControl,
+                                    sizeof( UINT32 ));
+
+        if( pAdapter->RegistryPMWOL )
+        {
+            SerdesPhyControl |= 0x00010000;
+        }
+        else
+        {
+            SerdesPhyControl &= 0xfffeffff;
+        }
+
+        ulResult = NdisWritePciSlotInformation(
+                                pAdapter->AdapterHandle,
+                                0,
+                                ET1310_PCI_PHY_INDEX_REG,
+                                (PVOID)&SerdesPhyControl,
+                                sizeof( UINT32 ));
+
+        if( pAdapter->Bmsr.bits.link_status )
+        {
+            /**********************************************************************
+                need to do this for all wake devices
+                make sure all ignore bits are set
+             *********************************************************************/
+            rxmac_ctl_crc0.bits.ignore_broad       = 1;
+            rxmac_ctl_crc0.bits.ignore_multi       = 1;
+            rxmac_ctl_crc0.bits.ignore_uni         = 1;
+
+            if( pAdapter->RegistryWOLMatch & 0x1 )
+            {
+                rxmac_ctl_crc0.bits.ignore_mp          = 0;
+            }
+            else
+            {
+                rxmac_ctl_crc0.bits.ignore_mp          = 1;
+            }
+
+            if( pAdapter->RegistryWOLMatch & 0x2 )
+            {
+                rxmac_ctl_crc0.bits.ignore_pp          = 0;
+            }
+            else
+            {
+                rxmac_ctl_crc0.bits.ignore_pp          = 1;
+            }
+
+            if( pAdapter->RegistryWOLLink & 0x1 )
+            {
+                rxmac_ctl_crc0.bits.ignore_link_chg    = 0;
+            }
+            else
+            {
+                rxmac_ctl_crc0.bits.ignore_link_chg    = 1;
+            }
+
+            /******************************************************************
+                Clear the pattern match validity bits - i.e. make all patterns
+                invalid
+             *****************************************************************/
+            rxmac_ctl_crc0.value &= ~0x1f;
+
+            if(( pAdapter->RegistryWOLMatch & 0x2 ) &&
+                ( pAdapter->PoMgmt.localWolAndCrc0 & 0x1f ))
+            {
+                /**************************************************************
+                    set the validity bits based on what has been enabled in
+                    the adapter
+                 *************************************************************/
+                rxmac_ctl_crc0.value |= (pAdapter->PoMgmt.localWolAndCrc0 & 0x1f);
+
+                /**************************************************************
+                    Copy the five CRCs from the adapter
+                 *************************************************************/
+                rxmac_ctl_crc0.bits.crc0  = pAdapter->PoMgmt.WOLPatternList [0];
+                crc12.bits.crc1 = pAdapter->PoMgmt.WOLPatternList [1];
+                crc12.bits.crc2 = pAdapter->PoMgmt.WOLPatternList [2];
+                crc34.bits.crc3 = pAdapter->PoMgmt.WOLPatternList [3];
+                crc34.bits.crc4 = pAdapter->PoMgmt.WOLPatternList [4];
+
+                for( mask = 0; mask < 5; mask++)
+                {
+                    UINT        i;
+                    PUINT32     pDevicePatternMask = (PUINT32)
+                        (&pAdapter->CSRAddress->rxmac.mask0_word0) +
+                                                        (mask * MAX_WOL_MASK_SIZE / 4);
+                    if(( pAdapter->PoMgmt.localWolAndCrc0 >> mask ) & 0x1 )
+                    {
+                        UINT32      Temp[ MAX_WOL_MASK_SIZE / 4 ];
+                        PUCHAR      pNdisPatternMask;
+
+                        pNdisPatternMask = (PUCHAR)&pAdapter->PoMgmt.WOLMaskList[ mask ][ 0 ];
+
+                        NdisZeroMemory( Temp, sizeof( Temp ));
+                        NdisMoveMemory( Temp, pNdisPatternMask,
+                                        pAdapter->PoMgmt.WOLMaskSize[ mask ] );
+
+                        /**************************************************************
+                            Write the mask to the device using the pointer calculated
+                            above.
+                        *************************************************************/
+                        for( i=0; i<( MAX_WOL_MASK_SIZE / 4 ); i++ )
+                        {
+                            pDevicePatternMask[ i ] = Temp[ i ];
+                        }
+                    }
+                }
+            }
+
+            pAdapter->CSRAddress->rxmac.crc0 = rxmac_ctl_crc0;
+            pAdapter->CSRAddress->rxmac.crc12 = crc12;
+            pAdapter->CSRAddress->rxmac.crc34 = crc34;
+
+            /******************************************************************
+		        we also need to read and clear the phy_interrupt register in
+                case of wakeup on link status change
+	         *****************************************************************/
+            MiRead( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                    (UINT8)offsetof( MI_REGS_t, isr ), &isr.value );
+
+            MiRead( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                    (UINT8)offsetof( MI_REGS_t, bmsr ), &lBmsr.value );
+
+            /******************************************************************
+                disable mif and async
+             *****************************************************************/
+		    ctrl.bits.mif_disable            = 1;
+		    ctrl.bits.async_disable          = 1;
+            ctrl.bits.wol_disable            = 0;
+            pAdapter->CSRAddress->rxmac.ctrl = ctrl;
+
+            rxmac_ctl_crc0.bits.clr_intr                = 1;
+            pAdapter->CSRAddress->rxmac.crc0.value = rxmac_ctl_crc0.value;
+
+            DBGPRINT( MP_SPEC, ("Going down - ctrl 0x%x, crc0_ctl 0x%x\n",
+                pAdapter->CSRAddress->rxmac.ctrl.value,
+                pAdapter->CSRAddress->rxmac.crc0.value ));
+
+            pAdapter->Stats.InterruptStatus.value = pAdapter->CSRAddress->global.int_status.value;
+
+            DBGPRINT( MP_SPEC, ("Going down - int stat was 0x%x, now 0x%x\n",
+                pAdapter->Stats.InterruptStatus.value,
+                pAdapter->CSRAddress->global.int_status.value ));
+        }
+        else if( pAdapter->RegistryWOLLink & 0x1 )
+        {
+            GlobalPmCSR = pAdapter->CSRAddress->global.pm_csr;
+
+	        /**************************************************************************
+                Gate off JAGCore 3 clock domains
+            *************************************************************************/
+	        GlobalPmCSR.bits.pm_sysclk_gate     = 0;
+            GlobalPmCSR.bits.pm_txclk_gate      = 0;
+            GlobalPmCSR.bits.pm_rxclk_gate      = 0;
+            pAdapter->CSRAddress->global.pm_csr = GlobalPmCSR;
+
+	        /**************************************************************************
+                Program gigE PHY in to Coma mode
+            *************************************************************************/
+	        GlobalPmCSR.bits.pm_phy_sw_coma     = 1;
+            GlobalPmCSR.bits.pm_phy_lped_en     = 1;
+
+            pAdapter->CSRAddress->global.pm_csr = GlobalPmCSR;
+        }
+    }
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  MPSetPowerD1Wake
+ ******************************************************************************
+   DESCRIPTION:
+        This routine is called when the adapter receives a SetPower to
+        D1 PowerState, and there is a set of wake-up patterns programmed
+        in the adapter.  The set could consist of a single wake-up pattern.
+
+   PARAMETERS :
+        pAdapter   - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+VOID MPSetPowerD1Wake( PMP_ADAPTER pAdapter )
+{
+    UINT32        uPmCsr;
+    PM_CSR_t     pm_csr;
+    /*-----------------------------------------------------------------------*/
+
+    DBGPRINT( MP_TRACE, ( "----> MPSetPowerD1Wake\n" ));
+
+    /**************************************************************************
+        common power down functionality; disable Tx & Rx, disable wol while
+        it is being provisioned, archive Tx and Rx enable, and do some of the
+        gating into jagcore.
+     *************************************************************************/
+    MPSetLowPower( pAdapter, NdisDeviceStateD1 );
+
+    if((( pAdapter->RegistryWOLLink & 0x1) == 0 ) || ( pAdapter->Bmsr.bits.link_status ))
+    {
+        /**********************************************************************
+        gate off paths we do not want active and leave ones we do
+         *********************************************************************/
+        pm_csr = pAdapter->CSRAddress->global.pm_csr;
+
+    pm_csr.bits.pm_sysclk_gate = 0;
+    pm_csr.bits.pm_txclk_gate  = 0;
+    pm_csr.bits.pm_rxclk_gate  = 1;
+
+    pAdapter->CSRAddress->global.pm_csr = pm_csr;
+    }
+
+    /**************************************************************************
+       Set the power state to 1 (d1), and blip the PME status pin.  Set the
+       PME Enable pin, which indicates wake state to PCI.
+     *************************************************************************/
+    uPmCsr = 0x00008100;
+    NdisWritePciSlotInformation( pAdapter->AdapterHandle,
+                                 0, // Slot no.  Reserved.  Ndis ignores.
+                                 ET1310_PCI_PM_CSR,
+                                 &uPmCsr,
+                                 sizeof( UINT32 ));
+
+    DBGPRINT( MP_TRACE, ( "<---- MPSetPowerD1Wake\n" ));
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+
+/******************************************************************************
+   ROUTINE:  MPSetPowerD1NonWake
+ ******************************************************************************
+   DESCRIPTION:
+        This routine is called when the adapter receives a SetPower to
+        D1 PowerState, and there are no wake-up patterns programmed
+        in the adapter.
+
+   PARAMETERS :
+        pAdapter   - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+VOID MPSetPowerD1NonWake( PMP_ADAPTER pAdapter )
+{
+    UINT32   uPmCsr;
+    PM_CSR_t pm_csr;
+    /*-----------------------------------------------------------------------*/
+
+    DBGPRINT( MP_TRACE, ( "----> MPSetPowerD1NonWake\n" ));
+
+    /**************************************************************************
+        common power down functionality; disable Tx & Rx, disable wol,
+        archive Tx and Rx enable, and do some of the gating into jagcore.
+     *************************************************************************/
+	MPSetLowPower( pAdapter, NdisDeviceStateD1 );
+
+    /**************************************************************************
+        gate off paths we do not want active and leave ones we do
+     *************************************************************************/
+    pm_csr = pAdapter->CSRAddress->global.pm_csr;
+
+    pm_csr.bits.pm_sysclk_gate = 1;
+    pm_csr.bits.pm_txclk_gate  = 1;
+    pm_csr.bits.pm_rxclk_gate  = 1;
+
+    pAdapter->CSRAddress->global.pm_csr = pm_csr;
+
+    /**************************************************************************
+       Set the power state to 1 (d1), and blip the PME status pin.  Leave the
+       PME Enable pin clear, which indicates non-wake state to PCI.
+     *************************************************************************/
+    uPmCsr = 0x00008000;
+    NdisWritePciSlotInformation( pAdapter->AdapterHandle,
+                                 0, // Slot no.  Reserved.  Ndis ignores.
+                                 ET1310_PCI_PM_CSR,
+                                 &uPmCsr,
+                                 sizeof( UINT32 ));
+
+    DBGPRINT( MP_TRACE, ( "<---- MPSetPowerD1NonWake\n" ));
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+
+/******************************************************************************
+   ROUTINE:  MPSetPowerD3Wake
+ ******************************************************************************
+   DESCRIPTION:
+        This routine is called when the adapter receives a SetPower to
+        D3 PowerState, and there is a set of wake-up patterns programmed
+        in the adapter.  The set could consist of a single wake-up pattern.
+
+   PARAMETERS :
+        pAdapter   - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+VOID MPSetPowerD3Wake( PMP_ADAPTER pAdapter )
+{
+    UINT32       uPmCsr;
+    PM_CSR_t     pm_csr;
+    /*-----------------------------------------------------------------------*/
+
+    DBGPRINT( MP_TRACE, ( "----> MPSetPowerD3Wake\n" ));
+
+    /**************************************************************************
+        common power down functionality; disable Tx & Rx, disable wol while
+        it is being provisioned, archive Tx and Rx enable, and do some of the
+        gating into jagcore.
+     *************************************************************************/
+    MPSetLowPower( pAdapter, NdisDeviceStateD3 );
+
+    if((( pAdapter->RegistryWOLLink & 0x1) == 0 ) || ( pAdapter->Bmsr.bits.link_status ))
+    {
+        /**********************************************************************
+           gate off paths we do not want active and leave ones we do
+         *********************************************************************/
+        pm_csr = pAdapter->CSRAddress->global.pm_csr;
+
+        pm_csr.bits.pm_sysclk_gate = 0;
+        pm_csr.bits.pm_txclk_gate  = 0;
+        pm_csr.bits.pm_rxclk_gate  = 1;
+
+        pAdapter->CSRAddress->global.pm_csr = pm_csr;
+    }
+
+    /**************************************************************************
+       Set the power state to 3 (d3), and blip the PME status pin.  Set the
+       PME Enable pin, which indicates wake state to PCI.
+     *************************************************************************/
+    uPmCsr = 0x00008100;
+    NdisWritePciSlotInformation( pAdapter->AdapterHandle,
+                                 0, // Slot no.  Reserved.  Ndis ignores.
+                                 ET1310_PCI_PM_CSR,
+                                 &uPmCsr,
+                                 sizeof( UINT32 ));
+
+    DBGPRINT( MP_TRACE, ( "<---- MPSetPowerD3Wake\n" ));
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  MPSetPowerD3NonWake
+ ******************************************************************************
+   DESCRIPTION:
+        This routine is called when the adapter receives a SetPower to
+        D3 PowerState, and there are no wake-up patterns programmed
+        in the adapter.
+
+   PARAMETERS :
+        pAdapter   - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+VOID MPSetPowerD3NonWake( PMP_ADAPTER pAdapter )
+{
+    UINT32   uPmCsr;
+    PM_CSR_t pm_csr;
+    /*-----------------------------------------------------------------------*/
+
+    DBGPRINT( MP_TRACE, ( "----> MPSetPowerD3NonWake\n" ));
+
+    /**************************************************************************
+        common power down functionality; disable Tx & Rx, disable wol,
+        archive Tx and Rx enable, and do some of the gating into jagcore.
+     *************************************************************************/
+    MPSetLowPower( pAdapter, NdisDeviceStateD3 );
+
+    /**************************************************************************
+        gate off paths we do not want active and leave ones we do
+     *************************************************************************/
+    pm_csr = pAdapter->CSRAddress->global.pm_csr;
+    pm_csr.bits.pm_sysclk_gate = 1;
+    pm_csr.bits.pm_txclk_gate  = 1;
+    pm_csr.bits.pm_rxclk_gate  = 1;
+
+    pAdapter->CSRAddress->global.pm_csr = pm_csr;
+
+    /**************************************************************************
+       Set the power state to 3 (d3), and blip the PME status pin.  Leave the
+       PME Enable pin clear, which indicates non-wake state to PCI.
+     *************************************************************************/
+    uPmCsr = 0x00008000;
+    NdisWritePciSlotInformation( pAdapter->AdapterHandle,
+                                 0, // Slot no.  Reserved.  Ndis ignores.
+                                 ET1310_PCI_PM_CSR,
+                                 &uPmCsr,
+                                 sizeof( UINT32 ));
+
+    DBGPRINT( MP_TRACE, ( "<---- MPSetPowerD3NonWake\n" ));
+
+    return;
+}
+/*===========================================================================*/
+
+#endif
+
+
+/******************************************************************************
+   ROUTINE:  EnablePhyComa
+ ******************************************************************************
+   DESCRIPTION:
+        This routine is called when network cable is unplugged -- driver
+        receive an phy status change interrupt while in D0 and check that
+        phy_status is down.
+
+            -- gate off JAGCore;
+            -- set gigE PHY in Coma mode
+            -- wake on phy_interrupt; Perform software reset JAGCore,
+               re-initialize jagcore and gigE PHY
+
+        Add D0-ASPM-PhyLinkDown Support:
+            -- while in D0, when there is a phy_interrupt indicating phy link
+               down status, call the MPSetPhyComa routine to enter this active
+               state power saving mode
+            -- while in D0-ASPM-PhyLinkDown mode, when there is a phy_interrupt
+		       indicating linkup status, call the MPDisablePhyComa routine to
+               restore JAGCore and gigE PHY
+
+   PARAMETERS :
+        pAdapter   - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void EnablePhyComa( ET131X_ADAPTER *pAdapter )
+{
+    unsigned long lockflags;
+    PM_CSR_t      GlobalPmCSR = pAdapter->CSRAddress->global.pm_csr;
+    INT32         LoopCounter = 10;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "EnablePhyComa" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+	/**************************************************************************
+	   Save the GbE PHY speed and duplex modes
+	   Need to restore this when cable is plugged back in
+	 *************************************************************************/
+	pAdapter->PoMgmt.PowerDownSpeed  = pAdapter->AiForceSpeed;
+    pAdapter->PoMgmt.PowerDownDuplex = pAdapter->AiForceDpx;
+
+
+    /**************************************************************************
+       Stop sending packets.
+     *************************************************************************/
+    spin_lock_irqsave( &pAdapter->SendHWLock, lockflags );
+
+    MP_SET_FLAG( pAdapter, fMP_ADAPTER_LOWER_POWER );
+
+    spin_unlock_irqrestore( &pAdapter->SendHWLock, lockflags );
+
+
+	/**************************************************************************
+       Wait for outstanding Receive packets
+     *************************************************************************/
+    while(( MP_GET_RCV_REF( pAdapter ) != 0 ) && ( LoopCounter-- > 0 ))
+    {
+        /**********************************************************************
+           Sleep for 2 Ms;
+         *********************************************************************/
+        mdelay( 2 );
+    }
+
+
+	/**************************************************************************
+       Gate off JAGCore 3 clock domains
+     *************************************************************************/
+	GlobalPmCSR.bits.pm_sysclk_gate     = 0;
+    GlobalPmCSR.bits.pm_txclk_gate      = 0;
+    GlobalPmCSR.bits.pm_rxclk_gate      = 0;
+    pAdapter->CSRAddress->global.pm_csr = GlobalPmCSR;
+
+
+	/**************************************************************************
+       Program gigE PHY in to Coma mode
+     *************************************************************************/
+	GlobalPmCSR.bits.pm_phy_sw_coma     = 1;
+
+    pAdapter->CSRAddress->global.pm_csr = GlobalPmCSR;
+
+
+	DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  DisablePhyComa
+ ******************************************************************************
+   DESCRIPTION:
+        This routine is used to disable the Phy Coma Mode
+
+   PARAMETERS :
+        pAdapter   - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void DisablePhyComa( ET131X_ADAPTER *pAdapter )
+{
+    PM_CSR_t     GlobalPmCSR = pAdapter->CSRAddress->global.pm_csr;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "DisablePhyComa" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /*************************************************************************
+       Disable phy_sw_coma register and re-enable JAGCore clocks
+     ************************************************************************/
+    GlobalPmCSR.bits.pm_sysclk_gate     = 1;
+    GlobalPmCSR.bits.pm_txclk_gate      = 1;
+    GlobalPmCSR.bits.pm_rxclk_gate      = 1;
+    GlobalPmCSR.bits.pm_phy_sw_coma     = 0;
+
+    pAdapter->CSRAddress->global.pm_csr = GlobalPmCSR;
+
+
+    /**************************************************************************
+       Restore the GbE PHY speed and duplex modes;
+       Reset JAGCore; re-configure and initialize JAGCore and gigE PHY
+     *************************************************************************/
+    pAdapter->AiForceSpeed = pAdapter->PoMgmt.PowerDownSpeed;
+    pAdapter->AiForceDpx   = pAdapter->PoMgmt.PowerDownDuplex;
+
+
+    /**************************************************************************
+       Re-initialize the send structures
+     *************************************************************************/
+    et131x_init_send( pAdapter );
+
+
+    /**************************************************************************
+       Reset the RFD list and re-start RU
+     *************************************************************************/
+    et131x_reset_recv( pAdapter );
+
+
+    /**************************************************************************
+       Bring the device back to the state it was during init prior to
+       autonegotiation being complete.  This way, when we get the auto-neg
+       complete interrupt, we can complete init by calling ConfigMacREGS2.
+     *************************************************************************/
+    et131x_soft_reset( pAdapter );
+
+
+    /**************************************************************************
+       setup et1310 as per the documentation ??
+     *************************************************************************/
+    et131x_adapter_setup( pAdapter );
+
+
+    /**************************************************************************
+        Allow Tx to restart
+     *************************************************************************/
+    MP_CLEAR_FLAG( pAdapter, fMP_ADAPTER_LOWER_POWER );
+
+
+    /**************************************************************************
+       Need to re-enable Rx.
+     *************************************************************************/
+    et131x_rx_dma_enable( pAdapter );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+#if 0
+/******************************************************************************
+   ROUTINE:  MPSetPower
+ ******************************************************************************
+
+   DESCRIPTION:
+        This routine is called when the adapter receives a SetPower
+        request. It redirects the call to an appropriate routine to
+        Set the New PowerState
+
+   PARAMETERS :
+         pAdapter   - pointer to the adapter structure
+         PowerState - NewPowerState
+
+   RETURN     :
+        NONE
+
+ *****************************************************************************/
+VOID MPSetPower( IN PMP_ADAPTER             pAdapter,
+                 IN NDIS_DEVICE_POWER_STATE PowerState )
+{
+    DBGPRINT( MP_TRACE, ( "====> MPSetPower()\n" ));
+
+    /**************************************************************************
+       determine what power state we are going to and go there
+     *************************************************************************/
+    pAdapter->PoMgmt.WOLEnabledByCurrentState = TRUE;
+
+    if( !pAdapter->PoMgmt.WOLEnabledByNdis )
+    {
+        pAdapter->PoMgmt.WOLEnabledByCurrentState = FALSE;
+    }
+
+    if(( pAdapter->RegistryWOLMatch == 0 ) && ( pAdapter->RegistryWOLLink == 0 ))
+    {
+        pAdapter->PoMgmt.WOLEnabledByCurrentState = FALSE;
+    }
+
+    if(( pAdapter->PoMgmt.localWolAndCrc0 & 0x1f ) == 0 )
+    {
+        /**********************************************************************
+            There are no wake patterns programmed.
+         *********************************************************************/
+        if( pAdapter->RegistryWOLLink == 0 )
+        {
+            pAdapter->PoMgmt.WOLEnabledByCurrentState = FALSE;
+        }
+    }
+
+    /**************************************************************************
+       If the link is pulled, then the only wake event that will wake us
+       up is wake on link state change.  If this change is disabled (0), go
+       to a non-wake state.
+     *************************************************************************/
+    if( !pAdapter->ucLinkStatus && ( pAdapter->RegistryWOLLink == 0 ))
+    {
+        pAdapter->PoMgmt.WOLEnabledByCurrentState = 0;
+    }
+
+    if( PowerState == NdisDeviceStateD0 )
+    {
+        MPSetPowerD0( pAdapter );
+    }
+    else if( PowerState == NdisDeviceStateD1 )
+    {
+        if( pAdapter->PoMgmt.WOLEnabledByCurrentState )
+        {
+            MPSetPowerD1Wake( pAdapter );
+        }
+        else
+        {
+            MPSetPowerD1NonWake( pAdapter );
+        }
+    }
+    else if( PowerState == NdisDeviceStateD3 )
+    {
+        if( pAdapter->PoMgmt.WOLEnabledByCurrentState )
+        {
+            MPSetPowerD3Wake( pAdapter );
+        }
+        else
+        {
+            MPSetPowerD3NonWake( pAdapter );
+        }
+    }
+
+    DBGPRINT( MP_TRACE, ( "<==== MPSetPower()\n" ));
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  MPFillPoMgmtCaps
+ ******************************************************************************
+
+   DESCRIPTION:
+        Fills in the Power Managment structure depending the capabilities of
+        the software driver and the card.  MGS CURRENTLY NOT SUPPORTED
+
+
+   PARAMETERS :
+         pAdapter       - pointer to the adapter structure
+         pPowManageCaps - power management struct as defined in the DDK,
+         pStatus        - status to be returned by the request,
+         pulInfoLen     - length of the pPowerManagmentCapabilites
+
+   RETURN     :
+        Success or failure
+
+   NOTE:
+        If the driver returns NDIS_STATUS_SUCCESS in response to a query of
+        this OID, NDIS treats a miniport driver as power management-aware.
+        If the driver returns NDIS_STATUS_NOT_SUPPORTED, NDIS treats the
+        miniport driver as a legacy driver that is not power
+        management-aware.
+
+        The Bus driver is the power policy owner here so we do not have to
+        perform our mapping of System States to Device states, that is
+        accomplished by NDIS, we need to worry more about our wake-up
+        capabilities
+
+ *****************************************************************************/
+VOID MPFillPoMgmtCaps( IN     PMP_ADAPTER             pAdapter,
+                       IN OUT PNDIS_PNP_CAPABILITIES  pPowMgmtCaps,
+                       IN OUT PNDIS_STATUS            pStatus,
+                       IN OUT PULONG                  pulInfoLen )
+{
+    BOOLEAN bIsPoMgmtSupported = TRUE;
+    /*-----------------------------------------------------------------------*/
+
+    bIsPoMgmtSupported = MPIsPoMgmtSupported( pAdapter );
+
+    if( bIsPoMgmtSupported )
+    {
+        /**********************************************************************
+           NDIS_DEVICE_WAKE_UP_ENABLE;
+         *********************************************************************/
+        pPowMgmtCaps->Flags                                   = 0;
+
+        /**********************************************************************
+           Magic Packet wakeups
+         *********************************************************************/
+        pPowMgmtCaps->WakeUpCapabilities.MinMagicPacketWakeUp =
+                                                             NdisDeviceStateD3;
+
+        /**********************************************************************
+           NdisDeviceStateD3;
+         *********************************************************************/
+        pPowMgmtCaps->WakeUpCapabilities.MinPatternWakeUp     =
+                                                             NdisDeviceStateD3;
+        pPowMgmtCaps->WakeUpCapabilities.MinLinkChangeWakeUp  =
+                                                             NdisDeviceStateD3;
+
+        *pulInfoLen = sizeof( *pPowMgmtCaps );
+        *pStatus    = NDIS_STATUS_SUCCESS;
+    }
+    else
+    {
+        NdisZeroMemory( pPowMgmtCaps, sizeof( *pPowMgmtCaps ));
+
+        *pStatus    = NDIS_STATUS_NOT_SUPPORTED;
+        *pulInfoLen = 0;
+    }
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  MPAddWakeUpPattern
+ ******************************************************************************
+
+   DESCRIPTION:
+        This routine will allocate a local memory structure, copy the pattern,
+        insert the pattern into a linked list and return success
+
+        We are gauranteed that we wll get only one request at a time, so this
+        is implemented without locks.
+
+   PARAMETERS :
+         pAdapter                - pointer to the adapter structure
+         InformationBuffer       - Wake up Pattern
+         InformationBufferLength - Wake Up Pattern Length
+
+   RETURN     :
+        Success - if successful
+        NDIS_STATUS_FAILURE - if memory allocation fails
+
+ *****************************************************************************/
+NDIS_STATUS MPAddWakeUpPattern( IN PMP_ADAPTER  pAdapter,
+                                IN PVOID        InfoBuf,
+                                IN UINT         InfoBufLen )
+{
+    NDIS_STATUS             Status;
+    PNDIS_PM_PACKET_PATTERN pPmPattern       = NULL;
+    UINT                    Slot = 0, FreeSlot = 0xff;
+    PUCHAR                  pNdisPatternMask;
+    PUINT32                 pDevicePatternMask;
+    UINT16                  DevMagicNumber;
+    UINT                    i;
+
+    PUCHAR TempBuf;
+    ULONG  offset;
+
+    /*-----------------------------------------------------------------------*/
+
+    pPmPattern = (PNDIS_PM_PACKET_PATTERN)InfoBuf;
+
+    /**************************************************************************
+        Check that the wake-up pattern is not too large for us.  Also, not
+        sure how to deal with a pattern whose mask is smaller than the pattern
+     *************************************************************************/
+    if(( pPmPattern->MaskSize < (( pPmPattern->PatternSize / 8) + 1)) ||
+       ( pPmPattern->PatternSize > MAX_WOL_PACKET_SIZE))
+    {
+        return( NDIS_STATUS_RESOURCES );
+    }
+
+    NdisAcquireSpinLock( &pAdapter->Lock );
+
+    /**************************************************************************
+        Check to see if there is an empty slot on the device to store this
+        pattern.  Store the slot number for later use.
+     *************************************************************************/
+    while ((FreeSlot == 0xff) && (Slot < NUM_WOL_PATTERNS))
+    {
+        if (!((pAdapter->PoMgmt.localWolAndCrc0 >> Slot) & 0x1))
+        {
+            FreeSlot = Slot;
+        }
+        else
+        {
+            Slot++;
+        }
+    }
+
+    if( FreeSlot == 0xff )
+    {
+        /**********************************************************************
+            Failed to find a free slot.
+         *********************************************************************/
+        NdisReleaseSpinLock( &pAdapter->Lock );
+        return( NDIS_STATUS_RESOURCES );
+    }
+
+    pNdisPatternMask = (PUCHAR)InfoBuf + sizeof( NDIS_PM_PACKET_PATTERN );
+
+    /**************************************************************************
+        Make a copy of what Ndis sent us
+     *************************************************************************/
+    for( i=0; i<pPmPattern->MaskSize; i++ )
+    {
+        pAdapter->PoMgmt.WOLMaskList[ FreeSlot ][ i ] = pNdisPatternMask[ i ];
+    }
+
+    /**************************************************************************
+        Calculate the CRC that will be used by the device to identify this
+        packet
+     *************************************************************************/
+    offset  = 0;
+    TempBuf = (PUCHAR)( InfoBuf ) + pPmPattern->PatternOffset;
+
+    DevMagicNumber = MPCalculateCCITCRC16( TempBuf,
+                                           (PUCHAR )( InfoBuf ) +
+                                           sizeof( NDIS_PM_PACKET_PATTERN ),
+                                           pPmPattern->MaskSize );
+
+    DBGPRINT( MP_SPEC, ( "DevMagicNumber 0x%08x\n", DevMagicNumber ));
+    DBGPRINT( MP_SPEC, ( "Pattern Size : 0x%08x, MaskSize : 0x%08x\n",
+        pPmPattern->PatternSize, pPmPattern->MaskSize ));
+
+    pAdapter->PoMgmt.localWolAndCrc0 |= ( 1 << FreeSlot );
+
+    /**************************************************************************
+        Now handle storing the pattern in our adapter.  Only store what makes
+        the pattern unique to our device. (the CRC, the mask and the mask
+        size.  The pattern is irrelevant, since it is not stored in the
+        device).  The mask is stored above.
+     *************************************************************************/
+    pAdapter->PoMgmt.WOLPatternList[ FreeSlot ] = DevMagicNumber;
+    pAdapter->PoMgmt.WOLMaskSize[ FreeSlot ]    = pPmPattern->MaskSize;
+
+    NdisReleaseSpinLock( &pAdapter->Lock );
+    return( NDIS_STATUS_SUCCESS );
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  MPRemoveWakeUpPattern
+ ******************************************************************************
+
+   DESCRIPTION:
+        This routine will scan the array of wake up patterns and attempt to
+        match the wake up pattern.  If it finds a copy , it will remove that
+        WakeUpPattern
+
+   PARAMETERS:
+        pAdapter                - pointer to the Adapter structure
+        InformationBuffer       - Wake up Pattern
+        InformationBufferLength - Wake Up Pattern Length
+
+   RETURN:
+        Success             - if successful.
+        NDIS_STATUS_FAILURE - if memory allocation fails.
+
+ *****************************************************************************/
+NDIS_STATUS MPRemoveWakeUpPattern( IN PMP_ADAPTER  pAdapter,
+                                   IN PVOID        InformationBuffer,
+                                   IN UINT         InformationBufferLength )
+{
+
+    PNDIS_PM_PACKET_PATTERN pPmPattern          = NULL;
+    UINT                    Slot = 0, FoundSlot = 0xff;
+    UINT16                  DevMagicNumber;
+    /*-----------------------------------------------------------------------*/
+
+    pPmPattern = (PNDIS_PM_PACKET_PATTERN)InformationBuffer;
+
+    /**************************************************************************
+        Check that the wake-up pattern is not too large for us.  Also, not
+        sure how to deal with a pattern whose mask is not the same size
+        as the pattern.
+     *************************************************************************/
+    if(( pPmPattern->MaskSize < (( pPmPattern->PatternSize / 8) + 1)) ||
+       ( pPmPattern->PatternSize > MAX_WOL_PACKET_SIZE))
+    {
+        return NDIS_STATUS_FAILURE;
+    }
+
+    /**************************************************************************
+        Calculate the CRC that will be used by the device to identify this
+        packet
+     *************************************************************************/
+    DevMagicNumber = MPCalculateCCITCRC16( (PUCHAR )( InformationBuffer ) +
+                                                    pPmPattern->PatternOffset ,
+                                           (PUCHAR )( InformationBuffer ) +
+                                              sizeof( NDIS_PM_PACKET_PATTERN ),
+                                           pPmPattern->MaskSize );
+
+    NdisAcquireSpinLock( &pAdapter->Lock );
+
+    while ((FoundSlot == 0xff) && (Slot < NUM_WOL_PATTERNS))
+    {
+        if(( pAdapter->PoMgmt.WOLPatternList[ Slot ] == DevMagicNumber ) &&
+           ( pAdapter->PoMgmt.WOLMaskSize[ Slot ] == pPmPattern->MaskSize ) &&
+           (( pAdapter->PoMgmt.localWolAndCrc0 >> Slot ) & 0x1) )
+        {
+            UINT    i;
+            PUCHAR   pIncomingMask = (PUCHAR)( InformationBuffer ) +
+                                              sizeof( NDIS_PM_PACKET_PATTERN );
+
+            for( i=0; i<pPmPattern->MaskSize; i++ )
+            {
+                if( pAdapter->PoMgmt.WOLMaskList[ Slot ][ i ] !=
+                                                           pIncomingMask[ i ] )
+                {
+                    break;
+                }
+            }
+            if( i >= pPmPattern->MaskSize )
+            {
+                FoundSlot = Slot;
+            }
+        }
+
+        Slot++;
+    }
+
+    if( FoundSlot == 0xff )
+    {
+        /**********************************************************************
+            Failed to find this packet in the list coinciding with a valid
+            entry in the device.
+         *********************************************************************/
+        NdisReleaseSpinLock( &pAdapter->Lock );
+        return( NDIS_STATUS_FAILURE );
+    }
+
+    pAdapter->PoMgmt.localWolAndCrc0 &= ~( 1 << FoundSlot );
+
+    NdisReleaseSpinLock( &pAdapter->Lock );
+
+    return( NDIS_STATUS_SUCCESS );
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  MPRemoveAllWakeUpPatterns
+ ******************************************************************************
+
+   DESCRIPTION:
+        This routine disables all wake-up on the device.  Probably not
+        required.
+
+   PARAMETERS:
+        pAdapter - pointer to the adapter structure
+
+   RETURN:
+        Nothing
+
+ *****************************************************************************/
+VOID MPRemoveAllWakeUpPatterns( IN PMP_ADAPTER pAdapter )
+{
+    RXMAC_WOL_CTL_CRC0_t    crc0;
+    /*-----------------------------------------------------------------------*/
+
+    if( pAdapter )
+    {
+        NdisAcquireSpinLock( &pAdapter->Lock );
+
+        pAdapter->PoMgmt.localWolAndCrc0 = 0;
+
+        NdisReleaseSpinLock( &pAdapter->Lock );
+    }
+}
+/*===========================================================================*/
+
+#endif
--- /dev/null
+++ b/drivers/net/et131x/ET1310_pm.h
@@ -0,0 +1,216 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_pm.h - Defines, structs, enums, prototypes, etc. pertaining to power
+ *               management.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:11 $
+     $Revision: 1.5 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef _ET1310_PM_H_
+#define _ET1310_PM_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+
+/******************************************************************************
+   INCLUDES
+ *****************************************************************************/
+#include "ET1310_common.h"
+
+
+
+
+/******************************************************************************
+   CONSTANTS FOR POWER MANAGEMENT
+ *****************************************************************************/
+#define MAX_WOL_PACKET_SIZE    0x80
+#define MAX_WOL_MASK_SIZE      ( MAX_WOL_PACKET_SIZE / 8 )
+#define NUM_WOL_PATTERNS       0x5
+#define CRC16_POLY             0x1021
+
+
+
+
+/******************************************************************************
+   Definition of NDIS_DEVICE_POWER_STATE
+ *****************************************************************************/
+typedef enum
+{
+    NdisDeviceStateUnspecified = 0,
+    NdisDeviceStateD0,
+    NdisDeviceStateD1,
+    NdisDeviceStateD2,
+    NdisDeviceStateD3
+} NDIS_DEVICE_POWER_STATE;
+
+
+
+
+/******************************************************************************
+   Structure for Power Management Info
+ *****************************************************************************/
+typedef struct _MP_PM_CONFIG_SPACE_INFO_t
+{
+    UCHAR  capId;
+    UCHAR  nextItemPtr;
+    UINT16 pmcr;
+    UINT16 pmcsr;
+    UCHAR  pmscr_bse;
+    UCHAR  pm_data_regs;
+}
+MP_PM_CONFIG_SPACE_INFO_t, *pMP_PM_CONFIG_SPACE_INFO_t;
+
+
+
+
+typedef struct _MP_POWER_MGMT
+{
+    /**************************************************************************
+        variable putting the phy into coma mode when boot up with no cable
+        plugged in after 5 seconds
+     *************************************************************************/
+    UCHAR               TransPhyComaModeOnBoot;
+
+
+    /**************************************************************************
+        Array holding the five CRC values that the device is currently using
+        for WOL.  This will be queried when a pattern is to be removed.
+     *************************************************************************/
+    UINT32              localWolAndCrc0;
+    UINT16              WOLPatternList[ NUM_WOL_PATTERNS ];
+    UCHAR               WOLMaskList[ NUM_WOL_PATTERNS ][ MAX_WOL_MASK_SIZE ];
+    UINT32              WOLMaskSize[ NUM_WOL_PATTERNS ];
+
+
+    /**************************************************************************
+       IP address
+     *************************************************************************/
+    union
+    {
+        UINT32  u32;
+        UCHAR   u8[4];
+    } IPAddress;
+
+
+    /**************************************************************************
+       Current Power state of the adapter.
+     *************************************************************************/
+    NDIS_DEVICE_POWER_STATE PowerState;
+    BOOL_t                  WOLState;
+    BOOL_t                  WOLEnabled;
+    BOOL_t                  Failed10Half;
+    BOOL_t                  bFailedStateTransition;
+
+    /**************************************************************************
+        Next two used to save power information at power down.
+        This information will be used during power up to set up parts of Power
+        Management in JAGCore
+     *************************************************************************/
+    UINT32  tx_en;
+    UINT32  rx_en;
+    UINT16  PowerDownSpeed;
+    UCHAR   PowerDownDuplex;
+
+    MP_PM_CONFIG_SPACE_INFO_t   pmConfigRegs;
+} MP_POWER_MGMT, *PMP_POWER_MGMT;
+
+
+
+
+/******************************************************************************
+   Forward declaration of the private adapter structure
+   ( IS THERE A WAY TO DO THIS WITH A TYPEDEF??? )
+ *****************************************************************************/
+struct et131x_adapter;
+
+
+
+
+/******************************************************************************
+   PROTOTYPES for ET1310_pm.c
+ *****************************************************************************/
+UINT16 CalculateCCITCRC16( PUCHAR Pattern, PUCHAR Mask, UINT32 MaskSize );
+
+void EnablePhyComa( struct et131x_adapter *pAdapter );
+
+void DisablePhyComa( struct et131x_adapter *pAdapter );
+
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* _ET1310_PM_H_ */
--- /dev/null
+++ b/drivers/net/et131x/ET1310_rx.c
@@ -0,0 +1,2046 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_rx.c - Routines used to perform data reception
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2006/01/20 21:29:44 $
+     $Revision: 1.21 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#include <linux/if_vlan.h>
+#endif
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_initpci.h"
+
+#include "ET1310_rx.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   Prototypes for functions local to this module
+ *****************************************************************************/
+void nic_return_rfd( ET131X_ADAPTER *pAdapter, PMP_RFD pMpRfd );
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_rx_dma_memory_alloc
+ ******************************************************************************
+
+   DESCRIPTION       : Allocates Free buffer ring 1 for sure, free buffer ring
+                       0 if required, and the Packet Status Ring
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_rx_dma_memory_alloc( ET131X_ADAPTER *adapter )
+{
+    UINT32          OuterLoop, InnerLoop;
+    UINT32          bufsize;
+    UINT32          pktStatRingSize, FBRChunkSize;
+    RX_RING_t      *rx_ring;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_rx_dma_memory_alloc" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Setup some convenience pointers
+     *************************************************************************/
+    rx_ring = (RX_RING_t *)&adapter->RxRing;
+
+
+    /**************************************************************************
+       Alloc memory for the lookup table
+     *************************************************************************/
+#ifdef USE_FBR0
+    rx_ring->Fbr[0] = kmalloc( sizeof( FBRLOOKUPTABLE ), GFP_KERNEL );
+#endif
+
+    rx_ring->Fbr[1] = kmalloc( sizeof( FBRLOOKUPTABLE ), GFP_KERNEL );
+
+
+    /**************************************************************************
+        The first thing we will do is configure the sizes of the buffer rings.
+        These will change based on jumbo packet support.  Larger jumbo packets
+        increases the size of each entry in FBR0, and the number of entries in
+        FBR0, while at the same time decreasing the number of entries in FBR1.
+
+        FBR1 holds "large" frames, FBR0 holds "small" frames.  If FBR1 entries
+        are huge in order to accomodate a "jumbo" frame, then it will have less
+        entries.  Conversely, FBR1 will now be relied upon to carry more
+        "normal" frames, thus it's entry size also increases and the number
+        of entries goes up too (since it now carries "small" + "regular"
+        packets.
+
+        In this scheme, we try to maintain 512 entries between the two rings.
+        Also, FBR1 remains a constant size - when it's size doubles the
+        number of entries halves.  FBR0 increases in size, however.
+     *************************************************************************/
+
+    if( adapter->RegistryJumboPacket < 2048 )
+    {
+#ifdef USE_FBR0
+        rx_ring->Fbr0BufferSize = 256;
+        rx_ring->Fbr0NumEntries = 512;
+#endif
+        rx_ring->Fbr1BufferSize = 2048;
+        rx_ring->Fbr1NumEntries = 512;
+    }
+    else if( adapter->RegistryJumboPacket < 4096 )
+    {
+#ifdef USE_FBR0
+        rx_ring->Fbr0BufferSize = 512;
+        rx_ring->Fbr0NumEntries = 1024;
+#endif
+        rx_ring->Fbr1BufferSize = 4096;
+        rx_ring->Fbr1NumEntries = 512;
+    }
+    else
+    {
+#ifdef USE_FBR0
+        rx_ring->Fbr0BufferSize = 1024;
+        rx_ring->Fbr0NumEntries = 768;
+#endif
+        rx_ring->Fbr1BufferSize = 16384;
+        rx_ring->Fbr1NumEntries = 128;
+    }
+
+#ifdef USE_FBR0
+    adapter->RxRing.PsrNumEntries = adapter->RxRing.Fbr0NumEntries +
+                                    adapter->RxRing.Fbr1NumEntries;
+#else
+    adapter->RxRing.PsrNumEntries = adapter->RxRing.Fbr1NumEntries;
+#endif
+
+
+    /**************************************************************************
+       Allocate an area of memory for Free Buffer Ring 1
+     *************************************************************************/
+    bufsize = ( sizeof( FBR_DESC_t ) * rx_ring->Fbr1NumEntries) + 0xfff;
+    rx_ring->pFbr1RingVa = pci_alloc_consistent( adapter->pdev,
+                                                 bufsize,
+                                                 &rx_ring->pFbr1RingPa );
+    if( !rx_ring->pFbr1RingVa )
+    {
+        DBG_ERROR( et131x_dbginfo, "Cannot alloc memory for Free Buffer Ring 1\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+
+    /**************************************************************************
+       Save physical address
+
+       NOTE : pci_alloc_consistent(), used above to alloc DMA regions, ALWAYS
+              returns SAC (32-bit) addresses. If DAC (64-bit) addresses are
+              ever returned, make sure the high part is retrieved here before
+              storing the adjusted address.
+     *************************************************************************/
+    rx_ring->Fbr1Realpa = rx_ring->pFbr1RingPa;
+
+
+    /**************************************************************************
+       Align Free Buffer Ring 1 on a 4K boundary
+     *************************************************************************/
+    et131x_align_allocated_memory( adapter,
+                                   &rx_ring->Fbr1Realpa,
+                                   &rx_ring->Fbr1offset,
+                                   0x0FFF );
+
+    rx_ring->pFbr1RingVa = (void *)( (PUCHAR)rx_ring->pFbr1RingVa +
+                                             rx_ring->Fbr1offset );
+
+
+#ifdef USE_FBR0
+    /**************************************************************************
+       Allocate an area of memory for Free Buffer Ring 0
+     *************************************************************************/
+    bufsize = ( sizeof( FBR_DESC_t ) * rx_ring->Fbr0NumEntries ) + 0xfff;
+    rx_ring->pFbr0RingVa = pci_alloc_consistent( adapter->pdev,
+                                                 bufsize,
+                                                 &rx_ring->pFbr0RingPa );
+    if( !rx_ring->pFbr0RingVa )
+    {
+        DBG_ERROR( et131x_dbginfo, "Cannot alloc memory for Free Buffer Ring 0\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+
+    /**************************************************************************
+       Save physical address
+
+       NOTE : pci_alloc_consistent(), used above to alloc DMA regions, ALWAYS
+              returns SAC (32-bit) addresses. If DAC (64-bit) addresses are
+              ever returned, make sure the high part is retrieved here before
+              storing the adjusted address.
+     *************************************************************************/
+    rx_ring->Fbr0Realpa =  rx_ring->pFbr0RingPa;
+
+
+    /**************************************************************************
+       Align Free Buffer Ring 0 on a 4K boundary
+     *************************************************************************/
+    et131x_align_allocated_memory( adapter,
+                                   &rx_ring->Fbr0Realpa,
+                                   &rx_ring->Fbr0offset,
+                                   0x0FFF );
+
+    rx_ring->pFbr0RingVa = (void *)( (PUCHAR)rx_ring->pFbr0RingVa +
+                                             rx_ring->Fbr0offset );
+
+#endif
+
+
+    for( OuterLoop = 0; OuterLoop < (rx_ring->Fbr1NumEntries / FBR_CHUNKS); OuterLoop++ )
+    {
+        UINT64  Fbr1Offset;
+        UINT64  Fbr1TempPa;
+        UINT32  Fbr1Align;
+
+        /**********************************************************************
+           This code allocates an area of memory big enough for N free
+           buffers + (buffer_size - 1) so that the buffers can be aligned
+           on 4k boundaries.  If each buffer were aligned
+           to a buffer_size boundary, the effect would be to double the size
+           of FBR0.  By allocating N buffers at once, we reduce this overhead.
+         *********************************************************************/
+        if( rx_ring->Fbr1BufferSize > 4096 )
+        {
+            Fbr1Align = 4096;
+        }
+        else
+        {
+            Fbr1Align = rx_ring->Fbr1BufferSize;
+        }
+
+        FBRChunkSize = ( FBR_CHUNKS * rx_ring->Fbr1BufferSize ) + Fbr1Align - 1;
+        rx_ring->Fbr1MemVa[OuterLoop] = pci_alloc_consistent( adapter->pdev,
+                                                              FBRChunkSize,
+                                                              &rx_ring->Fbr1MemPa[OuterLoop] );
+
+        if( !rx_ring->Fbr1MemVa[OuterLoop] )
+        {
+            DBG_ERROR( et131x_dbginfo, "Could not alloc memory\n" );
+            DBG_LEAVE( et131x_dbginfo );
+            return -ENOMEM;
+        }
+
+
+        /**********************************************************************
+           See NOTE in "Save Physical Address" comment above
+         *********************************************************************/
+        Fbr1TempPa = rx_ring->Fbr1MemPa[OuterLoop];
+
+        et131x_align_allocated_memory( adapter,
+                                       &Fbr1TempPa,
+                                       &Fbr1Offset,
+                                       (Fbr1Align - 1));
+
+
+        for( InnerLoop = 0; InnerLoop < FBR_CHUNKS; InnerLoop++ )
+        {
+            UINT32 index = (OuterLoop * FBR_CHUNKS) + InnerLoop;
+
+
+            /******************************************************************
+                Save the Virtual address of this index for quick access later
+             *****************************************************************/
+            rx_ring->Fbr[1]->Va[index] = (PUCHAR)rx_ring->Fbr1MemVa[OuterLoop] +
+                                        ( InnerLoop * rx_ring->Fbr1BufferSize ) +
+                                        Fbr1Offset;
+
+
+            /******************************************************************
+                now store the physical address in the descriptor so the device
+                can access it
+             *****************************************************************/
+            rx_ring->Fbr[1]->PAHigh[index] = (UINT32)(Fbr1TempPa >> 32);
+            rx_ring->Fbr[1]->PALow[index]  = (UINT32) Fbr1TempPa;
+
+            Fbr1TempPa += rx_ring->Fbr1BufferSize;
+
+            rx_ring->Fbr[1]->Buffer1[index] = rx_ring->Fbr[1]->Va[index];
+            rx_ring->Fbr[1]->Buffer2[index] = rx_ring->Fbr[1]->Va[index] - 4;
+        }
+    }
+
+#ifdef USE_FBR0
+    /**************************************************************************
+        Same for FBR0 (if in use)
+     *************************************************************************/
+    for( OuterLoop = 0; OuterLoop < (rx_ring->Fbr0NumEntries / FBR_CHUNKS); OuterLoop++ )
+    {
+        UINT64  Fbr0Offset;
+        UINT64  Fbr0TempPa;
+
+        FBRChunkSize = (( FBR_CHUNKS + 1 ) * rx_ring->Fbr0BufferSize ) - 1;
+        rx_ring->Fbr0MemVa[OuterLoop] = pci_alloc_consistent( adapter->pdev,
+                                                              FBRChunkSize,
+                                                              &rx_ring->Fbr0MemPa[OuterLoop] );
+
+        if( !rx_ring->Fbr0MemVa[OuterLoop] )
+        {
+            DBG_ERROR( et131x_dbginfo, "Could not alloc memory\n" );
+            DBG_LEAVE( et131x_dbginfo );
+            return -ENOMEM;
+        }
+
+
+        /**********************************************************************
+           See NOTE in "Save Physical Address" comment above
+         *********************************************************************/
+        Fbr0TempPa = rx_ring->Fbr0MemPa[OuterLoop];
+
+        et131x_align_allocated_memory( adapter,
+                                       &Fbr0TempPa,
+                                       &Fbr0Offset,
+                                       rx_ring->Fbr0BufferSize - 1 );
+
+
+        for( InnerLoop = 0; InnerLoop < FBR_CHUNKS; InnerLoop++ )
+        {
+            UINT32 index = (OuterLoop * FBR_CHUNKS) + InnerLoop;
+
+            rx_ring->Fbr[0]->Va[index] = (PUCHAR)rx_ring->Fbr0MemVa[OuterLoop] +
+                                        ( InnerLoop * rx_ring->Fbr0BufferSize ) +
+                                        Fbr0Offset;
+
+            rx_ring->Fbr[0]->PAHigh[index] = (UINT32)(Fbr0TempPa >> 32);
+            rx_ring->Fbr[0]->PALow[index]  = (UINT32) Fbr0TempPa;
+
+            Fbr0TempPa += rx_ring->Fbr0BufferSize;
+
+            rx_ring->Fbr[0]->Buffer1[index] = rx_ring->Fbr[0]->Va[index];
+            rx_ring->Fbr[0]->Buffer2[index] = rx_ring->Fbr[0]->Va[index] - 4;
+        }
+    }
+#endif
+
+    /**************************************************************************
+       Allocate an area of memory for the FIFO of Packet Status ring entries
+     *************************************************************************/
+    pktStatRingSize = sizeof( PKT_STAT_DESC_t ) * adapter->RxRing.PsrNumEntries;
+
+    rx_ring->pPSRingVa = pci_alloc_consistent( adapter->pdev,
+                                               pktStatRingSize + 0x0fff,
+                                               &rx_ring->pPSRingPa );
+
+    if( !rx_ring->pPSRingVa )
+    {
+        DBG_ERROR( et131x_dbginfo, "Cannot alloc memory for Packet Status Ring\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+
+    /**************************************************************************
+       Save physical address
+
+       NOTE : pci_alloc_consistent(), used above to alloc DMA regions, ALWAYS
+              returns SAC (32-bit) addresses. If DAC (64-bit) addresses are
+              ever returned, make sure the high part is retrieved here before
+              storing the adjusted address.
+     *************************************************************************/
+    rx_ring->pPSRingRealPa = rx_ring->pPSRingPa;
+
+
+    /**************************************************************************
+       Align Packet Status Ring on a 4K boundary
+     *************************************************************************/
+    et131x_align_allocated_memory( adapter,
+                                   &rx_ring->pPSRingRealPa,
+                                   &rx_ring->pPSRingOffset,
+                                   0x0FFF );
+
+    rx_ring->pPSRingVa = (void *)( (PUCHAR)rx_ring->pPSRingVa +
+                                           rx_ring->pPSRingOffset );
+
+
+    /**************************************************************************
+       Allocate an area of memory for the writeback of status information
+     *************************************************************************/
+    rx_ring->pRxStatusVa = pci_alloc_consistent( adapter->pdev,
+                                                 sizeof( RX_STATUS_BLOCK_t ) + 0x7,
+                                                 &rx_ring->pRxStatusPa );
+    if( !rx_ring->pRxStatusVa )
+    {
+        DBG_ERROR( et131x_dbginfo, "Cannot alloc memory for Status Block\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+
+    /**************************************************************************
+       Save physical address
+     *************************************************************************/
+    rx_ring->RxStatusRealPA = rx_ring->pRxStatusPa;
+
+
+    /**************************************************************************
+       Align write back on an 8 byte boundary
+     *************************************************************************/
+    et131x_align_allocated_memory( adapter,
+                                   &rx_ring->RxStatusRealPA,
+                                   &rx_ring->RxStatusOffset,
+                                   0x07 );
+
+    rx_ring->pRxStatusVa = (void *)( (PUCHAR)rx_ring->pRxStatusVa +
+                                             rx_ring->RxStatusOffset );
+    rx_ring->NumRfd = NIC_DEFAULT_NUM_RFD;
+
+
+    /**************************************************************************
+        Recv
+        pci_pool_create initializes a lookaside list.
+        After successful creation, nonpaged fixed-size blocks can be
+        allocated from and freed to the lookaside list.
+
+        RFDs will be allocated from this pool.
+     *************************************************************************/
+    rx_ring->RecvLookaside = kmem_cache_create( adapter->netdev->name,
+                                                sizeof( MP_RFD ),
+                                                0,
+                                                SLAB_CACHE_DMA |
+                                                SLAB_HWCACHE_ALIGN,
+                                                #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23))
+                                                NULL,
+                                                #endif
+                                                NULL );
+
+
+    MP_SET_FLAG( adapter, fMP_ADAPTER_RECV_LOOKASIDE );
+
+
+    /**************************************************************************
+        The RFDs are going to be put on lists later on, so initialize the lists
+        now.
+     *************************************************************************/
+    INIT_LIST_HEAD( &rx_ring->RecvList );
+    INIT_LIST_HEAD( &rx_ring->RecvPendingList );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_rx_dma_memory_free
+ ******************************************************************************
+
+   DESCRIPTION       : Should basically free all memory allocated within this
+                       module.
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_rx_dma_memory_free( ET131X_ADAPTER *adapter )
+{
+    UINT32     index;
+    UINT32     bufsize;
+    UINT32     pktStatRingSize;
+    PMP_RFD    pMpRfd;
+    RX_RING_t *rx_ring;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_rx_dma_memory_free" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Setup some convenience pointers
+     *************************************************************************/
+    rx_ring = (RX_RING_t *)&adapter->RxRing;
+
+
+    /**************************************************************************
+       Free RFDs and associated packet descriptors
+     *************************************************************************/
+    DBG_ASSERT( rx_ring->nReadyRecv == rx_ring->NumRfd );
+
+    while( !list_empty( &rx_ring->RecvList ))
+    {
+        pMpRfd = (MP_RFD *)list_entry( rx_ring->RecvList.next,
+                                       MP_RFD,
+                                       list_node );
+
+        list_del( &pMpRfd->list_node );
+        et131x_rfd_resources_free( adapter, pMpRfd );
+    }
+
+    while( !list_empty( &rx_ring->RecvPendingList ))
+    {
+        pMpRfd = (MP_RFD *)list_entry( rx_ring->RecvPendingList.next,
+                                       MP_RFD,
+                                       list_node );
+        list_del( &pMpRfd->list_node );
+        et131x_rfd_resources_free( adapter, pMpRfd );
+    }
+
+
+    /**************************************************************************
+        Free Free Buffer Ring 1
+     *************************************************************************/
+    if( rx_ring->pFbr1RingVa )
+    {
+        /**********************************************************************
+            First the packet memory
+         *********************************************************************/
+        for( index = 0; index <
+                      (rx_ring->Fbr1NumEntries / FBR_CHUNKS); index++ )
+        {
+            if( rx_ring->Fbr1MemVa[index] )
+            {
+                UINT32 Fbr1Align;
+
+                if( rx_ring->Fbr1BufferSize > 4096 )
+                {
+                    Fbr1Align = 4096;
+                }
+                else
+                {
+                    Fbr1Align = rx_ring->Fbr1BufferSize;
+                }
+
+                bufsize = ( rx_ring->Fbr1BufferSize * FBR_CHUNKS ) +
+                            Fbr1Align - 1;
+
+                pci_free_consistent( adapter->pdev,
+                                     bufsize,
+                                     rx_ring->Fbr1MemVa[index],
+                                     rx_ring->Fbr1MemPa[index] );
+
+                rx_ring->Fbr1MemVa[index] = 0;
+            }
+        }
+
+
+        /**********************************************************************
+            Now the FIFO itself
+         *********************************************************************/
+        rx_ring->pFbr1RingVa = (void *)( (PUCHAR)rx_ring->pFbr1RingVa -
+                                                 rx_ring->Fbr1offset );
+
+        bufsize = ( sizeof( FBR_DESC_t ) * rx_ring->Fbr1NumEntries ) + 0xfff;
+
+        pci_free_consistent( adapter->pdev,
+                             bufsize,
+                             rx_ring->pFbr1RingVa,
+                             rx_ring->pFbr1RingPa );
+
+        rx_ring->pFbr1RingVa = NULL;
+    }
+
+
+#ifdef USE_FBR0
+    /**********************************************************************
+        Now the same for Free Buffer Ring 0
+     *********************************************************************/
+    if( rx_ring->pFbr0RingVa )
+    {
+        /**********************************************************************
+            First the packet memory
+         *********************************************************************/
+        for( index = 0; index <
+                      (rx_ring->Fbr0NumEntries / FBR_CHUNKS); index++ )
+        {
+            if( rx_ring->Fbr0MemVa[index] )
+            {
+                bufsize = ( rx_ring->Fbr0BufferSize * ( FBR_CHUNKS + 1 )) - 1;
+
+                pci_free_consistent( adapter->pdev,
+                                     bufsize,
+                                     rx_ring->Fbr0MemVa[index],
+                                     rx_ring->Fbr0MemPa[index] );
+
+                rx_ring->Fbr0MemVa[index] = 0;
+            }
+        }
+
+
+        /**********************************************************************
+            Now the FIFO itself
+         *********************************************************************/
+        rx_ring->pFbr0RingVa = (void *)( (PUCHAR)rx_ring->pFbr0RingVa -
+                                                 rx_ring->Fbr0offset );
+
+        bufsize = ( sizeof( FBR_DESC_t ) * rx_ring->Fbr0NumEntries ) + 0xfff;
+
+        pci_free_consistent( adapter->pdev,
+                             bufsize,
+                             rx_ring->pFbr0RingVa,
+                             rx_ring->pFbr0RingPa );
+
+        rx_ring->pFbr0RingVa = NULL;
+    }
+#endif
+
+
+    /**************************************************************************
+        Free Packet Status Ring
+     *************************************************************************/
+    if( rx_ring->pPSRingVa )
+    {
+        rx_ring->pPSRingVa = (void *)( (PUCHAR)rx_ring->pPSRingVa -
+                                               rx_ring->pPSRingOffset );
+
+        pktStatRingSize = sizeof( PKT_STAT_DESC_t ) * adapter->RxRing.PsrNumEntries;
+
+        pci_free_consistent( adapter->pdev,
+                             pktStatRingSize + 0x0fff,
+                             rx_ring->pPSRingVa,
+                             rx_ring->pPSRingPa );
+
+        rx_ring->pPSRingVa = NULL;
+    }
+
+
+    /**********************************************************************
+        Free area of memory for the writeback of status information
+     *********************************************************************/
+    if( rx_ring->pRxStatusVa )
+    {
+        rx_ring->pRxStatusVa = (void *)( (PUCHAR)rx_ring->pRxStatusVa -
+                                                 rx_ring->RxStatusOffset );
+
+        pci_free_consistent( adapter->pdev,
+                             sizeof( RX_STATUS_BLOCK_t ) + 0x7,
+                             rx_ring->pRxStatusVa,
+                             rx_ring->pRxStatusPa );
+
+        rx_ring->pRxStatusVa = NULL;
+    }
+
+
+    /**************************************************************************
+        Free receive buffer pool
+     *************************************************************************/
+
+
+    /**************************************************************************
+       Free receive packet pool
+     *************************************************************************/
+
+
+    /**************************************************************************
+       Destroy the lookaside (RFD) pool
+     *************************************************************************/
+    if( MP_TEST_FLAG( adapter, fMP_ADAPTER_RECV_LOOKASIDE ))
+    {
+        kmem_cache_destroy( rx_ring->RecvLookaside );
+        MP_CLEAR_FLAG( adapter, fMP_ADAPTER_RECV_LOOKASIDE );
+    }
+
+
+    /**************************************************************************
+       Free the FBR Lookup Table
+     *************************************************************************/
+#ifdef USE_FBR0
+    kfree( rx_ring->Fbr[0] );
+#endif
+
+    kfree( rx_ring->Fbr[1] );
+
+
+    /**************************************************************************
+       Reset Counters
+     *************************************************************************/
+    rx_ring->nReadyRecv = 0;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_init_recv
+ ******************************************************************************
+
+   DESCRIPTION       : Initialize receive data structures.
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_init_recv( ET131X_ADAPTER *adapter )
+{
+    int               status        = -ENOMEM;
+    PMP_RFD           pMpRfd        = NULL;
+    UINT32            RfdCount;
+    UINT32            TotalNumRfd   = 0;
+    RX_RING_t        *rx_ring       = NULL;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_init_recv" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Setup some convenience pointers
+     *************************************************************************/
+    rx_ring = (RX_RING_t *)&adapter->RxRing;
+
+
+    /**************************************************************************
+       Setup each RFD
+     *************************************************************************/
+    for( RfdCount = 0; RfdCount < rx_ring->NumRfd; RfdCount++ )
+    {
+        pMpRfd = ( MP_RFD * )kmem_cache_alloc( rx_ring->RecvLookaside,
+                                               GFP_ATOMIC | GFP_DMA );
+
+        if( !pMpRfd )
+        {
+            DBG_ERROR( et131x_dbginfo, "Couldn't alloc RFD out of kmem_cache\n" );
+
+            status = -ENOMEM;
+            continue;
+        }
+
+        status = et131x_rfd_resources_alloc( adapter,pMpRfd );
+        if( status != 0 )
+        {
+            DBG_ERROR( et131x_dbginfo, "Couldn't alloc packet for RFD\n" );
+            kmem_cache_free( rx_ring->RecvLookaside, pMpRfd );
+            continue;
+        }
+
+
+        /**********************************************************************
+           Add this RFD to the RecvList
+         *********************************************************************/
+        list_add_tail( &pMpRfd->list_node, &rx_ring->RecvList );
+
+
+        /**********************************************************************
+           Increment both the available RFD's, and the total RFD's.
+         *********************************************************************/
+        rx_ring->nReadyRecv++;
+        TotalNumRfd++;
+    }
+
+    if( TotalNumRfd > NIC_MIN_NUM_RFD )
+    {
+        status = 0;
+    }
+
+    rx_ring->NumRfd = TotalNumRfd;
+
+    if( status != 0 )
+    {
+        kmem_cache_free( rx_ring->RecvLookaside, pMpRfd );
+        DBG_ERROR( et131x_dbginfo, "Allocation problems in et131x_init_recv\n" );
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_rfd_resources_alloc
+ ******************************************************************************
+
+   DESCRIPTION       :
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+                       pMpRfd  - pointer to a RFD
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_rfd_resources_alloc( ET131X_ADAPTER *adapter, MP_RFD *pMpRfd )
+{
+    pMpRfd->Packet = NULL;
+
+    return 0;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_rfd_resources_free
+ ******************************************************************************
+
+   DESCRIPTION       : Free the packet allocated for the given RFD
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+                       pMpRfd  - pointer to a RFD
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_rfd_resources_free( ET131X_ADAPTER *adapter, MP_RFD *pMpRfd )
+{
+    pMpRfd->Packet = NULL;
+    kmem_cache_free( adapter->RxRing.RecvLookaside, pMpRfd );
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+
+/******************************************************************************
+   ROUTINE:  ConfigRxDmaRegs
+ ******************************************************************************
+   DESCRIPTION:
+        START OF Rx_DMA INIT SEQUENCE
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+
+
+ *****************************************************************************/
+void ConfigRxDmaRegs( ET131X_ADAPTER *pAdapter )
+{
+    PRXDMA_t      pRxDma;
+    PFBR_DESC_t   pFbrEntry;
+    UINT32        iEntry;
+    unsigned long lockflags;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "ConfigRxDmaRegs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Let's get our pointer to the RxDma section of regs
+     *************************************************************************/
+    pRxDma = &pAdapter->CSRAddress->rxdma;
+
+
+    /**************************************************************************
+       Halt RXDMA to perform the reconfigure.
+     *************************************************************************/
+    et131x_rx_dma_disable( pAdapter );
+
+
+    /**************************************************************************
+       Load the completion writeback physical address
+
+       NOTE : pci_alloc_consistent(), used above to alloc DMA regions, ALWAYS
+              returns SAC (32-bit) addresses. If DAC (64-bit) addresses are
+              ever returned, make sure the high part is retrieved here before
+              storing the adjusted address.
+     *************************************************************************/
+    pRxDma->dma_wb_base_hi.addr_hi = (UINT32)( pAdapter->RxRing.RxStatusRealPA >> 32 );
+    pRxDma->dma_wb_base_lo.addr_lo = (UINT32)( pAdapter->RxRing.RxStatusRealPA );
+
+    memset( pAdapter->RxRing.pRxStatusVa, 0, sizeof( RX_STATUS_BLOCK_t ));
+
+
+    /**************************************************************************
+       Set the address and parameters of the packet status ring into the 1310's
+       registers
+     *************************************************************************/
+    pRxDma->psr_base_hi.addr_hi   = (UINT32)( pAdapter->RxRing.pPSRingRealPa >> 32 );
+    pRxDma->psr_base_lo.addr_lo   = (UINT32)( pAdapter->RxRing.pPSRingRealPa );
+
+    pRxDma->psr_num_des.value     = pAdapter->RxRing.PsrNumEntries - 1;
+
+    pRxDma->psr_full_offset.value = 0;
+
+    pRxDma->psr_min_des.value     =
+         ( pRxDma->psr_num_des.bits.psr_ndes * LO_MARK_PERCENT_FOR_PSR ) / 100;
+
+    spin_lock_irqsave( &pAdapter->RcvLock, lockflags );
+
+
+    /**************************************************************************
+       These local variables track the PSR in the adapter structure
+     *************************************************************************/
+    pAdapter->RxRing.local_psr_full.bits.psr_full      = 0;
+    pAdapter->RxRing.local_psr_full.bits.psr_full_wrap = 0;
+
+
+    /**************************************************************************
+       Now's the best time to initialize FBR1 contents
+     *************************************************************************/
+    pFbrEntry = (PFBR_DESC_t) pAdapter->RxRing.pFbr1RingVa;
+
+    for (iEntry=0; iEntry < pAdapter->RxRing.Fbr1NumEntries; iEntry++)
+    {
+        pFbrEntry->addr_hi = pAdapter->RxRing.Fbr[1]->PAHigh[ iEntry ];
+        pFbrEntry->addr_lo = pAdapter->RxRing.Fbr[1]->PALow [ iEntry ];
+        pFbrEntry->word2.bits.bi = iEntry;
+        pFbrEntry++;
+    }
+
+
+    /**************************************************************************
+       Set the address and parameters of Free buffer ring 1 (and 0 if required)
+       into the 1310's registers
+     *************************************************************************/
+    pRxDma->fbr1_base_hi.addr_hi = (UINT32)( pAdapter->RxRing.Fbr1Realpa >> 32 );
+    pRxDma->fbr1_base_lo.addr_lo = (UINT32)( pAdapter->RxRing.Fbr1Realpa );
+
+    pRxDma->fbr1_num_des.value = pAdapter->RxRing.Fbr1NumEntries - 1;
+
+    {
+        RXDMA_FBR_FULL_OFFSET_t fbr1_full;
+
+        fbr1_full.bits.fbr_full        = 0;
+        fbr1_full.bits.fbr_full_wrap   = 1;
+
+        pRxDma->fbr1_full_offset = fbr1_full;
+    }
+
+
+    /**************************************************************************
+       This variable tracks the free buffer ring 1 full position, so it has to
+       match the above.
+     *************************************************************************/
+    pAdapter->RxRing.local_Fbr1_full.bits.fbr_full      = 0;
+    pAdapter->RxRing.local_Fbr1_full.bits.fbr_full_wrap = 1;
+
+    pRxDma->fbr1_min_des.bits.fbr_min =
+      (( pAdapter->RxRing.Fbr1NumEntries * LO_MARK_PERCENT_FOR_RX ) / 100) - 1;
+
+
+#ifdef USE_FBR0
+    /**************************************************************************
+       Now's the best time to initialize FBR0 contents
+     *************************************************************************/
+    pFbrEntry = (PFBR_DESC_t) pAdapter->RxRing.pFbr0RingVa;
+
+    for (iEntry=0; iEntry < pAdapter->RxRing.Fbr0NumEntries; iEntry++)
+    {
+        pFbrEntry->addr_hi = pAdapter->RxRing.Fbr[0]->PAHigh[iEntry];
+        pFbrEntry->addr_lo = pAdapter->RxRing.Fbr[0]->PALow [iEntry];
+        pFbrEntry->word2.bits.bi = iEntry;
+        pFbrEntry++;
+    }
+
+    pRxDma->fbr0_base_hi.addr_hi = (UINT32)( pAdapter->RxRing.Fbr0Realpa >> 32 );
+    pRxDma->fbr0_base_lo.addr_lo = (UINT32)( pAdapter->RxRing.Fbr0Realpa );
+
+    pRxDma->fbr0_num_des.bits.fbr_ndesc = pAdapter->RxRing.Fbr0NumEntries - 1;
+
+    {
+        RXDMA_FBR_FULL_OFFSET_t fbr0_full;
+
+        fbr0_full.bits.fbr_full        = 0;
+        fbr0_full.bits.fbr_full_wrap   = 1;
+
+        pRxDma->fbr0_full_offset = fbr0_full;
+    }
+
+
+    /**************************************************************************
+       This variable tracks the free buffer ring 0 full position, so it has to
+       match the above.
+     *************************************************************************/
+    pAdapter->RxRing.local_Fbr0_full.bits.fbr_full      = 0;
+    pAdapter->RxRing.local_Fbr0_full.bits.fbr_full_wrap = 1;
+
+    pRxDma->fbr0_min_des.bits.fbr_min   =
+      (( pAdapter->RxRing.Fbr0NumEntries * LO_MARK_PERCENT_FOR_RX ) / 100) - 1;
+#endif
+
+
+    /**************************************************************************
+       Program the number of packets we will receive before generating an
+       interrupt.
+
+      For version B silicon, this value gets updated once autoneg is complete.
+     *************************************************************************/
+    pRxDma->num_pkt_done.value  = pAdapter->RegistryRxNumBuffers;
+
+
+    /**************************************************************************
+       The "time_done" is not working correctly to coalesce interrupts after
+       a given time period, but rather is giving us an interrupt regardless
+       of whether we have received packets.
+
+      This value gets updated once autoneg is complete.
+     *************************************************************************/
+    pRxDma->max_pkt_time.value = pAdapter->RegistryRxTimeInterval;
+
+    spin_unlock_irqrestore( &pAdapter->RcvLock, lockflags );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  SetRxDmaTimer
+ ******************************************************************************
+   DESCRIPTION:
+        SET the heartbeat timer according to line rate.
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        N/A
+
+ *****************************************************************************/
+void SetRxDmaTimer( ET131X_ADAPTER *pAdapter )
+{
+    /**************************************************************************
+       For version B silicon, we do not use the RxDMA timer for 10 and 100
+       Mbits/s line rates.  We do not enable and RxDMA interrupt coalescing.
+     *************************************************************************/
+    if(( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_100MBPS ) ||
+       ( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_10MBPS ))
+    {
+        pAdapter->CSRAddress->rxdma.max_pkt_time.value = 0;
+        pAdapter->CSRAddress->rxdma.num_pkt_done.value = 1;
+    }
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_rx_dma_disable
+ ******************************************************************************
+   DESCRIPTION:
+        Stop OF Rx_DMA on the ET1310
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+
+
+ *****************************************************************************/
+void et131x_rx_dma_disable( ET131X_ADAPTER *pAdapter )
+{
+    DBG_FUNC( "et131x_rx_dma_disable" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Setup the receive dma configuration register
+     *************************************************************************/
+    pAdapter->CSRAddress->rxdma.csr.value = 0x00002001;
+
+    if( pAdapter->CSRAddress->rxdma.csr.bits.halt_status != 1 )
+    {
+        udelay( 5 );
+        if( pAdapter->CSRAddress->rxdma.csr.bits.halt_status != 1 )
+        {
+            DBG_ERROR( et131x_dbginfo,
+                       "RX Dma failed to enter halt state. CSR 0x%08x\n",
+                       pAdapter->CSRAddress->rxdma.csr.value );
+        }
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_rx_dma_enable
+ ******************************************************************************
+   DESCRIPTION:
+        re-start OF Rx_DMA on the ET1310.
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+
+
+ *****************************************************************************/
+void et131x_rx_dma_enable( ET131X_ADAPTER *pAdapter )
+{
+    DBG_FUNC( "et131x_rx_dma_enable" );
+    DBG_RX_ENTER( et131x_dbginfo );
+
+
+    if( pAdapter->RegistryPhyLoopbk )
+    {
+        /**********************************************************************
+            RxDMA is disabled for loopback operation.
+         *********************************************************************/
+        pAdapter->CSRAddress->rxdma.csr.value = 0x1;
+    }
+    else
+    {
+        /**********************************************************************
+            Setup the receive dma configuration register for normal operation.
+         *********************************************************************/
+        {
+            RXDMA_CSR_t csr = {0};
+
+            csr.bits.fbr1_enable = 1;
+
+            if( pAdapter->RxRing.Fbr1BufferSize == 4096 )
+            {
+                csr.bits.fbr1_size = 1;
+            }
+            else if( pAdapter->RxRing.Fbr1BufferSize == 8192 )
+            {
+                csr.bits.fbr1_size = 2;
+            }
+            else if( pAdapter->RxRing.Fbr1BufferSize == 16384 )
+            {
+                csr.bits.fbr1_size = 3;
+            }
+#ifdef USE_FBR0
+            csr.bits.fbr0_enable = 1;
+
+            if( pAdapter->RxRing.Fbr0BufferSize == 256 )
+            {
+                csr.bits.fbr0_size = 1;
+            }
+            else if( pAdapter->RxRing.Fbr0BufferSize == 512 )
+            {
+                csr.bits.fbr0_size = 2;
+            }
+            else if( pAdapter->RxRing.Fbr0BufferSize == 1024 )
+            {
+                csr.bits.fbr0_size = 3;
+            }
+#endif
+            pAdapter->CSRAddress->rxdma.csr = csr;
+        }
+
+        if( pAdapter->CSRAddress->rxdma.csr.bits.halt_status != 0 )
+        {
+            udelay( 5 );
+            if( pAdapter->CSRAddress->rxdma.csr.bits.halt_status != 0 )
+            {
+                DBG_ERROR( et131x_dbginfo,
+                           "RX Dma failed to exit halt state.  CSR 0x%08x\n",
+                           pAdapter->CSRAddress->rxdma.csr.value );
+            }
+        }
+    }
+
+
+    DBG_RX_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  nic_rx_pkts
+ ******************************************************************************
+   DESCRIPTION:
+        Checks the hardware for available packets, using completion ring
+        If packets are available, it gets an RFD from the RecvList, attaches
+        the packet to it, puts the RFD in the RecvPendList, and also returns
+        the pointer to the RFD.
+
+    PARAMETERS :
+        pAdapter - pointer to our adapter
+
+   RETURNS    :
+        pMpRfd   - pointer to our MPRFD
+
+ *****************************************************************************/
+PMP_RFD nic_rx_pkts( ET131X_ADAPTER *pAdapter )
+{
+    PRX_STATUS_BLOCK_t      pRxStatusBlock;
+    PPKT_STAT_DESC_t        pPSREntry;
+    PMP_RFD                 pMpRfd;
+    UINT32                  nIndex;
+    PUCHAR                  pBufVa;
+    PUINT16                 pShBufVa;
+    unsigned long           lockflags;
+    struct list_head       *element;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "nic_rx_pkts" );
+    DBG_RX_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       RX Status block is written by the DMA engine prior to every interrupt.
+       It contains the next to be used entry in the Packet Status Ring, and
+       also the two Free Buffer rings.
+     *************************************************************************/
+    pRxStatusBlock = (PRX_STATUS_BLOCK_t)pAdapter->RxRing.pRxStatusVa;
+
+    if(( pRxStatusBlock->Word1.bits.PSRoffset !=
+                             pAdapter->RxRing.local_psr_full.bits.psr_full ) ||
+       ( pRxStatusBlock->Word1.bits.PSRwrap !=
+                          pAdapter->RxRing.local_psr_full.bits.psr_full_wrap ))
+    {
+        UINT8                   ringIndex;
+        UINT16                  bufferIndex;
+        UINT32                  localLen;
+        PKT_STAT_DESC_WORD0_t   Word0;
+
+
+        /**********************************************************************
+           The packet status ring indicates that data is available.
+         *********************************************************************/
+        pPSREntry = (PPKT_STAT_DESC_t)( pAdapter->RxRing.pPSRingVa ) +
+                                 pAdapter->RxRing.local_psr_full.bits.psr_full;
+
+
+        /**********************************************************************
+           Grab any information that is required once the PSR is advanced,
+           since we can no longer rely on the memory being accurate
+         *********************************************************************/
+        localLen    = pPSREntry->word1.bits.length;
+        ringIndex   = (UINT8)pPSREntry->word1.bits.ri;
+        bufferIndex = (UINT16)pPSREntry->word1.bits.bi;
+        Word0       = pPSREntry->word0;
+
+        DBG_RX( et131x_dbginfo, "RX PACKET STATUS\n" );
+        DBG_RX( et131x_dbginfo, "\tlength      : %d\n", localLen );
+        DBG_RX( et131x_dbginfo, "\tringIndex   : %d\n", ringIndex );
+        DBG_RX( et131x_dbginfo, "\tbufferIndex : %d\n", bufferIndex );
+        DBG_RX( et131x_dbginfo, "\tword0       : 0x%08x\n", Word0.value );
+
+
+#if 0
+        /**********************************************************************
+           Check the Status Word that the MAC has appended to the PSR entry in
+           case the MAC has detected errors.
+         *********************************************************************/
+        if( Word0.value & ALCATEL_BAD_STATUS )
+        {
+            DBG_ERROR( et131x_dbginfo,
+                       "NICRxPkts >> Alcatel Status Word error."
+                       "Value 0x%08x\n",
+                       pPSREntry->word0.value );
+        }
+#endif
+
+
+        /**********************************************************************
+           Indicate that we have used this PSR entry.
+         *********************************************************************/
+        if( ++pAdapter->RxRing.local_psr_full.bits.psr_full >
+                             ( pAdapter->RxRing.PsrNumEntries - 1 ))
+        {
+            pAdapter->RxRing.local_psr_full.bits.psr_full       = 0;
+            pAdapter->RxRing.local_psr_full.bits.psr_full_wrap ^= 1;
+        }
+
+        pAdapter->CSRAddress->rxdma.psr_full_offset =
+                                               pAdapter->RxRing.local_psr_full;
+
+#ifndef USE_FBR0
+        if( ringIndex != 1 )
+        {
+            DBG_ERROR( et131x_dbginfo,
+                       "NICRxPkts PSR Entry %d indicates "
+                       "Buffer Ring 0 in use\n",
+                       pAdapter->RxRing.local_psr_full.bits.psr_full );
+
+            DBG_RX_LEAVE( et131x_dbginfo );
+            return NULL;
+        }
+#endif
+
+#ifdef USE_FBR0
+        if(( ringIndex > 1 ) ||
+          (( ringIndex == 0 ) && ( bufferIndex > ( pAdapter->RxRing.Fbr0NumEntries - 1 ))) ||
+          (( ringIndex == 1 ) && ( bufferIndex > ( pAdapter->RxRing.Fbr1NumEntries - 1 ))))
+#else
+        if(( ringIndex != 1 ) || ( bufferIndex > ( pAdapter->RxRing.Fbr1NumEntries - 1 )))
+#endif
+        {
+            /******************************************************************
+               Illegal buffer or ring index cannot be used by the S/W
+             *****************************************************************/
+            DBG_ERROR( et131x_dbginfo,
+                       "NICRxPkts PSR Entry %d indicates "
+                       "length of %d and/or bad bi(%d)\n",
+                       pAdapter->RxRing.local_psr_full.bits.psr_full,
+                       localLen,
+                       bufferIndex );
+
+            DBG_RX_LEAVE( et131x_dbginfo );
+            return NULL;
+        }
+
+
+        /**********************************************************************
+           Get and fill the RFD.
+         *********************************************************************/
+        spin_lock_irqsave( &pAdapter->RcvLock, lockflags );
+
+        pMpRfd = NULL;
+        element = pAdapter->RxRing.RecvList.next;
+        pMpRfd  = (PMP_RFD)list_entry( element, MP_RFD, list_node );
+
+        if( pMpRfd == NULL )
+        {
+            DBG_RX( et131x_dbginfo,
+                    "NULL RFD returned from RecvList via list_entry()\n" );
+            DBG_RX_LEAVE( et131x_dbginfo );
+            return NULL;
+        }
+
+        list_del( &pMpRfd->list_node );
+        pAdapter->RxRing.nReadyRecv--;
+
+        spin_unlock_irqrestore( &pAdapter->RcvLock, lockflags );
+
+        pMpRfd->iBufferIndex = bufferIndex;
+        pMpRfd->iRingIndex   = ringIndex;
+
+
+        /**********************************************************************
+           In V1 silicon, there is a bug which screws up filtering of runt
+           packets.  Therefore runt packet filtering is disabled in the MAC
+           and the packets are dropped here.  They are also counted here.
+         *********************************************************************/
+        if( localLen < ( NIC_MIN_PACKET_SIZE + 4 ))
+        {
+            pAdapter->Stats.other_errors++;
+            localLen = 0;
+        }
+
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+        if( localLen )
+        {
+            pShBufVa = pAdapter->RxRing.Fbr[ringIndex]->Va[bufferIndex];
+
+            pMpRfd->bHasVLANTag = FALSE;
+
+
+            /******************************************************************
+                The protocol value of 0x8100 means there is a VLAN tag in the
+                packet.  Also the original protocol value will be present four
+                bytes further on.
+             *****************************************************************/
+            if( pShBufVa[6] == 0x0081 )
+            {
+                UINT16 LocalShort = (( pShBufVa[7] & 0xff00 ) >> 8 ) +
+                                    (( pShBufVa[7] & 0x00ff ) << 8 );
+                UINT16 vlan_tag   = LocalShort & 0x0fff;
+
+                pMpRfd->bHasVLANTag = TRUE;
+
+                DBG_RX( et131x_dbginfo,
+                        "VLAN: RX packet Tag: %d\n", vlan_tag );
+
+
+                /**************************************************************
+                    The rules are:
+                        - if our VLAN tag is zero we can pass anything up
+                        - if our VLAN tag matches the incoming we can pass it
+                        - If the packet is a protocol 802.3ad we pass it
+                           regardless (802.3ad had protocol val of 0x8809.
+                           proto val is now in ShBuf [8])
+                        - If the packet is a GARP VLAN Registration Protocol
+                          (GVRP) packet, we pass it regardless.
+                          01:80:c2:00:00:21 is the GVRP address.
+
+                    NOTE: Because the ET1310 doesn't perform VLAN tagging
+                          (it's done in the kernel) always pass packets up.
+                          We'll leave this code in, however, just in case it's
+                          needed in the future.
+                 *************************************************************/
+                if(( 1 ) ||
+                   (  pShBufVa[8] == 0x0988 ) ||
+                   (( pShBufVa[0] == 0x8001 ) &&
+                    ( pShBufVa[1] == 0x00c2 ) &&
+                    ( pShBufVa[2] == 0x2100 )))
+                {
+                    DBG_RX( et131x_dbginfo,
+                            "VLAN: Passed test, send pkt up\n" );
+                    pMpRfd->VLANTag = vlan_tag;
+                }
+                else
+                {
+                    /*********************************************************
+                        Our VLAN tag is non-zero, AND the incoming tag does
+                        not match it.  Drop the packet.
+                     ********************************************************/
+                    DBG_RX( et131x_dbginfo,
+                            "VLAN: no match, drop pkt\n" );
+                    localLen = 0;
+                }
+            }
+            else if((  pShBufVa[6] == 0x0988 ) ||
+                    (( pShBufVa[0] == 0x8001 ) &&
+                     ( pShBufVa[1] == 0x00c2 ) &&
+                     ( pShBufVa[2] == 0x2100 )))
+            {
+                /******************************************************************
+                    The protocol type (ethertype) of 0x8809 corresponds to 802.3ad
+                    The MAC address of 01:80:c2:00:00:21 is the GARP VLAN
+                    registration protocol (GVRP) address.
+
+                    Both of these message types should be passed up regardless
+                    of their VLAN tagging.
+                *****************************************************************/
+                DBG_RX( et131x_dbginfo,
+                        "VLAN: No tag, but 802.3ad/GVRP, send pkt up\n" );
+            }
+            else
+            {
+                /******************************************************************
+                    Our VLAN tag is non-zero.  no VLAN header on incoming.
+                    Packet is not GVRP or 802.3ad.  Drop the packet.
+                *****************************************************************/
+                DBG_RX( et131x_dbginfo,
+                        "VLAN: No RX packet tag\n" );
+                // NOTE: Same as the note above; never drop a packet for now.
+                // localLen = 0;
+            }
+        }
+#endif
+
+        if( localLen )
+        {
+            if ( pAdapter->ReplicaPhyLoopbk == 1 )
+            {
+                pBufVa = pAdapter->RxRing.Fbr[ringIndex]->Va[bufferIndex];
+
+                if( memcmp( &pBufVa[6], &pAdapter->CurrentAddress[0], ETH_ALEN ) == 0 )
+                {
+                    if( memcmp( &pBufVa[42], "Replica packet", ETH_HLEN ))
+                    {
+                        pAdapter->ReplicaPhyLoopbkPF = 1;
+                    }
+                }
+                DBG_WARNING( et131x_dbginfo,
+                             "pBufVa:\t%02x:%02x:%02x:%02x:%02x:%02x\n",
+                             pBufVa[6],
+                             pBufVa[7],
+                             pBufVa[8],
+                             pBufVa[9],
+                             pBufVa[10],
+                             pBufVa[11] );
+
+                DBG_WARNING( et131x_dbginfo,
+                             "CurrentAddr:\t%02x:%02x:%02x:%02x:%02x:%02x\n",
+                             pAdapter->CurrentAddress[0],
+                             pAdapter->CurrentAddress[1],
+                             pAdapter->CurrentAddress[2],
+                             pAdapter->CurrentAddress[3],
+                             pAdapter->CurrentAddress[4],
+                             pAdapter->CurrentAddress[5] );
+            }
+
+            /******************************************************************
+               Determine if this is a multicast packet coming in
+             *****************************************************************/
+            if(( Word0.value & ALCATEL_MULTICAST_PKT ) &&
+               !( Word0.value & ALCATEL_BROADCAST_PKT ))
+            {
+                /**************************************************************
+                   Promiscuous mode and Multicast mode are not mutually
+                   exclusive as was first thought.  I guess Promiscuous is
+                   just considered a super-set of the other filters.
+                   Generally filter is 0x2b when in promiscuous mode.
+                 *************************************************************/
+                if(( pAdapter->PacketFilter & ET131X_PACKET_TYPE_MULTICAST ) &&
+                   !( pAdapter->PacketFilter & ET131X_PACKET_TYPE_PROMISCUOUS ) &&
+                   !( pAdapter->PacketFilter & ET131X_PACKET_TYPE_ALL_MULTICAST ))
+                {
+                    pBufVa = pAdapter->RxRing.Fbr[ringIndex]->Va[bufferIndex];
+
+                    /**********************************************************
+                       Loop through our list to see if the destination address
+                       of this packet matches one in our list.
+                     *********************************************************/
+                    for( nIndex = 0; nIndex < pAdapter->MCAddressCount; nIndex++ )
+                    {
+                        if( pBufVa[0] == pAdapter->MCList[nIndex][0] &&
+                            pBufVa[1] == pAdapter->MCList[nIndex][1] &&
+                            pBufVa[2] == pAdapter->MCList[nIndex][2] &&
+                            pBufVa[3] == pAdapter->MCList[nIndex][3] &&
+                            pBufVa[4] == pAdapter->MCList[nIndex][4] &&
+                            pBufVa[5] == pAdapter->MCList[nIndex][5] )
+                        {
+                            break;
+                        }
+                    }
+
+                    /**********************************************************
+                       If our index is equal to the number of Multicast
+                       address we have, then this means we did not find this
+                       packet's matching address in our list.  Set the
+                       PacketSize to zero, so we free our RFD when we return
+                       from this function.
+                     *********************************************************/
+                    if( nIndex == pAdapter->MCAddressCount )
+                    {
+                        localLen = 0;
+                    }
+                }
+
+                if( localLen > 0 )
+                {
+                    pAdapter->Stats.multircv++;
+                }
+            }
+            else if( Word0.value & ALCATEL_BROADCAST_PKT )
+            {
+                pAdapter->Stats.brdcstrcv++;
+            }
+            else
+            {
+                /**************************************************************
+                   Not sure what this counter measures in promiscuous mode.
+                   Perhaps we should check the MAC address to see if it is
+                   directed to us in promiscuous mode.
+                 *************************************************************/
+                pAdapter->Stats.unircv++;
+            }
+        }
+
+        if( localLen > 0 )
+        {
+            struct sk_buff *skb = NULL;
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+            unsigned short  vlan_tag = 0;
+#endif
+
+            //vlan_tag = 0;
+
+            //pMpRfd->PacketSize = localLen - 4;
+            pMpRfd->PacketSize = localLen;
+
+            skb = dev_alloc_skb( pMpRfd->PacketSize + 2 );
+            if( !skb )
+            {
+                DBG_ERROR( et131x_dbginfo, "Couldn't alloc an SKB for Rx\n" );
+                DBG_RX_LEAVE( et131x_dbginfo );
+                return NULL;
+            }
+
+            pAdapter->net_stats.rx_bytes += pMpRfd->PacketSize;
+
+            memcpy( skb_put( skb, pMpRfd->PacketSize ),
+                    pAdapter->RxRing.Fbr[ringIndex]->Va[bufferIndex],
+                    pMpRfd->PacketSize );
+
+            skb->dev       = pAdapter->netdev;
+            skb->protocol  = eth_type_trans( skb, pAdapter->netdev );
+            skb->ip_summed = CHECKSUM_NONE;
+
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#if defined __vlan_get_tag
+            if( __vlan_get_tag( skb, &vlan_tag ) == -EINVAL )
+            {
+                DBG_RX( et131x_dbginfo,
+                        "VLAN: No Rx packet tag\n" );
+            }
+            else
+            {
+                DBG_RX( et131x_dbginfo,
+                        "VLAN: Rx packet tag: %d\n", vlan_tag );
+            }
+#endif
+#endif
+
+            netif_rx( skb );
+        }
+        else
+        {
+            pMpRfd->PacketSize   = 0;
+        }
+
+        nic_return_rfd( pAdapter, pMpRfd );
+
+
+        DBG_RX( et131x_dbginfo, "(1)\n" );
+        DBG_RX_LEAVE( et131x_dbginfo );
+        return pMpRfd;
+    }
+    else
+    {
+        /**********************************************************************
+           Looks like this ring is not updated yet
+         *********************************************************************/
+        DBG_RX( et131x_dbginfo, "(0)\n" );
+        DBG_RX_LEAVE( et131x_dbginfo );
+        return NULL;
+    }
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_reset_recv
+ ******************************************************************************
+   DESCRIPTION:
+        Reset the receive list
+
+        Assumption: Rcv spinlock has been acquired
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void et131x_reset_recv( ET131X_ADAPTER *pAdapter )
+{
+    PMP_RFD           pMpRfd;
+    struct list_head *element;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_reset_recv" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    DBG_ASSERT( !list_empty( &pAdapter->RxRing.RecvList ));
+
+
+    /**************************************************************************
+       Take all the RFD's from the pending list, and stick them on the
+       RecvList.
+     *************************************************************************/
+    while( !list_empty( &pAdapter->RxRing.RecvPendingList ) )
+    {
+        element = pAdapter->RxRing.RecvPendingList.next;
+
+        pMpRfd = (PMP_RFD)list_entry( element, MP_RFD, list_node );
+
+        list_del( &pMpRfd->list_node );
+        list_add_tail( &pMpRfd->list_node, &pAdapter->RxRing.RecvList );
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_handle_recv_interrupt
+ ******************************************************************************
+   DESCRIPTION:
+        Interrupt handler for receive processing
+
+        Assumption: Rcv spinlock has been acquired
+
+   PARAMETERS :
+        pAdapter  - pointer to our adapter
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void et131x_handle_recv_interrupt( ET131X_ADAPTER *pAdapter )
+{
+    PMP_RFD         pMpRfd = NULL;
+    struct sk_buff *PacketArray [NUM_PACKETS_HANDLED];
+    PMP_RFD         RFDFreeArray[NUM_PACKETS_HANDLED];
+    UINT32          PacketArrayCount = 0;
+    UINT32          PacketsToHandle;
+    UINT32          PacketFreeCount  = 0;
+    BOOL_t          TempUnfinishedRec = FALSE;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_handle_recv_interrupt" );
+    DBG_RX_ENTER( et131x_dbginfo );
+
+
+    PacketsToHandle = NUM_PACKETS_HANDLED;
+
+
+    /**************************************************************************
+       Process up to available RFD's
+     *************************************************************************/
+    while( PacketArrayCount < PacketsToHandle )
+    {
+        if( list_empty( &pAdapter->RxRing.RecvList ))
+        {
+            DBG_ASSERT( pAdapter->RxRing.nReadyRecv == 0 );
+            DBG_ERROR( et131x_dbginfo, "NO RFD's !!!!!!!!!!!!!\n" );
+            TempUnfinishedRec = TRUE;
+            break;
+        }
+
+        pMpRfd = nic_rx_pkts( pAdapter );
+
+        if( pMpRfd == NULL)
+        {
+            break;
+        }
+
+
+        /**********************************************************************
+           Do not receive any packets until a filter has been set.
+           Do not receive any packets until we are at D0.
+           Do not receive any packets until we have link.
+           If length is zero, return the RFD in order to advance the Free
+           buffer ring.
+         *********************************************************************/
+        if(( !pAdapter->PacketFilter ) ||
+           ( pAdapter->PoMgmt.PowerState != NdisDeviceStateD0 ) ||
+           ( !MP_LINK_DETECTED( pAdapter )) ||
+           ( pMpRfd->PacketSize == 0 ))
+        {
+            continue;
+        }
+
+
+        /**********************************************************************
+           Increment the number of packets we received
+         *********************************************************************/
+        pAdapter->Stats.ipackets++;
+
+
+        /**********************************************************************
+           Set the status on the packet, either resources or success
+         *********************************************************************/
+        if( pAdapter->RxRing.nReadyRecv >= RFD_LOW_WATER_MARK )
+        {
+            /******************************************************************
+                Put this RFD on the pending list
+
+                NOTE - nic_rx_pkts() above is already returning the RFD to the
+                RecvList, so don't additionally do that here.
+
+                Besides, we don't really need (at this point) the pending list
+                anyway.
+             *****************************************************************/
+            //spin_lock_irqsave( &pAdapter->RcvPendLock, lockflags );
+            //list_add_tail( &pMpRfd->list_node, &pAdapter->RxRing.RecvPendingList );
+            //spin_unlock_irqrestore( &pAdapter->RcvPendLock, lockflags );
+
+
+            /******************************************************************
+                Update the number of outstanding Recvs
+             *****************************************************************/
+            //MP_INC_RCV_REF( pAdapter );
+        }
+        else
+        {
+            RFDFreeArray[PacketFreeCount] = pMpRfd;
+            PacketFreeCount++;
+
+            DBG_WARNING( et131x_dbginfo, "RFD's are running out !!!!!!!!!!!!!\n" );
+        }
+
+        PacketArray[PacketArrayCount] = pMpRfd->Packet;
+        PacketArrayCount++;
+    }
+
+
+    if(( PacketArrayCount == NUM_PACKETS_HANDLED ) || TempUnfinishedRec )
+    {
+        pAdapter->RxRing.UnfinishedReceives = TRUE;
+        pAdapter->CSRAddress->global.watchdog_timer =
+                            pAdapter->RegistryTxTimeInterval * NANO_IN_A_MICRO;
+    }
+    else
+    {
+        /**********************************************************************
+           Watchdog timer will disable itself if appropriate.
+         *********************************************************************/
+        pAdapter->RxRing.UnfinishedReceives = FALSE;
+    }
+
+
+    DBG_RX_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  NICReturnRFD
+ ******************************************************************************
+   DESCRIPTION:
+        Recycle a RFD and put it back onto the receive list
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter
+        pMpRfd   - pointer to the RFD
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void nic_return_rfd( ET131X_ADAPTER *pAdapter, PMP_RFD pMpRfd )
+{
+    UINT16        ReturnedBI = pMpRfd->iBufferIndex;
+    UINT8         ReturnedRI = pMpRfd->iRingIndex;
+    unsigned long lockflags;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "nic_return_rfd" );
+    DBG_RX_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       We don't use any of the OOB data besides status
+       Otherwise, we need to clean up OOB data
+     *************************************************************************/
+        if(
+#ifdef USE_FBR0
+            (( ReturnedRI == 0 ) && ( ReturnedBI < pAdapter->RxRing.Fbr0NumEntries )) ||
+#endif
+            (( ReturnedRI == 1 ) && ( ReturnedBI < pAdapter->RxRing.Fbr1NumEntries )))
+    {
+        spin_lock_irqsave( &pAdapter->FbrLock, lockflags );
+
+        if( ReturnedRI == 1 )
+        {
+            PFBR_DESC_t pNextDesc = (PFBR_DESC_t)(pAdapter->RxRing.pFbr1RingVa) +
+                                    pAdapter->RxRing.local_Fbr1_full.bits.fbr_full;
+
+            /******************************************************************
+                Handle the Free Buffer Ring advancement here.  Write the
+                PA / Buffer Index for the returned buffer into the oldest
+                (next to be freed)FBR entry
+             *****************************************************************/
+            pNextDesc->addr_hi = pAdapter->RxRing.Fbr[1]->PAHigh[ReturnedBI];
+            pNextDesc->addr_lo = pAdapter->RxRing.Fbr[1]->PALow[ReturnedBI];
+            pNextDesc->word2.value = ReturnedBI;
+
+            if( ++pAdapter->RxRing.local_Fbr1_full.bits.fbr_full >
+                                       ( pAdapter->RxRing.Fbr1NumEntries - 1 ))
+            {
+                pAdapter->RxRing.local_Fbr1_full.bits.fbr_full = 0;
+                pAdapter->RxRing.local_Fbr1_full.bits.fbr_full_wrap ^= 1;
+            }
+
+            pAdapter->CSRAddress->rxdma.fbr1_full_offset =
+                                                pAdapter->RxRing.local_Fbr1_full;
+        }
+#ifdef USE_FBR0
+        else
+        {
+            PFBR_DESC_t pNextDesc = (PFBR_DESC_t)(pAdapter->RxRing.pFbr0RingVa) +
+                                    pAdapter->RxRing.local_Fbr0_full.bits.fbr_full;
+
+            /******************************************************************
+                Handle the Free Buffer Ring advancement here.  Write the
+                PA / Buffer Index for the returned buffer into the oldest
+                (next to be freed) FBR entry
+             *****************************************************************/
+            pNextDesc->addr_hi = pAdapter->RxRing.Fbr[0]->PAHigh[ReturnedBI];
+            pNextDesc->addr_lo = pAdapter->RxRing.Fbr[0]->PALow[ReturnedBI];
+            pNextDesc->word2.value = ReturnedBI;
+
+            if( ++pAdapter->RxRing.local_Fbr0_full.bits.fbr_full >
+                                         (pAdapter->RxRing.Fbr0NumEntries - 1))
+            {
+                pAdapter->RxRing.local_Fbr0_full.bits.fbr_full = 0;
+                pAdapter->RxRing.local_Fbr0_full.bits.fbr_full_wrap ^= 1;
+            }
+
+            pAdapter->CSRAddress->rxdma.fbr0_full_offset =
+                                                pAdapter->RxRing.local_Fbr0_full;
+        }
+#endif
+        spin_unlock_irqrestore( &pAdapter->FbrLock, lockflags );
+    }
+    else
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "NICReturnRFD illegal Buffer Index returned\n" );
+    }
+
+
+    /**************************************************************************
+        The processing on this RFD is done, so put it back on the tail of
+        our list
+     *************************************************************************/
+    spin_lock_irqsave( &pAdapter->RcvLock, lockflags );
+
+    list_add_tail( &pMpRfd->list_node, &pAdapter->RxRing.RecvList );
+    pAdapter->RxRing.nReadyRecv++;
+
+    spin_unlock_irqrestore( &pAdapter->RcvLock, lockflags );
+
+    DBG_ASSERT( pAdapter->RxRing.nReadyRecv <= pAdapter->RxRing.NumRfd );
+
+
+    DBG_RX_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
--- /dev/null
+++ b/drivers/net/et131x/ET1310_rx.h
@@ -0,0 +1,488 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_rx.h - Defines, structs, enums, prototypes, etc. pertaining to data
+ *               reception.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/10/28 18:43:45 $
+     $Revision: 1.10 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET1310_RX_H__
+#define __ET1310_RX_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+
+/******************************************************************************
+   INCLUDES
+ *****************************************************************************/
+#include "ET1310_common.h"
+
+#define USE_FBR0 TRUE
+
+#ifdef USE_FBR0
+//#define FBR0_BUFFER_SIZE 256
+#endif
+
+//#define FBR1_BUFFER_SIZE 2048
+
+#define FBR_CHUNKS 32
+
+#define MAX_DESC_PER_RING_RX         1024
+
+
+
+
+/******************************************************************************
+   number of RFDs - default and min
+ *****************************************************************************/
+#ifdef USE_FBR0
+    #define RFD_LOW_WATER_MARK              40
+    #define NIC_MIN_NUM_RFD                 64
+    #define NIC_DEFAULT_NUM_RFD             1024
+#else
+    #define RFD_LOW_WATER_MARK              20
+    #define NIC_MIN_NUM_RFD                 64
+    #define NIC_DEFAULT_NUM_RFD             256
+#endif
+
+#define NUM_PACKETS_HANDLED 256
+
+#define ALCATEL_BAD_STATUS       0xe47f0000
+#define ALCATEL_MULTICAST_PKT    0x01000000
+#define ALCATEL_BROADCAST_PKT    0x02000000
+
+
+
+
+/******************************************************************************
+   typedefs for Free Buffer Descriptors
+ *****************************************************************************/
+typedef union _FBR_WORD2_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 reserved:22;                         //bits 10-31
+        UINT32 bi:10;                               //bits 0-9(Buffer Index)
+    #else
+        UINT32 bi:10;                               //bits 0-9(Buffer Index)
+        UINT32 reserved:22;                         //bit 10-31
+    #endif
+    } bits;
+}
+FBR_WORD2_t, *PFBR_WORD2_t;
+
+typedef struct _FBR_DESC_t
+{
+    UINT32         addr_lo;
+    UINT32         addr_hi;
+    FBR_WORD2_t    word2;
+}
+FBR_DESC_t, *PFBR_DESC_t;
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   Typedefs for Packet Status Ring Descriptors
+ *****************************************************************************/
+typedef union _PKT_STAT_DESC_WORD0_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        // top 16 bits are from the Alcatel Status Word as enumerated in
+        // PE-MCXMAC Data Sheet IPD DS54 0210-1 (also IPD-DS80 0205-2)
+#if 0
+        UINT32 asw_trunc:1;                         //bit 31(Rx frame truncated)
+#endif
+        UINT32 asw_long_evt:1;                      //bit 31(Rx long event)
+        UINT32 asw_VLAN_tag:1;                      //bit 30(VLAN tag detected)
+        UINT32 asw_unsupported_op:1;                //bit 29(unsupported OP code)
+        UINT32 asw_pause_frame:1;                   //bit 28(is a pause frame)
+        UINT32 asw_control_frame:1;                 //bit 27(is a control frame)
+        UINT32 asw_dribble_nibble:1;                //bit 26(spurious bits after EOP)
+        UINT32 asw_broadcast:1;                     //bit 25(has a broadcast address)
+        UINT32 asw_multicast:1;                     //bit 24(has a multicast address)
+        UINT32 asw_OK:1;                            //bit 23(valid CRC + no code error)
+        UINT32 asw_too_long:1;                      //bit 22(frame length > 1518 bytes)
+        UINT32 asw_len_chk_err:1;                   //bit 21(frame length field incorrect)
+        UINT32 asw_CRC_err:1;                       //bit 20(CRC error)
+        UINT32 asw_code_err:1;                      //bit 19(one or more nibbles signalled as errors)
+        UINT32 asw_false_carrier_event:1;           //bit 18(bad carrier since last good packet)
+        UINT32 asw_RX_DV_event:1;                   //bit 17(short receive event detected)
+        UINT32 asw_prev_pkt_dropped:1;              //bit 16(e.g. IFG too small on previous)
+        UINT32 unused:5;                            //bits 11-15
+        UINT32 vp:1;                                //bit 10(VLAN Packet)
+        UINT32 jp:1;                                //bit 9(Jumbo Packet)
+        UINT32 ft:1;                                //bit 8(Frame Truncated)
+        UINT32 drop:1;                              //bit 7(Drop packet)
+        UINT32 rxmac_error:1;                       //bit 6(RXMAC Error Indicator)
+        UINT32 wol:1;                               //bit 5(WOL Event)
+        UINT32 tcpp:1;                              //bit 4(TCP checksum pass)
+        UINT32 tcpa:1;                              //bit 3(TCP checksum assist)
+        UINT32 ipp:1;                               //bit 2(IP checksum pass)
+        UINT32 ipa:1;                               //bit 1(IP checksum assist)
+        UINT32 hp:1;                                //bit 0(hash pass)
+    #else
+        UINT32 hp:1;                                //bit 0(hash pass)
+        UINT32 ipa:1;                               //bit 1(IP checksum assist)
+        UINT32 ipp:1;                               //bit 2(IP checksum pass)
+        UINT32 tcpa:1;                              //bit 3(TCP checksum assist)
+        UINT32 tcpp:1;                              //bit 4(TCP checksum pass)
+        UINT32 wol:1;                               //bit 5(WOL Event)
+        UINT32 rxmac_error:1;                       //bit 6(RXMAC Error Indicator)
+        UINT32 drop:1;                              //bit 7(Drop packet)
+        UINT32 ft:1;                                //bit 8(Frame Truncated)
+        UINT32 jp:1;                                //bit 9(Jumbo Packet)
+        UINT32 vp:1;                                //bit 10(VLAN Packet)
+        UINT32 unused:5;                            //bits 11-15
+        UINT32 asw_prev_pkt_dropped:1;              //bit 16(e.g. IFG too small on previous)
+        UINT32 asw_RX_DV_event:1;                   //bit 17(short receive event detected)
+        UINT32 asw_false_carrier_event:1;           //bit 18(bad carrier since last good packet)
+        UINT32 asw_code_err:1;                      //bit 19(one or more nibbles signalled as errors)
+        UINT32 asw_CRC_err:1;                       //bit 20(CRC error)
+        UINT32 asw_len_chk_err:1;                   //bit 21(frame length field incorrect)
+        UINT32 asw_too_long:1;                      //bit 22(frame length > 1518 bytes)
+        UINT32 asw_OK:1;                            //bit 23(valid CRC + no code error)
+        UINT32 asw_multicast:1;                     //bit 24(has a multicast address)
+        UINT32 asw_broadcast:1;                     //bit 25(has a broadcast address)
+        UINT32 asw_dribble_nibble:1;                //bit 26(spurious bits after EOP)
+        UINT32 asw_control_frame:1;                 //bit 27(is a control frame)
+        UINT32 asw_pause_frame:1;                   //bit 28(is a pause frame)
+        UINT32 asw_unsupported_op:1;                //bit 29(unsupported OP code)
+        UINT32 asw_VLAN_tag:1;                      //bit 30(VLAN tag detected)
+        UINT32 asw_long_evt:1;                      //bit 31(Rx long event)
+#if 0
+        UINT32 asw_trunc:1;                         //bit 31(Rx frame truncated)
+#endif
+    #endif
+    } bits;
+}
+PKT_STAT_DESC_WORD0_t, *PPKT_STAT_WORD0_t;
+
+typedef union _PKT_STAT_DESC_WORD1_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:4;                            //bits 28-31
+        UINT32 ri:2;                                //bits 26-27(Ring Index)
+        UINT32 bi:10;                               //bits 16-25(Buffer Index)
+        UINT32 length:16;                           //bit 0-15(length in bytes)
+    #else
+        UINT32 length:16;                           //bit 0-15(length in bytes)
+        UINT32 bi:10;                               //bits 16-25(Buffer Index)
+        UINT32 ri:2;                                //bits 26-27(Ring Index)
+        UINT32 unused:4;                            //bits 28-31
+    #endif
+    } bits;
+}
+PKT_STAT_DESC_WORD1_t, *PPKT_STAT_WORD1_t;
+
+typedef struct _PKT_STAT_DESC_t
+{
+    PKT_STAT_DESC_WORD0_t   word0;
+    PKT_STAT_DESC_WORD1_t   word1;
+}
+PKT_STAT_DESC_t, *PPKT_STAT_DESC_t;
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   Typedefs for the RX DMA status word
+ *****************************************************************************/
+/******************************************************************************
+   RXSTAT_WORD0_t structure holds part of the status bits of the Rx DMA engine
+   that get copied out to memory by the ET-1310.  Word 0 is a 32 bit word which
+   contains Free Buffer ring 0 and 1 available offset.
+ *****************************************************************************/
+typedef union _rxstat_word0_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 FBR1unused:5;                        //bits 27-31
+        UINT32 FBR1wrap:1;                          //bit 26
+        UINT32 FBR1offset:10;                       //bits 16-25
+        UINT32 FBR0unused:5;                        //bits 11-15
+        UINT32 FBR0wrap:1;                          //bit 10
+        UINT32 FBR0offset:10;                       //bits 0-9
+    #else
+        UINT32 FBR0offset:10;                       //bits 0-9
+        UINT32 FBR0wrap:1;                          //bit 10
+        UINT32 FBR0unused:5;                        //bits 11-15
+        UINT32 FBR1offset:10;                       //bits 16-25
+        UINT32 FBR1wrap:1;                          //bit 26
+        UINT32 FBR1unused:5;                        //bits 27-31
+    #endif
+    } bits;
+}RXSTAT_WORD0_t, *PRXSTAT_WORD0_t;
+
+
+
+
+/******************************************************************************
+   RXSTAT_WORD1_t structure holds part of the status bits of the Rx DMA engine
+   that get copied out to memory by the ET-1310.  Word 3 is a 32 bit word which
+   contains the Packet Status Ring available offset.
+ *****************************************************************************/
+typedef union _rxstat_word1_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 PSRunused:3;                            //bits 29-31
+        UINT32 PSRwrap:1;                              //bit 28
+        UINT32 PSRoffset:12;                           //bits 16-27
+        UINT32 reserved:16;                            //bits 0-15
+    #else
+        UINT32 reserved:16;                            //bits 0-15
+        UINT32 PSRoffset:12;                           //bits 16-27
+        UINT32 PSRwrap:1;                              //bit 28
+        UINT32 PSRunused:3;                            //bits 29-31
+    #endif
+    } bits;
+}RXSTAT_WORD1_t, *PRXSTAT_WORD1_t;
+
+
+
+
+/******************************************************************************
+   RX_STATUS_BLOCK_t is sructure representing the status of the Rx DMA engine
+   it sits in free memory, and is pointed to by 0x101c / 0x1020
+ *****************************************************************************/
+
+typedef struct _rx_status_block_t
+{
+    RXSTAT_WORD0_t    Word0;
+    RXSTAT_WORD1_t    Word1;
+}
+RX_STATUS_BLOCK_t, *PRX_STATUS_BLOCK_t;
+
+
+
+
+/******************************************************************************
+   Structure for look-up table holding free buffer ring pointers
+ *****************************************************************************/
+typedef struct _FbrLookupTable
+{
+    void                 *Va            [MAX_DESC_PER_RING_RX];
+    void                 *Buffer1       [MAX_DESC_PER_RING_RX];
+    void                 *Buffer2       [MAX_DESC_PER_RING_RX];
+    UINT32                PAHigh        [MAX_DESC_PER_RING_RX];
+    UINT32                PALow         [MAX_DESC_PER_RING_RX];
+} FBRLOOKUPTABLE, *PFBRLOOKUPTABLE;
+
+typedef enum {
+    ONE_PACKET_INTERRUPT,
+    FOUR_PACKET_INTERRUPT
+}
+eRX_INTERRUPT_STATE_t, *PeRX_INTERRUPT_STATE_t;
+
+
+
+
+/******************************************************************************
+   Structure to hold the skb's in a list
+ *****************************************************************************/
+typedef struct rx_skb_list_elem
+{
+	struct list_head  skb_list_elem;
+	dma_addr_t        dma_addr;
+	struct sk_buff   *skb;
+} RX_SKB_LIST_ELEM, *PRX_SKB_LIST_ELEM;
+
+
+
+
+/******************************************************************************
+   RX_RING_t is sructure representing the adaptor's local reference(s) to the
+   rings
+ *****************************************************************************/
+typedef struct _rx_ring_t
+{
+#ifdef USE_FBR0
+    void                       *pFbr0RingVa;
+    dma_addr_t                  pFbr0RingPa;
+    void                       *Fbr0MemVa[ MAX_DESC_PER_RING_RX / FBR_CHUNKS ];
+    dma_addr_t                  Fbr0MemPa[ MAX_DESC_PER_RING_RX / FBR_CHUNKS ];
+    UINT64                      Fbr0Realpa;
+    UINT64                      Fbr0offset;
+    RXDMA_FBR_FULL_OFFSET_t     local_Fbr0_full;
+    UINT32                      Fbr0NumEntries;
+    UINT32                      Fbr0BufferSize;
+#endif
+    void                       *pFbr1RingVa;
+    dma_addr_t                  pFbr1RingPa;
+    void                       *Fbr1MemVa[ MAX_DESC_PER_RING_RX / FBR_CHUNKS ];
+    dma_addr_t                  Fbr1MemPa[ MAX_DESC_PER_RING_RX / FBR_CHUNKS ];
+    UINT64                      Fbr1Realpa;
+    UINT64                      Fbr1offset;
+    FBRLOOKUPTABLE             *Fbr[2];
+    RXDMA_FBR_FULL_OFFSET_t     local_Fbr1_full;
+    UINT32                      Fbr1NumEntries;
+    UINT32                      Fbr1BufferSize;
+
+    void                       *pPSRingVa;
+    dma_addr_t                  pPSRingPa;
+    UINT64                      pPSRingRealPa;
+    UINT64                      pPSRingOffset;
+    RXDMA_PSR_FULL_OFFSET_t     local_psr_full;
+    UINT32                      PsrNumEntries;
+
+    void                       *pRxStatusVa;
+    dma_addr_t                  pRxStatusPa;
+    UINT64                      RxStatusRealPA;
+    UINT64                      RxStatusOffset;
+
+    struct list_head            RecvBufferPool;
+
+
+    /**************************************************************************
+       RECV
+     *************************************************************************/
+    struct list_head            RecvList;
+    struct list_head            RecvPendingList;
+    UINT32                      nReadyRecv;
+
+    UINT32                      NumRfd;
+
+    BOOL_t                      UnfinishedReceives;
+
+    struct list_head            RecvPacketPool;
+
+
+    /**************************************************************************
+       lookaside lists
+     *************************************************************************/
+    struct kmem_cache        *RecvLookaside;
+}
+RX_RING_t, *PRX_RING_t;
+
+
+
+
+/******************************************************************************
+   Forward reference of RFD
+ *****************************************************************************/
+struct _MP_RFD;
+
+
+
+
+/******************************************************************************
+   Forward declaration of the private adapter structure
+ *****************************************************************************/
+struct et131x_adapter;
+
+
+
+
+/******************************************************************************
+   PROTOTYPES for Initialization
+ *****************************************************************************/
+int et131x_rx_dma_memory_alloc( struct et131x_adapter *adapter );
+void et131x_rx_dma_memory_free( struct et131x_adapter *adapter );
+int et131x_rfd_resources_alloc( struct et131x_adapter *adapter, struct _MP_RFD *pMpRfd );
+void et131x_rfd_resources_free( struct et131x_adapter *adapter, struct _MP_RFD *pMpRfd );
+int et131x_init_recv( struct et131x_adapter *adapter );
+
+void ConfigRxDmaRegs( struct et131x_adapter *pAdapter );
+void SetRxDmaTimer( struct et131x_adapter *pAdapter );
+void et131x_rx_dma_disable( struct et131x_adapter *pAdapter );
+void et131x_rx_dma_enable( struct et131x_adapter *pAdapter );
+
+void et131x_reset_recv( struct et131x_adapter *pAdapter );
+
+void et131x_handle_recv_interrupt( struct et131x_adapter *pAdapter );
+
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __ET1310_RX_H__ */
--- /dev/null
+++ b/drivers/net/et131x/ET1310_tx.c
@@ -0,0 +1,2084 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_tx.c - Routines used to perform data transmission.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2006/01/20 21:29:44 $
+     $Revision: 1.24 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#include <linux/if_vlan.h>
+#endif
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_initpci.h"
+#include "et131x_isr.h"
+
+#include "ET1310_tx.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   Prototypes for functions local to this module
+ *****************************************************************************/
+void et131x_update_tcb_list( ET131X_ADAPTER *pAdapter );
+void et131x_check_send_wait_list( ET131X_ADAPTER *pAdapter );
+__inline void et131x_free_send_packet( ET131X_ADAPTER *pAdapter, PMP_TCB pMpTcb );
+
+int et131x_send_packet( struct sk_buff *skb, ET131X_ADAPTER *pAdapter );
+int nic_send_packet( ET131X_ADAPTER *pAdapter, PMP_TCB pMpTcb );
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_tx_dma_memory_alloc
+ ******************************************************************************
+
+   DESCRIPTION       : Allocates memory that will be visible both to the device
+                       and to the CPU. The OS will pass us packets, pointers to
+                       which we will insert in the Tx Descriptor queue. The
+                       device will read this queue to find the packets in
+                       memory. The device will update the "status" in memory
+                       each time it xmits a packet.
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_tx_dma_memory_alloc( ET131X_ADAPTER *adapter )
+{
+    int             desc_size = 0;
+    TX_RING_t      *tx_ring;
+    MP_TCB         *tcb;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_tx_dma_memory_alloc" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Allocate memory for the TCB's (Transmit Control Block)
+     *************************************************************************/
+    adapter->TxRing.MpTcbMem = kmalloc( NUM_TCB * sizeof( MP_TCB ),
+                                        GFP_ATOMIC | GFP_DMA );
+    if( !adapter->TxRing.MpTcbMem )
+    {
+        DBG_ERROR( et131x_dbginfo, "Cannot alloc memory for TCBs\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+    memset( adapter->TxRing.MpTcbMem, 0, ( NUM_TCB * sizeof( MP_TCB )));
+
+
+    /**************************************************************************
+       Setup some convenience pointers
+     *************************************************************************/
+    tx_ring = (TX_RING_t *)&adapter->TxRing;
+    tcb     = (MP_TCB *)adapter->TxRing.MpTcbMem;
+
+
+    /**************************************************************************
+       Allocate enough memory for the Tx descriptor ring, and allocate some
+       extra so that the ring can be aligned on a 4k boundary.
+     *************************************************************************/
+    desc_size = ( sizeof( TX_DESC_ENTRY_t ) * NUM_DESC_PER_RING_TX ) + 4096 - 1;
+    tx_ring->pTxDescRingVa = (PTX_DESC_ENTRY_t)pci_alloc_consistent( adapter->pdev,
+                                                   desc_size,
+                                                   &tx_ring->pTxDescRingPa );
+    if( !adapter->TxRing.pTxDescRingVa )
+    {
+        DBG_ERROR( et131x_dbginfo, "Cannot alloc memory for Tx Ring\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+
+    /**************************************************************************
+       Save physical address
+
+       NOTE : pci_alloc_consistent(), used above to alloc DMA regions, ALWAYS
+              returns SAC (32-bit) addresses. If DAC (64-bit) addresses are
+              ever returned, make sure the high part is retrieved here before
+              storing the adjusted address.
+     *************************************************************************/
+    tx_ring->pTxDescRingAdjustedPa = tx_ring->pTxDescRingPa;
+
+
+    /**************************************************************************
+       Align Tx Descriptor Ring on a 4k (0x1000) byte boundary
+     *************************************************************************/
+    et131x_align_allocated_memory( adapter,
+                                   &tx_ring->pTxDescRingAdjustedPa,
+                                   &tx_ring->TxDescOffset,
+                                   0x0FFF );
+
+    tx_ring->pTxDescRingVa += tx_ring->TxDescOffset;
+
+
+    /**************************************************************************
+       Allocate memory for the Tx status block
+     *************************************************************************/
+    tx_ring->pTxStatusVa = pci_alloc_consistent( adapter->pdev,
+                                                 sizeof( TX_STATUS_BLOCK_t ),
+                                                 &tx_ring->pTxStatusPa );
+    if( !adapter->TxRing.pTxStatusPa )
+    {
+        DBG_ERROR( et131x_dbginfo, "Cannot alloc memory for Tx status block\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+
+    /**************************************************************************
+       Allocate memory for a dummy buffer
+     *************************************************************************/
+    tx_ring->pTxDummyBlkVa = pci_alloc_consistent( adapter->pdev,
+                                                   NIC_MIN_PACKET_SIZE,
+                                                   &tx_ring->pTxDummyBlkPa );
+    if( !adapter->TxRing.pTxDummyBlkPa )
+    {
+        DBG_ERROR( et131x_dbginfo, "Cannot alloc memory for Tx dummy buffer\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_tx_dma_memory_free
+ ******************************************************************************
+
+   DESCRIPTION       : Free all memory allocated within this module
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_tx_dma_memory_free( ET131X_ADAPTER *adapter )
+{
+    int             desc_size = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_tx_dma_memory_free" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    if( adapter->TxRing.pTxDescRingVa )
+    {
+        /**********************************************************************
+           Free memory relating to Tx rings here
+         *********************************************************************/
+        adapter->TxRing.pTxDescRingVa -= adapter->TxRing.TxDescOffset;
+
+        desc_size = ( sizeof( TX_DESC_ENTRY_t ) * NUM_DESC_PER_RING_TX ) + 4096 - 1;
+
+        pci_free_consistent( adapter->pdev,
+                             desc_size,
+                             adapter->TxRing.pTxDescRingVa,
+                             adapter->TxRing.pTxDescRingPa );
+
+ 		adapter->TxRing.pTxDescRingVa = NULL ;
+    }
+
+
+    /**************************************************************************
+       Free memory for the Tx status block
+     *************************************************************************/
+    if( adapter->TxRing.pTxStatusVa )
+    {
+        pci_free_consistent( adapter->pdev,
+                             sizeof( TX_STATUS_BLOCK_t ),
+                             adapter->TxRing.pTxStatusVa,
+                             adapter->TxRing.pTxStatusPa );
+
+ 		adapter->TxRing.pTxStatusVa = NULL ;
+    }
+
+
+    /**************************************************************************
+       Free memory for the dummy buffer
+     *************************************************************************/
+    if( adapter->TxRing.pTxDummyBlkVa )
+    {
+        pci_free_consistent( adapter->pdev,
+                             NIC_MIN_PACKET_SIZE,
+                             adapter->TxRing.pTxDummyBlkVa,
+                             adapter->TxRing.pTxDummyBlkPa );
+
+ 		adapter->TxRing.pTxDummyBlkVa = NULL ;
+    }
+
+
+    /**************************************************************************
+       Free the memory for MP_TCB structures
+     *************************************************************************/
+    if( adapter->TxRing.MpTcbMem )
+    {
+        kfree( adapter->TxRing.MpTcbMem );
+        adapter->TxRing.MpTcbMem = NULL;
+    }
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  ConfigTxDmaRegs
+ ******************************************************************************
+
+   DESCRIPTION       : Used to set up the tx dma section of the JAGCore.
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void ConfigTxDmaRegs( ET131X_ADAPTER *pAdapter )
+{
+    PTXDMA_t pTxDma;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "ConfigTxDmaRegs" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       First lets get a copy of the pointer
+     *************************************************************************/
+    pTxDma = &pAdapter->CSRAddress->txdma;
+
+
+    /**************************************************************************
+	   Load the hardware with the start of the transmit descriptor ring.
+	 *************************************************************************/
+    pTxDma->pr_base_hi.addr_hi =
+                 (UINT32)( pAdapter->TxRing.pTxDescRingAdjustedPa >> 32 );
+    pTxDma->pr_base_lo.addr_lo =
+                 (UINT32)( pAdapter->TxRing.pTxDescRingAdjustedPa );
+
+
+    /**************************************************************************
+       Initialise the transmit DMA engine
+     *************************************************************************/
+    pTxDma->pr_num_des.value   = NUM_DESC_PER_RING_TX - 1;
+
+
+    /**************************************************************************
+       Load the completion writeback physical address
+
+       NOTE : pci_alloc_consistent(), used above to alloc DMA regions, ALWAYS
+              returns SAC (32-bit) addresses. If DAC (64-bit) addresses are
+              ever returned, make sure the high part is retrieved here before
+              storing the adjusted address.
+     *************************************************************************/
+    pTxDma->dma_wb_base_hi.addr_hi = 0x0;
+    pTxDma->dma_wb_base_lo.addr_lo = pAdapter->TxRing.pTxStatusPa;
+
+    memset( pAdapter->TxRing.pTxStatusVa, 0, sizeof( TX_STATUS_BLOCK_t ));
+
+
+    pTxDma->service_request.value           = 0x0;
+    pAdapter->TxRing.txDmaReadyToSend.value = 0x0;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_tx_dma_disable
+ ******************************************************************************
+   DESCRIPTION:
+        Stop OF Tx_DMA on the ET1310
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        N/A
+
+ *****************************************************************************/
+void et131x_tx_dma_disable( ET131X_ADAPTER *pAdapter )
+{
+    DBG_FUNC( "et131x_tx_dma_disable" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Setup the tramsmit dma configuration register
+     *************************************************************************/
+    pAdapter->CSRAddress->txdma.csr.value = 0x101;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_tx_dma_enable
+ ******************************************************************************
+   DESCRIPTION:
+        re-start OF Tx_DMA on the ET1310.  Mainly used after a return to the
+        D0 (full-power) state from a lower state.
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        N/A
+
+ *****************************************************************************/
+void et131x_tx_dma_enable( ET131X_ADAPTER *pAdapter )
+{
+    TXDMA_CSR_t csr = {0};
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_tx_dma_enable" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    if( pAdapter->RegistryPhyLoopbk )
+    {
+        /**********************************************************************
+            TxDMA is disabled for loopback operation.
+         *********************************************************************/
+        pAdapter->CSRAddress->txdma.csr.value = 0x101;
+
+    }
+    else
+    {
+        /**********************************************************************
+            Setup the transmit dma configuration register for normal operation
+         *********************************************************************/
+        csr.bits.sngl_epkt_mode = 1;
+        csr.bits.halt           = 0;
+        csr.bits.cache_thrshld  = pAdapter->RegistryDMACache;
+
+        pAdapter->CSRAddress->txdma.csr.value = csr.value;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_init_send
+ ******************************************************************************
+
+   DESCRIPTION       : Initialize send data structures
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_init_send( ET131X_ADAPTER *adapter )
+{
+    PMP_TCB         pMpTcb;
+    UINT32          TcbCount;
+    TX_RING_t      *tx_ring;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_init_send" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Setup some convenience pointers
+     *************************************************************************/
+    tx_ring = (TX_RING_t *)&adapter->TxRing;
+    pMpTcb  = (PMP_TCB)adapter->TxRing.MpTcbMem;
+
+
+    tx_ring->TCBReadyQueueHead = pMpTcb;
+
+
+    /**************************************************************************
+       Go through and set up each TCB
+     *************************************************************************/
+    for( TcbCount = 0; TcbCount < NUM_TCB; TcbCount++ )
+    {
+        memset( pMpTcb, 0, sizeof( MP_TCB ));
+
+
+        /**********************************************************************
+           Set the link pointer in HW TCB to the next TCB in the chain.  If
+           this is the last TCB in the chain, also set the tail pointer.
+         *********************************************************************/
+        if( TcbCount < NUM_TCB - 1 )
+        {
+            pMpTcb->Next = pMpTcb + 1;
+        }
+        else
+        {
+            tx_ring->TCBReadyQueueTail = pMpTcb;
+            pMpTcb->Next               = (PMP_TCB)NULL;
+        }
+
+        pMpTcb++;
+    }
+
+    /**************************************************************************
+       Curr send queue should now be empty
+     *************************************************************************/
+    tx_ring->CurrSendHead = (PMP_TCB)NULL;
+    tx_ring->CurrSendTail = (PMP_TCB)NULL;
+
+    INIT_LIST_HEAD( &adapter->TxRing.SendWaitQueue );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_send_packets
+ ******************************************************************************
+
+   DESCRIPTION:
+        This function is called by the OS to send packets
+
+   PARAMETERS :
+        skb    - the packet(s) to send
+        netdev - the net_device struct corresponding to the device on which to
+                 TX the above packet(s)
+
+   RETURN     :
+        0 in almost all cases
+        non-zero value in extreme hard failure only
+
+ *****************************************************************************/
+int et131x_send_packets( struct sk_buff *skb, struct net_device *netdev )
+{
+    int             status = 0;
+    ET131X_ADAPTER *pAdapter = NULL;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_send_packets" );
+    DBG_TX_ENTER( et131x_dbginfo );
+
+
+    pAdapter = netdev_priv( netdev );
+
+
+    /**************************************************************************
+       Send these packets
+
+       NOTE: The Linux Tx entry point is only given one packet at a time
+             to Tx, so the PacketCount and it's array used makes no sense here
+     *************************************************************************/
+
+    /**************************************************************************
+       Queue is not empty or TCB is not available
+     *************************************************************************/
+    if( !list_empty( &pAdapter->TxRing.SendWaitQueue ) ||
+         MP_TCB_RESOURCES_NOT_AVAILABLE( pAdapter ))
+    {
+        /**********************************************************************
+           NOTE - If there's an error on send, no need to queue the
+           packet under Linux; if we just send an error up to the netif
+           layer, it will resend the skb to us.
+         *********************************************************************/
+        DBG_VERBOSE( et131x_dbginfo,
+                     "TCB Resources Not Available\n" );
+        status = -ENOMEM;
+    }
+    else
+    {
+        /**********************************************************************
+           We need to see if the link is up; if it's not, make the netif layer
+           think we're good and drop the packet
+         *********************************************************************/
+        //if( MP_SHOULD_FAIL_SEND( pAdapter ) || pAdapter->DriverNoPhyAccess )
+        if( MP_SHOULD_FAIL_SEND( pAdapter ) || pAdapter->DriverNoPhyAccess ||
+            !netif_carrier_ok( netdev ))
+        {
+            DBG_VERBOSE( et131x_dbginfo,
+                         "Can't Tx, Link is DOWN; drop the packet\n" );
+
+            dev_kfree_skb_any( skb );
+            skb = NULL;
+
+            pAdapter->net_stats.tx_dropped++;
+        }
+        else
+        {
+            status = et131x_send_packet( skb, pAdapter );
+
+            if( status == -ENOMEM )
+            {
+
+                /**************************************************************
+                   NOTE - If there's an error on send, no need to queue the
+                   packet under Linux; if we just send an error up to the netif
+                   layer, it will resend the skb to us.
+                 *************************************************************/
+                DBG_WARNING( et131x_dbginfo,
+                             "Resources problem, Queue tx packet\n" );
+            }
+            else if( status != 0 )
+            {
+                /**************************************************************
+                   On any other error, make netif think we're OK and drop the
+                   packet
+                 *************************************************************/
+                DBG_WARNING( et131x_dbginfo,
+                             "General error, drop packet\n" );
+
+                dev_kfree_skb_any( skb );
+                skb = NULL;
+
+                pAdapter->net_stats.tx_dropped++;
+            }
+        }
+    }
+
+
+    DBG_TX_LEAVE( et131x_dbginfo );
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_send_packet
+ ******************************************************************************
+   DESCRIPTION:
+        Do the work to send a packet
+
+        Assumption: Send spinlock has been acquired
+
+   PARAMETERS :
+        skb      - the packet(s) to send
+        pAdapter - a pointer to the device's private adapter structure
+
+   RETURN     :
+        0 in almost all cases
+        non-zero value in extreme hard failure only
+
+ *****************************************************************************/
+int et131x_send_packet( struct sk_buff *skb, ET131X_ADAPTER *pAdapter )
+{
+    int             status          = 0;
+    PMP_TCB         pMpTcb          = NULL;
+    PUINT16         pShBufVa;
+    unsigned long   lockflags;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_send_packet" );
+    DBG_TX_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Is our buffer scattered, or continuous?
+     *************************************************************************/
+    if( skb_shinfo( skb )->nr_frags == 0 )
+    {
+        DBG_TX( et131x_dbginfo, "Scattered buffer: NO\n" );
+    }
+    else
+    {
+        DBG_TX( et131x_dbginfo, "Scattered buffer: YES, Num Frags: %d\n",
+                skb_shinfo( skb )->nr_frags );
+    }
+
+
+    /**************************************************************************
+       All packets must have at least a MAC address and a protocol type
+     *************************************************************************/
+    if( skb->len < ETH_HLEN )
+    {
+        DBG_ERROR( et131x_dbginfo, "Packet size < ETH_HLEN (14 bytes)\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -EIO;
+    }
+
+
+    /**************************************************************************
+       Is this packet VLAN tagged? If so, is it a tag previously registered?
+       If not, drop the packet
+
+       NOTE - We need not worry about the above note for now, as VLAN is handled
+       by the linux kernel (for the most part).
+     *************************************************************************/
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#if defined __vlan_get_tag
+    {
+        unsigned short vlan_tag;
+
+        if( __vlan_get_tag( skb, &vlan_tag ) == -EINVAL )
+        {
+            DBG_TX( et131x_dbginfo,
+                    "VLAN: No TX packet tag\n" );
+        }
+        else
+        {
+            DBG_TX( et131x_dbginfo,
+                    "VLAN: TX packet tag: %d\n", vlan_tag );
+        }
+    }
+#endif
+#endif
+
+
+    /**************************************************************************
+       Get a TCB for this packet
+     *************************************************************************/
+    spin_lock_irqsave( &pAdapter->TCBReadyQLock, lockflags );
+
+    pMpTcb = pAdapter->TxRing.TCBReadyQueueHead;
+
+    if( pMpTcb == NULL )
+    {
+        spin_unlock_irqrestore( &pAdapter->TCBReadyQLock, lockflags );
+
+        DBG_WARNING( et131x_dbginfo, "Can't obtain a TCB\n" );
+        DBG_TX_LEAVE( et131x_dbginfo );
+		return -ENOMEM;
+    }
+
+    pAdapter->TxRing.TCBReadyQueueHead = pMpTcb->Next;
+
+    if( pAdapter->TxRing.TCBReadyQueueHead == NULL )
+    {
+        pAdapter->TxRing.TCBReadyQueueTail = NULL;
+    }
+
+    spin_unlock_irqrestore( &pAdapter->TCBReadyQLock, lockflags );
+
+    pMpTcb->PacketLength    = skb->len;
+    pMpTcb->Packet          = skb;
+
+    if(( skb->data != NULL ) && (( skb->len - skb->data_len ) >= 6 ))
+    {
+        pShBufVa = (PUINT16)skb->data;
+
+        if(( pShBufVa [0] == 0xffff ) &&
+           ( pShBufVa [1] == 0xffff ) &&
+           ( pShBufVa [2] == 0xffff ))
+        {
+            MP_SET_FLAG( pMpTcb, fMP_DEST_BROAD );
+        }
+        else if(( pShBufVa [0] & 0x3 ) == 0x0001 )
+        {
+            MP_SET_FLAG( pMpTcb, fMP_DEST_MULTI );
+        }
+    }
+
+    pMpTcb->Next = NULL;
+
+
+    /**************************************************************************
+       Call the NIC specific send handler.
+     *************************************************************************/
+    if( status == 0 )
+    {
+        status = nic_send_packet( pAdapter, pMpTcb );
+    }
+
+	if( status != 0 )
+    {
+        spin_lock_irqsave( &pAdapter->TCBReadyQLock, lockflags );
+
+        if( pAdapter->TxRing.TCBReadyQueueTail )
+        {
+            pAdapter->TxRing.TCBReadyQueueTail->Next = pMpTcb;
+        }
+        else
+        {
+            /******************************************************************
+                Apparently ready Q is empty.
+             *****************************************************************/
+            pAdapter->TxRing.TCBReadyQueueHead = pMpTcb;
+        }
+
+        pAdapter->TxRing.TCBReadyQueueTail = pMpTcb;
+
+        spin_unlock_irqrestore( &pAdapter->TCBReadyQLock, lockflags );
+
+        DBG_TX_LEAVE( et131x_dbginfo );
+		return status ;
+    }
+
+    DBG_ASSERT( pAdapter->TxRing.nBusySend <= NUM_TCB );
+
+
+    DBG_TX_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  nic_send_packet
+ ******************************************************************************
+   DESCRIPTION:
+        NIC specific send handler. This version of the send routine is designed
+        for version B silicon.
+
+   PARAMETERS :
+        pAdapter  - pointer to our adapter
+        pMpTcb    - pointer to MP_TCB
+
+   RETURNS    :
+        0 or errno
+
+ *****************************************************************************/
+int nic_send_packet( ET131X_ADAPTER *pAdapter, PMP_TCB pMpTcb )
+{
+    UINT32                  loopIndex;
+    TX_DESC_ENTRY_t         CurDesc[24];
+    UINT32                  FragmentNumber = 0;
+    UINT32                  iThisCopy, iRemainder;
+    struct sk_buff         *pPacket = pMpTcb->Packet;
+    UINT32                  FragListCount = skb_shinfo( pPacket )->nr_frags + 1;
+    struct skb_frag_struct *pFragList = &skb_shinfo( pPacket )->frags[0];
+    unsigned long           lockflags1, lockflags2;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "nic_send_packet" );
+    DBG_TX_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+	    Part of the optimizations of this send routine restrict us to
+        sending 24 fragments at a pass.  In practice we should never see more
+        than 5 fragments.
+
+        NOTE: The older version of this function (below) can handle any number
+        of fragments. If needed, we can call this function, although it is less
+        efficient.
+	 *************************************************************************/
+    if( FragListCount > 23 )
+    {
+        DBG_TX_LEAVE( et131x_dbginfo );
+        return -EIO;
+    }
+
+    memset( CurDesc, 0, sizeof( TX_DESC_ENTRY_t ) * ( FragListCount + 1 ));
+
+    for( loopIndex = 0; loopIndex < FragListCount; loopIndex++ )
+    {
+        /**********************************************************************
+           If there is something in this element, lets get a descriptor from
+           the ring and get the necessary data
+         *********************************************************************/
+        if( loopIndex == 0 )
+        {
+            /******************************************************************
+               If the fragments are smaller than a standard MTU, then map them
+               to a single descriptor in the Tx Desc ring. However, if they're
+               larger, as is possible with support for jumbo packets, then
+               split them each across 2 descriptors.
+
+               This will work until we determine why the hardware doesn't seem
+               to like large fragments.
+             *****************************************************************/
+            if(( pPacket->len - pPacket->data_len ) <= 1514 )
+            {
+			    DBG_TX( et131x_dbginfo,
+                        "Got packet of length %d, "
+                        "filling desc entry %d, "
+                        "TCB: 0x%p\n",
+                        ( pPacket->len - pPacket->data_len ),
+                        pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
+                        pMpTcb );
+
+                CurDesc[FragmentNumber].DataBufferPtrHigh = 0;
+
+    		    CurDesc[FragmentNumber].word2.bits.length_in_bytes =
+                                        pPacket->len - pPacket->data_len;
+
+                /******************************************************************
+                   NOTE - Here, the dma_addr_t returned from pci_map_single() is
+                   implicitly cast as a UINT32. Although dma_addr_t can be 64-bit,
+                   the address returned by pci_map_single() is always 32-bit
+                   addressable (as defined by the pci/dma subsystem)
+                ******************************************************************/
+                CurDesc[FragmentNumber++].DataBufferPtrLow = pci_map_single( pAdapter->pdev,
+                                                                            pPacket->data,
+                                                                            pPacket->len - pPacket->data_len,
+                                                                            PCI_DMA_TODEVICE );
+            }
+            else
+            {
+                DBG_TX( et131x_dbginfo,
+                        "Got packet of length %d, "
+                        "filling desc entry %d, "
+                        "TCB: 0x%p\n",
+                        ( pPacket->len - pPacket->data_len ),
+                        pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
+                        pMpTcb );
+
+                CurDesc[FragmentNumber].DataBufferPtrHigh = 0;
+
+    		    CurDesc[FragmentNumber].word2.bits.length_in_bytes =
+                                        (( pPacket->len - pPacket->data_len ) / 2 );
+
+                /******************************************************************
+                   NOTE - Here, the dma_addr_t returned from pci_map_single() is
+                   implicitly cast as a UINT32. Although dma_addr_t can be 64-bit,
+                   the address returned by pci_map_single() is always 32-bit
+                   addressable (as defined by the pci/dma subsystem)
+                ******************************************************************/
+                CurDesc[FragmentNumber++].DataBufferPtrLow = pci_map_single( pAdapter->pdev,
+                                                                            pPacket->data,
+                                                                            (( pPacket->len - pPacket->data_len ) / 2 ),
+                                                                            PCI_DMA_TODEVICE );
+                CurDesc[FragmentNumber].DataBufferPtrHigh = 0;
+
+    		    CurDesc[FragmentNumber].word2.bits.length_in_bytes =
+                                        (( pPacket->len - pPacket->data_len ) / 2 );
+
+                /******************************************************************
+                   NOTE - Here, the dma_addr_t returned from pci_map_single() is
+                   implicitly cast as a UINT32. Although dma_addr_t can be 64-bit,
+                   the address returned by pci_map_single() is always 32-bit
+                   addressable (as defined by the pci/dma subsystem)
+                ******************************************************************/
+                CurDesc[FragmentNumber++].DataBufferPtrLow = pci_map_single( pAdapter->pdev,
+                                                                            pPacket->data + (( pPacket->len - pPacket->data_len ) / 2 ),
+                                                                            (( pPacket->len - pPacket->data_len ) / 2 ),
+                                                                            PCI_DMA_TODEVICE );
+            }
+        }
+        else
+        {
+            DBG_TX( et131x_dbginfo,
+                    "Got packet of length %d,"
+                    "filling desc entry %d\n"
+                    "TCB: 0x%p\n",
+                    pFragList[loopIndex].size,
+                    pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
+                    pMpTcb );
+
+            CurDesc[FragmentNumber].DataBufferPtrHigh = 0;
+
+
+    		CurDesc[FragmentNumber].word2.bits.length_in_bytes =
+                                    pFragList[loopIndex - 1].size;
+
+            /******************************************************************
+               NOTE - Here, the dma_addr_t returned from pci_map_page() is
+               implicitly cast as a UINT32. Although dma_addr_t can be 64-bit,
+               the address returned by pci_map_page() is always 32-bit
+               addressable (as defined by the pci/dma subsystem)
+            ******************************************************************/
+            CurDesc[FragmentNumber++].DataBufferPtrLow = pci_map_page( pAdapter->pdev,
+                                                                       pFragList[loopIndex - 1].page,
+                                                                       pFragList[loopIndex - 1].page_offset,
+                                                                       pFragList[loopIndex - 1].size,
+                                                                       PCI_DMA_TODEVICE );
+        }
+    }
+
+    if( FragmentNumber == 0 )
+    {
+        DBG_WARNING( et131x_dbginfo, "No. frags is 0\n" );
+        return -EIO;
+    }
+
+    if( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS )
+    {
+        if( ++pAdapter->TxRing.TxPacketsSinceLastinterrupt ==
+                                    pAdapter->RegistryTxNumBuffers )
+        {
+            CurDesc[FragmentNumber - 1].word3.value = 0x5;
+            pAdapter->TxRing.TxPacketsSinceLastinterrupt = 0;
+        }
+        else
+        {
+            CurDesc[FragmentNumber - 1].word3.value = 0x1;
+        }
+    }
+    else
+    {
+        CurDesc[FragmentNumber - 1].word3.value = 0x5;
+    }
+
+    CurDesc[0].word3.bits.f = 1;
+
+    pMpTcb->WrIndexStart = pAdapter->TxRing.txDmaReadyToSend;
+
+    pMpTcb->PacketStaleCount = 0;
+
+    spin_lock_irqsave( &pAdapter->SendHWLock, lockflags1 );
+
+    iThisCopy = NUM_DESC_PER_RING_TX - pAdapter->TxRing.txDmaReadyToSend.bits.serv_req;
+
+    if( iThisCopy >= FragmentNumber )
+    {
+        iRemainder = 0;
+        iThisCopy = FragmentNumber;
+    }
+    else
+    {
+        iRemainder = FragmentNumber - iThisCopy;
+    }
+
+    memcpy( pAdapter->TxRing.pTxDescRingVa + pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
+            CurDesc,
+            sizeof( TX_DESC_ENTRY_t ) * iThisCopy );
+
+
+    pAdapter->TxRing.txDmaReadyToSend.bits.serv_req += iThisCopy;
+
+    if(( pAdapter->TxRing.txDmaReadyToSend.bits.serv_req == 0 ) ||
+       ( pAdapter->TxRing.txDmaReadyToSend.bits.serv_req ==  NUM_DESC_PER_RING_TX))
+    {
+        if( pAdapter->TxRing.txDmaReadyToSend.bits.serv_req_wrap )
+        {
+            pAdapter->TxRing.txDmaReadyToSend.value = 0;
+        }
+        else
+        {
+            pAdapter->TxRing.txDmaReadyToSend.value = 0x400;
+        }
+    }
+
+    if( iRemainder )
+    {
+        memcpy( pAdapter->TxRing.pTxDescRingVa,
+                CurDesc + iThisCopy,
+                sizeof( TX_DESC_ENTRY_t ) * iRemainder );
+
+        pAdapter->TxRing.txDmaReadyToSend.bits.serv_req += iRemainder;
+    }
+
+    if( pAdapter->TxRing.txDmaReadyToSend.bits.serv_req == 0 )
+    {
+        if( pAdapter->TxRing.txDmaReadyToSend.value )
+        {
+            pMpTcb->WrIndex.value = NUM_DESC_PER_RING_TX - 1;
+        }
+        else
+        {
+            pMpTcb->WrIndex.value = 0x400 | ( NUM_DESC_PER_RING_TX - 1 );
+        }
+    }
+    else
+    {
+        pMpTcb->WrIndex.value = pAdapter->TxRing.txDmaReadyToSend.value - 1;
+    }
+
+    spin_lock_irqsave( &pAdapter->TCBSendQLock, lockflags2 );
+
+    if( pAdapter->TxRing.CurrSendTail )
+    {
+        pAdapter->TxRing.CurrSendTail->Next = pMpTcb;
+    }
+    else
+    {
+        pAdapter->TxRing.CurrSendHead = pMpTcb;
+    }
+
+    pAdapter->TxRing.CurrSendTail = pMpTcb;
+
+    DBG_ASSERT( pMpTcb->Next == NULL );
+
+    pAdapter->TxRing.nBusySend++;
+
+    spin_unlock_irqrestore( &pAdapter->TCBSendQLock, lockflags2 );
+
+
+    /**************************************************************************
+       Write the new write pointer back to the device.
+     *************************************************************************/
+    pAdapter->CSRAddress->txdma.service_request.value =
+                                       pAdapter->TxRing.txDmaReadyToSend.value;
+
+
+    /**************************************************************************
+       For Gig only, we use Tx Interrupt coalescing.  Enable the software
+       timer to wake us up if this packet isn't followed by N more.
+     *************************************************************************/
+    if( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS )
+    {
+        pAdapter->CSRAddress->global.watchdog_timer   =
+                            pAdapter->RegistryTxTimeInterval * NANO_IN_A_MICRO;
+    }
+
+    spin_unlock_irqrestore( &pAdapter->SendHWLock, lockflags1 );
+
+
+    DBG_TX_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
+
+
+
+
+/* NOTE - For now, keep this older version of NICSendPacket around for
+   reference, even though it's not used */
+#if 0
+
+/******************************************************************************
+   ROUTINE:  NICSendPacket
+ ******************************************************************************
+   DESCRIPTION:
+        NIC specific send handler. This version of the send routine is designed
+        for version A silicon.
+
+        Assumption: Send spinlock has been acquired
+
+   PARAMETERS :
+        pAdapter  - pointer to our adapter
+        pMpTcb    - pointer to MP_TCB
+        pFragList - pointer to the frag list to be filled
+
+   RETURNS    :
+        0 on succes, errno on failure
+
+ *****************************************************************************/
+int nic_send_packet( ET131X_ADAPTER *pAdapter, PMP_TCB pMpTcb )
+{
+    UINT32                       loopIndex, fragIndex, loopEnd;
+    UINT32                       iSplitFirstElement = 0;
+    UINT32                       SegmentSize = 0;
+    TX_DESC_ENTRY_t              CurDesc;
+    TX_DESC_ENTRY_t             *CurDescPostCopy = NULL;
+	UINT32			             SlotsAvailable;
+    TXDMA_SERVICE_COMPLETE_t     ServiceComplete = pAdapter->CSRAddress->txdma.NewServiceComplete;
+    unsigned int                 lockflags1, lockflags2;
+    struct sk_buff              *pPacket = pMpTcb->Packet;
+    UINT32                       FragListCount = skb_shinfo( pPacket )->nr_frags + 1;
+    struct skb_frag_struct      *pFragList = &skb_shinfo( pPacket )->frags[0];
+    PGLOBAL_t                    pGbl;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "nic_send_packet" );
+    DBG_TX_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+        Attempt to fix TWO hardware bugs:
+        1)  NEVER write an odd number of descriptors.
+        2)  If packet length is less than NIC_MIN_PACKET_SIZE, then pad the
+            packet to NIC_MIN_PACKET_SIZE bytes by adding a new last
+            descriptor IN HALF DUPLEX MODE ONLY
+        NOTE that (2) interacts with (1).  If the packet is less than
+        NIC_MIN_PACKET_SIZE bytes then we will append a descriptor.  Therefore
+        if it is even now, it will eventually end up odd, and so will need
+        adjusting.
+
+        VLAN tags get involved since VLAN tags add another one or two
+        segments.
+     *************************************************************************/
+    DBG_TX( et131x_dbginfo,
+            "pMpTcb->PacketLength: %d\n", pMpTcb->PacketLength );
+
+    if(( pAdapter->uiDuplexMode == 0 ) && ( pMpTcb->PacketLength < NIC_MIN_PACKET_SIZE ))
+    {
+        DBG_TX( et131x_dbginfo,
+                "HALF DUPLEX mode AND len < MIN_PKT_SIZE\n" );
+        if(( FragListCount & 0x1 ) == 0 )
+        {
+            DBG_TX( et131x_dbginfo,
+                    "Even number of descs, split 1st elem\n" );
+            iSplitFirstElement = 1;
+            //SegmentSize = pFragList[0].size / 2;
+            SegmentSize = ( pPacket->len - pPacket->data_len ) / 2;
+        }
+    }
+    else if( FragListCount & 0x1 )
+    {
+        DBG_TX( et131x_dbginfo,
+                "Odd number of descs, split 1st elem\n" );
+
+        iSplitFirstElement = 1;
+        //SegmentSize = pFragList[0].size / 2;
+        SegmentSize = ( pPacket->len - pPacket->data_len ) / 2;
+    }
+
+    spin_lock_irqsave( &pAdapter->SendHWLock, lockflags1 );
+
+    if( pAdapter->TxRing.txDmaReadyToSend.bits.serv_req_wrap ==
+                                           ServiceComplete.bits.serv_cpl_wrap )
+    {
+        /**********************************************************************
+	        The ring hasn't wrapped.  Slots available should be (RING_SIZE) -
+            the difference between the two pointers.
+	     *********************************************************************/
+        SlotsAvailable = NUM_DESC_PER_RING_TX -
+             ( pAdapter->TxRing.txDmaReadyToSend.bits.serv_req - ServiceComplete.bits.serv_cpl);
+    }
+    else
+    {
+        /**********************************************************************
+	        The ring has wrapped.  Slots available should be the difference
+            between the two pointers.
+	     *********************************************************************/
+        SlotsAvailable = ServiceComplete.bits.serv_cpl -
+                                                pAdapter->TxRing.txDmaReadyToSend.bits.serv_req;
+    }
+
+    if(( FragListCount + iSplitFirstElement ) > SlotsAvailable )
+    {
+		DBG_WARNING( et131x_dbginfo, "Not Enough Space in Tx Desc Ring\n" );
+        spin_unlock_irqrestore( &pAdapter->SendHWLock, lockflags1 );
+		return -ENOMEM;
+    }
+
+    loopEnd = ( FragListCount ) + iSplitFirstElement;
+    fragIndex = 0;
+
+    DBG_TX( et131x_dbginfo,
+            "TCB           : 0x%p\n", pMpTcb );
+    DBG_TX( et131x_dbginfo,
+            "Packet (SKB)  : 0x%p\t Packet->len: %d\t Packet->data_len: %d\n",
+            pPacket, pPacket->len, pPacket->data_len );
+
+    DBG_TX( et131x_dbginfo,
+            "FragListCount : %d\t iSplitFirstElement: %d\t loopEnd:%d\n",
+            FragListCount, iSplitFirstElement, loopEnd );
+
+    for( loopIndex = 0; loopIndex < loopEnd; loopIndex++ )
+    {
+        if( loopIndex > iSplitFirstElement )
+        {
+            fragIndex++;
+        }
+
+        DBG_TX( et131x_dbginfo, "In loop, loopIndex: %d\t fragIndex: %d\n",
+                loopIndex, fragIndex );
+
+
+        /**********************************************************************
+           If there is something in this element, let's get a descriptor from
+           the ring and get the necessary data
+         *********************************************************************/
+        DBG_TX( et131x_dbginfo,
+                "Packet Length %d,"
+                "filling desc entry %d\n",
+                pPacket->len,
+                pAdapter->TxRing.txDmaReadyToSend.bits.serv_req );
+
+        // NOTE - Should we do a paranoia check here to make sure the fragment
+        // actually has a length? It's HIGHLY unlikely the fragment would
+        // contain no data...
+        if( 1 )
+        {
+            // NOTE - Currently always getting 32-bit addrs, and dma_addr_t is
+            //        only 32-bit, so leave "high" ptr value out for now
+            CurDesc.DataBufferPtrHigh = 0;
+
+            CurDesc.word2.value       = 0;
+			CurDesc.word3.value       = 0;
+
+
+            if( fragIndex == 0 )
+            {
+                if( iSplitFirstElement )
+                {
+                    DBG_TX( et131x_dbginfo, "Split first element: YES\n" );
+
+                    if( loopIndex == 0 )
+                    {
+                        DBG_TX( et131x_dbginfo,
+                                "Got fragment of length %d, fragIndex: %d\n",
+                                pPacket->len - pPacket->data_len,
+                                fragIndex );
+                        DBG_TX( et131x_dbginfo,
+                                "SegmentSize: %d\n", SegmentSize );
+
+
+     			        CurDesc.word2.bits.length_in_bytes = SegmentSize;
+                        CurDesc.DataBufferPtrLow = pci_map_single( pAdapter->pdev,
+                                                                   pPacket->data,
+                                                                   SegmentSize,
+                                                                   PCI_DMA_TODEVICE );
+                        DBG_TX( et131x_dbginfo, "pci_map_single() returns: 0x%08x\n",
+                                CurDesc.DataBufferPtrLow );
+                    }
+                    else
+                    {
+                        DBG_TX( et131x_dbginfo,
+                                "Got fragment of length %d, fragIndex: %d\n",
+                                pPacket->len - pPacket->data_len,
+                                fragIndex );
+                        DBG_TX( et131x_dbginfo,
+                                "Leftover Size: %d\n",
+                                ( pPacket->len - pPacket->data_len - SegmentSize ));
+
+                        CurDesc.word2.bits.length_in_bytes = (( pPacket->len - pPacket->data_len ) -
+                                                                SegmentSize );
+                        CurDesc.DataBufferPtrLow = pci_map_single( pAdapter->pdev,
+                                                                 ( pPacket->data + SegmentSize ),
+                                                                 ( pPacket->len - pPacket->data_len -
+                                                                   SegmentSize ),
+                                                                   PCI_DMA_TODEVICE );
+                        DBG_TX( et131x_dbginfo, "pci_map_single() returns: 0x%08x\n",
+                                CurDesc.DataBufferPtrLow );
+                    }
+                }
+                else
+                {
+                    DBG_TX( et131x_dbginfo, "Split first element: NO\n" );
+
+                    CurDesc.word2.bits.length_in_bytes = pPacket->len -
+                                                         pPacket->data_len;
+
+                    CurDesc.DataBufferPtrLow = pci_map_single( pAdapter->pdev,
+                                                               pPacket->data,
+                                                             ( pPacket->len -
+                                                               pPacket->data_len ),
+                                                               PCI_DMA_TODEVICE );
+                    DBG_TX( et131x_dbginfo, "pci_map_single() returns: 0x%08x\n",
+                            CurDesc.DataBufferPtrLow );
+                }
+            }
+            else
+            {
+
+    			CurDesc.word2.bits.length_in_bytes = pFragList[fragIndex - 1].size;
+                CurDesc.DataBufferPtrLow = pci_map_page( pAdapter->pdev,
+                                                            pFragList[fragIndex - 1].page,
+                                                            pFragList[fragIndex - 1].page_offset,
+                                                            pFragList[fragIndex - 1].size,
+                                                            PCI_DMA_TODEVICE );
+                DBG_TX( et131x_dbginfo, "pci_map_page() returns: 0x%08x\n",
+                        CurDesc.DataBufferPtrLow );
+            }
+
+            if( loopIndex == 0 )
+            {
+                /**************************************************************
+                   This is the first descriptor of the packet
+                 *************************************************************/
+                /**************************************************************
+                   Set the "f" bit to indicate this is the first descriptor in
+                   the packet.
+                 *************************************************************/
+                DBG_TX( et131x_dbginfo, "This is our FIRST descriptor\n" );
+                CurDesc.word3.bits.f       = 1;
+
+                pMpTcb->WrIndexStart = pAdapter->TxRing.txDmaReadyToSend;
+            }
+
+            if(( loopIndex == (loopEnd - 1 )) &&
+               ( pAdapter->uiDuplexMode ||
+               ( pMpTcb->PacketLength >= NIC_MIN_PACKET_SIZE )))
+            {
+                /**************************************************************
+                   This is the Last descriptor of the packet
+                 *************************************************************/
+                DBG_TX( et131x_dbginfo, "THIS is our LAST descriptor\n" );
+
+                if( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS )
+                {
+                    if( ++pAdapter->TxRing.TxPacketsSinceLastinterrupt >= pAdapter->RegistryTxNumBuffers )
+                    {
+                        CurDesc.word3.value = 0x5;
+                        pAdapter->TxRing.TxPacketsSinceLastinterrupt = 0;
+                    }
+                    else
+                    {
+                        CurDesc.word3.value = 0x1;
+                    }
+                }
+                else
+                {
+                    CurDesc.word3.value = 0x5;
+                }
+
+
+				/**************************************************************
+                   Following index will be used during freeing of packet
+                 *************************************************************/
+                pMpTcb->WrIndex = pAdapter->TxRing.txDmaReadyToSend;
+                pMpTcb->PacketStaleCount = 0;
+            }
+
+            /******************************************************************
+                Copy the descriptor (filled above) into the descriptor ring
+                at the next free entry.  Advance the "next free entry" variable
+             *****************************************************************/
+            memcpy( pAdapter->TxRing.pTxDescRingVa + pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
+                    &CurDesc,
+                    sizeof( TX_DESC_ENTRY_t ));
+
+            CurDescPostCopy = pAdapter->TxRing.pTxDescRingVa + pAdapter->TxRing.txDmaReadyToSend.bits.serv_req;
+
+            DBG_TX( et131x_dbginfo, "CURRENT DESCRIPTOR\n" );
+            DBG_TX( et131x_dbginfo, "\tAddress           : 0x%p\n",   CurDescPostCopy );
+            DBG_TX( et131x_dbginfo, "\tDataBufferPtrHigh : 0x%08x\n", CurDescPostCopy->DataBufferPtrHigh );
+            DBG_TX( et131x_dbginfo, "\tDataBufferPtrLow  : 0x%08x\n", CurDescPostCopy->DataBufferPtrLow );
+            DBG_TX( et131x_dbginfo, "\tword2             : 0x%08x\n", CurDescPostCopy->word2.value );
+            DBG_TX( et131x_dbginfo, "\tword3             : 0x%08x\n", CurDescPostCopy->word3.value );
+
+
+            if( ++pAdapter->TxRing.txDmaReadyToSend.bits.serv_req >= NUM_DESC_PER_RING_TX )
+            {
+                if( pAdapter->TxRing.txDmaReadyToSend.bits.serv_req_wrap )
+                {
+                    pAdapter->TxRing.txDmaReadyToSend.value = 0;
+                }
+                else
+                {
+                    pAdapter->TxRing.txDmaReadyToSend.value = 0x400;
+                }
+            }
+        }
+    }
+
+
+    if(( pAdapter->uiDuplexMode == 0 ) && ( pMpTcb->PacketLength < NIC_MIN_PACKET_SIZE ))
+    {
+        // NOTE - Same 32/64-bit issue as above...
+        CurDesc.DataBufferPtrHigh = 0x0;
+        CurDesc.DataBufferPtrLow  = pAdapter->TxRing.pTxDummyBlkPa;
+		CurDesc.word2.value       = 0;
+
+        if( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS )
+        {
+            if( ++pAdapter->TxRing.TxPacketsSinceLastinterrupt >= pAdapter->RegistryTxNumBuffers )
+            {
+                CurDesc.word3.value = 0x5;
+                pAdapter->TxRing.TxPacketsSinceLastinterrupt = 0;
+            }
+            else
+            {
+                CurDesc.word3.value = 0x1;
+            }
+        }
+        else
+        {
+            CurDesc.word3.value = 0x5;
+        }
+
+     	CurDesc.word2.bits.length_in_bytes = NIC_MIN_PACKET_SIZE - pMpTcb->PacketLength;
+
+        pMpTcb->WrIndex = pAdapter->TxRing.txDmaReadyToSend;
+
+        memcpy( pAdapter->TxRing.pTxDescRingVa + pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
+                &CurDesc,
+                sizeof( TX_DESC_ENTRY_t ));
+
+        CurDescPostCopy = pAdapter->TxRing.pTxDescRingVa + pAdapter->TxRing.txDmaReadyToSend.bits.serv_req;
+
+        DBG_TX( et131x_dbginfo, "CURRENT DESCRIPTOR\n" );
+        DBG_TX( et131x_dbginfo, "\tAddress           : 0x%p\n",   CurDescPostCopy );
+        DBG_TX( et131x_dbginfo, "\tDataBufferPtrHigh : 0x%08x\n", CurDescPostCopy->DataBufferPtrHigh );
+        DBG_TX( et131x_dbginfo, "\tDataBufferPtrLow  : 0x%08x\n", CurDescPostCopy->DataBufferPtrLow );
+        DBG_TX( et131x_dbginfo, "\tword2             : 0x%08x\n", CurDescPostCopy->word2.value );
+        DBG_TX( et131x_dbginfo, "\tword3             : 0x%08x\n", CurDescPostCopy->word3.value );
+
+
+        if( ++pAdapter->TxRing.txDmaReadyToSend.bits.serv_req >= NUM_DESC_PER_RING_TX )
+        {
+            if( pAdapter->TxRing.txDmaReadyToSend.bits.serv_req_wrap )
+            {
+                pAdapter->TxRing.txDmaReadyToSend.value = 0;
+            }
+            else
+            {
+                pAdapter->TxRing.txDmaReadyToSend.value = 0x400;
+            }
+        }
+
+        DBG_TX( et131x_dbginfo, "Padding descriptor %d by %d bytes\n",
+                //pAdapter->TxRing.txDmaReadyToSend.value,
+                pAdapter->TxRing.txDmaReadyToSend.bits.serv_req,
+                NIC_MIN_PACKET_SIZE - pMpTcb->PacketLength );
+    }
+
+    spin_lock_irqsave( &pAdapter->TCBSendQLock, lockflags2 );
+
+    if( pAdapter->TxRing.CurrSendTail )
+    {
+        pAdapter->TxRing.CurrSendTail->Next = pMpTcb;
+    }
+    else
+    {
+        pAdapter->TxRing.CurrSendHead = pMpTcb;
+    }
+
+    pAdapter->TxRing.CurrSendTail = pMpTcb;
+
+    DBG_ASSERT( pMpTcb->Next == NULL );
+
+    pAdapter->TxRing.nBusySend++;
+
+    spin_unlock_irqrestore( &pAdapter->TCBSendQLock, lockflags2 );
+
+
+    /**************************************************************************
+       Write the new write pointer back to the device.
+     *************************************************************************/
+    pAdapter->CSRAddress->txdma.service_request.value = pAdapter->TxRing.txDmaReadyToSend.value;
+
+#if ( ET131X_DBG == 1 )
+    DumpDeviceBlock( DBG_TX_ON, pAdapter, 1 );
+#endif
+
+
+    /**************************************************************************
+        Map a local pointer to the global section of the JAGCore
+     *************************************************************************/
+    pGbl = &pAdapter->CSRAddress->global;
+
+
+    /**************************************************************************
+       For Gig only, we use Tx Interrupt coalescing.  Enable the software
+       timer to wake us up if this packet isn't followed by N more.
+     *************************************************************************/
+    if( pAdapter->uiLinkSpeed == TRUEPHY_SPEED_1000MBPS )
+    {
+        pAdapter->CSRAddress->global.watchdog_timer   =
+                            pAdapter->RegistryTxTimeInterval * NANO_IN_A_MICRO;
+    }
+
+    spin_unlock_irqrestore( &pAdapter->SendHWLock, lockflags1 );
+
+
+    DBG_TX_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
+#endif
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_free_send_packet
+ ******************************************************************************
+   DESCRIPTION:
+        Recycle a MP_TCB and complete the packet if necessary
+
+        Assumption: Send spinlock has been acquired
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter
+        pMpTcb   - pointer to MP_TCB
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+__inline void et131x_free_send_packet( ET131X_ADAPTER *pAdapter, PMP_TCB pMpTcb )
+{
+    unsigned long            lockflags;
+    TX_DESC_ENTRY_t         *desc       = NULL;
+    struct net_device_stats *stats      = &pAdapter->net_stats;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_free_send_packet" );
+
+
+    if( MP_TEST_FLAG( pMpTcb, fMP_DEST_BROAD ) )
+    {
+        atomic_inc( &pAdapter->Stats.brdcstxmt );
+    }
+    else if( MP_TEST_FLAG( pMpTcb, fMP_DEST_MULTI ))
+    {
+        atomic_inc( &pAdapter->Stats.multixmt );
+    }
+    else
+    {
+        atomic_inc( &pAdapter->Stats.unixmt );
+    }
+
+    if( pMpTcb->Packet )
+    {
+        stats->tx_bytes += pMpTcb->Packet->len;
+
+
+        /**********************************************************************
+           Iterate through the TX descriptors on the ring corresponding to this
+           packet and umap the fragments they point to
+         *********************************************************************/
+        DBG_TX( et131x_dbginfo, "Unmap descriptors Here\n" );
+
+        DBG_TX( et131x_dbginfo,
+                "TCB                  : 0x%p\n", pMpTcb );
+
+        DBG_TX( et131x_dbginfo,
+                "TCB Next             : 0x%p\n", pMpTcb->Next );
+
+        DBG_TX( et131x_dbginfo,
+                "TCB PacketLength     : %d\n", pMpTcb->PacketLength );
+
+        DBG_TX( et131x_dbginfo,
+                "TCB WrIndex.value    : 0x%08x\n", pMpTcb->WrIndexStart.value );
+        DBG_TX( et131x_dbginfo,
+                "TCB WrIndex.serv_req : %d\n", pMpTcb->WrIndexStart.bits.serv_req );
+
+        DBG_TX( et131x_dbginfo,
+                "TCB WrIndex.value    : 0x%08x\n", pMpTcb->WrIndex.value );
+        DBG_TX( et131x_dbginfo,
+                "TCB WrIndex.serv_req : %d\n", pMpTcb->WrIndex.bits.serv_req );
+
+        do
+        {
+            desc = (TX_DESC_ENTRY_t *)( pAdapter->TxRing.pTxDescRingVa +
+                                        pMpTcb->WrIndexStart.bits.serv_req );
+
+            DBG_TX( et131x_dbginfo, "CURRENT DESCRIPTOR\n" );
+            DBG_TX( et131x_dbginfo, "\tAddress           : 0x%p\n",   desc );
+            DBG_TX( et131x_dbginfo, "\tDataBufferPtrHigh : 0x%08x\n", desc->DataBufferPtrHigh );
+            DBG_TX( et131x_dbginfo, "\tDataBufferPtrLow  : 0x%08x\n", desc->DataBufferPtrLow );
+            DBG_TX( et131x_dbginfo, "\tword2             : 0x%08x\n", desc->word2.value );
+            DBG_TX( et131x_dbginfo, "\tword3             : 0x%08x\n", desc->word3.value );
+
+            pci_unmap_single( pAdapter->pdev,
+                              desc->DataBufferPtrLow,
+                              desc->word2.value,
+                              PCI_DMA_TODEVICE );
+
+            if( ++pMpTcb->WrIndexStart.bits.serv_req >= NUM_DESC_PER_RING_TX )
+            {
+                if( pMpTcb->WrIndexStart.bits.serv_req_wrap )
+                {
+                    pMpTcb->WrIndexStart.value = 0;
+                }
+                else
+                {
+                    pMpTcb->WrIndexStart.value = 0x400;
+                }
+            }
+        }
+        while( desc != ( pAdapter->TxRing.pTxDescRingVa +
+                         pMpTcb->WrIndex.bits.serv_req ));
+
+        DBG_TX( et131x_dbginfo,
+                "Free Packet (SKB)   : 0x%p\n", pMpTcb->Packet );
+
+        dev_kfree_skb_any( pMpTcb->Packet );
+    }
+
+    memset( pMpTcb, 0, sizeof( MP_TCB ));
+
+
+    /**************************************************************************
+       Add the TCB to the Ready Q
+     *************************************************************************/
+    spin_lock_irqsave( &pAdapter->TCBReadyQLock, lockflags );
+
+    pAdapter->Stats.opackets++;
+
+    if( pAdapter->TxRing.TCBReadyQueueTail )
+    {
+        pAdapter->TxRing.TCBReadyQueueTail->Next = pMpTcb;
+    }
+    else
+    {
+        /**********************************************************************
+            Apparently ready Q is empty.
+         *********************************************************************/
+        pAdapter->TxRing.TCBReadyQueueHead = pMpTcb;
+    }
+
+    pAdapter->TxRing.TCBReadyQueueTail = pMpTcb;
+
+    spin_unlock_irqrestore( &pAdapter->TCBReadyQLock, lockflags );
+
+
+    DBG_ASSERT( pAdapter->TxRing.nBusySend >= 0 );
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_free_busy_send_packets
+ ******************************************************************************
+   DESCRIPTION:
+        Free and complete the stopped active sends
+
+        Assumption: Send spinlock has been acquired
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void et131x_free_busy_send_packets( ET131X_ADAPTER *pAdapter )
+{
+    PMP_TCB           pMpTcb;
+    struct list_head *pEntry;
+    struct sk_buff   *pPacket     = NULL;
+    unsigned long     lockflags;
+    UINT32            FreeCounter = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_free_busy_send_packets" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    while( !list_empty( &pAdapter->TxRing.SendWaitQueue ))
+    {
+        spin_lock_irqsave( &pAdapter->SendWaitLock, lockflags );
+
+        pAdapter->TxRing.nWaitSend--;
+        spin_unlock_irqrestore( &pAdapter->SendWaitLock, lockflags );
+
+        pEntry  = pAdapter->TxRing.SendWaitQueue.next;
+
+        pPacket = NULL;
+    }
+
+    pAdapter->TxRing.nWaitSend = 0;
+
+
+    /**************************************************************************
+        Any packets being sent? Check the first TCB on the send list
+     *************************************************************************/
+    spin_lock_irqsave( &pAdapter->TCBSendQLock, lockflags );
+
+    pMpTcb = pAdapter->TxRing.CurrSendHead;
+
+    while(( pMpTcb != NULL ) && ( FreeCounter < NUM_TCB ))
+    {
+        PMP_TCB pNext = pMpTcb->Next;
+
+        pAdapter->TxRing.CurrSendHead = pNext;
+
+        if( pNext == NULL )
+        {
+            pAdapter->TxRing.CurrSendTail = NULL;
+        }
+
+        pAdapter->TxRing.nBusySend--;
+
+        spin_unlock_irqrestore( &pAdapter->TCBSendQLock, lockflags );
+
+        DBG_VERBOSE( et131x_dbginfo,
+                     "pMpTcb = 0x%p\n",
+                      pMpTcb );
+
+        FreeCounter++;
+        MP_FREE_SEND_PACKET_FUN( pAdapter, pMpTcb );
+
+        spin_lock_irqsave( &pAdapter->TCBSendQLock, lockflags );
+
+        pMpTcb = pAdapter->TxRing.CurrSendHead;
+    }
+
+    if( FreeCounter == NUM_TCB )
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "MpFreeBusySendPackets exitted loop for a bad reason\n" );
+        BUG();
+    }
+
+    spin_unlock_irqrestore( &pAdapter->TCBSendQLock, lockflags );
+
+    pAdapter->TxRing.nBusySend = 0;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_handle_send_interrupt
+ ******************************************************************************
+   DESCRIPTION:
+        Interrupt handler for sending processing
+        Re-claim the send resources, complete sends and get more to send from
+        the send wait queue
+
+        Assumption: Send spinlock has been acquired
+
+   PARAMETERS :
+        pAdapter  - pointer to our adapter
+
+   RETURNS    :
+        Nothing
+
+ *****************************************************************************/
+void et131x_handle_send_interrupt( ET131X_ADAPTER *pAdapter )
+{
+    DBG_FUNC( "et131x_handle_send_interrupt" );
+    DBG_TX_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Mark as completed any packets which have been sent by the device.
+     *************************************************************************/
+    et131x_update_tcb_list( pAdapter );
+
+
+    /**************************************************************************
+       If we queued any transmits because we didn't have any TCBs earlier,
+       dequeue and send those packets now, as long as we have free TCBs.
+     *************************************************************************/
+    et131x_check_send_wait_list( pAdapter );
+
+
+    DBG_TX_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_update_tcb_list
+ ******************************************************************************
+   DESCRIPTION:
+        Helper routine for Send Interrupt handler.  Re-claims the send
+        resources and completes sends.  Can also be called as part of the NIC
+        send routine when the "ServiceComplete" indication has wrapped.
+
+        Assumption:
+
+   PARAMETERS :
+        pAdapter  - pointer to our adapter
+
+   RETURNS    :
+        Nothing
+
+ *****************************************************************************/
+void et131x_update_tcb_list( ET131X_ADAPTER *pAdapter )
+{
+    unsigned long               lockflags;
+    TXDMA_SERVICE_COMPLETE_t    ServiceComplete = pAdapter->CSRAddress->txdma.NewServiceComplete;
+    PMP_TCB                     pMpTcb;
+    /*-----------------------------------------------------------------------*/
+
+
+	/**************************************************************************
+	   Has the ring wrapped?  Process any descriptors that do not have
+       the same "wrap" indicator as the current completion indicator
+	 *************************************************************************/
+    spin_lock_irqsave( &pAdapter->TCBSendQLock, lockflags );
+
+    pMpTcb = pAdapter->TxRing.CurrSendHead;
+
+    if( ServiceComplete.bits.serv_cpl_wrap )
+    {
+        while(  pMpTcb &&
+               !pMpTcb->WrIndex.bits.serv_req_wrap &&
+              ( pMpTcb->WrIndex.bits.serv_req > ServiceComplete.bits.serv_cpl ))
+	    {
+            PMP_TCB pNext = pMpTcb->Next;
+
+            pAdapter->TxRing.CurrSendHead = pNext;
+
+            if( pNext == NULL )
+            {
+                pAdapter->TxRing.CurrSendTail = NULL;
+            }
+
+            pAdapter->TxRing.nBusySend--;
+
+            spin_unlock_irqrestore( &pAdapter->TCBSendQLock, lockflags );
+            MP_FREE_SEND_PACKET_FUN( pAdapter, pMpTcb );
+            spin_lock_irqsave( &pAdapter->TCBSendQLock, lockflags );
+
+
+		    /******************************************************************
+			    Goto the next packet
+			 *****************************************************************/
+		    pMpTcb = pAdapter->TxRing.CurrSendHead;
+	    }
+    }
+    else
+    {
+        while( pMpTcb &&
+               pMpTcb->WrIndex.bits.serv_req_wrap &&
+             ( pMpTcb->WrIndex.bits.serv_req > ServiceComplete.bits.serv_cpl ))
+	    {
+            PMP_TCB pNext = pMpTcb->Next;
+
+            pAdapter->TxRing.CurrSendHead = pNext;
+
+            if( pNext == NULL )
+            {
+                pAdapter->TxRing.CurrSendTail = NULL;
+            }
+
+            pAdapter->TxRing.nBusySend--;
+
+            spin_unlock_irqrestore( &pAdapter->TCBSendQLock, lockflags );
+		    MP_FREE_SEND_PACKET_FUN( pAdapter, pMpTcb );
+            spin_lock_irqsave( &pAdapter->TCBSendQLock, lockflags );
+
+
+		    /******************************************************************
+			    Goto the next packet
+			 *****************************************************************/
+		    pMpTcb = pAdapter->TxRing.CurrSendHead;
+	    }
+    }
+
+    while( pMpTcb  &&
+         ( ServiceComplete.bits.serv_cpl_wrap == pMpTcb->WrIndex.bits.serv_req_wrap ) &&
+         ( ServiceComplete.bits.serv_cpl > pMpTcb->WrIndex.bits.serv_req ))
+    {
+        PMP_TCB pNext = pMpTcb->Next;
+
+        pAdapter->TxRing.CurrSendHead = pNext;
+
+        if( pNext == NULL )
+        {
+            pAdapter->TxRing.CurrSendTail = NULL;
+        }
+
+        pAdapter->TxRing.nBusySend--;
+
+        spin_unlock_irqrestore( &pAdapter->TCBSendQLock, lockflags );
+        MP_FREE_SEND_PACKET_FUN( pAdapter, pMpTcb );
+        spin_lock_irqsave( &pAdapter->TCBSendQLock, lockflags );
+
+
+		/**********************************************************************
+            Goto the next packet
+         *********************************************************************/
+        pMpTcb = pAdapter->TxRing.CurrSendHead;
+    }
+
+
+    /* Wake up the queue when we hit a low-water mark */
+    if( pAdapter->TxRing.nBusySend <= ( NUM_TCB / 3 ))
+    {
+        netif_wake_queue( pAdapter->netdev );
+    }
+
+    spin_unlock_irqrestore( &pAdapter->TCBSendQLock, lockflags );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_check_send_wait_list
+ ******************************************************************************
+   DESCRIPTION:
+        Helper routine for the interrupt handler.  Takes packets from the send
+        wait queue and posts them to the device (if room available).
+
+        Assumption:
+
+   PARAMETERS :
+        pAdapter  - pointer to our adapter
+
+   RETURNS    :
+        Nothing
+
+ *****************************************************************************/
+void et131x_check_send_wait_list( ET131X_ADAPTER *pAdapter )
+{
+    unsigned long lockflags;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_check_send_wait_list" );
+
+
+    spin_lock_irqsave( &pAdapter->SendWaitLock, lockflags );
+
+    while( !list_empty( &pAdapter->TxRing.SendWaitQueue ) &&
+           MP_TCB_RESOURCES_AVAILABLE( pAdapter ))
+    {
+        struct list_head *pEntry;
+
+        DBG_VERBOSE( et131x_dbginfo,
+                     "Tx packets on the wait queue\n" );
+
+        pEntry = pAdapter->TxRing.SendWaitQueue.next;
+
+        pAdapter->TxRing.nWaitSend--;
+
+        DBG_WARNING( et131x_dbginfo,
+                     "MpHandleSendInterrupt - sent a queued pkt. Waiting %d\n",
+                     pAdapter->TxRing.nWaitSend );
+    }
+
+    spin_unlock_irqrestore( &pAdapter->SendWaitLock, lockflags );
+
+    return;
+}
+/*===========================================================================*/
+
--- /dev/null
+++ b/drivers/net/et131x/ET1310_tx.h
@@ -0,0 +1,354 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * ET1310_tx.h - Defines, structs, enums, prototypes, etc. pertaining to data
+ *               transmission.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/10/07 21:26:45 $
+     $Revision: 1.9 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET1310_TX_H__
+#define __ET1310_TX_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+
+/******************************************************************************
+   Typedefs for Tx Descriptor Ring
+ *****************************************************************************/
+/******************************************************************************
+   TXDESC_WORD2_t structure holds part of the control bits in the Tx Descriptor
+   ring for the ET-1310
+ *****************************************************************************/
+typedef union _txdesc_word2_t
+{
+    UINT32 value;
+    struct
+    {
+        #ifdef _BIT_FIELDS_HTOL
+            UINT32 vlan_prio:3;                     //bits 29-31(VLAN priority)
+            UINT32 vlan_cfi:1;                      //bit 28(cfi)
+            UINT32 vlan_tag:12;                     //bits 16-27(VLAN tag)
+            UINT32 length_in_bytes:16;              //bits  0-15(packet length)
+        #else
+            UINT32 length_in_bytes:16;              //bits  0-15(packet length)
+            UINT32 vlan_tag:12;                     //bits 16-27(VLAN tag)
+            UINT32 vlan_cfi:1;                      //bit 28(cfi)
+            UINT32 vlan_prio:3;                     //bits 29-31(VLAN priority)
+        #endif /* _BIT_FIELDS_HTOL */
+    } bits;
+}TXDESC_WORD2_t, *PTXDESC_WORD2_t;
+
+
+
+
+/******************************************************************************
+   TXDESC_WORD3_t structure holds part of the control bits in the Tx Descriptor
+   ring for the ET-1310
+ *****************************************************************************/
+typedef union  _txdesc_word3_t
+{
+    UINT32 value;
+    struct
+    {
+        #ifdef _BIT_FIELDS_HTOL
+            UINT32 unused:17;                       //bits 15-31
+            UINT32 udpa:1;                          //bit 14(UDP checksum assist)
+            UINT32 tcpa:1;                          //bit 13(TCP checksum assist)
+            UINT32 ipa:1;                           //bit 12(IP checksum assist)
+            UINT32 vlan:1;                          //bit 11(append VLAN tag)
+            UINT32 hp:1;                            //bit 10(Packet is a Huge packet)
+            UINT32 pp:1;                            //bit  9(pad packet)
+            UINT32 mac:1;                           //bit  8(MAC override)
+            UINT32 crc:1;                           //bit  7(append CRC)
+            UINT32 e:1;                             //bit  6(Tx frame has error)
+            UINT32 pf:1;                            //bit  5(send pause frame)
+            UINT32 bp:1;                            //bit  4(Issue half-duplex backpressure (XON/XOFF)
+            UINT32 cw:1;                            //bit  3(Control word - no packet data)
+            UINT32 ir:1;                            //bit  2(interrupt the processor when this pkt sent)
+            UINT32 f:1;                             //bit  1(first packet in the sequence)
+            UINT32 l:1;                             //bit  0(last packet in the sequence)
+        #else
+            UINT32 l:1;                             //bit  0(last packet in the sequence)
+            UINT32 f:1;                             //bit  1(first packet in the sequence)
+            UINT32 ir:1;                            //bit  2(interrupt the processor when this pkt sent)
+            UINT32 cw:1;                            //bit  3(Control word - no packet data)
+            UINT32 bp:1;                            //bit  4(Issue half-duplex backpressure (XON/XOFF)
+            UINT32 pf:1;                            //bit  5(send pause frame)
+            UINT32 e:1;                             //bit  6(Tx frame has error)
+            UINT32 crc:1;                           //bit  7(append CRC)
+            UINT32 mac:1;                           //bit  8(MAC override)
+            UINT32 pp:1;                            //bit  9(pad packet)
+            UINT32 hp:1;                            //bit 10(Packet is a Huge packet)
+            UINT32 vlan:1;                          //bit 11(append VLAN tag)
+            UINT32 ipa:1;                           //bit 12(IP checksum assist)
+            UINT32 tcpa:1;                          //bit 13(TCP checksum assist)
+            UINT32 udpa:1;                          //bit 14(UDP checksum assist)
+            UINT32 unused:17;                       //bits 15-31
+        #endif /* _BIT_FIELDS_HTOL */
+    } bits;
+}TXDESC_WORD3_t, *PTXDESC_WORD3_t;
+
+
+
+
+/******************************************************************************
+   TX_DESC_ENTRY_t is sructure representing each descriptor on the ring
+ *****************************************************************************/
+typedef struct _tx_desc_entry_t
+{
+    UINT32         DataBufferPtrHigh;
+    UINT32         DataBufferPtrLow;
+    TXDESC_WORD2_t word2;                           // control words how to xmit the
+    TXDESC_WORD3_t word3;                           // data (detailed above)
+}
+TX_DESC_ENTRY_t, *PTX_DESC_ENTRY_t;
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   Typedefs for Tx DMA engine status writeback
+ *****************************************************************************/
+/******************************************************************************
+   TX_STATUS_BLOCK_t is sructure representing the status of the Tx DMA engine
+   it sits in free memory, and is pointed to by 0x101c / 0x1020
+ *****************************************************************************/
+
+typedef union _tx_status_block_t
+{
+    UINT32 value;
+    struct
+    {
+    #ifdef _BIT_FIELDS_HTOL
+        UINT32 unused:21;                           //bits 11-31
+        UINT32 serv_cpl_wrap:1;                     //bit 10
+        UINT32 serv_cpl:10;                         //bits 0-9
+    #else
+        UINT32 serv_cpl:10;                         //bits 0-9
+        UINT32 serv_cpl_wrap:1;                     //bit 10
+        UINT32 unused:21;                           //bits 11-31
+    #endif
+    } bits;
+}
+TX_STATUS_BLOCK_t, *PTX_STATUS_BLOCK_t;
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   TCB (Transmit Control Block)
+ *****************************************************************************/
+typedef struct _MP_TCB
+{
+    struct _MP_TCB          *Next;
+    UINT32                  Flags;
+    UINT32                  Count;
+    UINT32                  PacketStaleCount;
+    struct sk_buff          *Packet;
+    UINT32                  PacketLength;
+    TXDMA_SERVICE_REQUEST_t WrIndex;
+    TXDMA_SERVICE_REQUEST_t WrIndexStart;
+} MP_TCB, *PMP_TCB;
+
+
+
+
+/******************************************************************************
+   Structure to hold the skb's in a list
+ *****************************************************************************/
+typedef struct tx_skb_list_elem
+{
+	struct list_head  skb_list_elem;
+	struct sk_buff   *skb;
+} TX_SKB_LIST_ELEM, *PTX_SKB_LIST_ELEM;
+
+
+
+
+/******************************************************************************
+   TX_RING_t is sructure representing our local reference(s) to the ring
+ *****************************************************************************/
+typedef struct _tx_ring_t
+{
+    /**************************************************************************
+        TCB (Transmit Control Block) memory and lists
+     *************************************************************************/
+    PUCHAR                   MpTcbMem;
+
+
+    /**************************************************************************
+        List of TCBs that are ready to be used
+     *************************************************************************/
+    PMP_TCB                  TCBReadyQueueHead;
+    PMP_TCB                  TCBReadyQueueTail;
+
+
+    /**************************************************************************
+        list of TCBs that are currently being sent.  NOTE that access to all
+        three of these (including nBusySend) are controlled via the
+        TCBSendQLock.  This lock should be secured prior to incementing /
+        decrementing nBusySend, or any queue manipulation on CurrSendHead / Tail
+     *************************************************************************/
+    PMP_TCB                  CurrSendHead;
+    PMP_TCB                  CurrSendTail;
+    INT32                    nBusySend;
+
+
+    /**************************************************************************
+        List of packets (not TCBs) that were queued for lack of resources
+     *************************************************************************/
+    struct list_head         SendWaitQueue;
+    INT32                    nWaitSend;
+
+
+    /**************************************************************************
+        The actual descriptor ring
+     *************************************************************************/
+    PTX_DESC_ENTRY_t         pTxDescRingVa;
+    dma_addr_t               pTxDescRingPa;
+    UINT64                   pTxDescRingAdjustedPa;
+    UINT64                   TxDescOffset;
+
+
+    /**************************************************************************
+        ReadyToSend indicates where we last wrote to in the descriptor ring.
+     *************************************************************************/
+    TXDMA_SERVICE_REQUEST_t  txDmaReadyToSend;
+
+
+    /**************************************************************************
+        The location of the write-back status block
+     *************************************************************************/
+    PTX_STATUS_BLOCK_t       pTxStatusVa;
+    dma_addr_t               pTxStatusPa;
+
+
+    /**************************************************************************
+        A Block of zeroes, used to pad packets that are less than 60 bytes.
+     *************************************************************************/
+    void                    *pTxDummyBlkVa;
+    dma_addr_t               pTxDummyBlkPa;
+
+    TXMAC_ERR_t              TxMacErr;
+
+
+    /**************************************************************************
+        Variables to track the Tx interrupt coalescing features
+     *************************************************************************/
+    INT32                    TxPacketsSinceLastinterrupt;
+}
+TX_RING_t, *PTX_RING_t;
+
+
+
+
+/******************************************************************************
+   Forward declaration of the frag-list for the following prototypes
+ *****************************************************************************/
+typedef struct _MP_FRAG_LIST  MP_FRAG_LIST, *PMP_FRAG_LIST;
+
+
+
+
+/******************************************************************************
+   Forward declaration of the private adapter structure
+ *****************************************************************************/
+struct et131x_adapter;
+
+
+
+
+/******************************************************************************
+   PROTOTYPES for et1310_tx.c
+ *****************************************************************************/
+int et131x_tx_dma_memory_alloc( struct et131x_adapter *adapter );
+void et131x_tx_dma_memory_free( struct et131x_adapter *adapter );
+void ConfigTxDmaRegs( struct et131x_adapter *pAdapter );
+void et131x_init_send( struct et131x_adapter *adapter );
+void et131x_tx_dma_disable( struct et131x_adapter *pAdapter );
+void et131x_tx_dma_enable( struct et131x_adapter *pAdapter );
+void et131x_handle_send_interrupt( struct et131x_adapter *pAdapter );
+void et131x_free_busy_send_packets( struct et131x_adapter *pAdapter );
+int et131x_send_packets( struct sk_buff *skb, struct net_device *netdev );
+
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __ET1310_TX_H__ */
--- /dev/null
+++ b/drivers/net/et131x/Makefile
@@ -0,0 +1,17 @@
+obj-$(CONFIG_ET131X) += et131x.o
+
+et131x-objs :=	et131x_main.o \
+		et131x_initpci.o \
+		et131x_isr.o \
+		et131x_netdev.o \
+		et131x_supp.o \
+		et131x_config.o \
+		et131x_debug.o \
+		ET1310_jagcore.o \
+		ET1310_tx.o \
+		ET1310_rx.o \
+		ET1310_phy.o \
+		ET1310_mac.o \
+		ET1310_pm.o \
+		ET1310_eeprom.o
+
--- /dev/null
+++ b/drivers/net/et131x/et131x_adapter.h
@@ -0,0 +1,508 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_adapter.h - Header which includes the private adapter structure, along
+ *                    with related support structures, macros, definitions, etc.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2006/01/25 20:48:56 $
+     $Revision: 1.15 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET131X_ADAPTER_H__
+#define __ET131X_ADAPTER_H__
+
+
+
+
+#include "ET1310_address_map.h"
+#include "ET1310_tx.h"
+#include "ET1310_rx.h"
+
+
+
+
+/******************************************************************************
+   Do not change these values: if changed, then change also in respective
+   TXdma and Rxdma engines
+ *****************************************************************************/
+#define NUM_DESC_PER_RING_TX         512    // TX Do not change these values
+#define NUM_TCB                      64
+
+
+
+
+/******************************************************************************
+   These values are all superseded by registry entries to facilitate tuning.
+   Once the desired performance has been achieved, the optimal registry values
+   should be re-populated to these #defines:
+ *****************************************************************************/
+#define NUM_TRAFFIC_CLASSES          1
+
+
+
+
+/******************************************************************************
+   There are three ways of counting errors - if there are more than X errors
+   in Y packets (represented by the "SAMPLE" macros), if there are more than
+   N errors in a S mSec time period (the "PERIOD" macros), or if there are
+   consecutive packets with errors (CONSEC_ERRORED_THRESH).  This last covers
+   for "Bursty" errors, and the errored packets may well not be contiguous,
+   but several errors where the packet counter has changed by less than a
+   small amount will cause this count to increment.
+ *****************************************************************************/
+#define TX_PACKETS_IN_SAMPLE        10000
+#define TX_MAX_ERRORS_IN_SAMPLE     50
+
+#define TX_ERROR_PERIOD             1000
+#define TX_MAX_ERRORS_IN_PERIOD     10
+
+#define LINK_DETECTION_TIMER        5000
+
+#define TX_CONSEC_RANGE             5
+#define TX_CONSEC_ERRORED_THRESH    10
+
+#define LO_MARK_PERCENT_FOR_PSR     15
+#define LO_MARK_PERCENT_FOR_RX      15
+
+
+
+
+/******************************************************************************
+   Macros for flag and ref count operations
+ *****************************************************************************/
+#define MP_SET_FLAG(_M, _F)         ((_M)->Flags |= (_F))
+#define MP_CLEAR_FLAG(_M, _F)       ((_M)->Flags &= ~(_F))
+#define MP_CLEAR_FLAGS(_M)          ((_M)->Flags = 0)
+#define MP_TEST_FLAG(_M, _F)        (((_M)->Flags & (_F)) != 0)
+#define MP_TEST_FLAGS(_M, _F)       (((_M)->Flags & (_F)) == (_F))
+#define MP_IS_FLAG_CLEAR(_M, _F)    (((_M)->Flags & (_F)) == 0)
+
+#define MP_INC_RCV_REF(_A)          atomic_inc(&(_A)->RcvRefCount)
+#define MP_DEC_RCV_REF(_A)          atomic_dec(&(_A)->RcvRefCount)
+#define MP_GET_RCV_REF(_A)          atomic_read(&(_A)->RcvRefCount)
+
+
+
+
+/******************************************************************************
+   Macros specific to the private adapter structure
+ *****************************************************************************/
+#define MP_TCB_RESOURCES_AVAILABLE(_M) ((_M)->TxRing.nBusySend < NUM_TCB)
+#define MP_TCB_RESOURCES_NOT_AVAILABLE(_M) ((_M)->TxRing.nBusySend >= NUM_TCB)
+
+#define MP_SHOULD_FAIL_SEND(_M)   ((_M)->Flags & fMP_ADAPTER_FAIL_SEND_MASK)
+#define MP_IS_NOT_READY(_M)       ((_M)->Flags & fMP_ADAPTER_NOT_READY_MASK)
+#define MP_IS_READY(_M)           !((_M)->Flags & fMP_ADAPTER_NOT_READY_MASK)
+
+#define MP_HAS_CABLE(_M)           !((_M)->Flags & fMP_ADAPTER_NO_CABLE)
+#define MP_LINK_DETECTED(_M)       !((_M)->Flags & fMP_ADAPTER_LINK_DETECTION)
+
+
+
+
+/******************************************************************************
+   Counters for error rate monitoring
+ *****************************************************************************/
+typedef struct _MP_ERR_COUNTERS
+{
+    UINT32                  PktCountTxPackets;
+    UINT32                  PktCountTxErrors;
+    UINT32                  TimerBasedTxErrors;
+    UINT32                  PktCountLastError;
+    UINT32                  ErredConsecPackets;
+} MP_ERR_COUNTERS, *PMP_ERR_COUNTERS;
+
+
+
+
+/******************************************************************************
+   RFD (Receive Frame Descriptor)
+ *****************************************************************************/
+typedef struct _MP_RFD
+{
+    struct list_head        list_node;
+    struct sk_buff          *Packet;
+    UINT32                  PacketSize;         // total size of receive frame
+    UINT16                  iBufferIndex;
+    UINT8                   iRingIndex;
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+    BOOL_t                  bHasVLANTag;
+    UINT16                  VLANTag;
+#endif
+} MP_RFD, *PMP_RFD;
+
+
+
+
+/******************************************************************************
+   Enum for Flow Control
+ *****************************************************************************/
+typedef enum _eflow_control_t {
+    Both   = 0,
+    TxOnly = 1,
+    RxOnly = 2,
+    None   = 3
+} eFLOW_CONTROL_t, *PeFLOW_CONTROL_t;
+
+
+
+
+/******************************************************************************
+   Struct to define some device statistics
+ *****************************************************************************/
+typedef struct _ce_stats_t
+{
+    /**************************************************************************
+       Link Input/Output stats
+     *************************************************************************/
+    UINT64    ipackets;    // # of in packets
+    UINT64    opackets;    // # of out packets
+
+
+    /**************************************************************************
+       MIB II variables
+     *************************************************************************/
+    /**************************************************************************
+       NOTE - atomic_t types are only guaranteed to store 24-bits; if we MUST
+              have 32, then we'll need another way to perform atomic operations
+     *************************************************************************/
+    UINT32    unircv;      // # multicast packets received
+    atomic_t  unixmt;      // # multicast packets for Tx
+    UINT32    multircv;    // # multicast packets received
+    atomic_t  multixmt;    // # multicast packets for Tx
+    UINT32    brdcstrcv;   // # broadcast packets received
+    atomic_t  brdcstxmt;   // # broadcast packets for Tx
+    UINT32    norcvbuf;    // # Rx packets discarded
+    UINT32    noxmtbuf;    // # Tx packets discarded
+
+
+    /**************************************************************************
+       Transciever state informations.
+     *************************************************************************/
+    UINT32    xcvr_addr;
+    UINT32    xcvr_id;
+
+
+    /**************************************************************************
+       Tx Statistics.
+     *************************************************************************/
+    UINT32    tx_uflo;                   //Tx Underruns
+
+    UINT32    collisions;
+    UINT32    excessive_collisions;
+    UINT32    first_collision;
+    UINT32    late_collisions;
+    UINT32    max_pkt_error;
+    UINT32    tx_deferred;
+
+
+    /**************************************************************************
+       Rx Statistics.
+     *************************************************************************/
+    UINT32    rx_ov_flow;     //Rx Over Flow
+
+    UINT32    length_err;
+    UINT32    alignment_err;
+    UINT32    crc_err;
+    UINT32    code_violations;
+    UINT32    other_errors;
+
+#if ET131X_DBG
+    UINT32    UnhandledInterruptsPerSec;
+    UINT32    RxDmaInterruptsPerSec;
+    UINT32    TxDmaInterruptsPerSec;
+    UINT32    WatchDogInterruptsPerSec;
+#endif  /* ET131X_DBG */
+
+    UINT32    SynchrounousIterations;
+    INT_STATUS_t InterruptStatus;
+}
+CE_STATS_t, *PCE_STATS_t;
+
+
+
+
+/******************************************************************************
+   The private adapter structure
+ *****************************************************************************/
+typedef struct et131x_adapter
+{
+    struct net_device       *netdev;
+    struct pci_dev          *pdev;
+
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+    struct tq_struct        task;
+#else
+    struct work_struct      task;
+#endif
+
+
+    /**************************************************************************
+       Flags that indicate current state of the adapter
+     *************************************************************************/
+    UINT32                  Flags;
+    UINT32                  HwErrCount;
+
+
+    /**************************************************************************
+       Configuration
+     *************************************************************************/
+    UCHAR                   PermanentAddress[ETH_ALEN];
+    UCHAR                   CurrentAddress[ETH_ALEN];
+    BOOL_t                  bOverrideAddress;
+    BOOL_t                  bEepromPresent;
+    UCHAR                   eepromData[2];
+
+
+    /**************************************************************************
+       Spinlocks
+     *************************************************************************/
+    spinlock_t              Lock;
+
+    spinlock_t              TCBSendQLock;
+    spinlock_t              TCBReadyQLock;
+    spinlock_t              SendHWLock;
+    spinlock_t              SendWaitLock;
+
+    spinlock_t              RcvLock;
+    spinlock_t              RcvPendLock;
+    spinlock_t              FbrLock;
+
+    spinlock_t              PHYLock;
+
+
+    /**************************************************************************
+       Packet Filter and look ahead size
+     *************************************************************************/
+    UINT32                  PacketFilter;
+    UINT32                  ulLookAhead;
+    UINT32                  uiLinkSpeed;
+    UINT32                  uiDuplexMode;
+    UINT32                  uiAutoNegStatus;
+    UCHAR                   ucLinkStatus;
+
+
+    /**************************************************************************
+       multicast list
+     *************************************************************************/
+    UINT32                  MCAddressCount;
+    UCHAR                   MCList[NIC_MAX_MCAST_LIST][ETH_ALEN];
+
+
+    /**************************************************************************
+       MAC test
+     *************************************************************************/
+    TXMAC_TXTEST_t          TxMacTest;
+
+
+    /**************************************************************************
+       Pointer to the device's PCI register space
+     *************************************************************************/
+    ADDRESS_MAP_t          *CSRAddress;
+
+
+    /**************************************************************************
+       PCI config space info, for debug purposes only.
+     *************************************************************************/
+    UCHAR                   RevisionID;
+    UINT16                  VendorID;
+    UINT16                  DeviceID;
+    UINT16                  SubVendorID;
+    UINT16                  SubSystemID;
+    UINT32                  CacheFillSize;
+    UINT16                  PciXDevCtl;
+	UCHAR   		        pci_lat_timer;
+	UCHAR			        pci_hdr_type;
+	UCHAR			        pci_bist;
+	UINT32			        pci_cfg_state[64 / sizeof(u32)];
+
+
+    /**************************************************************************
+       Registry parameters
+     *************************************************************************/
+    UCHAR                   SpeedDuplex;            // speed/duplex
+    eFLOW_CONTROL_t         RegistryFlowControl;    // for 802.3x flow control
+    UCHAR                   RegistryWOLMatch;       // Enable WOL pattern-matching
+    UCHAR                   RegistryWOLLink;        // Link state change is independant
+    UCHAR                   RegistryPhyComa;        // Phy Coma mode enable/disable
+
+    UINT32                  RegistryRxMemEnd;       // Size of internal rx memory
+    UCHAR                   RegistryMACStat;        // If set, read MACSTAT, else don't
+    UINT32                  RegistryVlanTag;        // 802.1q Vlan TAG
+    UINT32                  RegistryJumboPacket;    // Max supported ethernet packet size
+
+    UINT32                  RegistryTxNumBuffers;
+    UINT32                  RegistryTxTimeInterval;
+
+    UINT32                  RegistryRxNumBuffers;
+    UINT32                  RegistryRxTimeInterval;
+
+
+    /**************************************************************************
+       Validation helpers
+     *************************************************************************/
+    UCHAR                   RegistryPMWOL;
+    UCHAR                   RegistryNMIDisable;
+    UINT32                  RegistryDMACache;
+    UINT32                  RegistrySCGain;
+    UCHAR                   RegistryPhyLoopbk;      // Enable Phy loopback
+
+
+    /**************************************************************************
+       Derived from the registry:
+     *************************************************************************/
+    UCHAR                   AiForceDpx;         // duplex setting
+    UINT16                  AiForceSpeed;       // 'Speed', user over-ride of line speed
+    eFLOW_CONTROL_t         FlowControl;        // flow control validated by the far-end
+    NETIF_STATUS            MediaState;
+    UCHAR                   DriverNoPhyAccess;
+
+
+    /**************************************************************************
+       Minimize init-time
+     *************************************************************************/
+    BOOL_t                  bQueryPending;
+    BOOL_t                  bSetPending;
+    BOOL_t                  bResetPending;
+    struct timer_list       ErrorTimer;
+    BOOL_t                  bLinkTimerActive;
+    MP_POWER_MGMT           PoMgmt;
+    INT_MASK_t              CachedMaskValue;
+
+    atomic_t                RcvRefCount;    // Num packets not yet returned
+
+
+    /**************************************************************************
+       Xcvr status at last poll
+     *************************************************************************/
+    MI_BMSR_t               Bmsr;
+
+
+    /**************************************************************************
+       Tx Memory Variables
+     *************************************************************************/
+    TX_RING_t               TxRing;
+
+
+    /**************************************************************************
+	   Rx Memory Variables
+     *************************************************************************/
+    RX_RING_t               RxRing;
+
+
+    /**************************************************************************
+       ET1310 register Access
+     *************************************************************************/
+	JAGCORE_ACCESS_REGS     JagCoreRegs;
+	PCI_CFG_SPACE_REGS		PciCfgRegs;
+
+
+    /**************************************************************************
+       Loopback specifics
+     *************************************************************************/
+    UCHAR                   ReplicaPhyLoopbk;       // Replica Enable
+    UCHAR                   ReplicaPhyLoopbkPF;     // Replica Enable Pass/Fail
+
+
+    /**************************************************************************
+       Stats
+     *************************************************************************/
+    CE_STATS_t              Stats;
+
+    struct net_device_stats	net_stats;
+	struct net_device_stats	net_stats_prev;
+
+
+    /**************************************************************************
+       VLAN
+     *************************************************************************/
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+    struct vlan_group      *vlgrp;
+#endif
+
+    /**************************************************************************
+       Data to support workaround for bad config space addresses; see
+       et131x_pci_setup() for more information
+     *************************************************************************/
+    BOOL_t                  pci_bar_workaround;
+    unsigned long           pci_bar_addr_orig;
+} ET131X_ADAPTER, *PET131X_ADAPTER;
+
+
+
+
+#define MPSendPacketsHandler  MPSendPackets
+#define  MP_FREE_SEND_PACKET_FUN(Adapter, pMpTcb)  et131x_free_send_packet(Adapter, pMpTcb)
+#define  MpSendPacketFun(Adapter,Packet) MpSendPacket(Adapter, Packet)
+
+
+
+
+#endif  /* __ET131X_ADAPTER_H__ */
--- /dev/null
+++ b/drivers/net/et131x/et131x_config.c
@@ -0,0 +1,383 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_config.c - Handles parsing of configuration data during
+ *                   initialization.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/10/28 18:43:46 $
+     $Revision: 1.8 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_initpci.h"
+
+#include "ET1310_tx.h"
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   Defines for Parameter Default/Min/Max vaules
+ *****************************************************************************/
+#define PARM_SPEED_DUPLEX_DEF   0
+#define PARM_SPEED_DUPLEX_MIN   0
+#define PARM_SPEED_DUPLEX_MAX   5
+
+#define PARM_VLAN_TAG_DEF       0
+#define PARM_VLAN_TAG_MIN       0
+#define PARM_VLAN_TAG_MAX       4095
+
+#define PARM_FLOW_CTL_DEF       0
+#define PARM_FLOW_CTL_MIN       0
+#define PARM_FLOW_CTL_MAX       3
+
+#define PARM_WOL_LINK_DEF       3
+#define PARM_WOL_LINK_MIN       0
+#define PARM_WOL_LINK_MAX       3
+
+#define PARM_WOL_MATCH_DEF      7
+#define PARM_WOL_MATCH_MIN      0
+#define PARM_WOL_MATCH_MAX      7
+
+#define PARM_JUMBO_PKT_DEF      1514
+#define PARM_JUMBO_PKT_MIN      1514
+#define PARM_JUMBO_PKT_MAX      9216
+
+#define PARM_PHY_COMA_DEF       0
+#define PARM_PHY_COMA_MIN       0
+#define PARM_PHY_COMA_MAX       1
+
+#define PARM_RX_NUM_BUFS_DEF    4
+#define PARM_RX_NUM_BUFS_MIN    1
+#define PARM_RX_NUM_BUFS_MAX    64
+
+#define PARM_RX_TIME_INT_DEF    10
+#define PARM_RX_TIME_INT_MIN    2
+#define PARM_RX_TIME_INT_MAX    320
+
+#define PARM_TX_NUM_BUFS_DEF    4
+#define PARM_TX_NUM_BUFS_MIN    1
+#define PARM_TX_NUM_BUFS_MAX    40
+
+#define PARM_TX_TIME_INT_DEF    40
+#define PARM_TX_TIME_INT_MIN    1
+#define PARM_TX_TIME_INT_MAX    140
+
+#define PARM_RX_MEM_END_DEF     0x2bc
+#define PARM_RX_MEM_END_MIN     0
+#define PARM_RX_MEM_END_MAX     0x3ff
+
+#define PARM_MAC_STAT_DEF       1
+#define PARM_MAC_STAT_MIN       0
+#define PARM_MAC_STAT_MAX       1
+
+#define PARM_SC_GAIN_DEF        7
+#define PARM_SC_GAIN_MIN        0
+#define PARM_SC_GAIN_MAX        7
+
+#define PARM_PM_WOL_DEF         0
+#define PARM_PM_WOL_MIN         0
+#define PARM_PM_WOL_MAX         1
+
+#define PARM_NMI_DISABLE_DEF    0
+#define PARM_NMI_DISABLE_MIN    0
+#define PARM_NMI_DISABLE_MAX    2
+
+#define PARM_DMA_CACHE_DEF      0
+#define PARM_DMA_CACHE_MIN      0
+#define PARM_DMA_CACHE_MAX      15
+
+#define PARM_PHY_LOOPBK_DEF     0
+#define PARM_PHY_LOOPBK_MIN     0
+#define PARM_PHY_LOOPBK_MAX     1
+
+
+#define PARM_MAC_ADDRESS_DEF    { 0x00, 0x05, 0x3d, 0x00, 0x02, 0x00 }
+
+
+
+
+/******************************************************************************
+    Module parameter for disabling NMI
+ *****************************************************************************/
+static u32 et131x_nmi_disable = PARM_NMI_DISABLE_DEF;
+
+module_param    ( et131x_nmi_disable, uint, 0 );
+MODULE_PARM_DESC( et131x_nmi_disable, "Disable NMI (0-2) [0]" );
+
+
+/*****************************************************************************
+    Module parameter for manual speed setting
+ ****************************************************************************/
+static u32 et131x_speed_set = PARM_SPEED_DUPLEX_DEF;
+module_param    (et131x_speed_set, uint, 0);
+MODULE_PARM_DESC( et131x_speed_set, "Set Link speed and dublex manually (0-5)  [0] \n  1 : 10Mb   Half-Duplex \n  2 : 10Mb   Full-Duplex \n  3 : 100Mb  Half-Duplex \n  4 : 100Mb  Full-Duplex \n  5 : 1000Mb Full-Duplex \n 0 : Auto Speed Auto Dublex");
+
+
+/******************************************************************************
+   ROUTINE :  et131x_config_parse
+ ******************************************************************************
+
+   DESCRIPTION       : Parses a configuration from some location (module
+                       parameters, for example) into the private adapter struct
+
+   PARAMETERS        : pAdapter - pointer to the private adapter struct
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_config_parse( ET131X_ADAPTER *pAdapter )
+{
+    UINT8   macAddrDef[] = PARM_MAC_ADDRESS_DEF;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_config_parse" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       The NDIS driver uses the registry to store persistent per-device
+       configuration, and reads this configuration into the appropriate
+       elements of the private adapter structure on initialization. Because
+       Linux has no analog to the registry, use this function to initialize the
+       private adapter structure with a default configuration.
+
+       One other possibility is to use a series of module parameters which can
+       be passed in by the caller when the module is initialized. However, this
+       implementation does not allow for seperate configurations in the event
+       multiple devices are present, and hence will not suffice.
+
+       If another method is derived which addresses this problem, this is where
+       it should be implemented.
+     *************************************************************************/
+
+    /**************************************************************************
+       Set the private adapter struct with default values for the corresponding
+       parameters
+     *************************************************************************/
+    if( et131x_speed_set != PARM_SPEED_DUPLEX_DEF )
+    {
+         DBG_VERBOSE( et131x_dbginfo, "Speed set manually to : %d \n",et131x_speed_set );
+        pAdapter->SpeedDuplex  = et131x_speed_set;
+    }
+    else
+    {
+        pAdapter->SpeedDuplex  = PARM_SPEED_DUPLEX_DEF;
+    }
+
+  //  pAdapter->SpeedDuplex            = PARM_SPEED_DUPLEX_DEF;
+
+    pAdapter->RegistryVlanTag        = PARM_VLAN_TAG_DEF;
+    pAdapter->RegistryFlowControl    = PARM_FLOW_CTL_DEF;
+    pAdapter->RegistryWOLLink        = PARM_WOL_LINK_DEF;
+    pAdapter->RegistryWOLMatch       = PARM_WOL_MATCH_DEF;
+    pAdapter->RegistryJumboPacket    = PARM_JUMBO_PKT_DEF;
+    pAdapter->RegistryPhyComa        = PARM_PHY_COMA_DEF;
+    pAdapter->RegistryRxNumBuffers   = PARM_RX_NUM_BUFS_DEF;
+    pAdapter->RegistryRxTimeInterval = PARM_RX_TIME_INT_DEF;
+    pAdapter->RegistryTxNumBuffers   = PARM_TX_NUM_BUFS_DEF;
+    pAdapter->RegistryTxTimeInterval = PARM_TX_TIME_INT_DEF;
+    pAdapter->RegistryRxMemEnd       = PARM_RX_MEM_END_DEF;
+    pAdapter->RegistryMACStat        = PARM_MAC_STAT_DEF;
+    pAdapter->RegistrySCGain         = PARM_SC_GAIN_DEF;
+    pAdapter->RegistryPMWOL          = PARM_PM_WOL_DEF;
+
+    if( et131x_nmi_disable != PARM_NMI_DISABLE_DEF )
+    {
+        pAdapter->RegistryNMIDisable = et131x_nmi_disable;
+    }
+    else
+    {
+        pAdapter->RegistryNMIDisable = PARM_NMI_DISABLE_DEF;
+    }
+
+    pAdapter->RegistryDMACache       = PARM_DMA_CACHE_DEF;
+    pAdapter->RegistryPhyLoopbk      = PARM_PHY_LOOPBK_DEF;
+
+
+    /**************************************************************************
+       Set the MAC address to a default
+     *************************************************************************/
+    memcpy( pAdapter->CurrentAddress, macAddrDef, ETH_ALEN );
+    pAdapter->bOverrideAddress = FALSE;
+
+    DBG_TRACE( et131x_dbginfo,
+               "Default MAC Address  : %02x:%02x:%02x:%02x:%02x:%02x\n",
+               pAdapter->CurrentAddress[0], pAdapter->CurrentAddress[1],
+               pAdapter->CurrentAddress[2], pAdapter->CurrentAddress[3],
+               pAdapter->CurrentAddress[4], pAdapter->CurrentAddress[5] );
+
+
+    /**************************************************************************
+       Decode SpeedDuplex
+
+       Set up as if we are auto negotiating always and then change if we go
+       into force mode
+     *************************************************************************/
+    pAdapter->AiForceSpeed = 0;         // Auto speed
+    pAdapter->AiForceDpx   = 0;         // Auto FDX
+
+
+    /**************************************************************************
+       If we are the 10/100 device, and gigabit is somehow requested then
+       knock it down to 100 full.
+     *************************************************************************/
+    if(( pAdapter->DeviceID == ET131X_PCI_DEVICE_ID_FAST ) &&
+       ( pAdapter->SpeedDuplex == 5 ))
+    {
+        pAdapter->SpeedDuplex = 4;
+    }
+
+
+    switch( pAdapter->SpeedDuplex )
+    {
+    case 1:                             // 10Mb   Half-Duplex
+        pAdapter->AiForceSpeed = 10;
+        pAdapter->AiForceDpx  = 1;
+        break;
+
+    case 2:                             // 10Mb   Full-Duplex
+        pAdapter->AiForceSpeed = 10;
+        pAdapter->AiForceDpx  = 2;
+        break;
+
+    case 3:                             // 100Mb  Half-Duplex
+        pAdapter->AiForceSpeed = 100;
+        pAdapter->AiForceDpx  = 1;
+        break;
+
+    case 4:                             // 100Mb  Full-Duplex
+        pAdapter->AiForceSpeed = 100;
+        pAdapter->AiForceDpx  = 2;
+        break;
+
+    case 5:                             // 1000Mb Full-Duplex
+        pAdapter->AiForceSpeed = 1000;
+        pAdapter->AiForceDpx  = 2;
+        break;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
--- /dev/null
+++ b/drivers/net/et131x/et131x_config.h
@@ -0,0 +1,99 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_config.h - Defines, structs, enums, prototypes, etc. to support
+ *                   et131x_config.c
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:12 $
+     $Revision: 1.4 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET131X_CONFIG_H__
+#define __ET131X_CONFIG_H__
+
+
+
+
+/******************************************************************************
+   Forward declaration of the private adapter structure
+ *****************************************************************************/
+struct et131x_adapter;
+
+
+
+
+/******************************************************************************
+   PROTOTYPES for et131x_config.c
+ *****************************************************************************/
+void et131x_config_parse( struct et131x_adapter *pAdapter );
+
+
+
+
+#endif  /* __ET131X_CONFIG_H__ */
--- /dev/null
+++ b/drivers/net/et131x/et131x_debug.c
@@ -0,0 +1,328 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_debug.c - Routines used for debugging.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:12 $
+     $Revision: 1.6 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#if ET131X_DBG
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+#include <linux/random.h>
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_netdev.h"
+#include "et131x_config.h"
+#include "et131x_isr.h"
+
+#include "ET1310_address_map.h"
+#include "ET1310_jagcore.h"
+#include "ET1310_tx.h"
+#include "ET1310_rx.h"
+#include "ET1310_mac.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+extern dbg_info_t *et131x_dbginfo;
+
+
+
+
+/******************************************************************************
+   ROUTINE:  DumpTxQueueContents
+ ******************************************************************************
+   DESCRIPTION:
+        Used to dump out hte tx queue and the shadow pointers
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter structure
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void DumpTxQueueContents( int dbgLvl, ET131X_ADAPTER *pAdapter )
+{
+    UINT32 TxQueueAddr;
+    /*-----------------------------------------------------------------------*/
+
+
+    if( DBG_FLAGS( et131x_dbginfo ) & dbgLvl )
+    {
+
+        for( TxQueueAddr = 0x200; TxQueueAddr< 0x3ff; TxQueueAddr++ )
+        {
+            pAdapter->CSRAddress->mmc.sram_access.bits.req_addr = TxQueueAddr;
+            pAdapter->CSRAddress->mmc.sram_access.bits.req_access = 1;
+
+
+            DBG_PRINT( "Addr 0x%x, Access 0x%08x\t"
+                    "Value 1 0x%08x, Value 2 0x%08x, "
+                    "Value 3 0x%08x, Value 4 0x%08x, \n",
+                    TxQueueAddr,
+                    pAdapter->CSRAddress->mmc.sram_access.value,
+                    pAdapter->CSRAddress->mmc.sram_word1.data,
+                    pAdapter->CSRAddress->mmc.sram_word2.data,
+                    pAdapter->CSRAddress->mmc.sram_word3.data,
+                    pAdapter->CSRAddress->mmc.sram_word4.data );
+
+        }
+
+        DBG_PRINT( "Shadow Pointers 0x%08x\n",
+                pAdapter->CSRAddress->txmac.shadow_ptr.value );
+    }
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  DumpDeviceBlock
+ ******************************************************************************
+
+   DESCRIPTION:
+        Dumps the first 64 regs of each block of the et-1310 (each block is
+        mapped to a new page, each page is 4096 bytes).
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter
+
+   RETURN     :
+        VOID
+ *****************************************************************************/
+#define NUM_BLOCKS 8
+void DumpDeviceBlock( int dbgLvl, ET131X_ADAPTER *pAdapter, UINT32 Block )
+{
+    UINT32 Address1, Address2;
+    UINT32 *BigDevicePointer = (UINT32 *)pAdapter->CSRAddress;
+    /*-----------------------------------------------------------------------*/
+
+
+    char* BlockNames[NUM_BLOCKS] =
+            {"Global", "Tx DMA", "Rx DMA", "Tx MAC",
+            "Rx MAC", "MAC", "MAC Stat", "MMC" };
+    /*-----------------------------------------------------------------------*/
+
+
+    /**************************************************************************
+       Output the debug counters to the debug terminal
+     *************************************************************************/
+    if( DBG_FLAGS( et131x_dbginfo ) & dbgLvl )
+    {
+        DBG_PRINT( "%s block\n", BlockNames[Block] );
+
+        for( Address1 = 0; Address1 < 8; Address1++ )
+        {
+            for( Address2 = 0; Address2 < 8; Address2++ )
+            {
+                if( Block == 0 )
+                {
+                    if((( Address1 * 8 ) + Address2 ) == 6 )
+                    {
+                        DBG_PRINT( "  ISR    , " );
+                    }
+                    else
+                    {
+                        DBG_PRINT( "0x%08x, ",
+                                BigDevicePointer[( Block * 1024 ) +
+                                                    ( Address1 * 8 ) + Address2] );
+
+                    }
+                }
+                else
+                {
+                    DBG_PRINT( "0x%08x, ",
+                            BigDevicePointer[( Block * 1024 ) +
+                                                ( Address1 * 8 ) + Address2] );
+                }
+            }
+
+            DBG_PRINT( "\n" );
+        }
+
+        DBG_PRINT( "\n" );
+    }
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  DumpDeviceReg
+ ******************************************************************************
+
+   DESCRIPTION:
+        Dumps the first 64 regs of each block of the et-1310 (each block is
+        mapped to a new page, each page is 4096 bytes).
+
+   PARAMETERS :
+        pAdapter - pointer to our adapter
+
+   RETURN     :
+        VOID
+ *****************************************************************************/
+void DumpDeviceReg( int dbgLvl, ET131X_ADAPTER *pAdapter )
+{
+    UINT32  Address1, Address2;
+    UINT32  Block;
+    UINT32 *BigDevicePointer = (UINT32 *)pAdapter->CSRAddress;
+
+    char* BlockNames[NUM_BLOCKS] =
+            {"Global", "Tx DMA", "Rx DMA", "Tx MAC",
+            "Rx MAC", "MAC", "MAC Stat", "MMC" };
+    /*-----------------------------------------------------------------------*/
+
+
+    /**************************************************************************
+       Output the debug counters to the debug terminal
+     *************************************************************************/
+    if( DBG_FLAGS( et131x_dbginfo ) & dbgLvl )
+    {
+        for( Block = 0; Block < NUM_BLOCKS; Block++ )
+        {
+            DBG_PRINT( "%s block\n", BlockNames[Block] );
+
+            for( Address1 = 0; Address1 < 8; Address1++ )
+            {
+                for( Address2 = 0; Address2 < 8; Address2++ )
+                {
+                    DBG_PRINT( "0x%08x, ",
+                            BigDevicePointer[( Block * 1024 ) +
+                            ( Address1 * 8 ) + Address2] );
+                }
+
+                DBG_PRINT( "\n" );
+            }
+
+            DBG_PRINT( "\n" );
+        }
+    }
+
+    return;
+}
+/*==========================================================================*/
+
+
+
+
+#endif // ET131X_DBG
--- /dev/null
+++ b/drivers/net/et131x/et131x_debug.h
@@ -0,0 +1,276 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_debug.h - Defines, structs, enums, prototypes, etc. used for
+ *                  outputting debug messages to the system logging facility
+ *                  (ksyslogd)
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:12 $
+     $Revision: 1.10 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET131X_DBG_H__
+#define __ET131X_DBG_H__
+
+
+
+
+#ifndef ET131X_DBG
+#define ET131X_DBG 0
+#else
+#define ET131X_DBG 1
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   Define Masks for debugging types/levels
+ *****************************************************************************/
+#define DBG_ERROR_ON        0x00000001L
+#define DBG_WARNING_ON      0x00000002L
+#define DBG_NOTICE_ON       0x00000004L
+#define DBG_TRACE_ON        0x00000008L
+#define DBG_VERBOSE_ON      0x00000010L
+#define DBG_PARAM_ON        0x00000020L
+#define DBG_BREAK_ON        0x00000040L
+#define DBG_RX_ON           0x00000100L
+#define DBG_TX_ON           0x00000200L
+
+
+
+
+#if ET131X_DBG
+
+
+/******************************************************************************
+   Set the level of debugging if not done with a preprocessor define. See
+   et131x_main.c, function et131x_init_module() for how the debug level
+   translates into the types of messages displayed.
+ *****************************************************************************/
+#ifndef DBG_LVL
+#define DBG_LVL 3
+#endif  /* DBG_LVL */
+
+
+#define DBG_DEFAULTS        (DBG_ERROR_ON | DBG_WARNING_ON | DBG_BREAK_ON )
+
+#define DBG_FLAGS(A)        (A)->dbgFlags
+#define DBG_NAME(A)         (A)->dbgName
+#define DBG_LEVEL(A)        (A)->dbgLevel
+
+
+#ifndef PRINTK
+#   define PRINTK(S...)     printk(S)
+#endif  /* PRINTK */
+
+
+#ifndef DBG_PRINT
+#   define DBG_PRINT(S...)  PRINTK(KERN_DEBUG S)
+#endif  /* DBG_PRINT */
+
+
+#ifndef DBG_PRINTC
+#   define DBG_PRINTC(S...) PRINTK(S)
+#endif  /* DBG_PRINTC */
+
+
+#ifndef DBG_TRAP
+#   define DBG_TRAP         {} //BUG()
+#endif  /* DBG_TRAP */
+
+
+#define _ENTER_STR          ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
+#define _LEAVE_STR          "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
+
+
+#define _DBG_ENTER(A)       DBG_PRINT("%s:%.*s:%s\n",DBG_NAME(A),++DBG_LEVEL(A),_ENTER_STR,__FUNC__)
+#define _DBG_LEAVE(A)       DBG_PRINT("%s:%.*s:%s\n",DBG_NAME(A),DBG_LEVEL(A)--,_LEAVE_STR,__FUNC__)
+
+
+#define DBG_FUNC(F)         static const char __FUNC__[] = F;
+
+
+#define DBG_ENTER(A)        {if (DBG_FLAGS(A) & DBG_TRACE_ON) \
+                                _DBG_ENTER(A);}
+
+
+#define DBG_LEAVE(A)        {if (DBG_FLAGS(A) & DBG_TRACE_ON) \
+                                _DBG_LEAVE(A);}
+
+
+#define DBG_PARAM(A,N,F,S...)   {if (DBG_FLAGS(A) & DBG_PARAM_ON) \
+                                    DBG_PRINT("  %s -- "F"\n",N,S);}
+
+
+#define DBG_ERROR(A,S...)   {if (DBG_FLAGS(A) & DBG_ERROR_ON) \
+                                {DBG_PRINT("%s:ERROR:%s ",DBG_NAME(A),__FUNC__);DBG_PRINTC(S);DBG_TRAP;}}
+
+
+#define DBG_WARNING(A,S...) {if (DBG_FLAGS(A) & DBG_WARNING_ON) \
+                                {DBG_PRINT("%s:WARNING:%s ",DBG_NAME(A),__FUNC__);DBG_PRINTC(S);}}
+
+
+#define DBG_NOTICE(A,S...)  {if (DBG_FLAGS(A) & DBG_NOTICE_ON) \
+                                {DBG_PRINT("%s:NOTICE:%s ",DBG_NAME(A),__FUNC__);DBG_PRINTC(S);}}
+
+
+#define DBG_TRACE(A,S...)   {if (DBG_FLAGS(A) & DBG_TRACE_ON) \
+                                {DBG_PRINT("%s:TRACE:%s ",DBG_NAME(A),__FUNC__);DBG_PRINTC(S);}}
+
+#define DBG_VERBOSE(A,S...) {if (DBG_FLAGS(A) & DBG_VERBOSE_ON) \
+                                {DBG_PRINT("%s:VERBOSE:%s ",DBG_NAME(A),__FUNC__);DBG_PRINTC(S);}}
+
+
+#define DBG_RX(A,S...)      {if (DBG_FLAGS(A) & DBG_RX_ON) \
+                                {DBG_PRINT(S);}}
+
+#define DBG_RX_ENTER(A)     {if (DBG_FLAGS(A) & DBG_RX_ON) \
+                                _DBG_ENTER(A);}
+
+#define DBG_RX_LEAVE(A)     {if (DBG_FLAGS(A) & DBG_RX_ON) \
+                                _DBG_LEAVE(A);}
+
+#define DBG_TX(A,S...)      {if (DBG_FLAGS(A) & DBG_TX_ON) \
+                                {DBG_PRINT(S);}}
+
+#define DBG_TX_ENTER(A)     {if (DBG_FLAGS(A) & DBG_TX_ON) \
+                                _DBG_ENTER(A);}
+
+#define DBG_TX_LEAVE(A)     {if (DBG_FLAGS(A) & DBG_TX_ON) \
+                                _DBG_LEAVE(A);}
+
+
+#define DBG_ASSERT(C)       {if (!(C)) \
+                                {DBG_PRINT("ASSERT(%s) -- %s#%d (%s)\n", \
+                                    #C,__FILE__,__LINE__,__FUNC__); \
+                                DBG_TRAP;}}
+#define STATIC
+
+
+typedef struct
+{
+    char           *dbgName;
+    int             dbgLevel;
+    unsigned long   dbgFlags;
+} dbg_info_t;
+
+
+
+
+#else   /* ET131X_DBG */
+
+
+
+
+#define DBG_DEFN
+#define DBG_TRAP
+#define DBG_FUNC(F)
+#define DBG_PRINT(S...)
+#define DBG_ENTER(A)
+#define DBG_LEAVE(A)
+#define DBG_PARAM(A,N,F,S...)
+#define DBG_ERROR(A,S...)
+#define DBG_WARNING(A,S...)
+#define DBG_NOTICE(A,S...)
+#define DBG_TRACE(A,S...)
+#define DBG_VERBOSE(A,S...)
+#define DBG_RX(A,S...)
+#define DBG_RX_ENTER(A)
+#define DBG_RX_LEAVE(A)
+#define DBG_TX(A,S...)
+#define DBG_TX_ENTER(A)
+#define DBG_TX_LEAVE(A)
+#define DBG_ASSERT(C)
+#define STATIC static
+
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   Forward declaration of the private adapter structure
+ *****************************************************************************/
+struct et131x_adapter;
+
+
+
+
+/******************************************************************************
+   PROTOTYPES for et131x_debug.c
+ *****************************************************************************/
+void DumpTxQueueContents( int dbgLvl, struct et131x_adapter *pAdapter );
+void DumpDeviceBlock( int dbgLvl, struct et131x_adapter *pAdapter, unsigned int Block );
+void DumpDeviceReg( int dbgLvl, struct et131x_adapter *pAdapter );
+
+
+
+
+#endif  /* __ET131X_DBG_H__ */
--- /dev/null
+++ b/drivers/net/et131x/et131x_defs.h
@@ -0,0 +1,206 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_defs.h - Defines, structs, enums, prototypes, etc. to assist with OS
+ *                 compatibility
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/10/28 18:43:46 $
+     $Revision: 1.8 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET131X_DEFS_H__
+#define __ET131X_DEFS_H__
+
+
+
+
+/******************************************************************************
+   Define a boolean type
+ *****************************************************************************/
+typedef enum { FALSE, TRUE } __attribute__ ((packed)) BOOL_t;
+
+
+
+
+/******************************************************************************
+   Packet and header sizes
+ *****************************************************************************/
+#define NIC_MIN_PACKET_SIZE             60
+#define NIC_HEADER_SIZE                 ETH_HLEN    //14
+
+
+
+
+/******************************************************************************
+   Multicast list size
+ *****************************************************************************/
+#define NIC_MAX_MCAST_LIST              128
+
+
+
+
+/******************************************************************************
+   Supported Filters
+ *****************************************************************************/
+#define ET131X_PACKET_TYPE_DIRECTED      0x0001
+#define ET131X_PACKET_TYPE_MULTICAST     0x0002
+#define ET131X_PACKET_TYPE_BROADCAST     0x0004
+#define ET131X_PACKET_TYPE_PROMISCUOUS   0x0008
+#define ET131X_PACKET_TYPE_ALL_MULTICAST 0x0010
+
+
+
+
+/******************************************************************************
+   Tx Timeout
+ *****************************************************************************/
+#define ET131X_TX_TIMEOUT       (1 * HZ)
+#define NIC_SEND_HANG_THRESHOLD 0
+
+
+
+
+/******************************************************************************
+   MP_TCB flags
+ *****************************************************************************/
+#define fMP_DEST_MULTI                          0x00000001
+#define fMP_DEST_BROAD                          0x00000002
+
+
+
+
+/******************************************************************************
+   MP_ADAPTER flags
+ *****************************************************************************/
+#define fMP_ADAPTER_RECV_LOOKASIDE              0x00000004
+#define fMP_ADAPTER_INTERRUPT_IN_USE            0x00000008
+#define fMP_ADAPTER_SECONDARY                   0x00000010
+
+
+
+
+/******************************************************************************
+   MP_SHARED flags
+ *****************************************************************************/
+#define fMP_ADAPTER_SHUTDOWN                    0x00100000
+#define fMP_ADAPTER_LOWER_POWER                 0x00200000
+
+#define fMP_ADAPTER_NON_RECOVER_ERROR           0x00800000
+#define fMP_ADAPTER_RESET_IN_PROGRESS           0x01000000
+#define fMP_ADAPTER_NO_CABLE                    0x02000000
+#define fMP_ADAPTER_HARDWARE_ERROR              0x04000000
+#define fMP_ADAPTER_REMOVE_IN_PROGRESS          0x08000000
+#define fMP_ADAPTER_HALT_IN_PROGRESS            0x10000000
+#define fMP_ADAPTER_LINK_DETECTION              0x20000000
+
+#define fMP_ADAPTER_FAIL_SEND_MASK              0x3ff00000
+#define fMP_ADAPTER_NOT_READY_MASK              0x3ff00000
+
+
+
+
+/******************************************************************************
+   Some offsets in PCI config space that are actually used.
+ *****************************************************************************/
+#define ET1310_PCI_PM_CAPABILITY    (UINT32)0x40
+#define ET1310_PCI_PM_CSR           (UINT32)0x44
+#define ET1310_PCI_MAX_PYLD         (UINT32)0x4C
+#define ET1310_PCI_DEV_CTRL         (UINT32)0x50
+#define ET1310_PCI_DEV_STAT         (UINT32)0x52
+#define ET1310_NMI_DISABLE          (UINT32)0x61
+#define ET1310_PCI_MAC_ADDRESS      (UINT32)0xA4
+#define ET1310_PCI_EEPROM_STATUS    (UINT32)0xB2
+#define ET1310_PCI_PHY_INDEX_REG    (UINT32)0xB4
+#define ET1310_PCI_ACK_NACK         (UINT32)0xC0
+#define ET1310_PCI_REPLAY           (UINT32)0xC2
+#define ET1310_PCI_L0L1LATENCY      (UINT32)0xCF
+#define ET1310_PCI_SEL_PHY_CTRL     (UINT32)0xE4
+#define ET1310_PCI_ADVANCED_ERR     (UINT32)0x100
+
+
+
+
+/******************************************************************************
+   PCI Vendor/Product IDs
+ *****************************************************************************/
+#define ET131X_PCI_VENDOR_ID      0x11C1  // Agere Systems
+#define ET131X_PCI_DEVICE_ID_GIG  0xED00  // ET1310 1000 Base-T
+#define ET131X_PCI_DEVICE_ID_FAST 0xED01  // ET1310 100  Base-T
+
+/******************************************************************************
+   Handle name change of some regsiter bits
+ *****************************************************************************/
+#define phy_sw_coma     pm_phy_sw_coma
+
+/******************************************************************************
+   Define order of magnitude converter
+ *****************************************************************************/
+#define NANO_IN_A_MICRO 1000
+
+#endif  /* __ET131X_DEFS_H__ */
--- /dev/null
+++ b/drivers/net/et131x/et131x_initpci.c
@@ -0,0 +1,1836 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_initpci.c - Routines and data used to register the driver with the
+ *                    PCI (and PCI Express) subsystem, as well as basic driver
+ *                    init and startup.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2006/01/25 20:48:56 $
+     $Revision: 1.22 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+#include <linux/random.h>
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#include <linux/if_vlan.h>
+#endif
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_netdev.h"
+#include "et131x_config.h"
+#include "et131x_isr.h"
+
+#include "ET1310_address_map.h"
+#include "ET1310_jagcore.h"
+#include "ET1310_tx.h"
+#include "ET1310_rx.h"
+#include "ET1310_mac.h"
+#include "ET1310_eeprom.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   Prototypes for functions with local scope
+ *****************************************************************************/
+int __devinit et131x_pci_probe( struct pci_dev *pdev,
+                                const struct pci_device_id *ent );
+
+void __devexit et131x_pci_remove( struct pci_dev *pdev );
+
+int et131x_pci_setup( struct pci_dev *pdev );
+
+
+
+
+/******************************************************************************
+   Data for PCI registration
+ *****************************************************************************/
+enum et131x_pci_versions
+{
+    Agere_Systems_PCI_V1 = 0,
+};
+
+
+static struct pci_device_id et131x_pci_table[] __devinitdata =
+{
+    { ET131X_PCI_VENDOR_ID, ET131X_PCI_DEVICE_ID_GIG, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+    { ET131X_PCI_VENDOR_ID, ET131X_PCI_DEVICE_ID_FAST, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+    { 0, }
+};
+
+MODULE_DEVICE_TABLE( pci, et131x_pci_table );
+
+
+static struct pci_driver et131x_driver =
+{
+    name:       DRIVER_NAME,
+    id_table:   et131x_pci_table,
+    probe:      et131x_pci_probe,
+    remove:     __devexit_p( et131x_pci_remove ),
+    suspend:    NULL, //et131x_pci_suspend,
+    resume:     NULL, //et131x_pci_resume,
+};
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_find_adapter
+ ******************************************************************************
+
+   DESCRIPTION       : Find the adapter and get all the assigned resources
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_find_adapter( ET131X_ADAPTER *adapter, struct pci_dev *pdev )
+{
+    int    result;
+    UCHAR  eepromStat         = 0;
+    UCHAR  maxPayload         = 0;
+    UCHAR  latencyTimers      = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_find_adapter" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+        Allow disabling of Non-Maskable Interrupts in I/O space, to
+        support validation.
+     *************************************************************************/
+    if( adapter->RegistryNMIDisable )
+    {
+        UCHAR RegisterVal;
+
+        RegisterVal  = inb( ET1310_NMI_DISABLE );
+        RegisterVal &= 0xf3;
+
+        if( adapter->RegistryNMIDisable == 2 )
+        {
+            RegisterVal |= 0xc;
+        }
+
+        outb( ET1310_NMI_DISABLE, RegisterVal );
+    }
+
+
+    /**************************************************************************
+       We first need to check the EEPROM Status code located at offset 0xB2
+       of config space
+     *************************************************************************/
+
+    result = pci_slot_information_read( pdev,
+                                        ET1310_PCI_EEPROM_STATUS,
+                                        &eepromStat,
+                                        sizeof( UCHAR ));
+    /*************************************************************************
+       THIS IS A WORKAROUND:
+ 	 * I need to call this function twice to get my card in a
+	   LG M1 Express Dual running. I tried also a msleep before this
+	   function, because I thougth there could be some time condidions
+	   but it didn't work. Call the whole function twice also work.
+     *************************************************************************/
+    result = pci_slot_information_read( pdev,
+                                        ET1310_PCI_EEPROM_STATUS,
+                                        &eepromStat,
+                                        sizeof( UCHAR ));
+
+    if( result != sizeof( UCHAR ))
+    {
+        DBG_ERROR( et131x_dbginfo, "Could not read PCI config space for "
+                                   "EEPROM Status\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -EIO;
+    }
+
+
+    /**************************************************************************
+       Determine if the error(s) we care about are present.  If they are
+       present, we need to fail.
+     *************************************************************************/
+    if( eepromStat & 0x4C )
+    {
+        result = pci_slot_information_read( pdev,
+                                            PCI_REVISION_ID,
+                                            &adapter->RevisionID,
+                                            sizeof( UCHAR ));
+        if( result != sizeof( UCHAR ))
+        {
+            DBG_ERROR( et131x_dbginfo,
+                        "Could not read PCI config space for "
+                        "Revision ID\n" );
+            DBG_LEAVE( et131x_dbginfo );
+            return -EIO;
+        }
+        else if( adapter->RevisionID == 0x01 )
+        {
+            INT32   nLoop;
+            UCHAR   ucTemp[4] = {0xFE, 0x13, 0x10, 0xFF};
+
+            /******************************************************************
+               Re-write the first 4 bytes if we have an eeprom present and
+               the revision id is 1, this fixes the corruption seen with
+               1310 B Silicon
+             *****************************************************************/
+			for( nLoop = 0; nLoop < 3; nLoop++ )
+			{
+                EepromWriteByte( adapter, nLoop, ucTemp[nLoop], 0, SINGLE_BYTE );
+			}
+        }
+
+        DBG_ERROR( et131x_dbginfo, "Fatal EEPROM Status Error - 0x%04x\n",
+                   eepromStat );
+
+        /**********************************************************************
+           This error could mean that there was an error reading the eeprom
+           or that the eeprom doesn't exist.  We will treat each case the
+           same and not try to gather additional information that normally
+           would come from the eeprom, like MAC Address
+         *********************************************************************/
+        adapter->bEepromPresent = FALSE;
+
+        DBG_LEAVE( et131x_dbginfo );
+        return -EIO;
+    }
+    else
+    {
+        DBG_TRACE( et131x_dbginfo, "EEPROM Status Code - 0x%04x\n", eepromStat );
+        adapter->bEepromPresent = TRUE;
+    }
+
+
+    /**************************************************************************
+       Read the EEPROM for information regarding LED behavior. Refer to
+       ET1310_phy.c, et131x_xcvr_init(), for its use.
+     *************************************************************************/
+    EepromReadByte( adapter, 0x70, &adapter->eepromData [0], 0, SINGLE_BYTE );
+    EepromReadByte( adapter, 0x71, &adapter->eepromData [1], 0, SINGLE_BYTE );
+
+    if( adapter->eepromData[0] != 0xcd )
+    {
+        adapter->eepromData[1] = 0x00;  // Disable all optional features
+    }
+
+
+    /**************************************************************************
+       Let's set up the PORT LOGIC Register.  First we need to know what the
+       max_payload_size is
+     *************************************************************************/
+    result = pci_slot_information_read( pdev,
+                                        ET1310_PCI_MAX_PYLD,
+                                        &maxPayload,
+                                        sizeof( UCHAR ));
+
+    if( result != sizeof( UCHAR ))
+    {
+        DBG_ERROR( et131x_dbginfo, "Could not read PCI config space for "
+                                   "Max Payload Size\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -EIO;
+    }
+    else
+    {
+        UINT16 AckNak [2] = {0x76,  0xD0};
+        UINT16 Replay [2] = {0x1E0, 0x2ED};
+
+
+        /**********************************************************************
+           Program the Ack/Nak latency and replay timers
+         *********************************************************************/
+        maxPayload &= 0x07;     // Only the lower 3 bits are valid
+
+        if( maxPayload < 2 )
+        {
+            result = pci_slot_information_write( pdev,
+                                                 ET1310_PCI_ACK_NACK,
+                                                 (UINT8 *)&AckNak[maxPayload],
+                                                 sizeof( UINT16 ));
+            if( result != sizeof( UINT16 ))
+            {
+                DBG_ERROR( et131x_dbginfo, "Could not write PCI config space "
+                                           "for ACK/NAK\n" );
+                DBG_LEAVE( et131x_dbginfo );
+                return -EIO;
+            }
+
+            result = pci_slot_information_write( pdev,
+                                                 ET1310_PCI_REPLAY,
+                                                 (UINT8 *)&Replay[maxPayload],
+                                                 sizeof( UINT16 ));
+            if( result != sizeof( UINT16 ))
+            {
+                DBG_ERROR( et131x_dbginfo, "Could not write PCI config space "
+                                           "for Replay Timer\n" );
+                DBG_LEAVE( et131x_dbginfo );
+                return -EIO;
+            }
+        }
+    }
+
+
+    /**************************************************************************
+       l0s and l1 latency timers.  We are using default values.
+     *************************************************************************/
+    latencyTimers = 0x11;   // Representing 001 for L0s and 010 for L1
+
+    result = pci_slot_information_write( pdev,
+                                         ET1310_PCI_L0L1LATENCY,
+                                         (UINT8 *)&latencyTimers,
+                                         sizeof( UCHAR ));
+    if( result != sizeof( UCHAR ))
+    {
+        DBG_ERROR( et131x_dbginfo, "Could not write PCI config space for "
+                                   "Latency Timers\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -EIO;
+    }
+
+
+    /**************************************************************************
+       Archive Power management capability values for later use
+     *************************************************************************/
+    result = pci_slot_information_read( pdev,
+                                        ET1310_PCI_PM_CAPABILITY,
+                                        (UINT8 *)&adapter->PoMgmt.pmConfigRegs,
+                                        sizeof( MP_PM_CONFIG_SPACE_INFO_t ));
+    if( result != sizeof( MP_PM_CONFIG_SPACE_INFO_t ))
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not read PCI config space for PM Capability\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -EIO;
+    }
+    else
+    {
+        UCHAR read_size_reg;
+
+        /******************************************************************
+           Change the max read size to 2k
+         *****************************************************************/
+        result = pci_slot_information_read( pdev,
+                                            0x51,
+                                            (void *)&read_size_reg,
+                                            sizeof( UCHAR ));
+
+        if( result != sizeof( UCHAR ))
+        {
+            DBG_ERROR( et131x_dbginfo,
+                       "Could not read PCI config space for Max read size\n" );
+            DBG_LEAVE( et131x_dbginfo );
+            return -EIO;
+        }
+
+        read_size_reg &= 0x8f;
+        read_size_reg |= 0x40;
+
+        result = pci_slot_information_write( pdev,
+                                             0x51,
+                                             &read_size_reg,
+                                             sizeof( UCHAR ));
+        if( result != sizeof( UCHAR ))
+        {
+            DBG_ERROR( et131x_dbginfo,
+                       "Could not write PCI config space for Max read size\n" );
+            DBG_LEAVE( et131x_dbginfo );
+            return -EIO;
+        }
+    }
+
+
+    /**************************************************************************
+       PCI Express Configuration registers 0x48-0x5B (Device Control)
+     *************************************************************************/
+    result = pci_slot_information_read( pdev,
+                                        ET1310_PCI_DEV_CTRL,
+                                        (UINT8 *)&adapter->PciXDevCtl,
+                                        sizeof( UINT16 ));
+
+    if( result != sizeof( UINT16 ))
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not read PCI config space for PCI Express Dev Ctl\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -EIO;
+    }
+
+
+    /**************************************************************************
+       Get MAC address from config space if an eeprom exists, otherwise the
+       MAC address there will not be valid
+     *************************************************************************/
+    if( adapter->bEepromPresent )
+    {
+        result = pci_slot_information_read( pdev,
+                                            ET1310_PCI_MAC_ADDRESS,
+                                            (UINT8 *)adapter->PermanentAddress,
+                                            ETH_ALEN );
+        if( result != ETH_ALEN )
+        {
+            DBG_ERROR( et131x_dbginfo,
+                       "Could not read PCI config space for MAC address\n" );
+            DBG_LEAVE( et131x_dbginfo );
+            return -EIO;
+        }
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_error_timer_handler
+ ******************************************************************************
+
+   DESCRIPTION       : The routine called when the error timer expires, to
+                       track the number of recurring errors.
+
+   PARAMETERS        : data - a timer-specific variable; in this case, a
+                              pointer to our private adapter structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_error_timer_handler( unsigned long data )
+{
+    ET131X_ADAPTER  *pAdapter = (ET131X_ADAPTER *)data;
+    PM_CSR_t        pm_csr;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_error_timer_handler" );
+
+
+    pm_csr = pAdapter->CSRAddress->global.pm_csr;
+
+    if( pm_csr.bits.pm_phy_sw_coma == 0 )
+    {
+        if( pAdapter->RegistryMACStat )
+        {
+            UpdateMacStatHostCounters( pAdapter );
+        }
+    }
+    else
+    {
+        DBG_VERBOSE( et131x_dbginfo,
+                     "No interrupts, in PHY coma, pm_csr = 0x%x\n",
+                     pm_csr.value );
+    }
+
+
+    if( !pAdapter->Bmsr.bits.link_status &&
+         pAdapter->RegistryPhyComa &&
+         pAdapter->PoMgmt.TransPhyComaModeOnBoot < 11 )
+    {
+        pAdapter->PoMgmt.TransPhyComaModeOnBoot++;
+    }
+
+    if( pAdapter->PoMgmt.TransPhyComaModeOnBoot == 10 )
+    {
+        if( !pAdapter->Bmsr.bits.link_status && pAdapter->RegistryPhyComa )
+        {
+            if( pAdapter->CSRAddress->global.pm_csr.bits.phy_sw_coma == 0 )
+            {
+                // NOTE - This was originally a 'sync with interrupt'. How
+                //        to do that under Linux?
+                et131x_enable_interrupts( pAdapter );
+                EnablePhyComa( pAdapter );
+            }
+        }
+    }
+
+
+    /**************************************************************************
+       This is a periodic timer, so reschedule
+     *************************************************************************/
+    mod_timer( &pAdapter->ErrorTimer, jiffies + 30*HZ );
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE:  et131x_link_detection_handler
+ ******************************************************************************
+   DESCRIPTION:
+        Timer function for handling link up at driver load time
+
+   PARAMETERS :
+        SystemSpecific1     Not used
+        FunctionContext     Pointer to our adapter
+        SystemSpecific2     Not used
+        SystemSpecific3     Not used
+
+   RETURNS    :
+        NONE
+
+ *****************************************************************************/
+void et131x_link_detection_handler( unsigned long data )
+{
+    ET131X_ADAPTER *pAdapter   = (ET131X_ADAPTER *)data;
+    unsigned long   lockflags;
+    /*-----------------------------------------------------------------------*/
+
+
+    /**************************************************************************
+       Let everyone know that we have run
+     *************************************************************************/
+    pAdapter->bLinkTimerActive = FALSE;
+
+    if( pAdapter->MediaState == 0 )
+    {
+        spin_lock_irqsave( &pAdapter->Lock, lockflags );
+
+        pAdapter->MediaState = NETIF_STATUS_MEDIA_DISCONNECT;
+        MP_CLEAR_FLAG( pAdapter, fMP_ADAPTER_LINK_DETECTION );
+
+        spin_unlock_irqrestore( &pAdapter->Lock, lockflags );
+
+        netif_indicate_status( pAdapter->netdev, pAdapter->MediaState );
+
+        if( pAdapter->bSetPending )
+        {
+            pAdapter->bSetPending = FALSE;
+        }
+    }
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_adapter_setup
+ ******************************************************************************
+
+   DESCRIPTION       : Used to set the adapter up as per cassini+ documentation
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_adapter_setup( ET131X_ADAPTER *pAdapter )
+{
+    int   status = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_adapter_setup" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Configure the JAGCore
+     *************************************************************************/
+    ConfigGlobalRegs( pAdapter );
+
+    ConfigMACRegs1( pAdapter );
+    ConfigMMCRegs( pAdapter );
+
+    ConfigRxMacRegs( pAdapter );
+    ConfigTxMacRegs( pAdapter );
+
+    ConfigRxDmaRegs( pAdapter );
+    ConfigTxDmaRegs( pAdapter );
+
+    ConfigMacStatRegs( pAdapter );
+
+
+    /**************************************************************************
+       Move the following code to Timer function??
+     *************************************************************************/
+    status = et131x_xcvr_find( pAdapter );
+
+    if( status != 0 )
+    {
+        DBG_WARNING( et131x_dbginfo, "Could not find the xcvr\n" );
+    }
+
+
+    /**********************************************************************
+        Prepare the TRUEPHY library.
+     *********************************************************************/
+    ET1310_PhyInit( pAdapter );
+
+
+    /**************************************************************************
+        Reset the phy now so changes take place
+     *************************************************************************/
+    ET1310_PhyReset( pAdapter );
+
+
+    /**************************************************************************
+       Power down PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 1 );
+
+
+    /**************************************************************************
+        We need to turn off 1000 base half dulplex, the mac does not
+        support it
+        For the 10/100 part, turn off all gig advertisement
+     *************************************************************************/
+    if( pAdapter->DeviceID != ET131X_PCI_DEVICE_ID_FAST )
+    {
+        ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_FULL );
+    }
+    else
+    {
+        ET1310_PhyAdvertise1000BaseT( pAdapter, TRUEPHY_ADV_DUPLEX_NONE );
+    }
+
+
+    /**************************************************************************
+       Power up PHY
+     *************************************************************************/
+    ET1310_PhyPowerDown( pAdapter, 0 );
+
+    et131x_setphy_normal( pAdapter );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_setup_hardware_properties
+ ******************************************************************************
+
+   DESCRIPTION       : Used to set up the MAC Address on the ET1310
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_setup_hardware_properties( ET131X_ADAPTER *adapter )
+{
+    DBG_FUNC( "et131x_setup_hardware_properties" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       If have our default mac from registry and no mac address from EEPROM
+       then we need to generate the last octet and set it on the device
+     *************************************************************************/
+    if( !adapter->bOverrideAddress )
+    {
+        if (adapter->PermanentAddress[0] == 0x00 &&
+            adapter->PermanentAddress[1] == 0x00 &&
+            adapter->PermanentAddress[2] == 0x00 &&
+            adapter->PermanentAddress[3] == 0x00 &&
+            adapter->PermanentAddress[4] == 0x00 &&
+            adapter->PermanentAddress[5] == 0x00 )
+        {
+            /******************************************************************
+                We need to randomly generate the last octet so we decrease our
+                chances of setting the mac address to same as another one of
+                our cards in the system
+             *****************************************************************/
+            get_random_bytes( &adapter->CurrentAddress[5], 1 );
+
+
+            /******************************************************************
+                We have the default value in the register we are working with
+                so we need to copy the current address into the permanent
+                address
+             *****************************************************************/
+            memcpy( adapter->PermanentAddress,
+                    adapter->CurrentAddress,
+                    ETH_ALEN );
+        }
+        else
+        {
+            /******************************************************************
+                We do not have an override address, so set the current address
+                to the permanent address and add it to the device
+             *****************************************************************/
+            memcpy( adapter->CurrentAddress,
+                    adapter->PermanentAddress,
+                    ETH_ALEN );
+        }
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_soft_reset
+ ******************************************************************************
+
+   DESCRIPTION       : Issue a soft reset to the hardware, complete for ET1310.
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_soft_reset( ET131X_ADAPTER *adapter )
+{
+    DBG_FUNC( "et131x_soft_reset" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Disable MAC Core
+     *************************************************************************/
+    adapter->CSRAddress->mac.cfg1.value = 0xc00f0000;
+
+
+    /**************************************************************************
+       Set everything to a reset value
+     *************************************************************************/
+    adapter->CSRAddress->global.sw_reset.value = 0x7F;
+    adapter->CSRAddress->mac.cfg1.value        = 0x000f0000;
+    adapter->CSRAddress->mac.cfg1.value        = 0x00000000;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_align_allocated_memory
+ ******************************************************************************
+
+   DESCRIPTION       : Align an allocated block of memory on a given boundary
+
+   PARAMETERS        : adapter   - pointer to our adapter structure
+                       phys_addr - pointer to Physical address
+                       offset    - pointer to the offset variable
+                       mask      - correct mask
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_align_allocated_memory( ET131X_ADAPTER *adapter,
+                                    UINT64         *phys_addr,
+                                    UINT64         *offset,
+                                    UINT64          mask )
+{
+    UINT64 new_addr;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_align_allocated_memory" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    *offset = 0;
+
+    new_addr = *phys_addr & ~mask;
+
+    if( new_addr != *phys_addr )
+    {
+        new_addr  += mask+1;                 // Move to next aligned block
+        *offset    = new_addr - *phys_addr;  // Return offset for adjusting virt addr
+        *phys_addr = new_addr;               // Return new physical address
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_adapter_memory_alloc
+ ******************************************************************************
+
+   DESCRIPTION       : Allocate all the memory blocks for send, receive and
+                       others.
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_adapter_memory_alloc( ET131X_ADAPTER *adapter )
+{
+    int status    = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_adapter_memory_alloc" );
+    DBG_ENTER( et131x_dbginfo );
+
+    do
+    {
+        /**********************************************************************
+           Allocate memory for the Tx Ring
+         *********************************************************************/
+        status = et131x_tx_dma_memory_alloc( adapter );
+        if( status != 0 )
+        {
+            DBG_ERROR( et131x_dbginfo, "et131x_tx_dma_memory_alloc FAILED\n" );
+            break;
+        }
+
+
+        /**********************************************************************
+           Receive buffer memory allocation
+         *********************************************************************/
+        status = et131x_rx_dma_memory_alloc( adapter );
+        if( status != 0 )
+        {
+            DBG_ERROR( et131x_dbginfo, "et131x_rx_dma_memory_alloc FAILED\n" );
+            et131x_tx_dma_memory_free( adapter );
+            break;
+        }
+
+
+        /**********************************************************************
+           Init receive data structures
+         *********************************************************************/
+        status = et131x_init_recv( adapter );
+        if( status != 0 )
+        {
+            DBG_ERROR( et131x_dbginfo, "et131x_init_recv FAILED\n" );
+            et131x_tx_dma_memory_free( adapter );
+            et131x_rx_dma_memory_free( adapter );
+            break;
+        }
+    } while( 0 );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_adapter_memory_free
+ ******************************************************************************
+
+   DESCRIPTION       : Free all memory allocated for use by Tx & Rx code
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_adapter_memory_free( ET131X_ADAPTER *adapter )
+{
+    DBG_FUNC( "et131x_adapter_memory_free" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Free DMA memory
+     *************************************************************************/
+    et131x_tx_dma_memory_free( adapter );
+    et131x_rx_dma_memory_free( adapter );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_pci_register
+ ******************************************************************************
+
+   DESCRIPTION       : This function uses the above data to regsiter the PCI
+                       function table and PCI Vendor/Product ID(s) with the PCI
+                       subsystem to match corresponding devices to this driver.
+
+   PARAMETERS        : N/A
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_pci_register( void )
+{
+    int result;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_pci_register" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    result = pci_register_driver( &et131x_driver );
+    DBG_TRACE( et131x_dbginfo,
+               " pci_register_driver( ) returns %d \n",
+               result );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return result;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_pci_cleanup
+ ******************************************************************************
+
+   DESCRIPTION       : This function deregisters the PCI function table and
+                       related PCI Vendor/Product ID(s) with the PCI subsytem.
+
+   PARAMETERS        : N/A
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_pci_unregister( void )
+{
+    DBG_FUNC( "et131x_pci_unregister" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    pci_unregister_driver( &et131x_driver );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_pci_probe
+ ******************************************************************************
+
+   DESCRIPTION       : Registered in the pci_driver structure, this function is
+                       called when the PCI subsystem finds a new PCI device
+                       which matches the information contained in the
+                       pci_device_id table. This routine is the equivalent to
+                       a device insertion routine.
+
+   PARAMETERS        : pdev - a pointer to the device's pci_dev structure
+                       ent  - this device's entry in the pci_device_id table
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int __devinit et131x_pci_probe( struct pci_dev *pdev,
+                            const struct pci_device_id *ent )
+{
+    int result;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_pci_probe" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    result = et131x_pci_setup( pdev );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_pci_remove
+ ******************************************************************************
+
+   DESCRIPTION       : Registered in the pci_driver structure, this function is
+                       called when the PCI subsystem detects that a PCI device
+                       which matches the information contained in the
+                       pci_device_id table has been removed.
+
+   PARAMETERS        : pdev - a pointer to the device's pci_dev structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void __devexit et131x_pci_remove( struct pci_dev *pdev )
+{
+    struct net_device *netdev = NULL;
+    ET131X_ADAPTER    *adapter = NULL;
+    BOOL_t             bar_workaround;
+    unsigned long      bar_addr_orig = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_pci_remove" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Make sure the pci_dev pointer is valid
+     *************************************************************************/
+    if( pdev == NULL )
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "PCI subsys passed in an invalid pci_dev pointer\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return;
+    }
+
+
+    /**************************************************************************
+       Retrieve the net_device pointer from the pci_dev struct, as well as the
+       private adapter struct
+     *************************************************************************/
+    netdev = (struct net_device *)pci_get_drvdata( pdev );
+    if( netdev == NULL )
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not retrieve net_device struct\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return;
+    }
+
+    adapter = netdev_priv( netdev );
+    if( adapter == NULL )
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not retrieve private adapter struct\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return;
+    }
+
+
+    /**************************************************************************
+       Retrieve config space workaround info before deleting the private
+       adapter struct
+     *************************************************************************/
+    bar_workaround = adapter->pci_bar_workaround;
+    bar_addr_orig  = adapter->pci_bar_addr_orig;
+
+
+    /**************************************************************************
+       Perform device cleanup
+     *************************************************************************/
+    unregister_netdev( netdev );
+    et131x_adapter_memory_free( adapter );
+    iounmap( (void *)adapter->CSRAddress );
+    et131x_device_free( netdev );
+
+    if( bar_workaround == FALSE )
+    {
+        pci_release_regions( pdev );
+    }
+    else
+    {
+        pdev->resource[0].start = bar_addr_orig;
+    }
+
+    pci_disable_device( pdev );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_pci_setup
+ ******************************************************************************
+
+   DESCRIPTION       : Called by et131x_pci_probe() to perform device
+                       initialization.
+
+   PARAMETERS        : pdev - a pointer to the device's pci_dev structure
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_pci_setup( struct pci_dev *pdev )
+{
+    int                result = 0;
+    int                pm_cap;
+    BOOL_t             pci_using_dac;
+    unsigned long      et131x_reg_base;
+    unsigned long      et131x_reg_len;
+    struct net_device *netdev = NULL;
+    ET131X_ADAPTER    *adapter = NULL;
+    BOOL_t             bar_workaround = FALSE;
+    unsigned long      bar_addr_orig = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_pci_setup" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Make sure the device pointer is valid
+     *************************************************************************/
+    if( pdev == NULL )
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "PCI subsys passed in an invalid pci_dev pointer\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENODEV;
+    }
+
+
+    /**************************************************************************
+       On some systems, the base address for a PCI device's config space which
+       is stored in the pci_dev structure is incorrect and different from
+       what's actually in the config space. If they're different, workaround
+       the issue by correcting the address.
+     *************************************************************************/
+    pci_read_config_dword( pdev, PCI_BASE_ADDRESS_0, (u32 *)&et131x_reg_base );
+    et131x_reg_base &= ~0x07;
+
+    if( (u32)pdev->resource[0].start != (u32)et131x_reg_base )
+    {
+        DBG_WARNING( et131x_dbginfo, "PCI CONFIG SPACE WORKAROUND REQUIRED\n" );
+        DBG_WARNING( et131x_dbginfo, "pdev->resource[0].start : 0x%08x\n",
+                     (unsigned int)pdev->resource[0].start );
+        DBG_WARNING( et131x_dbginfo, "et131x_reg_base         : 0x%08x\n",
+                     (unsigned int)et131x_reg_base );
+        bar_workaround = TRUE;
+        bar_addr_orig  = pdev->resource[0].start;
+        pdev->resource[0].start = et131x_reg_base;
+    }
+
+
+    /**************************************************************************
+       Enable the device via the PCI subsystem
+     *************************************************************************/
+    result = pci_enable_device( pdev );
+    if( result != 0 )
+    {
+        if( bar_workaround )
+        {
+            pdev->resource[0].start = bar_addr_orig;
+        }
+
+        DBG_ERROR( et131x_dbginfo, "pci_enable_device() failed\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return result;
+    }
+
+
+    /**************************************************************************
+       Perform some basic PCI checks
+     *************************************************************************/
+    if( !( pci_resource_flags( pdev, 0 ) & IORESOURCE_MEM ))
+    {
+        if( bar_workaround )
+        {
+            pdev->resource[0].start = bar_addr_orig;
+        }
+
+        DBG_ERROR( et131x_dbginfo,
+                   "Can't find PCI device's base address\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENODEV;
+    }
+
+    if( bar_workaround == FALSE )
+    {
+        result = pci_request_regions( pdev, DRIVER_NAME );
+        if( result != 0 )
+        {
+            DBG_ERROR( et131x_dbginfo,
+                       "Can't get PCI resources\n" );
+
+            pci_disable_device( pdev );
+
+            DBG_LEAVE( et131x_dbginfo );
+            return result;
+        }
+    }
+
+
+    /**************************************************************************
+       Enable PCI bus mastering
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Setting PCI Bus Mastering...\n" );
+    pci_set_master( pdev );
+
+
+    /**************************************************************************
+       Query PCI for Power Mgmt Capabilities
+
+       NOTE: Now reading PowerMgmt in another location; is this still needed?
+     *************************************************************************/
+    pm_cap = pci_find_capability( pdev, PCI_CAP_ID_PM );
+    if( pm_cap == 0 )
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "Cannot find Power Management capabilities\n" );
+
+        if( bar_workaround == FALSE )
+        {
+            pci_release_regions( pdev );
+        }
+        else
+        {
+            pdev->resource[0].start = bar_addr_orig;
+        }
+
+        pci_disable_device( pdev );
+
+        DBG_LEAVE( et131x_dbginfo );
+        return -EIO;
+    }
+
+
+    /**************************************************************************
+       Check the DMA addressing support of this device
+     *************************************************************************/
+    if( !pci_set_dma_mask( pdev, 0xffffffffffffffffULL ))
+    {
+        DBG_TRACE( et131x_dbginfo,
+                   "64-bit DMA addressing supported\n" );
+        pci_using_dac = TRUE;
+
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,0 ))
+        result = pci_set_consistent_dma_mask( pdev, 0xffffffffffffffffULL );
+		if( result != 0 )
+        {
+			DBG_ERROR( et131x_dbginfo,
+                       "Unable to obtain 64 bit DMA for consistent allocations\n" );
+            if( bar_workaround == FALSE )
+            {
+                pci_release_regions( pdev );
+            }
+            else
+            {
+                pdev->resource[0].start = bar_addr_orig;
+            }
+
+            pci_disable_device( pdev );
+
+			DBG_LEAVE( et131x_dbginfo );
+            return -EIO;
+        }
+#endif
+    }
+    else if( !pci_set_dma_mask( pdev, 0xffffffffULL ))
+    {
+        DBG_TRACE( et131x_dbginfo,
+                   "64-bit DMA addressing NOT supported\n" );
+        DBG_TRACE( et131x_dbginfo,
+                   "32-bit DMA addressing will be used\n" );
+        pci_using_dac = FALSE;
+    }
+    else
+    {
+        DBG_ERROR( et131x_dbginfo, "No usable DMA addressing method\n" );
+
+        if( bar_workaround == FALSE )
+        {
+            pci_release_regions( pdev );
+        }
+        else
+        {
+            pdev->resource[0].start = bar_addr_orig;
+        }
+
+        pci_disable_device( pdev );
+
+        DBG_LEAVE( et131x_dbginfo );
+        return -EIO;
+    }
+
+
+    /**************************************************************************
+       Allocate netdev and private adapter structs
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Allocate netdev and private adapter structs...\n" );
+    netdev = et131x_device_alloc( );
+
+    if( netdev == NULL )
+    {
+        DBG_ERROR( et131x_dbginfo, "Couldn't alloc netdev struct\n" );
+
+        if( bar_workaround == FALSE )
+        {
+            pci_release_regions( pdev );
+        }
+        else
+        {
+            pdev->resource[0].start = bar_addr_orig;
+        }
+
+        pci_disable_device( pdev );
+
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+
+    /**************************************************************************
+       Setup the fundamental net_device and private adapter structure elements
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Setting fundamental net_device info...\n" );
+
+//    SET_MODULE_OWNER( netdev );
+    SET_NETDEV_DEV( netdev, &pdev->dev );
+
+    if( pci_using_dac )
+    {
+        //netdev->features |= NETIF_F_HIGHDMA;
+    }
+
+
+    /**************************************************************************
+       NOTE - Turn this on when we're ready to deal with SG-DMA
+
+       NOTE: According to "Linux Device Drivers", 3rd ed, Rubini et al, if
+       checksumming is not performed in HW, then the kernel will not use SG.
+       From pp 510-511:
+
+       "Note that the kernel does not perform scatter/gather I/O to your device
+       if it does not also provide some form of checksumming as well. The
+       reason is that, if the kernel has to make a pass over a fragmented
+       ("nonlinear") packet to calculate the checksum, it might as well copy
+       the data and coalesce the packet at the same time."
+
+       This has been verified by setting the flags below and still not
+       receiving a scattered buffer from the network stack, so leave it off
+       until checksums are calculated in HW.
+     *************************************************************************/
+    //netdev->features |= NETIF_F_SG;
+    //netdev->features |= NETIF_F_NO_CSUM;
+
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION( 2,6,0 ))
+    //netdev->features |= NETIF_F_LLTX;
+#endif
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+    /**************************************************************************
+       The ET1310 does not perform VLAN tagging in hardware, so these flags are
+       not set.
+     *************************************************************************/
+    /*
+    netdev->features   |= NETIF_F_HW_VLAN_TX |
+                          NETIF_F_HW_VLAN_RX |
+                          NETIF_F_HW_VLAN_FILTER;
+    */
+#endif
+
+    /**************************************************************************
+       Allocate private adapter struct and copy in relevant information
+     *************************************************************************/
+    adapter           = netdev_priv( netdev );
+    adapter->pdev     = pdev;
+    adapter->netdev   = netdev;
+    adapter->VendorID = pdev->vendor;
+    adapter->DeviceID = pdev->device;
+
+    adapter->pci_bar_workaround = bar_workaround;
+    adapter->pci_bar_addr_orig  = bar_addr_orig;
+
+
+    /**************************************************************************
+       Do the same for the netdev struct
+     *************************************************************************/
+    netdev->irq       = pdev->irq;
+    netdev->base_addr = pdev->resource[0].start;
+
+
+    /**************************************************************************
+       Initialize spinlocks here
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Initialize spinlocks...\n" );
+
+    spin_lock_init( &adapter->Lock );
+    spin_lock_init( &adapter->TCBSendQLock );
+    spin_lock_init( &adapter->TCBReadyQLock );
+    spin_lock_init( &adapter->SendHWLock );
+    spin_lock_init( &adapter->SendWaitLock );
+    spin_lock_init( &adapter->RcvLock );
+    spin_lock_init( &adapter->RcvPendLock );
+    spin_lock_init( &adapter->FbrLock );
+    spin_lock_init( &adapter->PHYLock );
+
+
+    /**************************************************************************
+       Parse configuration parameters into the private adapter struct
+     *************************************************************************/
+    et131x_config_parse( adapter );
+
+
+    /**************************************************************************
+       Find the physical adapter
+
+       NOTE: This is the equivalent of the MpFindAdapter() routine; can we
+             lump it's init with the device specific init below into a single
+             init function?
+     *************************************************************************/
+    //while(et131x_find_adapter( adapter, pdev ) != 0);
+    et131x_find_adapter( adapter, pdev );
+
+    /**************************************************************************
+       Map the bus-relative registers to system virtual memory
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Mapping bus-relative registers to virtual memory...\n" );
+
+    if( bar_workaround == FALSE )
+    {
+        et131x_reg_base = pci_resource_start( pdev, 0 );
+        et131x_reg_len  = pci_resource_len( pdev, 0 );
+    }
+    else
+    {
+        et131x_reg_len  = 0x00200000;
+    }
+
+    adapter->CSRAddress = (ADDRESS_MAP_t *)ioremap_nocache( et131x_reg_base,
+                                                            et131x_reg_len );
+    if( adapter->CSRAddress == NULL )
+    {
+        DBG_ERROR( et131x_dbginfo, "Cannot map device registers\n" );
+
+        et131x_device_free( netdev );
+
+        if( bar_workaround == FALSE )
+        {
+            pci_release_regions( pdev );
+        }
+        else
+        {
+            pdev->resource[0].start = bar_addr_orig;
+        }
+
+        pci_disable_device( pdev );
+
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+
+    /**************************************************************************
+       Perform device-specific initialization here (See code below)
+     *************************************************************************/
+
+    /**************************************************************************
+       If Phy COMA mode was enabled when we went down, disable it here.
+     *************************************************************************/
+    {
+        PM_CSR_t     GlobalPmCSR = {0};
+
+        GlobalPmCSR.bits.pm_sysclk_gate     = 1;
+        GlobalPmCSR.bits.pm_txclk_gate      = 1;
+        GlobalPmCSR.bits.pm_rxclk_gate      = 1;
+
+        adapter->CSRAddress->global.pm_csr = GlobalPmCSR;
+    }
+
+
+    /**************************************************************************
+       Issue a global reset to the et1310
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Issuing soft reset...\n" );
+    et131x_soft_reset( adapter );
+
+
+    /**************************************************************************
+       Disable all interrupts (paranoid)
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Disable device interrupts...\n" );
+    et131x_disable_interrupts( adapter );
+
+
+    /**************************************************************************
+       Allocate DMA memory
+     *************************************************************************/
+    result = et131x_adapter_memory_alloc( adapter );
+    if( result != 0 )
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "Could not alloc adapater memory (DMA)\n" );
+
+        iounmap( (void *)adapter->CSRAddress );
+
+        et131x_device_free( netdev );
+
+        if( bar_workaround == FALSE )
+        {
+            pci_release_regions( pdev );
+        }
+        else
+        {
+            pdev->resource[0].start = bar_addr_orig;
+        }
+
+        pci_disable_device( pdev );
+
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENOMEM;
+    }
+
+
+    /**************************************************************************
+       Init send data structures
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Init send data structures...\n" );
+    et131x_init_send( adapter );
+
+    adapter->PoMgmt.PowerState = NdisDeviceStateD0;
+
+
+    /**************************************************************************
+       Register the interrupt
+
+       NOTE - This is being done in the open routine, where most other Linux
+              drivers setup IRQ handlers. Make sure device interrupts are not
+              turned on before the IRQ is registered!!!!
+
+              What we will do here is setup the task structure for the ISR's
+              deferred handler
+     *************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+    adapter->task.routine = (void (*)(void *))et131x_isr_handler;
+    adapter->task.data = adapter;
+#else
+    INIT_WORK( &adapter->task, et131x_isr_handler );
+#endif
+
+
+    /**************************************************************************
+       Determine MAC Address, and copy into the net_device struct
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Retrieve MAC address...\n" );
+    et131x_setup_hardware_properties( adapter );
+
+    memcpy( netdev->dev_addr, adapter->CurrentAddress, ETH_ALEN );
+
+
+    /**************************************************************************
+       Setup up our lookup table for CRC Calculations
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Setup CRC lookup table...\n" );
+    et131x_init_enet_crc_calc( );
+
+
+    /**************************************************************************
+       Setup et1310 as per the documentation
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Setup the adapter...\n" );
+    et131x_adapter_setup( adapter );
+
+
+    /**************************************************************************
+       Create a timer to count errors received by the NIC
+     *************************************************************************/
+    init_timer( &adapter->ErrorTimer );
+
+    adapter->ErrorTimer.expires  = jiffies + TX_ERROR_PERIOD * HZ / 1000;
+    adapter->ErrorTimer.function = et131x_error_timer_handler;
+    adapter->ErrorTimer.data     = (unsigned long)adapter;
+
+
+    /**************************************************************************
+       Initialize link state
+     *************************************************************************/
+    et131x_link_detection_handler( (unsigned long)adapter );
+
+
+    /**************************************************************************
+       Intialize variable for counting how long we do not have link status
+     *************************************************************************/
+    adapter->PoMgmt.TransPhyComaModeOnBoot = 0;
+
+
+    /**************************************************************************
+       We can enable interrupts now
+
+       NOTE - Because registration of interrupt handler is done in the device's
+              open(), defer enabling device interrupts to that point
+     *************************************************************************/
+
+
+    /**************************************************************************
+       Register the net_device struct with the Linux network layer
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Registering net_device...\n" );
+
+
+    if(( result = register_netdev( netdev )) != 0 )
+    {
+        DBG_ERROR( et131x_dbginfo, "register_netdev() failed\n" );
+
+        et131x_adapter_memory_free( adapter );
+
+        iounmap( (void *)adapter->CSRAddress );
+
+        et131x_device_free( netdev );
+
+        if( bar_workaround == FALSE )
+        {
+            pci_release_regions( pdev );
+        }
+        else
+        {
+            pdev->resource[0].start = bar_addr_orig;
+        }
+
+        pci_disable_device( pdev );
+
+        DBG_LEAVE( et131x_dbginfo );
+        return result;
+    }
+
+
+    /**************************************************************************
+       Register the net_device struct with the PCI subsystem. Save a copy
+       of the PCI config space for this device now that the device has been
+       initialized, just in case it needs to be quickly restored.
+     *************************************************************************/
+    pci_set_drvdata( pdev, netdev );
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,10 ))
+    pci_save_state( adapter->pdev, adapter->pci_cfg_state);
+#else
+    pci_save_state( adapter->pdev );
+#endif
+
+
+    /**************************************************************************
+       Print out some information about this device
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo,
+               "DEVICE FOUND\n" );
+    DBG_TRACE( et131x_dbginfo,
+               "------------------------------\n" );
+    DBG_TRACE( et131x_dbginfo,
+               "Device Vendor ID     : 0x%04x\n",
+               pdev->vendor );
+    DBG_TRACE( et131x_dbginfo,
+               "Device Product ID    : 0x%04x\n",
+               pdev->device );
+    DBG_TRACE( et131x_dbginfo,
+               "Device SubVendor ID  : 0x%04x\n",
+               pdev->subsystem_vendor );
+    DBG_TRACE( et131x_dbginfo,
+               "Device SubProduct ID : 0x%04x\n",
+               pdev->subsystem_device );
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+    DBG_TRACE( et131x_dbginfo,
+               "Device Name          : %s\n",
+               pdev->name );
+#endif
+
+    DBG_TRACE( et131x_dbginfo,
+               "Device on Bus #      : %d\n",
+               pdev->bus->number );
+    DBG_TRACE( et131x_dbginfo,
+               "          Bus Name   : %s\n",
+               pdev->bus->name );
+    DBG_TRACE( et131x_dbginfo,
+               "Device in Slot #     : %d\n",
+               PCI_SLOT( pdev->devfn ));
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,11 ))
+    DBG_TRACE( et131x_dbginfo,
+               "          Slot Name  : %s\n",
+               pdev->slot_name );
+#endif
+
+    DBG_TRACE( et131x_dbginfo,
+               "Device Base Address  : 0x%#03lx\n",
+               netdev->base_addr );
+    DBG_TRACE( et131x_dbginfo,
+               "Device IRQ           : %d\n",
+               netdev->irq );
+    DBG_TRACE( et131x_dbginfo,
+               "Device MAC Address   : %02x:%02x:%02x:%02x:%02x:%02x\n",
+               adapter->CurrentAddress[0], adapter->CurrentAddress[1],
+               adapter->CurrentAddress[2], adapter->CurrentAddress[3],
+               adapter->CurrentAddress[4], adapter->CurrentAddress[5] );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
--- /dev/null
+++ b/drivers/net/et131x/et131x_initpci.h
@@ -0,0 +1,103 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_initpci.h - Header which includes common data and function prototypes
+ *                    related to the driver's PCI (and PCI Express) information.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/10/28 17:31:23 $
+     $Revision: 1.4 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET131X_INITPCI_H__
+#define __ET131X_INITPCI_H__
+
+
+
+
+/******************************************************************************
+   Function Prototypes
+ *****************************************************************************/
+int et131x_pci_register( void );
+void et131x_pci_unregister( void );
+
+void et131x_align_allocated_memory( ET131X_ADAPTER *adapter,
+                                    UINT64         *phys_addr,
+                                    UINT64         *offset,
+                                    UINT64          mask );
+
+
+
+
+int et131x_adapter_setup( ET131X_ADAPTER *pAdapter );
+int et131x_adapter_memory_alloc( ET131X_ADAPTER *adapter );
+void et131x_adapter_memory_free( ET131X_ADAPTER *adapter );
+void et131x_setup_hardware_properties( ET131X_ADAPTER *adapter );
+void et131x_soft_reset( ET131X_ADAPTER *adapter );
+
+#endif  /* __ET131X_INITPCI_H__ */
--- /dev/null
+++ b/drivers/net/et131x/et131x_isr.c
@@ -0,0 +1,656 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_isr.c - File which contains the ISR, ISR handler, and related routines
+ *                for processing interrupts from the device.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2006/01/31 20:58:43 $
+     $Revision: 1.13 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+#include "ET1310_mac.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   Prototypes for functions with local scope
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Defines for 2.4 compatibility with the new 2.6 IRQ handler return values
+ *****************************************************************************/
+#ifndef IRQ_RETVAL
+
+typedef void irqreturn_t;
+#define IRQ_NONE
+#define IRQ_HANDLED
+#define IRQ_RETVAL(x)
+
+#endif  /* IRQ_RETVAL */
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_isr
+ ******************************************************************************
+
+   DESCRIPTION       : The Interrupt Service Routine for the driver.
+
+   PARAMETERS        : irq    - the IRQ on which the interrupt was received.
+                       dev_id - a buffer containing device-specific info (in
+                                this case, a pointer to a net_device struct)
+                       regs   -
+
+   RETURNS           : For 2.4.x kernels - N/A
+                       For 2.6.x kernels - A value indicating if the interrupt
+                                           was handled.
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+irqreturn_t et131x_isr( int irq, void *dev_id )
+{
+    BOOL_t                 handled = TRUE;
+    struct net_device     *netdev  = (struct net_device *)dev_id;
+    ET131X_ADAPTER        *adapter = NULL;
+    INT_STATUS_t           status;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_isr" );
+
+
+    do
+    {
+        if(( netdev == NULL ) || ( !netif_device_present( netdev )))
+        {
+            DBG_WARNING( et131x_dbginfo,
+                         "No net_device struct or device not present\n" );
+            handled = FALSE;
+            break;
+        }
+
+        adapter = netdev_priv( netdev );
+
+
+        /**********************************************************************
+           If the adapter is in low power state, then it should not recognize
+           any interrupt
+
+           NOTE
+         *********************************************************************/
+
+
+        /**********************************************************************
+           Disable Device Interrupts
+         *********************************************************************/
+        et131x_disable_interrupts( adapter );
+
+
+        /**********************************************************************
+           Get a copy of the value in the interrupt status register so we can
+           process the interrupting section
+         *********************************************************************/
+        status.value  =  adapter->CSRAddress->global.int_status.value;
+
+        if(( adapter->FlowControl == TxOnly ) ||
+           ( adapter->FlowControl == Both ))
+        {
+            status.value &= ~INT_MASK_ENABLE;
+        }
+        else
+        {
+            status.value &= ~INT_MASK_ENABLE_NO_FLOW;
+        }
+
+
+        /**********************************************************************
+           Make sure this is our interrupt
+         *********************************************************************/
+        if( !status.value )
+        {
+#if ET131X_DBG
+            adapter->Stats.UnhandledInterruptsPerSec++;
+#endif
+            handled = FALSE;
+            DBG_VERBOSE( et131x_dbginfo, "NOT OUR INTERRUPT\n" );
+            et131x_enable_interrupts( adapter );
+            break;
+        }
+
+        /**********************************************************************
+           This is our interrupt, so process accordingly
+         *********************************************************************/
+#if ET131X_DBG
+        if( status.bits.rxdma_xfr_done )
+        {
+            adapter->Stats.RxDmaInterruptsPerSec++;
+        }
+
+        if( status.bits.txdma_isr )
+        {
+            adapter->Stats.TxDmaInterruptsPerSec++;
+        }
+#endif
+
+        if( status.bits.watchdog_interrupt )
+        {
+            PMP_TCB pMpTcb = adapter->TxRing.CurrSendHead;
+
+            if( pMpTcb )
+            {
+                if( ++pMpTcb->PacketStaleCount > 1 )
+                {
+                    status.bits.txdma_isr = 1;
+                }
+            }
+
+            if( adapter->RxRing.UnfinishedReceives )
+            {
+                status.bits.rxdma_xfr_done = 1;
+            }
+            else if( pMpTcb == 0 )
+            {
+                adapter->CSRAddress->global.watchdog_timer = 0;
+            }
+
+            status.bits.watchdog_interrupt = 0;
+#if ET131X_DBG
+            adapter->Stats.WatchDogInterruptsPerSec++;
+#endif
+        }
+
+        if( status.value == 0 )
+        {
+            /******************************************************************
+               This interrupt has in some way been "handled" by the ISR. Either
+               it was a spurious Rx interrupt, or it was a Tx interrupt that
+               has been filtered by the ISR.
+             *****************************************************************/
+            et131x_enable_interrupts( adapter );
+            break;
+        }
+
+        /**********************************************************************
+           We need to save the interrupt status value for use in our DPC. We
+           will clear the software copy of that in that routine.
+         *********************************************************************/
+        adapter->Stats.InterruptStatus = status;
+
+
+        /**********************************************************************
+           Schedule the ISR handler as a bottom-half task in the kernel's
+           tq_immediate queue, and mark the queue for execution
+         *********************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+        schedule_task( &adapter->task );
+#else
+        schedule_work( &adapter->task );
+#endif
+
+    } while( 0 );
+
+    return IRQ_RETVAL( handled );
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_isr_handler
+ ******************************************************************************
+
+   DESCRIPTION       : The ISR handler, scheduled to run in a deferred context
+                       by the ISR. This is where the ISR's work actually gets
+                       done.
+
+   PARAMETERS        : p_adapter - a pointer to the device's private adapter
+                                   structure
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_isr_handler( struct work_struct *work )
+{
+    ET131X_ADAPTER *pAdapter = container_of( work, ET131X_ADAPTER, task );
+
+    INT_STATUS_t GlobStatus = pAdapter->Stats.InterruptStatus;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_isr_handler" );
+
+
+    /**************************************************************************
+       These first two are by far the most common.  Once handled, we clear
+       their two bits in the status word.  If the word is now zero, we exit.
+     *************************************************************************/
+    /**************************************************************************
+       Handle all the completed Transmit interrupts
+     *************************************************************************/
+    if( GlobStatus.bits.txdma_isr )
+    {
+        DBG_TX( et131x_dbginfo, "TXDMA_ISR interrupt\n" );
+        et131x_handle_send_interrupt( pAdapter );
+    }
+
+
+    /**************************************************************************
+       Handle all the completed Receives interrupts
+     *************************************************************************/
+    if( GlobStatus.bits.rxdma_xfr_done )
+    {
+        DBG_RX( et131x_dbginfo, "RXDMA_XFR_DONE interrupt\n" );
+        et131x_handle_recv_interrupt( pAdapter );
+    }
+
+    GlobStatus.value &= 0xffffffd7;
+
+    if( GlobStatus.value )
+    {
+
+        /**********************************************************************
+           Handle the TXDMA Error interrupt
+         *********************************************************************/
+        if( GlobStatus.bits.txdma_err )
+        {
+            TXDMA_ERROR_t   TxDmaErr;
+
+
+            /******************************************************************
+               Following read also clears the register (COR register)
+             *****************************************************************/
+            TxDmaErr.value = pAdapter->CSRAddress->txdma.TxDmaError.value;
+
+            DBG_WARNING( et131x_dbginfo, "TXDMA_ERR interrupt, error = %d\n",
+                         TxDmaErr.value );
+        }
+
+
+        /**********************************************************************
+           Handle Free Buffer Ring 0 and 1 Low interrupt
+         *********************************************************************/
+        if( GlobStatus.bits.rxdma_fb_ring0_low ||
+            GlobStatus.bits.rxdma_fb_ring1_low )
+        {
+            /******************************************************************
+               This indicates the number of unused buffers in RXDMA free buffer
+               ring 0 is <= the limit you programmed. Free buffer resources
+               need to be returned.  Free buffers are consumed as packets are
+               passed from the network to the host. The host becomes aware of
+               the packets from the contents of the packet status ring. This
+               ring is queried when the packet done interrupt occurs. Packets
+               are then passed to the OS. When the OS is done with the packets
+               the resources can be returned to the ET1310 for re-use. This
+               interrupt is one method of returning resources.
+             *****************************************************************/
+            DBG_WARNING( et131x_dbginfo,
+                         "RXDMA_FB_RING0_LOW or "
+                         "RXDMA_FB_RING1_LOW interrupt\n" );
+
+
+            /******************************************************************
+               If the user has flow control on, then we will send a pause
+               packet, otherwise just exit
+             *****************************************************************/
+            if(( pAdapter->FlowControl == TxOnly ) ||
+               ( pAdapter->FlowControl == Both ))
+            {
+                /**************************************************************
+                   Tell the device to send a pause packet via the back pressure
+                   register
+                 *************************************************************/
+                if( pAdapter->CSRAddress->global.pm_csr.bits.pm_phy_sw_coma == 0 )
+                {
+                    TXMAC_BP_CTRL_t     bp_ctrl;
+
+                    bp_ctrl.bits.bp_req     = 1;
+                    bp_ctrl.bits.bp_xonxoff = 1;
+
+                    pAdapter->CSRAddress->txmac.bp_ctrl.value = bp_ctrl.value;
+                }
+            }
+        }
+
+
+        /**********************************************************************
+           Handle Packet Status Ring Low Interrupt
+         *********************************************************************/
+        if( GlobStatus.bits.rxdma_pkt_stat_ring_low )
+        {
+            DBG_WARNING( et131x_dbginfo,
+                         "RXDMA_PKT_STAT_RING_LOW interrupt\n" );
+
+
+            /******************************************************************
+               Same idea as with the two Free Buffer Rings. Packets going from
+               the network to the host each consume a free buffer resource and
+               a packet status resource.  These resoures are passed to the OS.
+               When the OS is done with the resources, they need to be returned
+               to the ET1310. This is one method of returning the resources.
+             *****************************************************************/
+        }
+
+
+        /**********************************************************************
+           Handle RXDMA Error Interrupt
+         *********************************************************************/
+        if( GlobStatus.bits.rxdma_err )
+        {
+            /******************************************************************
+               The rxdma_error interrupt is sent when a time-out on a request
+               issued by the JAGCore has occurred or a completion is returned
+               with an un-successful status.  In both cases the request is
+               considered complete. The JAGCore will automatically re-try the
+               request in question. Normally information on events like these
+               are sent to the host using the "Advanced Error Reporting"
+               capability. This interrupt is another way of getting similar
+               information. The only thing required is to clear the interrupt
+               by reading the ISR in the global resources. The JAGCore will do
+               a re-try on the request.  Normally you should never see this
+               interrupt. If you start to see this interrupt occurring
+               frequently then something bad has occurred.
+               A reset might be the thing to do.
+             *****************************************************************/
+            // TRAP();
+
+            pAdapter->TxMacTest = pAdapter->CSRAddress->txmac.tx_test;
+            DBG_WARNING( et131x_dbginfo,
+                         "RxDMA_ERR interrupt, error %x\n",
+                         pAdapter->TxMacTest.value );
+        }
+
+
+        /**********************************************************************
+           Handle the Wake on LAN Event
+         *********************************************************************/
+        if( GlobStatus.bits.wake_on_lan )
+        {
+            /******************************************************************
+               This is a secondary interrupt for wake on LAN.  The driver
+               should never see this, if it does, something serious is wrong.
+               We will TRAP the message when we are in DBG mode, otherwise we
+               will ignore it.
+             *****************************************************************/
+            DBG_ERROR( et131x_dbginfo, "WAKE_ON_LAN interrupt\n" );
+        }
+
+
+        /**********************************************************************
+           Handle the PHY interrupt
+         *********************************************************************/
+        if( GlobStatus.bits.phy_interrupt )
+        {
+            MI_BMSR_t BmsrInts, BmsrData;
+            MI_ISR_t  myIsr;
+
+            DBG_VERBOSE( et131x_dbginfo, "PHY interrupt\n" );
+
+            /******************************************************************
+               If we are in coma mode when we get this interrupt, we need to
+               disable it.
+             *****************************************************************/
+            if( pAdapter->CSRAddress->global.pm_csr.bits.phy_sw_coma == 1 )
+            {
+                /**************************************************************
+                   Check to see if we are in coma mode and if so, disable it
+                   because we will not be able to read PHY values until we are
+                   out.
+                 *************************************************************/
+                DBG_VERBOSE( et131x_dbginfo, "Device is in COMA mode, "
+                                             "need to wake up\n" );
+                DisablePhyComa( pAdapter );
+            }
+
+
+            /******************************************************************
+               Read the PHY ISR to clear the reason for the interrupt.
+             *****************************************************************/
+            MiRead( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                    (UINT8)offsetof( MI_REGS_t, isr ), &myIsr.value );
+
+            if( !pAdapter->ReplicaPhyLoopbk )
+            {
+                MiRead( pAdapter, (UINT8)pAdapter->Stats.xcvr_addr,
+                        (UINT8)offsetof( MI_REGS_t, bmsr ), &BmsrData.value );
+
+                BmsrInts.value       = pAdapter->Bmsr.value ^ BmsrData.value;
+                pAdapter->Bmsr.value = BmsrData.value;
+
+                DBG_VERBOSE( et131x_dbginfo,
+                            "Bmsr.value = 0x%04x,"
+                            "Bmsr_ints.value = 0x%04x\n",
+                            BmsrData.value,
+                            BmsrInts.value );
+
+
+                /**************************************************************
+                   Do all the cable in / cable out stuff
+                 *************************************************************/
+                et131x_Mii_check( pAdapter, BmsrData, BmsrInts );
+            }
+        }
+
+
+        /**********************************************************************
+           Let's move on to the TxMac
+         *********************************************************************/
+        if( GlobStatus.bits.txmac_interrupt )
+        {
+            pAdapter->TxRing.TxMacErr.value = pAdapter->CSRAddress->txmac.err.value;
+
+            /******************************************************************
+               When any of the errors occur and TXMAC generates an interrupt to
+               report these errors, it usually means that TXMAC has detected an
+               error in the data stream retrieved from the on-chip Tx Q. All of
+               these errors are catastrophic and TXMAC won’t be able to recover
+               data when these errors occur.  In a nutshell, the whole Tx path
+               will have to be reset and re-configured afterwards.
+             *****************************************************************/
+            DBG_WARNING( et131x_dbginfo,
+                         "TXMAC interrupt, error 0x%08x\n",
+                         pAdapter->TxRing.TxMacErr.value );
+
+
+            /*******************************************************************
+               If we are debugging, we want to see this error, otherwise we just
+               want the device to be reset and continue
+             *****************************************************************/
+            //DBG_TRAP();
+
+        }
+
+        /**********************************************************************
+           Handle RXMAC Interrupt
+         *********************************************************************/
+        if( GlobStatus.bits.rxmac_interrupt )
+        {
+            /******************************************************************
+               These interrupts are catastrophic to the device, what we need to
+               do is disable the interrupts and set the flag to cause us to
+               reset so we can solve this issue.
+             ******************************************************************/
+            // MP_SET_FLAG( pAdapter, fMP_ADAPTER_HARDWARE_ERROR );
+
+            DBG_WARNING( et131x_dbginfo,
+                         "RXMAC interrupt, error 0x%08x.  Requesting reset\n",
+                         pAdapter->CSRAddress->rxmac.err_reg.value );
+
+            DBG_WARNING( et131x_dbginfo,
+                         "Enable 0x%08x, Diag 0x%p\n",
+                         pAdapter->CSRAddress->rxmac.ctrl.value,
+                         &pAdapter->CSRAddress->rxmac.rxq_diag );
+
+
+            /*******************************************************************
+               If we are debugging, we want to see this error, otherwise we just
+               want the device to be reset and continue
+             *****************************************************************/
+            // TRAP();
+        }
+
+        /**********************************************************************
+           Handle MAC_STAT Interrupt
+         *********************************************************************/
+        if( GlobStatus.bits.mac_stat_interrupt )
+        {
+            /******************************************************************
+               This means at least one of the un-masked counters in the MAC_STAT
+               block has rolled over.  Use this to maintain the top, software
+               managed bits of the counter(s).
+             *****************************************************************/
+            DBG_VERBOSE( et131x_dbginfo, "MAC_STAT interrupt\n" );
+            HandleMacStatInterrupt( pAdapter );
+        }
+
+
+        /**********************************************************************
+           Handle SLV Timeout Interrupt
+         *********************************************************************/
+        if( GlobStatus.bits.slv_timeout )
+        {
+            /******************************************************************
+               This means a timeout has occured on a read or write request to
+               one of the JAGCore registers. The Global Resources block has
+               terminated the request and on a read request, returned a "fake"
+               value.  The most likely reasons are: Bad Address or the
+               addressed module is in a power-down state and can't respond.
+             *****************************************************************/
+            DBG_VERBOSE( et131x_dbginfo, "SLV_TIMEOUT interrupt\n" );
+        }
+    }
+
+
+    if( pAdapter->PoMgmt.PowerState == NdisDeviceStateD0 )
+    {
+        et131x_enable_interrupts( pAdapter );
+    }
+
+    return;
+}
+/*===========================================================================*/
--- /dev/null
+++ b/drivers/net/et131x/et131x_isr.h
@@ -0,0 +1,95 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_isr.h - Defines, structs, enums, prototypes, etc. pertaining to the
+ *                ISR processing code.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:13 $
+     $Revision: 1.3 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET131X_ISR_H__
+#define __ET131X_ISR_H__
+
+
+
+
+/******************************************************************************
+   Function Prototypes
+ *****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+void et131x_isr( int irq, void *dev_id, struct pt_regs *regs );
+#else
+irqreturn_t et131x_isr( int irq, void *dev_id );
+#endif
+
+void et131x_isr_handler( struct work_struct *work );
+
+
+#endif  /* __ET131X_ISR_H__ */
--- /dev/null
+++ b/drivers/net/et131x/et131x_main.c
@@ -0,0 +1,258 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_main.c - This file contains the driver's main Linux entry points.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:13 $
+     $Revision: 1.6 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_initpci.h"
+
+
+
+
+/******************************************************************************
+   Modinfo parameters (filled out using defines from et131x_version.h)
+ *****************************************************************************/
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_INFO );
+MODULE_LICENSE( DRIVER_LICENSE );
+
+
+
+
+/******************************************************************************
+   Module Parameters and related data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+
+static u32 et131x_debug_level = DBG_LVL;
+static u32 et131x_debug_flags = DBG_DEFAULTS;
+
+module_param( et131x_debug_level, uint, 0 );
+module_param( et131x_debug_flags, uint, 0 );
+
+MODULE_PARM_DESC( et131x_debug_level,
+                 "Level of debugging desired (0-7)" );
+
+dbg_info_t et131x_info     = { DRIVER_NAME_EXT, 0, 0 };
+dbg_info_t *et131x_dbginfo = &et131x_info;
+
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_init_module
+ ******************************************************************************
+
+   DESCRIPTION       : The "main" entry point called on driver initialization
+
+   PARAMETERS        : N/A
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_init_module( void )
+{
+    int result;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_init_module" );
+
+
+#if ET131X_DBG
+    /**************************************************************************
+       Set the level of debug messages displayed using the module parameter
+     *************************************************************************/
+    et131x_dbginfo->dbgFlags = et131x_debug_flags;
+
+    switch( et131x_debug_level )
+    {
+    case 7:
+        et131x_dbginfo->dbgFlags |= ( DBG_RX_ON | DBG_TX_ON );
+
+    case 6:
+        et131x_dbginfo->dbgFlags |= DBG_PARAM_ON;
+
+    case 5:
+        et131x_dbginfo->dbgFlags |= DBG_VERBOSE_ON;
+
+    case 4:
+        et131x_dbginfo->dbgFlags |= DBG_TRACE_ON;
+
+    case 3:
+        et131x_dbginfo->dbgFlags |= DBG_NOTICE_ON;
+
+    case 2:
+    case 1:
+    case 0:
+    default:
+        break;
+    }
+#endif  /* ET131X_DBG */
+
+    DBG_ENTER( et131x_dbginfo );
+    DBG_PRINT( "%s\n", DRIVER_INFO );
+
+
+    result = et131x_pci_register( );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return result;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_cleanup_module
+ ******************************************************************************
+
+   DESCRIPTION       : The entry point called on driver cleanup
+
+   PARAMETERS        : N/A
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_cleanup_module( void )
+{
+    DBG_FUNC( "et131x_cleanup_module" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    et131x_pci_unregister( );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   These macros map the driver-specific init_module() and cleanup_module()
+   routines so they can be called by the kernel.
+ *****************************************************************************/
+module_init(et131x_init_module);
+module_exit(et131x_cleanup_module);
--- /dev/null
+++ b/drivers/net/et131x/et131x_netdev.c
@@ -0,0 +1,1624 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_netdev.c - Routines and data required by all Linux network devices.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2007/01/22 23:13:56 $
+     $Revision: 1.21 $
+         $Name: T_20060131_v1-2-3 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/*******************************************************************************
+   Includes
+ ******************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/mii.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+#include <linux/if_vlan.h>
+#endif
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+#include "ET1310_mac.h"
+#include "ET1310_tx.h"
+
+#include "et131x_supp.h"
+#include "et131x_adapter.h"
+#include "et131x_isr.h"
+#include "et131x_initpci.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   Prototypes for functions with local scope
+ *****************************************************************************/
+int et131x_init( struct net_device *netdev );
+
+int et131x_config( struct net_device *netdev, struct ifmap *map );
+
+struct net_device_stats *et131x_stats( struct net_device *netdev );
+
+int et131x_open( struct net_device *netdev );
+
+int et131x_close( struct net_device *netdev );
+
+int et131x_ioctl( struct net_device *netdev, struct ifreq *reqbuf, int cmd );
+
+void et131x_multicast( struct net_device *netdev );
+
+int et131x_tx( struct sk_buff *skb, struct net_device *netdev );
+
+void et131x_tx_timeout( struct net_device *netdev );
+
+int et131x_change_mtu( struct net_device *netdev, int new_mtu );
+
+int et131x_set_mac_addr( struct net_device *netdev, void *new_mac );
+
+void et131x_vlan_rx_register( struct net_device *netdev, struct vlan_group *grp );
+
+void et131x_vlan_rx_add_vid( struct net_device *netdev, UINT16 vid );
+
+void et131x_vlan_rx_kill_vid( struct net_device *netdev, UINT16 vid );
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_device_alloc()
+ ******************************************************************************
+
+   DESCRIPTION       : Create instances of net_device and wl_private for the
+                       new adapter and register the device's entry points in
+                       the net_device structure.
+
+   PARAMETERS        : N/A
+
+   RETURNS           : pointer to the allocated and initialized net_device
+                       struct for this device.
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+struct net_device * et131x_device_alloc( void )
+{
+    struct net_device *netdev  = NULL;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_device_alloc" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Alloc net_device and adapter structs
+     *************************************************************************/
+    netdev = alloc_etherdev( sizeof( ET131X_ADAPTER ));
+
+    if( netdev == NULL )
+    {
+        DBG_ERROR( et131x_dbginfo,
+                   "Alloc of net_device struct failed\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return NULL;
+    }
+
+
+    /**************************************************************************
+       Setup the function registration table (and other data) for a net_device
+     *************************************************************************/
+    //netdev->init               = &et131x_init;
+    netdev->set_config         = &et131x_config;
+    netdev->get_stats          = &et131x_stats;
+    netdev->open               = &et131x_open;
+    netdev->stop               = &et131x_close;
+    netdev->do_ioctl           = &et131x_ioctl;
+    netdev->set_multicast_list = &et131x_multicast;
+    netdev->hard_start_xmit    = &et131x_tx;
+    netdev->tx_timeout         = &et131x_tx_timeout;
+    netdev->watchdog_timeo     = ET131X_TX_TIMEOUT;
+    netdev->change_mtu         = &et131x_change_mtu;
+    netdev->set_mac_address    = &et131x_set_mac_addr;
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+    netdev->vlan_rx_register   = &et131x_vlan_rx_register;
+    netdev->vlan_rx_add_vid    = &et131x_vlan_rx_add_vid;
+    netdev->vlan_rx_kill_vid   = &et131x_vlan_rx_kill_vid;
+#endif
+
+    //netdev->ethtool_ops        = &et131x_ethtool_ops;
+
+    // Poll?
+    //netdev->poll               = &et131x_poll;
+    //netdev->poll_controller    = &et131x_poll_controller;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return netdev;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_device_free()
+ ******************************************************************************
+
+   DESCRIPTION       : Free the net_device and adapter private resources for
+                       an adapter and perform basic cleanup.
+
+   PARAMETERS        : netdev - a pointer to the net_device structure
+                                representing the device whose resources should
+                                be freed.
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_device_free( struct net_device *netdev )
+{
+
+    DBG_FUNC( "et131x_device_free" );
+    DBG_ENTER( et131x_dbginfo );
+
+    if( netdev == NULL )
+    {
+        DBG_WARNING( et131x_dbginfo, "Pointer to net_device == NULL\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return;
+    }
+    else
+    {
+        free_netdev( netdev );
+    }
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_init
+ ******************************************************************************
+
+   DESCRIPTION       : This function is called by the kernel to initialize a
+                       device
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                       the device to be initialized.
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION : At the moment, this routine does nothing, as most init
+                       processing needs to be performed before this point.
+
+ *****************************************************************************/
+int et131x_init( struct net_device *netdev )
+{
+
+    DBG_FUNC( "et131x_init" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_config
+ ******************************************************************************
+
+   DESCRIPTION       : Implement the SIOCSIFMAP interface.
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                the device to be configured.
+                       map    - a pointer to an ifmap struct
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_config( struct net_device *netdev, struct ifmap *map )
+{
+    DBG_FUNC( "et131x_config" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_stats
+ ******************************************************************************
+
+   DESCRIPTION       : Return the current device statistics.
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                the device whose stats are being queried.
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+struct net_device_stats *et131x_stats( struct net_device *netdev )
+{
+    ET131X_ADAPTER          *adapter = netdev_priv(netdev);
+	struct net_device_stats *stats   = &adapter->net_stats;
+    CE_STATS_t              *devstat = &adapter->Stats;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_stats" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    stats->rx_packets          = devstat->ipackets;
+    stats->tx_packets          = devstat->opackets;
+    stats->rx_errors           = devstat->length_err + devstat->alignment_err +
+                                 devstat->crc_err + devstat->code_violations +
+                                 devstat->other_errors;
+    stats->tx_errors           = devstat->max_pkt_error;
+    stats->multicast           = devstat->multircv;
+    stats->collisions          = devstat->collisions;
+
+    stats->rx_length_errors    = devstat->length_err;
+    stats->rx_over_errors      = devstat->rx_ov_flow;
+    stats->rx_crc_errors       = devstat->crc_err;
+
+    // NOTE: These stats don't have corresponding values in CE_STATS, so we're
+    //       going to have to update these directly from within the TX/RX code
+    //stats->rx_bytes            = 20; //devstat->;
+    //stats->tx_bytes            = 20; //devstat->;
+    //stats->rx_dropped          = devstat->;
+    //stats->tx_dropped          = devstat->;
+
+    // NOTE: Not used, can't find analogous statistics
+    //stats->rx_frame_errors     = devstat->;
+    //stats->rx_fifo_errors      = devstat->;
+    //stats->rx_missed_errors    = devstat->;
+
+    //stats->tx_aborted_errors   = devstat->;
+    //stats->tx_carrier_errors   = devstat->;
+    //stats->tx_fifo_errors      = devstat->;
+    //stats->tx_heartbeat_errors = devstat->;
+    //stats->tx_window_errors    = devstat->;
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return stats;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_open
+ ******************************************************************************
+
+   DESCRIPTION       : Open the device for use.
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                the device to be opened.
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_open( struct net_device *netdev )
+{
+    int             result  = 0;
+    ET131X_ADAPTER *adapter = NULL;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_open" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    adapter = netdev_priv( netdev );
+
+
+    /**************************************************************************
+       Start the timer to track NIC errors
+     *************************************************************************/
+    add_timer( &adapter->ErrorTimer );
+
+
+    /**************************************************************************
+       Register our ISR
+     *************************************************************************/
+    DBG_TRACE( et131x_dbginfo, "Registering ISR...\n" );
+
+    result = request_irq( netdev->irq, et131x_isr, IRQF_SHARED, netdev->name, netdev );
+    if( result )
+    {
+        DBG_ERROR( et131x_dbginfo, "Could not register ISR\n" );
+        DBG_LEAVE( et131x_dbginfo );
+        return result;
+    }
+
+
+    /**************************************************************************
+       Enable the Tx and Rx DMA engines (if not already enabled)
+     *************************************************************************/
+    et131x_rx_dma_enable( adapter );
+    et131x_tx_dma_enable( adapter );
+
+
+    /**************************************************************************
+       Enable device interrupts
+     *************************************************************************/
+    et131x_enable_interrupts( adapter );
+
+    MP_SET_FLAG( adapter, fMP_ADAPTER_INTERRUPT_IN_USE );
+
+
+    /**************************************************************************
+       We're ready to move some data, so start the queue
+     *************************************************************************/
+    netif_start_queue( netdev );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return result;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_close
+ ******************************************************************************
+
+   DESCRIPTION       : Close the device.
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                the device to be opened.
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_close( struct net_device *netdev )
+{
+    ET131X_ADAPTER *adapter = NULL;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_close" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    adapter = netdev_priv( netdev );
+
+
+    /**************************************************************************
+       First thing is to stop the queue
+     *************************************************************************/
+    netif_stop_queue( netdev );
+
+
+    /**************************************************************************
+       Stop the Tx and Rx DMA engines
+     *************************************************************************/
+    et131x_rx_dma_disable( adapter );
+    et131x_tx_dma_disable( adapter );
+
+
+    /**************************************************************************
+       Disable device interrupts
+     *************************************************************************/
+    et131x_disable_interrupts( adapter );
+
+
+    /**************************************************************************
+       Deregistering ISR
+     *************************************************************************/
+    MP_CLEAR_FLAG( adapter, fMP_ADAPTER_INTERRUPT_IN_USE );
+
+    DBG_TRACE( et131x_dbginfo, "Deregistering ISR...\n" );
+    free_irq( netdev->irq, netdev );
+
+
+    /**************************************************************************
+       Stop the error timer
+     *************************************************************************/
+    del_timer_sync( &adapter->ErrorTimer );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return 0;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_ioctl_mii
+ ******************************************************************************
+
+   DESCRIPTION       : The function which handles MII IOCTLs
+
+   PARAMETERS        : netdev - the net_device struct corresponding to the
+                                device on which the query is being made
+                       reqbuf - the request-specific data buffer
+                       cmd    - the command request code
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_ioctl_mii( struct net_device *netdev, struct ifreq *reqbuf, int cmd )
+{
+    int                    status   = 0;
+    ET131X_ADAPTER        *pAdapter = netdev_priv(netdev);
+    struct mii_ioctl_data *data     = if_mii( reqbuf );
+    UINT16                 mii_reg;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_ioctl_mii" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    switch( cmd )
+    {
+    case SIOCGMIIPHY:
+        DBG_VERBOSE( et131x_dbginfo, "SIOCGMIIPHY\n" );
+        data->phy_id = pAdapter->Stats.xcvr_addr;
+        break;
+
+
+    case SIOCGMIIREG:
+        DBG_VERBOSE( et131x_dbginfo, "SIOCGMIIREG\n" );
+        if( !capable( CAP_NET_ADMIN ))
+        {
+            status = -EPERM;
+        }
+        else
+        {
+            status = MiRead( pAdapter,
+                             pAdapter->Stats.xcvr_addr,
+                             data->reg_num,
+                            &data->val_out );
+        }
+
+        break;
+
+
+    case SIOCSMIIREG:
+        DBG_VERBOSE( et131x_dbginfo, "SIOCSMIIREG\n" );
+        if( !capable( CAP_NET_ADMIN ))
+        {
+            status = -EPERM;
+        }
+        else
+        {
+            mii_reg = data->val_in;
+
+            status = MiWrite( pAdapter,
+                              pAdapter->Stats.xcvr_addr,
+                              data->reg_num,
+                              mii_reg );
+        }
+
+        break;
+
+
+    default:
+        status = -EOPNOTSUPP;
+    }
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_ioctl
+ ******************************************************************************
+
+   DESCRIPTION       : The I/O Control handler for the driver.
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                the device on which the control request is
+                                being made.
+                       reqbuf - a pointer to the IOCTL request buffer.
+                       cmd    - the IOCTL command code.
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_ioctl( struct net_device *netdev, struct ifreq *reqbuf, int cmd )
+{
+    int status = 0;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_ioctl" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    switch( cmd )
+    {
+	case SIOCGMIIPHY:
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+        status = et131x_ioctl_mii( netdev, reqbuf, cmd );
+        break;
+
+    default:
+/*        DBG_WARNING( et131x_dbginfo, "Unhandled IOCTL Code: 0x%04x\n", cmd );*/
+		status = -EOPNOTSUPP;
+	}
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_set_packet_filter
+ ******************************************************************************
+
+   DESCRIPTION       : Configures the Rx Packet filtering on the device
+
+   PARAMETERS        : adapter - pointer to our private adapter structure
+
+   RETURNS           : 0 on success, errno on failure
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_set_packet_filter( ET131X_ADAPTER *adapter )
+{
+    int             status  = 0;
+    UINT32          filter  = adapter->PacketFilter;
+    RXMAC_CTRL_t    ctrl    = adapter->CSRAddress->rxmac.ctrl;
+    RXMAC_PF_CTRL_t pf_ctrl = adapter->CSRAddress->rxmac.pf_ctrl;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_set_packet_filter" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Default to disabled packet filtering.  Enable it in the individual case
+       statements that require the device to filter something
+     *************************************************************************/
+    ctrl.bits.pkt_filter_disable = 1;
+
+
+    /**************************************************************************
+       Set us to be in promiscuous mode so we receive everything,
+       this is also true when we get a packet filter of 0
+     *************************************************************************/
+    if(( filter & ET131X_PACKET_TYPE_PROMISCUOUS ) || filter == 0 )
+    {
+        pf_ctrl.bits.filter_broad_en = 0;
+        pf_ctrl.bits.filter_multi_en = 0;
+        pf_ctrl.bits.filter_uni_en   = 0;
+    }
+    else
+    {
+        /**********************************************************************
+           Set us up with Multicast packet filtering.  Three cases are
+           possible - (1) we have a multi-cast list, (2) we receive ALL
+           multicast entries or (3) we receive none.
+         *********************************************************************/
+        if( filter & ET131X_PACKET_TYPE_ALL_MULTICAST )
+        {
+            DBG_VERBOSE( et131x_dbginfo,
+                         "Multicast filtering OFF (Rx ALL MULTICAST)\n" );
+            pf_ctrl.bits.filter_multi_en = 0;
+        }
+        else
+        {
+            DBG_VERBOSE( et131x_dbginfo, "Multicast filtering ON\n" );
+            SetupDeviceForMulticast( adapter );
+            pf_ctrl.bits.filter_multi_en    = 1;
+            ctrl.bits.pkt_filter_disable    = 0;
+        }
+
+
+        /**********************************************************************
+           Set us up with Unicast packet filtering
+         *********************************************************************/
+        if( filter & ET131X_PACKET_TYPE_DIRECTED )
+        {
+            DBG_VERBOSE( et131x_dbginfo, "Unicast Filtering ON\n" );
+            SetupDeviceForUnicast( adapter );
+            pf_ctrl.bits.filter_uni_en = 1;
+            ctrl.bits.pkt_filter_disable    = 0;
+        }
+
+
+        /**********************************************************************
+           Set us up with Broadcast packet filtering
+         *********************************************************************/
+        if( filter & ET131X_PACKET_TYPE_BROADCAST )
+        {
+            DBG_VERBOSE( et131x_dbginfo, "Broadcast Filtering ON\n" );
+            pf_ctrl.bits.filter_broad_en = 1;
+            ctrl.bits.pkt_filter_disable    = 0;
+        }
+        else
+        {
+            DBG_VERBOSE( et131x_dbginfo, "Broadcast Filtering OFF\n" );
+            pf_ctrl.bits.filter_broad_en = 0;
+        }
+
+
+        /**********************************************************************
+           Setup the receive mac configuration registers - Packet Filter
+           control + the enable / disable for packet filter in the control
+           reg.
+         *********************************************************************/
+        adapter->CSRAddress->rxmac.pf_ctrl.value = pf_ctrl.value;
+        adapter->CSRAddress->rxmac.ctrl = ctrl;
+    }
+
+    DBG_LEAVE( et131x_dbginfo );
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_multicast
+ ******************************************************************************
+
+   DESCRIPTION       : The handler to configure multicasting on the interface.
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                the device.
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_multicast( struct net_device *netdev )
+{
+    ET131X_ADAPTER     *adapter = NULL;
+    UINT32              PacketFilter = 0;
+    UINT32              count;
+    unsigned long       lockflags;
+    struct dev_mc_list *mclist = netdev->mc_list;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_multicast" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    adapter = netdev_priv( netdev );
+
+
+    spin_lock_irqsave( &adapter->Lock, lockflags );
+
+
+    /**************************************************************************
+       Before we modify the platform-independent filter flags, store them
+       locally. This allows us to determine if anything's changed and if we
+       even need to bother the hardware
+     *************************************************************************/
+    PacketFilter = adapter->PacketFilter;
+
+
+    /**************************************************************************
+       Clear the 'multicast' flag locally; becuase we only have a single flag
+       to check multicast, and multiple multicast addresses can be set, this is
+       the easiest way to determine if more than one multicast address is being
+       set.
+     *************************************************************************/
+    PacketFilter &= ~ET131X_PACKET_TYPE_MULTICAST;
+
+
+    /**************************************************************************
+       Check the net_device flags and set the device independent flags
+       accordingly
+     *************************************************************************/
+    DBG_VERBOSE( et131x_dbginfo,
+                 "MULTICAST ADDR COUNT: %d\n",
+                 netdev->mc_count );
+
+    if( netdev->flags & IFF_PROMISC )
+    {
+        DBG_VERBOSE( et131x_dbginfo, "Request: PROMISCUOUS MODE ON\n" );
+        adapter->PacketFilter |= ET131X_PACKET_TYPE_PROMISCUOUS;
+    }
+    else
+    {
+        DBG_VERBOSE( et131x_dbginfo, "Request: PROMISCUOUS MODE OFF\n" );
+        adapter->PacketFilter &= ~ET131X_PACKET_TYPE_PROMISCUOUS;
+    }
+
+
+    if( netdev->flags & IFF_ALLMULTI )
+    {
+        DBG_VERBOSE( et131x_dbginfo, "Request: ACCEPT ALL MULTICAST\n" );
+        adapter->PacketFilter |= ET131X_PACKET_TYPE_ALL_MULTICAST;
+    }
+
+
+    if( netdev->mc_count > NIC_MAX_MCAST_LIST )
+    {
+        DBG_WARNING( et131x_dbginfo,
+                     "ACCEPT ALL MULTICAST for now, as there's more Multicast "
+                     "addresses than the HW supports\n" );
+
+        adapter->PacketFilter |= ET131X_PACKET_TYPE_ALL_MULTICAST;
+    }
+
+
+    if( netdev->mc_count < 1 )
+    {
+        DBG_VERBOSE( et131x_dbginfo, "Request: REJECT ALL MULTICAST\n" );
+        adapter->PacketFilter &= ~ET131X_PACKET_TYPE_ALL_MULTICAST;
+        adapter->PacketFilter &= ~ET131X_PACKET_TYPE_MULTICAST;
+    }
+    else
+    {
+        DBG_VERBOSE( et131x_dbginfo, "Request: SET MULTICAST FILTER(S)\n" );
+        adapter->PacketFilter |= ET131X_PACKET_TYPE_MULTICAST;
+    }
+
+
+    /**************************************************************************
+       Set values in the private adapter struct
+     *************************************************************************/
+    adapter->MCAddressCount = netdev->mc_count;
+
+    if( netdev->mc_count )
+    {
+        if( mclist->dmi_addrlen != ETH_ALEN )
+        {
+            DBG_WARNING( et131x_dbginfo, "Multicast addrs are not ETH_ALEN in size\n" );
+        }
+        else
+        {
+            count = netdev->mc_count - 1;
+            memcpy( adapter->MCList[count], mclist->dmi_addr, ETH_ALEN );
+        }
+    }
+
+
+    /**************************************************************************
+       Are the new flags different from the previous ones? If not, then no
+       action is required
+
+       NOTE - This block will always update the MCList with the hardware, even
+              if the addresses aren't the same.
+     *************************************************************************/
+    if( PacketFilter != adapter->PacketFilter )
+    {
+        /**********************************************************************
+           Call the device's filter function
+         *********************************************************************/
+        DBG_VERBOSE( et131x_dbginfo,
+                     "UPDATE REQUIRED, FLAGS changed\n" );
+
+        et131x_set_packet_filter( adapter );
+    }
+    else
+    {
+        DBG_VERBOSE( et131x_dbginfo,
+                     "NO UPDATE REQUIRED, FLAGS didn't change\n" );
+    }
+
+
+    spin_unlock_irqrestore( &adapter->Lock, lockflags );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_tx
+ ******************************************************************************
+
+   DESCRIPTION       : The handler called when the Linux network layer wants
+                       to a Tx a packet on the device.
+
+   PARAMETERS        : skb - a pointer to the sk_buff structure which
+                             represents the data to be Tx'd.
+                       netdev - a pointer to a net_device struct representing
+                                the device on which data is to be Tx'd.
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_tx( struct sk_buff *skb, struct net_device *netdev )
+{
+    int             status = 0;
+    ET131X_ADAPTER *adapter;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_tx" );
+    DBG_TX_ENTER( et131x_dbginfo );
+
+
+    adapter = netdev_priv( netdev );
+
+
+    /**************************************************************************
+       Save the timestamp for the TX timeout watchdog
+     *************************************************************************/
+    netdev->trans_start = jiffies;
+
+
+    /**************************************************************************
+       Call the device-specific data Tx routine
+     *************************************************************************/
+    status = et131x_send_packets( skb, netdev );
+
+
+    /**************************************************************************
+       Check status and manage the netif queue if necessary
+     *************************************************************************/
+    if( status != 0 )
+    {
+        if( status == -ENOMEM )
+        {
+            DBG_VERBOSE( et131x_dbginfo, "OUT OF TCBs; STOP NETIF QUEUE\n" );
+
+            /* Put the queue to sleep until resources are available */
+            netif_stop_queue( netdev );
+            status = 1;
+        }
+        else
+        {
+            DBG_WARNING( et131x_dbginfo, "Misc error; drop packet\n" );
+            status = 0;
+        }
+    }
+
+    DBG_TX_LEAVE( et131x_dbginfo );
+    return status;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_tx_timeout
+ ******************************************************************************
+
+   DESCRIPTION       : The handler called when a Tx request times out. The
+                       timeout period is specified by the 'tx_timeo" element in
+                       the net_device structure (see et131x_alloc_device() to
+                       see how this value is set).
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                the device.
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_tx_timeout( struct net_device *netdev )
+{
+    ET131X_ADAPTER     *pAdapter = netdev_priv( netdev );
+    PMP_TCB             pMpTcb;
+    unsigned long       lockflags;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_tx_timeout" );
+    DBG_WARNING( et131x_dbginfo, "TX TIMEOUT\n" );
+
+
+    /**************************************************************************
+       Just skip this part if the adapter is doing link detection
+     *************************************************************************/
+    if( MP_TEST_FLAG( pAdapter, fMP_ADAPTER_LINK_DETECTION ))
+    {
+        DBG_ERROR( et131x_dbginfo, "Still doing link detection\n" );
+        return;
+    }
+
+
+    /**************************************************************************
+       Any nonrecoverable hardware error?
+       Checks adapter->flags for any failure in phy reading
+     *************************************************************************/
+    if( MP_TEST_FLAG( pAdapter, fMP_ADAPTER_NON_RECOVER_ERROR ))
+    {
+        DBG_WARNING( et131x_dbginfo, "Non recoverable error - remove\n" );
+        return;
+    }
+
+
+    /**************************************************************************
+       Hardware failure?
+     *************************************************************************/
+    if( MP_TEST_FLAG( pAdapter, fMP_ADAPTER_HARDWARE_ERROR ))
+    {
+        DBG_WARNING( et131x_dbginfo, "hardware error - reset\n" );
+        return;
+    }
+
+    /**************************************************************************
+        Is send stuck?
+     *************************************************************************/
+    spin_lock_irqsave( &pAdapter->TCBSendQLock, lockflags );
+
+    pMpTcb = pAdapter->TxRing.CurrSendHead;
+
+    if( pMpTcb != NULL )
+    {
+        pMpTcb->Count++;
+
+        if( pMpTcb->Count > NIC_SEND_HANG_THRESHOLD )
+        {
+#if ( ET131X_DBG == 1 )
+            TX_STATUS_BLOCK_t   txDmaComplete = *( pAdapter->TxRing.pTxStatusVa );
+            PTX_DESC_ENTRY_t    pDesc = pAdapter->TxRing.pTxDescRingVa +
+                                        pMpTcb->WrIndex.bits.serv_req;
+#endif
+            TX_DESC_ENTRY_t     StuckDescriptors[10];
+
+            if( pMpTcb->WrIndex.bits.serv_req > 7 )
+            {
+                memcpy( StuckDescriptors,
+                        pAdapter->TxRing.pTxDescRingVa + pMpTcb->WrIndex.bits.serv_req - 6,
+                        sizeof( TX_DESC_ENTRY_t ) * 10 );
+            }
+
+            spin_unlock_irqrestore( &pAdapter->TCBSendQLock, lockflags );
+
+            DBG_WARNING( et131x_dbginfo,
+                         "Send stuck - reset.  pMpTcb->WrIndex %x, Flags 0x%08x\n",
+                         pMpTcb->WrIndex.bits.serv_req, pMpTcb->Flags );
+
+            DBG_WARNING( et131x_dbginfo,
+                         "pDesc 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
+                         pDesc->DataBufferPtrHigh, pDesc->DataBufferPtrLow,
+                         pDesc->word2.value, pDesc->word3.value );
+
+            DBG_WARNING( et131x_dbginfo,
+                         "WbStatus 0x%08x\n",
+                         txDmaComplete.value );
+
+#if ( ET131X_DBG == 1 )
+            DumpDeviceBlock( DBG_WARNING_ON, pAdapter, 0 );
+            DumpDeviceBlock( DBG_WARNING_ON, pAdapter, 1 );
+            DumpDeviceBlock( DBG_WARNING_ON, pAdapter, 3 );
+            DumpDeviceBlock( DBG_WARNING_ON, pAdapter, 5 );
+#endif
+            et131x_close( netdev );
+            et131x_open( netdev );
+
+            return;
+        }
+    }
+
+    spin_unlock_irqrestore( &pAdapter->TCBSendQLock, lockflags );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_change_mtu
+ ******************************************************************************
+
+   DESCRIPTION       : The handler called to change the MTU for the device.
+
+   PARAMETERS        : netdev  - a pointer to a net_device struct representing
+                                 the device whose MTU is to be changed.
+
+                       new_mtu - the desired MTU.
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+int et131x_change_mtu( struct net_device *netdev, int new_mtu )
+{
+    int             result = 0;
+    ET131X_ADAPTER *adapter = NULL;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_change_mtu" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Get the private adapter structure
+     *************************************************************************/
+    adapter = netdev_priv( netdev );
+
+    if( adapter == NULL )
+    {
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENODEV;
+    }
+
+
+    /**************************************************************************
+       Make sure the requested MTU is valid
+     *************************************************************************/
+    if( new_mtu == 0 || new_mtu > 9216 )
+    {
+        DBG_LEAVE( et131x_dbginfo );
+        return -EINVAL;
+    }
+
+
+    /**************************************************************************
+       Stop the netif queue
+     *************************************************************************/
+    netif_stop_queue( netdev );
+
+
+    /**************************************************************************
+       Stop the Tx and Rx DMA engines
+     *************************************************************************/
+    et131x_rx_dma_disable( adapter );
+    et131x_tx_dma_disable( adapter );
+
+
+    /**************************************************************************
+       Disable device interrupts
+     *************************************************************************/
+    et131x_disable_interrupts( adapter );
+    et131x_handle_send_interrupt( adapter );
+    et131x_handle_recv_interrupt( adapter );
+
+
+    /**************************************************************************
+       Set the new MTU
+     *************************************************************************/
+    netdev->mtu = new_mtu;
+
+
+    /**************************************************************************
+       Free Rx DMA memory
+     *************************************************************************/
+    et131x_adapter_memory_free( adapter );
+
+
+    /**************************************************************************
+       Set the config parameter for Jumbo Packet support
+     *************************************************************************/
+    adapter->RegistryJumboPacket = new_mtu + 14;
+    et131x_soft_reset( adapter );
+
+
+    /**************************************************************************
+       Alloc and init Rx DMA memory
+     *************************************************************************/
+    result = et131x_adapter_memory_alloc( adapter );
+    if( result != 0 )
+    {
+        DBG_WARNING( et131x_dbginfo,
+                     "Change MTU failed; couldn't re-alloc DMA memory\n" );
+        return result;
+    }
+
+    et131x_init_send( adapter );
+
+
+    et131x_setup_hardware_properties( adapter );
+    memcpy( netdev->dev_addr, adapter->CurrentAddress, ETH_ALEN );
+    et131x_init_enet_crc_calc( );
+
+
+    /**************************************************************************
+       Init the device with the new settings
+     *************************************************************************/
+    et131x_adapter_setup( adapter );
+
+
+    /**************************************************************************
+       Enable interrupts
+     *************************************************************************/
+    if( MP_TEST_FLAG( adapter, fMP_ADAPTER_INTERRUPT_IN_USE ))
+    {
+        et131x_enable_interrupts( adapter );
+    }
+
+
+    /**************************************************************************
+       Restart the Tx and Rx DMA engines
+     *************************************************************************/
+    et131x_rx_dma_enable( adapter );
+    et131x_tx_dma_enable( adapter );
+
+
+    /**************************************************************************
+       Restart the netif queue
+     *************************************************************************/
+    netif_wake_queue( netdev );
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return result;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_set_mac_addr
+ ******************************************************************************
+
+   DESCRIPTION       : The handler called to change the MAC address for the
+                       device.
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                 the device whose MAC is to be changed.
+
+                       new_mac  - a buffer containing a sock_addr struct in which
+                                the desired MAC address is stored.
+
+   RETURNS           : 0 on success
+                       errno on failure (as defined in errno.h)
+
+   REUSE INFORMATION :
+
+   IMPLEMENTED BY : blux http://berndlux.de 22.01.2007 21:14
+
+ *****************************************************************************/
+int et131x_set_mac_addr( struct net_device *netdev, void *new_mac )
+{
+    int             result = 0;
+    ET131X_ADAPTER *adapter = NULL;
+    struct sockaddr *address = new_mac;
+
+    DBG_FUNC( "et131x_set_mac_addr" );
+    DBG_ENTER( et131x_dbginfo );
+    // begin blux
+    // DBG_VERBOSE( et131x_dbginfo, "Function not implemented!!\n" );
+
+    /*-----------------------------------------------------------------------*/
+
+
+    /**************************************************************************
+       Get the private adapter structure
+     *************************************************************************/
+    adapter = netdev_priv( netdev );
+
+    if( adapter == NULL )
+    {
+        DBG_LEAVE( et131x_dbginfo );
+        return -ENODEV;
+    }
+
+
+    /**************************************************************************
+       Make sure the requested MAC is valid
+     *************************************************************************/
+   if (!is_valid_ether_addr(address->sa_data))
+    {
+        DBG_LEAVE( et131x_dbginfo );
+        return -EINVAL;
+    }
+
+
+    /**************************************************************************
+       Stop the netif queue
+     *************************************************************************/
+    netif_stop_queue( netdev );
+
+
+    /**************************************************************************
+       Stop the Tx and Rx DMA engines
+     *************************************************************************/
+    et131x_rx_dma_disable( adapter );
+    et131x_tx_dma_disable( adapter );
+
+
+    /**************************************************************************
+       Disable device interrupts
+     *************************************************************************/
+    et131x_disable_interrupts( adapter );
+    et131x_handle_send_interrupt( adapter );
+    et131x_handle_recv_interrupt( adapter );
+
+
+    /**************************************************************************
+       Set the new MAC
+     *************************************************************************/
+     //    netdev->set_mac_address  = &new_mac;
+     //  netdev->mtu = new_mtu;
+
+
+        memcpy(netdev->dev_addr, address->sa_data, netdev->addr_len);
+
+        printk("%s: Setting MAC address to %02x:%02x:%02x:%02x:%02x:%02x\n", netdev->name,
+           netdev->dev_addr[0], netdev->dev_addr[1], netdev->dev_addr[2],
+           netdev->dev_addr[3], netdev->dev_addr[4], netdev->dev_addr[5]);
+
+
+    /**************************************************************************
+       Free Rx DMA memory
+     *************************************************************************/
+    et131x_adapter_memory_free( adapter );
+
+
+    /**************************************************************************
+       Set the config parameter for Jumbo Packet support
+     *************************************************************************/
+    //adapter->RegistryJumboPacket = new_mtu + 14;
+    // blux: not needet here, w'll change the MAC
+
+    et131x_soft_reset( adapter );
+
+
+    /**************************************************************************
+       Alloc and init Rx DMA memory
+     *************************************************************************/
+    result = et131x_adapter_memory_alloc( adapter );
+    if( result != 0 )
+    {
+        DBG_WARNING( et131x_dbginfo,
+                     "Change MAC failed; couldn't re-alloc DMA memory\n" );
+        return result;
+    }
+
+    et131x_init_send( adapter );
+
+
+    et131x_setup_hardware_properties( adapter );
+   // memcpy( netdev->dev_addr, adapter->CurrentAddress, ETH_ALEN );
+   // blux: no, do not override our nice address
+    et131x_init_enet_crc_calc( );
+
+
+    /**************************************************************************
+       Init the device with the new settings
+     *************************************************************************/
+    et131x_adapter_setup( adapter );
+
+
+    /**************************************************************************
+       Enable interrupts
+     *************************************************************************/
+    if( MP_TEST_FLAG( adapter, fMP_ADAPTER_INTERRUPT_IN_USE ))
+    {
+        et131x_enable_interrupts( adapter );
+    }
+
+
+    /**************************************************************************
+       Restart the Tx and Rx DMA engines
+     *************************************************************************/
+    et131x_rx_dma_enable( adapter );
+    et131x_tx_dma_enable( adapter );
+
+
+    /**************************************************************************
+       Restart the netif queue
+     *************************************************************************/
+    netif_wake_queue( netdev );
+
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return result;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   NOTE: The ET1310 doesn't support hardware VLAN tagging, so these functions
+         are currently not used; they are in place to eventually support the
+         feature if needed.
+ *****************************************************************************/
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+
+/******************************************************************************
+   ROUTINE :  et131x_vlan_rx_register
+ ******************************************************************************
+
+   DESCRIPTION       : The handler called to enable or disable VLAN support on
+                       the device.
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                the device on which VLAN should be enabled or
+                                disabled.
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_vlan_rx_register( struct net_device *netdev, struct vlan_group *grp )
+{
+    ET131X_ADAPTER     *pAdapter = netdev_priv( netdev );
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_vlan_rx_register" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    /**************************************************************************
+       Track the vlan_group struct in the adapter private structure; if this
+       element is NULL, then VLAN is disabled; otherwise, it is enabled.
+     *************************************************************************/
+    if( grp )
+    {
+        DBG_VERBOSE( et131x_dbginfo, "VLAN: Enable, 0x%p\n", grp );
+    }
+    else
+    {
+        DBG_VERBOSE( et131x_dbginfo, "VLAN: Disable\n" );
+    }
+
+    pAdapter->vlgrp = grp;
+
+
+    /**************************************************************************
+       This is where any interfacing with the hardware to enable or disable
+       VLAN would be done. Since the ET1310 doesn't handle this in hardware,
+       nothing else needs to be done.
+     *************************************************************************/
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_vlan_rx_add_vid
+ ******************************************************************************
+
+   DESCRIPTION       : The handler called to register a VLAN tag.
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                the device on which a VLAN tag should be added.
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_vlan_rx_add_vid( struct net_device *netdev, UINT16 vid )
+{
+    DBG_FUNC( "et131x_vlan_rx_add_vid" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    DBG_VERBOSE( et131x_dbginfo, "VLAN, Add VID: %d\n", vid );
+
+
+    /**************************************************************************
+       This is where any interfacing with the hardware to register VLAN IDs
+       would take place. Since the ET1310 doesn't handle this in hardware,
+       nothing else needs to be done here; the vlan_group structure's
+       vlan_devices element can be used in the TX/RX routines to determine if
+       a VLAN tag has been 'registered' with the device.
+     *************************************************************************/
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_vlan_rx_kill_vid
+ ******************************************************************************
+
+   DESCRIPTION       : The handler called to deregister a VLAN tag.
+
+   PARAMETERS        : netdev - a pointer to a net_device struct representing
+                                the device on which a VLAN tag should be
+                                removed.
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_vlan_rx_kill_vid( struct net_device *netdev, UINT16 vid )
+{
+    ET131X_ADAPTER     *pAdapter = netdev_priv( netdev );
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "et131x_vlan_rx_kill_vid" );
+    DBG_ENTER( et131x_dbginfo );
+
+
+    DBG_VERBOSE( et131x_dbginfo, "VLAN, Remove VID: %d\n", vid );
+
+    if( pAdapter->vlgrp )
+    {
+        pAdapter->vlgrp->vlan_devices_arrays[vid] = NULL;
+    }
+
+
+    /**************************************************************************
+       This is where any interfacing with the hardware to deregister VLAN IDs
+       would take place. Since the ET1310 doesn't handle this in hardware,
+       nothing else needs to be done here.
+     *************************************************************************/
+
+
+    DBG_LEAVE( et131x_dbginfo );
+    return;
+}
+/*===========================================================================*/
+
+#endif
--- /dev/null
+++ b/drivers/net/et131x/et131x_netdev.h
@@ -0,0 +1,91 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_netdev.h - Defines, structs, enums, prototypes, etc. related to the
+ *                   driver's net_device support.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:13 $
+     $Revision: 1.3 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET131X_NETDEV_H__
+#define __ET131X_NETDEV_H__
+
+
+
+
+struct net_device * et131x_device_alloc( void );
+
+void et131x_device_free( struct net_device *netdev );
+
+
+
+
+#endif  /* __ET131X_NETDEV_H__ */
+
--- /dev/null
+++ b/drivers/net/et131x/et131x_supp.c
@@ -0,0 +1,440 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_supp.c - Misc. support routines.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:13 $
+     $Revision: 1.6 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include "et131x_version.h"
+#include "et131x_debug.h"
+#include "et131x_defs.h"
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#include <linux/tqueue.h>
+#endif
+
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+
+#include "ET1310_phy.h"
+#include "ET1310_pm.h"
+#include "ET1310_jagcore.h"
+#include "ET1310_mac.h"
+
+#include "et131x_supp.h"
+
+
+
+
+/******************************************************************************
+   Data for debugging facilities
+ *****************************************************************************/
+#if ET131X_DBG
+extern dbg_info_t *et131x_dbginfo;
+#endif  /* ET131X_DBG */
+
+
+
+
+/******************************************************************************
+   Global look-up table used to calculate CRC.  Preset with the appropriate
+   XORs from the 256 possible byte values that might be in the message.
+ *****************************************************************************/
+static UINT32 SynDrome [256];
+
+
+
+
+/******************************************************************************
+   Prototypes for functions with local scope
+ *****************************************************************************/
+static UINT32 crc32byte( UINT32 remainder, UCHAR data );
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_init_enet_crc_calc
+ ******************************************************************************
+
+   DESCRIPTION       : Initializes the look-up table (syndrome) for CRC
+                       calculation.
+
+   PARAMETERS        : N/A
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void et131x_init_enet_crc_calc( void )
+{
+    UINT32  EthernetKey = 0x04c11db7;
+    UINT32  i;
+    UINT32  j;
+    UINT32  reg;
+    BOOL_t  topBit;
+    /*-----------------------------------------------------------------------*/
+
+
+    for( i = 0; i < 256; i++ )
+    {
+        reg = i << 24;
+
+        for( j = 0; j < 8; j++ )
+        {
+            topBit = ( reg & 0x80000000 ) != 0;
+
+            reg <<= 1;
+
+            if( topBit )
+            {
+                reg ^= EthernetKey;
+            }
+        }
+        SynDrome[i] = reg;
+    }
+
+    return;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  crc32byte
+ ******************************************************************************
+
+   DESCRIPTION       :
+
+   PARAMETERS        :
+
+   RETURNS           :
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+#define CRC32_POLY 0x4C11DB7
+
+static UINT32 crc32byte( UINT32 remainder, UCHAR data )
+{
+    int	   index;
+	UINT32 remndr, hitbit;
+    /*-----------------------------------------------------------------------*/
+
+
+	remndr = remainder;
+
+	for( index = 0; index < 8; index++ )
+    {
+		hitbit = (remndr >> 31) ^ (data & 0x01);
+
+		data   = data >> 1;     // get the next data bit
+		remndr = remndr << 1;   // get the next remainder bit
+
+		if( hitbit )
+        {
+			remndr = remndr ^ CRC32_POLY;
+		}
+	}
+
+	return remndr;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  et131x_calc_enet_crc
+ ******************************************************************************
+
+   DESCRIPTION       : Used to calculate the CRC of an ethernet message. Used
+                       in the device's filtering of multi-cast packets.
+
+   PARAMETERS        : Message     - A pointer to the Ethernet bytes to be encoded
+                       MessageSize - The number of bytes in the message
+
+   RETURNS           : The computed CRC
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+UINT32 et131x_calc_enet_crc( PUCHAR Message, UINT32 MessageSize )
+{
+    UINT32 Result = 0xFFFFFFFF;
+    UINT32 i;
+    /*-----------------------------------------------------------------------*/
+
+    for( i = 0; i < MessageSize; i++ )
+    {
+        Result = crc32byte( Result, *Message );
+        Message++;
+    }
+
+    return Result;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  pci_slot_information_read
+ ******************************************************************************
+
+   DESCRIPTION       : Reads a segment of the PCI configuration space for a
+                       device.
+
+                       This is a port of the NDIS function
+                       NdisReadPciSlotInformation
+
+                       This function does not begin with 'et131x_' in order to
+                       remain consistent with other system pci_xxx() calls.
+
+   PARAMETERS        : pdev  - pointer to a pci_dev structure for the device
+                               whose PCI config space is to be read
+                       where - the offset to read
+                       buf   - a pointer to a buffer in which the data will be
+                               returned
+                       len   - the length of the above buffer
+
+   RETURNS           : The length of the buffer read
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+UINT32 pci_slot_information_read( struct pci_dev *pdev, UINT32 where,
+                                  UINT8 *buf, UINT32 len )
+{
+	int i;
+    int status;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "pci_slot_information_read" );
+
+
+	for( i = 0; i < len; i++ )
+    {
+        status = pci_read_config_byte( pdev, where+i, &buf[i] );
+
+        if( status != 0 )
+        {
+            DBG_ERROR( et131x_dbginfo, "Cannot Read PCI config space...\n" );
+            break;
+        }
+    }
+
+	return len;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  pci_slot_information_write
+ ******************************************************************************
+
+   DESCRIPTION       : Writes a segment of the PCI configuration space for a
+                       device.
+
+                       This is a port of the NDIS function
+                       NdisWritePciSlotInformation
+
+                       This function does not begin with 'et131x_' in order to
+                       remain consistent with other system pci_xxx() calls.
+
+   PARAMETERS        : pdev  - pointer to a pci_dev structure for the device
+                               whose PCI config space is to be written
+                       where - the offset to write
+                       buf   - a pointer to a buffer containing the data to be
+                               written
+                       len   - the length of the above buffer
+
+   RETURNS           : The length of the buffer written
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+UINT32 pci_slot_information_write( struct pci_dev *pdev, UINT32 where,
+                                   UINT8 *buf, UINT32 len )
+{
+	int i;
+    int status;
+    /*-----------------------------------------------------------------------*/
+
+
+    DBG_FUNC( "pci_slot_information_write" );
+
+
+	for( i = 0; i < len; i++ )
+    {
+        status = pci_write_config_byte( pdev, where+i, buf[i] );
+
+        if( status != 0 )
+        {
+            DBG_ERROR( et131x_dbginfo, "Cannot Write PCI config space...\n" );
+            break;
+        }
+    }
+
+	return len;
+}
+/*===========================================================================*/
+
+
+
+
+/******************************************************************************
+   ROUTINE :  netif_indicate_status
+ ******************************************************************************
+
+   DESCRIPTION       : Provides the network stack with link status for the
+                       given device.
+
+                       This is a port of the NDIS function
+                       NdisMIndicateStatus. Unlike NDIS, there is no
+                       corresponding status completion function.
+
+                       This function does not begin with 'et131x_' in order to
+                       remain consistent with other system netif_xxx() calls.
+
+   PARAMETERS        : netdev - a pointer to the net_device struct representing
+                                the device whose status we wosh to indicate.
+                       status - the link status
+
+   RETURNS           : N/A
+
+   REUSE INFORMATION :
+
+ *****************************************************************************/
+void netif_indicate_status( struct net_device *netdev, NETIF_STATUS status )
+{
+    DBG_FUNC( "netif_indicate_status" );
+
+
+    if( netdev != NULL )
+    {
+        switch( status )
+        {
+        case NETIF_STATUS_MEDIA_CONNECT:
+            DBG_VERBOSE( et131x_dbginfo, "Indicating Link UP\n" );
+            netif_carrier_on( netdev );
+            break;
+
+        case NETIF_STATUS_MEDIA_DISCONNECT:
+            DBG_VERBOSE( et131x_dbginfo, "Indicating Link DOWN\n" );
+            netif_carrier_off( netdev );
+            break;
+
+        default:
+            DBG_WARNING( et131x_dbginfo,
+                        "Unknown link status code: %d\n",
+                        status );
+            break;
+        }
+    }
+    else
+    {
+        DBG_WARNING( et131x_dbginfo, "net_device pointer is NULL\n" );
+    }
+
+    return;
+}
+/*===========================================================================*/
--- /dev/null
+++ b/drivers/net/et131x/et131x_supp.h
@@ -0,0 +1,133 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_supp.h - Misc. defines, structs, enums, prototypes, etc.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2005/08/01 19:35:13 $
+     $Revision: 1.5 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+#ifndef __ET131X_SUPP_H__
+#define __ET131X_SUPP_H__
+
+
+
+
+/******************************************************************************
+   Enum for use with netif_indicate_status
+ *****************************************************************************/
+typedef enum netif_status
+{
+    NETIF_STATUS_INVALID           = 0,
+    NETIF_STATUS_MEDIA_CONNECT,
+    NETIF_STATUS_MEDIA_DISCONNECT,
+    NETIF_STATUS_MAX
+} NETIF_STATUS;
+
+
+
+
+/******************************************************************************
+   Definitions to maintain compatibility with older versions of the kernel
+ *****************************************************************************/
+#ifndef netdev_priv
+#define netdev_priv(x)             (ET131X_ADAPTER *)netdev->priv
+#endif
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)
+#endif
+
+#ifndef free_netdev
+#define free_netdev(x)             kfree(x)
+#endif
+
+#ifndef if_mii
+#define if_mii(x)                  (struct mii_ioctl_data *)&x->ifr_ifru
+#endif
+
+
+
+
+/******************************************************************************
+   PROTOTYPES
+ *****************************************************************************/
+void et131x_init_enet_crc_calc( void );
+
+UINT32 et131x_calc_enet_crc( PUCHAR Message, UINT32 MessageSize );
+
+UINT32 pci_slot_information_read( struct pci_dev *pdev, UINT32 where,
+                                  UINT8 *buf, UINT32 len );
+
+UINT32 pci_slot_information_write( struct pci_dev *pdev, UINT32 where,
+                                   UINT8 *buf, UINT32 len );
+
+void netif_indicate_status( struct net_device *netdev, NETIF_STATUS status );
+
+
+
+
+#endif  /* __ET131X_SUPP_H__ */
--- /dev/null
+++ b/drivers/net/et131x/et131x_version.h
@@ -0,0 +1,124 @@
+/*******************************************************************************
+ * Agere Systems Inc.
+ * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *   http://www.agere.com
+ *
+ *------------------------------------------------------------------------------
+ *
+ * et131x_version.h - This file provides system and device version information.
+ *
+ *------------------------------------------------------------------------------
+ *
+ * SOFTWARE LICENSE
+ *
+ * This software is provided subject to the following terms and conditions,
+ * which you should read carefully before using the software.  Using this
+ * software indicates your acceptance of these terms and conditions.  If you do
+ * not agree with these terms and conditions, do not use the software.
+ *
+ * Copyright © 2005 Agere Systems Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source or binary forms, with or without
+ * modifications, are permitted provided that the following conditions are met:
+ *
+ * . Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following Disclaimer as comments in the code as
+ *    well as in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * . Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following Disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * . Neither the name of Agere Systems Inc. nor the names of the contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Disclaimer
+ *
+ * THIS SOFTWARE IS PROVIDED “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, INFRINGEMENT AND THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ANY
+ * USE, MODIFICATION OR DISTRIBUTION OF THIS SOFTWARE IS SOLELY AT THE USERS OWN
+ * RISK. IN NO EVENT SHALL AGERE SYSTEMS INC. OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, INCLUDING, BUT NOT LIMITED TO, CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ ******************************************************************************/
+
+
+
+
+/******************************************************************************
+ *  VERSION CONTROL INFORMATION
+ ******************************************************************************
+
+      $RCSFile: $
+         $Date: 2006/01/31 20:58:43 $
+     $Revision: 1.16 $
+         $Name: T_20060131_v1-2-2 $
+       $Author: vjs $
+
+ *****************************************************************************/
+
+
+
+
+#ifndef __ET131X_VERSION_H__
+#define __ET131X_VERSION_H__
+
+
+
+
+/******************************************************************************
+   Includes
+ *****************************************************************************/
+#include <linux/autoconf.h>
+#include <linux/version.h>
+
+
+
+
+/******************************************************************************
+   Constant Definitions
+ *****************************************************************************/
+#define DRIVER_AUTHOR           "Victor Soriano (vjsoriano@agere.com)"
+#define DRIVER_LICENSE          "Dual BSD/GPL"
+#define DRIVER_DEVICE_STRING    "ET1310"
+#define DRIVER_NAME             "et131x"
+#define DRIVER_MAJOR_VERSION    1
+#define DRIVER_MINOR_VERSION    2
+#define DRIVER_PATCH_VERSION    3
+#define DRIVER_VERSION_STRING   "1.2.3"
+#define DRIVER_VENDOR           "Agere Systems, http://www.agere.com"
+#define DRIVER_BUILD_DATE       "01/31/2006 15:40:00"
+#define DRIVER_DESC             "10/100/1000 Base-T Ethernet Driver"
+
+#define STRUCT_MODULE           "net" // blux: missed by the kernel
+
+#define DRIVER_INFO             DRIVER_DESC " for the "\
+                                DRIVER_DEVICE_STRING ", v" \
+                                DRIVER_VERSION_STRING " " \
+                                DRIVER_BUILD_DATE " by " \
+                                DRIVER_VENDOR
+
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION( 2,6,0 ))
+#define DRIVER_NAME_EXT         "et131x.o"
+#else
+#define DRIVER_NAME_EXT         "et131x.ko"
+#endif
+
+
+
+
+#endif  /* __ET131X_VERSION_H__ */
