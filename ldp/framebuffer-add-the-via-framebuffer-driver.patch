From b4cea74f040dc0aacf0ff0474483fd0cb12ad87d Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Tue, 6 May 2008 13:49:17 -0700
Subject: Framebuffer: add the VIA framebuffer driver

TODO:
	- remove globals that don't need to be global
	- put proper prefixes on remaining globals
	- possibly merge some of the files together
	- fix compiler warnings
	- minor coding style cleanups

Cc: Benjamin Pan <BenjaminPan@viatech.com>
Cc: Timothy Chen <TimothyChen@viatech.com>
Cc: Bruce Chang <BruceChang@via.com.tw>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/video/Kconfig               |    6 
 drivers/video/Makefile              |    1 
 drivers/video/viafb/Makefile        |    9 
 drivers/video/viafb/accel.c         |  245 +++
 drivers/video/viafb/accel.h         |  190 ++
 drivers/video/viafb/chip.h          |  189 ++
 drivers/video/viafb/debug.h         |   41 
 drivers/video/viafb/dvi.c           |  723 ++++++++
 drivers/video/viafb/dvi.h           |   69 
 drivers/video/viafb/global.c        |  170 ++
 drivers/video/viafb/global.h        |   98 +
 drivers/video/viafb/hw.c            | 2934 ++++++++++++++++++++++++++++++++++++
 drivers/video/viafb/hw.h            |  950 +++++++++++
 drivers/video/viafb/iface.c         |   78 
 drivers/video/viafb/iface.h         |   38 
 drivers/video/viafb/ioctl.c         |  111 +
 drivers/video/viafb/ioctl.h         |  212 ++
 drivers/video/viafb/lcd.c           | 2307 ++++++++++++++++++++++++++++
 drivers/video/viafb/lcd.h           |  119 +
 drivers/video/viafb/share.h         | 1113 +++++++++++++
 drivers/video/viafb/tbl1636.c       |   71 
 drivers/video/viafb/tbl1636.h       |   34 
 drivers/video/viafb/tblDPASetting.c |  109 +
 drivers/video/viafb/tblDPASetting.h |   47 
 drivers/video/viafb/via_i2c.c       |  469 +++++
 drivers/video/viafb/via_i2c.h       |   51 
 drivers/video/viafb/via_utility.c   |  299 +++
 drivers/video/viafb/via_utility.h   |   35 
 drivers/video/viafb/viafb.modes     |  870 ++++++++++
 drivers/video/viafb/viafbdev.c      | 2775 ++++++++++++++++++++++++++++++++++
 drivers/video/viafb/viafbdev.h      |  113 +
 drivers/video/viafb/viamode.c       | 1086 +++++++++++++
 drivers/video/viafb/viamode.h       |  177 ++
 drivers/video/viafb/vt1636.c        |  317 +++
 drivers/video/viafb/vt1636.h        |   47 
 35 files changed, 16103 insertions(+)

--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1953,6 +1953,12 @@ config FB_AM200EPD
          This enables support for the Metronome display controller used on
          the E-Ink AM-200 EPD devkit.
 
+config FB_VIA
+	tristate "Via Framebuffer support"
+	depends on FB
+	help
+	  This enables support for a large number of VIA framebuffer devices.
+
 config FB_VIRTUAL
 	tristate "Virtual Frame Buffer support (ONLY FOR TESTING!)"
 	depends on FB
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -117,6 +117,7 @@ obj-$(CONFIG_FB_SM501)            += sm5
 obj-$(CONFIG_FB_XILINX)           += xilinxfb.o
 obj-$(CONFIG_FB_OMAP)             += omap/
 obj-$(CONFIG_XEN_FBDEV_FRONTEND)  += xen-fbfront.o
+obj-$(CONFIG_FB_VIA)              += viafb/
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
--- /dev/null
+++ b/drivers/video/viafb/accel.c
@@ -0,0 +1,245 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "global.h"
+
+void init_accel(void)
+{
+	parinfo.cursor_start = parinfo.fbmem_free - CURSOR_SIZE;
+	parinfo.fbmem_free -= CURSOR_SIZE;
+	parinfo.fbmem_used += CURSOR_SIZE;
+
+	/* Reverse 8*1024 memory space for cursor image of the XServer */
+	parinfo.VQ_start = parinfo.fbmem_free - CURSOR_SIZE - VQ_SIZE;
+	parinfo.VQ_end = parinfo.VQ_start + VQ_SIZE - 1;
+	parinfo.fbmem_free -= (CURSOR_SIZE + VQ_SIZE);
+	parinfo.fbmem_used += (CURSOR_SIZE + VQ_SIZE);
+}
+
+void init_2d_engine(void)
+{
+	u32 dwVQStartAddr, dwVQEndAddr;
+	u32 dwVQLen, dwVQStartL, dwVQEndL, dwVQStartEndH;
+
+	/* init 2D engine regs to reset 2D engine */
+	MMIO_OUT32(VIA_REG_GEMODE, 0x0);
+	MMIO_OUT32(VIA_REG_SRCPOS, 0x0);
+	MMIO_OUT32(VIA_REG_DSTPOS, 0x0);
+	MMIO_OUT32(VIA_REG_DIMENSION, 0x0);
+	MMIO_OUT32(VIA_REG_PATADDR, 0x0);
+	MMIO_OUT32(VIA_REG_FGCOLOR, 0x0);
+	MMIO_OUT32(VIA_REG_BGCOLOR, 0x0);
+	MMIO_OUT32(VIA_REG_CLIPTL, 0x0);
+	MMIO_OUT32(VIA_REG_CLIPBR, 0x0);
+	MMIO_OUT32(VIA_REG_OFFSET, 0x0);
+	MMIO_OUT32(VIA_REG_KEYCONTROL, 0x0);
+	MMIO_OUT32(VIA_REG_SRCBASE, 0x0);
+	MMIO_OUT32(VIA_REG_DSTBASE, 0x0);
+	MMIO_OUT32(VIA_REG_PITCH, 0x0);
+	MMIO_OUT32(VIA_REG_MONOPAT1, 0x0);
+
+	/* Init AGP and VQ regs */
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_K8M890:
+	case UNICHROME_P4M900:
+		MMIO_OUT32(0x41c, 0x00100000);
+		MMIO_OUT32(0x420, 0x680A0000);
+		MMIO_OUT32(0x420, 0x02000000);
+		break;
+
+	default:
+		MMIO_OUT32(VIA_REG_TRANSET, 0x00100000);
+		MMIO_OUT32(VIA_REG_TRANSPACE, 0x00000000);
+		MMIO_OUT32(VIA_REG_TRANSPACE, 0x00333004);
+		MMIO_OUT32(VIA_REG_TRANSPACE, 0x60000000);
+		MMIO_OUT32(VIA_REG_TRANSPACE, 0x61000000);
+		MMIO_OUT32(VIA_REG_TRANSPACE, 0x62000000);
+		MMIO_OUT32(VIA_REG_TRANSPACE, 0x63000000);
+		MMIO_OUT32(VIA_REG_TRANSPACE, 0x64000000);
+		MMIO_OUT32(VIA_REG_TRANSPACE, 0x7D000000);
+
+		MMIO_OUT32(VIA_REG_TRANSET, 0xFE020000);
+		MMIO_OUT32(VIA_REG_TRANSPACE, 0x00000000);
+		break;
+	}
+	if (parinfo.VQ_start != 0) {
+		/* Enable VQ */
+		dwVQStartAddr = parinfo.VQ_start;
+		dwVQEndAddr = parinfo.VQ_end;
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M900:
+			dwVQStartL = 0x70000000 | (dwVQStartAddr & 0xFFFFFF);
+			dwVQEndL = 0x71000000 | (dwVQEndAddr & 0xFFFFFF);
+			dwVQStartEndH =
+			    0x72000000 | ((dwVQStartAddr & 0xFF000000) >>
+					  24) | ((dwVQEndAddr & 0xFF000000)
+						 >> 16);
+			dwVQLen = 0x73000000 | (VQ_SIZE >> 3);
+			break;
+		default:
+			dwVQStartL = 0x50000000 | (dwVQStartAddr & 0xFFFFFF);
+			dwVQEndL = 0x51000000 | (dwVQEndAddr & 0xFFFFFF);
+			dwVQStartEndH =
+			    0x52000000 | ((dwVQStartAddr & 0xFF000000) >>
+					  24) | ((dwVQEndAddr & 0xFF000000)
+						 >> 16);
+			dwVQLen = 0x53000000 | (VQ_SIZE >> 3);
+			break;
+		}
+
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M900:
+			MMIO_OUT32(0x41c, 0x00100000);
+			MMIO_OUT32(0x420, dwVQStartEndH);
+			MMIO_OUT32(0x420, dwVQStartL);
+			MMIO_OUT32(0x420, dwVQEndL);
+			MMIO_OUT32(0x420, dwVQLen);
+			MMIO_OUT32(0x420, 0x74301001);
+			MMIO_OUT32(0x420, 0x00000000);
+			break;
+		default:
+			MMIO_OUT32(VIA_REG_TRANSET, 0x00FE0000);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x080003FE);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x0A00027C);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x0B000260);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x0C000274);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x0D000264);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x0E000000);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x0F000020);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x1000027E);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x110002FE);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x200F0060);
+
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x00000006);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x40008C0F);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x44000000);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x45080C04);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x46800408);
+
+			MMIO_OUT32(VIA_REG_TRANSPACE, dwVQStartEndH);
+			MMIO_OUT32(VIA_REG_TRANSPACE, dwVQStartL);
+			MMIO_OUT32(VIA_REG_TRANSPACE, dwVQEndL);
+			MMIO_OUT32(VIA_REG_TRANSPACE, dwVQLen);
+			break;
+		}
+	} else {
+		/* Diable VQ */
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M900:
+			MMIO_OUT32(0x41c, 0x00100000);
+			MMIO_OUT32(0x420, 0x74301000);
+			break;
+		default:
+			MMIO_OUT32(VIA_REG_TRANSET, 0x00FE0000);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x00000004);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x40008C0F);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x44000000);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x45080C04);
+			MMIO_OUT32(VIA_REG_TRANSPACE, 0x46800408);
+			break;
+		}
+	}
+
+	set_2d_color_depth(parinfo.bpp);
+
+	MMIO_OUT32(VIA_REG_SRCBASE, 0x0);
+	MMIO_OUT32(VIA_REG_DSTBASE, 0x0);
+
+	MMIO_OUT32(VIA_REG_PITCH,
+		   VIA_PITCH_ENABLE |
+		   (((parinfo.hres *
+		      parinfo.bpp >> 3) >> 3) | (((parinfo.hres *
+						   parinfo.
+						   bpp >> 3) >> 3) << 16)));
+}
+
+void set_2d_color_depth(int bpp)
+{
+	u32 dwGEMode;
+
+	dwGEMode = MMIO_IN32(0x04) & 0xFFFFFCFF;
+
+	switch (bpp) {
+	case 16:
+		dwGEMode |= VIA_GEM_16bpp;
+		break;
+	case 32:
+		dwGEMode |= VIA_GEM_32bpp;
+		break;
+	default:
+		dwGEMode |= VIA_GEM_8bpp;
+		break;
+	}
+
+	/* Set BPP and Pitch */
+	MMIO_OUT32(VIA_REG_GEMODE, dwGEMode);
+}
+
+void hw_cursor_init(void)
+{
+	/* Set Cursor Image Base Address */
+	MMIO_OUT32(VIA_REG_CURSOR_MODE, parinfo.cursor_start);
+	MMIO_OUT32(VIA_REG_CURSOR_POS, 0x0);
+	MMIO_OUT32(VIA_REG_CURSOR_ORG, 0x0);
+	MMIO_OUT32(VIA_REG_CURSOR_BG, 0x0);
+	MMIO_OUT32(VIA_REG_CURSOR_FG, 0x0);
+}
+
+void show_hw_cursor(struct fb_info *info, int Status)
+{
+	u32 temp;
+	u32 iga_path = ((struct viafb_par *)(info->par))->iga_path;
+
+	temp = MMIO_IN32(VIA_REG_CURSOR_MODE);
+	switch (Status) {
+	case HW_Cursor_ON:
+		temp |= 0x1;
+		break;
+	case HW_Cursor_OFF:
+		temp &= 0xFFFFFFFE;
+		break;
+	}
+	switch (iga_path) {
+	case IGA2:
+		temp |= 0x80000000;
+		break;
+	case IGA1:
+	default:
+		temp &= 0x7FFFFFFF;
+	}
+	MMIO_OUT32(VIA_REG_CURSOR_MODE, temp);
+}
+
+int wait_engine_idle(void)
+{
+	int loop = 0;
+
+	while (!(MMIO_IN32(VIA_REG_STATUS) & VIA_VR_QUEUE_BUSY)
+	       && (loop++ < MAXLOOP)) ;
+
+	while ((MMIO_IN32(VIA_REG_STATUS) &
+		(VIA_CMD_RGTR_BUSY | VIA_2D_ENG_BUSY | VIA_3D_ENG_BUSY)) &&
+	       (loop++ < MAXLOOP)) ;
+
+	return loop >= MAXLOOP;
+}
--- /dev/null
+++ b/drivers/video/viafb/accel.h
@@ -0,0 +1,190 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __ACCEL_H__
+#define __ACCEL_H__
+
+#ifndef FB_ACCEL_VIA_UNICHROME
+#define FB_ACCEL_VIA_UNICHROME  50
+#endif
+
+/* MMIO Base Address Definition */
+#define MMIO_VGABASE                0x8000
+#define MMIO_CR_READ                MMIO_VGABASE + 0x3D4
+#define MMIO_CR_WRITE               MMIO_VGABASE + 0x3D5
+#define MMIO_SR_READ                MMIO_VGABASE + 0x3C4
+#define MMIO_SR_WRITE               MMIO_VGABASE + 0x3C5
+
+#ifndef VIA_MMIO
+#define VIA_MMIO 1
+#endif
+
+#if VIA_MMIO
+#define MMIO_OUT8(reg, val)  writeb(val, parinfo.io_virt + reg)
+#define MMIO_OUT16(reg, val) writew(val, parinfo.io_virt + reg)
+#define MMIO_OUT32(reg, val) writel(val, parinfo.io_virt + reg)
+#define MMIO_IN8(reg)       readb(parinfo.io_virt + reg)
+#define MMIO_IN16(reg)      readw(parinfo.io_virt + reg)
+#define MMIO_IN32(reg)      readl(parinfo.io_virt + reg)
+
+#else
+#define MMIO_OUT8(reg, val)  outb(val, reg)
+#define MMIO_OUT16(reg, val) outw(val, reg)
+#define MMIO_OUT32(reg, val) outl(val, reg)
+#define MMIO_IN8(reg)       inb(reg)
+#define MMIO_IN16(reg)      inw(reg)
+#define MMIO_IN32(reg)      inl(reg)
+#endif
+
+/* HW Cursor Status Define */
+#define HW_Cursor_ON    0
+#define HW_Cursor_OFF   1
+
+#define CURSOR_SIZE     (8 * 1024)
+#define VQ_SIZE         (256 * 1024)
+
+#define VIA_MMIO_BLTBASE        0x200000
+#define VIA_MMIO_BLTSIZE        0x200000
+
+/* Defines for 2D registers */
+#define VIA_REG_GECMD           0x000
+#define VIA_REG_GEMODE          0x004
+#define VIA_REG_SRCPOS          0x008
+#define VIA_REG_DSTPOS          0x00C
+/* width and height */
+#define VIA_REG_DIMENSION       0x010
+#define VIA_REG_PATADDR         0x014
+#define VIA_REG_FGCOLOR         0x018
+#define VIA_REG_BGCOLOR         0x01C
+/* top and left of clipping */
+#define VIA_REG_CLIPTL          0x020
+/* bottom and right of clipping */
+#define VIA_REG_CLIPBR          0x024
+#define VIA_REG_OFFSET          0x028
+/* color key control */
+#define VIA_REG_KEYCONTROL      0x02C
+#define VIA_REG_SRCBASE         0x030
+#define VIA_REG_DSTBASE         0x034
+/* pitch of src and dst */
+#define VIA_REG_PITCH           0x038
+#define VIA_REG_MONOPAT0        0x03C
+#define VIA_REG_MONOPAT1        0x040
+/* from 0x100 to 0x1ff */
+#define VIA_REG_COLORPAT        0x100
+
+/* VIA_REG_PITCH(0x38): Pitch Setting */
+#define VIA_PITCH_ENABLE        0x80000000
+
+/* defines for VIA HW cursor registers */
+#define VIA_REG_CURSOR_MODE     0x2D0
+#define VIA_REG_CURSOR_POS      0x2D4
+#define VIA_REG_CURSOR_ORG      0x2D8
+#define VIA_REG_CURSOR_BG       0x2DC
+#define VIA_REG_CURSOR_FG       0x2E0
+
+/* VIA_REG_GEMODE(0x04): GE mode */
+#define VIA_GEM_8bpp            0x00000000
+#define VIA_GEM_16bpp           0x00000100
+#define VIA_GEM_32bpp           0x00000300
+
+/* VIA_REG_GECMD(0x00): 2D Engine Command  */
+#define VIA_GEC_NOOP            0x00000000
+#define VIA_GEC_BLT             0x00000001
+#define VIA_GEC_LINE            0x00000005
+
+/* Rotate Command */
+#define VIA_GEC_ROT             0x00000008
+
+#define VIA_GEC_SRC_XY          0x00000000
+#define VIA_GEC_SRC_LINEAR      0x00000010
+#define VIA_GEC_DST_XY          0x00000000
+#define VIA_GEC_DST_LINRAT      0x00000020
+
+#define VIA_GEC_SRC_FB          0x00000000
+#define VIA_GEC_SRC_SYS         0x00000040
+#define VIA_GEC_DST_FB          0x00000000
+#define VIA_GEC_DST_SYS         0x00000080
+
+/* source is mono */
+#define VIA_GEC_SRC_MONO        0x00000100
+/* pattern is mono */
+#define VIA_GEC_PAT_MONO        0x00000200
+/* mono src is opaque */
+#define VIA_GEC_MSRC_OPAQUE     0x00000000
+/* mono src is transparent */
+#define VIA_GEC_MSRC_TRANS      0x00000400
+/* pattern is in frame buffer */
+#define VIA_GEC_PAT_FB          0x00000000
+/* pattern is from reg setting */
+#define VIA_GEC_PAT_REG         0x00000800
+
+#define VIA_GEC_CLIP_DISABLE    0x00000000
+#define VIA_GEC_CLIP_ENABLE     0x00001000
+
+#define VIA_GEC_FIXCOLOR_PAT    0x00002000
+
+#define VIA_GEC_INCX            0x00000000
+#define VIA_GEC_DECY            0x00004000
+#define VIA_GEC_INCY            0x00000000
+#define VIA_GEC_DECX            0x00008000
+/* mono pattern is opaque */
+#define VIA_GEC_MPAT_OPAQUE     0x00000000
+/* mono pattern is transparent */
+#define VIA_GEC_MPAT_TRANS      0x00010000
+
+#define VIA_GEC_MONO_UNPACK     0x00000000
+#define VIA_GEC_MONO_PACK       0x00020000
+#define VIA_GEC_MONO_DWORD      0x00000000
+#define VIA_GEC_MONO_WORD       0x00040000
+#define VIA_GEC_MONO_BYTE       0x00080000
+
+#define VIA_GEC_LASTPIXEL_ON    0x00000000
+#define VIA_GEC_LASTPIXEL_OFF   0x00100000
+#define VIA_GEC_X_MAJOR         0x00000000
+#define VIA_GEC_Y_MAJOR         0x00200000
+#define VIA_GEC_QUICK_START     0x00800000
+
+/* defines for VIA 3D registers */
+#define VIA_REG_STATUS          0x400
+#define VIA_REG_TRANSET         0x43C
+#define VIA_REG_TRANSPACE       0x440
+
+/* VIA_REG_STATUS(0x400): Engine Status */
+
+/* Command Regulator is busy */
+#define VIA_CMD_RGTR_BUSY       0x00000080
+/* 2D Engine is busy */
+#define VIA_2D_ENG_BUSY         0x00000002
+/* 3D Engine is busy */
+#define VIA_3D_ENG_BUSY         0x00000001
+/* Virtual Queue is busy */
+#define VIA_VR_QUEUE_BUSY       0x00020000
+
+#define MAXLOOP                 0xFFFFFF
+
+void init_accel(void);
+void init_2d_engine(void);
+void set_2d_color_depth(int);
+void hw_cursor_init(void);
+void show_hw_cursor(struct fb_info *info, int Status);
+int wait_engine_idle(void);
+
+#endif /* __ACCEL_H__ */
--- /dev/null
+++ b/drivers/video/viafb/chip.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __CHIP_H__
+#define __CHIP_H__
+
+#include "global.h"
+
+/***************************************/
+/* Definition Graphic Chip Information */
+/***************************************/
+
+#define     PCI_VIA_VENDOR_ID       0x1106
+
+/* Define VIA Graphic Chip Name */
+#define     UNICHROME_CLE266        1
+#define     UNICHROME_CLE266_DID    0x3122
+#define     CLE266_REVISION_AX      0x0A
+#define     CLE266_REVISION_CX      0x0C
+
+#define     UNICHROME_K400          2
+#define     UNICHROME_K400_DID      0x7205
+
+#define     UNICHROME_K800          3
+#define     UNICHROME_K800_DID      0x3108
+
+#define     UNICHROME_PM800          4
+#define     UNICHROME_PM800_DID      0x3118
+
+#define     UNICHROME_CN700         5
+#define     UNICHROME_CN700_DID     0x3344
+
+#define     UNICHROME_CX700         6
+#define     UNICHROME_CX700_DID     0x3157
+#define     CX700_REVISION_700         0x0
+#define     CX700_REVISION_700M      0x1
+#define     CX700_REVISION_700M2    0x2
+
+#define     UNICHROME_CN750         7
+#define     UNICHROME_CN750_DID     0x3225
+
+#define     UNICHROME_K8M890        8
+#define     UNICHROME_K8M890_DID    0x3230
+
+#define     UNICHROME_P4M890        9
+#define     UNICHROME_P4M890_DID    0x3343
+
+#define     UNICHROME_P4M900        10
+#define     UNICHROME_P4M900_DID    0x3371
+
+#define     UNICHROME_VX800         11
+#define     UNICHROME_VX800_DID     0x1122
+/**************************************************/
+/* Definition TMDS Trasmitter Information         */
+/**************************************************/
+
+/* Definition TMDS Trasmitter Index */
+#define     NON_TMDS_TRANSMITTER    0x00
+#define     VT1632_TMDS             0x01
+#define     INTEGRATED_TMDS         0x42
+
+/* Definition TMDS Trasmitter I2C Slave Address */
+#define     VT1632_TMDS_I2C_ADDR    0x10
+
+/**************************************************/
+/* Definition LVDS Trasmitter Information         */
+/**************************************************/
+
+/* Definition LVDS Trasmitter Index */
+#define     NON_LVDS_TRANSMITTER    0x00
+#define     VT1631_LVDS             0x01
+#define     VT1636_LVDS             0x0E
+#define     INTEGRATED_LVDS         0x41
+
+/* Definition Digital Transmitter Mode */
+#define     TX_DATA_12_BITS         0x01
+#define     TX_DATA_24_BITS         0x02
+#define     TX_DATA_DDR_MODE        0x04
+#define     TX_DATA_SDR_MODE        0x08
+
+/* Definition LVDS Trasmitter I2C Slave Address */
+#define     VT1631_LVDS_I2C_ADDR    0x70
+#define     VT3271_LVDS_I2C_ADDR    0x80
+#define     VT1636_LVDS_I2C_ADDR    0x80
+
+struct tmds_chip_information {
+	int tmds_chip_name;
+	int tmds_chip_slave_addr;
+	int dvi_panel_id;
+	int data_mode;
+	int output_interface;
+	int i2c_port;
+	int device_type;
+};
+
+struct lvds_chip_information {
+	int lvds_chip_name;
+	int lvds_chip_slave_addr;
+	int data_mode;
+	int output_interface;
+	int i2c_port;
+};
+
+struct chip_information {
+	int gfx_chip_name;
+	int gfx_chip_revision;
+	int chip_on_slot;
+	struct tmds_chip_information tmds_chip_info;
+	struct lvds_chip_information lvds_chip_info;
+	struct lvds_chip_information lvds_chip_info2;
+};
+
+struct crt_setting_information {
+	int iga_path;
+	int h_active;
+	int v_active;
+	int bpp;
+	int refresh_rate;
+};
+
+struct tmds_setting_information {
+	int iga_path;
+	int h_active;
+	int v_active;
+	int bpp;
+	int refresh_rate;
+	int get_dvi_size_method;
+	int max_pixel_clock;
+	int dvi_panel_size;
+	int dvi_panel_hres;
+	int dvi_panel_vres;
+	int native_size;
+};
+
+struct lvds_setting_information {
+	int iga_path;
+	int h_active;
+	int v_active;
+	int bpp;
+	int refresh_rate;
+	int get_lcd_size_method;
+	int lcd_panel_id;
+	int lcd_panel_size;
+	int lcd_panel_hres;
+	int lcd_panel_vres;
+	int display_method;
+	int device_lcd_dualedge;
+	int LCDDithering;
+	int lcd_mode;
+	u32 vclk;		/*panel mode clock value */
+};
+
+struct GFX_DPA_SETTING {
+	int ClkRangeIndex;
+	u8 DVP0;		/* CR96[3:0] */
+	u8 DVP0DataDri_S1;	/* SR2A[5]   */
+	u8 DVP0DataDri_S;	/* SR1B[1]   */
+	u8 DVP0ClockDri_S1;	/* SR2A[4]   */
+	u8 DVP0ClockDri_S;	/* SR1E[2]   */
+	u8 DVP1;		/* CR9B[3:0] */
+	u8 DVP1Driving;		/* SR65[3:0], Data and Clock driving */
+	u8 DFPHigh;		/* CR97[3:0] */
+	u8 DFPLow;		/* CR99[3:0] */
+
+};
+
+struct VT1636_DPA_SETTING {
+	int PanelSizeID;
+	u8 CLK_SEL_ST1;
+	u8 CLK_SEL_ST2;
+};
+#endif /* __CHIP_H__ */
--- /dev/null
+++ b/drivers/video/viafb/debug.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+#ifndef VIAFB_DEBUG
+#define VIAFB_DEBUG 1
+#endif
+
+#if VIAFB_DEBUG
+#define DEBUG_MSG(f, a...)   printk(f, ## a)
+#else
+#define DEBUG_MSG(f, a...)
+#endif
+
+#define VIAFB_WARN 0
+#if VIAFB_WARN
+#define WARN_MSG(f, a...)   printk(f, ## a)
+#else
+#define WARN_MSG(f, a...)
+#endif
+
+#endif /* __DEBUG_H__ */
--- /dev/null
+++ b/drivers/video/viafb/dvi.c
@@ -0,0 +1,723 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "global.h"
+
+int check_tmds_chip(int device_id_subaddr, int device_id)
+{
+	if (tmds_register_read(device_id_subaddr) == device_id)
+		return (OK);
+	else
+		return (FAIL);
+}
+
+void init_dvi_size(void)
+{
+	DEBUG_MSG(KERN_INFO "init_dvi_size()\n");
+	DEBUG_MSG(KERN_INFO "tmds_setting_info.get_dvi_size_method %d\n",
+		  tmds_setting_info.get_dvi_size_method);
+
+	switch (tmds_setting_info.get_dvi_size_method) {
+	case GET_DVI_SIZE_BY_SYSTEM_BIOS:
+		break;
+	case GET_DVI_SZIE_BY_HW_STRAPPING:
+		break;
+	case GET_DVI_SIZE_BY_VGA_BIOS:
+	default:
+		dvi_get_panel_info();
+		break;
+	}
+	return;
+}
+
+int tmds_trasmitter_identify(void)
+{
+	unsigned char sr2a = 0, sr1e = 0, sr3e = 0;
+
+	/* Turn on ouputting pad */
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_K8M890:
+	    /*=* DFP Low Pad on *=*/
+		sr2a = read_reg(VIASR, SR2A);
+		write_reg_mask(SR2A, VIASR, 0x03, BIT0 + BIT1);
+		break;
+
+	case UNICHROME_P4M900:
+	case UNICHROME_P4M890:
+		/* DFP Low Pad on */
+		sr2a = read_reg(VIASR, SR2A);
+		write_reg_mask(SR2A, VIASR, 0x03, BIT0 + BIT1);
+		/* DVP0 Pad on */
+		sr1e = read_reg(VIASR, SR1E);
+		write_reg_mask(SR1E, VIASR, 0xC0, BIT6 + BIT7);
+		break;
+
+	default:
+	    /* DVP0/DVP1 Pad on */
+		sr1e = read_reg(VIASR, SR1E);
+		write_reg_mask(SR1E, VIASR, 0xF0, BIT4 + BIT5 + BIT6 + BIT7);
+	    /* SR3E[1]Multi-function selection:
+	    0 = Emulate I2C and DDC bus by GPIO2/3/4. */
+		sr3e = read_reg(VIASR, SR3E);
+		write_reg_mask(SR3E, VIASR, 0x0, BIT5);
+		break;
+	}
+
+	/* Check for VT1632: */
+	chip_info.tmds_chip_info.tmds_chip_name = VT1632_TMDS;
+	chip_info.tmds_chip_info.tmds_chip_slave_addr = VT1632_TMDS_I2C_ADDR;
+	chip_info.tmds_chip_info.i2c_port = I2CPORTINDEX;
+	if (check_tmds_chip(VT1632_DEVICE_ID_REG, VT1632_DEVICE_ID) != FAIL) {
+	/*Currently only support 12bits,dual edge,add 24bits mode later */
+		tmds_register_write(0x08, 0x3b);
+
+		DEBUG_MSG(KERN_INFO "\n VT1632 TMDS ! \n");
+		DEBUG_MSG(KERN_INFO "\n %2d",
+			  chip_info.tmds_chip_info.tmds_chip_name);
+		DEBUG_MSG(KERN_INFO "\n %2d",
+			  chip_info.tmds_chip_info.i2c_port);
+		return (OK);
+	} else {
+		chip_info.tmds_chip_info.i2c_port = GPIOPORTINDEX;
+		if (check_tmds_chip(VT1632_DEVICE_ID_REG, VT1632_DEVICE_ID)
+		    != FAIL) {
+			tmds_register_write(0x08, 0x3b);
+			DEBUG_MSG(KERN_INFO "\n VT1632 TMDS ! \n");
+			DEBUG_MSG(KERN_INFO "\n %2d",
+				  chip_info.tmds_chip_info.tmds_chip_name);
+			DEBUG_MSG(KERN_INFO "\n %2d",
+				  chip_info.tmds_chip_info.i2c_port);
+			return (OK);
+		}
+	}
+
+	chip_info.tmds_chip_info.tmds_chip_name = INTEGRATED_TMDS;
+
+	if ((chip_info.gfx_chip_name == UNICHROME_CX700) &&
+	    ((display_hardware_layout == HW_LAYOUT_DVI_ONLY) ||
+	     (display_hardware_layout == HW_LAYOUT_LCD_DVI))) {
+		DEBUG_MSG(KERN_INFO "\n Integrated TMDS ! \n");
+		return (OK);
+	}
+
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_K8M890:
+		write_reg(SR2A, VIASR, sr2a);
+		break;
+
+	case UNICHROME_P4M900:
+	case UNICHROME_P4M890:
+		write_reg(SR2A, VIASR, sr2a);
+		write_reg(SR1E, VIASR, sr1e);
+		break;
+
+	default:
+		write_reg(SR1E, VIASR, sr1e);
+		write_reg(SR3E, VIASR, sr3e);
+		break;
+	}
+
+	chip_info.tmds_chip_info.tmds_chip_name = NON_TMDS_TRANSMITTER;
+	chip_info.tmds_chip_info.tmds_chip_slave_addr = VT1632_TMDS_I2C_ADDR;
+	return (FAIL);
+}
+
+void tmds_register_write(int index, u8 data)
+{
+	u8 tmp;
+
+	tmp = chip_info.chip_on_slot;
+	switch (chip_info.tmds_chip_info.i2c_port) {
+	case I2CPORTINDEX:
+		chip_info.chip_on_slot = PORT_ON_AMR;
+		break;
+
+	case GPIOPORTINDEX:
+	default:
+		chip_info.chip_on_slot = PORT_ON_AGP;
+		break;
+	}
+
+	i2cWriteByte(chip_info.tmds_chip_info.tmds_chip_slave_addr, index,
+		     data);
+
+	chip_info.chip_on_slot = tmp;
+
+}
+
+int tmds_register_read(int index)
+{
+	u8 data;
+	int status;
+	u8 tmp;
+
+	tmp = chip_info.chip_on_slot;
+	switch (chip_info.tmds_chip_info.i2c_port) {
+	case I2CPORTINDEX:
+		chip_info.chip_on_slot = PORT_ON_AMR;
+		break;
+
+	case GPIOPORTINDEX:
+	default:
+		chip_info.chip_on_slot = PORT_ON_AGP;
+		break;
+	}
+
+	status =
+	    i2cReadByte((u8) chip_info.tmds_chip_info.tmds_chip_slave_addr,
+			(u8) index, &data);
+	chip_info.chip_on_slot = tmp;
+	return (data);
+}
+
+int tmds_register_read_bytes(int index, u8 *buff, int buff_len)
+{
+	int status;
+	u8 tmp;
+
+	tmp = chip_info.chip_on_slot;
+	switch (chip_info.tmds_chip_info.i2c_port) {
+	case I2CPORTINDEX:
+		chip_info.chip_on_slot = PORT_ON_AMR;
+		break;
+
+	case GPIOPORTINDEX:
+	default:
+		chip_info.chip_on_slot = PORT_ON_AGP;
+		break;
+	}
+
+	status =
+	    i2cReadBytes((u8) chip_info.tmds_chip_info.
+			 tmds_chip_slave_addr, (u8) index, buff, buff_len);
+	chip_info.chip_on_slot = tmp;
+	return (status);
+}
+
+int check_reduce_blanking_mode(int mode_index, int refresh_rate)
+{
+	if (refresh_rate != 60)
+		return (FALSE);
+
+	switch (mode_index) {
+		/* Following modes have reduce blanking mode. */
+	case VIA_RES_1360X768:
+	case VIA_RES_1400X1050:
+	case VIA_RES_1440X900:
+	case VIA_RES_1600X900:
+	case VIA_RES_1680X1050:
+	case VIA_RES_1920X1080:
+	case VIA_RES_1920X1200:
+		break;
+
+	default:
+		DEBUG_MSG(KERN_INFO
+			  "This dvi mode %d have no reduce blanking mode!\n",
+			  mode_index);
+		return (FALSE);
+	}
+
+	return (TRUE);
+}
+
+/* DVI Set Mode */
+void dvi_set_mode(int video_index, int mode_bpp, int set_iga)
+{
+	struct VideoModeTable *videoMode = NULL;
+	struct crt_mode_table *pDviTiming;
+	unsigned long desirePixelClock, maxPixelClock;
+	int status = 0;
+	videoMode = get_modetbl_pointer(video_index);
+	pDviTiming = videoMode->crtc;
+	desirePixelClock = pDviTiming->clk / 1000000;
+	maxPixelClock = (unsigned long)tmds_setting_info.max_pixel_clock;
+
+	DEBUG_MSG(KERN_INFO "\nDVI_set_mode!!\n");
+
+	if ((maxPixelClock != 0) && (desirePixelClock > maxPixelClock)) {
+		/*Check if reduce-blanking mode is exist */
+		status =
+		    check_reduce_blanking_mode(video_index,
+					       pDviTiming->refresh_rate);
+		if (status) {
+			video_index += 100;	/*Use reduce-blanking mode */
+			videoMode = get_modetbl_pointer(video_index);
+			pDviTiming = videoMode->crtc;
+			DEBUG_MSG(KERN_INFO
+				  "DVI use reduce blanking mode %d!!\n",
+				  video_index);
+		}
+	}
+	fill_crtc_timing(pDviTiming, video_index, mode_bpp / 8, set_iga);
+	set_output_path(DEVICE_DVI, set_iga,
+			chip_info.tmds_chip_info.output_interface);
+}
+
+/* Sense DVI Connector */
+int dvi_sense(void)
+{
+	u8 RegSR1E = 0, RegSR3E = 0, RegCR6B = 0, RegCR91 = 0, RegCR93 =
+	    0, RegCR9B = 0, data;
+	int ret = FALSE;
+
+	DEBUG_MSG(KERN_INFO "dvi_sense!!\n");
+
+	if (chip_info.gfx_chip_name == UNICHROME_CLE266) {
+		/* DI1 Pad on */
+		RegSR1E = read_reg(VIASR, SR1E);
+		write_reg(SR1E, VIASR, RegSR1E | 0x30);
+
+		/* CR6B[0]VCK Input Selection: 1 = External clock. */
+		RegCR6B = read_reg(VIACR, CR6B);
+		write_reg(CR6B, VIACR, RegCR6B | 0x08);
+
+		/* CR91[4] VDD On [3] Data On [2] VEE On [1] Back Light Off
+		   [0] Software Control Power Sequence */
+		RegCR91 = read_reg(VIACR, CR91);
+		write_reg(CR91, VIACR, 0x1D);
+
+		/* CR93[7] DI1 Data Source Selection: 1 = DSP2.
+		   CR93[5] DI1 Clock Source: 1 = internal.
+		   CR93[4] DI1 Clock Polarity.
+		   CR93[3:1] DI1 Clock Adjust. CR93[0] DI1 enable */
+		RegCR93 = read_reg(VIACR, CR93);
+		write_reg(CR93, VIACR, 0x01);
+	} else {
+		/* DVP0/DVP1 Pad on */
+		RegSR1E = read_reg(VIASR, SR1E);
+		write_reg(SR1E, VIASR, RegSR1E | 0xF0);
+
+		/* SR3E[1]Multi-function selection:
+		   0 = Emulate I2C and DDC bus by GPIO2/3/4. */
+		RegSR3E = read_reg(VIASR, SR3E);
+		write_reg(SR3E, VIASR, RegSR3E & (~0x20));
+
+		/* CR91[4] VDD On [3] Data On [2] VEE On [1] Back Light Off
+		   [0] Software Control Power Sequence */
+		RegCR91 = read_reg(VIACR, CR91);
+		write_reg(CR91, VIACR, 0x1D);
+
+		/*CR9B[4] DVP1 Data Source Selection: 1 = From secondary
+		display.CR9B[2:0] DVP1 Clock Adjust */
+		RegCR9B = read_reg(VIACR, CR9B);
+		write_reg(CR9B, VIACR, 0x01);
+	}
+
+	data = (u8) tmds_register_read(0x09);
+	if (data & 0x04)
+		ret = TRUE;
+
+	if (ret == FALSE) {
+		if (dvi_query_EDID())
+			ret = TRUE;
+	}
+
+	/* Restore status */
+	if (chip_info.gfx_chip_name == UNICHROME_CLE266) {
+		write_reg(SR1E, VIASR, RegSR1E);
+		write_reg(CR6B, VIACR, RegCR6B);
+		write_reg(CR91, VIACR, RegCR91);
+		write_reg(CR93, VIACR, RegCR93);
+	} else {
+		write_reg(SR1E, VIASR, RegSR1E);
+		write_reg(SR3E, VIASR, RegSR3E);
+		write_reg(CR91, VIACR, RegCR91);
+		write_reg(CR9B, VIACR, RegCR9B);
+	}
+
+	return ret;
+}
+
+/* Query Flat Panel's EDID Table Version Through DVI Connector */
+int dvi_query_EDID(void)
+{
+	u8 data0, data1;
+	int restore;
+
+	DEBUG_MSG(KERN_INFO "dvi_query_EDID!!\n");
+
+	restore = chip_info.tmds_chip_info.tmds_chip_slave_addr;
+	chip_info.tmds_chip_info.tmds_chip_slave_addr = 0xA0;
+
+	data0 = (u8) tmds_register_read(0x00);
+	data1 = (u8) tmds_register_read(0x01);
+	if ((data0 == 0) && (data1 == 0xFF)) {
+		chip_info.tmds_chip_info.tmds_chip_slave_addr = restore;
+		return (EDID_VERSION_1);	/* Found EDID1 Table */
+	}
+
+	data0 = (u8) tmds_register_read(0x00);
+	chip_info.tmds_chip_info.tmds_chip_slave_addr = restore;
+	if (data0 == 0x20)
+		return (EDID_VERSION_2);	/* Found EDID2 Table */
+	else
+		return (FALSE);
+}
+
+/*
+ *
+ * int dvi_get_panel_size_from_DDCv1(void)
+ *
+ *     - Get Panel Size Using EDID1 Table
+ *
+ * Return Type:    int
+ *
+ */
+int dvi_get_panel_size_from_DDCv1(void)
+{
+	int i, max_h = 0, max_v = 0, tmp, restore;
+	unsigned char rData;
+	unsigned char EDID_DATA[18];
+
+	DEBUG_MSG(KERN_INFO "\n dvi_get_panel_size_from_DDCv1 \n");
+
+	restore = chip_info.tmds_chip_info.tmds_chip_slave_addr;
+	chip_info.tmds_chip_info.tmds_chip_slave_addr = 0xA0;
+
+	for (i = 0x23; i < 0x6D; i++) {
+		switch (i) {
+		case 0x23:
+			rData = tmds_register_read(0x23);
+			if (rData & 0x3C)
+				max_h = 640;
+			if (rData & 0xC0)
+				max_h = 720;
+			if (rData & 0x03)
+				max_h = 800;
+			break;
+		case 0x24:
+			rData = tmds_register_read(0x24);
+			if (rData & 0xC0)
+				max_h = 800;
+			if (rData & 0x1E)
+				max_h = 1024;
+			if (rData & 0x01)
+				max_h = 1280;
+			break;
+		case 0x26:
+		case 0x28:
+		case 0x2A:
+		case 0x2C:
+		case 0x2E:
+		case 0x30:
+		case 0x32:
+		case 0x34:
+			rData = tmds_register_read(i);
+			if (rData == 1)
+				break;
+			/* data = (data + 31) * 8 */
+			tmp = (rData + 31) << 3;
+			if (tmp > max_h)
+				max_h = tmp;
+			break;
+
+		case 0x36:
+		case 0x48:
+		case 0x5A:
+		case 0x6C:
+			tmds_register_read_bytes(i, EDID_DATA, 10);
+			if (!(EDID_DATA[0] || EDID_DATA[1])) {
+				/* The first two byte must be zero. */
+				if (EDID_DATA[3] == 0xFD) {
+					/* To get max pixel clock. */
+					tmds_setting_info.max_pixel_clock =
+					    EDID_DATA[9] * 10;
+				}
+			}
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	switch (max_h) {
+	case 640:
+		tmds_setting_info.dvi_panel_size = VIA_RES_640X480;
+		break;
+	case 800:
+		tmds_setting_info.dvi_panel_size = VIA_RES_800X600;
+		break;
+	case 1024:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1024X768;
+		break;
+	case 1280:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1280X1024;
+		break;
+	case 1400:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1400X1050;
+		break;
+	case 1440:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1440X1050;
+		break;
+	case 1600:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1600X1200;
+		break;
+	case 1920:
+		if (max_v == 1200) {
+			tmds_setting_info.dvi_panel_size = VIA_RES_1920X1200;
+		} else {
+			tmds_setting_info.dvi_panel_size = VIA_RES_1920X1080;
+		}
+
+		break;
+	default:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1024X768;
+		DEBUG_MSG(KERN_INFO "Unknow panel size max resolution = %d !\
+					 set default panel size.\n", max_h);
+		break;
+	}
+
+	DEBUG_MSG(KERN_INFO "DVI max pixelclock = %d\n",
+		  tmds_setting_info.max_pixel_clock);
+	chip_info.tmds_chip_info.tmds_chip_slave_addr = restore;
+	return tmds_setting_info.dvi_panel_size;
+}
+
+/*
+ *
+ * int dvi_get_panel_size_from_DDCv2(void)
+ *
+ *     - Get Panel Size Using EDID2 Table
+ *
+ * Return Type:    int
+ *
+ */
+int dvi_get_panel_size_from_DDCv2(void)
+{
+	int HSize = 0, restore;
+	unsigned char R_Buffer[2];
+
+	DEBUG_MSG(KERN_INFO "\n dvi_get_panel_size_from_DDCv2 \n");
+
+	restore = chip_info.tmds_chip_info.tmds_chip_slave_addr;
+	chip_info.tmds_chip_info.tmds_chip_slave_addr = 0xA2;
+
+	/* Horizontal: 0x76, 0x77 */
+	tmds_register_read_bytes(0x76, R_Buffer, 2);
+	HSize = R_Buffer[0];
+	HSize += R_Buffer[1] << 8;
+
+	switch (HSize) {
+	case 640:
+		tmds_setting_info.dvi_panel_size = VIA_RES_640X480;
+		break;
+	case 800:
+		tmds_setting_info.dvi_panel_size = VIA_RES_800X600;
+		break;
+	case 1024:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1024X768;
+		break;
+	case 1280:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1280X1024;
+		break;
+	case 1400:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1400X1050;
+		break;
+	case 1440:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1440X1050;
+		break;
+	case 1600:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1600X1200;
+		break;
+	default:
+		tmds_setting_info.dvi_panel_size = VIA_RES_1024X768;
+		DEBUG_MSG(KERN_INFO "Unknow panel size max resolution = %d!\
+					set default panel size.\n", HSize);
+		break;
+	}
+
+	chip_info.tmds_chip_info.tmds_chip_slave_addr = restore;
+	return tmds_setting_info.dvi_panel_size;
+}
+
+/*
+ *
+ * unsigned char dvi_get_panel_info(void)
+ *
+ *     - Get Panel Size
+ *
+ * Return Type:    unsigned char
+ */
+unsigned char dvi_get_panel_info(void)
+{
+	DEBUG_MSG(KERN_INFO "dvi_get_panel_info! \n");
+
+	dvi_sense();
+	switch (dvi_query_EDID()) {
+	case 1:
+		dvi_get_panel_size_from_DDCv1();
+		break;
+	case 2:
+		dvi_get_panel_size_from_DDCv2();
+		break;
+	default:
+		break;
+	}
+
+	DEBUG_MSG(KERN_INFO "dvi panel size is %2d \n",
+		  tmds_setting_info.dvi_panel_size);
+	return (unsigned char)(tmds_setting_info.dvi_panel_size);
+}
+
+/* If Disable DVI, turn off pad */
+void dvi_disable(void)
+{
+	if (chip_info.tmds_chip_info.output_interface == INTERFACE_DVP0)
+		write_reg(SR1E, VIASR, read_reg(VIASR, SR1E) & (~0xC0));
+
+	if (chip_info.tmds_chip_info.output_interface == INTERFACE_DVP1)
+		write_reg(SR1E, VIASR, read_reg(VIASR, SR1E) & (~0x30));
+
+	if (chip_info.tmds_chip_info.output_interface == INTERFACE_DFP_HIGH)
+		write_reg(SR2A, VIASR, read_reg(VIASR, SR2A) & (~0x0C));
+
+	if (chip_info.tmds_chip_info.output_interface == INTERFACE_DFP_LOW)
+		write_reg(SR2A, VIASR, read_reg(VIASR, SR2A) & (~0x03));
+
+	if (chip_info.tmds_chip_info.output_interface == INTERFACE_TMDS)
+		/* Turn off TMDS power. */
+		write_reg(CRD2, VIACR, read_reg(VIACR, CRD2) | 0x08);
+}
+
+/* If Enable DVI, turn off pad */
+void dvi_enable(void)
+{
+	if (chip_info.tmds_chip_info.output_interface == INTERFACE_DVP0) {
+		write_reg(SR1E, VIASR, read_reg(VIASR, SR1E) | 0xC0);
+		if (chip_info.gfx_chip_name == UNICHROME_CLE266)
+			tmds_register_write(0x88, 0x3b);
+		else
+			/*clear CR91[5] to direct on display period
+			   in the secondary diplay path */
+			write_reg(CR91, VIACR, read_reg(VIACR, CR91) & 0xDF);
+	}
+
+	if (chip_info.tmds_chip_info.output_interface == INTERFACE_DVP1) {
+		write_reg(SR1E, VIASR, read_reg(VIASR, SR1E) | 0x30);
+
+		/*fix dvi cann't be enabled with MB VT5718C4 - Al Zhang */
+		if (chip_info.gfx_chip_name == UNICHROME_CLE266) {
+			tmds_register_write(0x88, 0x3b);
+		} else {
+			/*clear CR91[5] to direct on display period
+			  in the secondary diplay path */
+			write_reg(CR91, VIACR, read_reg(VIACR, CR91) & 0xDF);
+		}
+
+		/*fix DVI cannot enable on EPIA-M board */
+		if (platform_epia_dvi == 1) {
+			write_reg_mask(CR91, VIACR, 0x1f, 0x1f);
+			write_reg_mask(CR88, VIACR, 0x00, BIT6 + BIT0);
+			if (via_bus_width == 24) {
+				if (device_lcd_dualedge == 1)
+					i2cWriteByte(chip_info.
+						     tmds_chip_info.
+						     tmds_chip_slave_addr,
+						     0x08, 0x3F);
+				else
+					i2cWriteByte(chip_info.
+						     tmds_chip_info.
+						     tmds_chip_slave_addr,
+						     0x08, 0x37);
+			}
+		}
+	}
+
+	if (chip_info.tmds_chip_info.output_interface == INTERFACE_DFP_HIGH) {
+		write_reg(SR2A, VIASR, read_reg(VIASR, SR2A) | 0x0C);
+		write_reg(CR91, VIACR, read_reg(VIACR, CR91) & 0xDF);
+	}
+
+	if (chip_info.tmds_chip_info.output_interface == INTERFACE_DFP_LOW) {
+		write_reg(SR2A, VIASR, read_reg(VIASR, SR2A) | 0x03);
+		write_reg(CR91, VIACR, read_reg(VIACR, CR91) & 0xDF);
+	}
+	if (chip_info.tmds_chip_info.output_interface == INTERFACE_TMDS) {
+		/* Turn on Display period in the panel path. */
+		write_reg_mask(CR91, VIACR, 0, BIT7);
+
+		/* Turn on TMDS power. */
+		write_reg_mask(CRD2, VIACR, 0, BIT3);
+	}
+}
+
+int check_hdmi_connected_device(void)
+{
+	int bEdidExist = FALSE;
+	u8 byTemp = 0, byTemp1 = 0, byTemp2 = 0;
+	u8 byVendorDataBlock;
+	int restore, result = DEV_CONNECT_DVI;
+
+	restore = chip_info.tmds_chip_info.tmds_chip_slave_addr;
+	chip_info.tmds_chip_info.tmds_chip_slave_addr = 0xA0;
+	byTemp = (u8) tmds_register_read(0x00);
+
+	if (byTemp == 0x00) {
+		byTemp = (u8) tmds_register_read(0x01);
+		if (byTemp == 0xFF)
+			bEdidExist = TRUE;
+	}
+
+	if (bEdidExist) {
+		byTemp = (u8) tmds_register_read(0x80);
+		byTemp1 = (u8) tmds_register_read(0x81);
+
+		if (byTemp == 0x02 && byTemp1 == 0x03) {
+			byTemp = (u8) tmds_register_read(0x82);
+
+			if (!(byTemp == 0 || byTemp == 4)) {
+				byVendorDataBlock = 0x82 + 2;
+
+				byTemp1 = (u8)
+				    tmds_register_read(byVendorDataBlock);
+				while ((byTemp1 & 0xE0) != 0x60
+				       && byVendorDataBlock < (byTemp + 0x82)) {
+					byTemp1 &= 0x1F;
+
+					byVendorDataBlock += (byTemp1 + 1);
+
+					byTemp1 = (u8)
+					    tmds_register_read
+					    (byVendorDataBlock);
+				}
+				if ((byTemp1 & 0xE0) == 0x60) {
+					byTemp = (u8)
+					    tmds_register_read
+					    (byVendorDataBlock + 1);
+					byTemp1 = (u8)
+					    tmds_register_read
+					    (byVendorDataBlock + 2);
+					byTemp2 = (u8)
+					    tmds_register_read
+					    (byVendorDataBlock + 3);
+
+					if (byTemp == 0x03
+					    && byTemp1 == 0x0C
+					    && byTemp2 == 0x00)
+						result = DEV_CONNECT_HDMI;
+				}
+			}
+		}
+	}
+
+	chip_info.tmds_chip_info.tmds_chip_slave_addr = restore;
+	return result;
+}
--- /dev/null
+++ b/drivers/video/viafb/dvi.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __DVI_H__
+#define __DVI_H__
+
+/*Definition TMDS Device ID register*/
+#define     VT1632_DEVICE_ID_REG        0x02
+#define     VT1632_DEVICE_ID            0x92
+
+#define     GET_DVI_SIZE_BY_SYSTEM_BIOS     0x01
+#define     GET_DVI_SIZE_BY_VGA_BIOS        0x02
+#define     GET_DVI_SZIE_BY_HW_STRAPPING    0x03
+
+/* Definition DVI Panel ID*/
+/* Resolution: 640x480,   Channel: single, Dithering: Enable */
+#define     DVI_PANEL_ID0_640X480       0x00
+/* Resolution: 800x600,   Channel: single, Dithering: Enable */
+#define     DVI_PANEL_ID1_800x600       0x01
+/* Resolution: 1024x768,  Channel: single, Dithering: Enable */
+#define     DVI_PANEL_ID1_1024x768      0x02
+/* Resolution: 1280x768,  Channel: single, Dithering: Enable */
+#define     DVI_PANEL_ID1_1280x768      0x03
+/* Resolution: 1280x1024, Channel: dual,   Dithering: Enable */
+#define     DVI_PANEL_ID1_1280x1024     0x04
+/* Resolution: 1400x1050, Channel: dual,   Dithering: Enable */
+#define     DVI_PANEL_ID1_1400x1050     0x05
+/* Resolution: 1600x1200, Channel: dual,   Dithering: Enable */
+#define     DVI_PANEL_ID1_1600x1200     0x06
+
+/* Define the version of EDID*/
+#define     EDID_VERSION_1      1
+#define     EDID_VERSION_2      2
+
+#define     DEV_CONNECT_DVI     0x01
+#define     DEV_CONNECT_HDMI    0x02
+
+int check_hdmi_connected_device(void);
+struct VideoModeTable *get_cea_mode_tbl_pointer(int Index);
+int tmds_register_read(int index);
+void tmds_register_write(int index, u8 data);
+int dvi_sense(void);
+int dvi_query_EDID(void);
+unsigned char dvi_get_panel_info(void);
+void dvi_disable(void);
+void dvi_enable(void);
+int tmds_trasmitter_identify(void);
+void init_dvi_size(void);
+void dvi_set_mode(int video_index, int mode_bpp, int set_iga);
+
+#endif /* __DVI_H__ */
--- /dev/null
+++ b/drivers/video/viafb/global.c
@@ -0,0 +1,170 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "global.h"
+int platform_epia_dvi = STATE_OFF;
+int device_lcd_dualedge = STATE_OFF;
+int via_bus_width = 12;
+int display_hardware_layout = HW_LAYOUT_LCD_DVI;
+int via_fb_memsize;
+int DeviceStatus = CRT_Device;
+int via_fb_hotplug;
+int refresh = 60;
+int lcd_dsp_method = LCD_EXPANDSION;
+int lcd_mode = LCD_OPENLDI;
+int via_fb_bpp = 32;
+int via_fb_bpp1 = 32;
+int via_fb_accel;
+int CRT_ON = 1;
+int DVI_ON ;
+int LCD_ON ;
+int LCD2_ON;
+int SAMM_ON;
+int dual_fb;
+int via_fb_hotplug_Xres = 640;
+int via_fb_hotplug_Yres = 480;
+int via_fb_hotplug_bpp = 32;
+int via_fb_hotplug_refresh = 60;
+unsigned int second_offset;
+int second_size;
+int primary_dev = None_Device;
+void __iomem *FB_MM;
+unsigned int second_xres = 640;
+unsigned int second_yres = 480;
+unsigned int second_virtual_xres;
+unsigned int second_virtual_yres;
+int lcd_panel_id = LCD_PANEL_ID_MAXIMUM + 1;
+struct fb_cursor viacursor;
+struct fb_info viafbinfo1;
+struct tmds_setting_information tmds_setting_info;
+struct crt_setting_information crt_setting_info;
+struct lvds_setting_information lvds_setting_info;
+struct lvds_setting_information lvds_setting_info2;
+struct chip_information chip_info;
+struct viafb_par parinfo;
+struct viafb_par parinfo1;
+struct fb_info viafbinfo;
+static u16 red256[] = {
+	0x0, 0x0, 0x0, 0x0, 0xa800, 0xa800, 0xa800, 0xa800, 0x5400, 0x5400,
+	0x5400, 0x5400, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
+	0x0, 0x1400, 0x2000, 0x2c00, 0x3800, 0x4400, 0x5000, 0x6000,
+	0x7000, 0x8000, 0x9000, 0xa000, 0xb400, 0xc800, 0xe000,
+	0xfc00, 0x0, 0x4000, 0x7c00, 0xbc00, 0xfc00, 0xfc00, 0xfc00,
+	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xbc00,
+	0x7c00, 0x4000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+	0x7c00, 0x9c00, 0xbc00, 0xdc00, 0xfc00, 0xfc00, 0xfc00,
+	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xdc00,
+	0xbc00, 0x9c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
+	0x7c00, 0x7c00, 0x7c00, 0xb400, 0xc400, 0xd800, 0xe800,
+	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
+	0xfc00, 0xfc00, 0xe800, 0xd800, 0xc400, 0xb400, 0xb400,
+	0xb400, 0xb400, 0xb400, 0xb400, 0xb400, 0xb400, 0x0, 0x1c00,
+	0x3800, 0x5400, 0x7000, 0x7000, 0x7000, 0x7000, 0x7000,
+	0x7000, 0x7000, 0x7000, 0x7000, 0x5400, 0x3800, 0x1c00, 0x0,
+	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3800, 0x4400, 0x5400,
+	0x6000, 0x7000, 0x7000, 0x7000, 0x7000, 0x7000, 0x7000,
+	0x7000, 0x7000, 0x7000, 0x6000, 0x5400, 0x4400, 0x3800,
+	0x3800, 0x3800, 0x3800, 0x3800, 0x3800, 0x3800, 0x3800,
+	0x5000, 0x5800, 0x6000, 0x6800, 0x7000, 0x7000, 0x7000,
+	0x7000, 0x7000, 0x7000, 0x7000, 0x7000, 0x7000, 0x6800,
+	0x6000, 0x5800, 0x5000, 0x5000, 0x5000, 0x5000, 0x5000,
+	0x5000, 0x5000, 0x5000, 0x0, 0x1000, 0x2000, 0x3000, 0x4000,
+	0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000,
+	0x4000, 0x3000, 0x2000, 0x1000, 0x0, 0x0, 0x0, 0x0, 0x0,
+	0x0, 0x0, 0x0, 0x2000, 0x2800, 0x3000, 0x3800, 0x4000,
+	0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000,
+	0x4000, 0x3800, 0x3000, 0x2800, 0x2000, 0x2000, 0x2000,
+	0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2c00, 0x3000,
+	0x3400, 0x3c00, 0x4000, 0x4000, 0x4000, 0x4000, 0x4000,
+	0x4000, 0x4000, 0x4000, 0x4000, 0x3c00, 0x3400, 0x3000,
+	0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00,
+	0x2c00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
+};
+static u16 green256[] =
+    { 0x0, 0x0, 0xa800, 0xa800, 0x0, 0x0, 0x5400, 0xa800, 0x5400, 0x5400,
+	0xfc00, 0xfc00, 0x5400, 0x5400, 0xfc00, 0xfc00,
+	0x0, 0x1400, 0x2000, 0x2c00, 0x3800, 0x4400, 0x5000, 0x6000,
+	0x7000, 0x8000, 0x9000, 0xa000, 0xb400, 0xc800, 0xe000, 0xfc00,
+	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7c00, 0xbc00,
+	0xfc00, 0xfc00, 0xfc00, 0xfc00,
+	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xbc00, 0x7c00, 0x4000,
+	0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
+	0x7c00, 0x9c00, 0xbc00, 0xdc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
+	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xdc00, 0xbc00, 0x9c00,
+	0xb400, 0xb400, 0xb400, 0xb400, 0xb400, 0xb400, 0xb400, 0xb400,
+	0xb400, 0xc400, 0xd800, 0xe800, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
+	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xe800, 0xd800, 0xc400,
+	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+	0x0, 0x1c00, 0x3800, 0x5400, 0x7000, 0x7000, 0x7000, 0x7000,
+	0x7000, 0x7000, 0x7000, 0x7000, 0x7000, 0x5400, 0x3800, 0x1c00,
+	0x3800, 0x3800, 0x3800, 0x3800, 0x3800, 0x3800, 0x3800, 0x3800,
+	0x3800, 0x4400, 0x5400, 0x6000, 0x7000, 0x7000, 0x7000, 0x7000,
+	0x7000, 0x7000, 0x7000, 0x7000, 0x7000, 0x6000, 0x5400, 0x4400,
+	0x5000, 0x5000, 0x5000, 0x5000, 0x5000, 0x5000, 0x5000, 0x5000,
+	0x5000, 0x5800, 0x6000, 0x6800, 0x7000, 0x7000, 0x7000, 0x7000,
+	0x7000, 0x7000, 0x7000, 0x7000, 0x7000, 0x6800, 0x6000, 0x5800,
+	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1000, 0x2000,
+	0x3000, 0x4000, 0x4000, 0x4000, 0x4000,
+	0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x3000, 0x2000, 0x1000,
+	0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000,
+	0x2000, 0x2800, 0x3000, 0x3800, 0x4000, 0x4000, 0x4000, 0x4000,
+	0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x3800, 0x3000, 0x2800,
+	0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00,
+	0x2c00, 0x3000, 0x3400, 0x3c00, 0x4000, 0x4000, 0x4000, 0x4000,
+	0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x3c00, 0x3400, 0x3000,
+	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
+};
+static u16 blue256[] =
+    { 0x0, 0xa800, 0x0, 0xa800, 0x0, 0xa800, 0x0, 0xa800, 0x5400, 0xfc00,
+	0x5400, 0xfc00, 0x5400, 0xfc00, 0x5400, 0xfc00,
+	0x0, 0x1400, 0x2000, 0x2c00, 0x3800, 0x4400, 0x5000, 0x6000,
+	0x7000, 0x8000, 0x9000, 0xa000, 0xb400, 0xc800, 0xe000, 0xfc00,
+	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xbc00, 0x7c00, 0x4000,
+	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+	0x0, 0x4000, 0x7c00, 0xbc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
+	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xdc00, 0xbc00, 0x9c00,
+	0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
+	0x7c00, 0x9c00, 0xbc00, 0xdc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
+	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xe800, 0xd800, 0xc400,
+	0xb400, 0xb400, 0xb400, 0xb400, 0xb400, 0xb400, 0xb400, 0xb400,
+	0xb400, 0xc400, 0xd800, 0xe800, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
+	0x7000, 0x7000, 0x7000, 0x7000, 0x7000, 0x5400, 0x3800, 0x1c00,
+	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1c00, 0x3800,
+	0x5400, 0x7000, 0x7000, 0x7000, 0x7000,
+	0x7000, 0x7000, 0x7000, 0x7000, 0x7000, 0x6000, 0x5400, 0x4400,
+	0x3800, 0x3800, 0x3800, 0x3800, 0x3800, 0x3800, 0x3800, 0x3800,
+	0x3800, 0x4400, 0x5400, 0x6000, 0x7000, 0x7000, 0x7000, 0x7000,
+	0x7000, 0x7000, 0x7000, 0x7000, 0x7000, 0x6800, 0x6000, 0x5800,
+	0x5000, 0x5000, 0x5000, 0x5000, 0x5000, 0x5000, 0x5000, 0x5000,
+	0x5000, 0x5800, 0x6000, 0x6800, 0x7000, 0x7000, 0x7000, 0x7000,
+	0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x3000, 0x2000, 0x1000,
+	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+	0x0, 0x1000, 0x2000, 0x3000, 0x4000, 0x4000, 0x4000, 0x4000,
+	0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x3800, 0x3000, 0x2800,
+	0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000,
+	0x2000, 0x2800, 0x3000, 0x3800, 0x4000, 0x4000, 0x4000, 0x4000,
+	0x4000, 0x4000, 0x4000, 0x4000, 0x4000, 0x3c00, 0x3400, 0x3000,
+	0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00, 0x2c00,
+	0x2c00, 0x3000, 0x3400, 0x3c00, 0x4000, 0x4000, 0x4000, 0x4000,
+	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
+};
+
+struct fb_cmap viafb_256_colors = { 0, 256, red256, green256, blue256, NULL
+};
--- /dev/null
+++ b/drivers/video/viafb/global.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GLOBAL_H__
+#define __GLOBAL_H__
+
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/console.h>
+#include <linux/timer.h>
+
+#include "debug.h"
+
+#include "iface.h"
+#include "viafbdev.h"
+#include "chip.h"
+#include "debug.h"
+#include "accel.h"
+#include "share.h"
+#include "dvi.h"
+#include "viamode.h"
+#include "via_i2c.h"
+#include "hw.h"
+
+#include "lcd.h"
+#include "ioctl.h"
+#include "viamode.h"
+#include "via_utility.h"
+#include "vt1636.h"
+#include "tblDPASetting.h"
+#include "tbl1636.h"
+#include "viafbdev.h"
+
+/* External struct*/
+#define     PORT_ON_AMR       1
+#define     PORT_ON_AGP       2
+
+extern int platform_epia_dvi;
+extern int device_lcd_dualedge;
+extern int via_bus_width;
+extern int display_hardware_layout;
+extern struct tmds_setting_information tmds_setting_info;
+extern struct crt_setting_information crt_setting_info;
+extern struct lvds_setting_information lvds_setting_info;
+extern struct lvds_setting_information lvds_setting_info2;
+extern struct offset offset_reg;
+extern struct chip_information chip_info;
+extern struct viafb_par parinfo;
+extern struct viafb_par parinfo1;
+extern struct fb_info viafbinfo;
+extern int DeviceStatus;
+extern int refresh;
+extern int lcd_dsp_method;
+extern int lcd_mode;
+extern int via_fb_bpp;
+extern int via_fb_bpp1;
+
+extern int CRT_ON;
+extern int via_fb_hotplug_Xres;
+extern int via_fb_hotplug_Yres;
+extern int via_fb_hotplug_bpp;
+extern int via_fb_hotplug_refresh;
+extern int primary_dev;
+extern void __iomem *FB_MM;
+extern struct fb_cursor viacursor;
+
+extern struct fb_cmap viafb_256_colors;
+extern struct fb_info viafbinfo1;
+
+extern unsigned int second_xres;
+extern unsigned int second_yres;
+extern int lcd_panel_id;
+
+#endif /* __GLOBAL_H__ */
--- /dev/null
+++ b/drivers/video/viafb/hw.c
@@ -0,0 +1,2934 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+struct offset offset_reg = {
+	/* IGA1 Offset Register */
+	{IGA1_OFFSET_REG_NUM, {{CR13, 0, 7}, {CR35, 5, 7} } },
+	/* IGA2 Offset Register */
+	{IGA2_OFFSET_REG_NUM, {{CR66, 0, 7}, {CR67, 0, 1} } }
+};
+
+struct pll_map pll_value[] = {
+	{CLK_25_175M, CLE266_PLL_25_175M, K800_PLL_25_175M, CX700_25_175M},
+	{CLK_29_581M, CLE266_PLL_29_581M, K800_PLL_29_581M, CX700_29_581M},
+	{CLK_26_880M, CLE266_PLL_26_880M, K800_PLL_26_880M, CX700_26_880M},
+	{CLK_31_490M, CLE266_PLL_31_490M, K800_PLL_31_490M, CX700_31_490M},
+	{CLK_31_500M, CLE266_PLL_31_500M, K800_PLL_31_500M, CX700_31_500M},
+	{CLK_31_728M, CLE266_PLL_31_728M, K800_PLL_31_728M, CX700_31_728M},
+	{CLK_32_668M, CLE266_PLL_32_668M, K800_PLL_32_668M, CX700_32_668M},
+	{CLK_36_000M, CLE266_PLL_36_000M, K800_PLL_36_000M, CX700_36_000M},
+	{CLK_40_000M, CLE266_PLL_40_000M, K800_PLL_40_000M, CX700_40_000M},
+	{CLK_41_291M, CLE266_PLL_41_291M, K800_PLL_41_291M, CX700_41_291M},
+	{CLK_43_163M, CLE266_PLL_43_163M, K800_PLL_43_163M, CX700_43_163M},
+	{CLK_45_250M, CLE266_PLL_45_250M, K800_PLL_45_250M, CX700_45_250M},
+	{CLK_46_000M, CLE266_PLL_46_000M, K800_PLL_46_000M, CX700_46_000M},
+	{CLK_46_996M, CLE266_PLL_46_996M, K800_PLL_46_996M, CX700_46_996M},
+	{CLK_48_000M, CLE266_PLL_48_000M, K800_PLL_48_000M, CX700_48_000M},
+	{CLK_48_875M, CLE266_PLL_48_875M, K800_PLL_48_875M, CX700_48_875M},
+	{CLK_49_500M, CLE266_PLL_49_500M, K800_PLL_49_500M, CX700_49_500M},
+	{CLK_52_406M, CLE266_PLL_52_406M, K800_PLL_52_406M, CX700_52_406M},
+	{CLK_52_977M, CLE266_PLL_52_977M, K800_PLL_52_977M, CX700_52_977M},
+	{CLK_56_250M, CLE266_PLL_56_250M, K800_PLL_56_250M, CX700_56_250M},
+	{CLK_60_466M, CLE266_PLL_60_466M, K800_PLL_60_466M, CX700_60_466M},
+	{CLK_61_500M, CLE266_PLL_61_500M, K800_PLL_61_500M, CX700_61_500M},
+	{CLK_65_000M, CLE266_PLL_65_000M, K800_PLL_65_000M, CX700_65_000M},
+	{CLK_65_178M, CLE266_PLL_65_178M, K800_PLL_65_178M, CX700_65_178M},
+	{CLK_66_750M, CLE266_PLL_66_750M, K800_PLL_66_750M, CX700_66_750M},
+	{CLK_68_179M, CLE266_PLL_68_179M, K800_PLL_68_179M, CX700_68_179M},
+	{CLK_69_924M, CLE266_PLL_69_924M, K800_PLL_69_924M, CX700_69_924M},
+	{CLK_70_159M, CLE266_PLL_70_159M, K800_PLL_70_159M, CX700_70_159M},
+	{CLK_72_000M, CLE266_PLL_72_000M, K800_PLL_72_000M, CX700_72_000M},
+	{CLK_78_750M, CLE266_PLL_78_750M, K800_PLL_78_750M, CX700_78_750M},
+	{CLK_80_136M, CLE266_PLL_80_136M, K800_PLL_80_136M, CX700_80_136M},
+	{CLK_83_375M, CLE266_PLL_83_375M, K800_PLL_83_375M, CX700_83_375M},
+	{CLK_83_950M, CLE266_PLL_83_950M, K800_PLL_83_950M, CX700_83_950M},
+	{CLK_84_750M, CLE266_PLL_84_750M, K800_PLL_84_750M, CX700_84_750M},
+	{CLK_85_860M, CLE266_PLL_85_860M, K800_PLL_85_860M, CX700_85_860M},
+	{CLK_88_750M, CLE266_PLL_88_750M, K800_PLL_88_750M, CX700_88_750M},
+	{CLK_94_500M, CLE266_PLL_94_500M, K800_PLL_94_500M, CX700_94_500M},
+	{CLK_97_750M, CLE266_PLL_97_750M, K800_PLL_97_750M, CX700_97_750M},
+	{CLK_101_000M, CLE266_PLL_101_000M, K800_PLL_101_000M,
+	 CX700_101_000M},
+	{CLK_106_500M, CLE266_PLL_106_500M, K800_PLL_106_500M,
+	 CX700_106_500M},
+	{CLK_108_000M, CLE266_PLL_108_000M, K800_PLL_108_000M,
+	 CX700_108_000M},
+	{CLK_113_309M, CLE266_PLL_113_309M, K800_PLL_113_309M,
+	 CX700_113_309M},
+	{CLK_118_840M, CLE266_PLL_118_840M, K800_PLL_118_840M,
+	 CX700_118_840M},
+	{CLK_119_000M, CLE266_PLL_119_000M, K800_PLL_119_000M,
+	 CX700_119_000M},
+	{CLK_121_750M, CLE266_PLL_121_750M, K800_PLL_121_750M,
+	 CX700_121_750M},
+	{CLK_125_104M, CLE266_PLL_125_104M, K800_PLL_125_104M,
+	 CX700_125_104M},
+	{CLK_133_308M, CLE266_PLL_133_308M, K800_PLL_133_308M,
+	 CX700_133_308M},
+	{CLK_135_000M, CLE266_PLL_135_000M, K800_PLL_135_000M,
+	 CX700_135_000M},
+	{CLK_136_700M, CLE266_PLL_136_700M, K800_PLL_136_700M,
+	 CX700_136_700M},
+	{CLK_138_400M, CLE266_PLL_138_400M, K800_PLL_138_400M,
+	 CX700_138_400M},
+	{CLK_146_760M, CLE266_PLL_146_760M, K800_PLL_146_760M,
+	 CX700_146_760M},
+	{CLK_153_920M, CLE266_PLL_153_920M, K800_PLL_153_920M,
+	 CX700_153_920M},
+	{CLK_156_000M, CLE266_PLL_156_000M, K800_PLL_156_000M,
+	 CX700_156_000M},
+	{CLK_157_500M, CLE266_PLL_157_500M, K800_PLL_157_500M,
+	 CX700_157_500M},
+	{CLK_162_000M, CLE266_PLL_162_000M, K800_PLL_162_000M,
+	 CX700_162_000M},
+	{CLK_187_000M, CLE266_PLL_187_000M, K800_PLL_187_000M,
+	 CX700_187_000M},
+	{CLK_193_295M, CLE266_PLL_193_295M, K800_PLL_193_295M,
+	 CX700_193_295M},
+	{CLK_202_500M, CLE266_PLL_202_500M, K800_PLL_202_500M,
+	 CX700_202_500M},
+	{CLK_204_000M, CLE266_PLL_204_000M, K800_PLL_204_000M,
+	 CX700_204_000M},
+	{CLK_218_500M, CLE266_PLL_218_500M, K800_PLL_218_500M,
+	 CX700_218_500M},
+	{CLK_234_000M, CLE266_PLL_234_000M, K800_PLL_234_000M,
+	 CX700_234_000M},
+	{CLK_267_250M, CLE266_PLL_267_250M, K800_PLL_267_250M,
+	 CX700_267_250M},
+	{CLK_297_500M, CLE266_PLL_297_500M, K800_PLL_297_500M,
+	 CX700_297_500M},
+	{CLK_74_481M, CLE266_PLL_74_481M, K800_PLL_74_481M, CX700_74_481M},
+	{CLK_172_798M, CLE266_PLL_172_798M, K800_PLL_172_798M,
+	 CX700_172_798M},
+	{CLK_122_614M, CLE266_PLL_122_614M, K800_PLL_122_614M,
+	 CX700_122_614M},
+	{CLK_74_270M, CLE266_PLL_74_270M, K800_PLL_74_270M, CX700_74_270M},
+	{CLK_148_500M, CLE266_PLL_148_500M, K800_PLL_148_500M,
+	 CX700_148_500M}
+};
+
+struct fifo_depth_select display_fifo_depth_reg = {
+	/* IGA1 FIFO Depth_Select */
+	{IGA1_FIFO_DEPTH_SELECT_REG_NUM, {{SR17, 0, 7} } },
+	/* IGA2 FIFO Depth_Select */
+	{IGA2_FIFO_DEPTH_SELECT_REG_NUM,
+	 {{CR68, 4, 7}, {CR94, 7, 7}, {CR95, 7, 7} } }
+};
+
+struct fifo_threshold_select fifo_threshold_select_reg = {
+	/* IGA1 FIFO Threshold Select */
+	{IGA1_FIFO_THRESHOLD_REG_NUM, {{SR16, 0, 5}, {SR16, 7, 7} } },
+	/* IGA2 FIFO Threshold Select */
+	{IGA2_FIFO_THRESHOLD_REG_NUM, {{CR68, 0, 3}, {CR95, 4, 6} } }
+};
+
+struct fifo_high_threshold_select fifo_high_threshold_select_reg = {
+	/* IGA1 FIFO High Threshold Select */
+	{IGA1_FIFO_HIGH_THRESHOLD_REG_NUM, {{SR18, 0, 5}, {SR18, 7, 7} } },
+	/* IGA2 FIFO High Threshold Select */
+	{IGA2_FIFO_HIGH_THRESHOLD_REG_NUM, {{CR92, 0, 3}, {CR95, 0, 2} } }
+};
+
+struct display_queue_expire_num display_queue_expire_num_reg = {
+	/* IGA1 Display Queue Expire Num */
+	{IGA1_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM, {{SR22, 0, 4} } },
+	/* IGA2 Display Queue Expire Num */
+	{IGA2_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM, {{CR94, 0, 6} } }
+};
+
+/* Definition Fetch Count Registers*/
+struct fetch_count fetch_count_reg = {
+	/* IGA1 Fetch Count Register */
+	{IGA1_FETCH_COUNT_REG_NUM, {{SR1C, 0, 7}, {SR1D, 0, 1} } },
+	/* IGA2 Fetch Count Register */
+	{IGA2_FETCH_COUNT_REG_NUM, {{CR65, 0, 7}, {CR67, 2, 3} } }
+};
+
+struct iga1_crtc_timing iga1_crtc_reg = {
+	/* IGA1 Horizontal Total */
+	{IGA1_HOR_TOTAL_REG_NUM, {{CR00, 0, 7}, {CR36, 3, 3} } },
+	/* IGA1 Horizontal Addressable Video */
+	{IGA1_HOR_ADDR_REG_NUM, {{CR01, 0, 7} } },
+	/* IGA1 Horizontal Blank Start */
+	{IGA1_HOR_BLANK_START_REG_NUM, {{CR02, 0, 7} } },
+	/* IGA1 Horizontal Blank End */
+	{IGA1_HOR_BLANK_END_REG_NUM,
+	 {{CR03, 0, 4}, {CR05, 7, 7}, {CR33, 5, 5} } },
+	/* IGA1 Horizontal Sync Start */
+	{IGA1_HOR_SYNC_START_REG_NUM, {{CR04, 0, 7}, {CR33, 4, 4} } },
+	/* IGA1 Horizontal Sync End */
+	{IGA1_HOR_SYNC_END_REG_NUM, {{CR05, 0, 4} } },
+	/* IGA1 Vertical Total */
+	{IGA1_VER_TOTAL_REG_NUM,
+	 {{CR06, 0, 7}, {CR07, 0, 0}, {CR07, 5, 5}, {CR35, 0, 0} } },
+	/* IGA1 Vertical Addressable Video */
+	{IGA1_VER_ADDR_REG_NUM,
+	 {{CR12, 0, 7}, {CR07, 1, 1}, {CR07, 6, 6}, {CR35, 2, 2} } },
+	/* IGA1 Vertical Blank Start */
+	{IGA1_VER_BLANK_START_REG_NUM,
+	 {{CR15, 0, 7}, {CR07, 3, 3}, {CR09, 5, 5}, {CR35, 3, 3} } },
+	/* IGA1 Vertical Blank End */
+	{IGA1_VER_BLANK_END_REG_NUM, {{CR16, 0, 7} } },
+	/* IGA1 Vertical Sync Start */
+	{IGA1_VER_SYNC_START_REG_NUM,
+	 {{CR10, 0, 7}, {CR07, 2, 2}, {CR07, 7, 7}, {CR35, 1, 1} } },
+	/* IGA1 Vertical Sync End */
+	{IGA1_VER_SYNC_END_REG_NUM, {{CR11, 0, 3} } }
+};
+
+struct iga2_crtc_timing iga2_crtc_reg = {
+	/* IGA2 Horizontal Total */
+	{IGA2_HOR_TOTAL_REG_NUM, {{CR50, 0, 7}, {CR55, 0, 3} } },
+	/* IGA2 Horizontal Addressable Video */
+	{IGA2_HOR_ADDR_REG_NUM, {{CR51, 0, 7}, {CR55, 4, 6} } },
+	/* IGA2 Horizontal Blank Start */
+	{IGA2_HOR_BLANK_START_REG_NUM, {{CR52, 0, 7}, {CR54, 0, 2} } },
+	/* IGA2 Horizontal Blank End */
+	{IGA2_HOR_BLANK_END_REG_NUM,
+	 {{CR53, 0, 7}, {CR54, 3, 5}, {CR5D, 6, 6} } },
+	/* IGA2 Horizontal Sync Start */
+	{IGA2_HOR_SYNC_START_REG_NUM,
+	 {{CR56, 0, 7}, {CR54, 6, 7}, {CR5C, 7, 7}, {CR5D, 7, 7} } },
+	/* IGA2 Horizontal Sync End */
+	{IGA2_HOR_SYNC_END_REG_NUM, {{CR57, 0, 7}, {CR5C, 6, 6} } },
+	/* IGA2 Vertical Total */
+	{IGA2_VER_TOTAL_REG_NUM, {{CR58, 0, 7}, {CR5D, 0, 2} } },
+	/* IGA2 Vertical Addressable Video */
+	{IGA2_VER_ADDR_REG_NUM, {{CR59, 0, 7}, {CR5D, 3, 5} } },
+	/* IGA2 Vertical Blank Start */
+	{IGA2_VER_BLANK_START_REG_NUM, {{CR5A, 0, 7}, {CR5C, 0, 2} } },
+	/* IGA2 Vertical Blank End */
+	{IGA2_VER_BLANK_END_REG_NUM, {{CR5B, 0, 7}, {CR5C, 3, 5} } },
+	/* IGA2 Vertical Sync Start */
+	{IGA2_VER_SYNC_START_REG_NUM, {{CR5E, 0, 7}, {CR5F, 5, 7} } },
+	/* IGA2 Vertical Sync End */
+	{IGA2_VER_SYNC_END_REG_NUM, {{CR5F, 0, 4} } }
+};
+
+struct rgbLUT palLUT_table[] = {
+	/* {R,G,B} */
+	/* Index 0x00~0x03 */
+	{0x00, 0x00, 0x00}, {0x00, 0x00, 0x2A}, {0x00, 0x2A, 0x00}, {0x00,
+								     0x2A,
+								     0x2A},
+	/* Index 0x04~0x07 */
+	{0x2A, 0x00, 0x00}, {0x2A, 0x00, 0x2A}, {0x2A, 0x15, 0x00}, {0x2A,
+								     0x2A,
+								     0x2A},
+	/* Index 0x08~0x0B */
+	{0x15, 0x15, 0x15}, {0x15, 0x15, 0x3F}, {0x15, 0x3F, 0x15}, {0x15,
+								     0x3F,
+								     0x3F},
+	/* Index 0x0C~0x0F */
+	{0x3F, 0x15, 0x15}, {0x3F, 0x15, 0x3F}, {0x3F, 0x3F, 0x15}, {0x3F,
+								     0x3F,
+								     0x3F},
+	/* Index 0x10~0x13 */
+	{0x00, 0x00, 0x00}, {0x05, 0x05, 0x05}, {0x08, 0x08, 0x08}, {0x0B,
+								     0x0B,
+								     0x0B},
+	/* Index 0x14~0x17 */
+	{0x0E, 0x0E, 0x0E}, {0x11, 0x11, 0x11}, {0x14, 0x14, 0x14}, {0x18,
+								     0x18,
+								     0x18},
+	/* Index 0x18~0x1B */
+	{0x1C, 0x1C, 0x1C}, {0x20, 0x20, 0x20}, {0x24, 0x24, 0x24}, {0x28,
+								     0x28,
+								     0x28},
+	/* Index 0x1C~0x1F */
+	{0x2D, 0x2D, 0x2D}, {0x32, 0x32, 0x32}, {0x38, 0x38, 0x38}, {0x3F,
+								     0x3F,
+								     0x3F},
+	/* Index 0x20~0x23 */
+	{0x00, 0x00, 0x3F}, {0x10, 0x00, 0x3F}, {0x1F, 0x00, 0x3F}, {0x2F,
+								     0x00,
+								     0x3F},
+	/* Index 0x24~0x27 */
+	{0x3F, 0x00, 0x3F}, {0x3F, 0x00, 0x2F}, {0x3F, 0x00, 0x1F}, {0x3F,
+								     0x00,
+								     0x10},
+	/* Index 0x28~0x2B */
+	{0x3F, 0x00, 0x00}, {0x3F, 0x10, 0x00}, {0x3F, 0x1F, 0x00}, {0x3F,
+								     0x2F,
+								     0x00},
+	/* Index 0x2C~0x2F */
+	{0x3F, 0x3F, 0x00}, {0x2F, 0x3F, 0x00}, {0x1F, 0x3F, 0x00}, {0x10,
+								     0x3F,
+								     0x00},
+	/* Index 0x30~0x33 */
+	{0x00, 0x3F, 0x00}, {0x00, 0x3F, 0x10}, {0x00, 0x3F, 0x1F}, {0x00,
+								     0x3F,
+								     0x2F},
+	/* Index 0x34~0x37 */
+	{0x00, 0x3F, 0x3F}, {0x00, 0x2F, 0x3F}, {0x00, 0x1F, 0x3F}, {0x00,
+								     0x10,
+								     0x3F},
+	/* Index 0x38~0x3B */
+	{0x1F, 0x1F, 0x3F}, {0x27, 0x1F, 0x3F}, {0x2F, 0x1F, 0x3F}, {0x37,
+								     0x1F,
+								     0x3F},
+	/* Index 0x3C~0x3F */
+	{0x3F, 0x1F, 0x3F}, {0x3F, 0x1F, 0x37}, {0x3F, 0x1F, 0x2F}, {0x3F,
+								     0x1F,
+								     0x27},
+	/* Index 0x40~0x43 */
+	{0x3F, 0x1F, 0x1F}, {0x3F, 0x27, 0x1F}, {0x3F, 0x2F, 0x1F}, {0x3F,
+								     0x3F,
+								     0x1F},
+	/* Index 0x44~0x47 */
+	{0x3F, 0x3F, 0x1F}, {0x37, 0x3F, 0x1F}, {0x2F, 0x3F, 0x1F}, {0x27,
+								     0x3F,
+								     0x1F},
+	/* Index 0x48~0x4B */
+	{0x1F, 0x3F, 0x1F}, {0x1F, 0x3F, 0x27}, {0x1F, 0x3F, 0x2F}, {0x1F,
+								     0x3F,
+								     0x37},
+	/* Index 0x4C~0x4F */
+	{0x1F, 0x3F, 0x3F}, {0x1F, 0x37, 0x3F}, {0x1F, 0x2F, 0x3F}, {0x1F,
+								     0x27,
+								     0x3F},
+	/* Index 0x50~0x53 */
+	{0x2D, 0x2D, 0x3F}, {0x31, 0x2D, 0x3F}, {0x36, 0x2D, 0x3F}, {0x3A,
+								     0x2D,
+								     0x3F},
+	/* Index 0x54~0x57 */
+	{0x3F, 0x2D, 0x3F}, {0x3F, 0x2D, 0x3A}, {0x3F, 0x2D, 0x36}, {0x3F,
+								     0x2D,
+								     0x31},
+	/* Index 0x58~0x5B */
+	{0x3F, 0x2D, 0x2D}, {0x3F, 0x31, 0x2D}, {0x3F, 0x36, 0x2D}, {0x3F,
+								     0x3A,
+								     0x2D},
+	/* Index 0x5C~0x5F */
+	{0x3F, 0x3F, 0x2D}, {0x3A, 0x3F, 0x2D}, {0x36, 0x3F, 0x2D}, {0x31,
+								     0x3F,
+								     0x2D},
+	/* Index 0x60~0x63 */
+	{0x2D, 0x3F, 0x2D}, {0x2D, 0x3F, 0x31}, {0x2D, 0x3F, 0x36}, {0x2D,
+								     0x3F,
+								     0x3A},
+	/* Index 0x64~0x67 */
+	{0x2D, 0x3F, 0x3F}, {0x2D, 0x3A, 0x3F}, {0x2D, 0x36, 0x3F}, {0x2D,
+								     0x31,
+								     0x3F},
+	/* Index 0x68~0x6B */
+	{0x00, 0x00, 0x1C}, {0x07, 0x00, 0x1C}, {0x0E, 0x00, 0x1C}, {0x15,
+								     0x00,
+								     0x1C},
+	/* Index 0x6C~0x6F */
+	{0x1C, 0x00, 0x1C}, {0x1C, 0x00, 0x15}, {0x1C, 0x00, 0x0E}, {0x1C,
+								     0x00,
+								     0x07},
+	/* Index 0x70~0x73 */
+	{0x1C, 0x00, 0x00}, {0x1C, 0x07, 0x00}, {0x1C, 0x0E, 0x00}, {0x1C,
+								     0x15,
+								     0x00},
+	/* Index 0x74~0x77 */
+	{0x1C, 0x1C, 0x00}, {0x15, 0x1C, 0x00}, {0x0E, 0x1C, 0x00}, {0x07,
+								     0x1C,
+								     0x00},
+	/* Index 0x78~0x7B */
+	{0x00, 0x1C, 0x00}, {0x00, 0x1C, 0x07}, {0x00, 0x1C, 0x0E}, {0x00,
+								     0x1C,
+								     0x15},
+	/* Index 0x7C~0x7F */
+	{0x00, 0x1C, 0x1C}, {0x00, 0x15, 0x1C}, {0x00, 0x0E, 0x1C}, {0x00,
+								     0x07,
+								     0x1C},
+	/* Index 0x80~0x83 */
+	{0x0E, 0x0E, 0x1C}, {0x11, 0x0E, 0x1C}, {0x15, 0x0E, 0x1C}, {0x18,
+								     0x0E,
+								     0x1C},
+	/* Index 0x84~0x87 */
+	{0x1C, 0x0E, 0x1C}, {0x1C, 0x0E, 0x18}, {0x1C, 0x0E, 0x15}, {0x1C,
+								     0x0E,
+								     0x11},
+	/* Index 0x88~0x8B */
+	{0x1C, 0x0E, 0x0E}, {0x1C, 0x11, 0x0E}, {0x1C, 0x15, 0x0E}, {0x1C,
+								     0x18,
+								     0x0E},
+	/* Index 0x8C~0x8F */
+	{0x1C, 0x1C, 0x0E}, {0x18, 0x1C, 0x0E}, {0x15, 0x1C, 0x0E}, {0x11,
+								     0x1C,
+								     0x0E},
+	/* Index 0x90~0x93 */
+	{0x0E, 0x1C, 0x0E}, {0x0E, 0x1C, 0x11}, {0x0E, 0x1C, 0x15}, {0x0E,
+								     0x1C,
+								     0x18},
+	/* Index 0x94~0x97 */
+	{0x0E, 0x1C, 0x1C}, {0x0E, 0x18, 0x1C}, {0x0E, 0x15, 0x1C}, {0x0E,
+								     0x11,
+								     0x1C},
+	/* Index 0x98~0x9B */
+	{0x14, 0x14, 0x1C}, {0x16, 0x14, 0x1C}, {0x18, 0x14, 0x1C}, {0x1A,
+								     0x14,
+								     0x1C},
+	/* Index 0x9C~0x9F */
+	{0x1C, 0x14, 0x1C}, {0x1C, 0x14, 0x1A}, {0x1C, 0x14, 0x18}, {0x1C,
+								     0x14,
+								     0x16},
+	/* Index 0xA0~0xA3 */
+	{0x1C, 0x14, 0x14}, {0x1C, 0x16, 0x14}, {0x1C, 0x18, 0x14}, {0x1C,
+								     0x1A,
+								     0x14},
+	/* Index 0xA4~0xA7 */
+	{0x1C, 0x1C, 0x14}, {0x1A, 0x1C, 0x14}, {0x18, 0x1C, 0x14}, {0x16,
+								     0x1C,
+								     0x14},
+	/* Index 0xA8~0xAB */
+	{0x14, 0x1C, 0x14}, {0x14, 0x1C, 0x16}, {0x14, 0x1C, 0x18}, {0x14,
+								     0x1C,
+								     0x1A},
+	/* Index 0xAC~0xAF */
+	{0x14, 0x1C, 0x1C}, {0x14, 0x1A, 0x1C}, {0x14, 0x18, 0x1C}, {0x14,
+								     0x16,
+								     0x1C},
+	/* Index 0xB0~0xB3 */
+	{0x00, 0x00, 0x10}, {0x04, 0x00, 0x10}, {0x08, 0x00, 0x10}, {0x0C,
+								     0x00,
+								     0x10},
+	/* Index 0xB4~0xB7 */
+	{0x10, 0x00, 0x10}, {0x10, 0x00, 0x0C}, {0x10, 0x00, 0x08}, {0x10,
+								     0x00,
+								     0x04},
+	/* Index 0xB8~0xBB */
+	{0x10, 0x00, 0x00}, {0x10, 0x04, 0x00}, {0x10, 0x08, 0x00}, {0x10,
+								     0x0C,
+								     0x00},
+	/* Index 0xBC~0xBF */
+	{0x10, 0x10, 0x00}, {0x0C, 0x10, 0x00}, {0x08, 0x10, 0x00}, {0x04,
+								     0x10,
+								     0x00},
+	/* Index 0xC0~0xC3 */
+	{0x00, 0x10, 0x00}, {0x00, 0x10, 0x04}, {0x00, 0x10, 0x08}, {0x00,
+								     0x10,
+								     0x0C},
+	/* Index 0xC4~0xC7 */
+	{0x00, 0x10, 0x10}, {0x00, 0x0C, 0x10}, {0x00, 0x08, 0x10}, {0x00,
+								     0x04,
+								     0x10},
+	/* Index 0xC8~0xCB */
+	{0x08, 0x08, 0x10}, {0x0A, 0x08, 0x10}, {0x0C, 0x08, 0x10}, {0x0E,
+								     0x08,
+								     0x10},
+	/* Index 0xCC~0xCF */
+	{0x10, 0x08, 0x10}, {0x10, 0x08, 0x0E}, {0x10, 0x08, 0x0C}, {0x10,
+								     0x08,
+								     0x0A},
+	/* Index 0xD0~0xD3 */
+	{0x10, 0x08, 0x08}, {0x10, 0x0A, 0x08}, {0x10, 0x0C, 0x08}, {0x10,
+								     0x0E,
+								     0x08},
+	/* Index 0xD4~0xD7 */
+	{0x10, 0x10, 0x08}, {0x0E, 0x10, 0x08}, {0x0C, 0x10, 0x08}, {0x0A,
+								     0x10,
+								     0x08},
+	/* Index 0xD8~0xDB */
+	{0x08, 0x10, 0x08}, {0x08, 0x10, 0x0A}, {0x08, 0x10, 0x0C}, {0x08,
+								     0x10,
+								     0x0E},
+	/* Index 0xDC~0xDF */
+	{0x08, 0x10, 0x10}, {0x08, 0x0E, 0x10}, {0x08, 0x0C, 0x10}, {0x08,
+								     0x0A,
+								     0x10},
+	/* Index 0xE0~0xE3 */
+	{0x0B, 0x0B, 0x10}, {0x0C, 0x0B, 0x10}, {0x0D, 0x0B, 0x10}, {0x0F,
+								     0x0B,
+								     0x10},
+	/* Index 0xE4~0xE7 */
+	{0x10, 0x0B, 0x10}, {0x10, 0x0B, 0x0F}, {0x10, 0x0B, 0x0D}, {0x10,
+								     0x0B,
+								     0x0C},
+	/* Index 0xE8~0xEB */
+	{0x10, 0x0B, 0x0B}, {0x10, 0x0C, 0x0B}, {0x10, 0x0D, 0x0B}, {0x10,
+								     0x0F,
+								     0x0B},
+	/* Index 0xEC~0xEF */
+	{0x10, 0x10, 0x0B}, {0x0F, 0x10, 0x0B}, {0x0D, 0x10, 0x0B}, {0x0C,
+								     0x10,
+								     0x0B},
+	/* Index 0xF0~0xF3 */
+	{0x0B, 0x10, 0x0B}, {0x0B, 0x10, 0x0C}, {0x0B, 0x10, 0x0D}, {0x0B,
+								     0x10,
+								     0x0F},
+	/* Index 0xF4~0xF7 */
+	{0x0B, 0x10, 0x10}, {0x0B, 0x0F, 0x10}, {0x0B, 0x0D, 0x10}, {0x0B,
+								     0x0C,
+								     0x10},
+	/* Index 0xF8~0xFB */
+	{0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00,
+								     0x00,
+								     0x00},
+	/* Index 0xFC~0xFF */
+	{0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00,
+								     0x00,
+								     0x00}
+};
+
+void write_reg(u8 index, u16 io_port, u8 data)
+{
+	outb(index, io_port);
+	outb(data, io_port + 1);
+	/*DEBUG_MSG(KERN_INFO "\nIndex=%2d Value=%2d", index, data); */
+}
+u8 read_reg(int io_port, u8 index)
+{
+	outb(index, io_port);
+	return (inb(io_port + 1));
+}
+
+void lock_crt(void)
+{
+	write_reg_mask(CR11, VIACR, BIT7, BIT7);
+}
+
+void unlock_crt(void)
+{
+	write_reg_mask(CR11, VIACR, 0, BIT7);
+	write_reg_mask(CR47, VIACR, 0, BIT0);
+}
+
+void write_reg_mask(u8 index, int io_port, u8 data, u8 mask)
+{
+	u8 tmp;
+
+	outb(index, io_port);
+	tmp = inb(io_port + 1);
+	outb((data & mask) | (tmp & (~mask)), io_port + 1);
+	/*DEBUG_MSG(KERN_INFO "\nIndex=%2d Value=%2d", index, tmp); */
+}
+
+void write_dac_reg(u8 index, u8 r, u8 g, u8 b)
+{
+	outb(index, LUT_INDEX_WRITE);
+	outb(r, LUT_DATA);
+	outb(g, LUT_DATA);
+	outb(b, LUT_DATA);
+}
+
+/*Set IGA path for each device*/
+void set_iga_path(void)
+{
+
+	if (SAMM_ON == 1) {
+		if (CRT_ON) {
+			if (primary_dev == CRT_Device) {
+				crt_setting_info.iga_path = IGA1;
+			} else {
+				crt_setting_info.iga_path = IGA2;
+			}
+		}
+
+		if (DVI_ON) {
+			if (primary_dev == DVI_Device) {
+				tmds_setting_info.iga_path = IGA1;
+			} else {
+				tmds_setting_info.iga_path = IGA2;
+			}
+		}
+
+		if (LCD_ON) {
+			if (primary_dev == LCD_Device) {
+				if (dual_fb
+				    && (chip_info.gfx_chip_name ==
+					UNICHROME_CLE266)) {
+					lvds_setting_info.iga_path = IGA2;
+					crt_setting_info.iga_path = IGA1;
+					tmds_setting_info.iga_path = IGA1;
+				} else
+					lvds_setting_info.iga_path = IGA1;
+			} else {
+				lvds_setting_info.iga_path = IGA2;
+			}
+		}
+		if (LCD2_ON) {
+			if (LCD2_Device == primary_dev) {
+				lvds_setting_info2.iga_path = IGA1;
+			} else {
+				lvds_setting_info2.iga_path = IGA2;
+			}
+		}
+	} else {
+		SAMM_ON = 0;
+
+		if (CRT_ON && LCD_ON) {
+			crt_setting_info.iga_path = IGA1;
+			lvds_setting_info.iga_path = IGA2;
+		} else if (CRT_ON && DVI_ON) {
+			crt_setting_info.iga_path = IGA1;
+			tmds_setting_info.iga_path = IGA2;
+		} else if (LCD_ON && DVI_ON) {
+			tmds_setting_info.iga_path = IGA1;
+			lvds_setting_info.iga_path = IGA2;
+		} else if (LCD_ON && LCD2_ON) {
+			lvds_setting_info.iga_path = IGA2;
+			lvds_setting_info2.iga_path = IGA2;
+		} else if (CRT_ON) {
+			crt_setting_info.iga_path = IGA1;
+		} else if (LCD_ON) {
+			lvds_setting_info.iga_path = IGA2;
+		} else if (DVI_ON) {
+			tmds_setting_info.iga_path = IGA1;
+		}
+	}
+}
+
+void set_start_addr(void)
+{
+	unsigned long offset = 0, tmp = 0, size = 0;
+	unsigned long length;
+
+	DEBUG_MSG(KERN_INFO "set_start_addr!\n");
+	unlock_crt();
+	/* update starting address of IGA1 */
+	write_reg(CR0C, VIACR, 0x00);	/*initial starting address */
+	write_reg(CR0D, VIACR, 0x00);
+	write_reg(CR34, VIACR, 0x00);
+	write_reg_mask(CR48, VIACR, 0x00, 0x1F);
+
+	if (dual_fb) {
+		parinfo.iga_path = IGA1;
+		parinfo1.iga_path = IGA2;
+	}
+
+	if (SAMM_ON == 1) {
+		if (!dual_fb) {
+			if (second_size) {
+				size = second_size * 1024 * 1024;
+			} else {
+				size = 8 * 1024 * 1024;
+			}
+		} else {
+
+			size = parinfo1.memsize;
+		}
+		offset = second_offset;
+		DEBUG_MSG(KERN_INFO
+			  "second_size=%lx, second start_adddress=%lx\n",
+			  size, offset);
+	}
+	if (SAMM_ON == 1) {
+		offset = offset >> 3;
+
+		tmp = read_reg(VIACR, 0x62) & 0x01;
+		tmp |= (offset & 0x7F) << 1;
+		write_reg(CR62, VIACR, tmp);
+		write_reg(CR63, VIACR, ((offset & 0x7F80) >> 7));
+		write_reg(CR64, VIACR, ((offset & 0x7F8000) >> 15));
+		write_reg(CRA3, VIACR, ((offset & 0x3800000) >> 23));
+	} else {
+		/* update starting address */
+		write_reg(CR62, VIACR, 0x00);
+		write_reg(CR63, VIACR, 0x00);
+		write_reg(CR64, VIACR, 0x00);
+		write_reg(CRA3, VIACR, 0x00);
+	}
+
+	if (SAMM_ON == 1) {
+		if (via_fb_accel) {
+			if (!dual_fb)
+				length = size - parinfo.fbmem_used;
+			else
+				length = size - parinfo1.fbmem_used;
+		} else
+			length = size;
+		offset = (unsigned long)(void *)FB_MM + second_offset;
+		memset_io((void *)offset, 0, length);
+	}
+
+	lock_crt();
+}
+
+void set_output_path(int device, int set_iga, int output_interface)
+{
+	switch (device) {
+	case DEVICE_CRT:
+		set_crt_output_path(set_iga);
+		break;
+	case DEVICE_DVI:
+		set_dvi_output_path(set_iga, output_interface);
+		break;
+	case DEVICE_LCD:
+		set_lcd_output_path(set_iga, output_interface);
+		break;
+	}
+}
+
+void set_crt_output_path(int set_iga)
+{
+	write_reg_mask(CR36, VIACR, 0x00, BIT4 + BIT5);
+
+	switch (set_iga) {
+	case IGA1:
+		write_reg_mask(SR16, VIASR, 0x00, BIT6);
+		break;
+	case IGA2:
+	case IGA1_IGA2:
+		write_reg_mask(CR6A, VIACR, 0xC0, BIT6 + BIT7);
+		write_reg_mask(SR16, VIASR, 0x40, BIT6);
+		if (set_iga == IGA1_IGA2)
+			write_reg_mask(CR6B, VIACR, 0x08, BIT3);
+		break;
+	}
+}
+
+void dvi_patch_skew_dvp0(void)
+{
+	/* Reset data driving first: */
+	write_reg_mask(SR1B, VIASR, 0, BIT1);
+	write_reg_mask(SR2A, VIASR, 0, BIT4);
+
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_P4M890:
+		{
+			if ((tmds_setting_info.h_active == 1600)
+			    && (tmds_setting_info.v_active == 1200))
+				write_reg_mask(CR96, VIACR, 0x03,
+					       BIT0 + BIT1 + BIT2);
+			else
+				write_reg_mask(CR96, VIACR, 0x07,
+					       BIT0 + BIT1 + BIT2);
+			break;
+		}
+
+	case UNICHROME_P4M900:
+		{
+			write_reg_mask(CR96, VIACR, 0x07,
+				       BIT0 + BIT1 + BIT2 + BIT3);
+			write_reg_mask(SR1B, VIASR, 0x02, BIT1);
+			write_reg_mask(SR2A, VIASR, 0x10, BIT4);
+			break;
+		}
+
+	default:
+		{
+			break;
+		}
+	}
+}
+
+void dvi_patch_skew_dvp1(void)
+{
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_CX700:
+		{
+			break;
+		}
+
+	default:
+		{
+			break;
+		}
+	}
+}
+
+void dvi_patch_skew_dvp_low(void)
+{
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_K8M890:
+		{
+			write_reg_mask(CR99, VIACR, 0x03, BIT0 + BIT1);
+			break;
+		}
+
+	case UNICHROME_P4M900:
+		{
+			write_reg_mask(CR99, VIACR, 0x08,
+				       BIT0 + BIT1 + BIT2 + BIT3);
+			break;
+		}
+
+	case UNICHROME_P4M890:
+		{
+			write_reg_mask(CR99, VIACR, 0x0F,
+				       BIT0 + BIT1 + BIT2 + BIT3);
+			break;
+		}
+
+	default:
+		{
+			break;
+		}
+	}
+}
+
+void set_dvi_output_path(int set_iga, int output_interface)
+{
+	switch (output_interface) {
+	case INTERFACE_DVP0:
+		write_reg_mask(CR6B, VIACR, 0x01, BIT0);
+
+		if (set_iga == IGA1) {
+			write_reg_mask(CR96, VIACR, 0x00, BIT4);
+			write_reg_mask(CR6C, VIACR, 0x21, BIT0 + BIT5 + BIT7);
+		} else {
+			write_reg_mask(CR96, VIACR, 0x10, BIT4);
+			write_reg_mask(CR6C, VIACR, 0xA1, BIT0 + BIT5 + BIT7);
+		}
+
+		write_reg_mask(SR1E, VIASR, 0xC0, BIT7 + BIT6);
+
+		dvi_patch_skew_dvp0();
+		break;
+
+	case INTERFACE_DVP1:
+		if (chip_info.gfx_chip_name == UNICHROME_CLE266) {
+			if (set_iga == IGA1)
+				write_reg_mask(CR93, VIACR, 0x21,
+					       BIT0 + BIT5 + BIT7);
+			else
+				write_reg_mask(CR93, VIACR, 0xA1,
+					       BIT0 + BIT5 + BIT7);
+		} else {
+			if (set_iga == IGA1)
+				write_reg_mask(CR9B, VIACR, 0x00, BIT4);
+			else
+				write_reg_mask(CR9B, VIACR, 0x10, BIT4);
+		}
+
+		write_reg_mask(SR1E, VIASR, 0x30, BIT4 + BIT5);
+		dvi_patch_skew_dvp1();
+		break;
+	case INTERFACE_DFP_HIGH:
+		if (chip_info.gfx_chip_name != UNICHROME_CLE266) {
+			if (set_iga == IGA1) {
+				write_reg_mask(CR96, VIACR, 0x00, BIT4);
+				write_reg_mask(CR97, VIACR, 0x03,
+					       BIT0 + BIT1 + BIT4);
+			} else {
+				write_reg_mask(CR96, VIACR, 0x10, BIT4);
+				write_reg_mask(CR97, VIACR, 0x13,
+					       BIT0 + BIT1 + BIT4);
+			}
+		}
+		write_reg_mask(SR2A, VIASR, 0x0C, BIT2 + BIT3);
+		break;
+
+	case INTERFACE_DFP_LOW:
+		if (chip_info.gfx_chip_name == UNICHROME_CLE266)
+			break;
+
+		if (set_iga == IGA1) {
+			write_reg_mask(CR99, VIACR, 0x00, BIT4);
+			write_reg_mask(CR9B, VIACR, 0x00, BIT4);
+		} else {
+			write_reg_mask(CR99, VIACR, 0x10, BIT4);
+			write_reg_mask(CR9B, VIACR, 0x10, BIT4);
+		}
+
+		write_reg_mask(SR2A, VIASR, 0x03, BIT0 + BIT1);
+		dvi_patch_skew_dvp_low();
+		break;
+
+	case INTERFACE_TMDS:
+		if (set_iga == IGA1) {
+			write_reg_mask(CR99, VIACR, 0x00, BIT4);
+		} else {
+			write_reg_mask(CR99, VIACR, 0x10, BIT4);
+		}
+		break;
+	}
+
+	if (set_iga == IGA2) {
+		enable_second_display_channel();
+		/* Disable LCD Scaling */
+		write_reg_mask(CR79, VIACR, 0x00, BIT0);
+	}
+}
+
+void set_lcd_output_path(int set_iga, int output_interface)
+{
+	DEBUG_MSG(KERN_INFO
+		  "set_lcd_output_path, iga:%d,out_interface:%d\n",
+		  set_iga, output_interface);
+	switch (set_iga) {
+	case IGA1:
+		write_reg_mask(CR6B, VIACR, 0x00, BIT3);
+		write_reg_mask(CR6A, VIACR, 0x08, BIT3);
+
+		disable_second_display_channel();
+		break;
+
+	case IGA2:
+		write_reg_mask(CR6B, VIACR, 0x00, BIT3);
+		write_reg_mask(CR6A, VIACR, 0x08, BIT3);
+
+		enable_second_display_channel();
+		break;
+
+	case IGA1_IGA2:
+		write_reg_mask(CR6B, VIACR, 0x08, BIT3);
+		write_reg_mask(CR6A, VIACR, 0x08, BIT3);
+
+		disable_second_display_channel();
+		break;
+	}
+
+	switch (output_interface) {
+	case INTERFACE_DVP0:
+		if (set_iga == IGA1) {
+			write_reg_mask(CR96, VIACR, 0x00, BIT4);
+		} else {
+			write_reg(CR91, VIACR, 0x00);
+			write_reg_mask(CR96, VIACR, 0x10, BIT4);
+		}
+		break;
+
+	case INTERFACE_DVP1:
+		if (set_iga == IGA1)
+			write_reg_mask(CR9B, VIACR, 0x00, BIT4);
+		else {
+			write_reg(CR91, VIACR, 0x00);
+			write_reg_mask(CR9B, VIACR, 0x10, BIT4);
+		}
+		break;
+
+	case INTERFACE_DFP_HIGH:
+		if (set_iga == IGA1)
+			write_reg_mask(CR97, VIACR, 0x00, BIT4);
+		else {
+			write_reg(CR91, VIACR, 0x00);
+			write_reg_mask(CR97, VIACR, 0x10, BIT4);
+			write_reg_mask(CR96, VIACR, 0x10, BIT4);
+		}
+		break;
+
+	case INTERFACE_DFP_LOW:
+		if (set_iga == IGA1)
+			write_reg_mask(CR99, VIACR, 0x00, BIT4);
+		else {
+			write_reg(CR91, VIACR, 0x00);
+			write_reg_mask(CR99, VIACR, 0x10, BIT4);
+			write_reg_mask(CR9B, VIACR, 0x10, BIT4);
+		}
+
+		break;
+
+	case INTERFACE_DFP:
+		if ((UNICHROME_K8M890 == chip_info.gfx_chip_name)
+		    || (UNICHROME_P4M890 == chip_info.gfx_chip_name))
+			write_reg_mask(CR97, VIACR, 0x84,
+				       BIT7 + BIT2 + BIT1 + BIT0);
+		if (set_iga == IGA1) {
+			write_reg_mask(CR97, VIACR, 0x00, BIT4);
+			write_reg_mask(CR99, VIACR, 0x00, BIT4);
+		} else {
+			write_reg(CR91, VIACR, 0x00);
+			write_reg_mask(CR97, VIACR, 0x10, BIT4);
+			write_reg_mask(CR99, VIACR, 0x10, BIT4);
+		}
+		break;
+
+	case INTERFACE_LVDS0:
+	case INTERFACE_LVDS0LVDS1:
+		if (set_iga == IGA1) {
+			write_reg_mask(CR99, VIACR, 0x00, BIT4);
+		} else {
+			write_reg_mask(CR99, VIACR, 0x10, BIT4);
+		}
+
+		break;
+
+	case INTERFACE_LVDS1:
+		if (set_iga == IGA1) {
+			write_reg_mask(CR97, VIACR, 0x00, BIT4);
+		} else {
+			write_reg_mask(CR97, VIACR, 0x10, BIT4);
+		}
+
+		break;
+	}
+}
+
+/* Search Mode Index */
+int search_mode_setting(int ModeInfoIndex)
+{
+	int i = 0;
+
+	while ((i < NUM_TOTAL_MODETABLE)
+	       && (ModeInfoIndex != CLE266Modes[i].ModeIndex)) i++;
+	if ((i >= NUM_TOTAL_MODETABLE))
+		i = 0;
+	return i;
+
+}
+
+struct VideoModeTable *get_modetbl_pointer(int Index)
+{
+	struct VideoModeTable *TmpTbl = NULL;
+	TmpTbl = &CLE266Modes[search_mode_setting(Index)];
+	return (TmpTbl);
+}
+
+struct VideoModeTable *get_cea_mode_tbl_pointer(int Index)
+{
+	struct VideoModeTable *TmpTbl = NULL;
+	int i = 0;
+	while ((i < NUM_TOTAL_CEA_MODES)
+	       && (Index != CEA_HDMI_Modes[i].ModeIndex)) i++;
+	if ((i < NUM_TOTAL_CEA_MODES))
+		TmpTbl = &CEA_HDMI_Modes[i];
+	 else {
+		/*Still use general timing if don't find CEA timing */
+		i = 0;
+		while ((i < NUM_TOTAL_MODETABLE)
+		       && (Index != CLE266Modes[i].ModeIndex))
+		       i++;
+		if ((i >= NUM_TOTAL_MODETABLE))
+			i = 0;
+		TmpTbl = &CLE266Modes[i];
+	}
+	return TmpTbl;
+}
+
+void load_fix_bit_crtc_reg(void)
+{
+	/* always set to 1 */
+	write_reg_mask(CR03, VIACR, 0x80, BIT7);
+	/* line compare should set all bits = 1 (extend modes) */
+	write_reg(CR18, VIACR, 0xff);
+	/* line compare should set all bits = 1 (extend modes) */
+	write_reg_mask(CR07, VIACR, 0x10, BIT4);
+	/* line compare should set all bits = 1 (extend modes) */
+	write_reg_mask(CR09, VIACR, 0x40, BIT6);
+	/* line compare should set all bits = 1 (extend modes) */
+	write_reg_mask(CR35, VIACR, 0x10, BIT4);
+	/* line compare should set all bits = 1 (extend modes) */
+	write_reg_mask(CR33, VIACR, 0x06, BIT0 + BIT1 + BIT2);
+	/*write_reg_mask(CR32, VIACR, 0x01, BIT0); */
+	write_reg(CR17, VIACR, 0xe3);	/* extend mode always set to e3h */
+	write_reg(CR08, VIACR, 0x00);	/* extend mode always set to 0h */
+	write_reg(CR14, VIACR, 0x00);	/* extend mode always set to 0h */
+
+	/* If K8M800, enable Prefetch Mode. */
+	if ((chip_info.gfx_chip_name == UNICHROME_K800)
+		|| (chip_info.gfx_chip_name == UNICHROME_K8M890))
+		write_reg_mask(CR33, VIACR, 0x08, BIT3);
+	if ((chip_info.gfx_chip_name == UNICHROME_CLE266)
+	    && (chip_info.gfx_chip_revision == CLE266_REVISION_AX))
+		write_reg_mask(SR1A, VIASR, 0x02, BIT1);
+
+}
+
+void load_reg(int timing_value, int load_reg_num, struct io_register *reg,
+	      int io_type)
+{
+	int reg_mask;
+	int bit_num = 0;
+	int data;
+	int i, j;
+	int shift_next_reg;
+	int start_index, end_index, cr_index;
+	u16 get_bit;
+
+	for (i = 0; i < load_reg_num; i++) {
+		reg_mask = 0;
+		data = 0;
+		start_index = reg[i].start_bit;
+		end_index = reg[i].end_bit;
+		cr_index = reg[i].io_addr;
+
+		shift_next_reg = bit_num;
+		for (j = start_index; j <= end_index; j++) {
+			/*if (bit_num==8) timing_value = timing_value >>8; */
+			reg_mask = reg_mask | (BIT0 << j);
+			get_bit = (timing_value & (BIT0 << bit_num));
+			data =
+			    data | ((get_bit >> shift_next_reg) << start_index);
+			bit_num++;
+		}
+		if (io_type == VIACR) {
+			write_reg_mask(cr_index, VIACR, data, reg_mask);
+		} else {
+			write_reg_mask(cr_index, VIASR, data, reg_mask);
+		}
+
+	}
+
+}
+
+/* Write Registers */
+void write_regx(struct io_reg RegTable[], int ItemNum)
+{
+	int i;
+	unsigned char RegTemp;
+
+	/*DEBUG_MSG(KERN_INFO "Table Size : %x!!\n",ItemNum ); */
+
+	for (i = 0; i < ItemNum; i++) {
+		outb(RegTable[i].index, RegTable[i].port);
+		RegTemp = inb(RegTable[i].port + 1);
+		RegTemp = (RegTemp & (~RegTable[i].mask)) | RegTable[i].value;
+		outb(RegTemp, RegTable[i].port + 1);
+	}
+}
+
+void load_offset_reg(int h_addr, int bpp_byte, int set_iga)
+{
+	int reg_value;
+	int load_reg_num;
+	struct io_register *reg;
+
+	switch (set_iga) {
+	case IGA1_IGA2:
+	case IGA1:
+		reg_value = IGA1_OFFSET_FORMULA(h_addr, bpp_byte);
+		load_reg_num = offset_reg.iga1_offset_reg.reg_num;
+		reg = offset_reg.iga1_offset_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIACR);
+		if (set_iga == IGA1)
+			break;
+	case IGA2:
+		reg_value = IGA2_OFFSET_FORMULA(h_addr, bpp_byte);
+		load_reg_num = offset_reg.iga2_offset_reg.reg_num;
+		reg = offset_reg.iga2_offset_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIACR);
+		break;
+	}
+}
+
+void load_fetch_count_reg(int h_addr, int bpp_byte, int set_iga)
+{
+	int reg_value;
+	int load_reg_num;
+	struct io_register *reg = NULL;
+
+	switch (set_iga) {
+	case IGA1_IGA2:
+	case IGA1:
+		reg_value = IGA1_FETCH_COUNT_FORMULA(h_addr, bpp_byte);
+		load_reg_num = fetch_count_reg.iga1_fetch_count_reg.reg_num;
+		reg = fetch_count_reg.iga1_fetch_count_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIASR);
+		if (set_iga == IGA1)
+			break;
+	case IGA2:
+		reg_value = IGA2_FETCH_COUNT_FORMULA(h_addr, bpp_byte);
+		load_reg_num = fetch_count_reg.iga2_fetch_count_reg.reg_num;
+		reg = fetch_count_reg.iga2_fetch_count_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIACR);
+		break;
+	}
+
+}
+
+void load_FIFO_reg(int set_iga, int hor_active, int ver_active)
+{
+	int reg_value;
+	int load_reg_num;
+	struct io_register *reg = NULL;
+	int iga1_fifo_max_depth = 0, iga1_fifo_threshold =
+	    0, iga1_fifo_high_threshold = 0, iga1_display_queue_expire_num = 0;
+	int iga2_fifo_max_depth = 0, iga2_fifo_threshold =
+	    0, iga2_fifo_high_threshold = 0, iga2_display_queue_expire_num = 0;
+
+	if (set_iga == IGA1) {
+		if (chip_info.gfx_chip_name == UNICHROME_K800) {
+			iga1_fifo_max_depth = K800_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = K800_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    K800_IGA1_FIFO_HIGH_THRESHOLD;
+			/* If resolution > 1280x1024, expire length = 64, else
+			   expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga1_display_queue_expire_num = 16;
+			else
+				iga1_display_queue_expire_num =
+				    K800_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_PM800) {
+			iga1_fifo_max_depth = P880_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = P880_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    P880_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    P880_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+
+			/* If resolution > 1280x1024, expire length = 64, else
+			   expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga1_display_queue_expire_num = 16;
+			else
+				iga1_display_queue_expire_num =
+				    P880_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_CN700) {
+			iga1_fifo_max_depth = CN700_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = CN700_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    CN700_IGA1_FIFO_HIGH_THRESHOLD;
+
+			/* If resolution > 1280x1024, expire length = 64,
+			   else expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga1_display_queue_expire_num = 16;
+			else
+				iga1_display_queue_expire_num =
+				    CN700_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_CX700) {
+			iga1_fifo_max_depth = CX700_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = CX700_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    CX700_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    CX700_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_K8M890) {
+			iga1_fifo_max_depth = K8M890_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = K8M890_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    K8M890_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    K8M890_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_P4M890) {
+			iga1_fifo_max_depth = P4M890_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = P4M890_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    P4M890_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    P4M890_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_P4M900) {
+			iga1_fifo_max_depth = P4M900_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = P4M900_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    P4M900_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    P4M900_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_VX800) {
+			iga1_fifo_max_depth = VX800_IGA1_FIFO_MAX_DEPTH;
+			iga1_fifo_threshold = VX800_IGA1_FIFO_THRESHOLD;
+			iga1_fifo_high_threshold =
+			    VX800_IGA1_FIFO_HIGH_THRESHOLD;
+			iga1_display_queue_expire_num =
+			    VX800_IGA1_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		/* Set Display FIFO Depath Select */
+		reg_value = IGA1_FIFO_DEPTH_SELECT_FORMULA(iga1_fifo_max_depth);
+		load_reg_num =
+		    display_fifo_depth_reg.iga1_fifo_depth_select_reg.reg_num;
+		reg = display_fifo_depth_reg.iga1_fifo_depth_select_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIASR);
+
+		/* Set Display FIFO Threshold Select */
+		reg_value = IGA1_FIFO_THRESHOLD_FORMULA(iga1_fifo_threshold);
+		load_reg_num =
+		    fifo_threshold_select_reg.
+		    iga1_fifo_threshold_select_reg.reg_num;
+		reg =
+		    fifo_threshold_select_reg.
+		    iga1_fifo_threshold_select_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIASR);
+
+		/* Set FIFO High Threshold Select */
+		reg_value =
+		    IGA1_FIFO_HIGH_THRESHOLD_FORMULA(iga1_fifo_high_threshold);
+		load_reg_num =
+		    fifo_high_threshold_select_reg.
+		    iga1_fifo_high_threshold_select_reg.reg_num;
+		reg =
+		    fifo_high_threshold_select_reg.
+		    iga1_fifo_high_threshold_select_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIASR);
+
+		/* Set Display Queue Expire Num */
+		reg_value =
+		    IGA1_DISPLAY_QUEUE_EXPIRE_NUM_FORMULA
+		    (iga1_display_queue_expire_num);
+		load_reg_num =
+		    display_queue_expire_num_reg.
+		    iga1_display_queue_expire_num_reg.reg_num;
+		reg =
+		    display_queue_expire_num_reg.
+		    iga1_display_queue_expire_num_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIASR);
+
+	} else {
+		if (chip_info.gfx_chip_name == UNICHROME_K800) {
+			iga2_fifo_max_depth = K800_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = K800_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    K800_IGA2_FIFO_HIGH_THRESHOLD;
+
+			/* If resolution > 1280x1024, expire length = 64,
+			   else  expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga2_display_queue_expire_num = 16;
+			else
+				iga2_display_queue_expire_num =
+				    K800_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_PM800) {
+			iga2_fifo_max_depth = P880_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = P880_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    P880_IGA2_FIFO_HIGH_THRESHOLD;
+
+			/* If resolution > 1280x1024, expire length = 64,
+			   else  expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga2_display_queue_expire_num = 16;
+			else
+				iga2_display_queue_expire_num =
+				    P880_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_CN700) {
+			iga2_fifo_max_depth = CN700_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = CN700_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    CN700_IGA2_FIFO_HIGH_THRESHOLD;
+
+			/* If resolution > 1280x1024, expire length = 64,
+			   else expire length = 128 */
+			if ((hor_active > 1280) && (ver_active > 1024))
+				iga2_display_queue_expire_num = 16;
+			else
+				iga2_display_queue_expire_num =
+				    CN700_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_CX700) {
+			iga2_fifo_max_depth = CX700_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = CX700_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    CX700_IGA2_FIFO_HIGH_THRESHOLD;
+			iga2_display_queue_expire_num =
+			    CX700_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_K8M890) {
+			iga2_fifo_max_depth = K8M890_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = K8M890_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    K8M890_IGA2_FIFO_HIGH_THRESHOLD;
+			iga2_display_queue_expire_num =
+			    K8M890_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_P4M890) {
+			iga2_fifo_max_depth = P4M890_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = P4M890_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    P4M890_IGA2_FIFO_HIGH_THRESHOLD;
+			iga2_display_queue_expire_num =
+			    P4M890_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_P4M900) {
+			iga2_fifo_max_depth = P4M900_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = P4M900_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    P4M900_IGA2_FIFO_HIGH_THRESHOLD;
+			iga2_display_queue_expire_num =
+			    P4M900_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_VX800) {
+			iga2_fifo_max_depth = VX800_IGA2_FIFO_MAX_DEPTH;
+			iga2_fifo_threshold = VX800_IGA2_FIFO_THRESHOLD;
+			iga2_fifo_high_threshold =
+			    VX800_IGA2_FIFO_HIGH_THRESHOLD;
+			iga2_display_queue_expire_num =
+			    VX800_IGA2_DISPLAY_QUEUE_EXPIRE_NUM;
+		}
+
+		if (chip_info.gfx_chip_name == UNICHROME_K800) {
+			/* Set Display FIFO Depath Select */
+			reg_value =
+			    IGA2_FIFO_DEPTH_SELECT_FORMULA(iga2_fifo_max_depth)
+			    - 1;
+			/* Patch LCD in IGA2 case */
+			load_reg_num =
+			    display_fifo_depth_reg.
+			    iga2_fifo_depth_select_reg.reg_num;
+			reg =
+			    display_fifo_depth_reg.
+			    iga2_fifo_depth_select_reg.reg;
+			load_reg(reg_value, load_reg_num, reg, VIACR);
+		} else {
+
+			/* Set Display FIFO Depath Select */
+			reg_value =
+			    IGA2_FIFO_DEPTH_SELECT_FORMULA(iga2_fifo_max_depth);
+			load_reg_num =
+			    display_fifo_depth_reg.
+			    iga2_fifo_depth_select_reg.reg_num;
+			reg =
+			    display_fifo_depth_reg.
+			    iga2_fifo_depth_select_reg.reg;
+			load_reg(reg_value, load_reg_num, reg, VIACR);
+		}
+
+		/* Set Display FIFO Threshold Select */
+		reg_value = IGA2_FIFO_THRESHOLD_FORMULA(iga2_fifo_threshold);
+		load_reg_num =
+		    fifo_threshold_select_reg.
+		    iga2_fifo_threshold_select_reg.reg_num;
+		reg =
+		    fifo_threshold_select_reg.
+		    iga2_fifo_threshold_select_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIACR);
+
+		/* Set FIFO High Threshold Select */
+		reg_value =
+		    IGA2_FIFO_HIGH_THRESHOLD_FORMULA(iga2_fifo_high_threshold);
+		load_reg_num =
+		    fifo_high_threshold_select_reg.
+		    iga2_fifo_high_threshold_select_reg.reg_num;
+		reg =
+		    fifo_high_threshold_select_reg.
+		    iga2_fifo_high_threshold_select_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIACR);
+
+		/* Set Display Queue Expire Num */
+		reg_value =
+		    IGA2_DISPLAY_QUEUE_EXPIRE_NUM_FORMULA
+		    (iga2_display_queue_expire_num);
+		load_reg_num =
+		    display_queue_expire_num_reg.
+		    iga2_display_queue_expire_num_reg.reg_num;
+		reg =
+		    display_queue_expire_num_reg.
+		    iga2_display_queue_expire_num_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIACR);
+
+	}
+
+}
+
+u32 get_clk_value(int clk)
+{
+	int i;
+
+	for (i = 0; i < NUM_TOTAL_PLL_TABLE; i++) {
+		if (clk == pll_value[i].clk) {
+			switch (chip_info.gfx_chip_name) {
+			case UNICHROME_CLE266:
+			case UNICHROME_K400:
+				return (pll_value[i].cle266_pll);
+
+			case UNICHROME_K800:
+			case UNICHROME_PM800:
+			case UNICHROME_CN700:
+				return (pll_value[i].k800_pll);
+
+			case UNICHROME_CX700:
+			case UNICHROME_K8M890:
+			case UNICHROME_P4M890:
+			case UNICHROME_P4M900:
+			case UNICHROME_VX800:
+				return (pll_value[i].cx700_pll);
+			}
+		}
+	}
+
+	DEBUG_MSG(KERN_INFO "Can't find match PLL value\n\n");
+	return (0);
+}
+
+/* Set VCLK*/
+void set_vclock(u32 CLK, int set_iga)
+{
+	unsigned char RegTemp;
+
+	/* H.W. Reset : ON */
+	write_reg_mask(CR17, VIACR, 0x00, BIT7);
+
+	if ((set_iga == IGA1) || (set_iga == IGA1_IGA2)) {
+		/* Change D,N FOR VCLK */
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			write_reg(SR46, VIASR, CLK / 0x100);
+			write_reg(SR47, VIASR, CLK % 0x100);
+			break;
+
+		case UNICHROME_K800:
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M890:
+		case UNICHROME_P4M900:
+		case UNICHROME_VX800:
+			write_reg(SR44, VIASR, CLK / 0x10000);
+			DEBUG_MSG(KERN_INFO "\nSR44=%x", CLK / 0x10000);
+			write_reg(SR45, VIASR, (CLK & 0xFFFF) / 0x100);
+			DEBUG_MSG(KERN_INFO "\nSR45=%x",
+				  (CLK & 0xFFFF) / 0x100);
+			write_reg(SR46, VIASR, CLK % 0x100);
+			DEBUG_MSG(KERN_INFO "\nSR46=%x", CLK % 0x100);
+			break;
+		}
+	}
+
+	if ((set_iga == IGA2) || (set_iga == IGA1_IGA2)) {
+		/* Change D,N FOR LCK */
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			write_reg(SR44, VIASR, CLK / 0x100);
+			write_reg(SR45, VIASR, CLK % 0x100);
+			break;
+
+		case UNICHROME_K800:
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M890:
+		case UNICHROME_P4M900:
+		case UNICHROME_VX800:
+			write_reg(SR4A, VIASR, CLK / 0x10000);
+			write_reg(SR4B, VIASR, (CLK & 0xFFFF) / 0x100);
+			write_reg(SR4C, VIASR, CLK % 0x100);
+			break;
+		}
+	}
+
+	/* H.W. Reset : OFF */
+	write_reg_mask(CR17, VIACR, 0x80, BIT7);
+
+	/* Reset PLL */
+	if ((set_iga == IGA1) || (set_iga == IGA1_IGA2)) {
+		write_reg_mask(SR40, VIASR, 0x02, BIT1);
+		write_reg_mask(SR40, VIASR, 0x00, BIT1);
+	}
+
+	if ((set_iga == IGA2) || (set_iga == IGA1_IGA2)) {
+		write_reg_mask(SR40, VIASR, 0x01, BIT0);
+		write_reg_mask(SR40, VIASR, 0x00, BIT0);
+	}
+
+	/* Fire! */
+	RegTemp = inb(VIARMisc);
+	outb(RegTemp | (BIT2 + BIT3), VIAWMisc);
+}
+
+void load_crtc_timing(struct display_timing device_timing, int set_iga)
+{
+	int i;
+	int load_reg_num = 0;
+	int reg_value = 0;
+	struct io_register *reg = NULL;
+
+	unlock_crt();
+
+	for (i = 0; i < 12; i++) {
+		if (set_iga == IGA1) {
+			switch (i) {
+			case H_TOTAL_INDEX:
+				reg_value =
+				    IGA1_HOR_TOTAL_FORMULA(device_timing.
+							   hor_total);
+				load_reg_num = iga1_crtc_reg.hor_total.reg_num;
+				reg = iga1_crtc_reg.hor_total.reg;
+				break;
+			case H_ADDR_INDEX:
+				reg_value =
+				    IGA1_HOR_ADDR_FORMULA(device_timing.
+							  hor_addr);
+				load_reg_num = iga1_crtc_reg.hor_addr.reg_num;
+				reg = iga1_crtc_reg.hor_addr.reg;
+				break;
+			case H_BLANK_START_INDEX:
+				reg_value =
+				    IGA1_HOR_BLANK_START_FORMULA
+				    (device_timing.hor_blank_start);
+				load_reg_num =
+				    iga1_crtc_reg.hor_blank_start.reg_num;
+				reg = iga1_crtc_reg.hor_blank_start.reg;
+				break;
+			case H_BLANK_END_INDEX:
+				reg_value =
+				    IGA1_HOR_BLANK_END_FORMULA
+				    (device_timing.hor_blank_start,
+				     device_timing.hor_blank_end);
+				load_reg_num =
+				    iga1_crtc_reg.hor_blank_end.reg_num;
+				reg = iga1_crtc_reg.hor_blank_end.reg;
+				break;
+			case H_SYNC_START_INDEX:
+				reg_value =
+				    IGA1_HOR_SYNC_START_FORMULA
+				    (device_timing.hor_sync_start);
+				load_reg_num =
+				    iga1_crtc_reg.hor_sync_start.reg_num;
+				reg = iga1_crtc_reg.hor_sync_start.reg;
+				break;
+			case H_SYNC_END_INDEX:
+				reg_value =
+				    IGA1_HOR_SYNC_END_FORMULA
+				    (device_timing.hor_sync_start,
+				     device_timing.hor_sync_end);
+				load_reg_num =
+				    iga1_crtc_reg.hor_sync_end.reg_num;
+				reg = iga1_crtc_reg.hor_sync_end.reg;
+				break;
+			case V_TOTAL_INDEX:
+				reg_value =
+				    IGA1_VER_TOTAL_FORMULA(device_timing.
+							   ver_total);
+				load_reg_num = iga1_crtc_reg.ver_total.reg_num;
+				reg = iga1_crtc_reg.ver_total.reg;
+				break;
+			case V_ADDR_INDEX:
+				reg_value =
+				    IGA1_VER_ADDR_FORMULA(device_timing.
+							  ver_addr);
+				load_reg_num = iga1_crtc_reg.ver_addr.reg_num;
+				reg = iga1_crtc_reg.ver_addr.reg;
+				break;
+			case V_BLANK_START_INDEX:
+				reg_value =
+				    IGA1_VER_BLANK_START_FORMULA
+				    (device_timing.ver_blank_start);
+				load_reg_num =
+				    iga1_crtc_reg.ver_blank_start.reg_num;
+				reg = iga1_crtc_reg.ver_blank_start.reg;
+				break;
+			case V_BLANK_END_INDEX:
+				reg_value =
+				    IGA1_VER_BLANK_END_FORMULA
+				    (device_timing.ver_blank_start,
+				     device_timing.ver_blank_end);
+				load_reg_num =
+				    iga1_crtc_reg.ver_blank_end.reg_num;
+				reg = iga1_crtc_reg.ver_blank_end.reg;
+				break;
+			case V_SYNC_START_INDEX:
+				reg_value =
+				    IGA1_VER_SYNC_START_FORMULA
+				    (device_timing.ver_sync_start);
+				load_reg_num =
+				    iga1_crtc_reg.ver_sync_start.reg_num;
+				reg = iga1_crtc_reg.ver_sync_start.reg;
+				break;
+			case V_SYNC_END_INDEX:
+				reg_value =
+				    IGA1_VER_SYNC_END_FORMULA
+				    (device_timing.ver_sync_start,
+				     device_timing.ver_sync_end);
+				load_reg_num =
+				    iga1_crtc_reg.ver_sync_end.reg_num;
+				reg = iga1_crtc_reg.ver_sync_end.reg;
+				break;
+
+			}
+		}
+
+		if (set_iga == IGA2) {
+			switch (i) {
+			case H_TOTAL_INDEX:
+				reg_value =
+				    IGA2_HOR_TOTAL_FORMULA(device_timing.
+							   hor_total);
+				load_reg_num = iga2_crtc_reg.hor_total.reg_num;
+				reg = iga2_crtc_reg.hor_total.reg;
+				break;
+			case H_ADDR_INDEX:
+				reg_value =
+				    IGA2_HOR_ADDR_FORMULA(device_timing.
+							  hor_addr);
+				load_reg_num = iga2_crtc_reg.hor_addr.reg_num;
+				reg = iga2_crtc_reg.hor_addr.reg;
+				break;
+			case H_BLANK_START_INDEX:
+				reg_value =
+				    IGA2_HOR_BLANK_START_FORMULA
+				    (device_timing.hor_blank_start);
+				load_reg_num =
+				    iga2_crtc_reg.hor_blank_start.reg_num;
+				reg = iga2_crtc_reg.hor_blank_start.reg;
+				break;
+			case H_BLANK_END_INDEX:
+				reg_value =
+				    IGA2_HOR_BLANK_END_FORMULA
+				    (device_timing.hor_blank_start,
+				     device_timing.hor_blank_end);
+				load_reg_num =
+				    iga2_crtc_reg.hor_blank_end.reg_num;
+				reg = iga2_crtc_reg.hor_blank_end.reg;
+				break;
+			case H_SYNC_START_INDEX:
+				reg_value =
+				    IGA2_HOR_SYNC_START_FORMULA
+				    (device_timing.hor_sync_start);
+				if (UNICHROME_CN700 <= chip_info.gfx_chip_name)
+					load_reg_num =
+					    iga2_crtc_reg.hor_sync_start.
+					    reg_num;
+				else
+					load_reg_num = 3;
+				reg = iga2_crtc_reg.hor_sync_start.reg;
+				break;
+			case H_SYNC_END_INDEX:
+				reg_value =
+				    IGA2_HOR_SYNC_END_FORMULA
+				    (device_timing.hor_sync_start,
+				     device_timing.hor_sync_end);
+				load_reg_num =
+				    iga2_crtc_reg.hor_sync_end.reg_num;
+				reg = iga2_crtc_reg.hor_sync_end.reg;
+				break;
+			case V_TOTAL_INDEX:
+				reg_value =
+				    IGA2_VER_TOTAL_FORMULA(device_timing.
+							   ver_total);
+				load_reg_num = iga2_crtc_reg.ver_total.reg_num;
+				reg = iga2_crtc_reg.ver_total.reg;
+				break;
+			case V_ADDR_INDEX:
+				reg_value =
+				    IGA2_VER_ADDR_FORMULA(device_timing.
+							  ver_addr);
+				load_reg_num = iga2_crtc_reg.ver_addr.reg_num;
+				reg = iga2_crtc_reg.ver_addr.reg;
+				break;
+			case V_BLANK_START_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_START_FORMULA
+				    (device_timing.ver_blank_start);
+				load_reg_num =
+				    iga2_crtc_reg.ver_blank_start.reg_num;
+				reg = iga2_crtc_reg.ver_blank_start.reg;
+				break;
+			case V_BLANK_END_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_END_FORMULA
+				    (device_timing.ver_blank_start,
+				     device_timing.ver_blank_end);
+				load_reg_num =
+				    iga2_crtc_reg.ver_blank_end.reg_num;
+				reg = iga2_crtc_reg.ver_blank_end.reg;
+				break;
+			case V_SYNC_START_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_START_FORMULA
+				    (device_timing.ver_sync_start);
+				load_reg_num =
+				    iga2_crtc_reg.ver_sync_start.reg_num;
+				reg = iga2_crtc_reg.ver_sync_start.reg;
+				break;
+			case V_SYNC_END_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_END_FORMULA
+				    (device_timing.ver_sync_start,
+				     device_timing.ver_sync_end);
+				load_reg_num =
+				    iga2_crtc_reg.ver_sync_end.reg_num;
+				reg = iga2_crtc_reg.ver_sync_end.reg;
+				break;
+
+			}
+		}
+		load_reg(reg_value, load_reg_num, reg, VIACR);
+	}
+
+	lock_crt();
+}
+
+void set_color_depth(int bpp_byte, int set_iga)
+{
+	if (set_iga == IGA1) {
+		switch (bpp_byte) {
+		case MODE_8BPP:
+			write_reg_mask(SR15, VIASR, 0x22, 0x7E);
+			break;
+		case MODE_16BPP:
+			write_reg_mask(SR15, VIASR, 0xB6, 0xFE);
+			break;
+		case MODE_32BPP:
+			write_reg_mask(SR15, VIASR, 0xAE, 0xFE);
+			break;
+		}
+	} else {
+		switch (bpp_byte) {
+		case MODE_8BPP:
+			write_reg_mask(CR67, VIACR, 0x00, BIT6 + BIT7);
+			break;
+		case MODE_16BPP:
+			write_reg_mask(CR67, VIACR, 0x40, BIT6 + BIT7);
+			break;
+		case MODE_32BPP:
+			write_reg_mask(CR67, VIACR, 0xC0, BIT6 + BIT7);
+			break;
+		}
+	}
+}
+
+void fill_crtc_timing(struct crt_mode_table *crt_table, int mode_index,
+		      int bpp_byte, int set_iga)
+{
+	struct VideoModeTable *video_mode;
+	struct display_timing crt_reg;
+	int i;
+	int index = 0;
+	int h_addr, v_addr;
+	u32 pll_D_N;
+
+	video_mode = &CLE266Modes[search_mode_setting(mode_index)];
+
+	for (i = 0; i < video_mode->mode_array; i++) {
+		index = i;
+
+		if (crt_table[i].refresh_rate == crt_setting_info.refresh_rate)
+			break;
+	}
+
+	crt_reg = crt_table[index].crtc;
+
+	/* Mode 640x480 has border, but LCD/DFP didn't have border. */
+	/* So we would delete border. */
+	if ((LCD_ON | DVI_ON) && (mode_index == VIA_RES_640X480)
+	    && (crt_setting_info.refresh_rate == 60)) {
+		/* The border is 8 pixels. */
+		crt_reg.hor_blank_start = crt_reg.hor_blank_start - 8;
+
+		/* Blanking time should add left and right borders. */
+		crt_reg.hor_blank_end = crt_reg.hor_blank_end + 16;
+	}
+
+	h_addr = crt_reg.hor_addr;
+	v_addr = crt_reg.ver_addr;
+
+	/* update polarity for CRT timing */
+	if (crt_table[index].h_sync_polarity == NEGATIVE) {
+		if (crt_table[index].v_sync_polarity == NEGATIVE)
+			outb((inb(VIARMisc) & (~(BIT6 + BIT7))) |
+			     (BIT6 + BIT7), VIAWMisc);
+		else
+			outb((inb(VIARMisc) & (~(BIT6 + BIT7))) | (BIT6),
+			     VIAWMisc);
+	} else {
+		if (crt_table[index].v_sync_polarity == NEGATIVE)
+			outb((inb(VIARMisc) & (~(BIT6 + BIT7))) | (BIT7),
+			     VIAWMisc);
+		else
+			outb((inb(VIARMisc) & (~(BIT6 + BIT7))), VIAWMisc);
+	}
+
+	if (set_iga == IGA1) {
+		unlock_crt();
+		write_reg(CR09, VIACR, 0x00);	/*initial CR09=0 */
+		write_reg_mask(CR11, VIACR, 0x00, BIT4 + BIT5 + BIT6);
+		write_reg_mask(CR17, VIACR, 0x00, BIT7);
+	}
+
+	switch (set_iga) {
+	case IGA1:
+		load_crtc_timing(crt_reg, IGA1);
+		break;
+	case IGA2:
+		load_crtc_timing(crt_reg, IGA2);
+		break;
+	}
+
+	load_fix_bit_crtc_reg();
+	lock_crt();
+	write_reg_mask(CR17, VIACR, 0x80, BIT7);
+	load_offset_reg(h_addr, bpp_byte, set_iga);
+	load_fetch_count_reg(h_addr, bpp_byte, set_iga);
+
+	/* load FIFO */
+	if ((chip_info.gfx_chip_name != UNICHROME_CLE266)
+	    && (chip_info.gfx_chip_name != UNICHROME_K400))
+		load_FIFO_reg(set_iga, h_addr, v_addr);
+
+	/* load SR Register About Memory and Color part */
+	set_color_depth(bpp_byte, set_iga);
+
+	pll_D_N = get_clk_value(crt_table[index].clk);
+	DEBUG_MSG(KERN_INFO "PLL=%x", pll_D_N);
+	set_vclock(pll_D_N, set_iga);
+
+}
+
+struct display_timing get_timing_value(struct crt_mode_table *crt_table,
+				       int mode_index)
+{
+	struct VideoModeTable *video_mode;
+	struct display_timing crt_reg;
+	int i;
+	int index = 0;
+
+	video_mode = &CLE266Modes[search_mode_setting(mode_index)];
+
+	for (i = 0; i < video_mode->mode_array; i++) {
+		index = i;
+
+		if (crt_table[i].refresh_rate == crt_setting_info.refresh_rate)
+			break;
+	}
+
+	crt_reg = crt_table[index].crtc;
+	return (crt_reg);
+}
+
+void init_chip_info(void)
+{
+	init_gfx_chip_info();
+	init_tmds_chip_info();
+	init_lvds_chip_info();
+
+	crt_setting_info.iga_path = IGA1;
+	crt_setting_info.refresh_rate = refresh;
+
+	/*Set IGA path for each device */
+	set_iga_path();
+
+	lvds_setting_info.display_method = lcd_dsp_method;
+	lvds_setting_info.get_lcd_size_method = GET_LCD_SIZE_BY_USER_SETTING;
+	lvds_setting_info.lcd_mode = lcd_mode;
+	lvds_setting_info2.display_method = lvds_setting_info.display_method;
+	lvds_setting_info2.lcd_mode = lvds_setting_info.lcd_mode;
+}
+
+void update_device_setting(int hres, int vres, int bpp, int vmode_refresh,
+			   int flag)
+{
+	if (flag == 0) {
+		crt_setting_info.h_active = hres;
+		crt_setting_info.v_active = vres;
+		crt_setting_info.bpp = bpp;
+		crt_setting_info.refresh_rate = vmode_refresh;
+
+		tmds_setting_info.h_active = hres;
+		tmds_setting_info.v_active = vres;
+		tmds_setting_info.bpp = bpp;
+		tmds_setting_info.refresh_rate = vmode_refresh;
+
+		lvds_setting_info.h_active = hres;
+		lvds_setting_info.v_active = vres;
+		lvds_setting_info.bpp = bpp;
+		lvds_setting_info.refresh_rate = vmode_refresh;
+		lvds_setting_info2.h_active = hres;
+		lvds_setting_info2.v_active = vres;
+		lvds_setting_info2.bpp = bpp;
+		lvds_setting_info2.refresh_rate = vmode_refresh;
+	} else {
+
+		if (tmds_setting_info.iga_path == IGA2) {
+			tmds_setting_info.h_active = hres;
+			tmds_setting_info.v_active = vres;
+			tmds_setting_info.bpp = bpp;
+			tmds_setting_info.refresh_rate = vmode_refresh;
+		}
+
+		if (lvds_setting_info.iga_path == IGA2) {
+			lvds_setting_info.h_active = hres;
+			lvds_setting_info.v_active = vres;
+			lvds_setting_info.bpp = bpp;
+			lvds_setting_info.refresh_rate = vmode_refresh;
+		}
+		if (IGA2 == lvds_setting_info2.iga_path) {
+			lvds_setting_info2.h_active = hres;
+			lvds_setting_info2.v_active = vres;
+			lvds_setting_info2.bpp = bpp;
+			lvds_setting_info2.refresh_rate = vmode_refresh;
+		}
+	}
+}
+
+void init_gfx_chip_info(void)
+{
+	struct pci_dev *pdev = NULL;
+	u8 tmp;
+
+	/* Indentify GFX Chip Name */
+	pdev =
+	    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+					     UNICHROME_CLE266_DID, NULL);
+	if (pdev != NULL)
+		chip_info.gfx_chip_name = UNICHROME_CLE266;
+
+	pdev =
+	    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+					     UNICHROME_K400_DID, NULL);
+	if (pdev != NULL)
+		chip_info.gfx_chip_name = UNICHROME_K400;
+
+	pdev =
+	    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+					     UNICHROME_K800_DID, NULL);
+	if (pdev != NULL)
+		chip_info.gfx_chip_name = UNICHROME_K800;
+
+	pdev =
+	    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+					     UNICHROME_PM800_DID, NULL);
+	if (pdev != NULL)
+		chip_info.gfx_chip_name = UNICHROME_PM800;
+
+	pdev =
+	    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+					     UNICHROME_CN700_DID, NULL);
+	if (pdev != NULL)
+		chip_info.gfx_chip_name = UNICHROME_CN700;
+
+	pdev =
+	    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+					     UNICHROME_CX700_DID, NULL);
+	if (pdev != NULL)
+		chip_info.gfx_chip_name = UNICHROME_CX700;
+	pdev =
+	    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+					     UNICHROME_K8M890_DID, NULL);
+	if (pdev != NULL)
+		chip_info.gfx_chip_name = UNICHROME_K8M890;
+
+	pdev =
+	    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+					     UNICHROME_P4M890_DID, NULL);
+	if (pdev != NULL)
+		chip_info.gfx_chip_name = UNICHROME_P4M890;
+
+	pdev =
+	    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+					     UNICHROME_P4M900_DID, NULL);
+	if (pdev != NULL)
+		chip_info.gfx_chip_name = UNICHROME_P4M900;
+
+	pdev =
+	    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+					     UNICHROME_VX800_DID, NULL);
+	if (pdev != NULL)
+		chip_info.gfx_chip_name = UNICHROME_VX800;
+	/* Check revision of CLE266 Chip */
+	if (chip_info.gfx_chip_name == UNICHROME_CLE266) {
+		/* CR4F only define in CLE266.CX chip */
+		tmp = read_reg(VIACR, CR4F);
+		write_reg(CR4F, VIACR, 0x55);
+		if (read_reg(VIACR, CR4F) != 0x55)
+			chip_info.gfx_chip_revision = CLE266_REVISION_AX;
+		else
+			chip_info.gfx_chip_revision = CLE266_REVISION_CX;
+
+		write_reg(CR4F, VIACR, tmp);	/* restore orignal CR4F value */
+	}
+
+	if (UNICHROME_CX700 == chip_info.gfx_chip_name) {
+		tmp = read_reg(VIASR, SR43);
+		DEBUG_MSG(KERN_INFO "SR43:%X\n", tmp);
+		if (tmp & 0x02) {
+			chip_info.gfx_chip_revision = CX700_REVISION_700M2;
+		} else if (tmp & 0x40) {
+			chip_info.gfx_chip_revision = CX700_REVISION_700M;
+		} else {
+			chip_info.gfx_chip_revision = CX700_REVISION_700;
+		}
+	}
+}
+
+void init_tmds_chip_info(void)
+{
+	tmds_trasmitter_identify();
+
+	if (INTERFACE_NONE == chip_info.tmds_chip_info.output_interface) {
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_CX700:
+			{
+				/* we should check support by hardware layout.*/
+				if ((display_hardware_layout ==
+				     HW_LAYOUT_DVI_ONLY)
+				    || (display_hardware_layout ==
+					HW_LAYOUT_LCD_DVI)) {
+					chip_info.tmds_chip_info.
+					    output_interface = INTERFACE_TMDS;
+				} else {
+					chip_info.tmds_chip_info.
+					    output_interface = INTERFACE_NONE;
+				}
+				break;
+			}
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M900:
+		case UNICHROME_P4M890:
+			/* TMDS on PCIE, we set DFPLOW as default. */
+			chip_info.tmds_chip_info.output_interface =
+			    INTERFACE_DFP_LOW;
+			break;
+		default:
+			{
+				/* set DVP1 default for DVI */
+				chip_info.tmds_chip_info.output_interface =
+				    INTERFACE_DVP1;
+			}
+		}
+	}
+
+	DEBUG_MSG(KERN_INFO "TMDS Chip = %d\n",
+		  chip_info.tmds_chip_info.tmds_chip_name);
+	tmds_setting_info.get_dvi_size_method = GET_DVI_SIZE_BY_VGA_BIOS;
+	init_dvi_size();
+}
+
+void init_lvds_chip_info(void)
+{
+	if (lcd_panel_id > LCD_PANEL_ID_MAXIMUM)
+		lvds_setting_info.get_lcd_size_method =
+		    GET_LCD_SIZE_BY_VGA_BIOS;
+	else
+		lvds_setting_info.get_lcd_size_method =
+		    GET_LCD_SIZE_BY_USER_SETTING;
+
+	lvds_trasmitter_identify();
+	init_lcd_size();
+	init_lvds_output_interface(&chip_info.lvds_chip_info,
+				   &lvds_setting_info);
+	if (chip_info.lvds_chip_info2.lvds_chip_name) {
+		init_lvds_output_interface(&chip_info.lvds_chip_info2,
+					   &lvds_setting_info2);
+	}
+	/*If CX700,two singel LCD, we need to reassign
+	   LCD interface to different LVDS port */
+	if ((UNICHROME_CX700 == chip_info.gfx_chip_name)
+	    && (HW_LAYOUT_LCD1_LCD2 == display_hardware_layout)) {
+		if ((INTEGRATED_LVDS == chip_info.lvds_chip_info.lvds_chip_name)
+		    && (INTEGRATED_LVDS ==
+			chip_info.lvds_chip_info2.lvds_chip_name)) {
+			chip_info.lvds_chip_info.output_interface =
+			    INTERFACE_LVDS0;
+			chip_info.lvds_chip_info2.output_interface =
+			    INTERFACE_LVDS1;
+		}
+	}
+
+	DEBUG_MSG(KERN_INFO "LVDS Chip = %d\n",
+		  chip_info.lvds_chip_info.lvds_chip_name);
+	DEBUG_MSG(KERN_INFO "LVDS1 output_interface = %d\n",
+		  chip_info.lvds_chip_info.output_interface);
+	DEBUG_MSG(KERN_INFO "LVDS2 output_interface = %d\n",
+		  chip_info.lvds_chip_info2.output_interface);
+}
+
+void init_dac(int set_iga)
+{
+	int i;
+	u8 tmp;
+
+	if (set_iga == IGA1) {
+		/* access Primary Display's LUT */
+		write_reg_mask(SR1A, VIASR, 0x00, BIT0);
+		/* turn off LCK */
+		write_reg_mask(SR1B, VIASR, 0x00, BIT7 + BIT6);
+		for (i = 0; i < 256; i++) {
+			write_dac_reg(i, palLUT_table[i].red,
+				      palLUT_table[i].green,
+				      palLUT_table[i].blue);
+		}
+		/* turn on LCK */
+		write_reg_mask(SR1B, VIASR, 0xC0, BIT7 + BIT6);
+	} else {
+		tmp = read_reg(VIACR, CR6A);
+		/* access Secondary Display's LUT */
+		write_reg_mask(CR6A, VIACR, 0x40, BIT6);
+		write_reg_mask(SR1A, VIASR, 0x01, BIT0);
+		for (i = 0; i < 256; i++) {
+			write_dac_reg(i, palLUT_table[i].red,
+				      palLUT_table[i].green,
+				      palLUT_table[i].blue);
+		}
+		/* set IGA1 DAC for default */
+		write_reg_mask(SR1A, VIASR, 0x00, BIT0);
+		write_reg(CR6A, VIACR, tmp);
+	}
+}
+
+void device_screen_off(void)
+{
+	/* turn off CRT screen (IGA1) */
+	write_reg_mask(SR01, VIASR, 0x20, BIT5);
+}
+
+void device_screen_on(void)
+{
+	/* turn on CRT screen (IGA1) */
+	write_reg_mask(SR01, VIASR, 0x00, BIT5);
+}
+
+void set_display_channel(void)
+{
+	/*If LCD2_ON, on cx700, internal lvds's information
+	is keeped on lvds_setting_info2 */
+	if (LCD2_ON && lvds_setting_info2.device_lcd_dualedge) {
+		/* For dual channel LCD: */
+		/* Set to Dual LVDS channel. */
+		write_reg_mask(CRD2, VIACR, 0x20, BIT4 + BIT5);
+	} else if (LCD_ON && DVI_ON) {
+		/* For LCD+DFP: */
+		/* Set to LVDS1 + TMDS channel. */
+		write_reg_mask(CRD2, VIACR, 0x10, BIT4 + BIT5);
+	} else if (DVI_ON) {
+		/* Set to single TMDS channel. */
+		write_reg_mask(CRD2, VIACR, 0x30, BIT4 + BIT5);
+	} else if (LCD_ON) {
+		if (lvds_setting_info.device_lcd_dualedge) {
+			/* For dual channel LCD: */
+			/* Set to Dual LVDS channel. */
+			write_reg_mask(CRD2, VIACR, 0x20, BIT4 + BIT5);
+		} else {
+			/* Set to LVDS0 + LVDS1 channel. */
+			write_reg_mask(CRD2, VIACR, 0x00, BIT4 + BIT5);
+		}
+	}
+}
+
+int setmode(int vmode_index, int hor_res, int ver_res, int video_bpp,
+	    int vmode_index1, int hor_res1, int ver_res1, int video_bpp1)
+{
+	int i, j;
+	int port;
+	u8 value, index, mask;
+	struct VideoModeTable *vmode_tbl;
+	struct crt_mode_table *crt_timing;
+	struct VideoModeTable *vmode_tbl1 = NULL;
+	struct crt_mode_table *crt_timing1 = NULL;
+
+	DEBUG_MSG(KERN_INFO "Set Mode!!\n");
+	DEBUG_MSG(KERN_INFO
+		  "vmode_index=%d hor_res=%d ver_res=%d video_bpp=%d\n",
+		  vmode_index, hor_res, ver_res, video_bpp);
+
+	device_screen_off();
+	vmode_tbl = &CLE266Modes[search_mode_setting(vmode_index)];
+	crt_timing = vmode_tbl->crtc;
+
+	if (SAMM_ON == 1) {
+		vmode_tbl1 = &CLE266Modes[search_mode_setting(vmode_index1)];
+		crt_timing1 = vmode_tbl1->crtc;
+	}
+
+	inb(VIAStatus);
+	outb(0x00, VIAAR);
+
+	/* Write Common Setting for Video Mode */
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_CLE266:
+		write_regx(CLE266_ModeXregs, NUM_TOTAL_CLE266_ModeXregs);
+		break;
+
+	case UNICHROME_K400:
+		write_regx(KM400_ModeXregs, NUM_TOTAL_KM400_ModeXregs);
+		break;
+
+	case UNICHROME_K800:
+	case UNICHROME_PM800:
+		write_regx(CN400_ModeXregs, NUM_TOTAL_CN400_ModeXregs);
+		break;
+
+	case UNICHROME_CN700:
+	case UNICHROME_K8M890:
+	case UNICHROME_P4M890:
+	case UNICHROME_P4M900:
+		write_regx(CN700_ModeXregs, NUM_TOTAL_CN700_ModeXregs);
+		break;
+
+	case UNICHROME_CX700:
+		write_regx(CX700_ModeXregs, NUM_TOTAL_CX700_ModeXregs);
+
+	case UNICHROME_VX800:
+		write_regx(VX800_ModeXregs, NUM_TOTAL_VX800_ModeXregs);
+
+		break;
+	}
+
+	device_off();
+
+	/* Fill VPIT Parameters */
+	/* Write Misc Register */
+	outb(VPIT.Misc, VIAWMisc);
+
+	/* Write Sequencer */
+	for (i = 1; i <= StdSR; i++) {
+		outb(i, VIASR);
+		outb(VPIT.SR[i - 1], VIASR + 1);
+	}
+
+	set_start_addr();
+	set_iga_path();
+
+	/* Write CRTC */
+	fill_crtc_timing(crt_timing, vmode_index, video_bpp / 8, IGA1);
+
+	/* Write Graphic Controller */
+	for (i = 0; i < StdGR; i++) {
+		outb(i, VIAGR);
+		outb(VPIT.GR[i], VIAGR + 1);
+	}
+
+	/* Write Attribute Controller */
+	for (i = 0; i < StdAR; i++) {
+		inb(VIAStatus);
+		outb(i, VIAAR);
+		outb(VPIT.AR[i], VIAAR);
+	}
+
+	inb(VIAStatus);
+	outb(0x20, VIAAR);
+
+	/* Update Patch Register */
+
+	if ((chip_info.gfx_chip_name == UNICHROME_CLE266)
+	    || (chip_info.gfx_chip_name == UNICHROME_K400)) {
+		for (i = 0; i < NUM_TOTAL_PATCH_MODE; i++) {
+			if (res_patch_table[i].mode_index == vmode_index) {
+				for (j = 0;
+				     j < res_patch_table[i].table_length; j++) {
+					index =
+					    res_patch_table[i].
+					    io_reg_table[j].index;
+					port =
+					    res_patch_table[i].
+					    io_reg_table[j].port;
+					value =
+					    res_patch_table[i].
+					    io_reg_table[j].value;
+					mask =
+					    res_patch_table[i].
+					    io_reg_table[j].mask;
+					write_reg_mask(index, port, value,
+						       mask);
+				}
+			}
+		}
+	}
+
+	if (SAMM_ON == 1) {
+		if ((chip_info.gfx_chip_name == UNICHROME_CLE266)
+		    || (chip_info.gfx_chip_name == UNICHROME_K400)) {
+			for (i = 0; i < NUM_TOTAL_PATCH_MODE; i++) {
+				if (res_patch_table[i].mode_index ==
+				    vmode_index1) {
+					for (j = 0;
+					     j <
+					     res_patch_table[i].
+					     table_length; j++) {
+						index =
+						    res_patch_table[i].
+						    io_reg_table[j].index;
+						port =
+						    res_patch_table[i].
+						    io_reg_table[j].port;
+						value =
+						    res_patch_table[i].
+						    io_reg_table[j].value;
+						mask =
+						    res_patch_table[i].
+						    io_reg_table[j].mask;
+						write_reg_mask(index, port,
+							       value, mask);
+					}
+				}
+			}
+		}
+	}
+
+	/* Update Refresh Rate Setting */
+
+	/* Clear On Screen */
+
+	/* CRT set mode */
+	if (CRT_ON) {
+		if (SAMM_ON && (crt_setting_info.iga_path == IGA2)) {
+			fill_crtc_timing(crt_timing1, vmode_index1,
+					 video_bpp1 / 8,
+					 crt_setting_info.iga_path);
+		} else {
+			fill_crtc_timing(crt_timing, vmode_index,
+					 video_bpp / 8,
+					 crt_setting_info.iga_path);
+		}
+
+		set_crt_output_path(crt_setting_info.iga_path);
+
+		/* Patch if set_hres is not 8 alignment (1366) to setmode
+		to 8 alignment (1368),there is several pixels (2 pixels)
+		on right side of screen. */
+		if (hor_res % 8) {
+			unlock_crt();
+			write_reg(CR02, VIACR, read_reg(VIACR, CR02) - 1);
+			lock_crt();
+		}
+	}
+
+	if (DVI_ON) {
+		if (SAMM_ON && (tmds_setting_info.iga_path == IGA2)) {
+			dvi_set_mode(get_mode_index
+				     (tmds_setting_info.h_active,
+				      tmds_setting_info.v_active, 1),
+				     video_bpp1, tmds_setting_info.iga_path);
+		} else {
+			dvi_set_mode(get_mode_index
+				     (tmds_setting_info.h_active,
+				      tmds_setting_info.v_active, 0),
+				     video_bpp, tmds_setting_info.iga_path);
+		}
+	}
+
+	if (LCD_ON) {
+		if (SAMM_ON && (lvds_setting_info.iga_path == IGA2)) {
+			lvds_setting_info.bpp = video_bpp1;
+			lcd_set_mode(crt_timing1, &lvds_setting_info,
+				     &chip_info.lvds_chip_info);
+		} else {
+			/* IGA1 doesn't have LCD scaling, so set it center. */
+			if (lvds_setting_info.iga_path == IGA1) {
+				lvds_setting_info.display_method =
+				    LCD_CENTERING;
+			}
+			lvds_setting_info.bpp = video_bpp;
+			lcd_set_mode(crt_timing, &lvds_setting_info,
+				     &chip_info.lvds_chip_info);
+		}
+	}
+	if (LCD2_ON) {
+		if (SAMM_ON && (lvds_setting_info2.iga_path == IGA2)) {
+			lvds_setting_info2.bpp = video_bpp1;
+			lcd_set_mode(crt_timing1, &lvds_setting_info2,
+				     &chip_info.lvds_chip_info2);
+		} else {
+			/* IGA1 doesn't have LCD scaling, so set it center. */
+			if (lvds_setting_info2.iga_path == IGA1) {
+				lvds_setting_info2.display_method =
+				    LCD_CENTERING;
+			}
+			lvds_setting_info2.bpp = video_bpp;
+			lcd_set_mode(crt_timing, &lvds_setting_info2,
+				     &chip_info.lvds_chip_info2);
+		}
+	}
+
+	if ((chip_info.gfx_chip_name == UNICHROME_CX700)
+	    && (LCD_ON || DVI_ON))
+		set_display_channel();
+
+	/* If set mode normally, save resolution information for hot-plug . */
+	if (!via_fb_hotplug) {
+		via_fb_hotplug_Xres = hor_res;
+		via_fb_hotplug_Yres = ver_res;
+		via_fb_hotplug_bpp = video_bpp;
+		via_fb_hotplug_refresh = refresh;
+
+		if (DVI_ON) {
+			DeviceStatus = DVI_Device;
+		} else {
+			DeviceStatus = CRT_Device;
+		}
+	}
+
+	device_on();
+
+	if (SAMM_ON == 1)
+		write_reg_mask(CR6A, VIACR, 0xC0, BIT6 + BIT7);
+
+	device_screen_on();
+
+	return 1;
+}
+
+int get_pixclock(int hres, int vres, int vmode_refresh)
+{
+	int i;
+
+	for (i = 0; i < NUM_TOTAL_RES_MAP_REFRESH; i++) {
+		if ((hres == res_map_refresh_tbl[i].hres)
+		    && (vres == res_map_refresh_tbl[i].vres)
+		    && (vmode_refresh == res_map_refresh_tbl[i].vmode_refresh))
+			return (res_map_refresh_tbl[i].pixclock);
+	}
+	return (RES_640X480_60HZ_PIXCLOCK);
+
+}
+
+int get_refresh(int hres, int vres, int pixclock)
+{
+	int i;
+	for (i = 0; i < NUM_TOTAL_RES_MAP_REFRESH; i++) {
+		if ((hres == res_map_refresh_tbl[i].hres)
+		    && (vres == res_map_refresh_tbl[i].vres)
+		    && (pixclock == res_map_refresh_tbl[i].pixclock))
+			return (res_map_refresh_tbl[i].vmode_refresh);
+	}
+	return (60);
+}
+
+void device_off(void)
+{
+	crt_disable();
+	dvi_disable();
+	lcd_disable();
+}
+
+void device_on(void)
+{
+	if (CRT_ON == 1)
+		crt_enable();
+	if (DVI_ON == 1)
+		dvi_enable();
+	if (LCD_ON == 1)
+		lcd_enable();
+}
+
+void crt_disable(void)
+{
+	write_reg_mask(CR36, VIACR, BIT5 + BIT4, BIT5 + BIT4);
+}
+
+void crt_enable(void)
+{
+	write_reg_mask(CR36, VIACR, 0x0, BIT5 + BIT4);
+}
+
+void get_mmio_info(unsigned long *mmio_base, unsigned long *mmio_len)
+{
+	struct pci_dev *pdev = NULL;
+
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_CLE266:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_CLE266_DID,
+						     NULL);
+		break;
+
+	case UNICHROME_K400:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_K400_DID, NULL);
+		break;
+
+	case UNICHROME_K800:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_K800_DID, NULL);
+		break;
+
+	case UNICHROME_PM800:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_PM800_DID, NULL);
+		break;
+
+	case UNICHROME_CN700:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_CN700_DID, NULL);
+		break;
+
+	case UNICHROME_CX700:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_CX700_DID, NULL);
+		break;
+
+	case UNICHROME_K8M890:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_K8M890_DID,
+						     NULL);
+		break;
+
+	case UNICHROME_P4M890:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_P4M890_DID,
+						     NULL);
+		break;
+
+	case UNICHROME_P4M900:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_P4M900_DID,
+						     NULL);
+		break;
+
+	case UNICHROME_VX800:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_VX800_DID, NULL);
+		break;
+	}
+
+	if (pdev != NULL) {
+		*mmio_base = pci_resource_start(pdev, 1);
+		*mmio_len = pci_resource_len(pdev, 1);
+	} else {
+		*mmio_base = 0;
+		*mmio_len = 0;
+	}
+
+}
+
+void enable_second_display_channel(void)
+{
+	/* to enable second display channel. */
+	write_reg_mask(CR6A, VIACR, 0x00, BIT6);
+	write_reg_mask(CR6A, VIACR, BIT7, BIT7);
+	write_reg_mask(CR6A, VIACR, BIT6, BIT6);
+}
+
+void disable_second_display_channel(void)
+{
+	/* to disable second display channel. */
+	write_reg_mask(CR6A, VIACR, 0x00, BIT6);
+	write_reg_mask(CR6A, VIACR, 0x00, BIT7);
+	write_reg_mask(CR6A, VIACR, BIT6, BIT6);
+}
+
+void plus_vck_to_iga1_timing(unsigned long h_total)
+{
+	/* Clear first. */
+	write_reg_mask(CR47, VIACR, 0x00, BIT7 + BIT6 + BIT3);
+
+	switch (h_total % 8) {
+	case 2:
+		{
+			write_reg_mask(CR47, VIACR, BIT7, BIT7);
+			break;
+		}
+
+	case 4:
+		{
+			write_reg_mask(CR47, VIACR, BIT6, BIT6);
+			break;
+		}
+
+	case 6:
+		{
+			write_reg_mask(CR47, VIACR, BIT3, BIT3);
+			break;
+		}
+
+	default:
+		{
+			break;
+		}
+	}
+}
+
+void get_fb_info(unsigned int *fb_base, unsigned int *fb_len)
+{
+	struct pci_dev *pdev = NULL;
+
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_CLE266:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_CLE266_DID,
+						     NULL);
+		break;
+
+	case UNICHROME_K400:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_K400_DID, NULL);
+		break;
+
+	case UNICHROME_K800:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_K800_DID, NULL);
+		break;
+
+	case UNICHROME_PM800:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_PM800_DID, NULL);
+		break;
+
+	case UNICHROME_CN700:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_CN700_DID, NULL);
+		break;
+
+	case UNICHROME_CX700:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_CX700_DID, NULL);
+		break;
+
+	case UNICHROME_K8M890:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_K8M890_DID,
+						     NULL);
+		break;
+
+	case UNICHROME_P4M890:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_P4M890_DID,
+						     NULL);
+		break;
+
+	case UNICHROME_P4M900:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_P4M900_DID,
+						     NULL);
+		break;
+
+	case UNICHROME_VX800:
+		pdev =
+		    (struct pci_dev *)pci_get_device(PCI_VIA_VENDOR_ID,
+						     UNICHROME_VX800_DID, NULL);
+		break;
+
+	default:
+		DEBUG_MSG(KERN_INFO "Can not detect chipset\n");
+		break;
+	}
+
+	if (pdev != NULL) {
+		*fb_base = (unsigned int)pci_resource_start(pdev, 0);
+		*fb_len = get_fb_size_from_pci();
+		DEBUG_MSG(KERN_INFO "Get FB info from PCI system!\n");
+		DEBUG_MSG(KERN_INFO "fb_base = %08x\n", *fb_base);
+		DEBUG_MSG(KERN_INFO "fb_len = %08x\n", *fb_len);
+	} else {
+		*fb_base = read_reg(VIASR, SR30) << 24;
+		*fb_len = get_memsize();
+		DEBUG_MSG(KERN_INFO "Get FB info from SR30!\n");
+		DEBUG_MSG(KERN_INFO "fb_base = %08x\n", *fb_base);
+		DEBUG_MSG(KERN_INFO "fb_len = %08x\n", *fb_len);
+	}
+}
+
+int get_fb_size_from_pci()
+{
+	unsigned long configid, deviceid, FBSize = 0;
+	int VideoMemSize;
+	int DeviceFound = FALSE;
+
+	for (configid = 0x80000000; configid < 0x80010800; configid += 0x100) {
+		outl(configid, (unsigned long)0xCF8);
+		deviceid = (inl((unsigned long)0xCFC) >> 16) & 0xffff;
+
+		switch (deviceid) {
+		case CLE266:
+		case KM400:
+			outl(configid + 0xE0, (unsigned long)0xCF8);
+			FBSize = inl((unsigned long)0xCFC);
+			DeviceFound = TRUE;	/* Found device id */
+			break;
+
+		case CN400_FUNCTION3:
+		case CN700_FUNCTION3:
+		case CX700_FUNCTION3:
+		case KM800_FUNCTION3:
+		case KM890_FUNCTION3:
+		case P4M890_FUNCTION3:
+		case P4M900_FUNCTION3:
+		case VX800_FUNCTION3:
+			/*case CN750_FUNCTION3: */
+			outl(configid + 0xA0, (unsigned long)0xCF8);
+			FBSize = inl((unsigned long)0xCFC);
+			DeviceFound = TRUE;	/* Found device id */
+			break;
+
+		default:
+			break;
+		}
+
+		if (DeviceFound)
+			break;
+	}
+
+	DEBUG_MSG(KERN_INFO "Device ID = %lx\n", deviceid);
+
+	FBSize = FBSize & 0x00007000;
+	DEBUG_MSG(KERN_INFO "FB Size = %lx\n", FBSize);
+
+	if (chip_info.gfx_chip_name < UNICHROME_CX700) {
+		switch (FBSize) {
+		case 0x00004000:
+			VideoMemSize = (16 << 20);	/*16M */
+			break;
+
+		case 0x00005000:
+			VideoMemSize = (32 << 20);	/*32M */
+			break;
+
+		case 0x00006000:
+			VideoMemSize = (64 << 20);	/*64M */
+			break;
+
+		default:
+			VideoMemSize = (32 << 20);	/*32M */
+			break;
+		}
+	} else {
+		switch (FBSize) {
+		case 0x00001000:
+			VideoMemSize = (8 << 20);	/*8M */
+			break;
+
+		case 0x00002000:
+			VideoMemSize = (16 << 20);	/*16M */
+			break;
+
+		case 0x00003000:
+			VideoMemSize = (32 << 20);	/*32M */
+			break;
+
+		case 0x00004000:
+			VideoMemSize = (64 << 20);	/*64M */
+			break;
+
+		case 0x00005000:
+			VideoMemSize = (128 << 20);	/*128M */
+			break;
+
+		case 0x00006000:
+			VideoMemSize = (256 << 20);	/*256M */
+			break;
+
+		default:
+			VideoMemSize = (32 << 20);	/*32M */
+			break;
+		}
+	}
+
+	return VideoMemSize;
+}
+
+void set_dpa_gfx(int output_interface, struct GFX_DPA_SETTING\
+					*p_gfx_dpa_setting)
+{
+	switch (output_interface) {
+	case INTERFACE_DVP0:
+		{
+			/* DVP0 Clock Polarity and Adjust: */
+			write_reg_mask(CR96, VIACR,
+				       p_gfx_dpa_setting->DVP0, 0x0F);
+
+			/* DVP0 Clock and Data Pads Driving: */
+			write_reg_mask(SR1E, VIASR,
+				       p_gfx_dpa_setting->DVP0ClockDri_S, BIT2);
+			write_reg_mask(SR2A, VIASR,
+				       p_gfx_dpa_setting->DVP0ClockDri_S1,
+				       BIT4);
+			write_reg_mask(SR1B, VIASR,
+				       p_gfx_dpa_setting->DVP0DataDri_S, BIT1);
+			write_reg_mask(SR2A, VIASR,
+				       p_gfx_dpa_setting->DVP0DataDri_S1, BIT5);
+			break;
+		}
+
+	case INTERFACE_DVP1:
+		{
+			/* DVP1 Clock Polarity and Adjust: */
+			write_reg_mask(CR9B, VIACR,
+				       p_gfx_dpa_setting->DVP1, 0x0F);
+
+			/* DVP1 Clock and Data Pads Driving: */
+			write_reg_mask(SR65, VIASR,
+				       p_gfx_dpa_setting->DVP1Driving, 0x0F);
+			break;
+		}
+
+	case INTERFACE_DFP_HIGH:
+		{
+			write_reg_mask(CR97, VIACR,
+				       p_gfx_dpa_setting->DFPHigh, 0x0F);
+			break;
+		}
+
+	case INTERFACE_DFP_LOW:
+		{
+			write_reg_mask(CR99, VIACR,
+				       p_gfx_dpa_setting->DFPLow, 0x0F);
+			break;
+		}
+
+	case INTERFACE_DFP:
+		{
+			write_reg_mask(CR97, VIACR,
+				       p_gfx_dpa_setting->DFPHigh, 0x0F);
+			write_reg_mask(CR99, VIACR,
+				       p_gfx_dpa_setting->DFPLow, 0x0F);
+			break;
+		}
+	}
+}
+
+void memory_pitch_patch(struct fb_info *info)
+{
+	if (info->var.xres != info->var.xres_virtual) {
+		load_offset_reg(info->var.xres_virtual,
+				info->var.bits_per_pixel >> 3, IGA1);
+
+		if (SAMM_ON) {
+			load_offset_reg(second_virtual_xres, via_fb_bpp1 >> 3,
+					IGA2);
+		} else {
+			load_offset_reg(info->var.xres_virtual,
+					info->var.bits_per_pixel >> 3, IGA2);
+		}
+
+	}
+}
+
+/*According var's xres, yres fill var's other timing information*/
+void fill_var_timing_info(struct fb_var_screeninfo *var, int refresh,
+			  int mode_index)
+{
+	struct VideoModeTable *vmode_tbl = NULL;
+	struct crt_mode_table *crt_timing = NULL;
+	struct display_timing crt_reg;
+	int i = 0, index = 0;
+	vmode_tbl = &CLE266Modes[search_mode_setting(mode_index)];
+	crt_timing = vmode_tbl->crtc;
+	for (i = 0; i < vmode_tbl->mode_array; i++) {
+		index = i;
+
+		if (crt_timing[i].refresh_rate == refresh)
+			break;
+	}
+	crt_reg = crt_timing[index].crtc;
+	var->left_margin =
+	    crt_reg.hor_total - (crt_reg.hor_sync_start + crt_reg.hor_sync_end);
+	var->right_margin = crt_reg.hor_sync_start - crt_reg.hor_addr;
+	var->hsync_len = crt_reg.hor_sync_end;
+	var->upper_margin =
+	    crt_reg.ver_total - (crt_reg.ver_sync_start + crt_reg.ver_sync_end);
+	var->lower_margin = crt_reg.ver_sync_start - crt_reg.ver_addr;
+	var->vsync_len = crt_reg.ver_sync_end;
+	var->pixclock = get_pixclock(var->xres, var->yres, refresh);
+}
--- /dev/null
+++ b/drivers/video/viafb/hw.h
@@ -0,0 +1,950 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __HW_H__
+#define __HW_H__
+
+#include "global.h"
+
+/***************************************************
+* Definition IGA1 Design Method of CRTC Registers *
+****************************************************/
+#define IGA1_HOR_TOTAL_FORMULA(x)           ((x)/8)-5
+#define IGA1_HOR_ADDR_FORMULA(x)            ((x)/8)-1
+#define IGA1_HOR_BLANK_START_FORMULA(x)     ((x)/8)-1
+#define IGA1_HOR_BLANK_END_FORMULA(x, y)     ((x+y)/8)-1
+#define IGA1_HOR_SYNC_START_FORMULA(x)      ((x)/8)
+#define IGA1_HOR_SYNC_END_FORMULA(x, y)      ((x+y)/8)
+
+#define IGA1_VER_TOTAL_FORMULA(x)           (x)-2
+#define IGA1_VER_ADDR_FORMULA(x)            (x)-1
+#define IGA1_VER_BLANK_START_FORMULA(x)     (x)-1
+#define IGA1_VER_BLANK_END_FORMULA(x, y)     (x+y)-1
+#define IGA1_VER_SYNC_START_FORMULA(x)      (x)-1
+#define IGA1_VER_SYNC_END_FORMULA(x, y)      (x+y)-1
+
+/***************************************************
+** Definition IGA2 Design Method of CRTC Registers *
+****************************************************/
+#define IGA2_HOR_TOTAL_FORMULA(x)           (x)-1
+#define IGA2_HOR_ADDR_FORMULA(x)            (x)-1
+#define IGA2_HOR_BLANK_START_FORMULA(x)     (x)-1
+#define IGA2_HOR_BLANK_END_FORMULA(x, y)     (x+y)-1
+#define IGA2_HOR_SYNC_START_FORMULA(x)      (x)-1
+#define IGA2_HOR_SYNC_END_FORMULA(x, y)      (x+y)-1
+
+#define IGA2_VER_TOTAL_FORMULA(x)           (x)-1
+#define IGA2_VER_ADDR_FORMULA(x)            (x)-1
+#define IGA2_VER_BLANK_START_FORMULA(x)     (x)-1
+#define IGA2_VER_BLANK_END_FORMULA(x, y)     (x+y)-1
+#define IGA2_VER_SYNC_START_FORMULA(x)      (x)-1
+#define IGA2_VER_SYNC_END_FORMULA(x, y)      (x+y)-1
+
+/**********************************************************/
+/* Definition IGA2 Design Method of CRTC Shadow Registers */
+/**********************************************************/
+#define IGA2_HOR_TOTAL_SHADOW_FORMULA(x)           (x/8)-5
+#define IGA2_HOR_BLANK_END_SHADOW_FORMULA(x, y)     ((x+y)/8)-1
+#define IGA2_VER_TOTAL_SHADOW_FORMULA(x)           (x)-2
+#define IGA2_VER_ADDR_SHADOW_FORMULA(x)            (x)-1
+#define IGA2_VER_BLANK_START_SHADOW_FORMULA(x)     (x)-1
+#define IGA2_VER_BLANK_END_SHADOW_FORMULA(x, y)     (x+y)-1
+#define IGA2_VER_SYNC_START_SHADOW_FORMULA(x)      (x)
+#define IGA2_VER_SYNC_END_SHADOW_FORMULA(x, y)      (x+y)
+
+/* Define Register Number for IGA1 CRTC Timing */
+
+/* location: {CR00,0,7},{CR36,3,3} */
+#define IGA1_HOR_TOTAL_REG_NUM		2
+/* location: {CR01,0,7} */
+#define IGA1_HOR_ADDR_REG_NUM		1
+/* location: {CR02,0,7} */
+#define IGA1_HOR_BLANK_START_REG_NUM    1
+/* location: {CR03,0,4},{CR05,7,7},{CR33,5,5} */
+#define IGA1_HOR_BLANK_END_REG_NUM	3
+/* location: {CR04,0,7},{CR33,4,4} */
+#define IGA1_HOR_SYNC_START_REG_NUM	2
+/* location: {CR05,0,4} */
+#define IGA1_HOR_SYNC_END_REG_NUM       1
+/* location: {CR06,0,7},{CR07,0,0},{CR07,5,5},{CR35,0,0} */
+#define IGA1_VER_TOTAL_REG_NUM          4
+/* location: {CR12,0,7},{CR07,1,1},{CR07,6,6},{CR35,2,2} */
+#define IGA1_VER_ADDR_REG_NUM           4
+/* location: {CR15,0,7},{CR07,3,3},{CR09,5,5},{CR35,3,3} */
+#define IGA1_VER_BLANK_START_REG_NUM    4
+/* location: {CR16,0,7} */
+#define IGA1_VER_BLANK_END_REG_NUM      1
+/* location: {CR10,0,7},{CR07,2,2},{CR07,7,7},{CR35,1,1} */
+#define IGA1_VER_SYNC_START_REG_NUM     4
+/* location: {CR11,0,3} */
+#define IGA1_VER_SYNC_END_REG_NUM       1
+
+/* Define Register Number for IGA2 Shadow CRTC Timing */
+
+/* location: {CR6D,0,7},{CR71,3,3} */
+#define IGA2_SHADOW_HOR_TOTAL_REG_NUM       2
+/* location: {CR6E,0,7} */
+#define IGA2_SHADOW_HOR_BLANK_END_REG_NUM   1
+/* location: {CR6F,0,7},{CR71,0,2} */
+#define IGA2_SHADOW_VER_TOTAL_REG_NUM       2
+/* location: {CR70,0,7},{CR71,4,6} */
+#define IGA2_SHADOW_VER_ADDR_REG_NUM        2
+/* location: {CR72,0,7},{CR74,4,6} */
+#define IGA2_SHADOW_VER_BLANK_START_REG_NUM 2
+/* location: {CR73,0,7},{CR74,0,2} */
+#define IGA2_SHADOW_VER_BLANK_END_REG_NUM   2
+/* location: {CR75,0,7},{CR76,4,6} */
+#define IGA2_SHADOW_VER_SYNC_START_REG_NUM  2
+/* location: {CR76,0,3} */
+#define IGA2_SHADOW_VER_SYNC_END_REG_NUM    1
+
+/* Define Register Number for IGA2 CRTC Timing */
+
+/* location: {CR50,0,7},{CR55,0,3} */
+#define IGA2_HOR_TOTAL_REG_NUM          2
+/* location: {CR51,0,7},{CR55,4,6} */
+#define IGA2_HOR_ADDR_REG_NUM           2
+/* location: {CR52,0,7},{CR54,0,2} */
+#define IGA2_HOR_BLANK_START_REG_NUM    2
+/* location: CLE266: {CR53,0,7},{CR54,3,5} => CLE266's CR5D[6]
+is reserved, so it may have problem to set 1600x1200 on IGA2. */
+/*         	Others: {CR53,0,7},{CR54,3,5},{CR5D,6,6} */
+#define IGA2_HOR_BLANK_END_REG_NUM      3
+/* location: {CR56,0,7},{CR54,6,7},{CR5C,7,7} */
+/* VT3314 and Later: {CR56,0,7},{CR54,6,7},{CR5C,7,7}, {CR5D,7,7} */
+#define IGA2_HOR_SYNC_START_REG_NUM     4
+
+/* location: {CR57,0,7},{CR5C,6,6} */
+#define IGA2_HOR_SYNC_END_REG_NUM       2
+/* location: {CR58,0,7},{CR5D,0,2} */
+#define IGA2_VER_TOTAL_REG_NUM          2
+/* location: {CR59,0,7},{CR5D,3,5} */
+#define IGA2_VER_ADDR_REG_NUM           2
+/* location: {CR5A,0,7},{CR5C,0,2} */
+#define IGA2_VER_BLANK_START_REG_NUM    2
+/* location: {CR5E,0,7},{CR5C,3,5} */
+#define IGA2_VER_BLANK_END_REG_NUM      2
+/* location: {CR5E,0,7},{CR5F,5,7} */
+#define IGA2_VER_SYNC_START_REG_NUM     2
+/* location: {CR5F,0,4} */
+#define IGA2_VER_SYNC_END_REG_NUM       1
+
+/* Define Offset and Fetch Count Register*/
+
+/* location: {CR13,0,7},{CR35,5,7} */
+#define IGA1_OFFSET_REG_NUM             2
+/* 8 bytes alignment. */
+#define IGA1_OFFSER_ALIGN_BYTE          8
+/* x: H resolution, y: color depth */
+#define IGA1_OFFSET_FORMULA(x, y)        (x*y)/IGA1_OFFSER_ALIGN_BYTE
+/* location: {SR1C,0,7},{SR1D,0,1} */
+#define IGA1_FETCH_COUNT_REG_NUM        2
+/* 16 bytes alignment. */
+#define IGA1_FETCH_COUNT_ALIGN_BYTE     16
+/* x: H resolution, y: color depth */
+#define IGA1_FETCH_COUNT_PATCH_VALUE    4
+#define IGA1_FETCH_COUNT_FORMULA(x, y)   \
+	((x*y)/IGA1_FETCH_COUNT_ALIGN_BYTE) + IGA1_FETCH_COUNT_PATCH_VALUE
+
+/* location: {CR66,0,7},{CR67,0,1} */
+#define IGA2_OFFSET_REG_NUM             2
+#define IGA2_OFFSET_ALIGN_BYTE          8
+/* x: H resolution, y: color depth */
+#define IGA2_OFFSET_FORMULA(x, y)        (x*y)/IGA2_OFFSET_ALIGN_BYTE
+/* location: {CR65,0,7},{CR67,2,3} */
+#define IGA2_FETCH_COUNT_REG_NUM        2
+#define IGA2_FETCH_COUNT_ALIGN_BYTE     16
+#define IGA2_FETCH_COUNT_PATCH_VALUE    0
+#define IGA2_FETCH_COUNT_FORMULA(x, y)   \
+	((x*y)/IGA2_FETCH_COUNT_ALIGN_BYTE) + IGA2_FETCH_COUNT_PATCH_VALUE
+
+/* Staring Address*/
+
+/* location: {CR0C,0,7},{CR0D,0,7},{CR34,0,7},{CR48,0,1} */
+#define IGA1_STARTING_ADDR_REG_NUM      4
+/* location: {CR62,1,7},{CR63,0,7},{CR64,0,7} */
+#define IGA2_STARTING_ADDR_REG_NUM      3
+
+/* Define Display OFFSET*/
+/* These value are by HW suggested value*/
+/* location: {SR17,0,7} */
+#define K800_IGA1_FIFO_MAX_DEPTH                384
+/* location: {SR16,0,5},{SR16,7,7} */
+#define K800_IGA1_FIFO_THRESHOLD                328
+/* location: {SR18,0,5},{SR18,7,7} */
+#define K800_IGA1_FIFO_HIGH_THRESHOLD           296
+/* location: {SR22,0,4}. (128/4) =64, K800 must be set zero, */
+				/* because HW only 5 bits */
+#define K800_IGA1_DISPLAY_QUEUE_EXPIRE_NUM      0
+
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define K800_IGA2_FIFO_MAX_DEPTH                384
+/* location: {CR68,0,3},{CR95,4,6} */
+#define K800_IGA2_FIFO_THRESHOLD                328
+/* location: {CR92,0,3},{CR95,0,2} */
+#define K800_IGA2_FIFO_HIGH_THRESHOLD           296
+/* location: {CR94,0,6} */
+#define K800_IGA2_DISPLAY_QUEUE_EXPIRE_NUM      128
+
+/* location: {SR17,0,7} */
+#define P880_IGA1_FIFO_MAX_DEPTH                192
+/* location: {SR16,0,5},{SR16,7,7} */
+#define P880_IGA1_FIFO_THRESHOLD                128
+/* location: {SR18,0,5},{SR18,7,7} */
+#define P880_IGA1_FIFO_HIGH_THRESHOLD           64
+/* location: {SR22,0,4}. (128/4) =64, K800 must be set zero, */
+				/* because HW only 5 bits */
+#define P880_IGA1_DISPLAY_QUEUE_EXPIRE_NUM      0
+
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define P880_IGA2_FIFO_MAX_DEPTH                96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define P880_IGA2_FIFO_THRESHOLD                64
+/* location: {CR92,0,3},{CR95,0,2} */
+#define P880_IGA2_FIFO_HIGH_THRESHOLD           32
+/* location: {CR94,0,6} */
+#define P880_IGA2_DISPLAY_QUEUE_EXPIRE_NUM      128
+
+/* VT3314 chipset*/
+
+/* location: {SR17,0,7} */
+#define CN700_IGA1_FIFO_MAX_DEPTH               96
+/* location: {SR16,0,5},{SR16,7,7} */
+#define CN700_IGA1_FIFO_THRESHOLD               80
+/* location: {SR18,0,5},{SR18,7,7} */
+#define CN700_IGA1_FIFO_HIGH_THRESHOLD          64
+/* location: {SR22,0,4}. (128/4) =64, P800 must be set zero,
+				because HW only 5 bits */
+#define CN700_IGA1_DISPLAY_QUEUE_EXPIRE_NUM     0
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define CN700_IGA2_FIFO_MAX_DEPTH               96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define CN700_IGA2_FIFO_THRESHOLD               80
+/* location: {CR92,0,3},{CR95,0,2} */
+#define CN700_IGA2_FIFO_HIGH_THRESHOLD          32
+/* location: {CR94,0,6} */
+#define CN700_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     128
+
+/* For VT3324, these values are suggested by HW */
+/* location: {SR17,0,7} */
+#define CX700_IGA1_FIFO_MAX_DEPTH               192
+/* location: {SR16,0,5},{SR16,7,7} */
+#define CX700_IGA1_FIFO_THRESHOLD               128
+/* location: {SR18,0,5},{SR18,7,7} */
+#define CX700_IGA1_FIFO_HIGH_THRESHOLD          128
+/* location: {SR22,0,4} */
+#define CX700_IGA1_DISPLAY_QUEUE_EXPIRE_NUM     124
+
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define CX700_IGA2_FIFO_MAX_DEPTH               96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define CX700_IGA2_FIFO_THRESHOLD               64
+/* location: {CR92,0,3},{CR95,0,2} */
+#define CX700_IGA2_FIFO_HIGH_THRESHOLD          32
+/* location: {CR94,0,6} */
+#define CX700_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     128
+
+/* VT3336 chipset*/
+/* location: {SR17,0,7} */
+#define K8M890_IGA1_FIFO_MAX_DEPTH               360
+/* location: {SR16,0,5},{SR16,7,7} */
+#define K8M890_IGA1_FIFO_THRESHOLD               328
+/* location: {SR18,0,5},{SR18,7,7} */
+#define K8M890_IGA1_FIFO_HIGH_THRESHOLD          296
+/* location: {SR22,0,4}. */
+#define K8M890_IGA1_DISPLAY_QUEUE_EXPIRE_NUM     124
+
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define K8M890_IGA2_FIFO_MAX_DEPTH               360
+/* location: {CR68,0,3},{CR95,4,6} */
+#define K8M890_IGA2_FIFO_THRESHOLD               328
+/* location: {CR92,0,3},{CR95,0,2} */
+#define K8M890_IGA2_FIFO_HIGH_THRESHOLD          296
+/* location: {CR94,0,6} */
+#define K8M890_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     124
+
+/* VT3327 chipset*/
+/* location: {SR17,0,7} */
+#define P4M890_IGA1_FIFO_MAX_DEPTH               96
+/* location: {SR16,0,5},{SR16,7,7} */
+#define P4M890_IGA1_FIFO_THRESHOLD               76
+/* location: {SR18,0,5},{SR18,7,7} */
+#define P4M890_IGA1_FIFO_HIGH_THRESHOLD          64
+/* location: {SR22,0,4}. (32/4) =8 */
+#define P4M890_IGA1_DISPLAY_QUEUE_EXPIRE_NUM     32
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define P4M890_IGA2_FIFO_MAX_DEPTH               96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define P4M890_IGA2_FIFO_THRESHOLD               76
+/* location: {CR92,0,3},{CR95,0,2} */
+#define P4M890_IGA2_FIFO_HIGH_THRESHOLD          64
+/* location: {CR94,0,6} */
+#define P4M890_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     32
+
+/* VT3364 chipset*/
+/* location: {SR17,0,7} */
+#define P4M900_IGA1_FIFO_MAX_DEPTH               96
+/* location: {SR16,0,5},{SR16,7,7} */
+#define P4M900_IGA1_FIFO_THRESHOLD               76
+/* location: {SR18,0,5},{SR18,7,7} */
+#define P4M900_IGA1_FIFO_HIGH_THRESHOLD          76
+/* location: {SR22,0,4}. */
+#define P4M900_IGA1_DISPLAY_QUEUE_EXPIRE_NUM     32
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define P4M900_IGA2_FIFO_MAX_DEPTH               96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define P4M900_IGA2_FIFO_THRESHOLD               76
+/* location: {CR92,0,3},{CR95,0,2} */
+#define P4M900_IGA2_FIFO_HIGH_THRESHOLD          76
+/* location: {CR94,0,6} */
+#define P4M900_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     32
+
+/* For VT3353, these values are suggested by HW */
+/* location: {SR17,0,7} */
+#define VX800_IGA1_FIFO_MAX_DEPTH               192
+/* location: {SR16,0,5},{SR16,7,7} */
+#define VX800_IGA1_FIFO_THRESHOLD               152
+/* location: {SR18,0,5},{SR18,7,7} */
+#define VX800_IGA1_FIFO_HIGH_THRESHOLD          152
+/* location: {SR22,0,4} */
+#define VX800_IGA1_DISPLAY_QUEUE_EXPIRE_NUM      64
+/* location: {CR68,4,7},{CR94,7,7},{CR95,7,7} */
+#define VX800_IGA2_FIFO_MAX_DEPTH               96
+/* location: {CR68,0,3},{CR95,4,6} */
+#define VX800_IGA2_FIFO_THRESHOLD               64
+/* location: {CR92,0,3},{CR95,0,2} */
+#define VX800_IGA2_FIFO_HIGH_THRESHOLD          32
+/* location: {CR94,0,6} */
+#define VX800_IGA2_DISPLAY_QUEUE_EXPIRE_NUM     128
+
+#define IGA1_FIFO_DEPTH_SELECT_REG_NUM          1
+#define IGA1_FIFO_THRESHOLD_REG_NUM             2
+#define IGA1_FIFO_HIGH_THRESHOLD_REG_NUM        2
+#define IGA1_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM   1
+
+#define IGA2_FIFO_DEPTH_SELECT_REG_NUM          3
+#define IGA2_FIFO_THRESHOLD_REG_NUM             2
+#define IGA2_FIFO_HIGH_THRESHOLD_REG_NUM        2
+#define IGA2_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM   1
+
+#define IGA1_FIFO_DEPTH_SELECT_FORMULA(x)                   (x/2)-1
+#define IGA1_FIFO_THRESHOLD_FORMULA(x)                      (x/4)
+#define IGA1_DISPLAY_QUEUE_EXPIRE_NUM_FORMULA(x)            (x/4)
+#define IGA1_FIFO_HIGH_THRESHOLD_FORMULA(x)                 (x/4)
+#define IGA2_FIFO_DEPTH_SELECT_FORMULA(x)                   ((x/2)/4)-1
+#define IGA2_FIFO_THRESHOLD_FORMULA(x)                      (x/4)
+#define IGA2_DISPLAY_QUEUE_EXPIRE_NUM_FORMULA(x)            (x/4)
+#define IGA2_FIFO_HIGH_THRESHOLD_FORMULA(x)                 (x/4)
+
+/************************************************************************/
+/*  LCD Timing                                                          */
+/************************************************************************/
+
+/* 500 ms = 500000 us */
+#define LCD_POWER_SEQ_TD0               500000
+/* 50 ms = 50000 us */
+#define LCD_POWER_SEQ_TD1               50000
+/* 0 us */
+#define LCD_POWER_SEQ_TD2               0
+/* 210 ms = 210000 us */
+#define LCD_POWER_SEQ_TD3               210000
+/* 2^10 * (1/14.31818M) = 71.475 us (K400.revA) */
+#define CLE266_POWER_SEQ_UNIT           71
+/* 2^11 * (1/14.31818M) = 142.95 us (K400.revB) */
+#define K800_POWER_SEQ_UNIT             142
+/* 2^13 * (1/14.31818M) = 572.1 us */
+#define P880_POWER_SEQ_UNIT             572
+
+#define CLE266_POWER_SEQ_FORMULA(x)     (x)/CLE266_POWER_SEQ_UNIT
+#define K800_POWER_SEQ_FORMULA(x)       (x)/K800_POWER_SEQ_UNIT
+#define P880_POWER_SEQ_FORMULA(x)       (x)/P880_POWER_SEQ_UNIT
+
+/* location: {CR8B,0,7},{CR8F,0,3} */
+#define LCD_POWER_SEQ_TD0_REG_NUM       2
+/* location: {CR8C,0,7},{CR8F,4,7} */
+#define LCD_POWER_SEQ_TD1_REG_NUM       2
+/* location: {CR8D,0,7},{CR90,0,3} */
+#define LCD_POWER_SEQ_TD2_REG_NUM       2
+/* location: {CR8E,0,7},{CR90,4,7} */
+#define LCD_POWER_SEQ_TD3_REG_NUM       2
+
+/* LCD Scaling factor*/
+/* x: indicate setting horizontal size*/
+/* y: indicate panel horizontal size*/
+
+/* Horizontal scaling factor 10 bits (2^10) */
+#define CLE266_LCD_HOR_SCF_FORMULA(x, y)   (((x-1)*1024)/(y-1))
+/* Vertical scaling factor 10 bits (2^10) */
+#define CLE266_LCD_VER_SCF_FORMULA(x, y)   (((x-1)*1024)/(y-1))
+/* Horizontal scaling factor 10 bits (2^12) */
+#define K800_LCD_HOR_SCF_FORMULA(x, y)     (((x-1)*4096)/(y-1))
+/* Vertical scaling factor 10 bits (2^11) */
+#define K800_LCD_VER_SCF_FORMULA(x, y)     (((x-1)*2048)/(y-1))
+
+/* location: {CR9F,0,1},{CR77,0,7},{CR79,4,5} */
+#define LCD_HOR_SCALING_FACTOR_REG_NUM  3
+/* location: {CR79,3,3},{CR78,0,7},{CR79,6,7} */
+#define LCD_VER_SCALING_FACTOR_REG_NUM  3
+/* location: {CR77,0,7},{CR79,4,5} */
+#define LCD_HOR_SCALING_FACTOR_REG_NUM_CLE  2
+/* location: {CR78,0,7},{CR79,6,7} */
+#define LCD_VER_SCALING_FACTOR_REG_NUM_CLE  2
+
+/************************************************
+ *****     Define IGA1 Display Timing       *****
+ ************************************************/
+struct io_register {
+	u8 io_addr;
+	u8 start_bit;
+	u8 end_bit;
+};
+
+/* IGA1 Horizontal Total */
+struct iga1_hor_total {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_TOTAL_REG_NUM];
+};
+
+/* IGA1 Horizontal Addressable Video */
+struct iga1_hor_addr {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_ADDR_REG_NUM];
+};
+
+/* IGA1 Horizontal Blank Start */
+struct iga1_hor_blank_start {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_BLANK_START_REG_NUM];
+};
+
+/* IGA1 Horizontal Blank End */
+struct iga1_hor_blank_end {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_BLANK_END_REG_NUM];
+};
+
+/* IGA1 Horizontal Sync Start */
+struct iga1_hor_sync_start {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_SYNC_START_REG_NUM];
+};
+
+/* IGA1 Horizontal Sync End */
+struct iga1_hor_sync_end {
+	int reg_num;
+	struct io_register reg[IGA1_HOR_SYNC_END_REG_NUM];
+};
+
+/* IGA1 Vertical Total */
+struct iga1_ver_total {
+	int reg_num;
+	struct io_register reg[IGA1_VER_TOTAL_REG_NUM];
+};
+
+/* IGA1 Vertical Addressable Video */
+struct iga1_ver_addr {
+	int reg_num;
+	struct io_register reg[IGA1_VER_ADDR_REG_NUM];
+};
+
+/* IGA1 Vertical Blank Start */
+struct iga1_ver_blank_start {
+	int reg_num;
+	struct io_register reg[IGA1_VER_BLANK_START_REG_NUM];
+};
+
+/* IGA1 Vertical Blank End */
+struct iga1_ver_blank_end {
+	int reg_num;
+	struct io_register reg[IGA1_VER_BLANK_END_REG_NUM];
+};
+
+/* IGA1 Vertical Sync Start */
+struct iga1_ver_sync_start {
+	int reg_num;
+	struct io_register reg[IGA1_VER_SYNC_START_REG_NUM];
+};
+
+/* IGA1 Vertical Sync End */
+struct iga1_ver_sync_end {
+	int reg_num;
+	struct io_register reg[IGA1_VER_SYNC_END_REG_NUM];
+};
+
+/*****************************************************
+**      Define IGA2 Shadow Display Timing         ****
+*****************************************************/
+
+/* IGA2 Shadow Horizontal Total */
+struct iga2_shadow_hor_total {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_HOR_TOTAL_REG_NUM];
+};
+
+/* IGA2 Shadow Horizontal Blank End */
+struct iga2_shadow_hor_blank_end {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_HOR_BLANK_END_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Total */
+struct iga2_shadow_ver_total {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_TOTAL_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Addressable Video */
+struct iga2_shadow_ver_addr {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_ADDR_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Blank Start */
+struct iga2_shadow_ver_blank_start {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_BLANK_START_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Blank End */
+struct iga2_shadow_ver_blank_end {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_BLANK_END_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Sync Start */
+struct iga2_shadow_ver_sync_start {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_SYNC_START_REG_NUM];
+};
+
+/* IGA2 Shadow Vertical Sync End */
+struct iga2_shadow_ver_sync_end {
+	int reg_num;
+	struct io_register reg[IGA2_SHADOW_VER_SYNC_END_REG_NUM];
+};
+
+/*****************************************************
+**      Define IGA2 Display Timing                ****
+******************************************************/
+
+/* IGA2 Horizontal Total */
+struct iga2_hor_total {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_TOTAL_REG_NUM];
+};
+
+/* IGA2 Horizontal Addressable Video */
+struct iga2_hor_addr {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_ADDR_REG_NUM];
+};
+
+/* IGA2 Horizontal Blank Start */
+struct iga2_hor_blank_start {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_BLANK_START_REG_NUM];
+};
+
+/* IGA2 Horizontal Blank End */
+struct iga2_hor_blank_end {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_BLANK_END_REG_NUM];
+};
+
+/* IGA2 Horizontal Sync Start */
+struct iga2_hor_sync_start {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_SYNC_START_REG_NUM];
+};
+
+/* IGA2 Horizontal Sync End */
+struct iga2_hor_sync_end {
+	int reg_num;
+	struct io_register reg[IGA2_HOR_SYNC_END_REG_NUM];
+};
+
+/* IGA2 Vertical Total */
+struct iga2_ver_total {
+	int reg_num;
+	struct io_register reg[IGA2_VER_TOTAL_REG_NUM];
+};
+
+/* IGA2 Vertical Addressable Video */
+struct iga2_ver_addr {
+	int reg_num;
+	struct io_register reg[IGA2_VER_ADDR_REG_NUM];
+};
+
+/* IGA2 Vertical Blank Start */
+struct iga2_ver_blank_start {
+	int reg_num;
+	struct io_register reg[IGA2_VER_BLANK_START_REG_NUM];
+};
+
+/* IGA2 Vertical Blank End */
+struct iga2_ver_blank_end {
+	int reg_num;
+	struct io_register reg[IGA2_VER_BLANK_END_REG_NUM];
+};
+
+/* IGA2 Vertical Sync Start */
+struct iga2_ver_sync_start {
+	int reg_num;
+	struct io_register reg[IGA2_VER_SYNC_START_REG_NUM];
+};
+
+/* IGA2 Vertical Sync End */
+struct iga2_ver_sync_end {
+	int reg_num;
+	struct io_register reg[IGA2_VER_SYNC_END_REG_NUM];
+};
+
+/* IGA1 Offset Register */
+struct iga1_offset {
+	int reg_num;
+	struct io_register reg[IGA1_OFFSET_REG_NUM];
+};
+
+/* IGA2 Offset Register */
+struct iga2_offset {
+	int reg_num;
+	struct io_register reg[IGA2_OFFSET_REG_NUM];
+};
+
+struct offset {
+	struct iga1_offset iga1_offset_reg;
+	struct iga2_offset iga2_offset_reg;
+};
+
+/* IGA1 Fetch Count Register */
+struct iga1_fetch_count {
+	int reg_num;
+	struct io_register reg[IGA1_FETCH_COUNT_REG_NUM];
+};
+
+/* IGA2 Fetch Count Register */
+struct iga2_fetch_count {
+	int reg_num;
+	struct io_register reg[IGA2_FETCH_COUNT_REG_NUM];
+};
+
+struct fetch_count {
+	struct iga1_fetch_count iga1_fetch_count_reg;
+	struct iga2_fetch_count iga2_fetch_count_reg;
+};
+
+/* Starting Address Register */
+struct iga1_starting_addr {
+	int reg_num;
+	struct io_register reg[IGA1_STARTING_ADDR_REG_NUM];
+};
+
+struct iga2_starting_addr {
+	int reg_num;
+	struct io_register reg[IGA2_STARTING_ADDR_REG_NUM];
+};
+
+struct starting_addr {
+	struct iga1_starting_addr iga1_starting_addr_reg;
+	struct iga2_starting_addr iga2_starting_addr_reg;
+};
+
+/* LCD Power Sequence Timer */
+struct lcd_pwd_seq_td0 {
+	int reg_num;
+	struct io_register reg[LCD_POWER_SEQ_TD0_REG_NUM];
+};
+
+struct lcd_pwd_seq_td1 {
+	int reg_num;
+	struct io_register reg[LCD_POWER_SEQ_TD1_REG_NUM];
+};
+
+struct lcd_pwd_seq_td2 {
+	int reg_num;
+	struct io_register reg[LCD_POWER_SEQ_TD2_REG_NUM];
+};
+
+struct lcd_pwd_seq_td3 {
+	int reg_num;
+	struct io_register reg[LCD_POWER_SEQ_TD3_REG_NUM];
+};
+
+struct _lcd_pwd_seq_timer {
+	struct lcd_pwd_seq_td0 td0;
+	struct lcd_pwd_seq_td1 td1;
+	struct lcd_pwd_seq_td2 td2;
+	struct lcd_pwd_seq_td3 td3;
+};
+
+/* LCD Scaling Factor */
+struct _lcd_hor_scaling_factor {
+	int reg_num;
+	struct io_register reg[LCD_HOR_SCALING_FACTOR_REG_NUM];
+};
+
+struct _lcd_ver_scaling_factor {
+	int reg_num;
+	struct io_register reg[LCD_VER_SCALING_FACTOR_REG_NUM];
+};
+
+struct _lcd_scaling_factor {
+	struct _lcd_hor_scaling_factor lcd_hor_scaling_factor;
+	struct _lcd_ver_scaling_factor lcd_ver_scaling_factor;
+};
+
+struct pll_map {
+	u32 clk;
+	u32 cle266_pll;
+	u32 k800_pll;
+	u32 cx700_pll;
+};
+
+struct rgbLUT {
+	u8 red;
+	u8 green;
+	u8 blue;
+};
+
+struct lcd_pwd_seq_timer {
+	u16 td0;
+	u16 td1;
+	u16 td2;
+	u16 td3;
+};
+
+/* Display FIFO Relation Registers*/
+struct iga1_fifo_depth_select {
+	int reg_num;
+	struct io_register reg[IGA1_FIFO_DEPTH_SELECT_REG_NUM];
+};
+
+struct iga1_fifo_threshold_select {
+	int reg_num;
+	struct io_register reg[IGA1_FIFO_THRESHOLD_REG_NUM];
+};
+
+struct iga1_fifo_high_threshold_select {
+	int reg_num;
+	struct io_register reg[IGA1_FIFO_HIGH_THRESHOLD_REG_NUM];
+};
+
+struct iga1_display_queue_expire_num {
+	int reg_num;
+	struct io_register reg[IGA1_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM];
+};
+
+struct iga2_fifo_depth_select {
+	int reg_num;
+	struct io_register reg[IGA2_FIFO_DEPTH_SELECT_REG_NUM];
+};
+
+struct iga2_fifo_threshold_select {
+	int reg_num;
+	struct io_register reg[IGA2_FIFO_THRESHOLD_REG_NUM];
+};
+
+struct iga2_fifo_high_threshold_select {
+	int reg_num;
+	struct io_register reg[IGA2_FIFO_HIGH_THRESHOLD_REG_NUM];
+};
+
+struct iga2_display_queue_expire_num {
+	int reg_num;
+	struct io_register reg[IGA2_DISPLAY_QUEUE_EXPIRE_NUM_REG_NUM];
+};
+
+struct fifo_depth_select {
+	struct iga1_fifo_depth_select iga1_fifo_depth_select_reg;
+	struct iga2_fifo_depth_select iga2_fifo_depth_select_reg;
+};
+
+struct fifo_threshold_select {
+	struct iga1_fifo_threshold_select iga1_fifo_threshold_select_reg;
+	struct iga2_fifo_threshold_select iga2_fifo_threshold_select_reg;
+};
+
+struct fifo_high_threshold_select {
+	struct iga1_fifo_high_threshold_select
+	 iga1_fifo_high_threshold_select_reg;
+	struct iga2_fifo_high_threshold_select
+	 iga2_fifo_high_threshold_select_reg;
+};
+
+struct display_queue_expire_num {
+	struct iga1_display_queue_expire_num
+	 iga1_display_queue_expire_num_reg;
+	struct iga2_display_queue_expire_num
+	 iga2_display_queue_expire_num_reg;
+};
+
+struct iga1_crtc_timing {
+	struct iga1_hor_total hor_total;
+	struct iga1_hor_addr hor_addr;
+	struct iga1_hor_blank_start hor_blank_start;
+	struct iga1_hor_blank_end hor_blank_end;
+	struct iga1_hor_sync_start hor_sync_start;
+	struct iga1_hor_sync_end hor_sync_end;
+	struct iga1_ver_total ver_total;
+	struct iga1_ver_addr ver_addr;
+	struct iga1_ver_blank_start ver_blank_start;
+	struct iga1_ver_blank_end ver_blank_end;
+	struct iga1_ver_sync_start ver_sync_start;
+	struct iga1_ver_sync_end ver_sync_end;
+};
+
+struct iga2_shadow_crtc_timing {
+	struct iga2_shadow_hor_total hor_total_shadow;
+	struct iga2_shadow_hor_blank_end hor_blank_end_shadow;
+	struct iga2_shadow_ver_total ver_total_shadow;
+	struct iga2_shadow_ver_addr ver_addr_shadow;
+	struct iga2_shadow_ver_blank_start ver_blank_start_shadow;
+	struct iga2_shadow_ver_blank_end ver_blank_end_shadow;
+	struct iga2_shadow_ver_sync_start ver_sync_start_shadow;
+	struct iga2_shadow_ver_sync_end ver_sync_end_shadow;
+};
+
+struct iga2_crtc_timing {
+	struct iga2_hor_total hor_total;
+	struct iga2_hor_addr hor_addr;
+	struct iga2_hor_blank_start hor_blank_start;
+	struct iga2_hor_blank_end hor_blank_end;
+	struct iga2_hor_sync_start hor_sync_start;
+	struct iga2_hor_sync_end hor_sync_end;
+	struct iga2_ver_total ver_total;
+	struct iga2_ver_addr ver_addr;
+	struct iga2_ver_blank_start ver_blank_start;
+	struct iga2_ver_blank_end ver_blank_end;
+	struct iga2_ver_sync_start ver_sync_start;
+	struct iga2_ver_sync_end ver_sync_end;
+};
+
+/* device ID */
+#define CLE266              0x3123
+#define KM400               0x3205
+#define CN400_FUNCTION2     0x2259
+#define CN400_FUNCTION3     0x3259
+/* support VT3314 chipset */
+#define CN700_FUNCTION2     0x2314
+#define CN700_FUNCTION3     0x3208
+/* VT3324 chipset */
+#define CX700_FUNCTION2     0x2324
+#define CX700_FUNCTION3     0x3324
+/* VT3204 chipset*/
+#define KM800_FUNCTION3      0x3204
+/* VT3336 chipset*/
+#define KM890_FUNCTION3      0x3336
+/* VT3327 chipset*/
+#define P4M890_FUNCTION3     0x3327
+/* VT3293 chipset*/
+#define CN750_FUNCTION3     0x3208
+/* VT3364 chipset*/
+#define P4M900_FUNCTION3    0x3364
+/* VT3353 chipset*/
+#define VX800_FUNCTION3     0x3353
+
+#define NUM_TOTAL_PLL_TABLE ARRAY_SIZE(pll_value)
+
+struct IODATA {
+	u8 Index;
+	u8 Mask;
+	u8 Data;
+};
+extern unsigned int second_virtual_xres;
+extern unsigned int second_offset;
+extern int second_size;
+extern int SAMM_ON;
+extern int dual_fb;
+extern int LCD2_ON;
+extern int LCD_ON;
+extern int DVI_ON;
+extern int via_fb_accel;
+extern int via_fb_hotplug;
+
+extern struct pll_map pll_value[68];
+extern struct fifo_depth_select display_fifo_depth_reg;
+extern struct fifo_threshold_select fifo_threshold_select_reg;
+extern struct fifo_high_threshold_select fifo_high_threshold_select_reg;
+extern struct display_queue_expire_num display_queue_expire_num_reg;
+extern struct fetch_count fetch_count_reg;
+extern struct iga1_crtc_timing iga1_crtc_reg;
+extern struct iga2_crtc_timing iga2_crtc_reg;
+
+void write_reg_mask(u8 index, int io_port, u8 data, u8 mask);
+void set_output_path(int device, int set_iga, int output_interface);
+void fill_crtc_timing(struct crt_mode_table *crt_table,
+		      int mode_index, int bpp_byte, int set_iga);
+
+void set_crt_output_path(int set_iga);
+void set_dvi_output_path(int set_iga, int output_interface);
+void set_lcd_output_path(int set_iga, int output_interface);
+void set_vclock(u32 CLK, int set_iga);
+void init_gfx_chip_info(void);
+void init_tmds_chip_info(void);
+void init_lvds_chip_info(void);
+void load_reg(int timing_value, int load_reg_num, struct io_register *reg,
+	      int io_type);
+void device_off(void);
+void device_on(void);
+void crt_disable(void);
+void crt_enable(void);
+void enable_second_display_channel(void);
+void disable_second_display_channel(void);
+void lcd_patch_skew(struct lvds_setting_information *plvds_setting_info,
+		    struct lvds_chip_information *plvds_chip_info);
+int get_fb_size_from_pci(void);
+void init_ad9389(void);
+int tmds_register_read(int index);
+void enable_second_display_channel(void);
+/* Access I/O Function */
+void write_reg(u8 index, u16 io_port, u8 data);
+u8 read_reg(int io_port, u8 index);
+void lock_crt(void);
+void unlock_crt(void);
+struct display_timing get_timing_value(struct crt_mode_table
+				       *crt_table, int mode_index);
+void load_offset_reg(int h_addr, int bpp_byte, int set_iga);
+void load_fetch_count_reg(int h_addr, int bpp_byte, int set_iga);
+void write_regx(struct io_reg RegTable[], int ItemNum);
+struct VideoModeTable *get_modetbl_pointer(int Index);
+int search_mode_setting(int ModeInfoIndex);
+u32 get_clk_value(int clk);
+void load_FIFO_reg(int set_iga, int hor_active, int ver_active);
+void set_color_depth(int bpp_byte, int set_iga);
+void set_dpa_gfx(int output_interface, struct GFX_DPA_SETTING\
+					*p_gfx_dpa_setting);
+
+int setmode(int vmode_index, int hor_res, int ver_res,
+	    int video_bpp, int vmode_index1, int hor_res1,
+	    int ver_res1, int video_bpp1);
+void init_chip_info(void);
+void init_dac(int set_iga);
+int get_pixclock(int hres, int vres, int vmode_refresh);
+int get_refresh(int hres, int vres, int pixclock);
+void update_device_setting(int hres, int vres, int bpp,
+			   int vmode_refresh, int flag);
+void get_mmio_info(unsigned long *mmio_base, unsigned long *mmio_len);
+
+void set_iga_path(void);
+void set_start_addr(void);
+void get_fb_info(unsigned int *fb_base, unsigned int *fb_len);
+
+#endif /* __HW_H__ */
--- /dev/null
+++ b/drivers/video/viafb/iface.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+/* Get frame buffer size from VGA BIOS */
+
+unsigned int get_memsize(void)
+{
+	unsigned int m;
+
+	/* If memory size provided by user */
+	if (via_fb_memsize)
+		m = via_fb_memsize * Mb;
+	else {
+		m = (unsigned int)read_reg(VIASR, SR39);
+		m = m * (4 * Mb);
+
+		if ((m < (16 * Mb)) || (m > (64 * Mb)))
+			m = 16 * Mb;
+	}
+	DEBUG_MSG(KERN_INFO "framebuffer size = %d Mb\n", m / Mb);
+	return m;
+}
+
+/* Get Video Buffer Starting Physical Address(back door)*/
+
+unsigned long get_videobuf_addr(void)
+{
+	struct pci_dev *pdev = NULL;
+	unsigned char sys_mem;
+	unsigned char video_mem;
+	unsigned long sys_mem_size;
+	unsigned long video_mem_size;
+	/*system memory = 256 MB, video memory 64 MB */
+	unsigned long vmem_starting_adr = 0x0C000000;
+
+	pdev =
+	    (struct pci_dev *)pci_get_device(VIA_K800_BRIDGE_VID,
+					     VIA_K800_BRIDGE_DID, NULL);
+	if (pdev != NULL) {
+		pci_read_config_byte(pdev, VIA_K800_SYSTEM_MEMORY_REG,
+				     &sys_mem);
+		pci_read_config_byte(pdev, VIA_K800_VIDEO_MEMORY_REG,
+				     &video_mem);
+		video_mem = (video_mem & 0x70) >> 4;
+		sys_mem_size = ((unsigned long)sys_mem) << 24;
+		if (video_mem != 0)
+			video_mem_size = (1 << (video_mem)) * 1024 * 1024;
+		else
+			video_mem_size = 0;
+
+		vmem_starting_adr = sys_mem_size - video_mem_size;
+
+	}
+
+	DEBUG_MSG(KERN_INFO "Video Memory Starting Address = %lx \n",
+		  vmem_starting_adr);
+	return vmem_starting_adr;
+}
--- /dev/null
+++ b/drivers/video/viafb/iface.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __IFACE_H__
+#define __IFACE_H__
+
+#define Kb  (1024)
+#define Mb  (Kb*Kb)
+
+#define VIA_K800_BRIDGE_VID         0x1106
+#define VIA_K800_BRIDGE_DID         0x3204
+
+#define VIA_K800_SYSTEM_MEMORY_REG  0x47
+#define VIA_K800_VIDEO_MEMORY_REG   0xA1
+
+extern int via_fb_memsize;
+unsigned int get_memsize(void);
+unsigned long get_videobuf_addr(void);
+
+#endif /* __IFACE_H__ */
--- /dev/null
+++ b/drivers/video/viafb/ioctl.c
@@ -0,0 +1,111 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+int ioctl_get_viafb_info(u_long arg)
+{
+	struct viafb_ioctl_info viainfo;
+
+	viainfo.viafb_id = VIAID;
+	viainfo.vendor_id = PCI_VIA_VENDOR_ID;
+
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_CLE266:
+		viainfo.device_id = UNICHROME_CLE266_DID;
+		break;
+
+	case UNICHROME_K400:
+		viainfo.device_id = UNICHROME_K400_DID;
+		break;
+
+	case UNICHROME_K800:
+		viainfo.device_id = UNICHROME_K800_DID;
+		break;
+
+	case UNICHROME_PM800:
+		viainfo.device_id = UNICHROME_PM800_DID;
+		break;
+
+	case UNICHROME_CN700:
+		viainfo.device_id = UNICHROME_CN700_DID;
+		break;
+
+	case UNICHROME_CX700:
+		viainfo.device_id = UNICHROME_CX700_DID;
+		break;
+
+	case UNICHROME_K8M890:
+		viainfo.device_id = UNICHROME_K8M890_DID;
+		break;
+
+	case UNICHROME_P4M890:
+		viainfo.device_id = UNICHROME_P4M890_DID;
+		break;
+
+	case UNICHROME_P4M900:
+		viainfo.device_id = UNICHROME_P4M900_DID;
+		break;
+	}
+
+	viainfo.version = VERSION_MAJOR;
+	viainfo.revision = VERSION_MINOR;
+
+	if (copy_to_user((void __user *)arg, &viainfo, sizeof(viainfo)))
+		return -EFAULT;
+
+	return 0;
+}
+
+/* Hot-Plug Priority: DVI > CRT*/
+int ioctl_hotplug(int hres, int vres, int bpp)
+{
+	int DVIsense, status = 0;
+	DEBUG_MSG(KERN_INFO "ioctl_hotplug!!\n");
+
+	if (chip_info.tmds_chip_info.tmds_chip_name != NON_TMDS_TRANSMITTER) {
+		DVIsense = dvi_sense();
+
+		if (DVIsense) {
+			DEBUG_MSG(KERN_INFO "DVI Attached...\n");
+			if (DeviceStatus != DVI_Device) {
+				DVI_ON = 1;
+				CRT_ON = 0;
+				LCD_ON = 0;
+				DeviceStatus = DVI_Device;
+				return DeviceStatus;
+			}
+			status = 1;
+		} else
+			DEBUG_MSG(KERN_INFO "DVI De-attached...\n");
+	}
+
+	if ((DeviceStatus != CRT_Device) && (status == 0)) {
+		CRT_ON = 1;
+		DVI_ON = 0;
+		LCD_ON = 0;
+
+		DeviceStatus = CRT_Device;
+		return DeviceStatus;
+	}
+
+	return 0;
+}
--- /dev/null
+++ b/drivers/video/viafb/ioctl.h
@@ -0,0 +1,212 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __IOCTL_H__
+#define __IOCTL_H__
+
+#ifndef __user
+#define __user
+#endif
+
+/* VIAFB IOCTL definition */
+#define VIAFB_GET_INFO_SIZE		0x56494101	/* 'VIA\01' */
+#define VIAFB_GET_INFO			0x56494102	/* 'VIA\02' */
+#define VIAFB_HOTPLUG			0x56494103	/* 'VIA\03' */
+#define VIAFB_SET_HOTPLUG_FLAG		0x56494104	/* 'VIA\04' */
+#define VIAFB_GET_RESOLUTION		0x56494105	/* 'VIA\05' */
+#define VIAFB_GET_SAMM_INFO		0x56494107	/* 'VIA\07' */
+#define VIAFB_TURN_ON_OUTPUT_DEVICE     0x56494108	/* 'VIA\08' */
+#define VIAFB_TURN_OFF_OUTPUT_DEVICE    0x56494109	/* 'VIA\09' */
+#define VIAFB_SET_DEVICE		0x5649410A
+#define VIAFB_GET_DEVICE		0x5649410B
+#define VIAFB_GET_DRIVER_VERSION	0x56494112	/* 'VIA\12' */
+#define VIAFB_GET_CHIP_INFO		0x56494113	/* 'VIA\13' */
+#define VIAFB_SET_DEVICE_INFO           0x56494114
+#define VIAFB_GET_DEVICE_INFO           0x56494115
+
+#define VIAFB_GET_DEVICE_SUPPORT	0x56494118
+#define VIAFB_GET_DEVICE_CONNECT	0x56494119
+#define VIAFB_GET_PANEL_SUPPORT_EXPAND	0x5649411A
+#define VIAFB_GET_DRIVER_NAME		0x56494122
+#define VIAFB_GET_DEVICE_SUPPORT_STATE	0x56494123
+#define VIAFB_GET_GAMMA_LUT		0x56494124
+#define VIAFB_SET_GAMMA_LUT		0x56494125
+#define VIAFB_GET_GAMMA_SUPPORT_STATE	0x56494126
+#define VIAFB_SET_VIDEO_DEVICE		0x56494127
+#define VIAFB_GET_VIDEO_DEVICE		0x56494128
+#define VIAFB_SET_SECOND_MODE		0x56494129
+#define VIAFB_SYNC_SURFACE		0x56494130
+#define VIAFB_GET_DRIVER_CAPS		0x56494131
+#define VIAFB_GET_IGA_SCALING_INFO	0x56494132
+#define VIAFB_GET_PANEL_MAX_SIZE	0x56494133
+#define VIAFB_GET_PANEL_MAX_POSITION	0x56494134
+#define VIAFB_SET_PANEL_SIZE		0x56494135
+#define VIAFB_SET_PANEL_POSITION        0x56494136
+#define VIAFB_GET_PANEL_POSITION        0x56494137
+#define VIAFB_GET_PANEL_SIZE		0x56494138
+
+#define None_Device 0x00
+#define CRT_Device  0x01
+#define LCD_Device  0x02
+#define DVI_Device  0x08
+#define CRT2_Device 0x10
+#define LCD2_Device 0x40
+
+#define OP_LCD_CENTERING   0x01
+#define OP_LCD_PANEL_ID    0x02
+#define OP_LCD_MODE        0x03
+
+/*SAMM operation flag*/
+#define OP_SAMM            0x80
+
+#define LCD_PANEL_ID_MAXIMUM	22
+
+#define STATE_ON            0x1
+#define STATE_OFF           0x0
+#define STATE_DEFAULT       0xFFFF
+
+#define MAX_ACTIVE_DEV_NUM  2
+
+struct device_t {
+	unsigned short crt:1;
+	unsigned short dvi:1;
+	unsigned short lcd:1;
+	unsigned short samm:1;
+	unsigned short primary_dev;
+
+	unsigned short lcd_dsp_cent:1;
+	unsigned char lcd_panel_id;
+	unsigned char lcd_mode:1;
+
+	unsigned short xres, yres;
+	unsigned short xres1, yres1;
+	unsigned short refresh;
+	unsigned short bpp;
+	unsigned short refresh1;
+	unsigned short bpp1;
+	unsigned short sequence;
+
+	unsigned short epia_dvi:1;
+	unsigned short lcd_dual_edge:1;
+	unsigned short bus_width;
+	unsigned short lcd2:1;
+};
+
+struct viafb_ioctl_info {
+	u32 viafb_id;		/* for identifying viafb */
+#define VIAID       0x56494146	/* Identify myself with 'VIAF' */
+	u16 vendor_id;
+	u16 device_id;
+	u8 version;
+	u8 revision;
+	u8 reserved[246];	/* for future use */
+};
+
+struct viafb_ioctl_mode {
+	u32 xres;
+	u32 yres;
+	u32 refresh;
+	u32 bpp;
+	u32 xres_sec;
+	u32 yres_sec;
+	u32 virtual_xres_sec;
+	u32 virtual_yres_sec;
+	u32 refresh_sec;
+	u32 bpp_sec;
+};
+struct viafb_ioctl_samm {
+	u32 samm_status;
+	u32 size_prim;
+	u32 size_sec;
+	u32 mem_base;
+	u32 offset_sec;
+};
+
+struct viafb_driver_version {
+	int iMajorNum;
+	int iKernelNum;
+	int iOSNum;
+	int iMinorNum;
+};
+
+struct viafb_ioctl_lcd_attribute {
+	unsigned int panel_id;
+	unsigned int display_center;
+	unsigned int lcd_mode;
+};
+
+struct viafb_ioctl_setting {
+	/* Enable or disable active devices */
+	unsigned short device_flag;
+	/* Indicate which device should be turn on or turn off. */
+	unsigned short device_status;
+	unsigned int reserved;
+	/* Indicate which LCD's attribute can be changed. */
+	unsigned short lcd_operation_flag;
+	/* 1: SAMM ON  0: SAMM OFF */
+	unsigned short samm_status;
+	/* horizontal resolution of first device */
+	unsigned short first_dev_hor_res;
+	/* vertical resolution of first device */
+	unsigned short first_dev_ver_res;
+	/* horizontal resolution of second device */
+	unsigned short second_dev_hor_res;
+	/* vertical resolution of second device */
+	unsigned short second_dev_ver_res;
+	/* refresh rate of first device */
+	unsigned short first_dev_refresh;
+	/* bpp of first device */
+	unsigned short first_dev_bpp;
+	/* refresh rate of second device */
+	unsigned short second_dev_refresh;
+	/* bpp of second device */
+	unsigned short second_dev_bpp;
+	/* Indicate which device are primary display device. */
+	unsigned int primary_device;
+	/* Indicate which device will show video. only valid in duoview mode */
+	unsigned int video_device_status;
+	unsigned int struct_reserved[34];
+	struct viafb_ioctl_lcd_attribute lcd_attributes;
+};
+
+struct _UTFunctionCaps {
+	unsigned int dw3DScalingState;
+	unsigned int reserved[31];
+};
+
+struct _POSITIONVALUE {
+	unsigned int dwX;
+	unsigned int dwY;
+};
+
+struct _panel_size_pos_info {
+	unsigned int device_type;
+	int x;
+	int y;
+};
+
+extern int LCD_ON;
+extern int DVI_ON;
+
+int ioctl_get_viafb_info(u_long arg);
+int ioctl_hotplug(int hres, int vres, int bpp);
+
+#endif /* __IOCTL_H__ */
--- /dev/null
+++ b/drivers/video/viafb/lcd.c
@@ -0,0 +1,2307 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+#include "share.h"
+
+/* CLE266 Software Power Sequence */
+/* {Mask}, {Data}, {Delay} */
+int PowerSequenceOn[3][3] =
+    { {0x10, 0x08, 0x06}, {0x10, 0x08, 0x06}, {0x19, 0x1FE, 0x01} };
+int PowerSequenceOff[3][3] =
+    { {0x06, 0x08, 0x10}, {0x00, 0x00, 0x00}, {0xD2, 0x19, 0x01} };
+
+/* ++++++ P880 ++++++ */
+/*   Panel 1600x1200   */
+struct io_reg P880_LCD_RES_6X4_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x73}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x73}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x5A}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x5E},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xD6}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR44, 0xFF, 0x7D}, {VIASR, SR45, 0xFF, 0x8C},
+	{VIASR, SR46, 0xFF, 0x02}
+
+};
+
+#define NUM_TOTAL_P880_LCD_RES_6X4_16X12 ARRAY_SIZE(P880_LCD_RES_6X4_16X12)
+
+struct io_reg P880_LCD_RES_7X4_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x67}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x67}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x74}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x78},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xF5}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR44, 0xFF, 0x78}, {VIASR, SR45, 0xFF, 0x8C},
+	{VIASR, SR46, 0xFF, 0x01}
+
+};
+
+#define NUM_TOTAL_P880_LCD_RES_7X4_16X12 ARRAY_SIZE(P880_LCD_RES_7X4_16X12)
+
+struct io_reg P880_LCD_RES_8X6_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x65}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x65}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xE1}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR44, 0xFF, 0x6D}, {VIASR, SR45, 0xFF, 0x88},
+	{VIASR, SR46, 0xFF, 0x03}
+
+};
+
+#define NUM_TOTAL_P880_LCD_RES_8X6_16X12 ARRAY_SIZE(P880_LCD_RES_8X6_16X12)
+
+struct io_reg P880_LCD_RES_10X7_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x65}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x65}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0xAB}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xAF},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xF0}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR44, 0xFF, 0x92}, {VIASR, SR45, 0xFF, 0x88},
+	{VIASR, SR46, 0xFF, 0x03}
+
+};
+
+#define NUM_TOTAL_P880_LCD_RES_10X7_16X12 ARRAY_SIZE(P880_LCD_RES_10X7_16X12)
+
+struct io_reg P880_LCD_RES_12X10_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x7D}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x7D}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0xD0}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xD4},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xFA}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR44, 0xFF, 0xF6}, {VIASR, SR45, 0xFF, 0x88},
+	{VIASR, SR46, 0xFF, 0x05}
+
+};
+
+#define NUM_TOTAL_P880_LCD_RES_12X10_16X12 ARRAY_SIZE(P880_LCD_RES_12X10_16X12)
+
+/*   Panel 1400x1050   */
+struct io_reg P880_LCD_RES_6X4_14X10[] = {
+	/* 640x480                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x5F}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x63},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xB4}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR44, 0xFF, 0xC6}, {VIASR, SR45, 0xFF, 0x8C},
+	{VIASR, SR46, 0xFF, 0x05}
+};
+
+#define NUM_TOTAL_P880_LCD_RES_6X4_14X10 ARRAY_SIZE(P880_LCD_RES_6X4_14X10)
+
+struct io_reg P880_LCD_RES_8X6_14X10[] = {
+	/* 800x600                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xBE}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR44, 0xFF, 0x06}, {VIASR, SR45, 0xFF, 0x8D},
+	{VIASR, SR46, 0xFF, 0x05}
+};
+
+#define NUM_TOTAL_P880_LCD_RES_8X6_14X10 ARRAY_SIZE(P880_LCD_RES_8X6_14X10)
+
+/* ++++++ K400 ++++++ */
+/*   Panel 1600x1200   */
+struct io_reg K400_LCD_RES_6X4_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x73}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x73}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x5A}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x5E},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xDA}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0xC4}, {VIASR, SR47, 0xFF, 0x7F}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_16X12 ARRAY_SIZE(K400_LCD_RES_6X4_16X12)
+
+struct io_reg K400_LCD_RES_7X4_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x67}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x67}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x74}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x78},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xF5}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x46}, {VIASR, SR47, 0xFF, 0x3D}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_7X4_16X12 ARRAY_SIZE(K400_LCD_RES_7X4_16X12)
+
+struct io_reg K400_LCD_RES_8X6_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x65}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x65}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xE1}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x85}, {VIASR, SR47, 0xFF, 0x6F}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_8X6_16X12 ARRAY_SIZE(K400_LCD_RES_8X6_16X12)
+
+struct io_reg K400_LCD_RES_10X7_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x65}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x65}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0xAB}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xAF},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xF0}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x45}, {VIASR, SR47, 0xFF, 0x4A}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_10X7_16X12 ARRAY_SIZE(K400_LCD_RES_10X7_16X12)
+
+struct io_reg K400_LCD_RES_12X10_16X12[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x7D}, {VIACR, CR55, 0x0F, 0x08},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x7D}, {VIACR, CR54, 0x38, 0x00},
+	{VIACR, CR5D, 0x40, 0x40},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0xD0}, {VIACR, CR71, 0x08, 0x00},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xD4},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xFA}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x47}, {VIASR, SR47, 0xFF, 0x7C}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_12X10_16X12 ARRAY_SIZE(K400_LCD_RES_12X10_16X12)
+
+/*   Panel 1400x1050   */
+struct io_reg K400_LCD_RES_6X4_14X10[] = {
+	/* 640x400                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x5F}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x63},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xB4}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x07}, {VIASR, SR47, 0xFF, 0x19}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_14X10 ARRAY_SIZE(K400_LCD_RES_6X4_14X10)
+
+struct io_reg K400_LCD_RES_8X6_14X10[] = {
+	/* 800x600                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xBE}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x07}, {VIASR, SR47, 0xFF, 0x21}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_8X6_14X10 ARRAY_SIZE(K400_LCD_RES_8X6_14X10)
+
+struct io_reg K400_LCD_RES_10X7_14X10[] = {
+	/* 1024x768                         */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0xA3}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xA7},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xC3}, {VIACR, CR67, 0x03, 0x04},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x05}, {VIASR, SR47, 0xFF, 0x1E}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_10X7_14X10 ARRAY_SIZE(K400_LCD_RES_10X7_14X10)
+
+struct io_reg K400_LCD_RES_12X10_14X10[] = {
+	/* 1280x768, 1280x960, 1280x1024    */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x97}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x97}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0xCE}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xD2},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xC9}, {VIACR, CR67, 0x03, 0x04},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x84}, {VIASR, SR47, 0xFF, 0x79}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_12X10_14X10 ARRAY_SIZE(K400_LCD_RES_12X10_14X10)
+
+/* ++++++ K400 ++++++ */
+/*   Panel 1366x768   */
+struct io_reg K400_LCD_RES_6X4_1366X7[] = {
+	/* 640x400                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x47}, {VIACR, CR55, 0x0F, 0x35},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x47}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x60}, {VIACR, CR71, 0x08, 0x23},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x64},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0x8C}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x87}, {VIASR, SR47, 0xFF, 0x4C}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_1366X7 ARRAY_SIZE(K400_LCD_RES_6X4_1366X7)
+
+struct io_reg K400_LCD_RES_7X4_1366X7[] = {
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x3B}, {VIACR, CR55, 0x0F, 0x35},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x3B}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x71}, {VIACR, CR71, 0x08, 0x23},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x75},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0x96}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x05}, {VIASR, SR47, 0xFF, 0x10}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_7X4_1366X7 ARRAY_SIZE(K400_LCD_RES_7X4_1366X7)
+
+struct io_reg K400_LCD_RES_8X6_1366X7[] = {
+	/* 800x600                          */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x37}, {VIACR, CR55, 0x0F, 0x35},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x37}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0x7E}, {VIACR, CR71, 0x08, 0x23},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x82},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0x8C}, {VIACR, CR67, 0x03, 0x00},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x84}, {VIASR, SR47, 0xFF, 0xB9}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_8X6_1366X7 ARRAY_SIZE(K400_LCD_RES_8X6_1366X7)
+
+struct io_reg K400_LCD_RES_10X7_1366X7[] = {
+	/* 1024x768                         */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0xA3}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xA7},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xC3}, {VIACR, CR67, 0x03, 0x04},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x05}, {VIASR, SR47, 0xFF, 0x1E}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_10X7_1366X7 ARRAY_SIZE(K400_LCD_RES_10X7_1366X7)
+
+struct io_reg K400_LCD_RES_12X10_1366X7[] = {
+	/* 1280x768, 1280x960, 1280x1024    */
+	/* IGA2 Horizontal Total            */
+	{VIACR, CR50, 0xFF, 0x97}, {VIACR, CR55, 0x0F, 0x56},
+	/* IGA2 Horizontal Blank End        */
+	{VIACR, CR53, 0xFF, 0x97}, {VIACR, CR54, 0x38, 0x75},
+	{VIACR, CR5D, 0x40, 0x24},
+	/* IGA2 Horizontal Total Shadow     */
+	{VIACR, CR6D, 0xFF, 0xCE}, {VIACR, CR71, 0x08, 0x44},
+	/* IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xD2},
+	/* IGA2 Offset                      */
+	{VIACR, CR66, 0xFF, 0xC9}, {VIACR, CR67, 0x03, 0x04},
+	/* VCLK                             */
+	{VIASR, SR46, 0xFF, 0x84}, {VIASR, SR47, 0xFF, 0x79}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_12X10_1366X7\
+			ARRAY_SIZE(K400_LCD_RES_12X10_1366X7)
+
+/* ++++++ K400 ++++++ */
+/*   Panel 1280x1024   */
+struct io_reg K400_LCD_RES_6X4_12X10[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x46},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x74},
+	{VIACR, CR5D, 0x40, 0x1C},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x5F}, {VIACR, CR71, 0x08, 0x34},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x63},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xAA}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x07}, {VIASR, SR47, 0xFF, 0x19}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_12X10 ARRAY_SIZE(K400_LCD_RES_6X4_12X10)
+
+struct io_reg K400_LCD_RES_7X4_12X10[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x46},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x74},
+	{VIACR, CR5D, 0x40, 0x1C},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x68}, {VIACR, CR71, 0x08, 0x34},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x6C},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xA8}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x87}, {VIASR, SR47, 0xFF, 0xED}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_7X4_12X10 ARRAY_SIZE(K400_LCD_RES_7X4_12X10)
+
+struct io_reg K400_LCD_RES_8X6_12X10[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x46},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x74},
+	{VIACR, CR5D, 0x40, 0x1C},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x34},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xBE}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x07}, {VIASR, SR47, 0xFF, 0x21}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_8X6_12X10 ARRAY_SIZE(K400_LCD_RES_8X6_12X10)
+
+struct io_reg K400_LCD_RES_10X7_12X10[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x9D}, {VIACR, CR55, 0x0F, 0x46},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x9D}, {VIACR, CR54, 0x38, 0x74},
+	{VIACR, CR5D, 0x40, 0x1C},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0xA3}, {VIACR, CR71, 0x08, 0x34},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0xA7},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0xBE}, {VIACR, CR67, 0x03, 0x04},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x05}, {VIASR, SR47, 0xFF, 0x1E}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_10X7_12X10 ARRAY_SIZE(K400_LCD_RES_10X7_12X10)
+
+/* ++++++ K400 ++++++ */
+/*   Panel 1024x768    */
+struct io_reg K400_LCD_RES_6X4_10X7[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x47}, {VIACR, CR55, 0x0F, 0x35},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x47}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x60}, {VIACR, CR71, 0x08, 0x23},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x64},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0x8C}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x87}, {VIASR, SR47, 0xFF, 0x4C}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_10X7 ARRAY_SIZE(K400_LCD_RES_6X4_10X7)
+
+struct io_reg K400_LCD_RES_7X4_10X7[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x3B}, {VIACR, CR55, 0x0F, 0x35},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x3B}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x71}, {VIACR, CR71, 0x08, 0x23},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x75},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0x96}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x05}, {VIASR, SR47, 0xFF, 0x10}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_7X4_10X7 ARRAY_SIZE(K400_LCD_RES_7X4_10X7)
+
+struct io_reg K400_LCD_RES_8X6_10X7[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x37}, {VIACR, CR55, 0x0F, 0x35},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x37}, {VIACR, CR54, 0x38, 0x2B},
+	{VIACR, CR5D, 0x40, 0x13},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x7E}, {VIACR, CR71, 0x08, 0x23},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x82},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0x8C}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x84}, {VIASR, SR47, 0xFF, 0xB9}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_8X6_10X7 ARRAY_SIZE(K400_LCD_RES_8X6_10X7)
+
+/* ++++++ K400 ++++++ */
+/*   Panel 800x600     */
+struct io_reg K400_LCD_RES_6X4_8X6[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x1A}, {VIACR, CR55, 0x0F, 0x34},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x1A}, {VIACR, CR54, 0x38, 0xE3},
+	{VIACR, CR5D, 0x40, 0x12},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x5F}, {VIACR, CR71, 0x08, 0x22},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x63},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0x6E}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0x86}, {VIASR, SR47, 0xFF, 0xB3}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_6X4_8X6 ARRAY_SIZE(K400_LCD_RES_6X4_8X6)
+
+struct io_reg K400_LCD_RES_7X4_8X6[] = {
+	/*IGA2 Horizontal Total */
+	{VIACR, CR50, 0xFF, 0x1F}, {VIACR, CR55, 0x0F, 0x34},
+	/*IGA2 Horizontal Blank End */
+	{VIACR, CR53, 0xFF, 0x1F}, {VIACR, CR54, 0x38, 0xE3},
+	{VIACR, CR5D, 0x40, 0x12},
+	/*IGA2 Horizontal Total Shadow */
+	{VIACR, CR6D, 0xFF, 0x7F}, {VIACR, CR71, 0x08, 0x22},
+	/*IGA2 Horizontal Blank End Shadow */
+	{VIACR, CR6E, 0xFF, 0x83},
+	/*IGA2 Offset */
+	{VIACR, CR66, 0xFF, 0x78}, {VIACR, CR67, 0x03, 0x00},
+	 /*VCLK*/ {VIASR, SR46, 0xFF, 0xC4}, {VIASR, SR47, 0xFF, 0x59}
+};
+
+#define NUM_TOTAL_K400_LCD_RES_7X4_8X6 ARRAY_SIZE(K400_LCD_RES_7X4_8X6)
+
+struct iga2_shadow_crtc_timing iga2_shadow_crtc_reg = {
+	/* IGA2 Shadow Horizontal Total */
+	{IGA2_SHADOW_HOR_TOTAL_REG_NUM, {{CR6D, 0, 7}, {CR71, 3, 3} } },
+	/* IGA2 Shadow Horizontal Blank End */
+	{IGA2_SHADOW_HOR_BLANK_END_REG_NUM, {{CR6E, 0, 7} } },
+	/* IGA2 Shadow Vertical Total */
+	{IGA2_SHADOW_VER_TOTAL_REG_NUM, {{CR6F, 0, 7}, {CR71, 0, 2} } },
+	/* IGA2 Shadow Vertical Addressable Video */
+	{IGA2_SHADOW_VER_ADDR_REG_NUM, {{CR70, 0, 7}, {CR71, 4, 6} } },
+	/* IGA2 Shadow Vertical Blank Start */
+	{IGA2_SHADOW_VER_BLANK_START_REG_NUM,
+	 {{CR72, 0, 7}, {CR74, 4, 6} } },
+	/* IGA2 Shadow Vertical Blank End */
+	{IGA2_SHADOW_VER_BLANK_END_REG_NUM, {{CR73, 0, 7}, {CR74, 0, 2} } },
+	/* IGA2 Shadow Vertical Sync Start */
+	{IGA2_SHADOW_VER_SYNC_START_REG_NUM, {{CR75, 0, 7}, {CR76, 4, 6} } },
+	/* IGA2 Shadow Vertical Sync End */
+	{IGA2_SHADOW_VER_SYNC_END_REG_NUM, {{CR76, 0, 3} } }
+};
+
+struct _lcd_scaling_factor lcd_scaling_factor = {
+	/* LCD Horizontal Scaling Factor Register */
+	{LCD_HOR_SCALING_FACTOR_REG_NUM,
+	 {{CR9F, 0, 1}, {CR77, 0, 7}, {CR79, 4, 5} } },
+	/* LCD Vertical Scaling Factor Register */
+	{LCD_VER_SCALING_FACTOR_REG_NUM,
+	 {{CR79, 3, 3}, {CR78, 0, 7}, {CR79, 6, 7} } }
+};
+struct _lcd_scaling_factor lcd_scaling_factor_CLE = {
+	/* LCD Horizontal Scaling Factor Register */
+	{LCD_HOR_SCALING_FACTOR_REG_NUM_CLE, {{CR77, 0, 7}, {CR79, 4, 5} } },
+	/* LCD Vertical Scaling Factor Register */
+	{LCD_VER_SCALING_FACTOR_REG_NUM_CLE, {{CR78, 0, 7}, {CR79, 6, 7} } }
+};
+
+int check_lvds_chip(int device_id_subaddr, int device_id)
+{
+	if (lvds_register_read(device_id_subaddr) == device_id)
+		return (OK);
+	else
+		return (FAIL);
+}
+
+void init_lcd_size(void)
+{
+	DEBUG_MSG(KERN_INFO "init_lcd_size()\n");
+	DEBUG_MSG(KERN_INFO "lvds_setting_info.get_lcd_size_method %d\n",
+		  lvds_setting_info.get_lcd_size_method);
+
+	switch (lvds_setting_info.get_lcd_size_method) {
+	case GET_LCD_SIZE_BY_SYSTEM_BIOS:
+		break;
+	case GET_LCD_SZIE_BY_HW_STRAPPING:
+		break;
+	case GET_LCD_SIZE_BY_VGA_BIOS:
+		DEBUG_MSG(KERN_INFO "Get LCD Size method by VGA BIOS !!\n");
+		lvds_setting_info.lcd_panel_size =
+		    fp_id_to_vindex(lcd_panel_id);
+		DEBUG_MSG(KERN_INFO "LCD Panel_ID = %d\n",
+			  lvds_setting_info.lcd_panel_id);
+		DEBUG_MSG(KERN_INFO "LCD Panel Size = %d\n",
+			  lvds_setting_info.lcd_panel_size);
+		break;
+	case GET_LCD_SIZE_BY_USER_SETTING:
+		DEBUG_MSG(KERN_INFO "Get LCD Size method by user setting !!\n");
+		lvds_setting_info.lcd_panel_size =
+		    fp_id_to_vindex(lcd_panel_id);
+		DEBUG_MSG(KERN_INFO "LCD Panel_ID = %d\n",
+			  lvds_setting_info.lcd_panel_id);
+		DEBUG_MSG(KERN_INFO "LCD Panel Size = %d\n",
+			  lvds_setting_info.lcd_panel_size);
+		break;
+	default:
+		DEBUG_MSG(KERN_INFO "init_lcd_size fail\n");
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID1_800X600;
+		lvds_setting_info.lcd_panel_size =
+		    fp_id_to_vindex(LCD_PANEL_ID1_800X600);
+	}
+	lvds_setting_info2.lcd_panel_id = lvds_setting_info.lcd_panel_id;
+	lvds_setting_info2.lcd_panel_size = lvds_setting_info.lcd_panel_size;
+	lvds_setting_info2.lcd_panel_hres = lvds_setting_info.lcd_panel_hres;
+	lvds_setting_info2.lcd_panel_vres = lvds_setting_info.lcd_panel_vres;
+	lvds_setting_info2.device_lcd_dualedge =
+	    lvds_setting_info.device_lcd_dualedge;
+	lvds_setting_info2.LCDDithering = lvds_setting_info.LCDDithering;
+}
+
+bool lvds_identify_integratedlvds(void)
+{
+	if (display_hardware_layout == HW_LAYOUT_LCD_EXTERNAL_LCD2) {
+		/* Two dual channel LCD (Internal LVDS + External LVDS): */
+		/* If we have an external LVDS, such as VT1636, we should
+		   have its chip ID already. */
+		if (chip_info.lvds_chip_info.lvds_chip_name) {
+			chip_info.lvds_chip_info2.lvds_chip_name =
+			    INTEGRATED_LVDS;
+			DEBUG_MSG(KERN_INFO "Support two dual channel LVDS!\
+				  (Internal LVDS + External LVDS)\n");
+		} else {
+			chip_info.lvds_chip_info.lvds_chip_name =
+			    INTEGRATED_LVDS;
+			DEBUG_MSG(KERN_INFO "Not found external LVDS,\
+				  so can't support two dual channel LVDS!\n");
+		}
+	} else if (display_hardware_layout == HW_LAYOUT_LCD1_LCD2) {
+		/* Two single channel LCD (Internal LVDS + Internal LVDS): */
+		chip_info.lvds_chip_info.lvds_chip_name = INTEGRATED_LVDS;
+		chip_info.lvds_chip_info2.lvds_chip_name = INTEGRATED_LVDS;
+		DEBUG_MSG(KERN_INFO "Support two single channel LVDS!\
+			  (Internal LVDS + Internal LVDS)\n");
+	} else if (display_hardware_layout != HW_LAYOUT_DVI_ONLY) {
+		/* If we have found external LVDS, just use it,
+		   otherwise, we will use internal LVDS as default. */
+		if (!chip_info.lvds_chip_info.lvds_chip_name) {
+			chip_info.lvds_chip_info.lvds_chip_name =
+			    INTEGRATED_LVDS;
+			DEBUG_MSG(KERN_INFO "Found Integrated LVDS!\n");
+		}
+	} else {
+		chip_info.lvds_chip_info.lvds_chip_name = NON_LVDS_TRANSMITTER;
+		DEBUG_MSG(KERN_INFO "Do not support LVDS!\n");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+int lvds_trasmitter_identify(void)
+{
+	u8 tmp;
+	tmp = chip_info.chip_on_slot;
+	chip_info.chip_on_slot = PORT_ON_AMR;
+	if (lvds_identify_vt1636()) {
+		chip_info.lvds_chip_info.i2c_port = I2CPORTINDEX;
+		DEBUG_MSG(KERN_INFO
+			  "Found VIA VT1636 LVDS on port i2c 0x31 \n");
+	} else {
+		chip_info.chip_on_slot = PORT_ON_AGP;
+		if (lvds_identify_vt1636()) {
+			chip_info.lvds_chip_info.i2c_port = GPIOPORTINDEX;
+			DEBUG_MSG(KERN_INFO
+				  "Found VIA VT1636 LVDS on port gpio 0x2c \n");
+		}
+	}
+	chip_info.chip_on_slot = tmp;
+
+	if (chip_info.gfx_chip_name == UNICHROME_CX700)
+		lvds_identify_integratedlvds();
+
+	if (chip_info.lvds_chip_info.lvds_chip_name)
+		return TRUE;
+	/* Check for VT1631: */
+	chip_info.lvds_chip_info.lvds_chip_name = VT1631_LVDS;
+	chip_info.lvds_chip_info.lvds_chip_slave_addr = VT1631_LVDS_I2C_ADDR;
+
+	if (check_lvds_chip(VT1631_DEVICE_ID_REG, VT1631_DEVICE_ID) != FAIL) {
+		DEBUG_MSG(KERN_INFO "\n VT1631 LVDS ! \n");
+		DEBUG_MSG(KERN_INFO "\n %2d",
+			  chip_info.lvds_chip_info.lvds_chip_name);
+		DEBUG_MSG(KERN_INFO "\n %2d",
+			  chip_info.lvds_chip_info.lvds_chip_name);
+		return (OK);
+	}
+
+	chip_info.lvds_chip_info.lvds_chip_name = NON_LVDS_TRANSMITTER;
+	chip_info.lvds_chip_info.lvds_chip_slave_addr = VT1631_LVDS_I2C_ADDR;
+	return (FAIL);
+}
+
+int fp_id_to_vindex(int panel_id)
+{
+	DEBUG_MSG(KERN_INFO "fp_get_panel_id()\n");
+
+	if (panel_id > LCD_PANEL_ID_MAXIMUM)
+		lcd_panel_id = panel_id = read_reg(VIACR, CR3F) & 0x0F;
+
+	switch (panel_id) {
+	case 0x0:
+		lvds_setting_info.lcd_panel_hres = 640;
+		lvds_setting_info.lcd_panel_vres = 480;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID0_640X480;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_640X480);
+		break;
+	case 0x1:
+		lvds_setting_info.lcd_panel_hres = 800;
+		lvds_setting_info.lcd_panel_vres = 600;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID1_800X600;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_800X600);
+		break;
+	case 0x2:
+		lvds_setting_info.lcd_panel_hres = 1024;
+		lvds_setting_info.lcd_panel_vres = 768;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID2_1024X768;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_1024X768);
+		break;
+	case 0x3:
+		lvds_setting_info.lcd_panel_hres = 1280;
+		lvds_setting_info.lcd_panel_vres = 768;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID3_1280X768;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_1280X768);
+		break;
+	case 0x4:
+		lvds_setting_info.lcd_panel_hres = 1280;
+		lvds_setting_info.lcd_panel_vres = 1024;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID4_1280X1024;
+		lvds_setting_info.device_lcd_dualedge = 1;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_1280X1024);
+		break;
+	case 0x5:
+		lvds_setting_info.lcd_panel_hres = 1400;
+		lvds_setting_info.lcd_panel_vres = 1050;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID5_1400X1050;
+		lvds_setting_info.device_lcd_dualedge = 1;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_1400X1050);
+		break;
+	case 0x6:
+		lvds_setting_info.lcd_panel_hres = 1600;
+		lvds_setting_info.lcd_panel_vres = 1200;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID6_1600X1200;
+		lvds_setting_info.device_lcd_dualedge = 1;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_1600X1200);
+		break;
+	case 0x8:
+		lvds_setting_info.lcd_panel_hres = 800;
+		lvds_setting_info.lcd_panel_vres = 480;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_IDA_800X480;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_800X480);
+		break;
+	case 0x9:
+		lvds_setting_info.lcd_panel_hres = 1024;
+		lvds_setting_info.lcd_panel_vres = 768;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID2_1024X768;
+		lvds_setting_info.device_lcd_dualedge = 1;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_1024X768);
+		break;
+	case 0xA:
+		lvds_setting_info.lcd_panel_hres = 1024;
+		lvds_setting_info.lcd_panel_vres = 768;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID2_1024X768;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 0;
+		return (VIA_RES_1024X768);
+		break;
+	case 0xB:
+		lvds_setting_info.lcd_panel_hres = 1024;
+		lvds_setting_info.lcd_panel_vres = 768;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID2_1024X768;
+		lvds_setting_info.device_lcd_dualedge = 1;
+		lvds_setting_info.LCDDithering = 0;
+		return (VIA_RES_1024X768);
+		break;
+	case 0xC:
+		lvds_setting_info.lcd_panel_hres = 1280;
+		lvds_setting_info.lcd_panel_vres = 768;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID3_1280X768;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 0;
+		return (VIA_RES_1280X768);
+		break;
+	case 0xD:
+		lvds_setting_info.lcd_panel_hres = 1280;
+		lvds_setting_info.lcd_panel_vres = 1024;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID4_1280X1024;
+		lvds_setting_info.device_lcd_dualedge = 1;
+		lvds_setting_info.LCDDithering = 0;
+		return (VIA_RES_1280X1024);
+		break;
+	case 0xE:
+		lvds_setting_info.lcd_panel_hres = 1400;
+		lvds_setting_info.lcd_panel_vres = 1050;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID5_1400X1050;
+		lvds_setting_info.device_lcd_dualedge = 1;
+		lvds_setting_info.LCDDithering = 0;
+		return (VIA_RES_1400X1050);
+		break;
+	case 0xF:
+		lvds_setting_info.lcd_panel_hres = 1600;
+		lvds_setting_info.lcd_panel_vres = 1200;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID6_1600X1200;
+		lvds_setting_info.device_lcd_dualedge = 1;
+		lvds_setting_info.LCDDithering = 0;
+		return (VIA_RES_1600X1200);
+		break;
+	case 0x10:
+		lvds_setting_info.lcd_panel_hres = 1366;
+		lvds_setting_info.lcd_panel_vres = 768;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID7_1366X768;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 0;
+		return (VIA_RES_1368X768);
+		break;
+	case 0x11:
+		lvds_setting_info.lcd_panel_hres = 1024;
+		lvds_setting_info.lcd_panel_vres = 600;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID8_1024X600;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_1024X600);
+		break;
+	case 0x12:
+		lvds_setting_info.lcd_panel_hres = 1280;
+		lvds_setting_info.lcd_panel_vres = 768;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID3_1280X768;
+		lvds_setting_info.device_lcd_dualedge = 1;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_1280X768);
+		break;
+	case 0x13:
+		lvds_setting_info.lcd_panel_hres = 1280;
+		lvds_setting_info.lcd_panel_vres = 800;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID9_1280X800;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_1280X800);
+		break;
+	case 0x14:
+		lvds_setting_info.lcd_panel_hres = 1360;
+		lvds_setting_info.lcd_panel_vres = 768;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_IDB_1360X768;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 0;
+		return (VIA_RES_1360X768);
+		break;
+	case 0x15:
+		lvds_setting_info.lcd_panel_hres = 1280;
+		lvds_setting_info.lcd_panel_vres = 768;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID3_1280X768;
+		lvds_setting_info.device_lcd_dualedge = 1;
+		lvds_setting_info.LCDDithering = 0;
+		return (VIA_RES_1280X768);
+		break;
+	case 0x16:
+		lvds_setting_info.lcd_panel_hres = 480;
+		lvds_setting_info.lcd_panel_vres = 640;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_IDC_480X640;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_480X640);
+		break;
+	default:
+		lvds_setting_info.lcd_panel_hres = 800;
+		lvds_setting_info.lcd_panel_vres = 600;
+		lvds_setting_info.lcd_panel_id = LCD_PANEL_ID1_800X600;
+		lvds_setting_info.device_lcd_dualedge = 0;
+		lvds_setting_info.LCDDithering = 1;
+		return (VIA_RES_800X600);
+	}
+}
+
+void lvds_register_write(int index, u8 data)
+{
+	u8 tmp;
+
+	tmp = chip_info.chip_on_slot;
+
+	chip_info.chip_on_slot = PORT_ON_AGP;
+
+	i2cWriteByte(chip_info.lvds_chip_info.lvds_chip_slave_addr, index,
+		     data);
+
+	chip_info.chip_on_slot = tmp;
+
+}
+
+int lvds_register_read(int index)
+{
+	u8 data;
+	int status;
+	u8 tmp;
+
+	tmp = chip_info.chip_on_slot;
+
+	chip_info.chip_on_slot = PORT_ON_AGP;
+	status =
+	    i2cReadByte((u8) chip_info.lvds_chip_info.lvds_chip_slave_addr,
+			(u8) index, &data);
+
+	chip_info.chip_on_slot = tmp;
+	return (data);
+}
+
+void load_lcd_scaling(int set_hres, int set_vres, int panel_hres,
+		      int panel_vres)
+{
+	int reg_value = 0;
+	int load_reg_num;
+	struct io_register *reg = NULL;
+
+	DEBUG_MSG(KERN_INFO "load_lcd_scaling()!!\n");
+
+	/* LCD Scaling Enable */
+	write_reg_mask(CR79, VIACR, 0x07, BIT0 + BIT1 + BIT2);
+	if (UNICHROME_P4M900 == chip_info.gfx_chip_name) {
+		load_scaling_factor_for_p4m900(set_hres, set_vres,
+					       panel_hres, panel_vres);
+		return;
+	}
+
+	/* Check if expansion for horizontal */
+	if (set_hres != panel_hres) {
+		/* Load Horizontal Scaling Factor */
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			reg_value =
+			    CLE266_LCD_HOR_SCF_FORMULA(set_hres, panel_hres);
+			load_reg_num =
+			    lcd_scaling_factor_CLE.lcd_hor_scaling_factor.
+			    reg_num;
+			reg = lcd_scaling_factor_CLE.lcd_hor_scaling_factor.reg;
+			load_reg(reg_value, load_reg_num, reg, VIACR);
+			break;
+		case UNICHROME_K800:
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M890:
+			reg_value =
+			    K800_LCD_HOR_SCF_FORMULA(set_hres, panel_hres);
+			/* Horizontal scaling enabled */
+			write_reg_mask(CRA2, VIACR, 0xC0, BIT7 + BIT6);
+			load_reg_num =
+			    lcd_scaling_factor.lcd_hor_scaling_factor.reg_num;
+			reg = lcd_scaling_factor.lcd_hor_scaling_factor.reg;
+			load_reg(reg_value, load_reg_num, reg, VIACR);
+			break;
+		}
+
+		DEBUG_MSG(KERN_INFO "Horizontal Scaling value = %d", reg_value);
+	} else {
+		/* Horizontal scaling disabled */
+		write_reg_mask(CRA2, VIACR, 0x00, BIT7);
+	}
+
+	/* Check if expansion for vertical */
+	if (set_vres != panel_vres) {
+		/* Load Vertical Scaling Factor */
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			reg_value =
+			    CLE266_LCD_VER_SCF_FORMULA(set_vres, panel_vres);
+			load_reg_num =
+			    lcd_scaling_factor_CLE.lcd_ver_scaling_factor.
+			    reg_num;
+			reg = lcd_scaling_factor_CLE.lcd_ver_scaling_factor.reg;
+			load_reg(reg_value, load_reg_num, reg, VIACR);
+			break;
+		case UNICHROME_K800:
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M890:
+			reg_value =
+			    K800_LCD_VER_SCF_FORMULA(set_vres, panel_vres);
+			/* Vertical scaling enabled */
+			write_reg_mask(CRA2, VIACR, 0x08, BIT3);
+			load_reg_num =
+			    lcd_scaling_factor.lcd_ver_scaling_factor.reg_num;
+			reg = lcd_scaling_factor.lcd_ver_scaling_factor.reg;
+			load_reg(reg_value, load_reg_num, reg, VIACR);
+			break;
+		}
+
+		DEBUG_MSG(KERN_INFO "Vertical Scaling value = %d", reg_value);
+	} else {
+		/* Vertical scaling disabled */
+		write_reg_mask(CRA2, VIACR, 0x00, BIT3);
+	}
+}
+
+void load_lcd_k400_patch_tbl(int set_hres, int set_vres, int panel_id)
+{
+	int vmode_index;
+	int reg_num = 0;
+	struct io_reg *lcd_patch_reg = NULL;
+
+	if (lvds_setting_info.iga_path == IGA2)
+		vmode_index = get_mode_index(set_hres, set_vres, 1);
+	else
+		vmode_index = get_mode_index(set_hres, set_vres, 0);
+	switch (panel_id) {
+		/* LCD 800x600 */
+	case LCD_PANEL_ID1_800X600:
+		switch (vmode_index) {
+		case VIA_RES_640X400:
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_8X6;
+			lcd_patch_reg = K400_LCD_RES_6X4_8X6;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_K400_LCD_RES_7X4_8X6;
+			lcd_patch_reg = K400_LCD_RES_7X4_8X6;
+			break;
+		}
+		break;
+
+		/* LCD 1024x768 */
+	case LCD_PANEL_ID2_1024X768:
+		switch (vmode_index) {
+		case VIA_RES_640X400:
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_10X7;
+			lcd_patch_reg = K400_LCD_RES_6X4_10X7;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_K400_LCD_RES_7X4_10X7;
+			lcd_patch_reg = K400_LCD_RES_7X4_10X7;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_K400_LCD_RES_8X6_10X7;
+			lcd_patch_reg = K400_LCD_RES_8X6_10X7;
+			break;
+		}
+		break;
+
+		/* LCD 1280x1024 */
+	case LCD_PANEL_ID4_1280X1024:
+		switch (vmode_index) {
+		case VIA_RES_640X400:
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_12X10;
+			lcd_patch_reg = K400_LCD_RES_6X4_12X10;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_K400_LCD_RES_7X4_12X10;
+			lcd_patch_reg = K400_LCD_RES_7X4_12X10;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_K400_LCD_RES_8X6_12X10;
+			lcd_patch_reg = K400_LCD_RES_8X6_12X10;
+			break;
+		case VIA_RES_1024X768:
+			reg_num = NUM_TOTAL_K400_LCD_RES_10X7_12X10;
+			lcd_patch_reg = K400_LCD_RES_10X7_12X10;
+			break;
+
+		}
+		break;
+
+		/* LCD 1400x1050 */
+	case LCD_PANEL_ID5_1400X1050:
+		switch (vmode_index) {
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_14X10;
+			lcd_patch_reg = K400_LCD_RES_6X4_14X10;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_K400_LCD_RES_8X6_14X10;
+			lcd_patch_reg = K400_LCD_RES_8X6_14X10;
+			break;
+		case VIA_RES_1024X768:
+			reg_num = NUM_TOTAL_K400_LCD_RES_10X7_14X10;
+			lcd_patch_reg = K400_LCD_RES_10X7_14X10;
+			break;
+		case VIA_RES_1280X768:
+		case VIA_RES_1280X800:
+		case VIA_RES_1280X960:
+		case VIA_RES_1280X1024:
+			reg_num = NUM_TOTAL_K400_LCD_RES_12X10_14X10;
+			lcd_patch_reg = K400_LCD_RES_12X10_14X10;
+			break;
+		}
+		break;
+
+		/* LCD 1600x1200 */
+	case LCD_PANEL_ID6_1600X1200:
+		switch (vmode_index) {
+		case VIA_RES_640X400:
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_16X12;
+			lcd_patch_reg = K400_LCD_RES_6X4_16X12;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_K400_LCD_RES_7X4_16X12;
+			lcd_patch_reg = K400_LCD_RES_7X4_16X12;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_K400_LCD_RES_8X6_16X12;
+			lcd_patch_reg = K400_LCD_RES_8X6_16X12;
+			break;
+		case VIA_RES_1024X768:
+			reg_num = NUM_TOTAL_K400_LCD_RES_10X7_16X12;
+			lcd_patch_reg = K400_LCD_RES_10X7_16X12;
+			break;
+		case VIA_RES_1280X768:
+		case VIA_RES_1280X800:
+		case VIA_RES_1280X960:
+		case VIA_RES_1280X1024:
+			reg_num = NUM_TOTAL_K400_LCD_RES_12X10_16X12;
+			lcd_patch_reg = K400_LCD_RES_12X10_16X12;
+			break;
+		}
+		break;
+
+		/* LCD 1366x768 */
+	case LCD_PANEL_ID7_1366X768:
+		switch (vmode_index) {
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_K400_LCD_RES_6X4_1366X7;
+			lcd_patch_reg = K400_LCD_RES_6X4_1366X7;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_K400_LCD_RES_7X4_1366X7;
+			lcd_patch_reg = K400_LCD_RES_7X4_1366X7;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_K400_LCD_RES_8X6_1366X7;
+			lcd_patch_reg = K400_LCD_RES_8X6_1366X7;
+			break;
+		case VIA_RES_1024X768:
+			reg_num = NUM_TOTAL_K400_LCD_RES_10X7_1366X7;
+			lcd_patch_reg = K400_LCD_RES_10X7_1366X7;
+			break;
+		case VIA_RES_1280X768:
+		case VIA_RES_1280X800:
+		case VIA_RES_1280X960:
+		case VIA_RES_1280X1024:
+			reg_num = NUM_TOTAL_K400_LCD_RES_12X10_1366X7;
+			lcd_patch_reg = K400_LCD_RES_12X10_1366X7;
+			break;
+		}
+		break;
+
+		/* LCD 1360x768 */
+	case LCD_PANEL_IDB_1360X768:
+		break;
+	}
+	if (reg_num != 0) {
+		/* H.W. Reset : ON */
+		write_reg_mask(CR17, VIACR, 0x00, BIT7);
+
+		write_regx(lcd_patch_reg, reg_num);
+
+		/* H.W. Reset : OFF */
+		write_reg_mask(CR17, VIACR, 0x80, BIT7);
+
+		/* Reset PLL */
+		write_reg_mask(SR40, VIASR, 0x02, BIT1);
+		write_reg_mask(SR40, VIASR, 0x00, BIT1);
+
+		/* Fire! */
+		outb(inb(VIARMisc) | (BIT2 + BIT3), VIAWMisc);
+	}
+}
+
+void load_lcd_p880_patch_tbl(int set_hres, int set_vres, int panel_id)
+{
+	int vmode_index;
+	int reg_num = 0;
+	struct io_reg *lcd_patch_reg = NULL;
+
+	if (lvds_setting_info.iga_path == IGA2)
+		vmode_index = get_mode_index(set_hres, set_vres, 1);
+	else
+		vmode_index = get_mode_index(set_hres, set_vres, 0);
+
+	switch (panel_id) {
+	case LCD_PANEL_ID5_1400X1050:
+		switch (vmode_index) {
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_P880_LCD_RES_6X4_14X10;
+			lcd_patch_reg = P880_LCD_RES_6X4_14X10;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_P880_LCD_RES_8X6_14X10;
+			lcd_patch_reg = P880_LCD_RES_8X6_14X10;
+			break;
+		}
+		break;
+	case LCD_PANEL_ID6_1600X1200:
+		switch (vmode_index) {
+		case VIA_RES_640X400:
+		case VIA_RES_640X480:
+			reg_num = NUM_TOTAL_P880_LCD_RES_6X4_16X12;
+			lcd_patch_reg = P880_LCD_RES_6X4_16X12;
+			break;
+		case VIA_RES_720X480:
+		case VIA_RES_720X576:
+			reg_num = NUM_TOTAL_P880_LCD_RES_7X4_16X12;
+			lcd_patch_reg = P880_LCD_RES_7X4_16X12;
+			break;
+		case VIA_RES_800X600:
+			reg_num = NUM_TOTAL_P880_LCD_RES_8X6_16X12;
+			lcd_patch_reg = P880_LCD_RES_8X6_16X12;
+			break;
+		case VIA_RES_1024X768:
+			reg_num = NUM_TOTAL_P880_LCD_RES_10X7_16X12;
+			lcd_patch_reg = P880_LCD_RES_10X7_16X12;
+			break;
+		case VIA_RES_1280X768:
+		case VIA_RES_1280X960:
+		case VIA_RES_1280X1024:
+			reg_num = NUM_TOTAL_P880_LCD_RES_12X10_16X12;
+			lcd_patch_reg = P880_LCD_RES_12X10_16X12;
+			break;
+		}
+		break;
+
+	}
+	if (reg_num != 0) {
+		/* H.W. Reset : ON */
+		write_reg_mask(CR17, VIACR, 0x00, BIT7);
+
+		write_regx(lcd_patch_reg, reg_num);
+
+		/* H.W. Reset : OFF */
+		write_reg_mask(CR17, VIACR, 0x80, BIT7);
+
+		/* Reset PLL */
+		write_reg_mask(SR40, VIASR, 0x02, BIT1);
+		write_reg_mask(SR40, VIASR, 0x00, BIT1);
+
+		/* Fire! */
+		outb(inb(VIARMisc) | (BIT2 + BIT3), VIAWMisc);
+	}
+}
+
+void load_lcd_patch_regs(int set_hres, int set_vres, int panel_id, int set_iga)
+{
+	int vmode_index;
+
+	if (lvds_setting_info.iga_path == IGA2)
+		vmode_index = get_mode_index(set_hres, set_vres, 1);
+	else
+		vmode_index = get_mode_index(set_hres, set_vres, 0);
+
+	unlock_crt();
+
+	/* Patch for simultaneous & Expansion */
+	if ((set_iga == IGA1_IGA2)
+	    && (lvds_setting_info.display_method == LCD_EXPANDSION)) {
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			load_lcd_k400_patch_tbl(set_hres, set_vres, panel_id);
+			break;
+		case UNICHROME_K800:
+			break;
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+			load_lcd_p880_patch_tbl(set_hres, set_vres, panel_id);
+		}
+	}
+
+	lock_crt();
+}
+
+void via_pitch_alignment_patch_lcd(struct lvds_setting_information
+				   *plvds_setting_info,
+				   struct lvds_chip_information
+				   *plvds_chip_info)
+{
+	unsigned char cr13, cr35, cr65, cr66, cr67;
+	unsigned long dwScreenPitch = 0;
+	unsigned long dwPitch;
+
+	dwPitch = plvds_setting_info->h_active * (plvds_setting_info->bpp >> 3);
+	if (dwPitch & 0x1F) {
+		dwScreenPitch = ((dwPitch + 31) & ~31) >> 3;
+		if (plvds_setting_info->iga_path == IGA2) {
+			if (plvds_setting_info->bpp > 8) {
+				cr66 = (unsigned char)(dwScreenPitch & 0xFF);
+				write_reg(CR66, VIACR, cr66);
+				cr67 = read_reg(VIACR, CR67) & 0xFC;
+				cr67 |=
+				    (unsigned
+				     char)((dwScreenPitch & 0x300) >> 8);
+				write_reg(CR67, VIACR, cr67);
+			}
+
+			/* Fetch Count */
+			cr67 = read_reg(VIACR, CR67) & 0xF3;
+			cr67 |= (unsigned char)((dwScreenPitch & 0x600) >> 7);
+			write_reg(CR67, VIACR, cr67);
+			cr65 = (unsigned char)((dwScreenPitch >> 1) & 0xFF);
+			cr65 += 2;
+			write_reg(CR65, VIACR, cr65);
+		} else {
+			if (plvds_setting_info->bpp > 8) {
+				cr13 = (unsigned char)(dwScreenPitch & 0xFF);
+				write_reg(CR13, VIACR, cr13);
+				cr35 = read_reg(VIACR, CR35) & 0x1F;
+				cr35 |=
+				    (unsigned
+				     char)((dwScreenPitch & 0x700) >> 3);
+				write_reg(CR35, VIACR, cr35);
+			}
+		}
+	}
+}
+void lcd_patch_skew_dvp0(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info)
+{
+	if (VT1636_LVDS == plvds_chip_info->lvds_chip_name) {
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_P4M900:
+			vt1636_patch_skew_on_vt3364(plvds_setting_info,
+						    plvds_chip_info);
+			break;
+		case UNICHROME_P4M890:
+			vt1636_patch_skew_on_vt3327(plvds_setting_info,
+						    plvds_chip_info);
+			break;
+		}
+	}
+}
+void lcd_patch_skew_dvp1(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info)
+{
+	if (VT1636_LVDS == plvds_chip_info->lvds_chip_name) {
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_CX700:
+			vt1636_patch_skew_on_vt3324(plvds_setting_info,
+						    plvds_chip_info);
+			break;
+		}
+	}
+}
+void lcd_patch_skew(struct lvds_setting_information *plvds_setting_info,
+		    struct lvds_chip_information *plvds_chip_info)
+{
+	DEBUG_MSG(KERN_INFO "lcd_patch_skew\n");
+	switch (plvds_chip_info->output_interface) {
+	case INTERFACE_DVP0:
+		lcd_patch_skew_dvp0(plvds_setting_info, plvds_chip_info);
+		break;
+	case INTERFACE_DVP1:
+		lcd_patch_skew_dvp1(plvds_setting_info, plvds_chip_info);
+		break;
+	case INTERFACE_DFP_LOW:
+		if (UNICHROME_P4M900 == chip_info.gfx_chip_name) {
+			write_reg_mask(CR99, VIACR, 0x08,
+				       BIT0 + BIT1 + BIT2 + BIT3);
+		}
+		break;
+	}
+}
+
+/* LCD Set Mode */
+void lcd_set_mode(struct crt_mode_table *mode_crt_table,
+		  struct lvds_setting_information *plvds_setting_info,
+		  struct lvds_chip_information *plvds_chip_info)
+{
+	int video_index = plvds_setting_info->lcd_panel_size;
+	int set_iga = plvds_setting_info->iga_path;
+	int mode_bpp = plvds_setting_info->bpp;
+	int load_reg_num = 0;
+	int reg_value = 0;
+	int set_hres, set_vres;
+	int panel_hres, panel_vres;
+	u32 pll_D_N;
+	int offset;
+	struct io_register *reg = NULL;
+	struct display_timing mode_crt_reg, panel_crt_reg;
+	struct crt_mode_table *panel_crt_table = NULL;
+	struct VideoModeTable *vmode_tbl = NULL;
+
+	DEBUG_MSG(KERN_INFO "LCD_Set_Mode!!\n");
+	/* Get mode table */
+	mode_crt_reg = mode_crt_table->crtc;
+	/* Get panel table Pointer */
+	vmode_tbl = get_modetbl_pointer(video_index);
+	panel_crt_table = vmode_tbl->crtc;
+	panel_crt_reg = panel_crt_table->crtc;
+	DEBUG_MSG(KERN_INFO "bellow LCD_Set_Mode!!\n");
+	set_hres = plvds_setting_info->h_active;
+	set_vres = plvds_setting_info->v_active;
+	panel_hres = plvds_setting_info->lcd_panel_hres;
+	panel_vres = plvds_setting_info->lcd_panel_vres;
+	if (VT1636_LVDS == plvds_chip_info->lvds_chip_name)
+		init_lvds_vt1636(plvds_setting_info, plvds_chip_info);
+	plvds_setting_info->vclk = panel_crt_table->clk;
+	if (set_iga == IGA1) {
+		/* IGA1 doesn't have LCD scaling, so set it as centering. */
+		load_crtc_timing(lcd_centering_timging
+				 (mode_crt_reg, panel_crt_reg), IGA1);
+	} else {
+		/* Expansion */
+		if ((plvds_setting_info->display_method ==
+		     LCD_EXPANDSION) & ((set_hres != panel_hres)
+					|| (set_vres != panel_vres))) {
+			/* expansion timing IGA2 loaded panel set timing*/
+			load_crtc_timing(panel_crt_reg, IGA2);
+			DEBUG_MSG(KERN_INFO "load_crtc_timing!!\n");
+			load_lcd_scaling(set_hres, set_vres, panel_hres,
+					 panel_vres);
+			DEBUG_MSG(KERN_INFO "load_lcd_scaling!!\n");
+		} else {	/* Centering */
+			/* centering timing IGA2 always loaded panel
+			   and mode releative timing */
+			load_crtc_timing(lcd_centering_timging
+					 (mode_crt_reg, panel_crt_reg), IGA2);
+			write_reg_mask(CR79, VIACR, 0x00, BIT0 + BIT1 + BIT2);
+			/* LCD scaling disabled */
+		}
+	}
+
+	if (set_iga == IGA1_IGA2) {
+		load_crtc_shadow_timing(mode_crt_reg, panel_crt_reg);
+		/* Fill shadow registers */
+
+		switch (plvds_setting_info->lcd_panel_id) {
+		case LCD_PANEL_ID0_640X480:
+			offset = 80;
+			break;
+		case LCD_PANEL_ID1_800X600:
+		case LCD_PANEL_IDA_800X480:
+			offset = 110;
+			break;
+		case LCD_PANEL_ID2_1024X768:
+			offset = 150;
+			break;
+		case LCD_PANEL_ID3_1280X768:
+		case LCD_PANEL_ID4_1280X1024:
+		case LCD_PANEL_ID5_1400X1050:
+		case LCD_PANEL_ID9_1280X800:
+			offset = 190;
+			break;
+		case LCD_PANEL_ID6_1600X1200:
+			offset = 250;
+			break;
+		case LCD_PANEL_ID7_1366X768:
+		case LCD_PANEL_IDB_1360X768:
+			offset = 212;
+			break;
+		default:
+			offset = 140;
+			break;
+		}
+
+		/* Offset for simultaneous */
+		reg_value = offset;
+		load_reg_num = offset_reg.iga2_offset_reg.reg_num;
+		reg = offset_reg.iga2_offset_reg.reg;
+		load_reg(reg_value, load_reg_num, reg, VIACR);
+		DEBUG_MSG(KERN_INFO "load_reg!!\n");
+		load_fetch_count_reg(set_hres, 4, IGA2);
+		/* Fetch count for simultaneous */
+	} else {		/* SAMM */
+		/* Offset for IGA2 only */
+		load_offset_reg(set_hres, mode_bpp / 8, set_iga);
+		/* Fetch count for IGA2 only */
+		load_fetch_count_reg(set_hres, mode_bpp / 8, set_iga);
+
+		if ((chip_info.gfx_chip_name != UNICHROME_CLE266)
+		    && (chip_info.gfx_chip_name != UNICHROME_K400))
+			load_FIFO_reg(set_iga, set_hres, set_vres);
+
+		set_color_depth(mode_bpp / 8, set_iga);
+	}
+
+	fill_lcd_format();
+
+	pll_D_N = get_clk_value(panel_crt_table[0].clk);
+	DEBUG_MSG(KERN_INFO "PLL=0x%x", pll_D_N);
+	set_vclock(pll_D_N, set_iga);
+
+	set_output_path(DEVICE_LCD, set_iga, plvds_chip_info->output_interface);
+	lcd_patch_skew(plvds_setting_info, plvds_chip_info);
+
+	/* If K8M800, enable LCD Prefetch Mode. */
+	if ((chip_info.gfx_chip_name == UNICHROME_K800)
+	    || (UNICHROME_K8M890 == chip_info.gfx_chip_name))
+		write_reg_mask(CR6A, VIACR, 0x01, BIT0);
+
+	load_lcd_patch_regs(set_hres, set_vres,
+			    plvds_setting_info->lcd_panel_id, set_iga);
+
+	DEBUG_MSG(KERN_INFO "load_lcd_patch_regs!!\n");
+
+	/* Patch for non 32bit alignment mode */
+	via_pitch_alignment_patch_lcd(plvds_setting_info, plvds_chip_info);
+}
+
+void integrated_lvds_disable(struct lvds_setting_information
+			     *plvds_setting_info,
+			     struct lvds_chip_information *plvds_chip_info)
+{
+	bool turn_off_first_powersequence = FALSE;
+	bool turn_off_second_powersequence = FALSE;
+	if (INTERFACE_LVDS0LVDS1 == plvds_chip_info->output_interface)
+		turn_off_first_powersequence = TRUE;
+	if (INTERFACE_LVDS0 == plvds_chip_info->output_interface)
+		turn_off_first_powersequence = TRUE;
+	if (INTERFACE_LVDS1 == plvds_chip_info->output_interface)
+		turn_off_second_powersequence = TRUE;
+	if (turn_off_second_powersequence) {
+		/* Use second power sequence control: */
+
+		/* Turn off power sequence. */
+		write_reg_mask(CRD4, VIACR, 0, BIT1);
+
+		/* Turn off back light. */
+		write_reg_mask(CRD3, VIACR, 0xC0, BIT6 + BIT7);
+	}
+	if (turn_off_first_powersequence) {
+		/* Use first power sequence control: */
+
+		/* Turn off power sequence. */
+		write_reg_mask(CR6A, VIACR, 0, BIT3);
+
+		/* Turn off back light. */
+		write_reg_mask(CR91, VIACR, 0xC0, BIT6 + BIT7);
+	}
+
+	/* Turn DFP High/Low Pad off. */
+	write_reg_mask(SR2A, VIASR, 0, BIT0 + BIT1 + BIT2 + BIT3);
+
+	/* Power off LVDS channel. */
+	switch (plvds_chip_info->output_interface) {
+	case INTERFACE_LVDS0:
+		{
+			write_reg_mask(CRD2, VIACR, 0x80, BIT7);
+			break;
+		}
+
+	case INTERFACE_LVDS1:
+		{
+			write_reg_mask(CRD2, VIACR, 0x40, BIT6);
+			break;
+		}
+
+	case INTERFACE_LVDS0LVDS1:
+		{
+			write_reg_mask(CRD2, VIACR, 0xC0, BIT6 + BIT7);
+			break;
+		}
+	}
+}
+
+void integrated_lvds_enable(struct lvds_setting_information
+			    *plvds_setting_info,
+			    struct lvds_chip_information *plvds_chip_info)
+{
+	bool turn_on_first_powersequence = FALSE;
+	bool turn_on_second_powersequence = FALSE;
+
+	DEBUG_MSG(KERN_INFO "integrated_lvds_enable, out_interface:%d\n",
+		  plvds_chip_info->output_interface);
+	if (plvds_setting_info->lcd_mode == LCD_SPWG)
+		write_reg_mask(CRD2, VIACR, 0x00, BIT0 + BIT1);
+	 else
+		write_reg_mask(CRD2, VIACR, 0x03, BIT0 + BIT1);
+	if (INTERFACE_LVDS0LVDS1 == plvds_chip_info->output_interface)
+		turn_on_first_powersequence = TRUE;
+	if (INTERFACE_LVDS0 == plvds_chip_info->output_interface)
+		turn_on_first_powersequence = TRUE;
+	if (INTERFACE_LVDS1 == plvds_chip_info->output_interface)
+		turn_on_second_powersequence = TRUE;
+
+	if (turn_on_second_powersequence) {
+		/* Use second power sequence control: */
+
+		/* Use hardware control power sequence. */
+		write_reg_mask(CRD3, VIACR, 0, BIT0);
+
+		/* Turn on back light. */
+		write_reg_mask(CRD3, VIACR, 0, BIT6 + BIT7);
+
+		/* Turn on hardware power sequence. */
+		write_reg_mask(CRD4, VIACR, 0x02, BIT1);
+	}
+	if (turn_on_first_powersequence) {
+		/* Use first power sequence control: */
+
+		/* Use hardware control power sequence. */
+		write_reg_mask(CR91, VIACR, 0, BIT0);
+
+		/* Turn on back light. */
+		write_reg_mask(CR91, VIACR, 0, BIT6 + BIT7);
+
+		/* Turn on hardware power sequence. */
+		write_reg_mask(CR6A, VIACR, 0x08, BIT3);
+	}
+
+	/* Turn DFP High/Low pad on. */
+	write_reg_mask(SR2A, VIASR, 0x0F, BIT0 + BIT1 + BIT2 + BIT3);
+
+	/* Power on LVDS channel. */
+	switch (plvds_chip_info->output_interface) {
+	case INTERFACE_LVDS0:
+		{
+			write_reg_mask(CRD2, VIACR, 0, BIT7);
+			break;
+		}
+
+	case INTERFACE_LVDS1:
+		{
+			write_reg_mask(CRD2, VIACR, 0, BIT6);
+			break;
+		}
+
+	case INTERFACE_LVDS0LVDS1:
+		{
+			write_reg_mask(CRD2, VIACR, 0, BIT6 + BIT7);
+			break;
+		}
+	}
+}
+
+void lcd_disable(void)
+{
+
+	if (chip_info.gfx_chip_name == UNICHROME_CLE266) {
+		lcd_powersequence_off();
+		/* DI1 pad off */
+		write_reg_mask(SR1E, VIASR, 0x00, 0x30);
+	} else if (chip_info.gfx_chip_name == UNICHROME_CX700) {
+		if (LCD2_ON
+		    && (INTEGRATED_LVDS ==
+			chip_info.lvds_chip_info2.lvds_chip_name))
+			integrated_lvds_disable(&lvds_setting_info2,
+						&chip_info.lvds_chip_info2);
+		if (INTEGRATED_LVDS == chip_info.lvds_chip_info.lvds_chip_name)
+			integrated_lvds_disable(&lvds_setting_info,
+						&chip_info.lvds_chip_info);
+		if (VT1636_LVDS == chip_info.lvds_chip_info.lvds_chip_name)
+			disable_lvds_vt1636(&lvds_setting_info,
+					    &chip_info.lvds_chip_info);
+	} else if (VT1636_LVDS == chip_info.lvds_chip_info.lvds_chip_name) {
+		disable_lvds_vt1636(&lvds_setting_info,
+				    &chip_info.lvds_chip_info);
+	} else {
+		/* DFP-HL pad off          */
+		write_reg_mask(SR2A, VIASR, 0x00, 0x0F);
+		/* Backlight off           */
+		write_reg_mask(SR3D, VIASR, 0x00, 0x20);
+		/* 24 bit DI data paht off */
+		write_reg_mask(CR91, VIACR, 0x80, 0x80);
+		/* Simultaneout disabled   */
+		write_reg_mask(CR6B, VIACR, 0x00, 0x08);
+	}
+
+	/* Disable expansion bit   */
+	write_reg_mask(CR79, VIACR, 0x00, 0x01);
+	/* CRT path set to IGA1    */
+	write_reg_mask(SR16, VIASR, 0x00, 0x40);
+	/* Simultaneout disabled   */
+	write_reg_mask(CR6B, VIACR, 0x00, 0x08);
+	/* IGA2 path disabled      */
+	write_reg_mask(CR6A, VIACR, 0x00, 0x80);
+
+}
+
+void lcd_enable(void)
+{
+	if (chip_info.gfx_chip_name == UNICHROME_CLE266) {
+		/* DI1 pad on */
+		write_reg_mask(SR1E, VIASR, 0x30, 0x30);
+		lcd_powersequence_on();
+	} else if (chip_info.gfx_chip_name == UNICHROME_CX700) {
+		if (LCD2_ON && (INTEGRATED_LVDS ==
+			chip_info.lvds_chip_info2.lvds_chip_name))
+			integrated_lvds_enable(&lvds_setting_info2, \
+					       &chip_info.lvds_chip_info2);
+		if (INTEGRATED_LVDS == chip_info.lvds_chip_info.lvds_chip_name)
+			integrated_lvds_enable(&lvds_setting_info, \
+					       &chip_info.lvds_chip_info);
+		if (VT1636_LVDS == chip_info.lvds_chip_info.lvds_chip_name)
+			enable_lvds_vt1636(&lvds_setting_info, \
+					   &chip_info.lvds_chip_info);
+	} else if (VT1636_LVDS == chip_info.lvds_chip_info.lvds_chip_name) {
+		enable_lvds_vt1636(&lvds_setting_info,
+				   &chip_info.lvds_chip_info);
+	} else {
+		/* DFP-HL pad on           */
+		write_reg_mask(SR2A, VIASR, 0x0F, 0x0F);
+		/* Backlight on            */
+		write_reg_mask(SR3D, VIASR, 0x20, 0x20);
+		/* 24 bit DI data paht on  */
+		write_reg_mask(CR91, VIACR, 0x00, 0x80);
+
+		/* Set data source selection bit by iga path */
+		if (lvds_setting_info.iga_path == IGA1) {
+			/* DFP-H set to IGA1       */
+			write_reg_mask(CR97, VIACR, 0x00, 0x10);
+			/* DFP-L set to IGA1       */
+			write_reg_mask(CR99, VIACR, 0x00, 0x10);
+		} else {
+			/* DFP-H set to IGA2       */
+			write_reg_mask(CR97, VIACR, 0x10, 0x10);
+			/* DFP-L set to IGA2       */
+			write_reg_mask(CR99, VIACR, 0x10, 0x10);
+		}
+		/* LCD enabled             */
+		write_reg_mask(CR6A, VIACR, 0x48, 0x48);
+	}
+
+	if ((lvds_setting_info.iga_path == IGA1)
+	    || (lvds_setting_info.iga_path == IGA1_IGA2)) {
+		/* CRT path set to IGA2    */
+		write_reg_mask(SR16, VIASR, 0x40, 0x40);
+		/* IGA2 path disabled      */
+		write_reg_mask(CR6A, VIACR, 0x00, 0x80);
+		/* IGA2 path enabled       */
+	} else {		/* IGA2 */
+		write_reg_mask(CR6A, VIACR, 0x80, 0x80);
+	}
+
+}
+
+void lcd_powersequence_off(void)
+{
+	int i, mask, data;
+
+	/* Software control power sequence */
+	write_reg_mask(CR91, VIACR, 0x11, 0x11);
+
+	for (i = 0; i < 3; i++) {
+		mask = PowerSequenceOff[0][i];
+		data = PowerSequenceOff[1][i] & mask;
+		write_reg_mask(CR91, VIACR, (u8) data, (u8) mask);
+		delays(PowerSequenceOff[2][i]);
+	}
+
+	/* Disable LCD */
+	write_reg_mask(CR6A, VIACR, 0x00, 0x08);
+}
+
+void lcd_powersequence_on(void)
+{
+	int i, mask, data;
+
+	/* Software control power sequence */
+	write_reg_mask(CR91, VIACR, 0x11, 0x11);
+
+	/* Enable LCD */
+	write_reg_mask(CR6A, VIACR, 0x08, 0x08);
+
+	for (i = 0; i < 3; i++) {
+		mask = PowerSequenceOn[0][i];
+		data = PowerSequenceOn[1][i] & mask;
+		write_reg_mask(CR91, VIACR, (u8) data, (u8) mask);
+		delays(PowerSequenceOn[2][i]);
+	}
+
+	delays(1);
+}
+
+void fill_lcd_format(void)
+{
+	u8 bdithering = 0, bdual = 0;
+
+	if (lvds_setting_info.device_lcd_dualedge)
+		bdual = BIT4;
+	if (lvds_setting_info.LCDDithering)
+		bdithering = BIT0;
+	/* Dual & Dithering */
+	write_reg_mask(CR88, VIACR, (bdithering | bdual), BIT4 + BIT0);
+}
+
+void check_diport_of_integrated_lvds(struct lvds_chip_information
+				     *plvds_chip_info,
+				     struct lvds_setting_information
+				     *plvds_setting_info)
+{
+	/* Determine LCD DI Port by hardware layout. */
+	switch (display_hardware_layout) {
+	case HW_LAYOUT_LCD_ONLY:
+		{
+			if (plvds_setting_info->device_lcd_dualedge) {
+				plvds_chip_info->output_interface =
+				    INTERFACE_LVDS0LVDS1;
+			} else {
+				plvds_chip_info->output_interface =
+				    INTERFACE_LVDS0;
+			}
+
+			break;
+		}
+
+	case HW_LAYOUT_DVI_ONLY:
+		{
+			plvds_chip_info->output_interface = INTERFACE_NONE;
+			break;
+		}
+
+	case HW_LAYOUT_LCD1_LCD2:
+	case HW_LAYOUT_LCD_EXTERNAL_LCD2:
+		{
+			plvds_chip_info->output_interface =
+			    INTERFACE_LVDS0LVDS1;
+			break;
+		}
+
+	case HW_LAYOUT_LCD_DVI:
+		{
+			plvds_chip_info->output_interface = INTERFACE_LVDS1;
+			break;
+		}
+
+	default:
+		{
+			plvds_chip_info->output_interface = INTERFACE_LVDS1;
+			break;
+		}
+	}
+
+	DEBUG_MSG(KERN_INFO
+		  "Display Hardware Layout: 0x%x, LCD DI Port: 0x%x\n",
+		  display_hardware_layout, plvds_chip_info->output_interface);
+}
+
+void init_lvds_output_interface(struct lvds_chip_information
+				*plvds_chip_info,
+				struct lvds_setting_information
+				*plvds_setting_info)
+{
+	if (INTERFACE_NONE != plvds_chip_info->output_interface) {
+		/*Do nothing, lcd port is specified by module parameter */
+		return;
+	}
+
+	switch (plvds_chip_info->lvds_chip_name) {
+
+	case VT1636_LVDS:
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_CX700:
+			plvds_chip_info->output_interface = INTERFACE_DVP1;
+			break;
+		case UNICHROME_CN700:
+			plvds_chip_info->output_interface = INTERFACE_DFP_LOW;
+			break;
+		default:
+			plvds_chip_info->output_interface = INTERFACE_DVP0;
+			break;
+		}
+		break;
+
+	case INTEGRATED_LVDS:
+		check_diport_of_integrated_lvds(plvds_chip_info,
+						plvds_setting_info);
+		break;
+
+	default:
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M900:
+		case UNICHROME_P4M890:
+			plvds_chip_info->output_interface = INTERFACE_DFP_LOW;
+			break;
+		default:
+			plvds_chip_info->output_interface = INTERFACE_DFP;
+			break;
+		}
+		break;
+	}
+}
+
+struct display_timing lcd_centering_timging(struct display_timing
+					    mode_crt_reg,
+					    struct display_timing panel_crt_reg)
+{
+	struct display_timing crt_reg;
+
+	crt_reg.hor_total = panel_crt_reg.hor_total;
+	crt_reg.hor_addr = mode_crt_reg.hor_addr;
+	crt_reg.hor_blank_start =
+	    (panel_crt_reg.hor_addr - mode_crt_reg.hor_addr) / 2 +
+	    crt_reg.hor_addr;
+	crt_reg.hor_blank_end = panel_crt_reg.hor_blank_end;
+	crt_reg.hor_sync_start =
+	    (panel_crt_reg.hor_sync_start -
+	     panel_crt_reg.hor_blank_start) + crt_reg.hor_blank_start;
+	crt_reg.hor_sync_end = panel_crt_reg.hor_sync_end;
+
+	crt_reg.ver_total = panel_crt_reg.ver_total;
+	crt_reg.ver_addr = mode_crt_reg.ver_addr;
+	crt_reg.ver_blank_start =
+	    (panel_crt_reg.ver_addr - mode_crt_reg.ver_addr) / 2 +
+	    crt_reg.ver_addr;
+	crt_reg.ver_blank_end = panel_crt_reg.ver_blank_end;
+	crt_reg.ver_sync_start =
+	    (panel_crt_reg.ver_sync_start -
+	     panel_crt_reg.ver_blank_start) + crt_reg.ver_blank_start;
+	crt_reg.ver_sync_end = panel_crt_reg.ver_sync_end;
+
+	return crt_reg;
+}
+
+void load_crtc_shadow_timing(struct display_timing mode_timing,
+			     struct display_timing panel_timing)
+{
+	struct io_register *reg = NULL;
+	int i;
+	int load_reg_Num = 0;
+	int reg_value = 0;
+
+	if (lvds_setting_info.display_method == LCD_EXPANDSION) {
+		/* Expansion */
+		for (i = 12; i < 20; i++) {
+			switch (i) {
+			case H_TOTAL_SHADOW_INDEX:
+				reg_value =
+				    IGA2_HOR_TOTAL_SHADOW_FORMULA
+				    (panel_timing.hor_total);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.hor_total_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.hor_total_shadow.reg;
+				break;
+			case H_BLANK_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_HOR_BLANK_END_SHADOW_FORMULA
+				    (panel_timing.hor_blank_start,
+				     panel_timing.hor_blank_end);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    hor_blank_end_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    hor_blank_end_shadow.reg;
+				break;
+			case V_TOTAL_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_TOTAL_SHADOW_FORMULA
+				    (panel_timing.ver_total);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_total_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.ver_total_shadow.reg;
+				break;
+			case V_ADDR_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_ADDR_SHADOW_FORMULA
+				    (panel_timing.ver_addr);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_addr_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.ver_addr_shadow.reg;
+				break;
+			case V_BLANK_SATRT_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_START_SHADOW_FORMULA
+				    (panel_timing.ver_blank_start);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_start_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_start_shadow.reg;
+				break;
+			case V_BLANK_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_END_SHADOW_FORMULA
+				    (panel_timing.ver_blank_start,
+				     panel_timing.ver_blank_end);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_end_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_end_shadow.reg;
+				break;
+			case V_SYNC_SATRT_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_START_SHADOW_FORMULA
+				    (panel_timing.ver_sync_start);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_sync_start_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_sync_start_shadow.reg;
+				break;
+			case V_SYNC_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_END_SHADOW_FORMULA
+				    (panel_timing.ver_sync_start,
+				     panel_timing.ver_sync_end);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_sync_end_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_sync_end_shadow.reg;
+				break;
+			}
+			load_reg(reg_value, load_reg_Num, reg, VIACR);
+		}
+	} else {		/* Centering */
+		for (i = 12; i < 20; i++) {
+			switch (i) {
+			case H_TOTAL_SHADOW_INDEX:
+				reg_value =
+				    IGA2_HOR_TOTAL_SHADOW_FORMULA
+				    (panel_timing.hor_total);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.hor_total_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.hor_total_shadow.reg;
+				break;
+			case H_BLANK_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_HOR_BLANK_END_SHADOW_FORMULA
+				    (panel_timing.hor_blank_start,
+				     panel_timing.hor_blank_end);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    hor_blank_end_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    hor_blank_end_shadow.reg;
+				break;
+			case V_TOTAL_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_TOTAL_SHADOW_FORMULA
+				    (panel_timing.ver_total);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_total_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.ver_total_shadow.reg;
+				break;
+			case V_ADDR_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_ADDR_SHADOW_FORMULA
+				    (mode_timing.ver_addr);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_addr_shadow.
+				    reg_num;
+				reg = iga2_shadow_crtc_reg.ver_addr_shadow.reg;
+				break;
+			case V_BLANK_SATRT_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_START_SHADOW_FORMULA
+				    (mode_timing.ver_blank_start);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_start_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_start_shadow.reg;
+				break;
+			case V_BLANK_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_BLANK_END_SHADOW_FORMULA
+				    (panel_timing.ver_blank_start,
+				     panel_timing.ver_blank_end);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_end_shadow.reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.
+				    ver_blank_end_shadow.reg;
+				break;
+			case V_SYNC_SATRT_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_START_SHADOW_FORMULA(
+				    (panel_timing.ver_sync_start -
+				    panel_timing.ver_blank_start) +
+				    (panel_timing.ver_addr -
+				    mode_timing.ver_addr) / 2 +
+				    mode_timing.ver_addr);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_sync_start_shadow.
+				    reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.ver_sync_start_shadow.
+				    reg;
+				break;
+			case V_SYNC_END_SHADOW_INDEX:
+				reg_value =
+				    IGA2_VER_SYNC_END_SHADOW_FORMULA(
+				    (panel_timing.ver_sync_start -
+				    panel_timing.ver_blank_start) +
+				    (panel_timing.ver_addr -
+				    mode_timing.ver_addr) / 2 +
+				    mode_timing.ver_addr,
+				    panel_timing.ver_sync_end);
+				load_reg_Num =
+				    iga2_shadow_crtc_reg.ver_sync_end_shadow.
+				    reg_num;
+				reg =
+				    iga2_shadow_crtc_reg.ver_sync_end_shadow.
+				    reg;
+				break;
+			}
+			load_reg(reg_value, load_reg_Num, reg, VIACR);
+		}
+	}
+}
+
+bool lcd_get_mobile_state(bool *mobile)
+{
+	unsigned char *romptr, *tableptr;
+	u8 core_base;
+	unsigned char *biosptr;
+	/* Rom address */
+	u32 romaddr = 0x000C0000;
+	u16 start_pattern = (u16) NULL;
+
+	biosptr = ioremap(romaddr, 0x10000);
+
+	memcpy(&start_pattern, biosptr, 2);
+	/* Compare pattern */
+	if (start_pattern == 0xAA55) {
+		/* Get the start of Table */
+		/* 0x1B means BIOS offset position */
+		romptr = biosptr + 0x1B;
+		tableptr = biosptr + *((u16 *) romptr);
+
+		/* Get the start of biosver structure */
+		/* 18 means BIOS version position. */
+		romptr = tableptr + 18;
+		romptr = biosptr + *((u16 *) romptr);
+
+		/* The offset should be 44, but the
+		   actual image is less three char. */
+		/* pRom += 44; */
+		romptr += 41;
+
+		core_base = *romptr++;
+
+		if (core_base & 0x8) {
+			*mobile = FALSE;
+		} else {
+			*mobile = TRUE;
+		}
+		/* release memory */
+		iounmap(biosptr);
+
+		return TRUE;
+	} else {
+		iounmap(biosptr);
+		return FALSE;
+	}
+}
+
+void load_scaling_factor_for_p4m900(int set_hres, int set_vres,
+				    int panel_hres, int panel_vres)
+{
+	int h_scaling_factor;
+	int v_scaling_factor;
+	u8 cra2 = 0;
+	u8 cr77 = 0;
+	u8 cr78 = 0;
+	u8 cr79 = 0;
+	u8 cr9f = 0;
+	/* Check if expansion for horizontal */
+	if (set_hres < panel_hres) {
+		/* Load Horizontal Scaling Factor */
+
+		/* For VIA_K8M800 or later chipsets. */
+		h_scaling_factor =
+		    K800_LCD_HOR_SCF_FORMULA(set_hres, panel_hres);
+		/* HSCaleFactor[1:0] at CR9F[1:0] */
+		cr9f = h_scaling_factor & 0x0003;
+		/* HSCaleFactor[9:2] at CR77[7:0] */
+		cr77 = (h_scaling_factor & 0x03FC) >> 2;
+		/* HSCaleFactor[11:10] at CR79[5:4] */
+		cr79 = (h_scaling_factor & 0x0C00) >> 10;
+		cr79 <<= 4;
+
+		/* Horizontal scaling enabled */
+		cra2 = 0xC0;
+
+		DEBUG_MSG(KERN_INFO "Horizontal Scaling value = %d\n",
+			  h_scaling_factor);
+	} else {
+		/* Horizontal scaling disabled */
+		cra2 = 0x00;
+	}
+
+	/* Check if expansion for vertical */
+	if (set_vres < panel_vres) {
+		/* Load Vertical Scaling Factor */
+
+		/* For VIA_K8M800 or later chipsets. */
+		v_scaling_factor =
+		    K800_LCD_VER_SCF_FORMULA(set_vres, panel_vres);
+
+		/* Vertical scaling enabled */
+		cra2 |= 0x08;
+		/* VSCaleFactor[0] at CR79[3] */
+		cr79 |= ((v_scaling_factor & 0x0001) << 3);
+		/* VSCaleFactor[8:1] at CR78[7:0] */
+		cr78 |= (v_scaling_factor & 0x01FE) >> 1;
+		/* VSCaleFactor[10:9] at CR79[7:6] */
+		cr79 |= ((v_scaling_factor & 0x0600) >> 9) << 6;
+
+		DEBUG_MSG(KERN_INFO "Vertical Scaling value = %d\n",
+			  v_scaling_factor);
+	} else {
+		/* Vertical scaling disabled */
+		cra2 |= 0x00;
+	}
+
+	write_reg_mask(CRA2, VIACR, cra2, BIT3 + BIT6 + BIT7);
+	write_reg_mask(CR77, VIACR, cr77, 0xFF);
+	write_reg_mask(CR78, VIACR, cr78, 0xFF);
+	write_reg_mask(CR79, VIACR, cr79, 0xF8);
+	write_reg_mask(CR9F, VIACR, cr9f, BIT0 + BIT1);
+}
--- /dev/null
+++ b/drivers/video/viafb/lcd.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __LCD_H__
+#define __LCD_H__
+
+/*Definition TMDS Device ID register*/
+#define     VT1631_DEVICE_ID_REG        0x02
+#define     VT1631_DEVICE_ID            0x92
+
+#define     VT3271_DEVICE_ID_REG        0x02
+#define     VT3271_DEVICE_ID            0x71
+
+#define     GET_LCD_SIZE_BY_SYSTEM_BIOS     0x01
+#define     GET_LCD_SIZE_BY_VGA_BIOS        0x02
+#define     GET_LCD_SZIE_BY_HW_STRAPPING    0x03
+#define     GET_LCD_SIZE_BY_USER_SETTING    0x04
+
+/* Definition DVI Panel ID*/
+/* Resolution: 640x480,   Channel: single, Dithering: Enable */
+#define     LCD_PANEL_ID0_640X480       0x00
+/* Resolution: 800x600,   Channel: single, Dithering: Enable */
+#define     LCD_PANEL_ID1_800X600       0x01
+/* Resolution: 1024x768,  Channel: single, Dithering: Enable */
+#define     LCD_PANEL_ID2_1024X768      0x02
+/* Resolution: 1280x768,  Channel: single, Dithering: Enable */
+#define     LCD_PANEL_ID3_1280X768      0x03
+/* Resolution: 1280x1024, Channel: dual,   Dithering: Enable */
+#define     LCD_PANEL_ID4_1280X1024     0x04
+/* Resolution: 1400x1050, Channel: dual,   Dithering: Enable */
+#define     LCD_PANEL_ID5_1400X1050     0x05
+/* Resolution: 1600x1200, Channel: dual,   Dithering: Enable */
+#define     LCD_PANEL_ID6_1600X1200     0x06
+/* Resolution: 1366x768,  Channel: single, Dithering: Disable */
+#define     LCD_PANEL_ID7_1366X768      0x07
+/* Resolution: 1024x600,  Channel: single, Dithering: Enable*/
+#define     LCD_PANEL_ID8_1024X600      0x08
+/* Resolution: 1280x800,  Channel: single, Dithering: Enable*/
+#define     LCD_PANEL_ID9_1280X800      0x09
+/* Resolution: 800x480,   Channel: single, Dithering: Enable*/
+#define     LCD_PANEL_IDA_800X480       0x0A
+/* Resolution: 1360x768,   Channel: single, Dithering: Disable*/
+#define     LCD_PANEL_IDB_1360X768     0x0B
+/* Resolution: 480x640,  Channel: single, Dithering: Enable */
+#define     LCD_PANEL_IDC_480X640      0x0C
+
+
+extern int LCD2_ON;
+extern int LCD_ON;
+extern int DVI_ON;
+
+void disable_lvds_vt1636(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info);
+void enable_lvds_vt1636(struct lvds_setting_information
+			*plvds_setting_info,
+			struct lvds_chip_information *plvds_chip_info);
+
+int lvds_register_read(int index);
+int fp_id_to_vindex(int panel_id);
+void load_lcd_scaling(int set_hres, int set_vres, int panel_hres,
+		      int panel_vres);
+void load_lcd_k400_patch_tbl(int set_hres, int set_vres, int panel_id);
+void load_lcd_p880_patch_tbl(int set_hres, int set_vres, int panel_id);
+void load_lcd_patch_regs(int set_hres, int set_vres, int panel_id, int set_iga);
+void via_pitch_alignment_patch_lcd(struct lvds_setting_information
+				   *plvds_setting_info,
+				   struct lvds_chip_information
+				   *plvds_chip_info);
+void lcd_disable(void);
+void lcd_enable(void);
+void init_lcd_size(void);
+void lcd_powersequence_off(void);
+void lcd_powersequence_on(void);
+void fill_lcd_format(void);
+void init_lvds_output_interface(struct lvds_chip_information
+				*plvds_chip_info,
+				struct lvds_setting_information
+				*plvds_setting_info);
+struct display_timing lcd_centering_timging(struct display_timing
+					    mode_crt_reg,
+					    struct display_timing
+					    panel_crt_reg);
+void load_crtc_shadow_timing(struct display_timing mode_timing,
+			     struct display_timing panel_timing);
+void load_scaling_factor_for_p4m900(int set_hres, int set_vres,
+				    int panel_hres, int panel_vres);
+
+void lcd_set_mode(struct crt_mode_table *mode_crt_table,
+		  struct lvds_setting_information *plvds_setting_info,
+		  struct lvds_chip_information *plvds_chip_info);
+
+int lvds_trasmitter_identify(void);
+void init_lvds_output_interface(struct lvds_chip_information
+				*plvds_chip_info,
+				struct lvds_setting_information
+				*plvds_setting_info);
+bool lcd_get_mobile_state(bool *mobile);
+void plus_vck_to_iga1_timing(unsigned long h_total);
+void load_crtc_timing(struct display_timing device_timing, int set_iga);
+
+#endif /* __LCD_H__ */
--- /dev/null
+++ b/drivers/video/viafb/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the VIA framebuffer driver (for Linux Kernel 2.6)
+#
+
+obj-$(CONFIG_FB_VIA) += viafb.o
+
+viafb-y	:= viafbdev.o hw.o iface.o  via_i2c.o dvi.o lcd.o ioctl.o accel.o via_utility.o vt1636.o global.o tblDPASetting.o viamode.o tbl1636.o
+
+viafb-objs	:=	$(viafb-y)
--- /dev/null
+++ b/drivers/video/viafb/share.h
@@ -0,0 +1,1113 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __SHARE_H__
+#define __SHARE_H__
+
+/* Define Return Value */
+#define FAIL        -1
+#define OK          1
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+/* Define Bit Field */
+#define BIT0    0x01
+#define BIT1    0x02
+#define BIT2    0x04
+#define BIT3    0x08
+#define BIT4    0x10
+#define BIT5    0x20
+#define BIT6    0x40
+#define BIT7    0x80
+
+/* Video Memory Size */
+#define VIDEO_MEMORY_SIZE_16M    0x1000000
+
+/* Definition Mode Index
+*/
+#define     VIA_RES_640X480                 	0
+#define     VIA_RES_800X600                 	1
+#define     VIA_RES_1024X768                	2
+#define     VIA_RES_1152X864                	3
+#define     VIA_RES_1280X1024               	4
+#define     VIA_RES_1600X1200               	5
+#define     VIA_RES_1440X1050               	6
+#define     VIA_RES_1280X768                	7
+#define     VIA_RES_1280X960                	8
+#define     VIA_RES_1920X1440               	9
+#define     VIA_RES_848X480                 	10
+#define     VIA_RES_1400X1050               	11
+#define     VIA_RES_720X480                 	12
+#define     VIA_RES_720X576                 	13
+#define     VIA_RES_1024X512                	14
+#define     VIA_RES_856X480                 	15
+#define     VIA_RES_1024X576                	16
+#define     VIA_RES_640X400                 	17
+#define     VIA_RES_1280X720                	18
+#define     VIA_RES_1920X1080               	19
+#define     VIA_RES_800X480                 	20
+#define     VIA_RES_1368X768                	21
+#define     VIA_RES_1024X600                	22
+#define     VIA_RES_1280X800                	23
+#define     VIA_RES_1680X1050               	24
+#define     VIA_RES_960X600			25
+#define     VIA_RES_1000X600               	26
+#define     VIA_RES_1088X612               	27
+#define     VIA_RES_1152X720               	28
+#define     VIA_RES_1200X720               	29
+#define     VIA_RES_1280X600               	30
+#define     VIA_RES_1360X768               	31
+#define     VIA_RES_1366X768               	32
+#define     VIA_RES_1440X900               	33
+#define     VIA_RES_1600X900               	34
+#define     VIA_RES_1600X1024              	35
+#define     VIA_RES_1792X1344              	36
+#define     VIA_RES_1856X1392              	37
+#define     VIA_RES_1920X1200              	38
+#define     VIA_RES_2048X1536              	39
+#define     VIA_RES_480X640                  	40
+
+/*Reduce Blanking*/
+#define     VIA_RES_1360X768_RB          	131
+#define     VIA_RES_1440X900_RB          	133
+#define     VIA_RES_1400X1050_RB        	111
+#define     VIA_RES_1600X900_RB          	134
+#define     VIA_RES_1680X1050_RB        	124
+#define     VIA_RES_1920X1080_RB        	119
+#define     VIA_RES_1920X1200_RB        	138
+
+#define     VIA_RES_INVALID                 	255
+
+/* standard VGA IO port
+*/
+#define VIARMisc    0x3CC
+#define VIAWMisc    0x3C2
+#define VIAStatus   0x3DA
+#define VIACR       0x3D4
+#define VIASR       0x3C4
+#define VIAGR       0x3CE
+#define VIAAR       0x3C0
+
+#define StdCR       0x19
+#define StdSR       0x04
+#define StdGR       0x09
+#define StdAR       0x14
+
+#define PatchCR     11
+
+/* Display path */
+#define IGA1        1
+#define IGA2        2
+#define IGA1_IGA2   3
+
+/* Define Color Depth  */
+#define MODE_8BPP       1
+#define MODE_16BPP      2
+#define MODE_32BPP      4
+
+#define GR20    0x20
+#define GR21    0x21
+#define GR22    0x22
+
+/* Sequencer Registers */
+#define SR01    0x01
+#define SR10    0x10
+#define SR12    0x12
+#define SR15    0x15
+#define SR16    0x16
+#define SR17    0x17
+#define SR18    0x18
+#define SR1B    0x1B
+#define SR1A    0x1A
+#define SR1C    0x1C
+#define SR1D    0x1D
+#define SR1E    0x1E
+#define SR1F    0x1F
+#define SR20    0x20
+#define SR21    0x21
+#define SR22    0x22
+#define SR2A    0x2A
+#define SR2D    0x2D
+#define SR2E    0x2E
+
+#define SR30    0x30
+#define SR39    0x39
+#define SR3D    0x3D
+#define SR3E    0x3E
+#define SR3F    0x3F
+#define SR40    0x40
+#define SR43    0x43
+#define SR44    0x44
+#define SR45    0x45
+#define SR46    0x46
+#define SR47    0x47
+#define SR48    0x48
+#define SR49    0x49
+#define SR4A    0x4A
+#define SR4B    0x4B
+#define SR4C    0x4C
+#define SR52    0x52
+#define SR5E    0x5E
+#define SR65    0x65
+
+/* CRT Controller Registers */
+#define CR00    0x00
+#define CR01    0x01
+#define CR02    0x02
+#define CR03    0x03
+#define CR04    0x04
+#define CR05    0x05
+#define CR06    0x06
+#define CR07    0x07
+#define CR08    0x08
+#define CR09    0x09
+#define CR0A    0x0A
+#define CR0B    0x0B
+#define CR0C    0x0C
+#define CR0D    0x0D
+#define CR0E    0x0E
+#define CR0F    0x0F
+#define CR10    0x10
+#define CR11    0x11
+#define CR12    0x12
+#define CR13    0x13
+#define CR14    0x14
+#define CR15    0x15
+#define CR16    0x16
+#define CR17    0x17
+#define CR18    0x18
+
+/* Extend CRT Controller Registers */
+#define CR30    0x30
+#define CR31    0x31
+#define CR32    0x32
+#define CR33    0x33
+#define CR34    0x34
+#define CR35    0x35
+#define CR36    0x36
+#define CR37    0x37
+#define CR38    0x38
+#define CR39    0x39
+#define CR3A    0x3A
+#define CR3B    0x3B
+#define CR3C    0x3C
+#define CR3D    0x3D
+#define CR3E    0x3E
+#define CR3F    0x3F
+#define CR40    0x40
+#define CR41    0x41
+#define CR42    0x42
+#define CR43    0x43
+#define CR44    0x44
+#define CR45    0x45
+#define CR46    0x46
+#define CR47    0x47
+#define CR48    0x48
+#define CR49    0x49
+#define CR4A    0x4A
+#define CR4B    0x4B
+#define CR4C    0x4C
+#define CR4D    0x4D
+#define CR4E    0x4E
+#define CR4F    0x4F
+#define CR50    0x50
+#define CR51    0x51
+#define CR52    0x52
+#define CR53    0x53
+#define CR54    0x54
+#define CR55    0x55
+#define CR56    0x56
+#define CR57    0x57
+#define CR58    0x58
+#define CR59    0x59
+#define CR5A    0x5A
+#define CR5B    0x5B
+#define CR5C    0x5C
+#define CR5D    0x5D
+#define CR5E    0x5E
+#define CR5F    0x5F
+#define CR60    0x60
+#define CR61    0x61
+#define CR62    0x62
+#define CR63    0x63
+#define CR64    0x64
+#define CR65    0x65
+#define CR66    0x66
+#define CR67    0x67
+#define CR68    0x68
+#define CR69    0x69
+#define CR6A    0x6A
+#define CR6B    0x6B
+#define CR6C    0x6C
+#define CR6D    0x6D
+#define CR6E    0x6E
+#define CR6F    0x6F
+#define CR70    0x70
+#define CR71    0x71
+#define CR72    0x72
+#define CR73    0x73
+#define CR74    0x74
+#define CR75    0x75
+#define CR76    0x76
+#define CR77    0x77
+#define CR78    0x78
+#define CR79    0x79
+#define CR7A    0x7A
+#define CR7B    0x7B
+#define CR7C    0x7C
+#define CR7D    0x7D
+#define CR7E    0x7E
+#define CR7F    0x7F
+#define CR80    0x80
+#define CR81    0x81
+#define CR82    0x82
+#define CR83    0x83
+#define CR84    0x84
+#define CR85    0x85
+#define CR86    0x86
+#define CR87    0x87
+#define CR88    0x88
+#define CR89    0x89
+#define CR8A    0x8A
+#define CR8B    0x8B
+#define CR8C    0x8C
+#define CR8D    0x8D
+#define CR8E    0x8E
+#define CR8F    0x8F
+#define CR90    0x90
+#define CR91    0x91
+#define CR92    0x92
+#define CR93    0x93
+#define CR94    0x94
+#define CR95    0x95
+#define CR96    0x96
+#define CR97    0x97
+#define CR98    0x98
+#define CR99    0x99
+#define CR9A    0x9A
+#define CR9B    0x9B
+#define CR9C    0x9C
+#define CR9D    0x9D
+#define CR9E    0x9E
+#define CR9F    0x9F
+#define CRA0    0xA0
+#define CRA1    0xA1
+#define CRA2    0xA2
+#define CRA3    0xA3
+#define CRD2    0xD2
+#define CRD3    0xD3
+#define CRD4    0xD4
+
+/* LUT Table*/
+#define LUT_DATA             0x3C9	/* DACDATA */
+#define LUT_INDEX_READ       0x3C7	/* DACRX */
+#define LUT_INDEX_WRITE      0x3C8	/* DACWX */
+#define DACMASK              0x3C6
+
+/* Definition Device */
+#define DEVICE_CRT  0x01
+#define DEVICE_DVI  0x03
+#define DEVICE_LCD  0x04
+
+/* Device output interface */
+#define INTERFACE_NONE          0x00
+#define INTERFACE_ANALOG_RGB    0x01
+#define INTERFACE_DVP0          0x02
+#define INTERFACE_DVP1          0x03
+#define INTERFACE_DFP_HIGH      0x04
+#define INTERFACE_DFP_LOW       0x05
+#define INTERFACE_DFP           0x06
+#define INTERFACE_LVDS0         0x07
+#define INTERFACE_LVDS1         0x08
+#define INTERFACE_LVDS0LVDS1    0x09
+#define INTERFACE_TMDS          0x0A
+
+#define HW_LAYOUT_LCD_ONLY      0x01
+#define HW_LAYOUT_DVI_ONLY      0x02
+#define HW_LAYOUT_LCD_DVI       0x03
+#define HW_LAYOUT_LCD1_LCD2     0x04
+#define HW_LAYOUT_LCD_EXTERNAL_LCD2 0x10
+
+/* Definition Refresh Rate */
+#define REFRESH_50      50
+#define REFRESH_60      60
+#define REFRESH_75      75
+#define REFRESH_85      85
+#define REFRESH_100     100
+#define REFRESH_120     120
+
+/* Definition Sync Polarity*/
+#define NEGATIVE        1
+#define POSITIVE        0
+
+/*480x640@60 Sync Polarity (GTF)
+*/
+#define M480X640_R60_HSP        NEGATIVE
+#define M480X640_R60_VSP        POSITIVE
+
+/*640x480@60 Sync Polarity (VESA Mode)
+*/
+#define M640X480_R60_HSP        NEGATIVE
+#define M640X480_R60_VSP        NEGATIVE
+
+/*640x480@75 Sync Polarity (VESA Mode)
+*/
+#define M640X480_R75_HSP        NEGATIVE
+#define M640X480_R75_VSP        NEGATIVE
+
+/*640x480@85 Sync Polarity (VESA Mode)
+*/
+#define M640X480_R85_HSP        NEGATIVE
+#define M640X480_R85_VSP        NEGATIVE
+
+/*640x480@100 Sync Polarity (GTF Mode)
+*/
+#define M640X480_R100_HSP       NEGATIVE
+#define M640X480_R100_VSP       POSITIVE
+
+/*640x480@120 Sync Polarity (GTF Mode)
+*/
+#define M640X480_R120_HSP       NEGATIVE
+#define M640X480_R120_VSP       POSITIVE
+
+/*720x480@60 Sync Polarity  (GTF Mode)
+*/
+#define M720X480_R60_HSP        NEGATIVE
+#define M720X480_R60_VSP        POSITIVE
+
+/*720x576@60 Sync Polarity  (GTF Mode)
+*/
+#define M720X576_R60_HSP        NEGATIVE
+#define M720X576_R60_VSP        POSITIVE
+
+/*800x600@60 Sync Polarity (VESA Mode)
+*/
+#define M800X600_R60_HSP        POSITIVE
+#define M800X600_R60_VSP        POSITIVE
+
+/*800x600@75 Sync Polarity (VESA Mode)
+*/
+#define M800X600_R75_HSP        POSITIVE
+#define M800X600_R75_VSP        POSITIVE
+
+/*800x600@85 Sync Polarity (VESA Mode)
+*/
+#define M800X600_R85_HSP        POSITIVE
+#define M800X600_R85_VSP        POSITIVE
+
+/*800x600@100 Sync Polarity (GTF Mode)
+*/
+#define M800X600_R100_HSP       NEGATIVE
+#define M800X600_R100_VSP       POSITIVE
+
+/*800x600@120 Sync Polarity (GTF Mode)
+*/
+#define M800X600_R120_HSP       NEGATIVE
+#define M800X600_R120_VSP       POSITIVE
+
+/*800x480@60 Sync Polarity  (CVT Mode)
+*/
+#define M800X480_R60_HSP        NEGATIVE
+#define M800X480_R60_VSP        POSITIVE
+
+/*848x480@60 Sync Polarity  (CVT Mode)
+*/
+#define M848X480_R60_HSP        NEGATIVE
+#define M848X480_R60_VSP        POSITIVE
+
+/*852x480@60 Sync Polarity  (GTF Mode)
+*/
+#define M852X480_R60_HSP        NEGATIVE
+#define M852X480_R60_VSP        POSITIVE
+
+/*1024x512@60 Sync Polarity (GTF Mode)
+*/
+#define M1024X512_R60_HSP       NEGATIVE
+#define M1024X512_R60_VSP       POSITIVE
+
+/*1024x600@60 Sync Polarity (GTF Mode)
+*/
+#define M1024X600_R60_HSP       NEGATIVE
+#define M1024X600_R60_VSP       POSITIVE
+
+/*1024x768@60 Sync Polarity (VESA Mode)
+*/
+#define M1024X768_R60_HSP       NEGATIVE
+#define M1024X768_R60_VSP       NEGATIVE
+
+/*1024x768@75 Sync Polarity (VESA Mode)
+*/
+#define M1024X768_R75_HSP       POSITIVE
+#define M1024X768_R75_VSP       POSITIVE
+
+/*1024x768@85 Sync Polarity (VESA Mode)
+*/
+#define M1024X768_R85_HSP       POSITIVE
+#define M1024X768_R85_VSP       POSITIVE
+
+/*1024x768@100 Sync Polarity (GTF Mode)
+*/
+#define M1024X768_R100_HSP      NEGATIVE
+#define M1024X768_R100_VSP      POSITIVE
+
+/*1152x864@75 Sync Polarity (VESA Mode)
+*/
+#define M1152X864_R75_HSP       POSITIVE
+#define M1152X864_R75_VSP       POSITIVE
+
+/*1280x720@60 Sync Polarity  (GTF Mode)
+*/
+#define M1280X720_R60_HSP       NEGATIVE
+#define M1280X720_R60_VSP       POSITIVE
+
+/* 1280x768@50 Sync Polarity  (GTF Mode) */
+#define M1280X768_R50_HSP       NEGATIVE
+#define M1280X768_R50_VSP       POSITIVE
+
+/*1280x768@60 Sync Polarity  (GTF Mode)
+*/
+#define M1280X768_R60_HSP       NEGATIVE
+#define M1280X768_R60_VSP       POSITIVE
+
+/*1280x800@60 Sync Polarity  (CVT Mode)
+*/
+#define M1280X800_R60_HSP       NEGATIVE
+#define M1280X800_R60_VSP       POSITIVE
+
+/*1280x960@60 Sync Polarity (VESA Mode)
+*/
+#define M1280X960_R60_HSP       POSITIVE
+#define M1280X960_R60_VSP       POSITIVE
+
+/*1280x1024@60 Sync Polarity (VESA Mode)
+*/
+#define M1280X1024_R60_HSP      POSITIVE
+#define M1280X1024_R60_VSP      POSITIVE
+
+/* 1360x768@60 Sync Polarity (CVT Mode) */
+#define M1360X768_R60_HSP       POSITIVE
+#define M1360X768_R60_VSP       POSITIVE
+
+/* 1360x768@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1360X768_RB_R60_HSP       POSITIVE
+#define M1360X768_RB_R60_VSP       NEGATIVE
+
+/* 1368x768@50 Sync Polarity (GTF Mode) */
+#define M1368X768_R50_HSP       NEGATIVE
+#define M1368X768_R50_VSP       POSITIVE
+
+/* 1368x768@60 Sync Polarity (VESA Mode) */
+#define M1368X768_R60_HSP       NEGATIVE
+#define M1368X768_R60_VSP       POSITIVE
+
+/*1280x1024@75 Sync Polarity (VESA Mode)
+*/
+#define M1280X1024_R75_HSP      POSITIVE
+#define M1280X1024_R75_VSP      POSITIVE
+
+/*1280x1024@85 Sync Polarity (VESA Mode)
+*/
+#define M1280X1024_R85_HSP      POSITIVE
+#define M1280X1024_R85_VSP      POSITIVE
+
+/*1440x1050@60 Sync Polarity (GTF Mode)
+*/
+#define M1440X1050_R60_HSP      NEGATIVE
+#define M1440X1050_R60_VSP      POSITIVE
+
+/*1600x1200@60 Sync Polarity (VESA Mode)
+*/
+#define M1600X1200_R60_HSP      POSITIVE
+#define M1600X1200_R60_VSP      POSITIVE
+
+/*1600x1200@75 Sync Polarity (VESA Mode)
+*/
+#define M1600X1200_R75_HSP      POSITIVE
+#define M1600X1200_R75_VSP      POSITIVE
+
+/* 1680x1050@60 Sync Polarity (CVT Mode) */
+#define M1680x1050_R60_HSP      NEGATIVE
+#define M1680x1050_R60_VSP      NEGATIVE
+
+/* 1680x1050@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1680x1050_RB_R60_HSP      POSITIVE
+#define M1680x1050_RB_R60_VSP      NEGATIVE
+
+/* 1680x1050@75 Sync Polarity (CVT Mode) */
+#define M1680x1050_R75_HSP      NEGATIVE
+#define M1680x1050_R75_VSP      POSITIVE
+
+/*1920x1080@60 Sync Polarity (CVT Mode)
+*/
+#define M1920X1080_R60_HSP      NEGATIVE
+#define M1920X1080_R60_VSP      POSITIVE
+
+/* 1920x1080@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1920X1080_RB_R60_HSP  POSITIVE
+#define M1920X1080_RB_R60_VSP  NEGATIVE
+
+/*1920x1440@60 Sync Polarity (VESA Mode)
+*/
+#define M1920X1440_R60_HSP      NEGATIVE
+#define M1920X1440_R60_VSP      POSITIVE
+
+/*1920x1440@75 Sync Polarity (VESA Mode)
+*/
+#define M1920X1440_R75_HSP      NEGATIVE
+#define M1920X1440_R75_VSP      POSITIVE
+
+#if 0
+/* 1400x1050@60 Sync Polarity (VESA Mode) */
+#define M1400X1050_R60_HSP      NEGATIVE
+#define M1400X1050_R60_VSP      NEGATIVE
+#endif
+
+/* 1400x1050@60 Sync Polarity (CVT Mode) */
+#define M1400X1050_R60_HSP      NEGATIVE
+#define M1400X1050_R60_VSP      POSITIVE
+
+/* 1400x1050@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1400X1050_RB_R60_HSP      POSITIVE
+#define M1400X1050_RB_R60_VSP      NEGATIVE
+
+/* 1400x1050@75 Sync Polarity (CVT Mode) */
+#define M1400X1050_R75_HSP      NEGATIVE
+#define M1400X1050_R75_VSP      POSITIVE
+
+/* 960x600@60 Sync Polarity (CVT Mode) */
+#define M960X600_R60_HSP        NEGATIVE
+#define M960X600_R60_VSP        POSITIVE
+
+/* 1000x600@60 Sync Polarity (GTF Mode) */
+#define M1000X600_R60_HSP       NEGATIVE
+#define M1000X600_R60_VSP       POSITIVE
+
+/* 1024x576@60 Sync Polarity (GTF Mode) */
+#define M1024X576_R60_HSP       NEGATIVE
+#define M1024X576_R60_VSP       POSITIVE
+
+/*1024x600@60 Sync Polarity (GTF Mode)*/
+#define M1024X600_R60_HSP       NEGATIVE
+#define M1024X600_R60_VSP       POSITIVE
+
+/* 1088x612@60 Sync Polarity (CVT Mode) */
+#define M1088X612_R60_HSP       NEGATIVE
+#define M1088X612_R60_VSP       POSITIVE
+
+/* 1152x720@60 Sync Polarity (CVT Mode) */
+#define M1152X720_R60_HSP       NEGATIVE
+#define M1152X720_R60_VSP       POSITIVE
+
+/* 1200x720@60 Sync Polarity (GTF Mode) */
+#define M1200X720_R60_HSP       NEGATIVE
+#define M1200X720_R60_VSP       POSITIVE
+
+/* 1280x600@60 Sync Polarity (GTF Mode) */
+#define M1280x600_R60_HSP       NEGATIVE
+#define M1280x600_R60_VSP       POSITIVE
+
+/* 1280x720@50 Sync Polarity  (GTF Mode) */
+#define M1280X720_R50_HSP       NEGATIVE
+#define M1280X720_R50_VSP       POSITIVE
+
+/* 1280x720@60 Sync Polarity  (CEA Mode) */
+#define M1280X720_CEA_R60_HSP       POSITIVE
+#define M1280X720_CEA_R60_VSP       POSITIVE
+
+/* 1440x900@60 Sync Polarity (CVT Mode) */
+#define M1440X900_R60_HSP       NEGATIVE
+#define M1440X900_R60_VSP       POSITIVE
+
+/* 1440x900@75 Sync Polarity (CVT Mode) */
+#define M1440X900_R75_HSP       NEGATIVE
+#define M1440X900_R75_VSP       POSITIVE
+
+/* 1440x900@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1440X900_RB_R60_HSP       POSITIVE
+#define M1440X900_RB_R60_VSP       NEGATIVE
+
+/* 1600x900@60 Sync Polarity (CVT Mode) */
+#define M1600X900_R60_HSP       NEGATIVE
+#define M1600X900_R60_VSP       POSITIVE
+
+/* 1600x900@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1600X900_RB_R60_HSP       POSITIVE
+#define M1600X900_RB_R60_VSP       NEGATIVE
+
+/* 1600x1024@60 Sync Polarity (GTF Mode) */
+#define M1600X1024_R60_HSP      NEGATIVE
+#define M1600X1024_R60_VSP      POSITIVE
+
+/* 1792x1344@60 Sync Polarity (DMT Mode) */
+#define M1792x1344_R60_HSP      NEGATIVE
+#define M1792x1344_R60_VSP      POSITIVE
+
+/* 1856x1392@60 Sync Polarity (DMT Mode) */
+#define M1856x1392_R60_HSP      NEGATIVE
+#define M1856x1392_R60_VSP      POSITIVE
+
+/* 1920x1200@60 Sync Polarity (CVT Mode) */
+#define M1920X1200_R60_HSP      NEGATIVE
+#define M1920X1200_R60_VSP      POSITIVE
+
+/* 1920x1200@60 Sync Polarity (CVT Reduce Blanking Mode) */
+#define M1920X1200_RB_R60_HSP  POSITIVE
+#define M1920X1200_RB_R60_VSP  NEGATIVE
+
+/* 1920x1080@60 Sync Polarity  (CEA Mode) */
+#define M1920X1080_CEA_R60_HSP       POSITIVE
+#define M1920X1080_CEA_R60_VSP       POSITIVE
+
+/* 2048x1536@60 Sync Polarity (CVT Mode) */
+#define M2048x1536_R60_HSP      NEGATIVE
+#define M2048x1536_R60_VSP      POSITIVE
+
+/* define PLL index: */
+#define CLK_25_175M     25175000
+#define CLK_26_880M     26880000
+#define CLK_29_581M     29581000
+#define CLK_31_490M     31490000
+#define CLK_31_500M     31500000
+#define CLK_31_728M     31728000
+#define CLK_32_668M     32688000
+#define CLK_36_000M     36000000
+#define CLK_40_000M     40000000
+#define CLK_41_291M     41291000
+#define CLK_43_163M     43163000
+#define CLK_45_250M     45250000	/* 45.46MHz */
+#define CLK_46_000M     46000000
+#define CLK_46_996M     46996000
+#define CLK_48_000M     48000000
+#define CLK_48_875M     48875000
+#define CLK_49_500M     49500000
+#define CLK_52_406M     52406000
+#define CLK_52_977M     52977000
+#define CLK_56_250M     56250000
+#define CLK_60_466M     60466000
+#define CLK_61_500M     61500000
+#define CLK_65_000M     65000000
+#define CLK_65_178M     65178000
+#define CLK_66_750M     66750000	/* 67.116MHz */
+#define CLK_68_179M     68179000
+#define CLK_69_924M     69924000
+#define CLK_70_159M     70159000
+#define CLK_72_000M     72000000
+#define CLK_74_270M     74270000
+#define CLK_78_750M     78750000
+#define CLK_80_136M     80136000
+#define CLK_83_375M     83375000
+#define CLK_83_950M     83950000
+#define CLK_84_750M     84750000	/* 84.537Mhz */
+#define CLK_85_860M     85860000
+#define CLK_88_750M     88750000
+#define CLK_94_500M     94500000
+#define CLK_97_750M     97750000
+#define CLK_101_000M    101000000
+#define CLK_106_500M    106500000
+#define CLK_108_000M    108000000
+#define CLK_113_309M    113309000
+#define CLK_118_840M    118840000
+#define CLK_119_000M    119000000
+#define CLK_121_750M    121750000	/* 121.704MHz */
+#define CLK_125_104M    125104000
+#define CLK_133_308M    133308000
+#define CLK_135_000M    135000000
+#define CLK_136_700M    136700000
+#define CLK_138_400M    138400000
+#define CLK_146_760M    146760000
+#define CLK_148_500M    148500000
+
+#define CLK_153_920M    153920000
+#define CLK_156_000M    156000000
+#define CLK_157_500M    157500000
+#define CLK_162_000M    162000000
+#define CLK_187_000M    187000000
+#define CLK_193_295M    193295000
+#define CLK_202_500M    202500000
+#define CLK_204_000M    204000000
+#define CLK_218_500M    218500000
+#define CLK_234_000M    234000000
+#define CLK_267_250M    267250000
+#define CLK_297_500M    297500000
+#define CLK_74_481M     74481000
+#define CLK_172_798M    172798000
+#define CLK_122_614M    122614000
+
+/* CLE266 PLL value
+*/
+#define CLE266_PLL_25_175M     0x0000C763
+#define CLE266_PLL_26_880M     0x0000440F
+#define CLE266_PLL_29_581M     0x00008421
+#define CLE266_PLL_31_490M     0x00004721
+#define CLE266_PLL_31_500M     0x0000C3B5
+#define CLE266_PLL_31_728M     0x0000471F
+#define CLE266_PLL_32_668M     0x0000C449
+#define CLE266_PLL_36_000M     0x0000C5E5
+#define CLE266_PLL_40_000M     0x0000C459
+#define CLE266_PLL_41_291M     0x00004417
+#define CLE266_PLL_43_163M     0x0000C579
+#define CLE266_PLL_45_250M     0x0000C57F	/* 45.46MHz */
+#define CLE266_PLL_46_000M     0x0000875A
+#define CLE266_PLL_46_996M     0x0000C4E9
+#define CLE266_PLL_48_000M     0x00001443
+#define CLE266_PLL_48_875M     0x00001D63
+#define CLE266_PLL_49_500M     0x00008653
+#define CLE266_PLL_52_406M     0x0000C475
+#define CLE266_PLL_52_977M     0x00004525
+#define CLE266_PLL_56_250M     0x000047B7
+#define CLE266_PLL_60_466M     0x0000494C
+#define CLE266_PLL_61_500M     0x00001456
+#define CLE266_PLL_65_000M     0x000086ED
+#define CLE266_PLL_65_178M     0x0000855B
+#define CLE266_PLL_66_750M     0x0000844B	/* 67.116MHz */
+#define CLE266_PLL_68_179M     0x00000413
+#define CLE266_PLL_69_924M     0x00001153
+#define CLE266_PLL_70_159M     0x00001462
+#define CLE266_PLL_72_000M     0x00001879
+#define CLE266_PLL_74_270M     0x00004853
+#define CLE266_PLL_78_750M     0x00004321
+#define CLE266_PLL_80_136M     0x0000051C
+#define CLE266_PLL_83_375M     0x0000C25D
+#define CLE266_PLL_83_950M     0x00000729
+#define CLE266_PLL_84_750M     0x00008576	/* 84.537MHz */
+#define CLE266_PLL_85_860M     0x00004754
+#define CLE266_PLL_88_750M     0x0000051F
+#define CLE266_PLL_94_500M     0x00000521
+#define CLE266_PLL_97_750M     0x00004652
+#define CLE266_PLL_101_000M    0x0000497F
+#define CLE266_PLL_106_500M    0x00008477	/* 106.491463 MHz */
+#define CLE266_PLL_108_000M    0x00008479
+#define CLE266_PLL_113_309M    0x00000C5F
+#define CLE266_PLL_118_840M    0x00004553
+#define CLE266_PLL_119_000M    0x00000D6C
+#define CLE266_PLL_121_750M    0x00004555	/* 121.704MHz */
+#define CLE266_PLL_125_104M    0x000006B5
+#define CLE266_PLL_133_308M    0x0000465F
+#define CLE266_PLL_135_000M    0x0000455E
+#define CLE266_PLL_136_700M    0x00000C73
+#define CLE266_PLL_138_400M    0x00000957
+#define CLE266_PLL_146_760M    0x00004567
+#define CLE266_PLL_148_500M    0x00000853
+#define CLE266_PLL_153_920M    0x00000856
+#define CLE266_PLL_156_000M    0x0000456D
+#define CLE266_PLL_157_500M    0x000005B7
+#define CLE266_PLL_162_000M    0x00004571
+#define CLE266_PLL_187_000M    0x00000976
+#define CLE266_PLL_193_295M    0x0000086C
+#define CLE266_PLL_202_500M    0x00000763
+#define CLE266_PLL_204_000M    0x00000764
+#define CLE266_PLL_218_500M    0x0000065C
+#define CLE266_PLL_234_000M    0x00000662
+#define CLE266_PLL_267_250M    0x00000670
+#define CLE266_PLL_297_500M    0x000005E6
+#define CLE266_PLL_74_481M     0x0000051A
+#define CLE266_PLL_172_798M    0x00004579
+#define CLE266_PLL_122_614M    0x0000073C
+
+/* K800 PLL value
+*/
+#define K800_PLL_25_175M     0x00539001
+#define K800_PLL_26_880M     0x001C8C80
+#define K800_PLL_29_581M     0x00409080
+#define K800_PLL_31_490M     0x006F9001
+#define K800_PLL_31_500M     0x008B9002
+#define K800_PLL_31_728M     0x00AF9003
+#define K800_PLL_32_668M     0x00909002
+#define K800_PLL_36_000M     0x009F9002
+#define K800_PLL_40_000M     0x00578C02
+#define K800_PLL_41_291M     0x00438C01
+#define K800_PLL_43_163M     0x00778C03
+#define K800_PLL_45_250M     0x007D8C83	/* 45.46MHz */
+#define K800_PLL_46_000M     0x00658C02
+#define K800_PLL_46_996M     0x00818C83
+#define K800_PLL_48_000M     0x00848C83
+#define K800_PLL_48_875M     0x00508C81
+#define K800_PLL_49_500M     0x00518C01
+#define K800_PLL_52_406M     0x00738C02
+#define K800_PLL_52_977M     0x00928C83
+#define K800_PLL_56_250M     0x007C8C02
+#define K800_PLL_60_466M     0x00A78C83
+#define K800_PLL_61_500M     0x00AA8C83
+#define K800_PLL_65_000M     0x006B8C01
+#define K800_PLL_65_178M     0x00B48C83
+#define K800_PLL_66_750M     0x00948C82	/* 67.116MHz */
+#define K800_PLL_68_179M     0x00708C01
+#define K800_PLL_69_924M     0x00C18C83
+#define K800_PLL_70_159M     0x00C28C83
+#define K800_PLL_72_000M     0x009F8C82
+#define K800_PLL_74_270M     0x00ce0c03
+#define K800_PLL_78_750M     0x00408801
+#define K800_PLL_80_136M     0x00428801
+#define K800_PLL_83_375M     0x005B0882
+#define K800_PLL_83_950M     0x00738803
+#define K800_PLL_84_750M     0x00748883	/* 84.477MHz */
+#define K800_PLL_85_860M     0x00768883
+#define K800_PLL_88_750M     0x007A8883
+#define K800_PLL_94_500M     0x00828803
+#define K800_PLL_97_750M     0x00878883
+#define K800_PLL_101_000M    0x008B8883
+#define K800_PLL_106_500M    0x00758882	/* 106.491463 MHz */
+#define K800_PLL_108_000M    0x00778882
+#define K800_PLL_113_309M    0x005D8881
+#define K800_PLL_118_840M    0x00A48883
+#define K800_PLL_119_000M    0x00838882
+#define K800_PLL_121_750M    0x00A88883	/* 121.704MHz */
+#define K800_PLL_125_104M    0x00688801
+#define K800_PLL_133_308M    0x005D8801
+#define K800_PLL_135_000M    0x001A4081
+#define K800_PLL_136_700M    0x00BD8883
+#define K800_PLL_138_400M    0x00728881
+#define K800_PLL_146_760M    0x00CC8883
+#define K800_PLL_148_500M    0x00ce0803
+#define K800_PLL_153_920M    0x00548482
+#define K800_PLL_156_000M    0x006B8483
+#define K800_PLL_157_500M    0x00142080
+#define K800_PLL_162_000M    0x006F8483
+#define K800_PLL_187_000M    0x00818483
+#define K800_PLL_193_295M    0x004F8481
+#define K800_PLL_202_500M    0x00538481
+#define K800_PLL_204_000M    0x008D8483
+#define K800_PLL_218_500M    0x00978483
+#define K800_PLL_234_000M    0x00608401
+#define K800_PLL_267_250M    0x006E8481
+#define K800_PLL_297_500M    0x00A48402
+#define K800_PLL_74_481M     0x007B8C81
+#define K800_PLL_172_798M    0x00778483
+#define K800_PLL_122_614M    0x00878882
+
+/* PLL for VT3324 */
+#define CX700_25_175M     0x008B1003
+#define CX700_26_719M     0x00931003
+#define CX700_26_880M     0x00941003
+#define CX700_29_581M     0x00A49003
+#define CX700_31_490M     0x00AE1003
+#define CX700_31_500M     0x00AE1003
+#define CX700_31_728M     0x00AF1003
+#define CX700_32_668M     0x00B51003
+#define CX700_36_000M     0x00C81003
+#define CX700_40_000M     0x006E0C03
+#define CX700_41_291M     0x00710C03
+#define CX700_43_163M     0x00770C03
+#define CX700_45_250M     0x007D0C03	/* 45.46MHz */
+#define CX700_46_000M     0x007F0C03
+#define CX700_46_996M     0x00818C83
+#define CX700_48_000M     0x00840C03
+#define CX700_48_875M     0x00508C81
+#define CX700_49_500M     0x00880C03
+#define CX700_52_406M     0x00730C02
+#define CX700_52_977M     0x00920C03
+#define CX700_56_250M     0x009B0C03
+#define CX700_60_466M     0x00460C00
+#define CX700_61_500M     0x00AA0C03
+#define CX700_65_000M     0x006B0C01
+#define CX700_65_178M     0x006B0C01
+#define CX700_66_750M     0x00940C02	/*67.116MHz */
+#define CX700_68_179M     0x00BC0C03
+#define CX700_69_924M     0x00C10C03
+#define CX700_70_159M     0x00C20C03
+#define CX700_72_000M     0x009F0C02
+#define CX700_74_270M     0x00CE0C03
+#define CX700_74_481M     0x00CE0C03
+#define CX700_78_750M     0x006C0803
+#define CX700_80_136M     0x006E0803
+#define CX700_83_375M     0x005B0882
+#define CX700_83_950M     0x00730803
+#define CX700_84_750M     0x00740803	/* 84.537Mhz */
+#define CX700_85_860M     0x00760803
+#define CX700_88_750M     0x00AC8885
+#define CX700_94_500M     0x00820803
+#define CX700_97_750M     0x00870803
+#define CX700_101_000M    0x008B0803
+#define CX700_106_500M    0x00750802
+#define CX700_108_000M    0x00950803
+#define CX700_113_309M    0x005D0801
+#define CX700_118_840M    0x00A40803
+#define CX700_119_000M    0x00830802
+#define CX700_121_750M    0x00420800	/* 121.704MHz */
+#define CX700_125_104M    0x00AD0803
+#define CX700_133_308M    0x00930802
+#define CX700_135_000M    0x00950802
+#define CX700_136_700M    0x00BD0803
+#define CX700_138_400M    0x00720801
+#define CX700_146_760M    0x00CC0803
+#define CX700_148_500M    0x00a40802
+#define CX700_153_920M    0x00540402
+#define CX700_156_000M    0x006B0403
+#define CX700_157_500M    0x006C0403
+#define CX700_162_000M    0x006F0403
+#define CX700_172_798M    0x00770403
+#define CX700_187_000M    0x00810403
+#define CX700_193_295M    0x00850403
+#define CX700_202_500M    0x008C0403
+#define CX700_204_000M    0x008D0403
+#define CX700_218_500M    0x00970403
+#define CX700_234_000M    0x00600401
+#define CX700_267_250M    0x00B90403
+#define CX700_297_500M    0x00CE0403
+#define CX700_122_614M    0x00870802
+
+/* Definition CRTC Timing Index */
+#define H_TOTAL_INDEX               0
+#define H_ADDR_INDEX                1
+#define H_BLANK_START_INDEX         2
+#define H_BLANK_END_INDEX           3
+#define H_SYNC_START_INDEX          4
+#define H_SYNC_END_INDEX            5
+#define V_TOTAL_INDEX               6
+#define V_ADDR_INDEX                7
+#define V_BLANK_START_INDEX         8
+#define V_BLANK_END_INDEX           9
+#define V_SYNC_START_INDEX          10
+#define V_SYNC_END_INDEX            11
+#define H_TOTAL_SHADOW_INDEX        12
+#define H_BLANK_END_SHADOW_INDEX    13
+#define V_TOTAL_SHADOW_INDEX        14
+#define V_ADDR_SHADOW_INDEX         15
+#define V_BLANK_SATRT_SHADOW_INDEX  16
+#define V_BLANK_END_SHADOW_INDEX    17
+#define V_SYNC_SATRT_SHADOW_INDEX   18
+#define V_SYNC_END_SHADOW_INDEX     19
+
+/* Definition Video Mode Pixel Clock (picoseconds)
+*/
+#define RES_480X640_60HZ_PIXCLOCK    39722
+#define RES_640X480_60HZ_PIXCLOCK    39722
+#define RES_640X480_75HZ_PIXCLOCK    31747
+#define RES_640X480_85HZ_PIXCLOCK    27777
+#define RES_640X480_100HZ_PIXCLOCK   23168
+#define RES_640X480_120HZ_PIXCLOCK   19081
+#define RES_720X480_60HZ_PIXCLOCK    37020
+#define RES_720X576_60HZ_PIXCLOCK    30611
+#define RES_800X600_60HZ_PIXCLOCK    25000
+#define RES_800X600_75HZ_PIXCLOCK    20203
+#define RES_800X600_85HZ_PIXCLOCK    17777
+#define RES_800X600_100HZ_PIXCLOCK   14667
+#define RES_800X600_120HZ_PIXCLOCK   11912
+#define RES_800X480_60HZ_PIXCLOCK    33805
+#define RES_848X480_60HZ_PIXCLOCK    31756
+#define RES_856X480_60HZ_PIXCLOCK    31518
+#define RES_1024X512_60HZ_PIXCLOCK   24218
+#define RES_1024X600_60HZ_PIXCLOCK   20460
+#define RES_1024X768_60HZ_PIXCLOCK   15385
+#define RES_1024X768_75HZ_PIXCLOCK   12699
+#define RES_1024X768_85HZ_PIXCLOCK   10582
+#define RES_1024X768_100HZ_PIXCLOCK  8825
+#define RES_1152X864_75HZ_PIXCLOCK   9259
+#define RES_1280X768_60HZ_PIXCLOCK   12480
+#define RES_1280X800_60HZ_PIXCLOCK   11994
+#define RES_1280X960_60HZ_PIXCLOCK   9259
+#define RES_1280X1024_60HZ_PIXCLOCK  9260
+#define RES_1280X1024_75HZ_PIXCLOCK  7408
+#define RES_1280X768_85HZ_PIXCLOCK   6349
+#define RES_1440X1050_60HZ_PIXCLOCK  7993
+#define RES_1600X1200_60HZ_PIXCLOCK  6172
+#define RES_1600X1200_75HZ_PIXCLOCK  4938
+#define RES_1280X720_60HZ_PIXCLOCK   13426
+#define RES_1920X1080_60HZ_PIXCLOCK  5787
+#define RES_1400X1050_60HZ_PIXCLOCK  8214
+#define RES_1400X1050_75HZ_PIXCLOCK  6410
+#define RES_1368X768_60HZ_PIXCLOCK   11647
+#define RES_960X600_60HZ_PIXCLOCK      22099
+#define RES_1000X600_60HZ_PIXCLOCK    20834
+#define RES_1024X576_60HZ_PIXCLOCK    21278
+#define RES_1088X612_60HZ_PIXCLOCK    18877
+#define RES_1152X720_60HZ_PIXCLOCK    14981
+#define RES_1200X720_60HZ_PIXCLOCK    14253
+#define RES_1280X600_60HZ_PIXCLOCK    16260
+#define RES_1280X720_50HZ_PIXCLOCK    16538
+#define RES_1280X768_50HZ_PIXCLOCK    15342
+#define RES_1366X768_50HZ_PIXCLOCK    14301
+#define RES_1366X768_60HZ_PIXCLOCK    11646
+#define RES_1360X768_60HZ_PIXCLOCK    11799
+#define RES_1440X900_60HZ_PIXCLOCK    9390
+#define RES_1440X900_75HZ_PIXCLOCK    7315
+#define RES_1600X900_60HZ_PIXCLOCK    8415
+#define RES_1600X1024_60HZ_PIXCLOCK   7315
+#define RES_1680X1050_60HZ_PIXCLOCK   6814
+#define RES_1680X1050_75HZ_PIXCLOCK   5348
+#define RES_1792X1344_60HZ_PIXCLOCK   4902
+#define RES_1856X1392_60HZ_PIXCLOCK   4577
+#define RES_1920X1200_60HZ_PIXCLOCK   5173
+#define RES_1920X1440_60HZ_PIXCLOCK   4274
+#define RES_1920X1440_75HZ_PIXCLOCK   3367
+#define RES_2048X1536_60HZ_PIXCLOCK   3742
+
+#define RES_1360X768_RB_60HZ_PIXCLOCK 13889
+#define RES_1400X1050_RB_60HZ_PIXCLOCK 9901
+#define RES_1440X900_RB_60HZ_PIXCLOCK   11268
+#define RES_1600X900_RB_60HZ_PIXCLOCK   10230
+#define RES_1680X1050_RB_60HZ_PIXCLOCK 8403
+#define RES_1920X1080_RB_60HZ_PIXCLOCK 7225
+#define RES_1920X1200_RB_60HZ_PIXCLOCK 6497
+
+/* LCD display method
+*/
+#define     LCD_EXPANDSION              0x00
+#define     LCD_CENTERING               0x01
+
+/* LCD mode
+*/
+#define     LCD_OPENLDI               0x00
+#define     LCD_SPWG                  0x01
+
+/* Define display timing
+*/
+struct display_timing {
+	u16 hor_total;
+	u16 hor_addr;
+	u16 hor_blank_start;
+	u16 hor_blank_end;
+	u16 hor_sync_start;
+	u16 hor_sync_end;
+	u16 ver_total;
+	u16 ver_addr;
+	u16 ver_blank_start;
+	u16 ver_blank_end;
+	u16 ver_sync_start;
+	u16 ver_sync_end;
+};
+
+struct crt_mode_table {
+	int refresh_rate;
+	unsigned long clk;
+	int h_sync_polarity;
+	int v_sync_polarity;
+	struct display_timing crtc;
+};
+
+struct io_reg {
+	int port;
+	u8 index;
+	u8 mask;
+	u8 value;
+};
+
+#endif /* __SHARE_H__ */
--- /dev/null
+++ b/drivers/video/viafb/tbl1636.c
@@ -0,0 +1,71 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+struct IODATA COMMON_INIT_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	/* Set panel power sequence timing */
+	{0x10, 0xC0, 0x00},
+	/* T1: VDD on - Data on. Each increment is 1 ms. (50ms = 031h) */
+	{0x0B, 0xFF, 0x40},
+	/* T2: Data on - Backlight on. Each increment is 2 ms. (210ms = 068h) */
+	{0x0C, 0xFF, 0x31},
+	/* T3: Backlight off -Data off. Each increment is 2 ms. (210ms = 068h)*/
+	{0x0D, 0xFF, 0x31},
+	/* T4: Data off - VDD off. Each increment is 1 ms. (50ms = 031h) */
+	{0x0E, 0xFF, 0x68},
+	/* T5: VDD off - VDD on. Each increment is 100 ms. (500ms = 04h) */
+	{0x0F, 0xFF, 0x68},
+	/* LVDS output power up */
+	{0x09, 0xA0, 0xA0},
+	/* turn on back light */
+	{0x10, 0x33, 0x13}
+};
+
+struct IODATA DUAL_CHANNEL_ENABLE_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x08, 0xF0, 0xE0}	/* Input Data Mode Select */
+};
+
+struct IODATA SINGLE_CHANNEL_ENABLE_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x08, 0xF0, 0x00}	/* Input Data Mode Select */
+};
+
+struct IODATA DITHERING_ENABLE_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x0A, 0x70, 0x50}
+};
+
+struct IODATA DITHERING_DISABLE_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x0A, 0x70, 0x00}
+};
+
+struct IODATA VDD_ON_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x10, 0x20, 0x20}
+};
+
+struct IODATA VDD_OFF_TBL_VT1636[] = {
+/*  Index, Mask, Value */
+	{0x10, 0x20, 0x00}
+};
--- /dev/null
+++ b/drivers/video/viafb/tbl1636.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TBL1636_H_
+#define _TBL1636_H_
+#include "hw.h"
+
+extern struct IODATA COMMON_INIT_TBL_VT1636[8];
+extern struct IODATA DUAL_CHANNEL_ENABLE_TBL_VT1636[1];
+extern struct IODATA SINGLE_CHANNEL_ENABLE_TBL_VT1636[1];
+extern struct IODATA DITHERING_ENABLE_TBL_VT1636[1];
+extern struct IODATA DITHERING_DISABLE_TBL_VT1636[1];
+extern struct IODATA VDD_ON_TBL_VT1636[1];
+extern struct IODATA VDD_OFF_TBL_VT1636[1];
+
+#endif /* _VIA_TBL1636_H_ */
--- /dev/null
+++ b/drivers/video/viafb/tblDPASetting.c
@@ -0,0 +1,109 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+/* For VT3324: */
+struct VT1636_DPA_SETTING VT1636_DPA_SETTING_TBL_VT3324[] = {
+	/* Panel ID,       CLK_SEL_ST1[09],    CLK_SEL_ST2[08] */
+	{LCD_PANEL_ID0_640X480, 0x00, 0x00},	/* For 640x480   */
+	{LCD_PANEL_ID1_800X600, 0x00, 0x00},	/* For 800x600   */
+	{LCD_PANEL_ID2_1024X768, 0x00, 0x00},	/* For 1024x768  */
+	{LCD_PANEL_ID3_1280X768, 0x00, 0x00},	/* For 1280x768  */
+	{LCD_PANEL_ID4_1280X1024, 0x00, 0x00},	/* For 1280x1024 */
+	{LCD_PANEL_ID5_1400X1050, 0x00, 0x00},	/* For 1400x1050 */
+	{LCD_PANEL_ID6_1600X1200, 0x0B, 0x03}	/* For 1600x1200 */
+};
+
+struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3324[] = {
+/*  ClkRange, DVP0, DVP0DataDriving,  DVP0ClockDriving, DVP1,
+					DVP1Driving, DFPHigh, DFPLow */
+/*  CR96, SR2A[5], SR1B[1], SR2A[4], SR1E[2], CR9B,
+					SR65,        CR97,    CR99   */
+	/* LCK/VCK < 30000000 will use this value */
+	{DPA_CLK_RANGE_30M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+	 0x00},
+	/* 30000000 < LCK/VCK < 50000000 will use this value */
+	{DPA_CLK_RANGE_30_50M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+	 0x00},
+	/* 50000000 < LCK/VCK < 70000000 will use this value */
+	{DPA_CLK_RANGE_50_70M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
+	 0x00},
+	/* 70000000 < LCK/VCK < 100000000 will use this value */
+	{DPA_CLK_RANGE_70_100M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
+	 0x00},
+	/* 100000000 < LCK/VCK < 15000000 will use this value */
+	{DPA_CLK_RANGE_100_150M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
+	 0x00},
+	/* 15000000 < LCK/VCK will use this value */
+	{DPA_CLK_RANGE_150M, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x00,
+	 0x00},
+};
+
+/* For VT3327: */
+struct VT1636_DPA_SETTING VT1636_DPA_SETTING_TBL_VT3327[] = {
+	/* Panel ID,       CLK_SEL_ST1[09],    CLK_SEL_ST2[08] */
+	{LCD_PANEL_ID0_640X480, 0x00, 0x00},	/* For 640x480   */
+	{LCD_PANEL_ID1_800X600, 0x00, 0x00},	/* For 800x600   */
+	{LCD_PANEL_ID2_1024X768, 0x00, 0x00},	/* For 1024x768  */
+	{LCD_PANEL_ID3_1280X768, 0x00, 0x00},	/* For 1280x768  */
+	{LCD_PANEL_ID4_1280X1024, 0x00, 0x00},	/* For 1280x1024 */
+	{LCD_PANEL_ID5_1400X1050, 0x00, 0x00},	/* For 1400x1050 */
+	{LCD_PANEL_ID6_1600X1200, 0x00, 0x00}	/* For 1600x1200 */
+};
+
+struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3327[] = {
+/*  ClkRange,DVP0, DVP0DataDriving,  DVP0ClockDriving, DVP1,
+					DVP1Driving, DFPHigh,   DFPLow */
+/*   CR96, SR2A[5], SR1B[1], SR2A[4], SR1E[2], CR9B,
+					SR65,        CR97,      CR99   */
+/* LCK/VCK < 30000000 will use this value */
+{DPA_CLK_RANGE_30M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x01},
+/* 30000000 < LCK/VCK < 50000000 will use this value */
+{DPA_CLK_RANGE_30_50M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x01},
+/* 50000000 < LCK/VCK < 70000000 will use this value */
+{DPA_CLK_RANGE_50_70M, 0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x01},
+/* 70000000 < LCK/VCK < 100000000 will use this value */
+{DPA_CLK_RANGE_70_100M, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x03},
+/* 100000000 < LCK/VCK < 15000000 will use this value */
+{DPA_CLK_RANGE_100_150M, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x02},
+/* 15000000 < LCK/VCK will use this value */
+{DPA_CLK_RANGE_150M, 0x00, 0x20, 0x00, 0x10, 0x00, 0x03, 0x00, 0x0D, 0x03},
+};
+
+/* For VT3364: */
+struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3364[] = {
+/*  ClkRange,DVP0, DVP0DataDriving,  DVP0ClockDriving, DVP1,
+					DVP1Driving, DFPHigh,   DFPLow */
+/*   CR96, SR2A[5], SR1B[1], SR2A[4], SR1E[2], CR9B,
+					SR65,        CR97,      CR99   */
+/* LCK/VCK < 30000000 will use this value */
+{DPA_CLK_RANGE_30M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x08},
+/* 30000000 < LCK/VCK < 50000000 will use this value */
+{DPA_CLK_RANGE_30_50M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x08},
+/* 50000000 < LCK/VCK < 70000000 will use this value */
+{DPA_CLK_RANGE_50_70M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x08},
+/* 70000000 < LCK/VCK < 100000000 will use this value */
+{DPA_CLK_RANGE_70_100M, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x08},
+/* 100000000 < LCK/VCK < 15000000 will use this value */
+{DPA_CLK_RANGE_100_150M, 0x03, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x08},
+/* 15000000 < LCK/VCK will use this value */
+{DPA_CLK_RANGE_150M, 0x01, 0x00, 0x02, 0x10, 0x00, 0x03, 0x00, 0x00, 0x08},
+};
--- /dev/null
+++ b/drivers/video/viafb/tblDPASetting.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TBLDPASETTING_H_
+#define _TBLDPASETTING_H_
+#include "global.h"
+
+#define DPA_CLK_30M       30000000
+#define DPA_CLK_50M       50000000
+#define DPA_CLK_70M       70000000
+#define DPA_CLK_100M      100000000
+#define DPA_CLK_150M      150000000
+
+enum DPA_RANGE {
+	DPA_CLK_RANGE_30M,
+	DPA_CLK_RANGE_30_50M,
+	DPA_CLK_RANGE_50_70M,
+	DPA_CLK_RANGE_70_100M,
+	DPA_CLK_RANGE_100_150M,
+	DPA_CLK_RANGE_150M
+};
+
+extern struct VT1636_DPA_SETTING VT1636_DPA_SETTING_TBL_VT3324[7];
+extern struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3324[6];
+extern struct VT1636_DPA_SETTING VT1636_DPA_SETTING_TBL_VT3327[7];
+extern struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3327[];
+extern struct GFX_DPA_SETTING GFX_DPA_SETTING_TBL_VT3364[6];
+
+#endif
--- /dev/null
+++ b/drivers/video/viafb/viafbdev.c
@@ -0,0 +1,2775 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef MODULE
+#include <linux/module.h>
+#endif
+#define _MASTER_FILE
+
+#include "global.h"
+
+static int MAX_CURS = 32;
+static struct fb_var_screeninfo default_var;
+static char *viafb_name = "Via";
+static u32 pseudo_pal[17];
+
+/* video mode */
+static char *mode = "640x480";
+static char *mode1 = "640x480";
+static int resMode = VIA_RES_640X480;
+
+int video_on_crt;
+int video_on_dvi;
+int video_on_lcd;
+
+/* Added for specifying active devices.*/
+char *active_dev = "";
+
+/* Added for specifying video on devices.*/
+char *video_dev = "";
+
+/*Added for specify lcd output port*/
+char *lcd_port = "";
+char *dvi_port = "";
+
+/* Display Mode Information */
+int refresh1 = 60;
+static int timer_on;
+struct timer_list timer_for3D;
+
+static struct fb_ops viafb_ops;
+void init_global_var(void)
+{
+	second_virtual_yres = 0;
+	second_virtual_xres = 0;
+	second_offset = 0;
+	second_size = 0;
+	SAMM_ON = 0;
+	dual_fb = 0;
+	LCD2_ON = 0;
+	LCD_ON = 0;
+	DVI_ON = 0;
+	via_fb_accel = 0;
+	via_fb_hotplug = 0;
+	via_fb_memsize = 0;
+	video_on_crt = 0;
+	video_on_dvi = 0;
+	video_on_lcd = 0;
+	timer_on = 0;
+}
+
+void get_panel_max_scal_size(struct _panel_size_pos_info *p_max_size)
+{
+	switch (p_max_size->device_type) {
+	case DVI_Device:
+		p_max_size->x = p_max_size->y = 0;
+		break;
+	default:
+		p_max_size->x = p_max_size->y = 0;
+	}
+}
+void get_panel_max_scal_pos(struct _panel_size_pos_info *p_para)
+{
+	switch (p_para->device_type) {
+	case DVI_Device:
+		p_para->x = p_para->y = 0;
+		break;
+	default:
+		p_para->x = p_para->y = 0;
+	}
+}
+
+void get_panel_scal_pos(struct _panel_size_pos_info *p_para)
+{
+	switch (p_para->device_type) {
+	case DVI_Device:
+		p_para->x = p_para->y = 0;
+		break;
+	default:
+		p_para->x = p_para->y = 0;
+	}
+}
+void get_panel_scal_size(struct _panel_size_pos_info *p_para)
+{
+	switch (p_para->device_type) {
+	case DVI_Device:
+		p_para->x = p_para->y = 0;
+		break;
+	default:
+		p_para->x = p_para->y = 0;
+	}
+}
+
+void set_panel_scal_pos(struct _panel_size_pos_info *p_para)
+{
+	switch (p_para->device_type) {
+	case DVI_Device:
+		break;
+	default:
+		;
+	}
+}
+
+void set_panel_scal_size(struct _panel_size_pos_info *p_para)
+{
+	switch (p_para->device_type) {
+	case DVI_Device:
+		break;
+	default:
+		;
+	}
+}
+
+static int viafb_get_fix(struct fb_fix_screeninfo *fix, struct fb_info *info)
+{
+	struct viafb_par *ppar;
+	ppar = info->par;
+
+	DEBUG_MSG(KERN_INFO "viafb_get_fix!\n");
+
+	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+	strcpy(fix->id, viafb_name);
+
+	fix->smem_start = ppar->fbmem;
+	fix->smem_len = ppar->fbmem_free;
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->type_aux = 0;
+
+	fix->visual =
+	    ppar->bpp == 8 ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+
+	fix->xpanstep = fix->ywrapstep = 0;
+	fix->ypanstep = 1;
+	fix->line_length = ppar->linelength;
+
+	fix->mmio_start = ppar->mmio_base;
+	fix->mmio_len = ppar->mmio_len;
+
+	if (via_fb_accel)
+		fix->accel = FB_ACCEL_VIA_UNICHROME;
+	else
+		fix->accel = FB_ACCEL_NONE;
+
+	return 0;
+}
+
+static int viafb_open(struct fb_info *info, int user)
+{
+	DEBUG_MSG(KERN_INFO "viafb_open!\n");
+	return 0;
+}
+
+static int viafb_release(struct fb_info *info, int user)
+{
+	DEBUG_MSG(KERN_INFO "viafb_release!\n");
+	return 0;
+}
+
+static int viafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	int vres, vfront, vback, vsync;
+	int vmode_index;
+	struct viafb_par *ppar;
+	ppar = info->par;
+
+	DEBUG_MSG(KERN_INFO "viafb_check_var!\n");
+	vmode_index = get_mode_index(var->xres, var->yres, 0);
+	if (vmode_index == VIA_RES_INVALID) {
+		DEBUG_MSG(KERN_INFO
+			  "viafb: Mode %dx%dx%d not supported!!\n",
+			  var->xres, var->yres, var->bits_per_pixel);
+		return -EINVAL;
+	}
+	/* convert from picoseconds to MHz */
+	refresh = get_refresh(var->xres, var->yres, var->pixclock);
+	if (24 == var->bits_per_pixel)
+		var->bits_per_pixel = 32;
+	if ((var->xres_virtual * (var->bits_per_pixel >> 3)) & 0x1F)
+		/*32 pixel alignment */
+		var->xres_virtual = (var->xres_virtual + 31) & ~31;
+
+	/*Fill var's time information according our table,
+	   or fbset will show wrong information */
+	fill_var_timing_info(var, refresh, vmode_index);
+
+	ppar->var = *var;
+	ppar->bpp = var->bits_per_pixel;
+
+	if (ppar->bpp == 24)
+		ppar->bpp = 32;
+
+	/*It seems that it is not possible, because it is 32 byte align now */
+	ppar->linelength = ((var->xres_virtual + 7) & ~7) * ppar->bpp / 8;
+
+	switch (ppar->bpp) {
+	case 8:
+		ppar->var.red.offset = 0;
+		ppar->var.green.offset = 0;
+		ppar->var.blue.offset = 0;
+		ppar->var.red.length = 6;
+		ppar->var.green.length = 6;
+		ppar->var.blue.length = 6;
+		break;
+	case 16:
+		ppar->var.red.offset = 11;
+		ppar->var.green.offset = 5;
+		ppar->var.blue.offset = 0;
+		ppar->var.red.length = 5;
+		ppar->var.green.length = 6;
+		ppar->var.blue.length = 5;
+		break;
+	case 32:
+		ppar->var.red.offset = 16;
+		ppar->var.green.offset = 8;
+		ppar->var.blue.offset = 0;
+		ppar->var.red.length = 8;
+		ppar->var.green.length = 8;
+		ppar->var.blue.length = 8;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ppar->vclk = 1000000 / var->pixclock;
+
+	if (ppar->bpp == 32)
+		ppar->vclk *= 2;
+
+	ppar->hres = var->xres;
+	vres = ppar->vres = var->yres;
+
+	/* See if requested resolution fits in available memory */
+	if (ppar->hres * ppar->vres * ppar->bpp / 8 > ppar->memsize)
+		return -EINVAL;
+
+	vfront = var->upper_margin;
+	vback = var->lower_margin;
+	vsync = var->vsync_len;
+
+	/* Compute horizontal and vertical VGA CRTC timing values */
+	if (var->vmode & FB_VMODE_INTERLACED) {
+		vres /= 2;
+		vfront /= 2;
+		vback /= 2;
+		vsync /= 2;
+	}
+
+	if (var->vmode & FB_VMODE_DOUBLE) {
+		vres *= 2;
+		vfront *= 2;
+		vback *= 2;
+		vsync *= 2;
+	}
+
+	ppar->htotal =
+	    (ppar->hres + var->left_margin + var->right_margin +
+	     var->hsync_len) / 8 - 10;
+	ppar->hdispend = ppar->hres / 8 - 1;
+	ppar->hsyncstart = (ppar->hres + var->right_margin) / 8;
+	ppar->hsyncend = var->hsync_len / 8;
+	ppar->hblankstart = ppar->hdispend + 1;
+	ppar->hblankend = ppar->htotal + 5;
+
+	ppar->vtotal = vres + vfront + vback + vsync - 2;
+	ppar->vdispend = vres - 1;
+	ppar->vsyncstart = vres + vback;
+	ppar->vsyncend = vsync;
+	ppar->vblankstart = vres;
+	ppar->vblankend = ppar->vtotal + 2;
+	info->var = ppar->var;
+	return 0;
+}
+
+static int viafb_set_par(struct fb_info *info)
+{
+	int vmode_index;
+	int vmode_index1 = 0;
+	DEBUG_MSG(KERN_INFO "viafb_set_par!\n");
+
+	refresh =
+	    get_refresh(info->var.xres, info->var.yres, info->var.pixclock);
+
+	update_device_setting(info->var.xres, info->var.yres,
+			      info->var.bits_per_pixel, refresh, 0);
+
+	vmode_index = get_mode_index(info->var.xres, info->var.yres, 0);
+
+	if (SAMM_ON == 1) {
+		DEBUG_MSG(KERN_INFO
+			  "second_xres=%d, second_yres=%d, bpp=%d\n",
+			  second_xres, second_yres, via_fb_bpp1);
+		vmode_index1 = get_mode_index(second_xres, second_yres, 1);
+		DEBUG_MSG(KERN_INFO "->SAMM_ON: index=%d\n", vmode_index1);
+
+		update_device_setting(second_xres, second_yres, via_fb_bpp1,
+				      refresh1, 1);
+	}
+
+	if (vmode_index != VIA_RES_INVALID) {
+		setmode(vmode_index, info->var.xres, info->var.yres,
+			info->var.bits_per_pixel, vmode_index1,
+			second_xres, second_yres, via_fb_bpp1);
+
+		/*We should set memory offset according virtual_x */
+		/*Fix me:put this function into setmode */
+		memory_pitch_patch(info);
+
+		viafb_check_var(&info->var, info);
+		viafb_get_fix(&info->fix, info);
+
+		via_fb_bpp = info->var.bits_per_pixel;
+
+		if (via_fb_accel)
+			set_2d_color_depth(info->var.bits_per_pixel);
+	}
+
+	return 0;
+}
+
+static int viafb_get_cmap_len(struct fb_var_screeninfo *var)
+{
+	DEBUG_MSG(KERN_INFO "viafb_get_cmap_len!\n");
+
+	return (var->bits_per_pixel == 8) ? 256 : 16;
+}
+
+/* Set one color register */
+static int viafb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			   unsigned blue, unsigned transp, struct fb_info *info)
+{
+	u8 sr1a, sr1b, cr67, cr6a, rev = 0, shift = 10;
+	DEBUG_MSG(KERN_INFO "viafb_setcolreg!\n");
+	if (regno >= viafb_get_cmap_len(&info->var))
+		return 1;
+	if (UNICHROME_CLE266 == chip_info.gfx_chip_name) {
+	/* Read PCI bus 0,dev 0,function 0,index 0xF6 to get chip rev. */
+		outl(0x80000000 | (0xf6 & ~3), (unsigned long)0xCF8);
+		rev = (inl((unsigned long)0xCFC) >> ((0xf6 & 3) * 8)) & 0xff;
+	}
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		outb(0x1A, 0x3C4);
+		sr1a = inb(0x3C5);
+		outb(0x1B, 0x3C4);
+		sr1b = inb(0x3C5);
+		outb(0x67, 0x3D4);
+		cr67 = inb(0x3D5);
+		outb(0x6A, 0x3D4);
+		cr6a = inb(0x3D5);
+
+		/* Map the 3C6/7/8/9 to the IGA2 */
+		outb(0x1A, 0x3C4);
+		outb(sr1a | 0x01, 0x3C5);
+		/* Second Display Engine colck always on */
+		outb(0x1B, 0x3C4);
+		outb(sr1b | 0x80, 0x3C5);
+		/* Second Display Color Depth 8 */
+		outb(0x67, 0x3D4);
+		outb(cr67 & 0x3F, 0x3D5);
+		outb(0x6A, 0x3D4);
+		/* Second Display Channel Reset CR6A[6]) */
+		outb(cr6a & 0xBF, 0x3D5);
+		/* Second Display Channel Enable CR6A[7] */
+		outb(cr6a | 0x80, 0x3D5);
+		/* Second Display Channel stop reset) */
+		outb(cr6a | 0x40, 0x3D5);
+
+		/* Bit mask of palette */
+		outb(0xFF, 0x3c6);
+		/* Write one register of IGA2 */
+		outb(regno, 0x3C8);
+		if (UNICHROME_CLE266 == chip_info.gfx_chip_name && rev >= 15) {
+			shift = 8;
+			write_reg_mask(CR6A, VIACR, BIT5, BIT5);
+			write_reg_mask(SR15, VIASR, BIT7, BIT7);
+		} else {
+			shift = 10;
+			write_reg_mask(CR6A, VIACR, 0, BIT5);
+			write_reg_mask(SR15, VIASR, 0, BIT7);
+		}
+		outb(red >> shift, 0x3C9);
+		outb(green >> shift, 0x3C9);
+		outb(blue >> shift, 0x3C9);
+
+		/* Map the 3C6/7/8/9 to the IGA1 */
+		outb(0x1A, 0x3C4);
+		outb(sr1a & 0xFE, 0x3C5);
+		/* Bit mask of palette */
+		outb(0xFF, 0x3c6);
+		/* Write one register of IGA1 */
+		outb(regno, 0x3C8);
+		outb(red >> shift, 0x3C9);
+		outb(green >> shift, 0x3C9);
+		outb(blue >> shift, 0x3C9);
+
+		outb(0x1A, 0x3C4);
+		outb(sr1a, 0x3C5);
+		outb(0x1B, 0x3C4);
+		outb(sr1b, 0x3C5);
+		outb(0x67, 0x3D4);
+		outb(cr67, 0x3D5);
+		outb(0x6A, 0x3D4);
+		outb(cr6a, 0x3D5);
+		break;
+	case 16:
+		((u32 *) info->pseudo_palette)[regno] = (red & 0xF800) |
+		    ((green & 0xFC00) >> 5) | ((blue & 0xF800) >> 11);
+		break;
+	case 32:
+		((u32 *) info->pseudo_palette)[regno] =
+		    ((transp & 0xFF00) << 16) |
+		    ((red & 0xFF00) << 8) |
+		    ((green & 0xFF00)) | ((blue & 0xFF00) >> 8);
+		break;
+	}
+
+	return 0;
+
+}
+
+/*CALLED BY: fb_set_cmap */
+/*           fb_set_var, pass 256 colors */
+/*CALLED BY: fb_set_cmap */
+/*           fbcon_set_palette, pass 16 colors */
+static int viafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
+{
+	u32 len = cmap->len;
+	u32 i;
+	u16 *pred = cmap->red;
+	u16 *pgreen = cmap->green;
+	u16 *pblue = cmap->blue;
+	u16 *ptransp = cmap->transp;
+	u8 sr1a, sr1b, cr67, cr6a, rev = 0, shift = 10;
+	if (len > 256)
+		return 1;
+	if (UNICHROME_CLE266 == chip_info.gfx_chip_name) {
+	/* Read PCI bus 0, dev 0, function 0, index 0xF6 to get chip rev. */
+		outl(0x80000000 | (0xf6 & ~3), (unsigned long)0xCF8);
+		rev = (inl((unsigned long)0xCFC) >> ((0xf6 & 3) * 8)) & 0xff;
+	}
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		outb(0x1A, 0x3C4);
+		sr1a = inb(0x3C5);
+		outb(0x1B, 0x3C4);
+		sr1b = inb(0x3C5);
+		outb(0x67, 0x3D4);
+		cr67 = inb(0x3D5);
+		outb(0x6A, 0x3D4);
+		cr6a = inb(0x3D5);
+		/* Map the 3C6/7/8/9 to the IGA2 */
+		outb(0x1A, 0x3C4);
+		outb(sr1a | 0x01, 0x3C5);
+		outb(0x1B, 0x3C4);
+		/* Second Display Engine colck always on */
+		outb(sr1b | 0x80, 0x3C5);
+		outb(0x67, 0x3D4);
+		/* Second Display Color Depth 8 */
+		outb(cr67 & 0x3F, 0x3D5);
+		outb(0x6A, 0x3D4);
+		/* Second Display Channel Reset CR6A[6]) */
+		outb(cr6a & 0xBF, 0x3D5);
+		/* Second Display Channel Enable CR6A[7] */
+		outb(cr6a | 0x80, 0x3D5);
+		/* Second Display Channel stop reset) */
+		outb(cr6a | 0xC0, 0x3D5);
+
+		/* Bit mask of palette */
+		outb(0xFF, 0x3c6);
+		outb(0x00, 0x3C8);
+		if (UNICHROME_CLE266 == chip_info.gfx_chip_name && rev >= 15) {
+			shift = 8;
+			write_reg_mask(CR6A, VIACR, BIT5, BIT5);
+			write_reg_mask(SR15, VIASR, BIT7, BIT7);
+		} else {
+			shift = 10;
+			write_reg_mask(CR6A, VIACR, 0, BIT5);
+			write_reg_mask(SR15, VIASR, 0, BIT7);
+		}
+		for (i = 0; i < len; i++) {
+			outb((*(pred + i)) >> shift, 0x3C9);
+			outb((*(pgreen + i)) >> shift, 0x3C9);
+			outb((*(pblue + i)) >> shift, 0x3C9);
+		}
+
+		outb(0x1A, 0x3C4);
+		/* Map the 3C6/7/8/9 to the IGA1 */
+		outb(sr1a & 0xFE, 0x3C5);
+		/* Bit mask of palette */
+		outb(0xFF, 0x3c6);
+		outb(0x00, 0x3C8);
+		for (i = 0; i < len; i++) {
+			outb((*(pred + i)) >> shift, 0x3C9);
+			outb((*(pgreen + i)) >> shift, 0x3C9);
+			outb((*(pblue + i)) >> shift, 0x3C9);
+		}
+
+		outb(0x1A, 0x3C4);
+		outb(sr1a, 0x3C5);
+		outb(0x1B, 0x3C4);
+		outb(sr1b, 0x3C5);
+		outb(0x67, 0x3D4);
+		outb(cr67, 0x3D5);
+		outb(0x6A, 0x3D4);
+		outb(cr6a, 0x3D5);
+		break;
+	case 16:
+		if (len > 17)
+			return 0;	/* Because static u32 pseudo_pal[17]; */
+		for (i = 0; i < len; i++)
+			((u32 *) info->pseudo_palette)[i] =
+			    (*(pred + i) & 0xF800) |
+			    ((*(pgreen + i) & 0xFC00) >> 5) |
+			    ((*(pblue + i) & 0xF800) >> 11);
+		break;
+	case 32:
+		if (len > 17)
+			return 0;
+		if (ptransp) {
+			for (i = 0; i < len; i++)
+				((u32 *) info->pseudo_palette)[i] =
+				    ((*(ptransp + i) & 0xFF00) << 16) |
+				    ((*(pred + i) & 0xFF00) << 8) |
+				    ((*(pgreen + i) & 0xFF00)) |
+				    ((*(pblue + i) & 0xFF00) >> 8);
+		} else {
+			for (i = 0; i < len; i++)
+				((u32 *) info->pseudo_palette)[i] =
+				    0x00000000 |
+				    ((*(pred + i) & 0xFF00) << 8) |
+				    ((*(pgreen + i) & 0xFF00)) |
+				    ((*(pblue + i) & 0xFF00) >> 8);
+		}
+		break;
+	}
+	return 0;
+}
+
+static int viafb_pan_display(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	unsigned int offset = 0;
+
+	DEBUG_MSG(KERN_INFO "viafb_pan_display!\n");
+
+	offset = (var->xoffset + (var->yoffset * var->xres)) *
+	    var->bits_per_pixel / 16;
+
+	DEBUG_MSG(KERN_INFO "\nviafb_pan_display,offset =%d ", offset);
+
+	write_reg_mask(0x48, 0x3d4, ((offset >> 24) & 0x3), 0x3);
+	write_reg_mask(0x34, 0x3d4, ((offset >> 16) & 0xff), 0xff);
+	write_reg_mask(0x0c, 0x3d4, ((offset >> 8) & 0xff), 0xff);
+	write_reg_mask(0x0d, 0x3d4, (offset & 0xff), 0xff);
+
+	((struct viafb_par *)(info->par))->var.xoffset = var->xoffset;
+	((struct viafb_par *)(info->par))->var.yoffset = var->yoffset;
+	return 0;
+}
+
+static int viafb_blank(int blank_mode, struct fb_info *info)
+{
+	DEBUG_MSG(KERN_INFO "viafb_blank!\n");
+	/* clear DPMS setting */
+
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		/* Screen: On, HSync: On, VSync: On */
+		/* control CRT monitor power management */
+		write_reg_mask(CR36, VIACR, 0x00, BIT4 + BIT5);
+		break;
+	case FB_BLANK_HSYNC_SUSPEND:
+		/* Screen: Off, HSync: Off, VSync: On */
+		/* control CRT monitor power management */
+		write_reg_mask(CR36, VIACR, 0x10, BIT4 + BIT5);
+		break;
+	case FB_BLANK_VSYNC_SUSPEND:
+		/* Screen: Off, HSync: On, VSync: Off */
+		/* control CRT monitor power management */
+		write_reg_mask(CR36, VIACR, 0x20, BIT4 + BIT5);
+		break;
+	case FB_BLANK_POWERDOWN:
+		/* Screen: Off, HSync: Off, VSync: Off */
+		/* control CRT monitor power management */
+		write_reg_mask(CR36, VIACR, 0x30, BIT4 + BIT5);
+		break;
+	}
+
+	return 0;
+}
+
+static int viafb_ioctl(struct fb_info *info, u_int cmd, u_long arg)
+{
+	struct viafb_ioctl_info viainfo;
+	struct viafb_ioctl_mode viamode;
+	struct viafb_ioctl_samm viasamm;
+	struct viafb_driver_version driver_version;
+	struct fb_var_screeninfo sec_var;
+	struct _panel_size_pos_info panel_pos_size_para;
+	u32 state_info = 0;
+	u32 viafb_gamma_table[256];
+	char driver_name[10] = "viafb\0";
+
+	u32 __user *argp = (u32 __user *) arg;
+	u32 gpu32 = 0, ss;
+	u32 video_dev_info = 0;
+	struct viafb_ioctl_setting viafb_setting;
+	struct device_t active_dev;
+	ss = sizeof(active_dev);
+	memset(&active_dev, 0, ss);
+	memset(&viafb_setting, 0, sizeof(viafb_setting));
+
+	DEBUG_MSG(KERN_INFO "viafb_ioctl: 0x%X !!\n", cmd);
+
+	switch (cmd) {
+	case VIAFB_GET_CHIP_INFO:	/*struct chip_information chip_info ; */
+	if (copy_to_user((void __user *)arg, &chip_info, sizeof(chip_info)))
+		return -EFAULT;
+		break;
+	case VIAFB_GET_INFO_SIZE:
+		return put_user(sizeof(viainfo), argp);
+	case VIAFB_GET_INFO:
+		return ioctl_get_viafb_info(arg);
+	case VIAFB_HOTPLUG:
+		return put_user((u32)
+				ioctl_hotplug(info->var.xres,
+					      info->var.yres,
+					      info->var.bits_per_pixel), argp);
+		break;
+	case VIAFB_SET_HOTPLUG_FLAG:
+		if (copy_from_user(&gpu32, argp, sizeof(gpu32)))
+			return -EFAULT;
+		via_fb_hotplug = (gpu32) ? 1 : 0;
+		break;
+	case VIAFB_GET_RESOLUTION:
+		viamode.xres = (u32) via_fb_hotplug_Xres;
+		viamode.yres = (u32) via_fb_hotplug_Yres;
+		viamode.refresh = (u32) via_fb_hotplug_refresh;
+		viamode.bpp = (u32) via_fb_hotplug_bpp;
+		if (SAMM_ON == 1) {
+			viamode.xres_sec = second_xres;
+			viamode.yres_sec = second_yres;
+			viamode.virtual_xres_sec = second_virtual_xres;
+			viamode.virtual_yres_sec = second_virtual_yres;
+			viamode.refresh_sec = refresh1;
+			viamode.bpp_sec = via_fb_bpp1;
+		} else {
+			viamode.xres_sec = 0;
+			viamode.yres_sec = 0;
+			viamode.virtual_xres_sec = 0;
+			viamode.virtual_yres_sec = 0;
+			viamode.refresh_sec = 0;
+			viamode.bpp_sec = 0;
+		}
+		if (copy_to_user((void __user *)arg, &viamode, sizeof(viamode)))
+			return -EFAULT;
+		break;
+	case VIAFB_GET_SAMM_INFO:
+		viasamm.samm_status = SAMM_ON;
+
+		if (SAMM_ON == 1) {
+			if (dual_fb) {
+				viasamm.size_prim = parinfo.fbmem_free;
+				viasamm.size_sec = parinfo1.fbmem_free;
+			} else {
+				if (second_size) {
+					viasamm.size_prim =
+					    parinfo.fbmem_free -
+					    second_size * 1024 * 1024;
+					viasamm.size_sec =
+					    second_size * 1024 * 1024;
+				} else {
+					viasamm.size_prim =
+					    parinfo.fbmem_free >> 1;
+					viasamm.size_sec =
+					    (parinfo.fbmem_free >> 1);
+				}
+			}
+			viasamm.mem_base = parinfo.fbmem;
+			viasamm.offset_sec = second_offset;
+		} else {
+			viasamm.size_prim =
+			    parinfo.memsize - parinfo.fbmem_used;
+			viasamm.size_sec = 0;
+			viasamm.mem_base = parinfo.fbmem;
+			viasamm.offset_sec = 0;
+		}
+
+		if (copy_to_user((void __user *)arg, &viasamm, sizeof(viasamm)))
+			return -EFAULT;
+
+		break;
+	case VIAFB_TURN_ON_OUTPUT_DEVICE:
+		if (copy_from_user(&gpu32, argp, sizeof(gpu32)))
+			return -EFAULT;
+		if (gpu32 & CRT_Device)
+			crt_enable();
+		if (gpu32 & DVI_Device)
+			dvi_enable();
+		if (gpu32 & LCD_Device)
+			lcd_enable();
+		break;
+	case VIAFB_TURN_OFF_OUTPUT_DEVICE:
+		if (copy_from_user(&gpu32, argp, sizeof(gpu32)))
+			return -EFAULT;
+		if (gpu32 & CRT_Device)
+			crt_disable();
+		if (gpu32 & DVI_Device)
+			dvi_disable();
+		if (gpu32 & LCD_Device)
+			lcd_disable();
+		break;
+	case VIAFB_SET_DEVICE:
+		if (copy_from_user(&active_dev, (void *)argp, ss))
+			return -EFAULT;
+		viafb_set_device(active_dev);
+		viafb_set_par(info);
+		break;
+	case VIAFB_GET_DEVICE:
+		active_dev.crt = CRT_ON;
+		active_dev.dvi = DVI_ON;
+		active_dev.lcd = LCD_ON;
+		active_dev.samm = SAMM_ON;
+		active_dev.primary_dev = primary_dev;
+
+		active_dev.lcd_dsp_cent = lcd_dsp_method;
+		active_dev.lcd_panel_id = lcd_panel_id;
+		active_dev.lcd_mode = lcd_mode;
+
+		active_dev.xres = via_fb_hotplug_Xres;
+		active_dev.yres = via_fb_hotplug_Yres;
+
+		active_dev.xres1 = second_xres;
+		active_dev.yres1 = second_yres;
+
+		active_dev.bpp = via_fb_bpp;
+		active_dev.bpp1 = via_fb_bpp1;
+		active_dev.refresh = refresh;
+		active_dev.refresh1 = refresh1;
+
+		active_dev.epia_dvi = platform_epia_dvi;
+		active_dev.lcd_dual_edge = device_lcd_dualedge;
+		active_dev.bus_width = via_bus_width;
+
+		if (copy_to_user((void __user *)arg, &active_dev, ss))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_DRIVER_VERSION:
+		driver_version.iMajorNum = VERSION_MAJOR;
+		driver_version.iKernelNum = VERSION_KERNEL;
+		driver_version.iOSNum = VERSION_OS;
+		driver_version.iMinorNum = VERSION_MINOR;
+
+		if (copy_to_user
+		    ((void __user *)arg, &driver_version,
+		     sizeof(driver_version)))
+			return -EFAULT;
+
+		break;
+
+	case VIAFB_SET_DEVICE_INFO:
+		if (copy_from_user
+		    (&viafb_setting, (void *)argp, sizeof(viafb_setting)))
+			return -EFAULT;
+		if (apply_device_setting(viafb_setting, info) < 0)
+			return -EINVAL;
+
+		break;
+
+	case VIAFB_SET_SECOND_MODE:
+		if (copy_from_user(&sec_var, (void *)argp, sizeof(sec_var)))
+			return -EFAULT;
+		apply_second_mode_setting(&sec_var);
+		break;
+
+	case VIAFB_GET_DEVICE_INFO:
+
+		retrieve_device_setting(&viafb_setting);
+
+		if (copy_to_user
+		    ((void __user *)arg, &viafb_setting,
+		     sizeof(viafb_setting)))
+			return -EFAULT;
+
+		break;
+
+	case VIAFB_GET_DEVICE_SUPPORT:
+		get_device_support_state(&state_info);
+		if (put_user(state_info, argp))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_DEVICE_CONNECT:
+		get_device_connect_state(&state_info);
+		if (put_user(state_info, argp))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_PANEL_SUPPORT_EXPAND:
+		state_info =
+		    lcd_get_support_expand_state(info->var.xres,
+						 info->var.yres);
+		if (put_user(state_info, argp))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_DRIVER_NAME:
+		if (copy_to_user
+		    ((void __user *)arg, driver_name, sizeof(driver_name)))
+			return -EFAULT;
+		break;
+
+	case VIAFB_SET_GAMMA_LUT:
+		if (copy_from_user
+		    (viafb_gamma_table, argp, sizeof(viafb_gamma_table)))
+			return -EFAULT;
+		set_gamma_table(via_fb_bpp, viafb_gamma_table);
+		break;
+
+	case VIAFB_GET_GAMMA_LUT:
+		get_gamma_table(viafb_gamma_table);
+		if (copy_to_user
+		    ((void __user *)arg, viafb_gamma_table,
+		     sizeof(viafb_gamma_table)))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_GAMMA_SUPPORT_STATE:
+		get_gamma_support_state(via_fb_bpp, &state_info);
+		if (put_user(state_info, argp))
+			return -EFAULT;
+		break;
+	case VIAFB_SET_VIDEO_DEVICE:
+		get_user(video_dev_info, argp);
+		viafb_set_video_device(video_dev_info);
+		break;
+	case VIAFB_GET_VIDEO_DEVICE:
+		viafb_get_video_device(&video_dev_info);
+		if (put_user(video_dev_info, argp))
+			return -EFAULT;
+		break;
+	case VIAFB_SYNC_SURFACE:
+		DEBUG_MSG(KERN_INFO "lobo VIAFB_SYNC_SURFACE\n");
+		break;
+	case VIAFB_GET_DRIVER_CAPS:
+		break;
+
+	case VIAFB_GET_PANEL_MAX_SIZE:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		get_panel_max_scal_size(&panel_pos_size_para);
+		if (copy_to_user
+		    ((void __user *)arg, &panel_pos_size_para,
+		     sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		break;
+	case VIAFB_GET_PANEL_MAX_POSITION:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		get_panel_max_scal_pos(&panel_pos_size_para);
+		if (copy_to_user
+		    ((void __user *)arg, &panel_pos_size_para,
+		     sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		break;
+
+	case VIAFB_GET_PANEL_POSITION:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		get_panel_scal_pos(&panel_pos_size_para);
+		if (copy_to_user
+		    ((void __user *)arg, &panel_pos_size_para,
+		     sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		break;
+	case VIAFB_GET_PANEL_SIZE:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		get_panel_scal_size(&panel_pos_size_para);
+		if (copy_to_user
+		    ((void __user *)arg, &panel_pos_size_para,
+		     sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		break;
+
+	case VIAFB_SET_PANEL_POSITION:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		set_panel_scal_pos(&panel_pos_size_para);
+		break;
+	case VIAFB_SET_PANEL_SIZE:
+		if (copy_from_user
+		    (&panel_pos_size_para, argp, sizeof(panel_pos_size_para)))
+			return -EFAULT;
+		set_panel_scal_size(&panel_pos_size_para);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void viafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
+{
+	u32 col = 0, rop = 0;
+	int pitch;
+
+	if (!via_fb_accel)
+		return cfb_fillrect(info, rect);
+
+	if (!rect->width || !rect->height)
+		return;
+
+	switch (rect->rop) {
+	case ROP_XOR:
+		rop = 0x5A;
+		break;
+	case ROP_COPY:
+	default:
+		rop = 0xF0;
+		break;
+	}
+
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		col = rect->color;
+		break;
+	case 16:
+		col = ((u32 *) (info->pseudo_palette))[rect->color];
+		break;
+	case 32:
+		col = ((u32 *) (info->pseudo_palette))[rect->color];
+		break;
+	}
+
+	/* BitBlt Source Address */
+	MMIO_OUT32(VIA_REG_SRCPOS, 0x0);
+	/* Source Base Address */
+	MMIO_OUT32(VIA_REG_SRCBASE, 0x0);
+	/* Destination Base Address */
+	/*MMIO_OUT32(VIA_REG_DSTBASE, 0x0); */
+	MMIO_OUT32(VIA_REG_DSTBASE,
+		   ((u32) (info->screen_base) - (u32) FB_MM) >> 3);
+	/* Pitch */
+	pitch = (info->var.xres_virtual + 7) & ~7;
+	MMIO_OUT32(VIA_REG_PITCH,
+		   VIA_PITCH_ENABLE |
+		   (((pitch *
+		      info->var.bits_per_pixel >> 3) >> 3) | (((pitch *
+								info->var.
+								bits_per_pixel
+								>> 3) >> 3)
+							      << 16)));
+	/* BitBlt Destination Address */
+	MMIO_OUT32(VIA_REG_DSTPOS, ((rect->dy << 16) | rect->dx));
+	/* Dimension: width & height */
+	MMIO_OUT32(VIA_REG_DIMENSION,
+		   (((rect->height - 1) << 16) | (rect->width - 1)));
+	/* Forground color or Destination color */
+	MMIO_OUT32(VIA_REG_FGCOLOR, col);
+	/* GE Command */
+	MMIO_OUT32(VIA_REG_GECMD, (0x01 | 0x2000 | (rop << 24)));
+
+}
+
+static void viafb_copyarea(struct fb_info *info, const struct fb_copyarea *area)
+{
+	u32 dy = area->dy, sy = area->sy, direction = 0x0;
+	u32 sx = area->sx, dx = area->dx, width = area->width;
+	int pitch;
+
+	DEBUG_MSG(KERN_INFO "viafb_copyarea!!\n");
+
+	if (!via_fb_accel)
+		return cfb_copyarea(info, area);
+
+	if (!area->width || !area->height)
+		return;
+
+	if (sy < dy) {
+		dy += area->height - 1;
+		sy += area->height - 1;
+		direction |= 0x4000;
+	}
+
+	if (sx < dx) {
+		dx += width - 1;
+		sx += width - 1;
+		direction |= 0x8000;
+	}
+
+	/* Source Base Address */
+	/*MMIO_OUT32(VIA_REG_SRCBASE, 0x0); */
+	MMIO_OUT32(VIA_REG_SRCBASE,
+		   ((u32) (info->screen_base) - (u32) FB_MM) >> 3);
+	/* Destination Base Address */
+	/*MMIO_OUT32(VIA_REG_DSTBASE, 0x0); */
+	MMIO_OUT32(VIA_REG_DSTBASE,
+		   ((u32) (info->screen_base) - (u32) FB_MM) >> 3);
+	/* Pitch */
+	pitch = (info->var.xres_virtual + 7) & ~7;
+	/* VIA_PITCH_ENABLE can be omitted now. */
+	MMIO_OUT32(VIA_REG_PITCH,
+		   VIA_PITCH_ENABLE |
+		   (((pitch *
+		      info->var.bits_per_pixel >> 3) >> 3) | (((pitch *
+								info->var.
+								bits_per_pixel
+								>> 3) >> 3)
+							      << 16)));
+	/* BitBlt Source Address */
+	MMIO_OUT32(VIA_REG_SRCPOS, ((sy << 16) | sx));
+	/* BitBlt Destination Address */
+	MMIO_OUT32(VIA_REG_DSTPOS, ((dy << 16) | dx));
+	/* Dimension: width & height */
+	MMIO_OUT32(VIA_REG_DIMENSION,
+		   (((area->height - 1) << 16) | (area->width - 1)));
+	/* GE Command */
+	MMIO_OUT32(VIA_REG_GECMD, (0x01 | direction | (0xCC << 24)));
+
+}
+
+static void viafb_imageblit(struct fb_info *info, const struct fb_image *image)
+{
+	u32 size, bg_col = 0, fg_col = 0, *udata;
+	int i;
+	int pitch;
+
+	if (!via_fb_accel)
+		return cfb_imageblit(info, image);
+
+	udata = (u32 *) image->data;
+
+	switch (info->var.bits_per_pixel) {
+	case 8:
+		bg_col = image->bg_color;
+		fg_col = image->fg_color;
+		break;
+	case 16:
+		bg_col = ((u32 *) (info->pseudo_palette))[image->bg_color];
+		fg_col = ((u32 *) (info->pseudo_palette))[image->fg_color];
+		break;
+	case 32:
+		bg_col = ((u32 *) (info->pseudo_palette))[image->bg_color];
+		fg_col = ((u32 *) (info->pseudo_palette))[image->fg_color];
+		break;
+	}
+	size = image->width * image->height;
+
+	/* Source Base Address */
+	MMIO_OUT32(VIA_REG_SRCBASE, 0x0);
+	/* Destination Base Address */
+	/*MMIO_OUT32(VIA_REG_DSTBASE, 0x0); */
+	MMIO_OUT32(VIA_REG_DSTBASE,
+		   ((u32) (info->screen_base) - (u32) FB_MM) >> 3);
+	/* Pitch */
+	pitch = (info->var.xres_virtual + 7) & ~7;
+	MMIO_OUT32(VIA_REG_PITCH,
+		   VIA_PITCH_ENABLE |
+		   (((pitch *
+		      info->var.bits_per_pixel >> 3) >> 3) | (((pitch *
+								info->var.
+								bits_per_pixel
+								>> 3) >> 3)
+							      << 16)));
+	/* BitBlt Source Address */
+	MMIO_OUT32(VIA_REG_SRCPOS, 0x0);
+	/* BitBlt Destination Address */
+	MMIO_OUT32(VIA_REG_DSTPOS, ((image->dy << 16) | image->dx));
+	/* Dimension: width & height */
+	MMIO_OUT32(VIA_REG_DIMENSION,
+		   (((image->height - 1) << 16) | (image->width - 1)));
+	/* fb color */
+	MMIO_OUT32(VIA_REG_FGCOLOR, fg_col);
+	/* bg color */
+	MMIO_OUT32(VIA_REG_BGCOLOR, bg_col);
+	/* GE Command */
+	MMIO_OUT32(VIA_REG_GECMD, 0xCC020142);
+
+	for (i = 0; i < size / 4; i++) {
+		MMIO_OUT32(VIA_MMIO_BLTBASE, *udata);
+		udata++;
+	}
+
+}
+
+static int viafb_cursor(struct fb_info *info, struct fb_cursor *cursor)
+{
+	u8 data[CURSOR_SIZE / 8];
+	u32 data_bak[CURSOR_SIZE / 32];
+	u32 temp, xx, yy, bg_col = 0, fg_col = 0;
+	int size, i, j = 0;
+
+	if (!via_fb_accel)
+		return soft_cursor(info, cursor);
+
+	if ((((struct viafb_par *)(info->par))->iga_path == IGA2)
+	    && (chip_info.gfx_chip_name == UNICHROME_CLE266))
+		return soft_cursor(info, cursor);
+
+	/*When duoview and using lcd , use soft cursor */
+	if (LCD_ON || ((struct viafb_par *)(info->par))->duoview)
+		return soft_cursor(info, cursor);
+
+	show_hw_cursor(info, HW_Cursor_OFF);
+	viacursor = *cursor;
+
+	if (cursor->set & FB_CUR_SETHOT) {
+		viacursor.hot = cursor->hot;
+		temp = ((viacursor.hot.x) << 16) + viacursor.hot.y;
+		MMIO_OUT32(VIA_REG_CURSOR_ORG, temp);
+	}
+
+	if (cursor->set & FB_CUR_SETPOS) {
+		viacursor.image.dx = cursor->image.dx;
+		viacursor.image.dy = cursor->image.dy;
+		yy = cursor->image.dy - info->var.yoffset;
+		xx = cursor->image.dx - info->var.xoffset;
+		temp = yy & 0xFFFF;
+		temp |= (xx << 16);
+		MMIO_OUT32(VIA_REG_CURSOR_POS, temp);
+	}
+
+	if (cursor->set & FB_CUR_SETSIZE) {
+		temp = MMIO_IN32(VIA_REG_CURSOR_MODE);
+
+		if ((cursor->image.width <= 32)
+		    && (cursor->image.height <= 32)) {
+			MAX_CURS = 32;
+			temp |= 0x2;
+		} else if ((cursor->image.width <= 64)
+			   && (cursor->image.height <= 64)) {
+			MAX_CURS = 64;
+			temp &= 0xFFFFFFFD;
+		} else {
+			DEBUG_MSG(KERN_INFO
+			"The cursor image is biger than 64x64 bits...\n");
+			return -ENXIO;
+		}
+		MMIO_OUT32(VIA_REG_CURSOR_MODE, temp);
+
+		viacursor.image.height = cursor->image.height;
+		viacursor.image.width = cursor->image.width;
+	}
+
+	if (cursor->set & FB_CUR_SETCMAP) {
+		viacursor.image.fg_color = cursor->image.fg_color;
+		viacursor.image.bg_color = cursor->image.bg_color;
+
+		switch (info->var.bits_per_pixel) {
+		case 8:
+			/*FIX ME:It seems that hardware cursor
+			   always work in true color mode */
+			bg_col =
+			    (viafb_256_colors.
+			     red[viacursor.image.bg_color] >> 8 << 16);
+			bg_col =
+			    bg_col | (viafb_256_colors.
+				      green[viacursor.image.
+					    bg_color] >> 8 << 8);
+			bg_col =
+			    bg_col | (viafb_256_colors.
+				      blue[viacursor.image.bg_color] >> 8);
+			fg_col =
+			    (viafb_256_colors.
+			     red[viacursor.image.fg_color] >> 8 << 16);
+			fg_col =
+			    fg_col | (viafb_256_colors.
+				      green[viacursor.image.
+					    fg_color] >> 8 << 8);
+			fg_col =
+			    fg_col | (viafb_256_colors.
+				      blue[viacursor.image.fg_color] >> 8);
+			break;
+		case 16:
+			bg_col =
+			    ((u32 *) (info->pseudo_palette))[viacursor.
+							     image.bg_color];
+			bg_col =
+			    (0xFF << 24) | ((bg_col & 0xF800) << 8) |
+			    ((bg_col & 0x7E0) << 5) | ((bg_col & 0x1F) << 3);
+			fg_col =
+			    ((u32 *) (info->pseudo_palette))[viacursor.
+							     image.fg_color];
+			fg_col =
+			    (0xFF << 24) | ((fg_col & 0xF800) << 8) |
+			    ((fg_col & 0x7E0) << 5) | ((fg_col & 0x1F) << 3);
+			break;
+		case 32:
+			bg_col =
+			    ((u32 *) (info->pseudo_palette))[viacursor.
+							     image.bg_color];
+			fg_col =
+			    ((u32 *) (info->pseudo_palette))[viacursor.
+							     image.fg_color];
+			break;
+		}
+
+		MMIO_OUT32(VIA_REG_CURSOR_BG, bg_col);
+		MMIO_OUT32(VIA_REG_CURSOR_FG, fg_col);
+	}
+
+	if (cursor->set & FB_CUR_SETSHAPE) {
+		size =
+		    ((viacursor.image.width + 7) >> 3) * viacursor.image.height;
+
+		if (MAX_CURS == 32) {
+			for (i = 0; i < (CURSOR_SIZE / 32); i++) {
+				data_bak[i] = 0x0;
+				data_bak[i + 1] = 0xFFFFFFFF;
+				i += 1;
+			}
+		} else if (MAX_CURS == 64) {
+			for (i = 0; i < (CURSOR_SIZE / 32); i++) {
+				data_bak[i] = 0x0;
+				data_bak[i + 1] = 0x0;
+				data_bak[i + 2] = 0xFFFFFFFF;
+				data_bak[i + 3] = 0xFFFFFFFF;
+				i += 3;
+			}
+		}
+
+		switch (viacursor.rop) {
+		case ROP_XOR:
+			for (i = 0; i < size; i++)
+				data[i] = viacursor.mask[i];
+			break;
+		case ROP_COPY:
+
+			for (i = 0; i < size; i++)
+				data[i] = viacursor.mask[i];
+			break;
+		default:
+			break;
+		}
+
+		if (MAX_CURS == 32) {
+			for (i = 0; i < size; i++) {
+				data_bak[j] = (u32) data[i];
+				data_bak[j + 1] = ~data_bak[j];
+				j += 2;
+			}
+		} else if (MAX_CURS == 64) {
+			for (i = 0; i < size; i++) {
+				data_bak[j] = (u32) data[i];
+				data_bak[j + 1] = 0x0;
+				data_bak[j + 2] = ~data_bak[j];
+				data_bak[j + 3] = ~data_bak[j + 1];
+				j += 4;
+			}
+		}
+
+		memcpy(((struct viafb_par *)(info->par))->fbmem_virt +
+		       ((struct viafb_par *)(info->par))->cursor_start,
+		       data_bak, CURSOR_SIZE);
+	}
+
+	if (viacursor.enable)
+		show_hw_cursor(info, HW_Cursor_ON);
+
+	return 0;
+}
+
+static int viafb_sync(struct fb_info *info)
+{
+	if (via_fb_accel)
+		wait_engine_idle();
+	return 0;
+}
+
+int get_mode_index(int hres, int vres, int flag)
+{
+	DEBUG_MSG(KERN_INFO "get_mode_index!\n");
+
+	if (flag == 0) {
+		if (hres == 480 && vres == 640) {
+			resMode = VIA_RES_480X640;
+			mode = "480x640";
+		} else if (hres == 640 && vres == 480) {
+			resMode = VIA_RES_640X480;
+			mode = "640x480";
+		} else if (hres == 800 && vres == 480) {
+			resMode = VIA_RES_800X480;
+			mode = "800x480";
+		} else if (hres == 800 && vres == 600) {
+			resMode = VIA_RES_800X600;
+			mode = "800x600";
+		} else if (hres == 1024 && vres == 768) {
+			resMode = VIA_RES_1024X768;
+			mode = "1024x768";
+		} else if (hres == 1152 && vres == 864) {
+			resMode = VIA_RES_1152X864;
+			mode = "1152x864";
+		} else if (hres == 1280 && vres == 1024) {
+			resMode = VIA_RES_1280X1024;
+			mode = "1280x1024";
+		} else if (hres == 1600 && vres == 1200) {
+			resMode = VIA_RES_1600X1200;
+			mode = "1600x1200";
+		} else if (hres == 1440 && vres == 1050) {
+			resMode = VIA_RES_1440X1050;
+			mode = "1440x1050";
+		} else if (hres == 1280 && vres == 768) {
+			resMode = VIA_RES_1280X768;
+			mode = "1280x768";
+		} else if (hres == 1280 && vres == 800) {
+			resMode = VIA_RES_1280X800;
+			mode = "1280x800";
+		} else if (hres == 1280 && vres == 960) {
+			resMode = VIA_RES_1280X960;
+			mode = "1280x960";
+		} else if (hres == 1920 && vres == 1440) {
+			resMode = VIA_RES_1920X1440;
+			mode = "1920x1440";
+		} else if (hres == 848 && vres == 480) {
+			resMode = VIA_RES_848X480;
+			mode = "848x480";
+		} else if (hres == 1400 && vres == 1050) {
+			resMode = VIA_RES_1400X1050;
+			mode = "1400x1050";
+		} else if (hres == 720 && vres == 480) {
+			resMode = VIA_RES_720X480;
+			mode = "720x480";
+		} else if (hres == 720 && vres == 576) {
+			resMode = VIA_RES_720X576;
+			mode = "720x576";
+		} else if (hres == 1024 && vres == 512) {
+			resMode = VIA_RES_1024X512;
+			mode = "1024x512";
+		} else if (hres == 856 && vres == 480) {
+			resMode = VIA_RES_856X480;
+			mode = "856x480";
+		} else if (hres == 1024 && vres == 576) {
+			resMode = VIA_RES_1024X576;
+			mode = "1024x576";
+		} else if (hres == 1024 && vres == 600) {
+			resMode = VIA_RES_1024X600;
+			mode = "1024x600";
+		} else if (hres == 1280 && vres == 720) {
+			resMode = VIA_RES_1280X720;
+			mode = "1280x720";
+		} else if (hres == 1920 && vres == 1080) {
+			resMode = VIA_RES_1920X1080;
+			mode = "1920x1080";
+		} else if (hres == 1366 && vres == 768) {
+			resMode = VIA_RES_1368X768;
+			mode = "1368x768";
+		} else if (hres == 1680 && vres == 1050) {
+			resMode = VIA_RES_1680X1050;
+			mode = "1680x1050";
+		} else if (hres == 960 && vres == 600) {
+			resMode = VIA_RES_960X600;
+			mode = "960x600";
+		} else if (hres == 1000 && vres == 600) {
+			resMode = VIA_RES_1000X600;
+			mode = "1000x600";
+		} else if (hres == 1024 && vres == 576) {
+			resMode = VIA_RES_1024X576;
+			mode = "1024x576";
+		} else if (hres == 1024 && vres == 600) {
+			resMode = VIA_RES_1024X600;
+			mode = "1024x600";
+		} else if (hres == 1088 && vres == 612) {
+			resMode = VIA_RES_1088X612;
+			mode = "1088x612";
+		} else if (hres == 1152 && vres == 720) {
+			resMode = VIA_RES_1152X720;
+			mode = "1152x720";
+		} else if (hres == 1200 && vres == 720) {
+			resMode = VIA_RES_1200X720;
+			mode = "1200x720";
+		} else if (hres == 1280 && vres == 600) {
+			resMode = VIA_RES_1280X600;
+			mode = "1280x600";
+		} else if (hres == 1360 && vres == 768) {
+			resMode = VIA_RES_1360X768;
+			mode = "1360x768";
+		} else if (hres == 1366 && vres == 768) {
+			resMode = VIA_RES_1366X768;
+			mode = "1366x768";
+		} else if (hres == 1440 && vres == 900) {
+			resMode = VIA_RES_1440X900;
+			mode = "1440x900";
+		} else if (hres == 1600 && vres == 900) {
+			resMode = VIA_RES_1600X900;
+			mode = "1600x900";
+		} else if (hres == 1600 && vres == 1024) {
+			resMode = VIA_RES_1600X1024;
+			mode = "1600x1024";
+		} else if (hres == 1792 && vres == 1344) {
+			resMode = VIA_RES_1792X1344;
+			mode = "1792x1344";
+		} else if (hres == 1856 && vres == 1392) {
+			resMode = VIA_RES_1856X1392;
+			mode = "1856x1392";
+		} else if (hres == 1920 && vres == 1200) {
+			resMode = VIA_RES_1920X1200;
+			mode = "1920x1200";
+		} else if (hres == 2048 && vres == 1536) {
+			resMode = VIA_RES_2048X1536;
+			mode = "2048x1536";
+		} else {
+			resMode = VIA_RES_INVALID;
+			mode = "640x480";
+		}
+	} else {
+		if (hres == 480 && vres == 640) {
+			resMode = VIA_RES_480X640;
+			mode1 = "480x640";
+		} else if (hres == 640 && vres == 480) {
+			resMode = VIA_RES_640X480;
+			mode1 = "640x480";
+		} else if (hres == 800 && vres == 480) {
+			resMode = VIA_RES_800X480;
+			mode1 = "800x480";
+		} else if (hres == 800 && vres == 600) {
+			resMode = VIA_RES_800X600;
+			mode1 = "800x600";
+		} else if (hres == 1024 && vres == 768) {
+			resMode = VIA_RES_1024X768;
+			mode1 = "1024x768";
+		} else if (hres == 1152 && vres == 864) {
+			resMode = VIA_RES_1152X864;
+			mode1 = "1152x864";
+		} else if (hres == 1280 && vres == 1024) {
+			resMode = VIA_RES_1280X1024;
+			mode1 = "1280x1024";
+		} else if (hres == 1600 && vres == 1200) {
+			resMode = VIA_RES_1600X1200;
+			mode = "1600x1200";
+		} else if (hres == 1440 && vres == 1050) {
+			resMode = VIA_RES_1440X1050;
+			mode1 = "1440x1050";
+		} else if (hres == 1280 && vres == 768) {
+			resMode = VIA_RES_1280X768;
+			mode1 = "1280x768";
+		} else if (hres == 1280 && vres == 800) {
+			resMode = VIA_RES_1280X800;
+			mode1 = "1280x800";
+		} else if (hres == 1280 && vres == 960) {
+			resMode = VIA_RES_1280X960;
+			mode1 = "1280x960";
+		} else if (hres == 1920 && vres == 1440) {
+			resMode = VIA_RES_1920X1440;
+			mode1 = "1920x1440";
+		} else if (hres == 848 && vres == 480) {
+			resMode = VIA_RES_848X480;
+			mode1 = "848x480";
+		} else if (hres == 1400 && vres == 1050) {
+			resMode = VIA_RES_1400X1050;
+			mode1 = "1400x1050";
+		} else if (hres == 720 && vres == 480) {
+			resMode = VIA_RES_720X480;
+			mode1 = "720x480";
+		} else if (hres == 720 && vres == 576) {
+			resMode = VIA_RES_720X576;
+			mode1 = "720x576";
+		} else if (hres == 1024 && vres == 512) {
+			resMode = VIA_RES_1024X512;
+			mode1 = "1024x512";
+		} else if (hres == 856 && vres == 480) {
+			resMode = VIA_RES_856X480;
+			mode1 = "856x480";
+		} else if (hres == 1024 && vres == 576) {
+			resMode = VIA_RES_1024X576;
+			mode1 = "1024x576";
+		} else if (hres == 1024 && vres == 600) {
+			resMode = VIA_RES_1024X600;
+			mode1 = "1024x600";
+		} else if (hres == 1280 && vres == 720) {
+			resMode = VIA_RES_1280X720;
+			mode1 = "1280x720";
+		} else if (hres == 1920 && vres == 1080) {
+			resMode = VIA_RES_1920X1080;
+			mode1 = "1920x1080";
+		} else if (hres == 1366 && vres == 768) {
+			resMode = VIA_RES_1368X768;
+			mode1 = "1368x768";
+		} else if (hres == 1680 && vres == 1050) {
+			resMode = VIA_RES_1680X1050;
+			mode1 = "1680x1050";
+		} else if (hres == 960 && vres == 600) {
+			resMode = VIA_RES_960X600;
+			mode1 = "960x600";
+		} else if (hres == 1000 && vres == 600) {
+			resMode = VIA_RES_1000X600;
+			mode1 = "1000x600";
+		} else if (hres == 1024 && vres == 576) {
+			resMode = VIA_RES_1024X576;
+			mode1 = "1024x576";
+		} else if (hres == 1024 && vres == 600) {
+			resMode = VIA_RES_1024X600;
+			mode1 = "1024x600";
+		} else if (hres == 1088 && vres == 612) {
+			resMode = VIA_RES_1088X612;
+			mode1 = "1088x612";
+		} else if (hres == 1152 && vres == 720) {
+			resMode = VIA_RES_1152X720;
+			mode1 = "1152x720";
+		} else if (hres == 1200 && vres == 720) {
+			resMode = VIA_RES_1200X720;
+			mode1 = "1200x720";
+		} else if (hres == 1280 && vres == 600) {
+			resMode = VIA_RES_1280X600;
+			mode1 = "1280x600";
+		} else if (hres == 1360 && vres == 768) {
+			resMode = VIA_RES_1360X768;
+			mode1 = "1360x768";
+		} else if (hres == 1366 && vres == 768) {
+			resMode = VIA_RES_1366X768;
+			mode1 = "1366x768";
+		} else if (hres == 1440 && vres == 900) {
+			resMode = VIA_RES_1440X900;
+			mode1 = "1440x900";
+		} else if (hres == 1600 && vres == 900) {
+			resMode = VIA_RES_1600X900;
+			mode1 = "1600x900";
+		} else if (hres == 1600 && vres == 1024) {
+			resMode = VIA_RES_1600X1024;
+			mode1 = "1600x1024";
+		} else if (hres == 1792 && vres == 1344) {
+			resMode = VIA_RES_1792X1344;
+			mode1 = "1792x1344";
+		} else if (hres == 1856 && vres == 1392) {
+			resMode = VIA_RES_1856X1392;
+			mode1 = "1856x1392";
+		} else if (hres == 1920 && vres == 1200) {
+			resMode = VIA_RES_1920X1200;
+			mode1 = "1920x1200";
+		} else if (hres == 2048 && vres == 1536) {
+			resMode = VIA_RES_2048X1536;
+			mode1 = "2048x1536";
+		} else {
+			resMode = VIA_RES_INVALID;
+			mode1 = "640x480";
+		}
+	}
+	return (resMode);
+}
+
+static void check_available_device_to_enable(int device_id)
+{
+	int device_num = 0;
+
+	/* Initialize: */
+	CRT_ON = STATE_OFF;
+	DVI_ON = STATE_OFF;
+	LCD_ON = STATE_OFF;
+	LCD2_ON = STATE_OFF;
+	DeviceStatus = None_Device;
+
+	if ((device_id & CRT_Device) && (device_num < MAX_ACTIVE_DEV_NUM)) {
+		CRT_ON = STATE_ON;
+		device_num++;
+		DeviceStatus |= CRT_Device;
+	}
+
+	if ((device_id & DVI_Device) && (device_num < MAX_ACTIVE_DEV_NUM)) {
+		DVI_ON = STATE_ON;
+		device_num++;
+		DeviceStatus |= DVI_Device;
+	}
+
+	if ((device_id & LCD_Device) && (device_num < MAX_ACTIVE_DEV_NUM)) {
+		LCD_ON = STATE_ON;
+		device_num++;
+		DeviceStatus |= LCD_Device;
+	}
+
+	if ((device_id & LCD2_Device) && (device_num < MAX_ACTIVE_DEV_NUM)) {
+		LCD2_ON = STATE_ON;
+		device_num++;
+		DeviceStatus |= LCD2_Device;
+	}
+
+	if (DeviceStatus == None_Device) {
+		/* Use CRT as default active device: */
+		CRT_ON = STATE_ON;
+		DeviceStatus = CRT_Device;
+	}
+	DEBUG_MSG(KERN_INFO "Device Status:%x", DeviceStatus);
+}
+
+void viafb_set_device(struct device_t active_dev)
+{
+	/* Check available device to enable: */
+	int device_id = None_Device;
+	if (active_dev.crt)
+		device_id |= CRT_Device;
+	if (active_dev.dvi)
+		device_id |= DVI_Device;
+	if (active_dev.lcd)
+		device_id |= LCD_Device;
+
+	check_available_device_to_enable(device_id);
+
+	/* Check property of LCD: */
+	if (LCD_ON) {
+		if (active_dev.lcd_dsp_cent) {
+			lvds_setting_info.display_method = lcd_dsp_method =
+			    LCD_CENTERING;
+		} else {
+			lvds_setting_info.display_method = lcd_dsp_method =
+			    LCD_EXPANDSION;
+		}
+
+		if (active_dev.lcd_mode == LCD_SPWG) {
+			lvds_setting_info.lcd_mode = lcd_mode = LCD_SPWG;
+		} else {
+			lvds_setting_info.lcd_mode = lcd_mode = LCD_OPENLDI;
+		}
+
+		if (active_dev.lcd_panel_id <= LCD_PANEL_ID_MAXIMUM) {
+			lcd_panel_id = active_dev.lcd_panel_id;
+			init_lcd_size();
+		}
+	}
+
+	/* Check property of mode: */
+	if (!active_dev.xres1) {
+		second_xres = 640;
+	} else {
+		second_xres = active_dev.xres1;
+	}
+
+	if (!active_dev.yres1) {
+		second_yres = 480;
+	} else {
+		second_yres = active_dev.yres1;
+	}
+	if (active_dev.bpp != 0)
+		via_fb_bpp = active_dev.bpp;
+	if (active_dev.bpp1 != 0)
+		via_fb_bpp1 = active_dev.bpp1;
+	if (active_dev.refresh != 0)
+		refresh = active_dev.refresh;
+	if (active_dev.refresh1 != 0)
+		refresh1 = active_dev.refresh1;
+	if ((active_dev.samm == STATE_OFF)
+	    || (active_dev.samm == STATE_ON))
+	    SAMM_ON = active_dev.samm;
+	primary_dev = active_dev.primary_dev;
+
+	set_start_addr();
+	set_iga_path();
+}
+
+void viafb_set_video_device(u32 video_dev_info)
+{
+	video_on_crt = STATE_OFF;
+	video_on_dvi = STATE_OFF;
+	video_on_lcd = STATE_OFF;
+
+	/* Check available device to enable: */
+	if ((video_dev_info & CRT_Device) == CRT_Device) {
+		video_on_crt = STATE_ON;
+	} else if ((video_dev_info & DVI_Device) == DVI_Device) {
+		video_on_dvi = STATE_ON;
+	} else if ((video_dev_info & LCD_Device) == LCD_Device) {
+		video_on_lcd = STATE_ON;
+	}
+}
+void viafb_get_video_device(u32 *video_dev_info)
+{
+	*video_dev_info = None_Device;
+	if (video_on_crt == STATE_ON) {
+		*video_dev_info |= CRT_Device;
+	} else if (video_on_dvi == STATE_ON) {
+		*video_dev_info |= DVI_Device;
+	} else if (video_on_lcd == STATE_ON) {
+		*video_dev_info |= LCD_Device;
+	}
+}
+
+/*
+*   S.T.Chen [2006.01.17]:
+*       Purpose: to get the current primary display device type.
+*       Return: an integer which indicates the current primary device type.
+*/
+int get_primary_device()
+{
+	int primary_device = 0;
+	/* Rule: device on iga1 path are the primary device. */
+	if (SAMM_ON) {
+		if (CRT_ON) {
+			if (crt_setting_info.iga_path == IGA1) {
+				DEBUG_MSG(KERN_INFO "CRT IGA Path:%d\n",
+					  crt_setting_info.iga_path);
+				primary_device = CRT_Device;
+			}
+		}
+		if (DVI_ON) {
+			if (tmds_setting_info.iga_path == IGA1) {
+				DEBUG_MSG(KERN_INFO "DVI IGA Path:%d\n",
+					  tmds_setting_info.iga_path);
+				primary_device = DVI_Device;
+			}
+		}
+		if (LCD_ON) {
+			if (lvds_setting_info.iga_path == IGA1) {
+				DEBUG_MSG(KERN_INFO "LCD IGA Path:%d\n",
+					  lvds_setting_info.iga_path);
+				primary_device = LCD_Device;
+			}
+		}
+		if (LCD2_ON) {
+			if (lvds_setting_info2.iga_path == IGA1) {
+				DEBUG_MSG(KERN_INFO "LCD2 IGA Path:%d\n",
+					  lvds_setting_info2.iga_path);
+				primary_device = LCD2_Device;
+			}
+		}
+	}
+	return primary_device;
+}
+
+static u8 is_duoview(void)
+{
+	if (0 == SAMM_ON) {
+		if (LCD_ON + LCD2_ON + DVI_ON + CRT_ON == 2)
+			return TRUE;
+		return FALSE;
+	} else {
+		return FALSE;
+	}
+}
+
+void apply_second_mode_setting(struct fb_var_screeninfo *sec_var)
+{
+	if ((sec_var->xres_virtual * (sec_var->bits_per_pixel >> 3)) & 0x1F) {
+		/*Is 32 bytes alignment? */
+		/*32 pixel alignment */
+		sec_var->xres_virtual = (sec_var->xres_virtual + 31) & ~31;
+	}
+	second_xres = sec_var->xres;
+	second_yres = sec_var->yres;
+	second_virtual_xres = sec_var->xres_virtual;
+	second_virtual_yres = sec_var->yres_virtual;
+	via_fb_bpp1 = sec_var->bits_per_pixel;
+	refresh1 = get_refresh(sec_var->xres, sec_var->yres, sec_var->pixclock);
+}
+
+int apply_device_setting(struct viafb_ioctl_setting setting_info,
+			 struct fb_info *info)
+{
+	int need_set_mode = 0;
+	DEBUG_MSG(KERN_INFO "apply_device_setting\n");
+
+	if (setting_info.device_flag) {
+		need_set_mode = 1;
+		check_available_device_to_enable(setting_info.device_status);
+	}
+
+	/* Unlock LCD's operation according to LCD flag
+	   and check if the setting value is valid. */
+	/* If the value is valid, apply the new setting value to the device. */
+	if (LCD_ON) {
+		if (setting_info.lcd_operation_flag & OP_LCD_CENTERING) {
+			need_set_mode = 1;
+			if (setting_info.lcd_attributes.display_center) {
+				/* Centering */
+				lvds_setting_info.display_method =
+				    LCD_CENTERING;
+				lcd_dsp_method = LCD_CENTERING;
+				lvds_setting_info2.display_method =
+				    lcd_dsp_method = LCD_CENTERING;
+			} else {
+				/* expandsion */
+				lvds_setting_info.display_method =
+				    LCD_EXPANDSION;
+				lcd_dsp_method = LCD_EXPANDSION;
+				lvds_setting_info2.display_method =
+				    LCD_EXPANDSION;
+				lcd_dsp_method = LCD_EXPANDSION;
+			}
+		}
+
+		if (setting_info.lcd_operation_flag & OP_LCD_MODE) {
+			need_set_mode = 1;
+			if (setting_info.lcd_attributes.lcd_mode == LCD_SPWG) {
+				lvds_setting_info.lcd_mode = lcd_mode =
+				    LCD_SPWG;
+			} else {
+				lvds_setting_info.lcd_mode = lcd_mode =
+				    LCD_OPENLDI;
+			}
+			lvds_setting_info2.lcd_mode =
+			    lvds_setting_info.lcd_mode;
+		}
+
+		if (setting_info.lcd_operation_flag & OP_LCD_PANEL_ID) {
+			need_set_mode = 1;
+			if (setting_info.lcd_attributes.panel_id <=
+			    LCD_PANEL_ID_MAXIMUM) {
+				lcd_panel_id =
+				    setting_info.lcd_attributes.panel_id;
+				init_lcd_size();
+			}
+		}
+	}
+
+	if (0 != (setting_info.samm_status & OP_SAMM)) {
+		setting_info.samm_status =
+		    setting_info.samm_status & (~OP_SAMM);
+		if (setting_info.samm_status == 0
+		    || setting_info.samm_status == 1) {
+			SAMM_ON = setting_info.samm_status;
+
+			if (SAMM_ON)
+				primary_dev = setting_info.primary_device;
+
+			set_start_addr();
+			set_iga_path();
+		}
+		need_set_mode = 1;
+	}
+
+	parinfo.duoview = is_duoview();
+
+	if (!need_set_mode) {
+		;
+	} else {
+		set_iga_path();
+		viafb_set_par(info);
+	}
+	return (TRUE);
+}
+
+void retrieve_device_setting(struct viafb_ioctl_setting *setting_info)
+{
+
+	/* get device status */
+	if (CRT_ON == 1)
+		setting_info->device_status = CRT_Device;
+	if (DVI_ON == 1)
+		setting_info->device_status |= DVI_Device;
+	if (LCD_ON == 1)
+		setting_info->device_status |= LCD_Device;
+	if (LCD2_ON == 1)
+		setting_info->device_status |= LCD2_Device;
+	if ((video_on_crt == 1) && (CRT_ON == 1)) {
+		setting_info->video_device_status = crt_setting_info.iga_path;
+	} else if ((video_on_dvi == 1) && (DVI_ON == 1)) {
+		setting_info->video_device_status = tmds_setting_info.iga_path;
+	} else if ((video_on_lcd == 1) && (LCD_ON == 1)) {
+		setting_info->video_device_status = lvds_setting_info.iga_path;
+	} else {
+		setting_info->video_device_status = 0;
+	}
+
+	setting_info->samm_status = SAMM_ON;
+	setting_info->primary_device = get_primary_device();
+
+	setting_info->first_dev_bpp = via_fb_bpp;
+	setting_info->second_dev_bpp = via_fb_bpp1;
+
+	setting_info->first_dev_refresh = refresh;
+	setting_info->second_dev_refresh = refresh1;
+
+	setting_info->first_dev_hor_res = via_fb_hotplug_Xres;
+	setting_info->first_dev_ver_res = via_fb_hotplug_Yres;
+	setting_info->second_dev_hor_res = second_xres;
+	setting_info->second_dev_ver_res = second_yres;
+
+	/* Get lcd attributes */
+	setting_info->lcd_attributes.display_center = lcd_dsp_method;
+	setting_info->lcd_attributes.panel_id = lcd_panel_id;
+	setting_info->lcd_attributes.lcd_mode = lcd_mode;
+}
+
+static void parse_active_dev(void)
+{
+	CRT_ON = STATE_OFF;
+	DVI_ON = STATE_OFF;
+	LCD_ON = STATE_OFF;
+	LCD2_ON = STATE_OFF;
+	/* 1. Modify the active status of devices. */
+	/* 2. Keep the order of devices, so we can set corresponding
+	   IGA path to devices in SAMM case. */
+	/*    Note: The previous of active_dev is primary device,
+	   and the following is secondary device. */
+	if (!strncmp(active_dev, "CRT+DVI", 7)) {
+		/* CRT+DVI */
+		CRT_ON = STATE_ON;
+		DVI_ON = STATE_ON;
+		primary_dev = CRT_Device;
+	} else if (!strncmp(active_dev, "DVI+CRT", 7)) {
+		/* DVI+CRT */
+		CRT_ON = STATE_ON;
+		DVI_ON = STATE_ON;
+		primary_dev = DVI_Device;
+	} else if (!strncmp(active_dev, "CRT+LCD", 7)) {
+		/* CRT+LCD */
+		CRT_ON = STATE_ON;
+		LCD_ON = STATE_ON;
+		primary_dev = CRT_Device;
+	} else if (!strncmp(active_dev, "LCD+CRT", 7)) {
+		/* LCD+CRT */
+		CRT_ON = STATE_ON;
+		LCD_ON = STATE_ON;
+		primary_dev = LCD_Device;
+	} else if (!strncmp(active_dev, "DVI+LCD", 7)) {
+		/* DVI+LCD */
+		DVI_ON = STATE_ON;
+		LCD_ON = STATE_ON;
+		primary_dev = DVI_Device;
+	} else if (!strncmp(active_dev, "LCD+DVI", 7)) {
+		/* LCD+DVI */
+		DVI_ON = STATE_ON;
+		LCD_ON = STATE_ON;
+		primary_dev = LCD_Device;
+	} else if (!strncmp(active_dev, "LCD+LCD2", 8)) {
+		LCD_ON = STATE_ON;
+		LCD2_ON = STATE_ON;
+		primary_dev = LCD_Device;
+	} else if (!strncmp(active_dev, "LCD2+LCD", 8)) {
+		LCD_ON = STATE_ON;
+		LCD2_ON = STATE_ON;
+		primary_dev = LCD2_Device;
+	} else if (!strncmp(active_dev, "CRT", 3)) {
+		/* CRT only */
+		CRT_ON = STATE_ON;
+		SAMM_ON = STATE_OFF;
+	} else if (!strncmp(active_dev, "DVI", 3)) {
+		/* DVI only */
+		DVI_ON = STATE_ON;
+		SAMM_ON = STATE_OFF;
+	} else if (!strncmp(active_dev, "LCD", 3)) {
+		/* LCD only */
+		LCD_ON = STATE_ON;
+		SAMM_ON = STATE_OFF;
+	} else {
+		CRT_ON = STATE_ON;
+		SAMM_ON = STATE_OFF;
+	}
+	parinfo.duoview = is_duoview();
+}
+
+static void parse_video_dev(void)
+{
+	video_on_crt = STATE_OFF;
+	video_on_dvi = STATE_OFF;
+	video_on_lcd = STATE_OFF;
+
+	if (!strncmp(video_dev, "CRT", 3)) {
+		/* Video on CRT */
+		video_on_crt = STATE_ON;
+	} else if (!strncmp(video_dev, "DVI", 3)) {
+		/* Video on DVI */
+		video_on_dvi = STATE_ON;
+	} else if (!strncmp(video_dev, "LCD", 3)) {
+		/* Video on LCD */
+		video_on_lcd = STATE_ON;
+	}
+}
+
+static int parse_port(char *opt_str, int *output_interface)
+{
+	if (!strncmp(opt_str, "DVP0", 4)) {
+		*output_interface = INTERFACE_DVP0;
+	} else if (!strncmp(opt_str, "DVP1", 4)) {
+		*output_interface = INTERFACE_DVP1;
+	} else if (!strncmp(opt_str, "DFP_HIGHLOW", 11)) {
+		*output_interface = INTERFACE_DFP;
+	} else if (!strncmp(opt_str, "DFP_HIGH", 8)) {
+		*output_interface = INTERFACE_DFP_HIGH;
+	} else if (!strncmp(opt_str, "DFP_LOW", 8)) {
+		*output_interface = INTERFACE_DFP_LOW;
+	} else {
+		*output_interface = INTERFACE_NONE;
+	}
+	return 0;
+}
+
+static void parse_lcd_port(void)
+{
+	parse_port(lcd_port, &chip_info.lvds_chip_info.output_interface);
+	/*Initialize to avoid unexpected behavior */
+	chip_info.lvds_chip_info2.output_interface = INTERFACE_NONE;
+
+	DEBUG_MSG(KERN_INFO "parse_lcd_port: lcd_port:%s,interface:%d\n",
+		  lcd_port, chip_info.lvds_chip_info.output_interface);
+}
+
+static void parse_dvi_port(void)
+{
+	parse_port(dvi_port, &chip_info.tmds_chip_info.output_interface);
+
+	DEBUG_MSG(KERN_INFO "parse_dvi_port: dvi_port:%s,interface:%d\n",
+		  dvi_port, chip_info.tmds_chip_info.output_interface);
+}
+
+/*
+ * The proc filesystem read/write function, a simple proc implement to
+ * get/set the value of DPA  DVP0,   DVP0DataDriving,  DVP0ClockDriving, DVP1,
+ * DVP1Driving, DFPHigh, DFPLow CR96,   SR2A[5], SR1B[1], SR2A[4], SR1E[2],
+ * CR9B,    SR65,    CR97,    CR99
+ */
+static int viafb_dvp0_proc_read(char *buf, char **start, off_t offset,
+				int count, int *eof, void *data)
+{
+	int len = 0;
+	u8 dvp0_data_dri = 0, dvp0_clk_dri = 0, dvp0 = 0;
+	dvp0_data_dri =
+	    (read_reg(VIASR, SR2A) & BIT5) >> 4 | (read_reg(VIASR, SR1B) &
+						   BIT1) >> 1;
+	dvp0_clk_dri =
+	    (read_reg(VIASR, SR2A) & BIT4) >> 3 | (read_reg(VIASR, SR1E) &
+						   BIT2) >> 2;
+	dvp0 = read_reg(VIACR, CR96) & 0x0f;
+	len +=
+	    sprintf(buf + len, "%x %x %x\n", dvp0, dvp0_data_dri, dvp0_clk_dri);
+	*eof = 1;		/*Inform kernel end of data */
+	return len;
+}
+static int viafb_dvp0_proc_write(struct file *file,
+				 const char __user *buffer,
+				 unsigned long count, void *data)
+{
+	char buf[20], *value, *pbuf;
+	u8 reg_val = 0;
+	unsigned long length, i;
+	if (count < 1)
+		return -EINVAL;
+	length = count > 20 ? 20 : count;
+	if (copy_from_user(&buf[0], buffer, length))
+		return -EFAULT;
+	buf[length - 1] = '\0';	/*Ensure end string */
+	pbuf = &buf[0];
+	for (i = 0; i < 3; i++) {
+		value = strsep(&pbuf, " ");
+		if (value != NULL) {
+			reg_val = simple_strtoul(value, NULL, 0);
+			DEBUG_MSG(KERN_INFO "DVP0:reg_val[%ld]=:%x\n", i,
+				  reg_val);
+			switch (i) {
+			case 0:
+				write_reg_mask(CR96, VIACR, reg_val, 0x0f);
+				break;
+			case 1:
+				write_reg_mask(SR2A, VIASR, reg_val << 4, BIT5);
+				write_reg_mask(SR1B, VIASR, reg_val << 1, BIT1);
+				break;
+			case 2:
+				write_reg_mask(SR2A, VIASR, reg_val << 3, BIT4);
+				write_reg_mask(SR1E, VIASR, reg_val << 2, BIT2);
+				break;
+			default:
+				break;
+			}
+		} else {
+			break;
+		}
+	}
+	return count;
+}
+static int viafb_dvp1_proc_read(char *buf, char **start, off_t offset,
+				int count, int *eof, void *data)
+{
+	int len = 0;
+	u8 dvp1 = 0, dvp1_data_dri = 0, dvp1_clk_dri = 0;
+	dvp1 = read_reg(VIACR, CR9B) & 0x0f;
+	dvp1_data_dri = (read_reg(VIASR, SR65) & 0x0c) >> 2;
+	dvp1_clk_dri = read_reg(VIASR, SR65) & 0x03;
+	len +=
+	    sprintf(buf + len, "%x %x %x\n", dvp1, dvp1_data_dri, dvp1_clk_dri);
+	*eof = 1;		/*Inform kernel end of data */
+	return len;
+}
+static int viafb_dvp1_proc_write(struct file *file,
+				 const char __user *buffer,
+				 unsigned long count, void *data)
+{
+	char buf[20], *value, *pbuf;
+	u8 reg_val = 0;
+	unsigned long length, i;
+	if (count < 1)
+		return -EINVAL;
+	length = count > 20 ? 20 : count;
+	if (copy_from_user(&buf[0], buffer, length))
+		return -EFAULT;
+	buf[length - 1] = '\0';	/*Ensure end string */
+	pbuf = &buf[0];
+	for (i = 0; i < 3; i++) {
+		value = strsep(&pbuf, " ");
+		if (value != NULL) {
+			reg_val = simple_strtoul(value, NULL, 0);
+			switch (i) {
+			case 0:
+				write_reg_mask(CR9B, VIACR, reg_val, 0x0f);
+				break;
+			case 1:
+				write_reg_mask(SR65, VIASR, reg_val << 2, 0x0c);
+				break;
+			case 2:
+				write_reg_mask(SR65, VIASR, reg_val, 0x03);
+				break;
+			default:
+				break;
+			}
+		} else {
+			break;
+		}
+	}
+	return count;
+}
+
+static int viafb_dfph_proc_read(char *buf, char **start, off_t offset,
+				int count, int *eof, void *data)
+{
+	int len = 0;
+	u8 dfp_high = 0;
+	dfp_high = read_reg(VIACR, CR97) & 0x0f;
+	len += sprintf(buf + len, "%x\n", dfp_high);
+	*eof = 1;		/*Inform kernel end of data */
+	return len;
+}
+static int viafb_dfph_proc_write(struct file *file,
+				 const char __user *buffer,
+				 unsigned long count, void *data)
+{
+	char buf[20];
+	u8 reg_val = 0;
+	unsigned long length;
+	if (count < 1)
+		return -EINVAL;
+	length = count > 20 ? 20 : count;
+	if (copy_from_user(&buf[0], buffer, length))
+		return -EFAULT;
+	buf[length - 1] = '\0';	/*Ensure end string */
+	reg_val = simple_strtoul(&buf[0], NULL, 0);
+	write_reg_mask(CR97, VIACR, reg_val, 0x0f);
+	return count;
+}
+static int viafb_dfpl_proc_read(char *buf, char **start, off_t offset,
+				int count, int *eof, void *data)
+{
+	int len = 0;
+	u8 dfp_low = 0;
+	dfp_low = read_reg(VIACR, CR99) & 0x0f;
+	len += sprintf(buf + len, "%x\n", dfp_low);
+	*eof = 1;		/*Inform kernel end of data */
+	return len;
+}
+static int viafb_dfpl_proc_write(struct file *file,
+				 const char __user *buffer,
+				 unsigned long count, void *data)
+{
+	char buf[20];
+	u8 reg_val = 0;
+	unsigned long length;
+	if (count < 1)
+		return -EINVAL;
+	length = count > 20 ? 20 : count;
+	if (copy_from_user(&buf[0], buffer, length))
+		return -EFAULT;
+	buf[length - 1] = '\0';	/*Ensure end string */
+	reg_val = simple_strtoul(&buf[0], NULL, 0);
+	write_reg_mask(CR99, VIACR, reg_val, 0x0f);
+	return count;
+}
+static int viafb_vt1636_proc_read(char *buf, char **start, off_t offset,
+				  int count, int *eof, void *data)
+{
+	int len = 0;
+	u8 vt1636_08 = 0, vt1636_09 = 0;
+	switch (chip_info.lvds_chip_info.lvds_chip_name) {
+	case VT1636_LVDS:
+		vt1636_08 =
+		    gpio_i2c_read_lvds(&lvds_setting_info,
+				       &chip_info.lvds_chip_info, 0x08) & 0x0f;
+		vt1636_09 =
+		    gpio_i2c_read_lvds(&lvds_setting_info,
+				       &chip_info.lvds_chip_info, 0x09) & 0x1f;
+		len += sprintf(buf + len, "%x %x\n", vt1636_08, vt1636_09);
+		break;
+	default:
+		break;
+	}
+	switch (chip_info.lvds_chip_info2.lvds_chip_name) {
+	case VT1636_LVDS:
+		vt1636_08 =
+		    gpio_i2c_read_lvds(&lvds_setting_info2,
+				       &chip_info.lvds_chip_info2, 0x08) & 0x0f;
+		vt1636_09 =
+		    gpio_i2c_read_lvds(&lvds_setting_info2,
+				       &chip_info.lvds_chip_info2, 0x09) & 0x1f;
+		len += sprintf(buf + len, " %x %x\n", vt1636_08, vt1636_09);
+		break;
+	default:
+		break;
+	}
+	*eof = 1;		/*Inform kernel end of data */
+	return len;
+}
+static int viafb_vt1636_proc_write(struct file *file,
+				   const char __user *buffer,
+				   unsigned long count, void *data)
+{
+	char buf[30], *value, *pbuf;
+	struct IODATA reg_val;
+	unsigned long length, i;
+	if (count < 1)
+		return -EINVAL;
+	length = count > 30 ? 30 : count;
+	if (copy_from_user(&buf[0], buffer, length))
+		return -EFAULT;
+	buf[length - 1] = '\0';	/*Ensure end string */
+	pbuf = &buf[0];
+	switch (chip_info.lvds_chip_info.lvds_chip_name) {
+	case VT1636_LVDS:
+		for (i = 0; i < 2; i++) {
+			value = strsep(&pbuf, " ");
+			if (value != NULL) {
+				reg_val.Data = simple_strtoul(value, NULL, 0);
+				switch (i) {
+				case 0:
+					reg_val.Index = 0x08;
+					reg_val.Mask = 0x0f;
+					gpio_i2c_write_mask_lvds
+					    (&lvds_setting_info,
+					     &chip_info.lvds_chip_info,
+					     reg_val);
+					break;
+				case 1:
+					reg_val.Index = 0x09;
+					reg_val.Mask = 0x1f;
+					gpio_i2c_write_mask_lvds
+					    (&lvds_setting_info,
+					     &chip_info.lvds_chip_info,
+					     reg_val);
+					break;
+				default:
+					break;
+				}
+			} else {
+				break;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	switch (chip_info.lvds_chip_info2.lvds_chip_name) {
+	case VT1636_LVDS:
+		for (i = 0; i < 2; i++) {
+			value = strsep(&pbuf, " ");
+			if (value != NULL) {
+				reg_val.Data = simple_strtoul(value, NULL, 0);
+				switch (i) {
+				case 0:
+					reg_val.Index = 0x08;
+					reg_val.Mask = 0x0f;
+					gpio_i2c_write_mask_lvds
+					    (&lvds_setting_info2,
+					     &chip_info.lvds_chip_info2,
+					     reg_val);
+					break;
+				case 1:
+					reg_val.Index = 0x09;
+					reg_val.Mask = 0x1f;
+					gpio_i2c_write_mask_lvds
+					    (&lvds_setting_info2,
+					     &chip_info.lvds_chip_info2,
+					     reg_val);
+					break;
+				default:
+					break;
+				}
+			} else {
+				break;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	return count;
+}
+
+static void viafb_init_proc(struct proc_dir_entry *viafb_entry)
+{
+	struct proc_dir_entry *entry;
+	viafb_entry = proc_mkdir("viafb", NULL);
+	if (viafb_entry) {
+		entry = create_proc_entry("dvp0", 0, viafb_entry);
+		if (entry) {
+			entry->owner = THIS_MODULE;
+			entry->read_proc = viafb_dvp0_proc_read;
+			entry->write_proc = viafb_dvp0_proc_write;
+		}
+		entry = create_proc_entry("dvp1", 0, viafb_entry);
+		if (entry) {
+			entry->owner = THIS_MODULE;
+			entry->read_proc = viafb_dvp1_proc_read;
+			entry->write_proc = viafb_dvp1_proc_write;
+		}
+		entry = create_proc_entry("dfph", 0, viafb_entry);
+		if (entry) {
+			entry->owner = THIS_MODULE;
+			entry->read_proc = viafb_dfph_proc_read;
+			entry->write_proc = viafb_dfph_proc_write;
+		}
+		entry = create_proc_entry("dfpl", 0, viafb_entry);
+		if (entry) {
+			entry->owner = THIS_MODULE;
+			entry->read_proc = viafb_dfpl_proc_read;
+			entry->write_proc = viafb_dfpl_proc_write;
+		}
+		if (VT1636_LVDS == chip_info.lvds_chip_info.lvds_chip_name
+		    || VT1636_LVDS ==
+		    chip_info.lvds_chip_info2.lvds_chip_name) {
+			entry = create_proc_entry("vt1636", 0, viafb_entry);
+			if (entry) {
+				entry->owner = THIS_MODULE;
+				entry->read_proc = viafb_vt1636_proc_read;
+				entry->write_proc = viafb_vt1636_proc_write;
+			}
+		}
+
+	}
+}
+static void viafb_remove_proc(struct proc_dir_entry *viafb_entry)
+{
+	/* no problem if it was not registered */
+	remove_proc_entry("dvp0", viafb_entry);/* parent dir */
+	remove_proc_entry("dvp1", viafb_entry);
+	remove_proc_entry("dfph", viafb_entry);
+	remove_proc_entry("dfpl", viafb_entry);
+	remove_proc_entry("vt1636", viafb_entry);
+	remove_proc_entry("vt1625", viafb_entry);
+}
+
+static int __devinit via_pci_probe(void)
+{
+
+	/*unsigned char revision; */
+	unsigned int default_xres, default_yres;
+	char *tmpc, *tmpm;
+	char *tmpc_sec, *tmpm_sec;
+	int vmode_index;
+
+	DEBUG_MSG(KERN_INFO "VIAFB PCI Probe!!\n");
+	init_global_var();
+	if (dual_fb)
+		SAMM_ON = 1;
+	parse_active_dev();
+	parse_video_dev();
+	parse_lcd_port();
+	parse_dvi_port();
+
+	/* for dual-fb must SAMM_ON=1 and dual_fb=1 */
+	if (!SAMM_ON)
+		dual_fb = 0;
+
+	init_chip_info();
+	get_fb_info(&parinfo.fbmem, &parinfo.memsize);
+	parinfo.fbmem_free = parinfo.memsize;
+	parinfo.fbmem_used = 0;
+	parinfo.fbmem_virt = ioremap_nocache(parinfo.fbmem, parinfo.memsize);
+	viafbinfo.screen_base = (char *)parinfo.fbmem_virt;
+
+	if (!parinfo.fbmem_virt) {
+		printk(KERN_INFO "ioremap failed\n");
+		return -1;
+	}
+
+	get_mmio_info(&parinfo.mmio_base, &parinfo.mmio_len);
+	parinfo.io_virt = ioremap_nocache(parinfo.mmio_base, parinfo.mmio_len);
+
+	viafbinfo.par = &parinfo;
+	viafbinfo.node = 0;
+	viafbinfo.fbops = &viafb_ops;
+	viafbinfo.flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;
+
+	viafbinfo.pseudo_palette = pseudo_pal;
+	if (via_fb_accel) {
+		init_accel();
+		parinfo.accel = 1;
+		init_2d_engine();
+		hw_cursor_init();
+	}
+
+	if (second_size && (second_size < 8)) {
+		second_offset = parinfo.fbmem_free - second_size * 1024 * 1024;
+	} else {
+		second_size = 8;
+		second_offset = parinfo.fbmem_free - second_size * 1024 * 1024;
+	}
+
+	FB_MM = parinfo.fbmem_virt;
+	tmpm = mode;
+	tmpc = strsep(&tmpm, "x");
+	default_xres = simple_strtoul(tmpc, NULL, 0);
+	default_yres = simple_strtoul(tmpm, NULL, 0);
+
+	vmode_index = get_mode_index(default_xres, default_yres, 0);
+	DEBUG_MSG(KERN_INFO "0->index=%d\n", vmode_index);
+
+	if (SAMM_ON == 1) {
+		if (strcmp(mode, mode1)) {
+			tmpm_sec = mode1;
+			tmpc_sec = strsep(&tmpm_sec, "x");
+			second_xres = simple_strtoul(tmpc_sec, NULL, 0);
+			second_yres = simple_strtoul(tmpm_sec, NULL, 0);
+		} else {
+			second_xres = default_xres;
+			second_yres = default_yres;
+		}
+		if (0 == second_virtual_xres) {
+			switch (second_xres) {
+			case 1400:
+				second_virtual_xres = 1408;
+				break;
+			default:
+				second_virtual_xres = second_xres;
+				break;
+			}
+		}
+		if (0 == second_virtual_yres)
+			second_virtual_yres = second_yres;
+	}
+
+	switch (via_fb_bpp) {
+	case 0 ... 8:
+		via_fb_bpp = 8;
+		break;
+	case 9 ... 16:
+		via_fb_bpp = 16;
+		break;
+	case 17 ... 32:
+		via_fb_bpp = 32;
+		break;
+	default:
+		via_fb_bpp = 8;
+	}
+	default_var.xres = default_xres;
+	default_var.yres = default_yres;
+	switch (default_xres) {
+	case 1400:
+		default_var.xres_virtual = 1408;
+		break;
+	default:
+		default_var.xres_virtual = default_xres;
+		break;
+	}
+	default_var.yres_virtual = default_yres;
+	default_var.bits_per_pixel = via_fb_bpp;
+	if (default_var.bits_per_pixel == 15)
+		default_var.bits_per_pixel = 16;
+	default_var.pixclock =
+	    get_pixclock(default_xres, default_yres, refresh);
+	default_var.left_margin = (default_xres >> 3) & 0xf8;
+	default_var.right_margin = 32;
+	default_var.upper_margin = 16;
+	default_var.lower_margin = 4;
+	default_var.hsync_len = default_var.left_margin;
+	default_var.vsync_len = 4;
+	default_var.accel_flags = 0;
+
+	viafbinfo.fix.accel = via_fb_accel;
+	parinfo.accel = via_fb_accel;
+	if (via_fb_accel)
+		viafbinfo.flags |=
+		    (FBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |
+		     FBINFO_HWACCEL_IMAGEBLIT);
+	else
+		viafbinfo.flags |= FBINFO_HWACCEL_DISABLED;
+
+	if (dual_fb) {
+		parinfo1 = parinfo;
+		parinfo1.memsize = parinfo.memsize - second_offset;
+		parinfo.memsize = second_offset;
+		parinfo1.fbmem_virt = parinfo.fbmem_virt + second_offset;
+		parinfo1.fbmem = parinfo.fbmem + second_offset;
+
+		parinfo1.fbmem_used = parinfo.fbmem_used;
+		parinfo1.fbmem_free = parinfo1.memsize - parinfo1.fbmem_used;
+		parinfo.fbmem_free = parinfo.memsize;
+		parinfo.fbmem_used = 0;
+		if (via_fb_accel) {
+			parinfo1.cursor_start =
+			    parinfo.cursor_start - second_offset;
+			parinfo1.VQ_start = parinfo.VQ_start - second_offset;
+			parinfo1.VQ_end = parinfo.VQ_end - second_offset;
+		}
+
+		viafbinfo1 = viafbinfo;
+		viafbinfo1.screen_base = viafbinfo.screen_base + second_offset;
+		viafbinfo1.fix.smem_start = parinfo1.fbmem;
+		viafbinfo1.fix.smem_len = parinfo1.fbmem_free;
+		viafbinfo1.par = &parinfo1;
+
+		default_var.xres = second_xres;
+		default_var.yres = second_yres;
+		default_var.xres_virtual = second_virtual_xres;
+		default_var.yres_virtual = second_virtual_yres;
+		if (via_fb_bpp1 != via_fb_bpp)
+			via_fb_bpp1 = via_fb_bpp;
+		default_var.bits_per_pixel = via_fb_bpp1;
+		default_var.pixclock =
+		    get_pixclock(second_xres, second_yres, refresh);
+		default_var.left_margin = (second_xres >> 3) & 0xf8;
+		default_var.right_margin = 32;
+		default_var.upper_margin = 16;
+		default_var.lower_margin = 4;
+		default_var.hsync_len = default_var.left_margin;
+		default_var.vsync_len = 4;
+
+		viafb_check_var(&default_var, &viafbinfo1);
+		parinfo1.var = default_var;
+		viafbinfo1.var = parinfo1.var;
+		viafb_get_fix(&viafbinfo1.fix, &viafbinfo1);
+	}
+
+	viafbinfo.fix.smem_start = parinfo.fbmem;
+	viafbinfo.fix.smem_len = parinfo.fbmem_free;
+	viafb_check_var(&default_var, &viafbinfo);
+	parinfo.var = default_var;
+	viafbinfo.var = parinfo.var;
+	viafb_get_fix(&viafbinfo.fix, &viafbinfo);
+	default_var.activate = FB_ACTIVATE_NOW;
+	viafbinfo.cmap = viafb_256_colors;
+
+	if (dual_fb && (primary_dev == LCD_Device)
+	    && (chip_info.gfx_chip_name == UNICHROME_CLE266)) {
+		if (register_framebuffer(&viafbinfo1) < 0)
+			return -EINVAL;
+	}
+	if (register_framebuffer(&viafbinfo) < 0)
+		return -EINVAL;
+
+	if (dual_fb && ((primary_dev != LCD_Device)
+			|| (chip_info.gfx_chip_name != UNICHROME_CLE266))) {
+		if (register_framebuffer(&viafbinfo1) < 0)
+			return -EINVAL;
+	}
+	DEBUG_MSG(KERN_INFO "fb%d: %s frame buffer device %dx%d-%dbpp\n",
+		  viafbinfo.node, viafbinfo.fix.id, default_var.xres,
+		  default_var.yres, default_var.bits_per_pixel);
+
+	viafb_init_proc(parinfo.proc_entry);
+	init_dac(IGA2);
+	return 0;
+}
+
+static void __devexit via_pci_remove(void)
+{
+	DEBUG_MSG(KERN_INFO "via_pci_remove!\n");
+	unregister_framebuffer(&viafbinfo);
+	if (dual_fb)
+		unregister_framebuffer(&viafbinfo1);
+	iounmap((void *)parinfo.fbmem_virt);
+
+	viafb_remove_proc(parinfo.proc_entry);
+}
+
+static int __init viafb_setup(char *options)
+{
+	char *this_opt;
+	DEBUG_MSG(KERN_INFO "viafb_setup!\n");
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+
+		if (!strncmp(this_opt, "mode=", 5)) {
+			mode = kmalloc(strlen(this_opt + 4), GFP_KERNEL);
+			strcpy(mode, this_opt + 5);
+		} else if (!strncmp(this_opt, "mode1=", 6)) {
+			mode1 = kmalloc(strlen(this_opt + 5), GFP_KERNEL);
+			strcpy(mode1, this_opt + 6);
+		} else if (!strncmp(this_opt, "bpp=", 4)) {
+			via_fb_bpp = simple_strtoul(this_opt + 4, NULL, 0);
+		} else if (!strncmp(this_opt, "bpp1=", 5)) {
+			via_fb_bpp1 = simple_strtoul(this_opt + 5, NULL, 0);
+		} else if (!strncmp(this_opt, "refresh=", 8)) {
+			refresh = simple_strtoul(this_opt + 8, NULL, 0);
+		} else if (!strncmp(this_opt, "refresh1=", 9)) {
+			refresh1 = simple_strtoul(this_opt + 9, NULL, 0);
+		} else if (!strncmp(this_opt, "lcd_dsp_method=", 15)) {
+			lcd_dsp_method = simple_strtoul(this_opt + 15, NULL, 0);
+		} else if (!strncmp(this_opt, "lcd_panel_id=", 13)) {
+			lcd_panel_id = simple_strtoul(this_opt + 13, NULL, 0);
+		} else if (!strncmp(this_opt, "via_fb_accel=", 6)) {
+			via_fb_accel = simple_strtoul(this_opt + 6, NULL, 0);
+		} else if (!strncmp(this_opt, "SAMM_ON=", 8)) {
+			SAMM_ON = simple_strtoul(this_opt + 8, NULL, 0);
+		} else if (!strncmp(this_opt, "active_dev=", 11)) {
+			active_dev = kmalloc(strlen(this_opt + 10), GFP_KERNEL);
+			strcpy(active_dev, this_opt + 11);
+		} else if (!strncmp(this_opt, "display_hardware_layout=", 24)) {
+			display_hardware_layout =
+			    simple_strtoul(this_opt + 24, NULL, 0);
+		} else if (!strncmp(this_opt, "second_size=", 12)) {
+			second_size = simple_strtoul(this_opt + 12, NULL, 0);
+		} else if (!strncmp(this_opt, "platform_epia_dvi=", 9)) {
+			platform_epia_dvi =
+			    simple_strtoul(this_opt + 9, NULL, 0);
+		} else if (!strncmp(this_opt, "device_lcd_dualedge =", 12)) {
+			device_lcd_dualedge =
+			    simple_strtoul(this_opt + 12, NULL, 0);
+		} else if (!strncmp(this_opt, "via_bus_width=", 9)) {
+			via_bus_width = simple_strtoul(this_opt + 9, NULL, 0);
+		} else if (!strncmp(this_opt, "lcd_mode=", 9)) {
+			lcd_mode = simple_strtoul(this_opt + 9, NULL, 0);
+		} else if (!strncmp(this_opt, "video_dev=", 10)) {
+			video_dev = kmalloc(strlen(this_opt + 9), GFP_KERNEL);
+			strcpy(video_dev, this_opt + 10);
+		} else if (!strncmp(this_opt, "lcd_port=", 9)) {
+			lcd_port = kmalloc(strlen(this_opt + 8), GFP_KERNEL);
+			strcpy(lcd_port, this_opt + 9);
+		}
+	}
+	return 0;
+}
+
+static int __init viafb_init(void)
+{
+	DEBUG_MSG(KERN_INFO "viafb_init!\n");
+	printk(KERN_INFO
+       "VIA Graphics Intergration Chipset framebuffer %d.%d initializing\n",
+	       VERSION_MAJOR, VERSION_MINOR);
+#ifndef MODULE
+	char *option = NULL;
+	if (fb_get_options("viafb", &option))
+		return -ENODEV;
+	viafb_setup(option);
+#endif
+	return via_pci_probe();
+}
+
+static void __exit viafb_exit(void)
+{
+	DEBUG_MSG(KERN_INFO "viafb_exit!\n");
+	if (timer_on) {
+		del_timer(&timer_for3D);
+		timer_on = 0;
+	}
+	via_pci_remove();
+}
+
+static struct fb_ops viafb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = viafb_open,
+	.fb_release = viafb_release,
+	.fb_check_var = viafb_check_var,
+	.fb_set_par = viafb_set_par,
+	.fb_setcolreg = viafb_setcolreg,
+	.fb_pan_display = viafb_pan_display,
+	.fb_blank = viafb_blank,
+	.fb_fillrect = viafb_fillrect,
+	.fb_copyarea = viafb_copyarea,
+	.fb_imageblit = viafb_imageblit,
+	.fb_cursor = viafb_cursor,
+	.fb_ioctl = viafb_ioctl,
+	.fb_sync = viafb_sync,
+	.fb_setcmap = viafb_setcmap,
+};
+
+module_init(viafb_init);
+module_exit(viafb_exit);
+
+#ifdef MODULE
+module_param(via_fb_memsize, int, 0);
+
+module_param(mode, charp, 0);
+MODULE_PARM_DESC(mode, "Set resolution (default=640x480)");
+
+module_param(mode1, charp, 0);
+MODULE_PARM_DESC(mode1, "Set resolution (default=640x480)");
+
+module_param(via_fb_bpp, int, 0);
+MODULE_PARM_DESC(via_fb_bpp, "Set color depth (default=32bpp)");
+
+module_param(via_fb_bpp1, int, 0);
+MODULE_PARM_DESC(via_fb_bpp1, "Set color depth (default=32bpp)");
+
+module_param(refresh, int, 0);
+MODULE_PARM_DESC(refresh, "Set CRT refresh rate (default = 60)");
+
+module_param(refresh1, int, 0);
+MODULE_PARM_DESC(refresh1, "Set CRT refresh rate (default = 60)");
+
+module_param(lcd_panel_id, int, 0);
+MODULE_PARM_DESC(lcd_panel_id, "Set Flat Panel type(Default=1024x768)");
+
+module_param(lcd_dsp_method, int, 0);
+MODULE_PARM_DESC(lcd_dsp_method,
+		 "Set Flat Panel display scaling method.(Default=Expandsion)");
+
+module_param(SAMM_ON, int, 0);
+MODULE_PARM_DESC(SAMM_ON, "Turn on/off flag of SAMM(Default=OFF)");
+
+module_param(via_fb_accel, int, 0);
+MODULE_PARM_DESC(via_fb_accel, "Set 2D Hardware Acceleration.(Default = OFF)");
+
+module_param(active_dev, charp, 0);
+MODULE_PARM_DESC(active_dev, "Specify active devices.");
+
+module_param(display_hardware_layout, int, 0);
+MODULE_PARM_DESC(display_hardware_layout,
+		 "Display Hardware Layout (LCD Only, DVI Only...,etc)");
+
+module_param(second_size, int, 0);
+MODULE_PARM_DESC(second_size, "Set secondary device memory size");
+
+module_param(dual_fb, int, 0);
+MODULE_PARM_DESC(dual_fb,
+	"Turn on/off flag of dual framebuffer devices.(Default = OFF)");
+
+module_param(platform_epia_dvi, int, 0);
+MODULE_PARM_DESC(platform_epia_dvi,
+	"Turn on/off flag of DVI devices on EPIA board.(Default = OFF)");
+
+module_param(device_lcd_dualedge, int, 0);
+MODULE_PARM_DESC(device_lcd_dualedge,
+		 "Turn on/off flag of dual edge panel.(Default = OFF)");
+
+module_param(via_bus_width, int, 0);
+MODULE_PARM_DESC(via_bus_width, "Set bus width of panel.(Default = 12)");
+
+module_param(lcd_mode, int, 0);
+MODULE_PARM_DESC(lcd_mode, "Set Flat Panel mode(Default=OPENLDI)");
+
+module_param(video_dev, charp, 0);
+MODULE_PARM_DESC(video_dev, "Specify video devices.");
+
+module_param(lcd_port, charp, 0);
+MODULE_PARM_DESC(lcd_port, "Specify LCD output port.");
+
+module_param(dvi_port, charp, 0);
+MODULE_PARM_DESC(dvi_port, "Specify DVI output port.");
+
+MODULE_LICENSE("GPL");
+#endif
--- /dev/null
+++ b/drivers/video/viafb/viafbdev.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __VIAFBDEV_H__
+#define __VIAFBDEV_H__
+
+#include <linux/proc_fs.h>
+#include <linux/fb.h>
+#include "ioctl.h"
+#include "share.h"
+#include "chip.h"
+#include "hw.h"
+
+#define VERSION_MAJOR       2
+#define VERSION_KERNEL      6	/* For kernel 2.6 */
+
+#define VERSION_OS          0	/* 0: for 32 bits OS, 1: for 64 bits OS */
+#define VERSION_MINOR       4
+
+struct viafb_par {
+	struct fb_var_screeninfo var;
+	int bpp;
+	int hres;
+	int vres;
+	int linelength;
+	int vclk;		/*in MHz */
+
+	int vtotal;
+	int vdispend;
+	int vsyncstart;
+	int vsyncend;
+	int vblankstart;
+	int vblankend;
+
+	int htotal;
+	int hdispend;
+	int hsyncstart;
+	int hsyncend;
+	int hblankstart;
+	int hblankend;
+
+	int accel;		/* Acceleration Flags */
+
+	void __iomem *fbmem_virt;	/*framebuffer virtual memory address */
+	void __iomem *io_virt;	/*iospace virtual memory address */
+	unsigned int fbmem;	/*framebuffer physical memory address */
+	unsigned int memsize;	/*size of fbmem */
+	unsigned int io;	/*io space address */
+	unsigned long mmio_base;	/*mmio base address */
+	unsigned long mmio_len;	/*mmio base length */
+	u32 fbmem_free;		/* Free FB memory */
+	u32 fbmem_used;		/* Use FB memory size */
+	u32 cursor_start;	/* Cursor Start Address */
+	u32 VQ_start;		/* Virtual Queue Start Address */
+	u32 VQ_end;		/* Virtual Queue End Address */
+	u32 iga_path;
+	struct proc_dir_entry *proc_entry;	/*viafb proc entry */
+	u8 duoview;		/*Is working in duoview mode? */
+};
+extern unsigned int second_virtual_yres;
+extern unsigned int second_virtual_xres;
+extern unsigned int second_offset;
+extern int second_size;
+extern int SAMM_ON;
+extern int dual_fb;
+extern int LCD2_ON;
+extern int LCD_ON;
+extern int DVI_ON;
+extern int via_fb_accel;
+extern int via_fb_hotplug;
+extern int via_fb_memsize;
+
+extern int soft_cursor(struct fb_info *info, struct fb_cursor *cursor);
+
+void memory_pitch_patch(struct fb_info *info);
+void fill_var_timing_info(struct fb_var_screeninfo *var, int refresh,
+			  int mode_index);
+int apply_device_setting(struct viafb_ioctl_setting ViaSetting,
+			 struct fb_info *info);
+void retrieve_device_setting(struct viafb_ioctl_setting *ViaSetting);
+
+int get_primary_device(void);
+int get_mode_index(int hres, int vres, int flag);
+void viafb_set_device(struct device_t active_dev);
+
+u8 gpio_i2c_read_lvds(struct lvds_setting_information *plvds_setting_info,
+		      struct lvds_chip_information *plvds_chip_info, u8 index);
+void gpio_i2c_write_mask_lvds(struct lvds_setting_information
+			      *plvds_setting_info, struct lvds_chip_information
+			      *plvds_chip_info, struct IODATA io_data);
+void viafb_set_video_device(u32 video_dev_info);
+void viafb_get_video_device(u32 *video_dev_info);
+void apply_second_mode_setting(struct fb_var_screeninfo *sec_var);
+void init_global_var(void);
+#endif /* __VIAFBDEV_H__ */
--- /dev/null
+++ b/drivers/video/viafb/viafb.modes
@@ -0,0 +1,870 @@
+#
+#
+#   These data are based on the CRTC parameters in
+#
+#       VIA Integration Graphics Chip
+#       (C) 2004 VIA Technologies Inc.
+#
+
+#
+#   640x480, 60 Hz, Non-Interlaced (25.175 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      640     480
+#   Scan Frequency      31.469 kHz  59.94 Hz
+#   Sync Width      3.813 us    0.064 ms
+#               12 chars    2 lines
+#   Front Porch     0.636 us    0.318  ms
+#               2 chars     10 lines
+#   Back Porch      1.907 us    1.048  ms
+#               6 chars     33 lines
+#   Active Time     25.422 us   15.253 ms
+#               80 chars    480 lines
+#   Blank Time      6.356 us    1.430 ms
+#               20 chars    45 lines
+#   Polarity        negative    negative
+#
+
+mode "640x480-60"
+# D: 25.175 MHz, H: 31.469 kHz, V: 59.94 Hz
+    geometry 640 480 640 480 32
+    timings 39722 48 16 33 10 96 2 endmode mode "480x640-60"
+# D: 24.823 MHz, H: 39.780 kHz, V: 60.00 Hz
+    geometry 480 640 480 640 32 timings 39722 72 24 19 1 48 3 endmode
+#
+#   640x480, 75 Hz, Non-Interlaced (31.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      640     480
+#   Scan Frequency      37.500 kHz  75.00 Hz
+#   Sync Width      2.032 us    0.080 ms
+#               8 chars     3 lines
+#   Front Porch     0.508 us    0.027 ms
+#               2 chars     1 lines
+#   Back Porch      3.810 us    0.427 ms
+#               15 chars    16 lines
+#   Active Time     20.317 us   12.800 ms
+#               80 chars    480 lines
+#   Blank Time      6.349 us    0.533 ms
+#               25 chars    20 lines
+#   Polarity        negative    negative
+#
+    mode "640x480-75"
+# D: 31.50 MHz, H: 37.500 kHz, V: 75.00 Hz
+    geometry 640 480 640 480 32 timings 31747 120 16 16 1 64 3 endmode
+#
+#   640x480, 85 Hz, Non-Interlaced (36.000 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      640     480
+#   Scan Frequency  43.269 kHz  85.00 Hz
+#   Sync Width      1.556 us    0.069 ms
+#               7 chars     3 lines
+#   Front Porch     1.556 us    0.023 ms
+#               7 chars     1 lines
+#   Back Porch      2.222 us    0.578 ms
+#               10 chars    25 lines
+#   Active Time     17.778 us   11.093 ms
+#               80 chars    480 lines
+#   Blank Time      5.333 us    0.670 ms
+#               24 chars    29 lines
+#   Polarity        negative    negative
+#
+    mode "640x480-85"
+# D: 36.000 MHz, H: 43.269 kHz, V: 85.00 Hz
+    geometry 640 480 640 480 32 timings 27777 80 56 25 1 56 3 endmode
+#
+#   640x480, 100 Hz, Non-Interlaced (43.163 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      640     480
+#   Scan Frequency      50.900 kHz  100.00 Hz
+#   Sync Width      1.483 us    0.058 ms
+#               8 chars     3 lines
+#   Front Porch     0.927 us    0.019 ms
+#               5 chars     1 lines
+#   Back Porch      2.409 us    0.475 ms
+#               13 chars    25 lines
+#   Active Time     14.827 us   9.430 ms
+#               80 chars    480 lines
+#   Blank Time      4.819 us    0.570 ms
+#               26 chars    29 lines
+#   Polarity        positive    positive
+#
+    mode "640x480-100"
+# D: 43.163 MHz, H: 50.900 kHz, V: 100.00 Hz
+    geometry 640 480 640 480 32 timings 23168 104 40 25 1 64 3 endmode
+#
+#   640x480, 120 Hz, Non-Interlaced (52.406 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      640     480
+#   Scan Frequency      61.800 kHz  120.00 Hz
+#   Sync Width      1.221 us    0.048 ms
+#               8 chars         3 lines
+#   Front Porch     0.763 us    0.016 ms
+#               5 chars     1 lines
+#   Back Porch      1.984 us    0.496 ms
+#               13 chars    31 lines
+#   Active Time     12.212 us   7.767 ms
+#               80 chars    480 lines
+#   Blank Time      3.969 us    0.566 ms
+#               26 chars    35 lines
+#   Polarity        positive    positive
+#
+    mode "640x480-120"
+# D: 52.406 MHz, H: 61.800 kHz, V: 120.00 Hz
+    geometry 640 480 640 480 32 timings 19081 104 40 31 1 64 3 endmode
+#
+#   720x480, 60 Hz, Non-Interlaced (26.880 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      720     480
+#   Scan Frequency      30.000 kHz  60.241 Hz
+#   Sync Width      2.679 us    0.099 ms
+#               9 chars     3 lines
+#   Front Porch     0.595 us    0.033 ms
+#               2 chars     1 lines
+#   Back Porch      3.274 us    0.462 ms
+#               11 chars    14 lines
+#   Active Time     26.786 us   16.000 ms
+#               90 chars    480 lines
+#   Blank Time      6.548 us    0.600 ms
+#               22 chars    18 lines
+#   Polarity        positive    positive
+#
+    mode "720x480-60"
+# D: 26.880 MHz, H: 30.000 kHz, V: 60.24 Hz
+    geometry 720 480 720 480 32 timings 37202 88 16 14 1 72 3 endmode
+#
+#   800x480, 60 Hz, Non-Interlaced (29.581 MHz dotclock)
+#
+#               Horizontal    Vertical
+#   Resolution      800         480
+#   Scan Frequency  29.892 kHz  60.00 Hz
+#   Sync Width      2.704 us    100.604 us
+#                   10 chars    3 lines
+#   Front Porch     0.541 us    33.535 us
+#                   2 chars     1 lines
+#   Back Porch      3.245 us    435.949 us
+#                   12 chars    13 lines
+#   Active Time     27.044 us   16.097 ms
+#                   100 chars   480 lines
+#   Blank Time      6.491 us    0.570 ms
+#                   24 chars    17 lines
+#   Polarity        positive    positive
+#
+    mode "800x480-60"
+# D: 29.500 MHz, H: 29.738 kHz, V: 60.00 Hz
+    geometry 800 480 800 480 32 timings 33805 96 24 10 3 72 7 endmode
+#
+#   720x576, 60 Hz, Non-Interlaced (32.668 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      720     576
+#   Scan Frequency      35.820 kHz  60.00 Hz
+#   Sync Width      2.204 us    0.083 ms
+#               9 chars     3 lines
+#   Front Porch     0.735 us    0.027 ms
+#               3 chars     1 lines
+#   Back Porch      2.939 us    0.459 ms
+#               12 chars    17 lines
+#   Active Time     22.040 us   16.080 ms
+#               90 chars    476 lines
+#   Blank Time      5.877 us    0.586 ms
+#               24 chars    21 lines
+#   Polarity        positive    positive
+#
+    mode "720x576-60"
+# D: 32.668 MHz, H: 35.820 kHz, V: 60.00 Hz
+    geometry 720 576 720 576 32 timings 30611 96 24 17 1 72 3 endmode
+#
+#   800x600, 60 Hz, Non-Interlaced (40.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      800     600
+#   Scan Frequency      37.879 kHz  60.32 Hz
+#   Sync Width      3.200 us    0.106 ms
+#               16 chars    4 lines
+#   Front Porch     1.000 us    0.026 ms
+#               5 chars     1 lines
+#   Back Porch      2.200 us    0.607 ms
+#               11 chars    23 lines
+#   Active Time     20.000 us   15.840 ms
+#               100 chars   600 lines
+#   Blank Time      6.400 us    0.739 ms
+#               32 chars    28 lines
+#   Polarity        positive    positive
+#
+    mode "800x600-60"
+# D: 40.00 MHz, H: 37.879 kHz, V: 60.32 Hz
+    geometry 800 600 800 600 32
+    timings 25000 88 40 23 1 128 4 hsync high vsync high endmode
+#
+#   800x600, 75 Hz, Non-Interlaced (49.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      800     600
+#   Scan Frequency      46.875 kHz  75.00 Hz
+#   Sync Width      1.616 us    0.064 ms
+#               10 chars    3 lines
+#   Front Porch     0.323 us    0.021 ms
+#               2 chars     1 lines
+#   Back Porch      3.232 us    0.448 ms
+#               20 chars    21 lines
+#   Active Time     16.162 us   12.800 ms
+#               100 chars   600 lines
+#   Blank Time      5.172 us    0.533 ms
+#               32 chars    25 lines
+#   Polarity        positive    positive
+#
+    mode "800x600-75"
+# D: 49.50 MHz, H: 46.875 kHz, V: 75.00 Hz
+    geometry 800 600 800 600 32
+    timings 20203 160 16 21 1 80 3 hsync high vsync high endmode
+#
+#   800x600, 85 Hz, Non-Interlaced (56.25 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      800     600
+#   Scan Frequency      53.674 kHz  85.061 Hz
+#   Sync Width      1.138 us    0.056 ms
+#               8 chars     3 lines
+#   Front Porch     0.569 us    0.019 ms
+#               4 chars     1 lines
+#   Back Porch      2.702 us    0.503 ms
+#               19 chars    27 lines
+#   Active Time     14.222 us   11.179 ms
+#               100 chars   600 lines
+#   Blank Time      4.409 us    0.578 ms
+#               31 chars    31 lines
+#   Polarity        positive    positive
+#
+    mode "800x600-85"
+# D: 56.25 MHz, H: 53.674 kHz, V: 85.061 Hz
+    geometry 800 600 800 600 32
+    timings 17777 152 32 27 1 64 3 hsync high vsync high endmode
+#
+#   800x600, 100 Hz, Non-Interlaced (67.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      800     600
+#   Scan Frequency      62.500 kHz  100.00 Hz
+#   Sync Width      0.948 us    0.064 ms
+#               8 chars     4 lines
+#   Front Porch     0.000 us    0.112 ms
+#               0 chars     7 lines
+#   Back Porch      3.200 us    0.224 ms
+#               27 chars    14 lines
+#   Active Time     11.852 us   9.600 ms
+#               100 chars   600 lines
+#   Blank Time      4.148 us    0.400 ms
+#               35 chars    25 lines
+#   Polarity        positive    positive
+#
+    mode "800x600-100"
+# D: 67.50 MHz, H: 62.500 kHz, V: 100.00 Hz
+    geometry 800 600 800 600 32
+    timings 14667 216 0 14 7 64 4 hsync high vsync high endmode
+#
+#   800x600, 120 Hz, Non-Interlaced (83.950 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      800     600
+#   Scan Frequency  77.160 kHz  120.00 Hz
+#   Sync Width      1.048 us    0.039 ms
+#               11 chars    3 lines
+#   Front Porch     0.667 us    0.013 ms
+#               7 chars     1 lines
+#   Back Porch      1.715 us    0.507 ms
+#               18 chars    39 lines
+#   Active Time     9.529 us    7.776 ms
+#               100 chars   600 lines
+#   Blank Time      3.431 us    0.557 ms
+#               36 chars    43 lines
+#   Polarity        positive    positive
+#
+    mode "800x600-120"
+# D: 83.950 MHz, H: 77.160 kHz, V: 120.00 Hz
+    geometry 800 600 800 600 32
+    timings 11912 144 56 39 1 88 3 hsync high vsync high endmode
+#
+#   848x480, 60 Hz, Non-Interlaced (31.490 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      848     480
+#   Scan Frequency  29.820 kHz  60.00 Hz
+#   Sync Width      2.795 us    0.099 ms
+#               11 chars    3 lines
+#   Front Porch     0.508 us    0.033 ms
+#               2 chars     1 lines
+#   Back Porch      3.303 us    0.429 ms
+#               13 chars    13 lines
+#   Active Time     26.929 us   16.097 ms
+#               106 chars   480 lines
+#   Blank Time      6.605 us    0.570 ms
+#               26 chars    17 lines
+#   Polarity        positive    positive
+#
+    mode "848x480-60"
+# D: 31.500 MHz, H: 29.830 kHz, V: 60.00 Hz
+    geometry 848 480 848 480 32
+    timings 31746 104 24 12 3 80 5 hsync high vsync high endmode
+#
+#   856x480, 60 Hz, Non-Interlaced (31.728 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      856     480
+#   Scan Frequency  29.820 kHz  60.00 Hz
+#   Sync Width      2.774 us    0.099 ms
+#               11 chars    3 lines
+#   Front Porch     0.504 us    0.033 ms
+#               2 chars     1 lines
+#   Back Porch      3.728 us    0.429 ms
+#               13 chars    13 lines
+#   Active Time     26.979 us   16.097 ms
+#               107 chars   480 lines
+#   Blank Time      6.556 us    0.570 ms
+#               26 chars    17 lines
+#   Polarity        positive    positive
+#
+    mode "856x480-60"
+# D: 31.728 MHz, H: 29.820 kHz, V: 60.00 Hz
+    geometry 856 480 856 480 32
+    timings 31518 104 16 13 1 88 3
+    hsync high vsync high endmode mode "960x600-60"
+# D: 45.250 MHz, H: 37.212 kHz, V: 60.00 Hz
+    geometry 960 600 960 600 32 timings 22099 128 32 15 3 96 6 endmode
+#
+#   1000x600, 60 Hz, Non-Interlaced (48.068 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1000     600
+#   Scan Frequency  37.320 kHz  60.00 Hz
+#   Sync Width      2.164 us    0.080 ms
+#               13 chars    3 lines
+#   Front Porch     0.832 us    0.027 ms
+#               5 chars     1 lines
+#   Back Porch      2.996 us    0.483 ms
+#               18 chars    18 lines
+#   Active Time     20.804 us   16.077 ms
+#               125 chars   600 lines
+#   Blank Time      5.991 us    0.589 ms
+#               36 chars    22 lines
+#   Polarity        negative    positive
+#
+    mode "1000x600-60"
+# D: 48.068 MHz, H: 37.320 kHz, V: 60.00 Hz
+    geometry 1000 600 1000 600 32
+    timings 20834 144 40 18 1 104 3 endmode mode "1024x576-60"
+# D: 46.996 MHz, H: 35.820 kHz, V: 60.00 Hz
+    geometry 1024 576 1024 576 32
+    timings 21278 144 40 17 1 104 3 endmode mode "1024x600-60"
+# D: 48.964 MHz, H: 37.320 kHz, V: 60.00 Hz
+    geometry 1024 600 1024 600 32
+    timings 20461 144 40 18 1 104 3 endmode mode "1088x612-60"
+# D: 52.952 MHz, H: 38.040 kHz, V: 60.00 Hz
+    geometry 1088 612 1088 612 32 timings 18877 152 48 16 3 104 5 endmode
+#
+#   1024x512, 60 Hz, Non-Interlaced (41.291 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1024    512
+#   Scan Frequency  31.860 kHz  60.00 Hz
+#   Sync Width      2.519 us    0.094 ms
+#               13 chars    3 lines
+#   Front Porch     0.775 us    0.031 ms
+#               4 chars     1 lines
+#   Back Porch      3.294 us    0.465 ms
+#               17 chars    15 lines
+#   Active Time     24.800 us   16.070 ms
+#               128 chars   512 lines
+#   Blank Time      6.587 us    0.596 ms
+#               34 chars    19 lines
+#   Polarity        positive    positive
+#
+    mode "1024x512-60"
+# D: 41.291 MHz, H: 31.860 kHz, V: 60.00 Hz
+    geometry 1024 512 1024 512 32
+    timings 24218 126 32 15 1 104 3 hsync high vsync high endmode
+#
+#   1024x600, 60 Hz, Non-Interlaced (48.875 MHz dotclock)
+#
+#                     Horizontal  Vertical
+#   Resolution          1024        768
+#   Scan Frequency      37.252 kHz  60.00 Hz
+#   Sync Width          2.128 us    80.532us
+#                       13 chars    3 lines
+#   Front Porch        0.818 us     26.844 us
+#                       5 chars     1 lines
+#   Back Porch          2.946 us    483.192 us
+#                       18 chars    18 lines
+#   Active Time         20.951 us   16.697 ms
+#                       128 chars   622 lines
+#   Blank Time          5.893 us    0.591 ms
+#                       36 chars    22 lines
+#   Polarity            negative    positive
+#
+#mode "1024x600-60"
+#     # D: 48.875 MHz, H: 37.252 kHz, V: 60.00 Hz
+#     geometry 1024 600 1024 600 32
+#    timings 20460  144 40 18 1 104  3
+# endmode
+#
+#   1024x768, 60 Hz, Non-Interlaced (65.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1024        768
+#   Scan Frequency      48.363 kHz  60.00 Hz
+#   Sync Width      2.092 us    0.124 ms
+#               17 chars    6 lines
+#   Front Porch     0.369 us    0.062 ms
+#               3 chars     3 lines
+#   Back Porch      2.462 us    0.601 ms
+#               20 chars    29 lines
+#   Active Time     15.754 us   15.880 ms
+#               128 chars   768 lines
+#   Blank Time      4.923 us    0.786 ms
+#               40 chars    38 lines
+#   Polarity        negative    negative
+#
+    mode "1024x768-60"
+# D: 65.00 MHz, H: 48.363 kHz, V: 60.00 Hz
+    geometry 1024 768 1024 768 32 timings 15385 160 24 29 3 136 6 endmode
+#
+#   1024x768, 75 Hz, Non-Interlaced (78.75 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1024        768
+#   Scan Frequency      60.023 kHz  75.03 Hz
+#   Sync Width      1.219 us    0.050 ms
+#               12 chars    3 lines
+#   Front Porch     0.203 us    0.017 ms
+#               2 chars     1 lines
+#   Back Porch      2.235 us    0.466 ms
+#               22 chars    28 lines
+#   Active Time     13.003 us   12.795 ms
+#               128 chars   768 lines
+#   Blank Time      3.657 us    0.533 ms
+#               36 chars    32 lines
+#   Polarity        positive    positive
+#
+    mode "1024x768-75"
+# D: 78.75 MHz, H: 60.023 kHz, V: 75.03 Hz
+    geometry 1024 768 1024 768 32
+    timings 12699 176 16 28 1 96 3 hsync high vsync high endmode
+#
+#   1024x768, 85 Hz, Non-Interlaced (94.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1024        768
+#   Scan Frequency  68.677 kHz  85.00 Hz
+#   Sync Width      1.016 us    0.044 ms
+#               12 chars    3 lines
+#   Front Porch     0.508 us    0.015 ms
+#               6 chars     1 lines
+#   Back Porch      2.201 us    0.524 ms
+#               26 chars    36 lines
+#   Active Time     10.836 us   11.183 ms
+#               128 chars   768 lines
+#   Blank Time      3.725 us    0.582 ms
+#               44 chars    40 lines
+#   Polarity        positive    positive
+#
+    mode "1024x768-85"
+# D: 94.50 MHz, H: 68.677 kHz, V: 85.00 Hz
+    geometry 1024 768 1024 768 32
+    timings 10582 208 48 36 1 96 3 hsync high vsync high endmode
+#
+#   1024x768, 100 Hz, Non-Interlaced (110.0 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1024        768
+#   Scan Frequency      79.023 kHz  99.78 Hz
+#   Sync Width      0.800 us    0.101 ms
+#               11 chars    8 lines
+#   Front Porch     0.000 us    0.000 ms
+#               0 chars     0 lines
+#   Back Porch      2.545 us    0.202 ms
+#               35 chars    16 lines
+#   Active Time     9.309 us    9.719 ms
+#               128 chars   768 lines
+#   Blank Time      3.345 us    0.304 ms
+#               46 chars    24 lines
+#   Polarity        negative    negative
+#
+    mode "1024x768-100"
+# D: 113.3 MHz, H: 79.023 kHz, V: 99.78 Hz
+    geometry 1024 768 1024 768 32
+    timings 8825 280 0 16 0 88 8 endmode mode "1152x720-60"
+# D: 66.750 MHz, H: 44.859 kHz, V: 60.00 Hz
+    geometry 1152 720 1152 720 32 timings 14981 168 56 19 3 112 6 endmode
+#
+#   1152x864, 75 Hz, Non-Interlaced (110.0 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1152        864
+#   Scan Frequency      75.137 kHz  74.99 Hz
+#   Sync Width      1.309 us    0.106 ms
+#               18 chars    8 lines
+#   Front Porch     0.245 us    0.599 ms
+#               3 chars     45 lines
+#   Back Porch      1.282 us    1.132 ms
+#               18 chars    85 lines
+#   Active Time     10.473 us   11.499 ms
+#               144 chars   864 lines
+#   Blank Time      2.836 us    1.837 ms
+#               39 chars    138 lines
+#   Polarity        positive    positive
+#
+    mode "1152x864-75"
+# D: 110.0 MHz, H: 75.137 kHz, V: 74.99 Hz
+    geometry 1152 864 1152 864 32
+    timings 9259 144 24 85 45 144 8
+    hsync high vsync high endmode mode "1200x720-60"
+# D: 70.184 MHz, H: 44.760 kHz, V: 60.00 Hz
+    geometry 1200 720 1200 720 32
+    timings 14253 184 28 22 1 128 3 endmode mode "1280x600-60"
+# D: 61.503 MHz, H: 37.320 kHz, V: 60.00 Hz
+    geometry 1280 600 1280 600 32
+    timings 16260 184 28 18 1 128 3 endmode mode "1280x720-50"
+# D: 60.466 MHz, H: 37.050 kHz, V: 50.00 Hz
+    geometry 1280 720 1280 720 32
+    timings 16538 176 48 17 1 128 3 endmode mode "1280x768-50"
+# D: 65.178 MHz, H: 39.550 kHz, V: 50.00 Hz
+    geometry 1280 768 1280 768 32 timings 15342 184 28 19 1 128 3 endmode
+#
+#   1280x768, 60 Hz, Non-Interlaced (80.136 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280    768
+#   Scan Frequency  47.700 kHz  60.00 Hz
+#   Sync Width      1.697 us    0.063 ms
+#               17 chars    3 lines
+#   Front Porch     0.799 us    0.021 ms
+#               8 chars     1 lines
+#   Back Porch      2.496 us    0.483 ms
+#               25 chars    23 lines
+#   Active Time     15.973 us   16.101 ms
+#               160 chars   768 lines
+#   Blank Time      4.992 us    0.566 ms
+#               50 chars    27 lines
+#   Polarity        positive    positive
+#
+    mode "1280x768-60"
+# D: 80.13 MHz, H: 47.700 kHz, V: 60.00 Hz
+    geometry 1280 768 1280 768 32
+    timings 12480 200 48 23 1 126 3 hsync high vsync high endmode
+#
+#   1280x800, 60 Hz, Non-Interlaced (83.375 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280    800
+#   Scan Frequency  49.628 kHz  60.00 Hz
+#   Sync Width      1.631 us    60.450 us
+#                   17 chars    3 lines
+#   Front Porch     0.768 us    20.15 us
+#                   8 chars     1 lines
+#   Back Porch      2.399 us    0.483 ms
+#                   25 chars    24 lines
+#   Active Time     15.352 us   16.120 ms
+#                   160 chars   800 lines
+#   Blank Time      4.798 us    0.564 ms
+#                   50 chars    28 lines
+#   Polarity        negtive    positive
+#
+    mode "1280x800-60"
+# D: 83.500 MHz, H: 49.702 kHz, V: 60.00 Hz
+    geometry 1280 800 1280 800 32 timings 11994 200 72 22 3 128 6 endmode
+#
+#   1280x960, 60 Hz, Non-Interlaced (108.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280    960
+#   Scan Frequency  60.000 kHz  60.00 Hz
+#   Sync Width      1.037 us    0.050 ms
+#               14 chars    3 lines
+#   Front Porch     0.889 us    0.017 ms
+#               12 chars    1 lines
+#   Back Porch      2.889 us    0.600 ms
+#               39 chars    36 lines
+#   Active Time     11.852 us   16.000 ms
+#               160 chars   960 lines
+#   Blank Time      4.815 us    0.667 ms
+#               65 chars    40 lines
+#   Polarity        positive    positive
+#
+    mode "1280x960-60"
+# D: 108.00 MHz, H: 60.000 kHz, V: 60.00 Hz
+    geometry 1280 960 1280 960 32
+    timings 9259 312 96 36 1 112 3 hsync high vsync high endmode
+#
+#   1280x1024, 60 Hz, Non-Interlaced (108.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280        1024
+#   Scan Frequency      63.981 kHz  60.02 Hz
+#   Sync Width      1.037 us    0.047 ms
+#               14 chars    3 lines
+#   Front Porch     0.444 us    0.015 ms
+#               6 chars     1 lines
+#   Back Porch      2.297 us    0.594 ms
+#               31 chars    38 lines
+#   Active Time     11.852 us   16.005 ms
+#               160 chars   1024 lines
+#   Blank Time      3.778 us    0.656 ms
+#               51 chars    42 lines
+#   Polarity        positive    positive
+#
+    mode "1280x1024-60"
+# D: 108.00 MHz, H: 63.981 kHz, V: 60.02 Hz
+    geometry 1280 1024 1280 1024 32
+    timings 9260 248 48 38 1 112 3 hsync high vsync high endmode
+#
+#   1280x1024, 75 Hz, Non-Interlaced (135.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280        1024
+#   Scan Frequency      79.976 kHz  75.02 Hz
+#   Sync Width      1.067 us    0.038 ms
+#               18 chars    3 lines
+#   Front Porch     0.119 us    0.012 ms
+#               2 chars     1 lines
+#   Back Porch      1.837 us    0.475 ms
+#               31 chars    38 lines
+#   Active Time     9.481 us    12.804 ms
+#               160 chars   1024 lines
+#   Blank Time      3.022 us    0.525 ms
+#               51 chars    42 lines
+#   Polarity        positive    positive
+#
+    mode "1280x1024-75"
+# D: 135.00 MHz, H: 79.976 kHz, V: 75.02 Hz
+    geometry 1280 1024 1280 1024 32
+    timings 7408 248 16 38 1 144 3 hsync high vsync high endmode
+#
+#   1280x1024, 85 Hz, Non-Interlaced (157.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280        1024
+#   Scan Frequency  91.146 kHz  85.02 Hz
+#   Sync Width      1.016 us    0.033 ms
+#               20 chars    3 lines
+#   Front Porch     0.406 us    0.011 ms
+#               8 chars     1 lines
+#   Back Porch      1.422 us    0.483 ms
+#               28 chars    44 lines
+#   Active Time     8.127 us    11.235 ms
+#               160 chars   1024 lines
+#   Blank Time      2.844 us    0.527 ms
+#               56 chars    48 lines
+#   Polarity        positive    positive
+#
+    mode "1280x1024-85"
+# D: 157.50 MHz, H: 91.146 kHz, V: 85.02 Hz
+    geometry 1280 1024 1280 1024 32
+    timings 6349 224 64 44 1 160 3
+    hsync high vsync high endmode mode "1440x900-60"
+# D: 106.500 MHz, H: 55.935 kHz, V: 60.00 Hz
+    geometry 1440 900 1440 900 32
+    timings 9390 232 80 25 3 152 6
+    hsync high vsync high endmode mode "1440x900-75"
+# D: 136.750 MHz, H: 70.635 kHz, V: 75.00 Hz
+    geometry 1440 900 1440 900 32
+    timings 7315 248 96 33 3 152 6 hsync high vsync high endmode
+#
+#   1440x1050, 60 Hz, Non-Interlaced (125.10 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1440        1050
+#   Scan Frequency      65.220 kHz  60.00 Hz
+#   Sync Width      1.204 us    0.046 ms
+#               19 chars    3 lines
+#   Front Porch     0.760 us    0.015 ms
+#               12 chars    1 lines
+#   Back Porch      1.964 us    0.495 ms
+#               31 chars    33 lines
+#   Active Time     11.405 us   16.099 ms
+#               180 chars   1050 lines
+#   Blank Time      3.928 us    0.567 ms
+#               62 chars    37 lines
+#   Polarity        positive    positive
+#
+    mode "1440x1050-60"
+# D: 125.10 MHz, H: 65.220 kHz, V: 60.00 Hz
+    geometry 1440 1050 1440 1050 32
+    timings 7993 248 96 33 1 152 3
+    hsync high vsync high endmode mode "1600x900-60"
+# D: 118.250 MHz, H: 55.990 kHz, V: 60.00 Hz
+    geometry 1600 900 1600 900 32
+    timings 8415 256 88 26 3 168 5 endmode mode "1600x1024-60"
+# D: 136.358 MHz, H: 63.600 kHz, V: 60.00 Hz
+    geometry 1600 1024 1600 1024 32 timings 7315 272 104 32 1 168 3 endmode
+#
+#   1600x1200, 60 Hz, Non-Interlaced (156.00 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1600        1200
+#   Scan Frequency      76.200 kHz  60.00 Hz
+#   Sync Width      1.026 us    0.105 ms
+#               20 chars    8 lines
+#   Front Porch     0.205 us    0.131 ms
+#               4 chars     10 lines
+#   Back Porch      1.636 us    0.682 ms
+#               32 chars    52 lines
+#   Active Time     10.256 us   15.748 ms
+#               200 chars   1200 lines
+#   Blank Time      2.872 us    0.866 ms
+#               56 chars    66 lines
+#   Polarity        negative    negative
+#
+    mode "1600x1200-60"
+# D: 156.00 MHz, H: 76.200 kHz, V: 60.00 Hz
+    geometry 1600 1200 1600 1200 32 timings 6172 256 32 52 10 160 8 endmode
+#
+#   1600x1200, 75 Hz, Non-Interlaced (202.50 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1600        1200
+#   Scan Frequency  93.750 kHz  75.00 Hz
+#   Sync Width      0.948 us    0.032 ms
+#               24 chars    3 lines
+#   Front Porch     0.316 us    0.011 ms
+#               8 chars     1 lines
+#   Back Porch      1.501 us    0.491 ms
+#               38 chars    46 lines
+#   Active Time     7.901 us    12.800 ms
+#               200 chars   1200 lines
+#   Blank Time      2.765 us    0.533 ms
+#               70 chars    50 lines
+#   Polarity    positive    positive
+#
+    mode "1600x1200-75"
+# D: 202.50 MHz, H: 93.750 kHz, V: 75.00 Hz
+    geometry 1600 1200 1600 1200 32
+    timings 4938 304 64 46 1 192 3
+    hsync high vsync high endmode mode "1680x1050-60"
+# D: 146.250 MHz, H: 65.290 kHz, V: 59.954 Hz
+    geometry 1680 1050 1680 1050 32
+    timings 6814 280 104 30 3 176 6
+    hsync high vsync high endmode mode "1680x1050-75"
+# D: 187.000 MHz, H: 82.306 kHz, V: 74.892 Hz
+    geometry 1680 1050 1680 1050 32
+    timings 5348 296 120 40 3 176 6
+    hsync high vsync high endmode mode "1792x1344-60"
+# D: 202.975 MHz, H: 83.460 kHz, V: 60.00 Hz
+    geometry 1792 1344 1792 1344 32
+    timings 4902 320 128 43 1 192 3
+    hsync high vsync high endmode mode "1856x1392-60"
+# D: 218.571 MHz, H: 86.460 kHz, V: 60.00 Hz
+    geometry 1856 1392 1856 1392 32
+    timings 4577 336 136 45 1 200 3
+    hsync high vsync high endmode mode "1920x1200-60"
+# D: 193.250 MHz, H: 74.556 kHz, V: 60.00 Hz
+    geometry 1920 1200 1920 1200 32
+    timings 5173 336 136 36 3 200 6
+    hsync high vsync high endmode mode "1920x1440-60"
+# D: 234.000 MHz, H:90.000 kHz, V: 60.00 Hz
+    geometry 1920 1440 1920 1440 32
+    timings 4274 344 128 56 1 208 3
+    hsync high vsync high endmode mode "1920x1440-75"
+# D: 297.000 MHz, H:112.500 kHz, V: 75.00 Hz
+    geometry 1920 1440 1920 1440 32
+    timings 3367 352 144 56 1 224 3
+    hsync high vsync high endmode mode "2048x1536-60"
+# D: 267.250 MHz, H: 95.446 kHz, V: 60.00 Hz
+    geometry 2048 1536 2048 1536 32
+    timings 3742 376 152 49 3 224 4 hsync high vsync high endmode
+#
+#   1280x720, 60 Hz, Non-Interlaced (74.481 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1280        720
+#   Scan Frequency      44.760 kHz  60.00 Hz
+#   Sync Width      1.826 us    67.024 ms
+#               17 chars    3 lines
+#   Front Porch     0.752 us    22.341 ms
+#               7 chars     1 lines
+#   Back Porch      2.578 us    491.510 ms
+#               24 chars    22 lines
+#   Active Time     17.186 us   16.086 ms
+#               160 chars   720 lines
+#   Blank Time      5.156 us    0.581 ms
+#               48 chars    26 lines
+#   Polarity        negative    negative
+#
+    mode "1280x720-60"
+# D: 74.481 MHz, H: 44.760 kHz, V: 60.00 Hz
+    geometry 1280 720 1280 720 32 timings 13426 192 64 22 1 136 3 endmode
+#
+#   1920x1080, 60 Hz, Non-Interlaced (172.798 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1920        1080
+#   Scan Frequency      67.080 kHz  60.00 Hz
+#   Sync Width      1.204 us    44.723 ms
+#               26 chars    3 lines
+#   Front Porch     0.694 us    14.908 ms
+#               15 chars     1 lines
+#   Back Porch      1.898 us    506.857 ms
+#               41 chars    34 lines
+#   Active Time     11.111 us   16.100 ms
+#               240 chars   1080 lines
+#   Blank Time      3.796 us    0.566 ms
+#               82 chars    38 lines
+#   Polarity        negative    negative
+#
+    mode "1920x1080-60"
+# D: 74.481 MHz, H: 67.080 kHz, V: 60.00 Hz
+    geometry 1920 1080 1920 1080 32 timings 5787 328 120 34 1 208 3 endmode
+#
+#   1400x1050, 60 Hz, Non-Interlaced (122.61 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1400        1050
+#   Scan Frequency      65.218 kHz  59.99 Hz
+#   Sync Width      1.037 us    0.047 ms
+#               19 chars    3 lines
+#   Front Porch     0.444 us    0.015 ms
+#               11 chars     1 lines
+#   Back Porch      1.185 us    0.188 ms
+#               30 chars    33 lines
+#   Active Time     12.963 us   16.411 ms
+#               175 chars   1050 lines
+#   Blank Time      2.667 us    0.250 ms
+#               60 chars    37 lines
+#   Polarity        negative    positive
+#
+    mode "1400x1050-60"
+# D: 122.750 MHz, H: 65.317 kHz, V: 59.99 Hz
+    geometry 1400 1050 1408 1050 32
+    timings 8214 232 88 32 3 144 4 endmode mode "1400x1050-75"
+# D: 156.000 MHz, H: 82.278 kHz, V: 74.867 Hz
+    geometry 1400 1050 1408 1050 32 timings 6410 248 104 42 3 144 4 endmode
+#
+#   1366x768, 60 Hz, Non-Interlaced (85.86 MHz dotclock)
+#
+#               Horizontal  Vertical
+#   Resolution      1366        768
+#   Scan Frequency      47.700 kHz  60.00 Hz
+#   Sync Width      1.677 us    0.063 ms
+#               18 chars    3 lines
+#   Front Porch     0.839 us    0.021 ms
+#               9 chars     1 lines
+#   Back Porch      2.516 us    0.482 ms
+#               27 chars    23 lines
+#   Active Time     15.933 us   16.101 ms
+#               171 chars   768 lines
+#   Blank Time      5.031 us    0.566 ms
+#               54 chars    27 lines
+#   Polarity        negative    positive
+#
+    mode "1360x768-60"
+# D: 84.750 MHz, H: 47.720 kHz, V: 60.00 Hz
+    geometry 1360 768 1360 768 32
+    timings 11799 208 72 22 3 136 5 endmode mode "1366x768-60"
+# D: 85.86 MHz, H: 47.700 kHz, V: 60.00 Hz
+    geometry 1366 768 1366 768 32
+    timings 11647 216 72 23 1 144 3 endmode mode "1366x768-50"
+# D: 69,924 MHz, H: 39.550 kHz, V: 50.00 Hz
+    geometry 1366 768 1366 768 32 timings 14301 200 56 19 1 144 3 endmode
--- /dev/null
+++ b/drivers/video/viafb/via_i2c.c
@@ -0,0 +1,469 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+/* i2c delay for microsecond*/
+void delays(int count)
+{
+	u8 data;
+	while (count--) {
+		/* delay 1 us */
+		data = inb(DELAYPORT);
+		data = inb(DELAYPORT);
+		data = inb(DELAYPORT);
+		data = inb(DELAYPORT);
+		data = inb(DELAYPORT);
+	}
+
+}
+
+/*  Write I2C BUS SDA And SCL*/
+void i2cWriteSdaScl(u8 sda, u8 scl)
+{
+	u8 data;
+	u16 port_addr;
+
+	if (chip_info.chip_on_slot == PORT_ON_AMR) {
+
+		data = ((scl << 1) | sda) << 4;
+		/* enable I2C port */
+		data = data | BIT0;
+
+		port_addr = I2CPORT;
+		/* Write Register Value */
+		write_reg(I2CPORTINDEX, port_addr, data);
+	} else {
+		if (chip_info.chip_on_slot == PORT_ON_AGP) {
+			data = ((scl << 1) | sda) << 4;
+			/* enable GPIO write port */
+			data = data | (BIT6 + BIT7);
+			port_addr = GPIOPORT;
+			/* Write Register Value */
+			write_reg(GPIOPORTINDEX, port_addr, data);
+		}
+	}
+}
+
+void i2cWriteScl(u8 scl)
+{
+	u8 data;
+	u16 port_addr;
+
+	if (chip_info.chip_on_slot == PORT_ON_AMR) {
+
+		data = (scl << 1) << 4;
+		/* enable I2C port */
+		data = data | BIT0;
+
+		port_addr = I2CPORT;
+		/* Write Register Value */
+		write_reg(I2CPORTINDEX, port_addr, data);
+	} else {
+		if (chip_info.chip_on_slot == PORT_ON_AGP) {
+			data = (scl << 1) << 4;
+			/* enable GPIO write clock */
+			data = data & 0xBF;
+			port_addr = GPIOPORT;
+			/* Write Register Value */
+			write_reg(GPIOPORTINDEX, port_addr, data);
+		}
+	}
+}
+
+void i2cReadSdaScl(u8 *pSda, u8 *pScl)
+{
+	u8 data;
+	u16 port_addr;
+
+	if (chip_info.chip_on_slot == PORT_ON_AMR) {
+		port_addr = I2CPORT;
+		data = read_reg(port_addr, I2CPORTINDEX);
+		*pSda = (data >> 2) & BIT0;	/* get sda */
+		*pScl = (data >> 3) & BIT0;	/* get scl */
+	} else {
+		if (chip_info.chip_on_slot == PORT_ON_AGP) {
+			port_addr = GPIOPORT;
+			data = read_reg(port_addr, GPIOPORTINDEX);
+			*pSda = (data >> 2) & BIT0;	/* get sda */
+			*pScl = (data >> 3) & BIT0;	/* get scl */
+		}
+	}
+}
+
+void i2cWriteSdaSclDelay(u8 sda, u8 scl)
+{
+	i2cWriteSdaScl(sda, scl);
+	delays(16);		/* Wait 16 uS */
+}
+
+void i2cStartSignal(void)
+{
+	i2cWriteSdaSclDelay(1, 1);
+	i2cWriteSdaSclDelay(0, 1);
+	i2cWriteSdaSclDelay(0, 0);
+}
+
+void i2cStopSignal(void)
+{
+	u8 data;
+	u16 port_addr;
+
+	i2cWriteSdaSclDelay(0, 0);
+	i2cWriteSdaSclDelay(0, 1);
+	i2cWriteSdaSclDelay(1, 1);
+
+	if (chip_info.chip_on_slot == PORT_ON_AGP) {
+		/* disable GPIO write port */
+		data = 0x3c;
+		port_addr = GPIOPORT;
+		/* Write Register Value */
+		write_reg(GPIOPORTINDEX, port_addr, data);
+	}
+	delays(2);
+
+}
+
+void disableSdaGPIO(void)
+{
+	u8 data;
+	u16 port_addr;
+
+	if (chip_info.chip_on_slot == PORT_ON_AGP) {
+		port_addr = GPIOPORT;
+		data = read_reg(port_addr, GPIOPORTINDEX);
+		/* disable GPIO write port */
+		data = data & (~BIT6);
+		/* Write Register Value */
+		write_reg(GPIOPORTINDEX, port_addr, data);
+	}
+}
+
+void enableSdaGPIO(void)
+{
+	u8 data;
+	u16 port_addr;
+
+	if (chip_info.chip_on_slot == PORT_ON_AGP) {
+		port_addr = GPIOPORT;
+		data = read_reg(port_addr, GPIOPORTINDEX);
+		/* disable GPIO write port */
+		data = data | (BIT6);
+		/* Write Register Value */
+		write_reg(GPIOPORTINDEX, port_addr, data);
+	}
+}
+
+void writeSclGPIO(u8 scl)
+{
+	u8 data;
+	u16 port_addr;
+
+	if (chip_info.chip_on_slot == PORT_ON_AGP) {
+		port_addr = GPIOPORT;
+		data = read_reg(port_addr, GPIOPORTINDEX);
+		data = data & (~BIT5);
+		/* write data to clock */
+		data = (data | (scl << 5)) & (~BIT6);
+		/* Write Register Value */
+		write_reg(GPIOPORTINDEX, port_addr, data);
+	}
+}
+
+void writeSdaGPIO(u8 sda)
+{
+	u8 data;
+	u16 port_addr;
+
+	if (chip_info.chip_on_slot == PORT_ON_AGP) {
+		port_addr = GPIOPORT;
+		data = read_reg(port_addr, GPIOPORTINDEX);
+
+		data = data & (~BIT4);
+		/* write data to clock */
+		data = (data | (sda << 4)) & (~BIT7);
+		/* Write Register Value */
+		write_reg(GPIOPORTINDEX, port_addr, data);
+	}
+}
+
+void enableGPIO(void)
+{
+	u8 data;
+	u16 port_addr;
+
+	if (chip_info.chip_on_slot == PORT_ON_AGP) {
+		port_addr = GPIOPORT;
+		data = read_reg(port_addr, GPIOPORTINDEX);
+		/* enable GPIO write port */
+		data = data | (BIT4 + BIT5 + BIT6 + BIT7);
+		/* Write Register Value */
+		write_reg(GPIOPORTINDEX, port_addr, data);
+	}
+}
+
+void releaseGPIO(void)
+{
+	u8 data;
+	u16 port_addr;
+
+	if (chip_info.chip_on_slot == PORT_ON_AGP) {
+		port_addr = GPIOPORT;
+		port_addr = port_addr + 1;
+
+		data = read_reg(port_addr, GPIOPORTINDEX);
+		/* disable GPIO write port */
+		data = data & 0x3c;
+		port_addr = GPIOPORT;
+		/* Write Register Value */
+		write_reg(GPIOPORTINDEX, port_addr, data);
+	}
+}
+
+int i2CWaitForSlave(void)
+{
+	int time_out = 20000;
+	u8 sda, scl;
+
+	while (time_out--) {
+		i2cReadSdaScl(&sda, &scl);
+		if (scl)
+			return (OK);	/* Successful stall */
+		delays(1);	/* wait 1 uS */
+	}
+	return (FAIL);		/* Slave fail */
+}
+
+int i2cOutByte(u8 data)
+{
+	u8 sda, scl;
+	u8 out_byte;
+	int bit_count = 8;
+	int status;
+
+	out_byte = data;
+	while (bit_count--) {
+		sda = (out_byte >> 7) & 1;	/* Load MSB */
+		out_byte = out_byte << 1;	/* next bit. */
+		i2cWriteSdaSclDelay(sda, 0);
+		i2cWriteSdaSclDelay(sda, 1);
+
+		status = i2CWaitForSlave();
+		if (status == FAIL)
+			return (status);
+		i2cWriteSdaSclDelay(sda, 0);
+
+	}
+
+	if ((chip_info.chip_on_slot == PORT_ON_AGP)) {
+
+		writeSclGPIO(0);
+		disableSdaGPIO();
+		delays(2);
+		writeSclGPIO(1);
+		delays(2);
+		i2cReadSdaScl(&sda, &scl);
+		writeSclGPIO(0);
+		delays(2);
+		if (sda == 0)
+			status = OK;
+		else
+			status = FAIL;
+
+	} else {
+		i2cWriteSdaSclDelay(1, 0);
+		i2cWriteSdaSclDelay(1, 1);
+		status = i2CWaitForSlave();
+		if (status == FAIL)
+			return (status);
+
+		i2cReadSdaScl(&sda, &scl);
+		if (sda == 0) {
+			i2cWriteSdaSclDelay(1, 0);
+			status = OK;
+		} else {
+
+			i2cWriteSdaSclDelay(1, 0);
+			status = FAIL;
+		}
+	}
+	return (status);
+}
+
+int i2cInputByte(u8 *pInByte, int ack)
+{
+
+	int bit_count = 8;
+	u8 sda, scl;
+	u8 data = 0;
+	int status;
+
+	disableSdaGPIO();
+
+	while (bit_count--) {
+		if ((chip_info.chip_on_slot == PORT_ON_AGP)) {
+
+			writeSclGPIO(1);
+			delays(2);
+			status = i2CWaitForSlave();
+			if (status == FAIL)
+				return (FAIL);
+			i2cReadSdaScl(&sda, &scl);
+			data = data << 1;
+			data |= sda;
+			writeSclGPIO(0);
+			delays(2);
+
+		} else {
+			i2cWriteSdaSclDelay(1, 1);
+			status = i2CWaitForSlave();
+			if (status == FAIL)
+				return (FAIL);
+			i2cReadSdaScl(&sda, &scl);
+			data = data << 1;
+			data |= sda;
+			i2cWriteSdaSclDelay(1, 0);
+		}
+	}
+	*pInByte = data;
+
+	if (ack) {
+		i2cWriteSdaSclDelay(0, 0);
+		i2cWriteSdaSclDelay(0, 1);
+		status = i2CWaitForSlave();
+		if (status == FAIL)
+			return (status);
+		i2cWriteSdaSclDelay(0, 0);
+	} else {
+		i2cWriteSdaSclDelay(1, 0);
+		i2cWriteSdaSclDelay(1, 1);
+		status = i2CWaitForSlave();
+		if (status == FAIL)
+			return (status);
+	}
+	i2cWriteSdaSclDelay(1, 0);
+
+	return (OK);
+}
+
+int i2cReadByte(u8 slave_addr, u8 index, u8 *pData)
+{
+
+	int status;
+
+	i2cStartSignal();
+
+	status = i2cOutByte(slave_addr);
+	if (status == FAIL) {
+		i2cStopSignal();
+		return (FAIL);
+	}
+	status = i2cOutByte(index);
+
+	if (status == FAIL) {
+		i2cStopSignal();
+		return (FAIL);
+	}
+
+	i2cStartSignal();
+	status = i2cOutByte(slave_addr | BIT0);
+	if (status == FAIL) {
+		i2cStopSignal();
+		return (FAIL);
+	}
+	status = i2cInputByte(pData, 0);
+	if (status == FAIL) {
+		i2cStopSignal();
+		return (FAIL);
+	}
+
+	i2cStopSignal();
+	return (OK);
+}
+
+int i2cWriteByte(u8 slave_addr, u8 index, u8 data)
+{
+
+	int status;
+
+	i2cStartSignal();
+	status = i2cOutByte(slave_addr);
+	if (status == FAIL) {
+		i2cStopSignal();
+		return (FAIL);
+	}
+	status = i2cOutByte(index);
+	if (status == FAIL) {
+		i2cStopSignal();
+		return (FAIL);
+	}
+	status = i2cOutByte(data);
+	if (status == FAIL) {
+		i2cStopSignal();
+		return (FAIL);
+	}
+	i2cStopSignal();
+	return (OK);
+}
+
+int i2cReadBytes(u8 slave_addr, u8 index, u8 *buff, int buff_len)
+{
+
+	int status, i;
+
+	i2cStartSignal();
+
+	status = i2cOutByte(slave_addr);
+	if (status == FAIL) {
+		i2cStopSignal();
+		return (FAIL);
+	}
+
+	status = i2cOutByte(index);
+	if (status == FAIL) {
+		i2cStopSignal();
+		return (FAIL);
+	}
+
+	i2cStartSignal();
+	status = i2cOutByte(slave_addr | BIT0);
+	if (status == FAIL) {
+		i2cStopSignal();
+		return (FAIL);
+	}
+
+	for (i = 0; i < buff_len; i++) {
+		if (buff_len == 1)
+			status = i2cInputByte(buff, 0);	/* send NACK */
+		else if (i < buff_len - 1)
+			status = i2cInputByte(buff, 1);	/* send ACK */
+		else
+			status = i2cInputByte(buff, 0);	/* send NACK */
+		if (status == FAIL) {
+			i2cStopSignal();
+			return (FAIL);
+		}
+		buff++;
+	}
+
+	i2cStopSignal();
+	return (OK);
+}
--- /dev/null
+++ b/drivers/video/viafb/via_i2c.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __VIA_I2C_H__
+#define __VIA_I2C_H__
+
+#define I2CPORT           0x3c4
+#define I2CPORTINDEX      0x31
+#define GPIOPORT          0x3C4
+#define GPIOPORTINDEX     0x2C
+#define I2C_BUS             1
+#define GPIO_BUS            2
+#define DELAYPORT           0x3C3
+
+void delays(int count);
+void i2cWriteSdaScl(u8 sda, u8 scl);
+void i2cWriteScl(u8 scl);
+void i2cReadSdaScl(u8 *pSda, u8 *pScl);
+void i2cWriteSdaSclDelay(u8 sda, u8 scl);
+void i2cStartSignal(void);
+void i2cStopSignal(void);
+void disableSdaGPIO(void);
+void enableSdaGPIO(void);
+void writeSclGPIO(u8 scl);
+void writeSdaGPIO(u8 sda);
+void enableGPIO(void);
+void releaseGPIO(void);
+int i2CWaitForSlave(void);
+int i2cOutByte(u8 data);
+int i2cInputByte(u8 *pInByte, int ack);
+int i2cReadByte(u8 slave_addr, u8 index, u8 *pData);
+int i2cWriteByte(u8 slave_addr, u8 index, u8 data);
+int i2cReadBytes(u8 slave_addr, u8 index, u8 *buff, int buff_len);
+#endif /* __VIA_I2C_H__ */
--- /dev/null
+++ b/drivers/video/viafb/viamode.c
@@ -0,0 +1,1086 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+struct res_map_refresh res_map_refresh_tbl[] = {
+/*hres, vres, vclock, vmode_refresh*/
+	{480, 640, RES_480X640_60HZ_PIXCLOCK, 60},
+	{640, 480, RES_640X480_60HZ_PIXCLOCK, 60},
+	{640, 480, RES_640X480_75HZ_PIXCLOCK, 75},
+	{640, 480, RES_640X480_85HZ_PIXCLOCK, 85},
+	{640, 480, RES_640X480_100HZ_PIXCLOCK, 100},
+	{640, 480, RES_640X480_120HZ_PIXCLOCK, 120},
+	{720, 480, RES_720X480_60HZ_PIXCLOCK, 60},
+	{720, 576, RES_720X576_60HZ_PIXCLOCK, 60},
+	{800, 480, RES_800X480_60HZ_PIXCLOCK, 60},
+	{800, 600, RES_800X600_60HZ_PIXCLOCK, 60},
+	{800, 600, RES_800X600_75HZ_PIXCLOCK, 75},
+	{800, 600, RES_800X600_85HZ_PIXCLOCK, 85},
+	{800, 600, RES_800X600_100HZ_PIXCLOCK, 100},
+	{800, 600, RES_800X600_120HZ_PIXCLOCK, 120},
+	{848, 480, RES_848X480_60HZ_PIXCLOCK, 60},
+	{856, 480, RES_856X480_60HZ_PIXCLOCK, 60},
+	{1024, 512, RES_1024X512_60HZ_PIXCLOCK, 60},
+	{1024, 600, RES_1024X600_60HZ_PIXCLOCK, 60},
+	{1024, 768, RES_1024X768_60HZ_PIXCLOCK, 60},
+	{1024, 768, RES_1024X768_75HZ_PIXCLOCK, 75},
+	{1024, 768, RES_1024X768_85HZ_PIXCLOCK, 85},
+	{1024, 768, RES_1024X768_100HZ_PIXCLOCK, 100},
+/*  {1152,864, RES_1152X864_70HZ_PIXCLOCK,  70},*/
+	{1152, 864, RES_1152X864_75HZ_PIXCLOCK, 75},
+	{1280, 768, RES_1280X768_60HZ_PIXCLOCK, 60},
+	{1280, 800, RES_1280X800_60HZ_PIXCLOCK, 60},
+	{1280, 960, RES_1280X960_60HZ_PIXCLOCK, 60},
+	{1280, 1024, RES_1280X1024_60HZ_PIXCLOCK, 60},
+	{1280, 1024, RES_1280X1024_75HZ_PIXCLOCK, 75},
+	{1280, 1024, RES_1280X768_85HZ_PIXCLOCK, 85},
+	{1440, 1050, RES_1440X1050_60HZ_PIXCLOCK, 60},
+	{1600, 1200, RES_1600X1200_60HZ_PIXCLOCK, 60},
+	{1600, 1200, RES_1600X1200_75HZ_PIXCLOCK, 75},
+	{1280, 720, RES_1280X720_60HZ_PIXCLOCK, 60},
+	{1920, 1080, RES_1920X1080_60HZ_PIXCLOCK, 60},
+	{1400, 1050, RES_1400X1050_60HZ_PIXCLOCK, 60},
+	{1400, 1050, RES_1400X1050_75HZ_PIXCLOCK, 75},
+	{1368, 768, RES_1368X768_60HZ_PIXCLOCK, 60},
+	{960, 600, RES_960X600_60HZ_PIXCLOCK, 60},
+	{1000, 600, RES_1000X600_60HZ_PIXCLOCK, 60},
+	{1024, 576, RES_1024X576_60HZ_PIXCLOCK, 60},
+	{1088, 612, RES_1088X612_60HZ_PIXCLOCK, 60},
+	{1152, 720, RES_1152X720_60HZ_PIXCLOCK, 60},
+	{1200, 720, RES_1200X720_60HZ_PIXCLOCK, 60},
+	{1280, 600, RES_1280X600_60HZ_PIXCLOCK, 60},
+	{1280, 720, RES_1280X720_50HZ_PIXCLOCK, 50},
+	{1280, 768, RES_1280X768_50HZ_PIXCLOCK, 50},
+	{1360, 768, RES_1360X768_60HZ_PIXCLOCK, 60},
+	{1366, 768, RES_1366X768_50HZ_PIXCLOCK, 50},
+	{1366, 768, RES_1366X768_60HZ_PIXCLOCK, 60},
+	{1440, 900, RES_1440X900_60HZ_PIXCLOCK, 60},
+	{1440, 900, RES_1440X900_75HZ_PIXCLOCK, 75},
+	{1600, 900, RES_1600X900_60HZ_PIXCLOCK, 60},
+	{1600, 1024, RES_1600X1024_60HZ_PIXCLOCK, 60},
+	{1680, 1050, RES_1680X1050_60HZ_PIXCLOCK, 60},
+	{1680, 1050, RES_1680X1050_75HZ_PIXCLOCK, 75},
+	{1792, 1344, RES_1792X1344_60HZ_PIXCLOCK, 60},
+	{1856, 1392, RES_1856X1392_60HZ_PIXCLOCK, 60},
+	{1920, 1200, RES_1920X1200_60HZ_PIXCLOCK, 60},
+	{1920, 1440, RES_1920X1440_60HZ_PIXCLOCK, 60},
+	{1920, 1440, RES_1920X1440_75HZ_PIXCLOCK, 75},
+	{2048, 1536, RES_2048X1536_60HZ_PIXCLOCK, 60}
+};
+
+struct io_reg CN400_ModeXregs[] = { {VIASR, SR10, 0xFF, 0x01},
+{VIASR, SR15, 0x02, 0x02},
+{VIASR, SR16, 0xBF, 0x08},
+{VIASR, SR17, 0xFF, 0x1F},
+{VIASR, SR18, 0xFF, 0x4E},
+{VIASR, SR1A, 0xFB, 0x08},
+{VIASR, SR1E, 0x0F, 0x01},
+{VIASR, SR2A, 0xF0, 0x00},
+{VIACR, CR0A, 0xFF, 0x1E},	/* Cursor Start                        */
+{VIACR, CR0B, 0xFF, 0x00},	/* Cursor End                          */
+{VIACR, CR0E, 0xFF, 0x00},	/* Cursor Location High                */
+{VIACR, CR0F, 0xFF, 0x00},	/* Cursor Localtion Low                */
+{VIACR, CR32, 0xFF, 0x00},
+{VIACR, CR33, 0xFF, 0x00},
+{VIACR, CR34, 0xFF, 0x00},
+{VIACR, CR35, 0xFF, 0x00},
+{VIACR, CR36, 0x08, 0x00},
+{VIACR, CR62, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR63, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR64, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR69, 0xFF, 0x00},
+{VIACR, CR6A, 0xFF, 0x40},
+{VIACR, CR6B, 0xFF, 0x00},
+{VIACR, CR6C, 0xFF, 0x00},
+{VIACR, CR7A, 0xFF, 0x01},	/* LCD Scaling Parameter 1             */
+{VIACR, CR7B, 0xFF, 0x02},	/* LCD Scaling Parameter 2             */
+{VIACR, CR7C, 0xFF, 0x03},	/* LCD Scaling Parameter 3             */
+{VIACR, CR7D, 0xFF, 0x04},	/* LCD Scaling Parameter 4             */
+{VIACR, CR7E, 0xFF, 0x07},	/* LCD Scaling Parameter 5             */
+{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Scaling Parameter 6             */
+{VIACR, CR80, 0xFF, 0x0D},	/* LCD Scaling Parameter 7             */
+{VIACR, CR81, 0xFF, 0x13},	/* LCD Scaling Parameter 8             */
+{VIACR, CR82, 0xFF, 0x16},	/* LCD Scaling Parameter 9             */
+{VIACR, CR83, 0xFF, 0x19},	/* LCD Scaling Parameter 10            */
+{VIACR, CR84, 0xFF, 0x1C},	/* LCD Scaling Parameter 11            */
+{VIACR, CR85, 0xFF, 0x1D},	/* LCD Scaling Parameter 12            */
+{VIACR, CR86, 0xFF, 0x1E},	/* LCD Scaling Parameter 13            */
+{VIACR, CR87, 0xFF, 0x1F},	/* LCD Scaling Parameter 14            */
+{VIACR, CR88, 0xFF, 0x40},	/* LCD Panel Type                      */
+{VIACR, CR89, 0xFF, 0x00},	/* LCD Timing Control 0                */
+{VIACR, CR8A, 0xFF, 0x88},	/* LCD Timing Control 1                */
+{VIACR, CR8B, 0xFF, 0x69},	/* LCD Power Sequence Control 0        */
+{VIACR, CR8C, 0xFF, 0x57},	/* LCD Power Sequence Control 1        */
+{VIACR, CR8D, 0xFF, 0x00},	/* LCD Power Sequence Control 2        */
+{VIACR, CR8E, 0xFF, 0x7B},	/* LCD Power Sequence Control 3        */
+{VIACR, CR8F, 0xFF, 0x03},	/* LCD Power Sequence Control 4        */
+{VIACR, CR90, 0xFF, 0x30},	/* LCD Power Sequence Control 5        */
+{VIACR, CR91, 0xFF, 0xA0},	/* 24/12 bit LVDS Data off             */
+{VIACR, CR96, 0xFF, 0x00},
+{VIACR, CR97, 0xFF, 0x00},
+{VIACR, CR99, 0xFF, 0x00},
+{VIACR, CR9B, 0xFF, 0x00}
+};
+
+/* Video Mode Table for VT3314 chipset*/
+/* Common Setting for Video Mode */
+struct io_reg CN700_ModeXregs[] = { {VIASR, SR10, 0xFF, 0x01},
+{VIASR, SR15, 0x02, 0x02},
+{VIASR, SR16, 0xBF, 0x08},
+{VIASR, SR17, 0xFF, 0x1F},
+{VIASR, SR18, 0xFF, 0x4E},
+{VIASR, SR1A, 0xFB, 0x82},
+{VIASR, SR1B, 0xFF, 0xF0},
+{VIASR, SR1F, 0xFF, 0x00},
+{VIASR, SR1E, 0xFF, 0xF1},
+{VIASR, SR22, 0xFF, 0x1F},
+{VIASR, SR2A, 0x0F, 0x0F},
+{VIASR, SR2E, 0xFF, 0xFF},
+{VIASR, SR3F, 0xFF, 0xFF},
+{VIASR, SR40, 0xF7, 0x00},
+{VIASR, CR30, 0xFF, 0x04},
+{VIACR, CR32, 0xFF, 0x00},
+{VIACR, CR33, 0x7F, 0x00},
+{VIACR, CR34, 0xFF, 0x00},
+{VIACR, CR35, 0xFF, 0x00},
+{VIACR, CR36, 0xFF, 0x31},
+{VIACR, CR41, 0xFF, 0x80},
+{VIACR, CR42, 0xFF, 0x00},
+{VIACR, CR55, 0x80, 0x00},
+{VIACR, CR5D, 0x80, 0x00},	/*Horizontal Retrace Start bit[11] should be 0*/
+{VIACR, CR62, 0xFF, 0x00},	/* Secondary Display Starting Address */
+{VIACR, CR63, 0xFF, 0x00},	/* Secondary Display Starting Address */
+{VIACR, CR64, 0xFF, 0x00},	/* Secondary Display Starting Address */
+{VIACR, CR68, 0xFF, 0x67},	/* Default FIFO For IGA2 */
+{VIACR, CR69, 0xFF, 0x00},
+{VIACR, CR6A, 0xFD, 0x40},
+{VIACR, CR6B, 0xFF, 0x00},
+{VIACR, CR6C, 0xFF, 0x00},
+{VIACR, CR77, 0xFF, 0x00},	/* LCD scaling Factor */
+{VIACR, CR78, 0xFF, 0x00},	/* LCD scaling Factor */
+{VIACR, CR79, 0xFF, 0x00},	/* LCD scaling Factor */
+{VIACR, CR9F, 0x03, 0x00},	/* LCD scaling Factor */
+{VIACR, CR7A, 0xFF, 0x01},	/* LCD Scaling Parameter 1 */
+{VIACR, CR7B, 0xFF, 0x02},	/* LCD Scaling Parameter 2 */
+{VIACR, CR7C, 0xFF, 0x03},	/* LCD Scaling Parameter 3 */
+{VIACR, CR7D, 0xFF, 0x04},	/* LCD Scaling Parameter 4 */
+{VIACR, CR7E, 0xFF, 0x07},	/* LCD Scaling Parameter 5 */
+{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Scaling Parameter 6 */
+{VIACR, CR80, 0xFF, 0x0D},	/* LCD Scaling Parameter 7 */
+{VIACR, CR81, 0xFF, 0x13},	/* LCD Scaling Parameter 8 */
+{VIACR, CR82, 0xFF, 0x16},	/* LCD Scaling Parameter 9 */
+{VIACR, CR83, 0xFF, 0x19},	/* LCD Scaling Parameter 10 */
+{VIACR, CR84, 0xFF, 0x1C},	/* LCD Scaling Parameter 11 */
+{VIACR, CR85, 0xFF, 0x1D},	/* LCD Scaling Parameter 12 */
+{VIACR, CR86, 0xFF, 0x1E},	/* LCD Scaling Parameter 13 */
+{VIACR, CR87, 0xFF, 0x1F},	/* LCD Scaling Parameter 14 */
+{VIACR, CR88, 0xFF, 0x40},	/* LCD Panel Type */
+{VIACR, CR89, 0xFF, 0x00},	/* LCD Timing Control 0 */
+{VIACR, CR8A, 0xFF, 0x88},	/* LCD Timing Control 1 */
+{VIACR, CR8B, 0xFF, 0x5D},	/* LCD Power Sequence Control 0 */
+{VIACR, CR8C, 0xFF, 0x2B},	/* LCD Power Sequence Control 1 */
+{VIACR, CR8D, 0xFF, 0x6F},	/* LCD Power Sequence Control 2 */
+{VIACR, CR8E, 0xFF, 0x2B},	/* LCD Power Sequence Control 3 */
+{VIACR, CR8F, 0xFF, 0x01},	/* LCD Power Sequence Control 4 */
+{VIACR, CR90, 0xFF, 0x01},	/* LCD Power Sequence Control 5 */
+{VIACR, CR91, 0xFF, 0xA0},	/* 24/12 bit LVDS Data off */
+{VIACR, CR96, 0xFF, 0x00},
+{VIACR, CR97, 0xFF, 0x00},
+{VIACR, CR99, 0xFF, 0x00},
+{VIACR, CR9B, 0xFF, 0x00},
+{VIACR, CR9D, 0xFF, 0x80},
+{VIACR, CR9E, 0xFF, 0x80}
+};
+
+struct io_reg KM400_ModeXregs[] = {
+	{VIASR, SR10, 0xFF, 0x01},	/* Unlock Register                 */
+	{VIASR, SR16, 0xFF, 0x08},	/* Display FIFO threshold Control  */
+	{VIASR, SR17, 0xFF, 0x1F},	/* Display FIFO Control            */
+	{VIASR, SR18, 0xFF, 0x4E},	/* GFX PREQ threshold              */
+	{VIASR, SR1A, 0xFF, 0x0a},	/* GFX PREQ threshold              */
+	{VIASR, SR1F, 0xFF, 0x00},	/* Memory Control 0                */
+	{VIASR, SR1B, 0xFF, 0xF0},	/* Power Management Control 0      */
+	{VIASR, SR1E, 0x0F, 0x01},	/* Power Management Control        */
+	{VIASR, SR20, 0xFF, 0x00},	/* Sequencer Arbiter Control 0     */
+	{VIASR, SR21, 0xFF, 0x00},	/* Sequencer Arbiter Control 1     */
+	{VIASR, SR22, 0xFF, 0x1F},	/* Display Arbiter Control 1       */
+	{VIASR, SR2A, 0xF0, 0x00},	/* Power Management Control 5      */
+	{VIASR, SR2D, 0xFF, 0xFF},	/* Power Management Control 1      */
+	{VIASR, SR2E, 0xFF, 0xFF},	/* Power Management Control 2      */
+	{VIACR, CR0A, 0xFF, 0x1E},	/* Cursor Start                    */
+	{VIACR, CR0B, 0xFF, 0x00},	/* Cursor End                      */
+	{VIACR, CR0E, 0xFF, 0x00},	/* Cursor Location High            */
+	{VIACR, CR0F, 0xFF, 0x00},	/* Cursor Localtion Low            */
+	{VIACR, CR33, 0xFF, 0x00},
+	{VIACR, CR55, 0x80, 0x00},
+	{VIACR, CR5D, 0x80, 0x00},
+	{VIACR, CR36, 0xFF, 0x01},	/* Power Mangement 3                  */
+	{VIACR, CR62, 0xFF, 0x00},	/* Secondary Display Starting Address */
+	{VIACR, CR63, 0xFF, 0x00},	/* Secondary Display Starting Address */
+	{VIACR, CR64, 0xFF, 0x00},	/* Secondary Display Starting Address */
+	{VIACR, CR68, 0xFF, 0x67},	/* Default FIFO For IGA2              */
+	{VIACR, CR6A, 0x20, 0x20},	/* Extended FIFO On                   */
+	{VIACR, CR7A, 0xFF, 0x01},	/* LCD Scaling Parameter 1            */
+	{VIACR, CR7B, 0xFF, 0x02},	/* LCD Scaling Parameter 2            */
+	{VIACR, CR7C, 0xFF, 0x03},	/* LCD Scaling Parameter 3            */
+	{VIACR, CR7D, 0xFF, 0x04},	/* LCD Scaling Parameter 4            */
+	{VIACR, CR7E, 0xFF, 0x07},	/* LCD Scaling Parameter 5            */
+	{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Scaling Parameter 6            */
+	{VIACR, CR80, 0xFF, 0x0D},	/* LCD Scaling Parameter 7            */
+	{VIACR, CR81, 0xFF, 0x13},	/* LCD Scaling Parameter 8            */
+	{VIACR, CR82, 0xFF, 0x16},	/* LCD Scaling Parameter 9            */
+	{VIACR, CR83, 0xFF, 0x19},	/* LCD Scaling Parameter 10           */
+	{VIACR, CR84, 0xFF, 0x1C},	/* LCD Scaling Parameter 11           */
+	{VIACR, CR85, 0xFF, 0x1D},	/* LCD Scaling Parameter 12           */
+	{VIACR, CR86, 0xFF, 0x1E},	/* LCD Scaling Parameter 13           */
+	{VIACR, CR87, 0xFF, 0x1F},	/* LCD Scaling Parameter 14           */
+	{VIACR, CR88, 0xFF, 0x40},	/* LCD Panel Type                     */
+	{VIACR, CR89, 0xFF, 0x00},	/* LCD Timing Control 0               */
+	{VIACR, CR8A, 0xFF, 0x88},	/* LCD Timing Control 1               */
+	{VIACR, CR8B, 0xFF, 0x2D},	/* LCD Power Sequence Control 0       */
+	{VIACR, CR8C, 0xFF, 0x2D},	/* LCD Power Sequence Control 1       */
+	{VIACR, CR8D, 0xFF, 0xC8},	/* LCD Power Sequence Control 2       */
+	{VIACR, CR8E, 0xFF, 0x36},	/* LCD Power Sequence Control 3       */
+	{VIACR, CR8F, 0xFF, 0x00},	/* LCD Power Sequence Control 4       */
+	{VIACR, CR90, 0xFF, 0x10},	/* LCD Power Sequence Control 5       */
+	{VIACR, CR91, 0xFF, 0xA0},	/* 24/12 bit LVDS Data off            */
+	{VIACR, CR96, 0xFF, 0x03},	/* DVP0        ; DVP0 Clock Skew */
+	{VIACR, CR97, 0xFF, 0x03},	/* DFP high    ; DFPH Clock Skew */
+	{VIACR, CR99, 0xFF, 0x03},	/* DFP low           ; DFPL Clock Skew*/
+	{VIACR, CR9B, 0xFF, 0x07}	/* DVI on DVP1       ; DVP1 Clock Skew*/
+};
+
+/* For VT3324: Common Setting for Video Mode */
+struct io_reg CX700_ModeXregs[] = { {VIASR, SR10, 0xFF, 0x01},
+{VIASR, SR15, 0x02, 0x02},
+{VIASR, SR16, 0xBF, 0x08},
+{VIASR, SR17, 0xFF, 0x1F},
+{VIASR, SR18, 0xFF, 0x4E},
+{VIASR, SR1A, 0xFB, 0x08},
+{VIASR, SR1B, 0xFF, 0xF0},
+{VIASR, SR1E, 0x0F, 0x01},
+{VIASR, SR2A, 0xF0, 0x00},
+{VIASR, SR2D, 0xFF, 0xFF},	/* VCK and LCK PLL power on.           */
+{VIACR, CR0A, 0xFF, 0x1E},	/* Cursor Start                        */
+{VIACR, CR0B, 0xFF, 0x00},	/* Cursor End                          */
+{VIACR, CR0E, 0xFF, 0x00},	/* Cursor Location High                */
+{VIACR, CR0F, 0xFF, 0x00},	/* Cursor Localtion Low                */
+{VIACR, CR32, 0xFF, 0x00},
+{VIACR, CR33, 0xFF, 0x00},
+{VIACR, CR34, 0xFF, 0x00},
+{VIACR, CR35, 0xFF, 0x00},
+{VIACR, CR36, 0x08, 0x00},
+{VIACR, CR47, 0xC8, 0x00},	/* Clear VCK Plus. */
+{VIACR, CR62, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR63, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR64, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CRA3, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR69, 0xFF, 0x00},
+{VIACR, CR6A, 0xFF, 0x40},
+{VIACR, CR6B, 0xFF, 0x00},
+{VIACR, CR6C, 0xFF, 0x00},
+{VIACR, CR7A, 0xFF, 0x01},	/* LCD Scaling Parameter 1             */
+{VIACR, CR7B, 0xFF, 0x02},	/* LCD Scaling Parameter 2             */
+{VIACR, CR7C, 0xFF, 0x03},	/* LCD Scaling Parameter 3             */
+{VIACR, CR7D, 0xFF, 0x04},	/* LCD Scaling Parameter 4             */
+{VIACR, CR7E, 0xFF, 0x07},	/* LCD Scaling Parameter 5             */
+{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Scaling Parameter 6             */
+{VIACR, CR80, 0xFF, 0x0D},	/* LCD Scaling Parameter 7             */
+{VIACR, CR81, 0xFF, 0x13},	/* LCD Scaling Parameter 8             */
+{VIACR, CR82, 0xFF, 0x16},	/* LCD Scaling Parameter 9             */
+{VIACR, CR83, 0xFF, 0x19},	/* LCD Scaling Parameter 10            */
+{VIACR, CR84, 0xFF, 0x1C},	/* LCD Scaling Parameter 11            */
+{VIACR, CR85, 0xFF, 0x1D},	/* LCD Scaling Parameter 12            */
+{VIACR, CR86, 0xFF, 0x1E},	/* LCD Scaling Parameter 13            */
+{VIACR, CR87, 0xFF, 0x1F},	/* LCD Scaling Parameter 14            */
+{VIACR, CR88, 0xFF, 0x40},	/* LCD Panel Type                      */
+{VIACR, CR89, 0xFF, 0x00},	/* LCD Timing Control 0                */
+{VIACR, CR8A, 0xFF, 0x88},	/* LCD Timing Control 1                */
+{VIACR, CRD4, 0xFF, 0x81},	/* Second power sequence control       */
+{VIACR, CR8B, 0xFF, 0x5D},	/* LCD Power Sequence Control 0        */
+{VIACR, CR8C, 0xFF, 0x2B},	/* LCD Power Sequence Control 1        */
+{VIACR, CR8D, 0xFF, 0x6F},	/* LCD Power Sequence Control 2        */
+{VIACR, CR8E, 0xFF, 0x2B},	/* LCD Power Sequence Control 3        */
+{VIACR, CR8F, 0xFF, 0x01},	/* LCD Power Sequence Control 4        */
+{VIACR, CR90, 0xFF, 0x01},	/* LCD Power Sequence Control 5        */
+{VIACR, CR91, 0xFF, 0x80},	/* 24/12 bit LVDS Data off             */
+{VIACR, CR96, 0xFF, 0x00},
+{VIACR, CR97, 0xFF, 0x00},
+{VIACR, CR99, 0xFF, 0x00},
+{VIACR, CR9B, 0xFF, 0x00},
+{VIACR, CRD2, 0xFF, 0xFF}	/* TMDS/LVDS control register.         */
+};
+
+/* For VT3353: Common Setting for Video Mode */
+struct io_reg VX800_ModeXregs[] = { {VIASR, SR10, 0xFF, 0x01},
+{VIASR, SR15, 0x02, 0x02},
+{VIASR, SR16, 0xBF, 0x08},
+{VIASR, SR17, 0xFF, 0x1F},
+{VIASR, SR18, 0xFF, 0x4E},
+{VIASR, SR1A, 0xFB, 0x08},
+{VIASR, SR1B, 0xFF, 0xF0},
+{VIASR, SR1E, 0x0F, 0x01},
+{VIASR, SR2A, 0xF0, 0x00},
+{VIASR, SR2D, 0xFF, 0xFF},	/* VCK and LCK PLL power on.           */
+{VIACR, CR0A, 0xFF, 0x1E},	/* Cursor Start                        */
+{VIACR, CR0B, 0xFF, 0x00},	/* Cursor End                          */
+{VIACR, CR0E, 0xFF, 0x00},	/* Cursor Location High                */
+{VIACR, CR0F, 0xFF, 0x00},	/* Cursor Localtion Low                */
+{VIACR, CR32, 0xFF, 0x00},
+{VIACR, CR33, 0xFF, 0x00},
+{VIACR, CR34, 0xFF, 0x00},
+{VIACR, CR35, 0xFF, 0x00},
+{VIACR, CR36, 0x08, 0x00},
+{VIACR, CR47, 0xC8, 0x00},	/* Clear VCK Plus. */
+{VIACR, CR62, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR63, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR64, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CRA3, 0xFF, 0x00},	/* Secondary Display Starting Address  */
+{VIACR, CR69, 0xFF, 0x00},
+{VIACR, CR6A, 0xFF, 0x40},
+{VIACR, CR6B, 0xFF, 0x00},
+{VIACR, CR6C, 0xFF, 0x00},
+{VIACR, CR7A, 0xFF, 0x01},	/* LCD Scaling Parameter 1             */
+{VIACR, CR7B, 0xFF, 0x02},	/* LCD Scaling Parameter 2             */
+{VIACR, CR7C, 0xFF, 0x03},	/* LCD Scaling Parameter 3             */
+{VIACR, CR7D, 0xFF, 0x04},	/* LCD Scaling Parameter 4             */
+{VIACR, CR7E, 0xFF, 0x07},	/* LCD Scaling Parameter 5             */
+{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Scaling Parameter 6             */
+{VIACR, CR80, 0xFF, 0x0D},	/* LCD Scaling Parameter 7             */
+{VIACR, CR81, 0xFF, 0x13},	/* LCD Scaling Parameter 8             */
+{VIACR, CR82, 0xFF, 0x16},	/* LCD Scaling Parameter 9             */
+{VIACR, CR83, 0xFF, 0x19},	/* LCD Scaling Parameter 10            */
+{VIACR, CR84, 0xFF, 0x1C},	/* LCD Scaling Parameter 11            */
+{VIACR, CR85, 0xFF, 0x1D},	/* LCD Scaling Parameter 12            */
+{VIACR, CR86, 0xFF, 0x1E},	/* LCD Scaling Parameter 13            */
+{VIACR, CR87, 0xFF, 0x1F},	/* LCD Scaling Parameter 14            */
+{VIACR, CR88, 0xFF, 0x40},	/* LCD Panel Type                      */
+{VIACR, CR89, 0xFF, 0x00},	/* LCD Timing Control 0                */
+{VIACR, CR8A, 0xFF, 0x88},	/* LCD Timing Control 1                */
+{VIACR, CRD4, 0xFF, 0x81},	/* Second power sequence control       */
+{VIACR, CR8B, 0xFF, 0x5D},	/* LCD Power Sequence Control 0        */
+{VIACR, CR8C, 0xFF, 0x2B},	/* LCD Power Sequence Control 1        */
+{VIACR, CR8D, 0xFF, 0x6F},	/* LCD Power Sequence Control 2        */
+{VIACR, CR8E, 0xFF, 0x2B},	/* LCD Power Sequence Control 3        */
+{VIACR, CR8F, 0xFF, 0x01},	/* LCD Power Sequence Control 4        */
+{VIACR, CR90, 0xFF, 0x01},	/* LCD Power Sequence Control 5        */
+{VIACR, CR91, 0xFF, 0x80},	/* 24/12 bit LVDS Data off             */
+{VIACR, CR96, 0xFF, 0x00},
+{VIACR, CR97, 0xFF, 0x00},
+{VIACR, CR99, 0xFF, 0x00},
+{VIACR, CR9B, 0xFF, 0x00},
+{VIACR, CRD2, 0xFF, 0xFF}	/* TMDS/LVDS control register.         */
+};
+
+/* Video Mode Table */
+/* Common Setting for Video Mode */
+struct io_reg CLE266_ModeXregs[] = { {VIASR, SR1E, 0xF0, 0xF0},
+{VIASR, SR2A, 0x0F, 0x0F},
+{VIASR, SR15, 0x02, 0x02},
+{VIASR, SR16, 0xBF, 0x08},
+{VIASR, SR17, 0xFF, 0x1F},
+{VIASR, SR18, 0xFF, 0x4E},
+{VIASR, SR1A, 0xFB, 0x08},
+
+{VIACR, CR32, 0xFF, 0x00},
+{VIACR, CR34, 0xFF, 0x00},
+{VIACR, CR35, 0xFF, 0x00},
+{VIACR, CR36, 0x08, 0x00},
+{VIACR, CR6A, 0xFF, 0x80},
+{VIACR, CR6A, 0xFF, 0xC0},
+
+{VIACR, CR55, 0x80, 0x00},
+{VIACR, CR5D, 0x80, 0x00},
+
+{VIAGR, GR20, 0xFF, 0x00},
+{VIAGR, GR21, 0xFF, 0x00},
+{VIAGR, GR22, 0xFF, 0x00},
+	/* LCD Parameters */
+{VIACR, CR7A, 0xFF, 0x01},	/* LCD Parameter 1 */
+{VIACR, CR7B, 0xFF, 0x02},	/* LCD Parameter 2 */
+{VIACR, CR7C, 0xFF, 0x03},	/* LCD Parameter 3 */
+{VIACR, CR7D, 0xFF, 0x04},	/* LCD Parameter 4 */
+{VIACR, CR7E, 0xFF, 0x07},	/* LCD Parameter 5 */
+{VIACR, CR7F, 0xFF, 0x0A},	/* LCD Parameter 6 */
+{VIACR, CR80, 0xFF, 0x0D},	/* LCD Parameter 7 */
+{VIACR, CR81, 0xFF, 0x13},	/* LCD Parameter 8 */
+{VIACR, CR82, 0xFF, 0x16},	/* LCD Parameter 9 */
+{VIACR, CR83, 0xFF, 0x19},	/* LCD Parameter 10 */
+{VIACR, CR84, 0xFF, 0x1C},	/* LCD Parameter 11 */
+{VIACR, CR85, 0xFF, 0x1D},	/* LCD Parameter 12 */
+{VIACR, CR86, 0xFF, 0x1E},	/* LCD Parameter 13 */
+{VIACR, CR87, 0xFF, 0x1F},	/* LCD Parameter 14 */
+
+};
+
+/* Mode:1024X768 */
+struct io_reg PM1024x768[] = { {VIASR, 0x16, 0xBF, 0x0C},
+{VIASR, 0x18, 0xFF, 0x4C}
+};
+
+struct patch_table res_patch_table[] = {
+	{VIA_RES_1024X768, ARRAY_SIZE(PM1024x768), PM1024x768}
+};
+
+/* struct VPITTable {
+	unsigned char  Misc;
+	unsigned char  SR[StdSR];
+	unsigned char  CR[StdCR];
+	unsigned char  GR[StdGR];
+	unsigned char  AR[StdAR];
+ };*/
+
+struct VPITTable VPIT = {
+	/* Msic */
+	0xC7,
+	/* Sequencer */
+	{0x01, 0x0F, 0x00, 0x0E},
+	/* Graphic Controller */
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0xFF},
+	/* Attribute Controller */
+	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	 0x01, 0x00, 0x0F, 0x00}
+};
+
+/********************/
+/* Mode Table       */
+/********************/
+
+/* 480x640 */
+struct crt_mode_table CRTM480x640[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_25_175M, M480X640_R60_HSP, M480X640_R60_VSP,
+	 {624, 480, 480, 144, 504, 48, 663, 640, 640, 23, 641, 3} }	/* GTF*/
+};
+
+/* 640x480*/
+struct crt_mode_table CRTM640x480[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_25_175M, M640X480_R60_HSP, M640X480_R60_VSP,
+	 {800, 640, 648, 144, 656, 96, 525, 480, 480, 45, 490, 2} },
+	{REFRESH_75, CLK_31_500M, M640X480_R75_HSP, M640X480_R75_VSP,
+	 {840, 640, 640, 200, 656, 64, 500, 480, 480, 20, 481, 3} },
+	{REFRESH_85, CLK_36_000M, M640X480_R85_HSP, M640X480_R85_VSP,
+	 {832, 640, 640, 192, 696, 56, 509, 480, 480, 29, 481, 3} },
+	{REFRESH_100, CLK_43_163M, M640X480_R100_HSP, M640X480_R100_VSP,
+	 {848, 640, 640, 208, 680, 64, 509, 480, 480, 29, 481, 3} }, /*GTF*/
+	    {REFRESH_120, CLK_52_406M, M640X480_R120_HSP,
+	     M640X480_R120_VSP,
+	     {848, 640, 640, 208, 680, 64, 515, 480, 480, 35, 481,
+	      3} } /*GTF*/
+};
+
+/*720x480 (GTF)*/
+struct crt_mode_table CRTM720x480[] = {
+	/*r_rate,vclk,hsp,vsp      */
+	/*HT, HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_26_880M, M720X480_R60_HSP, M720X480_R60_VSP,
+	 {896, 720, 720, 176, 736, 72, 497, 480, 480, 17, 481, 3} }
+
+};
+
+/*720x576 (GTF)*/
+struct crt_mode_table CRTM720x576[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_32_668M, M720X576_R60_HSP, M720X576_R60_VSP,
+	 {912, 720, 720, 192, 744, 72, 597, 576, 576, 21, 577, 3} }
+};
+
+/* 800x480 (CVT) */
+struct crt_mode_table CRTM800x480[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_29_581M, M800X480_R60_HSP, M800X480_R60_VSP,
+	 {992, 800, 800, 192, 824, 72, 500, 480, 480, 20, 483, 7} }
+};
+
+/* 800x600*/
+struct crt_mode_table CRTM800x600[] = {
+	/*r_rate,vclk,hsp,vsp     */
+	/*HT,   HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_40_000M, M800X600_R60_HSP, M800X600_R60_VSP,
+	 {1056, 800, 800, 256, 840, 128, 628, 600, 600, 28, 601, 4} },
+	{REFRESH_75, CLK_49_500M, M800X600_R75_HSP, M800X600_R75_VSP,
+	 {1056, 800, 800, 256, 816, 80, 625, 600, 600, 25, 601, 3} },
+	{REFRESH_85, CLK_56_250M, M800X600_R85_HSP, M800X600_R85_VSP,
+	 {1048, 800, 800, 248, 832, 64, 631, 600, 600, 31, 601, 3} },
+	{REFRESH_100, CLK_68_179M, M800X600_R100_HSP, M800X600_R100_VSP,
+	 {1072, 800, 800, 272, 848, 88, 636, 600, 600, 36, 601, 3} },
+	{REFRESH_120, CLK_83_950M, M800X600_R120_HSP,
+		  M800X600_R120_VSP,
+		  {1088, 800, 800, 288, 856, 88, 643, 600, 600, 43, 601,
+		   3} }
+};
+
+/* 848x480 (CVT) */
+struct crt_mode_table CRTM848x480[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_31_500M, M848X480_R60_HSP, M848X480_R60_VSP,
+	 {1056, 848, 848, 208, 872, 80, 500, 480, 480, 20, 483, 5} }
+};
+
+/*856x480 (GTF) convert to 852x480*/
+struct crt_mode_table CRTM852x480[] = {
+	/*r_rate,vclk,hsp,vsp     */
+	/*HT,   HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_31_728M, M852X480_R60_HSP, M852X480_R60_VSP,
+	{1064, 856, 856, 208, 872, 88, 497, 480, 480, 17, 481, 3} }
+};
+
+/*1024x512 (GTF)*/
+struct crt_mode_table CRTM1024x512[] = {
+	/*r_rate,vclk,hsp,vsp     */
+	/*HT,   HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_41_291M, M1024X512_R60_HSP, M1024X512_R60_VSP,
+	 {1296, 1024, 1024, 272, 1056, 104, 531, 512, 512, 19, 513, 3} }
+
+};
+
+/* 1024x600*/
+struct crt_mode_table CRTM1024x600[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_48_875M, M1024X600_R60_HSP, M1024X600_R60_VSP,
+	 {1312, 1024, 1024, 288, 1064, 104, 622, 600, 600, 22, 601, 3} },
+};
+
+/* 1024x768*/
+struct crt_mode_table CRTM1024x768[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_65_000M, M1024X768_R60_HSP, M1024X768_R60_VSP,
+	{1344, 1024, 1024, 320, 1048, 136, 806, 768, 768, 38, 771, 6} },
+	{REFRESH_75, CLK_78_750M, M1024X768_R75_HSP, M1024X768_R75_VSP,
+	{1312, 1024, 1024, 288, 1040, 96, 800, 768, 768, 32, 769, 3} },
+	{REFRESH_85, CLK_94_500M, M1024X768_R85_HSP, M1024X768_R85_VSP,
+	{1376, 1024, 1024, 352, 1072, 96, 808, 768, 768, 40, 769, 3} },
+	{REFRESH_100, CLK_113_309M, M1024X768_R100_HSP, M1024X768_R100_VSP,
+	{1392, 1024, 1024, 368, 1096, 112, 814, 768, 768, 46, 769, 3} }
+};
+
+/* 1152x864*/
+struct crt_mode_table CRTM1152x864[] = {
+	/*r_rate,vclk,hsp,vsp      */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_75, CLK_108_000M, M1152X864_R75_HSP, M1152X864_R75_VSP,
+	 {1600, 1152, 1152, 448, 1216, 128, 900, 864, 864, 36, 865, 3} }
+
+};
+
+/* 1280x720 (HDMI 720P)*/
+struct crt_mode_table CRTM1280x720[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE      */
+	{REFRESH_60, CLK_74_481M, M1280X720_R60_HSP, M1280X720_R60_VSP,
+	 {1648, 1280, 1280, 368, 1392, 40, 750, 720, 720, 30, 725, 5} },
+	{REFRESH_50, CLK_60_466M, M1280X720_R50_HSP, M1280X720_R50_VSP,
+	 {1632, 1280, 1280, 352, 1328, 128, 741, 720, 720, 21, 721, 3} }
+};
+
+/*1280x768 (GTF)*/
+struct crt_mode_table CRTM1280x768[] = {
+	/*r_rate,vclk,hsp,vsp     */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_80_136M, M1280X768_R60_HSP, M1280X768_R60_VSP,
+	 {1680, 1280, 1280, 400, 1344, 136, 795, 768, 768, 27, 769, 3} },
+	{REFRESH_50, CLK_65_178M, M1280X768_R50_HSP, M1280X768_R50_VSP,
+	 {1648, 1280, 1280, 368, 1336, 128, 791, 768, 768, 23, 769, 3} }
+};
+
+/* 1280x800 (CVT) */
+struct crt_mode_table CRTM1280x800[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_83_375M, M1280X800_R60_HSP, M1280X800_R60_VSP,
+	 {1680, 1280, 1280, 400, 1352, 128, 831, 800, 800, 31, 803, 6} }
+};
+
+/*1280x960*/
+struct crt_mode_table CRTM1280x960[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_108_000M, M1280X960_R60_HSP, M1280X960_R60_VSP,
+	 {1800, 1280, 1280, 520, 1376, 112, 1000, 960, 960, 40, 961, 3} }
+};
+
+/* 1280x1024*/
+struct crt_mode_table CRTM1280x1024[] = {
+	/*r_rate,vclk,,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_108_000M, M1280X1024_R60_HSP, M1280X1024_R60_VSP,
+	 {1688, 1280, 1280, 408, 1328, 112, 1066, 1024, 1024, 42, 1025,
+	  3} },
+	{REFRESH_75, CLK_135_000M, M1280X1024_R75_HSP, M1280X1024_R75_VSP,
+	 {1688, 1280, 1280, 408, 1296, 144, 1066, 1024, 1024, 42, 1025,
+	  3} },
+	{REFRESH_85, CLK_157_500M, M1280X1024_R85_HSP, M1280X1024_R85_VSP,
+	 {1728, 1280, 1280, 448, 1344, 160, 1072, 1024, 1024, 48, 1025, 3} }
+};
+
+/* 1368x768 (GTF) */
+struct crt_mode_table CRTM1368x768[] = {
+	/* r_rate,  vclk, hsp, vsp */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_85_860M, M1368X768_R60_HSP, M1368X768_R60_VSP,
+	 {1800, 1368, 1368, 432, 1440, 144, 795, 768, 768, 27, 769, 3} }
+};
+
+/*1440x1050 (GTF)*/
+struct crt_mode_table CRTM1440x1050[] = {
+	/*r_rate,vclk,hsp,vsp      */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_125_104M, M1440X1050_R60_HSP, M1440X1050_R60_VSP,
+	 {1936, 1440, 1440, 496, 1536, 152, 1077, 1040, 1040, 37, 1041, 3} }
+};
+
+/* 1600x1200*/
+struct crt_mode_table CRTM1600x1200[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_162_000M, M1600X1200_R60_HSP, M1600X1200_R60_VSP,
+	 {2160, 1600, 1600, 560, 1664, 192, 1250, 1200, 1200, 50, 1201,
+	  3} },
+	{REFRESH_75, CLK_202_500M, M1600X1200_R75_HSP, M1600X1200_R75_VSP,
+	 {2160, 1600, 1600, 560, 1664, 192, 1250, 1200, 1200, 50, 1201, 3} }
+
+};
+
+/* 1680x1050 (CVT) */
+struct crt_mode_table CRTM1680x1050[] = {
+	/* r_rate,          vclk,              hsp,             vsp  */
+	/* HT,  HA,  HBS, HBE, HSS, HSE,    VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_146_760M, M1680x1050_R60_HSP, M1680x1050_R60_VSP,
+	 {2240, 1680, 1680, 560, 1784, 176, 1089, 1050, 1050, 39, 1053,
+	  6} },
+	{REFRESH_75, CLK_187_000M, M1680x1050_R75_HSP, M1680x1050_R75_VSP,
+	 {2272, 1680, 1680, 592, 1800, 176, 1099, 1050, 1050, 49, 1053, 6} }
+};
+
+/* 1680x1050 (CVT Reduce Blanking) */
+struct crt_mode_table CRTM1680x1050_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE,    VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_119_000M, M1680x1050_RB_R60_HSP,
+	 M1680x1050_RB_R60_VSP,
+	 {1840, 1680, 1680, 160, 1728, 32, 1080, 1050, 1050, 30, 1053, 6} }
+};
+
+/* 1920x1080 (CVT)*/
+struct crt_mode_table CRTM1920x1080[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_172_798M, M1920X1080_R60_HSP, M1920X1080_R60_VSP,
+	 {2576, 1920, 1920, 656, 2048, 200, 1120, 1080, 1080, 40, 1083, 5} }
+};
+
+/* 1920x1080 (CVT with Reduce Blanking) */
+struct crt_mode_table CRTM1920x1080_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_138_400M, M1920X1080_RB_R60_HSP,
+	 M1920X1080_RB_R60_VSP,
+	 {2080, 1920, 1920, 160, 1968, 32, 1111, 1080, 1080, 31, 1083, 5} }
+};
+
+/* 1920x1440*/
+struct crt_mode_table CRTM1920x1440[] = {
+	/*r_rate,vclk,hsp,vsp */
+	/*HT,  HA,   HBS,  HBE, HSS,  HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_234_000M, M1920X1440_R60_HSP, M1920X1440_R60_VSP,
+	 {2600, 1920, 1920, 680, 2048, 208, 1500, 1440, 1440, 60, 1441,
+	  3} },
+	{REFRESH_75, CLK_297_500M, M1920X1440_R75_HSP, M1920X1440_R75_VSP,
+	 {2640, 1920, 1920, 720, 2064, 224, 1500, 1440, 1440, 60, 1441, 3} }
+};
+
+/* 1400x1050 (CVT) */
+struct crt_mode_table CRTM1400x1050[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_121_750M, M1400X1050_R60_HSP, M1400X1050_R60_VSP,
+	 {1864, 1400, 1400, 464, 1488, 144, 1089, 1050, 1050, 39, 1053,
+	  4} },
+	{REFRESH_75, CLK_156_000M, M1400X1050_R75_HSP, M1400X1050_R75_VSP,
+	 {1896, 1400, 1400, 496, 1504, 144, 1099, 1050, 1050, 49, 1053, 4} }
+};
+
+/* 1400x1050 (CVT Reduce Blanking) */
+struct crt_mode_table CRTM1400x1050_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_101_000M, M1400X1050_RB_R60_HSP,
+	 M1400X1050_RB_R60_VSP,
+	 {1560, 1400, 1400, 160, 1448, 32, 1080, 1050, 1050, 30, 1053, 4} }
+};
+
+/* 960x600 (CVT) */
+struct crt_mode_table CRTM960x600[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_45_250M, M960X600_R60_HSP, M960X600_R60_VSP,
+	 {1216, 960, 960, 256, 992, 96, 624, 600, 600, 24, 603, 6} }
+};
+
+/* 1000x600 (GTF) */
+struct crt_mode_table CRTM1000x600[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_48_000M, M1000X600_R60_HSP, M1000X600_R60_VSP,
+	 {1288, 1000, 1000, 288, 1040, 104, 622, 600, 600, 22, 601, 3} }
+};
+
+/* 1024x576 (GTF) */
+struct crt_mode_table CRTM1024x576[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_46_996M, M1024X576_R60_HSP, M1024X576_R60_VSP,
+	 {1312, 1024, 1024, 288, 1064, 104, 597, 576, 576, 21, 577, 3} }
+};
+
+/* 1088x612 (CVT) */
+struct crt_mode_table CRTM1088x612[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_52_977M, M1088X612_R60_HSP, M1088X612_R60_VSP,
+	 {1392, 1088, 1088, 304, 1136, 104, 636, 612, 612, 24, 615, 5} }
+};
+
+/* 1152x720 (CVT) */
+struct crt_mode_table CRTM1152x720[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_66_750M, M1152X720_R60_HSP, M1152X720_R60_VSP,
+	 {1488, 1152, 1152, 336, 1208, 112, 748, 720, 720, 28, 723, 6} }
+};
+
+/* 1200x720 (GTF) */
+struct crt_mode_table CRTM1200x720[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_70_159M, M1200X720_R60_HSP, M1200X720_R60_VSP,
+	 {1568, 1200, 1200, 368, 1256, 128, 746, 720, 720, 26, 721, 3} }
+};
+
+/* 1280x600 (GTF) */
+struct crt_mode_table CRTM1280x600[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE, VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_61_500M, M1280x600_R60_HSP, M1280x600_R60_VSP,
+	 {1648, 1280, 1280, 368, 1336, 128, 622, 600, 600, 22, 601, 3} }
+};
+
+/* 1360x768 (CVT) */
+struct crt_mode_table CRTM1360x768[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_84_750M, M1360X768_R60_HSP, M1360X768_R60_VSP,
+	 {1776, 1360, 1360, 416, 1432, 136, 798, 768, 768, 30, 771, 5} }
+};
+
+/* 1360x768 (CVT Reduce Blanking) */
+struct crt_mode_table CRTM1360x768_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_72_000M, M1360X768_RB_R60_HSP,
+	 M1360X768_RB_R60_VSP,
+	 {1520, 1360, 1360, 160, 1408, 32, 790, 768, 768, 22, 771, 5} }
+};
+
+/* 1366x768 (GTF) */
+struct crt_mode_table CRTM1366x768[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_85_860M, M1368X768_R60_HSP, M1368X768_R60_VSP,
+	 {1800, 1368, 1368, 432, 1440, 144, 795, 768, 768, 27, 769, 3} },
+	{REFRESH_50, CLK_69_924M, M1368X768_R50_HSP, M1368X768_R50_VSP,
+	 {1768, 1368, 1368, 400, 1424, 144, 791, 768, 768, 23, 769, 3} }
+};
+
+/* 1440x900 (CVT) */
+struct crt_mode_table CRTM1440x900[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_106_500M, M1440X900_R60_HSP, M1440X900_R60_VSP,
+	 {1904, 1440, 1440, 464, 1520, 152, 934, 900, 900, 34, 903, 6} },
+	{REFRESH_75, CLK_136_700M, M1440X900_R75_HSP, M1440X900_R75_VSP,
+	 {1936, 1440, 1440, 496, 1536, 152, 942, 900, 900, 42, 903, 6} }
+};
+
+/* 1440x900 (CVT Reduce Blanking) */
+struct crt_mode_table CRTM1440x900_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_88_750M, M1440X900_RB_R60_HSP,
+	 M1440X900_RB_R60_VSP,
+	 {1600, 1440, 1440, 160, 1488, 32, 926, 900, 900, 26, 903, 6} }
+};
+
+/* 1600x900 (CVT) */
+struct crt_mode_table CRTM1600x900[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_118_840M, M1600X900_R60_HSP, M1600X900_R60_VSP,
+	 {2112, 1600, 1600, 512, 1688, 168, 934, 900, 900, 34, 903, 5} }
+};
+
+/* 1600x900 (CVT Reduce Blanking) */
+struct crt_mode_table CRTM1600x900_RB[] = {
+	/* r_rate,        vclk,           hsp,        vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_97_750M, M1600X900_RB_R60_HSP,
+	 M1600X900_RB_R60_VSP,
+	 {1760, 1600, 1600, 160, 1648, 32, 926, 900, 900, 26, 903, 5} }
+};
+
+/* 1600x1024 (GTF) */
+struct crt_mode_table CRTM1600x1024[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_136_700M, M1600X1024_R60_HSP, M1600X1024_R60_VSP,
+	 {2144, 1600, 1600, 544, 1704, 168, 1060, 1024, 1024, 36, 1025, 3} }
+};
+
+/* 1792x1344 (DMT) */
+struct crt_mode_table CRTM1792x1344[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_204_000M, M1792x1344_R60_HSP, M1792x1344_R60_VSP,
+	 {2448, 1792, 1792, 656, 1920, 200, 1394, 1344, 1344, 50, 1345, 3} }
+};
+
+/* 1856x1392 (DMT) */
+struct crt_mode_table CRTM1856x1392[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_218_500M, M1856x1392_R60_HSP, M1856x1392_R60_VSP,
+	 {2528, 1856, 1856, 672, 1952, 224, 1439, 1392, 1392, 47, 1393, 3} }
+};
+
+/* 1920x1200 (CVT) */
+struct crt_mode_table CRTM1920x1200[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_193_295M, M1920X1200_R60_HSP, M1920X1200_R60_VSP,
+	 {2592, 1920, 1920, 672, 2056, 200, 1245, 1200, 1200, 45, 1203, 6} }
+};
+
+/* 1920x1200 (CVT with Reduce Blanking) */
+struct crt_mode_table CRTM1920x1200_RB[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE, HSS, HSE, VT,  VA,  VBS, VBE, VSS, VSE */
+	{REFRESH_60, CLK_153_920M, M1920X1200_RB_R60_HSP,
+	 M1920X1200_RB_R60_VSP,
+	 {2080, 1920, 1920, 160, 1968, 32, 1235, 1200, 1200, 35, 1203, 6} }
+};
+
+/* 2048x1536 (CVT) */
+struct crt_mode_table CRTM2048x1536[] = {
+	/* r_rate,          vclk,              hsp,             vsp   */
+	/* HT,  HA,  HBS, HBE,  HSS, HSE,   VT,  VA,  VBS, VBE,  VSS, VSE */
+	{REFRESH_60, CLK_267_250M, M2048x1536_R60_HSP, M2048x1536_R60_VSP,
+	 {2800, 2048, 2048, 752, 2200, 224, 1592, 1536, 1536, 56, 1539, 4} }
+};
+
+/* Video Mode Table */
+/* struct VideoModeTable {*/
+/*  int                               ModeIndex;*/
+/*  struct crt_mode_table             *crtc;*/
+/*  int                               mode_array;*/
+/* };*/
+struct VideoModeTable CLE266Modes[] = {
+	/* Display : 480x640 (GTF) */
+	{VIA_RES_480X640, CRTM480x640, ARRAY_SIZE(CRTM480x640)},
+
+	/* Display : 640x480 */
+	{VIA_RES_640X480, CRTM640x480, ARRAY_SIZE(CRTM640x480)},
+
+	/* Display : 720x480 (GTF) */
+	{VIA_RES_720X480, CRTM720x480, ARRAY_SIZE(CRTM720x480)},
+
+	/* Display : 720x576 (GTF) */
+	{VIA_RES_720X576, CRTM720x576, ARRAY_SIZE(CRTM720x576)},
+
+	/* Display : 800x600 */
+	{VIA_RES_800X600, CRTM800x600, ARRAY_SIZE(CRTM800x600)},
+
+	/* Display : 800x480 (CVT) */
+	{VIA_RES_800X480, CRTM800x480, ARRAY_SIZE(CRTM800x480)},
+
+	/* Display : 848x480 (CVT) */
+	{VIA_RES_848X480, CRTM848x480, ARRAY_SIZE(CRTM848x480)},
+
+	/* Display : 852x480 (GTF) */
+	{VIA_RES_856X480, CRTM852x480, ARRAY_SIZE(CRTM852x480)},
+
+	/* Display : 1024x512 (GTF) */
+	{VIA_RES_1024X512, CRTM1024x512, ARRAY_SIZE(CRTM1024x512)},
+
+	/* Display : 1024x600 */
+	{VIA_RES_1024X600, CRTM1024x600, ARRAY_SIZE(CRTM1024x600)},
+
+	/* Display : 1024x576 (GTF) */
+	/*{ VIA_RES_1024X576, CRTM1024x576, ARRAY_SIZE(CRTM1024x576)}, */
+
+	/* Display : 1024x768 */
+	{VIA_RES_1024X768, CRTM1024x768, ARRAY_SIZE(CRTM1024x768)},
+
+	/* Display : 1152x864 */
+	{VIA_RES_1152X864, CRTM1152x864, ARRAY_SIZE(CRTM1152x864)},
+
+	/* Display : 1280x768 (GTF) */
+	{VIA_RES_1280X768, CRTM1280x768, ARRAY_SIZE(CRTM1280x768)},
+
+	/* Display : 960x600 (CVT) */
+	{VIA_RES_960X600, CRTM960x600, ARRAY_SIZE(CRTM960x600)},
+
+	/* Display : 1000x600 (GTF) */
+	{VIA_RES_1000X600, CRTM1000x600, ARRAY_SIZE(CRTM1000x600)},
+
+	/* Display : 1024x576 (GTF) */
+	{VIA_RES_1024X576, CRTM1024x576, ARRAY_SIZE(CRTM1024x576)},
+
+	/* Display : 1088x612 (GTF) */
+	{VIA_RES_1088X612, CRTM1088x612, ARRAY_SIZE(CRTM1088x612)},
+
+	/* Display : 1152x720 (CVT) */
+	{VIA_RES_1152X720, CRTM1152x720, ARRAY_SIZE(CRTM1152x720)},
+
+	/* Display : 1200x720 (GTF) */
+	{VIA_RES_1200X720, CRTM1200x720, ARRAY_SIZE(CRTM1200x720)},
+
+	/* Display : 1280x600 (GTF) */
+	{VIA_RES_1280X600, CRTM1280x600, ARRAY_SIZE(CRTM1280x600)},
+
+	/* Display : 1280x800 (CVT) */
+	{VIA_RES_1280X800, CRTM1280x800, ARRAY_SIZE(CRTM1280x800)},
+
+	/* Display : 1280x800 (GTF) */
+	/*{ M1280x800, CRTM1280x800, ARRAY_SIZE(CRTM1280x800)}, */
+
+	/* Display : 1280x960 */
+	{VIA_RES_1280X960, CRTM1280x960, ARRAY_SIZE(CRTM1280x960)},
+
+	/* Display : 1280x1024 */
+	{VIA_RES_1280X1024, CRTM1280x1024, ARRAY_SIZE(CRTM1280x1024)},
+
+	/* Display : 1360x768 (CVT) */
+	{VIA_RES_1360X768, CRTM1360x768, ARRAY_SIZE(CRTM1360x768)},
+
+	/* Display : 1360x768 (CVT Reduce Blanking) */
+	{VIA_RES_1360X768_RB, CRTM1360x768_RB,
+	 ARRAY_SIZE(CRTM1360x768_RB)},
+
+	/* Display : 1366x768 */
+	{VIA_RES_1366X768, CRTM1366x768, ARRAY_SIZE(CRTM1366x768)},
+
+	/* Display : 1368x768 (GTF) */
+	/*{ M1368x768,CRTM1368x768,ARRAY_SIZE(CRTM1368x768)}, */
+	/* Display : 1368x768 (GTF) */
+	{VIA_RES_1368X768, CRTM1368x768, ARRAY_SIZE(CRTM1368x768)},
+
+	/* Display : 1440x900 (CVT) */
+	{VIA_RES_1440X900, CRTM1440x900, ARRAY_SIZE(CRTM1440x900)},
+
+	/* Display : 1440x900 (CVT Reduce Blanking) */
+	{VIA_RES_1440X900_RB, CRTM1440x900_RB,
+	 ARRAY_SIZE(CRTM1440x900_RB)},
+
+	/* Display : 1440x1050 (GTF) */
+	{VIA_RES_1440X1050, CRTM1440x1050, ARRAY_SIZE(CRTM1440x1050)},
+
+	/* Display : 1400x1050 (CVT Reduce Blanking) */
+	{VIA_RES_1400X1050_RB, CRTM1400x1050_RB,
+	 ARRAY_SIZE(CRTM1400x1050_RB)},
+
+	/* Display : 1600x900 (CVT) */
+	{VIA_RES_1600X900, CRTM1600x900, ARRAY_SIZE(CRTM1600x900)},
+
+	/* Display : 1600x900 (CVT Reduce Blanking) */
+	{VIA_RES_1600X900_RB, CRTM1600x900_RB,
+	 ARRAY_SIZE(CRTM1600x900_RB)},
+
+	/* Display : 1600x1024 (GTF) */
+	{VIA_RES_1600X1024, CRTM1600x1024, ARRAY_SIZE(CRTM1600x1024)},
+
+	/* Display : 1600x1200 */
+	{VIA_RES_1600X1200, CRTM1600x1200, ARRAY_SIZE(CRTM1600x1200)},
+
+	/* Display : 1680x1050 (CVT) */
+	{VIA_RES_1680X1050, CRTM1680x1050, ARRAY_SIZE(CRTM1680x1050)},
+
+	/* Display : 1680x1050 (CVT Reduce Blanking) */
+	{VIA_RES_1680X1050_RB, CRTM1680x1050_RB,
+	 ARRAY_SIZE(CRTM1680x1050_RB)},
+
+	/* Display : 1792x1344 (DMT) */
+	{VIA_RES_1792X1344, CRTM1792x1344, ARRAY_SIZE(CRTM1792x1344)},
+
+	/* Display : 1856x1392 (DMT) */
+	{VIA_RES_1856X1392, CRTM1856x1392, ARRAY_SIZE(CRTM1856x1392)},
+
+	/* Display : 1920x1440 */
+	{VIA_RES_1920X1440, CRTM1920x1440, ARRAY_SIZE(CRTM1920x1440)},
+
+	/* Display : 2048x1536 */
+	{VIA_RES_2048X1536, CRTM2048x1536, ARRAY_SIZE(CRTM2048x1536)},
+
+	/* Display : 1280x720 */
+	{VIA_RES_1280X720, CRTM1280x720, ARRAY_SIZE(CRTM1280x720)},
+
+	/* Display : 1920x1080 (CVT) */
+	{VIA_RES_1920X1080, CRTM1920x1080, ARRAY_SIZE(CRTM1920x1080)},
+
+	/* Display : 1920x1080 (CVT Reduce Blanking) */
+	{VIA_RES_1920X1080_RB, CRTM1920x1080_RB,
+	 ARRAY_SIZE(CRTM1920x1080_RB)},
+
+	/* Display : 1920x1200 (CVT) */
+	{VIA_RES_1920X1200, CRTM1920x1200, ARRAY_SIZE(CRTM1920x1200)},
+
+	/* Display : 1920x1200 (CVT Reduce Blanking) */
+	{VIA_RES_1920X1200_RB, CRTM1920x1200_RB,
+	 ARRAY_SIZE(CRTM1920x1200_RB)},
+
+	/* Display : 1400x1050 (CVT) */
+	{VIA_RES_1400X1050, CRTM1400x1050, ARRAY_SIZE(CRTM1400x1050)}
+};
+struct crt_mode_table CEAM1280x720[] = {
+	{REFRESH_60, CLK_74_270M, M1280X720_CEA_R60_HSP,
+	 M1280X720_CEA_R60_VSP,
+	 /* HT,    HA,   HBS,  HBE,  HSS, HSE,  VT,   VA,  VBS, VBE, VSS, VSE */
+	 {1650, 1280, 1280, 370, 1390, 40, 750, 720, 720, 30, 725, 5} }
+};
+struct crt_mode_table CEAM1920x1080[] = {
+	{REFRESH_60, CLK_148_500M, M1920X1080_CEA_R60_HSP,
+	 M1920X1080_CEA_R60_VSP,
+	 /* HT,    HA,   HBS,  HBE,  HSS, HSE,  VT,  VA, VBS, VBE,  VSS, VSE */
+	 {2200, 1920, 1920, 300, 2008, 44, 1125, 1080, 1080, 45, 1084, 5} }
+};
+struct VideoModeTable CEA_HDMI_Modes[] = {
+	/* Display : 1280x720 */
+	{VIA_RES_1280X720, CEAM1280x720, ARRAY_SIZE(CEAM1280x720)},
+	{VIA_RES_1920X1080, CEAM1920x1080, ARRAY_SIZE(CEAM1920x1080)}
+};
--- /dev/null
+++ b/drivers/video/viafb/viamode.h
@@ -0,0 +1,177 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __VIAMODE_H__
+#define __VIAMODE_H__
+
+#include "global.h"
+
+struct VPITTable {
+	unsigned char Misc;
+	unsigned char SR[StdSR];
+	unsigned char GR[StdGR];
+	unsigned char AR[StdAR];
+};
+
+struct VideoModeTable {
+	int ModeIndex;
+	struct crt_mode_table *crtc;
+	int mode_array;
+};
+
+struct patch_table {
+	int mode_index;
+	int table_length;
+	struct io_reg *io_reg_table;
+};
+
+struct res_map_refresh {
+	int hres;
+	int vres;
+	int pixclock;
+	int vmode_refresh;
+};
+
+#define NUM_TOTAL_RES_MAP_REFRESH ARRAY_SIZE(res_map_refresh_tbl)
+#define NUM_TOTAL_CEA_MODES  ARRAY_SIZE(CEA_HDMI_Modes)
+#define NUM_TOTAL_CN400_ModeXregs ARRAY_SIZE(CN400_ModeXregs)
+#define NUM_TOTAL_CN700_ModeXregs ARRAY_SIZE(CN700_ModeXregs)
+#define NUM_TOTAL_KM400_ModeXregs ARRAY_SIZE(KM400_ModeXregs)
+#define NUM_TOTAL_CX700_ModeXregs ARRAY_SIZE(CX700_ModeXregs)
+#define NUM_TOTAL_VX800_ModeXregs ARRAY_SIZE(VX800_ModeXregs)
+#define NUM_TOTAL_CLE266_ModeXregs ARRAY_SIZE(CLE266_ModeXregs)
+#define NUM_TOTAL_PATCH_MODE ARRAY_SIZE(res_patch_table)
+#define NUM_TOTAL_MODETABLE ARRAY_SIZE(CLE266Modes)
+
+/********************/
+/* Mode Table       */
+/********************/
+
+/* 480x640 */
+extern struct crt_mode_table CRTM480x640[1];
+/* 640x480*/
+extern struct crt_mode_table CRTM640x480[5];
+/*720x480 (GTF)*/
+extern struct crt_mode_table CRTM720x480[1];
+/*720x576 (GTF)*/
+extern struct crt_mode_table CRTM720x576[1];
+/* 800x480 (CVT) */
+extern struct crt_mode_table CRTM800x480[1];
+/* 800x600*/
+extern struct crt_mode_table CRTM800x600[5];
+/* 848x480 (CVT) */
+extern struct crt_mode_table CRTM848x480[1];
+/*856x480 (GTF) convert to 852x480*/
+extern struct crt_mode_table CRTM852x480[1];
+/*1024x512 (GTF)*/
+extern struct crt_mode_table CRTM1024x512[1];
+/* 1024x600*/
+extern struct crt_mode_table CRTM1024x600[1];
+/* 1024x768*/
+extern struct crt_mode_table CRTM1024x768[4];
+/* 1152x864*/
+extern struct crt_mode_table CRTM1152x864[1];
+/* 1280x720 (HDMI 720P)*/
+extern struct crt_mode_table CRTM1280x720[2];
+/*1280x768 (GTF)*/
+extern struct crt_mode_table CRTM1280x768[2];
+/* 1280x800 (CVT) */
+extern struct crt_mode_table CRTM1280x800[1];
+/*1280x960*/
+extern struct crt_mode_table CRTM1280x960[1];
+/* 1280x1024*/
+extern struct crt_mode_table CRTM1280x1024[3];
+/* 1368x768 (GTF) */
+extern struct crt_mode_table CRTM1368x768[1];
+/*1440x1050 (GTF)*/
+extern struct crt_mode_table CRTM1440x1050[1];
+/* 1600x1200*/
+extern struct crt_mode_table CRTM1600x1200[2];
+/* 1680x1050 (CVT) */
+extern struct crt_mode_table CRTM1680x1050[2];
+/* 1680x1050 (CVT Reduce Blanking) */
+extern struct crt_mode_table CRTM1680x1050_RB[1];
+/* 1920x1080 (CVT)*/
+extern struct crt_mode_table CRTM1920x1080[1];
+/* 1920x1080 (CVT with Reduce Blanking) */
+extern struct crt_mode_table CRTM1920x1080_RB[1];
+/* 1920x1440*/
+extern struct crt_mode_table CRTM1920x1440[2];
+/* 1400x1050 (CVT) */
+extern struct crt_mode_table CRTM1400x1050[2];
+/* 1400x1050 (CVT Reduce Blanking) */
+extern struct crt_mode_table CRTM1400x1050_RB[1];
+/* 960x600 (CVT) */
+extern struct crt_mode_table CRTM960x600[1];
+/* 1000x600 (GTF) */
+extern struct crt_mode_table CRTM1000x600[1];
+/* 1024x576 (GTF) */
+extern struct crt_mode_table CRTM1024x576[1];
+/* 1088x612 (CVT) */
+extern struct crt_mode_table CRTM1088x612[1];
+/* 1152x720 (CVT) */
+extern struct crt_mode_table CRTM1152x720[1];
+/* 1200x720 (GTF) */
+extern struct crt_mode_table CRTM1200x720[1];
+/* 1280x600 (GTF) */
+extern struct crt_mode_table CRTM1280x600[1];
+/* 1360x768 (CVT) */
+extern struct crt_mode_table CRTM1360x768[1];
+/* 1360x768 (CVT Reduce Blanking) */
+extern struct crt_mode_table CRTM1360x768_RB[1];
+/* 1366x768 (GTF) */
+extern struct crt_mode_table CRTM1366x768[2];
+/* 1440x900 (CVT) */
+extern struct crt_mode_table CRTM1440x900[2];
+/* 1440x900 (CVT Reduce Blanking) */
+extern struct crt_mode_table CRTM1440x900_RB[1];
+/* 1600x900 (CVT) */
+extern struct crt_mode_table CRTM1600x900[1];
+/* 1600x900 (CVT Reduce Blanking) */
+extern struct crt_mode_table CRTM1600x900_RB[1];
+/* 1600x1024 (GTF) */
+extern struct crt_mode_table CRTM1600x1024[1];
+/* 1792x1344 (DMT) */
+extern struct crt_mode_table CRTM1792x1344[1];
+/* 1856x1392 (DMT) */
+extern struct crt_mode_table CRTM1856x1392[1];
+/* 1920x1200 (CVT) */
+extern struct crt_mode_table CRTM1920x1200[1];
+/* 1920x1200 (CVT with Reduce Blanking) */
+extern struct crt_mode_table CRTM1920x1200_RB[1];
+/* 2048x1536 (CVT) */
+extern struct crt_mode_table CRTM2048x1536[1];
+extern struct VideoModeTable CLE266Modes[47];
+extern struct crt_mode_table CEAM1280x720[1];
+extern struct crt_mode_table CEAM1920x1080[1];
+extern struct VideoModeTable CEA_HDMI_Modes[2];
+
+extern struct res_map_refresh res_map_refresh_tbl[61];
+extern struct io_reg CN400_ModeXregs[52];
+extern struct io_reg CN700_ModeXregs[66];
+extern struct io_reg KM400_ModeXregs[55];
+extern struct io_reg CX700_ModeXregs[58];
+extern struct io_reg VX800_ModeXregs[58];
+extern struct io_reg CLE266_ModeXregs[32];
+extern struct io_reg PM1024x768[2];
+extern struct patch_table res_patch_table[1];
+extern struct VPITTable VPIT;
+#endif /* __VIAMODE_H__ */
--- /dev/null
+++ b/drivers/video/viafb/via_utility.c
@@ -0,0 +1,299 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+void get_device_support_state(u32 *support_state)
+{
+	*support_state = CRT_Device;
+
+	if (chip_info.tmds_chip_info.tmds_chip_name == VT1632_TMDS)
+		*support_state |= DVI_Device;
+
+	if (chip_info.lvds_chip_info.lvds_chip_name == VT1631_LVDS)
+		*support_state |= LCD_Device;
+}
+
+void get_device_connect_state(u32 *connect_state)
+{
+	bool mobile = FALSE;
+
+	*connect_state = CRT_Device;
+
+	if (dvi_sense())
+		*connect_state |= DVI_Device;
+
+	lcd_get_mobile_state(&mobile);
+	if (mobile)
+		*connect_state |= LCD_Device;
+}
+
+bool lcd_get_support_expand_state(u32 xres, u32 yres)
+{
+	unsigned int support_state = 0;
+
+	switch (lcd_panel_id) {
+	case LCD_PANEL_ID0_640X480:
+		if ((xres < 640) && (yres < 480))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_ID1_800X600:
+		if ((xres < 800) && (yres < 600))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_ID2_1024X768:
+		if ((xres < 1024) && (yres < 768))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_ID3_1280X768:
+		if ((xres < 1280) && (yres < 768))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_ID4_1280X1024:
+		if ((xres < 1280) && (yres < 1024))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_ID5_1400X1050:
+		if ((xres < 1400) && (yres < 1050))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_ID6_1600X1200:
+		if ((xres < 1600) && (yres < 1200))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_ID7_1366X768:
+		if ((xres < 1366) && (yres < 768))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_ID8_1024X600:
+		if ((xres < 1024) && (yres < 600))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_ID9_1280X800:
+		if ((xres < 1280) && (yres < 800))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_IDA_800X480:
+		if ((xres < 800) && (yres < 480))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_IDB_1360X768:
+		if ((xres < 1360) && (yres < 768))
+			support_state = TRUE;
+		break;
+
+	case LCD_PANEL_IDC_480X640:
+		if ((xres < 480) && (yres < 640))
+			support_state = TRUE;
+		break;
+
+	default:
+		support_state = FALSE;
+		break;
+	}
+
+	return support_state;
+}
+
+/*====================================================================*/
+/*                      Gamma Function Implementation*/
+/*====================================================================*/
+
+void set_gamma_table(int bpp, unsigned int *gamma_table)
+{
+	int i, sr1a;
+	int active_device_amount = 0;
+	int device_status = DeviceStatus;
+	unsigned char color_r[256];
+	unsigned char color_g[256];
+	unsigned char color_b[256];
+
+	for (i = 0; i < sizeof(DeviceStatus) * 8; i++) {
+		if (device_status & 1)
+			active_device_amount++;
+		device_status >>= 1;
+	}
+
+	for (i = 0; i < 256; i++) {
+		color_r[i] = gamma_table[i] >> 16;
+		color_g[i] = (gamma_table[i] >> 8) & 0x00FF;
+		color_b[i] = gamma_table[i] & 0x000000FF;
+	}
+
+	/* 8 bpp mode can't adjust gamma */
+	if (!(bpp == 8)) {
+		/* Enable Gamma */
+		switch (chip_info.gfx_chip_name) {
+		case UNICHROME_CLE266:
+		case UNICHROME_K400:
+			write_reg_mask(SR16, VIASR, 0x80, BIT7);
+			break;
+
+		case UNICHROME_K800:
+		case UNICHROME_PM800:
+		case UNICHROME_CN700:
+		case UNICHROME_CX700:
+		case UNICHROME_K8M890:
+		case UNICHROME_P4M890:
+		case UNICHROME_P4M900:
+			write_reg_mask(CR33, VIACR, 0x80, BIT7);
+			break;
+		}
+		sr1a = (unsigned int)read_reg(VIASR, SR1A);
+		write_reg_mask(SR1A, VIASR, 0x0, BIT0);
+
+		/* Fill IGA1 Gamma Table */
+		outb(0, LUT_INDEX_WRITE);
+		for (i = 0; i < 256; i++) {
+			outb(color_r[i], LUT_DATA);
+			outb(color_g[i], LUT_DATA);
+			outb(color_b[i], LUT_DATA);
+		}
+
+		/* If adjust Gamma value in SAMM, fill IGA1,
+		   IGA2 Gamma table simultanous. */
+		/* Switch to IGA2 Gamma Table */
+		if ((active_device_amount > 1) &&
+		    !((chip_info.gfx_chip_name == UNICHROME_CLE266) &&
+		      (chip_info.gfx_chip_revision < 15))) {
+			write_reg_mask(SR1A, VIASR, 0x01, BIT0);
+			write_reg_mask(CR6A, VIACR, 0x02, BIT1);
+
+			/* Fill IGA2 Gamma Table */
+			outb(0, LUT_INDEX_WRITE);
+			for (i = 0; i < 256; i++) {
+				outb(color_r[i], LUT_DATA);
+				outb(color_g[i], LUT_DATA);
+				outb(color_b[i], LUT_DATA);
+			}
+		}
+		write_reg(SR1A, VIASR, sr1a);
+	}
+}
+
+void get_gamma_table(unsigned int *gamma_table)
+{
+	unsigned char color_r[256];
+	unsigned char color_g[256];
+	unsigned char color_b[256];
+	unsigned char sr1a = 0;
+	int i;
+
+	/* Enable Gamma */
+	switch (chip_info.gfx_chip_name) {
+	case UNICHROME_CLE266:
+	case UNICHROME_K400:
+		write_reg_mask(SR16, VIASR, 0x80, BIT7);
+		break;
+
+	case UNICHROME_K800:
+	case UNICHROME_PM800:
+	case UNICHROME_CN700:
+	case UNICHROME_CX700:
+	case UNICHROME_K8M890:
+	case UNICHROME_P4M890:
+	case UNICHROME_P4M900:
+		write_reg_mask(CR33, VIACR, 0x80, BIT7);
+		break;
+	}
+	sr1a = read_reg(VIASR, SR1A);
+	write_reg_mask(SR1A, VIASR, 0x0, BIT0);
+
+	/* Reading gamma table to get color value */
+	outb(0, LUT_INDEX_READ);
+	for (i = 0; i < 256; i++) {
+		color_r[i] = inb(LUT_DATA);
+		color_g[i] = inb(LUT_DATA);
+		color_b[i] = inb(LUT_DATA);
+		gamma_table[i] =
+		    ((((u32) color_r[i]) << 16) |
+		     (((u16) color_g[i]) << 8)) | color_b[i];
+	}
+	write_reg(SR1A, VIASR, sr1a);
+}
+
+void get_gamma_support_state(int bpp, unsigned int *support_state)
+{
+	if (bpp == 8)
+		*support_state = None_Device;
+	else
+		*support_state = CRT_Device | DVI_Device | LCD_Device;
+}
+
+int input_parameter_converter(int parameter_value)
+{
+	int result;
+
+	switch (parameter_value) {
+	case 1:
+		result = 0x01;
+		break;
+
+	case 2:
+		result = 0x02;
+		break;
+
+	case 3:
+		result = 0x04;
+		break;
+
+	case 4:
+		result = 0x08;
+		break;
+
+	case 5:
+		result = 0x10;
+		break;
+
+	case 6:
+		result = 0x20;
+		break;
+
+	case 7:
+		result = 0x40;
+		break;
+
+	case 8:
+		result = 0x80;
+		break;
+
+	case 9:
+		result = 0x100;
+		break;
+
+	default:
+		result = 0x01;
+		break;
+	}
+
+	return result;
+}
--- /dev/null
+++ b/drivers/video/viafb/via_utility.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef __VIAUTILITY_H__
+#define __VIAUTILITY_H__
+
+/* These functions are used to get infomation about device's state */
+void get_device_support_state(u32 *support_state);
+void get_device_connect_state(u32 *connect_state);
+bool lcd_get_support_expand_state(u32 xres, u32 yres);
+
+/* These function are used to access gamma table */
+void set_gamma_table(int bpp, unsigned int *gamma_table);
+void get_gamma_table(unsigned int *gamma_table);
+void get_gamma_support_state(int bpp, unsigned int *support_state);
+int input_parameter_converter(int parameter_value);
+
+#endif /* __VIAUTILITY_H__ */
--- /dev/null
+++ b/drivers/video/viafb/vt1636.c
@@ -0,0 +1,317 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "global.h"
+
+u8 gpio_i2c_read_lvds(struct lvds_setting_information *plvds_setting_info,
+		      struct lvds_chip_information *plvds_chip_info, u8 index)
+{
+	u8 data;
+	int tmp;
+	tmp = chip_info.chip_on_slot;
+	switch (plvds_chip_info->i2c_port) {
+	case I2CPORTINDEX:
+		chip_info.chip_on_slot = PORT_ON_AMR;
+		break;
+	case GPIOPORTINDEX:
+	default:
+		chip_info.chip_on_slot = PORT_ON_AGP;
+		break;
+	}
+	i2cReadByte(plvds_chip_info->lvds_chip_slave_addr, index, &data);
+	chip_info.chip_on_slot = tmp;
+	return data;
+}
+
+void gpio_i2c_write_mask_lvds(struct lvds_setting_information
+			      *plvds_setting_info, struct lvds_chip_information
+			      *plvds_chip_info, struct IODATA io_data)
+{
+	int index, data, tmp;
+	tmp = chip_info.chip_on_slot;
+	switch (plvds_chip_info->i2c_port) {
+	case I2CPORTINDEX:
+		chip_info.chip_on_slot = PORT_ON_AMR;
+		break;
+	case GPIOPORTINDEX:
+	default:
+		chip_info.chip_on_slot = PORT_ON_AGP;
+		break;
+	}
+
+	index = io_data.Index;
+	data = gpio_i2c_read_lvds(plvds_setting_info, plvds_chip_info, index);
+	data = (data & (~io_data.Mask)) | io_data.Data;
+
+	i2cWriteByte(plvds_chip_info->lvds_chip_slave_addr, index, data);
+	chip_info.chip_on_slot = tmp;
+}
+
+void init_lvds_vt1636(struct lvds_setting_information *plvds_setting_info,
+		      struct lvds_chip_information *plvds_chip_info)
+{
+	int reg_num, i;
+
+	/* Common settings: */
+	reg_num = ARRAY_SIZE(COMMON_INIT_TBL_VT1636);
+
+	for (i = 0; i < reg_num; i++) {
+		gpio_i2c_write_mask_lvds(plvds_setting_info,
+					 plvds_chip_info,
+					 COMMON_INIT_TBL_VT1636[i]);
+	}
+
+	/* Input Data Mode Select */
+	if (plvds_setting_info->device_lcd_dualedge) {
+		gpio_i2c_write_mask_lvds(plvds_setting_info,
+					 plvds_chip_info,
+					 DUAL_CHANNEL_ENABLE_TBL_VT1636[0]);
+	} else {
+		gpio_i2c_write_mask_lvds(plvds_setting_info,
+					 plvds_chip_info,
+					 SINGLE_CHANNEL_ENABLE_TBL_VT1636[0]);
+	}
+
+	if (plvds_setting_info->LCDDithering) {
+		gpio_i2c_write_mask_lvds(plvds_setting_info,
+					 plvds_chip_info,
+					 DITHERING_ENABLE_TBL_VT1636[0]);
+	} else {
+		gpio_i2c_write_mask_lvds(plvds_setting_info,
+					 plvds_chip_info,
+					 DITHERING_DISABLE_TBL_VT1636[0]);
+	}
+}
+
+void enable_lvds_vt1636(struct lvds_setting_information
+			*plvds_setting_info,
+			struct lvds_chip_information *plvds_chip_info)
+{
+
+	gpio_i2c_write_mask_lvds(plvds_setting_info, plvds_chip_info,
+				 VDD_ON_TBL_VT1636[0]);
+
+	/* Pad on: */
+	switch (plvds_chip_info->output_interface) {
+	case INTERFACE_DVP0:
+		{
+			write_reg_mask(SR1E, VIASR, 0xC0, 0xC0);
+			break;
+		}
+
+	case INTERFACE_DVP1:
+		{
+			write_reg_mask(SR1E, VIASR, 0x30, 0x30);
+			break;
+		}
+
+	case INTERFACE_DFP_LOW:
+		{
+			write_reg_mask(SR2A, VIASR, 0x03, 0x03);
+			break;
+		}
+
+	case INTERFACE_DFP_HIGH:
+		{
+			write_reg_mask(SR2A, VIASR, 0x03, 0x0C);
+			break;
+		}
+
+	}
+}
+
+void disable_lvds_vt1636(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info)
+{
+
+	gpio_i2c_write_mask_lvds(plvds_setting_info, plvds_chip_info,
+				 VDD_OFF_TBL_VT1636[0]);
+
+	/* Pad off: */
+	switch (plvds_chip_info->output_interface) {
+	case INTERFACE_DVP0:
+		{
+			write_reg_mask(SR1E, VIASR, 0x00, 0xC0);
+			break;
+		}
+
+	case INTERFACE_DVP1:
+		{
+			write_reg_mask(SR1E, VIASR, 0x00, 0x30);
+			break;
+		}
+
+	case INTERFACE_DFP_LOW:
+		{
+			write_reg_mask(SR2A, VIASR, 0x00, 0x03);
+			break;
+		}
+
+	case INTERFACE_DFP_HIGH:
+		{
+			write_reg_mask(SR2A, VIASR, 0x00, 0x0C);
+			break;
+		}
+
+	}
+}
+
+bool lvds_identify_vt1636(void)
+{
+	u8 Buffer[2];
+
+	DEBUG_MSG(KERN_INFO "lvds_identify_vt1636.\n");
+
+	/* Sense VT1636 LVDS Transmiter */
+	chip_info.lvds_chip_info.lvds_chip_slave_addr = VT1636_LVDS_I2C_ADDR;
+
+	/* Check vendor ID first: */
+	i2cReadByte((u8) chip_info.lvds_chip_info.lvds_chip_slave_addr,
+		    0x00, &Buffer[0]);
+	i2cReadByte((u8) chip_info.lvds_chip_info.lvds_chip_slave_addr,
+		    0x01, &Buffer[1]);
+
+	if (!((Buffer[0] == 0x06) && (Buffer[1] == 0x11)))
+		return FALSE;
+
+	/* Check Chip ID: */
+	i2cReadByte((u8) chip_info.lvds_chip_info.lvds_chip_slave_addr,
+		    0x02, &Buffer[0]);
+	i2cReadByte((u8) chip_info.lvds_chip_info.lvds_chip_slave_addr,
+		    0x03, &Buffer[1]);
+	if ((Buffer[0] == 0x45) && (Buffer[1] == 0x33)) {
+		chip_info.lvds_chip_info.lvds_chip_name = VT1636_LVDS;
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static int get_clk_range_index(u32 Clk)
+{
+	if (Clk < DPA_CLK_30M)
+		return DPA_CLK_RANGE_30M;
+	else if ((DPA_CLK_30M < Clk) && (Clk < DPA_CLK_50M))
+		return DPA_CLK_RANGE_30_50M;
+	else if ((DPA_CLK_50M < Clk) && (Clk < DPA_CLK_70M))
+		return DPA_CLK_RANGE_50_70M;
+	else if ((DPA_CLK_70M < Clk) && (Clk < DPA_CLK_100M))
+		return DPA_CLK_RANGE_70_100M;
+	else if ((DPA_CLK_100M < Clk) && (Clk < DPA_CLK_150M))
+		return DPA_CLK_RANGE_100_150M;
+	else
+		return DPA_CLK_RANGE_150M;
+}
+
+static int get_lvds_dpa_setting_index(int panel_size_id,
+			     struct VT1636_DPA_SETTING *p_vt1636_dpasetting_tbl,
+			     int tbl_size)
+{
+	int i;
+
+	for (i = 0; i < tbl_size; i++) {
+		if (panel_size_id == p_vt1636_dpasetting_tbl->PanelSizeID)
+			return i;
+
+		p_vt1636_dpasetting_tbl++;
+	}
+
+	return 0;
+}
+
+static void set_dpa_vt1636(struct lvds_setting_information *plvds_setting_info,
+			   struct lvds_chip_information *plvds_chip_info,
+			   struct VT1636_DPA_SETTING *p_vt1636_dpa_setting)
+{
+	struct IODATA io_data;
+
+	io_data.Index = 0x09;
+	io_data.Mask = 0x1F;
+	io_data.Data = p_vt1636_dpa_setting->CLK_SEL_ST1;
+	gpio_i2c_write_mask_lvds(plvds_setting_info, plvds_chip_info, io_data);
+
+	io_data.Index = 0x08;
+	io_data.Mask = 0x0F;
+	io_data.Data = p_vt1636_dpa_setting->CLK_SEL_ST2;
+	gpio_i2c_write_mask_lvds(plvds_setting_info, plvds_chip_info, io_data);
+}
+
+void vt1636_patch_skew_on_vt3324(struct lvds_setting_information
+				 *plvds_setting_info,
+				 struct lvds_chip_information
+				 *plvds_chip_info)
+{
+	int index, size;
+
+	DEBUG_MSG(KERN_INFO "vt1636_patch_skew_on_vt3324.\n");
+
+	/* Graphics DPA settings: */
+	index = get_clk_range_index(plvds_setting_info->vclk);
+	set_dpa_gfx(plvds_chip_info->output_interface,
+		    &GFX_DPA_SETTING_TBL_VT3324[index]);
+
+	/* LVDS Transmitter DPA settings: */
+	size = ARRAY_SIZE(VT1636_DPA_SETTING_TBL_VT3324);
+	index =
+	    get_lvds_dpa_setting_index(plvds_setting_info->lcd_panel_id,
+				       VT1636_DPA_SETTING_TBL_VT3324, size);
+	set_dpa_vt1636(plvds_setting_info, plvds_chip_info,
+		       &VT1636_DPA_SETTING_TBL_VT3324[index]);
+}
+
+void vt1636_patch_skew_on_vt3327(struct lvds_setting_information
+				 *plvds_setting_info,
+				 struct lvds_chip_information
+				 *plvds_chip_info)
+{
+	int index, size;
+
+	DEBUG_MSG(KERN_INFO "vt1636_patch_skew_on_vt3327.\n");
+
+	/* Graphics DPA settings: */
+	index = get_clk_range_index(plvds_setting_info->vclk);
+	set_dpa_gfx(plvds_chip_info->output_interface,
+		    &GFX_DPA_SETTING_TBL_VT3327[index]);
+
+	/* LVDS Transmitter DPA settings: */
+	size = ARRAY_SIZE(VT1636_DPA_SETTING_TBL_VT3327);
+	index =
+	    get_lvds_dpa_setting_index(plvds_setting_info->lcd_panel_id,
+				       VT1636_DPA_SETTING_TBL_VT3327, size);
+	set_dpa_vt1636(plvds_setting_info, plvds_chip_info,
+		       &VT1636_DPA_SETTING_TBL_VT3327[index]);
+}
+
+void vt1636_patch_skew_on_vt3364(struct lvds_setting_information
+				 *plvds_setting_info,
+				 struct lvds_chip_information
+				 *plvds_chip_info)
+{
+	int index;
+
+	DEBUG_MSG(KERN_INFO "vt1636_patch_skew_on_vt3364.\n");
+
+	/* Graphics DPA settings: */
+	index = get_clk_range_index(plvds_setting_info->vclk);
+	set_dpa_gfx(plvds_chip_info->output_interface,
+		    &GFX_DPA_SETTING_TBL_VT3364[index]);
+}
--- /dev/null
+++ b/drivers/video/viafb/vt1636.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 1998-2008 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2008 S3 Graphics, Inc. All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under  the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTIES OR REPRESENTATIONS; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR
+ * A PARTICULAR PURPOSE.See the GNU General Public License
+ * for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _VT1636_H_
+#define _VT1636_H_
+#include "chip.h"
+bool lvds_identify_vt1636(void);
+void init_lvds_vt1636(struct lvds_setting_information *plvds_setting_info,
+		      struct lvds_chip_information *plvds_chip_info);
+void enable_lvds_vt1636(struct lvds_setting_information
+			*plvds_setting_info,
+			struct lvds_chip_information *plvds_chip_info);
+void disable_lvds_vt1636(struct lvds_setting_information
+			 *plvds_setting_info,
+			 struct lvds_chip_information *plvds_chip_info);
+void vt1636_patch_skew_on_vt3324(struct lvds_setting_information
+				 *plvds_setting_info,
+				 struct lvds_chip_information
+				 *plvds_chip_info);
+void vt1636_patch_skew_on_vt3327(struct lvds_setting_information
+				 *plvds_setting_info,
+				 struct lvds_chip_information
+				 *plvds_chip_info);
+void vt1636_patch_skew_on_vt3364(struct lvds_setting_information
+				 *plvds_setting_info,
+				 struct lvds_chip_information
+				 *plvds_chip_info);
+
+#endif
