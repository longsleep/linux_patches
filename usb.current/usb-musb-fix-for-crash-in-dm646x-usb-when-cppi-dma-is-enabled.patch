From felipe.balbi@nokia.com  Tue Dec 22 14:16:50 2009
From: Swaminathan S <swami.iyer@ti.com>
Date: Tue, 15 Dec 2009 13:30:00 +0200
Subject: USB: musb: fix for crash in DM646x USB when (CPPI)DMA is enabled
To: Greg Kroah-Hartman <gregkh@suse.de>
Cc: David Brownell <david-b@pacbell.net>, Anand Gadiyar <gadiyar@ti.com>, Ajay Kumar Gupta <ajay.gupta@ti.com>, Arnaud Mandy <ext-arnaud.2.mandy@nokia.com>, Heikki Krogerus <ext-heikki.krogerus@nokia.com>, Atal Shargorodsky <ext-atal.shargorodsky@nokia.com>, Yauheni Kaliuta <yauheni.kaliuta@nokia.com>, Swaminathan S <swami.iyer@ti.com>, Felipe Balbi <felipe.balbi@nokia.com>
Message-ID: <1260876601-7598-12-git-send-email-felipe.balbi@nokia.com>


From: Swaminathan S <swami.iyer@ti.com>

Race condition exists between the cppi_interrupt handler and
davinci_interrupt handler w.r.t completing a TX IO.  Since DM646x
has seperate DMA and USB endpoint interrupts cppi_interrupt handler
needs to hold the lock while operating on the endpoint.

Update over previous patch to avoid taking the lock if already
taken.  Tested on DM644x, DM355 and DM646x platforms.

Signed-off-by: Swaminathan S <swami.iyer@ti.com>
Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Acked-by: Anand Gadiyar <gadiyar@ti.com>
Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/musb/cppi_dma.c |    6 ++++++
 1 file changed, 6 insertions(+)

--- a/drivers/usb/musb/cppi_dma.c
+++ b/drivers/usb/musb/cppi_dma.c
@@ -1154,8 +1154,11 @@ irqreturn_t cppi_interrupt(int irq, void
 	struct musb_hw_ep	*hw_ep = NULL;
 	u32			rx, tx;
 	int			i, index;
+	unsigned long		flags;
 
 	cppi = container_of(musb->dma_controller, struct cppi, controller);
+	if (cppi->irq)
+		spin_lock_irqsave(&musb->lock, flags);
 
 	tibase = musb->ctrl_base;
 
@@ -1285,6 +1288,9 @@ irqreturn_t cppi_interrupt(int irq, void
 	/* write to CPPI EOI register to re-enable interrupts */
 	musb_writel(tibase, DAVINCI_CPPI_EOI_REG, 0);
 
+	if (cppi->irq)
+		spin_unlock_irqrestore(&musb->lock, flags);
+
 	return IRQ_HANDLED;
 }
 
