From david-b@pacbell.net  Thu Aug  7 21:10:21 2008
From: David Brownell <david-b@pacbell.net>
Date: Wed, 6 Aug 2008 18:41:12 -0700
Subject: usb: cdc-acm: bugfix release()
To: Greg KH <greg@kroah.com>
Cc: linux-usb@vger.kernel.org, Oliver Neukum <oneukum@suse.de>
Message-ID: <200808061841.13144.david-b@pacbell.net>
Content-Disposition: inline

From: David Brownell <dbrownell@users.sourceforge.net>

Bugfixes to the usb_driver_release_interface() usage;

  (a) make sure releasing *either* interface first will release
      the other, instead of insisting it be the control interface;

  (b) remove the recently-added self-deadlock.

(The "fix disconnect bug in cdc-acm" patch was incomplete and incorrect.)

Plus a small "sparse" fix:  rename a local variable so it doesn't
shadow a function parameter.

Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Acked-by: Oliver Neukum <oneukum@suse.de>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/class/cdc-acm.c |   15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -1108,9 +1108,11 @@ skip_normal_probe:
 		rcv->instance = acm;
 	}
 	for (i = 0; i < num_rx_buf; i++) {
-		struct acm_rb *buf = &(acm->rb[i]);
+		struct acm_rb *rb = &(acm->rb[i]);
 
-		if (!(buf->base = usb_buffer_alloc(acm->dev, readsize, GFP_KERNEL, &buf->dma))) {
+		rb->base = usb_buffer_alloc(acm->dev, readsize,
+				GFP_KERNEL, &rb->dma);
+		if (!rb->base) {
 			dev_dbg(&intf->dev, "out of memory (read bufs usb_buffer_alloc)\n");
 			goto alloc_fail7;
 		}
@@ -1172,6 +1174,7 @@ skip_countries:
 	acm_set_line(acm, &acm->line);
 
 	usb_driver_claim_interface(&acm_driver, data_interface, acm);
+	usb_set_intfdata(data_interface, acm);
 
 	usb_get_intf(control_interface);
 	tty_register_device(acm_tty_driver, minor, &control_interface->dev);
@@ -1221,11 +1224,11 @@ static void acm_disconnect(struct usb_in
 	struct acm *acm = usb_get_intfdata(intf);
 	struct usb_device *usb_dev = interface_to_usbdev(intf);
 
-	mutex_lock(&open_mutex);
-	if (!acm || !acm->dev) {
-		mutex_unlock(&open_mutex);
+	/* sibling interface is already cleaning up */
+	if (!acm)
 		return;
-	}
+
+	mutex_lock(&open_mutex);
 	if (acm->country_codes){
 		device_remove_file(&acm->control->dev,
 				&dev_attr_wCountryCodes);
