From stern@rowland.harvard.edu  Fri Jul 10 10:34:03 2009
From: Alan Stern <stern@rowland.harvard.edu>
Date: Thu, 9 Jul 2009 12:58:43 -0400 (EDT)
Subject: USB: option: remove unnecessary and erroneous code
To: Greg KH <greg@kroah.com>
Message-ID: <Pine.LNX.4.44L0.0907091257050.11201-100000@iolanthe.rowland.org>


This patch (as1264) removes a bunch of unnecessary and erroneous stuff
from the option USB-serial driver.  Clearly there's no need to verify
that the device pointer stored in the URBs is right or to store the
same pointer over again.  After all, the pointer can't change once it
has been set up.

There's also no need to call usb_clear_halt for the IN endpoint
multiple times -- in fact, doing so is an error since every time after
the first there will be active URBs queued for that endpoint.  Since
the Clear-Halts don't appear to be needed at all, the patch simply
removes them.

Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/serial/option.c |   27 +--------------------------
 1 file changed, 1 insertion(+), 26 deletions(-)

--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -748,7 +748,6 @@ static int option_write(struct tty_struc
 		memcpy(this_urb->transfer_buffer, buf, todo);
 		this_urb->transfer_buffer_length = todo;
 
-		this_urb->dev = port->serial->dev;
 		err = usb_submit_urb(this_urb, GFP_ATOMIC);
 		if (err) {
 			dbg("usb_submit_urb %p (write bulk) failed "
@@ -876,7 +875,6 @@ static void option_instat_callback(struc
 
 	/* Resubmit urb so we continue receiving IRQ data */
 	if (status != -ESHUTDOWN && status != -ENOENT) {
-		urb->dev = serial->dev;
 		err = usb_submit_urb(urb, GFP_ATOMIC);
 		if (err)
 			dbg("%s: resubmit intr urb failed. (%d)",
@@ -937,23 +935,11 @@ static int option_open(struct tty_struct
 
 	dbg("%s", __func__);
 
-	/* Reset low level data toggle and start reading from endpoints */
+	/* Start reading from the IN endpoint */
 	for (i = 0; i < N_IN_URB; i++) {
 		urb = portdata->in_urbs[i];
 		if (!urb)
 			continue;
-		if (urb->dev != serial->dev) {
-			dbg("%s: dev %p != %p", __func__,
-				urb->dev, serial->dev);
-			continue;
-		}
-
-		/*
-		 * make sure endpoint data toggle is synchronized with the
-		 * device
-		 */
-		usb_clear_halt(urb->dev, urb->pipe);
-
 		err = usb_submit_urb(urb, GFP_KERNEL);
 		if (err) {
 			dbg("%s: submit urb %d failed (%d) %d",
@@ -962,16 +948,6 @@ static int option_open(struct tty_struct
 		}
 	}
 
-	/* Reset low level data toggle on out endpoints */
-	for (i = 0; i < N_OUT_URB; i++) {
-		urb = portdata->out_urbs[i];
-		if (!urb)
-			continue;
-		urb->dev = serial->dev;
-		/* usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),
-				usb_pipeout(urb->pipe), 0); */
-	}
-
 	option_send_setup(port);
 
 	return 0;
@@ -1234,7 +1210,6 @@ static int option_resume(struct usb_seri
 			dbg("%s: No interrupt URB for port %d\n", __func__, i);
 			continue;
 		}
-		port->interrupt_in_urb->dev = serial->dev;
 		err = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);
 		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
 		if (err < 0) {
