From david-b@pacbell.net  Thu Jul  2 15:47:44 2009
From: David Brownell <david-b@pacbell.net>
Date: Wed, 1 Jul 2009 03:36:16 -0700
Subject: USB: musb: silence "suspend as a_wait_vrise is_active" msgs
To: Greg KH <greg@kroah.com>
Cc: linux-usb@vger.kernel.org
Message-ID: <200907010336.16890.david-b@pacbell.net>
Content-Disposition: inline


From: David Brownell <dbrownell@users.sourceforge.net>

Get rid of some obnoxious and inappropriate messaging, mostly on
DaVinci, when usbcore tries to autosuspend a root hub if just a
mini/micro-A connector is connected.  Symptom: endless stream of
messages reading like:

 musb_bus_suspend 2221: trying to suspend as a_wait_vrise is_active=1

Improve that musb bus suspend primitive a bit.  Take advantage of
this call to update the OTG state machine if appropriate, moving
the device out of the A_WAIT_VRISE state.  There's basically no
timer for that state transition just now, except with tusb6010;
that can make trouble.

Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/musb/davinci.c   |    5 +++--
 drivers/usb/musb/musb_host.c |   25 +++++++++++++++++++++----
 2 files changed, 24 insertions(+), 6 deletions(-)

--- a/drivers/usb/musb/davinci.c
+++ b/drivers/usb/musb/davinci.c
@@ -330,7 +330,6 @@ static irqreturn_t davinci_interrupt(int
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 			WARNING("VBUS error workaround (delay coming)\n");
 		} else if (is_host_enabled(musb) && drvvbus) {
-			musb->is_active = 1;
 			MUSB_HST_MODE(musb);
 			musb->xceiv->default_a = 1;
 			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
@@ -344,7 +343,9 @@ static irqreturn_t davinci_interrupt(int
 			portstate(musb->port1_status &= ~USB_PORT_STAT_POWER);
 		}
 
-		/* NOTE:  this must complete poweron within 100 msec */
+		/* NOTE:  this must complete poweron within 100 msec
+		 * (OTG_TIME_A_WAIT_VRISE) but we don't check for that.
+		 */
 		davinci_source_power(musb, drvvbus, 0);
 		DBG(2, "VBUS %s (%s)%s, devctl %02x\n",
 				drvvbus ? "on" : "off",
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -2235,13 +2235,30 @@ static void musb_h_stop(struct usb_hcd *
 static int musb_bus_suspend(struct usb_hcd *hcd)
 {
 	struct musb	*musb = hcd_to_musb(hcd);
+	u8		devctl;
 
-	if (musb->xceiv->state == OTG_STATE_A_SUSPEND)
+	if (!is_host_active(musb))
 		return 0;
 
-	if (is_host_active(musb) && musb->is_active) {
-		WARNING("trying to suspend as %s is_active=%i\n",
-			otg_state_string(musb), musb->is_active);
+	switch (musb->xceiv->state) {
+	case OTG_STATE_A_SUSPEND:
+		return 0;
+	case OTG_STATE_A_WAIT_VRISE:
+		/* ID could be grounded even if there's no device
+		 * on the other end of the cable.  NOTE that the
+		 * A_WAIT_VRISE timers are messy with MUSB...
+		 */
+		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+		if ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)
+			musb->xceiv->state = OTG_STATE_A_WAIT_BCON;
+		break;
+	default:
+		break;
+	}
+
+	if (musb->is_active) {
+		WARNING("trying to suspend as %s while active\n",
+				otg_state_string(musb));
 		return -EBUSY;
 	} else
 		return 0;
