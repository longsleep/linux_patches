From sarah.a.sharp@linux.intel.com  Fri Oct  9 10:38:36 2009
From: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date: Mon, 28 Sep 2009 17:21:37 -0700
Subject: USB: xhci: Handle canceled URBs when HC dies.
To: Greg KH <gregkh@suse.de>
Cc: Oliver Neukum <oliver@neukum.org>, linux-usb@vger.kernel.org
Message-ID: <20090929002137.GA7755@gamba.jf.intel.com>
Content-Disposition: inline


When the host controller dies (e.g. it is removed from a PCI card slot),
the xHCI driver cannot expect commands to complete.  The buggy code this
patch fixes would mark an URB as canceled and then expect the URB to be
completed when the stop endpoint command completed.  That would never
happen if the host controller was dead, so the USB core would just hang in
the disconnect code.

If the host controller died, and the driver asks to cancel an URB, free
any structures associated with that URB and immediately give it back.

Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/xhci-hcd.c |   12 ++++++++++++
 1 file changed, 12 insertions(+)

--- a/drivers/usb/host/xhci-hcd.c
+++ b/drivers/usb/host/xhci-hcd.c
@@ -782,6 +782,7 @@ int xhci_urb_dequeue(struct usb_hcd *hcd
 {
 	unsigned long flags;
 	int ret;
+	u32 temp;
 	struct xhci_hcd *xhci;
 	struct xhci_td *td;
 	unsigned int ep_index;
@@ -794,6 +795,17 @@ int xhci_urb_dequeue(struct usb_hcd *hcd
 	ret = usb_hcd_check_unlink_urb(hcd, urb, status);
 	if (ret || !urb->hcpriv)
 		goto done;
+	temp = xhci_readl(xhci, &xhci->op_regs->status);
+	if (temp == 0xffffffff) {
+		xhci_dbg(xhci, "HW died, freeing TD.\n");
+		td = (struct xhci_td *) urb->hcpriv;
+
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+		spin_unlock_irqrestore(&xhci->lock, flags);
+		usb_hcd_giveback_urb(xhci_to_hcd(xhci), urb, -ESHUTDOWN);
+		kfree(td);
+		return ret;
+	}
 
 	xhci_dbg(xhci, "Cancel URB %p\n", urb);
 	xhci_dbg(xhci, "Event ring:\n");
