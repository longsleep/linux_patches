From david.vrabel@csr.com  Tue Apr  7 11:46:43 2009
From: David Vrabel <david.vrabel@csr.com>
Date: Tue,  7 Apr 2009 17:31:58 +0000
Subject: USB: whci-hcd: check return value of usb_hcd_link_urb_to_ep()
To: Greg KH <gregkh@suse.de>
Cc: linux-usb@vger.kernel.org, David Vrabel <david.vrabel@csr.com>
Message-ID: <1239125532-25158-4-git-send-email-david.vrabel@csr.com>


Check the return value of usb_hcd_link_urb_to_ep() and do not add the
urb to the ASL/PZL if it returns an error.

Omitting the check results in urbs that appear to be submitted successfully
but then cannot be unliked (because usb_hcd_check_unlink_urb() returns an
error).  This can cause khubd (for example) to block forever in
usb_kill_urb().

Signed-off-by: David Vrabel <david.vrabel@csr.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/whci/asl.c |   12 +++++++++---
 drivers/usb/host/whci/pzl.c |   12 +++++++++---
 2 files changed, 18 insertions(+), 6 deletions(-)

--- a/drivers/usb/host/whci/asl.c
+++ b/drivers/usb/host/whci/asl.c
@@ -255,23 +255,29 @@ int asl_urb_enqueue(struct whc *whc, str
 
 	spin_lock_irqsave(&whc->lock, flags);
 
+	err = usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);
+	if (err < 0) {
+		spin_unlock_irqrestore(&whc->lock, flags);
+		return err;
+	}
+
 	qset = get_qset(whc, urb, GFP_ATOMIC);
 	if (qset == NULL)
 		err = -ENOMEM;
 	else
 		err = qset_add_urb(whc, qset, urb, GFP_ATOMIC);
 	if (!err) {
-		usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);
 		if (!qset->in_sw_list)
 			asl_qset_insert_begin(whc, qset);
-	}
+	} else
+		usb_hcd_unlink_urb_from_ep(&whc->wusbhc.usb_hcd, urb);
 
 	spin_unlock_irqrestore(&whc->lock, flags);
 
 	if (!err)
 		queue_work(whc->workqueue, &whc->async_work);
 
-	return 0;
+	return err;
 }
 
 /**
--- a/drivers/usb/host/whci/pzl.c
+++ b/drivers/usb/host/whci/pzl.c
@@ -283,23 +283,29 @@ int pzl_urb_enqueue(struct whc *whc, str
 
 	spin_lock_irqsave(&whc->lock, flags);
 
+	err = usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);
+	if (err < 0) {
+		spin_unlock_irqrestore(&whc->lock, flags);
+		return err;
+	}
+
 	qset = get_qset(whc, urb, GFP_ATOMIC);
 	if (qset == NULL)
 		err = -ENOMEM;
 	else
 		err = qset_add_urb(whc, qset, urb, GFP_ATOMIC);
 	if (!err) {
-		usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);
 		if (!qset->in_sw_list)
 			qset_insert_in_sw_list(whc, qset);
-	}
+	} else
+		usb_hcd_unlink_urb_from_ep(&whc->wusbhc.usb_hcd, urb);
 
 	spin_unlock_irqrestore(&whc->lock, flags);
 
 	if (!err)
 		queue_work(whc->workqueue, &whc->periodic_work);
 
-	return 0;
+	return err;
 }
 
 /**
