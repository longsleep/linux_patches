From felipe.balbi@nokia.com  Fri Oct 31 09:58:18 2008
From: Felipe Balbi <felipe.balbi@nokia.com>
Date: Wed, 29 Oct 2008 15:10:37 +0200
Subject: usb: musb: Fix for kernel panic with multiple bulk transfer
To: linux-usb@vger.kernel.org
Cc: Greg Kroah-Hartman <gregkh@suse.de>, Ajay Kumar Gupta <ajay.gupta@ti.com>, Romit Dasgupta <romit@ti.com>, Felipe Balbi <felipe.balbi@nokia.com>
Message-ID: <1225285839-3085-8-git-send-email-felipe.balbi@nokia.com>


From: Ajay Kumar Gupta <ajay.gupta@ti.com>

Fixes kernel panic when multiple copy is performed among more than two mass
storage media and transfer is aborted. musb_advance_schedule(),
musb_urb_dequeue(), musb_cleanup_urb() and musb_h_disable() functions have
been modified to correct urb handling associated with bulk and control
endpoints which are multiplexed on one hardware endpoint.

musb_advance_schedule() has been removed from musb_cleanup_urb() and added
to musb_urb_dequeue(). musb_h_disable() has been modified to take care of
multiple qh on same hw_ep scenario.

Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Romit Dasgupta <romit@ti.com>
Signed-off-by: Felipe Balbi <felipe.balbi@nokia.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/musb/musb_host.c |  110 ++++++++++++++++++++++++++++++++-----------
 1 file changed, 82 insertions(+), 28 deletions(-)

--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -431,8 +431,18 @@ musb_advance_schedule(struct musb *musb,
 		qh = musb_giveback(qh, urb, 0);
 	else
 		qh = musb_giveback(qh, urb, urb->status);
+	while (qh && qh->is_ready && qh->hep &&
+			 list_empty(&qh->hep->urb_list)) {
+		struct list_head *head;
+		head = qh->ring.prev;
+		list_del(&qh->ring);
+		qh->hep->hcpriv = NULL;
+		kfree(qh);
+		qh = first_qh(head);
+	}
+
 
-	if (qh && qh->is_ready && !list_empty(&qh->hep->urb_list)) {
+	if (qh && qh->is_ready) {
 		DBG(4, "... next ep%d %cX urb %p\n",
 				hw_ep->epnum, is_in ? 'R' : 'T',
 				next_urb(qh));
@@ -2019,8 +2029,6 @@ static int musb_cleanup_urb(struct urb *
 		/* flush cpu writebuffer */
 		csr = musb_readw(epio, MUSB_TXCSR);
 	}
-	if (status == 0)
-		musb_advance_schedule(ep->musb, urb, ep, is_in);
 	return status;
 }
 
@@ -2083,13 +2091,27 @@ static int musb_urb_dequeue(struct usb_h
 	/* NOTE:  qh is invalid unless !list_empty(&hep->urb_list) */
 	if (ret < 0 || (sched && qh != first_qh(sched))) {
 		int	ready = qh->is_ready;
-
+		int 	type = urb->pipe;
 		ret = 0;
 		qh->is_ready = 0;
 		__musb_giveback(musb, urb, 0);
-		qh->is_ready = ready;
-	} else
+
+		if (qh->hep && list_empty(&qh->hep->urb_list) &&
+			 list_empty(&qh->ring))
+			list_del(&qh->ring);
+		else
+			qh->is_ready = ready;
+		if (usb_pipeisoc(type) && usb_pipein(type))
+			musb->in[qh->hw_ep->epnum] = NULL;
+		else if (usb_pipeisoc(type) && usb_pipeout(type))
+			musb->out[qh->hw_ep->epnum] = NULL;
+	} else {
 		ret = musb_cleanup_urb(urb, qh, urb->pipe & USB_DIR_IN);
+		if (!ret) {
+			musb_advance_schedule(qh->hw_ep->musb, urb, qh->hw_ep,
+					urb->pipe & USB_DIR_IN);
+		}
+	}
 done:
 	spin_unlock_irqrestore(&musb->lock, flags);
 	return ret;
@@ -2103,14 +2125,17 @@ musb_h_disable(struct usb_hcd *hcd, stru
 	unsigned long		flags;
 	struct musb		*musb = hcd_to_musb(hcd);
 	u8			is_in = epnum & USB_DIR_IN;
-	struct musb_qh		*qh = hep->hcpriv;
+	struct musb_qh		*qh, *qh_for_curr_urb;
 	struct urb		*urb, *tmp;
 	struct list_head	*sched;
-
-	if (!qh)
-		return;
+	int			i;
 
 	spin_lock_irqsave(&musb->lock, flags);
+	qh = hep->hcpriv;
+	if (!qh) {
+		spin_unlock_irqrestore(&musb->lock, flags);
+		return;
+	}
 
 	switch (qh->type) {
 	case USB_ENDPOINT_XFER_CONTROL:
@@ -2124,6 +2149,13 @@ musb_h_disable(struct usb_hcd *hcd, stru
 				sched = &musb->out_bulk;
 			break;
 		}
+	case USB_ENDPOINT_XFER_ISOC:
+	case USB_ENDPOINT_XFER_INT:
+		for (i = 1; i < musb->nr_endpoints; i++) {
+			if ((musb->in[i] == qh) || (musb->out[i] == qh))
+				sched = &qh->ring;
+			break;
+		}
 	default:
 		/* REVISIT when we get a schedule tree, periodic transfers
 		 * won't always be at the head of a singleton queue...
@@ -2132,26 +2164,48 @@ musb_h_disable(struct usb_hcd *hcd, stru
 		break;
 	}
 
-	/* NOTE:  qh is invalid unless !list_empty(&hep->urb_list) */
-
 	/* kick first urb off the hardware, if needed */
-	qh->is_ready = 0;
-	if (!sched || qh == first_qh(sched)) {
+	if (sched) {
+		qh_for_curr_urb = qh;
 		urb = next_urb(qh);
-
-		/* make software (then hardware) stop ASAP */
-		if (!urb->unlinked)
-			urb->status = -ESHUTDOWN;
-
-		/* cleanup */
-		musb_cleanup_urb(urb, qh, urb->pipe & USB_DIR_IN);
-	} else
-		urb = NULL;
-
-	/* then just nuke all the others */
-	list_for_each_entry_safe_from(urb, tmp, &hep->urb_list, urb_list)
-		musb_giveback(qh, urb, -ESHUTDOWN);
-
+		if (urb) {
+			/* make software (then hardware) stop ASAP */
+			if (!urb->unlinked)
+				urb->status = -ESHUTDOWN;
+			/* cleanup first urb of first qh; */
+			if (qh == first_qh(sched)) {
+				musb_cleanup_urb(urb, qh,
+					urb->pipe & USB_DIR_IN);
+			}
+			qh = musb_giveback(qh, urb, -ESHUTDOWN);
+			if (qh == qh_for_curr_urb) {
+				list_for_each_entry_safe_from(urb, tmp,
+					&hep->urb_list, urb_list) {
+					qh = musb_giveback(qh, tmp, -ESHUTDOWN);
+					if (qh != qh_for_curr_urb)
+						break;
+				}
+			}
+		}
+		/* pick the next candidate and go */
+		if (qh && qh->is_ready) {
+			while (qh && qh->is_ready && qh->hep &&
+				list_empty(&qh->hep->urb_list)) {
+					struct list_head *head;
+					head = qh->ring.prev;
+					list_del(&qh->ring);
+					qh->hep->hcpriv = NULL;
+					kfree(qh);
+					qh = first_qh(head);
+			}
+			if (qh && qh->is_ready && qh->hep &&
+				qh_for_curr_urb == first_qh(sched)) {
+				epnum = qh->hep->desc.bEndpointAddress;
+				is_in = epnum & USB_DIR_IN;
+				musb_start_urb(musb, is_in, qh);
+			}
+		}
+	}
 	spin_unlock_irqrestore(&musb->lock, flags);
 }
 
