From foo@baz Mon Aug 19 12:48:43 PDT 2013
Date: Mon, 19 Aug 2013 12:48:43 -0700
To: Greg KH <gregkh@linuxfoundation.org>
From: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Subject: [PATCH]: serial: 8250_pci: add support for Fintek 4, 8, and 12 port cards

This adds support for Fintek's 4, 8, and 12 port PCIE serial cards.

Thanks to Fintek for the sample devices, and the spec needed in order to
implement this.


Cc: Amanda Ying <amanda_ying@fintek.com.tw>
Cc: Felix Shih <felix_shih@fintek.com.tw>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>


---
 drivers/tty/serial/8250/8250_pci.c |  114 +++++++++++++++++++++++++++++++++++--
 1 file changed, 108 insertions(+), 6 deletions(-)

--- a/drivers/tty/serial/8250/8250_pci.c
+++ b/drivers/tty/serial/8250/8250_pci.c
@@ -9,6 +9,7 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License.
  */
+#define DEBUG
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/pci.h>
@@ -27,7 +28,6 @@
 
 #include "8250.h"
 
-#undef SERIAL_DEBUG_PCI
 
 /*
  * init function returns:
@@ -1344,6 +1344,60 @@ pci_brcm_trumanage_setup(struct serial_p
 	return ret;
 }
 
+static int pci_fintek_setup(struct serial_private *priv,
+			    const struct pciserial_board *board,
+			    struct uart_8250_port *port, int idx)
+{
+	unsigned long base;
+	unsigned long iobase;
+	unsigned long ciobase = 0;
+
+	/* FIXME: read these from the PCI config space */
+	switch (idx) {
+	case 0: iobase = 0xe000; break;
+	case 1: iobase = 0xe008; break;
+	case 2: iobase = 0xe010; break;
+	case 3: iobase = 0xe018; break;
+	case 4: iobase = 0xe020; break;
+	case 5: iobase = 0xe028; break;
+	case 6: iobase = 0xe030; break;
+	case 7: iobase = 0xe038; break;
+	case 8: iobase = 0xe040; break;
+	case 9: iobase = 0xe048; break;
+	case 10: iobase = 0xe050; break;
+	case 11: iobase = 0xe058; break;
+	default:
+		/* Unknown number of ports, get out of here */
+		return -EINVAL;
+	}
+
+	dev_dbg(&priv->dev->dev, "bar 0 = %lx\n", (unsigned long)pci_resource_start(priv->dev, 0));
+	dev_dbg(&priv->dev->dev, "bar 1 = %lx\n", (unsigned long)pci_resource_start(priv->dev, 1));
+	dev_dbg(&priv->dev->dev, "bar 2 = %lx\n", (unsigned long)pci_resource_start(priv->dev, 2));
+	dev_dbg(&priv->dev->dev, "bar 3 = %lx\n", (unsigned long)pci_resource_start(priv->dev, 3));
+	dev_dbg(&priv->dev->dev, "bar 4 = %lx\n", (unsigned long)pci_resource_start(priv->dev, 4));
+	dev_dbg(&priv->dev->dev, "bar 5 = %lx\n", (unsigned long)pci_resource_start(priv->dev, 5));
+	dev_dbg(&priv->dev->dev, "bar 6 = %lx\n", (unsigned long)pci_resource_start(priv->dev, 6));
+
+	if (idx < 4) {
+		base = pci_resource_start(priv->dev, 3);
+		ciobase = (int)(base + (0x8 * idx));
+	}
+
+	dev_dbg(&priv->dev->dev, "%s: iobase=%lx ciobase=%lx\n", __func__, iobase, ciobase);
+
+	port->port.iotype = UPIO_PORT;
+	port->port.iobase = iobase;
+	port->port.mapbase = 0;
+	port->port.membase = NULL;
+	port->port.regshift = 0;
+
+	dev_dbg(&priv->dev->dev, "%s: idx=%d iobase=%lx\n",
+		__func__, idx, iobase);
+
+	return 0;
+}
+
 static int skip_tx_en_setup(struct serial_private *priv,
 			const struct pciserial_board *board,
 			struct uart_8250_port *port, int idx)
@@ -2255,6 +2309,27 @@ static struct pci_serial_quirk pci_seria
 		.subdevice	= PCI_ANY_ID,
 		.setup		= pci_brcm_trumanage_setup,
 	},
+	{
+		.vendor		= 0x1c29,
+		.device		= 0x1104,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.setup		= pci_fintek_setup,
+	},
+	{
+		.vendor		= 0x1c29,
+		.device		= 0x1108,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.setup		= pci_fintek_setup,
+	},
+	{
+		.vendor		= 0x1c29,
+		.device		= 0x1112,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.setup		= pci_fintek_setup,
+	},
 
 	/*
 	 * Default "match everything" terminator entry
@@ -2452,6 +2527,9 @@ enum pci_board_num_t {
 	pbn_omegapci,
 	pbn_NETMOS9900_2s_115200,
 	pbn_brcm_trumanage,
+	pbn_fintek_4,
+	pbn_fintek_8,
+	pbn_fintek_12,
 };
 
 /*
@@ -3202,6 +3280,24 @@ static struct pciserial_board pci_boards
 		.reg_shift	= 2,
 		.base_baud	= 115200,
 	},
+	[pbn_fintek_4] = {
+		.num_ports	= 4,
+		.uart_offset	= 8,
+		.base_baud	= 115200,
+		.first_offset	= 0x40,
+	},
+	[pbn_fintek_8] = {
+		.num_ports	= 8,
+		.uart_offset	= 8,
+		.base_baud	= 115200,
+		.first_offset	= 0x40,
+	},
+	[pbn_fintek_12] = {
+		.num_ports	= 12,
+		.uart_offset	= 8,
+		.base_baud	= 115200,
+		.first_offset	= 0x40,
+	},
 };
 
 static const struct pci_device_id blacklist[] = {
@@ -3362,14 +3458,15 @@ pciserial_init_ports(struct pci_dev *dev
 		if (quirk->setup(priv, board, &uart, i))
 			break;
 
-#ifdef SERIAL_DEBUG_PCI
-		printk(KERN_DEBUG "Setup PCI port: port %lx, irq %d, type %d\n",
-		       uart.port.iobase, uart.port.irq, uart.port.iotype);
-#endif
+		dev_dbg(&dev->dev, "Setup PCI port: port %lx, irq %d, type %d\n",
+			uart.port.iobase, uart.port.irq, uart.port.iotype);
 
 		priv->line[i] = serial8250_register_8250_port(&uart);
 		if (priv->line[i] < 0) {
-			printk(KERN_WARNING "Couldn't register serial port %s: %d\n", pci_name(dev), priv->line[i]);
+			dev_err(&dev->dev,
+				"Couldn't register serial port %lx, irq %d, type %d, error %d\n",
+				uart.port.iobase, uart.port.irq,
+				uart.port.iotype, priv->line[i]);
 			break;
 		}
 	}
@@ -4918,6 +5015,11 @@ static struct pci_device_id serial_pci_t
 		0,
 		0, pbn_exar_XR17V358 },
 
+	/* Fintek PCI serial cards */
+	{ PCI_DEVICE(0x1c29, 0x1104), .driver_data = pbn_fintek_4 },
+	{ PCI_DEVICE(0x1c29, 0x1108), .driver_data = pbn_fintek_8 },
+	{ PCI_DEVICE(0x1c29, 0x1112), .driver_data = pbn_fintek_12 },
+
 	/*
 	 * These entries match devices with class COMMUNICATION_SERIAL,
 	 * COMMUNICATION_MODEM or COMMUNICATION_MULTISERIAL
