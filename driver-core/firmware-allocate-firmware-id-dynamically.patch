From sameo@linux.intel.com  Tue Jun  2 14:49:19 2009
From: Samuel Ortiz <sameo@linux.intel.com>
Date: Wed, 27 May 2009 00:49:31 +0200
Subject: firmware: allocate firmware id dynamically
To: Greg Kroah-Hartmann <greg@kroah.com>, Andrew Morton <akpm@linux-foundation.org>
Cc: Kay Sievers <kay.sievers@vrfy.org>, Samuel Ortiz <sameo@linux.intel.com>, Marcel Holtmann <holtmann@linux.intel.com>, Zhu Yi <yi.zhu@intel.com>, John Linville <linville@tuxdriver.com>
Message-ID: <20090526225120.078277700@linux.intel.com>


From: Samuel Ortiz <sameo@linux.intel.com>

The firmware loader has a statically allocated 30 bytes long string for
the firmware id (a.k.a. the firmware file name). There is no reason why
we couldnt allocate it dynamically, and avoid having restrictions on the
firmware names lengths.

Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
Cc: Marcel Holtmann <holtmann@linux.intel.com>
Cc: Zhu Yi <yi.zhu@intel.com>,
Cc: John Linville <linville@tuxdriver.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/base/firmware_class.c |   16 ++++++++++++----
 1 file changed, 12 insertions(+), 4 deletions(-)

--- a/drivers/base/firmware_class.c
+++ b/drivers/base/firmware_class.c
@@ -40,7 +40,7 @@ static int loading_timeout = 60;	/* In s
 static DEFINE_MUTEX(fw_lock);
 
 struct firmware_priv {
-	char fw_id[FIRMWARE_NAME_MAX];
+	char *fw_id;
 	struct completion completion;
 	struct bin_attribute attr_data;
 	struct firmware *fw;
@@ -355,6 +355,7 @@ static void fw_dev_release(struct device
 	for (i = 0; i < fw_priv->nr_pages; i++)
 		__free_page(fw_priv->pages[i]);
 	kfree(fw_priv->pages);
+	kfree(fw_priv->fw_id);
 	kfree(fw_priv);
 	put_device(dev);
 
@@ -386,7 +387,13 @@ static int fw_register_device(struct dev
 
 	init_completion(&fw_priv->completion);
 	fw_priv->attr_data = firmware_attr_data_tmpl;
-	strlcpy(fw_priv->fw_id, fw_name, FIRMWARE_NAME_MAX);
+	fw_priv->fw_id = kstrdup(fw_name, GFP_KERNEL);
+	if (!fw_priv->fw_id) {
+		dev_err(device, "%s: Firmware name allocation failed\n",
+			__func__);
+		retval = -ENOMEM;
+		goto error_kfree;
+	}
 
 	fw_priv->timeout.function = firmware_class_timeout;
 	fw_priv->timeout.data = (u_long) fw_priv;
@@ -401,14 +408,15 @@ static int fw_register_device(struct dev
 	if (retval) {
 		dev_err(device, "%s: device_register failed\n", __func__);
 		put_device(f_dev);
-		goto error_kfree1;
+		goto error_kfree_fw_id;
 	}
 	*dev_p = f_dev;
 	return 0;
 
+error_kfree_fw_id:
+	kfree(fw_priv->fw_id);
 error_kfree:
 	kfree(f_dev);
-error_kfree1:
 	kfree(fw_priv);
 	return retval;
 }
