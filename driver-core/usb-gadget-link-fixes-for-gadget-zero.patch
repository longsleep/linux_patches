From david-b@pacbell.net  Wed Aug 20 13:17:09 2008
From: David Brownell <david-b@pacbell.net>
Date: Mon, 18 Aug 2008 17:41:31 -0700
Subject: usb gadget: link fixes for gadget zero
To: Greg KH <greg@kroah.com>
Cc: linux-usb@vger.kernel.org
Message-ID: <200808181741.31169.david-b@pacbell.net>
Content-Disposition: inline


From: David Brownell <dbrownell@users.sourceforge.net>

Change how the Gadget Zero driver builds:  don't use
separate compilation, since it works poorly when key
parts are library code (with init sections etc).
Instead be as close as we can to "gcc --combine ...".

Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/gadget/Makefile     |    2 +-
 drivers/usb/gadget/f_loopback.c |   34 ++++++++++++++++++----------------
 drivers/usb/gadget/zero.c       |   17 +++++++++++++++++
 3 files changed, 36 insertions(+), 17 deletions(-)

--- a/drivers/usb/gadget/f_loopback.c
+++ b/drivers/usb/gadget/f_loopback.c
@@ -70,7 +70,7 @@ static struct usb_interface_descriptor l
 
 /* full speed support: */
 
-static struct usb_endpoint_descriptor fs_source_desc = {
+static struct usb_endpoint_descriptor fs_loop_source_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -78,7 +78,7 @@ static struct usb_endpoint_descriptor fs
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
-static struct usb_endpoint_descriptor fs_sink_desc = {
+static struct usb_endpoint_descriptor fs_loop_sink_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -88,14 +88,14 @@ static struct usb_endpoint_descriptor fs
 
 static struct usb_descriptor_header *fs_loopback_descs[] = {
 	(struct usb_descriptor_header *) &loopback_intf,
-	(struct usb_descriptor_header *) &fs_sink_desc,
-	(struct usb_descriptor_header *) &fs_source_desc,
+	(struct usb_descriptor_header *) &fs_loop_sink_desc,
+	(struct usb_descriptor_header *) &fs_loop_source_desc,
 	NULL,
 };
 
 /* high speed support: */
 
-static struct usb_endpoint_descriptor hs_source_desc = {
+static struct usb_endpoint_descriptor hs_loop_source_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -103,7 +103,7 @@ static struct usb_endpoint_descriptor hs
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
-static struct usb_endpoint_descriptor hs_sink_desc = {
+static struct usb_endpoint_descriptor hs_loop_sink_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
@@ -113,8 +113,8 @@ static struct usb_endpoint_descriptor hs
 
 static struct usb_descriptor_header *hs_loopback_descs[] = {
 	(struct usb_descriptor_header *) &loopback_intf,
-	(struct usb_descriptor_header *) &hs_source_desc,
-	(struct usb_descriptor_header *) &hs_sink_desc,
+	(struct usb_descriptor_header *) &hs_loop_source_desc,
+	(struct usb_descriptor_header *) &hs_loop_sink_desc,
 	NULL,
 };
 
@@ -152,7 +152,7 @@ loopback_bind(struct usb_configuration *
 
 	/* allocate endpoints */
 
-	loop->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_source_desc);
+	loop->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_source_desc);
 	if (!loop->in_ep) {
 autoconf_fail:
 		ERROR(cdev, "%s: can't autoconfigure on %s\n",
@@ -161,17 +161,17 @@ autoconf_fail:
 	}
 	loop->in_ep->driver_data = cdev;	/* claim */
 
-	loop->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_sink_desc);
+	loop->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_sink_desc);
 	if (!loop->out_ep)
 		goto autoconf_fail;
 	loop->out_ep->driver_data = cdev;	/* claim */
 
 	/* support high speed hardware */
 	if (gadget_is_dualspeed(c->cdev->gadget)) {
-		hs_source_desc.bEndpointAddress =
-				fs_source_desc.bEndpointAddress;
-		hs_sink_desc.bEndpointAddress =
-				fs_sink_desc.bEndpointAddress;
+		hs_loop_source_desc.bEndpointAddress =
+				fs_loop_source_desc.bEndpointAddress;
+		hs_loop_sink_desc.bEndpointAddress =
+				fs_loop_sink_desc.bEndpointAddress;
 		f->hs_descriptors = hs_loopback_descs;
 	}
 
@@ -255,8 +255,10 @@ enable_loopback(struct usb_composite_dev
 	struct usb_request			*req;
 	unsigned				i;
 
-	src = ep_choose(cdev->gadget, &hs_source_desc, &fs_source_desc);
-	sink = ep_choose(cdev->gadget, &hs_sink_desc, &fs_sink_desc);
+	src = ep_choose(cdev->gadget,
+			&hs_loop_source_desc, &fs_loop_source_desc);
+	sink = ep_choose(cdev->gadget,
+			&hs_loop_sink_desc, &fs_loop_sink_desc);
 
 	/* one endpoint writes data back IN to the host */
 	ep = loop->in_ep;
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -24,7 +24,7 @@ obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
 #
 C_UTILS =	composite.o usbstring.o config.o epautoconf.o
 
-g_zero-objs			:= zero.o f_sourcesink.o f_loopback.o $(C_UTILS)
+g_zero-objs			:= zero.o
 g_ether-objs			:= ether.o u_ether.o f_subset.o f_ecm.o $(C_UTILS)
 g_serial-objs			:= serial.o
 g_midi-objs			:= gmidi.o usbstring.o config.o epautoconf.o
--- a/drivers/usb/gadget/zero.c
+++ b/drivers/usb/gadget/zero.c
@@ -59,6 +59,23 @@
 
 /*-------------------------------------------------------------------------*/
 
+/*
+ * Kbuild is not very cooperative with respect to linking separately
+ * compiled library objects into one module.  So for now we won't use
+ * separate compilation ... ensuring init/exit sections work to shrink
+ * the runtime footprint, and giving us at least some parts of what
+ * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
+ */
+#include "composite.c"
+#include "usbstring.c"
+#include "config.c"
+#include "epautoconf.c"
+
+#include "f_sourcesink.c"
+#include "f_loopback.c"
+
+/*-------------------------------------------------------------------------*/
+
 #define DRIVER_VERSION		"Cinco de Mayo 2008"
 
 static const char longname[] = "Gadget Zero";
