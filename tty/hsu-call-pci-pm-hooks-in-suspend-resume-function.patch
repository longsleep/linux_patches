From alan@linux.intel.com  Tue Jul 27 09:43:07 2010
From: Alan Cox <alan@linux.intel.com>
Subject: hsu: call PCI pm hooks in suspend/resume function
To: greg@kroah.com, linux-serial@vger.kernel.org
Date: Tue, 27 Jul 2010 08:20:52 +0100
Message-ID: <20100727072049.26058.35014.stgit@localhost.localdomain>

From: Feng Tang <feng.tang@intel.com>

Also add check for dma controller or the uart ports.

Signed-off-by: Feng Tang <feng.tang@intel.com>
Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/serial/mfd.c |   31 ++++++++++++++++++++++---------
 1 file changed, 22 insertions(+), 9 deletions(-)

--- a/drivers/serial/mfd.c
+++ b/drivers/serial/mfd.c
@@ -1217,25 +1217,38 @@ static struct uart_driver serial_hsu_reg
 #ifdef CONFIG_PM
 static int serial_hsu_suspend(struct pci_dev *pdev, pm_message_t state)
 {
+	void *priv = pci_get_drvdata(pdev);
 	struct uart_hsu_port *up;
 
-	up = pci_get_drvdata(pdev);
-	if (!up)
-		return 0;
-
-	uart_suspend_port(&serial_hsu_reg, &up->port);
+	/* Make sure this is not the internal dma controller */
+	if (priv && (pdev->device != 0x081E)) {
+		up = priv;
+		uart_suspend_port(&serial_hsu_reg, &up->port);
+	}
 
+	pci_save_state(pdev);
+	pci_set_power_state(pdev, pci_choose_state(pdev, state));
         return 0;
 }
 
 static int serial_hsu_resume(struct pci_dev *pdev)
 {
+	void *priv = pci_get_drvdata(pdev);
 	struct uart_hsu_port *up;
+	int ret;
+
+	pci_set_power_state(pdev, PCI_D0);
+	pci_restore_state(pdev);
+
+	ret = pci_enable_device(pdev);
+	if (ret)
+		dev_warn(&pdev->dev,
+			"HSU: can't re-enable device, try to continue\n");
 
-	up = pci_get_drvdata(pdev);
-	if (!up)
-		return 0;
-	uart_resume_port(&serial_hsu_reg, &up->port);
+	if (priv && (pdev->device != 0x081E)) {
+		up = priv;
+		uart_resume_port(&serial_hsu_reg, &up->port);
+	}
 	return 0;
 }
 #else
