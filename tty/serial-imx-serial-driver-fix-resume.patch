From daniel@caiaq.de  Thu Oct  7 10:49:08 2010
From: Volker Ernst <volker.ernst@txtr.com>
To: linux-arm-kernel@lists.infradead.org
Cc: gregkh@suse.de, akpm@linux-foundation.org,
	s.hauer@pengutronix.de, Volker Ernst <volker.ernst@txtr.com>,
	Daniel Mack <daniel@caiaq.de>, Andy Green <andy@warmcat.com>
Subject: serial: imx serial driver: fix resume
Date: Wed,  6 Oct 2010 18:57:16 +0200
Message-Id: <1286384236-4241-1-git-send-email-daniel@caiaq.de>

From: Volker Ernst <volker.ernst@txtr.com>

I just came across a bug in the IMX31 serial driver which is still
present in the newest kernels and which prevents successful
resume-operation for the IMX31 serial ports.

What happens is that in "drivers/serial/imx.c" on resume function
"serial_imx_resume" gets called. This function in turn calls
"uart_resume_port" (in the generic serial driver "serial_core.c"),
which in turn calls "imx_start_tx" in "imx.c" (in case the SIO-port
was really suspended) which in turn calls "imx_transmit_buffer".

However calling "imx_transmit_buffer" with an empty TX-fifo (as is
usually the case) will result in the serial port starting to transmit
(actually the old [already sent] tx-buffer), as there is no check if
the tx-buffer is empty before starting to feed tx-fifo-data to the
serial port hardware.

Signed-off-by: Volker Ernst <volker.ernst@txtr.com>
Cc: Daniel Mack <daniel@caiaq.de>
Cc: Andy Green <andy@warmcat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/serial/imx.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

--- a/drivers/serial/imx.c
+++ b/drivers/serial/imx.c
@@ -328,13 +328,13 @@ static inline void imx_transmit_buffer(s
 	struct circ_buf *xmit = &sport->port.state->xmit;
 
 	while (!(readl(sport->port.membase + UTS) & UTS_TXFULL)) {
+		if (uart_circ_empty(xmit))
+			break;
 		/* send xmit->buf[xmit->tail]
 		 * out the port here */
 		writel(xmit->buf[xmit->tail], sport->port.membase + URTX0);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		sport->port.icount.tx++;
-		if (uart_circ_empty(xmit))
-			break;
 	}
 
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
