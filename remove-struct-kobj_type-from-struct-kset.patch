Subject: remove struct kobj_type from struct kset

We don't need a "default" ktype for a kset.  We should set this
explicitly every time for each kset.  This change is needed so that we
can make ksets dynamic, and cleans up one of the odd, undocumented
assumption that the kset/kobject/ktype model has.

This patch is based on a lot of help from Kay Sievers.


---
 drivers/acpi/bus.c                     |    2 +-
 drivers/base/bus.c                     |    5 +++--
 drivers/base/class.c                   |    8 +++++---
 drivers/base/core.c                    |    5 +++--
 drivers/base/firmware.c                |    5 +++--
 drivers/base/sys.c                     |    3 ++-
 drivers/firmware/edd.c                 |    5 +++--
 drivers/firmware/efivars.c             |    9 +++++----
 drivers/gregkh/gregkh.c                |   14 +++++++-------
 drivers/pci/hotplug/pci_hotplug_core.c |    7 ++++---
 drivers/uio/uio.c                      |    2 +-
 fs/debugfs/inode.c                     |    4 ++--
 fs/fuse/inode.c                        |    8 ++++----
 fs/namespace.c                         |    2 +-
 fs/sysfs/file.c                        |    4 +---
 include/linux/kobject.h                |   15 ++++-----------
 kernel/ksysfs.c                        |    2 +-
 kernel/params.c                        |    9 +++++----
 kernel/power/main.c                    |    2 +-
 lib/kobject.c                          |    1 -
 security/inode.c                       |    4 ++--
 21 files changed, 58 insertions(+), 58 deletions(-)

--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -737,7 +737,7 @@ static int __init acpi_bus_init(void)
 	return -ENODEV;
 }
 
-decl_subsys(acpi, NULL, NULL);
+decl_subsys(acpi, NULL);
 
 static int __init acpi_init(void)
 {
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -166,7 +166,7 @@ static struct kset_uevent_ops bus_uevent
 	.filter = bus_uevent_filter,
 };
 
-static decl_subsys(bus, &bus_ktype, &bus_uevent_ops);
+static decl_subsys(bus, &bus_uevent_ops);
 
 
 #ifdef CONFIG_HOTPLUG
@@ -639,6 +639,7 @@ int bus_add_driver(struct device_driver 
 	if (error)
 		goto out_put_bus;
 	drv->kobj.kset = &bus->drivers;
+	drv->kobj.ktype = &driver_ktype;
 	error = kobject_register(&drv->kobj);
 	if (error)
 		goto out_put_bus;
@@ -851,6 +852,7 @@ int bus_register(struct bus_type * bus)
 		goto out;
 
 	bus->subsys.kobj.kset = &bus_subsys;
+	bus->subsys.kobj.ktype = &bus_ktype;
 
 	retval = subsystem_register(&bus->subsys);
 	if (retval)
@@ -868,7 +870,6 @@ int bus_register(struct bus_type * bus)
 
 	kobject_set_name(&bus->drivers.kobj, "drivers");
 	bus->drivers.kobj.parent = &bus->subsys.kobj;
-	bus->drivers.ktype = &driver_ktype;
 	retval = kset_register(&bus->drivers);
 	if (retval)
 		goto bus_drivers_fail;
--- a/drivers/base/class.c
+++ b/drivers/base/class.c
@@ -71,7 +71,7 @@ static struct kobj_type class_ktype = {
 };
 
 /* Hotplug events for classes go to the class_obj subsys */
-static decl_subsys(class, &class_ktype, NULL);
+static decl_subsys(class, NULL);
 
 
 int class_create_file(struct class * cls, const struct class_attribute * attr)
@@ -150,6 +150,7 @@ int class_register(struct class * cls)
 		return error;
 
 	cls->subsys.kobj.kset = &class_subsys;
+	cls->subsys.kobj.ktype = &class_ktype;
 
 	error = subsystem_register(&cls->subsys);
 	if (!error) {
@@ -452,7 +453,7 @@ static struct kset_uevent_ops class_ueve
 	.uevent =	class_uevent,
 };
 
-static decl_subsys(class_obj, &class_device_ktype, &class_uevent_ops);
+static decl_subsys(class_obj, &class_uevent_ops);
 
 
 static int class_device_add_attrs(struct class_device * cd)
@@ -537,7 +538,8 @@ static struct class_device_attribute cla
 
 void class_device_initialize(struct class_device *class_dev)
 {
-	kobj_set_kset_s(class_dev, class_obj_subsys);
+	class_dev->kobj.kset = &class_obj_subsys;
+	class_dev->kobj.ktype = &class_device_ktype;
 	kobject_init(&class_dev->kobj);
 	INIT_LIST_HEAD(&class_dev->node);
 }
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -405,7 +405,7 @@ static struct device_attribute devt_attr
  *	devices_subsys - structure to be registered with kobject core.
  */
 
-decl_subsys(devices, &device_ktype, &device_uevent_ops);
+decl_subsys(devices, &device_uevent_ops);
 
 
 /**
@@ -525,7 +525,8 @@ static void klist_children_put(struct kl
 
 void device_initialize(struct device *dev)
 {
-	kobj_set_kset_s(dev, devices_subsys);
+	dev->kobj.kset = &devices_subsys;
+	dev->kobj.ktype = &device_ktype;
 	kobject_init(&dev->kobj);
 	klist_init(&dev->klist_children, klist_children_get,
 		   klist_children_put);
--- a/drivers/base/firmware.c
+++ b/drivers/base/firmware.c
@@ -15,11 +15,12 @@
 
 #include "base.h"
 
-static decl_subsys(firmware, NULL, NULL);
+static decl_subsys(firmware, NULL);
 
 int firmware_register(struct kset *s)
 {
-	kobj_set_kset_s(s, firmware_subsys);
+	s->kobj.kset = &firmware_subsys;
+	s->kobj.ktype = NULL;
 	return subsystem_register(s);
 }
 
--- a/drivers/base/sys.c
+++ b/drivers/base/sys.c
@@ -131,7 +131,7 @@ EXPORT_SYMBOL_GPL(sysdev_class_remove_fi
 /*
  * declare system_subsys
  */
-static decl_subsys(system, &ktype_sysdev_class, NULL);
+static decl_subsys(system, NULL);
 
 int sysdev_class_register(struct sysdev_class * cls)
 {
@@ -139,6 +139,7 @@ int sysdev_class_register(struct sysdev_
 		 kobject_name(&cls->kset.kobj));
 	INIT_LIST_HEAD(&cls->drivers);
 	cls->kset.kobj.parent = &system_subsys.kobj;
+	cls->kset.kobj.ktype = &ktype_sysdev_class;
 	cls->kset.kobj.kset = &system_subsys;
 	return kset_register(&cls->kset);
 }
--- a/drivers/firmware/edd.c
+++ b/drivers/firmware/edd.c
@@ -631,7 +631,7 @@ static struct kobj_type edd_ktype = {
 	.default_attrs	= def_attrs,
 };
 
-static decl_subsys(edd, &edd_ktype, NULL);
+static decl_subsys(edd, NULL);
 
 
 /**
@@ -723,7 +723,8 @@ edd_device_register(struct edd_device *e
 	edd_dev_set_info(edev, i);
 	kobject_set_name(&edev->kobj, "int13_dev%02x",
 			 0x80 + i);
-	kobj_set_kset_s(edev,edd_subsys);
+	edev->kobj.kset = &edd_subsys;
+	edev->kobj.ktype = &edd_ktype;
 	error = kobject_register(&edev->kobj);
 	if (!error)
 		edd_populate_dir(edev);
--- a/drivers/firmware/efivars.c
+++ b/drivers/firmware/efivars.c
@@ -583,8 +583,8 @@ static struct subsys_attribute *efi_subs
 	NULL,	/* maybe more in the future? */
 };
 
-static decl_subsys(vars, &efivar_ktype, NULL);
-static decl_subsys(efi, NULL, NULL);
+static decl_subsys(vars, NULL);
+static decl_subsys(efi, NULL);
 
 /*
  * efivar_create_sysfs_entry()
@@ -629,7 +629,8 @@ efivar_create_sysfs_entry(unsigned long 
 	efi_guid_unparse(vendor_guid, short_name + strlen(short_name));
 
 	kobject_set_name(&new_efivar->kobj, "%s", short_name);
-	kobj_set_kset_s(new_efivar, vars_subsys);
+	new_efivar->kobj.kset = &vars_subsys;
+	new_efivar->kobj.ktype = &efivar_ktype;
 	i = kobject_register(&new_efivar->kobj);
 	if (i) {
 		kfree(short_name);
@@ -687,7 +688,7 @@ efivars_init(void)
 		goto out_free;
 	}
 
-	kobj_set_kset_s(&vars_subsys, efi_subsys);
+	vars_subsys.kobj.kset = &efi_subsys;
 
 	error = subsystem_register(&vars_subsys);
 
--- a/drivers/gregkh/gregkh.c
+++ b/drivers/gregkh/gregkh.c
@@ -84,7 +84,7 @@ static struct kobj_type greg_ktype = {
 };
 
 
-static decl_subsys(gregkh, &greg_ktype, NULL);
+//static decl_subsys(gregkh, &greg_ktype, NULL);
 
 static struct greg *g1;
 static struct greg *g2;
@@ -247,11 +247,11 @@ static int greg_init(void)
 {
 	int error;
 
-	error = subsystem_register(&gregkh_subsys);
-	if (error) {
-		dbg("error %d\n", error);
-		return error;
-	}
+//	error = subsystem_register(&gregkh_subsys);
+//	if (error) {
+//		dbg("error %d\n", error);
+//		return error;
+//	}
 
 	g1 = kmalloc(sizeof(*g1), GFP_KERNEL);
 	memset(g1, 0x00, sizeof(*g1));
@@ -299,7 +299,7 @@ static void greg_exit(void)
 {
 	kobject_unregister(&g1->kobj);
 	kobject_unregister(&g2->kobj);
-	subsystem_unregister(&gregkh_subsys);
+//	subsystem_unregister(&gregkh_subsys);
 
 	class_destroy(greg_class);
 }
--- a/drivers/pci/hotplug/pci_hotplug_core.c
+++ b/drivers/pci/hotplug/pci_hotplug_core.c
@@ -96,7 +96,7 @@ static struct kobj_type hotplug_slot_kty
 	.release = &hotplug_slot_release,
 };
 
-decl_subsys_name(pci_hotplug_slots, slots, &hotplug_slot_ktype, NULL);
+decl_subsys_name(pci_hotplug_slots, slots, NULL);
 
 /* these strings match up with the values in pci_bus_speed */
 static char *pci_bus_speed_strings[] = {
@@ -633,7 +633,8 @@ int pci_hp_register (struct hotplug_slot
 	}
 
 	kobject_set_name(&slot->kobj, "%s", slot->name);
-	kobj_set_kset_s(slot, pci_hotplug_slots_subsys);
+	slot->kobj.kset = &pci_hotplug_slots_subsys;
+	slot->kobj.ktype = &hotplug_slot_ktype;
 
 	/* this can fail if we have already registered a slot with the same name */
 	if (kobject_register(&slot->kobj)) {
@@ -703,7 +704,7 @@ static int __init pci_hotplug_init (void
 {
 	int result;
 
-	kobj_set_kset_s(&pci_hotplug_slots_subsys, pci_bus_type.subsys);
+	pci_hotplug_slots_subsys.kobj.kset = &pci_bus_type.subsys;
 	result = subsystem_register(&pci_hotplug_slots_subsys);
 	if (result) {
 		err("Register subsys with error %d\n", result);
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -160,7 +160,7 @@ static int uio_dev_add_attributes(struct
 		if (!map_found) {
 			map_found = 1;
 			kobject_set_name(&idev->map_attr_kset.kobj,"maps");
-			idev->map_attr_kset.ktype = &map_attr_type;
+			idev->map_attr_kset.kobj.ktype = &map_attr_type;
 			idev->map_attr_kset.kobj.parent = &idev->dev->kobj;
 			ret = kset_register(&idev->map_attr_kset);
 			if (ret)
--- a/fs/debugfs/inode.c
+++ b/fs/debugfs/inode.c
@@ -426,13 +426,13 @@ exit:
 }
 EXPORT_SYMBOL_GPL(debugfs_rename);
 
-static decl_subsys(debug, NULL, NULL);
+static decl_subsys(debug, NULL);
 
 static int __init debugfs_init(void)
 {
 	int retval;
 
-	kobj_set_kset_s(&debug_subsys, kernel_subsys);
+	debug_subsys.kobj.kset = &kernel_subsys;
 	retval = subsystem_register(&debug_subsys);
 	if (retval)
 		return retval;
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -680,8 +680,8 @@ static inline void unregister_fuseblk(vo
 }
 #endif
 
-static decl_subsys(fuse, NULL, NULL);
-static decl_subsys(connections, NULL, NULL);
+static decl_subsys(fuse, NULL);
+static decl_subsys(connections, NULL);
 
 static void fuse_inode_init_once(void *foo, struct kmem_cache *cachep,
 				 unsigned long flags)
@@ -732,12 +732,12 @@ static int fuse_sysfs_init(void)
 {
 	int err;
 
-	kobj_set_kset_s(&fuse_subsys, fs_subsys);
+	fuse_subsys.kobj.kset = &fs_subsys;
 	err = subsystem_register(&fuse_subsys);
 	if (err)
 		goto out_err;
 
-	kobj_set_kset_s(&connections_subsys, fuse_subsys);
+	fuse_subsys.kobj.kset = &fuse_subsys;
 	err = subsystem_register(&connections_subsys);
 	if (err)
 		goto out_fuse_unregister;
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -41,7 +41,7 @@ static struct kmem_cache *mnt_cache __re
 static struct rw_semaphore namespace_sem;
 
 /* /sys/fs */
-decl_subsys(fs, NULL, NULL);
+decl_subsys(fs, NULL);
 EXPORT_SYMBOL_GPL(fs_subsys);
 
 static inline unsigned long hash(struct vfsmount *mnt, struct dentry *dentry)
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -375,9 +375,7 @@ static int sysfs_open_file(struct inode 
 	/* if the kobject has no ktype, then we assume that it is a subsystem
 	 * itself, and use ops for it.
 	 */
-	if (kobj->kset && kobj->kset->ktype)
-		ops = kobj->kset->ktype->sysfs_ops;
-	else if (kobj->ktype)
+	if (kobj->ktype)
 		ops = kobj->ktype->sysfs_ops;
 	else
 		ops = &subsys_sysfs_ops;
--- a/include/linux/kobject.h
+++ b/include/linux/kobject.h
@@ -128,7 +128,6 @@ struct kset_uevent_ops {
  * define the attribute callbacks and other common events that happen to
  * a kobject.
  *
- * @ktype: the struct kobj_type for this specific kset
  * @list: the list of all kobjects for this kset
  * @list_lock: a lock for iterating over the kobjects
  * @kobj: the embedded kobject for this kset (recursion, isn't it fun...)
@@ -138,7 +137,6 @@ struct kset_uevent_ops {
  * desired.
  */
 struct kset {
-	struct kobj_type	*ktype;
 	struct list_head	list;
 	spinlock_t		list_lock;
 	struct kobject		kobj;
@@ -170,12 +168,9 @@ static inline void kset_put(struct kset 
 	kobject_put(&k->kobj);
 }
 
-static inline struct kobj_type * get_ktype(struct kobject * k)
+static inline struct kobj_type *get_ktype(struct kobject *kobj)
 {
-	if (k->kset && k->kset->ktype)
-		return k->kset->ktype;
-	else 
-		return k->ktype;
+	return kobj->ktype;
 }
 
 extern struct kobject * kset_find_obj(struct kset *, const char *);
@@ -188,16 +183,14 @@ extern struct kobject * kset_find_obj(st
 #define set_kset_name(str)	.kset = { .kobj = { .k_name = str } }
 
 
-#define decl_subsys(_name,_type,_uevent_ops) \
+#define decl_subsys(_name,_uevent_ops) \
 struct kset _name##_subsys = { \
 	.kobj = { .k_name = __stringify(_name) }, \
-	.ktype = _type, \
 	.uevent_ops =_uevent_ops, \
 }
-#define decl_subsys_name(_varname,_name,_type,_uevent_ops) \
+#define decl_subsys_name(_varname,_name,_uevent_ops) \
 struct kset _varname##_subsys = { \
 	.kobj = { .k_name = __stringify(_name) }, \
-	.ktype = _type, \
 	.uevent_ops =_uevent_ops, \
 }
 
--- a/kernel/ksysfs.c
+++ b/kernel/ksysfs.c
@@ -84,7 +84,7 @@ static struct bin_attribute notes_attr =
 	.read = &notes_read,
 };
 
-decl_subsys(kernel, NULL, NULL);
+decl_subsys(kernel, NULL);
 EXPORT_SYMBOL_GPL(kernel_subsys);
 
 static struct attribute * kernel_attrs[] = {
--- a/kernel/params.c
+++ b/kernel/params.c
@@ -30,6 +30,8 @@
 #define DEBUGP(fmt, a...)
 #endif
 
+static struct kobj_type module_ktype;
+
 static inline char dash2underscore(char c)
 {
 	if (c == '-')
@@ -563,7 +565,8 @@ static void __init kernel_param_sysfs_se
 	BUG_ON(!mk);
 
 	mk->mod = THIS_MODULE;
-	kobj_set_kset_s(mk, module_subsys);
+	mk->kobj.kset = &module_subsys;
+	mk->kobj.ktype = &module_ktype;
 	kobject_set_name(&mk->kobj, name);
 	kobject_init(&mk->kobj);
 	ret = kobject_add(&mk->kobj);
@@ -679,8 +682,6 @@ static struct sysfs_ops module_sysfs_ops
 	.store = module_attr_store,
 };
 
-static struct kobj_type module_ktype;
-
 static int uevent_filter(struct kset *kset, struct kobject *kobj)
 {
 	struct kobj_type *ktype = get_ktype(kobj);
@@ -694,7 +695,7 @@ static struct kset_uevent_ops module_uev
 	.filter = uevent_filter,
 };
 
-decl_subsys(module, &module_ktype, &module_uevent_ops);
+decl_subsys(module, &module_uevent_ops);
 int module_sysfs_initialized;
 
 static struct kobj_type module_ktype = {
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -273,7 +273,7 @@ EXPORT_SYMBOL(pm_suspend);
 
 #endif /* CONFIG_SUSPEND */
 
-decl_subsys(power,NULL,NULL);
+decl_subsys(power, NULL);
 
 
 /**
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -721,7 +721,6 @@ struct kset *kset_create(const char *nam
 	if (!kset)
 		return ERR_PTR(-ENOMEM);
 	kobject_set_name(&kset->kobj, name);
-	kset->ktype = ktype;
 	kset->uevent_ops = uevent_ops;
 
 	return kset;
--- a/security/inode.c
+++ b/security/inode.c
@@ -315,13 +315,13 @@ void securityfs_remove(struct dentry *de
 }
 EXPORT_SYMBOL_GPL(securityfs_remove);
 
-static decl_subsys(security, NULL, NULL);
+static decl_subsys(security, NULL);
 
 static int __init securityfs_init(void)
 {
 	int retval;
 
-	kobj_set_kset_s(&security_subsys, kernel_subsys);
+	security_subsys.kobj.kset = &kernel_subsys;
 	retval = subsystem_register(&security_subsys);
 	if (retval)
 		return retval;
