From eb9785131c6fb02340ddc77a1da2a384259cd588 Mon Sep 17 00:00:00 2001
From: Bruno Castro da Silva <brunocs@gmail.com>
Date: Wed, 14 Jan 2009 16:30:10 -0800
Subject: Staging: add TuxGuardian LSM to the staging tree

From: Bruno Castro da Silva <brunocs@gmail.com>

Adds the tuxguardian lsm to the staging tree.

It currently doesn't build, so it depends on CONFIG_BROKEN

From: Bruno Castro da Silva <brunocs@gmail.com>
Cc: Rafael Konrath <rafael.konrath@gmail.com>
Cc: Stephan Peijnik <stephan@peijnik.at>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/Kconfig                  |    2 +
 drivers/staging/Makefile                 |    1 +
 drivers/staging/tuxguardian/Kconfig      |    8 +
 drivers/staging/tuxguardian/Makefile     |    3 +
 drivers/staging/tuxguardian/capability.c |  102 +++++++
 drivers/staging/tuxguardian/commoncap.c  |  346 ++++++++++++++++++++++
 drivers/staging/tuxguardian/errors.h     |  135 +++++++++
 drivers/staging/tuxguardian/tg-defs.c    |  406 ++++++++++++++++++++++++++
 drivers/staging/tuxguardian/tg-defs.h    |   52 ++++
 drivers/staging/tuxguardian/tg.c         |  459 ++++++++++++++++++++++++++++++
 drivers/staging/tuxguardian/tg.h         |  110 +++++++
 11 files changed, 1624 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/tuxguardian/Kconfig
 create mode 100644 drivers/staging/tuxguardian/Makefile
 create mode 100644 drivers/staging/tuxguardian/capability.c
 create mode 100644 drivers/staging/tuxguardian/commoncap.c
 create mode 100644 drivers/staging/tuxguardian/errors.h
 create mode 100644 drivers/staging/tuxguardian/tg-defs.c
 create mode 100644 drivers/staging/tuxguardian/tg-defs.h
 create mode 100644 drivers/staging/tuxguardian/tg.c
 create mode 100644 drivers/staging/tuxguardian/tg.h

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index ce6badd..979afda 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -95,5 +95,7 @@ source "drivers/staging/epl/Kconfig"
 
 source "drivers/staging/android/Kconfig"
 
+source "drivers/staging/tuxguardian/Kconfig"
+
 endif # !STAGING_EXCLUDE_BUILD
 endif # STAGING
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index 9ddcc2b..5e3cf54 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -30,3 +30,4 @@ obj-$(CONFIG_INPUT_MIMIO)	+= mimio/
 obj-$(CONFIG_TRANZPORT)		+= frontier/
 obj-$(CONFIG_EPL)		+= epl/
 obj-$(CONFIG_ANDROID)		+= android/
+obj-$(CONFIG_SECURITY_TUXGUARDIAN)	+= tuxguardian/
diff --git a/drivers/staging/tuxguardian/Kconfig b/drivers/staging/tuxguardian/Kconfig
new file mode 100644
index 0000000..a34bf37
--- /dev/null
+++ b/drivers/staging/tuxguardian/Kconfig
@@ -0,0 +1,8 @@
+config SECURITY_TUXGUARDIAN
+	tristate "TuxGuardian network access control"
+	depends on SECURITY_NETWORK && BROKEN
+	default N
+	---help---
+	  Enable support for TuxGuardian, an access control that
+	  attempts to provide control over every process that connects
+	  to the network.
diff --git a/drivers/staging/tuxguardian/Makefile b/drivers/staging/tuxguardian/Makefile
new file mode 100644
index 0000000..85fc34f
--- /dev/null
+++ b/drivers/staging/tuxguardian/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_SECURITY_TUXGUARDIAN) += tuxg.o
+
+tuxg-objs := tg-defs.o tg.o
diff --git a/drivers/staging/tuxguardian/capability.c b/drivers/staging/tuxguardian/capability.c
new file mode 100644
index 0000000..f9b35cc
--- /dev/null
+++ b/drivers/staging/tuxguardian/capability.c
@@ -0,0 +1,102 @@
+/*
+ *  Capabilities Linux Security Module
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/security.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp_lock.h>
+#include <linux/skbuff.h>
+#include <linux/netlink.h>
+#include <linux/ptrace.h>
+#include <linux/moduleparam.h>
+
+static struct security_operations capability_ops = {
+	.ptrace =			cap_ptrace,
+	.capget =			cap_capget,
+	.capset_check =			cap_capset_check,
+	.capset_set =			cap_capset_set,
+	.capable =			cap_capable,
+	.settime =			cap_settime,
+	.netlink_send =			cap_netlink_send,
+	.netlink_recv =			cap_netlink_recv,
+
+	.bprm_apply_creds =		cap_bprm_apply_creds,
+	.bprm_set_security =		cap_bprm_set_security,
+	.bprm_secureexec =		cap_bprm_secureexec,
+
+	.inode_setxattr =		cap_inode_setxattr,
+	.inode_removexattr =		cap_inode_removexattr,
+
+	.task_post_setuid =		cap_task_post_setuid,
+	.task_reparent_to_init =	cap_task_reparent_to_init,
+
+	.syslog =                       cap_syslog,
+
+	.vm_enough_memory =             cap_vm_enough_memory,
+};
+
+/* flag to keep track of how we were registered */
+static int secondary;
+
+static int capability_disable;
+module_param_named(disable, capability_disable, int, 0);
+MODULE_PARM_DESC(disable, "To disable capabilities module set disable = 1");
+
+static int __init capability_init (void)
+{
+	if (capability_disable) {
+		printk(KERN_INFO "Capabilities disabled at initialization\n");
+		return 0;
+	}
+	/* register ourselves with the security framework */
+	if (register_security (&capability_ops)) {
+		/* try registering with primary module */
+		if (mod_reg_security (KBUILD_MODNAME, &capability_ops)) {
+			printk (KERN_INFO "Failure registering capabilities "
+				"with primary security module.\n");
+			return -EINVAL;
+		}
+		secondary = 1;
+	}
+	printk (KERN_INFO "Capability LSM initialized%s\n",
+		secondary ? " as secondary" : "");
+	return 0;
+}
+
+static void __exit capability_exit (void)
+{
+	if (capability_disable)
+		return;
+	/* remove ourselves from the security framework */
+	if (secondary) {
+		if (mod_unreg_security (KBUILD_MODNAME, &capability_ops))
+			printk (KERN_INFO "Failure unregistering capabilities "
+				"with primary module.\n");
+		return;
+	}
+
+	if (unregister_security (&capability_ops)) {
+		printk (KERN_INFO
+			"Failure unregistering capabilities with the kernel\n");
+	}
+}
+
+security_initcall (capability_init);
+module_exit (capability_exit);
+
+MODULE_DESCRIPTION("Standard Linux Capabilities Security Module");
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/tuxguardian/commoncap.c b/drivers/staging/tuxguardian/commoncap.c
new file mode 100644
index 0000000..8a6e097
--- /dev/null
+++ b/drivers/staging/tuxguardian/commoncap.c
@@ -0,0 +1,346 @@
+/* Common capabilities, needed by capability.o and root_plug.o 
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ */
+
+#include <linux/capability.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/security.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/pagemap.h>
+#include <linux/swap.h>
+#include <linux/smp_lock.h>
+#include <linux/skbuff.h>
+#include <linux/netlink.h>
+#include <linux/ptrace.h>
+#include <linux/xattr.h>
+#include <linux/hugetlb.h>
+
+int cap_netlink_send(struct sock *sk, struct sk_buff *skb)
+{
+	NETLINK_CB(skb).eff_cap = current->cap_effective;
+	return 0;
+}
+
+EXPORT_SYMBOL(cap_netlink_send);
+
+int cap_netlink_recv(struct sk_buff *skb)
+{
+	if (!cap_raised(NETLINK_CB(skb).eff_cap, CAP_NET_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+EXPORT_SYMBOL(cap_netlink_recv);
+
+int cap_capable (struct task_struct *tsk, int cap)
+{
+	/* Derived from include/linux/sched.h:capable. */
+	if (cap_raised(tsk->cap_effective, cap))
+		return 0;
+	return -EPERM;
+}
+
+int cap_settime(struct timespec *ts, struct timezone *tz)
+{
+	if (!capable(CAP_SYS_TIME))
+		return -EPERM;
+	return 0;
+}
+
+int cap_ptrace (struct task_struct *parent, struct task_struct *child)
+{
+	/* Derived from arch/i386/kernel/ptrace.c:sys_ptrace. */
+	if (!cap_issubset (child->cap_permitted, current->cap_permitted) &&
+	    !capable(CAP_SYS_PTRACE))
+		return -EPERM;
+	return 0;
+}
+
+int cap_capget (struct task_struct *target, kernel_cap_t *effective,
+		kernel_cap_t *inheritable, kernel_cap_t *permitted)
+{
+	/* Derived from kernel/capability.c:sys_capget. */
+	*effective = cap_t (target->cap_effective);
+	*inheritable = cap_t (target->cap_inheritable);
+	*permitted = cap_t (target->cap_permitted);
+	return 0;
+}
+
+int cap_capset_check (struct task_struct *target, kernel_cap_t *effective,
+		      kernel_cap_t *inheritable, kernel_cap_t *permitted)
+{
+	/* Derived from kernel/capability.c:sys_capset. */
+	/* verify restrictions on target's new Inheritable set */
+	if (!cap_issubset (*inheritable,
+			   cap_combine (target->cap_inheritable,
+					current->cap_permitted))) {
+		return -EPERM;
+	}
+
+	/* verify restrictions on target's new Permitted set */
+	if (!cap_issubset (*permitted,
+			   cap_combine (target->cap_permitted,
+					current->cap_permitted))) {
+		return -EPERM;
+	}
+
+	/* verify the _new_Effective_ is a subset of the _new_Permitted_ */
+	if (!cap_issubset (*effective, *permitted)) {
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+void cap_capset_set (struct task_struct *target, kernel_cap_t *effective,
+		     kernel_cap_t *inheritable, kernel_cap_t *permitted)
+{
+	target->cap_effective = *effective;
+	target->cap_inheritable = *inheritable;
+	target->cap_permitted = *permitted;
+}
+
+int cap_bprm_set_security (struct linux_binprm *bprm)
+{
+	/* Copied from fs/exec.c:prepare_binprm. */
+
+	/* We don't have VFS support for capabilities yet */
+	cap_clear (bprm->cap_inheritable);
+	cap_clear (bprm->cap_permitted);
+	cap_clear (bprm->cap_effective);
+
+	/*  To support inheritance of root-permissions and suid-root
+	 *  executables under compatibility mode, we raise all three
+	 *  capability sets for the file.
+	 *
+	 *  If only the real uid is 0, we only raise the inheritable
+	 *  and permitted sets of the executable file.
+	 */
+
+	if (!issecure (SECURE_NOROOT)) {
+		if (bprm->e_uid == 0 || current->uid == 0) {
+			cap_set_full (bprm->cap_inheritable);
+			cap_set_full (bprm->cap_permitted);
+		}
+		if (bprm->e_uid == 0)
+			cap_set_full (bprm->cap_effective);
+	}
+	return 0;
+}
+
+void cap_bprm_apply_creds (struct linux_binprm *bprm, int unsafe)
+{
+	/* Derived from fs/exec.c:compute_creds. */
+	kernel_cap_t new_permitted, working;
+
+	new_permitted = cap_intersect (bprm->cap_permitted, cap_bset);
+	working = cap_intersect (bprm->cap_inheritable,
+				 current->cap_inheritable);
+	new_permitted = cap_combine (new_permitted, working);
+
+	if (bprm->e_uid != current->uid || bprm->e_gid != current->gid ||
+	    !cap_issubset (new_permitted, current->cap_permitted)) {
+		current->mm->dumpable = suid_dumpable;
+
+		if (unsafe & ~LSM_UNSAFE_PTRACE_CAP) {
+			if (!capable(CAP_SETUID)) {
+				bprm->e_uid = current->uid;
+				bprm->e_gid = current->gid;
+			}
+			if (!capable (CAP_SETPCAP)) {
+				new_permitted = cap_intersect (new_permitted,
+							current->cap_permitted);
+			}
+		}
+	}
+
+	current->suid = current->euid = current->fsuid = bprm->e_uid;
+	current->sgid = current->egid = current->fsgid = bprm->e_gid;
+
+	/* For init, we want to retain the capabilities set
+	 * in the init_task struct. Thus we skip the usual
+	 * capability rules */
+	if (current->pid != 1) {
+		current->cap_permitted = new_permitted;
+		current->cap_effective =
+		    cap_intersect (new_permitted, bprm->cap_effective);
+	}
+
+	/* AUD: Audit candidate if current->cap_effective is set */
+
+	current->keep_capabilities = 0;
+}
+
+int cap_bprm_secureexec (struct linux_binprm *bprm)
+{
+	/* If/when this module is enhanced to incorporate capability
+	   bits on files, the test below should be extended to also perform a 
+	   test between the old and new capability sets.  For now,
+	   it simply preserves the legacy decision algorithm used by
+	   the old userland. */
+	return (current->euid != current->uid ||
+		current->egid != current->gid);
+}
+
+int cap_inode_setxattr(struct dentry *dentry, char *name, void *value,
+		       size_t size, int flags)
+{
+	if (!strncmp(name, XATTR_SECURITY_PREFIX,
+		     sizeof(XATTR_SECURITY_PREFIX) - 1)  &&
+	    !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int cap_inode_removexattr(struct dentry *dentry, char *name)
+{
+	if (!strncmp(name, XATTR_SECURITY_PREFIX,
+		     sizeof(XATTR_SECURITY_PREFIX) - 1)  &&
+	    !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+/* moved from kernel/sys.c. */
+/* 
+ * cap_emulate_setxuid() fixes the effective / permitted capabilities of
+ * a process after a call to setuid, setreuid, or setresuid.
+ *
+ *  1) When set*uiding _from_ one of {r,e,s}uid == 0 _to_ all of
+ *  {r,e,s}uid != 0, the permitted and effective capabilities are
+ *  cleared.
+ *
+ *  2) When set*uiding _from_ euid == 0 _to_ euid != 0, the effective
+ *  capabilities of the process are cleared.
+ *
+ *  3) When set*uiding _from_ euid != 0 _to_ euid == 0, the effective
+ *  capabilities are set to the permitted capabilities.
+ *
+ *  fsuid is handled elsewhere. fsuid == 0 and {r,e,s}uid!= 0 should 
+ *  never happen.
+ *
+ *  -astor 
+ *
+ * cevans - New behaviour, Oct '99
+ * A process may, via prctl(), elect to keep its capabilities when it
+ * calls setuid() and switches away from uid==0. Both permitted and
+ * effective sets will be retained.
+ * Without this change, it was impossible for a daemon to drop only some
+ * of its privilege. The call to setuid(!=0) would drop all privileges!
+ * Keeping uid 0 is not an option because uid 0 owns too many vital
+ * files..
+ * Thanks to Olaf Kirch and Peter Benie for spotting this.
+ */
+static inline void cap_emulate_setxuid (int old_ruid, int old_euid,
+					int old_suid)
+{
+	if ((old_ruid == 0 || old_euid == 0 || old_suid == 0) &&
+	    (current->uid != 0 && current->euid != 0 && current->suid != 0) &&
+	    !current->keep_capabilities) {
+		cap_clear (current->cap_permitted);
+		cap_clear (current->cap_effective);
+	}
+	if (old_euid == 0 && current->euid != 0) {
+		cap_clear (current->cap_effective);
+	}
+	if (old_euid != 0 && current->euid == 0) {
+		current->cap_effective = current->cap_permitted;
+	}
+}
+
+int cap_task_post_setuid (uid_t old_ruid, uid_t old_euid, uid_t old_suid,
+			  int flags)
+{
+	switch (flags) {
+	case LSM_SETID_RE:
+	case LSM_SETID_ID:
+	case LSM_SETID_RES:
+		/* Copied from kernel/sys.c:setreuid/setuid/setresuid. */
+		if (!issecure (SECURE_NO_SETUID_FIXUP)) {
+			cap_emulate_setxuid (old_ruid, old_euid, old_suid);
+		}
+		break;
+	case LSM_SETID_FS:
+		{
+			uid_t old_fsuid = old_ruid;
+
+			/* Copied from kernel/sys.c:setfsuid. */
+
+			/*
+			 * FIXME - is fsuser used for all CAP_FS_MASK capabilities?
+			 *          if not, we might be a bit too harsh here.
+			 */
+
+			if (!issecure (SECURE_NO_SETUID_FIXUP)) {
+				if (old_fsuid == 0 && current->fsuid != 0) {
+					cap_t (current->cap_effective) &=
+					    ~CAP_FS_MASK;
+				}
+				if (old_fsuid != 0 && current->fsuid == 0) {
+					cap_t (current->cap_effective) |=
+					    (cap_t (current->cap_permitted) &
+					     CAP_FS_MASK);
+				}
+			}
+			break;
+		}
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void cap_task_reparent_to_init (struct task_struct *p)
+{
+	p->cap_effective = CAP_INIT_EFF_SET;
+	p->cap_inheritable = CAP_INIT_INH_SET;
+	p->cap_permitted = CAP_FULL_SET;
+	p->keep_capabilities = 0;
+	return;
+}
+
+int cap_syslog (int type)
+{
+	if ((type != 3 && type != 10) && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
+int cap_vm_enough_memory(long pages)
+{
+	int cap_sys_admin = 0;
+
+	if (cap_capable(current, CAP_SYS_ADMIN) == 0)
+		cap_sys_admin = 1;
+	return __vm_enough_memory(pages, cap_sys_admin);
+}
+
+EXPORT_SYMBOL(cap_capable);
+EXPORT_SYMBOL(cap_settime);
+EXPORT_SYMBOL(cap_ptrace);
+EXPORT_SYMBOL(cap_capget);
+EXPORT_SYMBOL(cap_capset_check);
+EXPORT_SYMBOL(cap_capset_set);
+EXPORT_SYMBOL(cap_bprm_set_security);
+EXPORT_SYMBOL(cap_bprm_apply_creds);
+EXPORT_SYMBOL(cap_bprm_secureexec);
+EXPORT_SYMBOL(cap_inode_setxattr);
+EXPORT_SYMBOL(cap_inode_removexattr);
+EXPORT_SYMBOL(cap_task_post_setuid);
+EXPORT_SYMBOL(cap_task_reparent_to_init);
+EXPORT_SYMBOL(cap_syslog);
+EXPORT_SYMBOL(cap_vm_enough_memory);
+
+MODULE_DESCRIPTION("Standard Linux Common Capabilities Security Module");
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/tuxguardian/errors.h b/drivers/staging/tuxguardian/errors.h
new file mode 100644
index 0000000..62ef541
--- /dev/null
+++ b/drivers/staging/tuxguardian/errors.h
@@ -0,0 +1,135 @@
+#ifndef __HAS_ERRORS_H
+#define __HAS_ERRORS_H
+
+
+#include <linux/errno.h>
+
+
+struct sock_error_to_string
+{
+    int err;
+    char *explain;
+};
+
+
+struct sock_error_to_string error_to_string[] = {
+  { EPERM, "Not owner" },
+  { ENOENT, "No such file" },
+  { ESRCH, "No such process" },
+  { EINTR, "Interrupted system" },
+  { EIO, "I/O error" },
+  { ENXIO, "No such device" },
+  { E2BIG, "Argument list too long" },
+  { ENOEXEC, "Exec format error" },
+  { EBADF, "Bad file number" },
+  { ECHILD, "No children" },
+  { EAGAIN, "No more processes" },
+  { ENOMEM, "Not enough core" },
+  { EACCES, "Permission denied" },
+  { EFAULT, "Bad address" },
+  { ENOTBLK, "Block device required" },
+  { EBUSY, "Mount device busy" },
+  { EEXIST, "File exists" },
+  { EXDEV, "Cross-device link" },
+  { ENODEV, "No such device" },
+  { ENOTDIR, "Not a directory" },
+  { EISDIR, "Is a directory" },
+  { EINVAL, "Invalid argument" },
+  { ENFILE, "File table overflow" },
+  { EMFILE, "Too many open file" },
+  { ENOTTY, "Not a typewriter" },
+  { ETXTBSY, "Text file busy" },
+  { EFBIG, "File too large" },
+  { ENOSPC, "No space left on" },
+  { ESPIPE, "Illegal seek" },
+  { EROFS, "Read-only file system" },
+  { EMLINK, "Too many links" },
+  { EPIPE, "Broken pipe" },
+  { EWOULDBLOCK, "Operation would block" },
+  { EINPROGRESS, "Operation now in progress" },
+  { EALREADY, "Operation already in progress" },
+  { ENOTSOCK, "Socket operation on" },
+  { EDESTADDRREQ, "Destination address required" },
+  { EMSGSIZE, "Message too long" },
+  { EPROTOTYPE, "Protocol wrong type" },
+  { ENOPROTOOPT, "Protocol not available" },
+  { EPROTONOSUPPORT, "Protocol not supported" },
+  { ESOCKTNOSUPPORT, "Socket type not supported" },
+  { EOPNOTSUPP, "Operation not supported" },
+  { EPFNOSUPPORT, "Protocol family not supported" },
+  { EAFNOSUPPORT, "Address family not supported" },
+  { EADDRINUSE, "Address already in use" },
+  { EADDRNOTAVAIL, "Can't assign requested address" },
+  { ENETDOWN, "Network is down" },
+  { ENETUNREACH, "Network is unreachable" },
+  { ENETRESET, "Network dropped connection" },
+  { ECONNABORTED, "Software caused connection" },
+  { ECONNRESET, "Connection reset by peer" },
+  { ENOBUFS, "No buffer space available" },
+  { EISCONN, "Socket is already connected" },
+  { ENOTCONN, "Socket is not connected" },
+  { ESHUTDOWN, "Can't send after shutdown" },
+  { ETOOMANYREFS, "Too many references" },
+  { ETIMEDOUT, "Connection timed out" },
+  { ECONNREFUSED, "Connection refused" },
+  { ELOOP, "Too many levels of nesting" },
+  { ENAMETOOLONG, "File name too long" },
+  { EHOSTDOWN, "Host is down" },
+  { EHOSTUNREACH, "No route to host" },
+  { ENOTEMPTY, "Directory not empty" },
+  { EUSERS, "Too many users" },
+  { EDQUOT, "Disc quota exceeded" },
+  { ESTALE, "Stale NFS file handle" },
+  { EREMOTE, "Too many levels of remote in the path" },
+  { ENOSTR, "Device is not a stream" },
+  { ETIME, "Timer expired" },
+  { ENOSR, "Out of streams resources" },
+  { ENOMSG, "No message" },
+  { EBADMSG, "Trying to read unreadable message" },
+  { EIDRM, "Identifier removed" },
+  { EDEADLK, "Deadlock condition" },
+  { ENOLCK, "No record locks available" },
+  { ENONET, "Machine is not on network" },
+  { ENOLINK, "The link has been severed" },
+  { EADV, "ADVERTISE error" },
+  { ESRMNT, "SRMOUNT error" },
+  { ECOMM, "Communication error" },
+  { EPROTO, "Protocol error" },
+  { EMULTIHOP, "Multihop attempted" },
+  { EDOTDOT, "Cross mount point" },
+  { EREMCHG, "Remote address change" }
+};
+
+
+
+struct sock_proto_to_string
+{
+    int protonumber;
+    char *description;
+};
+
+static struct sock_proto_to_string proto_to_string[] = {
+  { IPPROTO_IP, "Dummy protocol for TCP" },
+  { IPPROTO_ICMP, "Internet Control Message Protocol" },
+  { IPPROTO_IGMP, "Internet Group Management Protocol" },
+  { IPPROTO_IPIP, "IPIP tunnels (older KA9Q tunnels use 94)" },
+  { IPPROTO_TCP, "Transmission Control Protocol" },
+  { IPPROTO_EGP, "Exterior Gateway Protocol" },
+  { IPPROTO_PUP, "PUP protocol" },
+  { IPPROTO_UDP, "User Datagram Protocol" },
+  { IPPROTO_IDP, "XNS IDP protocol" },
+  { IPPROTO_RSVP, "RSVP protocol" },
+  { IPPROTO_GRE, "Cisco GRE tunnels (rfc 1701,1702" },
+  { IPPROTO_IPV6, "IPv6-in-IPv4 tunnelling" },
+  { IPPROTO_ESP, "Encapsulation Security Payload protocol" },
+  { IPPROTO_AH, "Authentication Header protocol" },
+  { IPPROTO_PIM, "Protocol Independent Multicast" },
+  { IPPROTO_COMP, "Compression Header protocol" },
+  { IPPROTO_SCTP, "Stream Control Transport Protocol" },
+  { IPPROTO_RAW, "Raw IP packets" }
+};
+
+
+
+
+#endif
diff --git a/drivers/staging/tuxguardian/tg-defs.c b/drivers/staging/tuxguardian/tg-defs.c
new file mode 100644
index 0000000..880e603
--- /dev/null
+++ b/drivers/staging/tuxguardian/tg-defs.c
@@ -0,0 +1,406 @@
+/*
+    TuxGuardian is copyright 2004, Bruno Castro da Silva (brunocs@portoweb.com.br)
+                                   http://tuxguardian.sourceforge.net
+
+    This file is part of TuxGuardian.
+
+    TuxGuardian is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    TuxGuardian is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with TuxGuardian; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+
+
+
+#include "tg-defs.h"
+
+
+
+//--------------------------------------------------------------------------------
+char *err_to_str(int err)
+{
+  int i;
+  int error = -err;
+
+  if (error == 0)
+    return "ok";
+  
+  for (i = 0; i < ARRAY_SIZE(error_to_string); i++)
+    if (error_to_string[i].err == error)
+      return error_to_string[i].explain;
+
+  return "unknown error";
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+char *proto_to_str(int protonumber)
+{
+  int i;
+
+  for (i = 0; i < ARRAY_SIZE(proto_to_string); i++)
+    if (proto_to_string[i].protonumber == protonumber)
+      return proto_to_string[i].description;
+
+  return "unknown ip protocol";
+}
+//--------------------------------------------------------------------------------
+
+
+
+
+//--------------------------------------------------------------------------------
+/* void print_string_to_tty(char *str) */
+/* { */
+
+/*   struct tty_struct *my_tty; */
+/*   my_tty = current->tty; */
+/*   if (my_tty != NULL) {  */
+/*     (*(my_tty->driver)->write)( */
+/* 			       my_tty,                 // The tty itself */
+/* 			       0,                      // We don't take the string from user space */
+/* 			       str,                    // String */
+/* 			       strlen(str));           // Length */
+/*     (*(my_tty->driver)->write)(my_tty, 0, "\015\012", 2); */
+/*   } */
+/* } */
+//--------------------------------------------------------------------------------
+
+
+
+
+//--------------------------------------------------------------------------------
+void print_socket_info(int family, int type)
+{
+  switch (family) {
+
+  case PF_LOCAL:  // aka PF_UNIX (the old BSD name) and AF_UNIX/AF_LOCAL
+    // sockets for local interprocess communication
+    switch (type) {
+    case SOCK_STREAM: {
+      printk("(local communication) PF_UNIX SOCK_STREAM");
+      return;
+    }
+    case SOCK_DGRAM: {
+      printk("(local communication) PF_UNIX SOCK_DGRAM");
+      return;
+    }
+    }
+    
+  case PF_NETLINK: {
+    // netlink is used to transfer information between kernel modules and user space processes
+    printk("(kernel-user communication) PF_NETLINK");
+    return;
+  }
+
+  case PF_PACKET: {
+    // packet interface on device level (used to receive or send raw packets at the device driver)
+    printk("(device level communication) PF_PACKET");
+    return;
+  }
+
+  case PF_KEY: {
+    // IPSEC stuff.. A user process maintains keyring information on databases that are
+    // accessed by sending messages over this socket
+    printk("(keyring db communication - IPSEC) IPSECPF_KEY");
+    return;
+  }
+
+
+  case PF_INET: {
+    // IPv4 communication
+    printk("(IPv4 communication) PF_INET");
+    switch (type) {
+    case SOCK_STREAM:
+      printk(" SOCK_STREAM");
+    case SOCK_DGRAM:
+      printk(" SOCK_DGRAM");
+    case SOCK_RAW:
+      printk(" SOCK_RAW");
+    }
+    return;
+  }
+
+ 
+  case PF_INET6: {
+    // IPv6 communication
+    printk("(IPv6 communication) PF_INET6");
+    switch (type) {
+    case SOCK_STREAM:
+      printk(" SOCK_STREAM");
+    case SOCK_DGRAM:
+      printk(" SOCK_DGRAM");
+    case SOCK_RAW:
+      printk(" SOCK_RAW");
+    }
+    return;
+  }
+
+  }
+
+}
+//--------------------------------------------------------------------------------
+
+
+
+
+//--------------------------------------------------------------------------------
+int is_internet_socket(int family)
+{
+
+  if ((family == PF_INET) || (family == PF_INET6))
+    return 1;
+  else
+    return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+
+
+//--------------------------------------------------------------------------------
+static int create_socket(struct socket **sock)
+{
+
+  int retval;
+  mm_segment_t oldfs;      // to save the current userspace segment descriptor
+
+  // this is useful for SMP (shared memory multiprocessor) architectures, but i call it anyway
+  lock_kernel();
+
+  oldfs = get_fs();
+  set_fs(KERNEL_DS);
+
+  // 3rd parameter (protocol) is set to 0 to specify the family's default
+  retval = sock_create(AF_UNIX, SOCK_STREAM, 0, sock);
+  set_fs(oldfs);
+
+  unlock_kernel();
+
+  return retval;
+
+}
+//--------------------------------------------------------------------------------
+
+
+
+
+
+
+//--------------------------------------------------------------------------------
+static int connect_socket(struct socket **sock)
+{
+
+  struct sockaddr_un loc;  // unix domain socket address
+  int retval;
+  mm_segment_t oldfs;      // to save the current userspace segment descriptor
+
+
+  oldfs = get_fs();
+  set_fs(KERNEL_DS);
+
+  // if close() is called and there are queued msgs, block until msg is sent or timeout
+  (*sock)->sk->sk_lingertime  = 1;
+//  (*sock)->sk->sk_reuse = 1;
+
+  loc.sun_family = AF_UNIX;
+  strcpy(loc.sun_path, PATH_MODULE); 
+  retval = (*sock)->ops->connect(*sock, (struct sockaddr *)&loc, sizeof(loc), 0);
+
+  set_fs(oldfs);
+				
+  return retval;
+
+}
+//--------------------------------------------------------------------------------
+
+
+
+
+//--------------------------------------------------------------------------------
+static int send_query_to_daemon (struct socket **sock, struct tg_query *query, pid_t pid)
+{
+
+  struct msghdr	msg;       // msg is the message that will carry our query to the daemon
+  struct iovec	iov;
+  mm_segment_t oldfs;      // to save the current userspace segment descriptor
+  
+  int retval;
+  
+  if ((*sock)==NULL) {
+    printk(KERN_INFO "TuxGuardian: lost communication with the daemon (sock is NULL)\n");
+    printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet\n", pid,
+	   current->comm);
+    return -1;
+  }
+  else
+    if (! ((*sock)->sk) ) {
+      printk(KERN_INFO "TuxGuardian: lost communication with the daemon (sock->sk is NULL)\n");
+      printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet\n", pid,
+	     current->comm);
+      return -1;
+    }
+  
+  
+  msg.msg_name     = 0;    //  optional address
+  msg.msg_namelen  = 0;
+  
+  msg.msg_iov	 = &iov;    //  information about the send (or receive) buffer.
+  msg.msg_iovlen   = 1;
+  
+  msg.msg_iov->iov_base = (void *) query;     // the send buffer
+  msg.msg_iov->iov_len  = (__kernel_size_t) tg_query_size;
+  
+  msg.msg_control  = NULL;   // we don't want to transmit access rights
+  msg.msg_controllen = 0;
+  
+  msg.msg_flags    = MSG_NOSIGNAL;    // we don't want a SIGPIPE if the daemon close
+                                      // the connection
+  
+
+  // any system call checks whether the provided buffer is in a valid userspace address.
+  // To avoid weird error, we'll prevent the usual check to fail by making the task's
+  // maximum valid address conform to kernelspace addresses.
+  oldfs = get_fs();  // saves the current userspace segment descriptor
+  set_fs(KERNEL_DS);  // sets to the segment descriptor associated to kernelspace
+
+  retval = sock_sendmsg(*sock, &msg, (size_t) tg_query_size);
+  if (retval == 0) {
+    printk(KERN_INFO "TuxGuardian: connection reset by peer (daemon)\n");
+    printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet\n", pid,
+	   current->comm);
+    return -1;
+  }
+  else
+    if (retval < 0) {
+      printk(KERN_INFO "TuxGuardian: error %d on sending a query to the daemon\n", retval);
+      printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet\n", pid,
+	     current->comm);
+      return -1;
+    }
+
+  set_fs(oldfs);  // restores the userspace segment descriptor
+   
+  return 0;
+
+  // this is the correct way of doing it!
+  /* 	while (nbytes > 0) { */
+  /* 		msg.msg_iov->iov_base = (void *) buffer + offset; */
+  /* 		msg.msg_iov->iov_len = nbytes; */
+
+  /* 		oldfs = get_fs(); */
+  /* 		set_fs(KERNEL_DS); */
+  /* 		len = sock_sendmsg(sock, &msg, nbytes); */
+  /* 		set_fs(oldfs); */
+
+  /* 		if (len < 0) { */
+  /* 			ret = -1; */
+  /* 			break; */
+  /* 		} */
+
+  /* 		nbytes -= len; */
+  /* 		offset += len; */
+  /* 	} */
+
+}
+//--------------------------------------------------------------------------------
+
+
+
+
+//--------------------------------------------------------------------------------
+int send_question_permit(struct socket **sock, pid_t pid, int question)
+{
+
+  int retval;
+  struct tg_query query;   // used to ask the daemon if 'pid' is allowed to use the internet
+
+  retval = create_socket(sock);
+  if (retval != 0) {
+    printk(KERN_INFO "TuxGuardian: communication with daemon failed (could not create a socket)\n");
+    printk(KERN_INFO "TuxGuardian: error %d\n", retval);
+    printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet\n", pid,
+	   current->comm);
+    return -1;
+  }
+  
+   retval = connect_socket(sock);
+   if (retval != 0) {
+     printk(KERN_INFO "TuxGuardian: could not connect to the daemon! Error %d\n", retval);
+     printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet\n", pid,
+	    current->comm);
+     return -1;
+   }
+
+   query.sender = TG_MODULE;
+   query.seqno = cur_seqno++;
+   query.query_type = question;
+   query.query_data = pid;
+
+   retval = send_query_to_daemon(sock, &query, pid);   // (errors are treated inside the function)
+   if (retval != 0)
+     return -1;   // don't continue if send_query failed
+   
+   // TODO: return query.resposta
+   return retval;
+ 
+}
+//--------------------------------------------------------------------------------
+
+
+
+
+//--------------------------------------------------------------------------------
+int read_answer_from_daemon(struct socket *sock, struct tg_query *answer)
+{
+
+  struct msghdr	msg;
+  struct iovec	iov;
+  int retval;
+  mm_segment_t oldfs;      // to save the current userspace segment descriptor
+  //  struct tg_query answer;
+
+
+  //  Receive a packet
+  msg.msg_name = 0;
+  msg.msg_namelen = 0;
+  msg.msg_iov = &iov;
+  msg.msg_iovlen = 1;
+  msg.msg_control = NULL;
+  msg.msg_controllen = 0;
+  msg.msg_flags = 0;
+
+  msg.msg_iov->iov_base = (void *) answer;
+  msg.msg_iov->iov_len  = (__kernel_size_t) tg_query_size;
+  
+  oldfs = get_fs();
+  set_fs(KERNEL_DS);
+
+
+  // MSG_PEEK flag: do not remove data from the receive queue
+
+  retval = sock_recvmsg(sock, &msg, (size_t) tg_query_size, MSG_WAITALL /* 0 flags*/);
+  if (retval < 0) {
+    printk(KERN_INFO "TuxGuardian: (%s) read_answer_from_app failed. Error %d (%s)\n", 
+	   current->comm, retval, err_to_str(retval));
+  }
+  
+  set_fs(oldfs);
+
+  return retval;
+
+}
+//--------------------------------------------------------------------------------
diff --git a/drivers/staging/tuxguardian/tg-defs.h b/drivers/staging/tuxguardian/tg-defs.h
new file mode 100644
index 0000000..d67a413
--- /dev/null
+++ b/drivers/staging/tuxguardian/tg-defs.h
@@ -0,0 +1,52 @@
+/*
+    TuxGuardian is copyright 2004, Bruno Castro da Silva (brunocs@portoweb.com.br)
+                                   http://tuxguardian.sourceforge.net
+
+    This file is part of TuxGuardian.
+
+    TuxGuardian is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    TuxGuardian is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with TuxGuardian; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+
+
+
+#ifndef __HAS_TG_DEFS_H
+#define __HAS_TG_DEFS_H
+
+
+// #include <linux/tty.h>      /* For the tty declarations */
+
+#include "tg.h"
+#include "errors.h"
+
+
+static u32 cur_seqno = 0;
+
+     
+// void print_string_to_tty(char *str);
+
+int is_internet_socket(int family);
+void print_socket_info(int family, int type);
+
+int send_question_permit(struct socket **sock, pid_t pid, int question);
+  //int send_question_permit_app(struct socket **sock, pid_t pid);
+int read_answer_from_daemon(struct socket *sock, struct tg_query *answer);
+
+static int create_socket(struct socket **sock);
+static int connect_socket(struct socket **sock);
+static int send_query_to_daemon (struct socket **sock, struct tg_query *query, pid_t pid);
+
+
+#endif
diff --git a/drivers/staging/tuxguardian/tg.c b/drivers/staging/tuxguardian/tg.c
new file mode 100644
index 0000000..20c0e4a
--- /dev/null
+++ b/drivers/staging/tuxguardian/tg.c
@@ -0,0 +1,459 @@
+/*
+    TuxGuardian is copyright 2004, Bruno Castro da Silva (brunocs@portoweb.com.br)
+                                   http://tuxguardian.sourceforge.net
+
+    This file is part of TuxGuardian.
+
+    TuxGuardian is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    TuxGuardian is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with TuxGuardian; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+
+
+
+#include "tg.h"
+#include <linux/ip.h>
+#include <linux/version.h>
+
+#ifndef KERNEL_VERSION
+#define KERNEL_VERSION(a,b,c) (((a) << 16) | ((b) << 8) | (c))
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,16)
+#include <net/inet_sock.h>
+#endif
+
+
+
+int send_question_permit(struct socket **sock, pid_t pid, int question);
+extern int is_internet_socket(int family);
+extern void print_socket_info(int family, int type);  
+extern int read_answer_from_daemon(struct socket *sock, struct tg_query *answer);
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_bprm_check_security (struct linux_binprm *bprm)
+{
+/*  binprm_security_ops is a set of program loading hook */
+/*   debug_message("file %s, e_uid = %d, e_gid = %d\n", */
+/* 		bprm->filename, bprm->e_uid, bprm->e_gid); */
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_create(int family, int type, int protocol, int kern)
+{
+  // TODO: i think the 'kern' parameter is used to inform if the socket
+  // was created in kernel space.. not using this parameter, though
+
+  int retval;
+  struct tg_query answer;
+  struct socket *sock;
+
+     
+  // local communication is always allowed
+  // (notice that since we are creating local sockets to
+  //   communicate w/ userspace this function SHOULD NOT
+  //   analyse local sockets or it'll loop)
+
+  if (! is_internet_socket(family)) {
+//    printk("local communication always allowed\n");
+    return 0;
+  }
+/*   else { */
+/*     printk("\nAsking if '%s' may create a socket (", current->comm); */
+/*   print_socket_info(family, type); */
+/*     printk(")\n"); */
+/*   } */
+
+
+  retval = send_question_permit(&sock, current->pid, TG_ASK_PERMIT_APP);
+  if (retval < 0)
+    return -EPERM;
+
+  // TODO: controle de timeout
+  // /usr/src/linux269/fs/ncpfs/sock.c
+  // /usr/src/linux269/net/bluetooth/rfcomm/sock.c
+  // sock_rcvtimeo
+  retval = read_answer_from_daemon(sock, &answer);
+  if (retval < 0)
+    return -EPERM;
+
+
+  switch (answer.query_data) {
+  case YES:
+    return 0;
+  case NO_ACCESS_IS_DENIED:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet"
+	   " (ACCESS IS DENIED)\n", current->pid, current->comm);
+    return -EPERM;
+  case NO_WRONG_HASH:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet"
+	   " (WRONG MD5HASH)\n", current->pid, current->comm);
+    return -EPERM;
+  case NO_NOT_IN_HASHTABLE:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet"
+	   " (APP NOT PERMITTED)\n", current->pid, current->comm);
+    return -EPERM;
+  case NO_ERROR_IN_DAEMON:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet"
+	   " (ERR IN DAEMON)\n", current->pid, current->comm);
+    return -EPERM;
+  case NO_USER_FORBID:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet"
+	   " (USER FORBID)\n", current->pid, current->comm);
+    return -EPERM;
+  case NO_ERROR_IN_FRONTEND:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet"
+	   " (ERR IN FRONTEND)\n", current->pid, current->comm);
+    return -EPERM;
+  default:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s) will not be allowed to access the internet"
+	   " (UNKNOWN ANSWER %d)\n", current->pid, current->comm, answer.query_data);
+    return -EPERM;
+  }
+
+
+/*   printk("resposta -> sender: %d   seqno: %d    query_type: %d    query_data:  %d\n", */
+/* 	 (int)answer.sender, answer.seqno, (int)answer.query_type, answer.query_data); */
+
+  // connection is closed by the daemon
+  //  sock_release(sock);
+  
+}
+//--------------------------------------------------------------------------------
+
+
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_connect(struct socket *conn_sock, struct sockaddr *address, int addrlen)
+{
+//  printk("tuxguardian_socket_connect!\n");
+  return 0;
+
+}
+//--------------------------------------------------------------------------------
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
+{
+  //  printk("tuxguardian_socket_bind!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_listen(struct socket *listen_sock, int backlog)
+{
+  int retval;
+  struct tg_query answer;
+  struct socket *sock;
+
+
+
+     
+  // local communication is always allowed
+  // (notice that since we are creating local sockets to
+  //   communicate w/ userspace this function SHOULD NOT
+  //   analyse local sockets or it'll loop)
+
+  if (! is_internet_socket(listen_sock->sk->sk_family)) {
+//    printk("local communication always allowed\n");
+    return 0;
+  }
+/*   else { */
+/*   printk("\nAsking if '%s' may be a server - ", current->comm); */
+/*   print_socket_info(listen_sock->sk->sk_family, listen_sock->sk->sk_type);  */
+/*   printk("\n                                   protocol %s at port %d\n", listen_sock->sk->sk_prot->name, */
+/* 	 htons(((struct inet_opt *)inet_sk(listen_sock->sk))->sport)); */
+/*   } */
+
+  retval = send_question_permit(&sock, current->pid, TG_PERMIT_SERVER);
+  if (retval < 0)
+    return -EPERM;
+
+  // TODO: timeout
+  // /usr/src/linux269/fs/ncpfs/sock.c
+  // /usr/src/linux269/net/bluetooth/rfcomm/sock.c
+  // sock_rcvtimeo
+  retval = read_answer_from_daemon(sock, &answer);
+  if (retval < 0)
+    return -EPERM;
+
+
+  switch (answer.query_data) {
+  case YES:
+    return 0;
+  case NO_ACCESS_IS_DENIED:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s@%d) will not be allowed to act like a server"
+	   " (ACCESS IS DENIED)\n", current->pid, current->comm,
+	   htons(((struct inet_sock *)inet_sk(listen_sock->sk))->sport));
+    return -EPERM;
+  case NO_WRONG_HASH:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s@%d) will not be allowed to act like a server"
+	   " (WRONG MD5HASH)\n", current->pid, current->comm,
+	   htons(((struct inet_sock*)inet_sk(listen_sock->sk))->sport));
+    return -EPERM;
+  case NO_NOT_IN_HASHTABLE:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s@%d) will not be allowed to act like a server"
+	   " (APP NOT PERMITTED)\n", current->pid, current->comm,
+	   htons(((struct inet_sock *)inet_sk(listen_sock->sk))->sport));
+    return -EPERM;
+  case NO_ERROR_IN_DAEMON:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s@%d) will not be allowed to act like a server"
+	   " (ERR IN DAEMON)\n", current->pid, current->comm,
+	   htons(((struct inet_sock *)inet_sk(listen_sock->sk))->sport));
+    return -EPERM;
+  case NO_USER_FORBID:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s@%d) will not be allowed to act like a server"
+	   " (USER FORBID)\n", current->pid, current->comm,
+	   htons(((struct inet_sock *)inet_sk(listen_sock->sk))->sport));
+    return -EPERM;
+  case NO_ERROR_IN_FRONTEND:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s@%d) will not be allowed to act like a server"
+	   " (ERR IN FRONTEND)\n", current->pid, current->comm,
+	   htons(((struct inet_sock *)inet_sk(listen_sock->sk))->sport));
+    return -EPERM;
+  default:
+    printk(KERN_INFO "TuxGuardian: process #%d (%s@%d) will not be allowed to act like a server"
+	   " (UNKNOWN ANSWER %d)\n", current->pid, current->comm, answer.query_data,
+	   htons(((struct inet_sock *)inet_sk(listen_sock->sk))->sport));
+    return -EPERM;
+  }
+
+
+/*   printk("resposta -> sender: %d   seqno: %d    query_type: %d    query_data:  %d\n", */
+/* 	 (int)answer.sender, answer.seqno, (int)answer.query_type, answer.query_data); */
+
+  // connection is closed by the daemon
+//  sock_release(sock);
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_accept(struct socket *sock, struct socket *newsock)
+{
+//  printk("tuxguardian_socket_accept!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_sendmsg(struct socket *sock, struct msghdr *msg, int size)
+{
+  //  printk("tuxguardian_socket_sendmsg!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_recvmsg(struct socket *sock, struct msghdr *msg, int size, int flags)
+{
+  //  printk("tuxguardian_socket_recvmsg!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_getsockname(struct socket *sock)
+{
+//  printk("tuxguardian_socket_getsockname!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_getpeername(struct socket *sock)
+{
+//  printk("tuxguardian_socket_getpeername!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_setsockopt(struct socket *sock,int level,int optname)
+{
+//  printk("tuxguardian_socket_setsockopt!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_getsockopt(struct socket *sock, int level, int optname)
+{
+//  printk("tuxguardian_socket_getsockopt!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_shutdown(struct socket *sock, int how)
+{
+//  printk("tuxguardian_socket_shutdown!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_unix_stream_connect(struct socket *sock,
+					      struct socket *other,
+					      struct sock *newsk)
+{
+//  printk("tuxguardian_socket_unix_stream_connect!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+//--------------------------------------------------------------------------------
+static int tuxguardian_socket_unix_may_send(struct socket *sock,
+					struct socket *other)
+{
+//  printk("tuxguardian_socket_unix_stream_send!\n");
+  return 0;
+}
+//--------------------------------------------------------------------------------
+
+
+
+
+
+
+
+
+
+
+// commoncap.c exporta umas coisa dessas
+static struct security_operations tuxguardian_security_ops = {
+  /* Use the capability functions for some of the hooks */
+  .ptrace                    =  cap_ptrace,
+  .capget                    =  cap_capget,
+  .capset_check              =	cap_capset_check,
+  .capset_set                =  cap_capset_set,
+  .capable                   =  cap_capable,
+ 
+  // evil callback that keeps changing name beetwen kernel releases!
+  .bprm_apply_creds          =  cap_bprm_apply_creds,  
+
+  .bprm_set_security         =	cap_bprm_set_security,
+  
+  .task_post_setuid          =	cap_task_post_setuid,
+  .task_reparent_to_init     =	cap_task_reparent_to_init,
+  
+  .bprm_check_security       = tuxguardian_bprm_check_security,
+  
+  .socket_create             =	tuxguardian_socket_create,
+  .socket_connect            =  tuxguardian_socket_connect,
+
+
+  .socket_bind               =	tuxguardian_socket_bind, 
+  .socket_listen             =	tuxguardian_socket_listen,	     
+  .socket_accept             =	tuxguardian_socket_accept,	     
+  .socket_sendmsg            =	tuxguardian_socket_sendmsg,	     
+  .socket_recvmsg            = 	tuxguardian_socket_recvmsg,	     
+  .socket_getsockname        =	tuxguardian_socket_getsockname,  
+  .socket_getpeername        =	tuxguardian_socket_getpeername,  
+  .socket_getsockopt         =	tuxguardian_socket_getsockopt,   
+  .socket_setsockopt         =	tuxguardian_socket_setsockopt,   
+  .socket_shutdown           =	tuxguardian_socket_shutdown,     
+  .unix_stream_connect       =	tuxguardian_socket_unix_stream_connect,
+  .unix_may_send             =	tuxguardian_socket_unix_may_send,
+
+
+
+};
+
+
+
+
+static int __init tuxguardian_init (void)
+{
+
+  /* register ourselves with the security framework */
+  if (register_security (&tuxguardian_security_ops)) {
+
+    printk(KERN_INFO "Failure registering TuxGuardian module with the kernel\n");
+
+    /* try registering as the primary module */
+    if (mod_reg_security (MY_NAME, &tuxguardian_security_ops)) {
+      printk(KERN_INFO "Failure registering TuxGuardian as the primary security module\n");
+      return -EINVAL;
+    }
+  }
+
+  printk (KERN_INFO "TuxGuardian initialized\n");
+  return 0;
+}
+
+
+
+static void __exit tuxguardian_exit (void)
+{
+
+  /* remove ourselves from the security framework */
+  if (unregister_security (&tuxguardian_security_ops)) {
+    printk (KERN_INFO "Failure unregistering TuxGuardian\n");
+  }
+  else
+    printk (KERN_INFO "\nTuxGuardian module removed\n");
+
+
+}
+
+security_initcall (tuxguardian_init);
+module_exit (tuxguardian_exit);
+
+
+/* MODULE_PARAM(int_param, "i") */
+/* then passing value into module as */
+/* insmod module int_param=x */
+
+/* Initialize the module - show the parameters */
+/* int init_module() */
+/* { */
+/*   if (str1 == NULL || str2 == NULL) { */
+/*     printk("Next time, do insmod param str1=<something>"); */
+/*     printk("str2=<something>\n"); */
+/*   } else */
+/*     printk("Strings:%s and %s\n", str1, str2); */
+
+MODULE_AUTHOR("Bruno Castro da Silva");
+MODULE_DESCRIPTION("TuxGuardian Security Module");
+// thanks stallman, thanks linus
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/tuxguardian/tg.h b/drivers/staging/tuxguardian/tg.h
new file mode 100644
index 0000000..f51eadb
--- /dev/null
+++ b/drivers/staging/tuxguardian/tg.h
@@ -0,0 +1,110 @@
+/*
+    TuxGuardian is copyright 2004, Bruno Castro da Silva (brunocs@portoweb.com.br)
+                                   http://tuxguardian.sourceforge.net
+
+    This file is part of TuxGuardian.
+
+    TuxGuardian is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    TuxGuardian is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with TuxGuardian; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+
+
+#ifndef __HAS_TG_H
+#define __HAS_TG_H
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <linux/types.h>
+#include <linux/ctype.h>
+
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/fs.h>
+#include <asm/unistd.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/in.h>
+#include <linux/un.h>
+#include <linux/net.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <linux/poll.h>
+#include <linux/file.h>
+
+
+
+#include <linux/string.h>
+
+#include <linux/security.h>  // LSM stuff
+
+
+#define PATH_MODULE "/tmp/tux_daemon_server"
+
+
+#if defined(CONFIG_SECURITY_TESTE_MODULE)
+#define MY_NAME THIS_MODULE->name
+#else
+#define MY_NAME "TuxGuardian"
+#endif
+
+
+// sender
+#define TG_MODULE 0
+#define TG_DAEMON 1
+#define TG_FRONTEND 2
+
+// query_type
+#define TG_ASK_PERMIT_APP 0
+#define TG_RESPOND_PERMIT_APP 1
+#define TG_PERMIT_REMOVE_MODULE 2
+#define TG_PERMIT_ACCESS_FILE 3
+#define TG_PERMIT_SERVER 4
+#define TG_RESPOND_PERMIT_SERVER 5
+
+// RESPOND_PERMIT_APP possibilities
+#define YES 0
+#define YES_SAVE_IN_FILE 6
+#define NO_ACCESS_IS_DENIED 7
+#define NO_SAVE_IN_FILE 8
+#define NO_WRONG_HASH 1
+#define NO_NOT_IN_HASHTABLE 2
+#define NO_ERROR_IN_DAEMON 3
+#define NO_USER_FORBID 4
+#define NO_ERROR_IN_FRONTEND 5
+
+#define debug_message(fmt, arg...)                                      \
+        do {                                                    \
+                        printk(KERN_INFO "%s: %s: " fmt ,       \
+                                MY_NAME , __FUNCTION__ ,        \
+                                ## arg);                        \
+        } while (0)
+
+struct tg_query {
+  u8 sender;
+  u32 seqno;        // sequence number
+  u8 query_type;
+  u32 query_data;   // might be a pid, YES, NO,.. depending on the query_type
+};
+
+#define tg_query_size sizeof(struct tg_query)
+
+
+
+     
+#endif
-- 
1.6.0.4

