From gman.1352@googlemail.com  Tue Feb 23 16:32:18 2010
From: Graham M Howe <gman.1352@googlemail.com>
Date: Wed, 10 Feb 2010 18:11:47 +0000
Subject: Staging: comedi: fix bracing coding style and 80 character issues in ni_660x.c
To: gregkh@suse.de, wfp5p@virginia.edu
Message-ID: <1265825507-4123-1-git-send-email-gman.1352@googlemail.com>

This is a patch to the ni_660x.c file that fixes up the brace and 80
character issues found by the checkpatch tool

Signed-off-by: Graham M Howe <gmhowe@btopenworld.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/comedi/drivers/ni_660x.c |   48 +++++++++++++++----------------
 1 file changed, 24 insertions(+), 24 deletions(-)

--- a/drivers/staging/comedi/drivers/ni_660x.c
+++ b/drivers/staging/comedi/drivers/ni_660x.c
@@ -52,7 +52,8 @@ enum ni_660x_constants {
 };
 
 #define NUM_PFI_CHANNELS 40
-/* really there are only up to 3 dma channels, but the register layout allows for 4 */
+/* really there are only up to 3 dma channels, but the register layout allows
+for 4 */
 #define MAX_DMA_CHANNEL 4
 
 /* See Register-Level Programmer Manual page 3.1 */
@@ -198,7 +199,7 @@ struct NI_660xRegisterData {
 	const char *name;	/*  Register Name */
 	int offset;		/*  Offset from base address from GPCT chip */
 	enum ni_660x_register_direction direction;
-	enum ni_660x_register_width size;	/*  1 byte, 2 bytes, or 4 bytes */
+	enum ni_660x_register_width size;	/*1 byte, 2 bytes, or 4 bytes*/
 };
 
 static const struct NI_660xRegisterData registerData[NumRegisters] = {
@@ -382,8 +383,8 @@ enum global_interrupt_config_register_bi
 };
 
 /* Offset of the GPCT chips from the base-adress of the card */
-static const unsigned GPCT_OFFSET[2] = { 0x0, 0x800 };	/* First chip is at base-address +
-							   0x00, etc. */
+/* First chip is at base-address + 0x00, etc. */
+static const unsigned GPCT_OFFSET[2] = { 0x0, 0x800 };
 
 /* Board description*/
 struct ni_660x_board {
@@ -993,9 +994,9 @@ static int ni_660x_allocate_private(stru
 	spin_lock_init(&private(dev)->mite_channel_lock);
 	spin_lock_init(&private(dev)->interrupt_lock);
 	spin_lock_init(&private(dev)->soft_reg_copy_lock);
-	for (i = 0; i < NUM_PFI_CHANNELS; ++i) {
+	for (i = 0; i < NUM_PFI_CHANNELS; ++i)
 		private(dev)->pfi_output_selects[i] = pfi_output_select_counter;
-	}
+
 	return 0;
 }
 
@@ -1008,9 +1009,8 @@ static int ni_660x_alloc_mite_rings(stru
 		for (j = 0; j < counters_per_chip; ++j) {
 			private(dev)->mite_rings[i][j] =
 			    mite_alloc_ring(private(dev)->mite);
-			if (private(dev)->mite_rings[i][j] == NULL) {
+			if (private(dev)->mite_rings[i][j] == NULL)
 				return -ENOMEM;
-			}
 		}
 	}
 	return 0;
@@ -1022,9 +1022,8 @@ static void ni_660x_free_mite_rings(stru
 	unsigned j;
 
 	for (i = 0; i < board(dev)->n_chips; ++i) {
-		for (j = 0; j < counters_per_chip; ++j) {
+		for (j = 0; j < counters_per_chip; ++j)
 			mite_free_ring(private(dev)->mite_rings[i][j]);
-		}
 	}
 }
 
@@ -1078,15 +1077,16 @@ static int ni_660x_attach(struct comedi_
 	s->insn_bits = ni_660x_dio_insn_bits;
 	s->insn_config = ni_660x_dio_insn_config;
 	s->io_bits = 0;		/* all bits default to input */
-	/*  we use the ioconfig registers to control dio direction, so zero output enables in stc dio control reg */
+	/*  we use the ioconfig registers to control dio direction, so zero
+	output enables in stc dio control reg */
 	ni_660x_write_register(dev, 0, 0, STCDIOControl);
 
 	private(dev)->counter_dev = ni_gpct_device_construct(dev,
-							     &ni_gpct_write_register,
-							     &ni_gpct_read_register,
-							     ni_gpct_variant_660x,
-							     ni_660x_num_counters
-							     (dev));
+						     &ni_gpct_write_register,
+						     &ni_gpct_read_register,
+						     ni_gpct_variant_660x,
+						     ni_660x_num_counters
+						     (dev));
 	if (private(dev)->counter_dev == NULL)
 		return -ENOMEM;
 	for (i = 0; i < NI_660X_MAX_NUM_COUNTERS; ++i) {
@@ -1118,12 +1118,12 @@ static int ni_660x_attach(struct comedi_
 			s->type = COMEDI_SUBD_UNUSED;
 		}
 	}
-	for (i = 0; i < board(dev)->n_chips; ++i) {
+	for (i = 0; i < board(dev)->n_chips; ++i)
 		init_tio_chip(dev, i);
-	}
-	for (i = 0; i < ni_660x_num_counters(dev); ++i) {
+
+	for (i = 0; i < ni_660x_num_counters(dev); ++i)
 		ni_tio_init_counter(&private(dev)->counter_dev->counters[i]);
-	}
+
 	for (i = 0; i < NUM_PFI_CHANNELS; ++i) {
 		if (i < min_counter_pfi_chan)
 			ni_660x_set_pfi_routing(dev, i, pfi_output_select_do);
@@ -1134,9 +1134,9 @@ static int ni_660x_attach(struct comedi_
 	}
 	/* to be safe, set counterswap bits on tio chips after all the counter
 	   outputs have been set to high impedance mode */
-	for (i = 0; i < board(dev)->n_chips; ++i) {
+	for (i = 0; i < board(dev)->n_chips; ++i)
 		set_tio_counterswap(dev, i);
-	}
+
 	ret = request_irq(mite_irq(private(dev)->mite), ni_660x_interrupt,
 			  IRQF_SHARED, "ni_660x", dev);
 	if (ret < 0) {
@@ -1193,9 +1193,9 @@ static void init_tio_chip(struct comedi_
 			       private(dev)->
 			       dma_configuration_soft_copies[chipset],
 			       DMAConfigRegister);
-	for (i = 0; i < NUM_PFI_CHANNELS; ++i) {
+	for (i = 0; i < NUM_PFI_CHANNELS; ++i)
 		ni_660x_write_register(dev, chipset, 0, IOConfigReg(i));
-	}
+
 }
 
 static int
