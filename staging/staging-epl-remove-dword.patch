From 292820354b6595274301ddb0b4d88b4e9ae8fe72 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Mon, 23 Mar 2009 12:51:37 -0700
Subject: [PATCH] Staging: epl: remove DWORD

It's u32 in kernelspace, not DWORD.

Cc: Daniel Krueger <daniel.krueger@systec-electronic.com>
Cc: Ronald Sieber <Ronald.Sieber@systec-electronic.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/epl/Debug.h            |    2 -
 drivers/staging/epl/Edrv8139.c         |   54 ++++++++++++++++-----------------
 drivers/staging/epl/Epl.h              |   38 +++++++++++------------
 drivers/staging/epl/EplAmi.h           |   18 +++++------
 drivers/staging/epl/EplApiGeneric.c    |    4 +-
 drivers/staging/epl/EplDll.h           |   40 ++++++++++++------------
 drivers/staging/epl/EplDllk.c          |   12 +++----
 drivers/staging/epl/EplErrorHandlerk.c |   24 +++++++-------
 drivers/staging/epl/EplEvent.h         |    2 -
 drivers/staging/epl/EplEventk.c        |    2 -
 drivers/staging/epl/EplEventu.c        |    2 -
 drivers/staging/epl/EplFrame.h         |   28 ++++++++---------
 drivers/staging/epl/EplIdentu.c        |    4 +-
 drivers/staging/epl/EplInc.h           |    8 ++--
 drivers/staging/epl/EplNmtMnu.c        |   20 ++++++------
 drivers/staging/epl/EplNmtk.c          |    2 -
 drivers/staging/epl/EplNmtu.c          |    6 +--
 drivers/staging/epl/EplObd.c           |    8 ++--
 drivers/staging/epl/EplObd.h           |    2 -
 drivers/staging/epl/EplObdMacro.h      |    2 -
 drivers/staging/epl/EplPdou.c          |    4 +-
 drivers/staging/epl/EplSdo.h           |    2 -
 drivers/staging/epl/EplSdoAsndu.c      |    2 -
 drivers/staging/epl/EplSdoComu.c       |   36 +++++++++++-----------
 drivers/staging/epl/EplSdoUdpu.c       |    4 +-
 drivers/staging/epl/EplTarget.h        |    2 -
 drivers/staging/epl/TimerHighReskX86.c |    2 -
 drivers/staging/epl/amix86.c           |   36 +++++++++++-----------
 drivers/staging/epl/demo_main.c        |   14 ++++----
 drivers/staging/epl/global.h           |    3 -
 drivers/staging/epl/kernel/EplDllk.h   |    2 -
 drivers/staging/epl/proc_fs.c          |   12 +++----
 drivers/staging/epl/user/EplCfgMau.h   |    6 +--
 drivers/staging/epl/user/EplSdoAsndu.h |    2 -
 drivers/staging/epl/user/EplSdoComu.h  |    2 -
 drivers/staging/epl/user/EplSdoUdpu.h  |    2 -
 36 files changed, 203 insertions(+), 206 deletions(-)

--- a/drivers/staging/epl/amix86.c
+++ b/drivers/staging/epl/amix86.c
@@ -84,7 +84,7 @@ typedef struct {
 } twStruct;
 
 typedef struct {
-	DWORD m_dwDword;
+	u32 m_dwDword;
 
 } tdwStruct;
 
@@ -140,9 +140,9 @@ void AmiSetWordToBe(void * pAddr_p, WORD
 
 }
 
-//------------< write DWORD in big endian >-------------------------
+//------------< write u32 in big endian >-------------------------
 
-void AmiSetDwordToBe(void *pAddr_p, DWORD dwDwordVal_p)
+void AmiSetDwordToBe(void *pAddr_p, u32 dwDwordVal_p)
 {
 	tdwStruct *pdwStruct;
 	tdwStruct dwValue;
@@ -194,9 +194,9 @@ void AmiSetWordToLe(void *pAddr_p, WORD 
 
 }
 
-//------------< write DWORD in little endian >-------------------------
+//------------< write u32 in little endian >-------------------------
 
-void AmiSetDwordToLe(void *pAddr_p, DWORD dwDwordVal_p)
+void AmiSetDwordToLe(void *pAddr_p, u32 dwDwordVal_p)
 {
 	tdwStruct *pdwStruct;
 
@@ -246,9 +246,9 @@ WORD AmiGetWordFromBe(void *pAddr_p)
 
 }
 
-//------------< read DWORD in big endian >--------------------------
+//------------< read u32 in big endian >--------------------------
 
-DWORD AmiGetDwordFromBe(void *pAddr_p)
+u32 AmiGetDwordFromBe(void *pAddr_p)
 {
 	tdwStruct *pdwStruct;
 	tdwStruct dwValue;
@@ -299,9 +299,9 @@ WORD AmiGetWordFromLe(void *pAddr_p)
 	return (pwStruct->m_wWord);
 }
 
-//------------< read DWORD in little endian >--------------------------
+//------------< read u32 in little endian >--------------------------
 
-DWORD AmiGetDwordFromLe(void *pAddr_p)
+u32 AmiGetDwordFromLe(void *pAddr_p)
 {
 	tdwStruct *pdwStruct;
 
@@ -324,7 +324,7 @@ DWORD AmiGetDwordFromLe(void *pAddr_p)
 //
 //---------------------------------------------------------------------------
 
-void AmiSetDword24ToBe(void *pAddr_p, DWORD dwDwordVal_p)
+void AmiSetDword24ToBe(void *pAddr_p, u32 dwDwordVal_p)
 {
 	((u8 *) pAddr_p)[0] = ((u8 *) & dwDwordVal_p)[2];
 	((u8 *) pAddr_p)[1] = ((u8 *) & dwDwordVal_p)[1];
@@ -346,7 +346,7 @@ void AmiSetDword24ToBe(void *pAddr_p, DW
 //
 //---------------------------------------------------------------------------
 
-void AmiSetDword24ToLe(void *pAddr_p, DWORD dwDwordVal_p)
+void AmiSetDword24ToLe(void *pAddr_p, u32 dwDwordVal_p)
 {
 	((u8 *) pAddr_p)[0] = ((u8 *) & dwDwordVal_p)[0];
 	((u8 *) pAddr_p)[1] = ((u8 *) & dwDwordVal_p)[1];
@@ -361,12 +361,12 @@ void AmiSetDword24ToLe(void *pAddr_p, DW
 //
 // Parameters:  pAddr_p         = pointer to source buffer
 //
-// Return:      DWORD           = read value
+// Return:      u32           = read value
 //
 // State:       not tested
 //
 //---------------------------------------------------------------------------
-DWORD AmiGetDword24FromBe(void *pAddr_p)
+u32 AmiGetDword24FromBe(void *pAddr_p)
 {
 	tdwStruct dwStruct;
 
@@ -384,12 +384,12 @@ DWORD AmiGetDword24FromBe(void *pAddr_p)
 //
 // Parameters:  pAddr_p         = pointer to source buffer
 //
-// Return:      DWORD           = read value
+// Return:      u32           = read value
 //
 // State:       not tested
 //
 //---------------------------------------------------------------------------
-DWORD AmiGetDword24FromLe(void *pAddr_p)
+u32 AmiGetDword24FromLe(void *pAddr_p)
 {
 	tdwStruct dwStruct;
 
@@ -546,7 +546,7 @@ void AmiSetQword40ToBe(void *pAddr_p, u6
 void AmiSetQword40ToLe(void *pAddr_p, u64 qwQwordVal_p)
 {
 
-	((DWORD *) pAddr_p)[0] = ((DWORD *) & qwQwordVal_p)[0];
+	((u32 *) pAddr_p)[0] = ((u32 *) & qwQwordVal_p)[0];
 	((u8 *) pAddr_p)[4] = ((u8 *) & qwQwordVal_p)[4];
 
 }
@@ -648,7 +648,7 @@ void AmiSetQword48ToBe(void *pAddr_p, u6
 void AmiSetQword48ToLe(void *pAddr_p, u64 qwQwordVal_p)
 {
 
-	((DWORD *) pAddr_p)[0] = ((DWORD *) & qwQwordVal_p)[0];
+	((u32 *) pAddr_p)[0] = ((u32 *) & qwQwordVal_p)[0];
 	((WORD *) pAddr_p)[2] = ((WORD *) & qwQwordVal_p)[2];
 
 }
@@ -751,7 +751,7 @@ void AmiSetQword56ToBe(void *pAddr_p, u6
 void AmiSetQword56ToLe(void *pAddr_p, u64 qwQwordVal_p)
 {
 
-	((DWORD *) pAddr_p)[0] = ((DWORD *) & qwQwordVal_p)[0];
+	((u32 *) pAddr_p)[0] = ((u32 *) & qwQwordVal_p)[0];
 	((WORD *) pAddr_p)[2] = ((WORD *) & qwQwordVal_p)[2];
 	((u8 *) pAddr_p)[6] = ((u8 *) & qwQwordVal_p)[6];
 
--- a/drivers/staging/epl/Debug.h
+++ b/drivers/staging/epl/Debug.h
@@ -666,7 +666,7 @@ extern "C" {
                                                     DEBUG_LVL_ASSERT_TRACE4 ( \
                                                         "Assertion failed: line %d file '%s'\n" \
                                                         "    -> '%s'\n" \
-                                                        "    -> 0x%08lX\n", __LINE__, __FILE__, str, (DWORD) p1); \
+                                                        "    -> 0x%08lX\n", __LINE__, __FILE__, str, (u32) p1); \
                                                     while (1); }
 
 
--- a/drivers/staging/epl/demo_main.c
+++ b/drivers/staging/epl/demo_main.c
@@ -156,12 +156,12 @@ u8 bVarOut1Old_l;
 u8 bModeSelect_l;		// state of the pushbuttons to select the mode
 u8 bSpeedSelect_l;		// state of the pushbuttons to increase/decrease the speed
 u8 bSpeedSelectOld_l;		// old state of the pushbuttons
-DWORD dwLeds_l;			// current state of all LEDs
+u32 dwLeds_l;			// current state of all LEDs
 u8 bLedsRow1_l;		// current state of the LEDs in row 1
 u8 bLedsRow2_l;		// current state of the LEDs in row 2
 u8 abSelect_l[3];		// pushbuttons from CNs
 
-DWORD dwMode_l;			// current mode
+u32 dwMode_l;			// current mode
 int iCurCycleCount_l;		// current cycle count
 int iMaxCycleCount_l;		// maximum cycle count (i.e. number of cycles until next light movement step)
 int iToggle;			// indicates the light movement direction
@@ -171,7 +171,7 @@ u8 abDomain_l[3000];
 static wait_queue_head_t WaitQueueShutdown_g;	// wait queue for tEplNmtEventSwitchOff
 static atomic_t AtomicShutdown_g = ATOMIC_INIT(FALSE);
 
-static DWORD dw_le_CycleLen_g;
+static u32 dw_le_CycleLen_g;
 
 static uint uiNodeId_g = EPL_C_ADR_INVALID;
 module_param_named(nodeid, uiNodeId_g, uint, 0);
@@ -401,7 +401,7 @@ static int __init EplLinInit(void)
 
 	// configure IP address of virtual network interface
 	// for TCP/IP communication over the POWERLINK network
-	sprintf(sBuffer, "%lu.%lu.%lu.%lu",
+	sprintf(sBuffer, "%u.%u.%u.%u",
 		(EplApiInitParam.m_dwIpAddress >> 24),
 		((EplApiInitParam.m_dwIpAddress >> 16) & 0xFF),
 		((EplApiInitParam.m_dwIpAddress >> 8) & 0xFF),
@@ -515,7 +515,7 @@ tEplKernel AppCbEvent(tEplApiEventType E
 
 			case kEplNmtGsResetCommunication:
 				{
-					DWORD dwBuffer;
+					u32 dwBuffer;
 
 					// configure OD for MN in state ResetComm after reseting the OD
 					// TODO: setup your own network configuration here
@@ -677,8 +677,8 @@ tEplKernel AppCbEvent(tEplApiEventType E
 
 			case kEplEventSourceDllk:
 				{	// error occured within the data link layer (e.g. interrupt processing)
-					// the DWORD argument contains the DLL state and the NMT event
-					printk(" val=%lX\n",
+					// the u32 argument contains the DLL state and the NMT event
+					printk(" val=%X\n",
 					       pEventArg_p->m_InternalError.
 					       m_Arg.m_dwArg);
 					break;
--- a/drivers/staging/epl/Edrv8139.c
+++ b/drivers/staging/epl/Edrv8139.c
@@ -235,7 +235,7 @@
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
 void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
-void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+void TgtDbgPostTraceValue(u32 dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
@@ -456,7 +456,7 @@ tEplKernel EdrvShutdown(void)
 tEplKernel EdrvDefineRxMacAddrEntry(u8 * pbMacAddr_p)
 {
 	tEplKernel Ret = kEplSuccessful;
-	DWORD dwData;
+	u32 dwData;
 	u8 bHash;
 
 	bHash = EdrvCalcHash(pbMacAddr_p);
@@ -497,7 +497,7 @@ tEplKernel EdrvDefineRxMacAddrEntry(u8 *
 tEplKernel EdrvUndefineRxMacAddrEntry(u8 * pbMacAddr_p)
 {
 	tEplKernel Ret = kEplSuccessful;
-	DWORD dwData;
+	u32 dwData;
 	u8 bHash;
 
 	bHash = EdrvCalcHash(pbMacAddr_p);
@@ -532,7 +532,7 @@ tEplKernel EdrvUndefineRxMacAddrEntry(u8
 tEplKernel EdrvAllocTxMsgBuffer(tEdrvTxBuffer * pBuffer_p)
 {
 	tEplKernel Ret = kEplSuccessful;
-	DWORD i;
+	u32 i;
 
 	if (pBuffer_p->m_uiMaxBufferLen > EDRV_MAX_FRAME_SIZE) {
 		Ret = kEplEdrvNoFreeBufEntry;
@@ -605,7 +605,7 @@ tEplKernel EdrvSendTxMsg(tEdrvTxBuffer *
 {
 	tEplKernel Ret = kEplSuccessful;
 	unsigned int uiBufferNumber;
-	DWORD dwTemp;
+	u32 dwTemp;
 
 	uiBufferNumber = pBuffer_p->m_uiBufferNumber;
 
@@ -620,8 +620,8 @@ tEplKernel EdrvSendTxMsg(tEdrvTxBuffer *
 		dwTemp =
 		    EDRV_REGDW_READ((EDRV_REGDW_TSD0 +
 				     (EdrvInstance_l.m_uiCurTxDesc *
-				      sizeof(DWORD))));
-		printk("%s InvOp TSD%u = 0x%08lX", __func__,
+				      sizeof(u32))));
+		printk("%s InvOp TSD%u = 0x%08X", __func__,
 		       EdrvInstance_l.m_uiCurTxDesc, dwTemp);
 		printk("  Cmd = 0x%02X\n",
 		       (WORD) EDRV_REGB_READ(EDRV_REGB_COMMAND));
@@ -640,22 +640,22 @@ tEplKernel EdrvSendTxMsg(tEdrvTxBuffer *
 	}
 	// set DMA address of buffer
 	EDRV_REGDW_WRITE((EDRV_REGDW_TSAD0 +
-			  (EdrvInstance_l.m_uiCurTxDesc * sizeof(DWORD))),
+			  (EdrvInstance_l.m_uiCurTxDesc * sizeof(u32))),
 			 (EdrvInstance_l.m_pTxBufDma +
 			  (uiBufferNumber * EDRV_MAX_FRAME_SIZE)));
 	dwTemp =
 	    EDRV_REGDW_READ((EDRV_REGDW_TSAD0 +
-			     (EdrvInstance_l.m_uiCurTxDesc * sizeof(DWORD))));
+			     (EdrvInstance_l.m_uiCurTxDesc * sizeof(u32))));
 //    printk("%s TSAD%u = 0x%08lX", __func__, EdrvInstance_l.m_uiCurTxDesc, dwTemp);
 
 	// start transmission
 	EDRV_REGDW_WRITE((EDRV_REGDW_TSD0 +
-			  (EdrvInstance_l.m_uiCurTxDesc * sizeof(DWORD))),
+			  (EdrvInstance_l.m_uiCurTxDesc * sizeof(u32))),
 			 (EDRV_REGDW_TSD_TXTH_DEF | pBuffer_p->m_uiTxMsgLen));
 	dwTemp =
 	    EDRV_REGDW_READ((EDRV_REGDW_TSD0 +
-			     (EdrvInstance_l.m_uiCurTxDesc * sizeof(DWORD))));
-//    printk(" TSD%u = 0x%08lX / 0x%08lX\n", EdrvInstance_l.m_uiCurTxDesc, dwTemp, (DWORD)(EDRV_REGDW_TSD_TXTH_DEF | pBuffer_p->m_uiTxMsgLen));
+			     (EdrvInstance_l.m_uiCurTxDesc * sizeof(u32))));
+//    printk(" TSD%u = 0x%08lX / 0x%08lX\n", EdrvInstance_l.m_uiCurTxDesc, dwTemp, (u32)(EDRV_REGDW_TSD_TXTH_DEF | pBuffer_p->m_uiTxMsgLen));
 
       Exit:
 	return Ret;
@@ -762,8 +762,8 @@ static int TgtEthIsr(int nIrqNum_p, void
 	tEdrvRxBuffer RxBuffer;
 	tEdrvTxBuffer *pTxBuffer;
 	WORD wStatus;
-	DWORD dwTxStatus;
-	DWORD dwRxStatus;
+	u32 dwTxStatus;
+	u32 dwRxStatus;
 	WORD wCurRx;
 	u8 *pbRxBuf;
 	unsigned int uiLength;
@@ -793,7 +793,7 @@ static int TgtEthIsr(int nIrqNum_p, void
 		dwTxStatus =
 		    EDRV_REGDW_READ((EDRV_REGDW_TSD0 +
 				     (EdrvInstance_l.m_uiCurTxDesc *
-				      sizeof(DWORD))));
+				      sizeof(u32))));
 		if ((dwTxStatus & (EDRV_REGDW_TSD_TOK | EDRV_REGDW_TSD_TABT | EDRV_REGDW_TSD_TUN)) != 0) {	// transmit finished
 			EdrvInstance_l.m_uiCurTxDesc =
 			    (EdrvInstance_l.m_uiCurTxDesc + 1) & 0x03;
@@ -855,8 +855,8 @@ static int TgtEthIsr(int nIrqNum_p, void
 			// calculate pointer to current frame in receive buffer
 			pbRxBuf = EdrvInstance_l.m_pbRxBuf + wCurRx;
 
-			// read receive status DWORD
-			dwRxStatus = le32_to_cpu(*((DWORD *) pbRxBuf));
+			// read receive status u32
+			dwRxStatus = le32_to_cpu(*((u32 *) pbRxBuf));
 
 			// calculate length of received frame
 			uiLength = dwRxStatus >> 16;
@@ -896,7 +896,7 @@ static int TgtEthIsr(int nIrqNum_p, void
 				    m_pfnRxHandler(&RxBuffer);
 			}
 
-			// calulate new offset (DWORD aligned)
+			// calulate new offset (u32 aligned)
 			wCurRx =
 			    (WORD) ((wCurRx + uiLength + sizeof(dwRxStatus) +
 				     3) & ~0x3);
@@ -941,7 +941,7 @@ static int TgtEthIsr(int nIrqNum_p, void
 static int EdrvInitOne(struct pci_dev *pPciDev, const struct pci_device_id *pId)
 {
 	int iResult = 0;
-	DWORD dwTemp;
+	u32 dwTemp;
 
 	if (EdrvInstance_l.m_pPciDev != NULL) {	// Edrv is already connected to a PCI device
 		printk("%s device %s discarded\n", __func__,
@@ -1008,7 +1008,7 @@ static int EdrvInitOne(struct pci_dev *p
 	dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TCR);
 	if (((dwTemp & EDRV_REGDW_TCR_VER_MASK) != EDRV_REGDW_TCR_VER_C)
 	    && ((dwTemp & EDRV_REGDW_TCR_VER_MASK) != EDRV_REGDW_TCR_VER_D)) {	// unsupported chip
-		printk("%s Unsupported chip! TCR = 0x%08lX\n", __func__,
+		printk("%s Unsupported chip! TCR = 0x%08X\n", __func__,
 		       dwTemp);
 		iResult = -ENODEV;
 		goto Exit;
@@ -1043,11 +1043,11 @@ static int EdrvInitOne(struct pci_dev *p
             printk("%s set local MAC address\n", __func__);
             // write this MAC address to controller
             EDRV_REGDW_WRITE(EDRV_REGDW_IDR0,
-                le32_to_cpu(*((DWORD*)&EdrvInstance_l.m_InitParam.m_abMyMacAddr[0])));
+                le32_to_cpu(*((u32*)&EdrvInstance_l.m_InitParam.m_abMyMacAddr[0])));
             dwTemp = EDRV_REGDW_READ(EDRV_REGDW_IDR0);
 
             EDRV_REGDW_WRITE(EDRV_REGDW_IDR4,
-                le32_to_cpu(*((DWORD*)&EdrvInstance_l.m_InitParam.m_abMyMacAddr[4])));
+                le32_to_cpu(*((u32*)&EdrvInstance_l.m_InitParam.m_abMyMacAddr[4])));
             dwTemp = EDRV_REGDW_READ(EDRV_REGDW_IDR4);
             break;
         }
@@ -1217,11 +1217,11 @@ static void EdrvRemoveOne(struct pci_dev
 
 static u8 EdrvCalcHash(u8 * pbMAC_p)
 {
-	DWORD dwByteCounter;
-	DWORD dwBitCounter;
-	DWORD dwData;
-	DWORD dwCrc;
-	DWORD dwCarry;
+	u32 dwByteCounter;
+	u32 dwBitCounter;
+	u32 dwData;
+	u32 dwCrc;
+	u32 dwCarry;
 	u8 *pbData;
 	u8 bHash;
 
--- a/drivers/staging/epl/EplAmi.h
+++ b/drivers/staging/epl/EplAmi.h
@@ -111,9 +111,9 @@ extern "C" {
 #define AmiSetByteToLe(pAddr_p, bByteVal_p)  {*(u8 *)(pAddr_p) = (bByteVal_p);}
 
 void AmiSetWordToBe(void *pAddr_p, WORD wWordVal_p);
-void AmiSetDwordToBe(void *pAddr_p, DWORD dwDwordVal_p);
+void AmiSetDwordToBe(void *pAddr_p, u32 dwDwordVal_p);
 void AmiSetWordToLe(void *pAddr_p, WORD wWordVal_p);
-void AmiSetDwordToLe(void *pAddr_p, DWORD dwDwordVal_p);
+void AmiSetDwordToLe(void *pAddr_p, u32 dwDwordVal_p);
 
 //---------------------------------------------------------------------------
 //
@@ -127,9 +127,9 @@ void AmiSetDwordToLe(void *pAddr_p, DWOR
 #define AmiGetByteFromLe(pAddr_p)  (*(u8 *)(pAddr_p))
 
 WORD AmiGetWordFromBe(void *pAddr_p);
-DWORD AmiGetDwordFromBe(void *pAddr_p);
+u32 AmiGetDwordFromBe(void *pAddr_p);
 WORD AmiGetWordFromLe(void *pAddr_p);
-DWORD AmiGetDwordFromLe(void *pAddr_p);
+u32 AmiGetDwordFromLe(void *pAddr_p);
 
 //---------------------------------------------------------------------------
 //
@@ -144,8 +144,8 @@ DWORD AmiGetDwordFromLe(void *pAddr_p);
 //
 //---------------------------------------------------------------------------
 
-void AmiSetDword24ToBe(void *pAddr_p, DWORD dwDwordVal_p);
-void AmiSetDword24ToLe(void *pAddr_p, DWORD dwDwordVal_p);
+void AmiSetDword24ToBe(void *pAddr_p, u32 dwDwordVal_p);
+void AmiSetDword24ToLe(void *pAddr_p, u32 dwDwordVal_p);
 
 //---------------------------------------------------------------------------
 //
@@ -155,12 +155,12 @@ void AmiSetDword24ToLe(void *pAddr_p, DW
 //
 // Parameters:  pAddr_p         = pointer to source buffer
 //
-// Return:      DWORD           = read value
+// Return:      u32           = read value
 //
 //---------------------------------------------------------------------------
 
-DWORD AmiGetDword24FromBe(void *pAddr_p);
-DWORD AmiGetDword24FromLe(void *pAddr_p);
+u32 AmiGetDword24FromBe(void *pAddr_p);
+u32 AmiGetDword24FromLe(void *pAddr_p);
 
 //#ifdef USE_VAR64
 
--- a/drivers/staging/epl/EplApiGeneric.c
+++ b/drivers/staging/epl/EplApiGeneric.c
@@ -997,8 +997,8 @@ tEplKernel EplApiCbObdAccess(tEplObdCbPa
 		{
 			if ((pParam_p->m_ObdEvent == kEplObdEvPostWrite)
 			    && (pParam_p->m_uiSubIndex == 3)
-			    && (*((DWORD *) pParam_p->m_pArg) != 0)) {
-				DWORD dwVerifyConfInvalid = 0;
+			    && (*((u32 *) pParam_p->m_pArg) != 0)) {
+				u32 dwVerifyConfInvalid = 0;
 				// set CFM_VerifyConfiguration_REC.VerifyConfInvalid_U32 to 0
 				Ret =
 				    EplObdWriteEntry(0x1020, 4,
--- a/drivers/staging/epl/EplDll.h
+++ b/drivers/staging/epl/EplDll.h
@@ -135,22 +135,22 @@ typedef struct {
 	unsigned int m_uiNodeId;	// local node ID
 
 	// 0x1F82: NMT_FeatureFlags_U32
-	DWORD m_dwFeatureFlags;
+	u32 m_dwFeatureFlags;
 	// Cycle Length (0x1006: NMT_CycleLen_U32) in [us]
-	DWORD m_dwCycleLen;	// required for error detection
+	u32 m_dwCycleLen;	// required for error detection
 	// 0x1F98: NMT_CycleTiming_REC
 	// 0x1F98.1: IsochrTxMaxPayload_U16
 	unsigned int m_uiIsochrTxMaxPayload;	// const
 	// 0x1F98.2: IsochrRxMaxPayload_U16
 	unsigned int m_uiIsochrRxMaxPayload;	// const
 	// 0x1F98.3: PResMaxLatency_U32
-	DWORD m_dwPresMaxLatency;	// const in [ns], only required for IdentRes
+	u32 m_dwPresMaxLatency;	// const in [ns], only required for IdentRes
 	// 0x1F98.4: PReqActPayloadLimit_U16
 	unsigned int m_uiPreqActPayloadLimit;	// required for initialisation (+24 bytes)
 	// 0x1F98.5: PResActPayloadLimit_U16
 	unsigned int m_uiPresActPayloadLimit;	// required for initialisation of Pres frame (+24 bytes)
 	// 0x1F98.6: ASndMaxLatency_U32
-	DWORD m_dwAsndMaxLatency;	// const in [ns], only required for IdentRes
+	u32 m_dwAsndMaxLatency;	// const in [ns], only required for IdentRes
 	// 0x1F98.7: MultiplCycleCnt_U8
 	unsigned int m_uiMultiplCycleCnt;	// required for error detection
 	// 0x1F98.8: AsyncMTU_U16
@@ -159,32 +159,32 @@ typedef struct {
 	// $$$ Multiplexed Slot
 
 	// 0x1C14: DLL_LossOfFrameTolerance_U32 in [ns]
-	DWORD m_dwLossOfFrameTolerance;
+	u32 m_dwLossOfFrameTolerance;
 
 	// 0x1F8A: NMT_MNCycleTiming_REC
 	// 0x1F8A.1: WaitSoCPReq_U32 in [ns]
-	DWORD m_dwWaitSocPreq;
+	u32 m_dwWaitSocPreq;
 
 	// 0x1F8A.2: AsyncSlotTimeout_U32 in [ns]
-	DWORD m_dwAsyncSlotTimeout;
+	u32 m_dwAsyncSlotTimeout;
 
 } tEplDllConfigParam;
 
 typedef struct {
 	unsigned int m_uiSizeOfStruct;
-	DWORD m_dwDeviceType;	// NMT_DeviceType_U32
-	DWORD m_dwVendorId;	// NMT_IdentityObject_REC.VendorId_U32
-	DWORD m_dwProductCode;	// NMT_IdentityObject_REC.ProductCode_U32
-	DWORD m_dwRevisionNumber;	// NMT_IdentityObject_REC.RevisionNo_U32
-	DWORD m_dwSerialNumber;	// NMT_IdentityObject_REC.SerialNo_U32
+	u32 m_dwDeviceType;	// NMT_DeviceType_U32
+	u32 m_dwVendorId;	// NMT_IdentityObject_REC.VendorId_U32
+	u32 m_dwProductCode;	// NMT_IdentityObject_REC.ProductCode_U32
+	u32 m_dwRevisionNumber;	// NMT_IdentityObject_REC.RevisionNo_U32
+	u32 m_dwSerialNumber;	// NMT_IdentityObject_REC.SerialNo_U32
 	u64 m_qwVendorSpecificExt1;
-	DWORD m_dwVerifyConfigurationDate;	// CFM_VerifyConfiguration_REC.ConfDate_U32
-	DWORD m_dwVerifyConfigurationTime;	// CFM_VerifyConfiguration_REC.ConfTime_U32
-	DWORD m_dwApplicationSwDate;	// PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
-	DWORD m_dwApplicationSwTime;	// PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
-	DWORD m_dwIpAddress;
-	DWORD m_dwSubnetMask;
-	DWORD m_dwDefaultGateway;
+	u32 m_dwVerifyConfigurationDate;	// CFM_VerifyConfiguration_REC.ConfDate_U32
+	u32 m_dwVerifyConfigurationTime;	// CFM_VerifyConfiguration_REC.ConfTime_U32
+	u32 m_dwApplicationSwDate;	// PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
+	u32 m_dwApplicationSwTime;	// PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
+	u32 m_dwIpAddress;
+	u32 m_dwSubnetMask;
+	u32 m_dwDefaultGateway;
 	u8 m_sHostname[32];
 	u8 m_abVendorSpecificExt2[48];
 
@@ -194,7 +194,7 @@ typedef struct {
 	unsigned int m_uiNodeId;
 	WORD m_wPreqPayloadLimit;	// object 0x1F8B: NMT_MNPReqPayloadLimitList_AU16
 	WORD m_wPresPayloadLimit;	// object 0x1F8D: NMT_PResPayloadLimitList_AU16
-	DWORD m_dwPresTimeout;	// object 0x1F92: NMT_MNCNPResTimeout_AU32
+	u32 m_dwPresTimeout;	// object 0x1F92: NMT_MNCNPResTimeout_AU32
 
 } tEplDllNodeInfo;
 
--- a/drivers/staging/epl/EplDllk.c
+++ b/drivers/staging/epl/EplDllk.c
@@ -122,7 +122,7 @@
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
 void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
-void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+void TgtDbgPostTraceValue(u32 dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
@@ -3154,7 +3154,7 @@ static void EplDllkCbFrameReceived(tEdrv
 
       Exit:
 	if (Ret != kEplSuccessful) {
-		DWORD dwArg;
+		u32 dwArg;
 
 		BENCHMARK_MOD_02_TOGGLE(9);
 
@@ -3448,7 +3448,7 @@ static void EplDllkCbFrameTransmitted(tE
 
       Exit:
 	if (Ret != kEplSuccessful) {
-		DWORD dwArg;
+		u32 dwArg;
 
 		BENCHMARK_MOD_02_TOGGLE(9);
 
@@ -3582,7 +3582,7 @@ static tEplKernel EplDllkCbCnTimer(tEplT
 
       Exit:
 	if (Ret != kEplSuccessful) {
-		DWORD dwArg;
+		u32 dwArg;
 
 		BENCHMARK_MOD_02_TOGGLE(9);
 
@@ -3638,7 +3638,7 @@ static tEplKernel EplDllkCbMnTimerCycle(
 
       Exit:
 	if (Ret != kEplSuccessful) {
-		DWORD dwArg;
+		u32 dwArg;
 
 		BENCHMARK_MOD_02_TOGGLE(9);
 
@@ -3691,7 +3691,7 @@ static tEplKernel EplDllkCbMnTimerRespon
 
       Exit:
 	if (Ret != kEplSuccessful) {
-		DWORD dwArg;
+		u32 dwArg;
 
 		BENCHMARK_MOD_02_TOGGLE(9);
 
--- a/drivers/staging/epl/EplErrorHandlerk.c
+++ b/drivers/staging/epl/EplErrorHandlerk.c
@@ -97,9 +97,9 @@
 //---------------------------------------------------------------------------
 
 typedef struct {
-	DWORD m_dwCumulativeCnt;	// subindex 1
-	DWORD m_dwThresholdCnt;	// subindex 2
-	DWORD m_dwThreshold;	// subindex 3
+	u32 m_dwCumulativeCnt;	// subindex 1
+	u32 m_dwThresholdCnt;	// subindex 2
+	u32 m_dwThreshold;	// subindex 3
 
 } tEplErrorHandlerkErrorCounter;
 
@@ -112,9 +112,9 @@ typedef struct {
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 	tEplErrorHandlerkErrorCounter m_MnCrcErr;	// object 0x1C00
 	tEplErrorHandlerkErrorCounter m_MnCycTimeExceed;	// object 0x1C02
-	DWORD m_adwMnCnLossPresCumCnt[254];	// object 0x1C07
-	DWORD m_adwMnCnLossPresThrCnt[254];	// object 0x1C08
-	DWORD m_adwMnCnLossPresThreshold[254];	// object 0x1C09
+	u32 m_adwMnCnLossPresCumCnt[254];	// object 0x1C07
+	u32 m_adwMnCnLossPresThrCnt[254];	// object 0x1C08
+	u32 m_adwMnCnLossPresThreshold[254];	// object 0x1C09
 	BOOL m_afMnCnLossPresEvent[254];
 #endif
 
@@ -135,7 +135,7 @@ static tEplKernel EplErrorHandlerkLinkEr
 						   unsigned int uiIndex_p);
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-static tEplKernel EplErrorHandlerkLinkArray(DWORD * pdwValue_p,
+static tEplKernel EplErrorHandlerkLinkArray(u32 * pdwValue_p,
 					    unsigned int uiValueCount_p,
 					    unsigned int uiIndex_p);
 #endif
@@ -713,7 +713,7 @@ static tEplKernel EplErrorHandlerkLinkEr
 	tEplVarParam VarParam;
 
 	VarParam.m_pData = &pErrorCounter_p->m_dwCumulativeCnt;
-	VarParam.m_Size = sizeof(DWORD);
+	VarParam.m_Size = sizeof(u32);
 	VarParam.m_uiIndex = uiIndex_p;
 	VarParam.m_uiSubindex = 0x01;
 	VarParam.m_ValidFlag = kVarValidAll;
@@ -723,7 +723,7 @@ static tEplKernel EplErrorHandlerkLinkEr
 	}
 
 	VarParam.m_pData = &pErrorCounter_p->m_dwThresholdCnt;
-	VarParam.m_Size = sizeof(DWORD);
+	VarParam.m_Size = sizeof(u32);
 	VarParam.m_uiIndex = uiIndex_p;
 	VarParam.m_uiSubindex = 0x02;
 	VarParam.m_ValidFlag = kVarValidAll;
@@ -733,7 +733,7 @@ static tEplKernel EplErrorHandlerkLinkEr
 	}
 
 	VarParam.m_pData = &pErrorCounter_p->m_dwThreshold;
-	VarParam.m_Size = sizeof(DWORD);
+	VarParam.m_Size = sizeof(u32);
 	VarParam.m_uiIndex = uiIndex_p;
 	VarParam.m_uiSubindex = 0x03;
 	VarParam.m_ValidFlag = kVarValidAll;
@@ -763,7 +763,7 @@ static tEplKernel EplErrorHandlerkLinkEr
 //---------------------------------------------------------------------------
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-static tEplKernel EplErrorHandlerkLinkArray(DWORD * pdwValue_p,
+static tEplKernel EplErrorHandlerkLinkArray(u32 * pdwValue_p,
 					    unsigned int uiValueCount_p,
 					    unsigned int uiIndex_p)
 {
@@ -786,7 +786,7 @@ static tEplKernel EplErrorHandlerkLinkAr
 		uiValueCount_p = bIndexEntries;
 	}
 
-	VarParam.m_Size = sizeof(DWORD);
+	VarParam.m_Size = sizeof(u32);
 	VarParam.m_uiIndex = uiIndex_p;
 	VarParam.m_ValidFlag = kVarValidAll;
 
--- a/drivers/staging/epl/EplEvent.h
+++ b/drivers/staging/epl/EplEvent.h
@@ -249,7 +249,7 @@ typedef struct {
 	tEplKernel m_EplError;	// EPL error which occured
 	union {
 		u8 m_bArg;
-		DWORD m_dwArg;
+		u32 m_dwArg;
 		tEplEventSource m_EventSource;	// from Eventk/u module (originating error source)
 		tEplEventObdError m_ObdError;	// from Obd module
 //        tEplErrHistoryEntry     m_HistoryEntry; // from Nmtk/u module
--- a/drivers/staging/epl/EplEventk.c
+++ b/drivers/staging/epl/EplEventk.c
@@ -101,7 +101,7 @@
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
 void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
-void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+void TgtDbgPostTraceValue(u32 dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
--- a/drivers/staging/epl/EplEventu.c
+++ b/drivers/staging/epl/EplEventu.c
@@ -97,7 +97,7 @@
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
 void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
-void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+void TgtDbgPostTraceValue(u32 dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
--- a/drivers/staging/epl/EplFrame.h
+++ b/drivers/staging/epl/EplFrame.h
@@ -214,25 +214,25 @@ typedef struct {
 	u8 m_le_bIdentRespFlags;	// Flags: FW
 	u8 m_le_bEplProfileVersion;
 	u8 m_le_bRes1;
-	DWORD m_le_dwFeatureFlags;	// NMT_FeatureFlags_U32
+	u32 m_le_dwFeatureFlags;	// NMT_FeatureFlags_U32
 	WORD m_le_wMtu;		// NMT_CycleTiming_REC.AsyncMTU_U16: C_IP_MIN_MTU - C_IP_MAX_MTU
 	WORD m_le_wPollInSize;	// NMT_CycleTiming_REC.PReqActPayload_U16
 	WORD m_le_wPollOutSize;	// NMT_CycleTiming_REC.PResActPayload_U16
-	DWORD m_le_dwResponseTime;	// NMT_CycleTiming_REC.PResMaxLatency_U32
+	u32 m_le_dwResponseTime;	// NMT_CycleTiming_REC.PResMaxLatency_U32
 	WORD m_le_wRes2;
-	DWORD m_le_dwDeviceType;	// NMT_DeviceType_U32
-	DWORD m_le_dwVendorId;	// NMT_IdentityObject_REC.VendorId_U32
-	DWORD m_le_dwProductCode;	// NMT_IdentityObject_REC.ProductCode_U32
-	DWORD m_le_dwRevisionNumber;	// NMT_IdentityObject_REC.RevisionNo_U32
-	DWORD m_le_dwSerialNumber;	// NMT_IdentityObject_REC.SerialNo_U32
+	u32 m_le_dwDeviceType;	// NMT_DeviceType_U32
+	u32 m_le_dwVendorId;	// NMT_IdentityObject_REC.VendorId_U32
+	u32 m_le_dwProductCode;	// NMT_IdentityObject_REC.ProductCode_U32
+	u32 m_le_dwRevisionNumber;	// NMT_IdentityObject_REC.RevisionNo_U32
+	u32 m_le_dwSerialNumber;	// NMT_IdentityObject_REC.SerialNo_U32
 	u64 m_le_qwVendorSpecificExt1;
-	DWORD m_le_dwVerifyConfigurationDate;	// CFM_VerifyConfiguration_REC.ConfDate_U32
-	DWORD m_le_dwVerifyConfigurationTime;	// CFM_VerifyConfiguration_REC.ConfTime_U32
-	DWORD m_le_dwApplicationSwDate;	// PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
-	DWORD m_le_dwApplicationSwTime;	// PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
-	DWORD m_le_dwIpAddress;
-	DWORD m_le_dwSubnetMask;
-	DWORD m_le_dwDefaultGateway;
+	u32 m_le_dwVerifyConfigurationDate;	// CFM_VerifyConfiguration_REC.ConfDate_U32
+	u32 m_le_dwVerifyConfigurationTime;	// CFM_VerifyConfiguration_REC.ConfTime_U32
+	u32 m_le_dwApplicationSwDate;	// PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
+	u32 m_le_dwApplicationSwTime;	// PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
+	u32 m_le_dwIpAddress;
+	u32 m_le_dwSubnetMask;
+	u32 m_le_dwDefaultGateway;
 	u8 m_le_sHostname[32];
 	u8 m_le_abVendorSpecificExt2[48];
 
--- a/drivers/staging/epl/Epl.h
+++ b/drivers/staging/epl/Epl.h
@@ -142,22 +142,22 @@ typedef struct {
 	u8 m_abMacAddress[6];	// local MAC address
 
 	// 0x1F82: NMT_FeatureFlags_U32
-	DWORD m_dwFeatureFlags;
+	u32 m_dwFeatureFlags;
 	// Cycle Length (0x1006: NMT_CycleLen_U32) in [us]
-	DWORD m_dwCycleLen;	// required for error detection
+	u32 m_dwCycleLen;	// required for error detection
 	// 0x1F98: NMT_CycleTiming_REC
 	// 0x1F98.1: IsochrTxMaxPayload_U16
 	unsigned int m_uiIsochrTxMaxPayload;	// const
 	// 0x1F98.2: IsochrRxMaxPayload_U16
 	unsigned int m_uiIsochrRxMaxPayload;	// const
 	// 0x1F98.3: PResMaxLatency_U32
-	DWORD m_dwPresMaxLatency;	// const in [ns], only required for IdentRes
+	u32 m_dwPresMaxLatency;	// const in [ns], only required for IdentRes
 	// 0x1F98.4: PReqActPayloadLimit_U16
 	unsigned int m_uiPreqActPayloadLimit;	// required for initialisation (+28 bytes)
 	// 0x1F98.5: PResActPayloadLimit_U16
 	unsigned int m_uiPresActPayloadLimit;	// required for initialisation of Pres frame (+28 bytes)
 	// 0x1F98.6: ASndMaxLatency_U32
-	DWORD m_dwAsndMaxLatency;	// const in [ns], only required for IdentRes
+	u32 m_dwAsndMaxLatency;	// const in [ns], only required for IdentRes
 	// 0x1F98.7: MultiplCycleCnt_U8
 	unsigned int m_uiMultiplCycleCnt;	// required for error detection
 	// 0x1F98.8: AsyncMTU_U16
@@ -167,28 +167,28 @@ typedef struct {
 	// $$$ Multiplexed Slot
 
 	// 0x1C14: DLL_LossOfFrameTolerance_U32 in [ns]
-	DWORD m_dwLossOfFrameTolerance;
+	u32 m_dwLossOfFrameTolerance;
 
 	// 0x1F8A: NMT_MNCycleTiming_REC
 	// 0x1F8A.1: WaitSoCPReq_U32 in [ns]
-	DWORD m_dwWaitSocPreq;
+	u32 m_dwWaitSocPreq;
 
 	// 0x1F8A.2: AsyncSlotTimeout_U32 in [ns]
-	DWORD m_dwAsyncSlotTimeout;
+	u32 m_dwAsyncSlotTimeout;
 
-	DWORD m_dwDeviceType;	// NMT_DeviceType_U32
-	DWORD m_dwVendorId;	// NMT_IdentityObject_REC.VendorId_U32
-	DWORD m_dwProductCode;	// NMT_IdentityObject_REC.ProductCode_U32
-	DWORD m_dwRevisionNumber;	// NMT_IdentityObject_REC.RevisionNo_U32
-	DWORD m_dwSerialNumber;	// NMT_IdentityObject_REC.SerialNo_U32
+	u32 m_dwDeviceType;	// NMT_DeviceType_U32
+	u32 m_dwVendorId;	// NMT_IdentityObject_REC.VendorId_U32
+	u32 m_dwProductCode;	// NMT_IdentityObject_REC.ProductCode_U32
+	u32 m_dwRevisionNumber;	// NMT_IdentityObject_REC.RevisionNo_U32
+	u32 m_dwSerialNumber;	// NMT_IdentityObject_REC.SerialNo_U32
 	u64 m_qwVendorSpecificExt1;
-	DWORD m_dwVerifyConfigurationDate;	// CFM_VerifyConfiguration_REC.ConfDate_U32
-	DWORD m_dwVerifyConfigurationTime;	// CFM_VerifyConfiguration_REC.ConfTime_U32
-	DWORD m_dwApplicationSwDate;	// PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
-	DWORD m_dwApplicationSwTime;	// PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
-	DWORD m_dwIpAddress;
-	DWORD m_dwSubnetMask;
-	DWORD m_dwDefaultGateway;
+	u32 m_dwVerifyConfigurationDate;	// CFM_VerifyConfiguration_REC.ConfDate_U32
+	u32 m_dwVerifyConfigurationTime;	// CFM_VerifyConfiguration_REC.ConfTime_U32
+	u32 m_dwApplicationSwDate;	// PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
+	u32 m_dwApplicationSwTime;	// PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
+	u32 m_dwIpAddress;
+	u32 m_dwSubnetMask;
+	u32 m_dwDefaultGateway;
 	u8 m_sHostname[32];
 	u8 m_abVendorSpecificExt2[48];
 
--- a/drivers/staging/epl/EplIdentu.c
+++ b/drivers/staging/epl/EplIdentu.c
@@ -386,9 +386,9 @@ tEplKernel EplIdentuRequestIdentResponse
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT DWORD EplIdentuGetRunningRequests(void)
+EPLDLLEXPORT u32 EplIdentuGetRunningRequests(void)
 {
-	DWORD dwReqs = 0;
+	u32 dwReqs = 0;
 	unsigned int uiIndex;
 
 	for (uiIndex = 0; uiIndex < 32; uiIndex++) {
--- a/drivers/staging/epl/EplInc.h
+++ b/drivers/staging/epl/EplInc.h
@@ -140,8 +140,8 @@
 
 // IEEE 1588 conformant net time structure
 typedef struct {
-	DWORD m_dwSec;
-	DWORD m_dwNanoSec;
+	u32 m_dwSec;
+	u32 m_dwNanoSec;
 
 } tEplNetTime;
 
@@ -154,8 +154,8 @@ typedef struct {
 // -------------------------------------------------------------------------
 
 #define EPL_SPEC_VERSION                    0x20	// ETHERNET Powerlink V. 2.0
-#define EPL_STACK_VERSION(ver,rev,rel)      ((((DWORD)(ver)) & 0xFF)|((((DWORD)(rev))&0xFF)<<8)|(((DWORD)(rel))<<16))
-#define EPL_OBJ1018_VERSION(ver,rev,rel)    ((((DWORD)(ver))<<16) |(((DWORD)(rev))&0xFFFF))
+#define EPL_STACK_VERSION(ver,rev,rel)      ((((u32)(ver)) & 0xFF)|((((u32)(rev))&0xFF)<<8)|(((u32)(rel))<<16))
+#define EPL_OBJ1018_VERSION(ver,rev,rel)    ((((u32)(ver))<<16) |(((u32)(rev))&0xFFFF))
 #define EPL_STRING_VERSION(ver,rev,rel)     "V" #ver "." #rev " r" #rel
 
 #include "EplVersion.h"
--- a/drivers/staging/epl/EplNmtk.c
+++ b/drivers/staging/epl/EplNmtk.c
@@ -89,7 +89,7 @@
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
 void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
-void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+void TgtDbgPostTraceValue(u32 dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
--- a/drivers/staging/epl/EplNmtMnu.c
+++ b/drivers/staging/epl/EplNmtMnu.c
@@ -95,7 +95,7 @@
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
 void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
-void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+void TgtDbgPostTraceValue(u32 dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
@@ -211,7 +211,7 @@ typedef struct {
 	tEplTimerHdl m_TimerHdlStatReq;	// timer to delay StatusRequests and IdentRequests
 	tEplTimerHdl m_TimerHdlLonger;	// 2nd timer for NMT command EnableReadyToOp and CheckCommunication
 	tEplNmtMnuNodeState m_NodeState;	// internal node state (kind of sub state of NMT state)
-	DWORD m_dwNodeCfg;	// subindex from 0x1F81
+	u32 m_dwNodeCfg;	// subindex from 0x1F81
 	WORD m_wFlags;		// flags: CN is being accessed isochronously
 
 } tEplNmtMnuNodeInfo;
@@ -225,7 +225,7 @@ typedef struct {
 	unsigned long m_ulTimeoutReadyToOp;	// in [ms] (object 0x1F89/5)
 	unsigned long m_ulTimeoutCheckCom;	// in [ms] (object 0x1006 * MultiplexedCycleCount)
 	WORD m_wFlags;		// global flags
-	DWORD m_dwNmtStartup;	// object 0x1F80 NMT_StartUp_U32
+	u32 m_dwNmtStartup;	// object 0x1F80 NMT_StartUp_U32
 	tEplNmtMnuCbNodeEvent m_pfnCbNodeEvent;
 	tEplNmtMnuCbBootEvent m_pfnCbBootEvent;
 
@@ -673,7 +673,7 @@ tEplKernel EplNmtMnuCbNmtStateChange(tEp
 		// build the configuration with infos from OD
 	case kEplNmtGsResetConfiguration:
 		{
-			DWORD dwTimeout;
+			u32 dwTimeout;
 			tEplObdSize ObdSize;
 
 			// read object 0x1F80 NMT_StartUp_U32
@@ -785,7 +785,7 @@ tEplKernel EplNmtMnuCbNmtStateChange(tEp
 		// node processes only async frames
 	case kEplNmtMsPreOperational1:
 		{
-			DWORD dwTimeout;
+			u32 dwTimeout;
 			tEplTimerArg TimerArg;
 			tEplObdSize ObdSize;
 			tEplEvent Event;
@@ -1291,7 +1291,7 @@ tEplKernel EplNmtMnuGetDiagnosticInfo(un
 //
 //---------------------------------------------------------------------------
 /*
-DWORD EplNmtMnuGetRunningTimerStatReq(void)
+u32 EplNmtMnuGetRunningTimerStatReq(void)
 {
 tEplKernel      Ret = kEplSuccessful;
 unsigned int    uiIndex;
@@ -1376,7 +1376,7 @@ static tEplKernel EplNmtMnuCbIdentRespon
 						    kEplNmtMnuIntNodeEventNoIdentResponse);
 	} else {		// node answered IdentRequest
 		tEplObdSize ObdSize;
-		DWORD dwDevType;
+		u32 dwDevType;
 		WORD wErrorCode = EPL_E_NO_ERROR;
 		tEplNmtState NmtState =
 		    (tEplNmtState) (AmiGetByteFromLe
@@ -1466,7 +1466,7 @@ static tEplKernel EplNmtMnuStartBootStep
 	tEplKernel Ret = kEplSuccessful;
 	unsigned int uiSubIndex;
 	unsigned int uiLocalNodeId;
-	DWORD dwNodeCfg;
+	u32 dwNodeCfg;
 	tEplObdSize ObdSize;
 
 	// $$$ d.k.: save current time for 0x1F89/2 MNTimeoutPreOp1_U32
@@ -1626,7 +1626,7 @@ static tEplKernel EplNmtMnuNodeBootStep2
 {
 	tEplKernel Ret = kEplSuccessful;
 	tEplDllNodeInfo DllNodeInfo;
-	DWORD dwNodeCfg;
+	u32 dwNodeCfg;
 	tEplObdSize ObdSize;
 	tEplTimerArg TimerArg;
 
@@ -1775,7 +1775,7 @@ static tEplKernel EplNmtMnuNodeCheckCom(
 					tEplNmtMnuNodeInfo * pNodeInfo_p)
 {
 	tEplKernel Ret = kEplSuccessful;
-	DWORD dwNodeCfg;
+	u32 dwNodeCfg;
 	tEplTimerArg TimerArg;
 
 	dwNodeCfg = pNodeInfo_p->m_dwNodeCfg;
--- a/drivers/staging/epl/EplNmtu.c
+++ b/drivers/staging/epl/EplNmtu.c
@@ -382,7 +382,7 @@ EPLDLLEXPORT tEplKernel EplNmtuProcessEv
 					// node listens for EPL-Frames and check timeout
 				case kEplNmtCsNotActive:
 					{
-						DWORD dwBuffer;
+						u32 dwBuffer;
 						tEplObdSize ObdSize;
 						tEplTimerArg TimerArg;
 
@@ -475,7 +475,7 @@ EPLDLLEXPORT tEplKernel EplNmtuProcessEv
 					// node listens for EPL-Frames and check timeout
 				case kEplNmtMsNotActive:
 					{
-						DWORD dwBuffer;
+						u32 dwBuffer;
 						tEplObdSize ObdSize;
 						tEplTimerArg TimerArg;
 
@@ -544,7 +544,7 @@ EPLDLLEXPORT tEplKernel EplNmtuProcessEv
 					// node processes only async frames
 				case kEplNmtMsPreOperational1:
 					{
-						DWORD dwBuffer = 0;
+						u32 dwBuffer = 0;
 						tEplObdSize ObdSize;
 						tEplTimerArg TimerArg;
 
--- a/drivers/staging/epl/EplObd.c
+++ b/drivers/staging/epl/EplObd.c
@@ -1088,7 +1088,7 @@ EPLDLLEXPORT tEplKernel EplObdReadEntryT
 	case kEplObdTypInt24:
 	case kEplObdTypUInt24:
 		{
-			AmiSetDword24ToLe(pDstData_p, *((DWORD *) pSrcData));
+			AmiSetDword24ToLe(pDstData_p, *((u32 *) pSrcData));
 			break;
 		}
 
@@ -1097,7 +1097,7 @@ EPLDLLEXPORT tEplKernel EplObdReadEntryT
 	case kEplObdTypUInt32:
 	case kEplObdTypReal32:
 		{
-			AmiSetDwordToLe(pDstData_p, *((DWORD *) pSrcData));
+			AmiSetDwordToLe(pDstData_p, *((u32 *) pSrcData));
 			break;
 		}
 
@@ -1238,7 +1238,7 @@ EPLDLLEXPORT tEplKernel EplObdWriteEntry
 	case kEplObdTypInt24:
 	case kEplObdTypUInt24:
 		{
-			*((DWORD *) pBuffer) = AmiGetDword24FromLe(pSrcData_p);
+			*((u32 *) pBuffer) = AmiGetDword24FromLe(pSrcData_p);
 			break;
 		}
 
@@ -1247,7 +1247,7 @@ EPLDLLEXPORT tEplKernel EplObdWriteEntry
 	case kEplObdTypUInt32:
 	case kEplObdTypReal32:
 		{
-			*((DWORD *) pBuffer) = AmiGetDwordFromLe(pSrcData_p);
+			*((u32 *) pBuffer) = AmiGetDwordFromLe(pSrcData_p);
 			break;
 		}
 
--- a/drivers/staging/epl/EplObd.h
+++ b/drivers/staging/epl/EplObd.h
@@ -370,7 +370,7 @@ typedef struct {
 	unsigned int m_uiIndex;
 	unsigned int m_uiSubIndex;
 	void *m_pArg;
-	DWORD m_dwAbortCode;
+	u32 m_dwAbortCode;
 
 } tEplObdCbParam;
 
--- a/drivers/staging/epl/EplObdMacro.h
+++ b/drivers/staging/epl/EplObdMacro.h
@@ -80,7 +80,7 @@
 
 //        #pragma message ("EPL_OBD_CREATE_ROM_DATA")
 
-#define EPL_OBD_BEGIN()                                                         static  DWORD  dwObd_OBK_g = 0x0000;
+#define EPL_OBD_BEGIN()                                                         static  u32  dwObd_OBK_g = 0x0000;
 #define EPL_OBD_END()
 
 	//---------------------------------------------------------------------------------------
--- a/drivers/staging/epl/EplPdou.c
+++ b/drivers/staging/epl/EplPdou.c
@@ -160,7 +160,7 @@ static void EplPdouDecodeObjectMapping(u
 
 static tEplKernel EplPdouCheckObjectMapping(u64 qwObjectMapping_p,
 					    tEplObdAccess AccessType_p,
-					    DWORD * pdwAbortCode_p,
+					    u32 * pdwAbortCode_p,
 					    unsigned int *puiPdoSize_p);
 
 //=========================================================================//
@@ -482,7 +482,7 @@ static void EplPdouDecodeObjectMapping(u
 
 static tEplKernel EplPdouCheckObjectMapping(u64 qwObjectMapping_p,
 					    tEplObdAccess AccessType_p,
-					    DWORD * pdwAbortCode_p,
+					    u32 * pdwAbortCode_p,
 					    unsigned int *puiPdoSize_p)
 {
 	tEplKernel Ret = kEplSuccessful;
--- a/drivers/staging/epl/EplSdoAsndu.c
+++ b/drivers/staging/epl/EplSdoAsndu.c
@@ -321,7 +321,7 @@ tEplKernel EplSdoAsnduInitCon(tEplSdoCon
 //---------------------------------------------------------------------------
 tEplKernel EplSdoAsnduSendData(tEplSdoConHdl SdoConHandle_p,
 			       tEplFrame *pSrcData_p,
-			       DWORD dwDataSize_p)
+			       u32 dwDataSize_p)
 {
 	tEplKernel Ret;
 	unsigned int uiArray;
--- a/drivers/staging/epl/EplSdoComu.c
+++ b/drivers/staging/epl/EplSdoComu.c
@@ -174,7 +174,7 @@ typedef struct {
 	//    the SDO transfer
 	void *m_pUserArg;	// user definable argument pointer
 
-	DWORD m_dwLastAbortCode;	// save the last abort code
+	u32 m_dwLastAbortCode;	// save the last abort code
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
 	// only for client
 	unsigned int m_uiTargetIndex;	// index to access
@@ -246,7 +246,7 @@ static tEplKernel EplSdoComClientProcess
 					      tEplAsySdoCom * pAsySdoCom_p);
 
 static tEplKernel EplSdoComClientSendAbort(tEplSdoComCon * pSdoComCon_p,
-					   DWORD dwAbortCode_p);
+					   u32 dwAbortCode_p);
 #endif
 
 /***************************************************************************/
@@ -747,7 +747,7 @@ tEplKernel EplSdoComGetState(tEplSdoComC
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
 tEplKernel EplSdoComSdoAbort(tEplSdoComConHdl SdoComConHdl_p,
-			     DWORD dwAbortCode_p)
+			     u32 dwAbortCode_p)
 {
 	tEplKernel Ret;
 	tEplSdoComCon *pSdoComCon;
@@ -1001,7 +1001,7 @@ static tEplKernel EplSdoComProcessIntern
 	u8 bFlag;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
-	DWORD dwAbortCode;
+	u32 dwAbortCode;
 	unsigned int uiSize;
 #endif
 
@@ -1666,7 +1666,7 @@ static tEplKernel EplSdoComProcessIntern
 			case kEplSdoComConEventAbort:
 				{
 					EplSdoComClientSendAbort(pSdoComCon,
-								 *((DWORD *)
+								 *((u32 *)
 								   pSdoComCon->
 								   m_pData));
 
@@ -1674,7 +1674,7 @@ static tEplKernel EplSdoComProcessIntern
 					pSdoComCon->m_bTransactionId++;
 					// call callback of application
 					pSdoComCon->m_dwLastAbortCode =
-					    *((DWORD *) pSdoComCon->m_pData);
+					    *((u32 *) pSdoComCon->m_pData);
 					Ret =
 					    EplSdoComTransferFinished
 					    (SdoComCon_p, pSdoComCon,
@@ -1868,7 +1868,7 @@ static tEplKernel EplSdoComProcessIntern
 			case kEplSdoComConEventAbort:
 				{
 					EplSdoComClientSendAbort(pSdoComCon,
-								 *((DWORD *)
+								 *((u32 *)
 								   pSdoComCon->
 								   m_pData));
 
@@ -1879,7 +1879,7 @@ static tEplKernel EplSdoComProcessIntern
 					    kEplSdoComStateClientConnected;
 					// call callback of application
 					pSdoComCon->m_dwLastAbortCode =
-					    *((DWORD *) pSdoComCon->m_pData);
+					    *((u32 *) pSdoComCon->m_pData);
 					Ret =
 					    EplSdoComTransferFinished
 					    (SdoComCon_p, pSdoComCon,
@@ -1964,7 +1964,7 @@ static tEplKernel EplSdoComServerInitRea
 	unsigned int uiSubindex;
 	tEplObdSize EntrySize;
 	tEplObdAccess AccessType;
-	DWORD dwAbortCode;
+	u32 dwAbortCode;
 
 	dwAbortCode = 0;
 
@@ -2323,18 +2323,18 @@ static tEplKernel EplSdoComServerSendFra
 
 			// copy abortcode to frame
 			AmiSetDwordToLe(&pCommandFrame->m_le_abCommandData[0],
-					*((DWORD *) pSdoComCon_p->m_pData));
+					*((u32 *) pSdoComCon_p->m_pData));
 
 			// set size of segment
 			AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize,
-				       sizeof(DWORD));
+				       sizeof(u32));
 
 			// update counter
-			pSdoComCon_p->m_uiTransferredByte = sizeof(DWORD);
+			pSdoComCon_p->m_uiTransferredByte = sizeof(u32);
 			pSdoComCon_p->m_uiTransSize = 0;
 
 			// calc framesize
-			uiSizeOfFrame += sizeof(DWORD);
+			uiSizeOfFrame += sizeof(u32);
 			Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
 						   uiSizeOfFrame, pFrame);
 			break;
@@ -2372,7 +2372,7 @@ static tEplKernel EplSdoComServerInitWri
 	unsigned int uiBytesToTransfer;
 	tEplObdSize EntrySize;
 	tEplObdAccess AccessType;
-	DWORD dwAbortCode;
+	u32 dwAbortCode;
 	u8 *pbSrcData;
 
 	dwAbortCode = 0;
@@ -3216,7 +3216,7 @@ static tEplKernel EplSdoComClientProcess
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
 static tEplKernel EplSdoComClientSendAbort(tEplSdoComCon * pSdoComCon_p,
-					   DWORD dwAbortCode_p)
+					   u32 dwAbortCode_p)
 {
 	tEplKernel Ret;
 	u8 abFrame[EPL_MAX_SDO_FRAME_SIZE];
@@ -3249,14 +3249,14 @@ static tEplKernel EplSdoComClientSendAbo
 	AmiSetDwordToLe(&pCommandFrame->m_le_abCommandData[0], dwAbortCode_p);
 
 	// set size of segment
-	AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize, sizeof(DWORD));
+	AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize, sizeof(u32));
 
 	// update counter
-	pSdoComCon_p->m_uiTransferredByte = sizeof(DWORD);
+	pSdoComCon_p->m_uiTransferredByte = sizeof(u32);
 	pSdoComCon_p->m_uiTransSize = 0;
 
 	// calc framesize
-	uiSizeOfFrame += sizeof(DWORD);
+	uiSizeOfFrame += sizeof(u32);
 
 	// save abort code
 	pSdoComCon_p->m_dwLastAbortCode = dwAbortCode_p;
--- a/drivers/staging/epl/EplSdo.h
+++ b/drivers/staging/epl/EplSdo.h
@@ -207,7 +207,7 @@ typedef enum {
 typedef struct {
 	tEplSdoComConHdl m_SdoComConHdl;
 	tEplSdoComConState m_SdoComConState;
-	DWORD m_dwAbortCode;
+	u32 m_dwAbortCode;
 	tEplSdoAccessType m_SdoAccessType;
 	unsigned int m_uiNodeId;	// NodeId of the target
 	unsigned int m_uiTargetIndex;	// index which was accessed
--- a/drivers/staging/epl/EplSdoUdpu.c
+++ b/drivers/staging/epl/EplSdoUdpu.c
@@ -431,7 +431,7 @@ tEplKernel EplSdoUdpuInitCon(tEplSdoConH
 //
 //---------------------------------------------------------------------------
 tEplKernel EplSdoUdpuSendData(tEplSdoConHdl SdoConHandle_p,
-			      tEplFrame *pSrcData_p, DWORD dwDataSize_p)
+			      tEplFrame *pSrcData_p, u32 dwDataSize_p)
 {
 	tEplKernel Ret;
 	int iError;
@@ -536,7 +536,7 @@ tEplKernel EplSdoUdpuDelCon(tEplSdoConHd
 // Parameters:      lpParameter = pointer to parameter type tEplSdoUdpThreadPara
 //
 //
-// Returns:         DWORD   =   errorcode
+// Returns:         u32   =   errorcode
 //
 //
 // State:
--- a/drivers/staging/epl/EplTarget.h
+++ b/drivers/staging/epl/EplTarget.h
@@ -128,7 +128,7 @@
 // currently no Timer functions are needed by EPL stack
 // so they are not implemented yet
 //void  TgtTimerInit(void);
-//DWORD TgtGetTickCount(void);
+//u32 TgtGetTickCount(void);
 //void TgtGetNetTime(tEplNetTime * pNetTime_p);
 
 // functions for ethernet driver
--- a/drivers/staging/epl/global.h
+++ b/drivers/staging/epl/global.h
@@ -29,9 +29,6 @@
 #ifndef WORD
 #define WORD unsigned short int
 #endif
-#ifndef DWORD
-#define DWORD unsigned long int
-#endif
 #ifndef BOOL
 #define BOOL unsigned char
 #endif
--- a/drivers/staging/epl/kernel/EplDllk.h
+++ b/drivers/staging/epl/kernel/EplDllk.h
@@ -96,7 +96,7 @@ struct _tEplDllkNodeInfo {
 	struct _tEplDllkNodeInfo *m_pNextNodeInfo;
 	struct _tEdrvTxBuffer *m_pPreqTxBuffer;
 	unsigned int m_uiNodeId;
-	DWORD m_dwPresTimeout;
+	u32 m_dwPresTimeout;
 	unsigned long m_ulDllErrorEvents;
 	tEplNmtState m_NmtState;
 	WORD m_wPresPayloadLimit;
--- a/drivers/staging/epl/proc_fs.c
+++ b/drivers/staging/epl/proc_fs.c
@@ -129,8 +129,8 @@
 
 #ifdef _DBG_TRACE_POINTS_
 atomic_t aatmDbgTracePoint_l[DBG_TRACE_POINTS];
-DWORD adwDbgTraceValue_l[DBG_TRACE_VALUES];
-DWORD dwDbgTraceValueOld_l;
+u32 adwDbgTraceValue_l[DBG_TRACE_VALUES];
+u32 dwDbgTraceValueOld_l;
 unsigned int uiDbgTraceValuePos_l;
 spinlock_t spinlockDbgTraceValue_l;
 unsigned long ulDbTraceValueFlags_l;
@@ -146,9 +146,9 @@ static int EplLinProcWrite(struct file *
 			   unsigned long count, void *data);
 
 void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
-void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+void TgtDbgPostTraceValue(u32 dwTraceValue_p);
 
-EPLDLLEXPORT DWORD EplIdentuGetRunningRequests(void);
+EPLDLLEXPORT u32 EplIdentuGetRunningRequests(void);
 
 //=========================================================================//
 //                                                                         //
@@ -207,7 +207,7 @@ void TgtDbgSignalTracePoint(u8 bTracePoi
 
 }
 
-void TgtDbgPostTraceValue(DWORD dwTraceValue_p)
+void TgtDbgPostTraceValue(u32 dwTraceValue_p)
 {
 
 	spin_lock_irqsave(&spinlockDbgTraceValue_l, ulDbTraceValueFlags_l);
@@ -279,7 +279,7 @@ static int EplLinProcRead(char *pcBuffer
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 	// fetch running IdentRequests
 	nSize += snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
-			  "running IdentRequests:      0x%08lX\n",
+			  "running IdentRequests:      0x%08X\n",
 			  EplIdentuGetRunningRequests());
 
 	// fetch state of NmtMnu module
--- a/drivers/staging/epl/TimerHighReskX86.c
+++ b/drivers/staging/epl/TimerHighReskX86.c
@@ -104,7 +104,7 @@
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
 void TgtDbgSignalTracePoint(u8 bTracePointNumber_p);
-void TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+void TgtDbgPostTraceValue(u32 dwTraceValue_p);
 #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
--- a/drivers/staging/epl/user/EplCfgMau.h
+++ b/drivers/staging/epl/user/EplCfgMau.h
@@ -131,13 +131,13 @@ typedef enum {
 typedef struct {
 	tEplCfgState m_CfgState;	// state of the configuration state maschine
 	tEplSdoComConHdl m_SdoComConHdl;	// handle for sdo connection
-	DWORD m_dwLastAbortCode;
+	u32 m_dwLastAbortCode;
 	unsigned int m_uiLastIndex;	// last index of configuration, to compair with actual index
 	u8 *m_pbConcise;	// Ptr to concise DCF
 	u8 *m_pbActualIndex;	// Ptr to actual index in the DCF segment
 	tfpEplCfgMaCb m_pfnCfgMaCb;	// Ptr to CfgMa Callback, is call if configuration finished
 	tEplKernel m_EplKernelError;	// errorcode
-	DWORD m_dwNumValueCopy;	// numeric values are copied in this variable
+	u32 m_dwNumValueCopy;	// numeric values are copied in this variable
 	unsigned int m_uiPdoNodeId;	// buffer for PDO node id
 	u8 m_bNrOfMappedObject;	// number of mapped objects
 	unsigned int m_uiNodeId;	// Epl node addresse
@@ -145,7 +145,7 @@ typedef struct {
 	unsigned int m_uiLastSubIndex;	// last subindex of configuration
 	BOOL m_fOneTranferOk;	// atleased one transfer was successful
 	u8 m_bEventFlag;	// for Eventsignaling to the State Maschine
-	DWORD m_dwCntObjectInDcf;	// number of Objects in DCF
+	u32 m_dwCntObjectInDcf;	// number of Objects in DCF
 	tEplCfgMaIndexType m_SkipCfg;	// TRUE if a adsitional Configurationprocess
 	// have to insert e.g. PDO-mapping
 	WORD m_wTimeOutCnt;	// Timeout Counter, break configuration is
--- a/drivers/staging/epl/user/EplSdoAsndu.h
+++ b/drivers/staging/epl/user/EplSdoAsndu.h
@@ -98,7 +98,7 @@ tEplKernel EplSdoAsnduInitCon(tEplSdoCon
 
 tEplKernel EplSdoAsnduSendData(tEplSdoConHdl SdoConHandle_p,
 			       tEplFrame *pSrcData_p,
-			       DWORD dwDataSize_p);
+			       u32 dwDataSize_p);
 
 tEplKernel EplSdoAsnduDelCon(tEplSdoConHdl SdoConHandle_p);
 
--- a/drivers/staging/epl/user/EplSdoComu.h
+++ b/drivers/staging/epl/user/EplSdoComu.h
@@ -108,7 +108,7 @@ tEplKernel EplSdoComGetState(tEplSdoComC
 			     tEplSdoComFinished *pSdoComFinished_p);
 
 tEplKernel EplSdoComSdoAbort(tEplSdoComConHdl SdoComConHdl_p,
-			     DWORD dwAbortCode_p);
+			     u32 dwAbortCode_p);
 
 #endif
 
--- a/drivers/staging/epl/user/EplSdoUdpu.h
+++ b/drivers/staging/epl/user/EplSdoUdpu.h
@@ -99,7 +99,7 @@ tEplKernel EplSdoUdpuInitCon(tEplSdoConH
 			     unsigned int uiTargetNodeId_p);
 
 tEplKernel EplSdoUdpuSendData(tEplSdoConHdl SdoConHandle_p,
-			      tEplFrame *pSrcData_p, DWORD dwDataSize_p);
+			      tEplFrame *pSrcData_p, u32 dwDataSize_p);
 
 tEplKernel EplSdoUdpuDelCon(tEplSdoConHdl SdoConHandle_p);
 
