From andre@bitwigglers.org  Wed Jan 21 09:14:20 2009
From: Andre Haupt <andre@bitwigglers.org>
Date: Mon, 19 Jan 2009 12:00:19 +0100
Subject: Staging: asus_oled: fix various checkpatch.pl issues regarding missing or obsolete spaces
To: greg@kroah.com
Cc: Andre Haupt <andre@bitwigglers.org>, sjakub@gmail.com
Message-ID: <503949ae789d7f5c6ad0bafe4e5ff7c35cf39a8f.1232362203.git.andre@bitwigglers.org>


Signed-off-by: Andre Haupt <andre@bitwigglers.org>
Cc: Jakub Schmidtke <sjakub@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/staging/asus_oled/asus_oled.c |   66 +++++++++++++++++-----------------
 1 file changed, 33 insertions(+), 33 deletions(-)

--- a/drivers/staging/asus_oled/asus_oled.c
+++ b/drivers/staging/asus_oled/asus_oled.c
@@ -80,20 +80,20 @@ struct oled_dev_desc_str {
 };
 
 /* table of devices that work with this driver */
-static struct usb_device_id id_table [] = {
+static struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x0b05, 0x1726) }, // Asus G1/G2 (and variants)
 	{ USB_DEVICE(0x0b05, 0x175b) }, // Asus G50V (and possibly others - G70? G71?)
 	{ },
 };
 
 /* parameters of specific devices */
-static struct oled_dev_desc_str oled_dev_desc_table [] = {
+static struct oled_dev_desc_str oled_dev_desc_table[] = {
 	{ 0x0b05, 0x1726, 128, PACK_MODE_G1, "G1/G2" },
 	{ 0x0b05, 0x175b, 256, PACK_MODE_G50, "G50" },
 	{ },
 };
 
-MODULE_DEVICE_TABLE (usb, id_table);
+MODULE_DEVICE_TABLE(usb, id_table);
 
 #define SETUP_PACKET_HEADER(packet, val1, val2, val3, val4, val5, val6, val7) \
 	do {					\
@@ -107,7 +107,7 @@ MODULE_DEVICE_TABLE (usb, id_table);
 		packet->header.value6 = val5;		\
 		packet->header.value7 = val6;		\
 		packet->header.value8 = val7;		\
-	} while(0);
+	} while (0);
 
 struct asus_oled_header {
 	uint8_t		magic1;
@@ -165,7 +165,7 @@ static void enable_oled(struct asus_oled
 	else
 		packet->bitmap[0] = 0xae;
 
-	for (a=0; a<1; a++) {
+	for (a = 0; a < 1; a++) {
 		retval = usb_bulk_msg(odev->udev,
 			usb_sndbulkpipe(odev->udev, 2),
 			packet,
@@ -254,7 +254,7 @@ static void send_packets(struct usb_devi
 	}
 }
 
-static void send_packet(struct usb_device *udev, struct asus_oled_packet *packet, size_t offset, size_t len, char *buf, uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5, uint8_t b6){
+static void send_packet(struct usb_device *udev, struct asus_oled_packet *packet, size_t offset, size_t len, char *buf, uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5, uint8_t b6) {
 	int retval;
 	int act_len;
 
@@ -296,7 +296,7 @@ static void send_data(struct asus_oled_d
 		return;
 	}
 
-	if (odev->pack_mode==PACK_MODE_G1){
+	if (odev->pack_mode == PACK_MODE_G1) {
 		// When sending roll-mode data the display updated only first packet.
 		// I have no idea why, but when static picture is send just before
 		// rolling picture - everything works fine.
@@ -310,7 +310,7 @@ static void send_data(struct asus_oled_d
 		send_packets(odev->udev, packet, odev->buf, odev->pic_mode, packet_num);
 	}
 	else
-	if (odev->pack_mode==PACK_MODE_G50){
+	if (odev->pack_mode == PACK_MODE_G50) {
 		send_packets_g50(odev->udev, packet, odev->buf);
 	}
 
@@ -328,7 +328,7 @@ static int append_values(struct asus_ole
 			x += odev->x_shift;
 			y += odev->y_shift;
 
-			switch(odev->pack_mode)
+			switch (odev->pack_mode)
 			{
 				case PACK_MODE_G1:
 					// i = (x/128)*640 + 127 - x + (y/8)*128;
@@ -382,7 +382,7 @@ static ssize_t odev_set_picture(struct a
 	if (count < 1)
 		return 0;
 
-	if (tolower(buf[0]) == 'b'){
+	if (tolower(buf[0]) == 'b') {
 	    // binary mode, set the entire memory
 
 	    size_t i;
@@ -395,16 +395,16 @@ static ssize_t odev_set_picture(struct a
 
 	    memset(odev->buf, 0xff, odev->buf_size);
 
-	    for (i=1; i < count && i<=32*32; i++){
+	    for (i = 1; i < count && i <= 32 * 32; i++) {
 		odev->buf[i-1] = buf[i];
 		odev->buf_offs = i-1;
 	    }
 
-	    odev->width=odev->dev_width / 8;
-	    odev->height=ASUS_OLED_DISP_HEIGHT;
-	    odev->x_shift=0;
-	    odev->y_shift=0;
-	    odev->last_val=0;
+	    odev->width = odev->dev_width / 8;
+	    odev->height = ASUS_OLED_DISP_HEIGHT;
+	    odev->x_shift = 0;
+	    odev->y_shift = 0;
+	    odev->last_val =  0;
 
 	    send_data(odev);
 
@@ -420,7 +420,7 @@ static ssize_t odev_set_picture(struct a
 			goto error_header;
 		}
 
-		switch(tolower(buf[1])) {
+		switch (tolower(buf[1])) {
 			case ASUS_OLED_STATIC:
 			case ASUS_OLED_ROLL:
 			case ASUS_OLED_FLASH:
@@ -519,18 +519,18 @@ static ssize_t odev_set_picture(struct a
 		int ret;
 
 		if (buf[offs] == '1' || buf[offs] == '#') {
-			if ( (ret = append_values(odev, 1, 1)) < 0)
+			if ((ret = append_values(odev, 1, 1)) < 0)
 				return ret;
 		}
 		else if (buf[offs] == '0' || buf[offs] == ' ') {
-			if ( (ret = append_values(odev, 0, 1)) < 0)
+			if ((ret = append_values(odev, 0, 1)) < 0)
 				return ret;
 		}
 		else if (buf[offs] == '\n') {
 			// New line detected. Lets assume, that all characters till the end of the
 			// line were equal to the last character in this line.
 			if (odev->buf_offs % odev->width != 0)
-				if ( (ret = append_values(odev, odev->last_val,
+				if ((ret = append_values(odev, odev->last_val,
 				      odev->width - (odev->buf_offs % odev->width))) < 0)
 					return ret;
 		}
@@ -604,7 +604,7 @@ static int asus_oled_probe(struct usb_in
 		}
 	}
 
-	if ( !desc || dev_width < 1 || pack_mode == PACK_MODE_LAST) {
+	if (!desc || dev_width < 1 || pack_mode == PACK_MODE_LAST) {
 		dev_err(&interface->dev, "Missing or incomplete device description!\n");
 		return -ENODEV;
 	}
@@ -631,7 +631,7 @@ static int asus_oled_probe(struct usb_in
 	odev->enabled = 1;
 	odev->dev = NULL;
 
-	usb_set_intfdata (interface, odev);
+	usb_set_intfdata(interface, odev);
 
 	if ((retval = device_create_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(enabled)))) {
 		goto err_files;
@@ -641,8 +641,8 @@ static int asus_oled_probe(struct usb_in
 		goto err_files;
 	}
 
-	odev->dev = device_create(oled_class, &interface->dev, MKDEV(0,0),
-				NULL,"oled_%d", ++oled_num);
+	odev->dev = device_create(oled_class, &interface->dev, MKDEV(0, 0),
+				NULL, "oled_%d", ++oled_num);
 
 	if (IS_ERR(odev->dev)) {
 		retval = PTR_ERR(odev->dev);
@@ -651,11 +651,11 @@ static int asus_oled_probe(struct usb_in
 
 	dev_set_drvdata(odev->dev, odev);
 
-	if ( (retval = device_create_file(odev->dev, &dev_attr_enabled))) {
+	if ((retval = device_create_file(odev->dev, &dev_attr_enabled))) {
 		goto err_class_enabled;
 	}
 
-	if ( (retval = device_create_file(odev->dev, &dev_attr_picture))) {
+	if ((retval = device_create_file(odev->dev, &dev_attr_picture))) {
 		goto err_class_picture;
 	}
 
@@ -677,7 +677,7 @@ err_files:
 	device_remove_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(enabled));
 	device_remove_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(picture));
 
-	usb_set_intfdata (interface, NULL);
+	usb_set_intfdata(interface, NULL);
 	usb_put_dev(odev->udev);
 	kfree(odev);
 
@@ -688,15 +688,15 @@ static void asus_oled_disconnect(struct 
 {
 	struct asus_oled_dev *odev;
 
-	odev = usb_get_intfdata (interface);
-	usb_set_intfdata (interface, NULL);
+	odev = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
 
 	device_remove_file(odev->dev, &dev_attr_picture);
 	device_remove_file(odev->dev, &dev_attr_enabled);
 	device_unregister(odev->dev);
 
-	device_remove_file(&interface->dev, & ASUS_OLED_DEVICE_ATTR(picture));
-	device_remove_file(&interface->dev, & ASUS_OLED_DEVICE_ATTR(enabled));
+	device_remove_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(picture));
+	device_remove_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(enabled));
 
 	usb_put_dev(odev->udev);
 
@@ -759,6 +759,6 @@ static void __exit asus_oled_exit(void)
 	usb_deregister(&oled_driver);
 }
 
-module_init (asus_oled_init);
-module_exit (asus_oled_exit);
+module_init(asus_oled_init);
+module_exit(asus_oled_exit);
 
