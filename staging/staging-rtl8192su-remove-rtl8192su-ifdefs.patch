From bzolnier@gmail.com  Fri Jul 10 16:02:17 2009
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Fri, 03 Jul 2009 16:08:16 +0200
Subject: Staging: rtl8192su: remove RTL8192SU ifdefs
To: "Greg Kroah-Hartman" <gregkh@suse.de>
Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>, linux-kernel@vger.kernel.org
Message-ID: <20090703140816.7303.72376.sendpatchset@localhost.localdomain>


From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rtl8192su/Makefile                         |    2 
 drivers/staging/rtl8192su/ieee80211/ieee80211_softmac_wx.c |    5 
 drivers/staging/rtl8192su/ieee80211/ieee80211_tx.c         |    4 
 drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c       |   22 
 drivers/staging/rtl8192su/r8180_93cx6.h                    |    5 
 drivers/staging/rtl8192su/r8192S_Efuse.c                   |    2 
 drivers/staging/rtl8192su/r8192S_firmware.c                |  434 --
 drivers/staging/rtl8192su/r8192S_hw.h                      |    2 
 drivers/staging/rtl8192su/r8192S_phy.c                     |   95 
 drivers/staging/rtl8192su/r8192S_rtl6052.c                 |   27 
 drivers/staging/rtl8192su/r8192U.h                         |  190 -
 drivers/staging/rtl8192su/r8192U_core.c                    | 1900 -------------
 drivers/staging/rtl8192su/r8192U_dm.c                      |  178 -
 drivers/staging/rtl8192su/r8192U_wx.c                      |   12 
 drivers/staging/rtl8192su/r819xU_cmdpkt.c                  |   77 
 15 files changed, 82 insertions(+), 2873 deletions(-)

--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac_wx.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac_wx.c
@@ -230,7 +230,6 @@ int ieee80211_wx_get_rate(struct ieee802
 			     union iwreq_data *wrqu, char *extra)
 {
 	u32 tmp_rate = 0;
-#ifdef RTL8192SU
 	//printk("===>mode:%d, halfNmode:%d\n", ieee->mode, ieee->bHalfWirelessN24GMode);
 	if (ieee->mode & (IEEE_A | IEEE_B | IEEE_G))
 		tmp_rate = ieee->rate;
@@ -243,10 +242,6 @@ int ieee80211_wx_get_rate(struct ieee802
 		else
 			tmp_rate = HTMcsToDataRate(ieee, 15);
 	}
-#else
-	tmp_rate = TxCountToDataRate(ieee, ieee->softmac_stats.CurrentShowTxate);
-
-#endif
 	wrqu->bitrate.value = tmp_rate * 500000;
 
 	return 0;
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_tx.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_tx.c
@@ -495,11 +495,7 @@ void ieee80211_query_protectionmode(stru
 			{
 				tcb_desc->bCTSEnable	= true;
 				tcb_desc->rts_rate  = 	MGN_24M;
-#if defined(RTL8192SU)
 				tcb_desc->bRTSEnable = false;
-#else
-				tcb_desc->bRTSEnable = true;
-#endif
 				break;
 			}
 			else if(pHTInfo->IOTAction & (HT_IOT_ACT_FORCED_RTS|HT_IOT_ACT_PURE_N_MODE))
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
@@ -516,7 +516,6 @@ bool HTIOTActIsDisableMCSTwoSpatialStrea
 //#endif
 #endif
 #if 1
-#if  defined(RTL8192SU)
        PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	if(ieee->is_ap_in_wep_tkip && ieee->is_ap_in_wep_tkip(ieee->dev))
 	{
@@ -526,7 +525,6 @@ bool HTIOTActIsDisableMCSTwoSpatialStrea
 			retValue = true;
 	}
 #endif
-#endif
 	return retValue;
 }
 
@@ -595,7 +593,6 @@ u8 HTIOTActIsForcedRTSCTS(struct ieee802
 	u8	retValue = 0;
 	printk("============>%s(), %d\n", __FUNCTION__, network->realtek_cap_exit);
 	// Force protection
-#if defined(RTL8192SU)
 	if(ieee->pHTInfo->bCurrentHTSupport)
 	{
 		//if(!network->realtek_cap_exit)
@@ -606,7 +603,6 @@ u8 HTIOTActIsForcedRTSCTS(struct ieee802
 				retValue = 1;
 		}
 	}
-#endif
 	return retValue;
 }
 
@@ -640,7 +636,6 @@ HTIOCActRejcectADDBARequest(struct ieee8
 	//if(IS_HARDWARE_TYPE_8192SE(Adapter) ||
 	//	IS_HARDWARE_TYPE_8192SU(Adapter)
 	//)
-#if  defined RTL8192SU
 	{
 		// Do not reject ADDBA REQ because some of the AP may
 		// keep on sending ADDBA REQ qhich cause DHCP fail or ping loss!
@@ -650,7 +645,6 @@ HTIOCActRejcectADDBARequest(struct ieee8
 		//	return FALSE;
 
 	}
-#endif
 
 	return retValue;
 
@@ -664,7 +658,6 @@ HTIOCActRejcectADDBARequest(struct ieee8
 {
 	u8	retValue = 0;
 	//if(IS_HARDWARE_TYPE_8192SU(Adapter))
-#ifdef RTL8192SU
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	{
 //#if UNDER_VISTA
@@ -678,7 +671,6 @@ HTIOCActRejcectADDBARequest(struct ieee8
 			return 1;
 
 	}
-#endif
 	return retValue;
 }
 
@@ -733,7 +725,6 @@ HTIOTActIsDisableTx40MHz(struct ieee8021
 {
 	u8	retValue = 0;
 
-#if defined RTL8192SU
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	if(	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
 		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
@@ -744,7 +735,6 @@ HTIOTActIsDisableTx40MHz(struct ieee8021
 		if((pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK) && (network->bssht.bdSupportHT))
 			retValue = 1;
 	}
-#endif
 
 	return retValue;
 }
@@ -754,7 +744,6 @@ HTIOTActIsTxNoAggregation(struct ieee802
 {
 	u8 retValue = 0;
 
-#if defined RTL8192SU
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	if(	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
 		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
@@ -766,7 +755,6 @@ HTIOTActIsTxNoAggregation(struct ieee802
 		    pHTInfo->IOTPeer==HT_IOT_PEER_UNKNOWN)
 			retValue = 1;
 	}
-#endif
 
 	return retValue;
 }
@@ -777,7 +765,6 @@ HTIOTActIsDisableTx2SS(struct ieee80211_
 {
 	u8	retValue = 0;
 
-#if defined RTL8192SU
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	if(	(KEY_TYPE_WEP104 == ieee->pairwise_key_type) ||
 		(KEY_TYPE_WEP40 == ieee->pairwise_key_type) ||
@@ -788,7 +775,6 @@ HTIOTActIsDisableTx2SS(struct ieee80211_
 		if((pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK) && (network->bssht.bdSupportHT))
 			retValue = 1;
 	}
-#endif
 
 	return retValue;
 }
@@ -797,14 +783,12 @@ HTIOTActIsDisableTx2SS(struct ieee80211_
 bool HTIOCActAllowPeerAggOnePacket(struct ieee80211_device* ieee,struct ieee80211_network *network)
 {
 	bool 	retValue = false;
-#if defined(RTL8192SU)
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	{
 		if(pHTInfo->IOTPeer == HT_IOT_PEER_MARVELL)
 			return true;
 
 	}
-#endif
 	return retValue;
 }
 
@@ -1783,11 +1767,9 @@ void HTResetSelfAndSavePeerSetting(struc
 		//if(bIOTAction)
 		//	pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_RTS;
 
-#if defined(RTL8192SU)
 		bIOTAction = HTIOCActRejcectADDBARequest(pNetwork);
 		if(bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_REJECT_ADDBA_REQ;
-#endif
 
 		bIOTAction = HTIOCActAllowPeerAggOnePacket(ieee, pNetwork);
 		if(bIOTAction)
@@ -1797,7 +1779,6 @@ void HTResetSelfAndSavePeerSetting(struc
 		if(bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_EDCA_BIAS_ON_RX;
 
-#if defined(RTL8192SU)
 		bIOTAction = HTIOTActDisableShortGI(ieee, pNetwork);
 		if(bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_SHORT_GI;
@@ -1805,13 +1786,11 @@ void HTResetSelfAndSavePeerSetting(struc
 		bIOTAction = HTIOTActDisableHighPower(ieee, pNetwork);
 		if(bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_HIGH_POWER;
-#endif
 
 		bIOTAction = HTIOTActIsForcedAMSDU8K(ieee, pNetwork);
 		if(bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_TX_USE_AMSDU_8K;
 
-#if defined(RTL8192SU)
 		bIOTAction = HTIOTActIsTxNoAggregation(ieee, pNetwork);
 		if(bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_TX_NO_AGGREGATION;
@@ -1823,7 +1802,6 @@ void HTResetSelfAndSavePeerSetting(struc
 		bIOTAction = HTIOTActIsDisableTx2SS(ieee, pNetwork);
 		if(bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_DISABLE_TX_2SS;
-#endif
 		//must after HT_IOT_ACT_TX_NO_AGGREGATION
 		bIOTAction = HTIOTActIsForcedRTSCTS(ieee, pNetwork);
 		if(bIOTAction)
--- a/drivers/staging/rtl8192su/Makefile
+++ b/drivers/staging/rtl8192su/Makefile
@@ -7,8 +7,6 @@ EXTRA_CFLAGS += -mhard-float -DCONFIG_FO
 EXTRA_CFLAGS += -DJACKSON_NEW_RX
 EXTRA_CFLAGS += -DTHOMAS_BEACON
 
-EXTRA_CFLAGS += -DRTL8192SU
-
 #EXTRA_CFLAGS += -DMUTIPLE_BULK_OUT
 
 r8192s_usb-objs :=		\
--- a/drivers/staging/rtl8192su/r8180_93cx6.h
+++ b/drivers/staging/rtl8192su/r8180_93cx6.h
@@ -13,13 +13,8 @@
 /*This files contains card eeprom (93c46 or 93c56) programming routines*/
 /*memory is addressed by WORDS*/
 
-#ifdef RTL8192SU
 #include "r8192U.h"
 #include "r8192S_hw.h"
-#else
-#include "r8192U.h"
-#include "r8192U_hw.h"
-#endif
 
 #define EPROM_DELAY 10
 
--- a/drivers/staging/rtl8192su/r8192S_Efuse.c
+++ b/drivers/staging/rtl8192su/r8192S_Efuse.c
@@ -35,7 +35,6 @@
 //
 // In the future, we will always support EFUSE!!
 //
-#ifdef RTL8192SU
 /*---------------------------Define Local Constant---------------------------*/
 #define 	_POWERON_DELAY_
 #define 	_PRE_EXECUTE_READ_CMD_
@@ -2401,7 +2400,6 @@ void efuset_test_func_write(struct net_d
 
 
 
-#endif	// #if (HAL_CODE_BASE == RTL8192_S)
 
 
 
--- a/drivers/staging/rtl8192su/r8192S_firmware.c
+++ b/drivers/staging/rtl8192su/r8192S_firmware.c
@@ -11,19 +11,13 @@
  *        NDIS_STATUS_FAILURE - the following initialization process should be terminated
  *        NDIS_STATUS_SUCCESS - if firmware initialization process success
 **************************************************************************************************/
-#if defined(RTL8192SU)
 #include "r8192U.h"
 #include "r8192S_firmware.h"
 #include <linux/unistd.h>
 
-#ifdef RTL8192SU
 #include "r8192S_hw.h"
 #include "r8192SU_HWImg.h"
 //#include "r8192S_FwImgDTM.h"
-#else
-//#include "r8192U_hw.h"
-#include "r8192xU_firmware_img.h"
-#endif
 
 #include <linux/firmware.h>
 
@@ -342,11 +336,9 @@ u8 FirmwareHeaderMapRfType(struct net_de
 void FirmwareHeaderPriveUpdate(struct net_device *dev, PRT_8192S_FIRMWARE_PRIV 	pFwPriv)
 {
 	struct r8192_priv 	*priv = ieee80211_priv(dev);
-#ifdef RTL8192SU
 	// Update USB endpoint number for RQPN settings.
 	pFwPriv->usb_ep_num = priv->EEPROMUsbEndPointNumber; // endpoint number: 4, 6 and 11.
 	RT_TRACE(COMP_INIT, "FirmwarePriveUpdate(): usb_ep_num(%#x)\n", pFwPriv->usb_ep_num);
-#endif
 
 	// Update RF types for RATR settings.
 	pFwPriv->rf_config = FirmwareHeaderMapRfType(dev);
@@ -551,430 +543,4 @@ bool FirmwareDownload92S(struct net_devi
 	rtStatus = false;
 	return rtStatus;
 }
-#else
-void firmware_init_param(struct net_device *dev)
-{
-	struct r8192_priv 	*priv = ieee80211_priv(dev);
-	rt_firmware		*pfirmware = priv->pFirmware;
-
-	pfirmware->cmdpacket_frag_thresold = GET_COMMAND_PACKET_FRAG_THRESHOLD(MAX_TRANSMIT_BUFFER_SIZE);
-}
-
-/*
- * segment the img and use the ptr and length to remember info on each segment
- *
- */
-bool fw_download_code(struct net_device *dev, u8 *code_virtual_address, u32 buffer_len)
-{
-	struct r8192_priv   *priv = ieee80211_priv(dev);
-	bool 		    rt_status = true;
-	//u16		    frag_threshold;
-	u16		    frag_length, frag_offset = 0;
-	//u16		    total_size;
-	int		    i;
-
-	//rt_firmware	    *pfirmware = priv->pFirmware;
-	struct sk_buff	    *skb;
-	unsigned char	    *seg_ptr;
-	cb_desc		    *tcb_desc;
-	u8                  bLastIniPkt;
-
-#ifndef RTL8192SU
-	if(buffer_len >= 64000-USB_HWDESC_HEADER_LEN)
-	{
-		return rt_status;
-	}
-	firmware_init_param(dev);
-	//Fragmentation might be required
-	frag_threshold = pfirmware->cmdpacket_frag_thresold;
-#endif
-
-	do {
-#ifndef RTL8192SU
-		if((buffer_len - frag_offset) > frag_threshold) {
-			frag_length = frag_threshold ;
-			bLastIniPkt = 0;
-
-		} else
-#endif
-		{
-			frag_length = buffer_len - frag_offset;
-			bLastIniPkt = 1;
-
-		}
-
-		/* Allocate skb buffer to contain firmware info and tx descriptor info
-		 * add 4 to avoid packet appending overflow.
-		 * */
-		#ifdef RTL8192U
-		skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + frag_length + 4);
-		#else
-		skb  = dev_alloc_skb(frag_length + 4);
-		#endif
-		memcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));
-		tcb_desc = (cb_desc*)(skb->cb + MAX_DEV_ADDR_SIZE);
-		tcb_desc->queue_index = TXCMD_QUEUE;
-		tcb_desc->bCmdOrInit = DESC_PACKET_TYPE_INIT;
-		tcb_desc->bLastIniPkt = bLastIniPkt;
-
-		#ifdef RTL8192U
-		skb_reserve(skb, USB_HWDESC_HEADER_LEN);
-		#endif
-		seg_ptr = skb->data;
-		/*
-		 * Transform from little endian to big endian
-                 * and pending  zero
-		 */
-		for(i=0 ; i < frag_length; i+=4) {
-			*seg_ptr++ = ((i+0)<frag_length)?code_virtual_address[i+3]:0;
-			*seg_ptr++ = ((i+1)<frag_length)?code_virtual_address[i+2]:0;
-			*seg_ptr++ = ((i+2)<frag_length)?code_virtual_address[i+1]:0;
-			*seg_ptr++ = ((i+3)<frag_length)?code_virtual_address[i+0]:0;
-		}
-		tcb_desc->txbuf_size= (u16)i;
-		skb_put(skb, i);
-
-		if(!priv->ieee80211->check_nic_enough_desc(dev,tcb_desc->queue_index)||
-			(!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index]))||\
-			(priv->ieee80211->queue_stop) ) {
-			RT_TRACE(COMP_FIRMWARE,"=====================================================> tx full!\n");
-			skb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);
-		} else {
-			priv->ieee80211->softmac_hard_start_xmit(skb,dev);
-		}
-
-		code_virtual_address += frag_length;
-		frag_offset += frag_length;
-
-	}while(frag_offset < buffer_len);
-
-	return rt_status;
-
-#if 0
-cmdsend_downloadcode_fail:
-	rt_status = false;
-	RT_TRACE(COMP_ERR, "CmdSendDownloadCode fail !!\n");
-	return rt_status;
-#endif
-}
-
-bool
-fwSendNullPacket(
-	struct net_device *dev,
-	u32			Length
-)
-{
-	bool	rtStatus = true;
-	struct r8192_priv   *priv = ieee80211_priv(dev);
-	struct sk_buff	    *skb;
-	cb_desc		    *tcb_desc;
-	unsigned char	    *ptr_buf;
-	bool	bLastInitPacket = false;
-
-	//PlatformAcquireSpinLock(dev, RT_TX_SPINLOCK);
-
-	//Get TCB and local buffer from common pool. (It is shared by CmdQ, MgntQ, and USB coalesce DataQ)
-	skb  = dev_alloc_skb(Length+ 4);
-	memcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));
-	tcb_desc = (cb_desc*)(skb->cb + MAX_DEV_ADDR_SIZE);
-	tcb_desc->queue_index = TXCMD_QUEUE;
-	tcb_desc->bCmdOrInit = DESC_PACKET_TYPE_INIT;
-	tcb_desc->bLastIniPkt = bLastInitPacket;
-	ptr_buf = skb_put(skb, Length);
-	memset(ptr_buf,0,Length);
-	tcb_desc->txbuf_size= (u16)Length;
-
-	if(!priv->ieee80211->check_nic_enough_desc(dev,tcb_desc->queue_index)||
-			(!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index]))||\
-			(priv->ieee80211->queue_stop) ) {
-			RT_TRACE(COMP_FIRMWARE,"===================NULL packet==================================> tx full!\n");
-			skb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);
-		} else {
-			priv->ieee80211->softmac_hard_start_xmit(skb,dev);
-		}
-
-	//PlatformReleaseSpinLock(dev, RT_TX_SPINLOCK);
-	return rtStatus;
-}
-
-//-----------------------------------------------------------------------------
-// Procedure:    Check whether main code is download OK. If OK, turn on CPU
-//
-// Description:   CPU register locates in different page against general register.
-//			    Switch to CPU register in the begin and switch back before return
-//
-//
-// Arguments:   The pointer of the dev
-//
-// Returns:
-//        NDIS_STATUS_FAILURE - the following initialization process should be terminated
-//        NDIS_STATUS_SUCCESS - if firmware initialization process success
-//-----------------------------------------------------------------------------
-bool CPUcheck_maincodeok_turnonCPU(struct net_device *dev)
-{
-	bool		rt_status = true;
-	int		check_putcodeOK_time = 200000, check_bootOk_time = 200000;
-	u32	 	CPU_status = 0;
-
-	/* Check whether put code OK */
-	do {
-		CPU_status = read_nic_dword(dev, CPU_GEN);
-
-		if(CPU_status&CPU_GEN_PUT_CODE_OK)
-			break;
-
-	}while(check_putcodeOK_time--);
-
-	if(!(CPU_status&CPU_GEN_PUT_CODE_OK)) {
-		RT_TRACE(COMP_ERR, "Download Firmware: Put code fail!\n");
-		goto CPUCheckMainCodeOKAndTurnOnCPU_Fail;
-	} else {
-		RT_TRACE(COMP_FIRMWARE, "Download Firmware: Put code ok!\n");
-	}
-
-	/* Turn On CPU */
-	CPU_status = read_nic_dword(dev, CPU_GEN);
-	write_nic_byte(dev, CPU_GEN, (u8)((CPU_status|CPU_GEN_PWR_STB_CPU)&0xff));
-	mdelay(1000);
-
-	/* Check whether CPU boot OK */
-	do {
-		CPU_status = read_nic_dword(dev, CPU_GEN);
-
-		if(CPU_status&CPU_GEN_BOOT_RDY)
-			break;
-	}while(check_bootOk_time--);
-
-	if(!(CPU_status&CPU_GEN_BOOT_RDY)) {
-		goto CPUCheckMainCodeOKAndTurnOnCPU_Fail;
-	} else {
-		RT_TRACE(COMP_FIRMWARE, "Download Firmware: Boot ready!\n");
-	}
-
-	return rt_status;
-
-CPUCheckMainCodeOKAndTurnOnCPU_Fail:
-	RT_TRACE(COMP_ERR, "ERR in %s()\n", __FUNCTION__);
-	rt_status = FALSE;
-	return rt_status;
-}
-
-bool CPUcheck_firmware_ready(struct net_device *dev)
-{
-
-	bool		rt_status = true;
-	int		check_time = 200000;
-	u32		CPU_status = 0;
-
-	/* Check Firmware Ready */
-	do {
-		CPU_status = read_nic_dword(dev, CPU_GEN);
-
-		if(CPU_status&CPU_GEN_FIRM_RDY)
-			break;
-
-	}while(check_time--);
-
-	if(!(CPU_status&CPU_GEN_FIRM_RDY))
-		goto CPUCheckFirmwareReady_Fail;
-	else
-		RT_TRACE(COMP_FIRMWARE, "Download Firmware: Firmware ready!\n");
-
-	return rt_status;
-
-CPUCheckFirmwareReady_Fail:
-	RT_TRACE(COMP_ERR, "ERR in %s()\n", __FUNCTION__);
-	rt_status = false;
-	return rt_status;
-
-}
-
-bool init_firmware(struct net_device *dev)
-{
-	struct r8192_priv 	*priv = ieee80211_priv(dev);
-	bool			rt_status = TRUE;
-
-	u8			*firmware_img_buf[3] = { &rtl8190_fwboot_array[0],
-						   	 &rtl8190_fwmain_array[0],
-						   	 &rtl8190_fwdata_array[0]};
-
-	u32			firmware_img_len[3] = { sizeof(rtl8190_fwboot_array),
-						   	sizeof(rtl8190_fwmain_array),
-						   	sizeof(rtl8190_fwdata_array)};
-	u32			file_length = 0;
-	u8			*mapped_file = NULL;
-	u32			init_step = 0;
-	opt_rst_type_e	rst_opt = OPT_SYSTEM_RESET;
-	firmware_init_step_e 	starting_state = FW_INIT_STEP0_BOOT;
-
-	rt_firmware		*pfirmware = priv->pFirmware;
-	const struct firmware 	*fw_entry;
-	const char *fw_name[3] = { "RTL8192U/boot.img",
-                           "RTL8192U/main.img",
-			   "RTL8192U/data.img"};
-	int rc;
-
-	RT_TRACE(COMP_FIRMWARE, " PlatformInitFirmware()==>\n");
-
-	if (pfirmware->firmware_status == FW_STATUS_0_INIT ) {
-		/* it is called by reset */
-		rst_opt = OPT_SYSTEM_RESET;
-		starting_state = FW_INIT_STEP0_BOOT;
-		// TODO: system reset
-
-	}else if(pfirmware->firmware_status == FW_STATUS_5_READY) {
-		/* it is called by Initialize */
-		rst_opt = OPT_FIRMWARE_RESET;
-		starting_state = FW_INIT_STEP2_DATA;
-	}else {
-		 RT_TRACE(COMP_FIRMWARE, "PlatformInitFirmware: undefined firmware state\n");
-	}
-
-	/*
-	 * Download boot, main, and data image for System reset.
-	 * Download data image for firmware reseta
-	 */
-	priv->firmware_source = FW_SOURCE_IMG_FILE;
-
-	for(init_step = starting_state; init_step <= FW_INIT_STEP2_DATA; init_step++) {
-		/*
-		 * Open Image file, and map file to contineous memory if open file success.
-		 * or read image file from array. Default load from IMG file
-		 */
-		if(rst_opt == OPT_SYSTEM_RESET) {
-			switch(priv->firmware_source) {
-				case FW_SOURCE_IMG_FILE:
-					rc = request_firmware(&fw_entry, fw_name[init_step],&priv->udev->dev);
-					if(rc < 0 ) {
-						RT_TRACE(COMP_ERR, "request firmware fail!\n");
-						goto download_firmware_fail;
-					}
-
-					if(fw_entry->size > sizeof(pfirmware->firmware_buf)) {
-						RT_TRACE(COMP_ERR, "img file size exceed the container buffer fail!\n");
-						goto download_firmware_fail;
-					}
-
-					if(init_step != FW_INIT_STEP1_MAIN) {
-						memcpy(pfirmware->firmware_buf,fw_entry->data,fw_entry->size);
-						mapped_file = pfirmware->firmware_buf;
-						file_length = fw_entry->size;
-					} else {
-					#ifdef RTL8190P
-						memcpy(pfirmware->firmware_buf,fw_entry->data,fw_entry->size);
-						mapped_file = pfirmware->firmware_buf;
-						file_length = fw_entry->size;
-					#else
-						memset(pfirmware->firmware_buf,0,128);
-						memcpy(&pfirmware->firmware_buf[128],fw_entry->data,fw_entry->size);
-						mapped_file = pfirmware->firmware_buf;
-						file_length = fw_entry->size + 128;
-					#endif
-					}
-					pfirmware->firmware_buf_size = file_length;
-					break;
-
-				case FW_SOURCE_HEADER_FILE:
-					mapped_file =  firmware_img_buf[init_step];
-					file_length  = firmware_img_len[init_step];
-					if(init_step == FW_INIT_STEP2_DATA) {
-						memcpy(pfirmware->firmware_buf, mapped_file, file_length);
-						pfirmware->firmware_buf_size = file_length;
-					}
-					break;
-
-				default:
-					break;
-			}
-
-
-		}else if(rst_opt == OPT_FIRMWARE_RESET ) {
-			/* we only need to download data.img here */
-			mapped_file = pfirmware->firmware_buf;
-			file_length = pfirmware->firmware_buf_size;
-		}
-
-		/* Download image file */
-		/* The firmware download process is just as following,
-		 * 1. that is each packet will be segmented and inserted to the wait queue.
-		 * 2. each packet segment will be put in the skb_buff packet.
-		 * 3. each skb_buff packet data content will already include the firmware info
-		 *   and Tx descriptor info
-		 * */
-		rt_status = fw_download_code(dev,mapped_file,file_length);
-
-		if(rst_opt == OPT_SYSTEM_RESET) {
-			release_firmware(fw_entry);
-		}
-
-		if(rt_status != TRUE) {
-			goto download_firmware_fail;
-		}
-
-		switch(init_step) {
-			case FW_INIT_STEP0_BOOT:
-				/* Download boot
-				 * initialize command descriptor.
-				 * will set polling bit when firmware code is also configured
-				 */
-				pfirmware->firmware_status = FW_STATUS_1_MOVE_BOOT_CODE;
-#ifdef RTL8190P
-				// To initialize IMEM, CPU move code  from 0x80000080, hence, we send 0x80 byte packet
-				rt_status = fwSendNullPacket(dev, RTL8190_CPU_START_OFFSET);
-				if(rt_status != true)
-				{
-					RT_TRACE(COMP_INIT, "fwSendNullPacket() fail ! \n");
-					goto  download_firmware_fail;
-				}
-#endif
-				//mdelay(1000);
-				/*
-				 * To initialize IMEM, CPU move code  from 0x80000080,
-				 * hence, we send 0x80 byte packet
-				 */
-				break;
-
-			case FW_INIT_STEP1_MAIN:
-				/* Download firmware code. Wait until Boot Ready and Turn on CPU */
-				pfirmware->firmware_status = FW_STATUS_2_MOVE_MAIN_CODE;
-
-				/* Check Put Code OK and Turn On CPU */
-				rt_status = CPUcheck_maincodeok_turnonCPU(dev);
-				if(rt_status != TRUE) {
-					RT_TRACE(COMP_ERR, "CPUcheck_maincodeok_turnonCPU fail!\n");
-					goto download_firmware_fail;
-				}
-
-				pfirmware->firmware_status = FW_STATUS_3_TURNON_CPU;
-				break;
-
-			case FW_INIT_STEP2_DATA:
-				/* download initial data code */
-				pfirmware->firmware_status = FW_STATUS_4_MOVE_DATA_CODE;
-				mdelay(1);
-
-				rt_status = CPUcheck_firmware_ready(dev);
-				if(rt_status != TRUE) {
-					RT_TRACE(COMP_ERR, "CPUcheck_firmware_ready fail(%d)!\n",rt_status);
-					goto download_firmware_fail;
-				}
-
-				/* wait until data code is initialized ready.*/
-				pfirmware->firmware_status = FW_STATUS_5_READY;
-				break;
-		}
-	}
-
-	RT_TRACE(COMP_FIRMWARE, "Firmware Download Success\n");
-	//assert(pfirmware->firmware_status == FW_STATUS_5_READY, ("Firmware Download Fail\n"));
-
-	return rt_status;
-
-download_firmware_fail:
-	RT_TRACE(COMP_ERR, "ERR in %s()\n", __FUNCTION__);
-	rt_status = FALSE;
-	return rt_status;
-
-}
-#endif
 
--- a/drivers/staging/rtl8192su/r8192S_hw.h
+++ b/drivers/staging/rtl8192su/r8192S_hw.h
@@ -49,10 +49,8 @@ typedef	enum _RT_RF_TYPE_DEFINITION
 	RF_1T2R = 0,
 	RF_2T4R,
 	RF_2T2R,
-#ifdef RTL8192SU
 	RF_1T1R,
 	RF_2T2R_GREEN,
-#endif
 	//RF_3T3R,
 	//RF_3T4R,
 	//RF_4T4R,
--- a/drivers/staging/rtl8192su/r8192S_phy.c
+++ b/drivers/staging/rtl8192su/r8192S_phy.c
@@ -35,17 +35,11 @@
 #include "r8192U_dm.h"
 #include "r8192S_rtl6052.h"
 
-#ifdef RTL8192SU
 #include "r8192S_hw.h"
 #include "r8192S_phy.h"
 #include "r8192S_phyreg.h"
 #include "r8192SU_HWImg.h"
 //#include "r8192S_FwImgDTM.h"
-#else
-#include "r8192U_hw.h"
-#include "r819xU_phy.h"
-#include "r819xU_phyreg.h"
-#endif
 
 #include "ieee80211/dot11d.h"
 
@@ -58,26 +52,6 @@
 
 /*------------------------Define local variable------------------------------*/
 // 2004-05-11
-#ifndef RTL8192SU
-static u32	RF_CHANNEL_TABLE_ZEBRA[]={
-		0,
-		0x085c,//2412 1
-		0x08dc,//2417 2
-		0x095c,//2422 3
-		0x09dc,//2427 4
-		0x0a5c,//2432 5
-		0x0adc,//2437 6
-		0x0b5c,//2442 7
-		0x0bdc,//2447 8
-		0x0c5c,//2452 9
-		0x0cdc,//2457 10
-		0x0d5c,//2462 11
-		0x0ddc,//2467 12
-		0x0e5c,//2472 13
-		//0x0f5c,//2484
-		0x0f72,//2484  //20040810
-};
-#endif
 
 static	u32
 phy_CalculateBitShift(u32 BitMask);
@@ -114,7 +88,6 @@ static u8 phy_DbmToTxPwrIdx( struct net_
 void phy_SetFwCmdIOCallback(struct net_device* dev);
 
 //#if ((HAL_CODE_BASE == RTL8192_S) && (DEV_BUS_TYPE==USB_INTERFACE))
-#ifdef RTL8192SU
 //
 // Description:
 //	Base Band read by 4181 to make sure that operation could be done in unlimited cycle.
@@ -382,7 +355,6 @@ void phy_SetUsbRFReg(struct net_device* 
 
 }
 
-#endif
 
 /*---------------------Define local function prototype-----------------------*/
 
@@ -422,7 +394,6 @@ u32 rtl8192_QueryBBReg(struct net_device
 	// 2008.09.06.
 	//
 //#if ((HAL_CODE_BASE == RTL8192_S) && (DEV_BUS_TYPE==USB_INTERFACE))
-#ifdef RTL8192SU
 	if(IS_BB_REG_OFFSET_92S(RegAddr))
 	{
 		//if(RT_USB_CANNOT_IO(Adapter))	return	FALSE;
@@ -436,7 +407,6 @@ u32 rtl8192_QueryBBReg(struct net_device
 	OriginalValue = phy_QueryUsbBBReg(dev, RegAddr);
 	}
 	else
-#endif
 	{
 	OriginalValue = read_nic_dword(dev, RegAddr);
 	}
@@ -482,7 +452,6 @@ void rtl8192_setBBreg(struct net_device*
 	// 2008.09.06.
 	//
 //#if ((HAL_CODE_BASE == RTL8192_S) && (DEV_BUS_TYPE==USB_INTERFACE))
-#ifdef RTL8192SU
 	if(IS_BB_REG_OFFSET_92S(RegAddr))
 	{
 		if((RegAddr & 0x03) != 0)
@@ -501,7 +470,6 @@ void rtl8192_setBBreg(struct net_device*
 			phy_SetUsbBBReg(dev, RegAddr, Data);
 	}
 	else
-#endif
 	{
 		if(BitMask!= bMaskDWord)
 		{//if not "double word" write
@@ -571,19 +539,8 @@ u32 rtl8192_phy_QueryRFReg(struct net_de
 	// 2008.09.06.
 	//
 //#if (HAL_CODE_BASE == RTL8192_S && DEV_BUS_TYPE==USB_INTERFACE)
-#ifdef RTL8192SU
 	//if(RT_USB_CANNOT_IO(Adapter))	return FALSE;
 	Original_Value = phy_QueryUsbRFReg(dev, eRFPath, RegAddr);
-#else
-	if (priv->Rf_Mode == RF_OP_By_FW)
-	{
-		Original_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
-	}
-	else
-	{
-		Original_Value = phy_RFSerialRead(dev, eRFPath, RegAddr);
-	}
-#endif
 
 	BitShift =  phy_CalculateBitShift(BitMask);
 	Readback_Value = (Original_Value & BitMask) >> BitShift;
@@ -647,7 +604,6 @@ void rtl8192_phy_SetRFReg(struct net_dev
 	// 2008.09.06.
 	//
 //#if (HAL_CODE_BASE == RTL8192_S && DEV_BUS_TYPE==USB_INTERFACE)
-#ifdef RTL8192SU
 		//if(RT_USB_CANNOT_IO(Adapter))	return;
 
 		if (BitMask != bRFRegOffsetMask) // RF data is 12 bits only
@@ -659,37 +615,6 @@ void rtl8192_phy_SetRFReg(struct net_dev
 		}
 		else
 			phy_SetUsbRFReg(dev, eRFPath, RegAddr, Data);
-#else
-	if (priv->Rf_Mode == RF_OP_By_FW)
-	{
-		//DbgPrint("eRFPath-%d Addr[%02x] = %08x\n", eRFPath, RegAddr, Data);
-		if (BitMask != bRFRegOffsetMask) // RF data is 12 bits only
-		{
-			Original_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);
-			BitShift =  phy_CalculateBitShift(BitMask);
-			New_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
-
-			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, New_Value);
-		}
-		else
-			phy_FwRFSerialWrite(dev, eRFPath, RegAddr, Data);
-	}
-	else
-	{
-		//DbgPrint("eRFPath-%d Addr[%02x] = %08x\n", eRFPath, RegAddr, Data);
-		if (BitMask != bRFRegOffsetMask) // RF data is 12 bits only
-		{
-			Original_Value = phy_RFSerialRead(dev, eRFPath, RegAddr);
-			BitShift =  phy_CalculateBitShift(BitMask);
-			New_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
-
-			phy_RFSerialWrite(dev, eRFPath, RegAddr, New_Value);
-		}
-		else
-			phy_RFSerialWrite(dev, eRFPath, RegAddr, Data);
-
-	}
-#endif
 	//PlatformReleaseSpinLock(dev, RT_RF_OPERATE_SPINLOCK);
 	//spin_unlock_irqrestore(&priv->rf_lock, flags);   //YJ,test,090113
 	up(&priv->rf_sem);
@@ -1477,11 +1402,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(st
 				if(Rtl819XRadioA_Array_Table[i] == 0xfe)
 					{ // Deay specific ms. Only RF configuration require delay.
 //#if (DEV_BUS_TYPE == USB_INTERFACE)
-#ifdef RTL8192SU
 						mdelay(1000);
-#else
-						mdelay(50);
-#endif
 				}
 					else if (Rtl819XRadioA_Array_Table[i] == 0xfd)
 						mdelay(5);
@@ -1505,11 +1426,7 @@ u8 rtl8192_phy_ConfigRFWithHeaderFile(st
 				if(Rtl819XRadioB_Array_Table[i] == 0xfe)
 					{ // Deay specific ms. Only RF configuration require delay.
 //#if (DEV_BUS_TYPE == USB_INTERFACE)
-#ifdef RTL8192SU
 						mdelay(1000);
-#else
-						mdelay(50);
-#endif
 				}
 					else if (Rtl819XRadioB_Array_Table[i] == 0xfd)
 						mdelay(5);
@@ -2969,9 +2886,7 @@ void rtl8192_SetBWMode(struct net_device
 #endif
 	if((priv->up) )// && !(RT_CANNOT_IO(Adapter) && Adapter->bInSetPower) )
 	{
-#if   defined(RTL8192SU)
 	SetBWModeCallback8192SUsbWorkItem(dev);
-#endif
 	}
 	else
 	{
@@ -3086,9 +3001,7 @@ u8 rtl8192_phy_SwChnl(struct net_device*
 
 	if((priv->up))// && !(RT_CANNOT_IO(Adapter) && Adapter->bInSetPower))
 	{
-#if   defined(RTL8192SU)
 	SwChnlCallback8192SUsbWorkItem(dev);
-#endif
 #ifdef TO_DO_LIST
 	if(bResult)
 		{
@@ -3339,13 +3252,9 @@ phy_SwChnlStepByStep(
 		case CmdID_RF_WriteReg:	// Only modify channel for the register now !!!!!
 			for(eRFPath = 0; eRFPath <priv->NumTotalRFPath; eRFPath++)
 			{
-#if defined RTL8192SU
 			// For new T65 RF 0222d register 0x18 bit 0-9 = channel number.
 				rtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, 0x1f, (CurrentCmd->Para2));
 				//printk("====>%x, %x, read_back:%x\n", CurrentCmd->Para2,CurrentCmd->Para1, rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, 0x1f));
-#else
-				rtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, bRFRegOffsetMask, ((CurrentCmd->Para2)<<7));
-#endif
 			}
 			break;
                 default:
@@ -3813,7 +3722,6 @@ extern void PHY_IQCalibrateBcut(struct n
 //
 //-------------------------Move to other DIR later----------------------------*/
 //#if (DEV_BUS_TYPE == USB_INTERFACE)
-#ifdef RTL8192SU
 
 //    use in phy only (in win it's timer)
 void SwChnlCallback8192SUsb(struct net_device *dev)
@@ -4190,7 +4098,6 @@ void SetBWModeCallback8192SUsbWorkItem(s
 }
 
 //--------------------------Move to oter DIR later-------------------------------*/
-#ifdef RTL8192SU
 void InitialGain8192S(struct net_device *dev,	u8 Operation)
 {
 #ifdef TO_DO_LIST
@@ -4198,7 +4105,6 @@ void InitialGain8192S(struct net_device 
 #endif
 
 }
-#endif
 
 void InitialGain819xUsb(struct net_device *dev,	u8 Operation)
 {
@@ -4284,7 +4190,6 @@ extern void InitialGainOperateWorkItemCa
 	}
 }
 
-#endif	// #if (DEV_BUS_TYPE == USB_INTERFACE)
 
 //-----------------------------------------------------------------------------
 //	Description:
--- a/drivers/staging/rtl8192su/r8192S_rtl6052.c
+++ b/drivers/staging/rtl8192su/r8192S_rtl6052.c
@@ -23,15 +23,9 @@
 #include "r8192U.h"
 #include "r8192S_rtl6052.h"
 
-#ifdef RTL8192SU
 #include "r8192S_hw.h"
 #include "r8192S_phyreg.h"
 #include "r8192S_phy.h"
-#else
-#include "r8192U_hw.h"
-#include "r819xU_phyreg.h"
-#include "r819xU_phy.h"
-#endif
 
 
 /*---------------------------Define Local Constant---------------------------*/
@@ -162,7 +156,6 @@ void PHY_RF6052SetBandwidth(struct net_d
 
 
 	//if (priv->card_8192 == NIC_8192SE)
-#ifdef RTL8192SU  //YJ,test,090113
 	{
 		switch(Bandwidth)
 		{
@@ -184,26 +177,6 @@ void PHY_RF6052SetBandwidth(struct net_d
 		}
 	}
 //	else
-#else
-	{
-	for(eRFPath = 0; eRFPath <priv->NumTotalRFPath; eRFPath++)
-	{
-		switch(Bandwidth)
-		{
-			case HT_CHANNEL_WIDTH_20:
-					//PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, RF_CHNLBW, (BIT10|BIT11), 0x01);
-				break;
-			case HT_CHANNEL_WIDTH_20_40:
-					//PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A, RF_CHNLBW, (BIT10|BIT11), 0x00);
-				break;
-			default:
-					RT_TRACE(COMP_DBG, "PHY_SetRF8225Bandwidth(): unknown Bandwidth: %#X\n",Bandwidth );
-				break;
-
-		}
-	}
-	}
-#endif
 }
 
 
--- a/drivers/staging/rtl8192su/r8192U_core.c
+++ b/drivers/staging/rtl8192su/r8192U_core.c
@@ -58,7 +58,6 @@ double __extendsfdf2(float a) {return a;
 
 #define CONFIG_RTL8192_IO_MAP
 
-#ifdef RTL8192SU
 #include <asm/uaccess.h>
 #include "r8192U.h"
 //#include "r8190_rtl8256.h" /* RTL8225 Radio frontend */
@@ -80,29 +79,8 @@ double __extendsfdf2(float a) {return a;
 
 #include "ieee80211/dot11d.h"
 
-#else
-
-#include <asm/uaccess.h>
-#include "r8192U_hw.h"
-#include "r8192U.h"
-#include "r8190_rtl8256.h" /* RTL8225 Radio frontend */
-#include "r8180_93cx6.h"   /* Card EEPROM */
-#include "r8192U_wx.h"
-#include "r819xU_phy.h" //added by WB 4.30.2008
-#include "r819xU_phyreg.h"
-#include "r819xU_cmdpkt.h"
-#include "r8192U_dm.h"
-//#include "r8192xU_phyreg.h"
-#include <linux/usb.h>
-
-#include "r8192U_pm.h"
-
-#include "ieee80211/dot11d.h"
-
-#endif
 
 
-#ifdef RTL8192SU
 u32 rt_global_debug_component = \
 //				COMP_TRACE	|
 //    				COMP_DBG	|
@@ -136,29 +114,6 @@ u32 rt_global_debug_component = \
 				COMP_DOWN	|
 				COMP_RESET	|
 				COMP_ERR; //always open err flags on
-#else
-//set here to open your trace code. //WB
-u32 rt_global_debug_component = \
-			//	COMP_INIT    	|
-//				COMP_DBG	|
-			//	COMP_EPROM   	|
-//				COMP_PHY	|
-			//	COMP_RF		|
-//				COMP_FIRMWARE	|
-//				COMP_CH		|
-			//	COMP_POWER_TRACKING |
-//				COMP_RATE	|
-			//	COMP_TXAGC	|
-		//		COMP_TRACE	|
-				COMP_DOWN	|
-		//		COMP_RECV	|
-                //              COMP_SWBW	|
-				COMP_SEC	|
-	//			COMP_RESET	|
-		//		COMP_SEND	|
-			//	COMP_EVENTS	|
-				COMP_ERR ; //always open err flags on
-#endif
 
 #define TOTAL_CAM_ENTRY 32
 #define CAM_CONTENT_COUNT 8
@@ -224,7 +179,6 @@ static struct usb_driver rtl8192_usb_dri
 };
 
 
-#ifdef RTL8192SU
 static void 	rtl8192SU_read_eeprom_info(struct net_device *dev);
 short 	rtl8192SU_tx(struct net_device *dev, struct sk_buff* skb);
 void 	rtl8192SU_rx_nomal(struct sk_buff* skb);
@@ -247,30 +201,6 @@ struct rtl819x_ops rtl8192su_ops = {
 	.rtl819x_initial_gain = InitialGain8192S,
 	.rtl819x_query_rxdesc_status = rtl8192SU_query_rxdesc_status,
 };
-#else
-static void 	rtl8192_read_eeprom_info(struct net_device *dev);
-short	rtl8192_tx(struct net_device *dev, struct sk_buff* skb);
-void 	rtl8192_rx_nomal(struct sk_buff* skb);
-void 	rtl8192_rx_cmd(struct sk_buff *skb);
-bool 	rtl8192_adapter_start(struct net_device *dev);
-short	rtl819xU_tx_cmd(struct net_device *dev, struct sk_buff *skb);
-void 	rtl8192_link_change(struct net_device *dev);
-void 	InitialGain819xUsb(struct net_device *dev,u8 Operation);
-void 	query_rxdesc_status(struct sk_buff *skb, struct ieee80211_rx_stats *stats, bool bIsRxAggrSubframe);
-
-struct rtl819x_ops rtl8192u_ops = {
-	.nic_type = NIC_8192U,
-	.rtl819x_read_eeprom_info = rtl8192_read_eeprom_info,
-	.rtl819x_tx = rtl8192_tx,
-	.rtl819x_tx_cmd = rtl819xU_tx_cmd,
-	.rtl819x_rx_nomal = rtl8192_rx_nomal,
-	.rtl819x_rx_cmd = rtl8192_rx_cmd,
-	.rtl819x_adapter_start = rtl8192_adapter_start,
-	.rtl819x_link_change = rtl8192_link_change,
-	.rtl819x_initial_gain = InitialGain819xUsb,
-	.rtl819x_query_rxdesc_status = query_rxdesc_status,
-};
-#endif
 
 
 typedef struct _CHANNEL_LIST
@@ -350,7 +280,6 @@ static void rtl819x_set_channel_map(u8 c
 
 #define eqMacAddr(a,b) ( ((a)[0]==(b)[0] && (a)[1]==(b)[1] && (a)[2]==(b)[2] && (a)[3]==(b)[3] && (a)[4]==(b)[4] && (a)[5]==(b)[5]) ? 1:0 )
 
-#ifdef RTL8192SU
 #define		rx_hal_is_cck_rate(_pDesc)\
 			((_pDesc->RxMCS  == DESC92S_RATE1M ||\
 			_pDesc->RxMCS == DESC92S_RATE2M ||\
@@ -364,14 +293,6 @@ static void rtl819x_set_channel_map(u8 c
 			 _DataRate == MGN_5_5M ||\
 			 _DataRate == MGN_11M )
 
-#else
-#define 	rx_hal_is_cck_rate(_pdrvinfo)\
-			((_pdrvinfo->RxRate == DESC90_RATE1M ||\
-			_pdrvinfo->RxRate == DESC90_RATE2M ||\
-			_pdrvinfo->RxRate == DESC90_RATE5_5M ||\
-			_pdrvinfo->RxRate == DESC90_RATE11M) &&\
-			!_pdrvinfo->RxHT)
-#endif
 
 
 
@@ -456,11 +377,7 @@ void write_nic_byte(struct net_device *d
 
 	status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
-#ifdef RTL8192SU
 			       indx, 0, &data, 1, HZ / 2);
-#else
-			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 1, HZ / 2);
-#endif
 
         if (status < 0)
         {
@@ -481,11 +398,7 @@ void write_nic_word(struct net_device *d
 
 	status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
-#ifdef RTL8192SU
 			       indx, 0, &data, 2, HZ / 2);
-#else
-			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 2, HZ / 2);
-#endif
 
         if (status < 0)
         {
@@ -505,11 +418,7 @@ void write_nic_dword(struct net_device *
 
 	status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
-#ifdef RTL8192SU
 			       indx, 0, &data, 4, HZ / 2);
-#else
-			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 4, HZ / 2);
-#endif
 
 
         if (status < 0)
@@ -530,11 +439,7 @@ u8 read_nic_byte(struct net_device *dev,
 
 	status = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
-#ifdef RTL8192SU
 			       indx, 0, &data, 1, HZ / 2);
-#else
-			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 1, HZ / 2);
-#endif
 
         if (status < 0)
         {
@@ -555,11 +460,7 @@ u16 read_nic_word(struct net_device *dev
 
 	status = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
-#ifdef RTL8192SU
 			       indx, 0, &data, 2, HZ / 2);
-#else
-			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 2, HZ / 2);
-#endif
 
         if (status < 0)
         {
@@ -601,11 +502,7 @@ u32 read_nic_dword(struct net_device *de
 
 	status = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
-#ifdef RTL8192SU
 			       indx, 0, &data, 4, HZ / 2);
-#else
-			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 4, HZ / 2);
-#endif
 //	if(0 != result) {
 //	  printk(KERN_WARNING "read size of data = %d\, date = %d\n", result, data);
 //	}
@@ -681,7 +578,6 @@ static int proc_get_stats_ap(char *page,
 	return len;
 }
 
-#ifdef RTL8192SU
 static int proc_get_registers(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -972,73 +868,6 @@ static int proc_get_registers_e(char *pa
 	*eof = 1;
 	return len;
 }
-#else
-static int proc_get_registers(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-//	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-
-	int len = 0;
-	int i,n;
-
-	int max=0xff;
-
-	/* This dump the current register page */
-len += snprintf(page + len, count - len,
-                        "\n####################page 0##################\n ");
-
-	for(n=0;n<=max;)
-	{
-		//printk( "\nD: %2x> ", n);
-		len += snprintf(page + len, count - len,
-			"\nD:  %2x > ",n);
-
-		for(i=0;i<16 && n<=max;i++,n++)
-		len += snprintf(page + len, count - len,
-			"%2x ",read_nic_byte(dev,0x000|n));
-
-		//	printk("%2x ",read_nic_byte(dev,n));
-	}
-#if 1
-len += snprintf(page + len, count - len,
-                        "\n####################page 1##################\n ");
-        for(n=0;n<=max;)
-        {
-                //printk( "\nD: %2x> ", n);
-                len += snprintf(page + len, count - len,
-                        "\nD:  %2x > ",n);
-
-                for(i=0;i<16 && n<=max;i++,n++)
-                len += snprintf(page + len, count - len,
-                        "%2x ",read_nic_byte(dev,0x100|n));
-
-                //      printk("%2x ",read_nic_byte(dev,n));
-        }
-len += snprintf(page + len, count - len,
-                        "\n####################page 3##################\n ");
-        for(n=0;n<=max;)
-        {
-                //printk( "\nD: %2x> ", n);
-                len += snprintf(page + len, count - len,
-                        "\nD:  %2x > ",n);
-
-                for(i=0;i<16 && n<=max;i++,n++)
-                len += snprintf(page + len, count - len,
-                        "%2x ",read_nic_byte(dev,0x300|n));
-
-                //      printk("%2x ",read_nic_byte(dev,n));
-        }
-
-#endif
-
-	len += snprintf(page + len, count - len,"\n");
-	*eof = 1;
-	return len;
-
-}
-#endif
 
 #if 0
 static int proc_get_cck_reg(char *page, char **start,
@@ -1341,7 +1170,6 @@ void rtl8192_proc_init_one(struct net_de
 		      "/proc/net/rtl8192/%s/registers\n",
 		      dev->name);
 	}
-#ifdef RTL8192SU
 	e = create_proc_read_entry("registers-1", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_registers_1, dev);
 	if (!e) {
@@ -1405,7 +1233,6 @@ void rtl8192_proc_init_one(struct net_de
 		      "/proc/net/rtl8192/%s/registers-e\n",
 		      dev->name);
 	}
-#endif
 #if 0
 	e = create_proc_read_entry("cck-registers", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_cck_reg, dev);
@@ -2347,7 +2174,6 @@ void rtl8192_update_cap(struct net_devic
 	priv->short_preamble = cap & WLAN_CAPABILITY_SHORT_PREAMBLE;
 
 	//LZM MOD 090303 HW_VAR_ACK_PREAMBLE
-#ifdef RTL8192SU
 	if(0)
 	{
 		u8 tmp = 0;
@@ -2356,15 +2182,6 @@ void rtl8192_update_cap(struct net_devic
 			tmp |= 0x80;
 		write_nic_byte(dev, RRSR+2, tmp);
 	}
-#else
-	{
-	u32 tmp = 0;
-	tmp = priv->basic_rate;
-	if (priv->short_preamble)
-		tmp |= BRSR_AckShortPmb;
-	write_nic_dword(dev, RRSR, tmp);
-	}
-#endif
 
 	if (net->mode & (IEEE_G|IEEE_N_24G))
 	{
@@ -2593,7 +2410,6 @@ unsigned int txqueue2outpipe(struct r819
 	return priv->txqueue_to_outpipemap[tx_queue];
 }
 
-#ifdef RTL8192SU
 short rtl8192SU_tx_cmd(struct net_device *dev, struct sk_buff *skb)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -2653,62 +2469,6 @@ short rtl8192SU_tx_cmd(struct net_device
 		return -1;
 	}
 }
-#else
-short rtl819xU_tx_cmd(struct net_device *dev, struct sk_buff *skb)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	//u8			*tx;
-	int			status;
-	struct urb		*tx_urb;
-	//int			urb_buf_len;
-	unsigned int 		idx_pipe;
-	tx_desc_cmd_819x_usb *pdesc = (tx_desc_cmd_819x_usb *)skb->data;
-	cb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
-	u8 queue_index = tcb_desc->queue_index;
-
-	//printk("\n %s::queue_index = %d\n",__FUNCTION__, queue_index);
-	atomic_inc(&priv->tx_pending[queue_index]);
-
-	tx_urb = usb_alloc_urb(0,GFP_ATOMIC);
-	if(!tx_urb){
-		dev_kfree_skb(skb);
-		return -ENOMEM;
-	}
-
-	memset(pdesc, 0, USB_HWDESC_HEADER_LEN);
-	/* Tx descriptor ought to be set according to the skb->cb */
-	pdesc->FirstSeg = 1;//bFirstSeg;
-	pdesc->LastSeg = 1;//bLastSeg;
-	pdesc->CmdInit = tcb_desc->bCmdOrInit;
-	pdesc->TxBufferSize = tcb_desc->txbuf_size;
-	pdesc->OWN = 1;
-	pdesc->LINIP = tcb_desc->bLastIniPkt;
-
-	//----------------------------------------------------------------------------
-	// Fill up USB_OUT_CONTEXT.
-	//----------------------------------------------------------------------------
-	// Get index to out pipe from specified QueueID.
-	idx_pipe = txqueue2outpipe(priv,queue_index);
-#ifdef JOHN_DUMP_TXDESC
-	int i;
-	printk("<Tx descriptor>--rate %x---",rate);
-	for (i = 0; i < 8; i++)
-		printk("%8x ", tx[i]);
-	printk("\n");
-#endif
-	usb_fill_bulk_urb(tx_urb,priv->udev, usb_sndbulkpipe(priv->udev,idx_pipe), \
-			skb->data, skb->len, rtl8192_tx_isr, skb);
-
-	status = usb_submit_urb(tx_urb, GFP_ATOMIC);
-	if (!status){
-		return 0;
-	}else{
-		DMESGE("Error TX CMD URB, error %d",
-				status);
-		return -1;
-	}
-}
-#endif
 
 /*
  * Mapping Software/Hardware descriptor queue id to "Queue Select Field"
@@ -2763,7 +2523,6 @@ u8 MapHwQueueToFirmwareQueue(u8 QueueID)
 	return QueueSelect;
 }
 
-#ifdef RTL8192SU
 u8 MRateToHwRate8190Pci(u8 rate)
 {
 	u8	ret = DESC92S_RATE1M;
@@ -2828,49 +2587,6 @@ u8 MRateToHwRate8190Pci(u8 rate)
 	}
 	return ret;
 }
-#else
-u8 MRateToHwRate8190Pci(u8 rate)
-{
-	u8  ret = DESC90_RATE1M;
-
-	switch(rate) {
-		case MGN_1M:    ret = DESC90_RATE1M;    break;
-		case MGN_2M:    ret = DESC90_RATE2M;    break;
-		case MGN_5_5M:  ret = DESC90_RATE5_5M;  break;
-		case MGN_11M:   ret = DESC90_RATE11M;   break;
-		case MGN_6M:    ret = DESC90_RATE6M;    break;
-		case MGN_9M:    ret = DESC90_RATE9M;    break;
-		case MGN_12M:   ret = DESC90_RATE12M;   break;
-		case MGN_18M:   ret = DESC90_RATE18M;   break;
-		case MGN_24M:   ret = DESC90_RATE24M;   break;
-		case MGN_36M:   ret = DESC90_RATE36M;   break;
-		case MGN_48M:   ret = DESC90_RATE48M;   break;
-		case MGN_54M:   ret = DESC90_RATE54M;   break;
-
-		// HT rate since here
-		case MGN_MCS0:  ret = DESC90_RATEMCS0;  break;
-		case MGN_MCS1:  ret = DESC90_RATEMCS1;  break;
-		case MGN_MCS2:  ret = DESC90_RATEMCS2;  break;
-		case MGN_MCS3:  ret = DESC90_RATEMCS3;  break;
-		case MGN_MCS4:  ret = DESC90_RATEMCS4;  break;
-		case MGN_MCS5:  ret = DESC90_RATEMCS5;  break;
-		case MGN_MCS6:  ret = DESC90_RATEMCS6;  break;
-		case MGN_MCS7:  ret = DESC90_RATEMCS7;  break;
-		case MGN_MCS8:  ret = DESC90_RATEMCS8;  break;
-		case MGN_MCS9:  ret = DESC90_RATEMCS9;  break;
-		case MGN_MCS10: ret = DESC90_RATEMCS10; break;
-		case MGN_MCS11: ret = DESC90_RATEMCS11; break;
-		case MGN_MCS12: ret = DESC90_RATEMCS12; break;
-		case MGN_MCS13: ret = DESC90_RATEMCS13; break;
-		case MGN_MCS14: ret = DESC90_RATEMCS14; break;
-		case MGN_MCS15: ret = DESC90_RATEMCS15; break;
-		case (0x80|0x20): ret = DESC90_RATEMCS32; break;
-
-		default:       break;
-	}
-	return ret;
-}
-#endif
 
 u8 QueryIsShort(u8 TxHT, u8 TxRate, cb_desc *tcb_desc)
 {
@@ -2890,7 +2606,6 @@ static void tx_zero_isr(struct urb *tx_u
 }
 
 
-#ifdef RTL8192SU
 /*
  * The tx procedure is just as following,  skb->cb will contain all the following
  *information: * priority, morefrag, rate, &dev.
@@ -3224,311 +2939,47 @@ short rtl8192SU_tx(struct net_device *de
 		return -1;
 	}
 }
-#else
 
-/*
- * The tx procedure is just as following,
- * skb->cb will contain all the following information,
- * priority, morefrag, rate, &dev.
- * */
-short rtl8192_tx(struct net_device *dev, struct sk_buff* skb)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	cb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
-	tx_desc_819x_usb *tx_desc = (tx_desc_819x_usb *)skb->data;
-	tx_fwinfo_819x_usb *tx_fwinfo = (tx_fwinfo_819x_usb *)(skb->data + USB_HWDESC_HEADER_LEN);
-	struct usb_device *udev = priv->udev;
-	int pend;
-	int status;
-	struct urb *tx_urb = NULL, *tx_urb_zero = NULL;
-	//int urb_len;
-	unsigned int idx_pipe;
-//	RT_DEBUG_DATA(COMP_SEND, tcb_desc, sizeof(cb_desc));
-#if 0
-	/* Added by Annie for filling Len_Adjust field. 2005-12-14. */
-        RT_ENC_ALG  EncAlg = NO_Encryption;
-#endif
-//	printk("=============> %s\n", __FUNCTION__);
-	pend = atomic_read(&priv->tx_pending[tcb_desc->queue_index]);
-	/* we are locked here so the two atomic_read and inc are executed
-	 * without interleaves
-	 * !!! For debug purpose
-	 */
-	if( pend > MAX_TX_URB){
 #if 0
-		switch (tcb_desc->queue_index) {
-			case VO_PRIORITY:
-				priv->stats.txvodrop++;
-				break;
-			case VI_PRIORITY:
-				priv->stats.txvidrop++;
-				break;
-			case BE_PRIORITY:
-				priv->stats.txbedrop++;
-				break;
-			default://BK_PRIORITY
-				priv->stats.txbkdrop++;
-				break;
-		}
-#endif
-		printk("To discard skb packet!\n");
-		dev_kfree_skb_any(skb);
-		return -1;
-	}
+void rtl8192_set_rate(struct net_device *dev)
+{
+	int i;
+	u16 word;
+	int basic_rate,min_rr_rate,max_rr_rate;
 
-	tx_urb = usb_alloc_urb(0,GFP_ATOMIC);
-	if(!tx_urb){
-		dev_kfree_skb_any(skb);
-		return -ENOMEM;
-	}
+//	struct r8192_priv *priv = ieee80211_priv(dev);
 
-	/* Fill Tx firmware info */
-	memset(tx_fwinfo,0,sizeof(tx_fwinfo_819x_usb));
-	/* DWORD 0 */
-	tx_fwinfo->TxHT = (tcb_desc->data_rate&0x80)?1:0;
-	tx_fwinfo->TxRate = MRateToHwRate8190Pci(tcb_desc->data_rate);
-	tx_fwinfo->EnableCPUDur = tcb_desc->bTxEnableFwCalcDur;
-	tx_fwinfo->Short = QueryIsShort(tx_fwinfo->TxHT, tx_fwinfo->TxRate, tcb_desc);
-	if(tcb_desc->bAMPDUEnable) {//AMPDU enabled
-		tx_fwinfo->AllowAggregation = 1;
-		/* DWORD 1 */
-		tx_fwinfo->RxMF = tcb_desc->ampdu_factor;
-		tx_fwinfo->RxAMD = tcb_desc->ampdu_density&0x07;//ampdudensity
-	} else {
-		tx_fwinfo->AllowAggregation = 0;
-		/* DWORD 1 */
-		tx_fwinfo->RxMF = 0;
-		tx_fwinfo->RxAMD = 0;
-	}
+	//if (ieee80211_is_54g(priv->ieee80211->current_network) &&
+//		priv->ieee80211->state == IEEE80211_LINKED){
+	basic_rate = ieeerate2rtlrate(240);
+	min_rr_rate = ieeerate2rtlrate(60);
+	max_rr_rate = ieeerate2rtlrate(240);
 
-	/* Protection mode related */
-	tx_fwinfo->RtsEnable = (tcb_desc->bRTSEnable)?1:0;
-	tx_fwinfo->CtsEnable = (tcb_desc->bCTSEnable)?1:0;
-	tx_fwinfo->RtsSTBC = (tcb_desc->bRTSSTBC)?1:0;
-	tx_fwinfo->RtsHT = (tcb_desc->rts_rate&0x80)?1:0;
-	tx_fwinfo->RtsRate =  MRateToHwRate8190Pci((u8)tcb_desc->rts_rate);
-	tx_fwinfo->RtsSubcarrier = (tx_fwinfo->RtsHT==0)?(tcb_desc->RTSSC):0;
-	tx_fwinfo->RtsBandwidth = (tx_fwinfo->RtsHT==1)?((tcb_desc->bRTSBW)?1:0):0;
-	tx_fwinfo->RtsShort = (tx_fwinfo->RtsHT==0)?(tcb_desc->bRTSUseShortPreamble?1:0):\
-				(tcb_desc->bRTSUseShortGI?1:0);
+//
+//	}else{
+//		basic_rate = ieeerate2rtlrate(20);
+//		min_rr_rate = ieeerate2rtlrate(10);
+//		max_rr_rate = ieeerate2rtlrate(110);
+//	}
 
-	/* Set Bandwidth and sub-channel settings. */
-	if(priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20_40)
-	{
-		if(tcb_desc->bPacketBW) {
-			tx_fwinfo->TxBandwidth = 1;
-			tx_fwinfo->TxSubCarrier = 0;    //By SD3's Jerry suggestion, use duplicated mode
-		} else {
-			tx_fwinfo->TxBandwidth = 0;
-			tx_fwinfo->TxSubCarrier = priv->nCur40MhzPrimeSC;
-		}
-	} else {
-		tx_fwinfo->TxBandwidth = 0;
-		tx_fwinfo->TxSubCarrier = 0;
-	}
+	write_nic_byte(dev, RESP_RATE,
+			max_rr_rate<<MAX_RESP_RATE_SHIFT| min_rr_rate<<MIN_RESP_RATE_SHIFT);
 
-	/* Fill Tx descriptor */
-	memset(tx_desc, 0, sizeof(tx_desc_819x_usb));
-	/* DWORD 0 */
-        tx_desc->LINIP = 0;
-        tx_desc->CmdInit = 1;
-        tx_desc->Offset =  sizeof(tx_fwinfo_819x_usb) + 8;
+	//word  = read_nic_word(dev, BRSR);
+	word  = read_nic_word(dev, BRSR_8187);
+	word &= ~BRSR_MBR_8185;
 
-	{
-		tx_desc->PktSize = (skb->len - TX_PACKET_SHIFT_BYTES) & 0xffff;
-	}
 
-	/*DWORD 1*/
-	tx_desc->SecCAMID= 0;
-	tx_desc->RATid = tcb_desc->RATRIndex;
-#if 0
-	/* Fill security related */
-	if( pTcb->bEncrypt && !Adapter->MgntInfo.SecurityInfo.SWTxEncryptFlag)
-	{
-		EncAlg = SecGetEncryptionOverhead(
-				Adapter,
-				&EncryptionMPDUHeadOverhead,
-				&EncryptionMPDUTailOverhead,
-				NULL,
-				NULL,
-				FALSE,
-				FALSE);
-		//2004/07/22, kcwu, EncryptionMPDUHeadOverhead has been added in previous code
-		//MPDUOverhead = EncryptionMPDUHeadOverhead + EncryptionMPDUTailOverhead;
-		MPDUOverhead = EncryptionMPDUTailOverhead;
-		tx_desc->NoEnc = 0;
-		RT_TRACE(COMP_SEC, DBG_LOUD, ("******We in the loop SecCAMID is %d SecDescAssign is %d The Sec is %d********\n",tx_desc->SecCAMID,tx_desc->SecDescAssign,EncAlg));
-		//CamDumpAll(Adapter);
-	}
-	else
+	for(i=0;i<=basic_rate;i++)
+		word |= (1<<i);
+
+	//write_nic_word(dev, BRSR, word);
+	write_nic_word(dev, BRSR_8187, word);
+	//DMESG("RR:%x BRSR: %x", read_nic_byte(dev,RESP_RATE), read_nic_word(dev,BRSR));
+}
 #endif
-	{
-		//MPDUOverhead = 0;
-		tx_desc->NoEnc = 1;
-	}
-#if 0
-	switch(EncAlg){
-		case NO_Encryption:
-			tx_desc->SecType = 0x0;
-			break;
-		case WEP40_Encryption:
-		case WEP104_Encryption:
-			tx_desc->SecType = 0x1;
-			break;
-		case TKIP_Encryption:
-			tx_desc->SecType = 0x2;
-			break;
-		case AESCCMP_Encryption:
-			tx_desc->SecType = 0x3;
-			break;
-		default:
-			tx_desc->SecType = 0x0;
-			break;
-	}
-#else
-	tx_desc->SecType = 0x0;
-#endif
-		if (tcb_desc->bHwSec)
-			{
-				switch (priv->ieee80211->pairwise_key_type)
-				{
-					case KEY_TYPE_WEP40:
-					case KEY_TYPE_WEP104:
-						 tx_desc->SecType = 0x1;
-						 tx_desc->NoEnc = 0;
-						 break;
-					case KEY_TYPE_TKIP:
-						 tx_desc->SecType = 0x2;
-						 tx_desc->NoEnc = 0;
-						 break;
-					case KEY_TYPE_CCMP:
-						 tx_desc->SecType = 0x3;
-						 tx_desc->NoEnc = 0;
-						 break;
-					case KEY_TYPE_NA:
-						 tx_desc->SecType = 0x0;
-						 tx_desc->NoEnc = 1;
-						 break;
-				}
-			}
-
-	tx_desc->QueueSelect = MapHwQueueToFirmwareQueue(tcb_desc->queue_index);
-	tx_desc->TxFWInfoSize =  sizeof(tx_fwinfo_819x_usb);
-
-	tx_desc->DISFB = tcb_desc->bTxDisableRateFallBack;
-	tx_desc->USERATE = tcb_desc->bTxUseDriverAssingedRate;
-
-        /* Fill fields that are required to be initialized in all of the descriptors */
-        //DWORD 0
-#if 0
-        tx_desc->FirstSeg = (tcb_desc->bFirstSeg)? 1:0;
-        tx_desc->LastSeg = (tcb_desc->bLastSeg)?1:0;
-#else
-        tx_desc->FirstSeg = 1;
-        tx_desc->LastSeg = 1;
-#endif
-        tx_desc->OWN = 1;
-
-	{
-		//DWORD 2
-		tx_desc->TxBufferSize = (u32)(skb->len - USB_HWDESC_HEADER_LEN);
-	}
-	/* Get index to out pipe from specified QueueID */
-	idx_pipe = txqueue2outpipe(priv,tcb_desc->queue_index);
-
-	//RT_DEBUG_DATA(COMP_SEND,tx_fwinfo,sizeof(tx_fwinfo_819x_usb));
-	//RT_DEBUG_DATA(COMP_SEND,tx_desc,sizeof(tx_desc_819x_usb));
-
-	/* To submit bulk urb */
-	usb_fill_bulk_urb(tx_urb,udev,
-			usb_sndbulkpipe(udev,idx_pipe), skb->data,
-			skb->len, rtl8192_tx_isr, skb);
-
-	status = usb_submit_urb(tx_urb, GFP_ATOMIC);
-	if (!status){
-//we need to send 0 byte packet whenever 512N bytes/64N(HIGN SPEED/NORMAL SPEED) bytes packet has been transmitted. Otherwise, it will be halt to wait for another packet. WB. 2008.08.27
-		bool bSend0Byte = false;
-		u8 zero = 0;
-		if(udev->speed == USB_SPEED_HIGH)
-		{
-			if (skb->len > 0 && skb->len % 512 == 0)
-				bSend0Byte = true;
-		}
-		else
-		{
-			if (skb->len > 0 && skb->len % 64 == 0)
-				bSend0Byte = true;
-		}
-		if (bSend0Byte)
-		{
-#if 1
-			tx_urb_zero = usb_alloc_urb(0,GFP_ATOMIC);
-			if(!tx_urb_zero){
-				RT_TRACE(COMP_ERR, "can't alloc urb for zero byte\n");
-				return -ENOMEM;
-			}
-			usb_fill_bulk_urb(tx_urb_zero,udev,
-					usb_sndbulkpipe(udev,idx_pipe), &zero,
-					0, tx_zero_isr, dev);
-			status = usb_submit_urb(tx_urb_zero, GFP_ATOMIC);
-			if (status){
-			RT_TRACE(COMP_ERR, "Error TX URB for zero byte %d, error %d", atomic_read(&priv->tx_pending[tcb_desc->queue_index]), status);
-			return -1;
-			}
-#endif
-		}
-		dev->trans_start = jiffies;
-		atomic_inc(&priv->tx_pending[tcb_desc->queue_index]);
-		return 0;
-	}else{
-		RT_TRACE(COMP_ERR, "Error TX URB %d, error %d", atomic_read(&priv->tx_pending[tcb_desc->queue_index]),
-				status);
-		return -1;
-	}
-}
-#endif
-
-#if 0
-void rtl8192_set_rate(struct net_device *dev)
-{
-	int i;
-	u16 word;
-	int basic_rate,min_rr_rate,max_rr_rate;
-
-//	struct r8192_priv *priv = ieee80211_priv(dev);
-
-	//if (ieee80211_is_54g(priv->ieee80211->current_network) &&
-//		priv->ieee80211->state == IEEE80211_LINKED){
-	basic_rate = ieeerate2rtlrate(240);
-	min_rr_rate = ieeerate2rtlrate(60);
-	max_rr_rate = ieeerate2rtlrate(240);
-
-//
-//	}else{
-//		basic_rate = ieeerate2rtlrate(20);
-//		min_rr_rate = ieeerate2rtlrate(10);
-//		max_rr_rate = ieeerate2rtlrate(110);
-//	}
-
-	write_nic_byte(dev, RESP_RATE,
-			max_rr_rate<<MAX_RESP_RATE_SHIFT| min_rr_rate<<MIN_RESP_RATE_SHIFT);
-
-	//word  = read_nic_word(dev, BRSR);
-	word  = read_nic_word(dev, BRSR_8187);
-	word &= ~BRSR_MBR_8185;
-
 
-	for(i=0;i<=basic_rate;i++)
-		word |= (1<<i);
-
-	//write_nic_word(dev, BRSR, word);
-	write_nic_word(dev, BRSR_8187, word);
-	//DMESG("RR:%x BRSR: %x", read_nic_byte(dev,RESP_RATE), read_nic_word(dev,BRSR));
-}
-#endif
 
-
-#ifdef RTL8192SU
 void rtl8192SU_net_update(struct net_device *dev)
 {
 
@@ -3739,42 +3190,6 @@ void rtl8192SU_link_change(struct net_de
 
 	printk("<=====%s 2\n", __func__);
 }
-#else
-extern void rtl8192_update_ratr_table(struct net_device* dev);
-void rtl8192_link_change(struct net_device *dev)
-{
-//	int i;
-
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	struct ieee80211_device* ieee = priv->ieee80211;
-	//write_nic_word(dev, BCN_INTR_ITV, net->beacon_interval);
-	if (ieee->state == IEEE80211_LINKED)
-	{
-		rtl8192_net_update(dev);
-		rtl8192_update_ratr_table(dev);
-#if 1
-		//add this as in pure N mode, wep encryption will use software way, but there is no chance to set this as wep will not set group key in wext. WB.2008.07.08
-		if ((KEY_TYPE_WEP40 == ieee->pairwise_key_type) || (KEY_TYPE_WEP104 == ieee->pairwise_key_type))
-		EnableHWSecurityConfig8192(dev);
-#endif
-	}
-	/*update timing params*/
-//	RT_TRACE(COMP_CH, "========>%s(), chan:%d\n", __FUNCTION__, priv->chan);
-//	rtl8192_set_chan(dev, priv->chan);
-	 if (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC)
-        {
-                u32 reg = 0;
-                reg = read_nic_dword(dev, RCR);
-                if (priv->ieee80211->state == IEEE80211_LINKED)
-                        priv->ReceiveConfig = reg |= RCR_CBSSID;
-                else
-                        priv->ReceiveConfig = reg &= ~RCR_CBSSID;
-                write_nic_dword(dev, RCR, reg);
-        }
-
-//	rtl8192_set_rxconf(dev);
-}
-#endif
 
 static struct ieee80211_qos_parameters def_qos_parameters = {
         {3,3,3,3},/* cw_min */
@@ -4072,9 +3487,7 @@ bool GetHalfNmodeSupportByAPs819xUsb(str
 	struct ieee80211_device* ieee = priv->ieee80211;
 
 // 	Added by Roger, 2008.08.29.
-#ifdef RTL8192SU
 	return false;
-#endif
 
 	if(ieee->bHalfWirelessN24GMode == true)
 		Reval = true;
@@ -4156,10 +3569,8 @@ void rtl8192_SetWirelessMode(struct net_
 #ifdef TO_DO_LIST //// TODO: this function doesn't work well at this time, we shoud wait for FPGA
 	ActUpdateChannelAccessSetting( pAdapter, pHalData->CurrentWirelessMode, &pAdapter->MgntInfo.Info8185.ChannelAccessSetting );
 #endif
-#ifdef RTL8192SU
 	//LZM 090306 usb crash here, mark it temp
 	//write_nic_word(dev, SIFS_OFDM, 0x0e0e);
-#endif
 	priv->ieee80211->mode = wireless_mode;
 
 	if ((wireless_mode == WIRELESS_MODE_N_24G) ||  (wireless_mode == WIRELESS_MODE_N_5G))
@@ -4374,7 +3785,6 @@ static void rtl8192_init_priv_variable(s
 	priv->ieee80211->InitialGainHandler = priv->ops->rtl819x_initial_gain;
 	priv->card_type = USB;
 
-#ifdef RTL8192SU
 //1 RTL8192SU/
 	priv->ieee80211->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;
 	priv->ieee80211->SetFwCmdHandler = HalSetFwCmd8192S;
@@ -4433,51 +3843,6 @@ static void rtl8192_init_priv_variable(s
 
 //1 End
 
-#else
-
-#ifdef TO_DO_LIST
-	if(Adapter->bInHctTest)
-  	{
-		pHalData->ShortRetryLimit = 7;
-		pHalData->LongRetryLimit = 7;
-  	}
-#endif
-	{
-		priv->ShortRetryLimit = 0x30;
-		priv->LongRetryLimit = 0x30;
-	}
-	priv->EarlyRxThreshold = 7;
-	priv->enable_gpio0 = 0;
-	priv->TransmitConfig =
-	//	TCR_DurProcMode |	//for RTL8185B, duration setting by HW
-	//?	TCR_DISReqQsize |
-                (TCR_MXDMA_2048<<TCR_MXDMA_OFFSET)|  // Max DMA Burst Size per Tx DMA Burst, 7: reservied.
-		(priv->ShortRetryLimit<<TCR_SRL_OFFSET)|	// Short retry limit
-		(priv->LongRetryLimit<<TCR_LRL_OFFSET) |	// Long retry limit
-		(false ? TCR_SAT: 0);	// FALSE: HW provies PLCP length and LENGEXT, TURE: SW proiveds them
-#ifdef TO_DO_LIST
-	if(Adapter->bInHctTest)
-		pHalData->ReceiveConfig	=	pHalData->CSMethod |
-						RCR_AMF | RCR_ADF |	//RCR_AAP | 	//accept management/data
-						//guangan200710
-						RCR_ACF |	//accept control frame for SW AP needs PS-poll, 2005.07.07, by rcnjko.
-						RCR_AB | RCR_AM | RCR_APM |		//accept BC/MC/UC
-						RCR_AICV | RCR_ACRC32 | 		//accept ICV/CRC error packet
-						((u32)7<<RCR_MXDMA_OFFSET) | // Max DMA Burst Size per Rx DMA Burst, 7: unlimited.
-						(pHalData->EarlyRxThreshold<<RCR_FIFO_OFFSET) | // Rx FIFO Threshold, 7: No Rx threshold.
-						(pHalData->EarlyRxThreshold == 7 ? RCR_OnlyErlPkt:0);
-	else
-
-#endif
-	priv->ReceiveConfig	=
-		RCR_AMF | RCR_ADF |		//accept management/data
-		RCR_ACF |			//accept control frame for SW AP needs PS-poll, 2005.07.07, by rcnjko.
-		RCR_AB | RCR_AM | RCR_APM |	//accept BC/MC/UC
-		//RCR_AICV | RCR_ACRC32 | 	//accept ICV/CRC error packet
-		((u32)7<<RCR_MXDMA_OFFSET)| // Max DMA Burst Size per Rx DMA Burst, 7: unlimited.
-		(priv->EarlyRxThreshold<<RX_FIFO_THRESHOLD_SHIFT) | // Rx FIFO Threshold, 7: No Rx threshold.
-		(priv->EarlyRxThreshold == 7 ? RCR_ONLYERLPKT:0);
-#endif
 
 	priv->AcmControl = 0;
 	priv->pFirmware = (rt_firmware*)vmalloc(sizeof(rt_firmware));
@@ -4568,7 +3933,6 @@ static inline u16 endian_swap(u16* data)
 	return *data;
 }
 
-#ifdef RTL8192SU
 u8 rtl8192SU_UsbOptionToEndPointNumber(u8 UsbOption)
 {
 	u8	nEndPoint = 0;
@@ -6005,292 +5369,25 @@ static void rtl8192SU_read_eeprom_info(s
 
 	//return RT_STATUS_SUCCESS;
 }
-#else
-static void rtl8192_read_eeprom_info(struct net_device* dev)
+
+short rtl8192_get_channel_map(struct net_device * dev)
 {
-	u16 wEPROM_ID = 0;
-	u8 bMac_Tmp_Addr[6] = {0x00, 0xe0, 0x4c, 0x00, 0x00, 0x02};
-	u8 bLoad_From_EEPOM = false;
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	u16 tmpValue = 0;
-	RT_TRACE(COMP_EPROM, "===========>%s()\n", __FUNCTION__);
-	wEPROM_ID = eprom_read(dev, 0); //first read EEPROM ID out;
-	RT_TRACE(COMP_EPROM, "EEPROM ID is 0x%x\n", wEPROM_ID);
-
-	if (wEPROM_ID != RTL8190_EEPROM_ID)
-	{
-		RT_TRACE(COMP_ERR, "EEPROM ID is invalid(is 0x%x(should be 0x%x)\n", wEPROM_ID, RTL8190_EEPROM_ID);
-	}
-	else
-		bLoad_From_EEPOM = true;
-
-	if (bLoad_From_EEPOM)
-	{
-		tmpValue = eprom_read(dev, (EEPROM_VID>>1));
-		priv->eeprom_vid = endian_swap(&tmpValue);
-		priv->eeprom_pid = eprom_read(dev, (EEPROM_PID>>1));
-		tmpValue = eprom_read(dev, (EEPROM_ChannelPlan>>1));
-		priv->eeprom_ChannelPlan =((tmpValue&0xff00)>>8);
-		priv->btxpowerdata_readfromEEPORM = true;
-		priv->eeprom_CustomerID = eprom_read(dev, (EEPROM_Customer_ID>>1)) >>8;
-	}
-	else
-	{
-		priv->eeprom_vid = 0;
-		priv->eeprom_pid = 0;
-		priv->card_8192_version = VERSION_819xU_B;
-		priv->eeprom_ChannelPlan = 0;
-		priv->eeprom_CustomerID = 0;
-	}
-	RT_TRACE(COMP_EPROM, "vid:0x%4x, pid:0x%4x, CustomID:0x%2x, ChanPlan:0x%x\n", priv->eeprom_vid, priv->eeprom_pid, priv->eeprom_CustomerID, priv->eeprom_ChannelPlan);
-	//set channelplan from eeprom
-	priv->ChannelPlan = priv->eeprom_ChannelPlan;
-	if (bLoad_From_EEPOM)
-	{
-		int i;
-		for (i=0; i<6; i+=2)
-		{
-			u16 tmp = 0;
-			tmp = eprom_read(dev, (u16)((EEPROM_NODE_ADDRESS_BYTE_0 + i)>>1));
-			*(u16*)(&dev->dev_addr[i]) = tmp;
-		}
-	}
-	else
-	{
-		memcpy(dev->dev_addr, bMac_Tmp_Addr, 6);
-		//should I set IDR0 here?
+	if(priv->ChannelPlan > COUNTRY_CODE_GLOBAL_DOMAIN){
+		printk("rtl8180_init:Error channel plan! Set to default.\n");
+		priv->ChannelPlan= 0;
 	}
-	RT_TRACE(COMP_EPROM, "MAC addr:"MAC_FMT"\n", MAC_ARG(dev->dev_addr));
-	priv->rf_type = RTL819X_DEFAULT_RF_TYPE; //default 1T2R
-	priv->rf_chip = RF_8256;
+	RT_TRACE(COMP_INIT, "Channel plan is %d\n",priv->ChannelPlan);
 
-	if (priv->card_8192_version == (u8)VERSION_819xU_A)
-	{
-		//read Tx power gain offset of legacy OFDM to HT rate
-		if (bLoad_From_EEPOM)
-			priv->EEPROMTxPowerDiff = (eprom_read(dev, (EEPROM_TxPowerDiff>>1))&0xff00) >> 8;
-		else
-			priv->EEPROMTxPowerDiff = EEPROM_Default_TxPower;
-		RT_TRACE(COMP_EPROM, "TxPowerDiff:%d\n", priv->EEPROMTxPowerDiff);
-		//read ThermalMeter from EEPROM
-		if (bLoad_From_EEPOM)
-			priv->EEPROMThermalMeter = (u8)(eprom_read(dev, (EEPROM_ThermalMeter>>1))&0x00ff);
-		else
-			priv->EEPROMThermalMeter = EEPROM_Default_ThermalMeter;
-		RT_TRACE(COMP_EPROM, "ThermalMeter:%d\n", priv->EEPROMThermalMeter);
-		//vivi, for tx power track
-		priv->TSSI_13dBm = priv->EEPROMThermalMeter *100;
-		//read antenna tx power offset of B/C/D to A from EEPROM
-		if (bLoad_From_EEPOM)
-			priv->EEPROMPwDiff = (eprom_read(dev, (EEPROM_PwDiff>>1))&0x0f00)>>8;
-		else
-			priv->EEPROMPwDiff = EEPROM_Default_PwDiff;
-		RT_TRACE(COMP_EPROM, "TxPwDiff:%d\n", priv->EEPROMPwDiff);
-		// Read CrystalCap from EEPROM
-		if (bLoad_From_EEPOM)
-			priv->EEPROMCrystalCap = (eprom_read(dev, (EEPROM_CrystalCap>>1))&0x0f);
-		else
-			priv->EEPROMCrystalCap = EEPROM_Default_CrystalCap;
-		RT_TRACE(COMP_EPROM, "CrystalCap = %d\n", priv->EEPROMCrystalCap);
-		//get per-channel Tx power level
-		if (bLoad_From_EEPOM)
-			priv->EEPROM_Def_Ver = (eprom_read(dev, (EEPROM_TxPwIndex_Ver>>1))&0xff00)>>8;
-		else
-			priv->EEPROM_Def_Ver = 1;
-		RT_TRACE(COMP_EPROM, "EEPROM_DEF_VER:%d\n", priv->EEPROM_Def_Ver);
-		if (priv->EEPROM_Def_Ver == 0) //old eeprom definition
-		{
-			int i;
-			if (bLoad_From_EEPOM)
-				priv->EEPROMTxPowerLevelCCK = (eprom_read(dev, (EEPROM_TxPwIndex_CCK>>1))&0xff) >> 8;
-			else
-				priv->EEPROMTxPowerLevelCCK = 0x10;
-			RT_TRACE(COMP_EPROM, "CCK Tx Power Levl: 0x%02x\n", priv->EEPROMTxPowerLevelCCK);
-			for (i=0; i<3; i++)
-			{
-				if (bLoad_From_EEPOM)
-				{
-					tmpValue = eprom_read(dev, (EEPROM_TxPwIndex_OFDM_24G+i)>>1);
-					if (((EEPROM_TxPwIndex_OFDM_24G+i) % 2) == 0)
-						tmpValue = tmpValue & 0x00ff;
-					else
-						tmpValue = (tmpValue & 0xff00) >> 8;
-				}
-				else
-					tmpValue = 0x10;
-				priv->EEPROMTxPowerLevelOFDM24G[i] = (u8) tmpValue;
-				RT_TRACE(COMP_EPROM, "OFDM 2.4G Tx Power Level, Index %d = 0x%02x\n", i, priv->EEPROMTxPowerLevelCCK);
-			}
-		}//end if EEPROM_DEF_VER == 0
-		else if (priv->EEPROM_Def_Ver == 1)
-		{
-			if (bLoad_From_EEPOM)
-			{
-				tmpValue = eprom_read(dev, (EEPROM_TxPwIndex_CCK_V1>>1));
-				tmpValue = (tmpValue & 0xff00) >> 8;
-			}
-			else
-				tmpValue = 0x10;
-			priv->EEPROMTxPowerLevelCCK_V1[0] = (u8)tmpValue;
-
-			if (bLoad_From_EEPOM)
-				tmpValue = eprom_read(dev, (EEPROM_TxPwIndex_CCK_V1 + 2)>>1);
-			else
-				tmpValue = 0x1010;
-			*((u16*)(&priv->EEPROMTxPowerLevelCCK_V1[1])) = tmpValue;
-			if (bLoad_From_EEPOM)
-				tmpValue = eprom_read(dev, (EEPROM_TxPwIndex_OFDM_24G_V1>>1));
-			else
-				tmpValue = 0x1010;
-			*((u16*)(&priv->EEPROMTxPowerLevelOFDM24G[0])) = tmpValue;
-			if (bLoad_From_EEPOM)
-				tmpValue = eprom_read(dev, (EEPROM_TxPwIndex_OFDM_24G_V1+2)>>1);
-			else
-				tmpValue = 0x10;
-			priv->EEPROMTxPowerLevelOFDM24G[2] = (u8)tmpValue;
-		}//endif EEPROM_Def_Ver == 1
-
-		//update HAL variables
-		//
-		{
-			int i;
-			for (i=0; i<14; i++)
-			{
-				if (i<=3)
-					priv->TxPowerLevelOFDM24G[i] = priv->EEPROMTxPowerLevelOFDM24G[0];
-				else if (i>=4 && i<=9)
-					priv->TxPowerLevelOFDM24G[i] = priv->EEPROMTxPowerLevelOFDM24G[1];
-				else
-					priv->TxPowerLevelOFDM24G[i] = priv->EEPROMTxPowerLevelOFDM24G[2];
-			}
-
-			for (i=0; i<14; i++)
-			{
-				if (priv->EEPROM_Def_Ver == 0)
-				{
-					if (i<=3)
-						priv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelOFDM24G[0] + (priv->EEPROMTxPowerLevelCCK - priv->EEPROMTxPowerLevelOFDM24G[1]);
-					else if (i>=4 && i<=9)
-						priv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK;
-					else
-						priv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelOFDM24G[2] + (priv->EEPROMTxPowerLevelCCK - priv->EEPROMTxPowerLevelOFDM24G[1]);
-				}
-				else if (priv->EEPROM_Def_Ver == 1)
-				{
-					if (i<=3)
-						priv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK_V1[0];
-					else if (i>=4 && i<=9)
-						priv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK_V1[1];
-					else
-						priv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK_V1[2];
-				}
-			}
-		}//end update HAL variables
-		priv->TxPowerDiff = priv->EEPROMPwDiff;
-// Antenna B gain offset to antenna A, bit0~3
-		priv->AntennaTxPwDiff[0] = (priv->EEPROMTxPowerDiff & 0xf);
-		// Antenna C gain offset to antenna A, bit4~7
-		priv->AntennaTxPwDiff[1] = ((priv->EEPROMTxPowerDiff & 0xf0)>>4);
-		// CrystalCap, bit12~15
-		priv->CrystalCap = priv->EEPROMCrystalCap;
-		// ThermalMeter, bit0~3 for RFIC1, bit4~7 for RFIC2
-		// 92U does not enable TX power tracking.
-		priv->ThermalMeter[0] = priv->EEPROMThermalMeter;
-	}//end if VersionID == VERSION_819xU_A
-
-//added by vivi, for dlink led, 20080416
-	switch(priv->eeprom_CustomerID)
-	{
-		case EEPROM_CID_RUNTOP:
-			priv->CustomerID = RT_CID_819x_RUNTOP;
-			break;
-
-		case EEPROM_CID_DLINK:
-			priv->CustomerID = RT_CID_DLINK;
-			break;
-
-		default:
-			priv->CustomerID = RT_CID_DEFAULT;
-			break;
-
-	}
-
-	switch(priv->CustomerID)
-	{
-		case RT_CID_819x_RUNTOP:
-			priv->LedStrategy = SW_LED_MODE2;
-			break;
-
- 		case RT_CID_DLINK:
-			priv->LedStrategy = SW_LED_MODE4;
-			break;
-
-		default:
-			priv->LedStrategy = SW_LED_MODE0;
-			break;
-
-	}
-
-
-	if(priv->rf_type == RF_1T2R)
-	{
-		RT_TRACE(COMP_EPROM, "\n1T2R config\n");
-	}
-	else
-	{
-		RT_TRACE(COMP_EPROM, "\n2T4R config\n");
-	}
-
-	// 2008/01/16 MH We can only know RF type in the function. So we have to init
-	// DIG RATR table again.
-	init_rate_adaptive(dev);
-	//we need init DIG RATR table here again.
-
-	RT_TRACE(COMP_EPROM, "<===========%s()\n", __FUNCTION__);
-	return;
-}
-#endif
-
-short rtl8192_get_channel_map(struct net_device * dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	if(priv->ChannelPlan > COUNTRY_CODE_GLOBAL_DOMAIN){
-		printk("rtl8180_init:Error channel plan! Set to default.\n");
-		priv->ChannelPlan= 0;
-	}
-	RT_TRACE(COMP_INIT, "Channel plan is %d\n",priv->ChannelPlan);
-
-	rtl819x_set_channel_map(priv->ChannelPlan, priv);
-	return 0;
-}
+	rtl819x_set_channel_map(priv->ChannelPlan, priv);
+	return 0;
+}
 
 short rtl8192_init(struct net_device *dev)
 {
 
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-#ifndef RTL8192SU
-	memset(&(priv->stats),0,sizeof(struct Stats));
-	memset(priv->txqueue_to_outpipemap,0,9);
-#ifdef PIPE12
-	{
-		int i=0;
-		u8 queuetopipe[]={3,2,1,0,4,8,7,6,5};
-		memcpy(priv->txqueue_to_outpipemap,queuetopipe,9);
-/*		for(i=0;i<9;i++)
-			printk("%d ",priv->txqueue_to_outpipemap[i]);
-		printk("\n");*/
-	}
-#else
-	{
-		u8 queuetopipe[]={3,2,1,0,4,4,0,4,4};
-		memcpy(priv->txqueue_to_outpipemap,queuetopipe,9);
-/*		for(i=0;i<9;i++)
-			printk("%d ",priv->txqueue_to_outpipemap[i]);
-		printk("\n");*/
-	}
-#endif
-#endif
 	rtl8192_init_priv_variable(dev);
 	rtl8192_init_priv_lock(priv);
 	rtl8192_init_priv_task(dev);
@@ -6404,7 +5501,6 @@ void rtl8192_hwconfig(struct net_device*
 
 }
 
-#ifdef RTL8192SU
 
 //
 //	Description:
@@ -6892,9 +5988,7 @@ void rtl8192SU_HwConfigureRTL8192SUsb(st
 	//rtl8192SU_SetHwRegAmpduMinSpace(dev, priv->MinSpaceCfg);
 }
 
-#endif
 
-#ifdef RTL8192SU
 //	Description:	Initial HW relted registers.
 //
 //	Assumption:	This function is only invoked at driver intialization once.
@@ -7232,247 +6326,6 @@ end:
 return rtStatus;
 }
 
-#else
-
-//InitializeAdapter and PhyCfg
-bool rtl8192_adapter_start(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	u32 dwRegRead = 0;
-	bool init_status = true;
-	RT_TRACE(COMP_INIT, "====>%s()\n", __FUNCTION__);
-	priv->Rf_Mode = RF_OP_By_SW_3wire;
-	//for ASIC power on sequence
-	write_nic_byte_E(dev, 0x5f, 0x80);
-	mdelay(50);
-	write_nic_byte_E(dev, 0x5f, 0xf0);
-	write_nic_byte_E(dev, 0x5d, 0x00);
-	write_nic_byte_E(dev, 0x5e, 0x80);
-	write_nic_byte(dev, 0x17, 0x37);
-	mdelay(10);
-//#ifdef TO_DO_LIST
-	priv->pFirmware->firmware_status = FW_STATUS_0_INIT;
-	//config CPUReset Register
-	//Firmware Reset or not?
-	dwRegRead = read_nic_dword(dev, CPU_GEN);
-	if (priv->pFirmware->firmware_status == FW_STATUS_0_INIT)
-		dwRegRead |= CPU_GEN_SYSTEM_RESET; //do nothing here?
-	else if (priv->pFirmware->firmware_status == FW_STATUS_5_READY)
-		dwRegRead |= CPU_GEN_FIRMWARE_RESET;
-	else
-		RT_TRACE(COMP_ERR, "ERROR in %s(): undefined firmware state(%d)\n", __FUNCTION__,   priv->pFirmware->firmware_status);
-
-	write_nic_dword(dev, CPU_GEN, dwRegRead);
-	//mdelay(30);
-	//config BB.
-	rtl8192_BBConfig(dev);
-
-#if 1
-	//Loopback mode or not
-	priv->LoopbackMode = RTL819xU_NO_LOOPBACK;
-//	priv->LoopbackMode = RTL819xU_MAC_LOOPBACK;
-
-	dwRegRead = read_nic_dword(dev, CPU_GEN);
-	if (priv->LoopbackMode == RTL819xU_NO_LOOPBACK)
-		dwRegRead = ((dwRegRead & CPU_GEN_NO_LOOPBACK_MSK) | CPU_GEN_NO_LOOPBACK_SET);
-	else if (priv->LoopbackMode == RTL819xU_MAC_LOOPBACK)
-		dwRegRead |= CPU_CCK_LOOPBACK;
-	else
-		RT_TRACE(COMP_ERR, "Serious error in %s(): wrong loopback mode setting(%d)\n", __FUNCTION__,  priv->LoopbackMode);
-
-	write_nic_dword(dev, CPU_GEN, dwRegRead);
-
-	//after reset cpu, we need wait for a seconds to write in register.
-	udelay(500);
-
-	//xiong add for new bitfile:usb suspend reset pin set to 1. //do we need?
-	write_nic_byte_E(dev, 0x5f, (read_nic_byte_E(dev, 0x5f)|0x20));
-
-	//Set Hardware
-	rtl8192_hwconfig(dev);
-
-	//turn on Tx/Rx
-	write_nic_byte(dev, CMDR, CR_RE|CR_TE);
-
-	//set IDR0 here
-	write_nic_dword(dev, MAC0, ((u32*)dev->dev_addr)[0]);
-	write_nic_word(dev, MAC4, ((u16*)(dev->dev_addr + 4))[0]);
-
-	//set RCR
-	write_nic_dword(dev, RCR, priv->ReceiveConfig);
-
-	//Initialize Number of Reserved Pages in Firmware Queue
-	write_nic_dword(dev, RQPN1,  NUM_OF_PAGE_IN_FW_QUEUE_BK << RSVD_FW_QUEUE_PAGE_BK_SHIFT |\
-						NUM_OF_PAGE_IN_FW_QUEUE_BE << RSVD_FW_QUEUE_PAGE_BE_SHIFT | \
-						NUM_OF_PAGE_IN_FW_QUEUE_VI << RSVD_FW_QUEUE_PAGE_VI_SHIFT | \
-						NUM_OF_PAGE_IN_FW_QUEUE_VO <<RSVD_FW_QUEUE_PAGE_VO_SHIFT);
-	write_nic_dword(dev, RQPN2, NUM_OF_PAGE_IN_FW_QUEUE_MGNT << RSVD_FW_QUEUE_PAGE_MGNT_SHIFT |\
-						NUM_OF_PAGE_IN_FW_QUEUE_CMD << RSVD_FW_QUEUE_PAGE_CMD_SHIFT);
-	write_nic_dword(dev, RQPN3, APPLIED_RESERVED_QUEUE_IN_FW| \
-						NUM_OF_PAGE_IN_FW_QUEUE_BCN<<RSVD_FW_QUEUE_PAGE_BCN_SHIFT
-//						| NUM_OF_PAGE_IN_FW_QUEUE_PUB<<RSVD_FW_QUEUE_PAGE_PUB_SHIFT
-						);
-	write_nic_dword(dev, RATR0+4*7, (RATE_ALL_OFDM_AG | RATE_ALL_CCK));
-
-	//Set AckTimeout
-	// TODO: (it value is only for FPGA version). need to be changed!!2006.12.18, by Emily
-	write_nic_byte(dev, ACK_TIMEOUT, 0x30);
-
-//	RT_TRACE(COMP_INIT, "%s():priv->ResetProgress is %d\n", __FUNCTION__,priv->ResetProgress);
-	if(priv->ResetProgress == RESET_TYPE_NORESET)
-	rtl8192_SetWirelessMode(dev, priv->ieee80211->mode);
-	if(priv->ResetProgress == RESET_TYPE_NORESET){
-	CamResetAllEntry(dev);
-	{
-		u8 SECR_value = 0x0;
-		SECR_value |= SCR_TxEncEnable;
-		SECR_value |= SCR_RxDecEnable;
-		SECR_value |= SCR_NoSKMC;
-		write_nic_byte(dev, SECR, SECR_value);
-	}
-	}
-
-	//Beacon related
-	write_nic_word(dev, ATIMWND, 2);
-	write_nic_word(dev, BCN_INTERVAL, 100);
-
-	{
-#define DEFAULT_EDCA 0x005e4332
-		int i;
-		for (i=0; i<QOS_QUEUE_NUM; i++)
-		write_nic_dword(dev, WDCAPARA_ADD[i], DEFAULT_EDCA);
-	}
-
-	rtl8192_phy_configmac(dev);
-
-	if (priv->card_8192_version == (u8) VERSION_819xU_A)
-	{
-		rtl8192_phy_getTxPower(dev);
-		rtl8192_phy_setTxPower(dev, priv->chan);
-	}
-
-
-	priv->usb_error = false;
-	//Firmware download
-	init_status = init_firmware(dev);
-	if(!init_status)
-	{
-		RT_TRACE(COMP_ERR,"ERR!!! %s(): Firmware download is failed\n", __FUNCTION__);
-		return init_status;
-	}
-	RT_TRACE(COMP_INIT, "%s():after firmware download\n", __FUNCTION__);
-	//
-#ifdef TO_DO_LIST
-if(Adapter->ResetProgress == RESET_TYPE_NORESET)
-	{
-		if(pMgntInfo->RegRfOff == TRUE)
-		{ // User disable RF via registry.
-			RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter819xUsb(): Turn off RF for RegRfOff ----------\n"));
-			MgntActSet_RF_State(Adapter, eRfOff, RF_CHANGE_BY_SW);
-			// Those action will be discard in MgntActSet_RF_State because off the same state
-			for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
-				PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
-		}
-		else if(pMgntInfo->RfOffReason > RF_CHANGE_BY_PS)
-		{ // H/W or S/W RF OFF before sleep.
-			RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter819xUsb(): Turn off RF for RfOffReason(%d) ----------\n", pMgntInfo->RfOffReason));
-			MgntActSet_RF_State(Adapter, eRfOff, pMgntInfo->RfOffReason);
-		}
-		else
-		{
-			pHalData->eRFPowerState = eRfOn;
-			pMgntInfo->RfOffReason = 0;
-			RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter819xUsb(): RF is on ----------\n"));
-		}
-	}
-	else
-	{
-		if(pHalData->eRFPowerState == eRfOff)
-		{
-			MgntActSet_RF_State(Adapter, eRfOff, pMgntInfo->RfOffReason);
-			// Those action will be discard in MgntActSet_RF_State because off the same state
-			for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
-				PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
-		}
-	}
-#endif
-	//config RF.
-	if(priv->ResetProgress == RESET_TYPE_NORESET){
-	rtl8192_phy_RFConfig(dev);
-	RT_TRACE(COMP_INIT, "%s():after phy RF config\n", __FUNCTION__);
-	}
-
-
-	if(priv->ieee80211->FwRWRF)
-		// We can force firmware to do RF-R/W
-		priv->Rf_Mode = RF_OP_By_FW;
-	else
-		priv->Rf_Mode = RF_OP_By_SW_3wire;
-
-
-	rtl8192_phy_updateInitGain(dev);
-	/*--set CCK and OFDM Block "ON"--*/
-	rtl8192_setBBreg(dev, rFPGA0_RFMOD, bCCKEn, 0x1);
-	rtl8192_setBBreg(dev, rFPGA0_RFMOD, bOFDMEn, 0x1);
-
-	if(priv->ResetProgress == RESET_TYPE_NORESET)
-	{
-		//if D or C cut
-		u8 tmpvalue = read_nic_byte(dev, 0x301);
-		if(tmpvalue ==0x03)
-		{
-			priv->bDcut = TRUE;
-			RT_TRACE(COMP_POWER_TRACKING, "D-cut\n");
-		}
-		else
-		{
-			priv->bDcut = FALSE;
-			RT_TRACE(COMP_POWER_TRACKING, "C-cut\n");
-		}
-		dm_initialize_txpower_tracking(dev);
-
-		if(priv->bDcut == TRUE)
-		{
-			u32 i, TempCCk;
-			u32 tmpRegA= rtl8192_QueryBBReg(dev,rOFDM0_XATxIQImbalance,bMaskDWord);
-		//	u32 tmpRegC= rtl8192_QueryBBReg(dev,rOFDM0_XCTxIQImbalance,bMaskDWord);
-			for(i = 0; i<TxBBGainTableLength; i++)
-			{
-				if(tmpRegA == priv->txbbgain_table[i].txbbgain_value)
-				{
-					priv->rfa_txpowertrackingindex= (u8)i;
-					priv->rfa_txpowertrackingindex_real= (u8)i;
-					priv->rfa_txpowertracking_default= priv->rfa_txpowertrackingindex;
-					break;
-				}
-			}
-
-			TempCCk = rtl8192_QueryBBReg(dev, rCCK0_TxFilter1, bMaskByte2);
-
-			for(i=0 ; i<CCKTxBBGainTableLength ; i++)
-			{
-
-				if(TempCCk == priv->cck_txbbgain_table[i].ccktxbb_valuearray[0])
-				{
-					priv->cck_present_attentuation_20Mdefault=(u8) i;
-					break;
-				}
-			}
-			priv->cck_present_attentuation_40Mdefault= 0;
-			priv->cck_present_attentuation_difference= 0;
-			priv->cck_present_attentuation = priv->cck_present_attentuation_20Mdefault;
-
-	//		pMgntInfo->bTXPowerTracking = FALSE;//TEMPLY DISABLE
-		}
-	}
-	write_nic_byte(dev, 0x87, 0x0);
-
-
-#endif
-	return init_status;
-}
-
-#endif
 /* this configures registers for beacon tx and enables it via
  * rtl8192_beacon_tx_enable(). rtl8192_beacon_tx_disable() might
  * be used to stop beacon transmission
@@ -8489,7 +7342,6 @@ out:
 	return ret;
 }
 
-#ifdef RTL8192SU
 u8 rtl8192SU_HwRateToMRate(bool bIsHT, u8 rate,bool bFirstAMPDU)
 {
 
@@ -8592,7 +7444,6 @@ u8 rtl8192SU_HwRateToMRate(bool bIsHT, u
 	}
 	return ret_rate;
 }
-#endif
 
 u8 HwRateToMRate90(bool bIsHT, u8 rate)
 {
@@ -9043,7 +7894,6 @@ rtl819x_signal_scale_mapping(
 	return retsig;
 }
 
-#ifdef RTL8192SU
 /*-----------------------------------------------------------------------------
  * Function:	QueryRxPhyStatus8192S()
  *
@@ -9109,17 +7959,6 @@ static void rtl8192SU_query_rxphystatus(
 	pstats->bPacketBeacon = precord_stats->bPacketBeacon = bPacketBeacon;
 	pstats->bToSelfBA = precord_stats->bToSelfBA = bToSelfBA;
 
-#ifndef RTL8192SU
-	phy_sts_ofdm_819xusb_t*	pofdm_buf = NULL;
-	prxpkt = (u8*)pdrvinfo;
-
-	/* Move pointer to the 16th bytes. Phy status start address. */
-	prxpkt += sizeof(rx_drvinfo_819x_usb);
-
-	/* Initial the cck and ofdm buffer pointer */
-	pcck_buf = (phy_sts_cck_819xusb_t *)prxpkt;
-	pofdm_buf = (phy_sts_ofdm_819xusb_t *)prxpkt;
-#endif
 
 	pstats->RxMIMOSignalQuality[0] = -1;
 	pstats->RxMIMOSignalQuality[1] = -1;
@@ -9346,314 +8185,63 @@ static void rtl8192SU_query_rxphystatus(
 			pstats->SignalStrength = precord_stats->SignalStrength = (u8)(rtl819x_signal_scale_mapping((long)(total_rssi/=rf_rx_num)));
 	}
 }/* QueryRxPhyStatus8192S */
-#else
-static void rtl8192_query_rxphystatus(
+
+void
+rtl8192_record_rxdesc_forlateruse(
+	struct ieee80211_rx_stats *	psrc_stats,
+	struct ieee80211_rx_stats *	ptarget_stats
+)
+{
+	ptarget_stats->bIsAMPDU = psrc_stats->bIsAMPDU;
+	ptarget_stats->bFirstMPDU = psrc_stats->bFirstMPDU;
+	ptarget_stats->Seq_Num = psrc_stats->Seq_Num;
+}
+
+static void rtl8192SU_query_rxphystatus(
 	struct r8192_priv * priv,
 	struct ieee80211_rx_stats * pstats,
+	rx_desc_819x_usb	*pDesc,
 	rx_drvinfo_819x_usb  * pdrvinfo,
 	struct ieee80211_rx_stats * precord_stats,
 	bool bpacket_match_bssid,
 	bool bpacket_toself,
 	bool bPacketBeacon,
 	bool bToSelfBA
-	)
+	);
+void rtl8192SU_TranslateRxSignalStuff(struct sk_buff *skb,
+				   struct ieee80211_rx_stats * pstats,
+				   rx_desc_819x_usb	*pDesc,
+                                   rx_drvinfo_819x_usb  *pdrvinfo)
 {
-	//PRT_RFD_STATUS		pRtRfdStatus = &(pRfd->Status);
-	phy_sts_ofdm_819xusb_t*	pofdm_buf;
-	phy_sts_cck_819xusb_t	*	pcck_buf;
-	phy_ofdm_rx_status_rxsc_sgien_exintfflag* prxsc;
-	u8				*prxpkt;
-	u8				i, max_spatial_stream, tmp_rxsnr, tmp_rxevm, rxsc_sgien_exflg;
-	char				rx_pwr[4], rx_pwr_all=0;
-	//long				rx_avg_pwr = 0;
-	char				rx_snrX, rx_evmX;
-	u8				evm, pwdb_all;
-	u32				RSSI, total_rssi=0;//, total_evm=0;
-//	long				signal_strength_index = 0;
-	u8				is_cck_rate=0;
-	u8				rf_rx_num = 0;
-
-
-	priv->stats.numqry_phystatus++;
-
-	is_cck_rate = rx_hal_is_cck_rate(pdrvinfo);
+	// TODO: We must only check packet for current MAC address. Not finish
+	rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
+	struct net_device *dev=info->dev;
+	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
+	bool bpacket_match_bssid, bpacket_toself;
+	bool bPacketBeacon=FALSE, bToSelfBA=FALSE;
+	static struct ieee80211_rx_stats  previous_stats;
+	struct ieee80211_hdr_3addr *hdr;//by amy
+       u16 fc,type;
 
-	// Record it for next packet processing
-	memset(precord_stats, 0, sizeof(struct ieee80211_rx_stats));
-	pstats->bPacketMatchBSSID = precord_stats->bPacketMatchBSSID = bpacket_match_bssid;
-	pstats->bPacketToSelf = precord_stats->bPacketToSelf = bpacket_toself;
-	pstats->bIsCCK = precord_stats->bIsCCK = is_cck_rate;//RX_HAL_IS_CCK_RATE(pDrvInfo);
-	pstats->bPacketBeacon = precord_stats->bPacketBeacon = bPacketBeacon;
-	pstats->bToSelfBA = precord_stats->bToSelfBA = bToSelfBA;
+	// Get Signal Quality for only RX data queue (but not command queue)
 
-	prxpkt = (u8*)pdrvinfo;
+	u8* tmp_buf;
+	//u16 tmp_buf_len = 0;
+	u8  *praddr;
 
-	/* Move pointer to the 16th bytes. Phy status start address. */
-	prxpkt += sizeof(rx_drvinfo_819x_usb);
+	/* Get MAC frame start address. */
+	tmp_buf = (u8*)skb->data;// + get_rxpacket_shiftbytes_819xusb(pstats);
 
-	/* Initial the cck and ofdm buffer pointer */
-	pcck_buf = (phy_sts_cck_819xusb_t *)prxpkt;
-	pofdm_buf = (phy_sts_ofdm_819xusb_t *)prxpkt;
+	hdr = (struct ieee80211_hdr_3addr *)tmp_buf;
+	fc = le16_to_cpu(hdr->frame_ctl);
+	type = WLAN_FC_GET_TYPE(fc);
+	praddr = hdr->addr1;
 
-	pstats->RxMIMOSignalQuality[0] = -1;
-	pstats->RxMIMOSignalQuality[1] = -1;
-	precord_stats->RxMIMOSignalQuality[0] = -1;
-	precord_stats->RxMIMOSignalQuality[1] = -1;
-
-	if(is_cck_rate)
-	{
-		//
-		// (1)Hardware does not provide RSSI for CCK
-		//
-
-		//
-		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
-		//
-		u8 report;//, cck_agc_rpt;
-
-		priv->stats.numqry_phystatusCCK++;
-
-		if(!priv->bCckHighPower)
-		{
-			report = pcck_buf->cck_agc_rpt & 0xc0;
-			report = report>>6;
-			switch(report)
-			{
-				//Fixed by Jacken from Bryant 2008-03-20
-				//Original value is -38 , -26 , -14 , -2
-				//Fixed value is -35 , -23 , -11 , 6
-				case 0x3:
-					rx_pwr_all = -35 - (pcck_buf->cck_agc_rpt & 0x3e);
-					break;
-				case 0x2:
-					rx_pwr_all = -23 - (pcck_buf->cck_agc_rpt & 0x3e);
-					break;
-				case 0x1:
-					rx_pwr_all = -11 - (pcck_buf->cck_agc_rpt & 0x3e);
-					break;
-				case 0x0:
-					rx_pwr_all = 6 - (pcck_buf->cck_agc_rpt & 0x3e);
-					break;
-			}
-		}
-		else
-		{
-			report = pcck_buf->cck_agc_rpt & 0x60;
-			report = report>>5;
-			switch(report)
-			{
-				case 0x3:
-					rx_pwr_all = -35 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1) ;
-					break;
-				case 0x2:
-					rx_pwr_all = -23 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1);
-					break;
-				case 0x1:
-					rx_pwr_all = -11 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1) ;
-					break;
-				case 0x0:
-					rx_pwr_all = 6 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1) ;
-					break;
-			}
-		}
-
-		pwdb_all = rtl819x_query_rxpwrpercentage(rx_pwr_all);
-		pstats->RxPWDBAll = precord_stats->RxPWDBAll = pwdb_all;
-		pstats->RecvSignalPower = pwdb_all;
-
-		//
-		// (3) Get Signal Quality (EVM)
-		//
-		//if(bpacket_match_bssid)
-		{
-			u8	sq;
-
-			if(pstats->RxPWDBAll > 40)
-			{
-				sq = 100;
-			}else
-			{
-				sq = pcck_buf->sq_rpt;
-
-				if(pcck_buf->sq_rpt > 64)
-					sq = 0;
-				else if (pcck_buf->sq_rpt < 20)
-					sq = 100;
-				else
-					sq = ((64-sq) * 100) / 44;
-			}
-			pstats->SignalQuality = precord_stats->SignalQuality = sq;
-			pstats->RxMIMOSignalQuality[0] = precord_stats->RxMIMOSignalQuality[0] = sq;
-			pstats->RxMIMOSignalQuality[1] = precord_stats->RxMIMOSignalQuality[1] = -1;
-		}
-	}
-	else
-	{
-		priv->stats.numqry_phystatusHT++;
-		//
-		// (1)Get RSSI for HT rate
-		//
-		for(i=RF90_PATH_A; i<priv->NumTotalRFPath; i++)
-		{
-			// 2008/01/30 MH we will judge RF RX path now.
-			if (priv->brfpath_rxenable[i])
-				rf_rx_num++;
-			else
-				continue;
-
-		if (!rtl8192_phy_CheckIsLegalRFPath(priv->ieee80211->dev, i))
-				continue;
-
-			//Fixed by Jacken from Bryant 2008-03-20
-			//Original value is 106
-			rx_pwr[i] = ((pofdm_buf->trsw_gain_X[i]&0x3F)*2) - 106;
-
-			//Get Rx snr value in DB
-			tmp_rxsnr =	pofdm_buf->rxsnr_X[i];
-			rx_snrX = (char)(tmp_rxsnr);
-			//rx_snrX >>= 1;;
-			rx_snrX /= 2;
-			priv->stats.rxSNRdB[i] = (long)rx_snrX;
-
-			/* Translate DBM to percentage. */
-			RSSI = rtl819x_query_rxpwrpercentage(rx_pwr[i]);
-			total_rssi += RSSI;
-
-			/* Record Signal Strength for next packet */
-			//if(bpacket_match_bssid)
-			{
-				pstats->RxMIMOSignalStrength[i] =(u8) RSSI;
-				precord_stats->RxMIMOSignalStrength[i] =(u8) RSSI;
-			}
-		}
-
-
-		//
-		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
-		//
-		//Fixed by Jacken from Bryant 2008-03-20
-		//Original value is 106
-		rx_pwr_all = (((pofdm_buf->pwdb_all ) >> 1 )& 0x7f) -106;
-		pwdb_all = rtl819x_query_rxpwrpercentage(rx_pwr_all);
-
-		pstats->RxPWDBAll = precord_stats->RxPWDBAll = pwdb_all;
-		pstats->RxPower = precord_stats->RxPower =  rx_pwr_all;
-
-		//
-		// (3)EVM of HT rate
-		//
-		if(pdrvinfo->RxHT && pdrvinfo->RxRate>=DESC90_RATEMCS8 &&
-		 	pdrvinfo->RxRate<=DESC90_RATEMCS15)
-			max_spatial_stream = 2; //both spatial stream make sense
-		else
-			max_spatial_stream = 1; //only spatial stream 1 makes sense
-
-		for(i=0; i<max_spatial_stream; i++)
-		{
-			tmp_rxevm =	pofdm_buf->rxevm_X[i];
-			rx_evmX = (char)(tmp_rxevm);
-
-			// Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment
-			// fill most significant bit to "zero" when doing shifting operation which may change a negative
-			// value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore.
-			rx_evmX /= 2;	//dbm
-
-			evm = rtl819x_evm_dbtopercentage(rx_evmX);
-#if 0
-			EVM = SignalScaleMapping(EVM);//make it good looking, from 0~100
-#endif
-			//if(bpacket_match_bssid)
-			{
-				if(i==0) // Fill value in RFD, Get the first spatial stream only
-					pstats->SignalQuality = precord_stats->SignalQuality = (u8)(evm & 0xff);
-				pstats->RxMIMOSignalQuality[i] = precord_stats->RxMIMOSignalQuality[i] = (u8)(evm & 0xff);
-			}
-		}
-
-
-		/* record rx statistics for debug */
-		rxsc_sgien_exflg = pofdm_buf->rxsc_sgien_exflg;
-		prxsc =	(phy_ofdm_rx_status_rxsc_sgien_exintfflag *)&rxsc_sgien_exflg;
-		if(pdrvinfo->BW)	//40M channel
-			priv->stats.received_bwtype[1+prxsc->rxsc]++;
-		else				//20M channel
-			priv->stats.received_bwtype[0]++;
-	}
-
-	//UI BSS List signal strength(in percentage), make it good looking, from 0~100.
-	//It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp().
-	if(is_cck_rate)
-	{
-		pstats->SignalStrength = precord_stats->SignalStrength = (u8)(rtl819x_signal_scale_mapping((long)pwdb_all));//PWDB_ALL;
-
-	}
-	else
-	{
-		//pRfd->Status.SignalStrength = pRecordRfd->Status.SignalStrength = (u8)(SignalScaleMapping(total_rssi/=RF90_PATH_MAX));//(u8)(total_rssi/=RF90_PATH_MAX);
-		// We can judge RX path number now.
-		if (rf_rx_num != 0)
-			pstats->SignalStrength = precord_stats->SignalStrength = (u8)(rtl819x_signal_scale_mapping((long)(total_rssi/=rf_rx_num)));
-	}
-}	/* QueryRxPhyStatus8190Pci */
-#endif
-
-void
-rtl8192_record_rxdesc_forlateruse(
-	struct ieee80211_rx_stats *	psrc_stats,
-	struct ieee80211_rx_stats *	ptarget_stats
-)
-{
-	ptarget_stats->bIsAMPDU = psrc_stats->bIsAMPDU;
-	ptarget_stats->bFirstMPDU = psrc_stats->bFirstMPDU;
-	ptarget_stats->Seq_Num = psrc_stats->Seq_Num;
-}
-
-#ifdef RTL8192SU
-static void rtl8192SU_query_rxphystatus(
-	struct r8192_priv * priv,
-	struct ieee80211_rx_stats * pstats,
-	rx_desc_819x_usb	*pDesc,
-	rx_drvinfo_819x_usb  * pdrvinfo,
-	struct ieee80211_rx_stats * precord_stats,
-	bool bpacket_match_bssid,
-	bool bpacket_toself,
-	bool bPacketBeacon,
-	bool bToSelfBA
-	);
-void rtl8192SU_TranslateRxSignalStuff(struct sk_buff *skb,
-				   struct ieee80211_rx_stats * pstats,
-				   rx_desc_819x_usb	*pDesc,
-                                   rx_drvinfo_819x_usb  *pdrvinfo)
-{
-	// TODO: We must only check packet for current MAC address. Not finish
-	rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
-	struct net_device *dev=info->dev;
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	bool bpacket_match_bssid, bpacket_toself;
-	bool bPacketBeacon=FALSE, bToSelfBA=FALSE;
-	static struct ieee80211_rx_stats  previous_stats;
-	struct ieee80211_hdr_3addr *hdr;//by amy
-       u16 fc,type;
-
-	// Get Signal Quality for only RX data queue (but not command queue)
-
-	u8* tmp_buf;
-	//u16 tmp_buf_len = 0;
-	u8  *praddr;
-
-	/* Get MAC frame start address. */
-	tmp_buf = (u8*)skb->data;// + get_rxpacket_shiftbytes_819xusb(pstats);
-
-	hdr = (struct ieee80211_hdr_3addr *)tmp_buf;
-	fc = le16_to_cpu(hdr->frame_ctl);
-	type = WLAN_FC_GET_TYPE(fc);
-	praddr = hdr->addr1;
-
-	/* Check if the received packet is acceptabe. */
-	bpacket_match_bssid = ((IEEE80211_FTYPE_CTL != type) &&
-                                			(eqMacAddr(priv->ieee80211->current_network.bssid,  (fc & IEEE80211_FCTL_TODS)? hdr->addr1 : (fc & IEEE80211_FCTL_FROMDS )? hdr->addr2 : hdr->addr3))
-                                				 && (!pstats->bHwError) && (!pstats->bCRC)&& (!pstats->bICV));
-	bpacket_toself =  bpacket_match_bssid & (eqMacAddr(praddr, priv->ieee80211->dev->dev_addr));
+	/* Check if the received packet is acceptabe. */
+	bpacket_match_bssid = ((IEEE80211_FTYPE_CTL != type) &&
+                                			(eqMacAddr(priv->ieee80211->current_network.bssid,  (fc & IEEE80211_FCTL_TODS)? hdr->addr1 : (fc & IEEE80211_FCTL_FROMDS )? hdr->addr2 : hdr->addr3))
+                                				 && (!pstats->bHwError) && (!pstats->bCRC)&& (!pstats->bICV));
+	bpacket_toself =  bpacket_match_bssid & (eqMacAddr(praddr, priv->ieee80211->dev->dev_addr));
 
 #if 1//cosa
 		if(WLAN_FC_GET_FRAMETYPE(fc)== IEEE80211_STYPE_BEACON)
@@ -9688,75 +8276,6 @@ void rtl8192SU_TranslateRxSignalStuff(st
 	rtl8192_record_rxdesc_forlateruse(pstats, &previous_stats);
 
 }
-#else
-void TranslateRxSignalStuff819xUsb(struct sk_buff *skb,
-				   struct ieee80211_rx_stats * pstats,
-                                   rx_drvinfo_819x_usb  *pdrvinfo)
-{
-	// TODO: We must only check packet for current MAC address. Not finish
-	rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
-	struct net_device *dev=info->dev;
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	bool bpacket_match_bssid, bpacket_toself;
-	bool bPacketBeacon=FALSE, bToSelfBA=FALSE;
-	static struct ieee80211_rx_stats  previous_stats;
-	struct ieee80211_hdr_3addr *hdr;//by amy
-       u16 fc,type;
-
-	// Get Signal Quality for only RX data queue (but not command queue)
-
-	u8* tmp_buf;
-	//u16 tmp_buf_len = 0;
-	u8  *praddr;
-
-	/* Get MAC frame start address. */
-	tmp_buf = (u8*)skb->data;// + get_rxpacket_shiftbytes_819xusb(pstats);
-
-	hdr = (struct ieee80211_hdr_3addr *)tmp_buf;
-	fc = le16_to_cpu(hdr->frame_ctl);
-	type = WLAN_FC_GET_TYPE(fc);
-	praddr = hdr->addr1;
-
-	/* Check if the received packet is acceptabe. */
-	bpacket_match_bssid = ((IEEE80211_FTYPE_CTL != type) &&
-                                			(eqMacAddr(priv->ieee80211->current_network.bssid,  (fc & IEEE80211_FCTL_TODS)? hdr->addr1 : (fc & IEEE80211_FCTL_FROMDS )? hdr->addr2 : hdr->addr3))
-                                				 && (!pstats->bHwError) && (!pstats->bCRC)&& (!pstats->bICV));
-	bpacket_toself =  bpacket_match_bssid & (eqMacAddr(praddr, priv->ieee80211->dev->dev_addr));
-
-#if 1//cosa
-		if(WLAN_FC_GET_FRAMETYPE(fc)== IEEE80211_STYPE_BEACON)
-		{
-			bPacketBeacon = true;
-			//DbgPrint("Beacon 2, MatchBSSID = %d, ToSelf = %d \n", bPacketMatchBSSID, bPacketToSelf);
-		}
-		if(WLAN_FC_GET_FRAMETYPE(fc) == IEEE80211_STYPE_BLOCKACK)
-		{
-			if((eqMacAddr(praddr,dev->dev_addr)))
-				bToSelfBA = true;
-				//DbgPrint("BlockAck, MatchBSSID = %d, ToSelf = %d \n", bPacketMatchBSSID, bPacketToSelf);
-		}
-
-#endif
-
-
-	if(bpacket_match_bssid)
-	{
-		priv->stats.numpacket_matchbssid++;
-	}
-	if(bpacket_toself){
-		priv->stats.numpacket_toself++;
-	}
-	//
-	// Process PHY information for previous packet (RSSI/PWDB/EVM)
-	//
-	// Because phy information is contained in the last packet of AMPDU only, so driver
-	// should process phy information of previous packet
-	rtl8192_process_phyinfo(priv, tmp_buf, &previous_stats, pstats);
-	rtl8192_query_rxphystatus(priv, pstats, pdrvinfo, &previous_stats, bpacket_match_bssid,bpacket_toself,bPacketBeacon,bToSelfBA);
-	rtl8192_record_rxdesc_forlateruse(pstats, &previous_stats);
-
-}
-#endif
 
 /**
 * Function:	UpdateReceivedRateHistogramStatistics
@@ -9840,7 +8359,6 @@ UpdateReceivedRateHistogramStatistics819
     priv->stats.received_rate_histogram[rcvType][rateIndex]++;
 }
 
-#ifdef RTL8192SU
 void rtl8192SU_query_rxdesc_status(struct sk_buff *skb, struct ieee80211_rx_stats *stats, bool bIsRxAggrSubframe)
 {
 	rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
@@ -9978,128 +8496,7 @@ if(stats->bHwError)
 		rtl8192SU_TranslateRxSignalStuff(skb, stats, desc, driver_info);
 	}
 }
-#else
-void query_rxdesc_status(struct sk_buff *skb, struct ieee80211_rx_stats *stats, bool bIsRxAggrSubframe)
-{
-	rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
-	struct net_device *dev=info->dev;
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	//rx_desc_819x_usb *desc = (rx_desc_819x_usb *)skb->data;
-	rx_drvinfo_819x_usb  *driver_info = NULL;
-
-	//
-	//Get Rx Descriptor Information
-	//
-	{
-		rx_desc_819x_usb *desc = (rx_desc_819x_usb *)skb->data;
-
-		stats->Length = desc->Length;
-		stats->RxDrvInfoSize = desc->RxDrvInfoSize;
-		stats->RxBufShift = 0;//desc->Shift&0x03;
-		stats->bICV = desc->ICV;
-		stats->bCRC = desc->CRC32;
-		stats->bHwError = stats->bCRC|stats->bICV;
-		//RTL8190 set this bit to indicate that Hw does not decrypt packet
-		stats->Decrypted = !desc->SWDec;
-	}
-
-	if((priv->ieee80211->pHTInfo->bCurrentHTSupport == true) && (priv->ieee80211->pairwise_key_type == KEY_TYPE_CCMP))
-	{
-		stats->bHwError = false;
-	}
-	else
-	{
-		stats->bHwError = stats->bCRC|stats->bICV;
-	}
-
-	if(stats->Length < 24 || stats->Length > MAX_8192U_RX_SIZE)
-		stats->bHwError |= 1;
-	//
-	//Get Driver Info
-	//
-	// TODO: Need to verify it on FGPA platform
-	//Driver info are written to the RxBuffer following rx desc
-	if (stats->RxDrvInfoSize != 0) {
-		driver_info = (rx_drvinfo_819x_usb *)(skb->data + sizeof(rx_desc_819x_usb) + \
-				stats->RxBufShift);
-		/* unit: 0.5M */
-		/* TODO */
-		if(!stats->bHwError){
-			u8	ret_rate;
-			ret_rate = HwRateToMRate90(driver_info->RxHT, driver_info->RxRate);
-			if(ret_rate == 0xff)
-			{
-				// Abnormal Case: Receive CRC OK packet with Rx descriptor indicating non supported rate.
-				// Special Error Handling here, 2008.05.16, by Emily
-
-				stats->bHwError = 1;
-				stats->rate = MGN_1M;	//Set 1M rate by default
-			}else
-			{
-				stats->rate = ret_rate;
-			}
-		}
-		else
-			stats->rate = 0x02;
-
-		stats->bShortPreamble = driver_info->SPLCP;
-
-
-		UpdateReceivedRateHistogramStatistics8190(dev, stats);
-
-		stats->bIsAMPDU = (driver_info->PartAggr==1);
-		stats->bFirstMPDU = (driver_info->PartAggr==1) && (driver_info->FirstAGGR==1);
-#if 0
-		// TODO: it is debug only. It should be disabled in released driver. 2007.1.12 by Joseph
-		UpdateRxAMPDUHistogramStatistics8190(Adapter, pRfd);
-#endif
-		stats->TimeStampLow = driver_info->TSFL;
-		// xiong mask it, 070514
-		//pRfd->Status.TimeStampHigh = PlatformEFIORead4Byte(Adapter, TSFR+4);
-		// stats->TimeStampHigh = read_nic_dword(dev,  TSFR+4);
-
-		UpdateRxPktTimeStamp8190(dev, stats);
-
-		//
-		// Rx A-MPDU
-		//
-		if(driver_info->FirstAGGR==1 || driver_info->PartAggr == 1)
-			RT_TRACE(COMP_RXDESC, "driver_info->FirstAGGR = %d, driver_info->PartAggr = %d\n",
-					driver_info->FirstAGGR, driver_info->PartAggr);
-
-	}
-
-	skb_pull(skb,sizeof(rx_desc_819x_usb));
-	//
-	// Get Total offset of MPDU Frame Body
-	//
-	if((stats->RxBufShift + stats->RxDrvInfoSize) > 0) {
-		stats->bShift = 1;
-		skb_pull(skb,stats->RxBufShift + stats->RxDrvInfoSize);
-	}
-
-	/* for debug 2008.5.29 */
-#if 0
-	{
-		int i;
-		printk("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
-		for(i = 0; i < skb->len; i++) {
-			if(i % 10 == 0) printk("\n");
-			printk("%02x ", skb->data[i]);
-		}
-		printk("\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n");
-	}
-#endif
-
-	//added by vivi, for MP, 20080108
-	stats->RxIs40MHzPacket = driver_info->BW;
-	if(stats->RxDrvInfoSize != 0)
-		TranslateRxSignalStuff819xUsb(skb, stats, driver_info);
-
-}
-#endif
 
-#ifdef RTL8192SU
 #if 0
 /*-----------------------------------------------------------------------------
  * Function:	UpdateRxAMPDUHistogramStatistics8192S
@@ -10196,10 +8593,8 @@ UpdateRxAMPDUHistogramStatistics8192S(
 }	// UpdateRxAMPDUHistogramStatistics8192S
 #endif
 
-#endif
 
 
-#ifdef RTL8192SU
 //
 // Description:
 // 	The strarting address of wireless lan header will shift 1 or 2 or 3 or "more" bytes for the following reason :
@@ -10285,67 +8680,6 @@ void rtl8192SU_rx_nomal(struct sk_buff* 
 	}
 
 }
-#else
-u32 GetRxPacketShiftBytes819xUsb(struct ieee80211_rx_stats  *Status, bool bIsRxAggrSubframe)
-{
-		return (sizeof(rx_desc_819x_usb) + Status->RxDrvInfoSize
-				+ Status->RxBufShift);
-}
-
-void rtl8192_rx_nomal(struct sk_buff* skb)
-{
-	rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
-	struct net_device *dev=info->dev;
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	struct ieee80211_rx_stats stats = {
-		.signal = 0,
-		.noise = -98,
-		.rate = 0,
-		//      .mac_time = jiffies,
-		.freq = IEEE80211_24GHZ_BAND,
-	};
-	u32 rx_pkt_len = 0;
-	struct ieee80211_hdr_1addr *ieee80211_hdr = NULL;
-	bool unicast_packet = false;
-
-	/* 20 is for ps-poll */
-	if((skb->len >=(20 + sizeof(rx_desc_819x_usb))) && (skb->len < RX_URB_SIZE)) {
-		/* first packet should not contain Rx aggregation header */
-		query_rxdesc_status(skb, &stats, false);
-		/* TODO */
-		/* hardware related info */
-		/* Process the MPDU recevied */
-		skb_trim(skb, skb->len - 4/*sCrcLng*/);
-
-		rx_pkt_len = skb->len;
-		ieee80211_hdr = (struct ieee80211_hdr_1addr *)skb->data;
-		unicast_packet = false;
-		if(is_broadcast_ether_addr(ieee80211_hdr->addr1)) {
-			//TODO
-		}else if(is_multicast_ether_addr(ieee80211_hdr->addr1)){
-			//TODO
-		}else {
-			/* unicast packet */
-			unicast_packet = true;
-		}
-
-		if(!ieee80211_rx(priv->ieee80211,skb, &stats)) {
-			dev_kfree_skb_any(skb);
-		} else {
-			priv->stats.rxoktotal++;
-			if(unicast_packet) {
-				priv->stats.rxbytesunicast += rx_pkt_len;
-			}
-		}
-	} else {
-		priv->stats.rxurberr++;
-		printk("actual_length:%d\n", skb->len);
-		dev_kfree_skb_any(skb);
-	}
-
-}
-
-#endif
 
 void
 rtl819xusb_process_received_packet(
@@ -10424,7 +8758,6 @@ void query_rx_cmdpkt_desc_status(struct 
 	stats->ntotalfrag = 1;
 }
 
-#ifdef RTL8192SU
 void rtl8192SU_rx_cmd(struct sk_buff *skb)
 {
 	struct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
@@ -10495,70 +8828,6 @@ void rtl8192SU_rx_cmd(struct sk_buff *sk
 	RT_TRACE(COMP_RECV, "<--- HalUsbInCommandComplete8192SUsb()\n");
 
 }
-#else
-void rtl8192_rx_cmd(struct sk_buff *skb)
-{
-	struct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
-	struct net_device *dev = info->dev;
-	//int ret;
-//	struct urb *rx_urb = info->urb;
-	/* TODO */
-	struct ieee80211_rx_stats stats = {
-		.signal = 0,
-		.noise = -98,
-		.rate = 0,
-		//      .mac_time = jiffies,
-		.freq = IEEE80211_24GHZ_BAND,
-	};
-
-	if((skb->len >=(20 + sizeof(rx_desc_819x_usb))) && (skb->len < RX_URB_SIZE))
-	{
-
-		query_rx_cmdpkt_desc_status(skb,&stats);
-		// this is to be done by amy 080508     prfd->queue_id = 1;
-
-
-		//
-		//  Process the command packet received.
-		//
-
-		rtl819xusb_process_received_packet(dev,&stats);
-
-		dev_kfree_skb_any(skb);
-	}
-	else
-		;
-
-
-#if 0
-	desc = (u32*)(skb->data);
-	cmd = (desc[0] >> 30) & 0x03;
-
-	if(cmd == 0x00) {//beacon interrupt
-		//send beacon packet
-		skb = ieee80211_get_beacon(priv->ieee80211);
-
-		if(!skb){
-			DMESG("not enought memory for allocating beacon");
-			return;
-		}
-		skb->cb[0] = BEACON_PRIORITY;
-		skb->cb[1] = 0;
-		skb->cb[2] = ieeerate2rtlrate(priv->ieee80211->basic_rate);
-		ret = rtl8192_tx(dev, skb);
-
-		if( ret != 0 ){
-			printk(KERN_ALERT "tx beacon packet error : %d !\n", ret);
-		}
-		dev_kfree_skb_any(skb);
-	} else {//0x00
-		//{ log the device information
-		// At present, It is not implemented just now.
-		//}
-	}
-#endif
-}
-#endif
 
 void rtl8192_irq_rx_tasklet(struct r8192_priv *priv)
 {
@@ -10699,17 +8968,10 @@ static int __devinit rtl8192_usb_probe(s
 	priv->ieee80211 = netdev_priv(dev);
 	priv->udev=udev;
 
-#ifdef RTL8192SU
 	HalUsbSetQueuePipeMapping8192SUsb(intf, dev);
-#endif
 
-#ifdef RTL8192SU
 	//printk("===============>NIC 8192SU\n");
 	priv->ops = &rtl8192su_ops;
-#else
-	//printk("===============>NIC 8192U\n");
-	priv->ops = &rtl8192u_ops;
-#endif
 
 	dev->netdev_ops = &rtl8192_netdev_ops;
 
--- a/drivers/staging/rtl8192su/r8192U_dm.c
+++ b/drivers/staging/rtl8192su/r8192U_dm.c
@@ -15,7 +15,6 @@ Major Change History:
 --*/
 
 
-#ifdef RTL8192SU
 #include "r8192U.h"
 #include "r8192U_dm.h"
 //#include "r8190_rtl8256.h"
@@ -23,15 +22,6 @@ Major Change History:
 #include "r8192S_hw.h"
 #include "r8192S_phy.h"
 #include "r8192S_phyreg.h"
-#else
-#include "r8192U.h"
-#include "r8192U_dm.h"
-#include "r8192U_hw.h"
-#include "r819xU_phy.h"
-#include "r819xU_phyreg.h"
-#include "r8190_rtl8256.h"
-#include "r819xU_cmdpkt.h"
-#endif
 
 /*---------------------------Define Local Constant---------------------------*/
 //
@@ -50,7 +40,6 @@ typedef enum _HT_IOT_PEER
 }HT_IOT_PEER_E, *PHTIOT_PEER_E;
 #endif
 #if 1
-#ifdef RTL8192SU
 		static u32 edca_setting_DL[HT_IOT_PEER_MAX] =
 		// UNKNOWN	REALTEK_90	/*REALTEK_92SE*/	BROADCOM	RALINK		ATHEROS		CISCO		MARVELL		92U_AP		SELF_AP
 		   { 0xa44f, 	0x5ea44f, 	0x5ea44f,		0xa44f,		0xa44f, 		0xa44f, 		0xa630,		0xa42b,		0x5e4322,	0x5e4322};
@@ -58,14 +47,6 @@ typedef enum _HT_IOT_PEER
 		// UNKNOWN	REALTEK		/*REALTEK_92SE*/	BROADCOM	RALINK		ATHEROS		CISCO		MARVELL		92U_AP		SELF_AP
 		   { 0x5ea44f, 	0xa44f, 	0x5ea44f,		0x5e4322, 	0x5ea422, 	0x5e4322, 	0x3ea44f,	0x5ea42b,	0x5e4322,	0x5e4322};
 
-#else
-
-static u32 edca_setting_DL[HT_IOT_PEER_MAX] =
-		{ 0x5e4322, 	0x5e4322, 	0x5ea44f,		0x5e4322, 	0x604322, 	0xa44f, 	0x5ea44f};
-static u32 edca_setting_UL[HT_IOT_PEER_MAX] =
-		{ 0x5e4322, 	0xa44f, 	0x5ea44f,	        0x5e4322, 	0x604322, 	0x5ea44f, 	0x5ea44f};
-
-#endif
 #endif
 
 #define RTK_UL_EDCA 0xa44f
@@ -202,7 +183,6 @@ static	void	dm_ctstoself(struct net_devi
 //================================================================================
 //	HW Dynamic mechanism interface.
 //================================================================================
-#ifdef RTL8192SU
 static void dm_CheckAggrPolicy(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -273,7 +253,6 @@ static void dm_CheckAggrPolicy(struct ne
 	lastTxOkCnt = priv->stats.txbytesunicast;
 	lastRxOkCnt = priv->stats.rxbytesunicast;
 }
-#endif
 //
 //	Description:
 //		Prepare SW resource for HW dynamic mechanism.
@@ -293,11 +272,7 @@ init_hal_dm(struct net_device *dev)
 	//Initial TX Power Control for near/far range , add by amy 2008/05/15, porting from windows code.
 	dm_init_dynamic_txpower(dev);
 	init_rate_adaptive(dev);
-#ifdef RTL8192SU
 	dm_initialize_txpower_tracking(dev);
-#else
-	//dm_initialize_txpower_tracking(dev);
-#endif
 	dm_dig_init(dev);
 	dm_init_edca_turbo(dev);
 	dm_init_bandwidth_autoswitch(dev);
@@ -317,7 +292,6 @@ extern void deinit_hal_dm(struct net_dev
 
 
 
-#ifdef RTL8192SU
 //#if 0
 extern  void    hal_dm_watchdog(struct net_device *dev)
 {
@@ -372,31 +346,6 @@ extern  void    hal_dm_watchdog(struct n
 	dm_ctstoself(dev);
 
 }	//HalDmWatchDog
-#else
-extern  void    hal_dm_watchdog(struct net_device *dev)
-{
-        //struct r8192_priv *priv = ieee80211_priv(dev);
-
-	//static u8 	previous_bssid[6] ={0};
-
-	/*Add by amy 2008/05/15 ,porting from windows code.*/
-	dm_check_rate_adaptive(dev);
-	dm_dynamic_txpower(dev);
-	dm_check_txrateandretrycount(dev);
-	dm_check_txpower_tracking(dev);
-	dm_ctrl_initgain_byrssi(dev);
-	dm_check_edca_turbo(dev);
-	dm_bandwidth_autoswitch(dev);
-	dm_check_rfctrl_gpio(dev);
-	dm_check_rx_path_selection(dev);
-	dm_check_fsync(dev);
-
-	// Add by amy 2008-05-15 porting from windows code.
-	dm_check_pbc_gpio(dev);
-	dm_send_rssi_tofw(dev);
-	dm_ctstoself(dev);
-}	//HalDmWatchDog
-#endif
 
 /*
   * Decide Rate Adaptive Set according to distance (signal strength)
@@ -1595,37 +1544,15 @@ static void dm_InitializeTXPowerTracking
 
 }
 
-#ifndef RTL8192SU
-static void dm_InitializeTXPowerTracking_ThermalMeter(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-
-	// Tx Power tracking by Theremal Meter require Firmware R/W 3-wire. This mechanism
-	// can be enabled only when Firmware R/W 3-wire is enabled. Otherwise, frequent r/w
-	// 3-wire by driver cause RF goes into wrong state.
-	if(priv->ieee80211->FwRWRF)
-		priv->btxpower_tracking = TRUE;
-	else
-		priv->btxpower_tracking = FALSE;
-	priv->txpower_count       = 0;
-	priv->btxpower_trackingInit = FALSE;
-}
-#endif
 
 void dm_initialize_txpower_tracking(struct net_device *dev)
 {
 #if (defined RTL8190P)
 	dm_InitializeTXPowerTracking_TSSI(dev);
-#elif (defined RTL8192SU)
+#else
 	// 2009/01/12 MH Enable for 92S series channel 1-14 CCK tx pwer setting for MP.
 	//
 	dm_InitializeTXPowerTracking_TSSI(dev);
-#else
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	if(priv->bDcut == TRUE)
-		dm_InitializeTXPowerTracking_TSSI(dev);
-	else
-		dm_InitializeTXPowerTracking_ThermalMeter(dev);
 #endif
 }// dm_InitializeTXPowerTracking
 
@@ -1683,17 +1610,10 @@ static void dm_CheckTXPowerTracking_Ther
 		//Attention!! You have to wirte all 12bits data to RF, or it may cause RF to crash
 		//actually write reg0x02 bit1=0, then bit1=1.
 		//DbgPrint("Trigger ThermalMeter, write RF reg0x2 = 0x4d to 0x4f\n");
-#ifdef RTL8192SU
 		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bRFRegOffsetMask, 0x4d);
 		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bRFRegOffsetMask, 0x4f);
 		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bRFRegOffsetMask, 0x4d);
 		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bRFRegOffsetMask, 0x4f);
-#else
-		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);
-		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);
-		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);
-		rtl8192_phy_SetRFReg(dev, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);
-#endif
 		TM_Trigger = 1;
 		return;
 	}
@@ -2021,14 +1941,12 @@ extern void dm_change_dynamic_initgain_t
 								u32		dm_type,
 								u32		dm_value)
 {
-#ifdef RTL8192SU
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	if(dm_type == DIG_TYPE_THRESH_HIGHPWR_HIGH)
 		priv->MidHighPwrTHR_L2 = (u8)dm_value;
 	else if(dm_type == DIG_TYPE_THRESH_HIGHPWR_LOW)
 		priv->MidHighPwrTHR_L1 = (u8)dm_value;
 	return;
-#endif
 	if (dm_type == DIG_TYPE_THRESH_HIGH)
 	{
 		dm_digtable.rssi_high_thresh = dm_value;
@@ -2400,15 +2318,7 @@ static void dm_ctrl_initgain_byrssi_by_f
 		{
 			/* 2008/01/11 MH 40MHZ 90/92 register are not the same. */
 			// 2008/02/05 MH SD3-Jerry 92U/92E PD_TH are the same.
-#ifdef RTL8192SU
 			rtl8192_setBBreg(dev, (rOFDM0_XATxAFE+3), bMaskByte0, 0x00);
-#else
-			#ifdef RTL8190P
-				write_nic_byte(dev, rOFDM0_RxDetector1, 0x40);
-			#else
-				write_nic_byte(dev, (rOFDM0_XATxAFE+3), 0x00);
-			#endif
-#endif
 			/*else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
 				write_nic_byte(pAdapter, rOFDM0_RxDetector1, 0x40);
 			*/
@@ -2552,15 +2462,7 @@ static void dm_ctrl_initgain_byrssi_high
 		// 3.1 Higher PD_TH for OFDM for high power state.
 		if (priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20)
 		{
-#ifdef RTL8192SU
 			rtl8192_setBBreg(dev, (rOFDM0_XATxAFE+3), bMaskByte0, 0x10);
-#else
-			#ifdef RTL8190P
-				write_nic_byte(dev, rOFDM0_RxDetector1, 0x41);
-			#else
-				write_nic_byte(dev, (rOFDM0_XATxAFE+3), 0x10);
-			#endif
-#endif
 			/*else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
 				write_nic_byte(dev, rOFDM0_RxDetector1, 0x41);
 			*/
@@ -2727,15 +2629,7 @@ static void dm_pd_th(
 				{
 					/* 2008/01/11 MH 40MHZ 90/92 register are not the same. */
 					// 2008/02/05 MH SD3-Jerry 92U/92E PD_TH are the same.
-#ifdef RTL8192SU
 					rtl8192_setBBreg(dev, (rOFDM0_XATxAFE+3), bMaskByte0, 0x00);
-#else
-					#ifdef RTL8190P
-						write_nic_byte(dev, rOFDM0_RxDetector1, 0x40);
-					#else
-						write_nic_byte(dev, (rOFDM0_XATxAFE+3), 0x00);
-					#endif
-#endif
 					/*else if (priv->card_8192 == HARDWARE_TYPE_RTL8190P)
 						write_nic_byte(dev, rOFDM0_RxDetector1, 0x40);
 					*/
@@ -2899,7 +2793,6 @@ static void dm_check_edca_turbo(
 	{
 		curTxOkCnt = priv->stats.txbytesunicast - lastTxOkCnt;
 		curRxOkCnt = priv->stats.rxbytesunicast - lastRxOkCnt;
-#ifdef RTL8192SU
 		// Modify EDCA parameters selection bias
 		// For some APs, use downlink EDCA parameters for uplink+downlink
 		if(priv->ieee80211->pHTInfo->IOTAction & HT_IOT_ACT_EDCA_BIAS_ON_RX)
@@ -2942,31 +2835,6 @@ static void dm_check_edca_turbo(
 			}
 			priv->bcurrent_turbo_EDCA = true;
 		}
-#else
-		// For RT-AP, we needs to turn it on when Rx>Tx
-		if(curRxOkCnt > 4*curTxOkCnt)
-		{
-			//printk("%s():curRxOkCnt > 4*curTxOkCnt\n");
-			if(!priv->bis_cur_rdlstate || !priv->bcurrent_turbo_EDCA)
-			{
-				write_nic_dword(dev, EDCAPARA_BE, edca_setting_DL[pHTInfo->IOTPeer]);
-				priv->bis_cur_rdlstate = true;
-			}
-		}
-		else
-		{
-
-			//printk("%s():curRxOkCnt < 4*curTxOkCnt\n");
-			if(priv->bis_cur_rdlstate || !priv->bcurrent_turbo_EDCA)
-			{
-				write_nic_dword(dev, EDCAPARA_BE, edca_setting_UL[pHTInfo->IOTPeer]);
-				priv->bis_cur_rdlstate = false;
-			}
-
-		}
-
-		priv->bcurrent_turbo_EDCA = true;
-#endif
 	}
 	else
 	{
@@ -3212,9 +3080,7 @@ static void dm_check_rfctrl_gpio(struct 
 #ifdef RTL8192U
 	return;
 #endif
-#ifdef RTL8192SU
 	return;
-#endif
 #ifdef RTL8192E
 		queue_delayed_work(priv->priv_wq,&priv->gpio_change_rf_wq,0);
 #endif
@@ -3257,7 +3123,6 @@ static	void	dm_check_pbc_gpio(struct net
 		priv->bpbc_pressed = true;
 	}
 #endif
-#ifdef RTL8192SU
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8	tmp1byte;
 
@@ -3283,7 +3148,6 @@ static	void	dm_check_pbc_gpio(struct net
 		priv->bpbc_pressed = true;
 	}
 
-#endif
 
 
 }
@@ -3862,15 +3726,7 @@ extern void dm_fsync_timer_callback(unsi
 			write_nic_byte(dev, 0xC3e, 0x96);
 		}
 		priv->ContiuneDiffCount = 0;
-#ifdef RTL8192SU
 	rtl8192_setBBreg(dev, rOFDM0_RxDetector2, bMaskDWord, 0x164052cd);
-#else
-	#ifdef RTL8190P
-		write_nic_dword(dev, rOFDM0_RxDetector2, 0x164052cd);
-	#else
-		write_nic_dword(dev, rOFDM0_RxDetector2, 0x465c52cd);
-	#endif
-#endif
 	}
 	RT_TRACE(COMP_HALDM, "ContiuneDiffCount %d\n", priv->ContiuneDiffCount);
 	RT_TRACE(COMP_HALDM, "rateRecord %d rateCount %d, rateCountdiff %d bSwitchFsync %d\n", priv->rate_record, rate_count, rate_count_diff , priv->bswitch_fsync);
@@ -4283,16 +4139,6 @@ static void dm_dynamic_txpower(struct ne
 		(priv->bDynamicTxLowPower != priv->bLastDTPFlag_Low ) )
 	{
 		RT_TRACE(COMP_TXAGC,"SetTxPowerLevel8190()  channel = %d \n" , priv->ieee80211->current_network.channel);
-#ifndef RTL8192SU
-#if  defined(RTL8190P) || defined(RTL8192E)
-		SetTxPowerLevel8190(Adapter,pHalData->CurrentChannel);
-#endif
-
-#ifdef RTL8192U
-		rtl8192_phy_setTxPower(dev,priv->ieee80211->current_network.channel);
-		//pHalData->bStartTxCtrlByTPCNFR = FALSE;    //Clear th flag of Set TX Power from Sitesurvey
-#endif
-#endif
 	}
 	priv->bLastDTPFlag_High = priv->bDynamicTxHighPower;
 	priv->bLastDTPFlag_Low = priv->bDynamicTxLowPower;
@@ -4306,11 +4152,7 @@ static void dm_check_txrateandretrycount
 	struct ieee80211_device* ieee = priv->ieee80211;
 	//for 11n tx rate
 //	priv->stats.CurrentShowTxate = read_nic_byte(dev, Current_Tx_Rate_Reg);
-#ifdef RTL8192SU
 	ieee->softmac_stats.CurrentShowTxate = read_nic_byte(dev, TX_RATE_REG);
-#else
-	ieee->softmac_stats.CurrentShowTxate = read_nic_byte(dev, Current_Tx_Rate_Reg);
-#endif
 	//printk("=============>tx_rate_reg:%x\n", ieee->softmac_stats.CurrentShowTxate);
 	//for initial tx rate
 //	priv->stats.last_packet_rate = read_nic_byte(dev, Initial_Tx_Rate_Reg);
@@ -4322,24 +4164,6 @@ static void dm_check_txrateandretrycount
 
 static void dm_send_rssi_tofw(struct net_device *dev)
 {
-#ifndef RTL8192SU
-	DCMD_TXCMD_T			tx_cmd;
-	struct r8192_priv *priv = ieee80211_priv(dev);
-
-	// If we test chariot, we should stop the TX command ?
-	// Because 92E will always silent reset when we send tx command. We use register
-	// 0x1e0(byte) to botify driver.
-	write_nic_byte(dev, DRIVER_RSSI, (u8)priv->undecorated_smoothed_pwdb);
-	return;
-#if 1
-	tx_cmd.Op		= TXCMD_SET_RX_RSSI;
-	tx_cmd.Length	= 4;
-	tx_cmd.Value		= priv->undecorated_smoothed_pwdb;
-
-	cmpk_message_handle_tx(dev, (u8*)&tx_cmd,
-								DESC_PACKET_TYPE_INIT, sizeof(DCMD_TXCMD_T));
-#endif
-#endif
 }
 
 #ifdef TO_DO_LIST
--- a/drivers/staging/rtl8192su/r8192U.h
+++ b/drivers/staging/rtl8192su/r8192U.h
@@ -42,11 +42,7 @@
 
 #include "ieee80211/ieee80211.h"
 
-#ifdef RTL8192SU
 #include "r8192S_firmware.h"
-#else
-#include "r819xU_firmware.h"
-#endif
 
 //#define RTL8192U
 #define RTL819xU_MODULE_NAME "rtl819xU"
@@ -305,7 +301,6 @@ do { if(rt_global_debug_component & comp
 #define 	OFDM_Table_Length	19
 #define	CCK_Table_length	12
 
-#ifdef RTL8192SU
 //
 //Tx Descriptor for RLT8192SU(Normal mode)
 //
@@ -423,51 +418,9 @@ typedef struct _tx_status_desc_8192s_usb
 	u8		RxAGC3;
 	u8		RxAGC4;
 }tx_status_desc_8192s_usb, *ptx_status_desc_8192s_usb;
-#else
-/* for rtl819x */
-typedef struct _tx_desc_819x_usb {
-        //DWORD 0
-        u16	PktSize;
-        u8	Offset;
-        u8	Reserved0:3;
-        u8	CmdInit:1;
-        u8	LastSeg:1;
-        u8	FirstSeg:1;
-        u8	LINIP:1;
-        u8	OWN:1;
-
-        //DWORD 1
-        u8	TxFWInfoSize;
-        u8	RATid:3;
-        u8	DISFB:1;
-        u8	USERATE:1;
-        u8	MOREFRAG:1;
-        u8	NoEnc:1;
-        u8	PIFS:1;
-        u8	QueueSelect:5;
-        u8	NoACM:1;
-        u8	Reserved1:2;
-        u8	SecCAMID:5;
-        u8	SecDescAssign:1;
-        u8	SecType:2;
-
-        //DWORD 2
-        u16	TxBufferSize;
-        //u16 Reserved2;
-        u8	ResvForPaddingLen:7;
-        u8	Reserved3:1;
-        u8	Reserved4;
-
-        //DWORD 3, 4, 5
-        u32	Reserved5;
-        u32	Reserved6;
-        u32	Reserved7;
-}tx_desc_819x_usb, *ptx_desc_819x_usb;
-#endif
 
 
 
-#ifdef RTL8192SU
 //
 //Tx Descriptor for RLT8192SU(Load FW mode)
 //
@@ -532,39 +485,7 @@ typedef struct _tx_h2c_cmd_hdr_8192s_usb
 	// DWORD 1
 	u32		Rsvd0;
 }tx_h2c_cmd_hdr_8192s_usb, *ptx_h2c_cmd_hdr_8192s_usb;
-#else
-typedef struct _tx_desc_cmd_819x_usb {
-        //DWORD 0
-	u16	Reserved0;
-	u8	Reserved1;
-	u8	Reserved2:3;
-	u8	CmdInit:1;
-	u8	LastSeg:1;
-	u8	FirstSeg:1;
-	u8	LINIP:1;
-	u8	OWN:1;
-
-        //DOWRD 1
-	//u32	Reserved3;
-	u8	TxFWInfoSize;
-	u8	Reserved3;
-	u8	QueueSelect;
-	u8	Reserved4;
-
-        //DOWRD 2
-	u16 	TxBufferSize;
-	u16	Reserved5;
-
-       //DWORD 3,4,5
-	//u32	TxBufferAddr;
-	//u32	NextDescAddress;
-	u32	Reserved6;
-	u32	Reserved7;
-	u32	Reserved8;
-}tx_desc_cmd_819x_usb, *ptx_desc_cmd_819x_usb;
-#endif
 
-#ifdef RTL8192SU
 typedef struct _tx_fwinfo_819x_usb{
 	//DWORD 0
 	u8			TxRate:7;
@@ -593,38 +514,6 @@ typedef struct _tx_fwinfo_819x_usb{
 	u32			Tx_INFO_RSVD:6;
 	u32			PacketID:13;
 }tx_fwinfo_819x_usb, *ptx_fwinfo_819x_usb;
-#else
-typedef struct _tx_fwinfo_819x_usb {
-        //DOWRD 0
-        u8		TxRate:7;
-        u8		CtsEnable:1;
-        u8		RtsRate:7;
-        u8		RtsEnable:1;
-        u8		TxHT:1;
-        u8		Short:1;                //Short PLCP for CCK, or short GI for 11n MCS
-        u8		TxBandwidth:1;          // This is used for HT MCS rate only.
-        u8		TxSubCarrier:2;         // This is used for legacy OFDM rate only.
-        u8		STBC:2;
-        u8		AllowAggregation:1;
-        u8		RtsHT:1;                //Interpre RtsRate field as high throughput data rate
-        u8		RtsShort:1;             //Short PLCP for CCK, or short GI for 11n MCS
-        u8		RtsBandwidth:1;         // This is used for HT MCS rate only.
-        u8		RtsSubcarrier:2;        // This is used for legacy OFDM rate only.
-        u8		RtsSTBC:2;
-        u8		EnableCPUDur:1;         //Enable firmware to recalculate and assign packet duration
-
-        //DWORD 1
-        u32		RxMF:2;
-        u32		RxAMD:3;
-        u32		TxPerPktInfoFeedback:1;//1 indicate Tx info gathtered by firmware and returned by Rx Cmd
-        u32		Reserved1:2;
-        u32		TxAGCOffSet:4;
-        u32		TxAGCSign:1;
-        u32		Tx_INFO_RSVD:6;
-	u32		PacketID:13;
-        //u32                Reserved;
-}tx_fwinfo_819x_usb, *ptx_fwinfo_819x_usb;
-#endif
 
 typedef struct rtl8192_rx_info {
 	struct urb *urb;
@@ -632,7 +521,6 @@ typedef struct rtl8192_rx_info {
 	u8 out_pipe;
 }rtl8192_rx_info ;
 
-#ifdef RTL8192SU
 //typedef struct _RX_DESC_STATUS_8192SU{
 typedef struct rx_desc_819x_usb{
 	//DWORD 0
@@ -695,36 +583,8 @@ typedef struct rx_desc_819x_usb{
 	u32		TSFL;
 //}RX_DESC_STATUS_8192SU, *PRX_DESC_STATUS_8192SU;
 }rx_desc_819x_usb, *prx_desc_819x_usb;
-#else
-typedef struct rx_desc_819x_usb{
-	//DOWRD 0
-	u16                 Length:14;
-	u16                 CRC32:1;
-	u16                 ICV:1;
-	u8                  RxDrvInfoSize;
-	u8                  Shift:2;
-	u8                  PHYStatus:1;
-	u8                  SWDec:1;
-	//u8                LastSeg:1;
-	//u8                FirstSeg:1;
-	//u8                EOR:1;
-	//u8                OWN:1;
-	u8                  Reserved1:4;
-
-	//DWORD 1
-	u32                 Reserved2;
-
-	//DWORD 2
-	//u32               Reserved3;
-
-	//DWORD 3
-	//u32                BufferAddress;
-
-}rx_desc_819x_usb, *prx_desc_819x_usb;
-#endif
 
 
-#ifdef RTL8192SU
 //
 // Driver info are written to the begining of the RxBuffer
 //
@@ -800,41 +660,11 @@ typedef struct rx_drvinfo_819x_usb{
 	u8			reserve:4;
 
 }rx_drvinfo_819x_usb, *prx_drvinfo_819x_usb;
-#else
-typedef struct rx_drvinfo_819x_usb{
-	//DWORD 0
-	u16                 Reserved1:12;
-	u16                 PartAggr:1;
-	u16                 FirstAGGR:1;
-	u16                 Reserved2:2;
-
-	u8                  RxRate:7;
-	u8                  RxHT:1;
-
-	u8                  BW:1;
-	u8                  SPLCP:1;
-	u8                  Reserved3:2;
-	u8                  PAM:1;
-	u8                  Mcast:1;
-	u8                  Bcast:1;
-	u8                  Reserved4:1;
-
-	//DWORD 1
-	u32                  TSFL;
-
-}rx_drvinfo_819x_usb, *prx_drvinfo_819x_usb;
-#endif
 
 	#define HWSET_MAX_SIZE_92S	128
-#ifdef RTL8192SU
 	#define MAX_802_11_HEADER_LENGTH 40
 	#define MAX_PKT_AGG_NUM		256
 	#define TX_PACKET_SHIFT_BYTES USB_HWDESC_HEADER_LEN
-#else
-	#define MAX_802_11_HEADER_LENGTH        (40 + MAX_FIRMWARE_INFORMATION_SIZE)
-	#define	MAX_PKT_AGG_NUM		64
-	#define TX_PACKET_SHIFT_BYTES (USB_HWDESC_HEADER_LEN + sizeof(tx_fwinfo_819x_usb))
-#endif
 
 #define MAX_DEV_ADDR_SIZE		8  /* support till 64 bit bus width OS */
 #define MAX_FIRMWARE_INFORMATION_SIZE   32 /*2006/04/30 by Emily forRTL8190*/
@@ -908,7 +738,6 @@ typedef struct _rt_firmare_seg_container
 	u8	*seg_ptr;
 }fw_seg_container, *pfw_seg_container;
 
-#ifdef RTL8192SU
 //--------------------------------------------------------------------------------
 // 8192S Firmware related
 //--------------------------------------------------------------------------------
@@ -1006,16 +835,6 @@ typedef struct _rt_firmware{
 	//u16               firmware_buf_size;//in 92u temp FIXLZM
 
 }rt_firmware, *prt_firmware;
-#else
-typedef struct _rt_firmware{
-	firmware_status_e firmware_status;
-	u16               cmdpacket_frag_thresold;
-#define RTL8190_MAX_FIRMWARE_CODE_SIZE  64000   //64k
-#define MAX_FW_INIT_STEP                3
-	u8                firmware_buf[MAX_FW_INIT_STEP][RTL8190_MAX_FIRMWARE_CODE_SIZE];
-	u16               firmware_buf_size[MAX_FW_INIT_STEP];
-}rt_firmware, *prt_firmware;
-#endif
 typedef struct _rt_firmware_info_819xUsb{
 	u8		sz_info[16];
 }rt_firmware_info_819xUsb, *prt_firmware_info_819xUsb;
@@ -1659,11 +1478,7 @@ typedef struct r8192_priv
 /*PHY related*/
 	BB_REGISTER_DEFINITION_T	PHYRegDef[4];	//Radio A/B/C/D
 	// Read/write are allow for following hardware information variables
-#ifdef RTL8192SU
 	u32	MCSTxPowerLevelOriginalOffset[7];//FIXLZM
-#else
-	u32	MCSTxPowerLevelOriginalOffset[6];
-#endif
 	u32	CCKTxPowerLevelOriginalOffset;
 	u8	TxPowerLevelCCK[14];			// CCK channel 1~14
 	u8	TxPowerLevelOFDM24G[14];		// OFDM 2.4G channel 1~14
@@ -1945,14 +1760,9 @@ struct ssid_thread {
 };
 #endif
 
-#ifdef RTL8192SU
 short rtl8192SU_tx_cmd(struct net_device *dev, struct sk_buff *skb);
 short rtl8192SU_tx(struct net_device *dev, struct sk_buff* skb);
 bool FirmwareDownload92S(struct net_device *dev);
-#else
-short rtl8192_tx(struct net_device *dev, struct sk_buff* skb);
-bool init_firmware(struct net_device *dev);
-#endif
 
 short rtl819xU_tx_cmd(struct net_device *dev, struct sk_buff *skb);
 short rtl8192_tx(struct net_device *dev, struct sk_buff* skb);
--- a/drivers/staging/rtl8192su/r8192U_wx.c
+++ b/drivers/staging/rtl8192su/r8192U_wx.c
@@ -17,15 +17,9 @@
    project Authors.
 */
 
-#ifdef RTL8192SU
 #include <linux/string.h>
 #include "r8192U.h"
 #include "r8192S_hw.h"
-#else
-#include <linux/string.h>
-#include "r8192U.h"
-#include "r8192U_hw.h"
-#endif
 
 #include "ieee80211/dot11d.h"
 
@@ -344,7 +338,6 @@ static int r8192_wx_force_reset(struct n
 
 }
 
-#ifdef RTL8192SU
 static int r8191su_wx_get_firm_version(struct net_device *dev,
 		struct iw_request_info *info,
 		struct iw_param *wrqu, char *extra)
@@ -360,7 +353,6 @@ static int r8191su_wx_get_firm_version(s
 	up(&priv->wx_sem);
 	return 0;
 }
-#endif
 
 
 
@@ -1232,14 +1224,12 @@ static const struct iw_priv_args r8192_p
 		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "forcereset"
 	}
 
-#ifdef RTL8192SU
 	,
 	{
 		SIOCIWFIRSTPRIV + 0x5,
 		IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT|IW_PRIV_SIZE_FIXED|1,
 		"firm_ver"
 	}
-#endif
 };
 
 
@@ -1262,9 +1252,7 @@ static iw_handler r8192_private_handler[
 #endif
 	r8192_wx_force_reset,
         (iw_handler)NULL,
-#ifdef RTL8192SU
         (iw_handler)r8191su_wx_get_firm_version,
-#endif
 };
 
 struct iw_statistics *r8192_get_wireless_stats(struct net_device *dev)
--- a/drivers/staging/rtl8192su/r819xU_cmdpkt.c
+++ b/drivers/staging/rtl8192su/r819xU_cmdpkt.c
@@ -108,84 +108,7 @@ SendTxCommandPacket(
 {
 
 	bool 	    rt_status = true;
-#ifdef RTL8192SU
 	return rt_status;
-#else
-#ifdef RTL8192U
-	return rt_status;
-#else
-	struct r8192_priv   *priv = ieee80211_priv(dev);
-	u16		    frag_threshold;
-	u16		    frag_length, frag_offset = 0;
-	//u16		    total_size;
-	//int		    i;
-
-	rt_firmware	    *pfirmware = priv->pFirmware;
-	struct sk_buff	    *skb;
-	unsigned char	    *seg_ptr;
-	cb_desc		    *tcb_desc;
-	u8                  bLastIniPkt;
-
-	firmware_init_param(dev);
-	//Fragmentation might be required
-	frag_threshold = pfirmware->cmdpacket_frag_thresold;
-	do {
-		if((buffer_len - frag_offset) > frag_threshold) {
-			frag_length = frag_threshold ;
-			bLastIniPkt = 0;
-
-		} else {
-			frag_length = buffer_len - frag_offset;
-			bLastIniPkt = 1;
-
-		}
-
-		/* Allocate skb buffer to contain firmware info and tx descriptor info
-		 * add 4 to avoid packet appending overflow.
-		 * */
-		#ifdef RTL8192U
-		skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + frag_length + 4);
-		#else
-		skb  = dev_alloc_skb(frag_length + 4);
-		#endif
-		memcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));
-		tcb_desc = (cb_desc*)(skb->cb + MAX_DEV_ADDR_SIZE);
-		tcb_desc->queue_index = TXCMD_QUEUE;
-		tcb_desc->bCmdOrInit = packettype;
-		tcb_desc->bLastIniPkt = bLastIniPkt;
-
-		#ifdef RTL8192U
-		skb_reserve(skb, USB_HWDESC_HEADER_LEN);
-		#endif
-
-		seg_ptr = skb_put(skb, buffer_len);
-		/*
-		 * Transform from little endian to big endian
-                 * and pending  zero
-		 */
-		memcpy(seg_ptr,codevirtualaddress,buffer_len);
-		tcb_desc->txbuf_size= (u16)buffer_len;
-
-
-		if(!priv->ieee80211->check_nic_enough_desc(dev,tcb_desc->queue_index)||
-			(!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index]))||\
-			(priv->ieee80211->queue_stop) ) {
-			RT_TRACE(COMP_FIRMWARE,"=====================================================> tx full!\n");
-			skb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);
-		} else {
-			priv->ieee80211->softmac_hard_start_xmit(skb,dev);
-		}
-
-		codevirtualaddress += frag_length;
-		frag_offset += frag_length;
-
-	}while(frag_offset < buffer_len);
-
-	return rt_status;
-
-
-#endif
-#endif
 }	/* CMPK_Message_Handle_Tx */
 
 /*-----------------------------------------------------------------------------
