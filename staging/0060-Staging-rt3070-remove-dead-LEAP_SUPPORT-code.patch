From d09e554ce3c5c83219cbb37d5430135af8f35ec8 Mon Sep 17 00:00:00 2001
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Sun, 26 Apr 2009 16:05:26 +0200
Subject: [PATCH 060/102] Staging: rt3070: remove dead LEAP_SUPPORT code

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt3070/common/cmm_sanity.c |    6 
 drivers/staging/rt3070/common/mlme.c       |   15 --
 drivers/staging/rt3070/common/rtmp_init.c  |    7 
 drivers/staging/rt3070/leap.h              |  215 -----------------------------
 drivers/staging/rt3070/rt_config.h         |    4 
 drivers/staging/rt3070/rt_linux.c          |    3 
 drivers/staging/rt3070/rt_linux.h          |    3 
 drivers/staging/rt3070/sta/assoc.c         |  166 ----------------------
 drivers/staging/rt3070/sta/auth.c          |   14 -
 drivers/staging/rt3070/sta/auth_rsp.c      |   15 --
 drivers/staging/rt3070/sta/connect.c       |   64 --------
 drivers/staging/rt3070/sta/rtmp_data.c     |   27 ---
 drivers/staging/rt3070/sta/sync.c          |    9 -
 13 files changed, 1 insertion(+), 547 deletions(-)
 delete mode 100644 drivers/staging/rt3070/leap.h

--- a/drivers/staging/rt3070/common/cmm_sanity.c
+++ b/drivers/staging/rt3070/common/cmm_sanity.c
@@ -968,9 +968,6 @@ BOOLEAN PeerAuthSanity(
     NdisMoveMemory(pStatus, &pFrame->Octet[4], 2);
 
     if ((*pAlg == Ndis802_11AuthModeOpen)
-#ifdef LEAP_SUPPORT
-      || (*pAlg == CISCO_AuthModeLEAP)
-#endif // LEAP_SUPPORT //
       )
     {
         if (*pSeq == 1 || *pSeq == 2)
@@ -1031,9 +1028,6 @@ BOOLEAN MlmeAuthReqSanity(
     *pAlg = pInfo->Alg;
 
     if (((*pAlg == Ndis802_11AuthModeShared) ||(*pAlg == Ndis802_11AuthModeOpen)
-#ifdef LEAP_SUPPORT
-     || (*pAlg == CISCO_AuthModeLEAP)
-#endif // LEAP_SUPPORT //
      	) &&
         ((*pAddr & 0x01) == 0))
     {
--- a/drivers/staging/rt3070/common/mlme.c
+++ b/drivers/staging/rt3070/common/mlme.c
@@ -622,11 +622,6 @@ VOID MlmeHandler(
 				case WPA_PSK_STATE_MACHINE:
 					StateMachinePerformAction(pAd, &pAd->Mlme.WpaPskMachine, Elem);
 					break;
-#ifdef LEAP_SUPPORT
-				case LEAP_STATE_MACHINE:
-					LeapMachinePerformAction(pAd, &pAd->Mlme.LeapMachine, Elem);
-					break;
-#endif
 				case AIRONET_STATE_MACHINE:
 					StateMachinePerformAction(pAd, &pAd->Mlme.AironetMachine, Elem);
 					break;
@@ -4982,16 +4977,6 @@ BOOLEAN MsgTypeSubst(
 			*MsgType = MT2_AIRONET_MSG;
 			return (TRUE);
 		}
-#ifdef LEAP_SUPPORT
-		if ( pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP ) //LEAP
-		{
-			// LEAP frames
-			*Machine = LEAP_STATE_MACHINE;
-			EAPType = *((UCHAR*)pFrame + LENGTH_802_11 + LENGTH_802_1_H + 1);
-			return (LeapMsgTypeSubst(EAPType, MsgType));
-		}
-		else
-#endif // LEAP_SUPPORT //
 		{
 			*Machine = WPA_PSK_STATE_MACHINE;
 			EAPType = *((UCHAR*)pFrame + LENGTH_802_11 + LENGTH_802_1_H + 1);
--- a/drivers/staging/rt3070/common/rtmp_init.c
+++ b/drivers/staging/rt3070/common/rtmp_init.c
@@ -3411,13 +3411,6 @@ VOID	UserCfgInit(
 		pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeCAM;
 		pAd->StaCfg.bWindowsACCAMEnable = FALSE;
 
-#ifdef LEAP_SUPPORT
-		// CCX v1.0 releated init value
-		RTMPInitTimer(pAd, &pAd->StaCfg.LeapAuthTimer, GET_TIMER_FUNCTION(LeapAuthTimeout), pAd, FALSE);
-		pAd->StaCfg.LeapAuthMode = CISCO_AuthModeLEAPNone;
-		pAd->StaCfg.bCkipOn = FALSE;
-#endif // LEAP_SUPPORT //
-
 		RTMPInitTimer(pAd, &pAd->StaCfg.StaQuickResponeForRateUpTimer, GET_TIMER_FUNCTION(StaQuickResponeForRateUpExec), pAd, FALSE);
 		pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
 
--- a/drivers/staging/rt3070/leap.h
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- *************************************************************************
- * Ralink Tech Inc.
- * 5F., No.36, Taiyuan St., Jhubei City,
- * Hsinchu County 302,
- * Taiwan, R.O.C.
- *
- * (c) Copyright 2002-2007, Ralink Technology, Inc.
- *
- * This program is free software; you can redistribute it and/or modify  *
- * it under the terms of the GNU General Public License as published by  *
- * the Free Software Foundation; either version 2 of the License, or     *
- * (at your option) any later version.                                   *
- *                                                                       *
- * This program is distributed in the hope that it will be useful,       *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- * GNU General Public License for more details.                          *
- *                                                                       *
- * You should have received a copy of the GNU General Public License     *
- * along with this program; if not, write to the                         *
- * Free Software Foundation, Inc.,                                       *
- * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                       *
- *************************************************************************
-
-	Module Name:
-	leap.h
-
-	Abstract:
-
-	Revision History:
-	Who			When			What
-	--------	----------		----------------------------------------------
-	Name		Date			Modification logs
-*/
-#ifndef __LEAP_H__
-#define __LEAP_H__
-
-// Messages for Associate state machine
-#define LEAP_MACHINE_BASE                   30
-
-#define LEAP_MSG_REQUEST_IDENTITY           31
-#define LEAP_MSG_REQUEST_LEAP               32
-#define LEAP_MSG_SUCCESS                    33
-#define LEAP_MSG_FAILED                     34
-#define LEAP_MSG_RESPONSE_LEAP              35
-#define LEAP_MSG_EAPOLKEY                   36
-#define LEAP_MSG_UNKNOWN                    37
-#define LEAP_MSG                            38
-//! assoc state-machine states
-#define LEAP_IDLE                           0
-#define LEAP_WAIT_IDENTITY_REQUEST          1
-#define LEAP_WAIT_CHANLLENGE_REQUEST        2
-#define LEAP_WAIT_SUCCESS                   3
-#define LEAP_WAIT_CHANLLENGE_RESPONSE       4
-#define LEAP_WAIT_EAPOLKEY                  5
-
-#define LEAP_REASON_INVALID_AUTH                    0x01
-#define LEAP_REASON_AUTH_TIMEOUT                    0x02
-#define LEAP_REASON_CHALLENGE_FROM_AP_FAILED        0x03
-#define LEAP_REASON_CHALLENGE_TO_AP_FAILED          0x04
-
-#define CISCO_AuthModeLEAP                          0x80
-#define CISCO_AuthModeLEAPNone                      0x00
-#define LEAP_AUTH_TIMEOUT                           30000
-#define LEAP_CHALLENGE_RESPONSE_LENGTH              24
-#define LEAP_CHALLENGE_REQUEST_LENGTH               8
-
-typedef struct _LEAP_EAPOL_HEADER_ {
-    UCHAR       Version;
-    UCHAR       Type;
-    UCHAR       Length[2];
-} LEAP_EAPOL_HEADER, *PLEAP_EAPOL_HEADER;
-
-typedef struct _LEAP_EAPOL_PACKET_ {
-    UCHAR       Code;
-    UCHAR       Identifier;
-    UCHAR       Length[2];
-    UCHAR       Type;
-} LEAP_EAPOL_PACKET, *PLEAP_EAPOL_PACKET;
-
-typedef struct _LEAP_EAP_CONTENTS_ {
-    UCHAR       Version;
-    UCHAR       Reserved;
-    UCHAR       Length;
-} LEAP_EAP_CONTENTS, *PLEAP_EAP_CONTENTS;
-
-/*** EAPOL key ***/
-typedef struct _EAPOL_KEY_HEADER_ {
-    UCHAR       Type;
-    UCHAR       Length[2];
-    UCHAR       Counter[8];
-    UCHAR       IV[16];
-    UCHAR       Index;
-    UCHAR       Signature[16];
-} EAPOL_KEY_HEADER, *PEAPOL_KEY_HEADER;
-
-BOOLEAN LeapMsgTypeSubst(
-    IN  UCHAR   EAPType,
-    OUT ULONG   *MsgType);
-
-VOID LeapMachinePerformAction(
-    IN PRTMP_ADAPTER    pAd,
-    IN STATE_MACHINE    *S,
-    IN MLME_QUEUE_ELEM  *Elem);
-
-VOID LeapMacHeaderInit(
-    IN  PRTMP_ADAPTER       pAd,
-    IN  OUT PHEADER_802_11  pHdr80211,
-    IN  UCHAR               wep,
-    IN  PUCHAR              pAddr3);
-
-VOID LeapStartAction(
-    IN PRTMP_ADAPTER    pAd,
-    IN MLME_QUEUE_ELEM  *Elem);
-
-VOID LeapIdentityAction(
-    IN PRTMP_ADAPTER    pAd,
-    IN MLME_QUEUE_ELEM  *Elem);
-
-VOID LeapPeerChallengeAction(
-    IN PRTMP_ADAPTER    pAd,
-    IN MLME_QUEUE_ELEM  *Elem);
-
-VOID HashPwd(
-    IN  PUCHAR  pwd,
-    IN  INT     pwdlen,
-    OUT PUCHAR  hash);
-
-VOID PeerChallengeResponse(
-    IN  PUCHAR  szChallenge,
-    IN  PUCHAR  smbPasswd,
-    OUT PUCHAR  szResponse);
-
-VOID ParityKey(
-    OUT PUCHAR  szOut,
-    IN  PUCHAR  szIn);
-
-VOID DesKey(
-    OUT ULONG   k[16][2],
-    IN  PUCHAR  key,
-    IN  INT     decrypt);
-
-VOID Des(
-    IN  ULONG   ks[16][2],
-    OUT UCHAR   block[8]);
-
-VOID DesEncrypt(
-    IN  PUCHAR  szClear,
-    IN  PUCHAR  szKey,
-    OUT PUCHAR  szOut);
-
-VOID LeapNetworkChallengeAction(
-    IN PRTMP_ADAPTER    pAd,
-    IN MLME_QUEUE_ELEM  *Elem);
-
-VOID LeapNetworkChallengeResponse(
-    IN PRTMP_ADAPTER    pAd,
-    IN MLME_QUEUE_ELEM  *Elem);
-
-VOID HashpwdHash(
-    IN  PUCHAR  hash,
-    IN  PUCHAR  hashhash);
-
-VOID ProcessSessionKey(
-    OUT PUCHAR  SessionKey,
-    IN  PUCHAR  hash2,
-    IN  PUCHAR  ChallengeToRadius,
-    IN  PUCHAR  ChallengeResponseFromRadius,
-    IN  PUCHAR  ChallengeFromRadius,
-    IN  PUCHAR  ChallengeResponseToRadius);
-
-VOID LeapEapolKeyAction(
-    IN PRTMP_ADAPTER    pAd,
-    IN MLME_QUEUE_ELEM  *Elem);
-
-VOID RogueApTableInit(
-    IN ROGUEAP_TABLE    *Tab);
-
-ULONG RogueApTableSearch(
-    IN ROGUEAP_TABLE    *Tab,
-    IN PUCHAR           pAddr);
-
-VOID RogueApEntrySet(
-    IN  PRTMP_ADAPTER   pAd,
-    OUT ROGUEAP_ENTRY   *pRogueAp,
-    IN PUCHAR           pAddr,
-    IN UCHAR            FaileCode);
-
-ULONG RogueApTableSetEntry(
-    IN  PRTMP_ADAPTER   pAd,
-    OUT ROGUEAP_TABLE  *Tab,
-    IN PUCHAR           pAddr,
-    IN UCHAR            FaileCode);
-
-VOID RogueApTableDeleteEntry(
-    IN OUT ROGUEAP_TABLE *Tab,
-    IN PUCHAR          pAddr);
-
-VOID LeapAuthTimeout(
-    IN PVOID SystemSpecific1,
-    IN PVOID FunctionContext,
-    IN PVOID SystemSpecific2,
-    IN PVOID SystemSpecific3);
-
-VOID LeapSendRogueAPReport(
-    IN  PRTMP_ADAPTER   pAd);
-
-BOOLEAN CCKMAssocRspSanity(
-    IN PRTMP_ADAPTER    pAd,
-    IN VOID             *Msg,
-    IN ULONG            MsgLen);
-
-#endif  // __LEAP_H__
--- a/drivers/staging/rt3070/rt_config.h
+++ b/drivers/staging/rt3070/rt_config.h
@@ -62,10 +62,6 @@
 #include	"chlist.h"
 #include	"spectrum.h"
 
-#ifdef LEAP_SUPPORT
-#include    "leap.h"
-#endif // LEAP_SUPPORT //
-
 #ifdef CONFIG_STA_SUPPORT
 #endif // CONFIG_STA_SUPPORT //
 
--- a/drivers/staging/rt3070/rt_linux.c
+++ b/drivers/staging/rt3070/rt_linux.c
@@ -47,9 +47,6 @@ BUILD_TIMER_FUNCTION(AssocTimeout);
 BUILD_TIMER_FUNCTION(ReassocTimeout);
 BUILD_TIMER_FUNCTION(DisassocTimeout);
 BUILD_TIMER_FUNCTION(LinkDownExec);
-#ifdef LEAP_SUPPORT
-BUILD_TIMER_FUNCTION(LeapAuthTimeout);
-#endif
 BUILD_TIMER_FUNCTION(StaQuickResponeForRateUpExec);
 BUILD_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc);
 #endif // CONFIG_STA_SUPPORT //
--- a/drivers/staging/rt3070/rt_linux.h
+++ b/drivers/staging/rt3070/rt_linux.h
@@ -522,9 +522,6 @@ DECLARE_TIMER_FUNCTION(AssocTimeout);
 DECLARE_TIMER_FUNCTION(ReassocTimeout);
 DECLARE_TIMER_FUNCTION(DisassocTimeout);
 DECLARE_TIMER_FUNCTION(LinkDownExec);
-#ifdef LEAP_SUPPORT
-DECLARE_TIMER_FUNCTION(LeapAuthTimeout);
-#endif
 DECLARE_TIMER_FUNCTION(StaQuickResponeForRateUpExec);
 DECLARE_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc);
 DECLARE_TIMER_FUNCTION(PsPollWakeExec);
--- a/drivers/staging/rt3070/sta/assoc.c
+++ b/drivers/staging/rt3070/sta/assoc.c
@@ -581,34 +581,6 @@ VOID MlmeAssocReqAction(
 						END_OF_ARGS);
 			FrameLen += tmp;
 
-			//
-			// Add CipherSuite CCKM or LeapTkip if setting.
-			//
-#ifdef LEAP_SUPPORT
-			if (LEAP_CCKM_ON(pAd))
-			{
-				MakeOutgoingFrame(pOutBuffer + FrameLen,	&tmp,
-						CipherSuiteCiscoCCKMLen,		CipherSuiteCiscoCCKM,
-						END_OF_ARGS);
-				FrameLen += tmp;
-
-				// Third add RSN
-				NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, CipherSuiteCiscoCCKM, CipherSuiteCiscoCCKMLen); //Save CipherSuite
-				VarIesOffset += CipherSuiteCiscoCCKMLen;
-			}
-			else if ((pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP) && (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled))
-			{
-				MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-						CipherSuiteCCXTkipLen,	    CipherSuiteCCXTkip,
-						END_OF_ARGS);
-				FrameLen += tmp;
-
-				// Third add RSN
-				NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, CipherSuiteCCXTkip, CipherSuiteCCXTkipLen);
-				VarIesOffset += CipherSuiteCCXTkipLen;
-			}
-#endif // LEAP_SUPPORT //
-
 			// Add by James 03/06/27
 			// Set Variable IEs Length
 			pAd->StaCfg.ReqVarIELen = VarIesOffset;
@@ -668,23 +640,6 @@ VOID MlmeReassocReqAction(
 	NDIS_STATUS		NStatus;
 	ULONG			tmp;
 	PUCHAR			pOutBuffer = NULL;
-//CCX 2.X
-#ifdef LEAP_SUPPORT
-	UCHAR			CkipFlag;
-	UCHAR			CkipNegotiationBuffer[CKIP_NEGOTIATION_LENGTH];
-	UCHAR			AironetCkipIe = IE_AIRONET_CKIP;
-	UCHAR			AironetCkipLen = CKIP_NEGOTIATION_LENGTH;
-	UCHAR			AironetIPAddressIE = IE_AIRONET_IPADDRESS;
-	UCHAR			AironetIPAddressLen = AIRONET_IPADDRESS_LENGTH;
-	UCHAR			AironetIPAddressBuffer[AIRONET_IPADDRESS_LENGTH] = {0x00, 0x40, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00};
-	UCHAR			AironetCCKMReassocIE = IE_AIRONET_CCKMREASSOC;
-	UCHAR			AironetCCKMReassocLen = AIRONET_CCKMREASSOC_LENGTH;
-	UCHAR			AironetCCKMReassocBuffer[AIRONET_CCKMREASSOC_LENGTH];
-	UCHAR			AironetOUI[] = {0x00, 0x40, 0x96, 0x00};
-	UCHAR			MICMN[16];
-	UCHAR			CalcMicBuffer[80];
-	ULONG			CalcMicBufferLen = 0;
-#endif // LEAP_SUPPORT //
 	USHORT			Status;
 
 	// Block all authentication request durning WPA block period
@@ -826,73 +781,6 @@ VOID MlmeReassocReqAction(
 							  END_OF_ARGS);
 			FrameLen += TmpLen;
 		}
-#ifdef LEAP_SUPPORT
-		if (LEAP_CCKM_ON(pAd) && (pAd->StaCfg.CCKMLinkUpFlag == TRUE))
-		{
-			CkipFlag = pAd->StaCfg.CkipFlag;	// We have update that at PeerBeaconAtJoinRequest()
-			if (CkipFlag != 0)
-			{
-				NdisZeroMemory(CkipNegotiationBuffer, CKIP_NEGOTIATION_LENGTH);
-				CkipNegotiationBuffer[2] = 0x66;
-				// Make it try KP & MIC, since we have to follow the result from AssocRsp
-				CkipNegotiationBuffer[8] = 0x18;
-				CkipNegotiationBuffer[CKIP_NEGOTIATION_LENGTH - 1] = 0x22;
-
-				MakeOutgoingFrame(pOutBuffer + FrameLen,            &tmp,
-									1,                              &AironetCkipIe,
-									1,                              &AironetCkipLen,
-									AironetCkipLen,                 CkipNegotiationBuffer,
-									END_OF_ARGS);
-				FrameLen += tmp;
-			}
-
-			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-							1,                              &AironetIPAddressIE,
-							1,                              &AironetIPAddressLen,
-							AironetIPAddressLen,            AironetIPAddressBuffer,
-							END_OF_ARGS);
-			FrameLen += tmp;
-
-			//
-			// The RN is incremented before each reassociation request.
-			//
-			pAd->StaCfg.CCKMRN++;
-			//
-			// Calculate MIC = hmac-md5(krk, STA-ID|BSSID|RSNIE|TSF|RN);
-			//
-			COPY_MAC_ADDR(CalcMicBuffer, pAd->CurrentAddress);
-			CalcMicBufferLen = MAC_ADDR_LEN;
-			COPY_MAC_ADDR(CalcMicBuffer + CalcMicBufferLen, pAd->MlmeAux.Bssid);
-			CalcMicBufferLen += MAC_ADDR_LEN;
-			NdisMoveMemory(CalcMicBuffer + CalcMicBufferLen, CipherSuiteCiscoCCKM, CipherSuiteCiscoCCKMLen);
-			CalcMicBufferLen += CipherSuiteCiscoCCKMLen;
-			NdisMoveMemory(CalcMicBuffer + CalcMicBufferLen, (PUCHAR) &pAd->StaCfg.CCKMBeaconAtJoinTimeStamp, sizeof(pAd->StaCfg.CCKMBeaconAtJoinTimeStamp));
-			CalcMicBufferLen += sizeof(pAd->StaCfg.CCKMBeaconAtJoinTimeStamp);
-			NdisMoveMemory(CalcMicBuffer + CalcMicBufferLen, (PUCHAR)&pAd->StaCfg.CCKMRN, sizeof(pAd->StaCfg.CCKMRN));
-			CalcMicBufferLen += sizeof(pAd->StaCfg.CCKMRN);
-			hmac_md5(pAd->StaCfg.KRK, LEN_EAP_MICK, CalcMicBuffer, CalcMicBufferLen, MICMN);
-
-			//
-			// fill up CCKM reassociation request element
-			//
-			NdisMoveMemory(AironetCCKMReassocBuffer, AironetOUI, 4);
-			NdisMoveMemory(AironetCCKMReassocBuffer + 4, (PUCHAR)&pAd->StaCfg.CCKMBeaconAtJoinTimeStamp, 8);
-			NdisMoveMemory(AironetCCKMReassocBuffer + 12, (PUCHAR) &pAd->StaCfg.CCKMRN, 4);
-			NdisMoveMemory(AironetCCKMReassocBuffer +16, MICMN, 8);
-
-			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-							1,                      &AironetCCKMReassocIE,
-							1,                      &AironetCCKMReassocLen,
-							AironetCCKMReassocLen,  AironetCCKMReassocBuffer,
-							END_OF_ARGS);
-			FrameLen += tmp;
-
-			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
-							CipherSuiteCiscoCCKMLen,CipherSuiteCiscoCCKM,
-							END_OF_ARGS);
-			FrameLen += tmp;
-		}
-#endif // LEAP_SUPPORT //
 
 		// Add CCX v2 request if CCX2 admin state is on
 		if (pAd->StaCfg.CCXControl.field.Enable == 1)
@@ -1090,14 +978,6 @@ VOID PeerAssocRspAction(
 			}
 			else
 			{
-				// Faile on Association, we need to check the status code
-				// Is that a Rogue AP?
-#ifdef LEAP_SUPPORT
-				if ((pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP) && (Status == MLME_ALG_NOT_SUPPORT))
-				{ //Possibly Rogue AP
-					RogueApTableSetEntry(pAd, &pAd->StaCfg.RogueApTab, pAd->MlmeAux.Bssid, LEAP_REASON_INVALID_AUTH);
-				}
-#endif // LEAP_SUPPORT //
 			}
 			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
@@ -1181,37 +1061,6 @@ VOID PeerReassocRspAction(
 
 			}
 
-			//
-			// Cisco Leap CCKM supported Re-association.
-			//
-#ifdef LEAP_SUPPORT
-			if (LEAP_CCKM_ON(pAd) && (pAd->StaCfg.CCKMLinkUpFlag == TRUE))
-			{
-				if (CCKMAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen) == TRUE)
-				{
-					pAd->StaCfg.CkipFlag = CkipFlag;
-					if (CkipFlag & 0x18)
-					{
-						NdisZeroMemory(pAd->StaCfg.TxSEQ, 4);
-						NdisZeroMemory(pAd->StaCfg.RxSEQ, 4);
-						NdisZeroMemory(pAd->StaCfg.CKIPMIC, 4);
-						pAd->StaCfg.GIV[0] = RandomByte(pAd);
-						pAd->StaCfg.GIV[1] = RandomByte(pAd);
-						pAd->StaCfg.GIV[2] = RandomByte(pAd);
-						pAd->StaCfg.bCkipOn = TRUE;
-						DBGPRINT(RT_DEBUG_TRACE, ("<CCX> pAd->StaCfg.CkipFlag = 0x%02x\n", pAd->StaCfg.CkipFlag));
-					}
-
-					pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-					MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
-				}
-				else
-				{
-					DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - CCKMAssocRspSanity() sanity check fail\n"));
-				}
-			}
-			else
-#endif // LEAP_SUPPORT //
 			{
 				// CkipFlag is no use for reassociate
 				pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
@@ -1395,21 +1244,6 @@ VOID PeerDisassocAction(
 				RTMPSendWirelessEvent(pAd, IW_DISASSOC_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
 			}
 
-
-#ifdef LEAP_SUPPORT
-			if (pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP)
-			{
-				// Cisco_LEAP has start a timer
-				// We should cancel it if using LEAP
-				RTMPCancelTimer(&pAd->StaCfg.LeapAuthTimer, &TimerCancelled);
-				//Check is it mach the LEAP Authentication failed as possible a Rogue AP
-				//on it's PortSecured not equal to WPA_802_1X_PORT_SECURED while process the Association.
-				if ((pAd->Mlme.LeapMachine.CurrState != LEAP_IDLE) && (pAd->StaCfg.PortSecured != WPA_802_1X_PORT_SECURED))
-				{
-					RogueApTableSetEntry(pAd, &pAd->StaCfg.RogueApTab, Addr2, LEAP_REASON_AUTH_TIMEOUT);
-				}
-			}
-#endif	// LEAP_SUPPORT //
 			//
 			// Get Current System time and Turn on AdjacentAPReport
 			//
--- a/drivers/staging/rt3070/sta/auth.c
+++ b/drivers/staging/rt3070/sta/auth.c
@@ -218,15 +218,9 @@ VOID PeerAuthRspAtSeq2Action(
             {
                 // Authentication Mode "LEAP" has allow for CCX 1.X
                 if ((pAd->MlmeAux.Alg == Ndis802_11AuthModeOpen)
-#ifdef LEAP_SUPPORT
-					|| (pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP)
-#endif // LEAP_SUPPORT //
 				)
                 {
                     pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-#ifdef LEAP_SUPPORT
-                    pAd->Mlme.LeapMachine.CurrState = LEAP_IDLE;
-#endif // LEAP_SUPPORT //
                     MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
                 }
                 else
@@ -282,14 +276,6 @@ VOID PeerAuthRspAtSeq2Action(
             }
             else
             {
-#ifdef LEAP_SUPPORT
-                if (pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP)
-                {
-                    //Invalid Authentication possible rogue AP
-                    //Add this Ap to Rogue AP.
-                    RogueApTableSetEntry(pAd, &pAd->StaCfg.RogueApTab, Addr2, LEAP_REASON_INVALID_AUTH);
-				}
-#endif // LEAP_SUPPORT //
                 pAd->StaCfg.AuthFailReason = Status;
                 COPY_MAC_ADDR(pAd->StaCfg.AuthFailSta, Addr2);
                 pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
--- a/drivers/staging/rt3070/sta/auth_rsp.c
+++ b/drivers/staging/rt3070/sta/auth_rsp.c
@@ -142,21 +142,6 @@ VOID PeerDeauthAction(
 				RTMPSendWirelessEvent(pAd, IW_DEAUTH_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
 
             LinkDown(pAd, TRUE);
-
-            // Authentication Mode Cisco_LEAP has start a timer
-            // We should cancel it if using LEAP
-#ifdef LEAP_SUPPORT
-            if (pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP)
-            {
-                RTMPCancelTimer(&pAd->StaCfg.LeapAuthTimer, &TimerCancelled);
-                //Check is it mach the LEAP Authentication failed as possible a Rogue AP
-                //on it's PortSecured not equal to WPA_802_1X_PORT_SECURED while process the Authenticaton.
-                if ((pAd->StaCfg.PortSecured != WPA_802_1X_PORT_SECURED) && (pAd->Mlme.LeapMachine.CurrState != LEAP_IDLE))
-                {
-                    RogueApTableSetEntry(pAd, &pAd->StaCfg.RogueApTab, Addr2, LEAP_REASON_AUTH_TIMEOUT);
-                }
-            }
-#endif // LEAP_SUPPORT //
         }
     }
     else
--- a/drivers/staging/rt3070/sta/connect.c
+++ b/drivers/staging/rt3070/sta/connect.c
@@ -385,9 +385,6 @@ VOID CntlOidSsidProc(
 			 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
 			 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
 			 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
-#ifdef LEAP_SUPPORT
-			 || (pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP)
-#endif // LEAP_SUPPORT //
 			 ) &&
 			(pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
 		{
@@ -772,14 +769,6 @@ VOID CntlWaitJoinProc(
 			// 2. joined a new INFRA network, start from authentication
 			else
 			{
-#ifdef LEAP_SUPPORT
-				// Add AuthMode "LEAP" for CCX 1.X
-				if (pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP)
-				{
-					AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, CISCO_AuthModeLEAP);
-				}
-				else
-#endif // LEAP_SUPPORT //
 				{
 					// either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first
 					if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared) ||
@@ -915,21 +904,6 @@ VOID CntlWaitAuthProc(
 			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid, pAd->MlmeAux.CapabilityInfo,
 						  ASSOC_TIMEOUT, pAd->StaCfg.DefaultListenCount);
 
-#ifdef LEAP_SUPPORT
-			//
-			// Cisco Leap CCKM supported Re-association.
-			//
-			if (LEAP_CCKM_ON(pAd) && (pAd->StaCfg.CCKMLinkUpFlag == TRUE))
-			{
-				//if CCKM is turn on , that's mean Fast Reauthentication
-				//Use CCKM Reassociation instead of normal association for Fast Roaming.
-				MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_REASSOC_REQ,
-							sizeof(MLME_ASSOC_REQ_STRUCT), &AssocReq);
-
-				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_REASSOC;
-			}
-			else
-#endif // LEAP_SUPPORT //
 			{
 				MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_ASSOC_REQ,
 							sizeof(MLME_ASSOC_REQ_STRUCT), &AssocReq);
@@ -943,14 +917,7 @@ VOID CntlWaitAuthProc(
 			// ageing-out. The previous authentication attempt must have let it remove us.
 			// so try Authentication again may help. For D-Link DWL-900AP+ compatibility.
 			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - AUTH FAIL, try again...\n"));
-#ifdef LEAP_SUPPORT
-			//Add AuthMode "LEAP" for CCX 1.X
-			if (pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP)
-			{
-				AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, CISCO_AuthModeLEAP);
-			}
-			else
-#endif // LEAP_SUPPORT //
+
 			{
 				if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared) ||
 					(pAd->StaCfg.AuthMode == Ndis802_11AuthModeAutoSwitch))
@@ -1002,20 +969,6 @@ VOID CntlWaitAuthProc2(
 		}
 		else
 		{
-#ifdef LEAP_SUPPORT
-			// Process LEAP first, since it use different control variable
-			// We don't want to affect other poven operation
-			if (pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP)
-			{
-				// LEAP Auth not success, try next BSS
-				DBGPRINT(RT_DEBUG_TRACE, ("CNTL - *LEAP* AUTH FAIL, give up; try next BSS\n"));
-				DBGPRINT(RT_DEBUG_TRACE, ("Total match BSSID [=%d]\n", pAd->MlmeAux.SsidBssTab.BssNr));
-				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-				pAd->MlmeAux.BssIdx++;
-				IterateOnBssTab(pAd);
-			}
-			else
-#endif // LEAP_SUPPORT //
 			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeAutoSwitch) &&
 				 (pAd->MlmeAux.Alg == Ndis802_11AuthModeShared))
 			{
@@ -1104,14 +1057,6 @@ VOID CntlWaitReassocProc(
 			if (pAd->CommonCfg.bWirelessEvent)
 				RTMPSendWirelessEvent(pAd, IW_ASSOC_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
 
-
-#ifdef LEAP_SUPPORT
-			if (LEAP_CCKM_ON(pAd))
-			{
-				STA_PORT_SECURED(pAd);
-				pAd->StaCfg.WpaState = SS_FINISH;
-			}
-#endif // LEAP_SUPPORT //
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Re-assocition successful on BSS #%ld\n", pAd->MlmeAux.RoamIdx));
 		}
@@ -1629,13 +1574,6 @@ VOID LinkUp(
 		DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK UP !! (StaActive.bHtEnable =%d, )\n", pAd->StaActive.SupportedPhyInfo.bHtEnable));
 #endif // DOT11_N_SUPPORT //
 
-		//
-		// Report Adjacent AP report.
-		//
-#ifdef LEAP_SUPPORT
-		CCXAdjacentAPReport(pAd);
-#endif // LEAP_SUPPORT //
-
 		if (pAd->CommonCfg.bAggregationCapable)
 		{
 			if ((pAd->CommonCfg.bPiggyBackCapable) && (pAd->MlmeAux.APRalinkIe & 0x00000003) == 3)
--- a/drivers/staging/rt3070/sta/rtmp_data.c
+++ b/drivers/staging/rt3070/sta/rtmp_data.c
@@ -986,9 +986,6 @@ NDIS_STATUS STASendPacket(
 #ifdef WPA_SUPPLICANT_SUPPORT
 		  || (pAd->StaCfg.IEEE8021X == TRUE)
 #endif // WPA_SUPPLICANT_SUPPORT //
-#ifdef LEAP_SUPPORT
-		  || (pAd->StaCfg.LeapAuthMode == CISCO_AuthModeLEAP)
-#endif // LEAP_SUPPORT //
 		  )
 		  && ((pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED) || (pAd->StaCfg.MicErrCnt >= 2))
 		  && (RTMP_GET_PACKET_EAPOL(pPacket)== FALSE)
@@ -1349,30 +1346,6 @@ VOID STAFindCipherAlgorithm(
 		}
 		else if (Cipher == Ndis802_11Encryption1Enabled)
 		{
-#ifdef LEAP_SUPPORT
-			if (pAd->StaCfg.CkipFlag & 0x10) // Cisco CKIP KP is on
-			{
-				if (LEAP_CCKM_ON(pAd))
-				{
-					if (((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd))))
-						KeyIdx = 1;
-					else
-						KeyIdx = 0;
-				}
-				else
-					KeyIdx = pAd->StaCfg.DefaultKeyId;
-			}
-			else if (pAd->StaCfg.CkipFlag & 0x08) // only CKIP CMIC
-				KeyIdx = pAd->StaCfg.DefaultKeyId;
-			else if (LEAP_CCKM_ON(pAd))
-			{
-				if ((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd)))
-					KeyIdx = 1;
-				else
-					KeyIdx = 0;
-			}
-			else	// standard WEP64 or WEP128
-#endif // LEAP_SUPPORT //
 				KeyIdx = pAd->StaCfg.DefaultKeyId;
 		}
 		else if ((Cipher == Ndis802_11Encryption2Enabled) ||
--- a/drivers/staging/rt3070/sta/sync.c
+++ b/drivers/staging/rt3070/sta/sync.c
@@ -888,15 +888,6 @@ VOID PeerBeaconAtJoinAction(
 			DBGPRINT(RT_DEBUG_TRACE, ("SYNC - after JOIN, SupRateLen=%d, ExtRateLen=%d\n",
 										pAd->MlmeAux.SupRateLen, pAd->MlmeAux.ExtRateLen));
 
-#ifdef LEAP_SUPPORT
-			// Update CkipFlag
-			pAd->StaCfg.CkipFlag = CkipFlag;
-
-			// Keep TimeStamp for Re-Association used.
-			if (LEAP_CCKM_ON(pAd) && (pAd->StaCfg.CCKMLinkUpFlag == TRUE))
-				pAd->StaCfg.CCKMBeaconAtJoinTimeStamp = TimeStamp;
-#endif // LEAP_SUPPORT //
-
 			if (AironetCellPowerLimit != 0xFF)
 			{
 				//We need to change our TxPower for CCX 2.0 AP Control of Client Transmit Power
