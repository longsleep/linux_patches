From m.kozlowski@tuxland.pl  Tue Feb 17 18:14:11 2009
From: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date: Mon, 16 Feb 2009 21:31:28 +0100
Subject: Staging: comedi: usbduxfast: fix checkpatch issues plus some style cleanups etc.
To: greg@kroah.com
Cc: m.kozlowski@tuxland.pl
Message-ID: <1234816289-9859-4-git-send-email-m.kozlowski@tuxland.pl>


This patch is a major code rewrite to make checkpatch.pl happy and also
other minor things are fixed.

Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Cc: Bernd Porr <BerndPorr@f2s.com>
Cc: David Schleef <ds@schleef.org>
Cc: Frank Mori Hess <fmhess@users.sourceforge.net>
Cc: Ian Abbott <abbotti@mev.co.uk>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/staging/comedi/drivers/usbduxfast.c | 1906 +++++++++++++++-------------
 1 file changed, 1033 insertions(+), 873 deletions(-)

--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -1,33 +1,20 @@
-#define DRIVER_VERSION "v0.99a"
-#define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
-#define DRIVER_DESC "USB-DUXfast, BerndPorr@f2s.com"
 /*
-   comedi/drivers/usbduxfast.c
-   Copyright (C) 2004 Bernd Porr, Bernd.Porr@f2s.com
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-/*
-Driver: usbduxfast
-Description: ITL USB-DUXfast
-Devices: [ITL] USB-DUX (usbduxfast.o)
-Author: Bernd Porr <BerndPorr@f2s.com>
-Updated: 04 Dec 2006
-Status: testing
-*/
+ *  Copyright (C) 2004 Bernd Porr, Bernd.Porr@f2s.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 /*
  * I must give credit here to Chris Baugher who
@@ -42,7 +29,8 @@ Status: testing
  * 0.9: Dropping the first data packet which seems to be from the last transfer.
  *      Buffer overflows in the FX2 are handed over to comedi.
  * 0.92: Dropping now 4 packets. The quad buffer has to be emptied.
- *       Added insn command basically for testing. Sample rate is 1MHz/16ch=62.5kHz
+ *       Added insn command basically for testing. Sample rate is
+ *       1MHz/16ch=62.5kHz
  * 0.99: Ian Abbott pointed out a bug which has been corrected. Thanks!
  * 0.99a: added external trigger.
  */
@@ -59,522 +47,560 @@ Status: testing
 #include "comedi_fc.h"
 #include "../comedidev.h"
 
+
+#define DRIVER_VERSION "v0.99a"
+#define DRIVER_AUTHOR "Bernd Porr, BerndPorr@f2s.com"
+#define DRIVER_DESC "USB-DUXfast, BerndPorr@f2s.com"
 #define BOARDNAME "usbduxfast"
 
-// timeout for the USB-transfer
-#define EZTIMEOUT 30
+/*
+ * timeout for the USB-transfer
+ */
+#define EZTIMEOUT	30
 
-// constants for "firmware" upload and download
-#define USBDUXFASTSUB_FIRMWARE 0xA0
-#define VENDOR_DIR_IN  0xC0
-#define VENDOR_DIR_OUT 0x40
+/*
+ * constants for "firmware" upload and download
+ */
+#define USBDUXFASTSUB_FIRMWARE	0xA0
+#define VENDOR_DIR_IN		0xC0
+#define VENDOR_DIR_OUT		0x40
 
-// internal adresses of the 8051 processor
-#define USBDUXFASTSUB_CPUCS 0xE600
+/*
+ * internal adresses of the 8051 processor
+ */
+#define USBDUXFASTSUB_CPUCS	0xE600
 
-// max lenghth of the transfer-buffer for software upload
-#define TB_LEN 0x2000
+/*
+ * max lenghth of the transfer-buffer for software upload
+ */
+#define TB_LEN	0x2000
 
-// Input endpoint number
-#define BULKINEP           6
+/*
+ * input endpoint number
+ */
+#define BULKINEP	6
 
-// Endpoint for the A/D channellist: bulk OUT
-#define CHANNELLISTEP     4
+/*
+ * endpoint for the A/D channellist: bulk OUT
+ */
+#define CHANNELLISTEP	4
 
-// Number of channels
-#define NUMCHANNELS       32
+/*
+ * number of channels
+ */
+#define NUMCHANNELS	32
 
-// size of the waveform descriptor
-#define WAVESIZE          0x20
+/*
+ * size of the waveform descriptor
+ */
+#define WAVESIZE	0x20
 
-// Size of one A/D value
-#define SIZEADIN          ((sizeof(int16_t)))
+/*
+ * size of one A/D value
+ */
+#define SIZEADIN	(sizeof(int16_t))
 
-// Size of the input-buffer IN BYTES
-#define SIZEINBUF         512
+/*
+ * size of the input-buffer IN BYTES
+ */
+#define SIZEINBUF	512
 
-// 16 bytes.
-#define SIZEINSNBUF       512
+/*
+ * 16 bytes
+ */
+#define SIZEINSNBUF	512
 
-// Size of the buffer for the dux commands
-#define SIZEOFDUXBUFFER    256	// bytes
+/*
+ * size of the buffer for the dux commands in bytes
+ */
+#define SIZEOFDUXBUFFER	256
 
-// Number of in-URBs which receive the data: min=5
-#define NUMOFINBUFFERSHIGH     10
+/*
+ * number of in-URBs which receive the data: min=5
+ */
+#define NUMOFINBUFFERSHIGH	10
 
-// Total number of usbduxfast devices
-#define NUMUSBDUXFAST             16
+/*
+ * total number of usbduxfast devices
+ */
+#define NUMUSBDUXFAST	16
 
-// Number of subdevices
-#define N_SUBDEVICES          1
+/*
+ * number of subdevices
+ */
+#define N_SUBDEVICES	1
 
-// Analogue in subdevice
-#define SUBDEV_AD             0
+/*
+ * analogue in subdevice
+ */
+#define SUBDEV_AD	0
 
-// min delay steps for more than one channel
-// basically when the mux gives up. ;-)
-#define MIN_SAMPLING_PERIOD 9	// steps at 30MHz in the FX2
+/*
+ * min delay steps for more than one channel
+ * basically when the mux gives up ;-)
+ *
+ * steps at 30MHz in the FX2
+ */
+#define MIN_SAMPLING_PERIOD	9
 
-// Max number of 1/30MHz delay steps:
-#define MAX_SAMPLING_PERIOD 500
+/*
+ * max number of 1/30MHz delay steps
+ */
+#define MAX_SAMPLING_PERIOD	500
 
-// Number of received packets to ignore before we start handing data over to comedi.
-// It's quad buffering and we have to ignore 4 packets.
-#define PACKETS_TO_IGNORE 4
+/*
+ * number of received packets to ignore before we start handing data
+ * over to comedi, it's quad buffering and we have to ignore 4 packets
+ */
+#define PACKETS_TO_IGNORE	4
 
-/////////////////////////////////////////////
-// comedi constants
-static const comedi_lrange range_usbduxfast_ai_range = { 2, {
-			BIP_RANGE(0.75),
-			BIP_RANGE(0.5),
-	}
+/*
+ * comedi constants
+ */
+static const comedi_lrange range_usbduxfast_ai_range = {
+	2, { BIP_RANGE(0.75), BIP_RANGE(0.5) }
 };
 
 /*
  * private structure of one subdevice
+ *
+ * this is the structure which holds all the data of this driver
+ * one sub device just now: A/D
  */
-
-// This is the structure which holds all the data of this driver
-// one sub device just now: A/D
-typedef struct {
-	// attached?
-	int attached;
-	// is it associated with a subdevice?
-	int probed;
-	// pointer to the usb-device
-	struct usb_device *usbdev;
-	// BULK-transfer handling: urb
-	struct urb *urbIn;
+struct usbduxfastsub_s {
+	int attached;			/* is attached? */
+	int probed;			/* is it associated with a subdevice? */
+	struct usb_device *usbdev;	/* pointer to the usb-device */
+	struct urb *urbIn;		/* BULK-transfer handling: urb */
 	int8_t *transfer_buffer;
-	// input buffer for single insn
-	int16_t *insnBuffer;
-	// interface number
-	int ifnum;
-	// interface structure
-	struct usb_interface *interface;
-	// comedi device for the interrupt context
-	comedi_device *comedidev;
-	// asynchronous command is running
-	short int ai_cmd_running;
-	// continous aquisition
-	short int ai_continous;
-	// number of samples to aquire
-	long int ai_sample_count;
-	// commands
-	uint8_t *dux_commands;
-	// counter which ignores the first buffers
-	int ignore;
+	int16_t *insnBuffer;		/* input buffer for single insn */
+	int ifnum;			/* interface number */
+	struct usb_interface *interface;	/* interface structure */
+	comedi_device *comedidev;	/* comedi device for the interrupt
+					   context */
+	short int ai_cmd_running;	/* asynchronous command is running */
+	short int ai_continous;		/* continous aquisition */
+	long int ai_sample_count;	/* number of samples to aquire */
+	uint8_t *dux_commands;		/* commands */
+	int ignore;			/* counter which ignores the first
+					   buffers */
 	struct semaphore sem;
-} usbduxfastsub_t;
+};
 
-// The pointer to the private usb-data of the driver
-// is also the private data for the comedi-device.
-// This has to be global as the usb subsystem needs
-// global variables. The other reason is that this
-// structure must be there _before_ any comedi
-// command is issued. The usb subsystem must be
-// initialised before comedi can access it.
-static usbduxfastsub_t usbduxfastsub[NUMUSBDUXFAST];
+/*
+ * The pointer to the private usb-data of the driver
+ * is also the private data for the comedi-device.
+ * This has to be global as the usb subsystem needs
+ * global variables. The other reason is that this
+ * structure must be there _before_ any comedi
+ * command is issued. The usb subsystem must be
+ * initialised before comedi can access it.
+ */
+static struct usbduxfastsub_s usbduxfastsub[NUMUSBDUXFAST];
 
 static DECLARE_MUTEX(start_stop_sem);
 
-// bulk transfers to usbduxfast
-
+/*
+ * bulk transfers to usbduxfast
+ */
 #define SENDADCOMMANDS            0
 #define SENDINITEP6               1
 
-static int send_dux_commands(usbduxfastsub_t * this_usbduxfastsub, int cmd_type)
+static int send_dux_commands(struct usbduxfastsub_s *udfs, int cmd_type)
 {
 	int tmp, nsent;
 
-	this_usbduxfastsub->dux_commands[0] = cmd_type;
+	udfs->dux_commands[0] = cmd_type;
 
 #ifdef CONFIG_COMEDI_DEBUG
 	printk(KERN_DEBUG "comedi%d: usbduxfast: dux_commands: ",
-		this_usbduxfastsub->comedidev->minor);
+		udfs->comedidev->minor);
 	for (tmp = 0; tmp < SIZEOFDUXBUFFER; tmp++)
-		printk(" %02x", this_usbduxfastsub->dux_commands[tmp]);
+		printk(" %02x", udfs->dux_commands[tmp]);
 	printk("\n");
 #endif
 
-	tmp = usb_bulk_msg(this_usbduxfastsub->usbdev,
-			      usb_sndbulkpipe(this_usbduxfastsub->usbdev,
-					      CHANNELLISTEP),
-			      this_usbduxfastsub->dux_commands, SIZEOFDUXBUFFER,
-			      &nsent, 10000);
+	tmp = usb_bulk_msg(udfs->usbdev,
+			   usb_sndbulkpipe(udfs->usbdev, CHANNELLISTEP),
+			   udfs->dux_commands, SIZEOFDUXBUFFER, &nsent, 10000);
 	if (tmp < 0)
 		printk(KERN_ERR "comedi%d: could not transmit dux_commands to"
-		       "the usb-device, err=%d\n",
-		       this_usbduxfastsub->comedidev->minor, tmp);
-
+		      "the usb-device, err=%d\n", udfs->comedidev->minor, tmp);
 	return tmp;
 }
 
-// Stops the data acquision
-// It should be safe to call this function from any context
-static int usbduxfastsub_unlink_InURBs(usbduxfastsub_t * usbduxfastsub_tmp)
+/*
+ * Stops the data acquision.
+ * It should be safe to call this function from any context.
+ */
+static int usbduxfastsub_unlink_InURBs(struct usbduxfastsub_s *udfs)
 {
 	int j = 0;
 	int err = 0;
 
-	if (usbduxfastsub_tmp && usbduxfastsub_tmp->urbIn) {
-		usbduxfastsub_tmp->ai_cmd_running = 0;
-		// waits until a running transfer is over
-		usb_kill_urb(usbduxfastsub_tmp->urbIn);
+	if (udfs && udfs->urbIn) {
+		udfs->ai_cmd_running = 0;
+		/* waits until a running transfer is over */
+		usb_kill_urb(udfs->urbIn);
 		j = 0;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi: usbduxfast: unlinked InURB: res=%d\n", j);
+	printk(KERN_DEBUG "comedi: usbduxfast: unlinked InURB: res=%d\n", j);
 #endif
 	return err;
 }
 
-/* This will stop a running acquisition operation */
-// Is called from within this driver from both the
-// interrupt context and from comedi
-static int usbduxfast_ai_stop(usbduxfastsub_t * this_usbduxfastsub,
+/*
+ * This will stop a running acquisition operation.
+ * Is called from within this driver from both the
+ * interrupt context and from comedi.
+ */
+static int usbduxfast_ai_stop(struct usbduxfastsub_s *udfs,
 	int do_unlink)
 {
 	int ret = 0;
 
-	if (!this_usbduxfastsub) {
-		printk("comedi?: usbduxfast_ai_stop: this_usbduxfastsub=NULL!\n");
+	if (!udfs) {
+		printk(KERN_ERR "comedi?: usbduxfast_ai_stop: udfs=NULL!\n");
 		return -EFAULT;
 	}
+
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi: usbduxfast_ai_stop\n");
+	printk(KERN_DEBUG "comedi: usbduxfast_ai_stop\n");
 #endif
 
-	this_usbduxfastsub->ai_cmd_running = 0;
+	udfs->ai_cmd_running = 0;
 
-	if (do_unlink) {
-		// stop aquistion
-		ret = usbduxfastsub_unlink_InURBs(this_usbduxfastsub);
-	}
+	if (do_unlink)
+		ret = usbduxfastsub_unlink_InURBs(udfs); /* stop aquistion */
 
 	return ret;
 }
 
-// This will cancel a running acquisition operation.
-// This is called by comedi but never from inside the
-// driver.
-static int usbduxfast_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+/*
+ * This will cancel a running acquisition operation.
+ * This is called by comedi but never from inside the driver.
+ */
+static int usbduxfast_ai_cancel(comedi_device *dev, comedi_subdevice *s)
 {
-	usbduxfastsub_t *this_usbduxfastsub;
-	int res = 0;
+	struct usbduxfastsub_s *udfs;
+	int ret;
 
-	// force unlink of all urbs
+	/* force unlink of all urbs */
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi: usbduxfast_ai_cancel\n");
+	printk(KERN_DEBUG "comedi: usbduxfast_ai_cancel\n");
 #endif
-	this_usbduxfastsub = dev->private;
-	if (!this_usbduxfastsub) {
-		printk("comedi: usbduxfast_ai_cancel: this_usbduxfastsub=NULL\n");
+	udfs = dev->private;
+	if (!udfs) {
+		printk(KERN_ERR "comedi: usbduxfast_ai_cancel: udfs=NULL\n");
 		return -EFAULT;
 	}
-	down(&this_usbduxfastsub->sem);
-	if (!(this_usbduxfastsub->probed)) {
-		up(&this_usbduxfastsub->sem);
+	down(&udfs->sem);
+	if (!udfs->probed) {
+		up(&udfs->sem);
 		return -ENODEV;
 	}
-	// unlink
-	res = usbduxfast_ai_stop(this_usbduxfastsub, 1);
-	up(&this_usbduxfastsub->sem);
+	/* unlink */
+	ret = usbduxfast_ai_stop(udfs, 1);
+	up(&udfs->sem);
 
-	return res;
+	return ret;
 }
 
-// analogue IN
-// interrupt service routine
+/*
+ * analogue IN
+ * interrupt service routine
+ */
 static void usbduxfastsub_ai_Irq(struct urb *urb PT_REGS_ARG)
 {
 	int n, err;
-	usbduxfastsub_t *this_usbduxfastsub;
+	struct usbduxfastsub_s *udfs;
 	comedi_device *this_comedidev;
 	comedi_subdevice *s;
 	uint16_t *p;
 
-	// sanity checks
-	// is the urb there?
+	/* sanity checks - is the urb there? */
 	if (!urb) {
-		printk("comedi_: usbduxfast_: ao int-handler called with urb=NULL!\n");
+		printk(KERN_ERR "comedi_: usbduxfast_: ao int-handler called "
+		       "with urb=NULL!\n");
 		return;
 	}
-	// the context variable points to the subdevice
+	/* the context variable points to the subdevice */
 	this_comedidev = urb->context;
 	if (!this_comedidev) {
-		printk("comedi_: usbduxfast_: urb context is a NULL pointer!\n");
+		printk(KERN_ERR "comedi_: usbduxfast_: urb context is a NULL "
+		       "pointer!\n");
 		return;
 	}
-	// the private structure of the subdevice is usbduxfastsub_t
-	this_usbduxfastsub = this_comedidev->private;
-	if (!this_usbduxfastsub) {
-		printk("comedi_: usbduxfast_: private of comedi subdev is a NULL pointer!\n");
+	/* the private structure of the subdevice is usbduxfastsub_s */
+	udfs = this_comedidev->private;
+	if (!udfs) {
+		printk(KERN_ERR "comedi_: usbduxfast_: private of comedi "
+		       "subdev is a NULL pointer!\n");
 		return;
 	}
-	// are we running a command?
-	if (unlikely(!(this_usbduxfastsub->ai_cmd_running))) {
-		// not running a command
-		// do not continue execution if no asynchronous command is running
-		// in particular not resubmit
+	/* are we running a command? */
+	if (unlikely(!udfs->ai_cmd_running)) {
+		/*
+		 * not running a command
+		 * do not continue execution if no asynchronous command
+		 * is running in particular not resubmit
+		 */
 		return;
 	}
 
-	if (unlikely(!(this_usbduxfastsub->attached))) {
-		// no comedi device there
+	if (unlikely(!udfs->attached)) {
+		/* no comedi device there */
 		return;
 	}
-	// subdevice which is the AD converter
+	/* subdevice which is the AD converter */
 	s = this_comedidev->subdevices + SUBDEV_AD;
 
-	// first we test if something unusual has just happened
+	/* first we test if something unusual has just happened */
 	switch (urb->status) {
 	case 0:
 		break;
 
-		// happens after an unlink command or when the device is plugged out
+		/*
+		 * happens after an unlink command or when the device
+		 * is plugged out
+		 */
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -ECONNABORTED:
-		// tell this comedi
+		/* tell this comedi */
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(this_usbduxfastsub->comedidev, s);
-		// stop the transfer w/o unlink
-		usbduxfast_ai_stop(this_usbduxfastsub, 0);
+		comedi_event(udfs->comedidev, s);
+		/* stop the transfer w/o unlink */
+		usbduxfast_ai_stop(udfs, 0);
 		return;
 
 	default:
-		printk("comedi%d: usbduxfast: non-zero urb status received in ai intr context: %d\n", this_usbduxfastsub->comedidev->minor, urb->status);
+		printk("comedi%d: usbduxfast: non-zero urb status received in "
+		       "ai intr context: %d\n",
+		       udfs->comedidev->minor, urb->status);
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(this_usbduxfastsub->comedidev, s);
-		usbduxfast_ai_stop(this_usbduxfastsub, 0);
+		comedi_event(udfs->comedidev, s);
+		usbduxfast_ai_stop(udfs, 0);
 		return;
 	}
 
 	p = urb->transfer_buffer;
-	if (!this_usbduxfastsub->ignore) {
-		if (!(this_usbduxfastsub->ai_continous)) {
-			// not continous, fixed number of samples
+	if (!udfs->ignore) {
+		if (!udfs->ai_continous) {
+			/* not continous, fixed number of samples */
 			n = urb->actual_length / sizeof(uint16_t);
-			if (unlikely(this_usbduxfastsub->ai_sample_count < n)) {
-				// we have send only a fraction of the bytes received
+			if (unlikely(udfs->ai_sample_count < n)) {
+				/*
+				 * we have send only a fraction of the bytes
+				 * received
+				 */
 				cfc_write_array_to_buffer(s,
 					urb->transfer_buffer,
-					this_usbduxfastsub->ai_sample_count *
-					sizeof(uint16_t));
-				usbduxfast_ai_stop(this_usbduxfastsub, 0);
-				// say comedi that the acquistion is over
+					udfs->ai_sample_count
+					* sizeof(uint16_t));
+				usbduxfast_ai_stop(udfs, 0);
+				/* say comedi that the acquistion is over */
 				s->async->events |= COMEDI_CB_EOA;
-				comedi_event(this_usbduxfastsub->comedidev, s);
+				comedi_event(udfs->comedidev, s);
 				return;
 			}
-			this_usbduxfastsub->ai_sample_count -= n;
+			udfs->ai_sample_count -= n;
 		}
-		// write the full buffer to comedi
-		cfc_write_array_to_buffer(s,
-			urb->transfer_buffer, urb->actual_length);
+		/* write the full buffer to comedi */
+		cfc_write_array_to_buffer(s, urb->transfer_buffer,
+					  urb->actual_length);
 
-		// tell comedi that data is there
-		comedi_event(this_usbduxfastsub->comedidev, s);
+		/* tell comedi that data is there */
+		comedi_event(udfs->comedidev, s);
 
 	} else {
-		// ignore this packet
-		this_usbduxfastsub->ignore--;
+		/* ignore this packet */
+		udfs->ignore--;
 	}
 
-	// command is still running
-	// resubmit urb for BULK transfer
-	urb->dev = this_usbduxfastsub->usbdev;
+	/*
+	 * command is still running
+	 * resubmit urb for BULK transfer
+	 */
+	urb->dev = udfs->usbdev;
 	urb->status = 0;
 	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if (err < 0) {
-		printk("comedi%d: usbduxfast: urb resubm failed: %d",
-			this_usbduxfastsub->comedidev->minor, err);
+		printk(KERN_ERR "comedi%d: usbduxfast: urb resubm failed: %d",
+			udfs->comedidev->minor, err);
 		s->async->events |= COMEDI_CB_EOA;
 		s->async->events |= COMEDI_CB_ERROR;
-		comedi_event(this_usbduxfastsub->comedidev, s);
-		usbduxfast_ai_stop(this_usbduxfastsub, 0);
+		comedi_event(udfs->comedidev, s);
+		usbduxfast_ai_stop(udfs, 0);
 	}
 }
 
-static int usbduxfastsub_start(usbduxfastsub_t * usbduxfastsub)
+static int usbduxfastsub_start(struct usbduxfastsub_s *udfs)
 {
-	int errcode = 0;
+	int ret;
 	unsigned char local_transfer_buffer[16];
 
-	if (usbduxfastsub->probed) {
-		// 7f92 to zero
-		local_transfer_buffer[0] = 0;
-		errcode = usb_control_msg(usbduxfastsub->usbdev,
-			// create a pipe for a control transfer
-			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
-			// bRequest, "Firmware"
-			USBDUXFASTSUB_FIRMWARE,
-			// bmRequestType
-			VENDOR_DIR_OUT,
-			// Value
-			USBDUXFASTSUB_CPUCS,
-			// Index
-			0x0000,
-			// address of the transfer buffer
-			local_transfer_buffer,
-			// Length
-			1,
-			// Timeout
-			EZTIMEOUT);
-		if (errcode < 0) {
-			printk("comedi_: usbduxfast_: control msg failed (start)\n");
-			return errcode;
-		}
+	if (!udfs->probed)
+		return 0;
+
+	/* 7f92 to zero */
+	local_transfer_buffer[0] = 0;
+	ret = usb_control_msg(udfs->usbdev,
+		usb_sndctrlpipe(udfs->usbdev, 0),
+		USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
+		VENDOR_DIR_OUT,		/* bmRequestType */
+		USBDUXFASTSUB_CPUCS,	/* Value */
+		0x0000,			/* Index */
+		local_transfer_buffer,	/* address of the transfer buffer */
+		1,			/* Length */
+		EZTIMEOUT);		/* Timeout */
+	if (ret < 0) {
+		printk("comedi_: usbduxfast_: control msg failed (start)\n");
+		return ret;
 	}
+
 	return 0;
 }
 
-static int usbduxfastsub_stop(usbduxfastsub_t * usbduxfastsub)
+static int usbduxfastsub_stop(struct usbduxfastsub_s *udfs)
 {
-	int errcode = 0;
-
+	int ret;
 	unsigned char local_transfer_buffer[16];
-	if (usbduxfastsub->probed) {
-		// 7f92 to one
-		local_transfer_buffer[0] = 1;
-		errcode = usb_control_msg(usbduxfastsub->usbdev,
-			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
-			// bRequest, "Firmware"
-			USBDUXFASTSUB_FIRMWARE,
-			// bmRequestType
-			VENDOR_DIR_OUT,
-			// Value
-			USBDUXFASTSUB_CPUCS,
-			// Index
-			0x0000, local_transfer_buffer,
-			// Length
-			1,
-			// Timeout
-			EZTIMEOUT);
-		if (errcode < 0) {
-			printk("comedi_: usbduxfast: control msg failed (stop)\n");
-			return errcode;
-		}
+
+	if (!udfs->probed)
+		return 0;
+
+	/* 7f92 to one */
+	local_transfer_buffer[0] = 1;
+	ret = usb_control_msg(udfs->usbdev,
+		usb_sndctrlpipe(udfs->usbdev, 0),
+		USBDUXFASTSUB_FIRMWARE,	/* bRequest, "Firmware" */
+		VENDOR_DIR_OUT,		/* bmRequestType */
+		USBDUXFASTSUB_CPUCS,	/* Value */
+		0x0000,			/* Index */
+		local_transfer_buffer,
+		1,			/* Length */
+		EZTIMEOUT);		/* Timeout */
+	if (ret < 0) {
+		printk(KERN_ERR "comedi_: usbduxfast: control msg failed "
+		       "(stop)\n");
+		return ret;
 	}
+
 	return 0;
 }
 
-static int usbduxfastsub_upload(usbduxfastsub_t * usbduxfastsub,
+static int usbduxfastsub_upload(struct usbduxfastsub_s *udfs,
 	unsigned char *local_transfer_buffer,
 	unsigned int startAddr, unsigned int len)
 {
-	int errcode;
+	int ret;
 
-	if (usbduxfastsub->probed) {
-#ifdef CONFIG_COMEDI_DEBUG
-		printk("comedi%d: usbduxfast: uploading %d bytes",
-			usbduxfastsub->comedidev->minor, len);
-		printk(" to addr %d, first byte=%d.\n",
-			startAddr, local_transfer_buffer[0]);
-#endif
-		errcode = usb_control_msg(usbduxfastsub->usbdev,
-			usb_sndctrlpipe(usbduxfastsub->usbdev, 0),
-			// brequest, firmware
-			USBDUXFASTSUB_FIRMWARE,
-			// bmRequestType
-			VENDOR_DIR_OUT,
-			// value
-			startAddr,
-			// index
-			0x0000,
-			// our local safe buffer
-			local_transfer_buffer,
-			// length
-			len,
-			// timeout
-			EZTIMEOUT);
-#ifdef CONFIG_COMEDI_DEBUG
-		printk("comedi_: usbduxfast: result=%d\n", errcode);
-#endif
-		if (errcode < 0) {
-			printk("comedi_: usbduxfast: uppload failed\n");
-			return errcode;
-		}
-	} else {
-		// no device on the bus for this index
+	if (!udfs->probed)
+		/* no device on the bus for this index */
 		return -EFAULT;
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk(KERN_DEBUG "comedi%d: usbduxfast: uploading %d bytes",
+		udfs->comedidev->minor, len);
+	printk(KERN_DEBUG " to addr %d, first byte=%d.\n",
+		startAddr, local_transfer_buffer[0]);
+#endif
+	ret = usb_control_msg(udfs->usbdev,
+		usb_sndctrlpipe(udfs->usbdev, 0),
+		USBDUXFASTSUB_FIRMWARE, /* brequest, firmware */
+		VENDOR_DIR_OUT,		/* bmRequestType */
+		startAddr,		/* value */
+		0x0000,			/* index */
+		local_transfer_buffer,	/* our local safe buffer */
+		len,			/* length */
+		EZTIMEOUT);		/* timeout */
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk(KERN_DEBUG "comedi_: usbduxfast: result=%d\n", ret);
+#endif
+
+	if (ret < 0) {
+		printk(KERN_ERR "comedi_: usbduxfast: uppload failed\n");
+		return ret;
 	}
+
 	return 0;
 }
 
-int firmwareUpload(usbduxfastsub_t * usbduxfastsub,
-	unsigned char *firmwareBinary, int sizeFirmware)
+int firmwareUpload(struct usbduxfastsub_s *udfs, unsigned char *firmwareBinary,
+		   int sizeFirmware)
 {
 	int ret;
 
-	if (!firmwareBinary) {
+	if (!firmwareBinary)
 		return 0;
-	}
-	ret = usbduxfastsub_stop(usbduxfastsub);
+
+	ret = usbduxfastsub_stop(udfs);
 	if (ret < 0) {
-		printk("comedi_: usbduxfast: can not stop firmware\n");
+		printk(KERN_ERR "comedi_: usbduxfast: can not stop firmware\n");
 		return ret;
 	}
-	ret = usbduxfastsub_upload(usbduxfastsub,
-		firmwareBinary, 0, sizeFirmware);
+	ret = usbduxfastsub_upload(udfs, firmwareBinary, 0, sizeFirmware);
 	if (ret < 0) {
-		printk("comedi_: usbduxfast: firmware upload failed\n");
+		printk(KERN_ERR "comedi_: usbduxfast: firmware upload failed\n");
 		return ret;
 	}
-	ret = usbduxfastsub_start(usbduxfastsub);
+	ret = usbduxfastsub_start(udfs);
 	if (ret < 0) {
-		printk("comedi_: usbduxfast: can not start firmware\n");
+		printk(KERN_ERR "comedi_: usbduxfast: can not start firmware\n");
 		return ret;
 	}
+
 	return 0;
 }
 
-int usbduxfastsub_submit_InURBs(usbduxfastsub_t * usbduxfastsub)
+int usbduxfastsub_submit_InURBs(struct usbduxfastsub_s *udfs)
 {
-	int errFlag;
+	int ret;
 
-	if (!usbduxfastsub) {
+	if (!udfs)
 		return -EFAULT;
-	}
-	usb_fill_bulk_urb(usbduxfastsub->urbIn,
-		usbduxfastsub->usbdev,
-		usb_rcvbulkpipe(usbduxfastsub->usbdev, BULKINEP),
-		usbduxfastsub->transfer_buffer,
-		SIZEINBUF, usbduxfastsub_ai_Irq, usbduxfastsub->comedidev);
-
-#ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: submitting in-urb: 0x%p,0x%p\n",
-		usbduxfastsub->comedidev->minor,
-		usbduxfastsub->urbIn->context,
-		usbduxfastsub->urbIn->dev);
-#endif
-	errFlag = usb_submit_urb(usbduxfastsub->urbIn, GFP_ATOMIC);
-	if (errFlag) {
-		printk("comedi_: usbduxfast: ai: usb_submit_urb error %d\n",
-			errFlag);
-		return errFlag;
+
+	usb_fill_bulk_urb(udfs->urbIn, udfs->usbdev,
+			  usb_rcvbulkpipe(udfs->usbdev, BULKINEP),
+			  udfs->transfer_buffer,
+			  SIZEINBUF, usbduxfastsub_ai_Irq, udfs->comedidev);
+
+#ifdef CONFIG_COMEDI_DEBUG
+	printk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "
+	       "0x%p,0x%p\n", udfs->comedidev->minor, udfs->urbIn->context,
+		udfs->urbIn->dev);
+#endif
+	ret = usb_submit_urb(udfs->urbIn, GFP_ATOMIC);
+	if (ret) {
+		printk(KERN_ERR "comedi_: usbduxfast: ai: usb_submit_urb error"
+		       " %d\n", ret);
+		return ret;
 	}
 	return 0;
 }
 
-static int usbduxfast_ai_cmdtest(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd)
+static int usbduxfast_ai_cmdtest(comedi_device *dev,
+	comedi_subdevice *s, comedi_cmd *cmd)
 {
 	int err = 0, stop_mask = 0;
-	long int steps, tmp = 0;
+	long int steps, tmp;
 	int minSamplPer;
-	usbduxfastsub_t *this_usbduxfastsub = dev->private;
-	if (!(this_usbduxfastsub->probed)) {
+	struct usbduxfastsub_s *udfs = dev->private;
+
+	if (!udfs->probed)
 		return -ENODEV;
-	}
+
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast_ai_cmdtest\n", dev->minor);
-	printk("comedi%d: usbduxfast: convert_arg=%u scan_begin_arg=%u\n",
-		dev->minor, cmd->convert_arg, cmd->scan_begin_arg);
+	printk(KERN_DEBUG "comedi%d: usbduxfast_ai_cmdtest\n", dev->minor);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: convert_arg=%u "
+	       "scan_begin_arg=%u\n",
+	       dev->minor, cmd->convert_arg, cmd->scan_begin_arg);
 #endif
 	/* step 1: make sure trigger sources are trivially valid */
 
@@ -607,7 +633,9 @@ static int usbduxfast_ai_cmdtest(comedi_
 	if (err)
 		return 1;
 
-	/* step 2: make sure trigger sources are unique and mutually compatible */
+	/*
+	 * step 2: make sure trigger sources are unique and mutually compatible
+	 */
 
 	if (cmd->start_src != TRIG_NOW &&
 		cmd->start_src != TRIG_EXT && cmd->start_src != TRIG_INT)
@@ -622,7 +650,7 @@ static int usbduxfast_ai_cmdtest(comedi_
 		cmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)
 		err++;
 
-	// can't have external stop and start triggers at once
+	/* can't have external stop and start triggers at once */
 	if (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)
 		err++;
 
@@ -636,29 +664,28 @@ static int usbduxfast_ai_cmdtest(comedi_
 		err++;
 	}
 
-	if (!cmd->chanlist_len) {
+	if (!cmd->chanlist_len)
 		err++;
-	}
+
 	if (cmd->scan_end_arg != cmd->chanlist_len) {
 		cmd->scan_end_arg = cmd->chanlist_len;
 		err++;
 	}
 
-	if (cmd->chanlist_len == 1) {
+	if (cmd->chanlist_len == 1)
 		minSamplPer = 1;
-	} else {
+	else
 		minSamplPer = MIN_SAMPLING_PERIOD;
-	}
 
 	if (cmd->convert_src == TRIG_TIMER) {
 		steps = cmd->convert_arg * 30;
-		if (steps < (minSamplPer * 1000)) {
+		if (steps < (minSamplPer * 1000))
 			steps = minSamplPer * 1000;
-		}
-		if (steps > (MAX_SAMPLING_PERIOD * 1000)) {
+
+		if (steps > (MAX_SAMPLING_PERIOD * 1000))
 			steps = MAX_SAMPLING_PERIOD * 1000;
-		}
-		// calc arg again
+
+		/* calc arg again */
 		tmp = steps / 30;
 		if (cmd->convert_arg != tmp) {
 			cmd->convert_arg = tmp;
@@ -666,10 +693,10 @@ static int usbduxfast_ai_cmdtest(comedi_
 		}
 	}
 
-	if (cmd->scan_begin_src == TRIG_TIMER) {
+	if (cmd->scan_begin_src == TRIG_TIMER)
 		err++;
-	}
-	// stop source
+
+	/* stop source */
 	switch (cmd->stop_src) {
 	case TRIG_COUNT:
 		if (!cmd->stop_arg) {
@@ -683,7 +710,10 @@ static int usbduxfast_ai_cmdtest(comedi_
 			err++;
 		}
 		break;
-		// TRIG_EXT doesn't care since it doesn't trigger off a numbered channel
+		/*
+		 * TRIG_EXT doesn't care since it doesn't trigger
+		 * off a numbered channel
+		 */
 	default:
 		break;
 	}
@@ -697,588 +727,676 @@ static int usbduxfast_ai_cmdtest(comedi_
 
 }
 
-static int usbduxfast_ai_inttrig(comedi_device * dev,
-	comedi_subdevice * s, unsigned int trignum)
+static int usbduxfast_ai_inttrig(comedi_device *dev,
+	comedi_subdevice *s, unsigned int trignum)
 {
 	int ret;
-	usbduxfastsub_t *this_usbduxfastsub = dev->private;
-	if (!this_usbduxfastsub) {
+	struct usbduxfastsub_s *udfs = dev->private;
+
+	if (!udfs)
 		return -EFAULT;
-	}
-	down(&this_usbduxfastsub->sem);
-	if (!(this_usbduxfastsub->probed)) {
-		up(&this_usbduxfastsub->sem);
+
+	down(&udfs->sem);
+	if (!udfs->probed) {
+		up(&udfs->sem);
 		return -ENODEV;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast_ai_inttrig\n", dev->minor);
+	printk(KERN_DEBUG "comedi%d: usbduxfast_ai_inttrig\n", dev->minor);
 #endif
 
 	if (trignum != 0) {
-		printk("comedi%d: usbduxfast_ai_inttrig: invalid trignum\n",
-			dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: usbduxfast_ai_inttrig: invalid"
+		       " trignum\n", dev->minor);
+		up(&udfs->sem);
 		return -EINVAL;
 	}
-	if (!(this_usbduxfastsub->ai_cmd_running)) {
-		this_usbduxfastsub->ai_cmd_running = 1;
-		ret = usbduxfastsub_submit_InURBs(this_usbduxfastsub);
+	if (!udfs->ai_cmd_running) {
+		udfs->ai_cmd_running = 1;
+		ret = usbduxfastsub_submit_InURBs(udfs);
 		if (ret < 0) {
-			printk("comedi%d: usbduxfast_ai_inttrig: urbSubmit: err=%d\n", dev->minor, ret);
-			this_usbduxfastsub->ai_cmd_running = 0;
-			up(&this_usbduxfastsub->sem);
+			printk(KERN_ERR "comedi%d: usbduxfast_ai_inttrig: "
+			       "urbSubmit: err=%d\n", dev->minor, ret);
+			udfs->ai_cmd_running = 0;
+			up(&udfs->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
-		printk("comedi%d: ai_inttrig but acqu is already running\n",
-			dev->minor);
+		printk(KERN_ERR "comedi%d: ai_inttrig but acqu is already"
+		       " running\n", dev->minor);
 	}
-	up(&this_usbduxfastsub->sem);
+	up(&udfs->sem);
 	return 1;
 }
 
-// offsets for the GPIF bytes
-// the first byte is the command byte
-#define LENBASE 1+0x00
-#define OPBASE  1+0x08
-#define OUTBASE 1+0x10
-#define LOGBASE 1+0x18
+/*
+ * offsets for the GPIF bytes
+ * the first byte is the command byte
+ */
+#define LENBASE	(1+0x00)
+#define OPBASE	(1+0x08)
+#define OUTBASE	(1+0x10)
+#define LOGBASE	(1+0x18)
 
-static int usbduxfast_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int usbduxfast_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &s->async->cmd;
 	unsigned int chan, gain, rngmask = 0xff;
 	int i, j, ret;
-	usbduxfastsub_t *this_usbduxfastsub = dev->private;
+	struct usbduxfastsub_s *udfs;
 	int result;
 	long steps, steps_tmp;
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast_ai_cmd\n", dev->minor);
+	printk(KERN_DEBUG "comedi%d: usbduxfast_ai_cmd\n", dev->minor);
 #endif
-	if (!this_usbduxfastsub) {
+	udfs = dev->private;
+	if (!udfs)
 		return -EFAULT;
-	}
-	down(&this_usbduxfastsub->sem);
-	if (!(this_usbduxfastsub->probed)) {
-		up(&this_usbduxfastsub->sem);
+
+	down(&udfs->sem);
+	if (!udfs->probed) {
+		up(&udfs->sem);
 		return -ENODEV;
 	}
-	if (this_usbduxfastsub->ai_cmd_running) {
-		printk("comedi%d: ai_cmd not possible. Another ai_cmd is running.\n", dev->minor);
-		up(&this_usbduxfastsub->sem);
+	if (udfs->ai_cmd_running) {
+		printk(KERN_ERR "comedi%d: ai_cmd not possible. Another ai_cmd"
+		       " is running.\n", dev->minor);
+		up(&udfs->sem);
 		return -EBUSY;
 	}
-	// set current channel of the running aquisition to zero
+	/* set current channel of the running aquisition to zero */
 	s->async->cur_chan = 0;
 
-	// ignore the first buffers from the device if there is an error condition
-	this_usbduxfastsub->ignore = PACKETS_TO_IGNORE;
+	/*
+	 * ignore the first buffers from the device if there
+	 * is an error condition
+	 */
+	udfs->ignore = PACKETS_TO_IGNORE;
 
 	if (cmd->chanlist_len > 0) {
 		gain = CR_RANGE(cmd->chanlist[0]);
 		for (i = 0; i < cmd->chanlist_len; ++i) {
 			chan = CR_CHAN(cmd->chanlist[i]);
 			if (chan != i) {
-				printk("comedi%d: cmd is accepting only consecutive channels.\n", dev->minor);
-				up(&this_usbduxfastsub->sem);
+				printk(KERN_ERR "comedi%d: cmd is accepting "
+				       "only consecutive channels.\n",
+				       dev->minor);
+				up(&udfs->sem);
 				return -EINVAL;
 			}
 			if ((gain != CR_RANGE(cmd->chanlist[i]))
 				&& (cmd->chanlist_len > 3)) {
-				printk("comedi%d: the gain must be the same for all channels.\n", dev->minor);
-				up(&this_usbduxfastsub->sem);
+				printk(KERN_ERR "comedi%d: the gain must be"
+				       " the same for all channels.\n",
+				       dev->minor);
+				up(&udfs->sem);
 				return -EINVAL;
 			}
 			if (i >= NUMCHANNELS) {
-				printk("comedi%d: channel list too long\n",
-					dev->minor);
+				printk(KERN_ERR "comedi%d: channel list too"
+				       " long\n", dev->minor);
 				break;
 			}
 		}
 	}
 	steps = 0;
 	if (cmd->scan_begin_src == TRIG_TIMER) {
-		printk("comedi%d: usbduxfast: scan_begin_src==TRIG_TIMER not valid.\n", dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: usbduxfast: "
+		       "scan_begin_src==TRIG_TIMER not valid.\n", dev->minor);
+		up(&udfs->sem);
 		return -EINVAL;
 	}
-	if (cmd->convert_src == TRIG_TIMER) {
+	if (cmd->convert_src == TRIG_TIMER)
 		steps = (cmd->convert_arg * 30) / 1000;
-	}
+
 	if ((steps < MIN_SAMPLING_PERIOD) && (cmd->chanlist_len != 1)) {
-		printk("comedi%d: usbduxfast: ai_cmd: steps=%ld, scan_begin_arg=%d. Not properly tested by cmdtest?\n", dev->minor, steps, cmd->scan_begin_arg);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: steps=%ld, "
+		       "scan_begin_arg=%d. Not properly tested by cmdtest?\n",
+		       dev->minor, steps, cmd->scan_begin_arg);
+		up(&udfs->sem);
 		return -EINVAL;
 	}
 	if (steps > MAX_SAMPLING_PERIOD) {
-		printk("comedi%d: usbduxfast: ai_cmd: sampling rate too low.\n",
-			dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: sampling rate "
+		       "too low.\n", dev->minor);
+		up(&udfs->sem);
 		return -EINVAL;
 	}
 	if ((cmd->start_src == TRIG_EXT) && (cmd->chanlist_len != 1)
 		&& (cmd->chanlist_len != 16)) {
-		printk("comedi%d: usbduxfast: ai_cmd: TRIG_EXT only with 1 or 16 channels possible.\n", dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: usbduxfast: ai_cmd: TRIG_EXT only"
+		       " with 1 or 16 channels possible.\n", dev->minor);
+		up(&udfs->sem);
 		return -EINVAL;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: steps=%ld, convert_arg=%u\n",
-		dev->minor, steps, cmd->convert_arg);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: steps=%ld, convert_arg=%u\n",
+	       dev->minor, steps, cmd->convert_arg);
 #endif
 
 	switch (cmd->chanlist_len) {
-		// one channel
 	case 1:
+		/*
+		 * one channel
+		 */
+
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
 
-		// for external trigger: looping in this state until the RDY0 pin
-		// becomes zero
-		if (cmd->start_src == TRIG_EXT) {	// we loop here until ready has been set
-			this_usbduxfastsub->dux_commands[LENBASE + 0] = 0x01;	// branch back to state 0
-			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0x01;	// deceision state w/o data
-			this_usbduxfastsub->dux_commands[OUTBASE + 0] =
-				0xFF & rngmask;
-			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0x00;	// RDY0 = 0
-		} else {	// we just proceed to state 1
-			this_usbduxfastsub->dux_commands[LENBASE + 0] = 1;
-			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0;
-			this_usbduxfastsub->dux_commands[OUTBASE + 0] =
-				0xFF & rngmask;
-			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
+		/*
+		 * for external trigger: looping in this state until
+		 * the RDY0 pin becomes zero
+		 */
+
+		/* we loop here until ready has been set */
+		if (cmd->start_src == TRIG_EXT) {
+			/* branch back to state 0 */
+			udfs->dux_commands[LENBASE+0] = 0x01;
+			/* deceision state w/o data */
+			udfs->dux_commands[OPBASE+0] = 0x01;
+			udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
+			/* RDY0 = 0 */
+			udfs->dux_commands[LOGBASE+0] = 0x00;
+		} else {	/* we just proceed to state 1 */
+			udfs->dux_commands[LENBASE+0] = 1;
+			udfs->dux_commands[OPBASE+0] = 0;
+			udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE+0] = 0;
 		}
 
 		if (steps < MIN_SAMPLING_PERIOD) {
-			// for fast single channel aqu without mux
+			/* for fast single channel aqu without mux */
 			if (steps <= 1) {
-				// we just stay here at state 1 and rexecute the same state
-				// this gives us 30MHz sampling rate
-				this_usbduxfastsub->dux_commands[LENBASE + 1] = 0x89;	// branch back to state 1
-				this_usbduxfastsub->dux_commands[OPBASE + 1] = 0x03;	// deceision state with data
-				this_usbduxfastsub->dux_commands[OUTBASE + 1] =
-					0xFF & rngmask;
-				this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0xFF;	// doesn't matter
+				/*
+				 * we just stay here at state 1 and rexecute
+				 * the same state this gives us 30MHz sampling
+				 * rate
+				 */
+
+				/* branch back to state 1 */
+				udfs->dux_commands[LENBASE+1] = 0x89;
+				/* deceision state with data */
+				udfs->dux_commands[OPBASE+1] = 0x03;
+				udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+				/* doesn't matter */
+				udfs->dux_commands[LOGBASE+1] = 0xFF;
 			} else {
-				// we loop through two states: data and delay: max rate is 15Mhz
-				this_usbduxfastsub->dux_commands[LENBASE + 1] =
-					steps - 1;
-				this_usbduxfastsub->dux_commands[OPBASE + 1] = 0x02;	// data
-				this_usbduxfastsub->dux_commands[OUTBASE + 1] =
-					0xFF & rngmask;
-				this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;	// doesn't matter
-
-				this_usbduxfastsub->dux_commands[LENBASE + 2] = 0x09;	// branch back to state 1
-				this_usbduxfastsub->dux_commands[OPBASE + 2] = 0x01;	// deceision state w/o data
-				this_usbduxfastsub->dux_commands[OUTBASE + 2] =
-					0xFF & rngmask;
-				this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0xFF;	// doesn't matter
+				/*
+				 * we loop through two states: data and delay
+				 * max rate is 15MHz
+				 */
+				udfs->dux_commands[LENBASE+1] = steps - 1;
+				/* data */
+				udfs->dux_commands[OPBASE+1] = 0x02;
+				udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+				/* doesn't matter */
+				udfs->dux_commands[LOGBASE+1] = 0;
+				/* branch back to state 1 */
+				udfs->dux_commands[LENBASE+2] = 0x09;
+				/* deceision state w/o data */
+				udfs->dux_commands[OPBASE+2] = 0x01;
+				udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
+				/* doesn't matter */
+				udfs->dux_commands[LOGBASE+2] = 0xFF;
 			}
 		} else {
-			// we loop through 3 states: 2x delay and 1x data. This gives a min
-			// sampling rate of 60kHz.
+			/*
+			 * we loop through 3 states: 2x delay and 1x data
+			 * this gives a min sampling rate of 60kHz
+			 */
 
-			// we have 1 state with duration 1
+			/* we have 1 state with duration 1 */
 			steps = steps - 1;
 
-			// do the first part of the delay
-			this_usbduxfastsub->dux_commands[LENBASE + 1] =
-				steps / 2;
-			this_usbduxfastsub->dux_commands[OPBASE + 1] = 0;
-			this_usbduxfastsub->dux_commands[OUTBASE + 1] =
-				0xFF & rngmask;
-			this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
-
-			// and the second part
-			this_usbduxfastsub->dux_commands[LENBASE + 2] =
-				steps - steps / 2;
-			this_usbduxfastsub->dux_commands[OPBASE + 2] = 0;
-			this_usbduxfastsub->dux_commands[OUTBASE + 2] =
-				0xFF & rngmask;
-			this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
-
-			// get the data and branch back
-			this_usbduxfastsub->dux_commands[LENBASE + 3] = 0x09;	// branch back to state 1
-			this_usbduxfastsub->dux_commands[OPBASE + 3] = 0x03;	// deceision state w data
-			this_usbduxfastsub->dux_commands[OUTBASE + 3] =
-				0xFF & rngmask;
-			this_usbduxfastsub->dux_commands[LOGBASE + 3] = 0xFF;	// doesn't matter
+			/* do the first part of the delay */
+			udfs->dux_commands[LENBASE+1] = steps / 2;
+			udfs->dux_commands[OPBASE+1] = 0;
+			udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE+1] = 0;
+
+			/* and the second part */
+			udfs->dux_commands[LENBASE+2] = steps - steps / 2;
+			udfs->dux_commands[OPBASE+2] = 0;
+			udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE+2] = 0;
+
+			/* get the data and branch back */
+
+			/* branch back to state 1 */
+			udfs->dux_commands[LENBASE+3] = 0x09;
+			/* deceision state w data */
+			udfs->dux_commands[OPBASE+3] = 0x03;
+			udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
+			/* doesn't matter */
+			udfs->dux_commands[LOGBASE+3] = 0xFF;
 		}
 		break;
 
 	case 2:
-		// two channels
-		// commit data to the FIFO
+		/*
+		 * two channels
+		 * commit data to the FIFO
+		 */
+
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
-		this_usbduxfastsub->dux_commands[LENBASE + 0] = 1;
-		this_usbduxfastsub->dux_commands[OPBASE + 0] = 0x02;	// data
-		this_usbduxfastsub->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
 
-		// we have 1 state with duration 1: state 0
+		udfs->dux_commands[LENBASE+0] = 1;
+		/* data */
+		udfs->dux_commands[OPBASE+0] = 0x02;
+		udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+0] = 0;
+
+		/* we have 1 state with duration 1: state 0 */
 		steps_tmp = steps - 1;
 
 		if (CR_RANGE(cmd->chanlist[1]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
-		// do the first part of the delay
-		this_usbduxfastsub->dux_commands[LENBASE + 1] = steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 1] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 1] = 0xFE & rngmask;	//count
-		this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
-
-		// and the second part
-		this_usbduxfastsub->dux_commands[LENBASE + 2] =
-			steps_tmp - steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 2] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 2] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
-
-		this_usbduxfastsub->dux_commands[LENBASE + 3] = 1;
-		this_usbduxfastsub->dux_commands[OPBASE + 3] = 0x02;	// data
-		this_usbduxfastsub->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 3] = 0;
 
-		// we have 2 states with duration 1: step 6 and the IDLE state
+		/* do the first part of the delay */
+		udfs->dux_commands[LENBASE+1] = steps_tmp / 2;
+		udfs->dux_commands[OPBASE+1] = 0;
+		/* count */
+		udfs->dux_commands[OUTBASE+1] = 0xFE & rngmask;
+		udfs->dux_commands[LOGBASE+1] = 0;
+
+		/* and the second part */
+		udfs->dux_commands[LENBASE+2] = steps_tmp - steps_tmp / 2;
+		udfs->dux_commands[OPBASE+2] = 0;
+		udfs->dux_commands[OUTBASE+2] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+2] = 0;
+
+		udfs->dux_commands[LENBASE+3] = 1;
+		/* data */
+		udfs->dux_commands[OPBASE+3] = 0x02;
+		udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+3] = 0;
+
+		/*
+		 * we have 2 states with duration 1: step 6 and
+		 * the IDLE state
+		 */
 		steps_tmp = steps - 2;
 
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
-		// do the first part of the delay
-		this_usbduxfastsub->dux_commands[LENBASE + 4] = steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 4] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 4] = (0xFF - 0x02) & rngmask;	//reset
-		this_usbduxfastsub->dux_commands[LOGBASE + 4] = 0;
-
-		// and the second part
-		this_usbduxfastsub->dux_commands[LENBASE + 5] =
-			steps_tmp - steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 5] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 5] = 0;
-
-		this_usbduxfastsub->dux_commands[LENBASE + 6] = 1;
-		this_usbduxfastsub->dux_commands[OPBASE + 6] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 6] = 0;
+
+		/* do the first part of the delay */
+		udfs->dux_commands[LENBASE+4] = steps_tmp / 2;
+		udfs->dux_commands[OPBASE+4] = 0;
+		/* reset */
+		udfs->dux_commands[OUTBASE+4] = (0xFF - 0x02) & rngmask;
+		udfs->dux_commands[LOGBASE+4] = 0;
+
+		/* and the second part */
+		udfs->dux_commands[LENBASE+5] = steps_tmp - steps_tmp / 2;
+		udfs->dux_commands[OPBASE+5] = 0;
+		udfs->dux_commands[OUTBASE+5] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+5] = 0;
+
+		udfs->dux_commands[LENBASE+6] = 1;
+		udfs->dux_commands[OPBASE+6] = 0;
+		udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+6] = 0;
 		break;
 
 	case 3:
-		// three channels
+		/*
+		 * three channels
+		 */
 		for (j = 0; j < 1; j++) {
 			if (CR_RANGE(cmd->chanlist[j]) > 0)
 				rngmask = 0xff - 0x04;
 			else
 				rngmask = 0xff;
-			// commit data to the FIFO and do the first part of the delay
-			this_usbduxfastsub->dux_commands[LENBASE + j * 2] =
-				steps / 2;
-			this_usbduxfastsub->dux_commands[OPBASE + j * 2] = 0x02;	// data
-			this_usbduxfastsub->dux_commands[OUTBASE + j * 2] = 0xFF & rngmask;	// no change
-			this_usbduxfastsub->dux_commands[LOGBASE + j * 2] = 0;
+			/*
+			 * commit data to the FIFO and do the first part
+			 * of the delay
+			 */
+			udfs->dux_commands[LENBASE+j*2] = steps / 2;
+			/* data */
+			udfs->dux_commands[OPBASE+j*2] = 0x02;
+			/* no change */
+			udfs->dux_commands[OUTBASE+j*2] = 0xFF & rngmask;
+			udfs->dux_commands[LOGBASE+j*2] = 0;
 
 			if (CR_RANGE(cmd->chanlist[j + 1]) > 0)
 				rngmask = 0xff - 0x04;
 			else
 				rngmask = 0xff;
-			// do the second part of the delay
-			this_usbduxfastsub->dux_commands[LENBASE + j * 2 + 1] =
-				steps - steps / 2;
-			this_usbduxfastsub->dux_commands[OPBASE + j * 2 + 1] = 0;	// no data
-			this_usbduxfastsub->dux_commands[OUTBASE + j * 2 + 1] = 0xFE & rngmask;	//count
-			this_usbduxfastsub->dux_commands[LOGBASE + j * 2 + 1] =
-				0;
+
+			/* do the second part of the delay */
+			udfs->dux_commands[LENBASE+j*2+1] = steps - steps / 2;
+			/* no data */
+			udfs->dux_commands[OPBASE+j*2+1] = 0;
+			/* count */
+			udfs->dux_commands[OUTBASE+j*2+1] = 0xFE & rngmask;
+			udfs->dux_commands[LOGBASE+j*2+1] = 0;
 		}
 
-		// 2 steps with duration 1: the idele step and step 6:
+		/* 2 steps with duration 1: the idele step and step 6: */
 		steps_tmp = steps - 2;
-		// commit data to the FIFO and do the first part of the delay
-		this_usbduxfastsub->dux_commands[LENBASE + 4] = steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 4] = 0x02;	// data
-		this_usbduxfastsub->dux_commands[OUTBASE + 4] = 0xFF & rngmask;	// no change
-		this_usbduxfastsub->dux_commands[LOGBASE + 4] = 0;
+
+		/* commit data to the FIFO and do the first part of the delay */
+		udfs->dux_commands[LENBASE+4] = steps_tmp / 2;
+		/* data */
+		udfs->dux_commands[OPBASE+4] = 0x02;
+		udfs->dux_commands[OUTBASE+4] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+4] = 0;
 
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
-		// do the second part of the delay
-		this_usbduxfastsub->dux_commands[LENBASE + 5] =
-			steps_tmp - steps_tmp / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 5] = 0;	// no data
-		this_usbduxfastsub->dux_commands[OUTBASE + 5] = (0xFF - 0x02) & rngmask;	// reset
-		this_usbduxfastsub->dux_commands[LOGBASE + 5] = 0;
-
-		this_usbduxfastsub->dux_commands[LENBASE + 6] = 1;
-		this_usbduxfastsub->dux_commands[OPBASE + 6] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 6] = 0;
+
+		/* do the second part of the delay */
+		udfs->dux_commands[LENBASE+5] = steps_tmp - steps_tmp / 2;
+		/* no data */
+		udfs->dux_commands[OPBASE+5] = 0;
+		/* reset */
+		udfs->dux_commands[OUTBASE+5] = (0xFF - 0x02) & rngmask;
+		udfs->dux_commands[LOGBASE+5] = 0;
+
+		udfs->dux_commands[LENBASE+6] = 1;
+		udfs->dux_commands[OPBASE+6] = 0;
+		udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+6] = 0;
 
 	case 16:
 		if (CR_RANGE(cmd->chanlist[0]) > 0)
 			rngmask = 0xff - 0x04;
 		else
 			rngmask = 0xff;
-		if (cmd->start_src == TRIG_EXT) {	// we loop here until ready has been set
-			this_usbduxfastsub->dux_commands[LENBASE + 0] = 0x01;	// branch back to state 0
-			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0x01;	// deceision state w/o data
-			this_usbduxfastsub->dux_commands[OUTBASE + 0] = (0xFF - 0x02) & rngmask;	// reset
-			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0x00;	// RDY0 = 0
-		} else {	// we just proceed to state 1
-			this_usbduxfastsub->dux_commands[LENBASE + 0] = 255;	// 30us reset pulse
-			this_usbduxfastsub->dux_commands[OPBASE + 0] = 0;
-			this_usbduxfastsub->dux_commands[OUTBASE + 0] = (0xFF - 0x02) & rngmask;	// reset
-			this_usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
-		}
-
-		// commit data to the FIFO
-		this_usbduxfastsub->dux_commands[LENBASE + 1] = 1;
-		this_usbduxfastsub->dux_commands[OPBASE + 1] = 0x02;	// data
-		this_usbduxfastsub->dux_commands[OUTBASE + 1] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
 
-		// we have 2 states with duration 1
+		if (cmd->start_src == TRIG_EXT) {
+			/*
+			 * we loop here until ready has been set
+			 */
+
+			/* branch back to state 0 */
+			udfs->dux_commands[LENBASE+0] = 0x01;
+			/* deceision state w/o data */
+			udfs->dux_commands[OPBASE+0] = 0x01;
+			/* reset */
+			udfs->dux_commands[OUTBASE+0] = (0xFF-0x02) & rngmask;
+			/* RDY0 = 0 */
+			udfs->dux_commands[LOGBASE+0] = 0x00;
+		} else {
+			/*
+			 * we just proceed to state 1
+			 */
+
+			/* 30us reset pulse */
+			udfs->dux_commands[LENBASE+0] = 255;
+			udfs->dux_commands[OPBASE+0] = 0;
+			/* reset */
+			udfs->dux_commands[OUTBASE+0] = (0xFF-0x02) & rngmask;
+			udfs->dux_commands[LOGBASE+0] = 0;
+		}
+
+		/* commit data to the FIFO */
+		udfs->dux_commands[LENBASE+1] = 1;
+		/* data */
+		udfs->dux_commands[OPBASE+1] = 0x02;
+		udfs->dux_commands[OUTBASE+1] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+1] = 0;
+
+		/* we have 2 states with duration 1 */
 		steps = steps - 2;
 
-		// do the first part of the delay
-		this_usbduxfastsub->dux_commands[LENBASE + 2] = steps / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 2] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
-
-		// and the second part
-		this_usbduxfastsub->dux_commands[LENBASE + 3] =
-			steps - steps / 2;
-		this_usbduxfastsub->dux_commands[OPBASE + 3] = 0;
-		this_usbduxfastsub->dux_commands[OUTBASE + 3] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 3] = 0;
-
-		this_usbduxfastsub->dux_commands[LENBASE + 4] = 0x09;	// branch back to state 1
-		this_usbduxfastsub->dux_commands[OPBASE + 4] = 0x01;	// deceision state w/o data
-		this_usbduxfastsub->dux_commands[OUTBASE + 4] = 0xFF & rngmask;
-		this_usbduxfastsub->dux_commands[LOGBASE + 4] = 0xFF;	// doesn't matter
+		/* do the first part of the delay */
+		udfs->dux_commands[LENBASE+2] = steps / 2;
+		udfs->dux_commands[OPBASE+2] = 0;
+		udfs->dux_commands[OUTBASE+2] = 0xFE & rngmask;
+		udfs->dux_commands[LOGBASE+2] = 0;
+
+		/* and the second part */
+		udfs->dux_commands[LENBASE+3] = steps - steps / 2;
+		udfs->dux_commands[OPBASE+3] = 0;
+		udfs->dux_commands[OUTBASE+3] = 0xFF & rngmask;
+		udfs->dux_commands[LOGBASE+3] = 0;
+
+		/* branch back to state 1 */
+		udfs->dux_commands[LENBASE+4] = 0x09;
+		/* deceision state w/o data */
+		udfs->dux_commands[OPBASE+4] = 0x01;
+		udfs->dux_commands[OUTBASE+4] = 0xFF & rngmask;
+		/* doesn't matter */
+		udfs->dux_commands[LOGBASE+4] = 0xFF;
 
 		break;
 
 	default:
-		printk("comedi %d: unsupported combination of channels\n",
-			dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi %d: unsupported combination of "
+		       "channels\n", dev->minor);
+		up(&udfs->sem);
 		return -EFAULT;
 	}
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi %d: sending commands to the usb device\n", dev->minor);
+	printk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",
+	       dev->minor);
 #endif
-	// 0 means that the AD commands are sent
-	result = send_dux_commands(this_usbduxfastsub, SENDADCOMMANDS);
+	/* 0 means that the AD commands are sent */
+	result = send_dux_commands(udfs, SENDADCOMMANDS);
 	if (result < 0) {
-		printk("comedi%d: adc command could not be submitted. Aborting...\n", dev->minor);
-		up(&this_usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: adc command could not be submitted."
+		       "Aborting...\n", dev->minor);
+		up(&udfs->sem);
 		return result;
 	}
 	if (cmd->stop_src == TRIG_COUNT) {
-		this_usbduxfastsub->ai_sample_count =
-			(cmd->stop_arg) * (cmd->scan_end_arg);
-		if (usbduxfastsub->ai_sample_count < 1) {
-			printk("comedi%d: (cmd->stop_arg)*(cmd->scan_end_arg)<1, aborting.\n", dev->minor);
-			up(&this_usbduxfastsub->sem);
+		udfs->ai_sample_count =	cmd->stop_arg * cmd->scan_end_arg;
+		if (udfs->ai_sample_count < 1) {
+			printk(KERN_ERR "comedi%d: "
+			       "(cmd->stop_arg)*(cmd->scan_end_arg)<1, "
+			       "aborting.\n", dev->minor);
+			up(&udfs->sem);
 			return -EFAULT;
 		}
-		this_usbduxfastsub->ai_continous = 0;
+		udfs->ai_continous = 0;
 	} else {
-		// continous aquisition
-		this_usbduxfastsub->ai_continous = 1;
-		this_usbduxfastsub->ai_sample_count = 0;
+		/* continous aquisition */
+		udfs->ai_continous = 1;
+		udfs->ai_sample_count = 0;
 	}
 
 	if ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {
-		// enable this acquisition operation
-		this_usbduxfastsub->ai_cmd_running = 1;
-		ret = usbduxfastsub_submit_InURBs(this_usbduxfastsub);
+		/* enable this acquisition operation */
+		udfs->ai_cmd_running = 1;
+		ret = usbduxfastsub_submit_InURBs(udfs);
 		if (ret < 0) {
-			this_usbduxfastsub->ai_cmd_running = 0;
-			// fixme: unlink here??
-			up(&this_usbduxfastsub->sem);
+			udfs->ai_cmd_running = 0;
+			/* fixme: unlink here?? */
+			up(&udfs->sem);
 			return ret;
 		}
 		s->async->inttrig = NULL;
 	} else {
-		/* TRIG_INT */
-		// don't enable the acquision operation
-		// wait for an internal signal
+		/*
+		 * TRIG_INT
+		 * don't enable the acquision operation
+		 * wait for an internal signal
+		 */
 		s->async->inttrig = usbduxfast_ai_inttrig;
 	}
-	up(&this_usbduxfastsub->sem);
+	up(&udfs->sem);
 
 	return 0;
 }
 
-/* Mode 0 is used to get a single conversion on demand */
-static int usbduxfast_ai_insn_read(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+/*
+ * Mode 0 is used to get a single conversion on demand.
+ */
+static int usbduxfast_ai_insn_read(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 	int i, j, n, actual_length;
 	int chan, range, rngmask;
 	int err;
-	usbduxfastsub_t *usbduxfastsub = dev->private;
+	struct usbduxfastsub_s *udfs;
 
-	if (!usbduxfastsub) {
-		printk("comedi%d: ai_insn_read: no usb dev.\n", dev->minor);
+	udfs = dev->private;
+	if (!udfs) {
+		printk(KERN_ERR "comedi%d: ai_insn_read: no usb dev.\n",
+		       dev->minor);
 		return -ENODEV;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: ai_insn_read, insn->n=%d, insn->subdev=%d\n",
-		dev->minor, insn->n, insn->subdev);
+	printk(KERN_DEBUG "comedi%d: ai_insn_read, insn->n=%d, "
+	       "insn->subdev=%d\n", dev->minor, insn->n, insn->subdev);
 #endif
-	down(&usbduxfastsub->sem);
-	if (!(usbduxfastsub->probed)) {
-		up(&usbduxfastsub->sem);
+	down(&udfs->sem);
+	if (!udfs->probed) {
+		up(&udfs->sem);
 		return -ENODEV;
 	}
-	if (usbduxfastsub->ai_cmd_running) {
-		printk("comedi%d: ai_insn_read not possible. Async Command is running.\n", dev->minor);
-		up(&usbduxfastsub->sem);
+	if (udfs->ai_cmd_running) {
+		printk(KERN_ERR "comedi%d: ai_insn_read not possible. Async "
+		       "Command is running.\n", dev->minor);
+		up(&udfs->sem);
 		return -EBUSY;
 	}
-	// sample one channel
+	/* sample one channel */
 	chan = CR_CHAN(insn->chanspec);
 	range = CR_RANGE(insn->chanspec);
-	// set command for the first channel
+	/* set command for the first channel */
 
 	if (range > 0)
 		rngmask = 0xff - 0x04;
 	else
 		rngmask = 0xff;
-	// commit data to the FIFO
-	usbduxfastsub->dux_commands[LENBASE + 0] = 1;
-	usbduxfastsub->dux_commands[OPBASE + 0] = 0x02;	// data
-	usbduxfastsub->dux_commands[OUTBASE + 0] = 0xFF & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
-
-	// do the first part of the delay
-	usbduxfastsub->dux_commands[LENBASE + 1] = 12;
-	usbduxfastsub->dux_commands[OPBASE + 1] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 1] = 0xFE & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 1] = 0;
-
-	usbduxfastsub->dux_commands[LENBASE + 2] = 1;
-	usbduxfastsub->dux_commands[OPBASE + 2] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 2] = 0xFE & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 2] = 0;
-
-	usbduxfastsub->dux_commands[LENBASE + 3] = 1;
-	usbduxfastsub->dux_commands[OPBASE + 3] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 3] = 0xFE & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 3] = 0;
-
-	usbduxfastsub->dux_commands[LENBASE + 4] = 1;
-	usbduxfastsub->dux_commands[OPBASE + 4] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 4] = 0xFE & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 4] = 0;
-
-	// second part
-	usbduxfastsub->dux_commands[LENBASE + 5] = 12;
-	usbduxfastsub->dux_commands[OPBASE + 5] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 5] = 0xFF & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 5] = 0;
-
-	usbduxfastsub->dux_commands[LENBASE + 6] = 1;
-	usbduxfastsub->dux_commands[OPBASE + 6] = 0;
-	usbduxfastsub->dux_commands[OUTBASE + 6] = 0xFF & rngmask;
-	usbduxfastsub->dux_commands[LOGBASE + 0] = 0;
+
+	/* commit data to the FIFO */
+	udfs->dux_commands[LENBASE+0] = 1;
+	/* data */
+	udfs->dux_commands[OPBASE+0] = 0x02;
+	udfs->dux_commands[OUTBASE+0] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE+0] = 0;
+
+	/* do the first part of the delay */
+	udfs->dux_commands[LENBASE+1] = 12;
+	udfs->dux_commands[OPBASE+1] = 0;
+	udfs->dux_commands[OUTBASE+1] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE+1] = 0;
+
+	udfs->dux_commands[LENBASE+2] = 1;
+	udfs->dux_commands[OPBASE+2] = 0;
+	udfs->dux_commands[OUTBASE+2] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE+2] = 0;
+
+	udfs->dux_commands[LENBASE+3] = 1;
+	udfs->dux_commands[OPBASE+3] = 0;
+	udfs->dux_commands[OUTBASE+3] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE+3] = 0;
+
+	udfs->dux_commands[LENBASE+4] = 1;
+	udfs->dux_commands[OPBASE+4] = 0;
+	udfs->dux_commands[OUTBASE+4] = 0xFE & rngmask;
+	udfs->dux_commands[LOGBASE+4] = 0;
+
+	/* second part */
+	udfs->dux_commands[LENBASE+5] = 12;
+	udfs->dux_commands[OPBASE+5] = 0;
+	udfs->dux_commands[OUTBASE+5] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE+5] = 0;
+
+	udfs->dux_commands[LENBASE+6] = 1;
+	udfs->dux_commands[OPBASE+6] = 0;
+	udfs->dux_commands[OUTBASE+6] = 0xFF & rngmask;
+	udfs->dux_commands[LOGBASE+0] = 0;
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi %d: sending commands to the usb device\n", dev->minor);
+	printk(KERN_DEBUG "comedi %d: sending commands to the usb device\n",
+	       dev->minor);
 #endif
-	// 0 means that the AD commands are sent
-	err = send_dux_commands(usbduxfastsub, SENDADCOMMANDS);
+	/* 0 means that the AD commands are sent */
+	err = send_dux_commands(udfs, SENDADCOMMANDS);
 	if (err < 0) {
-		printk("comedi%d: adc command could not be submitted. Aborting...\n", dev->minor);
-		up(&usbduxfastsub->sem);
+		printk(KERN_ERR "comedi%d: adc command could not be submitted."
+		       "Aborting...\n", dev->minor);
+		up(&udfs->sem);
 		return err;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: submitting in-urb: 0x%p,0x%p\n",
-		usbduxfastsub->comedidev->minor,
-		usbduxfastsub->urbIn->context,
-		usbduxfastsub->urbIn->dev);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: submitting in-urb: "
+	       "0x%p,0x%p\n", udfs->comedidev->minor, udfs->urbIn->context,
+	       udfs->urbIn->dev);
 #endif
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
-		err = usb_bulk_msg(usbduxfastsub->usbdev,
-				   usb_rcvbulkpipe(usbduxfastsub->usbdev,
-						   BULKINEP),
-				   usbduxfastsub->transfer_buffer, SIZEINBUF,
+		err = usb_bulk_msg(udfs->usbdev,
+				   usb_rcvbulkpipe(udfs->usbdev, BULKINEP),
+				   udfs->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
-			printk("comedi%d: insn timeout. No data.\n",
+			printk(KERN_ERR "comedi%d: insn timeout. No data.\n",
 				dev->minor);
-			up(&usbduxfastsub->sem);
+			up(&udfs->sem);
 			return err;
 		}
 	}
-	// data points
+	/* data points */
 	for (i = 0; i < insn->n;) {
-		err = usb_bulk_msg(usbduxfastsub->usbdev,
-				   usb_rcvbulkpipe(usbduxfastsub->usbdev,
-						   BULKINEP),
-				   usbduxfastsub->transfer_buffer, SIZEINBUF,
+		err = usb_bulk_msg(udfs->usbdev,
+				   usb_rcvbulkpipe(udfs->usbdev, BULKINEP),
+				   udfs->transfer_buffer, SIZEINBUF,
 				   &actual_length, 10000);
 		if (err < 0) {
-			printk("comedi%d: insn data error: %d\n",
+			printk(KERN_ERR "comedi%d: insn data error: %d\n",
 				dev->minor, err);
-			up(&usbduxfastsub->sem);
+			up(&udfs->sem);
 			return err;
 		}
 		n = actual_length / sizeof(uint16_t);
 		if ((n % 16) != 0) {
-			printk("comedi%d: insn data packet corrupted.\n",
-				dev->minor);
-			up(&usbduxfastsub->sem);
+			printk(KERN_ERR "comedi%d: insn data packet "
+			       "corrupted.\n", dev->minor);
+			up(&udfs->sem);
 			return -EINVAL;
 		}
 		for (j = chan; (j < n) && (i < insn->n); j = j + 16) {
-			data[i] =
-				((uint16_t *) (usbduxfastsub->
-					transfer_buffer))[j];
+			data[i] = ((uint16_t *) (udfs->transfer_buffer))[j];
 			i++;
 		}
 	}
-	up(&usbduxfastsub->sem);
+	up(&udfs->sem);
 	return i;
 }
 
 static unsigned hex2unsigned(char *h)
 {
 	unsigned hi, lo;
-	if (h[0] > '9') {
+
+	if (h[0] > '9')
 		hi = h[0] - 'A' + 0x0a;
-	} else {
+	else
 		hi = h[0] - '0';
-	}
-	if (h[1] > '9') {
+
+	if (h[1] > '9')
 		lo = h[1] - 'A' + 0x0a;
-	} else {
+	else
 		lo = h[1] - '0';
-	}
+
 	return hi * 0x10 + lo;
 }
 
-// for FX2
+/* for FX2 */
 #define FIRMWARE_MAX_LEN 0x2000
 
-// taken from David Brownell's fxload and adjusted for this driver
-static int read_firmware(usbduxfastsub_t * usbduxfastsub, void *firmwarePtr,
+/*
+ * taken from David Brownell's fxload and adjusted for this driver
+ */
+static int read_firmware(struct usbduxfastsub_s *udfs, void *firmwarePtr,
 	long size)
 {
 	int i = 0;
@@ -1289,7 +1407,8 @@ static int read_firmware(usbduxfastsub_t
 
 	firmwareBinary = kmalloc(FIRMWARE_MAX_LEN, GFP_KERNEL);
 	if (!firmwareBinary) {
-		printk("comedi_: usbduxfast: mem alloc for firmware failed\n");
+		printk(KERN_ERR "comedi_: usbduxfast: mem alloc for firmware "
+		       " failed\n");
 		return -ENOMEM;
 	}
 
@@ -1300,32 +1419,36 @@ static int read_firmware(usbduxfastsub_t
 		int idx, off;
 		int j = 0;
 
-		// get one line
+		/* get one line */
 		while ((i < size) && (fp[i] != 13) && (fp[i] != 10)) {
 			buf[j] = fp[i];
 			i++;
 			j++;
 			if (j >= sizeof(buf)) {
-				printk("comedi_: usbduxfast: bogus firmware file!\n");
+				printk(KERN_ERR "comedi_: usbduxfast: bogus "
+				       "firmware file!\n");
 				kfree(firmwareBinary);
 				return -1;
 			}
 		}
-		// get rid of LF/CR/...
+		/* get rid of LF/CR/... */
 		while ((i < size) && ((fp[i] == 13) || (fp[i] == 10)
-				|| (fp[i] == 0))) {
+					|| (fp[i] == 0)))
 			i++;
-		}
 
 		buf[j] = 0;
-		//printk("comedi_: buf=%s\n",buf);
+		/* printk("comedi_: buf=%s\n",buf); */
 
-		/* EXTENSION: "# comment-till-end-of-line", for copyrights etc */
+		/*
+		 * EXTENSION: "# comment-till-end-of-line",
+		 * for copyrights etc
+		 */
 		if (buf[0] == '#')
 			continue;
 
 		if (buf[0] != ':') {
-			printk("comedi_: usbduxfast: upload: not an ihex record: %s", buf);
+			printk(KERN_ERR "comedi_: usbduxfast: upload: not an "
+			       "ihex record: %s", buf);
 			kfree(firmwareBinary);
 			return -EFAULT;
 		}
@@ -1336,86 +1459,88 @@ static int read_firmware(usbduxfastsub_t
 		/* Read the target offset */
 		off = (hex2unsigned(buf + 3) * 0x0100) + hex2unsigned(buf + 5);
 
-		if ((off + len) > maxAddr) {
+		if ((off + len) > maxAddr)
 			maxAddr = off + len;
-		}
 
 		if (maxAddr >= FIRMWARE_MAX_LEN) {
-			printk("comedi_: usbduxfast: firmware upload goes beyond FX2 RAM boundaries.");
+			printk(KERN_ERR "comedi_: usbduxfast: firmware upload "
+			       "goes beyond FX2 RAM boundaries.");
 			kfree(firmwareBinary);
 			return -EFAULT;
 		}
-		//printk("comedi_: usbduxfast: off=%x, len=%x:",off,len);
+		/* printk("comedi_: usbduxfast: off=%x, len=%x:",off,len); */
 
 		/* Read the record type */
 		type = hex2unsigned(buf + 7);
 
 		/* If this is an EOF record, then make it so. */
-		if (type == 1) {
+		if (type == 1)
 			break;
-		}
 
 		if (type != 0) {
-			printk("comedi_: usbduxfast: unsupported record type: %u\n", type);
+			printk(KERN_ERR "comedi_: usbduxfast: unsupported "
+			       "record type: %u\n", type);
 			kfree(firmwareBinary);
 			return -EFAULT;
 		}
 
 		for (idx = 0, cp = buf + 9; idx < len; idx += 1, cp += 2) {
 			firmwareBinary[idx + off] = hex2unsigned(cp);
-			//printk("%02x ",firmwareBinary[idx+off]);
+			/* printk("%02x ",firmwareBinary[idx+off]); */
 		}
-		//printk("\n");
+
+		/* printk("\n"); */
 
 		if (i >= size) {
-			printk("comedi_: usbduxfast: unexpected end of hex file\n");
+			printk(KERN_ERR "comedi_: usbduxfast: unexpected end "
+			       "of hex file\n");
 			break;
 		}
 
 	}
-	res = firmwareUpload(usbduxfastsub, firmwareBinary, maxAddr + 1);
+	res = firmwareUpload(udfs, firmwareBinary, maxAddr + 1);
 	kfree(firmwareBinary);
 	return res;
 }
 
-static void tidy_up(usbduxfastsub_t * usbduxfastsub_tmp)
+static void tidy_up(struct usbduxfastsub_s *udfs)
 {
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast: tiding up\n");
+	printk(KERN_DEBUG "comedi_: usbduxfast: tiding up\n");
 #endif
-	if (!usbduxfastsub_tmp) {
+
+	if (!udfs)
 		return;
-	}
 
-	// shows the usb subsystem that the driver is down
-	if (usbduxfastsub_tmp->interface) {
-		usb_set_intfdata(usbduxfastsub_tmp->interface, NULL);
-	}
+	/* shows the usb subsystem that the driver is down */
+	if (udfs->interface)
+		usb_set_intfdata(udfs->interface, NULL);
 
-	usbduxfastsub_tmp->probed = 0;
+	udfs->probed = 0;
 
-	if (usbduxfastsub_tmp->urbIn) {
-		// waits until a running transfer is over
-		usb_kill_urb(usbduxfastsub_tmp->urbIn);
-		if (usbduxfastsub_tmp->transfer_buffer) {
-			kfree(usbduxfastsub_tmp->transfer_buffer);
-			usbduxfastsub_tmp->transfer_buffer = NULL;
-		}
-		usb_free_urb(usbduxfastsub_tmp->urbIn);
-		usbduxfastsub_tmp->urbIn = NULL;
-	}
-	if (usbduxfastsub_tmp->insnBuffer) {
-		kfree(usbduxfastsub_tmp->insnBuffer);
-		usbduxfastsub_tmp->insnBuffer = NULL;
-	}
-	if (usbduxfastsub_tmp->dux_commands) {
-		kfree(usbduxfastsub_tmp->dux_commands);
-		usbduxfastsub_tmp->dux_commands = NULL;
+	if (udfs->urbIn) {
+		/* waits until a running transfer is over */
+		usb_kill_urb(udfs->urbIn);
+
+		kfree(udfs->transfer_buffer);
+		udfs->transfer_buffer = NULL;
+
+		usb_free_urb(udfs->urbIn);
+		udfs->urbIn = NULL;
 	}
-	usbduxfastsub_tmp->ai_cmd_running = 0;
+
+	kfree(udfs->insnBuffer);
+	udfs->insnBuffer = NULL;
+
+	kfree(udfs->dux_commands);
+	udfs->dux_commands = NULL;
+
+	udfs->ai_cmd_running = 0;
 }
 
-// allocate memory for the urbs and initialise them
+/*
+ * allocate memory for the urbs and initialise them
+ */
 static int usbduxfastsub_probe(struct usb_interface *uinterf,
 	const struct usb_device_id *id)
 {
@@ -1424,122 +1549,137 @@ static int usbduxfastsub_probe(struct us
 	int index;
 
 	if (udev->speed != USB_SPEED_HIGH) {
-		printk("comedi_: usbduxfast_: This driver needs USB 2.0 to operate. Aborting...\n");
+		printk(KERN_ERR "comedi_: usbduxfast_: This driver needs"
+		       "USB 2.0 to operate. Aborting...\n");
 		return -ENODEV;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast_: finding a free structure for the usb-device\n");
+	printk(KERN_DEBUG "comedi_: usbduxfast_: finding a free structure for "
+	       "the usb-device\n");
 #endif
 	down(&start_stop_sem);
-	// look for a free place in the usbduxfast array
+	/* look for a free place in the usbduxfast array */
 	index = -1;
 	for (i = 0; i < NUMUSBDUXFAST; i++) {
-		if (!(usbduxfastsub[i].probed)) {
+		if (!usbduxfastsub[i].probed) {
 			index = i;
 			break;
 		}
 	}
 
-	// no more space
+	/* no more space */
 	if (index == -1) {
-		printk("Too many usbduxfast-devices connected.\n");
+		printk(KERN_ERR "Too many usbduxfast-devices connected.\n");
 		up(&start_stop_sem);
 		return -EMFILE;
 	}
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast: usbduxfastsub[%d] is ready to connect to comedi.\n", index);
+	printk(KERN_DEBUG "comedi_: usbduxfast: usbduxfastsub[%d] is ready to "
+	       "connect to comedi.\n", index);
 #endif
 
 	init_MUTEX(&(usbduxfastsub[index].sem));
-	// save a pointer to the usb device
+	/* save a pointer to the usb device */
 	usbduxfastsub[index].usbdev = udev;
 
-	// save the interface itself
+	/* save the interface itself */
 	usbduxfastsub[index].interface = uinterf;
-	// get the interface number from the interface
+	/* get the interface number from the interface */
 	usbduxfastsub[index].ifnum = uinterf->altsetting->desc.bInterfaceNumber;
-	// hand the private data over to the usb subsystem
-	// will be needed for disconnect
+	/*
+	 * hand the private data over to the usb subsystem
+	 * will be needed for disconnect
+	 */
 	usb_set_intfdata(uinterf, &(usbduxfastsub[index]));
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast: ifnum=%d\n", usbduxfastsub[index].ifnum);
+	printk(KERN_DEBUG "comedi_: usbduxfast: ifnum=%d\n",
+	       usbduxfastsub[index].ifnum);
 #endif
-	// create space for the commands going to the usb device
+	/* create space for the commands going to the usb device */
 	usbduxfastsub[index].dux_commands = kmalloc(SIZEOFDUXBUFFER,
-		GFP_KERNEL);
+						    GFP_KERNEL);
 	if (!usbduxfastsub[index].dux_commands) {
-		printk("comedi_: usbduxfast: error alloc space for dac commands\n");
+		printk(KERN_ERR "comedi_: usbduxfast: error alloc space for "
+		       "dac commands\n");
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	// create space of the instruction buffer
+	/* create space of the instruction buffer */
 	usbduxfastsub[index].insnBuffer = kmalloc(SIZEINSNBUF, GFP_KERNEL);
-	if (!(usbduxfastsub[index].insnBuffer)) {
-		printk("comedi_: usbduxfast: could not alloc space for insnBuffer\n");
+	if (!usbduxfastsub[index].insnBuffer) {
+		printk(KERN_ERR "comedi_: usbduxfast: could not alloc space "
+		       "for insnBuffer\n");
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	// setting to alternate setting 1: enabling bulk ep
+	/* setting to alternate setting 1: enabling bulk ep */
 	i = usb_set_interface(usbduxfastsub[index].usbdev,
 		usbduxfastsub[index].ifnum, 1);
 	if (i < 0) {
-		printk("comedi_: usbduxfast%d: could not switch to alternate setting 1.\n", index);
+		printk(KERN_ERR "comedi_: usbduxfast%d: could not switch to "
+		       "alternate setting 1.\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENODEV;
 	}
 	usbduxfastsub[index].urbIn = usb_alloc_urb(0, GFP_KERNEL);
-	if (usbduxfastsub[index].urbIn == NULL) {
-		printk("comedi_: usbduxfast%d: Could not alloc. urb\n", index);
+	if (!usbduxfastsub[index].urbIn) {
+		printk(KERN_ERR "comedi_: usbduxfast%d: Could not alloc."
+		       "urb\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
 	usbduxfastsub[index].transfer_buffer = kmalloc(SIZEINBUF, GFP_KERNEL);
-	if (!(usbduxfastsub[index].transfer_buffer)) {
-		printk("comedi_: usbduxfast%d: could not alloc. transb.\n",
-			index);
+	if (!usbduxfastsub[index].transfer_buffer) {
+		printk(KERN_ERR "comedi_: usbduxfast%d: could not alloc. "
+		       "transb.\n", index);
 		tidy_up(&(usbduxfastsub[index]));
 		up(&start_stop_sem);
 		return -ENOMEM;
 	}
-	// we've reached the bottom of the function
+	/* we've reached the bottom of the function */
 	usbduxfastsub[index].probed = 1;
 	up(&start_stop_sem);
-	printk("comedi_: usbduxfast%d has been successfully initialized.\n",
-		index);
-	// success
+	printk(KERN_INFO "comedi_: usbduxfast%d has been successfully "
+	       "initialized.\n", index);
+	/* success */
 	return 0;
 }
 
 static void usbduxfastsub_disconnect(struct usb_interface *intf)
 {
-	usbduxfastsub_t *usbduxfastsub_tmp = usb_get_intfdata(intf);
+	struct usbduxfastsub_s *udfs = usb_get_intfdata(intf);
 	struct usb_device *udev = interface_to_usbdev(intf);
 
-	if (!usbduxfastsub_tmp) {
-		printk("comedi_: usbduxfast: disconnect called with null pointer.\n");
+	if (!udfs) {
+		printk(KERN_ERR "comedi_: usbduxfast: disconnect called with "
+		       "null pointer.\n");
 		return;
 	}
-	if (usbduxfastsub_tmp->usbdev != udev) {
-		printk("comedi_: usbduxfast: BUG! called with wrong ptr!!!\n");
+	if (udfs->usbdev != udev) {
+		printk(KERN_ERR "comedi_: usbduxfast: BUG! called with wrong "
+		       "ptr!!!\n");
 		return;
 	}
 	down(&start_stop_sem);
-	down(&usbduxfastsub_tmp->sem);
-	tidy_up(usbduxfastsub_tmp);
-	up(&usbduxfastsub_tmp->sem);
+	down(&udfs->sem);
+	tidy_up(udfs);
+	up(&udfs->sem);
 	up(&start_stop_sem);
+
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast: disconnected from the usb\n");
+	printk(KERN_DEBUG "comedi_: usbduxfast: disconnected from the usb\n");
 #endif
 }
 
-// is called when comedi-config is called
-static int usbduxfast_attach(comedi_device * dev, comedi_devconfig * it)
+/*
+ * is called when comedi-config is called
+ */
+static int usbduxfast_attach(comedi_device *dev, comedi_devconfig *it)
 {
 	int ret;
 	int index;
@@ -1548,26 +1688,31 @@ static int usbduxfast_attach(comedi_devi
 	dev->private = NULL;
 
 	down(&start_stop_sem);
-	// find a valid device which has been detected by the probe function of the usb
+	/*
+	 * find a valid device which has been detected by the
+	 * probe function of the usb
+	 */
 	index = -1;
 	for (i = 0; i < NUMUSBDUXFAST; i++) {
-		if ((usbduxfastsub[i].probed) && (!usbduxfastsub[i].attached)) {
+		if (usbduxfastsub[i].probed && !usbduxfastsub[i].attached) {
 			index = i;
 			break;
 		}
 	}
 
 	if (index < 0) {
-		printk("comedi%d: usbduxfast: error: attach failed, no usbduxfast devs connected to the usb bus.\n", dev->minor);
+		printk(KERN_ERR "comedi%d: usbduxfast: error: attach failed, "
+		       "no usbduxfast devs connected to the usb bus.\n",
+		       dev->minor);
 		up(&start_stop_sem);
 		return -ENODEV;
 	}
 
 	down(&(usbduxfastsub[index].sem));
-	// pointer back to the corresponding comedi device
+	/* pointer back to the corresponding comedi device */
 	usbduxfastsub[index].comedidev = dev;
 
-	// trying to upload the firmware into the chip
+	/* trying to upload the firmware into the chip */
 	if (comedi_aux_data(it->options, 0) &&
 		it->options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {
 		read_firmware(usbduxfastsub,
@@ -1580,109 +1725,120 @@ static int usbduxfast_attach(comedi_devi
 	/* set number of subdevices */
 	dev->n_subdevices = N_SUBDEVICES;
 
-	// allocate space for the subdevices
-	if ((ret = alloc_subdevices(dev, N_SUBDEVICES)) < 0) {
-		printk("comedi%d: usbduxfast: error alloc space for subdev\n",
-			dev->minor);
+	/* allocate space for the subdevices */
+	ret = alloc_subdevices(dev, N_SUBDEVICES);
+	if (ret < 0) {
+		printk(KERN_ERR "comedi%d: usbduxfast: error alloc space for "
+		       "subdev\n", dev->minor);
 		up(&start_stop_sem);
 		return ret;
 	}
 
-	printk("comedi%d: usbduxfast: usb-device %d is attached to comedi.\n",
-		dev->minor, index);
-	// private structure is also simply the usb-structure
+	printk(KERN_INFO "comedi%d: usbduxfast: usb-device %d is attached to "
+	       "comedi.\n", dev->minor, index);
+	/* private structure is also simply the usb-structure */
 	dev->private = usbduxfastsub + index;
-	// the first subdevice is the A/D converter
+	/* the first subdevice is the A/D converter */
 	s = dev->subdevices + SUBDEV_AD;
-	// the URBs get the comedi subdevice
-	// which is responsible for reading
-	// this is the subdevice which reads data
+	/*
+	 * the URBs get the comedi subdevice which is responsible for reading
+	 * this is the subdevice which reads data
+	 */
 	dev->read_subdev = s;
-	// the subdevice receives as private structure the
-	// usb-structure
+	/* the subdevice receives as private structure the usb-structure */
 	s->private = NULL;
-	// analog input
+	/* analog input */
 	s->type = COMEDI_SUBD_AI;
-	// readable and ref is to ground
+	/* readable and ref is to ground */
 	s->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;
-	// 16 channels
+	/* 16 channels */
 	s->n_chan = 16;
-	// length of the channellist
+	/* length of the channellist */
 	s->len_chanlist = 16;
-	// callback functions
+	/* callback functions */
 	s->insn_read = usbduxfast_ai_insn_read;
 	s->do_cmdtest = usbduxfast_ai_cmdtest;
 	s->do_cmd = usbduxfast_ai_cmd;
 	s->cancel = usbduxfast_ai_cancel;
-	// max value from the A/D converter (12bit+1 bit for overflow)
+	/* max value from the A/D converter (12bit+1 bit for overflow) */
 	s->maxdata = 0x1000;
-	// range table to convert to physical units
+	/* range table to convert to physical units */
 	s->range_table = &range_usbduxfast_ai_range;
 
-	// finally decide that it's attached
+	/* finally decide that it's attached */
 	usbduxfastsub[index].attached = 1;
 
 	up(&(usbduxfastsub[index].sem));
-
 	up(&start_stop_sem);
-
-	printk("comedi%d: successfully attached to usbduxfast.\n", dev->minor);
+	printk(KERN_INFO "comedi%d: successfully attached to usbduxfast.\n",
+	       dev->minor);
 
 	return 0;
 }
 
-static int usbduxfast_detach(comedi_device * dev)
+static int usbduxfast_detach(comedi_device *dev)
 {
-	usbduxfastsub_t *usbduxfastsub_tmp;
+	struct usbduxfastsub_s *udfs;
 
 	if (!dev) {
-		printk("comedi?: usbduxfast: detach without dev variable...\n");
+		printk(KERN_ERR "comedi?: usbduxfast: detach without dev "
+		       "variable...\n");
 		return -EFAULT;
 	}
 
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: detach usb device\n", dev->minor);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: detach usb device\n",
+	       dev->minor);
 #endif
 
-	usbduxfastsub_tmp = dev->private;
-	if (!usbduxfastsub_tmp) {
-		printk("comedi?: usbduxfast: detach without ptr to usbduxfastsub[]\n");
+	udfs = dev->private;
+	if (!udfs) {
+		printk(KERN_ERR "comedi?: usbduxfast: detach without ptr to "
+		       "usbduxfastsub[]\n");
 		return -EFAULT;
 	}
 
-	down(&usbduxfastsub_tmp->sem);
+	down(&udfs->sem);
 	down(&start_stop_sem);
-	// Don't allow detach to free the private structure
-	// It's one entry of of usbduxfastsub[]
+	/*
+	 * Don't allow detach to free the private structure
+	 * It's one entry of of usbduxfastsub[]
+	 */
 	dev->private = NULL;
-	usbduxfastsub_tmp->attached = 0;
-	usbduxfastsub_tmp->comedidev = NULL;
+	udfs->attached = 0;
+	udfs->comedidev = NULL;
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi%d: usbduxfast: detach: successfully removed\n",
-		dev->minor);
+	printk(KERN_DEBUG "comedi%d: usbduxfast: detach: successfully "
+	       "removed\n", dev->minor);
 #endif
 	up(&start_stop_sem);
-	up(&usbduxfastsub_tmp->sem);
+	up(&udfs->sem);
 	return 0;
 }
 
-/* main driver struct */
+/*
+ * main driver struct
+ */
 static comedi_driver driver_usbduxfast = {
-      driver_name:"usbduxfast",
-      module:THIS_MODULE,
-      attach:usbduxfast_attach,
-      detach:usbduxfast_detach,
+	.driver_name	= "usbduxfast",
+	.module		= THIS_MODULE,
+	.attach		= usbduxfast_attach,
+	.detach		= usbduxfast_detach
 };
 
 static void init_usb_devices(void)
 {
 	int index;
+
 #ifdef CONFIG_COMEDI_DEBUG
-	printk("comedi_: usbduxfast: setting all possible devs to invalid\n");
+	printk(KERN_DEBUG "comedi_: usbduxfast: setting all possible devs to "
+	       "invalid\n");
 #endif
-	// all devices entries are invalid to begin with
-	// they will become valid by the probe function
-	// and then finally by the attach-function
+	/*
+	 * all devices entries are invalid to begin with
+	 * they will become valid by the probe function
+	 * and then finally by the attach-function
+	 */
 	for (index = 0; index < NUMUSBDUXFAST; index++) {
 		memset(&(usbduxfastsub[index]), 0x00,
 			sizeof(usbduxfastsub[index]));
@@ -1690,44 +1846,48 @@ static void init_usb_devices(void)
 	}
 }
 
-// Table with the USB-devices: just now only testing IDs
+/*
+ * Table with the USB-devices: just now only testing IDs
+ */
 static struct usb_device_id usbduxfastsub_table[] = {
-	//        { USB_DEVICE(0x4b4, 0x8613), //testing
-	//        },
-	{USB_DEVICE(0x13d8, 0x0010)	//real ID
-		},
-	{USB_DEVICE(0x13d8, 0x0011)	//real ID
-		},
-	{}			/* Terminating entry */
+	/* { USB_DEVICE(0x4b4, 0x8613) }, testing */
+	{ USB_DEVICE(0x13d8, 0x0010) },	/* real ID */
+	{ USB_DEVICE(0x13d8, 0x0011) },	/* real ID */
+	{ }			/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE(usb, usbduxfastsub_table);
 
-// The usbduxfastsub-driver
+/*
+ * The usbduxfastsub-driver
+ */
 static struct usb_driver usbduxfastsub_driver = {
 #ifdef COMEDI_HAVE_USB_DRIVER_OWNER
-      owner:THIS_MODULE,
+	.owner		= THIS_MODULE,
 #endif
-      name:BOARDNAME,
-      probe:usbduxfastsub_probe,
-      disconnect:usbduxfastsub_disconnect,
-      id_table:usbduxfastsub_table,
+	.name		= BOARDNAME,
+	.probe		= usbduxfastsub_probe,
+	.disconnect	= usbduxfastsub_disconnect,
+	.id_table	= usbduxfastsub_table
 };
 
-// Can't use the nice macro as I have also to initialise the USB
-// subsystem:
-// registering the usb-system _and_ the comedi-driver
+/*
+ * Can't use the nice macro as I have also to initialise the USB subsystem:
+ * registering the usb-system _and_ the comedi-driver
+ */
 static int init_usbduxfast(void)
 {
-	printk(KERN_INFO KBUILD_MODNAME ": "
-	       DRIVER_VERSION ":" DRIVER_DESC "\n");
+	printk(KERN_INFO
+	       KBUILD_MODNAME ": " DRIVER_VERSION ":" DRIVER_DESC "\n");
 	init_usb_devices();
 	usb_register(&usbduxfastsub_driver);
 	comedi_driver_register(&driver_usbduxfast);
 	return 0;
 }
 
-// deregistering the comedi driver and the usb-subsystem
+/*
+ * deregistering the comedi driver and the usb-subsystem
+ */
 static void exit_usbduxfast(void)
 {
 	comedi_driver_unregister(&driver_usbduxfast);
