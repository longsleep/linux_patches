From 5f884cd952a600233ac4c37917c9a8c6d201f97f Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Fri, 27 Feb 2009 22:39:22 -0800
Subject: Staging: line6: fix checkpatch errors in capture.c

2 errors left, but they are minor.
Lots of warnings also fixed up.

Cc: Markus Grabner <grabner@icg.tugraz.at>
Cc: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/line6/capture.c |   94 ++++++++++++++++++++--------------------
 1 file changed, 49 insertions(+), 45 deletions(-)

--- a/drivers/staging/line6/capture.c
+++ b/drivers/staging/line6/capture.c
@@ -35,7 +35,7 @@ static int submit_audio_in_urb(struct sn
 	spin_lock_irqsave(&line6pcm->lock_audio_in, flags);
 	index = find_first_zero_bit(&line6pcm->active_urb_in, LINE6_ISO_BUFFERS);
 
-	if(index < 0 || index >= LINE6_ISO_BUFFERS) {
+	if (index < 0 || index >= LINE6_ISO_BUFFERS) {
 		spin_unlock_irqrestore(&line6pcm->lock_audio_in, flags);
 		dev_err(s2m(substream), "no free URB found\n");
 		return -EINVAL;
@@ -44,7 +44,7 @@ static int submit_audio_in_urb(struct sn
 	urb_in = line6pcm->urb_audio_in[index];
 	urb_size = 0;
 
-	for(i = 0; i < LINE6_ISO_PACKETS; ++i) {
+	for (i = 0; i < LINE6_ISO_PACKETS; ++i) {
 		struct usb_iso_packet_descriptor *fin = &urb_in->iso_frame_desc[i];
 		fin->offset = urb_size;
 		fin->length = line6pcm->max_packet_size;
@@ -55,7 +55,7 @@ static int submit_audio_in_urb(struct sn
 	urb_in->transfer_buffer_length = urb_size;
 	urb_in->context = substream;
 
-	if(usb_submit_urb(urb_in, GFP_ATOMIC) == 0)
+	if (usb_submit_urb(urb_in, GFP_ATOMIC) == 0)
 		set_bit(index, &line6pcm->active_urb_in);
 	else
 		dev_err(s2m(substream), "URB in #%d submission failed\n", index);
@@ -71,9 +71,11 @@ static int submit_audio_in_all_urbs(stru
 {
 	int ret, i;
 
-	for(i = 0; i < LINE6_ISO_BUFFERS; ++i)
-		if((ret = submit_audio_in_urb(substream)) < 0)
+	for (i = 0; i < LINE6_ISO_BUFFERS; ++i) {
+		ret = submit_audio_in_urb(substream);
+		if (ret < 0)
 			return ret;
+	}
 
 	return 0;
 }
@@ -85,9 +87,9 @@ static void unlink_audio_in_urbs(struct 
 {
 	unsigned int i;
 
-	for(i = LINE6_ISO_BUFFERS; i--;) {
-		if(test_bit(i, &line6pcm->active_urb_in)) {
-			if(!test_and_set_bit(i, &line6pcm->unlink_urb_in)) {
+	for (i = LINE6_ISO_BUFFERS; i--;) {
+		if (test_bit(i, &line6pcm->active_urb_in)) {
+			if (!test_and_set_bit(i, &line6pcm->unlink_urb_in)) {
 				struct urb *u = line6pcm->urb_audio_in[i];
 				usb_unlink_urb(u);
 			}
@@ -96,7 +98,8 @@ static void unlink_audio_in_urbs(struct 
 }
 
 /*
-	Wait until unlinking of all currently active capture URBs has been finished.
+	Wait until unlinking of all currently active capture URBs has been
+	finished.
 */
 static void wait_clear_audio_in_urbs(struct snd_line6_pcm *line6pcm)
 {
@@ -110,7 +113,7 @@ static void wait_clear_audio_in_urbs(str
 			if (test_bit(i, &line6pcm->active_urb_in))
 				alive++;
 		}
-		if (! alive)
+		if (!alive)
 			break;
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(1);
@@ -146,12 +149,12 @@ static void audio_in_callback(struct urb
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	/* find index of URB */
-	for(index = 0; index < LINE6_ISO_BUFFERS; ++index)
-		if(urb == line6pcm->urb_audio_in[index])
+	for (index = 0; index < LINE6_ISO_BUFFERS; ++index)
+		if (urb == line6pcm->urb_audio_in[index])
 			break;
 
 #if DO_DUMP_PCM_RECEIVE
-	for(i = 0; i < LINE6_ISO_PACKETS; ++i) {
+	for (i = 0; i < LINE6_ISO_PACKETS; ++i) {
 		struct usb_iso_packet_descriptor *fout = &urb->iso_frame_desc[i];
 		line6_write_hexdump(line6pcm->line6, 'C', urb->transfer_buffer + fout->offset, fout->length);
 	}
@@ -159,12 +162,12 @@ static void audio_in_callback(struct urb
 
 	spin_lock_irqsave(&line6pcm->lock_audio_in, flags);
 
-	for(i = 0; i < LINE6_ISO_PACKETS; ++i) {
+	for (i = 0; i < LINE6_ISO_PACKETS; ++i) {
 		char *fbuf;
 		int fsize;
 		struct usb_iso_packet_descriptor *fin = &urb->iso_frame_desc[i];
 
-		if(fin->status == -18) {
+		if (fin->status == -18) {
 			shutdown = 1;
 			break;
 		}
@@ -173,10 +176,10 @@ static void audio_in_callback(struct urb
 		fsize = fin->actual_length;
 		length += fsize;
 
-		if(fsize > 0) {
+		if (fsize > 0) {
 			frames = fsize / bytes_per_frame;
 
-			if(line6pcm->pos_in_done + frames > runtime->buffer_size) {
+			if (line6pcm->pos_in_done + frames > runtime->buffer_size) {
 				/*
 					The transferred area goes over buffer boundary,
 					copy two separate chunks.
@@ -184,34 +187,32 @@ static void audio_in_callback(struct urb
 				int len;
 				len = runtime->buffer_size - line6pcm->pos_in_done;
 
-				if(len > 0) {
+				if (len > 0) {
 					memcpy(runtime->dma_area + line6pcm->pos_in_done * bytes_per_frame, fbuf, len * bytes_per_frame);
 					memcpy(runtime->dma_area, fbuf + len * bytes_per_frame, (frames - len) * bytes_per_frame);
-				}
-				else
+				} else
 					dev_err(s2m(substream), "driver bug: len = %d\n", len);  /* this is somewhat paranoid */
-			}
-			else {
+			} else {
 				/* copy single chunk */
 				memcpy(runtime->dma_area + line6pcm->pos_in_done * bytes_per_frame, fbuf, fsize * bytes_per_frame);
 			}
 
-			if((line6pcm->pos_in_done += frames) >= runtime->buffer_size)
+			if ((line6pcm->pos_in_done += frames) >= runtime->buffer_size)
 				line6pcm->pos_in_done -= runtime->buffer_size;
 		}
 	}
 
 	clear_bit(index, &line6pcm->active_urb_in);
 
-	if(test_bit(index, &line6pcm->unlink_urb_in))
+	if (test_bit(index, &line6pcm->unlink_urb_in))
 		shutdown = 1;
 
 	spin_unlock_irqrestore(&line6pcm->lock_audio_in, flags);
 
-	if(!shutdown) {
+	if (!shutdown) {
 		submit_audio_in_urb(substream);
 
-		if((line6pcm->bytes_in += length) >= line6pcm->period_in) {
+		if ((line6pcm->bytes_in += length) >= line6pcm->period_in) {
 			line6pcm->bytes_in -= line6pcm->period_in;
 			snd_pcm_period_elapsed(substream);
 		}
@@ -225,8 +226,10 @@ static int snd_line6_capture_open(struct
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);
 
-	if((err = snd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-																					(&line6pcm->properties->snd_line6_rates))) < 0)
+	err = snd_pcm_hw_constraint_ratdens(runtime, 0,
+					    SNDRV_PCM_HW_PARAM_RATE,
+					    (&line6pcm->properties->snd_line6_rates));
+	if (err < 0)
 		return err;
 
 	runtime->hw = line6pcm->properties->snd_line6_capture_hw;
@@ -240,30 +243,33 @@ static int snd_line6_capture_close(struc
 }
 
 /* hw_params capture callback */
-static int snd_line6_capture_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *hw_params)
+static int snd_line6_capture_hw_params(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *hw_params)
 {
 	int ret;
 	struct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);
 
 	/* -- Florian Demski [FD] */
 	/* don't ask me why, but this fixes the bug on my machine */
-	if ( line6pcm == NULL ) {
-		if ( substream->pcm == NULL )
+	if (line6pcm == NULL) {
+		if (substream->pcm == NULL)
 			return -ENOMEM;
-		if ( substream->pcm->private_data == NULL )
+		if (substream->pcm->private_data == NULL)
 			return -ENOMEM;
 		substream->private_data = substream->pcm->private_data;
-		line6pcm = snd_pcm_substream_chip( substream );
+		line6pcm = snd_pcm_substream_chip(substream);
 	}
 	/* -- [FD] end */
 
-	if((ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)
+	ret = snd_pcm_lib_malloc_pages(substream,
+				       params_buffer_bytes(hw_params));
+	if (ret < 0)
 		return ret;
 
 	line6pcm->period_in = params_period_bytes(hw_params);
 	line6pcm->buffer_in = kmalloc(LINE6_ISO_BUFFERS * LINE6_ISO_PACKETS * LINE6_ISO_PACKET_SIZE_MAX, GFP_KERNEL);
 
-	if(!line6pcm->buffer_in) {
+	if (!line6pcm->buffer_in) {
 		dev_err(s2m(substream), "cannot malloc buffer_in\n");
 		return -ENOMEM;
 	}
@@ -277,10 +283,8 @@ static int snd_line6_capture_hw_free(str
 	struct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);
 	unlink_wait_clear_audio_in_urbs(line6pcm);
 
-	if(line6pcm->buffer_in) {
-		kfree(line6pcm->buffer_in);
-		line6pcm->buffer_in = NULL;
-	}
+	kfree(line6pcm->buffer_in);
+	line6pcm->buffer_in = NULL;
 
 	return snd_pcm_lib_free_pages(substream);
 }
@@ -292,12 +296,12 @@ int snd_line6_capture_trigger(struct snd
 	int err;
 	line6pcm->count_in = 0;
 
-	switch(cmd) {
+	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		if(!test_and_set_bit(BIT_RUNNING_CAPTURE, &line6pcm->flags)) {
+		if (!test_and_set_bit(BIT_RUNNING_CAPTURE, &line6pcm->flags)) {
 			err = submit_audio_in_all_urbs(substream);
 
-			if(err < 0) {
+			if (err < 0) {
 				clear_bit(BIT_RUNNING_CAPTURE, &line6pcm->flags);
 				return err;
 			}
@@ -306,7 +310,7 @@ int snd_line6_capture_trigger(struct snd
 		break;
 
 	case SNDRV_PCM_TRIGGER_STOP:
-		if(test_and_clear_bit(BIT_RUNNING_CAPTURE, &line6pcm->flags))
+		if (test_and_clear_bit(BIT_RUNNING_CAPTURE, &line6pcm->flags))
 			unlink_audio_in_urbs(line6pcm);
 
 		break;
@@ -343,13 +347,13 @@ int create_audio_in_urbs(struct snd_line
 	int i;
 
 	/* create audio URBs and fill in constant values: */
-	for(i = 0; i < LINE6_ISO_BUFFERS; ++i) {
+	for (i = 0; i < LINE6_ISO_BUFFERS; ++i) {
 		struct urb *urb;
 
 		/* URB for audio in: */
 		urb = line6pcm->urb_audio_in[i] = usb_alloc_urb(LINE6_ISO_PACKETS, GFP_KERNEL);
 
-		if(urb == NULL) {
+		if (urb == NULL) {
 			dev_err(line6pcm->line6->ifcdev, "Out of memory\n");
 			return -ENOMEM;
 		}
