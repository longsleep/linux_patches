From Larry.Finger@lwfinger.net  Thu Feb 18 07:45:26 2010
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sun, 14 Feb 2010 22:07:57 -0600
Subject: Staging: r8187se: Remove dead code from r8185b_init.c
To: Greg Kroah-Hartman <gregkh@suse.de>
Cc: Bernhard Schiffner <bernhard@schiffner-limbach.de>, wireless <linux-wireless@vger.kernel.org>
Message-ID: <4B78C89D.3040108@lwfinger.net>


Remove dead code from r8185b_init.c.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/rtl8187se/r8185b_init.c |  632 --------------------------------
 1 file changed, 2 insertions(+), 630 deletions(-)

--- a/drivers/staging/rtl8187se/r8185b_init.c
+++ b/drivers/staging/rtl8187se/r8185b_init.c
@@ -243,82 +243,7 @@ void SetOutputEnableOfRfPins(struct net_
 	write_nic_word(dev, RFPinsEnable, 0x1bff);
 }
 
-void
-ZEBRA_RFSerialWrite(
-	struct net_device *dev,
-	u32			data2Write,
-	u8			totalLength,
-	u8			low2high
-	)
-{
-	ThreeWireReg		twreg;
-	int 				i;
-	u16				oval,oval2,oval3;
-	u32				mask;
-	u16				UshortBuffer;
-
-	u8			u1bTmp;
-	// RTL8187S HSSI Read/Write Function
-	u1bTmp = read_nic_byte(dev, RF_SW_CONFIG);
-	u1bTmp |=   RF_SW_CFG_SI;   //reg08[1]=1 Serial Interface(SI)
-	write_nic_byte(dev, RF_SW_CONFIG, u1bTmp);
-	UshortBuffer = read_nic_word(dev, RFPinsOutput);
-	oval = UshortBuffer & 0xfff8; // We shall clear bit0, 1, 2 first, 2005.10.28, by rcnjko.
-
-	oval2 = read_nic_word(dev, RFPinsEnable);
-	oval3 = read_nic_word(dev, RFPinsSelect);
-
-	// <RJ_NOTE> 3-wire should be controled by HW when we finish SW 3-wire programming. 2005.08.10, by rcnjko.
-	oval3 &= 0xfff8;
-
-	write_nic_word(dev, RFPinsEnable, (oval2|0x0007)); // Set To Output Enable
-	write_nic_word(dev, RFPinsSelect, (oval3|0x0007)); // Set To SW Switch
-	udelay(10);
-
-	// Add this to avoid hardware and software 3-wire conflict.
-	// 2005.03.01, by rcnjko.
-	twreg.longData = 0;
-	twreg.struc.enableB = 1;
-	write_nic_word(dev, RFPinsOutput, (twreg.longData|oval)); // Set SI_EN (RFLE)
-	udelay(2);
-	twreg.struc.enableB = 0;
-	write_nic_word(dev, RFPinsOutput, (twreg.longData|oval)); // Clear SI_EN (RFLE)
-	udelay(10);
-
-	mask = (low2high)?0x01:((u32)0x01<<(totalLength-1));
-
-	for(i=0; i<totalLength/2; i++)
-	{
-		twreg.struc.data = ((data2Write&mask)!=0) ? 1 : 0;
-		write_nic_word(dev, RFPinsOutput, (twreg.longData|oval));
-		twreg.struc.clk = 1;
-		write_nic_word(dev, RFPinsOutput, (twreg.longData|oval));
-		write_nic_word(dev, RFPinsOutput, (twreg.longData|oval));
-
-		mask = (low2high)?(mask<<1):(mask>>1);
-		twreg.struc.data = ((data2Write&mask)!=0) ? 1 : 0;
-		write_nic_word(dev, RFPinsOutput, (twreg.longData|oval));
-		write_nic_word(dev, RFPinsOutput, (twreg.longData|oval));
-		twreg.struc.clk = 0;
-		write_nic_word(dev, RFPinsOutput, (twreg.longData|oval));
-		mask = (low2high)?(mask<<1):(mask>>1);
-	}
-
-	twreg.struc.enableB = 1;
-	twreg.struc.clk = 0;
-	twreg.struc.data = 0;
-	write_nic_word(dev, RFPinsOutput, twreg.longData|oval);
-	udelay(10);
-
-	write_nic_word(dev, RFPinsOutput, oval|0x0004);
-	write_nic_word(dev, RFPinsSelect, oval3|0x0000);
-
-	SetOutputEnableOfRfPins(dev);
-}
-//by amy
-
-
-int
+static int
 HwHSSIThreeWire(
 	struct net_device *dev,
 	u8			*pDataBuf,
@@ -456,138 +381,6 @@ HwHSSIThreeWire(
 
 	return bResult;
 }
-//by amy
-
-int
-HwThreeWire(
-	struct net_device *dev,
-	u8			*pDataBuf,
-	u8			nDataBufBitCnt,
-	int			bHold,
-	int			bWrite
-	)
-{
-	int	bResult = 1;
-	u8	TryCnt;
-	u8	u1bTmp;
-
-	do
-	{
-		// Check if WE and RE are cleared.
-		for(TryCnt = 0; TryCnt < TC_3W_POLL_MAX_TRY_CNT; TryCnt++)
-		{
-			u1bTmp = read_nic_byte(dev, SW_3W_CMD1);
-			if( (u1bTmp & (SW_3W_CMD1_RE|SW_3W_CMD1_WE)) == 0 )
-			{
-				break;
-			}
-			udelay(10);
-		}
-		if (TryCnt == TC_3W_POLL_MAX_TRY_CNT)
-			panic("HwThreeWire(): CmdReg: %#X RE|WE bits are not clear!!\n", u1bTmp);
-
-		// Fill up data buffer for write operation.
-		if(nDataBufBitCnt == 16)
-		{
-			write_nic_word(dev, SW_3W_DB0, *((u16 *)pDataBuf));
-		}
-		else if(nDataBufBitCnt == 64)
-		{
-			write_nic_dword(dev, SW_3W_DB0, *((u32 *)pDataBuf));
-			write_nic_dword(dev, SW_3W_DB1, *((u32 *)(pDataBuf + 4)));
-		}
-		else
-		{
-			int idx;
-			int ByteCnt = nDataBufBitCnt / 8;
-
-			if ((nDataBufBitCnt % 8) != 0)
-				panic("HwThreeWire(): nDataBufBitCnt(%d) should be multiple of 8!!!\n",
-				nDataBufBitCnt);
-
-			if (nDataBufBitCnt > 64)
-				panic("HwThreeWire(): nDataBufBitCnt(%d) should <= 64!!!\n",
-				nDataBufBitCnt);
-
-			for(idx = 0; idx < ByteCnt; idx++)
-			{
-				write_nic_byte(dev, (SW_3W_DB0+idx), *(pDataBuf+idx));
-			}
-		}
-
-		// Fill up length field.
-		u1bTmp = (u8)(nDataBufBitCnt - 1); // Number of bits - 1.
-		if(bHold)
-			u1bTmp |= SW_3W_CMD0_HOLD;
-		write_nic_byte(dev, SW_3W_CMD0, u1bTmp);
-
-		// Set up command: WE or RE.
-		if(bWrite)
-		{
-			write_nic_byte(dev, SW_3W_CMD1, SW_3W_CMD1_WE);
-		}
-		else
-		{
-			write_nic_byte(dev, SW_3W_CMD1, SW_3W_CMD1_RE);
-		}
-
-		// Check if WE and RE are cleared and DONE is set.
-		for(TryCnt = 0; TryCnt < TC_3W_POLL_MAX_TRY_CNT; TryCnt++)
-		{
-			u1bTmp = read_nic_byte(dev, SW_3W_CMD1);
-			if( (u1bTmp & (SW_3W_CMD1_RE|SW_3W_CMD1_WE)) == 0 &&
-				(u1bTmp & SW_3W_CMD1_DONE) != 0 )
-			{
-				break;
-			}
-			udelay(10);
-		}
-		if(TryCnt == TC_3W_POLL_MAX_TRY_CNT)
-		{
-			//RT_ASSERT(TryCnt != TC_3W_POLL_MAX_TRY_CNT,
-			//	("HwThreeWire(): CmdReg: %#X RE|WE bits are not clear or DONE is not set!!\n", u1bTmp));
-			// Workaround suggested by wcchu: clear WE here. 2006.07.07, by rcnjko.
-			write_nic_byte(dev, SW_3W_CMD1, 0);
-		}
-
-		// Read back data for read operation.
-		// <RJ_TODO> I am not sure if this is correct output format of a read operation.
-		if(bWrite == 0)
-		{
-			if(nDataBufBitCnt == 16)
-			{
-				*((u16 *)pDataBuf) = read_nic_word(dev, SW_3W_DB0);
-			}
-			else if(nDataBufBitCnt == 64)
-			{
-				*((u32 *)pDataBuf) = read_nic_dword(dev, SW_3W_DB0);
-				*((u32 *)(pDataBuf + 4)) = read_nic_dword(dev, SW_3W_DB1);
-			}
-			else
-			{
-				int idx;
-				int ByteCnt = nDataBufBitCnt / 8;
-
-				if ((nDataBufBitCnt % 8) != 0)
-					panic("HwThreeWire(): nDataBufBitCnt(%d) should be multiple of 8!!!\n",
-					nDataBufBitCnt);
-
-				if (nDataBufBitCnt > 64)
-					panic("HwThreeWire(): nDataBufBitCnt(%d) should <= 64!!!\n",
-					nDataBufBitCnt);
-
-				for(idx = 0; idx < ByteCnt; idx++)
-				{
-					*(pDataBuf+idx) = read_nic_byte(dev, (SW_3W_DB0+idx));
-				}
-			}
-		}
-
-	}while(0);
-
-	return bResult;
-}
-
 
 void
 RF_WriteReg(struct net_device *dev, u8 offset, u32 data)
@@ -602,125 +395,6 @@ RF_WriteReg(struct net_device *dev, u8 o
 	HwHSSIThreeWire(dev, (u8 *)(&data2Write), len, 1, 1);
 }
 
-void
-ZEBRA_RFSerialRead(struct net_device *dev, u32 data2Write, u8 wLength,
-		   u32 *data2Read, u8 rLength, u8 low2high)
-{
-	ThreeWireReg	twreg;
-	int i;
-	u16 oval, oval2, oval3, tmp, wReg80;
-	u32 mask;
-	u8 u1bTmp;
-	ThreeWireReg	tdata;
-	//PHAL_DATA_8187	pHalData = GetHalData8187(pAdapter);
-	{ // RTL8187S HSSI Read/Write Function
-		u1bTmp = read_nic_byte(dev, RF_SW_CONFIG);
-		u1bTmp |=   RF_SW_CFG_SI;   //reg08[1]=1 Serial Interface(SI)
-		write_nic_byte(dev, RF_SW_CONFIG, u1bTmp);
-	}
-
-	wReg80 = oval = read_nic_word(dev, RFPinsOutput);
-	oval2 = read_nic_word(dev, RFPinsEnable);
-	oval3 = read_nic_word(dev, RFPinsSelect);
-
-	write_nic_word(dev, RFPinsEnable, oval2|0xf);
-	write_nic_word(dev, RFPinsSelect, oval3|0xf);
-
-	*data2Read = 0;
-
-	// We must clear BIT0-3 here, otherwise,
-	// SW_Enalbe will be true when we first call ZEBRA_RFSerialRead() after 8187MPVC open,
-	// which will cause the value read become 0. 2005.04.11, by rcnjko.
-	oval &= ~0xf;
-
-	// Avoid collision with hardware three-wire.
-	twreg.longData = 0;
-	twreg.struc.enableB = 1;
-	write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(4);
-
-	twreg.longData = 0;
-	twreg.struc.enableB = 0;
-	twreg.struc.clk = 0;
-	twreg.struc.read_write = 0;
-	write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(5);
-
-	mask = (low2high) ? 0x01 : ((u32)0x01<<(32-1));
-	for(i = 0; i < wLength/2; i++)
-	{
-		twreg.struc.data = ((data2Write&mask) != 0) ? 1 : 0;
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(1);
-		twreg.struc.clk = 1;
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-
-		mask = (low2high) ? (mask<<1): (mask>>1);
-
-		if(i == 2)
-		{
-			// Commented out by Jackie, 2004.08.26. <RJ_NOTE> We must comment out the following two lines for we cannot pull down VCOPDN during RF Serail Read.
-			//PlatformEFIOWrite2Byte(pAdapter, RFPinsEnable, 0xe);     // turn off data enable
-			//PlatformEFIOWrite2Byte(pAdapter, RFPinsSelect, 0xe);
-
-			twreg.struc.read_write=1;
-			write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-			twreg.struc.clk = 0;
-			write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-			break;
-		}
-		twreg.struc.data = ((data2Write&mask) != 0) ? 1: 0;
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-
-		twreg.struc.clk = 0;
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(1);
-
-		mask = (low2high) ? (mask<<1) : (mask>>1);
-	}
-
-	twreg.struc.clk = 0;
-	twreg.struc.data = 0;
-	write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-	mask = (low2high) ? 0x01 : ((u32)0x01 << (12-1));
-
-	//
-	// 061016, by rcnjko:
-	// We must set data pin to HW controled, otherwise RF can't driver it and
-	// value RF register won't be able to read back properly.
-	//
-	write_nic_word(dev, RFPinsEnable, ( ((oval2|0x0E) & (~0x01))) );
-
-	for(i = 0; i < rLength; i++)
-	{
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(1);
-		twreg.struc.clk = 1;
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-		tmp = read_nic_word(dev, RFPinsInput);
-		tdata.longData = tmp;
-		*data2Read |= tdata.struc.clk ? mask : 0;
-
-		twreg.struc.clk = 0;
-		write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-
-		mask = (low2high) ? (mask<<1) : (mask>>1);
-	}
-	twreg.struc.enableB = 1;
-	twreg.struc.clk = 0;
-	twreg.struc.data = 0;
-	twreg.struc.read_write = 1;
-	write_nic_word(dev, RFPinsOutput, twreg.longData|oval); udelay(2);
-
-	//PlatformEFIOWrite2Byte(pAdapter, RFPinsEnable, oval2|0x8);   // Set To Output Enable
-	write_nic_word(dev, RFPinsEnable, oval2);   // Set To Output Enable, <RJ_NOTE> We cannot enable BIT3 here, otherwise, we will failed to switch channel. 2005.04.12.
-	//PlatformEFIOWrite2Byte(pAdapter, RFPinsEnable, 0x1bff);
-	write_nic_word(dev, RFPinsSelect, oval3);   // Set To SW Switch
-	//PlatformEFIOWrite2Byte(pAdapter, RFPinsSelect, 0x0488);
-	write_nic_word(dev, RFPinsOutput, 0x3a0);
-	//PlatformEFIOWrite2Byte(pAdapter, RFPinsOutput, 0x0480);
-}
-
-
 u32 RF_ReadReg(struct net_device *dev, u8 offset)
 {
 	u32 data2Write;
@@ -891,15 +565,12 @@ ZEBRA_Config_85BASIC_HardCode(
 
 	// Page0 : reg0-reg15
 
-//	RF_WriteReg(dev, 0x00, 0x003f);			mdelay(1);//1
 	RF_WriteReg(dev, 0x00, 0x009f);      	mdelay(1);// 1
 
 	RF_WriteReg(dev, 0x01, 0x06e0);			mdelay(1);
 
-//	RF_WriteReg(dev, 0x02, 0x004c);			mdelay(1);//2
 	RF_WriteReg(dev, 0x02, 0x004d);			mdelay(1);// 2
 
-//	RF_WriteReg(dev, 0x03, 0x0000);			mdelay(1);//3
 	RF_WriteReg(dev, 0x03, 0x07f1);			mdelay(1);// 3
 
 	RF_WriteReg(dev, 0x04, 0x0975);			mdelay(1);
@@ -928,8 +599,6 @@ ZEBRA_Config_85BASIC_HardCode(
 
 	RF_WriteReg(dev, 0x07, 0x01A0);			mdelay(1);
 // Don't write RF23/RF24 to make a difference between 87S C cut and D cut. asked by SD3 stevenl.
-//	RF_WriteReg(dev, 0x08, 0x0597);			mdelay(1);
-//	RF_WriteReg(dev, 0x09, 0x050a);			mdelay(1);
 	RF_WriteReg(dev, 0x0a, 0x0001);			mdelay(1);
 	RF_WriteReg(dev, 0x0b, 0x0418);			mdelay(1);
 
@@ -945,7 +614,6 @@ ZEBRA_Config_85BASIC_HardCode(
 
 	RF_WriteReg(dev, 0x0f, 0x0acc);			mdelay(1);
 
-//	RF_WriteReg(dev, 0x00, 0x017f);			mdelay(1);//6
 	RF_WriteReg(dev, 0x00, 0x01d7);			mdelay(1);// 6
 
 	RF_WriteReg(dev, 0x03, 0x0e00);			mdelay(1);
@@ -954,20 +622,14 @@ ZEBRA_Config_85BASIC_HardCode(
 	{
 		RF_WriteReg(dev, 0x01, i);                     mdelay(1);
 		RF_WriteReg(dev, 0x02, ZEBRA_RF_RX_GAIN_TABLE[i]); mdelay(1);
-		//DbgPrint("RF - 0x%x = 0x%x", i, ZEBRA_RF_RX_GAIN_TABLE[i]);
 	}
 
 	RF_WriteReg(dev, 0x05, 0x0203);			mdelay(1); 	/// 203, 343
-	//RF_WriteReg(dev, 0x06, 0x0300);			mdelay(1);	// 400
 	RF_WriteReg(dev, 0x06, 0x0200);			mdelay(1);	// 400
 
 	RF_WriteReg(dev, 0x00, 0x0137);			mdelay(1);	// switch to reg16-reg30, and HSSI disable 137
 	mdelay(10); 	// Deay 10 ms. //0xfd
 
-//	RF_WriteReg(dev, 0x0c, 0x09be);			mdelay(1);	// 7
-	//RF_WriteReg(dev, 0x0c, 0x07be);			mdelay(1);
-	//mdelay(10); 	// Deay 10 ms. //0xfd
-
 	RF_WriteReg(dev, 0x0d, 0x0008);			mdelay(1);	// Z4 synthesizer loop filter setting, 392
 	mdelay(10); 	// Deay 10 ms. //0xfd
 
@@ -1013,10 +675,8 @@ ZEBRA_Config_85BASIC_HardCode(
 		RF_WriteReg(dev, 0x0f, 0x0acc);			mdelay(1);
 	}
 //by amy 080312
-//	RF_WriteReg(dev, 0x0f, 0x0acc);			mdelay(1);  //-by amy 080312
 
 	RF_WriteReg(dev, 0x00, 0x00bf);			mdelay(1); // switch to reg0-reg15, and HSSI enable
-//	RF_WriteReg(dev, 0x0d, 0x009f);			mdelay(1); // Rx BB start calibration, 00c//-edward
 	RF_WriteReg(dev, 0x0d, 0x08df);			mdelay(1); // Rx BB start calibration, 00c//+edward
 	RF_WriteReg(dev, 0x02, 0x004d);			mdelay(1); // temperature meter off
 	RF_WriteReg(dev, 0x04, 0x0975);			mdelay(1); // Rx mode
@@ -1065,13 +725,10 @@ ZEBRA_Config_85BASIC_HardCode(
 	// AGC.txt
 	//=============================================================================
 
-//	PlatformIOWrite4Byte( dev, PhyAddr, 0x00001280);	// Annie, 2006-05-05
 	write_phy_ofdm(dev, 0x00, 0x12);
-	//WriteBBPortUchar(dev, 0x00001280);
 
 	for (i=0; i<128; i++)
 	{
-		//DbgPrint("AGC - [%x+1] = 0x%x\n", i, ZEBRA_AGC[i+1]);
 
 		data = ZEBRA_AGC[i+1];
 		data = data << 8;
@@ -1087,7 +744,6 @@ ZEBRA_Config_85BASIC_HardCode(
 	}
 
 	PlatformIOWrite4Byte( dev, PhyAddr, 0x00001080);	// Annie, 2006-05-05
-	//WriteBBPortUchar(dev, 0x00001080);
 
 	//=============================================================================
 
@@ -1100,8 +756,6 @@ ZEBRA_Config_85BASIC_HardCode(
 		u4bRegOffset=i;
 		u4bRegValue=OFDM_CONFIG[i];
 
-		//DbgPrint("OFDM - 0x%x = 0x%x\n", u4bRegOffset, u4bRegValue);
-
 		WriteBBPortUchar(dev,
 						(0x00000080 |
 						(u4bRegOffset & 0x7f) |
@@ -1125,9 +779,6 @@ UpdateInitialGain(
 	)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	//unsigned char* IGTable;
-	//u8			DIG_CurrentInitialGain = 4;
-	//unsigned char u1Tmp;
 
 	//lzm add 080826
 	if(priv->eRFPowerState != eRfOn)
@@ -1205,13 +856,11 @@ InitTxPwrTracking87SE(
 	struct net_device *dev
 )
 {
-	//struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	u32	u4bRfReg;
 
 	u4bRfReg = RF_ReadReg(dev, 0x02);
 
 	// Enable Thermal meter indication.
-	//printk("InitTxPwrTracking87SE(): Enable thermal meter indication, Write RF[0x02] = %#x", u4bRfReg|PWR_METER_EN);
 	RF_WriteReg(dev, 0x02, u4bRfReg|PWR_METER_EN);			mdelay(1);
 }
 
@@ -1231,7 +880,6 @@ PhyConfig8185(
 	{
 		if(priv->InitialGain == 0)
 			priv->InitialGain = 4;
-		//printk("PhyConfig8185(): DIG is enabled, set default initial gain index to %d\n", priv->InitialGain);
 	}
 
 	//
@@ -1249,34 +897,17 @@ PhyConfig8185(
 	return;
 }
 
-
-
-
 void
 HwConfigureRTL8185(
 		struct net_device *dev
 		)
 {
 	//RTL8185_TODO: Determine Retrylimit, TxAGC, AutoRateFallback control.
-//	u8		bUNIVERSAL_CONTROL_RL = 1;
         u8              bUNIVERSAL_CONTROL_RL = 0;
-
 	u8		bUNIVERSAL_CONTROL_AGC = 1;
 	u8		bUNIVERSAL_CONTROL_ANT = 1;
 	u8		bAUTO_RATE_FALLBACK_CTL = 1;
 	u8		val8;
-	//struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	//struct ieee80211_device *ieee = priv->ieee80211;
-      	//if(IS_WIRELESS_MODE_A(dev) || IS_WIRELESS_MODE_G(dev))
-//{by amy 080312	if((ieee->mode == IEEE_G)||(ieee->mode == IEEE_A))
-//	{
-//		write_nic_word(dev, BRSR, 0xffff);
-//	}
-//	else
-//	{
-//		write_nic_word(dev, BRSR, 0x000f);
-//	}
-//by amy 080312}
         write_nic_word(dev, BRSR, 0x0fff);
 	// Retry limit
 	val8 = read_nic_byte(dev, CW_CONF);
@@ -1327,20 +958,11 @@ HwConfigureRTL8185(
 		val8 |= RATE_FALLBACK_CTL_ENABLE | RATE_FALLBACK_CTL_AUTO_STEP1;
 
 		// <RJ_TODO_8185B> We shall set up the ARFR according to user's setting.
-		//write_nic_word(dev, ARFR, 0x0fff); // set 1M ~ 54M
-//by amy
-	        // Aadded by Roger, 2007.11.15.
 	        PlatformIOWrite2Byte(dev, ARFR, 0x0fff); //set 1M ~ 54Mbps.
-//by amy
-	}
-	else
-	{
 	}
 	write_nic_byte(dev, RATE_FALLBACK, val8);
 }
 
-
-
 static void
 MacConfig_85BASIC_HardCode(
 	struct net_device *dev)
@@ -1368,14 +990,11 @@ MacConfig_85BASIC_HardCode(
                 {
                     u4bRegOffset |= (u4bPageIndex << 8);
                 }
-                //DbgPrint("MAC - 0x%x = 0x%x\n", u4bRegOffset, u4bRegValue);
 		write_nic_byte(dev, u4bRegOffset, (u8)u4bRegValue);
 	}
 	//============================================================================
 }
 
-
-
 static void
 MacConfig_85BASIC(
 	struct net_device *dev)
@@ -1398,8 +1017,6 @@ MacConfig_85BASIC(
 	PlatformIOWrite1Byte(dev, 0x1F8, 0x00);
 
 	// Asked for by SD3 CM Lin, 2006.06.27, by rcnjko.
-	//PlatformIOWrite4Byte(dev, RFTiming, 0x00004001);
-//by amy
 	// power save parameter based on "87SE power save parameters 20071127.doc", as follow.
 
 	//Enable DA10 TX power saving
@@ -1418,16 +1035,10 @@ MacConfig_85BASIC(
 	write_nic_word(dev, 0x378, 0x0560);
 	write_nic_word(dev, 0x37A, 0x0560);
 	write_nic_word(dev, 0x37C, 0x00EC);
-//	write_nic_word(dev, 0x37E, 0x00FE);//-edward
 	write_nic_word(dev, 0x37E, 0x00EC);//+edward
        write_nic_byte(dev, 0x24E,0x01);
-//by amy
-
 }
 
-
-
-
 u8
 GetSupportedWirelessMode8185(
 	struct net_device *dev
@@ -1450,7 +1061,6 @@ ActUpdateChannelAccessSetting(
 	struct ieee80211_device *ieee = priv->ieee80211;
 	AC_CODING	eACI;
 	AC_PARAM	AcParam;
-	//PSTA_QOS	pStaQos = Adapter->MgntInfo.pStaQos;
 	u8	bFollowLegacySetting = 0;
 	u8   u1bAIFS;
 
@@ -1472,40 +1082,14 @@ ActUpdateChannelAccessSetting(
 	ChnlAccessSetting->CWmaxIndex = 7; // 2006.06.02, by rcnjko.
 
 	write_nic_byte(dev, SIFS, ChnlAccessSetting->SIFS_Timer);
-	//Adapter->HalFunc.SetHwRegHandler( Adapter, HW_VAR_SLOT_TIME, &ChnlAccessSetting->SlotTimeTimer );	// Rewrited from directly use PlatformEFIOWrite1Byte(), by Annie, 2006-03-29.
 	write_nic_byte(dev, SLOT, ChnlAccessSetting->SlotTimeTimer);	// Rewrited from directly use PlatformEFIOWrite1Byte(), by Annie, 2006-03-29.
 
 	u1bAIFS = aSifsTime + (2 * ChnlAccessSetting->SlotTimeTimer );
 
-	//write_nic_byte(dev, AC_VO_PARAM, u1bAIFS);
-	//write_nic_byte(dev, AC_VI_PARAM, u1bAIFS);
-	//write_nic_byte(dev, AC_BE_PARAM, u1bAIFS);
-	//write_nic_byte(dev, AC_BK_PARAM, u1bAIFS);
-
 	write_nic_byte(dev, EIFS, ChnlAccessSetting->EIFS_Timer);
 
 	write_nic_byte(dev, AckTimeOutReg, 0x5B); // <RJ_EXPR_QOS> Suggested by wcchu, it is the default value of EIFS register, 2005.12.08.
 
-#ifdef TODO
-	// <RJ_TODO_NOW_8185B> Update ECWmin/ECWmax, AIFS, TXOP Limit of each AC to the value defined by SPEC.
-	if( pStaQos->CurrentQosMode > QOS_DISABLE )
-	{ // QoS mode.
-		if(pStaQos->QBssWirelessMode == WirelessMode)
-		{
-			// Follow AC Parameters of the QBSS.
-			for(eACI = 0; eACI < AC_MAX; eACI++)
-			{
-				Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_AC_PARAM, (pu1Byte)(&(pStaQos->WMMParamEle.AcParam[eACI])) );
-			}
-		}
-		else
-		{
-			// Follow Default WMM AC Parameters.
-			bFollowLegacySetting = 1;
-		}
-	}
-	else
-#endif
 	{ // Legacy 802.11.
 		bFollowLegacySetting = 1;
 
@@ -1528,14 +1112,12 @@ ActUpdateChannelAccessSetting(
 		AcParam.f.TXOPLimit = 0;
 
 		//lzm reserved 080826
-#if 1
 		// For turbo mode setting. port from 87B by Isaiah 2008-08-01
 		if( ieee->current_network.Turbo_Enable == 1 )
 			AcParam.f.TXOPLimit = 0x01FF;
 		// For 87SE with Intel 4965  Ad-Hoc mode have poor throughput (19MB)
 		if (ieee->iw_mode == IW_MODE_ADHOC)
 			AcParam.f.TXOPLimit = 0x0020;
-#endif
 
 		for(eACI = 0; eACI < AC_MAX; eACI++)
 		{
@@ -1579,18 +1161,13 @@ ActUpdateChannelAccessSetting(
 
 				// Cehck ACM bit.
 				// If it is set, immediately set ACM control bit to downgrading AC for passing WMM testplan. Annie, 2005-12-13.
-				//write_nic_byte(dev, ACM_CONTROL, pAcParam->f.AciAifsn);
 				{
 					PACI_AIFSN	pAciAifsn = (PACI_AIFSN)(&pAcParam->f.AciAifsn);
 					AC_CODING	eACI = pAciAifsn->f.ACI;
 
 					//modified Joseph
 					//for 8187B AsynIORead issue
-#ifdef TODO
-					u8	AcmCtrl = pHalData->AcmControl;
-#else
 					u8	AcmCtrl = 0;
-#endif
 					if( pAciAifsn->f.ACM )
 					{ // ACM bit is 1.
 						switch(eACI)
@@ -1632,19 +1209,10 @@ ActUpdateChannelAccessSetting(
 								break;
 						}
 					}
-
-					//printk(KERN_WARNING "SetHwReg8185(): [HW_VAR_ACM_CTRL] Write 0x%X\n", AcmCtrl);
-
-#ifdef TO_DO
-					pHalData->AcmControl = AcmCtrl;
-#endif
-					//write_nic_byte(dev, ACM_CONTROL, AcmCtrl);
 					write_nic_byte(dev, ACM_CONTROL, 0);
 				}
 			}
 		}
-
-
 	}
 }
 
@@ -1656,7 +1224,6 @@ ActSetWirelessMode8185(
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	struct ieee80211_device *ieee = priv->ieee80211;
-	//PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
 	u8	btSupportedWirelessMode = GetSupportedWirelessMode8185(dev);
 
 	if( (btWirelessMode & btSupportedWirelessMode) == 0 )
@@ -1689,7 +1256,6 @@ ActSetWirelessMode8185(
 		}
 	}
 
-
 	/* 2. Swtich band: RF or BB specific actions,
 	 * for example, refresh tables in omc8255, or change initial gain if necessary.
 	 * Nothing to do for Zebra to switch band.
@@ -1706,7 +1272,6 @@ ActSetWirelessMode8185(
 	else if( ieee->mode == WIRELESS_MODE_G ){
 		DMESG("WIRELESS_MODE_G\n");
 	}
-
 	ActUpdateChannelAccessSetting( dev, ieee->mode, &priv->ChannelAccessSetting);
 }
 
@@ -1724,11 +1289,7 @@ DrvIFIndicateDisassociation(
 	u16			reason
 	)
 {
-	//printk("==> DrvIFIndicateDisassociation()\n");
-
 	// nothing is needed after disassociation request.
-
-	//printk("<== DrvIFIndicateDisassociation()\n");
 }
 void
 MgntDisconnectIBSS(
@@ -1738,11 +1299,7 @@ MgntDisconnectIBSS(
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	u8			i;
 
-	//printk("XXXXXXXXXX MgntDisconnect IBSS\n");
-
 	DrvIFIndicateDisassociation(dev, unspec_reason);
-
-//	PlatformZeroMemory( pMgntInfo->Bssid, 6 );
 	for(i=0;i<6;i++)  priv->ieee80211->current_network.bssid[i] = 0x55;
 
 	priv->ieee80211->state = IEEE80211_NOLINK;
@@ -1754,16 +1311,10 @@ MgntDisconnectIBSS(
 	// Because Bcn DMA isn't complete, mgnt queue would stuck until Bcn packet send.
 
 	// Disable Beacon Queue Own bit, suggested by jong
-//	Adapter->HalFunc.SetTxDescOWNHandler(Adapter, BEACON_QUEUE, 0, 0);
 	ieee80211_stop_send_beacons(priv->ieee80211);
 
 	priv->ieee80211->link_change(dev);
 	notify_wx_assoc_event(priv->ieee80211);
-
-	// Stop SW Beacon.Use hw beacon so do not need to do so.by amy
-
-//		MgntIndicateMediaStatus( Adapter, RT_MEDIA_DISCONNECT, GENERAL_INDICATE );
-
 }
 void
 MlmeDisassociateRequest(
@@ -1783,14 +1334,8 @@ MlmeDisassociateRequest(
 		DrvIFIndicateDisassociation(dev, unspec_reason);
 
 
-	//	pMgntInfo->AsocTimestamp = 0;
 		for(i=0;i<6;i++)  priv->ieee80211->current_network.bssid[i] = 0x22;
-//		pMgntInfo->mBrates.Length = 0;
-//		Adapter->HalFunc.SetHwRegHandler( Adapter, HW_VAR_BASIC_RATE, (pu1Byte)(&pMgntInfo->mBrates) );
-
 		ieee80211_disassociate(priv->ieee80211);
-
-
 	}
 
 }
@@ -1808,23 +1353,12 @@ MgntDisconnectAP(
 // I move SecClearAllKeys() to MgntActSet_802_11_DISASSOCIATE().
 //
 //	//2004/09/15, kcwu, the key should be cleared, or the new handshaking will not success
-//	SecClearAllKeys(Adapter);
 
 	// In WPA WPA2 need to Clear all key ... because new key will set after new handshaking.
-#ifdef TODO
-	if(   pMgntInfo->SecurityInfo.AuthMode > RT_802_11AuthModeAutoSwitch ||
-		(pMgntInfo->bAPSuportCCKM && pMgntInfo->bCCX8021xenable) )  // In CCKM mode will Clear key
-	{
-		SecClearAllKeys(Adapter);
-		RT_TRACE(COMP_SEC, DBG_LOUD,("======>CCKM clear key..."))
-	}
-#endif
 	// 2004.10.11, by rcnjko.
-	//MlmeDisassociateRequest( Adapter, pMgntInfo->Bssid, disas_lv_ss );
 	MlmeDisassociateRequest( dev, priv->ieee80211->current_network.bssid, asRsn );
 
 	priv->ieee80211->state = IEEE80211_NOLINK;
-//	pMgntInfo->AsocTimestamp = 0;
 }
 bool
 MgntDisconnect(
@@ -1836,20 +1370,7 @@ MgntDisconnect(
 	//
 	// Schedule an workitem to wake up for ps mode, 070109, by rcnjko.
 	//
-#ifdef TODO
-	if(pMgntInfo->mPss != eAwake)
-	{
-		//
-		// Using AwkaeTimer to prevent mismatch ps state.
-		// In the timer the state will be changed according to the RF is being awoke or not. By Bruce, 2007-10-31.
-		//
-		// PlatformScheduleWorkItem( &(pMgntInfo->AwakeWorkItem) );
-		PlatformSetTimer( Adapter, &(pMgntInfo->AwakeTimer), 0 );
-	}
-#endif
 
-	// Indication of disassociation event.
-	//DrvIFIndicateDisassociation(Adapter, asRsn);
 	if(IS_DOT11D_ENABLE(priv->ieee80211))
 		Dot11d_Reset(priv->ieee80211);
 	// In adhoc mode, update beacon frame.
@@ -1857,8 +1378,6 @@ MgntDisconnect(
 	{
 		if( priv->ieee80211->iw_mode == IW_MODE_ADHOC )
 		{
-//			RT_TRACE(COMP_MLME, DBG_LOUD, ("MgntDisconnect() ===> MgntDisconnectIBSS\n"));
-			//printk("MgntDisconnect() ===> MgntDisconnectIBSS\n");
 			MgntDisconnectIBSS(dev);
 		}
 		if( priv->ieee80211->iw_mode == IW_MODE_INFRA )
@@ -1868,17 +1387,10 @@ MgntDisconnect(
 			// e.g. OID_802_11_DISASSOCIATE in Windows while as MgntDisconnectAP() is
 			// used to handle disassociation related things to AP, e.g. send Disassoc
 			// frame to AP.  2005.01.27, by rcnjko.
-//			SecClearAllKeys(Adapter);
-
-//			RT_TRACE(COMP_MLME, DBG_LOUD, ("MgntDisconnect() ===> MgntDisconnectAP\n"));
-			//printk("MgntDisconnect() ===> MgntDisconnectAP\n");
 			MgntDisconnectAP(dev, asRsn);
 		}
-
 		// Inidicate Disconnect, 2005.02.23, by rcnjko.
-//		MgntIndicateMediaStatus( Adapter, RT_MEDIA_DISCONNECT, GENERAL_INDICATE);
 	}
-
 	return true;
 }
 //
@@ -1898,10 +1410,8 @@ SetRFPowerState(
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	bool			bResult = false;
 
-//	printk("---------> SetRFPowerState(): eRFPowerState(%d)\n", eRFPowerState);
 	if(eRFPowerState == priv->eRFPowerState)
 	{
-//		printk("<--------- SetRFPowerState(): discard the request for eRFPowerState(%d) is the same.\n", eRFPowerState);
 		return bResult;
 	}
 
@@ -1935,33 +1445,25 @@ MgntActSet_RF_State(
 	RT_RF_POWER_STATE 	rtState;
 	u16				RFWaitCounter = 0;
 	unsigned long flag;
-//	 printk("===>MgntActSet_RF_State(): StateToSet(%d), ChangeSource(0x%x)\n",StateToSet, ChangeSource);
 	//
 	// Prevent the race condition of RF state change. By Bruce, 2007-11-28.
 	// Only one thread can change the RF state at one time, and others should wait to be executed.
 	//
-#if 1
 	while(true)
 	{
-//		down(&priv->rf_state);
 		spin_lock_irqsave(&priv->rf_ps_lock,flag);
 		if(priv->RFChangeInProgress)
 		{
-//			printk("====================>haha111111111\n");
-//			up(&priv->rf_state);
-//			RT_TRACE(COMP_RF, DBG_LOUD, ("MgntActSet_RF_State(): RF Change in progress! Wait to set..StateToSet(%d).\n", StateToSet));
 			spin_unlock_irqrestore(&priv->rf_ps_lock,flag);
 			// Set RF after the previous action is done.
 			while(priv->RFChangeInProgress)
 			{
 				RFWaitCounter ++;
-//				RT_TRACE(COMP_RF, DBG_LOUD, ("MgntActSet_RF_State(): Wait 1 ms (%d times)...\n", RFWaitCounter));
 				udelay(1000); // 1 ms
 
 				// Wait too long, return FALSE to avoid to be stuck here.
 				if(RFWaitCounter > 1000) // 1sec
 				{
-//					RT_ASSERT(FALSE, ("MgntActSet_RF_State(): Wait too logn to set RF\n"));
 					printk("MgntActSet_RF_State(): Wait too long to set RF\n");
 					// TODO: Reset RF state?
 					return false;
@@ -1970,17 +1472,13 @@ MgntActSet_RF_State(
 		}
 		else
 		{
-//			printk("========================>haha2\n");
 			priv->RFChangeInProgress = true;
-//			up(&priv->rf_state);
 			spin_unlock_irqrestore(&priv->rf_ps_lock,flag);
 			break;
 		}
 	}
-#endif
 	rtState = priv->eRFPowerState;
 
-
 	switch(StateToSet)
 	{
 	case eRfOn:
@@ -2001,7 +1499,6 @@ MgntActSet_RF_State(
 			}
 		}
 		else
-//			RT_TRACE(COMP_RF, DBG_LOUD, ("MgntActSet_RF_State - eRfon reject pMgntInfo->RfOffReason= 0x%x, ChangeSource=0x%X\n", pMgntInfo->RfOffReason, ChangeSource));
 			;
 		break;
 
@@ -2018,38 +1515,26 @@ MgntActSet_RF_State(
 				//
 				// Calling MgntDisconnect() instead of MgntActSet_802_11_DISASSOCIATE(),
 				// because we do NOT need to set ssid to dummy ones.
-				// Revised by Roger, 2007.12.04.
 				//
 				MgntDisconnect( dev, disas_lv_ss );
 
 				// Clear content of bssDesc[] and bssDesc4Query[] to avoid reporting old bss to UI.
-				// 2007.05.28, by shien chang.
-//				PlatformZeroMemory( pMgntInfo->bssDesc, sizeof(RT_WLAN_BSS)*MAX_BSS_DESC );
-//				pMgntInfo->NumBssDesc = 0;
-//				PlatformZeroMemory( pMgntInfo->bssDesc4Query, sizeof(RT_WLAN_BSS)*MAX_BSS_DESC );
-//				pMgntInfo->NumBssDesc4Query = 0;
 			}
 
-
-
 		priv->RfOffReason |= ChangeSource;
 		bActionAllowed = true;
 		break;
-
 	case eRfSleep:
 		priv->RfOffReason |= ChangeSource;
 		bActionAllowed = true;
 		break;
-
 	default:
 		break;
 	}
 
 	if(bActionAllowed)
 	{
-//		RT_TRACE(COMP_RF, DBG_LOUD, ("MgntActSet_RF_State(): Action is allowed.... StateToSet(%d), RfOffReason(%#X)\n", StateToSet, pMgntInfo->RfOffReason));
                 // Config HW to the specified mode.
-//		printk("MgntActSet_RF_State(): Action is allowed.... StateToSet(%d), RfOffReason(%#X)\n", StateToSet, priv->RfOffReason);
 		SetRFPowerState(dev, StateToSet);
 
 		// Turn on RF.
@@ -2059,7 +1544,6 @@ MgntActSet_RF_State(
 			if(bConnectBySSID)
 			{
 			// by amy not supported
-//				MgntActSet_802_11_SSID(Adapter, Adapter->MgntInfo.Ssid.Octet, Adapter->MgntInfo.Ssid.Length, TRUE );
 			}
 		}
 		// Turn off RF.
@@ -2068,18 +1552,11 @@ MgntActSet_RF_State(
 			HalDisableRx8185Dummy(dev);
 		}
 	}
-	else
-	{
-	//	printk("MgntActSet_RF_State(): Action is rejected.... StateToSet(%d), ChangeSource(%#X), RfOffReason(%#X)\n", StateToSet, ChangeSource, priv->RfOffReason);
-	}
 
 	// Release RF spinlock
-//	down(&priv->rf_state);
 	spin_lock_irqsave(&priv->rf_ps_lock,flag);
 	priv->RFChangeInProgress = false;
-//	up(&priv->rf_state);
 	spin_unlock_irqrestore(&priv->rf_ps_lock,flag);
-//	printk("<===MgntActSet_RF_State()\n");
 	return bActionAllowed;
 }
 void
@@ -2088,15 +1565,12 @@ InactivePowerSave(
 	)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	//u8 index = 0;
-
 	//
 	// This flag "bSwRfProcessing", indicates the status of IPS procedure, should be set if the IPS workitem
 	// is really scheduled.
 	// The old code, sets this flag before scheduling the IPS workitem and however, at the same time the
 	// previous IPS workitem did not end yet, fails to schedule the current workitem. Thus, bSwRfProcessing
 	// blocks the IPS procedure of switching RF.
-	// By Bruce, 2007-12-25.
 	//
 	priv->bSwRfProcessing = true;
 
@@ -2112,7 +1586,6 @@ InactivePowerSave(
 //
 //	Description:
 //		Enter the inactive power save mode. RF will be off
-//	2007.08.17, by shien chang.
 //
 void
 IPSEnter(
@@ -2121,13 +1594,11 @@ IPSEnter(
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	RT_RF_POWER_STATE rtState;
-	//printk("==============================>enter IPS\n");
 	if (priv->bInactivePs)
 	{
 		rtState = priv->eRFPowerState;
 
 		//
-		// Added by Bruce, 2007-12-25.
 		// Do not enter IPS in the following conditions:
 		// (1) RF is already OFF or Sleep
 		// (2) bSwRfProcessing (indicates the IPS is still under going)
@@ -2138,12 +1609,10 @@ IPSEnter(
 		if (rtState == eRfOn && !priv->bSwRfProcessing
 			&& (priv->ieee80211->state != IEEE80211_LINKED ))
 		{
-	//		printk("IPSEnter(): Turn off RF.\n");
 			priv->eInactivePowerState = eRfOff;
 			InactivePowerSave(dev);
 		}
 	}
-//	printk("priv->eRFPowerState is %d\n",priv->eRFPowerState);
 }
 void
 IPSLeave(
@@ -2152,20 +1621,17 @@ IPSLeave(
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	RT_RF_POWER_STATE rtState;
-	//printk("===================================>leave IPS\n");
 	if (priv->bInactivePs)
 	{
 		rtState = priv->eRFPowerState;
 		if ((rtState == eRfOff || rtState == eRfSleep) && (!priv->bSwRfProcessing) && priv->RfOffReason <= RF_CHANGE_BY_IPS)
 		{
-//			printk("IPSLeave(): Turn on RF.\n");
 			priv->eInactivePowerState = eRfOn;
 			InactivePowerSave(dev);
 		}
 	}
-//	printk("priv->eRFPowerState is %d\n",priv->eRFPowerState);
 }
-//by amy for power save
+
 void rtl8185b_adapter_start(struct net_device *dev)
 {
       struct r8180_priv *priv = ieee80211_priv(dev);
@@ -2174,75 +1640,45 @@ void rtl8185b_adapter_start(struct net_d
 	u8 SupportedWirelessMode;
 	u8			InitWirelessMode;
 	u8			bInvalidWirelessMode = 0;
-	//int i;
 	u8 tmpu8;
-    	//u8 u1tmp,u2tmp;
 	u8 btCR9346;
 	u8 TmpU1b;
 	u8 btPSR;
 
-	//rtl8180_rtx_disable(dev);
-//{by amy 080312
 	write_nic_byte(dev,0x24e, (BIT5|BIT6|BIT0));
-//by amy 080312}
 	rtl8180_reset(dev);
 
 	priv->dma_poll_mask = 0;
 	priv->dma_poll_stop_mask = 0;
 
-	//rtl8180_beacon_tx_disable(dev);
-
 	HwConfigureRTL8185(dev);
-
 	write_nic_dword(dev, MAC0, ((u32*)dev->dev_addr)[0]);
 	write_nic_word(dev, MAC4, ((u32*)dev->dev_addr)[1] & 0xffff );
-
 	write_nic_byte(dev, MSR, read_nic_byte(dev, MSR) & 0xf3);	// default network type to 'No	Link'
-
-	//write_nic_byte(dev, BRSR, 0x0);		// Set BRSR= 1M
-
 	write_nic_word(dev, BcnItv, 100);
 	write_nic_word(dev, AtimWnd, 2);
-
-	//PlatformEFIOWrite2Byte(dev, FEMR, 0xFFFF);
 	PlatformIOWrite2Byte(dev, FEMR, 0xFFFF);
-
 	write_nic_byte(dev, WPA_CONFIG, 0);
-
 	MacConfig_85BASIC(dev);
-
 	// Override the RFSW_CTRL (MAC offset 0x272-0x273), 2006.06.07, by rcnjko.
 	// BT_DEMO_BOARD type
 	PlatformIOWrite2Byte(dev, RFSW_CTRL, 0x569a);
-//by amy
-//#ifdef CONFIG_RTL818X_S
-		// for jong required
-//	PlatformIOWrite2Byte(dev, RFSW_CTRL, 0x9a56);
-//#endif
-//by amy
-	//BT_QA_BOARD
-	//PlatformIOWrite2Byte(dev, RFSW_CTRL, 0x9a56);
 
 	//-----------------------------------------------------------------------------
 	// Set up PHY related.
 	//-----------------------------------------------------------------------------
 	// Enable Config3.PARAM_En to revise AnaaParm.
 	write_nic_byte(dev, CR9346, 0xc0);	// enable config register write
-//by amy
 	tmpu8 = read_nic_byte(dev, CONFIG3);
 	write_nic_byte(dev, CONFIG3, (tmpu8 |CONFIG3_PARM_En) );
-//by amy
 	// Turn on Analog power.
 	// Asked for by William, otherwise, MAC 3-wire can't work, 2006.06.27, by rcnjko.
 	write_nic_dword(dev, ANAPARAM2, ANAPARM2_ASIC_ON);
 	write_nic_dword(dev, ANAPARAM, ANAPARM_ASIC_ON);
-//by amy
 	write_nic_word(dev, ANAPARAM3, 0x0010);
-//by amy
 
 	write_nic_byte(dev, CONFIG3, tmpu8);
 	write_nic_byte(dev, CR9346, 0x00);
-//{by amy 080312 for led
 	// enable EEM0 and EEM1 in 9346CR
 	btCR9346 = read_nic_byte(dev, CR9346);
 	write_nic_byte(dev, CR9346, (btCR9346|0xC0) );
@@ -2260,7 +1696,6 @@ void rtl8185b_adapter_start(struct net_d
 	// B-cut RF Radio on/off  5e[3]=0
 	btPSR = read_nic_byte(dev, PSR);
 	write_nic_byte(dev, PSR, (btPSR | BIT3));
-//by amy 080312 for led}
 	// setup initial timing for RFE.
 	write_nic_word(dev, RFPinsOutput, 0x0480);
 	SetOutputEnableOfRfPins(dev);
@@ -2323,55 +1758,19 @@ void rtl8185b_adapter_start(struct net_d
 		InitWirelessMode = ieee->mode;
 	}
 //by amy for power save
-//	printk("initialize ENABLE_IPS\n");
 	priv->eRFPowerState = eRfOff;
 	priv->RfOffReason = 0;
 	{
-	//	u32 tmp2;
-	//	u32 tmp = jiffies;
 		MgntActSet_RF_State(dev, eRfOn, 0);
-	//	tmp2 = jiffies;
-	//	printk("rf on cost jiffies:%lx\n", (tmp2-tmp)*1000/HZ);
 	}
-//	DrvIFIndicateCurrentPhyStatus(priv);
 		//
 		// If inactive power mode is enabled, disable rf while in disconnected state.
-		// 2007.07.16, by shien chang.
 		//
 	if (priv->bInactivePs)
 	{
-	//	u32 tmp2;
-	//	u32 tmp = jiffies;
 		MgntActSet_RF_State(dev,eRfOff, RF_CHANGE_BY_IPS);
-	//	tmp2 = jiffies;
-	//	printk("rf off cost jiffies:%lx\n", (tmp2-tmp)*1000/HZ);
-
 	}
-//	IPSEnter(dev);
 //by amy for power save
-#ifdef TODO
-	// Turn off RF if necessary. 2005.08.23, by rcnjko.
-	// We shall turn off RF after setting CMDR, otherwise,
-	// RF will be turnned on after we enable MAC Tx/Rx.
-	if(Adapter->MgntInfo.RegRfOff == TRUE)
-	{
-		SetRFPowerState8185(Adapter, RF_OFF);
-	}
-	else
-	{
-		SetRFPowerState8185(Adapter, RF_ON);
-	}
-#endif
-
-/*   //these is equal with above TODO.
-	write_nic_byte(dev, CR9346, 0xc0);	// enable config register write
-	write_nic_byte(dev, CONFIG3, read_nic_byte(dev, CONFIG3) | CONFIG3_PARM_En);
-	RF_WriteReg(dev, 0x4, 0x9FF);
-	write_nic_dword(dev, ANAPARAM2, ANAPARM2_ASIC_ON);
-	write_nic_dword(dev, ANAPARAM, ANAPARM_ASIC_ON);
-	write_nic_byte(dev, CONFIG3, (read_nic_byte(dev, CONFIG3)&(~CONFIG3_PARM_En)));
-	write_nic_byte(dev, CR9346, 0x00);
-*/
 
 	ActSetWirelessMode8185(dev, (u8)(InitWirelessMode));
 
@@ -2380,14 +1779,11 @@ void rtl8185b_adapter_start(struct net_d
 	rtl8185b_irq_enable(dev);
 
 	netif_start_queue(dev);
-
  }
 
-
 void rtl8185b_rx_enable(struct net_device *dev)
 {
 	u8 cmd;
-	//u32 rxconf;
 	/* for now we accept data, management & ctl frame*/
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 
@@ -2399,11 +1795,6 @@ void rtl8185b_rx_enable(struct net_devic
 		priv->ReceiveConfig = priv->ReceiveConfig | RCR_AAP;
 	}
 
-	/*if(priv->ieee80211->iw_mode == IW_MODE_MASTER){
-		rxconf = rxconf | (1<<ACCEPT_ALLMAC_FRAME_SHIFT);
-		rxconf = rxconf | (1<<RX_CHECK_BSSID_SHIFT);
-	}*/
-
 	if(priv->ieee80211->iw_mode == IW_MODE_MONITOR){
 		priv->ReceiveConfig = priv->ReceiveConfig | RCR_ACF | RCR_APWRMGT | RCR_AICV;
 	}
@@ -2415,9 +1806,6 @@ void rtl8185b_rx_enable(struct net_devic
 
 	fix_rx_fifo(dev);
 
-#ifdef DEBUG_RX
-	DMESG("rxconf: %x %x",priv->ReceiveConfig ,read_nic_dword(dev,RCR));
-#endif
 	cmd=read_nic_byte(dev,CMD);
 	write_nic_byte(dev,CMD,cmd | (1<<CMD_RX_ENABLE_SHIFT));
 
@@ -2426,9 +1814,7 @@ void rtl8185b_rx_enable(struct net_devic
 void rtl8185b_tx_enable(struct net_device *dev)
 {
 	u8 cmd;
-	//u8 tx_agc_ctl;
 	u8 byte;
-	//u32 txconf;
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 
 	write_nic_dword(dev, TCR, priv->TransmitConfig);
@@ -2438,21 +1824,7 @@ void rtl8185b_tx_enable(struct net_devic
 
 	fix_tx_fifo(dev);
 
-#ifdef DEBUG_TX
-	DMESG("txconf: %x %x",priv->TransmitConfig,read_nic_dword(dev,TCR));
-#endif
-
 	cmd=read_nic_byte(dev,CMD);
 	write_nic_byte(dev,CMD,cmd | (1<<CMD_TX_ENABLE_SHIFT));
-
-	//write_nic_dword(dev,TX_CONF,txconf);
-
-
-/*
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev, TX_DMA_POLLING, priv->dma_poll_mask);
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-	*/
 }
 
-
