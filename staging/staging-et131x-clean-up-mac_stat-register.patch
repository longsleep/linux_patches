From alan@linux.intel.com  Thu Nov 19 14:42:10 2009
From: Alan Cox <alan@linux.intel.com>
Date: Wed, 18 Nov 2009 14:06:57 +0000
Subject: Staging: et131x: clean up MAC_STAT register
To: greg@kroah.com
Message-ID: <20091118140656.2578.21210.stgit@localhost.localdomain>


One by one...

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/et131x/et1310_address_map.h |  164 ++++++++--------------------
 drivers/staging/et131x/et1310_mac.c         |   99 +++-------------
 2 files changed, 74 insertions(+), 189 deletions(-)


--- a/drivers/staging/et131x/et1310_address_map.h
+++ b/drivers/staging/et131x/et1310_address_map.h
@@ -1577,120 +1577,60 @@ typedef struct _MAC_t {					/* Location:
 /*
  * structure for Carry Register One and it's Mask Register reg located in mac
  * stat address map address 0x6130 and 0x6138.
+ *
+ * 31: tr64
+ * 30: tr127
+ * 29: tr255
+ * 28: tr511
+ * 27: tr1k
+ * 26: trmax
+ * 25: trmgv
+ * 24-17: unused
+ * 16: rbyt
+ * 15: rpkt
+ * 14: rfcs
+ * 13: rmca
+ * 12: rbca
+ * 11: rxcf
+ * 10: rxpf
+ * 9: rxuo
+ * 8: raln
+ * 7: rflr
+ * 6: rcde
+ * 5: rcse
+ * 4: rund
+ * 3: rovr
+ * 2: rfrg
+ * 1: rjbr
+ * 0: rdrp
  */
-typedef union _MAC_STAT_REG_1_t {
-	u32 value;
-	struct {
-#ifdef _BIT_FIELDS_HTOL
-		u32 tr64:1;	/* bit 31 */
-		u32 tr127:1;	/* bit 30 */
-		u32 tr255:1;	/* bit 29 */
-		u32 tr511:1;	/* bit 28 */
-		u32 tr1k:1;	/* bit 27 */
-		u32 trmax:1;	/* bit 26 */
-		u32 trmgv:1;	/* bit 25 */
-		u32 unused:8;	/* bits 17-24 */
-		u32 rbyt:1;	/* bit 16 */
-		u32 rpkt:1;	/* bit 15 */
-		u32 rfcs:1;	/* bit 14 */
-		u32 rmca:1;	/* bit 13 */
-		u32 rbca:1;	/* bit 12 */
-		u32 rxcf:1;	/* bit 11 */
-		u32 rxpf:1;	/* bit 10 */
-		u32 rxuo:1;	/* bit 9 */
-		u32 raln:1;	/* bit 8 */
-		u32 rflr:1;	/* bit 7 */
-		u32 rcde:1;	/* bit 6 */
-		u32 rcse:1;	/* bit 5 */
-		u32 rund:1;	/* bit 4 */
-		u32 rovr:1;	/* bit 3 */
-		u32 rfrg:1;	/* bit 2 */
-		u32 rjbr:1;	/* bit 1 */
-		u32 rdrp:1;	/* bit 0 */
-#else
-		u32 rdrp:1;	/* bit 0 */
-		u32 rjbr:1;	/* bit 1 */
-		u32 rfrg:1;	/* bit 2 */
-		u32 rovr:1;	/* bit 3 */
-		u32 rund:1;	/* bit 4 */
-		u32 rcse:1;	/* bit 5 */
-		u32 rcde:1;	/* bit 6 */
-		u32 rflr:1;	/* bit 7 */
-		u32 raln:1;	/* bit 8 */
-		u32 rxuo:1;	/* bit 9 */
-		u32 rxpf:1;	/* bit 10 */
-		u32 rxcf:1;	/* bit 11 */
-		u32 rbca:1;	/* bit 12 */
-		u32 rmca:1;	/* bit 13 */
-		u32 rfcs:1;	/* bit 14 */
-		u32 rpkt:1;	/* bit 15 */
-		u32 rbyt:1;	/* bit 16 */
-		u32 unused:8;	/* bits 17-24 */
-		u32 trmgv:1;	/* bit 25 */
-		u32 trmax:1;	/* bit 26 */
-		u32 tr1k:1;	/* bit 27 */
-		u32 tr511:1;	/* bit 28 */
-		u32 tr255:1;	/* bit 29 */
-		u32 tr127:1;	/* bit 30 */
-		u32 tr64:1;	/* bit 31 */
-#endif
-	} bits;
-} MAC_STAT_REG_1_t, *PMAC_STAT_REG_1_t;
 
 /*
  * structure for Carry Register Two Mask Register reg in mac stat address map.
  * located at address 0x613C
+ *
+ * 31-20: unused
+ * 19: tjbr
+ * 18: tfcs
+ * 17: txcf
+ * 16: tovr
+ * 15: tund
+ * 14: trfg
+ * 13: tbyt
+ * 12: tpkt
+ * 11: tmca
+ * 10: tbca
+ * 9: txpf
+ * 8: tdfr
+ * 7: tedf
+ * 6: tscl
+ * 5: tmcl
+ * 4: tlcl
+ * 3: txcl
+ * 2: tncl
+ * 1: tpfh
+ * 0: tdrp
  */
-typedef union _MAC_STAT_REG_2_t {
-	u32 value;
-	struct {
-#ifdef _BIT_FIELDS_HTOL
-		u32 unused:12;	/* bit 20-31 */
-		u32 tjbr:1;	/* bit 19 */
-		u32 tfcs:1;	/* bit 18 */
-		u32 txcf:1;	/* bit 17 */
-		u32 tovr:1;	/* bit 16 */
-		u32 tund:1;	/* bit 15 */
-		u32 tfrg:1;	/* bit 14 */
-		u32 tbyt:1;	/* bit 13 */
-		u32 tpkt:1;	/* bit 12 */
-		u32 tmca:1;	/* bit 11 */
-		u32 tbca:1;	/* bit 10 */
-		u32 txpf:1;	/* bit 9 */
-		u32 tdfr:1;	/* bit 8 */
-		u32 tedf:1;	/* bit 7 */
-		u32 tscl:1;	/* bit 6 */
-		u32 tmcl:1;	/* bit 5 */
-		u32 tlcl:1;	/* bit 4 */
-		u32 txcl:1;	/* bit 3 */
-		u32 tncl:1;	/* bit 2 */
-		u32 tpfh:1;	/* bit 1 */
-		u32 tdrp:1;	/* bit 0 */
-#else
-		u32 tdrp:1;	/* bit 0 */
-		u32 tpfh:1;	/* bit 1 */
-		u32 tncl:1;	/* bit 2 */
-		u32 txcl:1;	/* bit 3 */
-		u32 tlcl:1;	/* bit 4 */
-		u32 tmcl:1;	/* bit 5 */
-		u32 tscl:1;	/* bit 6 */
-		u32 tedf:1;	/* bit 7 */
-		u32 tdfr:1;	/* bit 8 */
-		u32 txpf:1;	/* bit 9 */
-		u32 tbca:1;	/* bit 10 */
-		u32 tmca:1;	/* bit 11 */
-		u32 tpkt:1;	/* bit 12 */
-		u32 tbyt:1;	/* bit 13 */
-		u32 tfrg:1;	/* bit 14 */
-		u32 tund:1;	/* bit 15 */
-		u32 tovr:1;	/* bit 16 */
-		u32 txcf:1;	/* bit 17 */
-		u32 tfcs:1;	/* bit 18 */
-		u32 tjbr:1;	/* bit 19 */
-		u32 unused:12;	/* bit 20-31 */
-#endif
-	} bits;
-} MAC_STAT_REG_2_t, *PMAC_STAT_REG_2_t;
 
 /*
  * MAC STATS Module of JAGCore Address Mapping
@@ -1831,16 +1771,16 @@ typedef struct _MAC_STAT_t {		/* Locatio
 	u32 TFrg;			/*  0x612C */
 
 	/* Carry Register One Register */
-	MAC_STAT_REG_1_t Carry1;	/*  0x6130 */
+	u32 Carry1;			/*  0x6130 */
 
 	/* Carry Register Two Register */
-	MAC_STAT_REG_2_t Carry2;	/*  0x6134 */
+	u32 Carry2;			/*  0x6134 */
 
 	/* Carry Register One Mask Register */
-	MAC_STAT_REG_1_t Carry1M;	/*  0x6138 */
+	u32 Carry1M;			/*  0x6138 */
 
 	/* Carry Register Two Mask Register */
-	MAC_STAT_REG_2_t Carry2M;	/*  0x613C */
+	u32 Carry2M;			/*  0x613C */
 } MAC_STAT_t, *PMAC_STAT_t;
 
 /* END OF MAC STAT REGISTER ADDRESS MAP */
--- a/drivers/staging/et131x/et1310_mac.c
+++ b/drivers/staging/et131x/et1310_mac.c
@@ -414,63 +414,8 @@ void ConfigMacStatRegs(struct et131x_ada
 	 * Initially this will be all counters.  It may become clear later
 	 * that we do not need to track all counters.
 	 */
-	{
-		MAC_STAT_REG_1_t Carry1M = { 0xffffffff };
-
-		Carry1M.bits.rdrp = 0;
-		Carry1M.bits.rjbr = 1;
-		Carry1M.bits.rfrg = 0;
-		Carry1M.bits.rovr = 0;
-		Carry1M.bits.rund = 1;
-		Carry1M.bits.rcse = 1;
-		Carry1M.bits.rcde = 0;
-		Carry1M.bits.rflr = 0;
-		Carry1M.bits.raln = 0;
-		Carry1M.bits.rxuo = 1;
-		Carry1M.bits.rxpf = 1;
-		Carry1M.bits.rxcf = 1;
-		Carry1M.bits.rbca = 1;
-		Carry1M.bits.rmca = 1;
-		Carry1M.bits.rfcs = 0;
-		Carry1M.bits.rpkt = 1;
-		Carry1M.bits.rbyt = 1;
-		Carry1M.bits.trmgv = 1;
-		Carry1M.bits.trmax = 1;
-		Carry1M.bits.tr1k = 1;
-		Carry1M.bits.tr511 = 1;
-		Carry1M.bits.tr255 = 1;
-		Carry1M.bits.tr127 = 1;
-		Carry1M.bits.tr64 = 1;
-
-		writel(Carry1M.value, &pDevMacStat->Carry1M.value);
-	}
-
-	{
-		MAC_STAT_REG_2_t Carry2M = { 0xffffffff };
-
-		Carry2M.bits.tdrp = 1;
-		Carry2M.bits.tpfh = 1;
-		Carry2M.bits.tncl = 0;
-		Carry2M.bits.txcl = 1;
-		Carry2M.bits.tlcl = 0;
-		Carry2M.bits.tmcl = 0;
-		Carry2M.bits.tscl = 0;
-		Carry2M.bits.tedf = 1;
-		Carry2M.bits.tdfr = 0;
-		Carry2M.bits.txpf = 1;
-		Carry2M.bits.tbca = 1;
-		Carry2M.bits.tmca = 1;
-		Carry2M.bits.tpkt = 1;
-		Carry2M.bits.tbyt = 1;
-		Carry2M.bits.tfrg = 1;
-		Carry2M.bits.tund = 0;
-		Carry2M.bits.tovr = 0;
-		Carry2M.bits.txcf = 1;
-		Carry2M.bits.tfcs = 1;
-		Carry2M.bits.tjbr = 1;
-
-		writel(Carry2M.value, &pDevMacStat->Carry2M.value);
-	}
+	writel(0xFFFFBE32, &pDevMacStat->Carry1M);
+	writel(0xFFFE7E8B, &pDevMacStat->Carry2M);
 }
 
 void ConfigFlowControl(struct et131x_adapter *etdev)
@@ -546,17 +491,17 @@ void UpdateMacStatHostCounters(struct et
  */
 void HandleMacStatInterrupt(struct et131x_adapter *etdev)
 {
-	MAC_STAT_REG_1_t Carry1;
-	MAC_STAT_REG_2_t Carry2;
+	u32 Carry1;
+	u32 Carry2;
 
 	/* Read the interrupt bits from the register(s).  These are Clear On
 	 * Write.
 	 */
-	Carry1.value = readl(&etdev->regs->macStat.Carry1.value);
-	Carry2.value = readl(&etdev->regs->macStat.Carry2.value);
+	Carry1 = readl(&etdev->regs->macStat.Carry1);
+	Carry2 = readl(&etdev->regs->macStat.Carry2);
 
-	writel(Carry1.value, &etdev->regs->macStat.Carry1.value);
-	writel(Carry2.value, &etdev->regs->macStat.Carry2.value);
+	writel(Carry1, &etdev->regs->macStat.Carry1);
+	writel(Carry2, &etdev->regs->macStat.Carry2);
 
 	/* We need to do update the host copy of all the MAC_STAT counters.
 	 * For each counter, check it's overflow bit.  If the overflow bit is
@@ -564,33 +509,33 @@ void HandleMacStatInterrupt(struct et131
 	 * revolution of the counter.  This routine is called when the counter
 	 * block indicates that one of the counters has wrapped.
 	 */
-	if (Carry1.bits.rfcs)
+	if (Carry1 & (1 << 14))
 		etdev->Stats.code_violations += COUNTER_WRAP_16_BIT;
-	if (Carry1.bits.raln)
+	if (Carry1 & (1 << 8))
 		etdev->Stats.alignment_err += COUNTER_WRAP_12_BIT;
-	if (Carry1.bits.rflr)
+	if (Carry1 & (1 << 7))
 		etdev->Stats.length_err += COUNTER_WRAP_16_BIT;
-	if (Carry1.bits.rfrg)
+	if (Carry1 & (1 << 2))
 		etdev->Stats.other_errors += COUNTER_WRAP_16_BIT;
-	if (Carry1.bits.rcde)
+	if (Carry1 & (1 << 6))
 		etdev->Stats.crc_err += COUNTER_WRAP_16_BIT;
-	if (Carry1.bits.rovr)
+	if (Carry1 & (1 << 3))
 		etdev->Stats.rx_ov_flow += COUNTER_WRAP_16_BIT;
-	if (Carry1.bits.rdrp)
+	if (Carry1 & (1 << 0))
 		etdev->Stats.norcvbuf += COUNTER_WRAP_16_BIT;
-	if (Carry2.bits.tovr)
+	if (Carry2 & (1 << 16))
 		etdev->Stats.max_pkt_error += COUNTER_WRAP_12_BIT;
-	if (Carry2.bits.tund)
+	if (Carry2 & (1 << 15))
 		etdev->Stats.tx_uflo += COUNTER_WRAP_12_BIT;
-	if (Carry2.bits.tscl)
+	if (Carry2 & (1 << 6))
 		etdev->Stats.first_collision += COUNTER_WRAP_12_BIT;
-	if (Carry2.bits.tdfr)
+	if (Carry2 & (1 << 8))
 		etdev->Stats.tx_deferred += COUNTER_WRAP_12_BIT;
-	if (Carry2.bits.tmcl)
+	if (Carry2 & (1 << 5))
 		etdev->Stats.excessive_collisions += COUNTER_WRAP_12_BIT;
-	if (Carry2.bits.tlcl)
+	if (Carry2 & (1 << 4))
 		etdev->Stats.late_collisions += COUNTER_WRAP_12_BIT;
-	if (Carry2.bits.tncl)
+	if (Carry2 & (1 << 2))
 		etdev->Stats.collisions += COUNTER_WRAP_12_BIT;
 }
 
