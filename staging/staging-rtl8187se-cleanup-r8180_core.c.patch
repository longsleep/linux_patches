From bzolnier@gmail.com  Thu Jul  2 12:39:05 2009
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Sun, 28 Jun 2009 16:20:38 +0200
Subject: Staging: rtl8187se: cleanup r8180_core.c
To: "Greg Kroah-Hartman" <gregkh@suse.de>
Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>, linux-kernel@vger.kernel.org
Message-ID: <20090628142038.8761.90476.sendpatchset@localhost.localdomain>


From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

* remove commented out code
* remove useless comments
* beautify code

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rtl8187se/r8180_core.c | 1412 +++++----------------------------
 1 file changed, 245 insertions(+), 1167 deletions(-)

--- a/drivers/staging/rtl8187se/r8180_core.c
+++ b/drivers/staging/rtl8187se/r8180_core.c
@@ -31,8 +31,7 @@
 #undef DUMMY_RX
 
 #include <linux/syscalls.h>
-//#include <linux/fcntl.h>
-//#include <asm/uaccess.h>
+
 #include "r8180_hw.h"
 #include "r8180.h"
 #include "r8180_rtl8225.h" /* RTL8225 Radio frontend */
@@ -52,7 +51,6 @@
 static struct pci_device_id rtl8180_pci_id_tbl[] __devinitdata = {
         {
                 .vendor = PCI_VENDOR_ID_REALTEK,
-//                .device = 0x8180,
                 .device = 0x8199,
                 .subvendor = PCI_ANY_ID,
                 .subdevice = PCI_ANY_ID,
@@ -70,7 +68,6 @@ static struct pci_device_id rtl8180_pci_
 
 static char* ifname = "wlan%d";
 static int hwseqnum = 0;
-//static char* ifname = "ath%d";
 static int hwwep = 0;
 static int channels = 0x3fff;
 
@@ -82,28 +79,12 @@ MODULE_AUTHOR("Andrea Merello <andreamrl
 MODULE_DESCRIPTION("Linux driver for Realtek RTL8180 / RTL8185 WiFi cards");
 
 
-
-/*
-MODULE_PARM(ifname, "s");
-MODULE_PARM_DESC(devname," Net interface name, wlan%d=default");
-
-MODULE_PARM(hwseqnum,"i");
-MODULE_PARM_DESC(hwseqnum," Try to use hardware 802.11 header sequence numbers. Zero=default");
-
-MODULE_PARM(hwwep,"i");
-MODULE_PARM_DESC(hwwep," Try to use hardware WEP support. Still broken and not available on all cards");
-
-MODULE_PARM(channels,"i");
-MODULE_PARM_DESC(channels," Channel bitmask for specific locales. NYI");
-*/
-
 module_param(ifname, charp, S_IRUGO|S_IWUSR );
 module_param(hwseqnum,int, S_IRUGO|S_IWUSR);
 module_param(hwwep,int, S_IRUGO|S_IWUSR);
 module_param(channels,int, S_IRUGO|S_IWUSR);
 
 MODULE_PARM_DESC(devname," Net interface name, wlan%d=default");
-//MODULE_PARM_DESC(devname," Net interface name, ath%d=default");
 MODULE_PARM_DESC(hwseqnum," Try to use hardware 802.11 header sequence numbers. Zero=default");
 MODULE_PARM_DESC(hwwep," Try to use hardware WEP support. Still broken and not available on all cards");
 MODULE_PARM_DESC(channels," Channel bitmask for specific locales. NYI");
@@ -181,18 +162,15 @@ out:
 }
 
 static struct pci_driver rtl8180_pci_driver = {
-	.name		= RTL8180_MODULE_NAME,	          /* Driver name   */
-	.id_table	= rtl8180_pci_id_tbl,	          /* PCI_ID table  */
-	.probe		= rtl8180_pci_probe,	          /* probe fn      */
-	.remove		= __devexit_p(rtl8180_pci_remove),/* remove fn     */
-	.suspend	= rtl8180_suspend,	          /* PM suspend fn */
-	.resume		= rtl8180_resume,                 /* PM resume fn  */
+	.name		= RTL8180_MODULE_NAME,
+	.id_table	= rtl8180_pci_id_tbl,
+	.probe		= rtl8180_pci_probe,
+	.remove		= __devexit_p(rtl8180_pci_remove),
+	.suspend	= rtl8180_suspend,
+	.resume		= rtl8180_resume,
 	.shutdown	= rtl8180_shutdown,
 };
 
-
-
-
 u8 read_nic_byte(struct net_device *dev, int x)
 {
         return 0xff&readb((u8*)dev->mem_start +x);
@@ -226,18 +204,12 @@ void write_nic_word(struct net_device *d
 	udelay(20);
 }
 
-
-
-
-
-
 inline void force_pci_posting(struct net_device *dev)
 {
 	read_nic_byte(dev,EPROM_CMD);
 	mb();
 }
 
-
 irqreturn_t rtl8180_interrupt(int irq, void *netdev, struct pt_regs *regs);
 void set_nic_rxring(struct net_device *dev);
 void set_nic_txring(struct net_device *dev);
@@ -245,10 +217,6 @@ static struct net_device_stats *rtl8180_
 void rtl8180_commit(struct net_device *dev);
 void rtl8180_start_tx_beacon(struct net_device *dev);
 
-/****************************************************************************
-   -----------------------------PROCFS STUFF-------------------------
-*****************************************************************************/
-
 static struct proc_dir_entry *rtl8180_proc = NULL;
 
 static int proc_get_registers(char *page, char **start,
@@ -256,33 +224,22 @@ static int proc_get_registers(char *page
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-//	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-
 	int len = 0;
 	int i,n;
-
-	int max=0xff;
+	int max = 0xff;
 
 	/* This dump the current register page */
-	for(n=0;n<=max;)
-	{
-		//printk( "\nD: %2x> ", n);
-		len += snprintf(page + len, count - len,
-			"\nD:  %2x > ",n);
-
-		for(i=0;i<16 && n<=max;i++,n++)
-		len += snprintf(page + len, count - len,
-			"%2x ",read_nic_byte(dev,n));
+	for (n = 0; n <= max;) {
+		len += snprintf(page + len, count - len, "\nD:  %2x > ", n);
 
-		//	printk("%2x ",read_nic_byte(dev,n));
+		for (i = 0; i < 16 && n <= max; i++, n++)
+			len += snprintf(page + len, count - len, "%2x ",
+					read_nic_byte(dev, n));
 	}
 	len += snprintf(page + len, count - len,"\n");
 
-
-
 	*eof = 1;
 	return len;
-
 }
 
 int get_curr_tx_free_desc(struct net_device *dev, int priority);
@@ -291,16 +248,12 @@ static int proc_get_stats_hw(char *page,
 			  off_t offset, int count,
 			  int *eof, void *data)
 {
-	//struct net_device *dev = data;
-	//struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-
 	int len = 0;
 
 	*eof = 1;
 	return len;
 }
 
-
 static int proc_get_stats_rx(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -311,30 +264,6 @@ static int proc_get_stats_rx(char *page,
 	int len = 0;
 
 	len += snprintf(page + len, count - len,
-	/*	"RX descriptor not available: %lu\n"
-		"RX incomplete (missing last descriptor): %lu\n"
-		"RX not data: %lu\n"
-		//"RX descriptor pointer reset: %lu\n"
-		"RX descriptor pointer lost: %lu\n"
-		//"RX pointer workaround: %lu\n"
-		"RX error int: %lu\n"
-		"RX fifo overflow: %lu\n"
-		"RX int: %lu\n"
-		"RX packet: %lu\n"
-		"RX bytes: %lu\n"
-		"RX DMA fail: %lu\n",
-		priv->stats.rxrdu,
-		priv->stats.rxnolast,
-		priv->stats.rxnodata,
-		//priv->stats.rxreset,
-		priv->stats.rxnopointer,
-		//priv->stats.rxwrkaround,
-		priv->stats.rxerr,
-		priv->stats.rxoverflow,
-		priv->stats.rxint,
-		priv->ieee80211->stats.rx_packets,
-		priv->ieee80211->stats.rx_bytes,
-		priv->stats.rxdmafail  */
 		"RX OK: %lu\n"
 		"RX Retry: %lu\n"
 		"RX CRC Error(0-500): %lu\n"
@@ -365,36 +294,6 @@ static int proc_get_stats_tx(char *page,
 
 	totalOK=priv->stats.txnpokint+priv->stats.txhpokint+priv->stats.txlpokint;
 	len += snprintf(page + len, count - len,
-	/*	"TX normal priority ok int: %lu\n"
-		"TX normal priority error int: %lu\n"
-		"TX high priority ok int: %lu\n"
-		"TX high priority failed error int: %lu\n"
-		"TX low priority ok int: %lu\n"
-		"TX low priority failed error int: %lu\n"
-		"TX bytes: %lu\n"
-		"TX packets: %lu\n"
-		"TX queue resume: %lu\n"
-		"TX queue stopped?: %d\n"
-		"TX fifo overflow: %lu\n"
-		//"SW TX stop: %lu\n"
-		//"SW TX wake: %lu\n"
-		"TX beacon: %lu\n"
-		"TX beacon aborted: %lu\n",
-		priv->stats.txnpokint,
-		priv->stats.txnperr,
-		priv->stats.txhpokint,
-		priv->stats.txhperr,
-		priv->stats.txlpokint,
-		priv->stats.txlperr,
-		priv->ieee80211->stats.tx_bytes,
-		priv->ieee80211->stats.tx_packets,
-		priv->stats.txresumed,
-		netif_queue_stopped(dev),
-		priv->stats.txoverflow,
-		//priv->ieee80211->ieee_stats.swtxstop,
-		//priv->ieee80211->ieee_stats.swtxawake,
-		priv->stats.txbeacon,
-		priv->stats.txbeaconerr  */
 		"TX OK: %lu\n"
 		"TX Error: %lu\n"
 		"TX Retry: %lu\n"
@@ -417,13 +316,11 @@ void rtl8180_proc_module_init(void)
         rtl8180_proc=create_proc_entry(RTL8180_MODULE_NAME, S_IFDIR, init_net.proc_net);
 }
 
-
 void rtl8180_proc_module_remove(void)
 {
         remove_proc_entry(RTL8180_MODULE_NAME, init_net.proc_net);
 }
 
-
 void rtl8180_proc_remove_one(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -431,19 +328,17 @@ void rtl8180_proc_remove_one(struct net_
 		remove_proc_entry("stats-hw", priv->dir_dev);
 		remove_proc_entry("stats-tx", priv->dir_dev);
 		remove_proc_entry("stats-rx", priv->dir_dev);
-//		remove_proc_entry("stats-ieee", priv->dir_dev);
-//		remove_proc_entry("stats-ap", priv->dir_dev);
 		remove_proc_entry("registers", priv->dir_dev);
 		remove_proc_entry(dev->name, rtl8180_proc);
 		priv->dir_dev = NULL;
 	}
 }
 
-
 void rtl8180_proc_init_one(struct net_device *dev)
 {
 	struct proc_dir_entry *e;
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+
 	priv->dir_dev = rtl8180_proc;
 	if (!priv->dir_dev) {
 		DMESGE("Unable to initialize /proc/net/r8180/%s\n",
@@ -453,7 +348,6 @@ void rtl8180_proc_init_one(struct net_de
 
 	e = create_proc_read_entry("stats-hw", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_hw, dev);
-
 	if (!e) {
 		DMESGE("Unable to initialize "
 		      "/proc/net/r8180/%s/stats-hw\n",
@@ -462,7 +356,6 @@ void rtl8180_proc_init_one(struct net_de
 
 	e = create_proc_read_entry("stats-rx", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_rx, dev);
-
 	if (!e) {
 		DMESGE("Unable to initialize "
 		      "/proc/net/r8180/%s/stats-rx\n",
@@ -472,7 +365,6 @@ void rtl8180_proc_init_one(struct net_de
 
 	e = create_proc_read_entry("stats-tx", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_tx, dev);
-
 	if (!e) {
 		DMESGE("Unable to initialize "
 		      "/proc/net/r8180/%s/stats-tx\n",
@@ -481,16 +373,13 @@ void rtl8180_proc_init_one(struct net_de
 
 	e = create_proc_read_entry("registers", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_registers, dev);
-
 	if (!e) {
 		DMESGE("Unable to initialize "
 		      "/proc/net/r8180/%s/registers\n",
 		      dev->name);
 	}
 }
-/****************************************************************************
-   -----------------------------MISC STUFF-------------------------
-*****************************************************************************/
+
 /*
   FIXME: check if we can use some standard already-existent
   data type+functions in kernel
@@ -530,7 +419,6 @@ short buffer_add(struct buffer **buffer,
 	return 0;
 }
 
-
 void buffer_free(struct net_device *dev,struct buffer **buffer,int len,short
 consistent)
 {
@@ -538,14 +426,12 @@ consistent)
 	struct buffer *tmp,*next;
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	struct pci_dev *pdev=priv->pdev;
-	//int i;
 
-	if(! *buffer) return;
+	if (!*buffer)
+		return;
 
-	/*for(tmp=*buffer; tmp->next != *buffer; tmp=tmp->next)
+	tmp = *buffer;
 
-	*/
-	tmp=*buffer;
 	do{
 		next=tmp->next;
 		if(consistent){
@@ -564,7 +450,6 @@ consistent)
 	*buffer=NULL;
 }
 
-
 void print_buffer(u32 *buffer, int len)
 {
 	int i;
@@ -583,7 +468,6 @@ void print_buffer(u32 *buffer, int len)
 	printk("\n");
 }
 
-
 int get_curr_tx_free_desc(struct net_device *dev, int priority)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
@@ -620,34 +504,33 @@ int get_curr_tx_free_desc(struct net_dev
 			return -1;
 	}
 
-	//DMESG("%x %x", head, tail);
-
-	/* FIXME FIXME FIXME FIXME */
-
-	if( head <= tail )
+	if (head <= tail)
 		ret = priv->txringcount - (tail - head)/8;
 	else
 		ret = (head - tail)/8;
 
-	if(ret > priv->txringcount ) DMESG("BUG");
+	if (ret > priv->txringcount)
+		DMESG("BUG");
+
 	return ret;
 }
 
-
 short check_nic_enought_desc(struct net_device *dev, int priority)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	struct ieee80211_device *ieee = netdev_priv(dev);
-
 	int requiredbyte, required;
+
 	requiredbyte = priv->ieee80211->fts + sizeof(struct ieee80211_header_data);
 
-	if(ieee->current_network.QoS_Enable) {
+	if (ieee->current_network.QoS_Enable)
 		requiredbyte += 2;
-	};
 
 	required = requiredbyte / (priv->txbuffsize-4);
-	if (requiredbyte % priv->txbuffsize) required++;
+
+	if (requiredbyte % priv->txbuffsize)
+		required++;
+
 	/* for now we keep two free descriptor as a safety boundary
 	 * between the tail and the head
 	 */
@@ -734,7 +617,6 @@ void fix_tx_fifo(struct net_device *dev)
 	priv->ack_tx_to_ieee = 0;
 }
 
-
 void fix_rx_fifo(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -759,39 +641,34 @@ void fix_rx_fifo(struct net_device *dev)
 	set_nic_rxring(dev);
 }
 
-
-/****************************************************************************
-      ------------------------------HW STUFF---------------------------
-*****************************************************************************/
-
 unsigned char QUALITY_MAP[] = {
-  0x64, 0x64, 0x64, 0x63, 0x63, 0x62, 0x62, 0x61,
-  0x61, 0x60, 0x60, 0x5f, 0x5f, 0x5e, 0x5d, 0x5c,
-  0x5b, 0x5a, 0x59, 0x57, 0x56, 0x54, 0x52, 0x4f,
-  0x4c, 0x49, 0x45, 0x41, 0x3c, 0x37, 0x31, 0x29,
-  0x24, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  0x22, 0x22, 0x21, 0x21, 0x21, 0x21, 0x21, 0x20,
-  0x20, 0x20, 0x20, 0x1f, 0x1f, 0x1e, 0x1e, 0x1e,
-  0x1d, 0x1d, 0x1c, 0x1c, 0x1b, 0x1a, 0x19, 0x19,
-  0x18, 0x17, 0x16, 0x15, 0x14, 0x12, 0x11, 0x0f,
-  0x0e, 0x0c, 0x0a, 0x08, 0x06, 0x04, 0x01, 0x00
+	0x64, 0x64, 0x64, 0x63, 0x63, 0x62, 0x62, 0x61,
+	0x61, 0x60, 0x60, 0x5f, 0x5f, 0x5e, 0x5d, 0x5c,
+	0x5b, 0x5a, 0x59, 0x57, 0x56, 0x54, 0x52, 0x4f,
+	0x4c, 0x49, 0x45, 0x41, 0x3c, 0x37, 0x31, 0x29,
+	0x24, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+	0x22, 0x22, 0x21, 0x21, 0x21, 0x21, 0x21, 0x20,
+	0x20, 0x20, 0x20, 0x1f, 0x1f, 0x1e, 0x1e, 0x1e,
+	0x1d, 0x1d, 0x1c, 0x1c, 0x1b, 0x1a, 0x19, 0x19,
+	0x18, 0x17, 0x16, 0x15, 0x14, 0x12, 0x11, 0x0f,
+	0x0e, 0x0c, 0x0a, 0x08, 0x06, 0x04, 0x01, 0x00
 };
 
 unsigned char STRENGTH_MAP[] = {
-  0x64, 0x64, 0x63, 0x62, 0x61, 0x60, 0x5f, 0x5e,
-  0x5d, 0x5c, 0x5b, 0x5a, 0x57, 0x54, 0x52, 0x50,
-  0x4e, 0x4c, 0x4a, 0x48, 0x46, 0x44, 0x41, 0x3f,
-  0x3c, 0x3a, 0x37, 0x36, 0x36, 0x1c, 0x1c, 0x1b,
-  0x1b, 0x1a, 0x1a, 0x19, 0x19, 0x18, 0x18, 0x17,
-  0x17, 0x16, 0x16, 0x15, 0x15, 0x14, 0x14, 0x13,
-  0x13, 0x12, 0x12, 0x11, 0x11, 0x10, 0x10, 0x0f,
-  0x0f, 0x0e, 0x0e, 0x0d, 0x0d, 0x0c, 0x0c, 0x0b,
-  0x0b, 0x0a, 0x0a, 0x09, 0x09, 0x08, 0x08, 0x07,
-  0x07, 0x06, 0x06, 0x05, 0x04, 0x03, 0x02, 0x00
+	0x64, 0x64, 0x63, 0x62, 0x61, 0x60, 0x5f, 0x5e,
+	0x5d, 0x5c, 0x5b, 0x5a, 0x57, 0x54, 0x52, 0x50,
+	0x4e, 0x4c, 0x4a, 0x48, 0x46, 0x44, 0x41, 0x3f,
+	0x3c, 0x3a, 0x37, 0x36, 0x36, 0x1c, 0x1c, 0x1b,
+	0x1b, 0x1a, 0x1a, 0x19, 0x19, 0x18, 0x18, 0x17,
+	0x17, 0x16, 0x16, 0x15, 0x15, 0x14, 0x14, 0x13,
+	0x13, 0x12, 0x12, 0x11, 0x11, 0x10, 0x10, 0x0f,
+	0x0f, 0x0e, 0x0e, 0x0d, 0x0d, 0x0c, 0x0c, 0x0b,
+	0x0b, 0x0a, 0x0a, 0x09, 0x09, 0x08, 0x08, 0x07,
+	0x07, 0x06, 0x06, 0x05, 0x04, 0x03, 0x02, 0x00
 };
 
-void rtl8180_RSSI_calc(struct net_device *dev, u8 *rssi, u8 *qual){
-	//void Mlme_UpdateRssiSQ(struct net_device *dev, u8 *rssi, u8 *qual){
+void rtl8180_RSSI_calc(struct net_device *dev, u8 *rssi, u8 *qual)
+{
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	u32 temp;
 	u32 temp2;
@@ -887,8 +764,6 @@ void rtl8180_RSSI_calc(struct net_device
 			}
 		}
 		break;
-
-	/* case 4 */
 	case RFCHIPID_MAXIM:
 		lsb = temp2 & 1;
 		temp2 &= 0x7e;
@@ -913,21 +788,14 @@ void rtl8180_RSSI_calc(struct net_device
 	return;
 }
 
-
 void rtl8180_irq_enable(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+
 	priv->irq_enabled = 1;
-/*
-	write_nic_word(dev,INTA_MASK,INTA_RXOK | INTA_RXDESCERR | INTA_RXOVERFLOW |\
-	INTA_TXOVERFLOW | INTA_HIPRIORITYDESCERR | INTA_HIPRIORITYDESCOK |\
-	INTA_NORMPRIORITYDESCERR | INTA_NORMPRIORITYDESCOK |\
-	INTA_LOWPRIORITYDESCERR | INTA_LOWPRIORITYDESCOK | INTA_TIMEOUT);
-*/
 	write_nic_word(dev,INTA_MASK, priv->irq_mask);
 }
 
-
 void rtl8180_irq_disable(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -937,10 +805,10 @@ void rtl8180_irq_disable(struct net_devi
 	priv->irq_enabled = 0;
 }
 
-
 void rtl8180_set_mode(struct net_device *dev,int mode)
 {
 	u8 ecmd;
+
 	ecmd=read_nic_byte(dev, EPROM_CMD);
 	ecmd=ecmd &~ EPROM_CMD_OPERATING_MODE_MASK;
 	ecmd=ecmd | (mode<<EPROM_CMD_OPERATING_MODE_SHIFT);
@@ -982,28 +850,21 @@ void rtl8180_update_msr(struct net_devic
 
 	write_nic_byte(dev, MSR, msr);
 	write_nic_dword(dev, RX_CONF, rxconf);
-
 }
 
-
-
 void rtl8180_set_chan(struct net_device *dev,short ch)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 
-	if((ch > 14) || (ch < 1))
-	{
+	if ((ch > 14) || (ch < 1)) {
 		printk("In %s: Invalid chnanel %d\n", __func__, ch);
 		return;
 	}
 
 	priv->chan=ch;
-	//printk("in %s:channel is %d\n",__func__,ch);
 	priv->rf_set_chan(dev,priv->chan);
-
 }
 
-
 void rtl8180_rx_enable(struct net_device *dev)
 {
 	u8 cmd;
@@ -1017,8 +878,8 @@ void rtl8180_rx_enable(struct net_device
 	rxconf = rxconf | (1<<ACCEPT_DATA_FRAME_SHIFT);
 	rxconf = rxconf | (1<<ACCEPT_BCAST_FRAME_SHIFT);
 	rxconf = rxconf | (1<<ACCEPT_MCAST_FRAME_SHIFT);
-//	rxconf = rxconf | (1<<ACCEPT_CRCERR_FRAME_SHIFT);
-	if (dev->flags & IFF_PROMISC) DMESG ("NIC in promisc mode");
+	if (dev->flags & IFF_PROMISC)
+		DMESG("NIC in promisc mode");
 
 	if(priv->ieee80211->iw_mode == IW_MODE_MONITOR || \
 	   dev->flags & IFF_PROMISC){
@@ -1029,11 +890,6 @@ void rtl8180_rx_enable(struct net_device
 			rxconf = rxconf | (1<<RX_CHECK_BSSID_SHIFT);
 	}
 
-	/*if(priv->ieee80211->iw_mode == IW_MODE_MASTER){
-		rxconf = rxconf | (1<<ACCEPT_ALLMAC_FRAME_SHIFT);
-		rxconf = rxconf | (1<<RX_CHECK_BSSID_SHIFT);
-	}*/
-
 	if(priv->ieee80211->iw_mode == IW_MODE_MONITOR){
 		rxconf = rxconf | (1<<ACCEPT_CTL_FRAME_SHIFT);
 		rxconf = rxconf | (1<<ACCEPT_ICVERR_FRAME_SHIFT);
@@ -1043,81 +899,61 @@ void rtl8180_rx_enable(struct net_device
 	if( priv->crcmon == 1 && priv->ieee80211->iw_mode == IW_MODE_MONITOR)
 		rxconf = rxconf | (1<<ACCEPT_CRCERR_FRAME_SHIFT);
 
-	//if(!priv->card_8185){
-		rxconf = rxconf &~ RX_FIFO_THRESHOLD_MASK;
-		rxconf = rxconf | (RX_FIFO_THRESHOLD_NONE<<RX_FIFO_THRESHOLD_SHIFT);
-	//}
+	rxconf = rxconf & ~RX_FIFO_THRESHOLD_MASK;
+	rxconf = rxconf | (RX_FIFO_THRESHOLD_NONE << RX_FIFO_THRESHOLD_SHIFT);
 
 	rxconf = rxconf | (1<<RX_AUTORESETPHY_SHIFT);
 	rxconf = rxconf &~ MAX_RX_DMA_MASK;
 	rxconf = rxconf | (MAX_RX_DMA_2048<<MAX_RX_DMA_SHIFT);
 
-	//if(!priv->card_8185)
-		rxconf = rxconf | RCR_ONLYERLPKT;
+	rxconf = rxconf | RCR_ONLYERLPKT;
 
 	rxconf = rxconf &~ RCR_CS_MASK;
-	if(!priv->card_8185)
+
+	if (!priv->card_8185)
 		rxconf |= (priv->rcr_csense<<RCR_CS_SHIFT);
-//	rxconf &=~ 0xfff00000;
-//	rxconf |= 0x90100000;//9014f76f;
+
 	write_nic_dword(dev, RX_CONF, rxconf);
 
 	fix_rx_fifo(dev);
 
 	cmd=read_nic_byte(dev,CMD);
 	write_nic_byte(dev,CMD,cmd | (1<<CMD_RX_ENABLE_SHIFT));
-
-	/* In rtl8139 driver seems that DMA threshold has to be written
-	 *  after enabling RX, so we rewrite RX_CONFIG register
-	 */
-	//mdelay(100);
-//	write_nic_dword(dev, RX_CONF, rxconf);
-
 }
 
-
 void set_nic_txring(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-//		DMESG("ring %x %x", priv->txlpringdma,read_nic_dword(dev,TLPDA));
 
 	write_nic_dword(dev, TX_MANAGEPRIORITY_RING_ADDR, priv->txmapringdma);
-//		DMESG("ring %x %x", priv->txlpringdma,read_nic_dword(dev,TLPDA));
 	write_nic_dword(dev, TX_BKPRIORITY_RING_ADDR, priv->txbkpringdma);
-//		DMESG("ring %x %x", priv->txlpringdma,read_nic_dword(dev,TLPDA));
 	write_nic_dword(dev, TX_BEPRIORITY_RING_ADDR, priv->txbepringdma);
-//		DMESG("ring %x %x", priv->txlpringdma,read_nic_dword(dev,TLPDA));
 	write_nic_dword(dev, TX_VIPRIORITY_RING_ADDR, priv->txvipringdma);
-//		DMESG("ring %x %x", priv->txlpringdma,read_nic_dword(dev,TLPDA));
 	write_nic_dword(dev, TX_VOPRIORITY_RING_ADDR, priv->txvopringdma);
-//		DMESG("ring %x %x", priv->txlpringdma,read_nic_dword(dev,TLPDA));
 	write_nic_dword(dev, TX_HIGHPRIORITY_RING_ADDR, priv->txhpringdma);
-//		DMESG("ring %x %x", priv->txlpringdma,read_nic_dword(dev,TLPDA));
-
 	write_nic_dword(dev, TX_BEACON_RING_ADDR, priv->txbeaconringdma);
 }
 
-
 void rtl8180_conttx_enable(struct net_device *dev)
 {
 	u32 txconf;
+
 	txconf = read_nic_dword(dev,TX_CONF);
 	txconf = txconf &~ TX_LOOPBACK_MASK;
 	txconf = txconf | (TX_LOOPBACK_CONTINUE <<TX_LOOPBACK_SHIFT);
 	write_nic_dword(dev,TX_CONF,txconf);
 }
 
-
 void rtl8180_conttx_disable(struct net_device *dev)
 {
 	u32 txconf;
+
 	txconf = read_nic_dword(dev,TX_CONF);
 	txconf = txconf &~ TX_LOOPBACK_MASK;
 	txconf = txconf | (TX_LOOPBACK_NONE <<TX_LOOPBACK_SHIFT);
 	write_nic_dword(dev,TX_CONF,txconf);
 }
 
-
 void rtl8180_tx_enable(struct net_device *dev)
 {
 	u8 cmd;
@@ -1125,12 +961,10 @@ void rtl8180_tx_enable(struct net_device
 	u8 byte;
 	u32 txconf;
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	txconf= read_nic_dword(dev,TX_CONF);
-
-
-	if(priv->card_8185){
 
+	txconf = read_nic_dword(dev, TX_CONF);
 
+	if (priv->card_8185) {
 		byte = read_nic_byte(dev,CW_CONF);
 		byte &= ~(1<<CW_CONF_PERPACKET_CW_SHIFT);
 		byte &= ~(1<<CW_CONF_PERPACKET_RETRY_SHIFT);
@@ -1141,26 +975,12 @@ void rtl8180_tx_enable(struct net_device
 		tx_agc_ctl &= ~(1<<TX_AGC_CTL_PERPACKET_ANTSEL_SHIFT);
 		tx_agc_ctl |=(1<<TX_AGC_CTL_FEEDBACK_ANT);
 		write_nic_byte(dev, TX_AGC_CTL, tx_agc_ctl);
-		/*
-		write_nic_word(dev, 0x5e, 0x01);
-		force_pci_posting(dev);
-		mdelay(1);
-		write_nic_word(dev, 0xfe, 0x10);
-		force_pci_posting(dev);
-		mdelay(1);
-		write_nic_word(dev, 0x5e, 0x00);
-		force_pci_posting(dev);
-		mdelay(1);
-		*/
 		write_nic_byte(dev, 0xec, 0x3f); /* Disable early TX */
 	}
 
-	if(priv->card_8185){
-
+	if (priv->card_8185)
 		txconf = txconf &~ (1<<TCR_PROBE_NOTIMESTAMP_SHIFT);
-
-	}else{
-
+	else {
 		if(hwseqnum)
 			txconf= txconf &~ (1<<TX_CONF_HEADER_AUTOICREMENT_SHIFT);
 		else
@@ -1175,43 +995,31 @@ void rtl8180_tx_enable(struct net_device
 	txconf = txconf | (priv->retry_rts<<TX_RTSRETRY_SHIFT);
 	txconf = txconf &~ (1<<TX_NOCRC_SHIFT);
 
-	if(priv->card_8185){
-		if(priv->hw_plcp_len)
+	if (priv->card_8185) {
+		if (priv->hw_plcp_len)
 			txconf = txconf &~ TCR_PLCP_LEN;
 		else
 			txconf = txconf | TCR_PLCP_LEN;
-	}else{
+	} else
 		txconf = txconf &~ TCR_SAT;
-	}
+
 	txconf = txconf &~ TCR_MXDMA_MASK;
 	txconf = txconf | (TCR_MXDMA_2048<<TCR_MXDMA_SHIFT);
 	txconf = txconf | TCR_CWMIN;
 	txconf = txconf | TCR_DISCW;
 
-//	if(priv->ieee80211->hw_wep)
-//		txconf=txconf &~ (1<<TX_NOICV_SHIFT);
-//	else
-		txconf=txconf | (1<<TX_NOICV_SHIFT);
+	txconf = txconf | (1 << TX_NOICV_SHIFT);
 
 	write_nic_dword(dev,TX_CONF,txconf);
 
-
 	fix_tx_fifo(dev);
 
 	cmd=read_nic_byte(dev,CMD);
 	write_nic_byte(dev,CMD,cmd | (1<<CMD_TX_ENABLE_SHIFT));
 
-//	mdelay(100);
 	write_nic_dword(dev,TX_CONF,txconf);
-//	#endif
-/*
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev, TX_DMA_POLLING, priv->dma_poll_mask);
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-	*/
 }
 
-
 void rtl8180_beacon_tx_enable(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -1222,7 +1030,6 @@ void rtl8180_beacon_tx_enable(struct net
 	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
 }
 
-
 void rtl8180_beacon_tx_disable(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -1234,7 +1041,6 @@ void rtl8180_beacon_tx_disable(struct ne
 
 }
 
-
 void rtl8180_rtx_disable(struct net_device *dev)
 {
 	u8 cmd;
@@ -1245,9 +1051,6 @@ void rtl8180_rtx_disable(struct net_devi
 		       ((1<<CMD_RX_ENABLE_SHIFT)|(1<<CMD_TX_ENABLE_SHIFT)));
 	force_pci_posting(dev);
 	mdelay(10);
-	/*while (read_nic_byte(dev,CMD) & (1<<CMD_RX_ENABLE_SHIFT))
-	  udelay(10);
-	*/
 
 	if(!priv->rx_skb_complete)
 		dev_kfree_skb_any(priv->rx_skb);
@@ -1270,20 +1073,22 @@ short alloc_tx_desc_ring(struct net_devi
 	}
 	desc = (u32*)pci_alloc_consistent(pdev,
 					  sizeof(u32)*8*count+256, &dma_desc);
-	if(desc==NULL) return -1;
-	if(dma_desc & 0xff){
+	if (desc == NULL)
+		return -1;
 
+	if (dma_desc & 0xff)
 		/*
 		 * descriptor's buffer must be 256 byte aligned
 		 * we shouldn't be here, since we set DMA mask !
 		 */
 		WARN(1, "DMA buffer is not aligned\n");
-	}
-	tmp=desc;
-	for (i=0;i<count;i++)
-	{
-		buf = (void*)pci_alloc_consistent(pdev,bufsize,&dma_tmp);
-		if (buf == NULL) return -ENOMEM;
+
+	tmp = desc;
+
+	for (i = 0; i < count; i++) {
+		buf = (void *)pci_alloc_consistent(pdev, bufsize, &dma_tmp);
+		if (buf == NULL)
+			return -ENOMEM;
 
 		switch(addr) {
 		case TX_MANAGEPRIORITY_RING_ADDR:
@@ -1292,7 +1097,6 @@ short alloc_tx_desc_ring(struct net_devi
 				return -ENOMEM;
 			}
 			break;
-
 		case TX_BKPRIORITY_RING_ADDR:
 			if(-1 == buffer_add(&(priv->txbkpbufs),buf,dma_tmp,NULL)){
 				DMESGE("Unable to allocate mem for buffer LP");
@@ -1305,7 +1109,6 @@ short alloc_tx_desc_ring(struct net_devi
 				return -ENOMEM;
 			}
 			break;
-
 		case TX_VIPRIORITY_RING_ADDR:
 			if(-1 == buffer_add(&(priv->txvipbufs),buf,dma_tmp,NULL)){
 				DMESGE("Unable to allocate mem for buffer LP");
@@ -1348,32 +1151,26 @@ short alloc_tx_desc_ring(struct net_devi
 		priv->txmapringdma=dma_desc;
 		priv->txmapring=desc;
 		break;
-
 	case TX_BKPRIORITY_RING_ADDR:
 		priv->txbkpringdma=dma_desc;
 		priv->txbkpring=desc;
 		break;
-
 	case TX_BEPRIORITY_RING_ADDR:
 		priv->txbepringdma=dma_desc;
 		priv->txbepring=desc;
 		break;
-
 	case TX_VIPRIORITY_RING_ADDR:
 		priv->txvipringdma=dma_desc;
 		priv->txvipring=desc;
 		break;
-
 	case TX_VOPRIORITY_RING_ADDR:
 		priv->txvopringdma=dma_desc;
 		priv->txvopring=desc;
 		break;
-
 	case TX_HIGHPRIORITY_RING_ADDR:
 		priv->txhpringdma=dma_desc;
 		priv->txhpring=desc;
 		break;
-
 	case TX_BEACON_RING_ADDR:
 		priv->txbeaconringdma=dma_desc;
 		priv->txbeaconring=desc;
@@ -1384,10 +1181,8 @@ short alloc_tx_desc_ring(struct net_devi
 	return 0;
 }
 
-
 void free_tx_desc_rings(struct net_device *dev)
 {
-
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	struct pci_dev *pdev=priv->pdev;
 	int count = priv->txringcount;
@@ -1426,7 +1221,6 @@ void free_rx_desc_ring(struct net_device
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	struct pci_dev *pdev = priv->pdev;
-
 	int count = priv->rxringcount;
 
 	pci_free_consistent(pdev, sizeof(u32)*8*count+256,
@@ -1435,7 +1229,6 @@ void free_rx_desc_ring(struct net_device
 	buffer_free(dev,&(priv->rxbuffer),priv->rxbuffersize,0);
 }
 
-
 short alloc_rx_desc_ring(struct net_device *dev, u16 bufsize, int count)
 {
 	int i;
@@ -1457,21 +1250,18 @@ short alloc_rx_desc_ring(struct net_devi
 	desc = (u32*)pci_alloc_consistent(pdev,sizeof(u32)*rx_desc_size*count+256,
 					  &dma_desc);
 
-	if(dma_desc & 0xff){
-
+	if (dma_desc & 0xff)
 		/*
 		 * descriptor's buffer must be 256 byte aligned
 		 * should never happen since we specify the DMA mask
 		 */
 		WARN(1, "DMA buffer is not aligned\n");
-	}
 
 	priv->rxring=desc;
 	priv->rxringdma=dma_desc;
 	tmp=desc;
 
-	for (i=0;i<count;i++){
-
+	for (i = 0; i < count; i++) {
 		if ((buf= kmalloc(bufsize * sizeof(u8),GFP_ATOMIC)) == NULL){
 			DMESGE("Failed to kmalloc RX buffer");
 			return -1;
@@ -1480,7 +1270,6 @@ short alloc_rx_desc_ring(struct net_devi
 		dma_tmp = pci_map_single(pdev,buf,bufsize * sizeof(u8),
 					 PCI_DMA_FROMDEVICE);
 
-		//buf = (void*)pci_alloc_consistent(pdev,bufsize,&dma_tmp);
 		if(-1 == buffer_add(&(priv->rxbuffer), buf,dma_tmp,
 			   &(priv->rxbufferhead))){
 			   DMESGE("Unable to allocate mem RX buf");
@@ -1505,24 +1294,16 @@ void set_nic_rxring(struct net_device *d
 	u8 pgreg;
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 
-	//rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
-
 	pgreg=read_nic_byte(dev, PGSELECT);
 	write_nic_byte(dev, PGSELECT, pgreg &~ (1<<PGSELECT_PG_SHIFT));
 
-	//rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
-
 	write_nic_dword(dev, RXRING_ADDR,priv->rxringdma);
 }
 
-
 void rtl8180_reset(struct net_device *dev)
 {
-	//u32 txconf = 0x80e00707; //FIXME: Make me understandable
 	u8 cr;
 
-	//write_nic_dword(dev,TX_CONF,txconf);
-
 	rtl8180_irq_disable(dev);
 
 	cr=read_nic_byte(dev,CMD);
@@ -1539,83 +1320,80 @@ void rtl8180_reset(struct net_device *de
 	else
 		DMESG("Card successfully reset");
 
-//#ifndef CONFIG_RTL8185B
 	rtl8180_set_mode(dev,EPROM_CMD_LOAD);
 	force_pci_posting(dev);
 	mdelay(200);
-//#endif
 }
 
 inline u16 ieeerate2rtlrate(int rate)
 {
 	switch(rate){
 	case 10:
-	return 0;
+		return 0;
 	case 20:
-	return 1;
+		return 1;
 	case 55:
-	return 2;
+		return 2;
 	case 110:
-	return 3;
+		return 3;
 	case 60:
-	return 4;
+		return 4;
 	case 90:
-	return 5;
+		return 5;
 	case 120:
-	return 6;
+		return 6;
 	case 180:
-	return 7;
+		return 7;
 	case 240:
-	return 8;
+		return 8;
 	case 360:
-	return 9;
+		return 9;
 	case 480:
-	return 10;
+		return 10;
 	case 540:
-	return 11;
+		return 11;
 	default:
-	return 3;
-
+		return 3;
 	}
 }
 
 static u16 rtl_rate[] = {10,20,55,110,60,90,120,180,240,360,480,540,720};
+
 inline u16 rtl8180_rate2rate(short rate)
 {
-	if (rate >12) return 10;
+	if (rate > 12)
+		return 10;
 	return rtl_rate[rate];
 }
+
 inline u8 rtl8180_IsWirelessBMode(u16 rate)
 {
 	if( ((rate <= 110) && (rate != 60) && (rate != 90)) || (rate == 220) )
 		return 1;
-	else return 0;
+	else
+		return 0;
 }
+
 u16 N_DBPSOfRate(u16 DataRate);
-u16 ComputeTxTime(
-	u16		FrameLength,
-	u16		DataRate,
-	u8		bManagementFrame,
-	u8		bShortPreamble
-)
+
+u16 ComputeTxTime(u16 FrameLength, u16 DataRate, u8 bManagementFrame,
+		  u8 bShortPreamble)
 {
 	u16	FrameTime;
 	u16	N_DBPS;
 	u16	Ceiling;
 
-	if( rtl8180_IsWirelessBMode(DataRate) )
-	{
-		if( bManagementFrame || !bShortPreamble || DataRate == 10 )
-		{	// long preamble
+	if (rtl8180_IsWirelessBMode(DataRate)) {
+		if (bManagementFrame || !bShortPreamble || DataRate == 10)
+			/* long preamble */
 			FrameTime = (u16)(144+48+(FrameLength*8/(DataRate/10)));
-		}
 		else
-		{	// Short preamble
+			/* short preamble */
 			FrameTime = (u16)(72+24+(FrameLength*8/(DataRate/10)));
-		}
-		if( ( FrameLength*8 % (DataRate/10) ) != 0 ) //Get the Ceilling
-				FrameTime ++;
-	} else {	//802.11g DSSS-OFDM PLCP length field calculation.
+
+		if ((FrameLength*8 % (DataRate/10)) != 0) /* get the ceilling */
+			FrameTime++;
+	} else {	/* 802.11g DSSS-OFDM PLCP length field calculation. */
 		N_DBPS = N_DBPSOfRate(DataRate);
 		Ceiling = (16 + 8*FrameLength + 6) / N_DBPS
 				+ (((16 + 8*FrameLength + 6) % N_DBPS) ? 1 : 0);
@@ -1623,49 +1401,41 @@ u16 ComputeTxTime(
 	}
 	return FrameTime;
 }
+
 u16 N_DBPSOfRate(u16 DataRate)
 {
 	 u16 N_DBPS = 24;
 
-	 switch(DataRate)
-	 {
-	 case 60:
-	  N_DBPS = 24;
-	  break;
-
-	 case 90:
-	  N_DBPS = 36;
-	  break;
-
-	 case 120:
-	  N_DBPS = 48;
-	  break;
-
-	 case 180:
-	  N_DBPS = 72;
-	  break;
-
-	 case 240:
-	  N_DBPS = 96;
-	  break;
-
-	 case 360:
-	  N_DBPS = 144;
-	  break;
-
-	 case 480:
-	  N_DBPS = 192;
-	  break;
-
-	 case 540:
-	  N_DBPS = 216;
-	  break;
-
-	 default:
-	  break;
-	 }
+	switch (DataRate) {
+	case 60:
+		N_DBPS = 24;
+		break;
+	case 90:
+		N_DBPS = 36;
+		break;
+	case 120:
+		N_DBPS = 48;
+		break;
+	case 180:
+		N_DBPS = 72;
+		break;
+	case 240:
+		N_DBPS = 96;
+		break;
+	case 360:
+		N_DBPS = 144;
+		break;
+	case 480:
+		N_DBPS = 192;
+		break;
+	case 540:
+		N_DBPS = 216;
+		break;
+	default:
+		break;
+	}
 
-	 return N_DBPS;
+	return N_DBPS;
 }
 
 //{by amy 080312
@@ -1674,76 +1444,46 @@ u16 N_DBPSOfRate(u16 DataRate)
 // 	For Netgear case, they want good-looking singal strength.
 //		2004.12.05, by rcnjko.
 //
-long
-NetgearSignalStrengthTranslate(
-	long LastSS,
-	long CurrSS
-	)
+long NetgearSignalStrengthTranslate(long LastSS, long CurrSS)
 {
 	long RetSS;
 
 	// Step 1. Scale mapping.
-	if(CurrSS >= 71 && CurrSS <= 100)
-	{
+	if (CurrSS >= 71 && CurrSS <= 100)
 		RetSS = 90 + ((CurrSS - 70) / 3);
-	}
-	else if(CurrSS >= 41 && CurrSS <= 70)
-	{
+	else if (CurrSS >= 41 && CurrSS <= 70)
 		RetSS = 78 + ((CurrSS - 40) / 3);
-	}
-	else if(CurrSS >= 31 && CurrSS <= 40)
-	{
+	else if (CurrSS >= 31 && CurrSS <= 40)
 		RetSS = 66 + (CurrSS - 30);
-	}
-	else if(CurrSS >= 21 && CurrSS <= 30)
-	{
+	else if (CurrSS >= 21 && CurrSS <= 30)
 		RetSS = 54 + (CurrSS - 20);
-	}
-	else if(CurrSS >= 5 && CurrSS <= 20)
-	{
+	else if (CurrSS >= 5 && CurrSS <= 20)
 		RetSS = 42 + (((CurrSS - 5) * 2) / 3);
-	}
-	else if(CurrSS == 4)
-	{
+	else if (CurrSS == 4)
 		RetSS = 36;
-	}
-	else if(CurrSS == 3)
-	{
+	else if (CurrSS == 3)
 		RetSS = 27;
-	}
-	else if(CurrSS == 2)
-	{
+	else if (CurrSS == 2)
 		RetSS = 18;
-	}
-	else if(CurrSS == 1)
-	{
+	else if (CurrSS == 1)
 		RetSS = 9;
-	}
 	else
-	{
 		RetSS = CurrSS;
-	}
-	//RT_TRACE(COMP_DBG, DBG_LOUD, ("##### After Mapping:  LastSS: %d, CurrSS: %d, RetSS: %d\n", LastSS, CurrSS, RetSS));
 
 	// Step 2. Smoothing.
 	if(LastSS > 0)
-	{
 		RetSS = ((LastSS * 5) + (RetSS)+ 5) / 6;
-	}
-	//RT_TRACE(COMP_DBG, DBG_LOUD, ("$$$$$ After Smoothing:  LastSS: %d, CurrSS: %d, RetSS: %d\n", LastSS, CurrSS, RetSS));
 
 	return RetSS;
 }
+
 //
 //	Description:
 //		Translate 0-100 signal strength index into dBm.
 //
-long
-TranslateToDbm8185(
-	u8 SignalStrengthIndex	// 0-100 index.
-	)
+long TranslateToDbm8185(u8 SignalStrengthIndex)
 {
-	long	SignalPower; // in dBm.
+	long SignalPower;
 
 	// Translate to dBm (x=0.5y-95).
 	SignalPower = (long)((SignalStrengthIndex + 1) >> 1);
@@ -1751,6 +1491,7 @@ TranslateToDbm8185(
 
 	return SignalPower;
 }
+
 //
 //	Description:
 //		Perform signal smoothing for dynamic mechanism.
@@ -1759,53 +1500,23 @@ TranslateToDbm8185(
 //		of correctness. Ported from 8187B.
 //	2007-02-26, by Bruce.
 //
-void
-PerformUndecoratedSignalSmoothing8185(
-	struct r8180_priv *priv,
-	bool    bCckRate
-	)
+void PerformUndecoratedSignalSmoothing8185(struct r8180_priv *priv,
+					   bool bCckRate)
 {
-
-
 	// Determin the current packet is CCK rate.
 	priv->bCurCCKPkt = bCckRate;
 
-	if(priv->UndecoratedSmoothedSS >= 0)
-	{
+	if (priv->UndecoratedSmoothedSS >= 0)
 		priv->UndecoratedSmoothedSS = ( (priv->UndecoratedSmoothedSS * 5) + (priv->SignalStrength * 10) ) / 6;
-	}
 	else
-	{
 		priv->UndecoratedSmoothedSS = priv->SignalStrength * 10;
-	}
 
 	priv->UndercorateSmoothedRxPower = ( (priv->UndercorateSmoothedRxPower * 50) + (priv->RxPower* 11)) / 60;
 
-//	printk("Sommthing SignalSterngth (%d) => UndecoratedSmoothedSS (%d)\n", priv->SignalStrength, priv->UndecoratedSmoothedSS);
-//	printk("Sommthing RxPower (%d) => UndecoratedRxPower (%d)\n", priv->RxPower, priv->UndercorateSmoothedRxPower);
-
-	//if(priv->CurCCKRSSI >= 0 && bCckRate)
-	if(bCckRate)
-	{
+	if (bCckRate)
 		priv->CurCCKRSSI = priv->RSSI;
-	}
 	else
-	{
 		priv->CurCCKRSSI = 0;
-	}
-
-	// Boundary checking.
-	// TODO: The overflow condition does happen, if we want to fix,
-	// we shall recalculate thresholds first.
-	if(priv->UndecoratedSmoothedSS > 100)
-	{
-//		printk("UndecoratedSmoothedSS(%d) overflow, SignalStrength(%d)\n", priv->UndecoratedSmoothedSS, priv->SignalStrength);
-	}
-	if(priv->UndecoratedSmoothedSS < 0)
-	{
-//		printk("UndecoratedSmoothedSS(%d) underflow, SignalStrength(%d)\n", priv->UndecoratedSmoothedSS, priv->SignalStrength);
-	}
-
 }
 
 //by amy 080312}
@@ -1815,70 +1526,47 @@ void rtl8180_rx(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	struct sk_buff *tmp_skb;
-
-	//struct sk_buff *skb;
 	short first,last;
 	u32 len;
 	int lastlen;
 	unsigned char quality, signal;
 	u8 rate;
-	//u32 *prism_hdr;
 	u32 *tmp,*tmp2;
 	u8 rx_desc_size;
 	u8 padding;
-	//u32 count=0;
 	char rxpower = 0;
 	u32 RXAGC = 0;
 	long RxAGC_dBm = 0;
 	u8	LNA=0, BB=0;
 	u8 	LNA_gain[4]={02, 17, 29, 39};
 	u8  Antenna = 0;
-	struct ieee80211_hdr *hdr;//by amy
+	struct ieee80211_hdr *hdr;
 	u16 fc,type;
 	u8 bHwError = 0,bCRC = 0,bICV = 0;
-	//bHwError = 0;
-	//bCRC = 0;
-	//bICV = 0;
 	bool	bCckRate = false;
 	u8     RSSI = 0;
-	long	SignalStrengthIndex = 0;//+by amy 080312
-//	u8 SignalStrength = 0;
+	long	SignalStrengthIndex = 0;
 	struct ieee80211_rx_stats stats = {
 		.signal = 0,
 		.noise = -98,
 		.rate = 0,
-	//	.mac_time = jiffies,
 		.freq = IEEE80211_24GHZ_BAND,
 	};
 
 	stats.nic_type = NIC_8185B;
 	rx_desc_size = 8;
 
-	//printk("receive frame!%d\n",count++);
-	//if (!priv->rxbuffer) DMESG ("EE: NIC RX ack, but RX queue corrupted!");
-	//else {
-
 	if ((*(priv->rxringtail)) & (1<<31)) {
-
 		/* we have got an RX int, but the descriptor
 		 * we are pointing is empty*/
 
 		priv->stats.rxnodata++;
 		priv->ieee80211->stats.rx_errors++;
 
-	/*	if (! *(priv->rxring) & (1<<31)) {
-
-			priv->stats.rxreset++;
-			priv->rxringtail=priv->rxring;
-			priv->rxbuffer=priv->rxbufferhead;
-
-		}else{*/
-
 		tmp2 = NULL;
 		tmp = priv->rxringtail;
 		do{
 			if(tmp == priv->rxring)
-				//tmp  = priv->rxring + (priv->rxringcount )*rx_desc_size; xiong-2006-11-15
 				tmp  = priv->rxring + (priv->rxringcount - 1)*rx_desc_size;
 			else
 				tmp -= rx_desc_size;
@@ -1888,7 +1576,6 @@ void rtl8180_rx(struct net_device *dev)
 		}while(tmp != priv->rxring);
 
 		if(tmp2) priv->rxringtail = tmp2;
-		//}
 	}
 
 	/* while there are filled descriptors */
@@ -1930,7 +1617,6 @@ void rtl8180_rx(struct net_device *dev)
 				len=lastlen-priv->rx_prevlen;
 
 			if(*(priv->rxringtail) & (1<<13)) {
-//lastlen=((*priv->rxringtail) &0xfff);
 				if ((*(priv->rxringtail) & 0xfff) <500)
 					priv->stats.rxcrcerrmin++;
 				else if ((*(priv->rxringtail) & 0x0fff) >1000)
@@ -1982,9 +1668,7 @@ void rtl8180_rx(struct net_device *dev)
 			((1<<23)|(1<<22)|(1<<21)|(1<<20)))>>20;
 
 		stats.rate = rtl8180_rate2rate(rate);
-		//DMESG("%d",rate);
 		Antenna = (((*(priv->rxringtail +3))& (0x00008000)) == 0 )? 0:1 ;
-//		printk("in rtl8180_rx():Antenna is %d\n",Antenna);
 //by amy for antenna
 		if(!rtl8180_IsWirelessBMode(stats.rate))
 		{ // OFDM rate.
@@ -2089,12 +1773,6 @@ void rtl8180_rx(struct net_device *dev)
 			}
 
 //by amy for antenna
-
-
-
-
-
-
 #ifndef DUMMY_RX
 		if(first){
 			if(!priv->rx_skb_complete){
@@ -2164,16 +1842,13 @@ void rtl8180_rx(struct net_device *dev)
 		}
 
 #endif //DUMMY_RX
-
 		pci_dma_sync_single_for_device(priv->pdev,
 				    priv->rxbuffer->dma,
 				    priv->rxbuffersize * \
 				    sizeof(u8),
 				    PCI_DMA_FROMDEVICE);
 
-
 drop: // this is used when we have not enought mem
-
 		/* restore the descriptor */
 		*(priv->rxringtail+2)=priv->rxbuffer->dma;
 		*(priv->rxringtail)=*(priv->rxringtail) &~ 0xfff;
@@ -2182,32 +1857,14 @@ drop: // this is used when we have not e
 
 		*(priv->rxringtail)=
 			*(priv->rxringtail) | (1<<31);
-			//^empty descriptor
-
-			//wmb();
-
-		//unsigned long flags;
-		//spin_lock_irqsave(&priv->irq_lock,flags);
 
 		priv->rxringtail+=rx_desc_size;
 		if(priv->rxringtail >=
 		   (priv->rxring)+(priv->rxringcount )*rx_desc_size)
 			priv->rxringtail=priv->rxring;
 
-		//spin_unlock_irqrestore(&priv->irq_lock,flags);
-
-
 		priv->rxbuffer=(priv->rxbuffer->next);
-
 	}
-
-
-
-//	if(get_curr_tx_free_desc(dev,priority))
-//	ieee80211_sta_ps_sleep(priv->ieee80211, &tmp, &tmp2);
-
-
-
 }
 
 
@@ -2216,33 +1873,6 @@ void rtl8180_dma_kick(struct net_device 
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 
 	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-/*
-
-	switch(priority){
-
-		case LOW_PRIORITY:
-
-		write_nic_byte(dev,TX_DMA_POLLING,
-		       (1<< TX_DMA_POLLING_LOWPRIORITY_SHIFT) |
-			        priv->dma_poll_mask);
-		break;
-
-		case NORM_PRIORITY:
-
-		write_nic_byte(dev,TX_DMA_POLLING,
-		       (1<< TX_DMA_POLLING_NORMPRIORITY_SHIFT) |
-			        priv->dma_poll_mask);
-		break;
-
-		case HI_PRIORITY:
-
-		write_nic_byte(dev,TX_DMA_POLLING,
-		       (1<< TX_DMA_POLLING_HIPRIORITY_SHIFT) |
-			        priv->dma_poll_mask);
-		break;
-
-	}
-*/
 	write_nic_byte(dev, TX_DMA_POLLING,
 			(1 << (priority + 1)) | priv->dma_poll_mask);
 	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
@@ -2260,7 +1890,6 @@ void rtl8180_data_hard_stop(struct net_d
 	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
 }
 
-
 void rtl8180_data_hard_resume(struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
@@ -2271,7 +1900,6 @@ void rtl8180_data_hard_resume(struct net
 	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
 }
 
-
 /* this function TX data frames when the ieee80211 stack requires this.
  * It checks also if we need to stop the ieee tx queue, eventually do it
  */
@@ -2284,7 +1912,6 @@ rate)
 	short morefrag = (h->frame_ctl) & IEEE80211_FCTL_MOREFRAGS;
 	unsigned long flags;
 	int priority;
-	//static int count = 0;
 
 	mode = priv->ieee80211->iw_mode;
 
@@ -2306,22 +1933,16 @@ rate)
 		return;
 	}
 
-	//printk(KERN_WARNING "priority = %d@%d\n", priority, count++);
 	if (!check_nic_enought_desc(dev, priority)){
-		//DMESG("Error: no descriptor left by previous TX (avail %d) ",
-		//	get_curr_tx_free_desc(dev, priority));
 		DMESGW("Error: no descriptor left by previous TX (avail %d) ",
 			get_curr_tx_free_desc(dev, priority));
-	//printk(KERN_WARNING "==============================================================> \n");
 		ieee80211_stop_queue(priv->ieee80211);
 	}
 	rtl8180_tx(dev, skb->data, skb->len, priority, morefrag,0,rate);
 	if (!check_nic_enought_desc(dev, priority))
 		ieee80211_stop_queue(priv->ieee80211);
 
-	//dev_kfree_skb_any(skb);
 	spin_unlock_irqrestore(&priv->tx_lock,flags);
-
 }
 
 /* This is a rough attempt to TX a frame
@@ -2338,19 +1959,15 @@ rate)
 int rtl8180_hard_start_xmit(struct sk_buff *skb,struct net_device *dev)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-
 	unsigned long flags;
-
 	int priority;
 
 	priority = MANAGE_PRIORITY;
 
 	spin_lock_irqsave(&priv->tx_lock,flags);
 
-	if(priv->ieee80211->bHwRadioOff)
-	{
+	if (priv->ieee80211->bHwRadioOff) {
 		spin_unlock_irqrestore(&priv->tx_lock,flags);
-
 		dev_kfree_skb_any(skb);
 		return 0;
 	}
@@ -2381,7 +1998,6 @@ u16 rtl8180_len2duration(u32 len, short 
 		if(drift ==0 ) break;
 		duration++;
 		break;
-
 	case 1://2mbps
 		*ext=0;
 		duration = ((len+4)<<4) /0x4;
@@ -2389,7 +2005,6 @@ u16 rtl8180_len2duration(u32 len, short 
 		if(drift ==0 ) break;
 		duration++;
 		break;
-
 	case 2: //5.5mbps
 		*ext=0;
 		duration = ((len+4)<<4) /0xb;
@@ -2398,7 +2013,6 @@ u16 rtl8180_len2duration(u32 len, short 
 			break;
 		duration++;
 		break;
-
 	default:
 	case 3://11mbps
 		*ext=0;
@@ -2416,12 +2030,9 @@ u16 rtl8180_len2duration(u32 len, short 
 	return duration;
 }
 
-
 void rtl8180_prepare_beacon(struct net_device *dev)
 {
-
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-
 	struct sk_buff *skb;
 
 	u16 word  = read_nic_word(dev, BcnItv);
@@ -2429,7 +2040,6 @@ void rtl8180_prepare_beacon(struct net_d
 	word |= cpu_to_le16(priv->ieee80211->current_network.beacon_interval);//0x64;
 	write_nic_word(dev, BcnItv, word);
 
-
 	skb = ieee80211_get_beacon(priv->ieee80211);
 	if(skb){
 		rtl8180_tx(dev,skb->data,skb->len,BEACON_PRIORITY,
@@ -2453,19 +2063,14 @@ short rtl8180_tx(struct net_device *dev,
 	int remain;
 	int buflen;
 	int count;
-	//u16	AckCtsTime;
-	//u16	FrameTime;
 	u16 duration;
 	short ext;
 	struct buffer* buflist;
-	//unsigned long flags;
 	struct ieee80211_hdr_3addr *frag_hdr = (struct ieee80211_hdr_3addr *)txbuf;
 	u8 dest[ETH_ALEN];
 	u8			bUseShortPreamble = 0;
 	u8			bCTSEnable = 0;
 	u8			bRTSEnable = 0;
-	//u16			RTSRate = 22;
-	//u8			RetryLimit = 0;
 	u16 			Duration = 0;
 	u16			RtsDur = 0;
 	u16			ThisFrameTime = 0;
@@ -2479,56 +2084,47 @@ short rtl8180_tx(struct net_device *dev,
 		buflist = priv->txmapbufstail;
 		count = priv->txringcount;
 		break;
-
 	case BK_PRIORITY:
 		tail=priv->txbkpringtail;
 		begin=priv->txbkpring;
 		buflist = priv->txbkpbufstail;
 		count = priv->txringcount;
 		break;
-
 	case BE_PRIORITY:
 		tail=priv->txbepringtail;
 		begin=priv->txbepring;
 		buflist = priv->txbepbufstail;
 		count = priv->txringcount;
 		break;
-
 	case VI_PRIORITY:
 		tail=priv->txvipringtail;
 		begin=priv->txvipring;
 		buflist = priv->txvipbufstail;
 		count = priv->txringcount;
 		break;
-
 	case VO_PRIORITY:
 		tail=priv->txvopringtail;
 		begin=priv->txvopring;
 		buflist = priv->txvopbufstail;
 		count = priv->txringcount;
 		break;
-
 	case HI_PRIORITY:
 		tail=priv->txhpringtail;
 		begin=priv->txhpring;
 		buflist = priv->txhpbufstail;
 		count = priv->txringcount;
 		break;
-
 	case BEACON_PRIORITY:
 		tail=priv->txbeaconringtail;
 		begin=priv->txbeaconring;
 		buflist = priv->txbeaconbufstail;
 		count = priv->txbeaconcount;
 		break;
-
 	default:
 		return -1;
 		break;
  	}
 
-	//printk("in rtl8180_tx(): rate is %d\n",priv->ieee80211->rate);
-#if 1
 		memcpy(&dest, frag_hdr->addr1, ETH_ALEN);
 		if (is_multicast_ether_addr(dest) ||
 				is_broadcast_ether_addr(dest))
@@ -2541,20 +2137,13 @@ short rtl8180_tx(struct net_device *dev,
 			ThisFrameTime = ComputeTxTime(len + sCrcLng, rtl8180_rate2rate(rate), 0, bUseShortPreamble);
 			TxDescDuration = ThisFrameTime;
 		} else {// Unicast packet
-			//u8 AckRate;
 			u16 AckTime;
 
 			//YJ,add,080828,for Keep alive
 			priv->NumTxUnicast++;
 
 			// Figure out ACK rate according to BSS basic rate and Tx rate, 2006.03.08 by rcnjko.
-			//AckRate = ComputeAckRate( pMgntInfo->mBrates, (u1Byte)(pTcb->DataRate) );
-			// Figure out ACK time according to the AckRate and assume long preamble is used on receiver, 2006.03.08, by rcnjko.
-			//AckTime = ComputeTxTime( sAckCtsLng/8, AckRate, FALSE, FALSE);
-			//For simplicity, just use the 1M basic rate
-			//AckTime = ComputeTxTime(14, 540,0, 0);	// AckCTSLng = 14 use 1M bps send
 			AckTime = ComputeTxTime(14, 10,0, 0);	// AckCTSLng = 14 use 1M bps send
-			//AckTime = ComputeTxTime(14, 2,false, false);	// AckCTSLng = 14 use 1M bps send
 
 			if ( ((len + sCrcLng) > priv->rts) && priv->rts )
 			{ // RTS/CTS.
@@ -2605,30 +2194,24 @@ short rtl8180_tx(struct net_device *dev,
 		} // End of Unicast packet
 
 		frag_hdr->duration_id = Duration;
-#endif
 
 	buflen=priv->txbuffsize;
 	remain=len;
 	temp_tail = tail;
-//printk("================================>buflen = %d, remain = %d!\n", buflen,remain);
+
 	while(remain!=0){
 		mb();
 		if(!buflist){
 			DMESGE("TX buffer error, cannot TX frames. pri %d.", priority);
-			//spin_unlock_irqrestore(&priv->tx_lock,flags);
 			return -1;
 		}
 		buf=buflist->buf;
 
-		if( (*tail & (1<<31)) && (priority != BEACON_PRIORITY)){
-
-				DMESGW("No more TX desc, returning %x of %x",
-				remain,len);
-				priv->stats.txrdu++;
-			//	spin_unlock_irqrestore(&priv->tx_lock,flags);
-
+		if ((*tail & (1 << 31)) && (priority != BEACON_PRIORITY)) {
+			DMESGW("No more TX desc, returning %x of %x",
+			       remain, len);
+			priv->stats.txrdu++;
 			return remain;
-
 		}
 
 		*tail= 0; // zeroes header
@@ -2641,9 +2224,8 @@ short rtl8180_tx(struct net_device *dev,
 		if(priv->card_8185){
 			//FIXME: this should be triggered by HW encryption parameters.
 			*tail |= (1<<15); //no encrypt
-//			*tail |= (1<<30); //raise int when completed
 		}
-	//	*tail = *tail | (1<<16);
+
 		if(remain==len && !descfrag) {
 			ownbit_flag = false;	//added by david woo,2007.12.14
 			*tail = *tail| (1<<29) ; //fist segment of the packet
@@ -2681,19 +2263,11 @@ short rtl8180_tx(struct net_device *dev,
         	*(tail+5) |= (11<<8);//(priv->retry_data<<8); //retry lim ;
 
 		*tail = *tail | ((rate&0xf) << 24);
-		//DMESG("rate %d",rate);
-
-		if(priv->card_8185){
-           //    	*(tail+5) = 0;
-		}
 
 		/* hw_plcp_len is not used for rtl8180 chip */
 		/* FIXME */
 		if(priv->card_8185 == 0 || !priv->hw_plcp_len){
-
-			duration = rtl8180_len2duration(len,
-				rate,&ext);
-
+			duration = rtl8180_len2duration(len, rate, &ext);
 			*(tail+1) = *(tail+1) | ((duration & 0x7fff)<<16);
 			if(ext) *(tail+1) = *(tail+1) |(1<<31); //plcp length extension
 		}
@@ -2712,7 +2286,6 @@ short rtl8180_tx(struct net_device *dev,
 
 		if((tail - begin)/8 == count-1)
 			tail=begin;
-
 		else
 			tail=tail+8;
 
@@ -2725,75 +2298,56 @@ short rtl8180_tx(struct net_device *dev,
 				priv->txmapringtail=tail;
 				priv->txmapbufstail=buflist;
 				break;
-
 			case BK_PRIORITY:
 				priv->txbkpringtail=tail;
 				priv->txbkpbufstail=buflist;
 				break;
-
 			case BE_PRIORITY:
 				priv->txbepringtail=tail;
 				priv->txbepbufstail=buflist;
 				break;
-
 			case VI_PRIORITY:
 				priv->txvipringtail=tail;
 				priv->txvipbufstail=buflist;
 				break;
-
 			case VO_PRIORITY:
 				priv->txvopringtail=tail;
 				priv->txvopbufstail=buflist;
 				break;
-
 			case HI_PRIORITY:
 				priv->txhpringtail=tail;
 				priv->txhpbufstail = buflist;
 				break;
-
 			case BEACON_PRIORITY:
 				/* the HW seems to be happy with the 1st
 				 * descriptor filled and the 2nd empty...
 				 * So always update descriptor 1 and never
 				 * touch 2nd
 				 */
-			//	priv->txbeaconringtail=tail;
-			//	priv->txbeaconbufstail=buflist;
-
 				break;
-
 		}
-
-		//rtl8180_dma_kick(dev,priority);
 	}
 	*temp_tail = *temp_tail | (1<<31); // descriptor ready to be txed
 	rtl8180_dma_kick(dev,priority);
-	//spin_unlock_irqrestore(&priv->tx_lock,flags);
 
 	return 0;
-
 }
 
-
 void rtl8180_irq_rx_tasklet(struct r8180_priv * priv);
 
-
 void rtl8180_link_change(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	u16 beacon_interval;
-
 	struct ieee80211_network *net = &priv->ieee80211->current_network;
-//	rtl8180_adapter_start(dev);
-	rtl8180_update_msr(dev);
 
+	rtl8180_update_msr(dev);
 
 	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
 
 	write_nic_dword(dev,BSSID,((u32*)net->bssid)[0]);
 	write_nic_word(dev,BSSID+4,((u16*)net->bssid)[2]);
 
-
 	beacon_interval  = read_nic_dword(dev,BEACON_INTERVAL);
 	beacon_interval &= ~ BEACON_INTERVAL_MASK;
 	beacon_interval |= net->beacon_interval;
@@ -2801,23 +2355,14 @@ void rtl8180_link_change(struct net_devi
 
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
 
-
-	/*
-	u16 atim = read_nic_dword(dev,ATIM);
-	u16 = u16 &~ ATIM_MASK;
-	u16 = u16 | beacon->atim;
-	*/
-
 	if(priv->card_8185)
 		rtl8180_set_chan(dev, priv->chan);
-
-
 }
 
 void rtl8180_rq_tx_ack(struct net_device *dev){
 
 	struct r8180_priv *priv = ieee80211_priv(dev);
-//	printk("====================>%s\n",__func__);
+
 	write_nic_byte(dev,CONFIG4,read_nic_byte(dev,CONFIG4)|CONFIG4_PWRMGT);
 	priv->ack_tx_to_ieee = 1;
 }
@@ -2858,39 +2403,29 @@ short rtl8180_is_tx_queue_empty(struct n
 void rtl8180_hw_wakeup(struct net_device *dev)
 {
 	unsigned long flags;
-
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
 	spin_lock_irqsave(&priv->ps_lock,flags);
-	//DMESG("Waken up!");
 	write_nic_byte(dev,CONFIG4,read_nic_byte(dev,CONFIG4)&~CONFIG4_PWRMGT);
-
-	if(priv->rf_wakeup)
+	if (priv->rf_wakeup)
 		priv->rf_wakeup(dev);
-//	mdelay(HW_WAKE_DELAY);
 	spin_unlock_irqrestore(&priv->ps_lock,flags);
 }
 
 void rtl8180_hw_sleep_down(struct net_device *dev)
 {
         unsigned long flags;
-
         struct r8180_priv *priv = ieee80211_priv(dev);
 
         spin_lock_irqsave(&priv->ps_lock,flags);
-       //DMESG("Sleep!");
-
         if(priv->rf_sleep)
                 priv->rf_sleep(dev);
         spin_unlock_irqrestore(&priv->ps_lock,flags);
 }
 
-
 void rtl8180_hw_sleep(struct net_device *dev, u32 th, u32 tl)
 {
-
 	struct r8180_priv *priv = ieee80211_priv(dev);
-
 	u32 rb = jiffies;
 	unsigned long flags;
 
@@ -2901,14 +2436,6 @@ void rtl8180_hw_sleep(struct net_device 
 	 */
 	tl -= MSECS(4+16+7);
 
-	//if(tl == 0) tl = 1;
-
-	/* FIXME HACK FIXME HACK */
-//	force_pci_posting(dev);
-	//mdelay(1);
-
-//	rb = read_nic_dword(dev, TSFTR);
-
 	/* If the interval in witch we are requested to sleep is too
 	 * short then give up and remain awake
 	 */
@@ -2919,13 +2446,9 @@ void rtl8180_hw_sleep(struct net_device 
 		return;
 	}
 
-//	write_nic_dword(dev, TimerInt, tl);
-//	rb = read_nic_dword(dev, TSFTR);
 	{
 		u32 tmp = (tl>rb)?(tl-rb):(rb-tl);
-	//	if (tl<rb)
 
-		//lzm,add,080828
 		priv->DozePeriodInPast2Sec += jiffies_to_msecs(tmp);
 
 		queue_delayed_work(priv->ieee80211->wq, &priv->ieee80211->hw_wakeup_wq, tmp); //as tl may be less than rb
@@ -2933,26 +2456,20 @@ void rtl8180_hw_sleep(struct net_device 
 	/* if we suspect the TimerInt is gone beyond tl
 	 * while setting it, then give up
 	 */
-#if 1
+
 	if(((tl > rb) && ((tl-rb) > MSECS(MAX_SLEEP_TIME)))||
 		((tl < rb) && ((rb-tl) > MSECS(MAX_SLEEP_TIME)))) {
 		spin_unlock_irqrestore(&priv->ps_lock,flags);
 		return;
 	}
-#endif
-//	if(priv->rf_sleep)
-//		priv->rf_sleep(dev);
 
 	queue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->hw_sleep_wq);
 	spin_unlock_irqrestore(&priv->ps_lock,flags);
 }
 
-
-//void rtl8180_wmm_param_update(struct net_device *dev,u8 *ac_param)
 void rtl8180_wmm_param_update(struct work_struct * work)
 {
 	struct ieee80211_device * ieee = container_of(work, struct ieee80211_device,wmm_param_update_wq);
-	//struct r8180_priv *priv = (struct r8180_priv*)(ieee->priv);
 	struct net_device *dev = ieee->dev;
 	u8 *ac_param = (u8 *)(ieee->current_network.wmm_param);
 	u8 mode = ieee->current_network.mode;
@@ -2985,19 +2502,15 @@ void rtl8180_wmm_param_update(struct wor
 					case AC1_BK:
 						write_nic_dword(dev, AC_BK_PARAM, u4bAcParam);
 						break;
-
 					case AC0_BE:
 						write_nic_dword(dev, AC_BE_PARAM, u4bAcParam);
 						break;
-
 					case AC2_VI:
 						write_nic_dword(dev, AC_VI_PARAM, u4bAcParam);
 						break;
-
 					case AC3_VO:
 						write_nic_dword(dev, AC_VO_PARAM, u4bAcParam);
 						break;
-
 					default:
 						printk(KERN_WARNING "SetHwReg8185():invalid ACI: %d!\n", eACI);
 						break;
@@ -3028,19 +2541,15 @@ void rtl8180_wmm_param_update(struct wor
 				case AC1_BK:
 					write_nic_dword(dev, AC_BK_PARAM, u4bAcParam);
 					break;
-
 				case AC0_BE:
 					write_nic_dword(dev, AC_BE_PARAM, u4bAcParam);
 					break;
-
 				case AC2_VI:
 					write_nic_dword(dev, AC_VI_PARAM, u4bAcParam);
 					break;
-
 				case AC3_VO:
 					write_nic_dword(dev, AC_VO_PARAM, u4bAcParam);
 					break;
-
 				default:
 					printk(KERN_WARNING "SetHwReg8185(): invalid ACI: %d !\n", eACI);
 					break;
@@ -3061,17 +2570,13 @@ void rtl8180_watch_dog(struct net_device
 
 void watch_dog_adaptive(unsigned long data)
 {
-    struct r8180_priv* priv = ieee80211_priv((struct net_device *)data);
-//	DMESG("---->watch_dog_adaptive()\n");
-	if(!priv->up)
-	{
+	struct r8180_priv* priv = ieee80211_priv((struct net_device *)data);
+
+	if (!priv->up) {
 		DMESG("<----watch_dog_adaptive():driver is not up!\n");
 		return;
 	}
 
-  //      queue_work(priv->ieee80211->wq,&priv->ieee80211->watch_dog_wq);
-//{by amy 080312
-#if 1
 	// Tx High Power Mechanism.
 #ifdef HIGH_POWER
 	if(CheckHighPower((struct net_device *)data))
@@ -3094,19 +2599,14 @@ void watch_dog_adaptive(unsigned long da
 		queue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->hw_dig_wq);
 	}
 #endif
-#endif
-//by amy 080312}
    	rtl8180_watch_dog((struct net_device *)data);
 
-
 	queue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->GPIOChangeRFWorkItem);
 
    	priv->watch_dog_timer.expires = jiffies + MSECS(IEEE80211_WATCH_DOG_TIME);
 	add_timer(&priv->watch_dog_timer);
-//        DMESG("<----watch_dog_adaptive()\n");
 }
 
-
 static CHANNEL_LIST ChannelPlan[] = {
 	{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,52,56,60,64},19},  		//FCC
 	{{1,2,3,4,5,6,7,8,9,10,11},11},                    				//IC
@@ -3182,7 +2682,6 @@ static void rtl8180_set_channel_map(u8 c
 	}
 }
 
-//Add for RF power on power off by lizhaoming 080512
 void GPIOChangeRFWorkItemCallBack(struct work_struct *work);
 
 //YJ,add,080828
@@ -3190,6 +2689,7 @@ static void rtl8180_statistics_init(stru
 {
 	memset(pstats, 0, sizeof(struct Stats));
 }
+
 static void rtl8180_link_detect_init(plink_detect_t plink_detect)
 {
 	memset(plink_detect, 0, sizeof(link_detect_t));
@@ -3213,13 +2713,10 @@ short rtl8180_init(struct net_device *de
 		printk("rtl8180_init:Error channel plan! Set to default.\n");
 		priv->channel_plan = 0;
 	}
-	//priv->channel_plan = 9;  //Global Domain
 
 	DMESG("Channel plan is %d\n",priv->channel_plan);
 	rtl8180_set_channel_map(priv->channel_plan, priv->ieee80211);
 
-	//memcpy(priv->stats,0,sizeof(struct Stats));
-
 	//FIXME: these constants are placed in a bad pleace.
 	priv->txbuffsize = 2048;//1024;
 	priv->txringcount = 32;//32;
@@ -3227,14 +2724,9 @@ short rtl8180_init(struct net_device *de
 	priv->rxringcount = 64;//32;
 	priv->txbeaconcount = 2;
 	priv->rx_skb_complete = 1;
-	//priv->txnp_pending.ispending=0;
-	/* ^^ the SKB does not containt a partial RXed
-	 * packet (is empty)
-	 */
 
 	priv->RegThreeWireMode = HW_THREE_WIRE_SI;
 
-//Add for RF power on power off by lizhaoming 080512
 	priv->RFChangeInProgress = false;
 	priv->SetRFPowerStateInProgress = false;
 	priv->RFProgType = 0;
@@ -3242,11 +2734,8 @@ short rtl8180_init(struct net_device *de
 
 	priv->irq_enabled=0;
 
-//YJ,modified,080828
 	rtl8180_statistics_init(&priv->stats);
 	rtl8180_link_detect_init(&priv->link_detect);
-//YJ,modified,080828,end
-
 
 	priv->ack_tx_to_ieee = 0;
 	priv->ieee80211->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;
@@ -3279,8 +2768,6 @@ short rtl8180_init(struct net_device *de
 	priv->eRFPowerState = eRfOff;
 	priv->RfOffReason = 0;
 	priv->LedStrategy = SW_LED_MODE0;
-	//priv->NumRxOkInPeriod = 0;  //YJ,del,080828
-	//priv->NumTxOkInPeriod = 0;  //YJ,del,080828
 	priv->TxPollingTimes = 0;//lzm add 080826
 	priv->bLeisurePs = true;
 	priv->dot11PowerSaveMode = eActive;
@@ -3336,13 +2823,10 @@ short rtl8180_init(struct net_device *de
 	priv->CurCCKRSSI = 0;
 	priv->RxPower = 0;
 	priv->RSSI = 0;
-	//YJ,add,080828
 	priv->NumTxOkTotal = 0;
 	priv->NumTxUnicast = 0;
 	priv->keepAliveLevel = DEFAULT_KEEP_ALIVE_LEVEL;
 	priv->PowerProfile = POWER_PROFILE_AC;
-	//YJ,add,080828,end
-//by amy for rate adaptive
     priv->CurrRetryCnt=0;
     priv->LastRetryCnt=0;
     priv->LastTxokCnt=0;
@@ -3363,8 +2847,6 @@ short rtl8180_init(struct net_device *de
 	priv->ForcedDataRate = 0;
 	priv->RegBModeGainStage = 1;
 
-//by amy for rate adaptive
-//by amy 080312}
 	priv->promisc = (dev->flags & IFF_PROMISC) ? 1:0;
 	spin_lock_init(&priv->irq_lock);
 	spin_lock_init(&priv->irq_th_lock);
@@ -3377,39 +2859,26 @@ short rtl8180_init(struct net_device *de
 	INIT_WORK(&priv->tx_irq_wq,(void*) rtl8180_tx_irq_wq);
 	INIT_DELAYED_WORK(&priv->ieee80211->hw_wakeup_wq,(void*) rtl8180_hw_wakeup_wq);
 	INIT_DELAYED_WORK(&priv->ieee80211->hw_sleep_wq,(void*) rtl8180_hw_sleep_wq);
-	//INIT_DELAYED_WORK(&priv->ieee80211->watch_dog_wq,(void*) rtl8180_watch_dog_wq);
-	//INIT_DELAYED_WORK(&priv->ieee80211->sw_antenna_wq,(void*) rtl8180_sw_antenna_wq);
 	INIT_WORK(&priv->ieee80211->wmm_param_update_wq,(void*) rtl8180_wmm_param_update);
 	INIT_DELAYED_WORK(&priv->ieee80211->rate_adapter_wq,(void*)rtl8180_rate_adapter);//+by amy 080312
 	INIT_DELAYED_WORK(&priv->ieee80211->hw_dig_wq,(void*)rtl8180_hw_dig_wq);//+by amy 080312
 	INIT_DELAYED_WORK(&priv->ieee80211->tx_pw_wq,(void*)rtl8180_tx_pw_wq);//+by amy 080312
 
-	//add for RF power on power off by lizhaoming 080512
 	INIT_DELAYED_WORK(&priv->ieee80211->GPIOChangeRFWorkItem,(void*) GPIOChangeRFWorkItemCallBack);
-	//INIT_WORK(&priv->reset_wq,(void*) rtl8180_restart_wq,dev);
 
 	tasklet_init(&priv->irq_rx_tasklet,
 		     (void(*)(unsigned long)) rtl8180_irq_rx_tasklet,
 		     (unsigned long)priv);
-//by amy
+
     init_timer(&priv->watch_dog_timer);
 	priv->watch_dog_timer.data = (unsigned long)dev;
 	priv->watch_dog_timer.function = watch_dog_adaptive;
-//by amy
 
-//{by amy 080312
-//by amy for rate adaptive
     init_timer(&priv->rateadapter_timer);
         priv->rateadapter_timer.data = (unsigned long)dev;
         priv->rateadapter_timer.function = timer_rate_adaptive;
 		priv->RateAdaptivePeriod= RATE_ADAPTIVE_TIMER_PERIOD;
 		priv->bEnhanceTxPwr=false;
-//by amy for rate adaptive
-//by amy 080312}
-	//priv->ieee80211->func =
-	//	kmalloc(sizeof(struct ieee80211_helper_functions),GFP_KERNEL);
-	//memset(priv->ieee80211->func, 0,
-	  //     sizeof(struct ieee80211_helper_functions));
 
 	priv->ieee80211->softmac_hard_start_xmit = rtl8180_hard_start_xmit;
 	priv->ieee80211->set_chan = rtl8180_set_chan;
@@ -3440,11 +2909,9 @@ short rtl8180_init(struct net_device *de
 									(0 ? TCR_SAT : 0);	// FALSE: HW provies PLCP length and LENGEXT, TURE: SW proiveds them
 
 	priv->ReceiveConfig	=
-//								RCR_ENMARP |
 								RCR_AMF | RCR_ADF |				//accept management/data
 								RCR_ACF |						//accept control frame for SW AP needs PS-poll, 2005.07.07, by rcnjko.
 								RCR_AB | RCR_AM | RCR_APM |		//accept BC/MC/UC
-								//RCR_AICV | RCR_ACRC32 | 		//accept ICV/CRC error packet
 								(7<<RCR_MXDMA_OFFSET) | // Max DMA Burst Size per Rx DMA Burst, 7: unlimited.
 								(priv->EarlyRxThreshold<<RCR_FIFO_OFFSET) | // Rx FIFO Threshold, 7: No Rx threshold.
 								(priv->EarlyRxThreshold == 7 ? RCR_ONLYERLPKT:0);
@@ -3475,24 +2942,20 @@ short rtl8180_init(struct net_device *de
 			/* you should not find a card with 8225 PHY ver < C*/
 			priv->phy_ver = 2;
 			break;
-
 		case HW_VERID_R8185_D:
 			DMESG("MAC controller is a RTL8185 b/g (V. D)");
 			priv->card_8185 = 2;
 			/* you should not find a card with 8225 PHY ver < C*/
 			priv->phy_ver = 2;
 			break;
-
 		case HW_VERID_R8180_ABCD:
 			DMESG("MAC controller is a RTL8180");
 			priv->card_8185 = 0;
 			break;
-
 		case HW_VERID_R8180_F:
 			DMESG("MAC controller is a RTL8180 (v. F)");
 			priv->card_8185 = 0;
 			break;
-
 		default:
 			DMESGW("MAC chip not recognized: version %x. Assuming RTL8180",hw_version);
 			priv->card_8185 = 0;
@@ -3511,72 +2974,45 @@ short rtl8180_init(struct net_device *de
         DMESG("This is a PCI NIC");
 	priv->enable_gpio0 = 0;
 
-//by amy for antenna
 	usValue = eprom_read(dev, EEPROM_SW_REVD_OFFSET);
 	DMESG("usValue is 0x%x\n",usValue);
 	//3Read AntennaDiversity
+
 	// SW Antenna Diversity.
-	if(	(usValue & EEPROM_SW_AD_MASK) != EEPROM_SW_AD_ENABLE )
-	{
+	if ((usValue & EEPROM_SW_AD_MASK) != EEPROM_SW_AD_ENABLE)
 		priv->EEPROMSwAntennaDiversity = false;
-		//printk("EEPROM Disable SW Antenna Diversity\n");
-	}
 	else
-	{
 		priv->EEPROMSwAntennaDiversity = true;
-		//printk("EEPROM Enable SW Antenna Diversity\n");
-	}
+
 	// Default Antenna to use.
-	if( (usValue & EEPROM_DEF_ANT_MASK) != EEPROM_DEF_ANT_1 )
-	{
+	if ((usValue & EEPROM_DEF_ANT_MASK) != EEPROM_DEF_ANT_1)
 		priv->EEPROMDefaultAntenna1 = false;
-		//printk("EEPROM Default Antenna 0\n");
-	}
 	else
-	{
 		priv->EEPROMDefaultAntenna1 = true;
-		//printk("EEPROM Default Antenna 1\n");
-	}
 
-	//
-	// Antenna diversity mechanism. Added by Roger, 2007.11.05.
-	//
 	if( priv->RegSwAntennaDiversityMechanism == 0 ) // Auto
-	{// 0: default from EEPROM.
+		/* 0: default from EEPROM. */
 		priv->bSwAntennaDiverity = priv->EEPROMSwAntennaDiversity;
-	}
 	else
-	{// 1:disable antenna diversity, 2: enable antenna diversity.
+		/* 1:disable antenna diversity, 2: enable antenna diversity. */
 		priv->bSwAntennaDiverity = ((priv->RegSwAntennaDiversityMechanism == 1)? false : true);
-	}
-	//printk("bSwAntennaDiverity = %d\n", priv->bSwAntennaDiverity);
 
-
-	//
-	// Default antenna settings. Added by Roger, 2007.11.05.
-	//
-	if( priv->RegDefaultAntenna == 0)
-	{// 0: default from EEPROM.
+	if (priv->RegDefaultAntenna == 0)
+		/* 0: default from EEPROM. */
 		priv->bDefaultAntenna1 = priv->EEPROMDefaultAntenna1;
-	}
 	else
-	{// 1: main, 2: aux.
+		/* 1: main, 2: aux. */
 		priv->bDefaultAntenna1 = ((priv->RegDefaultAntenna== 2) ? true : false);
-	}
-	//printk("bDefaultAntenna1 = %d\n", priv->bDefaultAntenna1);
-//by amy for antenna
+
 	/* rtl8185 can calc plcp len in HW.*/
 	priv->hw_plcp_len = 1;
 
 	priv->plcp_preamble_mode = 2;
 	/*the eeprom type is stored in RCR register bit #6 */
-	if (RCR_9356SEL & read_nic_dword(dev, RCR)){
+	if (RCR_9356SEL & read_nic_dword(dev, RCR))
 		priv->epromtype=EPROM_93c56;
-		//DMESG("Reported EEPROM chip is a 93c56 (2Kbit)");
-	}else{
+	else
 		priv->epromtype=EPROM_93c46;
-		//DMESG("Reported EEPROM chip is a 93c46 (1Kbit)");
-	}
 
 	dev->dev_addr[0]=eprom_read(dev,MAC_ADR) & 0xff;
 	dev->dev_addr[1]=(eprom_read(dev,MAC_ADR) & 0xff00)>>8;
@@ -3584,32 +3020,26 @@ short rtl8180_init(struct net_device *de
 	dev->dev_addr[3]=(eprom_read(dev,MAC_ADR+1) & 0xff00)>>8;
 	dev->dev_addr[4]=eprom_read(dev,MAC_ADR+2) & 0xff;
 	dev->dev_addr[5]=(eprom_read(dev,MAC_ADR+2) & 0xff00)>>8;
-	//DMESG("Card MAC address is "MAC_FMT, MAC_ARG(dev->dev_addr));
-
 
 	for(i=1,j=0; i<14; i+=2,j++){
-
 		word = eprom_read(dev,EPROM_TXPW_CH1_2 + j);
 		priv->chtxpwr[i]=word & 0xff;
 		priv->chtxpwr[i+1]=(word & 0xff00)>>8;
 	}
 	if(priv->card_8185){
 		for(i=1,j=0; i<14; i+=2,j++){
-
 			word = eprom_read(dev,EPROM_TXPW_OFDM_CH1_2 + j);
 			priv->chtxpwr_ofdm[i]=word & 0xff;
 			priv->chtxpwr_ofdm[i+1]=(word & 0xff00)>>8;
 		}
 	}
-//{by amy 080312
+
 	//3Read crystal calibtration and thermal meter indication on 87SE.
 
 	// By SD3 SY's request. Added by Roger, 2007.12.11.
 
 	tmpu16 = eprom_read(dev, EEPROM_RSV>>1);
 
-	//printk("ReadAdapterInfo8185(): EEPROM_RSV(%04x)\n", tmpu16);
-
 		// Crystal calibration for Xin and Xout resp.
 		priv->XtalCal_Xout = tmpu16 & EEPROM_XTAL_CAL_XOUT_MASK; // 0~7.5pF
 		priv->XtalCal_Xin = (tmpu16 & EEPROM_XTAL_CAL_XIN_MASK)>>4; // 0~7.5pF
@@ -3621,7 +3051,6 @@ short rtl8180_init(struct net_device *de
 		if((tmpu16 & EEPROM_THERMAL_METER_ENABLE)>>13)
 			priv->bTxPowerTrack = true;
 
-//by amy 080312}
 	word = eprom_read(dev,EPROM_TXPW_BASE);
 	priv->cck_txpwr_base = word & 0xf;
 	priv->ofdm_txpwr_base = (word>>4) & 0xf;
@@ -3663,9 +3092,6 @@ DMESG output to andreamrl@tiscali.it THA
 	priv->rf_chip = RF_ZEBRA4;
 	priv->rf_sleep = rtl8225z4_rf_sleep;
 	priv->rf_wakeup = rtl8225z4_rf_wakeup;
-	//DMESG("Card reports RF frontend Realtek 8225z2");
-	//DMESGW("This driver has EXPERIMENTAL support for this chipset.");
-	//DMESGW("use it with care and at your own risk and");
 	DMESGW("**PLEASE** REPORT SUCCESSFUL/UNSUCCESSFUL TO Realtek!");
 
 	priv->rf_close = rtl8225z2_rf_close;
@@ -3718,11 +3144,7 @@ DMESG output to andreamrl@tiscali.it THA
 				  TX_BEACON_RING_ADDR))
 		return -ENOMEM;
 
-
-	//priv->beacon_buf=NULL;
-
 	if(!priv->card_8185){
-
 		if(read_nic_byte(dev, CONFIG0) & (1<<CONFIG0_WEP40_SHIFT))
 			DMESG ("40-bit WEP is supported in hardware");
 		else
@@ -3746,16 +3168,13 @@ DMESG output to andreamrl@tiscali.it THA
 	}
 
 	return 0;
-
 }
 
-
 void rtl8180_no_hw_wep(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
-	if(!priv->card_8185)
-	{
+	if (!priv->card_8185) {
 		u8 security;
 
 		security  = read_nic_byte(dev, SECURITY);
@@ -3763,19 +3182,9 @@ void rtl8180_no_hw_wep(struct net_device
 		security &=~(1<<SECURITY_WEP_RX_ENABLE_SHIFT);
 
 		write_nic_byte(dev, SECURITY, security);
-
-	}else{
-
-		//FIXME!!!
 	}
-	/*
-	  write_nic_dword(dev,TX_CONF,read_nic_dword(dev,TX_CONF) |
-	  (1<<TX_NOICV_SHIFT) );
-	*/
-//	priv->ieee80211->hw_wep=0;
 }
 
-
 void rtl8180_set_hw_wep(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
@@ -3794,10 +3203,6 @@ void rtl8180_set_hw_wep(struct net_devic
 	write_nic_dword(dev,KEY0+4+4,(priv->key0[2]));
 	write_nic_dword(dev,KEY0+4+4+4,(key0_word4));
 
-	/*
-	  TX_CONF,read_nic_dword(dev,TX_CONF) &~(1<<TX_NOICV_SHIFT));
-	*/
-
 	security  = read_nic_byte(dev,SECURITY);
 	security |= (1<<SECURITY_WEP_TX_ENABLE_SHIFT);
 	security |= (1<<SECURITY_WEP_RX_ENABLE_SHIFT);
@@ -3809,8 +3214,6 @@ void rtl8180_set_hw_wep(struct net_devic
 	DMESG("key %x %x %x %x",read_nic_dword(dev,KEY0+4+4+4),
 	      read_nic_dword(dev,KEY0+4+4),read_nic_dword(dev,KEY0+4),
 	      read_nic_dword(dev,KEY0));
-
-	//priv->ieee80211->hw_wep=1;
 }
 
 
@@ -3819,10 +3222,8 @@ void rtl8185_rf_pins_enable(struct net_d
 //	u16 tmp;
 //	tmp = read_nic_word(dev, RFPinsEnable);
 	write_nic_word(dev, RFPinsEnable, 0x1fff);// | tmp);
-//	write_nic_word(dev, RFPinsEnable,7 | tmp);
 }
 
-
 void rtl8185_set_anaparam2(struct net_device *dev, u32 a)
 {
 	u8 conf3;
@@ -3836,10 +3237,8 @@ void rtl8185_set_anaparam2(struct net_de
 	conf3 = read_nic_byte(dev, CONFIG3);
 	write_nic_byte(dev, CONFIG3, conf3 &~(1<<CONFIG3_ANAPARAM_W_SHIFT));
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
-
 }
 
-
 void rtl8180_set_anaparam(struct net_device *dev, u32 a)
 {
 	u8 conf3;
@@ -3855,7 +3254,6 @@ void rtl8180_set_anaparam(struct net_dev
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
 }
 
-
 void rtl8185_tx_antenna(struct net_device *dev, u8 ant)
 {
 	write_nic_byte(dev, TX_ANTENNA, ant);
@@ -3863,12 +3261,9 @@ void rtl8185_tx_antenna(struct net_devic
 	mdelay(1);
 }
 
-
 void rtl8185_write_phy(struct net_device *dev, u8 adr, u32 data)
 {
-	//u8 phyr;
 	u32 phyw;
-	//int i;
 
 	adr |= 0x80;
 
@@ -3886,21 +3281,18 @@ void rtl8185_write_phy(struct net_device
 	//if(phyr != (data&0xff)) DMESGW("Phy write timeout %x %x %x", phyr, data,adr);
 }
 
-
 inline void write_phy_ofdm (struct net_device *dev, u8 adr, u32 data)
 {
 	data = data & 0xff;
 	rtl8185_write_phy(dev, adr, data);
 }
 
-
 void write_phy_cck (struct net_device *dev, u8 adr, u32 data)
 {
 	data = data & 0xff;
 	rtl8185_write_phy(dev, adr, data | 0x10000);
 }
 
-
 /* 70*3 = 210 ms
  * I hope this is enougth
  */
@@ -3944,55 +3336,32 @@ void rtl8185_set_rate(struct net_device 
 	u16 word;
 	int basic_rate,min_rr_rate,max_rr_rate;
 
-//	struct r8180_priv *priv = ieee80211_priv(dev);
-
-	//if (ieee80211_is_54g(priv->ieee80211->current_network) &&
-//		priv->ieee80211->state == IEEE80211_LINKED){
 	basic_rate = ieeerate2rtlrate(240);
 	min_rr_rate = ieeerate2rtlrate(60);
 	max_rr_rate = ieeerate2rtlrate(240);
 
-//
-//	}else{
-//		basic_rate = ieeerate2rtlrate(20);
-//		min_rr_rate = ieeerate2rtlrate(10);
-//		max_rr_rate = ieeerate2rtlrate(110);
-//	}
-
 	write_nic_byte(dev, RESP_RATE,
 			max_rr_rate<<MAX_RESP_RATE_SHIFT| min_rr_rate<<MIN_RESP_RATE_SHIFT);
 
 	word  = read_nic_word(dev, BRSR);
 	word &= ~BRSR_MBR_8185;
 
-
 	for(i=0;i<=basic_rate;i++)
 		word |= (1<<i);
 
 	write_nic_word(dev, BRSR, word);
-	//DMESG("RR:%x BRSR: %x", read_nic_byte(dev,RESP_RATE),read_nic_word(dev,BRSR));
 }
 
-
-
 void rtl8180_adapter_start(struct net_device *dev)
 {
         struct r8180_priv *priv = ieee80211_priv(dev);
 	u32 anaparam;
 	u16 word;
 	u8 config3;
-//	int i;
 
 	rtl8180_rtx_disable(dev);
 	rtl8180_reset(dev);
 
-	/* seems that 0xffff or 0xafff will cause
-	 * HW interrupt line crash
-	 */
-
-	//priv->irq_mask = 0xafff;
-//	priv->irq_mask = 0x4fcf;
-
 	/* enable beacon timeout, beacon TX ok and err
 	 * LP tx ok and err, HP TX ok and err, NP TX ok and err,
 	 * RX ok and ERR, and GP timer */
@@ -4024,8 +3393,6 @@ void rtl8180_adapter_start(struct net_de
 	/* These might be unnecessary since we do in rx_enable / tx_enable */
 	fix_rx_fifo(dev);
 	fix_tx_fifo(dev);
-	/*set_nic_rxring(dev);
-	  set_nic_txring(dev);*/
 
 	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
 
@@ -4060,7 +3427,6 @@ void rtl8180_adapter_start(struct net_de
 		write_nic_byte(dev, CONFIG5,
 			read_nic_byte(dev, CONFIG5) &~ (1<<AGCRESET_SHIFT));
 	}else{
-
 		write_nic_byte(dev, WPA_CONFIG, 0);
 		//write_nic_byte(dev, TESTR, 0xd);
 	}
@@ -4070,28 +3436,23 @@ void rtl8180_adapter_start(struct net_de
 	if(priv->card_8185){
 		rtl8185_set_rate(dev);
 		write_nic_byte(dev, RATE_FALLBACK, 0x81);
-	//	write_nic_byte(dev, 0xdf, 0x15);
 	}else{
 		word  = read_nic_word(dev, BRSR);
 		word &= ~BRSR_MBR;
 		word &= ~BRSR_BPLCP;
 		word |= ieeerate2rtlrate(priv->ieee80211->basic_rate);
-//by amy
-              word |= 0x0f;
-//by amy
+		word |= 0x0f;
 		write_nic_word(dev, BRSR, word);
 	}
 
-
 	if(priv->card_8185){
 		write_nic_byte(dev, GP_ENABLE,read_nic_byte(dev, GP_ENABLE) & ~(1<<6));
 
 		//FIXME cfg 3 ClkRun enable - isn't it ReadOnly ?
 		rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
 		write_nic_byte(dev,CONFIG3, read_nic_byte(dev, CONFIG3)
-|(1<<CONFIG3_CLKRUN_SHIFT));
+			       | (1 << CONFIG3_CLKRUN_SHIFT));
 		rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
-
 	}
 
 	priv->rf_init(dev);
@@ -4101,39 +3462,23 @@ void rtl8180_adapter_start(struct net_de
 	rtl8180_irq_enable(dev);
 
 	netif_start_queue(dev);
-	/*DMESG ("lfree %d",get_curr_tx_free_desc(dev,LOW_PRIORITY));
-
-	DMESG ("nfree %d",get_curr_tx_free_desc(dev,NORM_PRIORITY));
-
-	DMESG ("hfree %d",get_curr_tx_free_desc(dev,HI_PRIORITY));
-	if(check_nic_enought_desc(dev,NORM_PRIORITY)) DMESG("NORM OK");
-	if(check_nic_enought_desc(dev,HI_PRIORITY)) DMESG("HI OK");
-	if(check_nic_enought_desc(dev,LOW_PRIORITY)) DMESG("LOW OK");*/
 }
 
-
-
 /* this configures registers for beacon tx and enables it via
  * rtl8180_beacon_tx_enable(). rtl8180_beacon_tx_disable() might
  * be used to stop beacon transmission
  */
 void rtl8180_start_tx_beacon(struct net_device *dev)
 {
-//	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
 	u16 word;
-//	DMESG("ring %x %x", priv->txlpringdma,read_nic_dword(dev,TLPDA));
 
 	DMESG("Enabling beacon TX");
-	//write_nic_byte(dev, 0x42,0xe6);// TCR
-//	set_nic_txring(dev);
-//	fix_tx_fifo(dev);
 	rtl8180_prepare_beacon(dev);
 	rtl8180_irq_disable(dev);
 	rtl8180_beacon_tx_enable(dev);
 
 	word = read_nic_word(dev, AtimWnd) &~ AtimWnd_AtimWnd;
 	write_nic_word(dev, AtimWnd,word);// word |=
-//priv->ieee80211->current_network.atim_window);
 
 	word  = read_nic_word(dev, BintrItv);
 	word &= ~BintrItv_BintrItv;
@@ -4143,26 +3488,11 @@ void rtl8180_start_tx_beacon(struct net_
 	*/
 	write_nic_word(dev, BintrItv, word);
 
-
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
 
-//	rtl8180_beacon_tx_enable(dev);
         rtl8185b_irq_enable(dev);
-	/* VV !!!!!!!!!! VV*/
-	/*
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,0x9d,0x00);
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-*/
-//	DMESG("ring %x %x", priv->txlpringdma,read_nic_dword(dev,TLPDA));
-
 }
 
-
-
-/***************************************************************************
-    -------------------------------NET STUFF---------------------------
-***************************************************************************/
 static struct net_device_stats *rtl8180_stats(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
@@ -4179,93 +3509,42 @@ MgntActSet_802_11_PowerSaveMode(
 	RT_PS_MODE		rtPsMode
 )
 {
-
 	// Currently, we do not change power save mode on IBSS mode.
 	if(priv->ieee80211->iw_mode == IW_MODE_ADHOC)
-	{
 		return false;
-	}
-
-	//
-	// <RJ_NOTE> If we make HW to fill up the PwrMgt bit for us,
-	// some AP will not response to our mgnt frames with PwrMgt bit set,
-	// e.g. cannot associate the AP.
-	// So I commented out it. 2005.02.16, by rcnjko.
-	//
-//	// Change device's power save mode.
-//	Adapter->HalFunc.SetPSModeHandler( Adapter, rtPsMode );
 
-	// Update power save mode configured.
-//	priv->dot11PowerSaveMode = rtPsMode;
 	priv->ieee80211->ps = rtPsMode;
-	// Determine ListenInterval.
 
 	return true;
 }
 
-//================================================================================
-// Leisure Power Save in linked state.
-//================================================================================
-
-//
-//	Description:
-//		Enter the leisure power save mode.
-//
-void
-LeisurePSEnter(
-	struct r8180_priv *priv
-	)
+void LeisurePSEnter(struct r8180_priv *priv)
 {
-	if (priv->bLeisurePs)
-	{
+	if (priv->bLeisurePs) {
 		if (priv->ieee80211->ps == IEEE80211_PS_DISABLED)
-		{
-			//printk("----Enter PS\n");
 			MgntActSet_802_11_PowerSaveMode(priv, IEEE80211_PS_MBCAST|IEEE80211_PS_UNICAST);//IEEE80211_PS_ENABLE
-		}
 	}
 }
 
-
-//
-//	Description:
-//		Leave the leisure power save mode.
-//
-void
-LeisurePSLeave(
-	struct r8180_priv *priv
-	)
+void LeisurePSLeave(struct r8180_priv *priv)
 {
-	if (priv->bLeisurePs)
-	{
+	if (priv->bLeisurePs) {
 		if (priv->ieee80211->ps != IEEE80211_PS_DISABLED)
-		{
-			//printk("----Leave PS\n");
 			MgntActSet_802_11_PowerSaveMode(priv, IEEE80211_PS_DISABLED);
-		}
 	}
 }
 
 void rtl8180_hw_wakeup_wq (struct work_struct *work)
 {
-//	struct r8180_priv *priv = container_of(work, struct r8180_priv, watch_dog_wq);
-//	struct ieee80211_device * ieee = (struct ieee80211_device*)
-//	                                       container_of(work, struct ieee80211_device, watch_dog_wq);
 	struct delayed_work *dwork = to_delayed_work(work);
 	struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_wakeup_wq);
 	struct net_device *dev = ieee->dev;
 
-//	printk("dev is %d\n",dev);
-//	printk("&*&(^*(&(&=========>%s()\n", __func__);
 	rtl8180_hw_wakeup(dev);
-
 }
 
 void rtl8180_hw_sleep_wq (struct work_struct *work)
 {
-//      struct r8180_priv *priv = container_of(work, struct r8180_priv, watch_dog_wq);
-//      struct ieee80211_device * ieee = (struct ieee80211_device*)
-//                                             container_of(work, struct ieee80211_device, watch_dog_wq);
 	struct delayed_work *dwork = to_delayed_work(work);
         struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_sleep_wq);
         struct net_device *dev = ieee->dev;
@@ -4273,7 +3552,6 @@ void rtl8180_hw_sleep_wq (struct work_st
         rtl8180_hw_sleep_down(dev);
 }
 
-//YJ,add,080828,for KeepAlive
 static void MgntLinkKeepAlive(struct r8180_priv *priv )
 {
 	if (priv->keepAliveLevel == 0)
@@ -4284,7 +3562,6 @@ static void MgntLinkKeepAlive(struct r81
 		//
 		// Keep-Alive.
 		//
-		//printk("LastTx:%d Tx:%d LastRx:%d Rx:%ld Idle:%d\n",priv->link_detect.LastNumTxUnicast,priv->NumTxUnicast, priv->link_detect.LastNumRxUnicast, priv->ieee80211->NumRxUnicast, priv->link_detect.IdleCount);
 
 		if ( (priv->keepAliveLevel== 2) ||
 			(priv->link_detect.LastNumTxUnicast == priv->NumTxUnicast &&
@@ -4310,9 +3587,9 @@ static void MgntLinkKeepAlive(struct r81
 		priv->link_detect.LastNumRxUnicast = priv->ieee80211->NumRxUnicast;
 	}
 }
-//YJ,add,080828,for KeepAlive,end
 
 static u8 read_acadapter_file(char *filename);
+
 void rtl8180_watch_dog(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
@@ -4334,7 +3611,7 @@ void rtl8180_watch_dog(struct net_device
 		priv->link_detect.RxFrameNum[SlotIndex] = priv->ieee80211->NumRxDataInPeriod + priv->ieee80211->NumRxBcnInPeriod;
 		for( i=0; i<priv->link_detect.SlotNum; i++ )
 			TotalRxNum+= priv->link_detect.RxFrameNum[i];
-		//printk("&&&&&=== TotalRxNum = %d\n", TotalRxNum);
+
 		if(TotalRxNum == 0){
 			priv->ieee80211->state = IEEE80211_ASSOCIATING;
 			queue_work(priv->ieee80211->wq, &priv->ieee80211->associate_procedure_wq);
@@ -4346,22 +3623,13 @@ void rtl8180_watch_dog(struct net_device
 
 	//YJ,add,080828,for LPS
 #ifdef ENABLE_LPS
-	if(priv->PowerProfile == POWER_PROFILE_BATTERY )
-	{
-		//Turn on LeisurePS on battery power
-		//printk("!!!!!On battery power\n");
+	if (priv->PowerProfile == POWER_PROFILE_BATTERY)
 		priv->bLeisurePs = true;
-	}
-	else if(priv->PowerProfile == POWER_PROFILE_AC )
-	{
-		// Turn off LeisurePS on AC power
-		//printk("----On AC power\n");
+	else if (priv->PowerProfile == POWER_PROFILE_AC) {
 		LeisurePSLeave(priv);
 		priv->bLeisurePs= false;
 	}
-#endif
 
-#ifdef ENABLE_LPS
 	if(priv->ieee80211->state == IEEE80211_LINKED){
 		priv->link_detect.NumRxOkInPeriod = priv->ieee80211->NumRxDataInPeriod;
 		//printk("TxOk=%d RxOk=%d\n", priv->link_detect.NumTxOkInPeriod, priv->link_detect.NumRxOkInPeriod);
@@ -4372,21 +3640,15 @@ void rtl8180_watch_dog(struct net_device
 		if(((priv->link_detect.NumRxOkInPeriod + priv->link_detect.NumTxOkInPeriod) > 8)
 			|| (priv->link_detect.NumRxOkInPeriod > 2)) {
 			bEnterPS= false;
-		}
-		else {
+		} else
 			bEnterPS= true;
-		}
 
-		if(bEnterPS) {
+		if (bEnterPS)
 			LeisurePSEnter(priv);
-		}
-		else {
+		else
 			LeisurePSLeave(priv);
-		}
-	}
-	else{
+	} else
 		LeisurePSLeave(priv);
-	}
 #endif
 	priv->link_detect.bBusyTraffic = bBusyTraffic;
 	priv->link_detect.NumRxOkInPeriod = 0;
@@ -4394,10 +3656,10 @@ void rtl8180_watch_dog(struct net_device
 	priv->ieee80211->NumRxDataInPeriod = 0;
 	priv->ieee80211->NumRxBcnInPeriod = 0;
 }
+
 int _rtl8180_up(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//int i;
 
 	priv->up=1;
 
@@ -4411,28 +3673,19 @@ int _rtl8180_up(struct net_device *dev)
 			IPSLeave(dev);
 	}
 #endif
-//by amy 080312
 #ifdef RATE_ADAPT
        timer_rate_adaptive((unsigned long)dev);
 #endif
-//by amy 080312
 	watch_dog_adaptive((unsigned long)dev);
 #ifdef SW_ANTE
         if(priv->bSwAntennaDiverity)
 			SwAntennaDiversityTimerCallback(dev);
 #endif
-//	IPSEnter(dev);
 	ieee80211_softmac_start_protocol(priv->ieee80211);
 
-//Add for RF power on power off by lizhaoming 080512
-//	priv->eRFPowerState = eRfOn;
-//	printk("\n--------Start queue_work:GPIOChangeRFWorkItem");
-//	queue_delayed_work(priv->ieee80211->wq,&priv->ieee80211->GPIOChangeRFWorkItem,1000);
-
 	return 0;
 }
 
-
 int rtl8180_open(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
@@ -4442,10 +3695,8 @@ int rtl8180_open(struct net_device *dev)
 	ret = rtl8180_up(dev);
 	up(&priv->wx_sem);
 	return ret;
-
 }
 
-
 int rtl8180_up(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
@@ -4455,7 +3706,6 @@ int rtl8180_up(struct net_device *dev)
 	return _rtl8180_up(dev);
 }
 
-
 int rtl8180_close(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
@@ -4466,14 +3716,14 @@ int rtl8180_close(struct net_device *dev
 	up(&priv->wx_sem);
 
 	return ret;
-
 }
 
 int rtl8180_down(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
-	if (priv->up == 0) return -1;
+	if (priv->up == 0)
+		return -1;
 
 	priv->up=0;
 
@@ -4484,18 +3734,14 @@ int rtl8180_down(struct net_device *dev)
 	rtl8180_rtx_disable(dev);
 	rtl8180_irq_disable(dev);
 	del_timer_sync(&priv->watch_dog_timer);
-	//cancel_delayed_work(&priv->ieee80211->watch_dog_wq);
-//{by amy 080312
-    del_timer_sync(&priv->rateadapter_timer);
-    cancel_delayed_work(&priv->ieee80211->rate_adapter_wq);
-//by amy 080312}
+	del_timer_sync(&priv->rateadapter_timer);
+	cancel_delayed_work(&priv->ieee80211->rate_adapter_wq);
 	cancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);
 	cancel_delayed_work(&priv->ieee80211->hw_sleep_wq);
 	cancel_delayed_work(&priv->ieee80211->hw_dig_wq);
 	cancel_delayed_work(&priv->ieee80211->tx_pw_wq);
 	del_timer_sync(&priv->SwAntennaDiversityTimer);
 	SetZebraRFPowerState8185(dev,eRfOff);
-	//ieee80211_softmac_stop_protocol(priv->ieee80211);
 	memset(&(priv->ieee80211->current_network),0,sizeof(struct ieee80211_network));
 	priv->ieee80211->state = IEEE80211_NOLINK;
 	return 0;
@@ -4516,26 +3762,20 @@ void rtl8180_restart_wq(struct work_stru
 void rtl8180_restart(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
-	//rtl8180_commit(dev);
+
 	schedule_work(&priv->reset_wq);
-	//DMESG("TXTIMEOUT");
 }
 
-
 void rtl8180_commit(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 
-	if (priv->up == 0) return ;
-//+by amy 080312
+	if (priv->up == 0)
+		return ;
+
 	del_timer_sync(&priv->watch_dog_timer);
-	//cancel_delayed_work(&priv->ieee80211->watch_dog_wq);
-//{by amy 080312
-//by amy for rate adaptive
-    del_timer_sync(&priv->rateadapter_timer);
-    cancel_delayed_work(&priv->ieee80211->rate_adapter_wq);
-//by amy for rate adaptive
-//by amy 080312}
+	del_timer_sync(&priv->rateadapter_timer);
+	cancel_delayed_work(&priv->ieee80211->rate_adapter_wq);
 	cancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);
 	cancel_delayed_work(&priv->ieee80211->hw_sleep_wq);
 	cancel_delayed_work(&priv->ieee80211->hw_dig_wq);
@@ -4547,22 +3787,17 @@ void rtl8180_commit(struct net_device *d
 	_rtl8180_up(dev);
 }
 
-
 static void r8180_set_multicast(struct net_device *dev)
 {
 	struct r8180_priv *priv = ieee80211_priv(dev);
 	short promisc;
 
-	//down(&priv->wx_sem);
-
 	promisc = (dev->flags & IFF_PROMISC) ? 1:0;
 
 	if (promisc != priv->promisc)
 		rtl8180_restart(dev);
 
 	priv->promisc = promisc;
-
-	//up(&priv->wx_sem);
 }
 
 int r8180_set_mac_adr(struct net_device *dev, void *mac)
@@ -4591,27 +3826,20 @@ int r8180_set_mac_adr(struct net_device 
 int rtl8180_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-
 	struct iwreq *wrq = (struct iwreq *) rq;
 	int ret=-1;
+
 	switch (cmd) {
-	    case RTL_IOCTL_WPA_SUPPLICANT:
+	case RTL_IOCTL_WPA_SUPPLICANT:
 		ret = ieee80211_wpa_supplicant_ioctl(priv->ieee80211, &wrq->u.data);
 		return ret;
-
-	    default:
+	default:
 		return -EOPNOTSUPP;
 	}
 
 	return -EOPNOTSUPP;
 }
 
-
-
-/****************************************************************************
-     -----------------------------PCI STUFF---------------------------
-*****************************************************************************/
-
 static const struct net_device_ops rtl8180_netdev_ops = {
 	.ndo_open		= rtl8180_open,
 	.ndo_stop		= rtl8180_close,
@@ -4631,7 +3859,6 @@ static int __devinit rtl8180_pci_probe(s
 	unsigned long ioaddr = 0;
 	struct net_device *dev = NULL;
 	struct r8180_priv *priv= NULL;
-	//u8 *ptr;
 	u8 unit = 0;
 
 	unsigned long pmem_start, pmem_len, pmem_flags;
@@ -4644,7 +3871,6 @@ static int __devinit rtl8180_pci_probe(s
 	}
 
 	pci_set_master(pdev);
-	//pci_set_wmi(pdev);
 	pci_set_dma_mask(pdev, 0xffffff00ULL);
 	pci_set_consistent_dma_mask(pdev,0xffffff00ULL);
 	dev = alloc_ieee80211(sizeof(struct r8180_priv));
@@ -4657,10 +3883,7 @@ static int __devinit rtl8180_pci_probe(s
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
 	priv = ieee80211_priv(dev);
-//	memset(priv,0,sizeof(struct r8180_priv));
-	priv->pdev=pdev;
-
-
+	priv->pdev = pdev;
 
 	pmem_start = pci_resource_start(pdev, 1);
 	pmem_len = pci_resource_len(pdev, 1);
@@ -4671,26 +3894,20 @@ static int __devinit rtl8180_pci_probe(s
 		goto fail;
 	}
 
-	//DMESG("Memory mapped space @ 0x%08lx ", pmem_start);
 	if( ! request_mem_region(pmem_start, pmem_len, RTL8180_MODULE_NAME)) {
 		DMESG("request_mem_region failed!");
 		goto fail;
 	}
 
-
 	ioaddr = (unsigned long)ioremap_nocache( pmem_start, pmem_len);
 	if( ioaddr == (unsigned long)NULL ){
 		DMESG("ioremap failed!");
-	       // release_mem_region( pmem_start, pmem_len );
 		goto fail1;
 	}
 
 	dev->mem_start = ioaddr; // shared mem start
 	dev->mem_end = ioaddr + pci_resource_len(pdev, 0); // shared mem end
 
-
-	//pci_read_config_byte(pdev, 0x05, ptr);
-	//pci_write_config_byte(pdev, 0x05, (*ptr) & (~0x04));
 	pci_read_config_byte(pdev, 0x05, &unit);
 	pci_write_config_byte(pdev, 0x05, unit & (~0x04));
 
@@ -4706,11 +3923,9 @@ static int __devinit rtl8180_pci_probe(s
 	if (dev_alloc_name(dev, ifname) < 0){
                 DMESG("Oops: devname already taken! Trying wlan%%d...\n");
 		ifname = "wlan%d";
-	//	ifname = "ath%d";
 		dev_alloc_name(dev, ifname);
         }
 
-
 	if(rtl8180_init(dev)!=0){
 		DMESG("Initialization failed");
 		goto fail1;
@@ -4724,19 +3939,14 @@ static int __devinit rtl8180_pci_probe(s
 
 	DMESG("Driver probe completed\n");
 	return 0;
-
 fail1:
-
 	if( dev->mem_start != (unsigned long)NULL ){
 		iounmap( (void *)dev->mem_start );
 		release_mem_region( pci_resource_start(pdev, 1),
 				    pci_resource_len(pdev, 1) );
 	}
-
-
 fail:
 	if(dev){
-
 		if (priv->irq) {
 			free_irq(dev->irq, dev);
 			dev->irq=0;
@@ -4749,42 +3959,32 @@ fail:
 	DMESG("wlan driver load failed\n");
 	pci_set_drvdata(pdev, NULL);
 	return -ENODEV;
-
 }
 
-
 static void __devexit rtl8180_pci_remove(struct pci_dev *pdev)
 {
 	struct r8180_priv *priv;
 	struct net_device *dev = pci_get_drvdata(pdev);
- 	if(dev){
 
+	if (dev) {
 		unregister_netdev(dev);
 
-		priv=ieee80211_priv(dev);
+		priv = ieee80211_priv(dev);
 
 		rtl8180_proc_remove_one(dev);
 		rtl8180_down(dev);
 		priv->rf_close(dev);
 		rtl8180_reset(dev);
-		//rtl8180_rtx_disable(dev);
-		//rtl8180_irq_disable(dev);
 		mdelay(10);
-		//write_nic_word(dev,INTA,read_nic_word(dev,INTA));
-		//force_pci_posting(dev);
-		//mdelay(10);
 
 		if(priv->irq){
-
 			DMESG("Freeing irq %d",dev->irq);
 			free_irq(dev->irq, dev);
 			priv->irq=0;
-
 		}
 
 		free_rx_desc_ring(dev);
 		free_tx_desc_rings(dev);
-	//	free_beacon_desc_ring(dev,priv->txbeaconcount);
 
 		if( dev->mem_start != (unsigned long)NULL ){
 			iounmap( (void *)dev->mem_start );
@@ -4799,7 +3999,6 @@ static void __devexit rtl8180_pci_remove
 	DMESG("wlan driver removed\n");
 }
 
-
 /* fun with the built-in ieee80211 stack... */
 extern int ieee80211_crypto_init(void);
 extern void ieee80211_crypto_deinit(void);
@@ -4842,17 +4041,13 @@ static int __init rtl8180_pci_module_ini
 	DMESG("Wireless extensions version %d", WIRELESS_EXT);
 	rtl8180_proc_module_init();
 
-      if(0!=pci_register_driver(&rtl8180_pci_driver))
-	//if(0!=pci_module_init(&rtl8180_pci_driver))
-	{
+      if (pci_register_driver(&rtl8180_pci_driver)) {
 		DMESG("No device found");
-		/*pci_unregister_driver (&rtl8180_pci_driver);*/
 		return -ENODEV;
 	}
 	return 0;
 }
 
-
 static void __exit rtl8180_pci_module_exit(void)
 {
 	pci_unregister_driver (&rtl8180_pci_driver);
@@ -4864,7 +4059,6 @@ static void __exit rtl8180_pci_module_ex
 	DMESG("Exiting");
 }
 
-
 void rtl8180_try_wake_queue(struct net_device *dev, int pri)
 {
 	unsigned long flags;
@@ -4879,25 +4073,17 @@ void rtl8180_try_wake_queue(struct net_d
 		ieee80211_wake_queue(priv->ieee80211);
 }
 
-/*****************************************************************************
-      -----------------------------IRQ STUFF---------------------------
-******************************************************************************/
-
 void rtl8180_tx_isr(struct net_device *dev, int pri,short error)
 {
 	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-
 	u32 *tail; //tail virtual addr
 	u32 *head; //head virtual addr
 	u32 *begin;//start of ring virtual addr
 	u32 *nicv; //nic pointer virtual addr
-//	u32 *txdv; //packet just TXed
 	u32 nic; //nic pointer physical addr
 	u32 nicbegin;// start of ring physical addr
-//	short txed;
 	unsigned long flag;
 	/* physical addr are ok on 32 bits since we set DMA mask*/
-
 	int offs;
 	int j,i;
 	int hd;
@@ -4911,7 +4097,6 @@ void rtl8180_tx_isr(struct net_device *d
 		nic = read_nic_dword(dev,TX_MANAGEPRIORITY_RING_ADDR);
 		nicbegin = priv->txmapringdma;
 		break;
-
 	case BK_PRIORITY:
 		tail = priv->txbkpringtail;
 		begin = priv->txbkpring;
@@ -4919,7 +4104,6 @@ void rtl8180_tx_isr(struct net_device *d
 		nic = read_nic_dword(dev,TX_BKPRIORITY_RING_ADDR);
 		nicbegin = priv->txbkpringdma;
 		break;
-
 	case BE_PRIORITY:
 		tail = priv->txbepringtail;
 		begin = priv->txbepring;
@@ -4927,7 +4111,6 @@ void rtl8180_tx_isr(struct net_device *d
 		nic = read_nic_dword(dev,TX_BEPRIORITY_RING_ADDR);
 		nicbegin = priv->txbepringdma;
 		break;
-
 	case VI_PRIORITY:
 		tail = priv->txvipringtail;
 		begin = priv->txvipring;
@@ -4935,7 +4118,6 @@ void rtl8180_tx_isr(struct net_device *d
 		nic = read_nic_dword(dev,TX_VIPRIORITY_RING_ADDR);
 		nicbegin = priv->txvipringdma;
 		break;
-
 	case VO_PRIORITY:
 		tail = priv->txvopringtail;
 		begin = priv->txvopring;
@@ -4943,7 +4125,6 @@ void rtl8180_tx_isr(struct net_device *d
 		nic = read_nic_dword(dev,TX_VOPRIORITY_RING_ADDR);
 		nicbegin = priv->txvopringdma;
 		break;
-
 	case HI_PRIORITY:
 		tail = priv->txhpringtail;
 		begin = priv->txhpring;
@@ -4956,12 +4137,7 @@ void rtl8180_tx_isr(struct net_device *d
 		spin_unlock_irqrestore(&priv->tx_lock,flag);
 		return ;
 	}
-/*	DMESG("%x %s %x %x",((int)nic & 0xfff)/8/4,
-	*(priv->txnpring + ((int)nic&0xfff)/4/8) & (1<<31) ? "filled" : "empty",
-	(priv->txnpringtail - priv->txnpring)/8,(priv->txnpringhead -
-priv->txnpring)/8);
-*/
-	//nicv = (u32*) ((nic - nicbegin) + (int)begin);
+
 	nicv = (u32*) ((nic - nicbegin) + (u8*)begin);
 	if((head <= tail && (nicv > tail || nicv < head)) ||
 		(head > tail && (nicv > tail && nicv < head))){
@@ -4975,56 +4151,39 @@ priv->txnpring)/8);
 	 * but not the currenly pointed by the nic (the next to be txed)
 	 * and the previous of the pointed (might be in process ??)
 	*/
-	//if (head == nic) return;
-	//DMESG("%x %x",head,nic);
 	offs = (nic - nicbegin);
-	//DMESG("%x %x %x",nic ,(u32)nicbegin, (int)nic -nicbegin);
-
 	offs = offs / 8 /4;
-
 	hd = (head - begin) /8;
 
 	if(offs >= hd)
 		j = offs - hd;
 	else
 		j = offs + (priv->txringcount -1 -hd);
-	//	j= priv->txringcount -1- (hd - offs);
 
 	j-=2;
 	if(j<0) j=0;
 
-
 	for(i=0;i<j;i++)
 	{
-//		printk("+++++++++++++check status desc\n");
 		if((*head) & (1<<31))
 			break;
 		if(((*head)&(0x10000000)) != 0){
-//			printk("++++++++++++++last desc,retry count is %d\n",((*head) & (0x000000ff)));
 			priv->CurrRetryCnt += (u16)((*head) & (0x000000ff));
-#if 1
-			if(!error)
-			{
+			if (!error)
 				priv->NumTxOkTotal++;
-//				printk("NumTxOkTotal is %d\n",priv->NumTxOkTotal++);
-			}
-#endif
-			//	printk("in function %s:curr_retry_count is %d\n",__func__,((*head) & (0x000000ff)));
 		}
-		if(!error){
+
+		if (!error)
 			priv->NumTxOkBytesTotal += (*(head+3)) & (0x00000fff);
-		}
-//		printk("in function %s:curr_txokbyte_count is %d\n",__func__,(*(head+3)) & (0x00000fff));
+
 		*head = *head &~ (1<<31);
 
 		if((head - begin)/8 == priv->txringcount-1)
 			head=begin;
-
 		else
 			head+=8;
 	}
 
-	//DMESG("%x",txdv[0]);
 	/* the head has been moved to the last certainly TXed
 	 * (or at least processed by the nic) packet.
 	 * The driver take forcefully owning of all these packets
@@ -5037,53 +4196,36 @@ priv->txnpring)/8);
 	switch(pri) {
 	case MANAGE_PRIORITY:
 		priv->txmapringhead = head;
-			//printk("1==========================================> priority check!\n");
+
 		if(priv->ack_tx_to_ieee){
-				// try to implement power-save mode 2008.1.22
-		//	printk("2==========================================> priority check!\n");
-#if 1
 			if(rtl8180_is_tx_queue_empty(dev)){
-			//	printk("tx queue empty, after send null sleep packet, try to sleep !\n");
 				priv->ack_tx_to_ieee = 0;
 				ieee80211_ps_tx_ack(priv->ieee80211,!error);
 			}
-#endif
 		}
 		break;
-
 	case BK_PRIORITY:
 		priv->txbkpringhead = head;
 		break;
-
 	case BE_PRIORITY:
 		priv->txbepringhead = head;
 		break;
-
 	case VI_PRIORITY:
 		priv->txvipringhead = head;
 		break;
-
 	case VO_PRIORITY:
 		priv->txvopringhead = head;
 		break;
-
 	case HI_PRIORITY:
 		priv->txhpringhead = head;
 		break;
 	}
 
-	/*DMESG("%x %x %x", (priv->txnpringhead - priv->txnpring) /8 ,
-		(priv->txnpringtail - priv->txnpring) /8,
-		offs );
-	*/
-
 	spin_unlock_irqrestore(&priv->tx_lock,flag);
-
 }
 
 void rtl8180_tx_irq_wq(struct work_struct *work)
 {
-	//struct r8180_priv *priv = container_of(work, struct r8180_priv, reset_wq);
 	struct delayed_work *dwork = to_delayed_work(work);
 	struct ieee80211_device * ieee = (struct ieee80211_device*)
 	                                       container_of(dwork, struct ieee80211_device, watch_dog_wq);
@@ -5109,8 +4251,6 @@ irqreturn_t rtl8180_interrupt(int irq, v
 
 	priv->stats.shints++;
 
-	//DMESG("Enter interrupt, ISR value = 0x%08x", inta);
-
 	if(!inta){
 		spin_unlock_irqrestore(&priv->irq_th_lock,flags);
 		return IRQ_HANDLED;
@@ -5120,41 +4260,30 @@ irqreturn_t rtl8180_interrupt(int irq, v
 	*/
 	}
 
-	if(inta == 0xffff){
-			/* HW disappared */
-			spin_unlock_irqrestore(&priv->irq_th_lock,flags);
-			return IRQ_HANDLED;
+	if (inta == 0xffff) {
+		/* HW disappared */
+		spin_unlock_irqrestore(&priv->irq_th_lock, flags);
+		return IRQ_HANDLED;
 	}
 
 	priv->stats.ints++;
-	//priv->irqpending = inta;
-
 
 	if(!netif_running(dev)) {
 		spin_unlock_irqrestore(&priv->irq_th_lock,flags);
 		return IRQ_HANDLED;
 	}
 
-	if(inta & ISR_TimeOut){
+	if (inta & ISR_TimeOut)
 		write_nic_dword(dev, TimerInt, 0);
-		//DMESG("=================>waking up");
-//		rtl8180_hw_wakeup(dev);
-	}
 
-	if(inta & ISR_TBDOK){
+	if (inta & ISR_TBDOK)
 		priv->stats.txbeacon++;
-	}
 
-	if(inta & ISR_TBDER){
+	if (inta & ISR_TBDER)
 		priv->stats.txbeaconerr++;
-	}
 
-	if(inta  & IMR_TMGDOK ) {
-//		priv->NumTxOkTotal++;
+	if (inta & IMR_TMGDOK)
 		rtl8180_tx_isr(dev,MANAGE_PRIORITY,0);
-//			schedule_work(&priv->tx_irq_wq);
-
-	}
 
 	if(inta & ISR_THPDER){
 		priv->stats.txhperr++;
@@ -5163,8 +4292,6 @@ irqreturn_t rtl8180_interrupt(int irq, v
 	}
 
 	if(inta & ISR_THPDOK){ //High priority tx ok
-//		priv->NumTxOkTotal++;
-		//priv->NumTxOkInPeriod++;  //YJ,del,080828
 		priv->link_detect.NumTxOkInPeriod++; //YJ,add,080828
 		priv->stats.txhpokint++;
 		rtl8180_tx_isr(dev,HI_PRIORITY,0);
@@ -5176,7 +4303,6 @@ irqreturn_t rtl8180_interrupt(int irq, v
 	if(inta & ISR_TBKDER){ //corresponding to BK_PRIORITY
 		priv->stats.txbkperr++;
 		priv->ieee80211->stats.tx_errors++;
-		//tasklet_schedule(&priv->irq_tx_tasklet);
 		rtl8180_tx_isr(dev,BK_PRIORITY,1);
 		rtl8180_try_wake_queue(dev, BE_PRIORITY);
 	}
@@ -5185,13 +4311,11 @@ irqreturn_t rtl8180_interrupt(int irq, v
 		priv->stats.txbeperr++;
 		priv->ieee80211->stats.tx_errors++;
 		rtl8180_tx_isr(dev,BE_PRIORITY,1);
-		//tasklet_schedule(&priv->irq_tx_tasklet);
 		rtl8180_try_wake_queue(dev, BE_PRIORITY);
 	}
 	if(inta & ISR_TNPDER){ //corresponding to VO_PRIORITY
 		priv->stats.txnperr++;
 		priv->ieee80211->stats.tx_errors++;
-		//tasklet_schedule(&priv->irq_tx_tasklet);
 		rtl8180_tx_isr(dev,NORM_PRIORITY,1);
 		rtl8180_try_wake_queue(dev, NORM_PRIORITY);
 	}
@@ -5200,23 +4324,19 @@ irqreturn_t rtl8180_interrupt(int irq, v
 		priv->stats.txlperr++;
 		priv->ieee80211->stats.tx_errors++;
 		rtl8180_tx_isr(dev,LOW_PRIORITY,1);
-		//tasklet_schedule(&priv->irq_tx_tasklet);
 		rtl8180_try_wake_queue(dev, LOW_PRIORITY);
 	}
 
 	if(inta & ISR_ROK){
-		//priv->NumRxOkInPeriod++;  //YJ,del,080828
 		priv->stats.rxint++;
 		tasklet_schedule(&priv->irq_rx_tasklet);
 	}
 
 	if(inta & ISR_RQoSOK ){
-		//priv->NumRxOkInPeriod++;  //YJ,del,080828
 		priv->stats.rxint++;
 		tasklet_schedule(&priv->irq_rx_tasklet);
 	}
 	if(inta & ISR_BcnInt) {
-		//DMESG("Preparing Beacons");
 		rtl8180_prepare_beacon(dev);
 	}
 
@@ -5224,31 +4344,24 @@ irqreturn_t rtl8180_interrupt(int irq, v
 		DMESGW("No RX descriptor available");
 		priv->stats.rxrdu++;
 		tasklet_schedule(&priv->irq_rx_tasklet);
-		/*queue_work(priv->workqueue ,&priv->restart_work);*/
-
 	}
+
 	if(inta & ISR_RXFOVW){
 		priv->stats.rxoverflow++;
 		tasklet_schedule(&priv->irq_rx_tasklet);
-		//queue_work(priv->workqueue ,&priv->restart_work);
 	}
 
-	if(inta & ISR_TXFOVW) priv->stats.txoverflow++;
+	if (inta & ISR_TXFOVW)
+		priv->stats.txoverflow++;
 
 	if(inta & ISR_TNPDOK){ //Normal priority tx ok
-//		priv->NumTxOkTotal++;
-		//priv->NumTxOkInPeriod++;  //YJ,del,080828
 		priv->link_detect.NumTxOkInPeriod++; //YJ,add,080828
-		//	priv->ieee80211->stats.tx_packets++;
 		priv->stats.txnpokint++;
 		rtl8180_tx_isr(dev,NORM_PRIORITY,0);
 	}
 
 	if(inta & ISR_TLPDOK){ //Low priority tx ok
-//		priv->NumTxOkTotal++;
-		//priv->NumTxOkInPeriod++;  //YJ,del,080828
 		priv->link_detect.NumTxOkInPeriod++; //YJ,add,080828
-		//	priv->ieee80211->stats.tx_packets++;
 		priv->stats.txlpokint++;
 		rtl8180_tx_isr(dev,LOW_PRIORITY,0);
 		rtl8180_try_wake_queue(dev, LOW_PRIORITY);
@@ -5256,8 +4369,6 @@ irqreturn_t rtl8180_interrupt(int irq, v
 
 	if(inta & ISR_TBKDOK){ //corresponding to BK_PRIORITY
 		priv->stats.txbkpokint++;
-//		priv->NumTxOkTotal++;
-		//priv->NumTxOkInPeriod++;  //YJ,del,080828
 		priv->link_detect.NumTxOkInPeriod++; //YJ,add,080828
 		rtl8180_tx_isr(dev,BK_PRIORITY,0);
 		rtl8180_try_wake_queue(dev, BE_PRIORITY);
@@ -5265,8 +4376,6 @@ irqreturn_t rtl8180_interrupt(int irq, v
 
 	if(inta & ISR_TBEDOK){ //corresponding to BE_PRIORITY
 		priv->stats.txbeperr++;
-//		priv->NumTxOkTotal++;
-		//priv->NumTxOkInPeriod++;  //YJ,del,080828
 		priv->link_detect.NumTxOkInPeriod++; //YJ,add,080828
 		rtl8180_tx_isr(dev,BE_PRIORITY,0);
 		rtl8180_try_wake_queue(dev, BE_PRIORITY);
@@ -5277,40 +4386,16 @@ irqreturn_t rtl8180_interrupt(int irq, v
 	return IRQ_HANDLED;
 }
 
-
 void rtl8180_irq_rx_tasklet(struct r8180_priv* priv)
 {
-//	unsigned long flags;
-
-/*	spin_lock_irqsave(&priv->irq_lock, flags);
-	priv->irq_mask &=~IMR_ROK;
-	priv->irq_mask &=~IMR_RDU;
-
-	rtl8180_irq_enable(priv->dev);
-	spin_unlock_irqrestore(&priv->irq_lock, flags);
-*/
 	rtl8180_rx(priv->dev);
-
-/*	spin_lock_irqsave(&priv->irq_lock, flags);
-	priv->irq_mask |= IMR_ROK;
-	priv->irq_mask |= IMR_RDU;
-	rtl8180_irq_enable(priv->dev);
-	spin_unlock_irqrestore(&priv->irq_lock, flags);
-*/
 }
 
-/****************************************************************************
-lizhaoming--------------------------- RF power on/power off -----------------
-*****************************************************************************/
-
 void GPIOChangeRFWorkItemCallBack(struct work_struct *work)
 {
-	//struct delayed_work *dwork = to_delayed_work(work);
 	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, GPIOChangeRFWorkItem.work);
 	struct net_device *dev = ieee->dev;
 	struct r8180_priv *priv = ieee80211_priv(dev);
-
-	//u16 tmp2byte;
 	u8 btPSR;
 	u8 btConfig0;
 	RT_RF_POWER_STATE	eRfPowerStateToSet;
@@ -5320,7 +4405,6 @@ void GPIOChangeRFWorkItemCallBack(struct
         static char *RadioPowerPath = "/etc/acpi/events/RadioPower.sh";
         static char *envp[] = {"HOME=/", "TERM=linux", "PATH=/usr/bin:/bin", NULL};
 	static int readf_count = 0;
-	//printk("============>%s in \n", __func__);
 
 #ifdef ENABLE_LPS
 	if(readf_count % 10 == 0)
@@ -5375,9 +4459,7 @@ void GPIOChangeRFWorkItemCallBack(struct
 
                                 call_usermodehelper(RadioPowerPath,argv,envp,1);
 			}
-
 		}
-
 }
 
 static u8 read_acadapter_file(char *filename)
@@ -5385,9 +4467,5 @@ static u8 read_acadapter_file(char *file
 	return 0;
 }
 
-/***************************************************************************
-     ------------------- module init / exit stubs ----------------
-****************************************************************************/
 module_init(rtl8180_pci_module_init);
 module_exit(rtl8180_pci_module_exit);
-
