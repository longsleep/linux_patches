From 50eeff6d23e931b9571836ff86f11d0583b4c8af Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Fri, 19 Dec 2008 17:09:38 -0800
Subject: Staging: epl: run Lindent on *.h files

It's a start, still a mess...

Cc: Daniel Krueger <daniel.krueger@systec-electronic.com>
Cc: Ronald Sieber <Ronald.Sieber@systec-electronic.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/epl/Benchmark.h         |  346 ++---
 drivers/staging/epl/Debug.h             |  988 ++++++++--------
 drivers/staging/epl/EdrvFec.h           |   24 
 drivers/staging/epl/EdrvFec5282.h       |  191 +--
 drivers/staging/epl/EdrvSim.h           |   11 
 drivers/staging/epl/Epl.h               |  319 ++---
 drivers/staging/epl/EplAmi.h            |  126 --
 drivers/staging/epl/EplApiLinux.h       |   88 -
 drivers/staging/epl/EplCfg.h            |   13 
 drivers/staging/epl/EplDef.h            |  183 +--
 drivers/staging/epl/EplDll.h            |  197 +--
 drivers/staging/epl/EplDllCal.h         |   24 
 drivers/staging/epl/EplErrDef.h         |  268 ++--
 drivers/staging/epl/EplEvent.h          |  304 ++---
 drivers/staging/epl/EplFrame.h          |  386 ++----
 drivers/staging/epl/EplInc.h            |  217 +--
 drivers/staging/epl/EplInstDef.h        |  221 +--
 drivers/staging/epl/EplLed.h            |   20 
 drivers/staging/epl/EplNmt.h            |  228 +--
 drivers/staging/epl/EplObd.h            |  418 +++---
 drivers/staging/epl/EplObdMacro.h       |  414 +++---
 drivers/staging/epl/EplObjDef.h         |   96 -
 drivers/staging/epl/EplPdo.h            |   43 
 drivers/staging/epl/EplSdo.h            |  166 +-
 drivers/staging/epl/EplSdoAc.h          |    2 
 drivers/staging/epl/EplTarget.h         |  193 +--
 drivers/staging/epl/EplTimer.h          |   46 
 drivers/staging/epl/EplVersion.h        |    6 
 drivers/staging/epl/SharedBuff.h        |  157 +-
 drivers/staging/epl/ShbIpc.h            |   77 -
 drivers/staging/epl/ShbLinuxKernel.h    |    8 
 drivers/staging/epl/SocketLinuxKernel.h |   15 
 drivers/staging/epl/edrv.h              |   90 -
 drivers/staging/epl/global.h            | 1925 +++++++++++++++-----------------
 drivers/staging/epl/proc_fs.h           |    7 
 35 files changed, 3683 insertions(+), 4134 deletions(-)

--- a/drivers/staging/epl/Benchmark.h
+++ b/drivers/staging/epl/Benchmark.h
@@ -73,31 +73,30 @@
 
 #include "global.h"
 
-
 #if (TARGET_SYSTEM == _NO_OS_) && (DEV_SYSTEM == _DEV_GNU_CF548X_)
-    #include "common.h"
+#include "common.h"
 
 #elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 
 //    #include <linux/config.h>
-    #include <linux/kernel.h>
+#include <linux/kernel.h>
 
-    #ifdef CONFIG_COLDFIRE
-        #include <asm/coldfire.h>
-        #include <asm/m5485gpio.h>
-
-        #define BENCHMARK_SET(x)    MCF_GPIO_PODR_PCIBG |= (1 << (x))   // (x+1)
-        #define BENCHMARK_RESET(x)  MCF_GPIO_PODR_PCIBG &= ~(1 << (x))  // (x+1)
-        #define BENCHMARK_TOGGLE(x) MCF_GPIO_PODR_PCIBR ^= (1 << (x - 5))
-    #else
-        #undef BENCHMARK_MODULES
-        #define BENCHMARK_MODULES           0x00000000
-    #endif
+#ifdef CONFIG_COLDFIRE
+#include <asm/coldfire.h>
+#include <asm/m5485gpio.h>
+
+#define BENCHMARK_SET(x)    MCF_GPIO_PODR_PCIBG |= (1 << (x))	// (x+1)
+#define BENCHMARK_RESET(x)  MCF_GPIO_PODR_PCIBG &= ~(1 << (x))	// (x+1)
+#define BENCHMARK_TOGGLE(x) MCF_GPIO_PODR_PCIBR ^= (1 << (x - 5))
+#else
+#undef BENCHMARK_MODULES
+#define BENCHMARK_MODULES           0x00000000
+#endif
 
 #else
     // disable Benchmarking
-    #undef BENCHMARK_MODULES
-    #define BENCHMARK_MODULES               0x00000000
+#undef BENCHMARK_MODULES
+#define BENCHMARK_MODULES               0x00000000
 #endif
 
 /***************************************************************************/
@@ -149,295 +148,290 @@
 #define BENCHMARK_MOD_31                    0x40000000
 #define BENCHMARK_MOD_32                    0x80000000
 
-
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_01)
-    #define BENCHMARK_MOD_01_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_01_RESET(x)       BENCHMARK_RESET(x)
-    #define BENCHMARK_MOD_01_TOGGLE(x)      BENCHMARK_TOGGLE(x)
-#else
-    #define BENCHMARK_MOD_01_SET(x)
-    #define BENCHMARK_MOD_01_RESET(x)
-    #define BENCHMARK_MOD_01_TOGGLE(x)
+#define BENCHMARK_MOD_01_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_01_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_01_TOGGLE(x)      BENCHMARK_TOGGLE(x)
+#else
+#define BENCHMARK_MOD_01_SET(x)
+#define BENCHMARK_MOD_01_RESET(x)
+#define BENCHMARK_MOD_01_TOGGLE(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_02)
-    #define BENCHMARK_MOD_02_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_02_RESET(x)       BENCHMARK_RESET(x)
-    #define BENCHMARK_MOD_02_TOGGLE(x)      BENCHMARK_TOGGLE(x)
-#else
-    #define BENCHMARK_MOD_02_SET(x)
-    #define BENCHMARK_MOD_02_RESET(x)
-    #define BENCHMARK_MOD_02_TOGGLE(x)
+#define BENCHMARK_MOD_02_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_02_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_02_TOGGLE(x)      BENCHMARK_TOGGLE(x)
+#else
+#define BENCHMARK_MOD_02_SET(x)
+#define BENCHMARK_MOD_02_RESET(x)
+#define BENCHMARK_MOD_02_TOGGLE(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_03)
-    #define BENCHMARK_MOD_03_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_03_RESET(x)       BENCHMARK_RESET(x)
-    #define BENCHMARK_MOD_03_TOGGLE(x)      BENCHMARK_TOGGLE(x)
-#else
-    #define BENCHMARK_MOD_03_SET(x)
-    #define BENCHMARK_MOD_03_RESET(x)
-    #define BENCHMARK_MOD_03_TOGGLE(x)
+#define BENCHMARK_MOD_03_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_03_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_03_TOGGLE(x)      BENCHMARK_TOGGLE(x)
+#else
+#define BENCHMARK_MOD_03_SET(x)
+#define BENCHMARK_MOD_03_RESET(x)
+#define BENCHMARK_MOD_03_TOGGLE(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_04)
-    #define BENCHMARK_MOD_04_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_04_RESET(x)       BENCHMARK_RESET(x)
-    #define BENCHMARK_MOD_04_TOGGLE(x)      BENCHMARK_TOGGLE(x)
-#else
-    #define BENCHMARK_MOD_04_SET(x)
-    #define BENCHMARK_MOD_04_RESET(x)
-    #define BENCHMARK_MOD_04_TOGGLE(x)
+#define BENCHMARK_MOD_04_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_04_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_04_TOGGLE(x)      BENCHMARK_TOGGLE(x)
+#else
+#define BENCHMARK_MOD_04_SET(x)
+#define BENCHMARK_MOD_04_RESET(x)
+#define BENCHMARK_MOD_04_TOGGLE(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_05)
-    #define BENCHMARK_MOD_05_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_05_RESET(x)       BENCHMARK_RESET(x)
-    #define BENCHMARK_MOD_05_TOGGLE(x)      BENCHMARK_TOGGLE(x)
-#else
-    #define BENCHMARK_MOD_05_SET(x)
-    #define BENCHMARK_MOD_05_RESET(x)
-    #define BENCHMARK_MOD_05_TOGGLE(x)
+#define BENCHMARK_MOD_05_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_05_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_05_TOGGLE(x)      BENCHMARK_TOGGLE(x)
+#else
+#define BENCHMARK_MOD_05_SET(x)
+#define BENCHMARK_MOD_05_RESET(x)
+#define BENCHMARK_MOD_05_TOGGLE(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_06)
-    #define BENCHMARK_MOD_06_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_06_RESET(x)       BENCHMARK_RESET(x)
-    #define BENCHMARK_MOD_06_TOGGLE(x)      BENCHMARK_TOGGLE(x)
-#else
-    #define BENCHMARK_MOD_06_SET(x)
-    #define BENCHMARK_MOD_06_RESET(x)
-    #define BENCHMARK_MOD_06_TOGGLE(x)
+#define BENCHMARK_MOD_06_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_06_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_06_TOGGLE(x)      BENCHMARK_TOGGLE(x)
+#else
+#define BENCHMARK_MOD_06_SET(x)
+#define BENCHMARK_MOD_06_RESET(x)
+#define BENCHMARK_MOD_06_TOGGLE(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_07)
-    #define BENCHMARK_MOD_07_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_07_RESET(x)       BENCHMARK_RESET(x)
-    #define BENCHMARK_MOD_07_TOGGLE(x)      BENCHMARK_TOGGLE(x)
-#else
-    #define BENCHMARK_MOD_07_SET(x)
-    #define BENCHMARK_MOD_07_RESET(x)
-    #define BENCHMARK_MOD_07_TOGGLE(x)
+#define BENCHMARK_MOD_07_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_07_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_07_TOGGLE(x)      BENCHMARK_TOGGLE(x)
+#else
+#define BENCHMARK_MOD_07_SET(x)
+#define BENCHMARK_MOD_07_RESET(x)
+#define BENCHMARK_MOD_07_TOGGLE(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_08)
-    #define BENCHMARK_MOD_08_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_08_RESET(x)       BENCHMARK_RESET(x)
-    #define BENCHMARK_MOD_08_TOGGLE(x)      BENCHMARK_TOGGLE(x)
-#else
-    #define BENCHMARK_MOD_08_SET(x)
-    #define BENCHMARK_MOD_08_RESET(x)
-    #define BENCHMARK_MOD_08_TOGGLE(x)
+#define BENCHMARK_MOD_08_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_08_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_08_TOGGLE(x)      BENCHMARK_TOGGLE(x)
+#else
+#define BENCHMARK_MOD_08_SET(x)
+#define BENCHMARK_MOD_08_RESET(x)
+#define BENCHMARK_MOD_08_TOGGLE(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_09)
-    #define BENCHMARK_MOD_09_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_09_RESET(x)       BENCHMARK_RESET(x)
-    #define BENCHMARK_MOD_09_TOGGLE(x)      BENCHMARK_TOGGLE(x)
-#else
-    #define BENCHMARK_MOD_09_SET(x)
-    #define BENCHMARK_MOD_09_RESET(x)
-    #define BENCHMARK_MOD_09_TOGGLE(x)
+#define BENCHMARK_MOD_09_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_09_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_09_TOGGLE(x)      BENCHMARK_TOGGLE(x)
+#else
+#define BENCHMARK_MOD_09_SET(x)
+#define BENCHMARK_MOD_09_RESET(x)
+#define BENCHMARK_MOD_09_TOGGLE(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_10)
-    #define BENCHMARK_MOD_10_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_10_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_10_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_10_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_10_SET(x)
-    #define BENCHMARK_MOD_10_RESET(x)
+#define BENCHMARK_MOD_10_SET(x)
+#define BENCHMARK_MOD_10_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_11)
-    #define BENCHMARK_MOD_11_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_11_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_11_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_11_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_11_SET(x)
-    #define BENCHMARK_MOD_11_RESET(x)
+#define BENCHMARK_MOD_11_SET(x)
+#define BENCHMARK_MOD_11_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_12)
-    #define BENCHMARK_MOD_12_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_12_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_12_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_12_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_12_SET(x)
-    #define BENCHMARK_MOD_12_RESET(x)
+#define BENCHMARK_MOD_12_SET(x)
+#define BENCHMARK_MOD_12_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_13)
-    #define BENCHMARK_MOD_13_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_13_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_13_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_13_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_13_SET(x)
-    #define BENCHMARK_MOD_13_RESET(x)
+#define BENCHMARK_MOD_13_SET(x)
+#define BENCHMARK_MOD_13_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_14)
-    #define BENCHMARK_MOD_14_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_14_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_14_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_14_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_14_SET(x)
-    #define BENCHMARK_MOD_14_RESET(x)
+#define BENCHMARK_MOD_14_SET(x)
+#define BENCHMARK_MOD_14_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_15)
-    #define BENCHMARK_MOD_15_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_15_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_15_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_15_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_15_SET(x)
-    #define BENCHMARK_MOD_15_RESET(x)
+#define BENCHMARK_MOD_15_SET(x)
+#define BENCHMARK_MOD_15_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_16)
-    #define BENCHMARK_MOD_16_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_16_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_16_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_16_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_16_SET(x)
-    #define BENCHMARK_MOD_16_RESET(x)
+#define BENCHMARK_MOD_16_SET(x)
+#define BENCHMARK_MOD_16_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_17)
-    #define BENCHMARK_MOD_17_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_17_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_17_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_17_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_17_SET(x)
-    #define BENCHMARK_MOD_17_RESET(x)
+#define BENCHMARK_MOD_17_SET(x)
+#define BENCHMARK_MOD_17_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_18)
-    #define BENCHMARK_MOD_18_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_18_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_18_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_18_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_18_SET(x)
-    #define BENCHMARK_MOD_18_RESET(x)
+#define BENCHMARK_MOD_18_SET(x)
+#define BENCHMARK_MOD_18_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_19)
-    #define BENCHMARK_MOD_19_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_19_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_19_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_19_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_19_SET(x)
-    #define BENCHMARK_MOD_19_RESET(x)
+#define BENCHMARK_MOD_19_SET(x)
+#define BENCHMARK_MOD_19_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_20)
-    #define BENCHMARK_MOD_20_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_20_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_20_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_20_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_20_SET(x)
-    #define BENCHMARK_MOD_20_RESET(x)
+#define BENCHMARK_MOD_20_SET(x)
+#define BENCHMARK_MOD_20_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_21)
-    #define BENCHMARK_MOD_21_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_21_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_21_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_21_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_21_SET(x)
-    #define BENCHMARK_MOD_21_RESET(x)
+#define BENCHMARK_MOD_21_SET(x)
+#define BENCHMARK_MOD_21_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_22)
-    #define BENCHMARK_MOD_22_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_22_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_22_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_22_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_22_SET(x)
-    #define BENCHMARK_MOD_22_RESET(x)
+#define BENCHMARK_MOD_22_SET(x)
+#define BENCHMARK_MOD_22_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_23)
-    #define BENCHMARK_MOD_23_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_23_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_23_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_23_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_23_SET(x)
-    #define BENCHMARK_MOD_23_RESET(x)
+#define BENCHMARK_MOD_23_SET(x)
+#define BENCHMARK_MOD_23_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_24)
-    #define BENCHMARK_MOD_24_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_24_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_24_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_24_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_24_SET(x)
-    #define BENCHMARK_MOD_24_RESET(x)
+#define BENCHMARK_MOD_24_SET(x)
+#define BENCHMARK_MOD_24_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_25)
-    #define BENCHMARK_MOD_25_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_25_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_25_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_25_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_25_SET(x)
-    #define BENCHMARK_MOD_25_RESET(x)
+#define BENCHMARK_MOD_25_SET(x)
+#define BENCHMARK_MOD_25_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_26)
-    #define BENCHMARK_MOD_26_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_26_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_26_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_26_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_26_SET(x)
-    #define BENCHMARK_MOD_26_RESET(x)
+#define BENCHMARK_MOD_26_SET(x)
+#define BENCHMARK_MOD_26_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_27)
-    #define BENCHMARK_MOD_27_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_27_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_27_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_27_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_27_SET(x)
-    #define BENCHMARK_MOD_27_RESET(x)
+#define BENCHMARK_MOD_27_SET(x)
+#define BENCHMARK_MOD_27_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_28)
-    #define BENCHMARK_MOD_28_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_28_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_28_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_28_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_28_SET(x)
-    #define BENCHMARK_MOD_28_RESET(x)
+#define BENCHMARK_MOD_28_SET(x)
+#define BENCHMARK_MOD_28_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_29)
-    #define BENCHMARK_MOD_29_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_29_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_29_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_29_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_29_SET(x)
-    #define BENCHMARK_MOD_29_RESET(x)
+#define BENCHMARK_MOD_29_SET(x)
+#define BENCHMARK_MOD_29_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_30)
-    #define BENCHMARK_MOD_30_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_30_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_30_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_30_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_30_SET(x)
-    #define BENCHMARK_MOD_30_RESET(x)
+#define BENCHMARK_MOD_30_SET(x)
+#define BENCHMARK_MOD_30_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_31)
-    #define BENCHMARK_MOD_31_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_31_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_31_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_31_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_31_SET(x)
-    #define BENCHMARK_MOD_31_RESET(x)
+#define BENCHMARK_MOD_31_SET(x)
+#define BENCHMARK_MOD_31_RESET(x)
 #endif
 
 #if (BENCHMARK_MODULES & BENCHMARK_MOD_32)
-    #define BENCHMARK_MOD_32_SET(x)         BENCHMARK_SET(x)
-    #define BENCHMARK_MOD_32_RESET(x)       BENCHMARK_RESET(x)
+#define BENCHMARK_MOD_32_SET(x)         BENCHMARK_SET(x)
+#define BENCHMARK_MOD_32_RESET(x)       BENCHMARK_RESET(x)
 #else
-    #define BENCHMARK_MOD_32_SET(x)
-    #define BENCHMARK_MOD_32_RESET(x)
+#define BENCHMARK_MOD_32_SET(x)
+#define BENCHMARK_MOD_32_RESET(x)
 #endif
 
-
 //---------------------------------------------------------------------------
 // modul global types
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // local vars
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 #endif // _BENCHMARK_H_
--- a/drivers/staging/epl/Debug.h
+++ b/drivers/staging/epl/Debug.h
@@ -71,7 +71,6 @@
 
 #include "global.h"
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -122,30 +121,24 @@
 #define DEBUG_LVL_ERROR                 0x40000000
 #define DEBUG_LVL_ALWAYS                0x80000000
 
-
 //---------------------------------------------------------------------------
 // global types
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // global vars
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // global function prototypes
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // global macros
 //---------------------------------------------------------------------------
 
 //---------------------------------------------------------------------------
 // this macro defines a version string
-#define MAKE_VERSION_STRING(product,appname,verstr,author) \
-    "§prd§:" product ",§app§:" appname ",§ver§:" verstr ",§dat§:" __DATE__ ",§aut§:" author
 
 
 //---------------------------------------------------------------------------
@@ -159,18 +152,16 @@
     prefix "Version:   " verstr                               "\n" \
     prefix "***************************************************\n\n"
 
-
 //---------------------------------------------------------------------------
 // The default debug-level is: ERROR and ALWAYS.
 // You can define an other debug-level in project settings.
 #ifndef DEF_DEBUG_LVL
-    #define DEF_DEBUG_LVL                   (DEBUG_LVL_ALWAYS | DEBUG_LVL_ERROR)
+#define DEF_DEBUG_LVL                   (DEBUG_LVL_ALWAYS | DEBUG_LVL_ERROR)
 #endif
 #ifndef DEBUG_GLB_LVL
-    #define DEBUG_GLB_LVL()                 (DEF_DEBUG_LVL)
+#define DEBUG_GLB_LVL()                 (DEF_DEBUG_LVL)
 #endif
 
-
 //---------------------------------------------------------------------------
 #if (DEV_SYSTEM == _DEV_WIN32_) && defined (TRACE_MSG)
 
@@ -182,12 +173,12 @@
     //
     // Example: DEBUG_TRACE1(DEBUG_LVL_30 | DEBUG_LVL_02, "Hello %d", bCount);
 
-    #define DEBUG_TRACE0(lvl,str)               TraceLvl((lvl),str)
-    #define DEBUG_TRACE1(lvl,str,p1)            TraceLvl((lvl),str,p1)
-    #define DEBUG_TRACE2(lvl,str,p1,p2)         TraceLvl((lvl),str,p1,p2)
-    #define DEBUG_TRACE3(lvl,str,p1,p2,p3)      TraceLvl((lvl),str,p1,p2,p3)
-    #define DEBUG_TRACE4(lvl,str,p1,p2,p3,p4)   TraceLvl((lvl),str,p1,p2,p3,p4)
-    #define DEBUG_GLB_LVL()                     dwDebugLevel_g
+#define DEBUG_TRACE0(lvl,str)               TraceLvl((lvl),str)
+#define DEBUG_TRACE1(lvl,str,p1)            TraceLvl((lvl),str,p1)
+#define DEBUG_TRACE2(lvl,str,p1,p2)         TraceLvl((lvl),str,p1,p2)
+#define DEBUG_TRACE3(lvl,str,p1,p2,p3)      TraceLvl((lvl),str,p1,p2,p3)
+#define DEBUG_TRACE4(lvl,str,p1,p2,p3,p4)   TraceLvl((lvl),str,p1,p2,p3,p4)
+#define DEBUG_GLB_LVL()                     dwDebugLevel_g
 
 #else
 
@@ -198,462 +189,461 @@
     //
     // Example: DEBUG_TRACE1(DEBUG_LVL_ERROR, "error code %d", dwRet);
 
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_ALWAYS)
-        #define DEBUG_LVL_ALWAYS_TRACE0(str)                TRACE0(str)
-        #define DEBUG_LVL_ALWAYS_TRACE1(str,p1)             TRACE1(str,p1)
-        #define DEBUG_LVL_ALWAYS_TRACE2(str,p1,p2)          TRACE2(str,p1,p2)
-        #define DEBUG_LVL_ALWAYS_TRACE3(str,p1,p2,p3)       TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_ALWAYS_TRACE4(str,p1,p2,p3,p4)    TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_ALWAYS_TRACE0(str)
-        #define DEBUG_LVL_ALWAYS_TRACE1(str,p1)
-        #define DEBUG_LVL_ALWAYS_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_ALWAYS_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_ALWAYS_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_ERROR)
-        #define DEBUG_LVL_ERROR_TRACE0(str)                 TRACE0(str)
-        #define DEBUG_LVL_ERROR_TRACE1(str,p1)              TRACE1(str,p1)
-        #define DEBUG_LVL_ERROR_TRACE2(str,p1,p2)           TRACE2(str,p1,p2)
-        #define DEBUG_LVL_ERROR_TRACE3(str,p1,p2,p3)        TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_ERROR_TRACE4(str,p1,p2,p3,p4)     TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_ERROR_TRACE0(str)
-        #define DEBUG_LVL_ERROR_TRACE1(str,p1)
-        #define DEBUG_LVL_ERROR_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_ERROR_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_ERROR_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_ASSERT)
-        #define DEBUG_LVL_ASSERT_TRACE0(str)                TRACE0(str)
-        #define DEBUG_LVL_ASSERT_TRACE1(str,p1)             TRACE1(str,p1)
-        #define DEBUG_LVL_ASSERT_TRACE2(str,p1,p2)          TRACE2(str,p1,p2)
-        #define DEBUG_LVL_ASSERT_TRACE3(str,p1,p2,p3)       TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_ASSERT_TRACE4(str,p1,p2,p3,p4)    TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_ASSERT_TRACE0(str)
-        #define DEBUG_LVL_ASSERT_TRACE1(str,p1)
-        #define DEBUG_LVL_ASSERT_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_ASSERT_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_ASSERT_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_29)
-        #define DEBUG_LVL_29_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_29_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_29_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_29_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_29_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_29_TRACE0(str)
-        #define DEBUG_LVL_29_TRACE1(str,p1)
-        #define DEBUG_LVL_29_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_29_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_29_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_28)
-        #define DEBUG_LVL_28_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_28_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_28_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_28_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_28_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_28_TRACE0(str)
-        #define DEBUG_LVL_28_TRACE1(str,p1)
-        #define DEBUG_LVL_28_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_28_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_28_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_27)
-        #define DEBUG_LVL_27_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_27_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_27_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_27_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_27_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_27_TRACE0(str)
-        #define DEBUG_LVL_27_TRACE1(str,p1)
-        #define DEBUG_LVL_27_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_27_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_27_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_26)
-        #define DEBUG_LVL_26_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_26_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_26_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_26_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_26_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_26_TRACE0(str)
-        #define DEBUG_LVL_26_TRACE1(str,p1)
-        #define DEBUG_LVL_26_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_26_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_26_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_25)
-        #define DEBUG_LVL_25_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_25_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_25_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_25_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_25_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_25_TRACE0(str)
-        #define DEBUG_LVL_25_TRACE1(str,p1)
-        #define DEBUG_LVL_25_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_25_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_25_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_24)
-        #define DEBUG_LVL_24_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_24_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_24_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_24_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_24_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_24_TRACE0(str)
-        #define DEBUG_LVL_24_TRACE1(str,p1)
-        #define DEBUG_LVL_24_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_24_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_24_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_23)
-        #define DEBUG_LVL_23_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_23_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_23_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_23_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_23_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_23_TRACE0(str)
-        #define DEBUG_LVL_23_TRACE1(str,p1)
-        #define DEBUG_LVL_23_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_23_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_23_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_22)
-        #define DEBUG_LVL_22_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_22_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_22_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_22_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_22_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_22_TRACE0(str)
-        #define DEBUG_LVL_22_TRACE1(str,p1)
-        #define DEBUG_LVL_22_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_22_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_22_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_21)
-        #define DEBUG_LVL_21_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_21_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_21_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_21_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_21_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_21_TRACE0(str)
-        #define DEBUG_LVL_21_TRACE1(str,p1)
-        #define DEBUG_LVL_21_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_21_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_21_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_20)
-        #define DEBUG_LVL_20_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_20_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_20_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_20_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_20_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_20_TRACE0(str)
-        #define DEBUG_LVL_20_TRACE1(str,p1)
-        #define DEBUG_LVL_20_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_20_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_20_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_19)
-        #define DEBUG_LVL_19_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_19_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_19_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_19_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_19_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_19_TRACE0(str)
-        #define DEBUG_LVL_19_TRACE1(str,p1)
-        #define DEBUG_LVL_19_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_19_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_19_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_18)
-        #define DEBUG_LVL_18_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_18_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_18_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_18_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_18_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_18_TRACE0(str)
-        #define DEBUG_LVL_18_TRACE1(str,p1)
-        #define DEBUG_LVL_18_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_18_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_18_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_17)
-        #define DEBUG_LVL_17_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_17_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_17_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_17_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_17_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_17_TRACE0(str)
-        #define DEBUG_LVL_17_TRACE1(str,p1)
-        #define DEBUG_LVL_17_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_17_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_17_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_16)
-        #define DEBUG_LVL_16_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_16_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_16_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_16_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_16_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_16_TRACE0(str)
-        #define DEBUG_LVL_16_TRACE1(str,p1)
-        #define DEBUG_LVL_16_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_16_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_16_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_15)
-        #define DEBUG_LVL_15_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_15_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_15_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_15_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_15_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_15_TRACE0(str)
-        #define DEBUG_LVL_15_TRACE1(str,p1)
-        #define DEBUG_LVL_15_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_15_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_15_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_14)
-        #define DEBUG_LVL_14_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_14_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_14_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_14_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_14_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_14_TRACE0(str)
-        #define DEBUG_LVL_14_TRACE1(str,p1)
-        #define DEBUG_LVL_14_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_14_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_14_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_13)
-        #define DEBUG_LVL_13_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_13_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_13_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_13_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_13_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_13_TRACE0(str)
-        #define DEBUG_LVL_13_TRACE1(str,p1)
-        #define DEBUG_LVL_13_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_13_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_13_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_12)
-        #define DEBUG_LVL_12_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_12_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_12_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_12_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_12_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_12_TRACE0(str)
-        #define DEBUG_LVL_12_TRACE1(str,p1)
-        #define DEBUG_LVL_12_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_12_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_12_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_11)
-        #define DEBUG_LVL_11_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_11_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_11_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_11_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_11_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_11_TRACE0(str)
-        #define DEBUG_LVL_11_TRACE1(str,p1)
-        #define DEBUG_LVL_11_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_11_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_11_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_10)
-        #define DEBUG_LVL_10_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_10_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_10_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_10_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_10_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_10_TRACE0(str)
-        #define DEBUG_LVL_10_TRACE1(str,p1)
-        #define DEBUG_LVL_10_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_10_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_10_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_09)
-        #define DEBUG_LVL_09_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_09_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_09_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_09_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_09_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_09_TRACE0(str)
-        #define DEBUG_LVL_09_TRACE1(str,p1)
-        #define DEBUG_LVL_09_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_09_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_09_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_08)
-        #define DEBUG_LVL_08_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_08_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_08_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_08_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_08_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_08_TRACE0(str)
-        #define DEBUG_LVL_08_TRACE1(str,p1)
-        #define DEBUG_LVL_08_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_08_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_08_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_07)
-        #define DEBUG_LVL_07_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_07_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_07_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_07_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_07_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_07_TRACE0(str)
-        #define DEBUG_LVL_07_TRACE1(str,p1)
-        #define DEBUG_LVL_07_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_07_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_07_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_06)
-        #define DEBUG_LVL_06_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_06_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_06_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_06_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_06_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_06_TRACE0(str)
-        #define DEBUG_LVL_06_TRACE1(str,p1)
-        #define DEBUG_LVL_06_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_06_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_06_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_05)
-        #define DEBUG_LVL_05_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_05_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_05_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_05_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_05_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_05_TRACE0(str)
-        #define DEBUG_LVL_05_TRACE1(str,p1)
-        #define DEBUG_LVL_05_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_05_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_05_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_04)
-        #define DEBUG_LVL_04_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_04_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_04_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_04_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_04_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_04_TRACE0(str)
-        #define DEBUG_LVL_04_TRACE1(str,p1)
-        #define DEBUG_LVL_04_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_04_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_04_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_03)
-        #define DEBUG_LVL_03_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_03_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_03_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_03_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_03_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_03_TRACE0(str)
-        #define DEBUG_LVL_03_TRACE1(str,p1)
-        #define DEBUG_LVL_03_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_03_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_03_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_02)
-        #define DEBUG_LVL_02_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_02_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_02_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_02_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_02_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_02_TRACE0(str)
-        #define DEBUG_LVL_02_TRACE1(str,p1)
-        #define DEBUG_LVL_02_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_02_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_02_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #if (DEBUG_GLB_LVL() & DEBUG_LVL_01)
-        #define DEBUG_LVL_01_TRACE0(str)                    TRACE0(str)
-        #define DEBUG_LVL_01_TRACE1(str,p1)                 TRACE1(str,p1)
-        #define DEBUG_LVL_01_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
-        #define DEBUG_LVL_01_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_01_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
-    #else
-        #define DEBUG_LVL_01_TRACE0(str)
-        #define DEBUG_LVL_01_TRACE1(str,p1)
-        #define DEBUG_LVL_01_TRACE2(str,p1,p2)
-        #define DEBUG_LVL_01_TRACE3(str,p1,p2,p3)
-        #define DEBUG_LVL_01_TRACE4(str,p1,p2,p3,p4)
-    #endif
-
-    #define DEBUG_TRACE0(lvl,str)                           lvl##_TRACE0(str)
-    #define DEBUG_TRACE1(lvl,str,p1)                        lvl##_TRACE1(str,p1)
-    #define DEBUG_TRACE2(lvl,str,p1,p2)                     lvl##_TRACE2(str,p1,p2)
-    #define DEBUG_TRACE3(lvl,str,p1,p2,p3)                  lvl##_TRACE3(str,p1,p2,p3)
-    #define DEBUG_TRACE4(lvl,str,p1,p2,p3,p4)               lvl##_TRACE4(str,p1,p2,p3,p4)
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_ALWAYS)
+#define DEBUG_LVL_ALWAYS_TRACE0(str)                TRACE0(str)
+#define DEBUG_LVL_ALWAYS_TRACE1(str,p1)             TRACE1(str,p1)
+#define DEBUG_LVL_ALWAYS_TRACE2(str,p1,p2)          TRACE2(str,p1,p2)
+#define DEBUG_LVL_ALWAYS_TRACE3(str,p1,p2,p3)       TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_ALWAYS_TRACE4(str,p1,p2,p3,p4)    TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_ALWAYS_TRACE0(str)
+#define DEBUG_LVL_ALWAYS_TRACE1(str,p1)
+#define DEBUG_LVL_ALWAYS_TRACE2(str,p1,p2)
+#define DEBUG_LVL_ALWAYS_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_ALWAYS_TRACE4(str,p1,p2,p3,p4)
+#endif
 
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_ERROR)
+#define DEBUG_LVL_ERROR_TRACE0(str)                 TRACE0(str)
+#define DEBUG_LVL_ERROR_TRACE1(str,p1)              TRACE1(str,p1)
+#define DEBUG_LVL_ERROR_TRACE2(str,p1,p2)           TRACE2(str,p1,p2)
+#define DEBUG_LVL_ERROR_TRACE3(str,p1,p2,p3)        TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_ERROR_TRACE4(str,p1,p2,p3,p4)     TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_ERROR_TRACE0(str)
+#define DEBUG_LVL_ERROR_TRACE1(str,p1)
+#define DEBUG_LVL_ERROR_TRACE2(str,p1,p2)
+#define DEBUG_LVL_ERROR_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_ERROR_TRACE4(str,p1,p2,p3,p4)
 #endif
 
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_ASSERT)
+#define DEBUG_LVL_ASSERT_TRACE0(str)                TRACE0(str)
+#define DEBUG_LVL_ASSERT_TRACE1(str,p1)             TRACE1(str,p1)
+#define DEBUG_LVL_ASSERT_TRACE2(str,p1,p2)          TRACE2(str,p1,p2)
+#define DEBUG_LVL_ASSERT_TRACE3(str,p1,p2,p3)       TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_ASSERT_TRACE4(str,p1,p2,p3,p4)    TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_ASSERT_TRACE0(str)
+#define DEBUG_LVL_ASSERT_TRACE1(str,p1)
+#define DEBUG_LVL_ASSERT_TRACE2(str,p1,p2)
+#define DEBUG_LVL_ASSERT_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_ASSERT_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_29)
+#define DEBUG_LVL_29_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_29_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_29_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_29_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_29_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_29_TRACE0(str)
+#define DEBUG_LVL_29_TRACE1(str,p1)
+#define DEBUG_LVL_29_TRACE2(str,p1,p2)
+#define DEBUG_LVL_29_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_29_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_28)
+#define DEBUG_LVL_28_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_28_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_28_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_28_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_28_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_28_TRACE0(str)
+#define DEBUG_LVL_28_TRACE1(str,p1)
+#define DEBUG_LVL_28_TRACE2(str,p1,p2)
+#define DEBUG_LVL_28_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_28_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_27)
+#define DEBUG_LVL_27_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_27_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_27_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_27_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_27_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_27_TRACE0(str)
+#define DEBUG_LVL_27_TRACE1(str,p1)
+#define DEBUG_LVL_27_TRACE2(str,p1,p2)
+#define DEBUG_LVL_27_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_27_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_26)
+#define DEBUG_LVL_26_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_26_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_26_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_26_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_26_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_26_TRACE0(str)
+#define DEBUG_LVL_26_TRACE1(str,p1)
+#define DEBUG_LVL_26_TRACE2(str,p1,p2)
+#define DEBUG_LVL_26_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_26_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_25)
+#define DEBUG_LVL_25_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_25_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_25_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_25_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_25_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_25_TRACE0(str)
+#define DEBUG_LVL_25_TRACE1(str,p1)
+#define DEBUG_LVL_25_TRACE2(str,p1,p2)
+#define DEBUG_LVL_25_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_25_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_24)
+#define DEBUG_LVL_24_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_24_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_24_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_24_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_24_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_24_TRACE0(str)
+#define DEBUG_LVL_24_TRACE1(str,p1)
+#define DEBUG_LVL_24_TRACE2(str,p1,p2)
+#define DEBUG_LVL_24_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_24_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_23)
+#define DEBUG_LVL_23_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_23_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_23_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_23_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_23_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_23_TRACE0(str)
+#define DEBUG_LVL_23_TRACE1(str,p1)
+#define DEBUG_LVL_23_TRACE2(str,p1,p2)
+#define DEBUG_LVL_23_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_23_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_22)
+#define DEBUG_LVL_22_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_22_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_22_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_22_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_22_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_22_TRACE0(str)
+#define DEBUG_LVL_22_TRACE1(str,p1)
+#define DEBUG_LVL_22_TRACE2(str,p1,p2)
+#define DEBUG_LVL_22_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_22_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_21)
+#define DEBUG_LVL_21_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_21_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_21_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_21_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_21_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_21_TRACE0(str)
+#define DEBUG_LVL_21_TRACE1(str,p1)
+#define DEBUG_LVL_21_TRACE2(str,p1,p2)
+#define DEBUG_LVL_21_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_21_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_20)
+#define DEBUG_LVL_20_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_20_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_20_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_20_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_20_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_20_TRACE0(str)
+#define DEBUG_LVL_20_TRACE1(str,p1)
+#define DEBUG_LVL_20_TRACE2(str,p1,p2)
+#define DEBUG_LVL_20_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_20_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_19)
+#define DEBUG_LVL_19_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_19_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_19_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_19_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_19_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_19_TRACE0(str)
+#define DEBUG_LVL_19_TRACE1(str,p1)
+#define DEBUG_LVL_19_TRACE2(str,p1,p2)
+#define DEBUG_LVL_19_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_19_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_18)
+#define DEBUG_LVL_18_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_18_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_18_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_18_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_18_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_18_TRACE0(str)
+#define DEBUG_LVL_18_TRACE1(str,p1)
+#define DEBUG_LVL_18_TRACE2(str,p1,p2)
+#define DEBUG_LVL_18_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_18_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_17)
+#define DEBUG_LVL_17_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_17_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_17_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_17_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_17_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_17_TRACE0(str)
+#define DEBUG_LVL_17_TRACE1(str,p1)
+#define DEBUG_LVL_17_TRACE2(str,p1,p2)
+#define DEBUG_LVL_17_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_17_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_16)
+#define DEBUG_LVL_16_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_16_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_16_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_16_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_16_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_16_TRACE0(str)
+#define DEBUG_LVL_16_TRACE1(str,p1)
+#define DEBUG_LVL_16_TRACE2(str,p1,p2)
+#define DEBUG_LVL_16_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_16_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_15)
+#define DEBUG_LVL_15_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_15_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_15_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_15_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_15_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_15_TRACE0(str)
+#define DEBUG_LVL_15_TRACE1(str,p1)
+#define DEBUG_LVL_15_TRACE2(str,p1,p2)
+#define DEBUG_LVL_15_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_15_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_14)
+#define DEBUG_LVL_14_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_14_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_14_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_14_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_14_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_14_TRACE0(str)
+#define DEBUG_LVL_14_TRACE1(str,p1)
+#define DEBUG_LVL_14_TRACE2(str,p1,p2)
+#define DEBUG_LVL_14_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_14_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_13)
+#define DEBUG_LVL_13_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_13_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_13_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_13_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_13_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_13_TRACE0(str)
+#define DEBUG_LVL_13_TRACE1(str,p1)
+#define DEBUG_LVL_13_TRACE2(str,p1,p2)
+#define DEBUG_LVL_13_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_13_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_12)
+#define DEBUG_LVL_12_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_12_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_12_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_12_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_12_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_12_TRACE0(str)
+#define DEBUG_LVL_12_TRACE1(str,p1)
+#define DEBUG_LVL_12_TRACE2(str,p1,p2)
+#define DEBUG_LVL_12_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_12_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_11)
+#define DEBUG_LVL_11_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_11_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_11_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_11_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_11_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_11_TRACE0(str)
+#define DEBUG_LVL_11_TRACE1(str,p1)
+#define DEBUG_LVL_11_TRACE2(str,p1,p2)
+#define DEBUG_LVL_11_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_11_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_10)
+#define DEBUG_LVL_10_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_10_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_10_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_10_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_10_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_10_TRACE0(str)
+#define DEBUG_LVL_10_TRACE1(str,p1)
+#define DEBUG_LVL_10_TRACE2(str,p1,p2)
+#define DEBUG_LVL_10_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_10_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_09)
+#define DEBUG_LVL_09_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_09_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_09_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_09_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_09_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_09_TRACE0(str)
+#define DEBUG_LVL_09_TRACE1(str,p1)
+#define DEBUG_LVL_09_TRACE2(str,p1,p2)
+#define DEBUG_LVL_09_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_09_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_08)
+#define DEBUG_LVL_08_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_08_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_08_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_08_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_08_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_08_TRACE0(str)
+#define DEBUG_LVL_08_TRACE1(str,p1)
+#define DEBUG_LVL_08_TRACE2(str,p1,p2)
+#define DEBUG_LVL_08_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_08_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_07)
+#define DEBUG_LVL_07_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_07_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_07_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_07_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_07_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_07_TRACE0(str)
+#define DEBUG_LVL_07_TRACE1(str,p1)
+#define DEBUG_LVL_07_TRACE2(str,p1,p2)
+#define DEBUG_LVL_07_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_07_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_06)
+#define DEBUG_LVL_06_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_06_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_06_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_06_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_06_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_06_TRACE0(str)
+#define DEBUG_LVL_06_TRACE1(str,p1)
+#define DEBUG_LVL_06_TRACE2(str,p1,p2)
+#define DEBUG_LVL_06_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_06_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_05)
+#define DEBUG_LVL_05_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_05_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_05_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_05_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_05_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_05_TRACE0(str)
+#define DEBUG_LVL_05_TRACE1(str,p1)
+#define DEBUG_LVL_05_TRACE2(str,p1,p2)
+#define DEBUG_LVL_05_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_05_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_04)
+#define DEBUG_LVL_04_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_04_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_04_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_04_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_04_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_04_TRACE0(str)
+#define DEBUG_LVL_04_TRACE1(str,p1)
+#define DEBUG_LVL_04_TRACE2(str,p1,p2)
+#define DEBUG_LVL_04_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_04_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_03)
+#define DEBUG_LVL_03_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_03_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_03_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_03_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_03_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_03_TRACE0(str)
+#define DEBUG_LVL_03_TRACE1(str,p1)
+#define DEBUG_LVL_03_TRACE2(str,p1,p2)
+#define DEBUG_LVL_03_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_03_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_02)
+#define DEBUG_LVL_02_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_02_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_02_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_02_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_02_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_02_TRACE0(str)
+#define DEBUG_LVL_02_TRACE1(str,p1)
+#define DEBUG_LVL_02_TRACE2(str,p1,p2)
+#define DEBUG_LVL_02_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_02_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#if (DEBUG_GLB_LVL() & DEBUG_LVL_01)
+#define DEBUG_LVL_01_TRACE0(str)                    TRACE0(str)
+#define DEBUG_LVL_01_TRACE1(str,p1)                 TRACE1(str,p1)
+#define DEBUG_LVL_01_TRACE2(str,p1,p2)              TRACE2(str,p1,p2)
+#define DEBUG_LVL_01_TRACE3(str,p1,p2,p3)           TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_01_TRACE4(str,p1,p2,p3,p4)        TRACE4(str,p1,p2,p3,p4)
+#else
+#define DEBUG_LVL_01_TRACE0(str)
+#define DEBUG_LVL_01_TRACE1(str,p1)
+#define DEBUG_LVL_01_TRACE2(str,p1,p2)
+#define DEBUG_LVL_01_TRACE3(str,p1,p2,p3)
+#define DEBUG_LVL_01_TRACE4(str,p1,p2,p3,p4)
+#endif
+
+#define DEBUG_TRACE0(lvl,str)                           lvl##_TRACE0(str)
+#define DEBUG_TRACE1(lvl,str,p1)                        lvl##_TRACE1(str,p1)
+#define DEBUG_TRACE2(lvl,str,p1,p2)                     lvl##_TRACE2(str,p1,p2)
+#define DEBUG_TRACE3(lvl,str,p1,p2,p3)                  lvl##_TRACE3(str,p1,p2,p3)
+#define DEBUG_TRACE4(lvl,str,p1,p2,p3,p4)               lvl##_TRACE4(str,p1,p2,p3,p4)
+
+#endif
 
 //---------------------------------------------------------------------------
 // The macro DEBUG_DUMP_DATA() can be used with the same debug-levels to dump
@@ -661,27 +651,23 @@
 // NOTE: DUMP_DATA has to be defined in project settings.
 #if (!defined (NDEBUG) && defined (DUMP_DATA)) || (DEV_SYSTEM == _DEV_WIN32_)
 
-    #ifdef __cplusplus
-    extern "C"
-    {
-    #endif
-
-        void DumpData (char* szStr_p, BYTE MEM* pbData_p, WORD wSize_p);
-
-    #ifdef __cplusplus
-    } // von extern "C"
-    #endif
+#ifdef __cplusplus
+extern "C" {
+#endif
 
-    #define DEBUG_DUMP_DATA(lvl,str,ptr,siz)    if ((DEBUG_GLB_LVL() & (lvl))==(lvl)) \
-                                                    DumpData (str, (BYTE MEM*) (ptr), (WORD) (siz));
+	void DumpData(char *szStr_p, BYTE MEM * pbData_p, WORD wSize_p);
 
+#ifdef __cplusplus
+}				// von extern "C"
+#endif
+#define DEBUG_DUMP_DATA(lvl,str,ptr,siz)    if ((DEBUG_GLB_LVL() & (lvl))==(lvl)) \
+                                                    DumpData (str, (BYTE MEM*) (ptr), (WORD) (siz));
 #else
 
-    #define DEBUG_DUMP_DATA(lvl,str,ptr,siz)
+#define DEBUG_DUMP_DATA(lvl,str,ptr,siz)
 
 #endif
 
-
 //---------------------------------------------------------------------------
 // The macro DEBUG_ASSERT() can be used to print out an error string if the
 // parametered expresion does not result TRUE.
@@ -689,62 +675,60 @@
 //       deleted from compiler (in release version too).
 #if !defined (NDEBUG) || defined (DEBUG_KEEP_ASSERT)
 
-    #if (DEV_SYSTEM == _DEV_WIN32_)
+#if (DEV_SYSTEM == _DEV_WIN32_)
 
-        // For WIN32 process will be killed after closing message box.
+	// For WIN32 process will be killed after closing message box.
 
-        #define DEBUG_ASSERT0(expr,str)         if (!(expr ) && ((DEBUG_GLB_LVL() & DEBUG_LVL_ASSERT)!=0)) { \
+#define DEBUG_ASSERT0(expr,str)         if (!(expr ) && ((DEBUG_GLB_LVL() & DEBUG_LVL_ASSERT)!=0)) { \
                                                     MessageBox (NULL, \
                                                         "Assertion failed: line " __LINE__ " file " __FILE__ \
                                                         "\n    -> " str "\n"); \
                                                     ExitProcess (-1); }
 
-        #define DEBUG_ASSERT1(expr,str,p1)      if (!(expr ) && ((DEBUG_GLB_LVL() & DEBUG_LVL_ASSERT)!=0)) { \
+#define DEBUG_ASSERT1(expr,str,p1)      if (!(expr ) && ((DEBUG_GLB_LVL() & DEBUG_LVL_ASSERT)!=0)) { \
                                                     MessageBox (NULL, \
                                                         "Assertion failed: line " __LINE__ " file " __FILE__ \
                                                         "\n    -> " str "\n"); \
                                                     ExitProcess (-1); }
 
-    #else
+#else
 
-        // For microcontrollers process will be stopped using endless loop.
+	// For microcontrollers process will be stopped using endless loop.
 
-        #define DEBUG_ASSERT0(expr,str)         if (!(expr )) { \
+#define DEBUG_ASSERT0(expr,str)         if (!(expr )) { \
                                                     DEBUG_LVL_ASSERT_TRACE3 ( \
                                                         "Assertion failed: line %d file '%s'\n" \
                                                         "    -> '%s'\n", __LINE__, __FILE__, str); \
                                                     while (1); }
 
-        #define DEBUG_ASSERT1(expr,str,p1)      if (!(expr )) { \
+#define DEBUG_ASSERT1(expr,str,p1)      if (!(expr )) { \
                                                     DEBUG_LVL_ASSERT_TRACE4 ( \
                                                         "Assertion failed: line %d file '%s'\n" \
                                                         "    -> '%s'\n" \
                                                         "    -> 0x%08lX\n", __LINE__, __FILE__, str, (DWORD) p1); \
                                                     while (1); }
 
-    #endif
+#endif
 
 #else
 
-    #define DEBUG_ASSERT0(expr,str)
-    #define DEBUG_ASSERT1(expr,str,p1)
+#define DEBUG_ASSERT0(expr,str)
+#define DEBUG_ASSERT1(expr,str,p1)
 
 #endif
 
-
 //---------------------------------------------------------------------------
 // The macro DEBUG_ONLY() implements code, if NDEBUG is not defined.
 #if !defined (DEBUG_ONLY)
-    #if !defined (NDEBUG)
+#if !defined (NDEBUG)
 
-        #define DEBUG_ONLY(expr)    expr
+#define DEBUG_ONLY(expr)    expr
 
-    #else
+#else
 
-        #define DEBUG_ONLY(expr)
+#define DEBUG_ONLY(expr)
 
-    #endif
 #endif
-
+#endif
 
 #endif // _DEBUG_H_
--- a/drivers/staging/epl/EdrvFec5282.h
+++ b/drivers/staging/epl/EdrvFec5282.h
@@ -73,94 +73,93 @@
 #ifndef _EDRVFEC_H_
 #define _EDRVFEC_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
 // base addresses
 #define FEC0_ADDR 0x0000
-#define FEC1_ADDR 0x0000 //tbd
+#define FEC1_ADDR 0x0000	//tbd
 
 // control / status registers
-#define FEC_EIR                 0x1004  // interrupt event register
-#define FEC_EIMR                0x1008  // interrupt mask register
-#define FEC_RDAR                0x1010  // receive descriptor active register
-#define FEC_TDAR                0x1014  // transmit descriptor active register
-#define FEC_ECR                 0x1024  // ethernet control register
-#define FEC_MMFR                0x1040  // MII data register
-#define FEC_MSCR                0x1044  // MII speed register
-#define FEC_MIBC                0x1064  // MIB control/status register
-#define FEC_RCR                 0x1084  // receive control register
-#define FEC_TCR                 0x10C4  // transmit control register
-#define FEC_PALR                0x10E4  // physical address low register
-#define FEC_PAUR                0x10E8  // physical address high + type register
-#define FEC_OPD                 0x10EC  // opcode + pause register
-#define FEC_IAUR                0x1118  // upper 32 bit of individual hash table
-#define FEC_IALR                0x111C  // lower 32 bit of individual hash table
-#define FEC_GAUR                0x1120  // upper 32 bit of group hash table
-#define FEC_GALR                0x1124  // lower 32 bit of group hash table
-#define FEC_TFWR                0x1144  // transmit FIFO watermark
-#define FEC_FRBR                0x114C  // FIFO receive bound register
-#define FEC_FRSR                0x1150  // FIFO receive FIFO start register
-#define FEC_ERDSR               0x1180  // pointer to receive descriptor ring
-#define FEC_ETDSR               0x1184  // pointer to transmit descriptor ring
-#define FEC_EMRBR               0x1188  // maximum receive buffer size
+#define FEC_EIR                 0x1004	// interrupt event register
+#define FEC_EIMR                0x1008	// interrupt mask register
+#define FEC_RDAR                0x1010	// receive descriptor active register
+#define FEC_TDAR                0x1014	// transmit descriptor active register
+#define FEC_ECR                 0x1024	// ethernet control register
+#define FEC_MMFR                0x1040	// MII data register
+#define FEC_MSCR                0x1044	// MII speed register
+#define FEC_MIBC                0x1064	// MIB control/status register
+#define FEC_RCR                 0x1084	// receive control register
+#define FEC_TCR                 0x10C4	// transmit control register
+#define FEC_PALR                0x10E4	// physical address low register
+#define FEC_PAUR                0x10E8	// physical address high + type register
+#define FEC_OPD                 0x10EC	// opcode + pause register
+#define FEC_IAUR                0x1118	// upper 32 bit of individual hash table
+#define FEC_IALR                0x111C	// lower 32 bit of individual hash table
+#define FEC_GAUR                0x1120	// upper 32 bit of group hash table
+#define FEC_GALR                0x1124	// lower 32 bit of group hash table
+#define FEC_TFWR                0x1144	// transmit FIFO watermark
+#define FEC_FRBR                0x114C	// FIFO receive bound register
+#define FEC_FRSR                0x1150	// FIFO receive FIFO start register
+#define FEC_ERDSR               0x1180	// pointer to receive descriptor ring
+#define FEC_ETDSR               0x1184	// pointer to transmit descriptor ring
+#define FEC_EMRBR               0x1188	// maximum receive buffer size
 
 // mib block counters memory map
-#define FEC_RMON_T_DROP         0x1200  // count of frames not counted correctly
-#define FEC_RMON_T_PACKETS      0x1204  // RMON tx packet count
-#define FEC_RMON_T_BC_PKT       0x1208  // RMON tx broadcast packets
-#define FEC_RMON_T_MC_PKT       0x120C  // RMON tx multicast packets
-#define FEC_RMON_T_CRC_ALIGN    0x1210  // RMON tx packets w CRC/align error
-#define FEC_RMON_T_UNDERSIZE    0x1214  // RMON tx packets < 64 bytes, good CRC
-#define FEC_RMON_T_OVERSIZE     0x1218  // RMON tx packets > MAX_FL bytes, good CRC
-#define FEC_RMON_T_FRAG         0x121C  // RMON tx packets < 64 bytes, bad CRC
-#define FEC_RMON_T_JAB          0x1220  // RMON tx packets > MAX_FL bytes, bad CRC
-#define FEC_RMON_T_COL          0x1224  // RMON tx collision count
-#define FEC_RMON_T_P64          0x1228  // RMON tx           64 byte packets
-#define FEC_RMON_T_P65TO127     0x122C  // RMON tx   65 to  127 byte packets
-#define FEC_RMON_T_P128TO255    0x1230  // RMON tx  128 to  255 byte packets
-#define FEC_RMON_T_P256TO511    0x1234  // RMON tx  256 to  511 byte packets
-#define FEC_RMON_T_P512TO1023   0x1238  // RMON tx  512 to 1023 byte packets
-#define FEC_RMON_T_P1024TO2047  0x123C  // RMON tx 1024 to 2047 byte packets
-#define FEC_RMON_T_P_GTE2048    0x1240  // RMON tx w > 2048 bytes
-#define FEC_RMON_T_OCTETS       0x1244  // RMON tx octets
-#define FEC_IEEE_T_DROP         0x1248  // count of frames not counted correctly
-#define FEC_IEEE_T_FRAME_OK     0x124C  // frames transmitted OK
-#define FEC_IEEE_T_1COL         0x1250  // frames transmitted with single collision
-#define FEC_IEEE_T_MCOL         0x1254  // frames transmitted with multiple collisions
-#define FEC_IEEE_T_DEF          0x1258  // frames transmitted after deferral delay
-#define FEC_IEEE_T_LCOL         0x125C  // frames transmitted with late collisions
-#define FEC_IEEE_T_EXCOL        0x1260  // frames transmitted with excessive collisions
-#define FEC_IEEE_T_MACERR       0x1264  // frames transmitted with tx-FIFO underrun
-#define FEC_IEEE_T_CSERR        0x1268  // frames transmitted with carrier sense error
-#define FEC_IEEE_T_SQE          0x126C  // frames transmitted with SQE error
-#define FEC_IEEE_T_FDXFC        0x1270  // flow control pause frames transmitted
-#define FEC_IEEE_T_OCTETS_OK    0x1274  // octet count for frames transmitted w/o error
-#define FEC_RMON_R_PACKETS      0x1284  // RMON rx packet count
-#define FEC_RMON_R_BC_PKT       0x1288  // RMON rx broadcast packets
-#define FEC_RMON_R_MC_PKT       0x128C  // RMON rx multicast packets
-#define FEC_RMON_R_CRC_ALIGN    0x1290  // RMON rx packets w CRC/align error
-#define FEC_RMON_R_UNDERSIZE    0x1294  // RMON rx packets < 64 bytes, good CRC
-#define FEC_RMON_R_OVERSIZE     0x1298  // RMON rx packets > MAX_FL bytes, good CRC
-#define FEC_RMON_R_FRAG         0x129C  // RMON rx packets < 64 bytes, bad CRC
-#define FEC_RMON_R_JAB          0x12A0  // RMON rx packets > MAX_FL bytes, bad CRC
-#define FEC_RMON_R_RESVD_0      0x12A4  //
-#define FEC_RMON_R_P64          0x12A8  // RMON rx           64 byte packets
-#define FEC_RMON_R_P65T0127     0x12AC  // RMON rx   65 to  127 byte packets
-#define FEC_RMON_R_P128TO255    0x12B0  // RMON rx  128 to  255 byte packets
-#define FEC_RMON_R_P256TO511    0x12B4  // RMON rx  256 to  511 byte packets
-#define FEC_RMON_R_P512TO1023   0x12B8  // RMON rx  512 to 1023 byte packets
-#define FEC_RMON_R_P1024TO2047  0x12BC  // RMON rx 1024 to 2047 byte packets
-#define FEC_RMON_R_GTE2048      0x12C0  // RMON rx w > 2048 bytes
-#define FEC_RMON_R_OCTETS       0x12C4  // RMON rx octets
-#define FEC_IEEE_R_DROP         0x12C8  // count of frames not counted correctly
-#define FEC_IEEE_R_FRAME_OK     0x12CC  // frames received OK
-#define FEC_IEEE_R_CRC          0x12D0  // frames received with CRC error
-#define FEC_IEEE_R_ALIGN        0x12D4  // frames received with alignment error
-#define FEC_IEEE_R_MACERR       0x12D8  // receive FIFO overflow count
-#define FEC_IEEE_R_FDXFC        0x12DC  // flow control pause frames received
-#define FEC_IEEE_R_OCTETS_OK    0x12E0  // octet count for frames rcvd w/o error
+#define FEC_RMON_T_DROP         0x1200	// count of frames not counted correctly
+#define FEC_RMON_T_PACKETS      0x1204	// RMON tx packet count
+#define FEC_RMON_T_BC_PKT       0x1208	// RMON tx broadcast packets
+#define FEC_RMON_T_MC_PKT       0x120C	// RMON tx multicast packets
+#define FEC_RMON_T_CRC_ALIGN    0x1210	// RMON tx packets w CRC/align error
+#define FEC_RMON_T_UNDERSIZE    0x1214	// RMON tx packets < 64 bytes, good CRC
+#define FEC_RMON_T_OVERSIZE     0x1218	// RMON tx packets > MAX_FL bytes, good CRC
+#define FEC_RMON_T_FRAG         0x121C	// RMON tx packets < 64 bytes, bad CRC
+#define FEC_RMON_T_JAB          0x1220	// RMON tx packets > MAX_FL bytes, bad CRC
+#define FEC_RMON_T_COL          0x1224	// RMON tx collision count
+#define FEC_RMON_T_P64          0x1228	// RMON tx           64 byte packets
+#define FEC_RMON_T_P65TO127     0x122C	// RMON tx   65 to  127 byte packets
+#define FEC_RMON_T_P128TO255    0x1230	// RMON tx  128 to  255 byte packets
+#define FEC_RMON_T_P256TO511    0x1234	// RMON tx  256 to  511 byte packets
+#define FEC_RMON_T_P512TO1023   0x1238	// RMON tx  512 to 1023 byte packets
+#define FEC_RMON_T_P1024TO2047  0x123C	// RMON tx 1024 to 2047 byte packets
+#define FEC_RMON_T_P_GTE2048    0x1240	// RMON tx w > 2048 bytes
+#define FEC_RMON_T_OCTETS       0x1244	// RMON tx octets
+#define FEC_IEEE_T_DROP         0x1248	// count of frames not counted correctly
+#define FEC_IEEE_T_FRAME_OK     0x124C	// frames transmitted OK
+#define FEC_IEEE_T_1COL         0x1250	// frames transmitted with single collision
+#define FEC_IEEE_T_MCOL         0x1254	// frames transmitted with multiple collisions
+#define FEC_IEEE_T_DEF          0x1258	// frames transmitted after deferral delay
+#define FEC_IEEE_T_LCOL         0x125C	// frames transmitted with late collisions
+#define FEC_IEEE_T_EXCOL        0x1260	// frames transmitted with excessive collisions
+#define FEC_IEEE_T_MACERR       0x1264	// frames transmitted with tx-FIFO underrun
+#define FEC_IEEE_T_CSERR        0x1268	// frames transmitted with carrier sense error
+#define FEC_IEEE_T_SQE          0x126C	// frames transmitted with SQE error
+#define FEC_IEEE_T_FDXFC        0x1270	// flow control pause frames transmitted
+#define FEC_IEEE_T_OCTETS_OK    0x1274	// octet count for frames transmitted w/o error
+#define FEC_RMON_R_PACKETS      0x1284	// RMON rx packet count
+#define FEC_RMON_R_BC_PKT       0x1288	// RMON rx broadcast packets
+#define FEC_RMON_R_MC_PKT       0x128C	// RMON rx multicast packets
+#define FEC_RMON_R_CRC_ALIGN    0x1290	// RMON rx packets w CRC/align error
+#define FEC_RMON_R_UNDERSIZE    0x1294	// RMON rx packets < 64 bytes, good CRC
+#define FEC_RMON_R_OVERSIZE     0x1298	// RMON rx packets > MAX_FL bytes, good CRC
+#define FEC_RMON_R_FRAG         0x129C	// RMON rx packets < 64 bytes, bad CRC
+#define FEC_RMON_R_JAB          0x12A0	// RMON rx packets > MAX_FL bytes, bad CRC
+#define FEC_RMON_R_RESVD_0      0x12A4	//
+#define FEC_RMON_R_P64          0x12A8	// RMON rx           64 byte packets
+#define FEC_RMON_R_P65T0127     0x12AC	// RMON rx   65 to  127 byte packets
+#define FEC_RMON_R_P128TO255    0x12B0	// RMON rx  128 to  255 byte packets
+#define FEC_RMON_R_P256TO511    0x12B4	// RMON rx  256 to  511 byte packets
+#define FEC_RMON_R_P512TO1023   0x12B8	// RMON rx  512 to 1023 byte packets
+#define FEC_RMON_R_P1024TO2047  0x12BC	// RMON rx 1024 to 2047 byte packets
+#define FEC_RMON_R_GTE2048      0x12C0	// RMON rx w > 2048 bytes
+#define FEC_RMON_R_OCTETS       0x12C4	// RMON rx octets
+#define FEC_IEEE_R_DROP         0x12C8	// count of frames not counted correctly
+#define FEC_IEEE_R_FRAME_OK     0x12CC	// frames received OK
+#define FEC_IEEE_R_CRC          0x12D0	// frames received with CRC error
+#define FEC_IEEE_R_ALIGN        0x12D4	// frames received with alignment error
+#define FEC_IEEE_R_MACERR       0x12D8	// receive FIFO overflow count
+#define FEC_IEEE_R_FDXFC        0x12DC	// flow control pause frames received
+#define FEC_IEEE_R_OCTETS_OK    0x12E0	// octet count for frames rcvd w/o error
 
 // register bit definitions and macros
 #define FEC_EIR_UN              (0x00080000)
@@ -315,11 +314,10 @@
 //---------------------------------------------------------------------------
 
 // Rx and Tx buffer descriptor format
-typedef struct
-{
-	WORD   m_wStatus;	// control / status  ---  used by edrv, do not change in application
-	WORD   m_wLength;	// transfer length
-	BYTE * m_pbData;	// buffer address
+typedef struct {
+	WORD m_wStatus;		// control / status  ---  used by edrv, do not change in application
+	WORD m_wLength;		// transfer length
+	BYTE *m_pbData;		// buffer address
 } tBufferDescr;
 
 //---------------------------------------------------------------------------
@@ -327,21 +325,16 @@ typedef struct
 //---------------------------------------------------------------------------
 
 #if (NO_OF_INSTANCES > 1)
-    #define ECI_WRITE_DW_REG(off,val)       (*(DWORD *)(void *)(&__IPSBAR[off]) = val)
-    #define ECI_READ_DW_REG(off)            (*(DWORD *)(void *)(&__IPSBAR[off]))
+#define ECI_WRITE_DW_REG(off,val)       (*(DWORD *)(void *)(&__IPSBAR[off]) = val)
+#define ECI_READ_DW_REG(off)            (*(DWORD *)(void *)(&__IPSBAR[off]))
+#else
+#if (EDRV_USED_ETH_CTRL == 0)
+#define ECI_WRITE_DW_REG(off,val)       (*(DWORD *)(void *)(&__IPSBAR[FEC0_ADDR+off]) = val)
+#define ECI_READ_DW_REG(off)            (*(DWORD *)(void *)(&__IPSBAR[FEC0_ADDR+off]))
 #else
-    #if (EDRV_USED_ETH_CTRL == 0)
-        #define ECI_WRITE_DW_REG(off,val)       (*(DWORD *)(void *)(&__IPSBAR[FEC0_ADDR+off]) = val)
-        #define ECI_READ_DW_REG(off)            (*(DWORD *)(void *)(&__IPSBAR[FEC0_ADDR+off]))
-    #else
-        #define ECI_WRITE_DW_REG(off,val)       (*(DWORD *)(void *)(&__IPSBAR[FEC1_ADDR+off]) = val)
-        #define ECI_READ_DW_REG(off)            (*(DWORD *)(void *)(&__IPSBAR[FEC1_ADDR+off]))
-    #endif
+#define ECI_WRITE_DW_REG(off,val)       (*(DWORD *)(void *)(&__IPSBAR[FEC1_ADDR+off]) = val)
+#define ECI_READ_DW_REG(off)            (*(DWORD *)(void *)(&__IPSBAR[FEC1_ADDR+off]))
+#endif
 #endif
 
-
-
-
-#endif  // #ifndef _EDRV_FEC_H_
-
-
+#endif // #ifndef _EDRV_FEC_H_
--- a/drivers/staging/epl/EdrvFec.h
+++ b/drivers/staging/epl/EdrvFec.h
@@ -73,40 +73,32 @@
 #ifndef _EDRVFEC_H_
 #define _EDRVFEC_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
 // do this in config header
 #define TARGET_HARDWARE TGTHW_SPLC_CF54
 
-
 // base addresses
 #if ((TARGET_HARDWARE & TGT_CPU_MASK_) == TGT_CPU_5282)
 
-
 #elif ((TARGET_HARDWARE & TGT_CPU_MASK_) == TGT_CPU_5485)
 
-
 #else
 
-    #error 'ERROR: Target was never implemented!'
+#error 'ERROR: Target was never implemented!'
 
 #endif
 
-
-
 //---------------------------------------------------------------------------
 // types
 //---------------------------------------------------------------------------
 
-
 // Rx and Tx buffer descriptor format
-typedef struct
-{
-	WORD   m_wStatus;	// control / status  ---  used by edrv, do not change in application
-	WORD   m_wLength;	// transfer length
-	BYTE * m_pbData;	// buffer address
+typedef struct {
+	WORD m_wStatus;		// control / status  ---  used by edrv, do not change in application
+	WORD m_wLength;		// transfer length
+	BYTE *m_pbData;		// buffer address
 } tBufferDescr;
 
 #if ((TARGET_HARDWARE & TGT_CPU_MASK_) == TGT_CPU_5282)
@@ -119,8 +111,4 @@ typedef struct
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-
-#endif  // #ifndef _EDRV_FEC_H_
-
-
+#endif // #ifndef _EDRV_FEC_H_
--- a/drivers/staging/epl/edrv.h
+++ b/drivers/staging/epl/edrv.h
@@ -81,103 +81,87 @@
 #define MAX_ETH_DATA_SIZE       1500
 #define MIN_ETH_DATA_SIZE         46
 
-#define ETH_HDR_OFFSET 	 0      // Ethernet header at the top of the frame
-#define ETH_HDR_SIZE	14      // size of Ethernet header
-#define MIN_ETH_SIZE     (MIN_ETH_DATA_SIZE + ETH_HDR_SIZE)    // without CRC
-
-#define ETH_CRC_SIZE	 4      // size of Ethernet CRC, i.e. FCS
-
+#define ETH_HDR_OFFSET 	 0	// Ethernet header at the top of the frame
+#define ETH_HDR_SIZE	14	// size of Ethernet header
+#define MIN_ETH_SIZE     (MIN_ETH_DATA_SIZE + ETH_HDR_SIZE)	// without CRC
 
+#define ETH_CRC_SIZE	 4	// size of Ethernet CRC, i.e. FCS
 
 //---------------------------------------------------------------------------
 // types
 //---------------------------------------------------------------------------
 
 // position of a buffer in an ethernet-frame
-typedef enum
-{
-    kEdrvBufferFirstInFrame   = 0x01,  // first data buffer in an ethernet frame
-    kEdrvBufferMiddleInFrame  = 0x02,  // a middle data buffer in an ethernet frame
-    kEdrvBufferLastInFrame    = 0x04   // last data buffer in an ethernet frame
+typedef enum {
+	kEdrvBufferFirstInFrame = 0x01,	// first data buffer in an ethernet frame
+	kEdrvBufferMiddleInFrame = 0x02,	// a middle data buffer in an ethernet frame
+	kEdrvBufferLastInFrame = 0x04	// last data buffer in an ethernet frame
 } tEdrvBufferInFrame;
 
-
 // format of a tx-buffer
-typedef struct _tEdrvTxBuffer
-{
-    tEplMsgType     m_EplMsgType;           // IN: type of EPL message, set by calling function
-    unsigned int    m_uiTxMsgLen;           // IN: length of message to be send (set for each transmit call)
-    // ----------------------
-    unsigned int    m_uiBufferNumber;       // OUT: number of the buffer, set by ethernetdriver
-    BYTE  *         m_pbBuffer;             // OUT: pointer to the buffer, set by ethernetdriver
-    tEplNetTime     m_NetTime;              // OUT: Timestamp of end of transmission, set by ethernetdriver
-    // ----------------------
-    unsigned int    m_uiMaxBufferLen;       // IN/OUT: maximum length of the buffer
+typedef struct _tEdrvTxBuffer {
+	tEplMsgType m_EplMsgType;	// IN: type of EPL message, set by calling function
+	unsigned int m_uiTxMsgLen;	// IN: length of message to be send (set for each transmit call)
+	// ----------------------
+	unsigned int m_uiBufferNumber;	// OUT: number of the buffer, set by ethernetdriver
+	BYTE *m_pbBuffer;	// OUT: pointer to the buffer, set by ethernetdriver
+	tEplNetTime m_NetTime;	// OUT: Timestamp of end of transmission, set by ethernetdriver
+	// ----------------------
+	unsigned int m_uiMaxBufferLen;	// IN/OUT: maximum length of the buffer
 } tEdrvTxBuffer;
 
 // format of a rx-buffer
-typedef struct _tEdrvRxBuffer
-{
-    tEdrvBufferInFrame m_BufferInFrame;   // OUT position of received buffer in an ethernet-frame
-    unsigned int       m_uiRxMsgLen;        // OUT: length of received buffer (without CRC)
-    BYTE  *            m_pbBuffer;          // OUT: pointer to the buffer, set by ethernetdriver
-    tEplNetTime        m_NetTime;           // OUT: Timestamp of end of receiption
+typedef struct _tEdrvRxBuffer {
+	tEdrvBufferInFrame m_BufferInFrame;	// OUT position of received buffer in an ethernet-frame
+	unsigned int m_uiRxMsgLen;	// OUT: length of received buffer (without CRC)
+	BYTE *m_pbBuffer;	// OUT: pointer to the buffer, set by ethernetdriver
+	tEplNetTime m_NetTime;	// OUT: Timestamp of end of receiption
 
 } tEdrvRxBuffer;
 
-
-
 //typedef void (*tEdrvRxHandler) (BYTE bBufferInFrame_p, tBufferDescr * pbBuffer_p);
 //typedef void (*tEdrvRxHandler) (BYTE bBufferInFrame_p, BYTE * pbEthernetData_p, WORD wDataLen_p);
 typedef void (*tEdrvRxHandler) (tEdrvRxBuffer * pRxBuffer_p);
 typedef void (*tEdrvTxHandler) (tEdrvTxBuffer * pTxBuffer_p);
 
-
 // format of init structure
-typedef struct
-{
-    BYTE            m_abMyMacAddr[6];       // the own MAC address
+typedef struct {
+	BYTE m_abMyMacAddr[6];	// the own MAC address
 
 //    BYTE            m_bNoOfRxBuffDescr;     // number of entries in rx bufferdescriptor table
 //    tBufferDescr *  m_pRxBuffDescrTable;    // rx bufferdescriptor table
 //    WORD            m_wRxBufferSize;        // size of the whole rx buffer
 
-    tEdrvRxHandler  m_pfnRxHandler;
-    tEdrvTxHandler  m_pfnTxHandler;
+	tEdrvRxHandler m_pfnRxHandler;
+	tEdrvTxHandler m_pfnTxHandler;
 
 } tEdrvInitParam;
 
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
+tEplKernel EdrvInit(tEdrvInitParam * pEdrvInitParam_p);
 
-tEplKernel EdrvInit                   (tEdrvInitParam* pEdrvInitParam_p);
-
-tEplKernel EdrvShutdown               (void);
+tEplKernel EdrvShutdown(void);
 
-tEplKernel EdrvDefineRxMacAddrEntry   (BYTE * pbMacAddr_p);
-tEplKernel EdrvUndefineRxMacAddrEntry (BYTE * pbMacAddr_p);
+tEplKernel EdrvDefineRxMacAddrEntry(BYTE * pbMacAddr_p);
+tEplKernel EdrvUndefineRxMacAddrEntry(BYTE * pbMacAddr_p);
 
 //tEplKernel EdrvDefineUnicastEntry     (BYTE * pbUCEntry_p);
 //tEplKernel EdrvUndfineUnicastEntry    (BYTE * pbUCEntry_p);
 
-tEplKernel EdrvAllocTxMsgBuffer       (tEdrvTxBuffer * pBuffer_p);
-tEplKernel EdrvReleaseTxMsgBuffer     (tEdrvTxBuffer * pBuffer_p);
+tEplKernel EdrvAllocTxMsgBuffer(tEdrvTxBuffer * pBuffer_p);
+tEplKernel EdrvReleaseTxMsgBuffer(tEdrvTxBuffer * pBuffer_p);
 
 //tEplKernel EdrvWriteMsg               (tBufferDescr * pbBuffer_p);
-tEplKernel EdrvSendTxMsg              (tEdrvTxBuffer * pBuffer_p);
-tEplKernel EdrvTxMsgReady              (tEdrvTxBuffer * pBuffer_p);
-tEplKernel EdrvTxMsgStart              (tEdrvTxBuffer * pBuffer_p);
+tEplKernel EdrvSendTxMsg(tEdrvTxBuffer * pBuffer_p);
+tEplKernel EdrvTxMsgReady(tEdrvTxBuffer * pBuffer_p);
+tEplKernel EdrvTxMsgStart(tEdrvTxBuffer * pBuffer_p);
 
 //tEplKernel EdrvReadMsg                (void);
 
 // interrupt handler called by target specific interrupt handler
-void        EdrvInterruptHandler       (void);
-
-
-
-#endif  // #ifndef _EDRV_H_
-
+void EdrvInterruptHandler(void);
 
+#endif // #ifndef _EDRV_H_
--- a/drivers/staging/epl/EdrvSim.h
+++ b/drivers/staging/epl/EdrvSim.h
@@ -71,7 +71,6 @@
 #ifndef _EDRVSIM_H_
 #define _EDRVSIM_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
@@ -80,15 +79,11 @@
 // types
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-void EdrvRxInterruptHandler (BYTE bBufferInFrame_p, BYTE * pbEthernetData_p, WORD wDataLen_p);
-
-
-
-#endif  // #ifndef _EDRVSIM_H_
-
+void EdrvRxInterruptHandler(BYTE bBufferInFrame_p, BYTE * pbEthernetData_p,
+			    WORD wDataLen_p);
 
+#endif // #ifndef _EDRVSIM_H_
--- a/drivers/staging/epl/EplAmi.h
+++ b/drivers/staging/epl/EplAmi.h
@@ -86,46 +86,43 @@
 #ifndef _EPLAMI_H_
 #define _EPLAMI_H_
 
-
 #if ((DEV_SYSTEM & _DEV_64BIT_SUPPORT_) == 0)
 //    #ifdef USE_VAR64
-        #error 'ERROR: development system does not support 64 bit operations!'
+#error 'ERROR: development system does not support 64 bit operations!'
 //    #endif
 #endif
 
-
 //---------------------------------------------------------------------------
 //  types
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 //  Prototypen
 //---------------------------------------------------------------------------
 
 #ifdef __cplusplus
-    extern "C" {
+extern "C" {
 #endif
 
 #if (TARGET_SYSTEM == _WIN32_)
-    #if defined(INLINE_FUNCTION_DEF)
-        #undef  INLINE_FUNCTION
-        #define INLINE_FUNCTION     INLINE_FUNCTION_DEF
-        #define INLINE_ENABLED      TRUE
-        #define EPL_AMI_INLINED
-        #include "../EplStack/amix86.c"
-    #endif
+#if defined(INLINE_FUNCTION_DEF)
+#undef  INLINE_FUNCTION
+#define INLINE_FUNCTION     INLINE_FUNCTION_DEF
+#define INLINE_ENABLED      TRUE
+#define EPL_AMI_INLINED
+#include "../EplStack/amix86.c"
+#endif
 
 #elif (TARGET_SYSTEM == _LINUX_)
-    #if defined(__m68k__)   // it is an big endian machine
-        #if defined(INLINE_FUNCTION_DEF)
-            #undef  INLINE_FUNCTION
-            #define INLINE_FUNCTION     INLINE_FUNCTION_DEF
-            #define INLINE_ENABLED      TRUE
-            #define EPL_AMI_INLINED
-            #include "../EplStack/amibe.c"
-        #endif
-    #endif
+#if defined(__m68k__)		// it is an big endian machine
+#if defined(INLINE_FUNCTION_DEF)
+#undef  INLINE_FUNCTION
+#define INLINE_FUNCTION     INLINE_FUNCTION_DEF
+#define INLINE_ENABLED      TRUE
+#define EPL_AMI_INLINED
+#include "../EplStack/amibe.c"
+#endif
+#endif
 #endif
 
 //---------------------------------------------------------------------------
@@ -140,13 +137,12 @@
 #define AmiSetByteToLe(pAddr_p, bByteVal_p)  {*(BYTE FAR*)(pAddr_p) = (bByteVal_p);}
 
 #if !defined(INLINE_ENABLED)
-void   PUBLIC  AmiSetWordToBe  (void FAR* pAddr_p, WORD wWordVal_p);
-void   PUBLIC  AmiSetDwordToBe (void FAR* pAddr_p, DWORD dwDwordVal_p);
-void   PUBLIC  AmiSetWordToLe  (void FAR* pAddr_p, WORD wWordVal_p);
-void   PUBLIC  AmiSetDwordToLe (void FAR* pAddr_p, DWORD dwDwordVal_p);
+	void PUBLIC AmiSetWordToBe(void FAR * pAddr_p, WORD wWordVal_p);
+	void PUBLIC AmiSetDwordToBe(void FAR * pAddr_p, DWORD dwDwordVal_p);
+	void PUBLIC AmiSetWordToLe(void FAR * pAddr_p, WORD wWordVal_p);
+	void PUBLIC AmiSetDwordToLe(void FAR * pAddr_p, DWORD dwDwordVal_p);
 #endif
 
-
 //---------------------------------------------------------------------------
 //
 // read functions
@@ -160,10 +156,10 @@ void   PUBLIC  AmiSetDwordToLe (void FAR
 
 #if !defined(INLINE_ENABLED)
 
-WORD   PUBLIC  AmiGetWordFromBe  (void FAR* pAddr_p);
-DWORD  PUBLIC  AmiGetDwordFromBe (void FAR* pAddr_p);
-WORD   PUBLIC  AmiGetWordFromLe  (void FAR* pAddr_p);
-DWORD  PUBLIC  AmiGetDwordFromLe (void FAR* pAddr_p);
+	WORD PUBLIC AmiGetWordFromBe(void FAR * pAddr_p);
+	DWORD PUBLIC AmiGetDwordFromBe(void FAR * pAddr_p);
+	WORD PUBLIC AmiGetWordFromLe(void FAR * pAddr_p);
+	DWORD PUBLIC AmiGetDwordFromLe(void FAR * pAddr_p);
 
 //---------------------------------------------------------------------------
 //
@@ -178,9 +174,8 @@ DWORD  PUBLIC  AmiGetDwordFromLe (void F
 //
 //---------------------------------------------------------------------------
 
-void PUBLIC AmiSetDword24ToBe (void FAR* pAddr_p, DWORD dwDwordVal_p);
-void PUBLIC AmiSetDword24ToLe (void FAR* pAddr_p, DWORD dwDwordVal_p);
-
+	void PUBLIC AmiSetDword24ToBe(void FAR * pAddr_p, DWORD dwDwordVal_p);
+	void PUBLIC AmiSetDword24ToLe(void FAR * pAddr_p, DWORD dwDwordVal_p);
 
 //---------------------------------------------------------------------------
 //
@@ -194,9 +189,8 @@ void PUBLIC AmiSetDword24ToLe (void FAR*
 //
 //---------------------------------------------------------------------------
 
-DWORD PUBLIC AmiGetDword24FromBe (void FAR* pAddr_p);
-DWORD PUBLIC AmiGetDword24FromLe (void FAR* pAddr_p);
-
+	DWORD PUBLIC AmiGetDword24FromBe(void FAR * pAddr_p);
+	DWORD PUBLIC AmiGetDword24FromLe(void FAR * pAddr_p);
 
 //#ifdef USE_VAR64
 
@@ -213,9 +207,8 @@ DWORD PUBLIC AmiGetDword24FromLe (void F
 //
 //---------------------------------------------------------------------------
 
-void PUBLIC AmiSetQword40ToBe (void FAR* pAddr_p, QWORD qwQwordVal_p);
-void PUBLIC AmiSetQword40ToLe (void FAR* pAddr_p, QWORD qwQwordVal_p);
-
+	void PUBLIC AmiSetQword40ToBe(void FAR * pAddr_p, QWORD qwQwordVal_p);
+	void PUBLIC AmiSetQword40ToLe(void FAR * pAddr_p, QWORD qwQwordVal_p);
 
 //---------------------------------------------------------------------------
 //
@@ -229,9 +222,8 @@ void PUBLIC AmiSetQword40ToLe (void FAR*
 //
 //---------------------------------------------------------------------------
 
-QWORD PUBLIC AmiGetQword40FromBe (void FAR* pAddr_p);
-QWORD PUBLIC AmiGetQword40FromLe (void FAR* pAddr_p);
-
+	QWORD PUBLIC AmiGetQword40FromBe(void FAR * pAddr_p);
+	QWORD PUBLIC AmiGetQword40FromLe(void FAR * pAddr_p);
 
 //---------------------------------------------------------------------------
 //
@@ -246,9 +238,8 @@ QWORD PUBLIC AmiGetQword40FromLe (void F
 //
 //---------------------------------------------------------------------------
 
-void PUBLIC AmiSetQword48ToBe (void FAR* pAddr_p, QWORD qwQwordVal_p);
-void PUBLIC AmiSetQword48ToLe (void FAR* pAddr_p, QWORD qwQwordVal_p);
-
+	void PUBLIC AmiSetQword48ToBe(void FAR * pAddr_p, QWORD qwQwordVal_p);
+	void PUBLIC AmiSetQword48ToLe(void FAR * pAddr_p, QWORD qwQwordVal_p);
 
 //---------------------------------------------------------------------------
 //
@@ -262,9 +253,8 @@ void PUBLIC AmiSetQword48ToLe (void FAR*
 //
 //---------------------------------------------------------------------------
 
-QWORD PUBLIC AmiGetQword48FromBe (void FAR* pAddr_p);
-QWORD PUBLIC AmiGetQword48FromLe (void FAR* pAddr_p);
-
+	QWORD PUBLIC AmiGetQword48FromBe(void FAR * pAddr_p);
+	QWORD PUBLIC AmiGetQword48FromLe(void FAR * pAddr_p);
 
 //---------------------------------------------------------------------------
 //
@@ -279,9 +269,8 @@ QWORD PUBLIC AmiGetQword48FromLe (void F
 //
 //---------------------------------------------------------------------------
 
-void PUBLIC AmiSetQword56ToBe (void FAR* pAddr_p, QWORD qwQwordVal_p);
-void PUBLIC AmiSetQword56ToLe (void FAR* pAddr_p, QWORD qwQwordVal_p);
-
+	void PUBLIC AmiSetQword56ToBe(void FAR * pAddr_p, QWORD qwQwordVal_p);
+	void PUBLIC AmiSetQword56ToLe(void FAR * pAddr_p, QWORD qwQwordVal_p);
 
 //---------------------------------------------------------------------------
 //
@@ -295,9 +284,8 @@ void PUBLIC AmiSetQword56ToLe (void FAR*
 //
 //---------------------------------------------------------------------------
 
-QWORD PUBLIC AmiGetQword56FromBe (void FAR* pAddr_p);
-QWORD PUBLIC AmiGetQword56FromLe (void FAR* pAddr_p);
-
+	QWORD PUBLIC AmiGetQword56FromBe(void FAR * pAddr_p);
+	QWORD PUBLIC AmiGetQword56FromLe(void FAR * pAddr_p);
 
 //---------------------------------------------------------------------------
 //
@@ -312,9 +300,8 @@ QWORD PUBLIC AmiGetQword56FromLe (void F
 //
 //---------------------------------------------------------------------------
 
-void PUBLIC AmiSetQword64ToBe (void FAR* pAddr_p, QWORD qwQwordVal_p);
-void PUBLIC AmiSetQword64ToLe (void FAR* pAddr_p, QWORD qwQwordVal_p);
-
+	void PUBLIC AmiSetQword64ToBe(void FAR * pAddr_p, QWORD qwQwordVal_p);
+	void PUBLIC AmiSetQword64ToLe(void FAR * pAddr_p, QWORD qwQwordVal_p);
 
 //---------------------------------------------------------------------------
 //
@@ -328,9 +315,8 @@ void PUBLIC AmiSetQword64ToLe (void FAR*
 //
 //---------------------------------------------------------------------------
 
-QWORD PUBLIC AmiGetQword64FromBe (void FAR* pAddr_p);
-QWORD PUBLIC AmiGetQword64FromLe (void FAR* pAddr_p);
-
+	QWORD PUBLIC AmiGetQword64FromBe(void FAR * pAddr_p);
+	QWORD PUBLIC AmiGetQword64FromLe(void FAR * pAddr_p);
 
 //---------------------------------------------------------------------------
 //
@@ -345,8 +331,8 @@ QWORD PUBLIC AmiGetQword64FromLe (void F
 //
 //---------------------------------------------------------------------------
 
-void PUBLIC AmiSetTimeOfDay (void FAR* pAddr_p, tTimeOfDay FAR* pTimeOfDay_p);
-
+	void PUBLIC AmiSetTimeOfDay(void FAR * pAddr_p,
+				    tTimeOfDay FAR * pTimeOfDay_p);
 
 //---------------------------------------------------------------------------
 //
@@ -361,20 +347,16 @@ void PUBLIC AmiSetTimeOfDay (void FAR* p
 //
 //---------------------------------------------------------------------------
 
-void PUBLIC AmiGetTimeOfDay (void FAR* pAddr_p, tTimeOfDay FAR* pTimeOfDay_p);
+	void PUBLIC AmiGetTimeOfDay(void FAR * pAddr_p,
+				    tTimeOfDay FAR * pTimeOfDay_p);
 
 #endif
 
-
-#undef  INLINE_ENABLED              // disable actual inlining of functions
+#undef  INLINE_ENABLED		// disable actual inlining of functions
 #define EPL_AMI_INCLUDED
 
 #ifdef __cplusplus
-    }
+}
 #endif
-
-
-#endif  // ifndef _EPLAMI_H_
-
-// Die letzte Zeile muß unbedingt eine leere Zeile sein, weil manche Compiler
-// damit ein Problem haben, wenn das nicht so ist (z.B. GNU oder Borland C++ Builder).
+#endif				// ifndef _EPLAMI_H_
+// Die letzte Zeile muß unbedingt eine leere Zeile sein, weil manche Compiler// damit ein Problem haben, wenn das nicht so ist (z.B. GNU oder Borland C++ Builder).
--- a/drivers/staging/epl/EplApiLinux.h
+++ b/drivers/staging/epl/EplApiLinux.h
@@ -66,79 +66,71 @@
 
   2006/10/11 d.k.:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #ifndef _EPL_API_LINUX_H_
 #define _EPL_API_LINUX_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
 
-#define EPLLIN_DEV_NAME     "epl"              // used for "/dev" and "/proc" entry
-
+#define EPLLIN_DEV_NAME     "epl"	// used for "/dev" and "/proc" entry
 
 //---------------------------------------------------------------------------
 //  Commands for <ioctl>
 //---------------------------------------------------------------------------
 
-#define EPLLIN_CMD_INITIALIZE               0   // ulArg_p ~ tEplApiInitParam*
-#define EPLLIN_CMD_PI_IN                    1   // ulArg_p ~ tEplApiProcessImage*
-#define EPLLIN_CMD_PI_OUT                   2   // ulArg_p ~ tEplApiProcessImage*
-#define EPLLIN_CMD_WRITE_OBJECT             3   // ulArg_p ~ tEplLinSdoObject*
-#define EPLLIN_CMD_READ_OBJECT              4   // ulArg_p ~ tEplLinSdoObject*
-#define EPLLIN_CMD_WRITE_LOCAL_OBJECT       5   // ulArg_p ~ tEplLinLocalObject*
-#define EPLLIN_CMD_READ_LOCAL_OBJECT        6   // ulArg_p ~ tEplLinLocalObject*
-#define EPLLIN_CMD_FREE_SDO_CHANNEL         7   // ulArg_p ~ tEplSdoComConHdl
-#define EPLLIN_CMD_NMT_COMMAND              8   // ulArg_p ~ tEplNmtEvent
-#define EPLLIN_CMD_GET_EVENT                9   // ulArg_p ~ tEplLinEvent*
-#define EPLLIN_CMD_MN_TRIGGER_STATE_CHANGE 10   // ulArg_p ~ tEplLinNodeCmdObject*
-#define EPLLIN_CMD_PI_SETUP                11   // ulArg_p ~ 0
-#define EPLLIN_CMD_SHUTDOWN                12   // ulArg_p ~ 0
-
+#define EPLLIN_CMD_INITIALIZE               0	// ulArg_p ~ tEplApiInitParam*
+#define EPLLIN_CMD_PI_IN                    1	// ulArg_p ~ tEplApiProcessImage*
+#define EPLLIN_CMD_PI_OUT                   2	// ulArg_p ~ tEplApiProcessImage*
+#define EPLLIN_CMD_WRITE_OBJECT             3	// ulArg_p ~ tEplLinSdoObject*
+#define EPLLIN_CMD_READ_OBJECT              4	// ulArg_p ~ tEplLinSdoObject*
+#define EPLLIN_CMD_WRITE_LOCAL_OBJECT       5	// ulArg_p ~ tEplLinLocalObject*
+#define EPLLIN_CMD_READ_LOCAL_OBJECT        6	// ulArg_p ~ tEplLinLocalObject*
+#define EPLLIN_CMD_FREE_SDO_CHANNEL         7	// ulArg_p ~ tEplSdoComConHdl
+#define EPLLIN_CMD_NMT_COMMAND              8	// ulArg_p ~ tEplNmtEvent
+#define EPLLIN_CMD_GET_EVENT                9	// ulArg_p ~ tEplLinEvent*
+#define EPLLIN_CMD_MN_TRIGGER_STATE_CHANGE 10	// ulArg_p ~ tEplLinNodeCmdObject*
+#define EPLLIN_CMD_PI_SETUP                11	// ulArg_p ~ 0
+#define EPLLIN_CMD_SHUTDOWN                12	// ulArg_p ~ 0
 
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    unsigned int        m_uiEventArgSize;
-    tEplApiEventArg*    m_pEventArg;
-    tEplApiEventType*   m_pEventType;
-    tEplKernel          m_RetCbEvent;
+typedef struct {
+	unsigned int m_uiEventArgSize;
+	tEplApiEventArg *m_pEventArg;
+	tEplApiEventType *m_pEventType;
+	tEplKernel m_RetCbEvent;
 
 } tEplLinEvent;
 
-typedef struct
-{
-    tEplSdoComConHdl  m_SdoComConHdl;
-    BOOL              m_fValidSdoComConHdl;
-    unsigned int      m_uiNodeId;
-    unsigned int      m_uiIndex;
-    unsigned int      m_uiSubindex;
-    void*             m_le_pData;
-    unsigned int      m_uiSize;
-    tEplSdoType       m_SdoType;
-    void*             m_pUserArg;
+typedef struct {
+	tEplSdoComConHdl m_SdoComConHdl;
+	BOOL m_fValidSdoComConHdl;
+	unsigned int m_uiNodeId;
+	unsigned int m_uiIndex;
+	unsigned int m_uiSubindex;
+	void *m_le_pData;
+	unsigned int m_uiSize;
+	tEplSdoType m_SdoType;
+	void *m_pUserArg;
 
 } tEplLinSdoObject;
 
-typedef struct
-{
-    unsigned int      m_uiIndex;
-    unsigned int      m_uiSubindex;
-    void*             m_pData;
-    unsigned int      m_uiSize;
+typedef struct {
+	unsigned int m_uiIndex;
+	unsigned int m_uiSubindex;
+	void *m_pData;
+	unsigned int m_uiSize;
 
 } tEplLinLocalObject;
 
-typedef struct
-{
-    unsigned int        m_uiNodeId;
-    tEplNmtNodeCommand  m_NodeCommand;
+typedef struct {
+	unsigned int m_uiNodeId;
+	tEplNmtNodeCommand m_NodeCommand;
 
 } tEplLinNodeCmdObject;
 
@@ -146,8 +138,4 @@ typedef struct
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-
-#endif  // #ifndef _EPL_API_LINUX_H_
-
-
+#endif // #ifndef _EPL_API_LINUX_H_
--- a/drivers/staging/epl/EplCfg.h
+++ b/drivers/staging/epl/EplCfg.h
@@ -71,9 +71,6 @@
 #ifndef _EPLCFG_H_
 #define _EPLCFG_H_
 
-
-
-
 // =========================================================================
 // generic defines which for whole EPL Stack
 // =========================================================================
@@ -100,7 +97,7 @@
 #define EPL_NO_USER_KERNEL
 
 #ifndef BENCHMARK_MODULES
-#define BENCHMARK_MODULES       0 //0xEE800042L
+#define BENCHMARK_MODULES       0	//0xEE800042L
 #endif
 
 // Default defug level:
@@ -113,7 +110,6 @@
 // * EPL_DBGLVL_ERROR       =   0x40000000L
 // * EPL_DBGLVL_ALWAYS      =   0x80000000L
 
-
 // EPL_MODULE_INTEGRATION defines all modules which are included in
 // EPL application. Please add or delete modules for your application.
 #define EPL_MODULE_INTEGRATION EPL_MODULE_OBDK \
@@ -155,7 +151,6 @@
 // number of used ethernet controller
 //#define EDRV_USED_ETH_CTRL              1
 
-
 // =========================================================================
 // Data Link Layer (DLL) specific defines
 // =========================================================================
@@ -170,7 +165,6 @@
 #define EPL_DLL_PRES_READY_AFTER_SOA    FALSE
 //#define EPL_DLL_PRES_READY_AFTER_SOA    TRUE
 
-
 // =========================================================================
 // OBD specific defines
 // =========================================================================
@@ -188,7 +182,6 @@
 
 #define EPL_OBD_USE_VARIABLE_SUBINDEX_TAB TRUE
 
-
 // =========================================================================
 // Timer module specific defines
 // =========================================================================
@@ -200,8 +193,4 @@
 #define EPL_TIMER_USE_HIGHRES              TRUE
 //#define EPL_TIMER_USE_HIGHRES              FALSE
 
-
 #endif //_EPLCFG_H_
-
-
-
--- a/drivers/staging/epl/EplDef.h
+++ b/drivers/staging/epl/EplDef.h
@@ -66,81 +66,77 @@
 
   2006/05/22 d.k.:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #ifndef _EPL_DEF_H_
 #define _EPL_DEF_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
 
-#define EPL_C_ADR_BROADCAST         0xFF // EPL broadcast address
-#define EPL_C_ADR_DIAG_DEF_NODE_ID  0xFD // EPL default address of dignostic device
-#define EPL_C_ADR_DUMMY_NODE_ID     0xFC // EPL dummy node address
-#define EPL_C_ADR_INVALID           0x00 // invalid EPL address
-#define EPL_C_ADR_MN_DEF_NODE_ID    0xF0 // EPL default address of MN
-#define EPL_C_ADR_RT1_DEF_NODE_ID   0xFE // EPL default address of router type 1
-#define EPL_C_DLL_ASND_PRIO_NMTRQST 7    // increased ASnd request priority to be used by NMT Requests
-#define EPL_C_DLL_ASND_PRIO_STD     0    // standard ASnd request priority
+#define EPL_C_ADR_BROADCAST         0xFF	// EPL broadcast address
+#define EPL_C_ADR_DIAG_DEF_NODE_ID  0xFD	// EPL default address of dignostic device
+#define EPL_C_ADR_DUMMY_NODE_ID     0xFC	// EPL dummy node address
+#define EPL_C_ADR_INVALID           0x00	// invalid EPL address
+#define EPL_C_ADR_MN_DEF_NODE_ID    0xF0	// EPL default address of MN
+#define EPL_C_ADR_RT1_DEF_NODE_ID   0xFE	// EPL default address of router type 1
+#define EPL_C_DLL_ASND_PRIO_NMTRQST 7	// increased ASnd request priority to be used by NMT Requests
+#define EPL_C_DLL_ASND_PRIO_STD     0	// standard ASnd request priority
 #define EPL_C_DLL_ETHERTYPE_EPL     0x88AB
-#define EPL_C_DLL_ISOCHR_MAX_PAYL   1490 // Byte: maximum size of PReq and PRes payload data, requires C_IP_MAX_MTU
-#define EPL_C_DLL_MAX_ASYNC_MTU     1500 // Byte: maximum asynchronous payload in bytes
-#define EPL_C_DLL_MAX_PAYL_OFFSET   1499 // Byte: maximum offset of Ethernet frame payload, requires C_IP_MAX_MTU
+#define EPL_C_DLL_ISOCHR_MAX_PAYL   1490	// Byte: maximum size of PReq and PRes payload data, requires C_IP_MAX_MTU
+#define EPL_C_DLL_MAX_ASYNC_MTU     1500	// Byte: maximum asynchronous payload in bytes
+#define EPL_C_DLL_MAX_PAYL_OFFSET   1499	// Byte: maximum offset of Ethernet frame payload, requires C_IP_MAX_MTU
 #define EPL_C_DLL_MAX_RS            7
-#define EPL_C_DLL_MIN_ASYNC_MTU     282  // Byte: minimum asynchronous payload in bytes.
-#define EPL_C_DLL_MIN_PAYL_OFFSET   45   // Byte: minimum offset of Ethernet frame payload
-#define EPL_C_DLL_MULTICAST_ASND    0x01111E000004LL // EPL ASnd multicast MAC address, canonical form
-#define EPL_C_DLL_MULTICAST_PRES    0x01111E000002LL // EPL PRes multicast MAC address, canonical form
-#define EPL_C_DLL_MULTICAST_SOA     0x01111E000003LL // EPL SoA multicast MAC address, canonical form
-#define EPL_C_DLL_MULTICAST_SOC     0x01111E000001LL // EPL Soc multicast MAC address, canonical form
-#define EPL_C_DLL_PREOP1_START_CYCLES 10 // number of unassigning SoA frames at start of NMT_MS_PRE_OPERATIONAL_1
-#define EPL_C_DLL_T_BITTIME         10   // ns: Transmission time per bit on 100 Mbit/s network
-#define EPL_C_DLL_T_EPL_PDO_HEADER  10   // Byte: size of PReq and PRes EPL PDO message header
-#define EPL_C_DLL_T_ETH2_WRAPPER    18   // Byte: size of Ethernet type II wrapper consisting of header and checksum
-#define EPL_C_DLL_T_IFG             640  // ns: Ethernet Interframe Gap
-#define EPL_C_DLL_T_MIN_FRAME       5120 // ns: Size of minimum Ethernet frame (without preamble)
-#define EPL_C_DLL_T_PREAMBLE        960  // ns: Size of Ethernet frame preamble
-
-#define EPL_C_DLL_MINSIZE_SOC       36   // minimum size of SoC without padding and CRC
-#define EPL_C_DLL_MINSIZE_PREQ      60   // minimum size of PRec without CRC
-#define EPL_C_DLL_MINSIZE_PRES      60   // minimum size of PRes without CRC
-#define EPL_C_DLL_MINSIZE_SOA       24   // minimum size of SoA without padding and CRC
-#define EPL_C_DLL_MINSIZE_IDENTRES  176  // minimum size of IdentResponse without CRC
-#define EPL_C_DLL_MINSIZE_STATUSRES 72   // minimum size of StatusResponse without CRC
-#define EPL_C_DLL_MINSIZE_NMTCMD    20   // minimum size of NmtCommand without CommandData, padding and CRC
-#define EPL_C_DLL_MINSIZE_NMTCMDEXT 52   // minimum size of NmtCommand without padding and CRC
-#define EPL_C_DLL_MINSIZE_NMTREQ    20   // minimum size of NmtRequest without CommandData, padding and CRC
-#define EPL_C_DLL_MINSIZE_NMTREQEXT 52   // minimum size of NmtRequest without padding and CRC
-
-#define EPL_C_ERR_MONITOR_DELAY     10   // Error monitoring start delay (not used in DS 1.0.0)
-#define EPL_C_IP_ADR_INVALID        0x00000000L // invalid IP address (0.0.0.0) used to indicate no change
-#define EPL_C_IP_INVALID_MTU        0    // Byte: invalid MTU size used to indicate no change
-#define EPL_C_IP_MAX_MTU            1518 // Byte: maximum size in bytes of the IP stack which must be processed.
-#define EPL_C_IP_MIN_MTU            300  // Byte: minimum size in bytes of the IP stack which must be processed.
-#define EPL_C_NMT_STATE_TOLERANCE   5    // Cycles: maximum reaction time to NMT state commands
-#define EPL_C_NMT_STATREQ_CYCLE     5    // sec: StatusRequest cycle time to be applied to AsyncOnly CNs
+#define EPL_C_DLL_MIN_ASYNC_MTU     282	// Byte: minimum asynchronous payload in bytes.
+#define EPL_C_DLL_MIN_PAYL_OFFSET   45	// Byte: minimum offset of Ethernet frame payload
+#define EPL_C_DLL_MULTICAST_ASND    0x01111E000004LL	// EPL ASnd multicast MAC address, canonical form
+#define EPL_C_DLL_MULTICAST_PRES    0x01111E000002LL	// EPL PRes multicast MAC address, canonical form
+#define EPL_C_DLL_MULTICAST_SOA     0x01111E000003LL	// EPL SoA multicast MAC address, canonical form
+#define EPL_C_DLL_MULTICAST_SOC     0x01111E000001LL	// EPL Soc multicast MAC address, canonical form
+#define EPL_C_DLL_PREOP1_START_CYCLES 10	// number of unassigning SoA frames at start of NMT_MS_PRE_OPERATIONAL_1
+#define EPL_C_DLL_T_BITTIME         10	// ns: Transmission time per bit on 100 Mbit/s network
+#define EPL_C_DLL_T_EPL_PDO_HEADER  10	// Byte: size of PReq and PRes EPL PDO message header
+#define EPL_C_DLL_T_ETH2_WRAPPER    18	// Byte: size of Ethernet type II wrapper consisting of header and checksum
+#define EPL_C_DLL_T_IFG             640	// ns: Ethernet Interframe Gap
+#define EPL_C_DLL_T_MIN_FRAME       5120	// ns: Size of minimum Ethernet frame (without preamble)
+#define EPL_C_DLL_T_PREAMBLE        960	// ns: Size of Ethernet frame preamble
+
+#define EPL_C_DLL_MINSIZE_SOC       36	// minimum size of SoC without padding and CRC
+#define EPL_C_DLL_MINSIZE_PREQ      60	// minimum size of PRec without CRC
+#define EPL_C_DLL_MINSIZE_PRES      60	// minimum size of PRes without CRC
+#define EPL_C_DLL_MINSIZE_SOA       24	// minimum size of SoA without padding and CRC
+#define EPL_C_DLL_MINSIZE_IDENTRES  176	// minimum size of IdentResponse without CRC
+#define EPL_C_DLL_MINSIZE_STATUSRES 72	// minimum size of StatusResponse without CRC
+#define EPL_C_DLL_MINSIZE_NMTCMD    20	// minimum size of NmtCommand without CommandData, padding and CRC
+#define EPL_C_DLL_MINSIZE_NMTCMDEXT 52	// minimum size of NmtCommand without padding and CRC
+#define EPL_C_DLL_MINSIZE_NMTREQ    20	// minimum size of NmtRequest without CommandData, padding and CRC
+#define EPL_C_DLL_MINSIZE_NMTREQEXT 52	// minimum size of NmtRequest without padding and CRC
+
+#define EPL_C_ERR_MONITOR_DELAY     10	// Error monitoring start delay (not used in DS 1.0.0)
+#define EPL_C_IP_ADR_INVALID        0x00000000L	// invalid IP address (0.0.0.0) used to indicate no change
+#define EPL_C_IP_INVALID_MTU        0	// Byte: invalid MTU size used to indicate no change
+#define EPL_C_IP_MAX_MTU            1518	// Byte: maximum size in bytes of the IP stack which must be processed.
+#define EPL_C_IP_MIN_MTU            300	// Byte: minimum size in bytes of the IP stack which must be processed.
+#define EPL_C_NMT_STATE_TOLERANCE   5	// Cycles: maximum reaction time to NMT state commands
+#define EPL_C_NMT_STATREQ_CYCLE     5	// sec: StatusRequest cycle time to be applied to AsyncOnly CNs
 #define EPL_C_SDO_EPL_PORT          3819
 
-#define EPL_C_DLL_MAX_ASND_SERVICE_IDS  5   // see tEplDllAsndServiceId in EplDll.h
-
-
+#define EPL_C_DLL_MAX_ASND_SERVICE_IDS  5	// see tEplDllAsndServiceId in EplDll.h
 
 // Default configuration
 // ======================
 
 #ifndef EPL_D_PDO_Granularity_U8
-#define EPL_D_PDO_Granularity_U8    8    // minimum size of objects to be mapped in bits UNSIGNED8 O O 1 1
+#define EPL_D_PDO_Granularity_U8    8	// minimum size of objects to be mapped in bits UNSIGNED8 O O 1 1
 #endif
 
 #ifndef EPL_NMT_MAX_NODE_ID
-#define EPL_NMT_MAX_NODE_ID         254  // maximum node-ID
+#define EPL_NMT_MAX_NODE_ID         254	// maximum node-ID
 #endif
 
 #ifndef EPL_D_NMT_MaxCNNumber_U8
-#define EPL_D_NMT_MaxCNNumber_U8    239  // maximum number of supported regular CNs in the Node ID range 1 .. 239 UNSIGNED8 O O 239 239
+#define EPL_D_NMT_MaxCNNumber_U8    239	// maximum number of supported regular CNs in the Node ID range 1 .. 239 UNSIGNED8 O O 239 239
 #endif
 
 // defines for EPL API layer static process image
@@ -162,7 +158,7 @@
 #endif
 
 #ifndef EPL_OBD_MAX_STRING_SIZE
-#define EPL_OBD_MAX_STRING_SIZE        32          // is used for objects 0x1008/0x1009/0x100A
+#define EPL_OBD_MAX_STRING_SIZE        32	// is used for objects 0x1008/0x1009/0x100A
 #endif
 
 #ifndef EPL_OBD_USE_STORE_RESTORE
@@ -194,7 +190,7 @@
 #endif
 
 #ifndef EPL_VETH_NAME
-#define EPL_VETH_NAME       "epl"   // name of net device in Linux
+#define EPL_VETH_NAME       "epl"	// name of net device in Linux
 #endif
 
 /*
@@ -303,60 +299,57 @@
 #define EPL_E_DLL_LOSS_SOA_TH           0x8244
 #define EPL_E_DLL_LOSS_SOC_TH           0x8245
 // 0x84xx BootUp Errors
-#define EPL_E_NMT_BA1                   0x8410  // other MN in MsNotActive active
-#define EPL_E_NMT_BA1_NO_MN_SUPPORT     0x8411  // MN is not supported
-#define EPL_E_NMT_BPO1                  0x8420  // mandatory CN was not found or failed in BootStep1
-#define EPL_E_NMT_BPO1_GET_IDENT        0x8421  // IdentRes was not received
-#define EPL_E_NMT_BPO1_DEVICE_TYPE      0x8422  // wrong device type
-#define EPL_E_NMT_BPO1_VENDOR_ID        0x8423  // wrong vendor ID
-#define EPL_E_NMT_BPO1_PRODUCT_CODE     0x8424  // wrong product code
-#define EPL_E_NMT_BPO1_REVISION_NO      0x8425  // wrong revision number
-#define EPL_E_NMT_BPO1_SERIAL_NO        0x8426  // wrong serial number
-#define EPL_E_NMT_BPO1_CF_VERIFY        0x8428  // verification of configuration failed
-#define EPL_E_NMT_BPO2                  0x8430  // mandatory CN failed in BootStep2
-#define EPL_E_NMT_BRO                   0x8440  // CheckCommunication failed for mandatory CN
-#define EPL_E_NMT_WRONG_STATE           0x8480  // mandatory CN has wrong NMT state
+#define EPL_E_NMT_BA1                   0x8410	// other MN in MsNotActive active
+#define EPL_E_NMT_BA1_NO_MN_SUPPORT     0x8411	// MN is not supported
+#define EPL_E_NMT_BPO1                  0x8420	// mandatory CN was not found or failed in BootStep1
+#define EPL_E_NMT_BPO1_GET_IDENT        0x8421	// IdentRes was not received
+#define EPL_E_NMT_BPO1_DEVICE_TYPE      0x8422	// wrong device type
+#define EPL_E_NMT_BPO1_VENDOR_ID        0x8423	// wrong vendor ID
+#define EPL_E_NMT_BPO1_PRODUCT_CODE     0x8424	// wrong product code
+#define EPL_E_NMT_BPO1_REVISION_NO      0x8425	// wrong revision number
+#define EPL_E_NMT_BPO1_SERIAL_NO        0x8426	// wrong serial number
+#define EPL_E_NMT_BPO1_CF_VERIFY        0x8428	// verification of configuration failed
+#define EPL_E_NMT_BPO2                  0x8430	// mandatory CN failed in BootStep2
+#define EPL_E_NMT_BRO                   0x8440	// CheckCommunication failed for mandatory CN
+#define EPL_E_NMT_WRONG_STATE           0x8480	// mandatory CN has wrong NMT state
 
 // Defines for object 0x1F80 NMT_StartUp_U32
 // ==========================================
-#define EPL_NMTST_STARTALLNODES         0x00000002L // Bit 1
-#define EPL_NMTST_NO_AUTOSTART          0x00000004L // Bit 2
-#define EPL_NMTST_NO_STARTNODE          0x00000008L // Bit 3
-#define EPL_NMTST_RESETALL_MAND_CN      0x00000010L // Bit 4
-#define EPL_NMTST_STOPALL_MAND_CN       0x00000040L // Bit 6
-#define EPL_NMTST_NO_AUTOPREOP2         0x00000080L // Bit 7
-#define EPL_NMTST_NO_AUTOREADYTOOP      0x00000100L // Bit 8
-#define EPL_NMTST_EXT_CNIDENTCHECK      0x00000200L // Bit 9
-#define EPL_NMTST_SWVERSIONCHECK        0x00000400L // Bit 10
-#define EPL_NMTST_CONFCHECK             0x00000800L // Bit 11
-#define EPL_NMTST_NO_RETURN_PREOP1      0x00001000L // Bit 12
-#define EPL_NMTST_BASICETHERNET         0x00002000L // Bit 13
+#define EPL_NMTST_STARTALLNODES         0x00000002L	// Bit 1
+#define EPL_NMTST_NO_AUTOSTART          0x00000004L	// Bit 2
+#define EPL_NMTST_NO_STARTNODE          0x00000008L	// Bit 3
+#define EPL_NMTST_RESETALL_MAND_CN      0x00000010L	// Bit 4
+#define EPL_NMTST_STOPALL_MAND_CN       0x00000040L	// Bit 6
+#define EPL_NMTST_NO_AUTOPREOP2         0x00000080L	// Bit 7
+#define EPL_NMTST_NO_AUTOREADYTOOP      0x00000100L	// Bit 8
+#define EPL_NMTST_EXT_CNIDENTCHECK      0x00000200L	// Bit 9
+#define EPL_NMTST_SWVERSIONCHECK        0x00000400L	// Bit 10
+#define EPL_NMTST_CONFCHECK             0x00000800L	// Bit 11
+#define EPL_NMTST_NO_RETURN_PREOP1      0x00001000L	// Bit 12
+#define EPL_NMTST_BASICETHERNET         0x00002000L	// Bit 13
 
 // Defines for object 0x1F81 NMT_NodeAssignment_AU32
 // ==================================================
-#define EPL_NODEASSIGN_NODE_EXISTS      0x00000001L // Bit 0
-#define EPL_NODEASSIGN_NODE_IS_CN       0x00000002L // Bit 1
-#define EPL_NODEASSIGN_START_CN         0x00000004L // Bit 2
-#define EPL_NODEASSIGN_MANDATORY_CN     0x00000008L // Bit 3
-#define EPL_NODEASSIGN_KEEPALIVE        0x00000010L //currently not used in EPL V2 standard
-#define EPL_NODEASSIGN_SWVERSIONCHECK   0x00000020L // Bit 5
-#define EPL_NODEASSIGN_SWUPDATE         0x00000040L // Bit 6
-#define EPL_NODEASSIGN_ASYNCONLY_NODE   0x00000100L // Bit 8
-#define EPL_NODEASSIGN_MULTIPLEXED_CN   0x00000200L // Bit 9
-#define EPL_NODEASSIGN_RT1              0x00000400L // Bit 10
-#define EPL_NODEASSIGN_RT2              0x00000800L // Bit 11
-#define EPL_NODEASSIGN_MN_PRES          0x00001000L // Bit 12
-#define EPL_NODEASSIGN_VALID            0x80000000L // Bit 31
+#define EPL_NODEASSIGN_NODE_EXISTS      0x00000001L	// Bit 0
+#define EPL_NODEASSIGN_NODE_IS_CN       0x00000002L	// Bit 1
+#define EPL_NODEASSIGN_START_CN         0x00000004L	// Bit 2
+#define EPL_NODEASSIGN_MANDATORY_CN     0x00000008L	// Bit 3
+#define EPL_NODEASSIGN_KEEPALIVE        0x00000010L	//currently not used in EPL V2 standard
+#define EPL_NODEASSIGN_SWVERSIONCHECK   0x00000020L	// Bit 5
+#define EPL_NODEASSIGN_SWUPDATE         0x00000040L	// Bit 6
+#define EPL_NODEASSIGN_ASYNCONLY_NODE   0x00000100L	// Bit 8
+#define EPL_NODEASSIGN_MULTIPLEXED_CN   0x00000200L	// Bit 9
+#define EPL_NODEASSIGN_RT1              0x00000400L	// Bit 10
+#define EPL_NODEASSIGN_RT2              0x00000800L	// Bit 11
+#define EPL_NODEASSIGN_MN_PRES          0x00001000L	// Bit 12
+#define EPL_NODEASSIGN_VALID            0x80000000L	// Bit 31
 
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-#endif  // #ifndef _EPL_DEF_H_
+#endif // #ifndef _EPL_DEF_H_
--- a/drivers/staging/epl/EplDllCal.h
+++ b/drivers/staging/epl/EplDllCal.h
@@ -66,13 +66,11 @@
 
   2006/06/20 d.k.:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #ifndef _EPL_DLLCAL_H_
 #define _EPL_DLLCAL_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
@@ -105,18 +103,16 @@
 // typedef
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    tEplDllAsndServiceId    m_ServiceId;
-    tEplDllAsndFilter       m_Filter;
+typedef struct {
+	tEplDllAsndServiceId m_ServiceId;
+	tEplDllAsndFilter m_Filter;
 
 } tEplDllCalAsndServiceIdFilter;
 
-typedef struct
-{
-    tEplDllReqServiceId     m_Service;
-    unsigned int            m_uiNodeId;
-    BYTE                    m_bSoaFlag1;
+typedef struct {
+	tEplDllReqServiceId m_Service;
+	unsigned int m_uiNodeId;
+	BYTE m_bSoaFlag1;
 
 } tEplDllCalIssueRequest;
 
@@ -124,8 +120,4 @@ typedef struct
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-
-#endif  // #ifndef _EPL_DLLKCAL_H_
-
-
+#endif // #ifndef _EPL_DLLKCAL_H_
--- a/drivers/staging/epl/EplDll.h
+++ b/drivers/staging/epl/EplDll.h
@@ -66,7 +66,6 @@
 
   2006/06/08 d.k.:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #ifndef _EPL_DLL_H_
@@ -79,133 +78,123 @@
 // const defines
 //---------------------------------------------------------------------------
 
-
 #ifndef EPL_DLL_MAX_ASND_SERVICE_ID
-#define EPL_DLL_MAX_ASND_SERVICE_ID (EPL_C_DLL_MAX_ASND_SERVICE_IDS + 1)    // last is kEplDllAsndSdo == 5
+#define EPL_DLL_MAX_ASND_SERVICE_ID (EPL_C_DLL_MAX_ASND_SERVICE_IDS + 1)	// last is kEplDllAsndSdo == 5
 #endif
 
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
-typedef enum
-{
-    kEplDllAsndNotDefined       = 0x00,
-    kEplDllAsndIdentResponse    = 0x01,
-    kEplDllAsndStatusResponse   = 0x02,
-    kEplDllAsndNmtRequest       = 0x03,
-    kEplDllAsndNmtCommand       = 0x04,
-    kEplDllAsndSdo              = 0x05
-
+typedef enum {
+	kEplDllAsndNotDefined = 0x00,
+	kEplDllAsndIdentResponse = 0x01,
+	kEplDllAsndStatusResponse = 0x02,
+	kEplDllAsndNmtRequest = 0x03,
+	kEplDllAsndNmtCommand = 0x04,
+	kEplDllAsndSdo = 0x05
 } tEplDllAsndServiceId;
 
-typedef enum
-{
-    kEplDllAsndFilterNone     = 0x00,
-    kEplDllAsndFilterLocal    = 0x01,  // receive only ASnd frames with local or broadcast node ID
-    kEplDllAsndFilterAny      = 0x02,  // receive any ASnd frame
+typedef enum {
+	kEplDllAsndFilterNone = 0x00,
+	kEplDllAsndFilterLocal = 0x01,	// receive only ASnd frames with local or broadcast node ID
+	kEplDllAsndFilterAny = 0x02,	// receive any ASnd frame
 } tEplDllAsndFilter;
 
-typedef enum
-{
-    kEplDllReqServiceNo         = 0x00,
-    kEplDllReqServiceIdent      = 0x01,
-    kEplDllReqServiceStatus     = 0x02,
-    kEplDllReqServiceNmtRequest = 0x03,
-    kEplDllReqServiceUnspecified= 0xFF,
+typedef enum {
+	kEplDllReqServiceNo = 0x00,
+	kEplDllReqServiceIdent = 0x01,
+	kEplDllReqServiceStatus = 0x02,
+	kEplDllReqServiceNmtRequest = 0x03,
+	kEplDllReqServiceUnspecified = 0xFF,
 
 } tEplDllReqServiceId;
 
-typedef enum
-{
-    kEplDllAsyncReqPrioNmt      = 0x07, // PRIO_NMT_REQUEST
-    kEplDllAsyncReqPrio6        = 0x06,
-    kEplDllAsyncReqPrio5        = 0x05,
-    kEplDllAsyncReqPrio4        = 0x04,
-    kEplDllAsyncReqPrioGeneric  = 0x03, // PRIO_GENERIC_REQUEST
-    kEplDllAsyncReqPrio2        = 0x02, // till WSP 0.1.3: PRIO_ABOVE_GENERIC
-    kEplDllAsyncReqPrio1        = 0x01, // till WSP 0.1.3: PRIO_BELOW_GENERIC
-    kEplDllAsyncReqPrio0        = 0x00, // till WSP 0.1.3: PRIO_GENERIC_REQUEST
+typedef enum {
+	kEplDllAsyncReqPrioNmt = 0x07,	// PRIO_NMT_REQUEST
+	kEplDllAsyncReqPrio6 = 0x06,
+	kEplDllAsyncReqPrio5 = 0x05,
+	kEplDllAsyncReqPrio4 = 0x04,
+	kEplDllAsyncReqPrioGeneric = 0x03,	// PRIO_GENERIC_REQUEST
+	kEplDllAsyncReqPrio2 = 0x02,	// till WSP 0.1.3: PRIO_ABOVE_GENERIC
+	kEplDllAsyncReqPrio1 = 0x01,	// till WSP 0.1.3: PRIO_BELOW_GENERIC
+	kEplDllAsyncReqPrio0 = 0x00,	// till WSP 0.1.3: PRIO_GENERIC_REQUEST
 
 } tEplDllAsyncReqPriority;
 
-typedef struct
-{
-    unsigned int      m_uiFrameSize;
-    tEplFrame       * m_pFrame;
-    tEplNetTime       m_NetTime;
+typedef struct {
+	unsigned int m_uiFrameSize;
+	tEplFrame *m_pFrame;
+	tEplNetTime m_NetTime;
 
 } tEplFrameInfo;
 
-typedef struct
-{
-    unsigned int        m_uiSizeOfStruct;
-    BOOL                m_fAsyncOnly;   // do not need to register PRes-Frame
-    unsigned int        m_uiNodeId;     // local node ID
-
-    // 0x1F82: NMT_FeatureFlags_U32
-    DWORD               m_dwFeatureFlags;
-    // Cycle Length (0x1006: NMT_CycleLen_U32) in [us]
-    DWORD               m_dwCycleLen;         // required for error detection
-    // 0x1F98: NMT_CycleTiming_REC
-    // 0x1F98.1: IsochrTxMaxPayload_U16
-    unsigned int        m_uiIsochrTxMaxPayload; // const
-    // 0x1F98.2: IsochrRxMaxPayload_U16
-    unsigned int        m_uiIsochrRxMaxPayload; // const
-    // 0x1F98.3: PResMaxLatency_U32
-    DWORD               m_dwPresMaxLatency;   // const in [ns], only required for IdentRes
-    // 0x1F98.4: PReqActPayloadLimit_U16
-    unsigned int        m_uiPreqActPayloadLimit; // required for initialisation (+24 bytes)
-    // 0x1F98.5: PResActPayloadLimit_U16
-    unsigned int        m_uiPresActPayloadLimit; // required for initialisation of Pres frame (+24 bytes)
-    // 0x1F98.6: ASndMaxLatency_U32
-    DWORD               m_dwAsndMaxLatency;   // const in [ns], only required for IdentRes
-    // 0x1F98.7: MultiplCycleCnt_U8
-    unsigned int        m_uiMultiplCycleCnt;  // required for error detection
-    // 0x1F98.8: AsyncMTU_U16
-    unsigned int        m_uiAsyncMtu;         // required to set up max frame size
-    // $$$ 0x1F98.9: Prescaler_U16
-    // $$$ Multiplexed Slot
-
-    // 0x1C14: DLL_LossOfFrameTolerance_U32 in [ns]
-    DWORD               m_dwLossOfFrameTolerance;
-
-    // 0x1F8A: NMT_MNCycleTiming_REC
-    // 0x1F8A.1: WaitSoCPReq_U32 in [ns]
-    DWORD               m_dwWaitSocPreq;
+typedef struct {
+	unsigned int m_uiSizeOfStruct;
+	BOOL m_fAsyncOnly;	// do not need to register PRes-Frame
+	unsigned int m_uiNodeId;	// local node ID
+
+	// 0x1F82: NMT_FeatureFlags_U32
+	DWORD m_dwFeatureFlags;
+	// Cycle Length (0x1006: NMT_CycleLen_U32) in [us]
+	DWORD m_dwCycleLen;	// required for error detection
+	// 0x1F98: NMT_CycleTiming_REC
+	// 0x1F98.1: IsochrTxMaxPayload_U16
+	unsigned int m_uiIsochrTxMaxPayload;	// const
+	// 0x1F98.2: IsochrRxMaxPayload_U16
+	unsigned int m_uiIsochrRxMaxPayload;	// const
+	// 0x1F98.3: PResMaxLatency_U32
+	DWORD m_dwPresMaxLatency;	// const in [ns], only required for IdentRes
+	// 0x1F98.4: PReqActPayloadLimit_U16
+	unsigned int m_uiPreqActPayloadLimit;	// required for initialisation (+24 bytes)
+	// 0x1F98.5: PResActPayloadLimit_U16
+	unsigned int m_uiPresActPayloadLimit;	// required for initialisation of Pres frame (+24 bytes)
+	// 0x1F98.6: ASndMaxLatency_U32
+	DWORD m_dwAsndMaxLatency;	// const in [ns], only required for IdentRes
+	// 0x1F98.7: MultiplCycleCnt_U8
+	unsigned int m_uiMultiplCycleCnt;	// required for error detection
+	// 0x1F98.8: AsyncMTU_U16
+	unsigned int m_uiAsyncMtu;	// required to set up max frame size
+	// $$$ 0x1F98.9: Prescaler_U16
+	// $$$ Multiplexed Slot
+
+	// 0x1C14: DLL_LossOfFrameTolerance_U32 in [ns]
+	DWORD m_dwLossOfFrameTolerance;
+
+	// 0x1F8A: NMT_MNCycleTiming_REC
+	// 0x1F8A.1: WaitSoCPReq_U32 in [ns]
+	DWORD m_dwWaitSocPreq;
 
-    // 0x1F8A.2: AsyncSlotTimeout_U32 in [ns]
-    DWORD               m_dwAsyncSlotTimeout;
+	// 0x1F8A.2: AsyncSlotTimeout_U32 in [ns]
+	DWORD m_dwAsyncSlotTimeout;
 
 } tEplDllConfigParam;
 
-typedef struct
-{
-    unsigned int      m_uiSizeOfStruct;
-    DWORD             m_dwDeviceType;              // NMT_DeviceType_U32
-    DWORD             m_dwVendorId;                // NMT_IdentityObject_REC.VendorId_U32
-    DWORD             m_dwProductCode;             // NMT_IdentityObject_REC.ProductCode_U32
-    DWORD             m_dwRevisionNumber;          // NMT_IdentityObject_REC.RevisionNo_U32
-    DWORD             m_dwSerialNumber;            // NMT_IdentityObject_REC.SerialNo_U32
-    QWORD             m_qwVendorSpecificExt1;
-    DWORD             m_dwVerifyConfigurationDate; // CFM_VerifyConfiguration_REC.ConfDate_U32
-    DWORD             m_dwVerifyConfigurationTime; // CFM_VerifyConfiguration_REC.ConfTime_U32
-    DWORD             m_dwApplicationSwDate;       // PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
-    DWORD             m_dwApplicationSwTime;       // PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
-    DWORD             m_dwIpAddress;
-    DWORD             m_dwSubnetMask;
-    DWORD             m_dwDefaultGateway;
-    BYTE              m_sHostname[32];
-    BYTE              m_abVendorSpecificExt2[48];
+typedef struct {
+	unsigned int m_uiSizeOfStruct;
+	DWORD m_dwDeviceType;	// NMT_DeviceType_U32
+	DWORD m_dwVendorId;	// NMT_IdentityObject_REC.VendorId_U32
+	DWORD m_dwProductCode;	// NMT_IdentityObject_REC.ProductCode_U32
+	DWORD m_dwRevisionNumber;	// NMT_IdentityObject_REC.RevisionNo_U32
+	DWORD m_dwSerialNumber;	// NMT_IdentityObject_REC.SerialNo_U32
+	QWORD m_qwVendorSpecificExt1;
+	DWORD m_dwVerifyConfigurationDate;	// CFM_VerifyConfiguration_REC.ConfDate_U32
+	DWORD m_dwVerifyConfigurationTime;	// CFM_VerifyConfiguration_REC.ConfTime_U32
+	DWORD m_dwApplicationSwDate;	// PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
+	DWORD m_dwApplicationSwTime;	// PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
+	DWORD m_dwIpAddress;
+	DWORD m_dwSubnetMask;
+	DWORD m_dwDefaultGateway;
+	BYTE m_sHostname[32];
+	BYTE m_abVendorSpecificExt2[48];
 
 } tEplDllIdentParam;
 
-typedef struct
-{
-    unsigned int                m_uiNodeId;
-    WORD                        m_wPreqPayloadLimit;    // object 0x1F8B: NMT_MNPReqPayloadLimitList_AU16
-    WORD                        m_wPresPayloadLimit;    // object 0x1F8D: NMT_PResPayloadLimitList_AU16
-    DWORD                       m_dwPresTimeout;        // object 0x1F92: NMT_MNCNPResTimeout_AU32
+typedef struct {
+	unsigned int m_uiNodeId;
+	WORD m_wPreqPayloadLimit;	// object 0x1F8B: NMT_MNPReqPayloadLimitList_AU16
+	WORD m_wPresPayloadLimit;	// object 0x1F8D: NMT_PResPayloadLimitList_AU16
+	DWORD m_dwPresTimeout;	// object 0x1F92: NMT_MNCNPResTimeout_AU32
 
 } tEplDllNodeInfo;
 
@@ -213,8 +202,4 @@ typedef struct
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-
-#endif  // #ifndef _EPL_DLL_H_
-
-
+#endif // #ifndef _EPL_DLL_H_
--- a/drivers/staging/epl/EplErrDef.h
+++ b/drivers/staging/epl/EplErrDef.h
@@ -71,185 +71,179 @@
 #ifndef _EPL_ERRORDEF_H_
 #define _EPL_ERRORDEF_H_
 
-
 //---------------------------------------------------------------------------
 // return codes
 //---------------------------------------------------------------------------
 
-typedef enum
-{
-    // area for generic errors 0x0000 - 0x000F
-    kEplSuccessful              = 0x0000,       // no error/successful run
-    kEplIllegalInstance         = 0x0001,       // the called Instanz does not exist
-    kEplInvalidInstanceParam    = 0x0002,       //
-    kEplNoFreeInstance          = 0x0003,       // XxxAddInstance was called but no free instance is available
-    kEplWrongSignature          = 0x0004,       // wrong signature while writing to object 0x1010 or 0x1011
-    kEplInvalidOperation        = 0x0005,       // operation not allowed in this situation
-    kEplInvalidNodeId           = 0x0007,       // invalid NodeId was specified
-    kEplNoResource              = 0x0008,       // resource could not be created (Windows, PxROS, ...)
-    kEplShutdown                = 0x0009,       // stack is shutting down
-    kEplReject                  = 0x000A,       // reject the subsequent command
+typedef enum {
+	// area for generic errors 0x0000 - 0x000F
+	kEplSuccessful = 0x0000,	// no error/successful run
+	kEplIllegalInstance = 0x0001,	// the called Instanz does not exist
+	kEplInvalidInstanceParam = 0x0002,	//
+	kEplNoFreeInstance = 0x0003,	// XxxAddInstance was called but no free instance is available
+	kEplWrongSignature = 0x0004,	// wrong signature while writing to object 0x1010 or 0x1011
+	kEplInvalidOperation = 0x0005,	// operation not allowed in this situation
+	kEplInvalidNodeId = 0x0007,	// invalid NodeId was specified
+	kEplNoResource = 0x0008,	// resource could not be created (Windows, PxROS, ...)
+	kEplShutdown = 0x0009,	// stack is shutting down
+	kEplReject = 0x000A,	// reject the subsequent command
 
-    // area for EDRV module 0x0010 - 0x001F
+	// area for EDRV module 0x0010 - 0x001F
 //    kEplEdrvNoFrame             = 0x0010,       // no CAN message was received
 //    kEplEdrvMsgHigh             = 0x0011,       // CAN message with high priority was received
 //    kEplEdrvMsgLow              = 0x0012,       // CAN message with low priority was received
-    kEplEdrvInitError           = 0x0013,       // initialisation error
-    kEplEdrvNoFreeBufEntry      = 0x0014,       // no free entry in internal buffer table for Tx frames
-    kEplEdrvBufNotExisting      = 0x0015,       // specified Tx buffer does not exist
+	kEplEdrvInitError = 0x0013,	// initialisation error
+	kEplEdrvNoFreeBufEntry = 0x0014,	// no free entry in internal buffer table for Tx frames
+	kEplEdrvBufNotExisting = 0x0015,	// specified Tx buffer does not exist
 //    kEplEdrvNoFreeChannel       = 0x0014,       // CAN controller has not a free channel
 //    kEplEdrvTxBuffHighOverrun   = 0x0015,       // buffer for high priority CAN transmit messages has overrun
 //    kEplEdrvTxBuffLowOverrun    = 0x0016,       // buffer for low priority CAN transmit messages has overrun
 //    kEplEdrvIllegalBdi          = 0x0017,       // unsupported baudrate within baudrate table
 //    kEplEdrvBusy                = 0x0018,       // remote frame can not be updated because no bus contact or CAN
-                                                // transmission is activ
+	// transmission is activ
 //    kEplEdrvInvalidDriverType   = 0x0019,       // (PC: Windows or Linux) invalid driver type
 //    kEplEdrvDriverNotFound      = 0x001A,       // (PC: Windows or Linux) driver (DLL) could not be found
 //    kEplEdrvInvalidBaseAddress  = 0x001B,       // (PC: Windows or Linux) driver could not found the CAN controller
 //    kEplEdrvInvalidParam        = 0x001C,       // invalid param in function call
 
-    // area for COB module 0x0020 - 0x002F
+	// area for COB module 0x0020 - 0x002F
 /*    kEplCobNoFreeEntry          = 0x0020,       // no free entry in RX- or TX-COB table
     kEplCobAlreadyExist         = 0x0021,       // COB-ID already exists in RX- resp. TX-COB table
     */
-    kEplDllIllegalHdl           = 0x0022,       // illegal handle for a TxFrame was passed
-    kEplDllCbAsyncRegistered    = 0x0023,       // handler for non-EPL frames was already registered before
+	kEplDllIllegalHdl = 0x0022,	// illegal handle for a TxFrame was passed
+	kEplDllCbAsyncRegistered = 0x0023,	// handler for non-EPL frames was already registered before
 //    kEplDllAsyncRxBufferFull    = 0x0024,       // receive buffer for asynchronous frames is full
-    kEplDllAsyncTxBufferEmpty   = 0x0025,       // transmit buffer for asynchronous frames is empty
-    kEplDllAsyncTxBufferFull    = 0x0026,       // transmit buffer for asynchronous frames is full
-    kEplDllNoNodeInfo           = 0x0027,       // MN: too less space in the internal node info structure
-    kEplDllInvalidParam         = 0x0028,       // invalid parameters passed to function
-    kEplDllTxBufNotReady        = 0x002E,       // TxBuffer (e.g. for PReq) is not ready yet
-    kEplDllTxFrameInvalid       = 0x002F,       // TxFrame (e.g. for PReq) is invalid or does not exist
+	kEplDllAsyncTxBufferEmpty = 0x0025,	// transmit buffer for asynchronous frames is empty
+	kEplDllAsyncTxBufferFull = 0x0026,	// transmit buffer for asynchronous frames is full
+	kEplDllNoNodeInfo = 0x0027,	// MN: too less space in the internal node info structure
+	kEplDllInvalidParam = 0x0028,	// invalid parameters passed to function
+	kEplDllTxBufNotReady = 0x002E,	// TxBuffer (e.g. for PReq) is not ready yet
+	kEplDllTxFrameInvalid = 0x002F,	// TxFrame (e.g. for PReq) is invalid or does not exist
 /*    kEplCobIllegalCanId         = 0x0023,       // COB-ID is not allowed (like 0x000 is reserved for NMT, ...)
     kEplCobInvalidCanId         = 0x0024,       // COB-ID is switched off
     kEplCobCdrvStateSet         = 0x0025,       // at least one bit of CAN driver state is set
     kEplCobNoFreeEntryHighBuf   = 0x0026,       // no free entry in high priotity RX- or TX-COB table
     kEplCobOwnId                = 0x0027,       // COB-ID already exists in own module which calls CobDefine() or CobCheck()
 */
-    // area for OBD module 0x0030 - 0x003F
-    kEplObdIllegalPart          = 0x0030,       // unknown OD part
-    kEplObdIndexNotExist        = 0x0031,       // object index does not exist in OD
-    kEplObdSubindexNotExist     = 0x0032,       // subindex does not exist in object index
-    kEplObdReadViolation        = 0x0033,       // read access to a write-only object
-    kEplObdWriteViolation       = 0x0034,       // write access to a read-only object
-    kEplObdAccessViolation      = 0x0035,       // access not allowed
-    kEplObdUnknownObjectType    = 0x0036,       // object type not defined/known
-    kEplObdVarEntryNotExist     = 0x0037,       // object does not contain VarEntry structure
-    kEplObdValueTooLow          = 0x0038,       // value to write to an object is too low
-    kEplObdValueTooHigh         = 0x0039,       // value to write to an object is too high
-    kEplObdValueLengthError     = 0x003A,       // value to write is to long or to short
+	// area for OBD module 0x0030 - 0x003F
+	kEplObdIllegalPart = 0x0030,	// unknown OD part
+	kEplObdIndexNotExist = 0x0031,	// object index does not exist in OD
+	kEplObdSubindexNotExist = 0x0032,	// subindex does not exist in object index
+	kEplObdReadViolation = 0x0033,	// read access to a write-only object
+	kEplObdWriteViolation = 0x0034,	// write access to a read-only object
+	kEplObdAccessViolation = 0x0035,	// access not allowed
+	kEplObdUnknownObjectType = 0x0036,	// object type not defined/known
+	kEplObdVarEntryNotExist = 0x0037,	// object does not contain VarEntry structure
+	kEplObdValueTooLow = 0x0038,	// value to write to an object is too low
+	kEplObdValueTooHigh = 0x0039,	// value to write to an object is too high
+	kEplObdValueLengthError = 0x003A,	// value to write is to long or to short
 //    kEplObdIllegalFloat         = 0x003B,       // illegal float variable
 //    kEplObdWrongOdBuilderKey    = 0x003F,       // OD was generated with demo version of tool ODBuilder
 
-    // area for NMT module 0x0040 - 0x004F
-    kEplNmtUnknownCommand       = 0x0040,       // unknown NMT command
-    kEplNmtInvalidFramePointer  = 0x0041,       // pointer to the frame is not valid
-    kEplNmtInvalidEvent         = 0x0042,       // invalid event send to NMT-modul
-    kEplNmtInvalidState         = 0x0043,       // unknown state in NMT-State-Maschine
-    kEplNmtInvalidParam         = 0x0044,       // invalid parameters specified
-
-    // area for SDO/UDP module 0x0050 - 0x005F
-    kEplSdoUdpMissCb            = 0x0050,       // missing callback-function pointer during inti of
-                                                // module
-    kEplSdoUdpNoSocket          = 0x0051,       // error during init of socket
-    kEplSdoUdpSocketError       = 0x0052,       // error during usage of socket
-    kEplSdoUdpThreadError       = 0x0053,       // error during start of listen thread
-    kEplSdoUdpNoFreeHandle      = 0x0054,       // no free connection handle for Udp
-    kEplSdoUdpSendError         = 0x0055,       // Error during send of frame
-    kEplSdoUdpInvalidHdl        = 0x0056,       // the connection handle is invalid
-
-    // area for SDO Sequence layer module 0x0060 - 0x006F
-    kEplSdoSeqMissCb            = 0x0060,       // no callback-function assign
-    kEplSdoSeqNoFreeHandle      = 0x0061,       // no free handle for connection
-    kEplSdoSeqInvalidHdl        = 0x0062,       // invalid handle in SDO sequence layer
-    kEplSdoSeqUnsupportedProt   = 0x0063,       // unsupported Protocol selected
-    kEplSdoSeqNoFreeHistory     = 0x0064,       // no free entry in history
-    kEplSdoSeqFrameSizeError    = 0x0065,       // the size of the frames is not correct
-    kEplSdoSeqRequestAckNeeded  = 0x0066,       // indeicates that the history buffer is full
-                                                // and a ack request is needed
-    kEplSdoSeqInvalidFrame      = 0x0067,       // frame not valid
-    kEplSdoSeqConnectionBusy    = 0x0068,       // connection is busy -> retry later
-    kEplSdoSeqInvalidEvent      = 0x0069,       // invalid event received
-
-    // area for SDO Command Layer Module 0x0070 - 0x007F
-    kEplSdoComUnsupportedProt   = 0x0070,       // unsupported Protocol selected
-    kEplSdoComNoFreeHandle      = 0x0071,       // no free handle for connection
-    kEplSdoComInvalidServiceType= 0x0072,       // invalid SDO service type specified
-    kEplSdoComInvalidHandle     = 0x0073,       // handle invalid
-    kEplSdoComInvalidSendType   = 0x0074,       // the stated to of frame to send is
-                                                // not possible
-    kEplSdoComNotResponsible    = 0x0075,       // internal error: command layer handle is
-                                                // not responsible for this event from sequence layer
-    kEplSdoComHandleExists      = 0x0076,       // handle to same node already exists
-    kEplSdoComHandleBusy        = 0x0077,       // transfer via this handle is already running
-    kEplSdoComInvalidParam      = 0x0078,       // invalid parameters passed to function
-
-    // area for EPL Event-Modul 0x0080 - 0x008F
-    kEplEventUnknownSink        = 0x0080,     // unknown sink for event
-    kEplEventPostError          = 0x0081,     // error during post of event
-
-
-
-    // area for EPL Timer Modul 0x0090 - 0x009F
-    kEplTimerInvalidHandle      = 0x0090,     // invalid handle for timer
-    kEplTimerNoTimerCreated     = 0x0091,     // no timer was created caused by
-                                                // an error
-
-    // area for EPL SDO/Asnd Module 0x00A0 - 0x0AF
-    kEplSdoAsndInvalidNodeId    = 0x00A0,     //0 node id is invalid
-    kEplSdoAsndNoFreeHandle     = 0x00A1,     // no free handle for connection
-    kEplSdoAsndInvalidHandle    = 0x00A2,     // handle for connection is invalid
-
-
-    // area for PDO module 0x00B0 - 0x00BF
-    kEplPdoNotExist             = 0x00B0,       // selected PDO does not exist
-    kEplPdoLengthExceeded       = 0x00B1,       // length of PDO mapping exceedes 64 bis
-    kEplPdoGranularityMismatch  = 0x00B2,       // configured PDO granularity is not equal to supported granularity
-    kEplPdoInitError            = 0x00B3,       // error during initialisation of PDO module
-    kEplPdoErrorPdoEncode       = 0x00B4,       // error during encoding a PDO
-    kEplPdoErrorPdoDecode       = 0x00B5,       // error during decoding a PDO
-    kEplPdoErrorSend            = 0x00B6,       // error during sending a PDO
-    kEplPdoErrorSyncWin         = 0x00B7,       // the SYNC window runs out during sending SYNC-PDOs
-    kEplPdoErrorMapp            = 0x00B8,       // invalid PDO mapping
-    kEplPdoVarNotFound          = 0x00B9,       // variable was not found in function PdoSignalVar()
-    kEplPdoErrorEmcyPdoLen      = 0x00BA,       // the length of a received PDO is unequal to the expected value
-    kEplPdoWriteConstObject     = 0x00BB,       // constant object can not be written
-                                                // (only TxType, Inhibit-, Event Time for CANopen Kit)
+	// area for NMT module 0x0040 - 0x004F
+	kEplNmtUnknownCommand = 0x0040,	// unknown NMT command
+	kEplNmtInvalidFramePointer = 0x0041,	// pointer to the frame is not valid
+	kEplNmtInvalidEvent = 0x0042,	// invalid event send to NMT-modul
+	kEplNmtInvalidState = 0x0043,	// unknown state in NMT-State-Maschine
+	kEplNmtInvalidParam = 0x0044,	// invalid parameters specified
+
+	// area for SDO/UDP module 0x0050 - 0x005F
+	kEplSdoUdpMissCb = 0x0050,	// missing callback-function pointer during inti of
+	// module
+	kEplSdoUdpNoSocket = 0x0051,	// error during init of socket
+	kEplSdoUdpSocketError = 0x0052,	// error during usage of socket
+	kEplSdoUdpThreadError = 0x0053,	// error during start of listen thread
+	kEplSdoUdpNoFreeHandle = 0x0054,	// no free connection handle for Udp
+	kEplSdoUdpSendError = 0x0055,	// Error during send of frame
+	kEplSdoUdpInvalidHdl = 0x0056,	// the connection handle is invalid
+
+	// area for SDO Sequence layer module 0x0060 - 0x006F
+	kEplSdoSeqMissCb = 0x0060,	// no callback-function assign
+	kEplSdoSeqNoFreeHandle = 0x0061,	// no free handle for connection
+	kEplSdoSeqInvalidHdl = 0x0062,	// invalid handle in SDO sequence layer
+	kEplSdoSeqUnsupportedProt = 0x0063,	// unsupported Protocol selected
+	kEplSdoSeqNoFreeHistory = 0x0064,	// no free entry in history
+	kEplSdoSeqFrameSizeError = 0x0065,	// the size of the frames is not correct
+	kEplSdoSeqRequestAckNeeded = 0x0066,	// indeicates that the history buffer is full
+	// and a ack request is needed
+	kEplSdoSeqInvalidFrame = 0x0067,	// frame not valid
+	kEplSdoSeqConnectionBusy = 0x0068,	// connection is busy -> retry later
+	kEplSdoSeqInvalidEvent = 0x0069,	// invalid event received
+
+	// area for SDO Command Layer Module 0x0070 - 0x007F
+	kEplSdoComUnsupportedProt = 0x0070,	// unsupported Protocol selected
+	kEplSdoComNoFreeHandle = 0x0071,	// no free handle for connection
+	kEplSdoComInvalidServiceType = 0x0072,	// invalid SDO service type specified
+	kEplSdoComInvalidHandle = 0x0073,	// handle invalid
+	kEplSdoComInvalidSendType = 0x0074,	// the stated to of frame to send is
+	// not possible
+	kEplSdoComNotResponsible = 0x0075,	// internal error: command layer handle is
+	// not responsible for this event from sequence layer
+	kEplSdoComHandleExists = 0x0076,	// handle to same node already exists
+	kEplSdoComHandleBusy = 0x0077,	// transfer via this handle is already running
+	kEplSdoComInvalidParam = 0x0078,	// invalid parameters passed to function
+
+	// area for EPL Event-Modul 0x0080 - 0x008F
+	kEplEventUnknownSink = 0x0080,	// unknown sink for event
+	kEplEventPostError = 0x0081,	// error during post of event
+
+	// area for EPL Timer Modul 0x0090 - 0x009F
+	kEplTimerInvalidHandle = 0x0090,	// invalid handle for timer
+	kEplTimerNoTimerCreated = 0x0091,	// no timer was created caused by
+	// an error
+
+	// area for EPL SDO/Asnd Module 0x00A0 - 0x0AF
+	kEplSdoAsndInvalidNodeId = 0x00A0,	//0 node id is invalid
+	kEplSdoAsndNoFreeHandle = 0x00A1,	// no free handle for connection
+	kEplSdoAsndInvalidHandle = 0x00A2,	// handle for connection is invalid
+
+	// area for PDO module 0x00B0 - 0x00BF
+	kEplPdoNotExist = 0x00B0,	// selected PDO does not exist
+	kEplPdoLengthExceeded = 0x00B1,	// length of PDO mapping exceedes 64 bis
+	kEplPdoGranularityMismatch = 0x00B2,	// configured PDO granularity is not equal to supported granularity
+	kEplPdoInitError = 0x00B3,	// error during initialisation of PDO module
+	kEplPdoErrorPdoEncode = 0x00B4,	// error during encoding a PDO
+	kEplPdoErrorPdoDecode = 0x00B5,	// error during decoding a PDO
+	kEplPdoErrorSend = 0x00B6,	// error during sending a PDO
+	kEplPdoErrorSyncWin = 0x00B7,	// the SYNC window runs out during sending SYNC-PDOs
+	kEplPdoErrorMapp = 0x00B8,	// invalid PDO mapping
+	kEplPdoVarNotFound = 0x00B9,	// variable was not found in function PdoSignalVar()
+	kEplPdoErrorEmcyPdoLen = 0x00BA,	// the length of a received PDO is unequal to the expected value
+	kEplPdoWriteConstObject = 0x00BB,	// constant object can not be written
+	// (only TxType, Inhibit-, Event Time for CANopen Kit)
 
-    // area for LSS slave module
+	// area for LSS slave module
 /*    kEplLsssResetNode           = 0x0080,       // NMT command "reset node" has to be processed after LSS configuration
                                                 // new of NodeId
     kEplLsssInvalidNodeId       = 0x0081,       // no valid NodeId is configured -> wait until it is configured with
                                                 // LSS service before calling CcmConnectToNet()
 */
-    // area for emergency consumer module 0x0090 - 0x009F
+	// area for emergency consumer module 0x0090 - 0x009F
 /*    kEplEmccNoFreeProducerEntry = 0x0090,       // no free entry to add a Emergency Producer
     kEplEmccNodeIdNotExist      = 0x0091,       // selected NodeId was never added
     kEplEmccNodeIdInvalid       = 0x0092,       // selected NodeId is outside of range (0x01 until 0x7F)
     kEplEmccNodeIdExist         = 0x0093,       // selected NodeId already exist
 */
-    // area for dynamic OD 0x00A0 - 0x00AF
+	// area for dynamic OD 0x00A0 - 0x00AF
 /*    kEplDynNoMemory             = 0x00A0,       // no memory available
     kEplDynInvalidConfig        = 0x00A1,       // invalid configuration in segment container
 */
-    // area for hertbeat consumer module 0x00B0 - 0x00BF
+	// area for hertbeat consumer module 0x00B0 - 0x00BF
 /*    kEplHbcEntryNotExist        = 0x00B0,       // Heartbeat Producer node not configured
     kEplHbcEntryAlreadyExist    = 0x00B1,       // NodeId was already defined in heartbeat consumer table (object 0x1016)
 */
-    // Configuration manager module 0x00C0 - 0x00CF
-    kEplCfgMaConfigError        = 0x00C0,       // error in configuration manager
-    kEplCfgMaSdocTimeOutError   = 0x00C1,       // error in configuration manager, Sdo timeout
-    kEplCfgMaInvalidDcf         = 0x00C2,       // configration file not valid
-    kEplCfgMaUnsupportedDcf     = 0x00C3,       // unsupported Dcf format
-    kEplCfgMaConfigWithErrors   = 0x00C4,       // configuration finished with errors
-    kEplCfgMaNoFreeConfig       = 0x00C5,       // no free configuration entry
-    kEplCfgMaNoConfigData       = 0x00C6,       // no configuration data present
-    kEplCfgMaUnsuppDatatypeDcf  = 0x00C7,       // unsupported datatype found in dcf
-                                                // -> this entry was not configured
-
+	// Configuration manager module 0x00C0 - 0x00CF
+	kEplCfgMaConfigError = 0x00C0,	// error in configuration manager
+	kEplCfgMaSdocTimeOutError = 0x00C1,	// error in configuration manager, Sdo timeout
+	kEplCfgMaInvalidDcf = 0x00C2,	// configration file not valid
+	kEplCfgMaUnsupportedDcf = 0x00C3,	// unsupported Dcf format
+	kEplCfgMaConfigWithErrors = 0x00C4,	// configuration finished with errors
+	kEplCfgMaNoFreeConfig = 0x00C5,	// no free configuration entry
+	kEplCfgMaNoConfigData = 0x00C6,	// no configuration data present
+	kEplCfgMaUnsuppDatatypeDcf = 0x00C7,	// unsupported datatype found in dcf
+	// -> this entry was not configured
 
-    // area for LSS master module 0x00D0 - 0x00DF
+	// area for LSS master module 0x00D0 - 0x00DF
 /*    kEplLssmIllegalMode         = 0x00D0,       // illegal LSS mode (operation / configuration)
     kEplLssmIllegalState        = 0x00D1,       // function was called in illegal state of LSS master
     kEplLssmBusy                = 0x00D2,       // LSS process is busy with an previous service
@@ -257,11 +251,11 @@ typedef enum
     kEplLssmTimeout             = 0x00D4,       // LSS slave did not answer a LSS service
     kEplLssmErrorInConfirm      = 0x00D5,       // LSS slave replied an error code for a LSS service
 */
-    // area for CCM modules 0x00E0 - 0xEF
+	// area for CCM modules 0x00E0 - 0xEF
 /*    kEplCcmStoreUnvalidState    = 0x00E0,       // memory device not available due device state
     kEplCcmStoreHwError         = 0x00E1,       // hw error due device access
 */
-    // area for SRDO module 0x0100 - 0x011F
+	// area for SRDO module 0x0100 - 0x011F
 /*    kEplSrdoNotExist            = 0x0100,       // selected SRDO does not exist
     kEplSrdoGranularityMismatch = 0x0101,       // configured SRDO granularity is not equal to supported granularity
     kEplSrdoCfgTimingError      = 0x0102,       // configuration is not ok (Timing)
@@ -285,18 +279,16 @@ typedef enum
     kEplSrdoOverrun             = 0x0114        // a RxSRDO was received but the pevious one was not else processed
 */
 
-    kEplApiTaskDeferred         = 0x0140,       // EPL performs task in background and informs the application (or vice-versa), when it is finished
-    kEplApiInvalidParam         = 0x0142,       // passed invalid parameters to a function (e.g. invalid node id)
+	kEplApiTaskDeferred = 0x0140,	// EPL performs task in background and informs the application (or vice-versa), when it is finished
+	kEplApiInvalidParam = 0x0142,	// passed invalid parameters to a function (e.g. invalid node id)
 
-    // area untill 0x07FF is reserved
-    // area for user application from 0x0800 to 0x7FFF
+	// area untill 0x07FF is reserved
+	// area for user application from 0x0800 to 0x7FFF
 
 } tEplKernel;
 
-
 #endif
 //EOF
 
 // Die letzte Zeile muß unbedingt eine leere Zeile sein, weil manche Compiler
 // damit ein Problem haben, wenn das nicht so ist (z.B. GNU oder Borland C++ Builder).
-
--- a/drivers/staging/epl/EplEvent.h
+++ b/drivers/staging/epl/EplEvent.h
@@ -66,7 +66,6 @@
 
   2006/06/12 d.k.:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #ifndef _EPL_EVENT_H_
@@ -82,222 +81,199 @@
 // name and size of event queues
 #define EPL_EVENT_NAME_SHB_KERNEL_TO_USER   "ShbKernelToUser"
 #ifndef EPL_EVENT_SIZE_SHB_KERNEL_TO_USER
-#define EPL_EVENT_SIZE_SHB_KERNEL_TO_USER   32768   // 32 kByte
+#define EPL_EVENT_SIZE_SHB_KERNEL_TO_USER   32768	// 32 kByte
 #endif
 
 #define EPL_EVENT_NAME_SHB_USER_TO_KERNEL   "ShbUserToKernel"
 #ifndef EPL_EVENT_SIZE_SHB_USER_TO_KERNEL
-#define EPL_EVENT_SIZE_SHB_USER_TO_KERNEL   32768   // 32 kByte
+#define EPL_EVENT_SIZE_SHB_USER_TO_KERNEL   32768	// 32 kByte
 #endif
 
-
 // max size of event argument
 #ifndef EPL_MAX_EVENT_ARG_SIZE
-#define EPL_MAX_EVENT_ARG_SIZE      256 // because of PDO
+#define EPL_MAX_EVENT_ARG_SIZE      256	// because of PDO
 #endif
 
-#define EPL_DLL_ERR_MN_CRC           0x00000001L  // object 0x1C00
-#define EPL_DLL_ERR_MN_COLLISION     0x00000002L  // object 0x1C01
-#define EPL_DLL_ERR_MN_CYCTIMEEXCEED 0x00000004L  // object 0x1C02
-#define EPL_DLL_ERR_MN_LOSS_LINK     0x00000008L  // object 0x1C03
-#define EPL_DLL_ERR_MN_CN_LATE_PRES  0x00000010L  // objects 0x1C04-0x1C06
-#define EPL_DLL_ERR_MN_CN_LOSS_PRES  0x00000080L  // objects 0x1C07-0x1C09
-#define EPL_DLL_ERR_CN_COLLISION     0x00000400L  // object 0x1C0A
-#define EPL_DLL_ERR_CN_LOSS_SOC      0x00000800L  // object 0x1C0B
-#define EPL_DLL_ERR_CN_LOSS_SOA      0x00001000L  // object 0x1C0C
-#define EPL_DLL_ERR_CN_LOSS_PREQ     0x00002000L  // object 0x1C0D
-#define EPL_DLL_ERR_CN_RECVD_PREQ    0x00004000L  // decrement object 0x1C0D/2
-#define EPL_DLL_ERR_CN_SOC_JITTER    0x00008000L  // object 0x1C0E
-#define EPL_DLL_ERR_CN_CRC           0x00010000L  // object 0x1C0F
-#define EPL_DLL_ERR_CN_LOSS_LINK     0x00020000L  // object 0x1C10
-#define EPL_DLL_ERR_MN_LOSS_STATRES  0x00040000L  // objects 0x1C15-0x1C17 (should be operated by NmtMnu module)
-#define EPL_DLL_ERR_BAD_PHYS_MODE    0x00080000L  // no object
-#define EPL_DLL_ERR_MAC_BUFFER       0x00100000L  // no object (NMT_GT6)
-#define EPL_DLL_ERR_INVALID_FORMAT   0x00200000L  // no object (NMT_GT6)
-#define EPL_DLL_ERR_ADDRESS_CONFLICT 0x00400000L  // no object (remove CN from configuration)
-
+#define EPL_DLL_ERR_MN_CRC           0x00000001L	// object 0x1C00
+#define EPL_DLL_ERR_MN_COLLISION     0x00000002L	// object 0x1C01
+#define EPL_DLL_ERR_MN_CYCTIMEEXCEED 0x00000004L	// object 0x1C02
+#define EPL_DLL_ERR_MN_LOSS_LINK     0x00000008L	// object 0x1C03
+#define EPL_DLL_ERR_MN_CN_LATE_PRES  0x00000010L	// objects 0x1C04-0x1C06
+#define EPL_DLL_ERR_MN_CN_LOSS_PRES  0x00000080L	// objects 0x1C07-0x1C09
+#define EPL_DLL_ERR_CN_COLLISION     0x00000400L	// object 0x1C0A
+#define EPL_DLL_ERR_CN_LOSS_SOC      0x00000800L	// object 0x1C0B
+#define EPL_DLL_ERR_CN_LOSS_SOA      0x00001000L	// object 0x1C0C
+#define EPL_DLL_ERR_CN_LOSS_PREQ     0x00002000L	// object 0x1C0D
+#define EPL_DLL_ERR_CN_RECVD_PREQ    0x00004000L	// decrement object 0x1C0D/2
+#define EPL_DLL_ERR_CN_SOC_JITTER    0x00008000L	// object 0x1C0E
+#define EPL_DLL_ERR_CN_CRC           0x00010000L	// object 0x1C0F
+#define EPL_DLL_ERR_CN_LOSS_LINK     0x00020000L	// object 0x1C10
+#define EPL_DLL_ERR_MN_LOSS_STATRES  0x00040000L	// objects 0x1C15-0x1C17 (should be operated by NmtMnu module)
+#define EPL_DLL_ERR_BAD_PHYS_MODE    0x00080000L	// no object
+#define EPL_DLL_ERR_MAC_BUFFER       0x00100000L	// no object (NMT_GT6)
+#define EPL_DLL_ERR_INVALID_FORMAT   0x00200000L	// no object (NMT_GT6)
+#define EPL_DLL_ERR_ADDRESS_CONFLICT 0x00400000L	// no object (remove CN from configuration)
 
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
 // EventType determines the argument of the event
-typedef enum
-{
-    kEplEventTypeNmtEvent       = 0x01, // NMT event
-                                        // arg is pointer to tEplNmtEvent
-    kEplEventTypePdoRx          = 0x02, // PDO frame received event (PRes/PReq)
-                                        // arg is pointer to tEplFrame
-    kEplEventTypePdoTx          = 0x03, // PDO frame transmitted event (PRes/PReq)
-                                        // arg is pointer to tEplFrameInfo
-    kEplEventTypePdoSoa         = 0x04, // SoA frame received event (isochronous phase completed)
-                                        // arg is pointer to nothing
-    kEplEventTypeSync           = 0x05, // Sync event (e.g. SoC or anticipated SoC)
-                                        // arg is pointer to nothing
-    kEplEventTypeTimer          = 0x06, // Timer event
-                                        // arg is pointer to tEplTimerEventArg
-    kEplEventTypeHeartbeat      = 0x07, // Heartbeat event
-                                        // arg is pointer to tEplHeartbeatEvent
-    kEplEventTypeDllkCreate     = 0x08, // DLL kernel create event
-                                        // arg is pointer to the new tEplNmtState
-    kEplEventTypeDllkDestroy    = 0x09, // DLL kernel destroy event
-                                        // arg is pointer to the old tEplNmtState
-    kEplEventTypeDllkFillTx     = 0x0A, // DLL kernel fill TxBuffer event
-                                        // arg is pointer to tEplDllAsyncReqPriority
-    kEplEventTypeDllkPresReady  = 0x0B, // DLL kernel PRes ready event
-                                        // arg is pointer to nothing
-    kEplEventTypeError          = 0x0C, // Error event for API layer
-                                        // arg is pointer to tEplEventError
-    kEplEventTypeNmtStateChange = 0x0D, // indicate change of NMT-State
-                                        // arg is pointer to tEplEventNmtStateChange
-    kEplEventTypeDllError       = 0x0E, // DLL error event for Error handler
-                                        // arg is pointer to tEplErrorHandlerkEvent
-    kEplEventTypeAsndRx         = 0x0F, // received ASnd frame for DLL user module
-                                        // arg is pointer to tEplFrame
-    kEplEventTypeDllkServFilter = 0x10, // configure ServiceIdFilter
-                                        // arg is pointer to tEplDllCalServiceIdFilter
-    kEplEventTypeDllkIdentity   = 0x11, // configure Identity
-                                        // arg is pointer to tEplDllIdentParam
-    kEplEventTypeDllkConfig     = 0x12, // configure ConfigParam
-                                        // arg is pointer to tEplDllConfigParam
-    kEplEventTypeDllkIssueReq   = 0x13, // issue Ident/Status request
-                                        // arg is pointer to tEplDllCalIssueRequest
-    kEplEventTypeDllkAddNode    = 0x14, // add node to isochronous phase
-                                        // arg is pointer to tEplDllNodeInfo
-    kEplEventTypeDllkDelNode    = 0x15, // remove node from isochronous phase
-                                        // arg is pointer to unsigned int
-    kEplEventTypeDllkSoftDelNode= 0x16, // remove node softly from isochronous phase
-                                        // arg is pointer to unsigned int
-    kEplEventTypeDllkStartReducedCycle = 0x17, // start reduced EPL cycle on MN
-                                        // arg is pointer to nothing
-    kEplEventTypeNmtMnuNmtCmdSent      = 0x18, // NMT command was actually sent
-                                        // arg is pointer to tEplFrame
+typedef enum {
+	kEplEventTypeNmtEvent = 0x01,	// NMT event
+	// arg is pointer to tEplNmtEvent
+	kEplEventTypePdoRx = 0x02,	// PDO frame received event (PRes/PReq)
+	// arg is pointer to tEplFrame
+	kEplEventTypePdoTx = 0x03,	// PDO frame transmitted event (PRes/PReq)
+	// arg is pointer to tEplFrameInfo
+	kEplEventTypePdoSoa = 0x04,	// SoA frame received event (isochronous phase completed)
+	// arg is pointer to nothing
+	kEplEventTypeSync = 0x05,	// Sync event (e.g. SoC or anticipated SoC)
+	// arg is pointer to nothing
+	kEplEventTypeTimer = 0x06,	// Timer event
+	// arg is pointer to tEplTimerEventArg
+	kEplEventTypeHeartbeat = 0x07,	// Heartbeat event
+	// arg is pointer to tEplHeartbeatEvent
+	kEplEventTypeDllkCreate = 0x08,	// DLL kernel create event
+	// arg is pointer to the new tEplNmtState
+	kEplEventTypeDllkDestroy = 0x09,	// DLL kernel destroy event
+	// arg is pointer to the old tEplNmtState
+	kEplEventTypeDllkFillTx = 0x0A,	// DLL kernel fill TxBuffer event
+	// arg is pointer to tEplDllAsyncReqPriority
+	kEplEventTypeDllkPresReady = 0x0B,	// DLL kernel PRes ready event
+	// arg is pointer to nothing
+	kEplEventTypeError = 0x0C,	// Error event for API layer
+	// arg is pointer to tEplEventError
+	kEplEventTypeNmtStateChange = 0x0D,	// indicate change of NMT-State
+	// arg is pointer to tEplEventNmtStateChange
+	kEplEventTypeDllError = 0x0E,	// DLL error event for Error handler
+	// arg is pointer to tEplErrorHandlerkEvent
+	kEplEventTypeAsndRx = 0x0F,	// received ASnd frame for DLL user module
+	// arg is pointer to tEplFrame
+	kEplEventTypeDllkServFilter = 0x10,	// configure ServiceIdFilter
+	// arg is pointer to tEplDllCalServiceIdFilter
+	kEplEventTypeDllkIdentity = 0x11,	// configure Identity
+	// arg is pointer to tEplDllIdentParam
+	kEplEventTypeDllkConfig = 0x12,	// configure ConfigParam
+	// arg is pointer to tEplDllConfigParam
+	kEplEventTypeDllkIssueReq = 0x13,	// issue Ident/Status request
+	// arg is pointer to tEplDllCalIssueRequest
+	kEplEventTypeDllkAddNode = 0x14,	// add node to isochronous phase
+	// arg is pointer to tEplDllNodeInfo
+	kEplEventTypeDllkDelNode = 0x15,	// remove node from isochronous phase
+	// arg is pointer to unsigned int
+	kEplEventTypeDllkSoftDelNode = 0x16,	// remove node softly from isochronous phase
+	// arg is pointer to unsigned int
+	kEplEventTypeDllkStartReducedCycle = 0x17,	// start reduced EPL cycle on MN
+	// arg is pointer to nothing
+	kEplEventTypeNmtMnuNmtCmdSent = 0x18,	// NMT command was actually sent
+	// arg is pointer to tEplFrame
 
 } tEplEventType;
 
-
 // EventSink determines the consumer of the event
-typedef enum
-{
-    kEplEventSinkSync           = 0x00, // Sync event for application or kernel EPL module
-    kEplEventSinkNmtk           = 0x01, // events for Nmtk module
-    kEplEventSinkDllk           = 0x02, // events for Dllk module
-    kEplEventSinkDlluCal        = 0x03, // events for DlluCal module
-    kEplEventSinkDllkCal        = 0x04, // events for DllkCal module
-    kEplEventSinkPdok           = 0x05, // events for Pdok module
-    kEplEventSinkNmtu           = 0x06, // events for Nmtu module
-    kEplEventSinkErrk           = 0x07, // events for Error handler module
-    kEplEventSinkErru           = 0x08, // events for Error signaling module
-    kEplEventSinkSdoAsySeq      = 0x09, // events for asyncronous SDO Sequence Layer module
-    kEplEventSinkNmtMnu         = 0x0A, // events for NmtMnu module
-    kEplEventSinkLedu           = 0x0B, // events for Ledu module
-    kEplEventSinkApi            = 0x0F, // events for API module
+typedef enum {
+	kEplEventSinkSync = 0x00,	// Sync event for application or kernel EPL module
+	kEplEventSinkNmtk = 0x01,	// events for Nmtk module
+	kEplEventSinkDllk = 0x02,	// events for Dllk module
+	kEplEventSinkDlluCal = 0x03,	// events for DlluCal module
+	kEplEventSinkDllkCal = 0x04,	// events for DllkCal module
+	kEplEventSinkPdok = 0x05,	// events for Pdok module
+	kEplEventSinkNmtu = 0x06,	// events for Nmtu module
+	kEplEventSinkErrk = 0x07,	// events for Error handler module
+	kEplEventSinkErru = 0x08,	// events for Error signaling module
+	kEplEventSinkSdoAsySeq = 0x09,	// events for asyncronous SDO Sequence Layer module
+	kEplEventSinkNmtMnu = 0x0A,	// events for NmtMnu module
+	kEplEventSinkLedu = 0x0B,	// events for Ledu module
+	kEplEventSinkApi = 0x0F,	// events for API module
 
 } tEplEventSink;
 
-
 // EventSource determines the source of an errorevent
-typedef enum
-{
-    // kernelspace modules
-    kEplEventSourceDllk         = 0x01, // Dllk module
-    kEplEventSourceNmtk         = 0x02, // Nmtk module
-    kEplEventSourceObdk         = 0x03, // Obdk module
-    kEplEventSourcePdok         = 0x04, // Pdok module
-    kEplEventSourceTimerk       = 0x05, // Timerk module
-    kEplEventSourceEventk       = 0x06, // Eventk module
-    kEplEventSourceSyncCb       = 0x07, // sync-Cb
-    kEplEventSourceErrk         = 0x08, // Error handler module
-
-    // userspace modules
-    kEplEventSourceDllu         = 0x10, // Dllu module
-    kEplEventSourceNmtu         = 0x11, // Nmtu module
-    kEplEventSourceNmtCnu       = 0x12, // NmtCnu module
-    kEplEventSourceNmtMnu       = 0x13, // NmtMnu module
-    kEplEventSourceObdu         = 0x14, // Obdu module
-    kEplEventSourceSdoUdp       = 0x15, // Sdo/Udp module
-    kEplEventSourceSdoAsnd      = 0x16, // Sdo/Asnd module
-    kEplEventSourceSdoAsySeq    = 0x17, // Sdo asynchronus Sequence Layer module
-    kEplEventSourceSdoCom       = 0x18, // Sdo command layer module
-    kEplEventSourceTimeru       = 0x19, // Timeru module
-    kEplEventSourceCfgMau       = 0x1A, // CfgMau module
-    kEplEventSourceEventu       = 0x1B, // Eventu module
-    kEplEventSourceEplApi       = 0x1C, // Api module
-    kEplEventSourceLedu         = 0x1D, // Ledu module
+typedef enum {
+	// kernelspace modules
+	kEplEventSourceDllk = 0x01,	// Dllk module
+	kEplEventSourceNmtk = 0x02,	// Nmtk module
+	kEplEventSourceObdk = 0x03,	// Obdk module
+	kEplEventSourcePdok = 0x04,	// Pdok module
+	kEplEventSourceTimerk = 0x05,	// Timerk module
+	kEplEventSourceEventk = 0x06,	// Eventk module
+	kEplEventSourceSyncCb = 0x07,	// sync-Cb
+	kEplEventSourceErrk = 0x08,	// Error handler module
+
+	// userspace modules
+	kEplEventSourceDllu = 0x10,	// Dllu module
+	kEplEventSourceNmtu = 0x11,	// Nmtu module
+	kEplEventSourceNmtCnu = 0x12,	// NmtCnu module
+	kEplEventSourceNmtMnu = 0x13,	// NmtMnu module
+	kEplEventSourceObdu = 0x14,	// Obdu module
+	kEplEventSourceSdoUdp = 0x15,	// Sdo/Udp module
+	kEplEventSourceSdoAsnd = 0x16,	// Sdo/Asnd module
+	kEplEventSourceSdoAsySeq = 0x17,	// Sdo asynchronus Sequence Layer module
+	kEplEventSourceSdoCom = 0x18,	// Sdo command layer module
+	kEplEventSourceTimeru = 0x19,	// Timeru module
+	kEplEventSourceCfgMau = 0x1A,	// CfgMau module
+	kEplEventSourceEventu = 0x1B,	// Eventu module
+	kEplEventSourceEplApi = 0x1C,	// Api module
+	kEplEventSourceLedu = 0x1D,	// Ledu module
 
 } tEplEventSource;
 
-
 // structure of EPL event (element order must not be changed!)
-typedef struct
-{
-    tEplEventType     m_EventType /*:28*/; // event type
-    tEplEventSink     m_EventSink /*:4*/;  // event sink
-    tEplNetTime       m_NetTime;       // timestamp
-    unsigned int      m_uiSize;        // size of argument
-    void            * m_pArg;          // argument of event
+typedef struct {
+	tEplEventType m_EventType /*:28 */ ;	// event type
+	tEplEventSink m_EventSink /*:4 */ ;	// event sink
+	tEplNetTime m_NetTime;	// timestamp
+	unsigned int m_uiSize;	// size of argument
+	void *m_pArg;		// argument of event
 
 } tEplEvent;
 
-
 // short structure of EPL event without argument and its size (element order must not be changed!)
-typedef struct
-{
-    tEplEventType     m_EventType /*:28*/; // event type
-    tEplEventSink     m_EventSink /*:4*/;  // event sink
-    tEplNetTime       m_NetTime;       // timestamp
+typedef struct {
+	tEplEventType m_EventType /*:28 */ ;	// event type
+	tEplEventSink m_EventSink /*:4 */ ;	// event sink
+	tEplNetTime m_NetTime;	// timestamp
 
 } tEplEventShort;
 
-
-typedef struct
-{
-    unsigned int    m_uiIndex;
-    unsigned int    m_uiSubIndex;
+typedef struct {
+	unsigned int m_uiIndex;
+	unsigned int m_uiSubIndex;
 
 } tEplEventObdError;
 
-
 // structure for kEplEventTypeError
-typedef struct
-{
-    tEplEventSource m_EventSource;              // module which posted this error event
-    tEplKernel      m_EplError;                 // EPL error which occured
-    union
-    {
-        BYTE                    m_bArg;
-        DWORD                   m_dwArg;
-        tEplEventSource         m_EventSource;  // from Eventk/u module (originating error source)
-        tEplEventObdError       m_ObdError;     // from Obd module
+typedef struct {
+	tEplEventSource m_EventSource;	// module which posted this error event
+	tEplKernel m_EplError;	// EPL error which occured
+	union {
+		BYTE m_bArg;
+		DWORD m_dwArg;
+		tEplEventSource m_EventSource;	// from Eventk/u module (originating error source)
+		tEplEventObdError m_ObdError;	// from Obd module
 //        tEplErrHistoryEntry     m_HistoryEntry; // from Nmtk/u module
 
-    } m_Arg;
+	} m_Arg;
 
 } tEplEventError;
 
-
 // structure for kEplEventTypeDllError
-typedef struct
-{
-    unsigned long   m_ulDllErrorEvents;   // EPL_DLL_ERR_*
-    unsigned int    m_uiNodeId;
-    tEplNmtState    m_NmtState;
+typedef struct {
+	unsigned long m_ulDllErrorEvents;	// EPL_DLL_ERR_*
+	unsigned int m_uiNodeId;
+	tEplNmtState m_NmtState;
 
 } tEplErrorHandlerkEvent;
 
-
 // callback function to get informed about sync event
-typedef tEplKernel (PUBLIC* tEplSyncCb) (void);
+typedef tEplKernel(PUBLIC * tEplSyncCb) (void);
 
 // callback function for generic events
-typedef tEplKernel (PUBLIC* tEplProcessEventCb) (tEplEvent* pEplEvent_p);
+typedef tEplKernel(PUBLIC * tEplProcessEventCb) (tEplEvent * pEplEvent_p);
 
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-
-#endif  // #ifndef _EPL_EVENT_H_
-
-
+#endif // #ifndef _EPL_EVENT_H_
--- a/drivers/staging/epl/EplFrame.h
+++ b/drivers/staging/epl/EplFrame.h
@@ -66,30 +66,27 @@
 
   2006/05/22 d.k.:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #ifndef _EPL_FRAME_H_
 #define _EPL_FRAME_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
 
-
 // defines for EplFrame.m_wFlag
-#define EPL_FRAME_FLAG1_RD          0x01    // ready                                    (PReq, PRes)
-#define EPL_FRAME_FLAG1_ER          0x02    // exception reset (error signalling)       (SoA)
-#define EPL_FRAME_FLAG1_EA          0x04    // exception acknowledge (error signalling) (PReq, SoA)
-#define EPL_FRAME_FLAG1_EC          0x08    // exception clear (error signalling)       (StatusRes)
-#define EPL_FRAME_FLAG1_EN          0x10    // exception new (error signalling)         (PRes, StatusRes)
-#define EPL_FRAME_FLAG1_MS          0x20    // multiplexed slot                         (PReq)
-#define EPL_FRAME_FLAG1_PS          0x40    // prescaled slot                           (SoC)
-#define EPL_FRAME_FLAG1_MC          0x80    // multiplexed cycle completed              (SoC)
-#define EPL_FRAME_FLAG2_RS          0x07    // number of pending requests to send       (PRes, StatusRes, IdentRes)
-#define EPL_FRAME_FLAG2_PR          0x38    // priority of requested asynch. frame      (PRes, StatusRes, IdentRes)
-#define EPL_FRAME_FLAG2_PR_SHIFT    3       // shift of priority of requested asynch. frame
+#define EPL_FRAME_FLAG1_RD          0x01	// ready                                    (PReq, PRes)
+#define EPL_FRAME_FLAG1_ER          0x02	// exception reset (error signalling)       (SoA)
+#define EPL_FRAME_FLAG1_EA          0x04	// exception acknowledge (error signalling) (PReq, SoA)
+#define EPL_FRAME_FLAG1_EC          0x08	// exception clear (error signalling)       (StatusRes)
+#define EPL_FRAME_FLAG1_EN          0x10	// exception new (error signalling)         (PRes, StatusRes)
+#define EPL_FRAME_FLAG1_MS          0x20	// multiplexed slot                         (PReq)
+#define EPL_FRAME_FLAG1_PS          0x40	// prescaled slot                           (SoC)
+#define EPL_FRAME_FLAG1_MC          0x80	// multiplexed cycle completed              (SoC)
+#define EPL_FRAME_FLAG2_RS          0x07	// number of pending requests to send       (PRes, StatusRes, IdentRes)
+#define EPL_FRAME_FLAG2_PR          0x38	// priority of requested asynch. frame      (PRes, StatusRes, IdentRes)
+#define EPL_FRAME_FLAG2_PR_SHIFT    3	// shift of priority of requested asynch. frame
 
 // error history/status entry types
 #define EPL_ERR_ENTRYTYPE_STATUS        0x8000
@@ -104,15 +101,13 @@
 #define EPL_ERR_ENTRYTYPE_PROF_MASK     0x0FFF
 
 // defines for EPL version / PDO version
-#define EPL_VERSION_SUB             0x0F  // sub version
-#define EPL_VERSION_MAIN            0xF0  // main version
-
+#define EPL_VERSION_SUB             0x0F	// sub version
+#define EPL_VERSION_MAIN            0xF0	// main version
 
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
-
 // $$$ d.k.: move this definition to global.h
 // byte-align structures
 #ifdef _MSC_VER
@@ -125,223 +120,205 @@
 #    error you must byte-align these structures with the appropriate compiler directives
 #endif
 
-
-typedef struct
-{
-    // Offset 17
-    BYTE                    m_le_bRes1;                     // reserved
-    // Offset 18
-    BYTE                    m_le_bFlag1;                    // Flags: MC, PS
-    // Offset 19
-    BYTE                    m_le_bFlag2;                    // Flags: res
-    // Offset 20
-    tEplNetTime             m_le_NetTime;                   // supported if D_NMT_NetTimeIsRealTime_BOOL is set
-    // Offset 28
-    QWORD                   m_le_RelativeTime;              // in us (supported if D_NMT_RelativeTime_BOOL is set)
+typedef struct {
+	// Offset 17
+	BYTE m_le_bRes1;	// reserved
+	// Offset 18
+	BYTE m_le_bFlag1;	// Flags: MC, PS
+	// Offset 19
+	BYTE m_le_bFlag2;	// Flags: res
+	// Offset 20
+	tEplNetTime m_le_NetTime;	// supported if D_NMT_NetTimeIsRealTime_BOOL is set
+	// Offset 28
+	QWORD m_le_RelativeTime;	// in us (supported if D_NMT_RelativeTime_BOOL is set)
 
 } PACK_STRUCT tEplSocFrame;
 
-typedef struct
-{
-    // Offset 17
-    BYTE                    m_le_bRes1;                     // reserved
-    // Offset 18
-    BYTE                    m_le_bFlag1;                    // Flags: MS, EA, RD
-    // Offset 19
-    BYTE                    m_le_bFlag2;                    // Flags: res
-    // Offset 20
-    BYTE                    m_le_bPdoVersion;
-    // Offset 21
-    BYTE                    m_le_bRes2;                     // reserved
-    // Offset 22
-    WORD                    m_le_wSize;
-    // Offset 24
-    BYTE                    m_le_abPayload[256 /*D_NMT_IsochrRxMaxPayload_U16*/];
+typedef struct {
+	// Offset 17
+	BYTE m_le_bRes1;	// reserved
+	// Offset 18
+	BYTE m_le_bFlag1;	// Flags: MS, EA, RD
+	// Offset 19
+	BYTE m_le_bFlag2;	// Flags: res
+	// Offset 20
+	BYTE m_le_bPdoVersion;
+	// Offset 21
+	BYTE m_le_bRes2;	// reserved
+	// Offset 22
+	WORD m_le_wSize;
+	// Offset 24
+	BYTE m_le_abPayload[256 /*D_NMT_IsochrRxMaxPayload_U16 */ ];
 
 } PACK_STRUCT tEplPreqFrame;
 
-typedef struct
-{
-    // Offset 17
-    BYTE                    m_le_bNmtStatus;                // NMT state
-    // Offset 18
-    BYTE                    m_le_bFlag1;                    // Flags: MS, EN, RD
-    // Offset 19
-    BYTE                    m_le_bFlag2;                    // Flags: PR, RS
-    // Offset 20
-    BYTE                    m_le_bPdoVersion;
-    // Offset 21
-    BYTE                    m_le_bRes2;                     // reserved
-    // Offset 22
-    WORD                    m_le_wSize;
-    // Offset 24
-    BYTE                    m_le_abPayload[256 /*D_NMT_IsochrRxMaxPayload_U16
-                                        / D_NMT_IsochrTxMaxPayload_U16*/];
+typedef struct {
+	// Offset 17
+	BYTE m_le_bNmtStatus;	// NMT state
+	// Offset 18
+	BYTE m_le_bFlag1;	// Flags: MS, EN, RD
+	// Offset 19
+	BYTE m_le_bFlag2;	// Flags: PR, RS
+	// Offset 20
+	BYTE m_le_bPdoVersion;
+	// Offset 21
+	BYTE m_le_bRes2;	// reserved
+	// Offset 22
+	WORD m_le_wSize;
+	// Offset 24
+	BYTE m_le_abPayload[256	/*D_NMT_IsochrRxMaxPayload_U16
+				   / D_NMT_IsochrTxMaxPayload_U16 */ ];
 
 } PACK_STRUCT tEplPresFrame;
 
-typedef struct
-{
-    // Offset 17
-    BYTE                    m_le_bNmtStatus;                // NMT state
-    // Offset 18
-    BYTE                    m_le_bFlag1;                    // Flags: EA, ER
-    // Offset 19
-    BYTE                    m_le_bFlag2;                    // Flags: res
-    // Offset 20
-    BYTE                    m_le_bReqServiceId;
-    // Offset 21
-    BYTE                    m_le_bReqServiceTarget;
-    // Offset 22
-    BYTE                    m_le_bEplVersion;
+typedef struct {
+	// Offset 17
+	BYTE m_le_bNmtStatus;	// NMT state
+	// Offset 18
+	BYTE m_le_bFlag1;	// Flags: EA, ER
+	// Offset 19
+	BYTE m_le_bFlag2;	// Flags: res
+	// Offset 20
+	BYTE m_le_bReqServiceId;
+	// Offset 21
+	BYTE m_le_bReqServiceTarget;
+	// Offset 22
+	BYTE m_le_bEplVersion;
 
 } PACK_STRUCT tEplSoaFrame;
 
-typedef struct
-{
-    WORD            m_wEntryType;
-    WORD            m_wErrorCode;
-    tEplNetTime     m_TimeStamp;
-    BYTE            m_abAddInfo[8];
+typedef struct {
+	WORD m_wEntryType;
+	WORD m_wErrorCode;
+	tEplNetTime m_TimeStamp;
+	BYTE m_abAddInfo[8];
 
 } PACK_STRUCT tEplErrHistoryEntry;
 
-typedef struct
-{
-    // Offset 18
-    BYTE                    m_le_bFlag1;                    // Flags: EN, EC
-    BYTE                    m_le_bFlag2;                    // Flags: PR, RS
-    BYTE                    m_le_bNmtStatus;                // NMT state
-    BYTE                    m_le_bRes1[3];
-    QWORD                   m_le_qwStaticError;             // static error bit field
-    tEplErrHistoryEntry     m_le_aErrHistoryEntry[14];
+typedef struct {
+	// Offset 18
+	BYTE m_le_bFlag1;	// Flags: EN, EC
+	BYTE m_le_bFlag2;	// Flags: PR, RS
+	BYTE m_le_bNmtStatus;	// NMT state
+	BYTE m_le_bRes1[3];
+	QWORD m_le_qwStaticError;	// static error bit field
+	tEplErrHistoryEntry m_le_aErrHistoryEntry[14];
 
 } PACK_STRUCT tEplStatusResponse;
 
-typedef struct
-{
-    // Offset 18
-    BYTE                    m_le_bFlag1;                    // Flags: res
-    BYTE                    m_le_bFlag2;                    // Flags: PR, RS
-    BYTE                    m_le_bNmtStatus;                // NMT state
-    BYTE                    m_le_bIdentRespFlags;           // Flags: FW
-    BYTE                    m_le_bEplProfileVersion;
-    BYTE                    m_le_bRes1;
-    DWORD                   m_le_dwFeatureFlags;            // NMT_FeatureFlags_U32
-    WORD                    m_le_wMtu;                      // NMT_CycleTiming_REC.AsyncMTU_U16: C_IP_MIN_MTU - C_IP_MAX_MTU
-    WORD                    m_le_wPollInSize;               // NMT_CycleTiming_REC.PReqActPayload_U16
-    WORD                    m_le_wPollOutSize;              // NMT_CycleTiming_REC.PResActPayload_U16
-    DWORD                   m_le_dwResponseTime;            // NMT_CycleTiming_REC.PResMaxLatency_U32
-    WORD                    m_le_wRes2;
-    DWORD                   m_le_dwDeviceType;              // NMT_DeviceType_U32
-    DWORD                   m_le_dwVendorId;                // NMT_IdentityObject_REC.VendorId_U32
-    DWORD                   m_le_dwProductCode;             // NMT_IdentityObject_REC.ProductCode_U32
-    DWORD                   m_le_dwRevisionNumber;          // NMT_IdentityObject_REC.RevisionNo_U32
-    DWORD                   m_le_dwSerialNumber;            // NMT_IdentityObject_REC.SerialNo_U32
-    QWORD                   m_le_qwVendorSpecificExt1;
-    DWORD                   m_le_dwVerifyConfigurationDate; // CFM_VerifyConfiguration_REC.ConfDate_U32
-    DWORD                   m_le_dwVerifyConfigurationTime; // CFM_VerifyConfiguration_REC.ConfTime_U32
-    DWORD                   m_le_dwApplicationSwDate;       // PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
-    DWORD                   m_le_dwApplicationSwTime;       // PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
-    DWORD                   m_le_dwIpAddress;
-    DWORD                   m_le_dwSubnetMask;
-    DWORD                   m_le_dwDefaultGateway;
-    BYTE                    m_le_sHostname[32];
-    BYTE                    m_le_abVendorSpecificExt2[48];
+typedef struct {
+	// Offset 18
+	BYTE m_le_bFlag1;	// Flags: res
+	BYTE m_le_bFlag2;	// Flags: PR, RS
+	BYTE m_le_bNmtStatus;	// NMT state
+	BYTE m_le_bIdentRespFlags;	// Flags: FW
+	BYTE m_le_bEplProfileVersion;
+	BYTE m_le_bRes1;
+	DWORD m_le_dwFeatureFlags;	// NMT_FeatureFlags_U32
+	WORD m_le_wMtu;		// NMT_CycleTiming_REC.AsyncMTU_U16: C_IP_MIN_MTU - C_IP_MAX_MTU
+	WORD m_le_wPollInSize;	// NMT_CycleTiming_REC.PReqActPayload_U16
+	WORD m_le_wPollOutSize;	// NMT_CycleTiming_REC.PResActPayload_U16
+	DWORD m_le_dwResponseTime;	// NMT_CycleTiming_REC.PResMaxLatency_U32
+	WORD m_le_wRes2;
+	DWORD m_le_dwDeviceType;	// NMT_DeviceType_U32
+	DWORD m_le_dwVendorId;	// NMT_IdentityObject_REC.VendorId_U32
+	DWORD m_le_dwProductCode;	// NMT_IdentityObject_REC.ProductCode_U32
+	DWORD m_le_dwRevisionNumber;	// NMT_IdentityObject_REC.RevisionNo_U32
+	DWORD m_le_dwSerialNumber;	// NMT_IdentityObject_REC.SerialNo_U32
+	QWORD m_le_qwVendorSpecificExt1;
+	DWORD m_le_dwVerifyConfigurationDate;	// CFM_VerifyConfiguration_REC.ConfDate_U32
+	DWORD m_le_dwVerifyConfigurationTime;	// CFM_VerifyConfiguration_REC.ConfTime_U32
+	DWORD m_le_dwApplicationSwDate;	// PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
+	DWORD m_le_dwApplicationSwTime;	// PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
+	DWORD m_le_dwIpAddress;
+	DWORD m_le_dwSubnetMask;
+	DWORD m_le_dwDefaultGateway;
+	BYTE m_le_sHostname[32];
+	BYTE m_le_abVendorSpecificExt2[48];
 
 } PACK_STRUCT tEplIdentResponse;
 
-typedef struct
-{
-    // Offset 18
-    BYTE                    m_le_bNmtCommandId;
-    BYTE                    m_le_bRes1;
-    BYTE                    m_le_abNmtCommandData[32];
+typedef struct {
+	// Offset 18
+	BYTE m_le_bNmtCommandId;
+	BYTE m_le_bRes1;
+	BYTE m_le_abNmtCommandData[32];
 
 } PACK_STRUCT tEplNmtCommandService;
 
-typedef struct
-{
-    BYTE                    m_le_bReserved;
-    BYTE                    m_le_bTransactionId;
-    BYTE                    m_le_bFlags;
-    BYTE                    m_le_bCommandId;
-    WORD                    m_le_wSegmentSize;
-    WORD                    m_le_wReserved;
-    BYTE                    m_le_abCommandData[8];  // just reserve a minimum number of bytes as a placeholder
-
-}PACK_STRUCT tEplAsySdoCom;
+typedef struct {
+	BYTE m_le_bReserved;
+	BYTE m_le_bTransactionId;
+	BYTE m_le_bFlags;
+	BYTE m_le_bCommandId;
+	WORD m_le_wSegmentSize;
+	WORD m_le_wReserved;
+	BYTE m_le_abCommandData[8];	// just reserve a minimum number of bytes as a placeholder
 
+} PACK_STRUCT tEplAsySdoCom;
 
 // asynchronous SDO Sequence Header
-typedef struct
-{
-    BYTE           m_le_bRecSeqNumCon;
-    BYTE           m_le_bSendSeqNumCon;
-    BYTE           m_le_abReserved[2];
-    tEplAsySdoCom  m_le_abSdoSeqPayload;
+typedef struct {
+	BYTE m_le_bRecSeqNumCon;
+	BYTE m_le_bSendSeqNumCon;
+	BYTE m_le_abReserved[2];
+	tEplAsySdoCom m_le_abSdoSeqPayload;
 
 } PACK_STRUCT tEplAsySdoSeq;
 
-typedef struct
-{
-    // Offset 18
-    BYTE                    m_le_bNmtCommandId;
-    BYTE                    m_le_bTargetNodeId;
-    BYTE                    m_le_abNmtCommandData[32];
+typedef struct {
+	// Offset 18
+	BYTE m_le_bNmtCommandId;
+	BYTE m_le_bTargetNodeId;
+	BYTE m_le_abNmtCommandData[32];
 
 } PACK_STRUCT tEplNmtRequestService;
 
-
-typedef union
-{
-    // Offset 18
-    tEplStatusResponse      m_StatusResponse;
-    tEplIdentResponse       m_IdentResponse;
-    tEplNmtCommandService   m_NmtCommandService;
-    tEplNmtRequestService   m_NmtRequestService;
-    tEplAsySdoSeq           m_SdoSequenceFrame;
-    BYTE                    m_le_abPayload[256 /*D_NMT_ASndTxMaxPayload_U16
-                                        / D_NMT_ASndRxMaxPayload_U16*/];
+typedef union {
+	// Offset 18
+	tEplStatusResponse m_StatusResponse;
+	tEplIdentResponse m_IdentResponse;
+	tEplNmtCommandService m_NmtCommandService;
+	tEplNmtRequestService m_NmtRequestService;
+	tEplAsySdoSeq m_SdoSequenceFrame;
+	BYTE m_le_abPayload[256	/*D_NMT_ASndTxMaxPayload_U16
+				   / D_NMT_ASndRxMaxPayload_U16 */ ];
 
 } tEplAsndPayload;
 
-typedef struct
-{
-    // Offset 17
-    BYTE                    m_le_bServiceId;
-    // Offset 18
-    tEplAsndPayload         m_Payload;
+typedef struct {
+	// Offset 17
+	BYTE m_le_bServiceId;
+	// Offset 18
+	tEplAsndPayload m_Payload;
 
 } PACK_STRUCT tEplAsndFrame;
 
-typedef union
-{
-    // Offset 17
-    tEplSocFrame            m_Soc;
-    tEplPreqFrame           m_Preq;
-    tEplPresFrame           m_Pres;
-    tEplSoaFrame            m_Soa;
-    tEplAsndFrame           m_Asnd;
+typedef union {
+	// Offset 17
+	tEplSocFrame m_Soc;
+	tEplPreqFrame m_Preq;
+	tEplPresFrame m_Pres;
+	tEplSoaFrame m_Soa;
+	tEplAsndFrame m_Asnd;
 
 } tEplFrameData;
 
-typedef struct
-{
-    // Offset 0
-    BYTE                    m_be_abDstMac[6];               // MAC address of the addressed nodes
-    // Offset 6
-    BYTE                    m_be_abSrcMac[6];               // MAC address of the transmitting node
-    // Offset 12
-    WORD                    m_be_wEtherType;                // Ethernet message type (big endian)
-    // Offset 14
-    BYTE                    m_le_bMessageType;              // EPL message type
-    // Offset 15
-    BYTE                    m_le_bDstNodeId;                // EPL node ID of the addressed nodes
-    // Offset 16
-    BYTE                    m_le_bSrcNodeId;                // EPL node ID of the transmitting node
-    // Offset 17
-    tEplFrameData           m_Data;
+typedef struct {
+	// Offset 0
+	BYTE m_be_abDstMac[6];	// MAC address of the addressed nodes
+	// Offset 6
+	BYTE m_be_abSrcMac[6];	// MAC address of the transmitting node
+	// Offset 12
+	WORD m_be_wEtherType;	// Ethernet message type (big endian)
+	// Offset 14
+	BYTE m_le_bMessageType;	// EPL message type
+	// Offset 15
+	BYTE m_le_bDstNodeId;	// EPL node ID of the addressed nodes
+	// Offset 16
+	BYTE m_le_bSrcNodeId;	// EPL node ID of the transmitting node
+	// Offset 17
+	tEplFrameData m_Data;
 
 } PACK_STRUCT tEplFrame;
 
@@ -350,25 +327,18 @@ typedef struct
 #    pragma pack( pop, packing )
 #endif
 
-
-typedef enum
-{
-    kEplMsgTypeNonEpl = 0x00,
-    kEplMsgTypeSoc    = 0x01,
-    kEplMsgTypePreq   = 0x03,
-    kEplMsgTypePres   = 0x04,
-    kEplMsgTypeSoa    = 0x05,
-    kEplMsgTypeAsnd   = 0x06,
+typedef enum {
+	kEplMsgTypeNonEpl = 0x00,
+	kEplMsgTypeSoc = 0x01,
+	kEplMsgTypePreq = 0x03,
+	kEplMsgTypePres = 0x04,
+	kEplMsgTypeSoa = 0x05,
+	kEplMsgTypeAsnd = 0x06,
 
 } tEplMsgType;
 
-
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-#endif  // #ifndef _EPL_FRAME_H_
-
-
+#endif // #ifndef _EPL_FRAME_H_
--- a/drivers/staging/epl/Epl.h
+++ b/drivers/staging/epl/Epl.h
@@ -66,7 +66,6 @@
 
   2006/05/22 d.k.:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #ifndef _EPL_API_H_
@@ -82,223 +81,193 @@
 // const defines
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
-
-typedef struct
-{
-    unsigned int        m_uiNodeId;
-    tEplNmtState        m_NmtState;
-    tEplNmtNodeEvent    m_NodeEvent;
-    WORD                m_wErrorCode;   // EPL error code if m_NodeEvent == kEplNmtNodeEventError
-    BOOL                m_fMandatory;
+typedef struct {
+	unsigned int m_uiNodeId;
+	tEplNmtState m_NmtState;
+	tEplNmtNodeEvent m_NodeEvent;
+	WORD m_wErrorCode;	// EPL error code if m_NodeEvent == kEplNmtNodeEventError
+	BOOL m_fMandatory;
 
 } tEplApiEventNode;
 
-
-typedef struct
-{
-    tEplNmtState        m_NmtState;     // local NMT state
-    tEplNmtBootEvent    m_BootEvent;
-    WORD                m_wErrorCode;   // EPL error code if m_BootEvent == kEplNmtBootEventError
+typedef struct {
+	tEplNmtState m_NmtState;	// local NMT state
+	tEplNmtBootEvent m_BootEvent;
+	WORD m_wErrorCode;	// EPL error code if m_BootEvent == kEplNmtBootEventError
 
 } tEplApiEventBoot;
 
-
-typedef struct
-{
-    tEplLedType         m_LedType;      // type of the LED (e.g. Status or Error)
-    BOOL                m_fOn;          // state of the LED (e.g. on or off)
+typedef struct {
+	tEplLedType m_LedType;	// type of the LED (e.g. Status or Error)
+	BOOL m_fOn;		// state of the LED (e.g. on or off)
 
 } tEplApiEventLed;
 
-
-typedef enum
-{
-    kEplApiEventNmtStateChange = 0x10,    // m_NmtStateChange
+typedef enum {
+	kEplApiEventNmtStateChange = 0x10,	// m_NmtStateChange
 //    kEplApiEventRequestNmt     = 0x11,    // m_bNmtCmd
-    kEplApiEventCriticalError  = 0x12,    // m_InternalError, Stack halted
-    kEplApiEventWarning        = 0x13,    // m_InternalError, Stack running
-    kEplApiEventNode           = 0x20,    // m_Node
-    kEplApiEventBoot           = 0x21,    // m_Boot
-    kEplApiEventSdo            = 0x62,    // m_Sdo
-    kEplApiEventObdAccess      = 0x69,    // m_ObdCbParam
-    kEplApiEventLed            = 0x70,    // m_Led
+	kEplApiEventCriticalError = 0x12,	// m_InternalError, Stack halted
+	kEplApiEventWarning = 0x13,	// m_InternalError, Stack running
+	kEplApiEventNode = 0x20,	// m_Node
+	kEplApiEventBoot = 0x21,	// m_Boot
+	kEplApiEventSdo = 0x62,	// m_Sdo
+	kEplApiEventObdAccess = 0x69,	// m_ObdCbParam
+	kEplApiEventLed = 0x70,	// m_Led
 
 } tEplApiEventType;
 
-
-typedef union
-{
-    tEplEventNmtStateChange m_NmtStateChange;
-    tEplEventError          m_InternalError;
-    tEplSdoComFinished      m_Sdo;
-    tEplObdCbParam          m_ObdCbParam;
-    tEplApiEventNode        m_Node;
-    tEplApiEventBoot        m_Boot;
-    tEplApiEventLed         m_Led;
+typedef union {
+	tEplEventNmtStateChange m_NmtStateChange;
+	tEplEventError m_InternalError;
+	tEplSdoComFinished m_Sdo;
+	tEplObdCbParam m_ObdCbParam;
+	tEplApiEventNode m_Node;
+	tEplApiEventBoot m_Boot;
+	tEplApiEventLed m_Led;
 
 } tEplApiEventArg;
 
-
-typedef tEplKernel (PUBLIC ROM* tEplApiCbEvent) (
-    tEplApiEventType        EventType_p,   // IN: event type (enum)
-    tEplApiEventArg*        pEventArg_p,   // IN: event argument (union)
-    void GENERIC*           pUserArg_p);
-
-
-typedef struct
-{
-    unsigned int        m_uiSizeOfStruct;
-    BOOL                m_fAsyncOnly;   // do not need to register PRes
-    unsigned int        m_uiNodeId;     // local node ID
-    BYTE                m_abMacAddress[6];  // local MAC address
-
-    // 0x1F82: NMT_FeatureFlags_U32
-    DWORD               m_dwFeatureFlags;
-    // Cycle Length (0x1006: NMT_CycleLen_U32) in [us]
-    DWORD               m_dwCycleLen;     // required for error detection
-    // 0x1F98: NMT_CycleTiming_REC
-    // 0x1F98.1: IsochrTxMaxPayload_U16
-    unsigned int        m_uiIsochrTxMaxPayload; // const
-    // 0x1F98.2: IsochrRxMaxPayload_U16
-    unsigned int        m_uiIsochrRxMaxPayload; // const
-    // 0x1F98.3: PResMaxLatency_U32
-    DWORD               m_dwPresMaxLatency;  // const in [ns], only required for IdentRes
-    // 0x1F98.4: PReqActPayloadLimit_U16
-    unsigned int        m_uiPreqActPayloadLimit; // required for initialisation (+28 bytes)
-    // 0x1F98.5: PResActPayloadLimit_U16
-    unsigned int        m_uiPresActPayloadLimit; // required for initialisation of Pres frame (+28 bytes)
-    // 0x1F98.6: ASndMaxLatency_U32
-    DWORD               m_dwAsndMaxLatency;   // const in [ns], only required for IdentRes
-    // 0x1F98.7: MultiplCycleCnt_U8
-    unsigned int        m_uiMultiplCycleCnt;  // required for error detection
-    // 0x1F98.8: AsyncMTU_U16
-    unsigned int        m_uiAsyncMtu;         // required to set up max frame size
-    // 0x1F98.9: Prescaler_U16
-    unsigned int        m_uiPrescaler;         // required for sync
-    // $$$ Multiplexed Slot
-
-    // 0x1C14: DLL_LossOfFrameTolerance_U32 in [ns]
-    DWORD               m_dwLossOfFrameTolerance;
-
-    // 0x1F8A: NMT_MNCycleTiming_REC
-    // 0x1F8A.1: WaitSoCPReq_U32 in [ns]
-    DWORD               m_dwWaitSocPreq;
-
-    // 0x1F8A.2: AsyncSlotTimeout_U32 in [ns]
-    DWORD               m_dwAsyncSlotTimeout;
-
-    DWORD               m_dwDeviceType;              // NMT_DeviceType_U32
-    DWORD               m_dwVendorId;                // NMT_IdentityObject_REC.VendorId_U32
-    DWORD               m_dwProductCode;             // NMT_IdentityObject_REC.ProductCode_U32
-    DWORD               m_dwRevisionNumber;          // NMT_IdentityObject_REC.RevisionNo_U32
-    DWORD               m_dwSerialNumber;            // NMT_IdentityObject_REC.SerialNo_U32
-    QWORD               m_qwVendorSpecificExt1;
-    DWORD               m_dwVerifyConfigurationDate; // CFM_VerifyConfiguration_REC.ConfDate_U32
-    DWORD               m_dwVerifyConfigurationTime; // CFM_VerifyConfiguration_REC.ConfTime_U32
-    DWORD               m_dwApplicationSwDate;       // PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
-    DWORD               m_dwApplicationSwTime;       // PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
-    DWORD               m_dwIpAddress;
-    DWORD               m_dwSubnetMask;
-    DWORD               m_dwDefaultGateway;
-    BYTE                m_sHostname[32];
-    BYTE                m_abVendorSpecificExt2[48];
-
-    char*               m_pszDevName;       // NMT_ManufactDevName_VS (0x1008/0 local OD)
-    char*               m_pszHwVersion;     // NMT_ManufactHwVers_VS  (0x1009/0 local OD)
-    char*               m_pszSwVersion;     // NMT_ManufactSwVers_VS  (0x100A/0 local OD)
-
-    tEplApiCbEvent      m_pfnCbEvent;
-    void*               m_pEventUserArg;
-    tEplSyncCb          m_pfnCbSync;
+typedef tEplKernel(PUBLIC ROM * tEplApiCbEvent) (tEplApiEventType EventType_p,	// IN: event type (enum)
+						 tEplApiEventArg * pEventArg_p,	// IN: event argument (union)
+						 void GENERIC * pUserArg_p);
+
+typedef struct {
+	unsigned int m_uiSizeOfStruct;
+	BOOL m_fAsyncOnly;	// do not need to register PRes
+	unsigned int m_uiNodeId;	// local node ID
+	BYTE m_abMacAddress[6];	// local MAC address
+
+	// 0x1F82: NMT_FeatureFlags_U32
+	DWORD m_dwFeatureFlags;
+	// Cycle Length (0x1006: NMT_CycleLen_U32) in [us]
+	DWORD m_dwCycleLen;	// required for error detection
+	// 0x1F98: NMT_CycleTiming_REC
+	// 0x1F98.1: IsochrTxMaxPayload_U16
+	unsigned int m_uiIsochrTxMaxPayload;	// const
+	// 0x1F98.2: IsochrRxMaxPayload_U16
+	unsigned int m_uiIsochrRxMaxPayload;	// const
+	// 0x1F98.3: PResMaxLatency_U32
+	DWORD m_dwPresMaxLatency;	// const in [ns], only required for IdentRes
+	// 0x1F98.4: PReqActPayloadLimit_U16
+	unsigned int m_uiPreqActPayloadLimit;	// required for initialisation (+28 bytes)
+	// 0x1F98.5: PResActPayloadLimit_U16
+	unsigned int m_uiPresActPayloadLimit;	// required for initialisation of Pres frame (+28 bytes)
+	// 0x1F98.6: ASndMaxLatency_U32
+	DWORD m_dwAsndMaxLatency;	// const in [ns], only required for IdentRes
+	// 0x1F98.7: MultiplCycleCnt_U8
+	unsigned int m_uiMultiplCycleCnt;	// required for error detection
+	// 0x1F98.8: AsyncMTU_U16
+	unsigned int m_uiAsyncMtu;	// required to set up max frame size
+	// 0x1F98.9: Prescaler_U16
+	unsigned int m_uiPrescaler;	// required for sync
+	// $$$ Multiplexed Slot
+
+	// 0x1C14: DLL_LossOfFrameTolerance_U32 in [ns]
+	DWORD m_dwLossOfFrameTolerance;
+
+	// 0x1F8A: NMT_MNCycleTiming_REC
+	// 0x1F8A.1: WaitSoCPReq_U32 in [ns]
+	DWORD m_dwWaitSocPreq;
+
+	// 0x1F8A.2: AsyncSlotTimeout_U32 in [ns]
+	DWORD m_dwAsyncSlotTimeout;
+
+	DWORD m_dwDeviceType;	// NMT_DeviceType_U32
+	DWORD m_dwVendorId;	// NMT_IdentityObject_REC.VendorId_U32
+	DWORD m_dwProductCode;	// NMT_IdentityObject_REC.ProductCode_U32
+	DWORD m_dwRevisionNumber;	// NMT_IdentityObject_REC.RevisionNo_U32
+	DWORD m_dwSerialNumber;	// NMT_IdentityObject_REC.SerialNo_U32
+	QWORD m_qwVendorSpecificExt1;
+	DWORD m_dwVerifyConfigurationDate;	// CFM_VerifyConfiguration_REC.ConfDate_U32
+	DWORD m_dwVerifyConfigurationTime;	// CFM_VerifyConfiguration_REC.ConfTime_U32
+	DWORD m_dwApplicationSwDate;	// PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
+	DWORD m_dwApplicationSwTime;	// PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
+	DWORD m_dwIpAddress;
+	DWORD m_dwSubnetMask;
+	DWORD m_dwDefaultGateway;
+	BYTE m_sHostname[32];
+	BYTE m_abVendorSpecificExt2[48];
+
+	char *m_pszDevName;	// NMT_ManufactDevName_VS (0x1008/0 local OD)
+	char *m_pszHwVersion;	// NMT_ManufactHwVers_VS  (0x1009/0 local OD)
+	char *m_pszSwVersion;	// NMT_ManufactSwVers_VS  (0x100A/0 local OD)
+
+	tEplApiCbEvent m_pfnCbEvent;
+	void *m_pEventUserArg;
+	tEplSyncCb m_pfnCbSync;
 
 } tEplApiInitParam;
 
-
-typedef struct
-{
-    void*          m_pImage;
-    unsigned int   m_uiSize;
+typedef struct {
+	void *m_pImage;
+	unsigned int m_uiSize;
 
 } tEplApiProcessImage;
 
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplApiInitialize(tEplApiInitParam* pInitParam_p);
+tEplKernel PUBLIC EplApiInitialize(tEplApiInitParam * pInitParam_p);
 
 tEplKernel PUBLIC EplApiShutdown(void);
 
-tEplKernel PUBLIC EplApiReadObject(
-            tEplSdoComConHdl* pSdoComConHdl_p,
-            unsigned int      uiNodeId_p,
-            unsigned int      uiIndex_p,
-            unsigned int      uiSubindex_p,
-            void*             pDstData_le_p,
-            unsigned int*     puiSize_p,
-            tEplSdoType       SdoType_p,
-            void*             pUserArg_p);
-
-tEplKernel PUBLIC EplApiWriteObject(
-            tEplSdoComConHdl* pSdoComConHdl_p,
-            unsigned int      uiNodeId_p,
-            unsigned int      uiIndex_p,
-            unsigned int      uiSubindex_p,
-            void*             pSrcData_le_p,
-            unsigned int      uiSize_p,
-            tEplSdoType       SdoType_p,
-            void*             pUserArg_p);
-
-tEplKernel PUBLIC EplApiFreeSdoChannel(
-            tEplSdoComConHdl SdoComConHdl_p);
-
-tEplKernel PUBLIC EplApiReadLocalObject(
-            unsigned int      uiIndex_p,
-            unsigned int      uiSubindex_p,
-            void*             pDstData_p,
-            unsigned int*     puiSize_p);
-
-tEplKernel PUBLIC EplApiWriteLocalObject(
-            unsigned int      uiIndex_p,
-            unsigned int      uiSubindex_p,
-            void*             pSrcData_p,
-            unsigned int      uiSize_p);
-
-tEplKernel PUBLIC EplApiCbObdAccess(tEplObdCbParam MEM* pParam_p);
-
-tEplKernel PUBLIC EplApiLinkObject( unsigned int    uiObjIndex_p,
-                                    void*           pVar_p,
-                                    unsigned int*   puiVarEntries_p,
-                                    tEplObdSize*    pEntrySize_p,
-                                    unsigned int    uiFirstSubindex_p);
+tEplKernel PUBLIC EplApiReadObject(tEplSdoComConHdl * pSdoComConHdl_p,
+				   unsigned int uiNodeId_p,
+				   unsigned int uiIndex_p,
+				   unsigned int uiSubindex_p,
+				   void *pDstData_le_p,
+				   unsigned int *puiSize_p,
+				   tEplSdoType SdoType_p, void *pUserArg_p);
+
+tEplKernel PUBLIC EplApiWriteObject(tEplSdoComConHdl * pSdoComConHdl_p,
+				    unsigned int uiNodeId_p,
+				    unsigned int uiIndex_p,
+				    unsigned int uiSubindex_p,
+				    void *pSrcData_le_p,
+				    unsigned int uiSize_p,
+				    tEplSdoType SdoType_p, void *pUserArg_p);
+
+tEplKernel PUBLIC EplApiFreeSdoChannel(tEplSdoComConHdl SdoComConHdl_p);
+
+tEplKernel PUBLIC EplApiReadLocalObject(unsigned int uiIndex_p,
+					unsigned int uiSubindex_p,
+					void *pDstData_p,
+					unsigned int *puiSize_p);
+
+tEplKernel PUBLIC EplApiWriteLocalObject(unsigned int uiIndex_p,
+					 unsigned int uiSubindex_p,
+					 void *pSrcData_p,
+					 unsigned int uiSize_p);
+
+tEplKernel PUBLIC EplApiCbObdAccess(tEplObdCbParam MEM * pParam_p);
+
+tEplKernel PUBLIC EplApiLinkObject(unsigned int uiObjIndex_p,
+				   void *pVar_p,
+				   unsigned int *puiVarEntries_p,
+				   tEplObdSize * pEntrySize_p,
+				   unsigned int uiFirstSubindex_p);
 
 tEplKernel PUBLIC EplApiExecNmtCommand(tEplNmtEvent NmtEvent_p);
 
 tEplKernel PUBLIC EplApiProcess(void);
 
-
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 tEplKernel PUBLIC EplApiMnTriggerStateChange(unsigned int uiNodeId_p,
-                                             tEplNmtNodeCommand  NodeCommand_p);
+					     tEplNmtNodeCommand NodeCommand_p);
 #endif
 
-tEplKernel PUBLIC EplApiGetIdentResponse(
-                                    unsigned int        uiNodeId_p,
-                                    tEplIdentResponse** ppIdentResponse_p);
-
+tEplKernel PUBLIC EplApiGetIdentResponse(unsigned int uiNodeId_p,
+					 tEplIdentResponse **
+					 ppIdentResponse_p);
 
 // functions for process image will be implemented in separate file
 tEplKernel PUBLIC EplApiProcessImageSetup(void);
-tEplKernel PUBLIC EplApiProcessImageExchangeIn(tEplApiProcessImage* pPI_p);
-tEplKernel PUBLIC EplApiProcessImageExchangeOut(tEplApiProcessImage* pPI_p);
-
-
-#endif  // #ifndef _EPL_API_H_
-
+tEplKernel PUBLIC EplApiProcessImageExchangeIn(tEplApiProcessImage * pPI_p);
+tEplKernel PUBLIC EplApiProcessImageExchangeOut(tEplApiProcessImage * pPI_p);
 
+#endif // #ifndef _EPL_API_H_
--- a/drivers/staging/epl/EplInc.h
+++ b/drivers/staging/epl/EplInc.h
@@ -66,7 +66,6 @@
 
   2006/05/22 d.k.:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #ifndef _EPL_INC_H_
@@ -77,28 +76,28 @@
 // ============================================================================
 #if defined(WIN32) || defined(_WIN32)
 
-    #ifdef UNDER_RTSS
-        // RTX header
-        #include <windows.h>
-        #include <process.h>
-        #include <rtapi.h>
-
-    #elif __BORLANDC__
-        // borland C header
-        #include <windows.h>
-        #include <process.h>
-
-    #elif WINCE
-        #include <windows.h>
-
-    #else
-        // MSVC needs to include windows.h at first
-        // the following defines ar necessary for function prototypes for waitable timers
-        #define _WIN32_WINDOWS 0x0401
-        #define _WIN32_WINNT   0x0400
-        #include <windows.h>
-        #include <process.h>
-    #endif
+#ifdef UNDER_RTSS
+	// RTX header
+#include <windows.h>
+#include <process.h>
+#include <rtapi.h>
+
+#elif __BORLANDC__
+	// borland C header
+#include <windows.h>
+#include <process.h>
+
+#elif WINCE
+#include <windows.h>
+
+#else
+	// MSVC needs to include windows.h at first
+	// the following defines ar necessary for function prototypes for waitable timers
+#define _WIN32_WINDOWS 0x0401
+#define _WIN32_WINNT   0x0400
+#include <windows.h>
+#include <process.h>
+#endif
 
 #endif
 
@@ -106,49 +105,47 @@
 // possible other include file needed
 // These constants defines modules which can be included in the Epl application.
 // Use this constants for define EPL_MODULE_INTEGRATION in file EplCfg.h.
-#define EPL_MODULE_OBDK        0x00000001L // OBD kernel part module
-#define EPL_MODULE_PDOK        0x00000002L // PDO kernel part module
-#define EPL_MODULE_NMT_MN      0x00000004L // NMT MN module
-#define EPL_MODULE_SDOS        0x00000008L // SDO Server module
-#define EPL_MODULE_SDOC        0x00000010L // SDO Client module
-#define EPL_MODULE_SDO_ASND    0x00000020L // SDO over Asnd module
-#define EPL_MODULE_SDO_UDP     0x00000040L // SDO over UDP module
-#define EPL_MODULE_SDO_PDO     0x00000080L // SDO in PDO module
-#define EPL_MODULE_NMT_CN      0x00000100L // NMT CN module
-#define EPL_MODULE_NMTU        0x00000200L // NMT user part module
-#define EPL_MODULE_NMTK        0x00000400L // NMT kernel part module
-#define EPL_MODULE_DLLK        0x00000800L // DLL kernel part module
-#define EPL_MODULE_DLLU        0x00001000L // DLL user part module
-#define EPL_MODULE_OBDU        0x00002000L // OBD user part module
-#define EPL_MODULE_CFGMA       0x00004000L // Configuartioan Manager module
-#define EPL_MODULE_VETH        0x00008000L // virtual ethernet driver module
-#define EPL_MODULE_PDOU        0x00010000L // PDO user part module
-#define EPL_MODULE_LEDU        0x00020000L // LED user part module
-
-#include "EplCfg.h"     // EPL configuration file (configuration from application)
-
-#include "global.h"     // global definitions
-
-#include "EplDef.h"     // EPL configuration file (default configuration)
-#include "EplInstDef.h" // defines macros for instance types and table
-#include "Debug.h"      // debug definitions
+#define EPL_MODULE_OBDK        0x00000001L	// OBD kernel part module
+#define EPL_MODULE_PDOK        0x00000002L	// PDO kernel part module
+#define EPL_MODULE_NMT_MN      0x00000004L	// NMT MN module
+#define EPL_MODULE_SDOS        0x00000008L	// SDO Server module
+#define EPL_MODULE_SDOC        0x00000010L	// SDO Client module
+#define EPL_MODULE_SDO_ASND    0x00000020L	// SDO over Asnd module
+#define EPL_MODULE_SDO_UDP     0x00000040L	// SDO over UDP module
+#define EPL_MODULE_SDO_PDO     0x00000080L	// SDO in PDO module
+#define EPL_MODULE_NMT_CN      0x00000100L	// NMT CN module
+#define EPL_MODULE_NMTU        0x00000200L	// NMT user part module
+#define EPL_MODULE_NMTK        0x00000400L	// NMT kernel part module
+#define EPL_MODULE_DLLK        0x00000800L	// DLL kernel part module
+#define EPL_MODULE_DLLU        0x00001000L	// DLL user part module
+#define EPL_MODULE_OBDU        0x00002000L	// OBD user part module
+#define EPL_MODULE_CFGMA       0x00004000L	// Configuartioan Manager module
+#define EPL_MODULE_VETH        0x00008000L	// virtual ethernet driver module
+#define EPL_MODULE_PDOU        0x00010000L	// PDO user part module
+#define EPL_MODULE_LEDU        0x00020000L	// LED user part module
+
+#include "EplCfg.h"		// EPL configuration file (configuration from application)
+
+#include "global.h"		// global definitions
+
+#include "EplDef.h"		// EPL configuration file (default configuration)
+#include "EplInstDef.h"		// defines macros for instance types and table
+#include "Debug.h"		// debug definitions
 
-#include "EplErrDef.h"  // EPL error codes for API funtions
+#include "EplErrDef.h"		// EPL error codes for API funtions
 
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
 // IEEE 1588 conformant net time structure
-typedef struct
-{
-    DWORD                   m_dwSec;
-    DWORD                   m_dwNanoSec;
+typedef struct {
+	DWORD m_dwSec;
+	DWORD m_dwNanoSec;
 
 } tEplNetTime;
 
-
-#include "EplTarget.h"  // target specific functions and definitions
+#include "EplTarget.h"		// target specific functions and definitions
 
 #include "EplAmi.h"
 
@@ -156,7 +153,7 @@ typedef struct
 // macros
 // -------------------------------------------------------------------------
 
-#define EPL_SPEC_VERSION                    0x20    // ETHERNET Powerlink V. 2.0
+#define EPL_SPEC_VERSION                    0x20	// ETHERNET Powerlink V. 2.0
 #define EPL_STACK_VERSION(ver,rev,rel)      ((((DWORD)(ver)) & 0xFF)|((((DWORD)(rev))&0xFF)<<8)|(((DWORD)(rel))<<16))
 #define EPL_OBJ1018_VERSION(ver,rev,rel)    ((((DWORD)(ver))<<16) |(((DWORD)(rev))&0xFFFF))
 #define EPL_STRING_VERSION(ver,rev,rel)     "V" #ver "." #rev " r" #rel
@@ -179,54 +176,53 @@ typedef struct
 #define EPL_FEATURE_RT1             0x00001000
 #define EPL_FEATURE_RT2             0x00002000
 
-
 // generate EPL NMT_FeatureFlags_U32
 #ifndef EPL_DEF_FEATURE_ISOCHR
-    #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-        #define EPL_DEF_FEATURE_ISOCHR          (EPL_FEATURE_ISOCHR)
-    #else
-        #define EPL_DEF_FEATURE_ISOCHR          0
-    #endif
+#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
+#define EPL_DEF_FEATURE_ISOCHR          (EPL_FEATURE_ISOCHR)
+#else
+#define EPL_DEF_FEATURE_ISOCHR          0
+#endif
 #endif
 
 #ifndef EPL_DEF_FEATURE_SDO_ASND
-    #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
-        #define EPL_DEF_FEATURE_SDO_ASND        (EPL_FEATURE_SDO_ASND)
-    #else
-        #define EPL_DEF_FEATURE_SDO_ASND        0
-    #endif
+#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
+#define EPL_DEF_FEATURE_SDO_ASND        (EPL_FEATURE_SDO_ASND)
+#else
+#define EPL_DEF_FEATURE_SDO_ASND        0
+#endif
 #endif
 
 #ifndef EPL_DEF_FEATURE_SDO_UDP
-    #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
-        #define EPL_DEF_FEATURE_SDO_UDP         (EPL_FEATURE_SDO_UDP)
-    #else
-        #define EPL_DEF_FEATURE_SDO_UDP         0
-    #endif
+#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
+#define EPL_DEF_FEATURE_SDO_UDP         (EPL_FEATURE_SDO_UDP)
+#else
+#define EPL_DEF_FEATURE_SDO_UDP         0
+#endif
 #endif
 
 #ifndef EPL_DEF_FEATURE_SDO_PDO
-    #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_PDO)) != 0)
-        #define EPL_DEF_FEATURE_SDO_PDO         (EPL_FEATURE_SDO_PDO)
-    #else
-        #define EPL_DEF_FEATURE_SDO_PDO         0
-    #endif
+#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_PDO)) != 0)
+#define EPL_DEF_FEATURE_SDO_PDO         (EPL_FEATURE_SDO_PDO)
+#else
+#define EPL_DEF_FEATURE_SDO_PDO         0
+#endif
 #endif
 
 #ifndef EPL_DEF_FEATURE_PDO_DYN
-    #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
-        #define EPL_DEF_FEATURE_PDO_DYN         (EPL_FEATURE_PDO_DYN)
-    #else
-        #define EPL_DEF_FEATURE_PDO_DYN         0
-    #endif
+#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
+#define EPL_DEF_FEATURE_PDO_DYN         (EPL_FEATURE_PDO_DYN)
+#else
+#define EPL_DEF_FEATURE_PDO_DYN         0
+#endif
 #endif
 
 #ifndef EPL_DEF_FEATURE_CFGMA
-    #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_CFGMA)) != 0)
-        #define EPL_DEF_FEATURE_CFGMA           (EPL_FEATURE_CFGMA)
-    #else
-        #define EPL_DEF_FEATURE_CFGMA           0
-    #endif
+#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_CFGMA)) != 0)
+#define EPL_DEF_FEATURE_CFGMA           (EPL_FEATURE_CFGMA)
+#else
+#define EPL_DEF_FEATURE_CFGMA           0
+#endif
 #endif
 
 #define EPL_DEF_FEATURE_FLAGS                   (EPL_DEF_FEATURE_ISOCHR \
@@ -236,12 +232,10 @@ typedef struct
                                                 | EPL_DEF_FEATURE_PDO_DYN \
                                                 | EPL_DEF_FEATURE_CFGMA)
 
-
 #ifndef tabentries
 #define tabentries(a)   (sizeof(a)/sizeof(*(a)))
 #endif
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
@@ -249,15 +243,14 @@ typedef struct
 // definitions for DLL export
 #if ((DEV_SYSTEM == _DEV_WIN32_) || (DEV_SYSTEM == _DEV_WIN_CE_)) && defined (COP_LIB)
 
-    #define EPLDLLEXPORT    __declspec (dllexport)
+#define EPLDLLEXPORT    __declspec (dllexport)
 
 #else
 
-    #define EPLDLLEXPORT
+#define EPLDLLEXPORT
 
 #endif
 
-
 // ============================================================================
 // common debug macros
 // ============================================================================
@@ -273,49 +266,49 @@ typedef struct
 // default level is defined in copdef.h
 
 // debug-level and TRACE-macros         // standard-level   // flags for DEF_DEBUG_LVL
-#define EPL_DBGLVL_EDRV                 DEBUG_LVL_01        // 0x00000001L
+#define EPL_DBGLVL_EDRV                 DEBUG_LVL_01	// 0x00000001L
 #define EPL_DBGLVL_EDRV_TRACE0          DEBUG_LVL_01_TRACE0
 #define EPL_DBGLVL_EDRV_TRACE1          DEBUG_LVL_01_TRACE1
 #define EPL_DBGLVL_EDRV_TRACE2          DEBUG_LVL_01_TRACE2
 #define EPL_DBGLVL_EDRV_TRACE3          DEBUG_LVL_01_TRACE3
 #define EPL_DBGLVL_EDRV_TRACE4          DEBUG_LVL_01_TRACE4
 
-#define EPL_DBGLVL_DLL                  DEBUG_LVL_02        // 0x00000002L
+#define EPL_DBGLVL_DLL                  DEBUG_LVL_02	// 0x00000002L
 #define EPL_DBGLVL_DLL_TRACE0           DEBUG_LVL_02_TRACE0
 #define EPL_DBGLVL_DLL_TRACE1           DEBUG_LVL_02_TRACE1
 #define EPL_DBGLVL_DLL_TRACE2           DEBUG_LVL_02_TRACE2
 #define EPL_DBGLVL_DLL_TRACE3           DEBUG_LVL_02_TRACE3
 #define EPL_DBGLVL_DLL_TRACE4           DEBUG_LVL_02_TRACE4
 
-#define EPL_DBGLVL_OBD                  DEBUG_LVL_03        // 0x00000004L
+#define EPL_DBGLVL_OBD                  DEBUG_LVL_03	// 0x00000004L
 #define EPL_DBGLVL_OBD_TRACE0           DEBUG_LVL_03_TRACE0
 #define EPL_DBGLVL_OBD_TRACE1           DEBUG_LVL_03_TRACE1
 #define EPL_DBGLVL_OBD_TRACE2           DEBUG_LVL_03_TRACE2
 #define EPL_DBGLVL_OBD_TRACE3           DEBUG_LVL_03_TRACE3
 #define EPL_DBGLVL_OBD_TRACE4           DEBUG_LVL_03_TRACE4
 
-#define EPL_DBGLVL_NMTK                 DEBUG_LVL_04        // 0x00000008L
+#define EPL_DBGLVL_NMTK                 DEBUG_LVL_04	// 0x00000008L
 #define EPL_DBGLVL_NMTK_TRACE0          DEBUG_LVL_04_TRACE0
 #define EPL_DBGLVL_NMTK_TRACE1          DEBUG_LVL_04_TRACE1
 #define EPL_DBGLVL_NMTK_TRACE2          DEBUG_LVL_04_TRACE2
 #define EPL_DBGLVL_NMTK_TRACE3          DEBUG_LVL_04_TRACE3
 #define EPL_DBGLVL_NMTK_TRACE4          DEBUG_LVL_04_TRACE4
 
-#define EPL_DBGLVL_NMTCN                DEBUG_LVL_05        // 0x00000010L
+#define EPL_DBGLVL_NMTCN                DEBUG_LVL_05	// 0x00000010L
 #define EPL_DBGLVL_NMTCN_TRACE0         DEBUG_LVL_05_TRACE0
 #define EPL_DBGLVL_NMTCN_TRACE1         DEBUG_LVL_05_TRACE1
 #define EPL_DBGLVL_NMTCN_TRACE2         DEBUG_LVL_05_TRACE2
 #define EPL_DBGLVL_NMTCN_TRACE3         DEBUG_LVL_05_TRACE3
 #define EPL_DBGLVL_NMTCN_TRACE4         DEBUG_LVL_05_TRACE4
 
-#define EPL_DBGLVL_NMTU                 DEBUG_LVL_06        // 0x00000020L
+#define EPL_DBGLVL_NMTU                 DEBUG_LVL_06	// 0x00000020L
 #define EPL_DBGLVL_NMTU_TRACE0          DEBUG_LVL_06_TRACE0
 #define EPL_DBGLVL_NMTU_TRACE1          DEBUG_LVL_06_TRACE1
 #define EPL_DBGLVL_NMTU_TRACE2          DEBUG_LVL_06_TRACE2
 #define EPL_DBGLVL_NMTU_TRACE3          DEBUG_LVL_06_TRACE3
 #define EPL_DBGLVL_NMTU_TRACE4          DEBUG_LVL_06_TRACE4
 
-#define EPL_DBGLVL_NMTMN                DEBUG_LVL_07        // 0x00000040L
+#define EPL_DBGLVL_NMTMN                DEBUG_LVL_07	// 0x00000040L
 #define EPL_DBGLVL_NMTMN_TRACE0         DEBUG_LVL_07_TRACE0
 #define EPL_DBGLVL_NMTMN_TRACE1         DEBUG_LVL_07_TRACE1
 #define EPL_DBGLVL_NMTMN_TRACE2         DEBUG_LVL_07_TRACE2
@@ -324,28 +317,28 @@ typedef struct
 
 //...
 
-#define EPL_DBGLVL_SDO                  DEBUG_LVL_25        // 0x01000000
+#define EPL_DBGLVL_SDO                  DEBUG_LVL_25	// 0x01000000
 #define EPL_DBGLVL_SDO_TRACE0           DEBUG_LVL_25_TRACE0
 #define EPL_DBGLVL_SDO_TRACE1           DEBUG_LVL_25_TRACE1
 #define EPL_DBGLVL_SDO_TRACE2           DEBUG_LVL_25_TRACE2
 #define EPL_DBGLVL_SDO_TRACE3           DEBUG_LVL_25_TRACE3
 #define EPL_DBGLVL_SDO_TRACE4           DEBUG_LVL_25_TRACE4
 
-#define EPL_DBGLVL_VETH                 DEBUG_LVL_26        // 0x02000000
+#define EPL_DBGLVL_VETH                 DEBUG_LVL_26	// 0x02000000
 #define EPL_DBGLVL_VETH_TRACE0          DEBUG_LVL_26_TRACE0
 #define EPL_DBGLVL_VETH_TRACE1          DEBUG_LVL_26_TRACE1
 #define EPL_DBGLVL_VETH_TRACE2          DEBUG_LVL_26_TRACE2
 #define EPL_DBGLVL_VETH_TRACE3          DEBUG_LVL_26_TRACE3
 #define EPL_DBGLVL_VETH_TRACE4          DEBUG_LVL_26_TRACE4
 
-#define EPL_DBGLVL_EVENTK               DEBUG_LVL_27        // 0x04000000
+#define EPL_DBGLVL_EVENTK               DEBUG_LVL_27	// 0x04000000
 #define EPL_DBGLVL_EVENTK_TRACE0        DEBUG_LVL_27_TRACE0
 #define EPL_DBGLVL_EVENTK_TRACE1        DEBUG_LVL_27_TRACE1
 #define EPL_DBGLVL_EVENTK_TRACE2        DEBUG_LVL_27_TRACE2
 #define EPL_DBGLVL_EVENTK_TRACE3        DEBUG_LVL_27_TRACE3
 #define EPL_DBGLVL_EVENTK_TRACE4        DEBUG_LVL_27_TRACE4
 
-#define EPL_DBGLVL_EVENTU               DEBUG_LVL_28        // 0x08000000
+#define EPL_DBGLVL_EVENTU               DEBUG_LVL_28	// 0x08000000
 #define EPL_DBGLVL_EVENTU_TRACE0        DEBUG_LVL_28_TRACE0
 #define EPL_DBGLVL_EVENTU_TRACE1        DEBUG_LVL_28_TRACE1
 #define EPL_DBGLVL_EVENTU_TRACE2        DEBUG_LVL_28_TRACE2
@@ -353,46 +346,40 @@ typedef struct
 #define EPL_DBGLVL_EVENTU_TRACE4        DEBUG_LVL_28_TRACE4
 
 // SharedBuff
-#define EPL_DBGLVL_SHB                  DEBUG_LVL_29        // 0x10000000
+#define EPL_DBGLVL_SHB                  DEBUG_LVL_29	// 0x10000000
 #define EPL_DBGLVL_SHB_TRACE0           DEBUG_LVL_29_TRACE0
 #define EPL_DBGLVL_SHB_TRACE1           DEBUG_LVL_29_TRACE1
 #define EPL_DBGLVL_SHB_TRACE2           DEBUG_LVL_29_TRACE2
 #define EPL_DBGLVL_SHB_TRACE3           DEBUG_LVL_29_TRACE3
 #define EPL_DBGLVL_SHB_TRACE4           DEBUG_LVL_29_TRACE4
 
-#define EPL_DBGLVL_ASSERT               DEBUG_LVL_ASSERT    // 0x20000000L
+#define EPL_DBGLVL_ASSERT               DEBUG_LVL_ASSERT	// 0x20000000L
 #define EPL_DBGLVL_ASSERT_TRACE0        DEBUG_LVL_ASSERT_TRACE0
 #define EPL_DBGLVL_ASSERT_TRACE1        DEBUG_LVL_ASSERT_TRACE1
 #define EPL_DBGLVL_ASSERT_TRACE2        DEBUG_LVL_ASSERT_TRACE2
 #define EPL_DBGLVL_ASSERT_TRACE3        DEBUG_LVL_ASSERT_TRACE3
 #define EPL_DBGLVL_ASSERT_TRACE4        DEBUG_LVL_ASSERT_TRACE4
 
-#define EPL_DBGLVL_ERROR                DEBUG_LVL_ERROR     // 0x40000000L
+#define EPL_DBGLVL_ERROR                DEBUG_LVL_ERROR	// 0x40000000L
 #define EPL_DBGLVL_ERROR_TRACE0         DEBUG_LVL_ERROR_TRACE0
 #define EPL_DBGLVL_ERROR_TRACE1         DEBUG_LVL_ERROR_TRACE1
 #define EPL_DBGLVL_ERROR_TRACE2         DEBUG_LVL_ERROR_TRACE2
 #define EPL_DBGLVL_ERROR_TRACE3         DEBUG_LVL_ERROR_TRACE3
 #define EPL_DBGLVL_ERROR_TRACE4         DEBUG_LVL_ERROR_TRACE4
 
-#define EPL_DBGLVL_ALWAYS               DEBUG_LVL_ALWAYS    // 0x80000000L
+#define EPL_DBGLVL_ALWAYS               DEBUG_LVL_ALWAYS	// 0x80000000L
 #define EPL_DBGLVL_ALWAYS_TRACE0        DEBUG_LVL_ALWAYS_TRACE0
 #define EPL_DBGLVL_ALWAYS_TRACE1        DEBUG_LVL_ALWAYS_TRACE1
 #define EPL_DBGLVL_ALWAYS_TRACE2        DEBUG_LVL_ALWAYS_TRACE2
 #define EPL_DBGLVL_ALWAYS_TRACE3        DEBUG_LVL_ALWAYS_TRACE3
 #define EPL_DBGLVL_ALWAYS_TRACE4        DEBUG_LVL_ALWAYS_TRACE4
 
-
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-#endif  // #ifndef _EPL_INC_H_
-
-
+#endif // #ifndef _EPL_INC_H_
--- a/drivers/staging/epl/EplInstDef.h
+++ b/drivers/staging/epl/EplInstDef.h
@@ -71,23 +71,20 @@
 #ifndef _EPLINSTDEF_H_
 #define _EPLINSTDEF_H_
 
-
 // =========================================================================
 // types and macros for generating instances
 // =========================================================================
 
-typedef enum
-{
-    kStateUnused    = 0,
-    kStateDeleted   = 1,
-    kStateUsed      = 0xFF
-
+typedef enum {
+	kStateUnused = 0,
+	kStateDeleted = 1,
+	kStateUsed = 0xFF
 } tInstState;
 
 //------------------------------------------------------------------------------------------
 
-typedef void MEM* tEplPtrInstance;
-typedef BYTE      tEplInstanceHdl;
+typedef void MEM *tEplPtrInstance;
+typedef BYTE tEplInstanceHdl;
 
 // define const for illegale values
 #define CCM_ILLINSTANCE      NULL
@@ -102,13 +99,12 @@ typedef BYTE      tEplInstanceHdl;
     //--------------------------------------------------------------------------------------
 
     // memory attributes for instance table
-    #define INST_NEAR                               // faster access to variables
-    #define INST_FAR                                // variables wich have to located in xdata
-    #define STATIC                                  // prevent warnings for variables with same name
-
-    #define INSTANCE_TYPE_BEGIN     typedef struct {
-    #define INSTANCE_TYPE_END       } tEplInstanceInfo;
+#define INST_NEAR		// faster access to variables
+#define INST_FAR		// variables wich have to located in xdata
+#define STATIC			// prevent warnings for variables with same name
 
+#define INSTANCE_TYPE_BEGIN     typedef struct {
+#define INSTANCE_TYPE_END       } tEplInstanceInfo;
 
     //--------------------------------------------------------------------------------------
     // macro definition for API interface
@@ -117,53 +113,51 @@ typedef BYTE      tEplInstanceHdl;
     // declaration:
 
     // macros for declaration within function header or prototype of API functions
-    #define CCM_DECL_INSTANCE_HDL                   tEplInstanceHdl InstanceHandle
-    #define CCM_DECL_INSTANCE_HDL_                  tEplInstanceHdl InstanceHandle,
+#define CCM_DECL_INSTANCE_HDL                   tEplInstanceHdl InstanceHandle
+#define CCM_DECL_INSTANCE_HDL_                  tEplInstanceHdl InstanceHandle,
 
     // macros for declaration of pointer to instance handle within function header or prototype of API functions
-    #define CCM_DECL_PTR_INSTANCE_HDL               tEplInstanceHdl MEM* pInstanceHandle
-    #define CCM_DECL_PTR_INSTANCE_HDL_              tEplInstanceHdl MEM* pInstanceHandle,
+#define CCM_DECL_PTR_INSTANCE_HDL               tEplInstanceHdl MEM* pInstanceHandle
+#define CCM_DECL_PTR_INSTANCE_HDL_              tEplInstanceHdl MEM* pInstanceHandle,
 
     // macros for declaration instance as lokacl variable within functions
-    #define CCM_DECL_INSTANCE_PTR_LOCAL             tCcmInstanceInfo MEM* pInstance;
-    #define CCM_DECL_PTR_INSTANCE_HDL_LOCAL         tEplInstanceHdl  MEM* pInstanceHandle;
+#define CCM_DECL_INSTANCE_PTR_LOCAL             tCcmInstanceInfo MEM* pInstance;
+#define CCM_DECL_PTR_INSTANCE_HDL_LOCAL         tEplInstanceHdl  MEM* pInstanceHandle;
 
     // reference:
 
     // macros for reference of instance handle for function parameters
-    #define CCM_INSTANCE_HDL                        InstanceHandle
-    #define CCM_INSTANCE_HDL_                       InstanceHandle,
+#define CCM_INSTANCE_HDL                        InstanceHandle
+#define CCM_INSTANCE_HDL_                       InstanceHandle,
 
     // macros for reference of instance parameter for function parameters
-    #define CCM_INSTANCE_PARAM(par)                 par
-    #define CCM_INSTANCE_PARAM_(par)                par,
+#define CCM_INSTANCE_PARAM(par)                 par
+#define CCM_INSTANCE_PARAM_(par)                par,
 
     // macros for reference of instance parameter for writing or reading values
-    #define CCM_INST_ENTRY                          (*((tEplPtrInstance)pInstance))
+#define CCM_INST_ENTRY                          (*((tEplPtrInstance)pInstance))
 
     // processing:
 
     // macros for process instance handle
-    #define CCM_CHECK_INSTANCE_HDL()                if (InstanceHandle >= EPL_MAX_INSTANCES) \
+#define CCM_CHECK_INSTANCE_HDL()                if (InstanceHandle >= EPL_MAX_INSTANCES) \
                                                         {return (kEplIllegalInstance);}
 
-
     // macros for process pointer to instance handle
-    #define CCM_CHECK_PTR_INSTANCE_HDL()            if (pInstanceHandle == NULL) \
+#define CCM_CHECK_PTR_INSTANCE_HDL()            if (pInstanceHandle == NULL) \
                                                         {return (kEplInvalidInstanceParam);}
 
     // This macro returned the handle and pointer to next free instance.
-    #define CCM_GET_FREE_INSTANCE_AND_HDL()         pInstance = CcmGetFreeInstanceAndHandle (pInstanceHandle); \
+#define CCM_GET_FREE_INSTANCE_AND_HDL()         pInstance = CcmGetFreeInstanceAndHandle (pInstanceHandle); \
                                                     ASSERT (*pInstanceHandle != CCM_ILLINSTANCE_HDL);
 
-    #define CCM_CHECK_INSTANCE_PTR()                if (pInstance == CCM_ILLINSTANCE) \
+#define CCM_CHECK_INSTANCE_PTR()                if (pInstance == CCM_ILLINSTANCE) \
                                                         {return (kEplNoFreeInstance);}
 
-    #define CCM_GET_INSTANCE_PTR()                  pInstance = CcmGetInstancePtr (InstanceHandle);
-    #define CCM_GET_FREE_INSTANCE_PTR()             pInstance = GetFreeInstance (); \
+#define CCM_GET_INSTANCE_PTR()                  pInstance = CcmGetInstancePtr (InstanceHandle);
+#define CCM_GET_FREE_INSTANCE_PTR()             pInstance = GetFreeInstance (); \
                                                     ASSERT (pInstance != CCM_ILLINSTANCE);
 
-
     //--------------------------------------------------------------------------------------
     // macro definition for stack interface
     //--------------------------------------------------------------------------------------
@@ -171,52 +165,52 @@ typedef BYTE      tEplInstanceHdl;
     // macros for declaration within the function header, prototype or local var list
     // Declaration of pointers within function paramater list must defined as void MEM*
     // pointer.
-    #define EPL_MCO_DECL_INSTANCE_PTR                   void MEM* pInstance
-    #define EPL_MCO_DECL_INSTANCE_PTR_                  void MEM* pInstance,
-    #define EPL_MCO_DECL_INSTANCE_PTR_LOCAL             tEplPtrInstance  pInstance;
+#define EPL_MCO_DECL_INSTANCE_PTR                   void MEM* pInstance
+#define EPL_MCO_DECL_INSTANCE_PTR_                  void MEM* pInstance,
+#define EPL_MCO_DECL_INSTANCE_PTR_LOCAL             tEplPtrInstance  pInstance;
 
     // macros for reference of pointer to instance
     // These macros are used for parameter passing to called function.
-    #define EPL_MCO_INSTANCE_PTR                        pInstance
-    #define EPL_MCO_INSTANCE_PTR_                       pInstance,
-    #define EPL_MCO_ADDR_INSTANCE_PTR_                  &pInstance,
+#define EPL_MCO_INSTANCE_PTR                        pInstance
+#define EPL_MCO_INSTANCE_PTR_                       pInstance,
+#define EPL_MCO_ADDR_INSTANCE_PTR_                  &pInstance,
 
     // macro for access of struct members of one instance
     // An access to a member of instance table must be casted by the local
     // defined type of instance table.
-    #define EPL_MCO_INST_ENTRY                          (*(tEplPtrInstance)pInstance)
-    #define EPL_MCO_GLB_VAR(var)                        (((tEplPtrInstance)pInstance)->var)
+#define EPL_MCO_INST_ENTRY                          (*(tEplPtrInstance)pInstance)
+#define EPL_MCO_GLB_VAR(var)                        (((tEplPtrInstance)pInstance)->var)
 
     // macros for process pointer to instance
-    #define EPL_MCO_GET_INSTANCE_PTR()                  pInstance = (tEplPtrInstance) GetInstancePtr (InstanceHandle);
-    #define EPL_MCO_GET_FREE_INSTANCE_PTR()             pInstance = (tEplPtrInstance) GetFreeInstance (); \
+#define EPL_MCO_GET_INSTANCE_PTR()                  pInstance = (tEplPtrInstance) GetInstancePtr (InstanceHandle);
+#define EPL_MCO_GET_FREE_INSTANCE_PTR()             pInstance = (tEplPtrInstance) GetFreeInstance (); \
                                                     ASSERT (pInstance != CCM_ILLINSTANCE);
 
     // This macro should be used to check the passed pointer to an public function
-    #define EPL_MCO_CHECK_INSTANCE_STATE()              ASSERT (pInstance != NULL); \
+#define EPL_MCO_CHECK_INSTANCE_STATE()              ASSERT (pInstance != NULL); \
                                                     ASSERT (((tEplPtrInstance)pInstance)->m_InstState == kStateUsed);
 
     // macros for declaration of pointer to instance pointer
-    #define EPL_MCO_DECL_PTR_INSTANCE_PTR               void MEM*  MEM* pInstancePtr
-    #define EPL_MCO_DECL_PTR_INSTANCE_PTR_              void MEM*  MEM* pInstancePtr,
+#define EPL_MCO_DECL_PTR_INSTANCE_PTR               void MEM*  MEM* pInstancePtr
+#define EPL_MCO_DECL_PTR_INSTANCE_PTR_              void MEM*  MEM* pInstancePtr,
 
     // macros for reference of pointer to instance pointer
     // These macros are used for parameter passing to called function.
-    #define EPL_MCO_PTR_INSTANCE_PTR                    pInstancePtr
-    #define EPL_MCO_PTR_INSTANCE_PTR_                   pInstancePtr,
+#define EPL_MCO_PTR_INSTANCE_PTR                    pInstancePtr
+#define EPL_MCO_PTR_INSTANCE_PTR_                   pInstancePtr,
 
     // macros for process pointer to instance pointer
-    #define EPL_MCO_CHECK_PTR_INSTANCE_PTR()            ASSERT (pInstancePtr != NULL);
-    #define EPL_MCO_SET_PTR_INSTANCE_PTR()              (*pInstancePtr = pInstance);
+#define EPL_MCO_CHECK_PTR_INSTANCE_PTR()            ASSERT (pInstancePtr != NULL);
+#define EPL_MCO_SET_PTR_INSTANCE_PTR()              (*pInstancePtr = pInstance);
 
-    #define EPL_MCO_INSTANCE_PARAM(a)                   (a)
-    #define EPL_MCO_INSTANCE_PARAM_(a)                  (a),
-    #define EPL_MCO_INSTANCE_PARAM_IDX_()               EPL_MCO_INSTANCE_PARAM_ (EPL_MCO_GLB_VAR (m_bInstIndex))
-    #define EPL_MCO_INSTANCE_PARAM_IDX()                EPL_MCO_INSTANCE_PARAM (EPL_MCO_GLB_VAR (m_bInstIndex))
-    #define EPL_MCO_WRITE_INSTANCE_STATE(a)             EPL_MCO_GLB_VAR (m_InstState) = a;
+#define EPL_MCO_INSTANCE_PARAM(a)                   (a)
+#define EPL_MCO_INSTANCE_PARAM_(a)                  (a),
+#define EPL_MCO_INSTANCE_PARAM_IDX_()               EPL_MCO_INSTANCE_PARAM_ (EPL_MCO_GLB_VAR (m_bInstIndex))
+#define EPL_MCO_INSTANCE_PARAM_IDX()                EPL_MCO_INSTANCE_PARAM (EPL_MCO_GLB_VAR (m_bInstIndex))
+#define EPL_MCO_WRITE_INSTANCE_STATE(a)             EPL_MCO_GLB_VAR (m_InstState) = a;
 
     // this macro deletes all instance entries as unused
-    #define EPL_MCO_DELETE_INSTANCE_TABLE()                                    \
+#define EPL_MCO_DELETE_INSTANCE_TABLE()                                    \
     {                                                                      \
         tEplInstanceInfo MEM*   pInstance       = &aEplInstanceTable_g[0]; \
         tFastByte               InstNumber      = 0;                       \
@@ -229,10 +223,10 @@ typedef BYTE      tEplInstanceHdl;
     }
 
     // definition of functions which has to be defined in each module of CANopen stack
-    #define EPL_MCO_DEFINE_INSTANCE_FCT() \
+#define EPL_MCO_DEFINE_INSTANCE_FCT() \
         static tEplPtrInstance GetInstancePtr (tEplInstanceHdl InstHandle_p);  \
         static tEplPtrInstance GetFreeInstance (void);
-    #define EPL_MCO_DECL_INSTANCE_FCT()                                            \
+#define EPL_MCO_DECL_INSTANCE_FCT()                                            \
         static tEplPtrInstance GetInstancePtr (tEplInstanceHdl InstHandle_p) { \
             return &aEplInstanceTable_g[InstHandle_p]; }                       \
         static tEplPtrInstance GetFreeInstance (void) {                        \
@@ -245,27 +239,27 @@ typedef BYTE      tEplInstanceHdl;
             return CCM_ILLINSTANCE; }
 
     // this macro defines the instance table. Each entry is reserved for an instance of CANopen.
-    #define EPL_MCO_DECL_INSTANCE_VAR() \
+#define EPL_MCO_DECL_INSTANCE_VAR() \
         static tEplInstanceInfo MEM aEplInstanceTable_g [EPL_MAX_INSTANCES];
 
     // this macro defines member variables in instance table which are needed in
     // all modules of Epl stack
-    #define EPL_MCO_DECL_INSTANCE_MEMBER() \
+#define EPL_MCO_DECL_INSTANCE_MEMBER() \
         STATIC  BYTE                            m_InstState; \
         STATIC  BYTE                            m_bInstIndex;
 
-    #define EPL_MCO_INSTANCE_PARAM_IDX_()           EPL_MCO_INSTANCE_PARAM_ (EPL_MCO_GLB_VAR (m_bInstIndex))
-    #define EPL_MCO_INSTANCE_PARAM_IDX()            EPL_MCO_INSTANCE_PARAM (EPL_MCO_GLB_VAR (m_bInstIndex))
+#define EPL_MCO_INSTANCE_PARAM_IDX_()           EPL_MCO_INSTANCE_PARAM_ (EPL_MCO_GLB_VAR (m_bInstIndex))
+#define EPL_MCO_INSTANCE_PARAM_IDX()            EPL_MCO_INSTANCE_PARAM (EPL_MCO_GLB_VAR (m_bInstIndex))
 
-#else       // only one instance is used
+#else // only one instance is used
 
     // Memory attributes for instance table.
-    #define INST_NEAR   NEAR                        // faster access to variables
-    #define INST_FAR    MEM                         // variables wich have to located in xdata
-    #define STATIC      static                      // prevent warnings for variables with same name
+#define INST_NEAR   NEAR	// faster access to variables
+#define INST_FAR    MEM		// variables wich have to located in xdata
+#define STATIC      static	// prevent warnings for variables with same name
 
-    #define INSTANCE_TYPE_BEGIN
-    #define INSTANCE_TYPE_END
+#define INSTANCE_TYPE_BEGIN
+#define INSTANCE_TYPE_END
 
 // macros for declaration, initializing and member access for instance handle
 // This class of macros are used by API function to inform CCM-modul which
@@ -273,99 +267,98 @@ typedef BYTE      tEplInstanceHdl;
 
     // macros for reference of instance handle
     // These macros are used for parameter passing to CANopen API function.
-    #define CCM_INSTANCE_HDL
-    #define CCM_INSTANCE_HDL_
+#define CCM_INSTANCE_HDL
+#define CCM_INSTANCE_HDL_
 
-    #define CCM_DECL_INSTANCE_PTR_LOCAL
+#define CCM_DECL_INSTANCE_PTR_LOCAL
 
     // macros for declaration within the function header or prototype
-    #define CCM_DECL_INSTANCE_HDL                   void
-    #define CCM_DECL_INSTANCE_HDL_
+#define CCM_DECL_INSTANCE_HDL                   void
+#define CCM_DECL_INSTANCE_HDL_
 
     // macros for process instance handle
-    #define CCM_CHECK_INSTANCE_HDL()
+#define CCM_CHECK_INSTANCE_HDL()
 
     // macros for declaration of pointer to instance handle
-    #define CCM_DECL_PTR_INSTANCE_HDL               void
-    #define CCM_DECL_PTR_INSTANCE_HDL_
+#define CCM_DECL_PTR_INSTANCE_HDL               void
+#define CCM_DECL_PTR_INSTANCE_HDL_
 
     // macros for process pointer to instance handle
-    #define CCM_CHECK_PTR_INSTANCE_HDL()
+#define CCM_CHECK_PTR_INSTANCE_HDL()
 
     // This macro returned the handle and pointer to next free instance.
-    #define CCM_GET_FREE_INSTANCE_AND_HDL()
+#define CCM_GET_FREE_INSTANCE_AND_HDL()
 
-    #define CCM_CHECK_INSTANCE_PTR()
+#define CCM_CHECK_INSTANCE_PTR()
 
-    #define CCM_GET_INSTANCE_PTR()
-    #define CCM_GET_FREE_INSTANCE_PTR()
+#define CCM_GET_INSTANCE_PTR()
+#define CCM_GET_FREE_INSTANCE_PTR()
 
-    #define CCM_INSTANCE_PARAM(par)
-    #define CCM_INSTANCE_PARAM_(par)
+#define CCM_INSTANCE_PARAM(par)
+#define CCM_INSTANCE_PARAM_(par)
 
-    #define CCM_INST_ENTRY                          aCcmInstanceTable_g[0]
+#define CCM_INST_ENTRY                          aCcmInstanceTable_g[0]
 
 // macros for declaration, initializing and member access for instance pointer
 // This class of macros are used by CANopen internal function to point to one instance.
 
     // macros for declaration within the function header, prototype or local var list
-    #define EPL_MCO_DECL_INSTANCE_PTR                   void
-    #define EPL_MCO_DECL_INSTANCE_PTR_
-    #define EPL_MCO_DECL_INSTANCE_PTR_LOCAL
+#define EPL_MCO_DECL_INSTANCE_PTR                   void
+#define EPL_MCO_DECL_INSTANCE_PTR_
+#define EPL_MCO_DECL_INSTANCE_PTR_LOCAL
 
     // macros for reference of pointer to instance
     // These macros are used for parameter passing to called function.
-    #define EPL_MCO_INSTANCE_PTR
-    #define EPL_MCO_INSTANCE_PTR_
-    #define EPL_MCO_ADDR_INSTANCE_PTR_
+#define EPL_MCO_INSTANCE_PTR
+#define EPL_MCO_INSTANCE_PTR_
+#define EPL_MCO_ADDR_INSTANCE_PTR_
 
     // macros for process pointer to instance
-    #define EPL_MCO_GET_INSTANCE_PTR()
-    #define EPL_MCO_GET_FREE_INSTANCE_PTR()
+#define EPL_MCO_GET_INSTANCE_PTR()
+#define EPL_MCO_GET_FREE_INSTANCE_PTR()
 
     // This macro should be used to check the passed pointer to an public function
-    #define EPL_MCO_CHECK_INSTANCE_STATE()
+#define EPL_MCO_CHECK_INSTANCE_STATE()
 
     // macros for declaration of pointer to instance pointer
-    #define EPL_MCO_DECL_PTR_INSTANCE_PTR               void
-    #define EPL_MCO_DECL_PTR_INSTANCE_PTR_
+#define EPL_MCO_DECL_PTR_INSTANCE_PTR               void
+#define EPL_MCO_DECL_PTR_INSTANCE_PTR_
 
     // macros for reference of pointer to instance pointer
     // These macros are used for parameter passing to called function.
-    #define EPL_MCO_PTR_INSTANCE_PTR
-    #define EPL_MCO_PTR_INSTANCE_PTR_
+#define EPL_MCO_PTR_INSTANCE_PTR
+#define EPL_MCO_PTR_INSTANCE_PTR_
 
     // macros for process pointer to instance pointer
-    #define EPL_MCO_CHECK_PTR_INSTANCE_PTR()
-    #define EPL_MCO_SET_PTR_INSTANCE_PTR()
+#define EPL_MCO_CHECK_PTR_INSTANCE_PTR()
+#define EPL_MCO_SET_PTR_INSTANCE_PTR()
 
-    #define EPL_MCO_INSTANCE_PARAM(a)
-    #define EPL_MCO_INSTANCE_PARAM_(a)
-    #define EPL_MCO_INSTANCE_PARAM_IDX_()
-    #define EPL_MCO_INSTANCE_PARAM_IDX()
+#define EPL_MCO_INSTANCE_PARAM(a)
+#define EPL_MCO_INSTANCE_PARAM_(a)
+#define EPL_MCO_INSTANCE_PARAM_IDX_()
+#define EPL_MCO_INSTANCE_PARAM_IDX()
 
     // macro for access of struct members of one instance
-    #define EPL_MCO_INST_ENTRY                          aEplInstanceTable_g[0]
-    #define EPL_MCO_GLB_VAR(var)                        (var)
-    #define EPL_MCO_WRITE_INSTANCE_STATE(a)
+#define EPL_MCO_INST_ENTRY                          aEplInstanceTable_g[0]
+#define EPL_MCO_GLB_VAR(var)                        (var)
+#define EPL_MCO_WRITE_INSTANCE_STATE(a)
 
     // this macro deletes all instance entries as unused
-    #define EPL_MCO_DELETE_INSTANCE_TABLE()
+#define EPL_MCO_DELETE_INSTANCE_TABLE()
 
     // definition of functions which has to be defined in each module of CANopen stack
-    #define EPL_MCO_DEFINE_INSTANCE_FCT()
-    #define EPL_MCO_DECL_INSTANCE_FCT()
+#define EPL_MCO_DEFINE_INSTANCE_FCT()
+#define EPL_MCO_DECL_INSTANCE_FCT()
 
     // this macro defines the instance table. Each entry is reserved for an instance of CANopen.
-    #define EPL_MCO_DECL_INSTANCE_VAR()
+#define EPL_MCO_DECL_INSTANCE_VAR()
 
     // this macro defines member variables in instance table which are needed in
     // all modules of CANopen stack
-    #define EPL_MCO_DECL_INSTANCE_MEMBER()
+#define EPL_MCO_DECL_INSTANCE_MEMBER()
 
 #endif
 
-
 /*
 #if (CDRV_MAX_INSTANCES > 1)
 
@@ -378,9 +371,7 @@ typedef BYTE      tEplInstanceHdl;
 #endif
 */
 
-
 #endif // _EPLINSTDEF_H_
 
 // Die letzte Zeile muß unbedingt eine leere Zeile sein, weil manche Compiler
 // damit ein Problem haben, wenn das nicht so ist (z.B. GNU oder Borland C++ Builder).
-
--- a/drivers/staging/epl/EplLed.h
+++ b/drivers/staging/epl/EplLed.h
@@ -66,39 +66,27 @@
 
   2008/11/17 d.k.:   start of the implementation
 
-
 ****************************************************************************/
 
-
 #ifndef _EPLLED_H_
 #define _EPLLED_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
-
-typedef enum
-{
-    kEplLedTypeStatus   = 0x00,
-    kEplLedTypeError    = 0x01,
+typedef enum {
+	kEplLedTypeStatus = 0x00,
+	kEplLedTypeError = 0x01,
 
 } tEplLedType;
 
-
-
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-#endif  // #ifndef _EPLLED_H_
-
-
+#endif // #ifndef _EPLLED_H_
--- a/drivers/staging/epl/EplNmt.h
+++ b/drivers/staging/epl/EplNmt.h
@@ -66,7 +66,6 @@
 
   2006/06/09 k.t.:   start of the implementation
 
-
 ****************************************************************************/
 
 #ifndef _EPLNMT_H_
@@ -79,18 +78,18 @@
 //---------------------------------------------------------------------------
 
 // define super-states and masks to identify a super-state
-#define EPL_NMT_GS_POWERED          0x0008  // super state
-#define EPL_NMT_GS_INITIALISATION   0x0009  // super state
-#define EPL_NMT_GS_COMMUNICATING    0x000C  // super state
-#define EPL_NMT_CS_EPLMODE          0x000D  // super state
-#define EPL_NMT_MS_EPLMODE          0x000D  // super state
-
-#define EPL_NMT_SUPERSTATE_MASK     0x000F  // mask to select state
-
-#define EPL_NMT_TYPE_UNDEFINED      0x0000  // type of NMT state is still undefined
-#define EPL_NMT_TYPE_CS             0x0100  // CS type of NMT state
-#define EPL_NMT_TYPE_MS             0x0200  // MS type of NMT state
-#define EPL_NMT_TYPE_MASK           0x0300  // mask to select type of NMT state (i.e. CS or MS)
+#define EPL_NMT_GS_POWERED          0x0008	// super state
+#define EPL_NMT_GS_INITIALISATION   0x0009	// super state
+#define EPL_NMT_GS_COMMUNICATING    0x000C	// super state
+#define EPL_NMT_CS_EPLMODE          0x000D	// super state
+#define EPL_NMT_MS_EPLMODE          0x000D	// super state
+
+#define EPL_NMT_SUPERSTATE_MASK     0x000F	// mask to select state
+
+#define EPL_NMT_TYPE_UNDEFINED      0x0000	// type of NMT state is still undefined
+#define EPL_NMT_TYPE_CS             0x0100	// CS type of NMT state
+#define EPL_NMT_TYPE_MS             0x0200	// MS type of NMT state
+#define EPL_NMT_TYPE_MASK           0x0300	// mask to select type of NMT state (i.e. CS or MS)
 
 //---------------------------------------------------------------------------
 // typedef
@@ -106,143 +105,126 @@
 // --> there are masks defined to indentify the
 // super-states
 
-typedef enum
-{
-    kEplNmtGsOff                    = 0x0000,
-    kEplNmtGsInitialising           = 0x0019,
-    kEplNmtGsResetApplication       = 0x0029,
-    kEplNmtGsResetCommunication     = 0x0039,
-    kEplNmtGsResetConfiguration     = 0x0079,
-    kEplNmtCsNotActive              = 0x011C,
-    kEplNmtCsPreOperational1        = 0x011D,
-    kEplNmtCsStopped                = 0x014D,
-    kEplNmtCsPreOperational2        = 0x015D,
-    kEplNmtCsReadyToOperate         = 0x016D,
-    kEplNmtCsOperational            = 0x01FD,
-    kEplNmtCsBasicEthernet          = 0x011E,
-    kEplNmtMsNotActive              = 0x021C,
-    kEplNmtMsPreOperational1        = 0x021D,
-    kEplNmtMsPreOperational2        = 0x025D,
-    kEplNmtMsReadyToOperate         = 0x026D,
-    kEplNmtMsOperational            = 0x02FD,
-    kEplNmtMsBasicEthernet          = 0x021E
-
+typedef enum {
+	kEplNmtGsOff = 0x0000,
+	kEplNmtGsInitialising = 0x0019,
+	kEplNmtGsResetApplication = 0x0029,
+	kEplNmtGsResetCommunication = 0x0039,
+	kEplNmtGsResetConfiguration = 0x0079,
+	kEplNmtCsNotActive = 0x011C,
+	kEplNmtCsPreOperational1 = 0x011D,
+	kEplNmtCsStopped = 0x014D,
+	kEplNmtCsPreOperational2 = 0x015D,
+	kEplNmtCsReadyToOperate = 0x016D,
+	kEplNmtCsOperational = 0x01FD,
+	kEplNmtCsBasicEthernet = 0x011E,
+	kEplNmtMsNotActive = 0x021C,
+	kEplNmtMsPreOperational1 = 0x021D,
+	kEplNmtMsPreOperational2 = 0x025D,
+	kEplNmtMsReadyToOperate = 0x026D,
+	kEplNmtMsOperational = 0x02FD,
+	kEplNmtMsBasicEthernet = 0x021E
 } tEplNmtState;
 
 // NMT-events
-typedef enum
-{
-    // Events from DLL
-    // Events defined by EPL V2 specification
-    kEplNmtEventNoEvent             =   0x00,
+typedef enum {
+	// Events from DLL
+	// Events defined by EPL V2 specification
+	kEplNmtEventNoEvent = 0x00,
 //    kEplNmtEventDllMePres           =   0x01,
-    kEplNmtEventDllMePresTimeout    =   0x02,
+	kEplNmtEventDllMePresTimeout = 0x02,
 //    kEplNmtEventDllMeAsnd           =   0x03,
 //    kEplNmtEventDllMeAsndTimeout    =   0x04,
-    kEplNmtEventDllMeSoaSent        =   0x04,
-    kEplNmtEventDllMeSocTrig        =   0x05,
-    kEplNmtEventDllMeSoaTrig        =   0x06,
-    kEplNmtEventDllCeSoc            =   0x07,
-    kEplNmtEventDllCePreq           =   0x08,
-    kEplNmtEventDllCePres           =   0x09,
-    kEplNmtEventDllCeSoa            =   0x0A,
-    kEplNmtEventDllCeAsnd           =   0x0B,
-    kEplNmtEventDllCeFrameTimeout   =   0x0C,
-
-    // Events triggered by NMT-Commands
-    kEplNmtEventSwReset             =   0x10, // NMT_GT1, NMT_GT2, NMT_GT8
-    kEplNmtEventResetNode           =   0x11,
-    kEplNmtEventResetCom            =   0x12,
-    kEplNmtEventResetConfig         =   0x13,
-    kEplNmtEventEnterPreOperational2=   0x14,
-    kEplNmtEventEnableReadyToOperate=   0x15,
-    kEplNmtEventStartNode           =   0x16, // NMT_CT7
-    kEplNmtEventStopNode            =   0x17,
-
-    // Events triggered by higher layer
-    kEplNmtEventEnterResetApp       =   0x20,
-    kEplNmtEventEnterResetCom       =   0x21,
-    kEplNmtEventInternComError      =   0x22, // NMT_GT6, internal communication error -> enter ResetCommunication
-    kEplNmtEventEnterResetConfig    =   0x23,
-    kEplNmtEventEnterCsNotActive    =   0x24,
-    kEplNmtEventEnterMsNotActive    =   0x25,
-    kEplNmtEventTimerBasicEthernet  =   0x26, // NMT_CT3; timer triggered state change (NotActive -> BasicEth)
-    kEplNmtEventTimerMsPreOp1       =   0x27, // enter PreOp1 on MN (NotActive -> MsPreOp1)
-    kEplNmtEventNmtCycleError       =   0x28, // NMT_CT11, NMT_MT6; error during cycle -> enter PreOp1
-    kEplNmtEventTimerMsPreOp2       =   0x29, // enter PreOp2 on MN (MsPreOp1 -> MsPreOp2 if kEplNmtEventAllMandatoryCNIdent)
-    kEplNmtEventAllMandatoryCNIdent =   0x2A, // enter PreOp2 on MN if kEplNmtEventTimerMsPreOp2
-    kEplNmtEventEnterReadyToOperate =   0x2B, // application ready for the state ReadyToOp
-    kEplNmtEventEnterMsOperational  =   0x2C, // enter Operational on MN
-    kEplNmtEventSwitchOff           =   0x2D, // enter state Off
-    kEplNmtEventCriticalError       =   0x2E, // enter state Off because of critical error
+	kEplNmtEventDllMeSoaSent = 0x04,
+	kEplNmtEventDllMeSocTrig = 0x05,
+	kEplNmtEventDllMeSoaTrig = 0x06,
+	kEplNmtEventDllCeSoc = 0x07,
+	kEplNmtEventDllCePreq = 0x08,
+	kEplNmtEventDllCePres = 0x09,
+	kEplNmtEventDllCeSoa = 0x0A,
+	kEplNmtEventDllCeAsnd = 0x0B,
+	kEplNmtEventDllCeFrameTimeout = 0x0C,
+
+	// Events triggered by NMT-Commands
+	kEplNmtEventSwReset = 0x10,	// NMT_GT1, NMT_GT2, NMT_GT8
+	kEplNmtEventResetNode = 0x11,
+	kEplNmtEventResetCom = 0x12,
+	kEplNmtEventResetConfig = 0x13,
+	kEplNmtEventEnterPreOperational2 = 0x14,
+	kEplNmtEventEnableReadyToOperate = 0x15,
+	kEplNmtEventStartNode = 0x16,	// NMT_CT7
+	kEplNmtEventStopNode = 0x17,
+
+	// Events triggered by higher layer
+	kEplNmtEventEnterResetApp = 0x20,
+	kEplNmtEventEnterResetCom = 0x21,
+	kEplNmtEventInternComError = 0x22,	// NMT_GT6, internal communication error -> enter ResetCommunication
+	kEplNmtEventEnterResetConfig = 0x23,
+	kEplNmtEventEnterCsNotActive = 0x24,
+	kEplNmtEventEnterMsNotActive = 0x25,
+	kEplNmtEventTimerBasicEthernet = 0x26,	// NMT_CT3; timer triggered state change (NotActive -> BasicEth)
+	kEplNmtEventTimerMsPreOp1 = 0x27,	// enter PreOp1 on MN (NotActive -> MsPreOp1)
+	kEplNmtEventNmtCycleError = 0x28,	// NMT_CT11, NMT_MT6; error during cycle -> enter PreOp1
+	kEplNmtEventTimerMsPreOp2 = 0x29,	// enter PreOp2 on MN (MsPreOp1 -> MsPreOp2 if kEplNmtEventAllMandatoryCNIdent)
+	kEplNmtEventAllMandatoryCNIdent = 0x2A,	// enter PreOp2 on MN if kEplNmtEventTimerMsPreOp2
+	kEplNmtEventEnterReadyToOperate = 0x2B,	// application ready for the state ReadyToOp
+	kEplNmtEventEnterMsOperational = 0x2C,	// enter Operational on MN
+	kEplNmtEventSwitchOff = 0x2D,	// enter state Off
+	kEplNmtEventCriticalError = 0x2E,	// enter state Off because of critical error
 
 } tEplNmtEvent;
 
-
 // type for argument of event kEplEventTypeNmtStateChange
-typedef struct
-{
-    tEplNmtState    m_NewNmtState;
-    tEplNmtEvent    m_NmtEvent;
+typedef struct {
+	tEplNmtState m_NewNmtState;
+	tEplNmtEvent m_NmtEvent;
 
 } tEplEventNmtStateChange;
 
-
 // structure for kEplEventTypeHeartbeat
-typedef struct
-{
-    unsigned int    m_uiNodeId;         // NodeId
-    tEplNmtState    m_NmtState;         // NMT state (remember distinguish between MN / CN)
-    WORD            m_wErrorCode;       // EPL error code in case of NMT state NotActive
+typedef struct {
+	unsigned int m_uiNodeId;	// NodeId
+	tEplNmtState m_NmtState;	// NMT state (remember distinguish between MN / CN)
+	WORD m_wErrorCode;	// EPL error code in case of NMT state NotActive
 
 } tEplHeartbeatEvent;
 
-
-typedef enum
-{
-    kEplNmtNodeEventFound       = 0x00,
-    kEplNmtNodeEventUpdateSw    = 0x01, // application shall update software on CN
-    kEplNmtNodeEventCheckConf   = 0x02, // application / Configuration Manager shall check and update configuration on CN
-    kEplNmtNodeEventUpdateConf  = 0x03, // application / Configuration Manager shall update configuration on CN (check was done by NmtMn module)
-    kEplNmtNodeEventVerifyConf  = 0x04, // application / Configuration Manager shall verify configuration of CN
-    kEplNmtNodeEventReadyToStart= 0x05, // issued if EPL_NMTST_NO_STARTNODE set
-                                        // application must call EplNmtMnuSendNmtCommand(kEplNmtCmdStartNode) manually
-    kEplNmtNodeEventNmtState    = 0x06,
-    kEplNmtNodeEventError       = 0x07, // NMT error of CN
+typedef enum {
+	kEplNmtNodeEventFound = 0x00,
+	kEplNmtNodeEventUpdateSw = 0x01,	// application shall update software on CN
+	kEplNmtNodeEventCheckConf = 0x02,	// application / Configuration Manager shall check and update configuration on CN
+	kEplNmtNodeEventUpdateConf = 0x03,	// application / Configuration Manager shall update configuration on CN (check was done by NmtMn module)
+	kEplNmtNodeEventVerifyConf = 0x04,	// application / Configuration Manager shall verify configuration of CN
+	kEplNmtNodeEventReadyToStart = 0x05,	// issued if EPL_NMTST_NO_STARTNODE set
+	// application must call EplNmtMnuSendNmtCommand(kEplNmtCmdStartNode) manually
+	kEplNmtNodeEventNmtState = 0x06,
+	kEplNmtNodeEventError = 0x07,	// NMT error of CN
 
 } tEplNmtNodeEvent;
 
-
-typedef enum
-{
-    kEplNmtNodeCommandBoot      = 0x01, // if EPL_NODEASSIGN_START_CN not set it must be issued after kEplNmtNodeEventFound
-    kEplNmtNodeCommandSwOk      = 0x02, // application updated software on CN successfully
-    kEplNmtNodeCommandSwUpdated = 0x03, // application updated software on CN successfully
-    kEplNmtNodeCommandConfOk    = 0x04, // application / Configuration Manager has updated configuration on CN successfully
-    kEplNmtNodeCommandConfReset = 0x05, // application / Configuration Manager has updated configuration on CN successfully
-                                        // and CN needs ResetConf so that the configuration gets actived
-    kEplNmtNodeCommandConfErr   = 0x06, // application / Configuration Manager failed on updating configuration on CN
-    kEplNmtNodeCommandStart     = 0x07, // if EPL_NMTST_NO_STARTNODE set it must be issued after kEplNmtNodeEventReadyToStart
+typedef enum {
+	kEplNmtNodeCommandBoot = 0x01,	// if EPL_NODEASSIGN_START_CN not set it must be issued after kEplNmtNodeEventFound
+	kEplNmtNodeCommandSwOk = 0x02,	// application updated software on CN successfully
+	kEplNmtNodeCommandSwUpdated = 0x03,	// application updated software on CN successfully
+	kEplNmtNodeCommandConfOk = 0x04,	// application / Configuration Manager has updated configuration on CN successfully
+	kEplNmtNodeCommandConfReset = 0x05,	// application / Configuration Manager has updated configuration on CN successfully
+	// and CN needs ResetConf so that the configuration gets actived
+	kEplNmtNodeCommandConfErr = 0x06,	// application / Configuration Manager failed on updating configuration on CN
+	kEplNmtNodeCommandStart = 0x07,	// if EPL_NMTST_NO_STARTNODE set it must be issued after kEplNmtNodeEventReadyToStart
 
 } tEplNmtNodeCommand;
 
-
-typedef enum
-{
-    kEplNmtBootEventBootStep1Finish = 0x00, // PreOp2 is possible
-    kEplNmtBootEventBootStep2Finish = 0x01, // ReadyToOp is possible
-    kEplNmtBootEventCheckComFinish  = 0x02, // Operational is possible
-    kEplNmtBootEventOperational     = 0x03, // all mandatory CNs are Operational
-    kEplNmtBootEventError           = 0x04, // boot process halted because of an error
+typedef enum {
+	kEplNmtBootEventBootStep1Finish = 0x00,	// PreOp2 is possible
+	kEplNmtBootEventBootStep2Finish = 0x01,	// ReadyToOp is possible
+	kEplNmtBootEventCheckComFinish = 0x02,	// Operational is possible
+	kEplNmtBootEventOperational = 0x03,	// all mandatory CNs are Operational
+	kEplNmtBootEventError = 0x04,	// boot process halted because of an error
 
 } tEplNmtBootEvent;
 
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-#endif  // #ifndef _EPLNMT_H_
-
-
+#endif // #ifndef _EPLNMT_H_
--- a/drivers/staging/epl/EplObd.h
+++ b/drivers/staging/epl/EplObd.h
@@ -66,7 +66,6 @@
 
   2006/06/02 k.t.:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #include "EplInc.h"
@@ -74,7 +73,6 @@
 #ifndef _EPLOBD_H_
 #define _EPLOBD_H_
 
-
 // ============================================================================
 // defines
 // ============================================================================
@@ -97,43 +95,39 @@
 // ============================================================================
 
 // directions for access to object dictionary
-typedef enum
-{
-    kEplObdDirInit         = 0x00,    // initialising after power on
-    kEplObdDirStore        = 0x01,    // store all object values to non volatile memory
-    kEplObdDirLoad         = 0x02,    // load all object values from non volatile memory
-    kEplObdDirRestore      = 0x03,    // deletes non volatile memory (restore)
-    kEplObdDirOBKCheck     = 0xFF     // reserved
-
-}tEplObdDir;
+typedef enum {
+	kEplObdDirInit = 0x00,	// initialising after power on
+	kEplObdDirStore = 0x01,	// store all object values to non volatile memory
+	kEplObdDirLoad = 0x02,	// load all object values from non volatile memory
+	kEplObdDirRestore = 0x03,	// deletes non volatile memory (restore)
+	kEplObdDirOBKCheck = 0xFF	// reserved
+} tEplObdDir;
 
 // commands for store
-typedef enum
-{
-    kEplObdCommNothing     = 0x00,
-    kEplObdCommOpenWrite   = 0x01,
-    kEplObdCommWriteObj    = 0x02,
-    kEplObdCommCloseWrite  = 0x03,
-    kEplObdCommOpenRead    = 0x04,
-    kEplObdCommReadObj     = 0x05,
-    kEplObdCommCloseRead   = 0x06,
-    kEplObdCommClear       = 0x07,
-    kEplObdCommUnknown     = 0xFF
-}tEplObdCommand;
+typedef enum {
+	kEplObdCommNothing = 0x00,
+	kEplObdCommOpenWrite = 0x01,
+	kEplObdCommWriteObj = 0x02,
+	kEplObdCommCloseWrite = 0x03,
+	kEplObdCommOpenRead = 0x04,
+	kEplObdCommReadObj = 0x05,
+	kEplObdCommCloseRead = 0x06,
+	kEplObdCommClear = 0x07,
+	kEplObdCommUnknown = 0xFF
+} tEplObdCommand;
 
 //-----------------------------------------------------------------------------------------------------------
 // events of object callback function
-typedef enum
-{
+typedef enum {
 //                                                                                                      m_pArg points to
 //                                                                                                    ---------------------
-    kEplObdEvCheckExist            = 0x06,    // checking if object does exist (reading and writing)    NULL
-    kEplObdEvPreRead               = 0x00,    // before reading an object                               source data buffer in OD
-    kEplObdEvPostRead              = 0x01,    // after reading an object                                destination data buffer from caller
-    kEplObdEvWrStringDomain        = 0x07,    // event for changing string/domain data pointer or size  struct tEplObdVStringDomain in RAM
-    kEplObdEvInitWrite             = 0x04,    // initializes writing an object (checking object size)   size of object in OD (tEplObdSize)
-    kEplObdEvPreWrite              = 0x02,    // before writing an object                               source data buffer from caller
-    kEplObdEvPostWrite             = 0x03,    // after writing an object                                destination data buffer in OD
+	kEplObdEvCheckExist = 0x06,	// checking if object does exist (reading and writing)    NULL
+	kEplObdEvPreRead = 0x00,	// before reading an object                               source data buffer in OD
+	kEplObdEvPostRead = 0x01,	// after reading an object                                destination data buffer from caller
+	kEplObdEvWrStringDomain = 0x07,	// event for changing string/domain data pointer or size  struct tEplObdVStringDomain in RAM
+	kEplObdEvInitWrite = 0x04,	// initializes writing an object (checking object size)   size of object in OD (tEplObdSize)
+	kEplObdEvPreWrite = 0x02,	// before writing an object                               source data buffer from caller
+	kEplObdEvPostWrite = 0x03,	// after writing an object                                destination data buffer in OD
 //    kEplObdEvAbortSdo              = 0x05     // after an abort of an SDO transfer
 
 } tEplObdEvent;
@@ -141,29 +135,29 @@ typedef enum
 // part of OD (bit oriented)
 typedef unsigned int tEplObdPart;
 
-#define kEplObdPartNo          0x00    // nothing
-#define kEplObdPartGen         0x01    //  part      (0x1000 - 0x1FFF)
-#define kEplObdPartMan         0x02    // manufacturer part (0x2000 - 0x5FFF)
-#define kEplObdPartDev         0x04    // device part       (0x6000 - 0x9FFF)
-#define kEplObdPartUsr         0x08    // dynamic part e.g. for ICE61131-3
+#define kEplObdPartNo          0x00	// nothing
+#define kEplObdPartGen         0x01	//  part      (0x1000 - 0x1FFF)
+#define kEplObdPartMan         0x02	// manufacturer part (0x2000 - 0x5FFF)
+#define kEplObdPartDev         0x04	// device part       (0x6000 - 0x9FFF)
+#define kEplObdPartUsr         0x08	// dynamic part e.g. for ICE61131-3
 
 // combinations
-#define kEplObdPartApp         (              kEplObdPartMan | kEplObdPartDev | kEplObdPartUsr)   // manufacturer and device part (0x2000 - 0x9FFF) and user OD
-#define kEplObdPartAll         (kEplObdPartGen | kEplObdPartMan | kEplObdPartDev | kEplObdPartUsr)   // whole OD
+#define kEplObdPartApp         (              kEplObdPartMan | kEplObdPartDev | kEplObdPartUsr)	// manufacturer and device part (0x2000 - 0x9FFF) and user OD
+#define kEplObdPartAll         (kEplObdPartGen | kEplObdPartMan | kEplObdPartDev | kEplObdPartUsr)	// whole OD
 
 //-----------------------------------------------------------------------------------------------------------
 // access types for objects
 // must be a difine because bit-flags
 typedef unsigned int tEplObdAccess;
 
-#define kEplObdAccRead         0x01    // object can be read
-#define kEplObdAccWrite        0x02    // object can be written
-#define kEplObdAccConst        0x04    // object contains a constant value
-#define kEplObdAccPdo          0x08    // object can be mapped in a PDO
-#define kEplObdAccArray        0x10    // object contains an array of numerical values
-#define kEplObdAccRange        0x20    // object contains lower and upper limit
-#define kEplObdAccVar          0x40    // object data is placed in application
-#define kEplObdAccStore        0x80    // object data can be stored to non volatile memory
+#define kEplObdAccRead         0x01	// object can be read
+#define kEplObdAccWrite        0x02	// object can be written
+#define kEplObdAccConst        0x04	// object contains a constant value
+#define kEplObdAccPdo          0x08	// object can be mapped in a PDO
+#define kEplObdAccArray        0x10	// object contains an array of numerical values
+#define kEplObdAccRange        0x20	// object contains lower and upper limit
+#define kEplObdAccVar          0x40	// object data is placed in application
+#define kEplObdAccStore        0x80	// object data can be stored to non volatile memory
 
 // combinations (not all combinations are required)
 #define kEplObdAccR            (0            | 0          | 0            | 0          | 0            | 0            | kEplObdAccRead)
@@ -205,10 +199,7 @@ typedef unsigned int tEplObdAccess;
 #define kEplObdAccSVGPW        (kEplObdAccStore | kEplObdAccVar | kEplObdAccRange | kEplObdAccPdo | 0            | kEplObdAccWrite | 0          )
 #define kEplObdAccSVGPRW       (kEplObdAccStore | kEplObdAccVar | kEplObdAccRange | kEplObdAccPdo | 0            | kEplObdAccWrite | kEplObdAccRead)
 
-
-
-typedef unsigned int tEplObdSize; // For all objects as objects size are used an unsigned int.
-
+typedef unsigned int tEplObdSize;	// For all objects as objects size are used an unsigned int.
 
 // -------------------------------------------------------------------------
 // types for data types defined in DS301
@@ -216,108 +207,99 @@ typedef unsigned int tEplObdSize; // For
 
 // types of objects in object dictionary
 // DS-301 defines these types as WORD
-typedef enum
-{
+typedef enum {
 // types which are always supported
-    kEplObdTypBool         = 0x0001,
-
-    kEplObdTypInt8         = 0x0002,
-    kEplObdTypInt16        = 0x0003,
-    kEplObdTypInt32        = 0x0004,
-    kEplObdTypUInt8        = 0x0005,
-    kEplObdTypUInt16       = 0x0006,
-    kEplObdTypUInt32       = 0x0007,
-    kEplObdTypReal32       = 0x0008,
-    kEplObdTypVString      = 0x0009,
-    kEplObdTypOString      = 0x000A,
-    kEplObdTypDomain       = 0x000F,
-
-    kEplObdTypInt24        = 0x0010,
-    kEplObdTypUInt24       = 0x0016,
-
-    kEplObdTypReal64       = 0x0011,
-    kEplObdTypInt40        = 0x0012,
-    kEplObdTypInt48        = 0x0013,
-    kEplObdTypInt56        = 0x0014,
-    kEplObdTypInt64        = 0x0015,
-    kEplObdTypUInt40       = 0x0018,
-    kEplObdTypUInt48       = 0x0019,
-    kEplObdTypUInt56       = 0x001A,
-    kEplObdTypUInt64       = 0x001B,
-    kEplObdTypTimeOfDay    = 0x000C,
-    kEplObdTypTimeDiff     = 0x000D
+	kEplObdTypBool = 0x0001,
 
-}tEplObdType;
+	kEplObdTypInt8 = 0x0002,
+	kEplObdTypInt16 = 0x0003,
+	kEplObdTypInt32 = 0x0004,
+	kEplObdTypUInt8 = 0x0005,
+	kEplObdTypUInt16 = 0x0006,
+	kEplObdTypUInt32 = 0x0007,
+	kEplObdTypReal32 = 0x0008,
+	kEplObdTypVString = 0x0009,
+	kEplObdTypOString = 0x000A,
+	kEplObdTypDomain = 0x000F,
+
+	kEplObdTypInt24 = 0x0010,
+	kEplObdTypUInt24 = 0x0016,
+
+	kEplObdTypReal64 = 0x0011,
+	kEplObdTypInt40 = 0x0012,
+	kEplObdTypInt48 = 0x0013,
+	kEplObdTypInt56 = 0x0014,
+	kEplObdTypInt64 = 0x0015,
+	kEplObdTypUInt40 = 0x0018,
+	kEplObdTypUInt48 = 0x0019,
+	kEplObdTypUInt56 = 0x001A,
+	kEplObdTypUInt64 = 0x001B,
+	kEplObdTypTimeOfDay = 0x000C,
+	kEplObdTypTimeDiff = 0x000D
+} tEplObdType;
 // other types are not supported in this version
 
-
 // -------------------------------------------------------------------------
 // types for data types defined in DS301
 // -------------------------------------------------------------------------
 
-typedef unsigned char       tEplObdBoolean;      // 0001
-typedef signed char         tEplObdInteger8;     // 0002
-typedef signed short int    tEplObdInteger16;    // 0003
-typedef signed long         tEplObdInteger32;    // 0004
-typedef unsigned char       tEplObdUnsigned8;    // 0005
-typedef unsigned short int  tEplObdUnsigned16;   // 0006
-typedef unsigned long       tEplObdUnsigned32;   // 0007
-typedef float               tEplObdReal32;       // 0008
-typedef unsigned char       tEplObdDomain;       // 000F
-typedef signed   long       tEplObdInteger24;    // 0010
-typedef unsigned long       tEplObdUnsigned24;   // 0016
-
-typedef signed QWORD        tEplObdInteger40;    // 0012
-typedef signed QWORD        tEplObdInteger48;    // 0013
-typedef signed QWORD        tEplObdInteger56;    // 0014
-typedef signed QWORD        tEplObdInteger64;    // 0015
-
-typedef unsigned QWORD      tEplObdUnsigned40;   // 0018
-typedef unsigned QWORD      tEplObdUnsigned48;   // 0019
-typedef unsigned QWORD      tEplObdUnsigned56;   // 001A
-typedef unsigned QWORD      tEplObdUnsigned64;   // 001B
-
-typedef double              tEplObdReal64;       // 0011
+typedef unsigned char tEplObdBoolean;	// 0001
+typedef signed char tEplObdInteger8;	// 0002
+typedef signed short int tEplObdInteger16;	// 0003
+typedef signed long tEplObdInteger32;	// 0004
+typedef unsigned char tEplObdUnsigned8;	// 0005
+typedef unsigned short int tEplObdUnsigned16;	// 0006
+typedef unsigned long tEplObdUnsigned32;	// 0007
+typedef float tEplObdReal32;	// 0008
+typedef unsigned char tEplObdDomain;	// 000F
+typedef signed long tEplObdInteger24;	// 0010
+typedef unsigned long tEplObdUnsigned24;	// 0016
+
+typedef signed QWORD tEplObdInteger40;	// 0012
+typedef signed QWORD tEplObdInteger48;	// 0013
+typedef signed QWORD tEplObdInteger56;	// 0014
+typedef signed QWORD tEplObdInteger64;	// 0015
+
+typedef unsigned QWORD tEplObdUnsigned40;	// 0018
+typedef unsigned QWORD tEplObdUnsigned48;	// 0019
+typedef unsigned QWORD tEplObdUnsigned56;	// 001A
+typedef unsigned QWORD tEplObdUnsigned64;	// 001B
 
-typedef tTimeOfDay          tEplObdTimeOfDay;         // 000C
-typedef tTimeOfDay          tEplObdTimeDifference;    // 000D
+typedef double tEplObdReal64;	// 0011
 
+typedef tTimeOfDay tEplObdTimeOfDay;	// 000C
+typedef tTimeOfDay tEplObdTimeDifference;	// 000D
 
 // -------------------------------------------------------------------------
 // structur for defining a variable
 // -------------------------------------------------------------------------
 // -------------------------------------------------------------------------
-typedef enum
-{
-    kVarValidSize           = 0x01,
-    kVarValidData           = 0x02,
+typedef enum {
+	kVarValidSize = 0x01,
+	kVarValidData = 0x02,
 //    kVarValidCallback       = 0x04,
 //    kVarValidArg            = 0x08,
 
-    kVarValidAll            = 0x03  // currently only size and data are implemented and used
-
-}tEplVarParamValid;
+	kVarValidAll = 0x03	// currently only size and data are implemented and used
+} tEplVarParamValid;
 
+typedef tEplKernel(PUBLIC ROM * tEplVarCallback) (CCM_DECL_INSTANCE_HDL_
+						  void *pParam_p);
 
-typedef tEplKernel (PUBLIC ROM* tEplVarCallback) (CCM_DECL_INSTANCE_HDL_
-    void * pParam_p);
-
-typedef struct
-{
-    tEplVarParamValid   m_ValidFlag;
-    unsigned int        m_uiIndex;
-    unsigned int        m_uiSubindex;
-    tEplObdSize         m_Size;
-    void MEM*           m_pData;
+typedef struct {
+	tEplVarParamValid m_ValidFlag;
+	unsigned int m_uiIndex;
+	unsigned int m_uiSubindex;
+	tEplObdSize m_Size;
+	void MEM *m_pData;
 //    tEplVarCallback     m_fpCallback;
 //    void *       m_pArg;
 
 } tEplVarParam;
 
-typedef struct
-{
-    void MEM*           m_pData;
-    tEplObdSize            m_Size;
+typedef struct {
+	void MEM *m_pData;
+	tEplObdSize m_Size;
 /*
     #if (EPL_PDO_USE_STATIC_MAPPING == FALSE)
         tEplVarCallback    m_fpCallback;
@@ -326,45 +308,38 @@ typedef struct
 */
 } tEplObdVarEntry;
 
-typedef struct
-{
-   tEplObdSize      m_Size;
-   BYTE *           m_pString;
-
-} tEplObdOString;                          // 000C
-
-typedef struct
-{
-   tEplObdSize      m_Size;
-   char *           m_pString;
-} tEplObdVString;                          // 000D
-
-
-typedef struct
-{
-    tEplObdSize      m_Size;
-    char *    m_pDefString;         // $$$ d.k. it is unused, so we could delete it
-    char *    m_pString;
+typedef struct {
+	tEplObdSize m_Size;
+	BYTE *m_pString;
+
+} tEplObdOString;		// 000C
+
+typedef struct {
+	tEplObdSize m_Size;
+	char *m_pString;
+} tEplObdVString;		// 000D
+
+typedef struct {
+	tEplObdSize m_Size;
+	char *m_pDefString;	// $$$ d.k. it is unused, so we could delete it
+	char *m_pString;
 
 } tEplObdVStringDef;
 
-typedef struct
-{
-   tEplObdSize      m_Size;
-   BYTE *           m_pDefString;   // $$$ d.k. it is unused, so we could delete it
-   BYTE *           m_pString;
+typedef struct {
+	tEplObdSize m_Size;
+	BYTE *m_pDefString;	// $$$ d.k. it is unused, so we could delete it
+	BYTE *m_pString;
 
 } tEplObdOStringDef;
 
 //r.d. parameter struct for changing object size and/or pointer to data of Strings or Domains
-typedef struct
-{
-   tEplObdSize      m_DownloadSize;     // download size from SDO or APP
-   tEplObdSize      m_ObjSize;          // current object size from OD - should be changed from callback function
-   void *    m_pData;            // current object ptr  from OD - should be changed from callback function
-
-} tEplObdVStringDomain;                          // 000D
+typedef struct {
+	tEplObdSize m_DownloadSize;	// download size from SDO or APP
+	tEplObdSize m_ObjSize;	// current object size from OD - should be changed from callback function
+	void *m_pData;		// current object ptr  from OD - should be changed from callback function
 
+} tEplObdVStringDomain;		// 000D
 
 // ============================================================================
 // types
@@ -374,131 +349,116 @@ typedef struct
 // -------------------------------------------------------------------------
 
 // Change not the order for this struct!!!
-typedef struct
-{
-    unsigned int    m_uiSubIndex;
-    tEplObdType     m_Type;
-    tEplObdAccess   m_Access;
-    void  *  m_pDefault;
-    void  MEM*      m_pCurrent;     // points always to RAM
+typedef struct {
+	unsigned int m_uiSubIndex;
+	tEplObdType m_Type;
+	tEplObdAccess m_Access;
+	void *m_pDefault;
+	void MEM *m_pCurrent;	// points always to RAM
 
 } tEplObdSubEntry;
 
 // r.d.: has always to be  because new OBD-Macros for arrays
-typedef tEplObdSubEntry * tEplObdSubEntryPtr;
+typedef tEplObdSubEntry *tEplObdSubEntryPtr;
 
 // -------------------------------------------------------------------------
 // callback function for objdictionary modul
 // -------------------------------------------------------------------------
 
 // parameters for callback function
-typedef struct
-{
-    tEplObdEvent    m_ObdEvent;
-    unsigned int    m_uiIndex;
-    unsigned int    m_uiSubIndex;
-    void *   m_pArg;
-    DWORD           m_dwAbortCode;
+typedef struct {
+	tEplObdEvent m_ObdEvent;
+	unsigned int m_uiIndex;
+	unsigned int m_uiSubIndex;
+	void *m_pArg;
+	DWORD m_dwAbortCode;
 
 } tEplObdCbParam;
 
 // define type for callback function: pParam_p points to tEplObdCbParam
-typedef tEplKernel (PUBLIC ROM* tEplObdCallback) (CCM_DECL_INSTANCE_HDL_
-    tEplObdCbParam MEM* pParam_p);
+typedef tEplKernel(PUBLIC ROM * tEplObdCallback) (CCM_DECL_INSTANCE_HDL_
+						  tEplObdCbParam MEM *
+						  pParam_p);
 
 // do not change the order for this struct!!!
 
-typedef struct
-{
-    unsigned int        m_uiIndex;
-    tEplObdSubEntryPtr  m_pSubIndex;
-    unsigned int        m_uiCount;
-    tEplObdCallback     m_fpCallback;   // function is called back if object access
+typedef struct {
+	unsigned int m_uiIndex;
+	tEplObdSubEntryPtr m_pSubIndex;
+	unsigned int m_uiCount;
+	tEplObdCallback m_fpCallback;	// function is called back if object access
 
 } tEplObdEntry;
 
-
 // allways  pointer
-typedef tEplObdEntry * tEplObdEntryPtr;
-
-
+typedef tEplObdEntry *tEplObdEntryPtr;
 
 // -------------------------------------------------------------------------
 // structur to initialize OBD module
 // -------------------------------------------------------------------------
 
-typedef struct
-{
-    tEplObdEntryPtr        m_pPart;
-    tEplObdEntryPtr        m_pManufacturerPart;
-    tEplObdEntryPtr        m_pDevicePart;
+typedef struct {
+	tEplObdEntryPtr m_pPart;
+	tEplObdEntryPtr m_pManufacturerPart;
+	tEplObdEntryPtr m_pDevicePart;
 
-    #if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
+#if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
 
-          tEplObdEntryPtr  m_pUserPart;
+	tEplObdEntryPtr m_pUserPart;
 
-    #endif
+#endif
 
 } tEplObdInitParam;
 
-
 // -------------------------------------------------------------------------
 // structur for parameters of STORE RESTORE command
 // -------------------------------------------------------------------------
 
-typedef struct
-{
-    tEplObdCommand  m_bCommand;
-    tEplObdPart        m_bCurrentOdPart;
-    void MEM*       m_pData;
-    tEplObdSize     m_ObjSize;
+typedef struct {
+	tEplObdCommand m_bCommand;
+	tEplObdPart m_bCurrentOdPart;
+	void MEM *m_pData;
+	tEplObdSize m_ObjSize;
 
 } tEplObdCbStoreParam;
 
-
-typedef tEplKernel (PUBLIC ROM* tInitTabEntryCallback) (
-    void MEM* pTabEntry_p,
-    unsigned int uiObjIndex_p);
-
-typedef tEplKernel (PUBLIC ROM* tEplObdStoreLoadObjCallback) (CCM_DECL_INSTANCE_HDL_
-    tEplObdCbStoreParam MEM* pCbStoreParam_p);
+typedef tEplKernel(PUBLIC ROM * tInitTabEntryCallback) (void MEM * pTabEntry_p,
+							unsigned int
+							uiObjIndex_p);
+
+typedef tEplKernel(PUBLIC ROM *
+		   tEplObdStoreLoadObjCallback) (CCM_DECL_INSTANCE_HDL_
+						 tEplObdCbStoreParam MEM *
+						 pCbStoreParam_p);
 
 // -------------------------------------------------------------------------
 // this stucture is used for parameters for function ObdInitModuleTab()
 // -------------------------------------------------------------------------
-typedef struct
-{
-    unsigned int            m_uiLowerObjIndex;  // lower limit of ObjIndex
-    unsigned int            m_uiUpperObjIndex;  // upper limit of ObjIndex
-    tInitTabEntryCallback   m_fpInitTabEntry;   // will be called if ObjIndex was found
-    void MEM*               m_pTabBase;         // base address of table
-    unsigned int            m_uiEntrySize;      // size of table entry      // 25-feb-2005 r.d.: expansion from BYTE to WORD necessary for PDO bit mapping
-    unsigned int            m_uiMaxEntries;     // max. tabel entries
+typedef struct {
+	unsigned int m_uiLowerObjIndex;	// lower limit of ObjIndex
+	unsigned int m_uiUpperObjIndex;	// upper limit of ObjIndex
+	tInitTabEntryCallback m_fpInitTabEntry;	// will be called if ObjIndex was found
+	void MEM *m_pTabBase;	// base address of table
+	unsigned int m_uiEntrySize;	// size of table entry      // 25-feb-2005 r.d.: expansion from BYTE to WORD necessary for PDO bit mapping
+	unsigned int m_uiMaxEntries;	// max. tabel entries
 
 } tEplObdModulTabParam;
 
 //-------------------------------------------------------------------
 //  enum for function EplObdSetNodeId
 //-------------------------------------------------------------------
-typedef enum
-{
-    kEplObdNodeIdUnknown    =   0x00,   // unknown how the node id was set
-    kEplObdNodeIdSoftware   =   0x01,   // node id set by software
-    kEplObdNodeIdHardware   =   0x02    // node id set by hardware
-
-}tEplObdNodeIdType;
+typedef enum {
+	kEplObdNodeIdUnknown = 0x00,	// unknown how the node id was set
+	kEplObdNodeIdSoftware = 0x01,	// node id set by software
+	kEplObdNodeIdHardware = 0x02	// node id set by hardware
+} tEplObdNodeIdType;
 
 // ============================================================================
 // global variables
 // ============================================================================
 
-
-
 // ============================================================================
 // public functions
 // ============================================================================
 
-
-#endif  // #ifndef _EPLOBD_H_
-
-
+#endif // #ifndef _EPLOBD_H_
--- a/drivers/staging/epl/EplObdMacro.h
+++ b/drivers/staging/epl/EplObdMacro.h
@@ -67,11 +67,8 @@
   2006/06/05 k.t.:   start of the implementation
                     -> based on CANopen ObdMacro.h
 
-
-
 ****************************************************************************/
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
@@ -79,284 +76,279 @@
 #if defined (EPL_OBD_DEFINE_MACRO)
 
     //-------------------------------------------------------------------------------------------
-    #if defined (EPL_OBD_CREATE_ROM_DATA)
+#if defined (EPL_OBD_CREATE_ROM_DATA)
 
 //        #pragma message ("EPL_OBD_CREATE_ROM_DATA")
 
-        #define EPL_OBD_BEGIN()                                                         static  DWORD  dwObd_OBK_g = 0x0000;
-        #define EPL_OBD_END()
+#define EPL_OBD_BEGIN()                                                         static  DWORD  dwObd_OBK_g = 0x0000;
+#define EPL_OBD_END()
 
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_PART_GENERIC()
-        #define EPL_OBD_BEGIN_PART_MANUFACTURER()
-        #define EPL_OBD_BEGIN_PART_DEVICE()
-        #define EPL_OBD_END_PART()
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)
-        #define EPL_OBD_END_INDEX(ind)
-        #define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)         static  tEplObdUnsigned8    xDef##ind##_0x00_g = (cnt); \
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_PART_GENERIC()
+#define EPL_OBD_BEGIN_PART_MANUFACTURER()
+#define EPL_OBD_BEGIN_PART_DEVICE()
+#define EPL_OBD_END_PART()
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)
+#define EPL_OBD_END_INDEX(ind)
+#define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)         static  tEplObdUnsigned8    xDef##ind##_0x00_g = (cnt); \
                                                                                         static  dtyp  xDef##ind##_0x01_g = (def);
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)      static  tEplObdUnsigned8    xDef##ind##_0x00_g = (cnt); \
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)      static  tEplObdUnsigned8    xDef##ind##_0x00_g = (cnt); \
                                                                                         static  dtyp  xDef##ind##_0x01_g = (def);
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)   static  tEplObdUnsigned8    xDef##ind##_0x00_g = (cnt);
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)   static  tEplObdUnsigned8    xDef##ind##_0x00_g = (cnt);
 
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)                 static  dtyp  xDef##ind##_##sub##_g        = val;
-        #define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)     static  dtyp  xDef##ind##_##sub##_g[3]     = {val,low,high};
-        #define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)
-        #define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)                 static char  MEM szCur##ind##_##sub##_g[size+1]; \
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)                 static  dtyp  xDef##ind##_##sub##_g        = val;
+#define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)     static  dtyp  xDef##ind##_##sub##_g[3]     = {val,low,high};
+#define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)
+#define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)                 static char  MEM szCur##ind##_##sub##_g[size+1]; \
                                                                                         static  tEplObdVStringDef  xDef##ind##_##sub##_g = {size, val, szCur##ind##_##sub##_g};
 
-        #define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)                     static  BYTE  MEM bCur##ind##_##sub##_g[size]; \
+#define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)                     static  BYTE  MEM bCur##ind##_##sub##_g[size]; \
                                                                                         static  tEplObdOStringDef  xDef##ind##_##sub##_g = {size, ((BYTE*)""), bCur##ind##_##sub##_g};
-        #define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)             static  dtyp  xDef##ind##_##sub##_g        = val;
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high) static  dtyp  xDef##ind##_##sub##_g[3]     = {val,low,high};
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)
+#define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)             static  dtyp  xDef##ind##_##sub##_g        = val;
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high) static  dtyp  xDef##ind##_##sub##_g[3]     = {val,low,high};
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)
 
 //-------------------------------------------------------------------------------------------
-    #elif defined (EPL_OBD_CREATE_RAM_DATA)
+#elif defined (EPL_OBD_CREATE_RAM_DATA)
 
 //        #pragma message ("EPL_OBD_CREATE_RAM_DATA")
 
-        #define EPL_OBD_BEGIN()
-        #define EPL_OBD_END()
+#define EPL_OBD_BEGIN()
+#define EPL_OBD_END()
 
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_PART_GENERIC()
-        #define EPL_OBD_BEGIN_PART_MANUFACTURER()
-        #define EPL_OBD_BEGIN_PART_DEVICE()
-        #define EPL_OBD_END_PART()
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)
-        #define EPL_OBD_END_INDEX(ind)
-        #define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)         static dtyp         MEM axCur##ind##_g[cnt];
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)      static tEplObdVarEntry MEM aVarEntry##ind##_g[cnt];
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)   static tEplObdVarEntry MEM aVarEntry##ind##_g[cnt];
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)                 static dtyp         MEM xCur##ind##_##sub##_g;
-        #define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)     static dtyp         MEM xCur##ind##_##sub##_g;
-        #define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)                 static tEplObdVString  MEM xCur##ind##_##sub##_g;
-        #define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)                     static tEplObdOString  MEM xCur##ind##_##sub##_g;
-        #define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)              static dtyp         MEM xCur##ind##_##sub##_g;
-        #define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)                           static tEplObdVarEntry MEM VarEntry##ind##_##sub##_g;
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)             static tEplObdVarEntry MEM VarEntry##ind##_##sub##_g;
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high) static tEplObdVarEntry MEM VarEntry##ind##_##sub##_g;
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)          static tEplObdVarEntry MEM VarEntry##ind##_##sub##_g;
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_PART_GENERIC()
+#define EPL_OBD_BEGIN_PART_MANUFACTURER()
+#define EPL_OBD_BEGIN_PART_DEVICE()
+#define EPL_OBD_END_PART()
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)
+#define EPL_OBD_END_INDEX(ind)
+#define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)         static dtyp         MEM axCur##ind##_g[cnt];
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)      static tEplObdVarEntry MEM aVarEntry##ind##_g[cnt];
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)   static tEplObdVarEntry MEM aVarEntry##ind##_g[cnt];
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)                 static dtyp         MEM xCur##ind##_##sub##_g;
+#define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)     static dtyp         MEM xCur##ind##_##sub##_g;
+#define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)                 static tEplObdVString  MEM xCur##ind##_##sub##_g;
+#define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)                     static tEplObdOString  MEM xCur##ind##_##sub##_g;
+#define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)              static dtyp         MEM xCur##ind##_##sub##_g;
+#define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)                           static tEplObdVarEntry MEM VarEntry##ind##_##sub##_g;
+#define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)             static tEplObdVarEntry MEM VarEntry##ind##_##sub##_g;
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high) static tEplObdVarEntry MEM VarEntry##ind##_##sub##_g;
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)          static tEplObdVarEntry MEM VarEntry##ind##_##sub##_g;
 
     //-------------------------------------------------------------------------------------------
-    #elif defined (EPL_OBD_CREATE_SUBINDEX_TAB)
+#elif defined (EPL_OBD_CREATE_SUBINDEX_TAB)
 
 //        #pragma message ("EPL_OBD_CREATE_SUBINDEX_TAB")
 
-        #define EPL_OBD_BEGIN()
-        #define EPL_OBD_END()
+#define EPL_OBD_BEGIN()
+#define EPL_OBD_END()
 
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_PART_GENERIC()
-        #define EPL_OBD_BEGIN_PART_MANUFACTURER()
-        #define EPL_OBD_BEGIN_PART_DEVICE()
-        #define EPL_OBD_END_PART()
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)                                   static tEplObdSubEntry MEM aObdSubEntry##ind##Ram_g[cnt]= {
-        #define EPL_OBD_END_INDEX(ind)                                                  EPL_OBD_END_SUBINDEX()};
-        #define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)         static tEplObdSubEntry MEM aObdSubEntry##ind##Ram_g[]= { \
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_PART_GENERIC()
+#define EPL_OBD_BEGIN_PART_MANUFACTURER()
+#define EPL_OBD_BEGIN_PART_DEVICE()
+#define EPL_OBD_END_PART()
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)                                   static tEplObdSubEntry MEM aObdSubEntry##ind##Ram_g[cnt]= {
+#define EPL_OBD_END_INDEX(ind)                                                  EPL_OBD_END_SUBINDEX()};
+#define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)         static tEplObdSubEntry MEM aObdSubEntry##ind##Ram_g[]= { \
                                                                                         {0, kEplObdTypUInt8, kEplObdAccCR,          &xDef##ind##_0x00_g,   NULL}, \
                                                                                         {1, typ,          (acc)|kEplObdAccArray, &xDef##ind##_0x01_g,   &axCur##ind##_g[0]}, \
                                                                                         EPL_OBD_END_SUBINDEX()};
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)      static tEplObdSubEntry MEM aObdSubEntry##ind##Ram_g[]= { \
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)      static tEplObdSubEntry MEM aObdSubEntry##ind##Ram_g[]= { \
                                                                                         {0, kEplObdTypUInt8, kEplObdAccCR,                     &xDef##ind##_0x00_g,   NULL}, \
                                                                                         {1, typ,          (acc)|kEplObdAccArray|kEplObdAccVar, &xDef##ind##_0x01_g,   &aVarEntry##ind##_g[0]}, \
                                                                                         EPL_OBD_END_SUBINDEX()};
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)   static tEplObdSubEntry MEM aObdSubEntry##ind##Ram_g[]= { \
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)   static tEplObdSubEntry MEM aObdSubEntry##ind##Ram_g[]= { \
                                                                                         {0, kEplObdTypUInt8, kEplObdAccCR,                     &xDef##ind##_0x00_g,   NULL}, \
                                                                                         {1, typ,          (acc)|kEplObdAccArray|kEplObdAccVar, NULL,                  &aVarEntry##ind##_g[0]}, \
                                                                                         EPL_OBD_END_SUBINDEX()};
 
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)                 {sub,typ,            (acc),                        &xDef##ind##_##sub##_g,   &xCur##ind##_##sub##_g},
-        #define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)     {sub,typ,            (acc)|kEplObdAccRange,           &xDef##ind##_##sub##_g[0],&xCur##ind##_##sub##_g},
-        #define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)              {sub,typ,            (acc),                        NULL,   &xCur##ind##_##sub##_g},
-        #define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)                 {sub,kEplObdTypVString,(acc)/*|kEplObdAccVar*/,         &xDef##ind##_##sub##_g,   &xCur##ind##_##sub##_g},
-        #define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)                     {sub,kEplObdTypOString,(acc)/*|kEplObdAccVar*/,         &xDef##ind##_##sub##_g,   &xCur##ind##_##sub##_g},
-        #define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)                           {sub,kEplObdTypDomain, (acc)|kEplObdAccVar,             NULL,                     &VarEntry##ind##_##sub##_g},
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)             {sub,typ,           (acc)|kEplObdAccVar,             &xDef##ind##_##sub##_g,   &VarEntry##ind##_##sub##_g},
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high) {sub,typ,           (acc)|kEplObdAccVar|kEplObdAccRange,&xDef##ind##_##sub##_g[0],&VarEntry##ind##_##sub##_g},
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)          {sub,typ,           (acc)|kEplObdAccVar,             NULL,    &VarEntry##ind##_##sub##_g},
-
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)                 {sub,typ,            (acc),                        &xDef##ind##_##sub##_g,   &xCur##ind##_##sub##_g},
+#define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)     {sub,typ,            (acc)|kEplObdAccRange,           &xDef##ind##_##sub##_g[0],&xCur##ind##_##sub##_g},
+#define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)              {sub,typ,            (acc),                        NULL,   &xCur##ind##_##sub##_g},
+#define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)                 {sub,kEplObdTypVString,(acc)/*|kEplObdAccVar*/,         &xDef##ind##_##sub##_g,   &xCur##ind##_##sub##_g},
+#define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)                     {sub,kEplObdTypOString,(acc)/*|kEplObdAccVar*/,         &xDef##ind##_##sub##_g,   &xCur##ind##_##sub##_g},
+#define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)                           {sub,kEplObdTypDomain, (acc)|kEplObdAccVar,             NULL,                     &VarEntry##ind##_##sub##_g},
+#define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)             {sub,typ,           (acc)|kEplObdAccVar,             &xDef##ind##_##sub##_g,   &VarEntry##ind##_##sub##_g},
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high) {sub,typ,           (acc)|kEplObdAccVar|kEplObdAccRange,&xDef##ind##_##sub##_g[0],&VarEntry##ind##_##sub##_g},
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)          {sub,typ,           (acc)|kEplObdAccVar,             NULL,    &VarEntry##ind##_##sub##_g},
 
     //-------------------------------------------------------------------------------------------
-    #elif defined (EPL_OBD_CREATE_INDEX_TAB)
+#elif defined (EPL_OBD_CREATE_INDEX_TAB)
 
 //        #pragma message ("EPL_OBD_CREATE_INDEX_TAB")
 
-        #define EPL_OBD_BEGIN()
-        #define EPL_OBD_END()
+#define EPL_OBD_BEGIN()
+#define EPL_OBD_END()
 
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_PART_GENERIC()                                                   static  tEplObdEntry  aObdTab_g[]      = {
-        #define EPL_OBD_BEGIN_PART_MANUFACTURER()                                       static  tEplObdEntry  aObdTabManufacturer_g[] = {
-        #define EPL_OBD_BEGIN_PART_DEVICE()                                             static  tEplObdEntry  aObdTabDevice_g[]       = {
-        #define EPL_OBD_END_PART()                                                      {EPL_OBD_TABLE_INDEX_END,(tEplObdSubEntryPtr)&dwObd_OBK_g,0,NULL}};
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)                                   {ind,(tEplObdSubEntryPtr)&aObdSubEntry##ind##Ram_g[0],cnt,(tEplObdCallback)call},
-        #define EPL_OBD_END_INDEX(ind)
-        #define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)         {ind,(tEplObdSubEntryPtr)&aObdSubEntry##ind##Ram_g[0],(cnt)+1,(tEplObdCallback)call},
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)      {ind,(tEplObdSubEntryPtr)&aObdSubEntry##ind##Ram_g[0],(cnt)+1,(tEplObdCallback)call},
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)   {ind,(tEplObdSubEntryPtr)&aObdSubEntry##ind##Ram_g[0],(cnt)+1,(tEplObdCallback)call},
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)
-        #define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
-        #define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)
-        #define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)
-        #define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)
-        #define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_PART_GENERIC()                                                   static  tEplObdEntry  aObdTab_g[]      = {
+#define EPL_OBD_BEGIN_PART_MANUFACTURER()                                       static  tEplObdEntry  aObdTabManufacturer_g[] = {
+#define EPL_OBD_BEGIN_PART_DEVICE()                                             static  tEplObdEntry  aObdTabDevice_g[]       = {
+#define EPL_OBD_END_PART()                                                      {EPL_OBD_TABLE_INDEX_END,(tEplObdSubEntryPtr)&dwObd_OBK_g,0,NULL}};
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)                                   {ind,(tEplObdSubEntryPtr)&aObdSubEntry##ind##Ram_g[0],cnt,(tEplObdCallback)call},
+#define EPL_OBD_END_INDEX(ind)
+#define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)         {ind,(tEplObdSubEntryPtr)&aObdSubEntry##ind##Ram_g[0],(cnt)+1,(tEplObdCallback)call},
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)      {ind,(tEplObdSubEntryPtr)&aObdSubEntry##ind##Ram_g[0],(cnt)+1,(tEplObdCallback)call},
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)   {ind,(tEplObdSubEntryPtr)&aObdSubEntry##ind##Ram_g[0],(cnt)+1,(tEplObdCallback)call},
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)
+#define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
+#define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)
+#define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)
+#define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)
+#define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)
 
-            //-------------------------------------------------------------------------------------------
-    #elif defined (EPL_OBD_CREATE_INIT_FUNCTION)
+	    //-------------------------------------------------------------------------------------------
+#elif defined (EPL_OBD_CREATE_INIT_FUNCTION)
 
 //        #pragma message ("EPL_OBD_CREATE_INIT_FUNCTION")
 
-        #define EPL_OBD_BEGIN()
-        #define EPL_OBD_END()
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_PART_GENERIC()                                                   pInitParam->m_pPart      = (tEplObdEntryPtr) &aObdTab_g[0];
-        #define EPL_OBD_BEGIN_PART_MANUFACTURER()                                       pInitParam->m_pManufacturerPart = (tEplObdEntryPtr) &aObdTabManufacturer_g[0];
-        #define EPL_OBD_BEGIN_PART_DEVICE()                                             pInitParam->m_pDevicePart       = (tEplObdEntryPtr) &aObdTabDevice_g[0];
-        #define EPL_OBD_END_PART()
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)
-        #define EPL_OBD_END_INDEX(ind)
-        #define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)
-        #define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
-        #define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)
-        #define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)
-        #define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)
-        #define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)
+#define EPL_OBD_BEGIN()
+#define EPL_OBD_END()
 
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_PART_GENERIC()                                                   pInitParam->m_pPart      = (tEplObdEntryPtr) &aObdTab_g[0];
+#define EPL_OBD_BEGIN_PART_MANUFACTURER()                                       pInitParam->m_pManufacturerPart = (tEplObdEntryPtr) &aObdTabManufacturer_g[0];
+#define EPL_OBD_BEGIN_PART_DEVICE()                                             pInitParam->m_pDevicePart       = (tEplObdEntryPtr) &aObdTabDevice_g[0];
+#define EPL_OBD_END_PART()
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)
+#define EPL_OBD_END_INDEX(ind)
+#define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)
+#define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
+#define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)
+#define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)
+#define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)
+#define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)
 
     //-------------------------------------------------------------------------------------------
-    #elif defined (EPL_OBD_CREATE_INIT_SUBINDEX)
+#elif defined (EPL_OBD_CREATE_INIT_SUBINDEX)
 
 //        #pragma message ("EPL_OBD_CREATE_INIT_SUBINDEX")
 
-        #define EPL_OBD_BEGIN()
-        #define EPL_OBD_END()
+#define EPL_OBD_BEGIN()
+#define EPL_OBD_END()
 
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_PART_GENERIC()
-        #define EPL_OBD_BEGIN_PART_MANUFACTURER()
-        #define EPL_OBD_BEGIN_PART_DEVICE()
-        #define EPL_OBD_END_PART()
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)                                   //CCM_SUBINDEX_RAM_ONLY (EPL_MEMCPY (&aObdSubEntry##ind##Ram_g[0],&aObdSubEntry##ind##Rom_g[0],sizeof(aObdSubEntry##ind##Ram_g)));
-        #define EPL_OBD_END_INDEX(ind)
-        #define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)         //EPL_MEMCPY (&aObdSubEntry##ind##Ram_g[0],&aObdSubEntry##ind##Rom_g[0],sizeof(aObdSubEntry##ind##Ram_g));
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)      //EPL_MEMCPY (&aObdSubEntry##ind##Ram_g[0],&aObdSubEntry##ind##Rom_g[0],sizeof(aObdSubEntry##ind##Ram_g));
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)   //EPL_MEMCPY (&aObdSubEntry##ind##Ram_g[0],&aObdSubEntry##ind##Rom_g[0],sizeof(aObdSubEntry##ind##Ram_g));
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)
-        #define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
-        #define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)
-        #define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)
-        #define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)
-        #define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_PART_GENERIC()
+#define EPL_OBD_BEGIN_PART_MANUFACTURER()
+#define EPL_OBD_BEGIN_PART_DEVICE()
+#define EPL_OBD_END_PART()
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)	//CCM_SUBINDEX_RAM_ONLY (EPL_MEMCPY (&aObdSubEntry##ind##Ram_g[0],&aObdSubEntry##ind##Rom_g[0],sizeof(aObdSubEntry##ind##Ram_g)));
+#define EPL_OBD_END_INDEX(ind)
+#define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)	//EPL_MEMCPY (&aObdSubEntry##ind##Ram_g[0],&aObdSubEntry##ind##Rom_g[0],sizeof(aObdSubEntry##ind##Ram_g));
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)	//EPL_MEMCPY (&aObdSubEntry##ind##Ram_g[0],&aObdSubEntry##ind##Rom_g[0],sizeof(aObdSubEntry##ind##Ram_g));
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)	//EPL_MEMCPY (&aObdSubEntry##ind##Ram_g[0],&aObdSubEntry##ind##Rom_g[0],sizeof(aObdSubEntry##ind##Ram_g));
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)
+#define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
+#define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,size,val)
+#define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)
+#define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)
+#define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)
 
     //-------------------------------------------------------------------------------------------
-    #else
+#else
 
 //        #pragma message ("ELSE OF DEFINE")
 
-        #define EPL_OBD_BEGIN()
-        #define EPL_OBD_END()
+#define EPL_OBD_BEGIN()
+#define EPL_OBD_END()
 
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_PART_GENERIC()
-        #define EPL_OBD_BEGIN_PART_MANUFACTURER()
-        #define EPL_OBD_BEGIN_PART_DEVICE()
-        #define EPL_OBD_END_PART()
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)
-        #define EPL_OBD_END_INDEX(ind)
-        #define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)
-        #define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)
-
-        //---------------------------------------------------------------------------------------
-        #define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)
-        #define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
-        #define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,sizes,val)
-        #define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)
-        #define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)
-        #define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
-        #define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_PART_GENERIC()
+#define EPL_OBD_BEGIN_PART_MANUFACTURER()
+#define EPL_OBD_BEGIN_PART_DEVICE()
+#define EPL_OBD_END_PART()
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_BEGIN_INDEX_RAM(ind,cnt,call)
+#define EPL_OBD_END_INDEX(ind)
+#define EPL_OBD_RAM_INDEX_RAM_ARRAY(ind,cnt,call,typ,acc,dtyp,name,def)
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY(ind,cnt,call,typ,acc,dtyp,name,def)
+#define EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT(ind,cnt,call,typ,acc,dtyp,name)
+
+	//---------------------------------------------------------------------------------------
+#define EPL_OBD_SUBINDEX_RAM_VAR(ind,sub,typ,acc,dtyp,name,val)
+#define EPL_OBD_SUBINDEX_RAM_VAR_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
+#define EPL_OBD_SUBINDEX_RAM_VSTRING(ind,sub,acc,name,sizes,val)
+#define EPL_OBD_SUBINDEX_RAM_OSTRING(ind,sub,acc,name,size)
+#define EPL_OBD_SUBINDEX_RAM_VAR_NOINIT(ind,sub,typ,acc,dtyp,name)
+#define EPL_OBD_SUBINDEX_RAM_DOMAIN(ind,sub,acc,name)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF(ind,sub,typ,acc,dtyp,name,val)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_RG(ind,sub,typ,acc,dtyp,name,val,low,high)
+#define EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT(ind,sub,typ,acc,dtyp,name)
 
-    #endif
+#endif
 
     //-------------------------------------------------------------------------------------------
 #elif defined (EPL_OBD_UNDEFINE_MACRO)
 
 //    #pragma message ("EPL_OBD_UNDEFINE_MACRO")
 
-    #undef EPL_OBD_BEGIN
-    #undef EPL_OBD_END
+#undef EPL_OBD_BEGIN
+#undef EPL_OBD_END
 
     //---------------------------------------------------------------------------------------
-    #undef EPL_OBD_BEGIN_PART_GENERIC
-    #undef EPL_OBD_BEGIN_PART_MANUFACTURER
-    #undef EPL_OBD_BEGIN_PART_DEVICE
-    #undef EPL_OBD_END_PART
+#undef EPL_OBD_BEGIN_PART_GENERIC
+#undef EPL_OBD_BEGIN_PART_MANUFACTURER
+#undef EPL_OBD_BEGIN_PART_DEVICE
+#undef EPL_OBD_END_PART
 
     //---------------------------------------------------------------------------------------
-    #undef EPL_OBD_BEGIN_INDEX_RAM
-    #undef EPL_OBD_END_INDEX
-    #undef EPL_OBD_RAM_INDEX_RAM_ARRAY
-    #undef EPL_OBD_RAM_INDEX_RAM_VARARRAY
-    #undef EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT
+#undef EPL_OBD_BEGIN_INDEX_RAM
+#undef EPL_OBD_END_INDEX
+#undef EPL_OBD_RAM_INDEX_RAM_ARRAY
+#undef EPL_OBD_RAM_INDEX_RAM_VARARRAY
+#undef EPL_OBD_RAM_INDEX_RAM_VARARRAY_NOINIT
 
     //---------------------------------------------------------------------------------------
-    #undef EPL_OBD_SUBINDEX_RAM_VAR
-    #undef EPL_OBD_SUBINDEX_RAM_VAR_RG
-    #undef EPL_OBD_SUBINDEX_RAM_VSTRING
-    #undef EPL_OBD_SUBINDEX_RAM_OSTRING
-    #undef EPL_OBD_SUBINDEX_RAM_VAR_NOINIT
-    #undef EPL_OBD_SUBINDEX_RAM_DOMAIN
-    #undef EPL_OBD_SUBINDEX_RAM_USERDEF
-    #undef EPL_OBD_SUBINDEX_RAM_USERDEF_RG
-    #undef EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT
+#undef EPL_OBD_SUBINDEX_RAM_VAR
+#undef EPL_OBD_SUBINDEX_RAM_VAR_RG
+#undef EPL_OBD_SUBINDEX_RAM_VSTRING
+#undef EPL_OBD_SUBINDEX_RAM_OSTRING
+#undef EPL_OBD_SUBINDEX_RAM_VAR_NOINIT
+#undef EPL_OBD_SUBINDEX_RAM_DOMAIN
+#undef EPL_OBD_SUBINDEX_RAM_USERDEF
+#undef EPL_OBD_SUBINDEX_RAM_USERDEF_RG
+#undef EPL_OBD_SUBINDEX_RAM_USERDEF_NOINIT
 
 #else
 
-    #error "nothing defined"
-
+#error "nothing defined"
 
 #endif
-
-
--- a/drivers/staging/epl/EplObjDef.h
+++ b/drivers/staging/epl/EplObjDef.h
@@ -71,48 +71,43 @@
 #ifndef _EPLOBJDEF_H_
 #define _EPLOBJDEF_H_
 
-
 //---------------------------------------------------------------------------
 // security checks
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // macros to help building OD
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 #if (defined (EPL_OBD_USE_VARIABLE_SUBINDEX_TAB) && (EPL_OBD_USE_VARIABLE_SUBINDEX_TAB != FALSE))
 
-    #define CCM_SUBINDEX_RAM_ONLY(a)    a;
-    #define CCM_SUBINDEX_RAM_ONEOF(a,b) a
+#define CCM_SUBINDEX_RAM_ONLY(a)    a;
+#define CCM_SUBINDEX_RAM_ONEOF(a,b) a
 
 #else
 
-    #define CCM_SUBINDEX_RAM_ONLY(a)
-    #define CCM_SUBINDEX_RAM_ONEOF(a,b) b
+#define CCM_SUBINDEX_RAM_ONLY(a)
+#define CCM_SUBINDEX_RAM_ONEOF(a,b) b
 
 #endif
 
-
 //---------------------------------------------------------------------------
 // To prevent unused memory in subindex tables we need this macro.
 // But not all compilers support to preset the last struct value followed by a comma.
 // Compilers which does not support a comma after last struct value has to place in a dummy subindex.
 #if ((DEV_SYSTEM & _DEV_COMMA_EXT_) != 0)
 
-    #define EPL_OBD_END_SUBINDEX()
-    #define EPL_OBD_MAX_ARRAY_SUBENTRIES    2
+#define EPL_OBD_END_SUBINDEX()
+#define EPL_OBD_MAX_ARRAY_SUBENTRIES    2
 
 #else
 
-    #define EPL_OBD_END_SUBINDEX()          {0,0,0,NULL,NULL}
-    #define EPL_OBD_MAX_ARRAY_SUBENTRIES    3
+#define EPL_OBD_END_SUBINDEX()          {0,0,0,NULL,NULL}
+#define EPL_OBD_MAX_ARRAY_SUBENTRIES    3
 
 #endif
 
-
 //---------------------------------------------------------------------------
 //---------------------------------------------------------------------------
 // globale vars
@@ -123,37 +118,33 @@
 // creation of data in ROM memory
 // -------------------------------------------------------------------------
 #define EPL_OBD_CREATE_ROM_DATA
-    #include "objdict.h"
+#include "objdict.h"
 #undef EPL_OBD_CREATE_ROM_DATA
 
-
 // -------------------------------------------------------------------------
 // creation of data in RAM memory
 // -------------------------------------------------------------------------
 
 #define EPL_OBD_CREATE_RAM_DATA
-    #include "objdict.h"
+#include "objdict.h"
 #undef EPL_OBD_CREATE_RAM_DATA
 
-
 // -------------------------------------------------------------------------
 // creation of subindex tables in ROM and RAM
 // -------------------------------------------------------------------------
 
 #define EPL_OBD_CREATE_SUBINDEX_TAB
-    #include "objdict.h"
+#include "objdict.h"
 #undef EPL_OBD_CREATE_SUBINDEX_TAB
 
-
 // -------------------------------------------------------------------------
 // creation of index tables for generic, manufacturer and device part
 // -------------------------------------------------------------------------
 
 #define EPL_OBD_CREATE_INDEX_TAB
-    #include "objdict.h"
+#include "objdict.h"
 #undef EPL_OBD_CREATE_INDEX_TAB
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -174,47 +165,44 @@
 //
 // ----------------------------------------------------------------------------
 
-EPLDLLEXPORT tEplKernel PUBLIC EPL_OBD_INIT_RAM_NAME (tEplObdInitParam MEM* pInitParam_p)
+EPLDLLEXPORT tEplKernel PUBLIC EPL_OBD_INIT_RAM_NAME(tEplObdInitParam MEM *
+						     pInitParam_p)
 {
 
-tEplObdInitParam MEM* pInitParam = pInitParam_p;
+	tEplObdInitParam MEM *pInitParam = pInitParam_p;
 
-    // check if pointer to parameter structure is valid
-    // if not then only copy subindex tables below
-    if (pInitParam != NULL)
-    {
-        // at first delete all parameters (all pointers will be set zu NULL)
-        EPL_MEMSET (pInitParam, 0, sizeof (tEplObdInitParam));
-
-        #define EPL_OBD_CREATE_INIT_FUNCTION
-        {
-            // inserts code to init pointer to index tables
-            #include "objdict.h"
-        }
-        #undef EPL_OBD_CREATE_INIT_FUNCTION
-
-        #if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
-        {
-            // to begin no user OD is defined
-            pInitParam_p->m_pUserPart = NULL;
-        }
-        #endif
-    }
-
-    #define EPL_OBD_CREATE_INIT_SUBINDEX
-    {
-        // inserts code to copy subindex tables
-        #include "objdict.h"
-    }
-    #undef EPL_OBD_CREATE_INIT_SUBINDEX
+	// check if pointer to parameter structure is valid
+	// if not then only copy subindex tables below
+	if (pInitParam != NULL) {
+		// at first delete all parameters (all pointers will be set zu NULL)
+		EPL_MEMSET(pInitParam, 0, sizeof(tEplObdInitParam));
+
+#define EPL_OBD_CREATE_INIT_FUNCTION
+		{
+			// inserts code to init pointer to index tables
+#include "objdict.h"
+		}
+#undef EPL_OBD_CREATE_INIT_FUNCTION
+
+#if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
+		{
+			// to begin no user OD is defined
+			pInitParam_p->m_pUserPart = NULL;
+		}
+#endif
+	}
+#define EPL_OBD_CREATE_INIT_SUBINDEX
+	{
+		// inserts code to copy subindex tables
+#include "objdict.h"
+	}
+#undef EPL_OBD_CREATE_INIT_SUBINDEX
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 
 }
 
-
 #endif // _EPLOBJDEF_H_
 
 // Die letzte Zeile muß unbedingt eine leere Zeile sein, weil manche Compiler
 // damit ein Problem haben, wenn das nicht so ist (z.B. GNU oder Borland C++ Builder).
-
--- a/drivers/staging/epl/EplPdo.h
+++ b/drivers/staging/epl/EplPdo.h
@@ -66,7 +66,6 @@
 
   2006/05/22 d.k.:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #ifndef _EPL_PDO_H_
@@ -85,42 +84,34 @@
 // NodeId for PRes TPDO
 #define EPL_PDO_PRES_NODE_ID        0x00
 
-
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    void*               m_pVar;
-    WORD                m_wOffset;   // in Bits
-    WORD                m_wSize;     // in Bits
-    BOOL                m_fNumeric;  // numeric value -> use AMI functions
+typedef struct {
+	void *m_pVar;
+	WORD m_wOffset;		// in Bits
+	WORD m_wSize;		// in Bits
+	BOOL m_fNumeric;	// numeric value -> use AMI functions
 
 } tEplPdoMapping;
 
-typedef struct
-{
-    unsigned int        m_uiSizeOfStruct;
-    unsigned int        m_uiPdoId;
-    unsigned int        m_uiNodeId;
-    // 0xFF=invalid, RPDO: 0x00=PReq, localNodeId=PRes, remoteNodeId=PRes
-    //               TPDO: 0x00=PRes, MN: CnNodeId=PReq
-
-    BOOL                m_fTxRx;
-    BYTE                m_bMappingVersion;
-    unsigned int        m_uiMaxMappingEntries; // maximum number of mapping entries, i.e. size of m_aPdoMapping
-    tEplPdoMapping      m_aPdoMapping[1];
+typedef struct {
+	unsigned int m_uiSizeOfStruct;
+	unsigned int m_uiPdoId;
+	unsigned int m_uiNodeId;
+	// 0xFF=invalid, RPDO: 0x00=PReq, localNodeId=PRes, remoteNodeId=PRes
+	//               TPDO: 0x00=PRes, MN: CnNodeId=PReq
+
+	BOOL m_fTxRx;
+	BYTE m_bMappingVersion;
+	unsigned int m_uiMaxMappingEntries;	// maximum number of mapping entries, i.e. size of m_aPdoMapping
+	tEplPdoMapping m_aPdoMapping[1];
 
 } tEplPdoParam;
 
-
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-#endif  // #ifndef _EPL_PDO_H_
-
-
+#endif // #ifndef _EPL_PDO_H_
--- a/drivers/staging/epl/EplSdoAc.h
+++ b/drivers/staging/epl/EplSdoAc.h
@@ -71,7 +71,6 @@
 #ifndef _EPLSDOAC_H_
 #define _EPLSDOAC_H_
 
-
 // =========================================================================
 // SDO abort codes
 // =========================================================================
@@ -106,7 +105,6 @@
 #define    EPL_SDOAC_OBJECT_DICTIONARY_NOT_EXIST         0x08000023L
 #define    EPL_SDOAC_CONFIG_DATA_EMPTY                   0x08000024L
 
-
 #endif // _EPLSDOAC_H_
 
 // Die letzte Zeile muß unbedingt eine leere Zeile sein, weil manche Compiler
--- a/drivers/staging/epl/EplSdo.h
+++ b/drivers/staging/epl/EplSdo.h
@@ -66,7 +66,6 @@
 
  2006/06/26 k.t.:   start of the implementation
 
-
 ****************************************************************************/
 
 #include "EplInc.h"
@@ -76,7 +75,6 @@
 #ifndef _EPLSDO_H_
 #define _EPLSDO_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
@@ -118,64 +116,58 @@ typedef unsigned int tEplSdoConHdl;
 
 // callback function pointer for Protocol Abstraction Layer to call
 // asynchronuus SDO Sequence Layer
-typedef tEplKernel (PUBLIC* tEplSequLayerReceiveCb ) (
-    tEplSdoConHdl       ConHdl_p,
-    tEplAsySdoSeq*      pSdoSeqData_p,
-    unsigned int        uiDataSize_p);
+typedef tEplKernel(PUBLIC * tEplSequLayerReceiveCb) (tEplSdoConHdl ConHdl_p,
+						     tEplAsySdoSeq *
+						     pSdoSeqData_p,
+						     unsigned int uiDataSize_p);
 
 // handle between asynchronuus SDO Sequence Layer and SDO Command layer
 typedef unsigned int tEplSdoSeqConHdl;
 
 // callback function pointer for asynchronuus SDO Sequence Layer to call
 // SDO Command layer for received data
-typedef tEplKernel (PUBLIC* tEplSdoComReceiveCb) (
-    tEplSdoSeqConHdl    SdoSeqConHdl_p,
-    tEplAsySdoCom*      pAsySdoCom_p,
-    unsigned int        uiDataSize_p);
+typedef tEplKernel(PUBLIC *
+		   tEplSdoComReceiveCb) (tEplSdoSeqConHdl SdoSeqConHdl_p,
+					 tEplAsySdoCom * pAsySdoCom_p,
+					 unsigned int uiDataSize_p);
 
 // status of connection
-typedef enum
-{
-    kAsySdoConStateConnected    = 0x00,
-    kAsySdoConStateInitError    = 0x01,
-    kAsySdoConStateConClosed    = 0x02,
-    kAsySdoConStateAckReceived  = 0x03,
-    kAsySdoConStateFrameSended  = 0x04,
-    kAsySdoConStateTimeout      = 0x05
-
-}tEplAsySdoConState;
+typedef enum {
+	kAsySdoConStateConnected = 0x00,
+	kAsySdoConStateInitError = 0x01,
+	kAsySdoConStateConClosed = 0x02,
+	kAsySdoConStateAckReceived = 0x03,
+	kAsySdoConStateFrameSended = 0x04,
+	kAsySdoConStateTimeout = 0x05
+} tEplAsySdoConState;
 
 // callback function pointer for asynchronuus SDO Sequence Layer to call
 // SDO Command layer for connection status
-typedef tEplKernel (PUBLIC* tEplSdoComConCb) (
-    tEplSdoSeqConHdl    SdoSeqConHdl_p,
-    tEplAsySdoConState  AsySdoConState_p);
+typedef tEplKernel(PUBLIC * tEplSdoComConCb) (tEplSdoSeqConHdl SdoSeqConHdl_p,
+					      tEplAsySdoConState
+					      AsySdoConState_p);
 
 // handle between  SDO Command layer and application
 typedef unsigned int tEplSdoComConHdl;
 
 // status of connection
-typedef enum
-{
-    kEplSdoComTransferNotActive         =   0x00,
-    kEplSdoComTransferRunning           =   0x01,
-    kEplSdoComTransferTxAborted         =   0x02,
-    kEplSdoComTransferRxAborted         =   0x03,
-    kEplSdoComTransferFinished          =   0x04,
-    kEplSdoComTransferLowerLayerAbort   =   0x05
-
+typedef enum {
+	kEplSdoComTransferNotActive = 0x00,
+	kEplSdoComTransferRunning = 0x01,
+	kEplSdoComTransferTxAborted = 0x02,
+	kEplSdoComTransferRxAborted = 0x03,
+	kEplSdoComTransferFinished = 0x04,
+	kEplSdoComTransferLowerLayerAbort = 0x05
 } tEplSdoComConState;
 
 // SDO Services and Command-Ids from DS 1.0.0 p.152
-typedef enum
-{
-    kEplSdoServiceNIL               = 0x00,
-    kEplSdoServiceWriteByIndex      = 0x01,
-    kEplSdoServiceReadByIndex       = 0x02
-
-    //--------------------------------
-    // the following services are optional and
-    // not supported now
+typedef enum {
+	kEplSdoServiceNIL = 0x00,
+	kEplSdoServiceWriteByIndex = 0x01,
+	kEplSdoServiceReadByIndex = 0x02
+	    //--------------------------------
+	    // the following services are optional and
+	    // not supported now
 /*
     kEplSdoServiceWriteAllByIndex   = 0x03,
     kEplSdoServiceReadAllByIndex    = 0x04,
@@ -196,76 +188,58 @@ typedef enum
 } tEplSdoServiceType;
 
 // describes if read or write access
-typedef enum
-{
-    kEplSdoAccessTypeRead   = 0x00,
-    kEplSdoAccessTypeWrite  = 0x01
-
+typedef enum {
+	kEplSdoAccessTypeRead = 0x00,
+	kEplSdoAccessTypeWrite = 0x01
 } tEplSdoAccessType;
 
-typedef enum
-{
-    kEplSdoTypeAuto  =   0x00,
-    kEplSdoTypeUdp   =   0x01,
-    kEplSdoTypeAsnd  =   0x02,
-    kEplSdoTypePdo   =   0x03
-
-}tEplSdoType;
-
-typedef enum
-{
-    kEplSdoTransAuto             =   0x00,
-    kEplSdoTransExpedited        =   0x01,
-    kEplSdoTransSegmented        =   0x02
-
-
+typedef enum {
+	kEplSdoTypeAuto = 0x00,
+	kEplSdoTypeUdp = 0x01,
+	kEplSdoTypeAsnd = 0x02,
+	kEplSdoTypePdo = 0x03
+} tEplSdoType;
+
+typedef enum {
+	kEplSdoTransAuto = 0x00,
+	kEplSdoTransExpedited = 0x01,
+	kEplSdoTransSegmented = 0x02
 } tEplSdoTransType;
 
-
 // structure to inform application about finish of SDO transfer
-typedef struct
-{
-    tEplSdoComConHdl    m_SdoComConHdl;
-    tEplSdoComConState  m_SdoComConState;
-    DWORD               m_dwAbortCode;
-    tEplSdoAccessType   m_SdoAccessType;
-    unsigned int        m_uiNodeId;         // NodeId of the target
-    unsigned int        m_uiTargetIndex;    // index which was accessed
-    unsigned int        m_uiTargetSubIndex; // subindex which was accessed
-    unsigned int        m_uiTransferredByte; // number of bytes transferred
-    void*               m_pUserArg;         // user definable argument pointer
+typedef struct {
+	tEplSdoComConHdl m_SdoComConHdl;
+	tEplSdoComConState m_SdoComConState;
+	DWORD m_dwAbortCode;
+	tEplSdoAccessType m_SdoAccessType;
+	unsigned int m_uiNodeId;	// NodeId of the target
+	unsigned int m_uiTargetIndex;	// index which was accessed
+	unsigned int m_uiTargetSubIndex;	// subindex which was accessed
+	unsigned int m_uiTransferredByte;	// number of bytes transferred
+	void *m_pUserArg;	// user definable argument pointer
 
 } tEplSdoComFinished;
 
-
 // callback function pointer to inform application about connection
-typedef tEplKernel (PUBLIC* tEplSdoFinishedCb) (
-    tEplSdoComFinished* pSdoComFinished_p);
-
+typedef tEplKernel(PUBLIC * tEplSdoFinishedCb) (tEplSdoComFinished *
+						pSdoComFinished_p);
 
 // structure to init SDO transfer to Read or Write by Index
-typedef struct
-{
-    tEplSdoComConHdl    m_SdoComConHdl;
-    unsigned int        m_uiIndex;
-    unsigned int        m_uiSubindex;
-    void*               m_pData;
-    unsigned int        m_uiDataSize;
-    unsigned int        m_uiTimeout;    // not used in this version
-    tEplSdoAccessType   m_SdoAccessType;
-    tEplSdoFinishedCb   m_pfnSdoFinishedCb;
-    void*               m_pUserArg;         // user definable argument pointer
+typedef struct {
+	tEplSdoComConHdl m_SdoComConHdl;
+	unsigned int m_uiIndex;
+	unsigned int m_uiSubindex;
+	void *m_pData;
+	unsigned int m_uiDataSize;
+	unsigned int m_uiTimeout;	// not used in this version
+	tEplSdoAccessType m_SdoAccessType;
+	tEplSdoFinishedCb m_pfnSdoFinishedCb;
+	void *m_pUserArg;	// user definable argument pointer
 
 } tEplSdoComTransParamByIndex;
 
-
-
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-#endif  // #ifndef _EPLSDO_H_
-
-
+#endif // #ifndef _EPLSDO_H_
--- a/drivers/staging/epl/EplTarget.h
+++ b/drivers/staging/epl/EplTarget.h
@@ -66,13 +66,11 @@
 
   2005/12/05 -as:   start of the implementation, version 1.00
 
-
 ****************************************************************************/
 
 #ifndef _EPLTARGET_H_
 #define _EPLTARGET_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
@@ -87,137 +85,132 @@
 
 #if (TARGET_SYSTEM == _WIN32_)
 
-    #define _WIN32_WINDOWS 0x0401
-    #define _WIN32_WINNT   0x0400
+#define _WIN32_WINDOWS 0x0401
+#define _WIN32_WINNT   0x0400
 
-    #include <stdlib.h>
-    #include <stdio.h>
+#include <stdlib.h>
+#include <stdio.h>
 
     //29.11.2004 f.j. sonst ist memcpy und memset unbekannt
-    #include <string.h>
+#include <string.h>
 
-    #define EPL_MEMCPY(dst,src,siz)     memcpy((void*)(dst),(const void*)(src),(size_t)(siz));
-    #define EPL_MEMSET(dst,val,siz)     memset((void*)(dst),(int)(val),(size_t)(siz));
+#define EPL_MEMCPY(dst,src,siz)     memcpy((void*)(dst),(const void*)(src),(size_t)(siz));
+#define EPL_MEMSET(dst,val,siz)     memset((void*)(dst),(int)(val),(size_t)(siz));
 
     // f.j.: die Funktionen für <MemAlloc> und <MemFree> sind in WinMem.c definiert
     //definition der Prototypen
-    void FAR*  MemAlloc (DWORD dwMemSize_p);
-    void       MemFree (void FAR* pMem_p);
+void FAR *MemAlloc(DWORD dwMemSize_p);
+void MemFree(void FAR * pMem_p);
 
-    #define EPL_MALLOC(siz)             malloc((size_t)(siz))
-    #define EPL_FREE(ptr)               free((void *)ptr)
+#define EPL_MALLOC(siz)             malloc((size_t)(siz))
+#define EPL_FREE(ptr)               free((void *)ptr)
+
+#ifndef PRINTF0
+void trace(const char *fmt, ...);
+#define PRINTF                      TRACE
+#define PRINTF0(arg)                TRACE0(arg)
+#define PRINTF1(arg,p1)             TRACE1(arg,p1)
+#define PRINTF2(arg,p1,p2)          TRACE2(arg,p1,p2)
+#define PRINTF3(arg,p1,p2,p3)       TRACE3(arg,p1,p2,p3)
+#define PRINTF4(arg,p1,p2,p3,p4)    TRACE4(arg,p1,p2,p3,p4)
+	//#define PRINTF                      printf
+	//#define PRINTF0(arg)                PRINTF(arg)
+	//#define PRINTF1(arg,p1)             PRINTF(arg,p1)
+	//#define PRINTF2(arg,p1,p2)          PRINTF(arg,p1,p2)
+	//#define PRINTF3(arg,p1,p2,p3)       PRINTF(arg,p1,p2,p3)
+	//#define PRINTF4(arg,p1,p2,p3,p4)    PRINTF(arg,p1,p2,p3,p4)
+#endif
 
-    #ifndef PRINTF0
-        void trace (const char* fmt, ...);
-        #define PRINTF                      TRACE
-        #define PRINTF0(arg)                TRACE0(arg)
-        #define PRINTF1(arg,p1)             TRACE1(arg,p1)
-        #define PRINTF2(arg,p1,p2)          TRACE2(arg,p1,p2)
-        #define PRINTF3(arg,p1,p2,p3)       TRACE3(arg,p1,p2,p3)
-        #define PRINTF4(arg,p1,p2,p3,p4)    TRACE4(arg,p1,p2,p3,p4)
-        //#define PRINTF                      printf
-        //#define PRINTF0(arg)                PRINTF(arg)
-        //#define PRINTF1(arg,p1)             PRINTF(arg,p1)
-        //#define PRINTF2(arg,p1,p2)          PRINTF(arg,p1,p2)
-        //#define PRINTF3(arg,p1,p2,p3)       PRINTF(arg,p1,p2,p3)
-        //#define PRINTF4(arg,p1,p2,p3,p4)    PRINTF(arg,p1,p2,p3,p4)
-    #endif
-
-    #ifdef ASSERTMSG
-        #undef ASSERTMSG
-    #endif
+#ifdef ASSERTMSG
+#undef ASSERTMSG
+#endif
 
-    #define ASSERTMSG(expr,string)  if (!(expr)) { \
+#define ASSERTMSG(expr,string)  if (!(expr)) { \
                                         MessageBox (NULL, string, "Assertion failed", MB_OK | MB_ICONERROR); \
                                         exit (-1);}
 
-
-
 #elif (TARGET_SYSTEM == _NO_OS_)
 
-    #include <stdlib.h>
-    #include <stdio.h>
+#include <stdlib.h>
+#include <stdio.h>
 
     //29.11.2004 f.j. sonst ist memcpy und memset unbekannt
 //    #include <string.h>
 
-    #define EPL_MEMCPY(dst,src,siz)     memcpy((void*)(dst),(const void*)(src),(size_t)(siz));
-    #define EPL_MEMSET(dst,val,siz)     memset((void*)(dst),(int)(val),(size_t)(siz));
-
-    #define EPL_MALLOC(siz)             malloc((size_t)(siz))
-    #define EPL_FREE(ptr)               free((void *)ptr)
+#define EPL_MEMCPY(dst,src,siz)     memcpy((void*)(dst),(const void*)(src),(size_t)(siz));
+#define EPL_MEMSET(dst,val,siz)     memset((void*)(dst),(int)(val),(size_t)(siz));
 
-    #ifndef PRINTF0
-        #define PRINTF                      TRACE
-        #define PRINTF0(arg)                TRACE0(arg)
-        #define PRINTF1(arg,p1)             TRACE1(arg,p1)
-        #define PRINTF2(arg,p1,p2)          TRACE2(arg,p1,p2)
-        #define PRINTF3(arg,p1,p2,p3)       TRACE3(arg,p1,p2,p3)
-        #define PRINTF4(arg,p1,p2,p3,p4)    TRACE4(arg,p1,p2,p3,p4)
-        //#define PRINTF                      printf
-        //#define PRINTF0(arg)                PRINTF(arg)
-        //#define PRINTF1(arg,p1)             PRINTF(arg,p1)
-        //#define PRINTF2(arg,p1,p2)          PRINTF(arg,p1,p2)
-        //#define PRINTF3(arg,p1,p2,p3)       PRINTF(arg,p1,p2,p3)
-        //#define PRINTF4(arg,p1,p2,p3,p4)    PRINTF(arg,p1,p2,p3,p4)
-    #endif
+#define EPL_MALLOC(siz)             malloc((size_t)(siz))
+#define EPL_FREE(ptr)               free((void *)ptr)
 
+#ifndef PRINTF0
+#define PRINTF                      TRACE
+#define PRINTF0(arg)                TRACE0(arg)
+#define PRINTF1(arg,p1)             TRACE1(arg,p1)
+#define PRINTF2(arg,p1,p2)          TRACE2(arg,p1,p2)
+#define PRINTF3(arg,p1,p2,p3)       TRACE3(arg,p1,p2,p3)
+#define PRINTF4(arg,p1,p2,p3,p4)    TRACE4(arg,p1,p2,p3,p4)
+	//#define PRINTF                      printf
+	//#define PRINTF0(arg)                PRINTF(arg)
+	//#define PRINTF1(arg,p1)             PRINTF(arg,p1)
+	//#define PRINTF2(arg,p1,p2)          PRINTF(arg,p1,p2)
+	//#define PRINTF3(arg,p1,p2,p3)       PRINTF(arg,p1,p2,p3)
+	//#define PRINTF4(arg,p1,p2,p3,p4)    PRINTF(arg,p1,p2,p3,p4)
+#endif
 
 #elif (TARGET_SYSTEM == _LINUX_)
 
-    #ifndef __KERNEL__
-        #include <stdlib.h>
-        #include <stdio.h>
-    #else
+#ifndef __KERNEL__
+#include <stdlib.h>
+#include <stdio.h>
+#else
 //        #include <linux/config.h>
-        #include <linux/module.h>
-        #include <linux/kernel.h>
-        #include <linux/init.h>
-        #include <linux/errno.h>
-        #include <linux/major.h>
-        #include <linux/version.h>
-    #endif
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/version.h>
+#endif
 
     //29.11.2004 f.j. sonst ist memcpy und memset unbekannt
 //    #include <string.h>
 
-    #define EPL_MEMCPY(dst,src,siz)     memcpy((void*)(dst),(const void*)(src),(size_t)(siz));
-    #define EPL_MEMSET(dst,val,siz)     memset((void*)(dst),(int)(val),(size_t)(siz));
+#define EPL_MEMCPY(dst,src,siz)     memcpy((void*)(dst),(const void*)(src),(size_t)(siz));
+#define EPL_MEMSET(dst,val,siz)     memset((void*)(dst),(int)(val),(size_t)(siz));
 
-    #ifndef __KERNEL__
-        #define EPL_MALLOC(siz)             malloc((size_t)(siz))
-        #define EPL_FREE(ptr)               free((void *)ptr)
-    #else
-        #define EPL_MALLOC(siz)             kmalloc((size_t)(siz), GFP_KERNEL)
-        #define EPL_FREE(ptr)               kfree((void *)ptr)
-    #endif
-
-    #ifndef PRINTF0
-        #define PRINTF                      TRACE
-        #define PRINTF0(arg)                TRACE0(arg)
-        #define PRINTF1(arg,p1)             TRACE1(arg,p1)
-        #define PRINTF2(arg,p1,p2)          TRACE2(arg,p1,p2)
-        #define PRINTF3(arg,p1,p2,p3)       TRACE3(arg,p1,p2,p3)
-        #define PRINTF4(arg,p1,p2,p3,p4)    TRACE4(arg,p1,p2,p3,p4)
-        //#define PRINTF                      printf
-        //#define PRINTF0(arg)                PRINTF(arg)
-        //#define PRINTF1(arg,p1)             PRINTF(arg,p1)
-        //#define PRINTF2(arg,p1,p2)          PRINTF(arg,p1,p2)
-        //#define PRINTF3(arg,p1,p2,p3)       PRINTF(arg,p1,p2,p3)
-        //#define PRINTF4(arg,p1,p2,p3,p4)    PRINTF(arg,p1,p2,p3,p4)
-    #endif
+#ifndef __KERNEL__
+#define EPL_MALLOC(siz)             malloc((size_t)(siz))
+#define EPL_FREE(ptr)               free((void *)ptr)
+#else
+#define EPL_MALLOC(siz)             kmalloc((size_t)(siz), GFP_KERNEL)
+#define EPL_FREE(ptr)               kfree((void *)ptr)
+#endif
 
+#ifndef PRINTF0
+#define PRINTF                      TRACE
+#define PRINTF0(arg)                TRACE0(arg)
+#define PRINTF1(arg,p1)             TRACE1(arg,p1)
+#define PRINTF2(arg,p1,p2)          TRACE2(arg,p1,p2)
+#define PRINTF3(arg,p1,p2,p3)       TRACE3(arg,p1,p2,p3)
+#define PRINTF4(arg,p1,p2,p3,p4)    TRACE4(arg,p1,p2,p3,p4)
+	//#define PRINTF                      printf
+	//#define PRINTF0(arg)                PRINTF(arg)
+	//#define PRINTF1(arg,p1)             PRINTF(arg,p1)
+	//#define PRINTF2(arg,p1,p2)          PRINTF(arg,p1,p2)
+	//#define PRINTF3(arg,p1,p2,p3)       PRINTF(arg,p1,p2,p3)
+	//#define PRINTF4(arg,p1,p2,p3,p4)    PRINTF(arg,p1,p2,p3,p4)
+#endif
 
 #endif
 
-#define EPL_TGT_INTMASK_ETH     0x0001  // ethernet interrupt
-#define EPL_TGT_INTMASK_DMA     0x0002  // DMA interrupt
+#define EPL_TGT_INTMASK_ETH     0x0001	// ethernet interrupt
+#define EPL_TGT_INTMASK_DMA     0x0002	// DMA interrupt
 
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
@@ -231,10 +224,10 @@
 // functions for ethernet driver
 tEplKernel PUBLIC TgtInitEthIsr(void);
 void PUBLIC TgtFreeEthIsr(void);
-void  PUBLIC  TgtEnableGlobalInterrupt(BYTE fEnable_p);
-void PUBLIC TgtEnableEthInterrupt0(BYTE fEnable_p, unsigned int uiInterruptMask_p);
-void PUBLIC TgtEnableEthInterrupt1(BYTE fEnable_p, unsigned int uiInterruptMask_p);
-
-#endif  // #ifndef _EPLTARGET_H_
-
+void PUBLIC TgtEnableGlobalInterrupt(BYTE fEnable_p);
+void PUBLIC TgtEnableEthInterrupt0(BYTE fEnable_p,
+				   unsigned int uiInterruptMask_p);
+void PUBLIC TgtEnableEthInterrupt1(BYTE fEnable_p,
+				   unsigned int uiInterruptMask_p);
 
+#endif // #ifndef _EPLTARGET_H_
--- a/drivers/staging/epl/EplTimer.h
+++ b/drivers/staging/epl/EplTimer.h
@@ -66,7 +66,6 @@
 
   2006/07/06 k.t.:   start of the implementation
 
-
 ****************************************************************************/
 
 #include "EplInc.h"
@@ -75,12 +74,10 @@
 #ifndef _EPLTIMER_H_
 #define _EPLTIMER_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // typedef
 //---------------------------------------------------------------------------
@@ -88,38 +85,33 @@
 // type for timer handle
 typedef unsigned long tEplTimerHdl;
 
-typedef struct
-{
-    tEplEventSink   m_EventSink;
-    unsigned long   m_ulArg;    // d.k.: converted to unsigned long because
-                                // it is never accessed as a pointer by the
-                                // timer module and the data the
-                                // pointer points to is not saved in any way.
-                                // It is just a value. The user is responsible
-                                // to store the data statically and convert
-                                // the pointer between address spaces.
+typedef struct {
+	tEplEventSink m_EventSink;
+	unsigned long m_ulArg;	// d.k.: converted to unsigned long because
+	// it is never accessed as a pointer by the
+	// timer module and the data the
+	// pointer points to is not saved in any way.
+	// It is just a value. The user is responsible
+	// to store the data statically and convert
+	// the pointer between address spaces.
 
 } tEplTimerArg;
 
-typedef struct
-{
-    tEplTimerHdl    m_TimerHdl;
-    unsigned long   m_ulArg;    // d.k.: converted to unsigned long because
-                                // it is never accessed as a pointer by the
-                                // timer module and the data the
-                                // pointer points to is not saved in any way.
-                                // It is just a value.
+typedef struct {
+	tEplTimerHdl m_TimerHdl;
+	unsigned long m_ulArg;	// d.k.: converted to unsigned long because
+	// it is never accessed as a pointer by the
+	// timer module and the data the
+	// pointer points to is not saved in any way.
+	// It is just a value.
 
 } tEplTimerEventArg;
 
-typedef tEplKernel (PUBLIC * tEplTimerkCallback) (
-    tEplTimerEventArg* pEventArg_p);
+typedef tEplKernel(PUBLIC * tEplTimerkCallback) (tEplTimerEventArg *
+						 pEventArg_p);
 
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
 
-
-#endif  // #ifndef _EPLTIMER_H_
-
-
+#endif // #ifndef _EPLTIMER_H_
--- a/drivers/staging/epl/EplVersion.h
+++ b/drivers/staging/epl/EplVersion.h
@@ -70,7 +70,6 @@
 #ifndef _EPL_VERSION_H_
 #define _EPL_VERSION_H_
 
-
 // NOTE:
 // All version macros should contain the same version number. But do not use
 // defines instead of the numbers. Because the macro EPL_STRING_VERSION() can not
@@ -85,14 +84,13 @@
 #define DEFINED_OBJ1018_VERSION     EPL_OBJ1018_VERSION (1, 3, 0)
 #define DEFINED_STRING_VERSION      EPL_STRING_VERSION  (1, 3, 0)
 
-
 // -----------------------------------------------------------------------------
 #define EPL_PRODUCT_NAME            "EPL V2"
 #define EPL_PRODUCT_VERSION         DEFINED_STRING_VERSION
 #define EPL_PRODUCT_MANUFACTURER    "SYS TEC electronic GmbH"
 
-    #define EPL_PRODUCT_KEY         "SO-1083"
-    #define EPL_PRODUCT_DESCRIPTION "openPOWERLINK Protocol Stack Source"
+#define EPL_PRODUCT_KEY         "SO-1083"
+#define EPL_PRODUCT_DESCRIPTION "openPOWERLINK Protocol Stack Source"
 
 #endif // _EPL_VERSION_H_
 
--- a/drivers/staging/epl/global.h
+++ b/drivers/staging/epl/global.h
@@ -22,50 +22,49 @@
 #ifndef _GLOBAL_H_
 #define _GLOBAL_H_
 
-
 //---------------------------------------------------------------------------
 //  elements of defines for development system
 //---------------------------------------------------------------------------
 
 // these defines are necessary to check some of characteristics of the development system
-#define _DEV_BIGEND_            0x80000000L     // big endian (motorolla format)
-#define _DEV_ALIGNMENT_4_       0x00400000L     //                  the CPU needs alignment of 4 bytes
-#define _DEV_ONLY_INT_MAIN_     0x00004000L     //                  the compiler needs "int main(int)" instead of "void main(void)"
-#define _DEV_COMMA_EXT_         0x00002000L     //                  support of last comma in struct predefinition
-#define _DEV_64BIT_SUPPORT_     0x00001000L     //                  support of 64 bit operations
-#define _DEV_BIT64_             0x00000400L     // count of bits:   64 bit
-#define _DEV_BIT32_             0x00000300L     //                  32 bit
-#define _DEV_BIT16_             0x00000200L     //                  16 bit
-#define _DEV_BIT8_              0x00000100L     //                  8 bit
-#define _DEV_RVCT_ARM_          0x0000001CL     //                  RealView ARM
-#define _DEV_RENESASM32C        0x0000001BL     // compiler from:   Renesas
-#define _DEV_GNUC_MIPS2_        0x0000001AL     //                  GNU for MIPS2
-#define _DEV_MPLAB_C30_         0x00000019L     //                  MPLAB C30 for Microchip dsPIC33F series
-#define _DEV_GNUC_TC_           0x00000018L     //                  GNU for Infineon TriCore
-#define _DEV_GNUC_X86_          0x00000017L     //                  GNU for I386
-#define _DEV_IAR_ARM_           0x00000016L     //                  ARM IAR C/C++ Compiler
-#define _DEV_PARADGM_X86        0x00000015L     //                  Paradigm C/C++ for Beck 1x3
-#define _DEV_GNUC_CF_           0x00000014L     //                  GNU for Coldfire
-#define _DEV_KEIL_ARM_          0x00000013L     //                  Keil ARM
-#define _DEV_MSEVC_             0x00000012L     //                  Microsoft embedded Visual C/C++
-#define _DEV_HIGHTEC_GNUC_X86_  0x00000011L     //                  Hightec elf386 gcc
-#define _DEV_MSVC_RTX_          0x00000010L     //                  VC600 + RTX
-#define _DEV_MSVC_V1_5_         0x0000000FL     //                  Microsoft Visual C/C++ V1.5
-#define _DEV_GNUC_ARM7_         0x0000000EL     //                  GNU Compiler gcc for ARM7
-#define _DEV_METROWERKS_CW_     0x0000000DL     //                  Metrowerks Code Warrior
-#define _DEV_MITSUBISHIM16C_    0x0000000CL     //compiler from:    Mitsubishi
-#define _DEV_GNUC_C16X_         0x0000000BL     //                  GNU Compiler gcc166 for Infineon C16x
-#define _DEV_LINUX_GCC_         0x0000000AL     //                  Linux GNU Compiler gcc
-#define _DEV_GNUC_MPC5X5        0x00000009L     //                  GNU for Motorola PPC5x5
-#define _DEV_TASKINGM16C_       0x00000008L     //                  Tasking for Mitsubishi M16C
-#define _DEV_FUJITSU_           0x00000007L     //                  Fujitsu
-#define _DEV_TASKING8_          0x00000006L     //                  Tasking 8051
-#define _DEV_TASKING16_         0x00000005L     //                  Tasking 166
-#define _DEV_KEIL8_             0x00000004L     //                  Keil C51
-#define _DEV_KEIL16_            0x00000003L     //                  Keil C166
-#define _DEV_BORLANDC_          0x00000002L     //                  Borland C/C++
-#define _DEV_MSVC16_            0x00000001L     //                  Microsoft Visual C/C++
-#define _DEV_MSVC32_            0x00000000L     //                  Microsoft Visual C/C++
+#define _DEV_BIGEND_            0x80000000L	// big endian (motorolla format)
+#define _DEV_ALIGNMENT_4_       0x00400000L	//                  the CPU needs alignment of 4 bytes
+#define _DEV_ONLY_INT_MAIN_     0x00004000L	//                  the compiler needs "int main(int)" instead of "void main(void)"
+#define _DEV_COMMA_EXT_         0x00002000L	//                  support of last comma in struct predefinition
+#define _DEV_64BIT_SUPPORT_     0x00001000L	//                  support of 64 bit operations
+#define _DEV_BIT64_             0x00000400L	// count of bits:   64 bit
+#define _DEV_BIT32_             0x00000300L	//                  32 bit
+#define _DEV_BIT16_             0x00000200L	//                  16 bit
+#define _DEV_BIT8_              0x00000100L	//                  8 bit
+#define _DEV_RVCT_ARM_          0x0000001CL	//                  RealView ARM
+#define _DEV_RENESASM32C        0x0000001BL	// compiler from:   Renesas
+#define _DEV_GNUC_MIPS2_        0x0000001AL	//                  GNU for MIPS2
+#define _DEV_MPLAB_C30_         0x00000019L	//                  MPLAB C30 for Microchip dsPIC33F series
+#define _DEV_GNUC_TC_           0x00000018L	//                  GNU for Infineon TriCore
+#define _DEV_GNUC_X86_          0x00000017L	//                  GNU for I386
+#define _DEV_IAR_ARM_           0x00000016L	//                  ARM IAR C/C++ Compiler
+#define _DEV_PARADGM_X86        0x00000015L	//                  Paradigm C/C++ for Beck 1x3
+#define _DEV_GNUC_CF_           0x00000014L	//                  GNU for Coldfire
+#define _DEV_KEIL_ARM_          0x00000013L	//                  Keil ARM
+#define _DEV_MSEVC_             0x00000012L	//                  Microsoft embedded Visual C/C++
+#define _DEV_HIGHTEC_GNUC_X86_  0x00000011L	//                  Hightec elf386 gcc
+#define _DEV_MSVC_RTX_          0x00000010L	//                  VC600 + RTX
+#define _DEV_MSVC_V1_5_         0x0000000FL	//                  Microsoft Visual C/C++ V1.5
+#define _DEV_GNUC_ARM7_         0x0000000EL	//                  GNU Compiler gcc for ARM7
+#define _DEV_METROWERKS_CW_     0x0000000DL	//                  Metrowerks Code Warrior
+#define _DEV_MITSUBISHIM16C_    0x0000000CL	//compiler from:    Mitsubishi
+#define _DEV_GNUC_C16X_         0x0000000BL	//                  GNU Compiler gcc166 for Infineon C16x
+#define _DEV_LINUX_GCC_         0x0000000AL	//                  Linux GNU Compiler gcc
+#define _DEV_GNUC_MPC5X5        0x00000009L	//                  GNU for Motorola PPC5x5
+#define _DEV_TASKINGM16C_       0x00000008L	//                  Tasking for Mitsubishi M16C
+#define _DEV_FUJITSU_           0x00000007L	//                  Fujitsu
+#define _DEV_TASKING8_          0x00000006L	//                  Tasking 8051
+#define _DEV_TASKING16_         0x00000005L	//                  Tasking 166
+#define _DEV_KEIL8_             0x00000004L	//                  Keil C51
+#define _DEV_KEIL16_            0x00000003L	//                  Keil C166
+#define _DEV_BORLANDC_          0x00000002L	//                  Borland C/C++
+#define _DEV_MSVC16_            0x00000001L	//                  Microsoft Visual C/C++
+#define _DEV_MSVC32_            0x00000000L	//                  Microsoft Visual C/C++
 
 // these defines can be used to mask previous elements
 #define _DEV_MASK_COMPILER      0x000000FFL
@@ -73,7 +72,6 @@
 #define _DEV_MASK_ADDSUPPORT    0x0000F000L
 #define _DEV_MASK_ALIGNMENT     0x00F00000L
 
-
 //---------------------------------------------------------------------------
 //  defines for development system (DEV_SYSTEM) including previous elements
 //---------------------------------------------------------------------------
@@ -81,34 +79,34 @@
 #define _DEV_WIN16_             (_DEV_BIT16_ | _DEV_MSVC16_                  )
 #define _DEV_WIN32_             (_DEV_BIT32_ | _DEV_MSVC32_                   | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
 #define _DEV_MSVC_DOS_          (_DEV_BIT32_ | _DEV_MSVC_V1_5_               )
-#define _DEV_BORLAND_DOS_       (_DEV_BIT32_ | _DEV_BORLANDC_                ) //| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
-#define _DEV_KEIL_C51X_         (_DEV_BIT8_  | _DEV_KEIL8_     | _DEV_BIGEND_ | _DEV_COMMA_EXT_) // at least C51 version 7.05 supports comma extension
-#define _DEV_KEIL_C16X_         (_DEV_BIT16_ | _DEV_KEIL16_                   | _DEV_COMMA_EXT_) // at least C166 version 5.03 supports comma extension
+#define _DEV_BORLAND_DOS_       (_DEV_BIT32_ | _DEV_BORLANDC_                )	//| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
+#define _DEV_KEIL_C51X_         (_DEV_BIT8_  | _DEV_KEIL8_     | _DEV_BIGEND_ | _DEV_COMMA_EXT_)	// at least C51 version 7.05 supports comma extension
+#define _DEV_KEIL_C16X_         (_DEV_BIT16_ | _DEV_KEIL16_                   | _DEV_COMMA_EXT_)	// at least C166 version 5.03 supports comma extension
 #define _DEV_TASKING_C51X_      (_DEV_BIT8_  | _DEV_TASKING8_  | _DEV_BIGEND_)
 #define _DEV_TASKING_C16X_      (_DEV_BIT16_ | _DEV_TASKING16_               )
-#define _DEV_FUJITSU_F590_      (_DEV_BIT8_  | _DEV_FUJITSU_                  | _DEV_COMMA_EXT_) // softune is not able to support 64 bit variables QWORD !!!
+#define _DEV_FUJITSU_F590_      (_DEV_BIT8_  | _DEV_FUJITSU_                  | _DEV_COMMA_EXT_)	// softune is not able to support 64 bit variables QWORD !!!
 //f.j.29.04.03 M16C kann effektiv mit Bytes umgehen
 //#define _DEV_TASKING_M16C_      (_DEV_BIT16_ | _DEV_TASKINGM16C_             )
 #define _DEV_TASKING_M16C_      (_DEV_BIT8_  | _DEV_TASKINGM16C_             )
 #define _DEV_MITSUBISHI_M16C_   (_DEV_BIT8_  | _DEV_MITSUBISHIM16C_          )
 #define _DEV_GNU_MPC5X5_        (_DEV_BIT32_ | _DEV_GNUC_MPC5X5| _DEV_BIGEND_ | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
 #define _DEV_LINUX_             (_DEV_BIT32_ | _DEV_LINUX_GCC_                | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
-#define _DEV_GNU_C16X_          (_DEV_BIT16_ | _DEV_GNUC_C16X_               ) //| _DEV_COMMA_EXT_)
-#define _DEV_MCW_MPC5X5_        (_DEV_BIT32_ | _DEV_METROWERKS_CW_           ) //| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
+#define _DEV_GNU_C16X_          (_DEV_BIT16_ | _DEV_GNUC_C16X_               )	//| _DEV_COMMA_EXT_)
+#define _DEV_MCW_MPC5X5_        (_DEV_BIT32_ | _DEV_METROWERKS_CW_           )	//| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
 #define _DEV_GNU_ARM7_          (_DEV_BIT32_ | _DEV_GNUC_ARM7_                | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_ | _DEV_ONLY_INT_MAIN_)
-#define _DEV_WIN32_RTX_         (_DEV_BIT32_ | _DEV_MSVC_RTX_                ) //| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
-#define _DEV_HIGHTEC_X86_       (_DEV_BIT32_ | _DEV_HIGHTEC_GNUC_X86_        ) //| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
-#define _DEV_WIN_CE_            (_DEV_BIT32_ | _DEV_MSEVC_                   ) //| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
+#define _DEV_WIN32_RTX_         (_DEV_BIT32_ | _DEV_MSVC_RTX_                )	//| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
+#define _DEV_HIGHTEC_X86_       (_DEV_BIT32_ | _DEV_HIGHTEC_GNUC_X86_        )	//| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
+#define _DEV_WIN_CE_            (_DEV_BIT32_ | _DEV_MSEVC_                   )	//| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
 #define _DEV_KEIL_CARM_         (_DEV_BIT32_ | _DEV_KEIL_ARM_                 | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
 #define _DEV_IAR_CARM_          (_DEV_BIT32_ | _DEV_IAR_ARM_                  | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
 #define _DEV_RVCT_CARM_         (_DEV_BIT32_ | _DEV_RVCT_ARM_                 | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_ | _DEV_ONLY_INT_MAIN_)
-#define _DEV_MCW_MCF5XXX_       (_DEV_BIT32_ | _DEV_METROWERKS_CW_           ) //| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
+#define _DEV_MCW_MCF5XXX_       (_DEV_BIT32_ | _DEV_METROWERKS_CW_           )	//| _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
 #define _DEV_GNU_CF5282_        (_DEV_BIT32_ | _DEV_GNUC_CF_   | _DEV_BIGEND_)
 #define _DEV_PAR_BECK1X3_       (_DEV_BIT16_ | _DEV_PARADGM_X86)
 #define _DEV_GNU_CF548X_        (_DEV_BIT32_ | _DEV_GNUC_CF_   | _DEV_BIGEND_ | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_)
 #define _DEV_GNU_I386_          (_DEV_BIT32_ | _DEV_GNUC_X86_                 | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_ | _DEV_ONLY_INT_MAIN_)
 #define _DEV_GNU_TRICORE_       (_DEV_BIT32_ | _DEV_GNUC_TC_                  | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_ | _DEV_ONLY_INT_MAIN_ | _DEV_ALIGNMENT_4_)
-#define _DEV_MPLAB_DSPIC33F_    (_DEV_BIT16_ | _DEV_MPLAB_C30_               ) //| _DEV_COMMA_EXT_)
+#define _DEV_MPLAB_DSPIC33F_    (_DEV_BIT16_ | _DEV_MPLAB_C30_               )	//| _DEV_COMMA_EXT_)
 #define _DEV_GNU_MIPSEL_        (_DEV_BIT32_ | _DEV_GNUC_MIPS2_     | _DEV_BIGEND_ | _DEV_64BIT_SUPPORT_ | _DEV_COMMA_EXT_ | _DEV_ONLY_INT_MAIN_)
 
 #define _DEV_RENESAS_M32C_      (_DEV_BIT32_ | _DEV_RENESASM32C)
@@ -120,7 +118,6 @@
 #define CHECK_IF_ONLY_INT_MAIN()    (DEV_SYSTEM & _DEV_ONLY_INT_MAIN_)
 #define CHECK_MEMORY_ALINMENT()     (DEV_SYSTEM & _DEV_MASK_ALIGNMENT)
 
-
 //---------------------------------------------------------------------------
 //  defines for target system (TARGET_SYSTEM)
 //---------------------------------------------------------------------------
@@ -134,14 +131,13 @@
 #define _PXROS_              2
 #define _ECOSPRO_            3
 
-
 //---------------------------------------------------------------------------
 //  definitions for function inlining
 //---------------------------------------------------------------------------
 
-#define INLINE_FUNCTION             // empty define
-#undef  INLINE_ENABLED              // disable actual inlining of functions
-#undef  INLINE_FUNCTION_DEF         // disable inlining for all compilers per default
+#define INLINE_FUNCTION		// empty define
+#undef  INLINE_ENABLED		// disable actual inlining of functions
+#undef  INLINE_FUNCTION_DEF	// disable inlining for all compilers per default
 
 //---------------------------------------------------------------------------
 //  definitions for Keil C51
@@ -149,35 +145,34 @@
 
 #ifdef  __C51__
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_KEIL_C51X_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_KEIL_C51X_
 
-    #pragma DEBUG OBJECTEXTEND
-    #pragma WARNINGLEVEL(2)             // maximum warning level
+#pragma DEBUG OBJECTEXTEND
+#pragma WARNINGLEVEL(2)		// maximum warning level
 
-    #define NEAR            idata       // variables mapped to internal data storage location
-    #define FAR             xdata       // variables mapped to external data storage location
-    #define CONST           const       // variables mapped to ROM (i.e. flash)
-    #define ROM             code        // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC           xdata       // hardware access through external memory (i.e. CAN)
-    #define LARGE           large       // functions set parameters to external data storage location
+#define NEAR            idata	// variables mapped to internal data storage location
+#define FAR             xdata	// variables mapped to external data storage location
+#define CONST           const	// variables mapped to ROM (i.e. flash)
+#define ROM             code	// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC           xdata	// hardware access through external memory (i.e. CAN)
+#define LARGE           large	// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM             xdata       // Memory attribute to optimize speed and code of pointer access.
-
-    #define REENTRANT       reentrant
-    #define PUBLIC
-
-    #ifndef NDEBUG
-        #include <stdio.h>              // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM             xdata	// Memory attribute to optimize speed and code of pointer access.
 
+#define REENTRANT       reentrant
+#define PUBLIC
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for GNU Compiler for Infineon C16x
@@ -185,36 +180,36 @@
 //---------------------------------------------------------------------------
 #elif  defined (__GNUC__) && defined (__C166__)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_GNU_C16X_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_GNU_C16X_
 
 //    #define NEAR            idata       // variables mapped to internal data storage location
-    #define NEAR            near       // variables mapped to internal data storage location
+#define NEAR            near	// variables mapped to internal data storage location
 //    #define FAR             xhuge       // variables mapped to external data storage location
-    #define FAR             huge       // variables mapped to external data storage location
-    #define CONST           const       // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
+#define FAR             huge	// variables mapped to external data storage location
+#define CONST           const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
 //    #define HWACC           sdata       // hardware access through external memory (i.e. CAN)
-    #define HWACC           huge       // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define HWACC           huge	// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
 //    #define GENERIC         xhuge       // generic pointer to point to application data
-    #define GENERIC         huge       // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
-
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef NDEBUG
-        #include <stdio.h>              // prototype printf() (for TRACE)
-        #define TRACE  printf
+#define GENERIC         huge	// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
 
-        #define ASSERT(p)  \
+#define REENTRANT
+#define PUBLIC
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+
+#define ASSERT(p)  \
             if (p)         \
             {              \
                 ;          \
@@ -224,213 +219,213 @@
                 PRINTF0("Assert failed: " #p " (file %s line %d)\n", __FILE__, (int) __LINE__ ); \
                 while (1); \
             }
-    #else
-        #define ASSERT(p)
-    #endif
+#else
+#define ASSERT(p)
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for Keil C166
 //---------------------------------------------------------------------------
-#elif  defined (__C166__)               // 24.01.2005 r.d.: Keil ARM7 needs directive 'defined'
+#elif  defined (__C166__)	// 24.01.2005 r.d.: Keil ARM7 needs directive 'defined'
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_KEIL_C16X_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_KEIL_C16X_
 
-    #pragma CODE
-    #pragma MOD167
-    #pragma NOINIT
-    #pragma DEBUG
-    #pragma WARNINGLEVEL(3)             // maximum warning level
-    #pragma WARNING DISABLE = 47        // warning <unreferenced parameter> = OFF
-    #pragma WARNING DISABLE = 38        // warning <empty translation unit> = OFF
+#pragma CODE
+#pragma MOD167
+#pragma NOINIT
+#pragma DEBUG
+#pragma WARNINGLEVEL(3)		// maximum warning level
+#pragma WARNING DISABLE = 47	// warning <unreferenced parameter> = OFF
+#pragma WARNING DISABLE = 38	// warning <empty translation unit> = OFF
 //  #pragma WARNING DISABLE = 102       // warning <different const/volatile qualifiers> = OFF
-    #pragma WARNING DISABLE = 174       // warning <unreferenced 'static' function> = OFF
-    #pragma WARNING DISABLE = 183       // warning <dead assignement eliminated> = OFF
+#pragma WARNING DISABLE = 174	// warning <unreferenced 'static' function> = OFF
+#pragma WARNING DISABLE = 183	// warning <dead assignement eliminated> = OFF
 
-    #define NEAR            idata       // variables mapped to internal data storage location
-    #define FAR             xhuge       // variables mapped to external data storage location
-    #define CONST           const       // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
+#define NEAR            idata	// variables mapped to internal data storage location
+#define FAR             xhuge	// variables mapped to external data storage location
+#define CONST           const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
 //    #define HWACC           sdata       // hardware access through external memory (i.e. CAN)
-    #define HWACC           huge       // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define HWACC           huge	// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC         xhuge       // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
-
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef NDEBUG
-        #include <stdio.h>              // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#define GENERIC         xhuge	// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+
+#define REENTRANT
+#define PUBLIC
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for MPLAB C30 for dsPIC33F series
 //---------------------------------------------------------------------------
 #elif  defined (__C30__)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_MPLAB_DSPIC33F_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_MPLAB_DSPIC33F_
 
-    #define NEAR                        // variables mapped to internal data storage location
-    #define FAR                         // variables mapped to external data storage location
-    #define CONST        const          // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC                       // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR			// variables mapped to internal data storage location
+#define FAR			// variables mapped to external data storage location
+#define CONST        const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
 
-    #define REENTRANT
-    #define PUBLIC
+#define REENTRANT
+#define PUBLIC
 
 //    #ifndef QWORD
 //        #define QWORD long long
 //    #endif
 
-    #ifndef NDEBUG
-        #include <stdio.h>              // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for Keil ARM
 //---------------------------------------------------------------------------
 #elif  defined (__CA__)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_KEIL_CARM_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_KEIL_CARM_
 
-    #define NEAR                        // variables mapped to internal data storage location
-    #define FAR                         // variables mapped to external data storage location
-    #define CONST        const          // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC                       // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR			// variables mapped to internal data storage location
+#define FAR			// variables mapped to external data storage location
+#define CONST        const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
-
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef QWORD
-        #define QWORD long long
-    #endif
-
-    #ifndef NDEBUG
-        #include <stdio.h>              // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+
+#define REENTRANT
+#define PUBLIC
+
+#ifndef QWORD
+#define QWORD long long
+#endif
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for RealView ARM compilation tools (provided by recent Keil Microcontroller Development Kits)
 //---------------------------------------------------------------------------
 #elif  defined (__ARMCC_VERSION)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_RVCT_CARM_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_RVCT_CARM_
 
-    #define NEAR                        // variables mapped to internal data storage location
-    #define FAR                         // variables mapped to external data storage location
-    #define CONST        const          // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC                       // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR			// variables mapped to internal data storage location
+#define FAR			// variables mapped to external data storage location
+#define CONST        const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
-
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef QWORD
-        #define QWORD long long
-    #endif
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
 
-    #ifndef NDEBUG
-        #define ASSERT(expr)    if (!(expr)) {\
+#define REENTRANT
+#define PUBLIC
+
+#ifndef QWORD
+#define QWORD long long
+#endif
+
+#ifndef NDEBUG
+#define ASSERT(expr)    if (!(expr)) {\
                                    TRACE0 ("Assertion failed: " #expr );\
                                    while (1);}
-    #else
-        #define ASSERT(expr)
-    #endif
-
-    #ifndef NDEBUG
-        #include <stdio.h>              // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#else
+#define ASSERT(expr)
+#endif
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for ARM IAR C Compiler
 //---------------------------------------------------------------------------
 #elif  defined (__ICCARM__)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_IAR_CARM_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_IAR_CARM_
 
-    #define NEAR                        // variables mapped to internal data storage location
-    #define FAR                         // variables mapped to external data storage location
-    #define CONST        const          // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC                       // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR			// variables mapped to internal data storage location
+#define FAR			// variables mapped to external data storage location
+#define CONST        const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
-
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef QWORD
-        #define QWORD long long
-    #endif
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+
+#define REENTRANT
+#define PUBLIC
+
+#ifndef QWORD
+#define QWORD long long
+#endif
 
     // Workaround:
     // If we use IAR and want to debug but don't want to use C-Spy Debugger
     // assert() doesn't work in debug mode because it needs support for FILE descriptors
     // (_DLIB_FILE_DESCRIPTOR == 1).
-    #ifndef NDEBUG
-        #define ASSERT(expr)    if (!(expr)) {\
+#ifndef NDEBUG
+#define ASSERT(expr)    if (!(expr)) {\
                                    TRACE0 ("Assertion failed: " #expr );\
                                    while (1);}
-    #else
-        #define ASSERT(expr)
-    #endif
-
-    #ifndef NDEBUG
-        #include <stdio.h>              // prototype printf() (for TRACE)
-        #define TRACE  printf
+#else
+#define ASSERT(expr)
+#endif
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
 //        #define TRACE  PRINTF4
-    #endif
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for Tasking 8051
@@ -438,34 +433,33 @@
 
 #elif defined (_CC51)
 
-    #include <cc51.h>
+#include <cc51.h>
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_TASKING_C51X_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_TASKING_C51X_
 
-    #define NEAR            _data       // variables mapped to internal data storage location
-    #define FAR             _xdat       // variables mapped to external data storage location
-    #define CONST           const       // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC           _xdat       // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR            _data	// variables mapped to internal data storage location
+#define FAR             _xdat	// variables mapped to external data storage location
+#define CONST           const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC           _xdat	// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM             _xdat       // Memory attribute to optimize speed and code of pointer access.
-
-    #define REENTRANT       _reentrant
-    #define PUBLIC
-
-    #ifndef NDEBUG
-        #include <stdio.h>              // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM             _xdat	// Memory attribute to optimize speed and code of pointer access.
 
+#define REENTRANT       _reentrant
+#define PUBLIC
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for Tasking C167CR and C164CI
@@ -473,35 +467,34 @@
 
 #elif defined (_C166)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_TASKING_C16X_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_TASKING_C16X_
 
-    #define NEAR            near        // variables mapped to internal data storage location
-    #define FAR             far         // variables mapped to external data storage location
-    #define CONST           const       // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC   /* to be defined */ // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR            near	// variables mapped to internal data storage location
+#define FAR             far	// variables mapped to external data storage location
+#define CONST           const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC   /* to be defined */	// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
 
-    #define REENTRANT
-    #define PUBLIC
+#define REENTRANT
+#define PUBLIC
 
     // Stdio.h has to be alway included here. If printf() is used stdio.h defines NULL
     // without checking if it is already included. So an error occurs while compiling.
     // (r.d.)
-    #include <stdio.h>                  // prototype printf() (for TRACE)
-    #ifndef NDEBUG
-        #define TRACE  printf
-    #endif
-
+#include <stdio.h>		// prototype printf() (for TRACE)
+#ifndef NDEBUG
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for FUJITSU FFMC-16LX MB90590
@@ -510,34 +503,33 @@
 //#elif (defined (F590) || defined (F543) || defined (F598) || defined (F495) || defined (F350))
 #elif defined(__COMPILER_FCC907__)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_FUJITSU_F590_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_FUJITSU_F590_
 
-    #define NEAR    /* to be defined */ // variables mapped to internal data storage location
-    #define FAR     /* to be defined */ // variables mapped to external data storage location
-    #define CONST           const       // variables mapped to ROM (i.e. flash)
-    #define ROM     /* to be defined */ // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC   /* to be defined */ // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR    /* to be defined */	// variables mapped to internal data storage location
+#define FAR     /* to be defined */	// variables mapped to external data storage location
+#define CONST           const	// variables mapped to ROM (i.e. flash)
+#define ROM     /* to be defined */	// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC   /* to be defined */	// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
 
     // softune is not able to support 64 bit variables QWORD !!!
 
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef NDEBUG
-        #include <stdio.h>              // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#define REENTRANT
+#define PUBLIC
 
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for Mitsubishi M16C family for TASKING Compiler CM16
@@ -545,36 +537,35 @@
 
 #elif defined (_CM16C)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_TASKING_M16C_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_TASKING_M16C_
 
-    #define NEAR            _near       // variables mapped to internal data storage location
-    #define FAR             _far        // variables mapped to external data storage location
-    #define CONST           _farrom       // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC           _near       // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR            _near	// variables mapped to internal data storage location
+#define FAR             _far	// variables mapped to external data storage location
+#define CONST           _farrom	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC           _near	// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC         _far        // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-                                        // do you use memory model SMALL, than you have to set _far
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
+#define GENERIC         _far	// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+					// do you use memory model SMALL, than you have to set _far
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
 
-    #define REENTRANT
-    #define PUBLIC
+#define REENTRANT
+#define PUBLIC
 
     // Stdio.h has to be alway included here. If printf() is used stdio.h defines NULL
     // without checking if it is already included. So an error occurs while compiling.
     // (r.d.)
-    #include <stdio.h>                  // prototype printf() (for TRACE)
-    #ifndef NDEBUG
-        #define TRACE  printf
-    #endif
-
+#include <stdio.h>		// prototype printf() (for TRACE)
+#ifndef NDEBUG
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for Mitsubishi M16C family for Mitsubishi Compiler NC30
@@ -582,61 +573,61 @@
 // name NC30, andere Form will der Compiler nicht !!
 #elif defined (NC30)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_MITSUBISHI_M16C_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_MITSUBISHI_M16C_
 
-    #define NEAR            near        // variables mapped to internal data storage location
-    #define FAR             far         // variables mapped to external data storage location
-    #define CONST           const       // variables mapped to ROM (i.e. flash)
-    #define ROM                      // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC           near        // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR            near	// variables mapped to internal data storage location
+#define FAR             far	// variables mapped to external data storage location
+#define CONST           const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC           near	// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC         far         // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
-
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef NDEBUG
-        #include <stdio.h>                  // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#define GENERIC         far	// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+
+#define REENTRANT
+#define PUBLIC
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for Renesas M32C family for Renesas Compiler
 //---------------------------------------------------------------------------
 #elif defined (NC308)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_RENESAS_M32C_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_RENESAS_M32C_
 
-    #define NEAR             near       // variables mapped to internal data storage location
-    #define FAR              far        // variables mapped to external data storage location
-    #define CONST            const      // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-    #define HWACC                       // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR             near	// variables mapped to internal data storage location
+#define FAR              far	// variables mapped to external data storage location
+#define CONST            const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+#define HWACC			// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM              far        // Memory attribute to optimize speed and code of pointer access.
-
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef NDEBUG
-        #include <stdio.h>                  // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM              far	// Memory attribute to optimize speed and code of pointer access.
+
+#define REENTRANT
+#define PUBLIC
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //    #error ("RENESAS o.k.")
 
@@ -646,37 +637,36 @@
 
 #elif defined(__GNUC__) && defined(__arm__) && !defined(__LINUX_ARM_ARCH__)
 
-    #define TARGET_SYSTEM   _NO_OS_
-    #define DEV_SYSTEM      _DEV_GNU_ARM7_
+#define TARGET_SYSTEM   _NO_OS_
+#define DEV_SYSTEM      _DEV_GNU_ARM7_
 
-    #define NEAR                        // variables mapped to internal data storage location
-    #define FAR                         // variables mapped to external data storage location
-    #define CONST           const       // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC                       // hardware access through external memory (i.e. CAN)
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR			// variables mapped to internal data storage location
+#define FAR			// variables mapped to external data storage location
+#define CONST           const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
-    #define HWACC                       // hardware access through external memory (i.e. CAN)
-
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef QWORD
-        #define QWORD long long    // i.A. durch Herr Kuschel
-    #endif
-
-    #ifndef NDEBUG
-        #include <stdio.h>                  // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+#define HWACC			// hardware access through external memory (i.e. CAN)
+
+#define REENTRANT
+#define PUBLIC
 
+#ifndef QWORD
+#define QWORD long long		// i.A. durch Herr Kuschel
+#endif
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for Motorola PowerPC family 5x5 (555/565)
@@ -685,261 +675,253 @@
 
 #elif defined (__GNUC__)
 
-    #if defined (LINUX) || defined (linux) || defined (__linux__)
-        #define LINUX_SYSTEM            // define 'LINUX_SYSTEM' uniform for all Linux based systems
-        // r.d.: We will need an other solution here! There are two sections here which do check the preproc-definitions:
-        //     LINUX and __linux__ . The first one was Linux for PC, the second one is this section for embedded Linux (MCF5xxx).
-        //     But Linux for PC does not need the definitions for embedded Linux.
-    #endif
+#if defined (LINUX) || defined (linux) || defined (__linux__)
+#define LINUX_SYSTEM		// define 'LINUX_SYSTEM' uniform for all Linux based systems
+	// r.d.: We will need an other solution here! There are two sections here which do check the preproc-definitions:
+	//     LINUX and __linux__ . The first one was Linux for PC, the second one is this section for embedded Linux (MCF5xxx).
+	//     But Linux for PC does not need the definitions for embedded Linux.
+#endif
 
     // GNU C compiler supports function inlining
-    #define INLINE_FUNCTION_DEF extern inline
+#define INLINE_FUNCTION_DEF extern inline
 
     // to actually enable inlining just include the following three lines
     // #undef INLINE_FUNCTION
     // #define INLINE_FUNCTION     INLINE_FUNCTION_DEF
     // #define INLINE_ENABLED      TRUE
 
-    #ifdef PXROS
-        #define TARGET_SYSTEM       _PXROS_
-        #ifdef __i386__
-            #undef LINUX // this define seems to be set from compiler
-            #define DEV_SYSTEM      _DEV_HIGHTEC_X86_
-	    #elif defined (__tricore__)
-            #define DEV_SYSTEM      _DEV_GNU_TRICORE_
-        #else // MPC5x5
-            #define DEV_SYSTEM      _DEV_GNU_MPC5X5_
-        #endif
-
-    #elif defined (LINUX) || defined (__linux__)
-        #define TARGET_SYSTEM       _LINUX_     // Linux definition
-        #define DEV_SYSTEM          _DEV_LINUX_
-
-    #elif defined (GNU_CF5282)
-        #define TARGET_SYSTEM       _NO_OS_
-        #define DEV_SYSTEM          _DEV_GNU_CF5282_
-
-    #elif defined (ECOSPRO_I386_PEAK_PCI)
-        #define TARGET_SYSTEM       _ECOSPRO_
-        #define DEV_SYSTEM          _DEV_GNU_I386_
-
-    #elif defined (GNU_CF548X)
-        #define TARGET_SYSTEM       _NO_OS_
-        #define DEV_SYSTEM          _DEV_GNU_CF548X_
-    #else
-        #error 'ERROR: DEV_SYSTEM not found!'
-    #endif
-
-
-    #ifndef QWORD
-        #define QWORD long long int
-    #endif
-
-    #if (TARGET_SYSTEM == _PXROS_)
-
-        #ifndef __KERNEL__
-            #include <string.h>
-        #endif
-
-
-        #define NEAR                        // variables mapped to internal data storage location
-        #define FAR                         // variables mapped to external data storage location
-        #define CONST           const       // variables mapped to ROM (i.e. flash)
-        #define ROM     /* to be defined */ // code or variables mapped to ROM (i.e. flash)
-                                            // usage: CONST BYTE ROM foo = 0x00;
-        #define LARGE                       // functions set parameters to external data storage location
-
-        // These types can be adjusted by users to match application requirements. The goal is to
-        // minimize code memory and maximize speed.
-        #define GENERIC                     // generic pointer to point to application data
-                                            // Variables with this attribute can be located in external
-                                            // or internal data memory.
-        #define MEM                         // Memory attribute to optimize speed and code of pointer access.
-
-        #define HWACC                       // hardware access through external memory (i.e. CAN)
-
-        #define REENTRANT
-        #define PUBLIC
-
-        #ifndef QWORD
-            #define QWORD long long int
-        #endif
-
-        #ifndef NDEBUG
-            #include <stdio.h>              // prototype printf() (for TRACE)
-            #define TRACE  printf
-        #endif
+#ifdef PXROS
+#define TARGET_SYSTEM       _PXROS_
+#ifdef __i386__
+#undef LINUX			// this define seems to be set from compiler
+#define DEV_SYSTEM      _DEV_HIGHTEC_X86_
+#elif defined (__tricore__)
+#define DEV_SYSTEM      _DEV_GNU_TRICORE_
+#else // MPC5x5
+#define DEV_SYSTEM      _DEV_GNU_MPC5X5_
+#endif
+
+#elif defined (LINUX) || defined (__linux__)
+#define TARGET_SYSTEM       _LINUX_	// Linux definition
+#define DEV_SYSTEM          _DEV_LINUX_
+
+#elif defined (GNU_CF5282)
+#define TARGET_SYSTEM       _NO_OS_
+#define DEV_SYSTEM          _DEV_GNU_CF5282_
+
+#elif defined (ECOSPRO_I386_PEAK_PCI)
+#define TARGET_SYSTEM       _ECOSPRO_
+#define DEV_SYSTEM          _DEV_GNU_I386_
+
+#elif defined (GNU_CF548X)
+#define TARGET_SYSTEM       _NO_OS_
+#define DEV_SYSTEM          _DEV_GNU_CF548X_
+#else
+#error 'ERROR: DEV_SYSTEM not found!'
+#endif
 
-    #endif
+#ifndef QWORD
+#define QWORD long long int
+#endif
+
+#if (TARGET_SYSTEM == _PXROS_)
+
+#ifndef __KERNEL__
+#include <string.h>
+#endif
+
+#define NEAR			// variables mapped to internal data storage location
+#define FAR			// variables mapped to external data storage location
+#define CONST           const	// variables mapped to ROM (i.e. flash)
+#define ROM     /* to be defined */	// code or variables mapped to ROM (i.e. flash)
+					    // usage: CONST BYTE ROM foo = 0x00;
+#define LARGE			// functions set parameters to external data storage location
+
+	// These types can be adjusted by users to match application requirements. The goal is to
+	// minimize code memory and maximize speed.
+#define GENERIC			// generic pointer to point to application data
+					    // Variables with this attribute can be located in external
+					    // or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+
+#define HWACC			// hardware access through external memory (i.e. CAN)
+
+#define REENTRANT
+#define PUBLIC
+
+#ifndef QWORD
+#define QWORD long long int
+#endif
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
+
+#endif
 
     // ------------------ GNUC for I386 ---------------------------------------------
 
-    #if (TARGET_SYSTEM == _LINUX_) || (TARGET_SYSTEM == _ECOSPRO_)
+#if (TARGET_SYSTEM == _LINUX_) || (TARGET_SYSTEM == _ECOSPRO_)
 
-        #ifndef __KERNEL__
-            #include <string.h>
-        #endif
-
-        #define ROM                     // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-        #define HWACC                   // hardware access through external memory (i.e. CAN)
-
-        // These types can be adjusted by users to match application requirements. The goal is to
-        // minimize code memory and maximize speed.
-        #define GENERIC                 // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-        #define MEM                     // Memory attribute to optimize speed and code of pointer access.
-
-        #ifndef NEAR
-            #define NEAR                // variables mapped to internal data storage location
-        #endif
-
-        #ifndef FAR
-            #define FAR                 // variables mapped to external data storage location
-        #endif
-
-        #ifndef CONST
-            #define CONST const         // variables mapped to ROM (i.e. flash)
-        #endif
-
-        #define LARGE
-
-        #define REENTRANT
-        #define PUBLIC
-
-        #ifndef NDEBUG
-            #ifndef __KERNEL__
-                #include <stdio.h>              // prototype printf() (for TRACE)
-                #define TRACE  printf
-            #else
-                #define TRACE  printk
-            #endif
-        #endif
-    #endif
+#ifndef __KERNEL__
+#include <string.h>
+#endif
 
-    // ------------------ GNU without OS ---------------------------------------------
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+
+	// These types can be adjusted by users to match application requirements. The goal is to
+	// minimize code memory and maximize speed.
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+
+#ifndef NEAR
+#define NEAR			// variables mapped to internal data storage location
+#endif
+
+#ifndef FAR
+#define FAR			// variables mapped to external data storage location
+#endif
+
+#ifndef CONST
+#define CONST const		// variables mapped to ROM (i.e. flash)
+#endif
+
+#define LARGE
+
+#define REENTRANT
+#define PUBLIC
+
+#ifndef NDEBUG
+#ifndef __KERNEL__
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#else
+#define TRACE  printk
+#endif
+#endif
+#endif
 
-    #if (TARGET_SYSTEM == _NO_OS_)
+    // ------------------ GNU without OS ---------------------------------------------
 
-        #define ROM                     // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-        #define HWACC                   // hardware access through external memory (i.e. CAN)
+#if (TARGET_SYSTEM == _NO_OS_)
 
-        // These types can be adjusted by users to match application requirements. The goal is to
-        // minimize code memory and maximize speed.
-        #define GENERIC                 // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-        #define MEM                     // Memory attribute to optimize speed and code of pointer access.
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+
+	// These types can be adjusted by users to match application requirements. The goal is to
+	// minimize code memory and maximize speed.
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
 
-        #ifndef NEAR
-            #define NEAR                // variables mapped to internal data storage location
-        #endif
+#ifndef NEAR
+#define NEAR			// variables mapped to internal data storage location
+#endif
 
-        #ifndef FAR
-            #define FAR                 // variables mapped to external data storage location
-        #endif
+#ifndef FAR
+#define FAR			// variables mapped to external data storage location
+#endif
 
-        #ifndef CONST
-            #define CONST const         // variables mapped to ROM (i.e. flash)
-        #endif
+#ifndef CONST
+#define CONST const		// variables mapped to ROM (i.e. flash)
+#endif
 
-        #define LARGE
+#define LARGE
 
-        #define REENTRANT
-        #define PUBLIC
+#define REENTRANT
+#define PUBLIC
 
-        #ifndef NDEBUG
+#ifndef NDEBUG
 //            #include "xuartdrv.h"
 //            #include <stdio.h>              // prototype printf() (for TRACE)
-            #define TRACE  printf
+#define TRACE  printf
 //            #define TRACE  mprintf
 //            #ifndef TRACE
 //                #define TRACE trace
 //                void trace (char *fmt, ...);
 //            #endif
-        #endif
+#endif
 
-    #endif
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for MPC565
 //---------------------------------------------------------------------------
 #elif __MWERKS__
 
-
 #ifdef __MC68K__
 
-    #define TARGET_SYSTEM = _MCF548X_
-    #define DEV_SYSTEM      _DEV_MCW_MCF5XXX_
+#define TARGET_SYSTEM = _MCF548X_
+#define DEV_SYSTEM      _DEV_MCW_MCF5XXX_
 
 #else
-    #define TARGET_SYSTEM = _MPC565_
-    #define DEV_SYSTEM      _DEV_MCW_MPC5X5_
+#define TARGET_SYSTEM = _MPC565_
+#define DEV_SYSTEM      _DEV_MCW_MPC5X5_
 #endif
 
-    #define NEAR                        // variables mapped to internal data storage location
-    #define FAR                         // variables mapped to external data storage location
-    #define CONST           const       // variables mapped to ROM (i.e. flash)
-    #define ROM                         // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-    #define LARGE                       // functions set parameters to external data storage location
+#define NEAR			// variables mapped to internal data storage location
+#define FAR			// variables mapped to external data storage location
+#define CONST           const	// variables mapped to ROM (i.e. flash)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define LARGE			// functions set parameters to external data storage location
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                     // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-    #define MEM                         // Memory attribute to optimize speed and code of pointer access.
-
-    #define HWACC                       // hardware access through external memory (i.e. CAN)
-
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef NDEBUG
-        #include <stdio.h>              // prototype printf() (for TRACE)
-        #define TRACE  printf
-    #endif
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+
+#define HWACC			// hardware access through external memory (i.e. CAN)
+
+#define REENTRANT
+#define PUBLIC
+
+#ifndef NDEBUG
+#include <stdio.h>		// prototype printf() (for TRACE)
+#define TRACE  printf
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for BECK 1x3
 //---------------------------------------------------------------------------
 #elif defined (__BORLANDC__) && defined (__PARADIGM__)
 
+#define TARGET_SYSTEM      _NO_OS_
+#define DEV_SYSTEM         _DEV_PAR_BECK1X3_
 
-     #define TARGET_SYSTEM      _NO_OS_
-     #define DEV_SYSTEM         _DEV_PAR_BECK1X3_
-
-
-
-     #define ROM                     // code or variables mapped to ROM (i.e. flash)
-                                     // usage: CONST BYTE ROM foo = 0x00;
-     #define HWACC                   // hardware access through external memory (i.e. CAN)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+				     // usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
 
      // These types can be adjusted by users to match application requirements. The goal is to
      // minimize code memory and maximize speed.
-     #define GENERIC                 // generic pointer to point to application data
-                                     // Variables with this attribute can be located in external
-                                     // or internal data memory.
-     #define MEM                     // Memory attribute to optimize speed and code of pointer access.
-     #define NEAR __near             // variables mapped to internal data storage location
-     #define FAR  __far              // variables mapped to external data storage location
-     #define CONST const             // variables mapped to ROM (i.e. flash)
-     #define LARGE
-
-     #define REENTRANT
-     #define PUBLIC
-
-     #ifndef NDEBUG
-         #ifndef TRACE
-             #include <stdio.h>
-             #define TRACE printf
-         #endif
-     #endif
+#define GENERIC			// generic pointer to point to application data
+				     // Variables with this attribute can be located in external
+				     // or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+#define NEAR __near		// variables mapped to internal data storage location
+#define FAR  __far		// variables mapped to external data storage location
+#define CONST const		// variables mapped to ROM (i.e. flash)
+#define LARGE
 
+#define REENTRANT
+#define PUBLIC
 
+#ifndef NDEBUG
+#ifndef TRACE
+#include <stdio.h>
+#define TRACE printf
+#endif
+#endif
 
 //---------------------------------------------------------------------------
 //  definitions for PC
@@ -949,113 +931,111 @@
 
     // ------------------ definition target system --------------------------
 
-    #ifdef _WIN32
-        #define TARGET_SYSTEM   _WIN32_     // WIN32 definition
-        #define DEV_SYSTEM      _DEV_WIN32_
-    #else
-        #define TARGET_SYSTEM   _DOS_
-        #define DEV_SYSTEM      _DEV_BORLAND_DOS_
-    #endif
-
+#ifdef _WIN32
+#define TARGET_SYSTEM   _WIN32_	// WIN32 definition
+#define DEV_SYSTEM      _DEV_WIN32_
+#else
+#define TARGET_SYSTEM   _DOS_
+#define DEV_SYSTEM      _DEV_BORLAND_DOS_
+#endif
 
     // ------------------ WIN32 ---------------------------------------------
 
-    #if (TARGET_SYSTEM == _WIN32_)
+#if (TARGET_SYSTEM == _WIN32_)
+
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+
+	// These types can be adjusted by users to match application requirements. The goal is to
+	// minimize code memory and maximize speed.
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+
+#ifndef NEAR
+#define NEAR			// variables mapped to internal data storage location
+#endif
+
+#ifndef FAR
+#define FAR			// variables mapped to external data storage location
+#endif
+
+#ifndef CONST
+#define CONST const		// variables mapped to ROM (i.e. flash)
+#endif
+
+#define LARGE
+
+#define REENTRANT
+#define PUBLIC __stdcall
 
-        #define ROM                     // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-        #define HWACC                   // hardware access through external memory (i.e. CAN)
-
-        // These types can be adjusted by users to match application requirements. The goal is to
-        // minimize code memory and maximize speed.
-        #define GENERIC                 // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-        #define MEM                     // Memory attribute to optimize speed and code of pointer access.
-
-        #ifndef NEAR
-            #define NEAR                // variables mapped to internal data storage location
-        #endif
-
-        #ifndef FAR
-            #define FAR                 // variables mapped to external data storage location
-        #endif
-
-        #ifndef CONST
-            #define CONST const         // variables mapped to ROM (i.e. flash)
-        #endif
-
-        #define LARGE
-
-        #define REENTRANT
-        #define PUBLIC __stdcall
-
-        #ifndef NDEBUG
-            #ifndef TRACE
-                    #include <stdio.h>
-            #define TRACE printf
-            #endif
-        #endif
-
-    #elif (TARGET_SYSTEM == _DOS_)
-
-        #define ROM                     // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-        #define HWACC                   // hardware access through external memory (i.e. CAN)
-
-        // These types can be adjusted by users to match application requirements. The goal is to
-        // minimize code memory and maximize speed.
-        #define GENERIC                 // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-        #define MEM                     // Memory attribute to optimize speed and code of pointer access.
-        #define NEAR near               // variables mapped to internal data storage location
-        #define FAR  far                // variables mapped to external data storage location
-        #define CONST const             // variables mapped to ROM (i.e. flash)
-        #define LARGE
-
-        #define REENTRANT
-        #define PUBLIC
-
-        #ifndef NDEBUG
-            #ifndef TRACE
-                #include <stdio.h>
-                #define TRACE printf
-            #endif
-        #endif
-
-    #endif
-
-#elif (_MSC_VER == 800) // PC MS Visual C/C++ for DOS applications
-
-    #define TARGET_SYSTEM   _DOS_
-    #define DEV_SYSTEM      _DEV_MSVC_DOS_
-
-    #define ROM                     // code or variables mapped to ROM (i.e. flash)
-                                    // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC near              // hardware access through external memory (i.e. CAN)
+#ifndef NDEBUG
+#ifndef TRACE
+#include <stdio.h>
+#define TRACE printf
+#endif
+#endif
+
+#elif (TARGET_SYSTEM == _DOS_)
+
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+
+	// These types can be adjusted by users to match application requirements. The goal is to
+	// minimize code memory and maximize speed.
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+#define NEAR near		// variables mapped to internal data storage location
+#define FAR  far		// variables mapped to external data storage location
+#define CONST const		// variables mapped to ROM (i.e. flash)
+#define LARGE
+
+#define REENTRANT
+#define PUBLIC
+
+#ifndef NDEBUG
+#ifndef TRACE
+#include <stdio.h>
+#define TRACE printf
+#endif
+#endif
+
+#endif
+
+#elif (_MSC_VER == 800)		// PC MS Visual C/C++ for DOS applications
+
+#define TARGET_SYSTEM   _DOS_
+#define DEV_SYSTEM      _DEV_MSVC_DOS_
+
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+				    // usage: CONST BYTE ROM foo = 0x00;
+#define HWACC near		// hardware access through external memory (i.e. CAN)
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                 // generic pointer to point to application data
-                                    // Variables with this attribute can be located in external
-                                    // or internal data memory.
-    #define MEM                     // Memory attribute to optimize speed and code of pointer access.
-    #define NEAR near               // variables mapped to internal data storage location
-    #define FAR  far                // variables mapped to external data storage location
-    #define CONST const             // variables mapped to ROM (i.e. flash)
-    #define LARGE
-
-    #define REENTRANT
-    #define PUBLIC
-
-    #ifndef NDEBUG
-        #ifndef TRACE
-            #include <stdio.h>
-            #define TRACE printf
-        #endif
-    #endif
+#define GENERIC			// generic pointer to point to application data
+				    // Variables with this attribute can be located in external
+				    // or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+#define NEAR near		// variables mapped to internal data storage location
+#define FAR  far		// variables mapped to external data storage location
+#define CONST const		// variables mapped to ROM (i.e. flash)
+#define LARGE
 
+#define REENTRANT
+#define PUBLIC
+
+#ifndef NDEBUG
+#ifndef TRACE
+#include <stdio.h>
+#define TRACE printf
+#endif
+#endif
 
 //---------------------------------------------------------------------------
 // definitions for RTX under WIN32
@@ -1063,42 +1043,42 @@
 #elif (defined (UNDER_RTSS) && defined (WIN32))
 
     // ------------------ definition target system --------------------------
-    #define TARGET_SYSTEM   _WIN32_RTX_
-    #define DEV_SYSTEM      _DEV_WIN32_RTX_
+#define TARGET_SYSTEM   _WIN32_RTX_
+#define DEV_SYSTEM      _DEV_WIN32_RTX_
 
-    #define ROM                     // code or variables mapped to ROM (i.e. flash)
-                                    // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC                   // hardware access through external memory (i.e. CAN)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+				    // usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                 // generic pointer to point to application data
-                                    // Variables with this attribute can be located in external
-                                    // or internal data memory.
-    #define MEM                     // Memory attribute to optimize speed and code of pointer access.
-
-    #ifndef NEAR
-        #define NEAR                // variables mapped to internal data storage location
-    #endif
-
-    #ifndef FAR
-        #define FAR                 // variables mapped to external data storage location
-    #endif
-
-    #ifndef CONST
-        #define CONST const         // variables mapped to ROM (i.e. flash)
-    #endif
-
-    #define LARGE
-
-    #define REENTRANT
-    #define PUBLIC __stdcall
-
-    #ifndef NDEBUG
-        #ifndef TRACE
-            #define TRACE RtPrintf
-        #endif
-    #endif
+#define GENERIC			// generic pointer to point to application data
+				    // Variables with this attribute can be located in external
+				    // or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+
+#ifndef NEAR
+#define NEAR			// variables mapped to internal data storage location
+#endif
+
+#ifndef FAR
+#define FAR			// variables mapped to external data storage location
+#endif
+
+#ifndef CONST
+#define CONST const		// variables mapped to ROM (i.e. flash)
+#endif
+
+#define LARGE
+
+#define REENTRANT
+#define PUBLIC __stdcall
+
+#ifndef NDEBUG
+#ifndef TRACE
+#define TRACE RtPrintf
+#endif
+#endif
 
 //---------------------------------------------------------------------------
 // definitions for WinCE
@@ -1106,341 +1086,288 @@
 #elif defined (_WIN32_WCE)
 
     // ------------------ definition target system --------------------------
-    #define TARGET_SYSTEM           _WINCE_
-    #define DEV_SYSTEM              _DEV_WIN_CE_
+#define TARGET_SYSTEM           _WINCE_
+#define DEV_SYSTEM              _DEV_WIN_CE_
 
-    #define ROM                     // code or variables mapped to ROM (i.e. flash)
-                                    // usage: CONST BYTE ROM foo = 0x00;
-    #define HWACC                   // hardware access through external memory (i.e. CAN)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+				    // usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
 
     // These types can be adjusted by users to match application requirements. The goal is to
     // minimize code memory and maximize speed.
-    #define GENERIC                 // generic pointer to point to application data
-                                    // Variables with this attribute can be located in external
-                                    // or internal data memory.
-    #define MEM                     // Memory attribute to optimize speed and code of pointer access.
-
-    #ifndef NEAR
-        #define NEAR                // variables mapped to internal data storage location
-    #endif
-
-    #ifndef FAR
-        #define FAR                 // variables mapped to external data storage location
-    #endif
-
-    #ifndef CONST
-        #define CONST const         // variables mapped to ROM (i.e. flash)
-    #endif
-
-    #define LARGE
-
-    #ifndef QWORD
-      //#define QWORD long long int // MSVC .NET can use "long long int" too (like GNU)
-        #define QWORD __int64
-    #endif
+#define GENERIC			// generic pointer to point to application data
+				    // Variables with this attribute can be located in external
+				    // or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
 
-    #define REENTRANT
-    #define PUBLIC __cdecl
-
-    #ifdef ASSERTMSG
-        #undef ASSERTMSG
-    #endif
-
-    #ifndef NDEBUG
-        #ifndef TRACE
-            #define TRACE printf
-//            void trace (char *fmt, ...);
-        #endif
-    #endif
-
-#else   // ===> PC MS Visual C/C++
-
-    // ------------------ definition target system --------------------------
-
-    #ifdef _WIN32
-        #define TARGET_SYSTEM   _WIN32_     // WIN32 definition
-        #define DEV_SYSTEM      _DEV_WIN32_
-    #else
-        #define TARGET_SYSTEM   _WIN16_     // WIN16 definition
-        #define DEV_SYSTEM      _DEV_WIN16_
-    #endif
+#ifndef NEAR
+#define NEAR			// variables mapped to internal data storage location
+#endif
 
+#ifndef FAR
+#define FAR			// variables mapped to external data storage location
+#endif
 
-    // ------------------ WIN16 ---------------------------------------------
+#ifndef CONST
+#define CONST const		// variables mapped to ROM (i.e. flash)
+#endif
 
-    #if (TARGET_SYSTEM == _WIN16_)
+#define LARGE
 
-        #define ROM                     // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-        #define HWACC                   // hardware access through external memory (i.e. CAN)
-
-        // These types can be adjusted by users to match application requirements. The goal is to
-        // minimize code memory and maximize speed.
-        #define GENERIC                 // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-        #define MEM                     // Memory attribute to optimize speed and code of pointer access.
-
-        #ifndef NEAR
-            #define NEAR                // variables mapped to internal data storage location
-        #endif
-
-        #ifndef FAR
-            #define FAR far             // variables mapped to external data storage location
-        #endif
-
-        #ifndef CONST
-            #define CONST const         // variables mapped to ROM (i.e. flash)
-        #endif
-
-        #define LARGE
-
-        #define REENTRANT
-        #define PUBLIC _far _pascal _export
-
-        #ifndef NDEBUG
-            #ifndef TRACE
-                #define TRACE trace
-                #ifdef __cplusplus
-                    extern "C"
-                    {
-                #endif
-                    void trace (const char *fmt, ...);
-                #ifdef __cplusplus
-                    }
-                #endif
-            #endif
-        #endif
+#ifndef QWORD
+      //#define QWORD long long int // MSVC .NET can use "long long int" too (like GNU)
+#define QWORD __int64
+#endif
 
-    #endif
+#define REENTRANT
+#define PUBLIC __cdecl
 
+#ifdef ASSERTMSG
+#undef ASSERTMSG
+#endif
 
-    // ------------------ WIN32 ---------------------------------------------
+#ifndef NDEBUG
+#ifndef TRACE
+#define TRACE printf
+//            void trace (char *fmt, ...);
+#endif
+#endif
 
-   #if (TARGET_SYSTEM == _WIN32_)
+#else // ===> PC MS Visual C/C++
 
-        #define ROM                     // code or variables mapped to ROM (i.e. flash)
-                                        // usage: CONST BYTE ROM foo = 0x00;
-        #define HWACC                   // hardware access through external memory (i.e. CAN)
+    // ------------------ definition target system --------------------------
 
-        // These types can be adjusted by users to match application requirements. The goal is to
-        // minimize code memory and maximize speed.
-        #define GENERIC                 // generic pointer to point to application data
-                                        // Variables with this attribute can be located in external
-                                        // or internal data memory.
-        #define MEM                     // Memory attribute to optimize speed and code of pointer access.
+#ifdef _WIN32
+#define TARGET_SYSTEM   _WIN32_	// WIN32 definition
+#define DEV_SYSTEM      _DEV_WIN32_
+#else
+#define TARGET_SYSTEM   _WIN16_	// WIN16 definition
+#define DEV_SYSTEM      _DEV_WIN16_
+#endif
 
-        #ifndef NEAR
-            #define NEAR                // variables mapped to internal data storage location
-        #endif
+    // ------------------ WIN16 ---------------------------------------------
 
-        #ifndef FAR
-            #define FAR                 // variables mapped to external data storage location
-        #endif
+#if (TARGET_SYSTEM == _WIN16_)
 
-        #ifndef CONST
-            #define CONST const         // variables mapped to ROM (i.e. flash)
-        #endif
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+
+	// These types can be adjusted by users to match application requirements. The goal is to
+	// minimize code memory and maximize speed.
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external
+					// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
 
-        #define LARGE
+#ifndef NEAR
+#define NEAR			// variables mapped to internal data storage location
+#endif
 
-        #define REENTRANT
-        #define PUBLIC __stdcall
+#ifndef FAR
+#define FAR far			// variables mapped to external data storage location
+#endif
 
-        #ifndef QWORD
-          //#define QWORD long long int // MSVC .NET can use "long long int" too (like GNU)
-            #define QWORD __int64
-        #endif
+#ifndef CONST
+#define CONST const		// variables mapped to ROM (i.e. flash)
+#endif
 
-        #ifndef NDEBUG
-            #ifndef TRACE
-                #define TRACE trace
-                #ifdef __cplusplus
-                    extern "C"
-                    {
-                #endif
-                    void trace (const char *fmt, ...);
-                #ifdef __cplusplus
-                    }
-                #endif
-            #endif
-        #endif
+#define LARGE
 
-        // MS Visual C++ compiler supports function inlining
-        #define INLINE_FUNCTION_DEF __forceinline
+#define REENTRANT
+#define PUBLIC _far _pascal _export
 
-        // to actually enable inlining just include the following two lines
-        // #define INLINE_FUNCTION     INLINE_FUNCTION_DEF
-        // #define INLINE_ENABLED      TRUE
+#ifndef NDEBUG
+#ifndef TRACE
+#define TRACE trace
+#ifdef __cplusplus
+extern "C" {
+#endif
+	void trace(const char *fmt, ...);
+#ifdef __cplusplus
+}
+#endif
+#endif
+#endif
+#endif
+    // ------------------ WIN32 ---------------------------------------------
+#if (TARGET_SYSTEM == _WIN32_)
+#define ROM			// code or variables mapped to ROM (i.e. flash)
+					// usage: CONST BYTE ROM foo = 0x00;
+#define HWACC			// hardware access through external memory (i.e. CAN)
+	// These types can be adjusted by users to match application requirements. The goal is to// minimize code memory and maximize speed.
+#define GENERIC			// generic pointer to point to application data
+					// Variables with this attribute can be located in external// or internal data memory.
+#define MEM			// Memory attribute to optimize speed and code of pointer access.
+#ifndef NEAR
+#define NEAR			// variables mapped to internal data storage location
+#endif
+#ifndef FAR
+#define FAR			// variables mapped to external data storage location
+#endif
+#ifndef CONST
+#define CONST const		// variables mapped to ROM (i.e. flash)
+#endif
+#define LARGE
+#define REENTRANT
+#define PUBLIC __stdcall
+#ifndef QWORD
+	  //#define QWORD long long int // MSVC .NET can use "long long int" too (like GNU)
+#define QWORD __int64
+#endif
+#ifndef NDEBUG
+#ifndef TRACE
+#define TRACE trace
+#ifdef __cplusplus
+extern "C" {
+#endif
+	void trace(const char *fmt, ...);
+#ifdef __cplusplus
+}
+#endif
+#endif
+#endif
+	// MS Visual C++ compiler supports function inlining
+#define INLINE_FUNCTION_DEF __forceinline
+	// to actually enable inlining just include the following two lines// #define INLINE_FUNCTION     INLINE_FUNCTION_DEF// #define INLINE_ENABLED      TRUE
+#endif
+#endif				// ===> PC
+//---------------------------------------------------------------------------//  definitions of basic types//---------------------------------------------------------------------------
+#ifndef _WINDEF_		// defined in WINDEF.H, included by <windows.h>
+    // --- arithmetic types ---
+#ifndef SHORT
+#define SHORT short int
+#endif
+#ifndef USHORT
+#define USHORT unsigned short int
+#endif
+#ifndef INT
+#define INT int
+#endif
+#ifndef UINT
+#define UINT unsigned int
+#endif
+#ifndef LONG
+#define LONG long int
+#endif
+#ifndef ULONG
+#define ULONG unsigned long int
+#endif
+    // --- logic types ---
+#ifndef BYTE
+#define BYTE unsigned char
+#endif
+#ifndef WORD
+#define WORD unsigned short int
+#endif
+#ifndef DWORD
+#define DWORD unsigned long int
+#endif
+#ifndef BOOL
+#define BOOL unsigned char
+#endif
+    // --- alias types ---
+#ifndef TRUE
+#define TRUE  0xFF
+#endif
+#ifndef FALSE
+#define FALSE 0x00
+#endif
+#ifndef NULL
+#define NULL ((void *) 0)
+#endif
+#endif
+#ifndef _TIME_OF_DAY_DEFINED_
+typedef struct {
+	unsigned long int m_dwMs;
+	unsigned short int m_wDays;
 
-    #endif
+} tTimeOfDay;
 
-#endif  // ===> PC
+#define _TIME_OF_DAY_DEFINED_
 
+#endif
 
 //---------------------------------------------------------------------------
-//  definitions of basic types
+//  Definition von TRACE
 //---------------------------------------------------------------------------
 
-#ifndef _WINDEF_        // defined in WINDEF.H, included by <windows.h>
-
-    // --- arithmetic types ---
-    #ifndef SHORT
-        #define SHORT short int
-    #endif
-
-    #ifndef USHORT
-        #define USHORT unsigned short int
-    #endif
-
-    #ifndef INT
-        #define INT int
-    #endif
-
-    #ifndef UINT
-        #define UINT unsigned int
-    #endif
-
-    #ifndef LONG
-        #define LONG long int
-    #endif
-
-    #ifndef ULONG
-        #define ULONG unsigned long int
-    #endif
-
-
-    // --- logic types ---
-    #ifndef BYTE
-        #define BYTE unsigned char
-    #endif
-
-    #ifndef WORD
-        #define WORD unsigned short int
-    #endif
-
-    #ifndef DWORD
-        #define DWORD unsigned long int
-    #endif
-
-    #ifndef BOOL
-        #define BOOL unsigned char
-    #endif
-
-
-    // --- alias types ---
-    #ifndef TRUE
-        #define TRUE  0xFF
-    #endif
-
-    #ifndef FALSE
-        #define FALSE 0x00
-    #endif
-
-    #ifndef NULL
-        #define NULL ((void *) 0)
-    #endif
+#ifndef NDEBUG
 
+#ifndef TRACE0
+#define TRACE0(p0)                      TRACE(p0)
 #endif
 
+#ifndef TRACE1
+#define TRACE1(p0, p1)                  TRACE(p0, p1)
+#endif
 
-#ifndef _TIME_OF_DAY_DEFINED_
+#ifndef TRACE2
+#define TRACE2(p0, p1, p2)              TRACE(p0, p1, p2)
+#endif
 
-    typedef struct
-    {
-        unsigned long  int  m_dwMs;
-        unsigned short int  m_wDays;
+#ifndef TRACE3
+#define TRACE3(p0, p1, p2, p3)          TRACE(p0, p1, p2, p3)
+#endif
 
-    } tTimeOfDay;
+#ifndef TRACE4
+#define TRACE4(p0, p1, p2, p3, p4)      TRACE(p0, p1, p2, p3, p4)
+#endif
 
-    #define _TIME_OF_DAY_DEFINED_
+#ifndef TRACE5
+#define TRACE5(p0, p1, p2, p3, p4, p5)  TRACE(p0, p1, p2, p3, p4, p5)
+#endif
 
+#ifndef TRACE6
+#define TRACE6(p0, p1, p2, p3, p4, p5, p6)  TRACE(p0, p1, p2, p3, p4, p5, p6)
 #endif
 
+#else
 
-//---------------------------------------------------------------------------
-//  Definition von TRACE
-//---------------------------------------------------------------------------
+#ifndef TRACE0
+#define TRACE0(p0)
+#endif
 
-#ifndef NDEBUG
+#ifndef TRACE1
+#define TRACE1(p0, p1)
+#endif
 
-    #ifndef TRACE0
-        #define TRACE0(p0)                      TRACE(p0)
-    #endif
-
-    #ifndef TRACE1
-        #define TRACE1(p0, p1)                  TRACE(p0, p1)
-    #endif
-
-    #ifndef TRACE2
-        #define TRACE2(p0, p1, p2)              TRACE(p0, p1, p2)
-    #endif
-
-    #ifndef TRACE3
-        #define TRACE3(p0, p1, p2, p3)          TRACE(p0, p1, p2, p3)
-    #endif
-
-    #ifndef TRACE4
-        #define TRACE4(p0, p1, p2, p3, p4)      TRACE(p0, p1, p2, p3, p4)
-    #endif
-
-    #ifndef TRACE5
-        #define TRACE5(p0, p1, p2, p3, p4, p5)  TRACE(p0, p1, p2, p3, p4, p5)
-    #endif
-
-    #ifndef TRACE6
-        #define TRACE6(p0, p1, p2, p3, p4, p5, p6)  TRACE(p0, p1, p2, p3, p4, p5, p6)
-    #endif
+#ifndef TRACE2
+#define TRACE2(p0, p1, p2)
+#endif
 
-#else
+#ifndef TRACE3
+#define TRACE3(p0, p1, p2, p3)
+#endif
 
-    #ifndef TRACE0
-        #define TRACE0(p0)
-    #endif
-
-    #ifndef TRACE1
-        #define TRACE1(p0, p1)
-    #endif
-
-    #ifndef TRACE2
-        #define TRACE2(p0, p1, p2)
-    #endif
-
-    #ifndef TRACE3
-        #define TRACE3(p0, p1, p2, p3)
-    #endif
-
-    #ifndef TRACE4
-        #define TRACE4(p0, p1, p2, p3, p4)
-    #endif
-
-    #ifndef TRACE5
-        #define TRACE5(p0, p1, p2, p3, p4, p5)
-    #endif
-
-    #ifndef TRACE6
-        #define TRACE6(p0, p1, p2, p3, p4, p5, p6)
-    #endif
+#ifndef TRACE4
+#define TRACE4(p0, p1, p2, p3, p4)
+#endif
 
+#ifndef TRACE5
+#define TRACE5(p0, p1, p2, p3, p4, p5)
 #endif
 
+#ifndef TRACE6
+#define TRACE6(p0, p1, p2, p3, p4, p5, p6)
+#endif
 
+#endif
 
 //---------------------------------------------------------------------------
 //  definition of ASSERT
 //---------------------------------------------------------------------------
 
 #ifndef ASSERT
-    #if !defined (__linux__) && !defined (__KERNEL__)
-        #include <assert.h>
-        #ifndef ASSERT
-            #define ASSERT(p)    assert(p)
-        #endif
-    #else
-        #define ASSERT(p)
-    #endif
+#if !defined (__linux__) && !defined (__KERNEL__)
+#include <assert.h>
+#ifndef ASSERT
+#define ASSERT(p)    assert(p)
+#endif
+#else
+#define ASSERT(p)
+#endif
 #endif
-
 
 //---------------------------------------------------------------------------
 //  SYS TEC extensions
@@ -1450,19 +1377,15 @@
 // but a string, which exactly names the mistake.
 #ifndef NDEBUG
 
-    #define ASSERTMSG(expr,string)  if (!(expr)) {\
+#define ASSERTMSG(expr,string)  if (!(expr)) {\
                                         PRINTF0 ("Assertion failed: " string );\
                                         while (1);}
 #else
-    #define ASSERTMSG(expr,string)
+#define ASSERTMSG(expr,string)
 #endif
 
-
-
-
 //---------------------------------------------------------------------------
 
-#endif  // #ifndef _GLOBAL_H_
+#endif // #ifndef _GLOBAL_H_
 
 // Please keep an empty line at the end of this file.
-
--- a/drivers/staging/epl/proc_fs.h
+++ b/drivers/staging/epl/proc_fs.h
@@ -71,7 +71,6 @@
 #ifndef _EPLPROCFS_H_
 #define _EPLPROCFS_H_
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
@@ -80,7 +79,6 @@
 // types
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // function prototypes
 //---------------------------------------------------------------------------
@@ -88,7 +86,4 @@
 tEplKernel EplLinProcInit(void);
 tEplKernel EplLinProcFree(void);
 
-
-#endif  // #ifndef _EPLPROCFS_H_
-
-
+#endif // #ifndef _EPLPROCFS_H_
--- a/drivers/staging/epl/SharedBuff.h
+++ b/drivers/staging/epl/SharedBuff.h
@@ -57,60 +57,50 @@
 #ifndef _SHAREDBUFF_H_
 #define _SHAREDBUFF_H_
 
-
-
 //---------------------------------------------------------------------------
 //  Type definitions
 //---------------------------------------------------------------------------
 
-typedef enum
-{
-    kShbOk                      =  0,
-    kShbNoReadableData          =  1,
-    kShbDataTruncated           =  2,
-    kShbBufferFull              =  3,
-    kShbDataOutsideBufferArea   =  4,
-    kShbBufferAlreadyCompleted  =  5,
-    kShbMemUsedByOtherProcs     =  6,
-    kShbOpenMismatch            =  7,
-    kShbInvalidBufferType       =  8,
-    kShbInvalidArg              =  9,
-    kShbBufferInvalid           = 10,
-    kShbOutOfMem                = 11,
-    kShbAlreadyReseting         = 12,
-    kShbAlreadySignaling        = 13,
-    kShbExceedDataSizeLimit     = 14,
+typedef enum {
+	kShbOk = 0,
+	kShbNoReadableData = 1,
+	kShbDataTruncated = 2,
+	kShbBufferFull = 3,
+	kShbDataOutsideBufferArea = 4,
+	kShbBufferAlreadyCompleted = 5,
+	kShbMemUsedByOtherProcs = 6,
+	kShbOpenMismatch = 7,
+	kShbInvalidBufferType = 8,
+	kShbInvalidArg = 9,
+	kShbBufferInvalid = 10,
+	kShbOutOfMem = 11,
+	kShbAlreadyReseting = 12,
+	kShbAlreadySignaling = 13,
+	kShbExceedDataSizeLimit = 14,
 
 } tShbError;
 
-
 // 2006/08/24 d.k.: Priority for threads (new data, job signaling)
-typedef enum
-{
-    kShbPriorityLow             =  0,
-    kShbPriorityNormal          =  1,
-    kshbPriorityHigh            =  2
-
+typedef enum {
+	kShbPriorityLow = 0,
+	kShbPriorityNormal = 1,
+	kshbPriorityHigh = 2
 } tShbPriority;
 
-
-typedef struct
-{
-    unsigned int   m_uiFullBlockSize;       // real size of allocated block (incl. alignment fill bytes)
-    unsigned long  m_ulAvailableSize;       // still available size for data
-    unsigned long  m_ulWrIndex;             // current write index
-    unsigned int   m_fBufferCompleted;      // TRUE if allocated block is complete filled with data
+typedef struct {
+	unsigned int m_uiFullBlockSize;	// real size of allocated block (incl. alignment fill bytes)
+	unsigned long m_ulAvailableSize;	// still available size for data
+	unsigned long m_ulWrIndex;	// current write index
+	unsigned int m_fBufferCompleted;	// TRUE if allocated block is complete filled with data
 
 } tShbCirChunk;
 
+typedef void *tShbInstance;
 
-typedef void*  tShbInstance;
-
-
-typedef void  (*tShbCirSigHndlrNewData)  (tShbInstance pShbInstance_p, unsigned long ulDataBlockSize_p);
-typedef void  (*tShbCirSigHndlrReset)    (tShbInstance pShbInstance_p, unsigned int fTimeOut_p);
-
-
+typedef void (*tShbCirSigHndlrNewData) (tShbInstance pShbInstance_p,
+					unsigned long ulDataBlockSize_p);
+typedef void (*tShbCirSigHndlrReset) (tShbInstance pShbInstance_p,
+				      unsigned int fTimeOut_p);
 
 //---------------------------------------------------------------------------
 //  Prototypes
@@ -129,55 +119,86 @@ extern "C" {
 #endif
 */
 
-tShbError  ShbInit (void);
-tShbError  ShbExit (void);
+	tShbError ShbInit(void);
+	tShbError ShbExit(void);
 
 // Circular Shared Buffer
-tShbError  ShbCirAllocBuffer             (unsigned long ulBufferSize_p, const char* pszBufferID_p, tShbInstance* ppShbInstance_p, unsigned int* pfShbNewCreated_p);
-tShbError  ShbCirReleaseBuffer           (tShbInstance pShbInstance_p);
+	tShbError ShbCirAllocBuffer(unsigned long ulBufferSize_p,
+				    const char *pszBufferID_p,
+				    tShbInstance * ppShbInstance_p,
+				    unsigned int *pfShbNewCreated_p);
+	tShbError ShbCirReleaseBuffer(tShbInstance pShbInstance_p);
 
 #if !defined(INLINE_ENABLED)
 
-tShbError  ShbCirResetBuffer             (tShbInstance pShbInstance_p, unsigned long ulTimeOut_p, tShbCirSigHndlrReset pfnSignalHandlerReset_p);
-tShbError  ShbCirWriteDataBlock          (tShbInstance pShbInstance_p, const void* pSrcDataBlock_p, unsigned long ulDataBlockSize_p);
-tShbError  ShbCirAllocDataBlock          (tShbInstance pShbInstance_p, tShbCirChunk* pShbCirChunk_p, unsigned long ulDataBufferSize_p);
-tShbError  ShbCirWriteDataChunk          (tShbInstance pShbInstance_p, tShbCirChunk* pShbCirChunk_p, const void* pSrcDataChunk_p, unsigned long ulDataChunkSize_p, unsigned int* pfBufferCompleted_p);
-tShbError  ShbCirReadDataBlock           (tShbInstance pShbInstance_p, void* pDstDataBlock_p, unsigned long ulRdBuffSize_p, unsigned long* pulDataBlockSize_p);
-tShbError  ShbCirGetReadDataSize         (tShbInstance pShbInstance_p, unsigned long* pulDataBlockSize_p);
-tShbError  ShbCirGetReadBlockCount       (tShbInstance pShbInstance_p, unsigned long* pulDataBlockCount_p);
-tShbError  ShbCirSetSignalHandlerNewData (tShbInstance pShbInstance_p, tShbCirSigHndlrNewData pfnShbSignalHandlerNewData_p, tShbPriority ShbPriority_p);
+	tShbError ShbCirResetBuffer(tShbInstance pShbInstance_p,
+				    unsigned long ulTimeOut_p,
+				    tShbCirSigHndlrReset
+				    pfnSignalHandlerReset_p);
+	tShbError ShbCirWriteDataBlock(tShbInstance pShbInstance_p,
+				       const void *pSrcDataBlock_p,
+				       unsigned long ulDataBlockSize_p);
+	tShbError ShbCirAllocDataBlock(tShbInstance pShbInstance_p,
+				       tShbCirChunk * pShbCirChunk_p,
+				       unsigned long ulDataBufferSize_p);
+	tShbError ShbCirWriteDataChunk(tShbInstance pShbInstance_p,
+				       tShbCirChunk * pShbCirChunk_p,
+				       const void *pSrcDataChunk_p,
+				       unsigned long ulDataChunkSize_p,
+				       unsigned int *pfBufferCompleted_p);
+	tShbError ShbCirReadDataBlock(tShbInstance pShbInstance_p,
+				      void *pDstDataBlock_p,
+				      unsigned long ulRdBuffSize_p,
+				      unsigned long *pulDataBlockSize_p);
+	tShbError ShbCirGetReadDataSize(tShbInstance pShbInstance_p,
+					unsigned long *pulDataBlockSize_p);
+	tShbError ShbCirGetReadBlockCount(tShbInstance pShbInstance_p,
+					  unsigned long *pulDataBlockCount_p);
+	tShbError ShbCirSetSignalHandlerNewData(tShbInstance pShbInstance_p,
+						tShbCirSigHndlrNewData
+						pfnShbSignalHandlerNewData_p,
+						tShbPriority ShbPriority_p);
 
 #endif
 
 // Linear Shared Buffer
-tShbError  ShbLinAllocBuffer             (unsigned long ulBufferSize_p, const char* pszBufferID_p, tShbInstance* ppShbInstance_p, unsigned int* pfShbNewCreated_p);
-tShbError  ShbLinReleaseBuffer           (tShbInstance pShbInstance_p);
+	tShbError ShbLinAllocBuffer(unsigned long ulBufferSize_p,
+				    const char *pszBufferID_p,
+				    tShbInstance * ppShbInstance_p,
+				    unsigned int *pfShbNewCreated_p);
+	tShbError ShbLinReleaseBuffer(tShbInstance pShbInstance_p);
 
 #if !defined(INLINE_ENABLED)
 
-tShbError  ShbLinWriteDataBlock          (tShbInstance pShbInstance_p, unsigned long ulDstBufferOffs_p, const void* pSrcDataBlock_p, unsigned long ulDataBlockSize_p);
-tShbError  ShbLinReadDataBlock           (tShbInstance pShbInstance_p, void* pDstDataBlock_p, unsigned long ulSrcBufferOffs_p, unsigned long ulDataBlockSize_p);
+	tShbError ShbLinWriteDataBlock(tShbInstance pShbInstance_p,
+				       unsigned long ulDstBufferOffs_p,
+				       const void *pSrcDataBlock_p,
+				       unsigned long ulDataBlockSize_p);
+	tShbError ShbLinReadDataBlock(tShbInstance pShbInstance_p,
+				      void *pDstDataBlock_p,
+				      unsigned long ulSrcBufferOffs_p,
+				      unsigned long ulDataBlockSize_p);
 
 #endif
 
 #ifndef NDEBUG
-    tShbError  ShbCirTraceBuffer         (tShbInstance pShbInstance_p);
-    tShbError  ShbLinTraceBuffer         (tShbInstance pShbInstance_p);
-    tShbError  ShbTraceDump              (const unsigned char* pabStartAddr_p, unsigned long ulDataSize_p, unsigned long ulAddrOffset_p, const char* pszInfoText_p);
+	tShbError ShbCirTraceBuffer(tShbInstance pShbInstance_p);
+	tShbError ShbLinTraceBuffer(tShbInstance pShbInstance_p);
+	tShbError ShbTraceDump(const unsigned char *pabStartAddr_p,
+			       unsigned long ulDataSize_p,
+			       unsigned long ulAddrOffset_p,
+			       const char *pszInfoText_p);
 #else
-    #define ShbCirTraceBuffer(p0)
-    #define ShbLinTraceBuffer(p0)
-    #define ShbTraceDump(p0, p1, p2, p3)
+#define ShbCirTraceBuffer(p0)
+#define ShbLinTraceBuffer(p0)
+#define ShbTraceDump(p0, p1, p2, p3)
 #endif
 
-#undef  INLINE_ENABLED              // disable actual inlining of functions
+#undef  INLINE_ENABLED		// disable actual inlining of functions
 #undef  INLINE_FUNCTION
-#define INLINE_FUNCTION             // define INLINE_FUNCTION to nothing
+#define INLINE_FUNCTION		// define INLINE_FUNCTION to nothing
 
 #ifdef __cplusplus
 }
 #endif
-
-
-#endif // #ifndef _SHAREDBUFF_H_
-
+#endif				// #ifndef _SHAREDBUFF_H_
--- a/drivers/staging/epl/ShbIpc.h
+++ b/drivers/staging/epl/ShbIpc.h
@@ -57,64 +57,69 @@
 #ifndef _SHBIPC_H_
 #define _SHBIPC_H_
 
-
-
 //---------------------------------------------------------------------------
 //  Type definitions
 //---------------------------------------------------------------------------
 
-typedef  int   (*tSigHndlrNewData)  (tShbInstance pShbInstance_p);
-typedef  void  (*tSigHndlrJobReady) (tShbInstance pShbInstance_p, unsigned int fTimeOut_p);
-
+typedef int (*tSigHndlrNewData) (tShbInstance pShbInstance_p);
+typedef void (*tSigHndlrJobReady) (tShbInstance pShbInstance_p,
+				   unsigned int fTimeOut_p);
 
 #if (TARGET_SYSTEM == _WIN32_)
-    #if defined(INLINE_FUNCTION_DEF)
-        #undef  INLINE_FUNCTION
-        #define INLINE_FUNCTION     INLINE_FUNCTION_DEF
-        #define SHBIPC_INLINE_ENABLED      TRUE
-        #define SHBIPC_INLINED
-        #include "ShbIpc-Win32.c"
-    #endif
+#if defined(INLINE_FUNCTION_DEF)
+#undef  INLINE_FUNCTION
+#define INLINE_FUNCTION     INLINE_FUNCTION_DEF
+#define SHBIPC_INLINE_ENABLED      TRUE
+#define SHBIPC_INLINED
+#include "ShbIpc-Win32.c"
+#endif
 
 #elif (TARGET_SYSTEM == _LINUX_)
-    #if defined(INLINE_FUNCTION_DEF)
-        #undef  INLINE_FUNCTION
-        #define INLINE_FUNCTION     INLINE_FUNCTION_DEF
-        #define SHBIPC_INLINE_ENABLED      TRUE
-        #define SHBIPC_INLINED
-        #include "ShbIpc-LinuxKernel.c"
-    #endif
+#if defined(INLINE_FUNCTION_DEF)
+#undef  INLINE_FUNCTION
+#define INLINE_FUNCTION     INLINE_FUNCTION_DEF
+#define SHBIPC_INLINE_ENABLED      TRUE
+#define SHBIPC_INLINED
+#include "ShbIpc-LinuxKernel.c"
+#endif
 #endif
-
 
 //---------------------------------------------------------------------------
 //  Prototypes
 //---------------------------------------------------------------------------
 
-tShbError  ShbIpcInit (void);
-tShbError  ShbIpcExit (void);
+tShbError ShbIpcInit(void);
+tShbError ShbIpcExit(void);
 
-tShbError  ShbIpcAllocBuffer            (unsigned long ulBufferSize_p, const char* pszBufferID_p, tShbInstance* ppShbInstance_p, unsigned int* pfShbNewCreated_p);
-tShbError  ShbIpcReleaseBuffer          (tShbInstance pShbInstance_p);
+tShbError ShbIpcAllocBuffer(unsigned long ulBufferSize_p,
+			    const char *pszBufferID_p,
+			    tShbInstance * ppShbInstance_p,
+			    unsigned int *pfShbNewCreated_p);
+tShbError ShbIpcReleaseBuffer(tShbInstance pShbInstance_p);
 
 #if !defined(SHBIPC_INLINE_ENABLED)
 
-tShbError  ShbIpcEnterAtomicSection     (tShbInstance pShbInstance_p);
-tShbError  ShbIpcLeaveAtomicSection     (tShbInstance pShbInstance_p);
+tShbError ShbIpcEnterAtomicSection(tShbInstance pShbInstance_p);
+tShbError ShbIpcLeaveAtomicSection(tShbInstance pShbInstance_p);
 
-tShbError  ShbIpcStartSignalingNewData  (tShbInstance pShbInstance_p, tSigHndlrNewData pfnSignalHandlerNewData_p, tShbPriority ShbPriority_p);
-tShbError  ShbIpcStopSignalingNewData   (tShbInstance pShbInstance_p);
-tShbError  ShbIpcSignalNewData          (tShbInstance pShbInstance_p);
+tShbError ShbIpcStartSignalingNewData(tShbInstance pShbInstance_p,
+				      tSigHndlrNewData
+				      pfnSignalHandlerNewData_p,
+				      tShbPriority ShbPriority_p);
+tShbError ShbIpcStopSignalingNewData(tShbInstance pShbInstance_p);
+tShbError ShbIpcSignalNewData(tShbInstance pShbInstance_p);
+
+tShbError ShbIpcStartSignalingJobReady(tShbInstance pShbInstance_p,
+				       unsigned long ulTimeOut_p,
+				       tSigHndlrJobReady
+				       pfnSignalHandlerJobReady_p);
+tShbError ShbIpcSignalJobReady(tShbInstance pShbInstance_p);
 
-tShbError  ShbIpcStartSignalingJobReady (tShbInstance pShbInstance_p, unsigned long ulTimeOut_p, tSigHndlrJobReady pfnSignalHandlerJobReady_p);
-tShbError  ShbIpcSignalJobReady         (tShbInstance pShbInstance_p);
-
-void*      ShbIpcGetShMemPtr            (tShbInstance pShbInstance_p);
+void *ShbIpcGetShMemPtr(tShbInstance pShbInstance_p);
 #endif
 
-#undef  SHBIPC_INLINE_ENABLED              // disable actual inlining of functions
+#undef  SHBIPC_INLINE_ENABLED	// disable actual inlining of functions
 #undef  INLINE_FUNCTION
-#define INLINE_FUNCTION             // define INLINE_FUNCTION to nothing
+#define INLINE_FUNCTION		// define INLINE_FUNCTION to nothing
 
 #endif // #ifndef _SHBIPC_H_
-
--- a/drivers/staging/epl/ShbLinuxKernel.h
+++ b/drivers/staging/epl/ShbLinuxKernel.h
@@ -57,10 +57,10 @@
 #ifndef _SHBLINUXKERNEL_H_
 #define _SHBLINUXKERNEL_H_
 
-struct sShbMemTable{
-    int                 m_iBufferId;
-    void*               m_pBuffer;
-    struct sShbMemTable *m_psNextMemTableElement;
+struct sShbMemTable {
+	int m_iBufferId;
+	void *m_pBuffer;
+	struct sShbMemTable *m_psNextMemTableElement;
 };
 
 extern struct sShbMemTable *psMemTableElementFirst_g;
--- a/drivers/staging/epl/SocketLinuxKernel.h
+++ b/drivers/staging/epl/SocketLinuxKernel.h
@@ -66,17 +66,14 @@
 
   2006/08/25 d.k.:   start of the implementation
 
-
 ****************************************************************************/
 
-
 #ifndef _SOCKETLINUXKERNEL_H_
 #define _SOCKETLINUXKERNEL_H_
 
 #include <linux/net.h>
 #include <linux/in.h>
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
@@ -87,7 +84,7 @@
 // typedef
 //---------------------------------------------------------------------------
 
-typedef struct socket* SOCKET;
+typedef struct socket *SOCKET;
 
 //---------------------------------------------------------------------------
 // function prototypes
@@ -97,12 +94,12 @@ int bind(SOCKET s, const struct sockaddr
 
 int closesocket(SOCKET s);
 
-int recvfrom(SOCKET s, char* buf, int len, int flags, struct sockaddr *from, int * fromlen);
+int recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from,
+	     int *fromlen);
 
-int sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr *to, int tolen);
+int sendto(SOCKET s, const char *buf, int len, int flags,
+	   const struct sockaddr *to, int tolen);
 
 SOCKET socket(int af, int type, int protocol);
 
-#endif  // #ifndef _SOCKETLINUXKERNEL_H_
-
-
+#endif // #ifndef _SOCKETLINUXKERNEL_H_
