From jmm@debian.org  Mon Jul 20 19:42:04 2009
From: Moritz Muehlenhoff <jmm@debian.org>
Date: Tue, 21 Jul 2009 01:22:08 +0200
Subject: Staging: hv: Remove compatibility ifdefry
To: gregkh@suse.de, hjanssen@microsoft.com
Cc: Moritz Muehlenhoff <jmm@debian.org>
Message-ID: <1248132128-15722-1-git-send-email-jmm@debian.org>

From: Moritz Muehlenhoff <jmm@debian.org>

Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
Cc: Hank Janssen <hjanssen@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/hv/NetVsc.c        |    2 
 drivers/staging/hv/RndisFilter.c   |    2 
 drivers/staging/hv/Sources.c       |    2 
 drivers/staging/hv/StorVsc.c       |    2 
 drivers/staging/hv/TODO            |    1 
 drivers/staging/hv/blkvsc_drv.c    |   51 --------
 drivers/staging/hv/include/vmbus.h |   11 -
 drivers/staging/hv/netvsc_drv.c    |   27 ----
 drivers/staging/hv/storvsc_drv.c   |  218 -------------------------------------
 drivers/staging/hv/vmbus_drv.c     |  115 -------------------
 10 files changed, 431 deletions(-)

--- a/drivers/staging/hv/blkvsc_drv.c
+++ b/drivers/staging/hv/blkvsc_drv.c
@@ -20,8 +20,6 @@
  *
  */
 
-#define KERNEL_2_6_27
-
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/device.h>
@@ -186,14 +184,9 @@ int blkvsc_drv_init(PFN_DRIVERINITIALIZE
 	drv_ctx->driver.name = storvsc_drv_obj->Base.name;
 	memcpy(&drv_ctx->class_id, &storvsc_drv_obj->Base.deviceType, sizeof(GUID));
 
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-	drv_ctx->driver.probe = blkvsc_probe;
-	drv_ctx->driver.remove = blkvsc_remove;
-#else
 	drv_ctx->probe = blkvsc_probe;
 	drv_ctx->remove = blkvsc_remove;
 	drv_ctx->shutdown = blkvsc_shutdown;
-#endif
 
 	// The driver belongs to vmbus
 	vmbus_child_driver_register(drv_ctx);
@@ -225,16 +218,6 @@ void blkvsc_drv_exit(void)
 
 	struct device *current_dev=NULL;
 
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#define driver_for_each_device(drv, start, data, fn) \
-	struct list_head *ptr, *n; \
-	list_for_each_safe(ptr, n, &((drv)->devices)) {\
-		struct device *curr_dev;\
-		curr_dev = list_entry(ptr, struct device, driver_list);\
-		fn(curr_dev, data);\
-	}
-#endif // KERNEL_2_6_9
-
 	DPRINT_ENTER(BLKVSC_DRV);
 
 	while (1)
@@ -313,15 +296,9 @@ static int blkvsc_probe(struct device *d
 
 	ASSERT(sizeof(struct blkvsc_request_group) <= sizeof(struct blkvsc_request));
 
-#ifdef KERNEL_2_6_27
         blkdev->request_pool = kmem_cache_create(dev_name(&device_ctx->device),
                 sizeof(struct blkvsc_request) + storvsc_drv_obj->RequestExtSize, 0,
                 SLAB_HWCACHE_ALIGN, NULL);
-#else
-	blkdev->request_pool = kmem_cache_create(device_ctx->device.bus_id,
-		sizeof(struct blkvsc_request) + storvsc_drv_obj->RequestExtSize, 0,
-		SLAB_HWCACHE_ALIGN, NULL, NULL);
-#endif
 	if (!blkdev->request_pool)
 	{
 		ret = -ENOMEM;
@@ -1170,7 +1147,6 @@ static void blkvsc_request_completion(ST
 
 			list_del(&comp_req->req_entry);
 
-#ifdef KERNEL_2_6_27
 			if (!__blk_end_request(
 				comp_req->req,
 				(!comp_req->request.Status ? 0: -EIO),
@@ -1180,17 +1156,6 @@ static void blkvsc_request_completion(ST
 				DPRINT_DBG(BLKVSC_DRV, "req %p COMPLETED\n", comp_req->req);
 				kmem_cache_free(blkdev->request_pool, comp_req->group);
 			}
-#else
-			if (!end_that_request_first(comp_req->req, !comp_req->request.Status,  (comp_req->sector_count * (blkdev->sector_size >> 9))))
-			{
-				//All the sectors have been xferred ie the request is done
-				DPRINT_DBG(BLKVSC_DRV, "req %p COMPLETED\n", comp_req->req);
-
-				end_that_request_last(comp_req->req, !comp_req->request.Status);
-
-				kmem_cache_free(blkdev->request_pool, comp_req->group);
-			}
-#endif
 
 			kmem_cache_free(blkdev->request_pool, comp_req);
 		}
@@ -1234,14 +1199,10 @@ static int blkvsc_cancel_pending_reqs(st
 
 			if (comp_req->req)
 			{
-#ifdef KERNEL_2_6_27
 			ret = __blk_end_request(
 			    comp_req->req,
 			    (!comp_req->request.Status ? 0 : -EIO),
 			    comp_req->sector_count * blkdev->sector_size);
-#else
-			ret = end_that_request_first(comp_req->req, !comp_req->request.Status,  (comp_req->sector_count * (blkdev->sector_size >> 9)));
-#endif
 			ASSERT(ret != 0);
 			}
 
@@ -1256,7 +1217,6 @@ static int blkvsc_cancel_pending_reqs(st
 
 		if (comp_req->req)
 		{
-#ifdef KERNEL_2_6_27
 		if (!__blk_end_request(
 			pend_req->req,
 			-EIO,
@@ -1266,17 +1226,6 @@ static int blkvsc_cancel_pending_reqs(st
 			DPRINT_DBG(BLKVSC_DRV, "blkvsc_cancel_pending_reqs() - req %p COMPLETED\n", pend_req->req);
 			kmem_cache_free(blkdev->request_pool, pend_req->group);
 		}
-#else
-		if (!end_that_request_first(pend_req->req, 0,  (pend_req->sector_count * (blkdev->sector_size >> 9))))
-		{
-			//All the sectors have been xferred ie the request is done
-			DPRINT_DBG(BLKVSC_DRV, "blkvsc_cancel_pending_reqs() - req %p COMPLETED\n", pend_req->req);
-
-			end_that_request_last(pend_req->req, 0);
-
-			kmem_cache_free(blkdev->request_pool, pend_req->group);
-		}
-#endif
 		}
 
 		kmem_cache_free(blkdev->request_pool, pend_req);
--- a/drivers/staging/hv/include/vmbus.h
+++ b/drivers/staging/hv/include/vmbus.h
@@ -79,17 +79,6 @@ static inline struct driver_context *dri
 	return container_of(driver, struct driver_context, driver);
 }
 
-#if defined(KERNEL_2_6_5)
-static inline void* kzalloc(int size, int flags)
-{
-	void *p;
-	p = kmalloc(size, flags);
-	if (p) memset(p, 0, size);
-
-	return p;
-}
-#endif // KERNEL_2_6_5
-
 //
 // Vmbus interface
 //
--- a/drivers/staging/hv/NetVsc.c
+++ b/drivers/staging/hv/NetVsc.c
@@ -20,8 +20,6 @@
  *
  */
 
-#define KERNEL_2_6_27
-
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/delay.h>
--- a/drivers/staging/hv/netvsc_drv.c
+++ b/drivers/staging/hv/netvsc_drv.c
@@ -20,17 +20,11 @@
  *
  */
 
-#define KERNEL_2_6_27
-
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/highmem.h>
 #include <linux/device.h>
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#include <asm/io.h>
-#else
 #include <linux/io.h>
-#endif
 #include <linux/delay.h>
 #include <linux/netdevice.h>
 #include <linux/inetdevice.h>
@@ -116,13 +110,8 @@ int netvsc_drv_init(PFN_DRIVERINITIALIZE
 	drv_ctx->driver.name = net_drv_obj->Base.name;
 	memcpy(&drv_ctx->class_id, &net_drv_obj->Base.deviceType, sizeof(GUID));
 
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-	drv_ctx->driver.probe = netvsc_probe;
-	drv_ctx->driver.remove = netvsc_remove;
-#else
 	drv_ctx->probe = netvsc_probe;
 	drv_ctx->remove = netvsc_remove;
-#endif
 
 	// The driver belongs to vmbus
 	vmbus_child_driver_register(drv_ctx);
@@ -236,9 +225,6 @@ static int netvsc_probe(struct device *d
 
 	net->netdev_ops = &device_ops;
 
-#if !defined(KERNEL_2_6_27)
-	SET_MODULE_OWNER(net);
-#endif
 	SET_NETDEV_DEV(net, device);
 
 	ret = register_netdev(net);
@@ -485,10 +471,6 @@ retry_send:
 
 	if (ret == 0)
 	{
-#ifdef KERNEL_2_6_5
-#define NETDEV_TX_OK	0
-#define NETDEV_TX_BUSY	0
-#endif
 		ret = NETDEV_TX_OK;
 		net_device_ctx->stats.tx_bytes += skb->len;
 		net_device_ctx->stats.tx_packets++;
@@ -658,15 +640,6 @@ void netvsc_drv_exit(void)
 	struct driver_context *drv_ctx=&g_netvsc_drv.drv_ctx;
 
 	struct device *current_dev=NULL;
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#define driver_for_each_device(drv, start, data, fn) \
-	struct list_head *ptr, *n; \
-	list_for_each_safe(ptr, n, &((drv)->devices)) {\
-		struct device *curr_dev;\
-		curr_dev = list_entry(ptr, struct device, driver_list);\
-		fn(curr_dev, data);\
-	}
-#endif
 
 	DPRINT_ENTER(NETVSC_DRV);
 
--- a/drivers/staging/hv/RndisFilter.c
+++ b/drivers/staging/hv/RndisFilter.c
@@ -21,8 +21,6 @@
  *
  */
 
-#define KERNEL_2_6_27
-
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include "include/logging.h"
--- a/drivers/staging/hv/Sources.c
+++ b/drivers/staging/hv/Sources.c
@@ -21,8 +21,6 @@
  *
  */
 
-#define KERNEL_2_6_27
-
 #include "Vmbus.c"
 #include "Hv.c"
 #include "Connection.c"
--- a/drivers/staging/hv/StorVsc.c
+++ b/drivers/staging/hv/StorVsc.c
@@ -21,8 +21,6 @@
  *
  */
 
-#define KERNEL_2_6_27
-
 #include <linux/kernel.h>
 #include <linux/string.h>
 #include <linux/mm.h>
--- a/drivers/staging/hv/storvsc_drv.c
+++ b/drivers/staging/hv/storvsc_drv.c
@@ -21,8 +21,6 @@
  *
  */
 
-#define KERNEL_2_6_27
-
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/device.h>
@@ -36,10 +34,7 @@
 #include <scsi/scsi_eh.h>
 #include <scsi/scsi_devinfo.h>
 
-#ifdef KERNEL_2_6_5
-#else
 #include <scsi/scsi_dbg.h>
-#endif
 
 #include "include/logging.h"
 #include "include/vmbus.h"
@@ -56,11 +51,7 @@
 struct host_device_context {
     struct work_struct		host_rescan_work;  //must be 1st field
     struct device_context	*device_ctx; // point back to our device context
-#ifdef KERNEL_2_6_27
     struct kmem_cache               *request_pool;
-#else
-    kmem_cache_t			*request_pool;
-#endif
     unsigned int			port;
     unsigned char			path;
     unsigned char			target;
@@ -90,11 +81,7 @@ static int storvsc_queuecommand(struct s
 static int storvsc_device_alloc(struct scsi_device *);
 static int storvsc_device_configure(struct scsi_device *);
 static int storvsc_host_reset_handler(struct scsi_cmnd *scmnd);
-#ifdef KERNEL_2_6_27
 static void storvsc_host_rescan_callback(struct work_struct *work);
-#else
-static void storvsc_host_rescan_callback(void* context);
-#endif
 static void storvsc_host_rescan(DEVICE_OBJECT* device_obj);
 static int storvsc_remove(struct device *dev);
 
@@ -171,13 +158,8 @@ int storvsc_drv_init(PFN_DRIVERINITIALIZ
 	drv_ctx->driver.name = storvsc_drv_obj->Base.name;
 	memcpy(&drv_ctx->class_id, &storvsc_drv_obj->Base.deviceType, sizeof(GUID));
 
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-	drv_ctx->driver.probe = storvsc_probe;
-	drv_ctx->driver.remove = storvsc_remove;
-#else
 	drv_ctx->probe = storvsc_probe;
 	drv_ctx->remove = storvsc_remove;
-#endif
 
 	// The driver belongs to vmbus
 	vmbus_child_driver_register(drv_ctx);
@@ -209,16 +191,6 @@ void storvsc_drv_exit(void)
 
 	struct device *current_dev=NULL;
 
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#define driver_for_each_device(drv, start, data, fn) \
-	struct list_head *ptr, *n; \
-	list_for_each_safe(ptr, n, &((drv)->devices)) {\
-		struct device *curr_dev;\
-		curr_dev = list_entry(ptr, struct device, driver_list);\
-		fn(curr_dev, data);\
-	}
-#endif // KERNEL_2_6_9
-
 	DPRINT_ENTER(STORVSC_DRV);
 
 	while (1)
@@ -287,28 +259,14 @@ static int storvsc_probe(struct device *
 	host_device_ctx->port = host->host_no;
 	host_device_ctx->device_ctx = device_ctx;
 
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#elif defined(KERNEL_2_6_27)
 	INIT_WORK(&host_device_ctx->host_rescan_work, storvsc_host_rescan_callback);
-#else
-	INIT_WORK(&host_device_ctx->host_rescan_work, storvsc_host_rescan_callback, device_obj);
-#endif
 
-#if defined(KERNEL_2_6_27)
 	host_device_ctx->request_pool =
 	    kmem_cache_create
 	    (dev_name(&device_ctx->device),
 	     sizeof(struct storvsc_cmd_request) + storvsc_drv_obj->RequestExtSize,
 	     0,
 	     SLAB_HWCACHE_ALIGN, NULL);
-#else
-	host_device_ctx->request_pool =
-	    kmem_cache_create
-	    (device_ctx->device.bus_id,
-	     sizeof(struct storvsc_cmd_request) + storvsc_drv_obj->RequestExtSize,
-	     0,
-	     SLAB_HWCACHE_ALIGN, NULL, NULL);
-#endif
 
 	if (!host_device_ctx->request_pool)
 	{
@@ -430,10 +388,7 @@ static void storvsc_commmand_completion(
 	struct scsi_cmnd *scmnd = cmd_request->cmd;
 	struct host_device_context *host_device_ctx = (struct host_device_context*)scmnd->device->host->hostdata;
 	void (*scsi_done_fn)(struct scsi_cmnd *);
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#else
 	struct scsi_sense_hdr sense_hdr;
-#endif
 
 	ASSERT(request == &cmd_request->request);
 	ASSERT((unsigned long)scmnd->host_scribble == (unsigned long)cmd_request);
@@ -447,11 +402,7 @@ static void storvsc_commmand_completion(
 		//printk("copy_from_bounce_buffer\n");
 
 		// FIXME: We can optimize on writes by just skipping this
-#ifdef KERNEL_2_6_27
 		copy_from_bounce_buffer(scsi_sglist(scmnd), cmd_request->bounce_sgl, scsi_sg_count(scmnd));
-#else
-		copy_from_bounce_buffer(scmnd->request_buffer, cmd_request->bounce_sgl, scmnd->use_sg);
-#endif
 		destroy_bounce_buffer(cmd_request->bounce_sgl, cmd_request->bounce_sgl_count);
 	}
 
@@ -459,22 +410,14 @@ static void storvsc_commmand_completion(
 
 	if (scmnd->result)
 	{
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-		DPRINT_INFO(STORVSC_DRV, "scsi result nonzero - %d", scmnd->result);
-#else
 		if (scsi_normalize_sense(scmnd->sense_buffer, request->SenseBufferSize, &sense_hdr))
 		{
 			scsi_print_sense_hdr("storvsc", &sense_hdr);
 		}
-#endif
 	}
 
 	ASSERT(request->BytesXfer <= request->DataBuffer.Length);
-#ifdef KERNEL_2_6_27
 	scsi_set_resid(scmnd, request->DataBuffer.Length - request->BytesXfer);
-#else
-	scmnd->resid = request->DataBuffer.Length - request->BytesXfer;
-#endif
 
 	scsi_done_fn = scmnd->scsi_done;
 
@@ -543,13 +486,7 @@ static struct scatterlist *create_bounce
 		{
 			goto cleanup;
 		}
-#ifdef KERNEL_2_6_27
 		sg_set_page(&bounce_sgl[i], page_buf, 0, 0);
-#else
-		bounce_sgl[i].page = page_buf;
-		bounce_sgl[i].offset = 0;
-		bounce_sgl[i].length = 0;
-#endif
 	}
 
 	return bounce_sgl;
@@ -566,11 +503,7 @@ static void destroy_bounce_buffer(struct
 
 	for (i=0; i<sg_count; i++)
 	{
-#ifdef KERNEL_2_6_27
 		if ((page_buf = sg_page((&sgl[i]))) != NULL)
-#else
-		if ((page_buf = sgl[i].page) != NULL)
-#endif
 
 		{
 			__free_page(page_buf);
@@ -595,11 +528,7 @@ static unsigned int copy_to_bounce_buffe
 
 	for (i=0; i<orig_sgl_count; i++)
 	{
-#ifdef KERNEL_2_6_27
 		src_addr = (unsigned long)kmap_atomic(sg_page((&orig_sgl[i])), KM_IRQ0) + orig_sgl[i].offset;
-#else
-		src_addr = (unsigned long)kmap_atomic(orig_sgl[i].page, KM_IRQ0) + orig_sgl[i].offset;
-#endif
 		src = src_addr;
 		srclen = orig_sgl[i].length;
 
@@ -610,11 +539,7 @@ static unsigned int copy_to_bounce_buffe
 
 		if (j == 0)
 		{
-#ifdef KERNEL_2_6_27
 			bounce_addr = (unsigned long)kmap_atomic(sg_page((&bounce_sgl[j])), KM_IRQ0);
-#else
-			bounce_addr = (unsigned long)kmap_atomic(bounce_sgl[j].page, KM_IRQ0);
-#endif
 		}
 
 		while (srclen)
@@ -639,11 +564,7 @@ static unsigned int copy_to_bounce_buffe
 				// if we need to use another bounce buffer
 				if (srclen || i != orig_sgl_count -1)
 				{
-#ifdef KERNEL_2_6_27
 					bounce_addr = (unsigned long)kmap_atomic(sg_page((&bounce_sgl[j])), KM_IRQ0);
-#else
-					bounce_addr = (unsigned long)kmap_atomic(bounce_sgl[j].page, KM_IRQ0);
-#endif
 				}
 			}
 			else if (srclen == 0 && i == orig_sgl_count -1) // // unmap the last bounce that is < PAGE_SIZE
@@ -675,22 +596,14 @@ static unsigned int copy_from_bounce_buf
 
 	for (i=0; i<orig_sgl_count; i++)
 	{
-#ifdef KERNEL_2_6_27
 		dest_addr = (unsigned long)kmap_atomic(sg_page((&orig_sgl[i])), KM_IRQ0) + orig_sgl[i].offset;
-#else
-		dest_addr = (unsigned long)kmap_atomic(orig_sgl[i].page, KM_IRQ0) + orig_sgl[i].offset;
-#endif
 		dest = dest_addr;
 		destlen = orig_sgl[i].length;
 		ASSERT(orig_sgl[i].offset + orig_sgl[i].length <= PAGE_SIZE);
 
 		if (j == 0)
 		{
-#ifdef KERNEL_2_6_27
 			bounce_addr = (unsigned long)kmap_atomic(sg_page((&bounce_sgl[j])), KM_IRQ0);
-#else
-			bounce_addr = (unsigned long)kmap_atomic(bounce_sgl[j].page, KM_IRQ0);
-#endif
 		}
 
 		while (destlen)
@@ -714,11 +627,7 @@ static unsigned int copy_from_bounce_buf
 				// if we need to use another bounce buffer
 				if (destlen || i != orig_sgl_count -1)
 				{
-#ifdef KERNEL_2_6_27
 					bounce_addr = (unsigned long)kmap_atomic(sg_page((&bounce_sgl[j])), KM_IRQ0);
-#else
-					bounce_addr = (unsigned long)kmap_atomic(bounce_sgl[j].page, KM_IRQ0);
-#endif
 				}
 			}
 			else if (destlen == 0 && i == orig_sgl_count -1) // unmap the last bounce that is < PAGE_SIZE
@@ -760,7 +669,6 @@ static int storvsc_queuecommand(struct s
 
 	DPRINT_ENTER(STORVSC_DRV);
 
-#ifdef KERNEL_2_6_27
 	DPRINT_DBG(STORVSC_DRV, "scmnd %p dir %d, use_sg %d buf %p len %d queue depth %d tagged %d",
 		scmnd,
 		scmnd->sc_data_direction,
@@ -769,16 +677,6 @@ static int storvsc_queuecommand(struct s
 		scsi_bufflen(scmnd),
 		scmnd->device->queue_depth,
 		scmnd->device->tagged_supported);
-#else
-	DPRINT_DBG(STORVSC_DRV, "scmnd %p dir %d, use_sg %d buf %p len %d queue depth %d tagged %d",
-		scmnd,
-		scmnd->sc_data_direction,
-		scmnd->use_sg,
-		scmnd->request_buffer,
-		scmnd->request_bufflen,
-		scmnd->device->queue_depth,
-		scmnd->device->tagged_supported);
-#endif
 
 	// If retrying, no need to prep the cmd
 	if (scmnd->host_scribble)
@@ -850,35 +748,16 @@ static int storvsc_queuecommand(struct s
 	request->SenseBufferSize = SCSI_SENSE_BUFFERSIZE;
 
 
-#ifdef KERNEL_2_6_27
 	request->DataBuffer.Length = scsi_bufflen(scmnd);
 	if (scsi_sg_count(scmnd))
-#else
-	request->DataBuffer.Length = scmnd->request_bufflen;
-	if (scmnd->use_sg)
-#endif
 	{
-#ifdef KERNEL_2_6_27
 		sgl = (struct scatterlist*)scsi_sglist(scmnd);
-#else
-		sgl = (struct scatterlist*)(scmnd->request_buffer);
-#endif
 
 		// check if we need to bounce the sgl
-#ifdef KERNEL_2_6_27
 		if (do_bounce_buffer(sgl, scsi_sg_count(scmnd)) != -1)
-#else
-		if (do_bounce_buffer(sgl, scmnd->use_sg) != -1)
-#endif
 		{
 			DPRINT_INFO(STORVSC_DRV, "need to bounce buffer for this scmnd %p", scmnd);
-#ifdef KERNEL_2_6_27
 			cmd_request->bounce_sgl = create_bounce_buffer(sgl, scsi_sg_count(scmnd), scsi_bufflen(scmnd));
-#else
-			cmd_request->bounce_sgl = create_bounce_buffer(
-			    sgl,
-			    scmnd->use_sg, scmnd->request_bufflen);
-#endif
 			if (!cmd_request->bounce_sgl)
 			{
 				DPRINT_ERR(STORVSC_DRV, "unable to create bounce buffer for this scmnd %p", scmnd);
@@ -890,42 +769,25 @@ static int storvsc_queuecommand(struct s
 				return SCSI_MLQUEUE_HOST_BUSY;
 			}
 
-#ifdef KERNEL_2_6_27
 			cmd_request->bounce_sgl_count = ALIGN_UP(scsi_bufflen(scmnd), PAGE_SIZE) >> PAGE_SHIFT;
-#else
-			cmd_request->bounce_sgl_count = ALIGN_UP(scmnd->request_bufflen, PAGE_SIZE) >> PAGE_SHIFT;
-#endif
 
 			//printk("bouncing buffer allocated %p original buffer %p\n", bounce_sgl, sgl);
 			//printk("copy_to_bounce_buffer\n");
 			// FIXME: We can optimize on reads by just skipping this
-#ifdef KERNEL_2_6_27
 			copy_to_bounce_buffer(sgl, cmd_request->bounce_sgl, scsi_sg_count(scmnd));
-#else
-			copy_to_bounce_buffer(sgl, cmd_request->bounce_sgl, scmnd->use_sg);
-#endif
 
 			sgl = cmd_request->bounce_sgl;
 		}
 
 		request->DataBuffer.Offset = sgl[0].offset;
 
-#ifdef KERNEL_2_6_27
 		for (i = 0; i < scsi_sg_count(scmnd); i++ )
-#else
-		for (i = 0; i < scmnd->use_sg; i++ )
-#endif
 		{
 			DPRINT_DBG(STORVSC_DRV, "sgl[%d] len %d offset %d \n", i, sgl[i].length, sgl[i].offset);
-#ifdef KERNEL_2_6_27
 			request->DataBuffer.PfnArray[i] = page_to_pfn(sg_page((&sgl[i])));
-#else
-			request->DataBuffer.PfnArray[i] = page_to_pfn(sgl[i].page);
-#endif
 		}
 	}
 
-#ifdef KERNEL_2_6_27
 	else if (scsi_sglist(scmnd))
 	{
 		ASSERT(scsi_bufflen(scmnd) <= PAGE_SIZE);
@@ -936,18 +798,6 @@ static int storvsc_queuecommand(struct s
 	{
 		ASSERT(scsi_bufflen(scmnd) == 0);
 	}
-#else
-	else if (scmnd->request_buffer)
-	{
-		ASSERT(scmnd->request_bufflen <= PAGE_SIZE);
-		request->DataBuffer.Offset = virt_to_phys(scmnd->request_buffer) & (PAGE_SIZE-1);
-		request->DataBuffer.PfnArray[0] = virt_to_phys(scmnd->request_buffer) >> PAGE_SHIFT;
-	}
-	else
-	{
-		ASSERT(scmnd->request_bufflen == 0);
-	}
-#endif
 
 retry_request:
 
@@ -960,14 +810,7 @@ retry_request:
 		if (cmd_request->bounce_sgl_count)
 		{
 			// FIXME: We can optimize on writes by just skipping this
-#ifdef KERNEL_2_6_27
 			copy_from_bounce_buffer(scsi_sglist(scmnd), cmd_request->bounce_sgl, scsi_sg_count(scmnd));
-#else
-			copy_from_bounce_buffer(
-			    scmnd->request_buffer,
-			    cmd_request->bounce_sgl,
-			    scmnd->use_sg);
-#endif
 			destroy_bounce_buffer(cmd_request->bounce_sgl, cmd_request->bounce_sgl_count);
 		}
 
@@ -984,50 +827,10 @@ retry_request:
 	return ret;
 }
 
-#ifdef KERNEL_2_6_27
 static int storvsc_merge_bvec(struct request_queue *q, struct bvec_merge_data *bmd, struct bio_vec *bvec)
 {
 	return bvec->bv_len; //checking done by caller.
 }
-#else
-static int storvsc_merge_bvec(struct request_queue *q, struct bio *bio, struct bio_vec *bvec)
-{
-	// Check if we are adding a new bvec
-	if (bio->bi_vcnt > 0)
-	{
-		//printk("storvsc_merge_bvec() - cnt %u offset %u len %u\n", bio->bi_vcnt, bvec->bv_offset, bvec->bv_len);
-
-		struct bio_vec *prev = &bio->bi_io_vec[bio->bi_vcnt - 1];
-		if (bvec == prev)
-			return bvec->bv_len; // success
-
-		// Adding new bvec. Make sure the prev one is a complete page
-		if (prev->bv_len == PAGE_SIZE && prev->bv_offset == 0)
-		{
-			return bvec->bv_len; // success
-		}
-		else
-		{
-			// Dont reject if the new bvec starts off from the prev one since
-			// they will be merge into 1 bvec or blk_rq_map_sg() will merge them into 1 sg element
-			if ((bvec->bv_page == prev->bv_page) &&
-				(bvec->bv_offset == prev->bv_offset + prev->bv_len))
-			{
-				return bvec->bv_len; // success
-			}
-			else
-			{
-				DPRINT_INFO(STORVSC_DRV, "detected holes in bio request (%p) - cnt %u offset %u len %u", bio, bio->bi_vcnt, bvec->bv_offset, bvec->bv_len);
-				return 0; // dont add the bvec to this bio since we dont allow holes in the middle of a multi-pages bio
-			}
-		}
-	}
-
-	return bvec->bv_len; // success
-
-}
-
-#endif
 
 /*++
 
@@ -1038,12 +841,9 @@ Desc:	Configure the specified scsi devic
 --*/
 static int storvsc_device_alloc(struct scsi_device *sdevice)
 {
-#ifdef KERNEL_2_6_5
-#else
 	DPRINT_DBG(STORVSC_DRV, "sdev (%p) - setting device flag to %d", sdevice, BLIST_SPARSELUN);
 	// This enables luns to be located sparsely. Otherwise, we may not discovered them.
 	sdevice->sdev_bflags |= BLIST_SPARSELUN | BLIST_LARGELUN;
-#endif
 	return 0;
 }
 
@@ -1110,20 +910,10 @@ Name:	storvsc_host_rescan
 Desc:	Rescan the scsi HBA
 
 --*/
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#else
-
-#ifdef KERNEL_2_6_27
 static void storvsc_host_rescan_callback(struct work_struct *work)
 {
 	DEVICE_OBJECT* device_obj =
 	    &((struct host_device_context*)work)->device_ctx->device_obj;
-#else
-static void storvsc_host_rescan_callback(void* context)
-{
-
-	DEVICE_OBJECT* device_obj = (DEVICE_OBJECT*)context;
-#endif
 	struct device_context* device_ctx = to_device_context(device_obj);
 	struct Scsi_Host *host = dev_get_drvdata(&device_ctx->device);
 	struct scsi_device *sdev;
@@ -1229,10 +1019,7 @@ static int storvsc_report_luns(struct sc
 	unsigned int num_luns;
 	int result;
 	unsigned char *data;
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#else
 	struct scsi_sense_hdr sshdr;
-#endif
 	unsigned char cmd[16]={0};
 	unsigned int report_len = 8*(STORVSC_MAX_LUNS_PER_TARGET+1); // Add 1 to cover the report_lun header
 	unsigned long long *report_luns;
@@ -1288,7 +1075,6 @@ static int storvsc_report_luns(struct sc
 	kfree(report_luns);
 	return 0;
 }
-#endif // KERNEL_2_6_9
 
 static void storvsc_host_rescan(DEVICE_OBJECT* device_obj)
 {
@@ -1297,9 +1083,6 @@ static void storvsc_host_rescan(DEVICE_O
 	struct host_device_context *host_device_ctx;
 
 	DPRINT_ENTER(STORVSC_DRV);
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-	DPRINT_ERR(STORVSC_DRV, "rescan not supported on 2.6.9 kernels!! You will need to reboot if you have added or removed the scsi lun device");
-#else
 
 	host_device_ctx = (struct host_device_context*)host->hostdata;
 
@@ -1308,7 +1091,6 @@ static void storvsc_host_rescan(DEVICE_O
 	// We need to queue this since the scanning may block and the caller may be in an intr context
 	//scsi_queue_work(host, &host_device_ctx->host_rescan_work);
 	schedule_work(&host_device_ctx->host_rescan_work);
-#endif // KERNEL_2_6_9
 	DPRINT_EXIT(STORVSC_DRV);
 }
 
--- a/drivers/staging/hv/TODO
+++ b/drivers/staging/hv/TODO
@@ -1,7 +1,6 @@
 TODO:
 	- fix checkpatch warnings/errors
 	- fix sparse issues
-	- remove compatibility layer
 	- fix HANDLE usage to be "real" pointers
 	- audit the vmbus to verify it is working properly with the
 	  driver model
--- a/drivers/staging/hv/vmbus_drv.c
+++ b/drivers/staging/hv/vmbus_drv.c
@@ -21,7 +21,6 @@
  *
  */
 
-#define KERNEL_2_6_27
 
 #include <linux/init.h>
 #include <linux/module.h>
@@ -39,9 +38,7 @@
 
 // FIXME! We need to do this dynamically for PIC and APIC system
 #define VMBUS_IRQ				0x5
-#ifdef KERNEL_2_6_27
 #define VMBUS_IRQ_VECTOR     IRQ5_VECTOR
-#endif
 //
 // Data types
 //
@@ -69,20 +66,11 @@ static int vmbus_match(struct device *de
 static int vmbus_probe(struct device *device);
 static int vmbus_remove(struct device *device);
 static void vmbus_shutdown(struct device *device);
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#elif defined(KERNEL_2_6_27)
 static int vmbus_uevent(struct device *device, struct kobj_uevent_env *env);
-#else
-static int vmbus_uevent(struct device *device, char **envp, int num_envp, char *buffer, int buffer_size);
-#endif
 static void vmbus_msg_dpc(unsigned long data);
 static void vmbus_event_dpc(unsigned long data);
 
-#ifdef KERNEL_2_6_27
 static irqreturn_t vmbus_isr(int irq, void* dev_id);
-#else
-static int vmbus_isr(int irq, void* dev_id, struct pt_regs *regs);
-#endif
 
 static void vmbus_device_release(struct device *device);
 static void vmbus_bus_release(struct device *device);
@@ -141,8 +129,6 @@ static ctl_table vmus_root_ctl_table[] =
 	{ }
 };
 
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#else
 //
 // Set up per device attributes in /sys/bus/vmbus/devices/<bus device>
 //
@@ -174,20 +160,16 @@ static struct device_attribute vmbus_dev
 	__ATTR(in_write_bytes_avail, S_IRUGO, vmbus_show_device_attr, NULL),
 	__ATTR_NULL
 };
-#endif
 
 // The one and only one
 static struct vmbus_driver_context g_vmbus_drv={
 	.bus.name	= "vmbus",
 	.bus.match	= vmbus_match,
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#else
 	.bus.shutdown = vmbus_shutdown,
 	.bus.remove = vmbus_remove,
 	.bus.probe	= vmbus_probe,
 	.bus.uevent = vmbus_uevent,
 	.bus.dev_attrs = vmbus_device_attrs,
-#endif
 };
 
 //
@@ -401,19 +383,11 @@ int vmbus_bus_init(PFN_DRIVERINITIALIZE 
 	bus_register(&vmbus_drv_ctx->bus);
 
 	// Get the interrupt resource
-#ifdef KERNEL_2_6_27
 	ret = request_irq(vmbus_irq,
 			  vmbus_isr,
 			  IRQF_SAMPLE_RANDOM,
 			  vmbus_drv_obj->Base.name,
 			  NULL);
-#else
-	ret = request_irq(vmbus_irq,
-			  vmbus_isr,
-			  SA_SAMPLE_RANDOM,
-			  vmbus_drv_obj->Base.name,
-			  NULL);
-#endif
 
 	if (ret != 0)
 	{
@@ -424,15 +398,7 @@ int vmbus_bus_init(PFN_DRIVERINITIALIZE 
 		ret = -1;
 		goto cleanup;
 	}
-#ifdef KERNEL_2_6_27
 	vector = VMBUS_IRQ_VECTOR;
-#else
-#if X2V_LINUX
-	vector = vmbus_irq + FIRST_DEVICE_VECTOR - 2;
-#else
-	vector = vmbus_irq + FIRST_EXTERNAL_VECTOR;
-#endif
-#endif
 
 	DPRINT_INFO(VMBUS_DRV, "irq 0x%x vector 0x%x", vmbus_irq, vector);
 
@@ -738,8 +704,6 @@ Desc:	This routine is invoked when a dev
 		userspace. The udev will then look at its rule and the uevent generated here to load the appropriate driver
 
 --*/
-#if defined(KERNEL_2_6_5) || defined(KERNEL_2_6_9)
-#elif defined(KERNEL_2_6_27)
 static int vmbus_uevent(struct device *device, struct kobj_uevent_env *env)
 {
 	struct device_context *device_ctx = device_to_device_context(device);
@@ -791,57 +755,6 @@ static int vmbus_uevent(struct device *d
 	return 0;
 }
 
-#else
-static int vmbus_uevent(struct device *device, char **envp, int num_envp, char *buffer, int buffer_size)
-{
-	struct device_context *device_ctx = device_to_device_context(device);
-	int i=0;
-	int len=0;
-	int ret;
-
-	DPRINT_ENTER(VMBUS_DRV);
-
-	DPRINT_INFO(VMBUS_DRV, "generating uevent - VMBUS_DEVICE_CLASS_GUID={%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x%02x%02x}",
-		device_ctx->class_id.Data[3], device_ctx->class_id.Data[2], device_ctx->class_id.Data[1], device_ctx->class_id.Data[0],
-		device_ctx->class_id.Data[5], device_ctx->class_id.Data[4],
-		device_ctx->class_id.Data[7], device_ctx->class_id.Data[6],
-		device_ctx->class_id.Data[8], device_ctx->class_id.Data[9], device_ctx->class_id.Data[10], device_ctx->class_id.Data[11],
-		device_ctx->class_id.Data[12], device_ctx->class_id.Data[13], device_ctx->class_id.Data[14], device_ctx->class_id.Data[15]);
-
-	ret = add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &len,
-		"VMBUS_DEVICE_CLASS_GUID={%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x%02x%02x}",
-		device_ctx->class_id.Data[3], device_ctx->class_id.Data[2], device_ctx->class_id.Data[1], device_ctx->class_id.Data[0],
-		device_ctx->class_id.Data[5], device_ctx->class_id.Data[4],
-		device_ctx->class_id.Data[7], device_ctx->class_id.Data[6],
-		device_ctx->class_id.Data[8], device_ctx->class_id.Data[9], device_ctx->class_id.Data[10], device_ctx->class_id.Data[11],
-		device_ctx->class_id.Data[12], device_ctx->class_id.Data[13], device_ctx->class_id.Data[14], device_ctx->class_id.Data[15]);
-
-	if (ret)
-	{
-		return ret;
-	}
-
-	ret = add_uevent_var(envp, num_envp, &i, buffer, buffer_size, &len,
-		"VMBUS_DEVICE_DEVICE_GUID={%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x%02x%02x}",
-		device_ctx->device_id.Data[3], device_ctx->device_id.Data[2], device_ctx->device_id.Data[1], device_ctx->device_id.Data[0],
-		device_ctx->device_id.Data[5], device_ctx->device_id.Data[4],
-		device_ctx->device_id.Data[7], device_ctx->device_id.Data[6],
-		device_ctx->device_id.Data[8], device_ctx->device_id.Data[9], device_ctx->device_id.Data[10], device_ctx->device_id.Data[11],
-		device_ctx->device_id.Data[12], device_ctx->device_id.Data[13], device_ctx->device_id.Data[14], device_ctx->device_id.Data[15]);
-
-	if (ret)
-	{
-		return ret;
-	}
-
-	envp[i] = NULL;
-
-	DPRINT_EXIT(VMBUS_DRV);
-
-	return 0;
-}
-#endif
-
 /*++
 
 Name:	vmbus_match()
@@ -884,11 +797,7 @@ Desc:	Callback when a driver probe faile
 		invoked inside device_register() i.e. we cannot call device_unregister() inside
 		device_register()
 --*/
-#ifdef KERNEL_2_6_27
 static void vmbus_probe_failed_cb(struct work_struct *context)
-#else
-static void vmbus_probe_failed_cb(void* context)
-#endif
 {
 	struct device_context *device_ctx = (struct device_context*)context;
 
@@ -927,11 +836,7 @@ static int vmbus_probe(struct device *ch
 		{
 			DPRINT_ERR(VMBUS_DRV, "probe() failed for device %s (%p) on driver %s (%d)...", dev_name(child_device), child_device, child_device->driver->name, ret);
 
-#ifdef KERNEL_2_6_27
 			INIT_WORK(&device_ctx->probe_failed_work_item, vmbus_probe_failed_cb);
-#else
-			INIT_WORK(&device_ctx->probe_failed_work_item, vmbus_probe_failed_cb, device_ctx);
-#endif
 			schedule_work(&device_ctx->probe_failed_work_item);
 		}
 	}
@@ -1119,11 +1024,7 @@ Name:	vmbus_msg_dpc()
 Desc:	ISR routine
 
 --*/
-#ifdef KERNEL_2_6_27
 static irqreturn_t vmbus_isr(int irq, void* dev_id)
-#else
-static int vmbus_isr(int irq, void* dev_id, struct pt_regs *regs)
-#endif
 {
 	int ret=0;
 	VMBUS_DRIVER_OBJECT* vmbus_driver_obj = &g_vmbus_drv.drv_obj;
@@ -1177,16 +1078,7 @@ static int __init vmbus_init(void)
 	DPRINT_INFO(VMBUS_DRV,
 		"Vmbus initializing.... current log level 0x%x (%x,%x)",
 		vmbus_loglevel, HIWORD(vmbus_loglevel), LOWORD(vmbus_loglevel));
-#ifdef KERNEL_2_6_27
 //Todo: it is used for loglevel, to be ported to new kernel.
-#else
-	vmbus_ctl_table_hdr = register_sysctl_table(vmus_root_ctl_table, 0);
-	if (!vmbus_ctl_table_hdr)
-	{
-		DPRINT_EXIT(VMBUS_DRV);
-		return -ENOMEM;
-	}
-#endif
 
 	ret = vmbus_bus_init(VmbusInitialize);
 
@@ -1208,21 +1100,14 @@ static void __exit vmbus_exit(void)
 	DPRINT_ENTER(VMBUS_DRV);
 
 	vmbus_bus_exit();
-#ifdef KERNEL_2_6_27
 //Todo: it is used for loglevel, to be ported to new kernel.
-#else
-	unregister_sysctl_table(vmbus_ctl_table_hdr);
-#endif
 	DPRINT_EXIT(VMBUS_DRV);
 
 	return;
 }
 
-#if defined(KERNEL_2_6_5)
-#else
 module_param(vmbus_irq, int, S_IRUGO);
 module_param(vmbus_loglevel, int, S_IRUGO);
-#endif
 
 module_init(vmbus_init);
 module_exit(vmbus_exit);
