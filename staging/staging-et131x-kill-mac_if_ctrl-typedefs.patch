From alan@linux.intel.com  Thu Nov 19 14:41:58 2009
From: Alan Cox <alan@linux.intel.com>
Date: Wed, 18 Nov 2009 14:06:50 +0000
Subject: Staging: et131x: Kill MAC_IF_CTRL typedefs
To: greg@kroah.com
Message-ID: <20091118140645.2578.28061.stgit@localhost.localdomain>


Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/et131x/et1310_address_map.h |   62 ++++++++--------------------
 drivers/staging/et131x/et1310_mac.c         |   17 ++++---
 2 files changed, 29 insertions(+), 50 deletions(-)


--- a/drivers/staging/et131x/et1310_address_map.h
+++ b/drivers/staging/et131x/et1310_address_map.h
@@ -1451,49 +1451,25 @@ typedef struct _RXMAC_t {				/* Location
 /*
  * structure for Interface Control reg in mac address map.
  * located at address 0x5038
+ *
+ * 31: reset if module
+ * 30-28: reserved
+ * 27: tbi mode
+ * 26: ghd mode
+ * 25: lhd mode
+ * 24: phy mode
+ * 23: reset per mii
+ * 22-17: reserved
+ * 16: speed
+ * 15: reset pe100x
+ * 14-11: reserved
+ * 10: force quiet
+ * 9: no cipher
+ * 8: disable link fail
+ * 7: reset gpsi
+ * 6-1: reserved
+ * 0: enable jabber protection
  */
-typedef union _MAC_IF_CTRL_t {
-	u32 value;
-	struct {
-#ifdef _BIT_FIELDS_HTOL
-		u32 reset_if_module:1;	/* bit 31 */
-		u32 reserved4:3;		/* bit 28-30 */
-		u32 tbi_mode:1;		/* bit 27 */
-		u32 ghd_mode:1;		/* bit 26 */
-		u32 lhd_mode:1;		/* bit 25 */
-		u32 phy_mode:1;		/* bit 24 */
-		u32 reset_per_mii:1;	/* bit 23 */
-		u32 reserved3:6;		/* bits 17-22 */
-		u32 speed:1;		/* bit 16 */
-		u32 reset_pe100x:1;	/* bit 15 */
-		u32 reserved2:4;		/* bits 11-14 */
-		u32 force_quiet:1;		/* bit 10 */
-		u32 no_cipher:1;		/* bit 9 */
-		u32 disable_link_fail:1;	/* bit 8 */
-		u32 reset_gpsi:1;		/* bit 7 */
-		u32 reserved1:6;		/* bits 1-6 */
-		u32 enab_jab_protect:1;	/* bit 0 */
-#else
-		u32 enab_jab_protect:1;	/* bit 0 */
-		u32 reserved1:6;		/* bits 1-6 */
-		u32 reset_gpsi:1;		/* bit 7 */
-		u32 disable_link_fail:1;	/* bit 8 */
-		u32 no_cipher:1;		/* bit 9 */
-		u32 force_quiet:1;		/* bit 10 */
-		u32 reserved2:4;		/* bits 11-14 */
-		u32 reset_pe100x:1;	/* bit 15 */
-		u32 speed:1;		/* bit 16 */
-		u32 reserved3:6;		/* bits 17-22 */
-		u32 reset_per_mii:1;	/* bit 23 */
-		u32 phy_mode:1;		/* bit 24 */
-		u32 lhd_mode:1;		/* bit 25 */
-		u32 ghd_mode:1;		/* bit 26 */
-		u32 tbi_mode:1;		/* bit 27 */
-		u32 reserved4:3;		/* bit 28-30 */
-		u32 reset_if_module:1;	/* bit 31 */
-#endif
-	} bits;
-} MAC_IF_CTRL_t, *PMAC_IF_CTRL_t;
 
 /*
  * structure for Interface Status reg in mac address map.
@@ -1588,7 +1564,7 @@ typedef struct _MAC_t {					/* Location:
 	u32 mii_mgmt_ctrl;				/*  0x502C */
 	u32 mii_mgmt_stat;				/*  0x5030 */
 	u32 mii_mgmt_indicator;				/*  0x5034 */
-	MAC_IF_CTRL_t if_ctrl;				/*  0x5038 */
+	u32 if_ctrl;					/*  0x5038 */
 	MAC_IF_STAT_t if_stat;				/*  0x503C */
 	MAC_STATION_ADDR1_t station_addr_1;		/*  0x5040 */
 	MAC_STATION_ADDR2_t station_addr_2;		/*  0x5044 */
--- a/drivers/staging/et131x/et1310_mac.c
+++ b/drivers/staging/et131x/et1310_mac.c
@@ -118,7 +118,7 @@ void ConfigMACRegs1(struct et131x_adapte
 	writel(0x00A1F037, &pMac->hfdp);
 
 	/* Next lets configure the MAC Interface Control register */
-	writel(0, &pMac->if_ctrl.value);
+	writel(0, &pMac->if_ctrl);
 
 	/* Let's move on to setting up the mii management configuration */
 	writel(0x07, &pMac->mii_mgmt_cfg);	/* Clock reset 0x7 */
@@ -162,22 +162,23 @@ void ConfigMACRegs2(struct et131x_adapte
 	struct _MAC_t __iomem *pMac = &etdev->regs->mac;
 	u32 cfg1;
 	u32 cfg2;
-	MAC_IF_CTRL_t ifctrl;
+	u32 ifctrl;
 	TXMAC_CTL_t ctl;
 
 	ctl.value = readl(&etdev->regs->txmac.ctl.value);
 	cfg1 = readl(&pMac->cfg1);
 	cfg2 = readl(&pMac->cfg2);
-	ifctrl.value = readl(&pMac->if_ctrl.value);
+	ifctrl = readl(&pMac->if_ctrl);
 
 	/* Set up the if mode bits */
 	cfg2 &= ~0x300;
 	if (etdev->linkspeed == TRUEPHY_SPEED_1000MBPS) {
 		cfg2 |= 0x200;
-		ifctrl.bits.phy_mode = 0x0;
+		/* Phy mode bit */
+		ifctrl &= ~(1 << 24);
 	} else {
 		cfg2 |= 0x100;
-		ifctrl.bits.phy_mode = 0x1;
+		ifctrl |= (1 << 24);
 	}
 
 	/* We need to enable Rx/Tx */
@@ -198,9 +199,11 @@ void ConfigMACRegs2(struct et131x_adapte
 	if (etdev->duplex_mode)
 		cfg2 |= 0x01;
 
-	ifctrl.bits.ghd_mode = !etdev->duplex_mode;
+	ifctrl &= ~(1 << 26);
+	if (!etdev->duplex_mode)
+		ifctrl |= (1<<26);	/* Enable ghd */
 
-	writel(ifctrl.value, &pMac->if_ctrl.value);
+	writel(ifctrl, &pMac->if_ctrl);
 	writel(cfg2, &pMac->cfg2);
 
 	do {
