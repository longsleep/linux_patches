From alan@linux.intel.com  Mon Oct 26 14:55:17 2009
From: Alan Cox <alan@linux.intel.com>
Date: Tue, 06 Oct 2009 15:48:49 +0100
Subject: Staging: et131x: pci_alloc_consistent DMA alignment is guaranteed
To: greg@kroah.com
Message-ID: <20091006144848.8604.48898.stgit@localhost.localdomain>


So we can remove this alignment work.

Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>


---
 drivers/staging/et131x/et1310_rx.c |   50 ++++++++-----------------------------
 drivers/staging/et131x/et1310_rx.h |    4 --
 drivers/staging/et131x/et1310_tx.c |   17 +-----------
 drivers/staging/et131x/et1310_tx.h |    2 -
 4 files changed, 14 insertions(+), 59 deletions(-)

--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -342,7 +342,7 @@ int et131x_rx_dma_memory_alloc(struct et
 	    sizeof(PKT_STAT_DESC_t) * adapter->RxRing.PsrNumEntries;
 
 	rx_ring->pPSRingVa = pci_alloc_consistent(adapter->pdev,
-						  pktStatRingSize + 0x0fff,
+						  pktStatRingSize,
 						  &rx_ring->pPSRingPa);
 
 	if (!rx_ring->pPSRingVa) {
@@ -350,45 +350,26 @@ int et131x_rx_dma_memory_alloc(struct et
 			  "Cannot alloc memory for Packet Status Ring\n");
 		return -ENOMEM;
 	}
+	printk("PSR %lx\n", (unsigned long) rx_ring->pPSRingPa);
 
-	/* Save physical address
-	 *
+	/*
 	 * NOTE : pci_alloc_consistent(), used above to alloc DMA regions,
 	 * ALWAYS returns SAC (32-bit) addresses. If DAC (64-bit) addresses
 	 * are ever returned, make sure the high part is retrieved here before
 	 * storing the adjusted address.
 	 */
-	rx_ring->pPSRingRealPa = rx_ring->pPSRingPa;
-
-	/* Align Packet Status Ring on a 4K boundary */
-	et131x_align_allocated_memory(adapter,
-				      &rx_ring->pPSRingRealPa,
-				      &rx_ring->pPSRingOffset, 0x0FFF);
-
-	rx_ring->pPSRingVa = (void *)((uint8_t *) rx_ring->pPSRingVa +
-				      rx_ring->pPSRingOffset);
 
 	/* Allocate an area of memory for writeback of status information */
 	rx_ring->pRxStatusVa = pci_alloc_consistent(adapter->pdev,
-						    sizeof(RX_STATUS_BLOCK_t) +
-						    0x7, &rx_ring->pRxStatusPa);
+						    sizeof(RX_STATUS_BLOCK_t),
+						    &rx_ring->pRxStatusPa);
 	if (!rx_ring->pRxStatusVa) {
 		dev_err(&adapter->pdev->dev,
 			  "Cannot alloc memory for Status Block\n");
 		return -ENOMEM;
 	}
-
-	/* Save physical address */
-	rx_ring->RxStatusRealPA = rx_ring->pRxStatusPa;
-
-	/* Align write back on an 8 byte boundary */
-	et131x_align_allocated_memory(adapter,
-				      &rx_ring->RxStatusRealPA,
-				      &rx_ring->RxStatusOffset, 0x07);
-
-	rx_ring->pRxStatusVa = (void *)((uint8_t *) rx_ring->pRxStatusVa +
-					rx_ring->RxStatusOffset);
 	rx_ring->NumRfd = NIC_DEFAULT_NUM_RFD;
+	printk("PRS %lx\n", (unsigned long)rx_ring->pRxStatusPa);
 
 	/* Recv
 	 * pci_pool_create initializes a lookaside list. After successful
@@ -523,14 +504,10 @@ void et131x_rx_dma_memory_free(struct et
 
 	/* Free Packet Status Ring */
 	if (rx_ring->pPSRingVa) {
-		rx_ring->pPSRingVa = (void *)((uint8_t *) rx_ring->pPSRingVa -
-					      rx_ring->pPSRingOffset);
-
 		pktStatRingSize =
 		    sizeof(PKT_STAT_DESC_t) * adapter->RxRing.PsrNumEntries;
 
-		pci_free_consistent(adapter->pdev,
-				    pktStatRingSize + 0x0fff,
+		pci_free_consistent(adapter->pdev, pktStatRingSize,
 				    rx_ring->pPSRingVa, rx_ring->pPSRingPa);
 
 		rx_ring->pPSRingVa = NULL;
@@ -538,11 +515,8 @@ void et131x_rx_dma_memory_free(struct et
 
 	/* Free area of memory for the writeback of status information */
 	if (rx_ring->pRxStatusVa) {
-		rx_ring->pRxStatusVa = (void *)((uint8_t *)
-				rx_ring->pRxStatusVa - rx_ring->RxStatusOffset);
-
 		pci_free_consistent(adapter->pdev,
-				sizeof(RX_STATUS_BLOCK_t) + 0x7,
+				sizeof(RX_STATUS_BLOCK_t),
 				rx_ring->pRxStatusVa, rx_ring->pRxStatusPa);
 
 		rx_ring->pRxStatusVa = NULL;
@@ -675,18 +649,18 @@ void ConfigRxDmaRegs(struct et131x_adapt
 	 * are ever returned, make sure the high part is retrieved here
 	 * before storing the adjusted address.
 	 */
-	writel((uint32_t) (pRxLocal->RxStatusRealPA >> 32),
+	writel((uint32_t) ((u64)pRxLocal->pRxStatusPa >> 32),
 	       &rx_dma->dma_wb_base_hi);
-	writel((uint32_t) pRxLocal->RxStatusRealPA, &rx_dma->dma_wb_base_lo);
+	writel((uint32_t) pRxLocal->pRxStatusPa, &rx_dma->dma_wb_base_lo);
 
 	memset(pRxLocal->pRxStatusVa, 0, sizeof(RX_STATUS_BLOCK_t));
 
 	/* Set the address and parameters of the packet status ring into the
 	 * 1310's registers
 	 */
-	writel((uint32_t) (pRxLocal->pPSRingRealPa >> 32),
+	writel((uint32_t) ((u64)pRxLocal->pPSRingPa >> 32),
 	       &rx_dma->psr_base_hi);
-	writel((uint32_t) pRxLocal->pPSRingRealPa, &rx_dma->psr_base_lo);
+	writel((uint32_t) pRxLocal->pPSRingPa, &rx_dma->psr_base_lo);
 	writel(pRxLocal->PsrNumEntries - 1, &rx_dma->psr_num_des.value);
 	writel(0, &rx_dma->psr_full_offset.value);
 
--- a/drivers/staging/et131x/et1310_rx.h
+++ b/drivers/staging/et131x/et1310_rx.h
@@ -309,15 +309,11 @@ typedef struct _rx_ring_t {
 
 	void *pPSRingVa;
 	dma_addr_t pPSRingPa;
-	uint64_t pPSRingRealPa;
-	uint64_t pPSRingOffset;
 	RXDMA_PSR_FULL_OFFSET_t local_psr_full;
 	u32 PsrNumEntries;
 
 	void *pRxStatusVa;
 	dma_addr_t pRxStatusPa;
-	uint64_t RxStatusRealPA;
-	uint64_t RxStatusOffset;
 
 	struct list_head RecvBufferPool;
 
--- a/drivers/staging/et131x/et1310_tx.c
+++ b/drivers/staging/et131x/et1310_tx.c
@@ -146,15 +146,6 @@ int et131x_tx_dma_memory_alloc(struct et
 	 * are ever returned, make sure the high part is retrieved here before
 	 * storing the adjusted address.
 	 */
-	tx_ring->pTxDescRingAdjustedPa = tx_ring->tx_desc_ring_pa;
-
-	/* Align Tx Descriptor Ring on a 4k (0x1000) byte boundary */
-	et131x_align_allocated_memory(adapter,
-				      &tx_ring->pTxDescRingAdjustedPa,
-				      &tx_ring->TxDescOffset, 0x0FFF);
-
-	tx_ring->tx_desc_ring += tx_ring->TxDescOffset;
-
 	/* Allocate memory for the Tx status block */
 	tx_ring->pTxStatusVa = pci_alloc_consistent(adapter->pdev,
 						    sizeof(TX_STATUS_BLOCK_t),
@@ -190,16 +181,12 @@ void et131x_tx_dma_memory_free(struct et
 
 	if (adapter->tx_ring.tx_desc_ring) {
 		/* Free memory relating to Tx rings here */
-		adapter->tx_ring.tx_desc_ring -= adapter->tx_ring.TxDescOffset;
-
 		desc_size = (sizeof(struct tx_desc) * NUM_DESC_PER_RING_TX)
 									+ 4096 - 1;
-
 		pci_free_consistent(adapter->pdev,
 				    desc_size,
 				    adapter->tx_ring.tx_desc_ring,
 				    adapter->tx_ring.tx_desc_ring_pa);
-
 		adapter->tx_ring.tx_desc_ring = NULL;
 	}
 
@@ -236,9 +223,9 @@ void ConfigTxDmaRegs(struct et131x_adapt
 	struct _TXDMA_t __iomem *txdma = &etdev->regs->txdma;
 
 	/* Load the hardware with the start of the transmit descriptor ring. */
-	writel((u32) (etdev->tx_ring.pTxDescRingAdjustedPa >> 32),
+	writel((u32) ((u64)etdev->tx_ring.tx_desc_ring_pa >> 32),
 	       &txdma->pr_base_hi);
-	writel((u32) etdev->tx_ring.pTxDescRingAdjustedPa,
+	writel((u32) etdev->tx_ring.tx_desc_ring_pa,
 	       &txdma->pr_base_lo);
 
 	/* Initialise the transmit DMA engine */
--- a/drivers/staging/et131x/et1310_tx.h
+++ b/drivers/staging/et131x/et1310_tx.h
@@ -162,8 +162,6 @@ struct tx_ring {
 	/* The actual descriptor ring */
 	struct tx_desc *tx_desc_ring;
 	dma_addr_t tx_desc_ring_pa;
-	u64 pTxDescRingAdjustedPa;
-	u64 TxDescOffset;
 
 	/* ReadyToSend indicates where we last wrote to in the descriptor ring. */
 	u32 txDmaReadyToSend;
