From pavel@ucw.cz  Mon Oct 26 16:41:16 2009
From: Pavel Machek <pavel@ucw.cz>
Date: Thu, 22 Oct 2009 11:03:54 +0200
Subject: Staging: dream: remove wakelock support
To: Arve Hj?nnev?g <arve@android.com>, Brian Swetland <swetland@google.com>, Greg KH <greg@kroah.com>
Message-ID: <20091022090354.GA30695@elf.ucw.cz>


Includes changed so that <linux/sched.h> is now needed for
TASK_INTERRUPTIBLE and friends, so include it.

Remove hooks for features not in mainline, such as earlysuspend and
wakelocks.

Signed-off-by: Pavel Machek <pavel@ucw.cz>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/dream/camera/msm_camera.c |    7 +------
 drivers/staging/dream/camera/msm_vfe7x.c  |    1 +
 drivers/staging/dream/gpio_event.c        |    3 +--
 drivers/staging/dream/gpio_input.c        |    7 -------
 drivers/staging/dream/gpio_matrix.c       |    8 --------
 drivers/staging/dream/qdsp5/adsp.c        |    5 -----
 drivers/staging/dream/qdsp5/audio_out.c   |    4 ----
 drivers/staging/dream/smd/smd_qmi.c       |    5 -----
 drivers/staging/dream/smd/smd_rpcrouter.c |   12 ------------
 drivers/staging/dream/smd/smd_tty.c       |    5 -----
 10 files changed, 3 insertions(+), 54 deletions(-)

--- a/drivers/staging/dream/camera/msm_camera.c
+++ b/drivers/staging/dream/camera/msm_camera.c
@@ -13,6 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/sched.h>
 #include <mach/board.h>
 
 #include <linux/fs.h>
@@ -1597,7 +1598,6 @@ static int __msm_release(struct msm_sync
 		MSM_DRAIN_QUEUE(sync, pict_frame_q);
 
 		sync->sctrl.s_release();
-		wake_unlock(&sync->wake_lock);
 
 		sync->apps_id = NULL;
 		CDBG("msm_release completed!\n");
@@ -1806,7 +1806,6 @@ static int __msm_open(struct msm_sync *s
 	sync->apps_id = apps_id;
 
 	if (!sync->opencnt) {
-		wake_lock(&sync->wake_lock);
 
 		msm_camvfe_fn_init(&sync->vfefn, sync);
 		if (sync->vfefn.vfe_init) {
@@ -2044,8 +2043,6 @@ static int msm_sync_init(struct msm_sync
 	INIT_LIST_HEAD(&sync->pict_frame_q);
 	init_waitqueue_head(&sync->pict_frame_wait);
 
-	wake_lock_init(&sync->wake_lock, WAKE_LOCK_IDLE, "msm_camera");
-
 	rc = msm_camio_probe_on(pdev);
 	if (rc < 0)
 		return rc;
@@ -2058,7 +2055,6 @@ static int msm_sync_init(struct msm_sync
 	if (rc < 0) {
 		pr_err("msm_camera: failed to initialize %s\n",
 			sync->sdata->sensor_name);
-		wake_lock_destroy(&sync->wake_lock);
 		return rc;
 	}
 
@@ -2070,7 +2066,6 @@ static int msm_sync_init(struct msm_sync
 
 static int msm_sync_destroy(struct msm_sync *sync)
 {
-	wake_lock_destroy(&sync->wake_lock);
 	return 0;
 }
 
--- a/drivers/staging/dream/camera/msm_vfe7x.c
+++ b/drivers/staging/dream/camera/msm_vfe7x.c
@@ -5,6 +5,7 @@
 #include <linux/msm_adsp.h>
 #include <linux/uaccess.h>
 #include <linux/fs.h>
+#include <linux/sched.h>
 #include <linux/android_pmem.h>
 #include <mach/msm_adsp.h>
 #include <linux/delay.h>
--- a/drivers/staging/dream/gpio_event.c
+++ b/drivers/staging/dream/gpio_event.c
@@ -13,7 +13,7 @@
  *
  */
 
-#include <linux/earlysuspend.h>
+
 #include <linux/module.h>
 #include <linux/input.h>
 #include <linux/gpio_event.h>
@@ -23,7 +23,6 @@
 struct gpio_event {
 	struct input_dev *input_dev;
 	const struct gpio_event_platform_data *info;
-	struct early_suspend early_suspend;
 	void *state[0];
 };
 
--- a/drivers/staging/dream/gpio_input.c
+++ b/drivers/staging/dream/gpio_input.c
@@ -19,7 +19,6 @@
 #include <linux/hrtimer.h>
 #include <linux/input.h>
 #include <linux/interrupt.h>
-#include <linux/wakelock.h>
 
 enum {
 	DEBOUNCE_UNSTABLE     = BIT(0),	/* Got irq, while debouncing */
@@ -44,7 +43,6 @@ struct gpio_input_state {
 	int use_irq;
 	int debounce_count;
 	spinlock_t irq_lock;
-	struct wake_lock wake_lock;
 	struct gpio_key_state key_state[0];
 };
 
@@ -143,8 +141,6 @@ static enum hrtimer_restart gpio_event_i
 		hrtimer_start(timer, ds->info->debounce_time, HRTIMER_MODE_REL);
 	else if (!ds->use_irq)
 		hrtimer_start(timer, ds->info->poll_time, HRTIMER_MODE_REL);
-	else
-		wake_unlock(&ds->wake_lock);
 
 	spin_unlock_irqrestore(&ds->irq_lock, irqflags);
 
@@ -170,7 +166,6 @@ static irqreturn_t gpio_event_input_irq_
 		if (ks->debounce & DEBOUNCE_WAIT_IRQ) {
 			ks->debounce = DEBOUNCE_UNKNOWN;
 			if (ds->debounce_count++ == 0) {
-				wake_lock(&ds->wake_lock);
 				hrtimer_start(
 					&ds->timer, ds->info->debounce_time,
 					HRTIMER_MODE_REL);
@@ -277,7 +272,6 @@ int gpio_event_input_func(struct input_d
 		ds->debounce_count = di->keymap_size;
 		ds->input_dev = input_dev;
 		ds->info = di;
-		wake_lock_init(&ds->wake_lock, WAKE_LOCK_SUSPEND, "gpio_input");
 		spin_lock_init(&ds->irq_lock);
 
 		for (i = 0; i < di->keymap_size; i++) {
@@ -336,7 +330,6 @@ err_gpio_configure_failed:
 err_gpio_request_failed:
 		;
 	}
-	wake_lock_destroy(&ds->wake_lock);
 	kfree(ds);
 err_ds_alloc_failed:
 	return ret;
--- a/drivers/staging/dream/gpio_matrix.c
+++ b/drivers/staging/dream/gpio_matrix.c
@@ -18,13 +18,11 @@
 #include <linux/gpio_event.h>
 #include <linux/hrtimer.h>
 #include <linux/interrupt.h>
-#include <linux/wakelock.h>
 
 struct gpio_kp {
 	struct input_dev *input_dev;
 	struct gpio_event_matrix_info *keypad_info;
 	struct hrtimer timer;
-	struct wake_lock wake_lock;
 	int current_output;
 	unsigned int use_irq:1;
 	unsigned int key_state_changed:1;
@@ -199,7 +197,6 @@ static enum hrtimer_restart gpio_keypad_
 	}
 	for (in = 0; in < mi->ninputs; in++)
 		enable_irq(gpio_to_irq(mi->input_gpios[in]));
-	wake_unlock(&kp->wake_lock);
 	return HRTIMER_NORESTART;
 }
 
@@ -222,7 +219,6 @@ static irqreturn_t gpio_keypad_irq_handl
 		else
 			gpio_direction_input(mi->output_gpios[i]);
 	}
-	wake_lock(&kp->wake_lock);
 	hrtimer_start(&kp->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
 	return IRQ_HANDLED;
 }
@@ -363,7 +359,6 @@ int gpio_event_matrix_func(struct input_
 
 		hrtimer_init(&kp->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 		kp->timer.function = gpio_keypad_timer_func;
-		wake_lock_init(&kp->wake_lock, WAKE_LOCK_SUSPEND, "gpio_kp");
 		err = gpio_keypad_request_irqs(kp);
 		kp->use_irq = err == 0;
 
@@ -371,8 +366,6 @@ int gpio_event_matrix_func(struct input_
 			"in %s mode\n", input_dev->name,
 			kp->use_irq ? "interrupt" : "polling");
 
-		if (kp->use_irq)
-			wake_lock(&kp->wake_lock);
 		hrtimer_start(&kp->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
 
 		return 0;
@@ -386,7 +379,6 @@ int gpio_event_matrix_func(struct input_
 			free_irq(gpio_to_irq(mi->input_gpios[i]), kp);
 
 	hrtimer_cancel(&kp->timer);
-	wake_lock_destroy(&kp->wake_lock);
 	for (i = mi->noutputs - 1; i >= 0; i--) {
 err_gpio_direction_input_failed:
 		gpio_free(mi->input_gpios[i]);
--- a/drivers/staging/dream/qdsp5/adsp.c
+++ b/drivers/staging/dream/qdsp5/adsp.c
@@ -32,16 +32,12 @@
 #include <linux/module.h>
 #include <linux/uaccess.h>
 #include <linux/wait.h>
-#include <linux/wakelock.h>
 
-static struct wake_lock adsp_wake_lock;
 static inline void prevent_suspend(void)
 {
-	wake_lock(&adsp_wake_lock);
 }
 static inline void allow_suspend(void)
 {
-	wake_unlock(&adsp_wake_lock);
 }
 
 #include <linux/io.h>
@@ -1046,7 +1042,6 @@ static int msm_adsp_probe(struct platfor
 
 	pr_info("adsp: probe\n");
 
-	wake_lock_init(&adsp_wake_lock, WAKE_LOCK_SUSPEND, "adsp");
 #if CONFIG_MSM_AMSS_VERSION >= 6350
 	adsp_info.init_info_ptr = kzalloc(
 		(sizeof(struct adsp_rtos_mp_mtoa_init_info_type)), GFP_KERNEL);
--- a/drivers/staging/dream/qdsp5/audio_out.c
+++ b/drivers/staging/dream/qdsp5/audio_out.c
@@ -38,8 +38,6 @@
 #include <mach/qdsp5/qdsp5audppcmdi.h>
 #include <mach/qdsp5/qdsp5audppmsg.h>
 
-#include <mach/htc_pwrsink.h>
-
 #include "evlog.h"
 
 #define LOG_AUDIO_EVENTS 1
@@ -260,7 +258,6 @@ static int audio_enable(struct audio *au
 	}
 
 	audio->enabled = 1;
-	htc_pwrsink_set(PWRSINK_AUDIO, 100);
 	return 0;
 }
 
@@ -695,7 +692,6 @@ static int audio_release(struct inode *i
 	audio_flush(audio);
 	audio->opened = 0;
 	mutex_unlock(&audio->lock);
-	htc_pwrsink_set(PWRSINK_AUDIO, 0);
 	return 0;
 }
 
--- a/drivers/staging/dream/smd/smd_qmi.c
+++ b/drivers/staging/dream/smd/smd_qmi.c
@@ -24,7 +24,6 @@
 #include <linux/wait.h>
 #include <linux/miscdevice.h>
 #include <linux/workqueue.h>
-#include <linux/wakelock.h>
 
 #include <asm/uaccess.h>
 #include <mach/msm_smd.h>
@@ -74,7 +73,6 @@ struct qmi_ctxt {
 
 	smd_channel_t *ch;
 	const char *ch_name;
-	struct wake_lock wake_lock;
 
 	struct work_struct open_work;
 	struct work_struct read_work;
@@ -90,7 +88,6 @@ void qmi_ctxt_init(struct qmi_ctxt *ctxt
 	mutex_init(&ctxt->lock);
 	INIT_WORK(&ctxt->read_work, qmi_read_work);
 	INIT_WORK(&ctxt->open_work, qmi_open_work);
-	wake_lock_init(&ctxt->wake_lock, WAKE_LOCK_SUSPEND, ctxt->misc.name);
 	ctxt->ctl_txn_id = 1;
 	ctxt->wds_txn_id = 1;
 	ctxt->wds_busy = 1;
@@ -454,7 +451,6 @@ static void qmi_process_qmux(struct qmi_
 		break;
 	}
 	mutex_unlock(&ctxt->lock);
-
 	wake_up(&qmi_wait_queue);
 }
 
@@ -509,7 +505,6 @@ static void qmi_notify(void *priv, unsig
 		int sz;
 		sz = smd_cur_packet_size(ctxt->ch);
 		if ((sz > 0) && (sz <= smd_read_avail(ctxt->ch))) {
-			wake_lock_timeout(&ctxt->wake_lock, HZ / 2);
 			queue_work(qmi_wq, &ctxt->read_work);
 		}
 		break;
--- a/drivers/staging/dream/smd/smd_rpcrouter.c
+++ b/drivers/staging/dream/smd/smd_rpcrouter.c
@@ -33,7 +33,6 @@
 #include <linux/err.h>
 #include <linux/sched.h>
 #include <linux/poll.h>
-#include <linux/wakelock.h>
 #include <asm/uaccess.h>
 #include <asm/byteorder.h>
 #include <linux/platform_device.h>
@@ -96,7 +95,6 @@ static DEFINE_SPINLOCK(server_list_lock)
 static DEFINE_SPINLOCK(smd_lock);
 
 static struct workqueue_struct *rpcrouter_workqueue;
-static struct wake_lock rpcrouter_wake_lock;
 static int rpcrouter_need_len;
 
 static atomic_t next_xid = ATOMIC_INIT(1);
@@ -290,7 +288,6 @@ struct msm_rpc_endpoint *msm_rpcrouter_c
 	init_waitqueue_head(&ept->wait_q);
 	INIT_LIST_HEAD(&ept->read_q);
 	spin_lock_init(&ept->read_q_lock);
-	wake_lock_init(&ept->read_q_wake_lock, WAKE_LOCK_SUSPEND, "rpc_read");
 	INIT_LIST_HEAD(&ept->incomplete);
 
 	spin_lock_irqsave(&local_endpoints_lock, flags);
@@ -313,7 +310,6 @@ int msm_rpcrouter_destroy_local_endpoint
 	if (rc < 0)
 		return rc;
 
-	wake_lock_destroy(&ept->read_q_wake_lock);
 	list_del(&ept->list);
 	kfree(ept);
 	return 0;
@@ -540,8 +536,6 @@ static void rpcrouter_smdnotify(void *_d
 	if (event != SMD_EVENT_DATA)
 		return;
 
-	if (smd_read_avail(smd_channel) >= rpcrouter_need_len)
-		wake_lock(&rpcrouter_wake_lock);
 	wake_up(&smd_wait);
 }
 
@@ -576,7 +570,6 @@ static int rr_read(void *data, int len)
 				return -EIO;
 		}
 		rpcrouter_need_len = len;
-		wake_unlock(&rpcrouter_wake_lock);
 		spin_unlock_irqrestore(&smd_lock, flags);
 
 //		printk("rr_read: waiting (%d)\n", len);
@@ -676,7 +669,6 @@ static void do_read_data(struct work_str
 
 packet_complete:
 	spin_lock_irqsave(&ept->read_q_lock, flags);
-	wake_lock(&ept->read_q_wake_lock);
 	list_add_tail(&pkt->list, &ept->read_q);
 	wake_up(&ept->wait_q);
 	spin_unlock_irqrestore(&ept->read_q_lock, flags);
@@ -699,7 +691,6 @@ done:
 fail_io:
 fail_data:
 	printk(KERN_ERR "rpc_router has died\n");
-	wake_unlock(&rpcrouter_wake_lock);
 }
 
 void msm_rpc_setup_req(struct rpc_request_hdr *hdr, uint32_t prog,
@@ -1061,8 +1052,6 @@ int __msm_rpc_read(struct msm_rpc_endpoi
 		return -ETOOSMALL;
 	}
 	list_del(&pkt->list);
-	if (list_empty(&ept->read_q))
-		wake_unlock(&ept->read_q_wake_lock);
 	spin_unlock_irqrestore(&ept->read_q_lock, flags);
 
 	rc = pkt->length;
@@ -1229,7 +1218,6 @@ static int msm_rpcrouter_probe(struct pl
 
 	init_waitqueue_head(&newserver_wait);
 	init_waitqueue_head(&smd_wait);
-	wake_lock_init(&rpcrouter_wake_lock, WAKE_LOCK_SUSPEND, "SMD_RPCCALL");
 
 	rpcrouter_workqueue = create_singlethread_workqueue("rpcrouter");
 	if (!rpcrouter_workqueue)
--- a/drivers/staging/dream/smd/smd_tty.c
+++ b/drivers/staging/dream/smd/smd_tty.c
@@ -19,7 +19,6 @@
 #include <linux/cdev.h>
 #include <linux/device.h>
 #include <linux/wait.h>
-#include <linux/wakelock.h>
 
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
@@ -34,7 +33,6 @@ static DEFINE_MUTEX(smd_tty_lock);
 struct smd_tty_info {
 	smd_channel_t *ch;
 	struct tty_struct *tty;
-	struct wake_lock wake_lock;
 	int open_count;
 };
 
@@ -69,7 +67,6 @@ static void smd_tty_notify(void *priv, u
 			printk(KERN_ERR "OOPS - smd_tty_buffer mismatch?!");
 		}
 
-		wake_lock_timeout(&info->wake_lock, HZ / 2);
 		tty_flip_buffer_push(tty);
 	}
 
@@ -95,7 +92,6 @@ static int smd_tty_open(struct tty_struc
 	info = smd_tty + n;
 
 	mutex_lock(&smd_tty_lock);
-	wake_lock_init(&info->wake_lock, WAKE_LOCK_SUSPEND, name);
 	tty->driver_data = info;
 
 	if (info->open_count++ == 0) {
@@ -122,7 +118,6 @@ static void smd_tty_close(struct tty_str
 	if (--info->open_count == 0) {
 		info->tty = 0;
 		tty->driver_data = 0;
-		wake_lock_destroy(&info->wake_lock);
 		if (info->ch) {
 			smd_close(info->ch);
 			info->ch = 0;
