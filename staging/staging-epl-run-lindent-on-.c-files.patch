From a4656151a7bbb27db5d11b3f8ad465af5f08fa1d Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Fri, 19 Dec 2008 17:11:52 -0800
Subject: Staging: epl: run Lindent on *.c files

It's a start, still a mess...

Cc: Daniel Krueger <daniel.krueger@systec-electronic.com>
Cc: Ronald Sieber <Ronald.Sieber@systec-electronic.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/epl/Edrv8139.c             | 1363 +++---
 drivers/staging/epl/EplApiGeneric.c        | 2433 +++++-------
 drivers/staging/epl/EplApiLinuxKernel.c    | 1871 ++++-----
 drivers/staging/epl/EplApiProcessImage.c   |  281 -
 drivers/staging/epl/EplDllk.c              | 5835 +++++++++++++++--------------
 drivers/staging/epl/EplDllkCal.c           | 1235 +++---
 drivers/staging/epl/EplDlluCal.c           |  291 -
 drivers/staging/epl/EplErrorHandlerk.c     | 1010 ++---
 drivers/staging/epl/EplEventk.c            | 1017 ++---
 drivers/staging/epl/EplEventu.c            |  875 ++--
 drivers/staging/epl/EplIdentu.c            |  281 -
 drivers/staging/epl/EplNmtCnu.c            |  747 +--
 drivers/staging/epl/EplNmtMnu.c            | 3875 +++++++++----------
 drivers/staging/epl/EplNmtk.c              | 2922 +++++++-------
 drivers/staging/epl/EplNmtkCal.c           |    8 
 drivers/staging/epl/EplNmtu.c              |  703 +--
 drivers/staging/epl/EplNmtuCal.c           |   16 
 drivers/staging/epl/EplObd.c               | 4569 ++++++++++------------
 drivers/staging/epl/EplObdkCal.c           |    7 
 drivers/staging/epl/EplObdu.c              |  167 
 drivers/staging/epl/EplObduCal.c           |  194 
 drivers/staging/epl/EplPdok.c              |  716 +--
 drivers/staging/epl/EplPdokCal.c           |   32 
 drivers/staging/epl/EplPdou.c              |  567 +-
 drivers/staging/epl/EplSdoAsndu.c          |  364 -
 drivers/staging/epl/EplSdoAsySequ.c        | 3597 +++++++++--------
 drivers/staging/epl/EplSdoComu.c           | 4989 +++++++++++++-----------
 drivers/staging/epl/EplSdoUdpu.c           |  831 +---
 drivers/staging/epl/EplStatusu.c           |  173 
 drivers/staging/epl/EplTimeruLinuxKernel.c |  302 -
 drivers/staging/epl/EplTimeruNull.c        |  113 
 drivers/staging/epl/EplTimeruWin32.c       |  486 +-
 drivers/staging/epl/SharedBuff.c           | 2992 ++++++--------
 drivers/staging/epl/ShbIpc-LinuxKernel.c   | 1203 ++---
 drivers/staging/epl/ShbIpc-Win32.c         | 1806 ++++----
 drivers/staging/epl/SocketLinuxKernel.c    |   99 
 drivers/staging/epl/TimerHighReskX86.c     |  514 +-
 drivers/staging/epl/VirtualEthernetLinux.c |  278 -
 drivers/staging/epl/amix86.c               |  410 --
 drivers/staging/epl/demo_main.c            | 1290 +++---
 drivers/staging/epl/proc_fs.c              |  417 +-
 41 files changed, 25335 insertions(+), 25544 deletions(-)

--- a/drivers/staging/epl/amix86.c
+++ b/drivers/staging/epl/amix86.c
@@ -80,25 +80,21 @@
 // typedef
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-   WORD  m_wWord;
+typedef struct {
+	WORD m_wWord;
 
 } twStruct;
 
-typedef struct
-{
-   DWORD  m_dwDword;
+typedef struct {
+	DWORD m_dwDword;
 
 } tdwStruct;
 
-typedef struct
-{
-   QWORD  m_qwQword;
+typedef struct {
+	QWORD m_qwQword;
 
 } tqwStruct;
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -131,46 +127,39 @@ void  PUBLIC  AmiSetByteToBe (void FAR* 
 }
 */
 
-
-
 //------------< write WORD in big endian >--------------------------
 
-INLINE_FUNCTION void  PUBLIC  AmiSetWordToBe (void FAR* pAddr_p, WORD wWordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetWordToBe(void FAR * pAddr_p, WORD wWordVal_p)
 {
-twStruct FAR*  pwStruct;
-twStruct wValue;
+	twStruct FAR *pwStruct;
+	twStruct wValue;
 
-   wValue.m_wWord   = (WORD)((wWordVal_p & 0x00FF) << 8); //LSB to MSB
-   wValue.m_wWord  |= (WORD)((wWordVal_p & 0xFF00) >> 8); //MSB to LSB
+	wValue.m_wWord = (WORD) ((wWordVal_p & 0x00FF) << 8);	//LSB to MSB
+	wValue.m_wWord |= (WORD) ((wWordVal_p & 0xFF00) >> 8);	//MSB to LSB
 
-   pwStruct = (twStruct FAR*)pAddr_p;
-   pwStruct->m_wWord = wValue.m_wWord;
+	pwStruct = (twStruct FAR *) pAddr_p;
+	pwStruct->m_wWord = wValue.m_wWord;
 
 }
 
-
-
 //------------< write DWORD in big endian >-------------------------
 
-INLINE_FUNCTION void  PUBLIC  AmiSetDwordToBe (void FAR* pAddr_p, DWORD dwDwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetDwordToBe(void FAR * pAddr_p,
+					    DWORD dwDwordVal_p)
 {
-tdwStruct FAR*  pdwStruct;
-tdwStruct dwValue;
-
+	tdwStruct FAR *pdwStruct;
+	tdwStruct dwValue;
 
-   dwValue.m_dwDword = ((dwDwordVal_p & 0x000000FF)<<24); //LSB to MSB
-   dwValue.m_dwDword|= ((dwDwordVal_p & 0x0000FF00)<<8);
-   dwValue.m_dwDword|= ((dwDwordVal_p & 0x00FF0000)>>8 );
-   dwValue.m_dwDword|= ((dwDwordVal_p & 0xFF000000)>>24); //MSB to LSB
+	dwValue.m_dwDword = ((dwDwordVal_p & 0x000000FF) << 24);	//LSB to MSB
+	dwValue.m_dwDword |= ((dwDwordVal_p & 0x0000FF00) << 8);
+	dwValue.m_dwDword |= ((dwDwordVal_p & 0x00FF0000) >> 8);
+	dwValue.m_dwDword |= ((dwDwordVal_p & 0xFF000000) >> 24);	//MSB to LSB
 
-   pdwStruct = (tdwStruct FAR*)pAddr_p;
-   pdwStruct->m_dwDword = dwValue.m_dwDword;
+	pdwStruct = (tdwStruct FAR *) pAddr_p;
+	pdwStruct->m_dwDword = dwValue.m_dwDword;
 
 }
 
-
-
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetXXXToLe()
@@ -197,35 +186,29 @@ void  PUBLIC  AmiSetByteToLe (void FAR* 
 }
 */
 
-
-
 //------------< write WORD in little endian >--------------------------
 
-INLINE_FUNCTION void  PUBLIC  AmiSetWordToLe (void FAR* pAddr_p, WORD wWordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetWordToLe(void FAR * pAddr_p, WORD wWordVal_p)
 {
-twStruct FAR*  pwStruct;
+	twStruct FAR *pwStruct;
 
-   pwStruct = (twStruct FAR*)pAddr_p;
-   pwStruct->m_wWord = wWordVal_p;
+	pwStruct = (twStruct FAR *) pAddr_p;
+	pwStruct->m_wWord = wWordVal_p;
 
 }
 
-
-
 //------------< write DWORD in little endian >-------------------------
 
-INLINE_FUNCTION void  PUBLIC  AmiSetDwordToLe (void FAR* pAddr_p, DWORD dwDwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetDwordToLe(void FAR * pAddr_p,
+					    DWORD dwDwordVal_p)
 {
-tdwStruct FAR*  pdwStruct;
+	tdwStruct FAR *pdwStruct;
 
-   pdwStruct = (tdwStruct FAR*)pAddr_p;
-   pdwStruct->m_dwDword = dwDwordVal_p;
+	pdwStruct = (tdwStruct FAR *) pAddr_p;
+	pdwStruct->m_dwDword = dwDwordVal_p;
 
 }
 
-
-
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetXXXFromBe()
@@ -251,46 +234,40 @@ BYTE  PUBLIC  AmiGetByteFromBe (void FAR
 }
 */
 
-
-
 //------------< read WORD in big endian >---------------------------
 
-INLINE_FUNCTION WORD  PUBLIC  AmiGetWordFromBe (void FAR* pAddr_p)
+INLINE_FUNCTION WORD PUBLIC AmiGetWordFromBe(void FAR * pAddr_p)
 {
-twStruct FAR*  pwStruct;
-twStruct wValue;
+	twStruct FAR *pwStruct;
+	twStruct wValue;
 
-   pwStruct = (twStruct FAR*)pAddr_p;
+	pwStruct = (twStruct FAR *) pAddr_p;
 
-   wValue.m_wWord   = (WORD)((pwStruct->m_wWord & 0x00FF) << 8); //LSB to MSB
-   wValue.m_wWord  |= (WORD)((pwStruct->m_wWord & 0xFF00) >> 8); //MSB to LSB
+	wValue.m_wWord = (WORD) ((pwStruct->m_wWord & 0x00FF) << 8);	//LSB to MSB
+	wValue.m_wWord |= (WORD) ((pwStruct->m_wWord & 0xFF00) >> 8);	//MSB to LSB
 
-   return ( wValue.m_wWord );
+	return (wValue.m_wWord);
 
 }
 
-
-
-
 //------------< read DWORD in big endian >--------------------------
 
-INLINE_FUNCTION DWORD  PUBLIC  AmiGetDwordFromBe (void FAR* pAddr_p)
+INLINE_FUNCTION DWORD PUBLIC AmiGetDwordFromBe(void FAR * pAddr_p)
 {
-tdwStruct FAR*  pdwStruct;
-tdwStruct dwValue;
+	tdwStruct FAR *pdwStruct;
+	tdwStruct dwValue;
 
-   pdwStruct = (tdwStruct FAR*)pAddr_p;
+	pdwStruct = (tdwStruct FAR *) pAddr_p;
 
-   dwValue.m_dwDword = ((pdwStruct->m_dwDword & 0x000000FF)<<24); //LSB to MSB
-   dwValue.m_dwDword|= ((pdwStruct->m_dwDword & 0x0000FF00)<<8);
-   dwValue.m_dwDword|= ((pdwStruct->m_dwDword & 0x00FF0000)>>8 );
-   dwValue.m_dwDword|= ((pdwStruct->m_dwDword & 0xFF000000)>>24); //MSB to LSB
+	dwValue.m_dwDword = ((pdwStruct->m_dwDword & 0x000000FF) << 24);	//LSB to MSB
+	dwValue.m_dwDword |= ((pdwStruct->m_dwDword & 0x0000FF00) << 8);
+	dwValue.m_dwDword |= ((pdwStruct->m_dwDword & 0x00FF0000) >> 8);
+	dwValue.m_dwDword |= ((pdwStruct->m_dwDword & 0xFF000000) >> 24);	//MSB to LSB
 
-   return ( dwValue.m_dwDword );
+	return (dwValue.m_dwDword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetXXXFromLe()
@@ -316,34 +293,28 @@ BYTE  PUBLIC  AmiGetByteFromLe (void FAR
 }
 */
 
-
-
 //------------< read WORD in little endian >---------------------------
 
-INLINE_FUNCTION WORD  PUBLIC  AmiGetWordFromLe (void FAR* pAddr_p)
+INLINE_FUNCTION WORD PUBLIC AmiGetWordFromLe(void FAR * pAddr_p)
 {
-twStruct FAR*  pwStruct;
+	twStruct FAR *pwStruct;
 
-   pwStruct = (twStruct FAR*)pAddr_p;
-   return ( pwStruct->m_wWord );
+	pwStruct = (twStruct FAR *) pAddr_p;
+	return (pwStruct->m_wWord);
 
 }
 
-
-
-
 //------------< read DWORD in little endian >--------------------------
 
-INLINE_FUNCTION DWORD  PUBLIC  AmiGetDwordFromLe (void FAR* pAddr_p)
+INLINE_FUNCTION DWORD PUBLIC AmiGetDwordFromLe(void FAR * pAddr_p)
 {
-tdwStruct FAR*  pdwStruct;
+	tdwStruct FAR *pdwStruct;
 
-   pdwStruct = (tdwStruct FAR*)pAddr_p;
-   return ( pdwStruct->m_dwDword );
+	pdwStruct = (tdwStruct FAR *) pAddr_p;
+	return (pdwStruct->m_dwDword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetDword24ToBe()
@@ -359,16 +330,16 @@ tdwStruct FAR*  pdwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetDword24ToBe (void FAR* pAddr_p, DWORD dwDwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetDword24ToBe(void FAR * pAddr_p,
+					      DWORD dwDwordVal_p)
 {
 
-    ((BYTE FAR*) pAddr_p)[0] = ((BYTE FAR*) &dwDwordVal_p)[2];
-    ((BYTE FAR*) pAddr_p)[1] = ((BYTE FAR*) &dwDwordVal_p)[1];
-    ((BYTE FAR*) pAddr_p)[2] = ((BYTE FAR*) &dwDwordVal_p)[0];
+	((BYTE FAR *) pAddr_p)[0] = ((BYTE FAR *) & dwDwordVal_p)[2];
+	((BYTE FAR *) pAddr_p)[1] = ((BYTE FAR *) & dwDwordVal_p)[1];
+	((BYTE FAR *) pAddr_p)[2] = ((BYTE FAR *) & dwDwordVal_p)[0];
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetDword24ToLe()
@@ -384,16 +355,16 @@ INLINE_FUNCTION void PUBLIC AmiSetDword2
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetDword24ToLe (void FAR* pAddr_p, DWORD dwDwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetDword24ToLe(void FAR * pAddr_p,
+					      DWORD dwDwordVal_p)
 {
 
-    ((BYTE FAR*) pAddr_p)[0] = ((BYTE FAR*) &dwDwordVal_p)[0];
-    ((BYTE FAR*) pAddr_p)[1] = ((BYTE FAR*) &dwDwordVal_p)[1];
-    ((BYTE FAR*) pAddr_p)[2] = ((BYTE FAR*) &dwDwordVal_p)[2];
+	((BYTE FAR *) pAddr_p)[0] = ((BYTE FAR *) & dwDwordVal_p)[0];
+	((BYTE FAR *) pAddr_p)[1] = ((BYTE FAR *) & dwDwordVal_p)[1];
+	((BYTE FAR *) pAddr_p)[2] = ((BYTE FAR *) & dwDwordVal_p)[2];
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetDword24FromBe()
@@ -408,19 +379,18 @@ INLINE_FUNCTION void PUBLIC AmiSetDword2
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION DWORD PUBLIC AmiGetDword24FromBe (void FAR* pAddr_p)
+INLINE_FUNCTION DWORD PUBLIC AmiGetDword24FromBe(void FAR * pAddr_p)
 {
 
-tdwStruct      dwStruct;
+	tdwStruct dwStruct;
 
-    dwStruct.m_dwDword  = AmiGetDwordFromBe (pAddr_p);
-    dwStruct.m_dwDword >>= 8;
+	dwStruct.m_dwDword = AmiGetDwordFromBe(pAddr_p);
+	dwStruct.m_dwDword >>= 8;
 
-    return ( dwStruct.m_dwDword );
+	return (dwStruct.m_dwDword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetDword24FromLe()
@@ -435,19 +405,18 @@ tdwStruct      dwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION DWORD PUBLIC AmiGetDword24FromLe (void FAR* pAddr_p)
+INLINE_FUNCTION DWORD PUBLIC AmiGetDword24FromLe(void FAR * pAddr_p)
 {
 
-tdwStruct      dwStruct;
+	tdwStruct dwStruct;
 
-    dwStruct.m_dwDword  = AmiGetDwordFromLe (pAddr_p);
-    dwStruct.m_dwDword &= 0x00FFFFFF;
+	dwStruct.m_dwDword = AmiGetDwordFromLe(pAddr_p);
+	dwStruct.m_dwDword &= 0x00FFFFFF;
 
-    return ( dwStruct.m_dwDword );
+	return (dwStruct.m_dwDword);
 
 }
 
-
 //#ifdef USE_VAR64
 
 //---------------------------------------------------------------------------
@@ -465,21 +434,21 @@ tdwStruct      dwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetQword64ToBe (void FAR* pAddr_p, QWORD qwQwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetQword64ToBe(void FAR * pAddr_p,
+					      QWORD qwQwordVal_p)
 {
 
-    ((BYTE FAR*) pAddr_p)[0] = ((BYTE FAR*) &qwQwordVal_p)[7];
-    ((BYTE FAR*) pAddr_p)[1] = ((BYTE FAR*) &qwQwordVal_p)[6];
-    ((BYTE FAR*) pAddr_p)[2] = ((BYTE FAR*) &qwQwordVal_p)[5];
-    ((BYTE FAR*) pAddr_p)[3] = ((BYTE FAR*) &qwQwordVal_p)[4];
-    ((BYTE FAR*) pAddr_p)[4] = ((BYTE FAR*) &qwQwordVal_p)[3];
-    ((BYTE FAR*) pAddr_p)[5] = ((BYTE FAR*) &qwQwordVal_p)[2];
-    ((BYTE FAR*) pAddr_p)[6] = ((BYTE FAR*) &qwQwordVal_p)[1];
-    ((BYTE FAR*) pAddr_p)[7] = ((BYTE FAR*) &qwQwordVal_p)[0];
+	((BYTE FAR *) pAddr_p)[0] = ((BYTE FAR *) & qwQwordVal_p)[7];
+	((BYTE FAR *) pAddr_p)[1] = ((BYTE FAR *) & qwQwordVal_p)[6];
+	((BYTE FAR *) pAddr_p)[2] = ((BYTE FAR *) & qwQwordVal_p)[5];
+	((BYTE FAR *) pAddr_p)[3] = ((BYTE FAR *) & qwQwordVal_p)[4];
+	((BYTE FAR *) pAddr_p)[4] = ((BYTE FAR *) & qwQwordVal_p)[3];
+	((BYTE FAR *) pAddr_p)[5] = ((BYTE FAR *) & qwQwordVal_p)[2];
+	((BYTE FAR *) pAddr_p)[6] = ((BYTE FAR *) & qwQwordVal_p)[1];
+	((BYTE FAR *) pAddr_p)[7] = ((BYTE FAR *) & qwQwordVal_p)[0];
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetQword64ToLe()
@@ -495,17 +464,17 @@ INLINE_FUNCTION void PUBLIC AmiSetQword6
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetQword64ToLe (void FAR* pAddr_p, QWORD qwQwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetQword64ToLe(void FAR * pAddr_p,
+					      QWORD qwQwordVal_p)
 {
 
-QWORD FAR* pqwDst;
+	QWORD FAR *pqwDst;
 
-    pqwDst  = (QWORD FAR*) pAddr_p;
-    *pqwDst = qwQwordVal_p;
+	pqwDst = (QWORD FAR *) pAddr_p;
+	*pqwDst = qwQwordVal_p;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetQword64FromBe()
@@ -520,25 +489,24 @@ QWORD FAR* pqwDst;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION QWORD PUBLIC AmiGetQword64FromBe (void FAR* pAddr_p)
+INLINE_FUNCTION QWORD PUBLIC AmiGetQword64FromBe(void FAR * pAddr_p)
 {
 
-tqwStruct      qwStruct;
+	tqwStruct qwStruct;
 
-    ((BYTE FAR*) &qwStruct.m_qwQword)[0] = ((BYTE FAR*) pAddr_p)[7];
-    ((BYTE FAR*) &qwStruct.m_qwQword)[1] = ((BYTE FAR*) pAddr_p)[6];
-    ((BYTE FAR*) &qwStruct.m_qwQword)[2] = ((BYTE FAR*) pAddr_p)[5];
-    ((BYTE FAR*) &qwStruct.m_qwQword)[3] = ((BYTE FAR*) pAddr_p)[4];
-    ((BYTE FAR*) &qwStruct.m_qwQword)[4] = ((BYTE FAR*) pAddr_p)[3];
-    ((BYTE FAR*) &qwStruct.m_qwQword)[5] = ((BYTE FAR*) pAddr_p)[2];
-    ((BYTE FAR*) &qwStruct.m_qwQword)[6] = ((BYTE FAR*) pAddr_p)[1];
-    ((BYTE FAR*) &qwStruct.m_qwQword)[7] = ((BYTE FAR*) pAddr_p)[0];
+	((BYTE FAR *) & qwStruct.m_qwQword)[0] = ((BYTE FAR *) pAddr_p)[7];
+	((BYTE FAR *) & qwStruct.m_qwQword)[1] = ((BYTE FAR *) pAddr_p)[6];
+	((BYTE FAR *) & qwStruct.m_qwQword)[2] = ((BYTE FAR *) pAddr_p)[5];
+	((BYTE FAR *) & qwStruct.m_qwQword)[3] = ((BYTE FAR *) pAddr_p)[4];
+	((BYTE FAR *) & qwStruct.m_qwQword)[4] = ((BYTE FAR *) pAddr_p)[3];
+	((BYTE FAR *) & qwStruct.m_qwQword)[5] = ((BYTE FAR *) pAddr_p)[2];
+	((BYTE FAR *) & qwStruct.m_qwQword)[6] = ((BYTE FAR *) pAddr_p)[1];
+	((BYTE FAR *) & qwStruct.m_qwQword)[7] = ((BYTE FAR *) pAddr_p)[0];
 
-    return ( qwStruct.m_qwQword );
+	return (qwStruct.m_qwQword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetQword64FromLe()
@@ -553,20 +521,19 @@ tqwStruct      qwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION QWORD PUBLIC AmiGetQword64FromLe (void FAR* pAddr_p)
+INLINE_FUNCTION QWORD PUBLIC AmiGetQword64FromLe(void FAR * pAddr_p)
 {
 
-tqwStruct FAR* pqwStruct;
-tqwStruct      qwStruct;
+	tqwStruct FAR *pqwStruct;
+	tqwStruct qwStruct;
 
-    pqwStruct = (tqwStruct FAR*) pAddr_p;
-    qwStruct.m_qwQword = pqwStruct->m_qwQword;
+	pqwStruct = (tqwStruct FAR *) pAddr_p;
+	qwStruct.m_qwQword = pqwStruct->m_qwQword;
 
-    return ( qwStruct.m_qwQword );
+	return (qwStruct.m_qwQword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetQword40ToBe()
@@ -582,18 +549,18 @@ tqwStruct      qwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetQword40ToBe (void FAR* pAddr_p, QWORD qwQwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetQword40ToBe(void FAR * pAddr_p,
+					      QWORD qwQwordVal_p)
 {
 
-    ((BYTE FAR*) pAddr_p)[0] = ((BYTE FAR*) &qwQwordVal_p)[4];
-    ((BYTE FAR*) pAddr_p)[1] = ((BYTE FAR*) &qwQwordVal_p)[3];
-    ((BYTE FAR*) pAddr_p)[2] = ((BYTE FAR*) &qwQwordVal_p)[2];
-    ((BYTE FAR*) pAddr_p)[3] = ((BYTE FAR*) &qwQwordVal_p)[1];
-    ((BYTE FAR*) pAddr_p)[4] = ((BYTE FAR*) &qwQwordVal_p)[0];
+	((BYTE FAR *) pAddr_p)[0] = ((BYTE FAR *) & qwQwordVal_p)[4];
+	((BYTE FAR *) pAddr_p)[1] = ((BYTE FAR *) & qwQwordVal_p)[3];
+	((BYTE FAR *) pAddr_p)[2] = ((BYTE FAR *) & qwQwordVal_p)[2];
+	((BYTE FAR *) pAddr_p)[3] = ((BYTE FAR *) & qwQwordVal_p)[1];
+	((BYTE FAR *) pAddr_p)[4] = ((BYTE FAR *) & qwQwordVal_p)[0];
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetQword40ToLe()
@@ -609,15 +576,15 @@ INLINE_FUNCTION void PUBLIC AmiSetQword4
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetQword40ToLe (void FAR* pAddr_p, QWORD qwQwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetQword40ToLe(void FAR * pAddr_p,
+					      QWORD qwQwordVal_p)
 {
 
-    ((DWORD FAR*) pAddr_p)[0] = ((DWORD FAR*) &qwQwordVal_p)[0];
-    ((BYTE  FAR*) pAddr_p)[4] = ((BYTE  FAR*) &qwQwordVal_p)[4];
+	((DWORD FAR *) pAddr_p)[0] = ((DWORD FAR *) & qwQwordVal_p)[0];
+	((BYTE FAR *) pAddr_p)[4] = ((BYTE FAR *) & qwQwordVal_p)[4];
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetQword40FromBe()
@@ -632,19 +599,18 @@ INLINE_FUNCTION void PUBLIC AmiSetQword4
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION QWORD PUBLIC AmiGetQword40FromBe (void FAR* pAddr_p)
+INLINE_FUNCTION QWORD PUBLIC AmiGetQword40FromBe(void FAR * pAddr_p)
 {
 
-tqwStruct      qwStruct;
+	tqwStruct qwStruct;
 
-    qwStruct.m_qwQword  = AmiGetQword64FromBe (pAddr_p);
-    qwStruct.m_qwQword >>= 24;
+	qwStruct.m_qwQword = AmiGetQword64FromBe(pAddr_p);
+	qwStruct.m_qwQword >>= 24;
 
-    return ( qwStruct.m_qwQword );
+	return (qwStruct.m_qwQword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetQword40FromLe()
@@ -659,19 +625,18 @@ tqwStruct      qwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION QWORD PUBLIC AmiGetQword40FromLe (void FAR* pAddr_p)
+INLINE_FUNCTION QWORD PUBLIC AmiGetQword40FromLe(void FAR * pAddr_p)
 {
 
-tqwStruct      qwStruct;
+	tqwStruct qwStruct;
 
-    qwStruct.m_qwQword  = AmiGetQword64FromLe (pAddr_p);
-    qwStruct.m_qwQword &= 0x000000FFFFFFFFFFLL;
+	qwStruct.m_qwQword = AmiGetQword64FromLe(pAddr_p);
+	qwStruct.m_qwQword &= 0x000000FFFFFFFFFFLL;
 
-    return ( qwStruct.m_qwQword );
+	return (qwStruct.m_qwQword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetQword48ToBe()
@@ -687,19 +652,19 @@ tqwStruct      qwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetQword48ToBe (void FAR* pAddr_p, QWORD qwQwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetQword48ToBe(void FAR * pAddr_p,
+					      QWORD qwQwordVal_p)
 {
 
-    ((BYTE FAR*) pAddr_p)[0] = ((BYTE FAR*) &qwQwordVal_p)[5];
-    ((BYTE FAR*) pAddr_p)[1] = ((BYTE FAR*) &qwQwordVal_p)[4];
-    ((BYTE FAR*) pAddr_p)[2] = ((BYTE FAR*) &qwQwordVal_p)[3];
-    ((BYTE FAR*) pAddr_p)[3] = ((BYTE FAR*) &qwQwordVal_p)[2];
-    ((BYTE FAR*) pAddr_p)[4] = ((BYTE FAR*) &qwQwordVal_p)[1];
-    ((BYTE FAR*) pAddr_p)[5] = ((BYTE FAR*) &qwQwordVal_p)[0];
+	((BYTE FAR *) pAddr_p)[0] = ((BYTE FAR *) & qwQwordVal_p)[5];
+	((BYTE FAR *) pAddr_p)[1] = ((BYTE FAR *) & qwQwordVal_p)[4];
+	((BYTE FAR *) pAddr_p)[2] = ((BYTE FAR *) & qwQwordVal_p)[3];
+	((BYTE FAR *) pAddr_p)[3] = ((BYTE FAR *) & qwQwordVal_p)[2];
+	((BYTE FAR *) pAddr_p)[4] = ((BYTE FAR *) & qwQwordVal_p)[1];
+	((BYTE FAR *) pAddr_p)[5] = ((BYTE FAR *) & qwQwordVal_p)[0];
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetQword48ToLe()
@@ -715,15 +680,15 @@ INLINE_FUNCTION void PUBLIC AmiSetQword4
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetQword48ToLe (void FAR* pAddr_p, QWORD qwQwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetQword48ToLe(void FAR * pAddr_p,
+					      QWORD qwQwordVal_p)
 {
 
-    ((DWORD FAR*) pAddr_p)[0] = ((DWORD FAR*) &qwQwordVal_p)[0];
-    ((WORD  FAR*) pAddr_p)[2] = ((WORD  FAR*) &qwQwordVal_p)[2];
+	((DWORD FAR *) pAddr_p)[0] = ((DWORD FAR *) & qwQwordVal_p)[0];
+	((WORD FAR *) pAddr_p)[2] = ((WORD FAR *) & qwQwordVal_p)[2];
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetQword48FromBe()
@@ -738,19 +703,18 @@ INLINE_FUNCTION void PUBLIC AmiSetQword4
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION QWORD PUBLIC AmiGetQword48FromBe (void FAR* pAddr_p)
+INLINE_FUNCTION QWORD PUBLIC AmiGetQword48FromBe(void FAR * pAddr_p)
 {
 
-tqwStruct      qwStruct;
+	tqwStruct qwStruct;
 
-    qwStruct.m_qwQword  = AmiGetQword64FromBe (pAddr_p);
-    qwStruct.m_qwQword >>= 16;
+	qwStruct.m_qwQword = AmiGetQword64FromBe(pAddr_p);
+	qwStruct.m_qwQword >>= 16;
 
-    return ( qwStruct.m_qwQword );
+	return (qwStruct.m_qwQword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetQword48FromLe()
@@ -765,19 +729,18 @@ tqwStruct      qwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION QWORD PUBLIC AmiGetQword48FromLe (void FAR* pAddr_p)
+INLINE_FUNCTION QWORD PUBLIC AmiGetQword48FromLe(void FAR * pAddr_p)
 {
 
-tqwStruct      qwStruct;
+	tqwStruct qwStruct;
 
-    qwStruct.m_qwQword  = AmiGetQword64FromLe (pAddr_p);
-    qwStruct.m_qwQword &= 0x0000FFFFFFFFFFFFLL;
+	qwStruct.m_qwQword = AmiGetQword64FromLe(pAddr_p);
+	qwStruct.m_qwQword &= 0x0000FFFFFFFFFFFFLL;
 
-    return ( qwStruct.m_qwQword );
+	return (qwStruct.m_qwQword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetQword56ToBe()
@@ -793,20 +756,20 @@ tqwStruct      qwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetQword56ToBe (void FAR* pAddr_p, QWORD qwQwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetQword56ToBe(void FAR * pAddr_p,
+					      QWORD qwQwordVal_p)
 {
 
-    ((BYTE FAR*) pAddr_p)[0] = ((BYTE FAR*) &qwQwordVal_p)[6];
-    ((BYTE FAR*) pAddr_p)[1] = ((BYTE FAR*) &qwQwordVal_p)[5];
-    ((BYTE FAR*) pAddr_p)[2] = ((BYTE FAR*) &qwQwordVal_p)[4];
-    ((BYTE FAR*) pAddr_p)[3] = ((BYTE FAR*) &qwQwordVal_p)[3];
-    ((BYTE FAR*) pAddr_p)[4] = ((BYTE FAR*) &qwQwordVal_p)[2];
-    ((BYTE FAR*) pAddr_p)[5] = ((BYTE FAR*) &qwQwordVal_p)[1];
-    ((BYTE FAR*) pAddr_p)[6] = ((BYTE FAR*) &qwQwordVal_p)[0];
+	((BYTE FAR *) pAddr_p)[0] = ((BYTE FAR *) & qwQwordVal_p)[6];
+	((BYTE FAR *) pAddr_p)[1] = ((BYTE FAR *) & qwQwordVal_p)[5];
+	((BYTE FAR *) pAddr_p)[2] = ((BYTE FAR *) & qwQwordVal_p)[4];
+	((BYTE FAR *) pAddr_p)[3] = ((BYTE FAR *) & qwQwordVal_p)[3];
+	((BYTE FAR *) pAddr_p)[4] = ((BYTE FAR *) & qwQwordVal_p)[2];
+	((BYTE FAR *) pAddr_p)[5] = ((BYTE FAR *) & qwQwordVal_p)[1];
+	((BYTE FAR *) pAddr_p)[6] = ((BYTE FAR *) & qwQwordVal_p)[0];
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetQword56ToLe()
@@ -822,16 +785,16 @@ INLINE_FUNCTION void PUBLIC AmiSetQword5
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetQword56ToLe (void FAR* pAddr_p, QWORD qwQwordVal_p)
+INLINE_FUNCTION void PUBLIC AmiSetQword56ToLe(void FAR * pAddr_p,
+					      QWORD qwQwordVal_p)
 {
 
-    ((DWORD FAR*) pAddr_p)[0] = ((DWORD FAR*) &qwQwordVal_p)[0];
-    ((WORD  FAR*) pAddr_p)[2] = ((WORD  FAR*) &qwQwordVal_p)[2];
-    ((BYTE  FAR*) pAddr_p)[6] = ((BYTE  FAR*) &qwQwordVal_p)[6];
+	((DWORD FAR *) pAddr_p)[0] = ((DWORD FAR *) & qwQwordVal_p)[0];
+	((WORD FAR *) pAddr_p)[2] = ((WORD FAR *) & qwQwordVal_p)[2];
+	((BYTE FAR *) pAddr_p)[6] = ((BYTE FAR *) & qwQwordVal_p)[6];
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetQword56FromBe()
@@ -846,19 +809,18 @@ INLINE_FUNCTION void PUBLIC AmiSetQword5
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION QWORD PUBLIC AmiGetQword56FromBe (void FAR* pAddr_p)
+INLINE_FUNCTION QWORD PUBLIC AmiGetQword56FromBe(void FAR * pAddr_p)
 {
 
-tqwStruct      qwStruct;
+	tqwStruct qwStruct;
 
-    qwStruct.m_qwQword  = AmiGetQword64FromBe (pAddr_p);
-    qwStruct.m_qwQword >>= 8;
+	qwStruct.m_qwQword = AmiGetQword64FromBe(pAddr_p);
+	qwStruct.m_qwQword >>= 8;
 
-    return ( qwStruct.m_qwQword );
+	return (qwStruct.m_qwQword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetQword56FromLe()
@@ -873,19 +835,18 @@ tqwStruct      qwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION QWORD PUBLIC AmiGetQword56FromLe (void FAR* pAddr_p)
+INLINE_FUNCTION QWORD PUBLIC AmiGetQword56FromLe(void FAR * pAddr_p)
 {
 
-tqwStruct      qwStruct;
+	tqwStruct qwStruct;
 
-    qwStruct.m_qwQword  = AmiGetQword64FromLe (pAddr_p);
-    qwStruct.m_qwQword &= 0x00FFFFFFFFFFFFFFLL;
+	qwStruct.m_qwQword = AmiGetQword64FromLe(pAddr_p);
+	qwStruct.m_qwQword &= 0x00FFFFFFFFFFFFFFLL;
 
-    return ( qwStruct.m_qwQword );
+	return (qwStruct.m_qwQword);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiSetTimeOfDay()
@@ -901,15 +862,16 @@ tqwStruct      qwStruct;
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiSetTimeOfDay (void FAR* pAddr_p, tTimeOfDay FAR* pTimeOfDay_p)
+INLINE_FUNCTION void PUBLIC AmiSetTimeOfDay(void FAR * pAddr_p,
+					    tTimeOfDay FAR * pTimeOfDay_p)
 {
 
-    AmiSetDwordToLe (((BYTE FAR*) pAddr_p),     pTimeOfDay_p->m_dwMs & 0x0FFFFFFF);
-    AmiSetWordToLe  (((BYTE FAR*) pAddr_p) + 4, pTimeOfDay_p->m_wDays);
+	AmiSetDwordToLe(((BYTE FAR *) pAddr_p),
+			pTimeOfDay_p->m_dwMs & 0x0FFFFFFF);
+	AmiSetWordToLe(((BYTE FAR *) pAddr_p) + 4, pTimeOfDay_p->m_wDays);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AmiGetTimeOfDay()
@@ -925,21 +887,19 @@ INLINE_FUNCTION void PUBLIC AmiSetTimeOf
 //
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void PUBLIC AmiGetTimeOfDay (void FAR* pAddr_p, tTimeOfDay FAR* pTimeOfDay_p)
+INLINE_FUNCTION void PUBLIC AmiGetTimeOfDay(void FAR * pAddr_p,
+					    tTimeOfDay FAR * pTimeOfDay_p)
 {
 
-    pTimeOfDay_p->m_dwMs  = AmiGetDwordFromLe (((BYTE FAR*) pAddr_p)) & 0x0FFFFFFF;
-    pTimeOfDay_p->m_wDays = AmiGetWordFromLe  (((BYTE FAR*) pAddr_p) + 4);
+	pTimeOfDay_p->m_dwMs =
+	    AmiGetDwordFromLe(((BYTE FAR *) pAddr_p)) & 0x0FFFFFFF;
+	pTimeOfDay_p->m_wDays = AmiGetWordFromLe(((BYTE FAR *) pAddr_p) + 4);
 
 }
 
-
 #endif
 
-
-
 // EOF
 
 // Die letzte Zeile muﬂ unbedingt eine leere Zeile sein, weil manche Compiler
 // damit ein Problem haben, wenn das nicht so ist (z.B. GNU oder Borland C++ Builder).
-
--- a/drivers/staging/epl/demo_main.c
+++ b/drivers/staging/epl/demo_main.c
@@ -69,7 +69,6 @@
 
 ****************************************************************************/
 
-
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -85,21 +84,19 @@
 #include <linux/pci.h>
 #include <linux/proc_fs.h>
 
-
 #include "Epl.h"
 #include "proc_fs.h"
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
     // remove ("make invisible") obsolete symbols for kernel versions 2.6
     // and higher
-    #define MOD_INC_USE_COUNT
-    #define MOD_DEC_USE_COUNT
-    #define EXPORT_NO_SYMBOLS
+#define MOD_INC_USE_COUNT
+#define MOD_DEC_USE_COUNT
+#define EXPORT_NO_SYMBOLS
 #else
-    #error "This driver needs a 2.6.x kernel or higher"
+#error "This driver needs a 2.6.x kernel or higher"
 #endif
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -111,76 +108,70 @@
 // Metainformation
 MODULE_LICENSE("Dual BSD/GPL");
 #ifdef MODULE_AUTHOR
-    MODULE_AUTHOR("Daniel.Krueger@SYSTEC-electronic.com");
-    MODULE_DESCRIPTION("EPL MN demo");
+MODULE_AUTHOR("Daniel.Krueger@SYSTEC-electronic.com");
+MODULE_DESCRIPTION("EPL MN demo");
 #endif
 
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
 
-
-
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-    void  PUBLIC  TgtDbgSignalTracePoint (BYTE bTracePointNumber_p);
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #else
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)
 #endif
 
-#define NODEID      0xF0 //=> MN
-#define CYCLE_LEN   5000 // [us]
-#define IP_ADDR     0xc0a86401  // 192.168.100.1
-#define SUBNET_MASK 0xFFFFFF00  // 255.255.255.0
+#define NODEID      0xF0	//=> MN
+#define CYCLE_LEN   5000	// [us]
+#define IP_ADDR     0xc0a86401	// 192.168.100.1
+#define SUBNET_MASK 0xFFFFFF00	// 255.255.255.0
 #define HOSTNAME    "SYS TEC electronic EPL Stack    "
 #define IF_ETH      EPL_VETH_NAME
 
-
 // LIGHT EFFECT
-#define DEFAULT_MAX_CYCLE_COUNT 20  // 6 is very fast
+#define DEFAULT_MAX_CYCLE_COUNT 20	// 6 is very fast
 #define APP_DEFAULT_MODE        0x01
-#define APP_LED_COUNT           5       // number of LEDs in one row
+#define APP_LED_COUNT           5	// number of LEDs in one row
 #define APP_LED_MASK            ((1 << APP_LED_COUNT) - 1)
 #define APP_DOUBLE_LED_MASK     ((1 << (APP_LED_COUNT * 2)) - 1)
 #define APP_MODE_COUNT          5
 #define APP_MODE_MASK           ((1 << APP_MODE_COUNT) - 1)
 
-
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 // modul globale vars
 //---------------------------------------------------------------------------
 
-CONST BYTE abMacAddr[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+CONST BYTE abMacAddr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 
-BYTE    bVarIn1_l;
-BYTE    bVarOut1_l;
-BYTE    bVarOut1Old_l;
-BYTE    bModeSelect_l;      // state of the pushbuttons to select the mode
-BYTE    bSpeedSelect_l;     // state of the pushbuttons to increase/decrease the speed
-BYTE    bSpeedSelectOld_l;  // old state of the pushbuttons
-DWORD   dwLeds_l;           // current state of all LEDs
-BYTE    bLedsRow1_l;        // current state of the LEDs in row 1
-BYTE    bLedsRow2_l;        // current state of the LEDs in row 2
-BYTE    abSelect_l[3];      // pushbuttons from CNs
-
-DWORD   dwMode_l;           // current mode
-int     iCurCycleCount_l;   // current cycle count
-int     iMaxCycleCount_l;   // maximum cycle count (i.e. number of cycles until next light movement step)
-int     iToggle;            // indicates the light movement direction
+BYTE bVarIn1_l;
+BYTE bVarOut1_l;
+BYTE bVarOut1Old_l;
+BYTE bModeSelect_l;		// state of the pushbuttons to select the mode
+BYTE bSpeedSelect_l;		// state of the pushbuttons to increase/decrease the speed
+BYTE bSpeedSelectOld_l;		// old state of the pushbuttons
+DWORD dwLeds_l;			// current state of all LEDs
+BYTE bLedsRow1_l;		// current state of the LEDs in row 1
+BYTE bLedsRow2_l;		// current state of the LEDs in row 2
+BYTE abSelect_l[3];		// pushbuttons from CNs
+
+DWORD dwMode_l;			// current mode
+int iCurCycleCount_l;		// current cycle count
+int iMaxCycleCount_l;		// maximum cycle count (i.e. number of cycles until next light movement step)
+int iToggle;			// indicates the light movement direction
 
-BYTE    abDomain_l[3000];
+BYTE abDomain_l[3000];
 
-static wait_queue_head_t    WaitQueueShutdown_g; // wait queue for tEplNmtEventSwitchOff
-static atomic_t             AtomicShutdown_g = ATOMIC_INIT(FALSE);
+static wait_queue_head_t WaitQueueShutdown_g;	// wait queue for tEplNmtEventSwitchOff
+static atomic_t AtomicShutdown_g = ATOMIC_INIT(FALSE);
 
-static DWORD    dw_le_CycleLen_g;
+static DWORD dw_le_CycleLen_g;
 
 static uint uiNodeId_g = EPL_C_ADR_INVALID;
 module_param_named(nodeid, uiNodeId_g, uint, 0);
@@ -188,7 +179,6 @@ module_param_named(nodeid, uiNodeId_g, u
 static uint uiCycleLen_g = CYCLE_LEN;
 module_param_named(cyclelen, uiCycleLen_g, uint, 0);
 
-
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
@@ -198,17 +188,16 @@ module_param_named(cyclelen, uiCycleLen_
 // this function prototype here. If you want to use more than one Epl
 // instances then the function name of each object dictionary has to differ.
 
-tEplKernel PUBLIC  EplObdInitRam (tEplObdInitParam MEM* pInitParam_p);
+tEplKernel PUBLIC EplObdInitRam(tEplObdInitParam MEM * pInitParam_p);
 
-tEplKernel PUBLIC AppCbEvent(
-    tEplApiEventType        EventType_p,   // IN: event type (enum)
-    tEplApiEventArg*        pEventArg_p,   // IN: event argument (union)
-    void GENERIC*           pUserArg_p);
+tEplKernel PUBLIC AppCbEvent(tEplApiEventType EventType_p,	// IN: event type (enum)
+			     tEplApiEventArg * pEventArg_p,	// IN: event argument (union)
+			     void GENERIC * pUserArg_p);
 
 tEplKernel PUBLIC AppCbSync(void);
 
-static int  __init  EplLinInit (void);
-static void __exit  EplLinExit (void);
+static int __init EplLinInit(void);
+static void __exit EplLinExit(void);
 
 //---------------------------------------------------------------------------
 //  Kernel Module specific Data Structures
@@ -216,11 +205,9 @@ static void __exit  EplLinExit (void);
 
 EXPORT_NO_SYMBOLS;
 
-
 //module_init(EplLinInit);
 //module_exit(EplLinExit);
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -244,227 +231,232 @@ EXPORT_NO_SYMBOLS;
 // State:
 //
 //---------------------------------------------------------------------------
-static  int  __init  EplLinInit (void)
+static int __init EplLinInit(void)
 {
-tEplKernel          EplRet;
-int                 iRet;
-static tEplApiInitParam EplApiInitParam = {0};
-char*               sHostname = HOSTNAME;
-char*               argv[4], *envp[3];
-char                sBuffer[16];
-unsigned int        uiVarEntries;
-tEplObdSize         ObdSize;
-
-    atomic_set(&AtomicShutdown_g, TRUE);
-
-    // get node ID from insmod command line
-    EplApiInitParam.m_uiNodeId = uiNodeId_g;
-
-    if (EplApiInitParam.m_uiNodeId == EPL_C_ADR_INVALID)
-    {   // invalid node ID set
-        // set default node ID
-        EplApiInitParam.m_uiNodeId = NODEID;
-    }
-
-    uiNodeId_g = EplApiInitParam.m_uiNodeId;
-
-    // calculate IP address
-    EplApiInitParam.m_dwIpAddress = (0xFFFFFF00 & IP_ADDR) | EplApiInitParam.m_uiNodeId;
-
-    EplApiInitParam.m_fAsyncOnly = FALSE;
-
-    EplApiInitParam.m_uiSizeOfStruct = sizeof (EplApiInitParam);
-    EPL_MEMCPY(EplApiInitParam.m_abMacAddress, abMacAddr, sizeof (EplApiInitParam.m_abMacAddress));
+	tEplKernel EplRet;
+	int iRet;
+	static tEplApiInitParam EplApiInitParam = { 0 };
+	char *sHostname = HOSTNAME;
+	char *argv[4], *envp[3];
+	char sBuffer[16];
+	unsigned int uiVarEntries;
+	tEplObdSize ObdSize;
+
+	atomic_set(&AtomicShutdown_g, TRUE);
+
+	// get node ID from insmod command line
+	EplApiInitParam.m_uiNodeId = uiNodeId_g;
+
+	if (EplApiInitParam.m_uiNodeId == EPL_C_ADR_INVALID) {	// invalid node ID set
+		// set default node ID
+		EplApiInitParam.m_uiNodeId = NODEID;
+	}
+
+	uiNodeId_g = EplApiInitParam.m_uiNodeId;
+
+	// calculate IP address
+	EplApiInitParam.m_dwIpAddress =
+	    (0xFFFFFF00 & IP_ADDR) | EplApiInitParam.m_uiNodeId;
+
+	EplApiInitParam.m_fAsyncOnly = FALSE;
+
+	EplApiInitParam.m_uiSizeOfStruct = sizeof(EplApiInitParam);
+	EPL_MEMCPY(EplApiInitParam.m_abMacAddress, abMacAddr,
+		   sizeof(EplApiInitParam.m_abMacAddress));
 //    EplApiInitParam.m_abMacAddress[5] = (BYTE) EplApiInitParam.m_uiNodeId;
-    EplApiInitParam.m_dwFeatureFlags = -1;
-    EplApiInitParam.m_dwCycleLen = uiCycleLen_g;     // required for error detection
-    EplApiInitParam.m_uiIsochrTxMaxPayload = 100; // const
-    EplApiInitParam.m_uiIsochrRxMaxPayload = 100; // const
-    EplApiInitParam.m_dwPresMaxLatency = 50000;  // const; only required for IdentRes
-    EplApiInitParam.m_uiPreqActPayloadLimit = 36; // required for initialisation (+28 bytes)
-    EplApiInitParam.m_uiPresActPayloadLimit = 36; // required for initialisation of Pres frame (+28 bytes)
-    EplApiInitParam.m_dwAsndMaxLatency = 150000;   // const; only required for IdentRes
-    EplApiInitParam.m_uiMultiplCycleCnt = 0;  // required for error detection
-    EplApiInitParam.m_uiAsyncMtu = 1500;         // required to set up max frame size
-    EplApiInitParam.m_uiPrescaler = 2;         // required for sync
-    EplApiInitParam.m_dwLossOfFrameTolerance = 500000;
-    EplApiInitParam.m_dwAsyncSlotTimeout = 3000000;
-    EplApiInitParam.m_dwWaitSocPreq = 150000;
-    EplApiInitParam.m_dwDeviceType = -1;              // NMT_DeviceType_U32
-    EplApiInitParam.m_dwVendorId = -1;                // NMT_IdentityObject_REC.VendorId_U32
-    EplApiInitParam.m_dwProductCode = -1;             // NMT_IdentityObject_REC.ProductCode_U32
-    EplApiInitParam.m_dwRevisionNumber = -1;          // NMT_IdentityObject_REC.RevisionNo_U32
-    EplApiInitParam.m_dwSerialNumber = -1;            // NMT_IdentityObject_REC.SerialNo_U32
-    EplApiInitParam.m_dwSubnetMask = SUBNET_MASK;
-    EplApiInitParam.m_dwDefaultGateway = 0;
-    EPL_MEMCPY(EplApiInitParam.m_sHostname, sHostname, sizeof(EplApiInitParam.m_sHostname));
-
-    // currently unset parameters left at default value 0
-    //EplApiInitParam.m_qwVendorSpecificExt1;
-    //EplApiInitParam.m_dwVerifyConfigurationDate; // CFM_VerifyConfiguration_REC.ConfDate_U32
-    //EplApiInitParam.m_dwVerifyConfigurationTime; // CFM_VerifyConfiguration_REC.ConfTime_U32
-    //EplApiInitParam.m_dwApplicationSwDate;       // PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
-    //EplApiInitParam.m_dwApplicationSwTime;       // PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
-    //EplApiInitParam.m_abVendorSpecificExt2[48];
-
-    // set callback functions
-    EplApiInitParam.m_pfnCbEvent = AppCbEvent;
-    EplApiInitParam.m_pfnCbSync = AppCbSync;
-
-
-    printk("\n\n Hello, I'm a simple POWERLINK node running as %s!\n  (build: %s / %s)\n\n",
-            (uiNodeId_g == EPL_C_ADR_MN_DEF_NODE_ID ?
-                "Managing Node" : "Controlled Node"),
-            __DATE__, __TIME__);
-
-    // initialize the Linux a wait queue for shutdown of this module
-    init_waitqueue_head(&WaitQueueShutdown_g);
-
-    // initialize the procfs device
-    EplRet = EplLinProcInit();
-    if (EplRet != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // initialize POWERLINK stack
-    EplRet = EplApiInitialize(&EplApiInitParam);
-    if(EplRet != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // link process variables used by CN to object dictionary
-    ObdSize = sizeof(bVarIn1_l);
-    uiVarEntries = 1;
-    EplRet = EplApiLinkObject(0x6000, &bVarIn1_l, &uiVarEntries, &ObdSize, 0x01);
-    if (EplRet != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    ObdSize = sizeof(bVarOut1_l);
-    uiVarEntries = 1;
-    EplRet = EplApiLinkObject(0x6200, &bVarOut1_l, &uiVarEntries, &ObdSize, 0x01);
-    if (EplRet != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // link process variables used by MN to object dictionary
+	EplApiInitParam.m_dwFeatureFlags = -1;
+	EplApiInitParam.m_dwCycleLen = uiCycleLen_g;	// required for error detection
+	EplApiInitParam.m_uiIsochrTxMaxPayload = 100;	// const
+	EplApiInitParam.m_uiIsochrRxMaxPayload = 100;	// const
+	EplApiInitParam.m_dwPresMaxLatency = 50000;	// const; only required for IdentRes
+	EplApiInitParam.m_uiPreqActPayloadLimit = 36;	// required for initialisation (+28 bytes)
+	EplApiInitParam.m_uiPresActPayloadLimit = 36;	// required for initialisation of Pres frame (+28 bytes)
+	EplApiInitParam.m_dwAsndMaxLatency = 150000;	// const; only required for IdentRes
+	EplApiInitParam.m_uiMultiplCycleCnt = 0;	// required for error detection
+	EplApiInitParam.m_uiAsyncMtu = 1500;	// required to set up max frame size
+	EplApiInitParam.m_uiPrescaler = 2;	// required for sync
+	EplApiInitParam.m_dwLossOfFrameTolerance = 500000;
+	EplApiInitParam.m_dwAsyncSlotTimeout = 3000000;
+	EplApiInitParam.m_dwWaitSocPreq = 150000;
+	EplApiInitParam.m_dwDeviceType = -1;	// NMT_DeviceType_U32
+	EplApiInitParam.m_dwVendorId = -1;	// NMT_IdentityObject_REC.VendorId_U32
+	EplApiInitParam.m_dwProductCode = -1;	// NMT_IdentityObject_REC.ProductCode_U32
+	EplApiInitParam.m_dwRevisionNumber = -1;	// NMT_IdentityObject_REC.RevisionNo_U32
+	EplApiInitParam.m_dwSerialNumber = -1;	// NMT_IdentityObject_REC.SerialNo_U32
+	EplApiInitParam.m_dwSubnetMask = SUBNET_MASK;
+	EplApiInitParam.m_dwDefaultGateway = 0;
+	EPL_MEMCPY(EplApiInitParam.m_sHostname, sHostname,
+		   sizeof(EplApiInitParam.m_sHostname));
+
+	// currently unset parameters left at default value 0
+	//EplApiInitParam.m_qwVendorSpecificExt1;
+	//EplApiInitParam.m_dwVerifyConfigurationDate; // CFM_VerifyConfiguration_REC.ConfDate_U32
+	//EplApiInitParam.m_dwVerifyConfigurationTime; // CFM_VerifyConfiguration_REC.ConfTime_U32
+	//EplApiInitParam.m_dwApplicationSwDate;       // PDL_LocVerApplSw_REC.ApplSwDate_U32 on programmable device or date portion of NMT_ManufactSwVers_VS on non-programmable device
+	//EplApiInitParam.m_dwApplicationSwTime;       // PDL_LocVerApplSw_REC.ApplSwTime_U32 on programmable device or time portion of NMT_ManufactSwVers_VS on non-programmable device
+	//EplApiInitParam.m_abVendorSpecificExt2[48];
+
+	// set callback functions
+	EplApiInitParam.m_pfnCbEvent = AppCbEvent;
+	EplApiInitParam.m_pfnCbSync = AppCbSync;
+
+	printk
+	    ("\n\n Hello, I'm a simple POWERLINK node running as %s!\n  (build: %s / %s)\n\n",
+	     (uiNodeId_g ==
+	      EPL_C_ADR_MN_DEF_NODE_ID ? "Managing Node" : "Controlled Node"),
+	     __DATE__, __TIME__);
+
+	// initialize the Linux a wait queue for shutdown of this module
+	init_waitqueue_head(&WaitQueueShutdown_g);
+
+	// initialize the procfs device
+	EplRet = EplLinProcInit();
+	if (EplRet != kEplSuccessful) {
+		goto Exit;
+	}
+	// initialize POWERLINK stack
+	EplRet = EplApiInitialize(&EplApiInitParam);
+	if (EplRet != kEplSuccessful) {
+		goto Exit;
+	}
+	// link process variables used by CN to object dictionary
+	ObdSize = sizeof(bVarIn1_l);
+	uiVarEntries = 1;
+	EplRet =
+	    EplApiLinkObject(0x6000, &bVarIn1_l, &uiVarEntries, &ObdSize, 0x01);
+	if (EplRet != kEplSuccessful) {
+		goto Exit;
+	}
+
+	ObdSize = sizeof(bVarOut1_l);
+	uiVarEntries = 1;
+	EplRet =
+	    EplApiLinkObject(0x6200, &bVarOut1_l, &uiVarEntries, &ObdSize,
+			     0x01);
+	if (EplRet != kEplSuccessful) {
+		goto Exit;
+	}
+	// link process variables used by MN to object dictionary
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    ObdSize = sizeof(bLedsRow1_l);
-    uiVarEntries = 1;
-    EplRet = EplApiLinkObject(0x2000, &bLedsRow1_l, &uiVarEntries, &ObdSize, 0x01);
-    if (EplRet != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    ObdSize = sizeof(bLedsRow2_l);
-    uiVarEntries = 1;
-    EplRet = EplApiLinkObject(0x2000, &bLedsRow2_l, &uiVarEntries, &ObdSize, 0x02);
-    if (EplRet != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    ObdSize = sizeof(bSpeedSelect_l);
-    uiVarEntries = 1;
-    EplRet = EplApiLinkObject(0x2000, &bSpeedSelect_l, &uiVarEntries, &ObdSize, 0x03);
-    if (EplRet != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    ObdSize = sizeof(bSpeedSelectOld_l);
-    uiVarEntries = 1;
-    EplRet = EplApiLinkObject(0x2000, &bSpeedSelectOld_l, &uiVarEntries, &ObdSize, 0x04);
-    if (EplRet != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    ObdSize = sizeof(abSelect_l[0]);
-    uiVarEntries = sizeof(abSelect_l);
-    EplRet = EplApiLinkObject(0x2200, &abSelect_l[0], &uiVarEntries, &ObdSize, 0x01);
-    if (EplRet != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	ObdSize = sizeof(bLedsRow1_l);
+	uiVarEntries = 1;
+	EplRet =
+	    EplApiLinkObject(0x2000, &bLedsRow1_l, &uiVarEntries, &ObdSize,
+			     0x01);
+	if (EplRet != kEplSuccessful) {
+		goto Exit;
+	}
+
+	ObdSize = sizeof(bLedsRow2_l);
+	uiVarEntries = 1;
+	EplRet =
+	    EplApiLinkObject(0x2000, &bLedsRow2_l, &uiVarEntries, &ObdSize,
+			     0x02);
+	if (EplRet != kEplSuccessful) {
+		goto Exit;
+	}
+
+	ObdSize = sizeof(bSpeedSelect_l);
+	uiVarEntries = 1;
+	EplRet =
+	    EplApiLinkObject(0x2000, &bSpeedSelect_l, &uiVarEntries, &ObdSize,
+			     0x03);
+	if (EplRet != kEplSuccessful) {
+		goto Exit;
+	}
+
+	ObdSize = sizeof(bSpeedSelectOld_l);
+	uiVarEntries = 1;
+	EplRet =
+	    EplApiLinkObject(0x2000, &bSpeedSelectOld_l, &uiVarEntries,
+			     &ObdSize, 0x04);
+	if (EplRet != kEplSuccessful) {
+		goto Exit;
+	}
+
+	ObdSize = sizeof(abSelect_l[0]);
+	uiVarEntries = sizeof(abSelect_l);
+	EplRet =
+	    EplApiLinkObject(0x2200, &abSelect_l[0], &uiVarEntries, &ObdSize,
+			     0x01);
+	if (EplRet != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-    // link a DOMAIN to object 0x6100, but do not exit, if it is missing
-    ObdSize = sizeof(abDomain_l);
-    uiVarEntries = 1;
-    EplRet = EplApiLinkObject(0x6100, &abDomain_l, &uiVarEntries, &ObdSize, 0x00);
-    if (EplRet != kEplSuccessful)
-    {
-        printk("EplApiLinkObject(0x6100): returns 0x%X\n", EplRet);
-    }
-
-    // reset old process variables
-    bVarOut1Old_l = 0;
-    bSpeedSelectOld_l = 0;
-    dwMode_l = APP_DEFAULT_MODE;
-    iMaxCycleCount_l = DEFAULT_MAX_CYCLE_COUNT;
-
-
-    // configure IP address of virtual network interface
-    // for TCP/IP communication over the POWERLINK network
-    sprintf(sBuffer, "%lu.%lu.%lu.%lu", (EplApiInitParam.m_dwIpAddress >> 24), ((EplApiInitParam.m_dwIpAddress >> 16) & 0xFF), ((EplApiInitParam.m_dwIpAddress >> 8) & 0xFF), (EplApiInitParam.m_dwIpAddress & 0xFF));
-    /* set up a minimal environment */
-    iRet = 0;
-    envp[iRet++] = "HOME=/";
-    envp[iRet++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
-    envp[iRet] = NULL;
-
-    /* set up the argument list */
-    iRet = 0;
-    argv[iRet++] = "/sbin/ifconfig";
-    argv[iRet++] = IF_ETH;
-    argv[iRet++] = sBuffer;
-    argv[iRet] = NULL;
-
-    /* call ifconfig to configure the virtual network interface */
-    iRet = call_usermodehelper(argv[0], argv, envp, 1);
-    printk("ifconfig %s %s returned %d\n", argv[1], argv[2], iRet);
-
-    // start the NMT state machine
-    EplRet = EplApiExecNmtCommand(kEplNmtEventSwReset);
-    atomic_set(&AtomicShutdown_g, FALSE);
-
-Exit:
-    printk("EplLinInit(): returns 0x%X\n", EplRet);
-    return EplRet;
+	// link a DOMAIN to object 0x6100, but do not exit, if it is missing
+	ObdSize = sizeof(abDomain_l);
+	uiVarEntries = 1;
+	EplRet =
+	    EplApiLinkObject(0x6100, &abDomain_l, &uiVarEntries, &ObdSize,
+			     0x00);
+	if (EplRet != kEplSuccessful) {
+		printk("EplApiLinkObject(0x6100): returns 0x%X\n", EplRet);
+	}
+	// reset old process variables
+	bVarOut1Old_l = 0;
+	bSpeedSelectOld_l = 0;
+	dwMode_l = APP_DEFAULT_MODE;
+	iMaxCycleCount_l = DEFAULT_MAX_CYCLE_COUNT;
+
+	// configure IP address of virtual network interface
+	// for TCP/IP communication over the POWERLINK network
+	sprintf(sBuffer, "%lu.%lu.%lu.%lu",
+		(EplApiInitParam.m_dwIpAddress >> 24),
+		((EplApiInitParam.m_dwIpAddress >> 16) & 0xFF),
+		((EplApiInitParam.m_dwIpAddress >> 8) & 0xFF),
+		(EplApiInitParam.m_dwIpAddress & 0xFF));
+	/* set up a minimal environment */
+	iRet = 0;
+	envp[iRet++] = "HOME=/";
+	envp[iRet++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	envp[iRet] = NULL;
+
+	/* set up the argument list */
+	iRet = 0;
+	argv[iRet++] = "/sbin/ifconfig";
+	argv[iRet++] = IF_ETH;
+	argv[iRet++] = sBuffer;
+	argv[iRet] = NULL;
+
+	/* call ifconfig to configure the virtual network interface */
+	iRet = call_usermodehelper(argv[0], argv, envp, 1);
+	printk("ifconfig %s %s returned %d\n", argv[1], argv[2], iRet);
+
+	// start the NMT state machine
+	EplRet = EplApiExecNmtCommand(kEplNmtEventSwReset);
+	atomic_set(&AtomicShutdown_g, FALSE);
+
+      Exit:
+	printk("EplLinInit(): returns 0x%X\n", EplRet);
+	return EplRet;
 }
 
-static  void  __exit  EplLinExit (void)
+static void __exit EplLinExit(void)
 {
-tEplKernel          EplRet;
+	tEplKernel EplRet;
 
-    // halt the NMT state machine
-    // so the processing of POWERLINK frames stops
-    EplRet = EplApiExecNmtCommand(kEplNmtEventSwitchOff);
-
-    // wait until NMT state machine is shut down
-    wait_event_interruptible(WaitQueueShutdown_g,
-                                    (atomic_read(&AtomicShutdown_g) == TRUE));
+	// halt the NMT state machine
+	// so the processing of POWERLINK frames stops
+	EplRet = EplApiExecNmtCommand(kEplNmtEventSwitchOff);
+
+	// wait until NMT state machine is shut down
+	wait_event_interruptible(WaitQueueShutdown_g,
+				 (atomic_read(&AtomicShutdown_g) == TRUE));
 /*    if ((iErr != 0) || (atomic_read(&AtomicShutdown_g) == EVENT_STATE_IOCTL))
     {   // waiting was interrupted by signal or application called wrong function
         EplRet = kEplShutdown;
     }*/
-    // delete instance for all modules
-    EplRet = EplApiShutdown();
-    printk("EplApiShutdown():  0x%X\n", EplRet);
-
-    // deinitialize proc fs
-    EplRet = EplLinProcFree();
-    printk("EplLinProcFree():        0x%X\n", EplRet);
+	// delete instance for all modules
+	EplRet = EplApiShutdown();
+	printk("EplApiShutdown():  0x%X\n", EplRet);
+
+	// deinitialize proc fs
+	EplRet = EplLinProcFree();
+	printk("EplLinProcFree():        0x%X\n", EplRet);
 
 }
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -492,106 +484,150 @@ tEplKernel          EplRet;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC AppCbEvent(
-    tEplApiEventType        EventType_p,   // IN: event type (enum)
-    tEplApiEventArg*        pEventArg_p,   // IN: event argument (union)
-    void GENERIC*           pUserArg_p)
+tEplKernel PUBLIC AppCbEvent(tEplApiEventType EventType_p,	// IN: event type (enum)
+			     tEplApiEventArg * pEventArg_p,	// IN: event argument (union)
+			     void GENERIC * pUserArg_p)
 {
-tEplKernel          EplRet = kEplSuccessful;
-
-    // check if NMT_GS_OFF is reached
-    switch (EventType_p)
-    {
-        case kEplApiEventNmtStateChange:
-        {
-            switch (pEventArg_p->m_NmtStateChange.m_NewNmtState)
-            {
-                case kEplNmtGsOff:
-                {   // NMT state machine was shut down,
-                    // because of user signal (CTRL-C) or critical EPL stack error
-                    // -> also shut down EplApiProcess() and main()
-                    EplRet = kEplShutdown;
-
-                    printk("AppCbEvent(kEplNmtGsOff) originating event = 0x%X\n", pEventArg_p->m_NmtStateChange.m_NmtEvent);
-
-                    // wake up EplLinExit()
-                    atomic_set(&AtomicShutdown_g, TRUE);
-                    wake_up_interruptible(&WaitQueueShutdown_g);
-                    break;
-                }
-
-                case kEplNmtGsResetCommunication:
-                {
-                DWORD   dwBuffer;
+	tEplKernel EplRet = kEplSuccessful;
 
-                    // configure OD for MN in state ResetComm after reseting the OD
-                    // TODO: setup your own network configuration here
-                    dwBuffer = (EPL_NODEASSIGN_NODE_IS_CN | EPL_NODEASSIGN_NODE_EXISTS);    // 0x00000003L
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0x01, &dwBuffer, 4);
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0x02, &dwBuffer, 4);
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0x03, &dwBuffer, 4);
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0x04, &dwBuffer, 4);
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0x05, &dwBuffer, 4);
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0x06, &dwBuffer, 4);
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0x07, &dwBuffer, 4);
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0x08, &dwBuffer, 4);
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0x20, &dwBuffer, 4);
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0xFE, &dwBuffer, 4);
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0x6E, &dwBuffer, 4);
+	// check if NMT_GS_OFF is reached
+	switch (EventType_p) {
+	case kEplApiEventNmtStateChange:
+		{
+			switch (pEventArg_p->m_NmtStateChange.m_NewNmtState) {
+			case kEplNmtGsOff:
+				{	// NMT state machine was shut down,
+					// because of user signal (CTRL-C) or critical EPL stack error
+					// -> also shut down EplApiProcess() and main()
+					EplRet = kEplShutdown;
+
+					printk
+					    ("AppCbEvent(kEplNmtGsOff) originating event = 0x%X\n",
+					     pEventArg_p->m_NmtStateChange.
+					     m_NmtEvent);
+
+					// wake up EplLinExit()
+					atomic_set(&AtomicShutdown_g, TRUE);
+					wake_up_interruptible
+					    (&WaitQueueShutdown_g);
+					break;
+				}
+
+			case kEplNmtGsResetCommunication:
+				{
+					DWORD dwBuffer;
+
+					// configure OD for MN in state ResetComm after reseting the OD
+					// TODO: setup your own network configuration here
+					dwBuffer = (EPL_NODEASSIGN_NODE_IS_CN | EPL_NODEASSIGN_NODE_EXISTS);	// 0x00000003L
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0x01,
+								   &dwBuffer,
+								   4);
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0x02,
+								   &dwBuffer,
+								   4);
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0x03,
+								   &dwBuffer,
+								   4);
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0x04,
+								   &dwBuffer,
+								   4);
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0x05,
+								   &dwBuffer,
+								   4);
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0x06,
+								   &dwBuffer,
+								   4);
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0x07,
+								   &dwBuffer,
+								   4);
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0x08,
+								   &dwBuffer,
+								   4);
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0x20,
+								   &dwBuffer,
+								   4);
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0xFE,
+								   &dwBuffer,
+								   4);
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0x6E,
+								   &dwBuffer,
+								   4);
 
 //                    dwBuffer |= EPL_NODEASSIGN_MANDATORY_CN;    // 0x0000000BL
 //                    EplRet = EplApiWriteLocalObject(0x1F81, 0x6E, &dwBuffer, 4);
-                    dwBuffer = (EPL_NODEASSIGN_MN_PRES | EPL_NODEASSIGN_NODE_EXISTS);       // 0x00010001L
-                    EplRet = EplApiWriteLocalObject(0x1F81, 0xF0, &dwBuffer, 4);
-
-                    // continue
-                }
-
-                case kEplNmtGsResetConfiguration:
-                {
-                unsigned int uiSize;
-
-                    // fetch object 0x1006 NMT_CycleLen_U32 from local OD (in little endian byte order)
-                    // for configuration of remote CN
-                    uiSize = 4;
-                    EplRet = EplApiReadObject(NULL, 0, 0x1006, 0x00, &dw_le_CycleLen_g, &uiSize, kEplSdoTypeAsnd, NULL);
-                    if (EplRet != kEplSuccessful)
-                    {   // local OD access failed
-                        break;
-                    }
-
-                    // continue
-                }
-
-                case kEplNmtMsPreOperational1:
-                {
-                    printk("AppCbEvent(0x%X) originating event = 0x%X\n",
-                           pEventArg_p->m_NmtStateChange.m_NewNmtState,
-                           pEventArg_p->m_NmtStateChange.m_NmtEvent);
-
-                    // continue
-                }
-
-                case kEplNmtGsInitialising:
-                case kEplNmtGsResetApplication:
-                case kEplNmtMsNotActive:
-                case kEplNmtCsNotActive:
-                case kEplNmtCsPreOperational1:
-                {
-                    break;
-                }
-
-                case kEplNmtCsOperational:
-                case kEplNmtMsOperational:
-                {
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-            }
+					dwBuffer = (EPL_NODEASSIGN_MN_PRES | EPL_NODEASSIGN_NODE_EXISTS);	// 0x00010001L
+					EplRet =
+					    EplApiWriteLocalObject(0x1F81, 0xF0,
+								   &dwBuffer,
+								   4);
+
+					// continue
+				}
+
+			case kEplNmtGsResetConfiguration:
+				{
+					unsigned int uiSize;
+
+					// fetch object 0x1006 NMT_CycleLen_U32 from local OD (in little endian byte order)
+					// for configuration of remote CN
+					uiSize = 4;
+					EplRet =
+					    EplApiReadObject(NULL, 0, 0x1006,
+							     0x00,
+							     &dw_le_CycleLen_g,
+							     &uiSize,
+							     kEplSdoTypeAsnd,
+							     NULL);
+					if (EplRet != kEplSuccessful) {	// local OD access failed
+						break;
+					}
+					// continue
+				}
+
+			case kEplNmtMsPreOperational1:
+				{
+					printk
+					    ("AppCbEvent(0x%X) originating event = 0x%X\n",
+					     pEventArg_p->m_NmtStateChange.
+					     m_NewNmtState,
+					     pEventArg_p->m_NmtStateChange.
+					     m_NmtEvent);
+
+					// continue
+				}
+
+			case kEplNmtGsInitialising:
+			case kEplNmtGsResetApplication:
+			case kEplNmtMsNotActive:
+			case kEplNmtCsNotActive:
+			case kEplNmtCsPreOperational1:
+				{
+					break;
+				}
+
+			case kEplNmtCsOperational:
+			case kEplNmtMsOperational:
+				{
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+			}
 
 /*
             switch (pEventArg_p->m_NmtStateChange.m_NmtEvent)
@@ -615,119 +651,138 @@ tEplKernel          EplRet = kEplSuccess
                 }
             }
 */
-            break;
-        }
+			break;
+		}
 
-        case kEplApiEventCriticalError:
-        case kEplApiEventWarning:
-        {   // error or warning occured within the stack or the application
-            // on error the API layer stops the NMT state machine
-
-            printk("AppCbEvent(Err/Warn): Source=%02X EplError=0x%03X", pEventArg_p->m_InternalError.m_EventSource, pEventArg_p->m_InternalError.m_EplError);
-            // check additional argument
-            switch (pEventArg_p->m_InternalError.m_EventSource)
-            {
-                case kEplEventSourceEventk:
-                case kEplEventSourceEventu:
-                {   // error occured within event processing
-                    // either in kernel or in user part
-                    printk(" OrgSource=%02X\n", pEventArg_p->m_InternalError.m_Arg.m_EventSource);
-                    break;
-                }
+	case kEplApiEventCriticalError:
+	case kEplApiEventWarning:
+		{		// error or warning occured within the stack or the application
+			// on error the API layer stops the NMT state machine
+
+			printk
+			    ("AppCbEvent(Err/Warn): Source=%02X EplError=0x%03X",
+			     pEventArg_p->m_InternalError.m_EventSource,
+			     pEventArg_p->m_InternalError.m_EplError);
+			// check additional argument
+			switch (pEventArg_p->m_InternalError.m_EventSource) {
+			case kEplEventSourceEventk:
+			case kEplEventSourceEventu:
+				{	// error occured within event processing
+					// either in kernel or in user part
+					printk(" OrgSource=%02X\n",
+					       pEventArg_p->m_InternalError.
+					       m_Arg.m_EventSource);
+					break;
+				}
+
+			case kEplEventSourceDllk:
+				{	// error occured within the data link layer (e.g. interrupt processing)
+					// the DWORD argument contains the DLL state and the NMT event
+					printk(" val=%lX\n",
+					       pEventArg_p->m_InternalError.
+					       m_Arg.m_dwArg);
+					break;
+				}
+
+			default:
+				{
+					printk("\n");
+					break;
+				}
+			}
+			break;
+		}
 
-                case kEplEventSourceDllk:
-                {   // error occured within the data link layer (e.g. interrupt processing)
-                    // the DWORD argument contains the DLL state and the NMT event
-                    printk(" val=%lX\n", pEventArg_p->m_InternalError.m_Arg.m_dwArg);
-                    break;
-                }
-
-                default:
-                {
-                    printk("\n");
-                    break;
-                }
-            }
-            break;
-        }
-
-        case kEplApiEventNode:
-        {
+	case kEplApiEventNode:
+		{
 //            printk("AppCbEvent(Node): Source=%02X EplError=0x%03X", pEventArg_p->m_InternalError.m_EventSource, pEventArg_p->m_InternalError.m_EplError);
-            // check additional argument
-            switch (pEventArg_p->m_Node.m_NodeEvent)
-            {
-                case kEplNmtNodeEventCheckConf:
-                {
-                tEplSdoComConHdl SdoComConHdl;
-                    // update object 0x1006 on CN
-                    EplRet = EplApiWriteObject(&SdoComConHdl, pEventArg_p->m_Node.m_uiNodeId, 0x1006, 0x00, &dw_le_CycleLen_g, 4, kEplSdoTypeAsnd, NULL);
-                    if (EplRet == kEplApiTaskDeferred)
-                    {   // SDO transfer started
-                        EplRet = kEplReject;
-                    }
-                    else if (EplRet == kEplSuccessful)
-                    {   // local OD access (should not occur)
-                        printk("AppCbEvent(Node) write to local OD\n");
-                    }
-                    else
-                    {   // error occured
-                        TGT_DBG_SIGNAL_TRACE_POINT(1);
-
-                        EplRet = EplApiFreeSdoChannel(SdoComConHdl);
-                        SdoComConHdl = 0;
-
-                        EplRet = EplApiWriteObject(&SdoComConHdl, pEventArg_p->m_Node.m_uiNodeId, 0x1006, 0x00, &dw_le_CycleLen_g, 4, kEplSdoTypeAsnd, NULL);
-                        if (EplRet == kEplApiTaskDeferred)
-                        {   // SDO transfer started
-                            EplRet = kEplReject;
-                        }
-                        else
-                        {
-                            printk("AppCbEvent(Node): EplApiWriteObject() returned 0x%02X\n", EplRet);
-                        }
-                    }
-
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-            }
-            break;
-        }
-
-        case kEplApiEventSdo:
-        {   // SDO transfer finished
-            EplRet = EplApiFreeSdoChannel(pEventArg_p->m_Sdo.m_SdoComConHdl);
-            if (EplRet != kEplSuccessful)
-            {
-                break;
-            }
+			// check additional argument
+			switch (pEventArg_p->m_Node.m_NodeEvent) {
+			case kEplNmtNodeEventCheckConf:
+				{
+					tEplSdoComConHdl SdoComConHdl;
+					// update object 0x1006 on CN
+					EplRet =
+					    EplApiWriteObject(&SdoComConHdl,
+							      pEventArg_p->
+							      m_Node.m_uiNodeId,
+							      0x1006, 0x00,
+							      &dw_le_CycleLen_g,
+							      4,
+							      kEplSdoTypeAsnd,
+							      NULL);
+					if (EplRet == kEplApiTaskDeferred) {	// SDO transfer started
+						EplRet = kEplReject;
+					} else if (EplRet == kEplSuccessful) {	// local OD access (should not occur)
+						printk
+						    ("AppCbEvent(Node) write to local OD\n");
+					} else {	// error occured
+						TGT_DBG_SIGNAL_TRACE_POINT(1);
+
+						EplRet =
+						    EplApiFreeSdoChannel
+						    (SdoComConHdl);
+						SdoComConHdl = 0;
+
+						EplRet =
+						    EplApiWriteObject
+						    (&SdoComConHdl,
+						     pEventArg_p->m_Node.
+						     m_uiNodeId, 0x1006, 0x00,
+						     &dw_le_CycleLen_g, 4,
+						     kEplSdoTypeAsnd, NULL);
+						if (EplRet == kEplApiTaskDeferred) {	// SDO transfer started
+							EplRet = kEplReject;
+						} else {
+							printk
+							    ("AppCbEvent(Node): EplApiWriteObject() returned 0x%02X\n",
+							     EplRet);
+						}
+					}
+
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+			}
+			break;
+		}
+
+	case kEplApiEventSdo:
+		{		// SDO transfer finished
+			EplRet =
+			    EplApiFreeSdoChannel(pEventArg_p->m_Sdo.
+						 m_SdoComConHdl);
+			if (EplRet != kEplSuccessful) {
+				break;
+			}
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-            if (pEventArg_p->m_Sdo.m_SdoComConState == kEplSdoComTransferFinished)
-            {   // continue boot-up of CN with NMT command Reset Configuration
-                EplRet = EplApiMnTriggerStateChange(pEventArg_p->m_Sdo.m_uiNodeId, kEplNmtNodeCommandConfReset);
-            }
-            else
-            {   // indicate configuration error CN
-                EplRet = EplApiMnTriggerStateChange(pEventArg_p->m_Sdo.m_uiNodeId, kEplNmtNodeCommandConfErr);
-            }
+			if (pEventArg_p->m_Sdo.m_SdoComConState == kEplSdoComTransferFinished) {	// continue boot-up of CN with NMT command Reset Configuration
+				EplRet =
+				    EplApiMnTriggerStateChange(pEventArg_p->
+							       m_Sdo.m_uiNodeId,
+							       kEplNmtNodeCommandConfReset);
+			} else {	// indicate configuration error CN
+				EplRet =
+				    EplApiMnTriggerStateChange(pEventArg_p->
+							       m_Sdo.m_uiNodeId,
+							       kEplNmtNodeCommandConfErr);
+			}
 #endif
 
-            break;
-        }
+			break;
+		}
 
-        default:
-            break;
-    }
+	default:
+		break;
+	}
 
-    return EplRet;
+	return EplRet;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    AppCbSync
@@ -749,189 +804,158 @@ tEplKernel          EplRet = kEplSuccess
 
 tEplKernel PUBLIC AppCbSync(void)
 {
-tEplKernel          EplRet = kEplSuccessful;
+	tEplKernel EplRet = kEplSuccessful;
 
-    if (bVarOut1Old_l != bVarOut1_l)
-    {   // output variable has changed
-        bVarOut1Old_l = bVarOut1_l;
-        // set LEDs
+	if (bVarOut1Old_l != bVarOut1_l) {	// output variable has changed
+		bVarOut1Old_l = bVarOut1_l;
+		// set LEDs
 
 //        printk("bVarIn = 0x%02X bVarOut = 0x%02X\n", (WORD) bVarIn_l, (WORD) bVarOut_l);
-    }
-    if (uiNodeId_g != EPL_C_ADR_MN_DEF_NODE_ID)
-    {
-        bVarIn1_l++;
-    }
-
-    if (uiNodeId_g == EPL_C_ADR_MN_DEF_NODE_ID)
-    {   // we are the master and must run the control loop
-
-        // collect inputs from CNs and own input
-        bSpeedSelect_l = (bVarIn1_l | abSelect_l[0]) & 0x07;
-
-        bModeSelect_l = abSelect_l[1] | abSelect_l[2];
-
-        if ((bModeSelect_l & APP_MODE_MASK) != 0)
-        {
-            dwMode_l = bModeSelect_l & APP_MODE_MASK;
-        }
-
-        iCurCycleCount_l--;
-
-        if (iCurCycleCount_l <= 0)
-        {
-            if ((dwMode_l & 0x01) != 0)
-            {   // fill-up
-                if (iToggle)
-                {
-                    if ((dwLeds_l & APP_DOUBLE_LED_MASK) == 0x00)
-                    {
-                        dwLeds_l = 0x01;
-                    }
-                    else
-                    {
-                        dwLeds_l <<= 1;
-                        dwLeds_l++;
-                        if (dwLeds_l >= APP_DOUBLE_LED_MASK)
-                        {
-                            iToggle = 0;
-                        }
-                    }
-                }
-                else
-                {
-                    dwLeds_l <<= 1;
-                    if ((dwLeds_l & APP_DOUBLE_LED_MASK) == 0x00)
-                    {
-                        iToggle = 1;
-                    }
-                }
-                bLedsRow1_l = (unsigned char) (dwLeds_l & APP_LED_MASK);
-                bLedsRow2_l = (unsigned char) ((dwLeds_l >> APP_LED_COUNT) & APP_LED_MASK);
-            }
-
-            else if ((dwMode_l & 0x02) != 0)
-            {   // running light forward
-                dwLeds_l <<= 1;
-                if ((dwLeds_l > APP_DOUBLE_LED_MASK) || (dwLeds_l == 0x00000000L))
-                {
-                    dwLeds_l = 0x01;
-                }
-                bLedsRow1_l = (unsigned char) (dwLeds_l & APP_LED_MASK);
-                bLedsRow2_l = (unsigned char) ((dwLeds_l >> APP_LED_COUNT) & APP_LED_MASK);
-            }
-
-            else if ((dwMode_l & 0x04) != 0)
-            {   // running light backward
-                dwLeds_l >>= 1;
-                if ((dwLeds_l > APP_DOUBLE_LED_MASK) || (dwLeds_l == 0x00000000L))
-                {
-                    dwLeds_l = 1 << (APP_LED_COUNT * 2);
-                }
-                bLedsRow1_l = (unsigned char) (dwLeds_l & APP_LED_MASK);
-                bLedsRow2_l = (unsigned char) ((dwLeds_l >> APP_LED_COUNT) & APP_LED_MASK);
-            }
-
-            else if ((dwMode_l & 0x08) != 0)
-            {   // Knightrider
-                if (bLedsRow1_l == 0x00)
-                {
-                    bLedsRow1_l = 0x01;
-                    iToggle = 1;
-                }
-                else if (iToggle)
-                {
-                    bLedsRow1_l <<= 1;
-                    if ( bLedsRow1_l >= (1 << (APP_LED_COUNT - 1)) )
-                    {
-                        iToggle = 0;
-                    }
-                }
-                else
-                {
-                    bLedsRow1_l >>= 1;
-                    if( bLedsRow1_l <= 0x01 )
-                    {
-                        iToggle = 1;
-                    }
-                }
-                bLedsRow2_l = bLedsRow1_l;
-            }
-
-            else if ((dwMode_l & 0x10) != 0)
-            {   // Knightrider
-                if ((bLedsRow1_l == 0x00)
-                    || (bLedsRow2_l == 0x00)
-                    || ((bLedsRow2_l & ~APP_LED_MASK) != 0))
-                {
-                    bLedsRow1_l = 0x01;
-                    bLedsRow2_l = (1 << (APP_LED_COUNT - 1));
-                    iToggle = 1;
-                }
-                else if (iToggle)
-                {
-                    bLedsRow1_l <<= 1;
-                    bLedsRow2_l >>= 1;
-                    if ( bLedsRow1_l >= (1 << (APP_LED_COUNT - 1)) )
-                    {
-                        iToggle = 0;
-                    }
-                }
-                else
-                {
-                    bLedsRow1_l >>= 1;
-                    bLedsRow2_l <<= 1;
-                    if ( bLedsRow1_l <= 0x01 )
-                    {
-                        iToggle = 1;
-                    }
-                }
-            }
-
-            // set own output
-            bVarOut1_l = bLedsRow1_l;
+	}
+	if (uiNodeId_g != EPL_C_ADR_MN_DEF_NODE_ID) {
+		bVarIn1_l++;
+	}
+
+	if (uiNodeId_g == EPL_C_ADR_MN_DEF_NODE_ID) {	// we are the master and must run the control loop
+
+		// collect inputs from CNs and own input
+		bSpeedSelect_l = (bVarIn1_l | abSelect_l[0]) & 0x07;
+
+		bModeSelect_l = abSelect_l[1] | abSelect_l[2];
+
+		if ((bModeSelect_l & APP_MODE_MASK) != 0) {
+			dwMode_l = bModeSelect_l & APP_MODE_MASK;
+		}
+
+		iCurCycleCount_l--;
+
+		if (iCurCycleCount_l <= 0) {
+			if ((dwMode_l & 0x01) != 0) {	// fill-up
+				if (iToggle) {
+					if ((dwLeds_l & APP_DOUBLE_LED_MASK) ==
+					    0x00) {
+						dwLeds_l = 0x01;
+					} else {
+						dwLeds_l <<= 1;
+						dwLeds_l++;
+						if (dwLeds_l >=
+						    APP_DOUBLE_LED_MASK) {
+							iToggle = 0;
+						}
+					}
+				} else {
+					dwLeds_l <<= 1;
+					if ((dwLeds_l & APP_DOUBLE_LED_MASK) ==
+					    0x00) {
+						iToggle = 1;
+					}
+				}
+				bLedsRow1_l =
+				    (unsigned char)(dwLeds_l & APP_LED_MASK);
+				bLedsRow2_l =
+				    (unsigned char)((dwLeds_l >> APP_LED_COUNT)
+						    & APP_LED_MASK);
+			}
+
+			else if ((dwMode_l & 0x02) != 0) {	// running light forward
+				dwLeds_l <<= 1;
+				if ((dwLeds_l > APP_DOUBLE_LED_MASK)
+				    || (dwLeds_l == 0x00000000L)) {
+					dwLeds_l = 0x01;
+				}
+				bLedsRow1_l =
+				    (unsigned char)(dwLeds_l & APP_LED_MASK);
+				bLedsRow2_l =
+				    (unsigned char)((dwLeds_l >> APP_LED_COUNT)
+						    & APP_LED_MASK);
+			}
+
+			else if ((dwMode_l & 0x04) != 0) {	// running light backward
+				dwLeds_l >>= 1;
+				if ((dwLeds_l > APP_DOUBLE_LED_MASK)
+				    || (dwLeds_l == 0x00000000L)) {
+					dwLeds_l = 1 << (APP_LED_COUNT * 2);
+				}
+				bLedsRow1_l =
+				    (unsigned char)(dwLeds_l & APP_LED_MASK);
+				bLedsRow2_l =
+				    (unsigned char)((dwLeds_l >> APP_LED_COUNT)
+						    & APP_LED_MASK);
+			}
+
+			else if ((dwMode_l & 0x08) != 0) {	// Knightrider
+				if (bLedsRow1_l == 0x00) {
+					bLedsRow1_l = 0x01;
+					iToggle = 1;
+				} else if (iToggle) {
+					bLedsRow1_l <<= 1;
+					if (bLedsRow1_l >=
+					    (1 << (APP_LED_COUNT - 1))) {
+						iToggle = 0;
+					}
+				} else {
+					bLedsRow1_l >>= 1;
+					if (bLedsRow1_l <= 0x01) {
+						iToggle = 1;
+					}
+				}
+				bLedsRow2_l = bLedsRow1_l;
+			}
+
+			else if ((dwMode_l & 0x10) != 0) {	// Knightrider
+				if ((bLedsRow1_l == 0x00)
+				    || (bLedsRow2_l == 0x00)
+				    || ((bLedsRow2_l & ~APP_LED_MASK) != 0)) {
+					bLedsRow1_l = 0x01;
+					bLedsRow2_l =
+					    (1 << (APP_LED_COUNT - 1));
+					iToggle = 1;
+				} else if (iToggle) {
+					bLedsRow1_l <<= 1;
+					bLedsRow2_l >>= 1;
+					if (bLedsRow1_l >=
+					    (1 << (APP_LED_COUNT - 1))) {
+						iToggle = 0;
+					}
+				} else {
+					bLedsRow1_l >>= 1;
+					bLedsRow2_l <<= 1;
+					if (bLedsRow1_l <= 0x01) {
+						iToggle = 1;
+					}
+				}
+			}
+			// set own output
+			bVarOut1_l = bLedsRow1_l;
 //            bVarOut1_l = (bLedsRow1_l & 0x03) | (bLedsRow2_l << 2);
 
-            // restart cycle counter
-            iCurCycleCount_l = iMaxCycleCount_l;
-        }
-
-        if (bSpeedSelectOld_l == 0)
-        {
-            if ((bSpeedSelect_l & 0x01) != 0)
-            {
-                if (iMaxCycleCount_l < 200)
-                {
-                    iMaxCycleCount_l++;
-                }
-                bSpeedSelectOld_l = bSpeedSelect_l;
-            }
-            else if ((bSpeedSelect_l & 0x02) != 0)
-            {
-                if (iMaxCycleCount_l > 1)
-                {
-                    iMaxCycleCount_l--;
-                }
-                bSpeedSelectOld_l = bSpeedSelect_l;
-            }
-            else if ((bSpeedSelect_l & 0x04) != 0)
-            {
-                iMaxCycleCount_l = DEFAULT_MAX_CYCLE_COUNT;
-                bSpeedSelectOld_l = bSpeedSelect_l;
-            }
-        }
-        else if (bSpeedSelect_l == 0)
-        {
-            bSpeedSelectOld_l = 0;
-        }
-    }
+			// restart cycle counter
+			iCurCycleCount_l = iMaxCycleCount_l;
+		}
+
+		if (bSpeedSelectOld_l == 0) {
+			if ((bSpeedSelect_l & 0x01) != 0) {
+				if (iMaxCycleCount_l < 200) {
+					iMaxCycleCount_l++;
+				}
+				bSpeedSelectOld_l = bSpeedSelect_l;
+			} else if ((bSpeedSelect_l & 0x02) != 0) {
+				if (iMaxCycleCount_l > 1) {
+					iMaxCycleCount_l--;
+				}
+				bSpeedSelectOld_l = bSpeedSelect_l;
+			} else if ((bSpeedSelect_l & 0x04) != 0) {
+				iMaxCycleCount_l = DEFAULT_MAX_CYCLE_COUNT;
+				bSpeedSelectOld_l = bSpeedSelect_l;
+			}
+		} else if (bSpeedSelect_l == 0) {
+			bSpeedSelectOld_l = 0;
+		}
+	}
 
-    TGT_DBG_SIGNAL_TRACE_POINT(1);
+	TGT_DBG_SIGNAL_TRACE_POINT(1);
 
-    return EplRet;
+	return EplRet;
 }
 
-
-
 // EOF
-
--- a/drivers/staging/epl/Edrv8139.c
+++ b/drivers/staging/epl/Edrv8139.c
@@ -89,7 +89,6 @@
 #include <linux/sched.h>
 #include <linux/delay.h>
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -108,7 +107,6 @@
 // NMT requests / commands. The less the size of the buffer the less the
 // number of the buffer.
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
@@ -119,26 +117,25 @@
 
 #define EDRV_MAX_FRAME_SIZE     0x600
 
-#define EDRV_RX_BUFFER_SIZE     0x8610  // 32 kB + 16 Byte + 1,5 kB (WRAP is enabled)
-#define EDRV_RX_BUFFER_LENGTH   (EDRV_RX_BUFFER_SIZE & 0xF800)  // buffer size cut down to 2 kB alignment
+#define EDRV_RX_BUFFER_SIZE     0x8610	// 32 kB + 16 Byte + 1,5 kB (WRAP is enabled)
+#define EDRV_RX_BUFFER_LENGTH   (EDRV_RX_BUFFER_SIZE & 0xF800)	// buffer size cut down to 2 kB alignment
 
-#define EDRV_TX_BUFFER_SIZE     (EDRV_MAX_TX_BUFFERS * EDRV_MAX_FRAME_SIZE) // n * (MTU + 14 + 4)
+#define EDRV_TX_BUFFER_SIZE     (EDRV_MAX_TX_BUFFERS * EDRV_MAX_FRAME_SIZE)	// n * (MTU + 14 + 4)
 
 #define DRV_NAME                "epl"
 
-
-#define EDRV_REGW_INT_MASK      0x3C    // interrupt mask register
-#define EDRV_REGW_INT_STATUS    0x3E    // interrupt status register
-#define EDRV_REGW_INT_ROK       0x0001  // Receive OK interrupt
-#define EDRV_REGW_INT_RER       0x0002  // Receive error interrupt
-#define EDRV_REGW_INT_TOK       0x0004  // Transmit OK interrupt
-#define EDRV_REGW_INT_TER       0x0008  // Transmit error interrupt
-#define EDRV_REGW_INT_RXOVW     0x0010  // Rx buffer overflow interrupt
-#define EDRV_REGW_INT_PUN       0x0020  // Packet underrun/ link change interrupt
-#define EDRV_REGW_INT_FOVW      0x0040  // Rx FIFO overflow interrupt
-#define EDRV_REGW_INT_LENCHG    0x2000  // Cable length change interrupt
-#define EDRV_REGW_INT_TIMEOUT   0x4000  // Time out interrupt
-#define EDRV_REGW_INT_SERR      0x8000  // System error interrupt
+#define EDRV_REGW_INT_MASK      0x3C	// interrupt mask register
+#define EDRV_REGW_INT_STATUS    0x3E	// interrupt status register
+#define EDRV_REGW_INT_ROK       0x0001	// Receive OK interrupt
+#define EDRV_REGW_INT_RER       0x0002	// Receive error interrupt
+#define EDRV_REGW_INT_TOK       0x0004	// Transmit OK interrupt
+#define EDRV_REGW_INT_TER       0x0008	// Transmit error interrupt
+#define EDRV_REGW_INT_RXOVW     0x0010	// Rx buffer overflow interrupt
+#define EDRV_REGW_INT_PUN       0x0020	// Packet underrun/ link change interrupt
+#define EDRV_REGW_INT_FOVW      0x0040	// Rx FIFO overflow interrupt
+#define EDRV_REGW_INT_LENCHG    0x2000	// Cable length change interrupt
+#define EDRV_REGW_INT_TIMEOUT   0x4000	// Time out interrupt
+#define EDRV_REGW_INT_SERR      0x8000	// System error interrupt
 #define EDRV_REGW_INT_MASK_DEF  (EDRV_REGW_INT_ROK \
                                  | EDRV_REGW_INT_RER \
                                  | EDRV_REGW_INT_TOK \
@@ -147,88 +144,86 @@
                                  | EDRV_REGW_INT_FOVW \
                                  | EDRV_REGW_INT_PUN \
                                  | EDRV_REGW_INT_TIMEOUT \
-                                 | EDRV_REGW_INT_SERR)   // default interrupt mask
+                                 | EDRV_REGW_INT_SERR)	// default interrupt mask
 
-#define EDRV_REGB_COMMAND       0x37    // command register
+#define EDRV_REGB_COMMAND       0x37	// command register
 #define EDRV_REGB_COMMAND_RST   0x10
 #define EDRV_REGB_COMMAND_RE    0x08
 #define EDRV_REGB_COMMAND_TE    0x04
 #define EDRV_REGB_COMMAND_BUFE  0x01
 
-#define EDRV_REGB_CMD9346       0x50    // 93C46 command register
-#define EDRV_REGB_CMD9346_LOCK  0x00    // lock configuration registers
-#define EDRV_REGB_CMD9346_UNLOCK 0xC0   // unlock configuration registers
-
-#define EDRV_REGDW_RCR          0x44    // Rx configuration register
-#define EDRV_REGDW_RCR_NO_FTH   0x0000E000  // no receive FIFO threshold
-#define EDRV_REGDW_RCR_RBLEN32K 0x00001000  // 32 kB receive buffer
-#define EDRV_REGDW_RCR_MXDMAUNL 0x00000700  // unlimited maximum DMA burst size
-#define EDRV_REGDW_RCR_NOWRAP   0x00000080  // do not wrap frame at end of buffer
-#define EDRV_REGDW_RCR_AER      0x00000020  // accept error frames (CRC, alignment, collided)
-#define EDRV_REGDW_RCR_AR       0x00000010  // accept runt
-#define EDRV_REGDW_RCR_AB       0x00000008  // accept broadcast frames
-#define EDRV_REGDW_RCR_AM       0x00000004  // accept multicast frames
-#define EDRV_REGDW_RCR_APM      0x00000002  // accept physical match frames
-#define EDRV_REGDW_RCR_AAP      0x00000001  // accept all frames
+#define EDRV_REGB_CMD9346       0x50	// 93C46 command register
+#define EDRV_REGB_CMD9346_LOCK  0x00	// lock configuration registers
+#define EDRV_REGB_CMD9346_UNLOCK 0xC0	// unlock configuration registers
+
+#define EDRV_REGDW_RCR          0x44	// Rx configuration register
+#define EDRV_REGDW_RCR_NO_FTH   0x0000E000	// no receive FIFO threshold
+#define EDRV_REGDW_RCR_RBLEN32K 0x00001000	// 32 kB receive buffer
+#define EDRV_REGDW_RCR_MXDMAUNL 0x00000700	// unlimited maximum DMA burst size
+#define EDRV_REGDW_RCR_NOWRAP   0x00000080	// do not wrap frame at end of buffer
+#define EDRV_REGDW_RCR_AER      0x00000020	// accept error frames (CRC, alignment, collided)
+#define EDRV_REGDW_RCR_AR       0x00000010	// accept runt
+#define EDRV_REGDW_RCR_AB       0x00000008	// accept broadcast frames
+#define EDRV_REGDW_RCR_AM       0x00000004	// accept multicast frames
+#define EDRV_REGDW_RCR_APM      0x00000002	// accept physical match frames
+#define EDRV_REGDW_RCR_AAP      0x00000001	// accept all frames
 #define EDRV_REGDW_RCR_DEF      (EDRV_REGDW_RCR_NO_FTH \
                                  | EDRV_REGDW_RCR_RBLEN32K \
                                  | EDRV_REGDW_RCR_MXDMAUNL \
                                  | EDRV_REGDW_RCR_NOWRAP \
                                  | EDRV_REGDW_RCR_AB \
                                  | EDRV_REGDW_RCR_AM \
-                                 | EDRV_REGDW_RCR_APM)  // default value
+                                 | EDRV_REGDW_RCR_APM)	// default value
 
-#define EDRV_REGDW_TCR          0x40    // Tx configuration register
-#define EDRV_REGDW_TCR_VER_MASK 0x7CC00000  // mask for hardware version
-#define EDRV_REGDW_TCR_VER_C    0x74000000  // RTL8139C
-#define EDRV_REGDW_TCR_VER_D    0x74400000  // RTL8139D
-#define EDRV_REGDW_TCR_IFG96    0x03000000  // default interframe gap (960 ns)
-#define EDRV_REGDW_TCR_CRC      0x00010000  // disable appending of CRC by the controller
-#define EDRV_REGDW_TCR_MXDMAUNL 0x00000700  // maximum DMA burst size of 2048 b
-#define EDRV_REGDW_TCR_TXRETRY  0x00000000  // 16 retries
+#define EDRV_REGDW_TCR          0x40	// Tx configuration register
+#define EDRV_REGDW_TCR_VER_MASK 0x7CC00000	// mask for hardware version
+#define EDRV_REGDW_TCR_VER_C    0x74000000	// RTL8139C
+#define EDRV_REGDW_TCR_VER_D    0x74400000	// RTL8139D
+#define EDRV_REGDW_TCR_IFG96    0x03000000	// default interframe gap (960 ns)
+#define EDRV_REGDW_TCR_CRC      0x00010000	// disable appending of CRC by the controller
+#define EDRV_REGDW_TCR_MXDMAUNL 0x00000700	// maximum DMA burst size of 2048 b
+#define EDRV_REGDW_TCR_TXRETRY  0x00000000	// 16 retries
 #define EDRV_REGDW_TCR_DEF      (EDRV_REGDW_TCR_IFG96 \
                                  | EDRV_REGDW_TCR_MXDMAUNL \
                                  | EDRV_REGDW_TCR_TXRETRY)
 
-#define EDRV_REGW_MULINT        0x5C    // multiple interrupt select register
+#define EDRV_REGW_MULINT        0x5C	// multiple interrupt select register
 
-#define EDRV_REGDW_MPC          0x4C    // missed packet counter register
+#define EDRV_REGDW_MPC          0x4C	// missed packet counter register
 
-#define EDRV_REGDW_TSAD0        0x20    // Transmit start address of descriptor 0
-#define EDRV_REGDW_TSAD1        0x24    // Transmit start address of descriptor 1
-#define EDRV_REGDW_TSAD2        0x28    // Transmit start address of descriptor 2
-#define EDRV_REGDW_TSAD3        0x2C    // Transmit start address of descriptor 3
-#define EDRV_REGDW_TSD0         0x10    // Transmit status of descriptor 0
-#define EDRV_REGDW_TSD_CRS      0x80000000  // Carrier sense lost
-#define EDRV_REGDW_TSD_TABT     0x40000000  // Transmit Abort
-#define EDRV_REGDW_TSD_OWC      0x20000000  // Out of window collision
-#define EDRV_REGDW_TSD_TXTH_DEF 0x00020000  // Transmit FIFO threshold of 64 bytes
-#define EDRV_REGDW_TSD_TOK      0x00008000  // Transmit OK
-#define EDRV_REGDW_TSD_TUN      0x00004000  // Transmit FIFO underrun
-#define EDRV_REGDW_TSD_OWN      0x00002000  // Owner
-
-#define EDRV_REGDW_RBSTART      0x30    // Receive buffer start address
+#define EDRV_REGDW_TSAD0        0x20	// Transmit start address of descriptor 0
+#define EDRV_REGDW_TSAD1        0x24	// Transmit start address of descriptor 1
+#define EDRV_REGDW_TSAD2        0x28	// Transmit start address of descriptor 2
+#define EDRV_REGDW_TSAD3        0x2C	// Transmit start address of descriptor 3
+#define EDRV_REGDW_TSD0         0x10	// Transmit status of descriptor 0
+#define EDRV_REGDW_TSD_CRS      0x80000000	// Carrier sense lost
+#define EDRV_REGDW_TSD_TABT     0x40000000	// Transmit Abort
+#define EDRV_REGDW_TSD_OWC      0x20000000	// Out of window collision
+#define EDRV_REGDW_TSD_TXTH_DEF 0x00020000	// Transmit FIFO threshold of 64 bytes
+#define EDRV_REGDW_TSD_TOK      0x00008000	// Transmit OK
+#define EDRV_REGDW_TSD_TUN      0x00004000	// Transmit FIFO underrun
+#define EDRV_REGDW_TSD_OWN      0x00002000	// Owner
+
+#define EDRV_REGDW_RBSTART      0x30	// Receive buffer start address
 
-#define EDRV_REGW_CAPR          0x38    // Current address of packet read
+#define EDRV_REGW_CAPR          0x38	// Current address of packet read
 
-#define EDRV_REGDW_IDR0         0x00    // ID register 0
-#define EDRV_REGDW_IDR4         0x04    // ID register 4
-
-#define EDRV_REGDW_MAR0         0x08    // Multicast address register 0
-#define EDRV_REGDW_MAR4         0x0C    // Multicast address register 4
+#define EDRV_REGDW_IDR0         0x00	// ID register 0
+#define EDRV_REGDW_IDR4         0x04	// ID register 4
 
+#define EDRV_REGDW_MAR0         0x08	// Multicast address register 0
+#define EDRV_REGDW_MAR4         0x0C	// Multicast address register 4
 
 // defines for the status word in the receive buffer
-#define EDRV_RXSTAT_MAR         0x8000  // Multicast address received
-#define EDRV_RXSTAT_PAM         0x4000  // Physical address matched
-#define EDRV_RXSTAT_BAR         0x2000  // Broadcast address received
-#define EDRV_RXSTAT_ISE         0x0020  // Invalid symbol error
-#define EDRV_RXSTAT_RUNT        0x0010  // Runt packet received
-#define EDRV_RXSTAT_LONG        0x0008  // Long packet
-#define EDRV_RXSTAT_CRC         0x0004  // CRC error
-#define EDRV_RXSTAT_FAE         0x0002  // Frame alignment error
-#define EDRV_RXSTAT_ROK         0x0001  // Receive OK
-
+#define EDRV_RXSTAT_MAR         0x8000	// Multicast address received
+#define EDRV_RXSTAT_PAM         0x4000	// Physical address matched
+#define EDRV_RXSTAT_BAR         0x2000	// Broadcast address received
+#define EDRV_RXSTAT_ISE         0x0020	// Invalid symbol error
+#define EDRV_RXSTAT_RUNT        0x0010	// Runt packet received
+#define EDRV_RXSTAT_LONG        0x0008	// Long packet
+#define EDRV_RXSTAT_CRC         0x0004	// CRC error
+#define EDRV_RXSTAT_FAE         0x0002	// Frame alignment error
+#define EDRV_RXSTAT_ROK         0x0001	// Receive OK
 
 #define EDRV_REGDW_WRITE(dwReg, dwVal)  writel(dwVal, EdrvInstance_l.m_pIoAddr + dwReg)
 #define EDRV_REGW_WRITE(dwReg, wVal)    writew(wVal, EdrvInstance_l.m_pIoAddr + dwReg)
@@ -237,16 +232,15 @@
 #define EDRV_REGW_READ(dwReg)           readw(EdrvInstance_l.m_pIoAddr + dwReg)
 #define EDRV_REGB_READ(dwReg)           readb(EdrvInstance_l.m_pIoAddr + dwReg)
 
-
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-    void  PUBLIC  TgtDbgSignalTracePoint (BYTE bTracePointNumber_p);
-    void  PUBLIC  TgtDbgPostTraceValue (DWORD dwTraceValue_p);
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void PUBLIC TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)
 #endif
 
 #define EDRV_COUNT_SEND                 TGT_DBG_SIGNAL_TRACE_POINT(2)
@@ -271,7 +265,6 @@
 #define EDRV_TRACE_RX_PUN(x)            TGT_DBG_POST_TRACE_VALUE(((x) & 0xFFFF) | 0x11000000)
 #define EDRV_TRACE(x)                   TGT_DBG_POST_TRACE_VALUE(((x) & 0xFFFF0000) | 0x0000FEC0)
 
-
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
@@ -286,59 +279,51 @@ typedef struct
 */
 
 // Private structure
-typedef struct
-{
-    struct pci_dev*     m_pPciDev;      // pointer to PCI device structure
-    void*               m_pIoAddr;      // pointer to register space of Ethernet controller
-    BYTE*               m_pbRxBuf;      // pointer to Rx buffer
-    dma_addr_t          m_pRxBufDma;
-    BYTE*               m_pbTxBuf;      // pointer to Tx buffer
-    dma_addr_t          m_pTxBufDma;
-    BOOL                m_afTxBufUsed[EDRV_MAX_TX_BUFFERS];
-    unsigned int        m_uiCurTxDesc;
+typedef struct {
+	struct pci_dev *m_pPciDev;	// pointer to PCI device structure
+	void *m_pIoAddr;	// pointer to register space of Ethernet controller
+	BYTE *m_pbRxBuf;	// pointer to Rx buffer
+	dma_addr_t m_pRxBufDma;
+	BYTE *m_pbTxBuf;	// pointer to Tx buffer
+	dma_addr_t m_pTxBufDma;
+	BOOL m_afTxBufUsed[EDRV_MAX_TX_BUFFERS];
+	unsigned int m_uiCurTxDesc;
 
-    tEdrvInitParam      m_InitParam;
-    tEdrvTxBuffer*      m_pLastTransmittedTxBuffer;
+	tEdrvInitParam m_InitParam;
+	tEdrvTxBuffer *m_pLastTransmittedTxBuffer;
 
 } tEdrvInstance;
 
-
-
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
 static int EdrvInitOne(struct pci_dev *pPciDev,
-                       const struct pci_device_id *pId);
+		       const struct pci_device_id *pId);
 
 static void EdrvRemoveOne(struct pci_dev *pPciDev);
 
-
 //---------------------------------------------------------------------------
 // modul globale vars
 //---------------------------------------------------------------------------
 // buffers and buffer descriptors and pointers
 
 static struct pci_device_id aEdrvPciTbl[] = {
-    {0x10ec, 0x8139, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-    {0,}
+	{0x10ec, 0x8139, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0,}
 };
-MODULE_DEVICE_TABLE (pci, aEdrvPciTbl);
 
+MODULE_DEVICE_TABLE(pci, aEdrvPciTbl);
 
 static tEdrvInstance EdrvInstance_l;
 
-
 static struct pci_driver EdrvDriver = {
-    .name         = DRV_NAME,
-    .id_table     = aEdrvPciTbl,
-    .probe        = EdrvInitOne,
-    .remove       = EdrvRemoveOne,
+	.name = DRV_NAME,
+	.id_table = aEdrvPciTbl,
+	.probe = EdrvInitOne,
+	.remove = EdrvRemoveOne,
 };
 
-
-
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -352,7 +337,6 @@ static struct pci_driver EdrvDriver = {
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -375,9 +359,7 @@ static struct pci_driver EdrvDriver = {
 // local function prototypes
 //---------------------------------------------------------------------------
 
-static BYTE EdrvCalcHash (BYTE * pbMAC_p);
-
-
+static BYTE EdrvCalcHash(BYTE * pbMAC_p);
 
 //---------------------------------------------------------------------------
 //
@@ -395,49 +377,46 @@ static BYTE EdrvCalcHash (BYTE * pbMAC_p
 //---------------------------------------------------------------------------
 tEplKernel EdrvInit(tEdrvInitParam * pEdrvInitParam_p)
 {
-tEplKernel  Ret;
-int         iResult;
-
-    Ret = kEplSuccessful;
+	tEplKernel Ret;
+	int iResult;
 
-    // clear instance structure
-    EPL_MEMSET(&EdrvInstance_l, 0, sizeof (EdrvInstance_l));
+	Ret = kEplSuccessful;
 
-    // save the init data
-    EdrvInstance_l.m_InitParam = *pEdrvInitParam_p;
+	// clear instance structure
+	EPL_MEMSET(&EdrvInstance_l, 0, sizeof(EdrvInstance_l));
 
+	// save the init data
+	EdrvInstance_l.m_InitParam = *pEdrvInitParam_p;
+
+	// register PCI driver
+	iResult = pci_register_driver(&EdrvDriver);
+	if (iResult != 0) {
+		printk("%s pci_register_driver failed with %d\n", __FUNCTION__,
+		       iResult);
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+
+	if (EdrvInstance_l.m_pPciDev == NULL) {
+		printk("%s m_pPciDev=NULL\n", __FUNCTION__);
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+	// read MAC address from controller
+	printk("%s local MAC = ", __FUNCTION__);
+	for (iResult = 0; iResult < 6; iResult++) {
+		pEdrvInitParam_p->m_abMyMacAddr[iResult] =
+		    EDRV_REGB_READ((EDRV_REGDW_IDR0 + iResult));
+		printk("%02X ",
+		       (unsigned int)pEdrvInitParam_p->m_abMyMacAddr[iResult]);
+	}
+	printk("\n");
 
-    // register PCI driver
-    iResult = pci_register_driver (&EdrvDriver);
-    if (iResult != 0)
-    {
-        printk("%s pci_register_driver failed with %d\n", __FUNCTION__, iResult);
-        Ret = kEplNoResource;
-        goto Exit;
-    }
-
-    if (EdrvInstance_l.m_pPciDev == NULL)
-    {
-        printk("%s m_pPciDev=NULL\n", __FUNCTION__);
-        Ret = kEplNoResource;
-        goto Exit;
-    }
-
-    // read MAC address from controller
-    printk("%s local MAC = ", __FUNCTION__);
-    for (iResult = 0; iResult < 6; iResult++)
-    {
-        pEdrvInitParam_p->m_abMyMacAddr[iResult] = EDRV_REGB_READ((EDRV_REGDW_IDR0 + iResult));
-        printk("%02X ", (unsigned int)pEdrvInitParam_p->m_abMyMacAddr[iResult]);
-    }
-    printk("\n");
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EdrvShutdown
@@ -454,14 +433,13 @@ Exit:
 tEplKernel EdrvShutdown(void)
 {
 
-    // unregister PCI driver
-    printk("%s calling pci_unregister_driver()\n", __FUNCTION__);
-    pci_unregister_driver (&EdrvDriver);
+	// unregister PCI driver
+	printk("%s calling pci_unregister_driver()\n", __FUNCTION__);
+	pci_unregister_driver(&EdrvDriver);
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EdrvDefineRxMacAddrEntry
@@ -475,13 +453,13 @@ tEplKernel EdrvShutdown(void)
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel EdrvDefineRxMacAddrEntry (BYTE * pbMacAddr_p)
+tEplKernel EdrvDefineRxMacAddrEntry(BYTE * pbMacAddr_p)
 {
-tEplKernel  Ret = kEplSuccessful;
-DWORD       dwData;
-BYTE        bHash;
+	tEplKernel Ret = kEplSuccessful;
+	DWORD dwData;
+	BYTE bHash;
 
-    bHash = EdrvCalcHash (pbMacAddr_p);
+	bHash = EdrvCalcHash(pbMacAddr_p);
 /*
     dwData = ether_crc(6, pbMacAddr_p);
 
@@ -490,23 +468,19 @@ BYTE        bHash;
         (WORD) pbMacAddr_p[3], (WORD) pbMacAddr_p[4], (WORD) pbMacAddr_p[5],
         (WORD) bHash, (WORD) (dwData >> 26), dwData);
 */
-    if (bHash > 31)
-    {
-        dwData = EDRV_REGDW_READ(EDRV_REGDW_MAR4);
-        dwData |= 1 << (bHash - 32);
-        EDRV_REGDW_WRITE(EDRV_REGDW_MAR4, dwData);
-    }
-    else
-    {
-        dwData = EDRV_REGDW_READ(EDRV_REGDW_MAR0);
-        dwData |= 1 << bHash;
-        EDRV_REGDW_WRITE(EDRV_REGDW_MAR0, dwData);
-    }
+	if (bHash > 31) {
+		dwData = EDRV_REGDW_READ(EDRV_REGDW_MAR4);
+		dwData |= 1 << (bHash - 32);
+		EDRV_REGDW_WRITE(EDRV_REGDW_MAR4, dwData);
+	} else {
+		dwData = EDRV_REGDW_READ(EDRV_REGDW_MAR0);
+		dwData |= 1 << bHash;
+		EDRV_REGDW_WRITE(EDRV_REGDW_MAR0, dwData);
+	}
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EdrvUndefineRxMacAddrEntry
@@ -520,28 +494,25 @@ BYTE        bHash;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel EdrvUndefineRxMacAddrEntry (BYTE * pbMacAddr_p)
+tEplKernel EdrvUndefineRxMacAddrEntry(BYTE * pbMacAddr_p)
 {
-tEplKernel  Ret = kEplSuccessful;
-DWORD       dwData;
-BYTE        bHash;
-
-    bHash = EdrvCalcHash (pbMacAddr_p);
+	tEplKernel Ret = kEplSuccessful;
+	DWORD dwData;
+	BYTE bHash;
+
+	bHash = EdrvCalcHash(pbMacAddr_p);
+
+	if (bHash > 31) {
+		dwData = EDRV_REGDW_READ(EDRV_REGDW_MAR4);
+		dwData &= ~(1 << (bHash - 32));
+		EDRV_REGDW_WRITE(EDRV_REGDW_MAR4, dwData);
+	} else {
+		dwData = EDRV_REGDW_READ(EDRV_REGDW_MAR0);
+		dwData &= ~(1 << bHash);
+		EDRV_REGDW_WRITE(EDRV_REGDW_MAR0, dwData);
+	}
 
-    if (bHash > 31)
-    {
-        dwData = EDRV_REGDW_READ(EDRV_REGDW_MAR4);
-        dwData &= ~(1 << (bHash - 32));
-        EDRV_REGDW_WRITE(EDRV_REGDW_MAR4, dwData);
-    }
-    else
-    {
-        dwData = EDRV_REGDW_READ(EDRV_REGDW_MAR0);
-        dwData &= ~(1 << bHash);
-        EDRV_REGDW_WRITE(EDRV_REGDW_MAR0, dwData);
-    }
-
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -558,42 +529,38 @@ BYTE        bHash;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel EdrvAllocTxMsgBuffer       (tEdrvTxBuffer * pBuffer_p)
+tEplKernel EdrvAllocTxMsgBuffer(tEdrvTxBuffer * pBuffer_p)
 {
-tEplKernel Ret = kEplSuccessful;
-DWORD i;
+	tEplKernel Ret = kEplSuccessful;
+	DWORD i;
 
-    if (pBuffer_p->m_uiMaxBufferLen > EDRV_MAX_FRAME_SIZE)
-    {
-        Ret = kEplEdrvNoFreeBufEntry;
-        goto Exit;
-    }
+	if (pBuffer_p->m_uiMaxBufferLen > EDRV_MAX_FRAME_SIZE) {
+		Ret = kEplEdrvNoFreeBufEntry;
+		goto Exit;
+	}
+	// search a free Tx buffer with appropriate size
+	for (i = 0; i < EDRV_MAX_TX_BUFFERS; i++) {
+		if (EdrvInstance_l.m_afTxBufUsed[i] == FALSE) {
+			// free channel found
+			EdrvInstance_l.m_afTxBufUsed[i] = TRUE;
+			pBuffer_p->m_uiBufferNumber = i;
+			pBuffer_p->m_pbBuffer =
+			    EdrvInstance_l.m_pbTxBuf +
+			    (i * EDRV_MAX_FRAME_SIZE);
+			pBuffer_p->m_uiMaxBufferLen = EDRV_MAX_FRAME_SIZE;
+			break;
+		}
+	}
+	if (i >= EDRV_MAX_TX_BUFFERS) {
+		Ret = kEplEdrvNoFreeBufEntry;
+		goto Exit;
+	}
 
-    // search a free Tx buffer with appropriate size
-    for (i = 0; i < EDRV_MAX_TX_BUFFERS; i++)
-    {
-        if (EdrvInstance_l.m_afTxBufUsed[i] == FALSE)
-        {
-            // free channel found
-            EdrvInstance_l.m_afTxBufUsed[i] = TRUE;
-            pBuffer_p->m_uiBufferNumber = i;
-            pBuffer_p->m_pbBuffer = EdrvInstance_l.m_pbTxBuf + (i * EDRV_MAX_FRAME_SIZE);
-            pBuffer_p->m_uiMaxBufferLen = EDRV_MAX_FRAME_SIZE;
-            break;
-        }
-    }
-    if (i >= EDRV_MAX_TX_BUFFERS)
-    {
-        Ret = kEplEdrvNoFreeBufEntry;
-        goto Exit;
-    }
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EdrvReleaseTxMsgBuffer
@@ -607,22 +574,20 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel EdrvReleaseTxMsgBuffer     (tEdrvTxBuffer * pBuffer_p)
+tEplKernel EdrvReleaseTxMsgBuffer(tEdrvTxBuffer * pBuffer_p)
 {
-unsigned int uiBufferNumber;
+	unsigned int uiBufferNumber;
 
-    uiBufferNumber = pBuffer_p->m_uiBufferNumber;
+	uiBufferNumber = pBuffer_p->m_uiBufferNumber;
 
-    if (uiBufferNumber < EDRV_MAX_TX_BUFFERS)
-    {
-        EdrvInstance_l.m_afTxBufUsed[uiBufferNumber] = FALSE;
-    }
+	if (uiBufferNumber < EDRV_MAX_TX_BUFFERS) {
+		EdrvInstance_l.m_afTxBufUsed[uiBufferNumber] = FALSE;
+	}
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EdrvSendTxMsg
@@ -636,54 +601,64 @@ unsigned int uiBufferNumber;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel EdrvSendTxMsg              (tEdrvTxBuffer * pBuffer_p)
+tEplKernel EdrvSendTxMsg(tEdrvTxBuffer * pBuffer_p)
 {
-tEplKernel Ret = kEplSuccessful;
-unsigned int uiBufferNumber;
-DWORD       dwTemp;
-
-    uiBufferNumber = pBuffer_p->m_uiBufferNumber;
-
-    if ((uiBufferNumber >= EDRV_MAX_TX_BUFFERS)
-        || (EdrvInstance_l.m_afTxBufUsed[uiBufferNumber] == FALSE))
-    {
-        Ret = kEplEdrvBufNotExisting;
-        goto Exit;
-    }
-
-    if (EdrvInstance_l.m_pLastTransmittedTxBuffer != NULL)
-    {   // transmission is already active
-        Ret = kEplInvalidOperation;
-        dwTemp = EDRV_REGDW_READ((EDRV_REGDW_TSD0 + (EdrvInstance_l.m_uiCurTxDesc * sizeof (DWORD))));
-        printk("%s InvOp TSD%u = 0x%08lX", __FUNCTION__, EdrvInstance_l.m_uiCurTxDesc, dwTemp);
-        printk("  Cmd = 0x%02X\n", (WORD) EDRV_REGB_READ(EDRV_REGB_COMMAND));
-        goto Exit;
-    }
-
-    // save pointer to buffer structure for TxHandler
-    EdrvInstance_l.m_pLastTransmittedTxBuffer = pBuffer_p;
-
-    EDRV_COUNT_SEND;
-
-    // pad with zeros if necessary, because controller does not do it
-    if (pBuffer_p->m_uiTxMsgLen < MIN_ETH_SIZE)
-    {
-        EPL_MEMSET(pBuffer_p->m_pbBuffer + pBuffer_p->m_uiTxMsgLen, 0, MIN_ETH_SIZE - pBuffer_p->m_uiTxMsgLen);
-        pBuffer_p->m_uiTxMsgLen = MIN_ETH_SIZE;
-    }
-
-    // set DMA address of buffer
-    EDRV_REGDW_WRITE((EDRV_REGDW_TSAD0 + (EdrvInstance_l.m_uiCurTxDesc * sizeof (DWORD))), (EdrvInstance_l.m_pTxBufDma + (uiBufferNumber * EDRV_MAX_FRAME_SIZE)));
-    dwTemp = EDRV_REGDW_READ((EDRV_REGDW_TSAD0 + (EdrvInstance_l.m_uiCurTxDesc * sizeof (DWORD))));
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiBufferNumber;
+	DWORD dwTemp;
+
+	uiBufferNumber = pBuffer_p->m_uiBufferNumber;
+
+	if ((uiBufferNumber >= EDRV_MAX_TX_BUFFERS)
+	    || (EdrvInstance_l.m_afTxBufUsed[uiBufferNumber] == FALSE)) {
+		Ret = kEplEdrvBufNotExisting;
+		goto Exit;
+	}
+
+	if (EdrvInstance_l.m_pLastTransmittedTxBuffer != NULL) {	// transmission is already active
+		Ret = kEplInvalidOperation;
+		dwTemp =
+		    EDRV_REGDW_READ((EDRV_REGDW_TSD0 +
+				     (EdrvInstance_l.m_uiCurTxDesc *
+				      sizeof(DWORD))));
+		printk("%s InvOp TSD%u = 0x%08lX", __FUNCTION__,
+		       EdrvInstance_l.m_uiCurTxDesc, dwTemp);
+		printk("  Cmd = 0x%02X\n",
+		       (WORD) EDRV_REGB_READ(EDRV_REGB_COMMAND));
+		goto Exit;
+	}
+	// save pointer to buffer structure for TxHandler
+	EdrvInstance_l.m_pLastTransmittedTxBuffer = pBuffer_p;
+
+	EDRV_COUNT_SEND;
+
+	// pad with zeros if necessary, because controller does not do it
+	if (pBuffer_p->m_uiTxMsgLen < MIN_ETH_SIZE) {
+		EPL_MEMSET(pBuffer_p->m_pbBuffer + pBuffer_p->m_uiTxMsgLen, 0,
+			   MIN_ETH_SIZE - pBuffer_p->m_uiTxMsgLen);
+		pBuffer_p->m_uiTxMsgLen = MIN_ETH_SIZE;
+	}
+	// set DMA address of buffer
+	EDRV_REGDW_WRITE((EDRV_REGDW_TSAD0 +
+			  (EdrvInstance_l.m_uiCurTxDesc * sizeof(DWORD))),
+			 (EdrvInstance_l.m_pTxBufDma +
+			  (uiBufferNumber * EDRV_MAX_FRAME_SIZE)));
+	dwTemp =
+	    EDRV_REGDW_READ((EDRV_REGDW_TSAD0 +
+			     (EdrvInstance_l.m_uiCurTxDesc * sizeof(DWORD))));
 //    printk("%s TSAD%u = 0x%08lX", __FUNCTION__, EdrvInstance_l.m_uiCurTxDesc, dwTemp);
 
-    // start transmission
-    EDRV_REGDW_WRITE((EDRV_REGDW_TSD0 + (EdrvInstance_l.m_uiCurTxDesc * sizeof (DWORD))), (EDRV_REGDW_TSD_TXTH_DEF | pBuffer_p->m_uiTxMsgLen));
-    dwTemp = EDRV_REGDW_READ((EDRV_REGDW_TSD0 + (EdrvInstance_l.m_uiCurTxDesc * sizeof (DWORD))));
+	// start transmission
+	EDRV_REGDW_WRITE((EDRV_REGDW_TSD0 +
+			  (EdrvInstance_l.m_uiCurTxDesc * sizeof(DWORD))),
+			 (EDRV_REGDW_TSD_TXTH_DEF | pBuffer_p->m_uiTxMsgLen));
+	dwTemp =
+	    EDRV_REGDW_READ((EDRV_REGDW_TSD0 +
+			     (EdrvInstance_l.m_uiCurTxDesc * sizeof(DWORD))));
 //    printk(" TSD%u = 0x%08lX / 0x%08lX\n", EdrvInstance_l.m_uiCurTxDesc, dwTemp, (DWORD)(EDRV_REGDW_TSD_TXTH_DEF | pBuffer_p->m_uiTxMsgLen));
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 #if 0
@@ -700,17 +675,15 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel EdrvTxMsgReady              (tEdrvTxBuffer * pBuffer_p)
+tEplKernel EdrvTxMsgReady(tEdrvTxBuffer * pBuffer_p)
 {
-tEplKernel Ret = kEplSuccessful;
-unsigned int uiBufferNumber;
-
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiBufferNumber;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EdrvTxMsgStart
@@ -724,18 +697,14 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel EdrvTxMsgStart              (tEdrvTxBuffer * pBuffer_p)
+tEplKernel EdrvTxMsgStart(tEdrvTxBuffer * pBuffer_p)
 {
-tEplKernel Ret = kEplSuccessful;
-
-
+	tEplKernel Ret = kEplSuccessful;
 
-    return Ret;
+	return Ret;
 }
 #endif
 
-
-
 //---------------------------------------------------------------------------
 //
 // Function:    EdrvReinitRx
@@ -751,19 +720,18 @@ tEplKernel Ret = kEplSuccessful;
 //---------------------------------------------------------------------------
 static void EdrvReinitRx(void)
 {
-BYTE    bCmd;
+	BYTE bCmd;
 
-    // simply switch off and on the receiver
-    // this will reset the CAPR register
-    bCmd = EDRV_REGB_READ(EDRV_REGB_COMMAND);
-    EDRV_REGB_WRITE(EDRV_REGB_COMMAND, (bCmd & ~EDRV_REGB_COMMAND_RE));
-    EDRV_REGB_WRITE(EDRV_REGB_COMMAND, bCmd);
+	// simply switch off and on the receiver
+	// this will reset the CAPR register
+	bCmd = EDRV_REGB_READ(EDRV_REGB_COMMAND);
+	EDRV_REGB_WRITE(EDRV_REGB_COMMAND, (bCmd & ~EDRV_REGB_COMMAND_RE));
+	EDRV_REGB_WRITE(EDRV_REGB_COMMAND, bCmd);
 
-    // set receive configuration register
-    EDRV_REGDW_WRITE(EDRV_REGDW_RCR, EDRV_REGDW_RCR_DEF);
+	// set receive configuration register
+	EDRV_REGDW_WRITE(EDRV_REGDW_RCR, EDRV_REGDW_RCR_DEF);
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:     EdrvInterruptHandler
@@ -778,203 +746,183 @@ BYTE    bCmd;
 //
 //---------------------------------------------------------------------------
 #if 0
-void EdrvInterruptHandler (void)
+void EdrvInterruptHandler(void)
 {
 }
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
-static int TgtEthIsr (int nIrqNum_p, void* ppDevInstData_p)
+static int TgtEthIsr(int nIrqNum_p, void *ppDevInstData_p)
 #else
-static int TgtEthIsr (int nIrqNum_p, void* ppDevInstData_p, struct pt_regs* ptRegs_p)
+static int TgtEthIsr(int nIrqNum_p, void *ppDevInstData_p,
+		     struct pt_regs *ptRegs_p)
 #endif
 {
 //    EdrvInterruptHandler();
-tEdrvRxBuffer   RxBuffer;
-tEdrvTxBuffer*  pTxBuffer;
-WORD            wStatus;
-DWORD           dwTxStatus;
-DWORD           dwRxStatus;
-WORD            wCurRx;
-BYTE*           pbRxBuf;
-unsigned int    uiLength;
-int             iHandled = IRQ_HANDLED;
+	tEdrvRxBuffer RxBuffer;
+	tEdrvTxBuffer *pTxBuffer;
+	WORD wStatus;
+	DWORD dwTxStatus;
+	DWORD dwRxStatus;
+	WORD wCurRx;
+	BYTE *pbRxBuf;
+	unsigned int uiLength;
+	int iHandled = IRQ_HANDLED;
 
 //    printk("§");
 
-    // read the interrupt status
-    wStatus = EDRV_REGW_READ(EDRV_REGW_INT_STATUS);
+	// read the interrupt status
+	wStatus = EDRV_REGW_READ(EDRV_REGW_INT_STATUS);
 
-    // acknowledge the interrupts
-    EDRV_REGW_WRITE(EDRV_REGW_INT_STATUS, wStatus);
+	// acknowledge the interrupts
+	EDRV_REGW_WRITE(EDRV_REGW_INT_STATUS, wStatus);
 
-    if (wStatus == 0)
-    {
-        iHandled = IRQ_NONE;
-        goto Exit;
-    }
-
-    // process tasks
-    if ((wStatus & (EDRV_REGW_INT_TER | EDRV_REGW_INT_TOK)) != 0)
-    {   // transmit interrupt
-
-        if (EdrvInstance_l.m_pbTxBuf == NULL)
-        {
-            printk("%s Tx buffers currently not allocated\n", __FUNCTION__);
-            goto Exit;
-        }
-
-        // read transmit status
-        dwTxStatus = EDRV_REGDW_READ((EDRV_REGDW_TSD0 + (EdrvInstance_l.m_uiCurTxDesc * sizeof (DWORD))));
-        if ((dwTxStatus & (EDRV_REGDW_TSD_TOK | EDRV_REGDW_TSD_TABT | EDRV_REGDW_TSD_TUN)) != 0)
-        {   // transmit finished
-            EdrvInstance_l.m_uiCurTxDesc = (EdrvInstance_l.m_uiCurTxDesc + 1) & 0x03;
-            pTxBuffer = EdrvInstance_l.m_pLastTransmittedTxBuffer;
-            EdrvInstance_l.m_pLastTransmittedTxBuffer = NULL;
-
-            if ((dwTxStatus & EDRV_REGDW_TSD_TOK) != 0)
-            {
-                EDRV_COUNT_TX;
-            }
-            else if ((dwTxStatus & EDRV_REGDW_TSD_TUN) != 0)
-            {
-                EDRV_COUNT_TX_FUN;
-            }
-            else
-            {   // assume EDRV_REGDW_TSD_TABT
-                EDRV_COUNT_TX_COL_RL;
-            }
+	if (wStatus == 0) {
+		iHandled = IRQ_NONE;
+		goto Exit;
+	}
+	// process tasks
+	if ((wStatus & (EDRV_REGW_INT_TER | EDRV_REGW_INT_TOK)) != 0) {	// transmit interrupt
+
+		if (EdrvInstance_l.m_pbTxBuf == NULL) {
+			printk("%s Tx buffers currently not allocated\n",
+			       __FUNCTION__);
+			goto Exit;
+		}
+		// read transmit status
+		dwTxStatus =
+		    EDRV_REGDW_READ((EDRV_REGDW_TSD0 +
+				     (EdrvInstance_l.m_uiCurTxDesc *
+				      sizeof(DWORD))));
+		if ((dwTxStatus & (EDRV_REGDW_TSD_TOK | EDRV_REGDW_TSD_TABT | EDRV_REGDW_TSD_TUN)) != 0) {	// transmit finished
+			EdrvInstance_l.m_uiCurTxDesc =
+			    (EdrvInstance_l.m_uiCurTxDesc + 1) & 0x03;
+			pTxBuffer = EdrvInstance_l.m_pLastTransmittedTxBuffer;
+			EdrvInstance_l.m_pLastTransmittedTxBuffer = NULL;
+
+			if ((dwTxStatus & EDRV_REGDW_TSD_TOK) != 0) {
+				EDRV_COUNT_TX;
+			} else if ((dwTxStatus & EDRV_REGDW_TSD_TUN) != 0) {
+				EDRV_COUNT_TX_FUN;
+			} else {	// assume EDRV_REGDW_TSD_TABT
+				EDRV_COUNT_TX_COL_RL;
+			}
 
 //            printk("T");
-            if (pTxBuffer != NULL)
-            {
-                // call Tx handler of Data link layer
-                EdrvInstance_l.m_InitParam.m_pfnTxHandler(pTxBuffer);
-            }
-        }
-        else
-        {
-            EDRV_COUNT_TX_ERR;
-        }
-    }
-
-    if ((wStatus & (EDRV_REGW_INT_RER | EDRV_REGW_INT_FOVW | EDRV_REGW_INT_RXOVW | EDRV_REGW_INT_PUN)) != 0)
-    {   // receive error interrupt
-
-        if ((wStatus & EDRV_REGW_INT_FOVW) != 0)
-        {
-            EDRV_COUNT_RX_FOVW;
-        }
-        else if ((wStatus & EDRV_REGW_INT_RXOVW) != 0)
-        {
-            EDRV_COUNT_RX_OVW;
-        }
-        else if ((wStatus & EDRV_REGW_INT_PUN) != 0)
-        {   // Packet underrun
-            EDRV_TRACE_RX_PUN(wStatus);
-            EDRV_COUNT_RX_PUN;
-        }
-        else /*if ((wStatus & EDRV_REGW_INT_RER) != 0)*/
-        {
-            EDRV_TRACE_RX_ERR(wStatus);
-            EDRV_COUNT_RX_ERR;
-        }
-
-        // reinitialize Rx process
-        EdrvReinitRx();
-    }
-
-    if ((wStatus & EDRV_REGW_INT_ROK) != 0)
-    {   // receive interrupt
-
-        if (EdrvInstance_l.m_pbRxBuf == NULL)
-        {
-            printk("%s Rx buffers currently not allocated\n", __FUNCTION__);
-            goto Exit;
-        }
-
-        // read current offset in receive buffer
-        wCurRx = (EDRV_REGW_READ(EDRV_REGW_CAPR) + 0x10) % EDRV_RX_BUFFER_LENGTH;
-
-        while ((EDRV_REGB_READ(EDRV_REGB_COMMAND) & EDRV_REGB_COMMAND_BUFE) == 0)
-        {   // frame available
-
-            // calculate pointer to current frame in receive buffer
-            pbRxBuf = EdrvInstance_l.m_pbRxBuf + wCurRx;
-
-            // read receive status DWORD
-            dwRxStatus = le32_to_cpu(*((DWORD*)pbRxBuf));
-
-            // calculate length of received frame
-            uiLength = dwRxStatus >> 16;
-
-            if (uiLength == 0xFFF0)
-            {   // frame is unfinished (maybe early Rx interrupt is active)
-                break;
-            }
-
-            if ((dwRxStatus & EDRV_RXSTAT_ROK) == 0)
-            {   // error occured while receiving this frame
-                // ignore it
-                if ((dwRxStatus & EDRV_RXSTAT_FAE) != 0)
-                {
-                    EDRV_COUNT_RX_FAE;
-                }
-                else if ((dwRxStatus & EDRV_RXSTAT_CRC) != 0)
-                {
-                    EDRV_TRACE_RX_CRC(dwRxStatus);
-                    EDRV_COUNT_RX_CRC;
-                }
-                else
-                {
-                    EDRV_TRACE_RX_ERR(dwRxStatus);
-                    EDRV_COUNT_RX_ERR;
-                }
-
-                // reinitialize Rx process
-                EdrvReinitRx();
-
-                break;
-            }
-            else
-            {   // frame is OK
-                RxBuffer.m_BufferInFrame = kEdrvBufferLastInFrame;
-                RxBuffer.m_uiRxMsgLen = uiLength - ETH_CRC_SIZE;
-                RxBuffer.m_pbBuffer = pbRxBuf + sizeof (dwRxStatus);
+			if (pTxBuffer != NULL) {
+				// call Tx handler of Data link layer
+				EdrvInstance_l.m_InitParam.
+				    m_pfnTxHandler(pTxBuffer);
+			}
+		} else {
+			EDRV_COUNT_TX_ERR;
+		}
+	}
+
+	if ((wStatus & (EDRV_REGW_INT_RER | EDRV_REGW_INT_FOVW | EDRV_REGW_INT_RXOVW | EDRV_REGW_INT_PUN)) != 0) {	// receive error interrupt
+
+		if ((wStatus & EDRV_REGW_INT_FOVW) != 0) {
+			EDRV_COUNT_RX_FOVW;
+		} else if ((wStatus & EDRV_REGW_INT_RXOVW) != 0) {
+			EDRV_COUNT_RX_OVW;
+		} else if ((wStatus & EDRV_REGW_INT_PUN) != 0) {	// Packet underrun
+			EDRV_TRACE_RX_PUN(wStatus);
+			EDRV_COUNT_RX_PUN;
+		} else {	/*if ((wStatus & EDRV_REGW_INT_RER) != 0) */
+
+			EDRV_TRACE_RX_ERR(wStatus);
+			EDRV_COUNT_RX_ERR;
+		}
+
+		// reinitialize Rx process
+		EdrvReinitRx();
+	}
+
+	if ((wStatus & EDRV_REGW_INT_ROK) != 0) {	// receive interrupt
+
+		if (EdrvInstance_l.m_pbRxBuf == NULL) {
+			printk("%s Rx buffers currently not allocated\n",
+			       __FUNCTION__);
+			goto Exit;
+		}
+		// read current offset in receive buffer
+		wCurRx =
+		    (EDRV_REGW_READ(EDRV_REGW_CAPR) +
+		     0x10) % EDRV_RX_BUFFER_LENGTH;
+
+		while ((EDRV_REGB_READ(EDRV_REGB_COMMAND) & EDRV_REGB_COMMAND_BUFE) == 0) {	// frame available
+
+			// calculate pointer to current frame in receive buffer
+			pbRxBuf = EdrvInstance_l.m_pbRxBuf + wCurRx;
+
+			// read receive status DWORD
+			dwRxStatus = le32_to_cpu(*((DWORD *) pbRxBuf));
+
+			// calculate length of received frame
+			uiLength = dwRxStatus >> 16;
+
+			if (uiLength == 0xFFF0) {	// frame is unfinished (maybe early Rx interrupt is active)
+				break;
+			}
+
+			if ((dwRxStatus & EDRV_RXSTAT_ROK) == 0) {	// error occured while receiving this frame
+				// ignore it
+				if ((dwRxStatus & EDRV_RXSTAT_FAE) != 0) {
+					EDRV_COUNT_RX_FAE;
+				} else if ((dwRxStatus & EDRV_RXSTAT_CRC) != 0) {
+					EDRV_TRACE_RX_CRC(dwRxStatus);
+					EDRV_COUNT_RX_CRC;
+				} else {
+					EDRV_TRACE_RX_ERR(dwRxStatus);
+					EDRV_COUNT_RX_ERR;
+				}
+
+				// reinitialize Rx process
+				EdrvReinitRx();
+
+				break;
+			} else {	// frame is OK
+				RxBuffer.m_BufferInFrame =
+				    kEdrvBufferLastInFrame;
+				RxBuffer.m_uiRxMsgLen = uiLength - ETH_CRC_SIZE;
+				RxBuffer.m_pbBuffer =
+				    pbRxBuf + sizeof(dwRxStatus);
 
 //                printk("R");
-                EDRV_COUNT_RX;
-
-                // call Rx handler of Data link layer
-                EdrvInstance_l.m_InitParam.m_pfnRxHandler(&RxBuffer);
-            }
-
-            // calulate new offset (DWORD aligned)
-            wCurRx = (WORD) ((wCurRx + uiLength + sizeof (dwRxStatus) + 3) & ~0x3);
-            EDRV_TRACE_CAPR(wCurRx - 0x10);
-            EDRV_REGW_WRITE(EDRV_REGW_CAPR, wCurRx - 0x10);
-
-            // reread current offset in receive buffer
-            wCurRx = (EDRV_REGW_READ(EDRV_REGW_CAPR) + 0x10) % EDRV_RX_BUFFER_LENGTH;
+				EDRV_COUNT_RX;
 
-        }
-    }
+				// call Rx handler of Data link layer
+				EdrvInstance_l.m_InitParam.
+				    m_pfnRxHandler(&RxBuffer);
+			}
+
+			// calulate new offset (DWORD aligned)
+			wCurRx =
+			    (WORD) ((wCurRx + uiLength + sizeof(dwRxStatus) +
+				     3) & ~0x3);
+			EDRV_TRACE_CAPR(wCurRx - 0x10);
+			EDRV_REGW_WRITE(EDRV_REGW_CAPR, wCurRx - 0x10);
+
+			// reread current offset in receive buffer
+			wCurRx =
+			    (EDRV_REGW_READ(EDRV_REGW_CAPR) +
+			     0x10) % EDRV_RX_BUFFER_LENGTH;
+
+		}
+	}
+
+	if ((wStatus & EDRV_REGW_INT_SERR) != 0) {	// PCI error
+		EDRV_COUNT_PCI_ERR;
+	}
+
+	if ((wStatus & EDRV_REGW_INT_TIMEOUT) != 0) {	// Timeout
+		EDRV_COUNT_TIMEOUT;
+	}
 
-    if ((wStatus & EDRV_REGW_INT_SERR) != 0)
-    {   // PCI error
-        EDRV_COUNT_PCI_ERR;
-    }
-
-    if ((wStatus & EDRV_REGW_INT_TIMEOUT) != 0)
-    {   // Timeout
-        EDRV_COUNT_TIMEOUT;
-    }
-
-Exit:
-    return iHandled;
+      Exit:
+	return iHandled;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EdrvInitOne
@@ -990,99 +938,96 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static int EdrvInitOne(struct pci_dev *pPciDev,
-                       const struct pci_device_id *pId)
+static int EdrvInitOne(struct pci_dev *pPciDev, const struct pci_device_id *pId)
 {
-int     iResult = 0;
-DWORD   dwTemp;
-
-    if (EdrvInstance_l.m_pPciDev != NULL)
-    {   // Edrv is already connected to a PCI device
-        printk("%s device %s discarded\n", __FUNCTION__, pci_name(pPciDev));
-        iResult = -ENODEV;
-        goto Exit;
-    }
-
-    if (pPciDev->revision >= 0x20)
-    {
-        printk("%s device %s is an enhanced 8139C+ version, which is not supported\n", __FUNCTION__, pci_name(pPciDev));
-        iResult = -ENODEV;
-        goto Exit;
-    }
-
-    EdrvInstance_l.m_pPciDev = pPciDev;
-
-    // enable device
-    printk("%s enable device\n", __FUNCTION__);
-    iResult = pci_enable_device(pPciDev);
-    if (iResult != 0)
-    {
-        goto Exit;
-    }
-
-    if ((pci_resource_flags(pPciDev, 1) & IORESOURCE_MEM) == 0)
-    {
-        iResult = -ENODEV;
-        goto Exit;
-    }
-
-    printk("%s request regions\n", __FUNCTION__);
-    iResult = pci_request_regions(pPciDev, DRV_NAME);
-    if (iResult != 0)
-    {
-        goto Exit;
-    }
-
-    printk("%s ioremap\n", __FUNCTION__);
-    EdrvInstance_l.m_pIoAddr = ioremap (pci_resource_start(pPciDev, 1), pci_resource_len(pPciDev, 1));
-    if (EdrvInstance_l.m_pIoAddr == NULL)
-    {   // remap of controller's register space failed
-        iResult = -EIO;
-        goto Exit;
-    }
-
-    // enable PCI busmaster
-    printk("%s enable busmaster\n", __FUNCTION__);
-    pci_set_master (pPciDev);
-
-    // reset controller
-    printk("%s reset controller\n", __FUNCTION__);
-    EDRV_REGB_WRITE(EDRV_REGB_COMMAND, EDRV_REGB_COMMAND_RST);
-
-    // wait until reset has finished
-    for (iResult = 500; iResult > 0; iResult--)
-    {
-        if ((EDRV_REGB_READ(EDRV_REGB_COMMAND) & EDRV_REGB_COMMAND_RST) == 0)
-        {
-            break;
-        }
+	int iResult = 0;
+	DWORD dwTemp;
 
-        schedule_timeout(10);
-    }
-
-    // check hardware version, i.e. chip ID
-    dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TCR);
-    if (((dwTemp & EDRV_REGDW_TCR_VER_MASK) != EDRV_REGDW_TCR_VER_C)
-        && ((dwTemp & EDRV_REGDW_TCR_VER_MASK) != EDRV_REGDW_TCR_VER_D))
-    {   // unsupported chip
-        printk("%s Unsupported chip! TCR = 0x%08lX\n", __FUNCTION__, dwTemp);
-        iResult = -ENODEV;
-        goto Exit;
-    }
-
-    // disable interrupts
-    printk("%s disable interrupts\n", __FUNCTION__);
-    EDRV_REGW_WRITE(EDRV_REGW_INT_MASK, 0);
-    // acknowledge all pending interrupts
-    EDRV_REGW_WRITE(EDRV_REGW_INT_STATUS, EDRV_REGW_READ(EDRV_REGW_INT_STATUS));
-
-    // install interrupt handler
-    printk("%s install interrupt handler\n", __FUNCTION__);
-    iResult = request_irq(pPciDev->irq, TgtEthIsr, IRQF_SHARED, DRV_NAME /*pPciDev->dev.name*/, pPciDev);
-    if (iResult != 0)
-    {
-        goto Exit;
-    }
+	if (EdrvInstance_l.m_pPciDev != NULL) {	// Edrv is already connected to a PCI device
+		printk("%s device %s discarded\n", __FUNCTION__,
+		       pci_name(pPciDev));
+		iResult = -ENODEV;
+		goto Exit;
+	}
+
+	if (pPciDev->revision >= 0x20) {
+		printk
+		    ("%s device %s is an enhanced 8139C+ version, which is not supported\n",
+		     __FUNCTION__, pci_name(pPciDev));
+		iResult = -ENODEV;
+		goto Exit;
+	}
+
+	EdrvInstance_l.m_pPciDev = pPciDev;
+
+	// enable device
+	printk("%s enable device\n", __FUNCTION__);
+	iResult = pci_enable_device(pPciDev);
+	if (iResult != 0) {
+		goto Exit;
+	}
+
+	if ((pci_resource_flags(pPciDev, 1) & IORESOURCE_MEM) == 0) {
+		iResult = -ENODEV;
+		goto Exit;
+	}
+
+	printk("%s request regions\n", __FUNCTION__);
+	iResult = pci_request_regions(pPciDev, DRV_NAME);
+	if (iResult != 0) {
+		goto Exit;
+	}
+
+	printk("%s ioremap\n", __FUNCTION__);
+	EdrvInstance_l.m_pIoAddr =
+	    ioremap(pci_resource_start(pPciDev, 1),
+		    pci_resource_len(pPciDev, 1));
+	if (EdrvInstance_l.m_pIoAddr == NULL) {	// remap of controller's register space failed
+		iResult = -EIO;
+		goto Exit;
+	}
+	// enable PCI busmaster
+	printk("%s enable busmaster\n", __FUNCTION__);
+	pci_set_master(pPciDev);
+
+	// reset controller
+	printk("%s reset controller\n", __FUNCTION__);
+	EDRV_REGB_WRITE(EDRV_REGB_COMMAND, EDRV_REGB_COMMAND_RST);
+
+	// wait until reset has finished
+	for (iResult = 500; iResult > 0; iResult--) {
+		if ((EDRV_REGB_READ(EDRV_REGB_COMMAND) & EDRV_REGB_COMMAND_RST)
+		    == 0) {
+			break;
+		}
+
+		schedule_timeout(10);
+	}
+
+	// check hardware version, i.e. chip ID
+	dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TCR);
+	if (((dwTemp & EDRV_REGDW_TCR_VER_MASK) != EDRV_REGDW_TCR_VER_C)
+	    && ((dwTemp & EDRV_REGDW_TCR_VER_MASK) != EDRV_REGDW_TCR_VER_D)) {	// unsupported chip
+		printk("%s Unsupported chip! TCR = 0x%08lX\n", __FUNCTION__,
+		       dwTemp);
+		iResult = -ENODEV;
+		goto Exit;
+	}
+	// disable interrupts
+	printk("%s disable interrupts\n", __FUNCTION__);
+	EDRV_REGW_WRITE(EDRV_REGW_INT_MASK, 0);
+	// acknowledge all pending interrupts
+	EDRV_REGW_WRITE(EDRV_REGW_INT_STATUS,
+			EDRV_REGW_READ(EDRV_REGW_INT_STATUS));
+
+	// install interrupt handler
+	printk("%s install interrupt handler\n", __FUNCTION__);
+	iResult =
+	    request_irq(pPciDev->irq, TgtEthIsr, IRQF_SHARED,
+			DRV_NAME /*pPciDev->dev.name */ , pPciDev);
+	if (iResult != 0) {
+		goto Exit;
+	}
 
 /*
     // unlock configuration registers
@@ -1113,64 +1058,66 @@ DWORD   dwTemp;
     EDRV_REGB_WRITE(EDRV_REGB_CMD9346, EDRV_REGB_CMD9346_LOCK);
 */
 
-    // allocate buffers
-    printk("%s allocate buffers\n", __FUNCTION__);
-    EdrvInstance_l.m_pbTxBuf = pci_alloc_consistent(pPciDev, EDRV_TX_BUFFER_SIZE,
-                     &EdrvInstance_l.m_pTxBufDma);
-    if (EdrvInstance_l.m_pbTxBuf == NULL)
-    {
-        iResult = -ENOMEM;
-        goto Exit;
-    }
-
-    EdrvInstance_l.m_pbRxBuf = pci_alloc_consistent(pPciDev, EDRV_RX_BUFFER_SIZE,
-                     &EdrvInstance_l.m_pRxBufDma);
-    if (EdrvInstance_l.m_pbRxBuf == NULL)
-    {
-        iResult = -ENOMEM;
-        goto Exit;
-    }
-
-    // reset pointers for Tx buffers
-    printk("%s reset pointers fo Tx buffers\n", __FUNCTION__);
-    EDRV_REGDW_WRITE(EDRV_REGDW_TSAD0, 0);
-    dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TSAD0);
-    EDRV_REGDW_WRITE(EDRV_REGDW_TSAD1, 0);
-    dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TSAD1);
-    EDRV_REGDW_WRITE(EDRV_REGDW_TSAD2, 0);
-    dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TSAD2);
-    EDRV_REGDW_WRITE(EDRV_REGDW_TSAD3, 0);
-    dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TSAD3);
-
-    printk("    Command = 0x%02X\n", (WORD) EDRV_REGB_READ(EDRV_REGB_COMMAND));
-
-    // set pointer for receive buffer in controller
-    printk("%s set pointer to Rx buffer\n", __FUNCTION__);
-    EDRV_REGDW_WRITE(EDRV_REGDW_RBSTART, EdrvInstance_l.m_pRxBufDma);
-
-    // enable transmitter and receiver
-    printk("%s enable Tx and Rx", __FUNCTION__);
-    EDRV_REGB_WRITE(EDRV_REGB_COMMAND, (EDRV_REGB_COMMAND_RE | EDRV_REGB_COMMAND_TE));
-    printk("  Command = 0x%02X\n", (WORD) EDRV_REGB_READ(EDRV_REGB_COMMAND));
-
-    // clear missed packet counter to enable Rx/Tx process
-    EDRV_REGDW_WRITE(EDRV_REGDW_MPC, 0);
-
-    // set transmit configuration register
-    printk("%s set Tx conf register", __FUNCTION__);
-    EDRV_REGDW_WRITE(EDRV_REGDW_TCR, EDRV_REGDW_TCR_DEF);
-    printk(" = 0x%08X\n", EDRV_REGDW_READ(EDRV_REGDW_TCR));
-
-    // set receive configuration register
-    printk("%s set Rx conf register", __FUNCTION__);
-    EDRV_REGDW_WRITE(EDRV_REGDW_RCR, EDRV_REGDW_RCR_DEF);
-    printk(" = 0x%08X\n", EDRV_REGDW_READ(EDRV_REGDW_RCR));
-
-    // reset multicast MAC address filter
-    EDRV_REGDW_WRITE(EDRV_REGDW_MAR0, 0);
-    dwTemp = EDRV_REGDW_READ(EDRV_REGDW_MAR0);
-    EDRV_REGDW_WRITE(EDRV_REGDW_MAR4, 0);
-    dwTemp = EDRV_REGDW_READ(EDRV_REGDW_MAR4);
+	// allocate buffers
+	printk("%s allocate buffers\n", __FUNCTION__);
+	EdrvInstance_l.m_pbTxBuf =
+	    pci_alloc_consistent(pPciDev, EDRV_TX_BUFFER_SIZE,
+				 &EdrvInstance_l.m_pTxBufDma);
+	if (EdrvInstance_l.m_pbTxBuf == NULL) {
+		iResult = -ENOMEM;
+		goto Exit;
+	}
+
+	EdrvInstance_l.m_pbRxBuf =
+	    pci_alloc_consistent(pPciDev, EDRV_RX_BUFFER_SIZE,
+				 &EdrvInstance_l.m_pRxBufDma);
+	if (EdrvInstance_l.m_pbRxBuf == NULL) {
+		iResult = -ENOMEM;
+		goto Exit;
+	}
+	// reset pointers for Tx buffers
+	printk("%s reset pointers fo Tx buffers\n", __FUNCTION__);
+	EDRV_REGDW_WRITE(EDRV_REGDW_TSAD0, 0);
+	dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TSAD0);
+	EDRV_REGDW_WRITE(EDRV_REGDW_TSAD1, 0);
+	dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TSAD1);
+	EDRV_REGDW_WRITE(EDRV_REGDW_TSAD2, 0);
+	dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TSAD2);
+	EDRV_REGDW_WRITE(EDRV_REGDW_TSAD3, 0);
+	dwTemp = EDRV_REGDW_READ(EDRV_REGDW_TSAD3);
+
+	printk("    Command = 0x%02X\n",
+	       (WORD) EDRV_REGB_READ(EDRV_REGB_COMMAND));
+
+	// set pointer for receive buffer in controller
+	printk("%s set pointer to Rx buffer\n", __FUNCTION__);
+	EDRV_REGDW_WRITE(EDRV_REGDW_RBSTART, EdrvInstance_l.m_pRxBufDma);
+
+	// enable transmitter and receiver
+	printk("%s enable Tx and Rx", __FUNCTION__);
+	EDRV_REGB_WRITE(EDRV_REGB_COMMAND,
+			(EDRV_REGB_COMMAND_RE | EDRV_REGB_COMMAND_TE));
+	printk("  Command = 0x%02X\n",
+	       (WORD) EDRV_REGB_READ(EDRV_REGB_COMMAND));
+
+	// clear missed packet counter to enable Rx/Tx process
+	EDRV_REGDW_WRITE(EDRV_REGDW_MPC, 0);
+
+	// set transmit configuration register
+	printk("%s set Tx conf register", __FUNCTION__);
+	EDRV_REGDW_WRITE(EDRV_REGDW_TCR, EDRV_REGDW_TCR_DEF);
+	printk(" = 0x%08X\n", EDRV_REGDW_READ(EDRV_REGDW_TCR));
+
+	// set receive configuration register
+	printk("%s set Rx conf register", __FUNCTION__);
+	EDRV_REGDW_WRITE(EDRV_REGDW_RCR, EDRV_REGDW_RCR_DEF);
+	printk(" = 0x%08X\n", EDRV_REGDW_READ(EDRV_REGDW_RCR));
+
+	// reset multicast MAC address filter
+	EDRV_REGDW_WRITE(EDRV_REGDW_MAR0, 0);
+	dwTemp = EDRV_REGDW_READ(EDRV_REGDW_MAR0);
+	EDRV_REGDW_WRITE(EDRV_REGDW_MAR4, 0);
+	dwTemp = EDRV_REGDW_READ(EDRV_REGDW_MAR4);
 
 /*
     // enable transmitter and receiver
@@ -1178,20 +1125,18 @@ DWORD   dwTemp;
     EDRV_REGB_WRITE(EDRV_REGB_COMMAND, (EDRV_REGB_COMMAND_RE | EDRV_REGB_COMMAND_TE));
     printk("  Command = 0x%02X\n", (WORD) EDRV_REGB_READ(EDRV_REGB_COMMAND));
 */
-    // disable early interrupts
-    EDRV_REGW_WRITE(EDRV_REGW_MULINT, 0);
-
-    // enable interrupts
-    printk("%s enable interrupts\n", __FUNCTION__);
-    EDRV_REGW_WRITE(EDRV_REGW_INT_MASK, EDRV_REGW_INT_MASK_DEF);
-
+	// disable early interrupts
+	EDRV_REGW_WRITE(EDRV_REGW_MULINT, 0);
 
-Exit:
-    printk("%s finished with %d\n", __FUNCTION__, iResult);
-    return iResult;
+	// enable interrupts
+	printk("%s enable interrupts\n", __FUNCTION__);
+	EDRV_REGW_WRITE(EDRV_REGW_INT_MASK, EDRV_REGW_INT_MASK_DEF);
+
+      Exit:
+	printk("%s finished with %d\n", __FUNCTION__, iResult);
+	return iResult;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EdrvRemoveOne
@@ -1209,55 +1154,48 @@ Exit:
 static void EdrvRemoveOne(struct pci_dev *pPciDev)
 {
 
-    if (EdrvInstance_l.m_pPciDev != pPciDev)
-    {   // trying to remove unknown device
-        BUG_ON(EdrvInstance_l.m_pPciDev != pPciDev);
-        goto Exit;
-    }
-
-    // disable transmitter and receiver
-    EDRV_REGB_WRITE(EDRV_REGB_COMMAND, 0);
-
-    // disable interrupts
-    EDRV_REGW_WRITE(EDRV_REGW_INT_MASK, 0);
-
-    // remove interrupt handler
-    free_irq(pPciDev->irq, pPciDev);
-
-
-    // free buffers
-    if (EdrvInstance_l.m_pbTxBuf != NULL)
-    {
-        pci_free_consistent(pPciDev, EDRV_TX_BUFFER_SIZE,
-                     EdrvInstance_l.m_pbTxBuf, EdrvInstance_l.m_pTxBufDma);
-        EdrvInstance_l.m_pbTxBuf = NULL;
-    }
-
-    if (EdrvInstance_l.m_pbRxBuf != NULL)
-    {
-        pci_free_consistent(pPciDev, EDRV_RX_BUFFER_SIZE,
-                     EdrvInstance_l.m_pbRxBuf, EdrvInstance_l.m_pRxBufDma);
-        EdrvInstance_l.m_pbRxBuf = NULL;
-    }
+	if (EdrvInstance_l.m_pPciDev != pPciDev) {	// trying to remove unknown device
+		BUG_ON(EdrvInstance_l.m_pPciDev != pPciDev);
+		goto Exit;
+	}
+	// disable transmitter and receiver
+	EDRV_REGB_WRITE(EDRV_REGB_COMMAND, 0);
+
+	// disable interrupts
+	EDRV_REGW_WRITE(EDRV_REGW_INT_MASK, 0);
+
+	// remove interrupt handler
+	free_irq(pPciDev->irq, pPciDev);
+
+	// free buffers
+	if (EdrvInstance_l.m_pbTxBuf != NULL) {
+		pci_free_consistent(pPciDev, EDRV_TX_BUFFER_SIZE,
+				    EdrvInstance_l.m_pbTxBuf,
+				    EdrvInstance_l.m_pTxBufDma);
+		EdrvInstance_l.m_pbTxBuf = NULL;
+	}
+
+	if (EdrvInstance_l.m_pbRxBuf != NULL) {
+		pci_free_consistent(pPciDev, EDRV_RX_BUFFER_SIZE,
+				    EdrvInstance_l.m_pbRxBuf,
+				    EdrvInstance_l.m_pRxBufDma);
+		EdrvInstance_l.m_pbRxBuf = NULL;
+	}
+	// unmap controller's register space
+	if (EdrvInstance_l.m_pIoAddr != NULL) {
+		iounmap(EdrvInstance_l.m_pIoAddr);
+	}
+	// disable the PCI device
+	pci_disable_device(pPciDev);
 
-    // unmap controller's register space
-    if (EdrvInstance_l.m_pIoAddr != NULL)
-    {
-        iounmap(EdrvInstance_l.m_pIoAddr);
-    }
+	// release memory regions
+	pci_release_regions(pPciDev);
 
-    // disable the PCI device
-    pci_disable_device(pPciDev);
+	EdrvInstance_l.m_pPciDev = NULL;
 
-    // release memory regions
-    pci_release_regions(pPciDev);
-
-    EdrvInstance_l.m_pPciDev = NULL;
-
-Exit:;
+      Exit:;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EdrvCalcHash
@@ -1272,46 +1210,43 @@ Exit:;
 // State:
 //
 //---------------------------------------------------------------------------
-#define HASH_BITS              6  // used bits in hash
-#define CRC32_POLY    0x04C11DB6  //
+#define HASH_BITS              6	// used bits in hash
+#define CRC32_POLY    0x04C11DB6	//
 //#define CRC32_POLY    0xEDB88320  //
 // G(x) = x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 + x7 + x5 + x4 + x2 + x + 1
 
-static BYTE EdrvCalcHash (BYTE * pbMAC_p)
+static BYTE EdrvCalcHash(BYTE * pbMAC_p)
 {
-DWORD dwByteCounter;
-DWORD dwBitCounter;
-DWORD dwData;
-DWORD dwCrc;
-DWORD dwCarry;
-BYTE * pbData;
-BYTE bHash;
-
-    pbData = pbMAC_p;
-
-    // calculate crc32 value of mac address
-    dwCrc = 0xFFFFFFFF;
-
-    for (dwByteCounter = 0; dwByteCounter < 6; dwByteCounter++)
-    {
-        dwData = *pbData;
-        pbData++;
-        for (dwBitCounter = 0; dwBitCounter < 8; dwBitCounter++, dwData >>= 1)
-        {
-            dwCarry = (((dwCrc >> 31) ^ dwData) & 1);
-            dwCrc = dwCrc << 1;
-            if (dwCarry != 0)
-            {
-                dwCrc = (dwCrc ^ CRC32_POLY) | dwCarry;
-            }
-        }
-    }
+	DWORD dwByteCounter;
+	DWORD dwBitCounter;
+	DWORD dwData;
+	DWORD dwCrc;
+	DWORD dwCarry;
+	BYTE *pbData;
+	BYTE bHash;
+
+	pbData = pbMAC_p;
+
+	// calculate crc32 value of mac address
+	dwCrc = 0xFFFFFFFF;
+
+	for (dwByteCounter = 0; dwByteCounter < 6; dwByteCounter++) {
+		dwData = *pbData;
+		pbData++;
+		for (dwBitCounter = 0; dwBitCounter < 8;
+		     dwBitCounter++, dwData >>= 1) {
+			dwCarry = (((dwCrc >> 31) ^ dwData) & 1);
+			dwCrc = dwCrc << 1;
+			if (dwCarry != 0) {
+				dwCrc = (dwCrc ^ CRC32_POLY) | dwCarry;
+			}
+		}
+	}
 
 //    printk("MyCRC = 0x%08lX\n", dwCrc);
-    // only upper 6 bits (HASH_BITS) are used
-    // which point to specific bit in the hash registers
-    bHash = (BYTE)((dwCrc >> (32 - HASH_BITS)) & 0x3f);
+	// only upper 6 bits (HASH_BITS) are used
+	// which point to specific bit in the hash registers
+	bHash = (BYTE) ((dwCrc >> (32 - HASH_BITS)) & 0x3f);
 
-    return bHash;
+	return bHash;
 }
-
--- a/drivers/staging/epl/EplApiGeneric.c
+++ b/drivers/staging/epl/EplApiGeneric.c
@@ -91,12 +91,10 @@
 
 #include "SharedBuff.h"
 
-
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) == 0)
 #error "EPL API layer needs EPL module OBDK!"
 #endif
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -121,7 +119,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -135,7 +132,6 @@
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -150,9 +146,8 @@
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    tEplApiInitParam    m_InitParam;
+typedef struct {
+	tEplApiInitParam m_InitParam;
 
 } tEplApiInstance;
 
@@ -160,15 +155,15 @@ typedef struct
 // local vars
 //---------------------------------------------------------------------------
 
-static tEplApiInstance  EplApiInstance_g;
-
+static tEplApiInstance EplApiInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
 // NMT state change event callback function
-static tEplKernel PUBLIC EplApiCbNmtStateChange(tEplEventNmtStateChange NmtStateChange_p);
+static tEplKernel PUBLIC EplApiCbNmtStateChange(tEplEventNmtStateChange
+						NmtStateChange_p);
 
 // update DLL configuration from OD
 static tEplKernel PUBLIC EplApiUpdateDllConfig(BOOL fUpdateIdentity_p);
@@ -177,35 +172,34 @@ static tEplKernel PUBLIC EplApiUpdateDll
 static tEplKernel PUBLIC EplApiUpdateObd(void);
 
 // process events from user event queue
-static tEplKernel PUBLIC EplApiProcessEvent(tEplEvent* pEplEvent_p);
+static tEplKernel PUBLIC EplApiProcessEvent(tEplEvent * pEplEvent_p);
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
 // callback function of SDO module
-static tEplKernel PUBLIC  EplApiCbSdoCon(tEplSdoComFinished* pSdoComFinished_p);
+static tEplKernel PUBLIC EplApiCbSdoCon(tEplSdoComFinished * pSdoComFinished_p);
 #endif
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 // callback functions of NmtMnu module
-static tEplKernel PUBLIC  EplApiCbNodeEvent(unsigned int uiNodeId_p,
-                                            tEplNmtNodeEvent NodeEvent_p,
-                                            tEplNmtState NmtState_p,
-                                            WORD wErrorCode_p,
-                                            BOOL fMandatory_p);
-
-static tEplKernel PUBLIC  EplApiCbBootEvent(tEplNmtBootEvent BootEvent_p,
-                                            tEplNmtState NmtState_p,
-                                            WORD wErrorCode_p);
+static tEplKernel PUBLIC EplApiCbNodeEvent(unsigned int uiNodeId_p,
+					   tEplNmtNodeEvent NodeEvent_p,
+					   tEplNmtState NmtState_p,
+					   WORD wErrorCode_p,
+					   BOOL fMandatory_p);
+
+static tEplKernel PUBLIC EplApiCbBootEvent(tEplNmtBootEvent BootEvent_p,
+					   tEplNmtState NmtState_p,
+					   WORD wErrorCode_p);
 #endif
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_LEDU)) != 0)
 // callback function of Ledu module
-static tEplKernel PUBLIC  EplApiCbLedStateChange(tEplLedType LedType_p,
-                                                 BOOL fOn_p);
+static tEplKernel PUBLIC EplApiCbLedStateChange(tEplLedType LedType_p,
+						BOOL fOn_p);
 #endif
 
 // OD initialization function (implemented in Objdict.c)
-tEplKernel PUBLIC  EplObdInitRam (tEplObdInitParam MEM* pInitParam_p);
-
+tEplKernel PUBLIC EplObdInitRam(tEplObdInitParam MEM * pInitParam_p);
 
 //=========================================================================//
 //                                                                         //
@@ -234,27 +228,27 @@ tEplKernel PUBLIC  EplObdInitRam (tEplOb
 
 tEplKernel PUBLIC EplApiInitialize(tEplApiInitParam * pInitParam_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplObdInitParam    ObdInitParam;
-tEplDllkInitParam   DllkInitParam;
+	tEplKernel Ret = kEplSuccessful;
+	tEplObdInitParam ObdInitParam;
+	tEplDllkInitParam DllkInitParam;
 #ifndef EPL_NO_FIFO
-    tShbError           ShbError;
+	tShbError ShbError;
 #endif
 
-    // reset instance structure
-    EPL_MEMSET(&EplApiInstance_g, 0, sizeof (EplApiInstance_g));
+	// reset instance structure
+	EPL_MEMSET(&EplApiInstance_g, 0, sizeof(EplApiInstance_g));
 
-    EPL_MEMCPY(&EplApiInstance_g.m_InitParam, pInitParam_p, min(sizeof (tEplApiInitParam), pInitParam_p->m_uiSizeOfStruct));
-
-    // check event callback function pointer
-    if (EplApiInstance_g.m_InitParam.m_pfnCbEvent == NULL)
-    {   // application must always have an event callback function
-        Ret = kEplApiInvalidParam;
-        goto Exit;
-    }
+	EPL_MEMCPY(&EplApiInstance_g.m_InitParam, pInitParam_p,
+		   min(sizeof(tEplApiInitParam),
+		       pInitParam_p->m_uiSizeOfStruct));
 
+	// check event callback function pointer
+	if (EplApiInstance_g.m_InitParam.m_pfnCbEvent == NULL) {	// application must always have an event callback function
+		Ret = kEplApiInvalidParam;
+		goto Exit;
+	}
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    // init OD
+	// init OD
 // FIXME
 //    Ret = EplObdInitRam(&ObdInitParam);
 //    if (Ret != kEplSuccessful)
@@ -262,177 +256,148 @@ tEplDllkInitParam   DllkInitParam;
 //        goto Exit;
 //    }
 
-    // initialize EplObd module
-    Ret = EplObdInit(&ObdInitParam);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	// initialize EplObd module
+	Ret = EplObdInit(&ObdInitParam);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
 #ifndef EPL_NO_FIFO
-    ShbError = ShbInit();
-    if (ShbError != kShbOk)
-    {
-        Ret = kEplNoResource;
-        goto Exit;
-    }
-#endif
-
-    // initialize EplEventk module
-    Ret = EplEventkInit(EplApiInstance_g.m_InitParam.m_pfnCbSync);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // initialize EplEventu module
-    Ret = EplEventuInit(EplApiProcessEvent);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // init EplTimerk module
-    Ret = EplTimerkInit();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // initialize EplNmtk module before DLL
+	ShbError = ShbInit();
+	if (ShbError != kShbOk) {
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+#endif
+
+	// initialize EplEventk module
+	Ret = EplEventkInit(EplApiInstance_g.m_InitParam.m_pfnCbSync);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// initialize EplEventu module
+	Ret = EplEventuInit(EplApiProcessEvent);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// init EplTimerk module
+	Ret = EplTimerkInit();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// initialize EplNmtk module before DLL
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTK)) != 0)
-    Ret = EplNmtkInit();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	Ret = EplNmtkInit();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-    // initialize EplDllk module
+	// initialize EplDllk module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-    EPL_MEMCPY(DllkInitParam.m_be_abSrcMac, EplApiInstance_g.m_InitParam.m_abMacAddress, 6);
-    Ret = EplDllkAddInstance(&DllkInitParam);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // initialize EplErrorHandlerk module
-    Ret = EplErrorHandlerkInit();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // initialize EplDllkCal module
-    Ret = EplDllkCalAddInstance();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	EPL_MEMCPY(DllkInitParam.m_be_abSrcMac,
+		   EplApiInstance_g.m_InitParam.m_abMacAddress, 6);
+	Ret = EplDllkAddInstance(&DllkInitParam);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// initialize EplErrorHandlerk module
+	Ret = EplErrorHandlerkInit();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// initialize EplDllkCal module
+	Ret = EplDllkCalAddInstance();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-    // initialize EplDlluCal module
+	// initialize EplDlluCal module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
-    Ret = EplDlluCalAddInstance();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
+	Ret = EplDlluCalAddInstance();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-    // initialize EplPdok module
+	// initialize EplPdok module
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
-    Ret = EplPdokAddInstance();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    Ret = EplPdokCalAddInstance();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
+	Ret = EplPdokAddInstance();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	Ret = EplPdokCalAddInstance();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-    // initialize EplNmtCnu module
+	// initialize EplNmtCnu module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_CN)) != 0)
-    Ret = EplNmtCnuAddInstance(EplApiInstance_g.m_InitParam.m_uiNodeId);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	Ret = EplNmtCnuAddInstance(EplApiInstance_g.m_InitParam.m_uiNodeId);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-    // initialize EplNmtu module
+	// initialize EplNmtu module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTU)) != 0)
-    Ret = EplNmtuInit();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // register NMT event callback function
-    Ret = EplNmtuRegisterStateChangeCb(EplApiCbNmtStateChange);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	Ret = EplNmtuInit();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// register NMT event callback function
+	Ret = EplNmtuRegisterStateChangeCb(EplApiCbNmtStateChange);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    // initialize EplNmtMnu module
-    Ret = EplNmtMnuInit(EplApiCbNodeEvent, EplApiCbBootEvent);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // initialize EplIdentu module
-    Ret = EplIdentuInit();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // initialize EplStatusu module
-    Ret = EplStatusuInit();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	// initialize EplNmtMnu module
+	Ret = EplNmtMnuInit(EplApiCbNodeEvent, EplApiCbBootEvent);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// initialize EplIdentu module
+	Ret = EplIdentuInit();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// initialize EplStatusu module
+	Ret = EplStatusuInit();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-    // initialize EplLedu module
+	// initialize EplLedu module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_LEDU)) != 0)
-    Ret = EplLeduInit(EplApiCbLedStateChange);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	Ret = EplLeduInit(EplApiCbLedStateChange);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-    // init SDO module
+	// init SDO module
 #if ((((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0) || \
      (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0))
-    // init sdo command layer
-    Ret = EplSdoComInit();
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	// init sdo command layer
+	Ret = EplSdoComInit();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-    // the application must start NMT state machine
-    // via EplApiExecNmtCommand(kEplNmtEventSwReset)
-    // and thereby the whole EPL stack
+	// the application must start NMT state machine
+	// via EplApiExecNmtCommand(kEplNmtEventSwReset)
+	// and thereby the whole EPL stack
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -452,98 +417,97 @@ Exit:
 
 tEplKernel PUBLIC EplApiShutdown(void)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    // $$$ d.k.: check if NMT state is NMT_GS_OFF
+	// $$$ d.k.: check if NMT state is NMT_GS_OFF
 
-    // $$$ d.k.: maybe delete event queues at first, but this implies that
-    //           no other module must not use the event queues for communication
-    //           during shutdown.
+	// $$$ d.k.: maybe delete event queues at first, but this implies that
+	//           no other module must not use the event queues for communication
+	//           during shutdown.
 
-    // delete instance for all modules
+	// delete instance for all modules
 
-    // deinitialize EplSdoCom module
+	// deinitialize EplSdoCom module
 #if ((((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0) || \
      (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0))
-    Ret = EplSdoComDelInstance();
+	Ret = EplSdoComDelInstance();
 //    PRINTF1("EplSdoComDelInstance():  0x%X\n", Ret);
 #endif
 
-    // deinitialize EplLedu module
+	// deinitialize EplLedu module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_LEDU)) != 0)
-    Ret = EplLeduDelInstance();
+	Ret = EplLeduDelInstance();
 //    PRINTF1("EplLeduDelInstance():    0x%X\n", Ret);
 #endif
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    // deinitialize EplNmtMnu module
-    Ret = EplNmtMnuDelInstance();
+	// deinitialize EplNmtMnu module
+	Ret = EplNmtMnuDelInstance();
 //    PRINTF1("EplNmtMnuDelInstance():  0x%X\n", Ret);
 
-    // deinitialize EplIdentu module
-    Ret = EplIdentuDelInstance();
+	// deinitialize EplIdentu module
+	Ret = EplIdentuDelInstance();
 //    PRINTF1("EplIdentuDelInstance():  0x%X\n", Ret);
 
-    // deinitialize EplStatusu module
-    Ret = EplStatusuDelInstance();
+	// deinitialize EplStatusu module
+	Ret = EplStatusuDelInstance();
 //    PRINTF1("EplStatusuDelInstance():  0x%X\n", Ret);
 #endif
 
-    // deinitialize EplNmtCnu module
+	// deinitialize EplNmtCnu module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_CN)) != 0)
-    Ret = EplNmtCnuDelInstance();
+	Ret = EplNmtCnuDelInstance();
 //    PRINTF1("EplNmtCnuDelInstance():  0x%X\n", Ret);
 #endif
 
-    // deinitialize EplNmtu module
+	// deinitialize EplNmtu module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTU)) != 0)
-    Ret = EplNmtuDelInstance();
+	Ret = EplNmtuDelInstance();
 //    PRINTF1("EplNmtuDelInstance():    0x%X\n", Ret);
 #endif
 
-    // deinitialize EplDlluCal module
+	// deinitialize EplDlluCal module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
-    Ret = EplDlluCalDelInstance();
+	Ret = EplDlluCalDelInstance();
 //    PRINTF1("EplDlluCalDelInstance(): 0x%X\n", Ret);
 
 #endif
 
-    // deinitialize EplEventu module
-    Ret = EplEventuDelInstance();
+	// deinitialize EplEventu module
+	Ret = EplEventuDelInstance();
 //    PRINTF1("EplEventuDelInstance():  0x%X\n", Ret);
 
-    // deinitialize EplNmtk module
+	// deinitialize EplNmtk module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTK)) != 0)
-    Ret = EplNmtkDelInstance();
+	Ret = EplNmtkDelInstance();
 //    PRINTF1("EplNmtkDelInstance():    0x%X\n", Ret);
 #endif
 
-    // deinitialize EplDllk module
+	// deinitialize EplDllk module
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-    Ret = EplDllkDelInstance();
+	Ret = EplDllkDelInstance();
 //    PRINTF1("EplDllkDelInstance():    0x%X\n", Ret);
 
-    // deinitialize EplDllkCal module
-    Ret = EplDllkCalDelInstance();
+	// deinitialize EplDllkCal module
+	Ret = EplDllkCalDelInstance();
 //    PRINTF1("EplDllkCalDelInstance(): 0x%X\n", Ret);
 #endif
 
-    // deinitialize EplEventk module
-    Ret = EplEventkDelInstance();
+	// deinitialize EplEventk module
+	Ret = EplEventkDelInstance();
 //    PRINTF1("EplEventkDelInstance():  0x%X\n", Ret);
 
-    // deinitialize EplTimerk module
-    Ret = EplTimerkDelInstance();
+	// deinitialize EplTimerk module
+	Ret = EplTimerkDelInstance();
 //    PRINTF1("EplTimerkDelInstance():  0x%X\n", Ret);
 
 #ifndef EPL_NO_FIFO
-    ShbExit();
+	ShbExit();
 #endif
 
-    return Ret;
+	return Ret;
 }
 
-
 //----------------------------------------------------------------------------
 // Function:    EplApiExecNmtCommand()
 //
@@ -561,16 +525,15 @@ tEplKernel      Ret = kEplSuccessful;
 
 tEplKernel PUBLIC EplApiExecNmtCommand(tEplNmtEvent NmtEvent_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTU)) != 0)
-    Ret = EplNmtuNmtEvent(NmtEvent_p);
+	Ret = EplNmtuNmtEvent(NmtEvent_p);
 #endif
 
-    return Ret;
+	return Ret;
 }
 
-
 //----------------------------------------------------------------------------
 // Function:    EplApiLinkObject()
 //
@@ -590,122 +553,107 @@ tEplKernel      Ret = kEplSuccessful;
 // State:
 //----------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplApiLinkObject( unsigned int    uiObjIndex_p,
-                                    void*           pVar_p,
-                                    unsigned int*   puiVarEntries_p,
-                                    tEplObdSize*    pEntrySize_p,
-                                    unsigned int    uiFirstSubindex_p)
+tEplKernel PUBLIC EplApiLinkObject(unsigned int uiObjIndex_p,
+				   void *pVar_p,
+				   unsigned int *puiVarEntries_p,
+				   tEplObdSize * pEntrySize_p,
+				   unsigned int uiFirstSubindex_p)
 {
-BYTE            bVarEntries;
-BYTE            bIndexEntries;
-BYTE MEM*       pbData;
-unsigned int    uiSubindex;
-tEplVarParam    VarParam;
-tEplObdSize     EntrySize;
-tEplObdSize     UsedSize;
-
-tEplKernel      RetCode = kEplSuccessful;
-
-    if ((pVar_p == NULL)
-        || (puiVarEntries_p == NULL)
-        || (*puiVarEntries_p == 0)
-        || (pEntrySize_p == NULL))
-    {
-        RetCode = kEplApiInvalidParam;
-        goto Exit;
-    }
+	BYTE bVarEntries;
+	BYTE bIndexEntries;
+	BYTE MEM *pbData;
+	unsigned int uiSubindex;
+	tEplVarParam VarParam;
+	tEplObdSize EntrySize;
+	tEplObdSize UsedSize;
+
+	tEplKernel RetCode = kEplSuccessful;
+
+	if ((pVar_p == NULL)
+	    || (puiVarEntries_p == NULL)
+	    || (*puiVarEntries_p == 0)
+	    || (pEntrySize_p == NULL)) {
+		RetCode = kEplApiInvalidParam;
+		goto Exit;
+	}
+
+	pbData = (BYTE MEM *) pVar_p;
+	bVarEntries = (BYTE) * puiVarEntries_p;
+	UsedSize = 0;
+
+	// init VarParam structure with default values
+	VarParam.m_uiIndex = uiObjIndex_p;
+	VarParam.m_ValidFlag = kVarValidAll;
+
+	if (uiFirstSubindex_p != 0) {	// check if object exists by reading subindex 0x00,
+		// because user wants to link a variable to a subindex unequal 0x00
+		// read number of entries
+		EntrySize = (tEplObdSize) sizeof(bIndexEntries);
+		RetCode = EplObdReadEntry(uiObjIndex_p,
+					  0x00,
+					  (void GENERIC *)&bIndexEntries,
+					  &EntrySize);
+
+		if ((RetCode != kEplSuccessful) || (bIndexEntries == 0x00)) {
+			// Object doesn't exist or invalid entry number
+			RetCode = kEplObdIndexNotExist;
+			goto Exit;
+		}
+	} else {		// user wants to link a variable to subindex 0x00
+		// that's OK
+		bIndexEntries = 0;
+	}
+
+	// Correct number of entries if number read from OD is greater
+	// than the specified number.
+	// This is done, so that we do not set more entries than subindexes the
+	// object actually has.
+	if ((bIndexEntries > (bVarEntries + uiFirstSubindex_p - 1)) &&
+	    (bVarEntries != 0x00)) {
+		bIndexEntries = (BYTE) (bVarEntries + uiFirstSubindex_p - 1);
+	}
+	// map entries
+	for (uiSubindex = uiFirstSubindex_p; uiSubindex <= bIndexEntries;
+	     uiSubindex++) {
+		// if passed entry size is 0, then get size from OD
+		if (*pEntrySize_p == 0x00) {
+			// read entry size
+			EntrySize = EplObdGetDataSize(uiObjIndex_p, uiSubindex);
+
+			if (EntrySize == 0x00) {
+				// invalid entry size (maybe object doesn't exist or entry of type DOMAIN is empty)
+				RetCode = kEplObdSubindexNotExist;
+				break;
+			}
+		} else {	// use passed entry size
+			EntrySize = *pEntrySize_p;
+		}
+
+		VarParam.m_uiSubindex = uiSubindex;
+
+		// set pointer to user var
+		VarParam.m_Size = EntrySize;
+		VarParam.m_pData = pbData;
+
+		UsedSize += EntrySize;
+		pbData += EntrySize;
+
+		RetCode = EplObdDefineVar(&VarParam);
+		if (RetCode != kEplSuccessful) {
+			break;
+		}
+	}
+
+	// set number of mapped entries and entry size
+	*puiVarEntries_p = ((bIndexEntries - uiFirstSubindex_p) + 1);
+	*pEntrySize_p = UsedSize;
 
-    pbData      = (BYTE MEM*) pVar_p;
-    bVarEntries = (BYTE) *puiVarEntries_p;
-    UsedSize    = 0;
-
-    // init VarParam structure with default values
-    VarParam.m_uiIndex    = uiObjIndex_p;
-    VarParam.m_ValidFlag  = kVarValidAll;
-
-    if (uiFirstSubindex_p != 0)
-    {   // check if object exists by reading subindex 0x00,
-        // because user wants to link a variable to a subindex unequal 0x00
-        // read number of entries
-        EntrySize = (tEplObdSize)  sizeof(bIndexEntries);
-        RetCode = EplObdReadEntry (
-                                uiObjIndex_p,
-                                0x00,
-                                (void GENERIC*) &bIndexEntries,
-                                &EntrySize );
+      Exit:
 
-        if ((RetCode != kEplSuccessful) || (bIndexEntries == 0x00) )
-        {
-            // Object doesn't exist or invalid entry number
-            RetCode = kEplObdIndexNotExist;
-            goto Exit;
-        }
-    }
-    else
-    {   // user wants to link a variable to subindex 0x00
-        // that's OK
-        bIndexEntries = 0;
-    }
-
-    // Correct number of entries if number read from OD is greater
-    // than the specified number.
-    // This is done, so that we do not set more entries than subindexes the
-    // object actually has.
-    if ((bIndexEntries > (bVarEntries + uiFirstSubindex_p - 1)) &&
-        (bVarEntries   != 0x00) )
-    {
-        bIndexEntries = (BYTE) (bVarEntries + uiFirstSubindex_p - 1);
-    }
-
-    // map entries
-    for (uiSubindex = uiFirstSubindex_p; uiSubindex <= bIndexEntries; uiSubindex++)
-    {
-        // if passed entry size is 0, then get size from OD
-        if (*pEntrySize_p == 0x00)
-        {
-            // read entry size
-            EntrySize = EplObdGetDataSize(uiObjIndex_p, uiSubindex);
-
-            if (EntrySize == 0x00)
-            {
-                // invalid entry size (maybe object doesn't exist or entry of type DOMAIN is empty)
-                RetCode = kEplObdSubindexNotExist;
-                break;
-            }
-        }
-        else
-        {   // use passed entry size
-            EntrySize = *pEntrySize_p;
-        }
-
-        VarParam.m_uiSubindex = uiSubindex;
-
-        // set pointer to user var
-        VarParam.m_Size  = EntrySize;
-        VarParam.m_pData = pbData;
-
-        UsedSize += EntrySize;
-        pbData   += EntrySize;
-
-        RetCode = EplObdDefineVar(&VarParam);
-        if (RetCode != kEplSuccessful)
-        {
-            break;
-        }
-    }
-
-    // set number of mapped entries and entry size
-    *puiVarEntries_p = ((bIndexEntries - uiFirstSubindex_p) + 1);
-    *pEntrySize_p = UsedSize;
-
-
-Exit:
-
-    return (RetCode);
+	return (RetCode);
 
 }
 
-
 // ----------------------------------------------------------------------------
 //
 // Function:    EplApiReadObject()
@@ -729,81 +677,71 @@ Exit:
 //
 // ----------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplApiReadObject(
-            tEplSdoComConHdl* pSdoComConHdl_p,
-            unsigned int      uiNodeId_p,
-            unsigned int      uiIndex_p,
-            unsigned int      uiSubindex_p,
-            void*             pDstData_le_p,
-            unsigned int*     puiSize_p,
-            tEplSdoType       SdoType_p,
-            void*             pUserArg_p)
+tEplKernel PUBLIC EplApiReadObject(tEplSdoComConHdl * pSdoComConHdl_p,
+				   unsigned int uiNodeId_p,
+				   unsigned int uiIndex_p,
+				   unsigned int uiSubindex_p,
+				   void *pDstData_le_p,
+				   unsigned int *puiSize_p,
+				   tEplSdoType SdoType_p, void *pUserArg_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    if ((uiIndex_p == 0) || (pDstData_le_p == NULL) || (puiSize_p == NULL) || (*puiSize_p == 0))
-    {
-        Ret = kEplApiInvalidParam;
-        goto Exit;
-    }
-
-    if (uiNodeId_p == 0
-        || uiNodeId_p == EplObdGetNodeId())
-    {   // local OD access can be performed
-    tEplObdSize     ObdSize;
-
-        ObdSize = (tEplObdSize) *puiSize_p;
-        Ret = EplObdReadEntryToLe(uiIndex_p, uiSubindex_p, pDstData_le_p, &ObdSize);
-        *puiSize_p = (unsigned int) ObdSize;
-    }
-    else
-    {   // perform SDO transfer
+	if ((uiIndex_p == 0) || (pDstData_le_p == NULL) || (puiSize_p == NULL)
+	    || (*puiSize_p == 0)) {
+		Ret = kEplApiInvalidParam;
+		goto Exit;
+	}
+
+	if (uiNodeId_p == 0 || uiNodeId_p == EplObdGetNodeId()) {	// local OD access can be performed
+		tEplObdSize ObdSize;
+
+		ObdSize = (tEplObdSize) * puiSize_p;
+		Ret =
+		    EplObdReadEntryToLe(uiIndex_p, uiSubindex_p, pDstData_le_p,
+					&ObdSize);
+		*puiSize_p = (unsigned int)ObdSize;
+	} else {		// perform SDO transfer
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-    tEplSdoComTransParamByIndex TransParamByIndex;
+		tEplSdoComTransParamByIndex TransParamByIndex;
 //    tEplSdoComConHdl            SdoComConHdl;
 
-        // check if application provides space for handle
-        if (pSdoComConHdl_p == NULL)
-        {
-            Ret = kEplApiInvalidParam;
-            goto Exit;
+		// check if application provides space for handle
+		if (pSdoComConHdl_p == NULL) {
+			Ret = kEplApiInvalidParam;
+			goto Exit;
 //            pSdoComConHdl_p = &SdoComConHdl;
-        }
-
-        // init command layer connection
-        Ret = EplSdoComDefineCon(pSdoComConHdl_p,
-                                    uiNodeId_p,  // target node id
-                                    SdoType_p);    // SDO type
-        if ((Ret != kEplSuccessful) && (Ret != kEplSdoComHandleExists))
-        {
-            goto Exit;
-        }
-        TransParamByIndex.m_pData = pDstData_le_p;
-        TransParamByIndex.m_SdoAccessType = kEplSdoAccessTypeRead;
-        TransParamByIndex.m_SdoComConHdl = *pSdoComConHdl_p;
-        TransParamByIndex.m_uiDataSize = *puiSize_p;
-        TransParamByIndex.m_uiIndex = uiIndex_p;
-        TransParamByIndex.m_uiSubindex = uiSubindex_p;
-        TransParamByIndex.m_pfnSdoFinishedCb = EplApiCbSdoCon;
-        TransParamByIndex.m_pUserArg = pUserArg_p;
-
-        Ret = EplSdoComInitTransferByIndex(&TransParamByIndex);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        Ret = kEplApiTaskDeferred;
+		}
+		// init command layer connection
+		Ret = EplSdoComDefineCon(pSdoComConHdl_p, uiNodeId_p,	// target node id
+					 SdoType_p);	// SDO type
+		if ((Ret != kEplSuccessful) && (Ret != kEplSdoComHandleExists)) {
+			goto Exit;
+		}
+		TransParamByIndex.m_pData = pDstData_le_p;
+		TransParamByIndex.m_SdoAccessType = kEplSdoAccessTypeRead;
+		TransParamByIndex.m_SdoComConHdl = *pSdoComConHdl_p;
+		TransParamByIndex.m_uiDataSize = *puiSize_p;
+		TransParamByIndex.m_uiIndex = uiIndex_p;
+		TransParamByIndex.m_uiSubindex = uiSubindex_p;
+		TransParamByIndex.m_pfnSdoFinishedCb = EplApiCbSdoCon;
+		TransParamByIndex.m_pUserArg = pUserArg_p;
+
+		Ret = EplSdoComInitTransferByIndex(&TransParamByIndex);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		Ret = kEplApiTaskDeferred;
 
 #else
-        Ret = kEplApiInvalidParam;
+		Ret = kEplApiInvalidParam;
 #endif
-    }
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 // ----------------------------------------------------------------------------
 //
 // Function:    EplApiWriteObject()
@@ -827,87 +765,76 @@ Exit:
 //
 // ----------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplApiWriteObject(
-            tEplSdoComConHdl* pSdoComConHdl_p,
-            unsigned int      uiNodeId_p,
-            unsigned int      uiIndex_p,
-            unsigned int      uiSubindex_p,
-            void*             pSrcData_le_p,
-            unsigned int      uiSize_p,
-            tEplSdoType       SdoType_p,
-            void*             pUserArg_p)
+tEplKernel PUBLIC EplApiWriteObject(tEplSdoComConHdl * pSdoComConHdl_p,
+				    unsigned int uiNodeId_p,
+				    unsigned int uiIndex_p,
+				    unsigned int uiSubindex_p,
+				    void *pSrcData_le_p,
+				    unsigned int uiSize_p,
+				    tEplSdoType SdoType_p, void *pUserArg_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    if ((uiIndex_p == 0) || (pSrcData_le_p == NULL) || (uiSize_p == 0))
-    {
-        Ret = kEplApiInvalidParam;
-        goto Exit;
-    }
-
-    if (uiNodeId_p == 0
-        || uiNodeId_p == EplObdGetNodeId())
-    {   // local OD access can be performed
-
-        Ret = EplObdWriteEntryFromLe(uiIndex_p, uiSubindex_p, pSrcData_le_p, uiSize_p);
-    }
-    else
-    {   // perform SDO transfer
+	if ((uiIndex_p == 0) || (pSrcData_le_p == NULL) || (uiSize_p == 0)) {
+		Ret = kEplApiInvalidParam;
+		goto Exit;
+	}
+
+	if (uiNodeId_p == 0 || uiNodeId_p == EplObdGetNodeId()) {	// local OD access can be performed
+
+		Ret =
+		    EplObdWriteEntryFromLe(uiIndex_p, uiSubindex_p,
+					   pSrcData_le_p, uiSize_p);
+	} else {		// perform SDO transfer
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-    tEplSdoComTransParamByIndex TransParamByIndex;
+		tEplSdoComTransParamByIndex TransParamByIndex;
 //    tEplSdoComConHdl            SdoComConHdl;
 
-        // check if application provides space for handle
-        if (pSdoComConHdl_p == NULL)
-        {
-            Ret = kEplApiInvalidParam;
-            goto Exit;
+		// check if application provides space for handle
+		if (pSdoComConHdl_p == NULL) {
+			Ret = kEplApiInvalidParam;
+			goto Exit;
 //            pSdoComConHdl_p = &SdoComConHdl;
-        }
-
-        // d.k.: How to recycle command layer connection?
-        //       Try to redefine it, which will return kEplSdoComHandleExists
-        //       and the existing command layer handle.
-        //       If the returned handle is busy, EplSdoComInitTransferByIndex()
-        //       will return with error.
-        // $$$ d.k.: Collisions may occur with Configuration Manager, if both the application and
-        //           Configuration Manager, are trying to communicate with the very same node.
-        //     possible solution: disallow communication by application if Configuration Manager is busy
-
-        // init command layer connection
-        Ret = EplSdoComDefineCon(pSdoComConHdl_p,
-                                    uiNodeId_p,  // target node id
-                                    SdoType_p);    // SDO type
-        if ((Ret != kEplSuccessful) && (Ret != kEplSdoComHandleExists))
-        {
-            goto Exit;
-        }
-        TransParamByIndex.m_pData = pSrcData_le_p;
-        TransParamByIndex.m_SdoAccessType = kEplSdoAccessTypeWrite;
-        TransParamByIndex.m_SdoComConHdl = *pSdoComConHdl_p;
-        TransParamByIndex.m_uiDataSize = uiSize_p;
-        TransParamByIndex.m_uiIndex = uiIndex_p;
-        TransParamByIndex.m_uiSubindex = uiSubindex_p;
-        TransParamByIndex.m_pfnSdoFinishedCb = EplApiCbSdoCon;
-        TransParamByIndex.m_pUserArg = pUserArg_p;
-
-        Ret = EplSdoComInitTransferByIndex(&TransParamByIndex);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        Ret = kEplApiTaskDeferred;
+		}
+		// d.k.: How to recycle command layer connection?
+		//       Try to redefine it, which will return kEplSdoComHandleExists
+		//       and the existing command layer handle.
+		//       If the returned handle is busy, EplSdoComInitTransferByIndex()
+		//       will return with error.
+		// $$$ d.k.: Collisions may occur with Configuration Manager, if both the application and
+		//           Configuration Manager, are trying to communicate with the very same node.
+		//     possible solution: disallow communication by application if Configuration Manager is busy
+
+		// init command layer connection
+		Ret = EplSdoComDefineCon(pSdoComConHdl_p, uiNodeId_p,	// target node id
+					 SdoType_p);	// SDO type
+		if ((Ret != kEplSuccessful) && (Ret != kEplSdoComHandleExists)) {
+			goto Exit;
+		}
+		TransParamByIndex.m_pData = pSrcData_le_p;
+		TransParamByIndex.m_SdoAccessType = kEplSdoAccessTypeWrite;
+		TransParamByIndex.m_SdoComConHdl = *pSdoComConHdl_p;
+		TransParamByIndex.m_uiDataSize = uiSize_p;
+		TransParamByIndex.m_uiIndex = uiIndex_p;
+		TransParamByIndex.m_uiSubindex = uiSubindex_p;
+		TransParamByIndex.m_pfnSdoFinishedCb = EplApiCbSdoCon;
+		TransParamByIndex.m_pUserArg = pUserArg_p;
+
+		Ret = EplSdoComInitTransferByIndex(&TransParamByIndex);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		Ret = kEplApiTaskDeferred;
 
 #else
-        Ret = kEplApiInvalidParam;
+		Ret = kEplApiInvalidParam;
 #endif
-    }
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 // ----------------------------------------------------------------------------
 //
 // Function:    EplApiFreeSdoChannel()
@@ -923,24 +850,22 @@ Exit:
 //
 // ----------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplApiFreeSdoChannel(
-            tEplSdoComConHdl SdoComConHdl_p)
+tEplKernel PUBLIC EplApiFreeSdoChannel(tEplSdoComConHdl SdoComConHdl_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
 
-    // init command layer connection
-    Ret = EplSdoComUndefineCon(SdoComConHdl_p);
+	// init command layer connection
+	Ret = EplSdoComUndefineCon(SdoComConHdl_p);
 
 #else
-    Ret = kEplApiInvalidParam;
+	Ret = kEplApiInvalidParam;
 #endif
 
-    return Ret;
+	return Ret;
 }
 
-
 // ----------------------------------------------------------------------------
 //
 // Function:    EplApiReadLocalObject()
@@ -956,23 +881,21 @@ tEplKernel      Ret = kEplSuccessful;
 //
 // ----------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplApiReadLocalObject(
-            unsigned int      uiIndex_p,
-            unsigned int      uiSubindex_p,
-            void*             pDstData_p,
-            unsigned int*     puiSize_p)
+tEplKernel PUBLIC EplApiReadLocalObject(unsigned int uiIndex_p,
+					unsigned int uiSubindex_p,
+					void *pDstData_p,
+					unsigned int *puiSize_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplObdSize     ObdSize;
+	tEplKernel Ret = kEplSuccessful;
+	tEplObdSize ObdSize;
 
-    ObdSize = (tEplObdSize) *puiSize_p;
-    Ret = EplObdReadEntry(uiIndex_p, uiSubindex_p, pDstData_p, &ObdSize);
-    *puiSize_p = (unsigned int) ObdSize;
+	ObdSize = (tEplObdSize) * puiSize_p;
+	Ret = EplObdReadEntry(uiIndex_p, uiSubindex_p, pDstData_p, &ObdSize);
+	*puiSize_p = (unsigned int)ObdSize;
 
-    return Ret;
+	return Ret;
 }
 
-
 // ----------------------------------------------------------------------------
 //
 // Function:    EplApiWriteLocalObject()
@@ -988,20 +911,20 @@ tEplObdSize     ObdSize;
 //
 // ----------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplApiWriteLocalObject(
-            unsigned int      uiIndex_p,
-            unsigned int      uiSubindex_p,
-            void*             pSrcData_p,
-            unsigned int      uiSize_p)
+tEplKernel PUBLIC EplApiWriteLocalObject(unsigned int uiIndex_p,
+					 unsigned int uiSubindex_p,
+					 void *pSrcData_p,
+					 unsigned int uiSize_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    Ret = EplObdWriteEntry(uiIndex_p, uiSubindex_p, pSrcData_p, (tEplObdSize) uiSize_p);
+	Ret =
+	    EplObdWriteEntry(uiIndex_p, uiSubindex_p, pSrcData_p,
+			     (tEplObdSize) uiSize_p);
 
-    return Ret;
+	return Ret;
 }
 
-
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 // ----------------------------------------------------------------------------
 //
@@ -1017,13 +940,13 @@ tEplKernel      Ret = kEplSuccessful;
 // ----------------------------------------------------------------------------
 
 tEplKernel PUBLIC EplApiMnTriggerStateChange(unsigned int uiNodeId_p,
-                                             tEplNmtNodeCommand  NodeCommand_p)
+					     tEplNmtNodeCommand NodeCommand_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    Ret = EplNmtMnuTriggerStateChange(uiNodeId_p, NodeCommand_p);
+	Ret = EplNmtMnuTriggerStateChange(uiNodeId_p, NodeCommand_p);
 
-    return Ret;
+	return Ret;
 }
 
 #endif // (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
@@ -1043,137 +966,140 @@ tEplKernel      Ret = kEplSuccessful;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplApiCbObdAccess(tEplObdCbParam MEM* pParam_p)
+tEplKernel PUBLIC EplApiCbObdAccess(tEplObdCbParam MEM * pParam_p)
 {
-tEplKernel          Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
 #if (EPL_API_OBD_FORWARD_EVENT != FALSE)
-tEplApiEventArg     EventArg;
+	tEplApiEventArg EventArg;
 
-    // call user callback
-    // must be disabled for EplApiLinuxKernel.c, because of reentrancy problem
-    // for local OD access. This is not so bad as user callback function in
-    // application does not use OD callbacks at the moment.
-    EventArg.m_ObdCbParam = *pParam_p;
-    Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventObdAccess,
-                                                    &EventArg,
-                                                    EplApiInstance_g.m_InitParam.m_pEventUserArg);
-#endif
-
-    switch (pParam_p->m_uiIndex)
-    {
-        //case 0x1006:    // NMT_CycleLen_U32 (valid on reset)
-        case 0x1C14:    // DLL_LossOfFrameTolerance_U32
-        //case 0x1F98:    // NMT_CycleTiming_REC (valid on reset)
-        {
-            if (pParam_p->m_ObdEvent == kEplObdEvPostWrite)
-            {
-                // update DLL configuration
-                Ret = EplApiUpdateDllConfig(FALSE);
-            }
-            break;
-        }
-
-        case 0x1020:    // CFM_VerifyConfiguration_REC.ConfId_U32 != 0
-        {
-            if ((pParam_p->m_ObdEvent == kEplObdEvPostWrite)
-                && (pParam_p->m_uiSubIndex == 3)
-                && (*((DWORD*)pParam_p->m_pArg) != 0))
-            {
-            DWORD   dwVerifyConfInvalid = 0;
-                // set CFM_VerifyConfiguration_REC.VerifyConfInvalid_U32 to 0
-                Ret = EplObdWriteEntry(0x1020, 4, &dwVerifyConfInvalid, 4);
-                // ignore any error because this objekt is optional
-                Ret = kEplSuccessful;
-            }
-            break;
-        }
-
-        case 0x1F9E:    // NMT_ResetCmd_U8
-        {
-            if (pParam_p->m_ObdEvent == kEplObdEvPreWrite)
-            {
-            BYTE    bNmtCommand;
-
-                bNmtCommand = *((BYTE *) pParam_p->m_pArg);
-                // check value range
-                switch ((tEplNmtCommand)bNmtCommand)
-                {
-                    case kEplNmtCmdResetNode:
-                    case kEplNmtCmdResetCommunication:
-                    case kEplNmtCmdResetConfiguration:
-                    case kEplNmtCmdSwReset:
-                    case kEplNmtCmdInvalidService:
-                        // valid command identifier specified
-                        break;
-
-                    default:
-                        pParam_p->m_dwAbortCode = EPL_SDOAC_VALUE_RANGE_EXCEEDED;
-                        Ret = kEplObdAccessViolation;
-                        break;
-                }
-            }
-            else if (pParam_p->m_ObdEvent == kEplObdEvPostWrite)
-            {
-            BYTE    bNmtCommand;
-
-                bNmtCommand = *((BYTE *) pParam_p->m_pArg);
-                // check value range
-                switch ((tEplNmtCommand)bNmtCommand)
-                {
-                    case kEplNmtCmdResetNode:
+	// call user callback
+	// must be disabled for EplApiLinuxKernel.c, because of reentrancy problem
+	// for local OD access. This is not so bad as user callback function in
+	// application does not use OD callbacks at the moment.
+	EventArg.m_ObdCbParam = *pParam_p;
+	Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventObdAccess,
+							&EventArg,
+							EplApiInstance_g.
+							m_InitParam.
+							m_pEventUserArg);
+#endif
+
+	switch (pParam_p->m_uiIndex) {
+		//case 0x1006:    // NMT_CycleLen_U32 (valid on reset)
+	case 0x1C14:		// DLL_LossOfFrameTolerance_U32
+		//case 0x1F98:    // NMT_CycleTiming_REC (valid on reset)
+		{
+			if (pParam_p->m_ObdEvent == kEplObdEvPostWrite) {
+				// update DLL configuration
+				Ret = EplApiUpdateDllConfig(FALSE);
+			}
+			break;
+		}
+
+	case 0x1020:		// CFM_VerifyConfiguration_REC.ConfId_U32 != 0
+		{
+			if ((pParam_p->m_ObdEvent == kEplObdEvPostWrite)
+			    && (pParam_p->m_uiSubIndex == 3)
+			    && (*((DWORD *) pParam_p->m_pArg) != 0)) {
+				DWORD dwVerifyConfInvalid = 0;
+				// set CFM_VerifyConfiguration_REC.VerifyConfInvalid_U32 to 0
+				Ret =
+				    EplObdWriteEntry(0x1020, 4,
+						     &dwVerifyConfInvalid, 4);
+				// ignore any error because this objekt is optional
+				Ret = kEplSuccessful;
+			}
+			break;
+		}
+
+	case 0x1F9E:		// NMT_ResetCmd_U8
+		{
+			if (pParam_p->m_ObdEvent == kEplObdEvPreWrite) {
+				BYTE bNmtCommand;
+
+				bNmtCommand = *((BYTE *) pParam_p->m_pArg);
+				// check value range
+				switch ((tEplNmtCommand) bNmtCommand) {
+				case kEplNmtCmdResetNode:
+				case kEplNmtCmdResetCommunication:
+				case kEplNmtCmdResetConfiguration:
+				case kEplNmtCmdSwReset:
+				case kEplNmtCmdInvalidService:
+					// valid command identifier specified
+					break;
+
+				default:
+					pParam_p->m_dwAbortCode =
+					    EPL_SDOAC_VALUE_RANGE_EXCEEDED;
+					Ret = kEplObdAccessViolation;
+					break;
+				}
+			} else if (pParam_p->m_ObdEvent == kEplObdEvPostWrite) {
+				BYTE bNmtCommand;
+
+				bNmtCommand = *((BYTE *) pParam_p->m_pArg);
+				// check value range
+				switch ((tEplNmtCommand) bNmtCommand) {
+				case kEplNmtCmdResetNode:
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTU)) != 0)
-                        Ret = EplNmtuNmtEvent(kEplNmtEventResetNode);
+					Ret =
+					    EplNmtuNmtEvent
+					    (kEplNmtEventResetNode);
 #endif
-                        break;
+					break;
 
-                    case kEplNmtCmdResetCommunication:
+				case kEplNmtCmdResetCommunication:
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTU)) != 0)
-                        Ret = EplNmtuNmtEvent(kEplNmtEventResetCom);
+					Ret =
+					    EplNmtuNmtEvent
+					    (kEplNmtEventResetCom);
 #endif
-                        break;
+					break;
 
-                    case kEplNmtCmdResetConfiguration:
+				case kEplNmtCmdResetConfiguration:
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTU)) != 0)
-                        Ret = EplNmtuNmtEvent(kEplNmtEventResetConfig);
+					Ret =
+					    EplNmtuNmtEvent
+					    (kEplNmtEventResetConfig);
 #endif
-                        break;
+					break;
 
-                    case kEplNmtCmdSwReset:
+				case kEplNmtCmdSwReset:
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTU)) != 0)
-                        Ret = EplNmtuNmtEvent(kEplNmtEventSwReset);
-#endif
-                        break;
-
-                    case kEplNmtCmdInvalidService:
-                        break;
-
-                    default:
-                        pParam_p->m_dwAbortCode = EPL_SDOAC_VALUE_RANGE_EXCEEDED;
-                        Ret = kEplObdAccessViolation;
-                        break;
-                }
-            }
-            break;
-        }
-
-        default:
-            break;
-    }
+					Ret =
+					    EplNmtuNmtEvent
+					    (kEplNmtEventSwReset);
+#endif
+					break;
+
+				case kEplNmtCmdInvalidService:
+					break;
+
+				default:
+					pParam_p->m_dwAbortCode =
+					    EPL_SDOAC_VALUE_RANGE_EXCEEDED;
+					Ret = kEplObdAccessViolation;
+					break;
+				}
+			}
+			break;
+		}
+
+	default:
+		break;
+	}
 
 //Exit:
-    return Ret;
+	return Ret;
 }
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
 //                                                                         //
 //=========================================================================//
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplApiProcessEvent
@@ -1189,59 +1115,64 @@ tEplApiEventArg     EventArg;
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC EplApiProcessEvent(
-            tEplEvent* pEplEvent_p)
+static tEplKernel PUBLIC EplApiProcessEvent(tEplEvent * pEplEvent_p)
 {
-tEplKernel          Ret;
-tEplEventError*     pEventError;
-tEplApiEventType    EventType;
-
-    Ret = kEplSuccessful;
-
-    // process event
-    switch(pEplEvent_p->m_EventType)
-    {
-        // error event
-        case kEplEventTypeError:
-        {
-            pEventError = (tEplEventError*) pEplEvent_p->m_pArg;
-            switch (pEventError->m_EventSource)
-            {
-                // treat the errors from the following sources as critical
-                case kEplEventSourceEventk:
-                case kEplEventSourceEventu:
-                case kEplEventSourceDllk:
-                {
-                    EventType = kEplApiEventCriticalError;
-                    // halt the stack by entering NMT state Off
-                    Ret = EplNmtuNmtEvent(kEplNmtEventCriticalError);
-                    break;
-                }
-
-                // the other errors are just warnings
-                default:
-                {
-                    EventType = kEplApiEventWarning;
-                    break;
-                }
-            }
-
-            // call user callback
-            Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(EventType, (tEplApiEventArg*) pEventError, EplApiInstance_g.m_InitParam.m_pEventUserArg);
-            // discard error from callback function, because this could generate an endless loop
-            Ret = kEplSuccessful;
-            break;
-        }
-
-        // at present, there are no other events for this module
-        default:
-            break;
-    }
+	tEplKernel Ret;
+	tEplEventError *pEventError;
+	tEplApiEventType EventType;
+
+	Ret = kEplSuccessful;
+
+	// process event
+	switch (pEplEvent_p->m_EventType) {
+		// error event
+	case kEplEventTypeError:
+		{
+			pEventError = (tEplEventError *) pEplEvent_p->m_pArg;
+			switch (pEventError->m_EventSource) {
+				// treat the errors from the following sources as critical
+			case kEplEventSourceEventk:
+			case kEplEventSourceEventu:
+			case kEplEventSourceDllk:
+				{
+					EventType = kEplApiEventCriticalError;
+					// halt the stack by entering NMT state Off
+					Ret =
+					    EplNmtuNmtEvent
+					    (kEplNmtEventCriticalError);
+					break;
+				}
+
+				// the other errors are just warnings
+			default:
+				{
+					EventType = kEplApiEventWarning;
+					break;
+				}
+			}
+
+			// call user callback
+			Ret =
+			    EplApiInstance_g.m_InitParam.m_pfnCbEvent(EventType,
+								      (tEplApiEventArg
+								       *)
+								      pEventError,
+								      EplApiInstance_g.
+								      m_InitParam.
+								      m_pEventUserArg);
+			// discard error from callback function, because this could generate an endless loop
+			Ret = kEplSuccessful;
+			break;
+		}
+
+		// at present, there are no other events for this module
+	default:
+		break;
+	}
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplApiCbNmtStateChange
@@ -1257,221 +1188,212 @@ tEplApiEventType    EventType;
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC EplApiCbNmtStateChange(tEplEventNmtStateChange NmtStateChange_p)
+static tEplKernel PUBLIC EplApiCbNmtStateChange(tEplEventNmtStateChange
+						NmtStateChange_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-BYTE                bNmtState;
-tEplApiEventArg     EventArg;
-
-    // save NMT state in OD
-    bNmtState = (BYTE) NmtStateChange_p.m_NewNmtState;
-    Ret = EplObdWriteEntry(0x1F8C, 0, &bNmtState, 1);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // do work which must be done in that state
-    switch (NmtStateChange_p.m_NewNmtState)
-    {
-        // EPL stack is not running
-        case kEplNmtGsOff:
-            break;
+	tEplKernel Ret = kEplSuccessful;
+	BYTE bNmtState;
+	tEplApiEventArg EventArg;
+
+	// save NMT state in OD
+	bNmtState = (BYTE) NmtStateChange_p.m_NewNmtState;
+	Ret = EplObdWriteEntry(0x1F8C, 0, &bNmtState, 1);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// do work which must be done in that state
+	switch (NmtStateChange_p.m_NewNmtState) {
+		// EPL stack is not running
+	case kEplNmtGsOff:
+		break;
 
-        // first init of the hardware
-        case kEplNmtGsInitialising:
+		// first init of the hardware
+	case kEplNmtGsInitialising:
 #if 0
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
-            // configure SDO via UDP (i.e. bind it to the EPL ethernet interface)
-            Ret = EplSdoUdpuConfig(EplApiInstance_g.m_InitParam.m_dwIpAddress, EPL_C_SDO_EPL_PORT);
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-#endif
-#endif
-
-            break;
-
-        // init of the manufacturer-specific profile area and the
-        // standardised device profile area
-        case kEplNmtGsResetApplication:
-        {
-            // reset application part of OD
-            Ret = EplObdAccessOdPart(
-                kEplObdPartApp,
-                kEplObdDirLoad);
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-
-            break;
-        }
-
-        // init of the communication profile area
-        case kEplNmtGsResetCommunication:
-        {
-            // reset communication part of OD
-            Ret = EplObdAccessOdPart(
-                kEplObdPartGen,
-                kEplObdDirLoad);
-
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-
-            // $$$ d.k.: update OD only if OD was not loaded from non-volatile memory
-            Ret = EplApiUpdateObd();
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-
-            break;
-        }
-
-        // build the configuration with infos from OD
-        case kEplNmtGsResetConfiguration:
-        {
-
-            Ret = EplApiUpdateDllConfig(TRUE);
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-
-            break;
-        }
-
-        //-----------------------------------------------------------
-        // CN part of the state machine
-
-        // node liste for EPL-Frames and check timeout
-        case kEplNmtCsNotActive:
-        {
-            // indicate completion of reset in NMT_ResetCmd_U8
-            bNmtState = (BYTE) kEplNmtCmdInvalidService;
-            Ret = EplObdWriteEntry(0x1F9E, 0, &bNmtState, 1);
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-
-            break;
-        }
-
-        // node process only async frames
-        case kEplNmtCsPreOperational1:
-        {
-            break;
-        }
-
-        // node process isochronus and asynchronus frames
-        case kEplNmtCsPreOperational2:
-        {
-            break;
-        }
-
-        // node should be configured und application is ready
-        case kEplNmtCsReadyToOperate:
-        {
-            break;
-        }
-
-        // normal work state
-        case kEplNmtCsOperational:
-        {
-            break;
-        }
-
-        // node stopped by MN
-        // -> only process asynchronus frames
-        case kEplNmtCsStopped:
-        {
-            break;
-        }
-
-        // no EPL cycle
-        // -> normal ethernet communication
-        case kEplNmtCsBasicEthernet:
-        {
-            break;
-        }
-
-        //-----------------------------------------------------------
-        // MN part of the state machine
-
-        // node listens for EPL-Frames and check timeout
-        case kEplNmtMsNotActive:
-        {
-            break;
-        }
-
-        // node processes only async frames
-        case kEplNmtMsPreOperational1:
-        {
-            break;
-        }
-
-        // node processes isochronous and asynchronous frames
-        case kEplNmtMsPreOperational2:
-        {
-            break;
-        }
-
-        // node should be configured und application is ready
-        case kEplNmtMsReadyToOperate:
-        {
-            break;
-        }
-
-        // normal work state
-        case kEplNmtMsOperational:
-        {
-            break;
-        }
-
-        // no EPL cycle
-        // -> normal ethernet communication
-        case kEplNmtMsBasicEthernet:
-        {
-            break;
-        }
-
-        default:
-        {
-            TRACE0("EplApiCbNmtStateChange(): unhandled NMT state\n");
-        }
-    }
+		// configure SDO via UDP (i.e. bind it to the EPL ethernet interface)
+		Ret =
+		    EplSdoUdpuConfig(EplApiInstance_g.m_InitParam.m_dwIpAddress,
+				     EPL_C_SDO_EPL_PORT);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+#endif
+#endif
+
+		break;
+
+		// init of the manufacturer-specific profile area and the
+		// standardised device profile area
+	case kEplNmtGsResetApplication:
+		{
+			// reset application part of OD
+			Ret = EplObdAccessOdPart(kEplObdPartApp,
+						 kEplObdDirLoad);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+
+			break;
+		}
+
+		// init of the communication profile area
+	case kEplNmtGsResetCommunication:
+		{
+			// reset communication part of OD
+			Ret = EplObdAccessOdPart(kEplObdPartGen,
+						 kEplObdDirLoad);
+
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+			// $$$ d.k.: update OD only if OD was not loaded from non-volatile memory
+			Ret = EplApiUpdateObd();
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+
+			break;
+		}
+
+		// build the configuration with infos from OD
+	case kEplNmtGsResetConfiguration:
+		{
+
+			Ret = EplApiUpdateDllConfig(TRUE);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+
+			break;
+		}
+
+		//-----------------------------------------------------------
+		// CN part of the state machine
+
+		// node liste for EPL-Frames and check timeout
+	case kEplNmtCsNotActive:
+		{
+			// indicate completion of reset in NMT_ResetCmd_U8
+			bNmtState = (BYTE) kEplNmtCmdInvalidService;
+			Ret = EplObdWriteEntry(0x1F9E, 0, &bNmtState, 1);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+
+			break;
+		}
+
+		// node process only async frames
+	case kEplNmtCsPreOperational1:
+		{
+			break;
+		}
+
+		// node process isochronus and asynchronus frames
+	case kEplNmtCsPreOperational2:
+		{
+			break;
+		}
+
+		// node should be configured und application is ready
+	case kEplNmtCsReadyToOperate:
+		{
+			break;
+		}
+
+		// normal work state
+	case kEplNmtCsOperational:
+		{
+			break;
+		}
+
+		// node stopped by MN
+		// -> only process asynchronus frames
+	case kEplNmtCsStopped:
+		{
+			break;
+		}
+
+		// no EPL cycle
+		// -> normal ethernet communication
+	case kEplNmtCsBasicEthernet:
+		{
+			break;
+		}
+
+		//-----------------------------------------------------------
+		// MN part of the state machine
+
+		// node listens for EPL-Frames and check timeout
+	case kEplNmtMsNotActive:
+		{
+			break;
+		}
+
+		// node processes only async frames
+	case kEplNmtMsPreOperational1:
+		{
+			break;
+		}
+
+		// node processes isochronous and asynchronous frames
+	case kEplNmtMsPreOperational2:
+		{
+			break;
+		}
+
+		// node should be configured und application is ready
+	case kEplNmtMsReadyToOperate:
+		{
+			break;
+		}
+
+		// normal work state
+	case kEplNmtMsOperational:
+		{
+			break;
+		}
+
+		// no EPL cycle
+		// -> normal ethernet communication
+	case kEplNmtMsBasicEthernet:
+		{
+			break;
+		}
+
+	default:
+		{
+			TRACE0
+			    ("EplApiCbNmtStateChange(): unhandled NMT state\n");
+		}
+	}
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_LEDU)) != 0)
-    // forward event to Led module
-    Ret = EplLeduCbNmtStateChange(NmtStateChange_p);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	// forward event to Led module
+	Ret = EplLeduCbNmtStateChange(NmtStateChange_p);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    // forward event to NmtMn module
-    Ret = EplNmtMnuCbNmtStateChange(NmtStateChange_p);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-#endif
-
-    // call user callback
-    EventArg.m_NmtStateChange = NmtStateChange_p;
-    Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventNmtStateChange,
-                                                    &EventArg,
-                                                    EplApiInstance_g.m_InitParam.m_pEventUserArg);
+	// forward event to NmtMn module
+	Ret = EplNmtMnuCbNmtStateChange(NmtStateChange_p);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+#endif
+
+	// call user callback
+	EventArg.m_NmtStateChange = NmtStateChange_p;
+	Ret =
+	    EplApiInstance_g.m_InitParam.
+	    m_pfnCbEvent(kEplApiEventNmtStateChange, &EventArg,
+			 EplApiInstance_g.m_InitParam.m_pEventUserArg);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1491,202 +1413,210 @@ Exit:
 
 static tEplKernel PUBLIC EplApiUpdateDllConfig(BOOL fUpdateIdentity_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplDllConfigParam  DllConfigParam;
-tEplDllIdentParam   DllIdentParam;
-tEplObdSize         ObdSize;
-WORD                wTemp;
-BYTE                bTemp;
-
-    // configure Dll
-    EPL_MEMSET(&DllConfigParam, 0, sizeof (DllConfigParam));
-    DllConfigParam.m_uiNodeId = EplObdGetNodeId();
-
-    // Cycle Length (0x1006: NMT_CycleLen_U32) in [us]
-    ObdSize = 4;
-    Ret = EplObdReadEntry(0x1006, 0, &DllConfigParam.m_dwCycleLen, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // 0x1F82: NMT_FeatureFlags_U32
-    ObdSize = 4;
-    Ret = EplObdReadEntry(0x1F82, 0, &DllConfigParam.m_dwFeatureFlags, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // d.k. There is no dependance between FeatureFlags and async-only CN
-    DllConfigParam.m_fAsyncOnly = EplApiInstance_g.m_InitParam.m_fAsyncOnly;
-
-    // 0x1C14: DLL_LossOfFrameTolerance_U32 in [ns]
-    ObdSize = 4;
-    Ret = EplObdReadEntry(0x1C14, 0, &DllConfigParam.m_dwLossOfFrameTolerance, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // 0x1F98: NMT_CycleTiming_REC
-    // 0x1F98.1: IsochrTxMaxPayload_U16
-    ObdSize = 2;
-    Ret = EplObdReadEntry(0x1F98, 1, &wTemp, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-    DllConfigParam.m_uiIsochrTxMaxPayload = wTemp;
-
-    // 0x1F98.2: IsochrRxMaxPayload_U16
-    ObdSize = 2;
-    Ret = EplObdReadEntry(0x1F98, 2, &wTemp, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-    DllConfigParam.m_uiIsochrRxMaxPayload = wTemp;
-
-    // 0x1F98.3: PResMaxLatency_U32
-    ObdSize = 4;
-    Ret = EplObdReadEntry(0x1F98, 3, &DllConfigParam.m_dwPresMaxLatency, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // 0x1F98.4: PReqActPayloadLimit_U16
-    ObdSize = 2;
-    Ret = EplObdReadEntry(0x1F98, 4, &wTemp, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-    DllConfigParam.m_uiPreqActPayloadLimit = wTemp;
-
-    // 0x1F98.5: PResActPayloadLimit_U16
-    ObdSize = 2;
-    Ret = EplObdReadEntry(0x1F98, 5, &wTemp, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-    DllConfigParam.m_uiPresActPayloadLimit = wTemp;
-
-    // 0x1F98.6: ASndMaxLatency_U32
-    ObdSize = 4;
-    Ret = EplObdReadEntry(0x1F98, 6, &DllConfigParam.m_dwAsndMaxLatency, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // 0x1F98.7: MultiplCycleCnt_U8
-    ObdSize = 1;
-    Ret = EplObdReadEntry(0x1F98, 7, &bTemp, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-    DllConfigParam.m_uiMultiplCycleCnt = bTemp;
-
-    // 0x1F98.8: AsyncMTU_U16
-    ObdSize = 2;
-    Ret = EplObdReadEntry(0x1F98, 8, &wTemp, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-    DllConfigParam.m_uiAsyncMtu = wTemp;
+	tEplKernel Ret = kEplSuccessful;
+	tEplDllConfigParam DllConfigParam;
+	tEplDllIdentParam DllIdentParam;
+	tEplObdSize ObdSize;
+	WORD wTemp;
+	BYTE bTemp;
+
+	// configure Dll
+	EPL_MEMSET(&DllConfigParam, 0, sizeof(DllConfigParam));
+	DllConfigParam.m_uiNodeId = EplObdGetNodeId();
+
+	// Cycle Length (0x1006: NMT_CycleLen_U32) in [us]
+	ObdSize = 4;
+	Ret =
+	    EplObdReadEntry(0x1006, 0, &DllConfigParam.m_dwCycleLen, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// 0x1F82: NMT_FeatureFlags_U32
+	ObdSize = 4;
+	Ret =
+	    EplObdReadEntry(0x1F82, 0, &DllConfigParam.m_dwFeatureFlags,
+			    &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// d.k. There is no dependance between FeatureFlags and async-only CN
+	DllConfigParam.m_fAsyncOnly = EplApiInstance_g.m_InitParam.m_fAsyncOnly;
+
+	// 0x1C14: DLL_LossOfFrameTolerance_U32 in [ns]
+	ObdSize = 4;
+	Ret =
+	    EplObdReadEntry(0x1C14, 0, &DllConfigParam.m_dwLossOfFrameTolerance,
+			    &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// 0x1F98: NMT_CycleTiming_REC
+	// 0x1F98.1: IsochrTxMaxPayload_U16
+	ObdSize = 2;
+	Ret = EplObdReadEntry(0x1F98, 1, &wTemp, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	DllConfigParam.m_uiIsochrTxMaxPayload = wTemp;
+
+	// 0x1F98.2: IsochrRxMaxPayload_U16
+	ObdSize = 2;
+	Ret = EplObdReadEntry(0x1F98, 2, &wTemp, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	DllConfigParam.m_uiIsochrRxMaxPayload = wTemp;
+
+	// 0x1F98.3: PResMaxLatency_U32
+	ObdSize = 4;
+	Ret =
+	    EplObdReadEntry(0x1F98, 3, &DllConfigParam.m_dwPresMaxLatency,
+			    &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// 0x1F98.4: PReqActPayloadLimit_U16
+	ObdSize = 2;
+	Ret = EplObdReadEntry(0x1F98, 4, &wTemp, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	DllConfigParam.m_uiPreqActPayloadLimit = wTemp;
+
+	// 0x1F98.5: PResActPayloadLimit_U16
+	ObdSize = 2;
+	Ret = EplObdReadEntry(0x1F98, 5, &wTemp, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	DllConfigParam.m_uiPresActPayloadLimit = wTemp;
+
+	// 0x1F98.6: ASndMaxLatency_U32
+	ObdSize = 4;
+	Ret =
+	    EplObdReadEntry(0x1F98, 6, &DllConfigParam.m_dwAsndMaxLatency,
+			    &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// 0x1F98.7: MultiplCycleCnt_U8
+	ObdSize = 1;
+	Ret = EplObdReadEntry(0x1F98, 7, &bTemp, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	DllConfigParam.m_uiMultiplCycleCnt = bTemp;
+
+	// 0x1F98.8: AsyncMTU_U16
+	ObdSize = 2;
+	Ret = EplObdReadEntry(0x1F98, 8, &wTemp, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	DllConfigParam.m_uiAsyncMtu = wTemp;
 
-    // $$$ Prescaler
+	// $$$ Prescaler
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    // 0x1F8A.1: WaitSoCPReq_U32 in [ns]
-    ObdSize = 4;
-    Ret = EplObdReadEntry(0x1F8A, 1, &DllConfigParam.m_dwWaitSocPreq, &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // 0x1F8A.2: AsyncSlotTimeout_U32 in [ns] (optional)
-    ObdSize = 4;
-    Ret = EplObdReadEntry(0x1F8A, 2, &DllConfigParam.m_dwAsyncSlotTimeout, &ObdSize);
+	// 0x1F8A.1: WaitSoCPReq_U32 in [ns]
+	ObdSize = 4;
+	Ret =
+	    EplObdReadEntry(0x1F8A, 1, &DllConfigParam.m_dwWaitSocPreq,
+			    &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// 0x1F8A.2: AsyncSlotTimeout_U32 in [ns] (optional)
+	ObdSize = 4;
+	Ret =
+	    EplObdReadEntry(0x1F8A, 2, &DllConfigParam.m_dwAsyncSlotTimeout,
+			    &ObdSize);
 /*    if(Ret != kEplSuccessful)
     {
         goto Exit;
     }*/
 #endif
 
-    DllConfigParam.m_uiSizeOfStruct = sizeof (DllConfigParam);
-    Ret = EplDllkConfig(&DllConfigParam);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    if (fUpdateIdentity_p != FALSE)
-    {
-        // configure Identity
-        EPL_MEMSET(&DllIdentParam, 0, sizeof (DllIdentParam));
-        ObdSize = 4;
-        Ret = EplObdReadEntry(0x1000, 0, &DllIdentParam.m_dwDeviceType, &ObdSize);
-        if(Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        ObdSize = 4;
-        Ret = EplObdReadEntry(0x1018, 1, &DllIdentParam.m_dwVendorId, &ObdSize);
-        if(Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        ObdSize = 4;
-        Ret = EplObdReadEntry(0x1018, 2, &DllIdentParam.m_dwProductCode, &ObdSize);
-        if(Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        ObdSize = 4;
-        Ret = EplObdReadEntry(0x1018, 3, &DllIdentParam.m_dwRevisionNumber, &ObdSize);
-        if(Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        ObdSize = 4;
-        Ret = EplObdReadEntry(0x1018, 4, &DllIdentParam.m_dwSerialNumber, &ObdSize);
-        if(Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        DllIdentParam.m_dwIpAddress = EplApiInstance_g.m_InitParam.m_dwIpAddress;
-        DllIdentParam.m_dwSubnetMask = EplApiInstance_g.m_InitParam.m_dwSubnetMask;
-        EPL_MEMCPY(DllIdentParam.m_sHostname, EplApiInstance_g.m_InitParam.m_sHostname, sizeof (DllIdentParam.m_sHostname));
-
-        ObdSize = 4;
-        Ret = EplObdReadEntry(0x1020, 1, &DllIdentParam.m_dwVerifyConfigurationDate, &ObdSize);
-        // ignore any error, because this object is optional
-
-        ObdSize = 4;
-        Ret = EplObdReadEntry(0x1020, 2, &DllIdentParam.m_dwVerifyConfigurationTime, &ObdSize);
-        // ignore any error, because this object is optional
+	DllConfigParam.m_uiSizeOfStruct = sizeof(DllConfigParam);
+	Ret = EplDllkConfig(&DllConfigParam);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	if (fUpdateIdentity_p != FALSE) {
+		// configure Identity
+		EPL_MEMSET(&DllIdentParam, 0, sizeof(DllIdentParam));
+		ObdSize = 4;
+		Ret =
+		    EplObdReadEntry(0x1000, 0, &DllIdentParam.m_dwDeviceType,
+				    &ObdSize);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+
+		ObdSize = 4;
+		Ret =
+		    EplObdReadEntry(0x1018, 1, &DllIdentParam.m_dwVendorId,
+				    &ObdSize);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		ObdSize = 4;
+		Ret =
+		    EplObdReadEntry(0x1018, 2, &DllIdentParam.m_dwProductCode,
+				    &ObdSize);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		ObdSize = 4;
+		Ret =
+		    EplObdReadEntry(0x1018, 3,
+				    &DllIdentParam.m_dwRevisionNumber,
+				    &ObdSize);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		ObdSize = 4;
+		Ret =
+		    EplObdReadEntry(0x1018, 4, &DllIdentParam.m_dwSerialNumber,
+				    &ObdSize);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+
+		DllIdentParam.m_dwIpAddress =
+		    EplApiInstance_g.m_InitParam.m_dwIpAddress;
+		DllIdentParam.m_dwSubnetMask =
+		    EplApiInstance_g.m_InitParam.m_dwSubnetMask;
+		EPL_MEMCPY(DllIdentParam.m_sHostname,
+			   EplApiInstance_g.m_InitParam.m_sHostname,
+			   sizeof(DllIdentParam.m_sHostname));
+
+		ObdSize = 4;
+		Ret =
+		    EplObdReadEntry(0x1020, 1,
+				    &DllIdentParam.m_dwVerifyConfigurationDate,
+				    &ObdSize);
+		// ignore any error, because this object is optional
+
+		ObdSize = 4;
+		Ret =
+		    EplObdReadEntry(0x1020, 2,
+				    &DllIdentParam.m_dwVerifyConfigurationTime,
+				    &ObdSize);
+		// ignore any error, because this object is optional
+
+		// $$$ d.k.: fill rest of ident structure
+
+		DllIdentParam.m_uiSizeOfStruct = sizeof(DllIdentParam);
+		Ret = EplDllkSetIdentity(&DllIdentParam);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+	}
 
-        // $$$ d.k.: fill rest of ident structure
-
-        DllIdentParam.m_uiSizeOfStruct = sizeof (DllIdentParam);
-        Ret = EplDllkSetIdentity(&DllIdentParam);
-        if(Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-    }
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1706,224 +1636,259 @@ Exit:
 
 static tEplKernel PUBLIC EplApiUpdateObd(void)
 {
-tEplKernel          Ret = kEplSuccessful;
-WORD                wTemp;
-BYTE                bTemp;
-
-    // set node id in OD
-    Ret = EplObdSetNodeId(EplApiInstance_g.m_InitParam.m_uiNodeId,    // node id
-                            kEplObdNodeIdHardware); // set by hardware
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    if (EplApiInstance_g.m_InitParam.m_dwCycleLen != -1)
-    {
-        Ret = EplObdWriteEntry(0x1006, 0, &EplApiInstance_g.m_InitParam.m_dwCycleLen, 4);
+	tEplKernel Ret = kEplSuccessful;
+	WORD wTemp;
+	BYTE bTemp;
+
+	// set node id in OD
+	Ret = EplObdSetNodeId(EplApiInstance_g.m_InitParam.m_uiNodeId,	// node id
+			      kEplObdNodeIdHardware);	// set by hardware
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	if (EplApiInstance_g.m_InitParam.m_dwCycleLen != -1) {
+		Ret =
+		    EplObdWriteEntry(0x1006, 0,
+				     &EplApiInstance_g.m_InitParam.m_dwCycleLen,
+				     4);
 /*    if(Ret != kEplSuccessful)
     {
         goto Exit;
     }*/
-    }
+	}
 
-    if (EplApiInstance_g.m_InitParam.m_dwLossOfFrameTolerance != -1)
-    {
-        Ret = EplObdWriteEntry(0x1C14, 0, &EplApiInstance_g.m_InitParam.m_dwLossOfFrameTolerance, 4);
-    /*        if(Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }*/
-    }
+	if (EplApiInstance_g.m_InitParam.m_dwLossOfFrameTolerance != -1) {
+		Ret =
+		    EplObdWriteEntry(0x1C14, 0,
+				     &EplApiInstance_g.m_InitParam.
+				     m_dwLossOfFrameTolerance, 4);
+		/*        if(Ret != kEplSuccessful)
+		   {
+		   goto Exit;
+		   } */
+	}
+	// d.k. There is no dependance between FeatureFlags and async-only CN.
+	if (EplApiInstance_g.m_InitParam.m_dwFeatureFlags != -1) {
+		Ret =
+		    EplObdWriteEntry(0x1F82, 0,
+				     &EplApiInstance_g.m_InitParam.
+				     m_dwFeatureFlags, 4);
+		/*    if(Ret != kEplSuccessful)
+		   {
+		   goto Exit;
+		   } */
+	}
 
-    // d.k. There is no dependance between FeatureFlags and async-only CN.
-    if (EplApiInstance_g.m_InitParam.m_dwFeatureFlags != -1)
-    {
-        Ret = EplObdWriteEntry(0x1F82, 0, &EplApiInstance_g.m_InitParam.m_dwFeatureFlags, 4);
-    /*    if(Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }*/
-    }
-
-    wTemp = (WORD) EplApiInstance_g.m_InitParam.m_uiIsochrTxMaxPayload;
-    Ret = EplObdWriteEntry(0x1F98, 1, &wTemp, 2);
+	wTemp = (WORD) EplApiInstance_g.m_InitParam.m_uiIsochrTxMaxPayload;
+	Ret = EplObdWriteEntry(0x1F98, 1, &wTemp, 2);
 /*    if(Ret != kEplSuccessful)
     {
         goto Exit;
     }*/
 
-    wTemp = (WORD) EplApiInstance_g.m_InitParam.m_uiIsochrRxMaxPayload;
-    Ret = EplObdWriteEntry(0x1F98, 2, &wTemp, 2);
+	wTemp = (WORD) EplApiInstance_g.m_InitParam.m_uiIsochrRxMaxPayload;
+	Ret = EplObdWriteEntry(0x1F98, 2, &wTemp, 2);
 /*    if(Ret != kEplSuccessful)
     {
         goto Exit;
     }*/
 
-    Ret = EplObdWriteEntry(0x1F98, 3, &EplApiInstance_g.m_InitParam.m_dwPresMaxLatency, 4);
+	Ret =
+	    EplObdWriteEntry(0x1F98, 3,
+			     &EplApiInstance_g.m_InitParam.m_dwPresMaxLatency,
+			     4);
 /*    if(Ret != kEplSuccessful)
     {
         goto Exit;
     }*/
 
-    if (EplApiInstance_g.m_InitParam.m_uiPreqActPayloadLimit <= EPL_C_DLL_ISOCHR_MAX_PAYL)
-    {
-        wTemp = (WORD) EplApiInstance_g.m_InitParam.m_uiPreqActPayloadLimit;
-        Ret = EplObdWriteEntry(0x1F98, 4, &wTemp, 2);
+	if (EplApiInstance_g.m_InitParam.m_uiPreqActPayloadLimit <=
+	    EPL_C_DLL_ISOCHR_MAX_PAYL) {
+		wTemp =
+		    (WORD) EplApiInstance_g.m_InitParam.m_uiPreqActPayloadLimit;
+		Ret = EplObdWriteEntry(0x1F98, 4, &wTemp, 2);
 /*    if(Ret != kEplSuccessful)
     {
         goto Exit;
     }*/
-    }
+	}
 
-    if (EplApiInstance_g.m_InitParam.m_uiPresActPayloadLimit <= EPL_C_DLL_ISOCHR_MAX_PAYL)
-    {
-        wTemp = (WORD) EplApiInstance_g.m_InitParam.m_uiPresActPayloadLimit;
-        Ret = EplObdWriteEntry(0x1F98, 5, &wTemp, 2);
+	if (EplApiInstance_g.m_InitParam.m_uiPresActPayloadLimit <=
+	    EPL_C_DLL_ISOCHR_MAX_PAYL) {
+		wTemp =
+		    (WORD) EplApiInstance_g.m_InitParam.m_uiPresActPayloadLimit;
+		Ret = EplObdWriteEntry(0x1F98, 5, &wTemp, 2);
 /*    if(Ret != kEplSuccessful)
     {
         goto Exit;
     }*/
-    }
+	}
 
-    Ret = EplObdWriteEntry(0x1F98, 6, &EplApiInstance_g.m_InitParam.m_dwAsndMaxLatency, 4);
+	Ret =
+	    EplObdWriteEntry(0x1F98, 6,
+			     &EplApiInstance_g.m_InitParam.m_dwAsndMaxLatency,
+			     4);
 /*    if(Ret != kEplSuccessful)
     {
         goto Exit;
     }*/
 
-    if (EplApiInstance_g.m_InitParam.m_uiMultiplCycleCnt <= 0xFF)
-    {
-        bTemp = (BYTE) EplApiInstance_g.m_InitParam.m_uiMultiplCycleCnt;
-        Ret = EplObdWriteEntry(0x1F98, 7, &bTemp, 1);
+	if (EplApiInstance_g.m_InitParam.m_uiMultiplCycleCnt <= 0xFF) {
+		bTemp = (BYTE) EplApiInstance_g.m_InitParam.m_uiMultiplCycleCnt;
+		Ret = EplObdWriteEntry(0x1F98, 7, &bTemp, 1);
 /*    if(Ret != kEplSuccessful)
     {
         goto Exit;
     }*/
-    }
+	}
 
-    if (EplApiInstance_g.m_InitParam.m_uiAsyncMtu <= EPL_C_DLL_MAX_ASYNC_MTU)
-    {
-        wTemp = (WORD) EplApiInstance_g.m_InitParam.m_uiAsyncMtu;
-        Ret = EplObdWriteEntry(0x1F98, 8, &wTemp, 2);
+	if (EplApiInstance_g.m_InitParam.m_uiAsyncMtu <=
+	    EPL_C_DLL_MAX_ASYNC_MTU) {
+		wTemp = (WORD) EplApiInstance_g.m_InitParam.m_uiAsyncMtu;
+		Ret = EplObdWriteEntry(0x1F98, 8, &wTemp, 2);
 /*    if(Ret != kEplSuccessful)
     {
         goto Exit;
     }*/
-    }
-
-    if (EplApiInstance_g.m_InitParam.m_uiPrescaler <= 1000)
-    {
-        wTemp = (WORD) EplApiInstance_g.m_InitParam.m_uiPrescaler;
-        Ret = EplObdWriteEntry(0x1F98, 9, &wTemp, 2);
-        // ignore return code
-        Ret = kEplSuccessful;
-    }
+	}
 
+	if (EplApiInstance_g.m_InitParam.m_uiPrescaler <= 1000) {
+		wTemp = (WORD) EplApiInstance_g.m_InitParam.m_uiPrescaler;
+		Ret = EplObdWriteEntry(0x1F98, 9, &wTemp, 2);
+		// ignore return code
+		Ret = kEplSuccessful;
+	}
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    if (EplApiInstance_g.m_InitParam.m_dwWaitSocPreq != -1)
-    {
-        Ret = EplObdWriteEntry(0x1F8A, 1, &EplApiInstance_g.m_InitParam.m_dwWaitSocPreq, 4);
-    /*        if(Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }*/
-    }
-
-    if ((EplApiInstance_g.m_InitParam.m_dwAsyncSlotTimeout != 0) && (EplApiInstance_g.m_InitParam.m_dwAsyncSlotTimeout != -1))
-    {
-        Ret = EplObdWriteEntry(0x1F8A, 2, &EplApiInstance_g.m_InitParam.m_dwAsyncSlotTimeout, 4);
-    /*        if(Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }*/
-    }
-#endif
-
-    // configure Identity
-    if (EplApiInstance_g.m_InitParam.m_dwDeviceType != -1)
-    {
-        Ret = EplObdWriteEntry(0x1000, 0, &EplApiInstance_g.m_InitParam.m_dwDeviceType, 4);
+	if (EplApiInstance_g.m_InitParam.m_dwWaitSocPreq != -1) {
+		Ret =
+		    EplObdWriteEntry(0x1F8A, 1,
+				     &EplApiInstance_g.m_InitParam.
+				     m_dwWaitSocPreq, 4);
+		/*        if(Ret != kEplSuccessful)
+		   {
+		   goto Exit;
+		   } */
+	}
+
+	if ((EplApiInstance_g.m_InitParam.m_dwAsyncSlotTimeout != 0)
+	    && (EplApiInstance_g.m_InitParam.m_dwAsyncSlotTimeout != -1)) {
+		Ret =
+		    EplObdWriteEntry(0x1F8A, 2,
+				     &EplApiInstance_g.m_InitParam.
+				     m_dwAsyncSlotTimeout, 4);
+		/*        if(Ret != kEplSuccessful)
+		   {
+		   goto Exit;
+		   } */
+	}
+#endif
+
+	// configure Identity
+	if (EplApiInstance_g.m_InitParam.m_dwDeviceType != -1) {
+		Ret =
+		    EplObdWriteEntry(0x1000, 0,
+				     &EplApiInstance_g.m_InitParam.
+				     m_dwDeviceType, 4);
 /*        if(Ret != kEplSuccessful)
         {
             goto Exit;
         }*/
-    }
+	}
 
-    if (EplApiInstance_g.m_InitParam.m_dwVendorId != -1)
-    {
-        Ret = EplObdWriteEntry(0x1018, 1, &EplApiInstance_g.m_InitParam.m_dwVendorId, 4);
+	if (EplApiInstance_g.m_InitParam.m_dwVendorId != -1) {
+		Ret =
+		    EplObdWriteEntry(0x1018, 1,
+				     &EplApiInstance_g.m_InitParam.m_dwVendorId,
+				     4);
 /*        if(Ret != kEplSuccessful)
         {
             goto Exit;
         }*/
-    }
+	}
 
-    if (EplApiInstance_g.m_InitParam.m_dwProductCode != -1)
-    {
-        Ret = EplObdWriteEntry(0x1018, 2, &EplApiInstance_g.m_InitParam.m_dwProductCode, 4);
+	if (EplApiInstance_g.m_InitParam.m_dwProductCode != -1) {
+		Ret =
+		    EplObdWriteEntry(0x1018, 2,
+				     &EplApiInstance_g.m_InitParam.
+				     m_dwProductCode, 4);
 /*        if(Ret != kEplSuccessful)
         {
             goto Exit;
         }*/
-    }
+	}
 
-    if (EplApiInstance_g.m_InitParam.m_dwRevisionNumber != -1)
-    {
-        Ret = EplObdWriteEntry(0x1018, 3, &EplApiInstance_g.m_InitParam.m_dwRevisionNumber, 4);
+	if (EplApiInstance_g.m_InitParam.m_dwRevisionNumber != -1) {
+		Ret =
+		    EplObdWriteEntry(0x1018, 3,
+				     &EplApiInstance_g.m_InitParam.
+				     m_dwRevisionNumber, 4);
 /*        if(Ret != kEplSuccessful)
         {
             goto Exit;
         }*/
-    }
+	}
 
-    if (EplApiInstance_g.m_InitParam.m_dwSerialNumber != -1)
-    {
-        Ret = EplObdWriteEntry(0x1018, 4, &EplApiInstance_g.m_InitParam.m_dwSerialNumber, 4);
+	if (EplApiInstance_g.m_InitParam.m_dwSerialNumber != -1) {
+		Ret =
+		    EplObdWriteEntry(0x1018, 4,
+				     &EplApiInstance_g.m_InitParam.
+				     m_dwSerialNumber, 4);
 /*        if(Ret != kEplSuccessful)
         {
             goto Exit;
         }*/
-    }
+	}
 
-    if (EplApiInstance_g.m_InitParam.m_pszDevName != NULL)
-    {
-        // write Device Name (0x1008)
-        Ret = EplObdWriteEntry (
-            0x1008, 0, (void GENERIC*) EplApiInstance_g.m_InitParam.m_pszDevName, (tEplObdSize) strlen(EplApiInstance_g.m_InitParam.m_pszDevName));
+	if (EplApiInstance_g.m_InitParam.m_pszDevName != NULL) {
+		// write Device Name (0x1008)
+		Ret =
+		    EplObdWriteEntry(0x1008, 0,
+				     (void GENERIC *)EplApiInstance_g.
+				     m_InitParam.m_pszDevName,
+				     (tEplObdSize) strlen(EplApiInstance_g.
+							  m_InitParam.
+							  m_pszDevName));
 /*        if (Ret != kEplSuccessful)
         {
             goto Exit;
         }*/
-    }
+	}
 
-    if (EplApiInstance_g.m_InitParam.m_pszHwVersion != NULL)
-    {
-        // write Hardware version (0x1009)
-        Ret = EplObdWriteEntry (
-            0x1009, 0, (void GENERIC*) EplApiInstance_g.m_InitParam.m_pszHwVersion, (tEplObdSize) strlen(EplApiInstance_g.m_InitParam.m_pszHwVersion));
+	if (EplApiInstance_g.m_InitParam.m_pszHwVersion != NULL) {
+		// write Hardware version (0x1009)
+		Ret =
+		    EplObdWriteEntry(0x1009, 0,
+				     (void GENERIC *)EplApiInstance_g.
+				     m_InitParam.m_pszHwVersion,
+				     (tEplObdSize) strlen(EplApiInstance_g.
+							  m_InitParam.
+							  m_pszHwVersion));
 /*        if (Ret != kEplSuccessful)
         {
             goto Exit;
         }*/
-    }
+	}
 
-    if (EplApiInstance_g.m_InitParam.m_pszSwVersion != NULL)
-    {
-        // write Software version (0x100A)
-        Ret = EplObdWriteEntry (
-            0x100A, 0, (void GENERIC*) EplApiInstance_g.m_InitParam.m_pszSwVersion, (tEplObdSize) strlen(EplApiInstance_g.m_InitParam.m_pszSwVersion));
+	if (EplApiInstance_g.m_InitParam.m_pszSwVersion != NULL) {
+		// write Software version (0x100A)
+		Ret =
+		    EplObdWriteEntry(0x100A, 0,
+				     (void GENERIC *)EplApiInstance_g.
+				     m_InitParam.m_pszSwVersion,
+				     (tEplObdSize) strlen(EplApiInstance_g.
+							  m_InitParam.
+							  m_pszSwVersion));
 /*        if (Ret != kEplSuccessful)
         {
             goto Exit;
         }*/
-    }
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplApiCbSdoCon
@@ -1940,25 +1905,26 @@ Exit:
 //---------------------------------------------------------------------------
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-static tEplKernel PUBLIC  EplApiCbSdoCon(tEplSdoComFinished* pSdoComFinished_p)
+static tEplKernel PUBLIC EplApiCbSdoCon(tEplSdoComFinished * pSdoComFinished_p)
 {
-tEplKernel Ret;
-tEplApiEventArg EventArg;
+	tEplKernel Ret;
+	tEplApiEventArg EventArg;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // call user callback
-    EventArg.m_Sdo = *pSdoComFinished_p;
-    Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventSdo,
-                                                    &EventArg,
-                                                    EplApiInstance_g.m_InitParam.m_pEventUserArg);
+	// call user callback
+	EventArg.m_Sdo = *pSdoComFinished_p;
+	Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventSdo,
+							&EventArg,
+							EplApiInstance_g.
+							m_InitParam.
+							m_pEventUserArg);
 
-    return Ret;
+	return Ret;
 
 }
 #endif
 
-
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
 //---------------------------------------------------------------------------
@@ -1980,33 +1946,33 @@ tEplApiEventArg EventArg;
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC  EplApiCbNodeEvent(unsigned int uiNodeId_p,
-                                            tEplNmtNodeEvent NodeEvent_p,
-                                            tEplNmtState NmtState_p,
-                                            WORD wErrorCode_p,
-                                            BOOL fMandatory_p)
+static tEplKernel PUBLIC EplApiCbNodeEvent(unsigned int uiNodeId_p,
+					   tEplNmtNodeEvent NodeEvent_p,
+					   tEplNmtState NmtState_p,
+					   WORD wErrorCode_p, BOOL fMandatory_p)
 {
-tEplKernel Ret;
-tEplApiEventArg EventArg;
+	tEplKernel Ret;
+	tEplApiEventArg EventArg;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // call user callback
-    EventArg.m_Node.m_uiNodeId = uiNodeId_p;
-    EventArg.m_Node.m_NodeEvent = NodeEvent_p;
-    EventArg.m_Node.m_NmtState = NmtState_p;
-    EventArg.m_Node.m_wErrorCode = wErrorCode_p;
-    EventArg.m_Node.m_fMandatory = fMandatory_p;
-
-    Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventNode,
-                                                    &EventArg,
-                                                    EplApiInstance_g.m_InitParam.m_pEventUserArg);
+	// call user callback
+	EventArg.m_Node.m_uiNodeId = uiNodeId_p;
+	EventArg.m_Node.m_NodeEvent = NodeEvent_p;
+	EventArg.m_Node.m_NmtState = NmtState_p;
+	EventArg.m_Node.m_wErrorCode = wErrorCode_p;
+	EventArg.m_Node.m_fMandatory = fMandatory_p;
+
+	Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventNode,
+							&EventArg,
+							EplApiInstance_g.
+							m_InitParam.
+							m_pEventUserArg);
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplApiCbBootEvent
@@ -2024,31 +1990,32 @@ tEplApiEventArg EventArg;
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC  EplApiCbBootEvent(tEplNmtBootEvent BootEvent_p,
-                                            tEplNmtState NmtState_p,
-                                            WORD wErrorCode_p)
+static tEplKernel PUBLIC EplApiCbBootEvent(tEplNmtBootEvent BootEvent_p,
+					   tEplNmtState NmtState_p,
+					   WORD wErrorCode_p)
 {
-tEplKernel Ret;
-tEplApiEventArg EventArg;
-
-    Ret = kEplSuccessful;
+	tEplKernel Ret;
+	tEplApiEventArg EventArg;
 
-    // call user callback
-    EventArg.m_Boot.m_BootEvent = BootEvent_p;
-    EventArg.m_Boot.m_NmtState = NmtState_p;
-    EventArg.m_Boot.m_wErrorCode = wErrorCode_p;
+	Ret = kEplSuccessful;
 
-    Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventBoot,
-                                                    &EventArg,
-                                                    EplApiInstance_g.m_InitParam.m_pEventUserArg);
+	// call user callback
+	EventArg.m_Boot.m_BootEvent = BootEvent_p;
+	EventArg.m_Boot.m_NmtState = NmtState_p;
+	EventArg.m_Boot.m_wErrorCode = wErrorCode_p;
+
+	Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventBoot,
+							&EventArg,
+							EplApiInstance_g.
+							m_InitParam.
+							m_pEventUserArg);
 
-    return Ret;
+	return Ret;
 
 }
 
 #endif // (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
-
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_LEDU)) != 0)
 
 //---------------------------------------------------------------------------
@@ -2066,28 +2033,28 @@ tEplApiEventArg EventArg;
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC  EplApiCbLedStateChange(tEplLedType LedType_p,
-                                                 BOOL fOn_p)
+static tEplKernel PUBLIC EplApiCbLedStateChange(tEplLedType LedType_p,
+						BOOL fOn_p)
 {
-tEplKernel Ret;
-tEplApiEventArg EventArg;
-
-    Ret = kEplSuccessful;
+	tEplKernel Ret;
+	tEplApiEventArg EventArg;
 
-    // call user callback
-    EventArg.m_Led.m_LedType = LedType_p;
-    EventArg.m_Led.m_fOn = fOn_p;
+	Ret = kEplSuccessful;
 
-    Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventLed,
-                                                    &EventArg,
-                                                    EplApiInstance_g.m_InitParam.m_pEventUserArg);
+	// call user callback
+	EventArg.m_Led.m_LedType = LedType_p;
+	EventArg.m_Led.m_fOn = fOn_p;
+
+	Ret = EplApiInstance_g.m_InitParam.m_pfnCbEvent(kEplApiEventLed,
+							&EventArg,
+							EplApiInstance_g.
+							m_InitParam.
+							m_pEventUserArg);
 
-    return Ret;
+	return Ret;
 
 }
 
 #endif
 
-
 // EOF
-
--- a/drivers/staging/epl/EplApiLinuxKernel.c
+++ b/drivers/staging/epl/EplApiLinuxKernel.c
@@ -70,7 +70,6 @@
 
 ****************************************************************************/
 
-
 // kernel modul and driver
 
 //#include <linux/version.h>
@@ -103,19 +102,16 @@
 //#include "kernel/EplPdokCal.h"
 #include "proc_fs.h"
 
-
-
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
     // remove ("make invisible") obsolete symbols for kernel versions 2.6
     // and higher
-    #define MOD_INC_USE_COUNT
-    #define MOD_DEC_USE_COUNT
-    #define EXPORT_NO_SYMBOLS
+#define MOD_INC_USE_COUNT
+#define MOD_DEC_USE_COUNT
+#define EXPORT_NO_SYMBOLS
 #else
-    #error "This driver needs a 2.6.x kernel or higher"
+#error "This driver needs a 2.6.x kernel or higher"
 #endif
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -127,19 +123,15 @@
 // Metainformation
 MODULE_LICENSE("Dual BSD/GPL");
 #ifdef MODULE_AUTHOR
-    MODULE_AUTHOR("Daniel.Krueger@SYSTEC-electronic.com");
-    MODULE_DESCRIPTION("EPL API driver");
+MODULE_AUTHOR("Daniel.Krueger@SYSTEC-electronic.com");
+MODULE_DESCRIPTION("EPL API driver");
 #endif
 
-
 //---------------------------------------------------------------------------
 //  Configuration
 //---------------------------------------------------------------------------
 
-
-#define EPLLIN_DRV_NAME     "systec_epl"       // used for <register_chrdev>
-
-
+#define EPLLIN_DRV_NAME     "systec_epl"	// used for <register_chrdev>
 
 //---------------------------------------------------------------------------
 //  Constant definitions
@@ -147,23 +139,22 @@ MODULE_LICENSE("Dual BSD/GPL");
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-    void  PUBLIC  TgtDbgSignalTracePoint (BYTE bTracePointNumber_p);
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
 #else
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)
 #endif
 
 #define EVENT_STATE_INIT        0
-#define EVENT_STATE_IOCTL       1   // ioctl entered and ready to receive EPL event
-#define EVENT_STATE_READY       2   // EPL event can be forwarded to user application
-#define EVENT_STATE_TERM        3   // terminate processing
+#define EVENT_STATE_IOCTL       1	// ioctl entered and ready to receive EPL event
+#define EVENT_STATE_READY       2	// EPL event can be forwarded to user application
+#define EVENT_STATE_TERM        3	// terminate processing
 
 #define EPL_STATE_NOTOPEN       0
 #define EPL_STATE_NOTINIT       1
 #define EPL_STATE_RUNNING       2
 #define EPL_STATE_SHUTDOWN      3
 
-
 //---------------------------------------------------------------------------
 //  Global variables
 //---------------------------------------------------------------------------
@@ -171,73 +162,65 @@ MODULE_LICENSE("Dual BSD/GPL");
 #ifdef CONFIG_DEVFS_FS
 
     // driver major number
-    static int  nDrvMajorNumber_g;
+static int nDrvMajorNumber_g;
 
 #else
 
     // device number (major and minor)
-    static dev_t        nDevNum_g;
-    static struct cdev *pEpl_cdev_g;
+static dev_t nDevNum_g;
+static struct cdev *pEpl_cdev_g;
 
 #endif
 
-
 static volatile unsigned int uiEplState_g = EPL_STATE_NOTOPEN;
 
-static struct semaphore     SemaphoreCbEvent_g; // semaphore for EplLinCbEvent
-static wait_queue_head_t    WaitQueueCbEvent_g; // wait queue EplLinCbEvent
-static wait_queue_head_t    WaitQueueProcess_g; // wait queue for EplApiProcess (user process)
-static wait_queue_head_t    WaitQueueRelease_g; // wait queue for EplLinRelease
-static atomic_t             AtomicEventState_g = ATOMIC_INIT(EVENT_STATE_INIT);
-static tEplApiEventType     EventType_g;        // event type (enum)
-static tEplApiEventArg*     pEventArg_g;        // event argument (union)
-static tEplKernel           RetCbEvent_g;       // return code from event callback function
-static wait_queue_head_t    WaitQueueCbSync_g;  // wait queue EplLinCbSync
-static wait_queue_head_t    WaitQueuePI_In_g;   // wait queue for EplApiProcessImageExchangeIn (user process)
-static atomic_t             AtomicSyncState_g = ATOMIC_INIT(EVENT_STATE_INIT);
-
+static struct semaphore SemaphoreCbEvent_g;	// semaphore for EplLinCbEvent
+static wait_queue_head_t WaitQueueCbEvent_g;	// wait queue EplLinCbEvent
+static wait_queue_head_t WaitQueueProcess_g;	// wait queue for EplApiProcess (user process)
+static wait_queue_head_t WaitQueueRelease_g;	// wait queue for EplLinRelease
+static atomic_t AtomicEventState_g = ATOMIC_INIT(EVENT_STATE_INIT);
+static tEplApiEventType EventType_g;	// event type (enum)
+static tEplApiEventArg *pEventArg_g;	// event argument (union)
+static tEplKernel RetCbEvent_g;	// return code from event callback function
+static wait_queue_head_t WaitQueueCbSync_g;	// wait queue EplLinCbSync
+static wait_queue_head_t WaitQueuePI_In_g;	// wait queue for EplApiProcessImageExchangeIn (user process)
+static atomic_t AtomicSyncState_g = ATOMIC_INIT(EVENT_STATE_INIT);
 
 //---------------------------------------------------------------------------
 //  Local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    void*       m_pUserArg;
-    void*       m_pData;
+typedef struct {
+	void *m_pUserArg;
+	void *m_pData;
 
 } tEplLinSdoBufHeader;
 
-
 //---------------------------------------------------------------------------
 //  Local variables
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 //  Prototypes of internal functions
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplLinCbEvent(
-    tEplApiEventType        EventType_p,   // IN: event type (enum)
-    tEplApiEventArg*        pEventArg_p,   // IN: event argument (union)
-    void GENERIC*           pUserArg_p);
+tEplKernel PUBLIC EplLinCbEvent(tEplApiEventType EventType_p,	// IN: event type (enum)
+				tEplApiEventArg * pEventArg_p,	// IN: event argument (union)
+				void GENERIC * pUserArg_p);
 
 tEplKernel PUBLIC EplLinCbSync(void);
 
-static int  __init  EplLinInit (void);
-static void __exit  EplLinExit (void);
-
-
-static  int      EplLinOpen    (struct inode* pDeviceFile_p, struct file* pInstance_p);
-static  int      EplLinRelease (struct inode* pDeviceFile_p, struct file* pInstance_p);
-static  ssize_t  EplLinRead    (struct file* pInstance_p, char* pDstBuff_p, size_t BuffSize_p, loff_t* pFileOffs_p);
-static  ssize_t  EplLinWrite   (struct file* pInstance_p, const char* pSrcBuff_p, size_t BuffSize_p, loff_t* pFileOffs_p);
-static  int      EplLinIoctl   (struct inode* pDeviceFile_p, struct file* pInstance_p, unsigned int uiIoctlCmd_p, unsigned long ulArg_p);
-
-
+static int __init EplLinInit(void);
+static void __exit EplLinExit(void);
 
+static int EplLinOpen(struct inode *pDeviceFile_p, struct file *pInstance_p);
+static int EplLinRelease(struct inode *pDeviceFile_p, struct file *pInstance_p);
+static ssize_t EplLinRead(struct file *pInstance_p, char *pDstBuff_p,
+			  size_t BuffSize_p, loff_t * pFileOffs_p);
+static ssize_t EplLinWrite(struct file *pInstance_p, const char *pSrcBuff_p,
+			   size_t BuffSize_p, loff_t * pFileOffs_p);
+static int EplLinIoctl(struct inode *pDeviceFile_p, struct file *pInstance_p,
+		       unsigned int uiIoctlCmd_p, unsigned long ulArg_p);
 
 //---------------------------------------------------------------------------
 //  Kernel Module specific Data Structures
@@ -245,27 +228,19 @@ static  int      EplLinIoctl   (struct i
 
 EXPORT_NO_SYMBOLS;
 
-
-
 module_init(EplLinInit);
 module_exit(EplLinExit);
 
-
-
-
-static struct file_operations  EplLinFileOps_g =
-{
-    .owner =     THIS_MODULE,
-    .open =      EplLinOpen,
-    .release =   EplLinRelease,
-    .read =      EplLinRead,
-    .write =     EplLinWrite,
-    .ioctl =     EplLinIoctl,
+static struct file_operations EplLinFileOps_g = {
+	.owner = THIS_MODULE,
+	.open = EplLinOpen,
+	.release = EplLinRelease,
+	.read = EplLinRead,
+	.write = EplLinWrite,
+	.ioctl = EplLinIoctl,
 
 };
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -278,1040 +253,1008 @@ static struct file_operations  EplLinFil
 //  -> insmod driver
 //---------------------------------------------------------------------------
 
-static  int  __init  EplLinInit (void)
+static int __init EplLinInit(void)
 {
 
-tEplKernel          EplRet;
-int  iErr;
-int  iRet;
+	tEplKernel EplRet;
+	int iErr;
+	int iRet;
 #ifdef CONFIG_DEVFS_FS
-int  nMinorNumber;
+	int nMinorNumber;
 #endif
 
-    TRACE0("EPL: + EplLinInit...\n");
-    TRACE2("EPL:   Driver build: %s / %s\n", __DATE__, __TIME__);
-
-    iRet = 0;
-
-    // initialize global variables
-    atomic_set(&AtomicEventState_g, EVENT_STATE_INIT);
-    sema_init(&SemaphoreCbEvent_g, 1);
-    init_waitqueue_head(&WaitQueueCbEvent_g);
-    init_waitqueue_head(&WaitQueueProcess_g);
-    init_waitqueue_head(&WaitQueueRelease_g);
+	TRACE0("EPL: + EplLinInit...\n");
+	TRACE2("EPL:   Driver build: %s / %s\n", __DATE__, __TIME__);
 
+	iRet = 0;
 
+	// initialize global variables
+	atomic_set(&AtomicEventState_g, EVENT_STATE_INIT);
+	sema_init(&SemaphoreCbEvent_g, 1);
+	init_waitqueue_head(&WaitQueueCbEvent_g);
+	init_waitqueue_head(&WaitQueueProcess_g);
+	init_waitqueue_head(&WaitQueueRelease_g);
 
 #ifdef CONFIG_DEVFS_FS
 
-    // register character device handler
-    TRACE2("EPL:   Installing Driver '%s', Version %s...\n", EPLLIN_DRV_NAME, EPL_PRODUCT_VERSION);
-    TRACE0("EPL:   (using dynamic major number assignment)\n");
-    nDrvMajorNumber_g = register_chrdev (0, EPLLIN_DRV_NAME, &EplLinFileOps_g);
-    if (nDrvMajorNumber_g != 0)
-    {
-        TRACE2("EPL:   Driver '%s' installed successful, assigned MajorNumber=%d\n", EPLLIN_DRV_NAME, nDrvMajorNumber_g);
-    }
-    else
-    {
-        TRACE1("EPL:   ERROR: Driver '%s' is unable to get a free MajorNumber!\n", EPLLIN_DRV_NAME);
-        iRet = -EIO;
-        goto Exit;
-    }
-
-
-    // create device node in DEVFS
-    nMinorNumber = 0;
-    TRACE1("EPL:   Creating device node '/dev/%s'...\n", EPLLIN_DEV_NAME);
-    iErr = devfs_mk_cdev (MKDEV(nDrvMajorNumber_g, nMinorNumber), S_IFCHR | S_IRUGO | S_IWUGO, EPLLIN_DEV_NAME);
-    if (iErr == 0)
-    {
-        TRACE1("EPL:   Device node '/dev/%s' created successful.\n", EPLLIN_DEV_NAME);
-    }
-    else
-    {
-        TRACE1("EPL:   ERROR: unable to create device node '/dev/%s'\n", EPLLIN_DEV_NAME);
-        iRet = -EIO;
-        goto Exit;
-    }
+	// register character device handler
+	TRACE2("EPL:   Installing Driver '%s', Version %s...\n",
+	       EPLLIN_DRV_NAME, EPL_PRODUCT_VERSION);
+	TRACE0("EPL:   (using dynamic major number assignment)\n");
+	nDrvMajorNumber_g =
+	    register_chrdev(0, EPLLIN_DRV_NAME, &EplLinFileOps_g);
+	if (nDrvMajorNumber_g != 0) {
+		TRACE2
+		    ("EPL:   Driver '%s' installed successful, assigned MajorNumber=%d\n",
+		     EPLLIN_DRV_NAME, nDrvMajorNumber_g);
+	} else {
+		TRACE1
+		    ("EPL:   ERROR: Driver '%s' is unable to get a free MajorNumber!\n",
+		     EPLLIN_DRV_NAME);
+		iRet = -EIO;
+		goto Exit;
+	}
+
+	// create device node in DEVFS
+	nMinorNumber = 0;
+	TRACE1("EPL:   Creating device node '/dev/%s'...\n", EPLLIN_DEV_NAME);
+	iErr =
+	    devfs_mk_cdev(MKDEV(nDrvMajorNumber_g, nMinorNumber),
+			  S_IFCHR | S_IRUGO | S_IWUGO, EPLLIN_DEV_NAME);
+	if (iErr == 0) {
+		TRACE1("EPL:   Device node '/dev/%s' created successful.\n",
+		       EPLLIN_DEV_NAME);
+	} else {
+		TRACE1("EPL:   ERROR: unable to create device node '/dev/%s'\n",
+		       EPLLIN_DEV_NAME);
+		iRet = -EIO;
+		goto Exit;
+	}
 
 #else
 
-    // register character device handler
-    // only one Minor required
-    TRACE2("EPL:   Installing Driver '%s', Version %s...\n", EPLLIN_DRV_NAME, EPL_PRODUCT_VERSION);
-    iRet = alloc_chrdev_region (&nDevNum_g, 0, 1, EPLLIN_DRV_NAME);
-    if (iRet == 0)
-    {
-        TRACE2("EPL:   Driver '%s' installed successful, assigned MajorNumber=%d\n", EPLLIN_DRV_NAME, MAJOR(nDevNum_g));
-    }
-    else
-    {
-        TRACE1("EPL:   ERROR: Driver '%s' is unable to get a free MajorNumber!\n", EPLLIN_DRV_NAME);
-        iRet = -EIO;
-        goto Exit;
-    }
-
-    // register cdev structure
-    pEpl_cdev_g = cdev_alloc();
-    pEpl_cdev_g->ops = &EplLinFileOps_g;
-    pEpl_cdev_g->owner = THIS_MODULE;
-    iErr = cdev_add (pEpl_cdev_g, nDevNum_g, 1);
-    if (iErr)
-    {
-        TRACE2("EPL:   ERROR %d: Driver '%s' could not be added!\n", iErr, EPLLIN_DRV_NAME);
-        iRet = -EIO;
-        goto Exit;
-    }
-
+	// register character device handler
+	// only one Minor required
+	TRACE2("EPL:   Installing Driver '%s', Version %s...\n",
+	       EPLLIN_DRV_NAME, EPL_PRODUCT_VERSION);
+	iRet = alloc_chrdev_region(&nDevNum_g, 0, 1, EPLLIN_DRV_NAME);
+	if (iRet == 0) {
+		TRACE2
+		    ("EPL:   Driver '%s' installed successful, assigned MajorNumber=%d\n",
+		     EPLLIN_DRV_NAME, MAJOR(nDevNum_g));
+	} else {
+		TRACE1
+		    ("EPL:   ERROR: Driver '%s' is unable to get a free MajorNumber!\n",
+		     EPLLIN_DRV_NAME);
+		iRet = -EIO;
+		goto Exit;
+	}
+
+	// register cdev structure
+	pEpl_cdev_g = cdev_alloc();
+	pEpl_cdev_g->ops = &EplLinFileOps_g;
+	pEpl_cdev_g->owner = THIS_MODULE;
+	iErr = cdev_add(pEpl_cdev_g, nDevNum_g, 1);
+	if (iErr) {
+		TRACE2("EPL:   ERROR %d: Driver '%s' could not be added!\n",
+		       iErr, EPLLIN_DRV_NAME);
+		iRet = -EIO;
+		goto Exit;
+	}
 #endif
 
-    // create device node in PROCFS
-    EplRet = EplLinProcInit();
-    if (EplRet != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	// create device node in PROCFS
+	EplRet = EplLinProcInit();
+	if (EplRet != kEplSuccessful) {
+		goto Exit;
+	}
 
+      Exit:
 
-Exit:
-
-    TRACE1("EPL: - EplLinInit (iRet=%d)\n", iRet);
-    return (iRet);
+	TRACE1("EPL: - EplLinInit (iRet=%d)\n", iRet);
+	return (iRet);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Remove Driver
 //---------------------------------------------------------------------------
 //  -> rmmod driver
 //---------------------------------------------------------------------------
 
-static void  __exit  EplLinExit (void)
+static void __exit EplLinExit(void)
 {
 
-tEplKernel          EplRet;
+	tEplKernel EplRet;
 
-    // delete instance for all modules
+	// delete instance for all modules
 //    EplRet = EplApiShutdown();
 //    printk("EplApiShutdown():  0x%X\n", EplRet);
 
-    // deinitialize proc fs
-    EplRet = EplLinProcFree();
-    printk("EplLinProcFree():        0x%X\n", EplRet);
-
-
-    TRACE0("EPL: + EplLinExit...\n");
+	// deinitialize proc fs
+	EplRet = EplLinProcFree();
+	printk("EplLinProcFree():        0x%X\n", EplRet);
 
+	TRACE0("EPL: + EplLinExit...\n");
 
 #ifdef CONFIG_DEVFS_FS
 
-    // remove device node from DEVFS
-    devfs_remove (EPLLIN_DEV_NAME);
-    TRACE1("EPL:   Device node '/dev/%s' removed.\n", EPLLIN_DEV_NAME);
+	// remove device node from DEVFS
+	devfs_remove(EPLLIN_DEV_NAME);
+	TRACE1("EPL:   Device node '/dev/%s' removed.\n", EPLLIN_DEV_NAME);
 
-    // unregister character device handler
-    unregister_chrdev (nDrvMajorNumber_g, EPLLIN_DRV_NAME);
+	// unregister character device handler
+	unregister_chrdev(nDrvMajorNumber_g, EPLLIN_DRV_NAME);
 
 #else
 
-    // remove cdev structure
-    cdev_del(pEpl_cdev_g);
+	// remove cdev structure
+	cdev_del(pEpl_cdev_g);
 
-    // unregister character device handler
-    unregister_chrdev_region (nDevNum_g, 1);
+	// unregister character device handler
+	unregister_chrdev_region(nDevNum_g, 1);
 
 #endif
 
-    TRACE1("EPL:   Driver '%s' removed.\n", EPLLIN_DRV_NAME);
+	TRACE1("EPL:   Driver '%s' removed.\n", EPLLIN_DRV_NAME);
 
-
-    TRACE0("EPL: - EplLinExit\n");
+	TRACE0("EPL: - EplLinExit\n");
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Open Driver
 //---------------------------------------------------------------------------
 //  -> open("/dev/driver", O_RDWR)...
 //---------------------------------------------------------------------------
 
-static int  EplLinOpen (
-    struct inode* pDeviceFile_p,    // information about the device to open
-    struct file* pInstance_p)       // information about driver instance
+static int EplLinOpen(struct inode *pDeviceFile_p,	// information about the device to open
+		      struct file *pInstance_p)	// information about driver instance
 {
 
-int  iRet;
-
+	int iRet;
 
-    TRACE0("EPL: + EplLinOpen...\n");
+	TRACE0("EPL: + EplLinOpen...\n");
 
-    MOD_INC_USE_COUNT;
+	MOD_INC_USE_COUNT;
 
-    if (uiEplState_g != EPL_STATE_NOTOPEN)
-    {   // stack already initialized
-        iRet = -EALREADY;
-    }
-    else
-    {
-        atomic_set(&AtomicEventState_g, EVENT_STATE_INIT);
-        sema_init(&SemaphoreCbEvent_g, 1);
-        init_waitqueue_head(&WaitQueueCbEvent_g);
-        init_waitqueue_head(&WaitQueueProcess_g);
-        init_waitqueue_head(&WaitQueueRelease_g);
-        atomic_set(&AtomicSyncState_g, EVENT_STATE_INIT);
-        init_waitqueue_head(&WaitQueueCbSync_g);
-        init_waitqueue_head(&WaitQueuePI_In_g);
-
-        uiEplState_g = EPL_STATE_NOTINIT;
-        iRet = 0;
-    }
+	if (uiEplState_g != EPL_STATE_NOTOPEN) {	// stack already initialized
+		iRet = -EALREADY;
+	} else {
+		atomic_set(&AtomicEventState_g, EVENT_STATE_INIT);
+		sema_init(&SemaphoreCbEvent_g, 1);
+		init_waitqueue_head(&WaitQueueCbEvent_g);
+		init_waitqueue_head(&WaitQueueProcess_g);
+		init_waitqueue_head(&WaitQueueRelease_g);
+		atomic_set(&AtomicSyncState_g, EVENT_STATE_INIT);
+		init_waitqueue_head(&WaitQueueCbSync_g);
+		init_waitqueue_head(&WaitQueuePI_In_g);
+
+		uiEplState_g = EPL_STATE_NOTINIT;
+		iRet = 0;
+	}
 
-    TRACE1("EPL: - EplLinOpen (iRet=%d)\n", iRet);
-    return (iRet);
+	TRACE1("EPL: - EplLinOpen (iRet=%d)\n", iRet);
+	return (iRet);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Close Driver
 //---------------------------------------------------------------------------
 //  -> close(device)...
 //---------------------------------------------------------------------------
 
-static int  EplLinRelease (
-    struct inode* pDeviceFile_p,    // information about the device to open
-    struct file* pInstance_p)       // information about driver instance
+static int EplLinRelease(struct inode *pDeviceFile_p,	// information about the device to open
+			 struct file *pInstance_p)	// information about driver instance
 {
 
-tEplKernel          EplRet = kEplSuccessful;
-int  iRet;
-
-
-    TRACE0("EPL: + EplLinRelease...\n");
-
-    if (uiEplState_g != EPL_STATE_NOTINIT)
-    {
-        // pass control to sync kernel thread, but signal termination
-        atomic_set(&AtomicSyncState_g, EVENT_STATE_TERM);
-        wake_up_interruptible(&WaitQueueCbSync_g);
-        wake_up_interruptible(&WaitQueuePI_In_g);
-
-        // pass control to event queue kernel thread
-        atomic_set(&AtomicEventState_g, EVENT_STATE_TERM);
-        wake_up_interruptible(&WaitQueueCbEvent_g);
-
-        if (uiEplState_g == EPL_STATE_RUNNING)
-        {   // post NmtEventSwitchOff
-            EplRet = EplApiExecNmtCommand(kEplNmtEventSwitchOff);
-
-        }
-
-        if (EplRet == kEplSuccessful)
-        {
-            TRACE0("EPL:   waiting for NMT_GS_OFF\n");
-            wait_event_interruptible(WaitQueueRelease_g,
-                                        (uiEplState_g == EPL_STATE_SHUTDOWN));
-        }
-        else
-        {   // post NmtEventSwitchOff failed
-            TRACE0("EPL:   event post failed\n");
-        }
-
-        // $$$ d.k.: What if waiting was interrupted by signal?
+	tEplKernel EplRet = kEplSuccessful;
+	int iRet;
 
-        TRACE0("EPL:   call EplApiShutdown()\n");
-        // EPL stack can be safely shut down
-        // delete instance for all EPL modules
-        EplRet = EplApiShutdown();
-        printk("EplApiShutdown():  0x%X\n", EplRet);
-    }
+	TRACE0("EPL: + EplLinRelease...\n");
 
-    uiEplState_g = EPL_STATE_NOTOPEN;
-    iRet = 0;
+	if (uiEplState_g != EPL_STATE_NOTINIT) {
+		// pass control to sync kernel thread, but signal termination
+		atomic_set(&AtomicSyncState_g, EVENT_STATE_TERM);
+		wake_up_interruptible(&WaitQueueCbSync_g);
+		wake_up_interruptible(&WaitQueuePI_In_g);
+
+		// pass control to event queue kernel thread
+		atomic_set(&AtomicEventState_g, EVENT_STATE_TERM);
+		wake_up_interruptible(&WaitQueueCbEvent_g);
+
+		if (uiEplState_g == EPL_STATE_RUNNING) {	// post NmtEventSwitchOff
+			EplRet = EplApiExecNmtCommand(kEplNmtEventSwitchOff);
+
+		}
+
+		if (EplRet == kEplSuccessful) {
+			TRACE0("EPL:   waiting for NMT_GS_OFF\n");
+			wait_event_interruptible(WaitQueueRelease_g,
+						 (uiEplState_g ==
+						  EPL_STATE_SHUTDOWN));
+		} else {	// post NmtEventSwitchOff failed
+			TRACE0("EPL:   event post failed\n");
+		}
+
+		// $$$ d.k.: What if waiting was interrupted by signal?
+
+		TRACE0("EPL:   call EplApiShutdown()\n");
+		// EPL stack can be safely shut down
+		// delete instance for all EPL modules
+		EplRet = EplApiShutdown();
+		printk("EplApiShutdown():  0x%X\n", EplRet);
+	}
 
+	uiEplState_g = EPL_STATE_NOTOPEN;
+	iRet = 0;
 
-    MOD_DEC_USE_COUNT;
+	MOD_DEC_USE_COUNT;
 
-
-    TRACE1("EPL: - EplLinRelease (iRet=%d)\n", iRet);
-    return (iRet);
+	TRACE1("EPL: - EplLinRelease (iRet=%d)\n", iRet);
+	return (iRet);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Read Data from Driver
 //---------------------------------------------------------------------------
 //  -> read(...)
 //---------------------------------------------------------------------------
 
-static ssize_t  EplLinRead (
-    struct file* pInstance_p,       // information about driver instance
-    char* pDstBuff_p,               // address of buffer to fill with data
-    size_t BuffSize_p,              // length of the buffer
-    loff_t* pFileOffs_p)            // offset in the file
+static ssize_t EplLinRead(struct file *pInstance_p,	// information about driver instance
+			  char *pDstBuff_p,	// address of buffer to fill with data
+			  size_t BuffSize_p,	// length of the buffer
+			  loff_t * pFileOffs_p)	// offset in the file
 {
 
-int  iRet;
-
-
-    TRACE0("EPL: + EplLinRead...\n");
+	int iRet;
 
+	TRACE0("EPL: + EplLinRead...\n");
 
-    TRACE0("EPL:   Sorry, this operation isn't supported.\n");
-    iRet = -EINVAL;
+	TRACE0("EPL:   Sorry, this operation isn't supported.\n");
+	iRet = -EINVAL;
 
-
-    TRACE1("EPL: - EplLinRead (iRet=%d)\n", iRet);
-    return (iRet);
+	TRACE1("EPL: - EplLinRead (iRet=%d)\n", iRet);
+	return (iRet);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Write Data to Driver
 //---------------------------------------------------------------------------
 //  -> write(...)
 //---------------------------------------------------------------------------
 
-static ssize_t  EplLinWrite (
-    struct file* pInstance_p,       // information about driver instance
-    const char* pSrcBuff_p,         // address of buffer to get data from
-    size_t BuffSize_p,              // length of the buffer
-    loff_t* pFileOffs_p)            // offset in the file
+static ssize_t EplLinWrite(struct file *pInstance_p,	// information about driver instance
+			   const char *pSrcBuff_p,	// address of buffer to get data from
+			   size_t BuffSize_p,	// length of the buffer
+			   loff_t * pFileOffs_p)	// offset in the file
 {
 
-int  iRet;
-
+	int iRet;
 
-    TRACE0("EPL: + EplLinWrite...\n");
+	TRACE0("EPL: + EplLinWrite...\n");
 
+	TRACE0("EPL:   Sorry, this operation isn't supported.\n");
+	iRet = -EINVAL;
 
-    TRACE0("EPL:   Sorry, this operation isn't supported.\n");
-    iRet = -EINVAL;
-
-
-    TRACE1("EPL: - EplLinWrite (iRet=%d)\n", iRet);
-    return (iRet);
+	TRACE1("EPL: - EplLinWrite (iRet=%d)\n", iRet);
+	return (iRet);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Generic Access to Driver
 //---------------------------------------------------------------------------
 //  -> ioctl(...)
 //---------------------------------------------------------------------------
 
-static int  EplLinIoctl (
-    struct inode* pDeviceFile_p,    // information about the device to open
-    struct file* pInstance_p,       // information about driver instance
-    unsigned int uiIoctlCmd_p,      // Ioctl command to execute
-    unsigned long ulArg_p)          // Ioctl command specific argument/parameter
+static int EplLinIoctl(struct inode *pDeviceFile_p,	// information about the device to open
+		       struct file *pInstance_p,	// information about driver instance
+		       unsigned int uiIoctlCmd_p,	// Ioctl command to execute
+		       unsigned long ulArg_p)	// Ioctl command specific argument/parameter
 {
 
-tEplKernel          EplRet;
-int  iErr;
-int  iRet;
-
+	tEplKernel EplRet;
+	int iErr;
+	int iRet;
 
 //    TRACE1("EPL: + EplLinIoctl (uiIoctlCmd_p=%d)...\n", uiIoctlCmd_p);
 
+	iRet = -EINVAL;
 
-    iRet = -EINVAL;
-
-    switch (uiIoctlCmd_p)
-    {
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_INITIALIZE:
-        {
-        tEplApiInitParam EplApiInitParam;
-
-            iErr = copy_from_user(&EplApiInitParam, (const void*)ulArg_p, sizeof (EplApiInitParam));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            EplApiInitParam.m_pfnCbEvent = EplLinCbEvent;
-            EplApiInitParam.m_pfnCbSync = EplLinCbSync;
-
-            EplRet = EplApiInitialize(&EplApiInitParam);
-
-            uiEplState_g = EPL_STATE_RUNNING;
-
-            iRet = (int) EplRet;
-            break;
-        }
-
-
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_SHUTDOWN:
-        {   // shutdown the threads
-
-            // pass control to sync kernel thread, but signal termination
-            atomic_set(&AtomicSyncState_g, EVENT_STATE_TERM);
-            wake_up_interruptible(&WaitQueueCbSync_g);
-            wake_up_interruptible(&WaitQueuePI_In_g);
-
-            // pass control to event queue kernel thread
-            atomic_set(&AtomicEventState_g, EVENT_STATE_TERM);
-            wake_up_interruptible(&WaitQueueCbEvent_g);
-
-            if (uiEplState_g == EPL_STATE_RUNNING)
-            {   // post NmtEventSwitchOff
-                EplRet = EplApiExecNmtCommand(kEplNmtEventSwitchOff);
-
-            }
-
-            iRet = 0;
-            break;
-        }
-
-
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_READ_LOCAL_OBJECT:
-        {
-        tEplLinLocalObject  LocalObject;
-        void*               pData;
-
-            iErr = copy_from_user(&LocalObject, (const void*)ulArg_p, sizeof (LocalObject));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            if ((LocalObject.m_pData == NULL) || (LocalObject.m_uiSize == 0))
-            {
-                iRet = (int) kEplApiInvalidParam;
-                goto Exit;
-            }
-
-            pData = vmalloc(LocalObject.m_uiSize);
-            if (pData == NULL)
-            {   // no memory available
-                iRet = -ENOMEM;
-                goto Exit;
-            }
-
-            EplRet = EplApiReadLocalObject(LocalObject.m_uiIndex, LocalObject.m_uiSubindex, pData, &LocalObject.m_uiSize);
-
-            if (EplRet == kEplSuccessful)
-            {
-                iErr = copy_to_user(LocalObject.m_pData, pData, LocalObject.m_uiSize);
-
-                vfree(pData);
-
-                if (iErr != 0)
-                {
-                    iRet = -EIO;
-                    goto Exit;
-                }
-
-                // return actual size (LocalObject.m_uiSize)
-                iErr = put_user(LocalObject.m_uiSize,
-                                (unsigned int*)(ulArg_p + (unsigned long)&LocalObject.m_uiSize - (unsigned long)&LocalObject));
-                if (iErr != 0)
-                {
-                    iRet = -EIO;
-                    goto Exit;
-                }
-
-            }
-            else
-            {
-                vfree(pData);
-            }
-
-            iRet = (int) EplRet;
-            break;
-        }
-
-
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_WRITE_LOCAL_OBJECT:
-        {
-        tEplLinLocalObject  LocalObject;
-        void*               pData;
-
-            iErr = copy_from_user(&LocalObject, (const void*)ulArg_p, sizeof (LocalObject));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            if ((LocalObject.m_pData == NULL) || (LocalObject.m_uiSize == 0))
-            {
-                iRet = (int) kEplApiInvalidParam;
-                goto Exit;
-            }
-
-            pData = vmalloc(LocalObject.m_uiSize);
-            if (pData == NULL)
-            {   // no memory available
-                iRet = -ENOMEM;
-                goto Exit;
-            }
-            iErr = copy_from_user(pData, LocalObject.m_pData, LocalObject.m_uiSize);
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            EplRet = EplApiWriteLocalObject(LocalObject.m_uiIndex, LocalObject.m_uiSubindex, pData, LocalObject.m_uiSize);
-
-            vfree(pData);
-
-            iRet = (int) EplRet;
-            break;
-        }
-
-
-        case EPLLIN_CMD_READ_OBJECT:
-        {
-        tEplLinSdoObject        SdoObject;
-        void*                   pData;
-        tEplLinSdoBufHeader*    pBufHeader;
-        tEplSdoComConHdl*       pSdoComConHdl;
-
-            iErr = copy_from_user(&SdoObject, (const void*)ulArg_p, sizeof (SdoObject));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            if ((SdoObject.m_le_pData == NULL) || (SdoObject.m_uiSize == 0))
-            {
-                iRet = (int) kEplApiInvalidParam;
-                goto Exit;
-            }
-
-            pBufHeader = (tEplLinSdoBufHeader*) vmalloc(sizeof (tEplLinSdoBufHeader) + SdoObject.m_uiSize);
-            if (pBufHeader == NULL)
-            {   // no memory available
-                iRet = -ENOMEM;
-                goto Exit;
-            }
-
-            // initiate temporary buffer
-            pBufHeader->m_pUserArg = SdoObject.m_pUserArg;  // original user argument pointer
-            pBufHeader->m_pData = SdoObject.m_le_pData;     // original data pointer from app
-            pData = pBufHeader + sizeof (tEplLinSdoBufHeader);
-
-            if (SdoObject.m_fValidSdoComConHdl != FALSE)
-            {
-                pSdoComConHdl = &SdoObject.m_SdoComConHdl;
-            }
-            else
-            {
-                pSdoComConHdl = NULL;
-            }
-
-            EplRet = EplApiReadObject(pSdoComConHdl, SdoObject.m_uiNodeId, SdoObject.m_uiIndex,
-                                      SdoObject.m_uiSubindex, pData, &SdoObject.m_uiSize,
-                                      SdoObject.m_SdoType, pBufHeader);
-
-            // return actual SDO handle (SdoObject.m_SdoComConHdl)
-            iErr = put_user(SdoObject.m_SdoComConHdl,
-                            (unsigned int*)(ulArg_p + (unsigned long)&SdoObject.m_SdoComConHdl - (unsigned long)&SdoObject));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            if (EplRet == kEplSuccessful)
-            {
-                iErr = copy_to_user(SdoObject.m_le_pData, pData, SdoObject.m_uiSize);
-
-                vfree(pBufHeader);
-
-                if (iErr != 0)
-                {
-                    iRet = -EIO;
-                    goto Exit;
-                }
-
-                // return actual size (SdoObject.m_uiSize)
-                iErr = put_user(SdoObject.m_uiSize,
-                                (unsigned int*)(ulArg_p + (unsigned long)&SdoObject.m_uiSize - (unsigned long)&SdoObject));
-                if (iErr != 0)
-                {
-                    iRet = -EIO;
-                    goto Exit;
-                }
-            }
-            else if (EplRet != kEplApiTaskDeferred)
-            {   // error ocurred
-                vfree(pBufHeader);
-                if (iErr != 0)
-                {
-                    iRet = -EIO;
-                    goto Exit;
-                }
-            }
-
-            iRet = (int) EplRet;
-            break;
-        }
-
-
-        case EPLLIN_CMD_WRITE_OBJECT:
-        {
-        tEplLinSdoObject        SdoObject;
-        void*                   pData;
-        tEplLinSdoBufHeader*    pBufHeader;
-        tEplSdoComConHdl*       pSdoComConHdl;
-
-            iErr = copy_from_user(&SdoObject, (const void*)ulArg_p, sizeof (SdoObject));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            if ((SdoObject.m_le_pData == NULL) || (SdoObject.m_uiSize == 0))
-            {
-                iRet = (int) kEplApiInvalidParam;
-                goto Exit;
-            }
-
-            pBufHeader = (tEplLinSdoBufHeader*) vmalloc(sizeof (tEplLinSdoBufHeader) + SdoObject.m_uiSize);
-            if (pBufHeader == NULL)
-            {   // no memory available
-                iRet = -ENOMEM;
-                goto Exit;
-            }
-
-            // initiate temporary buffer
-            pBufHeader->m_pUserArg = SdoObject.m_pUserArg;  // original user argument pointer
-            pBufHeader->m_pData = SdoObject.m_le_pData;     // original data pointer from app
-            pData = pBufHeader + sizeof (tEplLinSdoBufHeader);
-
-            iErr = copy_from_user(pData, SdoObject.m_le_pData, SdoObject.m_uiSize);
-
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            if (SdoObject.m_fValidSdoComConHdl != FALSE)
-            {
-                pSdoComConHdl = &SdoObject.m_SdoComConHdl;
-            }
-            else
-            {
-                pSdoComConHdl = NULL;
-            }
-
-            EplRet = EplApiWriteObject(pSdoComConHdl, SdoObject.m_uiNodeId, SdoObject.m_uiIndex,
-                                      SdoObject.m_uiSubindex, pData, SdoObject.m_uiSize,
-                                      SdoObject.m_SdoType, pBufHeader);
-
-            // return actual SDO handle (SdoObject.m_SdoComConHdl)
-            iErr = put_user(SdoObject.m_SdoComConHdl,
-                            (unsigned int*)(ulArg_p + (unsigned long)&SdoObject.m_SdoComConHdl - (unsigned long)&SdoObject));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            if (EplRet != kEplApiTaskDeferred)
-            {   // succeeded or error ocurred, but task not deferred
-                vfree(pBufHeader);
-            }
-
-            iRet = (int) EplRet;
-            break;
-        }
-
-
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_FREE_SDO_CHANNEL:
-        {
-            // forward SDO handle to EPL stack
-            EplRet = EplApiFreeSdoChannel((tEplSdoComConHdl)ulArg_p);
-
-            iRet = (int) EplRet;
-            break;
-        }
-
+	switch (uiIoctlCmd_p) {
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_INITIALIZE:
+		{
+			tEplApiInitParam EplApiInitParam;
+
+			iErr =
+			    copy_from_user(&EplApiInitParam,
+					   (const void *)ulArg_p,
+					   sizeof(EplApiInitParam));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			EplApiInitParam.m_pfnCbEvent = EplLinCbEvent;
+			EplApiInitParam.m_pfnCbSync = EplLinCbSync;
+
+			EplRet = EplApiInitialize(&EplApiInitParam);
+
+			uiEplState_g = EPL_STATE_RUNNING;
+
+			iRet = (int)EplRet;
+			break;
+		}
+
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_SHUTDOWN:
+		{		// shutdown the threads
+
+			// pass control to sync kernel thread, but signal termination
+			atomic_set(&AtomicSyncState_g, EVENT_STATE_TERM);
+			wake_up_interruptible(&WaitQueueCbSync_g);
+			wake_up_interruptible(&WaitQueuePI_In_g);
+
+			// pass control to event queue kernel thread
+			atomic_set(&AtomicEventState_g, EVENT_STATE_TERM);
+			wake_up_interruptible(&WaitQueueCbEvent_g);
+
+			if (uiEplState_g == EPL_STATE_RUNNING) {	// post NmtEventSwitchOff
+				EplRet =
+				    EplApiExecNmtCommand(kEplNmtEventSwitchOff);
+
+			}
+
+			iRet = 0;
+			break;
+		}
+
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_READ_LOCAL_OBJECT:
+		{
+			tEplLinLocalObject LocalObject;
+			void *pData;
+
+			iErr =
+			    copy_from_user(&LocalObject, (const void *)ulArg_p,
+					   sizeof(LocalObject));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			if ((LocalObject.m_pData == NULL)
+			    || (LocalObject.m_uiSize == 0)) {
+				iRet = (int)kEplApiInvalidParam;
+				goto Exit;
+			}
+
+			pData = vmalloc(LocalObject.m_uiSize);
+			if (pData == NULL) {	// no memory available
+				iRet = -ENOMEM;
+				goto Exit;
+			}
+
+			EplRet =
+			    EplApiReadLocalObject(LocalObject.m_uiIndex,
+						  LocalObject.m_uiSubindex,
+						  pData, &LocalObject.m_uiSize);
+
+			if (EplRet == kEplSuccessful) {
+				iErr =
+				    copy_to_user(LocalObject.m_pData, pData,
+						 LocalObject.m_uiSize);
+
+				vfree(pData);
+
+				if (iErr != 0) {
+					iRet = -EIO;
+					goto Exit;
+				}
+				// return actual size (LocalObject.m_uiSize)
+				iErr = put_user(LocalObject.m_uiSize,
+						(unsigned int *)(ulArg_p +
+								 (unsigned long)
+								 &LocalObject.
+								 m_uiSize -
+								 (unsigned long)
+								 &LocalObject));
+				if (iErr != 0) {
+					iRet = -EIO;
+					goto Exit;
+				}
+
+			} else {
+				vfree(pData);
+			}
+
+			iRet = (int)EplRet;
+			break;
+		}
+
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_WRITE_LOCAL_OBJECT:
+		{
+			tEplLinLocalObject LocalObject;
+			void *pData;
+
+			iErr =
+			    copy_from_user(&LocalObject, (const void *)ulArg_p,
+					   sizeof(LocalObject));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			if ((LocalObject.m_pData == NULL)
+			    || (LocalObject.m_uiSize == 0)) {
+				iRet = (int)kEplApiInvalidParam;
+				goto Exit;
+			}
+
+			pData = vmalloc(LocalObject.m_uiSize);
+			if (pData == NULL) {	// no memory available
+				iRet = -ENOMEM;
+				goto Exit;
+			}
+			iErr =
+			    copy_from_user(pData, LocalObject.m_pData,
+					   LocalObject.m_uiSize);
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			EplRet =
+			    EplApiWriteLocalObject(LocalObject.m_uiIndex,
+						   LocalObject.m_uiSubindex,
+						   pData, LocalObject.m_uiSize);
+
+			vfree(pData);
+
+			iRet = (int)EplRet;
+			break;
+		}
+
+	case EPLLIN_CMD_READ_OBJECT:
+		{
+			tEplLinSdoObject SdoObject;
+			void *pData;
+			tEplLinSdoBufHeader *pBufHeader;
+			tEplSdoComConHdl *pSdoComConHdl;
+
+			iErr =
+			    copy_from_user(&SdoObject, (const void *)ulArg_p,
+					   sizeof(SdoObject));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			if ((SdoObject.m_le_pData == NULL)
+			    || (SdoObject.m_uiSize == 0)) {
+				iRet = (int)kEplApiInvalidParam;
+				goto Exit;
+			}
+
+			pBufHeader =
+			    (tEplLinSdoBufHeader *)
+			    vmalloc(sizeof(tEplLinSdoBufHeader) +
+				    SdoObject.m_uiSize);
+			if (pBufHeader == NULL) {	// no memory available
+				iRet = -ENOMEM;
+				goto Exit;
+			}
+			// initiate temporary buffer
+			pBufHeader->m_pUserArg = SdoObject.m_pUserArg;	// original user argument pointer
+			pBufHeader->m_pData = SdoObject.m_le_pData;	// original data pointer from app
+			pData = pBufHeader + sizeof(tEplLinSdoBufHeader);
+
+			if (SdoObject.m_fValidSdoComConHdl != FALSE) {
+				pSdoComConHdl = &SdoObject.m_SdoComConHdl;
+			} else {
+				pSdoComConHdl = NULL;
+			}
+
+			EplRet =
+			    EplApiReadObject(pSdoComConHdl,
+					     SdoObject.m_uiNodeId,
+					     SdoObject.m_uiIndex,
+					     SdoObject.m_uiSubindex, pData,
+					     &SdoObject.m_uiSize,
+					     SdoObject.m_SdoType, pBufHeader);
+
+			// return actual SDO handle (SdoObject.m_SdoComConHdl)
+			iErr = put_user(SdoObject.m_SdoComConHdl,
+					(unsigned int *)(ulArg_p +
+							 (unsigned long)
+							 &SdoObject.
+							 m_SdoComConHdl -
+							 (unsigned long)
+							 &SdoObject));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			if (EplRet == kEplSuccessful) {
+				iErr =
+				    copy_to_user(SdoObject.m_le_pData, pData,
+						 SdoObject.m_uiSize);
+
+				vfree(pBufHeader);
+
+				if (iErr != 0) {
+					iRet = -EIO;
+					goto Exit;
+				}
+				// return actual size (SdoObject.m_uiSize)
+				iErr = put_user(SdoObject.m_uiSize,
+						(unsigned int *)(ulArg_p +
+								 (unsigned long)
+								 &SdoObject.
+								 m_uiSize -
+								 (unsigned long)
+								 &SdoObject));
+				if (iErr != 0) {
+					iRet = -EIO;
+					goto Exit;
+				}
+			} else if (EplRet != kEplApiTaskDeferred) {	// error ocurred
+				vfree(pBufHeader);
+				if (iErr != 0) {
+					iRet = -EIO;
+					goto Exit;
+				}
+			}
+
+			iRet = (int)EplRet;
+			break;
+		}
+
+	case EPLLIN_CMD_WRITE_OBJECT:
+		{
+			tEplLinSdoObject SdoObject;
+			void *pData;
+			tEplLinSdoBufHeader *pBufHeader;
+			tEplSdoComConHdl *pSdoComConHdl;
+
+			iErr =
+			    copy_from_user(&SdoObject, (const void *)ulArg_p,
+					   sizeof(SdoObject));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			if ((SdoObject.m_le_pData == NULL)
+			    || (SdoObject.m_uiSize == 0)) {
+				iRet = (int)kEplApiInvalidParam;
+				goto Exit;
+			}
+
+			pBufHeader =
+			    (tEplLinSdoBufHeader *)
+			    vmalloc(sizeof(tEplLinSdoBufHeader) +
+				    SdoObject.m_uiSize);
+			if (pBufHeader == NULL) {	// no memory available
+				iRet = -ENOMEM;
+				goto Exit;
+			}
+			// initiate temporary buffer
+			pBufHeader->m_pUserArg = SdoObject.m_pUserArg;	// original user argument pointer
+			pBufHeader->m_pData = SdoObject.m_le_pData;	// original data pointer from app
+			pData = pBufHeader + sizeof(tEplLinSdoBufHeader);
+
+			iErr =
+			    copy_from_user(pData, SdoObject.m_le_pData,
+					   SdoObject.m_uiSize);
+
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			if (SdoObject.m_fValidSdoComConHdl != FALSE) {
+				pSdoComConHdl = &SdoObject.m_SdoComConHdl;
+			} else {
+				pSdoComConHdl = NULL;
+			}
+
+			EplRet =
+			    EplApiWriteObject(pSdoComConHdl,
+					      SdoObject.m_uiNodeId,
+					      SdoObject.m_uiIndex,
+					      SdoObject.m_uiSubindex, pData,
+					      SdoObject.m_uiSize,
+					      SdoObject.m_SdoType, pBufHeader);
+
+			// return actual SDO handle (SdoObject.m_SdoComConHdl)
+			iErr = put_user(SdoObject.m_SdoComConHdl,
+					(unsigned int *)(ulArg_p +
+							 (unsigned long)
+							 &SdoObject.
+							 m_SdoComConHdl -
+							 (unsigned long)
+							 &SdoObject));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			if (EplRet != kEplApiTaskDeferred) {	// succeeded or error ocurred, but task not deferred
+				vfree(pBufHeader);
+			}
+
+			iRet = (int)EplRet;
+			break;
+		}
+
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_FREE_SDO_CHANNEL:
+		{
+			// forward SDO handle to EPL stack
+			EplRet =
+			    EplApiFreeSdoChannel((tEplSdoComConHdl) ulArg_p);
+
+			iRet = (int)EplRet;
+			break;
+		}
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_MN_TRIGGER_STATE_CHANGE:
-        {
-        tEplLinNodeCmdObject        NodeCmdObject;
-
-            iErr = copy_from_user(&NodeCmdObject, (const void*)ulArg_p, sizeof (NodeCmdObject));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            EplRet = EplApiMnTriggerStateChange(NodeCmdObject.m_uiNodeId,
-                                                NodeCmdObject.m_NodeCommand);
-            iRet = (int) EplRet;
-            break;
-        }
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_MN_TRIGGER_STATE_CHANGE:
+		{
+			tEplLinNodeCmdObject NodeCmdObject;
+
+			iErr =
+			    copy_from_user(&NodeCmdObject,
+					   (const void *)ulArg_p,
+					   sizeof(NodeCmdObject));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			EplRet =
+			    EplApiMnTriggerStateChange(NodeCmdObject.m_uiNodeId,
+						       NodeCmdObject.
+						       m_NodeCommand);
+			iRet = (int)EplRet;
+			break;
+		}
 #endif
 
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_GET_EVENT:
+		{
+			tEplLinEvent Event;
+
+			// save event structure
+			iErr =
+			    copy_from_user(&Event, (const void *)ulArg_p,
+					   sizeof(Event));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+			// save return code from application's event callback function
+			RetCbEvent_g = Event.m_RetCbEvent;
+
+			if (RetCbEvent_g == kEplShutdown) {
+				// pass control to event queue kernel thread, but signal termination
+				atomic_set(&AtomicEventState_g,
+					   EVENT_STATE_TERM);
+				wake_up_interruptible(&WaitQueueCbEvent_g);
+				// exit with error -> EplApiProcess() will leave the infinite loop
+				iRet = 1;
+				goto Exit;
+			}
+			// pass control to event queue kernel thread
+			atomic_set(&AtomicEventState_g, EVENT_STATE_IOCTL);
+			wake_up_interruptible(&WaitQueueCbEvent_g);
+
+			// fall asleep itself in own wait queue
+			iErr = wait_event_interruptible(WaitQueueProcess_g,
+							(atomic_read
+							 (&AtomicEventState_g)
+							 == EVENT_STATE_READY)
+							||
+							(atomic_read
+							 (&AtomicEventState_g)
+							 == EVENT_STATE_TERM));
+			if (iErr != 0) {	// waiting was interrupted by signal
+				// pass control to event queue kernel thread, but signal termination
+				atomic_set(&AtomicEventState_g,
+					   EVENT_STATE_TERM);
+				wake_up_interruptible(&WaitQueueCbEvent_g);
+				// exit with this error -> EplApiProcess() will leave the infinite loop
+				iRet = iErr;
+				goto Exit;
+			} else if (atomic_read(&AtomicEventState_g) == EVENT_STATE_TERM) {	// termination in progress
+				// pass control to event queue kernel thread, but signal termination
+				wake_up_interruptible(&WaitQueueCbEvent_g);
+				// exit with this error -> EplApiProcess() will leave the infinite loop
+				iRet = 1;
+				goto Exit;
+			}
+			// copy event to user space
+			iErr =
+			    copy_to_user(Event.m_pEventType, &EventType_g,
+					 sizeof(EventType_g));
+			if (iErr != 0) {	// not all data could be copied
+				iRet = -EIO;
+				goto Exit;
+			}
+			// $$$ d.k. perform SDO event processing
+			if (EventType_g == kEplApiEventSdo) {
+				void *pData;
+				tEplLinSdoBufHeader *pBufHeader;
+
+				pBufHeader =
+				    (tEplLinSdoBufHeader *) pEventArg_g->m_Sdo.
+				    m_pUserArg;
+				pData =
+				    pBufHeader + sizeof(tEplLinSdoBufHeader);
+
+				if (pEventArg_g->m_Sdo.m_SdoAccessType ==
+				    kEplSdoAccessTypeRead) {
+					// copy read data to user space
+					iErr =
+					    copy_to_user(pBufHeader->m_pData,
+							 pData,
+							 pEventArg_g->m_Sdo.
+							 m_uiTransferredByte);
+					if (iErr != 0) {	// not all data could be copied
+						iRet = -EIO;
+						goto Exit;
+					}
+				}
+				pEventArg_g->m_Sdo.m_pUserArg =
+				    pBufHeader->m_pUserArg;
+				vfree(pBufHeader);
+			}
+
+			iErr =
+			    copy_to_user(Event.m_pEventArg, pEventArg_g,
+					 min(sizeof(tEplApiEventArg),
+					     Event.m_uiEventArgSize));
+			if (iErr != 0) {	// not all data could be copied
+				iRet = -EIO;
+				goto Exit;
+			}
+			// return to EplApiProcess(), which will call the application's event callback function
+			iRet = 0;
+
+			break;
+		}
+
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_PI_SETUP:
+		{
+			EplRet = EplApiProcessImageSetup();
+			iRet = (int)EplRet;
+
+			break;
+		}
+
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_PI_IN:
+		{
+			tEplApiProcessImage ProcessImageIn;
+
+			// save process image structure
+			iErr =
+			    copy_from_user(&ProcessImageIn,
+					   (const void *)ulArg_p,
+					   sizeof(ProcessImageIn));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+			// pass control to event queue kernel thread
+			atomic_set(&AtomicSyncState_g, EVENT_STATE_IOCTL);
+
+			// fall asleep itself in own wait queue
+			iErr = wait_event_interruptible(WaitQueuePI_In_g,
+							(atomic_read
+							 (&AtomicSyncState_g) ==
+							 EVENT_STATE_READY)
+							||
+							(atomic_read
+							 (&AtomicSyncState_g) ==
+							 EVENT_STATE_TERM));
+			if (iErr != 0) {	// waiting was interrupted by signal
+				// pass control to sync kernel thread, but signal termination
+				atomic_set(&AtomicSyncState_g,
+					   EVENT_STATE_TERM);
+				wake_up_interruptible(&WaitQueueCbSync_g);
+				// exit with this error -> application will leave the infinite loop
+				iRet = iErr;
+				goto Exit;
+			} else if (atomic_read(&AtomicSyncState_g) == EVENT_STATE_TERM) {	// termination in progress
+				// pass control to sync kernel thread, but signal termination
+				wake_up_interruptible(&WaitQueueCbSync_g);
+				// exit with this error -> application will leave the infinite loop
+				iRet = 1;
+				goto Exit;
+			}
+			// exchange process image
+			EplRet = EplApiProcessImageExchangeIn(&ProcessImageIn);
+
+			// return to EplApiProcessImageExchangeIn()
+			iRet = (int)EplRet;
+
+			break;
+		}
+
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_PI_OUT:
+		{
+			tEplApiProcessImage ProcessImageOut;
+
+			// save process image structure
+			iErr =
+			    copy_from_user(&ProcessImageOut,
+					   (const void *)ulArg_p,
+					   sizeof(ProcessImageOut));
+			if (iErr != 0) {
+				iRet = -EIO;
+				goto Exit;
+			}
+
+			if (atomic_read(&AtomicSyncState_g) !=
+			    EVENT_STATE_READY) {
+				iRet = (int)kEplInvalidOperation;
+				goto Exit;
+			}
+			// exchange process image
+			EplRet =
+			    EplApiProcessImageExchangeOut(&ProcessImageOut);
+
+			// pass control to sync kernel thread
+			atomic_set(&AtomicSyncState_g, EVENT_STATE_TERM);
+			wake_up_interruptible(&WaitQueueCbSync_g);
+
+			// return to EplApiProcessImageExchangeout()
+			iRet = (int)EplRet;
+
+			break;
+		}
+
+		// ----------------------------------------------------------
+	case EPLLIN_CMD_NMT_COMMAND:
+		{
+			// forward NMT command to EPL stack
+			EplRet = EplApiExecNmtCommand((tEplNmtEvent) ulArg_p);
+
+			iRet = (int)EplRet;
+
+			break;
+		}
+
+		// ----------------------------------------------------------
+	default:
+		{
+			break;
+		}
+	}
 
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_GET_EVENT:
-        {
-        tEplLinEvent         Event;
-
-            // save event structure
-            iErr = copy_from_user(&Event, (const void*)ulArg_p, sizeof (Event));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            // save return code from application's event callback function
-            RetCbEvent_g = Event.m_RetCbEvent;
-
-            if (RetCbEvent_g == kEplShutdown)
-            {
-                // pass control to event queue kernel thread, but signal termination
-                atomic_set(&AtomicEventState_g, EVENT_STATE_TERM);
-                wake_up_interruptible(&WaitQueueCbEvent_g);
-                // exit with error -> EplApiProcess() will leave the infinite loop
-                iRet = 1;
-                goto Exit;
-            }
-
-            // pass control to event queue kernel thread
-            atomic_set(&AtomicEventState_g, EVENT_STATE_IOCTL);
-            wake_up_interruptible(&WaitQueueCbEvent_g);
-
-            // fall asleep itself in own wait queue
-            iErr = wait_event_interruptible(WaitQueueProcess_g,
-                                            (atomic_read(&AtomicEventState_g) == EVENT_STATE_READY)
-                                            || (atomic_read(&AtomicEventState_g) == EVENT_STATE_TERM));
-            if (iErr != 0)
-            {   // waiting was interrupted by signal
-                // pass control to event queue kernel thread, but signal termination
-                atomic_set(&AtomicEventState_g, EVENT_STATE_TERM);
-                wake_up_interruptible(&WaitQueueCbEvent_g);
-                // exit with this error -> EplApiProcess() will leave the infinite loop
-                iRet = iErr;
-                goto Exit;
-            }
-            else if (atomic_read(&AtomicEventState_g) == EVENT_STATE_TERM)
-            {   // termination in progress
-                // pass control to event queue kernel thread, but signal termination
-                wake_up_interruptible(&WaitQueueCbEvent_g);
-                // exit with this error -> EplApiProcess() will leave the infinite loop
-                iRet = 1;
-                goto Exit;
-            }
-
-            // copy event to user space
-            iErr = copy_to_user(Event.m_pEventType, &EventType_g, sizeof (EventType_g));
-            if (iErr != 0)
-            {   // not all data could be copied
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            // $$$ d.k. perform SDO event processing
-            if (EventType_g == kEplApiEventSdo)
-            {
-            void*               pData;
-            tEplLinSdoBufHeader*    pBufHeader;
-
-                pBufHeader = (tEplLinSdoBufHeader*) pEventArg_g->m_Sdo.m_pUserArg;
-                pData = pBufHeader + sizeof (tEplLinSdoBufHeader);
-
-                if (pEventArg_g->m_Sdo.m_SdoAccessType == kEplSdoAccessTypeRead)
-                {
-                    // copy read data to user space
-                    iErr = copy_to_user(pBufHeader->m_pData, pData, pEventArg_g->m_Sdo.m_uiTransferredByte);
-                    if (iErr != 0)
-                    {   // not all data could be copied
-                        iRet = -EIO;
-                        goto Exit;
-                    }
-                }
-                pEventArg_g->m_Sdo.m_pUserArg = pBufHeader->m_pUserArg;
-                vfree(pBufHeader);
-            }
-
-            iErr = copy_to_user(Event.m_pEventArg, pEventArg_g, min(sizeof (tEplApiEventArg), Event.m_uiEventArgSize));
-            if (iErr != 0)
-            {   // not all data could be copied
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            // return to EplApiProcess(), which will call the application's event callback function
-            iRet = 0;
-
-            break;
-        }
-
-
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_PI_SETUP:
-        {
-            EplRet = EplApiProcessImageSetup();
-            iRet = (int) EplRet;
-
-            break;
-        }
-
-
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_PI_IN:
-        {
-        tEplApiProcessImage ProcessImageIn;
-
-            // save process image structure
-            iErr = copy_from_user(&ProcessImageIn, (const void*)ulArg_p, sizeof (ProcessImageIn));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            // pass control to event queue kernel thread
-            atomic_set(&AtomicSyncState_g, EVENT_STATE_IOCTL);
-
-            // fall asleep itself in own wait queue
-            iErr = wait_event_interruptible(WaitQueuePI_In_g,
-                                            (atomic_read(&AtomicSyncState_g) == EVENT_STATE_READY)
-                                            || (atomic_read(&AtomicSyncState_g) == EVENT_STATE_TERM));
-            if (iErr != 0)
-            {   // waiting was interrupted by signal
-                // pass control to sync kernel thread, but signal termination
-                atomic_set(&AtomicSyncState_g, EVENT_STATE_TERM);
-                wake_up_interruptible(&WaitQueueCbSync_g);
-                // exit with this error -> application will leave the infinite loop
-                iRet = iErr;
-                goto Exit;
-            }
-            else if (atomic_read(&AtomicSyncState_g) == EVENT_STATE_TERM)
-            {   // termination in progress
-                // pass control to sync kernel thread, but signal termination
-                wake_up_interruptible(&WaitQueueCbSync_g);
-                // exit with this error -> application will leave the infinite loop
-                iRet = 1;
-                goto Exit;
-            }
-
-            // exchange process image
-            EplRet = EplApiProcessImageExchangeIn(&ProcessImageIn);
-
-            // return to EplApiProcessImageExchangeIn()
-            iRet = (int) EplRet;
-
-            break;
-        }
-
-
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_PI_OUT:
-        {
-        tEplApiProcessImage ProcessImageOut;
-
-            // save process image structure
-            iErr = copy_from_user(&ProcessImageOut, (const void*)ulArg_p, sizeof (ProcessImageOut));
-            if (iErr != 0)
-            {
-                iRet = -EIO;
-                goto Exit;
-            }
-
-            if (atomic_read(&AtomicSyncState_g) != EVENT_STATE_READY)
-            {
-                iRet = (int) kEplInvalidOperation;
-                goto Exit;
-            }
-
-            // exchange process image
-            EplRet = EplApiProcessImageExchangeOut(&ProcessImageOut);
-
-            // pass control to sync kernel thread
-            atomic_set(&AtomicSyncState_g, EVENT_STATE_TERM);
-            wake_up_interruptible(&WaitQueueCbSync_g);
-
-            // return to EplApiProcessImageExchangeout()
-            iRet = (int) EplRet;
-
-            break;
-        }
-
-
-        // ----------------------------------------------------------
-        case EPLLIN_CMD_NMT_COMMAND:
-        {
-            // forward NMT command to EPL stack
-            EplRet = EplApiExecNmtCommand((tEplNmtEvent)ulArg_p);
-
-            iRet = (int) EplRet;
-
-            break;
-        }
-
-
-
-        // ----------------------------------------------------------
-        default:
-        {
-            break;
-        }
-    }
-
-
-Exit:
+      Exit:
 
 //    TRACE1("EPL: - EplLinIoctl (iRet=%d)\n", iRet);
-    return (iRet);
+	return (iRet);
 
 }
 
-
-
-
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
 //                                                                         //
 //=========================================================================//
 
-
-tEplKernel PUBLIC EplLinCbEvent(
-    tEplApiEventType        EventType_p,   // IN: event type (enum)
-    tEplApiEventArg*        pEventArg_p,   // IN: event argument (union)
-    void GENERIC*           pUserArg_p)
+tEplKernel PUBLIC EplLinCbEvent(tEplApiEventType EventType_p,	// IN: event type (enum)
+				tEplApiEventArg * pEventArg_p,	// IN: event argument (union)
+				void GENERIC * pUserArg_p)
 {
-tEplKernel          EplRet = kEplSuccessful;
-int  iErr;
-
-    // block any further call to this function, i.e. enter critical section
-    iErr = down_interruptible(&SemaphoreCbEvent_g);
-    if (iErr != 0)
-    {   // waiting was interrupted by signal
-        EplRet = kEplShutdown;
-        goto Exit;
-    }
-
-    // wait for EplApiProcess() to call ioctl
-    // normally it should be waiting already for us to pass a new event
-    iErr = wait_event_interruptible(WaitQueueCbEvent_g,
-                                    (atomic_read(&AtomicEventState_g) == EVENT_STATE_IOCTL)
-                                    || (atomic_read(&AtomicEventState_g) == EVENT_STATE_TERM));
-    if ((iErr != 0) || (atomic_read(&AtomicEventState_g) == EVENT_STATE_TERM))
-    {   // waiting was interrupted by signal
-        EplRet = kEplShutdown;
-        goto LeaveCriticalSection;
-    }
-
-    // save event information for ioctl
-    EventType_g = EventType_p;
-    pEventArg_g = pEventArg_p;
-
-    // pass control to application's event callback function, i.e. EplApiProcess()
-    atomic_set(&AtomicEventState_g, EVENT_STATE_READY);
-    wake_up_interruptible(&WaitQueueProcess_g);
-
-    // now, the application's event callback function processes the event
-
-    // wait for completion of application's event callback function, i.e. EplApiProcess() calls ioctl again
-    iErr = wait_event_interruptible(WaitQueueCbEvent_g,
-                                    (atomic_read(&AtomicEventState_g) == EVENT_STATE_IOCTL)
-                                    || (atomic_read(&AtomicEventState_g) == EVENT_STATE_TERM));
-    if ((iErr != 0) || (atomic_read(&AtomicEventState_g) == EVENT_STATE_TERM))
-    {   // waiting was interrupted by signal
-        EplRet = kEplShutdown;
-        goto LeaveCriticalSection;
-    }
-
-    // read return code from application's event callback function
-    EplRet = RetCbEvent_g;
-
-
-LeaveCriticalSection:
-    up(&SemaphoreCbEvent_g);
-
-Exit:
-    // check if NMT_GS_OFF is reached
-    if (EventType_p == kEplApiEventNmtStateChange)
-    {
-        if (pEventArg_p->m_NmtStateChange.m_NewNmtState == kEplNmtGsOff)
-        {   // NMT state machine was shut down
-            TRACE0("EPL:   EplLinCbEvent(NMT_GS_OFF)\n");
-            uiEplState_g = EPL_STATE_SHUTDOWN;
-            atomic_set(&AtomicEventState_g, EVENT_STATE_TERM);
-            wake_up(&WaitQueueRelease_g);
-        }
-        else
-        {   // NMT state machine is running
-            uiEplState_g = EPL_STATE_RUNNING;
-        }
-    }
+	tEplKernel EplRet = kEplSuccessful;
+	int iErr;
 
+	// block any further call to this function, i.e. enter critical section
+	iErr = down_interruptible(&SemaphoreCbEvent_g);
+	if (iErr != 0) {	// waiting was interrupted by signal
+		EplRet = kEplShutdown;
+		goto Exit;
+	}
+	// wait for EplApiProcess() to call ioctl
+	// normally it should be waiting already for us to pass a new event
+	iErr = wait_event_interruptible(WaitQueueCbEvent_g,
+					(atomic_read(&AtomicEventState_g) ==
+					 EVENT_STATE_IOCTL)
+					|| (atomic_read(&AtomicEventState_g) ==
+					    EVENT_STATE_TERM));
+	if ((iErr != 0) || (atomic_read(&AtomicEventState_g) == EVENT_STATE_TERM)) {	// waiting was interrupted by signal
+		EplRet = kEplShutdown;
+		goto LeaveCriticalSection;
+	}
+	// save event information for ioctl
+	EventType_g = EventType_p;
+	pEventArg_g = pEventArg_p;
+
+	// pass control to application's event callback function, i.e. EplApiProcess()
+	atomic_set(&AtomicEventState_g, EVENT_STATE_READY);
+	wake_up_interruptible(&WaitQueueProcess_g);
+
+	// now, the application's event callback function processes the event
+
+	// wait for completion of application's event callback function, i.e. EplApiProcess() calls ioctl again
+	iErr = wait_event_interruptible(WaitQueueCbEvent_g,
+					(atomic_read(&AtomicEventState_g) ==
+					 EVENT_STATE_IOCTL)
+					|| (atomic_read(&AtomicEventState_g) ==
+					    EVENT_STATE_TERM));
+	if ((iErr != 0) || (atomic_read(&AtomicEventState_g) == EVENT_STATE_TERM)) {	// waiting was interrupted by signal
+		EplRet = kEplShutdown;
+		goto LeaveCriticalSection;
+	}
+	// read return code from application's event callback function
+	EplRet = RetCbEvent_g;
+
+      LeaveCriticalSection:
+	up(&SemaphoreCbEvent_g);
+
+      Exit:
+	// check if NMT_GS_OFF is reached
+	if (EventType_p == kEplApiEventNmtStateChange) {
+		if (pEventArg_p->m_NmtStateChange.m_NewNmtState == kEplNmtGsOff) {	// NMT state machine was shut down
+			TRACE0("EPL:   EplLinCbEvent(NMT_GS_OFF)\n");
+			uiEplState_g = EPL_STATE_SHUTDOWN;
+			atomic_set(&AtomicEventState_g, EVENT_STATE_TERM);
+			wake_up(&WaitQueueRelease_g);
+		} else {	// NMT state machine is running
+			uiEplState_g = EPL_STATE_RUNNING;
+		}
+	}
 
-    return EplRet;
+	return EplRet;
 }
 
-
 tEplKernel PUBLIC EplLinCbSync(void)
 {
-tEplKernel          EplRet = kEplSuccessful;
-int  iErr;
+	tEplKernel EplRet = kEplSuccessful;
+	int iErr;
 
-    // check if user process waits for sync
-    if (atomic_read(&AtomicSyncState_g) == EVENT_STATE_IOCTL)
-    {
-        // pass control to application, i.e. EplApiProcessImageExchangeIn()
-        atomic_set(&AtomicSyncState_g, EVENT_STATE_READY);
-        wake_up_interruptible(&WaitQueuePI_In_g);
-
-        // now, the application processes the sync event
-
-        // wait for call of EplApiProcessImageExchangeOut()
-        iErr = wait_event_interruptible(WaitQueueCbSync_g,
-                                        (atomic_read(&AtomicSyncState_g) == EVENT_STATE_IOCTL)
-                                        || (atomic_read(&AtomicSyncState_g) == EVENT_STATE_TERM));
-        if ((iErr != 0) || (atomic_read(&AtomicEventState_g) == EVENT_STATE_IOCTL))
-        {   // waiting was interrupted by signal or application called wrong function
-            EplRet = kEplShutdown;
-        }
-    }
-    else
-    {   // application is currently not waiting for sync
-        // continue without interruption
-        // TPDO are set valid by caller (i.e. EplEventkProcess())
-    }
+	// check if user process waits for sync
+	if (atomic_read(&AtomicSyncState_g) == EVENT_STATE_IOCTL) {
+		// pass control to application, i.e. EplApiProcessImageExchangeIn()
+		atomic_set(&AtomicSyncState_g, EVENT_STATE_READY);
+		wake_up_interruptible(&WaitQueuePI_In_g);
+
+		// now, the application processes the sync event
+
+		// wait for call of EplApiProcessImageExchangeOut()
+		iErr = wait_event_interruptible(WaitQueueCbSync_g,
+						(atomic_read(&AtomicSyncState_g)
+						 == EVENT_STATE_IOCTL)
+						||
+						(atomic_read(&AtomicSyncState_g)
+						 == EVENT_STATE_TERM));
+		if ((iErr != 0) || (atomic_read(&AtomicEventState_g) == EVENT_STATE_IOCTL)) {	// waiting was interrupted by signal or application called wrong function
+			EplRet = kEplShutdown;
+		}
+	} else {		// application is currently not waiting for sync
+		// continue without interruption
+		// TPDO are set valid by caller (i.e. EplEventkProcess())
+	}
 
-    TGT_DBG_SIGNAL_TRACE_POINT(1);
+	TGT_DBG_SIGNAL_TRACE_POINT(1);
 
-    return EplRet;
+	return EplRet;
 }
 
-
-
 // EOF
-
--- a/drivers/staging/epl/EplApiProcessImage.c
+++ b/drivers/staging/epl/EplApiProcessImage.c
@@ -75,7 +75,6 @@
 #include <asm/uaccess.h>
 #endif
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -100,7 +99,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -114,7 +112,6 @@
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -130,36 +127,33 @@
 //---------------------------------------------------------------------------
 
 #if ((EPL_API_PROCESS_IMAGE_SIZE_IN > 0) || (EPL_API_PROCESS_IMAGE_SIZE_OUT > 0))
-    typedef struct
-    {
-        #if EPL_API_PROCESS_IMAGE_SIZE_IN > 0
-            BYTE        m_abProcessImageInput[EPL_API_PROCESS_IMAGE_SIZE_IN];
-        #endif
-        #if EPL_API_PROCESS_IMAGE_SIZE_OUT > 0
-            BYTE        m_abProcessImageOutput[EPL_API_PROCESS_IMAGE_SIZE_OUT];
-        #endif
+typedef struct {
+#if EPL_API_PROCESS_IMAGE_SIZE_IN > 0
+	BYTE m_abProcessImageInput[EPL_API_PROCESS_IMAGE_SIZE_IN];
+#endif
+#if EPL_API_PROCESS_IMAGE_SIZE_OUT > 0
+	BYTE m_abProcessImageOutput[EPL_API_PROCESS_IMAGE_SIZE_OUT];
+#endif
 
-    } tEplApiProcessImageInstance;
+} tEplApiProcessImageInstance;
 
 //---------------------------------------------------------------------------
 // local vars
 //---------------------------------------------------------------------------
 
-static tEplApiProcessImageInstance  EplApiProcessImageInstance_g;
+static tEplApiProcessImageInstance EplApiProcessImageInstance_g;
 #endif
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
 //                                                                         //
 //=========================================================================//
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplApiProcessImageSetup()
@@ -177,125 +171,101 @@ static tEplApiProcessImageInstance  EplA
 
 tEplKernel PUBLIC EplApiProcessImageSetup(void)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 #if ((EPL_API_PROCESS_IMAGE_SIZE_IN > 0) || (EPL_API_PROCESS_IMAGE_SIZE_OUT > 0))
-unsigned int    uiVarEntries;
-tEplObdSize     ObdSize;
+	unsigned int uiVarEntries;
+	tEplObdSize ObdSize;
 #endif
 
 #if EPL_API_PROCESS_IMAGE_SIZE_IN > 0
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN;
-    ObdSize = 1;
-    Ret = EplApiLinkObject(
-                            0x2000,
-                            EplApiProcessImageInstance_g.m_abProcessImageInput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
-
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN;
-    ObdSize = 1;
-    Ret = EplApiLinkObject(
-                            0x2001,
-                            EplApiProcessImageInstance_g.m_abProcessImageInput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
-
-    ObdSize = 2;
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN / ObdSize;
-    Ret = EplApiLinkObject(
-                            0x2010,
-                            EplApiProcessImageInstance_g.m_abProcessImageInput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
-
-    ObdSize = 2;
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN / ObdSize;
-    Ret = EplApiLinkObject(
-                            0x2011,
-                            EplApiProcessImageInstance_g.m_abProcessImageInput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
-
-    ObdSize = 4;
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN / ObdSize;
-    Ret = EplApiLinkObject(
-                            0x2020,
-                            EplApiProcessImageInstance_g.m_abProcessImageInput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
-
-    ObdSize = 4;
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN / ObdSize;
-    Ret = EplApiLinkObject(
-                            0x2021,
-                            EplApiProcessImageInstance_g.m_abProcessImageInput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN;
+	ObdSize = 1;
+	Ret = EplApiLinkObject(0x2000,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageInput, &uiVarEntries, &ObdSize,
+			       1);
+
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN;
+	ObdSize = 1;
+	Ret = EplApiLinkObject(0x2001,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageInput, &uiVarEntries, &ObdSize,
+			       1);
+
+	ObdSize = 2;
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN / ObdSize;
+	Ret = EplApiLinkObject(0x2010,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageInput, &uiVarEntries, &ObdSize,
+			       1);
+
+	ObdSize = 2;
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN / ObdSize;
+	Ret = EplApiLinkObject(0x2011,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageInput, &uiVarEntries, &ObdSize,
+			       1);
+
+	ObdSize = 4;
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN / ObdSize;
+	Ret = EplApiLinkObject(0x2020,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageInput, &uiVarEntries, &ObdSize,
+			       1);
+
+	ObdSize = 4;
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_IN / ObdSize;
+	Ret = EplApiLinkObject(0x2021,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageInput, &uiVarEntries, &ObdSize,
+			       1);
 #endif
 
 #if EPL_API_PROCESS_IMAGE_SIZE_OUT > 0
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT;
-    ObdSize = 1;
-    Ret = EplApiLinkObject(
-                            0x2030,
-                            EplApiProcessImageInstance_g.m_abProcessImageOutput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
-
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT;
-    ObdSize = 1;
-    Ret = EplApiLinkObject(
-                            0x2031,
-                            EplApiProcessImageInstance_g.m_abProcessImageOutput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
-
-    ObdSize = 2;
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT / ObdSize;
-    Ret = EplApiLinkObject(
-                            0x2040,
-                            EplApiProcessImageInstance_g.m_abProcessImageOutput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
-
-    ObdSize = 2;
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT / ObdSize;
-    Ret = EplApiLinkObject(
-                            0x2041,
-                            EplApiProcessImageInstance_g.m_abProcessImageOutput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
-
-    ObdSize = 4;
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT / ObdSize;
-    Ret = EplApiLinkObject(
-                            0x2050,
-                            EplApiProcessImageInstance_g.m_abProcessImageOutput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
-
-    ObdSize = 4;
-    uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT / ObdSize;
-    Ret = EplApiLinkObject(
-                            0x2051,
-                            EplApiProcessImageInstance_g.m_abProcessImageOutput,
-                            &uiVarEntries,
-                            &ObdSize,
-                            1);
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT;
+	ObdSize = 1;
+	Ret = EplApiLinkObject(0x2030,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageOutput, &uiVarEntries, &ObdSize,
+			       1);
+
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT;
+	ObdSize = 1;
+	Ret = EplApiLinkObject(0x2031,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageOutput, &uiVarEntries, &ObdSize,
+			       1);
+
+	ObdSize = 2;
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT / ObdSize;
+	Ret = EplApiLinkObject(0x2040,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageOutput, &uiVarEntries, &ObdSize,
+			       1);
+
+	ObdSize = 2;
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT / ObdSize;
+	Ret = EplApiLinkObject(0x2041,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageOutput, &uiVarEntries, &ObdSize,
+			       1);
+
+	ObdSize = 4;
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT / ObdSize;
+	Ret = EplApiLinkObject(0x2050,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageOutput, &uiVarEntries, &ObdSize,
+			       1);
+
+	ObdSize = 4;
+	uiVarEntries = EPL_API_PROCESS_IMAGE_SIZE_OUT / ObdSize;
+	Ret = EplApiLinkObject(0x2051,
+			       EplApiProcessImageInstance_g.
+			       m_abProcessImageOutput, &uiVarEntries, &ObdSize,
+			       1);
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //----------------------------------------------------------------------------
@@ -310,26 +280,29 @@ tEplObdSize     ObdSize;
 // State:
 //----------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplApiProcessImageExchangeIn(tEplApiProcessImage* pPI_p)
+tEplKernel PUBLIC EplApiProcessImageExchangeIn(tEplApiProcessImage * pPI_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
 #if EPL_API_PROCESS_IMAGE_SIZE_IN > 0
-    #if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-        copy_to_user(pPI_p->m_pImage,
-            EplApiProcessImageInstance_g.m_abProcessImageInput,
-            min(pPI_p->m_uiSize, sizeof (EplApiProcessImageInstance_g.m_abProcessImageInput)));
-    #else
-        EPL_MEMCPY(pPI_p->m_pImage,
-            EplApiProcessImageInstance_g.m_abProcessImageInput,
-            min(pPI_p->m_uiSize, sizeof (EplApiProcessImageInstance_g.m_abProcessImageInput)));
-    #endif
+#if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+	copy_to_user(pPI_p->m_pImage,
+		     EplApiProcessImageInstance_g.m_abProcessImageInput,
+		     min(pPI_p->m_uiSize,
+			 sizeof(EplApiProcessImageInstance_g.
+				m_abProcessImageInput)));
+#else
+	EPL_MEMCPY(pPI_p->m_pImage,
+		   EplApiProcessImageInstance_g.m_abProcessImageInput,
+		   min(pPI_p->m_uiSize,
+		       sizeof(EplApiProcessImageInstance_g.
+			      m_abProcessImageInput)));
+#endif
 #endif
 
-    return Ret;
+	return Ret;
 }
 
-
 //----------------------------------------------------------------------------
 // Function:    EplApiProcessImageExchangeOut()
 //
@@ -342,33 +315,33 @@ tEplKernel      Ret = kEplSuccessful;
 // State:
 //----------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplApiProcessImageExchangeOut(tEplApiProcessImage* pPI_p)
+tEplKernel PUBLIC EplApiProcessImageExchangeOut(tEplApiProcessImage * pPI_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
 #if EPL_API_PROCESS_IMAGE_SIZE_OUT > 0
-    #if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-        copy_from_user(EplApiProcessImageInstance_g.m_abProcessImageOutput,
-            pPI_p->m_pImage,
-            min(pPI_p->m_uiSize, sizeof (EplApiProcessImageInstance_g.m_abProcessImageOutput)));
-    #else
-        EPL_MEMCPY(EplApiProcessImageInstance_g.m_abProcessImageOutput,
-            pPI_p->m_pImage,
-            min(pPI_p->m_uiSize, sizeof (EplApiProcessImageInstance_g.m_abProcessImageOutput)));
-    #endif
+#if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+	copy_from_user(EplApiProcessImageInstance_g.m_abProcessImageOutput,
+		       pPI_p->m_pImage,
+		       min(pPI_p->m_uiSize,
+			   sizeof(EplApiProcessImageInstance_g.
+				  m_abProcessImageOutput)));
+#else
+	EPL_MEMCPY(EplApiProcessImageInstance_g.m_abProcessImageOutput,
+		   pPI_p->m_pImage,
+		   min(pPI_p->m_uiSize,
+		       sizeof(EplApiProcessImageInstance_g.
+			      m_abProcessImageOutput)));
+#endif
 #endif
 
-    return Ret;
+	return Ret;
 }
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
 //                                                                         //
 //=========================================================================//
 
-
-
 // EOF
-
--- a/drivers/staging/epl/EplDllk.c
+++ b/drivers/staging/epl/EplDllk.c
@@ -121,19 +121,18 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-    void  PUBLIC  TgtDbgSignalTracePoint (BYTE bTracePointNumber_p);
-    void  PUBLIC  TgtDbgPostTraceValue (DWORD dwTraceValue_p);
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void PUBLIC TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)
 #endif
 #define EPL_DLLK_DBG_POST_TRACE_VALUE(Event_p, uiNodeId_p, wErrorCode_p) \
     TGT_DBG_POST_TRACE_VALUE((kEplEventSinkDllk << 28) | (Event_p << 24) \
                              | (uiNodeId_p << 16) | wErrorCode_p)
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -147,7 +146,6 @@
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -159,96 +157,93 @@
 //---------------------------------------------------------------------------
 
 // defines for indexes of tEplDllInstance.m_pTxFrameInfo
-#define EPL_DLLK_TXFRAME_IDENTRES   0   // IdentResponse on CN / MN
-#define EPL_DLLK_TXFRAME_STATUSRES  1   // StatusResponse on CN / MN
-#define EPL_DLLK_TXFRAME_NMTREQ     2   // NMT Request from FIFO on CN / MN
-#define EPL_DLLK_TXFRAME_NONEPL     3   // non-EPL frame from FIFO on CN / MN
-#define EPL_DLLK_TXFRAME_PRES       4   // PRes on CN / MN
-#define EPL_DLLK_TXFRAME_SOC        5   // SoC on MN
-#define EPL_DLLK_TXFRAME_SOA        6   // SoA on MN
-#define EPL_DLLK_TXFRAME_PREQ       7   // PReq on MN
+#define EPL_DLLK_TXFRAME_IDENTRES   0	// IdentResponse on CN / MN
+#define EPL_DLLK_TXFRAME_STATUSRES  1	// StatusResponse on CN / MN
+#define EPL_DLLK_TXFRAME_NMTREQ     2	// NMT Request from FIFO on CN / MN
+#define EPL_DLLK_TXFRAME_NONEPL     3	// non-EPL frame from FIFO on CN / MN
+#define EPL_DLLK_TXFRAME_PRES       4	// PRes on CN / MN
+#define EPL_DLLK_TXFRAME_SOC        5	// SoC on MN
+#define EPL_DLLK_TXFRAME_SOA        6	// SoA on MN
+#define EPL_DLLK_TXFRAME_PREQ       7	// PReq on MN
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-#define EPL_DLLK_TXFRAME_COUNT      (7 + EPL_D_NMT_MaxCNNumber_U8 + 2)   // on MN: 7 + MaxPReq of regular CNs + 1 Diag + 1 Router
+#define EPL_DLLK_TXFRAME_COUNT      (7 + EPL_D_NMT_MaxCNNumber_U8 + 2)	// on MN: 7 + MaxPReq of regular CNs + 1 Diag + 1 Router
 #else
-#define EPL_DLLK_TXFRAME_COUNT      5   // on CN: 5
+#define EPL_DLLK_TXFRAME_COUNT      5	// on CN: 5
 #endif
 
-#define EPL_DLLK_BUFLEN_EMPTY       0   // buffer is empty
-#define EPL_DLLK_BUFLEN_FILLING     1   // just the buffer is being filled
-#define EPL_DLLK_BUFLEN_MIN         60  // minimum ethernet frame length
+#define EPL_DLLK_BUFLEN_EMPTY       0	// buffer is empty
+#define EPL_DLLK_BUFLEN_FILLING     1	// just the buffer is being filled
+#define EPL_DLLK_BUFLEN_MIN         60	// minimum ethernet frame length
 
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 
-typedef enum
-{
-    kEplDllGsInit           = 0x00, // MN/CN: initialisation (< PreOp2)
-    kEplDllCsWaitPreq       = 0x01, // CN: wait for PReq frame
-    kEplDllCsWaitSoc        = 0x02, // CN: wait for SoC frame
-    kEplDllCsWaitSoa        = 0x03, // CN: wait for SoA frame
-    kEplDllMsNonCyclic      = 0x04, // MN: reduced EPL cycle (PreOp1)
-    kEplDllMsWaitSocTrig    = 0x05, // MN: wait for SoC trigger (cycle timer)
-    kEplDllMsWaitPreqTrig   = 0x06, // MN: wait for (first) PReq trigger (WaitSoCPReq_U32)
-    kEplDllMsWaitPres       = 0x07, // MN: wait for PRes frame from CN
-    kEplDllMsWaitSoaTrig    = 0x08, // MN: wait for SoA trigger (PRes transmitted)
-    kEplDllMsWaitAsndTrig   = 0x09, // MN: wait for ASnd trigger (SoA transmitted)
-    kEplDllMsWaitAsnd       = 0x0A, // MN: wait for ASnd frame if SoA contained invitation
+typedef enum {
+	kEplDllGsInit = 0x00,	// MN/CN: initialisation (< PreOp2)
+	kEplDllCsWaitPreq = 0x01,	// CN: wait for PReq frame
+	kEplDllCsWaitSoc = 0x02,	// CN: wait for SoC frame
+	kEplDllCsWaitSoa = 0x03,	// CN: wait for SoA frame
+	kEplDllMsNonCyclic = 0x04,	// MN: reduced EPL cycle (PreOp1)
+	kEplDllMsWaitSocTrig = 0x05,	// MN: wait for SoC trigger (cycle timer)
+	kEplDllMsWaitPreqTrig = 0x06,	// MN: wait for (first) PReq trigger (WaitSoCPReq_U32)
+	kEplDllMsWaitPres = 0x07,	// MN: wait for PRes frame from CN
+	kEplDllMsWaitSoaTrig = 0x08,	// MN: wait for SoA trigger (PRes transmitted)
+	kEplDllMsWaitAsndTrig = 0x09,	// MN: wait for ASnd trigger (SoA transmitted)
+	kEplDllMsWaitAsnd = 0x0A,	// MN: wait for ASnd frame if SoA contained invitation
 
 } tEplDllState;
 
-typedef struct
-{
-    BYTE                m_be_abSrcMac[6];
-    tEdrvTxBuffer*      m_pTxBuffer;        // Buffers for Tx-Frames
-    unsigned int        m_uiMaxTxFrames;
-    BYTE                m_bFlag1;           // Flag 1 with EN, EC for PRes, StatusRes
-    BYTE                m_bMnFlag1;         // Flag 1 with EA, ER from PReq, SoA of MN
-    BYTE                m_bFlag2;           // Flag 2 with PR and RS for PRes, StatusRes, IdentRes
-    tEplDllConfigParam  m_DllConfigParam;
-    tEplDllIdentParam   m_DllIdentParam;
-    tEplDllState        m_DllState;
-    tEplDllkCbAsync     m_pfnCbAsync;
-    tEplDllAsndFilter   m_aAsndFilter[EPL_DLL_MAX_ASND_SERVICE_ID];
+typedef struct {
+	BYTE m_be_abSrcMac[6];
+	tEdrvTxBuffer *m_pTxBuffer;	// Buffers for Tx-Frames
+	unsigned int m_uiMaxTxFrames;
+	BYTE m_bFlag1;		// Flag 1 with EN, EC for PRes, StatusRes
+	BYTE m_bMnFlag1;	// Flag 1 with EA, ER from PReq, SoA of MN
+	BYTE m_bFlag2;		// Flag 2 with PR and RS for PRes, StatusRes, IdentRes
+	tEplDllConfigParam m_DllConfigParam;
+	tEplDllIdentParam m_DllIdentParam;
+	tEplDllState m_DllState;
+	tEplDllkCbAsync m_pfnCbAsync;
+	tEplDllAsndFilter m_aAsndFilter[EPL_DLL_MAX_ASND_SERVICE_ID];
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    tEplDllkNodeInfo*   m_pFirstNodeInfo;
-    tEplDllkNodeInfo*   m_pCurNodeInfo;
-    tEplDllkNodeInfo    m_aNodeInfo[EPL_NMT_MAX_NODE_ID];
-    tEplDllReqServiceId m_LastReqServiceId;
-    unsigned int        m_uiLastTargetNodeId;
+	tEplDllkNodeInfo *m_pFirstNodeInfo;
+	tEplDllkNodeInfo *m_pCurNodeInfo;
+	tEplDllkNodeInfo m_aNodeInfo[EPL_NMT_MAX_NODE_ID];
+	tEplDllReqServiceId m_LastReqServiceId;
+	unsigned int m_uiLastTargetNodeId;
 #endif
 
 #if EPL_TIMER_USE_HIGHRES != FALSE
-    tEplTimerHdl        m_TimerHdlCycle;    // used for EPL cycle monitoring on CN and generation on MN
+	tEplTimerHdl m_TimerHdlCycle;	// used for EPL cycle monitoring on CN and generation on MN
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    tEplTimerHdl        m_TimerHdlResponse; // used for CN response monitoring
-#endif //(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
+	tEplTimerHdl m_TimerHdlResponse;	// used for CN response monitoring
+#endif				//(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 #endif
 
-    unsigned int        m_uiCycleCount;     // cycle counter (needed for multiplexed cycle support)
-    unsigned long long  m_ullFrameTimeout;  // frame timeout (cycle length + loss of frame tolerance)
+	unsigned int m_uiCycleCount;	// cycle counter (needed for multiplexed cycle support)
+	unsigned long long m_ullFrameTimeout;	// frame timeout (cycle length + loss of frame tolerance)
 
 } tEplDllkInstance;
 
-
 //---------------------------------------------------------------------------
 // local vars
 //---------------------------------------------------------------------------
 
 // if no dynamic memory allocation shall be used
 // define structures statically
-static tEplDllkInstance     EplDllkInstance_g;
-
-static tEdrvTxBuffer        aEplDllkTxBuffer_l[EPL_DLLK_TXFRAME_COUNT];
+static tEplDllkInstance EplDllkInstance_g;
 
+static tEdrvTxBuffer aEplDllkTxBuffer_l[EPL_DLLK_TXFRAME_COUNT];
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
 // change DLL state on event
-static tEplKernel EplDllkChangeState(tEplNmtEvent NmtEvent_p, tEplNmtState NmtState_p);
+static tEplKernel EplDllkChangeState(tEplNmtEvent NmtEvent_p,
+				     tEplNmtState NmtState_p);
 
 // called from EdrvInterruptHandler()
 static void EplDllkCbFrameReceived(tEdrvRxBuffer * pRxBuffer_p);
@@ -257,32 +252,36 @@ static void EplDllkCbFrameReceived(tEdrv
 static void EplDllkCbFrameTransmitted(tEdrvTxBuffer * pTxBuffer_p);
 
 // check frame and set missing information
-static tEplKernel EplDllkCheckFrame(tEplFrame * pFrame_p, unsigned int uiFrameSize_p);
+static tEplKernel EplDllkCheckFrame(tEplFrame * pFrame_p,
+				    unsigned int uiFrameSize_p);
 
 // called by high resolution timer module to monitor EPL cycle as CN
 #if EPL_TIMER_USE_HIGHRES != FALSE
-static tEplKernel PUBLIC EplDllkCbCnTimer(tEplTimerEventArg* pEventArg_p);
+static tEplKernel PUBLIC EplDllkCbCnTimer(tEplTimerEventArg * pEventArg_p);
 #endif
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 // MN: returns internal node info structure
-static tEplDllkNodeInfo* EplDllkGetNodeInfo(unsigned int uiNodeId_p);
+static tEplDllkNodeInfo *EplDllkGetNodeInfo(unsigned int uiNodeId_p);
 
 // transmit SoA
 static tEplKernel EplDllkMnSendSoa(tEplNmtState NmtState_p,
-                                   tEplDllState* pDllStateProposed_p,
-                                   BOOL fEnableInvitation_p);
+				   tEplDllState * pDllStateProposed_p,
+				   BOOL fEnableInvitation_p);
 
 static tEplKernel EplDllkMnSendSoc(void);
 
 static tEplKernel EplDllkMnSendPreq(tEplNmtState NmtState_p,
-                                    tEplDllState* pDllStateProposed_p);
+				    tEplDllState * pDllStateProposed_p);
 
-static tEplKernel EplDllkAsyncFrameNotReceived(tEplDllReqServiceId ReqServiceId_p, unsigned int uiNodeId_p);
+static tEplKernel EplDllkAsyncFrameNotReceived(tEplDllReqServiceId
+					       ReqServiceId_p,
+					       unsigned int uiNodeId_p);
 
-static tEplKernel PUBLIC EplDllkCbMnTimerCycle(tEplTimerEventArg* pEventArg_p);
+static tEplKernel PUBLIC EplDllkCbMnTimerCycle(tEplTimerEventArg * pEventArg_p);
 
-static tEplKernel PUBLIC EplDllkCbMnTimerResponse(tEplTimerEventArg* pEventArg_p);
+static tEplKernel PUBLIC EplDllkCbMnTimerResponse(tEplTimerEventArg *
+						  pEventArg_p);
 
 #endif
 
@@ -309,68 +308,68 @@ static tEplKernel PUBLIC EplDllkCbMnTime
 
 tEplKernel EplDllkAddInstance(tEplDllkInitParam * pInitParam_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-unsigned int    uiIndex;
-tEdrvInitParam  EdrvInitParam;
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiIndex;
+	tEdrvInitParam EdrvInitParam;
 
-    // reset instance structure
-    EPL_MEMSET(&EplDllkInstance_g, 0, sizeof (EplDllkInstance_g));
+	// reset instance structure
+	EPL_MEMSET(&EplDllkInstance_g, 0, sizeof(EplDllkInstance_g));
 
 #if EPL_TIMER_USE_HIGHRES != FALSE
-    Ret = EplTimerHighReskInit();
-    if (Ret != kEplSuccessful)
-    {   // error occured while initializing high resolution timer module
-        goto Exit;
-    }
-#endif
+	Ret = EplTimerHighReskInit();
+	if (Ret != kEplSuccessful) {	// error occured while initializing high resolution timer module
+		goto Exit;
+	}
+#endif
+
+	// if dynamic memory allocation available
+	// allocate instance structure
+	// allocate TPDO and RPDO table with default size
+
+	// initialize and link pointers in instance structure to frame tables
+	EplDllkInstance_g.m_pTxBuffer = aEplDllkTxBuffer_l;
+	EplDllkInstance_g.m_uiMaxTxFrames =
+	    sizeof(aEplDllkTxBuffer_l) / sizeof(tEdrvTxBuffer);
 
-    // if dynamic memory allocation available
-    // allocate instance structure
-    // allocate TPDO and RPDO table with default size
-
-    // initialize and link pointers in instance structure to frame tables
-    EplDllkInstance_g.m_pTxBuffer = aEplDllkTxBuffer_l;
-    EplDllkInstance_g.m_uiMaxTxFrames = sizeof (aEplDllkTxBuffer_l) / sizeof (tEdrvTxBuffer);
-
-    // initialize state
-    EplDllkInstance_g.m_DllState = kEplDllGsInit;
+	// initialize state
+	EplDllkInstance_g.m_DllState = kEplDllGsInit;
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    // set up node info structure
-    for (uiIndex = 0; uiIndex < tabentries (EplDllkInstance_g.m_aNodeInfo); uiIndex++)
-    {
-        EplDllkInstance_g.m_aNodeInfo[uiIndex].m_uiNodeId = uiIndex + 1;
-        EplDllkInstance_g.m_aNodeInfo[uiIndex].m_wPresPayloadLimit = 0xFFFF;
-    }
-#endif
-
-    // initialize Edrv
-    EPL_MEMCPY(EdrvInitParam.m_abMyMacAddr, pInitParam_p->m_be_abSrcMac, 6);
-    EdrvInitParam.m_pfnRxHandler = EplDllkCbFrameReceived;
-    EdrvInitParam.m_pfnTxHandler = EplDllkCbFrameTransmitted;
-    Ret = EdrvInit(&EdrvInitParam);
-    if (Ret != kEplSuccessful)
-    {   // error occured while initializing ethernet driver
-        goto Exit;
-    }
-
-    // copy local MAC address from Ethernet driver back to local instance structure
-    // because Ethernet driver may have read it from controller EEPROM
-    EPL_MEMCPY(EplDllkInstance_g.m_be_abSrcMac, EdrvInitParam.m_abMyMacAddr, 6);
-    EPL_MEMCPY(pInitParam_p->m_be_abSrcMac, EdrvInitParam.m_abMyMacAddr, 6);
-
-    // initialize TxBuffer array
-    for (uiIndex = 0; uiIndex < EplDllkInstance_g.m_uiMaxTxFrames; uiIndex++)
-    {
-        EplDllkInstance_g.m_pTxBuffer[uiIndex].m_pbBuffer = NULL;
-    }
+	// set up node info structure
+	for (uiIndex = 0; uiIndex < tabentries(EplDllkInstance_g.m_aNodeInfo);
+	     uiIndex++) {
+		EplDllkInstance_g.m_aNodeInfo[uiIndex].m_uiNodeId = uiIndex + 1;
+		EplDllkInstance_g.m_aNodeInfo[uiIndex].m_wPresPayloadLimit =
+		    0xFFFF;
+	}
+#endif
+
+	// initialize Edrv
+	EPL_MEMCPY(EdrvInitParam.m_abMyMacAddr, pInitParam_p->m_be_abSrcMac, 6);
+	EdrvInitParam.m_pfnRxHandler = EplDllkCbFrameReceived;
+	EdrvInitParam.m_pfnTxHandler = EplDllkCbFrameTransmitted;
+	Ret = EdrvInit(&EdrvInitParam);
+	if (Ret != kEplSuccessful) {	// error occured while initializing ethernet driver
+		goto Exit;
+	}
+	// copy local MAC address from Ethernet driver back to local instance structure
+	// because Ethernet driver may have read it from controller EEPROM
+	EPL_MEMCPY(EplDllkInstance_g.m_be_abSrcMac, EdrvInitParam.m_abMyMacAddr,
+		   6);
+	EPL_MEMCPY(pInitParam_p->m_be_abSrcMac, EdrvInitParam.m_abMyMacAddr, 6);
+
+	// initialize TxBuffer array
+	for (uiIndex = 0; uiIndex < EplDllkInstance_g.m_uiMaxTxFrames;
+	     uiIndex++) {
+		EplDllkInstance_g.m_pTxBuffer[uiIndex].m_pbBuffer = NULL;
+	}
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_VETH)) != 0)
-    Ret = VEthAddInstance(pInitParam_p);
+	Ret = VEthAddInstance(pInitParam_p);
 #endif
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -390,21 +389,21 @@ Exit:
 
 tEplKernel EplDllkDelInstance(void)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    // reset state
-    EplDllkInstance_g.m_DllState = kEplDllGsInit;
+	// reset state
+	EplDllkInstance_g.m_DllState = kEplDllGsInit;
 
 #if EPL_TIMER_USE_HIGHRES != FALSE
-    Ret = EplTimerHighReskDelInstance();
+	Ret = EplTimerHighReskDelInstance();
 #endif
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_VETH)) != 0)
-    Ret = VEthDelInstance();
+	Ret = VEthDelInstance();
 #endif
 
-    Ret = EdrvShutdown();
-    return Ret;
+	Ret = EdrvShutdown();
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -431,192 +430,182 @@ tEplKernel      Ret = kEplSuccessful;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkCreateTxFrame (unsigned int * puiHandle_p,
-                                 tEplFrame ** ppFrame_p,
-                                 unsigned int * puiFrameSize_p,
-                                 tEplMsgType MsgType_p,
-                                 tEplDllAsndServiceId ServiceId_p)
-{
-tEplKernel      Ret = kEplSuccessful;
-tEplFrame      *pTxFrame;
-unsigned int    uiHandle = EplDllkInstance_g.m_uiMaxTxFrames;
-tEdrvTxBuffer  *pTxBuffer = NULL;
-
-    if (MsgType_p == kEplMsgTypeAsnd)
-    {
-        // search for fixed Tx buffers
-        if (ServiceId_p == kEplDllAsndIdentResponse)
-        {
-            uiHandle = EPL_DLLK_TXFRAME_IDENTRES;
-        }
-        else if (ServiceId_p == kEplDllAsndStatusResponse)
-        {
-            uiHandle = EPL_DLLK_TXFRAME_STATUSRES;
-        }
-        else if ((ServiceId_p == kEplDllAsndNmtRequest) || (ServiceId_p == kEplDllAsndNmtCommand))
-        {
-            uiHandle = EPL_DLLK_TXFRAME_NMTREQ;
-        }
-
-        if (uiHandle >= EplDllkInstance_g.m_uiMaxTxFrames)
-        {   // look for free entry
-            uiHandle = EPL_DLLK_TXFRAME_PREQ;
-            pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[uiHandle];
-            for (; uiHandle < EplDllkInstance_g.m_uiMaxTxFrames; uiHandle++, pTxBuffer++)
-            {
-                if (pTxBuffer->m_pbBuffer == NULL)
-                {   // free entry found
-                    break;
-                }
-            }
-        }
-    }
-    else if (MsgType_p == kEplMsgTypeNonEpl)
-    {
-        uiHandle = EPL_DLLK_TXFRAME_NONEPL;
-    }
-    else if (MsgType_p == kEplMsgTypePres)
-    {
-        uiHandle = EPL_DLLK_TXFRAME_PRES;
-    }
-    else if (MsgType_p == kEplMsgTypeSoc)
-    {
-        uiHandle = EPL_DLLK_TXFRAME_SOC;
-    }
-    else if (MsgType_p == kEplMsgTypeSoa)
-    {
-        uiHandle = EPL_DLLK_TXFRAME_SOA;
-    }
-    else
-    {   // look for free entry
-        uiHandle = EPL_DLLK_TXFRAME_PREQ;
-        pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[uiHandle];
-        for (; uiHandle < EplDllkInstance_g.m_uiMaxTxFrames; uiHandle++, pTxBuffer++)
-        {
-            if (pTxBuffer->m_pbBuffer == NULL)
-            {   // free entry found
-                break;
-            }
-        }
-        if (pTxBuffer->m_pbBuffer != NULL)
-        {
-            Ret = kEplEdrvNoFreeBufEntry;
-            goto Exit;
-        }
-    }
+tEplKernel EplDllkCreateTxFrame(unsigned int *puiHandle_p,
+				tEplFrame ** ppFrame_p,
+				unsigned int *puiFrameSize_p,
+				tEplMsgType MsgType_p,
+				tEplDllAsndServiceId ServiceId_p)
+{
+	tEplKernel Ret = kEplSuccessful;
+	tEplFrame *pTxFrame;
+	unsigned int uiHandle = EplDllkInstance_g.m_uiMaxTxFrames;
+	tEdrvTxBuffer *pTxBuffer = NULL;
+
+	if (MsgType_p == kEplMsgTypeAsnd) {
+		// search for fixed Tx buffers
+		if (ServiceId_p == kEplDllAsndIdentResponse) {
+			uiHandle = EPL_DLLK_TXFRAME_IDENTRES;
+		} else if (ServiceId_p == kEplDllAsndStatusResponse) {
+			uiHandle = EPL_DLLK_TXFRAME_STATUSRES;
+		} else if ((ServiceId_p == kEplDllAsndNmtRequest)
+			   || (ServiceId_p == kEplDllAsndNmtCommand)) {
+			uiHandle = EPL_DLLK_TXFRAME_NMTREQ;
+		}
+
+		if (uiHandle >= EplDllkInstance_g.m_uiMaxTxFrames) {	// look for free entry
+			uiHandle = EPL_DLLK_TXFRAME_PREQ;
+			pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[uiHandle];
+			for (; uiHandle < EplDllkInstance_g.m_uiMaxTxFrames;
+			     uiHandle++, pTxBuffer++) {
+				if (pTxBuffer->m_pbBuffer == NULL) {	// free entry found
+					break;
+				}
+			}
+		}
+	} else if (MsgType_p == kEplMsgTypeNonEpl) {
+		uiHandle = EPL_DLLK_TXFRAME_NONEPL;
+	} else if (MsgType_p == kEplMsgTypePres) {
+		uiHandle = EPL_DLLK_TXFRAME_PRES;
+	} else if (MsgType_p == kEplMsgTypeSoc) {
+		uiHandle = EPL_DLLK_TXFRAME_SOC;
+	} else if (MsgType_p == kEplMsgTypeSoa) {
+		uiHandle = EPL_DLLK_TXFRAME_SOA;
+	} else {		// look for free entry
+		uiHandle = EPL_DLLK_TXFRAME_PREQ;
+		pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[uiHandle];
+		for (; uiHandle < EplDllkInstance_g.m_uiMaxTxFrames;
+		     uiHandle++, pTxBuffer++) {
+			if (pTxBuffer->m_pbBuffer == NULL) {	// free entry found
+				break;
+			}
+		}
+		if (pTxBuffer->m_pbBuffer != NULL) {
+			Ret = kEplEdrvNoFreeBufEntry;
+			goto Exit;
+		}
+	}
+
+	// test if requested entry is free
+	pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[uiHandle];
+	if (pTxBuffer->m_pbBuffer != NULL) {	// entry is not free
+		Ret = kEplEdrvNoFreeBufEntry;
+		goto Exit;
+	}
+	// setup Tx buffer
+	pTxBuffer->m_EplMsgType = MsgType_p;
+	pTxBuffer->m_uiMaxBufferLen = *puiFrameSize_p;
+
+	Ret = EdrvAllocTxMsgBuffer(pTxBuffer);
+	if (Ret != kEplSuccessful) {	// error occured while registering Tx frame
+		goto Exit;
+	}
+	// because buffer size may be larger than requested
+	// memorize real length of frame
+	pTxBuffer->m_uiTxMsgLen = *puiFrameSize_p;
+
+	// fill whole frame with 0
+	EPL_MEMSET(pTxBuffer->m_pbBuffer, 0, pTxBuffer->m_uiMaxBufferLen);
+
+	pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
+
+	if (MsgType_p != kEplMsgTypeNonEpl) {	// fill out Frame only if it is an EPL frame
+		// ethertype
+		AmiSetWordToBe(&pTxFrame->m_be_wEtherType,
+			       EPL_C_DLL_ETHERTYPE_EPL);
+		// source node ID
+		AmiSetByteToLe(&pTxFrame->m_le_bSrcNodeId,
+			       (BYTE) EplDllkInstance_g.m_DllConfigParam.
+			       m_uiNodeId);
+		// source MAC address
+		EPL_MEMCPY(&pTxFrame->m_be_abSrcMac[0],
+			   &EplDllkInstance_g.m_be_abSrcMac[0], 6);
+		switch (MsgType_p) {
+		case kEplMsgTypeAsnd:
+			// destination MAC address
+			AmiSetQword48ToBe(&pTxFrame->m_be_abDstMac[0],
+					  EPL_C_DLL_MULTICAST_ASND);
+			// destination node ID
+			switch (ServiceId_p) {
+			case kEplDllAsndIdentResponse:
+			case kEplDllAsndStatusResponse:
+				{	// IdentResponses and StatusResponses are Broadcast
+					AmiSetByteToLe(&pTxFrame->
+						       m_le_bDstNodeId,
+						       (BYTE)
+						       EPL_C_ADR_BROADCAST);
+					break;
+				}
+
+			default:
+				break;
+			}
+			// ASnd Service ID
+			AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_le_bServiceId,
+				       ServiceId_p);
+			break;
+
+		case kEplMsgTypeSoc:
+			// destination MAC address
+			AmiSetQword48ToBe(&pTxFrame->m_be_abDstMac[0],
+					  EPL_C_DLL_MULTICAST_SOC);
+			// destination node ID
+			AmiSetByteToLe(&pTxFrame->m_le_bDstNodeId,
+				       (BYTE) EPL_C_ADR_BROADCAST);
+			// reset Flags
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soc.m_le_bFlag1, (BYTE) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soc.m_le_bFlag2, (BYTE) 0);
+			break;
+
+		case kEplMsgTypeSoa:
+			// destination MAC address
+			AmiSetQword48ToBe(&pTxFrame->m_be_abDstMac[0],
+					  EPL_C_DLL_MULTICAST_SOA);
+			// destination node ID
+			AmiSetByteToLe(&pTxFrame->m_le_bDstNodeId,
+				       (BYTE) EPL_C_ADR_BROADCAST);
+			// reset Flags
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bFlag1, (BYTE) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bFlag2, (BYTE) 0);
+			// EPL profile version
+			AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bEplVersion,
+				       (BYTE) EPL_SPEC_VERSION);
+			break;
+
+		case kEplMsgTypePres:
+			// destination MAC address
+			AmiSetQword48ToBe(&pTxFrame->m_be_abDstMac[0],
+					  EPL_C_DLL_MULTICAST_PRES);
+			// destination node ID
+			AmiSetByteToLe(&pTxFrame->m_le_bDstNodeId,
+				       (BYTE) EPL_C_ADR_BROADCAST);
+			// reset Flags
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag1, (BYTE) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag2, (BYTE) 0);
+			// PDO size
+			//AmiSetWordToLe(&pTxFrame->m_Data.m_Pres.m_le_wSize, 0);
+			break;
+
+		case kEplMsgTypePreq:
+			// reset Flags
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag1, (BYTE) 0);
+			//AmiSetByteToLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag2, (BYTE) 0);
+			// PDO size
+			//AmiSetWordToLe(&pTxFrame->m_Data.m_Preq.m_le_wSize, 0);
+			break;
+
+		default:
+			break;
+		}
+		// EPL message type
+		AmiSetByteToLe(&pTxFrame->m_le_bMessageType, (BYTE) MsgType_p);
+	}
+
+	*ppFrame_p = pTxFrame;
+	*puiFrameSize_p = pTxBuffer->m_uiMaxBufferLen;
+	*puiHandle_p = uiHandle;
 
-    // test if requested entry is free
-    pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[uiHandle];
-    if (pTxBuffer->m_pbBuffer != NULL)
-    {   // entry is not free
-        Ret = kEplEdrvNoFreeBufEntry;
-        goto Exit;
-    }
-
-    // setup Tx buffer
-    pTxBuffer->m_EplMsgType = MsgType_p;
-    pTxBuffer->m_uiMaxBufferLen = *puiFrameSize_p;
-
-    Ret = EdrvAllocTxMsgBuffer(pTxBuffer);
-    if (Ret != kEplSuccessful)
-    {   // error occured while registering Tx frame
-        goto Exit;
-    }
-
-    // because buffer size may be larger than requested
-    // memorize real length of frame
-    pTxBuffer->m_uiTxMsgLen = *puiFrameSize_p;
-
-    // fill whole frame with 0
-    EPL_MEMSET(pTxBuffer->m_pbBuffer, 0, pTxBuffer->m_uiMaxBufferLen);
-
-    pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
-
-    if (MsgType_p != kEplMsgTypeNonEpl)
-    {   // fill out Frame only if it is an EPL frame
-        // ethertype
-        AmiSetWordToBe(&pTxFrame->m_be_wEtherType, EPL_C_DLL_ETHERTYPE_EPL);
-        // source node ID
-        AmiSetByteToLe(&pTxFrame->m_le_bSrcNodeId, (BYTE) EplDllkInstance_g.m_DllConfigParam.m_uiNodeId);
-        // source MAC address
-        EPL_MEMCPY(&pTxFrame->m_be_abSrcMac[0], &EplDllkInstance_g.m_be_abSrcMac[0], 6);
-        switch (MsgType_p)
-        {
-            case kEplMsgTypeAsnd:
-                // destination MAC address
-                AmiSetQword48ToBe(&pTxFrame->m_be_abDstMac[0], EPL_C_DLL_MULTICAST_ASND);
-                // destination node ID
-                switch (ServiceId_p)
-                {
-                    case kEplDllAsndIdentResponse:
-                    case kEplDllAsndStatusResponse:
-                    {   // IdentResponses and StatusResponses are Broadcast
-                        AmiSetByteToLe(&pTxFrame->m_le_bDstNodeId, (BYTE) EPL_C_ADR_BROADCAST);
-                        break;
-                    }
-
-                    default:
-                        break;
-                }
-                // ASnd Service ID
-                AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_le_bServiceId, ServiceId_p);
-                break;
-
-            case kEplMsgTypeSoc:
-                // destination MAC address
-                AmiSetQword48ToBe(&pTxFrame->m_be_abDstMac[0], EPL_C_DLL_MULTICAST_SOC);
-                // destination node ID
-                AmiSetByteToLe(&pTxFrame->m_le_bDstNodeId, (BYTE) EPL_C_ADR_BROADCAST);
-                // reset Flags
-                //AmiSetByteToLe(&pTxFrame->m_Data.m_Soc.m_le_bFlag1, (BYTE) 0);
-                //AmiSetByteToLe(&pTxFrame->m_Data.m_Soc.m_le_bFlag2, (BYTE) 0);
-                break;
-
-            case kEplMsgTypeSoa:
-                // destination MAC address
-                AmiSetQword48ToBe(&pTxFrame->m_be_abDstMac[0], EPL_C_DLL_MULTICAST_SOA);
-                // destination node ID
-                AmiSetByteToLe(&pTxFrame->m_le_bDstNodeId, (BYTE) EPL_C_ADR_BROADCAST);
-                // reset Flags
-                //AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bFlag1, (BYTE) 0);
-                //AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bFlag2, (BYTE) 0);
-                // EPL profile version
-                AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bEplVersion, (BYTE) EPL_SPEC_VERSION);
-                break;
-
-            case kEplMsgTypePres:
-                // destination MAC address
-                AmiSetQword48ToBe(&pTxFrame->m_be_abDstMac[0], EPL_C_DLL_MULTICAST_PRES);
-                // destination node ID
-                AmiSetByteToLe(&pTxFrame->m_le_bDstNodeId, (BYTE) EPL_C_ADR_BROADCAST);
-                // reset Flags
-                //AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag1, (BYTE) 0);
-                //AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag2, (BYTE) 0);
-                // PDO size
-                //AmiSetWordToLe(&pTxFrame->m_Data.m_Pres.m_le_wSize, 0);
-                break;
-
-            case kEplMsgTypePreq:
-                // reset Flags
-                //AmiSetByteToLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag1, (BYTE) 0);
-                //AmiSetByteToLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag2, (BYTE) 0);
-                // PDO size
-                //AmiSetWordToLe(&pTxFrame->m_Data.m_Preq.m_le_wSize, 0);
-                break;
-
-            default:
-                break;
-        }
-        // EPL message type
-        AmiSetByteToLe(&pTxFrame->m_le_bMessageType, (BYTE) MsgType_p);
-    }
-
-    *ppFrame_p = pTxFrame;
-    *puiFrameSize_p = pTxBuffer->m_uiMaxBufferLen;
-    *puiHandle_p = uiHandle;
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -635,33 +624,31 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkDeleteTxFrame (unsigned int uiHandle_p)
+tEplKernel EplDllkDeleteTxFrame(unsigned int uiHandle_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEdrvTxBuffer    *pTxBuffer = NULL;
+	tEplKernel Ret = kEplSuccessful;
+	tEdrvTxBuffer *pTxBuffer = NULL;
 
-    if (uiHandle_p >= EplDllkInstance_g.m_uiMaxTxFrames)
-    {   // handle is not valid
-        Ret = kEplDllIllegalHdl;
-        goto Exit;
-    }
-
-    pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[uiHandle_p];
-
-    // mark buffer as free so that frame will not be send in future anymore
-    // $$$ d.k. What's up with running transmissions?
-    pTxBuffer->m_uiTxMsgLen = EPL_DLLK_BUFLEN_EMPTY;
-    pTxBuffer->m_pbBuffer = NULL;
-
-    // delete Tx buffer
-    Ret = EdrvReleaseTxMsgBuffer(pTxBuffer);
-    if (Ret != kEplSuccessful)
-    {   // error occured while releasing Tx frame
-        goto Exit;
-    }
+	if (uiHandle_p >= EplDllkInstance_g.m_uiMaxTxFrames) {	// handle is not valid
+		Ret = kEplDllIllegalHdl;
+		goto Exit;
+	}
+
+	pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[uiHandle_p];
+
+	// mark buffer as free so that frame will not be send in future anymore
+	// $$$ d.k. What's up with running transmissions?
+	pTxBuffer->m_uiTxMsgLen = EPL_DLLK_BUFLEN_EMPTY;
+	pTxBuffer->m_pbBuffer = NULL;
+
+	// delete Tx buffer
+	Ret = EdrvReleaseTxMsgBuffer(pTxBuffer);
+	if (Ret != kEplSuccessful) {	// error occured while releasing Tx frame
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -681,544 +668,677 @@ Exit:
 
 tEplKernel EplDllkProcess(tEplEvent * pEvent_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplFrame      *pTxFrame;
-tEdrvTxBuffer  *pTxBuffer;
-unsigned int    uiHandle;
-unsigned int    uiFrameSize;
-BYTE            abMulticastMac[6];
-tEplDllAsyncReqPriority AsyncReqPriority;
-unsigned int    uiFrameCount;
-tEplNmtState    NmtState;
+	tEplKernel Ret = kEplSuccessful;
+	tEplFrame *pTxFrame;
+	tEdrvTxBuffer *pTxBuffer;
+	unsigned int uiHandle;
+	unsigned int uiFrameSize;
+	BYTE abMulticastMac[6];
+	tEplDllAsyncReqPriority AsyncReqPriority;
+	unsigned int uiFrameCount;
+	tEplNmtState NmtState;
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
-tEplFrameInfo   FrameInfo;
+	tEplFrameInfo FrameInfo;
 #endif
 
+	switch (pEvent_p->m_EventType) {
+	case kEplEventTypeDllkCreate:
+		{
+			// $$$ reset ethernet driver
 
-    switch (pEvent_p->m_EventType)
-    {
-        case kEplEventTypeDllkCreate:
-        {
-            // $$$ reset ethernet driver
+			NmtState = *((tEplNmtState *) pEvent_p->m_pArg);
 
-            NmtState = *((tEplNmtState*)pEvent_p->m_pArg);
-
-            // initialize flags for PRes and StatusRes
-            EplDllkInstance_g.m_bFlag1 = EPL_FRAME_FLAG1_EC;
-            EplDllkInstance_g.m_bMnFlag1 = 0;
-            EplDllkInstance_g.m_bFlag2 = 0;
+			// initialize flags for PRes and StatusRes
+			EplDllkInstance_g.m_bFlag1 = EPL_FRAME_FLAG1_EC;
+			EplDllkInstance_g.m_bMnFlag1 = 0;
+			EplDllkInstance_g.m_bFlag2 = 0;
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-            // initialize linked node list
-            EplDllkInstance_g.m_pFirstNodeInfo = NULL;
+			// initialize linked node list
+			EplDllkInstance_g.m_pFirstNodeInfo = NULL;
 #endif
 
-            // register TxFrames in Edrv
-
-            // IdentResponse
-            uiFrameSize = EPL_C_DLL_MINSIZE_IDENTRES;
-            Ret = EplDllkCreateTxFrame(&uiHandle, &pTxFrame, &uiFrameSize, kEplMsgTypeAsnd, kEplDllAsndIdentResponse);
-            if (Ret != kEplSuccessful)
-            {   // error occured while registering Tx frame
-                goto Exit;
-            }
-
-            // EPL profile version
-            AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_bEplProfileVersion,
-                (BYTE) EPL_SPEC_VERSION);
-            // FeatureFlags
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwFeatureFlags,
-                EplDllkInstance_g.m_DllConfigParam.m_dwFeatureFlags);
-            // MTU
-            AmiSetWordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_wMtu,
-                (WORD) EplDllkInstance_g.m_DllConfigParam.m_uiAsyncMtu);
-            // PollInSize
-            AmiSetWordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_wPollInSize,
-                (WORD)EplDllkInstance_g.m_DllConfigParam.m_uiPreqActPayloadLimit);
-            // PollOutSize
-            AmiSetWordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_wPollOutSize,
-                (WORD)EplDllkInstance_g.m_DllConfigParam.m_uiPresActPayloadLimit);
-            // ResponseTime / PresMaxLatency
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwResponseTime,
-                EplDllkInstance_g.m_DllConfigParam.m_dwPresMaxLatency);
-            // DeviceType
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwDeviceType,
-                EplDllkInstance_g.m_DllIdentParam.m_dwDeviceType);
-            // VendorId
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwVendorId,
-                EplDllkInstance_g.m_DllIdentParam.m_dwVendorId);
-            // ProductCode
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwProductCode,
-                EplDllkInstance_g.m_DllIdentParam.m_dwProductCode);
-            // RevisionNumber
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwRevisionNumber,
-                EplDllkInstance_g.m_DllIdentParam.m_dwRevisionNumber);
-            // SerialNumber
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwSerialNumber,
-                EplDllkInstance_g.m_DllIdentParam.m_dwSerialNumber);
-            // VendorSpecificExt1
-            AmiSetQword64ToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_qwVendorSpecificExt1,
-                EplDllkInstance_g.m_DllIdentParam.m_qwVendorSpecificExt1);
-            // VerifyConfigurationDate
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwVerifyConfigurationDate,
-                EplDllkInstance_g.m_DllIdentParam.m_dwVerifyConfigurationDate);
-            // VerifyConfigurationTime
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwVerifyConfigurationTime,
-                EplDllkInstance_g.m_DllIdentParam.m_dwVerifyConfigurationTime);
-            // ApplicationSwDate
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwApplicationSwDate,
-                EplDllkInstance_g.m_DllIdentParam.m_dwApplicationSwDate);
-            // ApplicationSwTime
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwApplicationSwTime,
-                EplDllkInstance_g.m_DllIdentParam.m_dwApplicationSwTime);
-            // IPAddress
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwIpAddress,
-                EplDllkInstance_g.m_DllIdentParam.m_dwIpAddress);
-            // SubnetMask
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwSubnetMask,
-                EplDllkInstance_g.m_DllIdentParam.m_dwSubnetMask);
-            // DefaultGateway
-            AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_dwDefaultGateway,
-                EplDllkInstance_g.m_DllIdentParam.m_dwDefaultGateway);
-            // HostName
-            EPL_MEMCPY(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_sHostname[0],
-                &EplDllkInstance_g.m_DllIdentParam.m_sHostname[0],
-                sizeof (EplDllkInstance_g.m_DllIdentParam.m_sHostname));
-            // VendorSpecificExt2
-            EPL_MEMCPY(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_abVendorSpecificExt2[0],
-                &EplDllkInstance_g.m_DllIdentParam.m_abVendorSpecificExt2[0],
-                sizeof (EplDllkInstance_g.m_DllIdentParam.m_abVendorSpecificExt2));
-
-            // StatusResponse
-            uiFrameSize = EPL_C_DLL_MINSIZE_STATUSRES;
-            Ret = EplDllkCreateTxFrame(&uiHandle, &pTxFrame, &uiFrameSize, kEplMsgTypeAsnd, kEplDllAsndStatusResponse);
-            if (Ret != kEplSuccessful)
-            {   // error occured while registering Tx frame
-                goto Exit;
-            }
-
-            // PRes $$$ maybe move this to PDO module
-            if ((EplDllkInstance_g.m_DllConfigParam.m_fAsyncOnly == FALSE)
-                && (EplDllkInstance_g.m_DllConfigParam.m_uiPresActPayloadLimit >= 36))
-            {   // it is not configured as async-only CN,
-                // so take part in isochronous phase and register PRes frame
-                uiFrameSize = EplDllkInstance_g.m_DllConfigParam.m_uiPresActPayloadLimit + 24;
-                Ret = EplDllkCreateTxFrame(&uiHandle, &pTxFrame, &uiFrameSize, kEplMsgTypePres, kEplDllAsndNotDefined);
-                if (Ret != kEplSuccessful)
-                {   // error occured while registering Tx frame
-                    goto Exit;
-                }
+			// register TxFrames in Edrv
 
+			// IdentResponse
+			uiFrameSize = EPL_C_DLL_MINSIZE_IDENTRES;
+			Ret =
+			    EplDllkCreateTxFrame(&uiHandle, &pTxFrame,
+						 &uiFrameSize, kEplMsgTypeAsnd,
+						 kEplDllAsndIdentResponse);
+			if (Ret != kEplSuccessful) {	// error occured while registering Tx frame
+				goto Exit;
+			}
+			// EPL profile version
+			AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+				       m_IdentResponse.m_le_bEplProfileVersion,
+				       (BYTE) EPL_SPEC_VERSION);
+			// FeatureFlags
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.m_le_dwFeatureFlags,
+					EplDllkInstance_g.m_DllConfigParam.
+					m_dwFeatureFlags);
+			// MTU
+			AmiSetWordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+				       m_IdentResponse.m_le_wMtu,
+				       (WORD) EplDllkInstance_g.
+				       m_DllConfigParam.m_uiAsyncMtu);
+			// PollInSize
+			AmiSetWordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+				       m_IdentResponse.m_le_wPollInSize,
+				       (WORD) EplDllkInstance_g.
+				       m_DllConfigParam.
+				       m_uiPreqActPayloadLimit);
+			// PollOutSize
+			AmiSetWordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+				       m_IdentResponse.m_le_wPollOutSize,
+				       (WORD) EplDllkInstance_g.
+				       m_DllConfigParam.
+				       m_uiPresActPayloadLimit);
+			// ResponseTime / PresMaxLatency
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.m_le_dwResponseTime,
+					EplDllkInstance_g.m_DllConfigParam.
+					m_dwPresMaxLatency);
+			// DeviceType
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.m_le_dwDeviceType,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwDeviceType);
+			// VendorId
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.m_le_dwVendorId,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwVendorId);
+			// ProductCode
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.m_le_dwProductCode,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwProductCode);
+			// RevisionNumber
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.m_le_dwRevisionNumber,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwRevisionNumber);
+			// SerialNumber
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.m_le_dwSerialNumber,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwSerialNumber);
+			// VendorSpecificExt1
+			AmiSetQword64ToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					  m_IdentResponse.
+					  m_le_qwVendorSpecificExt1,
+					  EplDllkInstance_g.m_DllIdentParam.
+					  m_qwVendorSpecificExt1);
+			// VerifyConfigurationDate
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.
+					m_le_dwVerifyConfigurationDate,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwVerifyConfigurationDate);
+			// VerifyConfigurationTime
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.
+					m_le_dwVerifyConfigurationTime,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwVerifyConfigurationTime);
+			// ApplicationSwDate
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.
+					m_le_dwApplicationSwDate,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwApplicationSwDate);
+			// ApplicationSwTime
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.
+					m_le_dwApplicationSwTime,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwApplicationSwTime);
+			// IPAddress
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.m_le_dwIpAddress,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwIpAddress);
+			// SubnetMask
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.m_le_dwSubnetMask,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwSubnetMask);
+			// DefaultGateway
+			AmiSetDwordToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.
+					m_IdentResponse.m_le_dwDefaultGateway,
+					EplDllkInstance_g.m_DllIdentParam.
+					m_dwDefaultGateway);
+			// HostName
+			EPL_MEMCPY(&pTxFrame->m_Data.m_Asnd.m_Payload.
+				   m_IdentResponse.m_le_sHostname[0],
+				   &EplDllkInstance_g.m_DllIdentParam.
+				   m_sHostname[0],
+				   sizeof(EplDllkInstance_g.m_DllIdentParam.
+					  m_sHostname));
+			// VendorSpecificExt2
+			EPL_MEMCPY(&pTxFrame->m_Data.m_Asnd.m_Payload.
+				   m_IdentResponse.m_le_abVendorSpecificExt2[0],
+				   &EplDllkInstance_g.m_DllIdentParam.
+				   m_abVendorSpecificExt2[0],
+				   sizeof(EplDllkInstance_g.m_DllIdentParam.
+					  m_abVendorSpecificExt2));
+
+			// StatusResponse
+			uiFrameSize = EPL_C_DLL_MINSIZE_STATUSRES;
+			Ret =
+			    EplDllkCreateTxFrame(&uiHandle, &pTxFrame,
+						 &uiFrameSize, kEplMsgTypeAsnd,
+						 kEplDllAsndStatusResponse);
+			if (Ret != kEplSuccessful) {	// error occured while registering Tx frame
+				goto Exit;
+			}
+			// PRes $$$ maybe move this to PDO module
+			if ((EplDllkInstance_g.m_DllConfigParam.m_fAsyncOnly ==
+			     FALSE)
+			    && (EplDllkInstance_g.m_DllConfigParam.m_uiPresActPayloadLimit >= 36)) {	// it is not configured as async-only CN,
+				// so take part in isochronous phase and register PRes frame
+				uiFrameSize =
+				    EplDllkInstance_g.m_DllConfigParam.
+				    m_uiPresActPayloadLimit + 24;
+				Ret =
+				    EplDllkCreateTxFrame(&uiHandle, &pTxFrame,
+							 &uiFrameSize,
+							 kEplMsgTypePres,
+							 kEplDllAsndNotDefined);
+				if (Ret != kEplSuccessful) {	// error occured while registering Tx frame
+					goto Exit;
+				}
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
-                // initially encode TPDO -> inform PDO module
-                FrameInfo.m_pFrame = pTxFrame;
-                FrameInfo.m_uiFrameSize = uiFrameSize;
-                Ret = EplPdokCbPdoTransmitted(&FrameInfo);
-#endif
-                // reset cycle counter
-                EplDllkInstance_g.m_uiCycleCount = 0;
-            }
-            else
-            {   // it is an async-only CN
-                // fool EplDllkChangeState() to think that PRes was not expected
-                EplDllkInstance_g.m_uiCycleCount = 1;
-            }
-
-            // NMT request
-            uiFrameSize = EPL_C_IP_MAX_MTU;
-            Ret = EplDllkCreateTxFrame(&uiHandle, &pTxFrame, &uiFrameSize, kEplMsgTypeAsnd, kEplDllAsndNmtRequest);
-            if (Ret != kEplSuccessful)
-            {   // error occured while registering Tx frame
-                goto Exit;
-            }
-            // mark Tx buffer as empty
-            EplDllkInstance_g.m_pTxBuffer[uiHandle].m_uiTxMsgLen = EPL_DLLK_BUFLEN_EMPTY;
-
-            // non-EPL frame
-            uiFrameSize = EPL_C_IP_MAX_MTU;
-            Ret = EplDllkCreateTxFrame(&uiHandle, &pTxFrame, &uiFrameSize, kEplMsgTypeNonEpl, kEplDllAsndNotDefined);
-            if (Ret != kEplSuccessful)
-            {   // error occured while registering Tx frame
-                goto Exit;
-            }
-            // mark Tx buffer as empty
-            EplDllkInstance_g.m_pTxBuffer[uiHandle].m_uiTxMsgLen = EPL_DLLK_BUFLEN_EMPTY;
-
-            // register multicast MACs in ethernet driver
-            AmiSetQword48ToBe(&abMulticastMac[0], EPL_C_DLL_MULTICAST_SOC);
-            Ret = EdrvDefineRxMacAddrEntry(abMulticastMac);
-            AmiSetQword48ToBe(&abMulticastMac[0], EPL_C_DLL_MULTICAST_SOA);
-            Ret = EdrvDefineRxMacAddrEntry(abMulticastMac);
-            AmiSetQword48ToBe(&abMulticastMac[0], EPL_C_DLL_MULTICAST_PRES);
-            Ret = EdrvDefineRxMacAddrEntry(abMulticastMac);
-            AmiSetQword48ToBe(&abMulticastMac[0], EPL_C_DLL_MULTICAST_ASND);
-            Ret = EdrvDefineRxMacAddrEntry(abMulticastMac);
+				// initially encode TPDO -> inform PDO module
+				FrameInfo.m_pFrame = pTxFrame;
+				FrameInfo.m_uiFrameSize = uiFrameSize;
+				Ret = EplPdokCbPdoTransmitted(&FrameInfo);
+#endif
+				// reset cycle counter
+				EplDllkInstance_g.m_uiCycleCount = 0;
+			} else {	// it is an async-only CN
+				// fool EplDllkChangeState() to think that PRes was not expected
+				EplDllkInstance_g.m_uiCycleCount = 1;
+			}
+
+			// NMT request
+			uiFrameSize = EPL_C_IP_MAX_MTU;
+			Ret =
+			    EplDllkCreateTxFrame(&uiHandle, &pTxFrame,
+						 &uiFrameSize, kEplMsgTypeAsnd,
+						 kEplDllAsndNmtRequest);
+			if (Ret != kEplSuccessful) {	// error occured while registering Tx frame
+				goto Exit;
+			}
+			// mark Tx buffer as empty
+			EplDllkInstance_g.m_pTxBuffer[uiHandle].m_uiTxMsgLen =
+			    EPL_DLLK_BUFLEN_EMPTY;
+
+			// non-EPL frame
+			uiFrameSize = EPL_C_IP_MAX_MTU;
+			Ret =
+			    EplDllkCreateTxFrame(&uiHandle, &pTxFrame,
+						 &uiFrameSize,
+						 kEplMsgTypeNonEpl,
+						 kEplDllAsndNotDefined);
+			if (Ret != kEplSuccessful) {	// error occured while registering Tx frame
+				goto Exit;
+			}
+			// mark Tx buffer as empty
+			EplDllkInstance_g.m_pTxBuffer[uiHandle].m_uiTxMsgLen =
+			    EPL_DLLK_BUFLEN_EMPTY;
+
+			// register multicast MACs in ethernet driver
+			AmiSetQword48ToBe(&abMulticastMac[0],
+					  EPL_C_DLL_MULTICAST_SOC);
+			Ret = EdrvDefineRxMacAddrEntry(abMulticastMac);
+			AmiSetQword48ToBe(&abMulticastMac[0],
+					  EPL_C_DLL_MULTICAST_SOA);
+			Ret = EdrvDefineRxMacAddrEntry(abMulticastMac);
+			AmiSetQword48ToBe(&abMulticastMac[0],
+					  EPL_C_DLL_MULTICAST_PRES);
+			Ret = EdrvDefineRxMacAddrEntry(abMulticastMac);
+			AmiSetQword48ToBe(&abMulticastMac[0],
+					  EPL_C_DLL_MULTICAST_ASND);
+			Ret = EdrvDefineRxMacAddrEntry(abMulticastMac);
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-            if (NmtState >= kEplNmtMsNotActive)
-            {   // local node is MN
-            unsigned int    uiIndex;
-
-                // SoC
-                uiFrameSize = EPL_C_DLL_MINSIZE_SOC;
-                Ret = EplDllkCreateTxFrame(&uiHandle, &pTxFrame, &uiFrameSize, kEplMsgTypeSoc, kEplDllAsndNotDefined);
-                if (Ret != kEplSuccessful)
-                {   // error occured while registering Tx frame
-                    goto Exit;
-                }
-
-                // SoA
-                uiFrameSize = EPL_C_DLL_MINSIZE_SOA;
-                Ret = EplDllkCreateTxFrame(&uiHandle, &pTxFrame, &uiFrameSize, kEplMsgTypeSoa, kEplDllAsndNotDefined);
-                if (Ret != kEplSuccessful)
-                {   // error occured while registering Tx frame
-                    goto Exit;
-                }
+			if (NmtState >= kEplNmtMsNotActive) {	// local node is MN
+				unsigned int uiIndex;
 
-                for (uiIndex = 0; uiIndex < tabentries (EplDllkInstance_g.m_aNodeInfo); uiIndex++)
-                {
+				// SoC
+				uiFrameSize = EPL_C_DLL_MINSIZE_SOC;
+				Ret =
+				    EplDllkCreateTxFrame(&uiHandle, &pTxFrame,
+							 &uiFrameSize,
+							 kEplMsgTypeSoc,
+							 kEplDllAsndNotDefined);
+				if (Ret != kEplSuccessful) {	// error occured while registering Tx frame
+					goto Exit;
+				}
+				// SoA
+				uiFrameSize = EPL_C_DLL_MINSIZE_SOA;
+				Ret =
+				    EplDllkCreateTxFrame(&uiHandle, &pTxFrame,
+							 &uiFrameSize,
+							 kEplMsgTypeSoa,
+							 kEplDllAsndNotDefined);
+				if (Ret != kEplSuccessful) {	// error occured while registering Tx frame
+					goto Exit;
+				}
+
+				for (uiIndex = 0;
+				     uiIndex <
+				     tabentries(EplDllkInstance_g.m_aNodeInfo);
+				     uiIndex++) {
 //                    EplDllkInstance_g.m_aNodeInfo[uiIndex].m_uiNodeId = uiIndex + 1;
-                    EplDllkInstance_g.m_aNodeInfo[uiIndex].m_wPresPayloadLimit = (WORD) EplDllkInstance_g.m_DllConfigParam.m_uiIsochrRxMaxPayload;
-                }
-
-                // calculate cycle length
-                EplDllkInstance_g.m_ullFrameTimeout = 1000LL
-                    * ((unsigned long long) EplDllkInstance_g.m_DllConfigParam.m_dwCycleLen);
-            }
+					EplDllkInstance_g.m_aNodeInfo[uiIndex].
+					    m_wPresPayloadLimit =
+					    (WORD) EplDllkInstance_g.
+					    m_DllConfigParam.
+					    m_uiIsochrRxMaxPayload;
+				}
+
+				// calculate cycle length
+				EplDllkInstance_g.m_ullFrameTimeout = 1000LL
+				    *
+				    ((unsigned long long)EplDllkInstance_g.
+				     m_DllConfigParam.m_dwCycleLen);
+			}
 #endif //(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
-            Ret = EplDllkCalAsyncClearBuffer();
-
-            break;
-        }
-
-        case kEplEventTypeDllkDestroy:
-        {
-            // destroy all data structures
-
-            NmtState = *((tEplNmtState*)pEvent_p->m_pArg);
+			Ret = EplDllkCalAsyncClearBuffer();
 
-            // delete Tx frames
-            Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_IDENTRES);
-            if (Ret != kEplSuccessful)
-            {   // error occured while deregistering Tx frame
-                goto Exit;
-            }
-
-            Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_STATUSRES);
-            if (Ret != kEplSuccessful)
-            {   // error occured while deregistering Tx frame
-                goto Exit;
-            }
-
-            Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_PRES);
-            if (Ret != kEplSuccessful)
-            {   // error occured while deregistering Tx frame
-                goto Exit;
-            }
-
-            Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_NMTREQ);
-            if (Ret != kEplSuccessful)
-            {   // error occured while deregistering Tx frame
-                goto Exit;
-            }
-
-            Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_NONEPL);
-            if (Ret != kEplSuccessful)
-            {   // error occured while deregistering Tx frame
-                goto Exit;
-            }
+			break;
+		}
 
+	case kEplEventTypeDllkDestroy:
+		{
+			// destroy all data structures
+
+			NmtState = *((tEplNmtState *) pEvent_p->m_pArg);
+
+			// delete Tx frames
+			Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_IDENTRES);
+			if (Ret != kEplSuccessful) {	// error occured while deregistering Tx frame
+				goto Exit;
+			}
+
+			Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_STATUSRES);
+			if (Ret != kEplSuccessful) {	// error occured while deregistering Tx frame
+				goto Exit;
+			}
+
+			Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_PRES);
+			if (Ret != kEplSuccessful) {	// error occured while deregistering Tx frame
+				goto Exit;
+			}
+
+			Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_NMTREQ);
+			if (Ret != kEplSuccessful) {	// error occured while deregistering Tx frame
+				goto Exit;
+			}
+
+			Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_NONEPL);
+			if (Ret != kEplSuccessful) {	// error occured while deregistering Tx frame
+				goto Exit;
+			}
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-            if (NmtState >= kEplNmtMsNotActive)
-            {   // local node was MN
-            unsigned int    uiIndex;
-
-                Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_SOC);
-                if (Ret != kEplSuccessful)
-                {   // error occured while deregistering Tx frame
-                    goto Exit;
-                }
-
-                Ret = EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_SOA);
-                if (Ret != kEplSuccessful)
-                {   // error occured while deregistering Tx frame
-                    goto Exit;
-                }
-
-                for (uiIndex = 0; uiIndex < tabentries (EplDllkInstance_g.m_aNodeInfo); uiIndex++)
-                {
-                    if (EplDllkInstance_g.m_aNodeInfo[uiIndex].m_pPreqTxBuffer != NULL)
-                    {
-                        uiHandle = EplDllkInstance_g.m_aNodeInfo[uiIndex].m_pPreqTxBuffer - EplDllkInstance_g.m_pTxBuffer;
-                        EplDllkInstance_g.m_aNodeInfo[uiIndex].m_pPreqTxBuffer = NULL;
-                        Ret = EplDllkDeleteTxFrame(uiHandle);
-                        if (Ret != kEplSuccessful)
-                        {   // error occured while deregistering Tx frame
-                            goto Exit;
-                        }
-
-                    }
-                    EplDllkInstance_g.m_aNodeInfo[uiIndex].m_wPresPayloadLimit = 0xFFFF;
-                }
-            }
+			if (NmtState >= kEplNmtMsNotActive) {	// local node was MN
+				unsigned int uiIndex;
+
+				Ret =
+				    EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_SOC);
+				if (Ret != kEplSuccessful) {	// error occured while deregistering Tx frame
+					goto Exit;
+				}
+
+				Ret =
+				    EplDllkDeleteTxFrame(EPL_DLLK_TXFRAME_SOA);
+				if (Ret != kEplSuccessful) {	// error occured while deregistering Tx frame
+					goto Exit;
+				}
+
+				for (uiIndex = 0;
+				     uiIndex <
+				     tabentries(EplDllkInstance_g.m_aNodeInfo);
+				     uiIndex++) {
+					if (EplDllkInstance_g.
+					    m_aNodeInfo[uiIndex].
+					    m_pPreqTxBuffer != NULL) {
+						uiHandle =
+						    EplDllkInstance_g.
+						    m_aNodeInfo[uiIndex].
+						    m_pPreqTxBuffer -
+						    EplDllkInstance_g.
+						    m_pTxBuffer;
+						EplDllkInstance_g.
+						    m_aNodeInfo[uiIndex].
+						    m_pPreqTxBuffer = NULL;
+						Ret =
+						    EplDllkDeleteTxFrame
+						    (uiHandle);
+						if (Ret != kEplSuccessful) {	// error occured while deregistering Tx frame
+							goto Exit;
+						}
+
+					}
+					EplDllkInstance_g.m_aNodeInfo[uiIndex].
+					    m_wPresPayloadLimit = 0xFFFF;
+				}
+			}
 #endif //(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
-            // deregister multicast MACs in ethernet driver
-            AmiSetQword48ToBe(&abMulticastMac[0], EPL_C_DLL_MULTICAST_SOC);
-            Ret = EdrvUndefineRxMacAddrEntry(abMulticastMac);
-            AmiSetQword48ToBe(&abMulticastMac[0], EPL_C_DLL_MULTICAST_SOA);
-            Ret = EdrvUndefineRxMacAddrEntry(abMulticastMac);
-            AmiSetQword48ToBe(&abMulticastMac[0], EPL_C_DLL_MULTICAST_PRES);
-            Ret = EdrvUndefineRxMacAddrEntry(abMulticastMac);
-            AmiSetQword48ToBe(&abMulticastMac[0], EPL_C_DLL_MULTICAST_ASND);
-            Ret = EdrvUndefineRxMacAddrEntry(abMulticastMac);
+			// deregister multicast MACs in ethernet driver
+			AmiSetQword48ToBe(&abMulticastMac[0],
+					  EPL_C_DLL_MULTICAST_SOC);
+			Ret = EdrvUndefineRxMacAddrEntry(abMulticastMac);
+			AmiSetQword48ToBe(&abMulticastMac[0],
+					  EPL_C_DLL_MULTICAST_SOA);
+			Ret = EdrvUndefineRxMacAddrEntry(abMulticastMac);
+			AmiSetQword48ToBe(&abMulticastMac[0],
+					  EPL_C_DLL_MULTICAST_PRES);
+			Ret = EdrvUndefineRxMacAddrEntry(abMulticastMac);
+			AmiSetQword48ToBe(&abMulticastMac[0],
+					  EPL_C_DLL_MULTICAST_ASND);
+			Ret = EdrvUndefineRxMacAddrEntry(abMulticastMac);
 
-            // delete timer
+			// delete timer
 #if EPL_TIMER_USE_HIGHRES != FALSE
-            Ret = EplTimerHighReskDeleteTimer(&EplDllkInstance_g.m_TimerHdlCycle);
-#endif
-
-            break;
-        }
-
-        case kEplEventTypeDllkFillTx:
-        {
-            // fill TxBuffer of specified priority with new frame if empty
+			Ret =
+			    EplTimerHighReskDeleteTimer(&EplDllkInstance_g.
+							m_TimerHdlCycle);
+#endif
+
+			break;
+		}
+
+	case kEplEventTypeDllkFillTx:
+		{
+			// fill TxBuffer of specified priority with new frame if empty
+
+			pTxFrame = NULL;
+			AsyncReqPriority =
+			    *((tEplDllAsyncReqPriority *) pEvent_p->m_pArg);
+			switch (AsyncReqPriority) {
+			case kEplDllAsyncReqPrioNmt:	// NMT request priority
+				{
+					pTxBuffer =
+					    &EplDllkInstance_g.
+					    m_pTxBuffer
+					    [EPL_DLLK_TXFRAME_NMTREQ];
+					if (pTxBuffer->m_pbBuffer != NULL) {	// NmtRequest does exist
+						// check if frame is empty and not being filled
+						if (pTxBuffer->m_uiTxMsgLen ==
+						    EPL_DLLK_BUFLEN_EMPTY) {
+							// mark Tx buffer as filling is in process
+							pTxBuffer->
+							    m_uiTxMsgLen =
+							    EPL_DLLK_BUFLEN_FILLING;
+							// set max buffer size as input parameter
+							uiFrameSize =
+							    pTxBuffer->
+							    m_uiMaxBufferLen;
+							// copy frame from shared loop buffer to Tx buffer
+							Ret =
+							    EplDllkCalAsyncGetTxFrame
+							    (pTxBuffer->
+							     m_pbBuffer,
+							     &uiFrameSize,
+							     AsyncReqPriority);
+							if (Ret ==
+							    kEplSuccessful) {
+								pTxFrame =
+								    (tEplFrame
+								     *)
+								    pTxBuffer->
+								    m_pbBuffer;
+								Ret =
+								    EplDllkCheckFrame
+								    (pTxFrame,
+								     uiFrameSize);
+
+								// set buffer valid
+								pTxBuffer->
+								    m_uiTxMsgLen
+								    =
+								    uiFrameSize;
+							} else if (Ret == kEplDllAsyncTxBufferEmpty) {	// empty Tx buffer is not a real problem
+								// so just ignore it
+								Ret =
+								    kEplSuccessful;
+								// mark Tx buffer as empty
+								pTxBuffer->
+								    m_uiTxMsgLen
+								    =
+								    EPL_DLLK_BUFLEN_EMPTY;
+							}
+						}
+					}
+					break;
+				}
+
+			default:	// generic priority
+				{
+					pTxBuffer =
+					    &EplDllkInstance_g.
+					    m_pTxBuffer
+					    [EPL_DLLK_TXFRAME_NONEPL];
+					if (pTxBuffer->m_pbBuffer != NULL) {	// non-EPL frame does exist
+						// check if frame is empty and not being filled
+						if (pTxBuffer->m_uiTxMsgLen ==
+						    EPL_DLLK_BUFLEN_EMPTY) {
+							// mark Tx buffer as filling is in process
+							pTxBuffer->
+							    m_uiTxMsgLen =
+							    EPL_DLLK_BUFLEN_FILLING;
+							// set max buffer size as input parameter
+							uiFrameSize =
+							    pTxBuffer->
+							    m_uiMaxBufferLen;
+							// copy frame from shared loop buffer to Tx buffer
+							Ret =
+							    EplDllkCalAsyncGetTxFrame
+							    (pTxBuffer->
+							     m_pbBuffer,
+							     &uiFrameSize,
+							     AsyncReqPriority);
+							if (Ret ==
+							    kEplSuccessful) {
+								pTxFrame =
+								    (tEplFrame
+								     *)
+								    pTxBuffer->
+								    m_pbBuffer;
+								Ret =
+								    EplDllkCheckFrame
+								    (pTxFrame,
+								     uiFrameSize);
+
+								// set buffer valid
+								pTxBuffer->
+								    m_uiTxMsgLen
+								    =
+								    uiFrameSize;
+							} else if (Ret == kEplDllAsyncTxBufferEmpty) {	// empty Tx buffer is not a real problem
+								// so just ignore it
+								Ret =
+								    kEplSuccessful;
+								// mark Tx buffer as empty
+								pTxBuffer->
+								    m_uiTxMsgLen
+								    =
+								    EPL_DLLK_BUFLEN_EMPTY;
+							}
+						}
+					}
+					break;
+				}
+			}
+
+			NmtState = EplNmtkGetNmtState();
+
+			if ((NmtState == kEplNmtCsBasicEthernet) || (NmtState == kEplNmtMsBasicEthernet)) {	// send frame immediately
+				if (pTxFrame != NULL) {	// frame is present
+					// padding is done by Edrv or ethernet controller
+					Ret = EdrvSendTxMsg(pTxBuffer);
+				} else {	// no frame moved to TxBuffer
+					// check if TxBuffers contain unsent frames
+					if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen > EPL_DLLK_BUFLEN_EMPTY) {	// NMT request Tx buffer contains a frame
+						Ret =
+						    EdrvSendTxMsg
+						    (&EplDllkInstance_g.
+						     m_pTxBuffer
+						     [EPL_DLLK_TXFRAME_NMTREQ]);
+					} else if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL].m_uiTxMsgLen > EPL_DLLK_BUFLEN_EMPTY) {	// non-EPL Tx buffer contains a frame
+						Ret =
+						    EdrvSendTxMsg
+						    (&EplDllkInstance_g.
+						     m_pTxBuffer
+						     [EPL_DLLK_TXFRAME_NONEPL]);
+					}
+					if (Ret == kEplInvalidOperation) {	// ignore error if caused by already active transmission
+						Ret = kEplSuccessful;
+					}
+				}
+				// reset PRes flag 2
+				EplDllkInstance_g.m_bFlag2 = 0;
+			} else {
+				// update Flag 2 (PR, RS)
+				Ret =
+				    EplDllkCalAsyncGetTxCount(&AsyncReqPriority,
+							      &uiFrameCount);
+				if (AsyncReqPriority == kEplDllAsyncReqPrioNmt) {	// non-empty FIFO with hightest priority is for NMT requests
+					if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen > EPL_DLLK_BUFLEN_EMPTY) {	// NMT request Tx buffer contains a frame
+						// add one more frame
+						uiFrameCount++;
+					}
+				} else {	// non-empty FIFO with highest priority is for generic frames
+					if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen > EPL_DLLK_BUFLEN_EMPTY) {	// NMT request Tx buffer contains a frame
+						// use NMT request FIFO, because of higher priority
+						uiFrameCount = 1;
+						AsyncReqPriority =
+						    kEplDllAsyncReqPrioNmt;
+					} else if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL].m_uiTxMsgLen > EPL_DLLK_BUFLEN_EMPTY) {	// non-EPL Tx buffer contains a frame
+						// use NMT request FIFO, because of higher priority
+						// add one more frame
+						uiFrameCount++;
+					}
+				}
+
+				if (uiFrameCount > 7) {	// limit frame request to send counter to 7
+					uiFrameCount = 7;
+				}
+				if (uiFrameCount > 0) {
+					EplDllkInstance_g.m_bFlag2 =
+					    (BYTE) (((AsyncReqPriority <<
+						      EPL_FRAME_FLAG2_PR_SHIFT)
+						     & EPL_FRAME_FLAG2_PR)
+						    | (uiFrameCount &
+						       EPL_FRAME_FLAG2_RS));
+				} else {
+					EplDllkInstance_g.m_bFlag2 = 0;
+				}
+			}
 
-            pTxFrame = NULL;
-            AsyncReqPriority = *((tEplDllAsyncReqPriority *) pEvent_p->m_pArg);
-            switch (AsyncReqPriority)
-            {
-                case kEplDllAsyncReqPrioNmt:    // NMT request priority
-                {
-                    pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ];
-                    if (pTxBuffer->m_pbBuffer != NULL)
-                    {   // NmtRequest does exist
-                        // check if frame is empty and not being filled
-                        if (pTxBuffer->m_uiTxMsgLen == EPL_DLLK_BUFLEN_EMPTY)
-                        {
-                            // mark Tx buffer as filling is in process
-                            pTxBuffer->m_uiTxMsgLen = EPL_DLLK_BUFLEN_FILLING;
-                            // set max buffer size as input parameter
-                            uiFrameSize = pTxBuffer->m_uiMaxBufferLen;
-                            // copy frame from shared loop buffer to Tx buffer
-                            Ret = EplDllkCalAsyncGetTxFrame(
-                                pTxBuffer->m_pbBuffer, &uiFrameSize, AsyncReqPriority);
-                            if (Ret == kEplSuccessful)
-                            {
-                                pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
-                                Ret = EplDllkCheckFrame(pTxFrame, uiFrameSize);
-
-                                // set buffer valid
-                                pTxBuffer->m_uiTxMsgLen = uiFrameSize;
-                            }
-                            else if (Ret == kEplDllAsyncTxBufferEmpty)
-                            {   // empty Tx buffer is not a real problem
-                                // so just ignore it
-                                Ret = kEplSuccessful;
-                                // mark Tx buffer as empty
-                                pTxBuffer->m_uiTxMsgLen = EPL_DLLK_BUFLEN_EMPTY;
-                            }
-                        }
-                    }
-                    break;
-                }
-
-                default:    // generic priority
-                {
-                    pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL];
-                    if (pTxBuffer->m_pbBuffer != NULL)
-                    {   // non-EPL frame does exist
-                        // check if frame is empty and not being filled
-                        if (pTxBuffer->m_uiTxMsgLen == EPL_DLLK_BUFLEN_EMPTY)
-                        {
-                            // mark Tx buffer as filling is in process
-                            pTxBuffer->m_uiTxMsgLen = EPL_DLLK_BUFLEN_FILLING;
-                            // set max buffer size as input parameter
-                            uiFrameSize = pTxBuffer->m_uiMaxBufferLen;
-                            // copy frame from shared loop buffer to Tx buffer
-                            Ret = EplDllkCalAsyncGetTxFrame(
-                                pTxBuffer->m_pbBuffer, &uiFrameSize, AsyncReqPriority);
-                            if (Ret == kEplSuccessful)
-                            {
-                                pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
-                                Ret = EplDllkCheckFrame(pTxFrame, uiFrameSize);
-
-                                // set buffer valid
-                                pTxBuffer->m_uiTxMsgLen = uiFrameSize;
-                            }
-                            else if (Ret == kEplDllAsyncTxBufferEmpty)
-                            {   // empty Tx buffer is not a real problem
-                                // so just ignore it
-                                Ret = kEplSuccessful;
-                                // mark Tx buffer as empty
-                                pTxBuffer->m_uiTxMsgLen = EPL_DLLK_BUFLEN_EMPTY;
-                            }
-                        }
-                    }
-                    break;
-                }
-            }
-
-            NmtState = EplNmtkGetNmtState();
-
-            if ((NmtState == kEplNmtCsBasicEthernet) || (NmtState == kEplNmtMsBasicEthernet))
-            {   // send frame immediately
-                if (pTxFrame != NULL)
-                {   // frame is present
-                    // padding is done by Edrv or ethernet controller
-                    Ret = EdrvSendTxMsg(pTxBuffer);
-                }
-                else
-                {   // no frame moved to TxBuffer
-                    // check if TxBuffers contain unsent frames
-                    if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen > EPL_DLLK_BUFLEN_EMPTY)
-                    {   // NMT request Tx buffer contains a frame
-                        Ret = EdrvSendTxMsg(
-                                &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ]);
-                    }
-                    else if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL].m_uiTxMsgLen > EPL_DLLK_BUFLEN_EMPTY)
-                    {   // non-EPL Tx buffer contains a frame
-                        Ret = EdrvSendTxMsg(
-                                &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL]);
-                    }
-                    if (Ret == kEplInvalidOperation)
-                    {   // ignore error if caused by already active transmission
-                        Ret = kEplSuccessful;
-                    }
-                }
-                // reset PRes flag 2
-                EplDllkInstance_g.m_bFlag2 = 0;
-            }
-            else
-            {
-                // update Flag 2 (PR, RS)
-                Ret = EplDllkCalAsyncGetTxCount(&AsyncReqPriority, &uiFrameCount);
-                if (AsyncReqPriority == kEplDllAsyncReqPrioNmt)
-                {   // non-empty FIFO with hightest priority is for NMT requests
-                    if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen > EPL_DLLK_BUFLEN_EMPTY)
-                    {   // NMT request Tx buffer contains a frame
-                        // add one more frame
-                        uiFrameCount++;
-                    }
-                }
-                else
-                {   // non-empty FIFO with highest priority is for generic frames
-                    if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen > EPL_DLLK_BUFLEN_EMPTY)
-                    {   // NMT request Tx buffer contains a frame
-                        // use NMT request FIFO, because of higher priority
-                        uiFrameCount = 1;
-                        AsyncReqPriority = kEplDllAsyncReqPrioNmt;
-                    }
-                    else if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL].m_uiTxMsgLen > EPL_DLLK_BUFLEN_EMPTY)
-                    {   // non-EPL Tx buffer contains a frame
-                        // use NMT request FIFO, because of higher priority
-                        // add one more frame
-                        uiFrameCount++;
-                    }
-                }
-
-                if (uiFrameCount > 7)
-                {   // limit frame request to send counter to 7
-                    uiFrameCount = 7;
-                }
-                if (uiFrameCount > 0)
-                {
-                    EplDllkInstance_g.m_bFlag2 =
-                        (BYTE) (((AsyncReqPriority << EPL_FRAME_FLAG2_PR_SHIFT) & EPL_FRAME_FLAG2_PR)
-                        | (uiFrameCount & EPL_FRAME_FLAG2_RS));
-                }
-                else
-                {
-                    EplDllkInstance_g.m_bFlag2 = 0;
-                }
-            }
-
-            break;
-        }
+			break;
+		}
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-        case kEplEventTypeDllkStartReducedCycle:
-        {
-            // start the reduced cycle by programming the cycle timer
-            // it is issued by NMT MN module, when PreOp1 is entered
-
-            // clear the asynchronous queues
-            Ret = EplDllkCalAsyncClearQueues();
-
-            // reset cycle counter (everytime a SoA is triggerd in PreOp1 the counter is incremented
-            // and when it reaches EPL_C_DLL_PREOP1_START_CYCLES the SoA may contain invitations)
-            EplDllkInstance_g.m_uiCycleCount = 0;
-
-            // remove any CN from isochronous phase
-            while (EplDllkInstance_g.m_pFirstNodeInfo != NULL)
-            {
-                EplDllkDeleteNode(EplDllkInstance_g.m_pFirstNodeInfo->m_uiNodeId);
-            }
-
-            // change state to NonCyclic,
-            // hence EplDllkChangeState() will not ignore the next call
-            EplDllkInstance_g.m_DllState = kEplDllMsNonCyclic;
+	case kEplEventTypeDllkStartReducedCycle:
+		{
+			// start the reduced cycle by programming the cycle timer
+			// it is issued by NMT MN module, when PreOp1 is entered
+
+			// clear the asynchronous queues
+			Ret = EplDllkCalAsyncClearQueues();
+
+			// reset cycle counter (everytime a SoA is triggerd in PreOp1 the counter is incremented
+			// and when it reaches EPL_C_DLL_PREOP1_START_CYCLES the SoA may contain invitations)
+			EplDllkInstance_g.m_uiCycleCount = 0;
+
+			// remove any CN from isochronous phase
+			while (EplDllkInstance_g.m_pFirstNodeInfo != NULL) {
+				EplDllkDeleteNode(EplDllkInstance_g.
+						  m_pFirstNodeInfo->m_uiNodeId);
+			}
+
+			// change state to NonCyclic,
+			// hence EplDllkChangeState() will not ignore the next call
+			EplDllkInstance_g.m_DllState = kEplDllMsNonCyclic;
 
 #if EPL_TIMER_USE_HIGHRES != FALSE
-            if (EplDllkInstance_g.m_DllConfigParam.m_dwAsyncSlotTimeout != 0)
-            {
-                Ret = EplTimerHighReskModifyTimerNs(&EplDllkInstance_g.m_TimerHdlCycle,
-                    EplDllkInstance_g.m_DllConfigParam.m_dwAsyncSlotTimeout,
-                    EplDllkCbMnTimerCycle,
-                    0L,
-                    FALSE);
-            }
+			if (EplDllkInstance_g.m_DllConfigParam.
+			    m_dwAsyncSlotTimeout != 0) {
+				Ret =
+				    EplTimerHighReskModifyTimerNs
+				    (&EplDllkInstance_g.m_TimerHdlCycle,
+				     EplDllkInstance_g.m_DllConfigParam.
+				     m_dwAsyncSlotTimeout,
+				     EplDllkCbMnTimerCycle, 0L, FALSE);
+			}
 #endif
 
-            break;
-        }
+			break;
+		}
 #endif
 
 #if EPL_DLL_PRES_READY_AFTER_SOA != FALSE
-        case kEplEventTypeDllkPresReady:
-        {
-            // post PRes to transmit FIFO
-
-            NmtState = EplNmtkGetNmtState();
-
-            if (NmtState != kEplNmtCsBasicEthernet)
-            {
-                // Does PRes exist?
-                if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES].m_pbBuffer != NULL)
-                {   // PRes does exist
-                    pTxFrame = (tEplFrame *) EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES].m_pbBuffer;
-                    // update frame (NMT state, RD, RS, PR, MS, EN flags)
-                    if (NmtState < kEplNmtCsPreOperational2)
-                    {   // NMT state is not PreOp2, ReadyToOp or Op
-                        // fake NMT state PreOp2, because PRes will be sent only in PreOp2 or greater
-                        NmtState = kEplNmtCsPreOperational2;
-                    }
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bNmtStatus, (BYTE) NmtState);
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag2, EplDllkInstance_g.m_bFlag2);
-                    if (NmtState != kEplNmtCsOperational)
-                    {   // mark PDO as invalid in NMT state Op
-                        // $$$ reset only RD flag; set other flags appropriately
-                        AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag1, 0);
-                    }
-                    // $$$ make function that updates Pres, StatusRes
-                    // mark PRes frame as ready for transmission
-                    Ret = EdrvTxMsgReady(&EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES]);
-                }
-            }
-
-            break;
-        }
-#endif
-        default:
-        {
-            ASSERTMSG(FALSE, "EplDllkProcess(): unhandled event type!\n");
-        }
-    }
+	case kEplEventTypeDllkPresReady:
+		{
+			// post PRes to transmit FIFO
+
+			NmtState = EplNmtkGetNmtState();
+
+			if (NmtState != kEplNmtCsBasicEthernet) {
+				// Does PRes exist?
+				if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES].m_pbBuffer != NULL) {	// PRes does exist
+					pTxFrame =
+					    (tEplFrame *) EplDllkInstance_g.
+					    m_pTxBuffer[EPL_DLLK_TXFRAME_PRES].
+					    m_pbBuffer;
+					// update frame (NMT state, RD, RS, PR, MS, EN flags)
+					if (NmtState < kEplNmtCsPreOperational2) {	// NMT state is not PreOp2, ReadyToOp or Op
+						// fake NMT state PreOp2, because PRes will be sent only in PreOp2 or greater
+						NmtState =
+						    kEplNmtCsPreOperational2;
+					}
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
+						       m_le_bNmtStatus,
+						       (BYTE) NmtState);
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
+						       m_le_bFlag2,
+						       EplDllkInstance_g.
+						       m_bFlag2);
+					if (NmtState != kEplNmtCsOperational) {	// mark PDO as invalid in NMT state Op
+						// $$$ reset only RD flag; set other flags appropriately
+						AmiSetByteToLe(&pTxFrame->
+							       m_Data.m_Pres.
+							       m_le_bFlag1, 0);
+					}
+					// $$$ make function that updates Pres, StatusRes
+					// mark PRes frame as ready for transmission
+					Ret =
+					    EdrvTxMsgReady(&EplDllkInstance_g.
+							   m_pTxBuffer
+							   [EPL_DLLK_TXFRAME_PRES]);
+				}
+			}
+
+			break;
+		}
+#endif
+	default:
+		{
+			ASSERTMSG(FALSE,
+				  "EplDllkProcess(): unhandled event type!\n");
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1238,7 +1358,7 @@ Exit:
 
 tEplKernel EplDllkConfig(tEplDllConfigParam * pDllConfigParam_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
 // d.k. check of NMT state disabled, because CycleLen is programmed at run time by MN without reset of CN
 /*tEplNmtState    NmtState;
@@ -1251,30 +1371,32 @@ tEplKernel      Ret = kEplSuccessful;
         goto Exit;
     }
 */
-    EPL_MEMCPY (&EplDllkInstance_g.m_DllConfigParam, pDllConfigParam_p,
-        (pDllConfigParam_p->m_uiSizeOfStruct < sizeof (tEplDllConfigParam) ?
-        pDllConfigParam_p->m_uiSizeOfStruct : sizeof (tEplDllConfigParam)));
-
-    if ((EplDllkInstance_g.m_DllConfigParam.m_dwCycleLen != 0)
-        && (EplDllkInstance_g.m_DllConfigParam.m_dwLossOfFrameTolerance != 0))
-    {   // monitor EPL cycle, calculate frame timeout
-        EplDllkInstance_g.m_ullFrameTimeout = (1000LL
-            * ((unsigned long long) EplDllkInstance_g.m_DllConfigParam.m_dwCycleLen))
-            + ((unsigned long long) EplDllkInstance_g.m_DllConfigParam.m_dwLossOfFrameTolerance);
-    }
-    else
-    {
-        EplDllkInstance_g.m_ullFrameTimeout = 0LL;
-    }
-
-    if (EplDllkInstance_g.m_DllConfigParam.m_fAsyncOnly != FALSE)
-    {   // it is configured as async-only CN
-        // disable multiplexed cycle, that m_uiCycleCount will not be incremented spuriously on SoC
-        EplDllkInstance_g.m_DllConfigParam.m_uiMultiplCycleCnt = 0;
-    }
-
+	EPL_MEMCPY(&EplDllkInstance_g.m_DllConfigParam, pDllConfigParam_p,
+		   (pDllConfigParam_p->m_uiSizeOfStruct <
+		    sizeof(tEplDllConfigParam) ? pDllConfigParam_p->
+		    m_uiSizeOfStruct : sizeof(tEplDllConfigParam)));
+
+	if ((EplDllkInstance_g.m_DllConfigParam.m_dwCycleLen != 0)
+	    && (EplDllkInstance_g.m_DllConfigParam.m_dwLossOfFrameTolerance != 0)) {	// monitor EPL cycle, calculate frame timeout
+		EplDllkInstance_g.m_ullFrameTimeout = (1000LL
+						       *
+						       ((unsigned long long)
+							EplDllkInstance_g.
+							m_DllConfigParam.
+							m_dwCycleLen))
+		    +
+		    ((unsigned long long)EplDllkInstance_g.m_DllConfigParam.
+		     m_dwLossOfFrameTolerance);
+	} else {
+		EplDllkInstance_g.m_ullFrameTimeout = 0LL;
+	}
+
+	if (EplDllkInstance_g.m_DllConfigParam.m_fAsyncOnly != FALSE) {	// it is configured as async-only CN
+		// disable multiplexed cycle, that m_uiCycleCount will not be incremented spuriously on SoC
+		EplDllkInstance_g.m_DllConfigParam.m_uiMultiplCycleCnt = 0;
+	}
 //Exit:
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1294,18 +1416,18 @@ tEplKernel      Ret = kEplSuccessful;
 
 tEplKernel EplDllkSetIdentity(tEplDllIdentParam * pDllIdentParam_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    EPL_MEMCPY (&EplDllkInstance_g.m_DllIdentParam, pDllIdentParam_p,
-        (pDllIdentParam_p->m_uiSizeOfStruct < sizeof (tEplDllIdentParam) ?
-        pDllIdentParam_p->m_uiSizeOfStruct : sizeof (tEplDllIdentParam)));
+	EPL_MEMCPY(&EplDllkInstance_g.m_DllIdentParam, pDllIdentParam_p,
+		   (pDllIdentParam_p->m_uiSizeOfStruct <
+		    sizeof(tEplDllIdentParam) ? pDllIdentParam_p->
+		    m_uiSizeOfStruct : sizeof(tEplDllIdentParam)));
 
-    // $$$ if IdentResponse frame exists update it
+	// $$$ if IdentResponse frame exists update it
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkRegAsyncHandler
@@ -1323,18 +1445,15 @@ tEplKernel      Ret = kEplSuccessful;
 
 tEplKernel EplDllkRegAsyncHandler(tEplDllkCbAsync pfnDllkCbAsync_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    if (EplDllkInstance_g.m_pfnCbAsync == NULL)
-    {   // no handler registered yet
-        EplDllkInstance_g.m_pfnCbAsync = pfnDllkCbAsync_p;
-    }
-    else
-    {   // handler already registered
-        Ret = kEplDllCbAsyncRegistered;
-    }
+	if (EplDllkInstance_g.m_pfnCbAsync == NULL) {	// no handler registered yet
+		EplDllkInstance_g.m_pfnCbAsync = pfnDllkCbAsync_p;
+	} else {		// handler already registered
+		Ret = kEplDllCbAsyncRegistered;
+	}
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1354,19 +1473,16 @@ tEplKernel  Ret = kEplSuccessful;
 
 tEplKernel EplDllkDeregAsyncHandler(tEplDllkCbAsync pfnDllkCbAsync_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    if (EplDllkInstance_g.m_pfnCbAsync == pfnDllkCbAsync_p)
-    {   // same handler is registered
-        // deregister it
-        EplDllkInstance_g.m_pfnCbAsync = NULL;
-    }
-    else
-    {   // wrong handler or no handler registered
-        Ret = kEplDllCbAsyncRegistered;
-    }
+	if (EplDllkInstance_g.m_pfnCbAsync == pfnDllkCbAsync_p) {	// same handler is registered
+		// deregister it
+		EplDllkInstance_g.m_pfnCbAsync = NULL;
+	} else {		// wrong handler or no handler registered
+		Ret = kEplDllCbAsyncRegistered;
+	}
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1387,19 +1503,18 @@ tEplKernel  Ret = kEplSuccessful;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkSetAsndServiceIdFilter(tEplDllAsndServiceId ServiceId_p, tEplDllAsndFilter Filter_p)
+tEplKernel EplDllkSetAsndServiceIdFilter(tEplDllAsndServiceId ServiceId_p,
+					 tEplDllAsndFilter Filter_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    if (ServiceId_p < tabentries (EplDllkInstance_g.m_aAsndFilter))
-    {
-        EplDllkInstance_g.m_aAsndFilter[ServiceId_p] = Filter_p;
-    }
+	if (ServiceId_p < tabentries(EplDllkInstance_g.m_aAsndFilter)) {
+		EplDllkInstance_g.m_aAsndFilter[ServiceId_p] = Filter_p;
+	}
 
-    return Ret;
+	return Ret;
 }
 
-
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
 //---------------------------------------------------------------------------
@@ -1420,21 +1535,19 @@ tEplKernel  Ret = kEplSuccessful;
 
 tEplKernel EplDllkSetFlag1OfNode(unsigned int uiNodeId_p, BYTE bSoaFlag1_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplDllkNodeInfo*   pNodeInfo;
+	tEplKernel Ret = kEplSuccessful;
+	tEplDllkNodeInfo *pNodeInfo;
 
-    pNodeInfo = EplDllkGetNodeInfo(uiNodeId_p);
-    if (pNodeInfo == NULL)
-    {   // no node info structure available
-        Ret = kEplDllNoNodeInfo;
-        goto Exit;
-    }
+	pNodeInfo = EplDllkGetNodeInfo(uiNodeId_p);
+	if (pNodeInfo == NULL) {	// no node info structure available
+		Ret = kEplDllNoNodeInfo;
+		goto Exit;
+	}
+	// store flag1 in internal node info structure
+	pNodeInfo->m_bSoaFlag1 = bSoaFlag1_p;
 
-    // store flag1 in internal node info structure
-    pNodeInfo->m_bSoaFlag1 = bSoaFlag1_p;
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1453,16 +1566,15 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkGetFirstNodeInfo(tEplDllkNodeInfo** ppNodeInfo_p)
+tEplKernel EplDllkGetFirstNodeInfo(tEplDllkNodeInfo ** ppNodeInfo_p)
 {
-tEplKernel          Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    *ppNodeInfo_p = EplDllkInstance_g.m_pFirstNodeInfo;
+	*ppNodeInfo_p = EplDllkInstance_g.m_pFirstNodeInfo;
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkAddNode()
@@ -1480,108 +1592,104 @@ tEplKernel          Ret = kEplSuccessful
 
 tEplKernel EplDllkAddNode(tEplDllNodeInfo * pNodeInfo_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplDllkNodeInfo*   pIntNodeInfo;
-tEplDllkNodeInfo**  ppIntNodeInfo;
-unsigned int        uiHandle;
-tEplFrame*          pFrame;
-unsigned int        uiFrameSize;
-
-    pIntNodeInfo = EplDllkGetNodeInfo(pNodeInfo_p->m_uiNodeId);
-    if (pIntNodeInfo == NULL)
-    {   // no node info structure available
-        Ret = kEplDllNoNodeInfo;
-        goto Exit;
-    }
-
-    EPL_DLLK_DBG_POST_TRACE_VALUE(kEplEventTypeDllkAddNode,
-                                  pNodeInfo_p->m_uiNodeId,
-                                  0);
-
-    // copy node configuration
-    pIntNodeInfo->m_dwPresTimeout = pNodeInfo_p->m_dwPresTimeout;
-    pIntNodeInfo->m_wPresPayloadLimit = pNodeInfo_p->m_wPresPayloadLimit;
-
-    // $$$ d.k.: actually add node only if MN. On CN it is sufficient to update the node configuration
-    if (pNodeInfo_p->m_uiNodeId == EplDllkInstance_g.m_DllConfigParam.m_uiNodeId)
-    {   // we shall send PRes ourself
-        // insert our node at the end of the list
-        ppIntNodeInfo = &EplDllkInstance_g.m_pFirstNodeInfo;
-        while ((*ppIntNodeInfo != NULL) && ((*ppIntNodeInfo)->m_pNextNodeInfo != NULL))
-        {
-            ppIntNodeInfo = &(*ppIntNodeInfo)->m_pNextNodeInfo;
-        }
-        if (*ppIntNodeInfo != NULL)
-        {
-            if ((*ppIntNodeInfo)->m_uiNodeId == pNodeInfo_p->m_uiNodeId)
-            {   // node was already added to list
-                // $$$ d.k. maybe this should be an error
-                goto Exit;
-            }
-            else
-            {   // add our node at the end of the list
-                ppIntNodeInfo = &(*ppIntNodeInfo)->m_pNextNodeInfo;
-            }
-        }
-        // set "PReq"-TxBuffer to PRes-TxBuffer
-        pIntNodeInfo->m_pPreqTxBuffer = &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES];
-    }
-    else
-    {   // normal CN shall be added to isochronous phase
-        // insert node into list in ascending order
-        ppIntNodeInfo = &EplDllkInstance_g.m_pFirstNodeInfo;
-        while ((*ppIntNodeInfo != NULL)
-               && ((*ppIntNodeInfo)->m_uiNodeId < pNodeInfo_p->m_uiNodeId)
-               && ((*ppIntNodeInfo)->m_uiNodeId != EplDllkInstance_g.m_DllConfigParam.m_uiNodeId))
-        {
-            ppIntNodeInfo = &(*ppIntNodeInfo)->m_pNextNodeInfo;
-        }
-        if ((*ppIntNodeInfo != NULL) && ((*ppIntNodeInfo)->m_uiNodeId == pNodeInfo_p->m_uiNodeId))
-        {   // node was already added to list
-            // $$$ d.k. maybe this should be an error
-            goto Exit;
-        }
-    }
-
-    // initialize elements of internal node info structure
-    pIntNodeInfo->m_bSoaFlag1 = 0;
-    pIntNodeInfo->m_fSoftDelete = FALSE;
-    pIntNodeInfo->m_NmtState = kEplNmtCsNotActive;
-    if (pIntNodeInfo->m_pPreqTxBuffer == NULL)
-    {   // create TxBuffer entry
-        uiFrameSize = pNodeInfo_p->m_wPreqPayloadLimit + 24;
-        Ret = EplDllkCreateTxFrame(&uiHandle, &pFrame, &uiFrameSize, kEplMsgTypePreq, kEplDllAsndNotDefined);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        pIntNodeInfo->m_pPreqTxBuffer = &EplDllkInstance_g.m_pTxBuffer[uiHandle];
-        AmiSetByteToLe(&pFrame->m_le_bDstNodeId, (BYTE) pNodeInfo_p->m_uiNodeId);
-
-        // set up destination MAC address
-        EPL_MEMCPY(pFrame->m_be_abDstMac, pIntNodeInfo->m_be_abMacAddr, 6);
+	tEplKernel Ret = kEplSuccessful;
+	tEplDllkNodeInfo *pIntNodeInfo;
+	tEplDllkNodeInfo **ppIntNodeInfo;
+	unsigned int uiHandle;
+	tEplFrame *pFrame;
+	unsigned int uiFrameSize;
+
+	pIntNodeInfo = EplDllkGetNodeInfo(pNodeInfo_p->m_uiNodeId);
+	if (pIntNodeInfo == NULL) {	// no node info structure available
+		Ret = kEplDllNoNodeInfo;
+		goto Exit;
+	}
+
+	EPL_DLLK_DBG_POST_TRACE_VALUE(kEplEventTypeDllkAddNode,
+				      pNodeInfo_p->m_uiNodeId, 0);
+
+	// copy node configuration
+	pIntNodeInfo->m_dwPresTimeout = pNodeInfo_p->m_dwPresTimeout;
+	pIntNodeInfo->m_wPresPayloadLimit = pNodeInfo_p->m_wPresPayloadLimit;
+
+	// $$$ d.k.: actually add node only if MN. On CN it is sufficient to update the node configuration
+	if (pNodeInfo_p->m_uiNodeId == EplDllkInstance_g.m_DllConfigParam.m_uiNodeId) {	// we shall send PRes ourself
+		// insert our node at the end of the list
+		ppIntNodeInfo = &EplDllkInstance_g.m_pFirstNodeInfo;
+		while ((*ppIntNodeInfo != NULL)
+		       && ((*ppIntNodeInfo)->m_pNextNodeInfo != NULL)) {
+			ppIntNodeInfo = &(*ppIntNodeInfo)->m_pNextNodeInfo;
+		}
+		if (*ppIntNodeInfo != NULL) {
+			if ((*ppIntNodeInfo)->m_uiNodeId == pNodeInfo_p->m_uiNodeId) {	// node was already added to list
+				// $$$ d.k. maybe this should be an error
+				goto Exit;
+			} else {	// add our node at the end of the list
+				ppIntNodeInfo =
+				    &(*ppIntNodeInfo)->m_pNextNodeInfo;
+			}
+		}
+		// set "PReq"-TxBuffer to PRes-TxBuffer
+		pIntNodeInfo->m_pPreqTxBuffer =
+		    &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES];
+	} else {		// normal CN shall be added to isochronous phase
+		// insert node into list in ascending order
+		ppIntNodeInfo = &EplDllkInstance_g.m_pFirstNodeInfo;
+		while ((*ppIntNodeInfo != NULL)
+		       && ((*ppIntNodeInfo)->m_uiNodeId <
+			   pNodeInfo_p->m_uiNodeId)
+		       && ((*ppIntNodeInfo)->m_uiNodeId !=
+			   EplDllkInstance_g.m_DllConfigParam.m_uiNodeId)) {
+			ppIntNodeInfo = &(*ppIntNodeInfo)->m_pNextNodeInfo;
+		}
+		if ((*ppIntNodeInfo != NULL) && ((*ppIntNodeInfo)->m_uiNodeId == pNodeInfo_p->m_uiNodeId)) {	// node was already added to list
+			// $$$ d.k. maybe this should be an error
+			goto Exit;
+		}
+	}
+
+	// initialize elements of internal node info structure
+	pIntNodeInfo->m_bSoaFlag1 = 0;
+	pIntNodeInfo->m_fSoftDelete = FALSE;
+	pIntNodeInfo->m_NmtState = kEplNmtCsNotActive;
+	if (pIntNodeInfo->m_pPreqTxBuffer == NULL) {	// create TxBuffer entry
+		uiFrameSize = pNodeInfo_p->m_wPreqPayloadLimit + 24;
+		Ret =
+		    EplDllkCreateTxFrame(&uiHandle, &pFrame, &uiFrameSize,
+					 kEplMsgTypePreq,
+					 kEplDllAsndNotDefined);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		pIntNodeInfo->m_pPreqTxBuffer =
+		    &EplDllkInstance_g.m_pTxBuffer[uiHandle];
+		AmiSetByteToLe(&pFrame->m_le_bDstNodeId,
+			       (BYTE) pNodeInfo_p->m_uiNodeId);
+
+		// set up destination MAC address
+		EPL_MEMCPY(pFrame->m_be_abDstMac, pIntNodeInfo->m_be_abMacAddr,
+			   6);
 
-        #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
-        {
-        tEplFrameInfo       FrameInfo;
+#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
+		{
+			tEplFrameInfo FrameInfo;
 
-            // initially encode TPDO -> inform PDO module
-            FrameInfo.m_pFrame = pFrame;
-            FrameInfo.m_uiFrameSize = uiFrameSize;
-            Ret = EplPdokCbPdoTransmitted(&FrameInfo);
-        }
-        #endif
-    }
-    pIntNodeInfo->m_ulDllErrorEvents = 0L;
-    // add node to list
-    pIntNodeInfo->m_pNextNodeInfo = *ppIntNodeInfo;
-    *ppIntNodeInfo = pIntNodeInfo;
+			// initially encode TPDO -> inform PDO module
+			FrameInfo.m_pFrame = pFrame;
+			FrameInfo.m_uiFrameSize = uiFrameSize;
+			Ret = EplPdokCbPdoTransmitted(&FrameInfo);
+		}
+#endif
+	}
+	pIntNodeInfo->m_ulDllErrorEvents = 0L;
+	// add node to list
+	pIntNodeInfo->m_pNextNodeInfo = *ppIntNodeInfo;
+	*ppIntNodeInfo = pIntNodeInfo;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkDeleteNode()
@@ -1599,54 +1707,49 @@ Exit:
 
 tEplKernel EplDllkDeleteNode(unsigned int uiNodeId_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplDllkNodeInfo*   pIntNodeInfo;
-tEplDllkNodeInfo**  ppIntNodeInfo;
-unsigned int        uiHandle;
-
-    pIntNodeInfo = EplDllkGetNodeInfo(uiNodeId_p);
-    if (pIntNodeInfo == NULL)
-    {   // no node info structure available
-        Ret = kEplDllNoNodeInfo;
-        goto Exit;
-    }
-
-    EPL_DLLK_DBG_POST_TRACE_VALUE(kEplEventTypeDllkDelNode,
-                                  uiNodeId_p,
-                                  0);
-
-    // search node in whole list
-    ppIntNodeInfo = &EplDllkInstance_g.m_pFirstNodeInfo;
-    while ((*ppIntNodeInfo != NULL) && ((*ppIntNodeInfo)->m_uiNodeId != uiNodeId_p))
-    {
-        ppIntNodeInfo = &(*ppIntNodeInfo)->m_pNextNodeInfo;
-    }
-    if ((*ppIntNodeInfo == NULL) || ((*ppIntNodeInfo)->m_uiNodeId != uiNodeId_p))
-    {   // node was not found in list
-        // $$$ d.k. maybe this should be an error
-        goto Exit;
-    }
-
-    // remove node from list
-    *ppIntNodeInfo = pIntNodeInfo->m_pNextNodeInfo;
-
-    if ((pIntNodeInfo->m_pPreqTxBuffer != NULL)
-        && (pIntNodeInfo->m_pPreqTxBuffer != &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES]))
-    {   // delete TxBuffer entry
-        uiHandle = pIntNodeInfo->m_pPreqTxBuffer - EplDllkInstance_g.m_pTxBuffer;
-        pIntNodeInfo->m_pPreqTxBuffer = NULL;
-        Ret = EplDllkDeleteTxFrame(uiHandle);
+	tEplKernel Ret = kEplSuccessful;
+	tEplDllkNodeInfo *pIntNodeInfo;
+	tEplDllkNodeInfo **ppIntNodeInfo;
+	unsigned int uiHandle;
+
+	pIntNodeInfo = EplDllkGetNodeInfo(uiNodeId_p);
+	if (pIntNodeInfo == NULL) {	// no node info structure available
+		Ret = kEplDllNoNodeInfo;
+		goto Exit;
+	}
+
+	EPL_DLLK_DBG_POST_TRACE_VALUE(kEplEventTypeDllkDelNode, uiNodeId_p, 0);
+
+	// search node in whole list
+	ppIntNodeInfo = &EplDllkInstance_g.m_pFirstNodeInfo;
+	while ((*ppIntNodeInfo != NULL)
+	       && ((*ppIntNodeInfo)->m_uiNodeId != uiNodeId_p)) {
+		ppIntNodeInfo = &(*ppIntNodeInfo)->m_pNextNodeInfo;
+	}
+	if ((*ppIntNodeInfo == NULL) || ((*ppIntNodeInfo)->m_uiNodeId != uiNodeId_p)) {	// node was not found in list
+		// $$$ d.k. maybe this should be an error
+		goto Exit;
+	}
+	// remove node from list
+	*ppIntNodeInfo = pIntNodeInfo->m_pNextNodeInfo;
+
+	if ((pIntNodeInfo->m_pPreqTxBuffer != NULL)
+	    && (pIntNodeInfo->m_pPreqTxBuffer != &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES])) {	// delete TxBuffer entry
+		uiHandle =
+		    pIntNodeInfo->m_pPreqTxBuffer -
+		    EplDllkInstance_g.m_pTxBuffer;
+		pIntNodeInfo->m_pPreqTxBuffer = NULL;
+		Ret = EplDllkDeleteTxFrame(uiHandle);
 /*        if (Ret != kEplSuccessful)
         {
             goto Exit;
         }*/
-    }
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkSoftDeleteNode()
@@ -1666,37 +1769,32 @@ Exit:
 
 tEplKernel EplDllkSoftDeleteNode(unsigned int uiNodeId_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplDllkNodeInfo*   pIntNodeInfo;
+	tEplKernel Ret = kEplSuccessful;
+	tEplDllkNodeInfo *pIntNodeInfo;
 
-    pIntNodeInfo = EplDllkGetNodeInfo(uiNodeId_p);
-    if (pIntNodeInfo == NULL)
-    {   // no node info structure available
-        Ret = kEplDllNoNodeInfo;
-        goto Exit;
-    }
+	pIntNodeInfo = EplDllkGetNodeInfo(uiNodeId_p);
+	if (pIntNodeInfo == NULL) {	// no node info structure available
+		Ret = kEplDllNoNodeInfo;
+		goto Exit;
+	}
 
-    EPL_DLLK_DBG_POST_TRACE_VALUE(kEplEventTypeDllkSoftDelNode,
-                                  uiNodeId_p,
-                                  0);
+	EPL_DLLK_DBG_POST_TRACE_VALUE(kEplEventTypeDllkSoftDelNode,
+				      uiNodeId_p, 0);
 
-    pIntNodeInfo->m_fSoftDelete = TRUE;
+	pIntNodeInfo->m_fSoftDelete = TRUE;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 #endif //(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
 //                                                                         //
 //=========================================================================//
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkChangeState
@@ -1712,556 +1810,596 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplDllkChangeState(tEplNmtEvent NmtEvent_p, tEplNmtState NmtState_p)
+static tEplKernel EplDllkChangeState(tEplNmtEvent NmtEvent_p,
+				     tEplNmtState NmtState_p)
 {
-tEplKernel              Ret = kEplSuccessful;
-tEplEvent               Event;
-tEplErrorHandlerkEvent  DllEvent;
-
-    DllEvent.m_ulDllErrorEvents = 0;
-    DllEvent.m_uiNodeId = 0;
-    DllEvent.m_NmtState = NmtState_p;
-
-    switch (NmtState_p)
-    {
-        case kEplNmtGsOff:
-        case kEplNmtGsInitialising:
-        case kEplNmtGsResetApplication:
-        case kEplNmtGsResetCommunication:
-        case kEplNmtGsResetConfiguration:
-        case kEplNmtCsBasicEthernet:
-            // enter DLL_GS_INIT
-            EplDllkInstance_g.m_DllState = kEplDllGsInit;
-            break;
-
-        case kEplNmtCsNotActive:
-        case kEplNmtCsPreOperational1:
-            // reduced EPL cycle is active
-            if (NmtEvent_p == kEplNmtEventDllCeSoc)
-            {   // SoC received
-                // enter DLL_CS_WAIT_PREQ
-                EplDllkInstance_g.m_DllState = kEplDllCsWaitPreq;
-            }
-            else
-            {
-                // enter DLL_GS_INIT
-                EplDllkInstance_g.m_DllState = kEplDllGsInit;
-            }
-            break;
-
-        case kEplNmtCsPreOperational2:
-        case kEplNmtCsReadyToOperate:
-        case kEplNmtCsOperational:
-            // full EPL cycle is active
-
-            switch (EplDllkInstance_g.m_DllState)
-            {
-                case kEplDllCsWaitPreq:
-                    switch (NmtEvent_p)
-                    {
-                            // DLL_CT2
-                        case kEplNmtEventDllCePreq:
-                            // enter DLL_CS_WAIT_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_RECVD_PREQ;
-                            EplDllkInstance_g.m_DllState = kEplDllCsWaitSoa;
-                            break;
-
-                            // DLL_CT8
-                        case kEplNmtEventDllCeFrameTimeout:
-                            if (NmtState_p == kEplNmtCsPreOperational2)
-                            {   // ignore frame timeout in PreOp2,
-                                // because the previously configured cycle len
-                                // may be wrong.
-                                // 2008/10/15 d.k. If it would not be ignored,
-                                // we would go cyclically to PreOp1 and on next
-                                // SoC back to PreOp2.
-                                break;
-                            }
-
-                            // report DLL_CEV_LOSS_SOC and DLL_CEV_LOSS_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOA | EPL_DLL_ERR_CN_LOSS_SOC;
-
-                            // enter DLL_CS_WAIT_SOC
-                            EplDllkInstance_g.m_DllState = kEplDllCsWaitSoc;
-                            break;
-
-                        case kEplNmtEventDllCeSoa:
-                            // check if multiplexed and PReq should have been received in this cycle
-                            // and if >= NMT_CS_READY_TO_OPERATE
-                            if ((EplDllkInstance_g.m_uiCycleCount == 0)
-                                && (NmtState_p >= kEplNmtCsReadyToOperate))
-                            {   // report DLL_CEV_LOSS_OF_PREQ
-                                DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_PREQ;
-                            }
-
-                            // enter DLL_CS_WAIT_SOC
-                            EplDllkInstance_g.m_DllState = kEplDllCsWaitSoc;
-                            break;
-
-                            // DLL_CT7
-                        case kEplNmtEventDllCeSoc:
-                        case kEplNmtEventDllCeAsnd:
-                            // report DLL_CEV_LOSS_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOA;
-
-                        case kEplNmtEventDllCePres:
-                        default:
-                            // remain in this state
-                            break;
-                    }
-                    break;
-
-                case kEplDllCsWaitSoc:
-                    switch (NmtEvent_p)
-                    {
-                            // DLL_CT1
-                        case kEplNmtEventDllCeSoc:
-                            // start of cycle and isochronous phase
-                            // enter DLL_CS_WAIT_PREQ
-                            EplDllkInstance_g.m_DllState = kEplDllCsWaitPreq;
-                            break;
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
+	tEplErrorHandlerkEvent DllEvent;
+
+	DllEvent.m_ulDllErrorEvents = 0;
+	DllEvent.m_uiNodeId = 0;
+	DllEvent.m_NmtState = NmtState_p;
+
+	switch (NmtState_p) {
+	case kEplNmtGsOff:
+	case kEplNmtGsInitialising:
+	case kEplNmtGsResetApplication:
+	case kEplNmtGsResetCommunication:
+	case kEplNmtGsResetConfiguration:
+	case kEplNmtCsBasicEthernet:
+		// enter DLL_GS_INIT
+		EplDllkInstance_g.m_DllState = kEplDllGsInit;
+		break;
+
+	case kEplNmtCsNotActive:
+	case kEplNmtCsPreOperational1:
+		// reduced EPL cycle is active
+		if (NmtEvent_p == kEplNmtEventDllCeSoc) {	// SoC received
+			// enter DLL_CS_WAIT_PREQ
+			EplDllkInstance_g.m_DllState = kEplDllCsWaitPreq;
+		} else {
+			// enter DLL_GS_INIT
+			EplDllkInstance_g.m_DllState = kEplDllGsInit;
+		}
+		break;
+
+	case kEplNmtCsPreOperational2:
+	case kEplNmtCsReadyToOperate:
+	case kEplNmtCsOperational:
+		// full EPL cycle is active
+
+		switch (EplDllkInstance_g.m_DllState) {
+		case kEplDllCsWaitPreq:
+			switch (NmtEvent_p) {
+				// DLL_CT2
+			case kEplNmtEventDllCePreq:
+				// enter DLL_CS_WAIT_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_RECVD_PREQ;
+				EplDllkInstance_g.m_DllState = kEplDllCsWaitSoa;
+				break;
+
+				// DLL_CT8
+			case kEplNmtEventDllCeFrameTimeout:
+				if (NmtState_p == kEplNmtCsPreOperational2) {	// ignore frame timeout in PreOp2,
+					// because the previously configured cycle len
+					// may be wrong.
+					// 2008/10/15 d.k. If it would not be ignored,
+					// we would go cyclically to PreOp1 and on next
+					// SoC back to PreOp2.
+					break;
+				}
+				// report DLL_CEV_LOSS_SOC and DLL_CEV_LOSS_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOA |
+				    EPL_DLL_ERR_CN_LOSS_SOC;
+
+				// enter DLL_CS_WAIT_SOC
+				EplDllkInstance_g.m_DllState = kEplDllCsWaitSoc;
+				break;
+
+			case kEplNmtEventDllCeSoa:
+				// check if multiplexed and PReq should have been received in this cycle
+				// and if >= NMT_CS_READY_TO_OPERATE
+				if ((EplDllkInstance_g.m_uiCycleCount == 0)
+				    && (NmtState_p >= kEplNmtCsReadyToOperate)) {	// report DLL_CEV_LOSS_OF_PREQ
+					DllEvent.m_ulDllErrorEvents |=
+					    EPL_DLL_ERR_CN_LOSS_PREQ;
+				}
+				// enter DLL_CS_WAIT_SOC
+				EplDllkInstance_g.m_DllState = kEplDllCsWaitSoc;
+				break;
+
+				// DLL_CT7
+			case kEplNmtEventDllCeSoc:
+			case kEplNmtEventDllCeAsnd:
+				// report DLL_CEV_LOSS_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOA;
+
+			case kEplNmtEventDllCePres:
+			default:
+				// remain in this state
+				break;
+			}
+			break;
+
+		case kEplDllCsWaitSoc:
+			switch (NmtEvent_p) {
+				// DLL_CT1
+			case kEplNmtEventDllCeSoc:
+				// start of cycle and isochronous phase
+				// enter DLL_CS_WAIT_PREQ
+				EplDllkInstance_g.m_DllState =
+				    kEplDllCsWaitPreq;
+				break;
 
-                            // DLL_CT4
+				// DLL_CT4
 //                        case kEplNmtEventDllCePres:
-                        case kEplNmtEventDllCeFrameTimeout:
-                            if (NmtState_p == kEplNmtCsPreOperational2)
-                            {   // ignore frame timeout in PreOp2,
-                                // because the previously configured cycle len
-                                // may be wrong.
-                                // 2008/10/15 d.k. If it would not be ignored,
-                                // we would go cyclically to PreOp1 and on next
-                                // SoC back to PreOp2.
-                                break;
-                            }
-
-                            // fall through
-
-                        case kEplNmtEventDllCePreq:
-                        case kEplNmtEventDllCeSoa:
-                            // report DLL_CEV_LOSS_SOC
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOC;
-
-                        case kEplNmtEventDllCeAsnd:
-                        default:
-                            // remain in this state
-                            break;
-                    }
-                    break;
-
-                case kEplDllCsWaitSoa:
-                    switch (NmtEvent_p)
-                    {
-                        case kEplNmtEventDllCeFrameTimeout:
-                            // DLL_CT3
-                            if (NmtState_p == kEplNmtCsPreOperational2)
-                            {   // ignore frame timeout in PreOp2,
-                                // because the previously configured cycle len
-                                // may be wrong.
-                                // 2008/10/15 d.k. If it would not be ignored,
-                                // we would go cyclically to PreOp1 and on next
-                                // SoC back to PreOp2.
-                                break;
-                            }
-
-                            // fall through
-
-                        case kEplNmtEventDllCePreq:
-                            // report DLL_CEV_LOSS_SOC and DLL_CEV_LOSS_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOA | EPL_DLL_ERR_CN_LOSS_SOC;
-
-                        case kEplNmtEventDllCeSoa:
-                            // enter DLL_CS_WAIT_SOC
-                            EplDllkInstance_g.m_DllState = kEplDllCsWaitSoc;
-                            break;
-
-                            // DLL_CT9
-                        case kEplNmtEventDllCeSoc:
-                            // report DLL_CEV_LOSS_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOA;
-
-                            // enter DLL_CS_WAIT_PREQ
-                            EplDllkInstance_g.m_DllState = kEplDllCsWaitPreq;
-                            break;
-
-                            // DLL_CT10
-                        case kEplNmtEventDllCeAsnd:
-                            // report DLL_CEV_LOSS_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOA;
-
-                        case kEplNmtEventDllCePres:
-                        default:
-                            // remain in this state
-                            break;
-                    }
-                    break;
-
-                case kEplDllGsInit:
-                    // enter DLL_CS_WAIT_PREQ
-                    EplDllkInstance_g.m_DllState = kEplDllCsWaitPreq;
-                    break;
-
-                default:
-                    break;
-            }
-            break;
-
-        case kEplNmtCsStopped:
-            // full EPL cycle is active, but without PReq/PRes
-
-            switch (EplDllkInstance_g.m_DllState)
-            {
-                case kEplDllCsWaitPreq:
-                    switch (NmtEvent_p)
-                    {
-                            // DLL_CT2
-                        case kEplNmtEventDllCePreq:
-                            // enter DLL_CS_WAIT_SOA
-                            EplDllkInstance_g.m_DllState = kEplDllCsWaitSoa;
-                            break;
-
-                            // DLL_CT8
-                        case kEplNmtEventDllCeFrameTimeout:
-                            // report DLL_CEV_LOSS_SOC and DLL_CEV_LOSS_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOA | EPL_DLL_ERR_CN_LOSS_SOC;
-
-                        case kEplNmtEventDllCeSoa:
-                            // NMT_CS_STOPPED active
-                            // it is Ok if no PReq was received
-
-                            // enter DLL_CS_WAIT_SOC
-                            EplDllkInstance_g.m_DllState = kEplDllCsWaitSoc;
-                            break;
-
-                            // DLL_CT7
-                        case kEplNmtEventDllCeSoc:
-                        case kEplNmtEventDllCeAsnd:
-                            // report DLL_CEV_LOSS_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOA;
-
-                        case kEplNmtEventDllCePres:
-                        default:
-                            // remain in this state
-                            break;
-                    }
-                    break;
-
-                case kEplDllCsWaitSoc:
-                    switch (NmtEvent_p)
-                    {
-                            // DLL_CT1
-                        case kEplNmtEventDllCeSoc:
-                            // start of cycle and isochronous phase
-                            // enter DLL_CS_WAIT_SOA
-                            EplDllkInstance_g.m_DllState = kEplDllCsWaitSoa;
-                            break;
+			case kEplNmtEventDllCeFrameTimeout:
+				if (NmtState_p == kEplNmtCsPreOperational2) {	// ignore frame timeout in PreOp2,
+					// because the previously configured cycle len
+					// may be wrong.
+					// 2008/10/15 d.k. If it would not be ignored,
+					// we would go cyclically to PreOp1 and on next
+					// SoC back to PreOp2.
+					break;
+				}
+				// fall through
+
+			case kEplNmtEventDllCePreq:
+			case kEplNmtEventDllCeSoa:
+				// report DLL_CEV_LOSS_SOC
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOC;
+
+			case kEplNmtEventDllCeAsnd:
+			default:
+				// remain in this state
+				break;
+			}
+			break;
+
+		case kEplDllCsWaitSoa:
+			switch (NmtEvent_p) {
+			case kEplNmtEventDllCeFrameTimeout:
+				// DLL_CT3
+				if (NmtState_p == kEplNmtCsPreOperational2) {	// ignore frame timeout in PreOp2,
+					// because the previously configured cycle len
+					// may be wrong.
+					// 2008/10/15 d.k. If it would not be ignored,
+					// we would go cyclically to PreOp1 and on next
+					// SoC back to PreOp2.
+					break;
+				}
+				// fall through
+
+			case kEplNmtEventDllCePreq:
+				// report DLL_CEV_LOSS_SOC and DLL_CEV_LOSS_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOA |
+				    EPL_DLL_ERR_CN_LOSS_SOC;
+
+			case kEplNmtEventDllCeSoa:
+				// enter DLL_CS_WAIT_SOC
+				EplDllkInstance_g.m_DllState = kEplDllCsWaitSoc;
+				break;
+
+				// DLL_CT9
+			case kEplNmtEventDllCeSoc:
+				// report DLL_CEV_LOSS_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOA;
+
+				// enter DLL_CS_WAIT_PREQ
+				EplDllkInstance_g.m_DllState =
+				    kEplDllCsWaitPreq;
+				break;
+
+				// DLL_CT10
+			case kEplNmtEventDllCeAsnd:
+				// report DLL_CEV_LOSS_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOA;
+
+			case kEplNmtEventDllCePres:
+			default:
+				// remain in this state
+				break;
+			}
+			break;
+
+		case kEplDllGsInit:
+			// enter DLL_CS_WAIT_PREQ
+			EplDllkInstance_g.m_DllState = kEplDllCsWaitPreq;
+			break;
+
+		default:
+			break;
+		}
+		break;
+
+	case kEplNmtCsStopped:
+		// full EPL cycle is active, but without PReq/PRes
+
+		switch (EplDllkInstance_g.m_DllState) {
+		case kEplDllCsWaitPreq:
+			switch (NmtEvent_p) {
+				// DLL_CT2
+			case kEplNmtEventDllCePreq:
+				// enter DLL_CS_WAIT_SOA
+				EplDllkInstance_g.m_DllState = kEplDllCsWaitSoa;
+				break;
+
+				// DLL_CT8
+			case kEplNmtEventDllCeFrameTimeout:
+				// report DLL_CEV_LOSS_SOC and DLL_CEV_LOSS_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOA |
+				    EPL_DLL_ERR_CN_LOSS_SOC;
+
+			case kEplNmtEventDllCeSoa:
+				// NMT_CS_STOPPED active
+				// it is Ok if no PReq was received
+
+				// enter DLL_CS_WAIT_SOC
+				EplDllkInstance_g.m_DllState = kEplDllCsWaitSoc;
+				break;
+
+				// DLL_CT7
+			case kEplNmtEventDllCeSoc:
+			case kEplNmtEventDllCeAsnd:
+				// report DLL_CEV_LOSS_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOA;
+
+			case kEplNmtEventDllCePres:
+			default:
+				// remain in this state
+				break;
+			}
+			break;
+
+		case kEplDllCsWaitSoc:
+			switch (NmtEvent_p) {
+				// DLL_CT1
+			case kEplNmtEventDllCeSoc:
+				// start of cycle and isochronous phase
+				// enter DLL_CS_WAIT_SOA
+				EplDllkInstance_g.m_DllState = kEplDllCsWaitSoa;
+				break;
 
-                            // DLL_CT4
+				// DLL_CT4
 //                        case kEplNmtEventDllCePres:
-                        case kEplNmtEventDllCePreq:
-                        case kEplNmtEventDllCeSoa:
-                        case kEplNmtEventDllCeFrameTimeout:
-                            // report DLL_CEV_LOSS_SOC
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOC;
-
-                        case kEplNmtEventDllCeAsnd:
-                        default:
-                            // remain in this state
-                            break;
-                    }
-                    break;
-
-                case kEplDllCsWaitSoa:
-                    switch (NmtEvent_p)
-                    {
-                            // DLL_CT3
-                        case kEplNmtEventDllCeFrameTimeout:
-                            // report DLL_CEV_LOSS_SOC and DLL_CEV_LOSS_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOA | EPL_DLL_ERR_CN_LOSS_SOC;
-
-                        case kEplNmtEventDllCeSoa:
-                            // enter DLL_CS_WAIT_SOC
-                            EplDllkInstance_g.m_DllState = kEplDllCsWaitSoc;
-                            break;
-
-                            // DLL_CT9
-                        case kEplNmtEventDllCeSoc:
-                            // report DLL_CEV_LOSS_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOA;
-                            // remain in DLL_CS_WAIT_SOA
-                            break;
-
-                            // DLL_CT10
-                        case kEplNmtEventDllCeAsnd:
-                            // report DLL_CEV_LOSS_SOA
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_CN_LOSS_SOA;
-
-                        case kEplNmtEventDllCePreq:
-                            // NMT_CS_STOPPED active and we do not expect any PReq
-                            // so just ignore it
-                        case kEplNmtEventDllCePres:
-                        default:
-                            // remain in this state
-                            break;
-                    }
-                    break;
-
-                case kEplDllGsInit:
-                default:
-                    // enter DLL_CS_WAIT_PREQ
-                    EplDllkInstance_g.m_DllState = kEplDllCsWaitSoa;
-                    break;
-            }
-            break;
+			case kEplNmtEventDllCePreq:
+			case kEplNmtEventDllCeSoa:
+			case kEplNmtEventDllCeFrameTimeout:
+				// report DLL_CEV_LOSS_SOC
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOC;
+
+			case kEplNmtEventDllCeAsnd:
+			default:
+				// remain in this state
+				break;
+			}
+			break;
+
+		case kEplDllCsWaitSoa:
+			switch (NmtEvent_p) {
+				// DLL_CT3
+			case kEplNmtEventDllCeFrameTimeout:
+				// report DLL_CEV_LOSS_SOC and DLL_CEV_LOSS_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOA |
+				    EPL_DLL_ERR_CN_LOSS_SOC;
+
+			case kEplNmtEventDllCeSoa:
+				// enter DLL_CS_WAIT_SOC
+				EplDllkInstance_g.m_DllState = kEplDllCsWaitSoc;
+				break;
+
+				// DLL_CT9
+			case kEplNmtEventDllCeSoc:
+				// report DLL_CEV_LOSS_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOA;
+				// remain in DLL_CS_WAIT_SOA
+				break;
+
+				// DLL_CT10
+			case kEplNmtEventDllCeAsnd:
+				// report DLL_CEV_LOSS_SOA
+				DllEvent.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOA;
+
+			case kEplNmtEventDllCePreq:
+				// NMT_CS_STOPPED active and we do not expect any PReq
+				// so just ignore it
+			case kEplNmtEventDllCePres:
+			default:
+				// remain in this state
+				break;
+			}
+			break;
+
+		case kEplDllGsInit:
+		default:
+			// enter DLL_CS_WAIT_PREQ
+			EplDllkInstance_g.m_DllState = kEplDllCsWaitSoa;
+			break;
+		}
+		break;
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-        case kEplNmtMsNotActive:
-        case kEplNmtMsBasicEthernet:
-            break;
-
-        case kEplNmtMsPreOperational1:
-            // reduced EPL cycle is active
-            if (EplDllkInstance_g.m_DllState != kEplDllMsNonCyclic)
-            {   // stop cycle timer
+	case kEplNmtMsNotActive:
+	case kEplNmtMsBasicEthernet:
+		break;
+
+	case kEplNmtMsPreOperational1:
+		// reduced EPL cycle is active
+		if (EplDllkInstance_g.m_DllState != kEplDllMsNonCyclic) {	// stop cycle timer
 #if EPL_TIMER_USE_HIGHRES != FALSE
-                Ret = EplTimerHighReskDeleteTimer(&EplDllkInstance_g.m_TimerHdlCycle);
-#endif
-                EplDllkInstance_g.m_DllState = kEplDllMsNonCyclic;
-
-                // stop further processing,
-                // because it will be restarted by NMT MN module
-                break;
-            }
-
-            switch (NmtEvent_p)
-            {
-                case kEplNmtEventDllMeSocTrig:
-                case kEplNmtEventDllCeAsnd:
-                {   // because of reduced EPL cycle SoA shall be triggered, not SoC
-                tEplDllState    DummyDllState;
+			Ret =
+			    EplTimerHighReskDeleteTimer(&EplDllkInstance_g.
+							m_TimerHdlCycle);
+#endif
+			EplDllkInstance_g.m_DllState = kEplDllMsNonCyclic;
+
+			// stop further processing,
+			// because it will be restarted by NMT MN module
+			break;
+		}
+
+		switch (NmtEvent_p) {
+		case kEplNmtEventDllMeSocTrig:
+		case kEplNmtEventDllCeAsnd:
+			{	// because of reduced EPL cycle SoA shall be triggered, not SoC
+				tEplDllState DummyDllState;
+
+				Ret =
+				    EplDllkAsyncFrameNotReceived
+				    (EplDllkInstance_g.m_LastReqServiceId,
+				     EplDllkInstance_g.m_uiLastTargetNodeId);
+
+				// go ahead and send SoA
+				Ret = EplDllkMnSendSoa(NmtState_p,
+						       &DummyDllState,
+						       (EplDllkInstance_g.
+							m_uiCycleCount >=
+							EPL_C_DLL_PREOP1_START_CYCLES));
+				// increment cycle counter to detect if EPL_C_DLL_PREOP1_START_CYCLES empty cycles are elapsed
+				EplDllkInstance_g.m_uiCycleCount++;
 
-                    Ret = EplDllkAsyncFrameNotReceived(EplDllkInstance_g.m_LastReqServiceId,
-                                                       EplDllkInstance_g.m_uiLastTargetNodeId);
-
-                    // go ahead and send SoA
-                    Ret = EplDllkMnSendSoa(NmtState_p,
-                                           &DummyDllState,
-                                           (EplDllkInstance_g.m_uiCycleCount >= EPL_C_DLL_PREOP1_START_CYCLES));
-                    // increment cycle counter to detect if EPL_C_DLL_PREOP1_START_CYCLES empty cycles are elapsed
-                    EplDllkInstance_g.m_uiCycleCount++;
-
-                    // reprogram timer
+				// reprogram timer
 #if EPL_TIMER_USE_HIGHRES != FALSE
-                    if (EplDllkInstance_g.m_DllConfigParam.m_dwAsyncSlotTimeout != 0)
-                    {
-                        Ret = EplTimerHighReskModifyTimerNs(&EplDllkInstance_g.m_TimerHdlCycle,
-                            EplDllkInstance_g.m_DllConfigParam.m_dwAsyncSlotTimeout,
-                            EplDllkCbMnTimerCycle,
-                            0L,
-                            FALSE);
-                    }
-#endif
-                    break;
-                }
-
-                default:
-                    break;
-            }
-            break;
-
-        case kEplNmtMsPreOperational2:
-        case kEplNmtMsReadyToOperate:
-        case kEplNmtMsOperational:
-            // full EPL cycle is active
-            switch (NmtEvent_p)
-            {
-                case kEplNmtEventDllMeSocTrig:
-                {
-                    // update cycle counter
-                    if (EplDllkInstance_g.m_DllConfigParam.m_uiMultiplCycleCnt > 0)
-                    {   // multiplexed cycle active
-                        EplDllkInstance_g.m_uiCycleCount = (EplDllkInstance_g.m_uiCycleCount + 1) % EplDllkInstance_g.m_DllConfigParam.m_uiMultiplCycleCnt;
-                        // $$$ check multiplexed cycle restart
-                        //     -> toggle MC flag
-                        //     -> change node linked list
-                    }
-                    else
-                    {   // non-multiplexed cycle active
-                        // start with first node in isochronous phase
-                        EplDllkInstance_g.m_pCurNodeInfo = NULL;
-                    }
-
-                    switch (EplDllkInstance_g.m_DllState)
-                    {
-                        case kEplDllMsNonCyclic:
-                        {   // start continuous cycle timer
+				if (EplDllkInstance_g.m_DllConfigParam.
+				    m_dwAsyncSlotTimeout != 0) {
+					Ret =
+					    EplTimerHighReskModifyTimerNs
+					    (&EplDllkInstance_g.m_TimerHdlCycle,
+					     EplDllkInstance_g.m_DllConfigParam.
+					     m_dwAsyncSlotTimeout,
+					     EplDllkCbMnTimerCycle, 0L, FALSE);
+				}
+#endif
+				break;
+			}
+
+		default:
+			break;
+		}
+		break;
+
+	case kEplNmtMsPreOperational2:
+	case kEplNmtMsReadyToOperate:
+	case kEplNmtMsOperational:
+		// full EPL cycle is active
+		switch (NmtEvent_p) {
+		case kEplNmtEventDllMeSocTrig:
+			{
+				// update cycle counter
+				if (EplDllkInstance_g.m_DllConfigParam.m_uiMultiplCycleCnt > 0) {	// multiplexed cycle active
+					EplDllkInstance_g.m_uiCycleCount =
+					    (EplDllkInstance_g.m_uiCycleCount +
+					     1) %
+					    EplDllkInstance_g.m_DllConfigParam.
+					    m_uiMultiplCycleCnt;
+					// $$$ check multiplexed cycle restart
+					//     -> toggle MC flag
+					//     -> change node linked list
+				} else {	// non-multiplexed cycle active
+					// start with first node in isochronous phase
+					EplDllkInstance_g.m_pCurNodeInfo = NULL;
+				}
+
+				switch (EplDllkInstance_g.m_DllState) {
+				case kEplDllMsNonCyclic:
+					{	// start continuous cycle timer
 #if EPL_TIMER_USE_HIGHRES != FALSE
-                            Ret = EplTimerHighReskModifyTimerNs(&EplDllkInstance_g.m_TimerHdlCycle,
-                                EplDllkInstance_g.m_ullFrameTimeout,
-                                EplDllkCbMnTimerCycle,
-                                0L,
-                                TRUE);
-#endif
-                            // continue with sending SoC
-                        }
-
-                        case kEplDllMsWaitAsnd:
-                        case kEplDllMsWaitSocTrig:
-                        {   // if m_LastReqServiceId is still valid,
-                            // SoA was not correctly answered
-                            // and user part has to be informed
-                            Ret = EplDllkAsyncFrameNotReceived(EplDllkInstance_g.m_LastReqServiceId,
-                                                               EplDllkInstance_g.m_uiLastTargetNodeId);
-
-                            // send SoC
-                            Ret = EplDllkMnSendSoc();
+						Ret =
+						    EplTimerHighReskModifyTimerNs
+						    (&EplDllkInstance_g.
+						     m_TimerHdlCycle,
+						     EplDllkInstance_g.
+						     m_ullFrameTimeout,
+						     EplDllkCbMnTimerCycle, 0L,
+						     TRUE);
+#endif
+						// continue with sending SoC
+					}
+
+				case kEplDllMsWaitAsnd:
+				case kEplDllMsWaitSocTrig:
+					{	// if m_LastReqServiceId is still valid,
+						// SoA was not correctly answered
+						// and user part has to be informed
+						Ret =
+						    EplDllkAsyncFrameNotReceived
+						    (EplDllkInstance_g.
+						     m_LastReqServiceId,
+						     EplDllkInstance_g.
+						     m_uiLastTargetNodeId);
+
+						// send SoC
+						Ret = EplDllkMnSendSoc();
+
+						// new DLL state
+						EplDllkInstance_g.m_DllState =
+						    kEplDllMsWaitPreqTrig;
 
-                            // new DLL state
-                            EplDllkInstance_g.m_DllState = kEplDllMsWaitPreqTrig;
-
-                            // start WaitSoCPReq Timer
+						// start WaitSoCPReq Timer
 #if EPL_TIMER_USE_HIGHRES != FALSE
-                            Ret = EplTimerHighReskModifyTimerNs(&EplDllkInstance_g.m_TimerHdlResponse,
-                                EplDllkInstance_g.m_DllConfigParam.m_dwWaitSocPreq,
-                                EplDllkCbMnTimerResponse,
-                                0L,
-                                FALSE);
-#endif
-                            break;
-                        }
-
-                        default:
-                        {   // wrong DLL state / cycle time exceeded
-                            DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_MN_CYCTIMEEXCEED;
-                            EplDllkInstance_g.m_DllState = kEplDllMsWaitSocTrig;
-                            break;
-                        }
-                    }
-
-                    break;
-                }
-
-                case kEplNmtEventDllMePresTimeout:
-                {
-
-                    switch (EplDllkInstance_g.m_DllState)
-                    {
-                        case kEplDllMsWaitPres:
-                        {   // PRes not received
-
-                            if (EplDllkInstance_g.m_pCurNodeInfo->m_fSoftDelete == FALSE)
-                            {   // normal isochronous CN
-                                DllEvent.m_ulDllErrorEvents |= EPL_DLL_ERR_MN_CN_LOSS_PRES;
-                                DllEvent.m_uiNodeId = EplDllkInstance_g.m_pCurNodeInfo->m_uiNodeId;
-                            }
-                            else
-                            {   // CN shall be deleted softly
-                                Event.m_EventSink = kEplEventSinkDllkCal;
-                                Event.m_EventType = kEplEventTypeDllkSoftDelNode;
-                                // $$$ d.k. set Event.m_NetTime to current time
-                                Event.m_uiSize = sizeof (unsigned int);
-                                Event.m_pArg = &EplDllkInstance_g.m_pCurNodeInfo->m_uiNodeId;
-                                Ret = EplEventkPost(&Event);
-                            }
-
-                            // continue with sending next PReq
-                        }
-
-                        case kEplDllMsWaitPreqTrig:
-                        {
-                            // send next PReq
-                            Ret = EplDllkMnSendPreq(NmtState_p, &EplDllkInstance_g.m_DllState);
-
-                            break;
-                        }
-
-                        default:
-                        {   // wrong DLL state
-                            break;
-                        }
-                    }
-
-                    break;
-                }
-
-                case kEplNmtEventDllCePres:
-                {
-
-                    switch (EplDllkInstance_g.m_DllState)
-                    {
-                        case kEplDllMsWaitPres:
-                        {   // PRes received
-                            // send next PReq
-                            Ret = EplDllkMnSendPreq(NmtState_p, &EplDllkInstance_g.m_DllState);
-
-                            break;
-                        }
-
-                        default:
-                        {   // wrong DLL state
-                            break;
-                        }
-                    }
-
-                    break;
-                }
-
-                case kEplNmtEventDllMeSoaTrig:
-                {
-
-                    switch (EplDllkInstance_g.m_DllState)
-                    {
-                        case kEplDllMsWaitSoaTrig:
-                        {   // MN PRes sent
-                            // send SoA
-                            Ret = EplDllkMnSendSoa(NmtState_p, &EplDllkInstance_g.m_DllState, TRUE);
-
-                            break;
-                        }
-
-                        default:
-                        {   // wrong DLL state
-                            break;
-                        }
-                    }
+						Ret =
+						    EplTimerHighReskModifyTimerNs
+						    (&EplDllkInstance_g.
+						     m_TimerHdlResponse,
+						     EplDllkInstance_g.
+						     m_DllConfigParam.
+						     m_dwWaitSocPreq,
+						     EplDllkCbMnTimerResponse,
+						     0L, FALSE);
+#endif
+						break;
+					}
+
+				default:
+					{	// wrong DLL state / cycle time exceeded
+						DllEvent.m_ulDllErrorEvents |=
+						    EPL_DLL_ERR_MN_CYCTIMEEXCEED;
+						EplDllkInstance_g.m_DllState =
+						    kEplDllMsWaitSocTrig;
+						break;
+					}
+				}
+
+				break;
+			}
+
+		case kEplNmtEventDllMePresTimeout:
+			{
+
+				switch (EplDllkInstance_g.m_DllState) {
+				case kEplDllMsWaitPres:
+					{	// PRes not received
+
+						if (EplDllkInstance_g.m_pCurNodeInfo->m_fSoftDelete == FALSE) {	// normal isochronous CN
+							DllEvent.
+							    m_ulDllErrorEvents
+							    |=
+							    EPL_DLL_ERR_MN_CN_LOSS_PRES;
+							DllEvent.m_uiNodeId =
+							    EplDllkInstance_g.
+							    m_pCurNodeInfo->
+							    m_uiNodeId;
+						} else {	// CN shall be deleted softly
+							Event.m_EventSink =
+							    kEplEventSinkDllkCal;
+							Event.m_EventType =
+							    kEplEventTypeDllkSoftDelNode;
+							// $$$ d.k. set Event.m_NetTime to current time
+							Event.m_uiSize =
+							    sizeof(unsigned
+								   int);
+							Event.m_pArg =
+							    &EplDllkInstance_g.
+							    m_pCurNodeInfo->
+							    m_uiNodeId;
+							Ret =
+							    EplEventkPost
+							    (&Event);
+						}
+
+						// continue with sending next PReq
+					}
+
+				case kEplDllMsWaitPreqTrig:
+					{
+						// send next PReq
+						Ret =
+						    EplDllkMnSendPreq
+						    (NmtState_p,
+						     &EplDllkInstance_g.
+						     m_DllState);
+
+						break;
+					}
+
+				default:
+					{	// wrong DLL state
+						break;
+					}
+				}
+
+				break;
+			}
+
+		case kEplNmtEventDllCePres:
+			{
+
+				switch (EplDllkInstance_g.m_DllState) {
+				case kEplDllMsWaitPres:
+					{	// PRes received
+						// send next PReq
+						Ret =
+						    EplDllkMnSendPreq
+						    (NmtState_p,
+						     &EplDllkInstance_g.
+						     m_DllState);
+
+						break;
+					}
+
+				default:
+					{	// wrong DLL state
+						break;
+					}
+				}
+
+				break;
+			}
+
+		case kEplNmtEventDllMeSoaTrig:
+			{
+
+				switch (EplDllkInstance_g.m_DllState) {
+				case kEplDllMsWaitSoaTrig:
+					{	// MN PRes sent
+						// send SoA
+						Ret =
+						    EplDllkMnSendSoa(NmtState_p,
+								     &EplDllkInstance_g.
+								     m_DllState,
+								     TRUE);
+
+						break;
+					}
+
+				default:
+					{	// wrong DLL state
+						break;
+					}
+				}
 
-                    break;
-                }
+				break;
+			}
 
-                case kEplNmtEventDllCeAsnd:
-                {   // ASnd has been received, but it may be not the requested one
+		case kEplNmtEventDllCeAsnd:
+			{	// ASnd has been received, but it may be not the requested one
 /*
                     // report if SoA was correctly answered
                     Ret = EplDllkAsyncFrameNotReceived(EplDllkInstance_g.m_LastReqServiceId,
                                                        EplDllkInstance_g.m_uiLastTargetNodeId);
 */
-                    if (EplDllkInstance_g.m_DllState == kEplDllMsWaitAsnd)
-                    {
-                        EplDllkInstance_g.m_DllState = kEplDllMsWaitSocTrig;
-                    }
-                    break;
-                }
-
-                default:
-                    break;
-            }
-            break;
+				if (EplDllkInstance_g.m_DllState ==
+				    kEplDllMsWaitAsnd) {
+					EplDllkInstance_g.m_DllState =
+					    kEplDllMsWaitSocTrig;
+				}
+				break;
+			}
+
+		default:
+			break;
+		}
+		break;
 #endif //(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
-        default:
-            break;
-    }
-
-    if (DllEvent.m_ulDllErrorEvents != 0)
-    {   // error event set -> post it to error handler
-        Event.m_EventSink = kEplEventSinkErrk;
-        Event.m_EventType = kEplEventTypeDllError;
-        // $$$ d.k. set Event.m_NetTime to current time
-        Event.m_uiSize = sizeof (DllEvent);
-        Event.m_pArg = &DllEvent;
-        Ret = EplEventkPost(&Event);
-    }
+	default:
+		break;
+	}
+
+	if (DllEvent.m_ulDllErrorEvents != 0) {	// error event set -> post it to error handler
+		Event.m_EventSink = kEplEventSinkErrk;
+		Event.m_EventType = kEplEventTypeDllError;
+		// $$$ d.k. set Event.m_NetTime to current time
+		Event.m_uiSize = sizeof(DllEvent);
+		Event.m_pArg = &DllEvent;
+		Ret = EplEventkPost(&Event);
+	}
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -2281,652 +2419,754 @@ tEplErrorHandlerkEvent  DllEvent;
 
 static void EplDllkCbFrameReceived(tEdrvRxBuffer * pRxBuffer_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplNmtState    NmtState;
-tEplNmtEvent    NmtEvent = kEplNmtEventNoEvent;
-tEplEvent       Event;
-tEplFrame      *pFrame;
-tEplFrame      *pTxFrame;
-tEdrvTxBuffer  *pTxBuffer = NULL;
-tEplFrameInfo   FrameInfo;
-tEplMsgType     MsgType;
-tEplDllReqServiceId     ReqServiceId;
-unsigned int    uiAsndServiceId;
-unsigned int    uiNodeId;
-BYTE            bFlag1;
+	tEplKernel Ret = kEplSuccessful;
+	tEplNmtState NmtState;
+	tEplNmtEvent NmtEvent = kEplNmtEventNoEvent;
+	tEplEvent Event;
+	tEplFrame *pFrame;
+	tEplFrame *pTxFrame;
+	tEdrvTxBuffer *pTxBuffer = NULL;
+	tEplFrameInfo FrameInfo;
+	tEplMsgType MsgType;
+	tEplDllReqServiceId ReqServiceId;
+	unsigned int uiAsndServiceId;
+	unsigned int uiNodeId;
+	BYTE bFlag1;
+
+	BENCHMARK_MOD_02_SET(3);
+	NmtState = EplNmtkGetNmtState();
+
+	if (NmtState <= kEplNmtGsResetConfiguration) {
+		goto Exit;
+	}
 
-    BENCHMARK_MOD_02_SET(3);
-    NmtState = EplNmtkGetNmtState();
-
-    if (NmtState <= kEplNmtGsResetConfiguration)
-    {
-        goto Exit;
-    }
-
-    pFrame = (tEplFrame *) pRxBuffer_p->m_pbBuffer;
+	pFrame = (tEplFrame *) pRxBuffer_p->m_pbBuffer;
 
 #if EDRV_EARLY_RX_INT != FALSE
-    switch (pRxBuffer_p->m_BufferInFrame)
-    {
-        case kEdrvBufferFirstInFrame:
-        {
-            MsgType = (tEplMsgType)AmiGetByteFromLe(&pFrame->m_le_bMessageType);
-            if (MsgType == kEplMsgTypePreq)
-            {
-            if (EplDllkInstance_g.m_DllState == kEplDllCsWaitPreq)
-            {   // PReq expected and actually received
-                // d.k.: The condition above is sufficent, because EPL cycle is active
-                //       and no non-EPL frame shall be received in isochronous phase.
-                // start transmission PRes
-                // $$$ What if Tx buffer is invalid?
-                pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES];
+	switch (pRxBuffer_p->m_BufferInFrame) {
+	case kEdrvBufferFirstInFrame:
+		{
+			MsgType =
+			    (tEplMsgType) AmiGetByteFromLe(&pFrame->
+							   m_le_bMessageType);
+			if (MsgType == kEplMsgTypePreq) {
+				if (EplDllkInstance_g.m_DllState == kEplDllCsWaitPreq) {	// PReq expected and actually received
+					// d.k.: The condition above is sufficent, because EPL cycle is active
+					//       and no non-EPL frame shall be received in isochronous phase.
+					// start transmission PRes
+					// $$$ What if Tx buffer is invalid?
+					pTxBuffer =
+					    &EplDllkInstance_g.
+					    m_pTxBuffer[EPL_DLLK_TXFRAME_PRES];
 #if (EPL_DLL_PRES_READY_AFTER_SOA != FALSE) || (EPL_DLL_PRES_READY_AFTER_SOC != FALSE)
-                Ret = EdrvTxMsgStart(pTxBuffer);
+					Ret = EdrvTxMsgStart(pTxBuffer);
 #else
-                pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
-                // update frame (NMT state, RD, RS, PR, MS, EN flags)
-                AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bNmtStatus, (BYTE) NmtState);
-                AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag2, EplDllkInstance_g.m_bFlag2);
-                if (NmtState != kEplNmtCsOperational)
-                {   // mark PDO as invalid in NMT state Op
-                    // $$$ reset only RD flag; set other flags appropriately
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag1, 0);
-                }
-                // $$$ make function that updates Pres, StatusRes
-                // send PRes frame
-                Ret = EdrvSendTxMsg(pTxBuffer);
-#endif
-            }
-            }
-            goto Exit;
-        }
-
-        case kEdrvBufferMiddleInFrame:
-        {
-            goto Exit;
-        }
-
-        case kEdrvBufferLastInFrame:
-        {
-            break;
-        }
-    }
-#endif
-
-    FrameInfo.m_pFrame = pFrame;
-    FrameInfo.m_uiFrameSize = pRxBuffer_p->m_uiRxMsgLen;
-    FrameInfo.m_NetTime.m_dwNanoSec = pRxBuffer_p->m_NetTime.m_dwNanoSec;
-    FrameInfo.m_NetTime.m_dwSec = pRxBuffer_p->m_NetTime.m_dwSec;
-
-    if (AmiGetWordFromBe(&pFrame->m_be_wEtherType) != EPL_C_DLL_ETHERTYPE_EPL)
-    {   // non-EPL frame
-        //TRACE2("EplDllkCbFrameReceived: pfnCbAsync=0x%p SrcMAC=0x%llx\n", EplDllkInstance_g.m_pfnCbAsync, AmiGetQword48FromBe(pFrame->m_be_abSrcMac));
-        if (EplDllkInstance_g.m_pfnCbAsync != NULL)
-        {   // handler for async frames is registered
-            EplDllkInstance_g.m_pfnCbAsync(&FrameInfo);
-        }
-
-        goto Exit;
-    }
-
-    MsgType = (tEplMsgType)AmiGetByteFromLe(&pFrame->m_le_bMessageType);
-    switch (MsgType)
-    {
-        case kEplMsgTypePreq:
-        {
-            // PReq frame
-            // d.k.: (we assume that this PReq frame is intended for us and don't check DstNodeId)
-            if (AmiGetByteFromLe(&pFrame->m_le_bDstNodeId) != EplDllkInstance_g.m_DllConfigParam.m_uiNodeId)
-            {   // this PReq is not intended for us
-                goto Exit;
-            }
-            NmtEvent = kEplNmtEventDllCePreq;
-
-            if (NmtState >= kEplNmtMsNotActive)
-            {   // MN is active -> wrong msg type
-                break;
-            }
-
+					pTxFrame =
+					    (tEplFrame *) pTxBuffer->m_pbBuffer;
+					// update frame (NMT state, RD, RS, PR, MS, EN flags)
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
+						       m_le_bNmtStatus,
+						       (BYTE) NmtState);
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
+						       m_le_bFlag2,
+						       EplDllkInstance_g.
+						       m_bFlag2);
+					if (NmtState != kEplNmtCsOperational) {	// mark PDO as invalid in NMT state Op
+						// $$$ reset only RD flag; set other flags appropriately
+						AmiSetByteToLe(&pTxFrame->
+							       m_Data.m_Pres.
+							       m_le_bFlag1, 0);
+					}
+					// $$$ make function that updates Pres, StatusRes
+					// send PRes frame
+					Ret = EdrvSendTxMsg(pTxBuffer);
+#endif
+				}
+			}
+			goto Exit;
+		}
+
+	case kEdrvBufferMiddleInFrame:
+		{
+			goto Exit;
+		}
+
+	case kEdrvBufferLastInFrame:
+		{
+			break;
+		}
+	}
+#endif
+
+	FrameInfo.m_pFrame = pFrame;
+	FrameInfo.m_uiFrameSize = pRxBuffer_p->m_uiRxMsgLen;
+	FrameInfo.m_NetTime.m_dwNanoSec = pRxBuffer_p->m_NetTime.m_dwNanoSec;
+	FrameInfo.m_NetTime.m_dwSec = pRxBuffer_p->m_NetTime.m_dwSec;
+
+	if (AmiGetWordFromBe(&pFrame->m_be_wEtherType) != EPL_C_DLL_ETHERTYPE_EPL) {	// non-EPL frame
+		//TRACE2("EplDllkCbFrameReceived: pfnCbAsync=0x%p SrcMAC=0x%llx\n", EplDllkInstance_g.m_pfnCbAsync, AmiGetQword48FromBe(pFrame->m_be_abSrcMac));
+		if (EplDllkInstance_g.m_pfnCbAsync != NULL) {	// handler for async frames is registered
+			EplDllkInstance_g.m_pfnCbAsync(&FrameInfo);
+		}
+
+		goto Exit;
+	}
+
+	MsgType = (tEplMsgType) AmiGetByteFromLe(&pFrame->m_le_bMessageType);
+	switch (MsgType) {
+	case kEplMsgTypePreq:
+		{
+			// PReq frame
+			// d.k.: (we assume that this PReq frame is intended for us and don't check DstNodeId)
+			if (AmiGetByteFromLe(&pFrame->m_le_bDstNodeId) != EplDllkInstance_g.m_DllConfigParam.m_uiNodeId) {	// this PReq is not intended for us
+				goto Exit;
+			}
+			NmtEvent = kEplNmtEventDllCePreq;
+
+			if (NmtState >= kEplNmtMsNotActive) {	// MN is active -> wrong msg type
+				break;
+			}
 #if EDRV_EARLY_RX_INT == FALSE
-            if (NmtState >= kEplNmtCsPreOperational2)
-            {   // respond to and process PReq frames only in PreOp2, ReadyToOp and Op
-                // Does PRes exist?
-                pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES];
-                if (pTxBuffer->m_pbBuffer != NULL)
-                {   // PRes does exist
+			if (NmtState >= kEplNmtCsPreOperational2) {	// respond to and process PReq frames only in PreOp2, ReadyToOp and Op
+				// Does PRes exist?
+				pTxBuffer =
+				    &EplDllkInstance_g.
+				    m_pTxBuffer[EPL_DLLK_TXFRAME_PRES];
+				if (pTxBuffer->m_pbBuffer != NULL) {	// PRes does exist
 #if (EPL_DLL_PRES_READY_AFTER_SOA != FALSE) || (EPL_DLL_PRES_READY_AFTER_SOC != FALSE)
-                    EdrvTxMsgStart(pTxBuffer);
+					EdrvTxMsgStart(pTxBuffer);
 #else
-                    pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
-                    // update frame (NMT state, RD, RS, PR, MS, EN flags)
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bNmtStatus, (BYTE) NmtState);
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag2, EplDllkInstance_g.m_bFlag2);
-                    bFlag1 = AmiGetByteFromLe(&pFrame->m_Data.m_Preq.m_le_bFlag1);
-                    // save EA flag
-                    EplDllkInstance_g.m_bMnFlag1 =
-                        (EplDllkInstance_g.m_bMnFlag1 & ~EPL_FRAME_FLAG1_EA)
-                        | (bFlag1 & EPL_FRAME_FLAG1_EA);
-                    // preserve MS flag
-                    bFlag1 &= EPL_FRAME_FLAG1_MS;
-                    // add EN flag from Error signaling module
-                    bFlag1 |= EplDllkInstance_g.m_bFlag1 & EPL_FRAME_FLAG1_EN;
-                    if (NmtState != kEplNmtCsOperational)
-                    {   // mark PDO as invalid in NMT state Op
-                        // reset only RD flag
-                        AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag1, bFlag1);
-                    }
-                    else
-                    {   // leave RD flag untouched
-                        AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag1,
-                            (AmiGetByteFromLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag1) & EPL_FRAME_FLAG1_RD)
-                            | bFlag1);
-                    }
-                    // $$$ update EPL_DLL_PRES_READY_AFTER_* code
-                    // send PRes frame
-                    Ret = EdrvSendTxMsg(pTxBuffer);
-                    if (Ret != kEplSuccessful)
-                    {
-                        goto Exit;
-                    }
+					pTxFrame =
+					    (tEplFrame *) pTxBuffer->m_pbBuffer;
+					// update frame (NMT state, RD, RS, PR, MS, EN flags)
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
+						       m_le_bNmtStatus,
+						       (BYTE) NmtState);
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
+						       m_le_bFlag2,
+						       EplDllkInstance_g.
+						       m_bFlag2);
+					bFlag1 =
+					    AmiGetByteFromLe(&pFrame->m_Data.
+							     m_Preq.
+							     m_le_bFlag1);
+					// save EA flag
+					EplDllkInstance_g.m_bMnFlag1 =
+					    (EplDllkInstance_g.
+					     m_bMnFlag1 & ~EPL_FRAME_FLAG1_EA)
+					    | (bFlag1 & EPL_FRAME_FLAG1_EA);
+					// preserve MS flag
+					bFlag1 &= EPL_FRAME_FLAG1_MS;
+					// add EN flag from Error signaling module
+					bFlag1 |=
+					    EplDllkInstance_g.
+					    m_bFlag1 & EPL_FRAME_FLAG1_EN;
+					if (NmtState != kEplNmtCsOperational) {	// mark PDO as invalid in NMT state Op
+						// reset only RD flag
+						AmiSetByteToLe(&pTxFrame->
+							       m_Data.m_Pres.
+							       m_le_bFlag1,
+							       bFlag1);
+					} else {	// leave RD flag untouched
+						AmiSetByteToLe(&pTxFrame->
+							       m_Data.m_Pres.
+							       m_le_bFlag1,
+							       (AmiGetByteFromLe
+								(&pTxFrame->
+								 m_Data.m_Pres.
+								 m_le_bFlag1) &
+								EPL_FRAME_FLAG1_RD)
+							       | bFlag1);
+					}
+					// $$$ update EPL_DLL_PRES_READY_AFTER_* code
+					// send PRes frame
+					Ret = EdrvSendTxMsg(pTxBuffer);
+					if (Ret != kEplSuccessful) {
+						goto Exit;
+					}
 #endif
-                }
+				}
 #endif
-                // inform PDO module
+				// inform PDO module
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
-                if (NmtState >= kEplNmtCsReadyToOperate)
-                {   // inform PDO module only in ReadyToOp and Op
-                    if (NmtState != kEplNmtCsOperational)
-                    {
-                        // reset RD flag and all other flags, but that does not matter, because they were processed above
-                        AmiSetByteToLe(&pFrame->m_Data.m_Preq.m_le_bFlag1, 0);
-                    }
-
-                    // compares real frame size and PDO size
-                    if ((unsigned int) (AmiGetWordFromLe(&pFrame->m_Data.m_Preq.m_le_wSize) + 24)
-                        > FrameInfo.m_uiFrameSize)
-                    {   // format error
-                    tEplErrorHandlerkEvent  DllEvent;
-
-                        DllEvent.m_ulDllErrorEvents = EPL_DLL_ERR_INVALID_FORMAT;
-                        DllEvent.m_uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bSrcNodeId);
-                        DllEvent.m_NmtState = NmtState;
-                        Event.m_EventSink = kEplEventSinkErrk;
-                        Event.m_EventType = kEplEventTypeDllError;
-                        Event.m_NetTime = FrameInfo.m_NetTime;
-                        Event.m_uiSize = sizeof (DllEvent);
-                        Event.m_pArg = &DllEvent;
-                        Ret = EplEventkPost(&Event);
-                        break;
-                    }
+				if (NmtState >= kEplNmtCsReadyToOperate) {	// inform PDO module only in ReadyToOp and Op
+					if (NmtState != kEplNmtCsOperational) {
+						// reset RD flag and all other flags, but that does not matter, because they were processed above
+						AmiSetByteToLe(&pFrame->m_Data.
+							       m_Preq.
+							       m_le_bFlag1, 0);
+					}
+					// compares real frame size and PDO size
+					if ((unsigned
+					     int)(AmiGetWordFromLe(&pFrame->
+								   m_Data.
+								   m_Preq.
+								   m_le_wSize) +
+						  24)
+					    > FrameInfo.m_uiFrameSize) {	// format error
+						tEplErrorHandlerkEvent DllEvent;
+
+						DllEvent.m_ulDllErrorEvents =
+						    EPL_DLL_ERR_INVALID_FORMAT;
+						DllEvent.m_uiNodeId =
+						    AmiGetByteFromLe(&pFrame->
+								     m_le_bSrcNodeId);
+						DllEvent.m_NmtState = NmtState;
+						Event.m_EventSink =
+						    kEplEventSinkErrk;
+						Event.m_EventType =
+						    kEplEventTypeDllError;
+						Event.m_NetTime =
+						    FrameInfo.m_NetTime;
+						Event.m_uiSize =
+						    sizeof(DllEvent);
+						Event.m_pArg = &DllEvent;
+						Ret = EplEventkPost(&Event);
+						break;
+					}
+					// forward PReq frame as RPDO to PDO module
+					Ret = EplPdokCbPdoReceived(&FrameInfo);
 
-                    // forward PReq frame as RPDO to PDO module
-                    Ret = EplPdokCbPdoReceived(&FrameInfo);
-
-                }
+				}
 #if (EPL_DLL_PRES_READY_AFTER_SOC != FALSE)
-                if (pTxBuffer->m_pbBuffer != NULL)
-                {   // PRes does exist
-                    // inform PDO module about PRes after PReq
-                    FrameInfo.m_pFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
-                    FrameInfo.m_uiFrameSize = pTxBuffer->m_uiMaxBufferLen;
-                    Ret = EplPdokCbPdoTransmitted(&FrameInfo);
-                }
+				if (pTxBuffer->m_pbBuffer != NULL) {	// PRes does exist
+					// inform PDO module about PRes after PReq
+					FrameInfo.m_pFrame =
+					    (tEplFrame *) pTxBuffer->m_pbBuffer;
+					FrameInfo.m_uiFrameSize =
+					    pTxBuffer->m_uiMaxBufferLen;
+					Ret =
+					    EplPdokCbPdoTransmitted(&FrameInfo);
+				}
 #endif
 #endif
 
 #if EDRV_EARLY_RX_INT == FALSE
-                // $$$ inform emergency protocol handling (error signaling module) about flags
-            }
+				// $$$ inform emergency protocol handling (error signaling module) about flags
+			}
 #endif
 
-            // reset cycle counter
-            EplDllkInstance_g.m_uiCycleCount = 0;
+			// reset cycle counter
+			EplDllkInstance_g.m_uiCycleCount = 0;
 
-            break;
-        }
+			break;
+		}
 
-        case kEplMsgTypePres:
-        {
+	case kEplMsgTypePres:
+		{
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-        tEplDllkNodeInfo*   pIntNodeInfo;
-        tEplHeartbeatEvent  HeartbeatEvent;
+			tEplDllkNodeInfo *pIntNodeInfo;
+			tEplHeartbeatEvent HeartbeatEvent;
 #endif
 
-            // PRes frame
-            NmtEvent = kEplNmtEventDllCePres;
+			// PRes frame
+			NmtEvent = kEplNmtEventDllCePres;
 
-            uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bSrcNodeId);
+			uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bSrcNodeId);
 
-            if ((NmtState >= kEplNmtCsPreOperational2)
-                && (NmtState <= kEplNmtCsOperational))
-            {   // process PRes frames only in PreOp2, ReadyToOp and Op of CN
+			if ((NmtState >= kEplNmtCsPreOperational2)
+			    && (NmtState <= kEplNmtCsOperational)) {	// process PRes frames only in PreOp2, ReadyToOp and Op of CN
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-                pIntNodeInfo = EplDllkGetNodeInfo(uiNodeId);
-                if (pIntNodeInfo == NULL)
-                {   // no node info structure available
-                    Ret = kEplDllNoNodeInfo;
-                    goto Exit;
-                }
-            }
-            else if (EplDllkInstance_g.m_DllState == kEplDllMsWaitPres)
-            {   // or process PRes frames in MsWaitPres
-
-                pIntNodeInfo = EplDllkInstance_g.m_pCurNodeInfo;
-                if ((pIntNodeInfo == NULL) || (pIntNodeInfo->m_uiNodeId != uiNodeId))
-                {   // ignore PRes, because it is from wrong CN
-                    // $$$ maybe post event to NmtMn module
-                    goto Exit;
-                }
-
-                // forward Flag2 to asynchronous scheduler
-                bFlag1 = AmiGetByteFromLe(&pFrame->m_Data.m_Asnd.m_Payload.m_StatusResponse.m_le_bFlag2);
-                Ret = EplDllkCalAsyncSetPendingRequests(uiNodeId,
-                    ((tEplDllAsyncReqPriority) ((bFlag1 & EPL_FRAME_FLAG2_PR) >> EPL_FRAME_FLAG2_PR_SHIFT)),
-                    (bFlag1 & EPL_FRAME_FLAG2_RS));
-
-#endif
-            }
-            else
-            {   // ignore PRes, because it was received in wrong NMT state
-                // but execute EplDllkChangeState() and post event to NMT module
-                break;
-            }
+				pIntNodeInfo = EplDllkGetNodeInfo(uiNodeId);
+				if (pIntNodeInfo == NULL) {	// no node info structure available
+					Ret = kEplDllNoNodeInfo;
+					goto Exit;
+				}
+			} else if (EplDllkInstance_g.m_DllState == kEplDllMsWaitPres) {	// or process PRes frames in MsWaitPres
+
+				pIntNodeInfo = EplDllkInstance_g.m_pCurNodeInfo;
+				if ((pIntNodeInfo == NULL) || (pIntNodeInfo->m_uiNodeId != uiNodeId)) {	// ignore PRes, because it is from wrong CN
+					// $$$ maybe post event to NmtMn module
+					goto Exit;
+				}
+				// forward Flag2 to asynchronous scheduler
+				bFlag1 =
+				    AmiGetByteFromLe(&pFrame->m_Data.m_Asnd.
+						     m_Payload.m_StatusResponse.
+						     m_le_bFlag2);
+				Ret =
+				    EplDllkCalAsyncSetPendingRequests(uiNodeId,
+								      ((tEplDllAsyncReqPriority) ((bFlag1 & EPL_FRAME_FLAG2_PR) >> EPL_FRAME_FLAG2_PR_SHIFT)), (bFlag1 & EPL_FRAME_FLAG2_RS));
+
+#endif
+			} else {	// ignore PRes, because it was received in wrong NMT state
+				// but execute EplDllkChangeState() and post event to NMT module
+				break;
+			}
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-            {   // check NMT state of CN
-                HeartbeatEvent.m_wErrorCode = EPL_E_NO_ERROR;
-                HeartbeatEvent.m_NmtState =
-                    (tEplNmtState) (AmiGetByteFromLe(&pFrame->m_Data.m_Pres.m_le_bNmtStatus) | EPL_NMT_TYPE_CS);
-                if (pIntNodeInfo->m_NmtState != HeartbeatEvent.m_NmtState)
-                {   // NMT state of CN has changed -> post event to NmtMnu module
-                    if (pIntNodeInfo->m_fSoftDelete == FALSE)
-                    {   // normal isochronous CN
-                        HeartbeatEvent.m_uiNodeId = uiNodeId;
-                        Event.m_EventSink = kEplEventSinkNmtMnu;
-                        Event.m_EventType = kEplEventTypeHeartbeat;
-                        Event.m_uiSize = sizeof (HeartbeatEvent);
-                        Event.m_pArg = &HeartbeatEvent;
-                    }
-                    else
-                    {   // CN shall be deleted softly
-                        Event.m_EventSink = kEplEventSinkDllkCal;
-                        Event.m_EventType = kEplEventTypeDllkSoftDelNode;
-                        Event.m_uiSize = sizeof (unsigned int);
-                        Event.m_pArg = &pIntNodeInfo->m_uiNodeId;
-                    }
-                    Event.m_NetTime = FrameInfo.m_NetTime;
-                    Ret = EplEventkPost(&Event);
-
-                    // save current NMT state of CN in internal node structure
-                    pIntNodeInfo->m_NmtState = HeartbeatEvent.m_NmtState;
-                }
-            }
+			{	// check NMT state of CN
+				HeartbeatEvent.m_wErrorCode = EPL_E_NO_ERROR;
+				HeartbeatEvent.m_NmtState =
+				    (tEplNmtState) (AmiGetByteFromLe
+						    (&pFrame->m_Data.m_Pres.
+						     m_le_bNmtStatus) |
+						    EPL_NMT_TYPE_CS);
+				if (pIntNodeInfo->m_NmtState != HeartbeatEvent.m_NmtState) {	// NMT state of CN has changed -> post event to NmtMnu module
+					if (pIntNodeInfo->m_fSoftDelete == FALSE) {	// normal isochronous CN
+						HeartbeatEvent.m_uiNodeId =
+						    uiNodeId;
+						Event.m_EventSink =
+						    kEplEventSinkNmtMnu;
+						Event.m_EventType =
+						    kEplEventTypeHeartbeat;
+						Event.m_uiSize =
+						    sizeof(HeartbeatEvent);
+						Event.m_pArg = &HeartbeatEvent;
+					} else {	// CN shall be deleted softly
+						Event.m_EventSink =
+						    kEplEventSinkDllkCal;
+						Event.m_EventType =
+						    kEplEventTypeDllkSoftDelNode;
+						Event.m_uiSize =
+						    sizeof(unsigned int);
+						Event.m_pArg =
+						    &pIntNodeInfo->m_uiNodeId;
+					}
+					Event.m_NetTime = FrameInfo.m_NetTime;
+					Ret = EplEventkPost(&Event);
+
+					// save current NMT state of CN in internal node structure
+					pIntNodeInfo->m_NmtState =
+					    HeartbeatEvent.m_NmtState;
+				}
+			}
 #endif
 
-            // inform PDO module
+			// inform PDO module
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
-            if ((NmtState != kEplNmtCsPreOperational2)
-                && (NmtState != kEplNmtMsPreOperational2))
-            {   // inform PDO module only in ReadyToOp and Op
-                // compare real frame size and PDO size?
-                if (((unsigned int) (AmiGetWordFromLe(&pFrame->m_Data.m_Pres.m_le_wSize) + 24)
-                    > FrameInfo.m_uiFrameSize)
+			if ((NmtState != kEplNmtCsPreOperational2)
+			    && (NmtState != kEplNmtMsPreOperational2)) {	// inform PDO module only in ReadyToOp and Op
+				// compare real frame size and PDO size?
+				if (((unsigned
+				      int)(AmiGetWordFromLe(&pFrame->m_Data.
+							    m_Pres.m_le_wSize) +
+					   24)
+				     > FrameInfo.m_uiFrameSize)
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-                    || (AmiGetWordFromLe(&pFrame->m_Data.m_Pres.m_le_wSize) > pIntNodeInfo->m_wPresPayloadLimit)
-#endif
-                    )
-                {   // format error
-                tEplErrorHandlerkEvent  DllEvent;
-
-                    DllEvent.m_ulDllErrorEvents = EPL_DLL_ERR_INVALID_FORMAT;
-                    DllEvent.m_uiNodeId = uiNodeId;
-                    DllEvent.m_NmtState = NmtState;
-                    Event.m_EventSink = kEplEventSinkErrk;
-                    Event.m_EventType = kEplEventTypeDllError;
-                    Event.m_NetTime = FrameInfo.m_NetTime;
-                    Event.m_uiSize = sizeof (DllEvent);
-                    Event.m_pArg = &DllEvent;
-                    Ret = EplEventkPost(&Event);
-                    break;
-                }
-                if ((NmtState != kEplNmtCsOperational)
-                    && (NmtState != kEplNmtMsOperational))
-                {
-                    // reset RD flag and all other flags, but that does not matter, because they were processed above
-                    AmiSetByteToLe(&pFrame->m_Data.m_Pres.m_le_bFlag1, 0);
-                }
-                Ret = EplPdokCbPdoReceived(&FrameInfo);
-            }
-#endif
-
-            break;
-        }
-
-        case kEplMsgTypeSoc:
-        {
-            // SoC frame
-            NmtEvent = kEplNmtEventDllCeSoc;
-
-            if (NmtState >= kEplNmtMsNotActive)
-            {   // MN is active -> wrong msg type
-                break;
-            }
-
+				    ||
+				    (AmiGetWordFromLe
+				     (&pFrame->m_Data.m_Pres.m_le_wSize) >
+				     pIntNodeInfo->m_wPresPayloadLimit)
+#endif
+				    ) {	// format error
+					tEplErrorHandlerkEvent DllEvent;
+
+					DllEvent.m_ulDllErrorEvents =
+					    EPL_DLL_ERR_INVALID_FORMAT;
+					DllEvent.m_uiNodeId = uiNodeId;
+					DllEvent.m_NmtState = NmtState;
+					Event.m_EventSink = kEplEventSinkErrk;
+					Event.m_EventType =
+					    kEplEventTypeDllError;
+					Event.m_NetTime = FrameInfo.m_NetTime;
+					Event.m_uiSize = sizeof(DllEvent);
+					Event.m_pArg = &DllEvent;
+					Ret = EplEventkPost(&Event);
+					break;
+				}
+				if ((NmtState != kEplNmtCsOperational)
+				    && (NmtState != kEplNmtMsOperational)) {
+					// reset RD flag and all other flags, but that does not matter, because they were processed above
+					AmiSetByteToLe(&pFrame->m_Data.m_Pres.
+						       m_le_bFlag1, 0);
+				}
+				Ret = EplPdokCbPdoReceived(&FrameInfo);
+			}
+#endif
+
+			break;
+		}
+
+	case kEplMsgTypeSoc:
+		{
+			// SoC frame
+			NmtEvent = kEplNmtEventDllCeSoc;
+
+			if (NmtState >= kEplNmtMsNotActive) {	// MN is active -> wrong msg type
+				break;
+			}
 #if EPL_DLL_PRES_READY_AFTER_SOC != FALSE
-            // post PRes to transmit FIFO of the ethernet controller, but don't start
-            // transmission over bus
-            pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES];
-            // Does PRes exist?
-            if (pTxBuffer->m_pbBuffer != NULL)
-            {   // PRes does exist
-                pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
-                // update frame (NMT state, RD, RS, PR, MS, EN flags)
-                if (NmtState < kEplNmtCsPreOperational2)
-                {   // NMT state is not PreOp2, ReadyToOp or Op
-                    // fake NMT state PreOp2, because PRes will be sent only in PreOp2 or greater
-                    NmtState = kEplNmtCsPreOperational2;
-                }
-                AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bNmtStatus, (BYTE) NmtState);
-                AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag2, EplDllkInstance_g.m_bFlag2);
-                if (NmtState != kEplNmtCsOperational)
-                {   // mark PDO as invalid in NMT state Op
-                    // $$$ reset only RD flag; set other flags appropriately
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bFlag1, 0);
-                }
-                // $$$ make function that updates Pres, StatusRes
-                // mark PRes frame as ready for transmission
-                Ret = EdrvTxMsgReady(pTxBuffer);
-            }
-#endif
-
-            if (NmtState >= kEplNmtCsPreOperational2)
-            {   // SoC frames only in PreOp2, ReadyToOp and Op
-                // trigger synchronous task
-                Event.m_EventSink = kEplEventSinkSync;
-                Event.m_EventType = kEplEventTypeSync;
-                Event.m_uiSize = 0;
-                Ret = EplEventkPost(&Event);
-
-                // update cycle counter
-                if (EplDllkInstance_g.m_DllConfigParam.m_uiMultiplCycleCnt > 0)
-                {   // multiplexed cycle active
-                    EplDllkInstance_g.m_uiCycleCount = (EplDllkInstance_g.m_uiCycleCount + 1) % EplDllkInstance_g.m_DllConfigParam.m_uiMultiplCycleCnt;
-                }
-            }
-
-            // reprogram timer
+			// post PRes to transmit FIFO of the ethernet controller, but don't start
+			// transmission over bus
+			pTxBuffer =
+			    &EplDllkInstance_g.
+			    m_pTxBuffer[EPL_DLLK_TXFRAME_PRES];
+			// Does PRes exist?
+			if (pTxBuffer->m_pbBuffer != NULL) {	// PRes does exist
+				pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
+				// update frame (NMT state, RD, RS, PR, MS, EN flags)
+				if (NmtState < kEplNmtCsPreOperational2) {	// NMT state is not PreOp2, ReadyToOp or Op
+					// fake NMT state PreOp2, because PRes will be sent only in PreOp2 or greater
+					NmtState = kEplNmtCsPreOperational2;
+				}
+				AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
+					       m_le_bNmtStatus,
+					       (BYTE) NmtState);
+				AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
+					       m_le_bFlag2,
+					       EplDllkInstance_g.m_bFlag2);
+				if (NmtState != kEplNmtCsOperational) {	// mark PDO as invalid in NMT state Op
+					// $$$ reset only RD flag; set other flags appropriately
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.
+						       m_le_bFlag1, 0);
+				}
+				// $$$ make function that updates Pres, StatusRes
+				// mark PRes frame as ready for transmission
+				Ret = EdrvTxMsgReady(pTxBuffer);
+			}
+#endif
+
+			if (NmtState >= kEplNmtCsPreOperational2) {	// SoC frames only in PreOp2, ReadyToOp and Op
+				// trigger synchronous task
+				Event.m_EventSink = kEplEventSinkSync;
+				Event.m_EventType = kEplEventTypeSync;
+				Event.m_uiSize = 0;
+				Ret = EplEventkPost(&Event);
+
+				// update cycle counter
+				if (EplDllkInstance_g.m_DllConfigParam.m_uiMultiplCycleCnt > 0) {	// multiplexed cycle active
+					EplDllkInstance_g.m_uiCycleCount =
+					    (EplDllkInstance_g.m_uiCycleCount +
+					     1) %
+					    EplDllkInstance_g.m_DllConfigParam.
+					    m_uiMultiplCycleCnt;
+				}
+			}
+			// reprogram timer
 #if EPL_TIMER_USE_HIGHRES != FALSE
-            if (EplDllkInstance_g.m_ullFrameTimeout != 0)
-            {
-                Ret = EplTimerHighReskModifyTimerNs(&EplDllkInstance_g.m_TimerHdlCycle, EplDllkInstance_g.m_ullFrameTimeout, EplDllkCbCnTimer, 0L, FALSE);
-            }
-#endif
-
-            break;
-        }
-
-        case kEplMsgTypeSoa:
-        {
-            // SoA frame
-            NmtEvent = kEplNmtEventDllCeSoa;
-
-            if (NmtState >= kEplNmtMsNotActive)
-            {   // MN is active -> wrong msg type
-                break;
-            }
-
-            pTxFrame = NULL;
-
-            if ((NmtState & EPL_NMT_SUPERSTATE_MASK) != EPL_NMT_CS_EPLMODE)
-            {   // do not respond, if NMT state is < PreOp1 (i.e. not EPL_MODE)
-                break;
-            }
-
-            // check TargetNodeId
-            uiNodeId = AmiGetByteFromLe(&pFrame->m_Data.m_Soa.m_le_bReqServiceTarget);
-            if (uiNodeId == EplDllkInstance_g.m_DllConfigParam.m_uiNodeId)
-            {   // local node is the target of the current request
-
-                // check ServiceId
-                ReqServiceId = (tEplDllReqServiceId) AmiGetByteFromLe(&pFrame->m_Data.m_Soa.m_le_bReqServiceId);
-                if (ReqServiceId == kEplDllReqServiceStatus)
-                {   // StatusRequest
-                    if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_STATUSRES].m_pbBuffer != NULL)
-                    {   // StatusRes does exist
-
-                        pTxFrame = (tEplFrame *) EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_STATUSRES].m_pbBuffer;
-                        // update StatusRes frame (NMT state, EN, EC, RS, PR flags)
-                        AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_StatusResponse.m_le_bNmtStatus, (BYTE) NmtState);
-                        AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_StatusResponse.m_le_bFlag1, EplDllkInstance_g.m_bFlag1);
-                        AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_StatusResponse.m_le_bFlag2, EplDllkInstance_g.m_bFlag2);
-                        // send StatusRes
-                        Ret = EdrvSendTxMsg(&EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_STATUSRES]);
-                        if (Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        TGT_DBG_SIGNAL_TRACE_POINT(8);
-
-                        // update error signaling
-                        bFlag1 = AmiGetByteFromLe(&pFrame->m_Data.m_Soa.m_le_bFlag1);
-                        if (((bFlag1 ^ EplDllkInstance_g.m_bMnFlag1) & EPL_FRAME_FLAG1_ER) != 0)
-                        {   // exception reset flag was changed by MN
-                            // assume same state for EC in next cycle (clear all other bits)
-                            if ((bFlag1 & EPL_FRAME_FLAG1_ER) != 0)
-                            {
-                                // set EC and reset rest
-                                EplDllkInstance_g.m_bFlag1 = EPL_FRAME_FLAG1_EC;
-                            }
-                            else
-                            {
-                                // reset complete flag 1 (including EC and EN)
-                                EplDllkInstance_g.m_bFlag1 = 0;
-                            }
-                        }
-                        // save flag 1 from MN for Status request response cycle
-                        EplDllkInstance_g.m_bMnFlag1 = bFlag1;
-                    }
-                }
-                else if (ReqServiceId == kEplDllReqServiceIdent)
-                {   // IdentRequest
-                    if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_IDENTRES].m_pbBuffer != NULL)
-                    {   // IdentRes does exist
-                        pTxFrame = (tEplFrame *) EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_IDENTRES].m_pbBuffer;
-                        // update IdentRes frame (NMT state, RS, PR flags)
-                        AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_bNmtStatus, (BYTE) NmtState);
-                        AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_bFlag2, EplDllkInstance_g.m_bFlag2);
-                        // send IdentRes
-                        Ret = EdrvSendTxMsg(&EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_IDENTRES]);
-                        if (Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        TGT_DBG_SIGNAL_TRACE_POINT(7);
-                    }
-                }
-                else if (ReqServiceId == kEplDllReqServiceNmtRequest)
-                {   // NmtRequest
-                    if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_pbBuffer != NULL)
-                    {   // NmtRequest does exist
-                        // check if frame is not empty and not being filled
-                        if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen > EPL_DLLK_BUFLEN_FILLING)
-                        {
-                            /*if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen < EPL_DLLK_BUFLEN_MIN)
-                            {   // pad frame
-                                EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen = EPL_DLLK_BUFLEN_MIN;
-                            }*/
-                            // memorize transmission
-                            pTxFrame = (tEplFrame*)1;
-                            // send NmtRequest
-                            Ret = EdrvSendTxMsg(&EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ]);
-                            if (Ret != kEplSuccessful)
-                            {
-                                goto Exit;
-                            }
-
-                        }
-                    }
-
-                }
-                else if (ReqServiceId == kEplDllReqServiceUnspecified)
-                {   // unspecified invite
-                    if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL].m_pbBuffer != NULL)
-                    {   // non-EPL frame does exist
-                        // check if frame is not empty and not being filled
-                        if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL].m_uiTxMsgLen > EPL_DLLK_BUFLEN_FILLING)
-                        {
-                            /*if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen < EPL_DLLK_BUFLEN_MIN)
-                            {   // pad frame
-                                EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen = EPL_DLLK_BUFLEN_MIN;
-                            }*/
-                            // memorize transmission
-                            pTxFrame = (tEplFrame*)1;
-                            // send non-EPL frame
-                            Ret = EdrvSendTxMsg(&EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL]);
-                            if (Ret != kEplSuccessful)
-                            {
-                                goto Exit;
-                            }
-
-                        }
-                    }
-
-                }
-                else if (ReqServiceId == kEplDllReqServiceNo)
-                {   // no async service requested -> do nothing
-                }
-            }
-
+			if (EplDllkInstance_g.m_ullFrameTimeout != 0) {
+				Ret =
+				    EplTimerHighReskModifyTimerNs
+				    (&EplDllkInstance_g.m_TimerHdlCycle,
+				     EplDllkInstance_g.m_ullFrameTimeout,
+				     EplDllkCbCnTimer, 0L, FALSE);
+			}
+#endif
+
+			break;
+		}
+
+	case kEplMsgTypeSoa:
+		{
+			// SoA frame
+			NmtEvent = kEplNmtEventDllCeSoa;
+
+			if (NmtState >= kEplNmtMsNotActive) {	// MN is active -> wrong msg type
+				break;
+			}
+
+			pTxFrame = NULL;
+
+			if ((NmtState & EPL_NMT_SUPERSTATE_MASK) != EPL_NMT_CS_EPLMODE) {	// do not respond, if NMT state is < PreOp1 (i.e. not EPL_MODE)
+				break;
+			}
+			// check TargetNodeId
+			uiNodeId =
+			    AmiGetByteFromLe(&pFrame->m_Data.m_Soa.
+					     m_le_bReqServiceTarget);
+			if (uiNodeId == EplDllkInstance_g.m_DllConfigParam.m_uiNodeId) {	// local node is the target of the current request
+
+				// check ServiceId
+				ReqServiceId =
+				    (tEplDllReqServiceId)
+				    AmiGetByteFromLe(&pFrame->m_Data.m_Soa.
+						     m_le_bReqServiceId);
+				if (ReqServiceId == kEplDllReqServiceStatus) {	// StatusRequest
+					if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_STATUSRES].m_pbBuffer != NULL) {	// StatusRes does exist
+
+						pTxFrame =
+						    (tEplFrame *)
+						    EplDllkInstance_g.
+						    m_pTxBuffer
+						    [EPL_DLLK_TXFRAME_STATUSRES].
+						    m_pbBuffer;
+						// update StatusRes frame (NMT state, EN, EC, RS, PR flags)
+						AmiSetByteToLe(&pTxFrame->
+							       m_Data.m_Asnd.
+							       m_Payload.
+							       m_StatusResponse.
+							       m_le_bNmtStatus,
+							       (BYTE) NmtState);
+						AmiSetByteToLe(&pTxFrame->
+							       m_Data.m_Asnd.
+							       m_Payload.
+							       m_StatusResponse.
+							       m_le_bFlag1,
+							       EplDllkInstance_g.
+							       m_bFlag1);
+						AmiSetByteToLe(&pTxFrame->
+							       m_Data.m_Asnd.
+							       m_Payload.
+							       m_StatusResponse.
+							       m_le_bFlag2,
+							       EplDllkInstance_g.
+							       m_bFlag2);
+						// send StatusRes
+						Ret =
+						    EdrvSendTxMsg
+						    (&EplDllkInstance_g.
+						     m_pTxBuffer
+						     [EPL_DLLK_TXFRAME_STATUSRES]);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						TGT_DBG_SIGNAL_TRACE_POINT(8);
+
+						// update error signaling
+						bFlag1 =
+						    AmiGetByteFromLe(&pFrame->
+								     m_Data.
+								     m_Soa.
+								     m_le_bFlag1);
+						if (((bFlag1 ^ EplDllkInstance_g.m_bMnFlag1) & EPL_FRAME_FLAG1_ER) != 0) {	// exception reset flag was changed by MN
+							// assume same state for EC in next cycle (clear all other bits)
+							if ((bFlag1 &
+							     EPL_FRAME_FLAG1_ER)
+							    != 0) {
+								// set EC and reset rest
+								EplDllkInstance_g.
+								    m_bFlag1 =
+								    EPL_FRAME_FLAG1_EC;
+							} else {
+								// reset complete flag 1 (including EC and EN)
+								EplDllkInstance_g.
+								    m_bFlag1 =
+								    0;
+							}
+						}
+						// save flag 1 from MN for Status request response cycle
+						EplDllkInstance_g.m_bMnFlag1 =
+						    bFlag1;
+					}
+				} else if (ReqServiceId == kEplDllReqServiceIdent) {	// IdentRequest
+					if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_IDENTRES].m_pbBuffer != NULL) {	// IdentRes does exist
+						pTxFrame =
+						    (tEplFrame *)
+						    EplDllkInstance_g.
+						    m_pTxBuffer
+						    [EPL_DLLK_TXFRAME_IDENTRES].
+						    m_pbBuffer;
+						// update IdentRes frame (NMT state, RS, PR flags)
+						AmiSetByteToLe(&pTxFrame->
+							       m_Data.m_Asnd.
+							       m_Payload.
+							       m_IdentResponse.
+							       m_le_bNmtStatus,
+							       (BYTE) NmtState);
+						AmiSetByteToLe(&pTxFrame->
+							       m_Data.m_Asnd.
+							       m_Payload.
+							       m_IdentResponse.
+							       m_le_bFlag2,
+							       EplDllkInstance_g.
+							       m_bFlag2);
+						// send IdentRes
+						Ret =
+						    EdrvSendTxMsg
+						    (&EplDllkInstance_g.
+						     m_pTxBuffer
+						     [EPL_DLLK_TXFRAME_IDENTRES]);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						TGT_DBG_SIGNAL_TRACE_POINT(7);
+					}
+				} else if (ReqServiceId == kEplDllReqServiceNmtRequest) {	// NmtRequest
+					if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_pbBuffer != NULL) {	// NmtRequest does exist
+						// check if frame is not empty and not being filled
+						if (EplDllkInstance_g.
+						    m_pTxBuffer
+						    [EPL_DLLK_TXFRAME_NMTREQ].
+						    m_uiTxMsgLen >
+						    EPL_DLLK_BUFLEN_FILLING) {
+							/*if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen < EPL_DLLK_BUFLEN_MIN)
+							   {   // pad frame
+							   EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen = EPL_DLLK_BUFLEN_MIN;
+							   } */
+							// memorize transmission
+							pTxFrame =
+							    (tEplFrame *) 1;
+							// send NmtRequest
+							Ret =
+							    EdrvSendTxMsg
+							    (&EplDllkInstance_g.
+							     m_pTxBuffer
+							     [EPL_DLLK_TXFRAME_NMTREQ]);
+							if (Ret !=
+							    kEplSuccessful) {
+								goto Exit;
+							}
+
+						}
+					}
+
+				} else if (ReqServiceId == kEplDllReqServiceUnspecified) {	// unspecified invite
+					if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL].m_pbBuffer != NULL) {	// non-EPL frame does exist
+						// check if frame is not empty and not being filled
+						if (EplDllkInstance_g.
+						    m_pTxBuffer
+						    [EPL_DLLK_TXFRAME_NONEPL].
+						    m_uiTxMsgLen >
+						    EPL_DLLK_BUFLEN_FILLING) {
+							/*if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen < EPL_DLLK_BUFLEN_MIN)
+							   {   // pad frame
+							   EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen = EPL_DLLK_BUFLEN_MIN;
+							   } */
+							// memorize transmission
+							pTxFrame =
+							    (tEplFrame *) 1;
+							// send non-EPL frame
+							Ret =
+							    EdrvSendTxMsg
+							    (&EplDllkInstance_g.
+							     m_pTxBuffer
+							     [EPL_DLLK_TXFRAME_NONEPL]);
+							if (Ret !=
+							    kEplSuccessful) {
+								goto Exit;
+							}
+
+						}
+					}
+
+				} else if (ReqServiceId == kEplDllReqServiceNo) {	// no async service requested -> do nothing
+				}
+			}
 #if EPL_DLL_PRES_READY_AFTER_SOA != FALSE
-            if (pTxFrame == NULL)
-            {   // signal process function readiness of PRes frame
-                Event.m_EventSink = kEplEventSinkDllk;
-                Event.m_EventType = kEplEventTypeDllkPresReady;
-                Event.m_uiSize = 0;
-                Event.m_pArg = NULL;
-                Ret = EplEventkPost(&Event);
-            }
+			if (pTxFrame == NULL) {	// signal process function readiness of PRes frame
+				Event.m_EventSink = kEplEventSinkDllk;
+				Event.m_EventType = kEplEventTypeDllkPresReady;
+				Event.m_uiSize = 0;
+				Event.m_pArg = NULL;
+				Ret = EplEventkPost(&Event);
+			}
 #endif
 
-            // inform PDO module
+			// inform PDO module
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
 //            Ret = EplPdokCbSoa(&FrameInfo);
 #endif
 
-            // $$$ put SrcNodeId, NMT state and NetTime as HeartbeatEvent into eventqueue
-
-            // $$$ inform emergency protocol handling about flags
-            break;
-        }
+			// $$$ put SrcNodeId, NMT state and NetTime as HeartbeatEvent into eventqueue
 
-        case kEplMsgTypeAsnd:
-        {
-            // ASnd frame
-            NmtEvent = kEplNmtEventDllCeAsnd;
-
-            // ASnd service registered?
-            uiAsndServiceId = (unsigned int) AmiGetByteFromLe(&pFrame->m_Data.m_Asnd.m_le_bServiceId);
+			// $$$ inform emergency protocol handling about flags
+			break;
+		}
+
+	case kEplMsgTypeAsnd:
+		{
+			// ASnd frame
+			NmtEvent = kEplNmtEventDllCeAsnd;
+
+			// ASnd service registered?
+			uiAsndServiceId =
+			    (unsigned int)AmiGetByteFromLe(&pFrame->m_Data.
+							   m_Asnd.
+							   m_le_bServiceId);
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-            if ((EplDllkInstance_g.m_DllState >= kEplDllMsNonCyclic)
-                && ((((tEplDllAsndServiceId) uiAsndServiceId) == kEplDllAsndStatusResponse)
-                || (((tEplDllAsndServiceId) uiAsndServiceId) == kEplDllAsndIdentResponse)))
-            {   // StatusRes or IdentRes received
-                uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bSrcNodeId);
-                if ((EplDllkInstance_g.m_LastReqServiceId == ((tEplDllReqServiceId) uiAsndServiceId))
-                    && (uiNodeId == EplDllkInstance_g.m_uiLastTargetNodeId))
-                {   // mark request as responded
-                    EplDllkInstance_g.m_LastReqServiceId = kEplDllReqServiceNo;
-                }
-                if (((tEplDllAsndServiceId) uiAsndServiceId) == kEplDllAsndIdentResponse)
-                {   // memorize MAC address of CN for PReq
-                tEplDllkNodeInfo*   pIntNodeInfo;
-
-                    pIntNodeInfo = EplDllkGetNodeInfo(uiNodeId);
-                    if (pIntNodeInfo == NULL)
-                    {   // no node info structure available
-                        Ret = kEplDllNoNodeInfo;
-                    }
-                    else
-                    {
-                        EPL_MEMCPY(pIntNodeInfo->m_be_abMacAddr, pFrame->m_be_abSrcMac, 6);
-                    }
-                }
-
-                // forward Flag2 to asynchronous scheduler
-                bFlag1 = AmiGetByteFromLe(&pFrame->m_Data.m_Asnd.m_Payload.m_StatusResponse.m_le_bFlag2);
-                Ret = EplDllkCalAsyncSetPendingRequests(uiNodeId,
-                    ((tEplDllAsyncReqPriority) ((bFlag1 & EPL_FRAME_FLAG2_PR) >> EPL_FRAME_FLAG2_PR_SHIFT)),
-                    (bFlag1 & EPL_FRAME_FLAG2_RS));
-            }
-#endif
-
-            if (uiAsndServiceId < EPL_DLL_MAX_ASND_SERVICE_ID)
-            {   // ASnd service ID is valid
-                if (EplDllkInstance_g.m_aAsndFilter[uiAsndServiceId] == kEplDllAsndFilterAny)
-                {   // ASnd service ID is registered
-                    // forward frame via async receive FIFO to userspace
-                    Ret = EplDllkCalAsyncFrameReceived(&FrameInfo);
-                }
-                else if (EplDllkInstance_g.m_aAsndFilter[uiAsndServiceId] == kEplDllAsndFilterLocal)
-                {   // ASnd service ID is registered, but only local node ID or broadcasts
-                    // shall be forwarded
-                    uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bDstNodeId);
-                    if ((uiNodeId == EplDllkInstance_g.m_DllConfigParam.m_uiNodeId)
-                        || (uiNodeId == EPL_C_ADR_BROADCAST))
-                    {   // ASnd frame is intended for us
-                        // forward frame via async receive FIFO to userspace
-                        Ret = EplDllkCalAsyncFrameReceived(&FrameInfo);
-                    }
-                }
-            }
-            break;
-        }
-
-        default:
-        {
-            break;
-        }
-    }
-
-    if (NmtEvent != kEplNmtEventNoEvent)
-    {   // event for DLL and NMT state machine generated
-        Ret = EplDllkChangeState(NmtEvent, NmtState);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        if ((NmtEvent != kEplNmtEventDllCeAsnd)
-            && ((NmtState <= kEplNmtCsPreOperational1) || (NmtEvent != kEplNmtEventDllCePres)))
-        {   // NMT state machine is not interested in ASnd frames and PRes frames when not CsNotActive or CsPreOp1
-            // inform NMT module
-            Event.m_EventSink = kEplEventSinkNmtk;
-            Event.m_EventType = kEplEventTypeNmtEvent;
-            Event.m_uiSize = sizeof (NmtEvent);
-            Event.m_pArg = &NmtEvent;
-            Ret = EplEventkPost(&Event);
-        }
-    }
-
-Exit:
-    if (Ret != kEplSuccessful)
-    {
-    DWORD   dwArg;
-
-        BENCHMARK_MOD_02_TOGGLE(9);
-
-        dwArg = EplDllkInstance_g.m_DllState | (NmtEvent << 8);
-
-        // Error event for API layer
-        Ret = EplEventkPostError(kEplEventSourceDllk,
-                        Ret,
-                        sizeof(dwArg),
-                        &dwArg);
-    }
-    BENCHMARK_MOD_02_RESET(3);
-    return;
+			if ((EplDllkInstance_g.m_DllState >= kEplDllMsNonCyclic)
+			    &&
+			    ((((tEplDllAsndServiceId) uiAsndServiceId) ==
+			      kEplDllAsndStatusResponse)
+			     || (((tEplDllAsndServiceId) uiAsndServiceId) == kEplDllAsndIdentResponse))) {	// StatusRes or IdentRes received
+				uiNodeId =
+				    AmiGetByteFromLe(&pFrame->m_le_bSrcNodeId);
+				if ((EplDllkInstance_g.m_LastReqServiceId ==
+				     ((tEplDllReqServiceId) uiAsndServiceId))
+				    && (uiNodeId == EplDllkInstance_g.m_uiLastTargetNodeId)) {	// mark request as responded
+					EplDllkInstance_g.m_LastReqServiceId =
+					    kEplDllReqServiceNo;
+				}
+				if (((tEplDllAsndServiceId) uiAsndServiceId) == kEplDllAsndIdentResponse) {	// memorize MAC address of CN for PReq
+					tEplDllkNodeInfo *pIntNodeInfo;
+
+					pIntNodeInfo =
+					    EplDllkGetNodeInfo(uiNodeId);
+					if (pIntNodeInfo == NULL) {	// no node info structure available
+						Ret = kEplDllNoNodeInfo;
+					} else {
+						EPL_MEMCPY(pIntNodeInfo->
+							   m_be_abMacAddr,
+							   pFrame->
+							   m_be_abSrcMac, 6);
+					}
+				}
+				// forward Flag2 to asynchronous scheduler
+				bFlag1 =
+				    AmiGetByteFromLe(&pFrame->m_Data.m_Asnd.
+						     m_Payload.m_StatusResponse.
+						     m_le_bFlag2);
+				Ret =
+				    EplDllkCalAsyncSetPendingRequests(uiNodeId,
+								      ((tEplDllAsyncReqPriority) ((bFlag1 & EPL_FRAME_FLAG2_PR) >> EPL_FRAME_FLAG2_PR_SHIFT)), (bFlag1 & EPL_FRAME_FLAG2_RS));
+			}
+#endif
+
+			if (uiAsndServiceId < EPL_DLL_MAX_ASND_SERVICE_ID) {	// ASnd service ID is valid
+				if (EplDllkInstance_g.m_aAsndFilter[uiAsndServiceId] == kEplDllAsndFilterAny) {	// ASnd service ID is registered
+					// forward frame via async receive FIFO to userspace
+					Ret =
+					    EplDllkCalAsyncFrameReceived
+					    (&FrameInfo);
+				} else if (EplDllkInstance_g.m_aAsndFilter[uiAsndServiceId] == kEplDllAsndFilterLocal) {	// ASnd service ID is registered, but only local node ID or broadcasts
+					// shall be forwarded
+					uiNodeId =
+					    AmiGetByteFromLe(&pFrame->
+							     m_le_bDstNodeId);
+					if ((uiNodeId ==
+					     EplDllkInstance_g.m_DllConfigParam.
+					     m_uiNodeId)
+					    || (uiNodeId == EPL_C_ADR_BROADCAST)) {	// ASnd frame is intended for us
+						// forward frame via async receive FIFO to userspace
+						Ret =
+						    EplDllkCalAsyncFrameReceived
+						    (&FrameInfo);
+					}
+				}
+			}
+			break;
+		}
+
+	default:
+		{
+			break;
+		}
+	}
+
+	if (NmtEvent != kEplNmtEventNoEvent) {	// event for DLL and NMT state machine generated
+		Ret = EplDllkChangeState(NmtEvent, NmtState);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+
+		if ((NmtEvent != kEplNmtEventDllCeAsnd)
+		    && ((NmtState <= kEplNmtCsPreOperational1) || (NmtEvent != kEplNmtEventDllCePres))) {	// NMT state machine is not interested in ASnd frames and PRes frames when not CsNotActive or CsPreOp1
+			// inform NMT module
+			Event.m_EventSink = kEplEventSinkNmtk;
+			Event.m_EventType = kEplEventTypeNmtEvent;
+			Event.m_uiSize = sizeof(NmtEvent);
+			Event.m_pArg = &NmtEvent;
+			Ret = EplEventkPost(&Event);
+		}
+	}
+
+      Exit:
+	if (Ret != kEplSuccessful) {
+		DWORD dwArg;
+
+		BENCHMARK_MOD_02_TOGGLE(9);
+
+		dwArg = EplDllkInstance_g.m_DllState | (NmtEvent << 8);
+
+		// Error event for API layer
+		Ret = EplEventkPostError(kEplEventSourceDllk,
+					 Ret, sizeof(dwArg), &dwArg);
+	}
+	BENCHMARK_MOD_02_RESET(3);
+	return;
 }
 
 //---------------------------------------------------------------------------
@@ -2947,235 +3187,282 @@ Exit:
 
 static void EplDllkCbFrameTransmitted(tEdrvTxBuffer * pTxBuffer_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplEvent       Event;
-tEplDllAsyncReqPriority Priority;
-tEplNmtState    NmtState;
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
+	tEplDllAsyncReqPriority Priority;
+	tEplNmtState NmtState;
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0) \
     && (EPL_DLL_PRES_READY_AFTER_SOC == FALSE)
-tEplFrameInfo   FrameInfo;
+	tEplFrameInfo FrameInfo;
 #endif
 
-    NmtState = EplNmtkGetNmtState();
-
-    if (NmtState <= kEplNmtGsResetConfiguration)
-    {
-        goto Exit;
-    }
+	NmtState = EplNmtkGetNmtState();
 
-    if ((pTxBuffer_p - EplDllkInstance_g.m_pTxBuffer) == EPL_DLLK_TXFRAME_NMTREQ)
-    {   // frame from NMT request FIFO sent
-        // mark Tx-buffer as empty
-        pTxBuffer_p->m_uiTxMsgLen = EPL_DLLK_BUFLEN_EMPTY;
-
-        // post event to DLL
-        Priority = kEplDllAsyncReqPrioNmt;
-        Event.m_EventSink = kEplEventSinkDllk;
-        Event.m_EventType = kEplEventTypeDllkFillTx;
-        EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
-        Event.m_pArg = &Priority;
-        Event.m_uiSize = sizeof(Priority);
-        Ret = EplEventkPost(&Event);
-    }
-    else if ((pTxBuffer_p - EplDllkInstance_g.m_pTxBuffer) == EPL_DLLK_TXFRAME_NONEPL)
-    {   // frame from generic priority FIFO sent
-        // mark Tx-buffer as empty
-        pTxBuffer_p->m_uiTxMsgLen = EPL_DLLK_BUFLEN_EMPTY;
-
-        // post event to DLL
-        Priority = kEplDllAsyncReqPrioGeneric;
-        Event.m_EventSink = kEplEventSinkDllk;
-        Event.m_EventType = kEplEventTypeDllkFillTx;
-        EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
-        Event.m_pArg = &Priority;
-        Event.m_uiSize = sizeof(Priority);
-        Ret = EplEventkPost(&Event);
-    }
+	if (NmtState <= kEplNmtGsResetConfiguration) {
+		goto Exit;
+	}
+
+	if ((pTxBuffer_p - EplDllkInstance_g.m_pTxBuffer) == EPL_DLLK_TXFRAME_NMTREQ) {	// frame from NMT request FIFO sent
+		// mark Tx-buffer as empty
+		pTxBuffer_p->m_uiTxMsgLen = EPL_DLLK_BUFLEN_EMPTY;
+
+		// post event to DLL
+		Priority = kEplDllAsyncReqPrioNmt;
+		Event.m_EventSink = kEplEventSinkDllk;
+		Event.m_EventType = kEplEventTypeDllkFillTx;
+		EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
+		Event.m_pArg = &Priority;
+		Event.m_uiSize = sizeof(Priority);
+		Ret = EplEventkPost(&Event);
+	} else if ((pTxBuffer_p - EplDllkInstance_g.m_pTxBuffer) == EPL_DLLK_TXFRAME_NONEPL) {	// frame from generic priority FIFO sent
+		// mark Tx-buffer as empty
+		pTxBuffer_p->m_uiTxMsgLen = EPL_DLLK_BUFLEN_EMPTY;
+
+		// post event to DLL
+		Priority = kEplDllAsyncReqPrioGeneric;
+		Event.m_EventSink = kEplEventSinkDllk;
+		Event.m_EventType = kEplEventTypeDllkFillTx;
+		EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
+		Event.m_pArg = &Priority;
+		Event.m_uiSize = sizeof(Priority);
+		Ret = EplEventkPost(&Event);
+	}
 #if ((((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0) \
     && (EPL_DLL_PRES_READY_AFTER_SOC == FALSE)) \
     || (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    else if ((pTxBuffer_p->m_EplMsgType == kEplMsgTypePreq)
-        || (pTxBuffer_p->m_EplMsgType == kEplMsgTypePres))
-    {   // PRes resp. PReq frame sent
+	else if ((pTxBuffer_p->m_EplMsgType == kEplMsgTypePreq)
+		 || (pTxBuffer_p->m_EplMsgType == kEplMsgTypePres)) {	// PRes resp. PReq frame sent
 
-        #if ((((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0) \
+#if ((((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0) \
             && (EPL_DLL_PRES_READY_AFTER_SOC == FALSE))
-        {
-            // inform PDO module
-            FrameInfo.m_pFrame = (tEplFrame *) pTxBuffer_p->m_pbBuffer;
-            FrameInfo.m_uiFrameSize = pTxBuffer_p->m_uiMaxBufferLen;
-            Ret = EplPdokCbPdoTransmitted(&FrameInfo);
-        }
-        #endif
+		{
+			// inform PDO module
+			FrameInfo.m_pFrame =
+			    (tEplFrame *) pTxBuffer_p->m_pbBuffer;
+			FrameInfo.m_uiFrameSize = pTxBuffer_p->m_uiMaxBufferLen;
+			Ret = EplPdokCbPdoTransmitted(&FrameInfo);
+		}
+#endif
 
-        #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-        {
-            // if own Pres on MN, trigger SoA
-            if ((NmtState >= kEplNmtMsPreOperational2)
-                && (pTxBuffer_p == &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES]))
-            {
-                Ret = EplDllkChangeState(kEplNmtEventDllMeSoaTrig, NmtState);
-            }
-        }
-        #endif
+#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
+		{
+			// if own Pres on MN, trigger SoA
+			if ((NmtState >= kEplNmtMsPreOperational2)
+			    && (pTxBuffer_p ==
+				&EplDllkInstance_g.
+				m_pTxBuffer[EPL_DLLK_TXFRAME_PRES])) {
+				Ret =
+				    EplDllkChangeState(kEplNmtEventDllMeSoaTrig,
+						       NmtState);
+			}
+		}
+#endif
 
-    #if EPL_DLL_PRES_READY_AFTER_SOA != FALSE
-        goto Exit;
-    #endif
-    }
+#if EPL_DLL_PRES_READY_AFTER_SOA != FALSE
+		goto Exit;
+#endif
+	}
 #endif
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    else if (pTxBuffer_p->m_EplMsgType == kEplMsgTypeSoa)
-    {   // SoA frame sent
-    tEplNmtEvent NmtEvent = kEplNmtEventDllMeSoaSent;
-
-        // check if we are invited
-        if (EplDllkInstance_g.m_uiLastTargetNodeId == EplDllkInstance_g.m_DllConfigParam.m_uiNodeId)
-        {
-        tEplFrame      *pTxFrame;
+	else if (pTxBuffer_p->m_EplMsgType == kEplMsgTypeSoa) {	// SoA frame sent
+		tEplNmtEvent NmtEvent = kEplNmtEventDllMeSoaSent;
 
-            if (EplDllkInstance_g.m_LastReqServiceId == kEplDllReqServiceStatus)
-            {   // StatusRequest
-                if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_STATUSRES].m_pbBuffer != NULL)
-                {   // StatusRes does exist
-
-                    pTxFrame = (tEplFrame *) EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_STATUSRES].m_pbBuffer;
-                    // update StatusRes frame (NMT state, EN, EC, RS, PR flags)
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_StatusResponse.m_le_bNmtStatus, (BYTE) NmtState);
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_StatusResponse.m_le_bFlag1, EplDllkInstance_g.m_bFlag1);
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_StatusResponse.m_le_bFlag2, EplDllkInstance_g.m_bFlag2);
-                    // send StatusRes
-                    Ret = EdrvSendTxMsg(&EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_STATUSRES]);
-                    if (Ret != kEplSuccessful)
-                    {
-                        goto Exit;
-                    }
-                    TGT_DBG_SIGNAL_TRACE_POINT(8);
-
-                }
-            }
-            else if (EplDllkInstance_g.m_LastReqServiceId == kEplDllReqServiceIdent)
-            {   // IdentRequest
-                if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_IDENTRES].m_pbBuffer != NULL)
-                {   // IdentRes does exist
-                    pTxFrame = (tEplFrame *) EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_IDENTRES].m_pbBuffer;
-                    // update IdentRes frame (NMT state, RS, PR flags)
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_bNmtStatus, (BYTE) NmtState);
-                    AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse.m_le_bFlag2, EplDllkInstance_g.m_bFlag2);
-                    // send IdentRes
-                    Ret = EdrvSendTxMsg(&EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_IDENTRES]);
-                    if (Ret != kEplSuccessful)
-                    {
-                        goto Exit;
-                    }
-                    TGT_DBG_SIGNAL_TRACE_POINT(7);
-                }
-            }
-            else if (EplDllkInstance_g.m_LastReqServiceId == kEplDllReqServiceNmtRequest)
-            {   // NmtRequest
-                if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_pbBuffer != NULL)
-                {   // NmtRequest does exist
-                    // check if frame is not empty and not being filled
-                    if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen > EPL_DLLK_BUFLEN_FILLING)
-                    {
-                        // check if this frame is a NMT command,
-                        // then forward this frame back to NmtMnu module,
-                        // because it needs the time, when this frame is
-                        // actually sent, to start the timer for monitoring
-                        // the NMT state change.
-
-                        pTxFrame = (tEplFrame *) EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_pbBuffer;
-                        if ((AmiGetByteFromLe(&pTxFrame->m_le_bMessageType)
-                                == (BYTE) kEplMsgTypeAsnd)
-                            && (AmiGetByteFromLe(&pTxFrame->m_Data.m_Asnd.m_le_bServiceId)
-                                == (BYTE) kEplDllAsndNmtCommand))
-                        {   // post event directly to NmtMnu module
-                            Event.m_EventSink = kEplEventSinkNmtMnu;
-                            Event.m_EventType = kEplEventTypeNmtMnuNmtCmdSent;
-                            Event.m_uiSize = EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_uiTxMsgLen;
-                            Event.m_pArg = pTxFrame;
-                            Ret = EplEventkPost(&Event);
-
-                        }
-
-                        // send NmtRequest
-                        Ret = EdrvSendTxMsg(&EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ]);
-                        if (Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-
-                    }
-                }
-
-            }
-            else if (EplDllkInstance_g.m_LastReqServiceId == kEplDllReqServiceUnspecified)
-            {   // unspecified invite
-                if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL].m_pbBuffer != NULL)
-                {   // non-EPL frame does exist
-                    // check if frame is not empty and not being filled
-                    if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL].m_uiTxMsgLen > EPL_DLLK_BUFLEN_FILLING)
-                    {
-                        // send non-EPL frame
-                        Ret = EdrvSendTxMsg(&EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL]);
-                        if (Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-
-                    }
-                }
-            }
-            // ASnd frame was sent, remove the request
-            EplDllkInstance_g.m_LastReqServiceId = kEplDllReqServiceNo;
-        }
-
-        // forward event to ErrorHandler and PDO module
-        Event.m_EventSink = kEplEventSinkNmtk;
-        Event.m_EventType = kEplEventTypeNmtEvent;
-        Event.m_uiSize = sizeof (NmtEvent);
-        Event.m_pArg = &NmtEvent;
-        Ret = EplEventkPost(&Event);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-    }
+		// check if we are invited
+		if (EplDllkInstance_g.m_uiLastTargetNodeId ==
+		    EplDllkInstance_g.m_DllConfigParam.m_uiNodeId) {
+			tEplFrame *pTxFrame;
+
+			if (EplDllkInstance_g.m_LastReqServiceId == kEplDllReqServiceStatus) {	// StatusRequest
+				if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_STATUSRES].m_pbBuffer != NULL) {	// StatusRes does exist
+
+					pTxFrame =
+					    (tEplFrame *) EplDllkInstance_g.
+					    m_pTxBuffer
+					    [EPL_DLLK_TXFRAME_STATUSRES].
+					    m_pbBuffer;
+					// update StatusRes frame (NMT state, EN, EC, RS, PR flags)
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.
+						       m_Payload.
+						       m_StatusResponse.
+						       m_le_bNmtStatus,
+						       (BYTE) NmtState);
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.
+						       m_Payload.
+						       m_StatusResponse.
+						       m_le_bFlag1,
+						       EplDllkInstance_g.
+						       m_bFlag1);
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.
+						       m_Payload.
+						       m_StatusResponse.
+						       m_le_bFlag2,
+						       EplDllkInstance_g.
+						       m_bFlag2);
+					// send StatusRes
+					Ret =
+					    EdrvSendTxMsg(&EplDllkInstance_g.
+							  m_pTxBuffer
+							  [EPL_DLLK_TXFRAME_STATUSRES]);
+					if (Ret != kEplSuccessful) {
+						goto Exit;
+					}
+					TGT_DBG_SIGNAL_TRACE_POINT(8);
+
+				}
+			} else if (EplDllkInstance_g.m_LastReqServiceId == kEplDllReqServiceIdent) {	// IdentRequest
+				if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_IDENTRES].m_pbBuffer != NULL) {	// IdentRes does exist
+					pTxFrame =
+					    (tEplFrame *) EplDllkInstance_g.
+					    m_pTxBuffer
+					    [EPL_DLLK_TXFRAME_IDENTRES].
+					    m_pbBuffer;
+					// update IdentRes frame (NMT state, RS, PR flags)
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.
+						       m_Payload.
+						       m_IdentResponse.
+						       m_le_bNmtStatus,
+						       (BYTE) NmtState);
+					AmiSetByteToLe(&pTxFrame->m_Data.m_Asnd.
+						       m_Payload.
+						       m_IdentResponse.
+						       m_le_bFlag2,
+						       EplDllkInstance_g.
+						       m_bFlag2);
+					// send IdentRes
+					Ret =
+					    EdrvSendTxMsg(&EplDllkInstance_g.
+							  m_pTxBuffer
+							  [EPL_DLLK_TXFRAME_IDENTRES]);
+					if (Ret != kEplSuccessful) {
+						goto Exit;
+					}
+					TGT_DBG_SIGNAL_TRACE_POINT(7);
+				}
+			} else if (EplDllkInstance_g.m_LastReqServiceId == kEplDllReqServiceNmtRequest) {	// NmtRequest
+				if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NMTREQ].m_pbBuffer != NULL) {	// NmtRequest does exist
+					// check if frame is not empty and not being filled
+					if (EplDllkInstance_g.
+					    m_pTxBuffer
+					    [EPL_DLLK_TXFRAME_NMTREQ].
+					    m_uiTxMsgLen >
+					    EPL_DLLK_BUFLEN_FILLING) {
+						// check if this frame is a NMT command,
+						// then forward this frame back to NmtMnu module,
+						// because it needs the time, when this frame is
+						// actually sent, to start the timer for monitoring
+						// the NMT state change.
+
+						pTxFrame =
+						    (tEplFrame *)
+						    EplDllkInstance_g.
+						    m_pTxBuffer
+						    [EPL_DLLK_TXFRAME_NMTREQ].
+						    m_pbBuffer;
+						if ((AmiGetByteFromLe
+						     (&pTxFrame->
+						      m_le_bMessageType)
+						     == (BYTE) kEplMsgTypeAsnd)
+						    &&
+						    (AmiGetByteFromLe
+						     (&pTxFrame->m_Data.m_Asnd.
+						      m_le_bServiceId)
+						     == (BYTE) kEplDllAsndNmtCommand)) {	// post event directly to NmtMnu module
+							Event.m_EventSink =
+							    kEplEventSinkNmtMnu;
+							Event.m_EventType =
+							    kEplEventTypeNmtMnuNmtCmdSent;
+							Event.m_uiSize =
+							    EplDllkInstance_g.
+							    m_pTxBuffer
+							    [EPL_DLLK_TXFRAME_NMTREQ].
+							    m_uiTxMsgLen;
+							Event.m_pArg = pTxFrame;
+							Ret =
+							    EplEventkPost
+							    (&Event);
+
+						}
+						// send NmtRequest
+						Ret =
+						    EdrvSendTxMsg
+						    (&EplDllkInstance_g.
+						     m_pTxBuffer
+						     [EPL_DLLK_TXFRAME_NMTREQ]);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+
+					}
+				}
+
+			} else if (EplDllkInstance_g.m_LastReqServiceId == kEplDllReqServiceUnspecified) {	// unspecified invite
+				if (EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_NONEPL].m_pbBuffer != NULL) {	// non-EPL frame does exist
+					// check if frame is not empty and not being filled
+					if (EplDllkInstance_g.
+					    m_pTxBuffer
+					    [EPL_DLLK_TXFRAME_NONEPL].
+					    m_uiTxMsgLen >
+					    EPL_DLLK_BUFLEN_FILLING) {
+						// send non-EPL frame
+						Ret =
+						    EdrvSendTxMsg
+						    (&EplDllkInstance_g.
+						     m_pTxBuffer
+						     [EPL_DLLK_TXFRAME_NONEPL]);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+
+					}
+				}
+			}
+			// ASnd frame was sent, remove the request
+			EplDllkInstance_g.m_LastReqServiceId =
+			    kEplDllReqServiceNo;
+		}
+		// forward event to ErrorHandler and PDO module
+		Event.m_EventSink = kEplEventSinkNmtk;
+		Event.m_EventType = kEplEventTypeNmtEvent;
+		Event.m_uiSize = sizeof(NmtEvent);
+		Event.m_pArg = &NmtEvent;
+		Ret = EplEventkPost(&Event);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+	}
 #endif
 
 #if EPL_DLL_PRES_READY_AFTER_SOA != FALSE
-    else
-    {   // d.k.: Why that else? on CN it is entered on IdentRes and StatusRes
-        goto Exit;
-    }
+	else {			// d.k.: Why that else? on CN it is entered on IdentRes and StatusRes
+		goto Exit;
+	}
 
-    // signal process function readiness of PRes frame
-    Event.m_EventSink = kEplEventSinkDllk;
-    Event.m_EventType = kEplEventTypeDllkPresReady;
-    Event.m_uiSize = 0;
-    Event.m_pArg = NULL;
-    Ret = EplEventkPost(&Event);
+	// signal process function readiness of PRes frame
+	Event.m_EventSink = kEplEventSinkDllk;
+	Event.m_EventType = kEplEventTypeDllkPresReady;
+	Event.m_uiSize = 0;
+	Event.m_pArg = NULL;
+	Ret = EplEventkPost(&Event);
 
 #endif
 
-Exit:
-    if (Ret != kEplSuccessful)
-    {
-    DWORD   dwArg;
+      Exit:
+	if (Ret != kEplSuccessful) {
+		DWORD dwArg;
 
-        BENCHMARK_MOD_02_TOGGLE(9);
+		BENCHMARK_MOD_02_TOGGLE(9);
 
-        dwArg = EplDllkInstance_g.m_DllState | (pTxBuffer_p->m_EplMsgType << 16);
+		dwArg =
+		    EplDllkInstance_g.m_DllState | (pTxBuffer_p->
+						    m_EplMsgType << 16);
 
-        // Error event for API layer
-        Ret = EplEventkPostError(kEplEventSourceDllk,
-                        Ret,
-                        sizeof(dwArg),
-                        &dwArg);
-    }
+		// Error event for API layer
+		Ret = EplEventkPostError(kEplEventSourceDllk,
+					 Ret, sizeof(dwArg), &dwArg);
+	}
 
-    return;
+	return;
 }
 
 //---------------------------------------------------------------------------
@@ -3194,53 +3481,53 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplDllkCheckFrame(tEplFrame * pFrame_p, unsigned int uiFrameSize_p)
+static tEplKernel EplDllkCheckFrame(tEplFrame * pFrame_p,
+				    unsigned int uiFrameSize_p)
 {
-tEplMsgType     MsgType;
-WORD            wEtherType;
+	tEplMsgType MsgType;
+	WORD wEtherType;
 
-    // check frame
-    if (pFrame_p != NULL)
-    {
-        // check SrcMAC
-        if (AmiGetQword48FromBe(pFrame_p->m_be_abSrcMac) == 0)
-        {
-            // source MAC address
-            EPL_MEMCPY(&pFrame_p->m_be_abSrcMac[0], &EplDllkInstance_g.m_be_abSrcMac[0], 6);
-        }
-
-        // check ethertype
-        wEtherType = AmiGetWordFromBe(&pFrame_p->m_be_wEtherType);
-        if (wEtherType == 0)
-        {
-            // assume EPL frame
-            wEtherType = EPL_C_DLL_ETHERTYPE_EPL;
-            AmiSetWordToBe(&pFrame_p->m_be_wEtherType, wEtherType);
-        }
+	// check frame
+	if (pFrame_p != NULL) {
+		// check SrcMAC
+		if (AmiGetQword48FromBe(pFrame_p->m_be_abSrcMac) == 0) {
+			// source MAC address
+			EPL_MEMCPY(&pFrame_p->m_be_abSrcMac[0],
+				   &EplDllkInstance_g.m_be_abSrcMac[0], 6);
+		}
+		// check ethertype
+		wEtherType = AmiGetWordFromBe(&pFrame_p->m_be_wEtherType);
+		if (wEtherType == 0) {
+			// assume EPL frame
+			wEtherType = EPL_C_DLL_ETHERTYPE_EPL;
+			AmiSetWordToBe(&pFrame_p->m_be_wEtherType, wEtherType);
+		}
+
+		if (wEtherType == EPL_C_DLL_ETHERTYPE_EPL) {
+			// source node ID
+			AmiSetByteToLe(&pFrame_p->m_le_bSrcNodeId,
+				       (BYTE) EplDllkInstance_g.
+				       m_DllConfigParam.m_uiNodeId);
+
+			// check message type
+			MsgType =
+			    AmiGetByteFromLe(&pFrame_p->m_le_bMessageType);
+			if (MsgType == 0) {
+				MsgType = kEplMsgTypeAsnd;
+				AmiSetByteToLe(&pFrame_p->m_le_bMessageType,
+					       (BYTE) MsgType);
+			}
+
+			if (MsgType == kEplMsgTypeAsnd) {
+				// destination MAC address
+				AmiSetQword48ToBe(&pFrame_p->m_be_abDstMac[0],
+						  EPL_C_DLL_MULTICAST_ASND);
+			}
 
-        if (wEtherType == EPL_C_DLL_ETHERTYPE_EPL)
-        {
-            // source node ID
-            AmiSetByteToLe(&pFrame_p->m_le_bSrcNodeId, (BYTE) EplDllkInstance_g.m_DllConfigParam.m_uiNodeId);
-
-            // check message type
-            MsgType = AmiGetByteFromLe(&pFrame_p->m_le_bMessageType);
-            if (MsgType == 0)
-            {
-                MsgType = kEplMsgTypeAsnd;
-                AmiSetByteToLe(&pFrame_p->m_le_bMessageType, (BYTE) MsgType);
-            }
-
-            if (MsgType == kEplMsgTypeAsnd)
-            {
-                // destination MAC address
-                AmiSetQword48ToBe(&pFrame_p->m_be_abDstMac[0], EPL_C_DLL_MULTICAST_ASND);
-            }
-
-        }
-    }
+		}
+	}
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 }
 
 //---------------------------------------------------------------------------
@@ -3259,34 +3546,30 @@ WORD            wEtherType;
 //---------------------------------------------------------------------------
 
 #if EPL_TIMER_USE_HIGHRES != FALSE
-static tEplKernel PUBLIC EplDllkCbCnTimer(tEplTimerEventArg* pEventArg_p)
+static tEplKernel PUBLIC EplDllkCbCnTimer(tEplTimerEventArg * pEventArg_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplNmtState    NmtState;
+	tEplKernel Ret = kEplSuccessful;
+	tEplNmtState NmtState;
 
 #if EPL_TIMER_USE_HIGHRES != FALSE
-    if (pEventArg_p->m_TimerHdl != EplDllkInstance_g.m_TimerHdlCycle)
-    {   // zombie callback
-        // just exit
-        goto Exit;
-    }
-#endif
-
-    NmtState = EplNmtkGetNmtState();
-
-    if (NmtState <= kEplNmtGsResetConfiguration)
-    {
-        goto Exit;
-    }
-
-    Ret = EplDllkChangeState(kEplNmtEventDllCeFrameTimeout, NmtState);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // 2008/10/15 d.k. reprogramming of timer not necessary,
-    // because it will be programmed, when SoC is received.
+	if (pEventArg_p->m_TimerHdl != EplDllkInstance_g.m_TimerHdlCycle) {	// zombie callback
+		// just exit
+		goto Exit;
+	}
+#endif
+
+	NmtState = EplNmtkGetNmtState();
+
+	if (NmtState <= kEplNmtGsResetConfiguration) {
+		goto Exit;
+	}
+
+	Ret = EplDllkChangeState(kEplNmtEventDllCeFrameTimeout, NmtState);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// 2008/10/15 d.k. reprogramming of timer not necessary,
+	// because it will be programmed, when SoC is received.
 /*
     // reprogram timer
 #if EPL_TIMER_USE_HIGHRES != FALSE
@@ -3298,23 +3581,22 @@ tEplNmtState    NmtState;
 #endif
 */
 
-Exit:
-    if (Ret != kEplSuccessful)
-    {
-    DWORD   dwArg;
-
-        BENCHMARK_MOD_02_TOGGLE(9);
-
-        dwArg = EplDllkInstance_g.m_DllState | (kEplNmtEventDllCeFrameTimeout << 8);
+      Exit:
+	if (Ret != kEplSuccessful) {
+		DWORD dwArg;
+
+		BENCHMARK_MOD_02_TOGGLE(9);
+
+		dwArg =
+		    EplDllkInstance_g.
+		    m_DllState | (kEplNmtEventDllCeFrameTimeout << 8);
+
+		// Error event for API layer
+		Ret = EplEventkPostError(kEplEventSourceDllk,
+					 Ret, sizeof(dwArg), &dwArg);
+	}
 
-        // Error event for API layer
-        Ret = EplEventkPostError(kEplEventSourceDllk,
-                        Ret,
-                        sizeof(dwArg),
-                        &dwArg);
-    }
-
-    return Ret;
+	return Ret;
 }
 #endif
 
@@ -3335,48 +3617,44 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC EplDllkCbMnTimerCycle(tEplTimerEventArg* pEventArg_p)
+static tEplKernel PUBLIC EplDllkCbMnTimerCycle(tEplTimerEventArg * pEventArg_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplNmtState    NmtState;
+	tEplKernel Ret = kEplSuccessful;
+	tEplNmtState NmtState;
 
 #if EPL_TIMER_USE_HIGHRES != FALSE
-    if (pEventArg_p->m_TimerHdl != EplDllkInstance_g.m_TimerHdlCycle)
-    {   // zombie callback
-        // just exit
-        goto Exit;
-    }
+	if (pEventArg_p->m_TimerHdl != EplDllkInstance_g.m_TimerHdlCycle) {	// zombie callback
+		// just exit
+		goto Exit;
+	}
 #endif
 
-    NmtState = EplNmtkGetNmtState();
+	NmtState = EplNmtkGetNmtState();
 
-    if (NmtState <= kEplNmtGsResetConfiguration)
-    {
-        goto Exit;
-    }
+	if (NmtState <= kEplNmtGsResetConfiguration) {
+		goto Exit;
+	}
 
-    Ret = EplDllkChangeState(kEplNmtEventDllMeSocTrig, NmtState);
+	Ret = EplDllkChangeState(kEplNmtEventDllMeSocTrig, NmtState);
 
-Exit:
-    if (Ret != kEplSuccessful)
-    {
-    DWORD   dwArg;
+      Exit:
+	if (Ret != kEplSuccessful) {
+		DWORD dwArg;
 
-        BENCHMARK_MOD_02_TOGGLE(9);
+		BENCHMARK_MOD_02_TOGGLE(9);
 
-        dwArg = EplDllkInstance_g.m_DllState | (kEplNmtEventDllMeSocTrig << 8);
+		dwArg =
+		    EplDllkInstance_g.
+		    m_DllState | (kEplNmtEventDllMeSocTrig << 8);
 
-        // Error event for API layer
-        Ret = EplEventkPostError(kEplEventSourceDllk,
-                        Ret,
-                        sizeof(dwArg),
-                        &dwArg);
-    }
+		// Error event for API layer
+		Ret = EplEventkPostError(kEplEventSourceDllk,
+					 Ret, sizeof(dwArg), &dwArg);
+	}
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkCbMnTimerResponse()
@@ -3392,48 +3670,45 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC EplDllkCbMnTimerResponse(tEplTimerEventArg* pEventArg_p)
+static tEplKernel PUBLIC EplDllkCbMnTimerResponse(tEplTimerEventArg *
+						  pEventArg_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplNmtState    NmtState;
+	tEplKernel Ret = kEplSuccessful;
+	tEplNmtState NmtState;
 
 #if EPL_TIMER_USE_HIGHRES != FALSE
-    if (pEventArg_p->m_TimerHdl != EplDllkInstance_g.m_TimerHdlResponse)
-    {   // zombie callback
-        // just exit
-        goto Exit;
-    }
+	if (pEventArg_p->m_TimerHdl != EplDllkInstance_g.m_TimerHdlResponse) {	// zombie callback
+		// just exit
+		goto Exit;
+	}
 #endif
 
-    NmtState = EplNmtkGetNmtState();
+	NmtState = EplNmtkGetNmtState();
 
-    if (NmtState <= kEplNmtGsResetConfiguration)
-    {
-        goto Exit;
-    }
+	if (NmtState <= kEplNmtGsResetConfiguration) {
+		goto Exit;
+	}
 
-    Ret = EplDllkChangeState(kEplNmtEventDllMePresTimeout, NmtState);
+	Ret = EplDllkChangeState(kEplNmtEventDllMePresTimeout, NmtState);
 
-Exit:
-    if (Ret != kEplSuccessful)
-    {
-    DWORD   dwArg;
+      Exit:
+	if (Ret != kEplSuccessful) {
+		DWORD dwArg;
 
-        BENCHMARK_MOD_02_TOGGLE(9);
+		BENCHMARK_MOD_02_TOGGLE(9);
 
-        dwArg = EplDllkInstance_g.m_DllState | (kEplNmtEventDllMePresTimeout << 8);
+		dwArg =
+		    EplDllkInstance_g.
+		    m_DllState | (kEplNmtEventDllMePresTimeout << 8);
 
-        // Error event for API layer
-        Ret = EplEventkPostError(kEplEventSourceDllk,
-                        Ret,
-                        sizeof(dwArg),
-                        &dwArg);
-    }
+		// Error event for API layer
+		Ret = EplEventkPostError(kEplEventSourceDllk,
+					 Ret, sizeof(dwArg), &dwArg);
+	}
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkGetNodeInfo()
@@ -3449,22 +3724,18 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplDllkNodeInfo* EplDllkGetNodeInfo(unsigned int uiNodeId_p)
+static tEplDllkNodeInfo *EplDllkGetNodeInfo(unsigned int uiNodeId_p)
 {
-    // $$$ d.k.: use hash algorithm to retrieve the appropriate node info structure
-    //           if size of array is less than 254.
-    uiNodeId_p--;   // node ID starts at 1 but array at 0
-    if (uiNodeId_p >= tabentries (EplDllkInstance_g.m_aNodeInfo))
-    {
-        return NULL;
-    }
-    else
-    {
-        return &EplDllkInstance_g.m_aNodeInfo[uiNodeId_p];
-    }
+	// $$$ d.k.: use hash algorithm to retrieve the appropriate node info structure
+	//           if size of array is less than 254.
+	uiNodeId_p--;		// node ID starts at 1 but array at 0
+	if (uiNodeId_p >= tabentries(EplDllkInstance_g.m_aNodeInfo)) {
+		return NULL;
+	} else {
+		return &EplDllkInstance_g.m_aNodeInfo[uiNodeId_p];
+	}
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkMnSendSoa()
@@ -3484,97 +3755,105 @@ static tEplDllkNodeInfo* EplDllkGetNodeI
 //---------------------------------------------------------------------------
 
 static tEplKernel EplDllkMnSendSoa(tEplNmtState NmtState_p,
-                                   tEplDllState* pDllStateProposed_p,
-                                   BOOL fEnableInvitation_p)
+				   tEplDllState * pDllStateProposed_p,
+				   BOOL fEnableInvitation_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEdrvTxBuffer  *pTxBuffer = NULL;
-tEplFrame      *pTxFrame;
-tEplDllkNodeInfo*   pNodeInfo;
-
-    *pDllStateProposed_p = kEplDllMsNonCyclic;
-
-    pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_SOA];
-    if (pTxBuffer->m_pbBuffer != NULL)
-    {   // SoA does exist
-        pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
-
-        if (fEnableInvitation_p != FALSE)
-        {   // fetch target of asynchronous phase
-            if (EplDllkInstance_g.m_bFlag2 == 0)
-            {   // own queues are empty
-                EplDllkInstance_g.m_LastReqServiceId = kEplDllReqServiceNo;
-            }
-            else if (((tEplDllAsyncReqPriority) (EplDllkInstance_g.m_bFlag2 >> EPL_FRAME_FLAG2_PR_SHIFT)) == kEplDllAsyncReqPrioNmt)
-            {   // frames in own NMT request queue available
-                EplDllkInstance_g.m_LastReqServiceId = kEplDllReqServiceNmtRequest;
-            }
-            else
-            {
-                EplDllkInstance_g.m_LastReqServiceId = kEplDllReqServiceUnspecified;
-            }
-            Ret = EplDllkCalAsyncGetSoaRequest(&EplDllkInstance_g.m_LastReqServiceId, &EplDllkInstance_g.m_uiLastTargetNodeId);
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-            if (EplDllkInstance_g.m_LastReqServiceId != kEplDllReqServiceNo)
-            {   // asynchronous phase will be assigned to one node
-                if (EplDllkInstance_g.m_uiLastTargetNodeId == EPL_C_ADR_INVALID)
-                {   // exchange invalid node ID with local node ID
-                    EplDllkInstance_g.m_uiLastTargetNodeId = EplDllkInstance_g.m_DllConfigParam.m_uiNodeId;
-                    // d.k. DLL state WaitAsndTrig is not helpful;
-                    //      so just step over to WaitSocTrig,
-                    //      because own ASnd is sent automatically in CbFrameTransmitted() after SoA.
-                    //*pDllStateProposed_p = kEplDllMsWaitAsndTrig;
-                    *pDllStateProposed_p = kEplDllMsWaitSocTrig;
-                }
-                else
-                {   // assignment to CN
-                    *pDllStateProposed_p = kEplDllMsWaitAsnd;
-                }
-
-                pNodeInfo = EplDllkGetNodeInfo(EplDllkInstance_g.m_uiLastTargetNodeId);
-                if (pNodeInfo == NULL)
-                {   // no node info structure available
-                    Ret = kEplDllNoNodeInfo;
-                    goto Exit;
-                }
-
-                // update frame (EA, ER flags)
-                AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bFlag1,
-                    pNodeInfo->m_bSoaFlag1 & (EPL_FRAME_FLAG1_EA | EPL_FRAME_FLAG1_ER));
-            }
-            else
-            {   // no assignment of asynchronous phase
-                *pDllStateProposed_p = kEplDllMsWaitSocTrig;
-                EplDllkInstance_g.m_uiLastTargetNodeId = EPL_C_ADR_INVALID;
-            }
-
-            // update frame (target)
-            AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bReqServiceId, (BYTE) EplDllkInstance_g.m_LastReqServiceId);
-            AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bReqServiceTarget, (BYTE) EplDllkInstance_g.m_uiLastTargetNodeId);
-
-        }
-        else
-        {   // invite nobody
-            // update frame (target)
-            AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bReqServiceId, (BYTE) 0);
-            AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bReqServiceTarget, (BYTE) 0);
-        }
-
-        // update frame (NMT state)
-        AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bNmtStatus, (BYTE) NmtState_p);
-
-        // send SoA frame
-        Ret = EdrvSendTxMsg(pTxBuffer);
-    }
+	tEplKernel Ret = kEplSuccessful;
+	tEdrvTxBuffer *pTxBuffer = NULL;
+	tEplFrame *pTxFrame;
+	tEplDllkNodeInfo *pNodeInfo;
+
+	*pDllStateProposed_p = kEplDllMsNonCyclic;
+
+	pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_SOA];
+	if (pTxBuffer->m_pbBuffer != NULL) {	// SoA does exist
+		pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
+
+		if (fEnableInvitation_p != FALSE) {	// fetch target of asynchronous phase
+			if (EplDllkInstance_g.m_bFlag2 == 0) {	// own queues are empty
+				EplDllkInstance_g.m_LastReqServiceId =
+				    kEplDllReqServiceNo;
+			} else if (((tEplDllAsyncReqPriority) (EplDllkInstance_g.m_bFlag2 >> EPL_FRAME_FLAG2_PR_SHIFT)) == kEplDllAsyncReqPrioNmt) {	// frames in own NMT request queue available
+				EplDllkInstance_g.m_LastReqServiceId =
+				    kEplDllReqServiceNmtRequest;
+			} else {
+				EplDllkInstance_g.m_LastReqServiceId =
+				    kEplDllReqServiceUnspecified;
+			}
+			Ret =
+			    EplDllkCalAsyncGetSoaRequest(&EplDllkInstance_g.
+							 m_LastReqServiceId,
+							 &EplDllkInstance_g.
+							 m_uiLastTargetNodeId);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+			if (EplDllkInstance_g.m_LastReqServiceId != kEplDllReqServiceNo) {	// asynchronous phase will be assigned to one node
+				if (EplDllkInstance_g.m_uiLastTargetNodeId == EPL_C_ADR_INVALID) {	// exchange invalid node ID with local node ID
+					EplDllkInstance_g.m_uiLastTargetNodeId =
+					    EplDllkInstance_g.m_DllConfigParam.
+					    m_uiNodeId;
+					// d.k. DLL state WaitAsndTrig is not helpful;
+					//      so just step over to WaitSocTrig,
+					//      because own ASnd is sent automatically in CbFrameTransmitted() after SoA.
+					//*pDllStateProposed_p = kEplDllMsWaitAsndTrig;
+					*pDllStateProposed_p =
+					    kEplDllMsWaitSocTrig;
+				} else {	// assignment to CN
+					*pDllStateProposed_p =
+					    kEplDllMsWaitAsnd;
+				}
+
+				pNodeInfo =
+				    EplDllkGetNodeInfo(EplDllkInstance_g.
+						       m_uiLastTargetNodeId);
+				if (pNodeInfo == NULL) {	// no node info structure available
+					Ret = kEplDllNoNodeInfo;
+					goto Exit;
+				}
+				// update frame (EA, ER flags)
+				AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.
+					       m_le_bFlag1,
+					       pNodeInfo->
+					       m_bSoaFlag1 & (EPL_FRAME_FLAG1_EA
+							      |
+							      EPL_FRAME_FLAG1_ER));
+			} else {	// no assignment of asynchronous phase
+				*pDllStateProposed_p = kEplDllMsWaitSocTrig;
+				EplDllkInstance_g.m_uiLastTargetNodeId =
+				    EPL_C_ADR_INVALID;
+			}
+
+			// update frame (target)
+			AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.
+				       m_le_bReqServiceId,
+				       (BYTE) EplDllkInstance_g.
+				       m_LastReqServiceId);
+			AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.
+				       m_le_bReqServiceTarget,
+				       (BYTE) EplDllkInstance_g.
+				       m_uiLastTargetNodeId);
+
+		} else {	// invite nobody
+			// update frame (target)
+			AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.
+				       m_le_bReqServiceId, (BYTE) 0);
+			AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.
+				       m_le_bReqServiceTarget, (BYTE) 0);
+		}
+
+		// update frame (NMT state)
+		AmiSetByteToLe(&pTxFrame->m_Data.m_Soa.m_le_bNmtStatus,
+			       (BYTE) NmtState_p);
+
+		// send SoA frame
+		Ret = EdrvSendTxMsg(pTxBuffer);
+	}
 
-Exit:
-     return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkMnSendSoc()
@@ -3592,37 +3871,33 @@ Exit:
 
 static tEplKernel EplDllkMnSendSoc(void)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEdrvTxBuffer*  pTxBuffer = NULL;
-tEplFrame*      pTxFrame;
-tEplEvent       Event;
-
-    pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_SOC];
-    if (pTxBuffer->m_pbBuffer != NULL)
-    {   // SoC does exist
-        pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
-
-        // $$$ update NetTime
-
-        // send SoC frame
-        Ret = EdrvSendTxMsg(pTxBuffer);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        // trigger synchronous task
-        Event.m_EventSink = kEplEventSinkSync;
-        Event.m_EventType = kEplEventTypeSync;
-        Event.m_uiSize = 0;
-        Ret = EplEventkPost(&Event);
-    }
+	tEplKernel Ret = kEplSuccessful;
+	tEdrvTxBuffer *pTxBuffer = NULL;
+	tEplFrame *pTxFrame;
+	tEplEvent Event;
+
+	pTxBuffer = &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_SOC];
+	if (pTxBuffer->m_pbBuffer != NULL) {	// SoC does exist
+		pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
+
+		// $$$ update NetTime
+
+		// send SoC frame
+		Ret = EdrvSendTxMsg(pTxBuffer);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		// trigger synchronous task
+		Event.m_EventSink = kEplEventSinkSync;
+		Event.m_EventType = kEplEventTypeSync;
+		Event.m_uiSize = 0;
+		Ret = EplEventkPost(&Event);
+	}
 
-Exit:
-     return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkMnSendPreq()
@@ -3641,87 +3916,83 @@ Exit:
 //---------------------------------------------------------------------------
 
 static tEplKernel EplDllkMnSendPreq(tEplNmtState NmtState_p,
-                                    tEplDllState* pDllStateProposed_p)
+				    tEplDllState * pDllStateProposed_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEdrvTxBuffer  *pTxBuffer = NULL;
-tEplFrame      *pTxFrame;
-BYTE            bFlag1 = 0;
-
-
-    if (EplDllkInstance_g.m_pCurNodeInfo == NULL)
-    {   // start with first isochronous CN
-        EplDllkInstance_g.m_pCurNodeInfo = EplDllkInstance_g.m_pFirstNodeInfo;
-    }
-    else
-    {   // iterate to next isochronous CN
-        EplDllkInstance_g.m_pCurNodeInfo = EplDllkInstance_g.m_pCurNodeInfo->m_pNextNodeInfo;
-    }
+	tEplKernel Ret = kEplSuccessful;
+	tEdrvTxBuffer *pTxBuffer = NULL;
+	tEplFrame *pTxFrame;
+	BYTE bFlag1 = 0;
+
+	if (EplDllkInstance_g.m_pCurNodeInfo == NULL) {	// start with first isochronous CN
+		EplDllkInstance_g.m_pCurNodeInfo =
+		    EplDllkInstance_g.m_pFirstNodeInfo;
+	} else {		// iterate to next isochronous CN
+		EplDllkInstance_g.m_pCurNodeInfo =
+		    EplDllkInstance_g.m_pCurNodeInfo->m_pNextNodeInfo;
+	}
+
+	if (EplDllkInstance_g.m_pCurNodeInfo == NULL) {	// last isochronous CN reached
+		Ret = EplDllkMnSendSoa(NmtState_p, pDllStateProposed_p, TRUE);
+		goto Exit;
+	} else {
+		pTxBuffer = EplDllkInstance_g.m_pCurNodeInfo->m_pPreqTxBuffer;
+		bFlag1 =
+		    EplDllkInstance_g.m_pCurNodeInfo->
+		    m_bSoaFlag1 & EPL_FRAME_FLAG1_EA;
+		*pDllStateProposed_p = kEplDllMsWaitPres;
 
-    if (EplDllkInstance_g.m_pCurNodeInfo == NULL)
-    {   // last isochronous CN reached
-        Ret = EplDllkMnSendSoa(NmtState_p, pDllStateProposed_p, TRUE);
-        goto Exit;
-    }
-    else
-    {
-        pTxBuffer = EplDllkInstance_g.m_pCurNodeInfo->m_pPreqTxBuffer;
-        bFlag1 = EplDllkInstance_g.m_pCurNodeInfo->m_bSoaFlag1 & EPL_FRAME_FLAG1_EA;
-        *pDllStateProposed_p = kEplDllMsWaitPres;
-
-        // start PRes Timer
-        // $$$ d.k.: maybe move this call to CbFrameTransmitted(), because the time should run from there
+		// start PRes Timer
+		// $$$ d.k.: maybe move this call to CbFrameTransmitted(), because the time should run from there
 #if EPL_TIMER_USE_HIGHRES != FALSE
-        Ret = EplTimerHighReskModifyTimerNs(&EplDllkInstance_g.m_TimerHdlResponse,
-            EplDllkInstance_g.m_pCurNodeInfo->m_dwPresTimeout,
-            EplDllkCbMnTimerResponse,
-            0L,
-            FALSE);
-#endif
-    }
-
-    if (pTxBuffer == NULL)
-    {   // PReq does not exist
-        Ret = kEplDllTxBufNotReady;
-        goto Exit;
-    }
-
-    pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
+		Ret =
+		    EplTimerHighReskModifyTimerNs(&EplDllkInstance_g.
+						  m_TimerHdlResponse,
+						  EplDllkInstance_g.
+						  m_pCurNodeInfo->
+						  m_dwPresTimeout,
+						  EplDllkCbMnTimerResponse, 0L,
+						  FALSE);
+#endif
+	}
+
+	if (pTxBuffer == NULL) {	// PReq does not exist
+		Ret = kEplDllTxBufNotReady;
+		goto Exit;
+	}
+
+	pTxFrame = (tEplFrame *) pTxBuffer->m_pbBuffer;
+
+	if (pTxFrame != NULL) {	// PReq does exist
+		if (NmtState_p == kEplNmtMsOperational) {	// leave RD flag untouched
+			bFlag1 |=
+			    AmiGetByteFromLe(&pTxFrame->m_Data.m_Preq.
+					     m_le_bFlag1) & EPL_FRAME_FLAG1_RD;
+		}
+
+		if (pTxBuffer == &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES]) {	// PRes of MN will be sent
+			// update NMT state
+			AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bNmtStatus,
+				       (BYTE) NmtState_p);
+			*pDllStateProposed_p = kEplDllMsWaitSoaTrig;
+		}
+		// $$$ d.k. set EPL_FRAME_FLAG1_MS if necessary
+		// update frame (Flag1)
+		AmiSetByteToLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag1, bFlag1);
+
+		// calculate frame size from payload size
+		pTxBuffer->m_uiTxMsgLen =
+		    AmiGetWordFromLe(&pTxFrame->m_Data.m_Preq.m_le_wSize) + 24;
+
+		// send PReq frame
+		Ret = EdrvSendTxMsg(pTxBuffer);
+	} else {
+		Ret = kEplDllTxFrameInvalid;
+	}
 
-    if (pTxFrame != NULL)
-    {   // PReq does exist
-        if (NmtState_p == kEplNmtMsOperational)
-        {   // leave RD flag untouched
-            bFlag1 |= AmiGetByteFromLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag1) & EPL_FRAME_FLAG1_RD;
-        }
-
-        if (pTxBuffer == &EplDllkInstance_g.m_pTxBuffer[EPL_DLLK_TXFRAME_PRES])
-        {   // PRes of MN will be sent
-            // update NMT state
-            AmiSetByteToLe(&pTxFrame->m_Data.m_Pres.m_le_bNmtStatus, (BYTE) NmtState_p);
-            *pDllStateProposed_p = kEplDllMsWaitSoaTrig;
-        }
-
-        // $$$ d.k. set EPL_FRAME_FLAG1_MS if necessary
-        // update frame (Flag1)
-        AmiSetByteToLe(&pTxFrame->m_Data.m_Preq.m_le_bFlag1, bFlag1);
-
-        // calculate frame size from payload size
-        pTxBuffer->m_uiTxMsgLen = AmiGetWordFromLe(&pTxFrame->m_Data.m_Preq.m_le_wSize) + 24;
-
-        // send PReq frame
-        Ret = EdrvSendTxMsg(pTxBuffer);
-    }
-    else
-    {
-        Ret = kEplDllTxFrameInvalid;
-    }
-
-Exit:
-     return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkAsyncFrameNotReceived()
@@ -3739,45 +4010,45 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplDllkAsyncFrameNotReceived(tEplDllReqServiceId ReqServiceId_p, unsigned int uiNodeId_p)
-{
-tEplKernel      Ret = kEplSuccessful;
-BYTE            abBuffer[18];
-tEplFrame*      pFrame = (tEplFrame*) abBuffer;
-tEplFrameInfo   FrameInfo;
+static tEplKernel EplDllkAsyncFrameNotReceived(tEplDllReqServiceId
+					       ReqServiceId_p,
+					       unsigned int uiNodeId_p)
+{
+	tEplKernel Ret = kEplSuccessful;
+	BYTE abBuffer[18];
+	tEplFrame *pFrame = (tEplFrame *) abBuffer;
+	tEplFrameInfo FrameInfo;
+
+	// check if previous SoA invitation was not answered
+	switch (ReqServiceId_p) {
+	case kEplDllReqServiceIdent:
+	case kEplDllReqServiceStatus:
+		// ASnd service registered?
+		if (EplDllkInstance_g.m_aAsndFilter[ReqServiceId_p] == kEplDllAsndFilterAny) {	// ASnd service ID is registered
+			AmiSetByteToLe(&pFrame->m_le_bSrcNodeId,
+				       (BYTE) uiNodeId_p);
+			// EPL MsgType ASnd
+			AmiSetByteToLe(&pFrame->m_le_bMessageType,
+				       (BYTE) kEplMsgTypeAsnd);
+			// ASnd Service ID
+			AmiSetByteToLe(&pFrame->m_Data.m_Asnd.m_le_bServiceId,
+				       (BYTE) ReqServiceId_p);
+			// create frame info structure
+			FrameInfo.m_pFrame = pFrame;
+			FrameInfo.m_uiFrameSize = 18;	// empty non existing ASnd frame
+			// forward frame via async receive FIFO to userspace
+			Ret = EplDllkCalAsyncFrameReceived(&FrameInfo);
+		}
+		break;
+	default:
+		// no invitation issued or it was successfully answered or it is uninteresting
+		break;
+	}
 
-    // check if previous SoA invitation was not answered
-    switch (ReqServiceId_p)
-    {
-        case kEplDllReqServiceIdent:
-        case kEplDllReqServiceStatus:
-            // ASnd service registered?
-            if (EplDllkInstance_g.m_aAsndFilter[ReqServiceId_p] == kEplDllAsndFilterAny)
-            {   // ASnd service ID is registered
-                AmiSetByteToLe(&pFrame->m_le_bSrcNodeId, (BYTE) uiNodeId_p);
-                // EPL MsgType ASnd
-                AmiSetByteToLe(&pFrame->m_le_bMessageType, (BYTE) kEplMsgTypeAsnd);
-                // ASnd Service ID
-                AmiSetByteToLe(&pFrame->m_Data.m_Asnd.m_le_bServiceId, (BYTE) ReqServiceId_p);
-                // create frame info structure
-                FrameInfo.m_pFrame = pFrame;
-                FrameInfo.m_uiFrameSize = 18;   // empty non existing ASnd frame
-                // forward frame via async receive FIFO to userspace
-                Ret = EplDllkCalAsyncFrameReceived(&FrameInfo);
-            }
-            break;
-        default:
-            // no invitation issued or it was successfully answered or it is uninteresting
-            break;
-    }
-
-    return Ret;
+	return Ret;
 }
 
-
 #endif //(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
-
 #endif // #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
 // EOF
-
--- a/drivers/staging/epl/EplDllkCal.c
+++ b/drivers/staging/epl/EplDllkCal.c
@@ -106,7 +106,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -120,7 +119,6 @@
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -131,43 +129,42 @@
 // const defines
 //---------------------------------------------------------------------------
 
-#define EPL_DLLKCAL_MAX_QUEUES  5   // CnGenReq, CnNmtReq, {MnGenReq, MnNmtReq}, MnIdentReq, MnStatusReq
+#define EPL_DLLKCAL_MAX_QUEUES  5	// CnGenReq, CnNmtReq, {MnGenReq, MnNmtReq}, MnIdentReq, MnStatusReq
 
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
+typedef struct {
 #ifndef EPL_NO_FIFO
 //    tShbInstance    m_ShbInstanceRx;      // FIFO for Rx ASnd frames
-    tShbInstance    m_ShbInstanceTxNmt;   // FIFO for Tx frames with NMT request priority
-    tShbInstance    m_ShbInstanceTxGen;   // FIFO for Tx frames with generic priority
+	tShbInstance m_ShbInstanceTxNmt;	// FIFO for Tx frames with NMT request priority
+	tShbInstance m_ShbInstanceTxGen;	// FIFO for Tx frames with generic priority
 #else
-    unsigned int    m_uiFrameSizeNmt;
-    BYTE            m_abFrameNmt[1500];
-    unsigned int    m_uiFrameSizeGen;
-    BYTE            m_abFrameGen[1500];
+	unsigned int m_uiFrameSizeNmt;
+	BYTE m_abFrameNmt[1500];
+	unsigned int m_uiFrameSizeGen;
+	BYTE m_abFrameGen[1500];
 #endif
 
-    tEplDllkCalStatistics   m_Statistics;
+	tEplDllkCalStatistics m_Statistics;
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    // IdentRequest queue with CN node IDs
-    unsigned int    m_auiQueueIdentReq[EPL_D_NMT_MaxCNNumber_U8 + 1];   // 1 entry is reserved to distinguish between full and empty
-    unsigned int    m_uiWriteIdentReq;
-    unsigned int    m_uiReadIdentReq;
-
-    // StatusRequest queue with CN node IDs
-    unsigned int    m_auiQueueStatusReq[EPL_D_NMT_MaxCNNumber_U8 + 1];  // 1 entry is reserved to distinguish between full and empty
-    unsigned int    m_uiWriteStatusReq;
-    unsigned int    m_uiReadStatusReq;
-
-    unsigned int    m_auiQueueCnRequests[254 * 2];
-        // first 254 entries represent the generic requests of the corresponding node
-        // second 254 entries represent the NMT requests of the corresponding node
-    unsigned int    m_uiNextQueueCnRequest;
-    unsigned int    m_uiNextRequestQueue;
+	// IdentRequest queue with CN node IDs
+	unsigned int m_auiQueueIdentReq[EPL_D_NMT_MaxCNNumber_U8 + 1];	// 1 entry is reserved to distinguish between full and empty
+	unsigned int m_uiWriteIdentReq;
+	unsigned int m_uiReadIdentReq;
+
+	// StatusRequest queue with CN node IDs
+	unsigned int m_auiQueueStatusReq[EPL_D_NMT_MaxCNNumber_U8 + 1];	// 1 entry is reserved to distinguish between full and empty
+	unsigned int m_uiWriteStatusReq;
+	unsigned int m_uiReadStatusReq;
+
+	unsigned int m_auiQueueCnRequests[254 * 2];
+	// first 254 entries represent the generic requests of the corresponding node
+	// second 254 entries represent the NMT requests of the corresponding node
+	unsigned int m_uiNextQueueCnRequest;
+	unsigned int m_uiNextRequestQueue;
 #endif
 
 } tEplDllkCalInstance;
@@ -178,13 +175,12 @@ typedef struct
 
 // if no dynamic memory allocation shall be used
 // define structures statically
-static tEplDllkCalInstance     EplDllkCalInstance_g;
+static tEplDllkCalInstance EplDllkCalInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -208,10 +204,10 @@ static tEplDllkCalInstance     EplDllkCa
 
 tEplKernel EplDllkCalAddInstance()
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 #ifndef EPL_NO_FIFO
-tShbError       ShbError;
-unsigned int    fShbNewCreated;
+	tShbError ShbError;
+	unsigned int fShbNewCreated;
 
 /*    ShbError = ShbCirAllocBuffer (EPL_DLLCAL_BUFFER_SIZE_RX, EPL_DLLCAL_BUFFER_ID_RX,
         &EplDllkCalInstance_g.m_ShbInstanceRx, &fShbNewCreated);
@@ -222,14 +218,16 @@ unsigned int    fShbNewCreated;
         Ret = kEplNoResource;
     }
 */
-    ShbError = ShbCirAllocBuffer (EPL_DLLCAL_BUFFER_SIZE_TX_NMT, EPL_DLLCAL_BUFFER_ID_TX_NMT,
-        &EplDllkCalInstance_g.m_ShbInstanceTxNmt, &fShbNewCreated);
-    // returns kShbOk, kShbOpenMismatch, kShbOutOfMem or kShbInvalidArg
-
-    if (ShbError != kShbOk)
-    {
-        Ret = kEplNoResource;
-    }
+	ShbError =
+	    ShbCirAllocBuffer(EPL_DLLCAL_BUFFER_SIZE_TX_NMT,
+			      EPL_DLLCAL_BUFFER_ID_TX_NMT,
+			      &EplDllkCalInstance_g.m_ShbInstanceTxNmt,
+			      &fShbNewCreated);
+	// returns kShbOk, kShbOpenMismatch, kShbOutOfMem or kShbInvalidArg
+
+	if (ShbError != kShbOk) {
+		Ret = kEplNoResource;
+	}
 
 /*    ShbError = ShbCirSetSignalHandlerNewData (EplDllkCalInstance_g.m_ShbInstanceTxNmt, EplDllkCalTxNmtSignalHandler, kShbPriorityNormal);
     // returns kShbOk, kShbAlreadySignaling or kShbInvalidArg
@@ -239,14 +237,16 @@ unsigned int    fShbNewCreated;
         Ret = kEplNoResource;
     }
 */
-    ShbError = ShbCirAllocBuffer (EPL_DLLCAL_BUFFER_SIZE_TX_GEN, EPL_DLLCAL_BUFFER_ID_TX_GEN,
-        &EplDllkCalInstance_g.m_ShbInstanceTxGen, &fShbNewCreated);
-    // returns kShbOk, kShbOpenMismatch, kShbOutOfMem or kShbInvalidArg
-
-    if (ShbError != kShbOk)
-    {
-        Ret = kEplNoResource;
-    }
+	ShbError =
+	    ShbCirAllocBuffer(EPL_DLLCAL_BUFFER_SIZE_TX_GEN,
+			      EPL_DLLCAL_BUFFER_ID_TX_GEN,
+			      &EplDllkCalInstance_g.m_ShbInstanceTxGen,
+			      &fShbNewCreated);
+	// returns kShbOk, kShbOpenMismatch, kShbOutOfMem or kShbInvalidArg
+
+	if (ShbError != kShbOk) {
+		Ret = kEplNoResource;
+	}
 
 /*    ShbError = ShbCirSetSignalHandlerNewData (EplDllkCalInstance_g.m_ShbInstanceTxGen, EplDllkCalTxGenSignalHandler, kShbPriorityNormal);
     // returns kShbOk, kShbAlreadySignaling or kShbInvalidArg
@@ -257,11 +257,11 @@ unsigned int    fShbNewCreated;
     }
 */
 #else
-    EplDllkCalInstance_g.m_uiFrameSizeNmt = 0;
-    EplDllkCalInstance_g.m_uiFrameSizeGen = 0;
+	EplDllkCalInstance_g.m_uiFrameSizeNmt = 0;
+	EplDllkCalInstance_g.m_uiFrameSizeGen = 0;
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -281,9 +281,9 @@ unsigned int    fShbNewCreated;
 
 tEplKernel EplDllkCalDelInstance()
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 #ifndef EPL_NO_FIFO
-tShbError       ShbError;
+	tShbError ShbError;
 
 /*    ShbError = ShbCirReleaseBuffer (EplDllkCalInstance_g.m_ShbInstanceRx);
     if (ShbError != kShbOk)
@@ -292,26 +292,24 @@ tShbError       ShbError;
     }
     EplDllkCalInstance_g.m_ShbInstanceRx = NULL;
 */
-    ShbError = ShbCirReleaseBuffer (EplDllkCalInstance_g.m_ShbInstanceTxNmt);
-    if (ShbError != kShbOk)
-    {
-        Ret = kEplNoResource;
-    }
-    EplDllkCalInstance_g.m_ShbInstanceTxNmt = NULL;
-
-    ShbError = ShbCirReleaseBuffer (EplDllkCalInstance_g.m_ShbInstanceTxGen);
-    if (ShbError != kShbOk)
-    {
-        Ret = kEplNoResource;
-    }
-    EplDllkCalInstance_g.m_ShbInstanceTxGen = NULL;
+	ShbError = ShbCirReleaseBuffer(EplDllkCalInstance_g.m_ShbInstanceTxNmt);
+	if (ShbError != kShbOk) {
+		Ret = kEplNoResource;
+	}
+	EplDllkCalInstance_g.m_ShbInstanceTxNmt = NULL;
+
+	ShbError = ShbCirReleaseBuffer(EplDllkCalInstance_g.m_ShbInstanceTxGen);
+	if (ShbError != kShbOk) {
+		Ret = kEplNoResource;
+	}
+	EplDllkCalInstance_g.m_ShbInstanceTxGen = NULL;
 
 #else
-    EplDllkCalInstance_g.m_uiFrameSizeNmt = 0;
-    EplDllkCalInstance_g.m_uiFrameSizeGen = 0;
+	EplDllkCalInstance_g.m_uiFrameSizeNmt = 0;
+	EplDllkCalInstance_g.m_uiFrameSizeGen = 0;
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -331,92 +329,98 @@ tShbError       ShbError;
 
 tEplKernel EplDllkCalProcess(tEplEvent * pEvent_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    switch (pEvent_p->m_EventType)
-    {
-        case kEplEventTypeDllkServFilter:
-        {
-        tEplDllCalAsndServiceIdFilter*  pServFilter;
-
-            pServFilter = (tEplDllCalAsndServiceIdFilter*) pEvent_p->m_pArg;
-            Ret = EplDllkSetAsndServiceIdFilter(pServFilter->m_ServiceId, pServFilter->m_Filter);
-            break;
-        }
+	switch (pEvent_p->m_EventType) {
+	case kEplEventTypeDllkServFilter:
+		{
+			tEplDllCalAsndServiceIdFilter *pServFilter;
+
+			pServFilter =
+			    (tEplDllCalAsndServiceIdFilter *) pEvent_p->m_pArg;
+			Ret =
+			    EplDllkSetAsndServiceIdFilter(pServFilter->
+							  m_ServiceId,
+							  pServFilter->
+							  m_Filter);
+			break;
+		}
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-        case kEplEventTypeDllkIssueReq:
-        {
-        tEplDllCalIssueRequest*  pIssueReq;
-
-            pIssueReq = (tEplDllCalIssueRequest*) pEvent_p->m_pArg;
-            Ret = EplDllkCalIssueRequest(pIssueReq->m_Service, pIssueReq->m_uiNodeId, pIssueReq->m_bSoaFlag1);
-            break;
-        }
-
-        case kEplEventTypeDllkAddNode:
-        {
-        tEplDllNodeInfo*    pNodeInfo;
-
-            pNodeInfo = (tEplDllNodeInfo*) pEvent_p->m_pArg;
-            Ret = EplDllkAddNode(pNodeInfo);
-            break;
-        }
-
-        case kEplEventTypeDllkDelNode:
-        {
-        unsigned int*   puiNodeId;
-
-            puiNodeId = (unsigned int*) pEvent_p->m_pArg;
-            Ret = EplDllkDeleteNode(*puiNodeId);
-            break;
-        }
-
-        case kEplEventTypeDllkSoftDelNode:
-        {
-        unsigned int*   puiNodeId;
-
-            puiNodeId = (unsigned int*) pEvent_p->m_pArg;
-            Ret = EplDllkSoftDeleteNode(*puiNodeId);
-            break;
-        }
+	case kEplEventTypeDllkIssueReq:
+		{
+			tEplDllCalIssueRequest *pIssueReq;
+
+			pIssueReq = (tEplDllCalIssueRequest *) pEvent_p->m_pArg;
+			Ret =
+			    EplDllkCalIssueRequest(pIssueReq->m_Service,
+						   pIssueReq->m_uiNodeId,
+						   pIssueReq->m_bSoaFlag1);
+			break;
+		}
+
+	case kEplEventTypeDllkAddNode:
+		{
+			tEplDllNodeInfo *pNodeInfo;
+
+			pNodeInfo = (tEplDllNodeInfo *) pEvent_p->m_pArg;
+			Ret = EplDllkAddNode(pNodeInfo);
+			break;
+		}
+
+	case kEplEventTypeDllkDelNode:
+		{
+			unsigned int *puiNodeId;
+
+			puiNodeId = (unsigned int *)pEvent_p->m_pArg;
+			Ret = EplDllkDeleteNode(*puiNodeId);
+			break;
+		}
+
+	case kEplEventTypeDllkSoftDelNode:
+		{
+			unsigned int *puiNodeId;
+
+			puiNodeId = (unsigned int *)pEvent_p->m_pArg;
+			Ret = EplDllkSoftDeleteNode(*puiNodeId);
+			break;
+		}
 #endif
 
-        case kEplEventTypeDllkIdentity:
-        {
-        tEplDllIdentParam*  pIdentParam;
-
-            pIdentParam = (tEplDllIdentParam*) pEvent_p->m_pArg;
-            if (pIdentParam->m_uiSizeOfStruct > pEvent_p->m_uiSize)
-            {
-                pIdentParam->m_uiSizeOfStruct = pEvent_p->m_uiSize;
-            }
-            Ret = EplDllkSetIdentity(pIdentParam);
-            break;
-        }
-
-        case kEplEventTypeDllkConfig:
-        {
-        tEplDllConfigParam* pConfigParam;
-
-            pConfigParam = (tEplDllConfigParam*) pEvent_p->m_pArg;
-            if (pConfigParam->m_uiSizeOfStruct > pEvent_p->m_uiSize)
-            {
-                pConfigParam->m_uiSizeOfStruct = pEvent_p->m_uiSize;
-            }
-            Ret = EplDllkConfig(pConfigParam);
-            break;
-        }
-
-        default:
-            break;
-    }
+	case kEplEventTypeDllkIdentity:
+		{
+			tEplDllIdentParam *pIdentParam;
+
+			pIdentParam = (tEplDllIdentParam *) pEvent_p->m_pArg;
+			if (pIdentParam->m_uiSizeOfStruct > pEvent_p->m_uiSize) {
+				pIdentParam->m_uiSizeOfStruct =
+				    pEvent_p->m_uiSize;
+			}
+			Ret = EplDllkSetIdentity(pIdentParam);
+			break;
+		}
+
+	case kEplEventTypeDllkConfig:
+		{
+			tEplDllConfigParam *pConfigParam;
+
+			pConfigParam = (tEplDllConfigParam *) pEvent_p->m_pArg;
+			if (pConfigParam->m_uiSizeOfStruct > pEvent_p->m_uiSize) {
+				pConfigParam->m_uiSizeOfStruct =
+				    pEvent_p->m_uiSize;
+			}
+			Ret = EplDllkConfig(pConfigParam);
+			break;
+		}
+
+	default:
+		break;
+	}
 
 //Exit:
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkCalAsyncGetTxCount()
@@ -432,75 +436,73 @@ tEplKernel      Ret = kEplSuccessful;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkCalAsyncGetTxCount(tEplDllAsyncReqPriority * pPriority_p, unsigned int * puiCount_p)
+tEplKernel EplDllkCalAsyncGetTxCount(tEplDllAsyncReqPriority * pPriority_p,
+				     unsigned int *puiCount_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 #ifndef EPL_NO_FIFO
-tShbError       ShbError;
-unsigned long   ulFrameCount;
-
-    // get frame count of Tx FIFO with NMT request priority
-    ShbError = ShbCirGetReadBlockCount (EplDllkCalInstance_g.m_ShbInstanceTxNmt, &ulFrameCount);
-    // returns kShbOk, kShbInvalidArg
-
-    // error handling
-    if (ShbError != kShbOk)
-    {
-        Ret = kEplNoResource;
-        goto Exit;
-    }
-
-    if (ulFrameCount > EplDllkCalInstance_g.m_Statistics.m_ulMaxTxFrameCountNmt)
-    {
-        EplDllkCalInstance_g.m_Statistics.m_ulMaxTxFrameCountNmt = ulFrameCount;
-    }
-
-    if (ulFrameCount != 0)
-    {   // NMT requests are in queue
-        *pPriority_p = kEplDllAsyncReqPrioNmt;
-        *puiCount_p = (unsigned int) ulFrameCount;
-        goto Exit;
-    }
-
-    // get frame count of Tx FIFO with generic priority
-    ShbError = ShbCirGetReadBlockCount (EplDllkCalInstance_g.m_ShbInstanceTxGen, &ulFrameCount);
-    // returns kShbOk, kShbInvalidArg
-
-    // error handling
-    if (ShbError != kShbOk)
-    {
-        Ret = kEplNoResource;
-        goto Exit;
-    }
+	tShbError ShbError;
+	unsigned long ulFrameCount;
 
-    if (ulFrameCount > EplDllkCalInstance_g.m_Statistics.m_ulMaxTxFrameCountGen)
-    {
-        EplDllkCalInstance_g.m_Statistics.m_ulMaxTxFrameCountGen = ulFrameCount;
-    }
+	// get frame count of Tx FIFO with NMT request priority
+	ShbError =
+	    ShbCirGetReadBlockCount(EplDllkCalInstance_g.m_ShbInstanceTxNmt,
+				    &ulFrameCount);
+	// returns kShbOk, kShbInvalidArg
+
+	// error handling
+	if (ShbError != kShbOk) {
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+
+	if (ulFrameCount >
+	    EplDllkCalInstance_g.m_Statistics.m_ulMaxTxFrameCountNmt) {
+		EplDllkCalInstance_g.m_Statistics.m_ulMaxTxFrameCountNmt =
+		    ulFrameCount;
+	}
+
+	if (ulFrameCount != 0) {	// NMT requests are in queue
+		*pPriority_p = kEplDllAsyncReqPrioNmt;
+		*puiCount_p = (unsigned int)ulFrameCount;
+		goto Exit;
+	}
+	// get frame count of Tx FIFO with generic priority
+	ShbError =
+	    ShbCirGetReadBlockCount(EplDllkCalInstance_g.m_ShbInstanceTxGen,
+				    &ulFrameCount);
+	// returns kShbOk, kShbInvalidArg
+
+	// error handling
+	if (ShbError != kShbOk) {
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+
+	if (ulFrameCount >
+	    EplDllkCalInstance_g.m_Statistics.m_ulMaxTxFrameCountGen) {
+		EplDllkCalInstance_g.m_Statistics.m_ulMaxTxFrameCountGen =
+		    ulFrameCount;
+	}
 
-    *pPriority_p = kEplDllAsyncReqPrioGeneric;
-    *puiCount_p = (unsigned int) ulFrameCount;
+	*pPriority_p = kEplDllAsyncReqPrioGeneric;
+	*puiCount_p = (unsigned int)ulFrameCount;
 
-Exit:
+      Exit:
 #else
-    if (EplDllkCalInstance_g.m_uiFrameSizeNmt > 0)
-    {
-        *pPriority_p = kEplDllAsyncReqPrioNmt;
-        *puiCount_p = 1;
-    }
-    else if (EplDllkCalInstance_g.m_uiFrameSizeGen > 0)
-    {
-        *pPriority_p = kEplDllAsyncReqPrioGeneric;
-        *puiCount_p = 1;
-    }
-    else
-    {
-        *pPriority_p = kEplDllAsyncReqPrioGeneric;
-        *puiCount_p = 0;
-    }
+	if (EplDllkCalInstance_g.m_uiFrameSizeNmt > 0) {
+		*pPriority_p = kEplDllAsyncReqPrioNmt;
+		*puiCount_p = 1;
+	} else if (EplDllkCalInstance_g.m_uiFrameSizeGen > 0) {
+		*pPriority_p = kEplDllAsyncReqPrioGeneric;
+		*puiCount_p = 1;
+	} else {
+		*pPriority_p = kEplDllAsyncReqPrioGeneric;
+		*puiCount_p = 0;
+	}
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -521,63 +523,69 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkCalAsyncGetTxFrame(void * pFrame_p, unsigned int * puiFrameSize_p, tEplDllAsyncReqPriority Priority_p)
+tEplKernel EplDllkCalAsyncGetTxFrame(void *pFrame_p,
+				     unsigned int *puiFrameSize_p,
+				     tEplDllAsyncReqPriority Priority_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 #ifndef EPL_NO_FIFO
-tShbError       ShbError;
-unsigned long   ulFrameSize;
+	tShbError ShbError;
+	unsigned long ulFrameSize;
 
-    switch (Priority_p)
-    {
-        case kEplDllAsyncReqPrioNmt:    // NMT request priority
-            ShbError = ShbCirReadDataBlock (EplDllkCalInstance_g.m_ShbInstanceTxNmt, (BYTE *) pFrame_p, *puiFrameSize_p, &ulFrameSize);
-            // returns kShbOk, kShbDataTruncated, kShbInvalidArg, kShbNoReadableData
-            break;
-
-        default:    // generic priority
-            ShbError = ShbCirReadDataBlock (EplDllkCalInstance_g.m_ShbInstanceTxGen, (BYTE *) pFrame_p, *puiFrameSize_p, &ulFrameSize);
-            // returns kShbOk, kShbDataTruncated, kShbInvalidArg, kShbNoReadableData
-            break;
+	switch (Priority_p) {
+	case kEplDllAsyncReqPrioNmt:	// NMT request priority
+		ShbError =
+		    ShbCirReadDataBlock(EplDllkCalInstance_g.m_ShbInstanceTxNmt,
+					(BYTE *) pFrame_p, *puiFrameSize_p,
+					&ulFrameSize);
+		// returns kShbOk, kShbDataTruncated, kShbInvalidArg, kShbNoReadableData
+		break;
+
+	default:		// generic priority
+		ShbError =
+		    ShbCirReadDataBlock(EplDllkCalInstance_g.m_ShbInstanceTxGen,
+					(BYTE *) pFrame_p, *puiFrameSize_p,
+					&ulFrameSize);
+		// returns kShbOk, kShbDataTruncated, kShbInvalidArg, kShbNoReadableData
+		break;
+
+	}
+
+	// error handling
+	if (ShbError != kShbOk) {
+		if (ShbError == kShbNoReadableData) {
+			Ret = kEplDllAsyncTxBufferEmpty;
+		} else {	// other error
+			Ret = kEplNoResource;
+		}
+		goto Exit;
+	}
 
-    }
+	*puiFrameSize_p = (unsigned int)ulFrameSize;
 
-    // error handling
-    if (ShbError != kShbOk)
-    {
-        if (ShbError == kShbNoReadableData)
-        {
-            Ret = kEplDllAsyncTxBufferEmpty;
-        }
-        else
-        {   // other error
-            Ret = kEplNoResource;
-        }
-        goto Exit;
-    }
-
-    *puiFrameSize_p = (unsigned int) ulFrameSize;
-
-Exit:
+      Exit:
 #else
-    switch (Priority_p)
-    {
-        case kEplDllAsyncReqPrioNmt:    // NMT request priority
-            *puiFrameSize_p = min(*puiFrameSize_p, EplDllkCalInstance_g.m_uiFrameSizeNmt);
-            EPL_MEMCPY(pFrame_p, EplDllkCalInstance_g.m_abFrameNmt, *puiFrameSize_p);
-            EplDllkCalInstance_g.m_uiFrameSizeNmt = 0;
-            break;
-
-        default:    // generic priority
-            *puiFrameSize_p = min(*puiFrameSize_p, EplDllkCalInstance_g.m_uiFrameSizeGen);
-            EPL_MEMCPY(pFrame_p, EplDllkCalInstance_g.m_abFrameGen, *puiFrameSize_p);
-            EplDllkCalInstance_g.m_uiFrameSizeGen = 0;
-            break;
-    }
+	switch (Priority_p) {
+	case kEplDllAsyncReqPrioNmt:	// NMT request priority
+		*puiFrameSize_p =
+		    min(*puiFrameSize_p, EplDllkCalInstance_g.m_uiFrameSizeNmt);
+		EPL_MEMCPY(pFrame_p, EplDllkCalInstance_g.m_abFrameNmt,
+			   *puiFrameSize_p);
+		EplDllkCalInstance_g.m_uiFrameSizeNmt = 0;
+		break;
+
+	default:		// generic priority
+		*puiFrameSize_p =
+		    min(*puiFrameSize_p, EplDllkCalInstance_g.m_uiFrameSizeGen);
+		EPL_MEMCPY(pFrame_p, EplDllkCalInstance_g.m_abFrameGen,
+			   *puiFrameSize_p);
+		EplDllkCalInstance_g.m_uiFrameSizeGen = 0;
+		break;
+	}
 
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -598,30 +606,26 @@ Exit:
 
 tEplKernel EplDllkCalAsyncFrameReceived(tEplFrameInfo * pFrameInfo_p)
 {
-tEplKernel  Ret = kEplSuccessful;
-tEplEvent   Event;
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
 
-    Event.m_EventSink = kEplEventSinkDlluCal;
-    Event.m_EventType = kEplEventTypeAsndRx;
-    Event.m_pArg = pFrameInfo_p->m_pFrame;
-    Event.m_uiSize = pFrameInfo_p->m_uiFrameSize;
-    // pass NetTime of frame to userspace
-    Event.m_NetTime = pFrameInfo_p->m_NetTime;
+	Event.m_EventSink = kEplEventSinkDlluCal;
+	Event.m_EventType = kEplEventTypeAsndRx;
+	Event.m_pArg = pFrameInfo_p->m_pFrame;
+	Event.m_uiSize = pFrameInfo_p->m_uiFrameSize;
+	// pass NetTime of frame to userspace
+	Event.m_NetTime = pFrameInfo_p->m_NetTime;
+
+	Ret = EplEventkPost(&Event);
+	if (Ret != kEplSuccessful) {
+		EplDllkCalInstance_g.m_Statistics.m_ulCurRxFrameCount++;
+	} else {
+		EplDllkCalInstance_g.m_Statistics.m_ulMaxRxFrameCount++;
+	}
 
-    Ret = EplEventkPost(&Event);
-    if (Ret != kEplSuccessful)
-    {
-        EplDllkCalInstance_g.m_Statistics.m_ulCurRxFrameCount++;
-    }
-    else
-    {
-        EplDllkCalInstance_g.m_Statistics.m_ulMaxRxFrameCount++;
-    }
-
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkCalAsyncSend()
@@ -639,96 +643,101 @@ tEplEvent   Event;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkCalAsyncSend(tEplFrameInfo * pFrameInfo_p, tEplDllAsyncReqPriority Priority_p)
+tEplKernel EplDllkCalAsyncSend(tEplFrameInfo * pFrameInfo_p,
+			       tEplDllAsyncReqPriority Priority_p)
 {
-tEplKernel  Ret = kEplSuccessful;
-tEplEvent       Event;
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
 #ifndef EPL_NO_FIFO
-tShbError   ShbError;
-
-    switch (Priority_p)
-    {
-        case kEplDllAsyncReqPrioNmt:    // NMT request priority
-            ShbError = ShbCirWriteDataBlock (EplDllkCalInstance_g.m_ShbInstanceTxNmt, pFrameInfo_p->m_pFrame, pFrameInfo_p->m_uiFrameSize);
-            // returns kShbOk, kShbExceedDataSizeLimit, kShbBufferFull, kShbInvalidArg
-            break;
-
-        default:    // generic priority
-            ShbError = ShbCirWriteDataBlock (EplDllkCalInstance_g.m_ShbInstanceTxGen, pFrameInfo_p->m_pFrame, pFrameInfo_p->m_uiFrameSize);
-            // returns kShbOk, kShbExceedDataSizeLimit, kShbBufferFull, kShbInvalidArg
-            break;
-
-    }
-
-    // error handling
-    switch (ShbError)
-    {
-        case kShbOk:
-            break;
+	tShbError ShbError;
 
-        case kShbExceedDataSizeLimit:
-            Ret = kEplDllAsyncTxBufferFull;
-            break;
-
-        case kShbBufferFull:
-            Ret = kEplDllAsyncTxBufferFull;
-            break;
-
-        case kShbInvalidArg:
-        default:
-            Ret = kEplNoResource;
-            break;
-    }
+	switch (Priority_p) {
+	case kEplDllAsyncReqPrioNmt:	// NMT request priority
+		ShbError =
+		    ShbCirWriteDataBlock(EplDllkCalInstance_g.
+					 m_ShbInstanceTxNmt,
+					 pFrameInfo_p->m_pFrame,
+					 pFrameInfo_p->m_uiFrameSize);
+		// returns kShbOk, kShbExceedDataSizeLimit, kShbBufferFull, kShbInvalidArg
+		break;
+
+	default:		// generic priority
+		ShbError =
+		    ShbCirWriteDataBlock(EplDllkCalInstance_g.
+					 m_ShbInstanceTxGen,
+					 pFrameInfo_p->m_pFrame,
+					 pFrameInfo_p->m_uiFrameSize);
+		// returns kShbOk, kShbExceedDataSizeLimit, kShbBufferFull, kShbInvalidArg
+		break;
+
+	}
+
+	// error handling
+	switch (ShbError) {
+	case kShbOk:
+		break;
+
+	case kShbExceedDataSizeLimit:
+		Ret = kEplDllAsyncTxBufferFull;
+		break;
+
+	case kShbBufferFull:
+		Ret = kEplDllAsyncTxBufferFull;
+		break;
+
+	case kShbInvalidArg:
+	default:
+		Ret = kEplNoResource;
+		break;
+	}
 
 #else
 
-    switch (Priority_p)
-    {
-        case kEplDllAsyncReqPrioNmt:    // NMT request priority
-            if (EplDllkCalInstance_g.m_uiFrameSizeNmt == 0)
-            {
-                EPL_MEMCPY(EplDllkCalInstance_g.m_abFrameNmt, pFrameInfo_p->m_pFrame, pFrameInfo_p->m_uiFrameSize);
-                EplDllkCalInstance_g.m_uiFrameSizeNmt = pFrameInfo_p->m_uiFrameSize;
-            }
-            else
-            {
-                Ret = kEplDllAsyncTxBufferFull;
-                goto Exit;
-            }
-            break;
-
-        default:    // generic priority
-            if (EplDllkCalInstance_g.m_uiFrameSizeGen == 0)
-            {
-                EPL_MEMCPY(EplDllkCalInstance_g.m_abFrameGen, pFrameInfo_p->m_pFrame, pFrameInfo_p->m_uiFrameSize);
-                EplDllkCalInstance_g.m_uiFrameSizeGen = pFrameInfo_p->m_uiFrameSize;
-            }
-            else
-            {
-                Ret = kEplDllAsyncTxBufferFull;
-                goto Exit;
-            }
-            break;
-    }
+	switch (Priority_p) {
+	case kEplDllAsyncReqPrioNmt:	// NMT request priority
+		if (EplDllkCalInstance_g.m_uiFrameSizeNmt == 0) {
+			EPL_MEMCPY(EplDllkCalInstance_g.m_abFrameNmt,
+				   pFrameInfo_p->m_pFrame,
+				   pFrameInfo_p->m_uiFrameSize);
+			EplDllkCalInstance_g.m_uiFrameSizeNmt =
+			    pFrameInfo_p->m_uiFrameSize;
+		} else {
+			Ret = kEplDllAsyncTxBufferFull;
+			goto Exit;
+		}
+		break;
+
+	default:		// generic priority
+		if (EplDllkCalInstance_g.m_uiFrameSizeGen == 0) {
+			EPL_MEMCPY(EplDllkCalInstance_g.m_abFrameGen,
+				   pFrameInfo_p->m_pFrame,
+				   pFrameInfo_p->m_uiFrameSize);
+			EplDllkCalInstance_g.m_uiFrameSizeGen =
+			    pFrameInfo_p->m_uiFrameSize;
+		} else {
+			Ret = kEplDllAsyncTxBufferFull;
+			goto Exit;
+		}
+		break;
+	}
 
 #endif
 
-    // post event to DLL
-    Event.m_EventSink = kEplEventSinkDllk;
-    Event.m_EventType = kEplEventTypeDllkFillTx;
-    EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
-    Event.m_pArg = &Priority_p;
-    Event.m_uiSize = sizeof(Priority_p);
-    Ret = EplEventkPost(&Event);
+	// post event to DLL
+	Event.m_EventSink = kEplEventSinkDllk;
+	Event.m_EventType = kEplEventTypeDllkFillTx;
+	EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
+	Event.m_pArg = &Priority_p;
+	Event.m_uiSize = sizeof(Priority_p);
+	Ret = EplEventkPost(&Event);
 
 #ifdef EPL_NO_FIFO
-Exit:
+      Exit:
 #endif
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkCalAsyncClearBuffer()
@@ -746,23 +755,26 @@ Exit:
 
 tEplKernel EplDllkCalAsyncClearBuffer(void)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 #ifndef EPL_NO_FIFO
-tShbError   ShbError;
+	tShbError ShbError;
 
-    ShbError = ShbCirResetBuffer (EplDllkCalInstance_g.m_ShbInstanceTxNmt, 1000, NULL);
-    ShbError = ShbCirResetBuffer (EplDllkCalInstance_g.m_ShbInstanceTxGen, 1000, NULL);
+	ShbError =
+	    ShbCirResetBuffer(EplDllkCalInstance_g.m_ShbInstanceTxNmt, 1000,
+			      NULL);
+	ShbError =
+	    ShbCirResetBuffer(EplDllkCalInstance_g.m_ShbInstanceTxGen, 1000,
+			      NULL);
 
 #else
-    EplDllkCalInstance_g.m_uiFrameSizeNmt = 0;
-    EplDllkCalInstance_g.m_uiFrameSizeGen = 0;
+	EplDllkCalInstance_g.m_uiFrameSizeNmt = 0;
+	EplDllkCalInstance_g.m_uiFrameSizeGen = 0;
 #endif
 
 //    EPL_MEMSET(&EplDllkCalInstance_g.m_Statistics, 0, sizeof (tEplDllkCalStatistics));
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkCalAsyncClearQueues()
@@ -781,21 +793,20 @@ tShbError   ShbError;
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 tEplKernel EplDllkCalAsyncClearQueues(void)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    // clear MN asynchronous queues
-    EplDllkCalInstance_g.m_uiNextQueueCnRequest = 0;
-    EplDllkCalInstance_g.m_uiNextRequestQueue = 0;
-    EplDllkCalInstance_g.m_uiReadIdentReq = 0;
-    EplDllkCalInstance_g.m_uiWriteIdentReq = 0;
-    EplDllkCalInstance_g.m_uiReadStatusReq = 0;
-    EplDllkCalInstance_g.m_uiWriteStatusReq = 0;
+	// clear MN asynchronous queues
+	EplDllkCalInstance_g.m_uiNextQueueCnRequest = 0;
+	EplDllkCalInstance_g.m_uiNextRequestQueue = 0;
+	EplDllkCalInstance_g.m_uiReadIdentReq = 0;
+	EplDllkCalInstance_g.m_uiWriteIdentReq = 0;
+	EplDllkCalInstance_g.m_uiReadStatusReq = 0;
+	EplDllkCalInstance_g.m_uiWriteStatusReq = 0;
 
-    return Ret;
+	return Ret;
 }
 #endif
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkCalGetStatistics()
@@ -813,38 +824,37 @@ tEplKernel  Ret = kEplSuccessful;
 
 tEplKernel EplDllkCalGetStatistics(tEplDllkCalStatistics ** ppStatistics)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 #ifndef EPL_NO_FIFO
-tShbError   ShbError;
+	tShbError ShbError;
 
-    ShbError = ShbCirGetReadBlockCount (EplDllkCalInstance_g.m_ShbInstanceTxNmt, &EplDllkCalInstance_g.m_Statistics.m_ulCurTxFrameCountNmt);
-    ShbError = ShbCirGetReadBlockCount (EplDllkCalInstance_g.m_ShbInstanceTxGen, &EplDllkCalInstance_g.m_Statistics.m_ulCurTxFrameCountGen);
+	ShbError =
+	    ShbCirGetReadBlockCount(EplDllkCalInstance_g.m_ShbInstanceTxNmt,
+				    &EplDllkCalInstance_g.m_Statistics.
+				    m_ulCurTxFrameCountNmt);
+	ShbError =
+	    ShbCirGetReadBlockCount(EplDllkCalInstance_g.m_ShbInstanceTxGen,
+				    &EplDllkCalInstance_g.m_Statistics.
+				    m_ulCurTxFrameCountGen);
 //    ShbError = ShbCirGetReadBlockCount (EplDllkCalInstance_g.m_ShbInstanceRx, &EplDllkCalInstance_g.m_Statistics.m_ulCurRxFrameCount);
 
 #else
-    if (EplDllkCalInstance_g.m_uiFrameSizeNmt > 0)
-    {
-        EplDllkCalInstance_g.m_Statistics.m_ulCurTxFrameCountNmt = 1;
-    }
-    else
-    {
-        EplDllkCalInstance_g.m_Statistics.m_ulCurTxFrameCountNmt = 0;
-    }
-    if (EplDllkCalInstance_g.m_uiFrameSizeGen > 0)
-    {
-        EplDllkCalInstance_g.m_Statistics.m_ulCurTxFrameCountGen = 1;
-    }
-    else
-    {
-        EplDllkCalInstance_g.m_Statistics.m_ulCurTxFrameCountGen = 0;
-    }
+	if (EplDllkCalInstance_g.m_uiFrameSizeNmt > 0) {
+		EplDllkCalInstance_g.m_Statistics.m_ulCurTxFrameCountNmt = 1;
+	} else {
+		EplDllkCalInstance_g.m_Statistics.m_ulCurTxFrameCountNmt = 0;
+	}
+	if (EplDllkCalInstance_g.m_uiFrameSizeGen > 0) {
+		EplDllkCalInstance_g.m_Statistics.m_ulCurTxFrameCountGen = 1;
+	} else {
+		EplDllkCalInstance_g.m_Statistics.m_ulCurTxFrameCountGen = 0;
+	}
 #endif
 
-    *ppStatistics = &EplDllkCalInstance_g.m_Statistics;
-    return Ret;
+	*ppStatistics = &EplDllkCalInstance_g.m_Statistics;
+	return Ret;
 }
 
-
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
 //---------------------------------------------------------------------------
@@ -865,62 +875,72 @@ tShbError   ShbError;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkCalIssueRequest(tEplDllReqServiceId Service_p, unsigned int uiNodeId_p, BYTE bSoaFlag1_p)
+tEplKernel EplDllkCalIssueRequest(tEplDllReqServiceId Service_p,
+				  unsigned int uiNodeId_p, BYTE bSoaFlag1_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    if (bSoaFlag1_p != 0xFF)
-    {
-        Ret = EplDllkSetFlag1OfNode(uiNodeId_p, bSoaFlag1_p);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-    }
-
-    // add node to appropriate request queue
-    switch (Service_p)
-    {
-        case kEplDllReqServiceIdent:
-        {
-            if (((EplDllkCalInstance_g.m_uiWriteIdentReq + 1) % tabentries (EplDllkCalInstance_g.m_auiQueueIdentReq))
-                == EplDllkCalInstance_g.m_uiReadIdentReq)
-            {   // queue is full
-                Ret = kEplDllAsyncTxBufferFull;
-                goto Exit;
-            }
-            EplDllkCalInstance_g.m_auiQueueIdentReq[EplDllkCalInstance_g.m_uiWriteIdentReq] = uiNodeId_p;
-            EplDllkCalInstance_g.m_uiWriteIdentReq =
-                (EplDllkCalInstance_g.m_uiWriteIdentReq + 1) % tabentries (EplDllkCalInstance_g.m_auiQueueIdentReq);
-            break;
-        }
-
-        case kEplDllReqServiceStatus:
-        {
-            if (((EplDllkCalInstance_g.m_uiWriteStatusReq + 1) % tabentries (EplDllkCalInstance_g.m_auiQueueStatusReq))
-                == EplDllkCalInstance_g.m_uiReadStatusReq)
-            {   // queue is full
-                Ret = kEplDllAsyncTxBufferFull;
-                goto Exit;
-            }
-            EplDllkCalInstance_g.m_auiQueueStatusReq[EplDllkCalInstance_g.m_uiWriteStatusReq] = uiNodeId_p;
-            EplDllkCalInstance_g.m_uiWriteStatusReq =
-                (EplDllkCalInstance_g.m_uiWriteStatusReq + 1) % tabentries (EplDllkCalInstance_g.m_auiQueueStatusReq);
-            break;
-        }
-
-        default:
-        {
-            Ret = kEplDllInvalidParam;
-            goto Exit;
-        }
-    }
+	if (bSoaFlag1_p != 0xFF) {
+		Ret = EplDllkSetFlag1OfNode(uiNodeId_p, bSoaFlag1_p);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+	}
+	// add node to appropriate request queue
+	switch (Service_p) {
+	case kEplDllReqServiceIdent:
+		{
+			if (((EplDllkCalInstance_g.m_uiWriteIdentReq +
+			      1) %
+			     tabentries(EplDllkCalInstance_g.
+					m_auiQueueIdentReq))
+			    == EplDllkCalInstance_g.m_uiReadIdentReq) {	// queue is full
+				Ret = kEplDllAsyncTxBufferFull;
+				goto Exit;
+			}
+			EplDllkCalInstance_g.
+			    m_auiQueueIdentReq[EplDllkCalInstance_g.
+					       m_uiWriteIdentReq] = uiNodeId_p;
+			EplDllkCalInstance_g.m_uiWriteIdentReq =
+			    (EplDllkCalInstance_g.m_uiWriteIdentReq +
+			     1) %
+			    tabentries(EplDllkCalInstance_g.m_auiQueueIdentReq);
+			break;
+		}
+
+	case kEplDllReqServiceStatus:
+		{
+			if (((EplDllkCalInstance_g.m_uiWriteStatusReq +
+			      1) %
+			     tabentries(EplDllkCalInstance_g.
+					m_auiQueueStatusReq))
+			    == EplDllkCalInstance_g.m_uiReadStatusReq) {	// queue is full
+				Ret = kEplDllAsyncTxBufferFull;
+				goto Exit;
+			}
+			EplDllkCalInstance_g.
+			    m_auiQueueStatusReq[EplDllkCalInstance_g.
+						m_uiWriteStatusReq] =
+			    uiNodeId_p;
+			EplDllkCalInstance_g.m_uiWriteStatusReq =
+			    (EplDllkCalInstance_g.m_uiWriteStatusReq +
+			     1) %
+			    tabentries(EplDllkCalInstance_g.
+				       m_auiQueueStatusReq);
+			break;
+		}
+
+	default:
+		{
+			Ret = kEplDllInvalidParam;
+			goto Exit;
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDllkCalAsyncGetSoaRequest()
@@ -941,118 +961,161 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkCalAsyncGetSoaRequest(tEplDllReqServiceId* pReqServiceId_p, unsigned int* puiNodeId_p)
+tEplKernel EplDllkCalAsyncGetSoaRequest(tEplDllReqServiceId * pReqServiceId_p,
+					unsigned int *puiNodeId_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-unsigned int    uiCount;
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiCount;
 
 //    *pReqServiceId_p = kEplDllReqServiceNo;
 
-    for (uiCount = EPL_DLLKCAL_MAX_QUEUES; uiCount > 0; uiCount--)
-    {
-        switch (EplDllkCalInstance_g.m_uiNextRequestQueue)
-        {
-            case 0:
-            {   // CnGenReq
-                for (;EplDllkCalInstance_g.m_uiNextQueueCnRequest < (tabentries (EplDllkCalInstance_g.m_auiQueueCnRequests) / 2);
-                    EplDllkCalInstance_g.m_uiNextQueueCnRequest++)
-                {
-                    if (EplDllkCalInstance_g.m_auiQueueCnRequests[EplDllkCalInstance_g.m_uiNextQueueCnRequest] > 0)
-                    {   // non empty queue found
-                        // remove one request from queue
-                        EplDllkCalInstance_g.m_auiQueueCnRequests[EplDllkCalInstance_g.m_uiNextQueueCnRequest]--;
-                        *puiNodeId_p = EplDllkCalInstance_g.m_uiNextQueueCnRequest + 1;
-                        *pReqServiceId_p = kEplDllReqServiceUnspecified;
-                        EplDllkCalInstance_g.m_uiNextQueueCnRequest++;
-                        if (EplDllkCalInstance_g.m_uiNextQueueCnRequest >= (tabentries (EplDllkCalInstance_g.m_auiQueueCnRequests) / 2))
-                        {   // last node reached
-                            // continue with CnNmtReq queue at next SoA
-                            EplDllkCalInstance_g.m_uiNextRequestQueue = 1;
-                        }
-                        goto Exit;
-                    }
-                }
-                // all CnGenReq queues are empty -> continue with CnNmtReq queue
-                EplDllkCalInstance_g.m_uiNextRequestQueue = 1;
-                break;
-            }
-
-            case 1:
-            {   // CnNmtReq
-                for (;EplDllkCalInstance_g.m_uiNextQueueCnRequest < tabentries (EplDllkCalInstance_g.m_auiQueueCnRequests);
-                    EplDllkCalInstance_g.m_uiNextQueueCnRequest++)
-                {
-                    if (EplDllkCalInstance_g.m_auiQueueCnRequests[EplDllkCalInstance_g.m_uiNextQueueCnRequest] > 0)
-                    {   // non empty queue found
-                        // remove one request from queue
-                        EplDllkCalInstance_g.m_auiQueueCnRequests[EplDllkCalInstance_g.m_uiNextQueueCnRequest]--;
-                        *puiNodeId_p = EplDllkCalInstance_g.m_uiNextQueueCnRequest + 1 - (tabentries (EplDllkCalInstance_g.m_auiQueueCnRequests) / 2);
-                        *pReqServiceId_p = kEplDllReqServiceNmtRequest;
-                        EplDllkCalInstance_g.m_uiNextQueueCnRequest++;
-                        if (EplDllkCalInstance_g.m_uiNextQueueCnRequest > tabentries (EplDllkCalInstance_g.m_auiQueueCnRequests))
-                        {   // last node reached
-                            // restart CnGenReq queue
-                            EplDllkCalInstance_g.m_uiNextQueueCnRequest = 0;
-                            // continue with MnGenReq queue at next SoA
-                            EplDllkCalInstance_g.m_uiNextRequestQueue = 2;
-                        }
-                        goto Exit;
-                    }
-                }
-                // restart CnGenReq queue
-                EplDllkCalInstance_g.m_uiNextQueueCnRequest = 0;
-                // all CnNmtReq queues are empty -> continue with MnGenReq queue
-                EplDllkCalInstance_g.m_uiNextRequestQueue = 2;
-                break;
-            }
-
-            case 2:
-            {   // MnNmtReq and MnGenReq
-                // next queue will be MnIdentReq queue
-                EplDllkCalInstance_g.m_uiNextRequestQueue = 3;
-                if (*pReqServiceId_p != kEplDllReqServiceNo)
-                {
-                    *puiNodeId_p = EPL_C_ADR_INVALID;   // DLLk must exchange this with the actual node ID
-                    goto Exit;
-                }
-                break;
-            }
-
-            case 3:
-            {   // MnIdentReq
-                // next queue will be MnStatusReq queue
-                EplDllkCalInstance_g.m_uiNextRequestQueue = 4;
-                if (EplDllkCalInstance_g.m_uiReadIdentReq != EplDllkCalInstance_g.m_uiWriteIdentReq)
-                {   // queue is not empty
-                    *puiNodeId_p = EplDllkCalInstance_g.m_auiQueueIdentReq[EplDllkCalInstance_g.m_uiReadIdentReq];
-                    EplDllkCalInstance_g.m_uiReadIdentReq =
-                        (EplDllkCalInstance_g.m_uiReadIdentReq + 1) % tabentries (EplDllkCalInstance_g.m_auiQueueIdentReq);
-                    *pReqServiceId_p = kEplDllReqServiceIdent;
-                    goto Exit;
-                }
-                break;
-            }
-
-            case 4:
-            {   // MnStatusReq
-                // next queue will be CnGenReq queue
-                EplDllkCalInstance_g.m_uiNextRequestQueue = 0;
-                if (EplDllkCalInstance_g.m_uiReadStatusReq != EplDllkCalInstance_g.m_uiWriteStatusReq)
-                {   // queue is not empty
-                    *puiNodeId_p = EplDllkCalInstance_g.m_auiQueueStatusReq[EplDllkCalInstance_g.m_uiReadStatusReq];
-                    EplDllkCalInstance_g.m_uiReadStatusReq =
-                        (EplDllkCalInstance_g.m_uiReadStatusReq + 1) % tabentries (EplDllkCalInstance_g.m_auiQueueStatusReq);
-                    *pReqServiceId_p = kEplDllReqServiceStatus;
-                    goto Exit;
-                }
-                break;
-            }
+	for (uiCount = EPL_DLLKCAL_MAX_QUEUES; uiCount > 0; uiCount--) {
+		switch (EplDllkCalInstance_g.m_uiNextRequestQueue) {
+		case 0:
+			{	// CnGenReq
+				for (;
+				     EplDllkCalInstance_g.
+				     m_uiNextQueueCnRequest <
+				     (tabentries
+				      (EplDllkCalInstance_g.
+				       m_auiQueueCnRequests) / 2);
+				     EplDllkCalInstance_g.
+				     m_uiNextQueueCnRequest++) {
+					if (EplDllkCalInstance_g.m_auiQueueCnRequests[EplDllkCalInstance_g.m_uiNextQueueCnRequest] > 0) {	// non empty queue found
+						// remove one request from queue
+						EplDllkCalInstance_g.
+						    m_auiQueueCnRequests
+						    [EplDllkCalInstance_g.
+						     m_uiNextQueueCnRequest]--;
+						*puiNodeId_p =
+						    EplDllkCalInstance_g.
+						    m_uiNextQueueCnRequest + 1;
+						*pReqServiceId_p =
+						    kEplDllReqServiceUnspecified;
+						EplDllkCalInstance_g.
+						    m_uiNextQueueCnRequest++;
+						if (EplDllkCalInstance_g.m_uiNextQueueCnRequest >= (tabentries(EplDllkCalInstance_g.m_auiQueueCnRequests) / 2)) {	// last node reached
+							// continue with CnNmtReq queue at next SoA
+							EplDllkCalInstance_g.
+							    m_uiNextRequestQueue
+							    = 1;
+						}
+						goto Exit;
+					}
+				}
+				// all CnGenReq queues are empty -> continue with CnNmtReq queue
+				EplDllkCalInstance_g.m_uiNextRequestQueue = 1;
+				break;
+			}
+
+		case 1:
+			{	// CnNmtReq
+				for (;
+				     EplDllkCalInstance_g.
+				     m_uiNextQueueCnRequest <
+				     tabentries(EplDllkCalInstance_g.
+						m_auiQueueCnRequests);
+				     EplDllkCalInstance_g.
+				     m_uiNextQueueCnRequest++) {
+					if (EplDllkCalInstance_g.m_auiQueueCnRequests[EplDllkCalInstance_g.m_uiNextQueueCnRequest] > 0) {	// non empty queue found
+						// remove one request from queue
+						EplDllkCalInstance_g.
+						    m_auiQueueCnRequests
+						    [EplDllkCalInstance_g.
+						     m_uiNextQueueCnRequest]--;
+						*puiNodeId_p =
+						    EplDllkCalInstance_g.
+						    m_uiNextQueueCnRequest + 1 -
+						    (tabentries
+						     (EplDllkCalInstance_g.
+						      m_auiQueueCnRequests) /
+						     2);
+						*pReqServiceId_p =
+						    kEplDllReqServiceNmtRequest;
+						EplDllkCalInstance_g.
+						    m_uiNextQueueCnRequest++;
+						if (EplDllkCalInstance_g.m_uiNextQueueCnRequest > tabentries(EplDllkCalInstance_g.m_auiQueueCnRequests)) {	// last node reached
+							// restart CnGenReq queue
+							EplDllkCalInstance_g.
+							    m_uiNextQueueCnRequest
+							    = 0;
+							// continue with MnGenReq queue at next SoA
+							EplDllkCalInstance_g.
+							    m_uiNextRequestQueue
+							    = 2;
+						}
+						goto Exit;
+					}
+				}
+				// restart CnGenReq queue
+				EplDllkCalInstance_g.m_uiNextQueueCnRequest = 0;
+				// all CnNmtReq queues are empty -> continue with MnGenReq queue
+				EplDllkCalInstance_g.m_uiNextRequestQueue = 2;
+				break;
+			}
+
+		case 2:
+			{	// MnNmtReq and MnGenReq
+				// next queue will be MnIdentReq queue
+				EplDllkCalInstance_g.m_uiNextRequestQueue = 3;
+				if (*pReqServiceId_p != kEplDllReqServiceNo) {
+					*puiNodeId_p = EPL_C_ADR_INVALID;	// DLLk must exchange this with the actual node ID
+					goto Exit;
+				}
+				break;
+			}
+
+		case 3:
+			{	// MnIdentReq
+				// next queue will be MnStatusReq queue
+				EplDllkCalInstance_g.m_uiNextRequestQueue = 4;
+				if (EplDllkCalInstance_g.m_uiReadIdentReq != EplDllkCalInstance_g.m_uiWriteIdentReq) {	// queue is not empty
+					*puiNodeId_p =
+					    EplDllkCalInstance_g.
+					    m_auiQueueIdentReq
+					    [EplDllkCalInstance_g.
+					     m_uiReadIdentReq];
+					EplDllkCalInstance_g.m_uiReadIdentReq =
+					    (EplDllkCalInstance_g.
+					     m_uiReadIdentReq +
+					     1) %
+					    tabentries(EplDllkCalInstance_g.
+						       m_auiQueueIdentReq);
+					*pReqServiceId_p =
+					    kEplDllReqServiceIdent;
+					goto Exit;
+				}
+				break;
+			}
+
+		case 4:
+			{	// MnStatusReq
+				// next queue will be CnGenReq queue
+				EplDllkCalInstance_g.m_uiNextRequestQueue = 0;
+				if (EplDllkCalInstance_g.m_uiReadStatusReq != EplDllkCalInstance_g.m_uiWriteStatusReq) {	// queue is not empty
+					*puiNodeId_p =
+					    EplDllkCalInstance_g.
+					    m_auiQueueStatusReq
+					    [EplDllkCalInstance_g.
+					     m_uiReadStatusReq];
+					EplDllkCalInstance_g.m_uiReadStatusReq =
+					    (EplDllkCalInstance_g.
+					     m_uiReadStatusReq +
+					     1) %
+					    tabentries(EplDllkCalInstance_g.
+						       m_auiQueueStatusReq);
+					*pReqServiceId_p =
+					    kEplDllReqServiceStatus;
+					goto Exit;
+				}
+				break;
+			}
 
-        }
-    }
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1073,41 +1136,49 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDllkCalAsyncSetPendingRequests(unsigned int uiNodeId_p, tEplDllAsyncReqPriority AsyncReqPrio_p, unsigned int uiCount_p)
+tEplKernel EplDllkCalAsyncSetPendingRequests(unsigned int uiNodeId_p,
+					     tEplDllAsyncReqPriority
+					     AsyncReqPrio_p,
+					     unsigned int uiCount_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    // add node to appropriate request queue
-    switch (AsyncReqPrio_p)
-    {
-        case kEplDllAsyncReqPrioNmt:
-        {
-            uiNodeId_p--;
-            if (uiNodeId_p >= (tabentries (EplDllkCalInstance_g.m_auiQueueCnRequests) / 2))
-            {
-                Ret = kEplDllInvalidParam;
-                goto Exit;
-            }
-            uiNodeId_p += tabentries (EplDllkCalInstance_g.m_auiQueueCnRequests) / 2;
-            EplDllkCalInstance_g.m_auiQueueCnRequests[uiNodeId_p] = uiCount_p;
-            break;
-        }
-
-        default:
-        {
-            uiNodeId_p--;
-            if (uiNodeId_p >= (tabentries (EplDllkCalInstance_g.m_auiQueueCnRequests) / 2))
-            {
-                Ret = kEplDllInvalidParam;
-                goto Exit;
-            }
-            EplDllkCalInstance_g.m_auiQueueCnRequests[uiNodeId_p] = uiCount_p;
-            break;
-        }
-    }
+	// add node to appropriate request queue
+	switch (AsyncReqPrio_p) {
+	case kEplDllAsyncReqPrioNmt:
+		{
+			uiNodeId_p--;
+			if (uiNodeId_p >=
+			    (tabentries
+			     (EplDllkCalInstance_g.m_auiQueueCnRequests) / 2)) {
+				Ret = kEplDllInvalidParam;
+				goto Exit;
+			}
+			uiNodeId_p +=
+			    tabentries(EplDllkCalInstance_g.
+				       m_auiQueueCnRequests) / 2;
+			EplDllkCalInstance_g.m_auiQueueCnRequests[uiNodeId_p] =
+			    uiCount_p;
+			break;
+		}
+
+	default:
+		{
+			uiNodeId_p--;
+			if (uiNodeId_p >=
+			    (tabentries
+			     (EplDllkCalInstance_g.m_auiQueueCnRequests) / 2)) {
+				Ret = kEplDllInvalidParam;
+				goto Exit;
+			}
+			EplDllkCalInstance_g.m_auiQueueCnRequests[uiNodeId_p] =
+			    uiCount_p;
+			break;
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 #endif //(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
@@ -1133,7 +1204,6 @@ tEplDllAsyncReqPriority Priority;
 tShbError   ShbError;
 unsigned long   ulBlockCount;
 
-
     ShbError = ShbCirGetReadBlockCount (EplDllkCalInstance_g.m_ShbInstanceTxNmt, &ulBlockCount);
     if (ulBlockCount > EplDllkCalInstance_g.m_Statistics.m_ulMaxTxFrameCountNmt)
     {
@@ -1164,7 +1234,6 @@ tEplDllAsyncReqPriority Priority;
 tShbError   ShbError;
 unsigned long   ulBlockCount;
 
-
     ShbError = ShbCirGetReadBlockCount (EplDllkCalInstance_g.m_ShbInstanceTxGen, &ulBlockCount);
     if (ulBlockCount > EplDllkCalInstance_g.m_Statistics.m_ulMaxTxFrameCountGen)
     {
@@ -1186,8 +1255,6 @@ unsigned long   ulBlockCount;
 */
 #endif
 
-
 #endif // #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
 
 // EOF
-
--- a/drivers/staging/epl/EplDlluCal.c
+++ b/drivers/staging/epl/EplDlluCal.c
@@ -78,7 +78,6 @@
 #include "kernel/EplDllkCal.h"
 #endif
 
-
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
 
 /***************************************************************************/
@@ -105,7 +104,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -119,7 +117,6 @@
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -134,9 +131,8 @@
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    tEplDlluCbAsnd  m_apfnDlluCbAsnd[EPL_DLL_MAX_ASND_SERVICE_ID];
+typedef struct {
+	tEplDlluCbAsnd m_apfnDlluCbAsnd[EPL_DLL_MAX_ASND_SERVICE_ID];
 
 } tEplDlluCalInstance;
 
@@ -146,13 +142,15 @@ typedef struct
 
 // if no dynamic memory allocation shall be used
 // define structures statically
-static tEplDlluCalInstance     EplDlluCalInstance_g;
+static tEplDlluCalInstance EplDlluCalInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-static tEplKernel EplDlluCalSetAsndServiceIdFilter(tEplDllAsndServiceId ServiceId_p, tEplDllAsndFilter Filter_p);
+static tEplKernel EplDlluCalSetAsndServiceIdFilter(tEplDllAsndServiceId
+						   ServiceId_p,
+						   tEplDllAsndFilter Filter_p);
 
 //=========================================================================//
 //                                                                         //
@@ -177,12 +175,12 @@ static tEplKernel EplDlluCalSetAsndServi
 
 tEplKernel EplDlluCalAddInstance()
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    // reset instance structure
-    EPL_MEMSET(&EplDlluCalInstance_g, 0, sizeof (EplDlluCalInstance_g));
+	// reset instance structure
+	EPL_MEMSET(&EplDlluCalInstance_g, 0, sizeof(EplDlluCalInstance_g));
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -202,15 +200,14 @@ tEplKernel      Ret = kEplSuccessful;
 
 tEplKernel EplDlluCalDelInstance()
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    // reset instance structure
-    EPL_MEMSET(&EplDlluCalInstance_g, 0, sizeof (EplDlluCalInstance_g));
+	// reset instance structure
+	EPL_MEMSET(&EplDlluCalInstance_g, 0, sizeof(EplDlluCalInstance_g));
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDlluCalProcess
@@ -228,37 +225,40 @@ tEplKernel      Ret = kEplSuccessful;
 
 tEplKernel EplDlluCalProcess(tEplEvent * pEvent_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplMsgType     MsgType;
-unsigned int    uiAsndServiceId;
-tEplFrameInfo   FrameInfo;
-
-    if (pEvent_p->m_EventType == kEplEventTypeAsndRx)
-    {
-        FrameInfo.m_pFrame = (tEplFrame*) pEvent_p->m_pArg;
-        FrameInfo.m_uiFrameSize = pEvent_p->m_uiSize;
-        // extract NetTime
-        FrameInfo.m_NetTime = pEvent_p->m_NetTime;
-
-        MsgType = (tEplMsgType)AmiGetByteFromLe(&FrameInfo.m_pFrame->m_le_bMessageType);
-        if (MsgType != kEplMsgTypeAsnd)
-        {
-            Ret = kEplInvalidOperation;
-            goto Exit;
-        }
-
-        uiAsndServiceId = (unsigned int) AmiGetByteFromLe(&FrameInfo.m_pFrame->m_Data.m_Asnd.m_le_bServiceId);
-        if (uiAsndServiceId < EPL_DLL_MAX_ASND_SERVICE_ID)
-        {   // ASnd service ID is valid
-            if (EplDlluCalInstance_g.m_apfnDlluCbAsnd[uiAsndServiceId] != NULL)
-            {   // handler was registered
-                Ret = EplDlluCalInstance_g.m_apfnDlluCbAsnd[uiAsndServiceId](&FrameInfo);
-            }
-        }
-    }
+	tEplKernel Ret = kEplSuccessful;
+	tEplMsgType MsgType;
+	unsigned int uiAsndServiceId;
+	tEplFrameInfo FrameInfo;
+
+	if (pEvent_p->m_EventType == kEplEventTypeAsndRx) {
+		FrameInfo.m_pFrame = (tEplFrame *) pEvent_p->m_pArg;
+		FrameInfo.m_uiFrameSize = pEvent_p->m_uiSize;
+		// extract NetTime
+		FrameInfo.m_NetTime = pEvent_p->m_NetTime;
+
+		MsgType =
+		    (tEplMsgType) AmiGetByteFromLe(&FrameInfo.m_pFrame->
+						   m_le_bMessageType);
+		if (MsgType != kEplMsgTypeAsnd) {
+			Ret = kEplInvalidOperation;
+			goto Exit;
+		}
+
+		uiAsndServiceId =
+		    (unsigned int)AmiGetByteFromLe(&FrameInfo.m_pFrame->m_Data.
+						   m_Asnd.m_le_bServiceId);
+		if (uiAsndServiceId < EPL_DLL_MAX_ASND_SERVICE_ID) {	// ASnd service ID is valid
+			if (EplDlluCalInstance_g.m_apfnDlluCbAsnd[uiAsndServiceId] != NULL) {	// handler was registered
+				Ret =
+				    EplDlluCalInstance_g.
+				    m_apfnDlluCbAsnd[uiAsndServiceId]
+				    (&FrameInfo);
+			}
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -279,26 +279,26 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDlluCalRegAsndService(tEplDllAsndServiceId ServiceId_p, tEplDlluCbAsnd pfnDlluCbAsnd_p, tEplDllAsndFilter Filter_p)
-{
-tEplKernel  Ret = kEplSuccessful;
-
-    if (ServiceId_p < tabentries (EplDlluCalInstance_g.m_apfnDlluCbAsnd))
-    {
-        // memorize function pointer
-        EplDlluCalInstance_g.m_apfnDlluCbAsnd[ServiceId_p] = pfnDlluCbAsnd_p;
-
-        if (pfnDlluCbAsnd_p == NULL)
-        {   // close filter
-            Filter_p = kEplDllAsndFilterNone;
-        }
-
-        // set filter in DLL module in kernel part
-        Ret = EplDlluCalSetAsndServiceIdFilter(ServiceId_p, Filter_p);
+tEplKernel EplDlluCalRegAsndService(tEplDllAsndServiceId ServiceId_p,
+				    tEplDlluCbAsnd pfnDlluCbAsnd_p,
+				    tEplDllAsndFilter Filter_p)
+{
+	tEplKernel Ret = kEplSuccessful;
+
+	if (ServiceId_p < tabentries(EplDlluCalInstance_g.m_apfnDlluCbAsnd)) {
+		// memorize function pointer
+		EplDlluCalInstance_g.m_apfnDlluCbAsnd[ServiceId_p] =
+		    pfnDlluCbAsnd_p;
+
+		if (pfnDlluCbAsnd_p == NULL) {	// close filter
+			Filter_p = kEplDllAsndFilterNone;
+		}
+		// set filter in DLL module in kernel part
+		Ret = EplDlluCalSetAsndServiceIdFilter(ServiceId_p, Filter_p);
 
-    }
+	}
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -319,21 +319,21 @@ tEplKernel  Ret = kEplSuccessful;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDlluCalAsyncSend(tEplFrameInfo * pFrameInfo_p, tEplDllAsyncReqPriority Priority_p)
+tEplKernel EplDlluCalAsyncSend(tEplFrameInfo * pFrameInfo_p,
+			       tEplDllAsyncReqPriority Priority_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-    pFrameInfo_p->m_uiFrameSize += 14;  // add size of ethernet header
-    Ret = EplDllkCalAsyncSend(pFrameInfo_p, Priority_p);
+	pFrameInfo_p->m_uiFrameSize += 14;	// add size of ethernet header
+	Ret = EplDllkCalAsyncSend(pFrameInfo_p, Priority_p);
 #else
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 #endif
 
-    return Ret;
+	return Ret;
 }
 
-
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
 //---------------------------------------------------------------------------
@@ -354,43 +354,42 @@ tEplKernel  Ret = kEplSuccessful;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel EplDlluCalIssueRequest(tEplDllReqServiceId Service_p, unsigned int uiNodeId_p, BYTE bSoaFlag1_p)
+tEplKernel EplDlluCalIssueRequest(tEplDllReqServiceId Service_p,
+				  unsigned int uiNodeId_p, BYTE bSoaFlag1_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    // add node to appropriate request queue
-    switch (Service_p)
-    {
-        case kEplDllReqServiceIdent:
-        case kEplDllReqServiceStatus:
-        {
-        tEplEvent   Event;
-        tEplDllCalIssueRequest  IssueReq;
-
-            Event.m_EventSink = kEplEventSinkDllkCal;
-            Event.m_EventType = kEplEventTypeDllkIssueReq;
-            IssueReq.m_Service = Service_p;
-            IssueReq.m_uiNodeId = uiNodeId_p;
-            IssueReq.m_bSoaFlag1 = bSoaFlag1_p;
-            Event.m_pArg = &IssueReq;
-            Event.m_uiSize = sizeof (IssueReq);
-
-            Ret = EplEventuPost(&Event);
-            break;
-        }
-
-        default:
-        {
-            Ret = kEplDllInvalidParam;
-            goto Exit;
-        }
-    }
+	// add node to appropriate request queue
+	switch (Service_p) {
+	case kEplDllReqServiceIdent:
+	case kEplDllReqServiceStatus:
+		{
+			tEplEvent Event;
+			tEplDllCalIssueRequest IssueReq;
+
+			Event.m_EventSink = kEplEventSinkDllkCal;
+			Event.m_EventType = kEplEventTypeDllkIssueReq;
+			IssueReq.m_Service = Service_p;
+			IssueReq.m_uiNodeId = uiNodeId_p;
+			IssueReq.m_bSoaFlag1 = bSoaFlag1_p;
+			Event.m_pArg = &IssueReq;
+			Event.m_uiSize = sizeof(IssueReq);
+
+			Ret = EplEventuPost(&Event);
+			break;
+		}
+
+	default:
+		{
+			Ret = kEplDllInvalidParam;
+			goto Exit;
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDlluCalAddNode()
@@ -408,20 +407,19 @@ Exit:
 
 tEplKernel EplDlluCalAddNode(tEplDllNodeInfo * pNodeInfo_p)
 {
-tEplKernel  Ret = kEplSuccessful;
-tEplEvent   Event;
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
 
-    Event.m_EventSink = kEplEventSinkDllkCal;
-    Event.m_EventType = kEplEventTypeDllkAddNode;
-    Event.m_pArg = pNodeInfo_p;
-    Event.m_uiSize = sizeof (tEplDllNodeInfo);
+	Event.m_EventSink = kEplEventSinkDllkCal;
+	Event.m_EventType = kEplEventTypeDllkAddNode;
+	Event.m_pArg = pNodeInfo_p;
+	Event.m_uiSize = sizeof(tEplDllNodeInfo);
 
-    Ret = EplEventuPost(&Event);
+	Ret = EplEventuPost(&Event);
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDlluCalDeleteNode()
@@ -439,20 +437,19 @@ tEplEvent   Event;
 
 tEplKernel EplDlluCalDeleteNode(unsigned int uiNodeId_p)
 {
-tEplKernel  Ret = kEplSuccessful;
-tEplEvent   Event;
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
 
-    Event.m_EventSink = kEplEventSinkDllkCal;
-    Event.m_EventType = kEplEventTypeDllkDelNode;
-    Event.m_pArg = &uiNodeId_p;
-    Event.m_uiSize = sizeof (uiNodeId_p);
+	Event.m_EventSink = kEplEventSinkDllkCal;
+	Event.m_EventType = kEplEventTypeDllkDelNode;
+	Event.m_pArg = &uiNodeId_p;
+	Event.m_uiSize = sizeof(uiNodeId_p);
 
-    Ret = EplEventuPost(&Event);
+	Ret = EplEventuPost(&Event);
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplDlluCalSoftDeleteNode()
@@ -470,23 +467,21 @@ tEplEvent   Event;
 
 tEplKernel EplDlluCalSoftDeleteNode(unsigned int uiNodeId_p)
 {
-tEplKernel  Ret = kEplSuccessful;
-tEplEvent   Event;
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
 
-    Event.m_EventSink = kEplEventSinkDllkCal;
-    Event.m_EventType = kEplEventTypeDllkSoftDelNode;
-    Event.m_pArg = &uiNodeId_p;
-    Event.m_uiSize = sizeof (uiNodeId_p);
+	Event.m_EventSink = kEplEventSinkDllkCal;
+	Event.m_EventType = kEplEventTypeDllkSoftDelNode;
+	Event.m_pArg = &uiNodeId_p;
+	Event.m_uiSize = sizeof(uiNodeId_p);
 
-    Ret = EplEventuPost(&Event);
+	Ret = EplEventuPost(&Event);
 
-    return Ret;
+	return Ret;
 }
 
-
 #endif // (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -509,26 +504,26 @@ tEplEvent   Event;
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplDlluCalSetAsndServiceIdFilter(tEplDllAsndServiceId ServiceId_p, tEplDllAsndFilter Filter_p)
-{
-tEplKernel  Ret = kEplSuccessful;
-tEplEvent   Event;
-tEplDllCalAsndServiceIdFilter   ServFilter;
-
-    Event.m_EventSink = kEplEventSinkDllkCal;
-    Event.m_EventType = kEplEventTypeDllkServFilter;
-    ServFilter.m_ServiceId = ServiceId_p;
-    ServFilter.m_Filter = Filter_p;
-    Event.m_pArg = &ServFilter;
-    Event.m_uiSize = sizeof (ServFilter);
+static tEplKernel EplDlluCalSetAsndServiceIdFilter(tEplDllAsndServiceId
+						   ServiceId_p,
+						   tEplDllAsndFilter Filter_p)
+{
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
+	tEplDllCalAsndServiceIdFilter ServFilter;
+
+	Event.m_EventSink = kEplEventSinkDllkCal;
+	Event.m_EventType = kEplEventTypeDllkServFilter;
+	ServFilter.m_ServiceId = ServiceId_p;
+	ServFilter.m_Filter = Filter_p;
+	Event.m_pArg = &ServFilter;
+	Event.m_uiSize = sizeof(ServFilter);
 
-    Ret = EplEventuPost(&Event);
+	Ret = EplEventuPost(&Event);
 
-    return Ret;
+	return Ret;
 }
 
-
 #endif // (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
 
 // EOF
-
--- a/drivers/staging/epl/EplErrorHandlerk.c
+++ b/drivers/staging/epl/EplErrorHandlerk.c
@@ -71,7 +71,7 @@
 #include "kernel/EplErrorHandlerk.h"
 #include "EplNmt.h"
 #include "kernel/EplEventk.h"
-#include "kernel/EplObdk.h"         // function prototyps of the EplOBD-Modul
+#include "kernel/EplObdk.h"	// function prototyps of the EplOBD-Modul
 #include "kernel/EplDllk.h"
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
@@ -80,7 +80,6 @@
 #error "EPL ErrorHandler module needs EPL module OBDK!"
 #endif
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -93,33 +92,30 @@
 // const defines
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    DWORD           m_dwCumulativeCnt;  // subindex 1
-    DWORD           m_dwThresholdCnt;   // subindex 2
-    DWORD           m_dwThreshold;      // subindex 3
+typedef struct {
+	DWORD m_dwCumulativeCnt;	// subindex 1
+	DWORD m_dwThresholdCnt;	// subindex 2
+	DWORD m_dwThreshold;	// subindex 3
 
 } tEplErrorHandlerkErrorCounter;
 
-typedef struct
-{
-    tEplErrorHandlerkErrorCounter   m_CnLossSoc;    // object 0x1C0B
-    tEplErrorHandlerkErrorCounter   m_CnLossPreq;   // object 0x1C0D
-    tEplErrorHandlerkErrorCounter   m_CnCrcErr;     // object 0x1C0F
-    unsigned long                   m_ulDllErrorEvents;
+typedef struct {
+	tEplErrorHandlerkErrorCounter m_CnLossSoc;	// object 0x1C0B
+	tEplErrorHandlerkErrorCounter m_CnLossPreq;	// object 0x1C0D
+	tEplErrorHandlerkErrorCounter m_CnCrcErr;	// object 0x1C0F
+	unsigned long m_ulDllErrorEvents;
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    tEplErrorHandlerkErrorCounter   m_MnCrcErr;                     // object 0x1C00
-    tEplErrorHandlerkErrorCounter   m_MnCycTimeExceed;              // object 0x1C02
-    DWORD                           m_adwMnCnLossPresCumCnt[254];   // object 0x1C07
-    DWORD                           m_adwMnCnLossPresThrCnt[254];   // object 0x1C08
-    DWORD                           m_adwMnCnLossPresThreshold[254];// object 0x1C09
-    BOOL                            m_afMnCnLossPresEvent[254];
+	tEplErrorHandlerkErrorCounter m_MnCrcErr;	// object 0x1C00
+	tEplErrorHandlerkErrorCounter m_MnCycTimeExceed;	// object 0x1C02
+	DWORD m_adwMnCnLossPresCumCnt[254];	// object 0x1C07
+	DWORD m_adwMnCnLossPresThrCnt[254];	// object 0x1C08
+	DWORD m_adwMnCnLossPresThreshold[254];	// object 0x1C09
+	BOOL m_afMnCnLossPresEvent[254];
 #endif
 
 } tEplErrorHandlerkInstance;
@@ -134,15 +130,14 @@ static tEplErrorHandlerkInstance EplErro
 // local function prototypes
 //---------------------------------------------------------------------------
 
-static tEplKernel EplErrorHandlerkLinkErrorCounter(
-                                tEplErrorHandlerkErrorCounter* pErrorCounter_p,
-                                unsigned int uiIndex_p);
+static tEplKernel EplErrorHandlerkLinkErrorCounter(tEplErrorHandlerkErrorCounter
+						   * pErrorCounter_p,
+						   unsigned int uiIndex_p);
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-static tEplKernel EplErrorHandlerkLinkArray(
-                                DWORD*      pdwValue_p,
-                                unsigned int uiValueCount_p,
-                                unsigned int uiIndex_p);
+static tEplKernel EplErrorHandlerkLinkArray(DWORD * pdwValue_p,
+					    unsigned int uiValueCount_p,
+					    unsigned int uiIndex_p);
 #endif
 
 /***************************************************************************/
@@ -183,17 +178,14 @@ static tEplKernel EplErrorHandlerkLinkAr
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplErrorHandlerkInit(void)
 {
-tEplKernel Ret;
-
+	tEplKernel Ret;
 
-    Ret = EplErrorHandlerkAddInstance();
+	Ret = EplErrorHandlerkAddInstance();
 
-
-return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplErrorHandlerkAddInstance
@@ -213,90 +205,87 @@ return Ret;
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplErrorHandlerkAddInstance(void)
 {
-tEplKernel      Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
-
-    // reset only event variable,
-    // all other instance members are reset by OD or may keep their current value
-    // d.k.: this is necessary for the cumulative counters, which shall not be reset
-    EplErrorHandlerkInstance_g.m_ulDllErrorEvents = 0;
-
-    // link counters to OD
-    // $$$ d.k. if OD resides in userspace, fetch pointer to shared memory,
-    //          which shall have the same structure as the instance (needs to be declared globally).
-    //          Other idea: error counter shall belong to the process image
-    //          (reset of counters by SDO write are a little bit tricky).
-
-    Ret = EplErrorHandlerkLinkErrorCounter(
-            &EplErrorHandlerkInstance_g.m_CnLossSoc,
-            0x1C0B);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    Ret = EplErrorHandlerkLinkErrorCounter(
-            &EplErrorHandlerkInstance_g.m_CnLossPreq,
-            0x1C0D);
-    // ignore return code, because object 0x1C0D is conditional
-
-    Ret = EplErrorHandlerkLinkErrorCounter(
-            &EplErrorHandlerkInstance_g.m_CnCrcErr,
-            0x1C0F);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	Ret = kEplSuccessful;
 
+	// reset only event variable,
+	// all other instance members are reset by OD or may keep their current value
+	// d.k.: this is necessary for the cumulative counters, which shall not be reset
+	EplErrorHandlerkInstance_g.m_ulDllErrorEvents = 0;
+
+	// link counters to OD
+	// $$$ d.k. if OD resides in userspace, fetch pointer to shared memory,
+	//          which shall have the same structure as the instance (needs to be declared globally).
+	//          Other idea: error counter shall belong to the process image
+	//          (reset of counters by SDO write are a little bit tricky).
+
+	Ret =
+	    EplErrorHandlerkLinkErrorCounter(&EplErrorHandlerkInstance_g.
+					     m_CnLossSoc, 0x1C0B);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	Ret =
+	    EplErrorHandlerkLinkErrorCounter(&EplErrorHandlerkInstance_g.
+					     m_CnLossPreq, 0x1C0D);
+	// ignore return code, because object 0x1C0D is conditional
+
+	Ret =
+	    EplErrorHandlerkLinkErrorCounter(&EplErrorHandlerkInstance_g.
+					     m_CnCrcErr, 0x1C0F);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    Ret = EplErrorHandlerkLinkErrorCounter(
-            &EplErrorHandlerkInstance_g.m_MnCrcErr,
-            0x1C00);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    Ret = EplErrorHandlerkLinkErrorCounter(
-            &EplErrorHandlerkInstance_g.m_MnCycTimeExceed,
-            0x1C02);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    Ret = EplErrorHandlerkLinkArray(
-            EplErrorHandlerkInstance_g.m_adwMnCnLossPresCumCnt,
-            tabentries(EplErrorHandlerkInstance_g.m_adwMnCnLossPresCumCnt),
-            0x1C07);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    Ret = EplErrorHandlerkLinkArray(
-            EplErrorHandlerkInstance_g.m_adwMnCnLossPresThrCnt,
-            tabentries(EplErrorHandlerkInstance_g.m_adwMnCnLossPresThrCnt),
-            0x1C08);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    Ret = EplErrorHandlerkLinkArray(
-            EplErrorHandlerkInstance_g.m_adwMnCnLossPresThreshold,
-            tabentries(EplErrorHandlerkInstance_g.m_adwMnCnLossPresThreshold),
-            0x1C09);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
+	Ret =
+	    EplErrorHandlerkLinkErrorCounter(&EplErrorHandlerkInstance_g.
+					     m_MnCrcErr, 0x1C00);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	Ret =
+	    EplErrorHandlerkLinkErrorCounter(&EplErrorHandlerkInstance_g.
+					     m_MnCycTimeExceed, 0x1C02);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	Ret =
+	    EplErrorHandlerkLinkArray(EplErrorHandlerkInstance_g.
+				      m_adwMnCnLossPresCumCnt,
+				      tabentries(EplErrorHandlerkInstance_g.
+						 m_adwMnCnLossPresCumCnt),
+				      0x1C07);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	Ret =
+	    EplErrorHandlerkLinkArray(EplErrorHandlerkInstance_g.
+				      m_adwMnCnLossPresThrCnt,
+				      tabentries(EplErrorHandlerkInstance_g.
+						 m_adwMnCnLossPresThrCnt),
+				      0x1C08);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	Ret =
+	    EplErrorHandlerkLinkArray(EplErrorHandlerkInstance_g.
+				      m_adwMnCnLossPresThreshold,
+				      tabentries(EplErrorHandlerkInstance_g.
+						 m_adwMnCnLossPresThreshold),
+				      0x1C09);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
@@ -319,12 +308,11 @@ Exit:
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplErrorHandlerkDelInstance()
 {
-tEplKernel      Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-
-return Ret;
+	return Ret;
 
 }
 
@@ -345,319 +333,353 @@ return Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplErrorHandlerkProcess(tEplEvent* pEvent_p)
+tEplKernel PUBLIC EplErrorHandlerkProcess(tEplEvent * pEvent_p)
 {
-tEplKernel              Ret;
-unsigned long           ulDllErrorEvents;
-tEplEvent               Event;
-tEplNmtEvent            NmtEvent;
-
-    Ret = kEplSuccessful;
-
-    // check m_EventType
-    switch(pEvent_p->m_EventType)
-    {
-        case kEplEventTypeDllError:
-        {
-        tEplErrorHandlerkEvent* pErrHandlerEvent = (tEplErrorHandlerkEvent*)pEvent_p->m_pArg;
-
-            ulDllErrorEvents = pErrHandlerEvent->m_ulDllErrorEvents;
-
-            // check the several error events
-            if ((EplErrorHandlerkInstance_g.m_CnLossSoc.m_dwThreshold > 0)
-                && ((ulDllErrorEvents & EPL_DLL_ERR_CN_LOSS_SOC) != 0))
-            {   // loss of SoC event occured
-                // increment cumulative counter by 1
-                EplErrorHandlerkInstance_g.m_CnLossSoc.m_dwCumulativeCnt++;
-                // increment threshold counter by 8
-                EplErrorHandlerkInstance_g.m_CnLossSoc.m_dwThresholdCnt += 8;
-                if (EplErrorHandlerkInstance_g.m_CnLossSoc.m_dwThresholdCnt
-                    >= EplErrorHandlerkInstance_g.m_CnLossSoc.m_dwThreshold)
-                {   // threshold is reached
-                    // $$$ d.k.: generate error history entry E_DLL_LOSS_SOC_TH
-
-                    // post event to NMT state machine
-                    NmtEvent = kEplNmtEventNmtCycleError;
-                    Event.m_EventSink = kEplEventSinkNmtk;
-                    Event.m_EventType = kEplEventTypeNmtEvent;
-                    Event.m_pArg = &NmtEvent;
-                    Event.m_uiSize = sizeof (NmtEvent);
-                    Ret = EplEventkPost(&Event);
-                }
-                EplErrorHandlerkInstance_g.m_ulDllErrorEvents |=
-                    EPL_DLL_ERR_CN_LOSS_SOC;
-            }
-
-            if ((EplErrorHandlerkInstance_g.m_CnLossPreq.m_dwThreshold > 0)
-                && ((ulDllErrorEvents & EPL_DLL_ERR_CN_LOSS_PREQ) != 0))
-            {   // loss of PReq event occured
-                // increment cumulative counter by 1
-                EplErrorHandlerkInstance_g.m_CnLossPreq.m_dwCumulativeCnt++;
-                // increment threshold counter by 8
-                EplErrorHandlerkInstance_g.m_CnLossPreq.m_dwThresholdCnt += 8;
-                if (EplErrorHandlerkInstance_g.m_CnLossPreq.m_dwThresholdCnt
-                    >= EplErrorHandlerkInstance_g.m_CnLossPreq.m_dwThreshold)
-                {   // threshold is reached
-                    // $$$ d.k.: generate error history entry E_DLL_LOSS_PREQ_TH
-
-                    // post event to NMT state machine
-                    NmtEvent = kEplNmtEventNmtCycleError;
-                    Event.m_EventSink = kEplEventSinkNmtk;
-                    Event.m_EventType = kEplEventTypeNmtEvent;
-                    Event.m_pArg = &NmtEvent;
-                    Event.m_uiSize = sizeof (NmtEvent);
-                    Ret = EplEventkPost(&Event);
-                }
-            }
-
-            if ((EplErrorHandlerkInstance_g.m_CnLossPreq.m_dwThresholdCnt > 0)
-                && ((ulDllErrorEvents & EPL_DLL_ERR_CN_RECVD_PREQ) != 0))
-            {   // PReq correctly received
-                // decrement threshold counter by 1
-                EplErrorHandlerkInstance_g.m_CnLossPreq.m_dwThresholdCnt--;
-            }
-
-            if ((EplErrorHandlerkInstance_g.m_CnCrcErr.m_dwThreshold > 0)
-                && ((ulDllErrorEvents & EPL_DLL_ERR_CN_CRC) != 0))
-            {   // CRC error event occured
-                // increment cumulative counter by 1
-                EplErrorHandlerkInstance_g.m_CnCrcErr.m_dwCumulativeCnt++;
-                // increment threshold counter by 8
-                EplErrorHandlerkInstance_g.m_CnCrcErr.m_dwThresholdCnt += 8;
-                if (EplErrorHandlerkInstance_g.m_CnCrcErr.m_dwThresholdCnt
-                    >= EplErrorHandlerkInstance_g.m_CnCrcErr.m_dwThreshold)
-                {   // threshold is reached
-                    // $$$ d.k.: generate error history entry E_DLL_CRC_TH
-
-                    // post event to NMT state machine
-                    NmtEvent = kEplNmtEventNmtCycleError;
-                    Event.m_EventSink = kEplEventSinkNmtk;
-                    Event.m_EventType = kEplEventTypeNmtEvent;
-                    Event.m_pArg = &NmtEvent;
-                    Event.m_uiSize = sizeof (NmtEvent);
-                    Ret = EplEventkPost(&Event);
-                }
-                EplErrorHandlerkInstance_g.m_ulDllErrorEvents |=
-                    EPL_DLL_ERR_CN_CRC;
-            }
-
-            if ((ulDllErrorEvents & EPL_DLL_ERR_INVALID_FORMAT) != 0)
-            {   // invalid format error occured (only direct reaction)
-                // $$$ d.k.: generate error history entry E_DLL_INVALID_FORMAT
+	tEplKernel Ret;
+	unsigned long ulDllErrorEvents;
+	tEplEvent Event;
+	tEplNmtEvent NmtEvent;
+
+	Ret = kEplSuccessful;
+
+	// check m_EventType
+	switch (pEvent_p->m_EventType) {
+	case kEplEventTypeDllError:
+		{
+			tEplErrorHandlerkEvent *pErrHandlerEvent =
+			    (tEplErrorHandlerkEvent *) pEvent_p->m_pArg;
+
+			ulDllErrorEvents = pErrHandlerEvent->m_ulDllErrorEvents;
+
+			// check the several error events
+			if ((EplErrorHandlerkInstance_g.m_CnLossSoc.
+			     m_dwThreshold > 0)
+			    && ((ulDllErrorEvents & EPL_DLL_ERR_CN_LOSS_SOC) != 0)) {	// loss of SoC event occured
+				// increment cumulative counter by 1
+				EplErrorHandlerkInstance_g.m_CnLossSoc.
+				    m_dwCumulativeCnt++;
+				// increment threshold counter by 8
+				EplErrorHandlerkInstance_g.m_CnLossSoc.
+				    m_dwThresholdCnt += 8;
+				if (EplErrorHandlerkInstance_g.m_CnLossSoc.m_dwThresholdCnt >= EplErrorHandlerkInstance_g.m_CnLossSoc.m_dwThreshold) {	// threshold is reached
+					// $$$ d.k.: generate error history entry E_DLL_LOSS_SOC_TH
+
+					// post event to NMT state machine
+					NmtEvent = kEplNmtEventNmtCycleError;
+					Event.m_EventSink = kEplEventSinkNmtk;
+					Event.m_EventType =
+					    kEplEventTypeNmtEvent;
+					Event.m_pArg = &NmtEvent;
+					Event.m_uiSize = sizeof(NmtEvent);
+					Ret = EplEventkPost(&Event);
+				}
+				EplErrorHandlerkInstance_g.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_LOSS_SOC;
+			}
+
+			if ((EplErrorHandlerkInstance_g.m_CnLossPreq.
+			     m_dwThreshold > 0)
+			    && ((ulDllErrorEvents & EPL_DLL_ERR_CN_LOSS_PREQ) != 0)) {	// loss of PReq event occured
+				// increment cumulative counter by 1
+				EplErrorHandlerkInstance_g.m_CnLossPreq.
+				    m_dwCumulativeCnt++;
+				// increment threshold counter by 8
+				EplErrorHandlerkInstance_g.m_CnLossPreq.
+				    m_dwThresholdCnt += 8;
+				if (EplErrorHandlerkInstance_g.m_CnLossPreq.m_dwThresholdCnt >= EplErrorHandlerkInstance_g.m_CnLossPreq.m_dwThreshold) {	// threshold is reached
+					// $$$ d.k.: generate error history entry E_DLL_LOSS_PREQ_TH
+
+					// post event to NMT state machine
+					NmtEvent = kEplNmtEventNmtCycleError;
+					Event.m_EventSink = kEplEventSinkNmtk;
+					Event.m_EventType =
+					    kEplEventTypeNmtEvent;
+					Event.m_pArg = &NmtEvent;
+					Event.m_uiSize = sizeof(NmtEvent);
+					Ret = EplEventkPost(&Event);
+				}
+			}
+
+			if ((EplErrorHandlerkInstance_g.m_CnLossPreq.
+			     m_dwThresholdCnt > 0)
+			    && ((ulDllErrorEvents & EPL_DLL_ERR_CN_RECVD_PREQ) != 0)) {	// PReq correctly received
+				// decrement threshold counter by 1
+				EplErrorHandlerkInstance_g.m_CnLossPreq.
+				    m_dwThresholdCnt--;
+			}
+
+			if ((EplErrorHandlerkInstance_g.m_CnCrcErr.
+			     m_dwThreshold > 0)
+			    && ((ulDllErrorEvents & EPL_DLL_ERR_CN_CRC) != 0)) {	// CRC error event occured
+				// increment cumulative counter by 1
+				EplErrorHandlerkInstance_g.m_CnCrcErr.
+				    m_dwCumulativeCnt++;
+				// increment threshold counter by 8
+				EplErrorHandlerkInstance_g.m_CnCrcErr.
+				    m_dwThresholdCnt += 8;
+				if (EplErrorHandlerkInstance_g.m_CnCrcErr.m_dwThresholdCnt >= EplErrorHandlerkInstance_g.m_CnCrcErr.m_dwThreshold) {	// threshold is reached
+					// $$$ d.k.: generate error history entry E_DLL_CRC_TH
+
+					// post event to NMT state machine
+					NmtEvent = kEplNmtEventNmtCycleError;
+					Event.m_EventSink = kEplEventSinkNmtk;
+					Event.m_EventType =
+					    kEplEventTypeNmtEvent;
+					Event.m_pArg = &NmtEvent;
+					Event.m_uiSize = sizeof(NmtEvent);
+					Ret = EplEventkPost(&Event);
+				}
+				EplErrorHandlerkInstance_g.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_CN_CRC;
+			}
+
+			if ((ulDllErrorEvents & EPL_DLL_ERR_INVALID_FORMAT) != 0) {	// invalid format error occured (only direct reaction)
+				// $$$ d.k.: generate error history entry E_DLL_INVALID_FORMAT
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-                if (pErrHandlerEvent->m_NmtState >= kEplNmtMsNotActive)
-                {   // MN is active
-                    if (pErrHandlerEvent->m_uiNodeId != 0)
-                    {
-                    tEplHeartbeatEvent  HeartbeatEvent;
-
-                        // remove node from isochronous phase
-                        Ret = EplDllkDeleteNode(pErrHandlerEvent->m_uiNodeId);
-
-                        // inform NmtMnu module about state change, which shall send NMT command ResetNode to this CN
-                        HeartbeatEvent.m_uiNodeId = pErrHandlerEvent->m_uiNodeId;
-                        HeartbeatEvent.m_NmtState = kEplNmtCsNotActive;
-                        HeartbeatEvent.m_wErrorCode = EPL_E_DLL_INVALID_FORMAT;
-                        Event.m_EventSink = kEplEventSinkNmtMnu;
-                        Event.m_EventType = kEplEventTypeHeartbeat;
-                        Event.m_uiSize = sizeof (HeartbeatEvent);
-                        Event.m_pArg = &HeartbeatEvent;
-                        Ret = EplEventkPost(&Event);
-                    }
-                    // $$$ and else should lead to InternComError
-                }
-                else
+				if (pErrHandlerEvent->m_NmtState >= kEplNmtMsNotActive) {	// MN is active
+					if (pErrHandlerEvent->m_uiNodeId != 0) {
+						tEplHeartbeatEvent
+						    HeartbeatEvent;
+
+						// remove node from isochronous phase
+						Ret =
+						    EplDllkDeleteNode
+						    (pErrHandlerEvent->
+						     m_uiNodeId);
+
+						// inform NmtMnu module about state change, which shall send NMT command ResetNode to this CN
+						HeartbeatEvent.m_uiNodeId =
+						    pErrHandlerEvent->
+						    m_uiNodeId;
+						HeartbeatEvent.m_NmtState =
+						    kEplNmtCsNotActive;
+						HeartbeatEvent.m_wErrorCode =
+						    EPL_E_DLL_INVALID_FORMAT;
+						Event.m_EventSink =
+						    kEplEventSinkNmtMnu;
+						Event.m_EventType =
+						    kEplEventTypeHeartbeat;
+						Event.m_uiSize =
+						    sizeof(HeartbeatEvent);
+						Event.m_pArg = &HeartbeatEvent;
+						Ret = EplEventkPost(&Event);
+					}
+					// $$$ and else should lead to InternComError
+				} else
 #endif
-                {   // CN is active
-                    // post event to NMT state machine
-                    NmtEvent = kEplNmtEventInternComError;
-                    Event.m_EventSink = kEplEventSinkNmtk;
-                    Event.m_EventType = kEplEventTypeNmtEvent;
-                    Event.m_pArg = &NmtEvent;
-                    Event.m_uiSize = sizeof (NmtEvent);
-                    Ret = EplEventkPost(&Event);
-                }
-            }
-
+				{	// CN is active
+					// post event to NMT state machine
+					NmtEvent = kEplNmtEventInternComError;
+					Event.m_EventSink = kEplEventSinkNmtk;
+					Event.m_EventType =
+					    kEplEventTypeNmtEvent;
+					Event.m_pArg = &NmtEvent;
+					Event.m_uiSize = sizeof(NmtEvent);
+					Ret = EplEventkPost(&Event);
+				}
+			}
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-            if ((EplErrorHandlerkInstance_g.m_MnCrcErr.m_dwThreshold > 0)
-                && ((ulDllErrorEvents & EPL_DLL_ERR_MN_CRC) != 0))
-            {   // CRC error event occured
-                // increment cumulative counter by 1
-                EplErrorHandlerkInstance_g.m_MnCrcErr.m_dwCumulativeCnt++;
-                // increment threshold counter by 8
-                EplErrorHandlerkInstance_g.m_MnCrcErr.m_dwThresholdCnt += 8;
-                if (EplErrorHandlerkInstance_g.m_MnCrcErr.m_dwThresholdCnt
-                    >= EplErrorHandlerkInstance_g.m_MnCrcErr.m_dwThreshold)
-                {   // threshold is reached
-                    // $$$ d.k.: generate error history entry E_DLL_CRC_TH
-
-                    // post event to NMT state machine
-                    NmtEvent = kEplNmtEventNmtCycleError;
-                    Event.m_EventSink = kEplEventSinkNmtk;
-                    Event.m_EventType = kEplEventTypeNmtEvent;
-                    Event.m_pArg = &NmtEvent;
-                    Event.m_uiSize = sizeof (NmtEvent);
-                    Ret = EplEventkPost(&Event);
-                }
-                EplErrorHandlerkInstance_g.m_ulDllErrorEvents |=
-                    EPL_DLL_ERR_MN_CRC;
-            }
-
-            if ((EplErrorHandlerkInstance_g.m_MnCycTimeExceed.m_dwThreshold > 0)
-                && ((ulDllErrorEvents & EPL_DLL_ERR_MN_CYCTIMEEXCEED) != 0))
-            {   // cycle time exceeded event occured
-                // increment cumulative counter by 1
-                EplErrorHandlerkInstance_g.m_MnCycTimeExceed.m_dwCumulativeCnt++;
-                // increment threshold counter by 8
-                EplErrorHandlerkInstance_g.m_MnCycTimeExceed.m_dwThresholdCnt += 8;
-                if (EplErrorHandlerkInstance_g.m_MnCycTimeExceed.m_dwThresholdCnt
-                    >= EplErrorHandlerkInstance_g.m_MnCycTimeExceed.m_dwThreshold)
-                {   // threshold is reached
-                    // $$$ d.k.: generate error history entry E_DLL_CYCLE_EXCEED_TH
-
-                    // post event to NMT state machine
-                    NmtEvent = kEplNmtEventNmtCycleError;
-                    Event.m_EventSink = kEplEventSinkNmtk;
-                    Event.m_EventType = kEplEventTypeNmtEvent;
-                    Event.m_pArg = &NmtEvent;
-                    Event.m_uiSize = sizeof (NmtEvent);
-                    Ret = EplEventkPost(&Event);
-                }
-                // $$$ d.k.: else generate error history entry E_DLL_CYCLE_EXCEED
-                EplErrorHandlerkInstance_g.m_ulDllErrorEvents |=
-                    EPL_DLL_ERR_MN_CYCTIMEEXCEED;
-            }
-
-            if ((ulDllErrorEvents & EPL_DLL_ERR_MN_CN_LOSS_PRES) != 0)
-            {   // CN loss PRes event occured
-            unsigned int uiNodeId;
-
-                uiNodeId = pErrHandlerEvent->m_uiNodeId - 1;
-                if ((uiNodeId < tabentries(EplErrorHandlerkInstance_g.m_adwMnCnLossPresCumCnt))
-                    && (EplErrorHandlerkInstance_g.m_adwMnCnLossPresThreshold[uiNodeId] > 0))
-                {
-                    // increment cumulative counter by 1
-                    EplErrorHandlerkInstance_g.m_adwMnCnLossPresCumCnt[uiNodeId]++;
-                    // increment threshold counter by 8
-                    EplErrorHandlerkInstance_g.m_adwMnCnLossPresThrCnt[uiNodeId] += 8;
-                    if (EplErrorHandlerkInstance_g.m_adwMnCnLossPresThrCnt[uiNodeId]
-                        >= EplErrorHandlerkInstance_g.m_adwMnCnLossPresThreshold[uiNodeId])
-                    {   // threshold is reached
-                    tEplHeartbeatEvent  HeartbeatEvent;
-
-                        // $$$ d.k.: generate error history entry E_DLL_LOSS_PRES_TH
-
-                        // remove node from isochronous phase
-                        Ret = EplDllkDeleteNode(pErrHandlerEvent->m_uiNodeId);
-
-                        // inform NmtMnu module about state change, which shall send NMT command ResetNode to this CN
-                        HeartbeatEvent.m_uiNodeId = pErrHandlerEvent->m_uiNodeId;
-                        HeartbeatEvent.m_NmtState = kEplNmtCsNotActive;
-                        HeartbeatEvent.m_wErrorCode = EPL_E_DLL_LOSS_PRES_TH;
-                        Event.m_EventSink = kEplEventSinkNmtMnu;
-                        Event.m_EventType = kEplEventTypeHeartbeat;
-                        Event.m_uiSize = sizeof (HeartbeatEvent);
-                        Event.m_pArg = &HeartbeatEvent;
-                        Ret = EplEventkPost(&Event);
-                    }
-                    EplErrorHandlerkInstance_g.m_afMnCnLossPresEvent[uiNodeId] = TRUE;
-                }
-            }
+			if ((EplErrorHandlerkInstance_g.m_MnCrcErr.
+			     m_dwThreshold > 0)
+			    && ((ulDllErrorEvents & EPL_DLL_ERR_MN_CRC) != 0)) {	// CRC error event occured
+				// increment cumulative counter by 1
+				EplErrorHandlerkInstance_g.m_MnCrcErr.
+				    m_dwCumulativeCnt++;
+				// increment threshold counter by 8
+				EplErrorHandlerkInstance_g.m_MnCrcErr.
+				    m_dwThresholdCnt += 8;
+				if (EplErrorHandlerkInstance_g.m_MnCrcErr.m_dwThresholdCnt >= EplErrorHandlerkInstance_g.m_MnCrcErr.m_dwThreshold) {	// threshold is reached
+					// $$$ d.k.: generate error history entry E_DLL_CRC_TH
+
+					// post event to NMT state machine
+					NmtEvent = kEplNmtEventNmtCycleError;
+					Event.m_EventSink = kEplEventSinkNmtk;
+					Event.m_EventType =
+					    kEplEventTypeNmtEvent;
+					Event.m_pArg = &NmtEvent;
+					Event.m_uiSize = sizeof(NmtEvent);
+					Ret = EplEventkPost(&Event);
+				}
+				EplErrorHandlerkInstance_g.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_MN_CRC;
+			}
+
+			if ((EplErrorHandlerkInstance_g.m_MnCycTimeExceed.
+			     m_dwThreshold > 0)
+			    && ((ulDllErrorEvents & EPL_DLL_ERR_MN_CYCTIMEEXCEED) != 0)) {	// cycle time exceeded event occured
+				// increment cumulative counter by 1
+				EplErrorHandlerkInstance_g.m_MnCycTimeExceed.
+				    m_dwCumulativeCnt++;
+				// increment threshold counter by 8
+				EplErrorHandlerkInstance_g.m_MnCycTimeExceed.
+				    m_dwThresholdCnt += 8;
+				if (EplErrorHandlerkInstance_g.m_MnCycTimeExceed.m_dwThresholdCnt >= EplErrorHandlerkInstance_g.m_MnCycTimeExceed.m_dwThreshold) {	// threshold is reached
+					// $$$ d.k.: generate error history entry E_DLL_CYCLE_EXCEED_TH
+
+					// post event to NMT state machine
+					NmtEvent = kEplNmtEventNmtCycleError;
+					Event.m_EventSink = kEplEventSinkNmtk;
+					Event.m_EventType =
+					    kEplEventTypeNmtEvent;
+					Event.m_pArg = &NmtEvent;
+					Event.m_uiSize = sizeof(NmtEvent);
+					Ret = EplEventkPost(&Event);
+				}
+				// $$$ d.k.: else generate error history entry E_DLL_CYCLE_EXCEED
+				EplErrorHandlerkInstance_g.m_ulDllErrorEvents |=
+				    EPL_DLL_ERR_MN_CYCTIMEEXCEED;
+			}
+
+			if ((ulDllErrorEvents & EPL_DLL_ERR_MN_CN_LOSS_PRES) != 0) {	// CN loss PRes event occured
+				unsigned int uiNodeId;
+
+				uiNodeId = pErrHandlerEvent->m_uiNodeId - 1;
+				if ((uiNodeId <
+				     tabentries(EplErrorHandlerkInstance_g.
+						m_adwMnCnLossPresCumCnt))
+				    && (EplErrorHandlerkInstance_g.
+					m_adwMnCnLossPresThreshold[uiNodeId] >
+					0)) {
+					// increment cumulative counter by 1
+					EplErrorHandlerkInstance_g.
+					    m_adwMnCnLossPresCumCnt[uiNodeId]++;
+					// increment threshold counter by 8
+					EplErrorHandlerkInstance_g.
+					    m_adwMnCnLossPresThrCnt[uiNodeId] +=
+					    8;
+					if (EplErrorHandlerkInstance_g.
+					    m_adwMnCnLossPresThrCnt[uiNodeId]
+					    >= EplErrorHandlerkInstance_g.m_adwMnCnLossPresThreshold[uiNodeId]) {	// threshold is reached
+						tEplHeartbeatEvent
+						    HeartbeatEvent;
+
+						// $$$ d.k.: generate error history entry E_DLL_LOSS_PRES_TH
+
+						// remove node from isochronous phase
+						Ret =
+						    EplDllkDeleteNode
+						    (pErrHandlerEvent->
+						     m_uiNodeId);
+
+						// inform NmtMnu module about state change, which shall send NMT command ResetNode to this CN
+						HeartbeatEvent.m_uiNodeId =
+						    pErrHandlerEvent->
+						    m_uiNodeId;
+						HeartbeatEvent.m_NmtState =
+						    kEplNmtCsNotActive;
+						HeartbeatEvent.m_wErrorCode =
+						    EPL_E_DLL_LOSS_PRES_TH;
+						Event.m_EventSink =
+						    kEplEventSinkNmtMnu;
+						Event.m_EventType =
+						    kEplEventTypeHeartbeat;
+						Event.m_uiSize =
+						    sizeof(HeartbeatEvent);
+						Event.m_pArg = &HeartbeatEvent;
+						Ret = EplEventkPost(&Event);
+					}
+					EplErrorHandlerkInstance_g.
+					    m_afMnCnLossPresEvent[uiNodeId] =
+					    TRUE;
+				}
+			}
 #endif
 
-            break;
-        }
-
-        // NMT event
-        case kEplEventTypeNmtEvent:
-        {
-            if ((*(tEplNmtEvent*)pEvent_p->m_pArg) == kEplNmtEventDllCeSoa)
-            {   // SoA event of CN -> decrement threshold counters
-
-                if ((EplErrorHandlerkInstance_g.m_ulDllErrorEvents & EPL_DLL_ERR_CN_LOSS_SOC) == 0)
-                {   // decrement loss of SoC threshold counter, because it didn't occur last cycle
-                    if (EplErrorHandlerkInstance_g.m_CnLossSoc.m_dwThresholdCnt > 0)
-                    {
-                        EplErrorHandlerkInstance_g.m_CnLossSoc.m_dwThresholdCnt--;
-                    }
-                }
-
-                if ((EplErrorHandlerkInstance_g.m_ulDllErrorEvents & EPL_DLL_ERR_CN_CRC) == 0)
-                {   // decrement CRC threshold counter, because it didn't occur last cycle
-                    if (EplErrorHandlerkInstance_g.m_CnCrcErr.m_dwThresholdCnt > 0)
-                    {
-                        EplErrorHandlerkInstance_g.m_CnCrcErr.m_dwThresholdCnt--;
-                    }
-                }
-            }
+			break;
+		}
 
+		// NMT event
+	case kEplEventTypeNmtEvent:
+		{
+			if ((*(tEplNmtEvent *) pEvent_p->m_pArg) == kEplNmtEventDllCeSoa) {	// SoA event of CN -> decrement threshold counters
+
+				if ((EplErrorHandlerkInstance_g.m_ulDllErrorEvents & EPL_DLL_ERR_CN_LOSS_SOC) == 0) {	// decrement loss of SoC threshold counter, because it didn't occur last cycle
+					if (EplErrorHandlerkInstance_g.
+					    m_CnLossSoc.m_dwThresholdCnt > 0) {
+						EplErrorHandlerkInstance_g.
+						    m_CnLossSoc.
+						    m_dwThresholdCnt--;
+					}
+				}
+
+				if ((EplErrorHandlerkInstance_g.m_ulDllErrorEvents & EPL_DLL_ERR_CN_CRC) == 0) {	// decrement CRC threshold counter, because it didn't occur last cycle
+					if (EplErrorHandlerkInstance_g.
+					    m_CnCrcErr.m_dwThresholdCnt > 0) {
+						EplErrorHandlerkInstance_g.
+						    m_CnCrcErr.
+						    m_dwThresholdCnt--;
+					}
+				}
+			}
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-            else if ((*(tEplNmtEvent*)pEvent_p->m_pArg) == kEplNmtEventDllMeSoaSent)
-            {   // SoA event of MN -> decrement threshold counters
-            tEplDllkNodeInfo*   pIntNodeInfo;
-            unsigned int        uiNodeId;
-
-                Ret = EplDllkGetFirstNodeInfo(&pIntNodeInfo);
-                if (Ret != kEplSuccessful)
-                {
-                    break;
-                }
-                // iterate through node info structure list
-                while (pIntNodeInfo != NULL)
-                {
-                    uiNodeId = pIntNodeInfo->m_uiNodeId - 1;
-                    if (uiNodeId < tabentries(EplErrorHandlerkInstance_g.m_adwMnCnLossPresCumCnt))
-                    {
-                        if  (EplErrorHandlerkInstance_g.m_afMnCnLossPresEvent[uiNodeId] == FALSE)
-                        {
-                            if (EplErrorHandlerkInstance_g.m_adwMnCnLossPresThrCnt[uiNodeId] > 0)
-                            {
-                                EplErrorHandlerkInstance_g.m_adwMnCnLossPresThrCnt[uiNodeId]--;
-                            }
-                        }
-                        else
-                        {
-                            EplErrorHandlerkInstance_g.m_afMnCnLossPresEvent[uiNodeId] = FALSE;
-                        }
-                    }
-                    pIntNodeInfo = pIntNodeInfo->m_pNextNodeInfo;
-                }
-
-                if ((EplErrorHandlerkInstance_g.m_ulDllErrorEvents & EPL_DLL_ERR_MN_CRC) == 0)
-                {   // decrement CRC threshold counter, because it didn't occur last cycle
-                    if (EplErrorHandlerkInstance_g.m_MnCrcErr.m_dwThresholdCnt > 0)
-                    {
-                        EplErrorHandlerkInstance_g.m_MnCrcErr.m_dwThresholdCnt--;
-                    }
-                }
-
-                if ((EplErrorHandlerkInstance_g.m_ulDllErrorEvents & EPL_DLL_ERR_MN_CYCTIMEEXCEED) == 0)
-                {   // decrement cycle exceed threshold counter, because it didn't occur last cycle
-                    if (EplErrorHandlerkInstance_g.m_MnCycTimeExceed.m_dwThresholdCnt > 0)
-                    {
-                        EplErrorHandlerkInstance_g.m_MnCycTimeExceed.m_dwThresholdCnt--;
-                    }
-                }
-            }
+			else if ((*(tEplNmtEvent *) pEvent_p->m_pArg) == kEplNmtEventDllMeSoaSent) {	// SoA event of MN -> decrement threshold counters
+				tEplDllkNodeInfo *pIntNodeInfo;
+				unsigned int uiNodeId;
+
+				Ret = EplDllkGetFirstNodeInfo(&pIntNodeInfo);
+				if (Ret != kEplSuccessful) {
+					break;
+				}
+				// iterate through node info structure list
+				while (pIntNodeInfo != NULL) {
+					uiNodeId = pIntNodeInfo->m_uiNodeId - 1;
+					if (uiNodeId <
+					    tabentries
+					    (EplErrorHandlerkInstance_g.
+					     m_adwMnCnLossPresCumCnt)) {
+						if (EplErrorHandlerkInstance_g.
+						    m_afMnCnLossPresEvent
+						    [uiNodeId] == FALSE) {
+							if (EplErrorHandlerkInstance_g.m_adwMnCnLossPresThrCnt[uiNodeId] > 0) {
+								EplErrorHandlerkInstance_g.
+								    m_adwMnCnLossPresThrCnt
+								    [uiNodeId]--;
+							}
+						} else {
+							EplErrorHandlerkInstance_g.
+							    m_afMnCnLossPresEvent
+							    [uiNodeId] = FALSE;
+						}
+					}
+					pIntNodeInfo =
+					    pIntNodeInfo->m_pNextNodeInfo;
+				}
+
+				if ((EplErrorHandlerkInstance_g.m_ulDllErrorEvents & EPL_DLL_ERR_MN_CRC) == 0) {	// decrement CRC threshold counter, because it didn't occur last cycle
+					if (EplErrorHandlerkInstance_g.
+					    m_MnCrcErr.m_dwThresholdCnt > 0) {
+						EplErrorHandlerkInstance_g.
+						    m_MnCrcErr.
+						    m_dwThresholdCnt--;
+					}
+				}
+
+				if ((EplErrorHandlerkInstance_g.m_ulDllErrorEvents & EPL_DLL_ERR_MN_CYCTIMEEXCEED) == 0) {	// decrement cycle exceed threshold counter, because it didn't occur last cycle
+					if (EplErrorHandlerkInstance_g.
+					    m_MnCycTimeExceed.m_dwThresholdCnt >
+					    0) {
+						EplErrorHandlerkInstance_g.
+						    m_MnCycTimeExceed.
+						    m_dwThresholdCnt--;
+					}
+				}
+			}
 #endif
 
-            // reset error events
-            EplErrorHandlerkInstance_g.m_ulDllErrorEvents = 0L;
+			// reset error events
+			EplErrorHandlerkInstance_g.m_ulDllErrorEvents = 0L;
 
-            break;
-        }
+			break;
+		}
 
+		// unknown type
+	default:
+		{
+		}
 
-        // unknown type
-        default:
-        {
-        }
+	}			// end of switch(pEvent_p->m_EventType)
 
-    } // end of switch(pEvent_p->m_EventType)
-
-
-    return Ret;
+	return Ret;
 
 }
 
@@ -683,48 +705,45 @@ tEplNmtEvent            NmtEvent;
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplErrorHandlerkLinkErrorCounter(
-                                tEplErrorHandlerkErrorCounter* pErrorCounter_p,
-                                unsigned int uiIndex_p)
+static tEplKernel EplErrorHandlerkLinkErrorCounter(tEplErrorHandlerkErrorCounter
+						   * pErrorCounter_p,
+						   unsigned int uiIndex_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplVarParam        VarParam;
+	tEplKernel Ret = kEplSuccessful;
+	tEplVarParam VarParam;
 
-    VarParam.m_pData = &pErrorCounter_p->m_dwCumulativeCnt;
-    VarParam.m_Size = sizeof(DWORD);
-    VarParam.m_uiIndex = uiIndex_p;
-    VarParam.m_uiSubindex = 0x01;
-    VarParam.m_ValidFlag = kVarValidAll;
-    Ret = EplObdDefineVar(&VarParam);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    VarParam.m_pData = &pErrorCounter_p->m_dwThresholdCnt;
-    VarParam.m_Size = sizeof(DWORD);
-    VarParam.m_uiIndex = uiIndex_p;
-    VarParam.m_uiSubindex = 0x02;
-    VarParam.m_ValidFlag = kVarValidAll;
-    Ret = EplObdDefineVar(&VarParam);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    VarParam.m_pData = &pErrorCounter_p->m_dwThreshold;
-    VarParam.m_Size = sizeof(DWORD);
-    VarParam.m_uiIndex = uiIndex_p;
-    VarParam.m_uiSubindex = 0x03;
-    VarParam.m_ValidFlag = kVarValidAll;
-    Ret = EplObdDefineVar(&VarParam);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	VarParam.m_pData = &pErrorCounter_p->m_dwCumulativeCnt;
+	VarParam.m_Size = sizeof(DWORD);
+	VarParam.m_uiIndex = uiIndex_p;
+	VarParam.m_uiSubindex = 0x01;
+	VarParam.m_ValidFlag = kVarValidAll;
+	Ret = EplObdDefineVar(&VarParam);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	VarParam.m_pData = &pErrorCounter_p->m_dwThresholdCnt;
+	VarParam.m_Size = sizeof(DWORD);
+	VarParam.m_uiIndex = uiIndex_p;
+	VarParam.m_uiSubindex = 0x02;
+	VarParam.m_ValidFlag = kVarValidAll;
+	Ret = EplObdDefineVar(&VarParam);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	VarParam.m_pData = &pErrorCounter_p->m_dwThreshold;
+	VarParam.m_Size = sizeof(DWORD);
+	VarParam.m_uiIndex = uiIndex_p;
+	VarParam.m_uiSubindex = 0x03;
+	VarParam.m_ValidFlag = kVarValidAll;
+	Ret = EplObdDefineVar(&VarParam);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -744,57 +763,48 @@ Exit:
 //---------------------------------------------------------------------------
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-static tEplKernel EplErrorHandlerkLinkArray(
-                                DWORD*      pdwValue_p,
-                                unsigned int uiValueCount_p,
-                                unsigned int uiIndex_p)
+static tEplKernel EplErrorHandlerkLinkArray(DWORD * pdwValue_p,
+					    unsigned int uiValueCount_p,
+					    unsigned int uiIndex_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplVarParam    VarParam;
-tEplObdSize     EntrySize;
-BYTE            bIndexEntries;
-
-    EntrySize = (tEplObdSize)  sizeof(bIndexEntries);
-    Ret = EplObdReadEntry (
-                            uiIndex_p,
-                            0x00,
-                            (void GENERIC*) &bIndexEntries,
-                            &EntrySize );
-
-    if ((Ret != kEplSuccessful) || (bIndexEntries == 0x00))
-    {
-        // Object doesn't exist or invalid entry number
-        Ret = kEplObdIndexNotExist;
-        goto Exit;
-    }
-
-    if (bIndexEntries < uiValueCount_p)
-    {
-        uiValueCount_p = bIndexEntries;
-    }
-
-    VarParam.m_Size = sizeof(DWORD);
-    VarParam.m_uiIndex = uiIndex_p;
-    VarParam.m_ValidFlag = kVarValidAll;
-
-    for (VarParam.m_uiSubindex = 0x01; VarParam.m_uiSubindex <= uiValueCount_p; VarParam.m_uiSubindex++)
-    {
-        VarParam.m_pData = pdwValue_p;
-        Ret = EplObdDefineVar(&VarParam);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        pdwValue_p++;
-    }
+	tEplKernel Ret = kEplSuccessful;
+	tEplVarParam VarParam;
+	tEplObdSize EntrySize;
+	BYTE bIndexEntries;
+
+	EntrySize = (tEplObdSize) sizeof(bIndexEntries);
+	Ret = EplObdReadEntry(uiIndex_p,
+			      0x00, (void GENERIC *)&bIndexEntries, &EntrySize);
+
+	if ((Ret != kEplSuccessful) || (bIndexEntries == 0x00)) {
+		// Object doesn't exist or invalid entry number
+		Ret = kEplObdIndexNotExist;
+		goto Exit;
+	}
+
+	if (bIndexEntries < uiValueCount_p) {
+		uiValueCount_p = bIndexEntries;
+	}
+
+	VarParam.m_Size = sizeof(DWORD);
+	VarParam.m_uiIndex = uiIndex_p;
+	VarParam.m_ValidFlag = kVarValidAll;
+
+	for (VarParam.m_uiSubindex = 0x01;
+	     VarParam.m_uiSubindex <= uiValueCount_p; VarParam.m_uiSubindex++) {
+		VarParam.m_pData = pdwValue_p;
+		Ret = EplObdDefineVar(&VarParam);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		pdwValue_p++;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 #endif //(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
-
 #endif //(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
 
 // EOF
-
--- a/drivers/staging/epl/EplEventk.c
+++ b/drivers/staging/epl/EplEventk.c
@@ -81,9 +81,9 @@
 #endif
 
 #ifdef EPL_NO_FIFO
-    #include "user/EplEventu.h"
+#include "user/EplEventu.h"
 #else
-    #include "SharedBuff.h"
+#include "SharedBuff.h"
 #endif
 
 /***************************************************************************/
@@ -100,29 +100,28 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-    void  PUBLIC  TgtDbgSignalTracePoint (BYTE bTracePointNumber_p);
-    void  PUBLIC  TgtDbgPostTraceValue (DWORD dwTraceValue_p);
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void PUBLIC TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)
 #endif
 
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
+typedef struct {
 #ifndef EPL_NO_FIFO
-    tShbInstance    m_pShbKernelToUserInstance;
-    tShbInstance    m_pShbUserToKernelInstance;
+	tShbInstance m_pShbKernelToUserInstance;
+	tShbInstance m_pShbUserToKernelInstance;
 #else
 
 #endif
-    tEplSyncCb      m_pfnCbSync;
-    unsigned int    m_uiUserToKernelFullCount;
+	tEplSyncCb m_pfnCbSync;
+	unsigned int m_uiUserToKernelFullCount;
 
 } tEplEventkInstance;
 
@@ -136,9 +135,8 @@ static tEplEventkInstance EplEventkInsta
 
 // callback function for incoming events
 #ifndef EPL_NO_FIFO
-static void  EplEventkRxSignalHandlerCb (
-    tShbInstance pShbRxInstance_p,
-    unsigned long ulDataSize_p);
+static void EplEventkRxSignalHandlerCb(tShbInstance pShbRxInstance_p,
+				       unsigned long ulDataSize_p);
 #endif
 
 /***************************************************************************/
@@ -176,15 +174,14 @@ static void  EplEventkRxSignalHandlerCb 
 
 tEplKernel PUBLIC EplEventkInit(tEplSyncCb pfnCbSync_p)
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = EplEventkAddInstance(pfnCbSync_p);
+	Ret = EplEventkAddInstance(pfnCbSync_p);
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplEventkAddInstance
@@ -201,65 +198,69 @@ tEplKernel Ret;
 
 tEplKernel PUBLIC EplEventkAddInstance(tEplSyncCb pfnCbSync_p)
 {
-tEplKernel      Ret;
+	tEplKernel Ret;
 #ifndef EPL_NO_FIFO
-tShbError       ShbError;
-unsigned int    fShbNewCreated;
+	tShbError ShbError;
+	unsigned int fShbNewCreated;
 #endif
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // init instance structure
-    EplEventkInstance_g.m_uiUserToKernelFullCount = 0;
-
-    // save cb-function
-    EplEventkInstance_g.m_pfnCbSync = pfnCbSync_p;
-
-#ifndef EPL_NO_FIFO
-    // init shared loop buffer
-    // kernel -> user
-    ShbError = ShbCirAllocBuffer (EPL_EVENT_SIZE_SHB_KERNEL_TO_USER,
-                                  EPL_EVENT_NAME_SHB_KERNEL_TO_USER,
-                                  &EplEventkInstance_g.m_pShbKernelToUserInstance,
-                                  &fShbNewCreated);
-    if(ShbError != kShbOk)
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventkAddInstance(): ShbCirAllocBuffer(K2U) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-        goto Exit;
-    }
-
-    // user -> kernel
-    ShbError = ShbCirAllocBuffer (EPL_EVENT_SIZE_SHB_USER_TO_KERNEL,
-                                  EPL_EVENT_NAME_SHB_USER_TO_KERNEL,
-                                  &EplEventkInstance_g.m_pShbUserToKernelInstance,
-                                  &fShbNewCreated);
-    if(ShbError != kShbOk)
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventkAddInstance(): ShbCirAllocBuffer(U2K) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-        goto Exit;
-    }
-
-    // register eventhandler
-    ShbError = ShbCirSetSignalHandlerNewData (EplEventkInstance_g.m_pShbUserToKernelInstance,
-                                    EplEventkRxSignalHandlerCb,
-                                    kshbPriorityHigh);
-    if(ShbError != kShbOk)
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventkAddInstance(): ShbCirSetSignalHandlerNewData(U2K) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-        goto Exit;
-    }
+	// init instance structure
+	EplEventkInstance_g.m_uiUserToKernelFullCount = 0;
+
+	// save cb-function
+	EplEventkInstance_g.m_pfnCbSync = pfnCbSync_p;
+
+#ifndef EPL_NO_FIFO
+	// init shared loop buffer
+	// kernel -> user
+	ShbError = ShbCirAllocBuffer(EPL_EVENT_SIZE_SHB_KERNEL_TO_USER,
+				     EPL_EVENT_NAME_SHB_KERNEL_TO_USER,
+				     &EplEventkInstance_g.
+				     m_pShbKernelToUserInstance,
+				     &fShbNewCreated);
+	if (ShbError != kShbOk) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventkAddInstance(): ShbCirAllocBuffer(K2U) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+	// user -> kernel
+	ShbError = ShbCirAllocBuffer(EPL_EVENT_SIZE_SHB_USER_TO_KERNEL,
+				     EPL_EVENT_NAME_SHB_USER_TO_KERNEL,
+				     &EplEventkInstance_g.
+				     m_pShbUserToKernelInstance,
+				     &fShbNewCreated);
+	if (ShbError != kShbOk) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventkAddInstance(): ShbCirAllocBuffer(U2K) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+	// register eventhandler
+	ShbError =
+	    ShbCirSetSignalHandlerNewData(EplEventkInstance_g.
+					  m_pShbUserToKernelInstance,
+					  EplEventkRxSignalHandlerCb,
+					  kshbPriorityHigh);
+	if (ShbError != kShbOk) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventkAddInstance(): ShbCirSetSignalHandlerNewData(U2K) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+		goto Exit;
+	}
 
-Exit:
+      Exit:
 #endif
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplEventkDelInstance
@@ -276,54 +277,54 @@ Exit:
 
 tEplKernel PUBLIC EplEventkDelInstance()
 {
-tEplKernel      Ret;
+	tEplKernel Ret;
 #ifndef EPL_NO_FIFO
-tShbError       ShbError;
+	tShbError ShbError;
 #endif
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
 #ifndef EPL_NO_FIFO
-    // set eventhandler to NULL
-    ShbError = ShbCirSetSignalHandlerNewData (EplEventkInstance_g.m_pShbUserToKernelInstance,
-                                    NULL,
-                                    kShbPriorityNormal);
-    if(ShbError != kShbOk)
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventkDelInstance(): ShbCirSetSignalHandlerNewData(U2K) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-    }
-
-    // free buffer User -> Kernel
-    ShbError = ShbCirReleaseBuffer (EplEventkInstance_g.m_pShbUserToKernelInstance);
-    if(ShbError != kShbOk)
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventkDelInstance(): ShbCirReleaseBuffer(U2K) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-    }
-    else
-    {
-        EplEventkInstance_g.m_pShbUserToKernelInstance = NULL;
-    }
-
-    // free buffer  Kernel -> User
-    ShbError = ShbCirReleaseBuffer (EplEventkInstance_g.m_pShbKernelToUserInstance);
-    if(ShbError != kShbOk)
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventkDelInstance(): ShbCirReleaseBuffer(K2U) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-    }
-    else
-    {
-        EplEventkInstance_g.m_pShbKernelToUserInstance = NULL;
-    }
+	// set eventhandler to NULL
+	ShbError =
+	    ShbCirSetSignalHandlerNewData(EplEventkInstance_g.
+					  m_pShbUserToKernelInstance, NULL,
+					  kShbPriorityNormal);
+	if (ShbError != kShbOk) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventkDelInstance(): ShbCirSetSignalHandlerNewData(U2K) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+	}
+	// free buffer User -> Kernel
+	ShbError =
+	    ShbCirReleaseBuffer(EplEventkInstance_g.m_pShbUserToKernelInstance);
+	if (ShbError != kShbOk) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventkDelInstance(): ShbCirReleaseBuffer(U2K) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+	} else {
+		EplEventkInstance_g.m_pShbUserToKernelInstance = NULL;
+	}
+
+	// free buffer  Kernel -> User
+	ShbError =
+	    ShbCirReleaseBuffer(EplEventkInstance_g.m_pShbKernelToUserInstance);
+	if (ShbError != kShbOk) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventkDelInstance(): ShbCirReleaseBuffer(K2U) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+	} else {
+		EplEventkInstance_g.m_pShbKernelToUserInstance = NULL;
+	}
 #endif
 
-return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplEventkProcess
@@ -338,227 +339,215 @@ return Ret;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplEventkProcess(tEplEvent* pEvent_p)
+tEplKernel PUBLIC EplEventkProcess(tEplEvent * pEvent_p)
 {
-tEplKernel              Ret;
-tEplEventSource         EventSource;
+	tEplKernel Ret;
+	tEplEventSource EventSource;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // error handling if event queue is full
-    if (EplEventkInstance_g.m_uiUserToKernelFullCount > 0)
-    {   // UserToKernel event queue has run out of space -> kEplNmtEventInternComError
+	// error handling if event queue is full
+	if (EplEventkInstance_g.m_uiUserToKernelFullCount > 0) {	// UserToKernel event queue has run out of space -> kEplNmtEventInternComError
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTK)) != 0)
-        tEplEvent   Event;
-        tEplNmtEvent NmtEvent;
+		tEplEvent Event;
+		tEplNmtEvent NmtEvent;
 #endif
 #ifndef EPL_NO_FIFO
-        tShbError   ShbError;
+		tShbError ShbError;
 #endif
 
-        // directly call NMTk process function, because event queue is full
+		// directly call NMTk process function, because event queue is full
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTK)) != 0)
-        NmtEvent = kEplNmtEventInternComError;
-        Event.m_EventSink = kEplEventSinkNmtk;
-        Event.m_NetTime.m_dwNanoSec = 0;
-        Event.m_NetTime.m_dwSec = 0;
-        Event.m_EventType = kEplEventTypeNmtEvent;
-        Event.m_pArg = &NmtEvent;
-        Event.m_uiSize = sizeof(NmtEvent);
-        Ret = EplNmtkProcess(&Event);
-#endif
-
-        // NMT state machine changed to reset (i.e. NMT_GS_RESET_COMMUNICATION)
-        // now, it is safe to reset the counter and empty the event queue
-#ifndef EPL_NO_FIFO
-        ShbError = ShbCirResetBuffer (EplEventkInstance_g.m_pShbUserToKernelInstance, 1000, NULL);
-#endif
-
-        EplEventkInstance_g.m_uiUserToKernelFullCount = 0;
-        TGT_DBG_SIGNAL_TRACE_POINT(22);
-
-        // also discard the current event (it doesn't matter if we lose another event)
-        goto Exit;
-    }
-
-    // check m_EventSink
-    switch(pEvent_p->m_EventSink)
-    {
-        case kEplEventSinkSync:
-        {
-            if (EplEventkInstance_g.m_pfnCbSync != NULL)
-            {
-                Ret = EplEventkInstance_g.m_pfnCbSync();
-                if (Ret == kEplSuccessful)
-                {
+		NmtEvent = kEplNmtEventInternComError;
+		Event.m_EventSink = kEplEventSinkNmtk;
+		Event.m_NetTime.m_dwNanoSec = 0;
+		Event.m_NetTime.m_dwSec = 0;
+		Event.m_EventType = kEplEventTypeNmtEvent;
+		Event.m_pArg = &NmtEvent;
+		Event.m_uiSize = sizeof(NmtEvent);
+		Ret = EplNmtkProcess(&Event);
+#endif
+
+		// NMT state machine changed to reset (i.e. NMT_GS_RESET_COMMUNICATION)
+		// now, it is safe to reset the counter and empty the event queue
+#ifndef EPL_NO_FIFO
+		ShbError =
+		    ShbCirResetBuffer(EplEventkInstance_g.
+				      m_pShbUserToKernelInstance, 1000, NULL);
+#endif
+
+		EplEventkInstance_g.m_uiUserToKernelFullCount = 0;
+		TGT_DBG_SIGNAL_TRACE_POINT(22);
+
+		// also discard the current event (it doesn't matter if we lose another event)
+		goto Exit;
+	}
+	// check m_EventSink
+	switch (pEvent_p->m_EventSink) {
+	case kEplEventSinkSync:
+		{
+			if (EplEventkInstance_g.m_pfnCbSync != NULL) {
+				Ret = EplEventkInstance_g.m_pfnCbSync();
+				if (Ret == kEplSuccessful) {
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
-                    // mark TPDOs as valid
-                    Ret = EplPdokCalSetTpdosValid(TRUE);
+					// mark TPDOs as valid
+					Ret = EplPdokCalSetTpdosValid(TRUE);
 #endif
-                }
-                else if ((Ret != kEplReject) && (Ret != kEplShutdown))
-                {
-                    EventSource = kEplEventSourceSyncCb;
-
-                    // Error event for API layer
-                    EplEventkPostError(kEplEventSourceEventk,
-                                    Ret,
-                                    sizeof(EventSource),
-                                    &EventSource);
-                }
-            }
-            break;
-        }
-
-        // NMT-Kernel-Modul
-        case kEplEventSinkNmtk:
-        {
+				} else if ((Ret != kEplReject)
+					   && (Ret != kEplShutdown)) {
+					EventSource = kEplEventSourceSyncCb;
+
+					// Error event for API layer
+					EplEventkPostError
+					    (kEplEventSourceEventk, Ret,
+					     sizeof(EventSource), &EventSource);
+				}
+			}
+			break;
+		}
+
+		// NMT-Kernel-Modul
+	case kEplEventSinkNmtk:
+		{
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTK)) != 0)
-            Ret = EplNmtkProcess(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourceNmtk;
-
-                // Error event for API layer
-                EplEventkPostError(kEplEventSourceEventk,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
+			Ret = EplNmtkProcess(pEvent_p);
+			if ((Ret != kEplSuccessful) && (Ret != kEplShutdown)) {
+				EventSource = kEplEventSourceNmtk;
+
+				// Error event for API layer
+				EplEventkPostError(kEplEventSourceEventk,
+						   Ret,
+						   sizeof(EventSource),
+						   &EventSource);
+			}
 #endif
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-            if ((pEvent_p->m_EventType == kEplEventTypeNmtEvent)
-                && ((*((tEplNmtEvent*)pEvent_p->m_pArg) == kEplNmtEventDllCeSoa)
+			if ((pEvent_p->m_EventType == kEplEventTypeNmtEvent)
+			    &&
+			    ((*((tEplNmtEvent *) pEvent_p->m_pArg) ==
+			      kEplNmtEventDllCeSoa)
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-                || (*((tEplNmtEvent*)pEvent_p->m_pArg) == kEplNmtEventDllMeSoaSent)
+			     || (*((tEplNmtEvent *) pEvent_p->m_pArg) ==
+				 kEplNmtEventDllMeSoaSent)
 #endif
-                ))
-            {   // forward SoA event to error handler
-                Ret = EplErrorHandlerkProcess(pEvent_p);
-                if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-                {
-                    EventSource = kEplEventSourceErrk;
-
-                    // Error event for API layer
-                    EplEventkPostError(kEplEventSourceEventk,
-                                    Ret,
-                                    sizeof(EventSource),
-                                    &EventSource);
-                }
-
+			    )) {	// forward SoA event to error handler
+				Ret = EplErrorHandlerkProcess(pEvent_p);
+				if ((Ret != kEplSuccessful)
+				    && (Ret != kEplShutdown)) {
+					EventSource = kEplEventSourceErrk;
+
+					// Error event for API layer
+					EplEventkPostError
+					    (kEplEventSourceEventk, Ret,
+					     sizeof(EventSource), &EventSource);
+				}
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
-                // forward SoA event to PDO module
-                pEvent_p->m_EventType = kEplEventTypePdoSoa;
-                Ret = EplPdokProcess(pEvent_p);
-                if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-                {
-                    EventSource = kEplEventSourcePdok;
-
-                    // Error event for API layer
-                    EplEventkPostError(kEplEventSourceEventk,
-                                    Ret,
-                                    sizeof(EventSource),
-                                    &EventSource);
-                }
-#endif
-
-            }
-            break;
-#endif
-        }
-
-        // events for Dllk module
-        case kEplEventSinkDllk:
-        {
+				// forward SoA event to PDO module
+				pEvent_p->m_EventType = kEplEventTypePdoSoa;
+				Ret = EplPdokProcess(pEvent_p);
+				if ((Ret != kEplSuccessful)
+				    && (Ret != kEplShutdown)) {
+					EventSource = kEplEventSourcePdok;
+
+					// Error event for API layer
+					EplEventkPostError
+					    (kEplEventSourceEventk, Ret,
+					     sizeof(EventSource), &EventSource);
+				}
+#endif
+
+			}
+			break;
+#endif
+		}
+
+		// events for Dllk module
+	case kEplEventSinkDllk:
+		{
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-            Ret = EplDllkProcess(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourceDllk;
-
-                // Error event for API layer
-                EplEventkPostError(kEplEventSourceEventk,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
-#endif
-            break;
-        }
-
-        // events for DllkCal module
-        case kEplEventSinkDllkCal:
-        {
+			Ret = EplDllkProcess(pEvent_p);
+			if ((Ret != kEplSuccessful) && (Ret != kEplShutdown)) {
+				EventSource = kEplEventSourceDllk;
+
+				// Error event for API layer
+				EplEventkPostError(kEplEventSourceEventk,
+						   Ret,
+						   sizeof(EventSource),
+						   &EventSource);
+			}
+#endif
+			break;
+		}
+
+		// events for DllkCal module
+	case kEplEventSinkDllkCal:
+		{
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-            Ret = EplDllkCalProcess(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourceDllk;
-
-                // Error event for API layer
-                EplEventkPostError(kEplEventSourceEventk,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
-#endif
-            break;
-        }
-
-        //
-        case kEplEventSinkPdok:
-        {
-            // PDO-Module
+			Ret = EplDllkCalProcess(pEvent_p);
+			if ((Ret != kEplSuccessful) && (Ret != kEplShutdown)) {
+				EventSource = kEplEventSourceDllk;
+
+				// Error event for API layer
+				EplEventkPostError(kEplEventSourceEventk,
+						   Ret,
+						   sizeof(EventSource),
+						   &EventSource);
+			}
+#endif
+			break;
+		}
+
+		//
+	case kEplEventSinkPdok:
+		{
+			// PDO-Module
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
-            Ret = EplPdokProcess(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourcePdok;
-
-                // Error event for API layer
-                EplEventkPostError(kEplEventSourceEventk,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
-#endif
-            break;
-        }
-
-        // events for Error handler module
-        case kEplEventSinkErrk:
-        {
-            // only call error handler if DLL is present
+			Ret = EplPdokProcess(pEvent_p);
+			if ((Ret != kEplSuccessful) && (Ret != kEplShutdown)) {
+				EventSource = kEplEventSourcePdok;
+
+				// Error event for API layer
+				EplEventkPostError(kEplEventSourceEventk,
+						   Ret,
+						   sizeof(EventSource),
+						   &EventSource);
+			}
+#endif
+			break;
+		}
+
+		// events for Error handler module
+	case kEplEventSinkErrk:
+		{
+			// only call error handler if DLL is present
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-            Ret = EplErrorHandlerkProcess(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourceErrk;
-
-                // Error event for API layer
-                EplEventkPostError(kEplEventSourceEventk,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
-            break;
-#endif
-        }
-
-        // unknown sink
-        default:
-        {
-            Ret = kEplEventUnknownSink;
-        }
+			Ret = EplErrorHandlerkProcess(pEvent_p);
+			if ((Ret != kEplSuccessful) && (Ret != kEplShutdown)) {
+				EventSource = kEplEventSourceErrk;
+
+				// Error event for API layer
+				EplEventkPostError(kEplEventSourceEventk,
+						   Ret,
+						   sizeof(EventSource),
+						   &EventSource);
+			}
+			break;
+#endif
+		}
+
+		// unknown sink
+	default:
+		{
+			Ret = kEplEventUnknownSink;
+		}
 
-    } // end of switch(pEvent_p->m_EventSink)
+	}			// end of switch(pEvent_p->m_EventSink)
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplEventkPost
@@ -575,165 +564,180 @@ Exit:
 
 tEplKernel PUBLIC EplEventkPost(tEplEvent * pEvent_p)
 {
-tEplKernel      Ret;
+	tEplKernel Ret;
 #ifndef EPL_NO_FIFO
-tShbError       ShbError;
-tShbCirChunk    ShbCirChunk;
-unsigned long   ulDataSize;
-unsigned int    fBufferCompleted;
-#endif
-
-    Ret = kEplSuccessful;
-
-
-    // the event must be posted by using the abBuffer
-    // it is neede because the Argument must by copied
-    // to the buffer too and not only the pointer
-
-#ifndef EPL_NO_FIFO
-    // 2006/08/03 d.k.: Event and argument are posted as separate chunks to the event queue.
-    ulDataSize = sizeof(tEplEvent) + ((pEvent_p->m_pArg != NULL) ? pEvent_p->m_uiSize : 0);
-#endif
-
-    // decide in which buffer the event have to write
-    switch(pEvent_p->m_EventSink)
-    {
-        // kernelspace modules
-        case kEplEventSinkSync:
-        case kEplEventSinkNmtk:
-        case kEplEventSinkDllk:
-        case kEplEventSinkDllkCal:
-        case kEplEventSinkPdok:
-        case kEplEventSinkErrk:
-        {
-#ifndef EPL_NO_FIFO
-            // post message
-            BENCHMARK_MOD_27_SET(2);
-            ShbError = ShbCirAllocDataBlock (EplEventkInstance_g.m_pShbUserToKernelInstance,
-                                   &ShbCirChunk,
-                                   ulDataSize);
-            switch (ShbError)
-            {
-                case kShbOk:
-                    break;
-
-                case kShbBufferFull:
-                {
-                    EplEventkInstance_g.m_uiUserToKernelFullCount++;
-                    Ret = kEplEventPostError;
-                    goto Exit;
-                }
-
-                default:
-                {
-                    EPL_DBGLVL_EVENTK_TRACE1("EplEventkPost(): ShbCirAllocDataBlock(U2K) -> 0x%X\n", ShbError);
-                    Ret = kEplEventPostError;
-                    goto Exit;
-                }
-            }
-            ShbError = ShbCirWriteDataChunk (EplEventkInstance_g.m_pShbUserToKernelInstance,
-                                   &ShbCirChunk,
-                                   pEvent_p,
-                                   sizeof (tEplEvent),
-                                   &fBufferCompleted);
-            if (ShbError != kShbOk)
-            {
-                EPL_DBGLVL_EVENTK_TRACE1("EplEventkPost(): ShbCirWriteDataChunk(U2K) -> 0x%X\n", ShbError);
-                Ret = kEplEventPostError;
-                goto Exit;
-            }
-            if (fBufferCompleted == FALSE)
-            {
-                ShbError = ShbCirWriteDataChunk (EplEventkInstance_g.m_pShbUserToKernelInstance,
-                                       &ShbCirChunk,
-                                       pEvent_p->m_pArg,
-                                       (unsigned long) pEvent_p->m_uiSize,
-                                       &fBufferCompleted);
-                if ((ShbError != kShbOk) || (fBufferCompleted == FALSE))
-                {
-                    EPL_DBGLVL_EVENTK_TRACE1("EplEventkPost(): ShbCirWriteDataChunk2(U2K) -> 0x%X\n", ShbError);
-                    Ret = kEplEventPostError;
-                    goto Exit;
-                }
-            }
-            BENCHMARK_MOD_27_RESET(2);
+	tShbError ShbError;
+	tShbCirChunk ShbCirChunk;
+	unsigned long ulDataSize;
+	unsigned int fBufferCompleted;
+#endif
+
+	Ret = kEplSuccessful;
+
+	// the event must be posted by using the abBuffer
+	// it is neede because the Argument must by copied
+	// to the buffer too and not only the pointer
+
+#ifndef EPL_NO_FIFO
+	// 2006/08/03 d.k.: Event and argument are posted as separate chunks to the event queue.
+	ulDataSize =
+	    sizeof(tEplEvent) +
+	    ((pEvent_p->m_pArg != NULL) ? pEvent_p->m_uiSize : 0);
+#endif
+
+	// decide in which buffer the event have to write
+	switch (pEvent_p->m_EventSink) {
+		// kernelspace modules
+	case kEplEventSinkSync:
+	case kEplEventSinkNmtk:
+	case kEplEventSinkDllk:
+	case kEplEventSinkDllkCal:
+	case kEplEventSinkPdok:
+	case kEplEventSinkErrk:
+		{
+#ifndef EPL_NO_FIFO
+			// post message
+			BENCHMARK_MOD_27_SET(2);
+			ShbError =
+			    ShbCirAllocDataBlock(EplEventkInstance_g.
+						 m_pShbUserToKernelInstance,
+						 &ShbCirChunk, ulDataSize);
+			switch (ShbError) {
+			case kShbOk:
+				break;
+
+			case kShbBufferFull:
+				{
+					EplEventkInstance_g.
+					    m_uiUserToKernelFullCount++;
+					Ret = kEplEventPostError;
+					goto Exit;
+				}
+
+			default:
+				{
+					EPL_DBGLVL_EVENTK_TRACE1
+					    ("EplEventkPost(): ShbCirAllocDataBlock(U2K) -> 0x%X\n",
+					     ShbError);
+					Ret = kEplEventPostError;
+					goto Exit;
+				}
+			}
+			ShbError =
+			    ShbCirWriteDataChunk(EplEventkInstance_g.
+						 m_pShbUserToKernelInstance,
+						 &ShbCirChunk, pEvent_p,
+						 sizeof(tEplEvent),
+						 &fBufferCompleted);
+			if (ShbError != kShbOk) {
+				EPL_DBGLVL_EVENTK_TRACE1
+				    ("EplEventkPost(): ShbCirWriteDataChunk(U2K) -> 0x%X\n",
+				     ShbError);
+				Ret = kEplEventPostError;
+				goto Exit;
+			}
+			if (fBufferCompleted == FALSE) {
+				ShbError =
+				    ShbCirWriteDataChunk(EplEventkInstance_g.
+							 m_pShbUserToKernelInstance,
+							 &ShbCirChunk,
+							 pEvent_p->m_pArg,
+							 (unsigned long)
+							 pEvent_p->m_uiSize,
+							 &fBufferCompleted);
+				if ((ShbError != kShbOk)
+				    || (fBufferCompleted == FALSE)) {
+					EPL_DBGLVL_EVENTK_TRACE1
+					    ("EplEventkPost(): ShbCirWriteDataChunk2(U2K) -> 0x%X\n",
+					     ShbError);
+					Ret = kEplEventPostError;
+					goto Exit;
+				}
+			}
+			BENCHMARK_MOD_27_RESET(2);
 
 #else
-            Ret = EplEventkProcess(pEvent_p);
+			Ret = EplEventkProcess(pEvent_p);
 #endif
 
-            break;
-        }
+			break;
+		}
 
-        // userspace modules
-        case kEplEventSinkNmtu:
-        case kEplEventSinkNmtMnu:
-        case kEplEventSinkSdoAsySeq:
-        case kEplEventSinkApi:
-        case kEplEventSinkDlluCal:
-        case kEplEventSinkErru:
-        {
+		// userspace modules
+	case kEplEventSinkNmtu:
+	case kEplEventSinkNmtMnu:
+	case kEplEventSinkSdoAsySeq:
+	case kEplEventSinkApi:
+	case kEplEventSinkDlluCal:
+	case kEplEventSinkErru:
+		{
 #ifndef EPL_NO_FIFO
-            // post message
+			// post message
 //            BENCHMARK_MOD_27_SET(3);    // 74 µs until reset
-            ShbError = ShbCirAllocDataBlock (EplEventkInstance_g.m_pShbKernelToUserInstance,
-                                   &ShbCirChunk,
-                                   ulDataSize);
-            if(ShbError != kShbOk)
-            {
-                EPL_DBGLVL_EVENTK_TRACE1("EplEventkPost(): ShbCirAllocDataBlock(K2U) -> 0x%X\n", ShbError);
-                Ret = kEplEventPostError;
-                goto Exit;
-            }
-            ShbError = ShbCirWriteDataChunk (EplEventkInstance_g.m_pShbKernelToUserInstance,
-                                   &ShbCirChunk,
-                                   pEvent_p,
-                                   sizeof (tEplEvent),
-                                   &fBufferCompleted);
-            if(ShbError != kShbOk)
-            {
-                EPL_DBGLVL_EVENTK_TRACE1("EplEventkPost(): ShbCirWriteDataChunk(K2U) -> 0x%X\n", ShbError);
-                Ret = kEplEventPostError;
-                goto Exit;
-            }
-            if (fBufferCompleted == FALSE)
-            {
-                ShbError = ShbCirWriteDataChunk (EplEventkInstance_g.m_pShbKernelToUserInstance,
-                                       &ShbCirChunk,
-                                       pEvent_p->m_pArg,
-                                       (unsigned long) pEvent_p->m_uiSize,
-                                       &fBufferCompleted);
-                if ((ShbError != kShbOk) || (fBufferCompleted == FALSE))
-                {
-                    EPL_DBGLVL_EVENTK_TRACE1("EplEventkPost(): ShbCirWriteDataChunk2(K2U) -> 0x%X\n", ShbError);
-                    Ret = kEplEventPostError;
-                    goto Exit;
-                }
-            }
+			ShbError =
+			    ShbCirAllocDataBlock(EplEventkInstance_g.
+						 m_pShbKernelToUserInstance,
+						 &ShbCirChunk, ulDataSize);
+			if (ShbError != kShbOk) {
+				EPL_DBGLVL_EVENTK_TRACE1
+				    ("EplEventkPost(): ShbCirAllocDataBlock(K2U) -> 0x%X\n",
+				     ShbError);
+				Ret = kEplEventPostError;
+				goto Exit;
+			}
+			ShbError =
+			    ShbCirWriteDataChunk(EplEventkInstance_g.
+						 m_pShbKernelToUserInstance,
+						 &ShbCirChunk, pEvent_p,
+						 sizeof(tEplEvent),
+						 &fBufferCompleted);
+			if (ShbError != kShbOk) {
+				EPL_DBGLVL_EVENTK_TRACE1
+				    ("EplEventkPost(): ShbCirWriteDataChunk(K2U) -> 0x%X\n",
+				     ShbError);
+				Ret = kEplEventPostError;
+				goto Exit;
+			}
+			if (fBufferCompleted == FALSE) {
+				ShbError =
+				    ShbCirWriteDataChunk(EplEventkInstance_g.
+							 m_pShbKernelToUserInstance,
+							 &ShbCirChunk,
+							 pEvent_p->m_pArg,
+							 (unsigned long)
+							 pEvent_p->m_uiSize,
+							 &fBufferCompleted);
+				if ((ShbError != kShbOk)
+				    || (fBufferCompleted == FALSE)) {
+					EPL_DBGLVL_EVENTK_TRACE1
+					    ("EplEventkPost(): ShbCirWriteDataChunk2(K2U) -> 0x%X\n",
+					     ShbError);
+					Ret = kEplEventPostError;
+					goto Exit;
+				}
+			}
 //            BENCHMARK_MOD_27_RESET(3);  // 82 µs until ShbCirGetReadDataSize() in EplEventu
 
 #else
-            Ret = EplEventuProcess(pEvent_p);
+			Ret = EplEventuProcess(pEvent_p);
 #endif
 
-            break;
-        }
-
-        default:
-        {
-            Ret = kEplEventUnknownSink;
-        }
+			break;
+		}
 
+	default:
+		{
+			Ret = kEplEventUnknownSink;
+		}
 
-    }// end of switch(pEvent_p->m_EventSink)
+	}			// end of switch(pEvent_p->m_EventSink)
 
 #ifndef EPL_NO_FIFO
-Exit:
+      Exit:
 #endif
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplEventkPostError
@@ -752,36 +756,35 @@ Exit:
 //---------------------------------------------------------------------------
 
 tEplKernel PUBLIC EplEventkPostError(tEplEventSource EventSource_p,
-                                     tEplKernel      EplError_p,
-                                     unsigned int    uiArgSize_p,
-                                     void*           pArg_p)
+				     tEplKernel EplError_p,
+				     unsigned int uiArgSize_p, void *pArg_p)
 {
-tEplKernel  Ret;
-BYTE        abBuffer[EPL_MAX_EVENT_ARG_SIZE];
-tEplEventError* pEventError = (tEplEventError*) abBuffer;
-tEplEvent   EplEvent;
-
-    Ret = kEplSuccessful;
-
-    // create argument
-    pEventError->m_EventSource = EventSource_p;
-    pEventError->m_EplError = EplError_p;
-    EPL_MEMCPY(&pEventError->m_Arg, pArg_p, uiArgSize_p);
-
-    // create event
-    EplEvent.m_EventType = kEplEventTypeError;
-    EplEvent.m_EventSink = kEplEventSinkApi;
-    EPL_MEMSET(&EplEvent.m_NetTime, 0x00, sizeof(EplEvent.m_NetTime));
-    EplEvent.m_uiSize = (sizeof(EventSource_p)+ sizeof(EplError_p)+ uiArgSize_p);
-    EplEvent.m_pArg = &abBuffer[0];
+	tEplKernel Ret;
+	BYTE abBuffer[EPL_MAX_EVENT_ARG_SIZE];
+	tEplEventError *pEventError = (tEplEventError *) abBuffer;
+	tEplEvent EplEvent;
+
+	Ret = kEplSuccessful;
+
+	// create argument
+	pEventError->m_EventSource = EventSource_p;
+	pEventError->m_EplError = EplError_p;
+	EPL_MEMCPY(&pEventError->m_Arg, pArg_p, uiArgSize_p);
+
+	// create event
+	EplEvent.m_EventType = kEplEventTypeError;
+	EplEvent.m_EventSink = kEplEventSinkApi;
+	EPL_MEMSET(&EplEvent.m_NetTime, 0x00, sizeof(EplEvent.m_NetTime));
+	EplEvent.m_uiSize =
+	    (sizeof(EventSource_p) + sizeof(EplError_p) + uiArgSize_p);
+	EplEvent.m_pArg = &abBuffer[0];
 
-    // post errorevent
-    Ret = EplEventkPost(&EplEvent);
+	// post errorevent
+	Ret = EplEventkPost(&EplEvent);
 
-    return Ret;
+	return Ret;
 }
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -804,55 +807,47 @@ tEplEvent   EplEvent;
 //---------------------------------------------------------------------------
 
 #ifndef EPL_NO_FIFO
-static void  EplEventkRxSignalHandlerCb (
-                tShbInstance pShbRxInstance_p,
-                unsigned long ulDataSize_p)
+static void EplEventkRxSignalHandlerCb(tShbInstance pShbRxInstance_p,
+				       unsigned long ulDataSize_p)
 {
-tEplEvent      *pEplEvent;
-tShbError       ShbError;
+	tEplEvent *pEplEvent;
+	tShbError ShbError;
 //unsigned long   ulBlockCount;
 //unsigned long   ulDataSize;
-BYTE            abDataBuffer[sizeof(tEplEvent) + EPL_MAX_EVENT_ARG_SIZE];
-                // d.k.: abDataBuffer contains the complete tEplEvent structure
-                //       and behind this the argument
-
-    TGT_DBG_SIGNAL_TRACE_POINT(20);
-
-    BENCHMARK_MOD_27_RESET(0);
-    // copy data from event queue
-    ShbError = ShbCirReadDataBlock (pShbRxInstance_p,
-                            &abDataBuffer[0],
-                            sizeof(abDataBuffer),
-                            &ulDataSize_p);
-    if(ShbError != kShbOk)
-    {
-        // error goto exit
-        goto Exit;
-    }
-
-    // resolve the pointer to the event structure
-    pEplEvent = (tEplEvent *) abDataBuffer;
-    // set Datasize
-    pEplEvent->m_uiSize = (ulDataSize_p - sizeof(tEplEvent));
-    if(pEplEvent->m_uiSize > 0)
-    {
-        // set pointer to argument
-        pEplEvent->m_pArg = &abDataBuffer[sizeof(tEplEvent)];
-    }
-    else
-    {
-        //set pointer to NULL
-        pEplEvent->m_pArg = NULL;
-    }
-
-    BENCHMARK_MOD_27_SET(0);
-    // call processfunction
-    EplEventkProcess(pEplEvent);
+	BYTE abDataBuffer[sizeof(tEplEvent) + EPL_MAX_EVENT_ARG_SIZE];
+	// d.k.: abDataBuffer contains the complete tEplEvent structure
+	//       and behind this the argument
+
+	TGT_DBG_SIGNAL_TRACE_POINT(20);
+
+	BENCHMARK_MOD_27_RESET(0);
+	// copy data from event queue
+	ShbError = ShbCirReadDataBlock(pShbRxInstance_p,
+				       &abDataBuffer[0],
+				       sizeof(abDataBuffer), &ulDataSize_p);
+	if (ShbError != kShbOk) {
+		// error goto exit
+		goto Exit;
+	}
+	// resolve the pointer to the event structure
+	pEplEvent = (tEplEvent *) abDataBuffer;
+	// set Datasize
+	pEplEvent->m_uiSize = (ulDataSize_p - sizeof(tEplEvent));
+	if (pEplEvent->m_uiSize > 0) {
+		// set pointer to argument
+		pEplEvent->m_pArg = &abDataBuffer[sizeof(tEplEvent)];
+	} else {
+		//set pointer to NULL
+		pEplEvent->m_pArg = NULL;
+	}
+
+	BENCHMARK_MOD_27_SET(0);
+	// call processfunction
+	EplEventkProcess(pEplEvent);
 
-Exit:
-    return;
+      Exit:
+	return;
 }
 #endif
 
 // EOF
-
--- a/drivers/staging/epl/EplEventu.c
+++ b/drivers/staging/epl/EplEventu.c
@@ -77,9 +77,9 @@
 #include "Benchmark.h"
 
 #ifdef EPL_NO_FIFO
-    #include "kernel/EplEventk.h"
+#include "kernel/EplEventk.h"
 #else
-    #include "SharedBuff.h"
+#include "SharedBuff.h"
 #endif
 
 /***************************************************************************/
@@ -96,28 +96,27 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-    void  PUBLIC  TgtDbgSignalTracePoint (BYTE bTracePointNumber_p);
-    void  PUBLIC  TgtDbgPostTraceValue (DWORD dwTraceValue_p);
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void PUBLIC TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)
 #endif
 
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
+typedef struct {
 #ifndef EPL_NO_FIFO
-    tShbInstance        m_pShbKernelToUserInstance;
-    tShbInstance        m_pShbUserToKernelInstance;
+	tShbInstance m_pShbKernelToUserInstance;
+	tShbInstance m_pShbUserToKernelInstance;
 #endif
-    tEplProcessEventCb  m_pfnApiProcessEventCb;
+	tEplProcessEventCb m_pfnApiProcessEventCb;
 
-}tEplEventuInstance;
+} tEplEventuInstance;
 
 //---------------------------------------------------------------------------
 // modul globale vars
@@ -133,9 +132,8 @@ static tEplEventuInstance EplEventuInsta
 
 #ifndef EPL_NO_FIFO
 // callback function for incomming events
-static void  EplEventuRxSignalHandlerCb (
-    tShbInstance pShbRxInstance_p,
-    unsigned long ulDataSize_p);
+static void EplEventuRxSignalHandlerCb(tShbInstance pShbRxInstance_p,
+				       unsigned long ulDataSize_p);
 #endif
 
 /***************************************************************************/
@@ -176,17 +174,14 @@ static void  EplEventuRxSignalHandlerCb 
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplEventuInit(tEplProcessEventCb pfnApiProcessEventCb_p)
 {
-tEplKernel Ret;
-
-
-    Ret = EplEventuAddInstance(pfnApiProcessEventCb_p);
+	tEplKernel Ret;
 
+	Ret = EplEventuAddInstance(pfnApiProcessEventCb_p);
 
-return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplEventuAddInstance
@@ -204,62 +199,67 @@ return Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplEventuAddInstance(tEplProcessEventCb pfnApiProcessEventCb_p)
+tEplKernel PUBLIC EplEventuAddInstance(tEplProcessEventCb
+				       pfnApiProcessEventCb_p)
 {
-tEplKernel      Ret;
+	tEplKernel Ret;
 #ifndef EPL_NO_FIFO
-tShbError       ShbError;
-unsigned int    fShbNewCreated;
+	tShbError ShbError;
+	unsigned int fShbNewCreated;
 #endif
 
-    Ret = kEplSuccessful;
-
-
-    // init instance variables
-    EplEventuInstance_g.m_pfnApiProcessEventCb = pfnApiProcessEventCb_p;
-
-#ifndef EPL_NO_FIFO
-    // init shared loop buffer
-    // kernel -> user
-    ShbError = ShbCirAllocBuffer (EPL_EVENT_SIZE_SHB_KERNEL_TO_USER,
-                                  EPL_EVENT_NAME_SHB_KERNEL_TO_USER,
-                                  &EplEventuInstance_g.m_pShbKernelToUserInstance,
-                                  &fShbNewCreated);
-    if(ShbError != kShbOk)
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventuAddInstance(): ShbCirAllocBuffer(K2U) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-        goto Exit;
-    }
-
+	Ret = kEplSuccessful;
 
-    // user -> kernel
-    ShbError = ShbCirAllocBuffer (EPL_EVENT_SIZE_SHB_USER_TO_KERNEL,
-                                  EPL_EVENT_NAME_SHB_USER_TO_KERNEL,
-                                  &EplEventuInstance_g.m_pShbUserToKernelInstance,
-                                  &fShbNewCreated);
-    if(ShbError != kShbOk)
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventuAddInstance(): ShbCirAllocBuffer(U2K) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-        goto Exit;
-    }
-
-    // register eventhandler
-    ShbError = ShbCirSetSignalHandlerNewData (EplEventuInstance_g.m_pShbKernelToUserInstance,
-                                    EplEventuRxSignalHandlerCb,
-                                    kShbPriorityNormal);
-    if(ShbError != kShbOk)
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventuAddInstance(): ShbCirSetSignalHandlerNewData(K2U) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-        goto Exit;
-    }
+	// init instance variables
+	EplEventuInstance_g.m_pfnApiProcessEventCb = pfnApiProcessEventCb_p;
+
+#ifndef EPL_NO_FIFO
+	// init shared loop buffer
+	// kernel -> user
+	ShbError = ShbCirAllocBuffer(EPL_EVENT_SIZE_SHB_KERNEL_TO_USER,
+				     EPL_EVENT_NAME_SHB_KERNEL_TO_USER,
+				     &EplEventuInstance_g.
+				     m_pShbKernelToUserInstance,
+				     &fShbNewCreated);
+	if (ShbError != kShbOk) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventuAddInstance(): ShbCirAllocBuffer(K2U) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+
+	// user -> kernel
+	ShbError = ShbCirAllocBuffer(EPL_EVENT_SIZE_SHB_USER_TO_KERNEL,
+				     EPL_EVENT_NAME_SHB_USER_TO_KERNEL,
+				     &EplEventuInstance_g.
+				     m_pShbUserToKernelInstance,
+				     &fShbNewCreated);
+	if (ShbError != kShbOk) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventuAddInstance(): ShbCirAllocBuffer(U2K) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+	// register eventhandler
+	ShbError =
+	    ShbCirSetSignalHandlerNewData(EplEventuInstance_g.
+					  m_pShbKernelToUserInstance,
+					  EplEventuRxSignalHandlerCb,
+					  kShbPriorityNormal);
+	if (ShbError != kShbOk) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventuAddInstance(): ShbCirSetSignalHandlerNewData(K2U) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+		goto Exit;
+	}
 
-Exit:
+      Exit:
 #endif
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -282,51 +282,52 @@ Exit:
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplEventuDelInstance()
 {
-tEplKernel      Ret;
+	tEplKernel Ret;
 #ifndef EPL_NO_FIFO
-tShbError       ShbError;
+	tShbError ShbError;
 #endif
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
 #ifndef EPL_NO_FIFO
-    // set eventhandler to NULL
-    ShbError = ShbCirSetSignalHandlerNewData (EplEventuInstance_g.m_pShbKernelToUserInstance,
-                                    NULL,
-                                    kShbPriorityNormal);
-    if(ShbError != kShbOk)
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventuDelInstance(): ShbCirSetSignalHandlerNewData(K2U) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-    }
-
-    // free buffer User -> Kernel
-    ShbError = ShbCirReleaseBuffer (EplEventuInstance_g.m_pShbUserToKernelInstance);
-    if((ShbError != kShbOk) && (ShbError != kShbMemUsedByOtherProcs))
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventuDelInstance(): ShbCirReleaseBuffer(U2K) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-    }
-    else
-    {
-        EplEventuInstance_g.m_pShbUserToKernelInstance = NULL;
-    }
-
-    // free buffer  Kernel -> User
-    ShbError = ShbCirReleaseBuffer (EplEventuInstance_g.m_pShbKernelToUserInstance);
-    if((ShbError != kShbOk) && (ShbError != kShbMemUsedByOtherProcs))
-    {
-        EPL_DBGLVL_EVENTK_TRACE1("EplEventuDelInstance(): ShbCirReleaseBuffer(K2U) -> 0x%X\n", ShbError);
-        Ret = kEplNoResource;
-    }
-    else
-    {
-        EplEventuInstance_g.m_pShbKernelToUserInstance = NULL;
-    }
+	// set eventhandler to NULL
+	ShbError =
+	    ShbCirSetSignalHandlerNewData(EplEventuInstance_g.
+					  m_pShbKernelToUserInstance, NULL,
+					  kShbPriorityNormal);
+	if (ShbError != kShbOk) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventuDelInstance(): ShbCirSetSignalHandlerNewData(K2U) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+	}
+	// free buffer User -> Kernel
+	ShbError =
+	    ShbCirReleaseBuffer(EplEventuInstance_g.m_pShbUserToKernelInstance);
+	if ((ShbError != kShbOk) && (ShbError != kShbMemUsedByOtherProcs)) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventuDelInstance(): ShbCirReleaseBuffer(U2K) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+	} else {
+		EplEventuInstance_g.m_pShbUserToKernelInstance = NULL;
+	}
+
+	// free buffer  Kernel -> User
+	ShbError =
+	    ShbCirReleaseBuffer(EplEventuInstance_g.m_pShbKernelToUserInstance);
+	if ((ShbError != kShbOk) && (ShbError != kShbMemUsedByOtherProcs)) {
+		EPL_DBGLVL_EVENTK_TRACE1
+		    ("EplEventuDelInstance(): ShbCirReleaseBuffer(K2U) -> 0x%X\n",
+		     ShbError);
+		Ret = kEplNoResource;
+	} else {
+		EplEventuInstance_g.m_pShbKernelToUserInstance = NULL;
+	}
 
 #endif
 
-return Ret;
+	return Ret;
 
 }
 
@@ -347,159 +348,153 @@ return Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplEventuProcess(tEplEvent* pEvent_p)
+tEplKernel PUBLIC EplEventuProcess(tEplEvent * pEvent_p)
 {
-tEplKernel              Ret;
-tEplEventSource         EventSource;
+	tEplKernel Ret;
+	tEplEventSource EventSource;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // check m_EventSink
-    switch(pEvent_p->m_EventSink)
-    {
-        // NMT-User-Module
-        case kEplEventSinkNmtu:
-        {
+	// check m_EventSink
+	switch (pEvent_p->m_EventSink) {
+		// NMT-User-Module
+	case kEplEventSinkNmtu:
+		{
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTU)) != 0)
-            Ret = EplNmtuProcessEvent(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourceNmtu;
-
-                // Error event for API layer
-                EplEventuPostError(kEplEventSourceEventu,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
+			Ret = EplNmtuProcessEvent(pEvent_p);
+			if ((Ret != kEplSuccessful) && (Ret != kEplShutdown)) {
+				EventSource = kEplEventSourceNmtu;
+
+				// Error event for API layer
+				EplEventuPostError(kEplEventSourceEventu,
+						   Ret,
+						   sizeof(EventSource),
+						   &EventSource);
+			}
 #endif
-            break;
-        }
+			break;
+		}
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-        // NMT-MN-User-Module
-        case kEplEventSinkNmtMnu:
-        {
-            Ret = EplNmtMnuProcessEvent(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourceNmtMnu;
-
-                // Error event for API layer
-                EplEventuPostError(kEplEventSourceEventu,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
-            break;
-        }
+		// NMT-MN-User-Module
+	case kEplEventSinkNmtMnu:
+		{
+			Ret = EplNmtMnuProcessEvent(pEvent_p);
+			if ((Ret != kEplSuccessful) && (Ret != kEplShutdown)) {
+				EventSource = kEplEventSourceNmtMnu;
+
+				// Error event for API layer
+				EplEventuPostError(kEplEventSourceEventu,
+						   Ret,
+						   sizeof(EventSource),
+						   &EventSource);
+			}
+			break;
+		}
 #endif
 
 #if ((((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)   \
      || (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0))
-        // events for asynchronus SDO Sequence Layer
-        case kEplEventSinkSdoAsySeq:
-        {
-            Ret = EplSdoAsySeqProcessEvent(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourceSdoAsySeq;
-
-                // Error event for API layer
-                EplEventuPostError(kEplEventSourceEventu,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
-            break;
-        }
-#endif
-
-        // LED user part module
-        case kEplEventSinkLedu:
-        {
+		// events for asynchronus SDO Sequence Layer
+	case kEplEventSinkSdoAsySeq:
+		{
+			Ret = EplSdoAsySeqProcessEvent(pEvent_p);
+			if ((Ret != kEplSuccessful) && (Ret != kEplShutdown)) {
+				EventSource = kEplEventSourceSdoAsySeq;
+
+				// Error event for API layer
+				EplEventuPostError(kEplEventSourceEventu,
+						   Ret,
+						   sizeof(EventSource),
+						   &EventSource);
+			}
+			break;
+		}
+#endif
+
+		// LED user part module
+	case kEplEventSinkLedu:
+		{
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_LEDU)) != 0)
-            Ret = EplLeduProcessEvent(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourceLedu;
-
-                // Error event for API layer
-                EplEventuPostError(kEplEventSourceEventu,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
-#endif
-            break;
-        }
+			Ret = EplLeduProcessEvent(pEvent_p);
+			if ((Ret != kEplSuccessful) && (Ret != kEplShutdown)) {
+				EventSource = kEplEventSourceLedu;
+
+				// Error event for API layer
+				EplEventuPostError(kEplEventSourceEventu,
+						   Ret,
+						   sizeof(EventSource),
+						   &EventSource);
+			}
+#endif
+			break;
+		}
+
+		// event for EPL api
+	case kEplEventSinkApi:
+		{
+			if (EplEventuInstance_g.m_pfnApiProcessEventCb != NULL) {
+				Ret =
+				    EplEventuInstance_g.
+				    m_pfnApiProcessEventCb(pEvent_p);
+				if ((Ret != kEplSuccessful)
+				    && (Ret != kEplShutdown)) {
+					EventSource = kEplEventSourceEplApi;
+
+					// Error event for API layer
+					EplEventuPostError
+					    (kEplEventSourceEventu, Ret,
+					     sizeof(EventSource), &EventSource);
+				}
+			}
+			break;
+
+		}
+
+	case kEplEventSinkDlluCal:
+		{
+			Ret = EplDlluCalProcess(pEvent_p);
+			if ((Ret != kEplSuccessful) && (Ret != kEplShutdown)) {
+				EventSource = kEplEventSourceDllu;
+
+				// Error event for API layer
+				EplEventuPostError(kEplEventSourceEventu,
+						   Ret,
+						   sizeof(EventSource),
+						   &EventSource);
+			}
+			break;
+
+		}
+
+	case kEplEventSinkErru:
+		{
+			/*
+			   Ret = EplErruProcess(pEvent_p);
+			   if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
+			   {
+			   EventSource = kEplEventSourceErru;
+
+			   // Error event for API layer
+			   EplEventuPostError(kEplEventSourceEventu,
+			   Ret,
+			   sizeof(EventSource),
+			   &EventSource);
+			   }
+			 */
+			break;
+
+		}
+
+		// unknown sink
+	default:
+		{
+			Ret = kEplEventUnknownSink;
+		}
 
-        // event for EPL api
-        case kEplEventSinkApi:
-        {
-            if (EplEventuInstance_g.m_pfnApiProcessEventCb != NULL)
-            {
-                Ret = EplEventuInstance_g.m_pfnApiProcessEventCb(pEvent_p);
-                if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-                {
-                    EventSource = kEplEventSourceEplApi;
-
-                    // Error event for API layer
-                    EplEventuPostError(kEplEventSourceEventu,
-                                    Ret,
-                                    sizeof(EventSource),
-                                    &EventSource);
-                }
-            }
-            break;
+	}			// end of switch(pEvent_p->m_EventSink)
 
-        }
-
-        case kEplEventSinkDlluCal:
-        {
-            Ret = EplDlluCalProcess(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourceDllu;
-
-                // Error event for API layer
-                EplEventuPostError(kEplEventSourceEventu,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
-            break;
-
-        }
-
-        case kEplEventSinkErru:
-        {
-            /*
-            Ret = EplErruProcess(pEvent_p);
-            if ((Ret != kEplSuccessful) && (Ret != kEplShutdown))
-            {
-                EventSource = kEplEventSourceErru;
-
-                // Error event for API layer
-                EplEventuPostError(kEplEventSourceEventu,
-                                Ret,
-                                sizeof(EventSource),
-                                &EventSource);
-            }
-            */
-            break;
-
-        }
-
-        // unknown sink
-        default:
-        {
-            Ret = kEplEventUnknownSink;
-        }
-
-    } // end of switch(pEvent_p->m_EventSink)
-
-    return Ret;
+	return Ret;
 
 }
 
@@ -522,143 +517,158 @@ tEplEventSource         EventSource;
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplEventuPost(tEplEvent * pEvent_p)
 {
-tEplKernel      Ret;
+	tEplKernel Ret;
 #ifndef EPL_NO_FIFO
-tShbError       ShbError;
-tShbCirChunk    ShbCirChunk;
-unsigned long   ulDataSize;
-unsigned int    fBufferCompleted;
-#endif
-
-    Ret = kEplSuccessful;
-
-
-#ifndef EPL_NO_FIFO
-    // 2006/08/03 d.k.: Event and argument are posted as separate chunks to the event queue.
-    ulDataSize = sizeof(tEplEvent) + ((pEvent_p->m_pArg != NULL) ? pEvent_p->m_uiSize : 0);
-#endif
-
-    // decide in which buffer the event have to write
-    switch(pEvent_p->m_EventSink)
-    {
-        // kernelspace modules
-        case kEplEventSinkSync:
-        case kEplEventSinkNmtk:
-        case kEplEventSinkDllk:
-        case kEplEventSinkDllkCal:
-        case kEplEventSinkPdok:
-        case kEplEventSinkErrk:
-        {
-#ifndef EPL_NO_FIFO
-            // post message
-            ShbError = ShbCirAllocDataBlock (EplEventuInstance_g.m_pShbUserToKernelInstance,
-                                   &ShbCirChunk,
-                                   ulDataSize);
-            if (ShbError != kShbOk)
-            {
-                EPL_DBGLVL_EVENTK_TRACE1("EplEventuPost(): ShbCirAllocDataBlock(U2K) -> 0x%X\n", ShbError);
-                Ret = kEplEventPostError;
-                goto Exit;
-            }
-            ShbError = ShbCirWriteDataChunk (EplEventuInstance_g.m_pShbUserToKernelInstance,
-                                   &ShbCirChunk,
-                                   pEvent_p,
-                                   sizeof (tEplEvent),
-                                   &fBufferCompleted);
-            if (ShbError != kShbOk)
-            {
-                EPL_DBGLVL_EVENTK_TRACE1("EplEventuPost(): ShbCirWriteDataChunk(U2K) -> 0x%X\n", ShbError);
-                Ret = kEplEventPostError;
-                goto Exit;
-            }
-            if (fBufferCompleted == FALSE)
-            {
-                ShbError = ShbCirWriteDataChunk (EplEventuInstance_g.m_pShbUserToKernelInstance,
-                                       &ShbCirChunk,
-                                       pEvent_p->m_pArg,
-                                       (unsigned long) pEvent_p->m_uiSize,
-                                       &fBufferCompleted);
-                if ((ShbError != kShbOk) || (fBufferCompleted == FALSE))
-                {
-                    EPL_DBGLVL_EVENTK_TRACE1("EplEventuPost(): ShbCirWriteDataChunk2(U2K) -> 0x%X\n", ShbError);
-                    Ret = kEplEventPostError;
-                    goto Exit;
-                }
-            }
+	tShbError ShbError;
+	tShbCirChunk ShbCirChunk;
+	unsigned long ulDataSize;
+	unsigned int fBufferCompleted;
+#endif
+
+	Ret = kEplSuccessful;
+
+#ifndef EPL_NO_FIFO
+	// 2006/08/03 d.k.: Event and argument are posted as separate chunks to the event queue.
+	ulDataSize =
+	    sizeof(tEplEvent) +
+	    ((pEvent_p->m_pArg != NULL) ? pEvent_p->m_uiSize : 0);
+#endif
+
+	// decide in which buffer the event have to write
+	switch (pEvent_p->m_EventSink) {
+		// kernelspace modules
+	case kEplEventSinkSync:
+	case kEplEventSinkNmtk:
+	case kEplEventSinkDllk:
+	case kEplEventSinkDllkCal:
+	case kEplEventSinkPdok:
+	case kEplEventSinkErrk:
+		{
+#ifndef EPL_NO_FIFO
+			// post message
+			ShbError =
+			    ShbCirAllocDataBlock(EplEventuInstance_g.
+						 m_pShbUserToKernelInstance,
+						 &ShbCirChunk, ulDataSize);
+			if (ShbError != kShbOk) {
+				EPL_DBGLVL_EVENTK_TRACE1
+				    ("EplEventuPost(): ShbCirAllocDataBlock(U2K) -> 0x%X\n",
+				     ShbError);
+				Ret = kEplEventPostError;
+				goto Exit;
+			}
+			ShbError =
+			    ShbCirWriteDataChunk(EplEventuInstance_g.
+						 m_pShbUserToKernelInstance,
+						 &ShbCirChunk, pEvent_p,
+						 sizeof(tEplEvent),
+						 &fBufferCompleted);
+			if (ShbError != kShbOk) {
+				EPL_DBGLVL_EVENTK_TRACE1
+				    ("EplEventuPost(): ShbCirWriteDataChunk(U2K) -> 0x%X\n",
+				     ShbError);
+				Ret = kEplEventPostError;
+				goto Exit;
+			}
+			if (fBufferCompleted == FALSE) {
+				ShbError =
+				    ShbCirWriteDataChunk(EplEventuInstance_g.
+							 m_pShbUserToKernelInstance,
+							 &ShbCirChunk,
+							 pEvent_p->m_pArg,
+							 (unsigned long)
+							 pEvent_p->m_uiSize,
+							 &fBufferCompleted);
+				if ((ShbError != kShbOk)
+				    || (fBufferCompleted == FALSE)) {
+					EPL_DBGLVL_EVENTK_TRACE1
+					    ("EplEventuPost(): ShbCirWriteDataChunk2(U2K) -> 0x%X\n",
+					     ShbError);
+					Ret = kEplEventPostError;
+					goto Exit;
+				}
+			}
 #else
-            Ret = EplEventkProcess(pEvent_p);
+			Ret = EplEventkProcess(pEvent_p);
 #endif
 
-            break;
-        }
-
-        // userspace modules
-        case kEplEventSinkNmtMnu:
-        case kEplEventSinkNmtu:
-        case kEplEventSinkSdoAsySeq:
-        case kEplEventSinkApi:
-        case kEplEventSinkDlluCal:
-        case kEplEventSinkErru:
-        case kEplEventSinkLedu:
-        {
-#ifndef EPL_NO_FIFO
-            // post message
-            ShbError = ShbCirAllocDataBlock (EplEventuInstance_g.m_pShbKernelToUserInstance,
-                                   &ShbCirChunk,
-                                   ulDataSize);
-            if(ShbError != kShbOk)
-            {
-                EPL_DBGLVL_EVENTK_TRACE1("EplEventuPost(): ShbCirAllocDataBlock(K2U) -> 0x%X\n", ShbError);
-                Ret = kEplEventPostError;
-                goto Exit;
-            }
-            ShbError = ShbCirWriteDataChunk (EplEventuInstance_g.m_pShbKernelToUserInstance,
-                                   &ShbCirChunk,
-                                   pEvent_p,
-                                   sizeof (tEplEvent),
-                                   &fBufferCompleted);
-            if(ShbError != kShbOk)
-            {
-                EPL_DBGLVL_EVENTK_TRACE1("EplEventuPost(): ShbCirWriteDataChunk(K2U) -> 0x%X\n", ShbError);
-                Ret = kEplEventPostError;
-                goto Exit;
-            }
-            if (fBufferCompleted == FALSE)
-            {
-                ShbError = ShbCirWriteDataChunk (EplEventuInstance_g.m_pShbKernelToUserInstance,
-                                       &ShbCirChunk,
-                                       pEvent_p->m_pArg,
-                                       (unsigned long) pEvent_p->m_uiSize,
-                                       &fBufferCompleted);
-                if ((ShbError != kShbOk) || (fBufferCompleted == FALSE))
-                {
-                    EPL_DBGLVL_EVENTK_TRACE1("EplEventuPost(): ShbCirWriteDataChunk2(K2U) -> 0x%X\n", ShbError);
-                    Ret = kEplEventPostError;
-                    goto Exit;
-                }
-            }
+			break;
+		}
 
+		// userspace modules
+	case kEplEventSinkNmtMnu:
+	case kEplEventSinkNmtu:
+	case kEplEventSinkSdoAsySeq:
+	case kEplEventSinkApi:
+	case kEplEventSinkDlluCal:
+	case kEplEventSinkErru:
+	case kEplEventSinkLedu:
+		{
+#ifndef EPL_NO_FIFO
+			// post message
+			ShbError =
+			    ShbCirAllocDataBlock(EplEventuInstance_g.
+						 m_pShbKernelToUserInstance,
+						 &ShbCirChunk, ulDataSize);
+			if (ShbError != kShbOk) {
+				EPL_DBGLVL_EVENTK_TRACE1
+				    ("EplEventuPost(): ShbCirAllocDataBlock(K2U) -> 0x%X\n",
+				     ShbError);
+				Ret = kEplEventPostError;
+				goto Exit;
+			}
+			ShbError =
+			    ShbCirWriteDataChunk(EplEventuInstance_g.
+						 m_pShbKernelToUserInstance,
+						 &ShbCirChunk, pEvent_p,
+						 sizeof(tEplEvent),
+						 &fBufferCompleted);
+			if (ShbError != kShbOk) {
+				EPL_DBGLVL_EVENTK_TRACE1
+				    ("EplEventuPost(): ShbCirWriteDataChunk(K2U) -> 0x%X\n",
+				     ShbError);
+				Ret = kEplEventPostError;
+				goto Exit;
+			}
+			if (fBufferCompleted == FALSE) {
+				ShbError =
+				    ShbCirWriteDataChunk(EplEventuInstance_g.
+							 m_pShbKernelToUserInstance,
+							 &ShbCirChunk,
+							 pEvent_p->m_pArg,
+							 (unsigned long)
+							 pEvent_p->m_uiSize,
+							 &fBufferCompleted);
+				if ((ShbError != kShbOk)
+				    || (fBufferCompleted == FALSE)) {
+					EPL_DBGLVL_EVENTK_TRACE1
+					    ("EplEventuPost(): ShbCirWriteDataChunk2(K2U) -> 0x%X\n",
+					     ShbError);
+					Ret = kEplEventPostError;
+					goto Exit;
+				}
+			}
 #else
-            Ret = EplEventuProcess(pEvent_p);
+			Ret = EplEventuProcess(pEvent_p);
 #endif
 
-            break;
-        }
-
-        default:
-        {
-            Ret = kEplEventUnknownSink;
-        }
+			break;
+		}
 
+	default:
+		{
+			Ret = kEplEventUnknownSink;
+		}
 
-    }// end of switch(pEvent_p->m_EventSink)
+	}			// end of switch(pEvent_p->m_EventSink)
 
 #ifndef EPL_NO_FIFO
-Exit:
+      Exit:
 #endif
-    return Ret;
+	return Ret;
 
 }
+
 //---------------------------------------------------------------------------
 //
 // Function:    EplEventuPostError
@@ -680,36 +690,35 @@ Exit:
 //
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplEventuPostError(tEplEventSource EventSource_p,
-                                     tEplKernel      EplError_p,
-                                     unsigned int    uiArgSize_p,
-                                     void*           pArg_p)
+				     tEplKernel EplError_p,
+				     unsigned int uiArgSize_p, void *pArg_p)
 {
-tEplKernel  Ret;
-BYTE        abBuffer[EPL_MAX_EVENT_ARG_SIZE];
-tEplEventError* pEventError = (tEplEventError*) abBuffer;
-tEplEvent   EplEvent;
-
-    Ret = kEplSuccessful;
-
-    // create argument
-    pEventError->m_EventSource = EventSource_p;
-    pEventError->m_EplError = EplError_p;
-    EPL_MEMCPY(&pEventError->m_Arg, pArg_p, uiArgSize_p);
-
-    // create event
-    EplEvent.m_EventType = kEplEventTypeError;
-    EplEvent.m_EventSink = kEplEventSinkApi;
-    EPL_MEMSET(&EplEvent.m_NetTime, 0x00, sizeof(EplEvent.m_NetTime));
-    EplEvent.m_uiSize = (sizeof(EventSource_p)+ sizeof(EplError_p)+ uiArgSize_p);
-    EplEvent.m_pArg = &abBuffer[0];
+	tEplKernel Ret;
+	BYTE abBuffer[EPL_MAX_EVENT_ARG_SIZE];
+	tEplEventError *pEventError = (tEplEventError *) abBuffer;
+	tEplEvent EplEvent;
+
+	Ret = kEplSuccessful;
+
+	// create argument
+	pEventError->m_EventSource = EventSource_p;
+	pEventError->m_EplError = EplError_p;
+	EPL_MEMCPY(&pEventError->m_Arg, pArg_p, uiArgSize_p);
+
+	// create event
+	EplEvent.m_EventType = kEplEventTypeError;
+	EplEvent.m_EventSink = kEplEventSinkApi;
+	EPL_MEMSET(&EplEvent.m_NetTime, 0x00, sizeof(EplEvent.m_NetTime));
+	EplEvent.m_uiSize =
+	    (sizeof(EventSource_p) + sizeof(EplError_p) + uiArgSize_p);
+	EplEvent.m_pArg = &abBuffer[0];
 
-    // post errorevent
-    Ret = EplEventuPost(&EplEvent);
+	// post errorevent
+	Ret = EplEventuPost(&EplEvent);
 
-    return Ret;
+	return Ret;
 }
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -735,19 +744,18 @@ tEplEvent   EplEvent;
 //
 //---------------------------------------------------------------------------
 #ifndef EPL_NO_FIFO
-static void  EplEventuRxSignalHandlerCb (
-    tShbInstance pShbRxInstance_p,
-    unsigned long ulDataSize_p)
+static void EplEventuRxSignalHandlerCb(tShbInstance pShbRxInstance_p,
+				       unsigned long ulDataSize_p)
 {
-tEplEvent      *pEplEvent;
-tShbError       ShbError;
+	tEplEvent *pEplEvent;
+	tShbError ShbError;
 //unsigned long   ulBlockCount;
 //unsigned long   ulDataSize;
-BYTE            abDataBuffer[sizeof(tEplEvent) + EPL_MAX_EVENT_ARG_SIZE];
-                // d.k.: abDataBuffer contains the complete tEplEvent structure
-                //       and behind this the argument
+	BYTE abDataBuffer[sizeof(tEplEvent) + EPL_MAX_EVENT_ARG_SIZE];
+	// d.k.: abDataBuffer contains the complete tEplEvent structure
+	//       and behind this the argument
 
-    TGT_DBG_SIGNAL_TRACE_POINT(21);
+	TGT_DBG_SIGNAL_TRACE_POINT(21);
 
 // d.k. not needed because it is already done in SharedBuff
 /*    do
@@ -763,38 +771,32 @@ BYTE            abDataBuffer[sizeof(tEpl
 
         BENCHMARK_MOD_28_RESET(1);  // 14 µs until set
 */
-        // copy data from event queue
-        ShbError = ShbCirReadDataBlock (pShbRxInstance_p,
-                                &abDataBuffer[0],
-                                sizeof(abDataBuffer),
-                                &ulDataSize_p);
-        if(ShbError != kShbOk)
-        {
-            // error goto exit
-            goto Exit;
-        }
+	// copy data from event queue
+	ShbError = ShbCirReadDataBlock(pShbRxInstance_p,
+				       &abDataBuffer[0],
+				       sizeof(abDataBuffer), &ulDataSize_p);
+	if (ShbError != kShbOk) {
+		// error goto exit
+		goto Exit;
+	}
+	// resolve the pointer to the event structure
+	pEplEvent = (tEplEvent *) abDataBuffer;
+	// set Datasize
+	pEplEvent->m_uiSize = (ulDataSize_p - sizeof(tEplEvent));
+	if (pEplEvent->m_uiSize > 0) {
+		// set pointer to argument
+		pEplEvent->m_pArg = &abDataBuffer[sizeof(tEplEvent)];
+	} else {
+		//set pointer to NULL
+		pEplEvent->m_pArg = NULL;
+	}
+
+	BENCHMARK_MOD_28_SET(1);
+	// call processfunction
+	EplEventuProcess(pEplEvent);
 
-        // resolve the pointer to the event structure
-        pEplEvent = (tEplEvent *) abDataBuffer;
-        // set Datasize
-        pEplEvent->m_uiSize = (ulDataSize_p - sizeof(tEplEvent));
-        if(pEplEvent->m_uiSize > 0)
-        {
-            // set pointer to argument
-            pEplEvent->m_pArg = &abDataBuffer[sizeof(tEplEvent)];
-        }
-        else
-        {
-            //set pointer to NULL
-            pEplEvent->m_pArg = NULL;
-        }
-
-        BENCHMARK_MOD_28_SET(1);
-        // call processfunction
-        EplEventuProcess(pEplEvent);
-
-        BENCHMARK_MOD_28_RESET(1);
-        // read number of left messages to process
+	BENCHMARK_MOD_28_RESET(1);
+	// read number of left messages to process
 // d.k. not needed because it is already done in SharedBuff
 /*        ShbError = ShbCirGetReadBlockCount (pShbRxInstance_p, &ulBlockCount);
         if (ShbError != kShbOk)
@@ -804,10 +806,9 @@ BYTE            abDataBuffer[sizeof(tEpl
         }
     } while (ulBlockCount > 0);
 */
-Exit:
-    return;
+      Exit:
+	return;
 }
 #endif
 
 // EOF
-
--- a/drivers/staging/epl/EplIdentu.c
+++ b/drivers/staging/epl/EplIdentu.c
@@ -95,7 +95,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -109,7 +108,6 @@
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -124,10 +122,9 @@
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    tEplIdentResponse*   m_apIdentResponse[254];    // the IdentResponse are managed dynamically
-    tEplIdentuCbResponse m_apfnCbResponse[254];
+typedef struct {
+	tEplIdentResponse *m_apIdentResponse[254];	// the IdentResponse are managed dynamically
+	tEplIdentuCbResponse m_apfnCbResponse[254];
 
 } tEplIdentuInstance;
 
@@ -135,7 +132,7 @@ typedef struct
 // local vars
 //---------------------------------------------------------------------------
 
-static tEplIdentuInstance   EplIdentuInstance_g;
+static tEplIdentuInstance EplIdentuInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
@@ -169,14 +166,13 @@ static tEplKernel PUBLIC EplIdentuCbIden
 
 EPLDLLEXPORT tEplKernel PUBLIC EplIdentuInit()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = EplIdentuAddInstance();
+	Ret = EplIdentuAddInstance();
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplIdentuAddInstance
@@ -197,21 +193,23 @@ tEplKernel Ret;
 
 EPLDLLEXPORT tEplKernel PUBLIC EplIdentuAddInstance()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // reset instance structure
-    EPL_MEMSET(&EplIdentuInstance_g, 0, sizeof (EplIdentuInstance_g));
+	// reset instance structure
+	EPL_MEMSET(&EplIdentuInstance_g, 0, sizeof(EplIdentuInstance_g));
 
-    // register IdentResponse callback function
-    Ret = EplDlluCalRegAsndService(kEplDllAsndIdentResponse, EplIdentuCbIdentResponse, kEplDllAsndFilterAny);
+	// register IdentResponse callback function
+	Ret =
+	    EplDlluCalRegAsndService(kEplDllAsndIdentResponse,
+				     EplIdentuCbIdentResponse,
+				     kEplDllAsndFilterAny);
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplIdentuDelInstance
@@ -232,20 +230,21 @@ tEplKernel Ret;
 
 EPLDLLEXPORT tEplKernel PUBLIC EplIdentuDelInstance()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // deregister IdentResponse callback function
-    Ret = EplDlluCalRegAsndService(kEplDllAsndIdentResponse, NULL, kEplDllAsndFilterNone);
+	// deregister IdentResponse callback function
+	Ret =
+	    EplDlluCalRegAsndService(kEplDllAsndIdentResponse, NULL,
+				     kEplDllAsndFilterNone);
 
-    Ret = EplIdentuReset();
+	Ret = EplIdentuReset();
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplIdentuReset
@@ -266,26 +265,25 @@ tEplKernel  Ret;
 
 EPLDLLEXPORT tEplKernel PUBLIC EplIdentuReset()
 {
-tEplKernel  Ret;
-int         iIndex;
+	tEplKernel Ret;
+	int iIndex;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    for (iIndex = 0; iIndex < tabentries (EplIdentuInstance_g.m_apIdentResponse); iIndex++)
-    {
-        if (EplIdentuInstance_g.m_apIdentResponse[iIndex] != NULL)
-        {   // free memory
-            EPL_FREE(EplIdentuInstance_g.m_apIdentResponse[iIndex]);
-        }
-    }
+	for (iIndex = 0;
+	     iIndex < tabentries(EplIdentuInstance_g.m_apIdentResponse);
+	     iIndex++) {
+		if (EplIdentuInstance_g.m_apIdentResponse[iIndex] != NULL) {	// free memory
+			EPL_FREE(EplIdentuInstance_g.m_apIdentResponse[iIndex]);
+		}
+	}
 
-    EPL_MEMSET(&EplIdentuInstance_g, 0, sizeof (EplIdentuInstance_g));
+	EPL_MEMSET(&EplIdentuInstance_g, 0, sizeof(EplIdentuInstance_g));
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplIdentuGetIdentResponse
@@ -302,31 +300,28 @@ int         iIndex;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplIdentuGetIdentResponse(
-                                    unsigned int        uiNodeId_p,
-                                    tEplIdentResponse** ppIdentResponse_p)
+tEplKernel PUBLIC EplIdentuGetIdentResponse(unsigned int uiNodeId_p,
+					    tEplIdentResponse **
+					    ppIdentResponse_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // decrement node ID, because array is zero based
-    uiNodeId_p--;
-    if (uiNodeId_p < tabentries (EplIdentuInstance_g.m_apIdentResponse))
-    {
-        *ppIdentResponse_p = EplIdentuInstance_g.m_apIdentResponse[uiNodeId_p];
-    }
-    else
-    {   // invalid node ID specified
-        *ppIdentResponse_p = NULL;
-        Ret = kEplInvalidNodeId;
-    }
+	// decrement node ID, because array is zero based
+	uiNodeId_p--;
+	if (uiNodeId_p < tabentries(EplIdentuInstance_g.m_apIdentResponse)) {
+		*ppIdentResponse_p =
+		    EplIdentuInstance_g.m_apIdentResponse[uiNodeId_p];
+	} else {		// invalid node ID specified
+		*ppIdentResponse_p = NULL;
+		Ret = kEplInvalidNodeId;
+	}
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplIdentuRequestIdentResponse
@@ -343,42 +338,38 @@ tEplKernel  Ret;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplIdentuRequestIdentResponse(
-                                    unsigned int        uiNodeId_p,
-                                    tEplIdentuCbResponse pfnCbResponse_p)
+tEplKernel PUBLIC EplIdentuRequestIdentResponse(unsigned int uiNodeId_p,
+						tEplIdentuCbResponse
+						pfnCbResponse_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // decrement node ID, because array is zero based
-    uiNodeId_p--;
-    if (uiNodeId_p < tabentries (EplIdentuInstance_g.m_apfnCbResponse))
-    {
+	// decrement node ID, because array is zero based
+	uiNodeId_p--;
+	if (uiNodeId_p < tabentries(EplIdentuInstance_g.m_apfnCbResponse)) {
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-        if (EplIdentuInstance_g.m_apfnCbResponse[uiNodeId_p] != NULL)
-        {   // request already issued (maybe by someone else)
-            Ret = kEplInvalidOperation;
-        }
-        else
-        {
-            EplIdentuInstance_g.m_apfnCbResponse[uiNodeId_p] = pfnCbResponse_p;
-            Ret = EplDlluCalIssueRequest(kEplDllReqServiceIdent, (uiNodeId_p + 1), 0xFF);
-        }
+		if (EplIdentuInstance_g.m_apfnCbResponse[uiNodeId_p] != NULL) {	// request already issued (maybe by someone else)
+			Ret = kEplInvalidOperation;
+		} else {
+			EplIdentuInstance_g.m_apfnCbResponse[uiNodeId_p] =
+			    pfnCbResponse_p;
+			Ret =
+			    EplDlluCalIssueRequest(kEplDllReqServiceIdent,
+						   (uiNodeId_p + 1), 0xFF);
+		}
 #else
-        Ret = kEplInvalidOperation;
+		Ret = kEplInvalidOperation;
 #endif
-    }
-    else
-    {   // invalid node ID specified
-        Ret = kEplInvalidNodeId;
-    }
+	} else {		// invalid node ID specified
+		Ret = kEplInvalidNodeId;
+	}
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplIdentuGetRunningRequests
@@ -399,21 +390,18 @@ tEplKernel  Ret;
 
 EPLDLLEXPORT DWORD PUBLIC EplIdentuGetRunningRequests(void)
 {
-DWORD       dwReqs = 0;
-unsigned int    uiIndex;
+	DWORD dwReqs = 0;
+	unsigned int uiIndex;
 
-    for (uiIndex = 0; uiIndex < 32; uiIndex++)
-    {
-        if (EplIdentuInstance_g.m_apfnCbResponse[uiIndex] != NULL)
-        {
-            dwReqs |= (1 << uiIndex);
-        }
-    }
+	for (uiIndex = 0; uiIndex < 32; uiIndex++) {
+		if (EplIdentuInstance_g.m_apfnCbResponse[uiIndex] != NULL) {
+			dwReqs |= (1 << uiIndex);
+		}
+	}
 
-    return dwReqs;
+	return dwReqs;
 }
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -440,58 +428,61 @@ unsigned int    uiIndex;
 
 static tEplKernel PUBLIC EplIdentuCbIdentResponse(tEplFrameInfo * pFrameInfo_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-unsigned int    uiNodeId;
-unsigned int    uiIndex;
-tEplIdentuCbResponse    pfnCbResponse;
-
-    uiNodeId = AmiGetByteFromLe(&pFrameInfo_p->m_pFrame->m_le_bSrcNodeId);
-
-    uiIndex = uiNodeId - 1;
-
-    if (uiIndex < tabentries (EplIdentuInstance_g.m_apfnCbResponse))
-    {
-        // memorize pointer to callback function
-        pfnCbResponse = EplIdentuInstance_g.m_apfnCbResponse[uiIndex];
-        // reset callback function pointer so that caller may issue next request immediately
-        EplIdentuInstance_g.m_apfnCbResponse[uiIndex] = NULL;
-
-        if (pFrameInfo_p->m_uiFrameSize < EPL_C_DLL_MINSIZE_IDENTRES)
-        {   // IdentResponse not received or it has invalid size
-            if (pfnCbResponse == NULL)
-            {   // response was not requested
-                goto Exit;
-            }
-            Ret = pfnCbResponse(uiNodeId, NULL);
-        }
-        else
-        {   // IdentResponse received
-            if (EplIdentuInstance_g.m_apIdentResponse[uiIndex] == NULL)
-            {   // memory for IdentResponse must be allocated
-                EplIdentuInstance_g.m_apIdentResponse[uiIndex] = EPL_MALLOC(sizeof (tEplIdentResponse));
-                if (EplIdentuInstance_g.m_apIdentResponse[uiIndex] == NULL)
-                {   // malloc failed
-                    if (pfnCbResponse == NULL)
-                    {   // response was not requested
-                        goto Exit;
-                    }
-                    Ret = pfnCbResponse(uiNodeId, &pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse);
-                    goto Exit;
-                }
-            }
-            // copy IdentResponse to instance structure
-            EPL_MEMCPY(EplIdentuInstance_g.m_apIdentResponse[uiIndex], &pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_IdentResponse, sizeof(tEplIdentResponse));
-            if (pfnCbResponse == NULL)
-            {   // response was not requested
-                goto Exit;
-            }
-            Ret = pfnCbResponse(uiNodeId, EplIdentuInstance_g.m_apIdentResponse[uiIndex]);
-        }
-    }
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiNodeId;
+	unsigned int uiIndex;
+	tEplIdentuCbResponse pfnCbResponse;
+
+	uiNodeId = AmiGetByteFromLe(&pFrameInfo_p->m_pFrame->m_le_bSrcNodeId);
+
+	uiIndex = uiNodeId - 1;
+
+	if (uiIndex < tabentries(EplIdentuInstance_g.m_apfnCbResponse)) {
+		// memorize pointer to callback function
+		pfnCbResponse = EplIdentuInstance_g.m_apfnCbResponse[uiIndex];
+		// reset callback function pointer so that caller may issue next request immediately
+		EplIdentuInstance_g.m_apfnCbResponse[uiIndex] = NULL;
+
+		if (pFrameInfo_p->m_uiFrameSize < EPL_C_DLL_MINSIZE_IDENTRES) {	// IdentResponse not received or it has invalid size
+			if (pfnCbResponse == NULL) {	// response was not requested
+				goto Exit;
+			}
+			Ret = pfnCbResponse(uiNodeId, NULL);
+		} else {	// IdentResponse received
+			if (EplIdentuInstance_g.m_apIdentResponse[uiIndex] == NULL) {	// memory for IdentResponse must be allocated
+				EplIdentuInstance_g.m_apIdentResponse[uiIndex] =
+				    EPL_MALLOC(sizeof(tEplIdentResponse));
+				if (EplIdentuInstance_g.m_apIdentResponse[uiIndex] == NULL) {	// malloc failed
+					if (pfnCbResponse == NULL) {	// response was not requested
+						goto Exit;
+					}
+					Ret =
+					    pfnCbResponse(uiNodeId,
+							  &pFrameInfo_p->
+							  m_pFrame->m_Data.
+							  m_Asnd.m_Payload.
+							  m_IdentResponse);
+					goto Exit;
+				}
+			}
+			// copy IdentResponse to instance structure
+			EPL_MEMCPY(EplIdentuInstance_g.
+				   m_apIdentResponse[uiIndex],
+				   &pFrameInfo_p->m_pFrame->m_Data.m_Asnd.
+				   m_Payload.m_IdentResponse,
+				   sizeof(tEplIdentResponse));
+			if (pfnCbResponse == NULL) {	// response was not requested
+				goto Exit;
+			}
+			Ret =
+			    pfnCbResponse(uiNodeId,
+					  EplIdentuInstance_g.
+					  m_apIdentResponse[uiIndex]);
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 // EOF
-
--- a/drivers/staging/epl/EplNmtCnu.c
+++ b/drivers/staging/epl/EplNmtCnu.c
@@ -90,10 +90,9 @@
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    unsigned int                m_uiNodeId;
-    tEplNmtuCheckEventCallback  m_pfnCheckEventCb;
+typedef struct {
+	unsigned int m_uiNodeId;
+	tEplNmtuCheckEventCallback m_pfnCheckEventCb;
 
 } tEplNmtCnuInstance;
 
@@ -101,7 +100,7 @@ typedef struct
 // modul globale vars
 //---------------------------------------------------------------------------
 
-static tEplNmtCnuInstance   EplNmtCnuInstance_g;
+static tEplNmtCnuInstance EplNmtCnuInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
@@ -109,12 +108,10 @@ static tEplNmtCnuInstance   EplNmtCnuIns
 
 static tEplNmtCommand EplNmtCnuGetNmtCommand(tEplFrameInfo * pFrameInfo_p);
 
-static BOOL EplNmtCnuNodeIdList(BYTE* pbNmtCommandDate_p);
+static BOOL EplNmtCnuNodeIdList(BYTE * pbNmtCommandDate_p);
 
 static tEplKernel PUBLIC EplNmtCnuCommandCb(tEplFrameInfo * pFrameInfo_p);
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -140,11 +137,11 @@ static tEplKernel PUBLIC EplNmtCnuComman
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtCnuInit(unsigned int uiNodeId_p)
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = EplNmtCnuAddInstance(uiNodeId_p);
+	Ret = EplNmtCnuAddInstance(uiNodeId_p);
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -166,25 +163,24 @@ tEplKernel Ret;
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtCnuAddInstance(unsigned int uiNodeId_p)
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // reset instance structure
-    EPL_MEMSET(&EplNmtCnuInstance_g, 0, sizeof (EplNmtCnuInstance_g));
+	// reset instance structure
+	EPL_MEMSET(&EplNmtCnuInstance_g, 0, sizeof(EplNmtCnuInstance_g));
 
-    // save nodeid
-    EplNmtCnuInstance_g.m_uiNodeId = uiNodeId_p;
+	// save nodeid
+	EplNmtCnuInstance_g.m_uiNodeId = uiNodeId_p;
 
-    // register callback-function for NMT-commands
+	// register callback-function for NMT-commands
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
-    Ret = EplDlluCalRegAsndService(kEplDllAsndNmtCommand,
-                                   EplNmtCnuCommandCb,
-                                   kEplDllAsndFilterLocal);
+	Ret = EplDlluCalRegAsndService(kEplDllAsndNmtCommand,
+				       EplNmtCnuCommandCb,
+				       kEplDllAsndFilterLocal);
 #endif
 
-
-    return Ret;
+	return Ret;
 
 }
 
@@ -207,18 +203,17 @@ tEplKernel Ret;
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtCnuDelInstance()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
-    // deregister callback function from DLL
-    Ret = EplDlluCalRegAsndService(kEplDllAsndNmtCommand,
-                                   NULL,
-                                   kEplDllAsndFilterNone);
+	// deregister callback function from DLL
+	Ret = EplDlluCalRegAsndService(kEplDllAsndNmtCommand,
+				       NULL, kEplDllAsndFilterNone);
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -239,49 +234,50 @@ tEplKernel Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplNmtCnuSendNmtRequest(
-                                    unsigned int uiNodeId_p,
-                                    tEplNmtCommand NmtCommand_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplNmtCnuSendNmtRequest(unsigned int uiNodeId_p,
+						       tEplNmtCommand
+						       NmtCommand_p)
 {
-tEplKernel      Ret;
-tEplFrameInfo   NmtRequestFrameInfo;
-tEplFrame       NmtRequestFrame;
-
-
-    Ret = kEplSuccessful;
-
-    // build frame
-    EPL_MEMSET(&NmtRequestFrame.m_be_abDstMac[0], 0x00, sizeof(NmtRequestFrame.m_be_abDstMac)); // set by DLL
-    EPL_MEMSET(&NmtRequestFrame.m_be_abSrcMac[0], 0x00, sizeof(NmtRequestFrame.m_be_abSrcMac)); // set by DLL
-    AmiSetWordToBe(&NmtRequestFrame.m_be_wEtherType, EPL_C_DLL_ETHERTYPE_EPL);
-    AmiSetByteToLe(&NmtRequestFrame.m_le_bDstNodeId, (BYTE) EPL_C_ADR_MN_DEF_NODE_ID); // node id of the MN
-    AmiSetByteToLe(&NmtRequestFrame.m_le_bMessageType, (BYTE)kEplMsgTypeAsnd);
-    AmiSetByteToLe(&NmtRequestFrame.m_Data.m_Asnd.m_le_bServiceId, (BYTE) kEplDllAsndNmtRequest);
-    AmiSetByteToLe(&NmtRequestFrame.m_Data.m_Asnd.m_Payload.m_NmtRequestService.m_le_bNmtCommandId,
-        (BYTE)NmtCommand_p);
-    AmiSetByteToLe(&NmtRequestFrame.m_Data.m_Asnd.m_Payload.m_NmtRequestService.m_le_bTargetNodeId,
-        (BYTE)uiNodeId_p); // target for the nmt command
-    EPL_MEMSET(&NmtRequestFrame.m_Data.m_Asnd.m_Payload.m_NmtRequestService.m_le_abNmtCommandData[0], 0x00, sizeof(NmtRequestFrame.m_Data.m_Asnd.m_Payload.m_NmtRequestService.m_le_abNmtCommandData));
-
-
+	tEplKernel Ret;
+	tEplFrameInfo NmtRequestFrameInfo;
+	tEplFrame NmtRequestFrame;
+
+	Ret = kEplSuccessful;
+
+	// build frame
+	EPL_MEMSET(&NmtRequestFrame.m_be_abDstMac[0], 0x00, sizeof(NmtRequestFrame.m_be_abDstMac));	// set by DLL
+	EPL_MEMSET(&NmtRequestFrame.m_be_abSrcMac[0], 0x00, sizeof(NmtRequestFrame.m_be_abSrcMac));	// set by DLL
+	AmiSetWordToBe(&NmtRequestFrame.m_be_wEtherType,
+		       EPL_C_DLL_ETHERTYPE_EPL);
+	AmiSetByteToLe(&NmtRequestFrame.m_le_bDstNodeId, (BYTE) EPL_C_ADR_MN_DEF_NODE_ID);	// node id of the MN
+	AmiSetByteToLe(&NmtRequestFrame.m_le_bMessageType,
+		       (BYTE) kEplMsgTypeAsnd);
+	AmiSetByteToLe(&NmtRequestFrame.m_Data.m_Asnd.m_le_bServiceId,
+		       (BYTE) kEplDllAsndNmtRequest);
+	AmiSetByteToLe(&NmtRequestFrame.m_Data.m_Asnd.m_Payload.
+		       m_NmtRequestService.m_le_bNmtCommandId,
+		       (BYTE) NmtCommand_p);
+	AmiSetByteToLe(&NmtRequestFrame.m_Data.m_Asnd.m_Payload.m_NmtRequestService.m_le_bTargetNodeId, (BYTE) uiNodeId_p);	// target for the nmt command
+	EPL_MEMSET(&NmtRequestFrame.m_Data.m_Asnd.m_Payload.m_NmtRequestService.
+		   m_le_abNmtCommandData[0], 0x00,
+		   sizeof(NmtRequestFrame.m_Data.m_Asnd.m_Payload.
+			  m_NmtRequestService.m_le_abNmtCommandData));
+
+	// build info-structure
+	NmtRequestFrameInfo.m_NetTime.m_dwNanoSec = 0;
+	NmtRequestFrameInfo.m_NetTime.m_dwSec = 0;
+	NmtRequestFrameInfo.m_pFrame = &NmtRequestFrame;
+	NmtRequestFrameInfo.m_uiFrameSize = EPL_C_DLL_MINSIZE_NMTREQ;	// sizeof(NmtRequestFrame);
 
-    // build info-structure
-    NmtRequestFrameInfo.m_NetTime.m_dwNanoSec = 0;
-    NmtRequestFrameInfo.m_NetTime.m_dwSec = 0;
-    NmtRequestFrameInfo.m_pFrame = &NmtRequestFrame;
-    NmtRequestFrameInfo.m_uiFrameSize = EPL_C_DLL_MINSIZE_NMTREQ; // sizeof(NmtRequestFrame);
-
-    // send NMT-Request
+	// send NMT-Request
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
-    Ret = EplDlluCalAsyncSend(&NmtRequestFrameInfo,    // pointer to frameinfo
-                           kEplDllAsyncReqPrioNmt); // priority
+	Ret = EplDlluCalAsyncSend(&NmtRequestFrameInfo,	// pointer to frameinfo
+				  kEplDllAsyncReqPrioNmt);	// priority
 #endif
 
-
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtCnuRegisterStateChangeCb
@@ -301,17 +297,18 @@ tEplFrame       NmtRequestFrame;
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT tEplKernel PUBLIC EplNmtCnuRegisterCheckEventCb(
-            tEplNmtuCheckEventCallback pfnEplNmtCheckEventCb_p)
+EPLDLLEXPORT tEplKernel PUBLIC
+EplNmtCnuRegisterCheckEventCb(tEplNmtuCheckEventCallback
+			      pfnEplNmtCheckEventCb_p)
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // save callback-function in modul global var
-    EplNmtCnuInstance_g.m_pfnCheckEventCb = pfnEplNmtCheckEventCb_p;
+	// save callback-function in modul global var
+	EplNmtCnuInstance_g.m_pfnCheckEventCb = pfnEplNmtCheckEventCb_p;
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -321,7 +318,6 @@ tEplKernel Ret;
 //                                                                         //
 //=========================================================================//
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtCnuCommandCb
@@ -341,273 +337,290 @@ tEplKernel Ret;
 //---------------------------------------------------------------------------
 static tEplKernel PUBLIC EplNmtCnuCommandCb(tEplFrameInfo * pFrameInfo_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplNmtCommand  NmtCommand;
-BOOL            fNodeIdInList;
-tEplNmtEvent    NmtEvent = kEplNmtEventNoEvent;
-
-
-    if(pFrameInfo_p == NULL)
-    {
-        Ret = kEplNmtInvalidFramePointer;
-        goto Exit;
-    }
-
-    NmtCommand = EplNmtCnuGetNmtCommand(pFrameInfo_p);
-
-    // check NMT-Command
-    switch(NmtCommand)
-    {
-
-        //------------------------------------------------------------------------
-        // plain NMT state commands
-        case kEplNmtCmdStartNode:
-        {   // send NMT-Event to state maschine kEplNmtEventStartNode
-            NmtEvent = kEplNmtEventStartNode;
-            break;
-        }
-
-        case kEplNmtCmdStopNode:
-        {   // send NMT-Event to state maschine kEplNmtEventStopNode
-            NmtEvent = kEplNmtEventStopNode;
-            break;
-        }
-
-        case kEplNmtCmdEnterPreOperational2:
-        {   // send NMT-Event to state maschine kEplNmtEventEnterPreOperational2
-            NmtEvent = kEplNmtEventEnterPreOperational2;
-            break;
-        }
-
-        case kEplNmtCmdEnableReadyToOperate:
-        {   // send NMT-Event to state maschine kEplNmtEventEnableReadyToOperate
-            NmtEvent = kEplNmtEventEnableReadyToOperate;
-            break;
-        }
-
-        case kEplNmtCmdResetNode:
-        {   // send NMT-Event to state maschine kEplNmtEventResetNode
-            NmtEvent = kEplNmtEventResetNode;
-            break;
-        }
-
-        case kEplNmtCmdResetCommunication:
-        {   // send NMT-Event to state maschine kEplNmtEventResetCom
-            NmtEvent = kEplNmtEventResetCom;
-            break;
-        }
-
-        case kEplNmtCmdResetConfiguration:
-        {   // send NMT-Event to state maschine kEplNmtEventResetConfig
-            NmtEvent = kEplNmtEventResetConfig;
-            break;
-        }
-
-        case kEplNmtCmdSwReset:
-        {   // send NMT-Event to state maschine kEplNmtEventSwReset
-            NmtEvent = kEplNmtEventSwReset;
-            break;
-        }
-
-        //------------------------------------------------------------------------
-        // extended NMT state commands
-
-        case kEplNmtCmdStartNodeEx:
-        {
-            // check if own nodeid is in EPL node list
-            fNodeIdInList = EplNmtCnuNodeIdList(&(pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_abNmtCommandData[0]));
-            if(fNodeIdInList != FALSE)
-            {   // own nodeid in list
-                // send event to process command
-                NmtEvent = kEplNmtEventStartNode;
-            }
-            break;
-        }
-
-        case kEplNmtCmdStopNodeEx:
-        {   // check if own nodeid is in EPL node list
-            fNodeIdInList = EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_abNmtCommandData[0]);
-            if(fNodeIdInList != FALSE)
-            {   // own nodeid in list
-                // send event to process command
-                NmtEvent = kEplNmtEventStopNode;
-            }
-            break;
-        }
-
-        case kEplNmtCmdEnterPreOperational2Ex:
-        {   // check if own nodeid is in EPL node list
-            fNodeIdInList = EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_abNmtCommandData[0]);
-            if(fNodeIdInList != FALSE)
-            {   // own nodeid in list
-                // send event to process command
-                NmtEvent = kEplNmtEventEnterPreOperational2;
-            }
-            break;
-        }
-
-        case kEplNmtCmdEnableReadyToOperateEx:
-        {   // check if own nodeid is in EPL node list
-            fNodeIdInList = EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_abNmtCommandData[0]);
-            if(fNodeIdInList != FALSE)
-            {   // own nodeid in list
-                // send event to process command
-                NmtEvent = kEplNmtEventEnableReadyToOperate;
-            }
-            break;
-        }
-
-        case kEplNmtCmdResetNodeEx:
-        {// check if own nodeid is in EPL node list
-            fNodeIdInList = EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_abNmtCommandData[0]);
-            if(fNodeIdInList != FALSE)
-            {   // own nodeid in list
-                // send event to process command
-                NmtEvent = kEplNmtEventResetNode;
-            }
-            break;
-        }
-
-        case kEplNmtCmdResetCommunicationEx:
-        {   // check if own nodeid is in EPL node list
-            fNodeIdInList = EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_abNmtCommandData[0]);
-            if(fNodeIdInList != FALSE)
-            {   // own nodeid in list
-                // send event to process command
-                NmtEvent = kEplNmtEventResetCom;
-            }
-            break;
-        }
-
-        case kEplNmtCmdResetConfigurationEx:
-        {   // check if own nodeid is in EPL node list
-            fNodeIdInList = EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_abNmtCommandData[0]);
-            if(fNodeIdInList != FALSE)
-            {   // own nodeid in list
-                // send event to process command
-                NmtEvent = kEplNmtEventResetConfig;
-            }
-            break;
-        }
-
-        case kEplNmtCmdSwResetEx:
-        {   // check if own nodeid is in EPL node list
-            fNodeIdInList = EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_abNmtCommandData[0]);
-            if(fNodeIdInList != FALSE)
-            {   // own nodeid in list
-                // send event to process command
-                NmtEvent = kEplNmtEventSwReset;
-            }
-            break;
-        }
-
-        //------------------------------------------------------------------------
-        // NMT managing commands
-
-        // TODO: add functions to process managing command (optional)
-
-        case kEplNmtCmdNetHostNameSet:
-        {
-            break;
-        }
-
-        case kEplNmtCmdFlushArpEntry:
-        {
-            break;
-        }
-
-        //------------------------------------------------------------------------
-        // NMT info services
-
-        // TODO: forward event with infos to the application (optional)
-
-        case kEplNmtCmdPublishConfiguredCN:
-        {
-            break;
-        }
-
-        case kEplNmtCmdPublishActiveCN:
-        {
-            break;
-        }
-
-        case kEplNmtCmdPublishPreOperational1:
-        {
-            break;
-        }
-
-        case kEplNmtCmdPublishPreOperational2:
-        {
-            break;
-        }
-
-        case kEplNmtCmdPublishReadyToOperate:
-        {
-            break;
-        }
-
-        case kEplNmtCmdPublishOperational:
-        {
-            break;
-        }
-
-        case kEplNmtCmdPublishStopped:
-        {
-            break;
-        }
-
-        case kEplNmtCmdPublishEmergencyNew:
-        {
-            break;
-        }
-
-        case kEplNmtCmdPublishTime:
-        {
-            break;
-        }
-
-        //-----------------------------------------------------------------------
-        // error from MN
-        // -> requested command not supported by MN
-        case kEplNmtCmdInvalidService:
-        {
-
-            // TODO: errorevent to application
-            break;
-        }
-
-        //------------------------------------------------------------------------
-        // default
-        default:
-        {
-            Ret = kEplNmtUnknownCommand;
-            goto Exit;
-        }
-
-    }// end of switch(NmtCommand)
-
-    if (NmtEvent != kEplNmtEventNoEvent)
-    {
-        if (EplNmtCnuInstance_g.m_pfnCheckEventCb != NULL)
-        {
-            Ret = EplNmtCnuInstance_g.m_pfnCheckEventCb(NmtEvent);
-            if (Ret == kEplReject)
-            {
-                Ret = kEplSuccessful;
-                goto Exit;
-            }
-            else if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-        }
+	tEplKernel Ret = kEplSuccessful;
+	tEplNmtCommand NmtCommand;
+	BOOL fNodeIdInList;
+	tEplNmtEvent NmtEvent = kEplNmtEventNoEvent;
+
+	if (pFrameInfo_p == NULL) {
+		Ret = kEplNmtInvalidFramePointer;
+		goto Exit;
+	}
+
+	NmtCommand = EplNmtCnuGetNmtCommand(pFrameInfo_p);
+
+	// check NMT-Command
+	switch (NmtCommand) {
+
+		//------------------------------------------------------------------------
+		// plain NMT state commands
+	case kEplNmtCmdStartNode:
+		{		// send NMT-Event to state maschine kEplNmtEventStartNode
+			NmtEvent = kEplNmtEventStartNode;
+			break;
+		}
+
+	case kEplNmtCmdStopNode:
+		{		// send NMT-Event to state maschine kEplNmtEventStopNode
+			NmtEvent = kEplNmtEventStopNode;
+			break;
+		}
+
+	case kEplNmtCmdEnterPreOperational2:
+		{		// send NMT-Event to state maschine kEplNmtEventEnterPreOperational2
+			NmtEvent = kEplNmtEventEnterPreOperational2;
+			break;
+		}
+
+	case kEplNmtCmdEnableReadyToOperate:
+		{		// send NMT-Event to state maschine kEplNmtEventEnableReadyToOperate
+			NmtEvent = kEplNmtEventEnableReadyToOperate;
+			break;
+		}
+
+	case kEplNmtCmdResetNode:
+		{		// send NMT-Event to state maschine kEplNmtEventResetNode
+			NmtEvent = kEplNmtEventResetNode;
+			break;
+		}
+
+	case kEplNmtCmdResetCommunication:
+		{		// send NMT-Event to state maschine kEplNmtEventResetCom
+			NmtEvent = kEplNmtEventResetCom;
+			break;
+		}
+
+	case kEplNmtCmdResetConfiguration:
+		{		// send NMT-Event to state maschine kEplNmtEventResetConfig
+			NmtEvent = kEplNmtEventResetConfig;
+			break;
+		}
+
+	case kEplNmtCmdSwReset:
+		{		// send NMT-Event to state maschine kEplNmtEventSwReset
+			NmtEvent = kEplNmtEventSwReset;
+			break;
+		}
+
+		//------------------------------------------------------------------------
+		// extended NMT state commands
+
+	case kEplNmtCmdStartNodeEx:
+		{
+			// check if own nodeid is in EPL node list
+			fNodeIdInList =
+			    EplNmtCnuNodeIdList(&
+						(pFrameInfo_p->m_pFrame->m_Data.
+						 m_Asnd.m_Payload.
+						 m_NmtCommandService.
+						 m_le_abNmtCommandData[0]));
+			if (fNodeIdInList != FALSE) {	// own nodeid in list
+				// send event to process command
+				NmtEvent = kEplNmtEventStartNode;
+			}
+			break;
+		}
+
+	case kEplNmtCmdStopNodeEx:
+		{		// check if own nodeid is in EPL node list
+			fNodeIdInList =
+			    EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.
+						m_Asnd.m_Payload.
+						m_NmtCommandService.
+						m_le_abNmtCommandData[0]);
+			if (fNodeIdInList != FALSE) {	// own nodeid in list
+				// send event to process command
+				NmtEvent = kEplNmtEventStopNode;
+			}
+			break;
+		}
+
+	case kEplNmtCmdEnterPreOperational2Ex:
+		{		// check if own nodeid is in EPL node list
+			fNodeIdInList =
+			    EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.
+						m_Asnd.m_Payload.
+						m_NmtCommandService.
+						m_le_abNmtCommandData[0]);
+			if (fNodeIdInList != FALSE) {	// own nodeid in list
+				// send event to process command
+				NmtEvent = kEplNmtEventEnterPreOperational2;
+			}
+			break;
+		}
+
+	case kEplNmtCmdEnableReadyToOperateEx:
+		{		// check if own nodeid is in EPL node list
+			fNodeIdInList =
+			    EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.
+						m_Asnd.m_Payload.
+						m_NmtCommandService.
+						m_le_abNmtCommandData[0]);
+			if (fNodeIdInList != FALSE) {	// own nodeid in list
+				// send event to process command
+				NmtEvent = kEplNmtEventEnableReadyToOperate;
+			}
+			break;
+		}
+
+	case kEplNmtCmdResetNodeEx:
+		{		// check if own nodeid is in EPL node list
+			fNodeIdInList =
+			    EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.
+						m_Asnd.m_Payload.
+						m_NmtCommandService.
+						m_le_abNmtCommandData[0]);
+			if (fNodeIdInList != FALSE) {	// own nodeid in list
+				// send event to process command
+				NmtEvent = kEplNmtEventResetNode;
+			}
+			break;
+		}
+
+	case kEplNmtCmdResetCommunicationEx:
+		{		// check if own nodeid is in EPL node list
+			fNodeIdInList =
+			    EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.
+						m_Asnd.m_Payload.
+						m_NmtCommandService.
+						m_le_abNmtCommandData[0]);
+			if (fNodeIdInList != FALSE) {	// own nodeid in list
+				// send event to process command
+				NmtEvent = kEplNmtEventResetCom;
+			}
+			break;
+		}
+
+	case kEplNmtCmdResetConfigurationEx:
+		{		// check if own nodeid is in EPL node list
+			fNodeIdInList =
+			    EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.
+						m_Asnd.m_Payload.
+						m_NmtCommandService.
+						m_le_abNmtCommandData[0]);
+			if (fNodeIdInList != FALSE) {	// own nodeid in list
+				// send event to process command
+				NmtEvent = kEplNmtEventResetConfig;
+			}
+			break;
+		}
+
+	case kEplNmtCmdSwResetEx:
+		{		// check if own nodeid is in EPL node list
+			fNodeIdInList =
+			    EplNmtCnuNodeIdList(&pFrameInfo_p->m_pFrame->m_Data.
+						m_Asnd.m_Payload.
+						m_NmtCommandService.
+						m_le_abNmtCommandData[0]);
+			if (fNodeIdInList != FALSE) {	// own nodeid in list
+				// send event to process command
+				NmtEvent = kEplNmtEventSwReset;
+			}
+			break;
+		}
+
+		//------------------------------------------------------------------------
+		// NMT managing commands
+
+		// TODO: add functions to process managing command (optional)
+
+	case kEplNmtCmdNetHostNameSet:
+		{
+			break;
+		}
+
+	case kEplNmtCmdFlushArpEntry:
+		{
+			break;
+		}
+
+		//------------------------------------------------------------------------
+		// NMT info services
+
+		// TODO: forward event with infos to the application (optional)
+
+	case kEplNmtCmdPublishConfiguredCN:
+		{
+			break;
+		}
+
+	case kEplNmtCmdPublishActiveCN:
+		{
+			break;
+		}
+
+	case kEplNmtCmdPublishPreOperational1:
+		{
+			break;
+		}
+
+	case kEplNmtCmdPublishPreOperational2:
+		{
+			break;
+		}
+
+	case kEplNmtCmdPublishReadyToOperate:
+		{
+			break;
+		}
+
+	case kEplNmtCmdPublishOperational:
+		{
+			break;
+		}
+
+	case kEplNmtCmdPublishStopped:
+		{
+			break;
+		}
+
+	case kEplNmtCmdPublishEmergencyNew:
+		{
+			break;
+		}
+
+	case kEplNmtCmdPublishTime:
+		{
+			break;
+		}
+
+		//-----------------------------------------------------------------------
+		// error from MN
+		// -> requested command not supported by MN
+	case kEplNmtCmdInvalidService:
+		{
+
+			// TODO: errorevent to application
+			break;
+		}
+
+		//------------------------------------------------------------------------
+		// default
+	default:
+		{
+			Ret = kEplNmtUnknownCommand;
+			goto Exit;
+		}
+
+	}			// end of switch(NmtCommand)
+
+	if (NmtEvent != kEplNmtEventNoEvent) {
+		if (EplNmtCnuInstance_g.m_pfnCheckEventCb != NULL) {
+			Ret = EplNmtCnuInstance_g.m_pfnCheckEventCb(NmtEvent);
+			if (Ret == kEplReject) {
+				Ret = kEplSuccessful;
+				goto Exit;
+			} else if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+		}
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTU)) != 0)
-        Ret = EplNmtuNmtEvent(NmtEvent);
+		Ret = EplNmtuNmtEvent(NmtEvent);
 #endif
-    }
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
@@ -631,14 +644,18 @@ Exit:
 //---------------------------------------------------------------------------
 static tEplNmtCommand EplNmtCnuGetNmtCommand(tEplFrameInfo * pFrameInfo_p)
 {
-tEplNmtCommand          NmtCommand;
-tEplNmtCommandService*  pNmtCommandService;
-
-    pNmtCommandService = &pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService;
+	tEplNmtCommand NmtCommand;
+	tEplNmtCommandService *pNmtCommandService;
 
-    NmtCommand = (tEplNmtCommand)AmiGetByteFromLe(&pNmtCommandService->m_le_bNmtCommandId);
+	pNmtCommandService =
+	    &pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.
+	    m_NmtCommandService;
+
+	NmtCommand =
+	    (tEplNmtCommand) AmiGetByteFromLe(&pNmtCommandService->
+					      m_le_bNmtCommandId);
 
-    return NmtCommand;
+	return NmtCommand;
 }
 
 //---------------------------------------------------------------------------
@@ -659,33 +676,29 @@ tEplNmtCommandService*  pNmtCommandServi
 // State:
 //
 //---------------------------------------------------------------------------
-static BOOL EplNmtCnuNodeIdList(BYTE* pbNmtCommandDate_p)
+static BOOL EplNmtCnuNodeIdList(BYTE * pbNmtCommandDate_p)
 {
-BOOL            fNodeIdInList;
-unsigned int    uiByteOffset;
-BYTE            bBitOffset;
-BYTE            bNodeListByte;
-
-    // get byte-offset of the own nodeid in NodeIdList
-    // devide though 8
-    uiByteOffset = (unsigned int)(EplNmtCnuInstance_g.m_uiNodeId >> 3);
-    // get bitoffset
-    bBitOffset = (BYTE) EplNmtCnuInstance_g.m_uiNodeId % 8;
-
-    bNodeListByte = AmiGetByteFromLe(&pbNmtCommandDate_p[uiByteOffset]);
-    if((bNodeListByte & bBitOffset) == 0)
-    {
-        fNodeIdInList = FALSE;
-    }
-    else
-    {
-        fNodeIdInList = TRUE;
-    }
+	BOOL fNodeIdInList;
+	unsigned int uiByteOffset;
+	BYTE bBitOffset;
+	BYTE bNodeListByte;
+
+	// get byte-offset of the own nodeid in NodeIdList
+	// devide though 8
+	uiByteOffset = (unsigned int)(EplNmtCnuInstance_g.m_uiNodeId >> 3);
+	// get bitoffset
+	bBitOffset = (BYTE) EplNmtCnuInstance_g.m_uiNodeId % 8;
+
+	bNodeListByte = AmiGetByteFromLe(&pbNmtCommandDate_p[uiByteOffset]);
+	if ((bNodeListByte & bBitOffset) == 0) {
+		fNodeIdInList = FALSE;
+	} else {
+		fNodeIdInList = TRUE;
+	}
 
-return  fNodeIdInList;
+	return fNodeIdInList;
 }
 
 #endif // #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_CN)) != 0)
 
 // EOF
-
--- a/drivers/staging/epl/EplNmtk.c
+++ b/drivers/staging/epl/EplNmtk.c
@@ -71,7 +71,7 @@
 #include "kernel/EplNmtk.h"
 #include "kernel/EplTimerk.h"
 
-#include "kernel/EplDllk.h"     // for EplDllkProcess()
+#include "kernel/EplDllk.h"	// for EplDllkProcess()
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTK)) != 0)
 /***************************************************************************/
@@ -88,34 +88,31 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-    void  PUBLIC  TgtDbgSignalTracePoint (BYTE bTracePointNumber_p);
-    void  PUBLIC  TgtDbgPostTraceValue (DWORD dwTraceValue_p);
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void PUBLIC TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)
 #endif
 #define EPL_NMTK_DBG_POST_TRACE_VALUE(NmtEvent_p, OldNmtState_p, NewNmtState_p) \
     TGT_DBG_POST_TRACE_VALUE((kEplEventSinkNmtk << 28) | (NmtEvent_p << 16) \
                              | ((OldNmtState_p & 0xFF) << 8) \
                              | (NewNmtState_p & 0xFF))
 
-
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 // struct for instance table
-INSTANCE_TYPE_BEGIN
-
-    EPL_MCO_DECL_INSTANCE_MEMBER ()
+INSTANCE_TYPE_BEGIN EPL_MCO_DECL_INSTANCE_MEMBER()
 
-    STATIC  volatile    tEplNmtState    INST_FAR    m_NmtState;
-    STATIC  volatile    BOOL            INST_FAR    m_fEnableReadyToOperate;
-    STATIC  volatile    BOOL            INST_FAR    m_fAppReadyToOperate;
-    STATIC  volatile    BOOL            INST_FAR    m_fTimerMsPreOp2;
-    STATIC  volatile    BOOL            INST_FAR    m_fAllMandatoryCNIdent;
-    STATIC  volatile    BOOL            INST_FAR    m_fFrozen;
+STATIC volatile tEplNmtState INST_FAR m_NmtState;
+STATIC volatile BOOL INST_FAR m_fEnableReadyToOperate;
+STATIC volatile BOOL INST_FAR m_fAppReadyToOperate;
+STATIC volatile BOOL INST_FAR m_fTimerMsPreOp2;
+STATIC volatile BOOL INST_FAR m_fAllMandatoryCNIdent;
+STATIC volatile BOOL INST_FAR m_fFrozen;
 
 INSTANCE_TYPE_END
 //---------------------------------------------------------------------------
@@ -125,14 +122,11 @@ INSTANCE_TYPE_END
 // the modul specific type for the local instance table. This macro
 // must defined in each modul.
 //#define tEplPtrInstance             tEplInstanceInfo MEM*
-
-EPL_MCO_DECL_INSTANCE_VAR ()
-
+EPL_MCO_DECL_INSTANCE_VAR()
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
-EPL_MCO_DEFINE_INSTANCE_FCT ()
-
+EPL_MCO_DEFINE_INSTANCE_FCT()
 
 /***************************************************************************/
 /*                                                                         */
@@ -171,14 +165,13 @@ EPL_MCO_DEFINE_INSTANCE_FCT ()
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtkInit(EPL_MCO_DECL_PTR_INSTANCE_PTR)
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = EplNmtkAddInstance (EPL_MCO_PTR_INSTANCE_PTR);
+	Ret = EplNmtkAddInstance(EPL_MCO_PTR_INSTANCE_PTR);
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:        EplNmtkAddInstance
@@ -198,45 +191,43 @@ tEplKernel Ret;
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtkAddInstance(EPL_MCO_DECL_PTR_INSTANCE_PTR)
 {
-EPL_MCO_DECL_INSTANCE_PTR_LOCAL
-tEplKernel              Ret;
+	EPL_MCO_DECL_INSTANCE_PTR_LOCAL tEplKernel Ret;
 //tEplEvent               Event;
 //tEplEventNmtStateChange NmtStateChange;
 
-     // check if pointer to instance pointer valid
-    // get free instance and set the globale instance pointer
-    // set also the instance addr to parameterlist
-    EPL_MCO_CHECK_PTR_INSTANCE_PTR ();
-    EPL_MCO_GET_FREE_INSTANCE_PTR ();
-    EPL_MCO_SET_PTR_INSTANCE_PTR ();
-
-    // sign instance as used
-    EPL_MCO_WRITE_INSTANCE_STATE (kStateUsed);
-
-
-    Ret = kEplSuccessful;
-
-    // initialize intern vaiables
-    // 2006/07/31 d.k.: set NMT-State to kEplNmtGsOff
-    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-    // set NMT-State to kEplNmtGsInitialising
-    //EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-
-    // set flags to FALSE
-    EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) = FALSE;
-    EPL_MCO_GLB_VAR(m_fAppReadyToOperate) = FALSE;
-    EPL_MCO_GLB_VAR(m_fTimerMsPreOp2) = FALSE;
-    EPL_MCO_GLB_VAR(m_fAllMandatoryCNIdent) = FALSE;
-    EPL_MCO_GLB_VAR(m_fFrozen) = FALSE;
+	// check if pointer to instance pointer valid
+	// get free instance and set the globale instance pointer
+	// set also the instance addr to parameterlist
+	EPL_MCO_CHECK_PTR_INSTANCE_PTR();
+	EPL_MCO_GET_FREE_INSTANCE_PTR();
+	EPL_MCO_SET_PTR_INSTANCE_PTR();
+
+	// sign instance as used
+	EPL_MCO_WRITE_INSTANCE_STATE(kStateUsed);
+
+	Ret = kEplSuccessful;
+
+	// initialize intern vaiables
+	// 2006/07/31 d.k.: set NMT-State to kEplNmtGsOff
+	EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
+	// set NMT-State to kEplNmtGsInitialising
+	//EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
+
+	// set flags to FALSE
+	EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) = FALSE;
+	EPL_MCO_GLB_VAR(m_fAppReadyToOperate) = FALSE;
+	EPL_MCO_GLB_VAR(m_fTimerMsPreOp2) = FALSE;
+	EPL_MCO_GLB_VAR(m_fAllMandatoryCNIdent) = FALSE;
+	EPL_MCO_GLB_VAR(m_fFrozen) = FALSE;
 
 //    EPL_MCO_GLB_VAR(m_TimerHdl) = 0;
 
-    // inform higher layer about state change
-    // 2006/07/31 d.k.: The EPL API layer/application has to start NMT state
-    //                  machine via NmtEventSwReset after initialisation of
-    //                  all modules has been completed. DLL has to be initialised
-    //                  after NMTk because NMT state shall not be uninitialised
-    //                  at that time.
+	// inform higher layer about state change
+	// 2006/07/31 d.k.: The EPL API layer/application has to start NMT state
+	//                  machine via NmtEventSwReset after initialisation of
+	//                  all modules has been completed. DLL has to be initialised
+	//                  after NMTk because NMT state shall not be uninitialised
+	//                  at that time.
 /*    NmtStateChange.m_NewNmtState = EPL_MCO_GLB_VAR(m_NmtState);
     NmtStateChange.m_NmtEvent = kEplNmtEventNoEvent;
     Event.m_EventSink = kEplEventSinkNmtu;
@@ -246,10 +237,9 @@ tEplKernel              Ret;
     Event.m_uiSize = sizeof(NmtStateChange);
     Ret = EplEventkPost(&Event);
 */
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:        EplNmtkDelInstance
@@ -270,24 +260,23 @@ tEplKernel              Ret;
 #if (EPL_USE_DELETEINST_FUNC != FALSE)
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtkDelInstance(EPL_MCO_DECL_PTR_INSTANCE_PTR)
 {
-tEplKernel              Ret = kEplSuccessful;
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
+	tEplKernel Ret = kEplSuccessful;
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
 
-    // set NMT-State to kEplNmtGsOff
-    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
+	// set NMT-State to kEplNmtGsOff
+	EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
 
-    // sign instance as unused
-    EPL_MCO_WRITE_INSTANCE_STATE (kStateUnused);
+	// sign instance as unused
+	EPL_MCO_WRITE_INSTANCE_STATE(kStateUnused);
 
-    // delete timer
+	// delete timer
 //    Ret = EplTimerkDeleteTimer(&EPL_MCO_GLB_VAR(m_TimerHdl));
 
-    return Ret;
+	return Ret;
 }
 #endif // (EPL_USE_DELETEINST_FUNC != FALSE)
 
-
 //---------------------------------------------------------------------------
 //
 // Function:        EplNmtkProcess
@@ -308,1387 +297,1493 @@ tEplKernel              Ret = kEplSucces
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtkProcess(EPL_MCO_DECL_PTR_INSTANCE_PTR_
-                                              tEplEvent* pEvent_p)
+					      tEplEvent * pEvent_p)
 {
-tEplKernel              Ret;
-tEplNmtState            OldNmtState;
-tEplNmtEvent            NmtEvent;
-tEplEvent               Event;
-tEplEventNmtStateChange NmtStateChange;
-
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
-
-    Ret = kEplSuccessful;
-
-    switch(pEvent_p->m_EventType)
-    {
-        case kEplEventTypeNmtEvent:
-        {
-            NmtEvent = *((tEplNmtEvent*)pEvent_p->m_pArg);
-            break;
-        }
-
-        case kEplEventTypeTimer:
-        {
-            NmtEvent = (tEplNmtEvent)((tEplTimerEventArg*)pEvent_p->m_pArg)->m_ulArg;
-            break;
-        }
-        default:
-        {
-            Ret = kEplNmtInvalidEvent;
-            goto Exit;
-        }
-    }
-
-    // save NMT-State
-    // needed for later comparison to
-    // inform hgher layer about state change
-    OldNmtState = EPL_MCO_GLB_VAR(m_NmtState);
-
-    // NMT-State-Maschine
-    switch(EPL_MCO_GLB_VAR(m_NmtState))
-    {
-        //-----------------------------------------------------------
-        // general part of the statemaschine
-
-        // first init of the hardware
-        case kEplNmtGsOff:
-        {
-            // leave this state only if higher layer says so
-            if(NmtEvent == kEplNmtEventSwReset)
-            {   // new state kEplNmtGsInitialising
-                EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-            }
-            break;
-        }
-
-        // first init of the hardware
-        case kEplNmtGsInitialising:
-        {
-            // leave this state only if higher layer says so
-
-            // check events
-            switch(NmtEvent)
-            {
-                // 2006/07/31 d.k.: react also on NMT reset commands in ResetApp state
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // new state kEplNmtGsResetApplication
-                case kEplNmtEventEnterResetApp:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-            }
-            break;
-        }
-
-        // init of the manufacturer-specific profile area and the
-        // standardised device profile area
-        case kEplNmtGsResetApplication:
-        {
-            // check events
-            switch(NmtEvent)
-            {
-                // 2006/07/31 d.k.: react also on NMT reset commands in ResetApp state
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // leave this state only if higher layer
-                // say so
-                case kEplNmtEventEnterResetCom:
-                {
-                    // new state kEplNmtGsResetCommunication
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-            }
-            break;
-        }
-
-        // init of the communication profile area
-        case kEplNmtGsResetCommunication:
-        {
-            // check events
-            switch(NmtEvent)
-            {
-                // 2006/07/31 d.k.: react also on NMT reset commands in ResetComm state
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // leave this state only if higher layer
-                // say so
-                case kEplNmtEventEnterResetConfig:
-                {
-                    // new state kEplNmtGsResetCommunication
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-            }
-            break;
-        }
-
-        // build the configuration with infos from OD
-        case kEplNmtGsResetConfiguration:
-        {
-            // reset flags
-            EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) = FALSE;
-            EPL_MCO_GLB_VAR(m_fAppReadyToOperate) = FALSE;
-            EPL_MCO_GLB_VAR(m_fFrozen) = FALSE;
-
-            // check events
-            switch(NmtEvent)
-            {
-                // 2006/07/31 d.k.: react also on NMT reset commands in ResetConf state
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                case kEplNmtEventResetCom:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // leave this state only if higher layer says so
-                case kEplNmtEventEnterCsNotActive:
-                {   // Node should be CN
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsNotActive;
-                    break;
-
-                }
-
-                case kEplNmtEventEnterMsNotActive:
-                {   // Node should be CN
-                    #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) == 0)
-                        // no MN functionality
-                        // TODO: -create error E_NMT_BA1_NO_MN_SUPPORT
-                        EPL_MCO_GLB_VAR(m_fFrozen) = TRUE;
-                    #else
+	tEplKernel Ret;
+	tEplNmtState OldNmtState;
+	tEplNmtEvent NmtEvent;
+	tEplEvent Event;
+	tEplEventNmtStateChange NmtStateChange;
+
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
+
+	Ret = kEplSuccessful;
+
+	switch (pEvent_p->m_EventType) {
+	case kEplEventTypeNmtEvent:
+		{
+			NmtEvent = *((tEplNmtEvent *) pEvent_p->m_pArg);
+			break;
+		}
+
+	case kEplEventTypeTimer:
+		{
+			NmtEvent =
+			    (tEplNmtEvent) ((tEplTimerEventArg *) pEvent_p->
+					    m_pArg)->m_ulArg;
+			break;
+		}
+	default:
+		{
+			Ret = kEplNmtInvalidEvent;
+			goto Exit;
+		}
+	}
+
+	// save NMT-State
+	// needed for later comparison to
+	// inform hgher layer about state change
+	OldNmtState = EPL_MCO_GLB_VAR(m_NmtState);
+
+	// NMT-State-Maschine
+	switch (EPL_MCO_GLB_VAR(m_NmtState)) {
+		//-----------------------------------------------------------
+		// general part of the statemaschine
+
+		// first init of the hardware
+	case kEplNmtGsOff:
+		{
+			// leave this state only if higher layer says so
+			if (NmtEvent == kEplNmtEventSwReset) {	// new state kEplNmtGsInitialising
+				EPL_MCO_GLB_VAR(m_NmtState) =
+				    kEplNmtGsInitialising;
+			}
+			break;
+		}
+
+		// first init of the hardware
+	case kEplNmtGsInitialising:
+		{
+			// leave this state only if higher layer says so
+
+			// check events
+			switch (NmtEvent) {
+				// 2006/07/31 d.k.: react also on NMT reset commands in ResetApp state
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// new state kEplNmtGsResetApplication
+			case kEplNmtEventEnterResetApp:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+			}
+			break;
+		}
+
+		// init of the manufacturer-specific profile area and the
+		// standardised device profile area
+	case kEplNmtGsResetApplication:
+		{
+			// check events
+			switch (NmtEvent) {
+				// 2006/07/31 d.k.: react also on NMT reset commands in ResetApp state
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// leave this state only if higher layer
+				// say so
+			case kEplNmtEventEnterResetCom:
+				{
+					// new state kEplNmtGsResetCommunication
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+			}
+			break;
+		}
+
+		// init of the communication profile area
+	case kEplNmtGsResetCommunication:
+		{
+			// check events
+			switch (NmtEvent) {
+				// 2006/07/31 d.k.: react also on NMT reset commands in ResetComm state
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// leave this state only if higher layer
+				// say so
+			case kEplNmtEventEnterResetConfig:
+				{
+					// new state kEplNmtGsResetCommunication
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+			}
+			break;
+		}
+
+		// build the configuration with infos from OD
+	case kEplNmtGsResetConfiguration:
+		{
+			// reset flags
+			EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) = FALSE;
+			EPL_MCO_GLB_VAR(m_fAppReadyToOperate) = FALSE;
+			EPL_MCO_GLB_VAR(m_fFrozen) = FALSE;
+
+			// check events
+			switch (NmtEvent) {
+				// 2006/07/31 d.k.: react also on NMT reset commands in ResetConf state
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+			case kEplNmtEventResetCom:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// leave this state only if higher layer says so
+			case kEplNmtEventEnterCsNotActive:
+				{	// Node should be CN
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsNotActive;
+					break;
+
+				}
+
+			case kEplNmtEventEnterMsNotActive:
+				{	// Node should be CN
+#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) == 0)
+					// no MN functionality
+					// TODO: -create error E_NMT_BA1_NO_MN_SUPPORT
+					EPL_MCO_GLB_VAR(m_fFrozen) = TRUE;
+#else
 
-                        EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtMsNotActive;
-                    #endif
-                    break;
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtMsNotActive;
+#endif
+					break;
 
-                }
+				}
 
-                default:
-                {
-                    break;
-                }
-            }
-            break;
-        }
-
-        //-----------------------------------------------------------
-        // CN part of the statemaschine
-
-        // node liste for EPL-Frames and check timeout
-        case kEplNmtCsNotActive:
-        {
-
-            // check events
-            switch(NmtEvent)
-            {
-                // 2006/07/31 d.k.: react also on NMT reset commands in NotActive state
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
+			default:
+				{
+					break;
+				}
+			}
+			break;
+		}
+
+		//-----------------------------------------------------------
+		// CN part of the statemaschine
+
+		// node liste for EPL-Frames and check timeout
+	case kEplNmtCsNotActive:
+		{
+
+			// check events
+			switch (NmtEvent) {
+				// 2006/07/31 d.k.: react also on NMT reset commands in NotActive state
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
 //                    Ret = EplTimerkDeleteTimer(&EPL_MCO_GLB_VAR(m_TimerHdl));
-                    break;
-                }
+					break;
+				}
 
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
 //                    Ret = EplTimerkDeleteTimer(&EPL_MCO_GLB_VAR(m_TimerHdl));
-                    break;
-                }
+					break;
+				}
 
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
 //                    Ret = EplTimerkDeleteTimer(&EPL_MCO_GLB_VAR(m_TimerHdl));
-                    break;
-                }
+					break;
+				}
 
-                // NMT Command Reset Configuration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
+				// NMT Command Reset Configuration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
 //                    Ret = EplTimerkDeleteTimer(&EPL_MCO_GLB_VAR(m_TimerHdl));
-                    break;
-                }
+					break;
+				}
 
-                // see if SoA or SoC received
-                // k.t. 20.07.2006: only SoA forces change of state
-                // see EPL V2 DS 1.0.0 p.267
-                // case kEplNmtEventDllCeSoc:
-                case kEplNmtEventDllCeSoa:
-                {   // new state PRE_OPERATIONAL1
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational1;
+				// see if SoA or SoC received
+				// k.t. 20.07.2006: only SoA forces change of state
+				// see EPL V2 DS 1.0.0 p.267
+				// case kEplNmtEventDllCeSoc:
+			case kEplNmtEventDllCeSoa:
+				{	// new state PRE_OPERATIONAL1
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsPreOperational1;
 //                    Ret = EplTimerkDeleteTimer(&EPL_MCO_GLB_VAR(m_TimerHdl));
-                    break;
-                }
-                // timeout for SoA and Soc
-                case kEplNmtEventTimerBasicEthernet:
-                {
-                    // new state BASIC_ETHERNET
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsBasicEthernet;
-                    break;
-                }
+					break;
+				}
+				// timeout for SoA and Soc
+			case kEplNmtEventTimerBasicEthernet:
+				{
+					// new state BASIC_ETHERNET
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsBasicEthernet;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+			}	// end of switch(NmtEvent)
+
+			break;
+		}
+
+		// node processes only async frames
+	case kEplNmtCsPreOperational1:
+		{
+
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command Reset Configuration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// NMT Command StopNode
+			case kEplNmtEventStopNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsStopped;
+					break;
+				}
+
+				// check if SoC received
+			case kEplNmtEventDllCeSoc:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsPreOperational2;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+
+			break;
+		}
+
+		// node processes isochronous and asynchronous frames
+	case kEplNmtCsPreOperational2:
+		{
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command Reset Configuration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// NMT Command StopNode
+			case kEplNmtEventStopNode:
+				{
+					// reset flags
+					EPL_MCO_GLB_VAR(m_fEnableReadyToOperate)
+					    = FALSE;
+					EPL_MCO_GLB_VAR(m_fAppReadyToOperate) =
+					    FALSE;
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsStopped;
+					break;
+				}
+
+				// error occured
+			case kEplNmtEventNmtCycleError:
+				{
+					// reset flags
+					EPL_MCO_GLB_VAR(m_fEnableReadyToOperate)
+					    = FALSE;
+					EPL_MCO_GLB_VAR(m_fAppReadyToOperate) =
+					    FALSE;
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsPreOperational1;
+					break;
+				}
+
+				// check if application is ready to operate
+			case kEplNmtEventEnterReadyToOperate:
+				{
+					// check if command NMTEnableReadyToOperate from MN was received
+					if (EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) == TRUE) {	// reset flags
+						EPL_MCO_GLB_VAR
+						    (m_fEnableReadyToOperate) =
+						    FALSE;
+						EPL_MCO_GLB_VAR
+						    (m_fAppReadyToOperate) =
+						    FALSE;
+						// change state
+						EPL_MCO_GLB_VAR(m_NmtState) =
+						    kEplNmtCsReadyToOperate;
+					} else {	// set Flag
+						EPL_MCO_GLB_VAR
+						    (m_fAppReadyToOperate) =
+						    TRUE;
+					}
+					break;
+				}
+
+				// NMT Commando EnableReadyToOperate
+			case kEplNmtEventEnableReadyToOperate:
+				{
+					// check if application is ready
+					if (EPL_MCO_GLB_VAR(m_fAppReadyToOperate) == TRUE) {	// reset flags
+						EPL_MCO_GLB_VAR
+						    (m_fEnableReadyToOperate) =
+						    FALSE;
+						EPL_MCO_GLB_VAR
+						    (m_fAppReadyToOperate) =
+						    FALSE;
+						// change state
+						EPL_MCO_GLB_VAR(m_NmtState) =
+						    kEplNmtCsReadyToOperate;
+					} else {	// set Flag
+						EPL_MCO_GLB_VAR
+						    (m_fEnableReadyToOperate) =
+						    TRUE;
+					}
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+			break;
+		}
+
+		// node should be configured und application is ready
+	case kEplNmtCsReadyToOperate:
+		{
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command ResetConfiguration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// NMT Command StopNode
+			case kEplNmtEventStopNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsStopped;
+					break;
+				}
+
+				// error occured
+			case kEplNmtEventNmtCycleError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsPreOperational1;
+					break;
+				}
+
+				// NMT Command StartNode
+			case kEplNmtEventStartNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsOperational;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+			break;
+		}
+
+		// normal work state
+	case kEplNmtCsOperational:
+		{
+
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command ResetConfiguration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// NMT Command StopNode
+			case kEplNmtEventStopNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsStopped;
+					break;
+				}
+
+				// NMT Command EnterPreOperational2
+			case kEplNmtEventEnterPreOperational2:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsPreOperational2;
+					break;
+				}
+
+				// error occured
+			case kEplNmtEventNmtCycleError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsPreOperational1;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+			break;
+		}
+
+		// node stopped by MN
+		// -> only process asynchronous frames
+	case kEplNmtCsStopped:
+		{
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command ResetConfiguration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// NMT Command EnterPreOperational2
+			case kEplNmtEventEnterPreOperational2:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsPreOperational2;
+					break;
+				}
+
+				// error occured
+			case kEplNmtEventNmtCycleError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsPreOperational1;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+			break;
+		}
+
+		// no epl cycle
+		// -> normal ethernet communication
+	case kEplNmtCsBasicEthernet:
+		{
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command ResetConfiguration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
 
-                default:
-                {
-                    break;
-                }
-            }// end of switch(NmtEvent)
-
-            break;
-        }
-
-        // node processes only async frames
-        case kEplNmtCsPreOperational1:
-        {
-
-            // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // NMT Command Reset Configuration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // NMT Command StopNode
-                case kEplNmtEventStopNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsStopped;
-                    break;
-                }
-
-                // check if SoC received
-                case kEplNmtEventDllCeSoc:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational2;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-
-            break;
-        }
-
-        // node processes isochronous and asynchronous frames
-        case kEplNmtCsPreOperational2:
-        {
-            // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // NMT Command Reset Configuration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // NMT Command StopNode
-                case kEplNmtEventStopNode:
-                {
-                    // reset flags
-                    EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) = FALSE;
-                    EPL_MCO_GLB_VAR(m_fAppReadyToOperate) = FALSE;
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsStopped;
-                    break;
-                }
-
-                // error occured
-                case kEplNmtEventNmtCycleError:
-                {
-                    // reset flags
-                    EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) = FALSE;
-                    EPL_MCO_GLB_VAR(m_fAppReadyToOperate) = FALSE;
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational1;
-                    break;
-                }
-
-                // check if application is ready to operate
-                case kEplNmtEventEnterReadyToOperate:
-                {
-                    // check if command NMTEnableReadyToOperate from MN was received
-                    if(EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) == TRUE)
-                    {   // reset flags
-                        EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) = FALSE;
-                        EPL_MCO_GLB_VAR(m_fAppReadyToOperate) = FALSE;
-                        // change state
-                        EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsReadyToOperate;
-                    }
-                    else
-                    {   // set Flag
-                        EPL_MCO_GLB_VAR(m_fAppReadyToOperate) = TRUE;
-                    }
-                    break;
-                }
-
-                // NMT Commando EnableReadyToOperate
-                case kEplNmtEventEnableReadyToOperate:
-                {
-                    // check if application is ready
-                    if(EPL_MCO_GLB_VAR(m_fAppReadyToOperate) == TRUE)
-                    {   // reset flags
-                        EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) = FALSE;
-                        EPL_MCO_GLB_VAR(m_fAppReadyToOperate) = FALSE;
-                        // change state
-                        EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsReadyToOperate;
-                    }
-                    else
-                    {   // set Flag
-                        EPL_MCO_GLB_VAR(m_fEnableReadyToOperate) = TRUE;
-                    }
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-            break;
-        }
-
-        // node should be configured und application is ready
-        case kEplNmtCsReadyToOperate:
-        {
-             // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // NMT Command ResetConfiguration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // NMT Command StopNode
-                case kEplNmtEventStopNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsStopped;
-                    break;
-                }
-
-                // error occured
-                case kEplNmtEventNmtCycleError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational1;
-                    break;
-                }
-
-                // NMT Command StartNode
-                case kEplNmtEventStartNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsOperational;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-            break;
-        }
-
-        // normal work state
-        case kEplNmtCsOperational:
-        {
-
-             // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // NMT Command ResetConfiguration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // NMT Command StopNode
-                case kEplNmtEventStopNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsStopped;
-                    break;
-                }
-
-                // NMT Command EnterPreOperational2
-                case kEplNmtEventEnterPreOperational2:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational2;
-                    break;
-                }
-
-                // error occured
-                case kEplNmtEventNmtCycleError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational1;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-            break;
-        }
-
-        // node stopped by MN
-        // -> only process asynchronous frames
-        case kEplNmtCsStopped:
-        {
-            // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // NMT Command ResetConfiguration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // NMT Command EnterPreOperational2
-                case kEplNmtEventEnterPreOperational2:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational2;
-                    break;
-                }
-
-                // error occured
-                case kEplNmtEventNmtCycleError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational1;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-            break;
-        }
-
-        // no epl cycle
-        // -> normal ethernet communication
-        case kEplNmtCsBasicEthernet:
-        {
-            // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // NMT Command ResetConfiguration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // error occured
-                // d.k.: how does this error occur? on CRC errors
+				// error occured
+				// d.k.: how does this error occur? on CRC errors
 /*                case kEplNmtEventNmtCycleError:
                 {
                     EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational1;
                     break;
                 }
 */
-                case kEplNmtEventDllCeSoc:
-                case kEplNmtEventDllCePreq:
-                case kEplNmtEventDllCePres:
-                case kEplNmtEventDllCeSoa:
-                {   // Epl-Frame on net -> stop any communication
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational1;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-
-            break;
-        }
-
-        //-----------------------------------------------------------
-        // MN part of the statemaschine
-
-        // MN listen to network
-        // -> if no EPL traffic go to next state
-        case kEplNmtMsNotActive:
-        {
-            #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) == 0)
-                // no MN functionality
-                // TODO: -create error E_NMT_BA1_NO_MN_SUPPORT
-                EPL_MCO_GLB_VAR(m_fFrozen) = TRUE;
-            #else
+			case kEplNmtEventDllCeSoc:
+			case kEplNmtEventDllCePreq:
+			case kEplNmtEventDllCePres:
+			case kEplNmtEventDllCeSoa:
+				{	// Epl-Frame on net -> stop any communication
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtCsPreOperational1;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+
+			break;
+		}
+
+		//-----------------------------------------------------------
+		// MN part of the statemaschine
+
+		// MN listen to network
+		// -> if no EPL traffic go to next state
+	case kEplNmtMsNotActive:
+		{
+#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) == 0)
+			// no MN functionality
+			// TODO: -create error E_NMT_BA1_NO_MN_SUPPORT
+			EPL_MCO_GLB_VAR(m_fFrozen) = TRUE;
+#else
 
-                // check events
-                switch(NmtEvent)
-                {
-                    // NMT Command SwitchOff
-                    case kEplNmtEventCriticalError:
-                    case kEplNmtEventSwitchOff:
-                    {
-                        EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                        break;
-                    }
-
-                    // NMT Command SwReset
-                    case kEplNmtEventSwReset:
-                    {
-                        EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                        break;
-                    }
-
-                    // NMT Command ResetNode
-                    case kEplNmtEventResetNode:
-                    {
-                        EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                        break;
-                    }
-
-                    // NMT Command ResetCommunication
-                    // or internal Communication error
-                    case kEplNmtEventResetCom:
-                    case kEplNmtEventInternComError:
-                    {
-                        EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                        break;
-                    }
-
-                    // NMT Command ResetConfiguration
-                    case kEplNmtEventResetConfig:
-                    {
-                        EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                        break;
-                    }
-
-                    // EPL frames received
-                    case kEplNmtEventDllCeSoc:
-                    case kEplNmtEventDllCeSoa:
-                    {   // other MN in network
-                        // $$$ d.k.: generate error history entry
-                        EPL_MCO_GLB_VAR(m_fFrozen) = TRUE;
-                        break;
-                    }
-
-                    // timeout event
-                    case kEplNmtEventTimerBasicEthernet:
-                    {
-                        if (EPL_MCO_GLB_VAR(m_fFrozen) == FALSE)
-                        {   // new state BasicEthernet
-                            EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtMsBasicEthernet;
-                        }
-                        break;
-                    }
-
-                    // timeout event
-                    case kEplNmtEventTimerMsPreOp1:
-                    {
-                        if (EPL_MCO_GLB_VAR(m_fFrozen) == FALSE)
-                        {   // new state PreOp1
-                            EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtMsPreOperational1;
-                            EPL_MCO_GLB_VAR(m_fTimerMsPreOp2) = FALSE;
-                            EPL_MCO_GLB_VAR(m_fAllMandatoryCNIdent) = FALSE;
-
-                        }
-                        break;
-                    }
-
-                    default:
-                    {
-                        break;
-                    }
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command ResetConfiguration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// EPL frames received
+			case kEplNmtEventDllCeSoc:
+			case kEplNmtEventDllCeSoa:
+				{	// other MN in network
+					// $$$ d.k.: generate error history entry
+					EPL_MCO_GLB_VAR(m_fFrozen) = TRUE;
+					break;
+				}
+
+				// timeout event
+			case kEplNmtEventTimerBasicEthernet:
+				{
+					if (EPL_MCO_GLB_VAR(m_fFrozen) == FALSE) {	// new state BasicEthernet
+						EPL_MCO_GLB_VAR(m_NmtState) =
+						    kEplNmtMsBasicEthernet;
+					}
+					break;
+				}
+
+				// timeout event
+			case kEplNmtEventTimerMsPreOp1:
+				{
+					if (EPL_MCO_GLB_VAR(m_fFrozen) == FALSE) {	// new state PreOp1
+						EPL_MCO_GLB_VAR(m_NmtState) =
+						    kEplNmtMsPreOperational1;
+						EPL_MCO_GLB_VAR
+						    (m_fTimerMsPreOp2) = FALSE;
+						EPL_MCO_GLB_VAR
+						    (m_fAllMandatoryCNIdent) =
+						    FALSE;
+
+					}
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
 
-                }// end of switch(NmtEvent)
+			}	// end of switch(NmtEvent)
 
-            #endif // ((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) == 0)
+#endif // ((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) == 0)
 
-            break;
-        }
+			break;
+		}
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-        // MN process reduces epl cycle
-        case kEplNmtMsPreOperational1:
-        {
-            // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // NMT Command ResetConfiguration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // EPL frames received
-                case kEplNmtEventDllCeSoc:
-                case kEplNmtEventDllCeSoa:
-                {   // other MN in network
-                    // $$$ d.k.: generate error history entry
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // error occured
-                // d.k. MSPreOp1->CSPreOp1: nonsense -> keep state
-                /*
-                case kEplNmtEventNmtCycleError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational1;
-                    break;
-                }
-                */
-
-                case kEplNmtEventAllMandatoryCNIdent:
-                {   // all mandatory CN identified
-                    if (EPL_MCO_GLB_VAR(m_fTimerMsPreOp2) != FALSE)
-                    {
-                        EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtMsPreOperational2;
-                    }
-                    else
-                    {
-                        EPL_MCO_GLB_VAR(m_fAllMandatoryCNIdent) = TRUE;
-                    }
-                    break;
-                }
-
-                case kEplNmtEventTimerMsPreOp2:
-                {   // residence time for PreOp1 is elapsed
-                    if (EPL_MCO_GLB_VAR(m_fAllMandatoryCNIdent) != FALSE)
-                    {
-                        EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtMsPreOperational2;
-                    }
-                    else
-                    {
-                        EPL_MCO_GLB_VAR(m_fTimerMsPreOp2) = TRUE;
-                    }
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-            break;
-        }
-
-        // MN process full epl cycle
-        case kEplNmtMsPreOperational2:
-        {
-            // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // NMT Command ResetConfiguration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // EPL frames received
-                case kEplNmtEventDllCeSoc:
-                case kEplNmtEventDllCeSoa:
-                {   // other MN in network
-                    // $$$ d.k.: generate error history entry
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // error occured
-                case kEplNmtEventNmtCycleError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtMsPreOperational1;
-                    break;
-                }
-
-                case kEplNmtEventEnterReadyToOperate:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtMsReadyToOperate;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-
-            break;
-        }
-
-        // all madatory nodes ready to operate
-        // -> MN process full epl cycle
-        case kEplNmtMsReadyToOperate:
-        {
-
-            // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // NMT Command ResetConfiguration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // EPL frames received
-                case kEplNmtEventDllCeSoc:
-                case kEplNmtEventDllCeSoa:
-                {   // other MN in network
-                    // $$$ d.k.: generate error history entry
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // error occured
-                case kEplNmtEventNmtCycleError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtMsPreOperational1;
-                    break;
-                }
-
-                case kEplNmtEventEnterMsOperational:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtMsOperational;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-
-            break;
-        }
-
-        // normal eplcycle processing
-        case kEplNmtMsOperational:
-        {
-            // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // NMT Command ResetConfiguration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // EPL frames received
-                case kEplNmtEventDllCeSoc:
-                case kEplNmtEventDllCeSoa:
-                {   // other MN in network
-                    // $$$ d.k.: generate error history entry
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // error occured
-                case kEplNmtEventNmtCycleError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtMsPreOperational1;
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-            break;
-        }
-
-        //  normal ethernet traffic
-        case kEplNmtMsBasicEthernet:
-        {
-
-            // check events
-            switch(NmtEvent)
-            {
-                // NMT Command SwitchOff
-                case kEplNmtEventCriticalError:
-                case kEplNmtEventSwitchOff:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsOff;
-                    break;
-                }
-
-                // NMT Command SwReset
-                case kEplNmtEventSwReset:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsInitialising;
-                    break;
-                }
-
-                // NMT Command ResetNode
-                case kEplNmtEventResetNode:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-                    break;
-                }
-
-                // NMT Command ResetCommunication
-                // or internal Communication error
-                case kEplNmtEventResetCom:
-                case kEplNmtEventInternComError:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
+		// MN process reduces epl cycle
+	case kEplNmtMsPreOperational1:
+		{
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command ResetConfiguration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// EPL frames received
+			case kEplNmtEventDllCeSoc:
+			case kEplNmtEventDllCeSoa:
+				{	// other MN in network
+					// $$$ d.k.: generate error history entry
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// error occured
+				// d.k. MSPreOp1->CSPreOp1: nonsense -> keep state
+				/*
+				   case kEplNmtEventNmtCycleError:
+				   {
+				   EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational1;
+				   break;
+				   }
+				 */
+
+			case kEplNmtEventAllMandatoryCNIdent:
+				{	// all mandatory CN identified
+					if (EPL_MCO_GLB_VAR(m_fTimerMsPreOp2) !=
+					    FALSE) {
+						EPL_MCO_GLB_VAR(m_NmtState) =
+						    kEplNmtMsPreOperational2;
+					} else {
+						EPL_MCO_GLB_VAR
+						    (m_fAllMandatoryCNIdent) =
+						    TRUE;
+					}
+					break;
+				}
+
+			case kEplNmtEventTimerMsPreOp2:
+				{	// residence time for PreOp1 is elapsed
+					if (EPL_MCO_GLB_VAR
+					    (m_fAllMandatoryCNIdent) != FALSE) {
+						EPL_MCO_GLB_VAR(m_NmtState) =
+						    kEplNmtMsPreOperational2;
+					} else {
+						EPL_MCO_GLB_VAR
+						    (m_fTimerMsPreOp2) = TRUE;
+					}
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+			break;
+		}
+
+		// MN process full epl cycle
+	case kEplNmtMsPreOperational2:
+		{
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command ResetConfiguration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// EPL frames received
+			case kEplNmtEventDllCeSoc:
+			case kEplNmtEventDllCeSoa:
+				{	// other MN in network
+					// $$$ d.k.: generate error history entry
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// error occured
+			case kEplNmtEventNmtCycleError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtMsPreOperational1;
+					break;
+				}
+
+			case kEplNmtEventEnterReadyToOperate:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtMsReadyToOperate;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+
+			break;
+		}
+
+		// all madatory nodes ready to operate
+		// -> MN process full epl cycle
+	case kEplNmtMsReadyToOperate:
+		{
+
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command ResetConfiguration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// EPL frames received
+			case kEplNmtEventDllCeSoc:
+			case kEplNmtEventDllCeSoa:
+				{	// other MN in network
+					// $$$ d.k.: generate error history entry
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// error occured
+			case kEplNmtEventNmtCycleError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtMsPreOperational1;
+					break;
+				}
+
+			case kEplNmtEventEnterMsOperational:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtMsOperational;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+
+			break;
+		}
+
+		// normal eplcycle processing
+	case kEplNmtMsOperational:
+		{
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command ResetConfiguration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// EPL frames received
+			case kEplNmtEventDllCeSoc:
+			case kEplNmtEventDllCeSoa:
+				{	// other MN in network
+					// $$$ d.k.: generate error history entry
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// error occured
+			case kEplNmtEventNmtCycleError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtMsPreOperational1;
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+			break;
+		}
+
+		//  normal ethernet traffic
+	case kEplNmtMsBasicEthernet:
+		{
+
+			// check events
+			switch (NmtEvent) {
+				// NMT Command SwitchOff
+			case kEplNmtEventCriticalError:
+			case kEplNmtEventSwitchOff:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsOff;
+					break;
+				}
+
+				// NMT Command SwReset
+			case kEplNmtEventSwReset:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsInitialising;
+					break;
+				}
+
+				// NMT Command ResetNode
+			case kEplNmtEventResetNode:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetApplication;
+					break;
+				}
+
+				// NMT Command ResetCommunication
+				// or internal Communication error
+			case kEplNmtEventResetCom:
+			case kEplNmtEventInternComError:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
+
+				// NMT Command ResetConfiguration
+			case kEplNmtEventResetConfig:
+				{
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetConfiguration;
+					break;
+				}
+
+				// EPL frames received
+			case kEplNmtEventDllCeSoc:
+			case kEplNmtEventDllCeSoa:
+				{	// other MN in network
+					// $$$ d.k.: generate error history entry
+					EPL_MCO_GLB_VAR(m_NmtState) =
+					    kEplNmtGsResetCommunication;
+					break;
+				}
 
-                // NMT Command ResetConfiguration
-                case kEplNmtEventResetConfig:
-                {
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetConfiguration;
-                    break;
-                }
-
-                // EPL frames received
-                case kEplNmtEventDllCeSoc:
-                case kEplNmtEventDllCeSoa:
-                {   // other MN in network
-                    // $$$ d.k.: generate error history entry
-                    EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetCommunication;
-                    break;
-                }
-
-                // error occured
-                // d.k. BE->PreOp1 on cycle error? No
+				// error occured
+				// d.k. BE->PreOp1 on cycle error? No
 /*                case kEplNmtEventNmtCycleError:
                 {
                     EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtCsPreOperational1;
                     break;
                 }
 */
-                default:
-                {
-                    break;
-                }
-
-            }// end of switch(NmtEvent)
-            break;
-        }
+			default:
+				{
+					break;
+				}
+
+			}	// end of switch(NmtEvent)
+			break;
+		}
 #endif //#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
-        default:
-        {
-            //DEBUG_EPL_DBGLVL_NMTK_TRACE0(EPL_DBGLVL_NMT ,"Error in EplNmtProcess: Unknown NMT-State");
-            //EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
-            Ret = kEplNmtInvalidState;
-            goto Exit;
-        }
-
-    }// end of switch(NmtEvent)
-
-    // inform higher layer about State-Change if needed
-    if(OldNmtState != EPL_MCO_GLB_VAR(m_NmtState))
-    {
-        EPL_NMTK_DBG_POST_TRACE_VALUE(NmtEvent, OldNmtState, EPL_MCO_GLB_VAR(m_NmtState));
-
-        // d.k.: memorize NMT state before posting any events
-        NmtStateChange.m_NewNmtState = EPL_MCO_GLB_VAR(m_NmtState);
-
-        // inform DLL
-        if ((OldNmtState > kEplNmtGsResetConfiguration)
-            && (EPL_MCO_GLB_VAR(m_NmtState) <= kEplNmtGsResetConfiguration))
-        {
-            // send DLL DEINIT
-            Event.m_EventSink = kEplEventSinkDllk;
-            Event.m_EventType = kEplEventTypeDllkDestroy;
-            EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
-            Event.m_pArg = &OldNmtState;
-            Event.m_uiSize = sizeof (OldNmtState);
-            // d.k.: directly call DLLk process function, because
-            //       1. execution of process function is still synchonized and serialized,
-            //       2. it is the same as without event queues (i.e. well tested),
-            //       3. DLLk will get those necessary events even if event queue is full,
-            //       4. event queue is very inefficient
+	default:
+		{
+			//DEBUG_EPL_DBGLVL_NMTK_TRACE0(EPL_DBGLVL_NMT ,"Error in EplNmtProcess: Unknown NMT-State");
+			//EPL_MCO_GLB_VAR(m_NmtState) = kEplNmtGsResetApplication;
+			Ret = kEplNmtInvalidState;
+			goto Exit;
+		}
+
+	}			// end of switch(NmtEvent)
+
+	// inform higher layer about State-Change if needed
+	if (OldNmtState != EPL_MCO_GLB_VAR(m_NmtState)) {
+		EPL_NMTK_DBG_POST_TRACE_VALUE(NmtEvent, OldNmtState,
+					      EPL_MCO_GLB_VAR(m_NmtState));
+
+		// d.k.: memorize NMT state before posting any events
+		NmtStateChange.m_NewNmtState = EPL_MCO_GLB_VAR(m_NmtState);
+
+		// inform DLL
+		if ((OldNmtState > kEplNmtGsResetConfiguration)
+		    && (EPL_MCO_GLB_VAR(m_NmtState) <=
+			kEplNmtGsResetConfiguration)) {
+			// send DLL DEINIT
+			Event.m_EventSink = kEplEventSinkDllk;
+			Event.m_EventType = kEplEventTypeDllkDestroy;
+			EPL_MEMSET(&Event.m_NetTime, 0x00,
+				   sizeof(Event.m_NetTime));
+			Event.m_pArg = &OldNmtState;
+			Event.m_uiSize = sizeof(OldNmtState);
+			// d.k.: directly call DLLk process function, because
+			//       1. execution of process function is still synchonized and serialized,
+			//       2. it is the same as without event queues (i.e. well tested),
+			//       3. DLLk will get those necessary events even if event queue is full,
+			//       4. event queue is very inefficient
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-            Ret = EplDllkProcess(&Event);
+			Ret = EplDllkProcess(&Event);
 #else
-            Ret = EplEventkPost(&Event);
+			Ret = EplEventkPost(&Event);
 #endif
-        }
-        else if ((OldNmtState <= kEplNmtGsResetConfiguration)
-            && (EPL_MCO_GLB_VAR(m_NmtState) > kEplNmtGsResetConfiguration))
-        {
-            // send DLL INIT
-            Event.m_EventSink = kEplEventSinkDllk;
-            Event.m_EventType = kEplEventTypeDllkCreate;
-            EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
-            Event.m_pArg = &NmtStateChange.m_NewNmtState;
-            Event.m_uiSize = sizeof (NmtStateChange.m_NewNmtState);
-            // d.k.: directly call DLLk process function, because
-            //       1. execution of process function is still synchonized and serialized,
-            //       2. it is the same as without event queues (i.e. well tested),
-            //       3. DLLk will get those necessary events even if event queue is full
-            //       4. event queue is very inefficient
+		} else if ((OldNmtState <= kEplNmtGsResetConfiguration)
+			   && (EPL_MCO_GLB_VAR(m_NmtState) >
+			       kEplNmtGsResetConfiguration)) {
+			// send DLL INIT
+			Event.m_EventSink = kEplEventSinkDllk;
+			Event.m_EventType = kEplEventTypeDllkCreate;
+			EPL_MEMSET(&Event.m_NetTime, 0x00,
+				   sizeof(Event.m_NetTime));
+			Event.m_pArg = &NmtStateChange.m_NewNmtState;
+			Event.m_uiSize = sizeof(NmtStateChange.m_NewNmtState);
+			// d.k.: directly call DLLk process function, because
+			//       1. execution of process function is still synchonized and serialized,
+			//       2. it is the same as without event queues (i.e. well tested),
+			//       3. DLLk will get those necessary events even if event queue is full
+			//       4. event queue is very inefficient
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-            Ret = EplDllkProcess(&Event);
+			Ret = EplDllkProcess(&Event);
 #else
-            Ret = EplEventkPost(&Event);
+			Ret = EplEventkPost(&Event);
 #endif
-        }
-        else if ((EPL_MCO_GLB_VAR(m_NmtState) == kEplNmtCsBasicEthernet)
-                 || (EPL_MCO_GLB_VAR(m_NmtState) == kEplNmtMsBasicEthernet))
-        {
-        tEplDllAsyncReqPriority AsyncReqPriority;
-
-            // send DLL Fill Async Tx Buffer, because state BasicEthernet was entered
-            Event.m_EventSink = kEplEventSinkDllk;
-            Event.m_EventType = kEplEventTypeDllkFillTx;
-            EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
-            AsyncReqPriority = kEplDllAsyncReqPrioGeneric;
-            Event.m_pArg = &AsyncReqPriority;
-            Event.m_uiSize = sizeof (AsyncReqPriority);
-            // d.k.: directly call DLLk process function, because
-            //       1. execution of process function is still synchonized and serialized,
-            //       2. it is the same as without event queues (i.e. well tested),
-            //       3. DLLk will get those necessary events even if event queue is full
-            //       4. event queue is very inefficient
+		} else
+		    if ((EPL_MCO_GLB_VAR(m_NmtState) == kEplNmtCsBasicEthernet)
+			|| (EPL_MCO_GLB_VAR(m_NmtState) ==
+			    kEplNmtMsBasicEthernet)) {
+			tEplDllAsyncReqPriority AsyncReqPriority;
+
+			// send DLL Fill Async Tx Buffer, because state BasicEthernet was entered
+			Event.m_EventSink = kEplEventSinkDllk;
+			Event.m_EventType = kEplEventTypeDllkFillTx;
+			EPL_MEMSET(&Event.m_NetTime, 0x00,
+				   sizeof(Event.m_NetTime));
+			AsyncReqPriority = kEplDllAsyncReqPrioGeneric;
+			Event.m_pArg = &AsyncReqPriority;
+			Event.m_uiSize = sizeof(AsyncReqPriority);
+			// d.k.: directly call DLLk process function, because
+			//       1. execution of process function is still synchonized and serialized,
+			//       2. it is the same as without event queues (i.e. well tested),
+			//       3. DLLk will get those necessary events even if event queue is full
+			//       4. event queue is very inefficient
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) != 0)
-            Ret = EplDllkProcess(&Event);
+			Ret = EplDllkProcess(&Event);
 #else
-            Ret = EplEventkPost(&Event);
+			Ret = EplEventkPost(&Event);
 #endif
-        }
-
-        // inform higher layer about state change
-        NmtStateChange.m_NmtEvent = NmtEvent;
-        Event.m_EventSink = kEplEventSinkNmtu;
-        Event.m_EventType = kEplEventTypeNmtStateChange;
-        EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
-        Event.m_pArg = &NmtStateChange;
-        Event.m_uiSize = sizeof(NmtStateChange);
-        Ret = EplEventkPost(&Event);
-        EPL_DBGLVL_NMTK_TRACE2("EplNmtkProcess(NMT-Event = 0x%04X): New NMT-State = 0x%03X\n", NmtEvent, NmtStateChange.m_NewNmtState);
+		}
+		// inform higher layer about state change
+		NmtStateChange.m_NmtEvent = NmtEvent;
+		Event.m_EventSink = kEplEventSinkNmtu;
+		Event.m_EventType = kEplEventTypeNmtStateChange;
+		EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
+		Event.m_pArg = &NmtStateChange;
+		Event.m_uiSize = sizeof(NmtStateChange);
+		Ret = EplEventkPost(&Event);
+		EPL_DBGLVL_NMTK_TRACE2
+		    ("EplNmtkProcess(NMT-Event = 0x%04X): New NMT-State = 0x%03X\n",
+		     NmtEvent, NmtStateChange.m_NewNmtState);
 
+	}
 
-    }
+      Exit:
 
-Exit:
-
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1709,13 +1804,14 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplNmtState PUBLIC EplNmtkGetNmtState(EPL_MCO_DECL_PTR_INSTANCE_PTR)
+EPLDLLEXPORT tEplNmtState PUBLIC
+EplNmtkGetNmtState(EPL_MCO_DECL_PTR_INSTANCE_PTR)
 {
-tEplNmtState NmtState;
+	tEplNmtState NmtState;
 
-    NmtState = EPL_MCO_GLB_VAR(m_NmtState);
+	NmtState = EPL_MCO_GLB_VAR(m_NmtState);
 
-    return NmtState;
+	return NmtState;
 
 }
 
@@ -1724,7 +1820,7 @@ tEplNmtState NmtState;
 //          P R I V A T E   D E F I N I T I O N S                          //
 //                                                                         //
 //=========================================================================//
-EPL_MCO_DECL_INSTANCE_FCT ()
+EPL_MCO_DECL_INSTANCE_FCT()
 //---------------------------------------------------------------------------
 //
 // Function:
@@ -1742,9 +1838,5 @@ EPL_MCO_DECL_INSTANCE_FCT ()
 // State:
 //
 //---------------------------------------------------------------------------
-
-
 #endif // #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTK)) != 0)
-
 // EOF
-
--- a/drivers/staging/epl/EplNmtkCal.c
+++ b/drivers/staging/epl/EplNmtkCal.c
@@ -71,11 +71,9 @@
 
 #include "kernel/EplNmtkCal.h"
 
-
 // TODO: init function needed to prepare EplNmtkGetNmtState for
 //       io-controll-call from EplNmtuCal-Modul
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -100,8 +98,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -126,7 +122,6 @@
 //
 //---------------------------------------------------------------------------
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -151,7 +146,4 @@
 //
 //---------------------------------------------------------------------------
 
-
-
 // EOF
-
--- a/drivers/staging/epl/EplNmtMnu.c
+++ b/drivers/staging/epl/EplNmtMnu.c
@@ -94,42 +94,41 @@
 
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-    void  PUBLIC  TgtDbgSignalTracePoint (BYTE bTracePointNumber_p);
-    void  PUBLIC  TgtDbgPostTraceValue (DWORD dwTraceValue_p);
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void PUBLIC TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)
 #endif
 #define EPL_NMTMNU_DBG_POST_TRACE_VALUE(Event_p, uiNodeId_p, wErrorCode_p) \
     TGT_DBG_POST_TRACE_VALUE((kEplEventSinkNmtMnu << 28) | (Event_p << 24) \
                              | (uiNodeId_p << 16) | wErrorCode_p)
 
-
 // defines for flags in node info structure
-#define EPL_NMTMNU_NODE_FLAG_ISOCHRON       0x0001  // CN is being accessed isochronously
-#define EPL_NMTMNU_NODE_FLAG_NOT_SCANNED    0x0002  // CN was not scanned once -> decrement SignalCounter and reset flag
-#define EPL_NMTMNU_NODE_FLAG_HALTED         0x0004  // boot process for this CN is halted
-#define EPL_NMTMNU_NODE_FLAG_NMT_CMD_ISSUED 0x0008  // NMT command was just issued, wrong NMT states will be tolerated
-#define EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ  0x0300  // counter for StatusRequest timer handle
-#define EPL_NMTMNU_NODE_FLAG_COUNT_LONGER   0x0C00  // counter for longer timeouts timer handle
-#define EPL_NMTMNU_NODE_FLAG_INC_STATREQ    0x0100  // increment for StatusRequest timer handle
-#define EPL_NMTMNU_NODE_FLAG_INC_LONGER     0x0400  // increment for longer timeouts timer handle
-                    // These counters will be incremented at every timer start
-                    // and copied to timerarg. When the timer event occures
-                    // both will be compared and if unequal the timer event
-                    // will be discarded, because it is an old one.
+#define EPL_NMTMNU_NODE_FLAG_ISOCHRON       0x0001	// CN is being accessed isochronously
+#define EPL_NMTMNU_NODE_FLAG_NOT_SCANNED    0x0002	// CN was not scanned once -> decrement SignalCounter and reset flag
+#define EPL_NMTMNU_NODE_FLAG_HALTED         0x0004	// boot process for this CN is halted
+#define EPL_NMTMNU_NODE_FLAG_NMT_CMD_ISSUED 0x0008	// NMT command was just issued, wrong NMT states will be tolerated
+#define EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ  0x0300	// counter for StatusRequest timer handle
+#define EPL_NMTMNU_NODE_FLAG_COUNT_LONGER   0x0C00	// counter for longer timeouts timer handle
+#define EPL_NMTMNU_NODE_FLAG_INC_STATREQ    0x0100	// increment for StatusRequest timer handle
+#define EPL_NMTMNU_NODE_FLAG_INC_LONGER     0x0400	// increment for longer timeouts timer handle
+		    // These counters will be incremented at every timer start
+		    // and copied to timerarg. When the timer event occures
+		    // both will be compared and if unequal the timer event
+		    // will be discarded, because it is an old one.
 
 // defines for timer arguments to draw a distinction between serveral events
-#define EPL_NMTMNU_TIMERARG_NODE_MASK   0x000000FFL // mask that contains the node-ID
-#define EPL_NMTMNU_TIMERARG_IDENTREQ    0x00010000L // timer event is for IdentRequest
-#define EPL_NMTMNU_TIMERARG_STATREQ     0x00020000L // timer event is for StatusRequest
-#define EPL_NMTMNU_TIMERARG_LONGER      0x00040000L // timer event is for longer timeouts
-#define EPL_NMTMNU_TIMERARG_STATE_MON   0x00080000L // timer event for StatusRequest to monitor execution of NMT state changes
-#define EPL_NMTMNU_TIMERARG_COUNT_SR    0x00000300L // counter for StatusRequest
-#define EPL_NMTMNU_TIMERARG_COUNT_LO    0x00000C00L // counter for longer timeouts
-                    // The counters must have the same position as in the node flags above.
+#define EPL_NMTMNU_TIMERARG_NODE_MASK   0x000000FFL	// mask that contains the node-ID
+#define EPL_NMTMNU_TIMERARG_IDENTREQ    0x00010000L	// timer event is for IdentRequest
+#define EPL_NMTMNU_TIMERARG_STATREQ     0x00020000L	// timer event is for StatusRequest
+#define EPL_NMTMNU_TIMERARG_LONGER      0x00040000L	// timer event is for longer timeouts
+#define EPL_NMTMNU_TIMERARG_STATE_MON   0x00080000L	// timer event for StatusRequest to monitor execution of NMT state changes
+#define EPL_NMTMNU_TIMERARG_COUNT_SR    0x00000300L	// counter for StatusRequest
+#define EPL_NMTMNU_TIMERARG_COUNT_LO    0x00000C00L	// counter for longer timeouts
+		    // The counters must have the same position as in the node flags above.
 
 #define EPL_NMTMNU_SET_FLAGS_TIMERARG_STATREQ(pNodeInfo_p, uiNodeId_p, TimerArg_p) \
     pNodeInfo_p->m_wFlags = \
@@ -167,10 +166,9 @@
         (pNodeInfo_p->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ); \
     TimerArg_p.m_EventSink = kEplEventSinkNmtMnu;
 
-
 // defines for global flags
-#define EPL_NMTMNU_FLAG_HALTED          0x0001  // boot process is halted
-#define EPL_NMTMNU_FLAG_APP_INFORMED    0x0002  // application was informed about possible NMT state change
+#define EPL_NMTMNU_FLAG_HALTED          0x0001	// boot process is halted
+#define EPL_NMTMNU_FLAG_APP_INFORMED    0x0002	// application was informed about possible NMT state change
 
 // return pointer to node info structure for specified node ID
 // d.k. may be replaced by special (hash) function if node ID array is smaller than 254
@@ -180,73 +178,64 @@
 // local types
 //---------------------------------------------------------------------------
 
-typedef enum
-{
-    kEplNmtMnuIntNodeEventNoIdentResponse   = 0x00,
-    kEplNmtMnuIntNodeEventIdentResponse     = 0x01,
-    kEplNmtMnuIntNodeEventBoot              = 0x02,
-    kEplNmtMnuIntNodeEventExecReset         = 0x03,
-    kEplNmtMnuIntNodeEventConfigured        = 0x04,
-    kEplNmtMnuIntNodeEventNoStatusResponse  = 0x05,
-    kEplNmtMnuIntNodeEventStatusResponse    = 0x06,
-    kEplNmtMnuIntNodeEventHeartbeat         = 0x07,
-    kEplNmtMnuIntNodeEventNmtCmdSent        = 0x08,
-    kEplNmtMnuIntNodeEventTimerIdentReq     = 0x09,
-    kEplNmtMnuIntNodeEventTimerStatReq      = 0x0A,
-    kEplNmtMnuIntNodeEventTimerStateMon     = 0x0B,
-    kEplNmtMnuIntNodeEventTimerLonger       = 0x0C,
-    kEplNmtMnuIntNodeEventError             = 0x0D,
+typedef enum {
+	kEplNmtMnuIntNodeEventNoIdentResponse = 0x00,
+	kEplNmtMnuIntNodeEventIdentResponse = 0x01,
+	kEplNmtMnuIntNodeEventBoot = 0x02,
+	kEplNmtMnuIntNodeEventExecReset = 0x03,
+	kEplNmtMnuIntNodeEventConfigured = 0x04,
+	kEplNmtMnuIntNodeEventNoStatusResponse = 0x05,
+	kEplNmtMnuIntNodeEventStatusResponse = 0x06,
+	kEplNmtMnuIntNodeEventHeartbeat = 0x07,
+	kEplNmtMnuIntNodeEventNmtCmdSent = 0x08,
+	kEplNmtMnuIntNodeEventTimerIdentReq = 0x09,
+	kEplNmtMnuIntNodeEventTimerStatReq = 0x0A,
+	kEplNmtMnuIntNodeEventTimerStateMon = 0x0B,
+	kEplNmtMnuIntNodeEventTimerLonger = 0x0C,
+	kEplNmtMnuIntNodeEventError = 0x0D,
 
 } tEplNmtMnuIntNodeEvent;
 
-
-typedef enum
-{
-    kEplNmtMnuNodeStateUnknown      = 0x00,
-    kEplNmtMnuNodeStateIdentified   = 0x01,
-    kEplNmtMnuNodeStateResetConf    = 0x02, // CN reset after configuration update
-    kEplNmtMnuNodeStateConfigured   = 0x03, // BootStep1 completed
-    kEplNmtMnuNodeStateReadyToOp    = 0x04, // BootStep2 completed
-    kEplNmtMnuNodeStateComChecked   = 0x05, // Communication checked successfully
-    kEplNmtMnuNodeStateOperational  = 0x06, // CN is in NMT state OPERATIONAL
+typedef enum {
+	kEplNmtMnuNodeStateUnknown = 0x00,
+	kEplNmtMnuNodeStateIdentified = 0x01,
+	kEplNmtMnuNodeStateResetConf = 0x02,	// CN reset after configuration update
+	kEplNmtMnuNodeStateConfigured = 0x03,	// BootStep1 completed
+	kEplNmtMnuNodeStateReadyToOp = 0x04,	// BootStep2 completed
+	kEplNmtMnuNodeStateComChecked = 0x05,	// Communication checked successfully
+	kEplNmtMnuNodeStateOperational = 0x06,	// CN is in NMT state OPERATIONAL
 
 } tEplNmtMnuNodeState;
 
-
-typedef struct
-{
-    tEplTimerHdl        m_TimerHdlStatReq;  // timer to delay StatusRequests and IdentRequests
-    tEplTimerHdl        m_TimerHdlLonger;   // 2nd timer for NMT command EnableReadyToOp and CheckCommunication
-    tEplNmtMnuNodeState m_NodeState;    // internal node state (kind of sub state of NMT state)
-    DWORD               m_dwNodeCfg;    // subindex from 0x1F81
-    WORD                m_wFlags;       // flags: CN is being accessed isochronously
+typedef struct {
+	tEplTimerHdl m_TimerHdlStatReq;	// timer to delay StatusRequests and IdentRequests
+	tEplTimerHdl m_TimerHdlLonger;	// 2nd timer for NMT command EnableReadyToOp and CheckCommunication
+	tEplNmtMnuNodeState m_NodeState;	// internal node state (kind of sub state of NMT state)
+	DWORD m_dwNodeCfg;	// subindex from 0x1F81
+	WORD m_wFlags;		// flags: CN is being accessed isochronously
 
 } tEplNmtMnuNodeInfo;
 
-
-typedef struct
-{
-    tEplNmtMnuNodeInfo  m_aNodeInfo[EPL_NMT_MAX_NODE_ID];
-    tEplTimerHdl        m_TimerHdlNmtState;     // timeout for stay in NMT state
-    unsigned int        m_uiMandatorySlaveCount;
-    unsigned int        m_uiSignalSlaveCount;
-    unsigned long       m_ulStatusRequestDelay; // in [ms] (object 0x1006 * EPL_C_NMT_STATREQ_CYCLE)
-    unsigned long       m_ulTimeoutReadyToOp;   // in [ms] (object 0x1F89/5)
-    unsigned long       m_ulTimeoutCheckCom;    // in [ms] (object 0x1006 * MultiplexedCycleCount)
-    WORD                m_wFlags;               // global flags
-    DWORD               m_dwNmtStartup;         // object 0x1F80 NMT_StartUp_U32
-    tEplNmtMnuCbNodeEvent m_pfnCbNodeEvent;
-    tEplNmtMnuCbBootEvent m_pfnCbBootEvent;
+typedef struct {
+	tEplNmtMnuNodeInfo m_aNodeInfo[EPL_NMT_MAX_NODE_ID];
+	tEplTimerHdl m_TimerHdlNmtState;	// timeout for stay in NMT state
+	unsigned int m_uiMandatorySlaveCount;
+	unsigned int m_uiSignalSlaveCount;
+	unsigned long m_ulStatusRequestDelay;	// in [ms] (object 0x1006 * EPL_C_NMT_STATREQ_CYCLE)
+	unsigned long m_ulTimeoutReadyToOp;	// in [ms] (object 0x1F89/5)
+	unsigned long m_ulTimeoutCheckCom;	// in [ms] (object 0x1006 * MultiplexedCycleCount)
+	WORD m_wFlags;		// global flags
+	DWORD m_dwNmtStartup;	// object 0x1F80 NMT_StartUp_U32
+	tEplNmtMnuCbNodeEvent m_pfnCbNodeEvent;
+	tEplNmtMnuCbBootEvent m_pfnCbBootEvent;
 
 } tEplNmtMnuInstance;
 
-
 //---------------------------------------------------------------------------
 // local vars
 //---------------------------------------------------------------------------
 
-static tEplNmtMnuInstance   EplNmtMnuInstance_g;
-
+static tEplNmtMnuInstance EplNmtMnuInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
@@ -254,20 +243,19 @@ static tEplNmtMnuInstance   EplNmtMnuIns
 
 static tEplKernel PUBLIC EplNmtMnuCbNmtRequest(tEplFrameInfo * pFrameInfo_p);
 
-static tEplKernel PUBLIC EplNmtMnuCbIdentResponse(
-                                    unsigned int        uiNodeId_p,
-                                    tEplIdentResponse*  pIdentResponse_p);
-
-static tEplKernel PUBLIC EplNmtMnuCbStatusResponse(
-                                    unsigned int        uiNodeId_p,
-                                    tEplStatusResponse* pStatusResponse_p);
-
-static tEplKernel EplNmtMnuCheckNmtState(
-                                    unsigned int        uiNodeId_p,
-                                    tEplNmtMnuNodeInfo* pNodeInfo_p,
-                                    tEplNmtState        NodeNmtState_p,
-                                    WORD                wErrorCode_p,
-                                    tEplNmtState        LocalNmtState_p);
+static tEplKernel PUBLIC EplNmtMnuCbIdentResponse(unsigned int uiNodeId_p,
+						  tEplIdentResponse *
+						  pIdentResponse_p);
+
+static tEplKernel PUBLIC EplNmtMnuCbStatusResponse(unsigned int uiNodeId_p,
+						   tEplStatusResponse *
+						   pStatusResponse_p);
+
+static tEplKernel EplNmtMnuCheckNmtState(unsigned int uiNodeId_p,
+					 tEplNmtMnuNodeInfo * pNodeInfo_p,
+					 tEplNmtState NodeNmtState_p,
+					 WORD wErrorCode_p,
+					 tEplNmtState LocalNmtState_p);
 
 static tEplKernel EplNmtMnuStartBootStep1(void);
 
@@ -275,22 +263,22 @@ static tEplKernel EplNmtMnuStartBootStep
 
 static tEplKernel EplNmtMnuStartCheckCom(void);
 
-static tEplKernel EplNmtMnuNodeBootStep2(unsigned int uiNodeId_p, tEplNmtMnuNodeInfo* pNodeInfo_p);
+static tEplKernel EplNmtMnuNodeBootStep2(unsigned int uiNodeId_p,
+					 tEplNmtMnuNodeInfo * pNodeInfo_p);
 
-static tEplKernel EplNmtMnuNodeCheckCom(unsigned int uiNodeId_p, tEplNmtMnuNodeInfo* pNodeInfo_p);
+static tEplKernel EplNmtMnuNodeCheckCom(unsigned int uiNodeId_p,
+					tEplNmtMnuNodeInfo * pNodeInfo_p);
 
 static tEplKernel EplNmtMnuStartNodes(void);
 
-static tEplKernel EplNmtMnuProcessInternalEvent(
-                                    unsigned int        uiNodeId_p,
-                                    tEplNmtState        NodeNmtState_p,
-                                    WORD                wErrorCode_p,
-                                    tEplNmtMnuIntNodeEvent NodeEvent_p);
+static tEplKernel EplNmtMnuProcessInternalEvent(unsigned int uiNodeId_p,
+						tEplNmtState NodeNmtState_p,
+						WORD wErrorCode_p,
+						tEplNmtMnuIntNodeEvent
+						NodeEvent_p);
 
 static tEplKernel EplNmtMnuReset(void);
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -316,16 +304,15 @@ static tEplKernel EplNmtMnuReset(void);
 //---------------------------------------------------------------------------
 
 tEplKernel EplNmtMnuInit(tEplNmtMnuCbNodeEvent pfnCbNodeEvent_p,
-                         tEplNmtMnuCbBootEvent pfnCbBootEvent_p)
+			 tEplNmtMnuCbBootEvent pfnCbBootEvent_p)
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = EplNmtMnuAddInstance(pfnCbNodeEvent_p, pfnCbBootEvent_p);
+	Ret = EplNmtMnuAddInstance(pfnCbNodeEvent_p, pfnCbBootEvent_p);
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuAddInstance
@@ -345,35 +332,36 @@ tEplKernel Ret;
 //---------------------------------------------------------------------------
 
 tEplKernel EplNmtMnuAddInstance(tEplNmtMnuCbNodeEvent pfnCbNodeEvent_p,
-                                tEplNmtMnuCbBootEvent pfnCbBootEvent_p)
+				tEplNmtMnuCbBootEvent pfnCbBootEvent_p)
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // reset instance structure
-    EPL_MEMSET(&EplNmtMnuInstance_g, 0, sizeof (EplNmtMnuInstance_g));
+	// reset instance structure
+	EPL_MEMSET(&EplNmtMnuInstance_g, 0, sizeof(EplNmtMnuInstance_g));
 
-    if ((pfnCbNodeEvent_p == NULL) || (pfnCbBootEvent_p == NULL))
-    {
-        Ret = kEplNmtInvalidParam;
-        goto Exit;
-    }
-    EplNmtMnuInstance_g.m_pfnCbNodeEvent = pfnCbNodeEvent_p;
-    EplNmtMnuInstance_g.m_pfnCbBootEvent = pfnCbBootEvent_p;
+	if ((pfnCbNodeEvent_p == NULL) || (pfnCbBootEvent_p == NULL)) {
+		Ret = kEplNmtInvalidParam;
+		goto Exit;
+	}
+	EplNmtMnuInstance_g.m_pfnCbNodeEvent = pfnCbNodeEvent_p;
+	EplNmtMnuInstance_g.m_pfnCbBootEvent = pfnCbBootEvent_p;
 
-    // initialize StatusRequest delay
-    EplNmtMnuInstance_g.m_ulStatusRequestDelay = 5000L;
+	// initialize StatusRequest delay
+	EplNmtMnuInstance_g.m_ulStatusRequestDelay = 5000L;
 
-    // register NmtMnResponse callback function
-    Ret = EplDlluCalRegAsndService(kEplDllAsndNmtRequest, EplNmtMnuCbNmtRequest, kEplDllAsndFilterLocal);
+	// register NmtMnResponse callback function
+	Ret =
+	    EplDlluCalRegAsndService(kEplDllAsndNmtRequest,
+				     EplNmtMnuCbNmtRequest,
+				     kEplDllAsndFilterLocal);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuDelInstance
@@ -394,20 +382,21 @@ Exit:
 
 tEplKernel EplNmtMnuDelInstance()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // deregister NmtMnResponse callback function
-    Ret = EplDlluCalRegAsndService(kEplDllAsndNmtRequest, NULL, kEplDllAsndFilterNone);
+	// deregister NmtMnResponse callback function
+	Ret =
+	    EplDlluCalRegAsndService(kEplDllAsndNmtRequest, NULL,
+				     kEplDllAsndFilterNone);
 
-    Ret = EplNmtMnuReset();
+	Ret = EplNmtMnuReset();
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuSendNmtCommandEx
@@ -424,124 +413,118 @@ tEplKernel  Ret;
 //---------------------------------------------------------------------------
 
 tEplKernel EplNmtMnuSendNmtCommandEx(unsigned int uiNodeId_p,
-                                    tEplNmtCommand  NmtCommand_p,
-                                    void* pNmtCommandData_p,
-                                    unsigned int uiDataSize_p)
-{
-tEplKernel      Ret = kEplSuccessful;
-tEplFrameInfo   FrameInfo;
-BYTE            abBuffer[EPL_C_DLL_MINSIZE_NMTCMDEXT];
-tEplFrame*      pFrame = (tEplFrame*) abBuffer;
-BOOL            fSoftDeleteNode = FALSE;
-
-    if ((uiNodeId_p == 0) || (uiNodeId_p > EPL_C_ADR_BROADCAST))
-    {   // invalid node ID specified
-        Ret = kEplInvalidNodeId;
-        goto Exit;
-    }
-
-    if ((pNmtCommandData_p != NULL) && (uiDataSize_p > (EPL_C_DLL_MINSIZE_NMTCMDEXT - EPL_C_DLL_MINSIZE_NMTCMD)))
-    {
-        Ret = kEplNmtInvalidParam;
-        goto Exit;
-    }
-
-    // $$$ d.k. may be check in future versions if the caller wants to perform prohibited state transitions
-    //     the CN should not perform these transitions, but the expected NMT state will be changed and never fullfilled.
-
-    // build frame
-    EPL_MEMSET(pFrame, 0x00, sizeof(abBuffer));
-    AmiSetByteToLe(&pFrame->m_le_bDstNodeId, (BYTE) uiNodeId_p);
-    AmiSetByteToLe(&pFrame->m_Data.m_Asnd.m_le_bServiceId, (BYTE) kEplDllAsndNmtCommand);
-    AmiSetByteToLe(&pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_bNmtCommandId,
-        (BYTE)NmtCommand_p);
-    if ((pNmtCommandData_p != NULL) && (uiDataSize_p > 0))
-    {   // copy command data to frame
-        EPL_MEMCPY(&pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_abNmtCommandData[0], pNmtCommandData_p, uiDataSize_p);
-    }
-
-    // build info structure
-    FrameInfo.m_NetTime.m_dwNanoSec = 0;
-    FrameInfo.m_NetTime.m_dwSec = 0;
-    FrameInfo.m_pFrame = pFrame;
-    FrameInfo.m_uiFrameSize = sizeof(abBuffer);
+				     tEplNmtCommand NmtCommand_p,
+				     void *pNmtCommandData_p,
+				     unsigned int uiDataSize_p)
+{
+	tEplKernel Ret = kEplSuccessful;
+	tEplFrameInfo FrameInfo;
+	BYTE abBuffer[EPL_C_DLL_MINSIZE_NMTCMDEXT];
+	tEplFrame *pFrame = (tEplFrame *) abBuffer;
+	BOOL fSoftDeleteNode = FALSE;
+
+	if ((uiNodeId_p == 0) || (uiNodeId_p > EPL_C_ADR_BROADCAST)) {	// invalid node ID specified
+		Ret = kEplInvalidNodeId;
+		goto Exit;
+	}
+
+	if ((pNmtCommandData_p != NULL)
+	    && (uiDataSize_p >
+		(EPL_C_DLL_MINSIZE_NMTCMDEXT - EPL_C_DLL_MINSIZE_NMTCMD))) {
+		Ret = kEplNmtInvalidParam;
+		goto Exit;
+	}
+	// $$$ d.k. may be check in future versions if the caller wants to perform prohibited state transitions
+	//     the CN should not perform these transitions, but the expected NMT state will be changed and never fullfilled.
+
+	// build frame
+	EPL_MEMSET(pFrame, 0x00, sizeof(abBuffer));
+	AmiSetByteToLe(&pFrame->m_le_bDstNodeId, (BYTE) uiNodeId_p);
+	AmiSetByteToLe(&pFrame->m_Data.m_Asnd.m_le_bServiceId,
+		       (BYTE) kEplDllAsndNmtCommand);
+	AmiSetByteToLe(&pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.
+		       m_le_bNmtCommandId, (BYTE) NmtCommand_p);
+	if ((pNmtCommandData_p != NULL) && (uiDataSize_p > 0)) {	// copy command data to frame
+		EPL_MEMCPY(&pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.
+			   m_le_abNmtCommandData[0], pNmtCommandData_p,
+			   uiDataSize_p);
+	}
+	// build info structure
+	FrameInfo.m_NetTime.m_dwNanoSec = 0;
+	FrameInfo.m_NetTime.m_dwSec = 0;
+	FrameInfo.m_pFrame = pFrame;
+	FrameInfo.m_uiFrameSize = sizeof(abBuffer);
 
-    // send NMT-Request
+	// send NMT-Request
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
-    Ret = EplDlluCalAsyncSend(&FrameInfo,    // pointer to frameinfo
-                           kEplDllAsyncReqPrioNmt); // priority
+	Ret = EplDlluCalAsyncSend(&FrameInfo,	// pointer to frameinfo
+				  kEplDllAsyncReqPrioNmt);	// priority
 #endif
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    EPL_DBGLVL_NMTMN_TRACE2("NMTCmd(%02X->%02X)\n", NmtCommand_p, uiNodeId_p);
-
-    switch (NmtCommand_p)
-    {
-        case kEplNmtCmdStartNode:
-        case kEplNmtCmdEnterPreOperational2:
-        case kEplNmtCmdEnableReadyToOperate:
-        {
-            // nothing left to do,
-            // because any further processing is done
-            // when the NMT command is actually sent
-            goto Exit;
-        }
-
-        case kEplNmtCmdStopNode:
-        {
-            fSoftDeleteNode = TRUE;
-            break;
-        }
-
-        case kEplNmtCmdResetNode:
-        case kEplNmtCmdResetCommunication:
-        case kEplNmtCmdResetConfiguration:
-        case kEplNmtCmdSwReset:
-        {
-            break;
-        }
-
-        default:
-            goto Exit;
-    }
-
-    // remove CN from isochronous phase;
-    // This must be done here and not when NMT command is actually sent
-    // because it will be too late and may cause unwanted errors
-    if (uiNodeId_p != EPL_C_ADR_BROADCAST)
-    {
-        if (fSoftDeleteNode == FALSE)
-        {   // remove CN immediately from isochronous phase
-            Ret = EplDlluCalDeleteNode(uiNodeId_p);
-        }
-        else
-        {   // remove CN from isochronous phase softly
-            Ret = EplDlluCalSoftDeleteNode(uiNodeId_p);
-        }
-    }
-    else
-    {   // do it for all active CNs
-        for (uiNodeId_p = 1; uiNodeId_p <= tabentries(EplNmtMnuInstance_g.m_aNodeInfo); uiNodeId_p++)
-        {
-            if ((EPL_NMTMNU_GET_NODEINFO(uiNodeId_p)->m_dwNodeCfg & (EPL_NODEASSIGN_NODE_IS_CN | EPL_NODEASSIGN_NODE_EXISTS)) != 0)
-            {
-                if (fSoftDeleteNode == FALSE)
-                {   // remove CN immediately from isochronous phase
-                    Ret = EplDlluCalDeleteNode(uiNodeId_p);
-                }
-                else
-                {   // remove CN from isochronous phase softly
-                    Ret = EplDlluCalSoftDeleteNode(uiNodeId_p);
-                }
-            }
-        }
-    }
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	EPL_DBGLVL_NMTMN_TRACE2("NMTCmd(%02X->%02X)\n", NmtCommand_p,
+				uiNodeId_p);
+
+	switch (NmtCommand_p) {
+	case kEplNmtCmdStartNode:
+	case kEplNmtCmdEnterPreOperational2:
+	case kEplNmtCmdEnableReadyToOperate:
+		{
+			// nothing left to do,
+			// because any further processing is done
+			// when the NMT command is actually sent
+			goto Exit;
+		}
+
+	case kEplNmtCmdStopNode:
+		{
+			fSoftDeleteNode = TRUE;
+			break;
+		}
+
+	case kEplNmtCmdResetNode:
+	case kEplNmtCmdResetCommunication:
+	case kEplNmtCmdResetConfiguration:
+	case kEplNmtCmdSwReset:
+		{
+			break;
+		}
+
+	default:
+		goto Exit;
+	}
+
+	// remove CN from isochronous phase;
+	// This must be done here and not when NMT command is actually sent
+	// because it will be too late and may cause unwanted errors
+	if (uiNodeId_p != EPL_C_ADR_BROADCAST) {
+		if (fSoftDeleteNode == FALSE) {	// remove CN immediately from isochronous phase
+			Ret = EplDlluCalDeleteNode(uiNodeId_p);
+		} else {	// remove CN from isochronous phase softly
+			Ret = EplDlluCalSoftDeleteNode(uiNodeId_p);
+		}
+	} else {		// do it for all active CNs
+		for (uiNodeId_p = 1;
+		     uiNodeId_p <= tabentries(EplNmtMnuInstance_g.m_aNodeInfo);
+		     uiNodeId_p++) {
+			if ((EPL_NMTMNU_GET_NODEINFO(uiNodeId_p)->
+			     m_dwNodeCfg & (EPL_NODEASSIGN_NODE_IS_CN |
+					    EPL_NODEASSIGN_NODE_EXISTS)) != 0) {
+				if (fSoftDeleteNode == FALSE) {	// remove CN immediately from isochronous phase
+					Ret = EplDlluCalDeleteNode(uiNodeId_p);
+				} else {	// remove CN from isochronous phase softly
+					Ret =
+					    EplDlluCalSoftDeleteNode
+					    (uiNodeId_p);
+				}
+			}
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -560,14 +543,14 @@ Exit:
 //---------------------------------------------------------------------------
 
 tEplKernel EplNmtMnuSendNmtCommand(unsigned int uiNodeId_p,
-                                    tEplNmtCommand  NmtCommand_p)
+				   tEplNmtCommand NmtCommand_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    Ret = EplNmtMnuSendNmtCommandEx(uiNodeId_p, NmtCommand_p, NULL, 0);
+	Ret = EplNmtMnuSendNmtCommandEx(uiNodeId_p, NmtCommand_p, NULL, 0);
 
 //Exit:
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -586,68 +569,65 @@ tEplKernel      Ret = kEplSuccessful;
 //---------------------------------------------------------------------------
 
 tEplKernel EplNmtMnuTriggerStateChange(unsigned int uiNodeId_p,
-                                       tEplNmtNodeCommand  NodeCommand_p)
+				       tEplNmtNodeCommand NodeCommand_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplNmtMnuIntNodeEvent  NodeEvent;
-tEplObdSize         ObdSize;
-BYTE                bNmtState;
-WORD                wErrorCode = EPL_E_NO_ERROR;
+	tEplKernel Ret = kEplSuccessful;
+	tEplNmtMnuIntNodeEvent NodeEvent;
+	tEplObdSize ObdSize;
+	BYTE bNmtState;
+	WORD wErrorCode = EPL_E_NO_ERROR;
+
+	if ((uiNodeId_p == 0) || (uiNodeId_p >= EPL_C_ADR_BROADCAST)) {
+		Ret = kEplInvalidNodeId;
+		goto Exit;
+	}
+
+	switch (NodeCommand_p) {
+	case kEplNmtNodeCommandBoot:
+		{
+			NodeEvent = kEplNmtMnuIntNodeEventBoot;
+			break;
+		}
+
+	case kEplNmtNodeCommandConfOk:
+		{
+			NodeEvent = kEplNmtMnuIntNodeEventConfigured;
+			break;
+		}
+
+	case kEplNmtNodeCommandConfErr:
+		{
+			NodeEvent = kEplNmtMnuIntNodeEventError;
+			wErrorCode = EPL_E_NMT_BPO1_CF_VERIFY;
+			break;
+		}
+
+	case kEplNmtNodeCommandConfReset:
+		{
+			NodeEvent = kEplNmtMnuIntNodeEventExecReset;
+			break;
+		}
+
+	default:
+		{		// invalid node command
+			goto Exit;
+		}
+	}
+
+	// fetch current NMT state
+	ObdSize = 1;
+	Ret = EplObduReadEntry(0x1F8E, uiNodeId_p, &bNmtState, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	Ret = EplNmtMnuProcessInternalEvent(uiNodeId_p,
+					    (tEplNmtState) (bNmtState |
+							    EPL_NMT_TYPE_CS),
+					    wErrorCode, NodeEvent);
 
-    if ((uiNodeId_p == 0) || (uiNodeId_p >= EPL_C_ADR_BROADCAST))
-    {
-        Ret = kEplInvalidNodeId;
-        goto Exit;
-    }
-
-    switch (NodeCommand_p)
-    {
-        case kEplNmtNodeCommandBoot:
-        {
-            NodeEvent = kEplNmtMnuIntNodeEventBoot;
-            break;
-        }
-
-        case kEplNmtNodeCommandConfOk:
-        {
-            NodeEvent = kEplNmtMnuIntNodeEventConfigured;
-            break;
-        }
-
-        case kEplNmtNodeCommandConfErr:
-        {
-            NodeEvent = kEplNmtMnuIntNodeEventError;
-            wErrorCode = EPL_E_NMT_BPO1_CF_VERIFY;
-            break;
-        }
-
-        case kEplNmtNodeCommandConfReset:
-        {
-            NodeEvent = kEplNmtMnuIntNodeEventExecReset;
-            break;
-        }
-
-        default:
-        {   // invalid node command
-            goto Exit;
-        }
-    }
-
-    // fetch current NMT state
-    ObdSize = 1;
-    Ret = EplObduReadEntry(0x1F8E, uiNodeId_p, &bNmtState, &ObdSize);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    Ret = EplNmtMnuProcessInternalEvent(uiNodeId_p,
-                                        (tEplNmtState) (bNmtState | EPL_NMT_TYPE_CS),
-                                        wErrorCode,
-                                        NodeEvent);
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -665,14 +645,14 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplNmtMnuCbNmtStateChange(tEplEventNmtStateChange NmtStateChange_p)
+tEplKernel PUBLIC EplNmtMnuCbNmtStateChange(tEplEventNmtStateChange
+					    NmtStateChange_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    // do work which must be done in that state
-    switch (NmtStateChange_p.m_NewNmtState)
-    {
-        // EPL stack is not running
+	// do work which must be done in that state
+	switch (NmtStateChange_p.m_NewNmtState) {
+		// EPL stack is not running
 /*        case kEplNmtGsOff:
             break;
 
@@ -693,66 +673,61 @@ tEplKernel      Ret = kEplSuccessful;
             break;
         }
 */
-        // build the configuration with infos from OD
-        case kEplNmtGsResetConfiguration:
-        {
-        DWORD           dwTimeout;
-        tEplObdSize     ObdSize;
-
-            // read object 0x1F80 NMT_StartUp_U32
-            ObdSize = 4;
-            Ret = EplObduReadEntry(0x1F80, 0, &EplNmtMnuInstance_g.m_dwNmtStartup, &ObdSize);
-            if (Ret != kEplSuccessful)
-            {
-                break;
-            }
-
-            // compute StatusReqDelay = object 0x1006 * EPL_C_NMT_STATREQ_CYCLE
-            ObdSize = sizeof (dwTimeout);
-            Ret = EplObduReadEntry(0x1006, 0, &dwTimeout, &ObdSize);
-            if (Ret != kEplSuccessful)
-            {
-                break;
-            }
-            if (dwTimeout != 0L)
-            {
-                EplNmtMnuInstance_g.m_ulStatusRequestDelay = dwTimeout * EPL_C_NMT_STATREQ_CYCLE / 1000L;
-                if (EplNmtMnuInstance_g.m_ulStatusRequestDelay == 0L)
-                {
-                    EplNmtMnuInstance_g.m_ulStatusRequestDelay = 1L;    // at least 1 ms
-                }
-
-                // $$$ fetch and use MultiplexedCycleCount from OD
-                EplNmtMnuInstance_g.m_ulTimeoutCheckCom = dwTimeout * EPL_C_NMT_STATREQ_CYCLE / 1000L;
-                if (EplNmtMnuInstance_g.m_ulTimeoutCheckCom == 0L)
-                {
-                    EplNmtMnuInstance_g.m_ulTimeoutCheckCom = 1L;    // at least 1 ms
-                }
-            }
-
-            // fetch ReadyToOp Timeout from OD
-            ObdSize = sizeof (dwTimeout);
-            Ret = EplObduReadEntry(0x1F89, 5, &dwTimeout, &ObdSize);
-            if (Ret != kEplSuccessful)
-            {
-                break;
-            }
-            if (dwTimeout != 0L)
-            {
-                // convert [us] to [ms]
-                dwTimeout /= 1000L;
-                if (dwTimeout == 0L)
-                {
-                    dwTimeout = 1L;    // at least 1 ms
-                }
-                EplNmtMnuInstance_g.m_ulTimeoutReadyToOp = dwTimeout;
-            }
-            else
-            {
-                EplNmtMnuInstance_g.m_ulTimeoutReadyToOp = 0L;
-            }
-            break;
-        }
+		// build the configuration with infos from OD
+	case kEplNmtGsResetConfiguration:
+		{
+			DWORD dwTimeout;
+			tEplObdSize ObdSize;
+
+			// read object 0x1F80 NMT_StartUp_U32
+			ObdSize = 4;
+			Ret =
+			    EplObduReadEntry(0x1F80, 0,
+					     &EplNmtMnuInstance_g.
+					     m_dwNmtStartup, &ObdSize);
+			if (Ret != kEplSuccessful) {
+				break;
+			}
+			// compute StatusReqDelay = object 0x1006 * EPL_C_NMT_STATREQ_CYCLE
+			ObdSize = sizeof(dwTimeout);
+			Ret = EplObduReadEntry(0x1006, 0, &dwTimeout, &ObdSize);
+			if (Ret != kEplSuccessful) {
+				break;
+			}
+			if (dwTimeout != 0L) {
+				EplNmtMnuInstance_g.m_ulStatusRequestDelay =
+				    dwTimeout * EPL_C_NMT_STATREQ_CYCLE / 1000L;
+				if (EplNmtMnuInstance_g.
+				    m_ulStatusRequestDelay == 0L) {
+					EplNmtMnuInstance_g.m_ulStatusRequestDelay = 1L;	// at least 1 ms
+				}
+				// $$$ fetch and use MultiplexedCycleCount from OD
+				EplNmtMnuInstance_g.m_ulTimeoutCheckCom =
+				    dwTimeout * EPL_C_NMT_STATREQ_CYCLE / 1000L;
+				if (EplNmtMnuInstance_g.m_ulTimeoutCheckCom ==
+				    0L) {
+					EplNmtMnuInstance_g.m_ulTimeoutCheckCom = 1L;	// at least 1 ms
+				}
+			}
+			// fetch ReadyToOp Timeout from OD
+			ObdSize = sizeof(dwTimeout);
+			Ret = EplObduReadEntry(0x1F89, 5, &dwTimeout, &ObdSize);
+			if (Ret != kEplSuccessful) {
+				break;
+			}
+			if (dwTimeout != 0L) {
+				// convert [us] to [ms]
+				dwTimeout /= 1000L;
+				if (dwTimeout == 0L) {
+					dwTimeout = 1L;	// at least 1 ms
+				}
+				EplNmtMnuInstance_g.m_ulTimeoutReadyToOp =
+				    dwTimeout;
+			} else {
+				EplNmtMnuInstance_g.m_ulTimeoutReadyToOp = 0L;
+			}
+			break;
+		}
 /*
         //-----------------------------------------------------------
         // CN part of the state machine
@@ -801,142 +776,141 @@ tEplKernel      Ret = kEplSuccessful;
             break;
         }
 */
-        //-----------------------------------------------------------
-        // MN part of the state machine
-
-        // node listens for EPL-Frames and check timeout
-        case kEplNmtMsNotActive:
-        {
-            break;
-        }
+		//-----------------------------------------------------------
+		// MN part of the state machine
 
-        // node processes only async frames
-        case kEplNmtMsPreOperational1:
-        {
-        DWORD           dwTimeout;
-        tEplTimerArg    TimerArg;
-        tEplObdSize     ObdSize;
-        tEplEvent       Event;
-
-            // clear global flags, e.g. reenable boot process
-            EplNmtMnuInstance_g.m_wFlags = 0;
-
-            // reset IdentResponses and running IdentRequests and StatusRequests
-            Ret = EplIdentuReset();
-            Ret = EplStatusuReset();
-
-            // reset timers
-            Ret = EplNmtMnuReset();
-
-            // 2008/11/18 d.k. reset internal node info is not necessary,
-            //                 because timer flags are important and other
-            //                 things are reset by EplNmtMnuStartBootStep1().
+		// node listens for EPL-Frames and check timeout
+	case kEplNmtMsNotActive:
+		{
+			break;
+		}
+
+		// node processes only async frames
+	case kEplNmtMsPreOperational1:
+		{
+			DWORD dwTimeout;
+			tEplTimerArg TimerArg;
+			tEplObdSize ObdSize;
+			tEplEvent Event;
+
+			// clear global flags, e.g. reenable boot process
+			EplNmtMnuInstance_g.m_wFlags = 0;
+
+			// reset IdentResponses and running IdentRequests and StatusRequests
+			Ret = EplIdentuReset();
+			Ret = EplStatusuReset();
+
+			// reset timers
+			Ret = EplNmtMnuReset();
+
+			// 2008/11/18 d.k. reset internal node info is not necessary,
+			//                 because timer flags are important and other
+			//                 things are reset by EplNmtMnuStartBootStep1().
 /*
             EPL_MEMSET(EplNmtMnuInstance_g.m_aNodeInfo,
                        0,
                        sizeof (EplNmtMnuInstance_g.m_aNodeInfo));
 */
 
-            // inform DLL about NMT state change,
-            // so that it can clear the asynchonous queues and start the reduced cycle
-            Event.m_EventSink = kEplEventSinkDllk;
-            Event.m_EventType = kEplEventTypeDllkStartReducedCycle;
-            EPL_MEMSET(&Event.m_NetTime, 0x00, sizeof(Event.m_NetTime));
-            Event.m_pArg = NULL;
-            Event.m_uiSize = 0;
-            Ret = EplEventuPost(&Event);
-            if (Ret != kEplSuccessful)
-            {
-                break;
-            }
-
-            // reset all nodes
-            // d.k.: skip this step if was just done before, e.g. because of a ResetNode command from a diagnostic node
-            if (NmtStateChange_p.m_NmtEvent == kEplNmtEventTimerMsPreOp1)
-            {
-                BENCHMARK_MOD_07_TOGGLE(9);
-
-                EPL_NMTMNU_DBG_POST_TRACE_VALUE(0,
-                                                EPL_C_ADR_BROADCAST,
-                                                kEplNmtCmdResetNode);
-
-                Ret = EplNmtMnuSendNmtCommand(EPL_C_ADR_BROADCAST, kEplNmtCmdResetNode);
-                if (Ret != kEplSuccessful)
-                {
-                    break;
-                }
-            }
-            // start network scan
-            Ret = EplNmtMnuStartBootStep1();
-
-            // start timer for 0x1F89/2 MNTimeoutPreOp1_U32
-            ObdSize = sizeof (dwTimeout);
-            Ret = EplObduReadEntry(0x1F89, 2, &dwTimeout, &ObdSize);
-            if (Ret != kEplSuccessful)
-            {
-                break;
-            }
-            if (dwTimeout != 0L)
-            {
-                dwTimeout /= 1000L;
-                if (dwTimeout == 0L)
-                {
-                    dwTimeout = 1L; // at least 1 ms
-                }
-                TimerArg.m_EventSink = kEplEventSinkNmtMnu;
-                TimerArg.m_ulArg = 0;
-                Ret = EplTimeruModifyTimerMs(&EplNmtMnuInstance_g.m_TimerHdlNmtState, dwTimeout, TimerArg);
-            }
-            break;
-        }
-
-        // node processes isochronous and asynchronous frames
-        case kEplNmtMsPreOperational2:
-        {
-            // add identified CNs to isochronous phase
-            // send EnableReadyToOp to all identified CNs
-            Ret = EplNmtMnuStartBootStep2();
-
-            // wait for NMT state change of CNs
-            break;
-        }
-
-        // node should be configured und application is ready
-        case kEplNmtMsReadyToOperate:
-        {
-            // check if PRes of CNs are OK
-            // d.k. that means wait CycleLength * MultiplexCycleCount (i.e. start timer)
-            //      because Dllk checks PRes of CNs automatically in ReadyToOp
-            Ret = EplNmtMnuStartCheckCom();
-            break;
-        }
-
-        // normal work state
-        case kEplNmtMsOperational:
-        {
-            // send StartNode to CNs
-            // wait for NMT state change of CNs
-            Ret = EplNmtMnuStartNodes();
-            break;
-        }
+			// inform DLL about NMT state change,
+			// so that it can clear the asynchonous queues and start the reduced cycle
+			Event.m_EventSink = kEplEventSinkDllk;
+			Event.m_EventType = kEplEventTypeDllkStartReducedCycle;
+			EPL_MEMSET(&Event.m_NetTime, 0x00,
+				   sizeof(Event.m_NetTime));
+			Event.m_pArg = NULL;
+			Event.m_uiSize = 0;
+			Ret = EplEventuPost(&Event);
+			if (Ret != kEplSuccessful) {
+				break;
+			}
+			// reset all nodes
+			// d.k.: skip this step if was just done before, e.g. because of a ResetNode command from a diagnostic node
+			if (NmtStateChange_p.m_NmtEvent ==
+			    kEplNmtEventTimerMsPreOp1) {
+				BENCHMARK_MOD_07_TOGGLE(9);
+
+				EPL_NMTMNU_DBG_POST_TRACE_VALUE(0,
+								EPL_C_ADR_BROADCAST,
+								kEplNmtCmdResetNode);
+
+				Ret =
+				    EplNmtMnuSendNmtCommand(EPL_C_ADR_BROADCAST,
+							    kEplNmtCmdResetNode);
+				if (Ret != kEplSuccessful) {
+					break;
+				}
+			}
+			// start network scan
+			Ret = EplNmtMnuStartBootStep1();
+
+			// start timer for 0x1F89/2 MNTimeoutPreOp1_U32
+			ObdSize = sizeof(dwTimeout);
+			Ret = EplObduReadEntry(0x1F89, 2, &dwTimeout, &ObdSize);
+			if (Ret != kEplSuccessful) {
+				break;
+			}
+			if (dwTimeout != 0L) {
+				dwTimeout /= 1000L;
+				if (dwTimeout == 0L) {
+					dwTimeout = 1L;	// at least 1 ms
+				}
+				TimerArg.m_EventSink = kEplEventSinkNmtMnu;
+				TimerArg.m_ulArg = 0;
+				Ret =
+				    EplTimeruModifyTimerMs(&EplNmtMnuInstance_g.
+							   m_TimerHdlNmtState,
+							   dwTimeout, TimerArg);
+			}
+			break;
+		}
+
+		// node processes isochronous and asynchronous frames
+	case kEplNmtMsPreOperational2:
+		{
+			// add identified CNs to isochronous phase
+			// send EnableReadyToOp to all identified CNs
+			Ret = EplNmtMnuStartBootStep2();
+
+			// wait for NMT state change of CNs
+			break;
+		}
+
+		// node should be configured und application is ready
+	case kEplNmtMsReadyToOperate:
+		{
+			// check if PRes of CNs are OK
+			// d.k. that means wait CycleLength * MultiplexCycleCount (i.e. start timer)
+			//      because Dllk checks PRes of CNs automatically in ReadyToOp
+			Ret = EplNmtMnuStartCheckCom();
+			break;
+		}
+
+		// normal work state
+	case kEplNmtMsOperational:
+		{
+			// send StartNode to CNs
+			// wait for NMT state change of CNs
+			Ret = EplNmtMnuStartNodes();
+			break;
+		}
+
+		// no EPL cycle
+		// -> normal ethernet communication
+	case kEplNmtMsBasicEthernet:
+		{
+			break;
+		}
 
-        // no EPL cycle
-        // -> normal ethernet communication
-        case kEplNmtMsBasicEthernet:
-        {
-            break;
-        }
-
-        default:
-        {
+	default:
+		{
 //            TRACE0("EplNmtMnuCbNmtStateChange(): unhandled NMT state\n");
-        }
-    }
+		}
+	}
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuCbCheckEvent
@@ -956,12 +930,11 @@ tEplKernel      Ret = kEplSuccessful;
 
 tEplKernel PUBLIC EplNmtMnuCbCheckEvent(tEplNmtEvent NmtEvent_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtuProcessEvent
@@ -976,52 +949,58 @@ tEplKernel      Ret = kEplSuccessful;
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT tEplKernel PUBLIC EplNmtMnuProcessEvent(
-            tEplEvent* pEvent_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplNmtMnuProcessEvent(tEplEvent * pEvent_p)
 {
-tEplKernel      Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
-
-    // process event
-    switch(pEvent_p->m_EventType)
-    {
-        // timer event
-        case kEplEventTypeTimer:
-        {
-        tEplTimerEventArg*  pTimerEventArg = (tEplTimerEventArg*)pEvent_p->m_pArg;
-        unsigned int        uiNodeId;
+	Ret = kEplSuccessful;
 
-            uiNodeId = (unsigned int) (pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_NODE_MASK);
-            if (uiNodeId != 0)
-            {
-            tEplObdSize         ObdSize;
-            BYTE                bNmtState;
-            tEplNmtMnuNodeInfo* pNodeInfo;
-
-                pNodeInfo = EPL_NMTMNU_GET_NODEINFO(uiNodeId);
-
-                ObdSize = 1;
-                Ret = EplObduReadEntry(0x1F8E, uiNodeId, &bNmtState, &ObdSize);
-                if (Ret != kEplSuccessful)
-                {
-                    break;
-                }
-
-                if ((pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_IDENTREQ) != 0L)
-                {
-                    if ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ)
-                        != (pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR))
-                    {   // this is an old (already deleted or modified) timer
-                        // but not the current timer
-                        // so discard it
-                        EPL_NMTMNU_DBG_POST_TRACE_VALUE(kEplNmtMnuIntNodeEventTimerIdentReq,
-                                                        uiNodeId,
-                                                        ((pNodeInfo->m_NodeState << 8)
-                                                         | 0xFF));
+	// process event
+	switch (pEvent_p->m_EventType) {
+		// timer event
+	case kEplEventTypeTimer:
+		{
+			tEplTimerEventArg *pTimerEventArg =
+			    (tEplTimerEventArg *) pEvent_p->m_pArg;
+			unsigned int uiNodeId;
+
+			uiNodeId =
+			    (unsigned int)(pTimerEventArg->
+					   m_ulArg &
+					   EPL_NMTMNU_TIMERARG_NODE_MASK);
+			if (uiNodeId != 0) {
+				tEplObdSize ObdSize;
+				BYTE bNmtState;
+				tEplNmtMnuNodeInfo *pNodeInfo;
+
+				pNodeInfo = EPL_NMTMNU_GET_NODEINFO(uiNodeId);
+
+				ObdSize = 1;
+				Ret =
+				    EplObduReadEntry(0x1F8E, uiNodeId,
+						     &bNmtState, &ObdSize);
+				if (Ret != kEplSuccessful) {
+					break;
+				}
+
+				if ((pTimerEventArg->
+				     m_ulArg & EPL_NMTMNU_TIMERARG_IDENTREQ) !=
+				    0L) {
+					if ((pNodeInfo->
+					     m_wFlags &
+					     EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ)
+					    != (pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR)) {	// this is an old (already deleted or modified) timer
+						// but not the current timer
+						// so discard it
+						EPL_NMTMNU_DBG_POST_TRACE_VALUE
+						    (kEplNmtMnuIntNodeEventTimerIdentReq,
+						     uiNodeId,
+						     ((pNodeInfo->
+						       m_NodeState << 8)
+						      | 0xFF));
 
-                        break;
-                    }
+						break;
+					}
 /*
                     EPL_NMTMNU_DBG_POST_TRACE_VALUE(kEplNmtMnuIntNodeEventTimerIdentReq,
                                                     uiNodeId,
@@ -1030,26 +1009,33 @@ tEplKernel      Ret;
                                                      | ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ) >> 6)
                                                      | ((pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR) >> 8)));
 */
-                    Ret = EplNmtMnuProcessInternalEvent(uiNodeId,
-                                                        (tEplNmtState) (bNmtState | EPL_NMT_TYPE_CS),
-                                                        EPL_E_NO_ERROR,
-                                                        kEplNmtMnuIntNodeEventTimerIdentReq);
-                }
-
-                else if ((pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_STATREQ) != 0L)
-                {
-                    if ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ)
-                        != (pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR))
-                    {   // this is an old (already deleted or modified) timer
-                        // but not the current timer
-                        // so discard it
-                        EPL_NMTMNU_DBG_POST_TRACE_VALUE(kEplNmtMnuIntNodeEventTimerStatReq,
-                                                        uiNodeId,
-                                                        ((pNodeInfo->m_NodeState << 8)
-                                                         | 0xFF));
+					Ret =
+					    EplNmtMnuProcessInternalEvent
+					    (uiNodeId,
+					     (tEplNmtState) (bNmtState |
+							     EPL_NMT_TYPE_CS),
+					     EPL_E_NO_ERROR,
+					     kEplNmtMnuIntNodeEventTimerIdentReq);
+				}
+
+				else if ((pTimerEventArg->
+					  m_ulArg & EPL_NMTMNU_TIMERARG_STATREQ)
+					 != 0L) {
+					if ((pNodeInfo->
+					     m_wFlags &
+					     EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ)
+					    != (pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR)) {	// this is an old (already deleted or modified) timer
+						// but not the current timer
+						// so discard it
+						EPL_NMTMNU_DBG_POST_TRACE_VALUE
+						    (kEplNmtMnuIntNodeEventTimerStatReq,
+						     uiNodeId,
+						     ((pNodeInfo->
+						       m_NodeState << 8)
+						      | 0xFF));
 
-                        break;
-                    }
+						break;
+					}
 /*
                     EPL_NMTMNU_DBG_POST_TRACE_VALUE(kEplNmtMnuIntNodeEventTimerStatReq,
                                                     uiNodeId,
@@ -1058,26 +1044,34 @@ tEplKernel      Ret;
                                                      | ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ) >> 6)
                                                      | ((pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR) >> 8)));
 */
-                    Ret = EplNmtMnuProcessInternalEvent(uiNodeId,
-                                                        (tEplNmtState) (bNmtState | EPL_NMT_TYPE_CS),
-                                                        EPL_E_NO_ERROR,
-                                                        kEplNmtMnuIntNodeEventTimerStatReq);
-                }
-
-                else if ((pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_STATE_MON) != 0L)
-                {
-                    if ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ)
-                        != (pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR))
-                    {   // this is an old (already deleted or modified) timer
-                        // but not the current timer
-                        // so discard it
-                        EPL_NMTMNU_DBG_POST_TRACE_VALUE(kEplNmtMnuIntNodeEventTimerStateMon,
-                                                        uiNodeId,
-                                                        ((pNodeInfo->m_NodeState << 8)
-                                                         | 0xFF));
+					Ret =
+					    EplNmtMnuProcessInternalEvent
+					    (uiNodeId,
+					     (tEplNmtState) (bNmtState |
+							     EPL_NMT_TYPE_CS),
+					     EPL_E_NO_ERROR,
+					     kEplNmtMnuIntNodeEventTimerStatReq);
+				}
+
+				else if ((pTimerEventArg->
+					  m_ulArg &
+					  EPL_NMTMNU_TIMERARG_STATE_MON) !=
+					 0L) {
+					if ((pNodeInfo->
+					     m_wFlags &
+					     EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ)
+					    != (pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR)) {	// this is an old (already deleted or modified) timer
+						// but not the current timer
+						// so discard it
+						EPL_NMTMNU_DBG_POST_TRACE_VALUE
+						    (kEplNmtMnuIntNodeEventTimerStateMon,
+						     uiNodeId,
+						     ((pNodeInfo->
+						       m_NodeState << 8)
+						      | 0xFF));
 
-                        break;
-                    }
+						break;
+					}
 /*
                     EPL_NMTMNU_DBG_POST_TRACE_VALUE(kEplNmtMnuIntNodeEventTimerStatReq,
                                                     uiNodeId,
@@ -1086,26 +1080,33 @@ tEplKernel      Ret;
                                                      | ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ) >> 6)
                                                      | ((pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR) >> 8)));
 */
-                    Ret = EplNmtMnuProcessInternalEvent(uiNodeId,
-                                                        (tEplNmtState) (bNmtState | EPL_NMT_TYPE_CS),
-                                                        EPL_E_NO_ERROR,
-                                                        kEplNmtMnuIntNodeEventTimerStateMon);
-                }
-
-                else if ((pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_LONGER) != 0L)
-                {
-                    if ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_LONGER)
-                        != (pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_LO))
-                    {   // this is an old (already deleted or modified) timer
-                        // but not the current timer
-                        // so discard it
-                        EPL_NMTMNU_DBG_POST_TRACE_VALUE(kEplNmtMnuIntNodeEventTimerLonger,
-                                                        uiNodeId,
-                                                        ((pNodeInfo->m_NodeState << 8)
-                                                         | 0xFF));
+					Ret =
+					    EplNmtMnuProcessInternalEvent
+					    (uiNodeId,
+					     (tEplNmtState) (bNmtState |
+							     EPL_NMT_TYPE_CS),
+					     EPL_E_NO_ERROR,
+					     kEplNmtMnuIntNodeEventTimerStateMon);
+				}
+
+				else if ((pTimerEventArg->
+					  m_ulArg & EPL_NMTMNU_TIMERARG_LONGER)
+					 != 0L) {
+					if ((pNodeInfo->
+					     m_wFlags &
+					     EPL_NMTMNU_NODE_FLAG_COUNT_LONGER)
+					    != (pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_LO)) {	// this is an old (already deleted or modified) timer
+						// but not the current timer
+						// so discard it
+						EPL_NMTMNU_DBG_POST_TRACE_VALUE
+						    (kEplNmtMnuIntNodeEventTimerLonger,
+						     uiNodeId,
+						     ((pNodeInfo->
+						       m_NodeState << 8)
+						      | 0xFF));
 
-                        break;
-                    }
+						break;
+					}
 /*
                     EPL_NMTMNU_DBG_POST_TRACE_VALUE(kEplNmtMnuIntNodeEventTimerLonger,
                                                     uiNodeId,
@@ -1114,117 +1115,134 @@ tEplKernel      Ret;
                                                      | ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_LONGER) >> 6)
                                                      | ((pTimerEventArg->m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_LO) >> 8)));
 */
-                    Ret = EplNmtMnuProcessInternalEvent(uiNodeId,
-                                                        (tEplNmtState) (bNmtState | EPL_NMT_TYPE_CS),
-                                                        EPL_E_NO_ERROR,
-                                                        kEplNmtMnuIntNodeEventTimerLonger);
-                }
-
-            }
-            else
-            {   // global timer event
-            }
-            break;
-        }
-
-        case kEplEventTypeHeartbeat:
-        {
-        tEplHeartbeatEvent* pHeartbeatEvent = (tEplHeartbeatEvent*)pEvent_p->m_pArg;
-
-            Ret = EplNmtMnuProcessInternalEvent(pHeartbeatEvent->m_uiNodeId,
-                                                pHeartbeatEvent->m_NmtState,
-                                                pHeartbeatEvent->m_wErrorCode,
-                                                kEplNmtMnuIntNodeEventHeartbeat);
-            break;
-        }
-
-        case kEplEventTypeNmtMnuNmtCmdSent:
-        {
-        tEplFrame* pFrame = (tEplFrame*)pEvent_p->m_pArg;
-        unsigned int        uiNodeId;
-        tEplNmtCommand      NmtCommand;
-        BYTE                bNmtState;
-
-            uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bDstNodeId);
-            NmtCommand = (tEplNmtCommand) AmiGetByteFromLe(&pFrame->m_Data.m_Asnd.m_Payload.m_NmtCommandService.m_le_bNmtCommandId);
-
-            switch (NmtCommand)
-            {
-                case kEplNmtCmdStartNode:
-                    bNmtState = (BYTE) (kEplNmtCsOperational & 0xFF);
-                    break;
-
-                case kEplNmtCmdStopNode:
-                    bNmtState = (BYTE) (kEplNmtCsStopped & 0xFF);
-                    break;
-
-                case kEplNmtCmdEnterPreOperational2:
-                    bNmtState = (BYTE) (kEplNmtCsPreOperational2 & 0xFF);
-                    break;
-
-                case kEplNmtCmdEnableReadyToOperate:
-                    // d.k. do not change expected node state, because of DS 1.0.0 7.3.1.2.1 Plain NMT State Command
-                    //      and because node may not change NMT state within EPL_C_NMT_STATE_TOLERANCE
-                    bNmtState = (BYTE) (kEplNmtCsPreOperational2 & 0xFF);
-                    break;
-
-                case kEplNmtCmdResetNode:
-                case kEplNmtCmdResetCommunication:
-                case kEplNmtCmdResetConfiguration:
-                case kEplNmtCmdSwReset:
-                    bNmtState = (BYTE) (kEplNmtCsNotActive & 0xFF);
-                    // EplNmtMnuProcessInternalEvent() sets internal node state to kEplNmtMnuNodeStateUnknown
-                    // after next unresponded IdentRequest/StatusRequest
-                    break;
-
-                default:
-                    goto Exit;
-            }
-
-            // process as internal event which update expected NMT state in OD
-            if (uiNodeId != EPL_C_ADR_BROADCAST)
-            {
-                Ret = EplNmtMnuProcessInternalEvent(uiNodeId,
-                                                    (tEplNmtState) (bNmtState | EPL_NMT_TYPE_CS),
-                                                    0,
-                                                    kEplNmtMnuIntNodeEventNmtCmdSent);
-
-            }
-            else
-            {   // process internal event for all active nodes (except myself)
-
-                for (uiNodeId = 1; uiNodeId <= tabentries(EplNmtMnuInstance_g.m_aNodeInfo); uiNodeId++)
-                {
-                    if ((EPL_NMTMNU_GET_NODEINFO(uiNodeId)->m_dwNodeCfg & (EPL_NODEASSIGN_NODE_IS_CN | EPL_NODEASSIGN_NODE_EXISTS)) != 0)
-                    {
-                        Ret = EplNmtMnuProcessInternalEvent(uiNodeId,
-                                                            (tEplNmtState) (bNmtState | EPL_NMT_TYPE_CS),
-                                                            0,
-                                                            kEplNmtMnuIntNodeEventNmtCmdSent);
-
-                        if (Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                    }
-                }
-            }
-
-            break;
-        }
+					Ret =
+					    EplNmtMnuProcessInternalEvent
+					    (uiNodeId,
+					     (tEplNmtState) (bNmtState |
+							     EPL_NMT_TYPE_CS),
+					     EPL_E_NO_ERROR,
+					     kEplNmtMnuIntNodeEventTimerLonger);
+				}
+
+			} else {	// global timer event
+			}
+			break;
+		}
+
+	case kEplEventTypeHeartbeat:
+		{
+			tEplHeartbeatEvent *pHeartbeatEvent =
+			    (tEplHeartbeatEvent *) pEvent_p->m_pArg;
+
+			Ret =
+			    EplNmtMnuProcessInternalEvent(pHeartbeatEvent->
+							  m_uiNodeId,
+							  pHeartbeatEvent->
+							  m_NmtState,
+							  pHeartbeatEvent->
+							  m_wErrorCode,
+							  kEplNmtMnuIntNodeEventHeartbeat);
+			break;
+		}
+
+	case kEplEventTypeNmtMnuNmtCmdSent:
+		{
+			tEplFrame *pFrame = (tEplFrame *) pEvent_p->m_pArg;
+			unsigned int uiNodeId;
+			tEplNmtCommand NmtCommand;
+			BYTE bNmtState;
+
+			uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bDstNodeId);
+			NmtCommand =
+			    (tEplNmtCommand) AmiGetByteFromLe(&pFrame->m_Data.
+							      m_Asnd.m_Payload.
+							      m_NmtCommandService.
+							      m_le_bNmtCommandId);
+
+			switch (NmtCommand) {
+			case kEplNmtCmdStartNode:
+				bNmtState =
+				    (BYTE) (kEplNmtCsOperational & 0xFF);
+				break;
+
+			case kEplNmtCmdStopNode:
+				bNmtState = (BYTE) (kEplNmtCsStopped & 0xFF);
+				break;
+
+			case kEplNmtCmdEnterPreOperational2:
+				bNmtState =
+				    (BYTE) (kEplNmtCsPreOperational2 & 0xFF);
+				break;
+
+			case kEplNmtCmdEnableReadyToOperate:
+				// d.k. do not change expected node state, because of DS 1.0.0 7.3.1.2.1 Plain NMT State Command
+				//      and because node may not change NMT state within EPL_C_NMT_STATE_TOLERANCE
+				bNmtState =
+				    (BYTE) (kEplNmtCsPreOperational2 & 0xFF);
+				break;
+
+			case kEplNmtCmdResetNode:
+			case kEplNmtCmdResetCommunication:
+			case kEplNmtCmdResetConfiguration:
+			case kEplNmtCmdSwReset:
+				bNmtState = (BYTE) (kEplNmtCsNotActive & 0xFF);
+				// EplNmtMnuProcessInternalEvent() sets internal node state to kEplNmtMnuNodeStateUnknown
+				// after next unresponded IdentRequest/StatusRequest
+				break;
+
+			default:
+				goto Exit;
+			}
+
+			// process as internal event which update expected NMT state in OD
+			if (uiNodeId != EPL_C_ADR_BROADCAST) {
+				Ret = EplNmtMnuProcessInternalEvent(uiNodeId,
+								    (tEplNmtState)
+								    (bNmtState |
+								     EPL_NMT_TYPE_CS),
+								    0,
+								    kEplNmtMnuIntNodeEventNmtCmdSent);
+
+			} else {	// process internal event for all active nodes (except myself)
+
+				for (uiNodeId = 1;
+				     uiNodeId <=
+				     tabentries(EplNmtMnuInstance_g.
+						m_aNodeInfo); uiNodeId++) {
+					if ((EPL_NMTMNU_GET_NODEINFO(uiNodeId)->
+					     m_dwNodeCfg &
+					     (EPL_NODEASSIGN_NODE_IS_CN |
+					      EPL_NODEASSIGN_NODE_EXISTS)) !=
+					    0) {
+						Ret =
+						    EplNmtMnuProcessInternalEvent
+						    (uiNodeId,
+						     (tEplNmtState) (bNmtState |
+								     EPL_NMT_TYPE_CS),
+						     0,
+						     kEplNmtMnuIntNodeEventNmtCmdSent);
+
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+					}
+				}
+			}
+
+			break;
+		}
+
+	default:
+		{
+			Ret = kEplNmtInvalidEvent;
+		}
 
-        default:
-        {
-            Ret = kEplNmtInvalidEvent;
-        }
-
-    }
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuGetRunningTimerStatReq
@@ -1240,29 +1258,29 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplNmtMnuGetDiagnosticInfo(unsigned int* puiMandatorySlaveCount_p,
-                                             unsigned int* puiSignalSlaveCount_p,
-                                             WORD* pwFlags_p)
-{
-tEplKernel      Ret = kEplSuccessful;
-
-    if ((puiMandatorySlaveCount_p == NULL)
-        || (puiSignalSlaveCount_p == NULL)
-        || (pwFlags_p == NULL))
-    {
-        Ret = kEplNmtInvalidParam;
-        goto Exit;
-    }
-
-    *puiMandatorySlaveCount_p = EplNmtMnuInstance_g.m_uiMandatorySlaveCount;
-    *puiSignalSlaveCount_p = EplNmtMnuInstance_g.m_uiSignalSlaveCount;
-    *pwFlags_p = EplNmtMnuInstance_g.m_wFlags;
+tEplKernel PUBLIC EplNmtMnuGetDiagnosticInfo(unsigned int
+					     *puiMandatorySlaveCount_p,
+					     unsigned int
+					     *puiSignalSlaveCount_p,
+					     WORD * pwFlags_p)
+{
+	tEplKernel Ret = kEplSuccessful;
+
+	if ((puiMandatorySlaveCount_p == NULL)
+	    || (puiSignalSlaveCount_p == NULL)
+	    || (pwFlags_p == NULL)) {
+		Ret = kEplNmtInvalidParam;
+		goto Exit;
+	}
+
+	*puiMandatorySlaveCount_p = EplNmtMnuInstance_g.m_uiMandatorySlaveCount;
+	*puiSignalSlaveCount_p = EplNmtMnuInstance_g.m_uiSignalSlaveCount;
+	*pwFlags_p = EplNmtMnuInstance_g.m_wFlags;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuGetRunningTimerStatReq
@@ -1331,13 +1349,12 @@ Exit:
 
 static tEplKernel PUBLIC EplNmtMnuCbNmtRequest(tEplFrameInfo * pFrameInfo_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    // $$$ perform NMTRequest
-    return Ret;
+	// $$$ perform NMTRequest
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuCbIdentResponse
@@ -1354,55 +1371,50 @@ tEplKernel      Ret = kEplSuccessful;
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC EplNmtMnuCbIdentResponse(
-                                  unsigned int        uiNodeId_p,
-                                  tEplIdentResponse* pIdentResponse_p)
-{
-tEplKernel      Ret = kEplSuccessful;
-
-    if (pIdentResponse_p == NULL)
-    {   // node did not answer
-        Ret = EplNmtMnuProcessInternalEvent(uiNodeId_p,
-                                            kEplNmtCsNotActive,
-                                            EPL_E_NMT_NO_IDENT_RES, // was EPL_E_NO_ERROR
-                                            kEplNmtMnuIntNodeEventNoIdentResponse);
-    }
-    else
-    {   // node answered IdentRequest
-    tEplObdSize ObdSize;
-    DWORD       dwDevType;
-    WORD        wErrorCode = EPL_E_NO_ERROR;
-    tEplNmtState NmtState = (tEplNmtState) (AmiGetByteFromLe(&pIdentResponse_p->m_le_bNmtStatus) | EPL_NMT_TYPE_CS);
-
-        // check IdentResponse $$$ move to ProcessIntern, because this function may be called also if CN
-
-        // check DeviceType (0x1F84)
-        ObdSize = 4;
-        Ret = EplObduReadEntry(0x1F84, uiNodeId_p, &dwDevType, &ObdSize);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        if (dwDevType != 0L)
-        {   // actually compare it with DeviceType from IdentResponse
-            if (AmiGetDwordFromLe(&pIdentResponse_p->m_le_dwDeviceType) != dwDevType)
-            {   // wrong DeviceType
-                NmtState = kEplNmtCsNotActive;
-                wErrorCode = EPL_E_NMT_BPO1_DEVICE_TYPE;
-            }
-        }
-
-        Ret = EplNmtMnuProcessInternalEvent(uiNodeId_p,
-                                            NmtState,
-                                            wErrorCode,
-                                            kEplNmtMnuIntNodeEventIdentResponse);
-    }
+static tEplKernel PUBLIC EplNmtMnuCbIdentResponse(unsigned int uiNodeId_p,
+						  tEplIdentResponse *
+						  pIdentResponse_p)
+{
+	tEplKernel Ret = kEplSuccessful;
+
+	if (pIdentResponse_p == NULL) {	// node did not answer
+		Ret = EplNmtMnuProcessInternalEvent(uiNodeId_p, kEplNmtCsNotActive, EPL_E_NMT_NO_IDENT_RES,	// was EPL_E_NO_ERROR
+						    kEplNmtMnuIntNodeEventNoIdentResponse);
+	} else {		// node answered IdentRequest
+		tEplObdSize ObdSize;
+		DWORD dwDevType;
+		WORD wErrorCode = EPL_E_NO_ERROR;
+		tEplNmtState NmtState =
+		    (tEplNmtState) (AmiGetByteFromLe
+				    (&pIdentResponse_p->
+				     m_le_bNmtStatus) | EPL_NMT_TYPE_CS);
+
+		// check IdentResponse $$$ move to ProcessIntern, because this function may be called also if CN
+
+		// check DeviceType (0x1F84)
+		ObdSize = 4;
+		Ret =
+		    EplObduReadEntry(0x1F84, uiNodeId_p, &dwDevType, &ObdSize);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		if (dwDevType != 0L) {	// actually compare it with DeviceType from IdentResponse
+			if (AmiGetDwordFromLe(&pIdentResponse_p->m_le_dwDeviceType) != dwDevType) {	// wrong DeviceType
+				NmtState = kEplNmtCsNotActive;
+				wErrorCode = EPL_E_NMT_BPO1_DEVICE_TYPE;
+			}
+		}
+
+		Ret = EplNmtMnuProcessInternalEvent(uiNodeId_p,
+						    NmtState,
+						    wErrorCode,
+						    kEplNmtMnuIntNodeEventIdentResponse);
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuCbStatusResponse
@@ -1419,31 +1431,29 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC EplNmtMnuCbStatusResponse(
-                                  unsigned int        uiNodeId_p,
-                                  tEplStatusResponse* pStatusResponse_p)
-{
-tEplKernel      Ret = kEplSuccessful;
-
-    if (pStatusResponse_p == NULL)
-    {   // node did not answer
-        Ret = EplNmtMnuProcessInternalEvent(uiNodeId_p,
-                                            kEplNmtCsNotActive,
-                                            EPL_E_NMT_NO_STATUS_RES, // was EPL_E_NO_ERROR
-                                            kEplNmtMnuIntNodeEventNoStatusResponse);
-    }
-    else
-    {   // node answered StatusRequest
-        Ret = EplNmtMnuProcessInternalEvent(uiNodeId_p,
-                                            (tEplNmtState) (AmiGetByteFromLe(&pStatusResponse_p->m_le_bNmtStatus) | EPL_NMT_TYPE_CS),
-                                            EPL_E_NO_ERROR,
-                                            kEplNmtMnuIntNodeEventStatusResponse);
-    }
+static tEplKernel PUBLIC EplNmtMnuCbStatusResponse(unsigned int uiNodeId_p,
+						   tEplStatusResponse *
+						   pStatusResponse_p)
+{
+	tEplKernel Ret = kEplSuccessful;
+
+	if (pStatusResponse_p == NULL) {	// node did not answer
+		Ret = EplNmtMnuProcessInternalEvent(uiNodeId_p, kEplNmtCsNotActive, EPL_E_NMT_NO_STATUS_RES,	// was EPL_E_NO_ERROR
+						    kEplNmtMnuIntNodeEventNoStatusResponse);
+	} else {		// node answered StatusRequest
+		Ret = EplNmtMnuProcessInternalEvent(uiNodeId_p,
+						    (tEplNmtState)
+						    (AmiGetByteFromLe
+						     (&pStatusResponse_p->
+						      m_le_bNmtStatus) |
+						     EPL_NMT_TYPE_CS),
+						    EPL_E_NO_ERROR,
+						    kEplNmtMnuIntNodeEventStatusResponse);
+	}
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuStartBootStep1
@@ -1460,83 +1470,82 @@ tEplKernel      Ret = kEplSuccessful;
 
 static tEplKernel EplNmtMnuStartBootStep1(void)
 {
-tEplKernel      Ret = kEplSuccessful;
-unsigned int    uiSubIndex;
-unsigned int    uiLocalNodeId;
-DWORD           dwNodeCfg;
-tEplObdSize     ObdSize;
-
-    // $$$ d.k.: save current time for 0x1F89/2 MNTimeoutPreOp1_U32
-
-    // start network scan
-    EplNmtMnuInstance_g.m_uiMandatorySlaveCount = 0;
-    EplNmtMnuInstance_g.m_uiSignalSlaveCount = 0;
-    // check 0x1F81
-    uiLocalNodeId = EplObduGetNodeId();
-    for (uiSubIndex = 1; uiSubIndex <= 254; uiSubIndex++)
-    {
-        ObdSize = 4;
-        Ret = EplObduReadEntry(0x1F81, uiSubIndex, &dwNodeCfg, &ObdSize);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        if (uiSubIndex != uiLocalNodeId)
-        {
-            // reset flags "not scanned" and "isochronous"
-            EPL_NMTMNU_GET_NODEINFO(uiSubIndex)->m_wFlags &= ~(EPL_NMTMNU_NODE_FLAG_ISOCHRON | EPL_NMTMNU_NODE_FLAG_NOT_SCANNED);
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiSubIndex;
+	unsigned int uiLocalNodeId;
+	DWORD dwNodeCfg;
+	tEplObdSize ObdSize;
+
+	// $$$ d.k.: save current time for 0x1F89/2 MNTimeoutPreOp1_U32
+
+	// start network scan
+	EplNmtMnuInstance_g.m_uiMandatorySlaveCount = 0;
+	EplNmtMnuInstance_g.m_uiSignalSlaveCount = 0;
+	// check 0x1F81
+	uiLocalNodeId = EplObduGetNodeId();
+	for (uiSubIndex = 1; uiSubIndex <= 254; uiSubIndex++) {
+		ObdSize = 4;
+		Ret =
+		    EplObduReadEntry(0x1F81, uiSubIndex, &dwNodeCfg, &ObdSize);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		if (uiSubIndex != uiLocalNodeId) {
+			// reset flags "not scanned" and "isochronous"
+			EPL_NMTMNU_GET_NODEINFO(uiSubIndex)->m_wFlags &=
+			    ~(EPL_NMTMNU_NODE_FLAG_ISOCHRON |
+			      EPL_NMTMNU_NODE_FLAG_NOT_SCANNED);
+
+			if (uiSubIndex == EPL_C_ADR_DIAG_DEF_NODE_ID) {	// diagnostic node must be scanned by MN in any case
+				dwNodeCfg |=
+				    (EPL_NODEASSIGN_NODE_IS_CN |
+				     EPL_NODEASSIGN_NODE_EXISTS);
+				// and it must be isochronously accessed
+				dwNodeCfg &= ~EPL_NODEASSIGN_ASYNCONLY_NODE;
+			}
+			// save node config in local node info structure
+			EPL_NMTMNU_GET_NODEINFO(uiSubIndex)->m_dwNodeCfg =
+			    dwNodeCfg;
+			EPL_NMTMNU_GET_NODEINFO(uiSubIndex)->m_NodeState =
+			    kEplNmtMnuNodeStateUnknown;
+
+			if ((dwNodeCfg & (EPL_NODEASSIGN_NODE_IS_CN | EPL_NODEASSIGN_NODE_EXISTS)) != 0) {	// node is configured as CN
+				// identify the node
+				Ret =
+				    EplIdentuRequestIdentResponse(uiSubIndex,
+								  EplNmtMnuCbIdentResponse);
+				if (Ret != kEplSuccessful) {
+					goto Exit;
+				}
+				// set flag "not scanned"
+				EPL_NMTMNU_GET_NODEINFO(uiSubIndex)->m_wFlags |=
+				    EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
+				EplNmtMnuInstance_g.m_uiSignalSlaveCount++;
+				// signal slave counter shall be decremented if IdentRequest was sent once to a CN
+
+				if ((dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0) {	// node is a mandatory CN
+					EplNmtMnuInstance_g.
+					    m_uiMandatorySlaveCount++;
+					// mandatory slave counter shall be decremented if mandatory CN was configured successfully
+				}
+			}
+		} else {	// subindex of MN
+			if ((dwNodeCfg & (EPL_NODEASSIGN_MN_PRES | EPL_NODEASSIGN_NODE_EXISTS)) != 0) {	// MN shall send PRes
+				tEplDllNodeInfo DllNodeInfo;
+
+				EPL_MEMSET(&DllNodeInfo, 0,
+					   sizeof(DllNodeInfo));
+				DllNodeInfo.m_uiNodeId = uiLocalNodeId;
+
+				Ret = EplDlluCalAddNode(&DllNodeInfo);
+			}
+		}
+	}
 
-            if (uiSubIndex == EPL_C_ADR_DIAG_DEF_NODE_ID)
-            {   // diagnostic node must be scanned by MN in any case
-                dwNodeCfg |= (EPL_NODEASSIGN_NODE_IS_CN | EPL_NODEASSIGN_NODE_EXISTS);
-                // and it must be isochronously accessed
-                dwNodeCfg &= ~EPL_NODEASSIGN_ASYNCONLY_NODE;
-            }
-
-            // save node config in local node info structure
-            EPL_NMTMNU_GET_NODEINFO(uiSubIndex)->m_dwNodeCfg = dwNodeCfg;
-            EPL_NMTMNU_GET_NODEINFO(uiSubIndex)->m_NodeState = kEplNmtMnuNodeStateUnknown;
-
-            if ((dwNodeCfg & (EPL_NODEASSIGN_NODE_IS_CN | EPL_NODEASSIGN_NODE_EXISTS)) != 0)
-            {   // node is configured as CN
-                // identify the node
-                Ret = EplIdentuRequestIdentResponse(uiSubIndex, EplNmtMnuCbIdentResponse);
-                if (Ret != kEplSuccessful)
-                {
-                    goto Exit;
-                }
-
-                // set flag "not scanned"
-                EPL_NMTMNU_GET_NODEINFO(uiSubIndex)->m_wFlags |= EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
-                EplNmtMnuInstance_g.m_uiSignalSlaveCount++;
-                // signal slave counter shall be decremented if IdentRequest was sent once to a CN
-
-                if ((dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0)
-                {   // node is a mandatory CN
-                    EplNmtMnuInstance_g.m_uiMandatorySlaveCount++;
-                    // mandatory slave counter shall be decremented if mandatory CN was configured successfully
-                }
-            }
-        }
-        else
-        {   // subindex of MN
-            if ((dwNodeCfg & (EPL_NODEASSIGN_MN_PRES | EPL_NODEASSIGN_NODE_EXISTS)) != 0)
-            {   // MN shall send PRes
-            tEplDllNodeInfo DllNodeInfo;
-
-                EPL_MEMSET(&DllNodeInfo, 0, sizeof (DllNodeInfo));
-                DllNodeInfo.m_uiNodeId = uiLocalNodeId;
-
-                Ret = EplDlluCalAddNode(&DllNodeInfo);
-            }
-        }
-    }
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuStartBootStep2
@@ -1555,51 +1564,48 @@ Exit:
 
 static tEplKernel EplNmtMnuStartBootStep2(void)
 {
-tEplKernel      Ret = kEplSuccessful;
-unsigned int    uiIndex;
-tEplNmtMnuNodeInfo* pNodeInfo;
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiIndex;
+	tEplNmtMnuNodeInfo *pNodeInfo;
+
+	if ((EplNmtMnuInstance_g.m_wFlags & EPL_NMTMNU_FLAG_HALTED) == 0) {	// boot process is not halted
+		// add nodes to isochronous phase and send NMT EnableReadyToOp
+		EplNmtMnuInstance_g.m_uiMandatorySlaveCount = 0;
+		EplNmtMnuInstance_g.m_uiSignalSlaveCount = 0;
+		// reset flag that application was informed about possible state change
+		EplNmtMnuInstance_g.m_wFlags &= ~EPL_NMTMNU_FLAG_APP_INFORMED;
+
+		pNodeInfo = EplNmtMnuInstance_g.m_aNodeInfo;
+		for (uiIndex = 1;
+		     uiIndex <= tabentries(EplNmtMnuInstance_g.m_aNodeInfo);
+		     uiIndex++, pNodeInfo++) {
+			if (pNodeInfo->m_NodeState ==
+			    kEplNmtMnuNodeStateConfigured) {
+				Ret =
+				    EplNmtMnuNodeBootStep2(uiIndex, pNodeInfo);
+				if (Ret != kEplSuccessful) {
+					goto Exit;
+				}
+				// set flag "not scanned"
+				pNodeInfo->m_wFlags |=
+				    EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
+
+				EplNmtMnuInstance_g.m_uiSignalSlaveCount++;
+				// signal slave counter shall be decremented if StatusRequest was sent once to a CN
+
+				if ((pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0) {	// node is a mandatory CN
+					EplNmtMnuInstance_g.
+					    m_uiMandatorySlaveCount++;
+				}
+				// mandatory slave counter shall be decremented if mandatory CN is ReadyToOp
+			}
+		}
+	}
 
-
-    if ((EplNmtMnuInstance_g.m_wFlags & EPL_NMTMNU_FLAG_HALTED) == 0)
-    {   // boot process is not halted
-        // add nodes to isochronous phase and send NMT EnableReadyToOp
-        EplNmtMnuInstance_g.m_uiMandatorySlaveCount = 0;
-        EplNmtMnuInstance_g.m_uiSignalSlaveCount = 0;
-        // reset flag that application was informed about possible state change
-        EplNmtMnuInstance_g.m_wFlags &= ~EPL_NMTMNU_FLAG_APP_INFORMED;
-
-        pNodeInfo = EplNmtMnuInstance_g.m_aNodeInfo;
-        for (uiIndex = 1; uiIndex <= tabentries(EplNmtMnuInstance_g.m_aNodeInfo); uiIndex++, pNodeInfo++)
-        {
-            if (pNodeInfo->m_NodeState == kEplNmtMnuNodeStateConfigured)
-            {
-                Ret = EplNmtMnuNodeBootStep2(uiIndex, pNodeInfo);
-                if (Ret != kEplSuccessful)
-                {
-                    goto Exit;
-                }
-
-                // set flag "not scanned"
-                pNodeInfo->m_wFlags |= EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
-
-                EplNmtMnuInstance_g.m_uiSignalSlaveCount++;
-                // signal slave counter shall be decremented if StatusRequest was sent once to a CN
-
-                if ((pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0)
-                {   // node is a mandatory CN
-                    EplNmtMnuInstance_g.m_uiMandatorySlaveCount++;
-                }
-
-                // mandatory slave counter shall be decremented if mandatory CN is ReadyToOp
-            }
-        }
-    }
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuNodeBootStep2
@@ -1622,74 +1628,79 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplNmtMnuNodeBootStep2(unsigned int uiNodeId_p, tEplNmtMnuNodeInfo* pNodeInfo_p)
+static tEplKernel EplNmtMnuNodeBootStep2(unsigned int uiNodeId_p,
+					 tEplNmtMnuNodeInfo * pNodeInfo_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplDllNodeInfo DllNodeInfo;
-DWORD           dwNodeCfg;
-tEplObdSize     ObdSize;
-tEplTimerArg    TimerArg;
-
-    dwNodeCfg = pNodeInfo_p->m_dwNodeCfg;
-    if ((dwNodeCfg & EPL_NODEASSIGN_ASYNCONLY_NODE) == 0)
-    {   // add node to isochronous phase
-        DllNodeInfo.m_uiNodeId = uiNodeId_p;
-        ObdSize = 4;
-        Ret = EplObduReadEntry(0x1F92, uiNodeId_p, &DllNodeInfo.m_dwPresTimeout, &ObdSize);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        ObdSize = 2;
-        Ret = EplObduReadEntry(0x1F8B, uiNodeId_p, &DllNodeInfo.m_wPreqPayloadLimit, &ObdSize);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        ObdSize = 2;
-        Ret = EplObduReadEntry(0x1F8D, uiNodeId_p, &DllNodeInfo.m_wPresPayloadLimit, &ObdSize);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        pNodeInfo_p->m_wFlags |= EPL_NMTMNU_NODE_FLAG_ISOCHRON;
-
-        Ret = EplDlluCalAddNode(&DllNodeInfo);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-    }
-
-    EPL_NMTMNU_DBG_POST_TRACE_VALUE(0,
-                                    uiNodeId_p,
-                                    kEplNmtCmdEnableReadyToOperate);
-
-    Ret = EplNmtMnuSendNmtCommand(uiNodeId_p, kEplNmtCmdEnableReadyToOperate);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    if (EplNmtMnuInstance_g.m_ulTimeoutReadyToOp != 0L)
-    {   // start timer
-        // when the timer expires the CN must be ReadyToOp
-        EPL_NMTMNU_SET_FLAGS_TIMERARG_LONGER(
-                pNodeInfo_p, uiNodeId_p, TimerArg);
+	tEplKernel Ret = kEplSuccessful;
+	tEplDllNodeInfo DllNodeInfo;
+	DWORD dwNodeCfg;
+	tEplObdSize ObdSize;
+	tEplTimerArg TimerArg;
+
+	dwNodeCfg = pNodeInfo_p->m_dwNodeCfg;
+	if ((dwNodeCfg & EPL_NODEASSIGN_ASYNCONLY_NODE) == 0) {	// add node to isochronous phase
+		DllNodeInfo.m_uiNodeId = uiNodeId_p;
+		ObdSize = 4;
+		Ret =
+		    EplObduReadEntry(0x1F92, uiNodeId_p,
+				     &DllNodeInfo.m_dwPresTimeout, &ObdSize);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+
+		ObdSize = 2;
+		Ret =
+		    EplObduReadEntry(0x1F8B, uiNodeId_p,
+				     &DllNodeInfo.m_wPreqPayloadLimit,
+				     &ObdSize);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+
+		ObdSize = 2;
+		Ret =
+		    EplObduReadEntry(0x1F8D, uiNodeId_p,
+				     &DllNodeInfo.m_wPresPayloadLimit,
+				     &ObdSize);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+
+		pNodeInfo_p->m_wFlags |= EPL_NMTMNU_NODE_FLAG_ISOCHRON;
+
+		Ret = EplDlluCalAddNode(&DllNodeInfo);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+
+	}
+
+	EPL_NMTMNU_DBG_POST_TRACE_VALUE(0,
+					uiNodeId_p,
+					kEplNmtCmdEnableReadyToOperate);
+
+	Ret =
+	    EplNmtMnuSendNmtCommand(uiNodeId_p, kEplNmtCmdEnableReadyToOperate);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	if (EplNmtMnuInstance_g.m_ulTimeoutReadyToOp != 0L) {	// start timer
+		// when the timer expires the CN must be ReadyToOp
+		EPL_NMTMNU_SET_FLAGS_TIMERARG_LONGER(pNodeInfo_p, uiNodeId_p,
+						     TimerArg);
 //        TimerArg.m_EventSink = kEplEventSinkNmtMnu;
 //        TimerArg.m_ulArg = EPL_NMTMNU_TIMERARG_LONGER | uiNodeId_p;
-        Ret = EplTimeruModifyTimerMs(&pNodeInfo_p->m_TimerHdlLonger, EplNmtMnuInstance_g.m_ulTimeoutReadyToOp, TimerArg);
-    }
+		Ret =
+		    EplTimeruModifyTimerMs(&pNodeInfo_p->m_TimerHdlLonger,
+					   EplNmtMnuInstance_g.
+					   m_ulTimeoutReadyToOp, TimerArg);
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuStartCheckCom
@@ -1706,55 +1717,50 @@ Exit:
 
 static tEplKernel EplNmtMnuStartCheckCom(void)
 {
-tEplKernel      Ret = kEplSuccessful;
-unsigned int    uiIndex;
-tEplNmtMnuNodeInfo* pNodeInfo;
-
-
-    if ((EplNmtMnuInstance_g.m_wFlags & EPL_NMTMNU_FLAG_HALTED) == 0)
-    {   // boot process is not halted
-        // wait some time and check that no communication error occurs
-        EplNmtMnuInstance_g.m_uiMandatorySlaveCount = 0;
-        EplNmtMnuInstance_g.m_uiSignalSlaveCount = 0;
-        // reset flag that application was informed about possible state change
-        EplNmtMnuInstance_g.m_wFlags &= ~EPL_NMTMNU_FLAG_APP_INFORMED;
-
-        pNodeInfo = EplNmtMnuInstance_g.m_aNodeInfo;
-        for (uiIndex = 1; uiIndex <= tabentries(EplNmtMnuInstance_g.m_aNodeInfo); uiIndex++, pNodeInfo++)
-        {
-            if (pNodeInfo->m_NodeState == kEplNmtMnuNodeStateReadyToOp)
-            {
-                Ret = EplNmtMnuNodeCheckCom(uiIndex, pNodeInfo);
-                if (Ret == kEplReject)
-                {   // timer was started
-                    // wait until it expires
-                    if ((pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0)
-                    {   // node is a mandatory CN
-                        EplNmtMnuInstance_g.m_uiMandatorySlaveCount++;
-                    }
-                }
-                else if (Ret != kEplSuccessful)
-                {
-                    goto Exit;
-                }
-
-                // set flag "not scanned"
-                pNodeInfo->m_wFlags |= EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
-
-                EplNmtMnuInstance_g.m_uiSignalSlaveCount++;
-                // signal slave counter shall be decremented if timeout elapsed and regardless of an error
-                // mandatory slave counter shall be decremented if timeout elapsed and no error occured
-            }
-        }
-    }
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiIndex;
+	tEplNmtMnuNodeInfo *pNodeInfo;
+
+	if ((EplNmtMnuInstance_g.m_wFlags & EPL_NMTMNU_FLAG_HALTED) == 0) {	// boot process is not halted
+		// wait some time and check that no communication error occurs
+		EplNmtMnuInstance_g.m_uiMandatorySlaveCount = 0;
+		EplNmtMnuInstance_g.m_uiSignalSlaveCount = 0;
+		// reset flag that application was informed about possible state change
+		EplNmtMnuInstance_g.m_wFlags &= ~EPL_NMTMNU_FLAG_APP_INFORMED;
+
+		pNodeInfo = EplNmtMnuInstance_g.m_aNodeInfo;
+		for (uiIndex = 1;
+		     uiIndex <= tabentries(EplNmtMnuInstance_g.m_aNodeInfo);
+		     uiIndex++, pNodeInfo++) {
+			if (pNodeInfo->m_NodeState ==
+			    kEplNmtMnuNodeStateReadyToOp) {
+				Ret = EplNmtMnuNodeCheckCom(uiIndex, pNodeInfo);
+				if (Ret == kEplReject) {	// timer was started
+					// wait until it expires
+					if ((pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0) {	// node is a mandatory CN
+						EplNmtMnuInstance_g.
+						    m_uiMandatorySlaveCount++;
+					}
+				} else if (Ret != kEplSuccessful) {
+					goto Exit;
+				}
+				// set flag "not scanned"
+				pNodeInfo->m_wFlags |=
+				    EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
+
+				EplNmtMnuInstance_g.m_uiSignalSlaveCount++;
+				// signal slave counter shall be decremented if timeout elapsed and regardless of an error
+				// mandatory slave counter shall be decremented if timeout elapsed and no error occured
+			}
+		}
+	}
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuNodeCheckCom
@@ -1772,44 +1778,43 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplNmtMnuNodeCheckCom(unsigned int uiNodeId_p, tEplNmtMnuNodeInfo* pNodeInfo_p)
+static tEplKernel EplNmtMnuNodeCheckCom(unsigned int uiNodeId_p,
+					tEplNmtMnuNodeInfo * pNodeInfo_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-DWORD           dwNodeCfg;
-tEplTimerArg    TimerArg;
-
-    dwNodeCfg = pNodeInfo_p->m_dwNodeCfg;
-    if (((dwNodeCfg & EPL_NODEASSIGN_ASYNCONLY_NODE) == 0)
-        && (EplNmtMnuInstance_g.m_ulTimeoutCheckCom != 0L))
-    {   // CN is not async-only and timeout for CheckCom was set
-
-        // check communication,
-        // that means wait some time and if no error occured everything is OK;
-
-        // start timer (when the timer expires the CN must be still ReadyToOp)
-        EPL_NMTMNU_SET_FLAGS_TIMERARG_LONGER(
-                pNodeInfo_p, uiNodeId_p, TimerArg);
+	tEplKernel Ret = kEplSuccessful;
+	DWORD dwNodeCfg;
+	tEplTimerArg TimerArg;
+
+	dwNodeCfg = pNodeInfo_p->m_dwNodeCfg;
+	if (((dwNodeCfg & EPL_NODEASSIGN_ASYNCONLY_NODE) == 0)
+	    && (EplNmtMnuInstance_g.m_ulTimeoutCheckCom != 0L)) {	// CN is not async-only and timeout for CheckCom was set
+
+		// check communication,
+		// that means wait some time and if no error occured everything is OK;
+
+		// start timer (when the timer expires the CN must be still ReadyToOp)
+		EPL_NMTMNU_SET_FLAGS_TIMERARG_LONGER(pNodeInfo_p, uiNodeId_p,
+						     TimerArg);
 //        TimerArg.m_EventSink = kEplEventSinkNmtMnu;
 //        TimerArg.m_ulArg = EPL_NMTMNU_TIMERARG_LONGER | uiNodeId_p;
-        Ret = EplTimeruModifyTimerMs(&pNodeInfo_p->m_TimerHdlLonger, EplNmtMnuInstance_g.m_ulTimeoutCheckCom, TimerArg);
-
-        // update mandatory slave counter, because timer was started
-        if (Ret == kEplSuccessful)
-        {
-            Ret = kEplReject;
-        }
-    }
-    else
-    {   // timer was not started
-        // assume everything is OK
-        pNodeInfo_p->m_NodeState = kEplNmtMnuNodeStateComChecked;
-    }
+		Ret =
+		    EplTimeruModifyTimerMs(&pNodeInfo_p->m_TimerHdlLonger,
+					   EplNmtMnuInstance_g.
+					   m_ulTimeoutCheckCom, TimerArg);
+
+		// update mandatory slave counter, because timer was started
+		if (Ret == kEplSuccessful) {
+			Ret = kEplReject;
+		}
+	} else {		// timer was not started
+		// assume everything is OK
+		pNodeInfo_p->m_NodeState = kEplNmtMnuNodeStateComChecked;
+	}
 
 //Exit:
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuStartNodes
@@ -1826,72 +1831,72 @@ tEplTimerArg    TimerArg;
 
 static tEplKernel EplNmtMnuStartNodes(void)
 {
-tEplKernel      Ret = kEplSuccessful;
-unsigned int    uiIndex;
-tEplNmtMnuNodeInfo* pNodeInfo;
-
-
-    if ((EplNmtMnuInstance_g.m_wFlags & EPL_NMTMNU_FLAG_HALTED) == 0)
-    {   // boot process is not halted
-        // send NMT command Start Node
-        EplNmtMnuInstance_g.m_uiMandatorySlaveCount = 0;
-        EplNmtMnuInstance_g.m_uiSignalSlaveCount = 0;
-        // reset flag that application was informed about possible state change
-        EplNmtMnuInstance_g.m_wFlags &= ~EPL_NMTMNU_FLAG_APP_INFORMED;
-
-        pNodeInfo = EplNmtMnuInstance_g.m_aNodeInfo;
-        for (uiIndex = 1; uiIndex <= tabentries(EplNmtMnuInstance_g.m_aNodeInfo); uiIndex++, pNodeInfo++)
-        {
-            if (pNodeInfo->m_NodeState == kEplNmtMnuNodeStateComChecked)
-            {
-                if ((EplNmtMnuInstance_g.m_dwNmtStartup & EPL_NMTST_STARTALLNODES) == 0)
-                {
-                    EPL_NMTMNU_DBG_POST_TRACE_VALUE(0,
-                                                    uiIndex,
-                                                    kEplNmtCmdStartNode);
-
-                    Ret = EplNmtMnuSendNmtCommand(uiIndex, kEplNmtCmdStartNode);
-                    if (Ret != kEplSuccessful)
-                    {
-                        goto Exit;
-                    }
-                }
-
-                if ((pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0)
-                {   // node is a mandatory CN
-                    EplNmtMnuInstance_g.m_uiMandatorySlaveCount++;
-                }
-
-                // set flag "not scanned"
-                pNodeInfo->m_wFlags |= EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
-
-                EplNmtMnuInstance_g.m_uiSignalSlaveCount++;
-                // signal slave counter shall be decremented if StatusRequest was sent once to a CN
-                // mandatory slave counter shall be decremented if mandatory CN is OPERATIONAL
-            }
-        }
-
-        // $$$ inform application if EPL_NMTST_NO_STARTNODE is set
-
-        if ((EplNmtMnuInstance_g.m_dwNmtStartup & EPL_NMTST_STARTALLNODES) != 0)
-        {
-            EPL_NMTMNU_DBG_POST_TRACE_VALUE(0,
-                                            EPL_C_ADR_BROADCAST,
-                                            kEplNmtCmdStartNode);
-
-            Ret = EplNmtMnuSendNmtCommand(EPL_C_ADR_BROADCAST, kEplNmtCmdStartNode);
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-        }
-    }
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiIndex;
+	tEplNmtMnuNodeInfo *pNodeInfo;
+
+	if ((EplNmtMnuInstance_g.m_wFlags & EPL_NMTMNU_FLAG_HALTED) == 0) {	// boot process is not halted
+		// send NMT command Start Node
+		EplNmtMnuInstance_g.m_uiMandatorySlaveCount = 0;
+		EplNmtMnuInstance_g.m_uiSignalSlaveCount = 0;
+		// reset flag that application was informed about possible state change
+		EplNmtMnuInstance_g.m_wFlags &= ~EPL_NMTMNU_FLAG_APP_INFORMED;
+
+		pNodeInfo = EplNmtMnuInstance_g.m_aNodeInfo;
+		for (uiIndex = 1;
+		     uiIndex <= tabentries(EplNmtMnuInstance_g.m_aNodeInfo);
+		     uiIndex++, pNodeInfo++) {
+			if (pNodeInfo->m_NodeState ==
+			    kEplNmtMnuNodeStateComChecked) {
+				if ((EplNmtMnuInstance_g.
+				     m_dwNmtStartup & EPL_NMTST_STARTALLNODES)
+				    == 0) {
+					EPL_NMTMNU_DBG_POST_TRACE_VALUE(0,
+									uiIndex,
+									kEplNmtCmdStartNode);
+
+					Ret =
+					    EplNmtMnuSendNmtCommand(uiIndex,
+								    kEplNmtCmdStartNode);
+					if (Ret != kEplSuccessful) {
+						goto Exit;
+					}
+				}
+
+				if ((pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0) {	// node is a mandatory CN
+					EplNmtMnuInstance_g.
+					    m_uiMandatorySlaveCount++;
+				}
+				// set flag "not scanned"
+				pNodeInfo->m_wFlags |=
+				    EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
+
+				EplNmtMnuInstance_g.m_uiSignalSlaveCount++;
+				// signal slave counter shall be decremented if StatusRequest was sent once to a CN
+				// mandatory slave counter shall be decremented if mandatory CN is OPERATIONAL
+			}
+		}
+
+		// $$$ inform application if EPL_NMTST_NO_STARTNODE is set
+
+		if ((EplNmtMnuInstance_g.
+		     m_dwNmtStartup & EPL_NMTST_STARTALLNODES) != 0) {
+			EPL_NMTMNU_DBG_POST_TRACE_VALUE(0, EPL_C_ADR_BROADCAST,
+							kEplNmtCmdStartNode);
+
+			Ret =
+			    EplNmtMnuSendNmtCommand(EPL_C_ADR_BROADCAST,
+						    kEplNmtCmdStartNode);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuProcessInternalEvent
@@ -1909,216 +1914,220 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplNmtMnuProcessInternalEvent(
-                                    unsigned int        uiNodeId_p,
-                                    tEplNmtState        NodeNmtState_p,
-                                    WORD                wErrorCode_p,
-                                    tEplNmtMnuIntNodeEvent NodeEvent_p)
-{
-tEplKernel          Ret = kEplSuccessful;
-tEplNmtState        NmtState;
-tEplNmtMnuNodeInfo* pNodeInfo;
-tEplTimerArg        TimerArg;
-
-    pNodeInfo = EPL_NMTMNU_GET_NODEINFO(uiNodeId_p);
-    NmtState = EplNmtuGetNmtState();
-    if (NmtState <= kEplNmtMsNotActive)
-    {   // MN is not active
-        goto Exit;
-    }
-
-    switch (NodeEvent_p)
-    {
-        case kEplNmtMnuIntNodeEventIdentResponse:
-        {
-        BYTE    bNmtState;
-
-            EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
-                                            uiNodeId_p,
-                                            pNodeInfo->m_NodeState);
-
-            if (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateResetConf)
-            {
-                pNodeInfo->m_NodeState = kEplNmtMnuNodeStateIdentified;
-            }
-
-            // reset flags ISOCHRON and NMT_CMD_ISSUED
-            pNodeInfo->m_wFlags &= ~(EPL_NMTMNU_NODE_FLAG_ISOCHRON
-                                     | EPL_NMTMNU_NODE_FLAG_NMT_CMD_ISSUED);
-
-            if ((NmtState == kEplNmtMsPreOperational1)
-                && ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) != 0))
-            {
-                // decrement only signal slave count
-                EplNmtMnuInstance_g.m_uiSignalSlaveCount--;
-                pNodeInfo->m_wFlags &= ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
-            }
-
-            // update object 0x1F8F NMT_MNNodeExpState_AU8 to PreOp1 (even if local state >= PreOp2)
-            bNmtState = (BYTE) (kEplNmtCsPreOperational1 & 0xFF);
-            Ret = EplObduWriteEntry(0x1F8F, uiNodeId_p, &bNmtState, 1);
-
-            // check NMT state of CN
-            Ret = EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo, NodeNmtState_p, wErrorCode_p, NmtState);
-            if (Ret != kEplSuccessful)
-            {
-                if (Ret == kEplReject)
-                {
-                    Ret = kEplSuccessful;
-                }
-                break;
-            }
-
-            // request StatusResponse immediately,
-            // because we want a fast boot-up of CNs
-            Ret = EplStatusuRequestStatusResponse(uiNodeId_p, EplNmtMnuCbStatusResponse);
-            if (Ret != kEplSuccessful)
-            {
-                EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
-                                                uiNodeId_p,
-                                                Ret);
-
-                if (Ret == kEplInvalidOperation)
-                {   // the only situation when this should happen is, when
-                    // StatusResponse was already requested from within
-                    // the StatReq timer event.
-                    // so ignore this error.
-                    Ret = kEplSuccessful;
-                }
-                else
-                {
-                    break;
-                }
-            }
-
-            if (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateResetConf)
-            {
-                // inform application
-                Ret = EplNmtMnuInstance_g.m_pfnCbNodeEvent(uiNodeId_p,
-                                                           kEplNmtNodeEventFound,
-                                                           NodeNmtState_p,
-                                                           EPL_E_NO_ERROR,
-                                                           (pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0);
-                if (Ret == kEplReject)
-                {   // interrupt boot process on user request
-                    EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
-                                                    uiNodeId_p,
-                                                    ((pNodeInfo->m_NodeState << 8)
-                                                     | Ret));
-
-                    Ret = kEplSuccessful;
-                    break;
-                }
-                else if (Ret != kEplSuccessful)
-                {
-                    EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
-                                                    uiNodeId_p,
-                                                    ((pNodeInfo->m_NodeState << 8)
-                                                     | Ret));
-
-                    break;
-                }
-            }
-
-            // continue BootStep1
-        }
-
-        case kEplNmtMnuIntNodeEventBoot:
-        {
-
-            // $$$ check identification (vendor ID, product code, revision no, serial no)
-
-            if (pNodeInfo->m_NodeState == kEplNmtMnuNodeStateIdentified)
-            {
-                // $$$ check software
-
-                // check/start configuration
-                // inform application
-                Ret = EplNmtMnuInstance_g.m_pfnCbNodeEvent(uiNodeId_p,
-                                                           kEplNmtNodeEventCheckConf,
-                                                           NodeNmtState_p,
-                                                           EPL_E_NO_ERROR,
-                                                           (pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0);
-                if (Ret == kEplReject)
-                {   // interrupt boot process on user request
-                    EPL_NMTMNU_DBG_POST_TRACE_VALUE(kEplNmtMnuIntNodeEventBoot,
-                                                    uiNodeId_p,
-                                                    ((pNodeInfo->m_NodeState << 8)
-                                                     | Ret));
-
-                    Ret = kEplSuccessful;
-                    break;
-                }
-                else if (Ret != kEplSuccessful)
-                {
-                    EPL_NMTMNU_DBG_POST_TRACE_VALUE(kEplNmtMnuIntNodeEventBoot,
-                                                    uiNodeId_p,
-                                                    ((pNodeInfo->m_NodeState << 8)
-                                                     | Ret));
-
-                    break;
-                }
-            }
-            else if (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateResetConf)
-            {   // wrong CN state
-                // ignore event
-                break;
-            }
-
-            // $$$ d.k.: currently we assume configuration is OK
-
-            // continue BootStep1
-        }
-
-        case kEplNmtMnuIntNodeEventConfigured:
-        {
-            if ((pNodeInfo->m_NodeState != kEplNmtMnuNodeStateIdentified)
-                && (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateResetConf))
-            {   // wrong CN state
-                // ignore event
-                break;
-            }
-
-            pNodeInfo->m_NodeState = kEplNmtMnuNodeStateConfigured;
-
-            if (NmtState == kEplNmtMsPreOperational1)
-            {
-                if ((pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0)
-                {   // decrement mandatory CN counter
-                    EplNmtMnuInstance_g.m_uiMandatorySlaveCount--;
-                }
-            }
-            else
-            {
-                // put optional node to next step (BootStep2)
-                Ret = EplNmtMnuNodeBootStep2(uiNodeId_p, pNodeInfo);
-            }
-            break;
-        }
-
-        case kEplNmtMnuIntNodeEventNoIdentResponse:
-        {
-            if ((NmtState == kEplNmtMsPreOperational1)
-                && ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) != 0))
-            {
-                // decrement only signal slave count
-                EplNmtMnuInstance_g.m_uiSignalSlaveCount--;
-                pNodeInfo->m_wFlags &= ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
-            }
-
-            if (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateResetConf)
-            {
-                pNodeInfo->m_NodeState = kEplNmtMnuNodeStateUnknown;
-            }
-
-            // $$$ d.k. check start time for 0x1F89/2 MNTimeoutPreOp1_U32
-            // $$$ d.k. check individual timeout 0x1F89/6 MNIdentificationTimeout_U32
-            // if mandatory node and timeout elapsed -> halt boot procedure
-            // trigger IdentRequest again (if >= PreOp2, after delay)
-            if (NmtState >= kEplNmtMsPreOperational2)
-            {   // start timer
-                EPL_NMTMNU_SET_FLAGS_TIMERARG_IDENTREQ(
-                        pNodeInfo, uiNodeId_p, TimerArg);
+static tEplKernel EplNmtMnuProcessInternalEvent(unsigned int uiNodeId_p,
+						tEplNmtState NodeNmtState_p,
+						WORD wErrorCode_p,
+						tEplNmtMnuIntNodeEvent
+						NodeEvent_p)
+{
+	tEplKernel Ret = kEplSuccessful;
+	tEplNmtState NmtState;
+	tEplNmtMnuNodeInfo *pNodeInfo;
+	tEplTimerArg TimerArg;
+
+	pNodeInfo = EPL_NMTMNU_GET_NODEINFO(uiNodeId_p);
+	NmtState = EplNmtuGetNmtState();
+	if (NmtState <= kEplNmtMsNotActive) {	// MN is not active
+		goto Exit;
+	}
+
+	switch (NodeEvent_p) {
+	case kEplNmtMnuIntNodeEventIdentResponse:
+		{
+			BYTE bNmtState;
+
+			EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
+							uiNodeId_p,
+							pNodeInfo->m_NodeState);
+
+			if (pNodeInfo->m_NodeState !=
+			    kEplNmtMnuNodeStateResetConf) {
+				pNodeInfo->m_NodeState =
+				    kEplNmtMnuNodeStateIdentified;
+			}
+			// reset flags ISOCHRON and NMT_CMD_ISSUED
+			pNodeInfo->m_wFlags &= ~(EPL_NMTMNU_NODE_FLAG_ISOCHRON
+						 |
+						 EPL_NMTMNU_NODE_FLAG_NMT_CMD_ISSUED);
+
+			if ((NmtState == kEplNmtMsPreOperational1)
+			    &&
+			    ((pNodeInfo->
+			      m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) !=
+			     0)) {
+				// decrement only signal slave count
+				EplNmtMnuInstance_g.m_uiSignalSlaveCount--;
+				pNodeInfo->m_wFlags &=
+				    ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
+			}
+			// update object 0x1F8F NMT_MNNodeExpState_AU8 to PreOp1 (even if local state >= PreOp2)
+			bNmtState = (BYTE) (kEplNmtCsPreOperational1 & 0xFF);
+			Ret =
+			    EplObduWriteEntry(0x1F8F, uiNodeId_p, &bNmtState,
+					      1);
+
+			// check NMT state of CN
+			Ret =
+			    EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo,
+						   NodeNmtState_p, wErrorCode_p,
+						   NmtState);
+			if (Ret != kEplSuccessful) {
+				if (Ret == kEplReject) {
+					Ret = kEplSuccessful;
+				}
+				break;
+			}
+			// request StatusResponse immediately,
+			// because we want a fast boot-up of CNs
+			Ret =
+			    EplStatusuRequestStatusResponse(uiNodeId_p,
+							    EplNmtMnuCbStatusResponse);
+			if (Ret != kEplSuccessful) {
+				EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
+								uiNodeId_p,
+								Ret);
+
+				if (Ret == kEplInvalidOperation) {	// the only situation when this should happen is, when
+					// StatusResponse was already requested from within
+					// the StatReq timer event.
+					// so ignore this error.
+					Ret = kEplSuccessful;
+				} else {
+					break;
+				}
+			}
+
+			if (pNodeInfo->m_NodeState !=
+			    kEplNmtMnuNodeStateResetConf) {
+				// inform application
+				Ret =
+				    EplNmtMnuInstance_g.
+				    m_pfnCbNodeEvent(uiNodeId_p,
+						     kEplNmtNodeEventFound,
+						     NodeNmtState_p,
+						     EPL_E_NO_ERROR,
+						     (pNodeInfo->
+						      m_dwNodeCfg &
+						      EPL_NODEASSIGN_MANDATORY_CN)
+						     != 0);
+				if (Ret == kEplReject) {	// interrupt boot process on user request
+					EPL_NMTMNU_DBG_POST_TRACE_VALUE
+					    (NodeEvent_p, uiNodeId_p,
+					     ((pNodeInfo->m_NodeState << 8)
+					      | Ret));
+
+					Ret = kEplSuccessful;
+					break;
+				} else if (Ret != kEplSuccessful) {
+					EPL_NMTMNU_DBG_POST_TRACE_VALUE
+					    (NodeEvent_p, uiNodeId_p,
+					     ((pNodeInfo->m_NodeState << 8)
+					      | Ret));
+
+					break;
+				}
+			}
+			// continue BootStep1
+		}
+
+	case kEplNmtMnuIntNodeEventBoot:
+		{
+
+			// $$$ check identification (vendor ID, product code, revision no, serial no)
+
+			if (pNodeInfo->m_NodeState ==
+			    kEplNmtMnuNodeStateIdentified) {
+				// $$$ check software
+
+				// check/start configuration
+				// inform application
+				Ret =
+				    EplNmtMnuInstance_g.
+				    m_pfnCbNodeEvent(uiNodeId_p,
+						     kEplNmtNodeEventCheckConf,
+						     NodeNmtState_p,
+						     EPL_E_NO_ERROR,
+						     (pNodeInfo->
+						      m_dwNodeCfg &
+						      EPL_NODEASSIGN_MANDATORY_CN)
+						     != 0);
+				if (Ret == kEplReject) {	// interrupt boot process on user request
+					EPL_NMTMNU_DBG_POST_TRACE_VALUE
+					    (kEplNmtMnuIntNodeEventBoot,
+					     uiNodeId_p,
+					     ((pNodeInfo->m_NodeState << 8)
+					      | Ret));
+
+					Ret = kEplSuccessful;
+					break;
+				} else if (Ret != kEplSuccessful) {
+					EPL_NMTMNU_DBG_POST_TRACE_VALUE
+					    (kEplNmtMnuIntNodeEventBoot,
+					     uiNodeId_p,
+					     ((pNodeInfo->m_NodeState << 8)
+					      | Ret));
+
+					break;
+				}
+			} else if (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateResetConf) {	// wrong CN state
+				// ignore event
+				break;
+			}
+			// $$$ d.k.: currently we assume configuration is OK
+
+			// continue BootStep1
+		}
+
+	case kEplNmtMnuIntNodeEventConfigured:
+		{
+			if ((pNodeInfo->m_NodeState !=
+			     kEplNmtMnuNodeStateIdentified)
+			    && (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateResetConf)) {	// wrong CN state
+				// ignore event
+				break;
+			}
+
+			pNodeInfo->m_NodeState = kEplNmtMnuNodeStateConfigured;
+
+			if (NmtState == kEplNmtMsPreOperational1) {
+				if ((pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0) {	// decrement mandatory CN counter
+					EplNmtMnuInstance_g.
+					    m_uiMandatorySlaveCount--;
+				}
+			} else {
+				// put optional node to next step (BootStep2)
+				Ret =
+				    EplNmtMnuNodeBootStep2(uiNodeId_p,
+							   pNodeInfo);
+			}
+			break;
+		}
+
+	case kEplNmtMnuIntNodeEventNoIdentResponse:
+		{
+			if ((NmtState == kEplNmtMsPreOperational1)
+			    &&
+			    ((pNodeInfo->
+			      m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) !=
+			     0)) {
+				// decrement only signal slave count
+				EplNmtMnuInstance_g.m_uiSignalSlaveCount--;
+				pNodeInfo->m_wFlags &=
+				    ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
+			}
+
+			if (pNodeInfo->m_NodeState !=
+			    kEplNmtMnuNodeStateResetConf) {
+				pNodeInfo->m_NodeState =
+				    kEplNmtMnuNodeStateUnknown;
+			}
+			// $$$ d.k. check start time for 0x1F89/2 MNTimeoutPreOp1_U32
+			// $$$ d.k. check individual timeout 0x1F89/6 MNIdentificationTimeout_U32
+			// if mandatory node and timeout elapsed -> halt boot procedure
+			// trigger IdentRequest again (if >= PreOp2, after delay)
+			if (NmtState >= kEplNmtMsPreOperational2) {	// start timer
+				EPL_NMTMNU_SET_FLAGS_TIMERARG_IDENTREQ
+				    (pNodeInfo, uiNodeId_p, TimerArg);
 //                TimerArg.m_EventSink = kEplEventSinkNmtMnu;
 //                TimerArg.m_ulArg = EPL_NMTMNU_TIMERARG_IDENTREQ | uiNodeId_p;
 /*
@@ -2129,53 +2138,59 @@ tEplTimerArg        TimerArg;
                                                  | ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ) >> 6)
                                                  | ((TimerArg.m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR) >> 8)));
 */
-                Ret = EplTimeruModifyTimerMs(&pNodeInfo->m_TimerHdlStatReq, EplNmtMnuInstance_g.m_ulStatusRequestDelay, TimerArg);
-            }
-            else
-            {   // trigger IdentRequest immediately
-                Ret = EplIdentuRequestIdentResponse(uiNodeId_p, EplNmtMnuCbIdentResponse);
-            }
-            break;
-        }
-
-        case kEplNmtMnuIntNodeEventStatusResponse:
-        {
-            if ((NmtState >= kEplNmtMsPreOperational2)
-                && ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) != 0))
-            {
-                // decrement only signal slave count if checked once for ReadyToOp, CheckCom, Operational
-                EplNmtMnuInstance_g.m_uiSignalSlaveCount--;
-                pNodeInfo->m_wFlags &= ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
-            }
-
-            // check NMT state of CN
-            Ret = EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo, NodeNmtState_p, wErrorCode_p, NmtState);
-            if (Ret != kEplSuccessful)
-            {
-                if (Ret == kEplReject)
-                {
-                    Ret = kEplSuccessful;
-                }
-                break;
-            }
-
-            if (NmtState == kEplNmtMsPreOperational1)
-            {
-                // request next StatusResponse immediately
-                Ret = EplStatusuRequestStatusResponse(uiNodeId_p, EplNmtMnuCbStatusResponse);
-                if (Ret != kEplSuccessful)
-                {
-                    EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
-                                                    uiNodeId_p,
-                                                    Ret);
-                }
-
-            }
-            else if ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_ISOCHRON) == 0)
-            {   // start timer
-                // not isochronously accessed CN (e.g. async-only or stopped CN)
-                EPL_NMTMNU_SET_FLAGS_TIMERARG_STATREQ(
-                        pNodeInfo, uiNodeId_p, TimerArg);
+				Ret =
+				    EplTimeruModifyTimerMs(&pNodeInfo->
+							   m_TimerHdlStatReq,
+							   EplNmtMnuInstance_g.
+							   m_ulStatusRequestDelay,
+							   TimerArg);
+			} else {	// trigger IdentRequest immediately
+				Ret =
+				    EplIdentuRequestIdentResponse(uiNodeId_p,
+								  EplNmtMnuCbIdentResponse);
+			}
+			break;
+		}
+
+	case kEplNmtMnuIntNodeEventStatusResponse:
+		{
+			if ((NmtState >= kEplNmtMsPreOperational2)
+			    &&
+			    ((pNodeInfo->
+			      m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) !=
+			     0)) {
+				// decrement only signal slave count if checked once for ReadyToOp, CheckCom, Operational
+				EplNmtMnuInstance_g.m_uiSignalSlaveCount--;
+				pNodeInfo->m_wFlags &=
+				    ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
+			}
+			// check NMT state of CN
+			Ret =
+			    EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo,
+						   NodeNmtState_p, wErrorCode_p,
+						   NmtState);
+			if (Ret != kEplSuccessful) {
+				if (Ret == kEplReject) {
+					Ret = kEplSuccessful;
+				}
+				break;
+			}
+
+			if (NmtState == kEplNmtMsPreOperational1) {
+				// request next StatusResponse immediately
+				Ret =
+				    EplStatusuRequestStatusResponse(uiNodeId_p,
+								    EplNmtMnuCbStatusResponse);
+				if (Ret != kEplSuccessful) {
+					EPL_NMTMNU_DBG_POST_TRACE_VALUE
+					    (NodeEvent_p, uiNodeId_p, Ret);
+				}
+
+			} else if ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_ISOCHRON) == 0) {	// start timer
+				// not isochronously accessed CN (e.g. async-only or stopped CN)
+				EPL_NMTMNU_SET_FLAGS_TIMERARG_STATREQ(pNodeInfo,
+								      uiNodeId_p,
+								      TimerArg);
 //                TimerArg.m_EventSink = kEplEventSinkNmtMnu;
 //                TimerArg.m_ulArg = EPL_NMTMNU_TIMERARG_STATREQ | uiNodeId_p;
 /*
@@ -2186,15 +2201,20 @@ tEplTimerArg        TimerArg;
                                                  | ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_COUNT_STATREQ) >> 6)
                                                  | ((TimerArg.m_ulArg & EPL_NMTMNU_TIMERARG_COUNT_SR) >> 8)));
 */
-                Ret = EplTimeruModifyTimerMs(&pNodeInfo->m_TimerHdlStatReq, EplNmtMnuInstance_g.m_ulStatusRequestDelay, TimerArg);
-            }
-
-            break;
-        }
-
-        case kEplNmtMnuIntNodeEventNoStatusResponse:
-        {
-            // function CheckNmtState sets node state to unknown if necessary
+				Ret =
+				    EplTimeruModifyTimerMs(&pNodeInfo->
+							   m_TimerHdlStatReq,
+							   EplNmtMnuInstance_g.
+							   m_ulStatusRequestDelay,
+							   TimerArg);
+			}
+
+			break;
+		}
+
+	case kEplNmtMnuIntNodeEventNoStatusResponse:
+		{
+			// function CheckNmtState sets node state to unknown if necessary
 /*
             if ((NmtState >= kEplNmtMsPreOperational2)
                 && ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) != 0))
@@ -2204,66 +2224,69 @@ tEplTimerArg        TimerArg;
                 pNodeInfo->m_wFlags &= ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
             }
 */
-            // check NMT state of CN
-            Ret = EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo, NodeNmtState_p, wErrorCode_p, NmtState);
-            if (Ret != kEplSuccessful)
-            {
-                if (Ret == kEplReject)
-                {
-                    Ret = kEplSuccessful;
-                }
-                break;
-            }
-
-            break;
-        }
-
-        case kEplNmtMnuIntNodeEventError:
-        {   // currently only issued on kEplNmtNodeCommandConfErr
-
-            if (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateIdentified)
-            {   // wrong CN state
-                // ignore event
-                break;
-            }
-
-            // check NMT state of CN
-            Ret = EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo, kEplNmtCsNotActive, wErrorCode_p, NmtState);
-            if (Ret != kEplSuccessful)
-            {
-                if (Ret == kEplReject)
-                {
-                    Ret = kEplSuccessful;
-                }
-                break;
-            }
+			// check NMT state of CN
+			Ret =
+			    EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo,
+						   NodeNmtState_p, wErrorCode_p,
+						   NmtState);
+			if (Ret != kEplSuccessful) {
+				if (Ret == kEplReject) {
+					Ret = kEplSuccessful;
+				}
+				break;
+			}
+
+			break;
+		}
+
+	case kEplNmtMnuIntNodeEventError:
+		{		// currently only issued on kEplNmtNodeCommandConfErr
+
+			if (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateIdentified) {	// wrong CN state
+				// ignore event
+				break;
+			}
+			// check NMT state of CN
+			Ret =
+			    EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo,
+						   kEplNmtCsNotActive,
+						   wErrorCode_p, NmtState);
+			if (Ret != kEplSuccessful) {
+				if (Ret == kEplReject) {
+					Ret = kEplSuccessful;
+				}
+				break;
+			}
+
+			break;
+		}
+
+	case kEplNmtMnuIntNodeEventExecReset:
+		{
+			if (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateIdentified) {	// wrong CN state
+				// ignore event
+				break;
+			}
+
+			pNodeInfo->m_NodeState = kEplNmtMnuNodeStateResetConf;
+
+			EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
+							uiNodeId_p,
+							(((NodeNmtState_p &
+							   0xFF) << 8)
+							 |
+							 kEplNmtCmdResetConfiguration));
+
+			// send NMT reset configuration to CN for activation of configuration
+			Ret =
+			    EplNmtMnuSendNmtCommand(uiNodeId_p,
+						    kEplNmtCmdResetConfiguration);
 
-            break;
-        }
-
-        case kEplNmtMnuIntNodeEventExecReset:
-        {
-            if (pNodeInfo->m_NodeState != kEplNmtMnuNodeStateIdentified)
-            {   // wrong CN state
-                // ignore event
-                break;
-            }
-
-            pNodeInfo->m_NodeState = kEplNmtMnuNodeStateResetConf;
-
-            EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
-                                            uiNodeId_p,
-                                            (((NodeNmtState_p & 0xFF) << 8)
-                                            | kEplNmtCmdResetConfiguration));
-
-            // send NMT reset configuration to CN for activation of configuration
-            Ret = EplNmtMnuSendNmtCommand(uiNodeId_p, kEplNmtCmdResetConfiguration);
-
-            break;
-        }
+			break;
+		}
 
-        case kEplNmtMnuIntNodeEventHeartbeat:
-        {
+	case kEplNmtMnuIntNodeEventHeartbeat:
+		{
 /*
             if ((NmtState >= kEplNmtMsPreOperational2)
                 && ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) != 0))
@@ -2273,290 +2296,318 @@ tEplTimerArg        TimerArg;
                 pNodeInfo->m_wFlags &= ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
             }
 */
-            // check NMT state of CN
-            Ret = EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo, NodeNmtState_p, wErrorCode_p, NmtState);
-            if (Ret != kEplSuccessful)
-            {
-                if (Ret == kEplReject)
-                {
-                    Ret = kEplSuccessful;
-                }
-                break;
-            }
-
-            break;
-        }
-
-        case kEplNmtMnuIntNodeEventTimerIdentReq:
-        {
-            EPL_DBGLVL_NMTMN_TRACE1("TimerStatReq->IdentReq(%02X)\n", uiNodeId_p);
-            // trigger IdentRequest again
-            Ret = EplIdentuRequestIdentResponse(uiNodeId_p, EplNmtMnuCbIdentResponse);
-            if (Ret != kEplSuccessful)
-            {
-                EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
-                                                uiNodeId_p,
-                                                (((NodeNmtState_p & 0xFF) << 8)
-                                                 | Ret));
-                if (Ret == kEplInvalidOperation)
-                {   // this can happen because of a bug in EplTimeruLinuxKernel.c
-                    // so ignore this error.
-                    Ret = kEplSuccessful;
-                }
-            }
-
-            break;
-        }
-
-        case kEplNmtMnuIntNodeEventTimerStateMon:
-        {
-            // reset NMT state change flag
-            // because from now on the CN must have the correct NMT state
-            pNodeInfo->m_wFlags &= ~EPL_NMTMNU_NODE_FLAG_NMT_CMD_ISSUED;
-
-            // continue with normal StatReq processing
-        }
-
-        case kEplNmtMnuIntNodeEventTimerStatReq:
-        {
-            EPL_DBGLVL_NMTMN_TRACE1("TimerStatReq->StatReq(%02X)\n", uiNodeId_p);
-            // request next StatusResponse
-            Ret = EplStatusuRequestStatusResponse(uiNodeId_p, EplNmtMnuCbStatusResponse);
-            if (Ret != kEplSuccessful)
-            {
-                EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
-                                                uiNodeId_p,
-                                                (((NodeNmtState_p & 0xFF) << 8)
-                                                 | Ret));
-                if (Ret == kEplInvalidOperation)
-                {   // the only situation when this should happen is, when
-                    // StatusResponse was already requested while processing
-                    // event IdentResponse.
-                    // so ignore this error.
-                    Ret = kEplSuccessful;
-                }
-            }
-
-            break;
-        }
-
-        case kEplNmtMnuIntNodeEventTimerLonger:
-        {
-            switch (pNodeInfo->m_NodeState)
-            {
-                case kEplNmtMnuNodeStateConfigured:
-                {   // node should be ReadyToOp but it is not
-
-                    // check NMT state which shall be intentionally wrong, so that ERROR_TREATMENT will be started
-                    Ret = EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo, kEplNmtCsNotActive, EPL_E_NMT_BPO2, NmtState);
-                    if (Ret != kEplSuccessful)
-                    {
-                        if (Ret == kEplReject)
-                        {
-                            Ret = kEplSuccessful;
-                        }
-                        break;
-                    }
-
-                    break;
-                }
-
-                case kEplNmtMnuNodeStateReadyToOp:
-                {   // CheckCom finished successfully
-
-                    pNodeInfo->m_NodeState = kEplNmtMnuNodeStateComChecked;
-
-                    if ((pNodeInfo->m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) != 0)
-                    {
-                        // decrement only signal slave count if checked once for ReadyToOp, CheckCom, Operational
-                        EplNmtMnuInstance_g.m_uiSignalSlaveCount--;
-                        pNodeInfo->m_wFlags &= ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
-                    }
-
-                    if ((pNodeInfo->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0)
-                    {
-                        // decrement mandatory slave counter
-                        EplNmtMnuInstance_g.m_uiMandatorySlaveCount--;
-                    }
-                    if (NmtState != kEplNmtMsReadyToOperate)
-                    {
-                        EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
-                                                        uiNodeId_p,
-                                                        (((NodeNmtState_p & 0xFF) << 8)
-                                                        | kEplNmtCmdStartNode));
-
-                        // start optional CN
-                        Ret = EplNmtMnuSendNmtCommand(uiNodeId_p, kEplNmtCmdStartNode);
-                    }
-                    break;
-                }
-
-                default:
-                {
-                    break;
-                }
-            }
-            break;
-        }
-
-        case kEplNmtMnuIntNodeEventNmtCmdSent:
-        {
-        BYTE    bNmtState;
-
-            // update expected NMT state with the one that results
-            // from the sent NMT command
-            bNmtState = (BYTE) (NodeNmtState_p & 0xFF);
-
-            // write object 0x1F8F NMT_MNNodeExpState_AU8
-            Ret = EplObduWriteEntry(0x1F8F, uiNodeId_p, &bNmtState, 1);
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-
-            if (NodeNmtState_p == kEplNmtCsNotActive)
-            {   // restart processing with IdentRequest
-                EPL_NMTMNU_SET_FLAGS_TIMERARG_IDENTREQ(
-                        pNodeInfo, uiNodeId_p, TimerArg);
-            }
-            else
-            {   // monitor NMT state change with StatusRequest after
-                // the corresponding delay;
-                // until then wrong NMT states will be ignored
-                EPL_NMTMNU_SET_FLAGS_TIMERARG_STATE_MON(
-                        pNodeInfo, uiNodeId_p, TimerArg);
-
-                // set NMT state change flag
-                pNodeInfo->m_wFlags |= EPL_NMTMNU_NODE_FLAG_NMT_CMD_ISSUED;
-            }
-
-            Ret = EplTimeruModifyTimerMs(&pNodeInfo->m_TimerHdlStatReq, EplNmtMnuInstance_g.m_ulStatusRequestDelay, TimerArg);
-
-            // finish processing, because NmtState_p is the expected and not the current state
-            goto Exit;
-        }
-
-        default:
-        {
-            break;
-        }
-    }
-
-    // check if network is ready to change local NMT state and this was not done before
-    if ((EplNmtMnuInstance_g.m_wFlags & (EPL_NMTMNU_FLAG_HALTED | EPL_NMTMNU_FLAG_APP_INFORMED)) == 0)
-    {   // boot process is not halted
-        switch (NmtState)
-        {
-            case kEplNmtMsPreOperational1:
-            {
-                if ((EplNmtMnuInstance_g.m_uiSignalSlaveCount == 0)
-                    && (EplNmtMnuInstance_g.m_uiMandatorySlaveCount == 0))
-                {   // all optional CNs scanned once and all mandatory CNs configured successfully
-                    EplNmtMnuInstance_g.m_wFlags |= EPL_NMTMNU_FLAG_APP_INFORMED;
-                    // inform application
-                    Ret = EplNmtMnuInstance_g.m_pfnCbBootEvent(kEplNmtBootEventBootStep1Finish,
-                                                               NmtState,
-                                                               EPL_E_NO_ERROR);
-                    if (Ret != kEplSuccessful)
-                    {
-                        if (Ret == kEplReject)
-                        {
-                            // wait for application
-                            Ret = kEplSuccessful;
-                        }
-                        break;
-                    }
-                    // enter PreOp2
-                    Ret = EplNmtuNmtEvent(kEplNmtEventAllMandatoryCNIdent);
-                }
-                break;
-            }
-
-            case kEplNmtMsPreOperational2:
-            {
-                if ((EplNmtMnuInstance_g.m_uiSignalSlaveCount == 0)
-                    && (EplNmtMnuInstance_g.m_uiMandatorySlaveCount == 0))
-                {   // all optional CNs checked once for ReadyToOp and all mandatory CNs are ReadyToOp
-                    EplNmtMnuInstance_g.m_wFlags |= EPL_NMTMNU_FLAG_APP_INFORMED;
-                    // inform application
-                    Ret = EplNmtMnuInstance_g.m_pfnCbBootEvent(kEplNmtBootEventBootStep2Finish,
-                                                               NmtState,
-                                                               EPL_E_NO_ERROR);
-                    if (Ret != kEplSuccessful)
-                    {
-                        if (Ret == kEplReject)
-                        {
-                            // wait for application
-                            Ret = kEplSuccessful;
-                        }
-                        break;
-                    }
-                    // enter ReadyToOp
-                    Ret = EplNmtuNmtEvent(kEplNmtEventEnterReadyToOperate);
-                }
-                break;
-            }
-
-            case kEplNmtMsReadyToOperate:
-            {
-                if ((EplNmtMnuInstance_g.m_uiSignalSlaveCount == 0)
-                    && (EplNmtMnuInstance_g.m_uiMandatorySlaveCount == 0))
-                {   // all CNs checked for errorless communication
-                    EplNmtMnuInstance_g.m_wFlags |= EPL_NMTMNU_FLAG_APP_INFORMED;
-                    // inform application
-                    Ret = EplNmtMnuInstance_g.m_pfnCbBootEvent(kEplNmtBootEventCheckComFinish,
-                                                               NmtState,
-                                                               EPL_E_NO_ERROR);
-                    if (Ret != kEplSuccessful)
-                    {
-                        if (Ret == kEplReject)
-                        {
-                            // wait for application
-                            Ret = kEplSuccessful;
-                        }
-                        break;
-                    }
-                    // enter Operational
-                    Ret = EplNmtuNmtEvent(kEplNmtEventEnterMsOperational);
-                }
-                break;
-            }
-
-            case kEplNmtMsOperational:
-            {
-                if ((EplNmtMnuInstance_g.m_uiSignalSlaveCount == 0)
-                    && (EplNmtMnuInstance_g.m_uiMandatorySlaveCount == 0))
-                {   // all optional CNs scanned once and all mandatory CNs are OPERATIONAL
-                    EplNmtMnuInstance_g.m_wFlags |= EPL_NMTMNU_FLAG_APP_INFORMED;
-                    // inform application
-                    Ret = EplNmtMnuInstance_g.m_pfnCbBootEvent(kEplNmtBootEventOperational,
-                                                               NmtState,
-                                                               EPL_E_NO_ERROR);
-                    if (Ret != kEplSuccessful)
-                    {
-                        if (Ret == kEplReject)
-                        {
-                            // ignore error code
-                            Ret = kEplSuccessful;
-                        }
-                        break;
-                    }
-                }
-                break;
-            }
+			// check NMT state of CN
+			Ret =
+			    EplNmtMnuCheckNmtState(uiNodeId_p, pNodeInfo,
+						   NodeNmtState_p, wErrorCode_p,
+						   NmtState);
+			if (Ret != kEplSuccessful) {
+				if (Ret == kEplReject) {
+					Ret = kEplSuccessful;
+				}
+				break;
+			}
+
+			break;
+		}
+
+	case kEplNmtMnuIntNodeEventTimerIdentReq:
+		{
+			EPL_DBGLVL_NMTMN_TRACE1
+			    ("TimerStatReq->IdentReq(%02X)\n", uiNodeId_p);
+			// trigger IdentRequest again
+			Ret =
+			    EplIdentuRequestIdentResponse(uiNodeId_p,
+							  EplNmtMnuCbIdentResponse);
+			if (Ret != kEplSuccessful) {
+				EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
+								uiNodeId_p,
+								(((NodeNmtState_p & 0xFF) << 8)
+								 | Ret));
+				if (Ret == kEplInvalidOperation) {	// this can happen because of a bug in EplTimeruLinuxKernel.c
+					// so ignore this error.
+					Ret = kEplSuccessful;
+				}
+			}
+
+			break;
+		}
+
+	case kEplNmtMnuIntNodeEventTimerStateMon:
+		{
+			// reset NMT state change flag
+			// because from now on the CN must have the correct NMT state
+			pNodeInfo->m_wFlags &=
+			    ~EPL_NMTMNU_NODE_FLAG_NMT_CMD_ISSUED;
+
+			// continue with normal StatReq processing
+		}
+
+	case kEplNmtMnuIntNodeEventTimerStatReq:
+		{
+			EPL_DBGLVL_NMTMN_TRACE1("TimerStatReq->StatReq(%02X)\n",
+						uiNodeId_p);
+			// request next StatusResponse
+			Ret =
+			    EplStatusuRequestStatusResponse(uiNodeId_p,
+							    EplNmtMnuCbStatusResponse);
+			if (Ret != kEplSuccessful) {
+				EPL_NMTMNU_DBG_POST_TRACE_VALUE(NodeEvent_p,
+								uiNodeId_p,
+								(((NodeNmtState_p & 0xFF) << 8)
+								 | Ret));
+				if (Ret == kEplInvalidOperation) {	// the only situation when this should happen is, when
+					// StatusResponse was already requested while processing
+					// event IdentResponse.
+					// so ignore this error.
+					Ret = kEplSuccessful;
+				}
+			}
+
+			break;
+		}
+
+	case kEplNmtMnuIntNodeEventTimerLonger:
+		{
+			switch (pNodeInfo->m_NodeState) {
+			case kEplNmtMnuNodeStateConfigured:
+				{	// node should be ReadyToOp but it is not
+
+					// check NMT state which shall be intentionally wrong, so that ERROR_TREATMENT will be started
+					Ret =
+					    EplNmtMnuCheckNmtState(uiNodeId_p,
+								   pNodeInfo,
+								   kEplNmtCsNotActive,
+								   EPL_E_NMT_BPO2,
+								   NmtState);
+					if (Ret != kEplSuccessful) {
+						if (Ret == kEplReject) {
+							Ret = kEplSuccessful;
+						}
+						break;
+					}
+
+					break;
+				}
+
+			case kEplNmtMnuNodeStateReadyToOp:
+				{	// CheckCom finished successfully
+
+					pNodeInfo->m_NodeState =
+					    kEplNmtMnuNodeStateComChecked;
+
+					if ((pNodeInfo->
+					     m_wFlags &
+					     EPL_NMTMNU_NODE_FLAG_NOT_SCANNED)
+					    != 0) {
+						// decrement only signal slave count if checked once for ReadyToOp, CheckCom, Operational
+						EplNmtMnuInstance_g.
+						    m_uiSignalSlaveCount--;
+						pNodeInfo->m_wFlags &=
+						    ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
+					}
+
+					if ((pNodeInfo->
+					     m_dwNodeCfg &
+					     EPL_NODEASSIGN_MANDATORY_CN) !=
+					    0) {
+						// decrement mandatory slave counter
+						EplNmtMnuInstance_g.
+						    m_uiMandatorySlaveCount--;
+					}
+					if (NmtState != kEplNmtMsReadyToOperate) {
+						EPL_NMTMNU_DBG_POST_TRACE_VALUE
+						    (NodeEvent_p, uiNodeId_p,
+						     (((NodeNmtState_p & 0xFF)
+						       << 8)
+						      | kEplNmtCmdStartNode));
+
+						// start optional CN
+						Ret =
+						    EplNmtMnuSendNmtCommand
+						    (uiNodeId_p,
+						     kEplNmtCmdStartNode);
+					}
+					break;
+				}
+
+			default:
+				{
+					break;
+				}
+			}
+			break;
+		}
+
+	case kEplNmtMnuIntNodeEventNmtCmdSent:
+		{
+			BYTE bNmtState;
+
+			// update expected NMT state with the one that results
+			// from the sent NMT command
+			bNmtState = (BYTE) (NodeNmtState_p & 0xFF);
+
+			// write object 0x1F8F NMT_MNNodeExpState_AU8
+			Ret =
+			    EplObduWriteEntry(0x1F8F, uiNodeId_p, &bNmtState,
+					      1);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+
+			if (NodeNmtState_p == kEplNmtCsNotActive) {	// restart processing with IdentRequest
+				EPL_NMTMNU_SET_FLAGS_TIMERARG_IDENTREQ
+				    (pNodeInfo, uiNodeId_p, TimerArg);
+			} else {	// monitor NMT state change with StatusRequest after
+				// the corresponding delay;
+				// until then wrong NMT states will be ignored
+				EPL_NMTMNU_SET_FLAGS_TIMERARG_STATE_MON
+				    (pNodeInfo, uiNodeId_p, TimerArg);
+
+				// set NMT state change flag
+				pNodeInfo->m_wFlags |=
+				    EPL_NMTMNU_NODE_FLAG_NMT_CMD_ISSUED;
+			}
+
+			Ret =
+			    EplTimeruModifyTimerMs(&pNodeInfo->
+						   m_TimerHdlStatReq,
+						   EplNmtMnuInstance_g.
+						   m_ulStatusRequestDelay,
+						   TimerArg);
+
+			// finish processing, because NmtState_p is the expected and not the current state
+			goto Exit;
+		}
+
+	default:
+		{
+			break;
+		}
+	}
+
+	// check if network is ready to change local NMT state and this was not done before
+	if ((EplNmtMnuInstance_g.m_wFlags & (EPL_NMTMNU_FLAG_HALTED | EPL_NMTMNU_FLAG_APP_INFORMED)) == 0) {	// boot process is not halted
+		switch (NmtState) {
+		case kEplNmtMsPreOperational1:
+			{
+				if ((EplNmtMnuInstance_g.m_uiSignalSlaveCount ==
+				     0)
+				    && (EplNmtMnuInstance_g.m_uiMandatorySlaveCount == 0)) {	// all optional CNs scanned once and all mandatory CNs configured successfully
+					EplNmtMnuInstance_g.m_wFlags |=
+					    EPL_NMTMNU_FLAG_APP_INFORMED;
+					// inform application
+					Ret =
+					    EplNmtMnuInstance_g.
+					    m_pfnCbBootEvent
+					    (kEplNmtBootEventBootStep1Finish,
+					     NmtState, EPL_E_NO_ERROR);
+					if (Ret != kEplSuccessful) {
+						if (Ret == kEplReject) {
+							// wait for application
+							Ret = kEplSuccessful;
+						}
+						break;
+					}
+					// enter PreOp2
+					Ret =
+					    EplNmtuNmtEvent
+					    (kEplNmtEventAllMandatoryCNIdent);
+				}
+				break;
+			}
+
+		case kEplNmtMsPreOperational2:
+			{
+				if ((EplNmtMnuInstance_g.m_uiSignalSlaveCount ==
+				     0)
+				    && (EplNmtMnuInstance_g.m_uiMandatorySlaveCount == 0)) {	// all optional CNs checked once for ReadyToOp and all mandatory CNs are ReadyToOp
+					EplNmtMnuInstance_g.m_wFlags |=
+					    EPL_NMTMNU_FLAG_APP_INFORMED;
+					// inform application
+					Ret =
+					    EplNmtMnuInstance_g.
+					    m_pfnCbBootEvent
+					    (kEplNmtBootEventBootStep2Finish,
+					     NmtState, EPL_E_NO_ERROR);
+					if (Ret != kEplSuccessful) {
+						if (Ret == kEplReject) {
+							// wait for application
+							Ret = kEplSuccessful;
+						}
+						break;
+					}
+					// enter ReadyToOp
+					Ret =
+					    EplNmtuNmtEvent
+					    (kEplNmtEventEnterReadyToOperate);
+				}
+				break;
+			}
+
+		case kEplNmtMsReadyToOperate:
+			{
+				if ((EplNmtMnuInstance_g.m_uiSignalSlaveCount ==
+				     0)
+				    && (EplNmtMnuInstance_g.m_uiMandatorySlaveCount == 0)) {	// all CNs checked for errorless communication
+					EplNmtMnuInstance_g.m_wFlags |=
+					    EPL_NMTMNU_FLAG_APP_INFORMED;
+					// inform application
+					Ret =
+					    EplNmtMnuInstance_g.
+					    m_pfnCbBootEvent
+					    (kEplNmtBootEventCheckComFinish,
+					     NmtState, EPL_E_NO_ERROR);
+					if (Ret != kEplSuccessful) {
+						if (Ret == kEplReject) {
+							// wait for application
+							Ret = kEplSuccessful;
+						}
+						break;
+					}
+					// enter Operational
+					Ret =
+					    EplNmtuNmtEvent
+					    (kEplNmtEventEnterMsOperational);
+				}
+				break;
+			}
+
+		case kEplNmtMsOperational:
+			{
+				if ((EplNmtMnuInstance_g.m_uiSignalSlaveCount ==
+				     0)
+				    && (EplNmtMnuInstance_g.m_uiMandatorySlaveCount == 0)) {	// all optional CNs scanned once and all mandatory CNs are OPERATIONAL
+					EplNmtMnuInstance_g.m_wFlags |=
+					    EPL_NMTMNU_FLAG_APP_INFORMED;
+					// inform application
+					Ret =
+					    EplNmtMnuInstance_g.
+					    m_pfnCbBootEvent
+					    (kEplNmtBootEventOperational,
+					     NmtState, EPL_E_NO_ERROR);
+					if (Ret != kEplSuccessful) {
+						if (Ret == kEplReject) {
+							// ignore error code
+							Ret = kEplSuccessful;
+						}
+						break;
+					}
+				}
+				break;
+			}
+
+		default:
+			{
+				break;
+			}
+		}
+	}
 
-            default:
-            {
-                break;
-            }
-        }
-    }
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplNmtMnuCheckNmtState
@@ -2576,188 +2627,172 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplNmtMnuCheckNmtState(
-                                    unsigned int        uiNodeId_p,
-                                    tEplNmtMnuNodeInfo* pNodeInfo_p,
-                                    tEplNmtState        NodeNmtState_p,
-                                    WORD                wErrorCode_p,
-                                    tEplNmtState        LocalNmtState_p)
-{
-tEplKernel      Ret = kEplSuccessful;
-tEplObdSize     ObdSize;
-BYTE            bNmtState;
-BYTE            bNmtStatePrev;
-tEplNmtState    ExpNmtState;
-
-    ObdSize = 1;
-    // read object 0x1F8F NMT_MNNodeExpState_AU8
-    Ret = EplObduReadEntry(0x1F8F, uiNodeId_p, &bNmtState, &ObdSize);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // compute expected NMT state
-    ExpNmtState = (tEplNmtState) (bNmtState | EPL_NMT_TYPE_CS);
-    // compute BYTE of current NMT state
-    bNmtState = ((BYTE) NodeNmtState_p & 0xFF);
-
-    if (ExpNmtState == kEplNmtCsNotActive)
-    {   // ignore the current state, because the CN shall be not active
-        Ret = kEplReject;
-        goto Exit;
-    }
-    else if ((ExpNmtState == kEplNmtCsPreOperational2)
-         && (NodeNmtState_p == kEplNmtCsReadyToOperate))
-    {   // CN switched to ReadyToOp
-        // delete timer for timeout handling
-        Ret = EplTimeruDeleteTimer(&pNodeInfo_p->m_TimerHdlLonger);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        pNodeInfo_p->m_NodeState = kEplNmtMnuNodeStateReadyToOp;
-
-        // update object 0x1F8F NMT_MNNodeExpState_AU8 to ReadyToOp
-        Ret = EplObduWriteEntry(0x1F8F, uiNodeId_p, &bNmtState, 1);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        if ((pNodeInfo_p->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0)
-        {   // node is a mandatory CN -> decrement counter
-            EplNmtMnuInstance_g.m_uiMandatorySlaveCount--;
-        }
-        if (LocalNmtState_p >= kEplNmtMsReadyToOperate)
-        {   // start procedure CheckCommunication for this node
-            Ret = EplNmtMnuNodeCheckCom(uiNodeId_p, pNodeInfo_p);
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
+static tEplKernel EplNmtMnuCheckNmtState(unsigned int uiNodeId_p,
+					 tEplNmtMnuNodeInfo * pNodeInfo_p,
+					 tEplNmtState NodeNmtState_p,
+					 WORD wErrorCode_p,
+					 tEplNmtState LocalNmtState_p)
+{
+	tEplKernel Ret = kEplSuccessful;
+	tEplObdSize ObdSize;
+	BYTE bNmtState;
+	BYTE bNmtStatePrev;
+	tEplNmtState ExpNmtState;
+
+	ObdSize = 1;
+	// read object 0x1F8F NMT_MNNodeExpState_AU8
+	Ret = EplObduReadEntry(0x1F8F, uiNodeId_p, &bNmtState, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// compute expected NMT state
+	ExpNmtState = (tEplNmtState) (bNmtState | EPL_NMT_TYPE_CS);
+	// compute BYTE of current NMT state
+	bNmtState = ((BYTE) NodeNmtState_p & 0xFF);
+
+	if (ExpNmtState == kEplNmtCsNotActive) {	// ignore the current state, because the CN shall be not active
+		Ret = kEplReject;
+		goto Exit;
+	} else if ((ExpNmtState == kEplNmtCsPreOperational2)
+		   && (NodeNmtState_p == kEplNmtCsReadyToOperate)) {	// CN switched to ReadyToOp
+		// delete timer for timeout handling
+		Ret = EplTimeruDeleteTimer(&pNodeInfo_p->m_TimerHdlLonger);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		pNodeInfo_p->m_NodeState = kEplNmtMnuNodeStateReadyToOp;
+
+		// update object 0x1F8F NMT_MNNodeExpState_AU8 to ReadyToOp
+		Ret = EplObduWriteEntry(0x1F8F, uiNodeId_p, &bNmtState, 1);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+
+		if ((pNodeInfo_p->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0) {	// node is a mandatory CN -> decrement counter
+			EplNmtMnuInstance_g.m_uiMandatorySlaveCount--;
+		}
+		if (LocalNmtState_p >= kEplNmtMsReadyToOperate) {	// start procedure CheckCommunication for this node
+			Ret = EplNmtMnuNodeCheckCom(uiNodeId_p, pNodeInfo_p);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+
+			if ((LocalNmtState_p == kEplNmtMsOperational)
+			    && (pNodeInfo_p->m_NodeState ==
+				kEplNmtMnuNodeStateComChecked)) {
+				EPL_NMTMNU_DBG_POST_TRACE_VALUE(0, uiNodeId_p,
+								(((NodeNmtState_p & 0xFF) << 8)
+								 |
+								 kEplNmtCmdStartNode));
+
+				// immediately start optional CN, because communication is always OK (e.g. async-only CN)
+				Ret =
+				    EplNmtMnuSendNmtCommand(uiNodeId_p,
+							    kEplNmtCmdStartNode);
+				if (Ret != kEplSuccessful) {
+					goto Exit;
+				}
+			}
+		}
+
+	} else if ((ExpNmtState == kEplNmtCsReadyToOperate)
+		   && (NodeNmtState_p == kEplNmtCsOperational)) {	// CN switched to OPERATIONAL
+		pNodeInfo_p->m_NodeState = kEplNmtMnuNodeStateOperational;
+
+		if ((pNodeInfo_p->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0) {	// node is a mandatory CN -> decrement counter
+			EplNmtMnuInstance_g.m_uiMandatorySlaveCount--;
+		}
+
+	} else if ((ExpNmtState != NodeNmtState_p)
+		   && !((ExpNmtState == kEplNmtCsPreOperational1)
+			&& (NodeNmtState_p == kEplNmtCsPreOperational2))) {	// CN is not in expected NMT state (without the exceptions above)
+		WORD wbeErrorCode;
+
+		if ((pNodeInfo_p->
+		     m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) != 0) {
+			// decrement only signal slave count if checked once
+			EplNmtMnuInstance_g.m_uiSignalSlaveCount--;
+			pNodeInfo_p->m_wFlags &=
+			    ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
+		}
+
+		if (pNodeInfo_p->m_NodeState == kEplNmtMnuNodeStateUnknown) {	// CN is already in state unknown, which means that it got
+			// NMT reset command earlier
+			goto Exit;
+		}
+		// -> CN is in wrong NMT state
+		pNodeInfo_p->m_NodeState = kEplNmtMnuNodeStateUnknown;
+
+		if (wErrorCode_p == 0) {	// assume wrong NMT state error
+			if ((pNodeInfo_p->m_wFlags & EPL_NMTMNU_NODE_FLAG_NMT_CMD_ISSUED) != 0) {	// NMT command has been just issued;
+				// ignore wrong NMT state until timer expires;
+				// other errors like LOSS_PRES_TH are still processed
+				goto Exit;
+			}
+
+			wErrorCode_p = EPL_E_NMT_WRONG_STATE;
+		}
+
+		BENCHMARK_MOD_07_TOGGLE(9);
+
+		// $$$ start ERROR_TREATMENT and inform application
+		Ret = EplNmtMnuInstance_g.m_pfnCbNodeEvent(uiNodeId_p,
+							   kEplNmtNodeEventError,
+							   NodeNmtState_p,
+							   wErrorCode_p,
+							   (pNodeInfo_p->
+							    m_dwNodeCfg &
+							    EPL_NODEASSIGN_MANDATORY_CN)
+							   != 0);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+
+		EPL_NMTMNU_DBG_POST_TRACE_VALUE(0,
+						uiNodeId_p,
+						(((NodeNmtState_p & 0xFF) << 8)
+						 | kEplNmtCmdResetNode));
+
+		// reset CN
+		// store error code in NMT command data for diagnostic purpose
+		AmiSetWordToLe(&wbeErrorCode, wErrorCode_p);
+		Ret =
+		    EplNmtMnuSendNmtCommandEx(uiNodeId_p, kEplNmtCmdResetNode,
+					      &wbeErrorCode,
+					      sizeof(wbeErrorCode));
+		if (Ret == kEplSuccessful) {
+			Ret = kEplReject;
+		}
+
+		goto Exit;
+	}
+	// check if NMT_MNNodeCurrState_AU8 has to be changed
+	ObdSize = 1;
+	Ret = EplObduReadEntry(0x1F8E, uiNodeId_p, &bNmtStatePrev, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	if (bNmtState != bNmtStatePrev) {
+		// update object 0x1F8E NMT_MNNodeCurrState_AU8
+		Ret = EplObduWriteEntry(0x1F8E, uiNodeId_p, &bNmtState, 1);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		Ret = EplNmtMnuInstance_g.m_pfnCbNodeEvent(uiNodeId_p,
+							   kEplNmtNodeEventNmtState,
+							   NodeNmtState_p,
+							   wErrorCode_p,
+							   (pNodeInfo_p->
+							    m_dwNodeCfg &
+							    EPL_NODEASSIGN_MANDATORY_CN)
+							   != 0);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+	}
 
-            if ((LocalNmtState_p == kEplNmtMsOperational)
-                && (pNodeInfo_p->m_NodeState == kEplNmtMnuNodeStateComChecked))
-            {
-                EPL_NMTMNU_DBG_POST_TRACE_VALUE(0,
-                                                uiNodeId_p,
-                                                (((NodeNmtState_p & 0xFF) << 8)
-                                                | kEplNmtCmdStartNode));
-
-                // immediately start optional CN, because communication is always OK (e.g. async-only CN)
-                Ret = EplNmtMnuSendNmtCommand(uiNodeId_p, kEplNmtCmdStartNode);
-                if (Ret != kEplSuccessful)
-                {
-                    goto Exit;
-                }
-            }
-        }
-
-    }
-    else if ((ExpNmtState == kEplNmtCsReadyToOperate)
-             && (NodeNmtState_p == kEplNmtCsOperational))
-    {   // CN switched to OPERATIONAL
-        pNodeInfo_p->m_NodeState = kEplNmtMnuNodeStateOperational;
-
-        if ((pNodeInfo_p->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0)
-        {   // node is a mandatory CN -> decrement counter
-            EplNmtMnuInstance_g.m_uiMandatorySlaveCount--;
-        }
-
-    }
-    else if ((ExpNmtState != NodeNmtState_p)
-             && !((ExpNmtState == kEplNmtCsPreOperational1)
-                  && (NodeNmtState_p == kEplNmtCsPreOperational2)))
-    {   // CN is not in expected NMT state (without the exceptions above)
-    WORD wbeErrorCode;
-
-        if ((pNodeInfo_p->m_wFlags & EPL_NMTMNU_NODE_FLAG_NOT_SCANNED) != 0)
-        {
-            // decrement only signal slave count if checked once
-            EplNmtMnuInstance_g.m_uiSignalSlaveCount--;
-            pNodeInfo_p->m_wFlags &= ~EPL_NMTMNU_NODE_FLAG_NOT_SCANNED;
-        }
-
-        if (pNodeInfo_p->m_NodeState == kEplNmtMnuNodeStateUnknown)
-        {   // CN is already in state unknown, which means that it got
-            // NMT reset command earlier
-            goto Exit;
-        }
-
-        // -> CN is in wrong NMT state
-        pNodeInfo_p->m_NodeState = kEplNmtMnuNodeStateUnknown;
-
-        if (wErrorCode_p == 0)
-        {   // assume wrong NMT state error
-            if ((pNodeInfo_p->m_wFlags & EPL_NMTMNU_NODE_FLAG_NMT_CMD_ISSUED) != 0)
-            {   // NMT command has been just issued;
-                // ignore wrong NMT state until timer expires;
-                // other errors like LOSS_PRES_TH are still processed
-                goto Exit;
-            }
-
-            wErrorCode_p = EPL_E_NMT_WRONG_STATE;
-        }
-
-        BENCHMARK_MOD_07_TOGGLE(9);
-
-        // $$$ start ERROR_TREATMENT and inform application
-        Ret = EplNmtMnuInstance_g.m_pfnCbNodeEvent(uiNodeId_p,
-                                                   kEplNmtNodeEventError,
-                                                   NodeNmtState_p,
-                                                   wErrorCode_p,
-                                                   (pNodeInfo_p->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        EPL_NMTMNU_DBG_POST_TRACE_VALUE(0,
-                                        uiNodeId_p,
-                                        (((NodeNmtState_p & 0xFF) << 8)
-                                        | kEplNmtCmdResetNode));
-
-        // reset CN
-        // store error code in NMT command data for diagnostic purpose
-        AmiSetWordToLe(&wbeErrorCode, wErrorCode_p);
-        Ret = EplNmtMnuSendNmtCommandEx(uiNodeId_p, kEplNmtCmdResetNode, &wbeErrorCode, sizeof (wbeErrorCode));
-        if (Ret == kEplSuccessful)
-        {
-            Ret = kEplReject;
-        }
-
-        goto Exit;
-    }
-
-    // check if NMT_MNNodeCurrState_AU8 has to be changed
-    ObdSize = 1;
-    Ret = EplObduReadEntry(0x1F8E, uiNodeId_p, &bNmtStatePrev, &ObdSize);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-    if (bNmtState != bNmtStatePrev)
-    {
-        // update object 0x1F8E NMT_MNNodeCurrState_AU8
-        Ret = EplObduWriteEntry(0x1F8E, uiNodeId_p, &bNmtState, 1);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-        Ret = EplNmtMnuInstance_g.m_pfnCbNodeEvent(uiNodeId_p,
-                                               kEplNmtNodeEventNmtState,
-                                               NodeNmtState_p,
-                                               wErrorCode_p,
-                                               (pNodeInfo_p->m_dwNodeCfg & EPL_NODEASSIGN_MANDATORY_CN) != 0);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-    }
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -2776,23 +2811,25 @@ Exit:
 
 static tEplKernel EplNmtMnuReset(void)
 {
-tEplKernel  Ret;
-int         iIndex;
+	tEplKernel Ret;
+	int iIndex;
 
-    Ret = EplTimeruDeleteTimer(&EplNmtMnuInstance_g.m_TimerHdlNmtState);
+	Ret = EplTimeruDeleteTimer(&EplNmtMnuInstance_g.m_TimerHdlNmtState);
 
-    for (iIndex = 1; iIndex <= tabentries (EplNmtMnuInstance_g.m_aNodeInfo); iIndex++)
-    {
-        // delete timer handles
-        Ret = EplTimeruDeleteTimer(&EPL_NMTMNU_GET_NODEINFO(iIndex)->m_TimerHdlStatReq);
-        Ret = EplTimeruDeleteTimer(&EPL_NMTMNU_GET_NODEINFO(iIndex)->m_TimerHdlLonger);
-    }
+	for (iIndex = 1; iIndex <= tabentries(EplNmtMnuInstance_g.m_aNodeInfo);
+	     iIndex++) {
+		// delete timer handles
+		Ret =
+		    EplTimeruDeleteTimer(&EPL_NMTMNU_GET_NODEINFO(iIndex)->
+					 m_TimerHdlStatReq);
+		Ret =
+		    EplTimeruDeleteTimer(&EPL_NMTMNU_GET_NODEINFO(iIndex)->
+					 m_TimerHdlLonger);
+	}
 
-    return Ret;
+	return Ret;
 }
 
-
 #endif // #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
 // EOF
-
--- a/drivers/staging/epl/EplNmtu.c
+++ b/drivers/staging/epl/EplNmtu.c
@@ -68,7 +68,6 @@
 
 ****************************************************************************/
 
-
 #include "EplInc.h"
 #include "user/EplNmtu.h"
 #include "user/EplObdu.h"
@@ -94,10 +93,9 @@
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    tEplNmtuStateChangeCallback     m_pfnNmtChangeCb;
-    tEplTimerHdl                    m_TimerHdl;
+typedef struct {
+	tEplNmtuStateChangeCallback m_pfnNmtChangeCb;
+	tEplTimerHdl m_TimerHdl;
 
 } tEplNmtuInstance;
 
@@ -136,11 +134,11 @@ static tEplNmtuInstance EplNmtuInstance_
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtuInit()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = EplNmtuAddInstance();
+	Ret = EplNmtuAddInstance();
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -162,13 +160,13 @@ tEplKernel Ret;
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtuAddInstance()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    EplNmtuInstance_g.m_pfnNmtChangeCb = NULL;
+	EplNmtuInstance_g.m_pfnNmtChangeCb = NULL;
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -191,16 +189,16 @@ tEplKernel Ret;
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtuDelInstance()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    EplNmtuInstance_g.m_pfnNmtChangeCb = NULL;
+	EplNmtuInstance_g.m_pfnNmtChangeCb = NULL;
 
-    // delete timer
-    Ret = EplTimeruDeleteTimer(&EplNmtuInstance_g.m_TimerHdl);
+	// delete timer
+	Ret = EplTimeruDeleteTimer(&EplNmtuInstance_g.m_TimerHdl);
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -223,20 +221,19 @@ tEplKernel Ret;
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplNmtuNmtEvent(tEplNmtEvent NmtEvent_p)
 {
-tEplKernel  Ret;
-tEplEvent   Event;
-
-    Event.m_EventSink = kEplEventSinkNmtk;
-    Event.m_NetTime.m_dwNanoSec = 0;
-    Event.m_NetTime.m_dwSec = 0;
-    Event.m_EventType = kEplEventTypeNmtEvent;
-    Event.m_pArg = &NmtEvent_p;
-    Event.m_uiSize = sizeof(NmtEvent_p);
+	tEplKernel Ret;
+	tEplEvent Event;
 
-    Ret = EplEventuPost(&Event);
+	Event.m_EventSink = kEplEventSinkNmtk;
+	Event.m_NetTime.m_dwNanoSec = 0;
+	Event.m_NetTime.m_dwSec = 0;
+	Event.m_EventType = kEplEventTypeNmtEvent;
+	Event.m_pArg = &NmtEvent_p;
+	Event.m_uiSize = sizeof(NmtEvent_p);
 
+	Ret = EplEventuPost(&Event);
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -258,16 +255,16 @@ tEplEvent   Event;
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplNmtState PUBLIC EplNmtuGetNmtState()
 {
-tEplNmtState    NmtState;
+	tEplNmtState NmtState;
 
-    // $$$ call function of communication abstraction layer
+	// $$$ call function of communication abstraction layer
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTK)) != 0)
-    NmtState = EplNmtkGetNmtState();
+	NmtState = EplNmtkGetNmtState();
 #else
-    NmtState = 0;
+	NmtState = 0;
 #endif
 
-    return NmtState;
+	return NmtState;
 }
 
 //---------------------------------------------------------------------------
@@ -287,335 +284,366 @@ tEplNmtState    NmtState;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplNmtuProcessEvent(
-            tEplEvent* pEplEvent_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplNmtuProcessEvent(tEplEvent * pEplEvent_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // process event
-    switch(pEplEvent_p->m_EventType)
-    {
-        // state change of NMT-Module
-        case kEplEventTypeNmtStateChange:
-        {
-        tEplEventNmtStateChange* pNmtStateChange;
-
-            // delete timer
-            Ret = EplTimeruDeleteTimer(&EplNmtuInstance_g.m_TimerHdl);
-
-            pNmtStateChange = (tEplEventNmtStateChange*)pEplEvent_p->m_pArg;
-
-            // call cb-functions to inform higher layer
-            if(EplNmtuInstance_g.m_pfnNmtChangeCb != NULL)
-            {
-                Ret = EplNmtuInstance_g.m_pfnNmtChangeCb(*pNmtStateChange);
-            }
-
-            if (Ret == kEplSuccessful)
-            {   // everything is OK, so switch to next state if necessary
-                switch (pNmtStateChange->m_NewNmtState)
-                {
-                    // EPL stack is not running
-                    case kEplNmtGsOff:
-                        break;
-
-                    // first init of the hardware
-                    case kEplNmtGsInitialising:
-                    {
-                        Ret = EplNmtuNmtEvent(kEplNmtEventEnterResetApp);
-                        break;
-                    }
-
-                    // init of the manufacturer-specific profile area and the
-                    // standardised device profile area
-                    case kEplNmtGsResetApplication:
-                    {
-                        Ret = EplNmtuNmtEvent(kEplNmtEventEnterResetCom);
-                        break;
-                    }
-
-                    // init of the communication profile area
-                    case kEplNmtGsResetCommunication:
-                    {
-                        Ret = EplNmtuNmtEvent(kEplNmtEventEnterResetConfig);
-                        break;
-                    }
-
-                    // build the configuration with infos from OD
-                    case kEplNmtGsResetConfiguration:
-                    {
-                    unsigned int uiNodeId;
+	// process event
+	switch (pEplEvent_p->m_EventType) {
+		// state change of NMT-Module
+	case kEplEventTypeNmtStateChange:
+		{
+			tEplEventNmtStateChange *pNmtStateChange;
+
+			// delete timer
+			Ret =
+			    EplTimeruDeleteTimer(&EplNmtuInstance_g.m_TimerHdl);
+
+			pNmtStateChange =
+			    (tEplEventNmtStateChange *) pEplEvent_p->m_pArg;
+
+			// call cb-functions to inform higher layer
+			if (EplNmtuInstance_g.m_pfnNmtChangeCb != NULL) {
+				Ret =
+				    EplNmtuInstance_g.
+				    m_pfnNmtChangeCb(*pNmtStateChange);
+			}
+
+			if (Ret == kEplSuccessful) {	// everything is OK, so switch to next state if necessary
+				switch (pNmtStateChange->m_NewNmtState) {
+					// EPL stack is not running
+				case kEplNmtGsOff:
+					break;
+
+					// first init of the hardware
+				case kEplNmtGsInitialising:
+					{
+						Ret =
+						    EplNmtuNmtEvent
+						    (kEplNmtEventEnterResetApp);
+						break;
+					}
+
+					// init of the manufacturer-specific profile area and the
+					// standardised device profile area
+				case kEplNmtGsResetApplication:
+					{
+						Ret =
+						    EplNmtuNmtEvent
+						    (kEplNmtEventEnterResetCom);
+						break;
+					}
+
+					// init of the communication profile area
+				case kEplNmtGsResetCommunication:
+					{
+						Ret =
+						    EplNmtuNmtEvent
+						    (kEplNmtEventEnterResetConfig);
+						break;
+					}
+
+					// build the configuration with infos from OD
+				case kEplNmtGsResetConfiguration:
+					{
+						unsigned int uiNodeId;
 
-                        // get node ID from OD
+						// get node ID from OD
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0) || (EPL_OBD_USE_KERNEL != FALSE)
-                        uiNodeId = EplObduGetNodeId(EPL_MCO_PTR_INSTANCE_PTR);
+						uiNodeId =
+						    EplObduGetNodeId
+						    (EPL_MCO_PTR_INSTANCE_PTR);
 #else
-                        uiNodeId = 0;
+						uiNodeId = 0;
 #endif
-                        //check node ID if not should be master or slave
-                        if (uiNodeId == EPL_C_ADR_MN_DEF_NODE_ID)
-                        {   // node shall be MN
+						//check node ID if not should be master or slave
+						if (uiNodeId == EPL_C_ADR_MN_DEF_NODE_ID) {	// node shall be MN
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-                            Ret = EplNmtuNmtEvent(kEplNmtEventEnterMsNotActive);
+							Ret =
+							    EplNmtuNmtEvent
+							    (kEplNmtEventEnterMsNotActive);
 #else
-                            TRACE0("EplNmtuProcess(): no MN functionality implemented\n");
+							TRACE0
+							    ("EplNmtuProcess(): no MN functionality implemented\n");
 #endif
-                        }
-                        else
-                        {   // node shall be CN
-                            Ret = EplNmtuNmtEvent(kEplNmtEventEnterCsNotActive);
-                        }
-                        break;
-                    }
-
-                    //-----------------------------------------------------------
-                    // CN part of the state machine
-
-                    // node listens for EPL-Frames and check timeout
-                    case kEplNmtCsNotActive:
-                    {
-                    DWORD           dwBuffer;
-                    tEplObdSize     ObdSize;
-                    tEplTimerArg    TimerArg;
+						} else {	// node shall be CN
+							Ret =
+							    EplNmtuNmtEvent
+							    (kEplNmtEventEnterCsNotActive);
+						}
+						break;
+					}
+
+					//-----------------------------------------------------------
+					// CN part of the state machine
+
+					// node listens for EPL-Frames and check timeout
+				case kEplNmtCsNotActive:
+					{
+						DWORD dwBuffer;
+						tEplObdSize ObdSize;
+						tEplTimerArg TimerArg;
 
-                        // create timer to switch automatically to BasicEthernet if no MN available in network
+						// create timer to switch automatically to BasicEthernet if no MN available in network
 
-                        // read NMT_CNBasicEthernetTimerout_U32 from OD
-                        ObdSize = sizeof(dwBuffer);
+						// read NMT_CNBasicEthernetTimerout_U32 from OD
+						ObdSize = sizeof(dwBuffer);
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0) || (EPL_OBD_USE_KERNEL != FALSE)
-                        Ret = EplObduReadEntry(EPL_MCO_PTR_INSTANCE_PTR_
-                                                0x1F99,
-                                                0x00,
-                                                &dwBuffer,
-                                                &ObdSize);
+						Ret =
+						    EplObduReadEntry
+						    (EPL_MCO_PTR_INSTANCE_PTR_
+						     0x1F99, 0x00, &dwBuffer,
+						     &ObdSize);
 #else
-                        Ret = kEplObdIndexNotExist;
+						Ret = kEplObdIndexNotExist;
 #endif
-                        if(Ret != kEplSuccessful)
-                        {
-                            break;
-                        }
-                        if (dwBuffer != 0)
-                        {   // BasicEthernet is enabled
-                            // convert us into ms
-                            dwBuffer = dwBuffer / 1000;
-                            if (dwBuffer == 0)
-                            {   // timer was below one ms
-                                // set one ms
-                                dwBuffer = 1;
-                            }
-                            TimerArg.m_EventSink = kEplEventSinkNmtk;
-                            TimerArg.m_ulArg = (unsigned long) kEplNmtEventTimerBasicEthernet;
-                            Ret = EplTimeruModifyTimerMs(&EplNmtuInstance_g.m_TimerHdl, (unsigned long) dwBuffer, TimerArg);
-                            // potential error is forwarded to event queue which generates error event
-                        }
-                        break;
-                    }
-
-                    // node processes only async frames
-                    case kEplNmtCsPreOperational1:
-                    {
-                        break;
-                    }
-
-                    // node processes isochronous and asynchronous frames
-                    case kEplNmtCsPreOperational2:
-                    {
-                        Ret = EplNmtuNmtEvent(kEplNmtEventEnterReadyToOperate);
-                        break;
-                    }
-
-                    // node should be configured und application is ready
-                    case kEplNmtCsReadyToOperate:
-                    {
-                        break;
-                    }
-
-                    // normal work state
-                    case kEplNmtCsOperational:
-                    {
-                        break;
-                    }
-
-                    // node stopped by MN
-                    // -> only process asynchronous frames
-                    case kEplNmtCsStopped:
-                    {
-                        break;
-                    }
-
-                    // no EPL cycle
-                    // -> normal ethernet communication
-                    case kEplNmtCsBasicEthernet:
-                    {
-                        break;
-                    }
+						if (Ret != kEplSuccessful) {
+							break;
+						}
+						if (dwBuffer != 0) {	// BasicEthernet is enabled
+							// convert us into ms
+							dwBuffer =
+							    dwBuffer / 1000;
+							if (dwBuffer == 0) {	// timer was below one ms
+								// set one ms
+								dwBuffer = 1;
+							}
+							TimerArg.m_EventSink =
+							    kEplEventSinkNmtk;
+							TimerArg.m_ulArg =
+							    (unsigned long)
+							    kEplNmtEventTimerBasicEthernet;
+							Ret =
+							    EplTimeruModifyTimerMs
+							    (&EplNmtuInstance_g.
+							     m_TimerHdl,
+							     (unsigned long)
+							     dwBuffer,
+							     TimerArg);
+							// potential error is forwarded to event queue which generates error event
+						}
+						break;
+					}
+
+					// node processes only async frames
+				case kEplNmtCsPreOperational1:
+					{
+						break;
+					}
+
+					// node processes isochronous and asynchronous frames
+				case kEplNmtCsPreOperational2:
+					{
+						Ret =
+						    EplNmtuNmtEvent
+						    (kEplNmtEventEnterReadyToOperate);
+						break;
+					}
+
+					// node should be configured und application is ready
+				case kEplNmtCsReadyToOperate:
+					{
+						break;
+					}
+
+					// normal work state
+				case kEplNmtCsOperational:
+					{
+						break;
+					}
+
+					// node stopped by MN
+					// -> only process asynchronous frames
+				case kEplNmtCsStopped:
+					{
+						break;
+					}
+
+					// no EPL cycle
+					// -> normal ethernet communication
+				case kEplNmtCsBasicEthernet:
+					{
+						break;
+					}
 
-                    //-----------------------------------------------------------
-                    // MN part of the state machine
+					//-----------------------------------------------------------
+					// MN part of the state machine
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-                    // node listens for EPL-Frames and check timeout
-                    case kEplNmtMsNotActive:
-                    {
-                    DWORD           dwBuffer;
-                    tEplObdSize     ObdSize;
-                    tEplTimerArg    TimerArg;
-
-                        // create timer to switch automatically to BasicEthernet/PreOp1 if no other MN active in network
-
-                        // check NMT_StartUp_U32.Bit13
-                        // read NMT_StartUp_U32 from OD
-                        ObdSize = sizeof(dwBuffer);
+					// node listens for EPL-Frames and check timeout
+				case kEplNmtMsNotActive:
+					{
+						DWORD dwBuffer;
+						tEplObdSize ObdSize;
+						tEplTimerArg TimerArg;
+
+						// create timer to switch automatically to BasicEthernet/PreOp1 if no other MN active in network
+
+						// check NMT_StartUp_U32.Bit13
+						// read NMT_StartUp_U32 from OD
+						ObdSize = sizeof(dwBuffer);
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0) || (EPL_OBD_USE_KERNEL != FALSE)
-                        Ret = EplObduReadEntry(EPL_MCO_PTR_INSTANCE_PTR_
-                                                0x1F80,
-                                                0x00,
-                                                &dwBuffer,
-                                                &ObdSize);
+						Ret =
+						    EplObduReadEntry
+						    (EPL_MCO_PTR_INSTANCE_PTR_
+						     0x1F80, 0x00, &dwBuffer,
+						     &ObdSize);
 #else
-                        Ret = kEplObdIndexNotExist;
+						Ret = kEplObdIndexNotExist;
 #endif
-                        if(Ret != kEplSuccessful)
-                        {
-                            break;
-                        }
-
-                        if((dwBuffer & EPL_NMTST_BASICETHERNET) == 0)
-                        {   // NMT_StartUp_U32.Bit13 == 0
-                            // new state PreOperational1
-                            TimerArg.m_ulArg = (unsigned long) kEplNmtEventTimerMsPreOp1;
-                        }
-                        else
-                        {   // NMT_StartUp_U32.Bit13 == 1
-                            // new state BasicEthernet
-                            TimerArg.m_ulArg = (unsigned long) kEplNmtEventTimerBasicEthernet;
-                        }
+						if (Ret != kEplSuccessful) {
+							break;
+						}
+
+						if ((dwBuffer & EPL_NMTST_BASICETHERNET) == 0) {	// NMT_StartUp_U32.Bit13 == 0
+							// new state PreOperational1
+							TimerArg.m_ulArg =
+							    (unsigned long)
+							    kEplNmtEventTimerMsPreOp1;
+						} else {	// NMT_StartUp_U32.Bit13 == 1
+							// new state BasicEthernet
+							TimerArg.m_ulArg =
+							    (unsigned long)
+							    kEplNmtEventTimerBasicEthernet;
+						}
 
-                        // read NMT_BootTime_REC.MNWaitNotAct_U32 from OD
-                        ObdSize = sizeof(dwBuffer);
+						// read NMT_BootTime_REC.MNWaitNotAct_U32 from OD
+						ObdSize = sizeof(dwBuffer);
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0) || (EPL_OBD_USE_KERNEL != FALSE)
-                        Ret = EplObduReadEntry(EPL_MCO_PTR_INSTANCE_PTR_
-                                                0x1F89,
-                                                0x01,
-                                                &dwBuffer,
-                                                &ObdSize);
+						Ret =
+						    EplObduReadEntry
+						    (EPL_MCO_PTR_INSTANCE_PTR_
+						     0x1F89, 0x01, &dwBuffer,
+						     &ObdSize);
 #else
-                        Ret = kEplObdIndexNotExist;
+						Ret = kEplObdIndexNotExist;
 #endif
-                        if(Ret != kEplSuccessful)
-                        {
-                            break;
-                        }
-                        // convert us into ms
-                        dwBuffer = dwBuffer / 1000;
-                        if (dwBuffer == 0)
-                        {   // timer was below one ms
-                            // set one ms
-                            dwBuffer = 1;
-                        }
-                        TimerArg.m_EventSink = kEplEventSinkNmtk;
-                        Ret = EplTimeruModifyTimerMs(&EplNmtuInstance_g.m_TimerHdl, (unsigned long) dwBuffer, TimerArg);
-                        // potential error is forwarded to event queue which generates error event
-                        break;
-                    }
-
-                    // node processes only async frames
-                    case kEplNmtMsPreOperational1:
-                    {
-                    DWORD           dwBuffer = 0;
-                    tEplObdSize     ObdSize;
-                    tEplTimerArg    TimerArg;
+						if (Ret != kEplSuccessful) {
+							break;
+						}
+						// convert us into ms
+						dwBuffer = dwBuffer / 1000;
+						if (dwBuffer == 0) {	// timer was below one ms
+							// set one ms
+							dwBuffer = 1;
+						}
+						TimerArg.m_EventSink =
+						    kEplEventSinkNmtk;
+						Ret =
+						    EplTimeruModifyTimerMs
+						    (&EplNmtuInstance_g.
+						     m_TimerHdl,
+						     (unsigned long)dwBuffer,
+						     TimerArg);
+						// potential error is forwarded to event queue which generates error event
+						break;
+					}
+
+					// node processes only async frames
+				case kEplNmtMsPreOperational1:
+					{
+						DWORD dwBuffer = 0;
+						tEplObdSize ObdSize;
+						tEplTimerArg TimerArg;
 
-                        // create timer to switch automatically to PreOp2 if MN identified all mandatory CNs
+						// create timer to switch automatically to PreOp2 if MN identified all mandatory CNs
 
-                        // read NMT_BootTime_REC.MNWaitPreOp1_U32 from OD
-                        ObdSize = sizeof(dwBuffer);
+						// read NMT_BootTime_REC.MNWaitPreOp1_U32 from OD
+						ObdSize = sizeof(dwBuffer);
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0) || (EPL_OBD_USE_KERNEL != FALSE)
-                        Ret = EplObduReadEntry(EPL_MCO_PTR_INSTANCE_PTR_
-                                                0x1F89,
-                                                0x03,
-                                                &dwBuffer,
-                                                &ObdSize);
-                        if(Ret != kEplSuccessful)
-                        {
-                            // ignore error, because this timeout is optional
-                            dwBuffer = 0;
-                        }
+						Ret =
+						    EplObduReadEntry
+						    (EPL_MCO_PTR_INSTANCE_PTR_
+						     0x1F89, 0x03, &dwBuffer,
+						     &ObdSize);
+						if (Ret != kEplSuccessful) {
+							// ignore error, because this timeout is optional
+							dwBuffer = 0;
+						}
 #endif
-                        if (dwBuffer == 0)
-                        {   // delay is deactivated
-                            // immediately post timer event
-                            Ret = EplNmtuNmtEvent(kEplNmtEventTimerMsPreOp2);
-                            break;
-                        }
-                        // convert us into ms
-                        dwBuffer = dwBuffer / 1000;
-                        if (dwBuffer == 0)
-                        {   // timer was below one ms
-                            // set one ms
-                            dwBuffer = 1;
-                        }
-                        TimerArg.m_EventSink = kEplEventSinkNmtk;
-                        TimerArg.m_ulArg = (unsigned long) kEplNmtEventTimerMsPreOp2;
-                        Ret = EplTimeruModifyTimerMs(&EplNmtuInstance_g.m_TimerHdl, (unsigned long) dwBuffer, TimerArg);
-                        // potential error is forwarded to event queue which generates error event
-                        break;
-                    }
-
-                    // node processes isochronous and asynchronous frames
-                    case kEplNmtMsPreOperational2:
-                    {
-                        break;
-                    }
-
-                    // node should be configured und application is ready
-                    case kEplNmtMsReadyToOperate:
-                    {
-                        break;
-                    }
-
-                    // normal work state
-                    case kEplNmtMsOperational:
-                    {
-                        break;
-                    }
-
-                    // no EPL cycle
-                    // -> normal ethernet communication
-                    case kEplNmtMsBasicEthernet:
-                    {
-                        break;
-                    }
+						if (dwBuffer == 0) {	// delay is deactivated
+							// immediately post timer event
+							Ret =
+							    EplNmtuNmtEvent
+							    (kEplNmtEventTimerMsPreOp2);
+							break;
+						}
+						// convert us into ms
+						dwBuffer = dwBuffer / 1000;
+						if (dwBuffer == 0) {	// timer was below one ms
+							// set one ms
+							dwBuffer = 1;
+						}
+						TimerArg.m_EventSink =
+						    kEplEventSinkNmtk;
+						TimerArg.m_ulArg =
+						    (unsigned long)
+						    kEplNmtEventTimerMsPreOp2;
+						Ret =
+						    EplTimeruModifyTimerMs
+						    (&EplNmtuInstance_g.
+						     m_TimerHdl,
+						     (unsigned long)dwBuffer,
+						     TimerArg);
+						// potential error is forwarded to event queue which generates error event
+						break;
+					}
+
+					// node processes isochronous and asynchronous frames
+				case kEplNmtMsPreOperational2:
+					{
+						break;
+					}
+
+					// node should be configured und application is ready
+				case kEplNmtMsReadyToOperate:
+					{
+						break;
+					}
+
+					// normal work state
+				case kEplNmtMsOperational:
+					{
+						break;
+					}
+
+					// no EPL cycle
+					// -> normal ethernet communication
+				case kEplNmtMsBasicEthernet:
+					{
+						break;
+					}
 #endif // (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
 
-                    default:
-                    {
-                        TRACE1("EplNmtuProcess(): unhandled NMT state 0x%X\n", pNmtStateChange->m_NewNmtState);
-                    }
-                }
-            }
-            else if (Ret == kEplReject)
-            {   // application wants to change NMT state itself
-                // it's OK
-                Ret = kEplSuccessful;
-            }
-
-            EPL_DBGLVL_NMTU_TRACE0("EplNmtuProcessEvent(): NMT-State-Maschine announce change of NMT State\n");
-            break;
-        }
-
-        default:
-        {
-            Ret = kEplNmtInvalidEvent;
-        }
+				default:
+					{
+						TRACE1
+						    ("EplNmtuProcess(): unhandled NMT state 0x%X\n",
+						     pNmtStateChange->
+						     m_NewNmtState);
+					}
+				}
+			} else if (Ret == kEplReject) {	// application wants to change NMT state itself
+				// it's OK
+				Ret = kEplSuccessful;
+			}
+
+			EPL_DBGLVL_NMTU_TRACE0
+			    ("EplNmtuProcessEvent(): NMT-State-Maschine announce change of NMT State\n");
+			break;
+		}
+
+	default:
+		{
+			Ret = kEplNmtInvalidEvent;
+		}
 
-    }
+	}
 
 //Exit:
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -636,17 +664,18 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplNmtuRegisterStateChangeCb(
-            tEplNmtuStateChangeCallback pfnEplNmtStateChangeCb_p)
+EPLDLLEXPORT tEplKernel PUBLIC
+EplNmtuRegisterStateChangeCb(tEplNmtuStateChangeCallback
+			     pfnEplNmtStateChangeCb_p)
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // save callback-function in modul global var
-    EplNmtuInstance_g.m_pfnNmtChangeCb = pfnEplNmtStateChangeCb_p;
+	// save callback-function in modul global var
+	EplNmtuInstance_g.m_pfnNmtChangeCb = pfnEplNmtStateChangeCb_p;
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -676,6 +705,4 @@ tEplKernel Ret;
 
 #endif // #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTU)) != 0)
 
-
 // EOF
-
--- a/drivers/staging/epl/EplNmtuCal.c
+++ b/drivers/staging/epl/EplNmtuCal.c
@@ -95,9 +95,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -124,14 +121,14 @@
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplNmtState PUBLIC EplNmtkCalGetNmtState()
 {
-tEplNmtState NmtState;
-    // for test direkt call for EplNmtkGetNmtState()
+	tEplNmtState NmtState;
+	// for test direkt call for EplNmtkGetNmtState()
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMTK)) != 0)
-    NmtState = EplNmtkGetNmtState();
+	NmtState = EplNmtkGetNmtState();
 #else
-    NmtState = 0;
+	NmtState = 0;
 #endif
-return NmtState;
+	return NmtState;
 }
 
 //=========================================================================//
@@ -158,7 +155,4 @@ return NmtState;
 //
 //---------------------------------------------------------------------------
 
-
-
 // EOF
-
--- a/drivers/staging/epl/EplObd.c
+++ b/drivers/staging/epl/EplObd.c
@@ -70,7 +70,7 @@
 ****************************************************************************/
 
 #include "EplInc.h"
-#include "kernel/EplObdk.h"         // function prototyps of the EplOBD-Modul
+#include "kernel/EplObdk.h"	// function prototyps of the EplOBD-Modul
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
 
@@ -94,30 +94,24 @@
 #define BASE_TO_THE_T_SP            ((float) 8388608.0)
 #define GET_EXPONENT_SP(x)          ((((x) >> T_SP) & _SHIFTED_EXPONENT_MASK_SP) - _BIAS_SP)
 
-
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 
 // struct for instance table
-INSTANCE_TYPE_BEGIN
-
-    EPL_MCO_DECL_INSTANCE_MEMBER ()
+INSTANCE_TYPE_BEGIN EPL_MCO_DECL_INSTANCE_MEMBER()
 
-    STATIC      tEplObdInitParam               INST_FAR    m_ObdInitParam;
-    STATIC      tEplObdStoreLoadObjCallback    INST_NEAR   m_fpStoreLoadObjCallback;
+STATIC tEplObdInitParam INST_FAR m_ObdInitParam;
+STATIC tEplObdStoreLoadObjCallback INST_NEAR m_fpStoreLoadObjCallback;
 
 INSTANCE_TYPE_END
-
 // decomposition of float
-typedef union
-{
-    tEplObdReal32   m_flRealPart;
-    int             m_nIntegerPart;
+typedef union {
+	tEplObdReal32 m_flRealPart;
+	int m_nIntegerPart;
 
 } tEplObdRealParts;
 
-
 //---------------------------------------------------------------------------
 // modul globale vars
 //---------------------------------------------------------------------------
@@ -127,101 +121,92 @@ typedef union
 // must defined in each modul.
 //#define tEplPtrInstance             tEplInstanceInfo MEM*
 
-EPL_MCO_DECL_INSTANCE_VAR ()
-
-BYTE MEM            abEplObdTrashObject_g[8];
+EPL_MCO_DECL_INSTANCE_VAR()
 
+BYTE MEM abEplObdTrashObject_g[8];
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-EPL_MCO_DEFINE_INSTANCE_FCT ()
+EPL_MCO_DEFINE_INSTANCE_FCT()
 
-static tEplKernel EplObdCallObjectCallback (EPL_MCO_DECL_INSTANCE_PTR_
-    tEplObdCallback     fpCallback_p,
-    tEplObdCbParam MEM* pCbParam_p);
+static tEplKernel EplObdCallObjectCallback(EPL_MCO_DECL_INSTANCE_PTR_
+					   tEplObdCallback fpCallback_p,
+					   tEplObdCbParam MEM * pCbParam_p);
 
-static tEplObdSize EplObdGetDataSizeIntern (tEplObdSubEntryPtr pSubIndexEntry_p);
+static tEplObdSize EplObdGetDataSizeIntern(tEplObdSubEntryPtr pSubIndexEntry_p);
 
-static tEplObdSize EplObdGetStrLen (void* pObjData_p,
-                                    tEplObdSize ObjLen_p,
-                                    tEplObdType ObjType_p);
+static tEplObdSize EplObdGetStrLen(void *pObjData_p,
+				   tEplObdSize ObjLen_p, tEplObdType ObjType_p);
 
 #if (EPL_OBD_CHECK_OBJECT_RANGE != FALSE)
-static tEplKernel EplObdCheckObjectRange (
-            tEplObdSubEntryPtr pSubindexEntry_p,
-            void * pData_p);
+static tEplKernel EplObdCheckObjectRange(tEplObdSubEntryPtr pSubindexEntry_p,
+					 void *pData_p);
 #endif
 
-static tEplKernel EplObdGetVarEntry (
-            tEplObdSubEntryPtr    pSubindexEntry_p,
-            tEplObdVarEntry MEM** ppVarEntry_p);
-
-static tEplKernel  EplObdGetEntry (EPL_MCO_DECL_INSTANCE_PTR_
-            unsigned int          uiIndex_p,
-            unsigned int          uiSubindex_p,
-            tEplObdEntryPtr*      ppObdEntry_p,
-            tEplObdSubEntryPtr*   ppObdSubEntry_p);
-
-static tEplObdSize EplObdGetObjectSize (tEplObdSubEntryPtr pSubIndexEntry_p);
-
-static tEplKernel EplObdGetIndexIntern (
-    tEplObdInitParam MEM*     pInitParam_p,
-    unsigned int              uiIndex_p,
-    tEplObdEntryPtr*          ppObdEntry_p);
-
-static tEplKernel EplObdGetSubindexIntern (
-    tEplObdEntryPtr           pObdEntry_p,
-    unsigned int              uiSubIndex_p,
-    tEplObdSubEntryPtr*       ppObdSubEntry_p);
-
-static tEplKernel EplObdAccessOdPartIntern (EPL_MCO_DECL_INSTANCE_PTR_
-                            tEplObdPart     CurrentOdPart_p,
-                            tEplObdEntryPtr pObdEnty_p,
-                            tEplObdDir      Direction_p);
+static tEplKernel EplObdGetVarEntry(tEplObdSubEntryPtr pSubindexEntry_p,
+				    tEplObdVarEntry MEM ** ppVarEntry_p);
 
-static void *   EplObdGetObjectDefaultPtr (tEplObdSubEntryPtr pSubIndexEntry_p);
-static void MEM*       EplObdGetObjectCurrentPtr (tEplObdSubEntryPtr pSubIndexEntry_p);
+static tEplKernel EplObdGetEntry(EPL_MCO_DECL_INSTANCE_PTR_
+				 unsigned int uiIndex_p,
+				 unsigned int uiSubindex_p,
+				 tEplObdEntryPtr * ppObdEntry_p,
+				 tEplObdSubEntryPtr * ppObdSubEntry_p);
+
+static tEplObdSize EplObdGetObjectSize(tEplObdSubEntryPtr pSubIndexEntry_p);
+
+static tEplKernel EplObdGetIndexIntern(tEplObdInitParam MEM * pInitParam_p,
+				       unsigned int uiIndex_p,
+				       tEplObdEntryPtr * ppObdEntry_p);
+
+static tEplKernel EplObdGetSubindexIntern(tEplObdEntryPtr pObdEntry_p,
+					  unsigned int uiSubIndex_p,
+					  tEplObdSubEntryPtr * ppObdSubEntry_p);
+
+static tEplKernel EplObdAccessOdPartIntern(EPL_MCO_DECL_INSTANCE_PTR_
+					   tEplObdPart CurrentOdPart_p,
+					   tEplObdEntryPtr pObdEnty_p,
+					   tEplObdDir Direction_p);
+
+static void *EplObdGetObjectDefaultPtr(tEplObdSubEntryPtr pSubIndexEntry_p);
+static void MEM *EplObdGetObjectCurrentPtr(tEplObdSubEntryPtr pSubIndexEntry_p);
 
 #if (EPL_OBD_USE_STORE_RESTORE != FALSE)
 
-    static tEplKernel EplObdCallStoreCallback (EPL_MCO_DECL_INSTANCE_PTR_
-        tEplObdCbStoreParam MEM* pCbStoreParam_p);
+static tEplKernel EplObdCallStoreCallback(EPL_MCO_DECL_INSTANCE_PTR_
+					  tEplObdCbStoreParam MEM *
+					  pCbStoreParam_p);
 
 #endif // (EPL_OBD_USE_STORE_RESTORE != FALSE)
 
-static void EplObdCopyObjectData (
-                        void MEM*       pDstData_p,
-                        void *   pSrcData_p,
-                        tEplObdSize     ObjSize_p,
-                        tEplObdType     ObjType_p);
+static void EplObdCopyObjectData(void MEM * pDstData_p,
+				 void *pSrcData_p,
+				 tEplObdSize ObjSize_p, tEplObdType ObjType_p);
 
-void * EplObdGetObjectDataPtrIntern (tEplObdSubEntryPtr pSubindexEntry_p);
+void *EplObdGetObjectDataPtrIntern(tEplObdSubEntryPtr pSubindexEntry_p);
 
 static tEplKernel EplObdIsNumericalIntern(tEplObdSubEntryPtr pObdSubEntry_p,
-                                        BOOL*         pfEntryNumerical_p);
-
-static tEplKernel PUBLIC EplObdWriteEntryPre (EPL_MCO_DECL_INSTANCE_PTR_
-    unsigned int  uiIndex_p,
-    unsigned int  uiSubIndex_p,
-    void * pSrcData_p,
-    void** ppDstData_p,
-    tEplObdSize   Size_p,
-    tEplObdEntryPtr*        ppObdEntry_p,
-    tEplObdSubEntryPtr*     ppSubEntry_p,
-    tEplObdCbParam MEM*     pCbParam_p,
-    tEplObdSize*  pObdSize_p);
-
-static tEplKernel PUBLIC EplObdWriteEntryPost (EPL_MCO_DECL_INSTANCE_PTR_
-    tEplObdEntryPtr         pObdEntry_p,
-    tEplObdSubEntryPtr      pSubEntry_p,
-    tEplObdCbParam MEM*     pCbParam_p,
-    void * pSrcData_p,
-    void * pDstData_p,
-    tEplObdSize   ObdSize_p);
-
+					  BOOL * pfEntryNumerical_p);
 
+static tEplKernel PUBLIC EplObdWriteEntryPre(EPL_MCO_DECL_INSTANCE_PTR_
+					     unsigned int uiIndex_p,
+					     unsigned int uiSubIndex_p,
+					     void *pSrcData_p,
+					     void **ppDstData_p,
+					     tEplObdSize Size_p,
+					     tEplObdEntryPtr * ppObdEntry_p,
+					     tEplObdSubEntryPtr * ppSubEntry_p,
+					     tEplObdCbParam MEM * pCbParam_p,
+					     tEplObdSize * pObdSize_p);
+
+static tEplKernel PUBLIC EplObdWriteEntryPost(EPL_MCO_DECL_INSTANCE_PTR_
+					      tEplObdEntryPtr pObdEntry_p,
+					      tEplObdSubEntryPtr pSubEntry_p,
+					      tEplObdCbParam MEM * pCbParam_p,
+					      void *pSrcData_p,
+					      void *pDstData_p,
+					      tEplObdSize ObdSize_p);
 
 //=========================================================================//
 //                                                                         //
@@ -243,28 +228,25 @@ static tEplKernel PUBLIC EplObdWriteEntr
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT tEplKernel PUBLIC EplObdInit (EPL_MCO_DECL_PTR_INSTANCE_PTR_
-                    tEplObdInitParam MEM* pInitParam_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObdInit(EPL_MCO_DECL_PTR_INSTANCE_PTR_
+					  tEplObdInitParam MEM * pInitParam_p)
 {
 
-tEplKernel Ret;
-EPL_MCO_DELETE_INSTANCE_TABLE ();
+	tEplKernel Ret;
+	EPL_MCO_DELETE_INSTANCE_TABLE();
 
-    if (pInitParam_p == NULL)
-    {
-        Ret = kEplSuccessful;
-        goto Exit;
-    }
+	if (pInitParam_p == NULL) {
+		Ret = kEplSuccessful;
+		goto Exit;
+	}
 
-    Ret = EplObdAddInstance (EPL_MCO_PTR_INSTANCE_PTR_
-        pInitParam_p);
+	Ret = EplObdAddInstance(EPL_MCO_PTR_INSTANCE_PTR_ pInitParam_p);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdAddInstance()
@@ -279,39 +261,39 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT tEplKernel PUBLIC EplObdAddInstance (EPL_MCO_DECL_PTR_INSTANCE_PTR_
-    tEplObdInitParam MEM* pInitParam_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObdAddInstance(EPL_MCO_DECL_PTR_INSTANCE_PTR_
+						 tEplObdInitParam MEM *
+						 pInitParam_p)
 {
 
-EPL_MCO_DECL_INSTANCE_PTR_LOCAL
-tEplKernel Ret;
+	EPL_MCO_DECL_INSTANCE_PTR_LOCAL tEplKernel Ret;
 
-    // check if pointer to instance pointer valid
-    // get free instance and set the globale instance pointer
-    // set also the instance addr to parameterlist
-    EPL_MCO_CHECK_PTR_INSTANCE_PTR ();
-    EPL_MCO_GET_FREE_INSTANCE_PTR ();
-    EPL_MCO_SET_PTR_INSTANCE_PTR ();
+	// check if pointer to instance pointer valid
+	// get free instance and set the globale instance pointer
+	// set also the instance addr to parameterlist
+	EPL_MCO_CHECK_PTR_INSTANCE_PTR();
+	EPL_MCO_GET_FREE_INSTANCE_PTR();
+	EPL_MCO_SET_PTR_INSTANCE_PTR();
 
-    // save init parameters
-    EPL_MEMCPY (&EPL_MCO_GLB_VAR (m_ObdInitParam), pInitParam_p, sizeof (tEplObdInitParam));
+	// save init parameters
+	EPL_MEMCPY(&EPL_MCO_GLB_VAR(m_ObdInitParam), pInitParam_p,
+		   sizeof(tEplObdInitParam));
 
-    // clear callback function for command LOAD and STORE
-    EPL_MCO_GLB_VAR (m_fpStoreLoadObjCallback) = NULL;
+	// clear callback function for command LOAD and STORE
+	EPL_MCO_GLB_VAR(m_fpStoreLoadObjCallback) = NULL;
 
-    // sign instance as used
-    EPL_MCO_WRITE_INSTANCE_STATE (kStateUsed);
+	// sign instance as used
+	EPL_MCO_WRITE_INSTANCE_STATE(kStateUsed);
 
-    // initialize object dictionary
-    // so all all VarEntries will be initialized to trash object and default values will be set to current data
-    Ret = EplObdAccessOdPart (EPL_MCO_INSTANCE_PTR_
-        kEplObdPartAll, kEplObdDirInit);
+	// initialize object dictionary
+	// so all all VarEntries will be initialized to trash object and default values will be set to current data
+	Ret = EplObdAccessOdPart(EPL_MCO_INSTANCE_PTR_
+				 kEplObdPartAll, kEplObdDirInit);
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdDeleteInstance()
@@ -326,20 +308,19 @@ tEplKernel Ret;
 //
 //---------------------------------------------------------------------------
 #if (EPL_USE_DELETEINST_FUNC != FALSE)
-EPLDLLEXPORT tEplKernel PUBLIC EplObdDeleteInstance (EPL_MCO_DECL_INSTANCE_PTR)
+EPLDLLEXPORT tEplKernel PUBLIC EplObdDeleteInstance(EPL_MCO_DECL_INSTANCE_PTR)
 {
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
 
-    // sign instance as unused
-    EPL_MCO_WRITE_INSTANCE_STATE (kStateUnused);
+	// sign instance as unused
+	EPL_MCO_WRITE_INSTANCE_STATE(kStateUnused);
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 
 }
 #endif // (EPL_USE_DELETEINST_FUNC != FALSE)
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdWriteEntry()
@@ -360,55 +341,45 @@ EPLDLLEXPORT tEplKernel PUBLIC EplObdDel
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT tEplKernel PUBLIC EplObdWriteEntry (EPL_MCO_DECL_INSTANCE_PTR_
-    unsigned int  uiIndex_p,
-    unsigned int  uiSubIndex_p,
-    void * pSrcData_p,
-    tEplObdSize   Size_p)
-{
-
-tEplKernel              Ret;
-tEplObdEntryPtr         pObdEntry;
-tEplObdSubEntryPtr      pSubEntry;
-tEplObdCbParam MEM      CbParam;
-void MEM*               pDstData;
-tEplObdSize             ObdSize;
-
-
-    Ret = EplObdWriteEntryPre (EPL_MCO_INSTANCE_PTR_
-                               uiIndex_p,
-                               uiSubIndex_p,
-                               pSrcData_p,
-                               &pDstData,
-                               Size_p,
-                               &pObdEntry,
-                               &pSubEntry,
-                               &CbParam,
-                               &ObdSize);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    Ret = EplObdWriteEntryPost (EPL_MCO_INSTANCE_PTR_
-                                pObdEntry,
-                                pSubEntry,
-                                &CbParam,
-                                pSrcData_p,
-                                pDstData,
-                                ObdSize);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+EPLDLLEXPORT tEplKernel PUBLIC EplObdWriteEntry(EPL_MCO_DECL_INSTANCE_PTR_
+						unsigned int uiIndex_p,
+						unsigned int uiSubIndex_p,
+						void *pSrcData_p,
+						tEplObdSize Size_p)
+{
+
+	tEplKernel Ret;
+	tEplObdEntryPtr pObdEntry;
+	tEplObdSubEntryPtr pSubEntry;
+	tEplObdCbParam MEM CbParam;
+	void MEM *pDstData;
+	tEplObdSize ObdSize;
+
+	Ret = EplObdWriteEntryPre(EPL_MCO_INSTANCE_PTR_
+				  uiIndex_p,
+				  uiSubIndex_p,
+				  pSrcData_p,
+				  &pDstData,
+				  Size_p,
+				  &pObdEntry, &pSubEntry, &CbParam, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	Ret = EplObdWriteEntryPost(EPL_MCO_INSTANCE_PTR_
+				   pObdEntry,
+				   pSubEntry,
+				   &CbParam, pSrcData_p, pDstData, ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 
-Exit:
+      Exit:
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdReadEntry()
@@ -431,81 +402,73 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT tEplKernel PUBLIC EplObdReadEntry (EPL_MCO_DECL_INSTANCE_PTR_
-                                                unsigned int        uiIndex_p,
-                                                unsigned int        uiSubIndex_p,
-                                                void *              pDstData_p,
-                                                tEplObdSize *       pSize_p)
-{
-
-tEplKernel                      Ret;
-tEplObdEntryPtr                 pObdEntry;
-tEplObdSubEntryPtr              pSubEntry;
-tEplObdCbParam  MEM             CbParam;
-void *                          pSrcData;
-tEplObdSize                     ObdSize;
-
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
-
-    ASSERT (pDstData_p != NULL);
-    ASSERT (pSize_p != NULL);
-
-    // get address of index and subindex entry
-    Ret = EplObdGetEntry (EPL_MCO_INSTANCE_PTR_
-        uiIndex_p, uiSubIndex_p, &pObdEntry, &pSubEntry);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // get pointer to object data
-     pSrcData = EplObdGetObjectDataPtrIntern (pSubEntry);
-
-    // check source pointer
-    if (pSrcData == NULL)
-    {
-        Ret = kEplObdReadViolation;
-        goto Exit;
-    }
-
-    //------------------------------------------------------------------------
-    // address of source data to structure of callback parameters
-    // so callback function can change this data before reading
-    CbParam.m_uiIndex   = uiIndex_p;
-    CbParam.m_uiSubIndex= uiSubIndex_p;
-    CbParam.m_pArg      = pSrcData;
-    CbParam.m_ObdEvent  = kEplObdEvPreRead;
-    Ret = EplObdCallObjectCallback (EPL_MCO_INSTANCE_PTR_
-        pObdEntry->m_fpCallback, &CbParam);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // get size of data and check if application has reserved enough memory
-    ObdSize = EplObdGetDataSizeIntern (pSubEntry);
-    // check if offset given and calc correct number of bytes to read
-    if (*pSize_p < ObdSize)
-    {
-        Ret = kEplObdValueLengthError;
-        goto Exit;
-    }
+EPLDLLEXPORT tEplKernel PUBLIC EplObdReadEntry(EPL_MCO_DECL_INSTANCE_PTR_
+					       unsigned int uiIndex_p,
+					       unsigned int uiSubIndex_p,
+					       void *pDstData_p,
+					       tEplObdSize * pSize_p)
+{
+
+	tEplKernel Ret;
+	tEplObdEntryPtr pObdEntry;
+	tEplObdSubEntryPtr pSubEntry;
+	tEplObdCbParam MEM CbParam;
+	void *pSrcData;
+	tEplObdSize ObdSize;
+
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
+
+	ASSERT(pDstData_p != NULL);
+	ASSERT(pSize_p != NULL);
+
+	// get address of index and subindex entry
+	Ret = EplObdGetEntry(EPL_MCO_INSTANCE_PTR_
+			     uiIndex_p, uiSubIndex_p, &pObdEntry, &pSubEntry);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// get pointer to object data
+	pSrcData = EplObdGetObjectDataPtrIntern(pSubEntry);
+
+	// check source pointer
+	if (pSrcData == NULL) {
+		Ret = kEplObdReadViolation;
+		goto Exit;
+	}
+	//------------------------------------------------------------------------
+	// address of source data to structure of callback parameters
+	// so callback function can change this data before reading
+	CbParam.m_uiIndex = uiIndex_p;
+	CbParam.m_uiSubIndex = uiSubIndex_p;
+	CbParam.m_pArg = pSrcData;
+	CbParam.m_ObdEvent = kEplObdEvPreRead;
+	Ret = EplObdCallObjectCallback(EPL_MCO_INSTANCE_PTR_
+				       pObdEntry->m_fpCallback, &CbParam);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// get size of data and check if application has reserved enough memory
+	ObdSize = EplObdGetDataSizeIntern(pSubEntry);
+	// check if offset given and calc correct number of bytes to read
+	if (*pSize_p < ObdSize) {
+		Ret = kEplObdValueLengthError;
+		goto Exit;
+	}
+	// read value from object
+	EPL_MEMCPY(pDstData_p, pSrcData, ObdSize);
+	*pSize_p = ObdSize;
+
+	// write address of destination data to structure of callback parameters
+	// so callback function can change this data after reading
+	CbParam.m_pArg = pDstData_p;
+	CbParam.m_ObdEvent = kEplObdEvPostRead;
+	Ret = EplObdCallObjectCallback(EPL_MCO_INSTANCE_PTR_
+				       pObdEntry->m_fpCallback, &CbParam);
 
-    // read value from object
-    EPL_MEMCPY (pDstData_p, pSrcData, ObdSize);
-    *pSize_p = ObdSize;
-
-    // write address of destination data to structure of callback parameters
-    // so callback function can change this data after reading
-    CbParam.m_pArg     = pDstData_p;
-    CbParam.m_ObdEvent = kEplObdEvPostRead;
-    Ret = EplObdCallObjectCallback (EPL_MCO_INSTANCE_PTR_
-        pObdEntry->m_fpCallback, &CbParam);
-
-Exit:
+      Exit:
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -524,103 +487,92 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT tEplKernel PUBLIC EplObdAccessOdPart (EPL_MCO_DECL_INSTANCE_PTR_
-    tEplObdPart ObdPart_p,
-    tEplObdDir  Direction_p)
-{
-
-tEplKernel      Ret = kEplSuccessful;
-BOOL            fPartFount;
-tEplObdEntryPtr pObdEntry;
-
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
-
-    //  part always has to be unequal to NULL
-    pObdEntry = EPL_MCO_GLB_VAR (m_ObdInitParam.m_pPart);
-    ASSERTMSG (pObdEntry != NULL, "EplObdAccessOdPart(): no  OD part is defined!\n");
-
-    // if ObdPart_p is not valid fPartFound keeps FALSE and function returns kEplObdIllegalPart
-    fPartFount = FALSE;
-
-    // access to  part
-    if ((ObdPart_p & kEplObdPartGen) != 0)
-    {
-        fPartFount = TRUE;
-
-        Ret = EplObdAccessOdPartIntern (EPL_MCO_INSTANCE_PTR_
-            kEplObdPartGen, pObdEntry, Direction_p);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-    }
-
-    // access to manufacturer part
-    pObdEntry = EPL_MCO_GLB_VAR (m_ObdInitParam.m_pManufacturerPart);
-
-    if ( ((ObdPart_p & kEplObdPartMan) != 0) &&
-         (pObdEntry != NULL) )
-    {
-        fPartFount = TRUE;
-
-        Ret = EplObdAccessOdPartIntern (EPL_MCO_INSTANCE_PTR_
-            kEplObdPartMan, pObdEntry, Direction_p);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-    }
-
-    // access to device part
-    pObdEntry = EPL_MCO_GLB_VAR (m_ObdInitParam.m_pDevicePart);
-
-    if ( ((ObdPart_p & kEplObdPartDev) != 0) &&
-         (pObdEntry != NULL) )
-    {
-        fPartFount = TRUE;
-
-        Ret = EplObdAccessOdPartIntern (EPL_MCO_INSTANCE_PTR_
-            kEplObdPartDev, pObdEntry, Direction_p);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-    }
-
-    #if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
-    {
-        // access to user part
-        pObdEntry = EPL_MCO_GLB_VAR (m_ObdInitParam.m_pUserPart);
-
-        if ( ((ObdPart_p & kEplObdPartUsr) != 0) &&
-             (pObdEntry != NULL) )
-        {
-            fPartFount = TRUE;
-
-            Ret = EplObdAccessOdPartIntern (EPL_MCO_INSTANCE_PTR_
-                kEplObdPartUsr, pObdEntry, Direction_p);
-            if (Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-        }
-    }
-    #endif
+EPLDLLEXPORT tEplKernel PUBLIC EplObdAccessOdPart(EPL_MCO_DECL_INSTANCE_PTR_
+						  tEplObdPart ObdPart_p,
+						  tEplObdDir Direction_p)
+{
+
+	tEplKernel Ret = kEplSuccessful;
+	BOOL fPartFount;
+	tEplObdEntryPtr pObdEntry;
+
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
+
+	//  part always has to be unequal to NULL
+	pObdEntry = EPL_MCO_GLB_VAR(m_ObdInitParam.m_pPart);
+	ASSERTMSG(pObdEntry != NULL,
+		  "EplObdAccessOdPart(): no  OD part is defined!\n");
+
+	// if ObdPart_p is not valid fPartFound keeps FALSE and function returns kEplObdIllegalPart
+	fPartFount = FALSE;
+
+	// access to  part
+	if ((ObdPart_p & kEplObdPartGen) != 0) {
+		fPartFount = TRUE;
+
+		Ret = EplObdAccessOdPartIntern(EPL_MCO_INSTANCE_PTR_
+					       kEplObdPartGen, pObdEntry,
+					       Direction_p);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+	}
+	// access to manufacturer part
+	pObdEntry = EPL_MCO_GLB_VAR(m_ObdInitParam.m_pManufacturerPart);
+
+	if (((ObdPart_p & kEplObdPartMan) != 0) && (pObdEntry != NULL)) {
+		fPartFount = TRUE;
+
+		Ret = EplObdAccessOdPartIntern(EPL_MCO_INSTANCE_PTR_
+					       kEplObdPartMan, pObdEntry,
+					       Direction_p);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+	}
+	// access to device part
+	pObdEntry = EPL_MCO_GLB_VAR(m_ObdInitParam.m_pDevicePart);
+
+	if (((ObdPart_p & kEplObdPartDev) != 0) && (pObdEntry != NULL)) {
+		fPartFount = TRUE;
+
+		Ret = EplObdAccessOdPartIntern(EPL_MCO_INSTANCE_PTR_
+					       kEplObdPartDev, pObdEntry,
+					       Direction_p);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+	}
+#if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
+	{
+		// access to user part
+		pObdEntry = EPL_MCO_GLB_VAR(m_ObdInitParam.m_pUserPart);
+
+		if (((ObdPart_p & kEplObdPartUsr) != 0) && (pObdEntry != NULL)) {
+			fPartFount = TRUE;
+
+			Ret = EplObdAccessOdPartIntern(EPL_MCO_INSTANCE_PTR_
+						       kEplObdPartUsr,
+						       pObdEntry, Direction_p);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+		}
+	}
+#endif
 
-    // no access to an OD part was done? illegal OD part was specified!
-    if (fPartFount == FALSE)
-    {
-        Ret = kEplObdIllegalPart;
-    }
+	// no access to an OD part was done? illegal OD part was specified!
+	if (fPartFount == FALSE) {
+		Ret = kEplObdIllegalPart;
+	}
 
-Exit:
+      Exit:
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdDefineVar()
@@ -635,64 +587,54 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT tEplKernel PUBLIC EplObdDefineVar (EPL_MCO_DECL_INSTANCE_PTR_
-    tEplVarParam MEM* pVarParam_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObdDefineVar(EPL_MCO_DECL_INSTANCE_PTR_
+					       tEplVarParam MEM * pVarParam_p)
 {
 
-tEplKernel              Ret;
-tEplObdVarEntry MEM*    pVarEntry;
-tEplVarParamValid       VarValid;
-tEplObdSubEntryPtr      pSubindexEntry;
-
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
-
-    ASSERT (pVarParam_p != NULL);   // is not allowed to be NULL
-
-    // get address of subindex entry
-    Ret = EplObdGetEntry (EPL_MCO_INSTANCE_PTR_
-        pVarParam_p->m_uiIndex,
-        pVarParam_p->m_uiSubindex,
-        NULL, &pSubindexEntry);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // get var entry
-    Ret = EplObdGetVarEntry (pSubindexEntry, &pVarEntry);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    VarValid =  pVarParam_p->m_ValidFlag;
-
-    // copy only this values, which valid flag is set
-    if ((VarValid & kVarValidSize) != 0)
-    {
-        if (pSubindexEntry->m_Type != kEplObdTypDomain)
-        {
-        tEplObdSize DataSize;
-
-            // check passed size parameter
-            DataSize = EplObdGetObjectSize(pSubindexEntry);
-            if (DataSize != pVarParam_p->m_Size)
-            {   // size of variable does not match
-                Ret = kEplObdValueLengthError;
-                goto Exit;
-            }
-        }
-        else
-        {   // size can be set only for objects of type DOMAIN
-            pVarEntry->m_Size = pVarParam_p->m_Size;
-        }
-    }
-
-    if ((VarValid & kVarValidData) != 0)
-    {
-       pVarEntry->m_pData = pVarParam_p->m_pData;
-    }
+	tEplKernel Ret;
+	tEplObdVarEntry MEM *pVarEntry;
+	tEplVarParamValid VarValid;
+	tEplObdSubEntryPtr pSubindexEntry;
+
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
+
+	ASSERT(pVarParam_p != NULL);	// is not allowed to be NULL
+
+	// get address of subindex entry
+	Ret = EplObdGetEntry(EPL_MCO_INSTANCE_PTR_
+			     pVarParam_p->m_uiIndex,
+			     pVarParam_p->m_uiSubindex, NULL, &pSubindexEntry);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// get var entry
+	Ret = EplObdGetVarEntry(pSubindexEntry, &pVarEntry);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	VarValid = pVarParam_p->m_ValidFlag;
+
+	// copy only this values, which valid flag is set
+	if ((VarValid & kVarValidSize) != 0) {
+		if (pSubindexEntry->m_Type != kEplObdTypDomain) {
+			tEplObdSize DataSize;
+
+			// check passed size parameter
+			DataSize = EplObdGetObjectSize(pSubindexEntry);
+			if (DataSize != pVarParam_p->m_Size) {	// size of variable does not match
+				Ret = kEplObdValueLengthError;
+				goto Exit;
+			}
+		} else {	// size can be set only for objects of type DOMAIN
+			pVarEntry->m_Size = pVarParam_p->m_Size;
+		}
+	}
+
+	if ((VarValid & kVarValidData) != 0) {
+		pVarEntry->m_pData = pVarParam_p->m_pData;
+	}
 /*
     #if (EPL_PDO_USE_STATIC_MAPPING == FALSE)
     {
@@ -708,15 +650,14 @@ tEplObdSubEntryPtr      pSubindexEntry;
     }
     #endif
 */
-    // Ret is already set to kEplSuccessful from ObdGetVarIntern()
+	// Ret is already set to kEplSuccessful from ObdGetVarIntern()
 
-Exit:
+      Exit:
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdGetObjectDataPtr()
@@ -733,44 +674,36 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT void * PUBLIC EplObdGetObjectDataPtr (EPL_MCO_DECL_INSTANCE_PTR_
-                                        unsigned int uiIndex_p,
-                                        unsigned int uiSubIndex_p)
- {
-tEplKernel          Ret;
-void *       pData;
-tEplObdEntryPtr     pObdEntry;
-tEplObdSubEntryPtr  pObdSubEntry;
-
-
-    // get pointer to index structure
-    Ret = EplObdGetIndexIntern (&EPL_MCO_GLB_VAR (m_ObdInitParam),
-                                uiIndex_p,
-                                &pObdEntry);
-    if(Ret != kEplSuccessful)
-    {
-        pData = NULL;
-        goto Exit;
-    }
-
-    // get pointer to subindex structure
-    Ret = EplObdGetSubindexIntern (pObdEntry,
-                                uiSubIndex_p,
-                                &pObdSubEntry);
-    if(Ret != kEplSuccessful)
-    {
-        pData = NULL;
-        goto Exit;
-    }
-    // get Datapointer
-    pData = EplObdGetObjectDataPtrIntern(pObdSubEntry);
+EPLDLLEXPORT void *PUBLIC EplObdGetObjectDataPtr(EPL_MCO_DECL_INSTANCE_PTR_
+						 unsigned int uiIndex_p,
+						 unsigned int uiSubIndex_p)
+{
+	tEplKernel Ret;
+	void *pData;
+	tEplObdEntryPtr pObdEntry;
+	tEplObdSubEntryPtr pObdSubEntry;
+
+	// get pointer to index structure
+	Ret = EplObdGetIndexIntern(&EPL_MCO_GLB_VAR(m_ObdInitParam),
+				   uiIndex_p, &pObdEntry);
+	if (Ret != kEplSuccessful) {
+		pData = NULL;
+		goto Exit;
+	}
+	// get pointer to subindex structure
+	Ret = EplObdGetSubindexIntern(pObdEntry, uiSubIndex_p, &pObdSubEntry);
+	if (Ret != kEplSuccessful) {
+		pData = NULL;
+		goto Exit;
+	}
+	// get Datapointer
+	pData = EplObdGetObjectDataPtrIntern(pObdSubEntry);
 
-Exit:
-    return pData;
+      Exit:
+	return pData;
 
 }
 
-
 #if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
 
 //---------------------------------------------------------------------------
@@ -786,21 +719,20 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObdRegisterUserOd (EPL_MCO_DECL_INSTANCE_PTR_
-    tEplObdEntryPtr pUserOd_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObdRegisterUserOd(EPL_MCO_DECL_INSTANCE_PTR_
+						    tEplObdEntryPtr pUserOd_p)
 {
 
-    EPL_MCO_CHECK_INSTANCE_STATE ();
+	EPL_MCO_CHECK_INSTANCE_STATE();
 
-    EPL_MCO_GLB_VAR (m_ObdInitParam.m_pUserPart) = pUserOd_p;
+	EPL_MCO_GLB_VAR(m_ObdInitParam.m_pUserPart) = pUserOd_p;
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 
 }
 
 #endif
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdInitVarEntry()
@@ -817,9 +749,10 @@ EPLDLLEXPORT tEplKernel PUBLIC EplObdReg
 //
 //---------------------------------------------------------------------------
 
-EPLDLLEXPORT void PUBLIC EplObdInitVarEntry (EPL_MCO_DECL_INSTANCE_PTR_
-                                             tEplObdVarEntry MEM* pVarEntry_p,
-                                             tEplObdType Type_p, tEplObdSize ObdSize_p)
+EPLDLLEXPORT void PUBLIC EplObdInitVarEntry(EPL_MCO_DECL_INSTANCE_PTR_
+					    tEplObdVarEntry MEM * pVarEntry_p,
+					    tEplObdType Type_p,
+					    tEplObdSize ObdSize_p)
 {
 /*
     #if (EPL_PDO_USE_STATIC_MAPPING == FALSE)
@@ -832,29 +765,26 @@ EPLDLLEXPORT void PUBLIC EplObdInitVarEn
 */
 
 // 10-dec-2004 r.d.: this function will not be used for strings
-    if ((Type_p == kEplObdTypDomain))
+	if ((Type_p == kEplObdTypDomain))
 //         (bType_p == kEplObdTypVString) /* ||
 //         (bType_p == kEplObdTypOString) ||
 //         (bType_p == kEplObdTypUString)    */ )
-    {
-        // variables which are defined as DOMAIN or VSTRING should not point to
-        // trash object, because this trash object contains only 8 bytes. DOMAINS or
-        // STRINGS can be longer.
-        pVarEntry_p->m_pData = NULL;
-        pVarEntry_p->m_Size  = 0;
-    }
-    else
-    {
-        // set address to variable data to trash object
-        // This prevents an access violation if user forgets to call EplObdDefineVar()
-        // for this variable but mappes it in a PDO.
-        pVarEntry_p->m_pData = &abEplObdTrashObject_g[0];
-        pVarEntry_p->m_Size  = ObdSize_p;
-    }
+	{
+		// variables which are defined as DOMAIN or VSTRING should not point to
+		// trash object, because this trash object contains only 8 bytes. DOMAINS or
+		// STRINGS can be longer.
+		pVarEntry_p->m_pData = NULL;
+		pVarEntry_p->m_Size = 0;
+	} else {
+		// set address to variable data to trash object
+		// This prevents an access violation if user forgets to call EplObdDefineVar()
+		// for this variable but mappes it in a PDO.
+		pVarEntry_p->m_pData = &abEplObdTrashObject_g[0];
+		pVarEntry_p->m_Size = ObdSize_p;
+	}
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdGetDataSize()
@@ -874,40 +804,33 @@ EPLDLLEXPORT void PUBLIC EplObdInitVarEn
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplObdSize PUBLIC EplObdGetDataSize(EPL_MCO_DECL_INSTANCE_PTR_
-                                                  unsigned int uiIndex_p,
-                                                  unsigned int uiSubIndex_p)
+						  unsigned int uiIndex_p,
+						  unsigned int uiSubIndex_p)
 {
-tEplKernel          Ret;
-tEplObdSize         ObdSize;
-tEplObdEntryPtr     pObdEntry;
-tEplObdSubEntryPtr  pObdSubEntry;
-
-
-    // get pointer to index structure
-    Ret = EplObdGetIndexIntern (&EPL_MCO_GLB_VAR (m_ObdInitParam),
-                                uiIndex_p,
-                                &pObdEntry);
-    if(Ret != kEplSuccessful)
-    {
-        ObdSize = 0;
-        goto Exit;
-    }
-
-    // get pointer to subindex structure
-    Ret = EplObdGetSubindexIntern (pObdEntry,
-                                uiSubIndex_p,
-                                &pObdSubEntry);
-    if(Ret != kEplSuccessful)
-    {
-        ObdSize = 0;
-        goto Exit;
-    }
-
-    // get size
-    ObdSize = EplObdGetDataSizeIntern (pObdSubEntry);
-Exit:
-    return ObdSize;
+	tEplKernel Ret;
+	tEplObdSize ObdSize;
+	tEplObdEntryPtr pObdEntry;
+	tEplObdSubEntryPtr pObdSubEntry;
+
+	// get pointer to index structure
+	Ret = EplObdGetIndexIntern(&EPL_MCO_GLB_VAR(m_ObdInitParam),
+				   uiIndex_p, &pObdEntry);
+	if (Ret != kEplSuccessful) {
+		ObdSize = 0;
+		goto Exit;
+	}
+	// get pointer to subindex structure
+	Ret = EplObdGetSubindexIntern(pObdEntry, uiSubIndex_p, &pObdSubEntry);
+	if (Ret != kEplSuccessful) {
+		ObdSize = 0;
+		goto Exit;
+	}
+	// get size
+	ObdSize = EplObdGetDataSizeIntern(pObdSubEntry);
+      Exit:
+	return ObdSize;
 }
+
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdGetNodeId()
@@ -924,29 +847,25 @@ Exit:
 //---------------------------------------------------------------------------
 EPLDLLEXPORT unsigned int PUBLIC EplObdGetNodeId(EPL_MCO_DECL_INSTANCE_PTR)
 {
-tEplKernel      Ret;
-tEplObdSize     ObdSize;
-BYTE            bNodeId;
-
-    bNodeId = 0;
-    ObdSize = sizeof(bNodeId);
-    Ret = EplObdReadEntry(EPL_MCO_PTR_INSTANCE_PTR_
-                            EPL_OBD_NODE_ID_INDEX,
-                            EPL_OBD_NODE_ID_SUBINDEX,
-                            &bNodeId,
-                            &ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        bNodeId = EPL_C_ADR_INVALID;
-        goto Exit;
-    }
+	tEplKernel Ret;
+	tEplObdSize ObdSize;
+	BYTE bNodeId;
+
+	bNodeId = 0;
+	ObdSize = sizeof(bNodeId);
+	Ret = EplObdReadEntry(EPL_MCO_PTR_INSTANCE_PTR_
+			      EPL_OBD_NODE_ID_INDEX,
+			      EPL_OBD_NODE_ID_SUBINDEX, &bNodeId, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		bNodeId = EPL_C_ADR_INVALID;
+		goto Exit;
+	}
 
-Exit:
-    return (unsigned int) bNodeId;
+      Exit:
+	return (unsigned int)bNodeId;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdSetNodeId()
@@ -964,76 +883,68 @@ Exit:
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplObdSetNodeId(EPL_MCO_DECL_PTR_INSTANCE_PTR_
-                                         unsigned int uiNodeId_p,
-                                         tEplObdNodeIdType NodeIdType_p)
+					       unsigned int uiNodeId_p,
+					       tEplObdNodeIdType NodeIdType_p)
 {
-tEplKernel  Ret;
-tEplObdSize ObdSize;
-BYTE        fHwBool;
-BYTE        bNodeId;
-
-    // check Node Id
-    if(uiNodeId_p == EPL_C_ADR_INVALID)
-    {
-        Ret = kEplInvalidNodeId;
-        goto Exit;
-    }
-    bNodeId = (BYTE)uiNodeId_p;
-    ObdSize = sizeof(BYTE);
-    // write NodeId to OD entry
-    Ret = EplObdWriteEntry(EPL_MCO_PTR_INSTANCE_PTR_
-                            EPL_OBD_NODE_ID_INDEX,
-                            EPL_OBD_NODE_ID_SUBINDEX,
-                            &bNodeId,
-                            ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // set HWBOOL-Flag in Subindex EPL_OBD_NODE_ID_HWBOOL_SUBINDEX
-    switch (NodeIdType_p)
-    {
-        // type unknown
-        case kEplObdNodeIdUnknown:
-        {
-            fHwBool = OBD_FALSE;
-            break;
-        }
-
-        case kEplObdNodeIdSoftware:
-        {
-            fHwBool = OBD_FALSE;
-            break;
-        }
-
-        case kEplObdNodeIdHardware:
-        {
-            fHwBool = OBD_TRUE;
-            break;
-        }
-
-        default:
-        {
-            fHwBool = OBD_FALSE;
-        }
-
-    }   // end of switch (NodeIdType_p)
-
-    // write flag
-    ObdSize = sizeof(fHwBool);
-    Ret = EplObdWriteEntry(EPL_MCO_PTR_INSTANCE_PTR
-                            EPL_OBD_NODE_ID_INDEX,
-                            EPL_OBD_NODE_ID_HWBOOL_SUBINDEX,
-                            &fHwBool,
-                            ObdSize);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	tEplKernel Ret;
+	tEplObdSize ObdSize;
+	BYTE fHwBool;
+	BYTE bNodeId;
+
+	// check Node Id
+	if (uiNodeId_p == EPL_C_ADR_INVALID) {
+		Ret = kEplInvalidNodeId;
+		goto Exit;
+	}
+	bNodeId = (BYTE) uiNodeId_p;
+	ObdSize = sizeof(BYTE);
+	// write NodeId to OD entry
+	Ret = EplObdWriteEntry(EPL_MCO_PTR_INSTANCE_PTR_
+			       EPL_OBD_NODE_ID_INDEX,
+			       EPL_OBD_NODE_ID_SUBINDEX, &bNodeId, ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// set HWBOOL-Flag in Subindex EPL_OBD_NODE_ID_HWBOOL_SUBINDEX
+	switch (NodeIdType_p) {
+		// type unknown
+	case kEplObdNodeIdUnknown:
+		{
+			fHwBool = OBD_FALSE;
+			break;
+		}
+
+	case kEplObdNodeIdSoftware:
+		{
+			fHwBool = OBD_FALSE;
+			break;
+		}
+
+	case kEplObdNodeIdHardware:
+		{
+			fHwBool = OBD_TRUE;
+			break;
+		}
+
+	default:
+		{
+			fHwBool = OBD_FALSE;
+		}
+
+	}			// end of switch (NodeIdType_p)
+
+	// write flag
+	ObdSize = sizeof(fHwBool);
+	Ret = EplObdWriteEntry(EPL_MCO_PTR_INSTANCE_PTR
+			       EPL_OBD_NODE_ID_INDEX,
+			       EPL_OBD_NODE_ID_HWBOOL_SUBINDEX,
+			       &fHwBool, ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1056,38 +967,30 @@ Exit:
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplObdIsNumerical(EPL_MCO_DECL_INSTANCE_PTR_
-                                        unsigned int  uiIndex_p,
-                                        unsigned int  uiSubIndex_p,
-                                        BOOL*         pfEntryNumerical_p)
-{
-tEplKernel          Ret;
-tEplObdEntryPtr     pObdEntry;
-tEplObdSubEntryPtr  pObdSubEntry;
-
-
-    // get pointer to index structure
-    Ret = EplObdGetIndexIntern (&EPL_MCO_GLB_VAR (m_ObdInitParam),
-                                uiIndex_p,
-                                &pObdEntry);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // get pointer to subindex structure
-    Ret = EplObdGetSubindexIntern (pObdEntry,
-                                uiSubIndex_p,
-                                &pObdSubEntry);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+						 unsigned int uiIndex_p,
+						 unsigned int uiSubIndex_p,
+						 BOOL * pfEntryNumerical_p)
+{
+	tEplKernel Ret;
+	tEplObdEntryPtr pObdEntry;
+	tEplObdSubEntryPtr pObdSubEntry;
+
+	// get pointer to index structure
+	Ret = EplObdGetIndexIntern(&EPL_MCO_GLB_VAR(m_ObdInitParam),
+				   uiIndex_p, &pObdEntry);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// get pointer to subindex structure
+	Ret = EplObdGetSubindexIntern(pObdEntry, uiSubIndex_p, &pObdSubEntry);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 
-    Ret = EplObdIsNumericalIntern(pObdSubEntry, pfEntryNumerical_p);
+	Ret = EplObdIsNumericalIntern(pObdSubEntry, pfEntryNumerical_p);
 
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
@@ -1115,173 +1018,163 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObdReadEntryToLe (EPL_MCO_DECL_INSTANCE_PTR_
-                                        unsigned int        uiIndex_p,
-                                        unsigned int        uiSubIndex_p,
-                                        void *              pDstData_p,
-                                        tEplObdSize *       pSize_p)
-{
-tEplKernel                      Ret;
-tEplObdEntryPtr                 pObdEntry;
-tEplObdSubEntryPtr              pSubEntry;
-tEplObdCbParam  MEM             CbParam;
-void *                          pSrcData;
-tEplObdSize                     ObdSize;
-
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
-
-    ASSERT (pDstData_p != NULL);
-    ASSERT (pSize_p != NULL);
-
-    // get address of index and subindex entry
-    Ret = EplObdGetEntry (EPL_MCO_INSTANCE_PTR_
-        uiIndex_p, uiSubIndex_p, &pObdEntry, &pSubEntry);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // get pointer to object data
-     pSrcData = EplObdGetObjectDataPtrIntern (pSubEntry);
-
-    // check source pointer
-    if (pSrcData == NULL)
-    {
-        Ret = kEplObdReadViolation;
-        goto Exit;
-    }
-
-    //------------------------------------------------------------------------
-    // address of source data to structure of callback parameters
-    // so callback function can change this data before reading
-    CbParam.m_uiIndex   = uiIndex_p;
-    CbParam.m_uiSubIndex= uiSubIndex_p;
-    CbParam.m_pArg      = pSrcData;
-    CbParam.m_ObdEvent  = kEplObdEvPreRead;
-    Ret = EplObdCallObjectCallback (EPL_MCO_INSTANCE_PTR_
-        pObdEntry->m_fpCallback, &CbParam);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // get size of data and check if application has reserved enough memory
-    ObdSize = EplObdGetDataSizeIntern (pSubEntry);
-    // check if offset given and calc correct number of bytes to read
-    if (*pSize_p < ObdSize)
-    {
-        Ret = kEplObdValueLengthError;
-        goto Exit;
-    }
-
-    // check if numerical type
-    switch(pSubEntry->m_Type)
-    {
-        //-----------------------------------------------
-        // types without ami
-        case kEplObdTypVString:
-        case kEplObdTypOString:
-        case kEplObdTypDomain:
-        default:
-        {
-            // read value from object
-            EPL_MEMCPY (pDstData_p, pSrcData, ObdSize);
-            break;
-        }
-
-        //-----------------------------------------------
-        // numerical type which needs ami-write
-        // 8 bit or smaller values
-        case kEplObdTypBool:
-        case kEplObdTypInt8:
-        case kEplObdTypUInt8:
-        {
-            AmiSetByteToLe(pDstData_p, *((BYTE*)pSrcData));
-            break;
-        }
-
-        // 16 bit values
-        case kEplObdTypInt16:
-        case kEplObdTypUInt16:
-        {
-            AmiSetWordToLe(pDstData_p, *((WORD*)pSrcData));
-            break;
-        }
-
-        // 24 bit values
-        case kEplObdTypInt24:
-        case kEplObdTypUInt24:
-        {
-            AmiSetDword24ToLe(pDstData_p, *((DWORD*)pSrcData));
-            break;
-        }
-
-        // 32 bit values
-        case kEplObdTypInt32:
-        case kEplObdTypUInt32:
-        case kEplObdTypReal32:
-        {
-            AmiSetDwordToLe(pDstData_p, *((DWORD*)pSrcData));
-            break;
-        }
-
-        // 40 bit values
-        case kEplObdTypInt40:
-        case kEplObdTypUInt40:
-        {
-            AmiSetQword40ToLe(pDstData_p, *((QWORD*)pSrcData));
-            break;
-        }
-
-        // 48 bit values
-        case kEplObdTypInt48:
-        case kEplObdTypUInt48:
-        {
-            AmiSetQword48ToLe(pDstData_p, *((QWORD*)pSrcData));
-            break;
-        }
-
-        // 56 bit values
-        case kEplObdTypInt56:
-        case kEplObdTypUInt56:
-        {
-            AmiSetQword56ToLe(pDstData_p, *((QWORD*)pSrcData));
-            break;
-        }
-
-        // 64 bit values
-        case kEplObdTypInt64:
-        case kEplObdTypUInt64:
-        case kEplObdTypReal64:
-        {
-            AmiSetQword64ToLe(pDstData_p, *((QWORD*)pSrcData));
-            break;
-        }
-
-        // time of day
-        case kEplObdTypTimeOfDay:
-        case kEplObdTypTimeDiff:
-        {
-            AmiSetTimeOfDay(pDstData_p, ((tTimeOfDay*)pSrcData));
-            break;
-        }
-
-    }// end of switch(pSubEntry->m_Type)
-
-    *pSize_p = ObdSize;
-
+EPLDLLEXPORT tEplKernel PUBLIC EplObdReadEntryToLe(EPL_MCO_DECL_INSTANCE_PTR_
+						   unsigned int uiIndex_p,
+						   unsigned int uiSubIndex_p,
+						   void *pDstData_p,
+						   tEplObdSize * pSize_p)
+{
+	tEplKernel Ret;
+	tEplObdEntryPtr pObdEntry;
+	tEplObdSubEntryPtr pSubEntry;
+	tEplObdCbParam MEM CbParam;
+	void *pSrcData;
+	tEplObdSize ObdSize;
+
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
+
+	ASSERT(pDstData_p != NULL);
+	ASSERT(pSize_p != NULL);
+
+	// get address of index and subindex entry
+	Ret = EplObdGetEntry(EPL_MCO_INSTANCE_PTR_
+			     uiIndex_p, uiSubIndex_p, &pObdEntry, &pSubEntry);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// get pointer to object data
+	pSrcData = EplObdGetObjectDataPtrIntern(pSubEntry);
+
+	// check source pointer
+	if (pSrcData == NULL) {
+		Ret = kEplObdReadViolation;
+		goto Exit;
+	}
+	//------------------------------------------------------------------------
+	// address of source data to structure of callback parameters
+	// so callback function can change this data before reading
+	CbParam.m_uiIndex = uiIndex_p;
+	CbParam.m_uiSubIndex = uiSubIndex_p;
+	CbParam.m_pArg = pSrcData;
+	CbParam.m_ObdEvent = kEplObdEvPreRead;
+	Ret = EplObdCallObjectCallback(EPL_MCO_INSTANCE_PTR_
+				       pObdEntry->m_fpCallback, &CbParam);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// get size of data and check if application has reserved enough memory
+	ObdSize = EplObdGetDataSizeIntern(pSubEntry);
+	// check if offset given and calc correct number of bytes to read
+	if (*pSize_p < ObdSize) {
+		Ret = kEplObdValueLengthError;
+		goto Exit;
+	}
+	// check if numerical type
+	switch (pSubEntry->m_Type) {
+		//-----------------------------------------------
+		// types without ami
+	case kEplObdTypVString:
+	case kEplObdTypOString:
+	case kEplObdTypDomain:
+	default:
+		{
+			// read value from object
+			EPL_MEMCPY(pDstData_p, pSrcData, ObdSize);
+			break;
+		}
+
+		//-----------------------------------------------
+		// numerical type which needs ami-write
+		// 8 bit or smaller values
+	case kEplObdTypBool:
+	case kEplObdTypInt8:
+	case kEplObdTypUInt8:
+		{
+			AmiSetByteToLe(pDstData_p, *((BYTE *) pSrcData));
+			break;
+		}
+
+		// 16 bit values
+	case kEplObdTypInt16:
+	case kEplObdTypUInt16:
+		{
+			AmiSetWordToLe(pDstData_p, *((WORD *) pSrcData));
+			break;
+		}
+
+		// 24 bit values
+	case kEplObdTypInt24:
+	case kEplObdTypUInt24:
+		{
+			AmiSetDword24ToLe(pDstData_p, *((DWORD *) pSrcData));
+			break;
+		}
+
+		// 32 bit values
+	case kEplObdTypInt32:
+	case kEplObdTypUInt32:
+	case kEplObdTypReal32:
+		{
+			AmiSetDwordToLe(pDstData_p, *((DWORD *) pSrcData));
+			break;
+		}
+
+		// 40 bit values
+	case kEplObdTypInt40:
+	case kEplObdTypUInt40:
+		{
+			AmiSetQword40ToLe(pDstData_p, *((QWORD *) pSrcData));
+			break;
+		}
+
+		// 48 bit values
+	case kEplObdTypInt48:
+	case kEplObdTypUInt48:
+		{
+			AmiSetQword48ToLe(pDstData_p, *((QWORD *) pSrcData));
+			break;
+		}
+
+		// 56 bit values
+	case kEplObdTypInt56:
+	case kEplObdTypUInt56:
+		{
+			AmiSetQword56ToLe(pDstData_p, *((QWORD *) pSrcData));
+			break;
+		}
+
+		// 64 bit values
+	case kEplObdTypInt64:
+	case kEplObdTypUInt64:
+	case kEplObdTypReal64:
+		{
+			AmiSetQword64ToLe(pDstData_p, *((QWORD *) pSrcData));
+			break;
+		}
+
+		// time of day
+	case kEplObdTypTimeOfDay:
+	case kEplObdTypTimeDiff:
+		{
+			AmiSetTimeOfDay(pDstData_p, ((tTimeOfDay *) pSrcData));
+			break;
+		}
+
+	}			// end of switch(pSubEntry->m_Type)
+
+	*pSize_p = ObdSize;
+
+	// write address of destination data to structure of callback parameters
+	// so callback function can change this data after reading
+	CbParam.m_pArg = pDstData_p;
+	CbParam.m_ObdEvent = kEplObdEvPostRead;
+	Ret = EplObdCallObjectCallback(EPL_MCO_INSTANCE_PTR_
+				       pObdEntry->m_fpCallback, &CbParam);
 
-    // write address of destination data to structure of callback parameters
-    // so callback function can change this data after reading
-    CbParam.m_pArg     = pDstData_p;
-    CbParam.m_ObdEvent = kEplObdEvPostRead;
-    Ret = EplObdCallObjectCallback (EPL_MCO_INSTANCE_PTR_
-        pObdEntry->m_fpCallback, &CbParam);
+      Exit:
 
-Exit:
-
-    return Ret;
+	return Ret;
 
 }
 
@@ -1306,144 +1199,132 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObdWriteEntryFromLe (EPL_MCO_DECL_INSTANCE_PTR_
-                                        unsigned int  uiIndex_p,
-                                        unsigned int  uiSubIndex_p,
-                                        void *        pSrcData_p,
-                                        tEplObdSize   Size_p)
-{
-tEplKernel              Ret;
-tEplObdEntryPtr         pObdEntry;
-tEplObdSubEntryPtr      pSubEntry;
-tEplObdCbParam MEM      CbParam;
-void MEM*               pDstData;
-tEplObdSize             ObdSize;
-QWORD                   qwBuffer;
-void*                   pBuffer = &qwBuffer;
-
-
-    Ret = EplObdWriteEntryPre (EPL_MCO_INSTANCE_PTR_
-                               uiIndex_p,
-                               uiSubIndex_p,
-                               pSrcData_p,
-                               &pDstData,
-                               Size_p,
-                               &pObdEntry,
-                               &pSubEntry,
-                               &CbParam,
-                               &ObdSize);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-
-    // check if numerical type
-    switch(pSubEntry->m_Type)
-    {
-        //-----------------------------------------------
-        // types without ami
-        default:
-        {   // do nothing, i.e. use the given source pointer
-            pBuffer = pSrcData_p;
-            break;
-        }
-
-        //-----------------------------------------------
-        // numerical type which needs ami-write
-        // 8 bit or smaller values
-        case kEplObdTypBool:
-        case kEplObdTypInt8:
-        case kEplObdTypUInt8:
-        {
-            *((BYTE*)pBuffer) = AmiGetByteFromLe(pSrcData_p);
-            break;
-        }
-
-        // 16 bit values
-        case kEplObdTypInt16:
-        case kEplObdTypUInt16:
-        {
-            *((WORD*)pBuffer) = AmiGetWordFromLe(pSrcData_p);
-            break;
-        }
-
-        // 24 bit values
-        case kEplObdTypInt24:
-        case kEplObdTypUInt24:
-        {
-            *((DWORD*)pBuffer) = AmiGetDword24FromLe(pSrcData_p);
-            break;
-        }
-
-        // 32 bit values
-        case kEplObdTypInt32:
-        case kEplObdTypUInt32:
-        case kEplObdTypReal32:
-        {
-            *((DWORD*)pBuffer) = AmiGetDwordFromLe(pSrcData_p);
-            break;
-        }
-
-        // 40 bit values
-        case kEplObdTypInt40:
-        case kEplObdTypUInt40:
-        {
-            *((QWORD*)pBuffer) = AmiGetQword40FromLe(pSrcData_p);
-            break;
-        }
-
-        // 48 bit values
-        case kEplObdTypInt48:
-        case kEplObdTypUInt48:
-        {
-            *((QWORD*)pBuffer) = AmiGetQword48FromLe(pSrcData_p);
-            break;
-        }
-
-        // 56 bit values
-        case kEplObdTypInt56:
-        case kEplObdTypUInt56:
-        {
-            *((QWORD*)pBuffer) = AmiGetQword56FromLe(pSrcData_p);
-            break;
-        }
-
-        // 64 bit values
-        case kEplObdTypInt64:
-        case kEplObdTypUInt64:
-        case kEplObdTypReal64:
-        {
-            *((QWORD*)pBuffer) = AmiGetQword64FromLe(pSrcData_p);
-            break;
-        }
-
-        // time of day
-        case kEplObdTypTimeOfDay:
-        case kEplObdTypTimeDiff:
-        {
-            AmiGetTimeOfDay(pBuffer, ((tTimeOfDay*)pSrcData_p));
-            break;
-        }
-
-    }// end of switch(pSubEntry->m_Type)
-
-
-    Ret = EplObdWriteEntryPost (EPL_MCO_INSTANCE_PTR_
-                                pObdEntry,
-                                pSubEntry,
-                                &CbParam,
-                                pBuffer,
-                                pDstData,
-                                ObdSize);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+EPLDLLEXPORT tEplKernel PUBLIC EplObdWriteEntryFromLe(EPL_MCO_DECL_INSTANCE_PTR_
+						      unsigned int uiIndex_p,
+						      unsigned int uiSubIndex_p,
+						      void *pSrcData_p,
+						      tEplObdSize Size_p)
+{
+	tEplKernel Ret;
+	tEplObdEntryPtr pObdEntry;
+	tEplObdSubEntryPtr pSubEntry;
+	tEplObdCbParam MEM CbParam;
+	void MEM *pDstData;
+	tEplObdSize ObdSize;
+	QWORD qwBuffer;
+	void *pBuffer = &qwBuffer;
+
+	Ret = EplObdWriteEntryPre(EPL_MCO_INSTANCE_PTR_
+				  uiIndex_p,
+				  uiSubIndex_p,
+				  pSrcData_p,
+				  &pDstData,
+				  Size_p,
+				  &pObdEntry, &pSubEntry, &CbParam, &ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	// check if numerical type
+	switch (pSubEntry->m_Type) {
+		//-----------------------------------------------
+		// types without ami
+	default:
+		{		// do nothing, i.e. use the given source pointer
+			pBuffer = pSrcData_p;
+			break;
+		}
+
+		//-----------------------------------------------
+		// numerical type which needs ami-write
+		// 8 bit or smaller values
+	case kEplObdTypBool:
+	case kEplObdTypInt8:
+	case kEplObdTypUInt8:
+		{
+			*((BYTE *) pBuffer) = AmiGetByteFromLe(pSrcData_p);
+			break;
+		}
+
+		// 16 bit values
+	case kEplObdTypInt16:
+	case kEplObdTypUInt16:
+		{
+			*((WORD *) pBuffer) = AmiGetWordFromLe(pSrcData_p);
+			break;
+		}
+
+		// 24 bit values
+	case kEplObdTypInt24:
+	case kEplObdTypUInt24:
+		{
+			*((DWORD *) pBuffer) = AmiGetDword24FromLe(pSrcData_p);
+			break;
+		}
+
+		// 32 bit values
+	case kEplObdTypInt32:
+	case kEplObdTypUInt32:
+	case kEplObdTypReal32:
+		{
+			*((DWORD *) pBuffer) = AmiGetDwordFromLe(pSrcData_p);
+			break;
+		}
+
+		// 40 bit values
+	case kEplObdTypInt40:
+	case kEplObdTypUInt40:
+		{
+			*((QWORD *) pBuffer) = AmiGetQword40FromLe(pSrcData_p);
+			break;
+		}
+
+		// 48 bit values
+	case kEplObdTypInt48:
+	case kEplObdTypUInt48:
+		{
+			*((QWORD *) pBuffer) = AmiGetQword48FromLe(pSrcData_p);
+			break;
+		}
+
+		// 56 bit values
+	case kEplObdTypInt56:
+	case kEplObdTypUInt56:
+		{
+			*((QWORD *) pBuffer) = AmiGetQword56FromLe(pSrcData_p);
+			break;
+		}
+
+		// 64 bit values
+	case kEplObdTypInt64:
+	case kEplObdTypUInt64:
+	case kEplObdTypReal64:
+		{
+			*((QWORD *) pBuffer) = AmiGetQword64FromLe(pSrcData_p);
+			break;
+		}
+
+		// time of day
+	case kEplObdTypTimeOfDay:
+	case kEplObdTypTimeDiff:
+		{
+			AmiGetTimeOfDay(pBuffer, ((tTimeOfDay *) pSrcData_p));
+			break;
+		}
+
+	}			// end of switch(pSubEntry->m_Type)
+
+	Ret = EplObdWriteEntryPost(EPL_MCO_INSTANCE_PTR_
+				   pObdEntry,
+				   pSubEntry,
+				   &CbParam, pBuffer, pDstData, ObdSize);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 
-Exit:
+      Exit:
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -1465,40 +1346,30 @@ Exit:
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplObdGetAccessType(EPL_MCO_DECL_INSTANCE_PTR_
-                                        unsigned int uiIndex_p,
-                                        unsigned int uiSubIndex_p,
-                                        tEplObdAccess* pAccessTyp_p)
-
-{
-tEplKernel          Ret;
-tEplObdEntryPtr     pObdEntry;
-tEplObdSubEntryPtr  pObdSubEntry;
-
-
-    // get pointer to index structure
-    Ret = EplObdGetIndexIntern (&EPL_MCO_GLB_VAR (m_ObdInitParam),
-                                uiIndex_p,
-                                &pObdEntry);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // get pointer to subindex structure
-    Ret = EplObdGetSubindexIntern (pObdEntry,
-                                uiSubIndex_p,
-                                &pObdSubEntry);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // get accessType
-    *pAccessTyp_p = pObdSubEntry->m_Access;
-
+						   unsigned int uiIndex_p,
+						   unsigned int uiSubIndex_p,
+						   tEplObdAccess * pAccessTyp_p)
+{
+	tEplKernel Ret;
+	tEplObdEntryPtr pObdEntry;
+	tEplObdSubEntryPtr pObdSubEntry;
+
+	// get pointer to index structure
+	Ret = EplObdGetIndexIntern(&EPL_MCO_GLB_VAR(m_ObdInitParam),
+				   uiIndex_p, &pObdEntry);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// get pointer to subindex structure
+	Ret = EplObdGetSubindexIntern(pObdEntry, uiSubIndex_p, &pObdSubEntry);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// get accessType
+	*pAccessTyp_p = pObdSubEntry->m_Access;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1517,37 +1388,37 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplObdSearchVarEntry (EPL_MCO_DECL_INSTANCE_PTR_
-    unsigned int            uiIndex_p,
-    unsigned int            uiSubindex_p,
-    tEplObdVarEntry MEM**   ppVarEntry_p)
-{
-
-tEplKernel           Ret;
-tEplObdSubEntryPtr   pSubindexEntry;
-
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
-
-    // get address of subindex entry
-    Ret = EplObdGetEntry (EPL_MCO_INSTANCE_PTR_
-        uiIndex_p, uiSubindex_p, NULL, &pSubindexEntry);
-    if (Ret == kEplSuccessful)
-    {
-        // get var entry
-        Ret = EplObdGetVarEntry (pSubindexEntry, ppVarEntry_p);
-    }
+tEplKernel PUBLIC EplObdSearchVarEntry(EPL_MCO_DECL_INSTANCE_PTR_
+				       unsigned int uiIndex_p,
+				       unsigned int uiSubindex_p,
+				       tEplObdVarEntry MEM ** ppVarEntry_p)
+{
+
+	tEplKernel Ret;
+	tEplObdSubEntryPtr pSubindexEntry;
+
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
+
+	// get address of subindex entry
+	Ret = EplObdGetEntry(EPL_MCO_INSTANCE_PTR_
+			     uiIndex_p, uiSubindex_p, NULL, &pSubindexEntry);
+	if (Ret == kEplSuccessful) {
+		// get var entry
+		Ret = EplObdGetVarEntry(pSubindexEntry, ppVarEntry_p);
+	}
 
-    return Ret;
+	return Ret;
 
 }
+
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
 //                                                                         //
 //=========================================================================//
 
-EPL_MCO_DECL_INSTANCE_FCT ()
+EPL_MCO_DECL_INSTANCE_FCT()
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdCallObjectCallback()
@@ -1562,35 +1433,33 @@ EPL_MCO_DECL_INSTANCE_FCT ()
 // State:
 //
 //---------------------------------------------------------------------------
-
-static tEplKernel EplObdCallObjectCallback (EPL_MCO_DECL_INSTANCE_PTR_
-    tEplObdCallback fpCallback_p,
-    tEplObdCbParam MEM* pCbParam_p)
+static tEplKernel EplObdCallObjectCallback(EPL_MCO_DECL_INSTANCE_PTR_
+					   tEplObdCallback fpCallback_p,
+					   tEplObdCbParam MEM * pCbParam_p)
 {
 
-tEplKernel           Ret;
-tEplObdCallback MEM  fpCallback;
+	tEplKernel Ret;
+	tEplObdCallback MEM fpCallback;
 
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
 
-    ASSERT (pCbParam_p != NULL);
+	ASSERT(pCbParam_p != NULL);
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // check address of callback function before calling it
-    if (fpCallback_p != NULL)
-    {
-        // KEIL C51 V6.01 has a bug.
-        // Therefore the parameter fpCallback_p has to be copied in local variable fpCallback.
-        fpCallback = fpCallback_p;
-
-        // call callback function for this object
-        Ret = fpCallback (EPL_MCO_INSTANCE_PARAM_IDX_()
-            pCbParam_p);
-    }
+	// check address of callback function before calling it
+	if (fpCallback_p != NULL) {
+		// KEIL C51 V6.01 has a bug.
+		// Therefore the parameter fpCallback_p has to be copied in local variable fpCallback.
+		fpCallback = fpCallback_p;
 
-    return Ret;
+		// call callback function for this object
+		Ret = fpCallback(EPL_MCO_INSTANCE_PARAM_IDX_()
+				 pCbParam_p);
+	}
+
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1608,33 +1477,33 @@ tEplObdCallback MEM  fpCallback;
 //
 //---------------------------------------------------------------------------
 
-static tEplObdSize EplObdGetDataSizeIntern (tEplObdSubEntryPtr pSubIndexEntry_p)
+static tEplObdSize EplObdGetDataSizeIntern(tEplObdSubEntryPtr pSubIndexEntry_p)
 {
 
-tEplObdSize DataSize;
-void MEM*   pData;
+	tEplObdSize DataSize;
+	void MEM *pData;
 
-    // If OD entry is defined by macro EPL_OBD_SUBINDEX_ROM_VSTRING
-    // then the current pointer is always NULL. The function
-    // returns the length of default string.
-    DataSize = EplObdGetObjectSize (pSubIndexEntry_p);
+	// If OD entry is defined by macro EPL_OBD_SUBINDEX_ROM_VSTRING
+	// then the current pointer is always NULL. The function
+	// returns the length of default string.
+	DataSize = EplObdGetObjectSize(pSubIndexEntry_p);
+
+	if (pSubIndexEntry_p->m_Type == kEplObdTypVString) {
+		// The pointer to current value can be received from EplObdGetObjectCurrentPtr()
+		pData =
+		    ((void MEM *)EplObdGetObjectCurrentPtr(pSubIndexEntry_p));
+		if (pData != NULL) {
+			DataSize =
+			    EplObdGetStrLen((void *)pData, DataSize,
+					    pSubIndexEntry_p->m_Type);
+		}
 
-    if (pSubIndexEntry_p->m_Type == kEplObdTypVString)
-    {
-        // The pointer to current value can be received from EplObdGetObjectCurrentPtr()
-        pData = ((void MEM*) EplObdGetObjectCurrentPtr (pSubIndexEntry_p));
-        if (pData != NULL)
-        {
-            DataSize = EplObdGetStrLen ((void *) pData, DataSize, pSubIndexEntry_p->m_Type);
-        }
-
-    }
+	}
 
-    return DataSize;
+	return DataSize;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdGetStrLen()
@@ -1652,47 +1521,38 @@ void MEM*   pData;
 //
 //---------------------------------------------------------------------------
 
-static tEplObdSize EplObdGetStrLen (void * pObjData_p,
-                                 tEplObdSize ObjLen_p,
-                                 tEplObdType ObjType_p)
+static tEplObdSize EplObdGetStrLen(void *pObjData_p,
+				   tEplObdSize ObjLen_p, tEplObdType ObjType_p)
 {
 
-tEplObdSize    StrLen = 0;
-BYTE *  pbString;
+	tEplObdSize StrLen = 0;
+	BYTE *pbString;
 
-    if (pObjData_p == NULL)
-    {
-        goto Exit;
-    }
-
-    //----------------------------------------
-    // Visible String: data format byte
-    if (ObjType_p == kEplObdTypVString)
-    {
-        pbString = pObjData_p;
+	if (pObjData_p == NULL) {
+		goto Exit;
+	}
+	//----------------------------------------
+	// Visible String: data format byte
+	if (ObjType_p == kEplObdTypVString) {
+		pbString = pObjData_p;
+
+		for (StrLen = 0; StrLen < ObjLen_p; StrLen++) {
+			if (*pbString == '\0') {
+				StrLen++;
+				break;
+			}
+
+			pbString++;
+		}
+	}
+	//----------------------------------------
+	// other string types ...
 
-        for (StrLen = 0; StrLen < ObjLen_p; StrLen++)
-        {
-            if (*pbString == '\0')
-            {
-                StrLen++;
-                break;
-            }
-
-            pbString++;
-        }
-    }
-
-    //----------------------------------------
-    // other string types ...
-
-Exit:
-    return (StrLen);
+      Exit:
+	return (StrLen);
 
 }
 
-
-
 #if (EPL_OBD_CHECK_OBJECT_RANGE != FALSE)
 
 //---------------------------------------------------------------------------
@@ -1715,293 +1575,277 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplObdCheckObjectRange (
-            tEplObdSubEntryPtr pSubindexEntry_p,
-            void * pData_p)
+static tEplKernel EplObdCheckObjectRange(tEplObdSubEntryPtr pSubindexEntry_p,
+					 void *pData_p)
 {
 
-tEplKernel      Ret;
-void *   pRangeData;
+	tEplKernel Ret;
+	void *pRangeData;
 
-    ASSERTMSG (pSubindexEntry_p != NULL,
-        "EplObdCheckObjectRange(): no address to subindex struct!\n");
+	ASSERTMSG(pSubindexEntry_p != NULL,
+		  "EplObdCheckObjectRange(): no address to subindex struct!\n");
+
+	Ret = kEplSuccessful;
+
+	// check if data range has to be checked
+	if ((pSubindexEntry_p->m_Access & kEplObdAccRange) == 0) {
+		goto Exit;
+	}
+	// get address of default data
+	pRangeData = pSubindexEntry_p->m_pDefault;
+
+	// jump to called object type
+	switch ((tEplObdType) pSubindexEntry_p->m_Type) {
+		// -----------------------------------------------------------------
+		// ObdType kEplObdTypBool will not be checked because there are only
+		// two possible values 0 or 1.
+
+		// -----------------------------------------------------------------
+		// ObdTypes which has to be check up because numerical values
+	case kEplObdTypInt8:
+
+		// switch to lower limit
+		pRangeData = ((tEplObdInteger8 *) pRangeData) + 1;
+
+		// check if value is to low
+		if (*((tEplObdInteger8 *) pData_p) <
+		    *((tEplObdInteger8 *) pRangeData)) {
+			Ret = kEplObdValueTooLow;
+			break;
+		}
+		// switch to higher limit
+		pRangeData = ((tEplObdInteger8 *) pRangeData) + 1;
+
+		// check if value is to high
+		if (*((tEplObdInteger8 *) pData_p) >
+		    *((tEplObdInteger8 *) pRangeData)) {
+			Ret = kEplObdValueTooHigh;
+		}
+
+		break;
+
+	case kEplObdTypUInt8:
+
+		// switch to lower limit
+		pRangeData = ((tEplObdUnsigned8 *) pRangeData) + 1;
+
+		// check if value is to low
+		if (*((tEplObdUnsigned8 *) pData_p) <
+		    *((tEplObdUnsigned8 *) pRangeData)) {
+			Ret = kEplObdValueTooLow;
+			break;
+		}
+		// switch to higher limit
+		pRangeData = ((tEplObdUnsigned8 *) pRangeData) + 1;
+
+		// check if value is to high
+		if (*((tEplObdUnsigned8 *) pData_p) >
+		    *((tEplObdUnsigned8 *) pRangeData)) {
+			Ret = kEplObdValueTooHigh;
+		}
+
+		break;
+
+	case kEplObdTypInt16:
+
+		// switch to lower limit
+		pRangeData = ((tEplObdInteger16 *) pRangeData) + 1;
+
+		// check if value is to low
+		if (*((tEplObdInteger16 *) pData_p) <
+		    *((tEplObdInteger16 *) pRangeData)) {
+			Ret = kEplObdValueTooLow;
+			break;
+		}
+		// switch to higher limit
+		pRangeData = ((tEplObdInteger16 *) pRangeData) + 1;
+
+		// check if value is to high
+		if (*((tEplObdInteger16 *) pData_p) >
+		    *((tEplObdInteger16 *) pRangeData)) {
+			Ret = kEplObdValueTooHigh;
+		}
+
+		break;
+
+	case kEplObdTypUInt16:
+
+		// switch to lower limit
+		pRangeData = ((tEplObdUnsigned16 *) pRangeData) + 1;
+
+		// check if value is to low
+		if (*((tEplObdUnsigned16 *) pData_p) <
+		    *((tEplObdUnsigned16 *) pRangeData)) {
+			Ret = kEplObdValueTooLow;
+			break;
+		}
+		// switch to higher limit
+		pRangeData = ((tEplObdUnsigned16 *) pRangeData) + 1;
+
+		// check if value is to high
+		if (*((tEplObdUnsigned16 *) pData_p) >
+		    *((tEplObdUnsigned16 *) pRangeData)) {
+			Ret = kEplObdValueTooHigh;
+		}
+
+		break;
+
+	case kEplObdTypInt32:
+
+		// switch to lower limit
+		pRangeData = ((tEplObdInteger32 *) pRangeData) + 1;
+
+		// check if value is to low
+		if (*((tEplObdInteger32 *) pData_p) <
+		    *((tEplObdInteger32 *) pRangeData)) {
+			Ret = kEplObdValueTooLow;
+			break;
+		}
+		// switch to higher limit
+		pRangeData = ((tEplObdInteger32 *) pRangeData) + 1;
+
+		// check if value is to high
+		if (*((tEplObdInteger32 *) pData_p) >
+		    *((tEplObdInteger32 *) pRangeData)) {
+			Ret = kEplObdValueTooHigh;
+		}
+
+		break;
+
+	case kEplObdTypUInt32:
+
+		// switch to lower limit
+		pRangeData = ((tEplObdUnsigned32 *) pRangeData) + 1;
+
+		// check if value is to low
+		if (*((tEplObdUnsigned32 *) pData_p) <
+		    *((tEplObdUnsigned32 *) pRangeData)) {
+			Ret = kEplObdValueTooLow;
+			break;
+		}
+		// switch to higher limit
+		pRangeData = ((tEplObdUnsigned32 *) pRangeData) + 1;
+
+		// check if value is to high
+		if (*((tEplObdUnsigned32 *) pData_p) >
+		    *((tEplObdUnsigned32 *) pRangeData)) {
+			Ret = kEplObdValueTooHigh;
+		}
+
+		break;
+
+	case kEplObdTypReal32:
+
+		// switch to lower limit
+		pRangeData = ((tEplObdReal32 *) pRangeData) + 1;
+
+		// check if value is to low
+		if (*((tEplObdReal32 *) pData_p) <
+		    *((tEplObdReal32 *) pRangeData)) {
+			Ret = kEplObdValueTooLow;
+			break;
+		}
+		// switch to higher limit
+		pRangeData = ((tEplObdReal32 *) pRangeData) + 1;
+
+		// check if value is to high
+		if (*((tEplObdReal32 *) pData_p) >
+		    *((tEplObdReal32 *) pRangeData)) {
+			Ret = kEplObdValueTooHigh;
+		}
+
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypInt40:
+	case kEplObdTypInt48:
+	case kEplObdTypInt56:
+	case kEplObdTypInt64:
+
+		// switch to lower limit
+		pRangeData = ((signed QWORD *)pRangeData) + 1;
+
+		// check if value is to low
+		if (*((signed QWORD *)pData_p) < *((signed QWORD *)pRangeData)) {
+			Ret = kEplObdValueTooLow;
+			break;
+		}
+		// switch to higher limit
+		pRangeData = ((signed QWORD *)pRangeData) + 1;
+
+		// check if value is to high
+		if (*((signed QWORD *)pData_p) > *((signed QWORD *)pRangeData)) {
+			Ret = kEplObdValueTooHigh;
+		}
+
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypUInt40:
+	case kEplObdTypUInt48:
+	case kEplObdTypUInt56:
+	case kEplObdTypUInt64:
+
+		// switch to lower limit
+		pRangeData = ((unsigned QWORD *)pRangeData) + 1;
+
+		// check if value is to low
+		if (*((unsigned QWORD *)pData_p) <
+		    *((unsigned QWORD *)pRangeData)) {
+			Ret = kEplObdValueTooLow;
+			break;
+		}
+		// switch to higher limit
+		pRangeData = ((unsigned QWORD *)pRangeData) + 1;
+
+		// check if value is to high
+		if (*((unsigned QWORD *)pData_p) >
+		    *((unsigned QWORD *)pRangeData)) {
+			Ret = kEplObdValueTooHigh;
+		}
+
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypReal64:
+
+		// switch to lower limit
+		pRangeData = ((tEplObdReal64 *) pRangeData) + 1;
+
+		// check if value is to low
+		if (*((tEplObdReal64 *) pData_p) <
+		    *((tEplObdReal64 *) pRangeData)) {
+			Ret = kEplObdValueTooLow;
+			break;
+		}
+		// switch to higher limit
+		pRangeData = ((tEplObdReal64 *) pRangeData) + 1;
+
+		// check if value is to high
+		if (*((tEplObdReal64 *) pData_p) >
+		    *((tEplObdReal64 *) pRangeData)) {
+			Ret = kEplObdValueTooHigh;
+		}
+
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypTimeOfDay:
+	case kEplObdTypTimeDiff:
+		break;
+
+		// -----------------------------------------------------------------
+		// ObdTypes kEplObdTypXString and kEplObdTypDomain can not be checkt because
+		// they have no numerical value.
+	default:
+
+		Ret = kEplObdUnknownObjectType;
+		break;
+	}
 
-    Ret  = kEplSuccessful;
+      Exit:
 
-    // check if data range has to be checked
-    if ((pSubindexEntry_p->m_Access & kEplObdAccRange) == 0)
-    {
-        goto Exit;
-    }
-
-    // get address of default data
-    pRangeData = pSubindexEntry_p->m_pDefault;
-
-    // jump to called object type
-    switch ((tEplObdType) pSubindexEntry_p->m_Type)
-    {
-        // -----------------------------------------------------------------
-        // ObdType kEplObdTypBool will not be checked because there are only
-        // two possible values 0 or 1.
-
-        // -----------------------------------------------------------------
-        // ObdTypes which has to be check up because numerical values
-        case kEplObdTypInt8:
-
-            // switch to lower limit
-            pRangeData = ((tEplObdInteger8 *) pRangeData) + 1;
-
-            // check if value is to low
-            if (*((tEplObdInteger8 *) pData_p) < *((tEplObdInteger8 *) pRangeData))
-            {
-                Ret = kEplObdValueTooLow;
-                break;
-            }
-
-            // switch to higher limit
-            pRangeData = ((tEplObdInteger8 *) pRangeData) + 1;
-
-            // check if value is to high
-            if (*((tEplObdInteger8 *) pData_p) > *((tEplObdInteger8 *) pRangeData))
-            {
-                Ret = kEplObdValueTooHigh;
-            }
-
-            break;
-
-        case kEplObdTypUInt8:
-
-            // switch to lower limit
-            pRangeData = ((tEplObdUnsigned8 *) pRangeData) + 1;
-
-            // check if value is to low
-            if (*((tEplObdUnsigned8 *) pData_p) < *((tEplObdUnsigned8 *) pRangeData))
-            {
-                Ret = kEplObdValueTooLow;
-                break;
-            }
-
-            // switch to higher limit
-            pRangeData = ((tEplObdUnsigned8*) pRangeData) + 1;
-
-            // check if value is to high
-            if (*((tEplObdUnsigned8 *) pData_p) > *((tEplObdUnsigned8 *) pRangeData))
-            {
-                Ret = kEplObdValueTooHigh;
-            }
-
-            break;
-
-        case kEplObdTypInt16:
-
-            // switch to lower limit
-            pRangeData = ((tEplObdInteger16 *) pRangeData) + 1;
-
-            // check if value is to low
-            if (*((tEplObdInteger16 *) pData_p) < *((tEplObdInteger16 *) pRangeData))
-            {
-                Ret = kEplObdValueTooLow;
-                break;
-            }
-
-            // switch to higher limit
-            pRangeData = ((tEplObdInteger16 *) pRangeData) + 1;
-
-            // check if value is to high
-            if (*((tEplObdInteger16 *) pData_p) > *((tEplObdInteger16 *) pRangeData))
-            {
-                Ret = kEplObdValueTooHigh;
-            }
-
-            break;
-
-        case kEplObdTypUInt16:
-
-            // switch to lower limit
-            pRangeData = ((tEplObdUnsigned16 *) pRangeData) + 1;
-
-            // check if value is to low
-            if (*((tEplObdUnsigned16 *) pData_p) < *((tEplObdUnsigned16 *) pRangeData))
-            {
-                Ret = kEplObdValueTooLow;
-                break;
-            }
-
-            // switch to higher limit
-            pRangeData = ((tEplObdUnsigned16 *) pRangeData) + 1;
-
-            // check if value is to high
-            if (*((tEplObdUnsigned16 *) pData_p) > *((tEplObdUnsigned16 *) pRangeData))
-            {
-                Ret = kEplObdValueTooHigh;
-            }
-
-            break;
-
-        case kEplObdTypInt32:
-
-            // switch to lower limit
-            pRangeData = ((tEplObdInteger32 *) pRangeData) + 1;
-
-            // check if value is to low
-            if (*((tEplObdInteger32 *) pData_p) < *((tEplObdInteger32 *) pRangeData))
-            {
-                Ret = kEplObdValueTooLow;
-                break;
-            }
-
-            // switch to higher limit
-            pRangeData = ((tEplObdInteger32 *) pRangeData) + 1;
-
-            // check if value is to high
-            if (*((tEplObdInteger32 *) pData_p) > *((tEplObdInteger32 *) pRangeData))
-            {
-                Ret = kEplObdValueTooHigh;
-            }
-
-            break;
-
-        case kEplObdTypUInt32:
-
-            // switch to lower limit
-            pRangeData = ((tEplObdUnsigned32 *) pRangeData) + 1;
-
-            // check if value is to low
-            if (*((tEplObdUnsigned32 *) pData_p) < *((tEplObdUnsigned32 *) pRangeData))
-            {
-                Ret = kEplObdValueTooLow;
-                break;
-            }
-
-            // switch to higher limit
-            pRangeData = ((tEplObdUnsigned32 *) pRangeData) + 1;
-
-            // check if value is to high
-            if (*((tEplObdUnsigned32 *) pData_p) > *((tEplObdUnsigned32 *) pRangeData))
-            {
-                Ret = kEplObdValueTooHigh;
-            }
-
-            break;
-
-        case kEplObdTypReal32:
-
-            // switch to lower limit
-            pRangeData = ((tEplObdReal32 *) pRangeData) + 1;
-
-            // check if value is to low
-            if (*((tEplObdReal32 *) pData_p) < *((tEplObdReal32 *) pRangeData))
-            {
-                Ret = kEplObdValueTooLow;
-                break;
-            }
-
-            // switch to higher limit
-            pRangeData = ((tEplObdReal32 *) pRangeData) + 1;
-
-            // check if value is to high
-            if (*((tEplObdReal32 *) pData_p) > *((tEplObdReal32 *) pRangeData))
-            {
-                Ret = kEplObdValueTooHigh;
-            }
-
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypInt40:
-        case kEplObdTypInt48:
-        case kEplObdTypInt56:
-        case kEplObdTypInt64:
-
-            // switch to lower limit
-            pRangeData = ((signed QWORD *) pRangeData) + 1;
-
-            // check if value is to low
-            if (*((signed QWORD *) pData_p) < *((signed QWORD *) pRangeData))
-            {
-                Ret = kEplObdValueTooLow;
-                break;
-            }
-
-            // switch to higher limit
-            pRangeData = ((signed QWORD *) pRangeData) + 1;
-
-            // check if value is to high
-            if (*((signed QWORD *) pData_p) > *((signed QWORD *) pRangeData))
-            {
-                Ret = kEplObdValueTooHigh;
-            }
-
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypUInt40:
-        case kEplObdTypUInt48:
-        case kEplObdTypUInt56:
-        case kEplObdTypUInt64:
-
-            // switch to lower limit
-            pRangeData = ((unsigned QWORD *) pRangeData) + 1;
-
-            // check if value is to low
-            if (*((unsigned QWORD *) pData_p) < *((unsigned QWORD *) pRangeData))
-            {
-                Ret = kEplObdValueTooLow;
-                break;
-            }
-
-            // switch to higher limit
-            pRangeData = ((unsigned QWORD *) pRangeData) + 1;
-
-            // check if value is to high
-            if (*((unsigned QWORD *) pData_p) > *((unsigned QWORD *) pRangeData))
-            {
-                Ret = kEplObdValueTooHigh;
-            }
-
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypReal64:
-
-            // switch to lower limit
-            pRangeData = ((tEplObdReal64 *) pRangeData) + 1;
-
-            // check if value is to low
-            if (*((tEplObdReal64 *) pData_p) < *((tEplObdReal64 *) pRangeData))
-            {
-                Ret = kEplObdValueTooLow;
-                break;
-            }
-
-            // switch to higher limit
-            pRangeData = ((tEplObdReal64 *) pRangeData) + 1;
-
-            // check if value is to high
-            if (*((tEplObdReal64 *) pData_p) > *((tEplObdReal64 *) pRangeData))
-            {
-                Ret = kEplObdValueTooHigh;
-            }
-
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypTimeOfDay:
-        case kEplObdTypTimeDiff:
-            break;
-
-        // -----------------------------------------------------------------
-        // ObdTypes kEplObdTypXString and kEplObdTypDomain can not be checkt because
-        // they have no numerical value.
-        default:
-
-            Ret = kEplObdUnknownObjectType;
-            break;
-    }
-
-Exit:
-
-    return Ret;
+	return Ret;
 
 }
 #endif // (EPL_OBD_CHECK_OBJECT_RANGE != FALSE)
@@ -2026,197 +1870,180 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC EplObdWriteEntryPre (EPL_MCO_DECL_INSTANCE_PTR_
-    unsigned int  uiIndex_p,
-    unsigned int  uiSubIndex_p,
-    void * pSrcData_p,
-    void** ppDstData_p,
-    tEplObdSize   Size_p,
-    tEplObdEntryPtr*        ppObdEntry_p,
-    tEplObdSubEntryPtr*     ppSubEntry_p,
-    tEplObdCbParam MEM*     pCbParam_p,
-    tEplObdSize*  pObdSize_p)
-{
-
-tEplKernel              Ret;
-tEplObdEntryPtr         pObdEntry;
-tEplObdSubEntryPtr      pSubEntry;
-tEplObdAccess           Access;
-void MEM*               pDstData;
-tEplObdSize             ObdSize;
-BOOL                    fEntryNumerical;
+static tEplKernel PUBLIC EplObdWriteEntryPre(EPL_MCO_DECL_INSTANCE_PTR_
+					     unsigned int uiIndex_p,
+					     unsigned int uiSubIndex_p,
+					     void *pSrcData_p,
+					     void **ppDstData_p,
+					     tEplObdSize Size_p,
+					     tEplObdEntryPtr * ppObdEntry_p,
+					     tEplObdSubEntryPtr * ppSubEntry_p,
+					     tEplObdCbParam MEM * pCbParam_p,
+					     tEplObdSize * pObdSize_p)
+{
+
+	tEplKernel Ret;
+	tEplObdEntryPtr pObdEntry;
+	tEplObdSubEntryPtr pSubEntry;
+	tEplObdAccess Access;
+	void MEM *pDstData;
+	tEplObdSize ObdSize;
+	BOOL fEntryNumerical;
 
 #if (EPL_OBD_USE_STRING_DOMAIN_IN_RAM != FALSE)
-    tEplObdVStringDomain MEM    MemVStringDomain;
-    void MEM*                   pCurrData;
+	tEplObdVStringDomain MEM MemVStringDomain;
+	void MEM *pCurrData;
 #endif
 
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
 
-    ASSERT (pSrcData_p != NULL);    // should never be NULL
+	ASSERT(pSrcData_p != NULL);	// should never be NULL
 
-    //------------------------------------------------------------------------
-    // get address of index and subindex entry
-    Ret = EplObdGetEntry (EPL_MCO_INSTANCE_PTR_
-        uiIndex_p, uiSubIndex_p, &pObdEntry, &pSubEntry);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    // get pointer to object data
-    pDstData = (void MEM*) EplObdGetObjectDataPtrIntern (pSubEntry);
-
-    Access = (tEplObdAccess) pSubEntry->m_Access;
-
-    // check access for write
-    // access violation if adress to current value is NULL
-    if ( ((Access & kEplObdAccConst) != 0) ||
-         (pDstData == NULL) )
-    {
-        Ret = kEplObdAccessViolation;
-        goto Exit;
-    }
-
-    //------------------------------------------------------------------------
-    // get size of object
-    // -as ObdSize = ObdGetObjectSize (pSubEntry);
-
-    //------------------------------------------------------------------------
-    // To use the same callback function for ObdWriteEntry as well as for
-    // an SDO download call at first (kEplObdEvPre...) the callback function
-    // with the argument pointer to object size.
-    pCbParam_p->m_uiIndex    = uiIndex_p;
-    pCbParam_p->m_uiSubIndex = uiSubIndex_p;
-
-    // Because object size and object pointer are
-    // adapted by user callback function, re-read
-    // this values.
-    ObdSize = EplObdGetObjectSize (pSubEntry);
-    pDstData = (void MEM*) EplObdGetObjectDataPtrIntern (pSubEntry);
-
-    // 09-dec-2004 r.d.:
-    //      Function EplObdWriteEntry() calls new event kEplObdEvWrStringDomain
-    //      for String or Domain which lets called module directly change
-    //      the data pointer or size. This prevents a recursive call to
-    //      the callback function if it calls EplObdGetEntry().
-    #if (EPL_OBD_USE_STRING_DOMAIN_IN_RAM != FALSE)
-    if ( (pSubEntry->m_Type == kEplObdTypVString) ||
-         (pSubEntry->m_Type == kEplObdTypDomain)  ||
-         (pSubEntry->m_Type == kEplObdTypOString))
-    {
-        if (pSubEntry->m_Type == kEplObdTypVString)
-        {
-            // reserve one byte for 0-termination
-            // -as ObdSize -= 1;
-            Size_p += 1;
-        }
-
-        // fill out new arg-struct
-        MemVStringDomain.m_DownloadSize = Size_p;
-        MemVStringDomain.m_ObjSize      = ObdSize;
-        MemVStringDomain.m_pData        = pDstData;
-
-        pCbParam_p->m_ObdEvent = kEplObdEvWrStringDomain;
-        pCbParam_p->m_pArg     = &MemVStringDomain;
-        //  call user callback
-        Ret = EplObdCallObjectCallback (EPL_MCO_INSTANCE_PTR_
-                pObdEntry->m_fpCallback, pCbParam_p);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        // write back new settings
-        pCurrData = pSubEntry->m_pCurrent;
-        if ((pSubEntry->m_Type == kEplObdTypVString)
-            ||(pSubEntry->m_Type ==  kEplObdTypOString))
-        {
-            ((tEplObdVString MEM*) pCurrData)->m_Size    = MemVStringDomain.m_ObjSize;
-            ((tEplObdVString MEM*) pCurrData)->m_pString = MemVStringDomain.m_pData;
-        }
-        else // if (pSdosTableEntry_p->m_bObjType == kEplObdTypDomain)
-        {
-            ((tEplObdVarEntry MEM*) pCurrData)->m_Size  = MemVStringDomain.m_ObjSize;
-            ((tEplObdVarEntry MEM*) pCurrData)->m_pData = (void MEM*) MemVStringDomain.m_pData;
-        }
-
-        // Because object size and object pointer are
-        // adapted by user callback function, re-read
-        // this values.
-        ObdSize  = MemVStringDomain.m_ObjSize;
-        pDstData = (void MEM*) MemVStringDomain.m_pData;
-    }
-    #endif //#if (OBD_USE_STRING_DOMAIN_IN_RAM != FALSE)
-
-    // 07-dec-2004 r.d.: size from application is needed because callback function can change the object size
-    // -as 16.11.04 CbParam.m_pArg     = &ObdSize;
-    // 09-dec-2004 r.d.: CbParam.m_pArg     = &Size_p;
-    pCbParam_p->m_pArg     = &ObdSize;
-    pCbParam_p->m_ObdEvent = kEplObdEvInitWrite;
-    Ret = EplObdCallObjectCallback (EPL_MCO_INSTANCE_PTR_
-        pObdEntry->m_fpCallback, pCbParam_p);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    if (Size_p > ObdSize)
-    {
-        Ret = kEplObdValueLengthError;
-        goto Exit;
-    }
-
-    if (pSubEntry->m_Type == kEplObdTypVString)
-    {
-        if (((char MEM*) pSrcData_p)[Size_p - 1] == '\0')
-        {   // last byte of source string contains null character
-
-            // reserve one byte in destination for 0-termination
-            Size_p  -= 1;
-        }
-        else if (Size_p >= ObdSize)
-        {   // source string is not 0-terminated
-            // and destination buffer is too short
-            Ret = kEplObdValueLengthError;
-            goto Exit;
-        }
-    }
-
-    Ret = EplObdIsNumericalIntern(pSubEntry, &fEntryNumerical);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    if ((fEntryNumerical != FALSE)
-        && (Size_p != ObdSize))
-    {
-        // type is numerical, therefor size has to fit, but it does not.
-        Ret = kEplObdValueLengthError;
-        goto Exit;
-    }
-
-    // use given size, because non-numerical objects can be written with shorter values
-    ObdSize = Size_p;
-
-    // set output parameters
-    *pObdSize_p = ObdSize;
-    *ppObdEntry_p = pObdEntry;
-    *ppSubEntry_p = pSubEntry;
-    *ppDstData_p = pDstData;
+	//------------------------------------------------------------------------
+	// get address of index and subindex entry
+	Ret = EplObdGetEntry(EPL_MCO_INSTANCE_PTR_
+			     uiIndex_p, uiSubIndex_p, &pObdEntry, &pSubEntry);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// get pointer to object data
+	pDstData = (void MEM *)EplObdGetObjectDataPtrIntern(pSubEntry);
+
+	Access = (tEplObdAccess) pSubEntry->m_Access;
+
+	// check access for write
+	// access violation if adress to current value is NULL
+	if (((Access & kEplObdAccConst) != 0) || (pDstData == NULL)) {
+		Ret = kEplObdAccessViolation;
+		goto Exit;
+	}
+	//------------------------------------------------------------------------
+	// get size of object
+	// -as ObdSize = ObdGetObjectSize (pSubEntry);
+
+	//------------------------------------------------------------------------
+	// To use the same callback function for ObdWriteEntry as well as for
+	// an SDO download call at first (kEplObdEvPre...) the callback function
+	// with the argument pointer to object size.
+	pCbParam_p->m_uiIndex = uiIndex_p;
+	pCbParam_p->m_uiSubIndex = uiSubIndex_p;
+
+	// Because object size and object pointer are
+	// adapted by user callback function, re-read
+	// this values.
+	ObdSize = EplObdGetObjectSize(pSubEntry);
+	pDstData = (void MEM *)EplObdGetObjectDataPtrIntern(pSubEntry);
+
+	// 09-dec-2004 r.d.:
+	//      Function EplObdWriteEntry() calls new event kEplObdEvWrStringDomain
+	//      for String or Domain which lets called module directly change
+	//      the data pointer or size. This prevents a recursive call to
+	//      the callback function if it calls EplObdGetEntry().
+#if (EPL_OBD_USE_STRING_DOMAIN_IN_RAM != FALSE)
+	if ((pSubEntry->m_Type == kEplObdTypVString) ||
+	    (pSubEntry->m_Type == kEplObdTypDomain) ||
+	    (pSubEntry->m_Type == kEplObdTypOString)) {
+		if (pSubEntry->m_Type == kEplObdTypVString) {
+			// reserve one byte for 0-termination
+			// -as ObdSize -= 1;
+			Size_p += 1;
+		}
+		// fill out new arg-struct
+		MemVStringDomain.m_DownloadSize = Size_p;
+		MemVStringDomain.m_ObjSize = ObdSize;
+		MemVStringDomain.m_pData = pDstData;
+
+		pCbParam_p->m_ObdEvent = kEplObdEvWrStringDomain;
+		pCbParam_p->m_pArg = &MemVStringDomain;
+		//  call user callback
+		Ret = EplObdCallObjectCallback(EPL_MCO_INSTANCE_PTR_
+					       pObdEntry->m_fpCallback,
+					       pCbParam_p);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		// write back new settings
+		pCurrData = pSubEntry->m_pCurrent;
+		if ((pSubEntry->m_Type == kEplObdTypVString)
+		    || (pSubEntry->m_Type == kEplObdTypOString)) {
+			((tEplObdVString MEM *) pCurrData)->m_Size =
+			    MemVStringDomain.m_ObjSize;
+			((tEplObdVString MEM *) pCurrData)->m_pString =
+			    MemVStringDomain.m_pData;
+		} else		// if (pSdosTableEntry_p->m_bObjType == kEplObdTypDomain)
+		{
+			((tEplObdVarEntry MEM *) pCurrData)->m_Size =
+			    MemVStringDomain.m_ObjSize;
+			((tEplObdVarEntry MEM *) pCurrData)->m_pData =
+			    (void MEM *)MemVStringDomain.m_pData;
+		}
+
+		// Because object size and object pointer are
+		// adapted by user callback function, re-read
+		// this values.
+		ObdSize = MemVStringDomain.m_ObjSize;
+		pDstData = (void MEM *)MemVStringDomain.m_pData;
+	}
+#endif //#if (OBD_USE_STRING_DOMAIN_IN_RAM != FALSE)
+
+	// 07-dec-2004 r.d.: size from application is needed because callback function can change the object size
+	// -as 16.11.04 CbParam.m_pArg     = &ObdSize;
+	// 09-dec-2004 r.d.: CbParam.m_pArg     = &Size_p;
+	pCbParam_p->m_pArg = &ObdSize;
+	pCbParam_p->m_ObdEvent = kEplObdEvInitWrite;
+	Ret = EplObdCallObjectCallback(EPL_MCO_INSTANCE_PTR_
+				       pObdEntry->m_fpCallback, pCbParam_p);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	if (Size_p > ObdSize) {
+		Ret = kEplObdValueLengthError;
+		goto Exit;
+	}
+
+	if (pSubEntry->m_Type == kEplObdTypVString) {
+		if (((char MEM *)pSrcData_p)[Size_p - 1] == '\0') {	// last byte of source string contains null character
+
+			// reserve one byte in destination for 0-termination
+			Size_p -= 1;
+		} else if (Size_p >= ObdSize) {	// source string is not 0-terminated
+			// and destination buffer is too short
+			Ret = kEplObdValueLengthError;
+			goto Exit;
+		}
+	}
+
+	Ret = EplObdIsNumericalIntern(pSubEntry, &fEntryNumerical);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+
+	if ((fEntryNumerical != FALSE)
+	    && (Size_p != ObdSize)) {
+		// type is numerical, therefor size has to fit, but it does not.
+		Ret = kEplObdValueLengthError;
+		goto Exit;
+	}
+	// use given size, because non-numerical objects can be written with shorter values
+	ObdSize = Size_p;
+
+	// set output parameters
+	*pObdSize_p = ObdSize;
+	*ppObdEntry_p = pObdEntry;
+	*ppSubEntry_p = pSubEntry;
+	*ppDstData_p = pDstData;
 
-    // all checks are done
-    // the caller may now convert the numerial source value to platform byte order in a temporary buffer
+	// all checks are done
+	// the caller may now convert the numerial source value to platform byte order in a temporary buffer
 
-Exit:
+      Exit:
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdWriteEntryPost()
@@ -2237,67 +2064,60 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC EplObdWriteEntryPost (EPL_MCO_DECL_INSTANCE_PTR_
-    tEplObdEntryPtr         pObdEntry_p,
-    tEplObdSubEntryPtr      pSubEntry_p,
-    tEplObdCbParam MEM*     pCbParam_p,
-    void * pSrcData_p,
-    void * pDstData_p,
-    tEplObdSize   ObdSize_p)
+static tEplKernel PUBLIC EplObdWriteEntryPost(EPL_MCO_DECL_INSTANCE_PTR_
+					      tEplObdEntryPtr pObdEntry_p,
+					      tEplObdSubEntryPtr pSubEntry_p,
+					      tEplObdCbParam MEM * pCbParam_p,
+					      void *pSrcData_p,
+					      void *pDstData_p,
+					      tEplObdSize ObdSize_p)
 {
 
-tEplKernel              Ret;
-
-
-    // caller converted the source value to platform byte order
-    // now the range of the value may be checked
-
-    #if (EPL_OBD_CHECK_OBJECT_RANGE != FALSE)
-    {
-        // check data range
-        Ret = EplObdCheckObjectRange (pSubEntry_p, pSrcData_p);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-    }
-    #endif
-
-    // now call user callback function to check value
-    // write address of source data to structure of callback parameters
-    // so callback function can check this data
-    pCbParam_p->m_pArg     = pSrcData_p;
-    pCbParam_p->m_ObdEvent = kEplObdEvPreWrite;
-    Ret = EplObdCallObjectCallback (EPL_MCO_INSTANCE_PTR_
-        pObdEntry_p->m_fpCallback, pCbParam_p);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	tEplKernel Ret;
 
-    // copy object data to OBD
-    EPL_MEMCPY (pDstData_p, pSrcData_p, ObdSize_p);
+	// caller converted the source value to platform byte order
+	// now the range of the value may be checked
 
-    // terminate string with 0
-    if (pSubEntry_p->m_Type == kEplObdTypVString)
-    {
-        ((char MEM*) pDstData_p)[ObdSize_p] = '\0';
-    }
+#if (EPL_OBD_CHECK_OBJECT_RANGE != FALSE)
+	{
+		// check data range
+		Ret = EplObdCheckObjectRange(pSubEntry_p, pSrcData_p);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+	}
+#endif
 
-    // write address of destination to structure of callback parameters
-    // so callback function can change data subsequently
-    pCbParam_p->m_pArg     = pDstData_p;
-    pCbParam_p->m_ObdEvent = kEplObdEvPostWrite;
-    Ret = EplObdCallObjectCallback (EPL_MCO_INSTANCE_PTR_
-        pObdEntry_p->m_fpCallback, pCbParam_p);
+	// now call user callback function to check value
+	// write address of source data to structure of callback parameters
+	// so callback function can check this data
+	pCbParam_p->m_pArg = pSrcData_p;
+	pCbParam_p->m_ObdEvent = kEplObdEvPreWrite;
+	Ret = EplObdCallObjectCallback(EPL_MCO_INSTANCE_PTR_
+				       pObdEntry_p->m_fpCallback, pCbParam_p);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	// copy object data to OBD
+	EPL_MEMCPY(pDstData_p, pSrcData_p, ObdSize_p);
+
+	// terminate string with 0
+	if (pSubEntry_p->m_Type == kEplObdTypVString) {
+		((char MEM *)pDstData_p)[ObdSize_p] = '\0';
+	}
+	// write address of destination to structure of callback parameters
+	// so callback function can change data subsequently
+	pCbParam_p->m_pArg = pDstData_p;
+	pCbParam_p->m_ObdEvent = kEplObdEvPostWrite;
+	Ret = EplObdCallObjectCallback(EPL_MCO_INSTANCE_PTR_
+				       pObdEntry_p->m_fpCallback, pCbParam_p);
 
-Exit:
+      Exit:
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdGetObjectSize()
@@ -2318,172 +2138,165 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplObdSize EplObdGetObjectSize (tEplObdSubEntryPtr pSubIndexEntry_p)
+static tEplObdSize EplObdGetObjectSize(tEplObdSubEntryPtr pSubIndexEntry_p)
 {
 
-tEplObdSize DataSize = 0;
-void * pData;
+	tEplObdSize DataSize = 0;
+	void *pData;
 
-    switch (pSubIndexEntry_p->m_Type)
-    {
-        // -----------------------------------------------------------------
-        case kEplObdTypBool:
+	switch (pSubIndexEntry_p->m_Type) {
+		// -----------------------------------------------------------------
+	case kEplObdTypBool:
+
+		DataSize = 1;
+		break;
+
+		// -----------------------------------------------------------------
+		// ObdTypes which has to be check because numerical values
+	case kEplObdTypInt8:
+		DataSize = sizeof(tEplObdInteger8);
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypUInt8:
+		DataSize = sizeof(tEplObdUnsigned8);
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypInt16:
+		DataSize = sizeof(tEplObdInteger16);
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypUInt16:
+		DataSize = sizeof(tEplObdUnsigned16);
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypInt32:
+		DataSize = sizeof(tEplObdInteger32);
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypUInt32:
+		DataSize = sizeof(tEplObdUnsigned32);
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypReal32:
+		DataSize = sizeof(tEplObdReal32);
+		break;
+
+		// -----------------------------------------------------------------
+		// ObdTypes which has to be not checked because not NUM values
+	case kEplObdTypDomain:
+
+		pData = (void *)pSubIndexEntry_p->m_pCurrent;
+		if ((void MEM *)pData != (void MEM *)NULL) {
+			DataSize = ((tEplObdVarEntry MEM *) pData)->m_Size;
+		}
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypVString:
+		//case kEplObdTypUString:
+
+		// If OD entry is defined by macro EPL_OBD_SUBINDEX_ROM_VSTRING
+		// then the current pointer is always NULL. The function
+		// returns the length of default string.
+		pData = (void *)pSubIndexEntry_p->m_pCurrent;
+		if ((void MEM *)pData != (void MEM *)NULL) {
+			// The max. size of strings defined by STRING-Macro is stored in
+			// tEplObdVString of current value.
+			// (types tEplObdVString, tEplObdOString and tEplObdUString has the same members)
+			DataSize = ((tEplObdVString MEM *) pData)->m_Size;
+		} else {
+			// The current position is not decleared. The string
+			// is located in ROM, therefor use default pointer.
+			pData = (void *)pSubIndexEntry_p->m_pDefault;
+			if ((CONST void ROM *)pData != (CONST void ROM *)NULL) {
+				// The max. size of strings defined by STRING-Macro is stored in
+				// tEplObdVString of default value.
+				DataSize =
+				    ((CONST tEplObdVString ROM *) pData)->
+				    m_Size;
+			}
+		}
+
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypOString:
+
+		pData = (void *)pSubIndexEntry_p->m_pCurrent;
+		if ((void MEM *)pData != (void MEM *)NULL) {
+			// The max. size of strings defined by STRING-Macro is stored in
+			// tEplObdVString of current value.
+			// (types tEplObdVString, tEplObdOString and tEplObdUString has the same members)
+			DataSize = ((tEplObdOString MEM *) pData)->m_Size;
+		} else {
+			// The current position is not decleared. The string
+			// is located in ROM, therefor use default pointer.
+			pData = (void *)pSubIndexEntry_p->m_pDefault;
+			if ((CONST void ROM *)pData != (CONST void ROM *)NULL) {
+				// The max. size of strings defined by STRING-Macro is stored in
+				// tEplObdVString of default value.
+				DataSize =
+				    ((CONST tEplObdOString ROM *) pData)->
+				    m_Size;
+			}
+		}
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypInt24:
+	case kEplObdTypUInt24:
+
+		DataSize = 3;
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypInt40:
+	case kEplObdTypUInt40:
+
+		DataSize = 5;
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypInt48:
+	case kEplObdTypUInt48:
+
+		DataSize = 6;
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypInt56:
+	case kEplObdTypUInt56:
+
+		DataSize = 7;
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypInt64:
+	case kEplObdTypUInt64:
+	case kEplObdTypReal64:
+
+		DataSize = 8;
+		break;
+
+		// -----------------------------------------------------------------
+	case kEplObdTypTimeOfDay:
+	case kEplObdTypTimeDiff:
+
+		DataSize = 6;
+		break;
+
+		// -----------------------------------------------------------------
+	default:
+		break;
+	}
 
-            DataSize = 1;
-            break;
-
-        // -----------------------------------------------------------------
-        // ObdTypes which has to be check because numerical values
-        case kEplObdTypInt8:
-            DataSize = sizeof (tEplObdInteger8);
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypUInt8:
-            DataSize = sizeof (tEplObdUnsigned8);
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypInt16:
-            DataSize = sizeof (tEplObdInteger16);
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypUInt16:
-            DataSize = sizeof (tEplObdUnsigned16);
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypInt32:
-            DataSize = sizeof (tEplObdInteger32);
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypUInt32:
-            DataSize = sizeof (tEplObdUnsigned32);
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypReal32:
-            DataSize = sizeof (tEplObdReal32);
-            break;
-
-        // -----------------------------------------------------------------
-        // ObdTypes which has to be not checked because not NUM values
-        case kEplObdTypDomain:
-
-            pData = (void *) pSubIndexEntry_p->m_pCurrent;
-            if ((void MEM*) pData != (void MEM*) NULL)
-            {
-                DataSize = ((tEplObdVarEntry MEM*) pData)->m_Size;
-            }
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypVString:
-        //case kEplObdTypUString:
-
-            // If OD entry is defined by macro EPL_OBD_SUBINDEX_ROM_VSTRING
-            // then the current pointer is always NULL. The function
-            // returns the length of default string.
-            pData = (void *) pSubIndexEntry_p->m_pCurrent;
-            if ((void MEM*) pData != (void MEM*) NULL)
-            {
-                // The max. size of strings defined by STRING-Macro is stored in
-                // tEplObdVString of current value.
-                // (types tEplObdVString, tEplObdOString and tEplObdUString has the same members)
-                DataSize = ((tEplObdVString MEM*) pData)->m_Size;
-            }
-            else
-            {
-                // The current position is not decleared. The string
-                // is located in ROM, therefor use default pointer.
-                pData = (void *) pSubIndexEntry_p->m_pDefault;
-                if ((CONST void ROM*) pData != (CONST void ROM*) NULL)
-                {
-                   // The max. size of strings defined by STRING-Macro is stored in
-                   // tEplObdVString of default value.
-                   DataSize = ((CONST tEplObdVString ROM*) pData)->m_Size;
-                }
-            }
-
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypOString:
-
-            pData = (void *) pSubIndexEntry_p->m_pCurrent;
-            if ((void MEM*) pData != (void MEM*) NULL)
-            {
-                // The max. size of strings defined by STRING-Macro is stored in
-                // tEplObdVString of current value.
-                // (types tEplObdVString, tEplObdOString and tEplObdUString has the same members)
-                DataSize = ((tEplObdOString MEM*) pData)->m_Size;
-            }
-            else
-            {
-                // The current position is not decleared. The string
-                // is located in ROM, therefor use default pointer.
-                pData = (void *) pSubIndexEntry_p->m_pDefault;
-                if ((CONST void ROM*) pData != (CONST void ROM*) NULL)
-                {
-                   // The max. size of strings defined by STRING-Macro is stored in
-                   // tEplObdVString of default value.
-                   DataSize = ((CONST tEplObdOString ROM*) pData)->m_Size;
-                }
-            }
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypInt24:
-        case kEplObdTypUInt24:
-
-            DataSize = 3;
-            break;
-
-
-        // -----------------------------------------------------------------
-        case kEplObdTypInt40:
-        case kEplObdTypUInt40:
-
-            DataSize = 5;
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypInt48:
-        case kEplObdTypUInt48:
-
-            DataSize = 6;
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypInt56:
-        case kEplObdTypUInt56:
-
-            DataSize = 7;
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypInt64:
-        case kEplObdTypUInt64:
-        case kEplObdTypReal64:
-
-            DataSize = 8;
-            break;
-
-        // -----------------------------------------------------------------
-        case kEplObdTypTimeOfDay:
-        case kEplObdTypTimeDiff:
-
-            DataSize = 6;
-            break;
-
-        // -----------------------------------------------------------------
-        default:
-            break;
-    }
-
-    return DataSize;
+	return DataSize;
 }
 
 //---------------------------------------------------------------------------
@@ -2500,45 +2313,43 @@ void * pData;
 //
 //---------------------------------------------------------------------------
 
-static void * EplObdGetObjectDefaultPtr (tEplObdSubEntryPtr pSubIndexEntry_p)
+static void *EplObdGetObjectDefaultPtr(tEplObdSubEntryPtr pSubIndexEntry_p)
 {
 
-void *   pDefault;
-tEplObdType     Type;
-
-    ASSERTMSG (pSubIndexEntry_p != NULL, "EplObdGetObjectDefaultPtr(): pointer to SubEntry not valid!\n");
+	void *pDefault;
+	tEplObdType Type;
 
-    // get address to default data from default pointer
-    pDefault = pSubIndexEntry_p->m_pDefault;
-    if (pDefault != NULL)
-    {
-        // there are some special types, whose default pointer always is NULL or has to get from other structure
-        // get type from subindex structure
-        Type = pSubIndexEntry_p->m_Type;
-
-        // check if object type is a string value
-        if ((Type == kEplObdTypVString) /* ||
-            (Type == kEplObdTypUString) */ )
-        {
+	ASSERTMSG(pSubIndexEntry_p != NULL,
+		  "EplObdGetObjectDefaultPtr(): pointer to SubEntry not valid!\n");
 
-            // EPL_OBD_SUBINDEX_RAM_VSTRING
-            //    tEplObdSize         m_Size;       --> size of default string
-            //    char *    m_pDefString; --> pointer to  default string
-            //    char *    m_pString;    --> pointer to string in RAM
-            //
-            pDefault = (void *) ((tEplObdVString *) pDefault)->m_pString;
-        }
-        else if(Type == kEplObdTypOString)
-        {
-             pDefault = (void *) ((tEplObdOString *) pDefault)->m_pString;
-        }
-    }
+	// get address to default data from default pointer
+	pDefault = pSubIndexEntry_p->m_pDefault;
+	if (pDefault != NULL) {
+		// there are some special types, whose default pointer always is NULL or has to get from other structure
+		// get type from subindex structure
+		Type = pSubIndexEntry_p->m_Type;
+
+		// check if object type is a string value
+		if ((Type == kEplObdTypVString)	/* ||
+						   (Type == kEplObdTypUString) */ ) {
+
+			// EPL_OBD_SUBINDEX_RAM_VSTRING
+			//    tEplObdSize         m_Size;       --> size of default string
+			//    char *    m_pDefString; --> pointer to  default string
+			//    char *    m_pString;    --> pointer to string in RAM
+			//
+			pDefault =
+			    (void *)((tEplObdVString *) pDefault)->m_pString;
+		} else if (Type == kEplObdTypOString) {
+			pDefault =
+			    (void *)((tEplObdOString *) pDefault)->m_pString;
+		}
+	}
 
-    return pDefault;
+	return pDefault;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdGetVarEntry()
@@ -2554,33 +2365,32 @@ tEplObdType     Type;
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplObdGetVarEntry (
-    tEplObdSubEntryPtr    pSubindexEntry_p,
-    tEplObdVarEntry MEM** ppVarEntry_p)
+static tEplKernel EplObdGetVarEntry(tEplObdSubEntryPtr pSubindexEntry_p,
+				    tEplObdVarEntry MEM ** ppVarEntry_p)
 {
 
-tEplKernel Ret = kEplObdVarEntryNotExist;
+	tEplKernel Ret = kEplObdVarEntryNotExist;
 
-    ASSERT (ppVarEntry_p != NULL);   // is not allowed to be NULL
-    ASSERT (pSubindexEntry_p != NULL);
+	ASSERT(ppVarEntry_p != NULL);	// is not allowed to be NULL
+	ASSERT(pSubindexEntry_p != NULL);
 
-    // check VAR-Flag - only this object points to variables
-    if ((pSubindexEntry_p->m_Access & kEplObdAccVar) != 0)
-    {
-        // check if object is an array
-        if ((pSubindexEntry_p->m_Access & kEplObdAccArray) != 0)
-        {
-            *ppVarEntry_p = &((tEplObdVarEntry MEM*) pSubindexEntry_p->m_pCurrent)[pSubindexEntry_p->m_uiSubIndex - 1];
-        }
-        else
-        {
-            *ppVarEntry_p = (tEplObdVarEntry MEM*) pSubindexEntry_p->m_pCurrent;
-        }
+	// check VAR-Flag - only this object points to variables
+	if ((pSubindexEntry_p->m_Access & kEplObdAccVar) != 0) {
+		// check if object is an array
+		if ((pSubindexEntry_p->m_Access & kEplObdAccArray) != 0) {
+			*ppVarEntry_p =
+			    &((tEplObdVarEntry MEM *) pSubindexEntry_p->
+			      m_pCurrent)[pSubindexEntry_p->m_uiSubIndex - 1];
+		} else {
+			*ppVarEntry_p =
+			    (tEplObdVarEntry MEM *) pSubindexEntry_p->
+			    m_pCurrent;
+		}
 
-        Ret = kEplSuccessful;
-    }
+		Ret = kEplSuccessful;
+	}
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -2602,64 +2412,60 @@ tEplKernel Ret = kEplObdVarEntryNotExist
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel  EplObdGetEntry (EPL_MCO_DECL_INSTANCE_PTR_
-    unsigned int             uiIndex_p,
-    unsigned int             uiSubindex_p,
-    tEplObdEntryPtr*         ppObdEntry_p,
-    tEplObdSubEntryPtr*      ppObdSubEntry_p)
-{
-
-tEplObdEntryPtr         pObdEntry;
-tEplObdCbParam MEM      CbParam;
-tEplKernel              Ret;
-
-    // check for all API function if instance is valid
-    EPL_MCO_CHECK_INSTANCE_STATE ();
-
-    //------------------------------------------------------------------------
-    // get address of entry of index
-    Ret = EplObdGetIndexIntern (&EPL_MCO_GLB_VAR (m_ObdInitParam), uiIndex_p, &pObdEntry);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    //------------------------------------------------------------------------
-    // get address of entry of subindex
-    Ret = EplObdGetSubindexIntern (pObdEntry, uiSubindex_p, ppObdSubEntry_p);
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
-    //------------------------------------------------------------------------
-    // call callback function to inform user/stack that an object will be searched
-    // if the called module returnes an error then we abort the searching with kEplObdIndexNotExist
-    CbParam.m_uiIndex    = uiIndex_p;
-    CbParam.m_uiSubIndex = uiSubindex_p;
-    CbParam.m_pArg       = NULL;
-    CbParam.m_ObdEvent   = kEplObdEvCheckExist;
-    Ret = EplObdCallObjectCallback (EPL_MCO_INSTANCE_PTR_
-        pObdEntry->m_fpCallback, &CbParam);
-    if (Ret != kEplSuccessful)
-    {
-        Ret = kEplObdIndexNotExist;
-        goto Exit;
-    }
-
-    //------------------------------------------------------------------------
-    // it is allowed to set ppObdEntry_p to NULL
-    // if so, no address will be written to calling function
-    if (ppObdEntry_p != NULL)
-    {
-        *ppObdEntry_p = pObdEntry;
-    }
+static tEplKernel EplObdGetEntry(EPL_MCO_DECL_INSTANCE_PTR_
+				 unsigned int uiIndex_p,
+				 unsigned int uiSubindex_p,
+				 tEplObdEntryPtr * ppObdEntry_p,
+				 tEplObdSubEntryPtr * ppObdSubEntry_p)
+{
+
+	tEplObdEntryPtr pObdEntry;
+	tEplObdCbParam MEM CbParam;
+	tEplKernel Ret;
+
+	// check for all API function if instance is valid
+	EPL_MCO_CHECK_INSTANCE_STATE();
+
+	//------------------------------------------------------------------------
+	// get address of entry of index
+	Ret =
+	    EplObdGetIndexIntern(&EPL_MCO_GLB_VAR(m_ObdInitParam), uiIndex_p,
+				 &pObdEntry);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	//------------------------------------------------------------------------
+	// get address of entry of subindex
+	Ret = EplObdGetSubindexIntern(pObdEntry, uiSubindex_p, ppObdSubEntry_p);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
+	//------------------------------------------------------------------------
+	// call callback function to inform user/stack that an object will be searched
+	// if the called module returnes an error then we abort the searching with kEplObdIndexNotExist
+	CbParam.m_uiIndex = uiIndex_p;
+	CbParam.m_uiSubIndex = uiSubindex_p;
+	CbParam.m_pArg = NULL;
+	CbParam.m_ObdEvent = kEplObdEvCheckExist;
+	Ret = EplObdCallObjectCallback(EPL_MCO_INSTANCE_PTR_
+				       pObdEntry->m_fpCallback, &CbParam);
+	if (Ret != kEplSuccessful) {
+		Ret = kEplObdIndexNotExist;
+		goto Exit;
+	}
+	//------------------------------------------------------------------------
+	// it is allowed to set ppObdEntry_p to NULL
+	// if so, no address will be written to calling function
+	if (ppObdEntry_p != NULL) {
+		*ppObdEntry_p = pObdEntry;
+	}
 
-Exit:
+      Exit:
 
-    return Ret;
+	return Ret;
 
 }
+
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdGetObjectCurrentPtr()
@@ -2674,58 +2480,51 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static void MEM* EplObdGetObjectCurrentPtr (tEplObdSubEntryPtr pSubIndexEntry_p)
+static void MEM *EplObdGetObjectCurrentPtr(tEplObdSubEntryPtr pSubIndexEntry_p)
 {
 
-void MEM*       pData;
-unsigned int    uiArrayIndex;
-tEplObdSize     Size;
-
-    pData = pSubIndexEntry_p->m_pCurrent;
-
-    // check if constant object
-    if (pData != NULL)
-    {
-        // check if object is an array
-        if ((pSubIndexEntry_p->m_Access & kEplObdAccArray) != 0)
-        {
-            // calculate correct data pointer
-            uiArrayIndex = pSubIndexEntry_p->m_uiSubIndex - 1;
-            if ((pSubIndexEntry_p->m_Access & kEplObdAccVar) != 0)
-            {
-                Size = sizeof (tEplObdVarEntry);
-            }
-            else
-            {
-                Size = EplObdGetObjectSize (pSubIndexEntry_p);
-            }
-            pData = ((BYTE MEM*) pData) + (Size * uiArrayIndex);
-        }
-
-        // check if VarEntry
-        if ((pSubIndexEntry_p->m_Access & kEplObdAccVar) != 0)
-        {
-            // The data pointer is stored in VarEntry->pData
-            pData = ((tEplObdVarEntry MEM*) pData)->m_pData;
-        }
-
-        // the default pointer is stored for strings in tEplObdVString
-        else if ((pSubIndexEntry_p->m_Type == kEplObdTypVString) /* ||
-            (pSubIndexEntry_p->m_Type == kEplObdTypUString)    */ )
-        {
-            pData = (void MEM*) ((tEplObdVString MEM*) pData)->m_pString;
-        }
-        else if (pSubIndexEntry_p->m_Type == kEplObdTypOString)
-        {
-            pData = (void MEM*) ((tEplObdOString MEM*) pData)->m_pString;
-        }
-    }
+	void MEM *pData;
+	unsigned int uiArrayIndex;
+	tEplObdSize Size;
+
+	pData = pSubIndexEntry_p->m_pCurrent;
+
+	// check if constant object
+	if (pData != NULL) {
+		// check if object is an array
+		if ((pSubIndexEntry_p->m_Access & kEplObdAccArray) != 0) {
+			// calculate correct data pointer
+			uiArrayIndex = pSubIndexEntry_p->m_uiSubIndex - 1;
+			if ((pSubIndexEntry_p->m_Access & kEplObdAccVar) != 0) {
+				Size = sizeof(tEplObdVarEntry);
+			} else {
+				Size = EplObdGetObjectSize(pSubIndexEntry_p);
+			}
+			pData = ((BYTE MEM *) pData) + (Size * uiArrayIndex);
+		}
+		// check if VarEntry
+		if ((pSubIndexEntry_p->m_Access & kEplObdAccVar) != 0) {
+			// The data pointer is stored in VarEntry->pData
+			pData = ((tEplObdVarEntry MEM *) pData)->m_pData;
+		}
+		// the default pointer is stored for strings in tEplObdVString
+		else if ((pSubIndexEntry_p->m_Type == kEplObdTypVString)	/* ||
+										   (pSubIndexEntry_p->m_Type == kEplObdTypUString)    */
+			 ) {
+			pData =
+			    (void MEM *)((tEplObdVString MEM *) pData)->
+			    m_pString;
+		} else if (pSubIndexEntry_p->m_Type == kEplObdTypOString) {
+			pData =
+			    (void MEM *)((tEplObdOString MEM *) pData)->
+			    m_pString;
+		}
+	}
 
-    return pData;
+	return pData;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdGetIndexIntern()
@@ -2742,142 +2541,127 @@ tEplObdSize     Size;
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplObdGetIndexIntern (
-                        tEplObdInitParam MEM*    pInitParam_p,
-                        unsigned int             uiIndex_p,
-                        tEplObdEntryPtr*         ppObdEntry_p)
+static tEplKernel EplObdGetIndexIntern(tEplObdInitParam MEM * pInitParam_p,
+				       unsigned int uiIndex_p,
+				       tEplObdEntryPtr * ppObdEntry_p)
 {
 
-tEplObdEntryPtr pObdEntry;
-tEplKernel      Ret;
-unsigned int    uiIndex;
+	tEplObdEntryPtr pObdEntry;
+	tEplKernel Ret;
+	unsigned int uiIndex;
 
 #if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
 
-unsigned int  nLoop;
+	unsigned int nLoop;
 
-    // if user OD is used then objekts also has to be searched in user OD
-    // there is less code need if we do this in a loop
-    nLoop = 2;
+	// if user OD is used then objekts also has to be searched in user OD
+	// there is less code need if we do this in a loop
+	nLoop = 2;
 
 #endif
 
-    ASSERTMSG (ppObdEntry_p != NULL, "EplObdGetIndexIntern(): pointer to index entry is NULL!\n");
+	ASSERTMSG(ppObdEntry_p != NULL,
+		  "EplObdGetIndexIntern(): pointer to index entry is NULL!\n");
 
-    Ret = kEplObdIndexNotExist;
+	Ret = kEplObdIndexNotExist;
 
-    // get start address of OD part
-    // start address depends on object index because
-    // object dictionary is divided in 3 parts
-    if ((uiIndex_p >= 0x1000) && (uiIndex_p < 0x2000))
-    {
-        pObdEntry = pInitParam_p->m_pPart;
-    }
-    else if ((uiIndex_p >= 0x2000) && (uiIndex_p < 0x6000))
-    {
-        pObdEntry = pInitParam_p->m_pManufacturerPart;
-    }
-
-    // index range 0xA000 to 0xFFFF is reserved for DSP-405
-    // DS-301 defines that range 0x6000 to 0x9FFF (!!!) is stored if "store" was written to 0x1010/3.
-    // Therefore default configuration is OBD_INCLUDE_A000_TO_DEVICE_PART = FALSE.
-    // But a CANopen Application which does not implement dynamic OD or user-OD but wants to use static objets 0xA000...
-    // should set OBD_INCLUDE_A000_TO_DEVICE_PART to TRUE.
+	// get start address of OD part
+	// start address depends on object index because
+	// object dictionary is divided in 3 parts
+	if ((uiIndex_p >= 0x1000) && (uiIndex_p < 0x2000)) {
+		pObdEntry = pInitParam_p->m_pPart;
+	} else if ((uiIndex_p >= 0x2000) && (uiIndex_p < 0x6000)) {
+		pObdEntry = pInitParam_p->m_pManufacturerPart;
+	}
+	// index range 0xA000 to 0xFFFF is reserved for DSP-405
+	// DS-301 defines that range 0x6000 to 0x9FFF (!!!) is stored if "store" was written to 0x1010/3.
+	// Therefore default configuration is OBD_INCLUDE_A000_TO_DEVICE_PART = FALSE.
+	// But a CANopen Application which does not implement dynamic OD or user-OD but wants to use static objets 0xA000...
+	// should set OBD_INCLUDE_A000_TO_DEVICE_PART to TRUE.
 
 #if (EPL_OBD_INCLUDE_A000_TO_DEVICE_PART == FALSE)
-    else if ((uiIndex_p >= 0x6000) && (uiIndex_p < 0x9FFF))
+	else if ((uiIndex_p >= 0x6000) && (uiIndex_p < 0x9FFF))
 #else
-    else if ((uiIndex_p >= 0x6000) && (uiIndex_p < 0xFFFF))
+	else if ((uiIndex_p >= 0x6000) && (uiIndex_p < 0xFFFF))
 #endif
-    {
-        pObdEntry = pInitParam_p->m_pDevicePart;
-    }
-
+	{
+		pObdEntry = pInitParam_p->m_pDevicePart;
+	}
 
 #if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
 
-    // if index does not match in static OD then index only has to be searched in user OD
-    else
-    {
-        // begin from first entry of user OD part
-        pObdEntry = pInitParam_p->m_pUserPart;
+	// if index does not match in static OD then index only has to be searched in user OD
+	else {
+		// begin from first entry of user OD part
+		pObdEntry = pInitParam_p->m_pUserPart;
+
+		// no user OD is available
+		if (pObdEntry == NULL) {
+			goto Exit;
+		}
+		// loop must only run once
+		nLoop = 1;
+	}
 
-        // no user OD is available
-        if (pObdEntry == NULL)
-        {
-            goto Exit;
-        }
-
-        // loop must only run once
-        nLoop = 1;
-    }
-
-    do
-    {
+	do {
 
 #else
 
-        // no user OD is available
-        // so other object can be found in OD
-        else
-        {
-            Ret = kEplObdIllegalPart;
-            goto Exit;
-        }
+	// no user OD is available
+	// so other object can be found in OD
+	else {
+		Ret = kEplObdIllegalPart;
+		goto Exit;
+	}
 
 #endif
 
-        // note:
-        // The end of Index table is marked with m_uiIndex = 0xFFFF.
-        // If this function will be called with wIndex_p = 0xFFFF, entry
-        // should not be found. Therefor it is important to use
-        // while{} instead of do{}while !!!
-
-        // get first index of index table
-        uiIndex = pObdEntry->m_uiIndex;
-
-        // search Index in OD part
-        while (uiIndex != EPL_OBD_TABLE_INDEX_END)
-        {
-            // go to the end of this function if index is found
-            if (uiIndex_p == uiIndex)
-            {
-                // write address of OD entry to calling function
-                *ppObdEntry_p = pObdEntry;
-                Ret = kEplSuccessful;
-                goto Exit;
-            }
-
-            // objects are sorted in OD
-            // if the current index in OD is greater than the index which is to search then break loop
-            // in this case user OD has to be search too
-            if (uiIndex_p < uiIndex)
-            {
-                break;
-            }
-
-            // next entry in index table
-            pObdEntry++;
-
-            // get next index of index table
-            uiIndex = pObdEntry->m_uiIndex;
-        }
+	// note:
+	// The end of Index table is marked with m_uiIndex = 0xFFFF.
+	// If this function will be called with wIndex_p = 0xFFFF, entry
+	// should not be found. Therefor it is important to use
+	// while{} instead of do{}while !!!
+
+	// get first index of index table
+	uiIndex = pObdEntry->m_uiIndex;
+
+	// search Index in OD part
+	while (uiIndex != EPL_OBD_TABLE_INDEX_END) {
+		// go to the end of this function if index is found
+		if (uiIndex_p == uiIndex) {
+			// write address of OD entry to calling function
+			*ppObdEntry_p = pObdEntry;
+			Ret = kEplSuccessful;
+			goto Exit;
+		}
+		// objects are sorted in OD
+		// if the current index in OD is greater than the index which is to search then break loop
+		// in this case user OD has to be search too
+		if (uiIndex_p < uiIndex) {
+			break;
+		}
+		// next entry in index table
+		pObdEntry++;
+
+		// get next index of index table
+		uiIndex = pObdEntry->m_uiIndex;
+	}
 
 #if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
 
-        // begin from first entry of user OD part
-        pObdEntry = pInitParam_p->m_pUserPart;
+	// begin from first entry of user OD part
+	pObdEntry = pInitParam_p->m_pUserPart;
 
-        // no user OD is available
-        if (pObdEntry == NULL)
-        {
-            goto Exit;
-        }
+	// no user OD is available
+	if (pObdEntry == NULL) {
+		goto Exit;
+	}
+	// switch next loop for user OD
+	nLoop--;
 
-        // switch next loop for user OD
-        nLoop--;
+}
 
-    } while (nLoop > 0);
+while (nLoop > 0) ;
 
 #endif
 
@@ -2885,11 +2669,10 @@ unsigned int  nLoop;
 
 Exit:
 
-    return Ret;
+return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdGetSubindexIntern()
@@ -2906,73 +2689,65 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplObdGetSubindexIntern (
-    tEplObdEntryPtr           pObdEntry_p,
-    unsigned int              uiSubIndex_p,
-    tEplObdSubEntryPtr*       ppObdSubEntry_p)
-{
-
-tEplObdSubEntryPtr pSubEntry;
-unsigned int       nSubIndexCount;
-tEplKernel         Ret;
+static tEplKernel EplObdGetSubindexIntern(tEplObdEntryPtr pObdEntry_p,
+					  unsigned int uiSubIndex_p,
+					  tEplObdSubEntryPtr * ppObdSubEntry_p)
+{
+
+	tEplObdSubEntryPtr pSubEntry;
+	unsigned int nSubIndexCount;
+	tEplKernel Ret;
+
+	ASSERTMSG(pObdEntry_p != NULL,
+		  "EplObdGetSubindexIntern(): pointer to index is NULL!\n");
+	ASSERTMSG(ppObdSubEntry_p != NULL,
+		  "EplObdGetSubindexIntern(): pointer to subindex is NULL!\n");
+
+	Ret = kEplObdSubindexNotExist;
+
+	// get start address of subindex table and count of subindices
+	pSubEntry = pObdEntry_p->m_pSubIndex;
+	nSubIndexCount = pObdEntry_p->m_uiCount;
+	ASSERTMSG((pSubEntry != NULL) && (nSubIndexCount > 0), "ObdGetSubindexIntern(): invalid subindex table within index table!\n");	// should never be NULL
+
+	// search subindex in subindex table
+	while (nSubIndexCount > 0) {
+		// check if array is found
+		if ((pSubEntry->m_Access & kEplObdAccArray) != 0) {
+			// check if subindex is in range
+			if (uiSubIndex_p < pObdEntry_p->m_uiCount) {
+				// update subindex number (subindex entry of an array is always in RAM !!!)
+				pSubEntry->m_uiSubIndex = uiSubIndex_p;
+				*ppObdSubEntry_p = pSubEntry;
+				Ret = kEplSuccessful;
+				goto Exit;
+			}
+		}
+		// go to the end of this function if subindex is found
+		else if (uiSubIndex_p == pSubEntry->m_uiSubIndex) {
+			*ppObdSubEntry_p = pSubEntry;
+			Ret = kEplSuccessful;
+			goto Exit;
+		}
+		// objects are sorted in OD
+		// if the current subindex in OD is greater than the subindex which is to search then break loop
+		// in this case user OD has to be search too
+		if (uiSubIndex_p < pSubEntry->m_uiSubIndex) {
+			break;
+		}
+
+		pSubEntry++;
+		nSubIndexCount--;
+	}
 
-    ASSERTMSG (pObdEntry_p != NULL, "EplObdGetSubindexIntern(): pointer to index is NULL!\n");
-    ASSERTMSG (ppObdSubEntry_p != NULL, "EplObdGetSubindexIntern(): pointer to subindex is NULL!\n");
+	// in this line SubIndex was not fount
 
-    Ret = kEplObdSubindexNotExist;
+      Exit:
 
-    // get start address of subindex table and count of subindices
-    pSubEntry     = pObdEntry_p->m_pSubIndex;
-    nSubIndexCount =  pObdEntry_p->m_uiCount;
-    ASSERTMSG ((pSubEntry != NULL) && (nSubIndexCount > 0),
-        "ObdGetSubindexIntern(): invalid subindex table within index table!\n");   // should never be NULL
-
-    // search subindex in subindex table
-    while (nSubIndexCount > 0)
-    {
-        // check if array is found
-        if ((pSubEntry->m_Access & kEplObdAccArray) != 0)
-        {
-            // check if subindex is in range
-            if (uiSubIndex_p < pObdEntry_p->m_uiCount)
-            {
-                // update subindex number (subindex entry of an array is always in RAM !!!)
-                pSubEntry->m_uiSubIndex = uiSubIndex_p;
-                *ppObdSubEntry_p = pSubEntry;
-                Ret = kEplSuccessful;
-                goto Exit;
-            }
-        }
-
-        // go to the end of this function if subindex is found
-        else if (uiSubIndex_p == pSubEntry->m_uiSubIndex)
-        {
-            *ppObdSubEntry_p = pSubEntry;
-            Ret = kEplSuccessful;
-            goto Exit;
-        }
-
-        // objects are sorted in OD
-        // if the current subindex in OD is greater than the subindex which is to search then break loop
-        // in this case user OD has to be search too
-        if (uiSubIndex_p < pSubEntry->m_uiSubIndex)
-        {
-            break;
-        }
-
-        pSubEntry++;
-        nSubIndexCount--;
-    }
-
-    // in this line SubIndex was not fount
-
-Exit:
-
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdSetStoreLoadObjCallback()
@@ -2987,21 +2762,21 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if (EPL_OBD_USE_STORE_RESTORE != FALSE)
-EPLDLLEXPORT tEplKernel PUBLIC EplObdSetStoreLoadObjCallback (EPL_MCO_DECL_INSTANCE_PTR_
-    tEplObdStoreLoadObjCallback fpCallback_p)
+EPLDLLEXPORT tEplKernel PUBLIC
+EplObdSetStoreLoadObjCallback(EPL_MCO_DECL_INSTANCE_PTR_
+			      tEplObdStoreLoadObjCallback fpCallback_p)
 {
 
-    EPL_MCO_CHECK_INSTANCE_STATE ();
+	EPL_MCO_CHECK_INSTANCE_STATE();
 
-    // set new address of callback function
-    EPL_MCO_GLB_VAR (m_fpStoreLoadObjCallback) = fpCallback_p;
+	// set new address of callback function
+	EPL_MCO_GLB_VAR(m_fpStoreLoadObjCallback) = fpCallback_p;
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 
 }
 #endif // (EPL_OBD_USE_STORE_RESTORE != FALSE)
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdAccessOdPartIntern()
@@ -3018,106 +2793,96 @@ EPLDLLEXPORT tEplKernel PUBLIC EplObdSet
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplObdAccessOdPartIntern (EPL_MCO_DECL_INSTANCE_PTR_
-    tEplObdPart     CurrentOdPart_p,
-    tEplObdEntryPtr pObdEnty_p,
-    tEplObdDir      Direction_p)
-{
-
-tEplObdSubEntryPtr          pSubIndex;
-unsigned int                nSubIndexCount;
-tEplObdAccess               Access;
-void MEM*                   pDstData;
-void *               pDefault;
-tEplObdSize                 ObjSize;
-tEplKernel                  Ret;
-tEplObdCbStoreParam MEM     CbStore;
-tEplObdVarEntry MEM*        pVarEntry;
-
-    ASSERT (pObdEnty_p != NULL);
-
-    Ret = kEplSuccessful;
-
-    // prepare structure for STORE RESTORE callback function
-    CbStore.m_bCurrentOdPart = (BYTE) CurrentOdPart_p;
-    CbStore.m_pData          = NULL;
-    CbStore.m_ObjSize        = 0;
-
-    // command of first action depends on direction to access
-    #if (EPL_OBD_USE_STORE_RESTORE != FALSE)
-    if (Direction_p == kEplObdDirLoad)
-    {
-        CbStore.m_bCommand = (BYTE) kEplObdCommOpenRead;
-
-        // call callback function for previous command
-        Ret = EplObdCallStoreCallback (EPL_MCO_INSTANCE_PTR_
-            &CbStore);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
-
-        // set command for index and subindex loop
-        CbStore.m_bCommand = (BYTE) kEplObdCommReadObj;
-    }
-    else if (Direction_p == kEplObdDirStore)
-    {
-        CbStore.m_bCommand = (BYTE) kEplObdCommOpenWrite;
+static tEplKernel EplObdAccessOdPartIntern(EPL_MCO_DECL_INSTANCE_PTR_
+					   tEplObdPart CurrentOdPart_p,
+					   tEplObdEntryPtr pObdEnty_p,
+					   tEplObdDir Direction_p)
+{
+
+	tEplObdSubEntryPtr pSubIndex;
+	unsigned int nSubIndexCount;
+	tEplObdAccess Access;
+	void MEM *pDstData;
+	void *pDefault;
+	tEplObdSize ObjSize;
+	tEplKernel Ret;
+	tEplObdCbStoreParam MEM CbStore;
+	tEplObdVarEntry MEM *pVarEntry;
+
+	ASSERT(pObdEnty_p != NULL);
+
+	Ret = kEplSuccessful;
+
+	// prepare structure for STORE RESTORE callback function
+	CbStore.m_bCurrentOdPart = (BYTE) CurrentOdPart_p;
+	CbStore.m_pData = NULL;
+	CbStore.m_ObjSize = 0;
 
-        // call callback function for previous command
-        Ret = EplObdCallStoreCallback (EPL_MCO_INSTANCE_PTR_
-            &CbStore);
-        if (Ret != kEplSuccessful)
-        {
-            goto Exit;
-        }
+	// command of first action depends on direction to access
+#if (EPL_OBD_USE_STORE_RESTORE != FALSE)
+	if (Direction_p == kEplObdDirLoad) {
+		CbStore.m_bCommand = (BYTE) kEplObdCommOpenRead;
 
-        // set command for index and subindex loop
-        CbStore.m_bCommand = (BYTE) kEplObdCommWriteObj;
-    }
-    #endif // (EPL_OBD_USE_STORE_RESTORE != FALSE)
+		// call callback function for previous command
+		Ret = EplObdCallStoreCallback(EPL_MCO_INSTANCE_PTR_ & CbStore);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		// set command for index and subindex loop
+		CbStore.m_bCommand = (BYTE) kEplObdCommReadObj;
+	} else if (Direction_p == kEplObdDirStore) {
+		CbStore.m_bCommand = (BYTE) kEplObdCommOpenWrite;
+
+		// call callback function for previous command
+		Ret = EplObdCallStoreCallback(EPL_MCO_INSTANCE_PTR_ & CbStore);
+		if (Ret != kEplSuccessful) {
+			goto Exit;
+		}
+		// set command for index and subindex loop
+		CbStore.m_bCommand = (BYTE) kEplObdCommWriteObj;
+	}
+#endif // (EPL_OBD_USE_STORE_RESTORE != FALSE)
 
-    // we should not restore the OD values here
-    // the next NMT command "Reset Node" or "Reset Communication" resets the OD data
-    if (Direction_p != kEplObdDirRestore)
-    {
-        // walk through OD part till end is found
-        while (pObdEnty_p->m_uiIndex != EPL_OBD_TABLE_INDEX_END)
-        {
-            // get address to subindex table and count of subindices
-            pSubIndex     = pObdEnty_p->m_pSubIndex;
-            nSubIndexCount = pObdEnty_p->m_uiCount;
-            ASSERT ((pSubIndex != NULL) && (nSubIndexCount > 0));    // should never be NULL
-
-            // walk through subindex table till all subinices were restored
-            while (nSubIndexCount != 0)
-            {
-                Access = (tEplObdAccess) pSubIndex->m_Access;
-
-                // get pointer to current and default data
-                pDefault = EplObdGetObjectDefaultPtr (pSubIndex);
-                pDstData = EplObdGetObjectCurrentPtr (pSubIndex);
-
-                // NOTE (for kEplObdTypVString):
-                //      The function returnes the max. number of bytes for a
-                //      current string.
-                //      r.d.: For stings the default-size will be read in other lines following (kEplObdDirInit).
-                ObjSize  = EplObdGetObjectSize (pSubIndex);
-
-                // switch direction of OD access
-                switch (Direction_p)
-                {
-                    // --------------------------------------------------------------------------
-                    // VarEntry structures has to be initialized
-                    case kEplObdDirInit:
-
-                        // If VAR-Flag is set, m_pCurrent means not address of data
-                        // but address of tEplObdVarEntry. Address of data has to be get from
-                        // this structure.
-                        if ((Access & kEplObdAccVar) != 0)
-                        {
-                            EplObdGetVarEntry (pSubIndex, &pVarEntry);
-                            EplObdInitVarEntry (pVarEntry, pSubIndex->m_Type, ObjSize);
+	// we should not restore the OD values here
+	// the next NMT command "Reset Node" or "Reset Communication" resets the OD data
+	if (Direction_p != kEplObdDirRestore) {
+		// walk through OD part till end is found
+		while (pObdEnty_p->m_uiIndex != EPL_OBD_TABLE_INDEX_END) {
+			// get address to subindex table and count of subindices
+			pSubIndex = pObdEnty_p->m_pSubIndex;
+			nSubIndexCount = pObdEnty_p->m_uiCount;
+			ASSERT((pSubIndex != NULL) && (nSubIndexCount > 0));	// should never be NULL
+
+			// walk through subindex table till all subinices were restored
+			while (nSubIndexCount != 0) {
+				Access = (tEplObdAccess) pSubIndex->m_Access;
+
+				// get pointer to current and default data
+				pDefault = EplObdGetObjectDefaultPtr(pSubIndex);
+				pDstData = EplObdGetObjectCurrentPtr(pSubIndex);
+
+				// NOTE (for kEplObdTypVString):
+				//      The function returnes the max. number of bytes for a
+				//      current string.
+				//      r.d.: For stings the default-size will be read in other lines following (kEplObdDirInit).
+				ObjSize = EplObdGetObjectSize(pSubIndex);
+
+				// switch direction of OD access
+				switch (Direction_p) {
+					// --------------------------------------------------------------------------
+					// VarEntry structures has to be initialized
+				case kEplObdDirInit:
+
+					// If VAR-Flag is set, m_pCurrent means not address of data
+					// but address of tEplObdVarEntry. Address of data has to be get from
+					// this structure.
+					if ((Access & kEplObdAccVar) != 0) {
+						EplObdGetVarEntry(pSubIndex,
+								  &pVarEntry);
+						EplObdInitVarEntry(pVarEntry,
+								   pSubIndex->
+								   m_Type,
+								   ObjSize);
 /*
                             if ((Access & kEplObdAccArray) == 0)
                             {
@@ -3129,197 +2894,203 @@ tEplObdVarEntry MEM*        pVarEntry;
                                     pSubIndex->m_Type, ObjSize);
                             }
 */
-                            // at this time no application variable is defined !!!
-                            // therefore data can not be copied.
-                            break;
-                        }
-                        else if (pSubIndex->m_Type == kEplObdTypVString)
-                        {
-                            // If pointer m_pCurrent is not equal to NULL then the
-                            // string was defined with EPL_OBD_SUBINDEX_RAM_VSTRING. The current
-                            // pointer points to struct tEplObdVString located in MEM.
-                            // The element size includes the max. number of
-                            // bytes. The element m_pString includes the pointer
-                            // to string in MEM. The memory location of default string
-                            // must be copied to memory location of current string.
-
-                            pDstData = pSubIndex->m_pCurrent;
-                            if (pDstData != NULL)
-                            {
-                                // 08-dec-2004: code optimization !!!
-                                //              entries ((tEplObdVStringDef ROM*) pSubIndex->m_pDefault)->m_pString
-                                //              and ((tEplObdVStringDef ROM*) pSubIndex->m_pDefault)->m_Size were read
-                                //              twice. thats not necessary!
-
-                                // For copying data we have to set the destination pointer to the real RAM string. This
-                                // pointer to RAM string is located in default string info structure. (translated r.d.)
-                                pDstData = (void MEM*) ((tEplObdVStringDef ROM*) pSubIndex->m_pDefault)->m_pString;
-                                ObjSize  = ((tEplObdVStringDef ROM*) pSubIndex->m_pDefault)->m_Size;
-
-
-                                ((tEplObdVString MEM*) pSubIndex->m_pCurrent)->m_pString = pDstData;
-                                ((tEplObdVString MEM*) pSubIndex->m_pCurrent)->m_Size    = ObjSize;
-                            }
+						// at this time no application variable is defined !!!
+						// therefore data can not be copied.
+						break;
+					} else if (pSubIndex->m_Type ==
+						   kEplObdTypVString) {
+						// If pointer m_pCurrent is not equal to NULL then the
+						// string was defined with EPL_OBD_SUBINDEX_RAM_VSTRING. The current
+						// pointer points to struct tEplObdVString located in MEM.
+						// The element size includes the max. number of
+						// bytes. The element m_pString includes the pointer
+						// to string in MEM. The memory location of default string
+						// must be copied to memory location of current string.
+
+						pDstData =
+						    pSubIndex->m_pCurrent;
+						if (pDstData != NULL) {
+							// 08-dec-2004: code optimization !!!
+							//              entries ((tEplObdVStringDef ROM*) pSubIndex->m_pDefault)->m_pString
+							//              and ((tEplObdVStringDef ROM*) pSubIndex->m_pDefault)->m_Size were read
+							//              twice. thats not necessary!
+
+							// For copying data we have to set the destination pointer to the real RAM string. This
+							// pointer to RAM string is located in default string info structure. (translated r.d.)
+							pDstData =
+							    (void MEM
+							     *)((tEplObdVStringDef ROM *) pSubIndex->m_pDefault)->m_pString;
+							ObjSize =
+							    ((tEplObdVStringDef
+							      ROM *) pSubIndex->
+							     m_pDefault)->
+							    m_Size;
+
+							((tEplObdVString MEM *)
+							 pSubIndex->
+							 m_pCurrent)->
+				     m_pString = pDstData;
+							((tEplObdVString MEM *)
+							 pSubIndex->
+							 m_pCurrent)->m_Size =
+				     ObjSize;
+						}
+
+					} else if (pSubIndex->m_Type ==
+						   kEplObdTypOString) {
+						pDstData =
+						    pSubIndex->m_pCurrent;
+						if (pDstData != NULL) {
+							// 08-dec-2004: code optimization !!!
+							//              entries ((tEplObdOStringDef ROM*) pSubIndex->m_pDefault)->m_pString
+							//              and ((tEplObdOStringDef ROM*) pSubIndex->m_pDefault)->m_Size were read
+							//              twice. thats not necessary!
+
+							// For copying data we have to set the destination pointer to the real RAM string. This
+							// pointer to RAM string is located in default string info structure. (translated r.d.)
+							pDstData =
+							    (void MEM
+							     *)((tEplObdOStringDef ROM *) pSubIndex->m_pDefault)->m_pString;
+							ObjSize =
+							    ((tEplObdOStringDef
+							      ROM *) pSubIndex->
+							     m_pDefault)->
+							    m_Size;
+
+							((tEplObdOString MEM *)
+							 pSubIndex->
+							 m_pCurrent)->
+				     m_pString = pDstData;
+							((tEplObdOString MEM *)
+							 pSubIndex->
+							 m_pCurrent)->m_Size =
+				     ObjSize;
+						}
+
+					}
+
+					// no break !! because copy of data has to done too.
+
+					// --------------------------------------------------------------------------
+					// all objects has to be restored with default values
+				case kEplObdDirRestore:
+
+					// 09-dec-2004 r.d.: optimization! the same code for kEplObdDirRestore and kEplObdDirLoad
+					//                   is replaced to function ObdCopyObjectData() with a new parameter.
+
+					// restore object data for init phase
+					EplObdCopyObjectData(pDstData, pDefault,
+							     ObjSize,
+							     pSubIndex->m_Type);
+					break;
+
+					// --------------------------------------------------------------------------
+					// objects with attribute kEplObdAccStore has to be load from EEPROM or from a file
+				case kEplObdDirLoad:
+
+					// restore object data for init phase
+					EplObdCopyObjectData(pDstData, pDefault,
+							     ObjSize,
+							     pSubIndex->m_Type);
+
+					// no break !! because callback function has to be called too.
+
+					// --------------------------------------------------------------------------
+					// objects with attribute kEplObdAccStore has to be stored in EEPROM or in a file
+				case kEplObdDirStore:
 
-                        }
-                        else if(pSubIndex->m_Type == kEplObdTypOString)
-                        {
-                            pDstData = pSubIndex->m_pCurrent;
-                            if (pDstData != NULL)
-                            {
-                                // 08-dec-2004: code optimization !!!
-                                //              entries ((tEplObdOStringDef ROM*) pSubIndex->m_pDefault)->m_pString
-                                //              and ((tEplObdOStringDef ROM*) pSubIndex->m_pDefault)->m_Size were read
-                                //              twice. thats not necessary!
-
-                                // For copying data we have to set the destination pointer to the real RAM string. This
-                                // pointer to RAM string is located in default string info structure. (translated r.d.)
-                                pDstData = (void MEM*) ((tEplObdOStringDef ROM*) pSubIndex->m_pDefault)->m_pString;
-                                ObjSize  = ((tEplObdOStringDef ROM*) pSubIndex->m_pDefault)->m_Size;
-
-
-                                ((tEplObdOString MEM*) pSubIndex->m_pCurrent)->m_pString = pDstData;
-                                ((tEplObdOString MEM*) pSubIndex->m_pCurrent)->m_Size    = ObjSize;
-                            }
-
-                        }
-
-
-                        // no break !! because copy of data has to done too.
-
-                    // --------------------------------------------------------------------------
-                    // all objects has to be restored with default values
-                    case kEplObdDirRestore:
-
-                        // 09-dec-2004 r.d.: optimization! the same code for kEplObdDirRestore and kEplObdDirLoad
-                        //                   is replaced to function ObdCopyObjectData() with a new parameter.
-
-
-                        // restore object data for init phase
-                        EplObdCopyObjectData (pDstData, pDefault, ObjSize, pSubIndex->m_Type);
-                        break;
-
-                    // --------------------------------------------------------------------------
-                    // objects with attribute kEplObdAccStore has to be load from EEPROM or from a file
-                    case kEplObdDirLoad:
-
-                        // restore object data for init phase
-                        EplObdCopyObjectData (pDstData, pDefault, ObjSize, pSubIndex->m_Type);
-
-                        // no break !! because callback function has to be called too.
-
-                    // --------------------------------------------------------------------------
-                    // objects with attribute kEplObdAccStore has to be stored in EEPROM or in a file
-                    case kEplObdDirStore:
-
-                        // when attribute kEplObdAccStore is set, then call callback function
-                        #if (EPL_OBD_USE_STORE_RESTORE != FALSE)
-                        if ((Access & kEplObdAccStore) != 0)
-                        {
-                            // fill out data pointer and size of data
-                            CbStore.m_pData    = pDstData;
-                            CbStore.m_ObjSize  = ObjSize;
-
-                            // call callback function for read or write object
-                            Ret = ObdCallStoreCallback (EPL_MCO_INSTANCE_PTR_
-                                &CbStore);
-                            if (Ret != kEplSuccessful)
-                            {
-                                goto Exit;
-                            }
-                        }
-                        #endif // (EPL_OBD_USE_STORE_RESTORE != FALSE)
-                        break;
-
-
-                    // --------------------------------------------------------------------------
-                    // if OD Builder key has to be checked no access to subindex and data should be made
-                    case kEplObdDirOBKCheck:
-
-                        // no break !! because we want to break the second loop too.
-
-
-                    // --------------------------------------------------------------------------
-                    // unknown Direction
-                    default:
-
-                        // so we can break the second loop earler
-                        nSubIndexCount = 1;
-                        break;
-                }
-
-                nSubIndexCount--;
-
-                // next subindex entry
-                if ((Access & kEplObdAccArray) == 0)
-                {
-                    pSubIndex++;
-                    if ((nSubIndexCount > 0)
-                        && ((pSubIndex->m_Access & kEplObdAccArray) != 0))
-                    {
-                        // next subindex points to an array
-                        // reset subindex number
-                        pSubIndex->m_uiSubIndex = 1;
-                    }
-                }
-                else
-                {
-                    if (nSubIndexCount > 0)
-                    {
-                        // next subindex points to an array
-                        // increment subindex number
-                        pSubIndex->m_uiSubIndex++;
-                    }
-                }
-            }
-
-            // next index entry
-            pObdEnty_p++;
-        }
-    }
-
-    // -----------------------------------------------------------------------------------------
-    // command of last action depends on direction to access
-    if (Direction_p == kEplObdDirOBKCheck)
-    {
+					// when attribute kEplObdAccStore is set, then call callback function
+#if (EPL_OBD_USE_STORE_RESTORE != FALSE)
+					if ((Access & kEplObdAccStore) != 0) {
+						// fill out data pointer and size of data
+						CbStore.m_pData = pDstData;
+						CbStore.m_ObjSize = ObjSize;
+
+						// call callback function for read or write object
+						Ret =
+						    ObdCallStoreCallback
+						    (EPL_MCO_INSTANCE_PTR_ &
+						     CbStore);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+					}
+#endif // (EPL_OBD_USE_STORE_RESTORE != FALSE)
+					break;
 
-        goto Exit;
-    }
-    #if (EPL_OBD_USE_STORE_RESTORE != FALSE)
-    else
-    {
-        if (Direction_p == kEplObdDirLoad)
-        {
-            CbStore.m_bCommand = (BYTE) kEplObdCommCloseRead;
-        }
-        else if (Direction_p == kEplObdDirStore)
-        {
-            CbStore.m_bCommand = (BYTE) kEplObdCommCloseWrite;
-        }
-        else if (Direction_p == kEplObdDirRestore)
-        {
-            CbStore.m_bCommand = (BYTE) kEplObdCommClear;
-        }
-        else
-        {
-            goto Exit;
-        }
+					// --------------------------------------------------------------------------
+					// if OD Builder key has to be checked no access to subindex and data should be made
+				case kEplObdDirOBKCheck:
+
+					// no break !! because we want to break the second loop too.
+
+					// --------------------------------------------------------------------------
+					// unknown Direction
+				default:
+
+					// so we can break the second loop earler
+					nSubIndexCount = 1;
+					break;
+				}
+
+				nSubIndexCount--;
+
+				// next subindex entry
+				if ((Access & kEplObdAccArray) == 0) {
+					pSubIndex++;
+					if ((nSubIndexCount > 0)
+					    &&
+					    ((pSubIndex->
+					      m_Access & kEplObdAccArray) !=
+					     0)) {
+						// next subindex points to an array
+						// reset subindex number
+						pSubIndex->m_uiSubIndex = 1;
+					}
+				} else {
+					if (nSubIndexCount > 0) {
+						// next subindex points to an array
+						// increment subindex number
+						pSubIndex->m_uiSubIndex++;
+					}
+				}
+			}
+
+			// next index entry
+			pObdEnty_p++;
+		}
+	}
+	// -----------------------------------------------------------------------------------------
+	// command of last action depends on direction to access
+	if (Direction_p == kEplObdDirOBKCheck) {
 
-        // call callback function for last command
-        Ret = EplObdCallStoreCallback (EPL_MCO_INSTANCE_PTR_
-            &CbStore);
-    }
-    #endif // (EPL_OBD_USE_STORE_RESTORE != FALSE)
+		goto Exit;
+	}
+#if (EPL_OBD_USE_STORE_RESTORE != FALSE)
+	else {
+		if (Direction_p == kEplObdDirLoad) {
+			CbStore.m_bCommand = (BYTE) kEplObdCommCloseRead;
+		} else if (Direction_p == kEplObdDirStore) {
+			CbStore.m_bCommand = (BYTE) kEplObdCommCloseWrite;
+		} else if (Direction_p == kEplObdDirRestore) {
+			CbStore.m_bCommand = (BYTE) kEplObdCommClear;
+		} else {
+			goto Exit;
+		}
+
+		// call callback function for last command
+		Ret = EplObdCallStoreCallback(EPL_MCO_INSTANCE_PTR_ & CbStore);
+	}
+#endif // (EPL_OBD_USE_STORE_RESTORE != FALSE)
 
 //    goto Exit;
 
-Exit:
+      Exit:
 
-    return Ret;
+	return Ret;
 
 }
 
-
 // ----------------------------------------------------------------------------
 // Function:    EplObdCopyObjectData()
 //
@@ -3333,52 +3104,44 @@ Exit:
 // Returns:     tEplKernel              = error code
 // ----------------------------------------------------------------------------
 
-static void EplObdCopyObjectData (
-            void MEM*           pDstData_p,
-            void *              pSrcData_p,
-            tEplObdSize         ObjSize_p,
-            tEplObdType         ObjType_p)
-{
-
-
-tEplObdSize StrSize = 0;
-
-
-    // it is allowed to set default and current address to NULL (nothing to copy)
-    if (pDstData_p != NULL)
-    {
-
-        if (ObjType_p == kEplObdTypVString)
-        {
-            // The function calculates the really number of characters of string. The
-            // object entry size can be bigger as string size of default string.
-            // The '\0'-termination is included. A string with no characters has a
-            // size of 1.
-            StrSize = EplObdGetStrLen ((void *) pSrcData_p, ObjSize_p, kEplObdTypVString);
-
-            // If the string length is greater than or equal to the entry size in OD then only copy
-            // entry size - 1 and always set the '\0'-termination.
-            if (StrSize >= ObjSize_p)
-            {
-                StrSize = ObjSize_p - 1;
-            }
-        }
-
-        if (pSrcData_p != NULL)
-        {
-            // copy data
-            EPL_MEMCPY (pDstData_p, pSrcData_p, ObjSize_p);
-
-            if (ObjType_p == kEplObdTypVString)
-            {
-                ((char MEM*) pDstData_p)[StrSize] = '\0';
-            }
-        }
-    }
+static void EplObdCopyObjectData(void MEM * pDstData_p,
+				 void *pSrcData_p,
+				 tEplObdSize ObjSize_p, tEplObdType ObjType_p)
+{
+
+	tEplObdSize StrSize = 0;
+
+	// it is allowed to set default and current address to NULL (nothing to copy)
+	if (pDstData_p != NULL) {
+
+		if (ObjType_p == kEplObdTypVString) {
+			// The function calculates the really number of characters of string. The
+			// object entry size can be bigger as string size of default string.
+			// The '\0'-termination is included. A string with no characters has a
+			// size of 1.
+			StrSize =
+			    EplObdGetStrLen((void *)pSrcData_p, ObjSize_p,
+					    kEplObdTypVString);
+
+			// If the string length is greater than or equal to the entry size in OD then only copy
+			// entry size - 1 and always set the '\0'-termination.
+			if (StrSize >= ObjSize_p) {
+				StrSize = ObjSize_p - 1;
+			}
+		}
+
+		if (pSrcData_p != NULL) {
+			// copy data
+			EPL_MEMCPY(pDstData_p, pSrcData_p, ObjSize_p);
+
+			if (ObjType_p == kEplObdTypVString) {
+				((char MEM *)pDstData_p)[StrSize] = '\0';
+			}
+		}
+	}
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdIsNumericalIntern()
@@ -3399,28 +3162,23 @@ tEplObdSize StrSize = 0;
 //
 //---------------------------------------------------------------------------
 static tEplKernel EplObdIsNumericalIntern(tEplObdSubEntryPtr pObdSubEntry_p,
-                                        BOOL*         pfEntryNumerical_p)
+					  BOOL * pfEntryNumerical_p)
 {
-tEplKernel          Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
+	// get Type
+	if ((pObdSubEntry_p->m_Type == kEplObdTypVString)
+	    || (pObdSubEntry_p->m_Type == kEplObdTypOString)
+	    || (pObdSubEntry_p->m_Type == kEplObdTypDomain)) {	// not numerical types
+		*pfEntryNumerical_p = FALSE;
+	} else {		// numerical types
+		*pfEntryNumerical_p = TRUE;
+	}
 
-    // get Type
-    if((pObdSubEntry_p->m_Type == kEplObdTypVString)
-        || (pObdSubEntry_p->m_Type == kEplObdTypOString)
-        || (pObdSubEntry_p->m_Type == kEplObdTypDomain))
-    {   // not numerical types
-        *pfEntryNumerical_p = FALSE;
-    }
-    else
-    {   // numerical types
-        *pfEntryNumerical_p = TRUE;
-    }
-
-    return Ret;
+	return Ret;
 
 }
 
-
 // -------------------------------------------------------------------------
 // function to classify object type (fixed/non fixed)
 // -------------------------------------------------------------------------
@@ -3437,22 +3195,24 @@ tEplKernel          Ret = kEplSuccessful
 // Returns:     tEplKernel             = error code
 // ----------------------------------------------------------------------------
 #if (EPL_OBD_USE_STORE_RESTORE != FALSE)
-static tEplKernel EplObdCallStoreCallback (EPL_MCO_DECL_INSTANCE_PTR_
-    tEplObdCbStoreParam MEM* pCbStoreParam_p)
+static tEplKernel EplObdCallStoreCallback(EPL_MCO_DECL_INSTANCE_PTR_
+					  tEplObdCbStoreParam MEM *
+					  pCbStoreParam_p)
 {
 
-tEplKernel Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    ASSERT (pCbStoreParam_p != NULL);
+	ASSERT(pCbStoreParam_p != NULL);
 
-    // check if function pointer is NULL - if so, no callback should be called
-    if (EPL_MCO_GLB_VAR (m_fpStoreLoadObjCallback) != NULL)
-    {
-        Ret = EPL_MCO_GLB_VAR (m_fpStoreLoadObjCallback) (EPL_MCO_INSTANCE_PARAM_IDX_()
-            pCbStoreParam_p);
-    }
+	// check if function pointer is NULL - if so, no callback should be called
+	if (EPL_MCO_GLB_VAR(m_fpStoreLoadObjCallback) != NULL) {
+		Ret =
+		    EPL_MCO_GLB_VAR(m_fpStoreLoadObjCallback)
+		    (EPL_MCO_INSTANCE_PARAM_IDX_()
+		     pCbStoreParam_p);
+	}
 
-    return Ret;
+	return Ret;
 
 }
 #endif // (EPL_OBD_USE_STORE_RESTORE != FALSE)
@@ -3472,34 +3232,31 @@ tEplKernel Ret = kEplSuccessful;
 //
 //---------------------------------------------------------------------------
 
-void * EplObdGetObjectDataPtrIntern (tEplObdSubEntryPtr pSubindexEntry_p)
+void *EplObdGetObjectDataPtrIntern(tEplObdSubEntryPtr pSubindexEntry_p)
 {
 
-void * pData;
-tEplObdAccess Access;
+	void *pData;
+	tEplObdAccess Access;
 
-    ASSERTMSG (pSubindexEntry_p != NULL, "EplObdGetObjectDataPtrIntern(): pointer to SubEntry not valid!\n");
+	ASSERTMSG(pSubindexEntry_p != NULL,
+		  "EplObdGetObjectDataPtrIntern(): pointer to SubEntry not valid!\n");
 
-    // there are are some objects whose data pointer has to get from other structure
-    // get access type for this object
-    Access = pSubindexEntry_p->m_Access;
-
-    // If object has access type = const,
-    // for data only exists default values.
-    if ((Access & kEplObdAccConst) != 0)
-    {
-        // The pointer to defualt value can be received from ObdGetObjectDefaultPtr()
-        pData = ((void *) EplObdGetObjectDefaultPtr (pSubindexEntry_p));
-    }
-    else
-    {
-        // The pointer to current value can be received from ObdGetObjectCurrentPtr()
-        pData = ((void *) EplObdGetObjectCurrentPtr (pSubindexEntry_p));
-    }
+	// there are are some objects whose data pointer has to get from other structure
+	// get access type for this object
+	Access = pSubindexEntry_p->m_Access;
+
+	// If object has access type = const,
+	// for data only exists default values.
+	if ((Access & kEplObdAccConst) != 0) {
+		// The pointer to defualt value can be received from ObdGetObjectDefaultPtr()
+		pData = ((void *)EplObdGetObjectDefaultPtr(pSubindexEntry_p));
+	} else {
+		// The pointer to current value can be received from ObdGetObjectCurrentPtr()
+		pData = ((void *)EplObdGetObjectCurrentPtr(pSubindexEntry_p));
+	}
 
-    return pData;
+	return pData;
 
 }
 #endif // end of #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
 // EOF
-
--- a/drivers/staging/epl/EplObdkCal.c
+++ b/drivers/staging/epl/EplObdkCal.c
@@ -96,9 +96,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -123,7 +120,6 @@
 //
 //---------------------------------------------------------------------------
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -148,7 +144,4 @@
 //
 //---------------------------------------------------------------------------
 
-
-
 // EOF
-
--- a/drivers/staging/epl/EplObdu.c
+++ b/drivers/staging/epl/EplObdu.c
@@ -97,8 +97,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -123,19 +121,18 @@
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduWriteEntry (unsigned int  uiIndex_p,
-                                                unsigned int  uiSubIndex_p,
-                                                void * pSrcData_p,
-                                                tEplObdSize   Size_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduWriteEntry(unsigned int uiIndex_p,
+						 unsigned int uiSubIndex_p,
+						 void *pSrcData_p,
+						 tEplObdSize Size_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplObduCalWriteEntry(uiIndex_p, uiSubIndex_p, pSrcData_p, Size_p);
+	Ret = EplObduCalWriteEntry(uiIndex_p, uiSubIndex_p, pSrcData_p, Size_p);
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObduReadEntry()
@@ -156,19 +153,18 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduReadEntry (unsigned int        uiIndex_p,
-                                            unsigned int        uiSubIndex_p,
-                                            void *       pDstData_p,
-                                            tEplObdSize* pSize_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduReadEntry(unsigned int uiIndex_p,
+						unsigned int uiSubIndex_p,
+						void *pDstData_p,
+						tEplObdSize * pSize_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplObduCalReadEntry(uiIndex_p, uiSubIndex_p, pDstData_p, pSize_p);
+	Ret = EplObduCalReadEntry(uiIndex_p, uiSubIndex_p, pDstData_p, pSize_p);
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObdAccessOdPart()
@@ -183,14 +179,14 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduAccessOdPart (tEplObdPart ObdPart_p,
-                                                    tEplObdDir Direction_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduAccessOdPart(tEplObdPart ObdPart_p,
+						   tEplObdDir Direction_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplObduCalAccessOdPart(ObdPart_p, Direction_p);
+	Ret = EplObduCalAccessOdPart(ObdPart_p, Direction_p);
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -206,13 +202,13 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduDefineVar (tEplVarParam MEM* pVarParam_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduDefineVar(tEplVarParam MEM * pVarParam_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplObduCalDefineVar(pVarParam_p);
+	Ret = EplObduCalDefineVar(pVarParam_p);
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -230,14 +226,14 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT void* PUBLIC EplObduGetObjectDataPtr (unsigned int uiIndex_p,
-                                        unsigned int uiSubIndex_p)
+EPLDLLEXPORT void *PUBLIC EplObduGetObjectDataPtr(unsigned int uiIndex_p,
+						  unsigned int uiSubIndex_p)
 {
-void*   pData;
+	void *pData;
 
-    pData =  EplObduCalGetObjectDataPtr(uiIndex_p, uiSubIndex_p);
+	pData = EplObduCalGetObjectDataPtr(uiIndex_p, uiSubIndex_p);
 
-    return pData;
+	return pData;
 }
 
 //---------------------------------------------------------------------------
@@ -254,13 +250,13 @@ void*   pData;
 //
 //---------------------------------------------------------------------------
 #if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
-EPLDLLEXPORT tEplKernel PUBLIC EplObduRegisterUserOd (tEplObdEntryPtr pUserOd_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduRegisterUserOd(tEplObdEntryPtr pUserOd_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplObduCalRegisterUserOd(pUserOd_p);
+	Ret = EplObduCalRegisterUserOd(pUserOd_p);
 
-    return Ret;
+	return Ret;
 
 }
 #endif
@@ -279,10 +275,11 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT void PUBLIC EplObduInitVarEntry (tEplObdVarEntry MEM* pVarEntry_p,
-                                        BYTE bType_p, tEplObdSize ObdSize_p)
+EPLDLLEXPORT void PUBLIC EplObduInitVarEntry(tEplObdVarEntry MEM * pVarEntry_p,
+					     BYTE bType_p,
+					     tEplObdSize ObdSize_p)
 {
-    EplObduCalInitVarEntry(pVarEntry_p, bType_p, ObdSize_p);
+	EplObduCalInitVarEntry(pVarEntry_p, bType_p, ObdSize_p);
 }
 
 //---------------------------------------------------------------------------
@@ -303,13 +300,13 @@ EPLDLLEXPORT void PUBLIC EplObduInitVarE
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplObdSize PUBLIC EplObduGetDataSize(unsigned int uiIndex_p,
-                                        unsigned int uiSubIndex_p)
+						   unsigned int uiSubIndex_p)
 {
-tEplObdSize Size;
+	tEplObdSize Size;
 
-    Size = EplObduCalGetDataSize(uiIndex_p, uiSubIndex_p);
+	Size = EplObduCalGetDataSize(uiIndex_p, uiSubIndex_p);
 
-    return Size;
+	return Size;
 }
 
 //---------------------------------------------------------------------------
@@ -328,11 +325,11 @@ tEplObdSize Size;
 //---------------------------------------------------------------------------
 EPLDLLEXPORT unsigned int PUBLIC EplObduGetNodeId()
 {
-unsigned int uiNodeId;
+	unsigned int uiNodeId;
 
-    uiNodeId = EplObduCalGetNodeId();
+	uiNodeId = EplObduCalGetNodeId();
 
-    return uiNodeId;
+	return uiNodeId;
 }
 
 //---------------------------------------------------------------------------
@@ -351,13 +348,13 @@ unsigned int uiNodeId;
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplObduSetNodeId(unsigned int uiNodeId_p,
-                                         tEplObdNodeIdType NodeIdType_p)
+						tEplObdNodeIdType NodeIdType_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplObduCalSetNodeId(uiNodeId_p, NodeIdType_p);
+	Ret = EplObduCalSetNodeId(uiNodeId_p, NodeIdType_p);
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -377,14 +374,16 @@ tEplKernel  Ret;
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplObduGetAccessType(unsigned int uiIndex_p,
-                                        unsigned int   uiSubIndex_p,
-                                        tEplObdAccess* pAccessTyp_p)
+						    unsigned int uiSubIndex_p,
+						    tEplObdAccess *
+						    pAccessTyp_p)
 {
-tEplObdAccess AccessType;
+	tEplObdAccess AccessType;
 
-    AccessType = EplObduCalGetAccessType(uiIndex_p, uiSubIndex_p, pAccessTyp_p);
+	AccessType =
+	    EplObduCalGetAccessType(uiIndex_p, uiSubIndex_p, pAccessTyp_p);
 
-    return AccessType;
+	return AccessType;
 }
 
 //---------------------------------------------------------------------------
@@ -411,16 +410,18 @@ tEplObdAccess AccessType;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduReadEntryToLe (unsigned int        uiIndex_p,
-                                        unsigned int        uiSubIndex_p,
-                                        void *              pDstData_p,
-                                        tEplObdSize *       pSize_p)
-{
-tEplKernel  Ret;
+EPLDLLEXPORT tEplKernel PUBLIC EplObduReadEntryToLe(unsigned int uiIndex_p,
+						    unsigned int uiSubIndex_p,
+						    void *pDstData_p,
+						    tEplObdSize * pSize_p)
+{
+	tEplKernel Ret;
+
+	Ret =
+	    EplObduCalReadEntryToLe(uiIndex_p, uiSubIndex_p, pDstData_p,
+				    pSize_p);
 
-    Ret = EplObduCalReadEntryToLe(uiIndex_p, uiSubIndex_p, pDstData_p, pSize_p);
-
-return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -444,16 +445,19 @@ return Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduWriteEntryFromLe (unsigned int  uiIndex_p,
-                                        unsigned int  uiSubIndex_p,
-                                        void *        pSrcData_p,
-                                        tEplObdSize   Size_p)
-{
-tEplKernel  Ret;
-
-    Ret = EplObduCalWriteEntryFromLe(uiIndex_p, uiSubIndex_p, pSrcData_p, Size_p);
+EPLDLLEXPORT tEplKernel PUBLIC EplObduWriteEntryFromLe(unsigned int uiIndex_p,
+						       unsigned int
+						       uiSubIndex_p,
+						       void *pSrcData_p,
+						       tEplObdSize Size_p)
+{
+	tEplKernel Ret;
+
+	Ret =
+	    EplObduCalWriteEntryFromLe(uiIndex_p, uiSubIndex_p, pSrcData_p,
+				       Size_p);
 
-return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -471,17 +475,19 @@ return Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduSearchVarEntry (EPL_MCO_DECL_INSTANCE_PTR_
-                                            unsigned int            uiIndex_p,
-                                            unsigned int            uiSubindex_p,
-                                            tEplObdVarEntry MEM**   ppVarEntry_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduSearchVarEntry(EPL_MCO_DECL_INSTANCE_PTR_
+						     unsigned int uiIndex_p,
+						     unsigned int uiSubindex_p,
+						     tEplObdVarEntry MEM **
+						     ppVarEntry_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplObduCalSearchVarEntry(uiIndex_p, uiSubindex_p, ppVarEntry_p);
+	Ret = EplObduCalSearchVarEntry(uiIndex_p, uiSubindex_p, ppVarEntry_p);
 
-return Ret;
+	return Ret;
 }
+
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -509,4 +515,3 @@ return Ret;
 #endif // #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
 
 // EOF
-
--- a/drivers/staging/epl/EplObduCal.c
+++ b/drivers/staging/epl/EplObduCal.c
@@ -74,7 +74,6 @@
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0) && (EPL_OBD_USE_KERNEL != FALSE)
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -99,8 +98,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -124,24 +121,22 @@
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduCalWriteEntry (
-                                                unsigned int  uiIndex_p,
-                                                unsigned int  uiSubIndex_p,
-                                                void * pSrcData_p,
-                                                tEplObdSize   Size_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduCalWriteEntry(unsigned int uiIndex_p,
+						    unsigned int uiSubIndex_p,
+						    void *pSrcData_p,
+						    tEplObdSize Size_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    Ret = EplObdWriteEntry(uiIndex_p,uiSubIndex_p,pSrcData_p,Size_p);
+	Ret = EplObdWriteEntry(uiIndex_p, uiSubIndex_p, pSrcData_p, Size_p);
 #else
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 #endif
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObduCalReadEntry()
@@ -160,24 +155,22 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduCalReadEntry (
-                                            unsigned int        uiIndex_p,
-                                            unsigned int        uiSubIndex_p,
-                                            void *       pDstData_p,
-                                            tEplObdSize *pSize_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduCalReadEntry(unsigned int uiIndex_p,
+						   unsigned int uiSubIndex_p,
+						   void *pDstData_p,
+						   tEplObdSize * pSize_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    Ret = EplObdReadEntry(uiIndex_p, uiSubIndex_p, pDstData_p, pSize_p);
+	Ret = EplObdReadEntry(uiIndex_p, uiSubIndex_p, pDstData_p, pSize_p);
 #else
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 #endif
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObduCalAccessOdPart()
@@ -192,19 +185,18 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduCalAccessOdPart (
-                                                    tEplObdPart ObdPart_p,
-                                                    tEplObdDir Direction_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduCalAccessOdPart(tEplObdPart ObdPart_p,
+						      tEplObdDir Direction_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    Ret = EplObdAccessOdPart(ObdPart_p, Direction_p);
+	Ret = EplObdAccessOdPart(ObdPart_p, Direction_p);
 #else
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -220,17 +212,18 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduCalDefineVar (tEplVarParam MEM* pVarParam_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduCalDefineVar(tEplVarParam MEM *
+						   pVarParam_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    Ret = EplObdDefineVar(pVarParam_p);
+	Ret = EplObdDefineVar(pVarParam_p);
 #else
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -247,18 +240,18 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT void* PUBLIC EplObduCalGetObjectDataPtr ( unsigned int uiIndex_p,
-                                        unsigned int uiSubIndex_p)
+EPLDLLEXPORT void *PUBLIC EplObduCalGetObjectDataPtr(unsigned int uiIndex_p,
+						     unsigned int uiSubIndex_p)
 {
-void*   pData;
+	void *pData;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    pData = EplObdGetObjectDataPtr(uiIndex_p, uiSubIndex_p);
+	pData = EplObdGetObjectDataPtr(uiIndex_p, uiSubIndex_p);
 #else
-    pData = NULL;
+	pData = NULL;
 #endif
 
-    return pData;
+	return pData;
 }
 
 //---------------------------------------------------------------------------
@@ -275,17 +268,18 @@ void*   pData;
 //
 //---------------------------------------------------------------------------
 #if (defined (EPL_OBD_USER_OD) && (EPL_OBD_USER_OD != FALSE))
-EPLDLLEXPORT tEplKernel PUBLIC EplObduCalRegisterUserOd (tEplObdEntryPtr pUserOd_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduCalRegisterUserOd(tEplObdEntryPtr
+							pUserOd_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    Ret = EplObdRegisterUserOd(pUserOd_p);
+	Ret = EplObdRegisterUserOd(pUserOd_p);
 #else
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 #endif
 
-    return Ret;
+	return Ret;
 
 }
 #endif
@@ -304,15 +298,15 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT void PUBLIC EplObduCalInitVarEntry (tEplObdVarEntry MEM* pVarEntry_p,
-                                        BYTE bType_p, tEplObdSize ObdSize_p)
+EPLDLLEXPORT void PUBLIC EplObduCalInitVarEntry(tEplObdVarEntry MEM *
+						pVarEntry_p, BYTE bType_p,
+						tEplObdSize ObdSize_p)
 {
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    EplObdInitVarEntry(pVarEntry_p, bType_p, ObdSize_p);
+	EplObdInitVarEntry(pVarEntry_p, bType_p, ObdSize_p);
 #endif
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplObduCalGetDataSize()
@@ -331,17 +325,17 @@ EPLDLLEXPORT void PUBLIC EplObduCalInitV
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplObdSize PUBLIC EplObduCalGetDataSize(unsigned int uiIndex_p,
-                                        unsigned int uiSubIndex_p)
+						      unsigned int uiSubIndex_p)
 {
-tEplObdSize Size;
+	tEplObdSize Size;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    Size = EplObdGetDataSize(uiIndex_p, uiSubIndex_p);
+	Size = EplObdGetDataSize(uiIndex_p, uiSubIndex_p);
 #else
-    Size = 0;
+	Size = 0;
 #endif
 
-    return Size;
+	return Size;
 }
 
 //---------------------------------------------------------------------------
@@ -360,15 +354,15 @@ tEplObdSize Size;
 //---------------------------------------------------------------------------
 EPLDLLEXPORT unsigned int PUBLIC EplObduCalGetNodeId()
 {
-unsigned int uiNodeId;
+	unsigned int uiNodeId;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    uiNodeId = EplObdGetNodeId();
+	uiNodeId = EplObdGetNodeId();
 #else
-    uiNodeId = 0;
+	uiNodeId = 0;
 #endif
 
-    return uiNodeId;
+	return uiNodeId;
 }
 
 //---------------------------------------------------------------------------
@@ -387,17 +381,18 @@ unsigned int uiNodeId;
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplObduCalSetNodeId(unsigned int uiNodeId_p,
-                                         tEplObdNodeIdType NodeIdType_p)
+						   tEplObdNodeIdType
+						   NodeIdType_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    Ret = EplObdSetNodeId(uiNodeId_p, NodeIdType_p);
+	Ret = EplObdSetNodeId(uiNodeId_p, NodeIdType_p);
 #else
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -417,19 +412,20 @@ tEplKernel  Ret;
 //
 //---------------------------------------------------------------------------
 EPLDLLEXPORT tEplKernel PUBLIC EplObduCalGetAccessType(unsigned int uiIndex_p,
-                                        unsigned int   uiSubIndex_p,
-                                        tEplObdAccess* pAccessTyp_p)
-
+						       unsigned int
+						       uiSubIndex_p,
+						       tEplObdAccess *
+						       pAccessTyp_p)
 {
-tEplObdAccess AccesType;
+	tEplObdAccess AccesType;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    AccesType = EplObdGetAccessType(uiIndex_p, uiSubIndex_p, pAccessTyp_p);
+	AccesType = EplObdGetAccessType(uiIndex_p, uiSubIndex_p, pAccessTyp_p);
 #else
-    AccesType = 0;
+	AccesType = 0;
 #endif
 
-return AccesType;
+	return AccesType;
 
 }
 
@@ -451,20 +447,21 @@ return AccesType;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduCalReadEntryToLe (unsigned int        uiIndex_p,
-                                        unsigned int        uiSubIndex_p,
-                                        void *              pDstData_p,
-                                        tEplObdSize *       pSize_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduCalReadEntryToLe(unsigned int uiIndex_p,
+						       unsigned int
+						       uiSubIndex_p,
+						       void *pDstData_p,
+						       tEplObdSize * pSize_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    Ret = EplObdReadEntryToLe(uiIndex_p, uiSubIndex_p, pDstData_p, pSize_p);
+	Ret = EplObdReadEntryToLe(uiIndex_p, uiSubIndex_p, pDstData_p, pSize_p);
 #else
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -484,19 +481,22 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduCalWriteEntryFromLe (unsigned int  uiIndex_p,
-                                        unsigned int  uiSubIndex_p,
-                                        void *        pSrcData_p,
-                                        tEplObdSize   Size_p)
+EPLDLLEXPORT tEplKernel PUBLIC EplObduCalWriteEntryFromLe(unsigned int
+							  uiIndex_p,
+							  unsigned int
+							  uiSubIndex_p,
+							  void *pSrcData_p,
+							  tEplObdSize Size_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    Ret = EplObdWriteEntryFromLe(uiIndex_p, uiSubIndex_p, pSrcData_p, Size_p);
+	Ret =
+	    EplObdWriteEntryFromLe(uiIndex_p, uiSubIndex_p, pSrcData_p, Size_p);
 #else
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 #endif
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -514,23 +514,21 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-EPLDLLEXPORT tEplKernel PUBLIC EplObduCalSearchVarEntry (EPL_MCO_DECL_INSTANCE_PTR_
-                                            unsigned int            uiIndex_p,
-                                            unsigned int            uiSubindex_p,
-                                            tEplObdVarEntry MEM**   ppVarEntry_p)
+EPLDLLEXPORT tEplKernel PUBLIC
+EplObduCalSearchVarEntry(EPL_MCO_DECL_INSTANCE_PTR_ unsigned int uiIndex_p,
+			 unsigned int uiSubindex_p,
+			 tEplObdVarEntry MEM ** ppVarEntry_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) != 0)
-    Ret = EplObdSearchVarEntry(uiIndex_p, uiSubindex_p, ppVarEntry_p);
+	Ret = EplObdSearchVarEntry(uiIndex_p, uiSubindex_p, ppVarEntry_p);
 #else
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 #endif
-    return Ret;
+	return Ret;
 }
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -557,6 +555,4 @@ tEplKernel  Ret;
 
 #endif //(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
 
-
 // EOF
-
--- a/drivers/staging/epl/EplPdok.c
+++ b/drivers/staging/epl/EplPdok.c
@@ -82,13 +82,13 @@
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLK)) == 0)
 
-    #error 'ERROR: Missing DLLk-Modul!'
+#error 'ERROR: Missing DLLk-Modul!'
 
 #endif
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDK)) == 0)
 
-    #error 'ERROR: Missing OBDk-Modul!'
+#error 'ERROR: Missing OBDk-Modul!'
 
 #endif
 /***************************************************************************/
@@ -120,7 +120,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -134,7 +133,6 @@
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -153,12 +151,10 @@
 // local vars
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -183,7 +179,7 @@
 tEplKernel EplPdokAddInstance(void)
 {
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 }
 
 //---------------------------------------------------------------------------
@@ -204,10 +200,9 @@ tEplKernel EplPdokAddInstance(void)
 tEplKernel EplPdokDelInstance(void)
 {
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplPdokCbPdoReceived
@@ -228,27 +223,27 @@ tEplKernel EplPdokDelInstance(void)
 
 tEplKernel EplPdokCbPdoReceived(tEplFrameInfo * pFrameInfo_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplEvent       Event;
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
 
 #if (DEV_SYSTEM == _DEV_GNU_CF548X_)
-    // reset LED
+	// reset LED
 //    MCF_GPIO_PODR_PCIBG &= ~PDO_LED;  // Level
 #endif
 
-    Event.m_EventSink = kEplEventSinkPdok;
-    Event.m_EventType = kEplEventTypePdoRx;
-    // limit copied data to size of PDO (because from some CNs the frame is larger than necessary)
-    Event.m_uiSize = AmiGetWordFromLe(&pFrameInfo_p->m_pFrame->m_Data.m_Pres.m_le_wSize) + 24; // pFrameInfo_p->m_uiFrameSize;
-    Event.m_pArg = pFrameInfo_p->m_pFrame;
-    Ret = EplEventkPost(&Event);
+	Event.m_EventSink = kEplEventSinkPdok;
+	Event.m_EventType = kEplEventTypePdoRx;
+	// limit copied data to size of PDO (because from some CNs the frame is larger than necessary)
+	Event.m_uiSize = AmiGetWordFromLe(&pFrameInfo_p->m_pFrame->m_Data.m_Pres.m_le_wSize) + 24;	// pFrameInfo_p->m_uiFrameSize;
+	Event.m_pArg = pFrameInfo_p->m_pFrame;
+	Ret = EplEventkPost(&Event);
 
 #if (DEV_SYSTEM == _DEV_GNU_CF548X_)
-    // set LED
+	// set LED
 //    MCF_GPIO_PODR_PCIBG |= PDO_LED;  // Level
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -271,26 +266,26 @@ tEplEvent       Event;
 
 tEplKernel EplPdokCbPdoTransmitted(tEplFrameInfo * pFrameInfo_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplEvent       Event;
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
 
 #if (DEV_SYSTEM == _DEV_GNU_CF548X_)
-    // reset LED
-    MCF_GPIO_PODR_PCIBG &= ~PDO_LED;  // Level
+	// reset LED
+	MCF_GPIO_PODR_PCIBG &= ~PDO_LED;	// Level
 #endif
 
-    Event.m_EventSink = kEplEventSinkPdok;
-    Event.m_EventType = kEplEventTypePdoTx;
-    Event.m_uiSize = sizeof (tEplFrameInfo);
-    Event.m_pArg = pFrameInfo_p;
-    Ret = EplEventkPost(&Event);
+	Event.m_EventSink = kEplEventSinkPdok;
+	Event.m_EventType = kEplEventTypePdoTx;
+	Event.m_uiSize = sizeof(tEplFrameInfo);
+	Event.m_pArg = pFrameInfo_p;
+	Ret = EplEventkPost(&Event);
 
 #if (DEV_SYSTEM == _DEV_GNU_CF548X_)
-    // set LED
-    MCF_GPIO_PODR_PCIBG |= PDO_LED;  // Level
+	// set LED
+	MCF_GPIO_PODR_PCIBG |= PDO_LED;	// Level
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -311,16 +306,16 @@ tEplEvent       Event;
 
 tEplKernel EplPdokCbSoa(tEplFrameInfo * pFrameInfo_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplEvent       Event;
+	tEplKernel Ret = kEplSuccessful;
+	tEplEvent Event;
 
-    Event.m_EventSink = kEplEventSinkPdok;
-    Event.m_EventType = kEplEventTypePdoSoa;
-    Event.m_uiSize = 0;
-    Event.m_pArg = NULL;
-    Ret = EplEventkPost(&Event);
+	Event.m_EventSink = kEplEventSinkPdok;
+	Event.m_EventType = kEplEventTypePdoSoa;
+	Event.m_uiSize = 0;
+	Event.m_pArg = NULL;
+	Ret = EplEventkPost(&Event);
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -343,323 +338,331 @@ tEplEvent       Event;
 
 tEplKernel EplPdokProcess(tEplEvent * pEvent_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-WORD    wPdoSize;
-WORD    wBitOffset;
-WORD    wBitSize;
-WORD    wVarSize;
-QWORD   qwObjectMapping;
-BYTE    bMappSubindex;
-BYTE    bObdSubindex;
-WORD    wObdMappIndex;
-WORD    wObdCommIndex;
-WORD    wPdoId;
-BYTE    bObdData;
-BYTE    bObjectCount;
-BYTE    bFrameData;
-BOOL    fValid;
-tEplObdSize     ObdSize;
-tEplFrame      *pFrame;
-tEplFrameInfo  *pFrameInfo;
-unsigned int    uiNodeId;
-tEplMsgType     MsgType;
-
-    // 0xFF=invalid, RPDO: 0x00=PReq, localNodeId=PRes, remoteNodeId=PRes
-    //               TPDO: 0x00=PRes, MN: CnNodeId=PReq
-
-    switch (pEvent_p->m_EventType)
-    {
-        case kEplEventTypePdoRx:  // RPDO received
-            pFrame = (tEplFrame *) pEvent_p->m_pArg;
-
-            // check if received RPDO is valid
-            bFrameData = AmiGetByteFromLe(&pFrame->m_Data.m_Pres.m_le_bFlag1);
-            if ((bFrameData & EPL_FRAME_FLAG1_RD) == 0)
-            {   // RPDO invalid
-                goto Exit;
-            }
-
-            // retrieve EPL message type
-            MsgType = AmiGetByteFromLe(&pFrame->m_le_bMessageType);
-            if (MsgType == kEplMsgTypePreq)
-            {   // RPDO is PReq frame
-                uiNodeId = EPL_PDO_PREQ_NODE_ID;  // 0x00
-            }
-            else
-            {   // RPDO is PRes frame
-                // retrieve node ID
-                uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bSrcNodeId);
-            }
-
-            // search for appropriate valid RPDO in OD
-            wObdMappIndex = EPL_PDOK_OBD_IDX_RX_MAPP_PARAM;
-            for (wObdCommIndex = EPL_PDOK_OBD_IDX_RX_COMM_PARAM;
-                wObdCommIndex < (EPL_PDOK_OBD_IDX_RX_COMM_PARAM + 0x00FF);
-                wObdCommIndex++, wObdMappIndex++)
-            {
-                ObdSize = 1;
-                // read node ID from OD
-                Ret = EplObdReadEntry(wObdCommIndex, 0x01, &bObdData, &ObdSize);
-                if ((Ret == kEplObdIndexNotExist)
-                    || (Ret == kEplObdSubindexNotExist)
-                    || (Ret == kEplObdIllegalPart))
-                {   // PDO does not exist; last PDO reached
-                    Ret = kEplSuccessful;
-                    goto Exit;
-                }
-                else if (Ret != kEplSuccessful)
-                {   // other fatal error occured
-                    goto Exit;
-                }
-                // entry read successfully
-                if (bObdData != uiNodeId)
-                {   // node ID does not equal - wrong PDO, try next PDO in OD
-                    continue;
-                }
-                ObdSize = 1;
-                // read number of mapped objects from OD; this indicates if the PDO is valid
-                Ret = EplObdReadEntry(wObdMappIndex, 0x00, &bObjectCount, &ObdSize);
-                if ((Ret == kEplObdIndexNotExist)
-                    || (Ret == kEplObdSubindexNotExist)
-                    || (Ret == kEplObdIllegalPart))
-                {   // PDO does not exist; last PDO reached
-                    Ret = kEplSuccessful;
-                    goto Exit;
-                }
-                else if (Ret != kEplSuccessful)
-                {   // other fatal error occured
-                    goto Exit;
-                }
-                // entry read successfully
-                if (bObjectCount == 0)
-                {   // PDO in OD not valid, try next PDO in OD
-                    continue;
-                }
-
-                ObdSize = 1;
-                // check PDO mapping version
-                Ret = EplObdReadEntry(wObdCommIndex, 0x02, &bObdData, &ObdSize);
-                if (Ret != kEplSuccessful)
-                {   // other fatal error occured
-                    goto Exit;
-                }
-                // entry read successfully
-                // retrieve PDO version from frame
-                bFrameData = AmiGetByteFromLe(&pFrame->m_Data.m_Pres.m_le_bPdoVersion);
-                if ((bObdData & EPL_VERSION_MAIN) != (bFrameData & EPL_VERSION_MAIN))
-                {   // PDO versions do not match
-                    // $$$ raise PDO error
-                    // termiate processing of this RPDO
-                    goto Exit;
-                }
-
-                // valid RPDO found
-
-                // retrieve PDO size
-                wPdoSize = AmiGetWordFromLe(&pFrame->m_Data.m_Pres.m_le_wSize);
-
-                // process mapping
-                for (bMappSubindex = 1; bMappSubindex <= bObjectCount; bMappSubindex++)
-                {
-                    ObdSize = 8;    // QWORD
-                    // read object mapping from OD
-                    Ret = EplObdReadEntry(wObdMappIndex, bMappSubindex, &qwObjectMapping, &ObdSize);
-                    if (Ret != kEplSuccessful)
-                    {   // other fatal error occured
-                        goto Exit;
-                    }
-
-                    // check if object mapping entry is valid, i.e. unequal zero, because "empty" entries are allowed
-                    if (qwObjectMapping == 0)
-                    {   // invalid entry, continue with next entry
-                        continue;
-                    }
-
-                    // decode object mapping
-                    wObdCommIndex = (WORD) (qwObjectMapping & 0x000000000000FFFFLL);
-                    bObdSubindex = (BYTE) ((qwObjectMapping & 0x0000000000FF0000LL) >> 16);
-                    wBitOffset = (WORD) ((qwObjectMapping & 0x0000FFFF00000000LL) >> 32);
-                    wBitSize = (WORD) ((qwObjectMapping & 0xFFFF000000000000LL) >> 48);
-
-                    // check if object exceeds PDO size
-                    if (((wBitOffset + wBitSize) >> 3) > wPdoSize)
-                    {   // wrong object mapping; PDO size is too low
-                        // $$$ raise PDO error
-                        // terminate processing of this RPDO
-                        goto Exit;
-                    }
-
-                    // copy object from RPDO to process/OD variable
-                    ObdSize = wBitSize >> 3;
-                    Ret = EplObdWriteEntryFromLe(wObdCommIndex, bObdSubindex, &pFrame->m_Data.m_Pres.m_le_abPayload[(wBitOffset >> 3)], ObdSize);
-                    if (Ret != kEplSuccessful)
-                    {   // other fatal error occured
-                        goto Exit;
-                    }
-
-                }
-
-                // processing finished successfully
-                goto Exit;
-            }
-            break;
-
-        case kEplEventTypePdoTx:  // TPDO transmitted
-            pFrameInfo = (tEplFrameInfo *) pEvent_p->m_pArg;
-            pFrame = pFrameInfo->m_pFrame;
-
-            // set TPDO invalid, so that only fully processed TPDOs are sent as valid
-            bFrameData = AmiGetByteFromLe(&pFrame->m_Data.m_Pres.m_le_bFlag1);
-            AmiSetByteToLe(&pFrame->m_Data.m_Pres.m_le_bFlag1, (bFrameData & ~EPL_FRAME_FLAG1_RD));
-
-            // retrieve EPL message type
-            MsgType = AmiGetByteFromLe(&pFrame->m_le_bMessageType);
-            if (MsgType == kEplMsgTypePres)
-            {   // TPDO is PRes frame
-                uiNodeId = EPL_PDO_PRES_NODE_ID;  // 0x00
-            }
-            else
-            {   // TPDO is PReq frame
-                // retrieve node ID
-                uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bDstNodeId);
-            }
-
-            // search for appropriate valid TPDO in OD
-            wObdMappIndex = EPL_PDOK_OBD_IDX_TX_MAPP_PARAM;
-            wObdCommIndex = EPL_PDOK_OBD_IDX_TX_COMM_PARAM;
-            for (wPdoId = 0; ; wPdoId++, wObdCommIndex++, wObdMappIndex++)
-            {
-                ObdSize = 1;
-                // read node ID from OD
-                Ret = EplObdReadEntry(wObdCommIndex, 0x01, &bObdData, &ObdSize);
-                if ((Ret == kEplObdIndexNotExist)
-                    || (Ret == kEplObdSubindexNotExist)
-                    || (Ret == kEplObdIllegalPart))
-                {   // PDO does not exist; last PDO reached
-                    Ret = kEplSuccessful;
-                    goto Exit;
-                }
-                else if (Ret != kEplSuccessful)
-                {   // other fatal error occured
-                    goto Exit;
-                }
-                // entry read successfully
-                if (bObdData != uiNodeId)
-                {   // node ID does not equal - wrong PDO, try next PDO in OD
-                    continue;
-                }
-                ObdSize = 1;
-                // read number of mapped objects from OD; this indicates if the PDO is valid
-                Ret = EplObdReadEntry(wObdMappIndex, 0x00, &bObjectCount, &ObdSize);
-                if ((Ret == kEplObdIndexNotExist)
-                    || (Ret == kEplObdSubindexNotExist)
-                    || (Ret == kEplObdIllegalPart))
-                {   // PDO does not exist; last PDO reached
-                    Ret = kEplSuccessful;
-                    goto Exit;
-                }
-                else if (Ret != kEplSuccessful)
-                {   // other fatal error occured
-                    goto Exit;
-                }
-                // entry read successfully
-                if (bObjectCount == 0)
-                {   // PDO in OD not valid, try next PDO in OD
-                    continue;
-                }
-
-                // valid TPDO found
-
-                ObdSize = 1;
-                // get PDO mapping version from OD
-                Ret = EplObdReadEntry(wObdCommIndex, 0x02, &bObdData, &ObdSize);
-                if (Ret != kEplSuccessful)
-                {   // other fatal error occured
-                    goto Exit;
-                }
-                // entry read successfully
-                // set PDO version in frame
-                AmiSetByteToLe(&pFrame->m_Data.m_Pres.m_le_bPdoVersion, bObdData);
-
-                // calculate PDO size
-                wPdoSize = 0;
-
-                // process mapping
-                for (bMappSubindex = 1; bMappSubindex <= bObjectCount; bMappSubindex++)
-                {
-                    ObdSize = 8;    // QWORD
-                    // read object mapping from OD
-                    Ret = EplObdReadEntry(wObdMappIndex, bMappSubindex, &qwObjectMapping, &ObdSize);
-                    if (Ret != kEplSuccessful)
-                    {   // other fatal error occured
-                        goto Exit;
-                    }
-
-                    // check if object mapping entry is valid, i.e. unequal zero, because "empty" entries are allowed
-                    if (qwObjectMapping == 0)
-                    {   // invalid entry, continue with next entry
-                        continue;
-                    }
-
-                    // decode object mapping
-                    wObdCommIndex = (WORD) (qwObjectMapping & 0x000000000000FFFFLL);
-                    bObdSubindex = (BYTE) ((qwObjectMapping & 0x0000000000FF0000LL) >> 16);
-                    wBitOffset = (WORD) ((qwObjectMapping & 0x0000FFFF00000000LL) >> 32);
-                    wBitSize = (WORD) ((qwObjectMapping & 0xFFFF000000000000LL) >> 48);
-
-                    // calculate max PDO size
-                    ObdSize = wBitSize >> 3;
-                    wVarSize = (wBitOffset >> 3) + (WORD) ObdSize;
-                    if ((unsigned int)(wVarSize + 24) > pFrameInfo->m_uiFrameSize)
-                    {   // TPDO is too short
-                        // $$$ raise PDO error, set Ret
-                        goto Exit;
-                    }
-                    if (wVarSize > wPdoSize)
-                    {   // memorize new PDO size
-                        wPdoSize = wVarSize;
-                    }
-
-                    // copy object from process/OD variable to TPDO
-                    Ret = EplObdReadEntryToLe(wObdCommIndex, bObdSubindex, &pFrame->m_Data.m_Pres.m_le_abPayload[(wBitOffset >> 3)], &ObdSize);
-                    if (Ret != kEplSuccessful)
-                    {   // other fatal error occured
-                        goto Exit;
-                    }
-
-                }
-
-                // set PDO size in frame
-                AmiSetWordToLe(&pFrame->m_Data.m_Pres.m_le_wSize, wPdoSize);
-
-                Ret = EplPdokCalAreTpdosValid(&fValid);
-                if (fValid != FALSE)
-                {
-                    // set TPDO valid
-                    bFrameData = AmiGetByteFromLe(&pFrame->m_Data.m_Pres.m_le_bFlag1);
-                    AmiSetByteToLe(&pFrame->m_Data.m_Pres.m_le_bFlag1, (bFrameData | EPL_FRAME_FLAG1_RD));
-                }
-
-                // processing finished successfully
-
-                goto Exit;
-            }
-            break;
-
-        case kEplEventTypePdoSoa: // SoA received
-
-            // invalidate TPDOs
-            Ret = EplPdokCalSetTpdosValid(FALSE);
-            break;
-
-        default:
-        {
-            ASSERTMSG(FALSE, "EplPdokProcess(): unhandled event type!\n");
-        }
-    }
+	tEplKernel Ret = kEplSuccessful;
+	WORD wPdoSize;
+	WORD wBitOffset;
+	WORD wBitSize;
+	WORD wVarSize;
+	QWORD qwObjectMapping;
+	BYTE bMappSubindex;
+	BYTE bObdSubindex;
+	WORD wObdMappIndex;
+	WORD wObdCommIndex;
+	WORD wPdoId;
+	BYTE bObdData;
+	BYTE bObjectCount;
+	BYTE bFrameData;
+	BOOL fValid;
+	tEplObdSize ObdSize;
+	tEplFrame *pFrame;
+	tEplFrameInfo *pFrameInfo;
+	unsigned int uiNodeId;
+	tEplMsgType MsgType;
+
+	// 0xFF=invalid, RPDO: 0x00=PReq, localNodeId=PRes, remoteNodeId=PRes
+	//               TPDO: 0x00=PRes, MN: CnNodeId=PReq
+
+	switch (pEvent_p->m_EventType) {
+	case kEplEventTypePdoRx:	// RPDO received
+		pFrame = (tEplFrame *) pEvent_p->m_pArg;
+
+		// check if received RPDO is valid
+		bFrameData =
+		    AmiGetByteFromLe(&pFrame->m_Data.m_Pres.m_le_bFlag1);
+		if ((bFrameData & EPL_FRAME_FLAG1_RD) == 0) {	// RPDO invalid
+			goto Exit;
+		}
+		// retrieve EPL message type
+		MsgType = AmiGetByteFromLe(&pFrame->m_le_bMessageType);
+		if (MsgType == kEplMsgTypePreq) {	// RPDO is PReq frame
+			uiNodeId = EPL_PDO_PREQ_NODE_ID;	// 0x00
+		} else {	// RPDO is PRes frame
+			// retrieve node ID
+			uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bSrcNodeId);
+		}
+
+		// search for appropriate valid RPDO in OD
+		wObdMappIndex = EPL_PDOK_OBD_IDX_RX_MAPP_PARAM;
+		for (wObdCommIndex = EPL_PDOK_OBD_IDX_RX_COMM_PARAM;
+		     wObdCommIndex < (EPL_PDOK_OBD_IDX_RX_COMM_PARAM + 0x00FF);
+		     wObdCommIndex++, wObdMappIndex++) {
+			ObdSize = 1;
+			// read node ID from OD
+			Ret =
+			    EplObdReadEntry(wObdCommIndex, 0x01, &bObdData,
+					    &ObdSize);
+			if ((Ret == kEplObdIndexNotExist)
+			    || (Ret == kEplObdSubindexNotExist)
+			    || (Ret == kEplObdIllegalPart)) {	// PDO does not exist; last PDO reached
+				Ret = kEplSuccessful;
+				goto Exit;
+			} else if (Ret != kEplSuccessful) {	// other fatal error occured
+				goto Exit;
+			}
+			// entry read successfully
+			if (bObdData != uiNodeId) {	// node ID does not equal - wrong PDO, try next PDO in OD
+				continue;
+			}
+			ObdSize = 1;
+			// read number of mapped objects from OD; this indicates if the PDO is valid
+			Ret =
+			    EplObdReadEntry(wObdMappIndex, 0x00, &bObjectCount,
+					    &ObdSize);
+			if ((Ret == kEplObdIndexNotExist)
+			    || (Ret == kEplObdSubindexNotExist)
+			    || (Ret == kEplObdIllegalPart)) {	// PDO does not exist; last PDO reached
+				Ret = kEplSuccessful;
+				goto Exit;
+			} else if (Ret != kEplSuccessful) {	// other fatal error occured
+				goto Exit;
+			}
+			// entry read successfully
+			if (bObjectCount == 0) {	// PDO in OD not valid, try next PDO in OD
+				continue;
+			}
+
+			ObdSize = 1;
+			// check PDO mapping version
+			Ret =
+			    EplObdReadEntry(wObdCommIndex, 0x02, &bObdData,
+					    &ObdSize);
+			if (Ret != kEplSuccessful) {	// other fatal error occured
+				goto Exit;
+			}
+			// entry read successfully
+			// retrieve PDO version from frame
+			bFrameData =
+			    AmiGetByteFromLe(&pFrame->m_Data.m_Pres.
+					     m_le_bPdoVersion);
+			if ((bObdData & EPL_VERSION_MAIN) != (bFrameData & EPL_VERSION_MAIN)) {	// PDO versions do not match
+				// $$$ raise PDO error
+				// termiate processing of this RPDO
+				goto Exit;
+			}
+			// valid RPDO found
+
+			// retrieve PDO size
+			wPdoSize =
+			    AmiGetWordFromLe(&pFrame->m_Data.m_Pres.m_le_wSize);
+
+			// process mapping
+			for (bMappSubindex = 1; bMappSubindex <= bObjectCount;
+			     bMappSubindex++) {
+				ObdSize = 8;	// QWORD
+				// read object mapping from OD
+				Ret =
+				    EplObdReadEntry(wObdMappIndex,
+						    bMappSubindex,
+						    &qwObjectMapping, &ObdSize);
+				if (Ret != kEplSuccessful) {	// other fatal error occured
+					goto Exit;
+				}
+				// check if object mapping entry is valid, i.e. unequal zero, because "empty" entries are allowed
+				if (qwObjectMapping == 0) {	// invalid entry, continue with next entry
+					continue;
+				}
+				// decode object mapping
+				wObdCommIndex =
+				    (WORD) (qwObjectMapping &
+					    0x000000000000FFFFLL);
+				bObdSubindex =
+				    (BYTE) ((qwObjectMapping &
+					     0x0000000000FF0000LL) >> 16);
+				wBitOffset =
+				    (WORD) ((qwObjectMapping &
+					     0x0000FFFF00000000LL) >> 32);
+				wBitSize =
+				    (WORD) ((qwObjectMapping &
+					     0xFFFF000000000000LL) >> 48);
+
+				// check if object exceeds PDO size
+				if (((wBitOffset + wBitSize) >> 3) > wPdoSize) {	// wrong object mapping; PDO size is too low
+					// $$$ raise PDO error
+					// terminate processing of this RPDO
+					goto Exit;
+				}
+				// copy object from RPDO to process/OD variable
+				ObdSize = wBitSize >> 3;
+				Ret =
+				    EplObdWriteEntryFromLe(wObdCommIndex,
+							   bObdSubindex,
+							   &pFrame->m_Data.
+							   m_Pres.
+							   m_le_abPayload[(wBitOffset >> 3)], ObdSize);
+				if (Ret != kEplSuccessful) {	// other fatal error occured
+					goto Exit;
+				}
+
+			}
+
+			// processing finished successfully
+			goto Exit;
+		}
+		break;
+
+	case kEplEventTypePdoTx:	// TPDO transmitted
+		pFrameInfo = (tEplFrameInfo *) pEvent_p->m_pArg;
+		pFrame = pFrameInfo->m_pFrame;
+
+		// set TPDO invalid, so that only fully processed TPDOs are sent as valid
+		bFrameData =
+		    AmiGetByteFromLe(&pFrame->m_Data.m_Pres.m_le_bFlag1);
+		AmiSetByteToLe(&pFrame->m_Data.m_Pres.m_le_bFlag1,
+			       (bFrameData & ~EPL_FRAME_FLAG1_RD));
+
+		// retrieve EPL message type
+		MsgType = AmiGetByteFromLe(&pFrame->m_le_bMessageType);
+		if (MsgType == kEplMsgTypePres) {	// TPDO is PRes frame
+			uiNodeId = EPL_PDO_PRES_NODE_ID;	// 0x00
+		} else {	// TPDO is PReq frame
+			// retrieve node ID
+			uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bDstNodeId);
+		}
+
+		// search for appropriate valid TPDO in OD
+		wObdMappIndex = EPL_PDOK_OBD_IDX_TX_MAPP_PARAM;
+		wObdCommIndex = EPL_PDOK_OBD_IDX_TX_COMM_PARAM;
+		for (wPdoId = 0;; wPdoId++, wObdCommIndex++, wObdMappIndex++) {
+			ObdSize = 1;
+			// read node ID from OD
+			Ret =
+			    EplObdReadEntry(wObdCommIndex, 0x01, &bObdData,
+					    &ObdSize);
+			if ((Ret == kEplObdIndexNotExist)
+			    || (Ret == kEplObdSubindexNotExist)
+			    || (Ret == kEplObdIllegalPart)) {	// PDO does not exist; last PDO reached
+				Ret = kEplSuccessful;
+				goto Exit;
+			} else if (Ret != kEplSuccessful) {	// other fatal error occured
+				goto Exit;
+			}
+			// entry read successfully
+			if (bObdData != uiNodeId) {	// node ID does not equal - wrong PDO, try next PDO in OD
+				continue;
+			}
+			ObdSize = 1;
+			// read number of mapped objects from OD; this indicates if the PDO is valid
+			Ret =
+			    EplObdReadEntry(wObdMappIndex, 0x00, &bObjectCount,
+					    &ObdSize);
+			if ((Ret == kEplObdIndexNotExist)
+			    || (Ret == kEplObdSubindexNotExist)
+			    || (Ret == kEplObdIllegalPart)) {	// PDO does not exist; last PDO reached
+				Ret = kEplSuccessful;
+				goto Exit;
+			} else if (Ret != kEplSuccessful) {	// other fatal error occured
+				goto Exit;
+			}
+			// entry read successfully
+			if (bObjectCount == 0) {	// PDO in OD not valid, try next PDO in OD
+				continue;
+			}
+			// valid TPDO found
+
+			ObdSize = 1;
+			// get PDO mapping version from OD
+			Ret =
+			    EplObdReadEntry(wObdCommIndex, 0x02, &bObdData,
+					    &ObdSize);
+			if (Ret != kEplSuccessful) {	// other fatal error occured
+				goto Exit;
+			}
+			// entry read successfully
+			// set PDO version in frame
+			AmiSetByteToLe(&pFrame->m_Data.m_Pres.m_le_bPdoVersion,
+				       bObdData);
+
+			// calculate PDO size
+			wPdoSize = 0;
+
+			// process mapping
+			for (bMappSubindex = 1; bMappSubindex <= bObjectCount;
+			     bMappSubindex++) {
+				ObdSize = 8;	// QWORD
+				// read object mapping from OD
+				Ret =
+				    EplObdReadEntry(wObdMappIndex,
+						    bMappSubindex,
+						    &qwObjectMapping, &ObdSize);
+				if (Ret != kEplSuccessful) {	// other fatal error occured
+					goto Exit;
+				}
+				// check if object mapping entry is valid, i.e. unequal zero, because "empty" entries are allowed
+				if (qwObjectMapping == 0) {	// invalid entry, continue with next entry
+					continue;
+				}
+				// decode object mapping
+				wObdCommIndex =
+				    (WORD) (qwObjectMapping &
+					    0x000000000000FFFFLL);
+				bObdSubindex =
+				    (BYTE) ((qwObjectMapping &
+					     0x0000000000FF0000LL) >> 16);
+				wBitOffset =
+				    (WORD) ((qwObjectMapping &
+					     0x0000FFFF00000000LL) >> 32);
+				wBitSize =
+				    (WORD) ((qwObjectMapping &
+					     0xFFFF000000000000LL) >> 48);
+
+				// calculate max PDO size
+				ObdSize = wBitSize >> 3;
+				wVarSize = (wBitOffset >> 3) + (WORD) ObdSize;
+				if ((unsigned int)(wVarSize + 24) > pFrameInfo->m_uiFrameSize) {	// TPDO is too short
+					// $$$ raise PDO error, set Ret
+					goto Exit;
+				}
+				if (wVarSize > wPdoSize) {	// memorize new PDO size
+					wPdoSize = wVarSize;
+				}
+				// copy object from process/OD variable to TPDO
+				Ret =
+				    EplObdReadEntryToLe(wObdCommIndex,
+							bObdSubindex,
+							&pFrame->m_Data.m_Pres.
+							m_le_abPayload[(wBitOffset >> 3)], &ObdSize);
+				if (Ret != kEplSuccessful) {	// other fatal error occured
+					goto Exit;
+				}
+
+			}
+
+			// set PDO size in frame
+			AmiSetWordToLe(&pFrame->m_Data.m_Pres.m_le_wSize,
+				       wPdoSize);
+
+			Ret = EplPdokCalAreTpdosValid(&fValid);
+			if (fValid != FALSE) {
+				// set TPDO valid
+				bFrameData =
+				    AmiGetByteFromLe(&pFrame->m_Data.m_Pres.
+						     m_le_bFlag1);
+				AmiSetByteToLe(&pFrame->m_Data.m_Pres.
+					       m_le_bFlag1,
+					       (bFrameData |
+						EPL_FRAME_FLAG1_RD));
+			}
+			// processing finished successfully
+
+			goto Exit;
+		}
+		break;
+
+	case kEplEventTypePdoSoa:	// SoA received
+
+		// invalidate TPDOs
+		Ret = EplPdokCalSetTpdosValid(FALSE);
+		break;
+
+	default:
+		{
+			ASSERTMSG(FALSE,
+				  "EplPdokProcess(): unhandled event type!\n");
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //=========================================================================//
@@ -689,4 +692,3 @@ Exit:
 #endif // #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
 
 // EOF
-
--- a/drivers/staging/epl/EplPdokCal.c
+++ b/drivers/staging/epl/EplPdokCal.c
@@ -72,7 +72,6 @@
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOK)) != 0)
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -97,7 +96,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -111,7 +109,6 @@
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -126,9 +123,8 @@
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    BOOL            m_fTpdosValid;
+typedef struct {
+	BOOL m_fTpdosValid;
 
 } tEplPdokCalInstance;
 
@@ -136,13 +132,12 @@ typedef struct
 // local vars
 //---------------------------------------------------------------------------
 
-static tEplPdokCalInstance  EplPdokCalInstance_g;
+static tEplPdokCalInstance EplPdokCalInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -167,9 +162,9 @@ static tEplPdokCalInstance  EplPdokCalIn
 tEplKernel EplPdokCalAddInstance(void)
 {
 
-    EPL_MEMSET(&EplPdokCalInstance_g, 0, sizeof(EplPdokCalInstance_g));
+	EPL_MEMSET(&EplPdokCalInstance_g, 0, sizeof(EplPdokCalInstance_g));
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 }
 
 //---------------------------------------------------------------------------
@@ -190,10 +185,9 @@ tEplKernel EplPdokCalAddInstance(void)
 tEplKernel EplPdokCalDelInstance(void)
 {
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplPdokCalSetTpdosValid()
@@ -212,11 +206,11 @@ tEplKernel EplPdokCalDelInstance(void)
 
 tEplKernel EplPdokCalSetTpdosValid(BOOL fValid_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    EplPdokCalInstance_g.m_fTpdosValid = fValid_p;
+	EplPdokCalInstance_g.m_fTpdosValid = fValid_p;
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -236,14 +230,13 @@ tEplKernel      Ret = kEplSuccessful;
 
 tEplKernel EplPdokCalAreTpdosValid(BOOL * pfValid_p)
 {
-tEplKernel      Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    *pfValid_p = EplPdokCalInstance_g.m_fTpdosValid;
+	*pfValid_p = EplPdokCalInstance_g.m_fTpdosValid;
 
-    return Ret;
+	return Ret;
 }
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -271,4 +264,3 @@ tEplKernel      Ret = kEplSuccessful;
 #endif
 
 // EOF
-
--- a/drivers/staging/epl/EplPdou.c
+++ b/drivers/staging/epl/EplPdou.c
@@ -82,7 +82,6 @@
 #error "EPL PDOu module needs EPL module OBDU or OBDK!"
 #endif
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -103,7 +102,6 @@
 #define EPL_PDOU_OBD_IDX_MASK           0xFF00
 #define EPL_PDOU_PDO_ID_MASK            0x00FF
 
-
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
@@ -116,7 +114,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -130,7 +127,6 @@
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -149,25 +145,23 @@
 // local vars
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-static tEplKernel EplPdouCheckPdoValidity(tEplObdCbParam MEM* pParam_p, unsigned int uiIndex_p);
+static tEplKernel EplPdouCheckPdoValidity(tEplObdCbParam MEM * pParam_p,
+					  unsigned int uiIndex_p);
 
 static void EplPdouDecodeObjectMapping(QWORD qwObjectMapping_p,
-                                    unsigned int* puiIndex_p,
-                                    unsigned int* puiSubIndex_p,
-                                    unsigned int* puiBitOffset_p,
-                                    unsigned int* puiBitSize_p);
+				       unsigned int *puiIndex_p,
+				       unsigned int *puiSubIndex_p,
+				       unsigned int *puiBitOffset_p,
+				       unsigned int *puiBitSize_p);
 
 static tEplKernel EplPdouCheckObjectMapping(QWORD qwObjectMapping_p,
-                                       tEplObdAccess AccessType_p,
-                                       DWORD* pdwAbortCode_p,
-                                       unsigned int* puiPdoSize_p);
-
-
+					    tEplObdAccess AccessType_p,
+					    DWORD * pdwAbortCode_p,
+					    unsigned int *puiPdoSize_p);
 
 //=========================================================================//
 //                                                                         //
@@ -193,10 +187,9 @@ static tEplKernel EplPdouCheckObjectMapp
 tEplKernel EplPdouAddInstance(void)
 {
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplPdouDelInstance()
@@ -215,10 +208,9 @@ tEplKernel EplPdouAddInstance(void)
 tEplKernel EplPdouDelInstance(void)
 {
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplPdouCbObdAccess
@@ -234,170 +226,153 @@ tEplKernel EplPdouDelInstance(void)
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplPdouCbObdAccess(tEplObdCbParam MEM* pParam_p)
+tEplKernel PUBLIC EplPdouCbObdAccess(tEplObdCbParam MEM * pParam_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-unsigned int        uiPdoId;
-unsigned int        uiIndexType;
-tEplObdSize         ObdSize;
-BYTE                bObjectCount;
-QWORD               qwObjectMapping;
-tEplObdAccess       AccessType;
-BYTE                bMappSubindex;
-unsigned int        uiCurPdoSize;
-WORD                wMaxPdoSize;
-unsigned int        uiSubIndex;
-
-    // fetch PDO ID
-    uiPdoId = pParam_p->m_uiIndex & EPL_PDOU_PDO_ID_MASK;
-
-    // fetch object index type
-    uiIndexType = pParam_p->m_uiIndex & EPL_PDOU_OBD_IDX_MASK;
-
-    if (pParam_p->m_ObdEvent != kEplObdEvPreWrite)
-    {   // read accesses, post write events etc. are OK
-        pParam_p->m_dwAbortCode = 0;
-        goto Exit;
-    }
-
-    // check index type
-    switch (uiIndexType)
-    {
-        case EPL_PDOU_OBD_IDX_RX_COMM_PARAM:
-            // RPDO communication parameter accessed
-        case EPL_PDOU_OBD_IDX_TX_COMM_PARAM:
-        {   // TPDO communication parameter accessed
-            Ret = EplPdouCheckPdoValidity(pParam_p,
-                    (EPL_PDOU_OBD_IDX_MAPP_PARAM | pParam_p->m_uiIndex));
-            if (Ret != kEplSuccessful)
-            {   // PDO is valid or does not exist
-                goto Exit;
-            }
-
-            goto Exit;
-        }
-
-        case EPL_PDOU_OBD_IDX_RX_MAPP_PARAM:
-        {   // RPDO mapping parameter accessed
-
-            AccessType = kEplObdAccWrite;
-            break;
-        }
-
-        case EPL_PDOU_OBD_IDX_TX_MAPP_PARAM:
-        {   // TPDO mapping parameter accessed
-
-            AccessType = kEplObdAccRead;
-            break;
-        }
-
-        default:
-        {   // this callback function is only for
-            // PDO mapping and communication parameters
-            pParam_p->m_dwAbortCode = EPL_SDOAC_GENERAL_ERROR;
-            goto Exit;
-        }
-    }
-
-    // RPDO and TPDO mapping parameter accessed
-
-    if (pParam_p->m_uiSubIndex == 0)
-    {   // object mapping count accessed
-
-        // PDO is enabled or disabled
-        bObjectCount = *((BYTE*) pParam_p->m_pArg);
-
-        if (bObjectCount == 0)
-        {   // PDO shall be disabled
-
-            // that is always possible
-            goto Exit;
-        }
-
-        // PDO shall be enabled
-        // it should have been disabled for this operation
-        Ret = EplPdouCheckPdoValidity(pParam_p, pParam_p->m_uiIndex);
-        if (Ret != kEplSuccessful)
-        {   // PDO is valid or does not exist
-            goto Exit;
-        }
-
-        if (AccessType == kEplObdAccWrite)
-        {
-            uiSubIndex = 0x04;  // PReqActPayloadLimit_U16
-        }
-        else
-        {
-            uiSubIndex = 0x05;  // PResActPayloadLimit_U16
-        }
-
-        // fetch maximum PDO size from Object 1F98h: NMT_CycleTiming_REC
-        ObdSize = sizeof (wMaxPdoSize);
-        Ret = EplObduReadEntry(0x1F98, uiSubIndex, &wMaxPdoSize, &ObdSize);
-        if (Ret != kEplSuccessful)
-        {   // other fatal error occured
-            pParam_p->m_dwAbortCode = EPL_SDOAC_GENERAL_ERROR;
-            goto Exit;
-        }
-
-        // check all objectmappings
-        for (bMappSubindex = 1; bMappSubindex <= bObjectCount; bMappSubindex++)
-        {
-            // read object mapping from OD
-            ObdSize = sizeof (qwObjectMapping); // QWORD
-            Ret = EplObduReadEntry(pParam_p->m_uiIndex,
-                                bMappSubindex, &qwObjectMapping, &ObdSize);
-            if (Ret != kEplSuccessful)
-            {   // other fatal error occured
-                pParam_p->m_dwAbortCode = EPL_SDOAC_GENERAL_ERROR;
-                goto Exit;
-            }
-
-            // check object mapping
-            Ret = EplPdouCheckObjectMapping(qwObjectMapping,
-                                   AccessType,
-                                   &pParam_p->m_dwAbortCode,
-                                   &uiCurPdoSize);
-            if (Ret != kEplSuccessful)
-            {   // illegal object mapping
-                goto Exit;
-            }
-
-            if (uiCurPdoSize > wMaxPdoSize)
-            {   // mapping exceeds object size
-                pParam_p->m_dwAbortCode = EPL_SDOAC_GENERAL_ERROR;
-                Ret = kEplPdoVarNotFound;
-            }
-
-
-        }
-
-    }
-    else
-    {   // ObjectMapping
-        Ret = EplPdouCheckPdoValidity(pParam_p, pParam_p->m_uiIndex);
-        if (Ret != kEplSuccessful)
-        {   // PDO is valid or does not exist
-            goto Exit;
-        }
-
-        // check existence of object and validity of object length
-
-        qwObjectMapping = *((QWORD*) pParam_p->m_pArg);
-
-        Ret = EplPdouCheckObjectMapping(qwObjectMapping,
-                               AccessType,
-                               &pParam_p->m_dwAbortCode,
-                               &uiCurPdoSize);
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiPdoId;
+	unsigned int uiIndexType;
+	tEplObdSize ObdSize;
+	BYTE bObjectCount;
+	QWORD qwObjectMapping;
+	tEplObdAccess AccessType;
+	BYTE bMappSubindex;
+	unsigned int uiCurPdoSize;
+	WORD wMaxPdoSize;
+	unsigned int uiSubIndex;
+
+	// fetch PDO ID
+	uiPdoId = pParam_p->m_uiIndex & EPL_PDOU_PDO_ID_MASK;
+
+	// fetch object index type
+	uiIndexType = pParam_p->m_uiIndex & EPL_PDOU_OBD_IDX_MASK;
+
+	if (pParam_p->m_ObdEvent != kEplObdEvPreWrite) {	// read accesses, post write events etc. are OK
+		pParam_p->m_dwAbortCode = 0;
+		goto Exit;
+	}
+	// check index type
+	switch (uiIndexType) {
+	case EPL_PDOU_OBD_IDX_RX_COMM_PARAM:
+		// RPDO communication parameter accessed
+	case EPL_PDOU_OBD_IDX_TX_COMM_PARAM:
+		{		// TPDO communication parameter accessed
+			Ret = EplPdouCheckPdoValidity(pParam_p,
+						      (EPL_PDOU_OBD_IDX_MAPP_PARAM
+						       | pParam_p->m_uiIndex));
+			if (Ret != kEplSuccessful) {	// PDO is valid or does not exist
+				goto Exit;
+			}
+
+			goto Exit;
+		}
+
+	case EPL_PDOU_OBD_IDX_RX_MAPP_PARAM:
+		{		// RPDO mapping parameter accessed
+
+			AccessType = kEplObdAccWrite;
+			break;
+		}
+
+	case EPL_PDOU_OBD_IDX_TX_MAPP_PARAM:
+		{		// TPDO mapping parameter accessed
+
+			AccessType = kEplObdAccRead;
+			break;
+		}
+
+	default:
+		{		// this callback function is only for
+			// PDO mapping and communication parameters
+			pParam_p->m_dwAbortCode = EPL_SDOAC_GENERAL_ERROR;
+			goto Exit;
+		}
+	}
+
+	// RPDO and TPDO mapping parameter accessed
+
+	if (pParam_p->m_uiSubIndex == 0) {	// object mapping count accessed
+
+		// PDO is enabled or disabled
+		bObjectCount = *((BYTE *) pParam_p->m_pArg);
+
+		if (bObjectCount == 0) {	// PDO shall be disabled
+
+			// that is always possible
+			goto Exit;
+		}
+		// PDO shall be enabled
+		// it should have been disabled for this operation
+		Ret = EplPdouCheckPdoValidity(pParam_p, pParam_p->m_uiIndex);
+		if (Ret != kEplSuccessful) {	// PDO is valid or does not exist
+			goto Exit;
+		}
+
+		if (AccessType == kEplObdAccWrite) {
+			uiSubIndex = 0x04;	// PReqActPayloadLimit_U16
+		} else {
+			uiSubIndex = 0x05;	// PResActPayloadLimit_U16
+		}
+
+		// fetch maximum PDO size from Object 1F98h: NMT_CycleTiming_REC
+		ObdSize = sizeof(wMaxPdoSize);
+		Ret =
+		    EplObduReadEntry(0x1F98, uiSubIndex, &wMaxPdoSize,
+				     &ObdSize);
+		if (Ret != kEplSuccessful) {	// other fatal error occured
+			pParam_p->m_dwAbortCode = EPL_SDOAC_GENERAL_ERROR;
+			goto Exit;
+		}
+		// check all objectmappings
+		for (bMappSubindex = 1; bMappSubindex <= bObjectCount;
+		     bMappSubindex++) {
+			// read object mapping from OD
+			ObdSize = sizeof(qwObjectMapping);	// QWORD
+			Ret = EplObduReadEntry(pParam_p->m_uiIndex,
+					       bMappSubindex, &qwObjectMapping,
+					       &ObdSize);
+			if (Ret != kEplSuccessful) {	// other fatal error occured
+				pParam_p->m_dwAbortCode =
+				    EPL_SDOAC_GENERAL_ERROR;
+				goto Exit;
+			}
+			// check object mapping
+			Ret = EplPdouCheckObjectMapping(qwObjectMapping,
+							AccessType,
+							&pParam_p->
+							m_dwAbortCode,
+							&uiCurPdoSize);
+			if (Ret != kEplSuccessful) {	// illegal object mapping
+				goto Exit;
+			}
+
+			if (uiCurPdoSize > wMaxPdoSize) {	// mapping exceeds object size
+				pParam_p->m_dwAbortCode =
+				    EPL_SDOAC_GENERAL_ERROR;
+				Ret = kEplPdoVarNotFound;
+			}
+
+		}
+
+	} else {		// ObjectMapping
+		Ret = EplPdouCheckPdoValidity(pParam_p, pParam_p->m_uiIndex);
+		if (Ret != kEplSuccessful) {	// PDO is valid or does not exist
+			goto Exit;
+		}
+		// check existence of object and validity of object length
+
+		qwObjectMapping = *((QWORD *) pParam_p->m_pArg);
+
+		Ret = EplPdouCheckObjectMapping(qwObjectMapping,
+						AccessType,
+						&pParam_p->m_dwAbortCode,
+						&uiCurPdoSize);
 
-    }
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -419,33 +394,32 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-static tEplKernel EplPdouCheckPdoValidity(tEplObdCbParam MEM* pParam_p, unsigned int uiIndex_p)
+static tEplKernel EplPdouCheckPdoValidity(tEplObdCbParam MEM * pParam_p,
+					  unsigned int uiIndex_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplObdSize         ObdSize;
-BYTE                bObjectCount;
-
-    ObdSize = 1;
-    // read number of mapped objects from OD; this indicates if the PDO is valid
-    Ret = EplObduReadEntry(uiIndex_p, 0x00, &bObjectCount, &ObdSize);
-    if (Ret != kEplSuccessful)
-    {   // other fatal error occured
-        pParam_p->m_dwAbortCode = EPL_SDOAC_GEN_INTERNAL_INCOMPATIBILITY;
-        goto Exit;
-    }
-    // entry read successfully
-    if (bObjectCount != 0)
-    {   // PDO in OD is still valid
-        pParam_p->m_dwAbortCode = EPL_SDOAC_GEN_PARAM_INCOMPATIBILITY;
-        Ret = kEplPdoNotExist;
-        goto Exit;
-    }
+	tEplKernel Ret = kEplSuccessful;
+	tEplObdSize ObdSize;
+	BYTE bObjectCount;
+
+	ObdSize = 1;
+	// read number of mapped objects from OD; this indicates if the PDO is valid
+	Ret = EplObduReadEntry(uiIndex_p, 0x00, &bObjectCount, &ObdSize);
+	if (Ret != kEplSuccessful) {	// other fatal error occured
+		pParam_p->m_dwAbortCode =
+		    EPL_SDOAC_GEN_INTERNAL_INCOMPATIBILITY;
+		goto Exit;
+	}
+	// entry read successfully
+	if (bObjectCount != 0) {	// PDO in OD is still valid
+		pParam_p->m_dwAbortCode = EPL_SDOAC_GEN_PARAM_INCOMPATIBILITY;
+		Ret = kEplPdoNotExist;
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplPdouDecodeObjectMapping
@@ -466,26 +440,25 @@ Exit:
 //---------------------------------------------------------------------------
 
 static void EplPdouDecodeObjectMapping(QWORD qwObjectMapping_p,
-                                    unsigned int* puiIndex_p,
-                                    unsigned int* puiSubIndex_p,
-                                    unsigned int* puiBitOffset_p,
-                                    unsigned int* puiBitSize_p)
+				       unsigned int *puiIndex_p,
+				       unsigned int *puiSubIndex_p,
+				       unsigned int *puiBitOffset_p,
+				       unsigned int *puiBitSize_p)
 {
-    *puiIndex_p = (unsigned int)
-                    (qwObjectMapping_p & 0x000000000000FFFFLL);
+	*puiIndex_p = (unsigned int)
+	    (qwObjectMapping_p & 0x000000000000FFFFLL);
 
-    *puiSubIndex_p = (unsigned int)
-                    ((qwObjectMapping_p & 0x0000000000FF0000LL) >> 16);
+	*puiSubIndex_p = (unsigned int)
+	    ((qwObjectMapping_p & 0x0000000000FF0000LL) >> 16);
 
-    *puiBitOffset_p = (unsigned int)
-                    ((qwObjectMapping_p & 0x0000FFFF00000000LL) >> 32);
+	*puiBitOffset_p = (unsigned int)
+	    ((qwObjectMapping_p & 0x0000FFFF00000000LL) >> 32);
 
-    *puiBitSize_p = (unsigned int)
-                    ((qwObjectMapping_p & 0xFFFF000000000000LL) >> 48);
+	*puiBitSize_p = (unsigned int)
+	    ((qwObjectMapping_p & 0xFFFF000000000000LL) >> 48);
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplPdouCheckObjectMapping
@@ -508,101 +481,85 @@ static void EplPdouDecodeObjectMapping(Q
 //---------------------------------------------------------------------------
 
 static tEplKernel EplPdouCheckObjectMapping(QWORD qwObjectMapping_p,
-                                       tEplObdAccess AccessType_p,
-                                       DWORD* pdwAbortCode_p,
-                                       unsigned int* puiPdoSize_p)
+					    tEplObdAccess AccessType_p,
+					    DWORD * pdwAbortCode_p,
+					    unsigned int *puiPdoSize_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplObdSize         ObdSize;
-unsigned int        uiIndex;
-unsigned int        uiSubIndex;
-unsigned int        uiBitOffset;
-unsigned int        uiBitSize;
-tEplObdAccess       AccessType;
-BOOL                fNumerical;
-
-    if (qwObjectMapping_p == 0)
-    {   // discard zero value
-        *puiPdoSize_p = 0;
-        goto Exit;
-    }
-
-    // decode object mapping
-    EplPdouDecodeObjectMapping(qwObjectMapping_p,
-                               &uiIndex,
-                               &uiSubIndex,
-                               &uiBitOffset,
-                               &uiBitSize);
-
-    if ((uiBitOffset & 0x7) != 0x0)
-    {   // bit mapping is not supported
-        *pdwAbortCode_p = EPL_SDOAC_GENERAL_ERROR;
-        Ret = kEplPdoGranularityMismatch;
-        goto Exit;
-    }
-
-    if ((uiBitSize & 0x7) != 0x0)
-    {   // bit mapping is not supported
-        *pdwAbortCode_p = EPL_SDOAC_GENERAL_ERROR;
-        Ret = kEplPdoGranularityMismatch;
-        goto Exit;
-    }
-
-    // check access type
-    Ret = EplObduGetAccessType(uiIndex, uiSubIndex, &AccessType);
-    if (Ret != kEplSuccessful)
-    {   // entry doesn't exist
-        *pdwAbortCode_p = EPL_SDOAC_OBJECT_NOT_EXIST;
-        goto Exit;
-    }
-
-    if ((AccessType & kEplObdAccPdo) == 0)
-    {   // object is not mappable
-        *pdwAbortCode_p = EPL_SDOAC_OBJECT_NOT_MAPPABLE;
-        Ret = kEplPdoVarNotFound;
-        goto Exit;
-    }
-
-    if ((AccessType & AccessType_p) == 0)
-    {   // object is not writeable (RPDO) or readable (TPDO) respectively
-        *pdwAbortCode_p = EPL_SDOAC_OBJECT_NOT_MAPPABLE;
-        Ret = kEplPdoVarNotFound;
-        goto Exit;
-    }
-
-    ObdSize = EplObduGetDataSize(uiIndex, uiSubIndex);
-    if (ObdSize < (uiBitSize >> 3))
-    {   // object does not exist or has smaller size
-        *pdwAbortCode_p = EPL_SDOAC_GENERAL_ERROR;
-        Ret = kEplPdoVarNotFound;
-    }
-
-    Ret = EplObduIsNumerical(uiIndex, uiSubIndex, &fNumerical);
-    if (Ret != kEplSuccessful)
-    {   // entry doesn't exist
-        *pdwAbortCode_p = EPL_SDOAC_OBJECT_NOT_EXIST;
-        goto Exit;
-    }
-
-    if ((fNumerical != FALSE)
-        && ((uiBitSize >> 3) != ObdSize))
-    {
-        // object is numerical,
-        // therefor size has to fit, but it does not.
-        *pdwAbortCode_p = EPL_SDOAC_GENERAL_ERROR;
-        Ret = kEplPdoVarNotFound;
-        goto Exit;
-    }
-
-    // calucaled needed PDO size
-    *puiPdoSize_p = (uiBitOffset >> 3) + (uiBitSize >> 3);
+	tEplKernel Ret = kEplSuccessful;
+	tEplObdSize ObdSize;
+	unsigned int uiIndex;
+	unsigned int uiSubIndex;
+	unsigned int uiBitOffset;
+	unsigned int uiBitSize;
+	tEplObdAccess AccessType;
+	BOOL fNumerical;
+
+	if (qwObjectMapping_p == 0) {	// discard zero value
+		*puiPdoSize_p = 0;
+		goto Exit;
+	}
+	// decode object mapping
+	EplPdouDecodeObjectMapping(qwObjectMapping_p,
+				   &uiIndex,
+				   &uiSubIndex, &uiBitOffset, &uiBitSize);
+
+	if ((uiBitOffset & 0x7) != 0x0) {	// bit mapping is not supported
+		*pdwAbortCode_p = EPL_SDOAC_GENERAL_ERROR;
+		Ret = kEplPdoGranularityMismatch;
+		goto Exit;
+	}
+
+	if ((uiBitSize & 0x7) != 0x0) {	// bit mapping is not supported
+		*pdwAbortCode_p = EPL_SDOAC_GENERAL_ERROR;
+		Ret = kEplPdoGranularityMismatch;
+		goto Exit;
+	}
+	// check access type
+	Ret = EplObduGetAccessType(uiIndex, uiSubIndex, &AccessType);
+	if (Ret != kEplSuccessful) {	// entry doesn't exist
+		*pdwAbortCode_p = EPL_SDOAC_OBJECT_NOT_EXIST;
+		goto Exit;
+	}
+
+	if ((AccessType & kEplObdAccPdo) == 0) {	// object is not mappable
+		*pdwAbortCode_p = EPL_SDOAC_OBJECT_NOT_MAPPABLE;
+		Ret = kEplPdoVarNotFound;
+		goto Exit;
+	}
+
+	if ((AccessType & AccessType_p) == 0) {	// object is not writeable (RPDO) or readable (TPDO) respectively
+		*pdwAbortCode_p = EPL_SDOAC_OBJECT_NOT_MAPPABLE;
+		Ret = kEplPdoVarNotFound;
+		goto Exit;
+	}
+
+	ObdSize = EplObduGetDataSize(uiIndex, uiSubIndex);
+	if (ObdSize < (uiBitSize >> 3)) {	// object does not exist or has smaller size
+		*pdwAbortCode_p = EPL_SDOAC_GENERAL_ERROR;
+		Ret = kEplPdoVarNotFound;
+	}
+
+	Ret = EplObduIsNumerical(uiIndex, uiSubIndex, &fNumerical);
+	if (Ret != kEplSuccessful) {	// entry doesn't exist
+		*pdwAbortCode_p = EPL_SDOAC_OBJECT_NOT_EXIST;
+		goto Exit;
+	}
+
+	if ((fNumerical != FALSE)
+	    && ((uiBitSize >> 3) != ObdSize)) {
+		// object is numerical,
+		// therefor size has to fit, but it does not.
+		*pdwAbortCode_p = EPL_SDOAC_GENERAL_ERROR;
+		Ret = kEplPdoVarNotFound;
+		goto Exit;
+	}
+	// calucaled needed PDO size
+	*puiPdoSize_p = (uiBitOffset >> 3) + (uiBitSize >> 3);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 #endif // #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_PDOU)) != 0)
 
 // EOF
-
--- a/drivers/staging/epl/EplSdoAsndu.c
+++ b/drivers/staging/epl/EplSdoAsndu.c
@@ -94,11 +94,9 @@
 //---------------------------------------------------------------------------
 
 // instance table
-typedef struct
-{
-    unsigned int            m_auiSdoAsndConnection[EPL_SDO_MAX_CONNECTION_ASND];
-    tEplSequLayerReceiveCb  m_fpSdoAsySeqCb;
-
+typedef struct {
+	unsigned int m_auiSdoAsndConnection[EPL_SDO_MAX_CONNECTION_ASND];
+	tEplSequLayerReceiveCb m_fpSdoAsySeqCb;
 
 } tEplSdoAsndInstance;
 
@@ -106,7 +104,7 @@ typedef struct
 // modul globale vars
 //---------------------------------------------------------------------------
 
-static tEplSdoAsndInstance  SdoAsndInstance_g;
+static tEplSdoAsndInstance SdoAsndInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
@@ -127,8 +125,6 @@ tEplKernel PUBLIC EplSdoAsnduCb(tEplFram
 //
 /***************************************************************************/
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -155,15 +151,13 @@ tEplKernel PUBLIC EplSdoAsnduCb(tEplFram
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoAsnduInit(tEplSequLayerReceiveCb fpReceiveCb_p)
 {
-tEplKernel  Ret;
-
+	tEplKernel Ret;
 
-    Ret = EplSdoAsnduAddInstance(fpReceiveCb_p);
+	Ret = EplSdoAsnduAddInstance(fpReceiveCb_p);
 
-return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplSdoAsnduAddInstance
@@ -184,30 +178,26 @@ return Ret;
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoAsnduAddInstance(tEplSequLayerReceiveCb fpReceiveCb_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // init control structure
-    EPL_MEMSET(&SdoAsndInstance_g, 0x00, sizeof(SdoAsndInstance_g));
+	// init control structure
+	EPL_MEMSET(&SdoAsndInstance_g, 0x00, sizeof(SdoAsndInstance_g));
 
-    // save pointer to callback-function
-    if (fpReceiveCb_p != NULL)
-    {
-        SdoAsndInstance_g.m_fpSdoAsySeqCb = fpReceiveCb_p;
-    }
-    else
-    {
-        Ret = kEplSdoUdpMissCb;
-    }
+	// save pointer to callback-function
+	if (fpReceiveCb_p != NULL) {
+		SdoAsndInstance_g.m_fpSdoAsySeqCb = fpReceiveCb_p;
+	} else {
+		Ret = kEplSdoUdpMissCb;
+	}
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
-    Ret = EplDlluCalRegAsndService(kEplDllAsndSdo,
-                                   EplSdoAsnduCb,
-                                   kEplDllAsndFilterLocal);
+	Ret = EplDlluCalRegAsndService(kEplDllAsndSdo,
+				       EplSdoAsnduCb, kEplDllAsndFilterLocal);
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -230,21 +220,19 @@ tEplKernel  Ret;
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoAsnduDelInstance()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
-    // deregister callback function from DLL
-    Ret = EplDlluCalRegAsndService(kEplDllAsndSdo,
-                                   NULL,
-                                   kEplDllAsndFilterNone);
+	// deregister callback function from DLL
+	Ret = EplDlluCalRegAsndService(kEplDllAsndSdo,
+				       NULL, kEplDllAsndFilterNone);
 #endif
 
-return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplSdoAsnduInitCon
@@ -263,61 +251,53 @@ return Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoAsnduInitCon(tEplSdoConHdl*  pSdoConHandle_p,
-                               unsigned int    uiTargetNodeId_p)
+tEplKernel PUBLIC EplSdoAsnduInitCon(tEplSdoConHdl * pSdoConHandle_p,
+				     unsigned int uiTargetNodeId_p)
 {
-tEplKernel      Ret;
-unsigned int    uiCount;
-unsigned int    uiFreeCon;
-unsigned int*   puiConnection;
-
-    Ret = kEplSuccessful;
-
-    if ((uiTargetNodeId_p == EPL_C_ADR_INVALID)
-        || (uiTargetNodeId_p >= EPL_C_ADR_BROADCAST))
-    {
-        Ret = kEplSdoAsndInvalidNodeId;
-        goto Exit;
-    }
-
-    // get free entry in control structure
-    uiCount = 0;
-    uiFreeCon = EPL_SDO_MAX_CONNECTION_ASND;
-    puiConnection = &SdoAsndInstance_g.m_auiSdoAsndConnection[0];
-    while(uiCount < EPL_SDO_MAX_CONNECTION_ASND)
-    {
-        if (*puiConnection == uiTargetNodeId_p)
-        {   // existing connection to target node found
-            // save handle for higher layer
-            *pSdoConHandle_p = (uiCount | EPL_SDO_ASND_HANDLE );
-
-            goto Exit;
-        }
-        else if (*puiConnection == 0)
-        {   // free entry-> save target nodeId
-            uiFreeCon = uiCount;
-        }
-        uiCount++;
-        puiConnection++;
-    }
-
-    if (uiFreeCon == EPL_SDO_MAX_CONNECTION_ASND)
-    {
-        // no free connection
-        Ret = kEplSdoAsndNoFreeHandle;
-    }
-    else
-    {
-        puiConnection = &SdoAsndInstance_g.m_auiSdoAsndConnection[uiFreeCon];
-        *puiConnection = uiTargetNodeId_p;
-        // save handle for higher layer
-        *pSdoConHandle_p = (uiFreeCon | EPL_SDO_ASND_HANDLE );
+	tEplKernel Ret;
+	unsigned int uiCount;
+	unsigned int uiFreeCon;
+	unsigned int *puiConnection;
+
+	Ret = kEplSuccessful;
+
+	if ((uiTargetNodeId_p == EPL_C_ADR_INVALID)
+	    || (uiTargetNodeId_p >= EPL_C_ADR_BROADCAST)) {
+		Ret = kEplSdoAsndInvalidNodeId;
+		goto Exit;
+	}
+	// get free entry in control structure
+	uiCount = 0;
+	uiFreeCon = EPL_SDO_MAX_CONNECTION_ASND;
+	puiConnection = &SdoAsndInstance_g.m_auiSdoAsndConnection[0];
+	while (uiCount < EPL_SDO_MAX_CONNECTION_ASND) {
+		if (*puiConnection == uiTargetNodeId_p) {	// existing connection to target node found
+			// save handle for higher layer
+			*pSdoConHandle_p = (uiCount | EPL_SDO_ASND_HANDLE);
+
+			goto Exit;
+		} else if (*puiConnection == 0) {	// free entry-> save target nodeId
+			uiFreeCon = uiCount;
+		}
+		uiCount++;
+		puiConnection++;
+	}
+
+	if (uiFreeCon == EPL_SDO_MAX_CONNECTION_ASND) {
+		// no free connection
+		Ret = kEplSdoAsndNoFreeHandle;
+	} else {
+		puiConnection =
+		    &SdoAsndInstance_g.m_auiSdoAsndConnection[uiFreeCon];
+		*puiConnection = uiTargetNodeId_p;
+		// save handle for higher layer
+		*pSdoConHandle_p = (uiFreeCon | EPL_SDO_ASND_HANDLE);
 
-        goto Exit;
-    }
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -339,47 +319,47 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoAsnduSendData(tEplSdoConHdl       SdoConHandle_p,
-                                    tEplFrame *          pSrcData_p,
-                                    DWORD                dwDataSize_p)
+tEplKernel PUBLIC EplSdoAsnduSendData(tEplSdoConHdl SdoConHandle_p,
+				      tEplFrame * pSrcData_p,
+				      DWORD dwDataSize_p)
 {
-tEplKernel      Ret;
-unsigned int    uiArray;
-tEplFrameInfo   FrameInfo;
-
-    Ret = kEplSuccessful;
-
-    uiArray = (SdoConHandle_p & ~EPL_SDO_ASY_HANDLE_MASK);
-
-    if(uiArray > EPL_SDO_MAX_CONNECTION_ASND)
-    {
-        Ret = kEplSdoAsndInvalidHandle;
-        goto Exit;
-    }
-
-    // fillout Asnd header
-    // own node id not needed -> filled by DLL
-
-    // set message type
-    AmiSetByteToLe(&pSrcData_p->m_le_bMessageType, (BYTE)kEplMsgTypeAsnd); // ASnd == 0x06
-    // target node id
-    AmiSetByteToLe(&pSrcData_p->m_le_bDstNodeId, (BYTE) SdoAsndInstance_g.m_auiSdoAsndConnection[uiArray]);
-    // set source-nodeid (filled by DLL 0)
-    AmiSetByteToLe(&pSrcData_p->m_le_bSrcNodeId, 0x00);
-
-    // calc size
-    dwDataSize_p += EPL_ASND_HEADER_SIZE;
-
-    // send function of DLL
-    FrameInfo.m_uiFrameSize = dwDataSize_p;
-    FrameInfo.m_pFrame = pSrcData_p;
-    EPL_MEMSET(&FrameInfo.m_NetTime , 0x00, sizeof(tEplNetTime));
+	tEplKernel Ret;
+	unsigned int uiArray;
+	tEplFrameInfo FrameInfo;
+
+	Ret = kEplSuccessful;
+
+	uiArray = (SdoConHandle_p & ~EPL_SDO_ASY_HANDLE_MASK);
+
+	if (uiArray > EPL_SDO_MAX_CONNECTION_ASND) {
+		Ret = kEplSdoAsndInvalidHandle;
+		goto Exit;
+	}
+	// fillout Asnd header
+	// own node id not needed -> filled by DLL
+
+	// set message type
+	AmiSetByteToLe(&pSrcData_p->m_le_bMessageType, (BYTE) kEplMsgTypeAsnd);	// ASnd == 0x06
+	// target node id
+	AmiSetByteToLe(&pSrcData_p->m_le_bDstNodeId,
+		       (BYTE) SdoAsndInstance_g.
+		       m_auiSdoAsndConnection[uiArray]);
+	// set source-nodeid (filled by DLL 0)
+	AmiSetByteToLe(&pSrcData_p->m_le_bSrcNodeId, 0x00);
+
+	// calc size
+	dwDataSize_p += EPL_ASND_HEADER_SIZE;
+
+	// send function of DLL
+	FrameInfo.m_uiFrameSize = dwDataSize_p;
+	FrameInfo.m_pFrame = pSrcData_p;
+	EPL_MEMSET(&FrameInfo.m_NetTime, 0x00, sizeof(tEplNetTime));
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_DLLU)) != 0)
-    Ret = EplDlluCalAsyncSend(&FrameInfo,kEplDllAsyncReqPrioGeneric);
+	Ret = EplDlluCalAsyncSend(&FrameInfo, kEplDllAsyncReqPrioGeneric);
 #endif
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
@@ -401,25 +381,22 @@ Exit:
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoAsnduDelCon(tEplSdoConHdl SdoConHandle_p)
 {
-tEplKernel  Ret;
-unsigned int    uiArray;
-
-    Ret = kEplSuccessful;
-
+	tEplKernel Ret;
+	unsigned int uiArray;
 
-    uiArray = (SdoConHandle_p & ~EPL_SDO_ASY_HANDLE_MASK);
-    // check parameter
-    if(uiArray > EPL_SDO_MAX_CONNECTION_ASND)
-    {
-        Ret = kEplSdoAsndInvalidHandle;
-        goto Exit;
-    }
+	Ret = kEplSuccessful;
 
-    // set target nodeId to 0
-    SdoAsndInstance_g.m_auiSdoAsndConnection[uiArray] = 0;
+	uiArray = (SdoConHandle_p & ~EPL_SDO_ASY_HANDLE_MASK);
+	// check parameter
+	if (uiArray > EPL_SDO_MAX_CONNECTION_ASND) {
+		Ret = kEplSdoAsndInvalidHandle;
+		goto Exit;
+	}
+	// set target nodeId to 0
+	SdoAsndInstance_g.m_auiSdoAsndConnection[uiArray] = 0;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //=========================================================================//
@@ -447,63 +424,60 @@ Exit:
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoAsnduCb(tEplFrameInfo * pFrameInfo_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-unsigned int    uiCount;
-unsigned int*   puiConnection;
-unsigned int    uiNodeId;
-unsigned int    uiFreeEntry = 0xFFFF;
-tEplSdoConHdl   SdoConHdl;
-tEplFrame*      pFrame;
-
-    pFrame = pFrameInfo_p->m_pFrame;
-
-    uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bSrcNodeId);
-
-    // search corresponding entry in control structure
-    uiCount = 0;
-    puiConnection = &SdoAsndInstance_g.m_auiSdoAsndConnection[0];
-    while (uiCount < EPL_SDO_MAX_CONNECTION_ASND)
-    {
-        if (uiNodeId == *puiConnection)
-        {
-            break;
-        }
-        else if ((*puiConnection == 0)
-            && (uiFreeEntry == 0xFFFF))
-        {   // free entry
-            uiFreeEntry = uiCount;
-        }
-        uiCount++;
-        puiConnection++;
-    }
-
-    if (uiCount == EPL_SDO_MAX_CONNECTION_ASND)
-    {
-        if (uiFreeEntry != 0xFFFF)
-        {
-            puiConnection = &SdoAsndInstance_g.m_auiSdoAsndConnection[uiFreeEntry];
-            *puiConnection = uiNodeId;
-            uiCount = uiFreeEntry;
-        }
-        else
-        {
-            EPL_DBGLVL_SDO_TRACE0("EplSdoAsnduCb(): no free handle\n");
-            goto Exit;
-        }
-    }
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiCount;
+	unsigned int *puiConnection;
+	unsigned int uiNodeId;
+	unsigned int uiFreeEntry = 0xFFFF;
+	tEplSdoConHdl SdoConHdl;
+	tEplFrame *pFrame;
+
+	pFrame = pFrameInfo_p->m_pFrame;
+
+	uiNodeId = AmiGetByteFromLe(&pFrame->m_le_bSrcNodeId);
+
+	// search corresponding entry in control structure
+	uiCount = 0;
+	puiConnection = &SdoAsndInstance_g.m_auiSdoAsndConnection[0];
+	while (uiCount < EPL_SDO_MAX_CONNECTION_ASND) {
+		if (uiNodeId == *puiConnection) {
+			break;
+		} else if ((*puiConnection == 0)
+			   && (uiFreeEntry == 0xFFFF)) {	// free entry
+			uiFreeEntry = uiCount;
+		}
+		uiCount++;
+		puiConnection++;
+	}
+
+	if (uiCount == EPL_SDO_MAX_CONNECTION_ASND) {
+		if (uiFreeEntry != 0xFFFF) {
+			puiConnection =
+			    &SdoAsndInstance_g.
+			    m_auiSdoAsndConnection[uiFreeEntry];
+			*puiConnection = uiNodeId;
+			uiCount = uiFreeEntry;
+		} else {
+			EPL_DBGLVL_SDO_TRACE0
+			    ("EplSdoAsnduCb(): no free handle\n");
+			goto Exit;
+		}
+	}
 //    if (uiNodeId == *puiConnection)
-    {   // entry found or created
-        SdoConHdl = (uiCount | EPL_SDO_ASND_HANDLE );
+	{			// entry found or created
+		SdoConHdl = (uiCount | EPL_SDO_ASND_HANDLE);
 
-        SdoAsndInstance_g.m_fpSdoAsySeqCb(SdoConHdl, &pFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame, (pFrameInfo_p->m_uiFrameSize - 18));
-    }
+		SdoAsndInstance_g.m_fpSdoAsySeqCb(SdoConHdl,
+						  &pFrame->m_Data.m_Asnd.
+						  m_Payload.m_SdoSequenceFrame,
+						  (pFrameInfo_p->m_uiFrameSize -
+						   18));
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
 #endif // end of #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
 // EOF
-
--- a/drivers/staging/epl/EplSdoAsySequ.c
+++ b/drivers/staging/epl/EplSdoAsySequ.c
@@ -70,11 +70,10 @@
 
 #include "user/EplSdoAsySequ.h"
 
-
 #if ((((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) == 0) &&\
      (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) == 0)   )
 
-    #error 'ERROR: At least UDP or Asnd module needed!'
+#error 'ERROR: At least UDP or Asnd module needed!'
 
 #endif
 /***************************************************************************/
@@ -95,11 +94,11 @@
 #define EPL_MAX_SDO_SEQ_CON         10
 #endif
 
-#define EPL_SEQ_DEFAULT_TIMEOUT     5000    // in [ms] => 5 sec
+#define EPL_SEQ_DEFAULT_TIMEOUT     5000	// in [ms] => 5 sec
 
-#define EPL_SEQ_RETRY_COUNT         5       // => max. Timeout 30 sec
+#define EPL_SEQ_RETRY_COUNT         5	// => max. Timeout 30 sec
 
-#define EPL_SEQ_NUM_THRESHOLD       100     // threshold which distinguishes between old and new sequence numbers
+#define EPL_SEQ_NUM_THRESHOLD       100	// threshold which distinguishes between old and new sequence numbers
 
 // define frame with size of Asnd-Header-, SDO Sequenze Header size, SDO Command header
 // and Ethernet-Header size
@@ -118,120 +117,115 @@
 //---------------------------------------------------------------------------
 
 // events for processfunction
-typedef enum
-{
-    kAsySdoSeqEventNoEvent  =   0x00,   // no Event
-    kAsySdoSeqEventInitCon  =   0x01,   // init connection
-    kAsySdoSeqEventFrameRec =   0x02,   // frame received
-    kAsySdoSeqEventFrameSend=   0x03,   // frame to send
-    kAsySdoSeqEventTimeout  =   0x04,   // Timeout for connection
-    kAsySdoSeqEventCloseCon =   0x05    // higher layer close connection
-
-}tEplAsySdoSeqEvent;
+typedef enum {
+	kAsySdoSeqEventNoEvent = 0x00,	// no Event
+	kAsySdoSeqEventInitCon = 0x01,	// init connection
+	kAsySdoSeqEventFrameRec = 0x02,	// frame received
+	kAsySdoSeqEventFrameSend = 0x03,	// frame to send
+	kAsySdoSeqEventTimeout = 0x04,	// Timeout for connection
+	kAsySdoSeqEventCloseCon = 0x05	// higher layer close connection
+} tEplAsySdoSeqEvent;
 
 // structure for History-Buffer
-typedef struct
-{
-    BYTE                m_bFreeEntries;
-    BYTE                m_bWrite; // index of the next free buffer entry
-    BYTE                m_bAck;   // index of the next message which should become acknowledged
-    BYTE                m_bRead;  // index between m_bAck and m_bWrite to the next message for retransmission
-    BYTE                m_aabHistoryFrame[EPL_SDO_HISTORY_SIZE][EPL_SEQ_HISTROY_FRAME_SIZE];
-    unsigned int        m_auiFrameSize[EPL_SDO_HISTORY_SIZE];
+typedef struct {
+	BYTE m_bFreeEntries;
+	BYTE m_bWrite;		// index of the next free buffer entry
+	BYTE m_bAck;		// index of the next message which should become acknowledged
+	BYTE m_bRead;		// index between m_bAck and m_bWrite to the next message for retransmission
+	BYTE m_aabHistoryFrame[EPL_SDO_HISTORY_SIZE]
+	    [EPL_SEQ_HISTROY_FRAME_SIZE];
+	unsigned int m_auiFrameSize[EPL_SDO_HISTORY_SIZE];
 
-}tEplAsySdoConHistory;
+} tEplAsySdoConHistory;
 
 // state of the statemaschine
-typedef enum
-{
-    kEplAsySdoStateIdle         = 0x00,
-    kEplAsySdoStateInit1        = 0x01,
-    kEplAsySdoStateInit2        = 0x02,
-    kEplAsySdoStateInit3        = 0x03,
-    kEplAsySdoStateConnected    = 0x04,
-    kEplAsySdoStateWaitAck      = 0x05
-
-}tEplAsySdoState;
+typedef enum {
+	kEplAsySdoStateIdle = 0x00,
+	kEplAsySdoStateInit1 = 0x01,
+	kEplAsySdoStateInit2 = 0x02,
+	kEplAsySdoStateInit3 = 0x03,
+	kEplAsySdoStateConnected = 0x04,
+	kEplAsySdoStateWaitAck = 0x05
+} tEplAsySdoState;
 
 // connection control structure
-typedef struct
-{
-    tEplSdoConHdl           m_ConHandle;
-    tEplAsySdoState         m_SdoState;
-    BYTE                    m_bRecSeqNum;   // name from view of the communication partner
-    BYTE                    m_bSendSeqNum;  // name from view of the communication partner
-    tEplAsySdoConHistory    m_SdoConHistory;
-    tEplTimerHdl            m_EplTimerHdl;
-    unsigned int            m_uiRetryCount; // retry counter
-    unsigned int            m_uiUseCount;   // one sequence layer connection may be used by
-                                            // multiple command layer connections
+typedef struct {
+	tEplSdoConHdl m_ConHandle;
+	tEplAsySdoState m_SdoState;
+	BYTE m_bRecSeqNum;	// name from view of the communication partner
+	BYTE m_bSendSeqNum;	// name from view of the communication partner
+	tEplAsySdoConHistory m_SdoConHistory;
+	tEplTimerHdl m_EplTimerHdl;
+	unsigned int m_uiRetryCount;	// retry counter
+	unsigned int m_uiUseCount;	// one sequence layer connection may be used by
+	// multiple command layer connections
 
-}tEplAsySdoSeqCon;
+} tEplAsySdoSeqCon;
 
 // instance structure
-typedef struct
-{
-    tEplAsySdoSeqCon    m_AsySdoConnection[EPL_MAX_SDO_SEQ_CON];
-    tEplSdoComReceiveCb m_fpSdoComReceiveCb;
-    tEplSdoComConCb     m_fpSdoComConCb;
+typedef struct {
+	tEplAsySdoSeqCon m_AsySdoConnection[EPL_MAX_SDO_SEQ_CON];
+	tEplSdoComReceiveCb m_fpSdoComReceiveCb;
+	tEplSdoComConCb m_fpSdoComConCb;
 
 #if defined(WIN32) || defined(_WIN32)
-    LPCRITICAL_SECTION  m_pCriticalSection;
-    CRITICAL_SECTION    m_CriticalSection;
+	LPCRITICAL_SECTION m_pCriticalSection;
+	CRITICAL_SECTION m_CriticalSection;
 
-    LPCRITICAL_SECTION  m_pCriticalSectionReceive;
-    CRITICAL_SECTION    m_CriticalSectionReceive;
+	LPCRITICAL_SECTION m_pCriticalSectionReceive;
+	CRITICAL_SECTION m_CriticalSectionReceive;
 #endif
 
-}tEplAsySdoSequInstance;
+} tEplAsySdoSequInstance;
 
 //---------------------------------------------------------------------------
 // modul globale vars
 //---------------------------------------------------------------------------
 
-static tEplAsySdoSequInstance   AsySdoSequInstance_g;
+static tEplAsySdoSequInstance AsySdoSequInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-static tEplKernel EplSdoAsySeqProcess(unsigned int  uiHandle_p,
-                                         unsigned int       uiDataSize_p,
-                                         tEplFrame*         pData_p,
-                                         tEplAsySdoSeq*     pRecFrame_p,
-                                         tEplAsySdoSeqEvent Event_p);
-
-static tEplKernel EplSdoAsySeqSendIntern(tEplAsySdoSeqCon*  pAsySdoSeqCon_p,
-                                         unsigned int       uiDataSize_p,
-                                         tEplFrame*         pData_p,
-                                         BOOL               fFrameInHistory);
-
-static tEplKernel EplSdoAsySeqSendLowerLayer(tEplAsySdoSeqCon*  pAsySdoSeqCon_p,
-                                         unsigned int       uiDataSize_p,
-                                         tEplFrame*         pEplFrame_p);
-
-tEplKernel PUBLIC EplSdoAsyReceiveCb (tEplSdoConHdl       ConHdl_p,
-                                        tEplAsySdoSeq*      pSdoSeqData_p,
-                                        unsigned int        uiDataSize_p);
+static tEplKernel EplSdoAsySeqProcess(unsigned int uiHandle_p,
+				      unsigned int uiDataSize_p,
+				      tEplFrame * pData_p,
+				      tEplAsySdoSeq * pRecFrame_p,
+				      tEplAsySdoSeqEvent Event_p);
+
+static tEplKernel EplSdoAsySeqSendIntern(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+					 unsigned int uiDataSize_p,
+					 tEplFrame * pData_p,
+					 BOOL fFrameInHistory);
+
+static tEplKernel EplSdoAsySeqSendLowerLayer(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+					     unsigned int uiDataSize_p,
+					     tEplFrame * pEplFrame_p);
+
+tEplKernel PUBLIC EplSdoAsyReceiveCb(tEplSdoConHdl ConHdl_p,
+				     tEplAsySdoSeq * pSdoSeqData_p,
+				     unsigned int uiDataSize_p);
 
 static tEplKernel EplSdoAsyInitHistory(void);
 
-static tEplKernel EplSdoAsyAddFrameToHistory(tEplAsySdoSeqCon*  pAsySdoSeqCon_p,
-                                        tEplFrame*      pFrame_p,
-                                        unsigned int    uiSize_p);
-
-static tEplKernel EplSdoAsyAckFrameToHistory(tEplAsySdoSeqCon*  pAsySdoSeqCon_p,
-                                        BYTE   bRecSeqNumber_p);
-
-static tEplKernel EplSdoAsyReadFromHistory(tEplAsySdoSeqCon*  pAsySdoSeqCon_p,
-                                           tEplFrame**      ppFrame_p,
-                                           unsigned int*    puiSize_p,
-                                           BOOL             fInitRead);
+static tEplKernel EplSdoAsyAddFrameToHistory(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+					     tEplFrame * pFrame_p,
+					     unsigned int uiSize_p);
+
+static tEplKernel EplSdoAsyAckFrameToHistory(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+					     BYTE bRecSeqNumber_p);
+
+static tEplKernel EplSdoAsyReadFromHistory(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+					   tEplFrame ** ppFrame_p,
+					   unsigned int *puiSize_p,
+					   BOOL fInitRead);
 
-static unsigned int EplSdoAsyGetFreeEntriesFromHistory(tEplAsySdoSeqCon*  pAsySdoSeqCon_p);
+static unsigned int EplSdoAsyGetFreeEntriesFromHistory(tEplAsySdoSeqCon *
+						       pAsySdoSeqCon_p);
 
-static tEplKernel EplSdoAsySeqSetTimer(tEplAsySdoSeqCon* pAsySdoSeqCon_p,
-                                        unsigned long    ulTimeout);
+static tEplKernel EplSdoAsySeqSetTimer(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+				       unsigned long ulTimeout);
 
 /***************************************************************************/
 /*                                                                         */
@@ -274,14 +268,13 @@ static tEplKernel EplSdoAsySeqSetTimer(t
 //
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoAsySeqInit(tEplSdoComReceiveCb fpSdoComCb_p,
-                                   tEplSdoComConCb fpSdoComConCb_p)
+				   tEplSdoComConCb fpSdoComConCb_p)
 {
-tEplKernel  Ret;
-
+	tEplKernel Ret;
 
-    Ret = EplSdoAsySeqAddInstance(fpSdoComCb_p, fpSdoComConCb_p);
+	Ret = EplSdoAsySeqAddInstance(fpSdoComCb_p, fpSdoComConCb_p);
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -304,78 +297,69 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoAsySeqAddInstance (tEplSdoComReceiveCb fpSdoComCb_p,
-                                   tEplSdoComConCb fpSdoComConCb_p)
+tEplKernel PUBLIC EplSdoAsySeqAddInstance(tEplSdoComReceiveCb fpSdoComCb_p,
+					  tEplSdoComConCb fpSdoComConCb_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
-
-    // check functionpointer
-    if(fpSdoComCb_p == NULL)
-    {
-        Ret = kEplSdoSeqMissCb;
-        goto Exit;
-    }
-    else
-    {
-        AsySdoSequInstance_g.m_fpSdoComReceiveCb = fpSdoComCb_p;
-    }
-
-    // check functionpointer
-    if(fpSdoComConCb_p == NULL)
-    {
-        Ret = kEplSdoSeqMissCb;
-        goto Exit;
-    }
-    else
-    {
-        AsySdoSequInstance_g.m_fpSdoComConCb = fpSdoComConCb_p;
-    }
-
-    // set controllstructure to 0
-    EPL_MEMSET(&AsySdoSequInstance_g.m_AsySdoConnection[0], 0x00, sizeof(AsySdoSequInstance_g.m_AsySdoConnection));
-
-    // init History
-    Ret = EplSdoAsyInitHistory();
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	Ret = kEplSuccessful;
 
+	// check functionpointer
+	if (fpSdoComCb_p == NULL) {
+		Ret = kEplSdoSeqMissCb;
+		goto Exit;
+	} else {
+		AsySdoSequInstance_g.m_fpSdoComReceiveCb = fpSdoComCb_p;
+	}
+
+	// check functionpointer
+	if (fpSdoComConCb_p == NULL) {
+		Ret = kEplSdoSeqMissCb;
+		goto Exit;
+	} else {
+		AsySdoSequInstance_g.m_fpSdoComConCb = fpSdoComConCb_p;
+	}
+
+	// set controllstructure to 0
+	EPL_MEMSET(&AsySdoSequInstance_g.m_AsySdoConnection[0], 0x00,
+		   sizeof(AsySdoSequInstance_g.m_AsySdoConnection));
+
+	// init History
+	Ret = EplSdoAsyInitHistory();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #if defined(WIN32) || defined(_WIN32)
-    // create critical section for process function
-    AsySdoSequInstance_g.m_pCriticalSection = &AsySdoSequInstance_g.m_CriticalSection;
-    InitializeCriticalSection(AsySdoSequInstance_g.m_pCriticalSection);
-
-    // init critical section for receive cb function
-    AsySdoSequInstance_g.m_pCriticalSectionReceive = &AsySdoSequInstance_g.m_CriticalSectionReceive;
-    InitializeCriticalSection(AsySdoSequInstance_g.m_pCriticalSectionReceive);
+	// create critical section for process function
+	AsySdoSequInstance_g.m_pCriticalSection =
+	    &AsySdoSequInstance_g.m_CriticalSection;
+	InitializeCriticalSection(AsySdoSequInstance_g.m_pCriticalSection);
+
+	// init critical section for receive cb function
+	AsySdoSequInstance_g.m_pCriticalSectionReceive =
+	    &AsySdoSequInstance_g.m_CriticalSectionReceive;
+	InitializeCriticalSection(AsySdoSequInstance_g.
+				  m_pCriticalSectionReceive);
 #endif
 
-
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
-    // init lower layer
-    Ret = EplSdoUdpuAddInstance(EplSdoAsyReceiveCb);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	// init lower layer
+	Ret = EplSdoUdpuAddInstance(EplSdoAsyReceiveCb);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
-    // init lower layer
-    Ret = EplSdoAsnduAddInstance(EplSdoAsyReceiveCb);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	// init lower layer
+	Ret = EplSdoAsnduAddInstance(EplSdoAsyReceiveCb);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #endif
 
-
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
@@ -398,45 +382,42 @@ Exit:
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoAsySeqDelInstance()
 {
-tEplKernel  Ret;
-unsigned int        uiCount;
-tEplAsySdoSeqCon*   pAsySdoSeqCon;
-
-    Ret = kEplSuccessful;
-
-    // delete timer of open connections
-    uiCount = 0;
-    pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[0];
-    while(uiCount < EPL_MAX_SDO_SEQ_CON)
-    {
-        if (pAsySdoSeqCon->m_ConHandle != 0)
-        {
-            EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
-        }
-        uiCount++;
-        pAsySdoSeqCon++;
-    }
-
+	tEplKernel Ret;
+	unsigned int uiCount;
+	tEplAsySdoSeqCon *pAsySdoSeqCon;
+
+	Ret = kEplSuccessful;
+
+	// delete timer of open connections
+	uiCount = 0;
+	pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[0];
+	while (uiCount < EPL_MAX_SDO_SEQ_CON) {
+		if (pAsySdoSeqCon->m_ConHandle != 0) {
+			EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
+		}
+		uiCount++;
+		pAsySdoSeqCon++;
+	}
 
 #if defined(WIN32) || defined(_WIN32)
-    // delete critical section for process function
-    DeleteCriticalSection(AsySdoSequInstance_g.m_pCriticalSection);
+	// delete critical section for process function
+	DeleteCriticalSection(AsySdoSequInstance_g.m_pCriticalSection);
 #endif
 
-    // set instance-table to 0
-    EPL_MEMSET(&AsySdoSequInstance_g, 0x00, sizeof(AsySdoSequInstance_g));
+	// set instance-table to 0
+	EPL_MEMSET(&AsySdoSequInstance_g, 0x00, sizeof(AsySdoSequInstance_g));
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
-    // delete lower layer
-    Ret = EplSdoUdpuDelInstance();
+	// delete lower layer
+	Ret = EplSdoUdpuDelInstance();
 #endif
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
-    // delete lower layer
-    Ret = EplSdoAsnduDelInstance();
+	// delete lower layer
+	Ret = EplSdoAsnduDelInstance();
 #endif
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -458,159 +439,139 @@ tEplAsySdoSeqCon*   pAsySdoSeqCon;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoAsySeqInitCon(tEplSdoSeqConHdl* pSdoSeqConHdl_p,
-                                unsigned int uiNodeId_p,
-                                tEplSdoType   SdoType)
-{
-tEplKernel          Ret;
-unsigned int        uiCount;
-unsigned int        uiFreeCon;
-tEplSdoConHdl       ConHandle;
-tEplAsySdoSeqCon*   pAsySdoSeqCon;
-    Ret = kEplSuccessful;
-
-    // check SdoType
-    // call init function of the protcol abstraction layer
-    // which tries to find an existing connection to the same node
-    switch (SdoType)
-    {
-        // SDO over UDP
-        case kEplSdoTypeUdp:
-        {
+tEplKernel PUBLIC EplSdoAsySeqInitCon(tEplSdoSeqConHdl * pSdoSeqConHdl_p,
+				      unsigned int uiNodeId_p,
+				      tEplSdoType SdoType)
+{
+	tEplKernel Ret;
+	unsigned int uiCount;
+	unsigned int uiFreeCon;
+	tEplSdoConHdl ConHandle;
+	tEplAsySdoSeqCon *pAsySdoSeqCon;
+	Ret = kEplSuccessful;
+
+	// check SdoType
+	// call init function of the protcol abstraction layer
+	// which tries to find an existing connection to the same node
+	switch (SdoType) {
+		// SDO over UDP
+	case kEplSdoTypeUdp:
+		{
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
-            Ret = EplSdoUdpuInitCon(&ConHandle,
-                                    uiNodeId_p);
-            if(Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
+			Ret = EplSdoUdpuInitCon(&ConHandle, uiNodeId_p);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
 #else
-            Ret = kEplSdoSeqUnsupportedProt;
+			Ret = kEplSdoSeqUnsupportedProt;
 #endif
-            break;
-        }
+			break;
+		}
 
-        // SDO over Asnd
-        case kEplSdoTypeAsnd:
-        {
+		// SDO over Asnd
+	case kEplSdoTypeAsnd:
+		{
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
-            Ret = EplSdoAsnduInitCon(&ConHandle,
-                                    uiNodeId_p);
-            if(Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
+			Ret = EplSdoAsnduInitCon(&ConHandle, uiNodeId_p);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
 #else
-            Ret = kEplSdoSeqUnsupportedProt;
+			Ret = kEplSdoSeqUnsupportedProt;
 #endif
-            break;
-        }
+			break;
+		}
 
-        // unsupported protocols
-        // -> auto should be replaced by command layer
-        case kEplSdoTypeAuto:
-        case kEplSdoTypePdo:
-        default:
-        {
-            Ret = kEplSdoSeqUnsupportedProt;
-            goto Exit;
-        }
-
-    }// end of switch(SdoType)
-
-
-    // find existing connection to the same node or find empty entry for connection
-    uiCount = 0;
-    uiFreeCon = EPL_MAX_SDO_SEQ_CON;
-    pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[0];
-
-    while (uiCount < EPL_MAX_SDO_SEQ_CON)
-    {
-        if (pAsySdoSeqCon->m_ConHandle == ConHandle)
-        {   // existing connection found
-            break;
-        }
-        if (pAsySdoSeqCon->m_ConHandle == 0)
-        {
-            uiFreeCon = uiCount;
-        }
-        uiCount++;
-        pAsySdoSeqCon++;
-    }
-
-    if (uiCount == EPL_MAX_SDO_SEQ_CON)
-    {
-        if (uiFreeCon == EPL_MAX_SDO_SEQ_CON)
-        {   // no free entry found
-            switch (SdoType)
-            {
-                // SDO over UDP
-                case kEplSdoTypeUdp:
-                {
+		// unsupported protocols
+		// -> auto should be replaced by command layer
+	case kEplSdoTypeAuto:
+	case kEplSdoTypePdo:
+	default:
+		{
+			Ret = kEplSdoSeqUnsupportedProt;
+			goto Exit;
+		}
+
+	}			// end of switch(SdoType)
+
+	// find existing connection to the same node or find empty entry for connection
+	uiCount = 0;
+	uiFreeCon = EPL_MAX_SDO_SEQ_CON;
+	pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[0];
+
+	while (uiCount < EPL_MAX_SDO_SEQ_CON) {
+		if (pAsySdoSeqCon->m_ConHandle == ConHandle) {	// existing connection found
+			break;
+		}
+		if (pAsySdoSeqCon->m_ConHandle == 0) {
+			uiFreeCon = uiCount;
+		}
+		uiCount++;
+		pAsySdoSeqCon++;
+	}
+
+	if (uiCount == EPL_MAX_SDO_SEQ_CON) {
+		if (uiFreeCon == EPL_MAX_SDO_SEQ_CON) {	// no free entry found
+			switch (SdoType) {
+				// SDO over UDP
+			case kEplSdoTypeUdp:
+				{
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
-                    Ret = EplSdoUdpuDelCon(ConHandle);
-                    if(Ret != kEplSuccessful)
-                    {
-                        goto Exit;
-                    }
+					Ret = EplSdoUdpuDelCon(ConHandle);
+					if (Ret != kEplSuccessful) {
+						goto Exit;
+					}
 #endif
-                    break;
-                }
+					break;
+				}
 
-                // SDO over Asnd
-                case kEplSdoTypeAsnd:
-                {
+				// SDO over Asnd
+			case kEplSdoTypeAsnd:
+				{
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
-                    Ret = EplSdoAsnduDelCon(ConHandle);
-                    if(Ret != kEplSuccessful)
-                    {
-                        goto Exit;
-                    }
+					Ret = EplSdoAsnduDelCon(ConHandle);
+					if (Ret != kEplSuccessful) {
+						goto Exit;
+					}
 #endif
-                    break;
-                }
+					break;
+				}
 
-                // unsupported protocols
-                // -> auto should be replaced by command layer
-                case kEplSdoTypeAuto:
-                case kEplSdoTypePdo:
-                default:
-                {
-                    Ret = kEplSdoSeqUnsupportedProt;
-                    goto Exit;
-                }
-
-            }// end of switch(SdoType)
-
-            Ret = kEplSdoSeqNoFreeHandle;
-            goto Exit;
-        }
-        else
-        {   // free entry found
-            pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[uiFreeCon];
-            pAsySdoSeqCon->m_ConHandle = ConHandle;
-            uiCount = uiFreeCon;
-        }
-    }
-
-    // set handle
-    *pSdoSeqConHdl_p = (uiCount | EPL_SDO_ASY_HANDLE);
-
-    // increment use counter
-    pAsySdoSeqCon->m_uiUseCount++;
-
-    // call intern process function
-    Ret = EplSdoAsySeqProcess(uiCount,
-                                0,
-                                NULL,
-                                NULL,
-                                kAsySdoSeqEventInitCon);
+				// unsupported protocols
+				// -> auto should be replaced by command layer
+			case kEplSdoTypeAuto:
+			case kEplSdoTypePdo:
+			default:
+				{
+					Ret = kEplSdoSeqUnsupportedProt;
+					goto Exit;
+				}
+
+			}	// end of switch(SdoType)
+
+			Ret = kEplSdoSeqNoFreeHandle;
+			goto Exit;
+		} else {	// free entry found
+			pAsySdoSeqCon =
+			    &AsySdoSequInstance_g.m_AsySdoConnection[uiFreeCon];
+			pAsySdoSeqCon->m_ConHandle = ConHandle;
+			uiCount = uiFreeCon;
+		}
+	}
+	// set handle
+	*pSdoSeqConHdl_p = (uiCount | EPL_SDO_ASY_HANDLE);
+
+	// increment use counter
+	pAsySdoSeqCon->m_uiUseCount++;
+
+	// call intern process function
+	Ret = EplSdoAsySeqProcess(uiCount,
+				  0, NULL, NULL, kAsySdoSeqEventInitCon);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplSdoAsySeqSendData
@@ -634,39 +595,33 @@ Exit:
 //
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoAsySeqSendData(tEplSdoSeqConHdl SdoSeqConHdl_p,
-                                 unsigned int    uiDataSize_p,
-                                 tEplFrame*      pabData_p )
+				       unsigned int uiDataSize_p,
+				       tEplFrame * pabData_p)
 {
-tEplKernel      Ret;
-unsigned int    uiHandle;
-
+	tEplKernel Ret;
+	unsigned int uiHandle;
 
+	uiHandle = (SdoSeqConHdl_p & ~EPL_SDO_SEQ_HANDLE_MASK);
 
-    uiHandle = (SdoSeqConHdl_p & ~EPL_SDO_SEQ_HANDLE_MASK);
-
-    // check if connection ready
-    if(AsySdoSequInstance_g.m_AsySdoConnection[uiHandle].m_SdoState == kEplAsySdoStateIdle )
-    {
-        // no connection with this handle
-        Ret = kEplSdoSeqInvalidHdl;
-        goto Exit;
-    }
-    else if(AsySdoSequInstance_g.m_AsySdoConnection[uiHandle].m_SdoState != kEplAsySdoStateConnected)
-    {
-        Ret = kEplSdoSeqConnectionBusy;
-        goto Exit;
-    }
-
-    Ret = EplSdoAsySeqProcess(uiHandle,
-                                uiDataSize_p,
-                                pabData_p,
-                                NULL,
-                                kAsySdoSeqEventFrameSend);
-Exit:
-    return Ret;
+	// check if connection ready
+	if (AsySdoSequInstance_g.m_AsySdoConnection[uiHandle].m_SdoState ==
+	    kEplAsySdoStateIdle) {
+		// no connection with this handle
+		Ret = kEplSdoSeqInvalidHdl;
+		goto Exit;
+	} else if (AsySdoSequInstance_g.m_AsySdoConnection[uiHandle].
+		   m_SdoState != kEplAsySdoStateConnected) {
+		Ret = kEplSdoSeqConnectionBusy;
+		goto Exit;
+	}
+
+	Ret = EplSdoAsySeqProcess(uiHandle,
+				  uiDataSize_p,
+				  pabData_p, NULL, kAsySdoSeqEventFrameSend);
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplSdoAsySeqProcessEvent
@@ -685,71 +640,60 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoAsySeqProcessEvent(tEplEvent* pEvent_p)
+tEplKernel PUBLIC EplSdoAsySeqProcessEvent(tEplEvent * pEvent_p)
 {
-tEplKernel          Ret;
-tEplTimerEventArg*  pTimerEventArg;
-tEplAsySdoSeqCon*   pAsySdoSeqCon;
-tEplTimerHdl        EplTimerHdl;
-unsigned int        uiCount;
-
-    Ret = kEplSuccessful;
-    // check parameter
-    if(pEvent_p == NULL)
-    {
-        Ret = kEplSdoSeqInvalidEvent;
-        goto Exit;
-    }
-
-    if(pEvent_p->m_EventType != kEplEventTypeTimer)
-    {
-        Ret = kEplSdoSeqInvalidEvent;
-        goto Exit;
-    }
-
-    // get timerhdl
-    pTimerEventArg = (tEplTimerEventArg*)pEvent_p->m_pArg;
-    EplTimerHdl = pTimerEventArg->m_TimerHdl;
-
-    // get pointer to intern control structure of connection
-    if(pTimerEventArg->m_ulArg == 0)
-    {
-        goto Exit;
-    }
-    pAsySdoSeqCon = (tEplAsySdoSeqCon*)pTimerEventArg->m_ulArg;
-
-    // check if time is current
-    if(EplTimerHdl != pAsySdoSeqCon->m_EplTimerHdl)
-    {
-        // delete timer
-        EplTimeruDeleteTimer(&EplTimerHdl);
-        goto Exit;
-    }
-
-    // delete timer
-    EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
-
-    // get indexnumber of control structure
-    uiCount = 0;
-    while((&AsySdoSequInstance_g.m_AsySdoConnection[uiCount]) != pAsySdoSeqCon)
-    {
-        uiCount++;
-        if(uiCount > EPL_MAX_SDO_SEQ_CON)
-        {
-            goto Exit;
-        }
-    }
-
-
-    // process event and call processfunction if needed
-    Ret = EplSdoAsySeqProcess(uiCount,
-                                0,
-                                NULL,
-                                NULL,
-                                kAsySdoSeqEventTimeout);
+	tEplKernel Ret;
+	tEplTimerEventArg *pTimerEventArg;
+	tEplAsySdoSeqCon *pAsySdoSeqCon;
+	tEplTimerHdl EplTimerHdl;
+	unsigned int uiCount;
+
+	Ret = kEplSuccessful;
+	// check parameter
+	if (pEvent_p == NULL) {
+		Ret = kEplSdoSeqInvalidEvent;
+		goto Exit;
+	}
+
+	if (pEvent_p->m_EventType != kEplEventTypeTimer) {
+		Ret = kEplSdoSeqInvalidEvent;
+		goto Exit;
+	}
+	// get timerhdl
+	pTimerEventArg = (tEplTimerEventArg *) pEvent_p->m_pArg;
+	EplTimerHdl = pTimerEventArg->m_TimerHdl;
+
+	// get pointer to intern control structure of connection
+	if (pTimerEventArg->m_ulArg == 0) {
+		goto Exit;
+	}
+	pAsySdoSeqCon = (tEplAsySdoSeqCon *) pTimerEventArg->m_ulArg;
+
+	// check if time is current
+	if (EplTimerHdl != pAsySdoSeqCon->m_EplTimerHdl) {
+		// delete timer
+		EplTimeruDeleteTimer(&EplTimerHdl);
+		goto Exit;
+	}
+	// delete timer
+	EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
+
+	// get indexnumber of control structure
+	uiCount = 0;
+	while ((&AsySdoSequInstance_g.m_AsySdoConnection[uiCount]) !=
+	       pAsySdoSeqCon) {
+		uiCount++;
+		if (uiCount > EPL_MAX_SDO_SEQ_CON) {
+			goto Exit;
+		}
+	}
+
+	// process event and call processfunction if needed
+	Ret = EplSdoAsySeqProcess(uiCount,
+				  0, NULL, NULL, kAsySdoSeqEventTimeout);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
@@ -772,60 +716,54 @@ Exit:
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoAsySeqDelCon(tEplSdoSeqConHdl SdoSeqConHdl_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-unsigned int    uiHandle;
-tEplAsySdoSeqCon*   pAsySdoSeqCon;
-
-    uiHandle = (SdoSeqConHdl_p & ~EPL_SDO_SEQ_HANDLE_MASK);
-
-    // check if handle invalid
-    if(uiHandle >= EPL_MAX_SDO_SEQ_CON)
-    {
-        Ret = kEplSdoSeqInvalidHdl;
-        goto Exit;
-    }
-
-    // get pointer to connection
-    pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[uiHandle];
-
-    // decrement use counter
-    pAsySdoSeqCon->m_uiUseCount--;
-
-    if (pAsySdoSeqCon->m_uiUseCount == 0)
-    {
-        // process close in processfunction
-        Ret = EplSdoAsySeqProcess(uiHandle,
-                                    0,
-                                    NULL,
-                                    NULL,
-                                    kAsySdoSeqEventCloseCon);
-
-        //check protocol
-        if((pAsySdoSeqCon->m_ConHandle & EPL_SDO_ASY_HANDLE_MASK) == EPL_SDO_UDP_HANDLE)
-        {
-        #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
-            // call close function of lower layer
-            EplSdoUdpuDelCon(pAsySdoSeqCon->m_ConHandle);
-        #endif// end of #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
-        }
-        else
-        {
-        #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
-            // call close function of lower layer
-            EplSdoAsnduDelCon(pAsySdoSeqCon->m_ConHandle);
-        #endif// end of #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
-        }
-
-        // delete timer
-        EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
-
-        // clean controllstructure
-        EPL_MEMSET(pAsySdoSeqCon, 0x00, sizeof(tEplAsySdoSeqCon));
-        pAsySdoSeqCon->m_SdoConHistory.m_bFreeEntries = EPL_SDO_HISTORY_SIZE;
-    }
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiHandle;
+	tEplAsySdoSeqCon *pAsySdoSeqCon;
+
+	uiHandle = (SdoSeqConHdl_p & ~EPL_SDO_SEQ_HANDLE_MASK);
+
+	// check if handle invalid
+	if (uiHandle >= EPL_MAX_SDO_SEQ_CON) {
+		Ret = kEplSdoSeqInvalidHdl;
+		goto Exit;
+	}
+	// get pointer to connection
+	pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[uiHandle];
+
+	// decrement use counter
+	pAsySdoSeqCon->m_uiUseCount--;
+
+	if (pAsySdoSeqCon->m_uiUseCount == 0) {
+		// process close in processfunction
+		Ret = EplSdoAsySeqProcess(uiHandle,
+					  0,
+					  NULL, NULL, kAsySdoSeqEventCloseCon);
+
+		//check protocol
+		if ((pAsySdoSeqCon->m_ConHandle & EPL_SDO_ASY_HANDLE_MASK) ==
+		    EPL_SDO_UDP_HANDLE) {
+#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
+			// call close function of lower layer
+			EplSdoUdpuDelCon(pAsySdoSeqCon->m_ConHandle);
+#endif // end of #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
+		} else {
+#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
+			// call close function of lower layer
+			EplSdoAsnduDelCon(pAsySdoSeqCon->m_ConHandle);
+#endif // end of #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
+		}
+
+		// delete timer
+		EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
+
+		// clean controllstructure
+		EPL_MEMSET(pAsySdoSeqCon, 0x00, sizeof(tEplAsySdoSeqCon));
+		pAsySdoSeqCon->m_SdoConHistory.m_bFreeEntries =
+		    EPL_SDO_HISTORY_SIZE;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
@@ -860,966 +798,1191 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel EplSdoAsySeqProcess(unsigned int  uiHandle_p,
-                                         unsigned int       uiDataSize_p,
-                                         tEplFrame*         pData_p,
-                                         tEplAsySdoSeq*     pRecFrame_p,
-                                         tEplAsySdoSeqEvent Event_p)
-
-{
-tEplKernel          Ret;
-unsigned int        uiFrameSize;
-tEplFrame*          pEplFrame;
-tEplAsySdoSeqCon*   pAsySdoSeqCon;
-tEplSdoSeqConHdl    SdoSeqConHdl;
-unsigned int        uiFreeEntries;
+static tEplKernel EplSdoAsySeqProcess(unsigned int uiHandle_p,
+				      unsigned int uiDataSize_p,
+				      tEplFrame * pData_p,
+				      tEplAsySdoSeq * pRecFrame_p,
+				      tEplAsySdoSeqEvent Event_p)
+{
+	tEplKernel Ret;
+	unsigned int uiFrameSize;
+	tEplFrame *pEplFrame;
+	tEplAsySdoSeqCon *pAsySdoSeqCon;
+	tEplSdoSeqConHdl SdoSeqConHdl;
+	unsigned int uiFreeEntries;
 
 #if defined(WIN32) || defined(_WIN32)
-    // enter  critical section for process function
-    EnterCriticalSection(AsySdoSequInstance_g.m_pCriticalSection);
+	// enter  critical section for process function
+	EnterCriticalSection(AsySdoSequInstance_g.m_pCriticalSection);
 #endif
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // get handle for hinger layer
-    SdoSeqConHdl = uiHandle_p | EPL_SDO_ASY_HANDLE;
+	// get handle for hinger layer
+	SdoSeqConHdl = uiHandle_p | EPL_SDO_ASY_HANDLE;
 
-    // check if handle invalid
-    if((SdoSeqConHdl & ~EPL_SDO_SEQ_HANDLE_MASK) == EPL_SDO_SEQ_INVALID_HDL)
-    {
-        Ret = kEplSdoSeqInvalidHdl;
-        goto Exit;
-    }
-
-    // get pointer to connection
-    pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[uiHandle_p];
-
-    // check size
-    if((pData_p == NULL)&& (pRecFrame_p == NULL) && (uiDataSize_p != 0))
-    {
-        Ret = kEplSdoSeqInvalidFrame;
-        goto Exit;
-    }
-
-    // check state
-    switch(pAsySdoSeqCon->m_SdoState)
-    {
-        // idle state
-        case kEplAsySdoStateIdle:
-        {
-            // check event
-            switch(Event_p)
-            {
-                // new connection
-                // -> send init frame and change to
-                // kEplAsySdoStateInit1
-                case kAsySdoSeqEventInitCon:
-                {
-                    // set sending scon to 1
-                    pAsySdoSeqCon->m_bRecSeqNum = 0x01;
-                    // set set send rcon to 0
-                    pAsySdoSeqCon->m_bSendSeqNum = 0x00;
-                    Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                 0,
-                                                 NULL,
-                                                 FALSE);
-                    if(Ret != kEplSuccessful)
-                    {
-                        goto Exit;
-                    }
-
-                    // change state
-                    pAsySdoSeqCon->m_SdoState = kEplAsySdoStateInit1;
-
-                    // set timer
-                    Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                                EPL_SEQ_DEFAULT_TIMEOUT);
-
-                    break;
-                }
-
-                // init con from extern
-                // check rcon and scon
-                // -> send answer
-                case kAsySdoSeqEventFrameRec:
-                {
+	// check if handle invalid
+	if ((SdoSeqConHdl & ~EPL_SDO_SEQ_HANDLE_MASK) ==
+	    EPL_SDO_SEQ_INVALID_HDL) {
+		Ret = kEplSdoSeqInvalidHdl;
+		goto Exit;
+	}
+	// get pointer to connection
+	pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[uiHandle_p];
+
+	// check size
+	if ((pData_p == NULL) && (pRecFrame_p == NULL) && (uiDataSize_p != 0)) {
+		Ret = kEplSdoSeqInvalidFrame;
+		goto Exit;
+	}
+	// check state
+	switch (pAsySdoSeqCon->m_SdoState) {
+		// idle state
+	case kEplAsySdoStateIdle:
+		{
+			// check event
+			switch (Event_p) {
+				// new connection
+				// -> send init frame and change to
+				// kEplAsySdoStateInit1
+			case kAsySdoSeqEventInitCon:
+				{
+					// set sending scon to 1
+					pAsySdoSeqCon->m_bRecSeqNum = 0x01;
+					// set set send rcon to 0
+					pAsySdoSeqCon->m_bSendSeqNum = 0x00;
+					Ret =
+					    EplSdoAsySeqSendIntern
+					    (pAsySdoSeqCon, 0, NULL, FALSE);
+					if (Ret != kEplSuccessful) {
+						goto Exit;
+					}
+					// change state
+					pAsySdoSeqCon->m_SdoState =
+					    kEplAsySdoStateInit1;
+
+					// set timer
+					Ret =
+					    EplSdoAsySeqSetTimer(pAsySdoSeqCon,
+								 EPL_SEQ_DEFAULT_TIMEOUT);
+
+					break;
+				}
+
+				// init con from extern
+				// check rcon and scon
+				// -> send answer
+			case kAsySdoSeqEventFrameRec:
+				{
 /*
                     PRINTF3("%s scon=%u rcon=%u\n",
                             __FUNCTION__,
                             pRecFrame_p->m_le_bSendSeqNumCon,
                             pRecFrame_p->m_le_bRecSeqNumCon);
 */
-                    // check if scon == 1 and rcon == 0
-                    if(((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x00)
-                        &&((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x01))
-                    {
-                        // save sequence numbers
-                        pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                        pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-                        // create answer and send answer
-                        // set rcon to 1 (in send direction own scon)
-                        pAsySdoSeqCon->m_bRecSeqNum++;
-                        Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                 0,
-                                                 NULL,
-                                                 FALSE);
-                        if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        // change state to kEplAsySdoStateInit2
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateInit2;
-
-                        // set timer
-                        Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                                EPL_SEQ_DEFAULT_TIMEOUT);
-                    }
-                    else
-                    {   // error -> close
-                        // delete timer
-                        EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
-                        if (((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00)
-                            || ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00))
-                        {   // d.k. only answer with close message if the message sent was not a close message
-                            // save sequence numbers
-                            pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                            pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-                            // set rcon and scon to 0
-                            pAsySdoSeqCon->m_bSendSeqNum &= EPL_SEQ_NUM_MASK;
-                            pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
-                            // send frame
-                            EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                        0,
-                                                        NULL,
-                                                        FALSE);
-                        }
-
-                        // call Command Layer Cb
-                        AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                            kAsySdoConStateInitError);
-                    }
-                    break;
-                }
-
-                default:
-                    // d.k. do nothing
-                    break;
-
-            }// end of switch(Event_p)
-            break;
-        }
-
-        // init connection step 1
-        // wait for frame with scon = 1
-        // and rcon = 1
-        case kEplAsySdoStateInit1:
-        {
+					// check if scon == 1 and rcon == 0
+					if (((pRecFrame_p->
+					      m_le_bRecSeqNumCon &
+					      EPL_ASY_SDO_CON_MASK) == 0x00)
+					    &&
+					    ((pRecFrame_p->
+					      m_le_bSendSeqNumCon &
+					      EPL_ASY_SDO_CON_MASK) == 0x01)) {
+						// save sequence numbers
+						pAsySdoSeqCon->m_bRecSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bRecSeqNumCon);
+						pAsySdoSeqCon->m_bSendSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bSendSeqNumCon);
+						// create answer and send answer
+						// set rcon to 1 (in send direction own scon)
+						pAsySdoSeqCon->m_bRecSeqNum++;
+						Ret =
+						    EplSdoAsySeqSendIntern
+						    (pAsySdoSeqCon, 0, NULL,
+						     FALSE);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						// change state to kEplAsySdoStateInit2
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateInit2;
+
+						// set timer
+						Ret =
+						    EplSdoAsySeqSetTimer
+						    (pAsySdoSeqCon,
+						     EPL_SEQ_DEFAULT_TIMEOUT);
+					} else {	// error -> close
+						// delete timer
+						EplTimeruDeleteTimer
+						    (&pAsySdoSeqCon->
+						     m_EplTimerHdl);
+						if (((pRecFrame_p->
+						      m_le_bRecSeqNumCon &
+						      EPL_ASY_SDO_CON_MASK) !=
+						     0x00)
+						    || ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00)) {	// d.k. only answer with close message if the message sent was not a close message
+							// save sequence numbers
+							pAsySdoSeqCon->
+							    m_bRecSeqNum =
+							    AmiGetByteFromLe
+							    (&pRecFrame_p->
+							     m_le_bRecSeqNumCon);
+							pAsySdoSeqCon->
+							    m_bSendSeqNum =
+							    AmiGetByteFromLe
+							    (&pRecFrame_p->
+							     m_le_bSendSeqNumCon);
+							// set rcon and scon to 0
+							pAsySdoSeqCon->
+							    m_bSendSeqNum &=
+							    EPL_SEQ_NUM_MASK;
+							pAsySdoSeqCon->
+							    m_bRecSeqNum &=
+							    EPL_SEQ_NUM_MASK;
+							// send frame
+							EplSdoAsySeqSendIntern
+							    (pAsySdoSeqCon, 0,
+							     NULL, FALSE);
+						}
+						// call Command Layer Cb
+						AsySdoSequInstance_g.
+						    m_fpSdoComConCb
+						    (SdoSeqConHdl,
+						     kAsySdoConStateInitError);
+					}
+					break;
+				}
+
+			default:
+				// d.k. do nothing
+				break;
+
+			}	// end of switch(Event_p)
+			break;
+		}
+
+		// init connection step 1
+		// wait for frame with scon = 1
+		// and rcon = 1
+	case kEplAsySdoStateInit1:
+		{
 //            PRINTF0("EplSdoAsySequ: StateInit1\n");
 
-            // check event
-            switch(Event_p)
-            {
-                // frame received
-                case kAsySdoSeqEventFrameRec:
-                {
-                    // check scon == 1 and rcon == 1
-                    if(((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x01)
-                        &&((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x01))
-                    {   // create answer own scon = 2
-                        // save sequence numbers
-                        pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                        pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-
-                        pAsySdoSeqCon->m_bRecSeqNum++;
-                        Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                 0,
-                                                 NULL,
-                                                 FALSE);
-                        if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        // change state to kEplAsySdoStateInit3
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateInit3;
-
-                        // set timer
-                        Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                                EPL_SEQ_DEFAULT_TIMEOUT);
-
-                    }
-                    // check if scon == 1 and rcon == 0, i.e. other side wants me to be server
-                    else if(((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x00)
-                        &&((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x01))
-                    {
-                        // save sequence numbers
-                        pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                        pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-                        // create answer and send answer
-                        // set rcon to 1 (in send direction own scon)
-                        pAsySdoSeqCon->m_bRecSeqNum++;
-                        Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                 0,
-                                                 NULL,
-                                                 FALSE);
-                        if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        // change state to kEplAsySdoStateInit2
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateInit2;
-
-                        // set timer
-                        Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                                EPL_SEQ_DEFAULT_TIMEOUT);
-                    }
-                    else
-                    {   // error -> Close
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-                        // delete timer
-                        EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
-                        if (((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00)
-                            || ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00))
-                        {   // d.k. only answer with close message if the message sent was not a close message
-                            // save sequence numbers
-                            pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                            pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-
-                            // set rcon and scon to 0
-                            pAsySdoSeqCon->m_bSendSeqNum &= EPL_SEQ_NUM_MASK;
-                            pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
-                            // send frame
-                            EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                        0,
-                                                        NULL,
-                                                        FALSE);
-                        }
-                        // call Command Layer Cb
-                        AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                            kAsySdoConStateInitError);
-                    }
-                    break;
-                }
-
-                // timeout
-                case kAsySdoSeqEventTimeout:
-                {   // error -> Close
-                    pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-
-                    // set rcon and scon to 0
-                    pAsySdoSeqCon->m_bSendSeqNum &= EPL_SEQ_NUM_MASK;
-                    pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
-                    // send frame
-                    EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                0,
-                                                NULL,
-                                                FALSE);
-                    // call Command Layer Cb
-                    AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                        kAsySdoConStateInitError);
-                    break;
-                }
-
-                default:
-                    // d.k. do nothing
-                    break;
-
-            }// end of switch(Event_p)
-            break;
-        }
-
-        // init connection step 2
-        case kEplAsySdoStateInit2:
-        {
+			// check event
+			switch (Event_p) {
+				// frame received
+			case kAsySdoSeqEventFrameRec:
+				{
+					// check scon == 1 and rcon == 1
+					if (((pRecFrame_p->
+					      m_le_bRecSeqNumCon &
+					      EPL_ASY_SDO_CON_MASK) == 0x01)
+					    && ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x01)) {	// create answer own scon = 2
+						// save sequence numbers
+						pAsySdoSeqCon->m_bRecSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bRecSeqNumCon);
+						pAsySdoSeqCon->m_bSendSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bSendSeqNumCon);
+
+						pAsySdoSeqCon->m_bRecSeqNum++;
+						Ret =
+						    EplSdoAsySeqSendIntern
+						    (pAsySdoSeqCon, 0, NULL,
+						     FALSE);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						// change state to kEplAsySdoStateInit3
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateInit3;
+
+						// set timer
+						Ret =
+						    EplSdoAsySeqSetTimer
+						    (pAsySdoSeqCon,
+						     EPL_SEQ_DEFAULT_TIMEOUT);
+
+					}
+					// check if scon == 1 and rcon == 0, i.e. other side wants me to be server
+					else if (((pRecFrame_p->
+						   m_le_bRecSeqNumCon &
+						   EPL_ASY_SDO_CON_MASK) ==
+						  0x00)
+						 &&
+						 ((pRecFrame_p->
+						   m_le_bSendSeqNumCon &
+						   EPL_ASY_SDO_CON_MASK) ==
+						  0x01)) {
+						// save sequence numbers
+						pAsySdoSeqCon->m_bRecSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bRecSeqNumCon);
+						pAsySdoSeqCon->m_bSendSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bSendSeqNumCon);
+						// create answer and send answer
+						// set rcon to 1 (in send direction own scon)
+						pAsySdoSeqCon->m_bRecSeqNum++;
+						Ret =
+						    EplSdoAsySeqSendIntern
+						    (pAsySdoSeqCon, 0, NULL,
+						     FALSE);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						// change state to kEplAsySdoStateInit2
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateInit2;
+
+						// set timer
+						Ret =
+						    EplSdoAsySeqSetTimer
+						    (pAsySdoSeqCon,
+						     EPL_SEQ_DEFAULT_TIMEOUT);
+					} else {	// error -> Close
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateIdle;
+						// delete timer
+						EplTimeruDeleteTimer
+						    (&pAsySdoSeqCon->
+						     m_EplTimerHdl);
+						if (((pRecFrame_p->
+						      m_le_bRecSeqNumCon &
+						      EPL_ASY_SDO_CON_MASK) !=
+						     0x00)
+						    || ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00)) {	// d.k. only answer with close message if the message sent was not a close message
+							// save sequence numbers
+							pAsySdoSeqCon->
+							    m_bRecSeqNum =
+							    AmiGetByteFromLe
+							    (&pRecFrame_p->
+							     m_le_bRecSeqNumCon);
+							pAsySdoSeqCon->
+							    m_bSendSeqNum =
+							    AmiGetByteFromLe
+							    (&pRecFrame_p->
+							     m_le_bSendSeqNumCon);
+
+							// set rcon and scon to 0
+							pAsySdoSeqCon->
+							    m_bSendSeqNum &=
+							    EPL_SEQ_NUM_MASK;
+							pAsySdoSeqCon->
+							    m_bRecSeqNum &=
+							    EPL_SEQ_NUM_MASK;
+							// send frame
+							EplSdoAsySeqSendIntern
+							    (pAsySdoSeqCon, 0,
+							     NULL, FALSE);
+						}
+						// call Command Layer Cb
+						AsySdoSequInstance_g.
+						    m_fpSdoComConCb
+						    (SdoSeqConHdl,
+						     kAsySdoConStateInitError);
+					}
+					break;
+				}
+
+				// timeout
+			case kAsySdoSeqEventTimeout:
+				{	// error -> Close
+					pAsySdoSeqCon->m_SdoState =
+					    kEplAsySdoStateIdle;
+
+					// set rcon and scon to 0
+					pAsySdoSeqCon->m_bSendSeqNum &=
+					    EPL_SEQ_NUM_MASK;
+					pAsySdoSeqCon->m_bRecSeqNum &=
+					    EPL_SEQ_NUM_MASK;
+					// send frame
+					EplSdoAsySeqSendIntern(pAsySdoSeqCon,
+							       0, NULL, FALSE);
+					// call Command Layer Cb
+					AsySdoSequInstance_g.
+					    m_fpSdoComConCb(SdoSeqConHdl,
+							    kAsySdoConStateInitError);
+					break;
+				}
+
+			default:
+				// d.k. do nothing
+				break;
+
+			}	// end of switch(Event_p)
+			break;
+		}
+
+		// init connection step 2
+	case kEplAsySdoStateInit2:
+		{
 //            PRINTF0("EplSdoAsySequ: StateInit2\n");
 
-            // check event
-            switch(Event_p)
-            {
-                // frame received
-                case kAsySdoSeqEventFrameRec:
-                {
-                    // check scon == 2 and rcon == 1
-                    if(((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x01)
-                        &&((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x02))
-                    {   // create answer own rcon = 2
-                        // save sequence numbers
-                        pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                        pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-
-                        pAsySdoSeqCon->m_bRecSeqNum++;
-                        Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                 0,
-                                                 NULL,
-                                                 FALSE);
-                        if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        // change state to kEplAsySdoStateConnected
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateConnected;
-
-                        // set timer
-                        Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                                EPL_SEQ_DEFAULT_TIMEOUT);
-
-                        // call Command Layer Cb
-                        AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                        kAsySdoConStateConnected);
-
-                    }
-                    // check scon == 1 and rcon == 1, i.e. other side wants me to initiate the connection
-                    else if(((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x01)
-                        &&((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x01))
-                    {
-                        // save sequence numbers
-                        pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                        pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-                        // create answer and send answer
-                        // set rcon to 1 (in send direction own scon)
-                        pAsySdoSeqCon->m_bRecSeqNum++;
-                        Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                 0,
-                                                 NULL,
-                                                 FALSE);
-                        if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        // set timer
-                        Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                                EPL_SEQ_DEFAULT_TIMEOUT);
-                        // change state to kEplAsySdoStateInit3
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateInit3;
-
-                    }
-                    else
-                    {   // error -> Close
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-                        // delete timer
-                        EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
-                        if (((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00)
-                            || ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00))
-                        {   // d.k. only answer with close message if the message sent was not a close message
-                            // save sequence numbers
-                            pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                            pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-                            // set rcon and scon to 0
-                            pAsySdoSeqCon->m_bSendSeqNum &= EPL_SEQ_NUM_MASK;
-                            pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
-                            // send frame
-                            EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                        0,
-                                                        NULL,
-                                                        FALSE);
-                        }
-                        // call Command Layer Cb
-                        AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                            kAsySdoConStateInitError);
-                    }
-                    break;
-                }
-
-                // timeout
-                case kAsySdoSeqEventTimeout:
-                {   // error -> Close
-                    pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-                    // set rcon and scon to 0
-                    pAsySdoSeqCon->m_bSendSeqNum &= EPL_SEQ_NUM_MASK;
-                    pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
-                    // send frame
-                    EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                0,
-                                                NULL,
-                                                FALSE);
-
-                    // call Command Layer Cb
-                    AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                            kAsySdoConStateInitError);
-                    break;
-                }
-
-                default:
-                    // d.k. do nothing
-                    break;
-
-            }// end of switch(Event_p)
-            break;
-        }
-
-        // init connection step 3
-        case kEplAsySdoStateInit3:
-        {
-            // check event
-            switch(Event_p)
-            {
-                // frame received
-                case kAsySdoSeqEventFrameRec:
-                {
-                    // check scon == 2 and rcon == 2
-                    if(((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x02)
-                        &&((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x02))
-                    {
-                        // save sequence numbers
-                        pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                        pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-                        // change state to kEplAsySdoStateConnected
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateConnected;
-
-                        // set timer
-                        Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                                EPL_SEQ_DEFAULT_TIMEOUT);
-                        // call Command Layer Cb
-                        AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                        kAsySdoConStateConnected);
-
-                    }
-                    // check scon == 2 and rcon == 1
-                    else if(((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x01)
-                        &&((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x02))
-                    {   // create answer own rcon = 2
-                        // save sequence numbers
-                        pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                        pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-
-                        pAsySdoSeqCon->m_bRecSeqNum++;
-                        Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                 0,
-                                                 NULL,
-                                                 FALSE);
-                        if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        // change state to kEplAsySdoStateConnected
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateConnected;
-
-                        // set timer
-                        Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                                EPL_SEQ_DEFAULT_TIMEOUT);
-
-                        // call Command Layer Cb
-                        AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                        kAsySdoConStateConnected);
-
-                    }
-                    else
-                    {   // error -> Close
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-                        // delete timer
-                        EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
-                        if (((pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00)
-                            || ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00))
-                        {   // d.k. only answer with close message if the message sent was not a close message
-                            // save sequence numbers
-                            pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                            pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-                            // set rcon and scon to 0
-                            pAsySdoSeqCon->m_bSendSeqNum &= EPL_SEQ_NUM_MASK;
-                            pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
-                            // send frame
-                            EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                        0,
-                                                        NULL,
-                                                        FALSE);
-                        }
-                        // call Command Layer Cb
-                        AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                            kAsySdoConStateInitError);
-                    }
-                    break;
-                }
-
-                // timeout
-                case kAsySdoSeqEventTimeout:
-                {   // error -> Close
-                    pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-                    // set rcon and scon to 0
-                    pAsySdoSeqCon->m_bSendSeqNum &= EPL_SEQ_NUM_MASK;
-                    pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
-                    // send frame
-                    EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                0,
-                                                NULL,
-                                                FALSE);
-
-                    // call Command Layer Cb
-                    AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                        kAsySdoConStateInitError);
-                    break;
-                }
-
-                default:
-                    // d.k. do nothing
-                    break;
-
-            }// end of switch(Event_p)
-            break;
-        }
-
-        // connection established
-        case kEplAsySdoStateConnected:
-        {
-            // check event
-            switch(Event_p)
-            {
-
-                // frame to send
-                case kAsySdoSeqEventFrameSend:
-                {
-                    // set timer
-                    Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                            EPL_SEQ_DEFAULT_TIMEOUT);
-                    // check if data frame or ack
-                    if(pData_p == NULL)
-                    {   // send ack
-                        // inc scon
-                        //pAsySdoSeqCon->m_bRecSeqNum += 4;
-                        Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                 0,
-                                                 NULL,
-                                                 FALSE);
-                        if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                    }
-                    else
-                    {   // send dataframe
-                        // increment send sequence number
-                        pAsySdoSeqCon->m_bRecSeqNum += 4;
-                        Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                 uiDataSize_p,
-                                                 pData_p,
-                                                 TRUE);
-                        if(Ret == kEplSdoSeqRequestAckNeeded)
-                        { // request ack
-                            // change state to wait ack
-                            pAsySdoSeqCon->m_SdoState = kEplAsySdoStateWaitAck;
-                            // set Ret to kEplSuccessful, because no error
-                            // for higher layer
-                            Ret = kEplSuccessful;
-
-                        }
-                        else if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        else
-                        {
-                            // call Command Layer Cb
-                            AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                            kAsySdoConStateFrameSended);
-                        }
-                    }
-                    break;
-                }// end of case kAsySdoSeqEventFrameSend
-
-                // frame received
-                case kAsySdoSeqEventFrameRec:
-                {
-                BYTE bSendSeqNumCon = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-
-                    // set timer
-                    Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                            EPL_SEQ_DEFAULT_TIMEOUT);
-                    // check scon
-                    switch (bSendSeqNumCon & EPL_ASY_SDO_CON_MASK)
-                    {
-                        // close from other node
-                        case 0:
-                        case 1:
-                        {
-                            // return to idle
-                            pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-                            // delete timer
-                            EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
-                            // call Command Layer Cb
-                            AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                    kAsySdoConStateConClosed);
-
-                            break;
-                        }
-
-                        // Request Ack or Error Ack
-                        // possible contain data
-                        case 3:
-                        // normal frame
-                        case 2:
-                        {
-                            if ((AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon) & EPL_ASY_SDO_CON_MASK) == 3)
-                            {
+			// check event
+			switch (Event_p) {
+				// frame received
+			case kAsySdoSeqEventFrameRec:
+				{
+					// check scon == 2 and rcon == 1
+					if (((pRecFrame_p->
+					      m_le_bRecSeqNumCon &
+					      EPL_ASY_SDO_CON_MASK) == 0x01)
+					    && ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x02)) {	// create answer own rcon = 2
+						// save sequence numbers
+						pAsySdoSeqCon->m_bRecSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bRecSeqNumCon);
+						pAsySdoSeqCon->m_bSendSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bSendSeqNumCon);
+
+						pAsySdoSeqCon->m_bRecSeqNum++;
+						Ret =
+						    EplSdoAsySeqSendIntern
+						    (pAsySdoSeqCon, 0, NULL,
+						     FALSE);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						// change state to kEplAsySdoStateConnected
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateConnected;
+
+						// set timer
+						Ret =
+						    EplSdoAsySeqSetTimer
+						    (pAsySdoSeqCon,
+						     EPL_SEQ_DEFAULT_TIMEOUT);
+
+						// call Command Layer Cb
+						AsySdoSequInstance_g.
+						    m_fpSdoComConCb
+						    (SdoSeqConHdl,
+						     kAsySdoConStateConnected);
+
+					}
+					// check scon == 1 and rcon == 1, i.e. other side wants me to initiate the connection
+					else if (((pRecFrame_p->
+						   m_le_bRecSeqNumCon &
+						   EPL_ASY_SDO_CON_MASK) ==
+						  0x01)
+						 &&
+						 ((pRecFrame_p->
+						   m_le_bSendSeqNumCon &
+						   EPL_ASY_SDO_CON_MASK) ==
+						  0x01)) {
+						// save sequence numbers
+						pAsySdoSeqCon->m_bRecSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bRecSeqNumCon);
+						pAsySdoSeqCon->m_bSendSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bSendSeqNumCon);
+						// create answer and send answer
+						// set rcon to 1 (in send direction own scon)
+						pAsySdoSeqCon->m_bRecSeqNum++;
+						Ret =
+						    EplSdoAsySeqSendIntern
+						    (pAsySdoSeqCon, 0, NULL,
+						     FALSE);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						// set timer
+						Ret =
+						    EplSdoAsySeqSetTimer
+						    (pAsySdoSeqCon,
+						     EPL_SEQ_DEFAULT_TIMEOUT);
+						// change state to kEplAsySdoStateInit3
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateInit3;
+
+					} else {	// error -> Close
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateIdle;
+						// delete timer
+						EplTimeruDeleteTimer
+						    (&pAsySdoSeqCon->
+						     m_EplTimerHdl);
+						if (((pRecFrame_p->
+						      m_le_bRecSeqNumCon &
+						      EPL_ASY_SDO_CON_MASK) !=
+						     0x00)
+						    || ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00)) {	// d.k. only answer with close message if the message sent was not a close message
+							// save sequence numbers
+							pAsySdoSeqCon->
+							    m_bRecSeqNum =
+							    AmiGetByteFromLe
+							    (&pRecFrame_p->
+							     m_le_bRecSeqNumCon);
+							pAsySdoSeqCon->
+							    m_bSendSeqNum =
+							    AmiGetByteFromLe
+							    (&pRecFrame_p->
+							     m_le_bSendSeqNumCon);
+							// set rcon and scon to 0
+							pAsySdoSeqCon->
+							    m_bSendSeqNum &=
+							    EPL_SEQ_NUM_MASK;
+							pAsySdoSeqCon->
+							    m_bRecSeqNum &=
+							    EPL_SEQ_NUM_MASK;
+							// send frame
+							EplSdoAsySeqSendIntern
+							    (pAsySdoSeqCon, 0,
+							     NULL, FALSE);
+						}
+						// call Command Layer Cb
+						AsySdoSequInstance_g.
+						    m_fpSdoComConCb
+						    (SdoSeqConHdl,
+						     kAsySdoConStateInitError);
+					}
+					break;
+				}
+
+				// timeout
+			case kAsySdoSeqEventTimeout:
+				{	// error -> Close
+					pAsySdoSeqCon->m_SdoState =
+					    kEplAsySdoStateIdle;
+					// set rcon and scon to 0
+					pAsySdoSeqCon->m_bSendSeqNum &=
+					    EPL_SEQ_NUM_MASK;
+					pAsySdoSeqCon->m_bRecSeqNum &=
+					    EPL_SEQ_NUM_MASK;
+					// send frame
+					EplSdoAsySeqSendIntern(pAsySdoSeqCon,
+							       0, NULL, FALSE);
+
+					// call Command Layer Cb
+					AsySdoSequInstance_g.
+					    m_fpSdoComConCb(SdoSeqConHdl,
+							    kAsySdoConStateInitError);
+					break;
+				}
+
+			default:
+				// d.k. do nothing
+				break;
+
+			}	// end of switch(Event_p)
+			break;
+		}
+
+		// init connection step 3
+	case kEplAsySdoStateInit3:
+		{
+			// check event
+			switch (Event_p) {
+				// frame received
+			case kAsySdoSeqEventFrameRec:
+				{
+					// check scon == 2 and rcon == 2
+					if (((pRecFrame_p->
+					      m_le_bRecSeqNumCon &
+					      EPL_ASY_SDO_CON_MASK) == 0x02)
+					    &&
+					    ((pRecFrame_p->
+					      m_le_bSendSeqNumCon &
+					      EPL_ASY_SDO_CON_MASK) == 0x02)) {
+						// save sequence numbers
+						pAsySdoSeqCon->m_bRecSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bRecSeqNumCon);
+						pAsySdoSeqCon->m_bSendSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bSendSeqNumCon);
+						// change state to kEplAsySdoStateConnected
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateConnected;
+
+						// set timer
+						Ret =
+						    EplSdoAsySeqSetTimer
+						    (pAsySdoSeqCon,
+						     EPL_SEQ_DEFAULT_TIMEOUT);
+						// call Command Layer Cb
+						AsySdoSequInstance_g.
+						    m_fpSdoComConCb
+						    (SdoSeqConHdl,
+						     kAsySdoConStateConnected);
+
+					}
+					// check scon == 2 and rcon == 1
+					else if (((pRecFrame_p->
+						   m_le_bRecSeqNumCon &
+						   EPL_ASY_SDO_CON_MASK) ==
+						  0x01)
+						 && ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 0x02)) {	// create answer own rcon = 2
+						// save sequence numbers
+						pAsySdoSeqCon->m_bRecSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bRecSeqNumCon);
+						pAsySdoSeqCon->m_bSendSeqNum =
+						    AmiGetByteFromLe
+						    (&pRecFrame_p->
+						     m_le_bSendSeqNumCon);
+
+						pAsySdoSeqCon->m_bRecSeqNum++;
+						Ret =
+						    EplSdoAsySeqSendIntern
+						    (pAsySdoSeqCon, 0, NULL,
+						     FALSE);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						// change state to kEplAsySdoStateConnected
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateConnected;
+
+						// set timer
+						Ret =
+						    EplSdoAsySeqSetTimer
+						    (pAsySdoSeqCon,
+						     EPL_SEQ_DEFAULT_TIMEOUT);
+
+						// call Command Layer Cb
+						AsySdoSequInstance_g.
+						    m_fpSdoComConCb
+						    (SdoSeqConHdl,
+						     kAsySdoConStateConnected);
+
+					} else {	// error -> Close
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateIdle;
+						// delete timer
+						EplTimeruDeleteTimer
+						    (&pAsySdoSeqCon->
+						     m_EplTimerHdl);
+						if (((pRecFrame_p->
+						      m_le_bRecSeqNumCon &
+						      EPL_ASY_SDO_CON_MASK) !=
+						     0x00)
+						    || ((pRecFrame_p->m_le_bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) != 0x00)) {	// d.k. only answer with close message if the message sent was not a close message
+							// save sequence numbers
+							pAsySdoSeqCon->
+							    m_bRecSeqNum =
+							    AmiGetByteFromLe
+							    (&pRecFrame_p->
+							     m_le_bRecSeqNumCon);
+							pAsySdoSeqCon->
+							    m_bSendSeqNum =
+							    AmiGetByteFromLe
+							    (&pRecFrame_p->
+							     m_le_bSendSeqNumCon);
+							// set rcon and scon to 0
+							pAsySdoSeqCon->
+							    m_bSendSeqNum &=
+							    EPL_SEQ_NUM_MASK;
+							pAsySdoSeqCon->
+							    m_bRecSeqNum &=
+							    EPL_SEQ_NUM_MASK;
+							// send frame
+							EplSdoAsySeqSendIntern
+							    (pAsySdoSeqCon, 0,
+							     NULL, FALSE);
+						}
+						// call Command Layer Cb
+						AsySdoSequInstance_g.
+						    m_fpSdoComConCb
+						    (SdoSeqConHdl,
+						     kAsySdoConStateInitError);
+					}
+					break;
+				}
+
+				// timeout
+			case kAsySdoSeqEventTimeout:
+				{	// error -> Close
+					pAsySdoSeqCon->m_SdoState =
+					    kEplAsySdoStateIdle;
+					// set rcon and scon to 0
+					pAsySdoSeqCon->m_bSendSeqNum &=
+					    EPL_SEQ_NUM_MASK;
+					pAsySdoSeqCon->m_bRecSeqNum &=
+					    EPL_SEQ_NUM_MASK;
+					// send frame
+					EplSdoAsySeqSendIntern(pAsySdoSeqCon,
+							       0, NULL, FALSE);
+
+					// call Command Layer Cb
+					AsySdoSequInstance_g.
+					    m_fpSdoComConCb(SdoSeqConHdl,
+							    kAsySdoConStateInitError);
+					break;
+				}
+
+			default:
+				// d.k. do nothing
+				break;
+
+			}	// end of switch(Event_p)
+			break;
+		}
+
+		// connection established
+	case kEplAsySdoStateConnected:
+		{
+			// check event
+			switch (Event_p) {
+
+				// frame to send
+			case kAsySdoSeqEventFrameSend:
+				{
+					// set timer
+					Ret =
+					    EplSdoAsySeqSetTimer(pAsySdoSeqCon,
+								 EPL_SEQ_DEFAULT_TIMEOUT);
+					// check if data frame or ack
+					if (pData_p == NULL) {	// send ack
+						// inc scon
+						//pAsySdoSeqCon->m_bRecSeqNum += 4;
+						Ret =
+						    EplSdoAsySeqSendIntern
+						    (pAsySdoSeqCon, 0, NULL,
+						     FALSE);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+					} else {	// send dataframe
+						// increment send sequence number
+						pAsySdoSeqCon->m_bRecSeqNum +=
+						    4;
+						Ret =
+						    EplSdoAsySeqSendIntern
+						    (pAsySdoSeqCon,
+						     uiDataSize_p, pData_p,
+						     TRUE);
+						if (Ret == kEplSdoSeqRequestAckNeeded) {	// request ack
+							// change state to wait ack
+							pAsySdoSeqCon->
+							    m_SdoState =
+							    kEplAsySdoStateWaitAck;
+							// set Ret to kEplSuccessful, because no error
+							// for higher layer
+							Ret = kEplSuccessful;
+
+						} else if (Ret !=
+							   kEplSuccessful) {
+							goto Exit;
+						} else {
+							// call Command Layer Cb
+							AsySdoSequInstance_g.
+							    m_fpSdoComConCb
+							    (SdoSeqConHdl,
+							     kAsySdoConStateFrameSended);
+						}
+					}
+					break;
+				}	// end of case kAsySdoSeqEventFrameSend
+
+				// frame received
+			case kAsySdoSeqEventFrameRec:
+				{
+					BYTE bSendSeqNumCon =
+					    AmiGetByteFromLe(&pRecFrame_p->
+							     m_le_bSendSeqNumCon);
+
+					// set timer
+					Ret =
+					    EplSdoAsySeqSetTimer(pAsySdoSeqCon,
+								 EPL_SEQ_DEFAULT_TIMEOUT);
+					// check scon
+					switch (bSendSeqNumCon &
+						EPL_ASY_SDO_CON_MASK) {
+						// close from other node
+					case 0:
+					case 1:
+						{
+							// return to idle
+							pAsySdoSeqCon->
+							    m_SdoState =
+							    kEplAsySdoStateIdle;
+							// delete timer
+							EplTimeruDeleteTimer
+							    (&pAsySdoSeqCon->
+							     m_EplTimerHdl);
+							// call Command Layer Cb
+							AsySdoSequInstance_g.
+							    m_fpSdoComConCb
+							    (SdoSeqConHdl,
+							     kAsySdoConStateConClosed);
+
+							break;
+						}
+
+						// Request Ack or Error Ack
+						// possible contain data
+					case 3:
+						// normal frame
+					case 2:
+						{
+							if ((AmiGetByteFromLe
+							     (&pRecFrame_p->
+							      m_le_bRecSeqNumCon)
+							     &
+							     EPL_ASY_SDO_CON_MASK)
+							    == 3) {
 //                                PRINTF0("EplSdoAsySequ: error response received\n");
 
-                                // error response (retransmission request)
-                                // resend frames from history
+								// error response (retransmission request)
+								// resend frames from history
 
-                                // read frame from history
-                                Ret = EplSdoAsyReadFromHistory(pAsySdoSeqCon,
-                                                                &pEplFrame,
-                                                                &uiFrameSize,
-                                                                TRUE);
-                                if (Ret != kEplSuccessful)
-                                {
-                                    goto Exit;
-                                }
-
-                                while ((pEplFrame != NULL)
-                                       && (uiFrameSize != 0))
-                                {
-                                    // send frame
-                                    Ret = EplSdoAsySeqSendLowerLayer(pAsySdoSeqCon,
-                                                        uiFrameSize,
-                                                        pEplFrame);
-                                    if(Ret != kEplSuccessful)
-                                    {
-                                        goto Exit;
-                                    }
-
-                                    // read next frame from history
-                                    Ret = EplSdoAsyReadFromHistory(pAsySdoSeqCon,
-                                                                    &pEplFrame,
-                                                                    &uiFrameSize,
-                                                                    FALSE);
-                                    if(Ret != kEplSuccessful)
-                                    {
-                                        goto Exit;
-                                    }
-                                } // end of while((pabFrame != NULL)
-                            }   // end of if (error response)
-
-                            if (((pAsySdoSeqCon->m_bSendSeqNum + 4) & EPL_SEQ_NUM_MASK) == (bSendSeqNumCon & EPL_SEQ_NUM_MASK))
-                            {   // next frame of sequence received
-                                // save send sequence number (without ack request)
-                                pAsySdoSeqCon->m_bSendSeqNum = bSendSeqNumCon & ~0x01;
-
-                                // check if ack or data-frame
-                                //ignore ack -> already processed
-                                if(uiDataSize_p > EPL_SEQ_HEADER_SIZE)
-                                {
-                                    AsySdoSequInstance_g.m_fpSdoComReceiveCb(
-                                                        SdoSeqConHdl,
-                                                        ((tEplAsySdoCom*) &pRecFrame_p->m_le_abSdoSeqPayload),
-                                                        (uiDataSize_p - EPL_SEQ_HEADER_SIZE));
-                                    // call Command Layer Cb
-                                    AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                                kAsySdoConStateFrameSended);
-
-
-                                }
-                                else
-                                {
-                                    // call Command Layer Cb
-                                    AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                        kAsySdoConStateAckReceived);
-                                }
-                            }
-                            else if (((bSendSeqNumCon - pAsySdoSeqCon->m_bSendSeqNum - 4) & EPL_SEQ_NUM_MASK) < EPL_SEQ_NUM_THRESHOLD)
-                            {   // frame of sequence was lost,
-                                // because difference of received and old value
-                                // is less then halve of the values range.
-
-                                // send error frame with own rcon = 3
-                                pAsySdoSeqCon->m_bSendSeqNum |= 0x03;
-                                Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                        0,
-                                                        NULL,
-                                                        FALSE);
-                                // restore send sequence number
-                                pAsySdoSeqCon->m_bSendSeqNum = (pAsySdoSeqCon->m_bSendSeqNum & EPL_SEQ_NUM_MASK) | 0x02;
-                                if(Ret != kEplSuccessful)
-                                {
-                                    goto Exit;
-                                }
-
-                                // break here, because a requested acknowledge
-                                // was sent implicitly above
-                                break;
-                            }
-                            // else, ignore repeated frame
-
-                            if ((bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 3)
-                            {   // ack request received
-
-                                // create ack with own scon = 2
-                                Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                        0,
-                                                        NULL,
-                                                        FALSE);
-                                if(Ret != kEplSuccessful)
-                                {
-                                    goto Exit;
-                                }
-                            }
-
-                            break;
-                        }
-
-                    } // switch(pAsySdoSeqCon->m_bSendSeqNum & EPL_ASY_SDO_CON_MASK)
-                    break;
-                } // end of case kAsySdoSeqEventFrameRec:
-
-
-                //close event from higher layer
-                case kAsySdoSeqEventCloseCon:
-                {
-                    pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-                    // set rcon and scon to 0
-                    pAsySdoSeqCon->m_bSendSeqNum &= EPL_SEQ_NUM_MASK;
-                    pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
-                    // send frame
-                    EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                 0,
-                                                 NULL,
-                                                 FALSE);
-
-                    // delete timer
-                    EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
-                    // call Command Layer Cb is not necessary, because the event came from there
+								// read frame from history
+								Ret =
+								    EplSdoAsyReadFromHistory
+								    (pAsySdoSeqCon,
+								     &pEplFrame,
+								     &uiFrameSize,
+								     TRUE);
+								if (Ret !=
+								    kEplSuccessful)
+								{
+									goto Exit;
+								}
+
+								while ((pEplFrame != NULL)
+								       &&
+								       (uiFrameSize
+									!= 0)) {
+									// send frame
+									Ret =
+									    EplSdoAsySeqSendLowerLayer
+									    (pAsySdoSeqCon,
+									     uiFrameSize,
+									     pEplFrame);
+									if (Ret
+									    !=
+									    kEplSuccessful)
+									{
+										goto Exit;
+									}
+									// read next frame from history
+									Ret =
+									    EplSdoAsyReadFromHistory
+									    (pAsySdoSeqCon,
+									     &pEplFrame,
+									     &uiFrameSize,
+									     FALSE);
+									if (Ret
+									    !=
+									    kEplSuccessful)
+									{
+										goto Exit;
+									}
+								}	// end of while((pabFrame != NULL)
+							}	// end of if (error response)
+
+							if (((pAsySdoSeqCon->m_bSendSeqNum + 4) & EPL_SEQ_NUM_MASK) == (bSendSeqNumCon & EPL_SEQ_NUM_MASK)) {	// next frame of sequence received
+								// save send sequence number (without ack request)
+								pAsySdoSeqCon->
+								    m_bSendSeqNum
+								    =
+								    bSendSeqNumCon
+								    & ~0x01;
+
+								// check if ack or data-frame
+								//ignore ack -> already processed
+								if (uiDataSize_p
+								    >
+								    EPL_SEQ_HEADER_SIZE)
+								{
+									AsySdoSequInstance_g.
+									    m_fpSdoComReceiveCb
+									    (SdoSeqConHdl,
+									     ((tEplAsySdoCom *) & pRecFrame_p->m_le_abSdoSeqPayload), (uiDataSize_p - EPL_SEQ_HEADER_SIZE));
+									// call Command Layer Cb
+									AsySdoSequInstance_g.
+									    m_fpSdoComConCb
+									    (SdoSeqConHdl,
+									     kAsySdoConStateFrameSended);
+
+								} else {
+									// call Command Layer Cb
+									AsySdoSequInstance_g.
+									    m_fpSdoComConCb
+									    (SdoSeqConHdl,
+									     kAsySdoConStateAckReceived);
+								}
+							} else if (((bSendSeqNumCon - pAsySdoSeqCon->m_bSendSeqNum - 4) & EPL_SEQ_NUM_MASK) < EPL_SEQ_NUM_THRESHOLD) {	// frame of sequence was lost,
+								// because difference of received and old value
+								// is less then halve of the values range.
+
+								// send error frame with own rcon = 3
+								pAsySdoSeqCon->
+								    m_bSendSeqNum
+								    |= 0x03;
+								Ret =
+								    EplSdoAsySeqSendIntern
+								    (pAsySdoSeqCon,
+								     0, NULL,
+								     FALSE);
+								// restore send sequence number
+								pAsySdoSeqCon->
+								    m_bSendSeqNum
+								    =
+								    (pAsySdoSeqCon->
+								     m_bSendSeqNum
+								     &
+								     EPL_SEQ_NUM_MASK)
+								    | 0x02;
+								if (Ret !=
+								    kEplSuccessful)
+								{
+									goto Exit;
+								}
+								// break here, because a requested acknowledge
+								// was sent implicitly above
+								break;
+							}
+							// else, ignore repeated frame
+
+							if ((bSendSeqNumCon & EPL_ASY_SDO_CON_MASK) == 3) {	// ack request received
+
+								// create ack with own scon = 2
+								Ret =
+								    EplSdoAsySeqSendIntern
+								    (pAsySdoSeqCon,
+								     0, NULL,
+								     FALSE);
+								if (Ret !=
+								    kEplSuccessful)
+								{
+									goto Exit;
+								}
+							}
+
+							break;
+						}
+
+					}	// switch(pAsySdoSeqCon->m_bSendSeqNum & EPL_ASY_SDO_CON_MASK)
+					break;
+				}	// end of case kAsySdoSeqEventFrameRec:
+
+				//close event from higher layer
+			case kAsySdoSeqEventCloseCon:
+				{
+					pAsySdoSeqCon->m_SdoState =
+					    kEplAsySdoStateIdle;
+					// set rcon and scon to 0
+					pAsySdoSeqCon->m_bSendSeqNum &=
+					    EPL_SEQ_NUM_MASK;
+					pAsySdoSeqCon->m_bRecSeqNum &=
+					    EPL_SEQ_NUM_MASK;
+					// send frame
+					EplSdoAsySeqSendIntern(pAsySdoSeqCon,
+							       0, NULL, FALSE);
+
+					// delete timer
+					EplTimeruDeleteTimer(&pAsySdoSeqCon->
+							     m_EplTimerHdl);
+					// call Command Layer Cb is not necessary, because the event came from there
 //                    AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
 //                                                            kAsySdoConStateInitError);
-                    break;
-                }
-
-                // timeout
-                case kAsySdoSeqEventTimeout:
-                {
-
-                    uiFreeEntries = EplSdoAsyGetFreeEntriesFromHistory(pAsySdoSeqCon);
-                    if ((uiFreeEntries < EPL_SDO_HISTORY_SIZE)
-                        && (pAsySdoSeqCon->m_uiRetryCount < EPL_SEQ_RETRY_COUNT))
-                    {   // unacknowlegded frames in history
-                        // and retry counter not exceeded
-
-                        // resend data with acknowledge request
-
-                        // increment retry counter
-                        pAsySdoSeqCon->m_uiRetryCount++;
-
-                        // set timer
-                        Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                                EPL_SEQ_DEFAULT_TIMEOUT);
-
-                        // read first frame from history
-                        Ret = EplSdoAsyReadFromHistory(pAsySdoSeqCon,
-                                                        &pEplFrame,
-                                                        &uiFrameSize,
-                                                        TRUE);
-                        if (Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-
-                        if ((pEplFrame != NULL)
-                               && (uiFrameSize != 0))
-                        {
-
-                            // set ack request in scon
-                            AmiSetByteToLe( &pEplFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.m_le_bSendSeqNumCon,
-                                    AmiGetByteFromLe( &pEplFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.m_le_bSendSeqNumCon) | 0x03);
-
-                            // send frame
-                            Ret = EplSdoAsySeqSendLowerLayer(pAsySdoSeqCon,
-                                                uiFrameSize,
-                                                pEplFrame);
-                            if(Ret != kEplSuccessful)
-                            {
-                                goto Exit;
-                            }
-
-                        }
-                    }
-                    else
-                    {
-                        // timeout, because of no traffic -> Close
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-                        // set rcon and scon to 0
-                        pAsySdoSeqCon->m_bSendSeqNum &= EPL_SEQ_NUM_MASK;
-                        pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
-                        // send frame
-                        EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                    0,
-                                                    NULL,
-                                                    FALSE);
-
-                        // call Command Layer Cb
-                        AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                                kAsySdoConStateTimeout);
-                    }
-
-                    break;
-                }
-
-                default:
-                    // d.k. do nothing
-                    break;
-
-            }// end of switch(Event_p)
-            break;
-        }
-
-        // wait for Acknowledge (history buffer full)
-        case kEplAsySdoStateWaitAck:
-        {
-            PRINTF0("EplSdoAsySequ: StateWaitAck\n");
-
-            // set timer
-            Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
-                                        EPL_SEQ_DEFAULT_TIMEOUT);
-
-            //TODO: retry of acknowledge
-            if(Event_p == kAsySdoSeqEventFrameRec)
-            {
-                // check rcon
-                switch(pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK)
-                {
-                    // close-frome other node
-                    case 0:
-                    {
-                        // return to idle
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-                        // delete timer
-                        EplTimeruDeleteTimer(&pAsySdoSeqCon->m_EplTimerHdl);
-                        // call Command Layer Cb
-                        AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                kAsySdoConStateConClosed);
-
-                        break;
-                    }
-
-                    // normal frame
-                    case 2:
-                    {
-                        // should be ack
-                        // -> change to state kEplAsySdoStateConnected
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateConnected;
-                        // call Command Layer Cb
-                        AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                                kAsySdoConStateAckReceived);
-                        // send data to higher layer if needed
-                        if(uiDataSize_p > EPL_SEQ_HEADER_SIZE)
-                        {
-                            AsySdoSequInstance_g.m_fpSdoComReceiveCb(
-                                                SdoSeqConHdl,
-                                                ((tEplAsySdoCom*) &pRecFrame_p->m_le_abSdoSeqPayload),
-                                                (uiDataSize_p - EPL_SEQ_HEADER_SIZE));
-                        }
-                        break;
-                    }
-
-                    // Request Ack or Error Ack
-                    case 3:
-                    {
-                        // -> change to state kEplAsySdoStateConnected
-                        pAsySdoSeqCon->m_SdoState = kEplAsySdoStateConnected;
-
-                        if(pRecFrame_p->m_le_bRecSeqNumCon == pAsySdoSeqCon->m_bRecSeqNum )
-                        {   // ack request
-                            // -> send ack
-                            // save sequence numbers
-                            pAsySdoSeqCon->m_bRecSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bRecSeqNumCon);
-                            pAsySdoSeqCon->m_bSendSeqNum = AmiGetByteFromLe(&pRecFrame_p->m_le_bSendSeqNumCon);
-
-                            // create answer own rcon = 2
-                            pAsySdoSeqCon->m_bRecSeqNum--;
-
-                            // check if ack or data-frame
-                            if(uiDataSize_p > EPL_SEQ_HEADER_SIZE)
-                            {
-                                AsySdoSequInstance_g.m_fpSdoComReceiveCb(
-                                                    SdoSeqConHdl,
-                                                    ((tEplAsySdoCom*) &pRecFrame_p->m_le_abSdoSeqPayload),
-                                                    (uiDataSize_p - EPL_SEQ_HEADER_SIZE));
-                                // call Command Layer Cb
-                                AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                            kAsySdoConStateFrameSended);
-
-
-                            }
-                            else
-                            {
-                                Ret = EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                                        0,
-                                                        NULL,
-                                                        FALSE);
-                                if(Ret != kEplSuccessful)
-                                {
-                                    goto Exit;
-                                }
-                            }
-
-                        }
-                        else
-                        {
-                            // error ack
-                            // resend frames from history
-
-                            // read frame from history
-                            Ret = EplSdoAsyReadFromHistory(pAsySdoSeqCon,
-                                                            &pEplFrame,
-                                                            &uiFrameSize,
-                                                            TRUE);
-                            while ((pEplFrame != NULL)
-                                    && (uiFrameSize != 0))
-                            {
-                                // send frame
-                                Ret = EplSdoAsySeqSendLowerLayer(pAsySdoSeqCon,
-                                                    uiFrameSize,
-                                                    pEplFrame);
-                                if(Ret != kEplSuccessful)
-                                {
-                                    goto Exit;
-                                }
-                                // read next frame
-
-                                // read frame from history
-                                Ret = EplSdoAsyReadFromHistory(pAsySdoSeqCon,
-                                                                &pEplFrame,
-                                                                &uiFrameSize,
-                                                                FALSE);
-                            } // end of while((pabFrame != NULL)
-                        }
-                        break;
-                    }
-                }// end of switch(pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK)
-
-            }
-            else if(Event_p == kAsySdoSeqEventTimeout)
-            {   // error -> Close
-                pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
-                // set rcon and scon to 0
-                pAsySdoSeqCon->m_bSendSeqNum &= EPL_SEQ_NUM_MASK;
-                pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
-                // send frame
-                EplSdoAsySeqSendIntern(pAsySdoSeqCon,
-                                            0,
-                                            NULL,
-                                            FALSE);
-
-                // call Command Layer Cb
-                AsySdoSequInstance_g.m_fpSdoComConCb(SdoSeqConHdl,
-                                                        kAsySdoConStateTimeout);
-            }
-
-            break;
-        }
-
-        // unknown state
-        default:
-        {
-            EPL_DBGLVL_SDO_TRACE0("Error: Unknown State in EplSdoAsySeqProcess\n");
-
-        }
-    }// end of switch(pAsySdoSeqCon->m_SdoState)
+					break;
+				}
 
+				// timeout
+			case kAsySdoSeqEventTimeout:
+				{
+
+					uiFreeEntries =
+					    EplSdoAsyGetFreeEntriesFromHistory
+					    (pAsySdoSeqCon);
+					if ((uiFreeEntries <
+					     EPL_SDO_HISTORY_SIZE)
+					    && (pAsySdoSeqCon->m_uiRetryCount < EPL_SEQ_RETRY_COUNT)) {	// unacknowlegded frames in history
+						// and retry counter not exceeded
+
+						// resend data with acknowledge request
+
+						// increment retry counter
+						pAsySdoSeqCon->m_uiRetryCount++;
+
+						// set timer
+						Ret =
+						    EplSdoAsySeqSetTimer
+						    (pAsySdoSeqCon,
+						     EPL_SEQ_DEFAULT_TIMEOUT);
+
+						// read first frame from history
+						Ret =
+						    EplSdoAsyReadFromHistory
+						    (pAsySdoSeqCon, &pEplFrame,
+						     &uiFrameSize, TRUE);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+
+						if ((pEplFrame != NULL)
+						    && (uiFrameSize != 0)) {
+
+							// set ack request in scon
+							AmiSetByteToLe
+							    (&pEplFrame->m_Data.
+							     m_Asnd.m_Payload.
+							     m_SdoSequenceFrame.
+							     m_le_bSendSeqNumCon,
+							     AmiGetByteFromLe
+							     (&pEplFrame->
+							      m_Data.m_Asnd.
+							      m_Payload.
+							      m_SdoSequenceFrame.
+							      m_le_bSendSeqNumCon)
+							     | 0x03);
+
+							// send frame
+							Ret =
+							    EplSdoAsySeqSendLowerLayer
+							    (pAsySdoSeqCon,
+							     uiFrameSize,
+							     pEplFrame);
+							if (Ret !=
+							    kEplSuccessful) {
+								goto Exit;
+							}
+
+						}
+					} else {
+						// timeout, because of no traffic -> Close
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateIdle;
+						// set rcon and scon to 0
+						pAsySdoSeqCon->m_bSendSeqNum &=
+						    EPL_SEQ_NUM_MASK;
+						pAsySdoSeqCon->m_bRecSeqNum &=
+						    EPL_SEQ_NUM_MASK;
+						// send frame
+						EplSdoAsySeqSendIntern
+						    (pAsySdoSeqCon, 0, NULL,
+						     FALSE);
+
+						// call Command Layer Cb
+						AsySdoSequInstance_g.
+						    m_fpSdoComConCb
+						    (SdoSeqConHdl,
+						     kAsySdoConStateTimeout);
+					}
+
+					break;
+				}
+
+			default:
+				// d.k. do nothing
+				break;
+
+			}	// end of switch(Event_p)
+			break;
+		}
+
+		// wait for Acknowledge (history buffer full)
+	case kEplAsySdoStateWaitAck:
+		{
+			PRINTF0("EplSdoAsySequ: StateWaitAck\n");
+
+			// set timer
+			Ret = EplSdoAsySeqSetTimer(pAsySdoSeqCon,
+						   EPL_SEQ_DEFAULT_TIMEOUT);
+
+			//TODO: retry of acknowledge
+			if (Event_p == kAsySdoSeqEventFrameRec) {
+				// check rcon
+				switch (pRecFrame_p->
+					m_le_bRecSeqNumCon &
+					EPL_ASY_SDO_CON_MASK) {
+					// close-frome other node
+				case 0:
+					{
+						// return to idle
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateIdle;
+						// delete timer
+						EplTimeruDeleteTimer
+						    (&pAsySdoSeqCon->
+						     m_EplTimerHdl);
+						// call Command Layer Cb
+						AsySdoSequInstance_g.
+						    m_fpSdoComConCb
+						    (SdoSeqConHdl,
+						     kAsySdoConStateConClosed);
+
+						break;
+					}
+
+					// normal frame
+				case 2:
+					{
+						// should be ack
+						// -> change to state kEplAsySdoStateConnected
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateConnected;
+						// call Command Layer Cb
+						AsySdoSequInstance_g.
+						    m_fpSdoComConCb
+						    (SdoSeqConHdl,
+						     kAsySdoConStateAckReceived);
+						// send data to higher layer if needed
+						if (uiDataSize_p >
+						    EPL_SEQ_HEADER_SIZE) {
+							AsySdoSequInstance_g.
+							    m_fpSdoComReceiveCb
+							    (SdoSeqConHdl,
+							     ((tEplAsySdoCom *)
+							      & pRecFrame_p->
+							      m_le_abSdoSeqPayload),
+							     (uiDataSize_p -
+							      EPL_SEQ_HEADER_SIZE));
+						}
+						break;
+					}
+
+					// Request Ack or Error Ack
+				case 3:
+					{
+						// -> change to state kEplAsySdoStateConnected
+						pAsySdoSeqCon->m_SdoState =
+						    kEplAsySdoStateConnected;
+
+						if (pRecFrame_p->m_le_bRecSeqNumCon == pAsySdoSeqCon->m_bRecSeqNum) {	// ack request
+							// -> send ack
+							// save sequence numbers
+							pAsySdoSeqCon->
+							    m_bRecSeqNum =
+							    AmiGetByteFromLe
+							    (&pRecFrame_p->
+							     m_le_bRecSeqNumCon);
+							pAsySdoSeqCon->
+							    m_bSendSeqNum =
+							    AmiGetByteFromLe
+							    (&pRecFrame_p->
+							     m_le_bSendSeqNumCon);
+
+							// create answer own rcon = 2
+							pAsySdoSeqCon->
+							    m_bRecSeqNum--;
+
+							// check if ack or data-frame
+							if (uiDataSize_p >
+							    EPL_SEQ_HEADER_SIZE)
+							{
+								AsySdoSequInstance_g.
+								    m_fpSdoComReceiveCb
+								    (SdoSeqConHdl,
+								     ((tEplAsySdoCom *) & pRecFrame_p->m_le_abSdoSeqPayload), (uiDataSize_p - EPL_SEQ_HEADER_SIZE));
+								// call Command Layer Cb
+								AsySdoSequInstance_g.
+								    m_fpSdoComConCb
+								    (SdoSeqConHdl,
+								     kAsySdoConStateFrameSended);
+
+							} else {
+								Ret =
+								    EplSdoAsySeqSendIntern
+								    (pAsySdoSeqCon,
+								     0, NULL,
+								     FALSE);
+								if (Ret !=
+								    kEplSuccessful)
+								{
+									goto Exit;
+								}
+							}
+
+						} else {
+							// error ack
+							// resend frames from history
+
+							// read frame from history
+							Ret =
+							    EplSdoAsyReadFromHistory
+							    (pAsySdoSeqCon,
+							     &pEplFrame,
+							     &uiFrameSize,
+							     TRUE);
+							while ((pEplFrame !=
+								NULL)
+							       && (uiFrameSize
+								   != 0)) {
+								// send frame
+								Ret =
+								    EplSdoAsySeqSendLowerLayer
+								    (pAsySdoSeqCon,
+								     uiFrameSize,
+								     pEplFrame);
+								if (Ret !=
+								    kEplSuccessful)
+								{
+									goto Exit;
+								}
+								// read next frame
+
+								// read frame from history
+								Ret =
+								    EplSdoAsyReadFromHistory
+								    (pAsySdoSeqCon,
+								     &pEplFrame,
+								     &uiFrameSize,
+								     FALSE);
+							}	// end of while((pabFrame != NULL)
+						}
+						break;
+					}
+				}	// end of switch(pRecFrame_p->m_le_bRecSeqNumCon & EPL_ASY_SDO_CON_MASK)
+
+			} else if (Event_p == kAsySdoSeqEventTimeout) {	// error -> Close
+				pAsySdoSeqCon->m_SdoState = kEplAsySdoStateIdle;
+				// set rcon and scon to 0
+				pAsySdoSeqCon->m_bSendSeqNum &=
+				    EPL_SEQ_NUM_MASK;
+				pAsySdoSeqCon->m_bRecSeqNum &= EPL_SEQ_NUM_MASK;
+				// send frame
+				EplSdoAsySeqSendIntern(pAsySdoSeqCon,
+						       0, NULL, FALSE);
+
+				// call Command Layer Cb
+				AsySdoSequInstance_g.
+				    m_fpSdoComConCb(SdoSeqConHdl,
+						    kAsySdoConStateTimeout);
+			}
+
+			break;
+		}
+
+		// unknown state
+	default:
+		{
+			EPL_DBGLVL_SDO_TRACE0
+			    ("Error: Unknown State in EplSdoAsySeqProcess\n");
 
+		}
+	}			// end of switch(pAsySdoSeqCon->m_SdoState)
 
-Exit:
+      Exit:
 
 #if defined(WIN32) || defined(_WIN32)
-    // leave critical section for process function
-    LeaveCriticalSection(AsySdoSequInstance_g.m_pCriticalSection);
+	// leave critical section for process function
+	LeaveCriticalSection(AsySdoSequInstance_g.m_pCriticalSection);
 #endif
-    return Ret;
+	return Ret;
 
 }
 
@@ -1847,77 +2010,67 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel EplSdoAsySeqSendIntern(tEplAsySdoSeqCon*  pAsySdoSeqCon_p,
-                                         unsigned int       uiDataSize_p,
-                                         tEplFrame*         pData_p,
-                                         BOOL               fFrameInHistory_p)
-{
-tEplKernel      Ret;
-BYTE            abFrame[EPL_SEQ_FRAME_SIZE];
-tEplFrame*      pEplFrame;
-unsigned int    uiFreeEntries;
-
-    if(pData_p == NULL)
-    {   // set pointer to own frame
-        EPL_MEMSET(&abFrame[0], 0x00, sizeof(abFrame));
-        pEplFrame = (tEplFrame*)&abFrame[0];
-    }
-    else
-    {   // set pointer to frame from calling function
-        pEplFrame = pData_p;
-    }
-
-    if(fFrameInHistory_p != FALSE)
-    {
-        // check if only one free entry in history buffer
-        uiFreeEntries = EplSdoAsyGetFreeEntriesFromHistory(pAsySdoSeqCon_p);
-        if(uiFreeEntries == 1)
-        {   // request an acknowledge in dataframe
-            // own scon = 3
-            pAsySdoSeqCon_p->m_bRecSeqNum |= 0x03;
-        }
-    }
-
-    // fillin header informations
-    // set service id sdo
-    AmiSetByteToLe( &pEplFrame->m_Data.m_Asnd.m_le_bServiceId, 0x05);
-    AmiSetByteToLe( &pEplFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.m_le_abReserved,0x00);
-    // set receive sequence number and rcon
-    AmiSetByteToLe( &pEplFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.m_le_bRecSeqNumCon, pAsySdoSeqCon_p->m_bSendSeqNum);
-    // set send sequence number and scon
-    AmiSetByteToLe( &pEplFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.m_le_bSendSeqNumCon, pAsySdoSeqCon_p->m_bRecSeqNum);
-
-    // add size
-    uiDataSize_p += EPL_SEQ_HEADER_SIZE;
-
-
-    // forward frame to appropriate lower layer
-    Ret = EplSdoAsySeqSendLowerLayer(pAsySdoSeqCon_p,
-                                     uiDataSize_p,
-                                     pEplFrame);    // pointer to frame
-
-    // check if all allright
-    if ((Ret == kEplSuccessful)
-        && (fFrameInHistory_p != FALSE))
-    {
-        // set own scon to 2 if needed
-        if((pAsySdoSeqCon_p->m_bRecSeqNum & 0x03) == 0x03)
-        {
-            pAsySdoSeqCon_p->m_bRecSeqNum--;
-        }
-
-        // save frame to history
-        Ret = EplSdoAsyAddFrameToHistory(pAsySdoSeqCon_p,
-                                            pEplFrame,
-                                            uiDataSize_p);
-        if (Ret == kEplSdoSeqNoFreeHistory)
-        {   // request Ack needed
-            Ret = kEplSdoSeqRequestAckNeeded;
-        }
+static tEplKernel EplSdoAsySeqSendIntern(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+					 unsigned int uiDataSize_p,
+					 tEplFrame * pData_p,
+					 BOOL fFrameInHistory_p)
+{
+	tEplKernel Ret;
+	BYTE abFrame[EPL_SEQ_FRAME_SIZE];
+	tEplFrame *pEplFrame;
+	unsigned int uiFreeEntries;
+
+	if (pData_p == NULL) {	// set pointer to own frame
+		EPL_MEMSET(&abFrame[0], 0x00, sizeof(abFrame));
+		pEplFrame = (tEplFrame *) & abFrame[0];
+	} else {		// set pointer to frame from calling function
+		pEplFrame = pData_p;
+	}
+
+	if (fFrameInHistory_p != FALSE) {
+		// check if only one free entry in history buffer
+		uiFreeEntries =
+		    EplSdoAsyGetFreeEntriesFromHistory(pAsySdoSeqCon_p);
+		if (uiFreeEntries == 1) {	// request an acknowledge in dataframe
+			// own scon = 3
+			pAsySdoSeqCon_p->m_bRecSeqNum |= 0x03;
+		}
+	}
+	// fillin header informations
+	// set service id sdo
+	AmiSetByteToLe(&pEplFrame->m_Data.m_Asnd.m_le_bServiceId, 0x05);
+	AmiSetByteToLe(&pEplFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.
+		       m_le_abReserved, 0x00);
+	// set receive sequence number and rcon
+	AmiSetByteToLe(&pEplFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.
+		       m_le_bRecSeqNumCon, pAsySdoSeqCon_p->m_bSendSeqNum);
+	// set send sequence number and scon
+	AmiSetByteToLe(&pEplFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.
+		       m_le_bSendSeqNumCon, pAsySdoSeqCon_p->m_bRecSeqNum);
+
+	// add size
+	uiDataSize_p += EPL_SEQ_HEADER_SIZE;
+
+	// forward frame to appropriate lower layer
+	Ret = EplSdoAsySeqSendLowerLayer(pAsySdoSeqCon_p, uiDataSize_p, pEplFrame);	// pointer to frame
+
+	// check if all allright
+	if ((Ret == kEplSuccessful)
+	    && (fFrameInHistory_p != FALSE)) {
+		// set own scon to 2 if needed
+		if ((pAsySdoSeqCon_p->m_bRecSeqNum & 0x03) == 0x03) {
+			pAsySdoSeqCon_p->m_bRecSeqNum--;
+		}
+		// save frame to history
+		Ret = EplSdoAsyAddFrameToHistory(pAsySdoSeqCon_p,
+						 pEplFrame, uiDataSize_p);
+		if (Ret == kEplSdoSeqNoFreeHistory) {	// request Ack needed
+			Ret = kEplSdoSeqRequestAckNeeded;
+		}
 
-    }
+	}
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1937,41 +2090,34 @@ unsigned int    uiFreeEntries;
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel EplSdoAsySeqSendLowerLayer(tEplAsySdoSeqCon*  pAsySdoSeqCon_p,
-                                         unsigned int       uiDataSize_p,
-                                         tEplFrame*         pEplFrame_p)
-{
-tEplKernel      Ret;
-
-    // call send-function
-    // check handle for UDP or Asnd
-    if ((pAsySdoSeqCon_p->m_ConHandle & EPL_SDO_ASY_HANDLE_MASK) == EPL_SDO_UDP_HANDLE)
-    {   // send over UDP
+static tEplKernel EplSdoAsySeqSendLowerLayer(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+					     unsigned int uiDataSize_p,
+					     tEplFrame * pEplFrame_p)
+{
+	tEplKernel Ret;
+
+	// call send-function
+	// check handle for UDP or Asnd
+	if ((pAsySdoSeqCon_p->m_ConHandle & EPL_SDO_ASY_HANDLE_MASK) == EPL_SDO_UDP_HANDLE) {	// send over UDP
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
-        Ret = EplSdoUdpuSendData(pAsySdoSeqCon_p->m_ConHandle,
-                                    pEplFrame_p,      // pointer to frame
-                                    uiDataSize_p);
+		Ret = EplSdoUdpuSendData(pAsySdoSeqCon_p->m_ConHandle, pEplFrame_p,	// pointer to frame
+					 uiDataSize_p);
 #else
-        Ret = kEplSdoSeqUnsupportedProt;
+		Ret = kEplSdoSeqUnsupportedProt;
 #endif
 
-    }
-    else if ((pAsySdoSeqCon_p->m_ConHandle & EPL_SDO_ASY_HANDLE_MASK) == EPL_SDO_ASND_HANDLE)
-    {   // ASND
+	} else if ((pAsySdoSeqCon_p->m_ConHandle & EPL_SDO_ASY_HANDLE_MASK) == EPL_SDO_ASND_HANDLE) {	// ASND
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_ASND)) != 0)
-        Ret = EplSdoAsnduSendData(pAsySdoSeqCon_p->m_ConHandle,
-                                    pEplFrame_p,      // pointer to frame
-                                    uiDataSize_p);
+		Ret = EplSdoAsnduSendData(pAsySdoSeqCon_p->m_ConHandle, pEplFrame_p,	// pointer to frame
+					  uiDataSize_p);
 #else
-        Ret = kEplSdoSeqUnsupportedProt;
+		Ret = kEplSdoSeqUnsupportedProt;
 #endif
-    }
-    else
-    {   // error
-        Ret =  kEplSdoSeqInvalidHdl;
-    }
+	} else {		// error
+		Ret = kEplSdoSeqInvalidHdl;
+	}
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -1993,82 +2139,73 @@ tEplKernel      Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoAsyReceiveCb (
-                tEplSdoConHdl       ConHdl_p,
-                tEplAsySdoSeq*      pSdoSeqData_p,
-                unsigned int        uiDataSize_p)
-{
-tEplKernel          Ret;
-unsigned int        uiCount = 0;
-unsigned int        uiFreeEntry = EPL_MAX_SDO_SEQ_CON;
-tEplAsySdoSeqCon*   pAsySdoSeqCon;
+tEplKernel PUBLIC EplSdoAsyReceiveCb(tEplSdoConHdl ConHdl_p,
+				     tEplAsySdoSeq * pSdoSeqData_p,
+				     unsigned int uiDataSize_p)
+{
+	tEplKernel Ret;
+	unsigned int uiCount = 0;
+	unsigned int uiFreeEntry = EPL_MAX_SDO_SEQ_CON;
+	tEplAsySdoSeqCon *pAsySdoSeqCon;
 
 #if defined(WIN32) || defined(_WIN32)
-    // enter  critical section
-    EnterCriticalSection(AsySdoSequInstance_g.m_pCriticalSectionReceive);
+	// enter  critical section
+	EnterCriticalSection(AsySdoSequInstance_g.m_pCriticalSectionReceive);
 #endif
 
-    EPL_DBGLVL_SDO_TRACE2("Handle: 0x%x , First Databyte 0x%x\n", ConHdl_p,((BYTE*)pSdoSeqData_p)[0]);
-
-    // search controll structure for this connection
-    pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[uiCount];
-    while (uiCount < EPL_MAX_SDO_SEQ_CON)
-    {
-        if (pAsySdoSeqCon->m_ConHandle == ConHdl_p)
-        {
-            break;
-        }
-        else if ((pAsySdoSeqCon->m_ConHandle == 0)
-            && (uiFreeEntry == EPL_MAX_SDO_SEQ_CON))
-        {
-            // free entry
-            uiFreeEntry = uiCount;
-        }
-        uiCount++;
-        pAsySdoSeqCon++;
-    }
-
-    if (uiCount == EPL_MAX_SDO_SEQ_CON)
-    {   // new connection
-        if (uiFreeEntry == EPL_MAX_SDO_SEQ_CON)
-        {
-            Ret = kEplSdoSeqNoFreeHandle;
-            goto Exit;
-        }
-        else
-        {
-            pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[uiFreeEntry];
-            // save handle from lower layer
-            pAsySdoSeqCon->m_ConHandle = ConHdl_p;
-            // increment use counter
-            pAsySdoSeqCon->m_uiUseCount++;
-            uiCount = uiFreeEntry ;
-        }
-    }
-
-    // call history ack function
-    Ret = EplSdoAsyAckFrameToHistory(pAsySdoSeqCon,
-        (AmiGetByteFromLe(&pSdoSeqData_p->m_le_bRecSeqNumCon)& EPL_SEQ_NUM_MASK));
-    if (Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	EPL_DBGLVL_SDO_TRACE2("Handle: 0x%x , First Databyte 0x%x\n", ConHdl_p,
+			      ((BYTE *) pSdoSeqData_p)[0]);
 
+	// search controll structure for this connection
+	pAsySdoSeqCon = &AsySdoSequInstance_g.m_AsySdoConnection[uiCount];
+	while (uiCount < EPL_MAX_SDO_SEQ_CON) {
+		if (pAsySdoSeqCon->m_ConHandle == ConHdl_p) {
+			break;
+		} else if ((pAsySdoSeqCon->m_ConHandle == 0)
+			   && (uiFreeEntry == EPL_MAX_SDO_SEQ_CON)) {
+			// free entry
+			uiFreeEntry = uiCount;
+		}
+		uiCount++;
+		pAsySdoSeqCon++;
+	}
+
+	if (uiCount == EPL_MAX_SDO_SEQ_CON) {	// new connection
+		if (uiFreeEntry == EPL_MAX_SDO_SEQ_CON) {
+			Ret = kEplSdoSeqNoFreeHandle;
+			goto Exit;
+		} else {
+			pAsySdoSeqCon =
+			    &AsySdoSequInstance_g.
+			    m_AsySdoConnection[uiFreeEntry];
+			// save handle from lower layer
+			pAsySdoSeqCon->m_ConHandle = ConHdl_p;
+			// increment use counter
+			pAsySdoSeqCon->m_uiUseCount++;
+			uiCount = uiFreeEntry;
+		}
+	}
+	// call history ack function
+	Ret = EplSdoAsyAckFrameToHistory(pAsySdoSeqCon,
+					 (AmiGetByteFromLe
+					  (&pSdoSeqData_p->
+					   m_le_bRecSeqNumCon) &
+					  EPL_SEQ_NUM_MASK));
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #if defined(WIN32) || defined(_WIN32)
-    // leave critical section
-    LeaveCriticalSection(AsySdoSequInstance_g.m_pCriticalSectionReceive);
+	// leave critical section
+	LeaveCriticalSection(AsySdoSequInstance_g.m_pCriticalSectionReceive);
 #endif
 
-    // call process function with pointer of frame and event kAsySdoSeqEventFrameRec
-    Ret = EplSdoAsySeqProcess(uiCount,
-                                uiDataSize_p,
-                                NULL,
-                                pSdoSeqData_p,
-                                kAsySdoSeqEventFrameRec);
-
+	// call process function with pointer of frame and event kAsySdoSeqEventFrameRec
+	Ret = EplSdoAsySeqProcess(uiCount,
+				  uiDataSize_p,
+				  NULL, pSdoSeqData_p, kAsySdoSeqEventFrameRec);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -2090,20 +2227,19 @@ Exit:
 //---------------------------------------------------------------------------
 static tEplKernel EplSdoAsyInitHistory(void)
 {
-tEplKernel      Ret;
-unsigned int    uiCount;
+	tEplKernel Ret;
+	unsigned int uiCount;
 
-    Ret = kEplSuccessful;
-    // init m_bFreeEntries in history-buffer
-    for(uiCount = 0; uiCount < EPL_MAX_SDO_SEQ_CON; uiCount++)
-    {
-        AsySdoSequInstance_g.m_AsySdoConnection[uiCount].m_SdoConHistory.m_bFreeEntries = EPL_SDO_HISTORY_SIZE;
-    }
+	Ret = kEplSuccessful;
+	// init m_bFreeEntries in history-buffer
+	for (uiCount = 0; uiCount < EPL_MAX_SDO_SEQ_CON; uiCount++) {
+		AsySdoSequInstance_g.m_AsySdoConnection[uiCount].
+		    m_SdoConHistory.m_bFreeEntries = EPL_SDO_HISTORY_SIZE;
+	}
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:        EplSdoAsyAddFrameToHistory
@@ -2124,61 +2260,55 @@ unsigned int    uiCount;
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel EplSdoAsyAddFrameToHistory(tEplAsySdoSeqCon*  pAsySdoSeqCon_p,
-                                        tEplFrame*      pFrame_p,
-                                        unsigned int    uiSize_p)
-{
-tEplKernel              Ret;
-tEplAsySdoConHistory*   pHistory;
+static tEplKernel EplSdoAsyAddFrameToHistory(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+					     tEplFrame * pFrame_p,
+					     unsigned int uiSize_p)
+{
+	tEplKernel Ret;
+	tEplAsySdoConHistory *pHistory;
+
+	Ret = kEplSuccessful;
+
+	// add frame to history buffer
+
+	// check size
+	// $$$ d.k. EPL_SEQ_HISTORY_FRAME_SIZE includes the header size, but uiSize_p does not!!!
+	if (uiSize_p > EPL_SEQ_HISTROY_FRAME_SIZE) {
+		Ret = kEplSdoSeqFrameSizeError;
+		goto Exit;
+	}
+	// save pointer to history
+	pHistory = &pAsySdoSeqCon_p->m_SdoConHistory;
+
+	// check if a free entry is available
+	if (pHistory->m_bFreeEntries > 0) {	// write message in free entry
+		EPL_MEMCPY(&
+			   ((tEplFrame *) pHistory->
+			    m_aabHistoryFrame[pHistory->m_bWrite])->
+			   m_le_bMessageType, &pFrame_p->m_le_bMessageType,
+			   uiSize_p + EPL_ASND_HEADER_SIZE);
+		// store size
+		pHistory->m_auiFrameSize[pHistory->m_bWrite] = uiSize_p;
+
+		// decremend number of free bufferentries
+		pHistory->m_bFreeEntries--;
+
+		// increment writeindex
+		pHistory->m_bWrite++;
+
+		// check if write-index run over array-boarder
+		if (pHistory->m_bWrite == EPL_SDO_HISTORY_SIZE) {
+			pHistory->m_bWrite = 0;
+		}
+
+	} else {		// no free entry
+		Ret = kEplSdoSeqNoFreeHistory;
+	}
 
-    Ret = kEplSuccessful;
-
-    // add frame to history buffer
-
-    // check size
-    // $$$ d.k. EPL_SEQ_HISTORY_FRAME_SIZE includes the header size, but uiSize_p does not!!!
-    if(uiSize_p > EPL_SEQ_HISTROY_FRAME_SIZE)
-    {
-        Ret = kEplSdoSeqFrameSizeError;
-        goto Exit;
-    }
-
-    // save pointer to history
-    pHistory = &pAsySdoSeqCon_p->m_SdoConHistory;
-
-
-    // check if a free entry is available
-    if(pHistory->m_bFreeEntries > 0)
-    {   // write message in free entry
-        EPL_MEMCPY(&((tEplFrame*)pHistory->m_aabHistoryFrame[pHistory->m_bWrite])->m_le_bMessageType,
-                &pFrame_p->m_le_bMessageType,
-                uiSize_p + EPL_ASND_HEADER_SIZE);
-        // store size
-        pHistory->m_auiFrameSize[pHistory->m_bWrite] = uiSize_p;
-
-        // decremend number of free bufferentries
-        pHistory->m_bFreeEntries--;
-
-        // increment writeindex
-        pHistory->m_bWrite++;
-
-        // check if write-index run over array-boarder
-        if(pHistory->m_bWrite == EPL_SDO_HISTORY_SIZE)
-        {
-            pHistory->m_bWrite = 0;
-        }
-
-    }
-    else
-    {   // no free entry
-        Ret = kEplSdoSeqNoFreeHistory;
-    }
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:        EplSdoAsyAckFrameToHistory
@@ -2197,56 +2327,56 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel EplSdoAsyAckFrameToHistory(tEplAsySdoSeqCon*  pAsySdoSeqCon_p,
-                                        BYTE   bRecSeqNumber_p)
+static tEplKernel EplSdoAsyAckFrameToHistory(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+					     BYTE bRecSeqNumber_p)
 {
-tEplKernel              Ret;
-tEplAsySdoConHistory*   pHistory;
-BYTE                    bAckIndex;
-BYTE                    bCurrentSeqNum;
-
-    Ret = kEplSuccessful;
-
-    // get pointer to history buffer
-    pHistory = &pAsySdoSeqCon_p->m_SdoConHistory;
-
-    // release all acknowledged frames from history buffer
-
-    // check if there are entries in history
-    if (pHistory->m_bFreeEntries < EPL_SDO_HISTORY_SIZE)
-    {
-        bAckIndex = pHistory->m_bAck;
-        do
-        {
-            bCurrentSeqNum = (((tEplFrame*)pHistory->m_aabHistoryFrame[bAckIndex])->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.m_le_bSendSeqNumCon & EPL_SEQ_NUM_MASK);
-            if (((bRecSeqNumber_p - bCurrentSeqNum) & EPL_SEQ_NUM_MASK)
-                    < EPL_SEQ_NUM_THRESHOLD)
-            {
-                pHistory->m_auiFrameSize[bAckIndex] = 0;
-                bAckIndex++;
-                pHistory->m_bFreeEntries++;
-                if (bAckIndex == EPL_SDO_HISTORY_SIZE)
-                {   // read index run over array-boarder
-                    bAckIndex = 0;
-                }
-            }
-            else
-            {   // nothing to do anymore,
-                // because any further frame in history has larger sequence
-                // number than the acknowledge
-                goto Exit;
-            }
-        }
-        while ((((bRecSeqNumber_p - 1 - bCurrentSeqNum) & EPL_SEQ_NUM_MASK)
-                    < EPL_SEQ_NUM_THRESHOLD)
-               && (pHistory->m_bWrite != bAckIndex));
-
-        // store local read-index to global var
-        pHistory->m_bAck = bAckIndex;
-    }
+	tEplKernel Ret;
+	tEplAsySdoConHistory *pHistory;
+	BYTE bAckIndex;
+	BYTE bCurrentSeqNum;
+
+	Ret = kEplSuccessful;
+
+	// get pointer to history buffer
+	pHistory = &pAsySdoSeqCon_p->m_SdoConHistory;
+
+	// release all acknowledged frames from history buffer
+
+	// check if there are entries in history
+	if (pHistory->m_bFreeEntries < EPL_SDO_HISTORY_SIZE) {
+		bAckIndex = pHistory->m_bAck;
+		do {
+			bCurrentSeqNum =
+			    (((tEplFrame *) pHistory->
+			      m_aabHistoryFrame[bAckIndex])->m_Data.m_Asnd.
+			     m_Payload.m_SdoSequenceFrame.
+			     m_le_bSendSeqNumCon & EPL_SEQ_NUM_MASK);
+			if (((bRecSeqNumber_p -
+			      bCurrentSeqNum) & EPL_SEQ_NUM_MASK)
+			    < EPL_SEQ_NUM_THRESHOLD) {
+				pHistory->m_auiFrameSize[bAckIndex] = 0;
+				bAckIndex++;
+				pHistory->m_bFreeEntries++;
+				if (bAckIndex == EPL_SDO_HISTORY_SIZE) {	// read index run over array-boarder
+					bAckIndex = 0;
+				}
+			} else {	// nothing to do anymore,
+				// because any further frame in history has larger sequence
+				// number than the acknowledge
+				goto Exit;
+			}
+		}
+		while ((((bRecSeqNumber_p - 1 -
+			  bCurrentSeqNum) & EPL_SEQ_NUM_MASK)
+			< EPL_SEQ_NUM_THRESHOLD)
+		       && (pHistory->m_bWrite != bAckIndex));
+
+		// store local read-index to global var
+		pHistory->m_bAck = bAckIndex;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -2270,59 +2400,55 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel EplSdoAsyReadFromHistory(tEplAsySdoSeqCon*  pAsySdoSeqCon_p,
-                                           tEplFrame**      ppFrame_p,
-                                           unsigned int*    puiSize_p,
-                                           BOOL             fInitRead_p)
-{
-tEplKernel              Ret;
-tEplAsySdoConHistory*   pHistory;
-
-    Ret = kEplSuccessful;
-
-    // read one message from History
-
-    // get pointer to history buffer
-    pHistory = &pAsySdoSeqCon_p->m_SdoConHistory;
-
-    // check if init
-    if (fInitRead_p != FALSE)
-    {   // initialize read index to the index which shall be acknowledged next
-        pHistory->m_bRead = pHistory->m_bAck;
-    }
-
-    // check if entries are available for reading
-    if ((pHistory->m_bFreeEntries < EPL_SDO_HISTORY_SIZE)
-        && (pHistory->m_bWrite != pHistory->m_bRead))
-    {
+static tEplKernel EplSdoAsyReadFromHistory(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+					   tEplFrame ** ppFrame_p,
+					   unsigned int *puiSize_p,
+					   BOOL fInitRead_p)
+{
+	tEplKernel Ret;
+	tEplAsySdoConHistory *pHistory;
+
+	Ret = kEplSuccessful;
+
+	// read one message from History
+
+	// get pointer to history buffer
+	pHistory = &pAsySdoSeqCon_p->m_SdoConHistory;
+
+	// check if init
+	if (fInitRead_p != FALSE) {	// initialize read index to the index which shall be acknowledged next
+		pHistory->m_bRead = pHistory->m_bAck;
+	}
+	// check if entries are available for reading
+	if ((pHistory->m_bFreeEntries < EPL_SDO_HISTORY_SIZE)
+	    && (pHistory->m_bWrite != pHistory->m_bRead)) {
 //        PRINTF4("EplSdoAsyReadFromHistory(): init = %d, read = %u, write = %u, ack = %u", (int) fInitRead_p, (WORD)pHistory->m_bRead, (WORD)pHistory->m_bWrite, (WORD)pHistory->m_bAck);
 //        PRINTF2(", free entries = %u, next frame size = %u\n", (WORD)pHistory->m_bFreeEntries, pHistory->m_auiFrameSize[pHistory->m_bRead]);
 
-        // return pointer to stored frame
-        *ppFrame_p = (tEplFrame*)pHistory->m_aabHistoryFrame[pHistory->m_bRead];
-
-        // save size
-        *puiSize_p = pHistory->m_auiFrameSize[pHistory->m_bRead];
+		// return pointer to stored frame
+		*ppFrame_p =
+		    (tEplFrame *) pHistory->m_aabHistoryFrame[pHistory->
+							      m_bRead];
+
+		// save size
+		*puiSize_p = pHistory->m_auiFrameSize[pHistory->m_bRead];
+
+		pHistory->m_bRead++;
+		if (pHistory->m_bRead == EPL_SDO_HISTORY_SIZE) {
+			pHistory->m_bRead = 0;
+		}
 
-        pHistory->m_bRead++;
-        if(pHistory->m_bRead == EPL_SDO_HISTORY_SIZE)
-        {
-            pHistory->m_bRead = 0;
-        }
-
-    }
-    else
-    {
+	} else {
 //        PRINTF3("EplSdoAsyReadFromHistory(): read = %u, ack = %u, free entries = %u, no frame\n", (WORD)pHistory->m_bRead, (WORD)pHistory->m_bAck, (WORD)pHistory->m_bFreeEntries);
 
-        // no more frames to send
-        // return null pointer
-        *ppFrame_p = NULL;
+		// no more frames to send
+		// return null pointer
+		*ppFrame_p = NULL;
 
-        *puiSize_p = 0;
-    }
+		*puiSize_p = 0;
+	}
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -2343,13 +2469,15 @@ tEplAsySdoConHistory*   pHistory;
 // State:
 //
 //---------------------------------------------------------------------------
-static unsigned int EplSdoAsyGetFreeEntriesFromHistory(tEplAsySdoSeqCon*  pAsySdoSeqCon_p)
+static unsigned int EplSdoAsyGetFreeEntriesFromHistory(tEplAsySdoSeqCon *
+						       pAsySdoSeqCon_p)
 {
-unsigned int uiFreeEntries;
+	unsigned int uiFreeEntries;
 
-    uiFreeEntries = (unsigned int)pAsySdoSeqCon_p->m_SdoConHistory.m_bFreeEntries;
+	uiFreeEntries =
+	    (unsigned int)pAsySdoSeqCon_p->m_SdoConHistory.m_bFreeEntries;
 
-    return uiFreeEntries;
+	return uiFreeEntries;
 }
 
 //---------------------------------------------------------------------------
@@ -2370,32 +2498,25 @@ unsigned int uiFreeEntries;
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel EplSdoAsySeqSetTimer(tEplAsySdoSeqCon* pAsySdoSeqCon_p,
-                                        unsigned long    ulTimeout)
+static tEplKernel EplSdoAsySeqSetTimer(tEplAsySdoSeqCon * pAsySdoSeqCon_p,
+				       unsigned long ulTimeout)
 {
-tEplKernel      Ret;
-tEplTimerArg    TimerArg;
+	tEplKernel Ret;
+	tEplTimerArg TimerArg;
 
-    TimerArg.m_EventSink = kEplEventSinkSdoAsySeq;
-    TimerArg.m_ulArg = (unsigned long)pAsySdoSeqCon_p;
+	TimerArg.m_EventSink = kEplEventSinkSdoAsySeq;
+	TimerArg.m_ulArg = (unsigned long)pAsySdoSeqCon_p;
 
-    if(pAsySdoSeqCon_p->m_EplTimerHdl == 0)
-    {   // create new timer
-        Ret = EplTimeruSetTimerMs(&pAsySdoSeqCon_p->m_EplTimerHdl,
-                                    ulTimeout,
-                                    TimerArg);
-    }
-    else
-    {   // modify exisiting timer
-        Ret = EplTimeruModifyTimerMs(&pAsySdoSeqCon_p->m_EplTimerHdl,
-                                    ulTimeout,
-                                    TimerArg);
+	if (pAsySdoSeqCon_p->m_EplTimerHdl == 0) {	// create new timer
+		Ret = EplTimeruSetTimerMs(&pAsySdoSeqCon_p->m_EplTimerHdl,
+					  ulTimeout, TimerArg);
+	} else {		// modify exisiting timer
+		Ret = EplTimeruModifyTimerMs(&pAsySdoSeqCon_p->m_EplTimerHdl,
+					     ulTimeout, TimerArg);
 
-    }
+	}
 
-
-    return Ret;
+	return Ret;
 }
 
 // EOF
-
--- a/drivers/staging/epl/EplSdoComu.c
+++ b/drivers/staging/epl/EplSdoComu.c
@@ -73,16 +73,16 @@
 #if ((((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) == 0) &&\
      (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) == 0)   )
 
-    #error 'ERROR: At least SDO Server or SDO Client should be activate!'
+#error 'ERROR: At least SDO Server or SDO Client should be activate!'
 
 #endif
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
-    #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) == 0) && (EPL_OBD_USE_KERNEL == FALSE)
+#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) == 0) && (EPL_OBD_USE_KERNEL == FALSE)
 
-    #error 'ERROR: SDO Server needs OBDu module!'
+#error 'ERROR: SDO Server needs OBDu module!'
 
-    #endif
+#endif
 
 #endif
 
@@ -102,116 +102,101 @@
 #define EPL_MAX_SDO_COM_CON         5
 #endif
 
-
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 
 // intern events
-typedef enum
-{
-    kEplSdoComConEventSendFirst     = 0x00, // first frame to send
-    kEplSdoComConEventRec           = 0x01, // frame received
-    kEplSdoComConEventConEstablished= 0x02, // connection established
-    kEplSdoComConEventConClosed     = 0x03, // connection closed
-    kEplSdoComConEventAckReceived   = 0x04, // acknowledge received by lower layer
-                                        // -> continue sending
-    kEplSdoComConEventFrameSended   = 0x05, // lower has send a frame
-    kEplSdoComConEventInitError     = 0x06, // error duringinitialisiation
-                                            // of the connection
-    kEplSdoComConEventTimeout       = 0x07 // timeout in lower layer
+typedef enum {
+	kEplSdoComConEventSendFirst = 0x00,	// first frame to send
+	kEplSdoComConEventRec = 0x01,	// frame received
+	kEplSdoComConEventConEstablished = 0x02,	// connection established
+	kEplSdoComConEventConClosed = 0x03,	// connection closed
+	kEplSdoComConEventAckReceived = 0x04,	// acknowledge received by lower layer
+	// -> continue sending
+	kEplSdoComConEventFrameSended = 0x05,	// lower has send a frame
+	kEplSdoComConEventInitError = 0x06,	// error duringinitialisiation
+	// of the connection
+	kEplSdoComConEventTimeout = 0x07	// timeout in lower layer
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
+	    ,
 
-    ,
-
-    kEplSdoComConEventInitCon       = 0x08, // init connection (only client)
-    kEplSdoComConEventAbort         = 0x09 // abort sdo transfer (only client)
+	kEplSdoComConEventInitCon = 0x08,	// init connection (only client)
+	kEplSdoComConEventAbort = 0x09	// abort sdo transfer (only client)
 #endif
+} tEplSdoComConEvent;
 
-
-}tEplSdoComConEvent;
-
-typedef enum
-{
-    kEplSdoComSendTypeReq      = 0x00,  // send a request
-    kEplSdoComSendTypeAckRes   = 0x01,  // send a resonse without data
-    kEplSdoComSendTypeRes      = 0x02,  // send response with data
-    kEplSdoComSendTypeAbort    = 0x03   // send abort
-
-}tEplSdoComSendType;
+typedef enum {
+	kEplSdoComSendTypeReq = 0x00,	// send a request
+	kEplSdoComSendTypeAckRes = 0x01,	// send a resonse without data
+	kEplSdoComSendTypeRes = 0x02,	// send response with data
+	kEplSdoComSendTypeAbort = 0x03	// send abort
+} tEplSdoComSendType;
 
 // state of the state maschine
-typedef enum
-{
-    // General State
-    kEplSdoComStateIdle             = 0x00, // idle state
+typedef enum {
+	// General State
+	kEplSdoComStateIdle = 0x00,	// idle state
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
-    // Server States
-    kEplSdoComStateServerSegmTrans  = 0x01, // send following frames
+	// Server States
+	kEplSdoComStateServerSegmTrans = 0x01,	// send following frames
 #endif
 
-
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-    // Client States
-    kEplSdoComStateClientWaitInit   = 0x10, // wait for init connection
-                                            // on lower layer
-    kEplSdoComStateClientConnected  = 0x11, // connection established
-    kEplSdoComStateClientSegmTrans  = 0x12  // send following frames
+	// Client States
+	kEplSdoComStateClientWaitInit = 0x10,	// wait for init connection
+	// on lower layer
+	kEplSdoComStateClientConnected = 0x11,	// connection established
+	kEplSdoComStateClientSegmTrans = 0x12	// send following frames
 #endif
-
-
-
 } tEplSdoComState;
 
-
 // control structure for transaction
-typedef struct
-{
-    tEplSdoSeqConHdl    m_SdoSeqConHdl;     // if != 0 -> entry used
-    tEplSdoComState     m_SdoComState;
-    BYTE                m_bTransactionId;
-    unsigned int        m_uiNodeId;         // NodeId of the target
-                                            // -> needed to reinit connection
-                                            //    after timeout
-    tEplSdoTransType    m_SdoTransType;     // Auto, Expedited, Segmented
-    tEplSdoServiceType  m_SdoServiceType;   // WriteByIndex, ReadByIndex
-    tEplSdoType         m_SdoProtType;      // protocol layer: Auto, Udp, Asnd, Pdo
-    BYTE*               m_pData;            // pointer to data
-    unsigned int        m_uiTransSize;      // number of bytes
-                                            // to transfer
-    unsigned int        m_uiTransferredByte;// number of bytes
-                                            // already transferred
-    tEplSdoFinishedCb   m_pfnTransferFinished;// callback function of the
-                                            // application
-                                            // -> called in the end of
-                                            //    the SDO transfer
-    void*               m_pUserArg;         // user definable argument pointer
+typedef struct {
+	tEplSdoSeqConHdl m_SdoSeqConHdl;	// if != 0 -> entry used
+	tEplSdoComState m_SdoComState;
+	BYTE m_bTransactionId;
+	unsigned int m_uiNodeId;	// NodeId of the target
+	// -> needed to reinit connection
+	//    after timeout
+	tEplSdoTransType m_SdoTransType;	// Auto, Expedited, Segmented
+	tEplSdoServiceType m_SdoServiceType;	// WriteByIndex, ReadByIndex
+	tEplSdoType m_SdoProtType;	// protocol layer: Auto, Udp, Asnd, Pdo
+	BYTE *m_pData;		// pointer to data
+	unsigned int m_uiTransSize;	// number of bytes
+	// to transfer
+	unsigned int m_uiTransferredByte;	// number of bytes
+	// already transferred
+	tEplSdoFinishedCb m_pfnTransferFinished;	// callback function of the
+	// application
+	// -> called in the end of
+	//    the SDO transfer
+	void *m_pUserArg;	// user definable argument pointer
 
-    DWORD               m_dwLastAbortCode;  // save the last abort code
+	DWORD m_dwLastAbortCode;	// save the last abort code
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-    // only for client
-    unsigned int        m_uiTargetIndex;    // index to access
-    unsigned int        m_uiTargetSubIndex; // subiondex to access
+	// only for client
+	unsigned int m_uiTargetIndex;	// index to access
+	unsigned int m_uiTargetSubIndex;	// subiondex to access
 
-    // for future use
-    unsigned int        m_uiTimeout;        // timeout for this connection
+	// for future use
+	unsigned int m_uiTimeout;	// timeout for this connection
 
 #endif
 
 } tEplSdoComCon;
 
 // instance table
-typedef struct
-{
-    tEplSdoComCon       m_SdoComCon[EPL_MAX_SDO_COM_CON];
+typedef struct {
+	tEplSdoComCon m_SdoComCon[EPL_MAX_SDO_COM_CON];
 
 #if defined(WIN32) || defined(_WIN32)
-    LPCRITICAL_SECTION  m_pCriticalSection;
-    CRITICAL_SECTION    m_CriticalSection;
+	LPCRITICAL_SECTION m_pCriticalSection;
+	CRITICAL_SECTION m_CriticalSection;
 #endif
 
-}tEplSdoComInstance;
+} tEplSdoComInstance;
 
 //---------------------------------------------------------------------------
 // modul globale vars
@@ -220,53 +205,50 @@ static tEplSdoComInstance SdoComInstance
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoComReceiveCb (tEplSdoSeqConHdl    SdoSeqConHdl_p,
-                                    tEplAsySdoCom*      pAsySdoCom_p,
-                                    unsigned int        uiDataSize_p);
-
-
-tEplKernel PUBLIC EplSdoComConCb (tEplSdoSeqConHdl    SdoSeqConHdl_p,
-                                    tEplAsySdoConState  AsySdoConState_p);
-
-static tEplKernel EplSdoComSearchConIntern(tEplSdoSeqConHdl    SdoSeqConHdl_p,
-                                         tEplSdoComConEvent SdoComConEvent_p,
-                                         tEplAsySdoCom*     pAsySdoCom_p);
-
-static tEplKernel EplSdoComProcessIntern(tEplSdoComConHdl   SdoComCon_p,
-                                         tEplSdoComConEvent SdoComConEvent_p,
-                                         tEplAsySdoCom*     pAsySdoCom_p);
-
-static tEplKernel EplSdoComTransferFinished(tEplSdoComConHdl   SdoComCon_p,
-                                            tEplSdoComCon*     pSdoComCon_p,
-                                            tEplSdoComConState SdoComConState_p);
+tEplKernel PUBLIC EplSdoComReceiveCb(tEplSdoSeqConHdl SdoSeqConHdl_p,
+				     tEplAsySdoCom * pAsySdoCom_p,
+				     unsigned int uiDataSize_p);
+
+tEplKernel PUBLIC EplSdoComConCb(tEplSdoSeqConHdl SdoSeqConHdl_p,
+				 tEplAsySdoConState AsySdoConState_p);
+
+static tEplKernel EplSdoComSearchConIntern(tEplSdoSeqConHdl SdoSeqConHdl_p,
+					   tEplSdoComConEvent SdoComConEvent_p,
+					   tEplAsySdoCom * pAsySdoCom_p);
+
+static tEplKernel EplSdoComProcessIntern(tEplSdoComConHdl SdoComCon_p,
+					 tEplSdoComConEvent SdoComConEvent_p,
+					 tEplAsySdoCom * pAsySdoCom_p);
+
+static tEplKernel EplSdoComTransferFinished(tEplSdoComConHdl SdoComCon_p,
+					    tEplSdoComCon * pSdoComCon_p,
+					    tEplSdoComConState
+					    SdoComConState_p);
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
-static tEplKernel EplSdoComServerInitReadByIndex(tEplSdoComCon*     pSdoComCon_p,
-                                         tEplAsySdoCom*     pAsySdoCom_p);
+static tEplKernel EplSdoComServerInitReadByIndex(tEplSdoComCon * pSdoComCon_p,
+						 tEplAsySdoCom * pAsySdoCom_p);
 
-static tEplKernel EplSdoComServerSendFrameIntern(tEplSdoComCon*     pSdoComCon_p,
-                                           unsigned int       uiIndex_p,
-                                           unsigned int       uiSubIndex_p,
-                                           tEplSdoComSendType SendType_p);
+static tEplKernel EplSdoComServerSendFrameIntern(tEplSdoComCon * pSdoComCon_p,
+						 unsigned int uiIndex_p,
+						 unsigned int uiSubIndex_p,
+						 tEplSdoComSendType SendType_p);
 
-static tEplKernel EplSdoComServerInitWriteByIndex(tEplSdoComCon*     pSdoComCon_p,
-                                         tEplAsySdoCom*     pAsySdoCom_p);
+static tEplKernel EplSdoComServerInitWriteByIndex(tEplSdoComCon * pSdoComCon_p,
+						  tEplAsySdoCom * pAsySdoCom_p);
 #endif
 
-
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
 
-static tEplKernel EplSdoComClientSend(tEplSdoComCon* pSdoComCon_p);
+static tEplKernel EplSdoComClientSend(tEplSdoComCon * pSdoComCon_p);
 
-static tEplKernel EplSdoComClientProcessFrame(tEplSdoComConHdl   SdoComCon_p,
-                                              tEplAsySdoCom*     pAsySdoCom_p);
+static tEplKernel EplSdoComClientProcessFrame(tEplSdoComConHdl SdoComCon_p,
+					      tEplAsySdoCom * pAsySdoCom_p);
 
-static tEplKernel EplSdoComClientSendAbort(tEplSdoComCon* pSdoComCon_p,
-                                           DWORD          dwAbortCode_p);
+static tEplKernel EplSdoComClientSendAbort(tEplSdoComCon * pSdoComCon_p,
+					   DWORD dwAbortCode_p);
 #endif
 
-
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -305,12 +287,11 @@ static tEplKernel EplSdoComClientSendAbo
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoComInit(void)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
+	Ret = EplSdoComAddInstance();
 
-    Ret = EplSdoComAddInstance();
-
-return Ret;
+	return Ret;
 
 }
 
@@ -333,28 +314,27 @@ return Ret;
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoComAddInstance(void)
 {
-tEplKernel Ret;
-
-    Ret = kEplSuccessful;
+	tEplKernel Ret;
 
-    // init controll structure
-    EPL_MEMSET(&SdoComInstance_g, 0x00, sizeof(SdoComInstance_g));
+	Ret = kEplSuccessful;
 
-    // init instance of lower layer
-    Ret = EplSdoAsySeqAddInstance(EplSdoComReceiveCb, EplSdoComConCb);
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
+	// init controll structure
+	EPL_MEMSET(&SdoComInstance_g, 0x00, sizeof(SdoComInstance_g));
 
+	// init instance of lower layer
+	Ret = EplSdoAsySeqAddInstance(EplSdoComReceiveCb, EplSdoComConCb);
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 #if defined(WIN32) || defined(_WIN32)
-    // create critical section for process function
-    SdoComInstance_g.m_pCriticalSection = &SdoComInstance_g.m_CriticalSection;
-    InitializeCriticalSection(SdoComInstance_g.m_pCriticalSection);
+	// create critical section for process function
+	SdoComInstance_g.m_pCriticalSection =
+	    &SdoComInstance_g.m_CriticalSection;
+	InitializeCriticalSection(SdoComInstance_g.m_pCriticalSection);
 #endif
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -376,25 +356,22 @@ Exit:
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoComDelInstance(void)
 {
-tEplKernel  Ret;
-
-    Ret = kEplSuccessful;
+	tEplKernel Ret;
 
+	Ret = kEplSuccessful;
 
 #if defined(WIN32) || defined(_WIN32)
-    // delete critical section for process function
-    DeleteCriticalSection(SdoComInstance_g.m_pCriticalSection);
+	// delete critical section for process function
+	DeleteCriticalSection(SdoComInstance_g.m_pCriticalSection);
 #endif
 
-    Ret = EplSdoAsySeqDelInstance();
-    if(Ret != kEplSuccessful)
-    {
-        goto Exit;
-    }
-
+	Ret = EplSdoAsySeqDelInstance();
+	if (Ret != kEplSuccessful) {
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -421,110 +398,99 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-tEplKernel PUBLIC EplSdoComDefineCon(tEplSdoComConHdl*  pSdoComConHdl_p,
-                                      unsigned int      uiTargetNodeId_p,
-                                      tEplSdoType       ProtType_p)
-{
-tEplKernel      Ret;
-unsigned int    uiCount;
-unsigned int    uiFreeHdl;
-tEplSdoComCon*  pSdoComCon;
-
-    // check Parameter
-    ASSERT(pSdoComConHdl_p != NULL);
-
-    // check NodeId
-    if((uiTargetNodeId_p == EPL_C_ADR_INVALID)
-        ||(uiTargetNodeId_p >= EPL_C_ADR_BROADCAST))
-    {
-        Ret = kEplInvalidNodeId;
-
-    }
-
-    // search free control structure
-    pSdoComCon = &SdoComInstance_g.m_SdoComCon[0];
-    uiCount = 0;
-    uiFreeHdl = EPL_MAX_SDO_COM_CON;
-    while (uiCount < EPL_MAX_SDO_COM_CON)
-    {
-        if (pSdoComCon->m_SdoSeqConHdl == 0)
-        {   // free entry
-            uiFreeHdl = uiCount;
-        }
-        else if ((pSdoComCon->m_uiNodeId == uiTargetNodeId_p)
-            && (pSdoComCon->m_SdoProtType == ProtType_p))
-        {   // existing client connection with same node ID and same protocol type
-            *pSdoComConHdl_p = uiCount;
-            Ret = kEplSdoComHandleExists;
-            goto Exit;
-        }
-        uiCount++;
-        pSdoComCon++;
-    }
-
-    if (uiFreeHdl == EPL_MAX_SDO_COM_CON)
-    {
-        Ret = kEplSdoComNoFreeHandle;
-        goto Exit;
-    }
-
-    pSdoComCon = &SdoComInstance_g.m_SdoComCon[uiFreeHdl];
-    // save handle for application
-    *pSdoComConHdl_p = uiFreeHdl;
-    // save parameters
-    pSdoComCon->m_SdoProtType = ProtType_p;
-    pSdoComCon->m_uiNodeId = uiTargetNodeId_p;
-
-    // set Transaction Id
-    pSdoComCon->m_bTransactionId = 0;
-
-    // check protocol
-    switch(ProtType_p)
-    {
-        // udp
-        case kEplSdoTypeUdp:
-        {
-            // call connection int function of lower layer
-            Ret = EplSdoAsySeqInitCon(&pSdoComCon->m_SdoSeqConHdl,
-                          pSdoComCon->m_uiNodeId,
-                          kEplSdoTypeUdp);
-            if(Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-            break;
-        }
-
-        // Asend
-        case kEplSdoTypeAsnd:
-        {
-            // call connection int function of lower layer
-            Ret = EplSdoAsySeqInitCon(&pSdoComCon->m_SdoSeqConHdl,
-                          pSdoComCon->m_uiNodeId,
-                          kEplSdoTypeAsnd);
-            if(Ret != kEplSuccessful)
-            {
-                goto Exit;
-            }
-            break;
-        }
-
-        // Pdo -> not supported
-        case kEplSdoTypePdo:
-        default:
-        {
-            Ret = kEplSdoComUnsupportedProt;
-            goto Exit;
-        }
-    }// end of switch(m_ProtType_p)
-
-    // call process function
-    Ret = EplSdoComProcessIntern(uiFreeHdl,
-                                    kEplSdoComConEventInitCon,
-                                    NULL);
+tEplKernel PUBLIC EplSdoComDefineCon(tEplSdoComConHdl * pSdoComConHdl_p,
+				     unsigned int uiTargetNodeId_p,
+				     tEplSdoType ProtType_p)
+{
+	tEplKernel Ret;
+	unsigned int uiCount;
+	unsigned int uiFreeHdl;
+	tEplSdoComCon *pSdoComCon;
+
+	// check Parameter
+	ASSERT(pSdoComConHdl_p != NULL);
+
+	// check NodeId
+	if ((uiTargetNodeId_p == EPL_C_ADR_INVALID)
+	    || (uiTargetNodeId_p >= EPL_C_ADR_BROADCAST)) {
+		Ret = kEplInvalidNodeId;
+
+	}
+	// search free control structure
+	pSdoComCon = &SdoComInstance_g.m_SdoComCon[0];
+	uiCount = 0;
+	uiFreeHdl = EPL_MAX_SDO_COM_CON;
+	while (uiCount < EPL_MAX_SDO_COM_CON) {
+		if (pSdoComCon->m_SdoSeqConHdl == 0) {	// free entry
+			uiFreeHdl = uiCount;
+		} else if ((pSdoComCon->m_uiNodeId == uiTargetNodeId_p)
+			   && (pSdoComCon->m_SdoProtType == ProtType_p)) {	// existing client connection with same node ID and same protocol type
+			*pSdoComConHdl_p = uiCount;
+			Ret = kEplSdoComHandleExists;
+			goto Exit;
+		}
+		uiCount++;
+		pSdoComCon++;
+	}
+
+	if (uiFreeHdl == EPL_MAX_SDO_COM_CON) {
+		Ret = kEplSdoComNoFreeHandle;
+		goto Exit;
+	}
+
+	pSdoComCon = &SdoComInstance_g.m_SdoComCon[uiFreeHdl];
+	// save handle for application
+	*pSdoComConHdl_p = uiFreeHdl;
+	// save parameters
+	pSdoComCon->m_SdoProtType = ProtType_p;
+	pSdoComCon->m_uiNodeId = uiTargetNodeId_p;
+
+	// set Transaction Id
+	pSdoComCon->m_bTransactionId = 0;
+
+	// check protocol
+	switch (ProtType_p) {
+		// udp
+	case kEplSdoTypeUdp:
+		{
+			// call connection int function of lower layer
+			Ret = EplSdoAsySeqInitCon(&pSdoComCon->m_SdoSeqConHdl,
+						  pSdoComCon->m_uiNodeId,
+						  kEplSdoTypeUdp);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+			break;
+		}
+
+		// Asend
+	case kEplSdoTypeAsnd:
+		{
+			// call connection int function of lower layer
+			Ret = EplSdoAsySeqInitCon(&pSdoComCon->m_SdoSeqConHdl,
+						  pSdoComCon->m_uiNodeId,
+						  kEplSdoTypeAsnd);
+			if (Ret != kEplSuccessful) {
+				goto Exit;
+			}
+			break;
+		}
+
+		// Pdo -> not supported
+	case kEplSdoTypePdo:
+	default:
+		{
+			Ret = kEplSdoComUnsupportedProt;
+			goto Exit;
+		}
+	}			// end of switch(m_ProtType_p)
+
+	// call process function
+	Ret = EplSdoComProcessIntern(uiFreeHdl,
+				     kEplSdoComConEventInitCon, NULL);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 #endif
 //---------------------------------------------------------------------------
@@ -545,84 +511,76 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-tEplKernel PUBLIC EplSdoComInitTransferByIndex(tEplSdoComTransParamByIndex* pSdoComTransParam_p)
+tEplKernel PUBLIC EplSdoComInitTransferByIndex(tEplSdoComTransParamByIndex *
+					       pSdoComTransParam_p)
 {
-tEplKernel      Ret;
-tEplSdoComCon*  pSdoComCon;
+	tEplKernel Ret;
+	tEplSdoComCon *pSdoComCon;
 
-    // check parameter
-    if ((pSdoComTransParam_p->m_uiSubindex >= 0xFF)
-        || (pSdoComTransParam_p->m_uiIndex == 0)
-        || (pSdoComTransParam_p->m_uiIndex > 0xFFFF)
-        || (pSdoComTransParam_p->m_pData == NULL)
-        || (pSdoComTransParam_p->m_uiDataSize == 0))
-    {
-        Ret = kEplSdoComInvalidParam;
-        goto Exit;
-    }
-
-    if(pSdoComTransParam_p->m_SdoComConHdl >= EPL_MAX_SDO_COM_CON)
-    {
-        Ret = kEplSdoComInvalidHandle;
-        goto Exit;
-    }
-
-    // get pointer to control structure of connection
-    pSdoComCon = &SdoComInstance_g.m_SdoComCon[pSdoComTransParam_p->m_SdoComConHdl];
-
-    // check if handle ok
-    if(pSdoComCon->m_SdoSeqConHdl == 0)
-    {
-        Ret = kEplSdoComInvalidHandle;
-        goto Exit;
-    }
-
-    // check if command layer is idle
-    if ((pSdoComCon->m_uiTransferredByte + pSdoComCon->m_uiTransSize) > 0)
-    {   // handle is not idle
-        Ret = kEplSdoComHandleBusy;
-        goto Exit;
-    }
-
-    // save parameter
-    // callback function for end of transfer
-    pSdoComCon->m_pfnTransferFinished = pSdoComTransParam_p->m_pfnSdoFinishedCb;
-    pSdoComCon->m_pUserArg = pSdoComTransParam_p->m_pUserArg;
-
-    // set type of SDO command
-    if (pSdoComTransParam_p->m_SdoAccessType == kEplSdoAccessTypeRead)
-    {
-        pSdoComCon->m_SdoServiceType = kEplSdoServiceReadByIndex;
-    }
-    else
-    {
-        pSdoComCon->m_SdoServiceType = kEplSdoServiceWriteByIndex;
-
-    }
-    // save pointer to data
-    pSdoComCon->m_pData = pSdoComTransParam_p->m_pData;
-    // maximal bytes to transfer
-    pSdoComCon->m_uiTransSize = pSdoComTransParam_p->m_uiDataSize;
-    // bytes already transfered
-    pSdoComCon->m_uiTransferredByte = 0;
-
-    // reset parts of control structure
-    pSdoComCon->m_dwLastAbortCode = 0;
-    pSdoComCon->m_SdoTransType = kEplSdoTransAuto;
-    // save timeout
-    //pSdoComCon->m_uiTimeout = SdoComTransParam_p.m_uiTimeout;
-
-    // save index and subindex
-    pSdoComCon->m_uiTargetIndex = pSdoComTransParam_p->m_uiIndex;
-    pSdoComCon->m_uiTargetSubIndex = pSdoComTransParam_p->m_uiSubindex;
-
-    // call process function
-    Ret = EplSdoComProcessIntern(pSdoComTransParam_p->m_SdoComConHdl,
-                                    kEplSdoComConEventSendFirst,    // event to start transfer
-                                    NULL);
+	// check parameter
+	if ((pSdoComTransParam_p->m_uiSubindex >= 0xFF)
+	    || (pSdoComTransParam_p->m_uiIndex == 0)
+	    || (pSdoComTransParam_p->m_uiIndex > 0xFFFF)
+	    || (pSdoComTransParam_p->m_pData == NULL)
+	    || (pSdoComTransParam_p->m_uiDataSize == 0)) {
+		Ret = kEplSdoComInvalidParam;
+		goto Exit;
+	}
+
+	if (pSdoComTransParam_p->m_SdoComConHdl >= EPL_MAX_SDO_COM_CON) {
+		Ret = kEplSdoComInvalidHandle;
+		goto Exit;
+	}
+	// get pointer to control structure of connection
+	pSdoComCon =
+	    &SdoComInstance_g.m_SdoComCon[pSdoComTransParam_p->m_SdoComConHdl];
+
+	// check if handle ok
+	if (pSdoComCon->m_SdoSeqConHdl == 0) {
+		Ret = kEplSdoComInvalidHandle;
+		goto Exit;
+	}
+	// check if command layer is idle
+	if ((pSdoComCon->m_uiTransferredByte + pSdoComCon->m_uiTransSize) > 0) {	// handle is not idle
+		Ret = kEplSdoComHandleBusy;
+		goto Exit;
+	}
+	// save parameter
+	// callback function for end of transfer
+	pSdoComCon->m_pfnTransferFinished =
+	    pSdoComTransParam_p->m_pfnSdoFinishedCb;
+	pSdoComCon->m_pUserArg = pSdoComTransParam_p->m_pUserArg;
+
+	// set type of SDO command
+	if (pSdoComTransParam_p->m_SdoAccessType == kEplSdoAccessTypeRead) {
+		pSdoComCon->m_SdoServiceType = kEplSdoServiceReadByIndex;
+	} else {
+		pSdoComCon->m_SdoServiceType = kEplSdoServiceWriteByIndex;
+
+	}
+	// save pointer to data
+	pSdoComCon->m_pData = pSdoComTransParam_p->m_pData;
+	// maximal bytes to transfer
+	pSdoComCon->m_uiTransSize = pSdoComTransParam_p->m_uiDataSize;
+	// bytes already transfered
+	pSdoComCon->m_uiTransferredByte = 0;
+
+	// reset parts of control structure
+	pSdoComCon->m_dwLastAbortCode = 0;
+	pSdoComCon->m_SdoTransType = kEplSdoTransAuto;
+	// save timeout
+	//pSdoComCon->m_uiTimeout = SdoComTransParam_p.m_uiTimeout;
+
+	// save index and subindex
+	pSdoComCon->m_uiTargetIndex = pSdoComTransParam_p->m_uiIndex;
+	pSdoComCon->m_uiTargetSubIndex = pSdoComTransParam_p->m_uiSubindex;
+
+	// call process function
+	Ret = EplSdoComProcessIntern(pSdoComTransParam_p->m_SdoComConHdl, kEplSdoComConEventSendFirst,	// event to start transfer
+				     NULL);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 #endif
@@ -645,53 +603,51 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-tEplKernel PUBLIC EplSdoComUndefineCon(tEplSdoComConHdl  SdoComConHdl_p)
+tEplKernel PUBLIC EplSdoComUndefineCon(tEplSdoComConHdl SdoComConHdl_p)
 {
-tEplKernel          Ret;
-tEplSdoComCon*      pSdoComCon;
+	tEplKernel Ret;
+	tEplSdoComCon *pSdoComCon;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    if(SdoComConHdl_p >= EPL_MAX_SDO_COM_CON)
-    {
-        Ret = kEplSdoComInvalidHandle;
-        goto Exit;
-    }
-
-    // get pointer to control structure
-    pSdoComCon = &SdoComInstance_g.m_SdoComCon[SdoComConHdl_p];
-
-    // $$$ d.k. abort a running transfer before closing the sequence layer
-
-    if(((pSdoComCon->m_SdoSeqConHdl & ~EPL_SDO_SEQ_HANDLE_MASK)  != EPL_SDO_SEQ_INVALID_HDL)
-        && (pSdoComCon->m_SdoSeqConHdl != 0))
-    {
-        // close connection in lower layer
-        switch(pSdoComCon->m_SdoProtType)
-        {
-            case kEplSdoTypeAsnd:
-            case kEplSdoTypeUdp:
-            {
-                Ret = EplSdoAsySeqDelCon(pSdoComCon->m_SdoSeqConHdl);
-                break;
-            }
-
-            case kEplSdoTypePdo:
-            case kEplSdoTypeAuto:
-            default:
-            {
-                Ret = kEplSdoComUnsupportedProt;
-                goto Exit;
-            }
-
-        }// end of switch(pSdoComCon->m_SdoProtType)
-    }
-
-
-    // clean controll structure
-    EPL_MEMSET(pSdoComCon, 0x00, sizeof(tEplSdoComCon));
-Exit:
-    return Ret;
+	if (SdoComConHdl_p >= EPL_MAX_SDO_COM_CON) {
+		Ret = kEplSdoComInvalidHandle;
+		goto Exit;
+	}
+	// get pointer to control structure
+	pSdoComCon = &SdoComInstance_g.m_SdoComCon[SdoComConHdl_p];
+
+	// $$$ d.k. abort a running transfer before closing the sequence layer
+
+	if (((pSdoComCon->m_SdoSeqConHdl & ~EPL_SDO_SEQ_HANDLE_MASK) !=
+	     EPL_SDO_SEQ_INVALID_HDL)
+	    && (pSdoComCon->m_SdoSeqConHdl != 0)) {
+		// close connection in lower layer
+		switch (pSdoComCon->m_SdoProtType) {
+		case kEplSdoTypeAsnd:
+		case kEplSdoTypeUdp:
+			{
+				Ret =
+				    EplSdoAsySeqDelCon(pSdoComCon->
+						       m_SdoSeqConHdl);
+				break;
+			}
+
+		case kEplSdoTypePdo:
+		case kEplSdoTypeAuto:
+		default:
+			{
+				Ret = kEplSdoComUnsupportedProt;
+				goto Exit;
+			}
+
+		}		// end of switch(pSdoComCon->m_SdoProtType)
+	}
+
+	// clean controll structure
+	EPL_MEMSET(pSdoComCon, 0x00, sizeof(tEplSdoComCon));
+      Exit:
+	return Ret;
 }
 #endif
 //---------------------------------------------------------------------------
@@ -713,70 +669,62 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-tEplKernel PUBLIC EplSdoComGetState(tEplSdoComConHdl    SdoComConHdl_p,
-                                    tEplSdoComFinished* pSdoComFinished_p)
+tEplKernel PUBLIC EplSdoComGetState(tEplSdoComConHdl SdoComConHdl_p,
+				    tEplSdoComFinished * pSdoComFinished_p)
 {
-tEplKernel          Ret;
-tEplSdoComCon*      pSdoComCon;
+	tEplKernel Ret;
+	tEplSdoComCon *pSdoComCon;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    if(SdoComConHdl_p >= EPL_MAX_SDO_COM_CON)
-    {
-        Ret = kEplSdoComInvalidHandle;
-        goto Exit;
-    }
-
-    // get pointer to control structure
-    pSdoComCon = &SdoComInstance_g.m_SdoComCon[SdoComConHdl_p];
-
-    // check if handle ok
-    if(pSdoComCon->m_SdoSeqConHdl == 0)
-    {
-        Ret = kEplSdoComInvalidHandle;
-        goto Exit;
-    }
-
-    pSdoComFinished_p->m_pUserArg = pSdoComCon->m_pUserArg;
-    pSdoComFinished_p->m_uiNodeId = pSdoComCon->m_uiNodeId;
-    pSdoComFinished_p->m_uiTargetIndex = pSdoComCon->m_uiTargetIndex;
-    pSdoComFinished_p->m_uiTargetSubIndex = pSdoComCon->m_uiTargetSubIndex;
-    pSdoComFinished_p->m_uiTransferredByte = pSdoComCon->m_uiTransferredByte;
-    pSdoComFinished_p->m_dwAbortCode = pSdoComCon->m_dwLastAbortCode;
-    pSdoComFinished_p->m_SdoComConHdl = SdoComConHdl_p;
-    if (pSdoComCon->m_SdoServiceType == kEplSdoServiceWriteByIndex)
-    {
-        pSdoComFinished_p->m_SdoAccessType = kEplSdoAccessTypeWrite;
-    }
-    else
-    {
-        pSdoComFinished_p->m_SdoAccessType = kEplSdoAccessTypeRead;
-    }
-
-    if(pSdoComCon->m_dwLastAbortCode != 0)
-    {   // sdo abort
-        pSdoComFinished_p->m_SdoComConState = kEplSdoComTransferRxAborted;
-
-        // delete abort code
-        pSdoComCon->m_dwLastAbortCode = 0;
-
-    }
-    else if((pSdoComCon->m_SdoSeqConHdl & ~EPL_SDO_SEQ_HANDLE_MASK)== EPL_SDO_SEQ_INVALID_HDL)
-    {   // check state
-        pSdoComFinished_p->m_SdoComConState = kEplSdoComTransferLowerLayerAbort;
-    }
-    else if(pSdoComCon->m_SdoComState == kEplSdoComStateClientWaitInit)
-    {
-        // finished
-        pSdoComFinished_p->m_SdoComConState = kEplSdoComTransferNotActive;
-    }
-    else if(pSdoComCon->m_uiTransSize == 0)
-    {   // finished
-        pSdoComFinished_p->m_SdoComConState = kEplSdoComTransferFinished;
-    }
+	if (SdoComConHdl_p >= EPL_MAX_SDO_COM_CON) {
+		Ret = kEplSdoComInvalidHandle;
+		goto Exit;
+	}
+	// get pointer to control structure
+	pSdoComCon = &SdoComInstance_g.m_SdoComCon[SdoComConHdl_p];
+
+	// check if handle ok
+	if (pSdoComCon->m_SdoSeqConHdl == 0) {
+		Ret = kEplSdoComInvalidHandle;
+		goto Exit;
+	}
+
+	pSdoComFinished_p->m_pUserArg = pSdoComCon->m_pUserArg;
+	pSdoComFinished_p->m_uiNodeId = pSdoComCon->m_uiNodeId;
+	pSdoComFinished_p->m_uiTargetIndex = pSdoComCon->m_uiTargetIndex;
+	pSdoComFinished_p->m_uiTargetSubIndex = pSdoComCon->m_uiTargetSubIndex;
+	pSdoComFinished_p->m_uiTransferredByte =
+	    pSdoComCon->m_uiTransferredByte;
+	pSdoComFinished_p->m_dwAbortCode = pSdoComCon->m_dwLastAbortCode;
+	pSdoComFinished_p->m_SdoComConHdl = SdoComConHdl_p;
+	if (pSdoComCon->m_SdoServiceType == kEplSdoServiceWriteByIndex) {
+		pSdoComFinished_p->m_SdoAccessType = kEplSdoAccessTypeWrite;
+	} else {
+		pSdoComFinished_p->m_SdoAccessType = kEplSdoAccessTypeRead;
+	}
+
+	if (pSdoComCon->m_dwLastAbortCode != 0) {	// sdo abort
+		pSdoComFinished_p->m_SdoComConState =
+		    kEplSdoComTransferRxAborted;
+
+		// delete abort code
+		pSdoComCon->m_dwLastAbortCode = 0;
+
+	} else if ((pSdoComCon->m_SdoSeqConHdl & ~EPL_SDO_SEQ_HANDLE_MASK) == EPL_SDO_SEQ_INVALID_HDL) {	// check state
+		pSdoComFinished_p->m_SdoComConState =
+		    kEplSdoComTransferLowerLayerAbort;
+	} else if (pSdoComCon->m_SdoComState == kEplSdoComStateClientWaitInit) {
+		// finished
+		pSdoComFinished_p->m_SdoComConState =
+		    kEplSdoComTransferNotActive;
+	} else if (pSdoComCon->m_uiTransSize == 0) {	// finished
+		pSdoComFinished_p->m_SdoComConState =
+		    kEplSdoComTransferFinished;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 #endif
@@ -800,37 +748,32 @@ Exit:
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
 tEplKernel PUBLIC EplSdoComSdoAbort(tEplSdoComConHdl SdoComConHdl_p,
-                                    DWORD            dwAbortCode_p)
+				    DWORD dwAbortCode_p)
 {
-tEplKernel  Ret;
-tEplSdoComCon*      pSdoComCon;
-
+	tEplKernel Ret;
+	tEplSdoComCon *pSdoComCon;
 
-    if(SdoComConHdl_p >= EPL_MAX_SDO_COM_CON)
-    {
-        Ret = kEplSdoComInvalidHandle;
-        goto Exit;
-    }
-
-    // get pointer to control structure of connection
-    pSdoComCon = &SdoComInstance_g.m_SdoComCon[SdoComConHdl_p];
-
-    // check if handle ok
-    if(pSdoComCon->m_SdoSeqConHdl == 0)
-    {
-        Ret = kEplSdoComInvalidHandle;
-        goto Exit;
-    }
-
-    // save pointer to abort code
-    pSdoComCon->m_pData = (BYTE*)&dwAbortCode_p;
-
-    Ret = EplSdoComProcessIntern(SdoComConHdl_p,
-                                kEplSdoComConEventAbort,
-                                (tEplAsySdoCom*)NULL);
+	if (SdoComConHdl_p >= EPL_MAX_SDO_COM_CON) {
+		Ret = kEplSdoComInvalidHandle;
+		goto Exit;
+	}
+	// get pointer to control structure of connection
+	pSdoComCon = &SdoComInstance_g.m_SdoComCon[SdoComConHdl_p];
+
+	// check if handle ok
+	if (pSdoComCon->m_SdoSeqConHdl == 0) {
+		Ret = kEplSdoComInvalidHandle;
+		goto Exit;
+	}
+	// save pointer to abort code
+	pSdoComCon->m_pData = (BYTE *) & dwAbortCode_p;
+
+	Ret = EplSdoComProcessIntern(SdoComConHdl_p,
+				     kEplSdoComConEventAbort,
+				     (tEplAsySdoCom *) NULL);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 #endif
 
@@ -860,21 +803,22 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoComReceiveCb (tEplSdoSeqConHdl    SdoSeqConHdl_p,
-                                    tEplAsySdoCom*      pAsySdoCom_p,
-                                    unsigned int        uiDataSize_p)
-{
-tEplKernel       Ret;
-
-
-    // search connection internally
-    Ret = EplSdoComSearchConIntern(SdoSeqConHdl_p,
-                                   kEplSdoComConEventRec,
-                                   pAsySdoCom_p);
+tEplKernel PUBLIC EplSdoComReceiveCb(tEplSdoSeqConHdl SdoSeqConHdl_p,
+				     tEplAsySdoCom * pAsySdoCom_p,
+				     unsigned int uiDataSize_p)
+{
+	tEplKernel Ret;
+
+	// search connection internally
+	Ret = EplSdoComSearchConIntern(SdoSeqConHdl_p,
+				       kEplSdoComConEventRec, pAsySdoCom_p);
+
+	EPL_DBGLVL_SDO_TRACE3
+	    ("EplSdoComReceiveCb SdoSeqConHdl: 0x%X, First Byte of pAsySdoCom_p: 0x%02X, uiDataSize_p: 0x%04X\n",
+	     SdoSeqConHdl_p, (WORD) pAsySdoCom_p->m_le_abCommandData[0],
+	     uiDataSize_p);
 
-    EPL_DBGLVL_SDO_TRACE3("EplSdoComReceiveCb SdoSeqConHdl: 0x%X, First Byte of pAsySdoCom_p: 0x%02X, uiDataSize_p: 0x%04X\n", SdoSeqConHdl_p, (WORD)pAsySdoCom_p->m_le_abCommandData[0], uiDataSize_p);
-
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -896,73 +840,71 @@ tEplKernel       Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoComConCb (tEplSdoSeqConHdl    SdoSeqConHdl_p,
-                                    tEplAsySdoConState  AsySdoConState_p)
+tEplKernel PUBLIC EplSdoComConCb(tEplSdoSeqConHdl SdoSeqConHdl_p,
+				 tEplAsySdoConState AsySdoConState_p)
 {
-tEplKernel          Ret;
-tEplSdoComConEvent  SdoComConEvent = kEplSdoComConEventSendFirst;
+	tEplKernel Ret;
+	tEplSdoComConEvent SdoComConEvent = kEplSdoComConEventSendFirst;
+
+	Ret = kEplSuccessful;
 
-    Ret = kEplSuccessful;
+	// check state
+	switch (AsySdoConState_p) {
+	case kAsySdoConStateConnected:
+		{
+			EPL_DBGLVL_SDO_TRACE0("Connection established\n");
+			SdoComConEvent = kEplSdoComConEventConEstablished;
+			// start transmission if needed
+			break;
+		}
+
+	case kAsySdoConStateInitError:
+		{
+			EPL_DBGLVL_SDO_TRACE0("Error during initialisation\n");
+			SdoComConEvent = kEplSdoComConEventInitError;
+			// inform app about error and close sequence layer handle
+			break;
+		}
+
+	case kAsySdoConStateConClosed:
+		{
+			EPL_DBGLVL_SDO_TRACE0("Connection closed\n");
+			SdoComConEvent = kEplSdoComConEventConClosed;
+			// close sequence layer handle
+			break;
+		}
+
+	case kAsySdoConStateAckReceived:
+		{
+			EPL_DBGLVL_SDO_TRACE0("Acknowlage received\n");
+			SdoComConEvent = kEplSdoComConEventAckReceived;
+			// continue transmission
+			break;
+		}
+
+	case kAsySdoConStateFrameSended:
+		{
+			EPL_DBGLVL_SDO_TRACE0("One Frame sent\n");
+			SdoComConEvent = kEplSdoComConEventFrameSended;
+			// to continue transmission
+			break;
+
+		}
+
+	case kAsySdoConStateTimeout:
+		{
+			EPL_DBGLVL_SDO_TRACE0("Timeout\n");
+			SdoComConEvent = kEplSdoComConEventTimeout;
+			// close sequence layer handle
+			break;
 
-    // check state
-    switch(AsySdoConState_p)
-    {
-        case kAsySdoConStateConnected:
-        {
-            EPL_DBGLVL_SDO_TRACE0("Connection established\n");
-            SdoComConEvent = kEplSdoComConEventConEstablished;
-            // start transmission if needed
-            break;
-        }
-
-        case kAsySdoConStateInitError:
-        {
-            EPL_DBGLVL_SDO_TRACE0("Error during initialisation\n");
-            SdoComConEvent = kEplSdoComConEventInitError;
-            // inform app about error and close sequence layer handle
-            break;
-        }
-
-        case kAsySdoConStateConClosed:
-        {
-            EPL_DBGLVL_SDO_TRACE0("Connection closed\n");
-            SdoComConEvent = kEplSdoComConEventConClosed;
-            // close sequence layer handle
-            break;
-        }
-
-        case kAsySdoConStateAckReceived:
-        {
-            EPL_DBGLVL_SDO_TRACE0("Acknowlage received\n");
-            SdoComConEvent = kEplSdoComConEventAckReceived;
-            // continue transmission
-            break;
-        }
-
-        case kAsySdoConStateFrameSended:
-        {
-            EPL_DBGLVL_SDO_TRACE0("One Frame sent\n");
-            SdoComConEvent = kEplSdoComConEventFrameSended;
-            // to continue transmission
-            break;
-
-        }
-
-        case kAsySdoConStateTimeout:
-        {
-            EPL_DBGLVL_SDO_TRACE0("Timeout\n");
-            SdoComConEvent = kEplSdoComConEventTimeout;
-            // close sequence layer handle
-            break;
-
-        }
-    }// end of switch(AsySdoConState_p)
-
-    Ret = EplSdoComSearchConIntern(SdoSeqConHdl_p,
-                                   SdoComConEvent,
-                                   (tEplAsySdoCom*)NULL);
+		}
+	}			// end of switch(AsySdoConState_p)
 
-    return Ret;
+	Ret = EplSdoComSearchConIntern(SdoSeqConHdl_p,
+				       SdoComConEvent, (tEplAsySdoCom *) NULL);
+
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -982,61 +924,53 @@ tEplSdoComConEvent  SdoComConEvent = kEp
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel EplSdoComSearchConIntern(tEplSdoSeqConHdl    SdoSeqConHdl_p,
-                                         tEplSdoComConEvent SdoComConEvent_p,
-                                         tEplAsySdoCom*     pAsySdoCom_p)
-{
-tEplKernel          Ret;
-tEplSdoComCon*      pSdoComCon;
-tEplSdoComConHdl    HdlCount;
-tEplSdoComConHdl    HdlFree;
-
-    Ret = kEplSdoComNotResponsible;
-
-    // get pointer to first element of the array
-    pSdoComCon = &SdoComInstance_g.m_SdoComCon[0];
-    HdlCount = 0;
-    HdlFree = 0xFFFF;
-    while (HdlCount < EPL_MAX_SDO_COM_CON)
-    {
-        if (pSdoComCon->m_SdoSeqConHdl == SdoSeqConHdl_p)
-        {   // matching command layer handle found
-            Ret = EplSdoComProcessIntern(HdlCount,
-                                    SdoComConEvent_p,
-                                    pAsySdoCom_p);
-        }
-        else if ((pSdoComCon->m_SdoSeqConHdl == 0)
-            &&(HdlFree == 0xFFFF))
-        {
-            HdlFree = HdlCount;
-        }
-
-        pSdoComCon++;
-        HdlCount++;
-    }
-
-    if (Ret == kEplSdoComNotResponsible)
-    {   // no responsible command layer handle found
-        if (HdlFree == 0xFFFF)
-        {   // no free handle
-            // delete connection immediately
-            // 2008/04/14 m.u./d.k. This connection actually does not exist.
-            //                      pSdoComCon is invalid.
-            // Ret = EplSdoAsySeqDelCon(pSdoComCon->m_SdoSeqConHdl);
-            Ret = kEplSdoComNoFreeHandle;
-        }
-        else
-        {   // create new handle
-            HdlCount = HdlFree;
-            pSdoComCon = &SdoComInstance_g.m_SdoComCon[HdlCount];
-            pSdoComCon->m_SdoSeqConHdl = SdoSeqConHdl_p;
-            Ret = EplSdoComProcessIntern(HdlCount,
-                                    SdoComConEvent_p,
-                                    pAsySdoCom_p);
-        }
-    }
+static tEplKernel EplSdoComSearchConIntern(tEplSdoSeqConHdl SdoSeqConHdl_p,
+					   tEplSdoComConEvent SdoComConEvent_p,
+					   tEplAsySdoCom * pAsySdoCom_p)
+{
+	tEplKernel Ret;
+	tEplSdoComCon *pSdoComCon;
+	tEplSdoComConHdl HdlCount;
+	tEplSdoComConHdl HdlFree;
+
+	Ret = kEplSdoComNotResponsible;
+
+	// get pointer to first element of the array
+	pSdoComCon = &SdoComInstance_g.m_SdoComCon[0];
+	HdlCount = 0;
+	HdlFree = 0xFFFF;
+	while (HdlCount < EPL_MAX_SDO_COM_CON) {
+		if (pSdoComCon->m_SdoSeqConHdl == SdoSeqConHdl_p) {	// matching command layer handle found
+			Ret = EplSdoComProcessIntern(HdlCount,
+						     SdoComConEvent_p,
+						     pAsySdoCom_p);
+		} else if ((pSdoComCon->m_SdoSeqConHdl == 0)
+			   && (HdlFree == 0xFFFF)) {
+			HdlFree = HdlCount;
+		}
+
+		pSdoComCon++;
+		HdlCount++;
+	}
+
+	if (Ret == kEplSdoComNotResponsible) {	// no responsible command layer handle found
+		if (HdlFree == 0xFFFF) {	// no free handle
+			// delete connection immediately
+			// 2008/04/14 m.u./d.k. This connection actually does not exist.
+			//                      pSdoComCon is invalid.
+			// Ret = EplSdoAsySeqDelCon(pSdoComCon->m_SdoSeqConHdl);
+			Ret = kEplSdoComNoFreeHandle;
+		} else {	// create new handle
+			HdlCount = HdlFree;
+			pSdoComCon = &SdoComInstance_g.m_SdoComCon[HdlCount];
+			pSdoComCon->m_SdoSeqConHdl = SdoSeqConHdl_p;
+			Ret = EplSdoComProcessIntern(HdlCount,
+						     SdoComConEvent_p,
+						     pAsySdoCom_p);
+		}
+	}
 
-    return Ret;
+	return Ret;
 
 }
 
@@ -1059,748 +993,952 @@ tEplSdoComConHdl    HdlFree;
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel EplSdoComProcessIntern(tEplSdoComConHdl   SdoComCon_p,
-                                         tEplSdoComConEvent SdoComConEvent_p,
-                                         tEplAsySdoCom*     pAsySdoCom_p)
-{
-tEplKernel          Ret;
-tEplSdoComCon*      pSdoComCon;
-BYTE                bFlag;
+static tEplKernel EplSdoComProcessIntern(tEplSdoComConHdl SdoComCon_p,
+					 tEplSdoComConEvent SdoComConEvent_p,
+					 tEplAsySdoCom * pAsySdoCom_p)
+{
+	tEplKernel Ret;
+	tEplSdoComCon *pSdoComCon;
+	BYTE bFlag;
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
-DWORD               dwAbortCode;
-unsigned int        uiSize;
+	DWORD dwAbortCode;
+	unsigned int uiSize;
 #endif
 
 #if defined(WIN32) || defined(_WIN32)
-    // enter  critical section for process function
-    EnterCriticalSection(SdoComInstance_g.m_pCriticalSection);
-    EPL_DBGLVL_SDO_TRACE0("\n\tEnterCiticalSection EplSdoComProcessIntern\n\n");
-#endif
-
-    Ret = kEplSuccessful;
-
-    // get pointer to control structure
-    pSdoComCon = &SdoComInstance_g.m_SdoComCon[SdoComCon_p];
-
-    // process state maschine
-    switch(pSdoComCon->m_SdoComState)
-    {
-        // idle state
-        case kEplSdoComStateIdle:
-        {
-            // check events
-            switch(SdoComConEvent_p)
-            {
+	// enter  critical section for process function
+	EnterCriticalSection(SdoComInstance_g.m_pCriticalSection);
+	EPL_DBGLVL_SDO_TRACE0
+	    ("\n\tEnterCiticalSection EplSdoComProcessIntern\n\n");
+#endif
+
+	Ret = kEplSuccessful;
+
+	// get pointer to control structure
+	pSdoComCon = &SdoComInstance_g.m_SdoComCon[SdoComCon_p];
+
+	// process state maschine
+	switch (pSdoComCon->m_SdoComState) {
+		// idle state
+	case kEplSdoComStateIdle:
+		{
+			// check events
+			switch (SdoComConEvent_p) {
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-                // init con for client
-                case kEplSdoComConEventInitCon:
-                {
-
-                    // call of the init function already
-                    // processed in EplSdoComDefineCon()
-                    // only change state to kEplSdoComStateClientWaitInit
-                    pSdoComCon->m_SdoComState = kEplSdoComStateClientWaitInit;
-                    break;
-                }
-#endif
-
-
-                // int con for server
-                case kEplSdoComConEventRec:
-                {
+				// init con for client
+			case kEplSdoComConEventInitCon:
+				{
+
+					// call of the init function already
+					// processed in EplSdoComDefineCon()
+					// only change state to kEplSdoComStateClientWaitInit
+					pSdoComCon->m_SdoComState =
+					    kEplSdoComStateClientWaitInit;
+					break;
+				}
+#endif
+
+				// int con for server
+			case kEplSdoComConEventRec:
+				{
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
-                    // check if init of an transfer and no SDO abort
-                    if ((pAsySdoCom_p->m_le_bFlags & 0x80) == 0)
-                    {   // SDO request
-                        if ((pAsySdoCom_p->m_le_bFlags & 0x40) == 0)
-                        {   // no SDO abort
-                            // save tansaction id
-                            pSdoComCon->m_bTransactionId = AmiGetByteFromLe(&pAsySdoCom_p->m_le_bTransactionId);
-                            // check command
-                            switch(pAsySdoCom_p->m_le_bCommandId)
-                            {
-                                case kEplSdoServiceNIL:
-                                {   // simply acknowlegde NIL command on sequence layer
-
-                                    Ret = EplSdoAsySeqSendData(pSdoComCon->m_SdoSeqConHdl,
-                                                                            0,
-                                                                            (tEplFrame*)NULL);
-
-                                    break;
-                                }
-
-                                case kEplSdoServiceReadByIndex:
-                                {   // read by index
-
-                                    // search entry an start transfer
-                                    EplSdoComServerInitReadByIndex(pSdoComCon,
-                                                                    pAsySdoCom_p);
-                                    // check next state
-                                    if(pSdoComCon->m_uiTransSize == 0)
-                                    {   // ready -> stay idle
-                                        pSdoComCon->m_SdoComState = kEplSdoComStateIdle;
-                                        // reset abort code
-                                        pSdoComCon->m_dwLastAbortCode = 0;
-                                    }
-                                    else
-                                    {   // segmented transfer
-                                        pSdoComCon->m_SdoComState = kEplSdoComStateServerSegmTrans;
-                                    }
-
-                                    break;
-                                }
-
-                                case kEplSdoServiceWriteByIndex:
-                                {
-
-                                    // search entry an start write
-                                    EplSdoComServerInitWriteByIndex(pSdoComCon,
-                                                                    pAsySdoCom_p);
-                                    // check next state
-                                    if(pSdoComCon->m_uiTransSize == 0)
-                                    {   // already -> stay idle
-                                        pSdoComCon->m_SdoComState = kEplSdoComStateIdle;
-                                        // reset abort code
-                                        pSdoComCon->m_dwLastAbortCode = 0;
-                                    }
-                                    else
-                                    {   // segmented transfer
-                                        pSdoComCon->m_SdoComState = kEplSdoComStateServerSegmTrans;
-                                    }
-
-                                    break;
-                                }
-
-                                default:
-                                {
-                                    //  unsupported command
-                                    //       -> abort senden
-                                    dwAbortCode = EPL_SDOAC_UNKNOWN_COMMAND_SPECIFIER;
-                                    // send abort
-                                    pSdoComCon->m_pData = (BYTE*)&dwAbortCode;
-                                    Ret = EplSdoComServerSendFrameIntern(pSdoComCon,
-                                                                0,
-                                                                0,
-                                                                kEplSdoComSendTypeAbort);
-
-                                }
-
-
-                            }// end of switch(pAsySdoCom_p->m_le_bCommandId)
-                        }
-                    }
-                    else
-                    {   // this command layer handle is not responsible
-                        // (wrong direction or wrong transaction ID)
-                        Ret = kEplSdoComNotResponsible;
-                        goto Exit;
-                    }
+					// check if init of an transfer and no SDO abort
+					if ((pAsySdoCom_p->m_le_bFlags & 0x80) == 0) {	// SDO request
+						if ((pAsySdoCom_p->m_le_bFlags & 0x40) == 0) {	// no SDO abort
+							// save tansaction id
+							pSdoComCon->
+							    m_bTransactionId =
+							    AmiGetByteFromLe
+							    (&pAsySdoCom_p->
+							     m_le_bTransactionId);
+							// check command
+							switch (pAsySdoCom_p->
+								m_le_bCommandId)
+							{
+							case kEplSdoServiceNIL:
+								{	// simply acknowlegde NIL command on sequence layer
+
+									Ret =
+									    EplSdoAsySeqSendData
+									    (pSdoComCon->
+									     m_SdoSeqConHdl,
+									     0,
+									     (tEplFrame
+									      *)
+									     NULL);
+
+									break;
+								}
+
+							case kEplSdoServiceReadByIndex:
+								{	// read by index
+
+									// search entry an start transfer
+									EplSdoComServerInitReadByIndex
+									    (pSdoComCon,
+									     pAsySdoCom_p);
+									// check next state
+									if (pSdoComCon->m_uiTransSize == 0) {	// ready -> stay idle
+										pSdoComCon->
+										    m_SdoComState
+										    =
+										    kEplSdoComStateIdle;
+										// reset abort code
+										pSdoComCon->
+										    m_dwLastAbortCode
+										    =
+										    0;
+									} else {	// segmented transfer
+										pSdoComCon->
+										    m_SdoComState
+										    =
+										    kEplSdoComStateServerSegmTrans;
+									}
+
+									break;
+								}
+
+							case kEplSdoServiceWriteByIndex:
+								{
+
+									// search entry an start write
+									EplSdoComServerInitWriteByIndex
+									    (pSdoComCon,
+									     pAsySdoCom_p);
+									// check next state
+									if (pSdoComCon->m_uiTransSize == 0) {	// already -> stay idle
+										pSdoComCon->
+										    m_SdoComState
+										    =
+										    kEplSdoComStateIdle;
+										// reset abort code
+										pSdoComCon->
+										    m_dwLastAbortCode
+										    =
+										    0;
+									} else {	// segmented transfer
+										pSdoComCon->
+										    m_SdoComState
+										    =
+										    kEplSdoComStateServerSegmTrans;
+									}
+
+									break;
+								}
+
+							default:
+								{
+									//  unsupported command
+									//       -> abort senden
+									dwAbortCode
+									    =
+									    EPL_SDOAC_UNKNOWN_COMMAND_SPECIFIER;
+									// send abort
+									pSdoComCon->
+									    m_pData
+									    =
+									    (BYTE
+									     *)
+									    &
+									    dwAbortCode;
+									Ret =
+									    EplSdoComServerSendFrameIntern
+									    (pSdoComCon,
+									     0,
+									     0,
+									     kEplSdoComSendTypeAbort);
+
+								}
+
+							}	// end of switch(pAsySdoCom_p->m_le_bCommandId)
+						}
+					} else {	// this command layer handle is not responsible
+						// (wrong direction or wrong transaction ID)
+						Ret = kEplSdoComNotResponsible;
+						goto Exit;
+					}
 #endif // end of #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
 
-                    break;
-                }
+					break;
+				}
 
-                // connection closed
-                case kEplSdoComConEventInitError:
-                case kEplSdoComConEventTimeout:
-                case kEplSdoComConEventConClosed:
-                {
-                    Ret = EplSdoAsySeqDelCon(pSdoComCon->m_SdoSeqConHdl);
-                    // clean control structure
-                    EPL_MEMSET(pSdoComCon, 0x00, sizeof(tEplSdoComCon));
-                    break;
-                }
-
-                default:
-                    // d.k. do nothing
-                    break;
-            }// end of switch(SdoComConEvent_p)
-            break;
-        }
+				// connection closed
+			case kEplSdoComConEventInitError:
+			case kEplSdoComConEventTimeout:
+			case kEplSdoComConEventConClosed:
+				{
+					Ret =
+					    EplSdoAsySeqDelCon(pSdoComCon->
+							       m_SdoSeqConHdl);
+					// clean control structure
+					EPL_MEMSET(pSdoComCon, 0x00,
+						   sizeof(tEplSdoComCon));
+					break;
+				}
+
+			default:
+				// d.k. do nothing
+				break;
+			}	// end of switch(SdoComConEvent_p)
+			break;
+		}
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
-        //-------------------------------------------------------------------------
-        // SDO Server part
-        // segmented transfer
-        case kEplSdoComStateServerSegmTrans:
-        {
-            // check events
-            switch(SdoComConEvent_p)
-            {
-                // send next frame
-                case kEplSdoComConEventAckReceived:
-                case kEplSdoComConEventFrameSended:
-                {
-                    // check if it is a read
-                    if(pSdoComCon->m_SdoServiceType == kEplSdoServiceReadByIndex)
-                    {
-                        // send next frame
-                        EplSdoComServerSendFrameIntern(pSdoComCon,
-                                                            0,
-                                                            0,
-                                                            kEplSdoComSendTypeRes);
-                        // if all send -> back to idle
-                        if(pSdoComCon->m_uiTransSize == 0)
-                        {   // back to idle
-                            pSdoComCon->m_SdoComState = kEplSdoComStateIdle;
-                            // reset abort code
-                            pSdoComCon->m_dwLastAbortCode = 0;
-                        }
-
-                    }
-                    break;
-                }
-
-                // process next frame
-                case kEplSdoComConEventRec:
-                {
-                    // check if the frame is a SDO response and has the right transaction ID
-                    bFlag = AmiGetByteFromLe(&pAsySdoCom_p->m_le_bFlags);
-                    if (((bFlag & 0x80) != 0) && (AmiGetByteFromLe(&pAsySdoCom_p->m_le_bTransactionId) == pSdoComCon->m_bTransactionId))
-                    {
-                        // check if it is a abort
-                        if((bFlag & 0x40) != 0)
-                        {   // SDO abort
-                            // clear control structure
-                            pSdoComCon->m_uiTransSize = 0;
-                            pSdoComCon->m_uiTransferredByte = 0;
-                            // change state
-                            pSdoComCon->m_SdoComState = kEplSdoComStateIdle;
-                            // reset abort code
-                            pSdoComCon->m_dwLastAbortCode = 0;
-                            // d.k.: do not execute anything further on this command
-                            break;
-                        }
-
-                        // check if it is a write
-                        if(pSdoComCon->m_SdoServiceType == kEplSdoServiceWriteByIndex)
-                        {
-                            // write data to OD
-                            uiSize = AmiGetWordFromLe(&pAsySdoCom_p->m_le_wSegmentSize);
-                            if(pSdoComCon->m_dwLastAbortCode == 0)
-                            {
-                                EPL_MEMCPY(pSdoComCon->m_pData, &pAsySdoCom_p->m_le_abCommandData[0],uiSize);
-                            }
-                            // update counter
-                            pSdoComCon->m_uiTransferredByte += uiSize;
-                            pSdoComCon->m_uiTransSize -= uiSize;
-
-                            // update pointer
-                            if(pSdoComCon->m_dwLastAbortCode == 0)
-                            {
-                                (/*(BYTE*)*/pSdoComCon->m_pData) += uiSize;
-                            }
-
-                            // check end of transfer
-                            if((pAsySdoCom_p->m_le_bFlags & 0x30) == 0x30)
-                            {   // transfer ready
-                                pSdoComCon->m_uiTransSize = 0;
-
-                                if(pSdoComCon->m_dwLastAbortCode == 0)
-                                {
-                                    // send response
-                                    // send next frame
-                                    EplSdoComServerSendFrameIntern(pSdoComCon,
-                                                                        0,
-                                                                        0,
-                                                                        kEplSdoComSendTypeRes);
-                                    // if all send -> back to idle
-                                    if(pSdoComCon->m_uiTransSize == 0)
-                                    {   // back to idle
-                                        pSdoComCon->m_SdoComState = kEplSdoComStateIdle;
-                                        // reset abort code
-                                        pSdoComCon->m_dwLastAbortCode = 0;
-                                    }
-                                }
-                                else
-                                {   // send dabort code
-                                    // send abort
-                                    pSdoComCon->m_pData = (BYTE*)&pSdoComCon->m_dwLastAbortCode;
-                                    Ret = EplSdoComServerSendFrameIntern(pSdoComCon,
-                                                                0,
-                                                                0,
-                                                                kEplSdoComSendTypeAbort);
-
-                                    // reset abort code
-                                    pSdoComCon->m_dwLastAbortCode = 0;
-
-                                }
-                            }
-                            else
-                            {
-                                // send acknowledge without any Command layer data
-                                Ret = EplSdoAsySeqSendData(pSdoComCon->m_SdoSeqConHdl,
-                                                                        0,
-                                                                        (tEplFrame*)NULL);
-                            }
-                        }
-                    }
-                    else
-                    {   // this command layer handle is not responsible
-                        // (wrong direction or wrong transaction ID)
-                        Ret = kEplSdoComNotResponsible;
-                        goto Exit;
-                    }
-                    break;
-                }
-
-                // connection closed
-                case kEplSdoComConEventInitError:
-                case kEplSdoComConEventTimeout:
-                case kEplSdoComConEventConClosed:
-                {
-                    Ret = EplSdoAsySeqDelCon(pSdoComCon->m_SdoSeqConHdl);
-                    // clean control structure
-                    EPL_MEMSET(pSdoComCon, 0x00, sizeof(tEplSdoComCon));
-                    break;
-                }
-
-                default:
-                    // d.k. do nothing
-                    break;
-            }// end of switch(SdoComConEvent_p)
+		//-------------------------------------------------------------------------
+		// SDO Server part
+		// segmented transfer
+	case kEplSdoComStateServerSegmTrans:
+		{
+			// check events
+			switch (SdoComConEvent_p) {
+				// send next frame
+			case kEplSdoComConEventAckReceived:
+			case kEplSdoComConEventFrameSended:
+				{
+					// check if it is a read
+					if (pSdoComCon->m_SdoServiceType ==
+					    kEplSdoServiceReadByIndex) {
+						// send next frame
+						EplSdoComServerSendFrameIntern
+						    (pSdoComCon, 0, 0,
+						     kEplSdoComSendTypeRes);
+						// if all send -> back to idle
+						if (pSdoComCon->m_uiTransSize == 0) {	// back to idle
+							pSdoComCon->
+							    m_SdoComState =
+							    kEplSdoComStateIdle;
+							// reset abort code
+							pSdoComCon->
+							    m_dwLastAbortCode =
+							    0;
+						}
+
+					}
+					break;
+				}
+
+				// process next frame
+			case kEplSdoComConEventRec:
+				{
+					// check if the frame is a SDO response and has the right transaction ID
+					bFlag =
+					    AmiGetByteFromLe(&pAsySdoCom_p->
+							     m_le_bFlags);
+					if (((bFlag & 0x80) != 0)
+					    &&
+					    (AmiGetByteFromLe
+					     (&pAsySdoCom_p->
+					      m_le_bTransactionId) ==
+					     pSdoComCon->m_bTransactionId)) {
+						// check if it is a abort
+						if ((bFlag & 0x40) != 0) {	// SDO abort
+							// clear control structure
+							pSdoComCon->
+							    m_uiTransSize = 0;
+							pSdoComCon->
+							    m_uiTransferredByte
+							    = 0;
+							// change state
+							pSdoComCon->
+							    m_SdoComState =
+							    kEplSdoComStateIdle;
+							// reset abort code
+							pSdoComCon->
+							    m_dwLastAbortCode =
+							    0;
+							// d.k.: do not execute anything further on this command
+							break;
+						}
+						// check if it is a write
+						if (pSdoComCon->
+						    m_SdoServiceType ==
+						    kEplSdoServiceWriteByIndex)
+						{
+							// write data to OD
+							uiSize =
+							    AmiGetWordFromLe
+							    (&pAsySdoCom_p->
+							     m_le_wSegmentSize);
+							if (pSdoComCon->
+							    m_dwLastAbortCode ==
+							    0) {
+								EPL_MEMCPY
+								    (pSdoComCon->
+								     m_pData,
+								     &pAsySdoCom_p->
+								     m_le_abCommandData
+								     [0],
+								     uiSize);
+							}
+							// update counter
+							pSdoComCon->
+							    m_uiTransferredByte
+							    += uiSize;
+							pSdoComCon->
+							    m_uiTransSize -=
+							    uiSize;
+
+							// update pointer
+							if (pSdoComCon->
+							    m_dwLastAbortCode ==
+							    0) {
+								( /*(BYTE*) */
+								 pSdoComCon->
+								 m_pData) +=
+						      uiSize;
+							}
+							// check end of transfer
+							if ((pAsySdoCom_p->m_le_bFlags & 0x30) == 0x30) {	// transfer ready
+								pSdoComCon->
+								    m_uiTransSize
+								    = 0;
+
+								if (pSdoComCon->
+								    m_dwLastAbortCode
+								    == 0) {
+									// send response
+									// send next frame
+									EplSdoComServerSendFrameIntern
+									    (pSdoComCon,
+									     0,
+									     0,
+									     kEplSdoComSendTypeRes);
+									// if all send -> back to idle
+									if (pSdoComCon->m_uiTransSize == 0) {	// back to idle
+										pSdoComCon->
+										    m_SdoComState
+										    =
+										    kEplSdoComStateIdle;
+										// reset abort code
+										pSdoComCon->
+										    m_dwLastAbortCode
+										    =
+										    0;
+									}
+								} else {	// send dabort code
+									// send abort
+									pSdoComCon->
+									    m_pData
+									    =
+									    (BYTE
+									     *)
+									    &
+									    pSdoComCon->
+									    m_dwLastAbortCode;
+									Ret =
+									    EplSdoComServerSendFrameIntern
+									    (pSdoComCon,
+									     0,
+									     0,
+									     kEplSdoComSendTypeAbort);
+
+									// reset abort code
+									pSdoComCon->
+									    m_dwLastAbortCode
+									    = 0;
+
+								}
+							} else {
+								// send acknowledge without any Command layer data
+								Ret =
+								    EplSdoAsySeqSendData
+								    (pSdoComCon->
+								     m_SdoSeqConHdl,
+								     0,
+								     (tEplFrame
+								      *) NULL);
+							}
+						}
+					} else {	// this command layer handle is not responsible
+						// (wrong direction or wrong transaction ID)
+						Ret = kEplSdoComNotResponsible;
+						goto Exit;
+					}
+					break;
+				}
+
+				// connection closed
+			case kEplSdoComConEventInitError:
+			case kEplSdoComConEventTimeout:
+			case kEplSdoComConEventConClosed:
+				{
+					Ret =
+					    EplSdoAsySeqDelCon(pSdoComCon->
+							       m_SdoSeqConHdl);
+					// clean control structure
+					EPL_MEMSET(pSdoComCon, 0x00,
+						   sizeof(tEplSdoComCon));
+					break;
+				}
+
+			default:
+				// d.k. do nothing
+				break;
+			}	// end of switch(SdoComConEvent_p)
 
-            break;
-        }
+			break;
+		}
 #endif // endif of #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
 
-
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-        //-------------------------------------------------------------------------
-        // SDO Client part
-        // wait for finish of establishing connection
-        case kEplSdoComStateClientWaitInit:
-        {
-
-            // if connection handle is invalid reinit connection
-            // d.k.: this will be done only on new events (i.e. InitTransfer)
-            if((pSdoComCon->m_SdoSeqConHdl & ~EPL_SDO_SEQ_HANDLE_MASK) == EPL_SDO_SEQ_INVALID_HDL)
-            {
-                // check kind of connection to reinit
-                // check protocol
-                switch(pSdoComCon->m_SdoProtType)
-                {
-                    // udp
-                    case kEplSdoTypeUdp:
-                    {
-                        // call connection int function of lower layer
-                        Ret = EplSdoAsySeqInitCon(&pSdoComCon->m_SdoSeqConHdl,
-                                    pSdoComCon->m_uiNodeId,
-                                    kEplSdoTypeUdp);
-                        if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        break;
-                    }
-
-                    // Asend -> not supported
-                    case kEplSdoTypeAsnd:
-                    {
-                        // call connection int function of lower layer
-                        Ret = EplSdoAsySeqInitCon(&pSdoComCon->m_SdoSeqConHdl,
-                                    pSdoComCon->m_uiNodeId,
-                                    kEplSdoTypeAsnd);
-                        if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-                        break;
-                    }
-
-                    // Pdo -> not supported
-                    case kEplSdoTypePdo:
-                    default:
-                    {
-                        Ret = kEplSdoComUnsupportedProt;
-                        goto Exit;
-                    }
-                }// end of switch(m_ProtType_p)
-                // d.k.: reset transaction ID, because new sequence layer connection was initialized
-                // $$$ d.k. is this really necessary?
-                //pSdoComCon->m_bTransactionId = 0;
-            }
-
-            // check events
-            switch(SdoComConEvent_p)
-            {
-                // connection established
-                case kEplSdoComConEventConEstablished:
-                {
-                    //send first frame if needed
-                    if((pSdoComCon->m_uiTransSize > 0)
-                        &&(pSdoComCon->m_uiTargetIndex != 0))
-                    {   // start SDO transfer
-                        Ret = EplSdoComClientSend(pSdoComCon);
-                        if(Ret != kEplSuccessful)
-                        {
-                            goto Exit;
-                        }
-
-                        // check if segemted transfer
-                        if(pSdoComCon->m_SdoTransType == kEplSdoTransSegmented)
-                        {
-                            pSdoComCon->m_SdoComState = kEplSdoComStateClientSegmTrans;
-                            goto Exit;
-                        }
-                    }
-                    // goto state kEplSdoComStateClientConnected
-                    pSdoComCon->m_SdoComState = kEplSdoComStateClientConnected;
-                    goto Exit;
-                }
-
-                case kEplSdoComConEventSendFirst:
-                {
-                    // infos for transfer already saved by function EplSdoComInitTransferByIndex
-                    break;
-                }
-
-                case kEplSdoComConEventConClosed:
-                case kEplSdoComConEventInitError:
-                case kEplSdoComConEventTimeout:
-                {
-                    // close sequence layer handle
-                    Ret = EplSdoAsySeqDelCon(pSdoComCon->m_SdoSeqConHdl);
-                    pSdoComCon->m_SdoSeqConHdl |= EPL_SDO_SEQ_INVALID_HDL;
-                    // call callback function
-                    if (SdoComConEvent_p == kEplSdoComConEventTimeout)
-                    {
-                        pSdoComCon->m_dwLastAbortCode = EPL_SDOAC_TIME_OUT;
-                    }
-                    else
-                    {
-                        pSdoComCon->m_dwLastAbortCode = 0;
-                    }
-                    Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferLowerLayerAbort);
-                    // d.k.: do not clean control structure
-                    break;
-                }
-
-                default:
-                    // d.k. do nothing
-                    break;
-
-            } // end of  switch(SdoComConEvent_p)
-            break;
-        }
-
-        // connected
-        case kEplSdoComStateClientConnected:
-        {
-            // check events
-            switch(SdoComConEvent_p)
-            {
-                // send a frame
-                case kEplSdoComConEventSendFirst:
-                case kEplSdoComConEventAckReceived:
-                case kEplSdoComConEventFrameSended:
-                {
-                    Ret = EplSdoComClientSend(pSdoComCon);
-                    if(Ret != kEplSuccessful)
-                    {
-                        goto Exit;
-                    }
-
-                    // check if read transfer finished
-                    if((pSdoComCon->m_uiTransSize == 0)
-                        && (pSdoComCon->m_uiTransferredByte != 0)
-                        && (pSdoComCon->m_SdoServiceType == kEplSdoServiceReadByIndex))
-                    {
-                        // inc transaction id
-                        pSdoComCon->m_bTransactionId++;
-                        // call callback of application
-                        pSdoComCon->m_dwLastAbortCode = 0;
-                        Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferFinished);
-
-                        goto Exit;
-                    }
-
-                    // check if segemted transfer
-                    if(pSdoComCon->m_SdoTransType == kEplSdoTransSegmented)
-                    {
-                        pSdoComCon->m_SdoComState = kEplSdoComStateClientSegmTrans;
-                        goto Exit;
-                    }
-                    break;
-                }
-
-                // frame received
-                case kEplSdoComConEventRec:
-                {
-                    // check if the frame is a SDO response and has the right transaction ID
-                    bFlag = AmiGetByteFromLe(&pAsySdoCom_p->m_le_bFlags);
-                    if (((bFlag & 0x80) != 0) && (AmiGetByteFromLe(&pAsySdoCom_p->m_le_bTransactionId) == pSdoComCon->m_bTransactionId))
-                    {
-                        // check if abort or not
-                        if((bFlag & 0x40) != 0)
-                        {
-                            // send acknowledge without any Command layer data
-                            Ret = EplSdoAsySeqSendData(pSdoComCon->m_SdoSeqConHdl,
-                                                                    0,
-                                                                    (tEplFrame*)NULL);
-                            // inc transaction id
-                            pSdoComCon->m_bTransactionId++;
-                            // save abort code
-                            pSdoComCon->m_dwLastAbortCode = AmiGetDwordFromLe(&pAsySdoCom_p->m_le_abCommandData[0]);
-                            // call callback of application
-                            Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferRxAborted);
-
-                            goto Exit;
-                        }
-                        else
-                        {   // normal frame received
-                            // check frame
-                            Ret = EplSdoComClientProcessFrame(SdoComCon_p, pAsySdoCom_p);
-
-                            // check if transfer ready
-                            if(pSdoComCon->m_uiTransSize == 0)
-                            {
-                                // send acknowledge without any Command layer data
-                                Ret = EplSdoAsySeqSendData(pSdoComCon->m_SdoSeqConHdl,
-                                                                        0,
-                                                                        (tEplFrame*)NULL);
-                                // inc transaction id
-                                pSdoComCon->m_bTransactionId++;
-                                // call callback of application
-                                pSdoComCon->m_dwLastAbortCode = 0;
-                                Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferFinished);
-
-                                goto Exit;
-                            }
-
-                        }
-                    }
-                    else
-                    {   // this command layer handle is not responsible
-                        // (wrong direction or wrong transaction ID)
-                        Ret = kEplSdoComNotResponsible;
-                        goto Exit;
-                    }
-                    break;
-                }
-
-                // connection closed event go back to kEplSdoComStateClientWaitInit
-                case kEplSdoComConEventConClosed:
-                {   // connection closed by communication partner
-                    // close sequence layer handle
-                    Ret = EplSdoAsySeqDelCon(pSdoComCon->m_SdoSeqConHdl);
-                    // set handle to invalid and enter kEplSdoComStateClientWaitInit
-                    pSdoComCon->m_SdoSeqConHdl |= EPL_SDO_SEQ_INVALID_HDL;
-                    // change state
-                    pSdoComCon->m_SdoComState = kEplSdoComStateClientWaitInit;
-
-                    // call callback of application
-                    pSdoComCon->m_dwLastAbortCode = 0;
-                    Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferLowerLayerAbort);
-
-                    goto Exit;
-
-                    break;
-                }
-
-                // abort to send from higher layer
-                case kEplSdoComConEventAbort:
-                {
-                    EplSdoComClientSendAbort(pSdoComCon,*((DWORD*)pSdoComCon->m_pData));
-
-                    // inc transaction id
-                    pSdoComCon->m_bTransactionId++;
-                    // call callback of application
-                    pSdoComCon->m_dwLastAbortCode = *((DWORD*)pSdoComCon->m_pData);
-                    Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferTxAborted);
-
-                    break;
-                }
-
-                case kEplSdoComConEventInitError:
-                case kEplSdoComConEventTimeout:
-                {
-                    // close sequence layer handle
-                    Ret = EplSdoAsySeqDelCon(pSdoComCon->m_SdoSeqConHdl);
-                    pSdoComCon->m_SdoSeqConHdl |= EPL_SDO_SEQ_INVALID_HDL;
-                    // change state
-                    pSdoComCon->m_SdoComState = kEplSdoComStateClientWaitInit;
-                    // call callback of application
-                    pSdoComCon->m_dwLastAbortCode = EPL_SDOAC_TIME_OUT;
-                    Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferLowerLayerAbort);
-
-                }
-
-                default:
-                    // d.k. do nothing
-                    break;
-
-            } // end of switch(SdoComConEvent_p)
-
-            break;
-        }
-
-        // process segmented transfer
-        case kEplSdoComStateClientSegmTrans:
-        {
-            // check events
-            switch(SdoComConEvent_p)
-            {
-                // sned a frame
-                case kEplSdoComConEventSendFirst:
-                case kEplSdoComConEventAckReceived:
-                case kEplSdoComConEventFrameSended:
-                {
-                    Ret = EplSdoComClientSend(pSdoComCon);
-                    if(Ret != kEplSuccessful)
-                    {
-                        goto Exit;
-                    }
-
-                    // check if read transfer finished
-                    if((pSdoComCon->m_uiTransSize == 0)
-                        && (pSdoComCon->m_SdoServiceType == kEplSdoServiceReadByIndex))
-                    {
-                        // inc transaction id
-                        pSdoComCon->m_bTransactionId++;
-                        // change state
-                        pSdoComCon->m_SdoComState = kEplSdoComStateClientConnected;
-                        // call callback of application
-                        pSdoComCon->m_dwLastAbortCode = 0;
-                        Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferFinished);
-
-                        goto Exit;
-                    }
-
-                    break;
-                }
-
-                // frame received
-                case kEplSdoComConEventRec:
-                {
-                    // check if the frame is a response
-                    bFlag = AmiGetByteFromLe(&pAsySdoCom_p->m_le_bFlags);
-                    if (((bFlag & 0x80) != 0) && (AmiGetByteFromLe(&pAsySdoCom_p->m_le_bTransactionId) == pSdoComCon->m_bTransactionId))
-                    {
-                        // check if abort or not
-                        if((bFlag & 0x40) != 0)
-                        {
-                            // send acknowledge without any Command layer data
-                            Ret = EplSdoAsySeqSendData(pSdoComCon->m_SdoSeqConHdl,
-                                                                    0,
-                                                                    (tEplFrame*)NULL);
-                            // inc transaction id
-                            pSdoComCon->m_bTransactionId++;
-                            // change state
-                            pSdoComCon->m_SdoComState = kEplSdoComStateClientConnected;
-                            // save abort code
-                            pSdoComCon->m_dwLastAbortCode = AmiGetDwordFromLe(&pAsySdoCom_p->m_le_abCommandData[0]);
-                            // call callback of application
-                            Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferRxAborted);
-
-                            goto Exit;
-                        }
-                        else
-                        {   // normal frame received
-                            // check frame
-                            Ret = EplSdoComClientProcessFrame(SdoComCon_p, pAsySdoCom_p);
-
-                            // check if transfer ready
-                            if(pSdoComCon->m_uiTransSize == 0)
-                            {
-                                // send acknowledge without any Command layer data
-                                Ret = EplSdoAsySeqSendData(pSdoComCon->m_SdoSeqConHdl,
-                                                                        0,
-                                                                        (tEplFrame*)NULL);
-                                // inc transaction id
-                                pSdoComCon->m_bTransactionId++;
-                                // change state
-                                pSdoComCon->m_SdoComState = kEplSdoComStateClientConnected;
-                                // call callback of application
-                                pSdoComCon->m_dwLastAbortCode = 0;
-                                Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferFinished);
-
-                            }
-
-                        }
-                    }
-                    break;
-                }
-
-                // connection closed event go back to kEplSdoComStateClientWaitInit
-                case kEplSdoComConEventConClosed:
-                {   // connection closed by communication partner
-                    // close sequence layer handle
-                    Ret = EplSdoAsySeqDelCon(pSdoComCon->m_SdoSeqConHdl);
-                    // set handle to invalid and enter kEplSdoComStateClientWaitInit
-                    pSdoComCon->m_SdoSeqConHdl |= EPL_SDO_SEQ_INVALID_HDL;
-                    // change state
-                    pSdoComCon->m_SdoComState = kEplSdoComStateClientWaitInit;
-                    // inc transaction id
-                    pSdoComCon->m_bTransactionId++;
-                    // call callback of application
-                    pSdoComCon->m_dwLastAbortCode = 0;
-                    Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferFinished);
-
-                    break;
-                }
-
-                // abort to send from higher layer
-                case kEplSdoComConEventAbort:
-                {
-                    EplSdoComClientSendAbort(pSdoComCon,*((DWORD*)pSdoComCon->m_pData));
-
-                    // inc transaction id
-                    pSdoComCon->m_bTransactionId++;
-                    // change state
-                    pSdoComCon->m_SdoComState = kEplSdoComStateClientConnected;
-                    // call callback of application
-                    pSdoComCon->m_dwLastAbortCode = *((DWORD*)pSdoComCon->m_pData);
-                    Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferTxAborted);
-
-                    break;
-                }
-
-                case kEplSdoComConEventInitError:
-                case kEplSdoComConEventTimeout:
-                {
-                    // close sequence layer handle
-                    Ret = EplSdoAsySeqDelCon(pSdoComCon->m_SdoSeqConHdl);
-                    pSdoComCon->m_SdoSeqConHdl |= EPL_SDO_SEQ_INVALID_HDL;
-                    // change state
-                    pSdoComCon->m_SdoComState = kEplSdoComStateClientWaitInit;
-                    // call callback of application
-                    pSdoComCon->m_dwLastAbortCode = EPL_SDOAC_TIME_OUT;
-                    Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferLowerLayerAbort);
-
-                }
-
-                default:
-                    // d.k. do nothing
-                    break;
+		//-------------------------------------------------------------------------
+		// SDO Client part
+		// wait for finish of establishing connection
+	case kEplSdoComStateClientWaitInit:
+		{
+
+			// if connection handle is invalid reinit connection
+			// d.k.: this will be done only on new events (i.e. InitTransfer)
+			if ((pSdoComCon->
+			     m_SdoSeqConHdl & ~EPL_SDO_SEQ_HANDLE_MASK) ==
+			    EPL_SDO_SEQ_INVALID_HDL) {
+				// check kind of connection to reinit
+				// check protocol
+				switch (pSdoComCon->m_SdoProtType) {
+					// udp
+				case kEplSdoTypeUdp:
+					{
+						// call connection int function of lower layer
+						Ret =
+						    EplSdoAsySeqInitCon
+						    (&pSdoComCon->
+						     m_SdoSeqConHdl,
+						     pSdoComCon->m_uiNodeId,
+						     kEplSdoTypeUdp);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						break;
+					}
+
+					// Asend -> not supported
+				case kEplSdoTypeAsnd:
+					{
+						// call connection int function of lower layer
+						Ret =
+						    EplSdoAsySeqInitCon
+						    (&pSdoComCon->
+						     m_SdoSeqConHdl,
+						     pSdoComCon->m_uiNodeId,
+						     kEplSdoTypeAsnd);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						break;
+					}
+
+					// Pdo -> not supported
+				case kEplSdoTypePdo:
+				default:
+					{
+						Ret = kEplSdoComUnsupportedProt;
+						goto Exit;
+					}
+				}	// end of switch(m_ProtType_p)
+				// d.k.: reset transaction ID, because new sequence layer connection was initialized
+				// $$$ d.k. is this really necessary?
+				//pSdoComCon->m_bTransactionId = 0;
+			}
+			// check events
+			switch (SdoComConEvent_p) {
+				// connection established
+			case kEplSdoComConEventConEstablished:
+				{
+					//send first frame if needed
+					if ((pSdoComCon->m_uiTransSize > 0)
+					    && (pSdoComCon->m_uiTargetIndex != 0)) {	// start SDO transfer
+						Ret =
+						    EplSdoComClientSend
+						    (pSdoComCon);
+						if (Ret != kEplSuccessful) {
+							goto Exit;
+						}
+						// check if segemted transfer
+						if (pSdoComCon->
+						    m_SdoTransType ==
+						    kEplSdoTransSegmented) {
+							pSdoComCon->
+							    m_SdoComState =
+							    kEplSdoComStateClientSegmTrans;
+							goto Exit;
+						}
+					}
+					// goto state kEplSdoComStateClientConnected
+					pSdoComCon->m_SdoComState =
+					    kEplSdoComStateClientConnected;
+					goto Exit;
+				}
+
+			case kEplSdoComConEventSendFirst:
+				{
+					// infos for transfer already saved by function EplSdoComInitTransferByIndex
+					break;
+				}
+
+			case kEplSdoComConEventConClosed:
+			case kEplSdoComConEventInitError:
+			case kEplSdoComConEventTimeout:
+				{
+					// close sequence layer handle
+					Ret =
+					    EplSdoAsySeqDelCon(pSdoComCon->
+							       m_SdoSeqConHdl);
+					pSdoComCon->m_SdoSeqConHdl |=
+					    EPL_SDO_SEQ_INVALID_HDL;
+					// call callback function
+					if (SdoComConEvent_p ==
+					    kEplSdoComConEventTimeout) {
+						pSdoComCon->m_dwLastAbortCode =
+						    EPL_SDOAC_TIME_OUT;
+					} else {
+						pSdoComCon->m_dwLastAbortCode =
+						    0;
+					}
+					Ret =
+					    EplSdoComTransferFinished
+					    (SdoComCon_p, pSdoComCon,
+					     kEplSdoComTransferLowerLayerAbort);
+					// d.k.: do not clean control structure
+					break;
+				}
+
+			default:
+				// d.k. do nothing
+				break;
+
+			}	// end of  switch(SdoComConEvent_p)
+			break;
+		}
+
+		// connected
+	case kEplSdoComStateClientConnected:
+		{
+			// check events
+			switch (SdoComConEvent_p) {
+				// send a frame
+			case kEplSdoComConEventSendFirst:
+			case kEplSdoComConEventAckReceived:
+			case kEplSdoComConEventFrameSended:
+				{
+					Ret = EplSdoComClientSend(pSdoComCon);
+					if (Ret != kEplSuccessful) {
+						goto Exit;
+					}
+					// check if read transfer finished
+					if ((pSdoComCon->m_uiTransSize == 0)
+					    && (pSdoComCon->
+						m_uiTransferredByte != 0)
+					    && (pSdoComCon->m_SdoServiceType ==
+						kEplSdoServiceReadByIndex)) {
+						// inc transaction id
+						pSdoComCon->m_bTransactionId++;
+						// call callback of application
+						pSdoComCon->m_dwLastAbortCode =
+						    0;
+						Ret =
+						    EplSdoComTransferFinished
+						    (SdoComCon_p, pSdoComCon,
+						     kEplSdoComTransferFinished);
+
+						goto Exit;
+					}
+					// check if segemted transfer
+					if (pSdoComCon->m_SdoTransType ==
+					    kEplSdoTransSegmented) {
+						pSdoComCon->m_SdoComState =
+						    kEplSdoComStateClientSegmTrans;
+						goto Exit;
+					}
+					break;
+				}
+
+				// frame received
+			case kEplSdoComConEventRec:
+				{
+					// check if the frame is a SDO response and has the right transaction ID
+					bFlag =
+					    AmiGetByteFromLe(&pAsySdoCom_p->
+							     m_le_bFlags);
+					if (((bFlag & 0x80) != 0)
+					    &&
+					    (AmiGetByteFromLe
+					     (&pAsySdoCom_p->
+					      m_le_bTransactionId) ==
+					     pSdoComCon->m_bTransactionId)) {
+						// check if abort or not
+						if ((bFlag & 0x40) != 0) {
+							// send acknowledge without any Command layer data
+							Ret =
+							    EplSdoAsySeqSendData
+							    (pSdoComCon->
+							     m_SdoSeqConHdl, 0,
+							     (tEplFrame *)
+							     NULL);
+							// inc transaction id
+							pSdoComCon->
+							    m_bTransactionId++;
+							// save abort code
+							pSdoComCon->
+							    m_dwLastAbortCode =
+							    AmiGetDwordFromLe
+							    (&pAsySdoCom_p->
+							     m_le_abCommandData
+							     [0]);
+							// call callback of application
+							Ret =
+							    EplSdoComTransferFinished
+							    (SdoComCon_p,
+							     pSdoComCon,
+							     kEplSdoComTransferRxAborted);
+
+							goto Exit;
+						} else {	// normal frame received
+							// check frame
+							Ret =
+							    EplSdoComClientProcessFrame
+							    (SdoComCon_p,
+							     pAsySdoCom_p);
+
+							// check if transfer ready
+							if (pSdoComCon->
+							    m_uiTransSize ==
+							    0) {
+								// send acknowledge without any Command layer data
+								Ret =
+								    EplSdoAsySeqSendData
+								    (pSdoComCon->
+								     m_SdoSeqConHdl,
+								     0,
+								     (tEplFrame
+								      *) NULL);
+								// inc transaction id
+								pSdoComCon->
+								    m_bTransactionId++;
+								// call callback of application
+								pSdoComCon->
+								    m_dwLastAbortCode
+								    = 0;
+								Ret =
+								    EplSdoComTransferFinished
+								    (SdoComCon_p,
+								     pSdoComCon,
+								     kEplSdoComTransferFinished);
+
+								goto Exit;
+							}
+
+						}
+					} else {	// this command layer handle is not responsible
+						// (wrong direction or wrong transaction ID)
+						Ret = kEplSdoComNotResponsible;
+						goto Exit;
+					}
+					break;
+				}
+
+				// connection closed event go back to kEplSdoComStateClientWaitInit
+			case kEplSdoComConEventConClosed:
+				{	// connection closed by communication partner
+					// close sequence layer handle
+					Ret =
+					    EplSdoAsySeqDelCon(pSdoComCon->
+							       m_SdoSeqConHdl);
+					// set handle to invalid and enter kEplSdoComStateClientWaitInit
+					pSdoComCon->m_SdoSeqConHdl |=
+					    EPL_SDO_SEQ_INVALID_HDL;
+					// change state
+					pSdoComCon->m_SdoComState =
+					    kEplSdoComStateClientWaitInit;
+
+					// call callback of application
+					pSdoComCon->m_dwLastAbortCode = 0;
+					Ret =
+					    EplSdoComTransferFinished
+					    (SdoComCon_p, pSdoComCon,
+					     kEplSdoComTransferLowerLayerAbort);
+
+					goto Exit;
+
+					break;
+				}
+
+				// abort to send from higher layer
+			case kEplSdoComConEventAbort:
+				{
+					EplSdoComClientSendAbort(pSdoComCon,
+								 *((DWORD *)
+								   pSdoComCon->
+								   m_pData));
+
+					// inc transaction id
+					pSdoComCon->m_bTransactionId++;
+					// call callback of application
+					pSdoComCon->m_dwLastAbortCode =
+					    *((DWORD *) pSdoComCon->m_pData);
+					Ret =
+					    EplSdoComTransferFinished
+					    (SdoComCon_p, pSdoComCon,
+					     kEplSdoComTransferTxAborted);
+
+					break;
+				}
+
+			case kEplSdoComConEventInitError:
+			case kEplSdoComConEventTimeout:
+				{
+					// close sequence layer handle
+					Ret =
+					    EplSdoAsySeqDelCon(pSdoComCon->
+							       m_SdoSeqConHdl);
+					pSdoComCon->m_SdoSeqConHdl |=
+					    EPL_SDO_SEQ_INVALID_HDL;
+					// change state
+					pSdoComCon->m_SdoComState =
+					    kEplSdoComStateClientWaitInit;
+					// call callback of application
+					pSdoComCon->m_dwLastAbortCode =
+					    EPL_SDOAC_TIME_OUT;
+					Ret =
+					    EplSdoComTransferFinished
+					    (SdoComCon_p, pSdoComCon,
+					     kEplSdoComTransferLowerLayerAbort);
+
+				}
+
+			default:
+				// d.k. do nothing
+				break;
+
+			}	// end of switch(SdoComConEvent_p)
+
+			break;
+		}
+
+		// process segmented transfer
+	case kEplSdoComStateClientSegmTrans:
+		{
+			// check events
+			switch (SdoComConEvent_p) {
+				// sned a frame
+			case kEplSdoComConEventSendFirst:
+			case kEplSdoComConEventAckReceived:
+			case kEplSdoComConEventFrameSended:
+				{
+					Ret = EplSdoComClientSend(pSdoComCon);
+					if (Ret != kEplSuccessful) {
+						goto Exit;
+					}
+					// check if read transfer finished
+					if ((pSdoComCon->m_uiTransSize == 0)
+					    && (pSdoComCon->m_SdoServiceType ==
+						kEplSdoServiceReadByIndex)) {
+						// inc transaction id
+						pSdoComCon->m_bTransactionId++;
+						// change state
+						pSdoComCon->m_SdoComState =
+						    kEplSdoComStateClientConnected;
+						// call callback of application
+						pSdoComCon->m_dwLastAbortCode =
+						    0;
+						Ret =
+						    EplSdoComTransferFinished
+						    (SdoComCon_p, pSdoComCon,
+						     kEplSdoComTransferFinished);
+
+						goto Exit;
+					}
+
+					break;
+				}
+
+				// frame received
+			case kEplSdoComConEventRec:
+				{
+					// check if the frame is a response
+					bFlag =
+					    AmiGetByteFromLe(&pAsySdoCom_p->
+							     m_le_bFlags);
+					if (((bFlag & 0x80) != 0)
+					    &&
+					    (AmiGetByteFromLe
+					     (&pAsySdoCom_p->
+					      m_le_bTransactionId) ==
+					     pSdoComCon->m_bTransactionId)) {
+						// check if abort or not
+						if ((bFlag & 0x40) != 0) {
+							// send acknowledge without any Command layer data
+							Ret =
+							    EplSdoAsySeqSendData
+							    (pSdoComCon->
+							     m_SdoSeqConHdl, 0,
+							     (tEplFrame *)
+							     NULL);
+							// inc transaction id
+							pSdoComCon->
+							    m_bTransactionId++;
+							// change state
+							pSdoComCon->
+							    m_SdoComState =
+							    kEplSdoComStateClientConnected;
+							// save abort code
+							pSdoComCon->
+							    m_dwLastAbortCode =
+							    AmiGetDwordFromLe
+							    (&pAsySdoCom_p->
+							     m_le_abCommandData
+							     [0]);
+							// call callback of application
+							Ret =
+							    EplSdoComTransferFinished
+							    (SdoComCon_p,
+							     pSdoComCon,
+							     kEplSdoComTransferRxAborted);
+
+							goto Exit;
+						} else {	// normal frame received
+							// check frame
+							Ret =
+							    EplSdoComClientProcessFrame
+							    (SdoComCon_p,
+							     pAsySdoCom_p);
+
+							// check if transfer ready
+							if (pSdoComCon->
+							    m_uiTransSize ==
+							    0) {
+								// send acknowledge without any Command layer data
+								Ret =
+								    EplSdoAsySeqSendData
+								    (pSdoComCon->
+								     m_SdoSeqConHdl,
+								     0,
+								     (tEplFrame
+								      *) NULL);
+								// inc transaction id
+								pSdoComCon->
+								    m_bTransactionId++;
+								// change state
+								pSdoComCon->
+								    m_SdoComState
+								    =
+								    kEplSdoComStateClientConnected;
+								// call callback of application
+								pSdoComCon->
+								    m_dwLastAbortCode
+								    = 0;
+								Ret =
+								    EplSdoComTransferFinished
+								    (SdoComCon_p,
+								     pSdoComCon,
+								     kEplSdoComTransferFinished);
+
+							}
+
+						}
+					}
+					break;
+				}
+
+				// connection closed event go back to kEplSdoComStateClientWaitInit
+			case kEplSdoComConEventConClosed:
+				{	// connection closed by communication partner
+					// close sequence layer handle
+					Ret =
+					    EplSdoAsySeqDelCon(pSdoComCon->
+							       m_SdoSeqConHdl);
+					// set handle to invalid and enter kEplSdoComStateClientWaitInit
+					pSdoComCon->m_SdoSeqConHdl |=
+					    EPL_SDO_SEQ_INVALID_HDL;
+					// change state
+					pSdoComCon->m_SdoComState =
+					    kEplSdoComStateClientWaitInit;
+					// inc transaction id
+					pSdoComCon->m_bTransactionId++;
+					// call callback of application
+					pSdoComCon->m_dwLastAbortCode = 0;
+					Ret =
+					    EplSdoComTransferFinished
+					    (SdoComCon_p, pSdoComCon,
+					     kEplSdoComTransferFinished);
+
+					break;
+				}
+
+				// abort to send from higher layer
+			case kEplSdoComConEventAbort:
+				{
+					EplSdoComClientSendAbort(pSdoComCon,
+								 *((DWORD *)
+								   pSdoComCon->
+								   m_pData));
+
+					// inc transaction id
+					pSdoComCon->m_bTransactionId++;
+					// change state
+					pSdoComCon->m_SdoComState =
+					    kEplSdoComStateClientConnected;
+					// call callback of application
+					pSdoComCon->m_dwLastAbortCode =
+					    *((DWORD *) pSdoComCon->m_pData);
+					Ret =
+					    EplSdoComTransferFinished
+					    (SdoComCon_p, pSdoComCon,
+					     kEplSdoComTransferTxAborted);
+
+					break;
+				}
+
+			case kEplSdoComConEventInitError:
+			case kEplSdoComConEventTimeout:
+				{
+					// close sequence layer handle
+					Ret =
+					    EplSdoAsySeqDelCon(pSdoComCon->
+							       m_SdoSeqConHdl);
+					pSdoComCon->m_SdoSeqConHdl |=
+					    EPL_SDO_SEQ_INVALID_HDL;
+					// change state
+					pSdoComCon->m_SdoComState =
+					    kEplSdoComStateClientWaitInit;
+					// call callback of application
+					pSdoComCon->m_dwLastAbortCode =
+					    EPL_SDOAC_TIME_OUT;
+					Ret =
+					    EplSdoComTransferFinished
+					    (SdoComCon_p, pSdoComCon,
+					     kEplSdoComTransferLowerLayerAbort);
+
+				}
+
+			default:
+				// d.k. do nothing
+				break;
 
-            } // end of switch(SdoComConEvent_p)
+			}	// end of switch(SdoComConEvent_p)
 
-            break;
-        }
+			break;
+		}
 #endif // endo of #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
 
-    }// end of switch(pSdoComCon->m_SdoComState)
-
-
+	}			// end of switch(pSdoComCon->m_SdoComState)
 
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-Exit:
+      Exit:
 #endif
 
 #if defined(WIN32) || defined(_WIN32)
-    // leave critical section for process function
-    EPL_DBGLVL_SDO_TRACE0("\n\tLeaveCriticalSection EplSdoComProcessIntern\n\n");
-    LeaveCriticalSection(SdoComInstance_g.m_pCriticalSection);
+	// leave critical section for process function
+	EPL_DBGLVL_SDO_TRACE0
+	    ("\n\tLeaveCriticalSection EplSdoComProcessIntern\n\n");
+	LeaveCriticalSection(SdoComInstance_g.m_pCriticalSection);
 
 #endif
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:        EplSdoComServerInitReadByIndex
@@ -1819,123 +1957,110 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
-static tEplKernel EplSdoComServerInitReadByIndex(tEplSdoComCon*     pSdoComCon_p,
-                                         tEplAsySdoCom*     pAsySdoCom_p)
+static tEplKernel EplSdoComServerInitReadByIndex(tEplSdoComCon * pSdoComCon_p,
+						 tEplAsySdoCom * pAsySdoCom_p)
 {
-tEplKernel      Ret;
-unsigned int    uiIndex;
-unsigned int    uiSubindex;
-tEplObdSize     EntrySize;
-tEplObdAccess   AccessType;
-DWORD           dwAbortCode;
-
-    dwAbortCode = 0;
-
-    // a init of a read could not be a segmented transfer
-    // -> no variable part of header
-
-    // get index and subindex
-    uiIndex = AmiGetWordFromLe(&pAsySdoCom_p->m_le_abCommandData[0]);
-    uiSubindex = AmiGetByteFromLe(&pAsySdoCom_p->m_le_abCommandData[2]);
+	tEplKernel Ret;
+	unsigned int uiIndex;
+	unsigned int uiSubindex;
+	tEplObdSize EntrySize;
+	tEplObdAccess AccessType;
+	DWORD dwAbortCode;
+
+	dwAbortCode = 0;
+
+	// a init of a read could not be a segmented transfer
+	// -> no variable part of header
+
+	// get index and subindex
+	uiIndex = AmiGetWordFromLe(&pAsySdoCom_p->m_le_abCommandData[0]);
+	uiSubindex = AmiGetByteFromLe(&pAsySdoCom_p->m_le_abCommandData[2]);
 
-    // check accesstype of entry
-    // existens of entry
+	// check accesstype of entry
+	// existens of entry
 //#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
-    Ret = EplObduGetAccessType(uiIndex, uiSubindex, &AccessType);
+	Ret = EplObduGetAccessType(uiIndex, uiSubindex, &AccessType);
 /*#else
     Ret = kEplObdSubindexNotExist;
     AccessType = 0;
 #endif*/
-    if(Ret == kEplObdSubindexNotExist)
-    {   // subentry doesn't exist
-        dwAbortCode = EPL_SDOAC_SUB_INDEX_NOT_EXIST;
-        // send abort
-        pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
-        Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                    uiIndex,
-                                    uiSubindex,
-                                    kEplSdoComSendTypeAbort);
-        goto Exit;
-    }
-    else if(Ret != kEplSuccessful)
-    {   // entry doesn't exist
-        dwAbortCode = EPL_SDOAC_OBJECT_NOT_EXIST;
-        // send abort
-        pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
-        Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                    uiIndex,
-                                    uiSubindex,
-                                    kEplSdoComSendTypeAbort);
-        goto Exit;
-    }
-
-    // compare accesstype must be read or const
-    if(((AccessType & kEplObdAccRead) == 0)
-        && ((AccessType & kEplObdAccConst) == 0))
-    {
-
-        if((AccessType & kEplObdAccWrite) != 0)
-        {
-            // entry read a write only object
-            dwAbortCode = EPL_SDOAC_READ_TO_WRITE_ONLY_OBJ;
-        }
-        else
-        {
-            dwAbortCode = EPL_SDOAC_UNSUPPORTED_ACCESS;
-        }
-        // send abort
-        pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
-        Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                    uiIndex,
-                                    uiSubindex,
-                                    kEplSdoComSendTypeAbort);
-        goto Exit;
-    }
+	if (Ret == kEplObdSubindexNotExist) {	// subentry doesn't exist
+		dwAbortCode = EPL_SDOAC_SUB_INDEX_NOT_EXIST;
+		// send abort
+		pSdoComCon_p->m_pData = (BYTE *) & dwAbortCode;
+		Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
+						     uiIndex,
+						     uiSubindex,
+						     kEplSdoComSendTypeAbort);
+		goto Exit;
+	} else if (Ret != kEplSuccessful) {	// entry doesn't exist
+		dwAbortCode = EPL_SDOAC_OBJECT_NOT_EXIST;
+		// send abort
+		pSdoComCon_p->m_pData = (BYTE *) & dwAbortCode;
+		Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
+						     uiIndex,
+						     uiSubindex,
+						     kEplSdoComSendTypeAbort);
+		goto Exit;
+	}
+	// compare accesstype must be read or const
+	if (((AccessType & kEplObdAccRead) == 0)
+	    && ((AccessType & kEplObdAccConst) == 0)) {
+
+		if ((AccessType & kEplObdAccWrite) != 0) {
+			// entry read a write only object
+			dwAbortCode = EPL_SDOAC_READ_TO_WRITE_ONLY_OBJ;
+		} else {
+			dwAbortCode = EPL_SDOAC_UNSUPPORTED_ACCESS;
+		}
+		// send abort
+		pSdoComCon_p->m_pData = (BYTE *) & dwAbortCode;
+		Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
+						     uiIndex,
+						     uiSubindex,
+						     kEplSdoComSendTypeAbort);
+		goto Exit;
+	}
+	// save service
+	pSdoComCon_p->m_SdoServiceType = kEplSdoServiceReadByIndex;
 
-    // save service
-    pSdoComCon_p->m_SdoServiceType = kEplSdoServiceReadByIndex;
-
-    // get size of object to see iof segmented or expedited transfer
+	// get size of object to see iof segmented or expedited transfer
 //#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
-    EntrySize = EplObduGetDataSize(uiIndex, uiSubindex);
+	EntrySize = EplObduGetDataSize(uiIndex, uiSubindex);
 /*#else
     EntrySize = 0;
 #endif*/
-    if(EntrySize > EPL_SDO_MAX_PAYLOAD)
-    {   // segmented transfer
-        pSdoComCon_p->m_SdoTransType = kEplSdoTransSegmented;
-        // get pointer to object-entry data
+	if (EntrySize > EPL_SDO_MAX_PAYLOAD) {	// segmented transfer
+		pSdoComCon_p->m_SdoTransType = kEplSdoTransSegmented;
+		// get pointer to object-entry data
 //#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
-        pSdoComCon_p->m_pData = EplObduGetObjectDataPtr(uiIndex, uiSubindex);
+		pSdoComCon_p->m_pData =
+		    EplObduGetObjectDataPtr(uiIndex, uiSubindex);
 //#endif
-    }
-    else
-    {   // expedited transfer
-        pSdoComCon_p->m_SdoTransType = kEplSdoTransExpedited;
-    }
-
-    pSdoComCon_p->m_uiTransSize = EntrySize;
-    pSdoComCon_p->m_uiTransferredByte = 0;
-
-    Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                    uiIndex,
-                                    uiSubindex,
-                                    kEplSdoComSendTypeRes);
-    if(Ret != kEplSuccessful)
-    {
-        // error -> abort
-        dwAbortCode = EPL_SDOAC_GENERAL_ERROR;
-        // send abort
-        pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
-        Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                    uiIndex,
-                                    uiSubindex,
-                                    kEplSdoComSendTypeAbort);
-        goto Exit;
-    }
+	} else {		// expedited transfer
+		pSdoComCon_p->m_SdoTransType = kEplSdoTransExpedited;
+	}
+
+	pSdoComCon_p->m_uiTransSize = EntrySize;
+	pSdoComCon_p->m_uiTransferredByte = 0;
+
+	Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
+					     uiIndex,
+					     uiSubindex, kEplSdoComSendTypeRes);
+	if (Ret != kEplSuccessful) {
+		// error -> abort
+		dwAbortCode = EPL_SDOAC_GENERAL_ERROR;
+		// send abort
+		pSdoComCon_p->m_pData = (BYTE *) & dwAbortCode;
+		Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
+						     uiIndex,
+						     uiSubindex,
+						     kEplSdoComSendTypeAbort);
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 #endif
 
@@ -1959,219 +2084,266 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
-static tEplKernel EplSdoComServerSendFrameIntern(tEplSdoComCon*     pSdoComCon_p,
-                                           unsigned int       uiIndex_p,
-                                           unsigned int       uiSubIndex_p,
-                                           tEplSdoComSendType SendType_p)
-{
-tEplKernel      Ret;
-BYTE            abFrame[EPL_MAX_SDO_FRAME_SIZE];
-tEplFrame*      pFrame;
-tEplAsySdoCom*  pCommandFrame;
-unsigned int    uiSizeOfFrame;
-BYTE            bFlag;
-
-    Ret = kEplSuccessful;
-
-    pFrame = (tEplFrame*)&abFrame[0];
-
-    EPL_MEMSET(&abFrame[0], 0x00, sizeof(abFrame));
-
-    // build generic part of frame
-    // get pointer to command layerpart of frame
-    pCommandFrame = &pFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.m_le_abSdoSeqPayload;
-    AmiSetByteToLe(&pCommandFrame->m_le_bCommandId, pSdoComCon_p->m_SdoServiceType);
-    AmiSetByteToLe(&pCommandFrame->m_le_bTransactionId, pSdoComCon_p->m_bTransactionId);
-
-    // set size to header size
-    uiSizeOfFrame = 8;
-
-    // check SendType
-    switch(SendType_p)
-    {
-        // requestframe to send
-        case kEplSdoComSendTypeReq:
-        {
-            // nothing to do for server
-            //-> error
-            Ret = kEplSdoComInvalidSendType;
-            break;
-        }
-
-        // response without data to send
-        case kEplSdoComSendTypeAckRes:
-        {
-            // set response flag
-            AmiSetByteToLe(&pCommandFrame->m_le_bFlags,  0x80);
-
-            // send frame
-            Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
-                                            uiSizeOfFrame,
-                                            pFrame);
-
-            break;
-        }
-
-        // responsframe to send
-        case kEplSdoComSendTypeRes:
-        {
-            // set response flag
-            bFlag = AmiGetByteFromLe( &pCommandFrame->m_le_bFlags);
-            bFlag |= 0x80;
-            AmiSetByteToLe(&pCommandFrame->m_le_bFlags,  bFlag);
-
-            // check type of resonse
-            if(pSdoComCon_p->m_SdoTransType == kEplSdoTransExpedited)
-            {   // Expedited transfer
-                // copy data in frame
+static tEplKernel EplSdoComServerSendFrameIntern(tEplSdoComCon * pSdoComCon_p,
+						 unsigned int uiIndex_p,
+						 unsigned int uiSubIndex_p,
+						 tEplSdoComSendType SendType_p)
+{
+	tEplKernel Ret;
+	BYTE abFrame[EPL_MAX_SDO_FRAME_SIZE];
+	tEplFrame *pFrame;
+	tEplAsySdoCom *pCommandFrame;
+	unsigned int uiSizeOfFrame;
+	BYTE bFlag;
+
+	Ret = kEplSuccessful;
+
+	pFrame = (tEplFrame *) & abFrame[0];
+
+	EPL_MEMSET(&abFrame[0], 0x00, sizeof(abFrame));
+
+	// build generic part of frame
+	// get pointer to command layerpart of frame
+	pCommandFrame =
+	    &pFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.
+	    m_le_abSdoSeqPayload;
+	AmiSetByteToLe(&pCommandFrame->m_le_bCommandId,
+		       pSdoComCon_p->m_SdoServiceType);
+	AmiSetByteToLe(&pCommandFrame->m_le_bTransactionId,
+		       pSdoComCon_p->m_bTransactionId);
+
+	// set size to header size
+	uiSizeOfFrame = 8;
+
+	// check SendType
+	switch (SendType_p) {
+		// requestframe to send
+	case kEplSdoComSendTypeReq:
+		{
+			// nothing to do for server
+			//-> error
+			Ret = kEplSdoComInvalidSendType;
+			break;
+		}
+
+		// response without data to send
+	case kEplSdoComSendTypeAckRes:
+		{
+			// set response flag
+			AmiSetByteToLe(&pCommandFrame->m_le_bFlags, 0x80);
+
+			// send frame
+			Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
+						   uiSizeOfFrame, pFrame);
+
+			break;
+		}
+
+		// responsframe to send
+	case kEplSdoComSendTypeRes:
+		{
+			// set response flag
+			bFlag = AmiGetByteFromLe(&pCommandFrame->m_le_bFlags);
+			bFlag |= 0x80;
+			AmiSetByteToLe(&pCommandFrame->m_le_bFlags, bFlag);
+
+			// check type of resonse
+			if (pSdoComCon_p->m_SdoTransType == kEplSdoTransExpedited) {	// Expedited transfer
+				// copy data in frame
 //#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
-                Ret = EplObduReadEntryToLe(uiIndex_p,
-                                        uiSubIndex_p,
-                                        &pCommandFrame->m_le_abCommandData[0],
-                                        (tEplObdSize*)&pSdoComCon_p->m_uiTransSize);
-                if(Ret != kEplSuccessful)
-                {
-                    goto Exit;
-                }
+				Ret = EplObduReadEntryToLe(uiIndex_p,
+							   uiSubIndex_p,
+							   &pCommandFrame->
+							   m_le_abCommandData
+							   [0],
+							   (tEplObdSize *) &
+							   pSdoComCon_p->
+							   m_uiTransSize);
+				if (Ret != kEplSuccessful) {
+					goto Exit;
+				}
 //#endif
 
-                // set size of frame
-                AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize, (WORD) pSdoComCon_p->m_uiTransSize);
+				// set size of frame
+				AmiSetWordToLe(&pCommandFrame->
+					       m_le_wSegmentSize,
+					       (WORD) pSdoComCon_p->
+					       m_uiTransSize);
+
+				// correct byte-counter
+				uiSizeOfFrame += pSdoComCon_p->m_uiTransSize;
+				pSdoComCon_p->m_uiTransferredByte +=
+				    pSdoComCon_p->m_uiTransSize;
+				pSdoComCon_p->m_uiTransSize = 0;
+
+				// send frame
+				uiSizeOfFrame += pSdoComCon_p->m_uiTransSize;
+				Ret =
+				    EplSdoAsySeqSendData(pSdoComCon_p->
+							 m_SdoSeqConHdl,
+							 uiSizeOfFrame, pFrame);
+			} else if (pSdoComCon_p->m_SdoTransType == kEplSdoTransSegmented) {	// segmented transfer
+				// distinguish between init, segment and complete
+				if (pSdoComCon_p->m_uiTransferredByte == 0) {	// init
+					// set init flag
+					bFlag =
+					    AmiGetByteFromLe(&pCommandFrame->
+							     m_le_bFlags);
+					bFlag |= 0x10;
+					AmiSetByteToLe(&pCommandFrame->
+						       m_le_bFlags, bFlag);
+					// init variable header
+					AmiSetDwordToLe(&pCommandFrame->
+							m_le_abCommandData[0],
+							pSdoComCon_p->
+							m_uiTransSize);
+					// copy data in frame
+					EPL_MEMCPY(&pCommandFrame->
+						   m_le_abCommandData[4],
+						   pSdoComCon_p->m_pData,
+						   (EPL_SDO_MAX_PAYLOAD - 4));
+
+					// correct byte-counter
+					pSdoComCon_p->m_uiTransSize -=
+					    (EPL_SDO_MAX_PAYLOAD - 4);
+					pSdoComCon_p->m_uiTransferredByte +=
+					    (EPL_SDO_MAX_PAYLOAD - 4);
+					// move data pointer
+					pSdoComCon_p->m_pData +=
+					    (EPL_SDO_MAX_PAYLOAD - 4);
+
+					// set segment size
+					AmiSetWordToLe(&pCommandFrame->
+						       m_le_wSegmentSize,
+						       (EPL_SDO_MAX_PAYLOAD -
+							4));
+
+					// send frame
+					uiSizeOfFrame += EPL_SDO_MAX_PAYLOAD;
+					Ret =
+					    EplSdoAsySeqSendData(pSdoComCon_p->
+								 m_SdoSeqConHdl,
+								 uiSizeOfFrame,
+								 pFrame);
+
+				} else
+				    if ((pSdoComCon_p->m_uiTransferredByte > 0)
+					&& (pSdoComCon_p->m_uiTransSize > EPL_SDO_MAX_PAYLOAD)) {	// segment
+					// set segment flag
+					bFlag =
+					    AmiGetByteFromLe(&pCommandFrame->
+							     m_le_bFlags);
+					bFlag |= 0x20;
+					AmiSetByteToLe(&pCommandFrame->
+						       m_le_bFlags, bFlag);
+
+					// copy data in frame
+					EPL_MEMCPY(&pCommandFrame->
+						   m_le_abCommandData[0],
+						   pSdoComCon_p->m_pData,
+						   EPL_SDO_MAX_PAYLOAD);
+
+					// correct byte-counter
+					pSdoComCon_p->m_uiTransSize -=
+					    EPL_SDO_MAX_PAYLOAD;
+					pSdoComCon_p->m_uiTransferredByte +=
+					    EPL_SDO_MAX_PAYLOAD;
+					// move data pointer
+					pSdoComCon_p->m_pData +=
+					    EPL_SDO_MAX_PAYLOAD;
+
+					// set segment size
+					AmiSetWordToLe(&pCommandFrame->
+						       m_le_wSegmentSize,
+						       EPL_SDO_MAX_PAYLOAD);
+
+					// send frame
+					uiSizeOfFrame += EPL_SDO_MAX_PAYLOAD;
+					Ret =
+					    EplSdoAsySeqSendData(pSdoComCon_p->
+								 m_SdoSeqConHdl,
+								 uiSizeOfFrame,
+								 pFrame);
+				} else {
+					if ((pSdoComCon_p->m_uiTransSize == 0)
+					    && (pSdoComCon_p->
+						m_SdoServiceType !=
+						kEplSdoServiceWriteByIndex)) {
+						goto Exit;
+					}
+					// complete
+					// set segment complete flag
+					bFlag =
+					    AmiGetByteFromLe(&pCommandFrame->
+							     m_le_bFlags);
+					bFlag |= 0x30;
+					AmiSetByteToLe(&pCommandFrame->
+						       m_le_bFlags, bFlag);
+
+					// copy data in frame
+					EPL_MEMCPY(&pCommandFrame->
+						   m_le_abCommandData[0],
+						   pSdoComCon_p->m_pData,
+						   pSdoComCon_p->m_uiTransSize);
+
+					// correct byte-counter
+					pSdoComCon_p->m_uiTransferredByte +=
+					    pSdoComCon_p->m_uiTransSize;
+
+					// move data pointer
+					pSdoComCon_p->m_pData +=
+					    pSdoComCon_p->m_uiTransSize;
+
+					// set segment size
+					AmiSetWordToLe(&pCommandFrame->
+						       m_le_wSegmentSize,
+						       (WORD) pSdoComCon_p->
+						       m_uiTransSize);
+
+					// send frame
+					uiSizeOfFrame +=
+					    pSdoComCon_p->m_uiTransSize;
+					pSdoComCon_p->m_uiTransSize = 0;
+					Ret =
+					    EplSdoAsySeqSendData(pSdoComCon_p->
+								 m_SdoSeqConHdl,
+								 uiSizeOfFrame,
+								 pFrame);
+				}
+
+			}
+			break;
+		}
+		// abort to send
+	case kEplSdoComSendTypeAbort:
+		{
+			// set response and abort flag
+			bFlag = AmiGetByteFromLe(&pCommandFrame->m_le_bFlags);
+			bFlag |= 0xC0;
+			AmiSetByteToLe(&pCommandFrame->m_le_bFlags, bFlag);
+
+			// copy abortcode to frame
+			AmiSetDwordToLe(&pCommandFrame->m_le_abCommandData[0],
+					*((DWORD *) pSdoComCon_p->m_pData));
+
+			// set size of segment
+			AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize,
+				       sizeof(DWORD));
+
+			// update counter
+			pSdoComCon_p->m_uiTransferredByte = sizeof(DWORD);
+			pSdoComCon_p->m_uiTransSize = 0;
+
+			// calc framesize
+			uiSizeOfFrame += sizeof(DWORD);
+			Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
+						   uiSizeOfFrame, pFrame);
+			break;
+		}
+	}			// end of switch(SendType_p)
 
-                // correct byte-counter
-                uiSizeOfFrame += pSdoComCon_p->m_uiTransSize;
-                pSdoComCon_p->m_uiTransferredByte += pSdoComCon_p->m_uiTransSize;
-                pSdoComCon_p->m_uiTransSize = 0;
-
-
-                // send frame
-                uiSizeOfFrame += pSdoComCon_p->m_uiTransSize;
-                Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
-                                            uiSizeOfFrame,
-                                            pFrame);
-            }
-            else if(pSdoComCon_p->m_SdoTransType == kEplSdoTransSegmented)
-            {   // segmented transfer
-                // distinguish between init, segment and complete
-                if(pSdoComCon_p->m_uiTransferredByte == 0)
-                {   // init
-                    // set init flag
-                    bFlag = AmiGetByteFromLe( &pCommandFrame->m_le_bFlags);
-                    bFlag |= 0x10;
-                    AmiSetByteToLe(&pCommandFrame->m_le_bFlags,  bFlag);
-                    // init variable header
-                    AmiSetDwordToLe(&pCommandFrame->m_le_abCommandData[0],pSdoComCon_p->m_uiTransSize);
-                    // copy data in frame
-                    EPL_MEMCPY(&pCommandFrame->m_le_abCommandData[4],pSdoComCon_p->m_pData, (EPL_SDO_MAX_PAYLOAD-4));
-
-                    // correct byte-counter
-                    pSdoComCon_p->m_uiTransSize -= (EPL_SDO_MAX_PAYLOAD-4);
-                    pSdoComCon_p->m_uiTransferredByte += (EPL_SDO_MAX_PAYLOAD-4);
-                    // move data pointer
-                    pSdoComCon_p->m_pData +=(EPL_SDO_MAX_PAYLOAD-4);
-
-                    // set segment size
-                    AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize,(EPL_SDO_MAX_PAYLOAD-4));
-
-                    // send frame
-                    uiSizeOfFrame += EPL_SDO_MAX_PAYLOAD;
-                    Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
-                                                uiSizeOfFrame,
-                                                pFrame);
-
-                }
-                else if((pSdoComCon_p->m_uiTransferredByte > 0)
-                    &&(pSdoComCon_p->m_uiTransSize > EPL_SDO_MAX_PAYLOAD))
-                {   // segment
-                    // set segment flag
-                    bFlag = AmiGetByteFromLe( &pCommandFrame->m_le_bFlags);
-                    bFlag |= 0x20;
-                    AmiSetByteToLe(&pCommandFrame->m_le_bFlags,  bFlag);
-
-                    // copy data in frame
-                    EPL_MEMCPY(&pCommandFrame->m_le_abCommandData[0],pSdoComCon_p->m_pData, EPL_SDO_MAX_PAYLOAD);
-
-                    // correct byte-counter
-                    pSdoComCon_p->m_uiTransSize -= EPL_SDO_MAX_PAYLOAD;
-                    pSdoComCon_p->m_uiTransferredByte += EPL_SDO_MAX_PAYLOAD;
-                    // move data pointer
-                    pSdoComCon_p->m_pData +=EPL_SDO_MAX_PAYLOAD;
-
-                    // set segment size
-                    AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize,EPL_SDO_MAX_PAYLOAD);
-
-                    // send frame
-                    uiSizeOfFrame += EPL_SDO_MAX_PAYLOAD;
-                    Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
-                                                uiSizeOfFrame,
-                                                pFrame);
-                }
-                else
-                {
-                    if((pSdoComCon_p->m_uiTransSize == 0)
-                        && (pSdoComCon_p->m_SdoServiceType != kEplSdoServiceWriteByIndex))
-                    {
-                        goto Exit;
-                    }
-                    // complete
-                    // set segment complete flag
-                    bFlag = AmiGetByteFromLe( &pCommandFrame->m_le_bFlags);
-                    bFlag |= 0x30;
-                    AmiSetByteToLe(&pCommandFrame->m_le_bFlags,  bFlag);
-
-                    // copy data in frame
-                    EPL_MEMCPY(&pCommandFrame->m_le_abCommandData[0],pSdoComCon_p->m_pData, pSdoComCon_p->m_uiTransSize);
-
-                    // correct byte-counter
-                    pSdoComCon_p->m_uiTransferredByte += pSdoComCon_p->m_uiTransSize;
-
-
-                    // move data pointer
-                    pSdoComCon_p->m_pData +=pSdoComCon_p->m_uiTransSize;
-
-                    // set segment size
-                    AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize, (WORD) pSdoComCon_p->m_uiTransSize);
-
-                    // send frame
-                    uiSizeOfFrame += pSdoComCon_p->m_uiTransSize;
-                    pSdoComCon_p->m_uiTransSize = 0;
-                    Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
-                                                uiSizeOfFrame,
-                                                pFrame);
-                }
-
-            }
-            break;
-        }
-        // abort to send
-        case kEplSdoComSendTypeAbort:
-        {
-            // set response and abort flag
-            bFlag = AmiGetByteFromLe( &pCommandFrame->m_le_bFlags);
-            bFlag |= 0xC0;
-            AmiSetByteToLe(&pCommandFrame->m_le_bFlags,  bFlag);
-
-            // copy abortcode to frame
-            AmiSetDwordToLe(&pCommandFrame->m_le_abCommandData[0], *((DWORD*)pSdoComCon_p->m_pData));
-
-            // set size of segment
-            AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize, sizeof(DWORD));
-
-            // update counter
-            pSdoComCon_p->m_uiTransferredByte = sizeof(DWORD);
-            pSdoComCon_p->m_uiTransSize = 0;
-
-            // calc framesize
-            uiSizeOfFrame += sizeof(DWORD);
-            Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
-                                                uiSizeOfFrame,
-                                                pFrame);
-            break;
-        }
-    } // end of switch(SendType_p)
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 #endif
 //---------------------------------------------------------------------------
@@ -2192,260 +2364,254 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOS)) != 0)
-static tEplKernel EplSdoComServerInitWriteByIndex(tEplSdoComCon*     pSdoComCon_p,
-                                         tEplAsySdoCom*     pAsySdoCom_p)
+static tEplKernel EplSdoComServerInitWriteByIndex(tEplSdoComCon * pSdoComCon_p,
+						  tEplAsySdoCom * pAsySdoCom_p)
 {
-tEplKernel  Ret = kEplSuccessful;
-unsigned int    uiIndex;
-unsigned int    uiSubindex;
-unsigned int    uiBytesToTransfer;
-tEplObdSize     EntrySize;
-tEplObdAccess   AccessType;
-DWORD           dwAbortCode;
-BYTE*           pbSrcData;
-
-    dwAbortCode = 0;
-
-    // a init of a write
-    // -> variable part of header possible
-
-    // check if expedited or segmented transfer
-    if ((pAsySdoCom_p->m_le_bFlags & 0x30) == 0x10)
-    {   // initiate segmented transfer
-        pSdoComCon_p->m_SdoTransType = kEplSdoTransSegmented;
-        // get index and subindex
-        uiIndex = AmiGetWordFromLe(&pAsySdoCom_p->m_le_abCommandData[4]);
-        uiSubindex = AmiGetByteFromLe(&pAsySdoCom_p->m_le_abCommandData[6]);
-        // get source-pointer for copy
-        pbSrcData = &pAsySdoCom_p->m_le_abCommandData[8];
-        // save size
-        pSdoComCon_p->m_uiTransSize = AmiGetDwordFromLe(&pAsySdoCom_p->m_le_abCommandData[0]);
-
-    }
-    else if ((pAsySdoCom_p->m_le_bFlags & 0x30) == 0x00)
-    {   // expedited transfer
-        pSdoComCon_p->m_SdoTransType = kEplSdoTransExpedited;
-        // get index and subindex
-        uiIndex = AmiGetWordFromLe(&pAsySdoCom_p->m_le_abCommandData[0]);
-        uiSubindex = AmiGetByteFromLe(&pAsySdoCom_p->m_le_abCommandData[2]);
-        // get source-pointer for copy
-        pbSrcData = &pAsySdoCom_p->m_le_abCommandData[4];
-        // save size
-        pSdoComCon_p->m_uiTransSize = AmiGetWordFromLe(&pAsySdoCom_p->m_le_wSegmentSize);
-        // subtract header
-        pSdoComCon_p->m_uiTransSize -= 4;
-
-    }
-    else
-    {
-        // just ignore any other transfer type
-        goto Exit;
-    }
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiIndex;
+	unsigned int uiSubindex;
+	unsigned int uiBytesToTransfer;
+	tEplObdSize EntrySize;
+	tEplObdAccess AccessType;
+	DWORD dwAbortCode;
+	BYTE *pbSrcData;
+
+	dwAbortCode = 0;
+
+	// a init of a write
+	// -> variable part of header possible
+
+	// check if expedited or segmented transfer
+	if ((pAsySdoCom_p->m_le_bFlags & 0x30) == 0x10) {	// initiate segmented transfer
+		pSdoComCon_p->m_SdoTransType = kEplSdoTransSegmented;
+		// get index and subindex
+		uiIndex =
+		    AmiGetWordFromLe(&pAsySdoCom_p->m_le_abCommandData[4]);
+		uiSubindex =
+		    AmiGetByteFromLe(&pAsySdoCom_p->m_le_abCommandData[6]);
+		// get source-pointer for copy
+		pbSrcData = &pAsySdoCom_p->m_le_abCommandData[8];
+		// save size
+		pSdoComCon_p->m_uiTransSize =
+		    AmiGetDwordFromLe(&pAsySdoCom_p->m_le_abCommandData[0]);
+
+	} else if ((pAsySdoCom_p->m_le_bFlags & 0x30) == 0x00) {	// expedited transfer
+		pSdoComCon_p->m_SdoTransType = kEplSdoTransExpedited;
+		// get index and subindex
+		uiIndex =
+		    AmiGetWordFromLe(&pAsySdoCom_p->m_le_abCommandData[0]);
+		uiSubindex =
+		    AmiGetByteFromLe(&pAsySdoCom_p->m_le_abCommandData[2]);
+		// get source-pointer for copy
+		pbSrcData = &pAsySdoCom_p->m_le_abCommandData[4];
+		// save size
+		pSdoComCon_p->m_uiTransSize =
+		    AmiGetWordFromLe(&pAsySdoCom_p->m_le_wSegmentSize);
+		// subtract header
+		pSdoComCon_p->m_uiTransSize -= 4;
+
+	} else {
+		// just ignore any other transfer type
+		goto Exit;
+	}
 
-    // check accesstype of entry
-    // existens of entry
+	// check accesstype of entry
+	// existens of entry
 //#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
-    Ret = EplObduGetAccessType(uiIndex, uiSubindex, &AccessType);
+	Ret = EplObduGetAccessType(uiIndex, uiSubindex, &AccessType);
 /*#else
     Ret = kEplObdSubindexNotExist;
     AccessType = 0;
 #endif*/
-    if (Ret == kEplObdSubindexNotExist)
-    {   // subentry doesn't exist
-        pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_SUB_INDEX_NOT_EXIST;
-        // send abort
-        // d.k. This is wrong: k.t. not needed send abort on end of write
-        /*pSdoComCon_p->m_pData = (BYTE*)pSdoComCon_p->m_dwLastAbortCode;
-        Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                    uiIndex,
-                                    uiSubindex,
-                                    kEplSdoComSendTypeAbort);*/
-        goto Abort;
-    }
-    else if(Ret != kEplSuccessful)
-    {   // entry doesn't exist
-        pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_OBJECT_NOT_EXIST;
-        // send abort
-        // d.k. This is wrong: k.t. not needed send abort on end of write
-        /*
-        pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
-        Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                    uiIndex,
-                                    uiSubindex,
-                                    kEplSdoComSendTypeAbort);*/
-        goto Abort;
-    }
-
-    // compare accesstype must be read
-    if((AccessType & kEplObdAccWrite) == 0)
-    {
-
-        if((AccessType & kEplObdAccRead) != 0)
-        {
-            // entry write a read only object
-            pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_WRITE_TO_READ_ONLY_OBJ;
-        }
-        else
-        {
-            pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_UNSUPPORTED_ACCESS;
-        }
-        // send abort
-        // d.k. This is wrong: k.t. not needed send abort on end of write
-        /*pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
-        Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                    uiIndex,
-                                    uiSubindex,
-                                    kEplSdoComSendTypeAbort);*/
-        goto Abort;
-    }
-
-    // save service
-    pSdoComCon_p->m_SdoServiceType = kEplSdoServiceWriteByIndex;
-
-    pSdoComCon_p->m_uiTransferredByte = 0;
-
-    // write data to OD
-    if(pSdoComCon_p->m_SdoTransType == kEplSdoTransExpedited)
-    {   // expedited transfer
-        // size checking is done by EplObduWriteEntryFromLe()
+	if (Ret == kEplObdSubindexNotExist) {	// subentry doesn't exist
+		pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_SUB_INDEX_NOT_EXIST;
+		// send abort
+		// d.k. This is wrong: k.t. not needed send abort on end of write
+		/*pSdoComCon_p->m_pData = (BYTE*)pSdoComCon_p->m_dwLastAbortCode;
+		   Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
+		   uiIndex,
+		   uiSubindex,
+		   kEplSdoComSendTypeAbort); */
+		goto Abort;
+	} else if (Ret != kEplSuccessful) {	// entry doesn't exist
+		pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_OBJECT_NOT_EXIST;
+		// send abort
+		// d.k. This is wrong: k.t. not needed send abort on end of write
+		/*
+		   pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
+		   Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
+		   uiIndex,
+		   uiSubindex,
+		   kEplSdoComSendTypeAbort); */
+		goto Abort;
+	}
+	// compare accesstype must be read
+	if ((AccessType & kEplObdAccWrite) == 0) {
+
+		if ((AccessType & kEplObdAccRead) != 0) {
+			// entry write a read only object
+			pSdoComCon_p->m_dwLastAbortCode =
+			    EPL_SDOAC_WRITE_TO_READ_ONLY_OBJ;
+		} else {
+			pSdoComCon_p->m_dwLastAbortCode =
+			    EPL_SDOAC_UNSUPPORTED_ACCESS;
+		}
+		// send abort
+		// d.k. This is wrong: k.t. not needed send abort on end of write
+		/*pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
+		   Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
+		   uiIndex,
+		   uiSubindex,
+		   kEplSdoComSendTypeAbort); */
+		goto Abort;
+	}
+	// save service
+	pSdoComCon_p->m_SdoServiceType = kEplSdoServiceWriteByIndex;
+
+	pSdoComCon_p->m_uiTransferredByte = 0;
+
+	// write data to OD
+	if (pSdoComCon_p->m_SdoTransType == kEplSdoTransExpedited) {	// expedited transfer
+		// size checking is done by EplObduWriteEntryFromLe()
 
 //#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
-        Ret = EplObduWriteEntryFromLe(uiIndex,
-                                    uiSubindex,
-                                    pbSrcData,
-                                    pSdoComCon_p->m_uiTransSize);
-        switch (Ret)
-        {
-            case kEplSuccessful:
-            {
-                break;
-            }
-
-            case kEplObdAccessViolation:
-            {
-                pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_UNSUPPORTED_ACCESS;
-                // send abort
-                goto Abort;
-            }
-
-            case kEplObdValueLengthError:
-            {
-                pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_DATA_TYPE_LENGTH_NOT_MATCH;
-                // send abort
-                goto Abort;
-            }
-
-            case kEplObdValueTooHigh:
-            {
-                pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_VALUE_RANGE_TOO_HIGH;
-                // send abort
-                goto Abort;
-            }
-
-            case kEplObdValueTooLow:
-            {
-                pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_VALUE_RANGE_TOO_LOW;
-                // send abort
-                goto Abort;
-            }
-
-            default:
-            {
-                pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_GENERAL_ERROR;
-                // send abort
-                goto Abort;
-            }
-        }
+		Ret = EplObduWriteEntryFromLe(uiIndex,
+					      uiSubindex,
+					      pbSrcData,
+					      pSdoComCon_p->m_uiTransSize);
+		switch (Ret) {
+		case kEplSuccessful:
+			{
+				break;
+			}
+
+		case kEplObdAccessViolation:
+			{
+				pSdoComCon_p->m_dwLastAbortCode =
+				    EPL_SDOAC_UNSUPPORTED_ACCESS;
+				// send abort
+				goto Abort;
+			}
+
+		case kEplObdValueLengthError:
+			{
+				pSdoComCon_p->m_dwLastAbortCode =
+				    EPL_SDOAC_DATA_TYPE_LENGTH_NOT_MATCH;
+				// send abort
+				goto Abort;
+			}
+
+		case kEplObdValueTooHigh:
+			{
+				pSdoComCon_p->m_dwLastAbortCode =
+				    EPL_SDOAC_VALUE_RANGE_TOO_HIGH;
+				// send abort
+				goto Abort;
+			}
+
+		case kEplObdValueTooLow:
+			{
+				pSdoComCon_p->m_dwLastAbortCode =
+				    EPL_SDOAC_VALUE_RANGE_TOO_LOW;
+				// send abort
+				goto Abort;
+			}
+
+		default:
+			{
+				pSdoComCon_p->m_dwLastAbortCode =
+				    EPL_SDOAC_GENERAL_ERROR;
+				// send abort
+				goto Abort;
+			}
+		}
 //#endif
-        // send command acknowledge
-        Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                        0,
-                                        0,
-                                        kEplSdoComSendTypeAckRes);
-
-        pSdoComCon_p->m_uiTransSize = 0;
-        goto Exit;
-    }
-    else
-    {
-        // get size of the object to check if it fits
-        // because we directly write to the destination memory
-        // d.k. no one calls the user OD callback function
-
-    //#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
-        EntrySize = EplObduGetDataSize(uiIndex, uiSubindex);
-    /*#else
-        EntrySize = 0;
-    #endif*/
-        if(EntrySize < pSdoComCon_p->m_uiTransSize)
-        {   // parameter too big
-            pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_DATA_TYPE_LENGTH_TOO_HIGH;
-            // send abort
-            // d.k. This is wrong: k.t. not needed send abort on end of write
-            /*pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
-            Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                        uiIndex,
-                                        uiSubindex,
-                                        kEplSdoComSendTypeAbort);*/
-            goto Abort;
-        }
-
-        uiBytesToTransfer = AmiGetWordFromLe(&pAsySdoCom_p->m_le_wSegmentSize);
-        // eleminate header (Command header (8) + variable part (4) + Command header (4))
-        uiBytesToTransfer -= 16;
-        // get pointer to object entry
+		// send command acknowledge
+		Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
+						     0,
+						     0,
+						     kEplSdoComSendTypeAckRes);
+
+		pSdoComCon_p->m_uiTransSize = 0;
+		goto Exit;
+	} else {
+		// get size of the object to check if it fits
+		// because we directly write to the destination memory
+		// d.k. no one calls the user OD callback function
+
+		//#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
+		EntrySize = EplObduGetDataSize(uiIndex, uiSubindex);
+		/*#else
+		   EntrySize = 0;
+		   #endif */
+		if (EntrySize < pSdoComCon_p->m_uiTransSize) {	// parameter too big
+			pSdoComCon_p->m_dwLastAbortCode =
+			    EPL_SDOAC_DATA_TYPE_LENGTH_TOO_HIGH;
+			// send abort
+			// d.k. This is wrong: k.t. not needed send abort on end of write
+			/*pSdoComCon_p->m_pData = (BYTE*)&dwAbortCode;
+			   Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
+			   uiIndex,
+			   uiSubindex,
+			   kEplSdoComSendTypeAbort); */
+			goto Abort;
+		}
+
+		uiBytesToTransfer =
+		    AmiGetWordFromLe(&pAsySdoCom_p->m_le_wSegmentSize);
+		// eleminate header (Command header (8) + variable part (4) + Command header (4))
+		uiBytesToTransfer -= 16;
+		// get pointer to object entry
 //#if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_OBDU)) != 0)
-        pSdoComCon_p->m_pData = EplObduGetObjectDataPtr(uiIndex,
-                                                        uiSubindex);
+		pSdoComCon_p->m_pData = EplObduGetObjectDataPtr(uiIndex,
+								uiSubindex);
 //#endif
-        if(pSdoComCon_p->m_pData == NULL)
-        {
-            pSdoComCon_p->m_dwLastAbortCode = EPL_SDOAC_GENERAL_ERROR;
-            // send abort
-            // d.k. This is wrong: k.t. not needed send abort on end of write
+		if (pSdoComCon_p->m_pData == NULL) {
+			pSdoComCon_p->m_dwLastAbortCode =
+			    EPL_SDOAC_GENERAL_ERROR;
+			// send abort
+			// d.k. This is wrong: k.t. not needed send abort on end of write
 /*            pSdoComCon_p->m_pData = (BYTE*)&pSdoComCon_p->m_dwLastAbortCode;
             Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
                                         uiIndex,
                                         uiSubindex,
                                         kEplSdoComSendTypeAbort);*/
-            goto Abort;
-        }
-
-        // copy data
-        EPL_MEMCPY(pSdoComCon_p->m_pData, pbSrcData, uiBytesToTransfer);
+			goto Abort;
+		}
+		// copy data
+		EPL_MEMCPY(pSdoComCon_p->m_pData, pbSrcData, uiBytesToTransfer);
+
+		// update internal counter
+		pSdoComCon_p->m_uiTransferredByte = uiBytesToTransfer;
+		pSdoComCon_p->m_uiTransSize -= uiBytesToTransfer;
+
+		// update target pointer
+		( /*(BYTE*) */ pSdoComCon_p->m_pData) += uiBytesToTransfer;
+
+		// send acknowledge without any Command layer data
+		Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
+					   0, (tEplFrame *) NULL);
+		goto Exit;
+	}
+
+      Abort:
+	if (pSdoComCon_p->m_dwLastAbortCode != 0) {
+		// send abort
+		pSdoComCon_p->m_pData =
+		    (BYTE *) & pSdoComCon_p->m_dwLastAbortCode;
+		Ret =
+		    EplSdoComServerSendFrameIntern(pSdoComCon_p, uiIndex,
+						   uiSubindex,
+						   kEplSdoComSendTypeAbort);
+
+		// reset abort code
+		pSdoComCon_p->m_dwLastAbortCode = 0;
+		pSdoComCon_p->m_uiTransSize = 0;
+		goto Exit;
+	}
 
-        // update internal counter
-        pSdoComCon_p->m_uiTransferredByte = uiBytesToTransfer;
-        pSdoComCon_p->m_uiTransSize -= uiBytesToTransfer;
-
-        // update target pointer
-        (/*(BYTE*)*/pSdoComCon_p->m_pData) += uiBytesToTransfer;
-
-        // send acknowledge without any Command layer data
-        Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
-                                                0,
-                                                (tEplFrame*)NULL);
-        goto Exit;
-    }
-
-Abort:
-    if(pSdoComCon_p->m_dwLastAbortCode != 0)
-    {
-        // send abort
-        pSdoComCon_p->m_pData = (BYTE*)&pSdoComCon_p->m_dwLastAbortCode;
-        Ret = EplSdoComServerSendFrameIntern(pSdoComCon_p,
-                                    uiIndex,
-                                    uiSubindex,
-                                    kEplSdoComSendTypeAbort);
-
-        // reset abort code
-        pSdoComCon_p->m_dwLastAbortCode = 0;
-        pSdoComCon_p->m_uiTransSize = 0;
-        goto Exit;
-    }
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 #endif
 
@@ -2466,210 +2632,293 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-static tEplKernel EplSdoComClientSend(tEplSdoComCon* pSdoComCon_p)
+static tEplKernel EplSdoComClientSend(tEplSdoComCon * pSdoComCon_p)
 {
-tEplKernel      Ret;
-BYTE            abFrame[EPL_MAX_SDO_FRAME_SIZE];
-tEplFrame*      pFrame;
-tEplAsySdoCom*  pCommandFrame;
-unsigned int    uiSizeOfFrame;
-BYTE            bFlags;
-BYTE*           pbPayload;
-
-    Ret = kEplSuccessful;
-
-    pFrame = (tEplFrame*)&abFrame[0];
-
-    EPL_MEMSET(&abFrame[0], 0x00, sizeof(abFrame));
-
-    // build generic part of frame
-    // get pointer to command layerpart of frame
-    pCommandFrame = &pFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.m_le_abSdoSeqPayload;
-    AmiSetByteToLe( &pCommandFrame->m_le_bCommandId, pSdoComCon_p->m_SdoServiceType);
-    AmiSetByteToLe( &pCommandFrame->m_le_bTransactionId, pSdoComCon_p->m_bTransactionId);
-
-    // set size constant part of header
-    uiSizeOfFrame = 8;
-
-    // check if first frame to send -> command header needed
-    if (pSdoComCon_p->m_uiTransSize > 0)
-    {
-        if (pSdoComCon_p->m_uiTransferredByte == 0)
-        {   // start SDO transfer
-            // check if segmented or expedited transfer
-            // only for write commands
-            switch(pSdoComCon_p->m_SdoServiceType)
-            {
-                case kEplSdoServiceReadByIndex:
-                {   // first frame of read access always expedited
-                    pSdoComCon_p->m_SdoTransType = kEplSdoTransExpedited;
-                    pbPayload = &pCommandFrame->m_le_abCommandData[0];
-                    // fill rest of header
-                    AmiSetWordToLe( &pCommandFrame->m_le_wSegmentSize, 4);
-
-                    // create command header
-                    AmiSetWordToLe(pbPayload, (WORD)pSdoComCon_p->m_uiTargetIndex);
-                    pbPayload += 2;
-                    AmiSetByteToLe(pbPayload, (BYTE)pSdoComCon_p->m_uiTargetSubIndex);
-                    // calc size
-                    uiSizeOfFrame += 4;
-
-                    // set pSdoComCon_p->m_uiTransferredByte to one
-                    pSdoComCon_p->m_uiTransferredByte = 1;
-                    break;
-                }
-
-                case kEplSdoServiceWriteByIndex:
-                {
-                    if(pSdoComCon_p->m_uiTransSize > EPL_SDO_MAX_PAYLOAD )
-                    {   // segmented transfer
-                        // -> variable part of header needed
-                        // save that transfer is segmented
-                        pSdoComCon_p->m_SdoTransType = kEplSdoTransSegmented;
-                        // fill variable part of header
-                        AmiSetDwordToLe( &pCommandFrame->m_le_abCommandData[0], pSdoComCon_p->m_uiTransSize);
-                        // set pointer to real payload
-                        pbPayload = &pCommandFrame->m_le_abCommandData[4];
-                        // fill rest of header
-                        AmiSetWordToLe( &pCommandFrame->m_le_wSegmentSize, EPL_SDO_MAX_PAYLOAD);
-                        bFlags = 0x10;
-                        AmiSetByteToLe( &pCommandFrame->m_le_bFlags, bFlags);
-                        // create command header
-                        AmiSetWordToLe(pbPayload, (WORD) pSdoComCon_p->m_uiTargetIndex);
-                        pbPayload += 2;
-                        AmiSetByteToLe(pbPayload, (BYTE)pSdoComCon_p->m_uiTargetSubIndex);
-                        // on byte for reserved
-                        pbPayload += 2;
-                        // calc size
-                        uiSizeOfFrame += EPL_SDO_MAX_PAYLOAD;
-
-                        // copy payload
-                        EPL_MEMCPY( pbPayload,pSdoComCon_p->m_pData,  (EPL_SDO_MAX_PAYLOAD - 8));
-                        pSdoComCon_p->m_pData += (EPL_SDO_MAX_PAYLOAD - 8);
-                        // correct intern counter
-                        pSdoComCon_p->m_uiTransSize -= (EPL_SDO_MAX_PAYLOAD - 8);
-                        pSdoComCon_p->m_uiTransferredByte = (EPL_SDO_MAX_PAYLOAD - 8);
-
-                    }
-                    else
-                    {   // expedited trandsfer
-                        // save that transfer is expedited
-                        pSdoComCon_p->m_SdoTransType = kEplSdoTransExpedited;
-                        pbPayload = &pCommandFrame->m_le_abCommandData[0];
-
-                        // create command header
-                        AmiSetWordToLe(pbPayload, (WORD) pSdoComCon_p->m_uiTargetIndex);
-                        pbPayload += 2;
-                        AmiSetByteToLe(pbPayload, (BYTE)pSdoComCon_p->m_uiTargetSubIndex);
-                        // + 2 -> one byte for subindex and one byte reserved
-                        pbPayload += 2;
-                        // copy data
-                        EPL_MEMCPY( pbPayload,pSdoComCon_p->m_pData,  pSdoComCon_p->m_uiTransSize);
-                        // calc size
-                        uiSizeOfFrame += (4 + pSdoComCon_p->m_uiTransSize);
-                        // fill rest of header
-                        AmiSetWordToLe( &pCommandFrame->m_le_wSegmentSize, (WORD) (4 + pSdoComCon_p->m_uiTransSize));
-
-                        pSdoComCon_p->m_uiTransferredByte = pSdoComCon_p->m_uiTransSize;
-                        pSdoComCon_p->m_uiTransSize = 0;
-                    }
-                    break;
-                }
-
-                case kEplSdoServiceNIL:
-                default:
-                    // invalid service requested
-                    Ret = kEplSdoComInvalidServiceType;
-                    goto Exit;
-            } // end of switch(pSdoComCon_p->m_SdoServiceType)
-        }
-        else // (pSdoComCon_p->m_uiTransferredByte > 0)
-        {   // continue SDO transfer
-            switch(pSdoComCon_p->m_SdoServiceType)
-            {
-                // for expedited read is nothing to do
-                // -> server sends data
-
-                case kEplSdoServiceWriteByIndex:
-                {   // send next frame
-                    if(pSdoComCon_p->m_SdoTransType == kEplSdoTransSegmented)
-                    {
-                        if(pSdoComCon_p->m_uiTransSize > EPL_SDO_MAX_PAYLOAD)
-                        {   // next segment
-                            pbPayload = &pCommandFrame->m_le_abCommandData[0];
-                            // fill rest of header
-                            AmiSetWordToLe( &pCommandFrame->m_le_wSegmentSize, EPL_SDO_MAX_PAYLOAD);
-                            bFlags = 0x20;
-                            AmiSetByteToLe( &pCommandFrame->m_le_bFlags, bFlags);
-                            // copy data
-                            EPL_MEMCPY( pbPayload,pSdoComCon_p->m_pData,  EPL_SDO_MAX_PAYLOAD);
-                            pSdoComCon_p->m_pData += EPL_SDO_MAX_PAYLOAD;
-                            // correct intern counter
-                            pSdoComCon_p->m_uiTransSize -= EPL_SDO_MAX_PAYLOAD;
-                            pSdoComCon_p->m_uiTransferredByte = EPL_SDO_MAX_PAYLOAD;
-                            // calc size
-                            uiSizeOfFrame += EPL_SDO_MAX_PAYLOAD;
-
-
-                        }
-                        else
-                        {   // end of transfer
-                            pbPayload = &pCommandFrame->m_le_abCommandData[0];
-                            // fill rest of header
-                            AmiSetWordToLe( &pCommandFrame->m_le_wSegmentSize, (WORD) pSdoComCon_p->m_uiTransSize);
-                            bFlags = 0x30;
-                            AmiSetByteToLe( &pCommandFrame->m_le_bFlags, bFlags);
-                            // copy data
-                            EPL_MEMCPY( pbPayload,pSdoComCon_p->m_pData,  pSdoComCon_p->m_uiTransSize);
-                            pSdoComCon_p->m_pData += pSdoComCon_p->m_uiTransSize;
-                            // calc size
-                            uiSizeOfFrame += pSdoComCon_p->m_uiTransSize;
-                            // correct intern counter
-                            pSdoComCon_p->m_uiTransSize = 0;
-                            pSdoComCon_p->m_uiTransferredByte = pSdoComCon_p->m_uiTransSize;
-
-                        }
-                    }
-                    else
-                    {
-                        goto Exit;
-                    }
-                    break;
-                }
-                default:
-                {
-                    goto Exit;
-                }
-            } // end of switch(pSdoComCon_p->m_SdoServiceType)
-        }
-    }
-    else
-    {
-        goto Exit;
-    }
-
-
-    // call send function of lower layer
-    switch(pSdoComCon_p->m_SdoProtType)
-    {
-        case kEplSdoTypeAsnd:
-        case kEplSdoTypeUdp:
-        {
-            Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
-                                        uiSizeOfFrame,
-                                        pFrame);
-            break;
-        }
-
-        default:
-        {
-            Ret = kEplSdoComUnsupportedProt;
-        }
-    } // end of switch(pSdoComCon_p->m_SdoProtType)
-
+	tEplKernel Ret;
+	BYTE abFrame[EPL_MAX_SDO_FRAME_SIZE];
+	tEplFrame *pFrame;
+	tEplAsySdoCom *pCommandFrame;
+	unsigned int uiSizeOfFrame;
+	BYTE bFlags;
+	BYTE *pbPayload;
+
+	Ret = kEplSuccessful;
+
+	pFrame = (tEplFrame *) & abFrame[0];
+
+	EPL_MEMSET(&abFrame[0], 0x00, sizeof(abFrame));
+
+	// build generic part of frame
+	// get pointer to command layerpart of frame
+	pCommandFrame =
+	    &pFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.
+	    m_le_abSdoSeqPayload;
+	AmiSetByteToLe(&pCommandFrame->m_le_bCommandId,
+		       pSdoComCon_p->m_SdoServiceType);
+	AmiSetByteToLe(&pCommandFrame->m_le_bTransactionId,
+		       pSdoComCon_p->m_bTransactionId);
+
+	// set size constant part of header
+	uiSizeOfFrame = 8;
+
+	// check if first frame to send -> command header needed
+	if (pSdoComCon_p->m_uiTransSize > 0) {
+		if (pSdoComCon_p->m_uiTransferredByte == 0) {	// start SDO transfer
+			// check if segmented or expedited transfer
+			// only for write commands
+			switch (pSdoComCon_p->m_SdoServiceType) {
+			case kEplSdoServiceReadByIndex:
+				{	// first frame of read access always expedited
+					pSdoComCon_p->m_SdoTransType =
+					    kEplSdoTransExpedited;
+					pbPayload =
+					    &pCommandFrame->
+					    m_le_abCommandData[0];
+					// fill rest of header
+					AmiSetWordToLe(&pCommandFrame->
+						       m_le_wSegmentSize, 4);
+
+					// create command header
+					AmiSetWordToLe(pbPayload,
+						       (WORD) pSdoComCon_p->
+						       m_uiTargetIndex);
+					pbPayload += 2;
+					AmiSetByteToLe(pbPayload,
+						       (BYTE) pSdoComCon_p->
+						       m_uiTargetSubIndex);
+					// calc size
+					uiSizeOfFrame += 4;
+
+					// set pSdoComCon_p->m_uiTransferredByte to one
+					pSdoComCon_p->m_uiTransferredByte = 1;
+					break;
+				}
+
+			case kEplSdoServiceWriteByIndex:
+				{
+					if (pSdoComCon_p->m_uiTransSize > EPL_SDO_MAX_PAYLOAD) {	// segmented transfer
+						// -> variable part of header needed
+						// save that transfer is segmented
+						pSdoComCon_p->m_SdoTransType =
+						    kEplSdoTransSegmented;
+						// fill variable part of header
+						AmiSetDwordToLe(&pCommandFrame->
+								m_le_abCommandData
+								[0],
+								pSdoComCon_p->
+								m_uiTransSize);
+						// set pointer to real payload
+						pbPayload =
+						    &pCommandFrame->
+						    m_le_abCommandData[4];
+						// fill rest of header
+						AmiSetWordToLe(&pCommandFrame->
+							       m_le_wSegmentSize,
+							       EPL_SDO_MAX_PAYLOAD);
+						bFlags = 0x10;
+						AmiSetByteToLe(&pCommandFrame->
+							       m_le_bFlags,
+							       bFlags);
+						// create command header
+						AmiSetWordToLe(pbPayload,
+							       (WORD)
+							       pSdoComCon_p->
+							       m_uiTargetIndex);
+						pbPayload += 2;
+						AmiSetByteToLe(pbPayload,
+							       (BYTE)
+							       pSdoComCon_p->
+							       m_uiTargetSubIndex);
+						// on byte for reserved
+						pbPayload += 2;
+						// calc size
+						uiSizeOfFrame +=
+						    EPL_SDO_MAX_PAYLOAD;
+
+						// copy payload
+						EPL_MEMCPY(pbPayload,
+							   pSdoComCon_p->
+							   m_pData,
+							   (EPL_SDO_MAX_PAYLOAD
+							    - 8));
+						pSdoComCon_p->m_pData +=
+						    (EPL_SDO_MAX_PAYLOAD - 8);
+						// correct intern counter
+						pSdoComCon_p->m_uiTransSize -=
+						    (EPL_SDO_MAX_PAYLOAD - 8);
+						pSdoComCon_p->
+						    m_uiTransferredByte =
+						    (EPL_SDO_MAX_PAYLOAD - 8);
+
+					} else {	// expedited trandsfer
+						// save that transfer is expedited
+						pSdoComCon_p->m_SdoTransType =
+						    kEplSdoTransExpedited;
+						pbPayload =
+						    &pCommandFrame->
+						    m_le_abCommandData[0];
+
+						// create command header
+						AmiSetWordToLe(pbPayload,
+							       (WORD)
+							       pSdoComCon_p->
+							       m_uiTargetIndex);
+						pbPayload += 2;
+						AmiSetByteToLe(pbPayload,
+							       (BYTE)
+							       pSdoComCon_p->
+							       m_uiTargetSubIndex);
+						// + 2 -> one byte for subindex and one byte reserved
+						pbPayload += 2;
+						// copy data
+						EPL_MEMCPY(pbPayload,
+							   pSdoComCon_p->
+							   m_pData,
+							   pSdoComCon_p->
+							   m_uiTransSize);
+						// calc size
+						uiSizeOfFrame +=
+						    (4 +
+						     pSdoComCon_p->
+						     m_uiTransSize);
+						// fill rest of header
+						AmiSetWordToLe(&pCommandFrame->
+							       m_le_wSegmentSize,
+							       (WORD) (4 +
+								       pSdoComCon_p->
+								       m_uiTransSize));
+
+						pSdoComCon_p->
+						    m_uiTransferredByte =
+						    pSdoComCon_p->m_uiTransSize;
+						pSdoComCon_p->m_uiTransSize = 0;
+					}
+					break;
+				}
+
+			case kEplSdoServiceNIL:
+			default:
+				// invalid service requested
+				Ret = kEplSdoComInvalidServiceType;
+				goto Exit;
+			}	// end of switch(pSdoComCon_p->m_SdoServiceType)
+		} else		// (pSdoComCon_p->m_uiTransferredByte > 0)
+		{		// continue SDO transfer
+			switch (pSdoComCon_p->m_SdoServiceType) {
+				// for expedited read is nothing to do
+				// -> server sends data
+
+			case kEplSdoServiceWriteByIndex:
+				{	// send next frame
+					if (pSdoComCon_p->m_SdoTransType ==
+					    kEplSdoTransSegmented) {
+						if (pSdoComCon_p->m_uiTransSize > EPL_SDO_MAX_PAYLOAD) {	// next segment
+							pbPayload =
+							    &pCommandFrame->
+							    m_le_abCommandData
+							    [0];
+							// fill rest of header
+							AmiSetWordToLe
+							    (&pCommandFrame->
+							     m_le_wSegmentSize,
+							     EPL_SDO_MAX_PAYLOAD);
+							bFlags = 0x20;
+							AmiSetByteToLe
+							    (&pCommandFrame->
+							     m_le_bFlags,
+							     bFlags);
+							// copy data
+							EPL_MEMCPY(pbPayload,
+								   pSdoComCon_p->
+								   m_pData,
+								   EPL_SDO_MAX_PAYLOAD);
+							pSdoComCon_p->m_pData +=
+							    EPL_SDO_MAX_PAYLOAD;
+							// correct intern counter
+							pSdoComCon_p->
+							    m_uiTransSize -=
+							    EPL_SDO_MAX_PAYLOAD;
+							pSdoComCon_p->
+							    m_uiTransferredByte
+							    =
+							    EPL_SDO_MAX_PAYLOAD;
+							// calc size
+							uiSizeOfFrame +=
+							    EPL_SDO_MAX_PAYLOAD;
+
+						} else {	// end of transfer
+							pbPayload =
+							    &pCommandFrame->
+							    m_le_abCommandData
+							    [0];
+							// fill rest of header
+							AmiSetWordToLe
+							    (&pCommandFrame->
+							     m_le_wSegmentSize,
+							     (WORD)
+							     pSdoComCon_p->
+							     m_uiTransSize);
+							bFlags = 0x30;
+							AmiSetByteToLe
+							    (&pCommandFrame->
+							     m_le_bFlags,
+							     bFlags);
+							// copy data
+							EPL_MEMCPY(pbPayload,
+								   pSdoComCon_p->
+								   m_pData,
+								   pSdoComCon_p->
+								   m_uiTransSize);
+							pSdoComCon_p->m_pData +=
+							    pSdoComCon_p->
+							    m_uiTransSize;
+							// calc size
+							uiSizeOfFrame +=
+							    pSdoComCon_p->
+							    m_uiTransSize;
+							// correct intern counter
+							pSdoComCon_p->
+							    m_uiTransSize = 0;
+							pSdoComCon_p->
+							    m_uiTransferredByte
+							    =
+							    pSdoComCon_p->
+							    m_uiTransSize;
+
+						}
+					} else {
+						goto Exit;
+					}
+					break;
+				}
+			default:
+				{
+					goto Exit;
+				}
+			}	// end of switch(pSdoComCon_p->m_SdoServiceType)
+		}
+	} else {
+		goto Exit;
+	}
+
+	// call send function of lower layer
+	switch (pSdoComCon_p->m_SdoProtType) {
+	case kEplSdoTypeAsnd:
+	case kEplSdoTypeUdp:
+		{
+			Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
+						   uiSizeOfFrame, pFrame);
+			break;
+		}
+
+	default:
+		{
+			Ret = kEplSdoComUnsupportedProt;
+		}
+	}			// end of switch(pSdoComCon_p->m_SdoProtType)
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 #endif
@@ -2691,192 +2940,261 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-static tEplKernel EplSdoComClientProcessFrame(tEplSdoComConHdl   SdoComCon_p,
-                                              tEplAsySdoCom*     pAsySdoCom_p)
+static tEplKernel EplSdoComClientProcessFrame(tEplSdoComConHdl SdoComCon_p,
+					      tEplAsySdoCom * pAsySdoCom_p)
 {
-tEplKernel          Ret;
-BYTE                bBuffer;
-unsigned int        uiBuffer;
-unsigned int        uiDataSize;
-unsigned long       ulBuffer;
-tEplSdoComCon*      pSdoComCon;
-
-
-    Ret = kEplSuccessful;
-
-    // get pointer to control structure
-    pSdoComCon = &SdoComInstance_g.m_SdoComCon[SdoComCon_p];
-
-    // check if transaction Id fit
-    bBuffer = AmiGetByteFromLe(&pAsySdoCom_p->m_le_bTransactionId);
-    if(pSdoComCon->m_bTransactionId != bBuffer)
-    {
-        // incorrect transaction id
-
-        // if running transfer
-        if((pSdoComCon->m_uiTransferredByte != 0)
-            && (pSdoComCon->m_uiTransSize !=0))
-        {
-            pSdoComCon->m_dwLastAbortCode = EPL_SDOAC_GENERAL_ERROR;
-            // -> send abort
-            EplSdoComClientSendAbort(pSdoComCon, pSdoComCon->m_dwLastAbortCode);
-            // call callback of application
-            Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferTxAborted);
-        }
-
-    }
-    else
-    {   // check if correct command
-        bBuffer = AmiGetByteFromLe(&pAsySdoCom_p->m_le_bCommandId);
-        if(pSdoComCon->m_SdoServiceType != bBuffer)
-        {
-            // incorrect command
-            // if running transfer
-            if((pSdoComCon->m_uiTransferredByte != 0)
-                && (pSdoComCon->m_uiTransSize !=0))
-            {
-                pSdoComCon->m_dwLastAbortCode = EPL_SDOAC_GENERAL_ERROR;
-                // -> send abort
-                EplSdoComClientSendAbort(pSdoComCon, pSdoComCon->m_dwLastAbortCode);
-                // call callback of application
-                Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferTxAborted);
-            }
-
-        }
-        else
-        {   // switch on command
-            switch(pSdoComCon->m_SdoServiceType)
-            {
-                case kEplSdoServiceWriteByIndex:
-                {   // check if confirmation from server
-                    // nothing more to do
-                    break;
-                }
-
-                case kEplSdoServiceReadByIndex:
-                {   // check if it is an segmented or an expedited transfer
-                    bBuffer = AmiGetByteFromLe(&pAsySdoCom_p->m_le_bFlags);
-                    // mask uninteressting bits
-                    bBuffer &= 0x30;
-                    switch(bBuffer)
-                    {
-                        // expedited transfer
-                        case 0x00:
-                        {
-                            // check size of buffer
-                            uiBuffer = AmiGetWordFromLe(&pAsySdoCom_p->m_le_wSegmentSize);
-                            if(uiBuffer > pSdoComCon->m_uiTransSize)
-                            {   // buffer provided by the application is to small
-                                // copy only a part
-                                uiDataSize = pSdoComCon->m_uiTransSize;
-                            }
-                            else
-                            {   // buffer fits
-                                uiDataSize = uiBuffer;
-                            }
-
-                            // copy data
-                            EPL_MEMCPY(pSdoComCon->m_pData, &pAsySdoCom_p->m_le_abCommandData[0], uiDataSize);
-
-                            // correct counter
-                            pSdoComCon->m_uiTransSize = 0;
-                            pSdoComCon->m_uiTransferredByte = uiDataSize;
-                            break;
-                        }
-
-                        // start of a segmented transfer
-                        case 0x10:
-                        {   // get total size of transfer
-                            ulBuffer = AmiGetDwordFromLe(&pAsySdoCom_p->m_le_abCommandData[0]);
-                            if(ulBuffer <= pSdoComCon->m_uiTransSize)
-                            {   // buffer fit
-                                pSdoComCon->m_uiTransSize = (unsigned int)ulBuffer;
-                            }
-                            else
-                            {   // buffer to small
-                                // send abort
-                                pSdoComCon->m_dwLastAbortCode = EPL_SDOAC_DATA_TYPE_LENGTH_TOO_HIGH;
-                                // -> send abort
-                                EplSdoComClientSendAbort(pSdoComCon, pSdoComCon->m_dwLastAbortCode);
-                                // call callback of application
-                                Ret = EplSdoComTransferFinished(SdoComCon_p, pSdoComCon, kEplSdoComTransferRxAborted);
-                                goto Exit;
-                            }
-
-                            // get segment size
-                            // check size of buffer
-                            uiBuffer = AmiGetWordFromLe(&pAsySdoCom_p->m_le_wSegmentSize);
-                            // subtract size of vaiable header from datasize
-                            uiBuffer -= 4;
-                            // copy data
-                            EPL_MEMCPY(pSdoComCon->m_pData, &pAsySdoCom_p->m_le_abCommandData[4], uiBuffer);
-
-                            // correct counter an pointer
-                            pSdoComCon->m_pData += uiBuffer;
-                            pSdoComCon->m_uiTransferredByte += uiBuffer;
-                            pSdoComCon->m_uiTransSize -= uiBuffer;
-
-                            break;
-                        }
-
-                        // segment
-                        case 0x20:
-                        {
-                            // get segment size
-                            // check size of buffer
-                            uiBuffer = AmiGetWordFromLe(&pAsySdoCom_p->m_le_wSegmentSize);
-                            // check if data to copy fit to buffer
-                            if(uiBuffer >= pSdoComCon->m_uiTransSize)
-                            {   // to much data
-                                uiBuffer =  (pSdoComCon->m_uiTransSize - 1);
-                            }
-                            // copy data
-                            EPL_MEMCPY(pSdoComCon->m_pData, &pAsySdoCom_p->m_le_abCommandData[0], uiBuffer);
-
-                            // correct counter an pointer
-                            pSdoComCon->m_pData += uiBuffer;
-                            pSdoComCon->m_uiTransferredByte += uiBuffer;
-                            pSdoComCon->m_uiTransSize -= uiBuffer;
-                            break;
-                        }
-
-                        // last segment
-                        case 0x30:
-                        {
-                            // get segment size
-                            // check size of buffer
-                            uiBuffer = AmiGetWordFromLe(&pAsySdoCom_p->m_le_wSegmentSize);
-                            // check if data to copy fit to buffer
-                            if(uiBuffer > pSdoComCon->m_uiTransSize)
-                            {   // to much data
-                                uiBuffer =  (pSdoComCon->m_uiTransSize - 1);
-                            }
-                            // copy data
-                            EPL_MEMCPY(pSdoComCon->m_pData, &pAsySdoCom_p->m_le_abCommandData[0], uiBuffer);
-
-                            // correct counter an pointer
-                            pSdoComCon->m_pData += uiBuffer;
-                            pSdoComCon->m_uiTransferredByte += uiBuffer;
-                            pSdoComCon->m_uiTransSize  = 0;
-
-                            break;
-                        }
-                    }// end of switch(bBuffer & 0x30)
-
-                    break;
-                }
-
-                case kEplSdoServiceNIL:
-                default:
-                    // invalid service requested
-                    // $$$ d.k. What should we do?
-                    break;
-            }// end of switch(pSdoComCon->m_SdoServiceType)
-        }
-    }
+	tEplKernel Ret;
+	BYTE bBuffer;
+	unsigned int uiBuffer;
+	unsigned int uiDataSize;
+	unsigned long ulBuffer;
+	tEplSdoComCon *pSdoComCon;
+
+	Ret = kEplSuccessful;
+
+	// get pointer to control structure
+	pSdoComCon = &SdoComInstance_g.m_SdoComCon[SdoComCon_p];
+
+	// check if transaction Id fit
+	bBuffer = AmiGetByteFromLe(&pAsySdoCom_p->m_le_bTransactionId);
+	if (pSdoComCon->m_bTransactionId != bBuffer) {
+		// incorrect transaction id
+
+		// if running transfer
+		if ((pSdoComCon->m_uiTransferredByte != 0)
+		    && (pSdoComCon->m_uiTransSize != 0)) {
+			pSdoComCon->m_dwLastAbortCode = EPL_SDOAC_GENERAL_ERROR;
+			// -> send abort
+			EplSdoComClientSendAbort(pSdoComCon,
+						 pSdoComCon->m_dwLastAbortCode);
+			// call callback of application
+			Ret =
+			    EplSdoComTransferFinished(SdoComCon_p, pSdoComCon,
+						      kEplSdoComTransferTxAborted);
+		}
+
+	} else {		// check if correct command
+		bBuffer = AmiGetByteFromLe(&pAsySdoCom_p->m_le_bCommandId);
+		if (pSdoComCon->m_SdoServiceType != bBuffer) {
+			// incorrect command
+			// if running transfer
+			if ((pSdoComCon->m_uiTransferredByte != 0)
+			    && (pSdoComCon->m_uiTransSize != 0)) {
+				pSdoComCon->m_dwLastAbortCode =
+				    EPL_SDOAC_GENERAL_ERROR;
+				// -> send abort
+				EplSdoComClientSendAbort(pSdoComCon,
+							 pSdoComCon->
+							 m_dwLastAbortCode);
+				// call callback of application
+				Ret =
+				    EplSdoComTransferFinished(SdoComCon_p,
+							      pSdoComCon,
+							      kEplSdoComTransferTxAborted);
+			}
+
+		} else {	// switch on command
+			switch (pSdoComCon->m_SdoServiceType) {
+			case kEplSdoServiceWriteByIndex:
+				{	// check if confirmation from server
+					// nothing more to do
+					break;
+				}
+
+			case kEplSdoServiceReadByIndex:
+				{	// check if it is an segmented or an expedited transfer
+					bBuffer =
+					    AmiGetByteFromLe(&pAsySdoCom_p->
+							     m_le_bFlags);
+					// mask uninteressting bits
+					bBuffer &= 0x30;
+					switch (bBuffer) {
+						// expedited transfer
+					case 0x00:
+						{
+							// check size of buffer
+							uiBuffer =
+							    AmiGetWordFromLe
+							    (&pAsySdoCom_p->
+							     m_le_wSegmentSize);
+							if (uiBuffer > pSdoComCon->m_uiTransSize) {	// buffer provided by the application is to small
+								// copy only a part
+								uiDataSize =
+								    pSdoComCon->
+								    m_uiTransSize;
+							} else {	// buffer fits
+								uiDataSize =
+								    uiBuffer;
+							}
+
+							// copy data
+							EPL_MEMCPY(pSdoComCon->
+								   m_pData,
+								   &pAsySdoCom_p->
+								   m_le_abCommandData
+								   [0],
+								   uiDataSize);
+
+							// correct counter
+							pSdoComCon->
+							    m_uiTransSize = 0;
+							pSdoComCon->
+							    m_uiTransferredByte
+							    = uiDataSize;
+							break;
+						}
+
+						// start of a segmented transfer
+					case 0x10:
+						{	// get total size of transfer
+							ulBuffer =
+							    AmiGetDwordFromLe
+							    (&pAsySdoCom_p->
+							     m_le_abCommandData
+							     [0]);
+							if (ulBuffer <= pSdoComCon->m_uiTransSize) {	// buffer fit
+								pSdoComCon->
+								    m_uiTransSize
+								    =
+								    (unsigned
+								     int)
+								    ulBuffer;
+							} else {	// buffer to small
+								// send abort
+								pSdoComCon->
+								    m_dwLastAbortCode
+								    =
+								    EPL_SDOAC_DATA_TYPE_LENGTH_TOO_HIGH;
+								// -> send abort
+								EplSdoComClientSendAbort
+								    (pSdoComCon,
+								     pSdoComCon->
+								     m_dwLastAbortCode);
+								// call callback of application
+								Ret =
+								    EplSdoComTransferFinished
+								    (SdoComCon_p,
+								     pSdoComCon,
+								     kEplSdoComTransferRxAborted);
+								goto Exit;
+							}
+
+							// get segment size
+							// check size of buffer
+							uiBuffer =
+							    AmiGetWordFromLe
+							    (&pAsySdoCom_p->
+							     m_le_wSegmentSize);
+							// subtract size of vaiable header from datasize
+							uiBuffer -= 4;
+							// copy data
+							EPL_MEMCPY(pSdoComCon->
+								   m_pData,
+								   &pAsySdoCom_p->
+								   m_le_abCommandData
+								   [4],
+								   uiBuffer);
+
+							// correct counter an pointer
+							pSdoComCon->m_pData +=
+							    uiBuffer;
+							pSdoComCon->
+							    m_uiTransferredByte
+							    += uiBuffer;
+							pSdoComCon->
+							    m_uiTransSize -=
+							    uiBuffer;
+
+							break;
+						}
+
+						// segment
+					case 0x20:
+						{
+							// get segment size
+							// check size of buffer
+							uiBuffer =
+							    AmiGetWordFromLe
+							    (&pAsySdoCom_p->
+							     m_le_wSegmentSize);
+							// check if data to copy fit to buffer
+							if (uiBuffer >= pSdoComCon->m_uiTransSize) {	// to much data
+								uiBuffer =
+								    (pSdoComCon->
+								     m_uiTransSize
+								     - 1);
+							}
+							// copy data
+							EPL_MEMCPY(pSdoComCon->
+								   m_pData,
+								   &pAsySdoCom_p->
+								   m_le_abCommandData
+								   [0],
+								   uiBuffer);
+
+							// correct counter an pointer
+							pSdoComCon->m_pData +=
+							    uiBuffer;
+							pSdoComCon->
+							    m_uiTransferredByte
+							    += uiBuffer;
+							pSdoComCon->
+							    m_uiTransSize -=
+							    uiBuffer;
+							break;
+						}
+
+						// last segment
+					case 0x30:
+						{
+							// get segment size
+							// check size of buffer
+							uiBuffer =
+							    AmiGetWordFromLe
+							    (&pAsySdoCom_p->
+							     m_le_wSegmentSize);
+							// check if data to copy fit to buffer
+							if (uiBuffer > pSdoComCon->m_uiTransSize) {	// to much data
+								uiBuffer =
+								    (pSdoComCon->
+								     m_uiTransSize
+								     - 1);
+							}
+							// copy data
+							EPL_MEMCPY(pSdoComCon->
+								   m_pData,
+								   &pAsySdoCom_p->
+								   m_le_abCommandData
+								   [0],
+								   uiBuffer);
+
+							// correct counter an pointer
+							pSdoComCon->m_pData +=
+							    uiBuffer;
+							pSdoComCon->
+							    m_uiTransferredByte
+							    += uiBuffer;
+							pSdoComCon->
+							    m_uiTransSize = 0;
+
+							break;
+						}
+					}	// end of switch(bBuffer & 0x30)
+
+					break;
+				}
+
+			case kEplSdoServiceNIL:
+			default:
+				// invalid service requested
+				// $$$ d.k. What should we do?
+				break;
+			}	// end of switch(pSdoComCon->m_SdoServiceType)
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 #endif
 
@@ -2898,68 +3216,69 @@ Exit:
 //
 //---------------------------------------------------------------------------
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDOC)) != 0)
-static tEplKernel EplSdoComClientSendAbort(tEplSdoComCon* pSdoComCon_p,
-                                           DWORD          dwAbortCode_p)
+static tEplKernel EplSdoComClientSendAbort(tEplSdoComCon * pSdoComCon_p,
+					   DWORD dwAbortCode_p)
 {
-tEplKernel      Ret;
-BYTE            abFrame[EPL_MAX_SDO_FRAME_SIZE];
-tEplFrame*      pFrame;
-tEplAsySdoCom*  pCommandFrame;
-unsigned int    uiSizeOfFrame;
+	tEplKernel Ret;
+	BYTE abFrame[EPL_MAX_SDO_FRAME_SIZE];
+	tEplFrame *pFrame;
+	tEplAsySdoCom *pCommandFrame;
+	unsigned int uiSizeOfFrame;
+
+	Ret = kEplSuccessful;
+
+	pFrame = (tEplFrame *) & abFrame[0];
+
+	EPL_MEMSET(&abFrame[0], 0x00, sizeof(abFrame));
+
+	// build generic part of frame
+	// get pointer to command layerpart of frame
+	pCommandFrame =
+	    &pFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.
+	    m_le_abSdoSeqPayload;
+	AmiSetByteToLe(&pCommandFrame->m_le_bCommandId,
+		       pSdoComCon_p->m_SdoServiceType);
+	AmiSetByteToLe(&pCommandFrame->m_le_bTransactionId,
+		       pSdoComCon_p->m_bTransactionId);
+
+	uiSizeOfFrame = 8;
+
+	// set response and abort flag
+	pCommandFrame->m_le_bFlags |= 0x40;
+
+	// copy abortcode to frame
+	AmiSetDwordToLe(&pCommandFrame->m_le_abCommandData[0], dwAbortCode_p);
+
+	// set size of segment
+	AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize, sizeof(DWORD));
+
+	// update counter
+	pSdoComCon_p->m_uiTransferredByte = sizeof(DWORD);
+	pSdoComCon_p->m_uiTransSize = 0;
+
+	// calc framesize
+	uiSizeOfFrame += sizeof(DWORD);
+
+	// save abort code
+	pSdoComCon_p->m_dwLastAbortCode = dwAbortCode_p;
+
+	// call send function of lower layer
+	switch (pSdoComCon_p->m_SdoProtType) {
+	case kEplSdoTypeAsnd:
+	case kEplSdoTypeUdp:
+		{
+			Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
+						   uiSizeOfFrame, pFrame);
+			break;
+		}
+
+	default:
+		{
+			Ret = kEplSdoComUnsupportedProt;
+		}
+	}			// end of switch(pSdoComCon_p->m_SdoProtType)
 
-    Ret = kEplSuccessful;
-
-    pFrame = (tEplFrame*)&abFrame[0];
-
-    EPL_MEMSET(&abFrame[0], 0x00, sizeof(abFrame));
-
-    // build generic part of frame
-    // get pointer to command layerpart of frame
-    pCommandFrame = &pFrame->m_Data.m_Asnd.m_Payload.m_SdoSequenceFrame.m_le_abSdoSeqPayload;
-    AmiSetByteToLe( &pCommandFrame->m_le_bCommandId, pSdoComCon_p->m_SdoServiceType);
-    AmiSetByteToLe( &pCommandFrame->m_le_bTransactionId, pSdoComCon_p->m_bTransactionId);
-
-    uiSizeOfFrame = 8;
-
-    // set response and abort flag
-    pCommandFrame->m_le_bFlags |= 0x40;
-
-    // copy abortcode to frame
-    AmiSetDwordToLe(&pCommandFrame->m_le_abCommandData[0], dwAbortCode_p);
-
-    // set size of segment
-    AmiSetWordToLe(&pCommandFrame->m_le_wSegmentSize, sizeof(DWORD));
-
-    // update counter
-    pSdoComCon_p->m_uiTransferredByte = sizeof(DWORD);
-    pSdoComCon_p->m_uiTransSize = 0;
-
-    // calc framesize
-    uiSizeOfFrame += sizeof(DWORD);
-
-    // save abort code
-    pSdoComCon_p->m_dwLastAbortCode = dwAbortCode_p;
-
-    // call send function of lower layer
-    switch(pSdoComCon_p->m_SdoProtType)
-    {
-        case kEplSdoTypeAsnd:
-        case kEplSdoTypeUdp:
-        {
-            Ret = EplSdoAsySeqSendData(pSdoComCon_p->m_SdoSeqConHdl,
-                                        uiSizeOfFrame,
-                                        pFrame);
-            break;
-        }
-
-        default:
-        {
-            Ret = kEplSdoComUnsupportedProt;
-        }
-    } // end of switch(pSdoComCon_p->m_SdoProtType)
-
-
-    return Ret;
+	return Ret;
 }
 #endif
 
@@ -2979,51 +3298,49 @@ unsigned int    uiSizeOfFrame;
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel EplSdoComTransferFinished(tEplSdoComConHdl   SdoComCon_p,
-                                            tEplSdoComCon*     pSdoComCon_p,
-                                            tEplSdoComConState SdoComConState_p)
-{
-tEplKernel      Ret;
-
-    Ret = kEplSuccessful;
+static tEplKernel EplSdoComTransferFinished(tEplSdoComConHdl SdoComCon_p,
+					    tEplSdoComCon * pSdoComCon_p,
+					    tEplSdoComConState SdoComConState_p)
+{
+	tEplKernel Ret;
+
+	Ret = kEplSuccessful;
+
+	if (pSdoComCon_p->m_pfnTransferFinished != NULL) {
+		tEplSdoFinishedCb pfnTransferFinished;
+		tEplSdoComFinished SdoComFinished;
+
+		SdoComFinished.m_pUserArg = pSdoComCon_p->m_pUserArg;
+		SdoComFinished.m_uiNodeId = pSdoComCon_p->m_uiNodeId;
+		SdoComFinished.m_uiTargetIndex = pSdoComCon_p->m_uiTargetIndex;
+		SdoComFinished.m_uiTargetSubIndex =
+		    pSdoComCon_p->m_uiTargetSubIndex;
+		SdoComFinished.m_uiTransferredByte =
+		    pSdoComCon_p->m_uiTransferredByte;
+		SdoComFinished.m_dwAbortCode = pSdoComCon_p->m_dwLastAbortCode;
+		SdoComFinished.m_SdoComConHdl = SdoComCon_p;
+		SdoComFinished.m_SdoComConState = SdoComConState_p;
+		if (pSdoComCon_p->m_SdoServiceType ==
+		    kEplSdoServiceWriteByIndex) {
+			SdoComFinished.m_SdoAccessType = kEplSdoAccessTypeWrite;
+		} else {
+			SdoComFinished.m_SdoAccessType = kEplSdoAccessTypeRead;
+		}
+
+		// reset transfer state so this handle is not busy anymore
+		pSdoComCon_p->m_uiTransferredByte = 0;
+		pSdoComCon_p->m_uiTransSize = 0;
+
+		pfnTransferFinished = pSdoComCon_p->m_pfnTransferFinished;
+		// delete function pointer to inform application only once for each transfer
+		pSdoComCon_p->m_pfnTransferFinished = NULL;
 
-    if(pSdoComCon_p->m_pfnTransferFinished != NULL)
-    {
-    tEplSdoFinishedCb   pfnTransferFinished;
-    tEplSdoComFinished  SdoComFinished;
-
-        SdoComFinished.m_pUserArg = pSdoComCon_p->m_pUserArg;
-        SdoComFinished.m_uiNodeId = pSdoComCon_p->m_uiNodeId;
-        SdoComFinished.m_uiTargetIndex = pSdoComCon_p->m_uiTargetIndex;
-        SdoComFinished.m_uiTargetSubIndex = pSdoComCon_p->m_uiTargetSubIndex;
-        SdoComFinished.m_uiTransferredByte = pSdoComCon_p->m_uiTransferredByte;
-        SdoComFinished.m_dwAbortCode = pSdoComCon_p->m_dwLastAbortCode;
-        SdoComFinished.m_SdoComConHdl = SdoComCon_p;
-        SdoComFinished.m_SdoComConState = SdoComConState_p;
-        if (pSdoComCon_p->m_SdoServiceType == kEplSdoServiceWriteByIndex)
-        {
-            SdoComFinished.m_SdoAccessType = kEplSdoAccessTypeWrite;
-        }
-        else
-        {
-            SdoComFinished.m_SdoAccessType = kEplSdoAccessTypeRead;
-        }
-
-        // reset transfer state so this handle is not busy anymore
-        pSdoComCon_p->m_uiTransferredByte = 0;
-        pSdoComCon_p->m_uiTransSize = 0;
-
-        pfnTransferFinished = pSdoComCon_p->m_pfnTransferFinished;
-        // delete function pointer to inform application only once for each transfer
-        pSdoComCon_p->m_pfnTransferFinished = NULL;
+		// call application's callback function
+		pfnTransferFinished(&SdoComFinished);
 
-        // call application's callback function
-        pfnTransferFinished(&SdoComFinished);
+	}
 
-    }
-
-    return Ret;
+	return Ret;
 }
 
 // EOF
-
--- a/drivers/staging/epl/EplSdoUdpu.c
+++ b/drivers/staging/epl/EplSdoUdpu.c
@@ -68,7 +68,6 @@
 
 ****************************************************************************/
 
-
 #include "user/EplSdoUdpu.h"
 
 #if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
@@ -79,7 +78,6 @@
 #include <linux/sched.h>
 #endif
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -100,29 +98,27 @@
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    unsigned long   m_ulIpAddr;     // in network byte order
-    unsigned int    m_uiPort;       // in network byte order
+typedef struct {
+	unsigned long m_ulIpAddr;	// in network byte order
+	unsigned int m_uiPort;	// in network byte order
 
 } tEplSdoUdpCon;
 
 // instance table
-typedef struct
-{
-    tEplSdoUdpCon           m_aSdoAbsUdpConnection[EPL_SDO_MAX_CONNECTION_UDP];
-    tEplSequLayerReceiveCb  m_fpSdoAsySeqCb;
-    SOCKET                  m_UdpSocket;
+typedef struct {
+	tEplSdoUdpCon m_aSdoAbsUdpConnection[EPL_SDO_MAX_CONNECTION_UDP];
+	tEplSequLayerReceiveCb m_fpSdoAsySeqCb;
+	SOCKET m_UdpSocket;
 
 #if (TARGET_SYSTEM == _WIN32_)
-    HANDLE                  m_ThreadHandle;
-    LPCRITICAL_SECTION      m_pCriticalSection;
-    CRITICAL_SECTION        m_CriticalSection;
+	HANDLE m_ThreadHandle;
+	LPCRITICAL_SECTION m_pCriticalSection;
+	CRITICAL_SECTION m_CriticalSection;
 
 #elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-    struct completion       m_CompletionUdpThread;
-    int                     m_ThreadHandle;
-    int                     m_iTerminateThread;
+	struct completion m_CompletionUdpThread;
+	int m_ThreadHandle;
+	int m_iTerminateThread;
 #endif
 
 } tEplSdoUdpInstance;
@@ -131,7 +127,7 @@ typedef struct
 // modul globale vars
 //---------------------------------------------------------------------------
 
-static tEplSdoUdpInstance  SdoUdpInstance_g;
+static tEplSdoUdpInstance SdoUdpInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
@@ -141,7 +137,7 @@ static tEplSdoUdpInstance  SdoUdpInstanc
 static DWORD PUBLIC EplSdoUdpThread(LPVOID lpParameter);
 
 #elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-static int EplSdoUdpThread(void * pArg_p);
+static int EplSdoUdpThread(void *pArg_p);
 #endif
 
 /***************************************************************************/
@@ -157,8 +153,6 @@ static int EplSdoUdpThread(void * pArg_p
 //
 /***************************************************************************/
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -185,12 +179,11 @@ static int EplSdoUdpThread(void * pArg_p
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoUdpuInit(tEplSequLayerReceiveCb fpReceiveCb_p)
 {
-tEplKernel  Ret;
-
+	tEplKernel Ret;
 
-    Ret = EplSdoUdpuAddInstance(fpReceiveCb_p);
+	Ret = EplSdoUdpuAddInstance(fpReceiveCb_p);
 
-return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -214,59 +207,54 @@ return Ret;
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoUdpuAddInstance(tEplSequLayerReceiveCb fpReceiveCb_p)
 {
-tEplKernel          Ret;
+	tEplKernel Ret;
 
 #if (TARGET_SYSTEM == _WIN32_)
-int                 iError;
-WSADATA             Wsa;
+	int iError;
+	WSADATA Wsa;
 
 #endif
 
-    // set instance variables to 0
-    EPL_MEMSET(&SdoUdpInstance_g, 0x00, sizeof(SdoUdpInstance_g));
+	// set instance variables to 0
+	EPL_MEMSET(&SdoUdpInstance_g, 0x00, sizeof(SdoUdpInstance_g));
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // save pointer to callback-function
-    if (fpReceiveCb_p != NULL)
-    {
-        SdoUdpInstance_g.m_fpSdoAsySeqCb = fpReceiveCb_p;
-    }
-    else
-    {
-        Ret = kEplSdoUdpMissCb;
-        goto Exit;
-    }
+	// save pointer to callback-function
+	if (fpReceiveCb_p != NULL) {
+		SdoUdpInstance_g.m_fpSdoAsySeqCb = fpReceiveCb_p;
+	} else {
+		Ret = kEplSdoUdpMissCb;
+		goto Exit;
+	}
 
 #if (TARGET_SYSTEM == _WIN32_)
-    // start winsock2 for win32
-    // windows specific start of socket
-    iError = WSAStartup(MAKEWORD(2,0),&Wsa);
-    if (iError != 0)
-    {
-        Ret = kEplSdoUdpNoSocket;
-        goto Exit;
-    }
-
-    // create critical section for acccess of instnace variables
-    SdoUdpInstance_g.m_pCriticalSection = &SdoUdpInstance_g.m_CriticalSection;
-    InitializeCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
+	// start winsock2 for win32
+	// windows specific start of socket
+	iError = WSAStartup(MAKEWORD(2, 0), &Wsa);
+	if (iError != 0) {
+		Ret = kEplSdoUdpNoSocket;
+		goto Exit;
+	}
+	// create critical section for acccess of instnace variables
+	SdoUdpInstance_g.m_pCriticalSection =
+	    &SdoUdpInstance_g.m_CriticalSection;
+	InitializeCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
 
 #elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-    init_completion(&SdoUdpInstance_g.m_CompletionUdpThread);
-    SdoUdpInstance_g.m_iTerminateThread = 0;
+	init_completion(&SdoUdpInstance_g.m_CompletionUdpThread);
+	SdoUdpInstance_g.m_iTerminateThread = 0;
 #endif
 
-    SdoUdpInstance_g.m_ThreadHandle = 0;
-    SdoUdpInstance_g.m_UdpSocket = INVALID_SOCKET;
+	SdoUdpInstance_g.m_ThreadHandle = 0;
+	SdoUdpInstance_g.m_UdpSocket = INVALID_SOCKET;
 
-    Ret = EplSdoUdpuConfig(INADDR_ANY, 0);
+	Ret = EplSdoUdpuConfig(INADDR_ANY, 0);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplSdoUdpuDelInstance
@@ -287,56 +275,52 @@ Exit:
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoUdpuDelInstance()
 {
-tEplKernel      Ret;
+	tEplKernel Ret;
 
 #if (TARGET_SYSTEM == _WIN32_)
-BOOL                fTermError;
+	BOOL fTermError;
 #endif
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    if (SdoUdpInstance_g.m_ThreadHandle != 0)
-    {   // listen thread was started
-        // close thread
+	if (SdoUdpInstance_g.m_ThreadHandle != 0) {	// listen thread was started
+		// close thread
 #if (TARGET_SYSTEM == _WIN32_)
-        fTermError = TerminateThread(SdoUdpInstance_g.m_ThreadHandle, 0);
-        if(fTermError == FALSE)
-        {
-            Ret = kEplSdoUdpThreadError;
-            goto Exit;
-        }
-
+		fTermError =
+		    TerminateThread(SdoUdpInstance_g.m_ThreadHandle, 0);
+		if (fTermError == FALSE) {
+			Ret = kEplSdoUdpThreadError;
+			goto Exit;
+		}
 #elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-        SdoUdpInstance_g.m_iTerminateThread = 1;
-        /* kill_proc(SdoUdpInstance_g.m_ThreadHandle, SIGTERM, 1 ); */
-        send_sig(SIGTERM, SdoUdpInstance_g.m_ThreadHandle, 1);
-        wait_for_completion(&SdoUdpInstance_g.m_CompletionUdpThread);
+		SdoUdpInstance_g.m_iTerminateThread = 1;
+		/* kill_proc(SdoUdpInstance_g.m_ThreadHandle, SIGTERM, 1 ); */
+		send_sig(SIGTERM, SdoUdpInstance_g.m_ThreadHandle, 1);
+		wait_for_completion(&SdoUdpInstance_g.m_CompletionUdpThread);
 #endif
 
-        SdoUdpInstance_g.m_ThreadHandle = 0;
-    }
-
-    if (SdoUdpInstance_g.m_UdpSocket != INVALID_SOCKET)
-    {
-        // close socket
-        closesocket(SdoUdpInstance_g.m_UdpSocket);
-        SdoUdpInstance_g.m_UdpSocket = INVALID_SOCKET;
-    }
+		SdoUdpInstance_g.m_ThreadHandle = 0;
+	}
 
+	if (SdoUdpInstance_g.m_UdpSocket != INVALID_SOCKET) {
+		// close socket
+		closesocket(SdoUdpInstance_g.m_UdpSocket);
+		SdoUdpInstance_g.m_UdpSocket = INVALID_SOCKET;
+	}
 #if (TARGET_SYSTEM == _WIN32_)
-    // delete critical section
-    DeleteCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
+	// delete critical section
+	DeleteCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
 #endif
 
 #if (TARGET_SYSTEM == _WIN32_)
-    // for win 32
-    WSACleanup();
+	// for win 32
+	WSACleanup();
 #endif
 
 #if (TARGET_SYSTEM == _WIN32_)
-Exit:
+      Exit:
 #endif
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -356,120 +340,107 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoUdpuConfig(unsigned long ulIpAddr_p, unsigned int uiPort_p)
+tEplKernel PUBLIC EplSdoUdpuConfig(unsigned long ulIpAddr_p,
+				   unsigned int uiPort_p)
 {
-tEplKernel          Ret;
-struct sockaddr_in  Addr;
-int                 iError;
-
-#if (TARGET_SYSTEM == _WIN32_)
-BOOL                fTermError;
-unsigned long       ulThreadId;
-#endif
-
-    Ret = kEplSuccessful;
-
-    if (uiPort_p == 0)
-    {   // set UDP port to default port number
-        uiPort_p = EPL_C_SDO_EPL_PORT;
-    }
-    else if (uiPort_p > 65535)
-    {
-        Ret = kEplSdoUdpSocketError;
-        goto Exit;
-    }
-
-    if (SdoUdpInstance_g.m_ThreadHandle != 0)
-    {   // listen thread was started
-
-        // close old thread
-#if (TARGET_SYSTEM == _WIN32_)
-        fTermError = TerminateThread(SdoUdpInstance_g.m_ThreadHandle, 0);
-        if(fTermError == FALSE)
-        {
-            Ret = kEplSdoUdpThreadError;
-            goto Exit;
-        }
+	tEplKernel Ret;
+	struct sockaddr_in Addr;
+	int iError;
 
-#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-        SdoUdpInstance_g.m_iTerminateThread = 1;
-        /* kill_proc(SdoUdpInstance_g.m_ThreadHandle, SIGTERM, 1 ); */
-        send_sig(SIGTERM, SdoUdpInstance_g.m_ThreadHandle, 1);
-        wait_for_completion(&SdoUdpInstance_g.m_CompletionUdpThread);
-        SdoUdpInstance_g.m_iTerminateThread = 0;
-#endif
-
-        SdoUdpInstance_g.m_ThreadHandle = 0;
-    }
-
-    if (SdoUdpInstance_g.m_UdpSocket != INVALID_SOCKET)
-    {
-        // close socket
-        iError = closesocket(SdoUdpInstance_g.m_UdpSocket);
-        SdoUdpInstance_g.m_UdpSocket = INVALID_SOCKET;
-        if(iError != 0)
-        {
-            Ret = kEplSdoUdpSocketError;
-            goto Exit;
-        }
-    }
-
-    // create Socket
-    SdoUdpInstance_g.m_UdpSocket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-    if (SdoUdpInstance_g.m_UdpSocket == INVALID_SOCKET)
-    {
-        Ret = kEplSdoUdpNoSocket;
-        EPL_DBGLVL_SDO_TRACE0("EplSdoUdpuConfig: socket() failed\n");
-        goto Exit;
-    }
-
-    // bind socket
-    Addr.sin_family = AF_INET;
-    Addr.sin_port = htons((unsigned short) uiPort_p);
-    Addr.sin_addr.s_addr = htonl(ulIpAddr_p);
-    iError = bind(SdoUdpInstance_g.m_UdpSocket, (struct sockaddr*)&Addr, sizeof (Addr));
-    if (iError < 0)
-    {
-        //iError = WSAGetLastError();
-        EPL_DBGLVL_SDO_TRACE1("EplSdoUdpuConfig: bind() finished with %i\n", iError);
-        Ret = kEplSdoUdpNoSocket;
-        goto Exit;
-    }
-
-    // create Listen-Thread
-#if (TARGET_SYSTEM == _WIN32_)
-    // for win32
-
-    // create thread
-    SdoUdpInstance_g.m_ThreadHandle = CreateThread(NULL,
-                                                    0,
-                                                    EplSdoUdpThread,
-                                                    &SdoUdpInstance_g,
-                                                    0,
-                                                    &ulThreadId);
-    if(SdoUdpInstance_g.m_ThreadHandle == NULL)
-    {
-        Ret = kEplSdoUdpThreadError;
-        goto Exit;
-    }
+#if (TARGET_SYSTEM == _WIN32_)
+	BOOL fTermError;
+	unsigned long ulThreadId;
+#endif
 
+	Ret = kEplSuccessful;
+
+	if (uiPort_p == 0) {	// set UDP port to default port number
+		uiPort_p = EPL_C_SDO_EPL_PORT;
+	} else if (uiPort_p > 65535) {
+		Ret = kEplSdoUdpSocketError;
+		goto Exit;
+	}
+
+	if (SdoUdpInstance_g.m_ThreadHandle != 0) {	// listen thread was started
+
+		// close old thread
+#if (TARGET_SYSTEM == _WIN32_)
+		fTermError =
+		    TerminateThread(SdoUdpInstance_g.m_ThreadHandle, 0);
+		if (fTermError == FALSE) {
+			Ret = kEplSdoUdpThreadError;
+			goto Exit;
+		}
+#elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
+		SdoUdpInstance_g.m_iTerminateThread = 1;
+		/* kill_proc(SdoUdpInstance_g.m_ThreadHandle, SIGTERM, 1 ); */
+		send_sig(SIGTERM, SdoUdpInstance_g.m_ThreadHandle, 1);
+		wait_for_completion(&SdoUdpInstance_g.m_CompletionUdpThread);
+		SdoUdpInstance_g.m_iTerminateThread = 0;
+#endif
+
+		SdoUdpInstance_g.m_ThreadHandle = 0;
+	}
+
+	if (SdoUdpInstance_g.m_UdpSocket != INVALID_SOCKET) {
+		// close socket
+		iError = closesocket(SdoUdpInstance_g.m_UdpSocket);
+		SdoUdpInstance_g.m_UdpSocket = INVALID_SOCKET;
+		if (iError != 0) {
+			Ret = kEplSdoUdpSocketError;
+			goto Exit;
+		}
+	}
+	// create Socket
+	SdoUdpInstance_g.m_UdpSocket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
+	if (SdoUdpInstance_g.m_UdpSocket == INVALID_SOCKET) {
+		Ret = kEplSdoUdpNoSocket;
+		EPL_DBGLVL_SDO_TRACE0("EplSdoUdpuConfig: socket() failed\n");
+		goto Exit;
+	}
+	// bind socket
+	Addr.sin_family = AF_INET;
+	Addr.sin_port = htons((unsigned short)uiPort_p);
+	Addr.sin_addr.s_addr = htonl(ulIpAddr_p);
+	iError =
+	    bind(SdoUdpInstance_g.m_UdpSocket, (struct sockaddr *)&Addr,
+		 sizeof(Addr));
+	if (iError < 0) {
+		//iError = WSAGetLastError();
+		EPL_DBGLVL_SDO_TRACE1
+		    ("EplSdoUdpuConfig: bind() finished with %i\n", iError);
+		Ret = kEplSdoUdpNoSocket;
+		goto Exit;
+	}
+	// create Listen-Thread
+#if (TARGET_SYSTEM == _WIN32_)
+	// for win32
+
+	// create thread
+	SdoUdpInstance_g.m_ThreadHandle = CreateThread(NULL,
+						       0,
+						       EplSdoUdpThread,
+						       &SdoUdpInstance_g,
+						       0, &ulThreadId);
+	if (SdoUdpInstance_g.m_ThreadHandle == NULL) {
+		Ret = kEplSdoUdpThreadError;
+		goto Exit;
+	}
 #elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
 
-    SdoUdpInstance_g.m_ThreadHandle = kernel_thread(EplSdoUdpThread, &SdoUdpInstance_g, CLONE_KERNEL);
-    if(SdoUdpInstance_g.m_ThreadHandle == 0)
-    {
-        Ret = kEplSdoUdpThreadError;
-        goto Exit;
-    }
+	SdoUdpInstance_g.m_ThreadHandle =
+	    kernel_thread(EplSdoUdpThread, &SdoUdpInstance_g, CLONE_KERNEL);
+	if (SdoUdpInstance_g.m_ThreadHandle == 0) {
+		Ret = kEplSdoUdpThreadError;
+		goto Exit;
+	}
 #endif
 
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplSdoUdpuInitCon
@@ -488,57 +459,51 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoUdpuInitCon(tEplSdoConHdl*  pSdoConHandle_p,
-                                    unsigned int    uiTargetNodeId_p)
+tEplKernel PUBLIC EplSdoUdpuInitCon(tEplSdoConHdl * pSdoConHandle_p,
+				    unsigned int uiTargetNodeId_p)
 {
-tEplKernel          Ret;
-unsigned int        uiCount;
-unsigned int        uiFreeCon;
-tEplSdoUdpCon*      pSdoUdpCon;
-
-    Ret = kEplSuccessful;
-
-    // get free entry in control structure
-    uiCount = 0;
-    uiFreeCon = EPL_SDO_MAX_CONNECTION_UDP;
-    pSdoUdpCon = &SdoUdpInstance_g.m_aSdoAbsUdpConnection[0];
-    while (uiCount < EPL_SDO_MAX_CONNECTION_UDP)
-    {
-        if ((pSdoUdpCon->m_ulIpAddr & htonl(0xFF)) == htonl(uiTargetNodeId_p))
-        {   // existing connection to target node found
-            // set handle
-            *pSdoConHandle_p = (uiCount | EPL_SDO_UDP_HANDLE);
-
-            goto Exit;
-        }
-        else if ((pSdoUdpCon->m_ulIpAddr == 0)
-                && (pSdoUdpCon->m_uiPort == 0))
-        {
-            uiFreeCon = uiCount;
-        }
-        uiCount++;
-        pSdoUdpCon++;
-    }
-
-    if (uiFreeCon == EPL_SDO_MAX_CONNECTION_UDP)
-    {
-        // error no free handle
-        Ret = kEplSdoUdpNoFreeHandle;
-    }
-    else
-    {
-        pSdoUdpCon = &SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiFreeCon];
-        // save infos for connection
-        pSdoUdpCon->m_uiPort = htons(EPL_C_SDO_EPL_PORT);
-        pSdoUdpCon->m_ulIpAddr = htonl(0xC0A86400 | uiTargetNodeId_p);   // 192.168.100.uiTargetNodeId_p
+	tEplKernel Ret;
+	unsigned int uiCount;
+	unsigned int uiFreeCon;
+	tEplSdoUdpCon *pSdoUdpCon;
+
+	Ret = kEplSuccessful;
+
+	// get free entry in control structure
+	uiCount = 0;
+	uiFreeCon = EPL_SDO_MAX_CONNECTION_UDP;
+	pSdoUdpCon = &SdoUdpInstance_g.m_aSdoAbsUdpConnection[0];
+	while (uiCount < EPL_SDO_MAX_CONNECTION_UDP) {
+		if ((pSdoUdpCon->m_ulIpAddr & htonl(0xFF)) == htonl(uiTargetNodeId_p)) {	// existing connection to target node found
+			// set handle
+			*pSdoConHandle_p = (uiCount | EPL_SDO_UDP_HANDLE);
+
+			goto Exit;
+		} else if ((pSdoUdpCon->m_ulIpAddr == 0)
+			   && (pSdoUdpCon->m_uiPort == 0)) {
+			uiFreeCon = uiCount;
+		}
+		uiCount++;
+		pSdoUdpCon++;
+	}
+
+	if (uiFreeCon == EPL_SDO_MAX_CONNECTION_UDP) {
+		// error no free handle
+		Ret = kEplSdoUdpNoFreeHandle;
+	} else {
+		pSdoUdpCon =
+		    &SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiFreeCon];
+		// save infos for connection
+		pSdoUdpCon->m_uiPort = htons(EPL_C_SDO_EPL_PORT);
+		pSdoUdpCon->m_ulIpAddr = htonl(0xC0A86400 | uiTargetNodeId_p);	// 192.168.100.uiTargetNodeId_p
 
-        // set handle
-        *pSdoConHandle_p = (uiFreeCon | EPL_SDO_UDP_HANDLE);
+		// set handle
+		*pSdoConHandle_p = (uiFreeCon | EPL_SDO_UDP_HANDLE);
 
-    }
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
@@ -561,67 +526,67 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplSdoUdpuSendData(tEplSdoConHdl       SdoConHandle_p,
-                                    tEplFrame *          pSrcData_p,
-                                    DWORD                dwDataSize_p)
+tEplKernel PUBLIC EplSdoUdpuSendData(tEplSdoConHdl SdoConHandle_p,
+				     tEplFrame * pSrcData_p, DWORD dwDataSize_p)
 {
-tEplKernel          Ret;
-int                 iError;
-unsigned int        uiArray;
-struct sockaddr_in  Addr;
-
-    Ret = kEplSuccessful;
-
-    uiArray = (SdoConHandle_p & ~EPL_SDO_ASY_HANDLE_MASK);
-    if(uiArray >= EPL_SDO_MAX_CONNECTION_UDP)
-    {
-        Ret = kEplSdoUdpInvalidHdl;
-        goto Exit;
-    }
-    //set message type
-    AmiSetByteToLe(&pSrcData_p->m_le_bMessageType, 0x06); // SDO
-    // target node id (for Udp = 0)
-    AmiSetByteToLe(&pSrcData_p->m_le_bDstNodeId, 0x00);
-    // set source-nodeid (for Udp = 0)
-    AmiSetByteToLe(&pSrcData_p->m_le_bSrcNodeId, 0x00);
-
-    // calc size
-    dwDataSize_p += EPL_ASND_HEADER_SIZE;
-
-    // call sendto
-    Addr.sin_family = AF_INET;
-#if (TARGET_SYSTEM == _WIN32_)
-        // enter  critical section for process function
-    EnterCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
-#endif
-
-    Addr.sin_port = (unsigned short) SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiArray].m_uiPort;
-    Addr.sin_addr.s_addr = SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiArray].m_ulIpAddr;
-
-#if (TARGET_SYSTEM == _WIN32_)
-    // leave critical section for process function
-    LeaveCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
-#endif
-
-    iError = sendto (SdoUdpInstance_g.m_UdpSocket,       // sockethandle
-                (const char*) &pSrcData_p->m_le_bMessageType,        // data to send
-                dwDataSize_p,                          // number of bytes to send
-                0,                                     // flags
-                (struct sockaddr*)&Addr,                      // target
-                sizeof(struct sockaddr_in));                  // sizeof targetadress
-    if(iError < 0)
-    {
-        EPL_DBGLVL_SDO_TRACE1("EplSdoUdpuSendData: sendto() finished with %i\n", iError);
-        Ret = kEplSdoUdpSendError;
-        goto Exit;
-    }
+	tEplKernel Ret;
+	int iError;
+	unsigned int uiArray;
+	struct sockaddr_in Addr;
+
+	Ret = kEplSuccessful;
+
+	uiArray = (SdoConHandle_p & ~EPL_SDO_ASY_HANDLE_MASK);
+	if (uiArray >= EPL_SDO_MAX_CONNECTION_UDP) {
+		Ret = kEplSdoUdpInvalidHdl;
+		goto Exit;
+	}
+	//set message type
+	AmiSetByteToLe(&pSrcData_p->m_le_bMessageType, 0x06);	// SDO
+	// target node id (for Udp = 0)
+	AmiSetByteToLe(&pSrcData_p->m_le_bDstNodeId, 0x00);
+	// set source-nodeid (for Udp = 0)
+	AmiSetByteToLe(&pSrcData_p->m_le_bSrcNodeId, 0x00);
+
+	// calc size
+	dwDataSize_p += EPL_ASND_HEADER_SIZE;
+
+	// call sendto
+	Addr.sin_family = AF_INET;
+#if (TARGET_SYSTEM == _WIN32_)
+	// enter  critical section for process function
+	EnterCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
+#endif
+
+	Addr.sin_port =
+	    (unsigned short)SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiArray].
+	    m_uiPort;
+	Addr.sin_addr.s_addr =
+	    SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiArray].m_ulIpAddr;
+
+#if (TARGET_SYSTEM == _WIN32_)
+	// leave critical section for process function
+	LeaveCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
+#endif
+
+	iError = sendto(SdoUdpInstance_g.m_UdpSocket,	// sockethandle
+			(const char *)&pSrcData_p->m_le_bMessageType,	// data to send
+			dwDataSize_p,	// number of bytes to send
+			0,	// flags
+			(struct sockaddr *)&Addr,	// target
+			sizeof(struct sockaddr_in));	// sizeof targetadress
+	if (iError < 0) {
+		EPL_DBGLVL_SDO_TRACE1
+		    ("EplSdoUdpuSendData: sendto() finished with %i\n", iError);
+		Ret = kEplSdoUdpSendError;
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplSdoUdpuDelCon
@@ -640,29 +605,24 @@ Exit:
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplSdoUdpuDelCon(tEplSdoConHdl SdoConHandle_p)
 {
-tEplKernel      Ret;
-unsigned int    uiArray;
-
-
-    uiArray = (SdoConHandle_p & ~EPL_SDO_ASY_HANDLE_MASK);
+	tEplKernel Ret;
+	unsigned int uiArray;
 
-    if(uiArray >= EPL_SDO_MAX_CONNECTION_UDP)
-    {
-        Ret = kEplSdoUdpInvalidHdl;
-        goto Exit;
-    }
-    else
-    {
-        Ret = kEplSuccessful;
-    }
+	uiArray = (SdoConHandle_p & ~EPL_SDO_ASY_HANDLE_MASK);
 
+	if (uiArray >= EPL_SDO_MAX_CONNECTION_UDP) {
+		Ret = kEplSdoUdpInvalidHdl;
+		goto Exit;
+	} else {
+		Ret = kEplSuccessful;
+	}
+
+	// delete connection
+	SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiArray].m_ulIpAddr = 0;
+	SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiArray].m_uiPort = 0;
 
-    // delete connection
-    SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiArray].m_ulIpAddr = 0;
-    SdoUdpInstance_g.m_aSdoAbsUdpConnection[uiArray].m_uiPort = 0;
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 //=========================================================================//
@@ -691,131 +651,140 @@ Exit:
 #if (TARGET_SYSTEM == _WIN32_)
 static DWORD PUBLIC EplSdoUdpThread(LPVOID lpParameter)
 #elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-static int EplSdoUdpThread(void * pArg_p)
+static int EplSdoUdpThread(void *pArg_p)
 #endif
 {
 
-tEplSdoUdpInstance* pInstance;
-struct sockaddr_in  RemoteAddr;
-int                 iError;
-int                 iCount;
-int                 iFreeEntry;
-BYTE                abBuffer[EPL_MAX_SDO_REC_FRAME_SIZE];
-unsigned int        uiSize;
-tEplSdoConHdl       SdoConHdl;
+	tEplSdoUdpInstance *pInstance;
+	struct sockaddr_in RemoteAddr;
+	int iError;
+	int iCount;
+	int iFreeEntry;
+	BYTE abBuffer[EPL_MAX_SDO_REC_FRAME_SIZE];
+	unsigned int uiSize;
+	tEplSdoConHdl SdoConHdl;
 
 #if (TARGET_SYSTEM == _WIN32_)
-    pInstance = (tEplSdoUdpInstance*)lpParameter;
-
-    for (;;)
+	pInstance = (tEplSdoUdpInstance *) lpParameter;
 
+	for (;;)
 #elif (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-    pInstance = (tEplSdoUdpInstance*)pArg_p;
-    daemonize("EplSdoUdpThread");
-    allow_signal( SIGTERM );
-
-    for (;pInstance->m_iTerminateThread == 0;)
-#endif
-
-    {
-        // wait for data
-        uiSize = sizeof(struct sockaddr);
-        iError = recvfrom(pInstance->m_UdpSocket,   // Socket
-                        (char *)&abBuffer[0],               // buffer for data
-                        sizeof(abBuffer),           // size of the buffer
-                        0,                          // flags
-                        (struct sockaddr*)&RemoteAddr,
-                        (int*)&uiSize);
+	pInstance = (tEplSdoUdpInstance *) pArg_p;
+	daemonize("EplSdoUdpThread");
+	allow_signal(SIGTERM);
+
+	for (; pInstance->m_iTerminateThread == 0;)
+#endif
+
+	{
+		// wait for data
+		uiSize = sizeof(struct sockaddr);
+		iError = recvfrom(pInstance->m_UdpSocket,	// Socket
+				  (char *)&abBuffer[0],	// buffer for data
+				  sizeof(abBuffer),	// size of the buffer
+				  0,	// flags
+				  (struct sockaddr *)&RemoteAddr,
+				  (int *)&uiSize);
 #if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-        if (iError == -ERESTARTSYS)
-        {
-            break;
-        }
-#endif
-        if (iError > 0)
-        {
-            // get handle for higher layer
-            iCount = 0;
-            iFreeEntry = 0xFFFF;
-#if (TARGET_SYSTEM == _WIN32_)
-        // enter  critical section for process function
-    EnterCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
-#endif
-            while (iCount < EPL_SDO_MAX_CONNECTION_UDP)
-            {
-                // check if this connection is already known
-                if((pInstance->m_aSdoAbsUdpConnection[iCount].m_ulIpAddr == RemoteAddr.sin_addr.s_addr)
-                    && (pInstance->m_aSdoAbsUdpConnection[iCount].m_uiPort == RemoteAddr.sin_port))
-                {
-                    break;
-                }
-
-                if((pInstance->m_aSdoAbsUdpConnection[iCount].m_ulIpAddr == 0)
-                    && (pInstance->m_aSdoAbsUdpConnection[iCount].m_uiPort == 0)
-                    && (iFreeEntry == 0xFFFF))
-
-                {
-                    iFreeEntry  = iCount;
-                }
-
-                iCount++;
-            }
-
-            if (iCount == EPL_SDO_MAX_CONNECTION_UDP)
-            {
-                // connection unknown
-                // see if there is a free handle
-                if (iFreeEntry != 0xFFFF)
-                {
-                    // save adress infos
-                    pInstance->m_aSdoAbsUdpConnection[iFreeEntry].m_ulIpAddr =
-                        RemoteAddr.sin_addr.s_addr;
-                    pInstance->m_aSdoAbsUdpConnection[iFreeEntry].m_uiPort =
-                        RemoteAddr.sin_port;
-#if (TARGET_SYSTEM == _WIN32_)
-    // leave critical section for process function
-    LeaveCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
-#endif
-                    // call callback
-                    SdoConHdl = iFreeEntry;
-                    SdoConHdl |= EPL_SDO_UDP_HANDLE;
-                    // offset 4 -> start of SDO Sequence header
-                    pInstance->m_fpSdoAsySeqCb(SdoConHdl, (tEplAsySdoSeq*)&abBuffer[4], (iError - 4));
-                }
-                else
-                {
-                    EPL_DBGLVL_SDO_TRACE0("Error in EplSdoUdpThread() no free handle\n");
-#if (TARGET_SYSTEM == _WIN32_)
-    // leave critical section for process function
-    LeaveCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
-#endif
-                }
-
-            }
-            else
-            {
-                // known connection
-                // call callback with correct handle
-                SdoConHdl = iCount;
-                SdoConHdl |= EPL_SDO_UDP_HANDLE;
-#if (TARGET_SYSTEM == _WIN32_)
-    // leave critical section for process function
-    LeaveCriticalSection(SdoUdpInstance_g.m_pCriticalSection);
-#endif
-                // offset 4 -> start of SDO Sequence header
-                pInstance->m_fpSdoAsySeqCb(SdoConHdl, (tEplAsySdoSeq*)&abBuffer[4], (iError - 4));
-            }
-        } // end of  if(iError!=SOCKET_ERROR)
-    }// end of for(;;)
+		if (iError == -ERESTARTSYS) {
+			break;
+		}
+#endif
+		if (iError > 0) {
+			// get handle for higher layer
+			iCount = 0;
+			iFreeEntry = 0xFFFF;
+#if (TARGET_SYSTEM == _WIN32_)
+			// enter  critical section for process function
+			EnterCriticalSection(SdoUdpInstance_g.
+					     m_pCriticalSection);
+#endif
+			while (iCount < EPL_SDO_MAX_CONNECTION_UDP) {
+				// check if this connection is already known
+				if ((pInstance->m_aSdoAbsUdpConnection[iCount].
+				     m_ulIpAddr == RemoteAddr.sin_addr.s_addr)
+				    && (pInstance->
+					m_aSdoAbsUdpConnection[iCount].
+					m_uiPort == RemoteAddr.sin_port)) {
+					break;
+				}
+
+				if ((pInstance->m_aSdoAbsUdpConnection[iCount].
+				     m_ulIpAddr == 0)
+				    && (pInstance->
+					m_aSdoAbsUdpConnection[iCount].
+					m_uiPort == 0)
+				    && (iFreeEntry == 0xFFFF))
+				{
+					iFreeEntry = iCount;
+				}
+
+				iCount++;
+			}
+
+			if (iCount == EPL_SDO_MAX_CONNECTION_UDP) {
+				// connection unknown
+				// see if there is a free handle
+				if (iFreeEntry != 0xFFFF) {
+					// save adress infos
+					pInstance->
+					    m_aSdoAbsUdpConnection[iFreeEntry].
+					    m_ulIpAddr =
+					    RemoteAddr.sin_addr.s_addr;
+					pInstance->
+					    m_aSdoAbsUdpConnection[iFreeEntry].
+					    m_uiPort = RemoteAddr.sin_port;
+#if (TARGET_SYSTEM == _WIN32_)
+					// leave critical section for process function
+					LeaveCriticalSection(SdoUdpInstance_g.
+							     m_pCriticalSection);
+#endif
+					// call callback
+					SdoConHdl = iFreeEntry;
+					SdoConHdl |= EPL_SDO_UDP_HANDLE;
+					// offset 4 -> start of SDO Sequence header
+					pInstance->m_fpSdoAsySeqCb(SdoConHdl,
+								   (tEplAsySdoSeq
+								    *) &
+								   abBuffer[4],
+								   (iError -
+								    4));
+				} else {
+					EPL_DBGLVL_SDO_TRACE0
+					    ("Error in EplSdoUdpThread() no free handle\n");
+#if (TARGET_SYSTEM == _WIN32_)
+					// leave critical section for process function
+					LeaveCriticalSection(SdoUdpInstance_g.
+							     m_pCriticalSection);
+#endif
+				}
+
+			} else {
+				// known connection
+				// call callback with correct handle
+				SdoConHdl = iCount;
+				SdoConHdl |= EPL_SDO_UDP_HANDLE;
+#if (TARGET_SYSTEM == _WIN32_)
+				// leave critical section for process function
+				LeaveCriticalSection(SdoUdpInstance_g.
+						     m_pCriticalSection);
+#endif
+				// offset 4 -> start of SDO Sequence header
+				pInstance->m_fpSdoAsySeqCb(SdoConHdl,
+							   (tEplAsySdoSeq *) &
+							   abBuffer[4],
+							   (iError - 4));
+			}
+		}		// end of  if(iError!=SOCKET_ERROR)
+	}			// end of for(;;)
 
 #if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-    complete_and_exit(&SdoUdpInstance_g.m_CompletionUdpThread, 0);
+	complete_and_exit(&SdoUdpInstance_g.m_CompletionUdpThread, 0);
 #endif
 
-    return 0;
+	return 0;
 }
 
 #endif // end of #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_SDO_UDP)) != 0)
 
 // EOF
-
--- a/drivers/staging/epl/EplStatusu.c
+++ b/drivers/staging/epl/EplStatusu.c
@@ -95,7 +95,6 @@
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -109,7 +108,6 @@
 //
 /***************************************************************************/
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   D E F I N I T I O N S                          //
@@ -124,9 +122,8 @@
 // local types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    tEplStatusuCbResponse m_apfnCbResponse[254];
+typedef struct {
+	tEplStatusuCbResponse m_apfnCbResponse[254];
 
 } tEplStatusuInstance;
 
@@ -134,13 +131,14 @@ typedef struct
 // local vars
 //---------------------------------------------------------------------------
 
-static tEplStatusuInstance   EplStatusuInstance_g;
+static tEplStatusuInstance EplStatusuInstance_g;
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-static tEplKernel PUBLIC EplStatusuCbStatusResponse(tEplFrameInfo * pFrameInfo_p);
+static tEplKernel PUBLIC EplStatusuCbStatusResponse(tEplFrameInfo *
+						    pFrameInfo_p);
 
 //=========================================================================//
 //                                                                         //
@@ -168,14 +166,13 @@ static tEplKernel PUBLIC EplStatusuCbSta
 
 EPLDLLEXPORT tEplKernel PUBLIC EplStatusuInit()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = EplStatusuAddInstance();
+	Ret = EplStatusuAddInstance();
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplStatusuAddInstance
@@ -196,21 +193,23 @@ tEplKernel Ret;
 
 EPLDLLEXPORT tEplKernel PUBLIC EplStatusuAddInstance()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // reset instance structure
-    EPL_MEMSET(&EplStatusuInstance_g, 0, sizeof (EplStatusuInstance_g));
+	// reset instance structure
+	EPL_MEMSET(&EplStatusuInstance_g, 0, sizeof(EplStatusuInstance_g));
 
-    // register StatusResponse callback function
-    Ret = EplDlluCalRegAsndService(kEplDllAsndStatusResponse, EplStatusuCbStatusResponse, kEplDllAsndFilterAny);
+	// register StatusResponse callback function
+	Ret =
+	    EplDlluCalRegAsndService(kEplDllAsndStatusResponse,
+				     EplStatusuCbStatusResponse,
+				     kEplDllAsndFilterAny);
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplStatusuDelInstance
@@ -231,18 +230,19 @@ tEplKernel Ret;
 
 EPLDLLEXPORT tEplKernel PUBLIC EplStatusuDelInstance()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // deregister StatusResponse callback function
-    Ret = EplDlluCalRegAsndService(kEplDllAsndStatusResponse, NULL, kEplDllAsndFilterNone);
+	// deregister StatusResponse callback function
+	Ret =
+	    EplDlluCalRegAsndService(kEplDllAsndStatusResponse, NULL,
+				     kEplDllAsndFilterNone);
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplStatusuReset
@@ -260,18 +260,17 @@ tEplKernel  Ret;
 
 EPLDLLEXPORT tEplKernel PUBLIC EplStatusuReset()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // reset instance structure
-    EPL_MEMSET(&EplStatusuInstance_g, 0, sizeof (EplStatusuInstance_g));
+	// reset instance structure
+	EPL_MEMSET(&EplStatusuInstance_g, 0, sizeof(EplStatusuInstance_g));
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplStatusuRequestStatusResponse
@@ -288,42 +287,38 @@ tEplKernel  Ret;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplStatusuRequestStatusResponse(
-                                  unsigned int        uiNodeId_p,
-                                  tEplStatusuCbResponse pfnCbResponse_p)
+tEplKernel PUBLIC EplStatusuRequestStatusResponse(unsigned int uiNodeId_p,
+						  tEplStatusuCbResponse
+						  pfnCbResponse_p)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // decrement node ID, because array is zero based
-    uiNodeId_p--;
-    if (uiNodeId_p < tabentries (EplStatusuInstance_g.m_apfnCbResponse))
-    {
+	// decrement node ID, because array is zero based
+	uiNodeId_p--;
+	if (uiNodeId_p < tabentries(EplStatusuInstance_g.m_apfnCbResponse)) {
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-        if (EplStatusuInstance_g.m_apfnCbResponse[uiNodeId_p] != NULL)
-        {   // request already issued (maybe by someone else)
-            Ret = kEplInvalidOperation;
-        }
-        else
-        {
-            EplStatusuInstance_g.m_apfnCbResponse[uiNodeId_p] = pfnCbResponse_p;
-            Ret = EplDlluCalIssueRequest(kEplDllReqServiceStatus, (uiNodeId_p + 1), 0xFF);
-        }
+		if (EplStatusuInstance_g.m_apfnCbResponse[uiNodeId_p] != NULL) {	// request already issued (maybe by someone else)
+			Ret = kEplInvalidOperation;
+		} else {
+			EplStatusuInstance_g.m_apfnCbResponse[uiNodeId_p] =
+			    pfnCbResponse_p;
+			Ret =
+			    EplDlluCalIssueRequest(kEplDllReqServiceStatus,
+						   (uiNodeId_p + 1), 0xFF);
+		}
 #else
-        Ret = kEplInvalidOperation;
+		Ret = kEplInvalidOperation;
 #endif
-    }
-    else
-    {   // invalid node ID specified
-        Ret = kEplInvalidNodeId;
-    }
+	} else {		// invalid node ID specified
+		Ret = kEplInvalidNodeId;
+	}
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -347,41 +342,39 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-static tEplKernel PUBLIC EplStatusuCbStatusResponse(tEplFrameInfo * pFrameInfo_p)
+static tEplKernel PUBLIC EplStatusuCbStatusResponse(tEplFrameInfo *
+						    pFrameInfo_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-unsigned int    uiNodeId;
-unsigned int    uiIndex;
-tEplStatusuCbResponse    pfnCbResponse;
-
-    uiNodeId = AmiGetByteFromLe(&pFrameInfo_p->m_pFrame->m_le_bSrcNodeId);
-
-    uiIndex = uiNodeId - 1;
-
-    if (uiIndex < tabentries (EplStatusuInstance_g.m_apfnCbResponse))
-    {
-        // memorize pointer to callback function
-        pfnCbResponse = EplStatusuInstance_g.m_apfnCbResponse[uiIndex];
-        if (pfnCbResponse == NULL)
-        {   // response was not requested
-            goto Exit;
-        }
-        // reset callback function pointer so that caller may issue next request
-        EplStatusuInstance_g.m_apfnCbResponse[uiIndex] = NULL;
-
-        if (pFrameInfo_p->m_uiFrameSize < EPL_C_DLL_MINSIZE_STATUSRES)
-        {   // StatusResponse not received or it has invalid size
-            Ret = pfnCbResponse(uiNodeId, NULL);
-        }
-        else
-        {   // StatusResponse received
-            Ret = pfnCbResponse(uiNodeId, &pFrameInfo_p->m_pFrame->m_Data.m_Asnd.m_Payload.m_StatusResponse);
-        }
-    }
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiNodeId;
+	unsigned int uiIndex;
+	tEplStatusuCbResponse pfnCbResponse;
+
+	uiNodeId = AmiGetByteFromLe(&pFrameInfo_p->m_pFrame->m_le_bSrcNodeId);
+
+	uiIndex = uiNodeId - 1;
+
+	if (uiIndex < tabentries(EplStatusuInstance_g.m_apfnCbResponse)) {
+		// memorize pointer to callback function
+		pfnCbResponse = EplStatusuInstance_g.m_apfnCbResponse[uiIndex];
+		if (pfnCbResponse == NULL) {	// response was not requested
+			goto Exit;
+		}
+		// reset callback function pointer so that caller may issue next request
+		EplStatusuInstance_g.m_apfnCbResponse[uiIndex] = NULL;
+
+		if (pFrameInfo_p->m_uiFrameSize < EPL_C_DLL_MINSIZE_STATUSRES) {	// StatusResponse not received or it has invalid size
+			Ret = pfnCbResponse(uiNodeId, NULL);
+		} else {	// StatusResponse received
+			Ret =
+			    pfnCbResponse(uiNodeId,
+					  &pFrameInfo_p->m_pFrame->m_Data.
+					  m_Asnd.m_Payload.m_StatusResponse);
+		}
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
 // EOF
-
--- a/drivers/staging/epl/EplTimeruLinuxKernel.c
+++ b/drivers/staging/epl/EplTimeruLinuxKernel.c
@@ -86,10 +86,9 @@
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
-typedef struct
-{
-    struct timer_list   m_Timer;
-    tEplTimerArg        TimerArgument;
+typedef struct {
+	struct timer_list m_Timer;
+	tEplTimerArg TimerArgument;
 
 } tEplTimeruData;
 
@@ -137,14 +136,13 @@ static void PUBLIC EplTimeruCbMs(unsigne
 
 tEplKernel PUBLIC EplTimeruInit()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplTimeruAddInstance();
+	Ret = EplTimeruAddInstance();
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimeruAddInstance
@@ -161,14 +159,13 @@ tEplKernel  Ret;
 
 tEplKernel PUBLIC EplTimeruAddInstance()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimeruDelInstance
@@ -187,14 +184,13 @@ tEplKernel Ret;
 
 tEplKernel PUBLIC EplTimeruDelInstance()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimeruSetTimerMs
@@ -211,43 +207,40 @@ tEplKernel  Ret;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplTimeruSetTimerMs(tEplTimerHdl*     pTimerHdl_p,
-                                        unsigned long   ulTime_p,
-                                        tEplTimerArg    Argument_p)
+tEplKernel PUBLIC EplTimeruSetTimerMs(tEplTimerHdl * pTimerHdl_p,
+				      unsigned long ulTime_p,
+				      tEplTimerArg Argument_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplTimeruData*     pData;
-
-    // check pointer to handle
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
-
-    pData = (tEplTimeruData*) EPL_MALLOC(sizeof (tEplTimeruData));
-    if (pData == NULL)
-    {
-        Ret = kEplNoResource;
-        goto Exit;
-    }
+	tEplKernel Ret = kEplSuccessful;
+	tEplTimeruData *pData;
 
-    init_timer(&pData->m_Timer);
-    pData->m_Timer.function = EplTimeruCbMs;
-    pData->m_Timer.data = (unsigned long) pData;
-    pData->m_Timer.expires = jiffies + ulTime_p * HZ / 1000;
+	// check pointer to handle
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
+
+	pData = (tEplTimeruData *) EPL_MALLOC(sizeof(tEplTimeruData));
+	if (pData == NULL) {
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+
+	init_timer(&pData->m_Timer);
+	pData->m_Timer.function = EplTimeruCbMs;
+	pData->m_Timer.data = (unsigned long)pData;
+	pData->m_Timer.expires = jiffies + ulTime_p * HZ / 1000;
 
-    EPL_MEMCPY(&pData->TimerArgument, &Argument_p, sizeof(tEplTimerArg));
+	EPL_MEMCPY(&pData->TimerArgument, &Argument_p, sizeof(tEplTimerArg));
 
-    add_timer(&pData->m_Timer);
+	add_timer(&pData->m_Timer);
 
-    *pTimerHdl_p = (tEplTimerHdl) pData;
+	*pTimerHdl_p = (tEplTimerHdl) pData;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimeruModifyTimerMs
@@ -264,57 +257,50 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplTimeruModifyTimerMs(tEplTimerHdl*     pTimerHdl_p,
-                                        unsigned long     ulTime_p,
-                                        tEplTimerArg      Argument_p)
+tEplKernel PUBLIC EplTimeruModifyTimerMs(tEplTimerHdl * pTimerHdl_p,
+					 unsigned long ulTime_p,
+					 tEplTimerArg Argument_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplTimeruData*     pData;
-
-    // check pointer to handle
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
-
-    // check handle itself, i.e. was the handle initialized before
-    if (*pTimerHdl_p == 0)
-    {
-        Ret = EplTimeruSetTimerMs(pTimerHdl_p, ulTime_p, Argument_p);
-        goto Exit;
-    }
-    pData = (tEplTimeruData*) *pTimerHdl_p;
-    if ((tEplTimeruData*)pData->m_Timer.data != pData)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
+	tEplKernel Ret = kEplSuccessful;
+	tEplTimeruData *pData;
 
-    mod_timer(&pData->m_Timer, (jiffies + ulTime_p * HZ / 1000));
-
-    // copy the TimerArg after the timer is restarted,
-    // so that a timer occured immediately before mod_timer
-    // won't use the new TimerArg and
-    // therefore the old timer cannot be distinguished from the new one.
-    // But if the new timer is too fast, it may get lost.
-    EPL_MEMCPY(&pData->TimerArgument, &Argument_p, sizeof(tEplTimerArg));
-
-    // check if timer is really running
-    if (timer_pending(&pData->m_Timer) == 0)
-    {   // timer is not running
-        // retry starting it
-        add_timer(&pData->m_Timer);
-    }
-
-    // set handle to pointer of tEplTimeruData
+	// check pointer to handle
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
+	// check handle itself, i.e. was the handle initialized before
+	if (*pTimerHdl_p == 0) {
+		Ret = EplTimeruSetTimerMs(pTimerHdl_p, ulTime_p, Argument_p);
+		goto Exit;
+	}
+	pData = (tEplTimeruData *) * pTimerHdl_p;
+	if ((tEplTimeruData *) pData->m_Timer.data != pData) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
+
+	mod_timer(&pData->m_Timer, (jiffies + ulTime_p * HZ / 1000));
+
+	// copy the TimerArg after the timer is restarted,
+	// so that a timer occured immediately before mod_timer
+	// won't use the new TimerArg and
+	// therefore the old timer cannot be distinguished from the new one.
+	// But if the new timer is too fast, it may get lost.
+	EPL_MEMCPY(&pData->TimerArgument, &Argument_p, sizeof(tEplTimerArg));
+
+	// check if timer is really running
+	if (timer_pending(&pData->m_Timer) == 0) {	// timer is not running
+		// retry starting it
+		add_timer(&pData->m_Timer);
+	}
+	// set handle to pointer of tEplTimeruData
 //    *pTimerHdl_p = (tEplTimerHdl) pData;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimeruDeleteTimer
@@ -329,50 +315,45 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplTimeruDeleteTimer(tEplTimerHdl*     pTimerHdl_p)
+tEplKernel PUBLIC EplTimeruDeleteTimer(tEplTimerHdl * pTimerHdl_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplTimeruData*     pData;
+	tEplKernel Ret = kEplSuccessful;
+	tEplTimeruData *pData;
 
-    // check pointer to handle
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
-
-    // check handle itself, i.e. was the handle initialized before
-    if (*pTimerHdl_p == 0)
-    {
-        Ret = kEplSuccessful;
-        goto Exit;
-    }
-    pData = (tEplTimeruData*) *pTimerHdl_p;
-    if ((tEplTimeruData*)pData->m_Timer.data != pData)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
+	// check pointer to handle
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
+	// check handle itself, i.e. was the handle initialized before
+	if (*pTimerHdl_p == 0) {
+		Ret = kEplSuccessful;
+		goto Exit;
+	}
+	pData = (tEplTimeruData *) * pTimerHdl_p;
+	if ((tEplTimeruData *) pData->m_Timer.data != pData) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
 
 /*    if (del_timer(&pData->m_Timer) == 1)
     {
         kfree(pData);
     }
 */
-    // try to delete the timer
-    del_timer(&pData->m_Timer);
-    // free memory in any case
-    kfree(pData);
+	// try to delete the timer
+	del_timer(&pData->m_Timer);
+	// free memory in any case
+	kfree(pData);
 
-    // uninitialize handle
-    *pTimerHdl_p = 0;
+	// uninitialize handle
+	*pTimerHdl_p = 0;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimeruIsTimerActive
@@ -391,33 +372,28 @@ Exit:
 
 BOOL PUBLIC EplTimeruIsTimerActive(tEplTimerHdl TimerHdl_p)
 {
-BOOL        fActive = FALSE;
-tEplTimeruData*     pData;
+	BOOL fActive = FALSE;
+	tEplTimeruData *pData;
 
-    // check handle itself, i.e. was the handle initialized before
-    if (TimerHdl_p == 0)
-    {   // timer was not created yet, so it is not active
-        goto Exit;
-    }
-    pData = (tEplTimeruData*) TimerHdl_p;
-    if ((tEplTimeruData*)pData->m_Timer.data != pData)
-    {   // invalid timer
-        goto Exit;
-    }
+	// check handle itself, i.e. was the handle initialized before
+	if (TimerHdl_p == 0) {	// timer was not created yet, so it is not active
+		goto Exit;
+	}
+	pData = (tEplTimeruData *) TimerHdl_p;
+	if ((tEplTimeruData *) pData->m_Timer.data != pData) {	// invalid timer
+		goto Exit;
+	}
+	// check if timer is running
+	if (timer_pending(&pData->m_Timer) == 0) {	// timer is not running
+		goto Exit;
+	}
 
-    // check if timer is running
-    if (timer_pending(&pData->m_Timer) == 0)
-    {   // timer is not running
-        goto Exit;
-    }
+	fActive = TRUE;
 
-    fActive = TRUE;
-
-Exit:
-    return fActive;
+      Exit:
+	return fActive;
 }
 
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -443,30 +419,28 @@ Exit:
 //---------------------------------------------------------------------------
 static void PUBLIC EplTimeruCbMs(unsigned long ulParameter_p)
 {
-tEplKernel          Ret = kEplSuccessful;
-tEplTimeruData*     pData;
-tEplEvent           EplEvent;
-tEplTimerEventArg   TimerEventArg;
-
-    pData = (tEplTimeruData*) ulParameter_p;
-
-    // call event function
-    TimerEventArg.m_TimerHdl = (tEplTimerHdl)pData;
-    TimerEventArg.m_ulArg = pData->TimerArgument.m_ulArg;
-
-    EplEvent.m_EventSink = pData->TimerArgument.m_EventSink;
-    EplEvent.m_EventType = kEplEventTypeTimer;
-    EPL_MEMSET(&EplEvent.m_NetTime, 0x00, sizeof(tEplNetTime));
-    EplEvent.m_pArg = &TimerEventArg;
-    EplEvent.m_uiSize = sizeof(TimerEventArg);
+	tEplKernel Ret = kEplSuccessful;
+	tEplTimeruData *pData;
+	tEplEvent EplEvent;
+	tEplTimerEventArg TimerEventArg;
+
+	pData = (tEplTimeruData *) ulParameter_p;
+
+	// call event function
+	TimerEventArg.m_TimerHdl = (tEplTimerHdl) pData;
+	TimerEventArg.m_ulArg = pData->TimerArgument.m_ulArg;
+
+	EplEvent.m_EventSink = pData->TimerArgument.m_EventSink;
+	EplEvent.m_EventType = kEplEventTypeTimer;
+	EPL_MEMSET(&EplEvent.m_NetTime, 0x00, sizeof(tEplNetTime));
+	EplEvent.m_pArg = &TimerEventArg;
+	EplEvent.m_uiSize = sizeof(TimerEventArg);
 
-    Ret = EplEventuPost(&EplEvent);
+	Ret = EplEventuPost(&EplEvent);
 
-    // d.k. do not free memory, user has to call EplTimeruDeleteTimer()
-    //kfree(pData);
+	// d.k. do not free memory, user has to call EplTimeruDeleteTimer()
+	//kfree(pData);
 
 }
 
-
 // EOF
-
--- a/drivers/staging/epl/EplTimeruNull.c
+++ b/drivers/staging/epl/EplTimeruNull.c
@@ -132,11 +132,11 @@
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplTimeruInit()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplTimeruAddInstance();
+	Ret = EplTimeruAddInstance();
 
-return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -158,11 +158,11 @@ return Ret;
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplTimeruAddInstance()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -186,11 +186,11 @@ return Ret;
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplTimeruDelInstance()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -212,27 +212,24 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplTimeruSetTimerMs(tEplTimerHdl*     pTimerHdl_p,
-                                        unsigned long   ulTime_p,
-                                        tEplTimerArg    Argument_p)
-{
-tEplKernel          Ret;
-
-
-    Ret = kEplSuccessful;
-
-    // check handle
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
+tEplKernel PUBLIC EplTimeruSetTimerMs(tEplTimerHdl * pTimerHdl_p,
+				      unsigned long ulTime_p,
+				      tEplTimerArg Argument_p)
+{
+	tEplKernel Ret;
+
+	Ret = kEplSuccessful;
+
+	// check handle
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
  //---------------------------------------------------------------------------
 //
 // Function:    EplTimeruModifyTimerMs
@@ -252,24 +249,22 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplTimeruModifyTimerMs(tEplTimerHdl*     pTimerHdl_p,
-                                        unsigned long     ulTime_p,
-                                        tEplTimerArg      Argument_p)
-{
-tEplKernel          Ret;
-
-    Ret = kEplSuccessful;
+tEplKernel PUBLIC EplTimeruModifyTimerMs(tEplTimerHdl * pTimerHdl_p,
+					 unsigned long ulTime_p,
+					 tEplTimerArg Argument_p)
+{
+	tEplKernel Ret;
+
+	Ret = kEplSuccessful;
+
+	// check parameter
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
 
-    // check parameter
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
-
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
  //---------------------------------------------------------------------------
@@ -289,25 +284,22 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplTimeruDeleteTimer(tEplTimerHdl*     pTimerHdl_p)
+tEplKernel PUBLIC EplTimeruDeleteTimer(tEplTimerHdl * pTimerHdl_p)
 {
-tEplKernel  Ret;
-
-    Ret = kEplSuccessful;
-
-    // check parameter
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
+	tEplKernel Ret;
 
-    // set handle invalide
-    *pTimerHdl_p = 0;
+	Ret = kEplSuccessful;
 
+	// check parameter
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
+	// set handle invalide
+	*pTimerHdl_p = 0;
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
@@ -317,7 +309,4 @@ Exit:
 //                                                                         //
 //=========================================================================//
 
-
-
 // EOF
-
--- a/drivers/staging/epl/EplTimeruWin32.c
+++ b/drivers/staging/epl/EplTimeruWin32.c
@@ -85,24 +85,22 @@
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
-typedef struct
-{
-    tEplTimerArg    TimerArgument;
-    HANDLE          DelteHandle;
-    unsigned long   ulTimeout;
-
-}tEplTimeruThread;
-
-typedef struct
-{
-    LPCRITICAL_SECTION  m_pCriticalSection;
-    CRITICAL_SECTION    m_CriticalSection;
-}tEplTimeruInstance;
+typedef struct {
+	tEplTimerArg TimerArgument;
+	HANDLE DelteHandle;
+	unsigned long ulTimeout;
+
+} tEplTimeruThread;
+
+typedef struct {
+	LPCRITICAL_SECTION m_pCriticalSection;
+	CRITICAL_SECTION m_CriticalSection;
+} tEplTimeruInstance;
 //---------------------------------------------------------------------------
 // modul globale vars
 //---------------------------------------------------------------------------
 static tEplTimeruInstance EplTimeruInstance_g;
-static tEplTimeruThread   ThreadData_l;
+static tEplTimeruThread ThreadData_l;
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
@@ -146,11 +144,11 @@ DWORD PUBLIC EplSdoTimeruThreadms(LPVOID
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplTimeruInit()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplTimeruAddInstance();
+	Ret = EplTimeruAddInstance();
 
-return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -172,18 +170,16 @@ return Ret;
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplTimeruAddInstance()
 {
-tEplKernel Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
+	// create critical section
+	EplTimeruInstance_g.m_pCriticalSection =
+	    &EplTimeruInstance_g.m_CriticalSection;
+	InitializeCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
 
-    // create critical section
-    EplTimeruInstance_g.m_pCriticalSection = &EplTimeruInstance_g.m_CriticalSection;
-    InitializeCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
-
-
-
-return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -207,11 +203,11 @@ return Ret;
 //---------------------------------------------------------------------------
 tEplKernel PUBLIC EplTimeruDelInstance()
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    return Ret;
+	return Ret;
 }
 
 //---------------------------------------------------------------------------
@@ -233,71 +229,60 @@ tEplKernel  Ret;
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplTimeruSetTimerMs(tEplTimerHdl*     pTimerHdl_p,
-                                        unsigned long   ulTime_p,
-                                        tEplTimerArg    Argument_p)
+tEplKernel PUBLIC EplTimeruSetTimerMs(tEplTimerHdl * pTimerHdl_p,
+				      unsigned long ulTime_p,
+				      tEplTimerArg Argument_p)
 {
-tEplKernel          Ret;
-HANDLE              DeleteHandle;
-HANDLE              ThreadHandle;
-DWORD               ThreadId;
-
-
-    Ret = kEplSuccessful;
-
-    // check handle
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
-
-    // enter  critical section
-    EnterCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
-
-    // first create event to delete timer
-    DeleteHandle = CreateEvent(NULL,FALSE,FALSE, NULL);
-    if(DeleteHandle == NULL)
-    {
-        Ret = kEplTimerNoTimerCreated;
-        goto Exit;
-    }
-
-    // set handle for caller
-    *pTimerHdl_p = (tEplTimerHdl)DeleteHandle;
-
+	tEplKernel Ret;
+	HANDLE DeleteHandle;
+	HANDLE ThreadHandle;
+	DWORD ThreadId;
+
+	Ret = kEplSuccessful;
+
+	// check handle
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
+	// enter  critical section
+	EnterCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
+
+	// first create event to delete timer
+	DeleteHandle = CreateEvent(NULL, FALSE, FALSE, NULL);
+	if (DeleteHandle == NULL) {
+		Ret = kEplTimerNoTimerCreated;
+		goto Exit;
+	}
+	// set handle for caller
+	*pTimerHdl_p = (tEplTimerHdl) DeleteHandle;
+
+	// fill data for thread
+	ThreadData_l.DelteHandle = DeleteHandle;
+	EPL_MEMCPY(&ThreadData_l.TimerArgument, &Argument_p,
+		   sizeof(tEplTimerArg));
+	ThreadData_l.ulTimeout = ulTime_p;
+
+	// create thread to create waitable timer and wait for timer
+	ThreadHandle = CreateThread(NULL,
+				    0,
+				    EplSdoTimeruThreadms,
+				    &ThreadData_l, 0, &ThreadId);
+	if (ThreadHandle == NULL) {
+		// leave critical section
+		LeaveCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
+
+		// delte handle
+		CloseHandle(DeleteHandle);
+
+		Ret = kEplTimerNoTimerCreated;
+		goto Exit;
+	}
 
-
-
-    // fill data for thread
-    ThreadData_l.DelteHandle = DeleteHandle;
-    EPL_MEMCPY(&ThreadData_l.TimerArgument, &Argument_p, sizeof(tEplTimerArg));
-    ThreadData_l.ulTimeout = ulTime_p;
-
-    // create thread to create waitable timer and wait for timer
-    ThreadHandle = CreateThread(NULL,
-                                0,
-                                EplSdoTimeruThreadms,
-                                &ThreadData_l,
-                                0,
-                                &ThreadId);
-    if(ThreadHandle == NULL)
-    {
-        // leave critical section
-        LeaveCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
-
-        // delte handle
-        CloseHandle(DeleteHandle);
-
-        Ret = kEplTimerNoTimerCreated;
-        goto Exit;
-    }
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
  //---------------------------------------------------------------------------
 //
 // Function:    EplTimeruModifyTimerMs
@@ -317,69 +302,64 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplTimeruModifyTimerMs(tEplTimerHdl*     pTimerHdl_p,
-                                        unsigned long     ulTime_p,
-                                        tEplTimerArg      Argument_p)
+tEplKernel PUBLIC EplTimeruModifyTimerMs(tEplTimerHdl * pTimerHdl_p,
+					 unsigned long ulTime_p,
+					 tEplTimerArg Argument_p)
 {
-tEplKernel          Ret;
-HANDLE              DeleteHandle;
-HANDLE              ThreadHandle;
-DWORD               ThreadId;
-
-    Ret = kEplSuccessful;
-
-    // check parameter
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
-
-    DeleteHandle = (HANDLE)(*pTimerHdl_p);
-
-    // set event to end timer task for this timer
-    SetEvent(DeleteHandle);
-
-    // create new timer
-    // first create event to delete timer
-    DeleteHandle = CreateEvent(NULL,FALSE,FALSE, NULL);
-    if(DeleteHandle == NULL)
-    {
-        Ret = kEplTimerNoTimerCreated;
-        goto Exit;
-    }
-
-    // set handle for caller
-    *pTimerHdl_p = (tEplTimerHdl)DeleteHandle;
-
-    // enter  critical section
-    EnterCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
-
-    // fill data for thread
-    ThreadData_l.DelteHandle = DeleteHandle;
-    EPL_MEMCPY(&ThreadData_l.TimerArgument, &Argument_p, sizeof(tEplTimerArg));
-    ThreadData_l.ulTimeout = ulTime_p;
-
-    // create thread to create waitable timer and wait for timer
-    ThreadHandle = CreateThread(NULL,
-                                0,
-                                EplSdoTimeruThreadms,
-                                &ThreadData_l,
-                                0,
-                                &ThreadId);
-    if(ThreadHandle == NULL)
-    {
-        // leave critical section
-        LeaveCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
-
-        // delte handle
-
-        Ret = kEplTimerNoTimerCreated;
-        goto Exit;
-    }
+	tEplKernel Ret;
+	HANDLE DeleteHandle;
+	HANDLE ThreadHandle;
+	DWORD ThreadId;
+
+	Ret = kEplSuccessful;
+
+	// check parameter
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
+
+	DeleteHandle = (HANDLE) (*pTimerHdl_p);
+
+	// set event to end timer task for this timer
+	SetEvent(DeleteHandle);
+
+	// create new timer
+	// first create event to delete timer
+	DeleteHandle = CreateEvent(NULL, FALSE, FALSE, NULL);
+	if (DeleteHandle == NULL) {
+		Ret = kEplTimerNoTimerCreated;
+		goto Exit;
+	}
+	// set handle for caller
+	*pTimerHdl_p = (tEplTimerHdl) DeleteHandle;
+
+	// enter  critical section
+	EnterCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
+
+	// fill data for thread
+	ThreadData_l.DelteHandle = DeleteHandle;
+	EPL_MEMCPY(&ThreadData_l.TimerArgument, &Argument_p,
+		   sizeof(tEplTimerArg));
+	ThreadData_l.ulTimeout = ulTime_p;
+
+	// create thread to create waitable timer and wait for timer
+	ThreadHandle = CreateThread(NULL,
+				    0,
+				    EplSdoTimeruThreadms,
+				    &ThreadData_l, 0, &ThreadId);
+	if (ThreadHandle == NULL) {
+		// leave critical section
+		LeaveCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
+
+		// delte handle
+
+		Ret = kEplTimerNoTimerCreated;
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
  //---------------------------------------------------------------------------
@@ -399,31 +379,29 @@ Exit:
 // State:
 //
 //---------------------------------------------------------------------------
-tEplKernel PUBLIC EplTimeruDeleteTimer(tEplTimerHdl*     pTimerHdl_p)
+tEplKernel PUBLIC EplTimeruDeleteTimer(tEplTimerHdl * pTimerHdl_p)
 {
-tEplKernel  Ret;
-HANDLE      DeleteHandle;
+	tEplKernel Ret;
+	HANDLE DeleteHandle;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    // check parameter
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
+	// check parameter
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
 
-    DeleteHandle = (HANDLE)(*pTimerHdl_p);
+	DeleteHandle = (HANDLE) (*pTimerHdl_p);
 
-    // set event to end timer task for this timer
-    SetEvent(DeleteHandle);
+	// set event to end timer task for this timer
+	SetEvent(DeleteHandle);
 
-    // set handle invalide
-    *pTimerHdl_p = 0;
+	// set handle invalide
+	*pTimerHdl_p = 0;
 
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
@@ -452,100 +430,84 @@ Exit:
 //---------------------------------------------------------------------------
 DWORD PUBLIC EplSdoTimeruThreadms(LPVOID lpParameter)
 {
-tEplKernel          Ret;
-tEplTimeruThread*   pThreadData;
-HANDLE              aHandles[2];
-BOOL                fReturn;
-LARGE_INTEGER       TimeoutTime;
-unsigned long       ulEvent;
-tEplEvent           EplEvent;
-tEplTimeruThread    ThreadData;
-tEplTimerEventArg   TimerEventArg;
-
-    Ret = kEplSuccessful;
-
-    // get pointer to data
-    pThreadData = (tEplTimeruThread*)lpParameter;
-    // copy thread data
-    EPL_MEMCPY(&ThreadData, pThreadData, sizeof(ThreadData));
-    pThreadData = &ThreadData;
-
-    // leave critical section
-    LeaveCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
-
-    // create waitable timer
-    aHandles[1] = CreateWaitableTimer(NULL,FALSE,NULL);
-    if(aHandles[1] == NULL)
-    {
-        Ret = kEplTimerNoTimerCreated;
-        goto Exit;
-    }
-
-    // set timer
-    // set timeout interval -> needed to be negativ
-    // -> because relative timeout
-    // -> multiply by 10000 for 100 ns timebase of function
-    TimeoutTime.QuadPart = (((long long)pThreadData->ulTimeout) * -10000);
-    fReturn = SetWaitableTimer(aHandles[1],
-                               &TimeoutTime,
-                               0,
-                               NULL,
-                               NULL,
-                               FALSE);
-    if(fReturn == 0)
-    {
-        Ret = kEplTimerNoTimerCreated;
-        goto Exit;
-    }
-
-    // save delte event handle in handle array
-    aHandles[0] = pThreadData->DelteHandle;
-
-    // wait for one of the events
-    ulEvent = WaitForMultipleObjects( 2,
-                            &aHandles[0],
-                            FALSE,
-                            INFINITE);
-    if(ulEvent == WAIT_OBJECT_0)
-    {   // delte event
-
-        // close handels
-        CloseHandle(aHandles[1]);
-        // terminate thread
-        goto Exit;
-    }
-    else if(ulEvent == (WAIT_OBJECT_0 + 1))
-    {   // timer event
-        // call event function
-        TimerEventArg.m_TimerHdl = (tEplTimerHdl)pThreadData->DelteHandle;
-        TimerEventArg.m_ulArg = pThreadData->TimerArgument.m_ulArg;
-
-        EplEvent.m_EventSink = pThreadData->TimerArgument.m_EventSink;
-        EplEvent.m_EventType = kEplEventTypeTimer;
-        EPL_MEMSET(&EplEvent.m_NetTime, 0x00, sizeof(tEplNetTime));
-        EplEvent.m_pArg = &TimerEventArg;
-        EplEvent.m_uiSize = sizeof(TimerEventArg);
-
-        Ret = EplEventuPost(&EplEvent);
-
-        // close handels
-        CloseHandle(aHandles[1]);
-        // terminate thread
-        goto Exit;
-
-    }
-    else
-    {   // error
-        ulEvent = GetLastError();
-        TRACE1("Error in WaitForMultipleObjects Errorcode: 0x%x\n",ulEvent);
-         // terminate thread
-        goto Exit;
-    }
+	tEplKernel Ret;
+	tEplTimeruThread *pThreadData;
+	HANDLE aHandles[2];
+	BOOL fReturn;
+	LARGE_INTEGER TimeoutTime;
+	unsigned long ulEvent;
+	tEplEvent EplEvent;
+	tEplTimeruThread ThreadData;
+	tEplTimerEventArg TimerEventArg;
+
+	Ret = kEplSuccessful;
+
+	// get pointer to data
+	pThreadData = (tEplTimeruThread *) lpParameter;
+	// copy thread data
+	EPL_MEMCPY(&ThreadData, pThreadData, sizeof(ThreadData));
+	pThreadData = &ThreadData;
+
+	// leave critical section
+	LeaveCriticalSection(EplTimeruInstance_g.m_pCriticalSection);
+
+	// create waitable timer
+	aHandles[1] = CreateWaitableTimer(NULL, FALSE, NULL);
+	if (aHandles[1] == NULL) {
+		Ret = kEplTimerNoTimerCreated;
+		goto Exit;
+	}
+	// set timer
+	// set timeout interval -> needed to be negativ
+	// -> because relative timeout
+	// -> multiply by 10000 for 100 ns timebase of function
+	TimeoutTime.QuadPart = (((long long)pThreadData->ulTimeout) * -10000);
+	fReturn = SetWaitableTimer(aHandles[1],
+				   &TimeoutTime, 0, NULL, NULL, FALSE);
+	if (fReturn == 0) {
+		Ret = kEplTimerNoTimerCreated;
+		goto Exit;
+	}
+	// save delte event handle in handle array
+	aHandles[0] = pThreadData->DelteHandle;
+
+	// wait for one of the events
+	ulEvent = WaitForMultipleObjects(2, &aHandles[0], FALSE, INFINITE);
+	if (ulEvent == WAIT_OBJECT_0) {	// delte event
+
+		// close handels
+		CloseHandle(aHandles[1]);
+		// terminate thread
+		goto Exit;
+	} else if (ulEvent == (WAIT_OBJECT_0 + 1)) {	// timer event
+		// call event function
+		TimerEventArg.m_TimerHdl =
+		    (tEplTimerHdl) pThreadData->DelteHandle;
+		TimerEventArg.m_ulArg = pThreadData->TimerArgument.m_ulArg;
+
+		EplEvent.m_EventSink = pThreadData->TimerArgument.m_EventSink;
+		EplEvent.m_EventType = kEplEventTypeTimer;
+		EPL_MEMSET(&EplEvent.m_NetTime, 0x00, sizeof(tEplNetTime));
+		EplEvent.m_pArg = &TimerEventArg;
+		EplEvent.m_uiSize = sizeof(TimerEventArg);
+
+		Ret = EplEventuPost(&EplEvent);
+
+		// close handels
+		CloseHandle(aHandles[1]);
+		// terminate thread
+		goto Exit;
+
+	} else {		// error
+		ulEvent = GetLastError();
+		TRACE1("Error in WaitForMultipleObjects Errorcode: 0x%x\n",
+		       ulEvent);
+		// terminate thread
+		goto Exit;
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 // EOF
-
--- a/drivers/staging/epl/proc_fs.c
+++ b/drivers/staging/epl/proc_fs.c
@@ -91,11 +91,10 @@
 #include <linux/spinlock.h>
 
 #ifdef CONFIG_COLDFIRE
-    #include <asm/coldfire.h>
-    #include "fec.h"
+#include <asm/coldfire.h>
+#include "fec.h"
 #endif
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -113,45 +112,44 @@
 #endif
 
 #ifndef DBG_TRACE_POINTS
-#define DBG_TRACE_POINTS    23  // # of supported debug trace points
+#define DBG_TRACE_POINTS    23	// # of supported debug trace points
 #endif
 
 #ifndef DBG_TRACE_VALUES
-#define DBG_TRACE_VALUES    24 // # of supported debug trace values (size of circular buffer)
+#define DBG_TRACE_VALUES    24	// # of supported debug trace values (size of circular buffer)
 #endif
 
 //---------------------------------------------------------------------------
 // modul global types
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // local vars
 //---------------------------------------------------------------------------
 
 #ifdef _DBG_TRACE_POINTS_
-    atomic_t            aatmDbgTracePoint_l[DBG_TRACE_POINTS];
-    DWORD               adwDbgTraceValue_l[DBG_TRACE_VALUES];
-    DWORD               dwDbgTraceValueOld_l;
-    unsigned int        uiDbgTraceValuePos_l;
-    spinlock_t          spinlockDbgTraceValue_l;
-    unsigned long       ulDbTraceValueFlags_l;
+atomic_t aatmDbgTracePoint_l[DBG_TRACE_POINTS];
+DWORD adwDbgTraceValue_l[DBG_TRACE_VALUES];
+DWORD dwDbgTraceValueOld_l;
+unsigned int uiDbgTraceValuePos_l;
+spinlock_t spinlockDbgTraceValue_l;
+unsigned long ulDbTraceValueFlags_l;
 #endif
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-static  int        EplLinProcRead       (char* pcBuffer_p, char** ppcStart_p, off_t Offset_p, int nBufferSize_p, int* pEof_p, void* pData_p);
-static int EplLinProcWrite(struct file *file, const char __user *buffer, unsigned long count, void *data);
-
-void  PUBLIC  TgtDbgSignalTracePoint (BYTE bTracePointNumber_p);
-void  PUBLIC  TgtDbgPostTraceValue (DWORD dwTraceValue_p);
+static int EplLinProcRead(char *pcBuffer_p, char **ppcStart_p, off_t Offset_p,
+			  int nBufferSize_p, int *pEof_p, void *pData_p);
+static int EplLinProcWrite(struct file *file, const char __user * buffer,
+			   unsigned long count, void *data);
 
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void PUBLIC TgtDbgPostTraceValue(DWORD dwTraceValue_p);
 
 EPLDLLEXPORT DWORD PUBLIC EplIdentuGetRunningRequests(void);
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -160,35 +158,32 @@ EPLDLLEXPORT DWORD PUBLIC EplIdentuGetRu
 
 tEplKernel EplLinProcInit(void)
 {
-    struct proc_dir_entry*  pProcDirEntry;
-    pProcDirEntry = create_proc_entry (EPL_PROC_DEV_NAME, S_IRUGO, NULL);
-    if (pProcDirEntry != NULL)
-    {
-        pProcDirEntry->read_proc  = EplLinProcRead;
-        pProcDirEntry->write_proc = EplLinProcWrite;
-        pProcDirEntry->data       = NULL; // device number or something else
-
-    }
-    else
-    {
-        return kEplNoResource;
-    }
+	struct proc_dir_entry *pProcDirEntry;
+	pProcDirEntry = create_proc_entry(EPL_PROC_DEV_NAME, S_IRUGO, NULL);
+	if (pProcDirEntry != NULL) {
+		pProcDirEntry->read_proc = EplLinProcRead;
+		pProcDirEntry->write_proc = EplLinProcWrite;
+		pProcDirEntry->data = NULL;	// device number or something else
+
+	} else {
+		return kEplNoResource;
+	}
 
 #ifdef _DBG_TRACE_POINTS_
-    // initialize spinlock and circular buffer position
-    spin_lock_init(&spinlockDbgTraceValue_l);
-    uiDbgTraceValuePos_l = 0;
-    dwDbgTraceValueOld_l = 0;
+	// initialize spinlock and circular buffer position
+	spin_lock_init(&spinlockDbgTraceValue_l);
+	uiDbgTraceValuePos_l = 0;
+	dwDbgTraceValueOld_l = 0;
 #endif
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 }
 
 tEplKernel EplLinProcFree(void)
 {
-    remove_proc_entry (EPL_PROC_DEV_NAME, NULL);
+	remove_proc_entry(EPL_PROC_DEV_NAME, NULL);
 
-    return kEplSuccessful;
+	return kEplSuccessful;
 }
 
 //---------------------------------------------------------------------------
@@ -196,225 +191,219 @@ tEplKernel EplLinProcFree(void)
 //---------------------------------------------------------------------------
 
 #ifdef _DBG_TRACE_POINTS_
-void  PUBLIC  TgtDbgSignalTracePoint (
-    BYTE bTracePointNumber_p)
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p)
 {
 
-    if (bTracePointNumber_p >= (sizeof(aatmDbgTracePoint_l) / sizeof(aatmDbgTracePoint_l[0])))
-    {
-        goto Exit;
-    }
-
+	if (bTracePointNumber_p >=
+	    (sizeof(aatmDbgTracePoint_l) / sizeof(aatmDbgTracePoint_l[0]))) {
+		goto Exit;
+	}
 
-    atomic_inc (&aatmDbgTracePoint_l[bTracePointNumber_p]);
+	atomic_inc(&aatmDbgTracePoint_l[bTracePointNumber_p]);
 
-Exit:
+      Exit:
 
-    return;
+	return;
 
 }
 
-void  PUBLIC  TgtDbgPostTraceValue (DWORD dwTraceValue_p)
+void PUBLIC TgtDbgPostTraceValue(DWORD dwTraceValue_p)
 {
 
-    spin_lock_irqsave(&spinlockDbgTraceValue_l, ulDbTraceValueFlags_l);
-    if (dwDbgTraceValueOld_l != dwTraceValue_p)
-    {
-        adwDbgTraceValue_l[uiDbgTraceValuePos_l] = dwTraceValue_p;
-        uiDbgTraceValuePos_l = (uiDbgTraceValuePos_l + 1) % DBG_TRACE_VALUES;
-        dwDbgTraceValueOld_l = dwTraceValue_p;
-    }
-    spin_unlock_irqrestore(&spinlockDbgTraceValue_l, ulDbTraceValueFlags_l);
+	spin_lock_irqsave(&spinlockDbgTraceValue_l, ulDbTraceValueFlags_l);
+	if (dwDbgTraceValueOld_l != dwTraceValue_p) {
+		adwDbgTraceValue_l[uiDbgTraceValuePos_l] = dwTraceValue_p;
+		uiDbgTraceValuePos_l =
+		    (uiDbgTraceValuePos_l + 1) % DBG_TRACE_VALUES;
+		dwDbgTraceValueOld_l = dwTraceValue_p;
+	}
+	spin_unlock_irqrestore(&spinlockDbgTraceValue_l, ulDbTraceValueFlags_l);
 
-    return;
+	return;
 
 }
 #endif
 
-
 //---------------------------------------------------------------------------
 //  Read function for PROC-FS read access
 //---------------------------------------------------------------------------
 
-static  int  EplLinProcRead (
-    char* pcBuffer_p,
-    char** ppcStart_p,
-    off_t Offset_p,
-    int nBufferSize_p,
-    int* pEof_p,
-    void* pData_p)
+static int EplLinProcRead(char *pcBuffer_p,
+			  char **ppcStart_p,
+			  off_t Offset_p,
+			  int nBufferSize_p, int *pEof_p, void *pData_p)
 {
 
-int             nSize;
-int             Eof;
-tEplDllkCalStatistics* pDllkCalStats;
+	int nSize;
+	int Eof;
+	tEplDllkCalStatistics *pDllkCalStats;
 
-    nSize = 0;
-    Eof   = 0;
+	nSize = 0;
+	Eof = 0;
 
-    // count calls of this function
+	// count calls of this function
 #ifdef _DBG_TRACE_POINTS_
-    TgtDbgSignalTracePoint(0);
+	TgtDbgSignalTracePoint(0);
 #endif
 
-    //---------------------------------------------------------------
-    // generate static information
-    //---------------------------------------------------------------
-
-    // ---- Driver information ----
-    nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                       "%s    %s    (c) 2006 %s\n",
-                       EPL_PRODUCT_NAME, EPL_PRODUCT_VERSION, EPL_PRODUCT_MANUFACTURER);
+	//---------------------------------------------------------------
+	// generate static information
+	//---------------------------------------------------------------
+
+	// ---- Driver information ----
+	nSize += snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
+			  "%s    %s    (c) 2006 %s\n",
+			  EPL_PRODUCT_NAME, EPL_PRODUCT_VERSION,
+			  EPL_PRODUCT_MANUFACTURER);
+
+	//---------------------------------------------------------------
+	// generate process information
+	//---------------------------------------------------------------
+
+	// ---- EPL state ----
+	nSize += snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
+			  "NMT state:                  0x%04X\n",
+			  (WORD) EplNmtkGetNmtState());
+
+	EplDllkCalGetStatistics(&pDllkCalStats);
+
+	nSize += snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
+			  "CurAsyncTxGen=%lu CurAsyncTxNmt=%lu CurAsyncRx=%lu\nMaxAsyncTxGen=%lu MaxAsyncTxNmt=%lu MaxAsyncRx=%lu\n",
+			  pDllkCalStats->m_ulCurTxFrameCountGen,
+			  pDllkCalStats->m_ulCurTxFrameCountNmt,
+			  pDllkCalStats->m_ulCurRxFrameCount,
+			  pDllkCalStats->m_ulMaxTxFrameCountGen,
+			  pDllkCalStats->m_ulMaxTxFrameCountNmt,
+			  pDllkCalStats->m_ulMaxRxFrameCount);
 
+#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
+	// fetch running IdentRequests
+	nSize += snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
+			  "running IdentRequests:      0x%08lX\n",
+			  EplIdentuGetRunningRequests());
+
+	// fetch state of NmtMnu module
+	{
+		unsigned int uiMandatorySlaveCount;
+		unsigned int uiSignalSlaveCount;
+		WORD wFlags;
+
+		EplNmtMnuGetDiagnosticInfo(&uiMandatorySlaveCount,
+					   &uiSignalSlaveCount, &wFlags);
+
+		nSize += snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
+				  "MN  MandSlaveCount: %u  SigSlaveCount: %u  Flags: 0x%X\n",
+				  uiMandatorySlaveCount, uiSignalSlaveCount,
+				  wFlags);
 
-    //---------------------------------------------------------------
-    // generate process information
-    //---------------------------------------------------------------
+	}
+#endif
 
-    // ---- EPL state ----
-    nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                       "NMT state:                  0x%04X\n",
-                       (WORD) EplNmtkGetNmtState());
+	// ---- FEC state ----
+#ifdef CONFIG_COLDFIRE
+	{
+		// Receive the base address
+		unsigned long base_addr;
+#if (EDRV_USED_ETH_CTRL == 0)
+		// Set the base address of FEC0
+		base_addr = FEC_BASE_ADDR_FEC0;
+#else
+		// Set the base address of FEC1
+		base_addr = FEC_BASE_ADDR_FEC1;
+#endif
 
-    EplDllkCalGetStatistics(&pDllkCalStats);
+		nSize += snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
+				  "FEC_ECR = 0x%08X FEC_EIR = 0x%08X FEC_EIMR = 0x%08X\nFEC_TCR = 0x%08X FECTFSR = 0x%08X FECRFSR = 0x%08X\n",
+				  FEC_ECR(base_addr), FEC_EIR(base_addr),
+				  FEC_EIMR(base_addr), FEC_TCR(base_addr),
+				  FEC_FECTFSR(base_addr),
+				  FEC_FECRFSR(base_addr));
+	}
+#endif
 
-    nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                       "CurAsyncTxGen=%lu CurAsyncTxNmt=%lu CurAsyncRx=%lu\nMaxAsyncTxGen=%lu MaxAsyncTxNmt=%lu MaxAsyncRx=%lu\n", pDllkCalStats->m_ulCurTxFrameCountGen, pDllkCalStats->m_ulCurTxFrameCountNmt, pDllkCalStats->m_ulCurRxFrameCount, pDllkCalStats->m_ulMaxTxFrameCountGen, pDllkCalStats->m_ulMaxTxFrameCountNmt, pDllkCalStats->m_ulMaxRxFrameCount);
+	// ---- DBG: TracePoints ----
+#ifdef _DBG_TRACE_POINTS_
+	{
+		int nNum;
 
-#if (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_NMT_MN)) != 0)
-    // fetch running IdentRequests
-    nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                       "running IdentRequests:      0x%08lX\n",
-                       EplIdentuGetRunningRequests());
-
-    // fetch state of NmtMnu module
-    {
-    unsigned int    uiMandatorySlaveCount;
-    unsigned int    uiSignalSlaveCount;
-    WORD            wFlags;
-
-        EplNmtMnuGetDiagnosticInfo(&uiMandatorySlaveCount,
-                                   &uiSignalSlaveCount,
-                                   &wFlags);
-
-
-        nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                           "MN  MandSlaveCount: %u  SigSlaveCount: %u  Flags: 0x%X\n",
-                           uiMandatorySlaveCount, uiSignalSlaveCount, wFlags);
-
-    }
-#endif
-
-    // ---- FEC state ----
-    #ifdef CONFIG_COLDFIRE
-    {
-        // Receive the base address
-        unsigned long base_addr;
-        #if (EDRV_USED_ETH_CTRL == 0)
-            // Set the base address of FEC0
-            base_addr = FEC_BASE_ADDR_FEC0;
-        #else
-            // Set the base address of FEC1
-            base_addr = FEC_BASE_ADDR_FEC1;
-        #endif
-
-        nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                           "FEC_ECR = 0x%08X FEC_EIR = 0x%08X FEC_EIMR = 0x%08X\nFEC_TCR = 0x%08X FECTFSR = 0x%08X FECRFSR = 0x%08X\n",
-                           FEC_ECR(base_addr), FEC_EIR(base_addr), FEC_EIMR(base_addr), FEC_TCR(base_addr), FEC_FECTFSR(base_addr), FEC_FECRFSR(base_addr));
-    }
-    #endif
-
-
-    // ---- DBG: TracePoints ----
-    #ifdef _DBG_TRACE_POINTS_
-    {
-        int nNum;
-
-        nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                           "DbgTracePoints:\n");
-        for (nNum=0; nNum<(sizeof(aatmDbgTracePoint_l)/sizeof(atomic_t)); nNum++)
-        {
-            nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                               " TracePoint[%2d]: %d\n", (int)nNum,
-                               atomic_read(&aatmDbgTracePoint_l[nNum]));
-        }
-
-        nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                           "DbgTraceValues:\n");
-        for (nNum=0; nNum<DBG_TRACE_VALUES; nNum++)
-        {
-            if (nNum == uiDbgTraceValuePos_l)
-            {   // next value will be stored at that position
-                nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                                   "*%08lX", adwDbgTraceValue_l[nNum]);
-            }
-            else
-            {
-                nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                                   " %08lX", adwDbgTraceValue_l[nNum]);
-            }
-            if ((nNum & 0x00000007) == 0x00000007)
-            {   // 8 values printed -> end of line reached
-                nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                                   "\n");
-            }
-        }
-        if ((nNum & 0x00000007) != 0x00000007)
-        {   // number of values printed is not a multiple of 8 -> print new line
-            nSize += snprintf (pcBuffer_p + nSize, nBufferSize_p - nSize,
-                               "\n");
-        }
-    }
-    #endif
-
-
-    Eof = 1;
-    goto Exit;
+		nSize += snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
+				  "DbgTracePoints:\n");
+		for (nNum = 0;
+		     nNum < (sizeof(aatmDbgTracePoint_l) / sizeof(atomic_t));
+		     nNum++) {
+			nSize +=
+			    snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
+				     " TracePoint[%2d]: %d\n", (int)nNum,
+				     atomic_read(&aatmDbgTracePoint_l[nNum]));
+		}
+
+		nSize += snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
+				  "DbgTraceValues:\n");
+		for (nNum = 0; nNum < DBG_TRACE_VALUES; nNum++) {
+			if (nNum == uiDbgTraceValuePos_l) {	// next value will be stored at that position
+				nSize +=
+				    snprintf(pcBuffer_p + nSize,
+					     nBufferSize_p - nSize, "*%08lX",
+					     adwDbgTraceValue_l[nNum]);
+			} else {
+				nSize +=
+				    snprintf(pcBuffer_p + nSize,
+					     nBufferSize_p - nSize, " %08lX",
+					     adwDbgTraceValue_l[nNum]);
+			}
+			if ((nNum & 0x00000007) == 0x00000007) {	// 8 values printed -> end of line reached
+				nSize +=
+				    snprintf(pcBuffer_p + nSize,
+					     nBufferSize_p - nSize, "\n");
+			}
+		}
+		if ((nNum & 0x00000007) != 0x00000007) {	// number of values printed is not a multiple of 8 -> print new line
+			nSize +=
+			    snprintf(pcBuffer_p + nSize, nBufferSize_p - nSize,
+				     "\n");
+		}
+	}
+#endif
 
+	Eof = 1;
+	goto Exit;
 
-Exit:
+      Exit:
 
-    *pEof_p = Eof;
+	*pEof_p = Eof;
 
-    return (nSize);
+	return (nSize);
 
 }
 
-
 //---------------------------------------------------------------------------
 //  Write function for PROC-FS write access
 //---------------------------------------------------------------------------
 
-static int EplLinProcWrite(struct file *file, const char __user *buffer, unsigned long count, void *data)
+static int EplLinProcWrite(struct file *file, const char __user * buffer,
+			   unsigned long count, void *data)
 {
-char            abBuffer[count + 1];
-int             iErr;
-int             iVal = 0;
-tEplNmtEvent    NmtEvent;
-
-    if (count > 0)
-    {
-        iErr = copy_from_user(abBuffer, buffer, count);
-        if (iErr != 0)
-        {
-            return count;
-        }
-        abBuffer[count] = '\0';
-
-        iErr = sscanf(abBuffer, "%i", &iVal);
-    }
-    if ((iVal <= 0) || (iVal > 0x2F))
-    {
-        NmtEvent = kEplNmtEventSwReset;
-    }
-    else
-    {
-        NmtEvent = (tEplNmtEvent) iVal;
-    }
-    // execute specified NMT command on write access of /proc/epl
-    EplNmtuNmtEvent(NmtEvent);
+	char abBuffer[count + 1];
+	int iErr;
+	int iVal = 0;
+	tEplNmtEvent NmtEvent;
+
+	if (count > 0) {
+		iErr = copy_from_user(abBuffer, buffer, count);
+		if (iErr != 0) {
+			return count;
+		}
+		abBuffer[count] = '\0';
+
+		iErr = sscanf(abBuffer, "%i", &iVal);
+	}
+	if ((iVal <= 0) || (iVal > 0x2F)) {
+		NmtEvent = kEplNmtEventSwReset;
+	} else {
+		NmtEvent = (tEplNmtEvent) iVal;
+	}
+	// execute specified NMT command on write access of /proc/epl
+	EplNmtuNmtEvent(NmtEvent);
 
-    return count;
+	return count;
 }
-
-
--- a/drivers/staging/epl/SharedBuff.c
+++ b/drivers/staging/epl/SharedBuff.c
@@ -56,28 +56,28 @@
 
 #if defined(WIN32) || defined(_WIN32)
 
-    #ifdef UNDER_RTSS
-        // RTX header
-        #include <windows.h>
-        #include <process.h>
-        #include <rtapi.h>
-
-    #elif __BORLANDC__
-        // borland C header
-        #include <windows.h>
-        #include <process.h>
-
-    #elif WINCE
-        #include <windows.h>
-
-    #else
-        // MSVC needs to include windows.h at first
-        // the following defines ar necessary for function prototypes for waitable timers
-        #define _WIN32_WINDOWS 0x0401
-        #define _WIN32_WINNT   0x0400
-        #include <windows.h>
-        #include <process.h>
-    #endif
+#ifdef UNDER_RTSS
+	// RTX header
+#include <windows.h>
+#include <process.h>
+#include <rtapi.h>
+
+#elif __BORLANDC__
+	// borland C header
+#include <windows.h>
+#include <process.h>
+
+#elif WINCE
+#include <windows.h>
+
+#else
+	// MSVC needs to include windows.h at first
+	// the following defines ar necessary for function prototypes for waitable timers
+#define _WIN32_WINDOWS 0x0401
+#define _WIN32_WINNT   0x0400
+#include <windows.h>
+#include <process.h>
+#endif
 
 #endif
 
@@ -87,16 +87,13 @@
 
 // d.k. Linux kernel modules needs other header files for memcpy()
 #if (TARGET_SYSTEM == _LINUX_) && defined(__KERNEL__)
-    #include <linux/string.h>
+#include <linux/string.h>
 #else
-    #include <stdio.h>
-    #include <stdlib.h>
-    #include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
 #endif
 
-
-
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -111,82 +108,67 @@
 //  Configuration
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 //  Constant definitions
 //---------------------------------------------------------------------------
 
-#define SBC_MAGIC_ID    0x53424323              // magic ID ("SBC#")
-#define SBL_MAGIC_ID    0x53424C23              // magic ID ("SBL#")
-
-
+#define SBC_MAGIC_ID    0x53424323	// magic ID ("SBC#")
+#define SBL_MAGIC_ID    0x53424C23	// magic ID ("SBL#")
 
 //---------------------------------------------------------------------------
 //  Local types
 //---------------------------------------------------------------------------
 
 // structure to administrate circular shared buffer head
-typedef struct
-{
-    unsigned long          m_ShbCirMagicID;     // magic ID ("SBC#")
-    unsigned long          m_ulBufferTotalSize; // over-all size of complete buffer
-    unsigned long          m_ulBufferDataSize;  // size of complete data area
-    unsigned long          m_ulWrIndex;         // current write index (set bevore write)
-    unsigned long          m_ulRdIndex;         // current read index (set after read)
-    unsigned long          m_ulNumOfWriteJobs;  // number of currently (parallel running) write operations
-    unsigned long          m_ulDataInUse;       // currently used buffer size (incl. uncompleted write operations)
-    unsigned long          m_ulDataApended;     // buffer size of complete new written but not yet readable data (in case of m_ulNumOfWriteJobs>1)
-    unsigned long          m_ulBlocksApended;   // number of complete new written but not yet readable data blocks (in case of m_ulNumOfWriteJobs>1)
-    unsigned long          m_ulDataReadable;    // buffer size with readable (complete written) data
-    unsigned long          m_ulBlocksReadable;  // number of readable (complete written) data blocks
-    tShbCirSigHndlrNewData m_pfnSigHndlrNewData;// application handler to signal new data
-    unsigned int           m_fBufferLocked;     // TRUE if buffer is locked (because of pending reset request)
-    tShbCirSigHndlrReset   m_pfnSigHndlrReset;  // application handler to signal buffer reset is done
-    unsigned char          m_Data;              // start of data area (the real data size is unknown at this time)
+typedef struct {
+	unsigned long m_ShbCirMagicID;	// magic ID ("SBC#")
+	unsigned long m_ulBufferTotalSize;	// over-all size of complete buffer
+	unsigned long m_ulBufferDataSize;	// size of complete data area
+	unsigned long m_ulWrIndex;	// current write index (set bevore write)
+	unsigned long m_ulRdIndex;	// current read index (set after read)
+	unsigned long m_ulNumOfWriteJobs;	// number of currently (parallel running) write operations
+	unsigned long m_ulDataInUse;	// currently used buffer size (incl. uncompleted write operations)
+	unsigned long m_ulDataApended;	// buffer size of complete new written but not yet readable data (in case of m_ulNumOfWriteJobs>1)
+	unsigned long m_ulBlocksApended;	// number of complete new written but not yet readable data blocks (in case of m_ulNumOfWriteJobs>1)
+	unsigned long m_ulDataReadable;	// buffer size with readable (complete written) data
+	unsigned long m_ulBlocksReadable;	// number of readable (complete written) data blocks
+	tShbCirSigHndlrNewData m_pfnSigHndlrNewData;	// application handler to signal new data
+	unsigned int m_fBufferLocked;	// TRUE if buffer is locked (because of pending reset request)
+	tShbCirSigHndlrReset m_pfnSigHndlrReset;	// application handler to signal buffer reset is done
+	unsigned char m_Data;	// start of data area (the real data size is unknown at this time)
 
 } tShbCirBuff;
 
-
 // structure to administrate linear shared buffer head
-typedef struct
-{
-    unsigned int          m_ShbLinMagicID;      // magic ID ("SBL#")
-    unsigned long         m_ulBufferTotalSize;  // over-all size of complete buffer
-    unsigned long         m_ulBufferDataSize;   // size of complete data area
-    unsigned char         m_Data;               // start of data area (the real data size is unknown at this time)
+typedef struct {
+	unsigned int m_ShbLinMagicID;	// magic ID ("SBL#")
+	unsigned long m_ulBufferTotalSize;	// over-all size of complete buffer
+	unsigned long m_ulBufferDataSize;	// size of complete data area
+	unsigned char m_Data;	// start of data area (the real data size is unknown at this time)
 
 } tShbLinBuff;
 
-
 // type to save size of a single data block inside the circular shared buffer
-typedef struct
-{
-    unsigned int    m_uiFullBlockSize  :    28; // a single block must not exceed a length of 256MByte :-)
-    unsigned int    m_uiAlignFillBytes :     4;
+typedef struct {
+	unsigned int m_uiFullBlockSize:28;	// a single block must not exceed a length of 256MByte :-)
+	unsigned int m_uiAlignFillBytes:4;
 
 } tShbCirBlockSize;
 
-#define SBC_BLOCK_ALIGNMENT                  4  // alignment must *not* be lower than sizeof(tShbCirBlockSize)!
-#define SBC_MAX_BLOCK_SIZE         ((1<<28)-1)  // = (2^28 - 1) = (256MByte - 1) -> should be enought for real life :-)
+#define SBC_BLOCK_ALIGNMENT                  4	// alignment must *not* be lower than sizeof(tShbCirBlockSize)!
+#define SBC_MAX_BLOCK_SIZE         ((1<<28)-1)	// = (2^28 - 1) = (256MByte - 1) -> should be enought for real life :-)
 
 #define SBL_BLOCK_ALIGNMENT                  4
-#define SBL_MAX_BLOCK_SIZE         ((1<<28)-1)  // = (2^28 - 1) = (256MByte - 1) -> should be enought for real life :-)
-
-
+#define SBL_MAX_BLOCK_SIZE         ((1<<28)-1)	// = (2^28 - 1) = (256MByte - 1) -> should be enought for real life :-)
 
 //---------------------------------------------------------------------------
 //  Global variables
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 //  Local variables
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 //  Prototypes of internal functions
 //---------------------------------------------------------------------------
@@ -195,50 +177,41 @@ typedef struct
 //  Get pointer to Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbCirBuff*  ShbCirGetBuffer (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbCirBuff *ShbCirGetBuffer(tShbInstance pShbInstance_p)
 {
 
-tShbCirBuff*  pShbCirBuff;
+	tShbCirBuff *pShbCirBuff;
 
+	pShbCirBuff = (tShbCirBuff *) ShbIpcGetShMemPtr(pShbInstance_p);
+	ASSERT(pShbCirBuff->m_ShbCirMagicID == SBC_MAGIC_ID);
 
-    pShbCirBuff = (tShbCirBuff*) ShbIpcGetShMemPtr (pShbInstance_p);
-    ASSERT(pShbCirBuff->m_ShbCirMagicID == SBC_MAGIC_ID);
-
-    return (pShbCirBuff);
+	return (pShbCirBuff);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Get pointer to Linear Shared Buffer
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbLinBuff*  ShbLinGetBuffer (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbLinBuff *ShbLinGetBuffer(tShbInstance pShbInstance_p)
 {
 
-tShbLinBuff*  pShbLinBuff;
+	tShbLinBuff *pShbLinBuff;
 
+	pShbLinBuff = (tShbLinBuff *) ShbIpcGetShMemPtr(pShbInstance_p);
+	ASSERT(pShbLinBuff->m_ShbLinMagicID == SBL_MAGIC_ID);
 
-    pShbLinBuff = (tShbLinBuff*) ShbIpcGetShMemPtr (pShbInstance_p);
-    ASSERT(pShbLinBuff->m_ShbLinMagicID == SBL_MAGIC_ID);
-
-    return (pShbLinBuff);
+	return (pShbLinBuff);
 
 }
 
-
-
 // not inlined internal functions
-int           ShbCirSignalHandlerNewData (tShbInstance pShbInstance_p);
-void          ShbCirSignalHandlerReset   (tShbInstance pShbInstance_p, unsigned int fTimeOut_p);
+int ShbCirSignalHandlerNewData(tShbInstance pShbInstance_p);
+void ShbCirSignalHandlerReset(tShbInstance pShbInstance_p,
+			      unsigned int fTimeOut_p);
 
 #endif
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -252,40 +225,32 @@ void          ShbCirSignalHandlerReset  
 //  Initialize Shared Buffer Module
 //---------------------------------------------------------------------------
 
-tShbError  ShbInit (void)
+tShbError ShbInit(void)
 {
 
-tShbError  ShbError;
-
+	tShbError ShbError;
 
-    ShbError = ShbIpcInit();
+	ShbError = ShbIpcInit();
 
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Deinitialize Shared Buffer Module
 //---------------------------------------------------------------------------
 
-tShbError  ShbExit (void)
+tShbError ShbExit(void)
 {
 
-tShbError  ShbError;
+	tShbError ShbError;
 
+	ShbError = ShbIpcExit();
 
-    ShbError = ShbIpcExit();
-
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
-
-
 //-------------------------------------------------------------------------//
 //                                                                         //
 //          C i r c u l a r   S h a r e d   B u f f e r                    //
@@ -296,128 +261,109 @@ tShbError  ShbError;
 //  Allocate Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-tShbError  ShbCirAllocBuffer (
-    unsigned long ulBufferSize_p,
-    const char* pszBufferID_p,
-    tShbInstance* ppShbInstance_p,
-    unsigned int* pfShbNewCreated_p)
-{
-
-tShbInstance   pShbInstance;
-tShbCirBuff*   pShbCirBuff;
-unsigned int   fShbNewCreated;
-unsigned long  ulBufferDataSize;
-unsigned long  ulBufferTotalSize;
-tShbError      ShbError;
-
-
-    // check arguments
-    if ((ulBufferSize_p == 0) || (ppShbInstance_p == NULL))
-    {
-        return (kShbInvalidArg);
-    }
-
-
-    // calculate length of memory to allocate
-    ulBufferDataSize  = (ulBufferSize_p + (SBC_BLOCK_ALIGNMENT-1)) & ~(SBC_BLOCK_ALIGNMENT-1);
-    ulBufferTotalSize = ulBufferDataSize + sizeof(tShbCirBuff);
-
-    // allocate a new or open an existing shared buffer
-    ShbError = ShbIpcAllocBuffer (ulBufferTotalSize, pszBufferID_p,
-                                  &pShbInstance, &fShbNewCreated);
-    if (ShbError != kShbOk)
-    {
-        goto Exit;
-    }
-
-    if (pShbInstance == NULL)
-    {
-        ShbError = kShbOutOfMem;
-        goto Exit;
-    }
-
-
-    // get pointer to shared buffer
-    pShbCirBuff = (tShbCirBuff*) ShbIpcGetShMemPtr (pShbInstance);
-
-    // if the shared buffer was new created, than this process has
-    // to initialize it, otherwise the buffer is already in use
-    // and *must not* be reseted
-    if ( fShbNewCreated )
-    {
-        #ifndef NDEBUG
-        {
-            memset (pShbCirBuff, 0xCC, ulBufferTotalSize);
-        }
-        #endif
-
-
-        pShbCirBuff->m_ShbCirMagicID      = SBC_MAGIC_ID;
-        pShbCirBuff->m_ulBufferTotalSize  = ulBufferTotalSize;
-        pShbCirBuff->m_ulBufferDataSize   = ulBufferDataSize;
-        pShbCirBuff->m_ulWrIndex          = 0;
-        pShbCirBuff->m_ulRdIndex          = 0;
-        pShbCirBuff->m_ulNumOfWriteJobs   = 0;
-        pShbCirBuff->m_ulDataInUse        = 0;
-        pShbCirBuff->m_ulDataApended      = 0;
-        pShbCirBuff->m_ulBlocksApended    = 0;
-        pShbCirBuff->m_ulDataReadable     = 0;
-        pShbCirBuff->m_ulBlocksReadable   = 0;
-        pShbCirBuff->m_pfnSigHndlrNewData = NULL;
-        pShbCirBuff->m_fBufferLocked      = FALSE;
-        pShbCirBuff->m_pfnSigHndlrReset   = NULL;
-    }
-    else
-    {
-        if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-        {
-            ShbError = kShbInvalidBufferType;
-            goto Exit;
-        }
-    }
+tShbError ShbCirAllocBuffer(unsigned long ulBufferSize_p,
+			    const char *pszBufferID_p,
+			    tShbInstance * ppShbInstance_p,
+			    unsigned int *pfShbNewCreated_p)
+{
+
+	tShbInstance pShbInstance;
+	tShbCirBuff *pShbCirBuff;
+	unsigned int fShbNewCreated;
+	unsigned long ulBufferDataSize;
+	unsigned long ulBufferTotalSize;
+	tShbError ShbError;
+
+	// check arguments
+	if ((ulBufferSize_p == 0) || (ppShbInstance_p == NULL)) {
+		return (kShbInvalidArg);
+	}
+
+	// calculate length of memory to allocate
+	ulBufferDataSize =
+	    (ulBufferSize_p +
+	     (SBC_BLOCK_ALIGNMENT - 1)) & ~(SBC_BLOCK_ALIGNMENT - 1);
+	ulBufferTotalSize = ulBufferDataSize + sizeof(tShbCirBuff);
+
+	// allocate a new or open an existing shared buffer
+	ShbError = ShbIpcAllocBuffer(ulBufferTotalSize, pszBufferID_p,
+				     &pShbInstance, &fShbNewCreated);
+	if (ShbError != kShbOk) {
+		goto Exit;
+	}
+
+	if (pShbInstance == NULL) {
+		ShbError = kShbOutOfMem;
+		goto Exit;
+	}
+
+	// get pointer to shared buffer
+	pShbCirBuff = (tShbCirBuff *) ShbIpcGetShMemPtr(pShbInstance);
+
+	// if the shared buffer was new created, than this process has
+	// to initialize it, otherwise the buffer is already in use
+	// and *must not* be reseted
+	if (fShbNewCreated) {
+#ifndef NDEBUG
+		{
+			memset(pShbCirBuff, 0xCC, ulBufferTotalSize);
+		}
+#endif
 
+		pShbCirBuff->m_ShbCirMagicID = SBC_MAGIC_ID;
+		pShbCirBuff->m_ulBufferTotalSize = ulBufferTotalSize;
+		pShbCirBuff->m_ulBufferDataSize = ulBufferDataSize;
+		pShbCirBuff->m_ulWrIndex = 0;
+		pShbCirBuff->m_ulRdIndex = 0;
+		pShbCirBuff->m_ulNumOfWriteJobs = 0;
+		pShbCirBuff->m_ulDataInUse = 0;
+		pShbCirBuff->m_ulDataApended = 0;
+		pShbCirBuff->m_ulBlocksApended = 0;
+		pShbCirBuff->m_ulDataReadable = 0;
+		pShbCirBuff->m_ulBlocksReadable = 0;
+		pShbCirBuff->m_pfnSigHndlrNewData = NULL;
+		pShbCirBuff->m_fBufferLocked = FALSE;
+		pShbCirBuff->m_pfnSigHndlrReset = NULL;
+	} else {
+		if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+			ShbError = kShbInvalidBufferType;
+			goto Exit;
+		}
+	}
 
-Exit:
+      Exit:
 
-    *ppShbInstance_p   = pShbInstance;
-    *pfShbNewCreated_p = fShbNewCreated;
+	*ppShbInstance_p = pShbInstance;
+	*pfShbNewCreated_p = fShbNewCreated;
 
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Release Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-tShbError  ShbCirReleaseBuffer (
-    tShbInstance pShbInstance_p)
+tShbError ShbCirReleaseBuffer(tShbInstance pShbInstance_p)
 {
 
-tShbError  ShbError;
-
+	tShbError ShbError;
 
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        ShbError = kShbOk;
-        goto Exit;
-    }
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		ShbError = kShbOk;
+		goto Exit;
+	}
 
+	ShbError = ShbIpcReleaseBuffer(pShbInstance_p);
 
-    ShbError = ShbIpcReleaseBuffer (pShbInstance_p);
+      Exit:
 
-
-Exit:
-
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-#endif  // !defined(INLINE_ENABLED)
+#endif // !defined(INLINE_ENABLED)
 
 #if (!defined(SHAREDBUFF_INLINED)) || defined(INLINE_ENABLED)
 
@@ -425,895 +371,797 @@ Exit:
 //  Reset Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbCirResetBuffer (
-    tShbInstance pShbInstance_p,
-    unsigned long ulTimeOut_p,
-    tShbCirSigHndlrReset pfnSignalHandlerReset_p)
-{
-
-tShbCirBuff*   pShbCirBuff;
-unsigned long  ulNumOfWriteJobs = 0;  // d.k. GCC complains about uninitialized variable otherwise
-tShbError      ShbError;
-
-
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-
-
-    pShbCirBuff = ShbCirGetBuffer (pShbInstance_p);
-    ShbError    = kShbOk;
-
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
-
-    // start reset job by setting request request in buffer header
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        if ( !pShbCirBuff->m_fBufferLocked )
-        {
-            ulNumOfWriteJobs = pShbCirBuff->m_ulNumOfWriteJobs;
-
-            pShbCirBuff->m_fBufferLocked    = TRUE;
-            pShbCirBuff->m_pfnSigHndlrReset = pfnSignalHandlerReset_p;
-        }
-        else
-        {
-            ShbError = kShbAlreadyReseting;
-        }
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
-
-    if (ShbError != kShbOk)
-    {
-        goto Exit;
-    }
-
-
-    // if there is currently no running write operation then reset buffer
-    // immediately, otherwise wait until the last write job is ready by
-    // starting a signal process
-    if (ulNumOfWriteJobs == 0)
-    {
-        // there is currently no running write operation
-        // -> reset buffer immediately
-        ShbCirSignalHandlerReset (pShbInstance_p, FALSE);
-        ShbError = kShbOk;
-    }
-    else
-    {
-        // there is currently at least one running write operation
-        // -> starting signal process to wait until the last write job is ready
-        ShbError = ShbIpcStartSignalingJobReady (pShbInstance_p, ulTimeOut_p, ShbCirSignalHandlerReset);
-    }
+INLINE_FUNCTION tShbError ShbCirResetBuffer(tShbInstance pShbInstance_p,
+					    unsigned long ulTimeOut_p,
+					    tShbCirSigHndlrReset
+					    pfnSignalHandlerReset_p)
+{
+
+	tShbCirBuff *pShbCirBuff;
+	unsigned long ulNumOfWriteJobs = 0;	// d.k. GCC complains about uninitialized variable otherwise
+	tShbError ShbError;
+
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	ShbError = kShbOk;
+
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	// start reset job by setting request request in buffer header
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		if (!pShbCirBuff->m_fBufferLocked) {
+			ulNumOfWriteJobs = pShbCirBuff->m_ulNumOfWriteJobs;
+
+			pShbCirBuff->m_fBufferLocked = TRUE;
+			pShbCirBuff->m_pfnSigHndlrReset =
+			    pfnSignalHandlerReset_p;
+		} else {
+			ShbError = kShbAlreadyReseting;
+		}
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
+
+	if (ShbError != kShbOk) {
+		goto Exit;
+	}
+
+	// if there is currently no running write operation then reset buffer
+	// immediately, otherwise wait until the last write job is ready by
+	// starting a signal process
+	if (ulNumOfWriteJobs == 0) {
+		// there is currently no running write operation
+		// -> reset buffer immediately
+		ShbCirSignalHandlerReset(pShbInstance_p, FALSE);
+		ShbError = kShbOk;
+	} else {
+		// there is currently at least one running write operation
+		// -> starting signal process to wait until the last write job is ready
+		ShbError =
+		    ShbIpcStartSignalingJobReady(pShbInstance_p, ulTimeOut_p,
+						 ShbCirSignalHandlerReset);
+	}
 
+      Exit:
 
-Exit:
-
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Write data block to Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbCirWriteDataBlock (
-    tShbInstance pShbInstance_p,
-    const void* pSrcDataBlock_p,
-    unsigned long ulDataBlockSize_p)
-{
-
-tShbCirBuff*      pShbCirBuff;
-tShbCirBlockSize  ShbCirBlockSize;
-unsigned int      uiFullBlockSize;
-unsigned int      uiAlignFillBytes;
-unsigned char*    pShbCirDataPtr;
-unsigned char*    pScrDataPtr;
-unsigned long     ulDataSize;
-unsigned long     ulChunkSize;
-unsigned long     ulWrIndex = 0;  // d.k. GCC complains about uninitialized variable otherwise
-unsigned int      fSignalNewData;
-unsigned int      fSignalReset;
-tShbError         ShbError;
-tShbError         ShbError2;
-int               fRes;
-
-
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-
-    if ((pSrcDataBlock_p == NULL) || (ulDataBlockSize_p == 0))
-    {
-        // nothing to do here
-        ShbError = kShbOk;
-        goto Exit;
-    }
-
-    if (ulDataBlockSize_p > SBC_MAX_BLOCK_SIZE)
-    {
-        ShbError = kShbExceedDataSizeLimit;
-        goto Exit;
-    }
-
-
-    pShbCirBuff    = ShbCirGetBuffer (pShbInstance_p);
-    pScrDataPtr    = (unsigned char*)pSrcDataBlock_p;
-    fSignalNewData = FALSE;
-    fSignalReset   = FALSE;
-    ShbError       = kShbOk;
-
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
-
-    // calculate data block size in circular buffer
-    ulDataSize       = (ulDataBlockSize_p + (SBC_BLOCK_ALIGNMENT-1)) & ~(SBC_BLOCK_ALIGNMENT-1);
-    uiFullBlockSize  = ulDataSize + sizeof(tShbCirBlockSize);   // data size + header
-    uiAlignFillBytes = ulDataSize - ulDataBlockSize_p;
-
-    ShbCirBlockSize.m_uiFullBlockSize  = uiFullBlockSize;
-    ShbCirBlockSize.m_uiAlignFillBytes = uiAlignFillBytes;
-
-
-    // reserve the needed memory for the write operation to do now
-    // and make necessary adjustments in the circular buffer header
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        // check if there is sufficient memory available to store
-        // the new data
-        fRes = uiFullBlockSize <= (pShbCirBuff->m_ulBufferDataSize - pShbCirBuff->m_ulDataInUse);
-        if ( fRes )
-        {
-            // set write pointer for the write operation to do now
-            // to the current write pointer of the circular buffer
-            ulWrIndex = pShbCirBuff->m_ulWrIndex;
-
-            // reserve the needed memory for the write operation to do now
-            pShbCirBuff->m_ulDataInUse += uiFullBlockSize;
-
-            // set new write pointer behind the reserved memory
-            // for the write operation to do now
-            pShbCirBuff->m_ulWrIndex += uiFullBlockSize;
-            pShbCirBuff->m_ulWrIndex %= pShbCirBuff->m_ulBufferDataSize;
-
-            // increment number of currently (parallel running)
-            // write operations
-            pShbCirBuff->m_ulNumOfWriteJobs++;
-        }
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
-
-
-    if ( !fRes )
-    {
-        ShbError = kShbBufferFull;
-        goto Exit;
-    }
-
-
-    // copy the data to the circular buffer
-    // (the copy process itself will be done outside of any
-    // critical/locked section)
-    pShbCirDataPtr = &pShbCirBuff->m_Data;          // ptr to start of data area
-
-    // write real size of current block (incl. alignment fill bytes)
-    *(tShbCirBlockSize*)(pShbCirDataPtr + ulWrIndex) = ShbCirBlockSize;
-    ulWrIndex += sizeof(tShbCirBlockSize);
-    ulWrIndex %= pShbCirBuff->m_ulBufferDataSize;
-
-     if (ulWrIndex + ulDataBlockSize_p <= pShbCirBuff->m_ulBufferDataSize)
-    {
-        // linear write operation
-        memcpy (pShbCirDataPtr + ulWrIndex, pScrDataPtr, ulDataBlockSize_p);
-    }
-    else
-    {
-        // wrap-around write operation
-        ulChunkSize = pShbCirBuff->m_ulBufferDataSize - ulWrIndex;
-        memcpy (pShbCirDataPtr + ulWrIndex, pScrDataPtr, ulChunkSize);
-        memcpy (pShbCirDataPtr, pScrDataPtr + ulChunkSize, ulDataBlockSize_p - ulChunkSize);
-    }
-
-
-    // adjust header information for circular buffer with properties
-    // of the wiritten data block
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        pShbCirBuff->m_ulDataApended   += uiFullBlockSize;
-        pShbCirBuff->m_ulBlocksApended ++;
-
-        // decrement number of currently (parallel running) write operations
-        if ( !--pShbCirBuff->m_ulNumOfWriteJobs )
-        {
-            // if there is no other write process running then
-            // set new size of readable (complete written) data and
-            // adjust number of readable blocks
-            pShbCirBuff->m_ulDataReadable   += pShbCirBuff->m_ulDataApended;
-            pShbCirBuff->m_ulBlocksReadable += pShbCirBuff->m_ulBlocksApended;
-
-            pShbCirBuff->m_ulDataApended   = 0;
-            pShbCirBuff->m_ulBlocksApended = 0;
-
-            fSignalNewData = TRUE;
-            fSignalReset   = pShbCirBuff->m_fBufferLocked;
-        }
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
-
-
-    // signal new data event to a potentially reading application
-    if ( fSignalNewData )
-    {
-        ShbError2 = ShbIpcSignalNewData (pShbInstance_p);
-        if (ShbError == kShbOk)
-        {
-            ShbError = ShbError2;
-        }
-    }
-
-    // signal that the last write job has been finished to allow
-    // a waiting application to reset the buffer now
-    if ( fSignalReset )
-    {
-        ShbError2 = ShbIpcSignalJobReady (pShbInstance_p);
-        if (ShbError == kShbOk)
-        {
-            ShbError = ShbError2;
-        }
-    }
+INLINE_FUNCTION tShbError ShbCirWriteDataBlock(tShbInstance pShbInstance_p,
+					       const void *pSrcDataBlock_p,
+					       unsigned long ulDataBlockSize_p)
+{
+
+	tShbCirBuff *pShbCirBuff;
+	tShbCirBlockSize ShbCirBlockSize;
+	unsigned int uiFullBlockSize;
+	unsigned int uiAlignFillBytes;
+	unsigned char *pShbCirDataPtr;
+	unsigned char *pScrDataPtr;
+	unsigned long ulDataSize;
+	unsigned long ulChunkSize;
+	unsigned long ulWrIndex = 0;	// d.k. GCC complains about uninitialized variable otherwise
+	unsigned int fSignalNewData;
+	unsigned int fSignalReset;
+	tShbError ShbError;
+	tShbError ShbError2;
+	int fRes;
+
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+
+	if ((pSrcDataBlock_p == NULL) || (ulDataBlockSize_p == 0)) {
+		// nothing to do here
+		ShbError = kShbOk;
+		goto Exit;
+	}
+
+	if (ulDataBlockSize_p > SBC_MAX_BLOCK_SIZE) {
+		ShbError = kShbExceedDataSizeLimit;
+		goto Exit;
+	}
+
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	pScrDataPtr = (unsigned char *)pSrcDataBlock_p;
+	fSignalNewData = FALSE;
+	fSignalReset = FALSE;
+	ShbError = kShbOk;
+
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	// calculate data block size in circular buffer
+	ulDataSize =
+	    (ulDataBlockSize_p +
+	     (SBC_BLOCK_ALIGNMENT - 1)) & ~(SBC_BLOCK_ALIGNMENT - 1);
+	uiFullBlockSize = ulDataSize + sizeof(tShbCirBlockSize);	// data size + header
+	uiAlignFillBytes = ulDataSize - ulDataBlockSize_p;
+
+	ShbCirBlockSize.m_uiFullBlockSize = uiFullBlockSize;
+	ShbCirBlockSize.m_uiAlignFillBytes = uiAlignFillBytes;
+
+	// reserve the needed memory for the write operation to do now
+	// and make necessary adjustments in the circular buffer header
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		// check if there is sufficient memory available to store
+		// the new data
+		fRes =
+		    uiFullBlockSize <=
+		    (pShbCirBuff->m_ulBufferDataSize -
+		     pShbCirBuff->m_ulDataInUse);
+		if (fRes) {
+			// set write pointer for the write operation to do now
+			// to the current write pointer of the circular buffer
+			ulWrIndex = pShbCirBuff->m_ulWrIndex;
+
+			// reserve the needed memory for the write operation to do now
+			pShbCirBuff->m_ulDataInUse += uiFullBlockSize;
+
+			// set new write pointer behind the reserved memory
+			// for the write operation to do now
+			pShbCirBuff->m_ulWrIndex += uiFullBlockSize;
+			pShbCirBuff->m_ulWrIndex %=
+			    pShbCirBuff->m_ulBufferDataSize;
+
+			// increment number of currently (parallel running)
+			// write operations
+			pShbCirBuff->m_ulNumOfWriteJobs++;
+		}
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
+
+	if (!fRes) {
+		ShbError = kShbBufferFull;
+		goto Exit;
+	}
+
+	// copy the data to the circular buffer
+	// (the copy process itself will be done outside of any
+	// critical/locked section)
+	pShbCirDataPtr = &pShbCirBuff->m_Data;	// ptr to start of data area
+
+	// write real size of current block (incl. alignment fill bytes)
+	*(tShbCirBlockSize *) (pShbCirDataPtr + ulWrIndex) = ShbCirBlockSize;
+	ulWrIndex += sizeof(tShbCirBlockSize);
+	ulWrIndex %= pShbCirBuff->m_ulBufferDataSize;
+
+	if (ulWrIndex + ulDataBlockSize_p <= pShbCirBuff->m_ulBufferDataSize) {
+		// linear write operation
+		memcpy(pShbCirDataPtr + ulWrIndex, pScrDataPtr,
+		       ulDataBlockSize_p);
+	} else {
+		// wrap-around write operation
+		ulChunkSize = pShbCirBuff->m_ulBufferDataSize - ulWrIndex;
+		memcpy(pShbCirDataPtr + ulWrIndex, pScrDataPtr, ulChunkSize);
+		memcpy(pShbCirDataPtr, pScrDataPtr + ulChunkSize,
+		       ulDataBlockSize_p - ulChunkSize);
+	}
+
+	// adjust header information for circular buffer with properties
+	// of the wiritten data block
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		pShbCirBuff->m_ulDataApended += uiFullBlockSize;
+		pShbCirBuff->m_ulBlocksApended++;
+
+		// decrement number of currently (parallel running) write operations
+		if (!--pShbCirBuff->m_ulNumOfWriteJobs) {
+			// if there is no other write process running then
+			// set new size of readable (complete written) data and
+			// adjust number of readable blocks
+			pShbCirBuff->m_ulDataReadable +=
+			    pShbCirBuff->m_ulDataApended;
+			pShbCirBuff->m_ulBlocksReadable +=
+			    pShbCirBuff->m_ulBlocksApended;
+
+			pShbCirBuff->m_ulDataApended = 0;
+			pShbCirBuff->m_ulBlocksApended = 0;
+
+			fSignalNewData = TRUE;
+			fSignalReset = pShbCirBuff->m_fBufferLocked;
+		}
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
+
+	// signal new data event to a potentially reading application
+	if (fSignalNewData) {
+		ShbError2 = ShbIpcSignalNewData(pShbInstance_p);
+		if (ShbError == kShbOk) {
+			ShbError = ShbError2;
+		}
+	}
+	// signal that the last write job has been finished to allow
+	// a waiting application to reset the buffer now
+	if (fSignalReset) {
+		ShbError2 = ShbIpcSignalJobReady(pShbInstance_p);
+		if (ShbError == kShbOk) {
+			ShbError = ShbError2;
+		}
+	}
 
+      Exit:
 
-Exit:
-
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Allocate block within the Circular Shared Buffer for chunk writing
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbCirAllocDataBlock (
-    tShbInstance pShbInstance_p,
-    tShbCirChunk* pShbCirChunk_p,
-    unsigned long ulDataBufferSize_p)
-{
-
-tShbCirBuff*      pShbCirBuff;
-tShbCirBlockSize  ShbCirBlockSize;
-unsigned int      uiFullBlockSize;
-unsigned int      uiAlignFillBytes;
-unsigned char*    pShbCirDataPtr;
-unsigned long     ulDataSize;
-unsigned long     ulWrIndex = 0;  // d.k. GCC complains about uninitialized variable otherwise
-tShbError         ShbError;
-int               fRes;
-
-
-    // check arguments
-    if ((pShbInstance_p == NULL) || (pShbCirChunk_p == NULL))
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-
-    if (ulDataBufferSize_p == 0)
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-
-    if (ulDataBufferSize_p > SBC_MAX_BLOCK_SIZE)
-    {
-        ShbError = kShbExceedDataSizeLimit;
-        goto Exit;
-    }
-
-
-    pShbCirBuff = ShbCirGetBuffer (pShbInstance_p);
-    ShbError    = kShbOk;
-
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
-
-    // calculate data block size in circular buffer
-    ulDataSize       = (ulDataBufferSize_p + (SBC_BLOCK_ALIGNMENT-1)) & ~(SBC_BLOCK_ALIGNMENT-1);
-    uiFullBlockSize  = ulDataSize + sizeof(tShbCirBlockSize);   // data size + header
-    uiAlignFillBytes = ulDataSize - ulDataBufferSize_p;
-
-    ShbCirBlockSize.m_uiFullBlockSize  = uiFullBlockSize;
-    ShbCirBlockSize.m_uiAlignFillBytes = uiAlignFillBytes;
-
-
-    // reserve the needed memory for the write operation to do now
-    // and make necessary adjustments in the circular buffer header
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        // check if there is sufficient memory available to store
-        // the new data
-        fRes = (uiFullBlockSize <= (pShbCirBuff->m_ulBufferDataSize - pShbCirBuff->m_ulDataInUse));
-        if ( fRes )
-        {
-            // set write pointer for the write operation to do now
-            // to the current write pointer of the circular buffer
-            ulWrIndex = pShbCirBuff->m_ulWrIndex;
-
-            // reserve the needed memory for the write operation to do now
-            pShbCirBuff->m_ulDataInUse += uiFullBlockSize;
-
-            // set new write pointer behind the reserved memory
-            // for the write operation to do now
-            pShbCirBuff->m_ulWrIndex += uiFullBlockSize;
-            pShbCirBuff->m_ulWrIndex %= pShbCirBuff->m_ulBufferDataSize;
-
-            // increment number of currently (parallel running)
-            // write operations
-            pShbCirBuff->m_ulNumOfWriteJobs++;
-        }
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
-
-
-    if ( !fRes )
-    {
-        ShbError = kShbBufferFull;
-        goto Exit;
-    }
-
-
-    // setup header information for allocated buffer
-    pShbCirDataPtr = &pShbCirBuff->m_Data;          // ptr to start of data area
-
-    // write real size of current block (incl. alignment fill bytes)
-    *(tShbCirBlockSize*)(pShbCirDataPtr + ulWrIndex) = ShbCirBlockSize;
-    ulWrIndex += sizeof(tShbCirBlockSize);
-    ulWrIndex %= pShbCirBuff->m_ulBufferDataSize;
-
-    // setup chunk descriptor
-    pShbCirChunk_p->m_uiFullBlockSize  = uiFullBlockSize;
-    pShbCirChunk_p->m_ulAvailableSize  = ulDataBufferSize_p;
-    pShbCirChunk_p->m_ulWrIndex        = ulWrIndex;
-    pShbCirChunk_p->m_fBufferCompleted = FALSE;
+INLINE_FUNCTION tShbError ShbCirAllocDataBlock(tShbInstance pShbInstance_p,
+					       tShbCirChunk * pShbCirChunk_p,
+					       unsigned long ulDataBufferSize_p)
+{
+
+	tShbCirBuff *pShbCirBuff;
+	tShbCirBlockSize ShbCirBlockSize;
+	unsigned int uiFullBlockSize;
+	unsigned int uiAlignFillBytes;
+	unsigned char *pShbCirDataPtr;
+	unsigned long ulDataSize;
+	unsigned long ulWrIndex = 0;	// d.k. GCC complains about uninitialized variable otherwise
+	tShbError ShbError;
+	int fRes;
+
+	// check arguments
+	if ((pShbInstance_p == NULL) || (pShbCirChunk_p == NULL)) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+
+	if (ulDataBufferSize_p == 0) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+
+	if (ulDataBufferSize_p > SBC_MAX_BLOCK_SIZE) {
+		ShbError = kShbExceedDataSizeLimit;
+		goto Exit;
+	}
+
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	ShbError = kShbOk;
+
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	// calculate data block size in circular buffer
+	ulDataSize =
+	    (ulDataBufferSize_p +
+	     (SBC_BLOCK_ALIGNMENT - 1)) & ~(SBC_BLOCK_ALIGNMENT - 1);
+	uiFullBlockSize = ulDataSize + sizeof(tShbCirBlockSize);	// data size + header
+	uiAlignFillBytes = ulDataSize - ulDataBufferSize_p;
+
+	ShbCirBlockSize.m_uiFullBlockSize = uiFullBlockSize;
+	ShbCirBlockSize.m_uiAlignFillBytes = uiAlignFillBytes;
+
+	// reserve the needed memory for the write operation to do now
+	// and make necessary adjustments in the circular buffer header
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		// check if there is sufficient memory available to store
+		// the new data
+		fRes =
+		    (uiFullBlockSize <=
+		     (pShbCirBuff->m_ulBufferDataSize -
+		      pShbCirBuff->m_ulDataInUse));
+		if (fRes) {
+			// set write pointer for the write operation to do now
+			// to the current write pointer of the circular buffer
+			ulWrIndex = pShbCirBuff->m_ulWrIndex;
+
+			// reserve the needed memory for the write operation to do now
+			pShbCirBuff->m_ulDataInUse += uiFullBlockSize;
+
+			// set new write pointer behind the reserved memory
+			// for the write operation to do now
+			pShbCirBuff->m_ulWrIndex += uiFullBlockSize;
+			pShbCirBuff->m_ulWrIndex %=
+			    pShbCirBuff->m_ulBufferDataSize;
+
+			// increment number of currently (parallel running)
+			// write operations
+			pShbCirBuff->m_ulNumOfWriteJobs++;
+		}
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
+
+	if (!fRes) {
+		ShbError = kShbBufferFull;
+		goto Exit;
+	}
+
+	// setup header information for allocated buffer
+	pShbCirDataPtr = &pShbCirBuff->m_Data;	// ptr to start of data area
+
+	// write real size of current block (incl. alignment fill bytes)
+	*(tShbCirBlockSize *) (pShbCirDataPtr + ulWrIndex) = ShbCirBlockSize;
+	ulWrIndex += sizeof(tShbCirBlockSize);
+	ulWrIndex %= pShbCirBuff->m_ulBufferDataSize;
+
+	// setup chunk descriptor
+	pShbCirChunk_p->m_uiFullBlockSize = uiFullBlockSize;
+	pShbCirChunk_p->m_ulAvailableSize = ulDataBufferSize_p;
+	pShbCirChunk_p->m_ulWrIndex = ulWrIndex;
+	pShbCirChunk_p->m_fBufferCompleted = FALSE;
 
+      Exit:
 
-Exit:
-
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Write data chunk into an allocated buffer of the Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbCirWriteDataChunk (
-    tShbInstance pShbInstance_p,
-    tShbCirChunk* pShbCirChunk_p,
-    const void* pSrcDataChunk_p,
-    unsigned long ulDataChunkSize_p,
-    unsigned int* pfBufferCompleted_p)
-{
-
-tShbCirBuff*    pShbCirBuff;
-unsigned char*  pShbCirDataPtr;
-unsigned char*  pScrDataPtr;
-unsigned long   ulSubChunkSize;
-unsigned long   ulWrIndex;
-unsigned int    fBufferCompleted;
-unsigned int    fSignalNewData;
-unsigned int    fSignalReset;
-tShbError       ShbError;
-tShbError       ShbError2;
-
-
-    // check arguments
-    if ((pShbInstance_p == NULL) || (pShbCirChunk_p == NULL) || (pfBufferCompleted_p == NULL))
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-
-    if ((pSrcDataChunk_p == NULL) || (ulDataChunkSize_p == 0))
-    {
-        // nothing to do here
-        ShbError = kShbOk;
-        goto Exit;
-    }
-
-    if ( pShbCirChunk_p->m_fBufferCompleted )
-    {
-        ShbError = kShbBufferAlreadyCompleted;
-        goto Exit;
-    }
-
-    if (ulDataChunkSize_p > pShbCirChunk_p->m_ulAvailableSize)
-    {
-        ShbError = kShbExceedDataSizeLimit;
-        goto Exit;
-    }
-
-
-    pShbCirBuff    = ShbCirGetBuffer (pShbInstance_p);
-    pScrDataPtr    = (unsigned char*)pSrcDataChunk_p;
-    fSignalNewData = FALSE;
-    fSignalReset   = FALSE;
-    ShbError       = kShbOk;
-
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
-
-    ulWrIndex = pShbCirChunk_p->m_ulWrIndex;
-
-
-    // copy the data to the circular buffer
-    // (the copy process itself will be done outside of any
-    // critical/locked section)
-    pShbCirDataPtr = &pShbCirBuff->m_Data;          // ptr to start of data area
-
-
-    if (ulWrIndex + ulDataChunkSize_p <= pShbCirBuff->m_ulBufferDataSize)
-    {
-        // linear write operation
-        memcpy (pShbCirDataPtr + ulWrIndex, pScrDataPtr, ulDataChunkSize_p);
-    }
-    else
-    {
-        // wrap-around write operation
-        ulSubChunkSize = pShbCirBuff->m_ulBufferDataSize - ulWrIndex;
-        memcpy (pShbCirDataPtr + ulWrIndex, pScrDataPtr, ulSubChunkSize);
-        memcpy (pShbCirDataPtr, pScrDataPtr + ulSubChunkSize, ulDataChunkSize_p - ulSubChunkSize);
-    }
-
-
-    // adjust chunk descriptor
-    ulWrIndex += ulDataChunkSize_p;
-    ulWrIndex %= pShbCirBuff->m_ulBufferDataSize;
-
-    pShbCirChunk_p->m_ulAvailableSize -= ulDataChunkSize_p;
-    pShbCirChunk_p->m_ulWrIndex        = ulWrIndex;
-
-    fBufferCompleted = (pShbCirChunk_p->m_ulAvailableSize == 0);
-    pShbCirChunk_p->m_fBufferCompleted = fBufferCompleted;
-
-
-    // if the complete allocated buffer is filled with data then
-    // adjust header information for circular buffer with properties
-    // of the wiritten data block
-    if ( fBufferCompleted )
-    {
-        ShbIpcEnterAtomicSection (pShbInstance_p);
-        {
-            pShbCirBuff->m_ulDataApended   += pShbCirChunk_p->m_uiFullBlockSize;
-            pShbCirBuff->m_ulBlocksApended ++;
-
-            // decrement number of currently (parallel running) write operations
-            if ( !--pShbCirBuff->m_ulNumOfWriteJobs )
-            {
-                // if there is no other write process running then
-                // set new size of readable (complete written) data and
-                // adjust number of readable blocks
-                pShbCirBuff->m_ulDataReadable   += pShbCirBuff->m_ulDataApended;
-                pShbCirBuff->m_ulBlocksReadable += pShbCirBuff->m_ulBlocksApended;
-
-                pShbCirBuff->m_ulDataApended   = 0;
-                pShbCirBuff->m_ulBlocksApended = 0;
-
-                fSignalNewData = TRUE;
-                fSignalReset   = pShbCirBuff->m_fBufferLocked;
-            }
-        }
-        ShbIpcLeaveAtomicSection (pShbInstance_p);
-    }
-
-
-    // signal new data event to a potentially reading application
-    if ( fSignalNewData )
-    {
-        ShbError2 = ShbIpcSignalNewData (pShbInstance_p);
-        if (ShbError == kShbOk)
-        {
-            ShbError = ShbError2;
-        }
-    }
-
-    // signal that the last write job has been finished to allow
-    // a waiting application to reset the buffer now
-    if ( fSignalReset )
-    {
-        ShbError2 = ShbIpcSignalJobReady (pShbInstance_p);
-        if (ShbError == kShbOk)
-        {
-            ShbError = ShbError2;
-        }
-    }
-
-
-    *pfBufferCompleted_p = fBufferCompleted;
+INLINE_FUNCTION tShbError ShbCirWriteDataChunk(tShbInstance pShbInstance_p,
+					       tShbCirChunk * pShbCirChunk_p,
+					       const void *pSrcDataChunk_p,
+					       unsigned long ulDataChunkSize_p,
+					       unsigned int
+					       *pfBufferCompleted_p)
+{
+
+	tShbCirBuff *pShbCirBuff;
+	unsigned char *pShbCirDataPtr;
+	unsigned char *pScrDataPtr;
+	unsigned long ulSubChunkSize;
+	unsigned long ulWrIndex;
+	unsigned int fBufferCompleted;
+	unsigned int fSignalNewData;
+	unsigned int fSignalReset;
+	tShbError ShbError;
+	tShbError ShbError2;
+
+	// check arguments
+	if ((pShbInstance_p == NULL) || (pShbCirChunk_p == NULL)
+	    || (pfBufferCompleted_p == NULL)) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+
+	if ((pSrcDataChunk_p == NULL) || (ulDataChunkSize_p == 0)) {
+		// nothing to do here
+		ShbError = kShbOk;
+		goto Exit;
+	}
+
+	if (pShbCirChunk_p->m_fBufferCompleted) {
+		ShbError = kShbBufferAlreadyCompleted;
+		goto Exit;
+	}
+
+	if (ulDataChunkSize_p > pShbCirChunk_p->m_ulAvailableSize) {
+		ShbError = kShbExceedDataSizeLimit;
+		goto Exit;
+	}
+
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	pScrDataPtr = (unsigned char *)pSrcDataChunk_p;
+	fSignalNewData = FALSE;
+	fSignalReset = FALSE;
+	ShbError = kShbOk;
+
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	ulWrIndex = pShbCirChunk_p->m_ulWrIndex;
+
+	// copy the data to the circular buffer
+	// (the copy process itself will be done outside of any
+	// critical/locked section)
+	pShbCirDataPtr = &pShbCirBuff->m_Data;	// ptr to start of data area
+
+	if (ulWrIndex + ulDataChunkSize_p <= pShbCirBuff->m_ulBufferDataSize) {
+		// linear write operation
+		memcpy(pShbCirDataPtr + ulWrIndex, pScrDataPtr,
+		       ulDataChunkSize_p);
+	} else {
+		// wrap-around write operation
+		ulSubChunkSize = pShbCirBuff->m_ulBufferDataSize - ulWrIndex;
+		memcpy(pShbCirDataPtr + ulWrIndex, pScrDataPtr, ulSubChunkSize);
+		memcpy(pShbCirDataPtr, pScrDataPtr + ulSubChunkSize,
+		       ulDataChunkSize_p - ulSubChunkSize);
+	}
+
+	// adjust chunk descriptor
+	ulWrIndex += ulDataChunkSize_p;
+	ulWrIndex %= pShbCirBuff->m_ulBufferDataSize;
+
+	pShbCirChunk_p->m_ulAvailableSize -= ulDataChunkSize_p;
+	pShbCirChunk_p->m_ulWrIndex = ulWrIndex;
+
+	fBufferCompleted = (pShbCirChunk_p->m_ulAvailableSize == 0);
+	pShbCirChunk_p->m_fBufferCompleted = fBufferCompleted;
+
+	// if the complete allocated buffer is filled with data then
+	// adjust header information for circular buffer with properties
+	// of the wiritten data block
+	if (fBufferCompleted) {
+		ShbIpcEnterAtomicSection(pShbInstance_p);
+		{
+			pShbCirBuff->m_ulDataApended +=
+			    pShbCirChunk_p->m_uiFullBlockSize;
+			pShbCirBuff->m_ulBlocksApended++;
+
+			// decrement number of currently (parallel running) write operations
+			if (!--pShbCirBuff->m_ulNumOfWriteJobs) {
+				// if there is no other write process running then
+				// set new size of readable (complete written) data and
+				// adjust number of readable blocks
+				pShbCirBuff->m_ulDataReadable +=
+				    pShbCirBuff->m_ulDataApended;
+				pShbCirBuff->m_ulBlocksReadable +=
+				    pShbCirBuff->m_ulBlocksApended;
+
+				pShbCirBuff->m_ulDataApended = 0;
+				pShbCirBuff->m_ulBlocksApended = 0;
+
+				fSignalNewData = TRUE;
+				fSignalReset = pShbCirBuff->m_fBufferLocked;
+			}
+		}
+		ShbIpcLeaveAtomicSection(pShbInstance_p);
+	}
+
+	// signal new data event to a potentially reading application
+	if (fSignalNewData) {
+		ShbError2 = ShbIpcSignalNewData(pShbInstance_p);
+		if (ShbError == kShbOk) {
+			ShbError = ShbError2;
+		}
+	}
+	// signal that the last write job has been finished to allow
+	// a waiting application to reset the buffer now
+	if (fSignalReset) {
+		ShbError2 = ShbIpcSignalJobReady(pShbInstance_p);
+		if (ShbError == kShbOk) {
+			ShbError = ShbError2;
+		}
+	}
 
+	*pfBufferCompleted_p = fBufferCompleted;
 
-Exit:
+      Exit:
 
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Read data block from Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbCirReadDataBlock (
-    tShbInstance pShbInstance_p,
-    void* pDstDataBlock_p,
-    unsigned long ulRdBuffSize_p,
-    unsigned long* pulDataBlockSize_p)
-{
-
-tShbCirBuff*      pShbCirBuff;
-tShbCirBlockSize  ShbCirBlockSize;
-unsigned long     ulDataReadable;
-unsigned char*    pShbCirDataPtr;
-unsigned char*    pDstDataPtr;
-unsigned long     ulDataSize = 0;  // d.k. GCC complains about uninitialized variable otherwise
-unsigned long     ulChunkSize;
-unsigned long     ulRdIndex;
-tShbError         ShbError;
-
-
-    // check arguments
-    if ((pShbInstance_p == NULL) || (pulDataBlockSize_p == NULL))
-    {
-        return (kShbInvalidArg);
-    }
-
-    if ((pDstDataBlock_p == NULL) || (ulRdBuffSize_p == 0))
-    {
-        // nothing to do here
-        ShbError = kShbOk;
-        goto Exit;
-    }
-
-
-    ShbError    = kShbOk;
-    pShbCirBuff = ShbCirGetBuffer (pShbInstance_p);
-    pDstDataPtr = (unsigned char*)pDstDataBlock_p;
-    ulDataSize  = 0;
-
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
-
-    // get total number of readable bytes for the whole circular buffer
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        ulDataReadable = pShbCirBuff->m_ulDataReadable;
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
-
-
-    // if there are readable data available, then there must be at least
-    // one complete readable data block
-    if (ulDataReadable > 0)
-    {
-        // get pointer to start of data area and current read index
-        pShbCirDataPtr = &pShbCirBuff->m_Data;      // ptr to start of data area
-        ulRdIndex      =  pShbCirBuff->m_ulRdIndex;
-
-        // get real size of current block (incl. alignment fill bytes)
-        ShbCirBlockSize = *(tShbCirBlockSize*)(pShbCirDataPtr + ulRdIndex);
-        ulRdIndex += sizeof(tShbCirBlockSize);
-        ulRdIndex %= pShbCirBuff->m_ulBufferDataSize;
-
-        // get size of user data inside the current block
-        ulDataSize  = ShbCirBlockSize.m_uiFullBlockSize - ShbCirBlockSize.m_uiAlignFillBytes;
-        ulDataSize -= sizeof(tShbCirBlockSize);
-    }
-
-
-    // ulDataSize = MIN(ulDataSize, ulRdBuffSize_p);
-    if (ulDataSize > ulRdBuffSize_p)
-    {
-        ulDataSize = ulRdBuffSize_p;
-        ShbError = kShbDataTruncated;
-    }
-
-    if (ulDataSize == 0)
-    {
-        // nothing to do here
-        ShbError = kShbNoReadableData;
-        goto Exit;
-    }
-
-
-    // copy the data from the circular buffer
-    // (the copy process itself will be done outside of any
-    // critical/locked section)
-    if (ulRdIndex + ulDataSize <= pShbCirBuff->m_ulBufferDataSize)
-    {
-        // linear read operation
-        memcpy (pDstDataPtr, pShbCirDataPtr + ulRdIndex, ulDataSize);
-    }
-    else
-    {
-        // wrap-around read operation
-        ulChunkSize = pShbCirBuff->m_ulBufferDataSize - ulRdIndex;
-        memcpy (pDstDataPtr, pShbCirDataPtr + ulRdIndex, ulChunkSize);
-        memcpy (pDstDataPtr + ulChunkSize, pShbCirDataPtr, ulDataSize - ulChunkSize);
-    }
-
-
-    #ifndef NDEBUG
-    {
-        tShbCirBlockSize  ClrShbCirBlockSize;
-
-        if (ulRdIndex + ulDataSize <= pShbCirBuff->m_ulBufferDataSize)
-        {
-            // linear buffer
-            memset (pShbCirDataPtr + ulRdIndex, 0xDD, ulDataSize);
-        }
-        else
-        {
-            // wrap-around read operation
-            ulChunkSize = pShbCirBuff->m_ulBufferDataSize - ulRdIndex;
-            memset (pShbCirDataPtr + ulRdIndex, 0xDD, ulChunkSize);
-            memset (pShbCirDataPtr, 0xDD, ulDataSize - ulChunkSize);
-        }
-
-        ClrShbCirBlockSize.m_uiFullBlockSize  = /*(unsigned int)*/ -1;     // -1 = xFFFFFFF
-        ClrShbCirBlockSize.m_uiAlignFillBytes = /*(unsigned int)*/ -1;     // -1 = Fxxxxxxx
-        *(tShbCirBlockSize*)(pShbCirDataPtr + pShbCirBuff->m_ulRdIndex) = ClrShbCirBlockSize;
-    }
-    #endif  // #ifndef NDEBUG
-
-
-    // set new size of readable data, data in use, new read index
-    // and adjust number of readable blocks
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        pShbCirBuff->m_ulDataInUse      -= ShbCirBlockSize.m_uiFullBlockSize;
-        pShbCirBuff->m_ulDataReadable   -= ShbCirBlockSize.m_uiFullBlockSize;
-        pShbCirBuff->m_ulBlocksReadable --;
-
-        //$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-        if ((pShbCirBuff->m_ulDataInUse == 0) && (pShbCirBuff->m_ulDataReadable == 0))
-        {
-            ASSERT(pShbCirBuff->m_ulBlocksReadable == 0);
-
-            pShbCirBuff->m_ulWrIndex = 0;
-            pShbCirBuff->m_ulRdIndex = 0;
-        }
-        else
-        //$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
-        {
-            pShbCirBuff->m_ulRdIndex += ShbCirBlockSize.m_uiFullBlockSize;
-            pShbCirBuff->m_ulRdIndex %= pShbCirBuff->m_ulBufferDataSize;
-        }
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
+INLINE_FUNCTION tShbError ShbCirReadDataBlock(tShbInstance pShbInstance_p,
+					      void *pDstDataBlock_p,
+					      unsigned long ulRdBuffSize_p,
+					      unsigned long *pulDataBlockSize_p)
+{
+
+	tShbCirBuff *pShbCirBuff;
+	tShbCirBlockSize ShbCirBlockSize;
+	unsigned long ulDataReadable;
+	unsigned char *pShbCirDataPtr;
+	unsigned char *pDstDataPtr;
+	unsigned long ulDataSize = 0;	// d.k. GCC complains about uninitialized variable otherwise
+	unsigned long ulChunkSize;
+	unsigned long ulRdIndex;
+	tShbError ShbError;
+
+	// check arguments
+	if ((pShbInstance_p == NULL) || (pulDataBlockSize_p == NULL)) {
+		return (kShbInvalidArg);
+	}
+
+	if ((pDstDataBlock_p == NULL) || (ulRdBuffSize_p == 0)) {
+		// nothing to do here
+		ShbError = kShbOk;
+		goto Exit;
+	}
+
+	ShbError = kShbOk;
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	pDstDataPtr = (unsigned char *)pDstDataBlock_p;
+	ulDataSize = 0;
+
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	// get total number of readable bytes for the whole circular buffer
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		ulDataReadable = pShbCirBuff->m_ulDataReadable;
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
+
+	// if there are readable data available, then there must be at least
+	// one complete readable data block
+	if (ulDataReadable > 0) {
+		// get pointer to start of data area and current read index
+		pShbCirDataPtr = &pShbCirBuff->m_Data;	// ptr to start of data area
+		ulRdIndex = pShbCirBuff->m_ulRdIndex;
+
+		// get real size of current block (incl. alignment fill bytes)
+		ShbCirBlockSize =
+		    *(tShbCirBlockSize *) (pShbCirDataPtr + ulRdIndex);
+		ulRdIndex += sizeof(tShbCirBlockSize);
+		ulRdIndex %= pShbCirBuff->m_ulBufferDataSize;
+
+		// get size of user data inside the current block
+		ulDataSize =
+		    ShbCirBlockSize.m_uiFullBlockSize -
+		    ShbCirBlockSize.m_uiAlignFillBytes;
+		ulDataSize -= sizeof(tShbCirBlockSize);
+	}
+
+	// ulDataSize = MIN(ulDataSize, ulRdBuffSize_p);
+	if (ulDataSize > ulRdBuffSize_p) {
+		ulDataSize = ulRdBuffSize_p;
+		ShbError = kShbDataTruncated;
+	}
+
+	if (ulDataSize == 0) {
+		// nothing to do here
+		ShbError = kShbNoReadableData;
+		goto Exit;
+	}
+
+	// copy the data from the circular buffer
+	// (the copy process itself will be done outside of any
+	// critical/locked section)
+	if (ulRdIndex + ulDataSize <= pShbCirBuff->m_ulBufferDataSize) {
+		// linear read operation
+		memcpy(pDstDataPtr, pShbCirDataPtr + ulRdIndex, ulDataSize);
+	} else {
+		// wrap-around read operation
+		ulChunkSize = pShbCirBuff->m_ulBufferDataSize - ulRdIndex;
+		memcpy(pDstDataPtr, pShbCirDataPtr + ulRdIndex, ulChunkSize);
+		memcpy(pDstDataPtr + ulChunkSize, pShbCirDataPtr,
+		       ulDataSize - ulChunkSize);
+	}
 
+#ifndef NDEBUG
+	{
+		tShbCirBlockSize ClrShbCirBlockSize;
 
-Exit:
-
-    *pulDataBlockSize_p = ulDataSize;
+		if (ulRdIndex + ulDataSize <= pShbCirBuff->m_ulBufferDataSize) {
+			// linear buffer
+			memset(pShbCirDataPtr + ulRdIndex, 0xDD, ulDataSize);
+		} else {
+			// wrap-around read operation
+			ulChunkSize =
+			    pShbCirBuff->m_ulBufferDataSize - ulRdIndex;
+			memset(pShbCirDataPtr + ulRdIndex, 0xDD, ulChunkSize);
+			memset(pShbCirDataPtr, 0xDD, ulDataSize - ulChunkSize);
+		}
+
+		ClrShbCirBlockSize.m_uiFullBlockSize = /*(unsigned int) */ -1;	// -1 = xFFFFFFF
+		ClrShbCirBlockSize.m_uiAlignFillBytes = /*(unsigned int) */ -1;	// -1 = Fxxxxxxx
+		*(tShbCirBlockSize *) (pShbCirDataPtr +
+				       pShbCirBuff->m_ulRdIndex) =
+		    ClrShbCirBlockSize;
+	}
+#endif // #ifndef NDEBUG
+
+	// set new size of readable data, data in use, new read index
+	// and adjust number of readable blocks
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		pShbCirBuff->m_ulDataInUse -= ShbCirBlockSize.m_uiFullBlockSize;
+		pShbCirBuff->m_ulDataReadable -=
+		    ShbCirBlockSize.m_uiFullBlockSize;
+		pShbCirBuff->m_ulBlocksReadable--;
+
+		//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
+		if ((pShbCirBuff->m_ulDataInUse == 0)
+		    && (pShbCirBuff->m_ulDataReadable == 0)) {
+			ASSERT(pShbCirBuff->m_ulBlocksReadable == 0);
+
+			pShbCirBuff->m_ulWrIndex = 0;
+			pShbCirBuff->m_ulRdIndex = 0;
+		} else
+			//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
+		{
+			pShbCirBuff->m_ulRdIndex +=
+			    ShbCirBlockSize.m_uiFullBlockSize;
+			pShbCirBuff->m_ulRdIndex %=
+			    pShbCirBuff->m_ulBufferDataSize;
+		}
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
 
-    return (ShbError);
+      Exit:
 
-}
+	*pulDataBlockSize_p = ulDataSize;
 
+	return (ShbError);
 
+}
 
 //---------------------------------------------------------------------------
 //  Get data size of next readable block from Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbCirGetReadDataSize (
-    tShbInstance pShbInstance_p,
-    unsigned long* pulDataBlockSize_p)
-{
-
-tShbCirBuff*      pShbCirBuff;
-unsigned long     ulDataReadable;
-unsigned char*    pShbCirDataPtr;
-tShbCirBlockSize  ShbCirBlockSize;
-unsigned long     ulDataSize;
-tShbError         ShbError;
-
-
-    // check arguments
-    if ((pShbInstance_p == NULL) || (pulDataBlockSize_p == NULL))
-    {
-        return (kShbInvalidArg);
-    }
-
-
-    pShbCirBuff = ShbCirGetBuffer (pShbInstance_p);
-    ulDataSize  = 0;
-    ShbError    = kShbOk;
-
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
-
-    // get total number of readable bytes for the whole circular buffer
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        ulDataReadable = pShbCirBuff->m_ulDataReadable;
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
-
-
-    // if there are readable data available, then there must be at least
-    // one complete readable data block
-    if (ulDataReadable > 0)
-    {
-        pShbCirDataPtr = &pShbCirBuff->m_Data + pShbCirBuff->m_ulRdIndex;
-
-        // get real size of current block (incl. alignment fill bytes)
-        ShbCirBlockSize = *(tShbCirBlockSize*)pShbCirDataPtr;
+INLINE_FUNCTION tShbError ShbCirGetReadDataSize(tShbInstance pShbInstance_p,
+						unsigned long
+						*pulDataBlockSize_p)
+{
+
+	tShbCirBuff *pShbCirBuff;
+	unsigned long ulDataReadable;
+	unsigned char *pShbCirDataPtr;
+	tShbCirBlockSize ShbCirBlockSize;
+	unsigned long ulDataSize;
+	tShbError ShbError;
+
+	// check arguments
+	if ((pShbInstance_p == NULL) || (pulDataBlockSize_p == NULL)) {
+		return (kShbInvalidArg);
+	}
+
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	ulDataSize = 0;
+	ShbError = kShbOk;
+
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	// get total number of readable bytes for the whole circular buffer
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		ulDataReadable = pShbCirBuff->m_ulDataReadable;
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
+
+	// if there are readable data available, then there must be at least
+	// one complete readable data block
+	if (ulDataReadable > 0) {
+		pShbCirDataPtr =
+		    &pShbCirBuff->m_Data + pShbCirBuff->m_ulRdIndex;
+
+		// get real size of current block (incl. alignment fill bytes)
+		ShbCirBlockSize = *(tShbCirBlockSize *) pShbCirDataPtr;
+
+		// get size of user data inside the current block
+		ulDataSize =
+		    ShbCirBlockSize.m_uiFullBlockSize -
+		    ShbCirBlockSize.m_uiAlignFillBytes;
+		ulDataSize -= sizeof(tShbCirBlockSize);
+	}
 
-        // get size of user data inside the current block
-        ulDataSize  = ShbCirBlockSize.m_uiFullBlockSize - ShbCirBlockSize.m_uiAlignFillBytes;
-        ulDataSize -= sizeof(tShbCirBlockSize);
-    }
+      Exit:
 
+	*pulDataBlockSize_p = ulDataSize;
 
-Exit:
-
-    *pulDataBlockSize_p = ulDataSize;
-
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Get number of readable blocks from Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbCirGetReadBlockCount (
-    tShbInstance pShbInstance_p,
-    unsigned long* pulDataBlockCount_p)
+INLINE_FUNCTION tShbError ShbCirGetReadBlockCount(tShbInstance pShbInstance_p,
+						  unsigned long
+						  *pulDataBlockCount_p)
 {
 
-tShbCirBuff*   pShbCirBuff;
-unsigned long  ulBlockCount;
-tShbError      ShbError;
-
+	tShbCirBuff *pShbCirBuff;
+	unsigned long ulBlockCount;
+	tShbError ShbError;
 
-    // check arguments
-    if ((pShbInstance_p == NULL) || (pulDataBlockCount_p == NULL))
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
+	// check arguments
+	if ((pShbInstance_p == NULL) || (pulDataBlockCount_p == NULL)) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
 
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	ulBlockCount = 0;
+	ShbError = kShbOk;
 
-    pShbCirBuff  = ShbCirGetBuffer (pShbInstance_p);
-    ulBlockCount = 0;
-    ShbError     = kShbOk;
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
 
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		ulBlockCount = pShbCirBuff->m_ulBlocksReadable;
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
 
+	*pulDataBlockCount_p = ulBlockCount;
 
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        ulBlockCount = pShbCirBuff->m_ulBlocksReadable;
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
+      Exit:
 
-
-    *pulDataBlockCount_p = ulBlockCount;
-
-
-Exit:
-
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Set application handler to signal new data for Circular Shared Buffer
 //  d.k.: new parameter priority as enum
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbCirSetSignalHandlerNewData (
-    tShbInstance pShbInstance_p,
-    tShbCirSigHndlrNewData pfnSignalHandlerNewData_p,
-    tShbPriority ShbPriority_p)
-{
-
-tShbCirBuff*  pShbCirBuff;
-tShbError     ShbError;
-
-
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-
-
-    pShbCirBuff = ShbCirGetBuffer (pShbInstance_p);
-    ShbError    = kShbOk;
-
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
-
-    if (pfnSignalHandlerNewData_p != NULL)
-    {
-        // set a new signal handler
-        if (pShbCirBuff->m_pfnSigHndlrNewData != NULL)
-        {
-            ShbError = kShbAlreadySignaling;
-            goto Exit;
-        }
-
-        pShbCirBuff->m_pfnSigHndlrNewData = pfnSignalHandlerNewData_p;
-        ShbError = ShbIpcStartSignalingNewData (pShbInstance_p, ShbCirSignalHandlerNewData, ShbPriority_p);
-    }
-    else
-    {
-        // remove existing signal handler
-        ShbError = ShbIpcStopSignalingNewData (pShbInstance_p);
-        if (pShbCirBuff->m_pfnSigHndlrNewData != NULL)
-        {
-            pShbCirBuff->m_pfnSigHndlrNewData (pShbInstance_p, 0);
-        }
-        pShbCirBuff->m_pfnSigHndlrNewData = NULL;
-    }
-
+INLINE_FUNCTION tShbError ShbCirSetSignalHandlerNewData(tShbInstance
+							pShbInstance_p,
+							tShbCirSigHndlrNewData
+							pfnSignalHandlerNewData_p,
+							tShbPriority
+							ShbPriority_p)
+{
+
+	tShbCirBuff *pShbCirBuff;
+	tShbError ShbError;
+
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	ShbError = kShbOk;
+
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	if (pfnSignalHandlerNewData_p != NULL) {
+		// set a new signal handler
+		if (pShbCirBuff->m_pfnSigHndlrNewData != NULL) {
+			ShbError = kShbAlreadySignaling;
+			goto Exit;
+		}
+
+		pShbCirBuff->m_pfnSigHndlrNewData = pfnSignalHandlerNewData_p;
+		ShbError =
+		    ShbIpcStartSignalingNewData(pShbInstance_p,
+						ShbCirSignalHandlerNewData,
+						ShbPriority_p);
+	} else {
+		// remove existing signal handler
+		ShbError = ShbIpcStopSignalingNewData(pShbInstance_p);
+		if (pShbCirBuff->m_pfnSigHndlrNewData != NULL) {
+			pShbCirBuff->m_pfnSigHndlrNewData(pShbInstance_p, 0);
+		}
+		pShbCirBuff->m_pfnSigHndlrNewData = NULL;
+	}
 
-Exit:
+      Exit:
 
-    return (ShbError);
+	return (ShbError);
 
 }
 
@@ -1326,136 +1174,144 @@ Exit:
 //---------------------------------------------------------------------------
 
 #ifndef NDEBUG
-tShbError  ShbCirTraceBuffer (
-    tShbInstance pShbInstance_p)
+tShbError ShbCirTraceBuffer(tShbInstance pShbInstance_p)
 {
 
-tShbCirBuff*      pShbCirBuff;
-char              szMagigID[sizeof(SBC_MAGIC_ID)+1];
-tShbCirBlockSize  ShbCirBlockSize;
-unsigned long     ulDataReadable;
-unsigned char*    pShbCirDataPtr;
-unsigned long     ulBlockIndex;
-unsigned int      nBlockCount;
-unsigned long     ulDataSize;
-unsigned long     ulChunkSize;
-unsigned long     ulRdIndex;
-tShbError         ShbError;
-
-
-    TRACE0("\n\n##### Circular Shared Buffer #####\n");
-
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        TRACE1("\nERROR: invalid buffer address (0x%08lX)\n", (unsigned long)pShbInstance_p);
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-
-
-    pShbCirBuff = ShbCirGetBuffer (pShbInstance_p);
-    ShbError    = kShbOk;
-
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
-
-    *(unsigned long*) &szMagigID[0] = pShbCirBuff->m_ShbCirMagicID;
-    szMagigID[sizeof(SBC_MAGIC_ID)] = '\0';
-
-
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        TRACE1("\nBuffer Address:   0x%08lX\n",    (unsigned long)pShbCirBuff);
-
-        TRACE0("\nHeader Info:");
-        TRACE2("\nMagigID:          '%s' (%08lX)", szMagigID, pShbCirBuff->m_ShbCirMagicID);
-        TRACE1("\nBufferTotalSize:  %4lu [Bytes]", pShbCirBuff->m_ulBufferTotalSize);
-        TRACE1("\nBufferDataSize:   %4lu [Bytes]", pShbCirBuff->m_ulBufferDataSize);
-        TRACE1("\nWrIndex:          %4lu",         pShbCirBuff->m_ulWrIndex);
-        TRACE1("\nRdIndex:          %4lu",         pShbCirBuff->m_ulRdIndex);
-        TRACE1("\nNumOfWriteJobs:   %4lu",         pShbCirBuff->m_ulNumOfWriteJobs);
-        TRACE1("\nDataInUse:        %4lu [Bytes]", pShbCirBuff->m_ulDataInUse);
-        TRACE1("\nDataApended:      %4lu [Bytes]", pShbCirBuff->m_ulDataApended);
-        TRACE1("\nBlocksApended:    %4lu",         pShbCirBuff->m_ulBlocksApended);
-        TRACE1("\nDataReadable:     %4lu [Bytes]", pShbCirBuff->m_ulDataReadable);
-        TRACE1("\nBlocksReadable:   %4lu",         pShbCirBuff->m_ulBlocksReadable);
-        TRACE1("\nSigHndlrNewData:  %08lX",        (unsigned long)pShbCirBuff->m_pfnSigHndlrNewData);
-        TRACE1("\nBufferLocked:     %d",           pShbCirBuff->m_fBufferLocked);
-        TRACE1("\nSigHndlrReset:    %08lX",        (unsigned long)pShbCirBuff->m_pfnSigHndlrReset);
-
-        ShbTraceDump (&pShbCirBuff->m_Data, pShbCirBuff->m_ulBufferDataSize,
-                      0x00000000L, "\nData Area:");
-
-
-        ulDataReadable = pShbCirBuff->m_ulDataReadable;
-        nBlockCount  = 1;
-        ulBlockIndex = pShbCirBuff->m_ulRdIndex;
-
-        while (ulDataReadable > 0)
-        {
-            TRACE1("\n\n--- Block #%u ---", nBlockCount);
-
-            // get pointer to start of data area and current read index
-            pShbCirDataPtr = &pShbCirBuff->m_Data;      // ptr to start of data area
-            ulRdIndex      = ulBlockIndex;
-
-            // get real size of current block (incl. alignment fill bytes)
-            ShbCirBlockSize = *(tShbCirBlockSize*)(pShbCirDataPtr + ulRdIndex);
-            ulRdIndex += sizeof(tShbCirBlockSize);
-            ulRdIndex %= pShbCirBuff->m_ulBufferDataSize;
-
-            // get size of user data inside the current block
-            ulDataSize  = ShbCirBlockSize.m_uiFullBlockSize - ShbCirBlockSize.m_uiAlignFillBytes;
-            ulDataSize -= sizeof(tShbCirBlockSize);
-
-            TRACE1("\nFull Data Size:       %4u [Bytes] (incl. header and alignment fill bytes)", ShbCirBlockSize.m_uiFullBlockSize);
-            TRACE1("\nUser Data Size:       %4lu [Bytes]", ulDataSize);
-            TRACE1("\nAlignment Fill Bytes: %4u [Bytes]", ShbCirBlockSize.m_uiAlignFillBytes);
-
+	tShbCirBuff *pShbCirBuff;
+	char szMagigID[sizeof(SBC_MAGIC_ID) + 1];
+	tShbCirBlockSize ShbCirBlockSize;
+	unsigned long ulDataReadable;
+	unsigned char *pShbCirDataPtr;
+	unsigned long ulBlockIndex;
+	unsigned int nBlockCount;
+	unsigned long ulDataSize;
+	unsigned long ulChunkSize;
+	unsigned long ulRdIndex;
+	tShbError ShbError;
+
+	TRACE0("\n\n##### Circular Shared Buffer #####\n");
+
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		TRACE1("\nERROR: invalid buffer address (0x%08lX)\n",
+		       (unsigned long)pShbInstance_p);
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	ShbError = kShbOk;
+
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	*(unsigned long *)&szMagigID[0] = pShbCirBuff->m_ShbCirMagicID;
+	szMagigID[sizeof(SBC_MAGIC_ID)] = '\0';
+
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		TRACE1("\nBuffer Address:   0x%08lX\n",
+		       (unsigned long)pShbCirBuff);
+
+		TRACE0("\nHeader Info:");
+		TRACE2("\nMagigID:          '%s' (%08lX)", szMagigID,
+		       pShbCirBuff->m_ShbCirMagicID);
+		TRACE1("\nBufferTotalSize:  %4lu [Bytes]",
+		       pShbCirBuff->m_ulBufferTotalSize);
+		TRACE1("\nBufferDataSize:   %4lu [Bytes]",
+		       pShbCirBuff->m_ulBufferDataSize);
+		TRACE1("\nWrIndex:          %4lu", pShbCirBuff->m_ulWrIndex);
+		TRACE1("\nRdIndex:          %4lu", pShbCirBuff->m_ulRdIndex);
+		TRACE1("\nNumOfWriteJobs:   %4lu",
+		       pShbCirBuff->m_ulNumOfWriteJobs);
+		TRACE1("\nDataInUse:        %4lu [Bytes]",
+		       pShbCirBuff->m_ulDataInUse);
+		TRACE1("\nDataApended:      %4lu [Bytes]",
+		       pShbCirBuff->m_ulDataApended);
+		TRACE1("\nBlocksApended:    %4lu",
+		       pShbCirBuff->m_ulBlocksApended);
+		TRACE1("\nDataReadable:     %4lu [Bytes]",
+		       pShbCirBuff->m_ulDataReadable);
+		TRACE1("\nBlocksReadable:   %4lu",
+		       pShbCirBuff->m_ulBlocksReadable);
+		TRACE1("\nSigHndlrNewData:  %08lX",
+		       (unsigned long)pShbCirBuff->m_pfnSigHndlrNewData);
+		TRACE1("\nBufferLocked:     %d", pShbCirBuff->m_fBufferLocked);
+		TRACE1("\nSigHndlrReset:    %08lX",
+		       (unsigned long)pShbCirBuff->m_pfnSigHndlrReset);
+
+		ShbTraceDump(&pShbCirBuff->m_Data,
+			     pShbCirBuff->m_ulBufferDataSize, 0x00000000L,
+			     "\nData Area:");
+
+		ulDataReadable = pShbCirBuff->m_ulDataReadable;
+		nBlockCount = 1;
+		ulBlockIndex = pShbCirBuff->m_ulRdIndex;
+
+		while (ulDataReadable > 0) {
+			TRACE1("\n\n--- Block #%u ---", nBlockCount);
+
+			// get pointer to start of data area and current read index
+			pShbCirDataPtr = &pShbCirBuff->m_Data;	// ptr to start of data area
+			ulRdIndex = ulBlockIndex;
+
+			// get real size of current block (incl. alignment fill bytes)
+			ShbCirBlockSize =
+			    *(tShbCirBlockSize *) (pShbCirDataPtr + ulRdIndex);
+			ulRdIndex += sizeof(tShbCirBlockSize);
+			ulRdIndex %= pShbCirBuff->m_ulBufferDataSize;
+
+			// get size of user data inside the current block
+			ulDataSize =
+			    ShbCirBlockSize.m_uiFullBlockSize -
+			    ShbCirBlockSize.m_uiAlignFillBytes;
+			ulDataSize -= sizeof(tShbCirBlockSize);
+
+			TRACE1
+			    ("\nFull Data Size:       %4u [Bytes] (incl. header and alignment fill bytes)",
+			     ShbCirBlockSize.m_uiFullBlockSize);
+			TRACE1("\nUser Data Size:       %4lu [Bytes]",
+			       ulDataSize);
+			TRACE1("\nAlignment Fill Bytes: %4u [Bytes]",
+			       ShbCirBlockSize.m_uiAlignFillBytes);
+
+			if (ulRdIndex + ulDataSize <=
+			    pShbCirBuff->m_ulBufferDataSize) {
+				// linear data buffer
+				ShbTraceDump(pShbCirDataPtr + ulRdIndex,
+					     ulDataSize, 0x00000000L, NULL);
+			} else {
+				// wrap-around data buffer
+				ulChunkSize =
+				    pShbCirBuff->m_ulBufferDataSize - ulRdIndex;
+				ShbTraceDump(pShbCirDataPtr + ulRdIndex,
+					     ulChunkSize, 0x00000000L, NULL);
+				ShbTraceDump(pShbCirDataPtr,
+					     ulDataSize - ulChunkSize,
+					     ulChunkSize, NULL);
+			}
+
+			nBlockCount++;
+
+			ulBlockIndex += ShbCirBlockSize.m_uiFullBlockSize;
+			ulBlockIndex %= pShbCirBuff->m_ulBufferDataSize;
+
+			ulDataReadable -= ShbCirBlockSize.m_uiFullBlockSize;
+		}
+
+		ASSERT(pShbCirBuff->m_ulBlocksReadable == nBlockCount - 1);
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
 
-            if (ulRdIndex + ulDataSize <= pShbCirBuff->m_ulBufferDataSize)
-            {
-                // linear data buffer
-                ShbTraceDump (pShbCirDataPtr + ulRdIndex, ulDataSize, 0x00000000L, NULL);
-            }
-            else
-            {
-                // wrap-around data buffer
-                ulChunkSize = pShbCirBuff->m_ulBufferDataSize - ulRdIndex;
-                ShbTraceDump (pShbCirDataPtr + ulRdIndex, ulChunkSize, 0x00000000L, NULL);
-                ShbTraceDump (pShbCirDataPtr, ulDataSize - ulChunkSize, ulChunkSize, NULL);
-            }
+      Exit:
 
-            nBlockCount++;
-
-            ulBlockIndex += ShbCirBlockSize.m_uiFullBlockSize;
-            ulBlockIndex %= pShbCirBuff->m_ulBufferDataSize;
-
-            ulDataReadable -= ShbCirBlockSize.m_uiFullBlockSize;
-        }
-
-        ASSERT(pShbCirBuff->m_ulBlocksReadable == nBlockCount-1);
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
-
-
-
-Exit:
-
-    return (ShbError);
+	return (ShbError);
 
 }
 #endif
 
-
-
-
-
 //-------------------------------------------------------------------------//
 //                                                                         //
 //          L i n e a r   S h a r e d   B u f f e r                        //
@@ -1466,117 +1322,98 @@ Exit:
 //  Allocate Linear Shared Buffer
 //---------------------------------------------------------------------------
 
-tShbError  ShbLinAllocBuffer (
-    unsigned long ulBufferSize_p,
-    const char* pszBufferID_p,
-    tShbInstance* ppShbInstance_p,
-    unsigned int* pfShbNewCreated_p)
-{
-
-tShbInstance   pShbInstance;
-tShbLinBuff*   pShbLinBuff;
-unsigned int   fShbNewCreated;
-unsigned long  ulBufferDataSize;
-unsigned long  ulBufferTotalSize;
-tShbError      ShbError;
-
-
-    // check arguments
-    if ((ulBufferSize_p == 0) || (ppShbInstance_p == NULL))
-    {
-        return (kShbInvalidArg);
-    }
-
-
-    // calculate length of memory to allocate
-    ulBufferDataSize  = (ulBufferSize_p + (SBL_BLOCK_ALIGNMENT-1)) & ~(SBL_BLOCK_ALIGNMENT-1);
-    ulBufferTotalSize = ulBufferDataSize + sizeof(tShbLinBuff);
-
-    // allocate a new or open an existing shared buffer
-    ShbError = ShbIpcAllocBuffer (ulBufferTotalSize, pszBufferID_p,
-                                  &pShbInstance, &fShbNewCreated);
-    if (ShbError != kShbOk)
-    {
-        goto Exit;
-    }
-
-    if (pShbInstance == NULL)
-    {
-        ShbError = kShbOutOfMem;
-        goto Exit;
-    }
-
-
-    // get pointer to shared buffer
-    pShbLinBuff = (tShbLinBuff*) ShbIpcGetShMemPtr (pShbInstance);
-
-    // if the shared buffer was new created, than this process has
-    // to initialize it, otherwise the buffer is already in use
-    // and *must not* be reseted
-    if ( fShbNewCreated )
-    {
-        #ifndef NDEBUG
-        {
-            memset (pShbLinBuff, 0xCC, ulBufferTotalSize);
-        }
-        #endif
-
-
-        pShbLinBuff->m_ShbLinMagicID     = SBL_MAGIC_ID;
-        pShbLinBuff->m_ulBufferTotalSize = ulBufferTotalSize;
-        pShbLinBuff->m_ulBufferDataSize  = ulBufferDataSize;
-    }
-    else
-    {
-        if (pShbLinBuff->m_ShbLinMagicID != SBL_MAGIC_ID)
-        {
-            ShbError = kShbInvalidBufferType;
-            goto Exit;
-        }
-    }
+tShbError ShbLinAllocBuffer(unsigned long ulBufferSize_p,
+			    const char *pszBufferID_p,
+			    tShbInstance * ppShbInstance_p,
+			    unsigned int *pfShbNewCreated_p)
+{
+
+	tShbInstance pShbInstance;
+	tShbLinBuff *pShbLinBuff;
+	unsigned int fShbNewCreated;
+	unsigned long ulBufferDataSize;
+	unsigned long ulBufferTotalSize;
+	tShbError ShbError;
+
+	// check arguments
+	if ((ulBufferSize_p == 0) || (ppShbInstance_p == NULL)) {
+		return (kShbInvalidArg);
+	}
+
+	// calculate length of memory to allocate
+	ulBufferDataSize =
+	    (ulBufferSize_p +
+	     (SBL_BLOCK_ALIGNMENT - 1)) & ~(SBL_BLOCK_ALIGNMENT - 1);
+	ulBufferTotalSize = ulBufferDataSize + sizeof(tShbLinBuff);
+
+	// allocate a new or open an existing shared buffer
+	ShbError = ShbIpcAllocBuffer(ulBufferTotalSize, pszBufferID_p,
+				     &pShbInstance, &fShbNewCreated);
+	if (ShbError != kShbOk) {
+		goto Exit;
+	}
+
+	if (pShbInstance == NULL) {
+		ShbError = kShbOutOfMem;
+		goto Exit;
+	}
+
+	// get pointer to shared buffer
+	pShbLinBuff = (tShbLinBuff *) ShbIpcGetShMemPtr(pShbInstance);
+
+	// if the shared buffer was new created, than this process has
+	// to initialize it, otherwise the buffer is already in use
+	// and *must not* be reseted
+	if (fShbNewCreated) {
+#ifndef NDEBUG
+		{
+			memset(pShbLinBuff, 0xCC, ulBufferTotalSize);
+		}
+#endif
 
+		pShbLinBuff->m_ShbLinMagicID = SBL_MAGIC_ID;
+		pShbLinBuff->m_ulBufferTotalSize = ulBufferTotalSize;
+		pShbLinBuff->m_ulBufferDataSize = ulBufferDataSize;
+	} else {
+		if (pShbLinBuff->m_ShbLinMagicID != SBL_MAGIC_ID) {
+			ShbError = kShbInvalidBufferType;
+			goto Exit;
+		}
+	}
 
-Exit:
+      Exit:
 
-    *ppShbInstance_p   = pShbInstance;
-    *pfShbNewCreated_p = fShbNewCreated;
+	*ppShbInstance_p = pShbInstance;
+	*pfShbNewCreated_p = fShbNewCreated;
 
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Release Linear Shared Buffer
 //---------------------------------------------------------------------------
 
-tShbError  ShbLinReleaseBuffer (
-    tShbInstance pShbInstance_p)
+tShbError ShbLinReleaseBuffer(tShbInstance pShbInstance_p)
 {
 
-tShbError  ShbError;
-
+	tShbError ShbError;
 
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        ShbError = kShbOk;
-        goto Exit;
-    }
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		ShbError = kShbOk;
+		goto Exit;
+	}
 
+	ShbError = ShbIpcReleaseBuffer(pShbInstance_p);
 
-    ShbError = ShbIpcReleaseBuffer (pShbInstance_p);
+      Exit:
 
-
-Exit:
-
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-#endif  // !defined(INLINE_ENABLED)
+#endif // !defined(INLINE_ENABLED)
 
 #if (!defined(SHAREDBUFF_INLINED)) || defined(INLINE_ENABLED)
 
@@ -1584,325 +1421,266 @@ Exit:
 //  Write data block to Linear Shared Buffer
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbLinWriteDataBlock (
-    tShbInstance pShbInstance_p,
-    unsigned long ulDstBufferOffs_p,
-    const void* pSrcDataBlock_p,
-    unsigned long ulDataBlockSize_p)
-{
-
-tShbLinBuff*    pShbLinBuff;
-unsigned char*  pShbLinDataPtr;
-unsigned char*  pScrDataPtr;
-unsigned long   ulBufferDataSize;
-tShbError       ShbError;
-
-
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-
-    if ((pSrcDataBlock_p == NULL) || (ulDataBlockSize_p == 0))
-    {
-        // nothing to do here
-        ShbError = kShbOk;
-        goto Exit;
-    }
-
-    if (ulDataBlockSize_p > SBL_MAX_BLOCK_SIZE)
-    {
-        ShbError = kShbExceedDataSizeLimit;
-        goto Exit;
-    }
-
-
-    pShbLinBuff = ShbLinGetBuffer (pShbInstance_p);
-    pScrDataPtr = (unsigned char*)pSrcDataBlock_p;
-    ShbError    = kShbOk;
-
-    if (pShbLinBuff->m_ShbLinMagicID != SBL_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
-
-    // check if offeset and size for the write operation matches with
-    // the size of the shared buffer
-    ulBufferDataSize = pShbLinBuff->m_ulBufferDataSize;
-    if ( (ulDstBufferOffs_p > ulBufferDataSize) ||
-         (ulDataBlockSize_p > ulBufferDataSize) ||
-         ((ulDstBufferOffs_p + ulDataBlockSize_p) > ulBufferDataSize) )
-    {
-        ShbError = kShbDataOutsideBufferArea;
-        goto Exit;
-    }
-
-
-    // copy the data to the linear buffer
-    // (the copy process will be done inside of any critical/locked section)
-    pShbLinDataPtr  = &pShbLinBuff->m_Data;         // ptr to start of data area
-    pShbLinDataPtr += ulDstBufferOffs_p;
-
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        memcpy (pShbLinDataPtr, pScrDataPtr, ulDataBlockSize_p);
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
+INLINE_FUNCTION tShbError ShbLinWriteDataBlock(tShbInstance pShbInstance_p,
+					       unsigned long ulDstBufferOffs_p,
+					       const void *pSrcDataBlock_p,
+					       unsigned long ulDataBlockSize_p)
+{
+
+	tShbLinBuff *pShbLinBuff;
+	unsigned char *pShbLinDataPtr;
+	unsigned char *pScrDataPtr;
+	unsigned long ulBufferDataSize;
+	tShbError ShbError;
+
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+
+	if ((pSrcDataBlock_p == NULL) || (ulDataBlockSize_p == 0)) {
+		// nothing to do here
+		ShbError = kShbOk;
+		goto Exit;
+	}
+
+	if (ulDataBlockSize_p > SBL_MAX_BLOCK_SIZE) {
+		ShbError = kShbExceedDataSizeLimit;
+		goto Exit;
+	}
+
+	pShbLinBuff = ShbLinGetBuffer(pShbInstance_p);
+	pScrDataPtr = (unsigned char *)pSrcDataBlock_p;
+	ShbError = kShbOk;
+
+	if (pShbLinBuff->m_ShbLinMagicID != SBL_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	// check if offeset and size for the write operation matches with
+	// the size of the shared buffer
+	ulBufferDataSize = pShbLinBuff->m_ulBufferDataSize;
+	if ((ulDstBufferOffs_p > ulBufferDataSize) ||
+	    (ulDataBlockSize_p > ulBufferDataSize) ||
+	    ((ulDstBufferOffs_p + ulDataBlockSize_p) > ulBufferDataSize)) {
+		ShbError = kShbDataOutsideBufferArea;
+		goto Exit;
+	}
+
+	// copy the data to the linear buffer
+	// (the copy process will be done inside of any critical/locked section)
+	pShbLinDataPtr = &pShbLinBuff->m_Data;	// ptr to start of data area
+	pShbLinDataPtr += ulDstBufferOffs_p;
+
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		memcpy(pShbLinDataPtr, pScrDataPtr, ulDataBlockSize_p);
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
 
+      Exit:
 
-Exit:
-
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Read data block from Linear Shared Buffer
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbLinReadDataBlock (
-    tShbInstance pShbInstance_p,
-    void* pDstDataBlock_p,
-    unsigned long ulSrcBufferOffs_p,
-    unsigned long ulDataBlockSize_p)
-{
-
-tShbLinBuff*    pShbLinBuff;
-unsigned char*  pShbLinDataPtr;
-unsigned char*  pDstDataPtr;
-unsigned long   ulBufferDataSize;
-tShbError       ShbError;
-
-
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-
-    if ((pDstDataBlock_p == NULL) || (ulDataBlockSize_p == 0))
-    {
-        // nothing to do here
-        ShbError = kShbOk;
-        goto Exit;
-    }
-
-    if (ulDataBlockSize_p > SBL_MAX_BLOCK_SIZE)
-    {
-        ShbError = kShbExceedDataSizeLimit;
-        goto Exit;
-    }
-
-
-    pShbLinBuff = ShbLinGetBuffer (pShbInstance_p);
-    pDstDataPtr = (unsigned char*)pDstDataBlock_p;
-    ShbError    = kShbOk;
-
-    if (pShbLinBuff->m_ShbLinMagicID != SBL_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
-
-    // check if offeset and size for the read operation matches with
-    // the size of the shared buffer
-    ulBufferDataSize = pShbLinBuff->m_ulBufferDataSize;
-    if ( (ulSrcBufferOffs_p > ulBufferDataSize) ||
-         (ulDataBlockSize_p > ulBufferDataSize) ||
-         ((ulSrcBufferOffs_p + ulDataBlockSize_p) > ulBufferDataSize) )
-    {
-        ShbError = kShbDataOutsideBufferArea;
-        goto Exit;
-    }
-
-
-    // copy the data to the linear buffer
-    // (the copy process will be done inside of any critical/locked section)
-    pShbLinDataPtr  = &pShbLinBuff->m_Data;         // ptr to start of data area
-    pShbLinDataPtr += ulSrcBufferOffs_p;
-
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        memcpy (pDstDataPtr, pShbLinDataPtr, ulDataBlockSize_p);
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
-
+INLINE_FUNCTION tShbError ShbLinReadDataBlock(tShbInstance pShbInstance_p,
+					      void *pDstDataBlock_p,
+					      unsigned long ulSrcBufferOffs_p,
+					      unsigned long ulDataBlockSize_p)
+{
+
+	tShbLinBuff *pShbLinBuff;
+	unsigned char *pShbLinDataPtr;
+	unsigned char *pDstDataPtr;
+	unsigned long ulBufferDataSize;
+	tShbError ShbError;
+
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+
+	if ((pDstDataBlock_p == NULL) || (ulDataBlockSize_p == 0)) {
+		// nothing to do here
+		ShbError = kShbOk;
+		goto Exit;
+	}
+
+	if (ulDataBlockSize_p > SBL_MAX_BLOCK_SIZE) {
+		ShbError = kShbExceedDataSizeLimit;
+		goto Exit;
+	}
+
+	pShbLinBuff = ShbLinGetBuffer(pShbInstance_p);
+	pDstDataPtr = (unsigned char *)pDstDataBlock_p;
+	ShbError = kShbOk;
+
+	if (pShbLinBuff->m_ShbLinMagicID != SBL_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	// check if offeset and size for the read operation matches with
+	// the size of the shared buffer
+	ulBufferDataSize = pShbLinBuff->m_ulBufferDataSize;
+	if ((ulSrcBufferOffs_p > ulBufferDataSize) ||
+	    (ulDataBlockSize_p > ulBufferDataSize) ||
+	    ((ulSrcBufferOffs_p + ulDataBlockSize_p) > ulBufferDataSize)) {
+		ShbError = kShbDataOutsideBufferArea;
+		goto Exit;
+	}
+
+	// copy the data to the linear buffer
+	// (the copy process will be done inside of any critical/locked section)
+	pShbLinDataPtr = &pShbLinBuff->m_Data;	// ptr to start of data area
+	pShbLinDataPtr += ulSrcBufferOffs_p;
+
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		memcpy(pDstDataPtr, pShbLinDataPtr, ulDataBlockSize_p);
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
 
-Exit:
+      Exit:
 
-    return (ShbError);
+	return (ShbError);
 
 }
 
 #endif
 
-
 #if !defined(INLINE_ENABLED)
 
-
 //---------------------------------------------------------------------------
 //  DEBUG: Trace Linear Shared Buffer
 //---------------------------------------------------------------------------
 
 #ifndef NDEBUG
-tShbError  ShbLinTraceBuffer (
-    tShbInstance pShbInstance_p)
+tShbError ShbLinTraceBuffer(tShbInstance pShbInstance_p)
 {
 
-tShbLinBuff*  pShbLinBuff;
-char          szMagigID[sizeof(SBL_MAGIC_ID)+1];
-tShbError     ShbError;
-
-
-    TRACE0("\n\n##### Linear Shared Buffer #####\n");
-
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        TRACE1("\nERROR: invalid buffer address (0x%08lX)\n", (unsigned long)pShbInstance_p);
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-
-
-    pShbLinBuff = ShbLinGetBuffer (pShbInstance_p);
-    ShbError    = kShbOk;
-
-    if (pShbLinBuff->m_ShbLinMagicID != SBL_MAGIC_ID)
-    {
-        ShbError = kShbInvalidBufferType;
-        goto Exit;
-    }
-
+	tShbLinBuff *pShbLinBuff;
+	char szMagigID[sizeof(SBL_MAGIC_ID) + 1];
+	tShbError ShbError;
+
+	TRACE0("\n\n##### Linear Shared Buffer #####\n");
+
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		TRACE1("\nERROR: invalid buffer address (0x%08lX)\n",
+		       (unsigned long)pShbInstance_p);
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+
+	pShbLinBuff = ShbLinGetBuffer(pShbInstance_p);
+	ShbError = kShbOk;
+
+	if (pShbLinBuff->m_ShbLinMagicID != SBL_MAGIC_ID) {
+		ShbError = kShbInvalidBufferType;
+		goto Exit;
+	}
+
+	*(unsigned int *)&szMagigID[0] = pShbLinBuff->m_ShbLinMagicID;
+	szMagigID[sizeof(SBL_MAGIC_ID)] = '\0';
+
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		TRACE1("\nBuffer Address:   0x%08lX\n",
+		       (unsigned long)pShbLinBuff);
+
+		TRACE0("\nHeader Info:");
+		TRACE2("\nMagigID:          '%s' (%08X)", szMagigID,
+		       pShbLinBuff->m_ShbLinMagicID);
+		TRACE1("\nBufferTotalSize:  %4lu [Bytes]",
+		       pShbLinBuff->m_ulBufferTotalSize);
+		TRACE1("\nBufferDataSize:   %4lu [Bytes]",
+		       pShbLinBuff->m_ulBufferDataSize);
+
+		ShbTraceDump(&pShbLinBuff->m_Data,
+			     pShbLinBuff->m_ulBufferDataSize, 0x00000000L,
+			     "\nData Area:");
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
 
-    *(unsigned int*) &szMagigID[0] = pShbLinBuff->m_ShbLinMagicID;
-    szMagigID[sizeof(SBL_MAGIC_ID)] = '\0';
+      Exit:
 
-
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        TRACE1("\nBuffer Address:   0x%08lX\n",    (unsigned long)pShbLinBuff);
-
-        TRACE0("\nHeader Info:");
-        TRACE2("\nMagigID:          '%s' (%08X)", szMagigID, pShbLinBuff->m_ShbLinMagicID);
-        TRACE1("\nBufferTotalSize:  %4lu [Bytes]", pShbLinBuff->m_ulBufferTotalSize);
-        TRACE1("\nBufferDataSize:   %4lu [Bytes]", pShbLinBuff->m_ulBufferDataSize);
-
-        ShbTraceDump (&pShbLinBuff->m_Data, pShbLinBuff->m_ulBufferDataSize,
-                      0x00000000L, "\nData Area:");
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
-
-
-
-Exit:
-
-    return (ShbError);
+	return (ShbError);
 
 }
 #endif
 
-
-
-
-
 //---------------------------------------------------------------------------
 //  Dump buffer contents
 //---------------------------------------------------------------------------
 
 #ifndef NDEBUG
-tShbError  ShbTraceDump (
-    const unsigned char* pabStartAddr_p,
-    unsigned long ulDataSize_p,
-    unsigned long ulAddrOffset_p,
-    const char* pszInfoText_p)
-{
-
-const unsigned char*  pabBuffData;
-unsigned long         ulBuffSize;
-unsigned char         bData;
-int                   nRow;
-int                   nCol;
-
-
-    // get pointer to buffer and length of buffer
-    pabBuffData = pabStartAddr_p;
-    ulBuffSize  = ulDataSize_p;
-
-
-    if (pszInfoText_p != NULL)
-    {
-        TRACE0(pszInfoText_p);
-    }
-
-    // dump buffer contents
-    for (nRow=0; ; nRow++)
-    {
-        TRACE1("\n%08lX:   ", (unsigned long)(nRow*0x10) + ulAddrOffset_p);
-
-        for (nCol=0; nCol<16; nCol++)
-        {
-            if ((unsigned long)nCol < ulBuffSize)
-            {
-                TRACE1("%02X ", (unsigned int)*(pabBuffData+nCol));
-            }
-            else
-            {
-                TRACE0("   ");
-            }
-        }
-
-        TRACE0(" ");
-
-        for (nCol=0; nCol<16; nCol++)
-        {
-            bData = *pabBuffData++;
-            if ((unsigned long)nCol < ulBuffSize)
-            {
-                if ((bData >= 0x20) && (bData < 0x7F))
-                {
-                    TRACE1("%c", bData);
-                }
-                else
-                {
-                    TRACE0(".");
-                }
-            }
-            else
-            {
-                TRACE0(" ");
-            }
-        }
-
-        if (ulBuffSize > 16)
-        {
-            ulBuffSize -= 16;
-        }
-        else
-        {
-            break;
-        }
-    }
-
+tShbError ShbTraceDump(const unsigned char *pabStartAddr_p,
+		       unsigned long ulDataSize_p,
+		       unsigned long ulAddrOffset_p, const char *pszInfoText_p)
+{
+
+	const unsigned char *pabBuffData;
+	unsigned long ulBuffSize;
+	unsigned char bData;
+	int nRow;
+	int nCol;
+
+	// get pointer to buffer and length of buffer
+	pabBuffData = pabStartAddr_p;
+	ulBuffSize = ulDataSize_p;
+
+	if (pszInfoText_p != NULL) {
+		TRACE0(pszInfoText_p);
+	}
+	// dump buffer contents
+	for (nRow = 0;; nRow++) {
+		TRACE1("\n%08lX:   ",
+		       (unsigned long)(nRow * 0x10) + ulAddrOffset_p);
+
+		for (nCol = 0; nCol < 16; nCol++) {
+			if ((unsigned long)nCol < ulBuffSize) {
+				TRACE1("%02X ",
+				       (unsigned int)*(pabBuffData + nCol));
+			} else {
+				TRACE0("   ");
+			}
+		}
+
+		TRACE0(" ");
+
+		for (nCol = 0; nCol < 16; nCol++) {
+			bData = *pabBuffData++;
+			if ((unsigned long)nCol < ulBuffSize) {
+				if ((bData >= 0x20) && (bData < 0x7F)) {
+					TRACE1("%c", bData);
+				} else {
+					TRACE0(".");
+				}
+			} else {
+				TRACE0(" ");
+			}
+		}
+
+		if (ulBuffSize > 16) {
+			ulBuffSize -= 16;
+		} else {
+			break;
+		}
+	}
 
-    return (kShbOk);
+	return (kShbOk);
 
 }
-#endif  // #ifndef NDEBUG
-
-
-
-
-
-
+#endif // #ifndef NDEBUG
 
 //=========================================================================//
 //                                                                         //
@@ -1914,128 +1692,108 @@ int                   nCol;
 //  Handler to signal new data event for Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-int  ShbCirSignalHandlerNewData (
-    tShbInstance pShbInstance_p)
+int ShbCirSignalHandlerNewData(tShbInstance pShbInstance_p)
 {
 
-tShbCirBuff*   pShbCirBuff;
-unsigned long  ulDataSize;
-unsigned long  ulBlockCount;
-tShbError      ShbError;
-
+	tShbCirBuff *pShbCirBuff;
+	unsigned long ulDataSize;
+	unsigned long ulBlockCount;
+	tShbError ShbError;
 
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        return FALSE;
-    }
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		return FALSE;
+	}
 
-    pShbCirBuff = ShbCirGetBuffer (pShbInstance_p);
-    ShbError    = kShbOk;
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	ShbError = kShbOk;
 
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        return FALSE;
-    }
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		return FALSE;
+	}
 
-
-    // call application handler
-    if (pShbCirBuff->m_pfnSigHndlrNewData != NULL)
-    {
+	// call application handler
+	if (pShbCirBuff->m_pfnSigHndlrNewData != NULL) {
 /*        do
         {*/
-            ShbError = ShbCirGetReadDataSize (pShbInstance_p, &ulDataSize);
-            if ((ulDataSize > 0) && (ShbError == kShbOk))
-            {
-                pShbCirBuff->m_pfnSigHndlrNewData (pShbInstance_p, ulDataSize);
-            }
+		ShbError = ShbCirGetReadDataSize(pShbInstance_p, &ulDataSize);
+		if ((ulDataSize > 0) && (ShbError == kShbOk)) {
+			pShbCirBuff->m_pfnSigHndlrNewData(pShbInstance_p,
+							  ulDataSize);
+		}
 
-            ShbError = ShbCirGetReadBlockCount (pShbInstance_p, &ulBlockCount);
+		ShbError =
+		    ShbCirGetReadBlockCount(pShbInstance_p, &ulBlockCount);
 /*        }
         while ((ulBlockCount > 0) && (ShbError == kShbOk));*/
-    }
-
-    // Return TRUE if there are pending blocks.
-    // In that case ShbIpc tries to call this function again immediately if there
-    // is no other filled shared buffer with higher priority.
-    return ((ulBlockCount > 0) && (ShbError == kShbOk));
+	}
+	// Return TRUE if there are pending blocks.
+	// In that case ShbIpc tries to call this function again immediately if there
+	// is no other filled shared buffer with higher priority.
+	return ((ulBlockCount > 0) && (ShbError == kShbOk));
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Handler to reset Circular Shared Buffer
 //---------------------------------------------------------------------------
 
-void  ShbCirSignalHandlerReset (
-    tShbInstance pShbInstance_p,
-    unsigned int fTimeOut_p)
-{
-
-tShbCirBuff*  pShbCirBuff;
-
-
-    // check arguments
-    if (pShbInstance_p == NULL)
-    {
-        return;
-    }
-
-    pShbCirBuff = ShbCirGetBuffer (pShbInstance_p);
-    if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID)
-    {
-        return;
-    }
-
-
-    // reset buffer header
-    if ( !fTimeOut_p )
-    {
-        ShbIpcEnterAtomicSection (pShbInstance_p);
-        {
-            pShbCirBuff->m_ulWrIndex        = 0;
-            pShbCirBuff->m_ulRdIndex        = 0;
-            pShbCirBuff->m_ulNumOfWriteJobs = 0;
-            pShbCirBuff->m_ulDataInUse      = 0;
-            pShbCirBuff->m_ulDataApended    = 0;
-            pShbCirBuff->m_ulBlocksApended  = 0;
-            pShbCirBuff->m_ulDataReadable   = 0;
-            pShbCirBuff->m_ulBlocksReadable = 0;
-        }
-        ShbIpcLeaveAtomicSection (pShbInstance_p);
-
-
-        #ifndef NDEBUG
-        {
-            memset (&pShbCirBuff->m_Data, 0xCC, pShbCirBuff->m_ulBufferDataSize);
-        }
-        #endif
-    }
-
-
-    // call application handler
-    if (pShbCirBuff->m_pfnSigHndlrReset != NULL)
-    {
-        pShbCirBuff->m_pfnSigHndlrReset (pShbInstance_p, fTimeOut_p);
-    }
-
-
-    // unlock buffer
-    ShbIpcEnterAtomicSection (pShbInstance_p);
-    {
-        pShbCirBuff->m_fBufferLocked    = FALSE;
-        pShbCirBuff->m_pfnSigHndlrReset = NULL;
-    }
-    ShbIpcLeaveAtomicSection (pShbInstance_p);
+void ShbCirSignalHandlerReset(tShbInstance pShbInstance_p,
+			      unsigned int fTimeOut_p)
+{
+
+	tShbCirBuff *pShbCirBuff;
+
+	// check arguments
+	if (pShbInstance_p == NULL) {
+		return;
+	}
+
+	pShbCirBuff = ShbCirGetBuffer(pShbInstance_p);
+	if (pShbCirBuff->m_ShbCirMagicID != SBC_MAGIC_ID) {
+		return;
+	}
+
+	// reset buffer header
+	if (!fTimeOut_p) {
+		ShbIpcEnterAtomicSection(pShbInstance_p);
+		{
+			pShbCirBuff->m_ulWrIndex = 0;
+			pShbCirBuff->m_ulRdIndex = 0;
+			pShbCirBuff->m_ulNumOfWriteJobs = 0;
+			pShbCirBuff->m_ulDataInUse = 0;
+			pShbCirBuff->m_ulDataApended = 0;
+			pShbCirBuff->m_ulBlocksApended = 0;
+			pShbCirBuff->m_ulDataReadable = 0;
+			pShbCirBuff->m_ulBlocksReadable = 0;
+		}
+		ShbIpcLeaveAtomicSection(pShbInstance_p);
 
+#ifndef NDEBUG
+		{
+			memset(&pShbCirBuff->m_Data, 0xCC,
+			       pShbCirBuff->m_ulBufferDataSize);
+		}
+#endif
+	}
+
+	// call application handler
+	if (pShbCirBuff->m_pfnSigHndlrReset != NULL) {
+		pShbCirBuff->m_pfnSigHndlrReset(pShbInstance_p, fTimeOut_p);
+	}
+
+	// unlock buffer
+	ShbIpcEnterAtomicSection(pShbInstance_p);
+	{
+		pShbCirBuff->m_fBufferLocked = FALSE;
+		pShbCirBuff->m_pfnSigHndlrReset = NULL;
+	}
+	ShbIpcLeaveAtomicSection(pShbInstance_p);
 
-    return;
+	return;
 
 }
 
 #endif
 
-
 // EOF
-
--- a/drivers/staging/epl/ShbIpc-LinuxKernel.c
+++ b/drivers/staging/epl/ShbIpc-LinuxKernel.c
@@ -55,7 +55,6 @@
 
 ****************************************************************************/
 
-
 #include "global.h"
 #include "SharedBuff.h"
 #include "ShbIpc.h"
@@ -72,8 +71,6 @@
 #include <linux/wait.h>
 #include <linux/completion.h>
 
-
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -88,26 +85,23 @@
 //  Configuration
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 //  Constant definitions
 //---------------------------------------------------------------------------
 
 #define MAX_LEN_BUFFER_ID       256
 
-#define TIMEOUT_ENTER_ATOMIC    1000        // (ms) for debgging: INFINITE
+#define TIMEOUT_ENTER_ATOMIC    1000	// (ms) for debgging: INFINITE
 #define TIMEOUT_TERM_THREAD     1000
 #define INFINITE                3600
 
-#define SBI_MAGIC_ID            0x5342492B  // magic ID ("SBI+")
-#define SBH_MAGIC_ID            0x5342482A  // magic ID ("SBH*")
+#define SBI_MAGIC_ID            0x5342492B	// magic ID ("SBI+")
+#define SBH_MAGIC_ID            0x5342482A	// magic ID ("SBH*")
 
 #define INVALID_ID              -1
 
 #define TABLE_SIZE              10
 
-
 //---------------------------------------------------------------------------
 //  Local types
 //---------------------------------------------------------------------------
@@ -118,26 +112,23 @@
 // separated processes (e.g. the refernce counter). This structure is
 // located at the start of the shared memory region itself and exists
 // consequently only one times per shared memory instance.
-typedef struct
-{
+typedef struct {
 
-    unsigned long       m_ulShMemSize;
-    unsigned long       m_ulRefCount;
-    int                 m_iBufferId;
+	unsigned long m_ulShMemSize;
+	unsigned long m_ulRefCount;
+	int m_iBufferId;
 //    int                 m_iUserSpaceMem;           //0 for userspace mem   !=0 kernelspace mem
-    spinlock_t          m_SpinlockBuffAccess;
-    BOOL                m_fNewData;
-    BOOL                m_fJobReady;
-    wait_queue_head_t   m_WaitQueueNewData;
-    wait_queue_head_t   m_WaitQueueJobReady;
-
-    #ifndef NDEBUG
-        unsigned long   m_ulOwnerProcID;
-    #endif
-
-} tShbMemHeader;
+	spinlock_t m_SpinlockBuffAccess;
+	BOOL m_fNewData;
+	BOOL m_fJobReady;
+	wait_queue_head_t m_WaitQueueNewData;
+	wait_queue_head_t m_WaitQueueJobReady;
 
+#ifndef NDEBUG
+	unsigned long m_ulOwnerProcID;
+#endif
 
+} tShbMemHeader;
 
 // This structure is the "external entry point" from a separate process
 // to get access to a shared buffer. This structure includes all platform
@@ -148,34 +139,32 @@ typedef struct
 // owner process only). The structure member <m_pShbMemHeader> points
 // to the (process specific) start address of the shared memory region
 // itself.
-typedef struct
-{
-    unsigned long       m_SbiMagicID;           // magic ID ("SBI+")
+typedef struct {
+	unsigned long m_SbiMagicID;	// magic ID ("SBI+")
 //    void*               m_pSharedMem;
-    int                 m_tThreadNewDataId;
-    long                m_lThreadNewDataNice;   // nice value of the new data thread
-    int                 m_tThreadJobReadyId;
-    unsigned long       m_ulFlagsBuffAccess;    // d.k. moved from tShbMemHeader, because each
-                                                // process needs to store the interrupt flags separately
-    tSigHndlrNewData    m_pfnSigHndlrNewData;
-    unsigned long       m_ulTimeOutJobReady;
-    tSigHndlrJobReady   m_pfnSigHndlrJobReady;
-    tShbMemHeader*      m_pShbMemHeader;
-    int                 m_iThreadTermFlag;
-    struct completion   m_CompletionNewData;
+	int m_tThreadNewDataId;
+	long m_lThreadNewDataNice;	// nice value of the new data thread
+	int m_tThreadJobReadyId;
+	unsigned long m_ulFlagsBuffAccess;	// d.k. moved from tShbMemHeader, because each
+	// process needs to store the interrupt flags separately
+	tSigHndlrNewData m_pfnSigHndlrNewData;
+	unsigned long m_ulTimeOutJobReady;
+	tSigHndlrJobReady m_pfnSigHndlrJobReady;
+	tShbMemHeader *m_pShbMemHeader;
+	int m_iThreadTermFlag;
+	struct completion m_CompletionNewData;
 /*
     struct semaphore    *m_pSemBuffAccess;
     struct semaphore    *m_pSemNewData;
     struct semaphore    *m_pSemStopSignalingNewData;
     struct semaphore    *m_pSemJobReady;
 */
-    #ifndef NDEBUG
-        unsigned long   m_ulThreadIDNewData;
-        unsigned long   m_ulThreadIDJobReady;
-    #endif
+#ifndef NDEBUG
+	unsigned long m_ulThreadIDNewData;
+	unsigned long m_ulThreadIDJobReady;
+#endif
 } tShbMemInst;
 
-
 //---------------------------------------------------------------------------
 //  Prototypes of internal functions
 //---------------------------------------------------------------------------
@@ -187,36 +176,29 @@ typedef struct
 //  Get pointer to process local information structure
 //---------------------------------------------------------------------------
 
-static inline tShbMemInst*  ShbIpcGetShbMemInst (
-    tShbInstance pShbInstance_p)
+static inline tShbMemInst *ShbIpcGetShbMemInst(tShbInstance pShbInstance_p)
 {
 
-tShbMemInst*  pShbMemInst;
-
-
-    pShbMemInst = (tShbMemInst*)pShbInstance_p;
+	tShbMemInst *pShbMemInst;
 
+	pShbMemInst = (tShbMemInst *) pShbInstance_p;
 
-    return (pShbMemInst);
+	return (pShbMemInst);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Get pointer to shared memory header
 //---------------------------------------------------------------------------
 
-static inline tShbMemHeader*  ShbIpcGetShbMemHeader (
-    tShbMemInst* pShbMemInst_p)
+static inline tShbMemHeader *ShbIpcGetShbMemHeader(tShbMemInst * pShbMemInst_p)
 {
 
-tShbMemHeader*  pShbMemHeader;
+	tShbMemHeader *pShbMemHeader;
 
+	pShbMemHeader = pShbMemInst_p->m_pShbMemHeader;
 
-    pShbMemHeader = pShbMemInst_p->m_pShbMemHeader;
-
-    return (pShbMemHeader);
+	return (pShbMemHeader);
 
 }
 
@@ -227,8 +209,8 @@ tShbMemHeader*  pShbMemHeader;
 //#define ShbIpcGetShbMemHeader(pShbMemInst_p) (pShbMemInst_p->m_pShbMemHeader)
 
 // not inlined internal functions
-int                     ShbIpcThreadSignalNewData   (void* pvThreadParam_p);
-int                     ShbIpcThreadSignalJobReady  (void* pvThreadParam_p);
+int ShbIpcThreadSignalNewData(void *pvThreadParam_p);
+int ShbIpcThreadSignalJobReady(void *pvThreadParam_p);
 #endif
 
 //---------------------------------------------------------------------------
@@ -238,16 +220,18 @@ int                     ShbIpcThreadSign
 #if !defined(SHBIPC_INLINE_ENABLED)
 struct sShbMemTable *psMemTableElementFirst_g;
 
-static void*            ShbIpcAllocPrivateMem       (unsigned long ulMemSize_p);
-static int              ShbIpcFindListElement       (int iBufferId, struct sShbMemTable **ppsReturnMemTableElement);
-static void             ShbIpcAppendListElement     (struct sShbMemTable *sNewMemTableElement);
-static void             ShbIpcDeleteListElement     (int iBufferId);
-static void             ShbIpcCrc32GenTable         (unsigned long aulCrcTable[256]);
-static unsigned long    ShbIpcCrc32GetCrc           (const char *pcString, unsigned long aulCrcTable[256]);
+static void *ShbIpcAllocPrivateMem(unsigned long ulMemSize_p);
+static int ShbIpcFindListElement(int iBufferId,
+				 struct sShbMemTable
+				 **ppsReturnMemTableElement);
+static void ShbIpcAppendListElement(struct sShbMemTable *sNewMemTableElement);
+static void ShbIpcDeleteListElement(int iBufferId);
+static void ShbIpcCrc32GenTable(unsigned long aulCrcTable[256]);
+static unsigned long ShbIpcCrc32GetCrc(const char *pcString,
+				       unsigned long aulCrcTable[256]);
 
 #endif
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -261,497 +245,466 @@ static unsigned long    ShbIpcCrc32GetCr
 //  Initialize IPC for Shared Buffer Module
 //---------------------------------------------------------------------------
 
-tShbError  ShbIpcInit (void)
+tShbError ShbIpcInit(void)
 {
-    psMemTableElementFirst_g = NULL;
-    return (kShbOk);
+	psMemTableElementFirst_g = NULL;
+	return (kShbOk);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Deinitialize IPC for Shared Buffer Module
 //---------------------------------------------------------------------------
 
-tShbError  ShbIpcExit (void)
+tShbError ShbIpcExit(void)
 {
 
-    return (kShbOk);
+	return (kShbOk);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Allocate Shared Buffer
 //---------------------------------------------------------------------------
 
-tShbError  ShbIpcAllocBuffer (
-    unsigned long ulBufferSize_p,
-    const char* pszBufferID_p,
-    tShbInstance* ppShbInstance_p,
-    unsigned int* pfShbNewCreated_p)
-{
-tShbError               ShbError;
-int                     iBufferId=0;
-unsigned long           ulCrc32=0;
-unsigned int            uiFirstProcess=0;
-unsigned long           ulShMemSize;
-tShbMemHeader*          pShbMemHeader;
-tShbMemInst*            pShbMemInst=NULL;
-tShbInstance            pShbInstance;
-unsigned int            fShMemNewCreated=FALSE;
-void                    *pSharedMem=NULL;
-unsigned long           aulCrcTable[256];
-struct sShbMemTable     *psMemTableElement;
-
-
-    DEBUG_LVL_29_TRACE0("ShbIpcAllocBuffer \n");
-    ulShMemSize      = ulBufferSize_p + sizeof(tShbMemHeader);
-
-    //create Buffer ID
-    ShbIpcCrc32GenTable(aulCrcTable);
-    ulCrc32=ShbIpcCrc32GetCrc(pszBufferID_p,aulCrcTable);
-    iBufferId=ulCrc32;
-    DEBUG_LVL_29_TRACE2("ShbIpcAllocBuffer BufferSize:%d sizeof(tShb..):%d\n",ulBufferSize_p,sizeof(tShbMemHeader));
-    DEBUG_LVL_29_TRACE2("ShbIpcAllocBuffer BufferId:%d MemSize:%d\n",iBufferId,ulShMemSize);
-    //---------------------------------------------------------------
-    // (1) open an existing or create a new shared memory
-    //---------------------------------------------------------------
-    //test if buffer already exists
-    if (ShbIpcFindListElement(iBufferId, &psMemTableElement) == 0)
-    {
-        //Buffer already exists
-        fShMemNewCreated=FALSE;
-        pSharedMem = psMemTableElement->m_pBuffer;
-        DEBUG_LVL_29_TRACE1("ShbIpcAllocBuffer attach Buffer at:%p Id:%d\n",pSharedMem);
-        uiFirstProcess=1;
-    }
-    else
-    {
-        //create new Buffer
-        fShMemNewCreated = TRUE;
-        uiFirstProcess=0;
-        pSharedMem = kmalloc(ulShMemSize,GFP_KERNEL);
-        DEBUG_LVL_29_TRACE2("ShbIpcAllocBuffer Create New Buffer at:%p Id:%d\n",pSharedMem,iBufferId);
-        if (pSharedMem == NULL)
-        {
-            //unable to create mem
-            ShbError = kShbOutOfMem;
-            goto Exit;
-        }
-        DEBUG_LVL_29_TRACE0("ShbIpcAllocBuffer create semas\n");
-        // append Element to Mem Table
-        psMemTableElement = kmalloc(sizeof(struct sShbMemTable),GFP_KERNEL);
-        psMemTableElement->m_iBufferId = iBufferId;
-        psMemTableElement->m_pBuffer = pSharedMem;
-        psMemTableElement->m_psNextMemTableElement = NULL;
-        ShbIpcAppendListElement (psMemTableElement);
-    }
-
-    DEBUG_LVL_29_TRACE0("ShbIpcAllocBuffer update header\n");
-    //update header
-    pShbMemHeader = (tShbMemHeader*)pSharedMem;
-    DEBUG_LVL_29_TRACE1("ShbIpcAllocBuffer 0 pShbMemHeader->m_ulShMemSize: %d\n",pShbMemHeader->m_ulShMemSize);
-    // allocate a memory block from process specific mempool to save
-    // process local information to administrate/manage the shared buffer
-    DEBUG_LVL_29_TRACE0("ShbIpcAllocBuffer alloc private mem\n");
-    pShbMemInst = (tShbMemInst*) ShbIpcAllocPrivateMem (sizeof(tShbMemInst));
-    if (pShbMemInst == NULL)
-    {
-        ShbError = kShbOutOfMem;
-        goto Exit;
-    }
-
-    // reset complete header to default values
-    //pShbMemInst->m_SbiMagicID                             = SBI_MAGIC_ID;
+tShbError ShbIpcAllocBuffer(unsigned long ulBufferSize_p,
+			    const char *pszBufferID_p,
+			    tShbInstance * ppShbInstance_p,
+			    unsigned int *pfShbNewCreated_p)
+{
+	tShbError ShbError;
+	int iBufferId = 0;
+	unsigned long ulCrc32 = 0;
+	unsigned int uiFirstProcess = 0;
+	unsigned long ulShMemSize;
+	tShbMemHeader *pShbMemHeader;
+	tShbMemInst *pShbMemInst = NULL;
+	tShbInstance pShbInstance;
+	unsigned int fShMemNewCreated = FALSE;
+	void *pSharedMem = NULL;
+	unsigned long aulCrcTable[256];
+	struct sShbMemTable *psMemTableElement;
+
+	DEBUG_LVL_29_TRACE0("ShbIpcAllocBuffer \n");
+	ulShMemSize = ulBufferSize_p + sizeof(tShbMemHeader);
+
+	//create Buffer ID
+	ShbIpcCrc32GenTable(aulCrcTable);
+	ulCrc32 = ShbIpcCrc32GetCrc(pszBufferID_p, aulCrcTable);
+	iBufferId = ulCrc32;
+	DEBUG_LVL_29_TRACE2
+	    ("ShbIpcAllocBuffer BufferSize:%d sizeof(tShb..):%d\n",
+	     ulBufferSize_p, sizeof(tShbMemHeader));
+	DEBUG_LVL_29_TRACE2("ShbIpcAllocBuffer BufferId:%d MemSize:%d\n",
+			    iBufferId, ulShMemSize);
+	//---------------------------------------------------------------
+	// (1) open an existing or create a new shared memory
+	//---------------------------------------------------------------
+	//test if buffer already exists
+	if (ShbIpcFindListElement(iBufferId, &psMemTableElement) == 0) {
+		//Buffer already exists
+		fShMemNewCreated = FALSE;
+		pSharedMem = psMemTableElement->m_pBuffer;
+		DEBUG_LVL_29_TRACE1
+		    ("ShbIpcAllocBuffer attach Buffer at:%p Id:%d\n",
+		     pSharedMem);
+		uiFirstProcess = 1;
+	} else {
+		//create new Buffer
+		fShMemNewCreated = TRUE;
+		uiFirstProcess = 0;
+		pSharedMem = kmalloc(ulShMemSize, GFP_KERNEL);
+		DEBUG_LVL_29_TRACE2
+		    ("ShbIpcAllocBuffer Create New Buffer at:%p Id:%d\n",
+		     pSharedMem, iBufferId);
+		if (pSharedMem == NULL) {
+			//unable to create mem
+			ShbError = kShbOutOfMem;
+			goto Exit;
+		}
+		DEBUG_LVL_29_TRACE0("ShbIpcAllocBuffer create semas\n");
+		// append Element to Mem Table
+		psMemTableElement =
+		    kmalloc(sizeof(struct sShbMemTable), GFP_KERNEL);
+		psMemTableElement->m_iBufferId = iBufferId;
+		psMemTableElement->m_pBuffer = pSharedMem;
+		psMemTableElement->m_psNextMemTableElement = NULL;
+		ShbIpcAppendListElement(psMemTableElement);
+	}
+
+	DEBUG_LVL_29_TRACE0("ShbIpcAllocBuffer update header\n");
+	//update header
+	pShbMemHeader = (tShbMemHeader *) pSharedMem;
+	DEBUG_LVL_29_TRACE1
+	    ("ShbIpcAllocBuffer 0 pShbMemHeader->m_ulShMemSize: %d\n",
+	     pShbMemHeader->m_ulShMemSize);
+	// allocate a memory block from process specific mempool to save
+	// process local information to administrate/manage the shared buffer
+	DEBUG_LVL_29_TRACE0("ShbIpcAllocBuffer alloc private mem\n");
+	pShbMemInst =
+	    (tShbMemInst *) ShbIpcAllocPrivateMem(sizeof(tShbMemInst));
+	if (pShbMemInst == NULL) {
+		ShbError = kShbOutOfMem;
+		goto Exit;
+	}
+	// reset complete header to default values
+	//pShbMemInst->m_SbiMagicID                             = SBI_MAGIC_ID;
 //    pShbMemInst->m_pSharedMem                               = pSharedMem;
-    pShbMemInst->m_tThreadNewDataId                         = INVALID_ID;
-    pShbMemInst->m_tThreadJobReadyId                        = INVALID_ID;
-    pShbMemInst->m_pfnSigHndlrNewData                       = NULL;
-    pShbMemInst->m_ulTimeOutJobReady                        = 0;
-    pShbMemInst->m_pfnSigHndlrJobReady                      = NULL;
-    pShbMemInst->m_pShbMemHeader                            = pShbMemHeader;
-    pShbMemInst->m_iThreadTermFlag                          = 0;
-
-    // initialize completion etc.
-    init_completion(&pShbMemInst->m_CompletionNewData);
-
-    ShbError         = kShbOk;
-    if ( fShMemNewCreated )
-    {
-        // this process was the first who wanted to use the shared memory,
-        // so a new shared memory was created
-        // -> setup new header information inside the shared memory region
-        //    itself
-        pShbMemHeader->m_ulShMemSize = ulShMemSize;
-        pShbMemHeader->m_ulRefCount  = 1;
-        pShbMemHeader->m_iBufferId=iBufferId;
-        // initialize spinlock
-        spin_lock_init(&pShbMemHeader->m_SpinlockBuffAccess);
-        // initialize wait queues
-        init_waitqueue_head(&pShbMemHeader->m_WaitQueueNewData);
-        init_waitqueue_head(&pShbMemHeader->m_WaitQueueJobReady);
-    }
-    else
-    {
-        // any other process has created the shared memory and this
-        // process only has to attach to it
-        // -> check and update existing header information inside the
-        //    shared memory region itself
-        if (pShbMemHeader->m_ulShMemSize != ulShMemSize)
-        {
-            ShbError = kShbOpenMismatch;
-            goto Exit;
-        }
-        pShbMemHeader->m_ulRefCount++;
-    }
-
-    Exit:
-    pShbInstance = (tShbInstance*)pShbMemInst;
-    *pfShbNewCreated_p = fShMemNewCreated;
-    *ppShbInstance_p   = pShbInstance;
-    return (ShbError);
+	pShbMemInst->m_tThreadNewDataId = INVALID_ID;
+	pShbMemInst->m_tThreadJobReadyId = INVALID_ID;
+	pShbMemInst->m_pfnSigHndlrNewData = NULL;
+	pShbMemInst->m_ulTimeOutJobReady = 0;
+	pShbMemInst->m_pfnSigHndlrJobReady = NULL;
+	pShbMemInst->m_pShbMemHeader = pShbMemHeader;
+	pShbMemInst->m_iThreadTermFlag = 0;
+
+	// initialize completion etc.
+	init_completion(&pShbMemInst->m_CompletionNewData);
+
+	ShbError = kShbOk;
+	if (fShMemNewCreated) {
+		// this process was the first who wanted to use the shared memory,
+		// so a new shared memory was created
+		// -> setup new header information inside the shared memory region
+		//    itself
+		pShbMemHeader->m_ulShMemSize = ulShMemSize;
+		pShbMemHeader->m_ulRefCount = 1;
+		pShbMemHeader->m_iBufferId = iBufferId;
+		// initialize spinlock
+		spin_lock_init(&pShbMemHeader->m_SpinlockBuffAccess);
+		// initialize wait queues
+		init_waitqueue_head(&pShbMemHeader->m_WaitQueueNewData);
+		init_waitqueue_head(&pShbMemHeader->m_WaitQueueJobReady);
+	} else {
+		// any other process has created the shared memory and this
+		// process only has to attach to it
+		// -> check and update existing header information inside the
+		//    shared memory region itself
+		if (pShbMemHeader->m_ulShMemSize != ulShMemSize) {
+			ShbError = kShbOpenMismatch;
+			goto Exit;
+		}
+		pShbMemHeader->m_ulRefCount++;
+	}
+
+      Exit:
+	pShbInstance = (tShbInstance *) pShbMemInst;
+	*pfShbNewCreated_p = fShMemNewCreated;
+	*ppShbInstance_p = pShbInstance;
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Release Shared Buffer
 //---------------------------------------------------------------------------
 
-tShbError  ShbIpcReleaseBuffer (tShbInstance pShbInstance_p)
+tShbError ShbIpcReleaseBuffer(tShbInstance pShbInstance_p)
 {
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-tShbError       ShbError;
-tShbError       ShbError2;
-
-    DEBUG_LVL_26_TRACE1("ShbIpcReleaseBuffer(%p)\n", pShbInstance_p);
-    if (pShbInstance_p == NULL)
-    {
-        return (kShbOk);
-    }
-    pShbMemInst   = ShbIpcGetShbMemInst   (pShbInstance_p);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbMemInst);
-
-    // stop threads in any case, because they are bound to that specific instance
-    ShbError2 = ShbIpcStopSignalingNewData (pShbInstance_p);
-    // d.k.: Whats up with JobReady thread?
-    //       Just wake it up, but without setting the semaphore variable
-    wake_up_interruptible(&pShbMemHeader->m_WaitQueueJobReady);
-
-    if ( !--pShbMemHeader->m_ulRefCount )
-    {
-        ShbError = kShbOk;
-        // delete mem table element
-        ShbIpcDeleteListElement(pShbMemHeader->m_iBufferId);
-        // delete shared mem
-        kfree(pShbMemInst->m_pShbMemHeader);
-    }
-    else
-    {
-        ShbError = kShbMemUsedByOtherProcs;
-    }
-    //delete privat mem
-    kfree(pShbMemInst);
-    return (ShbError);
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	tShbError ShbError;
+	tShbError ShbError2;
+
+	DEBUG_LVL_26_TRACE1("ShbIpcReleaseBuffer(%p)\n", pShbInstance_p);
+	if (pShbInstance_p == NULL) {
+		return (kShbOk);
+	}
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbMemInst);
+
+	// stop threads in any case, because they are bound to that specific instance
+	ShbError2 = ShbIpcStopSignalingNewData(pShbInstance_p);
+	// d.k.: Whats up with JobReady thread?
+	//       Just wake it up, but without setting the semaphore variable
+	wake_up_interruptible(&pShbMemHeader->m_WaitQueueJobReady);
+
+	if (!--pShbMemHeader->m_ulRefCount) {
+		ShbError = kShbOk;
+		// delete mem table element
+		ShbIpcDeleteListElement(pShbMemHeader->m_iBufferId);
+		// delete shared mem
+		kfree(pShbMemInst->m_pShbMemHeader);
+	} else {
+		ShbError = kShbMemUsedByOtherProcs;
+	}
+	//delete privat mem
+	kfree(pShbMemInst);
+	return (ShbError);
 }
 
-
-#endif  // !defined(SHBIPC_INLINE_ENABLED)
+#endif // !defined(SHBIPC_INLINE_ENABLED)
 
 #if (!defined(SHBIPC_INLINED)) || defined(SHBIPC_INLINE_ENABLED)
 
-
 //---------------------------------------------------------------------------
 //  Enter atomic section for Shared Buffer access
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcEnterAtomicSection (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbError ShbIpcEnterAtomicSection(tShbInstance pShbInstance_p)
 {
 
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-tShbError       ShbError = kShbOk;
-
-    if (pShbInstance_p == NULL)
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-    DEBUG_LVL_29_TRACE0("enter atomic\n");
-    pShbMemInst   = ShbIpcGetShbMemInst   (pShbInstance_p);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbMemInst);
-
-    // lock interrupts
-    spin_lock_irqsave(&pShbMemHeader->m_SpinlockBuffAccess, pShbMemInst->m_ulFlagsBuffAccess);
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	tShbError ShbError = kShbOk;
+
+	if (pShbInstance_p == NULL) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+	DEBUG_LVL_29_TRACE0("enter atomic\n");
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbMemInst);
+
+	// lock interrupts
+	spin_lock_irqsave(&pShbMemHeader->m_SpinlockBuffAccess,
+			  pShbMemInst->m_ulFlagsBuffAccess);
 
-Exit:
-    return ShbError;
+      Exit:
+	return ShbError;
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Leave atomic section for Shared Buffer access
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcLeaveAtomicSection (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbError ShbIpcLeaveAtomicSection(tShbInstance pShbInstance_p)
 {
 
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-tShbError       ShbError = kShbOk;
-
-    if (pShbInstance_p == NULL)
-    {
-        ShbError = kShbInvalidArg;
-        goto Exit;
-    }
-    pShbMemInst   = ShbIpcGetShbMemInst   (pShbInstance_p);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbMemInst);
-    // unlock interrupts
-    spin_unlock_irqrestore(&pShbMemHeader->m_SpinlockBuffAccess, pShbMemInst->m_ulFlagsBuffAccess);
-
-Exit:
-    DEBUG_LVL_29_TRACE0("Leave Atomic \n");
-    return ShbError;
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	tShbError ShbError = kShbOk;
+
+	if (pShbInstance_p == NULL) {
+		ShbError = kShbInvalidArg;
+		goto Exit;
+	}
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbMemInst);
+	// unlock interrupts
+	spin_unlock_irqrestore(&pShbMemHeader->m_SpinlockBuffAccess,
+			       pShbMemInst->m_ulFlagsBuffAccess);
+
+      Exit:
+	DEBUG_LVL_29_TRACE0("Leave Atomic \n");
+	return ShbError;
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Start signaling of new data (called from reading process)
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcStartSignalingNewData (
-    tShbInstance pShbInstance_p,
-    tSigHndlrNewData pfnSignalHandlerNewData_p,
-    tShbPriority ShbPriority_p)
-{
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-tShbError       ShbError;
-
-    DEBUG_LVL_29_TRACE0("------->ShbIpcStartSignalingNewData\n");
-    if ((pShbInstance_p == NULL) || (pfnSignalHandlerNewData_p == NULL))
-    {
-        return (kShbInvalidArg);
-    }
-
-    pShbMemInst   = ShbIpcGetShbMemInst   (pShbInstance_p);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbMemInst);
-    ShbError = kShbOk;
-
-    if ((pShbMemInst->m_tThreadNewDataId != INVALID_ID)
-        || (pShbMemInst->m_pfnSigHndlrNewData != NULL))
-    {
-        ShbError = kShbAlreadySignaling;
-        goto Exit;
-    }
-    DEBUG_LVL_26_TRACE2("ShbIpcStartSignalingNewData(%p) m_pfnSigHndlrNewData = %p\n", pShbInstance_p, pfnSignalHandlerNewData_p);
-    pShbMemInst->m_pfnSigHndlrNewData = pfnSignalHandlerNewData_p;
-    pShbMemHeader->m_fNewData = FALSE;
-    pShbMemInst->m_iThreadTermFlag = 0;
-
-    switch (ShbPriority_p)
-    {
-        case kShbPriorityLow:
-            pShbMemInst->m_lThreadNewDataNice = -2;
-            break;
-
-        case kShbPriorityNormal:
-            pShbMemInst->m_lThreadNewDataNice = -9;
-            break;
-
-        case kshbPriorityHigh:
-            pShbMemInst->m_lThreadNewDataNice = -20;
-            break;
-
-    }
-
-    //create thread for signalling new data
-    pShbMemInst->m_tThreadNewDataId = kernel_thread(ShbIpcThreadSignalNewData,pShbInstance_p,CLONE_KERNEL);
+INLINE_FUNCTION tShbError ShbIpcStartSignalingNewData(tShbInstance
+						      pShbInstance_p,
+						      tSigHndlrNewData
+						      pfnSignalHandlerNewData_p,
+						      tShbPriority
+						      ShbPriority_p)
+{
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	tShbError ShbError;
+
+	DEBUG_LVL_29_TRACE0("------->ShbIpcStartSignalingNewData\n");
+	if ((pShbInstance_p == NULL) || (pfnSignalHandlerNewData_p == NULL)) {
+		return (kShbInvalidArg);
+	}
+
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbMemInst);
+	ShbError = kShbOk;
+
+	if ((pShbMemInst->m_tThreadNewDataId != INVALID_ID)
+	    || (pShbMemInst->m_pfnSigHndlrNewData != NULL)) {
+		ShbError = kShbAlreadySignaling;
+		goto Exit;
+	}
+	DEBUG_LVL_26_TRACE2
+	    ("ShbIpcStartSignalingNewData(%p) m_pfnSigHndlrNewData = %p\n",
+	     pShbInstance_p, pfnSignalHandlerNewData_p);
+	pShbMemInst->m_pfnSigHndlrNewData = pfnSignalHandlerNewData_p;
+	pShbMemHeader->m_fNewData = FALSE;
+	pShbMemInst->m_iThreadTermFlag = 0;
+
+	switch (ShbPriority_p) {
+	case kShbPriorityLow:
+		pShbMemInst->m_lThreadNewDataNice = -2;
+		break;
+
+	case kShbPriorityNormal:
+		pShbMemInst->m_lThreadNewDataNice = -9;
+		break;
+
+	case kshbPriorityHigh:
+		pShbMemInst->m_lThreadNewDataNice = -20;
+		break;
+
+	}
+
+	//create thread for signalling new data
+	pShbMemInst->m_tThreadNewDataId =
+	    kernel_thread(ShbIpcThreadSignalNewData, pShbInstance_p,
+			  CLONE_KERNEL);
 
-Exit:
-    return ShbError;
+      Exit:
+	return ShbError;
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Stop signaling of new data (called from reading process)
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcStopSignalingNewData (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbError ShbIpcStopSignalingNewData(tShbInstance
+						     pShbInstance_p)
 {
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-tShbError       ShbError;
-
-    DEBUG_LVL_29_TRACE0("------->ShbIpcStopSignalingNewData\n");
-    if (pShbInstance_p == NULL)
-    {
-        return (kShbInvalidArg);
-    }
-    ShbError = kShbOk;
-    pShbMemInst = ShbIpcGetShbMemInst (pShbInstance_p);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbMemInst);
-
-    DEBUG_LVL_26_TRACE2("ShbIpcStopSignalingNewData(%p) pfnSignHndlrNewData=%p\n", pShbInstance_p, pShbMemInst->m_pfnSigHndlrNewData);
-    if (pShbMemInst->m_pfnSigHndlrNewData != NULL)
-    {   // signal handler was set before
-        int iErr;
-        //set termination flag in mem header
-        pShbMemInst->m_iThreadTermFlag = 1;
-
-        // check if thread is still running at all by sending the null-signal to this thread
-        /* iErr = kill_proc(pShbMemInst->m_tThreadNewDataId, 0, 1); */
-        iErr = send_sig(0, pShbMemInst->m_tThreadNewDataId, 1);
-        if (iErr == 0)
-        {
-            // wake up thread, because it is still running
-            wake_up_interruptible(&pShbMemHeader->m_WaitQueueNewData);
-
-            //wait for termination of thread
-            wait_for_completion(&pShbMemInst->m_CompletionNewData);
-        }
-
-        pShbMemInst->m_pfnSigHndlrNewData = NULL;
-        pShbMemInst->m_tThreadNewDataId = INVALID_ID;
-    }
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	tShbError ShbError;
+
+	DEBUG_LVL_29_TRACE0("------->ShbIpcStopSignalingNewData\n");
+	if (pShbInstance_p == NULL) {
+		return (kShbInvalidArg);
+	}
+	ShbError = kShbOk;
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbMemInst);
+
+	DEBUG_LVL_26_TRACE2
+	    ("ShbIpcStopSignalingNewData(%p) pfnSignHndlrNewData=%p\n",
+	     pShbInstance_p, pShbMemInst->m_pfnSigHndlrNewData);
+	if (pShbMemInst->m_pfnSigHndlrNewData != NULL) {	// signal handler was set before
+		int iErr;
+		//set termination flag in mem header
+		pShbMemInst->m_iThreadTermFlag = 1;
+
+		// check if thread is still running at all by sending the null-signal to this thread
+		/* iErr = kill_proc(pShbMemInst->m_tThreadNewDataId, 0, 1); */
+		iErr = send_sig(0, pShbMemInst->m_tThreadNewDataId, 1);
+		if (iErr == 0) {
+			// wake up thread, because it is still running
+			wake_up_interruptible(&pShbMemHeader->
+					      m_WaitQueueNewData);
+
+			//wait for termination of thread
+			wait_for_completion(&pShbMemInst->m_CompletionNewData);
+		}
+
+		pShbMemInst->m_pfnSigHndlrNewData = NULL;
+		pShbMemInst->m_tThreadNewDataId = INVALID_ID;
+	}
 
-    return ShbError;
+	return ShbError;
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Signal new data (called from writing process)
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcSignalNewData (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbError ShbIpcSignalNewData(tShbInstance pShbInstance_p)
 {
-tShbMemHeader*  pShbMemHeader;
+	tShbMemHeader *pShbMemHeader;
 
-    if (pShbInstance_p == NULL)
-    {
-        return (kShbInvalidArg);
-    }
-    pShbMemHeader = ShbIpcGetShbMemHeader (ShbIpcGetShbMemInst (pShbInstance_p));
-    //set semaphore
-    pShbMemHeader->m_fNewData = TRUE;
-    DEBUG_LVL_29_TRACE0("ShbIpcSignalNewData set Sem -> New Data\n");
+	if (pShbInstance_p == NULL) {
+		return (kShbInvalidArg);
+	}
+	pShbMemHeader =
+	    ShbIpcGetShbMemHeader(ShbIpcGetShbMemInst(pShbInstance_p));
+	//set semaphore
+	pShbMemHeader->m_fNewData = TRUE;
+	DEBUG_LVL_29_TRACE0("ShbIpcSignalNewData set Sem -> New Data\n");
 
-    wake_up_interruptible(&pShbMemHeader->m_WaitQueueNewData);
-    return (kShbOk);
+	wake_up_interruptible(&pShbMemHeader->m_WaitQueueNewData);
+	return (kShbOk);
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Start signaling for job ready (called from waiting process)
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcStartSignalingJobReady (
-    tShbInstance pShbInstance_p,
-    unsigned long ulTimeOut_p,
-    tSigHndlrJobReady pfnSignalHandlerJobReady_p)
-{
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-tShbError       ShbError;
-
-    if ((pShbInstance_p == NULL) || (pfnSignalHandlerJobReady_p == NULL))
-    {
-        return (kShbInvalidArg);
-    }
-    pShbMemInst   = ShbIpcGetShbMemInst   (pShbInstance_p);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbMemInst);
-
-    ShbError = kShbOk;
-    if ((pShbMemInst->m_tThreadJobReadyId != INVALID_ID)||(pShbMemInst->m_pfnSigHndlrJobReady!= NULL))
-    {
-        ShbError = kShbAlreadySignaling;
-        goto Exit;
-    }
-    pShbMemInst->m_ulTimeOutJobReady = ulTimeOut_p;
-    pShbMemInst->m_pfnSigHndlrJobReady = pfnSignalHandlerJobReady_p;
-    pShbMemHeader->m_fJobReady = FALSE;
-    //create thread for signalling new data
-    pShbMemInst->m_tThreadJobReadyId=kernel_thread(ShbIpcThreadSignalJobReady,pShbInstance_p,CLONE_KERNEL);
-    Exit:
-    return ShbError;
+INLINE_FUNCTION tShbError ShbIpcStartSignalingJobReady(tShbInstance
+						       pShbInstance_p,
+						       unsigned long
+						       ulTimeOut_p,
+						       tSigHndlrJobReady
+						       pfnSignalHandlerJobReady_p)
+{
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	tShbError ShbError;
+
+	if ((pShbInstance_p == NULL) || (pfnSignalHandlerJobReady_p == NULL)) {
+		return (kShbInvalidArg);
+	}
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbMemInst);
+
+	ShbError = kShbOk;
+	if ((pShbMemInst->m_tThreadJobReadyId != INVALID_ID)
+	    || (pShbMemInst->m_pfnSigHndlrJobReady != NULL)) {
+		ShbError = kShbAlreadySignaling;
+		goto Exit;
+	}
+	pShbMemInst->m_ulTimeOutJobReady = ulTimeOut_p;
+	pShbMemInst->m_pfnSigHndlrJobReady = pfnSignalHandlerJobReady_p;
+	pShbMemHeader->m_fJobReady = FALSE;
+	//create thread for signalling new data
+	pShbMemInst->m_tThreadJobReadyId =
+	    kernel_thread(ShbIpcThreadSignalJobReady, pShbInstance_p,
+			  CLONE_KERNEL);
+      Exit:
+	return ShbError;
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Signal job ready (called from executing process)
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcSignalJobReady (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbError ShbIpcSignalJobReady(tShbInstance pShbInstance_p)
 {
-tShbMemHeader*  pShbMemHeader;
+	tShbMemHeader *pShbMemHeader;
 
+	DEBUG_LVL_29_TRACE0("ShbIpcSignalJobReady\n");
+	if (pShbInstance_p == NULL) {
+		return (kShbInvalidArg);
+	}
+	pShbMemHeader =
+	    ShbIpcGetShbMemHeader(ShbIpcGetShbMemInst(pShbInstance_p));
+	//set semaphore
+	pShbMemHeader->m_fJobReady = TRUE;
+	DEBUG_LVL_29_TRACE0("ShbIpcSignalJobReady set Sem -> Job Ready \n");
 
-    DEBUG_LVL_29_TRACE0("ShbIpcSignalJobReady\n");
-    if (pShbInstance_p == NULL)
-    {
-        return (kShbInvalidArg);
-    }
-    pShbMemHeader = ShbIpcGetShbMemHeader (ShbIpcGetShbMemInst (pShbInstance_p));
-    //set semaphore
-    pShbMemHeader->m_fJobReady = TRUE;
-    DEBUG_LVL_29_TRACE0("ShbIpcSignalJobReady set Sem -> Job Ready \n");
-
-    wake_up_interruptible(&pShbMemHeader->m_WaitQueueJobReady);
-    return (kShbOk);
+	wake_up_interruptible(&pShbMemHeader->m_WaitQueueJobReady);
+	return (kShbOk);
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Get pointer to common used share memory area
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void*  ShbIpcGetShMemPtr (tShbInstance pShbInstance_p)
+INLINE_FUNCTION void *ShbIpcGetShMemPtr(tShbInstance pShbInstance_p)
 {
 
-tShbMemHeader*  pShbMemHeader;
-void*  pShbShMemPtr;
-
+	tShbMemHeader *pShbMemHeader;
+	void *pShbShMemPtr;
 
-    pShbMemHeader = ShbIpcGetShbMemHeader (ShbIpcGetShbMemInst (pShbInstance_p));
-    if (pShbMemHeader != NULL)
-    {
-        pShbShMemPtr = (BYTE*)pShbMemHeader + sizeof(tShbMemHeader);
-    }
-    else
-    {
-        pShbShMemPtr = NULL;
-    }
+	pShbMemHeader =
+	    ShbIpcGetShbMemHeader(ShbIpcGetShbMemInst(pShbInstance_p));
+	if (pShbMemHeader != NULL) {
+		pShbShMemPtr = (BYTE *) pShbMemHeader + sizeof(tShbMemHeader);
+	} else {
+		pShbShMemPtr = NULL;
+	}
 
-    return (pShbShMemPtr);
+	return (pShbShMemPtr);
 
 }
 
 #endif
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -770,16 +723,13 @@ void*  pShbShMemPtr;
 
 tShbMemInst*  pShbMemInst;
 
-
     pShbMemInst = (tShbMemInst*)pShbInstance_p;
 
-
     return (pShbMemInst);
 
 }
 */
 
-
 //---------------------------------------------------------------------------
 //  Get pointer to shared memory header
 //---------------------------------------------------------------------------
@@ -790,7 +740,6 @@ tShbMemInst*  pShbMemInst;
 
 tShbMemHeader*  pShbMemHeader;
 
-
     pShbMemHeader = pShbMemInst_p->m_pShbMemHeader;
 
     return (pShbMemHeader);
@@ -798,233 +747,219 @@ tShbMemHeader*  pShbMemHeader;
 }
 */
 
-
 //---------------------------------------------------------------------------
 //  Allocate a memory block from process specific mempool
 //---------------------------------------------------------------------------
 
-static void*  ShbIpcAllocPrivateMem (unsigned long ulMemSize_p)
+static void *ShbIpcAllocPrivateMem(unsigned long ulMemSize_p)
 {
-tShbError       ShbError;
-void*           pMem;
+	tShbError ShbError;
+	void *pMem;
 
-    DEBUG_LVL_29_TRACE0("ShbIpcAllocPrivateMem \n");
-    //get private mem
-    pMem = kmalloc(ulMemSize_p, GFP_KERNEL);
-    if (pMem == NULL)
-    {
-        //unable to create mem
-        ShbError = kShbOutOfMem;
-        goto Exit;
-    }
-Exit:
-    return (pMem);
+	DEBUG_LVL_29_TRACE0("ShbIpcAllocPrivateMem \n");
+	//get private mem
+	pMem = kmalloc(ulMemSize_p, GFP_KERNEL);
+	if (pMem == NULL) {
+		//unable to create mem
+		ShbError = kShbOutOfMem;
+		goto Exit;
+	}
+      Exit:
+	return (pMem);
 
 }
 
-
 //---------------------------------------------------------------------------
 //  Thread for new data signaling
 //---------------------------------------------------------------------------
 
-int ShbIpcThreadSignalNewData (void *pvThreadParam_p)
+int ShbIpcThreadSignalNewData(void *pvThreadParam_p)
 {
-tShbInstance    pShbInstance;
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-int             iRetVal=-1;
-int             fCallAgain;
-
-    daemonize("ShbND%p", pvThreadParam_p);
-    allow_signal(SIGTERM);
-    pShbInstance = (tShbMemInst*)pvThreadParam_p;
-    pShbMemInst  = ShbIpcGetShbMemInst (pShbInstance);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbMemInst);
+	tShbInstance pShbInstance;
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	int iRetVal = -1;
+	int fCallAgain;
+
+	daemonize("ShbND%p", pvThreadParam_p);
+	allow_signal(SIGTERM);
+	pShbInstance = (tShbMemInst *) pvThreadParam_p;
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbMemInst);
 
-    DEBUG_LVL_26_TRACE1("ShbIpcThreadSignalNewData(%p)\n",pvThreadParam_p);
+	DEBUG_LVL_26_TRACE1("ShbIpcThreadSignalNewData(%p)\n", pvThreadParam_p);
 
-    set_user_nice(current, pShbMemInst->m_lThreadNewDataNice);
+	set_user_nice(current, pShbMemInst->m_lThreadNewDataNice);
 
 //            DEBUG_LVL_29_TRACE1("ShbIpcThreadSignalNewData wait for New Data Sem %p\n",pShbMemInst->m_pSemNewData);
-    do
-    {
-        iRetVal = wait_event_interruptible(pShbMemHeader->m_WaitQueueNewData,
-            (pShbMemInst->m_iThreadTermFlag != 0) || (pShbMemHeader->m_fNewData != FALSE));
-
-        if (iRetVal != 0)
-        {   // signal pending
-            break;
-        }
-
-        if (pShbMemHeader->m_fNewData != FALSE)
-        {
-            pShbMemHeader->m_fNewData = FALSE;
-            do
-            {
-                fCallAgain = pShbMemInst->m_pfnSigHndlrNewData(pShbInstance);
-                // call scheduler, which will execute any task with higher priority
-                schedule();
-            } while (fCallAgain != FALSE);
-        }
-    } while (pShbMemInst->m_iThreadTermFlag==0);
-    DEBUG_LVL_29_TRACE0("ShbIpcThreadSignalNewData terminated \n");
-    //set thread completed
-    complete_and_exit(&pShbMemInst->m_CompletionNewData, 0);
-    return 0;
+	do {
+		iRetVal =
+		    wait_event_interruptible(pShbMemHeader->m_WaitQueueNewData,
+					     (pShbMemInst->m_iThreadTermFlag !=
+					      0)
+					     || (pShbMemHeader->m_fNewData !=
+						 FALSE));
+
+		if (iRetVal != 0) {	// signal pending
+			break;
+		}
+
+		if (pShbMemHeader->m_fNewData != FALSE) {
+			pShbMemHeader->m_fNewData = FALSE;
+			do {
+				fCallAgain =
+				    pShbMemInst->
+				    m_pfnSigHndlrNewData(pShbInstance);
+				// call scheduler, which will execute any task with higher priority
+				schedule();
+			} while (fCallAgain != FALSE);
+		}
+	} while (pShbMemInst->m_iThreadTermFlag == 0);
+	DEBUG_LVL_29_TRACE0("ShbIpcThreadSignalNewData terminated \n");
+	//set thread completed
+	complete_and_exit(&pShbMemInst->m_CompletionNewData, 0);
+	return 0;
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Thread for new data Job Ready signaling
 //---------------------------------------------------------------------------
 
-int ShbIpcThreadSignalJobReady (void *pvThreadParam_p)
+int ShbIpcThreadSignalJobReady(void *pvThreadParam_p)
 {
-tShbInstance    pShbInstance;
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-long            lTimeOut;
-int             iRetVal=-1;
+	tShbInstance pShbInstance;
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	long lTimeOut;
+	int iRetVal = -1;
+
+	daemonize("ShbJR%p", pvThreadParam_p);
+	allow_signal(SIGTERM);
+	pShbInstance = (tShbMemInst *) pvThreadParam_p;
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbMemInst);
+
+	DEBUG_LVL_29_TRACE0
+	    ("ShbIpcThreadSignalJobReady wait for job ready Sem\n");
+	if (pShbMemInst->m_ulTimeOutJobReady != 0) {
+		lTimeOut = (long)pShbMemInst->m_ulTimeOutJobReady;
+		//wait for job ready semaphore
+		iRetVal =
+		    wait_event_interruptible_timeout(pShbMemHeader->
+						     m_WaitQueueJobReady,
+						     (pShbMemHeader->
+						      m_fJobReady != FALSE),
+						     lTimeOut);
+	} else {
+		//wait for job ready semaphore
+		iRetVal =
+		    wait_event_interruptible(pShbMemHeader->m_WaitQueueJobReady,
+					     (pShbMemHeader->m_fJobReady !=
+					      FALSE));
+	}
+
+	if (pShbMemInst->m_pfnSigHndlrJobReady != NULL) {
+		//call Handler
+		pShbMemInst->m_pfnSigHndlrJobReady(pShbInstance,
+						   !pShbMemHeader->m_fJobReady);
+	}
 
-    daemonize("ShbJR%p", pvThreadParam_p);
-    allow_signal(SIGTERM);
-    pShbInstance = (tShbMemInst*)pvThreadParam_p;
-    pShbMemInst  = ShbIpcGetShbMemInst (pShbInstance);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbMemInst);
-
-    DEBUG_LVL_29_TRACE0("ShbIpcThreadSignalJobReady wait for job ready Sem\n");
-    if (pShbMemInst->m_ulTimeOutJobReady != 0)
-    {
-        lTimeOut = (long) pShbMemInst->m_ulTimeOutJobReady;
-        //wait for job ready semaphore
-        iRetVal = wait_event_interruptible_timeout(pShbMemHeader->m_WaitQueueJobReady,
-            (pShbMemHeader->m_fJobReady != FALSE), lTimeOut);
-    }
-    else
-    {
-        //wait for job ready semaphore
-        iRetVal = wait_event_interruptible(pShbMemHeader->m_WaitQueueJobReady,
-            (pShbMemHeader->m_fJobReady != FALSE));
-    }
-
-    if (pShbMemInst->m_pfnSigHndlrJobReady != NULL)
-    {
-        //call Handler
-        pShbMemInst->m_pfnSigHndlrJobReady(pShbInstance, !pShbMemHeader->m_fJobReady);
-    }
-
-    pShbMemInst->m_pfnSigHndlrJobReady=NULL;
-    return 0;
+	pShbMemInst->m_pfnSigHndlrJobReady = NULL;
+	return 0;
 }
 
-
-
 //Build the crc table
 static void ShbIpcCrc32GenTable(unsigned long aulCrcTable[256])
 {
-    unsigned long       ulCrc,ulPoly;
-    int                 iIndexI,iIndexJ;
+	unsigned long ulCrc, ulPoly;
+	int iIndexI, iIndexJ;
 
-    ulPoly = 0xEDB88320L;
-    for (iIndexI = 0; iIndexI < 256; iIndexI++)
-    {
-        ulCrc = iIndexI;
-        for (iIndexJ = 8; iIndexJ > 0; iIndexJ--)
-        {
-            if (ulCrc & 1)
-            {
-                ulCrc = (ulCrc >> 1) ^ ulPoly;
-            }
-            else
-            {
-                ulCrc >>= 1;
-            }
-        }
-        aulCrcTable[iIndexI] = ulCrc;
-    }
+	ulPoly = 0xEDB88320L;
+	for (iIndexI = 0; iIndexI < 256; iIndexI++) {
+		ulCrc = iIndexI;
+		for (iIndexJ = 8; iIndexJ > 0; iIndexJ--) {
+			if (ulCrc & 1) {
+				ulCrc = (ulCrc >> 1) ^ ulPoly;
+			} else {
+				ulCrc >>= 1;
+			}
+		}
+		aulCrcTable[iIndexI] = ulCrc;
+	}
 }
 
 //Calculate the crc value
-static unsigned long ShbIpcCrc32GetCrc(const char *pcString,unsigned long aulCrcTable[256])
+static unsigned long ShbIpcCrc32GetCrc(const char *pcString,
+				       unsigned long aulCrcTable[256])
 {
-    unsigned long   ulCrc;
-    int             iIndex;
+	unsigned long ulCrc;
+	int iIndex;
 
-    ulCrc = 0xFFFFFFFF;
-    for (iIndex=0;iIndex<strlen(pcString);iIndex++)
-    {
-        ulCrc = ((ulCrc>>8) & 0x00FFFFFF) ^ aulCrcTable[ (ulCrc^pcString[iIndex]) & 0xFF ];
-    }
-    return( ulCrc^0xFFFFFFFF );
+	ulCrc = 0xFFFFFFFF;
+	for (iIndex = 0; iIndex < strlen(pcString); iIndex++) {
+		ulCrc =
+		    ((ulCrc >> 8) & 0x00FFFFFF) ^
+		    aulCrcTable[(ulCrc ^ pcString[iIndex]) & 0xFF];
+	}
+	return (ulCrc ^ 0xFFFFFFFF);
 
 }
 
-static void ShbIpcAppendListElement (struct sShbMemTable *psNewMemTableElement)
+static void ShbIpcAppendListElement(struct sShbMemTable *psNewMemTableElement)
 {
-    struct sShbMemTable *psMemTableElement=psMemTableElementFirst_g;
-    psNewMemTableElement->m_psNextMemTableElement=NULL;
+	struct sShbMemTable *psMemTableElement = psMemTableElementFirst_g;
+	psNewMemTableElement->m_psNextMemTableElement = NULL;
 
-    if (psMemTableElementFirst_g!= NULL )
-    {      /* sind Elemente vorhanden */
-       while (psMemTableElement->m_psNextMemTableElement != NULL )
-       {    /* suche das letzte Element */
-           psMemTableElement=psMemTableElement->m_psNextMemTableElement;
-       }
-       psMemTableElement->m_psNextMemTableElement=psNewMemTableElement;              /*  Haenge das Element hinten an */
-    }
-    else
-    {                           /* wenn die liste leer ist, bin ich das erste Element */
-        psMemTableElementFirst_g=psNewMemTableElement;
-    }
+	if (psMemTableElementFirst_g != NULL) {	/* sind Elemente vorhanden */
+		while (psMemTableElement->m_psNextMemTableElement != NULL) {	/* suche das letzte Element */
+			psMemTableElement =
+			    psMemTableElement->m_psNextMemTableElement;
+		}
+		psMemTableElement->m_psNextMemTableElement = psNewMemTableElement;	/*  Haenge das Element hinten an */
+	} else {		/* wenn die liste leer ist, bin ich das erste Element */
+		psMemTableElementFirst_g = psNewMemTableElement;
+	}
 }
 
-
-
-
-static int ShbIpcFindListElement (int iBufferId, struct sShbMemTable **ppsReturnMemTableElement)
+static int ShbIpcFindListElement(int iBufferId,
+				 struct sShbMemTable **ppsReturnMemTableElement)
 {
-    struct sShbMemTable *psMemTableElement=psMemTableElementFirst_g;
-    while (psMemTableElement!=NULL)
-    {
-        if(psMemTableElement->m_iBufferId==iBufferId)
-        {
+	struct sShbMemTable *psMemTableElement = psMemTableElementFirst_g;
+	while (psMemTableElement != NULL) {
+		if (psMemTableElement->m_iBufferId == iBufferId) {
 //printk("ShbIpcFindListElement Buffer at:%p Id:%d\n",psMemTableElement->m_pBuffer,psMemTableElement->m_iBufferId);
-             *ppsReturnMemTableElement=psMemTableElement;
+			*ppsReturnMemTableElement = psMemTableElement;
 //printk("ShbIpcFindListElement Buffer at:%p Id:%d\n",(*ppsReturnMemTableElement)->m_pBuffer,(*ppsReturnMemTableElement)->m_iBufferId);
-             return 0;
-        }
-        psMemTableElement=psMemTableElement->m_psNextMemTableElement;
-    }
-    return -1;
+			return 0;
+		}
+		psMemTableElement = psMemTableElement->m_psNextMemTableElement;
+	}
+	return -1;
 }
 
 static void ShbIpcDeleteListElement(int iBufferId)
 {
-   struct sShbMemTable *psMemTableElement=psMemTableElementFirst_g;
-   struct sShbMemTable *psMemTableElementOld=psMemTableElementFirst_g;
-   if (psMemTableElement!=NULL)
-   {
-        while((psMemTableElement!=NULL)&&(psMemTableElement->m_iBufferId!=iBufferId))
-        {
-            psMemTableElementOld=psMemTableElement;
-            psMemTableElement=psMemTableElement->m_psNextMemTableElement;
-        }
-        if (psMemTableElement!=NULL)
-        {
-            if (psMemTableElement!=psMemTableElementFirst_g)
-            {
-                psMemTableElementOld->m_psNextMemTableElement=psMemTableElement->m_psNextMemTableElement;
-                kfree(psMemTableElement);
-            }
-            else
-            {
-                kfree(psMemTableElement);
-                psMemTableElementFirst_g=NULL;
-            }
+	struct sShbMemTable *psMemTableElement = psMemTableElementFirst_g;
+	struct sShbMemTable *psMemTableElementOld = psMemTableElementFirst_g;
+	if (psMemTableElement != NULL) {
+		while ((psMemTableElement != NULL)
+		       && (psMemTableElement->m_iBufferId != iBufferId)) {
+			psMemTableElementOld = psMemTableElement;
+			psMemTableElement =
+			    psMemTableElement->m_psNextMemTableElement;
+		}
+		if (psMemTableElement != NULL) {
+			if (psMemTableElement != psMemTableElementFirst_g) {
+				psMemTableElementOld->m_psNextMemTableElement =
+				    psMemTableElement->m_psNextMemTableElement;
+				kfree(psMemTableElement);
+			} else {
+				kfree(psMemTableElement);
+				psMemTableElementFirst_g = NULL;
+			}
 
-        }
-   }
+		}
+	}
 
 }
 
--- a/drivers/staging/epl/ShbIpc-Win32.c
+++ b/drivers/staging/epl/ShbIpc-Win32.c
@@ -55,8 +55,8 @@
 
 ****************************************************************************/
 
-#define WINVER       0x0400             // #defines necessary for usage of
-#define _WIN32_WINNT 0x0400             // function <SignalObjectAndWait>
+#define WINVER       0x0400	// #defines necessary for usage of
+#define _WIN32_WINNT 0x0400	// function <SignalObjectAndWait>
 
 #include <windows.h>
 #include <stdio.h>
@@ -64,10 +64,6 @@
 #include "sharedbuff.h"
 #include "shbipc.h"
 
-
-
-
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -82,8 +78,6 @@
 //  Configuration
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 //  Constant definitions
 //---------------------------------------------------------------------------
@@ -100,13 +94,11 @@
 #define NAME_EVENT_TERM_RESP    "TermResp"
 #define NAME_EVENT_JOB_READY    "JobReady"
 
-#define TIMEOUT_ENTER_ATOMIC    1000        // for debgging: INFINITE
+#define TIMEOUT_ENTER_ATOMIC    1000	// for debgging: INFINITE
 #define TIMEOUT_TERM_THREAD     2000
 
-#define SBI_MAGIC_ID            0x5342492B  // magic ID ("SBI+")
-#define SBH_MAGIC_ID            0x5342482A  // magic ID ("SBH*")
-
-
+#define SBI_MAGIC_ID            0x5342492B	// magic ID ("SBI+")
+#define SBH_MAGIC_ID            0x5342482A	// magic ID ("SBH*")
 
 //---------------------------------------------------------------------------
 //  Local types
@@ -118,19 +110,17 @@
 // separated processes (e.g. the refernce counter). This structure is
 // located at the start of the shared memory region itself and exists
 // consequently only one times per shared memory instance.
-typedef struct
-{
-    unsigned long       m_SbhMagicID;       // magic ID ("SBH*")
-    unsigned long       m_ulShMemSize;
-    unsigned long       m_ulRefCount;
-    char                m_szBufferID[MAX_LEN_BUFFER_ID];
-
-    #ifndef NDEBUG
-        unsigned long   m_ulOwnerProcID;
-    #endif
+typedef struct {
+	unsigned long m_SbhMagicID;	// magic ID ("SBH*")
+	unsigned long m_ulShMemSize;
+	unsigned long m_ulRefCount;
+	char m_szBufferID[MAX_LEN_BUFFER_ID];
 
-} tShbMemHeader;
+#ifndef NDEBUG
+	unsigned long m_ulOwnerProcID;
+#endif
 
+} tShbMemHeader;
 
 // This structure is the "external entry point" from a separate process
 // to get access to a shared buffer. This structure includes all platform
@@ -141,41 +131,34 @@ typedef struct
 // owner process only). The structure member <m_pShbMemHeader> points
 // to the (process specific) start address of the shared memory region
 // itself.
-typedef struct
-{
-    unsigned long       m_SbiMagicID;           // magic ID ("SBI+")
-    HANDLE              m_hSharedMem;
-    HANDLE              m_hMutexBuffAccess;
-    HANDLE              m_hThreadNewData;       // thraed to signal that new data are available
-    HANDLE              m_ahEventNewData[3];    // IDX_EVENT_NEW_DATA + IDX_EVENT_TERM_REQU + ID_EVENT_TERM_RESP
-    tSigHndlrNewData    m_pfnSigHndlrNewData;
-    HANDLE              m_hThreadJobReady;      // thread to signal that a job/operation is ready now (e.g. reset buffer)
-    HANDLE              m_hEventJobReady;
-    unsigned long       m_ulTimeOutJobReady;
-    tSigHndlrJobReady   m_pfnSigHndlrJobReady;
-    tShbMemHeader*      m_pShbMemHeader;
-
-    #ifndef NDEBUG
-        unsigned long   m_ulThreadIDNewData;
-        unsigned long   m_ulThreadIDJobReady;
-    #endif
+typedef struct {
+	unsigned long m_SbiMagicID;	// magic ID ("SBI+")
+	HANDLE m_hSharedMem;
+	HANDLE m_hMutexBuffAccess;
+	HANDLE m_hThreadNewData;	// thraed to signal that new data are available
+	HANDLE m_ahEventNewData[3];	// IDX_EVENT_NEW_DATA + IDX_EVENT_TERM_REQU + ID_EVENT_TERM_RESP
+	tSigHndlrNewData m_pfnSigHndlrNewData;
+	HANDLE m_hThreadJobReady;	// thread to signal that a job/operation is ready now (e.g. reset buffer)
+	HANDLE m_hEventJobReady;
+	unsigned long m_ulTimeOutJobReady;
+	tSigHndlrJobReady m_pfnSigHndlrJobReady;
+	tShbMemHeader *m_pShbMemHeader;
+
+#ifndef NDEBUG
+	unsigned long m_ulThreadIDNewData;
+	unsigned long m_ulThreadIDJobReady;
+#endif
 
 } tShbMemInst;
 
-
-
 //---------------------------------------------------------------------------
 //  Global variables
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 //  Local variables
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 //  Prototypes of internal functions
 //---------------------------------------------------------------------------
@@ -184,54 +167,50 @@ typedef struct
 //  Get pointer to process local information structure
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbMemInst*  ShbIpcGetShbMemInst (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbMemInst *ShbIpcGetShbMemInst(tShbInstance pShbInstance_p)
 {
 
-tShbMemInst*  pShbMemInst;
-
+	tShbMemInst *pShbMemInst;
 
-    pShbMemInst = (tShbMemInst*)pShbInstance_p;
-    ASSERT (pShbMemInst->m_SbiMagicID == SBI_MAGIC_ID);
+	pShbMemInst = (tShbMemInst *) pShbInstance_p;
+	ASSERT(pShbMemInst->m_SbiMagicID == SBI_MAGIC_ID);
 
-    return (pShbMemInst);
+	return (pShbMemInst);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Get pointer to shared memory header
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbMemHeader*  ShbIpcGetShbMemHeader (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbMemHeader *ShbIpcGetShbMemHeader(tShbInstance
+						     pShbInstance_p)
 {
 
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
 
-    pShbMemInst   = ShbIpcGetShbMemInst (pShbInstance_p);
-    pShbMemHeader = pShbMemInst->m_pShbMemHeader;
-    ASSERT(pShbMemHeader->m_SbhMagicID == SBH_MAGIC_ID);
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	pShbMemHeader = pShbMemInst->m_pShbMemHeader;
+	ASSERT(pShbMemHeader->m_SbhMagicID == SBH_MAGIC_ID);
 
-    return (pShbMemHeader);
+	return (pShbMemHeader);
 
 }
 
-
 // not inlined internal functions
-DWORD  WINAPI   ShbIpcThreadSignalNewData  (LPVOID pvThreadParam_p);
-DWORD  WINAPI   ShbIpcThreadSignalJobReady (LPVOID pvThreadParam_p);
-const char*     ShbIpcGetUniformObjectName (const char* pszEventJobName_p, const char* pszBufferID_p, BOOL fGlobalObject_p);
+DWORD WINAPI ShbIpcThreadSignalNewData(LPVOID pvThreadParam_p);
+DWORD WINAPI ShbIpcThreadSignalJobReady(LPVOID pvThreadParam_p);
+const char *ShbIpcGetUniformObjectName(const char *pszEventJobName_p,
+				       const char *pszBufferID_p,
+				       BOOL fGlobalObject_p);
 
 #endif
 
 #if !defined(SHBIPC_INLINE_ENABLED)
 // true internal functions (not inlined)
-static void*        ShbIpcAllocPrivateMem      (unsigned long ulMemSize_p);
-static void         ShbIpcReleasePrivateMem    (void* pMem_p);
+static void *ShbIpcAllocPrivateMem(unsigned long ulMemSize_p);
+static void ShbIpcReleasePrivateMem(void *pMem_p);
 #endif
 
 //=========================================================================//
@@ -247,324 +226,294 @@ static void         ShbIpcReleasePrivate
 //  Initialize IPC for Shared Buffer Module
 //---------------------------------------------------------------------------
 
-tShbError  ShbIpcInit (void)
+tShbError ShbIpcInit(void)
 {
 
-    return (kShbOk);
+	return (kShbOk);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Deinitialize IPC for Shared Buffer Module
 //---------------------------------------------------------------------------
 
-tShbError  ShbIpcExit (void)
+tShbError ShbIpcExit(void)
 {
 
-    return (kShbOk);
+	return (kShbOk);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Allocate Shared Buffer
 //---------------------------------------------------------------------------
 
-tShbError  ShbIpcAllocBuffer (
-    unsigned long ulBufferSize_p,
-    const char* pszBufferID_p,
-    tShbInstance* ppShbInstance_p,
-    unsigned int* pfShbNewCreated_p)
-{
+tShbError ShbIpcAllocBuffer(unsigned long ulBufferSize_p,
+			    const char *pszBufferID_p,
+			    tShbInstance * ppShbInstance_p,
+			    unsigned int *pfShbNewCreated_p)
+{
+
+	HANDLE hSharedMem;
+	LPVOID pSharedMem;
+	unsigned long ulShMemSize;
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	tShbInstance pShbInstance;
+	unsigned int fShMemNewCreated;
+	const char *pszObjectName;
+	HANDLE hMutexBuffAccess;
+	HANDLE hEventNewData;
+	HANDLE hEventJobReady;
+	tShbError ShbError;
+
+	ulShMemSize = ulBufferSize_p + sizeof(tShbMemHeader);
+	pSharedMem = NULL;
+	pShbInstance = NULL;
+	fShMemNewCreated = FALSE;
+	ShbError = kShbOk;
+
+	//---------------------------------------------------------------
+	// (1) open an existing or create a new shared memory
+	//---------------------------------------------------------------
+	// try to open an already existing shared memory
+	// (created by an another process)
+	hSharedMem = OpenFileMapping(FILE_MAP_ALL_ACCESS,	// DWORD dwDesiredAccess
+				     FALSE,	// BOOL bInheritHandle
+				     pszBufferID_p);	// LPCTSTR lpName
+	if (hSharedMem != NULL) {
+		// a shared memory already exists
+		fShMemNewCreated = FALSE;
+	} else {
+		// it seams that this process is the first who wants to use the
+		// shared memory, so it has to create a new shared memory
+		hSharedMem = CreateFileMapping(INVALID_HANDLE_VALUE,	// HANDLE hFile
+					       NULL,	// LPSECURITY_ATTRIBUTES lpAttributes
+					       PAGE_READWRITE,	// DWORD flProtect
+					       0,	// DWORD dwMaximumSizeHigh
+					       ulShMemSize,	// DWORD dwMaximumSizeLow
+					       pszBufferID_p);	// LPCTSTR lpName
+
+		fShMemNewCreated = TRUE;
+	}
+
+	if (hSharedMem == NULL) {
+		ShbError = kShbOutOfMem;
+		goto Exit;
+	}
+
+	//---------------------------------------------------------------
+	// (2) get the pointer to the shared memory
+	//---------------------------------------------------------------
+	pSharedMem = MapViewOfFile(hSharedMem,	// HANDLE hFileMappingObject
+				   FILE_MAP_ALL_ACCESS,	// DWORD dwDesiredAccess,
+				   0,	// DWORD dwFileOffsetHigh,
+				   0,	// DWORD dwFileOffsetLow,
+				   ulShMemSize);	// SIZE_T dwNumberOfBytesToMap
+
+	if (pSharedMem == NULL) {
+		ShbError = kShbOutOfMem;
+		goto Exit;
+	}
+
+	//---------------------------------------------------------------
+	// (3) setup or update header and management information
+	//---------------------------------------------------------------
+	pShbMemHeader = (tShbMemHeader *) pSharedMem;
+
+	// allocate a memory block from process specific mempool to save
+	// process local information to administrate/manage the shared buffer
+	pShbMemInst =
+	    (tShbMemInst *) ShbIpcAllocPrivateMem(sizeof(tShbMemInst));
+	if (pShbMemInst == NULL) {
+		ShbError = kShbOutOfMem;
+		goto Exit;
+	}
+	// reset complete header to default values
+	pShbMemInst->m_SbiMagicID = SBI_MAGIC_ID;
+	pShbMemInst->m_hSharedMem = hSharedMem;
+	pShbMemInst->m_hMutexBuffAccess = INVALID_HANDLE_VALUE;
+	pShbMemInst->m_hThreadNewData = INVALID_HANDLE_VALUE;
+	pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA] =
+	    INVALID_HANDLE_VALUE;
+	pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] =
+	    INVALID_HANDLE_VALUE;
+	pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] =
+	    INVALID_HANDLE_VALUE;
+	pShbMemInst->m_pfnSigHndlrNewData = NULL;
+	pShbMemInst->m_hThreadJobReady = INVALID_HANDLE_VALUE;
+	pShbMemInst->m_hEventJobReady = INVALID_HANDLE_VALUE;
+	pShbMemInst->m_ulTimeOutJobReady = 0;
+	pShbMemInst->m_pfnSigHndlrJobReady = NULL;
+	pShbMemInst->m_pShbMemHeader = pShbMemHeader;
+
+#ifndef NDEBUG
+	{
+		pShbMemInst->m_ulThreadIDNewData = 0;
+		pShbMemInst->m_ulThreadIDJobReady = 0;
+	}
+#endif
+
+	// create mutex for buffer access
+	pszObjectName =
+	    ShbIpcGetUniformObjectName(NAME_MUTEX_BUFF_ACCESS, pszBufferID_p,
+				       TRUE);
+	hMutexBuffAccess = CreateMutex(NULL,	// LPSECURITY_ATTRIBUTES lpMutexAttributes
+				       FALSE,	// BOOL bInitialOwner
+				       pszObjectName);	// LPCTSTR lpName
+	pShbMemInst->m_hMutexBuffAccess = hMutexBuffAccess;
+	ASSERT(pShbMemInst->m_hMutexBuffAccess != NULL);
+
+	// The EventNewData is used for signaling of new data after a write
+	// operation (SetEvent) as well as for waiting for new data on the
+	// reader side (WaitForMultipleObjects). Because it's not known if
+	// this process will be read or write data, the event will be
+	// always created here.
+	pszObjectName =
+	    ShbIpcGetUniformObjectName(NAME_EVENT_NEW_DATA, pszBufferID_p,
+				       TRUE);
+	hEventNewData = CreateEvent(NULL,	// LPSECURITY_ATTRIBUTES lpEventAttributes
+				    FALSE,	// BOOL bManualReset
+				    FALSE,	// BOOL bInitialState
+				    pszObjectName);	// LPCTSTR lpName
+	pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA] = hEventNewData;
+	ASSERT(pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA] != NULL);
+
+	// The EventJobReady is used for signaling that a job is done (SetEvent)
+	// as well as for waiting for finishing of a job (WaitForMultipleObjects).
+	// Because it's not known if this process will signal or wait, the event
+	// will be always created here.
+	pszObjectName =
+	    ShbIpcGetUniformObjectName(NAME_EVENT_JOB_READY, pszBufferID_p,
+				       TRUE);
+	hEventJobReady = CreateEvent(NULL,	// LPSECURITY_ATTRIBUTES lpEventAttributes
+				     FALSE,	// BOOL bManualReset
+				     FALSE,	// BOOL bInitialState
+				     pszObjectName);	// LPCTSTR lpName
+	pShbMemInst->m_hEventJobReady = hEventJobReady;
+	ASSERT(pShbMemInst->m_hEventJobReady != NULL);
+
+	if (fShMemNewCreated) {
+		// this process was the first who wanted to use the shared memory,
+		// so a new shared memory was created
+		// -> setup new header information inside the shared memory region
+		//    itself
+		pShbMemHeader->m_SbhMagicID = SBH_MAGIC_ID;
+		pShbMemHeader->m_ulShMemSize = ulShMemSize;
+		pShbMemHeader->m_ulRefCount = 1;
+		strncpy(pShbMemHeader->m_szBufferID, pszBufferID_p,
+			sizeof(pShbMemHeader->m_szBufferID) - 1);
+
+#ifndef NDEBUG
+		{
+			pShbMemHeader->m_ulOwnerProcID = GetCurrentProcessId();
+		}
+#endif
+	} else {
+		// any other process has created the shared memory and this
+		// process has only attached to it
+		// -> check and update existing header information inside the
+		//    shared memory region itself
+		if (pShbMemHeader->m_ulShMemSize != ulShMemSize) {
+			ShbError = kShbOpenMismatch;
+			goto Exit;
+		}
+#ifndef NDEBUG
+		{
+			if (strncmp
+			    (pShbMemHeader->m_szBufferID, pszBufferID_p,
+			     sizeof(pShbMemHeader->m_szBufferID) - 1)) {
+				ShbError = kShbOpenMismatch;
+				goto Exit;
+			}
+		}
+#endif
 
-HANDLE          hSharedMem;
-LPVOID          pSharedMem;
-unsigned long   ulShMemSize;
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-tShbInstance    pShbInstance;
-unsigned int    fShMemNewCreated;
-const char*     pszObjectName;
-HANDLE          hMutexBuffAccess;
-HANDLE          hEventNewData;
-HANDLE          hEventJobReady;
-tShbError       ShbError;
-
-
-    ulShMemSize      = ulBufferSize_p + sizeof(tShbMemHeader);
-    pSharedMem       = NULL;
-    pShbInstance     = NULL;
-    fShMemNewCreated = FALSE;
-    ShbError         = kShbOk;
-
-
-    //---------------------------------------------------------------
-    // (1) open an existing or create a new shared memory
-    //---------------------------------------------------------------
-    // try to open an already existing shared memory
-    // (created by an another process)
-    hSharedMem = OpenFileMapping (FILE_MAP_ALL_ACCESS,      // DWORD dwDesiredAccess
-                                  FALSE,                    // BOOL bInheritHandle
-                                  pszBufferID_p);           // LPCTSTR lpName
-    if (hSharedMem != NULL)
-    {
-        // a shared memory already exists
-        fShMemNewCreated = FALSE;
-    }
-    else
-    {
-        // it seams that this process is the first who wants to use the
-        // shared memory, so it has to create a new shared memory
-        hSharedMem = CreateFileMapping(INVALID_HANDLE_VALUE,// HANDLE hFile
-                                       NULL,                // LPSECURITY_ATTRIBUTES lpAttributes
-                                       PAGE_READWRITE,      // DWORD flProtect
-                                       0,                   // DWORD dwMaximumSizeHigh
-                                       ulShMemSize,         // DWORD dwMaximumSizeLow
-                                       pszBufferID_p);      // LPCTSTR lpName
-
-        fShMemNewCreated = TRUE;
-    }
-
-    if (hSharedMem == NULL)
-    {
-        ShbError = kShbOutOfMem;
-        goto Exit;
-    }
-
-
-    //---------------------------------------------------------------
-    // (2) get the pointer to the shared memory
-    //---------------------------------------------------------------
-    pSharedMem = MapViewOfFile (hSharedMem,                 // HANDLE hFileMappingObject
-                                FILE_MAP_ALL_ACCESS,        // DWORD dwDesiredAccess,
-                                0,                          // DWORD dwFileOffsetHigh,
-                                0,                          // DWORD dwFileOffsetLow,
-                                ulShMemSize);               // SIZE_T dwNumberOfBytesToMap
-
-    if (pSharedMem == NULL)
-    {
-        ShbError = kShbOutOfMem;
-        goto Exit;
-    }
-
-
-    //---------------------------------------------------------------
-    // (3) setup or update header and management information
-    //---------------------------------------------------------------
-    pShbMemHeader = (tShbMemHeader*)pSharedMem;
-
-    // allocate a memory block from process specific mempool to save
-    // process local information to administrate/manage the shared buffer
-    pShbMemInst = (tShbMemInst*) ShbIpcAllocPrivateMem (sizeof(tShbMemInst));
-    if (pShbMemInst == NULL)
-    {
-        ShbError = kShbOutOfMem;
-        goto Exit;
-    }
-
-    // reset complete header to default values
-    pShbMemInst->m_SbiMagicID                          = SBI_MAGIC_ID;
-    pShbMemInst->m_hSharedMem                          = hSharedMem;
-    pShbMemInst->m_hMutexBuffAccess                    = INVALID_HANDLE_VALUE;
-    pShbMemInst->m_hThreadNewData                      = INVALID_HANDLE_VALUE;
-    pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA]  = INVALID_HANDLE_VALUE;
-    pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] = INVALID_HANDLE_VALUE;
-    pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] = INVALID_HANDLE_VALUE;
-    pShbMemInst->m_pfnSigHndlrNewData                  = NULL;
-    pShbMemInst->m_hThreadJobReady                     = INVALID_HANDLE_VALUE;
-    pShbMemInst->m_hEventJobReady                      = INVALID_HANDLE_VALUE;
-    pShbMemInst->m_ulTimeOutJobReady                   = 0;
-    pShbMemInst->m_pfnSigHndlrJobReady                 = NULL;
-    pShbMemInst->m_pShbMemHeader                       = pShbMemHeader;
-
-    #ifndef NDEBUG
-    {
-        pShbMemInst->m_ulThreadIDNewData  = 0;
-        pShbMemInst->m_ulThreadIDJobReady = 0;
-    }
-    #endif
-
-    // create mutex for buffer access
-    pszObjectName = ShbIpcGetUniformObjectName (NAME_MUTEX_BUFF_ACCESS, pszBufferID_p, TRUE);
-    hMutexBuffAccess = CreateMutex (NULL,                   // LPSECURITY_ATTRIBUTES lpMutexAttributes
-                                    FALSE,                  // BOOL bInitialOwner
-                                    pszObjectName);         // LPCTSTR lpName
-    pShbMemInst->m_hMutexBuffAccess = hMutexBuffAccess;
-    ASSERT(pShbMemInst->m_hMutexBuffAccess != NULL);
-
-    // The EventNewData is used for signaling of new data after a write
-    // operation (SetEvent) as well as for waiting for new data on the
-    // reader side (WaitForMultipleObjects). Because it's not known if
-    // this process will be read or write data, the event will be
-    // always created here.
-    pszObjectName = ShbIpcGetUniformObjectName (NAME_EVENT_NEW_DATA, pszBufferID_p, TRUE);
-    hEventNewData = CreateEvent (NULL,                      // LPSECURITY_ATTRIBUTES lpEventAttributes
-                                 FALSE,                     // BOOL bManualReset
-                                 FALSE,                     // BOOL bInitialState
-                                 pszObjectName);            // LPCTSTR lpName
-    pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA] = hEventNewData;
-    ASSERT(pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA] != NULL);
-
-    // The EventJobReady is used for signaling that a job is done (SetEvent)
-    // as well as for waiting for finishing of a job (WaitForMultipleObjects).
-    // Because it's not known if this process will signal or wait, the event
-    // will be always created here.
-    pszObjectName = ShbIpcGetUniformObjectName (NAME_EVENT_JOB_READY, pszBufferID_p, TRUE);
-    hEventJobReady = CreateEvent (NULL,                     // LPSECURITY_ATTRIBUTES lpEventAttributes
-                                  FALSE,                    // BOOL bManualReset
-                                  FALSE,                    // BOOL bInitialState
-                                  pszObjectName);           // LPCTSTR lpName
-    pShbMemInst->m_hEventJobReady = hEventJobReady;
-    ASSERT(pShbMemInst->m_hEventJobReady != NULL);
-
-    if ( fShMemNewCreated )
-    {
-        // this process was the first who wanted to use the shared memory,
-        // so a new shared memory was created
-        // -> setup new header information inside the shared memory region
-        //    itself
-        pShbMemHeader->m_SbhMagicID  = SBH_MAGIC_ID;
-        pShbMemHeader->m_ulShMemSize = ulShMemSize;
-        pShbMemHeader->m_ulRefCount  = 1;
-        strncpy (pShbMemHeader->m_szBufferID, pszBufferID_p, sizeof(pShbMemHeader->m_szBufferID)-1);
-
-        #ifndef NDEBUG
-        {
-            pShbMemHeader->m_ulOwnerProcID = GetCurrentProcessId();
-        }
-        #endif
-    }
-    else
-    {
-        // any other process has created the shared memory and this
-        // process has only attached to it
-        // -> check and update existing header information inside the
-        //    shared memory region itself
-        if (pShbMemHeader->m_ulShMemSize != ulShMemSize)
-        {
-            ShbError = kShbOpenMismatch;
-            goto Exit;
-        }
-
-        #ifndef NDEBUG
-        {
-            if ( strncmp(pShbMemHeader->m_szBufferID, pszBufferID_p, sizeof(pShbMemHeader->m_szBufferID)-1) )
-            {
-                ShbError = kShbOpenMismatch;
-                goto Exit;
-            }
-        }
-        #endif
-
-        pShbMemHeader->m_ulRefCount++;
-    }
-
-
-    // set abstarct "handle" for returning to application
-    pShbInstance = (tShbInstance*)pShbMemInst;
-
-
-Exit:
-
-    if (ShbError != kShbOk)
-    {
-        if (pShbMemInst != NULL)
-        {
-            ShbIpcReleasePrivateMem (pShbMemInst);
-        }
-        if (pSharedMem != NULL)
-        {
-            UnmapViewOfFile (pSharedMem);
-        }
-        if (hSharedMem != NULL)
-        {
-            CloseHandle (hSharedMem);
-        }
-    }
+		pShbMemHeader->m_ulRefCount++;
+	}
 
-    *pfShbNewCreated_p = fShMemNewCreated;
-    *ppShbInstance_p   = pShbInstance;
+	// set abstarct "handle" for returning to application
+	pShbInstance = (tShbInstance *) pShbMemInst;
 
-    return (ShbError);
+      Exit:
 
-}
+	if (ShbError != kShbOk) {
+		if (pShbMemInst != NULL) {
+			ShbIpcReleasePrivateMem(pShbMemInst);
+		}
+		if (pSharedMem != NULL) {
+			UnmapViewOfFile(pSharedMem);
+		}
+		if (hSharedMem != NULL) {
+			CloseHandle(hSharedMem);
+		}
+	}
 
+	*pfShbNewCreated_p = fShMemNewCreated;
+	*ppShbInstance_p = pShbInstance;
 
+	return (ShbError);
+
+}
 
 //---------------------------------------------------------------------------
 //  Release Shared Buffer
 //---------------------------------------------------------------------------
 
-tShbError  ShbIpcReleaseBuffer (
-    tShbInstance pShbInstance_p)
+tShbError ShbIpcReleaseBuffer(tShbInstance pShbInstance_p)
 {
 
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-HANDLE          hEventNewData;
-HANDLE          hMutexBuffAccess;
-tShbError       ShbError;
-tShbError       ShbError2;
-
-
-    if (pShbInstance_p == NULL)
-    {
-        return (kShbOk);
-    }
-
-
-    pShbMemInst   = ShbIpcGetShbMemInst   (pShbInstance_p);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbInstance_p);
-
-
-    if ( !--pShbMemHeader->m_ulRefCount )
-    {
-        ShbError = kShbOk;
-    }
-    else
-    {
-        ShbError = kShbMemUsedByOtherProcs;
-    }
-
-
-    ShbError2 = ShbIpcStopSignalingNewData (pShbInstance_p);
-    hEventNewData = pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA];
-    if (hEventNewData != INVALID_HANDLE_VALUE)
-    {
-        CloseHandle (hEventNewData);
-        pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA] = INVALID_HANDLE_VALUE;
-    }
-
-    hMutexBuffAccess = pShbMemInst->m_hMutexBuffAccess;
-    if (hMutexBuffAccess != INVALID_HANDLE_VALUE)
-    {
-        CloseHandle (hMutexBuffAccess);
-        pShbMemInst->m_hMutexBuffAccess = INVALID_HANDLE_VALUE;
-    }
-
-    UnmapViewOfFile (pShbMemHeader);
-    if (pShbMemInst->m_hSharedMem != INVALID_HANDLE_VALUE)
-    {
-        CloseHandle (pShbMemInst->m_hSharedMem);
-        pShbMemInst->m_hSharedMem = INVALID_HANDLE_VALUE;
-    }
-
-    ShbIpcReleasePrivateMem (pShbMemInst);
-
-
-    if (ShbError == kShbOk)
-    {
-        ShbError = ShbError2;
-    }
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	HANDLE hEventNewData;
+	HANDLE hMutexBuffAccess;
+	tShbError ShbError;
+	tShbError ShbError2;
+
+	if (pShbInstance_p == NULL) {
+		return (kShbOk);
+	}
+
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbInstance_p);
+
+	if (!--pShbMemHeader->m_ulRefCount) {
+		ShbError = kShbOk;
+	} else {
+		ShbError = kShbMemUsedByOtherProcs;
+	}
+
+	ShbError2 = ShbIpcStopSignalingNewData(pShbInstance_p);
+	hEventNewData = pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA];
+	if (hEventNewData != INVALID_HANDLE_VALUE) {
+		CloseHandle(hEventNewData);
+		pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA] =
+		    INVALID_HANDLE_VALUE;
+	}
+
+	hMutexBuffAccess = pShbMemInst->m_hMutexBuffAccess;
+	if (hMutexBuffAccess != INVALID_HANDLE_VALUE) {
+		CloseHandle(hMutexBuffAccess);
+		pShbMemInst->m_hMutexBuffAccess = INVALID_HANDLE_VALUE;
+	}
+
+	UnmapViewOfFile(pShbMemHeader);
+	if (pShbMemInst->m_hSharedMem != INVALID_HANDLE_VALUE) {
+		CloseHandle(pShbMemInst->m_hSharedMem);
+		pShbMemInst->m_hSharedMem = INVALID_HANDLE_VALUE;
+	}
+
+	ShbIpcReleasePrivateMem(pShbMemInst);
+
+	if (ShbError == kShbOk) {
+		ShbError = ShbError2;
+	}
 
-    return (ShbError);
+	return (ShbError);
 
 }
 
-#endif  // !defined(SHBIPC_INLINE_ENABLED)
+#endif // !defined(SHBIPC_INLINE_ENABLED)
 
 #if (!defined(SHBIPC_INLINED)) || defined(SHBIPC_INLINE_ENABLED)
 
@@ -572,486 +521,435 @@ tShbError       ShbError2;
 //  Enter atomic section for Shared Buffer access
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcEnterAtomicSection (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbError ShbIpcEnterAtomicSection(tShbInstance pShbInstance_p)
 {
 
-tShbMemInst*  pShbMemInst;
-HANDLE        hMutexBuffAccess;
-DWORD         dwWaitResult;
-tShbError     ShbError;
-
-
-    if (pShbInstance_p == NULL)
-    {
-        return (kShbInvalidArg);
-    }
-
-
-    pShbMemInst = ShbIpcGetShbMemInst (pShbInstance_p);
-    ShbError = kShbOk;
-
-    hMutexBuffAccess = pShbMemInst->m_hMutexBuffAccess;
-    if (hMutexBuffAccess != INVALID_HANDLE_VALUE)
-    {
-        dwWaitResult = WaitForSingleObject (hMutexBuffAccess, TIMEOUT_ENTER_ATOMIC);
-        switch (dwWaitResult)
-        {
-            case WAIT_OBJECT_0 + 0:
-            {
-                break;
-            }
-
-            case WAIT_TIMEOUT:
-            {
-                TRACE0("\nShbIpcEnterAtomicSection(): WAIT_TIMEOUT");
-                ASSERT(0);
-                ShbError = kShbBufferInvalid;
-                break;
-            }
-
-            case WAIT_ABANDONED:
-            {
-                TRACE0("\nShbIpcEnterAtomicSection(): WAIT_ABANDONED");
-                ASSERT(0);
-                ShbError = kShbBufferInvalid;
-                break;
-            }
-
-            case WAIT_FAILED:
-            {
-                TRACE1("\nShbIpcEnterAtomicSection(): WAIT_FAILED -> LastError=%ld", GetLastError());
-                ASSERT(0);
-                ShbError = kShbBufferInvalid;
-                break;
-            }
-
-            default:
-            {
-                TRACE1("\nShbIpcEnterAtomicSection(): unknown error -> LastError=%ld", GetLastError());
-                ASSERT(0);
-                ShbError = kShbBufferInvalid;
-                break;
-            }
-        }
-    }
-    else
-    {
-        ShbError = kShbBufferInvalid;
-    }
+	tShbMemInst *pShbMemInst;
+	HANDLE hMutexBuffAccess;
+	DWORD dwWaitResult;
+	tShbError ShbError;
+
+	if (pShbInstance_p == NULL) {
+		return (kShbInvalidArg);
+	}
+
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	ShbError = kShbOk;
+
+	hMutexBuffAccess = pShbMemInst->m_hMutexBuffAccess;
+	if (hMutexBuffAccess != INVALID_HANDLE_VALUE) {
+		dwWaitResult =
+		    WaitForSingleObject(hMutexBuffAccess, TIMEOUT_ENTER_ATOMIC);
+		switch (dwWaitResult) {
+		case WAIT_OBJECT_0 + 0:
+			{
+				break;
+			}
+
+		case WAIT_TIMEOUT:
+			{
+				TRACE0
+				    ("\nShbIpcEnterAtomicSection(): WAIT_TIMEOUT");
+				ASSERT(0);
+				ShbError = kShbBufferInvalid;
+				break;
+			}
+
+		case WAIT_ABANDONED:
+			{
+				TRACE0
+				    ("\nShbIpcEnterAtomicSection(): WAIT_ABANDONED");
+				ASSERT(0);
+				ShbError = kShbBufferInvalid;
+				break;
+			}
+
+		case WAIT_FAILED:
+			{
+				TRACE1
+				    ("\nShbIpcEnterAtomicSection(): WAIT_FAILED -> LastError=%ld",
+				     GetLastError());
+				ASSERT(0);
+				ShbError = kShbBufferInvalid;
+				break;
+			}
+
+		default:
+			{
+				TRACE1
+				    ("\nShbIpcEnterAtomicSection(): unknown error -> LastError=%ld",
+				     GetLastError());
+				ASSERT(0);
+				ShbError = kShbBufferInvalid;
+				break;
+			}
+		}
+	} else {
+		ShbError = kShbBufferInvalid;
+	}
 
-
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Leave atomic section for Shared Buffer access
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcLeaveAtomicSection (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbError ShbIpcLeaveAtomicSection(tShbInstance pShbInstance_p)
 {
 
-tShbMemInst*  pShbMemInst;
-HANDLE        hMutexBuffAccess;
-BOOL          fRes;
-tShbError     ShbError;
-
-
-    if (pShbInstance_p == NULL)
-    {
-        return (kShbInvalidArg);
-    }
-
-
-    pShbMemInst = ShbIpcGetShbMemInst (pShbInstance_p);
-    ShbError = kShbOk;
-
-    hMutexBuffAccess = pShbMemInst->m_hMutexBuffAccess;
-    if (hMutexBuffAccess != INVALID_HANDLE_VALUE)
-    {
-        fRes = ReleaseMutex (hMutexBuffAccess);
-        ASSERT( fRes );
-    }
-    else
-    {
-        ShbError = kShbBufferInvalid;
-    }
-
+	tShbMemInst *pShbMemInst;
+	HANDLE hMutexBuffAccess;
+	BOOL fRes;
+	tShbError ShbError;
+
+	if (pShbInstance_p == NULL) {
+		return (kShbInvalidArg);
+	}
+
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	ShbError = kShbOk;
+
+	hMutexBuffAccess = pShbMemInst->m_hMutexBuffAccess;
+	if (hMutexBuffAccess != INVALID_HANDLE_VALUE) {
+		fRes = ReleaseMutex(hMutexBuffAccess);
+		ASSERT(fRes);
+	} else {
+		ShbError = kShbBufferInvalid;
+	}
 
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Start signaling of new data (called from reading process)
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcStartSignalingNewData (
-    tShbInstance pShbInstance_p,
-    tSigHndlrNewData pfnSignalHandlerNewData_p,
-    tShbPriority ShbPriority_p)
-{
-
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-const char*     pszObjectName;
-HANDLE          hEventTermRequ;
-HANDLE          hEventTermResp;
-HANDLE          hThreadNewData;
-unsigned long   ulThreadIDNewData;
-tShbError       ShbError;
-int             iPriority;
-
-    if ((pShbInstance_p == NULL) || (pfnSignalHandlerNewData_p == NULL))
-    {
-        return (kShbInvalidArg);
-    }
-
-
-    pShbMemInst   = ShbIpcGetShbMemInst   (pShbInstance_p);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbInstance_p);
-    ShbError = kShbOk;
-
-    if ( (pShbMemInst->m_hThreadNewData                      != INVALID_HANDLE_VALUE) ||
-         (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] != INVALID_HANDLE_VALUE) ||
-         (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] != INVALID_HANDLE_VALUE) ||
-         (pShbMemInst->m_pfnSigHndlrNewData                  != NULL) )
-    {
-        ShbError = kShbAlreadySignaling;
-        goto Exit;
-    }
-
-
-    pShbMemInst->m_pfnSigHndlrNewData = pfnSignalHandlerNewData_p;
-
-
-    // Because the event <pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA]>
-    // is used for signaling of new data after a write operation too (using
-    // SetEvent), it is always created here (see <ShbIpcAllocBuffer>).
-
-    pszObjectName = ShbIpcGetUniformObjectName (NAME_EVENT_TERM_REQU, pShbMemHeader->m_szBufferID, FALSE);
-    hEventTermRequ = CreateEvent (NULL,                         // LPSECURITY_ATTRIBUTES lpEventAttributes
-                                  FALSE,                        // BOOL bManualReset
-                                  FALSE,                        // BOOL bInitialState
-                                  pszObjectName);               // LPCTSTR lpName
-    pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] = hEventTermRequ;
-    ASSERT(pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] != NULL);
-
-    pszObjectName = ShbIpcGetUniformObjectName (NAME_EVENT_TERM_RESP, pShbMemHeader->m_szBufferID, FALSE);
-    hEventTermResp = CreateEvent (NULL,                         // LPSECURITY_ATTRIBUTES lpEventAttributes
-                                  FALSE,                        // BOOL bManualReset
-                                  FALSE,                        // BOOL bInitialState
-                                  pszObjectName);               // LPCTSTR lpName
-    pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] = hEventTermResp;
-    ASSERT(pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] != NULL);
-
-    hThreadNewData = CreateThread (NULL,                        // LPSECURITY_ATTRIBUTES lpThreadAttributes
-                                   0,                           // SIZE_T dwStackSize
-                                   ShbIpcThreadSignalNewData,   // LPTHREAD_START_ROUTINE lpStartAddress
-                                   pShbInstance_p,              // LPVOID lpParameter
-                                   0,                           // DWORD dwCreationFlags
-                                   &ulThreadIDNewData);         // LPDWORD lpThreadId
-
-    switch (ShbPriority_p)
-    {
-        case kShbPriorityLow:
-            iPriority = THREAD_PRIORITY_BELOW_NORMAL;
-            break;
-
-        case kShbPriorityNormal:
-            iPriority = THREAD_PRIORITY_NORMAL;
-            break;
-
-        case kshbPriorityHigh:
-            iPriority = THREAD_PRIORITY_ABOVE_NORMAL;
-            break;
-
-    }
-
-    ASSERT(pShbMemInst->m_hThreadNewData != NULL);
-
-    SetThreadPriority(hThreadNewData, iPriority);
-
-    pShbMemInst->m_hThreadNewData = hThreadNewData;
-
-    #ifndef NDEBUG
-    {
-        pShbMemInst->m_ulThreadIDNewData = ulThreadIDNewData;
-    }
-    #endif
-
+INLINE_FUNCTION tShbError ShbIpcStartSignalingNewData(tShbInstance
+						      pShbInstance_p,
+						      tSigHndlrNewData
+						      pfnSignalHandlerNewData_p,
+						      tShbPriority
+						      ShbPriority_p)
+{
+
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	const char *pszObjectName;
+	HANDLE hEventTermRequ;
+	HANDLE hEventTermResp;
+	HANDLE hThreadNewData;
+	unsigned long ulThreadIDNewData;
+	tShbError ShbError;
+	int iPriority;
+
+	if ((pShbInstance_p == NULL) || (pfnSignalHandlerNewData_p == NULL)) {
+		return (kShbInvalidArg);
+	}
+
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbInstance_p);
+	ShbError = kShbOk;
+
+	if ((pShbMemInst->m_hThreadNewData != INVALID_HANDLE_VALUE) ||
+	    (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] !=
+	     INVALID_HANDLE_VALUE)
+	    || (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] !=
+		INVALID_HANDLE_VALUE)
+	    || (pShbMemInst->m_pfnSigHndlrNewData != NULL)) {
+		ShbError = kShbAlreadySignaling;
+		goto Exit;
+	}
+
+	pShbMemInst->m_pfnSigHndlrNewData = pfnSignalHandlerNewData_p;
+
+	// Because the event <pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA]>
+	// is used for signaling of new data after a write operation too (using
+	// SetEvent), it is always created here (see <ShbIpcAllocBuffer>).
+
+	pszObjectName =
+	    ShbIpcGetUniformObjectName(NAME_EVENT_TERM_REQU,
+				       pShbMemHeader->m_szBufferID, FALSE);
+	hEventTermRequ = CreateEvent(NULL,	// LPSECURITY_ATTRIBUTES lpEventAttributes
+				     FALSE,	// BOOL bManualReset
+				     FALSE,	// BOOL bInitialState
+				     pszObjectName);	// LPCTSTR lpName
+	pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] = hEventTermRequ;
+	ASSERT(pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] != NULL);
+
+	pszObjectName =
+	    ShbIpcGetUniformObjectName(NAME_EVENT_TERM_RESP,
+				       pShbMemHeader->m_szBufferID, FALSE);
+	hEventTermResp = CreateEvent(NULL,	// LPSECURITY_ATTRIBUTES lpEventAttributes
+				     FALSE,	// BOOL bManualReset
+				     FALSE,	// BOOL bInitialState
+				     pszObjectName);	// LPCTSTR lpName
+	pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] = hEventTermResp;
+	ASSERT(pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] != NULL);
+
+	hThreadNewData = CreateThread(NULL,	// LPSECURITY_ATTRIBUTES lpThreadAttributes
+				      0,	// SIZE_T dwStackSize
+				      ShbIpcThreadSignalNewData,	// LPTHREAD_START_ROUTINE lpStartAddress
+				      pShbInstance_p,	// LPVOID lpParameter
+				      0,	// DWORD dwCreationFlags
+				      &ulThreadIDNewData);	// LPDWORD lpThreadId
+
+	switch (ShbPriority_p) {
+	case kShbPriorityLow:
+		iPriority = THREAD_PRIORITY_BELOW_NORMAL;
+		break;
+
+	case kShbPriorityNormal:
+		iPriority = THREAD_PRIORITY_NORMAL;
+		break;
+
+	case kshbPriorityHigh:
+		iPriority = THREAD_PRIORITY_ABOVE_NORMAL;
+		break;
+
+	}
+
+	ASSERT(pShbMemInst->m_hThreadNewData != NULL);
+
+	SetThreadPriority(hThreadNewData, iPriority);
+
+	pShbMemInst->m_hThreadNewData = hThreadNewData;
+
+#ifndef NDEBUG
+	{
+		pShbMemInst->m_ulThreadIDNewData = ulThreadIDNewData;
+	}
+#endif
 
-Exit:
+      Exit:
 
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Stop signaling of new data (called from reading process)
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcStopSignalingNewData (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbError ShbIpcStopSignalingNewData(tShbInstance
+						     pShbInstance_p)
 {
 
-tShbMemInst*  pShbMemInst;
-HANDLE        hEventTermRequ;
-HANDLE        hEventTermResp;
-DWORD         dwWaitResult;
-
-
-    if (pShbInstance_p == NULL)
-    {
-        return (kShbInvalidArg);
-    }
-
-    pShbMemInst = ShbIpcGetShbMemInst (pShbInstance_p);
-
-
-    // terminate new data signaling thread
-    // (set event <hEventTermRequ> to wakeup the thread and dispose it
-    // to exit, then wait for confirmation using event <hEventTermResp>)
-    hEventTermRequ = pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU];
-    hEventTermResp = pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP];
-    if ( (hEventTermRequ != INVALID_HANDLE_VALUE) &&
-         (hEventTermResp != INVALID_HANDLE_VALUE)  )
-    {
-        TRACE0("\nShbIpcStopSignalingNewData(): enter wait state");
-        dwWaitResult = SignalObjectAndWait (hEventTermRequ,         // HANDLE hObjectToSignal
-                                            hEventTermResp,         // HANDLE hObjectToWaitOn
-                                            TIMEOUT_TERM_THREAD,    // DWORD dwMilliseconds
-                                            FALSE);                 // BOOL bAlertable
-        TRACE0("\nShbIpcStopSignalingNewData(): wait state leaved: ---> ");
-        switch (dwWaitResult)
-        {
-            case WAIT_OBJECT_0 + 0:     // event "new data signaling thread terminated"
-            {
-                TRACE0("Event = WAIT_OBJECT_0+0");
-                break;
-            }
-
-            default:
-            {
-                TRACE0("Unhandled Event");
-                ASSERT(0);
-                break;
-            }
-        }
-    }
-
-
-    if (pShbMemInst->m_hThreadNewData != INVALID_HANDLE_VALUE)
-    {
-        CloseHandle (pShbMemInst->m_hThreadNewData);
-        pShbMemInst->m_hThreadNewData = INVALID_HANDLE_VALUE;
-    }
-
-    if (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] != INVALID_HANDLE_VALUE)
-    {
-        CloseHandle (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU]);
-        pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] = INVALID_HANDLE_VALUE;
-    }
-
-    if (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] != INVALID_HANDLE_VALUE)
-    {
-        CloseHandle (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP]);
-        pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] = INVALID_HANDLE_VALUE;
-    }
-
-    pShbMemInst->m_pfnSigHndlrNewData = NULL;
+	tShbMemInst *pShbMemInst;
+	HANDLE hEventTermRequ;
+	HANDLE hEventTermResp;
+	DWORD dwWaitResult;
+
+	if (pShbInstance_p == NULL) {
+		return (kShbInvalidArg);
+	}
+
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+
+	// terminate new data signaling thread
+	// (set event <hEventTermRequ> to wakeup the thread and dispose it
+	// to exit, then wait for confirmation using event <hEventTermResp>)
+	hEventTermRequ = pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU];
+	hEventTermResp = pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP];
+	if ((hEventTermRequ != INVALID_HANDLE_VALUE) &&
+	    (hEventTermResp != INVALID_HANDLE_VALUE)) {
+		TRACE0("\nShbIpcStopSignalingNewData(): enter wait state");
+		dwWaitResult = SignalObjectAndWait(hEventTermRequ,	// HANDLE hObjectToSignal
+						   hEventTermResp,	// HANDLE hObjectToWaitOn
+						   TIMEOUT_TERM_THREAD,	// DWORD dwMilliseconds
+						   FALSE);	// BOOL bAlertable
+		TRACE0
+		    ("\nShbIpcStopSignalingNewData(): wait state leaved: ---> ");
+		switch (dwWaitResult) {
+		case WAIT_OBJECT_0 + 0:	// event "new data signaling thread terminated"
+			{
+				TRACE0("Event = WAIT_OBJECT_0+0");
+				break;
+			}
+
+		default:
+			{
+				TRACE0("Unhandled Event");
+				ASSERT(0);
+				break;
+			}
+		}
+	}
+
+	if (pShbMemInst->m_hThreadNewData != INVALID_HANDLE_VALUE) {
+		CloseHandle(pShbMemInst->m_hThreadNewData);
+		pShbMemInst->m_hThreadNewData = INVALID_HANDLE_VALUE;
+	}
+
+	if (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] !=
+	    INVALID_HANDLE_VALUE) {
+		CloseHandle(pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU]);
+		pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_REQU] =
+		    INVALID_HANDLE_VALUE;
+	}
+
+	if (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] !=
+	    INVALID_HANDLE_VALUE) {
+		CloseHandle(pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP]);
+		pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] =
+		    INVALID_HANDLE_VALUE;
+	}
 
+	pShbMemInst->m_pfnSigHndlrNewData = NULL;
 
-    return (kShbOk);
+	return (kShbOk);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Signal new data (called from writing process)
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcSignalNewData (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbError ShbIpcSignalNewData(tShbInstance pShbInstance_p)
 {
 
-tShbMemInst*  pShbMemInst;
-HANDLE  hEventNewData;
-BOOL    fRes;
-
-
-    // TRACE0("\nShbIpcSignalNewData(): enter\n");
-
-    if (pShbInstance_p == NULL)
-    {
-        return (kShbInvalidArg);
-    }
-
-
-    pShbMemInst = ShbIpcGetShbMemInst (pShbInstance_p);
-
-    ASSERT(pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA] != INVALID_HANDLE_VALUE);
-    hEventNewData = pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA];
-    if (hEventNewData != INVALID_HANDLE_VALUE)
-    {
-        fRes = SetEvent (hEventNewData);
-        // TRACE1("\nShbIpcSignalNewData(): EventNewData set (Result=%d)\n", (int)fRes);
-        ASSERT( fRes );
-    }
-
-    // TRACE0("\nShbIpcSignalNewData(): leave\n");
-    return (kShbOk);
+	tShbMemInst *pShbMemInst;
+	HANDLE hEventNewData;
+	BOOL fRes;
+
+	// TRACE0("\nShbIpcSignalNewData(): enter\n");
+
+	if (pShbInstance_p == NULL) {
+		return (kShbInvalidArg);
+	}
+
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+
+	ASSERT(pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA] !=
+	       INVALID_HANDLE_VALUE);
+	hEventNewData = pShbMemInst->m_ahEventNewData[IDX_EVENT_NEW_DATA];
+	if (hEventNewData != INVALID_HANDLE_VALUE) {
+		fRes = SetEvent(hEventNewData);
+		// TRACE1("\nShbIpcSignalNewData(): EventNewData set (Result=%d)\n", (int)fRes);
+		ASSERT(fRes);
+	}
+	// TRACE0("\nShbIpcSignalNewData(): leave\n");
+	return (kShbOk);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Start signaling for job ready (called from waiting process)
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcStartSignalingJobReady (
-    tShbInstance pShbInstance_p,
-    unsigned long ulTimeOut_p,
-    tSigHndlrJobReady pfnSignalHandlerJobReady_p)
-{
-
-tShbMemInst*    pShbMemInst;
-tShbMemHeader*  pShbMemHeader;
-HANDLE          hThreadJobReady;
-unsigned long   ulThreadIDJobReady;
-tShbError       ShbError;
-
-
-    if ((pShbInstance_p == NULL) || (pfnSignalHandlerJobReady_p == NULL))
-    {
-        return (kShbInvalidArg);
-    }
-
-
-    pShbMemInst   = ShbIpcGetShbMemInst   (pShbInstance_p);
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbInstance_p);
-    ShbError = kShbOk;
-
-    if ( (pShbMemInst->m_hThreadJobReady     != INVALID_HANDLE_VALUE) ||
-         (pShbMemInst->m_pfnSigHndlrJobReady != NULL) )
-    {
-        ShbError = kShbAlreadySignaling;
-        goto Exit;
-    }
-
-
-    pShbMemInst->m_ulTimeOutJobReady   = ulTimeOut_p;
-    pShbMemInst->m_pfnSigHndlrJobReady = pfnSignalHandlerJobReady_p;
-
-
-    // Because the event <pShbMemInst->m_ahEventJobReady> is used for
-    // signaling of a finished job too (using SetEvent), it is always
-    // created here (see <ShbIpcAllocBuffer>).
-
-    hThreadJobReady = CreateThread (NULL,                       // LPSECURITY_ATTRIBUTES lpThreadAttributes
-                                    0,                          // SIZE_T dwStackSize
-                                    ShbIpcThreadSignalJobReady, // LPTHREAD_START_ROUTINE lpStartAddress
-                                    pShbInstance_p,             // LPVOID lpParameter
-                                    0,                          // DWORD dwCreationFlags
-                                    &ulThreadIDJobReady);       // LPDWORD lpThreadId
-
-    pShbMemInst->m_hThreadJobReady = hThreadJobReady;
-    ASSERT(pShbMemInst->m_hThreadJobReady != NULL);
-
-    #ifndef NDEBUG
-    {
-        pShbMemInst->m_ulThreadIDJobReady = ulThreadIDJobReady;
-    }
-    #endif
-
+INLINE_FUNCTION tShbError ShbIpcStartSignalingJobReady(tShbInstance
+						       pShbInstance_p,
+						       unsigned long
+						       ulTimeOut_p,
+						       tSigHndlrJobReady
+						       pfnSignalHandlerJobReady_p)
+{
+
+	tShbMemInst *pShbMemInst;
+	tShbMemHeader *pShbMemHeader;
+	HANDLE hThreadJobReady;
+	unsigned long ulThreadIDJobReady;
+	tShbError ShbError;
+
+	if ((pShbInstance_p == NULL) || (pfnSignalHandlerJobReady_p == NULL)) {
+		return (kShbInvalidArg);
+	}
+
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbInstance_p);
+	ShbError = kShbOk;
+
+	if ((pShbMemInst->m_hThreadJobReady != INVALID_HANDLE_VALUE) ||
+	    (pShbMemInst->m_pfnSigHndlrJobReady != NULL)) {
+		ShbError = kShbAlreadySignaling;
+		goto Exit;
+	}
+
+	pShbMemInst->m_ulTimeOutJobReady = ulTimeOut_p;
+	pShbMemInst->m_pfnSigHndlrJobReady = pfnSignalHandlerJobReady_p;
+
+	// Because the event <pShbMemInst->m_ahEventJobReady> is used for
+	// signaling of a finished job too (using SetEvent), it is always
+	// created here (see <ShbIpcAllocBuffer>).
+
+	hThreadJobReady = CreateThread(NULL,	// LPSECURITY_ATTRIBUTES lpThreadAttributes
+				       0,	// SIZE_T dwStackSize
+				       ShbIpcThreadSignalJobReady,	// LPTHREAD_START_ROUTINE lpStartAddress
+				       pShbInstance_p,	// LPVOID lpParameter
+				       0,	// DWORD dwCreationFlags
+				       &ulThreadIDJobReady);	// LPDWORD lpThreadId
+
+	pShbMemInst->m_hThreadJobReady = hThreadJobReady;
+	ASSERT(pShbMemInst->m_hThreadJobReady != NULL);
+
+#ifndef NDEBUG
+	{
+		pShbMemInst->m_ulThreadIDJobReady = ulThreadIDJobReady;
+	}
+#endif
 
-Exit:
+      Exit:
 
-    return (ShbError);
+	return (ShbError);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Signal job ready (called from executing process)
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION tShbError  ShbIpcSignalJobReady (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION tShbError ShbIpcSignalJobReady(tShbInstance pShbInstance_p)
 {
 
-tShbMemInst*  pShbMemInst;
-HANDLE  hEventJobReady;
-BOOL    fRes;
-
-
-    // TRACE0("\nShbIpcSignalJobReady(): enter\n");
-
-    if (pShbInstance_p == NULL)
-    {
-        return (kShbInvalidArg);
-    }
-
-
-    pShbMemInst = ShbIpcGetShbMemInst (pShbInstance_p);
-
-    ASSERT(pShbMemInst->m_hEventJobReady != INVALID_HANDLE_VALUE);
-    hEventJobReady = pShbMemInst->m_hEventJobReady;
-    if (hEventJobReady != INVALID_HANDLE_VALUE)
-    {
-        fRes = SetEvent (hEventJobReady);
-        // TRACE1("\nShbIpcSignalJobReady(): EventJobReady set (Result=%d)\n", (int)fRes);
-        ASSERT( fRes );
-    }
-
-    // TRACE0("\nShbIpcSignalJobReady(): leave\n");
-    return (kShbOk);
+	tShbMemInst *pShbMemInst;
+	HANDLE hEventJobReady;
+	BOOL fRes;
+
+	// TRACE0("\nShbIpcSignalJobReady(): enter\n");
+
+	if (pShbInstance_p == NULL) {
+		return (kShbInvalidArg);
+	}
+
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance_p);
+
+	ASSERT(pShbMemInst->m_hEventJobReady != INVALID_HANDLE_VALUE);
+	hEventJobReady = pShbMemInst->m_hEventJobReady;
+	if (hEventJobReady != INVALID_HANDLE_VALUE) {
+		fRes = SetEvent(hEventJobReady);
+		// TRACE1("\nShbIpcSignalJobReady(): EventJobReady set (Result=%d)\n", (int)fRes);
+		ASSERT(fRes);
+	}
+	// TRACE0("\nShbIpcSignalJobReady(): leave\n");
+	return (kShbOk);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Get pointer to common used share memory area
 //---------------------------------------------------------------------------
 
-INLINE_FUNCTION void*  ShbIpcGetShMemPtr (
-    tShbInstance pShbInstance_p)
+INLINE_FUNCTION void *ShbIpcGetShMemPtr(tShbInstance pShbInstance_p)
 {
 
-tShbMemHeader*  pShbMemHeader;
-void*  pShbShMemPtr;
-
+	tShbMemHeader *pShbMemHeader;
+	void *pShbShMemPtr;
 
-    pShbMemHeader = ShbIpcGetShbMemHeader (pShbInstance_p);
-    if (pShbMemHeader != NULL)
-    {
-        pShbShMemPtr = (BYTE*)pShbMemHeader + sizeof(tShbMemHeader);
-    }
-    else
-    {
-        pShbShMemPtr = NULL;
-    }
+	pShbMemHeader = ShbIpcGetShbMemHeader(pShbInstance_p);
+	if (pShbMemHeader != NULL) {
+		pShbShMemPtr = (BYTE *) pShbMemHeader + sizeof(tShbMemHeader);
+	} else {
+		pShbShMemPtr = NULL;
+	}
 
-    return (pShbShMemPtr);
+	return (pShbShMemPtr);
 
 }
 
 #endif
 
-
-
 //=========================================================================//
 //                                                                         //
 //          P R I V A T E   F U N C T I O N S                              //
@@ -1064,265 +962,241 @@ void*  pShbShMemPtr;
 //  Allocate a memory block from process specific mempool
 //---------------------------------------------------------------------------
 
-static void*  ShbIpcAllocPrivateMem (
-    unsigned long ulMemSize_p)
+static void *ShbIpcAllocPrivateMem(unsigned long ulMemSize_p)
 {
 
-HGLOBAL  hMem;
-void*    pMem;
-
-
-    hMem = GlobalAlloc (GMEM_FIXED, ulMemSize_p+sizeof(HGLOBAL));
-    pMem = GlobalLock  (hMem);
-    if (pMem != NULL)
-    {
-        *(HGLOBAL*)pMem = hMem;
-        (BYTE*)pMem += sizeof(HGLOBAL);
-    }
-
-
-    #ifndef NDEBUG
-    {
-        memset (pMem, 0xaa, ulMemSize_p);
-    }
-    #endif
+	HGLOBAL hMem;
+	void *pMem;
 
+	hMem = GlobalAlloc(GMEM_FIXED, ulMemSize_p + sizeof(HGLOBAL));
+	pMem = GlobalLock(hMem);
+	if (pMem != NULL) {
+		*(HGLOBAL *) pMem = hMem;
+		(BYTE *) pMem += sizeof(HGLOBAL);
+	}
+
+#ifndef NDEBUG
+	{
+		memset(pMem, 0xaa, ulMemSize_p);
+	}
+#endif
 
-    return (pMem);
+	return (pMem);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Release a memory block from process specific mempool
 //---------------------------------------------------------------------------
 
-static void  ShbIpcReleasePrivateMem (
-    void* pMem_p)
+static void ShbIpcReleasePrivateMem(void *pMem_p)
 {
 
-HGLOBAL  hMem;
+	HGLOBAL hMem;
 
+	if (pMem_p == NULL) {
+		return;
+	}
 
-    if (pMem_p == NULL)
-    {
-        return;
-    }
+	(BYTE *) pMem_p -= sizeof(HGLOBAL);
+	hMem = *(HGLOBAL *) pMem_p;
 
+	GlobalUnlock(hMem);
+	GlobalFree(hMem);
 
-    (BYTE*)pMem_p -= sizeof(HGLOBAL);
-    hMem = *(HGLOBAL*)pMem_p;
-
-    GlobalUnlock (hMem);
-    GlobalFree   (hMem);
-
-    return;
+	return;
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Create uniform object name (needed for inter-process communication)
 //---------------------------------------------------------------------------
 
-const char*  ShbIpcGetUniformObjectName (
-    const char* pszObjectJobName_p,
-    const char* pszBufferID_p,
-    BOOL fGlobalObject_p)
+const char *ShbIpcGetUniformObjectName(const char *pszObjectJobName_p,
+				       const char *pszBufferID_p,
+				       BOOL fGlobalObject_p)
 {
 
-static  char  szObjectName[MAX_PATH];
-char  szObjectPrefix[MAX_PATH];
-
-
-    if ( fGlobalObject_p )
-    {
-        strncpy (szObjectPrefix, "Global\\", sizeof(szObjectPrefix));
-    }
-    else
-    {
-        _snprintf (szObjectPrefix, sizeof(szObjectPrefix), "PID%08lX_",
-                   (unsigned long)GetCurrentProcessId());
-    }
-
+	static char szObjectName[MAX_PATH];
+	char szObjectPrefix[MAX_PATH];
 
-    _snprintf (szObjectName, sizeof(szObjectName), "%s%s#%s",
-               szObjectPrefix, pszBufferID_p, pszObjectJobName_p);
+	if (fGlobalObject_p) {
+		strncpy(szObjectPrefix, "Global\\", sizeof(szObjectPrefix));
+	} else {
+		_snprintf(szObjectPrefix, sizeof(szObjectPrefix), "PID%08lX_",
+			  (unsigned long)GetCurrentProcessId());
+	}
 
+	_snprintf(szObjectName, sizeof(szObjectName), "%s%s#%s",
+		  szObjectPrefix, pszBufferID_p, pszObjectJobName_p);
 
-    return (szObjectName);
+	return (szObjectName);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Thread for new data signaling
 //---------------------------------------------------------------------------
 
-DWORD  WINAPI  ShbIpcThreadSignalNewData (
-    LPVOID pvThreadParam_p)
+DWORD WINAPI ShbIpcThreadSignalNewData(LPVOID pvThreadParam_p)
 {
 
-tShbInstance  pShbInstance;
-tShbMemInst*  pShbMemInst;
-DWORD         dwWaitResult;
-BOOL          fTermRequ;
-int           fCallAgain;
-
-
-    TRACE1("\nShbIpcThreadSignalNewData(): SignalThread started (pShbInstance=0x%08lX)\n", (DWORD)pvThreadParam_p);
-
-    pShbInstance = (tShbMemInst*)pvThreadParam_p;
-    pShbMemInst  = ShbIpcGetShbMemInst (pShbInstance);
-    fTermRequ    = FALSE;
-
-    do
-    {
-        ASSERT((pShbMemInst->m_ahEventNewData[0] != INVALID_HANDLE_VALUE) && (pShbMemInst->m_ahEventNewData[0] != NULL));
-        ASSERT((pShbMemInst->m_ahEventNewData[1] != INVALID_HANDLE_VALUE) && (pShbMemInst->m_ahEventNewData[1] != NULL));
-
-        TRACE0("\nShbIpcThreadSignalNewData(): enter wait state");
-        dwWaitResult = WaitForMultipleObjects (2,                               // DWORD nCount
-                                               pShbMemInst->m_ahEventNewData,   // const HANDLE* lpHandles
-                                               FALSE,                           // BOOL bWaitAll
-                                               INFINITE);                       // DWORD dwMilliseconds
-        TRACE0("\nShbIpcThreadSignalNewData(): wait state leaved: ---> ");
-        switch (dwWaitResult)
-        {
-            case WAIT_OBJECT_0 + 0:     // event "new data"
-            {
-                TRACE0("Event = WAIT_OBJECT_0+0");
-                if (pShbMemInst->m_pfnSigHndlrNewData != NULL)
-                {
-                    TRACE0("\nShbIpcThreadSignalNewData(): calling SignalHandlerNewData");
-                    do
-                    {
-                        fCallAgain = pShbMemInst->m_pfnSigHndlrNewData (pShbInstance);
-                        // d.k.: try to run any shared buffer which has higher priority.
-                        //           under Windows this is not really necessary because the Windows scheduler
-                        //           already preempts tasks with lower priority.
-                    } while (fCallAgain != FALSE);
-                }
-                break;
-            }
-
-            case WAIT_OBJECT_0 + 1:     // event "terminate"
-            {
-                TRACE0("Event = WAIT_OBJECT_0+1");
-                fTermRequ = TRUE;
-                break;
-            }
-
-            default:
-            {
-                TRACE0("Unhandled Event");
-                ASSERT(0);
-                fTermRequ = TRUE;
-                break;
-            }
-        }
-    }
-    while ( !fTermRequ );
-
-
-    if (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] != INVALID_HANDLE_VALUE)
-    {
-        SetEvent (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP]);
-    }
-
-    TRACE1("\nShbIpcThreadSignalNewData(): SignalThread terminated (pShbInstance=0x%08lX)\n", (DWORD)pShbInstance);
+	tShbInstance pShbInstance;
+	tShbMemInst *pShbMemInst;
+	DWORD dwWaitResult;
+	BOOL fTermRequ;
+	int fCallAgain;
+
+	TRACE1
+	    ("\nShbIpcThreadSignalNewData(): SignalThread started (pShbInstance=0x%08lX)\n",
+	     (DWORD) pvThreadParam_p);
+
+	pShbInstance = (tShbMemInst *) pvThreadParam_p;
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance);
+	fTermRequ = FALSE;
+
+	do {
+		ASSERT((pShbMemInst->m_ahEventNewData[0] !=
+			INVALID_HANDLE_VALUE)
+		       && (pShbMemInst->m_ahEventNewData[0] != NULL));
+		ASSERT((pShbMemInst->m_ahEventNewData[1] !=
+			INVALID_HANDLE_VALUE)
+		       && (pShbMemInst->m_ahEventNewData[1] != NULL));
+
+		TRACE0("\nShbIpcThreadSignalNewData(): enter wait state");
+		dwWaitResult = WaitForMultipleObjects(2,	// DWORD nCount
+						      pShbMemInst->m_ahEventNewData,	// const HANDLE* lpHandles
+						      FALSE,	// BOOL bWaitAll
+						      INFINITE);	// DWORD dwMilliseconds
+		TRACE0
+		    ("\nShbIpcThreadSignalNewData(): wait state leaved: ---> ");
+		switch (dwWaitResult) {
+		case WAIT_OBJECT_0 + 0:	// event "new data"
+			{
+				TRACE0("Event = WAIT_OBJECT_0+0");
+				if (pShbMemInst->m_pfnSigHndlrNewData != NULL) {
+					TRACE0
+					    ("\nShbIpcThreadSignalNewData(): calling SignalHandlerNewData");
+					do {
+						fCallAgain =
+						    pShbMemInst->
+						    m_pfnSigHndlrNewData
+						    (pShbInstance);
+						// d.k.: try to run any shared buffer which has higher priority.
+						//           under Windows this is not really necessary because the Windows scheduler
+						//           already preempts tasks with lower priority.
+					} while (fCallAgain != FALSE);
+				}
+				break;
+			}
+
+		case WAIT_OBJECT_0 + 1:	// event "terminate"
+			{
+				TRACE0("Event = WAIT_OBJECT_0+1");
+				fTermRequ = TRUE;
+				break;
+			}
+
+		default:
+			{
+				TRACE0("Unhandled Event");
+				ASSERT(0);
+				fTermRequ = TRUE;
+				break;
+			}
+		}
+	}
+	while (!fTermRequ);
+
+	if (pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP] !=
+	    INVALID_HANDLE_VALUE) {
+		SetEvent(pShbMemInst->m_ahEventNewData[IDX_EVENT_TERM_RESP]);
+	}
+
+	TRACE1
+	    ("\nShbIpcThreadSignalNewData(): SignalThread terminated (pShbInstance=0x%08lX)\n",
+	     (DWORD) pShbInstance);
 
-    ExitThread (0);
+	ExitThread(0);
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //  Thread for new data signaling
 //---------------------------------------------------------------------------
 
-DWORD  WINAPI  ShbIpcThreadSignalJobReady (
-    LPVOID pvThreadParam_p)
+DWORD WINAPI ShbIpcThreadSignalJobReady(LPVOID pvThreadParam_p)
 {
 
-tShbInstance*  pShbInstance;
-tShbMemInst*   pShbMemInst;
-DWORD          ulTimeOut;
-DWORD          dwWaitResult;
-unsigned int   fTimeOut;
-
-
-    TRACE1("\nShbIpcThreadSignalJobReady(): SignalThread started (pShbInstance=0x%08lX)\n", (DWORD)pvThreadParam_p);
-
-
-    pShbInstance = (tShbInstance*)pvThreadParam_p;
-    pShbMemInst  = ShbIpcGetShbMemInst (pShbInstance);
-    fTimeOut     = FALSE;
-
-    if (pShbMemInst->m_ulTimeOutJobReady != 0)
-    {
-        ulTimeOut = pShbMemInst->m_ulTimeOutJobReady;
-    }
-    else
-    {
-        ulTimeOut = INFINITE;
-    }
-
-    ASSERT((pShbMemInst->m_hEventJobReady != INVALID_HANDLE_VALUE) && (pShbMemInst->m_hEventJobReady != NULL));
-
-    TRACE0("\nShbIpcThreadSignalJobReady(): enter wait state");
-    dwWaitResult = WaitForSingleObject (pShbMemInst->m_hEventJobReady,          // HANDLE hHandle
-                                        ulTimeOut);                             // DWORD dwMilliseconds
-    TRACE0("\nShbIpcThreadSignalJobReady(): wait state leaved: ---> ");
-    switch (dwWaitResult)
-    {
-        case WAIT_OBJECT_0 + 0:     // event "new data"
-        {
-            TRACE0("Event = WAIT_OBJECT_0+0");
-            fTimeOut = FALSE;
-            break;
-        }
-
-        case WAIT_TIMEOUT:
-        {
-            TRACE0("\nEvent = WAIT_TIMEOUT");
-            fTimeOut = TRUE;
-            // ASSERT(0);
-            break;
-        }
-
-        default:
-        {
-            TRACE0("Unhandled Event");
-            fTimeOut = TRUE;
-            ASSERT(0);
-            break;
-        }
-    }
-
-
-    if (pShbMemInst->m_pfnSigHndlrJobReady != NULL)
-    {
-        TRACE0("\nShbIpcThreadSignalJobReady(): calling SignalHandlerJobReady");
-        pShbMemInst->m_pfnSigHndlrJobReady (pShbInstance, fTimeOut);
-    }
-
-
-    pShbMemInst->m_hThreadJobReady     = INVALID_HANDLE_VALUE;
-    pShbMemInst->m_pfnSigHndlrJobReady = NULL;
+	tShbInstance *pShbInstance;
+	tShbMemInst *pShbMemInst;
+	DWORD ulTimeOut;
+	DWORD dwWaitResult;
+	unsigned int fTimeOut;
+
+	TRACE1
+	    ("\nShbIpcThreadSignalJobReady(): SignalThread started (pShbInstance=0x%08lX)\n",
+	     (DWORD) pvThreadParam_p);
+
+	pShbInstance = (tShbInstance *) pvThreadParam_p;
+	pShbMemInst = ShbIpcGetShbMemInst(pShbInstance);
+	fTimeOut = FALSE;
+
+	if (pShbMemInst->m_ulTimeOutJobReady != 0) {
+		ulTimeOut = pShbMemInst->m_ulTimeOutJobReady;
+	} else {
+		ulTimeOut = INFINITE;
+	}
+
+	ASSERT((pShbMemInst->m_hEventJobReady != INVALID_HANDLE_VALUE)
+	       && (pShbMemInst->m_hEventJobReady != NULL));
+
+	TRACE0("\nShbIpcThreadSignalJobReady(): enter wait state");
+	dwWaitResult = WaitForSingleObject(pShbMemInst->m_hEventJobReady,	// HANDLE hHandle
+					   ulTimeOut);	// DWORD dwMilliseconds
+	TRACE0("\nShbIpcThreadSignalJobReady(): wait state leaved: ---> ");
+	switch (dwWaitResult) {
+	case WAIT_OBJECT_0 + 0:	// event "new data"
+		{
+			TRACE0("Event = WAIT_OBJECT_0+0");
+			fTimeOut = FALSE;
+			break;
+		}
+
+	case WAIT_TIMEOUT:
+		{
+			TRACE0("\nEvent = WAIT_TIMEOUT");
+			fTimeOut = TRUE;
+			// ASSERT(0);
+			break;
+		}
+
+	default:
+		{
+			TRACE0("Unhandled Event");
+			fTimeOut = TRUE;
+			ASSERT(0);
+			break;
+		}
+	}
+
+	if (pShbMemInst->m_pfnSigHndlrJobReady != NULL) {
+		TRACE0
+		    ("\nShbIpcThreadSignalJobReady(): calling SignalHandlerJobReady");
+		pShbMemInst->m_pfnSigHndlrJobReady(pShbInstance, fTimeOut);
+	}
+
+	pShbMemInst->m_hThreadJobReady = INVALID_HANDLE_VALUE;
+	pShbMemInst->m_pfnSigHndlrJobReady = NULL;
+
+	TRACE1
+	    ("\nShbIpcThreadSignalJobReady(): SignalThread terminated (pShbInstance=0x%08lX)\n",
+	     (DWORD) pShbInstance);
 
-
-    TRACE1("\nShbIpcThreadSignalJobReady(): SignalThread terminated (pShbInstance=0x%08lX)\n", (DWORD)pShbInstance);
-
-    ExitThread (0);
+	ExitThread(0);
 
 }
 
 #endif
 
 // EOF
-
--- a/drivers/staging/epl/SocketLinuxKernel.c
+++ b/drivers/staging/epl/SocketLinuxKernel.c
@@ -68,12 +68,10 @@
 
 ****************************************************************************/
 
-
 #include <linux/net.h>
 #include <linux/in.h>
 #include "SocketLinuxKernel.h"
 
-
 /***************************************************************************/
 /*                                                                         */
 /*                                                                         */
@@ -82,34 +80,26 @@
 /*                                                                         */
 /***************************************************************************/
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 // modul globale vars
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-
 //---------------------------------------------------------------------------
 //  Kernel Module specific Data Structures
 //---------------------------------------------------------------------------
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -136,75 +126,72 @@
 
 SOCKET socket(int af, int type, int protocol)
 {
-int rc;
-SOCKET socket;
+	int rc;
+	SOCKET socket;
 
-    rc = sock_create_kern(af, type, protocol, &socket);
-    if (rc < 0)
-    {
-        socket = NULL;
-        goto Exit;
-    }
+	rc = sock_create_kern(af, type, protocol, &socket);
+	if (rc < 0) {
+		socket = NULL;
+		goto Exit;
+	}
 
-Exit:
-    return socket;
+      Exit:
+	return socket;
 }
 
 int bind(SOCKET socket_p, const struct sockaddr *addr, int addrlen)
 {
-int rc;
+	int rc;
 
-    rc = socket_p->ops->bind(socket_p,
-                          (struct sockaddr *)addr,
-                          addrlen);
+	rc = socket_p->ops->bind(socket_p, (struct sockaddr *)addr, addrlen);
 
-    return rc;
+	return rc;
 }
 
 int closesocket(SOCKET socket_p)
 {
-    sock_release(socket_p);
+	sock_release(socket_p);
 
-    return 0;
+	return 0;
 }
 
-int recvfrom(SOCKET socket_p, char* buf, int len, int flags, struct sockaddr *from, int * fromlen)
+int recvfrom(SOCKET socket_p, char *buf, int len, int flags,
+	     struct sockaddr *from, int *fromlen)
 {
-int rc;
-struct msghdr msg;
-struct kvec iov;
-
-    msg.msg_control = NULL;
-    msg.msg_controllen = 0;
-    msg.msg_name = from;     // will be struct sock_addr
-    msg.msg_namelen = *fromlen;
-    iov.iov_len = len;
-    iov.iov_base = buf;
+	int rc;
+	struct msghdr msg;
+	struct kvec iov;
+
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_name = from;	// will be struct sock_addr
+	msg.msg_namelen = *fromlen;
+	iov.iov_len = len;
+	iov.iov_base = buf;
 
-    rc = kernel_recvmsg(socket_p, &msg, &iov, 1, iov.iov_len, 0);
+	rc = kernel_recvmsg(socket_p, &msg, &iov, 1, iov.iov_len, 0);
 
-    return rc;
+	return rc;
 }
 
-int sendto(SOCKET socket_p, const char* buf, int len, int flags, const struct sockaddr *to, int tolen)
+int sendto(SOCKET socket_p, const char *buf, int len, int flags,
+	   const struct sockaddr *to, int tolen)
 {
-int rc;
-struct msghdr msg;
-struct kvec iov;
-
-    msg.msg_control = NULL;
-    msg.msg_controllen = 0;
-    msg.msg_name = (struct sockaddr *)to;     // will be struct sock_addr
-    msg.msg_namelen = tolen;
-    msg.msg_flags = 0;
-    iov.iov_len = len;
-    iov.iov_base = (char *)buf;
+	int rc;
+	struct msghdr msg;
+	struct kvec iov;
+
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_name = (struct sockaddr *)to;	// will be struct sock_addr
+	msg.msg_namelen = tolen;
+	msg.msg_flags = 0;
+	iov.iov_len = len;
+	iov.iov_base = (char *)buf;
 
-    rc = kernel_sendmsg(socket_p, &msg, &iov, 1, len);
+	rc = kernel_sendmsg(socket_p, &msg, &iov, 1, len);
 
-    return rc;
+	return rc;
 }
 
-
 // EOF
-
--- a/drivers/staging/epl/TimerHighReskX86.c
+++ b/drivers/staging/epl/TimerHighReskX86.c
@@ -91,27 +91,25 @@
 // const defines
 //---------------------------------------------------------------------------
 
-#define TIMER_COUNT           2            /* max 15 timers selectable */
-#define TIMER_MIN_VAL_SINGLE  5000         /* min 5us */
-#define TIMER_MIN_VAL_CYCLE   100000       /* min 100us */
+#define TIMER_COUNT           2	/* max 15 timers selectable */
+#define TIMER_MIN_VAL_SINGLE  5000	/* min 5us */
+#define TIMER_MIN_VAL_CYCLE   100000	/* min 100us */
 
 #define PROVE_OVERRUN
 
-
 #ifndef CONFIG_HIGH_RES_TIMERS
-    #error "Kernel symbol CONFIG_HIGH_RES_TIMERS is required."
+#error "Kernel symbol CONFIG_HIGH_RES_TIMERS is required."
 #endif
 
-
 // TracePoint support for realtime-debugging
 #ifdef _DBG_TRACE_POINTS_
-    void  PUBLIC  TgtDbgSignalTracePoint (BYTE bTracePointNumber_p);
-    void  PUBLIC  TgtDbgPostTraceValue (DWORD dwTraceValue_p);
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
+void PUBLIC TgtDbgSignalTracePoint(BYTE bTracePointNumber_p);
+void PUBLIC TgtDbgPostTraceValue(DWORD dwTraceValue_p);
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)   TgtDbgSignalTracePoint(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)     TgtDbgPostTraceValue(v)
 #else
-    #define TGT_DBG_SIGNAL_TRACE_POINT(p)
-    #define TGT_DBG_POST_TRACE_VALUE(v)
+#define TGT_DBG_SIGNAL_TRACE_POINT(p)
+#define TGT_DBG_POST_TRACE_VALUE(v)
 #endif
 #define HRT_DBG_POST_TRACE_VALUE(Event_p, uiNodeId_p, wErrorCode_p) \
     TGT_DBG_POST_TRACE_VALUE((0xE << 28) | (Event_p << 24) \
@@ -128,19 +126,17 @@
 // modul global types
 //---------------------------------------------------------------------------
 
-typedef struct
-{
-    tEplTimerEventArg    m_EventArg;
-    tEplTimerkCallback   m_pfnCallback;
-    struct hrtimer       m_Timer;
-    BOOL                 m_fContinuously;
-    unsigned long long   m_ullPeriod;
+typedef struct {
+	tEplTimerEventArg m_EventArg;
+	tEplTimerkCallback m_pfnCallback;
+	struct hrtimer m_Timer;
+	BOOL m_fContinuously;
+	unsigned long long m_ullPeriod;
 
 } tEplTimerHighReskTimerInfo;
 
-typedef struct
-{
-    tEplTimerHighReskTimerInfo  m_aTimerInfo[TIMER_COUNT];
+typedef struct {
+	tEplTimerHighReskTimerInfo m_aTimerInfo[TIMER_COUNT];
 
 } tEplTimerHighReskInstance;
 
@@ -148,13 +144,13 @@ typedef struct
 // local vars
 //---------------------------------------------------------------------------
 
-static tEplTimerHighReskInstance    EplTimerHighReskInstance_l;
+static tEplTimerHighReskInstance EplTimerHighReskInstance_l;
 
 //---------------------------------------------------------------------------
 // local function prototypes
 //---------------------------------------------------------------------------
 
-enum hrtimer_restart EplTimerHighReskCallback (struct hrtimer* pTimer_p);
+enum hrtimer_restart EplTimerHighReskCallback(struct hrtimer *pTimer_p);
 
 //=========================================================================//
 //                                                                         //
@@ -162,7 +158,6 @@ enum hrtimer_restart EplTimerHighReskCal
 //                                                                         //
 //=========================================================================//
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimerHighReskInit()
@@ -179,15 +174,14 @@ enum hrtimer_restart EplTimerHighReskCal
 
 tEplKernel PUBLIC EplTimerHighReskInit(void)
 {
-tEplKernel  Ret;
+	tEplKernel Ret;
 
-    Ret = EplTimerHighReskAddInstance();
+	Ret = EplTimerHighReskAddInstance();
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimerHighReskAddInstance()
@@ -204,45 +198,45 @@ tEplKernel  Ret;
 
 tEplKernel PUBLIC EplTimerHighReskAddInstance(void)
 {
-tEplKernel                   Ret;
-unsigned int                 uiIndex;
+	tEplKernel Ret;
+	unsigned int uiIndex;
 
-    Ret = kEplSuccessful;
+	Ret = kEplSuccessful;
 
-    EPL_MEMSET(&EplTimerHighReskInstance_l, 0, sizeof (EplTimerHighReskInstance_l));
+	EPL_MEMSET(&EplTimerHighReskInstance_l, 0,
+		   sizeof(EplTimerHighReskInstance_l));
 
 #ifndef CONFIG_HIGH_RES_TIMERS
-    printk("EplTimerHighResk: Kernel symbol CONFIG_HIGH_RES_TIMERS is required.\n");
-    Ret = kEplNoResource;
-    return Ret;
+	printk
+	    ("EplTimerHighResk: Kernel symbol CONFIG_HIGH_RES_TIMERS is required.\n");
+	Ret = kEplNoResource;
+	return Ret;
 #endif
 
-    /*
-     * Initialize hrtimer structures for all usable timers.
-     */
-    for (uiIndex = 0; uiIndex < TIMER_COUNT; uiIndex++)
-    {
-    tEplTimerHighReskTimerInfo*  pTimerInfo;
-    struct hrtimer*              pTimer;
-
-        pTimerInfo = &EplTimerHighReskInstance_l.m_aTimerInfo[uiIndex];
-        pTimer = &pTimerInfo->m_Timer;
-        hrtimer_init(pTimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
-
-        pTimer->function = EplTimerHighReskCallback;
-
-        /*
-         * We use HRTIMER_CB_SOFTIRQ here.
-         * HRTIMER_CB_IRQSAFE is critical as the callback function
-         * would be called with IRQs disabled.
-         */
-        pTimer->cb_mode = HRTIMER_CB_SOFTIRQ;
-    }
+	/*
+	 * Initialize hrtimer structures for all usable timers.
+	 */
+	for (uiIndex = 0; uiIndex < TIMER_COUNT; uiIndex++) {
+		tEplTimerHighReskTimerInfo *pTimerInfo;
+		struct hrtimer *pTimer;
+
+		pTimerInfo = &EplTimerHighReskInstance_l.m_aTimerInfo[uiIndex];
+		pTimer = &pTimerInfo->m_Timer;
+		hrtimer_init(pTimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+
+		pTimer->function = EplTimerHighReskCallback;
+
+		/*
+		 * We use HRTIMER_CB_SOFTIRQ here.
+		 * HRTIMER_CB_IRQSAFE is critical as the callback function
+		 * would be called with IRQs disabled.
+		 */
+		pTimer->cb_mode = HRTIMER_CB_SOFTIRQ;
+	}
 
-    return Ret;
+	return Ret;
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimerHighReskDelInstance()
@@ -259,30 +253,28 @@ unsigned int                 uiIndex;
 
 tEplKernel PUBLIC EplTimerHighReskDelInstance(void)
 {
-tEplTimerHighReskTimerInfo*  pTimerInfo;
-tEplKernel                   Ret;
-unsigned int                 uiIndex;
-
-    Ret = kEplSuccessful;
-
-    for (uiIndex = 0; uiIndex < TIMER_COUNT; uiIndex++)
-    {
-        pTimerInfo = &EplTimerHighReskInstance_l.m_aTimerInfo[0];
-        pTimerInfo->m_pfnCallback = NULL;
-        pTimerInfo->m_EventArg.m_TimerHdl = 0;
-        /*
-         * In this case we can not just try to cancel the timer.
-         * We actually have to wait until its callback function
-         * has returned.
-         */
-        hrtimer_cancel(&pTimerInfo->m_Timer);
-    }
+	tEplTimerHighReskTimerInfo *pTimerInfo;
+	tEplKernel Ret;
+	unsigned int uiIndex;
+
+	Ret = kEplSuccessful;
+
+	for (uiIndex = 0; uiIndex < TIMER_COUNT; uiIndex++) {
+		pTimerInfo = &EplTimerHighReskInstance_l.m_aTimerInfo[0];
+		pTimerInfo->m_pfnCallback = NULL;
+		pTimerInfo->m_EventArg.m_TimerHdl = 0;
+		/*
+		 * In this case we can not just try to cancel the timer.
+		 * We actually have to wait until its callback function
+		 * has returned.
+		 */
+		hrtimer_cancel(&pTimerInfo->m_Timer);
+	}
 
-    return Ret;
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimerHighReskModifyTimerNs()
@@ -313,96 +305,89 @@ unsigned int                 uiIndex;
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplTimerHighReskModifyTimerNs(tEplTimerHdl*     pTimerHdl_p,
-                                    unsigned long long  ullTimeNs_p,
-                                    tEplTimerkCallback  pfnCallback_p,
-                                    unsigned long       ulArgument_p,
-                                    BOOL                fContinuously_p)
+tEplKernel PUBLIC EplTimerHighReskModifyTimerNs(tEplTimerHdl * pTimerHdl_p,
+						unsigned long long ullTimeNs_p,
+						tEplTimerkCallback
+						pfnCallback_p,
+						unsigned long ulArgument_p,
+						BOOL fContinuously_p)
 {
-tEplKernel                   Ret;
-unsigned int                 uiIndex;
-tEplTimerHighReskTimerInfo*  pTimerInfo;
-ktime_t                      RelTime;
-
-    Ret = kEplSuccessful;
-
-    // check pointer to handle
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
-
-    if (*pTimerHdl_p == 0)
-    {   // no timer created yet
-
-        // search free timer info structure
-        pTimerInfo = &EplTimerHighReskInstance_l.m_aTimerInfo[0];
-        for (uiIndex = 0; uiIndex < TIMER_COUNT; uiIndex++, pTimerInfo++)
-        {
-            if (pTimerInfo->m_EventArg.m_TimerHdl == 0)
-            {   // free structure found
-                break;
-            }
-        }
-        if (uiIndex >= TIMER_COUNT)
-        {   // no free structure found
-            Ret = kEplTimerNoTimerCreated;
-            goto Exit;
-        }
-
-        pTimerInfo->m_EventArg.m_TimerHdl = HDL_INIT(uiIndex);
-    }
-    else
-    {
-        uiIndex = HDL_TO_IDX(*pTimerHdl_p);
-        if (uiIndex >= TIMER_COUNT)
-        {   // invalid handle
-            Ret = kEplTimerInvalidHandle;
-            goto Exit;
-        }
-
-        pTimerInfo = &EplTimerHighReskInstance_l.m_aTimerInfo[uiIndex];
-    }
-
-    /*
-     * increment timer handle
-     * (if timer expires right after this statement, the user
-     * would detect an unknown timer handle and discard it)
-     */
-    pTimerInfo->m_EventArg.m_TimerHdl = HDL_INC(pTimerInfo->m_EventArg.m_TimerHdl);
-    *pTimerHdl_p = pTimerInfo->m_EventArg.m_TimerHdl;
-
-    // reject too small time values
-    if (    (fContinuously_p  && (ullTimeNs_p < TIMER_MIN_VAL_CYCLE))
-         || (!fContinuously_p && (ullTimeNs_p < TIMER_MIN_VAL_SINGLE)) )
-    {
-        Ret = kEplTimerNoTimerCreated;
-        goto Exit;
-    }
-
-    pTimerInfo->m_EventArg.m_ulArg = ulArgument_p;
-    pTimerInfo->m_pfnCallback      = pfnCallback_p;
-    pTimerInfo->m_fContinuously    = fContinuously_p;
-    pTimerInfo->m_ullPeriod        = ullTimeNs_p;
-
-    /*
-     * HRTIMER_MODE_REL does not influence general handling of this timer.
-     * It only sets relative mode for this start operation.
-     * -> Expire time is calculated by: Now + RelTime
-     * hrtimer_start also skips pending timer events.
-     * The state HRTIMER_STATE_CALLBACK is ignored.
-     * We have to cope with that in our callback function.
-     */
-    RelTime = ktime_add_ns(ktime_set(0,0), ullTimeNs_p);
-    hrtimer_start(&pTimerInfo->m_Timer, RelTime, HRTIMER_MODE_REL);
+	tEplKernel Ret;
+	unsigned int uiIndex;
+	tEplTimerHighReskTimerInfo *pTimerInfo;
+	ktime_t RelTime;
+
+	Ret = kEplSuccessful;
+
+	// check pointer to handle
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
+
+	if (*pTimerHdl_p == 0) {	// no timer created yet
+
+		// search free timer info structure
+		pTimerInfo = &EplTimerHighReskInstance_l.m_aTimerInfo[0];
+		for (uiIndex = 0; uiIndex < TIMER_COUNT;
+		     uiIndex++, pTimerInfo++) {
+			if (pTimerInfo->m_EventArg.m_TimerHdl == 0) {	// free structure found
+				break;
+			}
+		}
+		if (uiIndex >= TIMER_COUNT) {	// no free structure found
+			Ret = kEplTimerNoTimerCreated;
+			goto Exit;
+		}
+
+		pTimerInfo->m_EventArg.m_TimerHdl = HDL_INIT(uiIndex);
+	} else {
+		uiIndex = HDL_TO_IDX(*pTimerHdl_p);
+		if (uiIndex >= TIMER_COUNT) {	// invalid handle
+			Ret = kEplTimerInvalidHandle;
+			goto Exit;
+		}
+
+		pTimerInfo = &EplTimerHighReskInstance_l.m_aTimerInfo[uiIndex];
+	}
+
+	/*
+	 * increment timer handle
+	 * (if timer expires right after this statement, the user
+	 * would detect an unknown timer handle and discard it)
+	 */
+	pTimerInfo->m_EventArg.m_TimerHdl =
+	    HDL_INC(pTimerInfo->m_EventArg.m_TimerHdl);
+	*pTimerHdl_p = pTimerInfo->m_EventArg.m_TimerHdl;
+
+	// reject too small time values
+	if ((fContinuously_p && (ullTimeNs_p < TIMER_MIN_VAL_CYCLE))
+	    || (!fContinuously_p && (ullTimeNs_p < TIMER_MIN_VAL_SINGLE))) {
+		Ret = kEplTimerNoTimerCreated;
+		goto Exit;
+	}
+
+	pTimerInfo->m_EventArg.m_ulArg = ulArgument_p;
+	pTimerInfo->m_pfnCallback = pfnCallback_p;
+	pTimerInfo->m_fContinuously = fContinuously_p;
+	pTimerInfo->m_ullPeriod = ullTimeNs_p;
+
+	/*
+	 * HRTIMER_MODE_REL does not influence general handling of this timer.
+	 * It only sets relative mode for this start operation.
+	 * -> Expire time is calculated by: Now + RelTime
+	 * hrtimer_start also skips pending timer events.
+	 * The state HRTIMER_STATE_CALLBACK is ignored.
+	 * We have to cope with that in our callback function.
+	 */
+	RelTime = ktime_add_ns(ktime_set(0, 0), ullTimeNs_p);
+	hrtimer_start(&pTimerInfo->m_Timer, RelTime, HRTIMER_MODE_REL);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimerHighReskDeleteTimer()
@@ -418,64 +403,56 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-tEplKernel PUBLIC EplTimerHighReskDeleteTimer(tEplTimerHdl* pTimerHdl_p)
+tEplKernel PUBLIC EplTimerHighReskDeleteTimer(tEplTimerHdl * pTimerHdl_p)
 {
-tEplKernel                  Ret = kEplSuccessful;
-unsigned int                uiIndex;
-tEplTimerHighReskTimerInfo* pTimerInfo;
-
-    // check pointer to handle
-    if(pTimerHdl_p == NULL)
-    {
-        Ret = kEplTimerInvalidHandle;
-        goto Exit;
-    }
-
-    if (*pTimerHdl_p == 0)
-    {   // no timer created yet
-        goto Exit;
-    }
-    else
-    {
-        uiIndex = HDL_TO_IDX(*pTimerHdl_p);
-        if (uiIndex >= TIMER_COUNT)
-        {   // invalid handle
-            Ret = kEplTimerInvalidHandle;
-            goto Exit;
-        }
-        pTimerInfo = &EplTimerHighReskInstance_l.m_aTimerInfo[uiIndex];
-        if (pTimerInfo->m_EventArg.m_TimerHdl != *pTimerHdl_p)
-        {   // invalid handle
-            goto Exit;
-        }
-    }
-
-    *pTimerHdl_p = 0;
-    pTimerInfo->m_EventArg.m_TimerHdl = 0;
-    pTimerInfo->m_pfnCallback = NULL;
-
-    /*
-     * Three return cases of hrtimer_try_to_cancel have to be tracked:
-     *  1 - timer has been removed
-     *  0 - timer was not active
-     *      We need not do anything. hrtimer timers just consist of
-     *      a hrtimer struct, which we might enqueue in the hrtimers
-     *      event list by calling hrtimer_start().
-     *      If a timer is not enqueued, it is not present in hrtimers.
-     * -1 - callback function is running
-     *      In this case we have to ensure that the timer is not
-     *      continuously restarted. This has been done by clearing
-     *      its handle.
-     */
-    hrtimer_try_to_cancel(&pTimerInfo->m_Timer);
+	tEplKernel Ret = kEplSuccessful;
+	unsigned int uiIndex;
+	tEplTimerHighReskTimerInfo *pTimerInfo;
+
+	// check pointer to handle
+	if (pTimerHdl_p == NULL) {
+		Ret = kEplTimerInvalidHandle;
+		goto Exit;
+	}
+
+	if (*pTimerHdl_p == 0) {	// no timer created yet
+		goto Exit;
+	} else {
+		uiIndex = HDL_TO_IDX(*pTimerHdl_p);
+		if (uiIndex >= TIMER_COUNT) {	// invalid handle
+			Ret = kEplTimerInvalidHandle;
+			goto Exit;
+		}
+		pTimerInfo = &EplTimerHighReskInstance_l.m_aTimerInfo[uiIndex];
+		if (pTimerInfo->m_EventArg.m_TimerHdl != *pTimerHdl_p) {	// invalid handle
+			goto Exit;
+		}
+	}
+
+	*pTimerHdl_p = 0;
+	pTimerInfo->m_EventArg.m_TimerHdl = 0;
+	pTimerInfo->m_pfnCallback = NULL;
+
+	/*
+	 * Three return cases of hrtimer_try_to_cancel have to be tracked:
+	 *  1 - timer has been removed
+	 *  0 - timer was not active
+	 *      We need not do anything. hrtimer timers just consist of
+	 *      a hrtimer struct, which we might enqueue in the hrtimers
+	 *      event list by calling hrtimer_start().
+	 *      If a timer is not enqueued, it is not present in hrtimers.
+	 * -1 - callback function is running
+	 *      In this case we have to ensure that the timer is not
+	 *      continuously restarted. This has been done by clearing
+	 *      its handle.
+	 */
+	hrtimer_try_to_cancel(&pTimerInfo->m_Timer);
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 
 }
 
-
-
 //---------------------------------------------------------------------------
 //
 // Function:    EplTimerHighReskCallback()
@@ -490,66 +467,63 @@ Exit:
 //
 //---------------------------------------------------------------------------
 
-enum hrtimer_restart EplTimerHighReskCallback (struct hrtimer* pTimer_p)
+enum hrtimer_restart EplTimerHighReskCallback(struct hrtimer *pTimer_p)
 {
-unsigned int                 uiIndex;
-tEplTimerHighReskTimerInfo*  pTimerInfo;
-tEplTimerHdl                 OrgTimerHdl;
-enum hrtimer_restart         Ret;
-
-    BENCHMARK_MOD_24_SET(4);
-
-    Ret        = HRTIMER_NORESTART;
-    pTimerInfo = container_of(pTimer_p, tEplTimerHighReskTimerInfo, m_Timer);
-    uiIndex    = HDL_TO_IDX(pTimerInfo->m_EventArg.m_TimerHdl);
-    if (uiIndex >= TIMER_COUNT)
-    {   // invalid handle
-        goto Exit;
-    }
-
-    /*
-     * We store the timer handle before calling the callback function
-     * as the timer can be modified inside it.
-     */
-    OrgTimerHdl = pTimerInfo->m_EventArg.m_TimerHdl;
-
-    if (pTimerInfo->m_pfnCallback != NULL)
-    {
-        pTimerInfo->m_pfnCallback(&pTimerInfo->m_EventArg);
-    }
-
-    if (pTimerInfo->m_fContinuously)
-    {
-    ktime_t        Interval;
+	unsigned int uiIndex;
+	tEplTimerHighReskTimerInfo *pTimerInfo;
+	tEplTimerHdl OrgTimerHdl;
+	enum hrtimer_restart Ret;
+
+	BENCHMARK_MOD_24_SET(4);
+
+	Ret = HRTIMER_NORESTART;
+	pTimerInfo =
+	    container_of(pTimer_p, tEplTimerHighReskTimerInfo, m_Timer);
+	uiIndex = HDL_TO_IDX(pTimerInfo->m_EventArg.m_TimerHdl);
+	if (uiIndex >= TIMER_COUNT) {	// invalid handle
+		goto Exit;
+	}
+
+	/*
+	 * We store the timer handle before calling the callback function
+	 * as the timer can be modified inside it.
+	 */
+	OrgTimerHdl = pTimerInfo->m_EventArg.m_TimerHdl;
+
+	if (pTimerInfo->m_pfnCallback != NULL) {
+		pTimerInfo->m_pfnCallback(&pTimerInfo->m_EventArg);
+	}
+
+	if (pTimerInfo->m_fContinuously) {
+		ktime_t Interval;
 #ifdef PROVE_OVERRUN
-    ktime_t        Now;
-    unsigned long  Overruns;
+		ktime_t Now;
+		unsigned long Overruns;
 #endif
 
-        if (OrgTimerHdl != pTimerInfo->m_EventArg.m_TimerHdl)
-        {
-            /* modified timer has already been restarted */
-            goto Exit;
-        }
-
+		if (OrgTimerHdl != pTimerInfo->m_EventArg.m_TimerHdl) {
+			/* modified timer has already been restarted */
+			goto Exit;
+		}
 #ifdef PROVE_OVERRUN
-        Now      = ktime_get();
-        Interval = ktime_add_ns(ktime_set(0,0), pTimerInfo->m_ullPeriod);
-        Overruns = hrtimer_forward(pTimer_p, Now, Interval);
-        if (Overruns > 1)
-        {
-            printk("EplTimerHighResk: Continuous timer (handle 0x%lX) had to skip %lu interval(s)!\n", pTimerInfo->m_EventArg.m_TimerHdl, Overruns-1);
-        }
+		Now = ktime_get();
+		Interval =
+		    ktime_add_ns(ktime_set(0, 0), pTimerInfo->m_ullPeriod);
+		Overruns = hrtimer_forward(pTimer_p, Now, Interval);
+		if (Overruns > 1) {
+			printk
+			    ("EplTimerHighResk: Continuous timer (handle 0x%lX) had to skip %lu interval(s)!\n",
+			     pTimerInfo->m_EventArg.m_TimerHdl, Overruns - 1);
+		}
 #else
-        pTimer_p->expires = ktime_add_ns(pTimer_p->expires,
-                                         pTimerInfo->m_ullPeriod);
+		pTimer_p->expires = ktime_add_ns(pTimer_p->expires,
+						 pTimerInfo->m_ullPeriod);
 #endif
 
-        Ret = HRTIMER_RESTART;
-    }
+		Ret = HRTIMER_RESTART;
+	}
 
-Exit:
-    BENCHMARK_MOD_24_RESET(4);
-    return Ret;
+      Exit:
+	BENCHMARK_MOD_24_RESET(4);
+	return Ret;
 }
-
--- a/drivers/staging/epl/VirtualEthernetLinux.c
+++ b/drivers/staging/epl/VirtualEthernetLinux.c
@@ -59,7 +59,6 @@
 
                 Build Environment:
 
-
   -------------------------------------------------------------------------
 
   Revision History:
@@ -75,7 +74,6 @@
 
 ****************************************************************************/
 
-
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/netdevice.h>
@@ -93,13 +91,12 @@
 #include <linux/udp.h>
 #include <linux/mm.h>
 #include <linux/types.h>
-#include <linux/skbuff.h>  /* for struct sk_buff */
+#include <linux/skbuff.h>	/* for struct sk_buff */
 
 #include "kernel/VirtualEthernet.h"
 #include "kernel/EplDllkCal.h"
 #include "kernel/EplDllk.h"
 
-
 #if(((EPL_MODULE_INTEGRATION) & (EPL_MODULE_VETH)) != 0)
 
 /***************************************************************************/
@@ -110,28 +107,24 @@
 /*                                                                         */
 /***************************************************************************/
 
-
 //---------------------------------------------------------------------------
 // const defines
 //---------------------------------------------------------------------------
 
 #ifndef EPL_VETH_TX_TIMEOUT
 //#define EPL_VETH_TX_TIMEOUT (2*HZ)
-#define EPL_VETH_TX_TIMEOUT 0       // d.k.: we use no timeout
+#define EPL_VETH_TX_TIMEOUT 0	// d.k.: we use no timeout
 #endif
 
-
 //---------------------------------------------------------------------------
 // local types
 //---------------------------------------------------------------------------
 
-
-
 //---------------------------------------------------------------------------
 // modul globale vars
 //---------------------------------------------------------------------------
 
-static struct net_device * pVEthNetDevice_g = NULL;
+static struct net_device *pVEthNetDevice_g = NULL;
 
 //---------------------------------------------------------------------------
 // local function prototypes
@@ -140,11 +133,10 @@ static struct net_device * pVEthNetDevic
 static int VEthOpen(struct net_device *pNetDevice_p);
 static int VEthClose(struct net_device *pNetDevice_p);
 static int VEthXmit(struct sk_buff *pSkb_p, struct net_device *pNetDevice_p);
-static struct net_device_stats* VEthGetStats(struct net_device *pNetDevice_p);
+static struct net_device_stats *VEthGetStats(struct net_device *pNetDevice_p);
 static void VEthTimeout(struct net_device *pNetDevice_p);
 static tEplKernel VEthRecvFrame(tEplFrameInfo * pFrameInfo_p);
 
-
 //=========================================================================//
 //                                                                         //
 //          P U B L I C   F U N C T I O N S                                //
@@ -171,188 +163,182 @@ static tEplKernel VEthRecvFrame(tEplFram
 
 static int VEthOpen(struct net_device *pNetDevice_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    //open the device
+	//open the device
 //    struct net_device_stats* pStats = (struct net_device_stats*)pNetDevice_p->priv;
 
-    //start the interface queue for the network subsystem
-    netif_start_queue(pNetDevice_p);
+	//start the interface queue for the network subsystem
+	netif_start_queue(pNetDevice_p);
 
-    // register callback function in DLL
-    Ret = EplDllkRegAsyncHandler(VEthRecvFrame);
+	// register callback function in DLL
+	Ret = EplDllkRegAsyncHandler(VEthRecvFrame);
 
-    EPL_DBGLVL_VETH_TRACE1("VEthOpen: EplDllkRegAsyncHandler returned 0x%02X\n", Ret);
+	EPL_DBGLVL_VETH_TRACE1
+	    ("VEthOpen: EplDllkRegAsyncHandler returned 0x%02X\n", Ret);
 
-    return 0;
+	return 0;
 }
 
 static int VEthClose(struct net_device *pNetDevice_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    EPL_DBGLVL_VETH_TRACE0("VEthClose\n");
+	EPL_DBGLVL_VETH_TRACE0("VEthClose\n");
 
-    Ret = EplDllkDeregAsyncHandler(VEthRecvFrame);
+	Ret = EplDllkDeregAsyncHandler(VEthRecvFrame);
 
-    //stop the interface queue for the network subsystem
-    netif_stop_queue(pNetDevice_p);
-    return 0;
+	//stop the interface queue for the network subsystem
+	netif_stop_queue(pNetDevice_p);
+	return 0;
 }
 
-
 static int VEthXmit(struct sk_buff *pSkb_p, struct net_device *pNetDevice_p)
 {
-tEplKernel      Ret = kEplSuccessful;
-tEplFrameInfo   FrameInfo;
-
-    //transmit function
-    struct net_device_stats* pStats = (struct net_device_stats*)pNetDevice_p->priv;
+	tEplKernel Ret = kEplSuccessful;
+	tEplFrameInfo FrameInfo;
 
-    //save timestemp
-    pNetDevice_p->trans_start = jiffies;
+	//transmit function
+	struct net_device_stats *pStats =
+	    (struct net_device_stats *)pNetDevice_p->priv;
+
+	//save timestemp
+	pNetDevice_p->trans_start = jiffies;
+
+	FrameInfo.m_pFrame = (tEplFrame *) pSkb_p->data;
+	FrameInfo.m_uiFrameSize = pSkb_p->len;
+
+	//call send fkt on DLL
+	Ret = EplDllkCalAsyncSend(&FrameInfo, kEplDllAsyncReqPrioGeneric);
+	if (Ret != kEplSuccessful) {
+		EPL_DBGLVL_VETH_TRACE1
+		    ("VEthXmit: EplDllkCalAsyncSend returned 0x%02X\n", Ret);
+		netif_stop_queue(pNetDevice_p);
+		goto Exit;
+	} else {
+		EPL_DBGLVL_VETH_TRACE0("VEthXmit: frame passed to DLL\n");
+		dev_kfree_skb(pSkb_p);
+
+		//set stats for the device
+		pStats->tx_packets++;
+		pStats->tx_bytes += FrameInfo.m_uiFrameSize;
+	}
 
-    FrameInfo.m_pFrame = (tEplFrame *)pSkb_p->data;
-    FrameInfo.m_uiFrameSize = pSkb_p->len;
-
-    //call send fkt on DLL
-    Ret = EplDllkCalAsyncSend(&FrameInfo, kEplDllAsyncReqPrioGeneric);
-    if (Ret != kEplSuccessful)
-    {
-        EPL_DBGLVL_VETH_TRACE1("VEthXmit: EplDllkCalAsyncSend returned 0x%02X\n", Ret);
-        netif_stop_queue(pNetDevice_p);
-        goto Exit;
-    }
-    else
-    {
-        EPL_DBGLVL_VETH_TRACE0("VEthXmit: frame passed to DLL\n");
-        dev_kfree_skb(pSkb_p);
-
-        //set stats for the device
-        pStats->tx_packets++;
-        pStats->tx_bytes += FrameInfo.m_uiFrameSize;
-    }
-
-Exit:
-    return 0;
+      Exit:
+	return 0;
 
 }
 
-
-static struct net_device_stats* VEthGetStats(struct net_device *pNetDevice_p)
+static struct net_device_stats *VEthGetStats(struct net_device *pNetDevice_p)
 {
-    EPL_DBGLVL_VETH_TRACE0("VEthGetStats\n");
+	EPL_DBGLVL_VETH_TRACE0("VEthGetStats\n");
 
-    return (struct net_device_stats *)pNetDevice_p->priv;
+	return (struct net_device_stats *)pNetDevice_p->priv;
 }
 
-
-
 static void VEthTimeout(struct net_device *pNetDevice_p)
 {
-    EPL_DBGLVL_VETH_TRACE0("VEthTimeout(\n");
+	EPL_DBGLVL_VETH_TRACE0("VEthTimeout(\n");
 
-    // $$$ d.k.: move to extra function, which is called by DLL when new space is available in TxFifo
-    if (netif_queue_stopped (pNetDevice_p))
-    {
-        netif_wake_queue (pNetDevice_p);
-    }
+	// $$$ d.k.: move to extra function, which is called by DLL when new space is available in TxFifo
+	if (netif_queue_stopped(pNetDevice_p)) {
+		netif_wake_queue(pNetDevice_p);
+	}
 }
 
-
-
 static tEplKernel VEthRecvFrame(tEplFrameInfo * pFrameInfo_p)
 {
-tEplKernel  Ret = kEplSuccessful;
-    struct net_device* pNetDevice = pVEthNetDevice_g;
-    struct net_device_stats* pStats = (struct net_device_stats*)pNetDevice->priv;
-    struct sk_buff *pSkb;
-
-    EPL_DBGLVL_VETH_TRACE1("VEthRecvFrame: FrameSize=%u\n", pFrameInfo_p->m_uiFrameSize);
-
-    pSkb = dev_alloc_skb(pFrameInfo_p->m_uiFrameSize + 2);
-    if (pSkb == NULL)
-    {
-        pStats->rx_dropped++;
-        goto Exit;
-    }
-    pSkb->dev = pNetDevice;
-
-    skb_reserve(pSkb, 2);
-
-    memcpy((void *)skb_put(pSkb, pFrameInfo_p->m_uiFrameSize), pFrameInfo_p->m_pFrame, pFrameInfo_p->m_uiFrameSize);
+	tEplKernel Ret = kEplSuccessful;
+	struct net_device *pNetDevice = pVEthNetDevice_g;
+	struct net_device_stats *pStats =
+	    (struct net_device_stats *)pNetDevice->priv;
+	struct sk_buff *pSkb;
+
+	EPL_DBGLVL_VETH_TRACE1("VEthRecvFrame: FrameSize=%u\n",
+			       pFrameInfo_p->m_uiFrameSize);
+
+	pSkb = dev_alloc_skb(pFrameInfo_p->m_uiFrameSize + 2);
+	if (pSkb == NULL) {
+		pStats->rx_dropped++;
+		goto Exit;
+	}
+	pSkb->dev = pNetDevice;
+
+	skb_reserve(pSkb, 2);
+
+	memcpy((void *)skb_put(pSkb, pFrameInfo_p->m_uiFrameSize),
+	       pFrameInfo_p->m_pFrame, pFrameInfo_p->m_uiFrameSize);
+
+	pSkb->protocol = eth_type_trans(pSkb, pNetDevice);
+	pSkb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	// call netif_rx with skb
+	netif_rx(pSkb);
+
+	EPL_DBGLVL_VETH_TRACE1("VEthRecvFrame: SrcMAC=0x%llx\n",
+			       AmiGetQword48FromBe(pFrameInfo_p->m_pFrame->
+						   m_be_abSrcMac));
+
+	// update receive statistics
+	pStats->rx_packets++;
+	pStats->rx_bytes += pFrameInfo_p->m_uiFrameSize;
 
-    pSkb->protocol = eth_type_trans(pSkb, pNetDevice);
-    pSkb->ip_summed = CHECKSUM_UNNECESSARY;
-
-    // call netif_rx with skb
-    netif_rx(pSkb);
-
-    EPL_DBGLVL_VETH_TRACE1("VEthRecvFrame: SrcMAC=0x%llx\n", AmiGetQword48FromBe(pFrameInfo_p->m_pFrame->m_be_abSrcMac));
-
-    // update receive statistics
-    pStats->rx_packets++;
-    pStats->rx_bytes += pFrameInfo_p->m_uiFrameSize;
-
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 tEplKernel PUBLIC VEthAddInstance(tEplDllkInitParam * pInitParam_p)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    // allocate net device structure with priv pointing to stats structure
-    pVEthNetDevice_g = alloc_netdev(sizeof (struct net_device_stats), EPL_VETH_NAME, ether_setup);
+	// allocate net device structure with priv pointing to stats structure
+	pVEthNetDevice_g =
+	    alloc_netdev(sizeof(struct net_device_stats), EPL_VETH_NAME,
+			 ether_setup);
 //    pVEthNetDevice_g = alloc_etherdev(sizeof (struct net_device_stats));
 
-    if (pVEthNetDevice_g == NULL)
-    {
-        Ret = kEplNoResource;
-        goto Exit;
-    }
-
-    pVEthNetDevice_g->open               = VEthOpen;
-    pVEthNetDevice_g->stop               = VEthClose;
-    pVEthNetDevice_g->get_stats          = VEthGetStats;
-    pVEthNetDevice_g->hard_start_xmit    = VEthXmit;
-    pVEthNetDevice_g->tx_timeout         = VEthTimeout;
-    pVEthNetDevice_g->watchdog_timeo     = EPL_VETH_TX_TIMEOUT;
-    pVEthNetDevice_g->destructor         = free_netdev;
-
-    // copy own MAC address to net device structure
-    memcpy(pVEthNetDevice_g->dev_addr, pInitParam_p->m_be_abSrcMac, 6);
-
-    //register VEth to the network subsystem
-    if (register_netdev(pVEthNetDevice_g))
-    {
-        EPL_DBGLVL_VETH_TRACE0("VEthAddInstance: Could not register VEth...\n");
-    }
-    else
-    {
-        EPL_DBGLVL_VETH_TRACE0("VEthAddInstance: Register VEth successfull...\n");
-    }
+	if (pVEthNetDevice_g == NULL) {
+		Ret = kEplNoResource;
+		goto Exit;
+	}
+
+	pVEthNetDevice_g->open = VEthOpen;
+	pVEthNetDevice_g->stop = VEthClose;
+	pVEthNetDevice_g->get_stats = VEthGetStats;
+	pVEthNetDevice_g->hard_start_xmit = VEthXmit;
+	pVEthNetDevice_g->tx_timeout = VEthTimeout;
+	pVEthNetDevice_g->watchdog_timeo = EPL_VETH_TX_TIMEOUT;
+	pVEthNetDevice_g->destructor = free_netdev;
+
+	// copy own MAC address to net device structure
+	memcpy(pVEthNetDevice_g->dev_addr, pInitParam_p->m_be_abSrcMac, 6);
+
+	//register VEth to the network subsystem
+	if (register_netdev(pVEthNetDevice_g)) {
+		EPL_DBGLVL_VETH_TRACE0
+		    ("VEthAddInstance: Could not register VEth...\n");
+	} else {
+		EPL_DBGLVL_VETH_TRACE0
+		    ("VEthAddInstance: Register VEth successfull...\n");
+	}
 
-Exit:
-    return Ret;
+      Exit:
+	return Ret;
 }
 
-
 tEplKernel PUBLIC VEthDelInstance(void)
 {
-tEplKernel  Ret = kEplSuccessful;
+	tEplKernel Ret = kEplSuccessful;
 
-    if (pVEthNetDevice_g != NULL)
-    {
-        //unregister VEth from the network subsystem
-        unregister_netdev(pVEthNetDevice_g);
-        // destructor was set to free_netdev,
-        // so we do not need to call free_netdev here
-        pVEthNetDevice_g = NULL;
-    }
+	if (pVEthNetDevice_g != NULL) {
+		//unregister VEth from the network subsystem
+		unregister_netdev(pVEthNetDevice_g);
+		// destructor was set to free_netdev,
+		// so we do not need to call free_netdev here
+		pVEthNetDevice_g = NULL;
+	}
 
-    return Ret;
+	return Ret;
 }
 
 #endif // (((EPL_MODULE_INTEGRATION) & (EPL_MODULE_VETH)) != 0)
