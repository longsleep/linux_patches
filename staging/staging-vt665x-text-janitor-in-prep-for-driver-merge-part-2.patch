From lieb@canonical.com  Mon Aug 17 12:41:46 2009
From: Jim Lieb <lieb@canonical.com>
Date: Wed, 12 Aug 2009 14:54:03 -0700
Subject: Staging: vt665x: Text janitor in prep for driver merge, part 2
To: Greg KH <greg@kroah.com>, Forest Bond <forest@alittletooquiet.net>, Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Cc: jim.lieb@canonical.com, Jim Lieb <lieb@canonical.com>
Message-ID: <1250114056-13843-2-git-send-email-lieb@canonical.com>


Text only changes to remove textual differences between the vt6655
and vt6656 trees in prep for driver merge.

Signed-off-by: Jim Lieb <lieb@canonical.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/vt6655/80211hdr.h   |    5 +-
 drivers/staging/vt6655/80211mgr.c   |    8 ---
 drivers/staging/vt6655/80211mgr.h   |    6 +-
 drivers/staging/vt6655/baseband.c   |   10 +++-
 drivers/staging/vt6655/baseband.h   |   19 +++-----
 drivers/staging/vt6655/bssdb.c      |   48 +++++++++++----------
 drivers/staging/vt6655/bssdb.h      |   10 +++-
 drivers/staging/vt6655/desc.h       |    4 +
 drivers/staging/vt6655/device.h     |   28 +++++-------
 drivers/staging/vt6655/device_cfg.h |    5 +-
 drivers/staging/vt6655/dpc.c        |   21 ++++++---
 drivers/staging/vt6655/dpc.h        |    2 
 drivers/staging/vt6655/hostap.c     |    7 ++-
 drivers/staging/vt6655/iocmd.h      |   14 +++---
 drivers/staging/vt6655/ioctl.c      |   10 +---
 drivers/staging/vt6655/iowpa.h      |    3 -
 drivers/staging/vt6655/iwctl.c      |   79 ++++++++++++++++--------------------
 drivers/staging/vt6655/iwctl.h      |    1 
 drivers/staging/vt6655/kcompat.h    |    5 --
 drivers/staging/vt6655/key.c        |    1 
 drivers/staging/vt6655/mac.c        |    7 +++
 drivers/staging/vt6655/mac.h        |    6 --
 drivers/staging/vt6655/power.c      |    1 
 drivers/staging/vt6655/power.h      |    1 
 drivers/staging/vt6655/rc4.c        |    5 +-
 drivers/staging/vt6655/rf.c         |    1 
 drivers/staging/vt6655/rxtx.h       |    2 
 drivers/staging/vt6655/srom.h       |    8 ---
 drivers/staging/vt6655/tpci.h       |    2 
 drivers/staging/vt6655/ttype.h      |    5 +-
 drivers/staging/vt6655/vntwifi.h    |    3 -
 drivers/staging/vt6655/wcmd.c       |   12 ++++-
 drivers/staging/vt6655/wcmd.h       |    8 +--
 drivers/staging/vt6655/wmgr.c       |   55 +++++++++----------------
 drivers/staging/vt6655/wpa2.h       |    5 --
 drivers/staging/vt6655/wpactl.c     |   24 +++-------
 drivers/staging/vt6655/wpactl.h     |    1 
 37 files changed, 216 insertions(+), 216 deletions(-)

--- a/drivers/staging/vt6655/80211hdr.h
+++ b/drivers/staging/vt6655/80211hdr.h
@@ -16,10 +16,11 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ *
  * File: 80211hdr.h
  *
- * Purpose: Defines the macros, types, and functions for dealing
- *          with 802.11 MAC headers.
+ * Purpose: 802.11 MAC headers related pre-defines and macros.
+ *
  *
  * Author: Lyndon Chen
  *
--- a/drivers/staging/vt6655/80211mgr.c
+++ b/drivers/staging/vt6655/80211mgr.c
@@ -16,7 +16,6 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- *
  * File: 80211mgr.c
  *
  * Purpose: Handles the 802.11 management support functions
@@ -747,7 +746,6 @@ vMgrDecodeProbeResponse(
     )
 {
     PWLAN_IE    pItem;
-//    BYTE        byCheckEID = 0;
 
 
     pFrame->pHdr = (PUWLAN_80211HDR)pFrame->pBuf;
@@ -765,12 +763,6 @@ vMgrDecodeProbeResponse(
                        + WLAN_PROBERESP_OFF_SSID);
 
     while( ((PBYTE)pItem) < (pFrame->pBuf + pFrame->len) ) {
-		/*
-        if (pItem->byElementID < byCheckEID)
-            break;
-        else
-            byCheckEID = pItem->byElementID;
-*/
         switch (pItem->byElementID) {
             case WLAN_EID_SSID:
                 if (pFrame->pSSID == NULL)
--- a/drivers/staging/vt6655/80211mgr.h
+++ b/drivers/staging/vt6655/80211mgr.h
@@ -16,10 +16,11 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ *
  * File: 80211mgr.h
  *
- * Purpose: Defines the macros, types, and functions for dealing
- *          with 802.11 management frames.
+ * Purpose: 802.11 managment frames pre-defines.
+ *
  *
  * Author: Lyndon Chen
  *
@@ -273,7 +274,6 @@ typedef struct _WLAN_IE_FH_PARMS {
     BYTE    byHopIndex;
 } WLAN_IE_FH_PARMS,  *PWLAN_IE_FH_PARMS;
 
-
 // DS Parameter Set
 #pragma pack(1)
 typedef struct tagWLAN_IE_DS_PARMS {
--- a/drivers/staging/vt6655/baseband.c
+++ b/drivers/staging/vt6655/baseband.c
@@ -16,6 +16,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ *
  * File: baseband.c
  *
  * Purpose: Implement functions to access baseband
@@ -44,8 +45,11 @@
  *                                Add the comments.
  *      09-01-2003 Bryan YC Fan:  RF & BB tables updated.
  *                                Modified BBvLoopbackOn & BBvLoopbackOff().
+ *
+ *
  */
 
+
 #if !defined(__TMACRO_H__)
 #include "tmacro.h"
 #endif
@@ -80,6 +84,7 @@ static int          msglevel            
 /*---------------------  Static Classes  ----------------------------*/
 
 /*---------------------  Static Variables  --------------------------*/
+
 /*---------------------  Static Functions  --------------------------*/
 
 /*---------------------  Export Variables  --------------------------*/
@@ -1806,6 +1811,7 @@ BBuGetFrameTime (
 
 
     if (uRateIdx > RATE_54M) {
+	    ASSERT(0);
         return 0;
     }
 
@@ -2897,8 +2903,6 @@ TimerSQ3CallBack (
     PSDevice        pDevice = (PSDevice)hDeviceContext;
 
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TimerSQ3CallBack...");
-
-
     spin_lock_irq(&pDevice->lock);
 
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"3.[%08x][%08x], %d\n",(int)pDevice->ulRatio_State0, (int)pDevice->ulRatio_State1, (int)pDevice->uDiversityCnt);
@@ -2915,8 +2919,8 @@ TimerSQ3CallBack (
     add_timer(&pDevice->TimerSQ3Tmax3);
     add_timer(&pDevice->TimerSQ3Tmax2);
 
-    spin_unlock_irq(&pDevice->lock);
 
+    spin_unlock_irq(&pDevice->lock);
     return;
 }
 
--- a/drivers/staging/vt6655/baseband.h
+++ b/drivers/staging/vt6655/baseband.h
@@ -16,6 +16,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ *
  * File: baseband.h
  *
  * Purpose: Implement functions to access baseband
@@ -26,11 +27,9 @@
  *
  */
 
-
 #ifndef __BASEBAND_H__
 #define __BASEBAND_H__
 
-
 #if !defined(__TTYPE_H__)
 #include "ttype.h"
 #endif
@@ -106,12 +105,11 @@
 #define TOP_RATE_2M         0x00200000
 #define TOP_RATE_1M         0x00100000
 
+
 /*---------------------  Export Types  ------------------------------*/
 
 /*---------------------  Export Macros ------------------------------*/
 
-
-
 #define BBvClearFOE(dwIoBase)                               \
 {                                                           \
     BBbWriteEmbeded(dwIoBase, 0xB1, 0);                     \
@@ -173,13 +171,15 @@ VOID BBvSetDeepSleep(DWORD_PTR dwIoBase,
 VOID BBvExitDeepSleep(DWORD_PTR dwIoBase, BYTE byLocalID);
 
 // timer for antenna diversity
+
 VOID
-TimerSQ3CallBack(
-    IN  HANDLE hDeviceContext
+TimerSQ3CallBack (
+    IN  HANDLE      hDeviceContext
     );
+
 VOID
 TimerState1CallBack(
-    IN  HANDLE hDeviceContext
+    IN  HANDLE      hDeviceContext
     );
 
 void BBvAntennaDiversity(PSDevice pDevice, BYTE byRxRate, BYTE bySQ3);
@@ -188,11 +188,8 @@ BBvClearAntDivSQ3Value (PSDevice pDevice
 
 
 #ifdef __cplusplus
-}                /* End of extern "C" { */
+}                                	/* End of extern "C" { */
 #endif /* __cplusplus */
 
 
 #endif // __BASEBAND_H__
-
-
-
--- a/drivers/staging/vt6655/bssdb.c
+++ b/drivers/staging/vt6655/bssdb.c
@@ -170,7 +170,7 @@ BSSpSearchBSSList(
     IN HANDLE hDeviceContext,
     IN PBYTE pbyDesireBSSID,
     IN PBYTE pbyDesireSSID,
-    IN CARD_PHY_TYPE ePhyType
+    IN CARD_PHY_TYPE  ePhyType
     )
 {
     PSDevice        pDevice = (PSDevice)hDeviceContext;
@@ -187,7 +187,7 @@ BYTE                 ZeroBSSID[WLAN_BSSI
                             *pbyDesireBSSID,*(pbyDesireBSSID+1),*(pbyDesireBSSID+2),
                             *(pbyDesireBSSID+3),*(pbyDesireBSSID+4),*(pbyDesireBSSID+5));
         if ((!IS_BROADCAST_ADDRESS(pbyDesireBSSID)) &&
-	     (memcmp(pbyDesireBSSID, ZeroBSSID, 6)!= 0)) {
+	     (memcmp(pbyDesireBSSID, ZeroBSSID, 6)!= 0)){
             pbyBSSID = pbyDesireBSSID;
         }
     }
@@ -246,11 +246,11 @@ if(pDevice->bLinkPass==FALSE) pCurrBSS->
                         (pSSID->len != ((PWLAN_IE_SSID)pCurrBSS->abySSID)->len)) {
                         // SSID not match skip this BSS
                         continue;
-                    }
+                      }
                 }
                 if (((pMgmt->eConfigMode == WMAC_CONFIG_IBSS_STA) && WLAN_GET_CAP_INFO_ESS(pCurrBSS->wCapInfo)) ||
                     ((pMgmt->eConfigMode == WMAC_CONFIG_ESS_STA) && WLAN_GET_CAP_INFO_IBSS(pCurrBSS->wCapInfo))
-                    ) {
+                    ){
                     // Type not match skip this BSS
                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"BSS type mismatch.... Config[%d] BSS[0x%04x]\n", pMgmt->eConfigMode, pCurrBSS->wCapInfo);
                     continue;
@@ -399,6 +399,7 @@ BSSpAddrIsInBSSList(
 
 
 
+
 /*+
  *
  * Routine Description:
@@ -450,7 +451,7 @@ BSSbInsertToBSSList (
     }
 
     if (ii == MAX_BSS_NUM){
-        DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "Get free KnowBSS node failed.\n");
+        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Get free KnowBSS node failed.\n");
         return FALSE;
     }
     // save the BSS info
@@ -575,8 +576,6 @@ BSSbInsertToBSSList (
                             pIE_Country);
     }
 
-
-
     if ((bParsingQuiet == TRUE) && (pIE_Quiet != NULL)) {
         if ((((PWLAN_IE_QUIET)pIE_Quiet)->len == 8) &&
             (((PWLAN_IE_QUIET)pIE_Quiet)->byQuietCount != 0)) {
@@ -663,6 +662,7 @@ BSSbUpdateToBSSList (
     if (pBSSList == NULL)
         return FALSE;
 
+
     HIDWORD(pBSSList->qwBSSTimestamp) = cpu_to_le32(HIDWORD(qwTimestamp));
     LODWORD(pBSSList->qwBSSTimestamp) = cpu_to_le32(LODWORD(qwTimestamp));
     pBSSList->wBeaconInterval = cpu_to_le16(wBeaconInterval);
@@ -711,7 +711,7 @@ BSSbUpdateToBSSList (
         }
     }
 
-    WPA_ClearRSN(pBSSList);         //mike update
+   WPA_ClearRSN(pBSSList);         //mike update
 
     if (pRSNWPA != NULL) {
         UINT uLen = pRSNWPA->len + 2;
@@ -722,7 +722,7 @@ BSSbUpdateToBSSList (
         }
     }
 
-  WPA2_ClearRSN(pBSSList);  //mike update
+   WPA2_ClearRSN(pBSSList);  //mike update
 
     if (pRSN != NULL) {
         UINT uLen = pRSN->len + 2;
@@ -1067,7 +1067,7 @@ BSSvSecondCallBack(
     UINT            uSleepySTACnt = 0;
     UINT            uNonShortSlotSTACnt = 0;
     UINT            uLongPreambleSTACnt = 0;
-viawget_wpa_header* wpahdr;
+    viawget_wpa_header* wpahdr;  //DavidWang
 
     spin_lock_irq(&pDevice->lock);
 
@@ -1145,7 +1145,7 @@ start:
                   	union iwreq_data  wrqu;
                   	memset(&wrqu, 0, sizeof (wrqu));
                           wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-                  	printk("wireless_send_event--->SIOCGIWAP(disassociated)\n");
+                  	PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated)\n");
                   	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
                        }
                     #endif
@@ -1161,14 +1161,13 @@ start:
     for (ii = 0; ii < (MAX_NODE_NUM + 1); ii++) {
 
         if (pMgmt->sNodeDBTable[ii].bActive) {
-
             // Increase in-activity counter
             pMgmt->sNodeDBTable[ii].uInActiveCount++;
 
             if (ii > 0) {
                 if (pMgmt->sNodeDBTable[ii].uInActiveCount > MAX_INACTIVE_COUNT) {
                     BSSvRemoveOneNode(pDevice, ii);
-                    DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO
+                    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
                         "Inactive timeout [%d] sec, STA index = [%d] remove\n", MAX_INACTIVE_COUNT, ii);
                     continue;
                 }
@@ -1200,7 +1199,6 @@ start:
             }
 
             // Rate fallback check
-
             if (!pDevice->bFixRate) {
 /*
                 if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (ii == 0))
@@ -1300,7 +1298,7 @@ start:
 
     pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
     pCurrSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;
-//printk("pCurrSSID=%s\n",pCurrSSID->abySSID);
+
     if ((pMgmt->eCurrMode == WMAC_MODE_STANDBY) ||
         (pMgmt->eCurrMode == WMAC_MODE_ESS_STA)) {
 
@@ -1309,17 +1307,18 @@ start:
             //if (pDevice->bUpdateBBVGA) {
             //  s_vCheckSensitivity((HANDLE) pDevice);
             //}
+
             if (pDevice->bUpdateBBVGA) {
                // s_vCheckSensitivity((HANDLE) pDevice);
                s_vCheckPreEDThreshold((HANDLE)pDevice);
             }
+
     	    if ((pMgmt->sNodeDBTable[0].uInActiveCount >= (LOST_BEACON_COUNT/2)) &&
     	        (pDevice->byBBVGACurrent != pDevice->abyBBVGA[0]) ) {
     	        pDevice->byBBVGANew = pDevice->abyBBVGA[0];
                 bScheduleCommand((HANDLE) pDevice, WLAN_CMD_CHANGE_BBSENSITIVITY, NULL);
     	    }
 
-
         	if (pMgmt->sNodeDBTable[0].uInActiveCount >= LOST_BEACON_COUNT) {
                 pMgmt->sNodeDBTable[0].bActive = FALSE;
                 pMgmt->eCurrMode = WMAC_MODE_STANDBY;
@@ -1348,29 +1347,29 @@ start:
 	union iwreq_data  wrqu;
 	memset(&wrqu, 0, sizeof (wrqu));
         wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	printk("wireless_send_event--->SIOCGIWAP(disassociated)\n");
+	PRINT_K("wireless_send_event--->SIOCGIWAP(disassociated)\n");
 	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
      }
   #endif
-			}
+	    }
         }
         else if (pItemSSID->len != 0) {
             if (pDevice->uAutoReConnectTime < 10) {
                 pDevice->uAutoReConnectTime++;
-	#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+	       #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
                 //network manager support need not do Roaming scan???
                 if(pDevice->bWPASuppWextEnabled ==TRUE)
 		 pDevice->uAutoReConnectTime = 0;
 	     #endif
-
             }
             else {
-		    //mike use old encryption status for wpa reauthen
+	   //mike use old encryption status for wpa reauthen
 	      if(pDevice->bWPADEVUp)
 	          pDevice->eEncryptionStatus = pDevice->eOldEncryptionStatus;
+
                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Roaming ...\n");
                 BSSvClearBSSList((HANDLE)pDevice, pDevice->bLinkPass);
-	pMgmt->eScanType = WMAC_SCAN_ACTIVE;
+ 	      pMgmt->eScanType = WMAC_SCAN_ACTIVE;
                 bScheduleCommand((HANDLE) pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);
                 bScheduleCommand((HANDLE) pDevice, WLAN_CMD_SSID, pMgmt->abyDesireSSID);
                 pDevice->uAutoReConnectTime = 0;
@@ -1386,13 +1385,14 @@ start:
             }
             else {
                 DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "Adhoc re-scaning ...\n");
-	pMgmt->eScanType = WMAC_SCAN_ACTIVE;
+	      pMgmt->eScanType = WMAC_SCAN_ACTIVE;
                 bScheduleCommand((HANDLE) pDevice, WLAN_CMD_BSSID_SCAN, NULL);
                 bScheduleCommand((HANDLE) pDevice, WLAN_CMD_SSID, NULL);
                 pDevice->uAutoReConnectTime = 0;
             };
         }
         if (pMgmt->eCurrState == WMAC_STATE_JOINTED) {
+
             if (pDevice->bUpdateBBVGA) {
                //s_vCheckSensitivity((HANDLE) pDevice);
                s_vCheckPreEDThreshold((HANDLE)pDevice);
@@ -1600,6 +1600,7 @@ BSSvUpdateNodeTxCounter(
 
     return;
 
+
 }
 
 
@@ -1784,3 +1785,4 @@ VOID s_vCheckPreEDThreshold(
     }
     return;
 }
+
--- a/drivers/staging/vt6655/bssdb.h
+++ b/drivers/staging/vt6655/bssdb.h
@@ -33,7 +33,9 @@
 //#if !defined(__DEVICE_H__)
 //#include "device.h"
 //#endif
+
 #include <linux/skbuff.h>
+
 #if !defined(__80211HDR_H__)
 #include "80211hdr.h"
 #endif
@@ -103,13 +105,13 @@ typedef enum _NDIS_802_11_NETWORK_TYPE
 typedef struct tagSERPObject {
     BOOL    bERPExist;
     BYTE    byERP;
-} ERPObject, DEF* PERPObject;
+}ERPObject, DEF* PERPObject;
 
 
 typedef struct tagSRSNCapObject {
     BOOL    bRSNCapExist;
     WORD    wRSNCap;
-} SRSNCapObject, DEF* PSRSNCapObject;
+}SRSNCapObject, DEF* PSRSNCapObject;
 
 // BSS info(AP)
 #pragma pack(1)
@@ -126,11 +128,12 @@ typedef struct tagKnownBSS {
     WORD            wCapInfo;
     BYTE            abySSID[WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1];
     BYTE            byRxRate;
+
 //    WORD            wATIMWindow;
     BYTE            byRSSIStatCnt;
     LONG            ldBmMAX;
     LONG            ldBmAverage[RSSI_STAT_COUNT];
-     LONG            ldBmAverRange;
+    LONG            ldBmAverRange;
     //For any BSSID selection improvment
     BOOL            bSelected;
 
@@ -345,6 +348,7 @@ BSSvSecondCallBack(
     IN HANDLE hDeviceContext
     );
 
+
 VOID
 BSSvUpdateNodeTxCounter(
     IN HANDLE hDeviceContext,
--- a/drivers/staging/vt6655/desc.h
+++ b/drivers/staging/vt6655/desc.h
@@ -43,6 +43,9 @@
 #endif
 
 
+
+
+
 /*---------------------  Export Definitions -------------------------*/
 
 #define B_OWNED_BY_CHIP     1           //
@@ -129,6 +132,7 @@
 #define CB_PROTOCOL_RESERVED_SECTION    16
 
 
+
 // if retrys excess 15 times , tx will abort, and
 // if tx fifo underflow, tx will fail
 // we should try to resend it
--- a/drivers/staging/vt6655/device_cfg.h
+++ b/drivers/staging/vt6655/device_cfg.h
@@ -1,5 +1,6 @@
 /*
- * Copyright (c) 1996, 2003 VIA Networking, Inc. All rights reserved.
+ * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
+ * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -15,7 +16,6 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- *
  * File: device_cfg.h
  *
  * Purpose: Driver configuration header
@@ -100,6 +100,7 @@ struct _version {
 #ifndef DEVICE_VERSION
 #define DEVICE_VERSION       "1.19.12"
 #endif
+
 //config file
 #include <linux/fs.h>
 #include <linux/fcntl.h>
--- a/drivers/staging/vt6655/device.h
+++ b/drivers/staging/vt6655/device.h
@@ -81,9 +81,10 @@
 //
 
 
-
-//  device specific
 //
+// device specific
+//
+
 #if !defined(_KCOMPAT_H)
 #include "kcompat.h"
 #endif
@@ -122,11 +123,9 @@
 #if !defined(__DESC_H__)
 #include "desc.h"
 #endif
-
 #if !defined(__KEY_H__)
 #include "key.h"
 #endif
-
 #if !defined(__MAC_H__)
 #include "mac.h"
 #endif
@@ -189,6 +188,7 @@
 #define BB_VGA_CHANGE_THRESHOLD 16
 
 
+
 #ifndef RUN_AT
 #define RUN_AT(x)                       (jiffies+(x))
 #endif
@@ -312,7 +312,6 @@ typedef struct tagSPMKIDCandidateEvent {
     PMKID_CANDIDATE CandidateList[MAX_PMKIDLIST];
 } SPMKIDCandidateEvent, DEF* PSPMKIDCandidateEvent;
 
-
 //--
 
 //++ 802.11h related
@@ -347,7 +346,6 @@ typedef struct tagSCacheEntry{
     BYTE        abyAddr2[U_ETHER_ADDR_LEN];
 } SCacheEntry, *PSCacheEntry;
 
-
 typedef struct tagSCache{
 /* The receive cache is updated circularly.  The next entry to be written is
  * indexed by the "InPtr".
@@ -372,7 +370,6 @@ typedef struct tagSDeFragControlBlock
 
 
 
-
 //flags for options
 #define     DEVICE_FLAGS_IP_ALIGN        0x00000001UL
 #define     DEVICE_FLAGS_PREAMBLE_TYPE   0x00000002UL
@@ -417,11 +414,11 @@ typedef	struct _RxManagementQueue
 
 
 typedef struct __device_opt {
-    int         nRxDescs0;      //Number of RX descriptors0
-    int         nRxDescs1;      //Number of RX descriptors1
-    int         nTxDescs[2];    //Number of TX descriptors 0, 1
-    int         int_works;      //interrupt limits
-    int         rts_thresh;     //rts threshold
+    int         nRxDescs0;    //Number of RX descriptors0
+    int         nRxDescs1;    //Number of RX descriptors1
+    int         nTxDescs[2];  //Number of TX descriptors 0, 1
+    int         int_works;    //interrupt limits
+    int         rts_thresh;   //rts threshold
     int         frag_thresh;
     int         data_rate;
     int         channel_num;
@@ -609,8 +606,8 @@ typedef struct __device_info {
     BYTE                        byERPFlag;
     WORD                        wUseProtectCntDown;
 
-    BOOL                    bRadioControlOff;
-    BOOL                    bRadioOff;
+    BOOL                        bRadioControlOff;
+    BOOL                        bRadioOff;
     BOOL                    bEnablePSMode;
     WORD                    wListenInterval;
     BOOL                    bPWBitOn;
@@ -666,6 +663,7 @@ typedef struct __device_info {
 //2007-0925-01<Add>by MikeLiu
 //mike add :save old Encryption
     NDIS_802_11_WEP_STATUS  eOldEncryptionStatus;
+
     SKeyManagement          sKey;
     DWORD                   dwIVCounter;
 
@@ -674,7 +672,6 @@ typedef struct __device_info {
 
     RC4Ext                  SBox;
     BYTE                    abyPRNG[WLAN_WEPMAX_KEYLEN+3];
-
     BYTE                    byKeyIndex;
     UINT                    uKeyLength;
     BYTE                    abyKey[WLAN_WEP232_KEYLEN];
@@ -713,6 +710,7 @@ typedef struct __device_info {
     BYTE                    byBBPreEDRSSI;
     BYTE                    byBBPreEDIndex;
 
+
     BOOL                    bRadioCmd;
     DWORD                   dwDiagRefCount;
 
--- a/drivers/staging/vt6655/dpc.c
+++ b/drivers/staging/vt6655/dpc.c
@@ -144,6 +144,7 @@ static BOOL s_bAPModeRxCtl(
     );
 
 
+
 static BOOL s_bAPModeRxData (
     IN PSDevice pDevice,
     IN struct sk_buff* skb,
@@ -532,6 +533,8 @@ device_receive_frame (
             return FALSE;
         }
     }
+
+
     if (IS_FC_WEP(pbyFrame)) {
         BOOL     bRxDecryOK = FALSE;
 
@@ -718,7 +721,6 @@ device_receive_frame (
                 }
                 return FALSE;
             }
-
    //mike add:station mode check eapol-key challenge--->
    	  {
    	    BYTE  Protocol_Version;    //802.1x Authentication
@@ -742,8 +744,10 @@ device_receive_frame (
         }
     }
 
+
 // Data frame Handle
 
+
     if (pDevice->bEnablePSMode) {
         if (IS_FC_MOREDATA((skb->data+4))) {
             if (BITbIsBitOn(*pbyRsr, RSR_ADDROK)) {
@@ -890,12 +894,11 @@ device_receive_frame (
                             pDevice->dev->name);
                     }
                 }
-
-//2008-0409-07, <Add> by Einsn Liu
+               //2008-0409-07, <Add> by Einsn Liu
        #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 				//send event to wpa_supplicant
 				//if(pDevice->bWPADevEnable == TRUE)
-					{
+				{
 					union iwreq_data wrqu;
 					struct iw_michaelmicfailure ev;
 					int keyidx = pbyFrame[cbHeaderSize+3] >> 6; //top two-bits
@@ -917,6 +920,8 @@ device_receive_frame (
 
 				}
          #endif
+
+
                 if ((pDevice->bWPADEVUp) && (pDevice->skb != NULL)) {
                      wpahdr = (viawget_wpa_header *)pDevice->skb->data;
                      if ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&
@@ -1067,6 +1072,7 @@ device_receive_frame (
         }
         return FALSE;
     }
+
     return TRUE;
 }
 
@@ -1429,6 +1435,7 @@ static BOOL s_bHostWepRxEncryption (
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);
 
         if (byDecMode == KEY_CTL_TKIP) {
+
             if ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == FALSE)) {
                 // Software TKIP
                 // 1. 3253 A
@@ -1471,8 +1478,6 @@ static BOOL s_bHostWepRxEncryption (
 
 
 
-
-
 static BOOL s_bAPModeRxData (
     IN PSDevice pDevice,
     IN struct sk_buff* skb,
@@ -1487,9 +1492,9 @@ static BOOL s_bAPModeRxData (
     BOOL                bRelayOnly = FALSE;
     BYTE                byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};
     WORD                wAID;
-    struct sk_buff* skbcpy = NULL;
 
 
+    struct sk_buff* skbcpy = NULL;
 
     if (FrameSize > CB_MAX_BUF_SIZE)
         return FALSE;
@@ -1498,6 +1503,7 @@ static BOOL s_bAPModeRxData (
        if (pMgmt->sNodeDBTable[0].bPSEnable) {
 
            skbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);
+
         // if any node in PS mode, buffer packet until DTIM.
            if (skbcpy == NULL) {
                DBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");
@@ -1507,6 +1513,7 @@ static BOOL s_bAPModeRxData (
                skbcpy->len = FrameSize;
                memcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);
                skb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy);
+
                pMgmt->sNodeDBTable[0].wEnQueueCnt++;
                // set tx map
                pMgmt->abyPSTxMap[0] |= byMask[0];
--- a/drivers/staging/vt6655/dpc.h
+++ b/drivers/staging/vt6655/dpc.h
@@ -16,7 +16,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * File: whdr.h
+ * File: dpc.h
  *
  * Purpose:
  *
--- a/drivers/staging/vt6655/hostap.c
+++ b/drivers/staging/vt6655/hostap.c
@@ -109,7 +109,7 @@ static int hostap_enable_hostapd(PSDevic
 
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "%s: Enabling hostapd mode\n", dev->name);
 
-    pDevice->apdev = (struct net_device *)kmalloc(sizeof(struct net_device), GFP_KERNEL);
+	pDevice->apdev = (struct net_device *)kmalloc(sizeof(struct net_device), GFP_KERNEL);
 	if (pDevice->apdev == NULL)
 		return -ENOMEM;
 	memset(pDevice->apdev, 0, sizeof(struct net_device));
@@ -118,7 +118,7 @@ static int hostap_enable_hostapd(PSDevic
     *apdev_priv = *pDevice;
 	memcpy(pDevice->apdev->dev_addr, dev->dev_addr, ETH_ALEN);
 
-    pDevice->apdev->netdev_ops = &apdev_netdev_ops;
+	pDevice->apdev->netdev_ops = &apdev_netdev_ops;
 
 	pDevice->apdev->type = ARPHRD_IEEE80211;
 
@@ -288,7 +288,9 @@ static int hostap_add_sta(PSDevice pDevi
             WLAN_GET_CAP_INFO_SHORTPREAMBLE(pMgmt->sNodeDBTable[uNodeIndex].wCapInfo);
 
     pMgmt->sNodeDBTable[uNodeIndex].wAID = (WORD)param->u.add_sta.aid;
+
     pMgmt->sNodeDBTable[uNodeIndex].ulLastRxJiffer = jiffies;
+
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Add STA AID= %d \n", pMgmt->sNodeDBTable[uNodeIndex].wAID);
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "MAC=%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X \n",
                param->sta_addr[0],
@@ -327,6 +329,7 @@ static int hostap_get_info_sta(PSDevice 
     if (BSSDBbIsSTAInNodeDB(pMgmt, param->sta_addr, &uNodeIndex)) {
 	    param->u.get_info_sta.inactive_sec =
 	        (jiffies - pMgmt->sNodeDBTable[uNodeIndex].ulLastRxJiffer) / HZ;
+
 	    //param->u.get_info_sta.txexc = pMgmt->sNodeDBTable[uNodeIndex].uTxAttempts;
 	}
 	else {
--- a/drivers/staging/vt6655/iocmd.h
+++ b/drivers/staging/vt6655/iocmd.h
@@ -1,5 +1,6 @@
 /*
- * Copyright (c) 1996, 2003 VIA Networking, Inc. All rights reserved.
+ * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
+ * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -73,12 +74,12 @@ typedef enum tagWMAC_CMD {
     WLAN_CMD_SET_HOST_WEP,
     WLAN_CMD_SET_WPA,
     WLAN_CMD_GET_NODE_CNT,
-     WLAN_CMD_ZONETYPE_SET,
+    WLAN_CMD_ZONETYPE_SET,
     WLAN_CMD_GET_NODE_LIST
 
 } WMAC_CMD, DEF* PWMAC_CMD;
 
-	typedef enum tagWZONETYPE {
+typedef enum tagWZONETYPE {
   ZoneType_USA=0,
   ZoneType_Japan=1,
   ZoneType_Europe=2
@@ -106,7 +107,6 @@ typedef enum tagWMAC_CMD {
 #define WEP_104BIT_LEN         13
 #define WEP_232BIT_LEN         16
 
-
 // Ioctl interface structure
 // Command structure
 //
@@ -118,7 +118,6 @@ typedef struct tagSCmdRequest {
 	U16     wCmdCode;
 } SCmdRequest, *PSCmdRequest;
 
-
 //
 // Scan
 //
@@ -145,6 +144,10 @@ typedef struct tagSCmdBSSJoin {
 
 } SCmdBSSJoin, *PSCmdBSSJoin;
 
+//
+// Zonetype Setting
+//
+
 typedef struct tagSCmdZoneTypeSet {
 
  BOOL       bWrite;
@@ -162,7 +165,6 @@ typedef struct tagSWPAResult {
 } SWPAResult, *PSWPAResult;
 #endif
 
-
 typedef struct tagSCmdStartAP {
 
     U16	    wBSSType;
--- a/drivers/staging/vt6655/ioctl.c
+++ b/drivers/staging/vt6655/ioctl.c
@@ -65,12 +65,11 @@
 //static int          msglevel                =MSG_LEVEL_DEBUG;
 static int          msglevel                =MSG_LEVEL_INFO;
 
-/*---------------------  Static Functions  --------------------------*/
-
 #ifdef WPA_SM_Transtatus
     SWPAResult wpa_Result;
 #endif
 
+/*---------------------  Static Functions  --------------------------*/
 
 /*---------------------  Export Variables  --------------------------*/
 
@@ -101,7 +100,6 @@ int private_ioctl(PSDevice pDevice, stru
     BYTE                abyScanSSID[WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1];
     LONG                ldBm;
 
-
     pReq->wResult = 0;
 
     switch(pReq->wCmdCode) {
@@ -250,7 +248,6 @@ int private_ioctl(PSDevice pDevice, stru
         break;
 
     case WLAN_CMD_SET_WEP:
-
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "WLAN_CMD_SET_WEP Key. \n");
         memset(&sWEPCmd, 0 ,sizeof(SCmdSetWEP));
         if (copy_from_user(&sWEPCmd, pReq->data, sizeof(SCmdSetWEP))) {
@@ -695,13 +692,13 @@ int private_ioctl(PSDevice pDevice, stru
 	    wpa_Result.key_mgmt = 0;
 	    wpa_Result.eap_type = 0;
 	    wpa_Result.authenticated = FALSE;
-		  pDevice->fWPA_Authened = FALSE;
+	      pDevice->fWPA_Authened = FALSE;
         if (copy_from_user(&wpa_Result, pReq->data, sizeof(wpa_Result))) {
             result = -EFAULT;
 			break;
 		}
 
-	if(wpa_Result.authenticated==TRUE) {
+if(wpa_Result.authenticated==TRUE) {
    #ifdef SndEvt_ToAPI
    {
      union iwreq_data      wrqu;
@@ -728,7 +725,6 @@ int private_ioctl(PSDevice pDevice, stru
         break;
 #endif
 
-
     default:
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Private command not support..\n");
     }
--- a/drivers/staging/vt6655/iowpa.h
+++ b/drivers/staging/vt6655/iowpa.h
@@ -1,5 +1,6 @@
 /*
- * Copyright (c) 1996, 2003 VIA Networking, Inc. All rights reserved.
+ * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
+ * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
--- a/drivers/staging/vt6655/iwctl.c
+++ b/drivers/staging/vt6655/iwctl.c
@@ -105,6 +105,7 @@ struct iw_statistics *iwctl_get_wireless
 {
 	PSDevice pDevice = netdev_priv(dev);
 	long ldBm;
+
 	pDevice->wstats.status = pDevice->eOPMode;
 	#ifdef Calcu_LinkQual
 	 #if 0
@@ -161,7 +162,6 @@ static int iwctl_commit(struct net_devic
 	return 0;
 
 }
-
 /*
  * Wireless Handler : get protocol name
  */
@@ -197,8 +197,8 @@ int iwctl_siwscan(struct net_device *dev
              char *extra)
 {
 	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
-		struct iw_scan_req  *req = (struct iw_scan_req *)extra;
-		 PSMgmtObject        pMgmt = &(pDevice->sMgmtObj);
+	 PSMgmtObject        pMgmt = &(pDevice->sMgmtObj);
+	struct iw_scan_req  *req = (struct iw_scan_req *)extra;
 	BYTE                abyScanSSID[WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1];
 	PWLAN_IE_SSID       pItemSSID=NULL;
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSCAN \n");
@@ -207,14 +207,14 @@ int iwctl_siwscan(struct net_device *dev
 if(pDevice->byReAssocCount > 0) {   //reject scan when re-associating!
 //send scan event to wpa_Supplicant
   union iwreq_data wrqu;
- printk("wireless_send_event--->SIOCGIWSCAN(scan done)\n");
+ PRINT_K("wireless_send_event--->SIOCGIWSCAN(scan done)\n");
  memset(&wrqu, 0, sizeof(wrqu));
  wireless_send_event(pDevice->dev, SIOCGIWSCAN, &wrqu, NULL);
   return 0;
 }
 
 	spin_lock_irq(&pDevice->lock);
-	   BSSvClearBSSList((HANDLE)pDevice, pDevice->bLinkPass);
+	 BSSvClearBSSList((HANDLE)pDevice, pDevice->bLinkPass);
 
 //mike add: active scan OR passive scan OR desire_ssid scan
  if(wrq->length == sizeof(struct iw_scan_req)) {
@@ -230,7 +230,7 @@ if(pDevice->byReAssocCount > 0) {   //re
 	else
 	  pItemSSID->len = req->essid_len;
 	  pMgmt->eScanType = WMAC_SCAN_PASSIVE;
-         printk("SIOCSIWSCAN:[desired_ssid=%s,len=%d]\n",((PWLAN_IE_SSID)abyScanSSID)->abySSID,
+         PRINT_K("SIOCSIWSCAN:[desired_ssid=%s,len=%d]\n",((PWLAN_IE_SSID)abyScanSSID)->abySSID,
 		 	                                                                                ((PWLAN_IE_SSID)abyScanSSID)->len);
 	bScheduleCommand((HANDLE) pDevice, WLAN_CMD_BSSID_SCAN, abyScanSSID);
 	spin_unlock_irq(&pDevice->lock);
@@ -246,6 +246,7 @@ if(pDevice->byReAssocCount > 0) {   //re
  }
 
 	 pMgmt->eScanType = WMAC_SCAN_PASSIVE;
+          //printk("SIOCSIWSCAN:WLAN_CMD_BSSID_SCAN\n");
 	bScheduleCommand((HANDLE) pDevice, WLAN_CMD_BSSID_SCAN, NULL);
 	spin_unlock_irq(&pDevice->lock);
 
@@ -288,18 +289,19 @@ int iwctl_giwscan(struct net_device *dev
 			break;
         pBSS = &(pMgmt->sBSSList[jj]);
         if (pBSS->bActive) {
+		//ADD mac address
 		    memset(&iwe, 0, sizeof(iwe));
 		    iwe.cmd = SIOCGIWAP;
 		    iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
 			memcpy(iwe.u.ap_addr.sa_data, pBSS->abyBSSID, WLAN_BSSID_LEN);
-            current_ev = iwe_stream_add_event(info,current_ev,end_buf, &iwe, IW_EV_ADDR_LEN);
+                            current_ev = iwe_stream_add_event(info,current_ev,end_buf, &iwe, IW_EV_ADDR_LEN);
                  //ADD ssid
 	             memset(&iwe, 0, sizeof(iwe));
                       iwe.cmd = SIOCGIWESSID;
                       pItemSSID = (PWLAN_IE_SSID)pBSS->abySSID;
                        iwe.u.data.length = pItemSSID->len;
                        iwe.u.data.flags = 1;
-            current_ev = iwe_stream_add_point(info,current_ev,end_buf, &iwe, pItemSSID->abySSID);
+                      current_ev = iwe_stream_add_point(info,current_ev,end_buf, &iwe, pItemSSID->abySSID);
 		//ADD mode
 		    memset(&iwe, 0, sizeof(iwe));
 		    iwe.cmd = SIOCGIWMODE;
@@ -310,7 +312,7 @@ int iwctl_giwscan(struct net_device *dev
                 iwe.u.mode = IW_MODE_ADHOC;
 		    }
 	        iwe.len = IW_EV_UINT_LEN;
-            current_ev = iwe_stream_add_event(info,current_ev, end_buf, &iwe,  IW_EV_UINT_LEN);
+                      current_ev = iwe_stream_add_event(info,current_ev, end_buf, &iwe,  IW_EV_UINT_LEN);
            //ADD frequency
             pSuppRates = (PWLAN_IE_SUPP_RATES)pBSS->abySuppRates;
             pExtSuppRates = (PWLAN_IE_SUPP_RATES)pBSS->abyExtSuppRates;
@@ -319,9 +321,7 @@ int iwctl_giwscan(struct net_device *dev
            	iwe.u.freq.m = pBSS->uChannel;
            	iwe.u.freq.e = 0;
            	iwe.u.freq.i = 0;
-            current_ev = iwe_stream_add_event(info,current_ev,end_buf, &iwe, IW_EV_FREQ_LEN);
-
-
+                   current_ev = iwe_stream_add_event(info,current_ev,end_buf, &iwe, IW_EV_FREQ_LEN);
             //2008-0409-04, <Add> by Einsn Liu
 			{
 			int f = (int)pBSS->uChannel - 1;
@@ -329,7 +329,7 @@ int iwctl_giwscan(struct net_device *dev
 			iwe.u.freq.m = frequency_list[f] * 100000;
 			iwe.u.freq.e = 1;
 			}
-            current_ev = iwe_stream_add_event(info,current_ev,end_buf, &iwe, IW_EV_FREQ_LEN);
+                   current_ev = iwe_stream_add_event(info,current_ev,end_buf, &iwe, IW_EV_FREQ_LEN);
        		//ADD quality
             memset(&iwe, 0, sizeof(iwe));
 	        iwe.cmd = IWEVQUAL;
@@ -369,14 +369,14 @@ int iwctl_giwscan(struct net_device *dev
 			        break;
 		        // Bit rate given in 500 kb/s units (+ 0x80)
 		        iwe.u.bitrate.value = ((pSuppRates->abyRates[kk] & 0x7f) * 500000);
-                current_val = iwe_stream_add_value(info,current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
-			}
+                           current_val = iwe_stream_add_value(info,current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
+		}
        		for (kk = 0 ; kk < 8 ; kk++) {
 		        if (pExtSuppRates->abyRates[kk] == 0)
 			        break;
 		        // Bit rate given in 500 kb/s units (+ 0x80)
 		        iwe.u.bitrate.value = ((pExtSuppRates->abyRates[kk] & 0x7f) * 500000);
-                current_val = iwe_stream_add_value(info,current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
+                          current_val = iwe_stream_add_value(info,current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
 	        }
 
 	        if((current_val - current_ev) > IW_EV_LCP_LEN)
@@ -386,7 +386,7 @@ int iwctl_giwscan(struct net_device *dev
             iwe.cmd = IWEVCUSTOM;
             sprintf(buf, "bcn_int=%d", pBSS->wBeaconInterval);
             iwe.u.data.length = strlen(buf);
-            current_ev = iwe_stream_add_point(info,current_ev, end_buf, &iwe, buf);
+             current_ev = iwe_stream_add_point(info,current_ev, end_buf, &iwe, buf);
 
             if ((pBSS->wWPALen > 0) && (pBSS->wWPALen <= MAX_WPA_IE_LEN)) {
                 memset(&iwe, 0, sizeof(iwe));
@@ -712,7 +712,7 @@ int iwctl_siwap(struct net_device *dev,
 	PSDevice	        pDevice = (PSDevice)netdev_priv(dev);
     PSMgmtObject        pMgmt = &(pDevice->sMgmtObj);
     int rc = 0;
-        BYTE                 ZeroBSSID[WLAN_BSSID_LEN]={0x00,0x00,0x00,0x00,0x00,0x00};
+    BYTE                 ZeroBSSID[WLAN_BSSID_LEN]={0x00,0x00,0x00,0x00,0x00,0x00};
 
     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAP \n");
 if (pMgmt->eScanState ==  WMAC_IS_SCANNING) {
@@ -733,7 +733,7 @@ if (pMgmt->eScanState ==  WMAC_IS_SCANNI
 	//mike :add
 	 if ((IS_BROADCAST_ADDRESS(pMgmt->abyDesireBSSID)) ||
 	     (memcmp(pMgmt->abyDesireBSSID, ZeroBSSID, 6) == 0)){
-	      printk("SIOCSIWAP:invalid desired BSSID return!\n");
+	      PRINT_K("SIOCSIWAP:invalid desired BSSID return!\n");
                return rc;
          }
        //mike add: if desired AP is hidden ssid(there are two same BSSID in list),
@@ -747,10 +747,11 @@ if (pMgmt->eScanState ==  WMAC_IS_SCANNI
                      }
                   }
 	     if(uSameBssidNum >= 2) {  //hit: desired AP is in hidden ssid mode!!!
-                 printk("SIOCSIWAP:ignore for desired AP in hidden mode\n");
+                 PRINT_K("SIOCSIWAP:ignore for desired AP in hidden mode\n");
 	        return rc;
 	     }
        	}
+
         if (pDevice->flags & DEVICE_FLAGS_OPENED) {
 		    pDevice->bCommit = TRUE;
    		}
@@ -867,10 +868,9 @@ if (pMgmt->eScanState ==  WMAC_IS_SCANNI
 	// Check if we asked for `any'
 	if(wrq->flags == 0) {
 		// Just send an empty SSID list
-		// Just send an empty SSID list
 		memset(pMgmt->abyDesireSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
                   memset(pMgmt->abyDesireBSSID, 0xFF,6);
-	    printk("set essid to 'any' \n");
+	    PRINT_K("set essid to 'any' \n");
            #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
              //Unknown desired AP,so here need not associate??
             //if(pDevice->bWPASuppWextEnabled == TRUE)  {
@@ -882,8 +882,9 @@ if (pMgmt->eScanState ==  WMAC_IS_SCANNI
 		memset(pMgmt->abyDesireSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);
         pItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;
         pItemSSID->byElementID = WLAN_EID_SSID;
+
 		memcpy(pItemSSID->abySSID, extra, wrq->length);
-		         if (pItemSSID->abySSID[wrq->length - 1] == '\0') {
+	 if (pItemSSID->abySSID[wrq->length - 1] == '\0') {
            if(wrq->length>0)
 		pItemSSID->len = wrq->length - 1;
          }
@@ -896,7 +897,7 @@ if (pMgmt->eScanState ==  WMAC_IS_SCANNI
   	(memcmp(pItemSSID->abySSID,((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->abySSID,len)==0))
          return 0;
 
-        //mike:need clear desiredBSSID
+     //mike:need clear desiredBSSID
      if(pItemSSID->len==0) {
         memset(pMgmt->abyDesireBSSID, 0xFF,6);
         return 0;
@@ -921,7 +922,7 @@ if (pMgmt->eScanState ==  WMAC_IS_SCANNI
                                       );
 
             if (pCurr == NULL){
-               printk("SIOCSIWESSID:hidden ssid site survey before associate.......\n");
+               PRINT_K("SIOCSIWESSID:hidden ssid site survey before associate.......\n");
 	      vResetCommandTimer((HANDLE) pDevice);
 	      pMgmt->eScanType = WMAC_SCAN_ACTIVE;
                bScheduleCommand((HANDLE) pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);
@@ -949,10 +950,6 @@ if (pMgmt->eScanState ==  WMAC_IS_SCANNI
 	     #endif
 
 	    DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "set essid = %s \n", pItemSSID->abySSID);
-/*
- DBG_PRT(MSG_LEVEL_INFO, KERN_INFO " SIOCSIWESSID2 \n");
-		pItemSSID->len = wrq->length;
-	     */
 	}
 
     if (pDevice->flags & DEVICE_FLAGS_OPENED) {
@@ -1064,8 +1061,7 @@ int iwctl_siwrate(struct net_device *dev
 	printk("Rate Fix\n");
 		pDevice->bFixRate = TRUE;
         if ((pDevice->byBBType == BB_TYPE_11B)&& (brate > 3)) {
-
-			pDevice->uConnectionRate = 3;
+	    pDevice->uConnectionRate = 3;
         }
         else {
             pDevice->uConnectionRate = brate;
@@ -1077,7 +1073,7 @@ int iwctl_siwrate(struct net_device *dev
         pDevice->bFixRate = FALSE;
         pDevice->uConnectionRate = 13;
 	printk("auto rate:connection_rate is 13\n");
-}
+     }
 
 	return rc;
 }
@@ -1441,7 +1437,7 @@ if((wrq->flags & IW_ENCODE_DISABLED)==0)
 //End Modify,Einsn
 
 /*
-	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODE \n");
+     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODE \n");
 
 	// Check the size of the key
 	if (wrq->length > WLAN_WEP232_KEYLEN) {
@@ -1663,6 +1659,7 @@ int iwctl_giwencode(struct net_device *d
 	return 0;
 }
 
+
 /*
  * Wireless Handler : set power mode
  */
@@ -1790,20 +1787,19 @@ int iwctl_siwauth(struct net_device *dev
 	case IW_AUTH_WPA_VERSION:
 		wpa_version = wrq->value;
 		if(wrq->value == IW_AUTH_WPA_VERSION_DISABLED) {
-		       printk("iwctl_siwauth:set WPADEV to disable at 1??????\n");
+		       PRINT_K("iwctl_siwauth:set WPADEV to disable at 1??????\n");
 			//pDevice->bWPADevEnable = FALSE;
 		}
 		else if(wrq->value == IW_AUTH_WPA_VERSION_WPA) {
-                          printk("iwctl_siwauth:set WPADEV to WPA1******\n");
+                          PRINT_K("iwctl_siwauth:set WPADEV to WPA1******\n");
 		}
 		else {
-                          printk("iwctl_siwauth:set WPADEV to WPA2******\n");
+                          PRINT_K("iwctl_siwauth:set WPADEV to WPA2******\n");
 		}
 		//pDevice->bWPASuppWextEnabled =TRUE;
 		break;
 	case IW_AUTH_CIPHER_PAIRWISE:
 		pairwise = wrq->value;
-
 		if(pairwise == IW_AUTH_CIPHER_CCMP){
 			pDevice->eEncryptionStatus = Ndis802_11Encryption3Enabled;
 		}else if(pairwise == IW_AUTH_CIPHER_TKIP){
@@ -1968,10 +1964,10 @@ int iwctl_siwencodeext(struct net_device
 //original member
     wpa_alg alg_name;
     u8  addr[6];
-    int key_idx, set_tx;
+    int key_idx, set_tx=0;
     u8  seq[IW_ENCODE_SEQ_MAX_SIZE];
     u8 key[64];
-    size_t seq_len,key_len=0;
+    size_t seq_len=0,key_len=0;
 //
    // int ii;
     u8 *buf;
@@ -1979,7 +1975,7 @@ int iwctl_siwencodeext(struct net_device
     u8 key_array[64];
     int ret=0;
 
-printk("SIOCSIWENCODEEXT...... \n");
+PRINT_K("SIOCSIWENCODEEXT...... \n");
 
 blen = sizeof(*param);
 buf = kmalloc((int)blen, (int)GFP_KERNEL);
@@ -2003,7 +1999,7 @@ switch (ext->alg) {
                   alg_name = WPA_ALG_CCMP;
 		break;
     default:
-		printk("Unknown alg = %d\n",ext->alg);
+		PRINT_K("Unknown alg = %d\n",ext->alg);
 		ret= -ENOMEM;
 		goto error;
 		}
@@ -2046,7 +2042,6 @@ param->u.wpa_key.seq = (u8 *)seq;
 param->u.wpa_key.seq_len = seq_len;
 
 #if 0
-int ii;
 printk("param->u.wpa_key.alg_name =%d\n",param->u.wpa_key.alg_name);
 printk("param->addr=%02x:%02x:%02x:%02x:%02x:%02x\n",
 	      param->addr[0],param->addr[1],param->addr[2],
--- a/drivers/staging/vt6655/iwctl.h
+++ b/drivers/staging/vt6655/iwctl.h
@@ -227,6 +227,7 @@ int iwctl_siwmlme(struct net_device *dev
 			struct iw_point *wrq,
 			char *extra);
 #endif // #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+//End Add -- //2008-0409-07, <Add> by Einsn Liu
 
 
 extern const struct iw_handler_def	iwctl_handler_def;
--- a/drivers/staging/vt6655/kcompat.h
+++ b/drivers/staging/vt6655/kcompat.h
@@ -1,6 +1,5 @@
 /*
- * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
- * All rights reserved.
+ * Copyright (c) 1996, 2003 VIA Networking, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -66,6 +65,7 @@
 #ifndef IRQ_RETVAL
 typedef void irqreturn_t;
 
+
 #define IRQ_RETVAL(x)
 
 #endif
@@ -75,6 +75,5 @@ typedef void irqreturn_t;
 #define MODULE_LICESEN(x)
 #endif
 
-
 #endif
 
--- a/drivers/staging/vt6655/key.c
+++ b/drivers/staging/vt6655/key.c
@@ -85,6 +85,7 @@ s_vCheckKeyTableValid (PSKeyManagement p
             (pTable->KeyTable[i].GroupKey[2].bKeyValid == FALSE) &&
             (pTable->KeyTable[i].GroupKey[3].bKeyValid == FALSE)
             ) {
+
             pTable->KeyTable[i].bInUse = FALSE;
             pTable->KeyTable[i].wKeyCtl = 0;
             pTable->KeyTable[i].bSoftWEP = FALSE;
--- a/drivers/staging/vt6655/mac.c
+++ b/drivers/staging/vt6655/mac.c
@@ -16,6 +16,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ *
  * File: mac.c
  *
  * Purpose:  MAC routines
@@ -67,6 +68,8 @@
  *
  */
 
+
+
 #if !defined(__TMACRO_H__)
 #include "tmacro.h"
 #endif
@@ -95,6 +98,10 @@ static int          msglevel            
 
 /*---------------------  Export Functions  --------------------------*/
 
+
+
+
+
 /*
  * Description:
  *      Read All MAC Registers to buffer
--- a/drivers/staging/vt6655/mac.h
+++ b/drivers/staging/vt6655/mac.h
@@ -24,18 +24,16 @@
  * Author: Tevin Chen
  *
  * Date: May 21, 1996
+ *
  * Revision History:
  *      07-01-2003 Bryan YC Fan:  Re-write codes to support VT3253 spec.
  *      08-25-2003 Kyle Hsu:      Porting MAC functions from sim53.
  *      09-03-2003 Bryan YC Fan:  Add MACvDisableProtectMD & MACvEnableProtectMD
- *
  */
 
 #ifndef __MAC_H__
 #define __MAC_H__
 
-
-
 #if !defined(__TTYPE_H__)
 #include "ttype.h"
 #endif
@@ -130,7 +128,7 @@
 #define MAC_REG_IFREGCTL    0x70        //
 #define MAC_REG_IFDATA      0x71        //
 #define MAC_REG_ITRTMSET    0x74        //
-#define MAC_REG_PAPEDELAY   0x77        //
+#define MAC_REG_PAPEDELAY   0x77
 #define MAC_REG_SOFTPWRCTL  0x78        //
 #define MAC_REG_GPIOCTL0    0x7A        //
 #define MAC_REG_GPIOCTL1    0x7B        //
--- a/drivers/staging/vt6655/power.c
+++ b/drivers/staging/vt6655/power.c
@@ -16,6 +16,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ *
  * File: power.c
  *
  * Purpose: Handles 802.11 power management  functions
--- a/drivers/staging/vt6655/power.h
+++ b/drivers/staging/vt6655/power.h
@@ -16,7 +16,6 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- *
  * File: power.h
  *
  * Purpose: Handles 802.11 power management  functions
--- a/drivers/staging/vt6655/rc4.c
+++ b/drivers/staging/vt6655/rc4.c
@@ -1,5 +1,6 @@
 /*
- * File: rc4.c
+ * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
+ * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -15,6 +16,8 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ * File: rc4.c
+ *
  * Purpose:
  *
  * Functions:
--- a/drivers/staging/vt6655/rf.c
+++ b/drivers/staging/vt6655/rf.c
@@ -31,6 +31,7 @@
  * Revision History:
  *
  */
+
 #if !defined(__MAC_H__)
 #include "mac.h"
 #endif
--- a/drivers/staging/vt6655/rxtx.h
+++ b/drivers/staging/vt6655/rxtx.h
@@ -16,7 +16,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * File: whdr.h
+ * File: rxtx.h
  *
  * Purpose:
  *
--- a/drivers/staging/vt6655/srom.h
+++ b/drivers/staging/vt6655/srom.h
@@ -36,9 +36,10 @@
 #endif
 
 
-/*---------------------  Export Definitions -------------------------*/
 
 
+/*---------------------  Export Definitions -------------------------*/
+
 #define EEP_MAX_CONTEXT_SIZE    256
 
 #define CB_EEPROM_READBYTE_WAIT 900     //us
@@ -48,7 +49,6 @@
 //
 // Contents in the EEPROM
 //
-
 #define EEP_OFS_PAR         0x00        // physical address
 #define EEP_OFS_ANTENNA     0x16
 #define EEP_OFS_RADIOCTL    0x17
@@ -97,8 +97,6 @@
 #define EEP_RADIOCTL_ENABLE 0x80
 #define EEP_RADIOCTL_INV    0x01
 
-
-
 /*---------------------  Export Types  ------------------------------*/
 
 // AT24C02 eeprom contents
@@ -175,5 +173,3 @@ BOOL SROMbAutoLoad (DWORD_PTR dwIoBase);
 
 
 #endif // __EEPROM_H__
-
-
--- a/drivers/staging/vt6655/tpci.h
+++ b/drivers/staging/vt6655/tpci.h
@@ -2,6 +2,7 @@
  * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  * All rights reserved.
  *
+
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -15,6 +16,7 @@
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
  *
  *
  * File: tpci.h
--- a/drivers/staging/vt6655/ttype.h
+++ b/drivers/staging/vt6655/ttype.h
@@ -1,5 +1,6 @@
 /*
- * File: ttype.h
+ * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
+ * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -15,6 +16,8 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ * File: ttype.h
+ *
  * Purpose: define basic common types and macros
  *
  * Author: Tevin Chen
--- a/drivers/staging/vt6655/vntwifi.h
+++ b/drivers/staging/vt6655/vntwifi.h
@@ -39,6 +39,7 @@
 #if !defined(__CARD_H__)
 #include "card.h"
 #endif
+#include "wpa2.h"
 
 /*---------------------  Export Definitions -------------------------*/
 #define RATE_1M         0
@@ -67,8 +68,6 @@
 
 #define MAX_BSS_NUM             42
 
-#define MAX_PMKID_CACHE         16
-
 // Pre-configured Authenticaiton Mode (from XP)
 typedef enum tagWMAC_AUTHENTICATION_MODE {
 
--- a/drivers/staging/vt6655/wcmd.c
+++ b/drivers/staging/vt6655/wcmd.c
@@ -1,4 +1,4 @@
- /*
+/*
  * Copyright (c) 1996, 2003 VIA Networking Technologies, Inc.
  * All rights reserved.
  *
@@ -16,7 +16,6 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- *
  * File: wcmd.c
  *
  * Purpose: Handles the management command interface functions
@@ -122,6 +121,7 @@ s_MgrMakeProbeRequest(
     IN PWLAN_IE_SUPP_RATES pCurrExtSuppRates
     );
 
+
 static
 BOOL
 s_bCommandComplete (
@@ -134,6 +134,7 @@ s_bCommandComplete (
 /*---------------------  Export Functions  --------------------------*/
 
 
+
 /*
  * Description:
  *      Stop AdHoc beacon during scan process
@@ -186,7 +187,8 @@ vAdHocBeaconStop(PSDevice  pDevice)
         MACvRegBitsOff(pDevice->PortOffset, MAC_REG_TCR, TCR_AUTOBCNTX);
     }
 
-}
+} /* vAdHocBeaconStop */
+
 
 /*
  * Description:
@@ -224,6 +226,8 @@ vAdHocBeaconRestart(PSDevice pDevice)
 
 
 
+
+
 /*+
  *
  * Routine Description:
@@ -350,6 +354,7 @@ s_MgrMakeProbeRequest(
 
 
 
+
 VOID
 vCommandTimerWait(
     IN HANDLE    hDeviceContext,
@@ -369,6 +374,7 @@ vCommandTimerWait(
 
 
 
+
 VOID
 vCommandTimer (
     IN  HANDLE      hDeviceContext
--- a/drivers/staging/vt6655/wcmd.h
+++ b/drivers/staging/vt6655/wcmd.h
@@ -46,6 +46,7 @@
 #define AUTHENTICATE_TIMEOUT   1000 //ms
 #define ASSOCIATE_TIMEOUT      1000 //ms
 
+
 // Command code
 typedef enum tagCMD_CODE {
     WLAN_CMD_BSSID_SCAN,
@@ -67,11 +68,9 @@ typedef enum tagCMD_CODE {
 
 #define CMD_Q_SIZE              32
 
-
-// Command code
 typedef enum tagCMD_STATUS {
 
-    CMD_STATUS_SUCCESS,
+    CMD_STATUS_SUCCESS = 0,
     CMD_STATUS_FAILURE,
     CMD_STATUS_RESOURCES,
     CMD_STATUS_TIMEOUT,
@@ -106,6 +105,7 @@ typedef enum tagCMD_STATE {
 } CMD_STATE, DEF* PCMD_STATE;
 
 
+
 /*---------------------  Export Classes  ----------------------------*/
 
 /*---------------------  Export Variables  --------------------------*/
@@ -115,7 +115,6 @@ typedef enum tagCMD_STATE {
 
 
 /*---------------------  Export Functions  --------------------------*/
-
 VOID
 vResetCommandTimer(
     IN HANDLE      hDeviceContext
@@ -148,4 +147,5 @@ BSSvSecondTxData(
     IN  HANDLE      hDeviceContext
     );
 #endif
+
 #endif //__WCMD_H__
--- a/drivers/staging/vt6655/wmgr.c
+++ b/drivers/staging/vt6655/wmgr.c
@@ -16,6 +16,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ *
  * File: wmgr.c
  *
  * Purpose: Handles the 802.11 management functions
@@ -137,6 +138,7 @@ static BOOL ChannelExceedZoneType(
     IN PSDevice pDevice,
     IN BYTE byCurrChannel
     );
+
 // Association/diassociation functions
 static
 PSTxMgmtPacket
@@ -363,33 +365,10 @@ s_bCipherMatch (
     OUT PBYTE                           pbyCCSGK
     );
 
-
  static VOID  Encyption_Rebuild(
     IN PSDevice pDevice,
     IN PKnownBSS pCurr
  );
-/*
-static
-VOID
-s_vProbeChannel(
-    IN PSDevice pDevice
-    );
-
-static
-VOID
-s_vListenChannel(
-    IN PSDevice pDevice
-    );
-
-static
-PSTxMgmtPacket
-s_MgrMakeProbeRequest(
-    IN PSMgmtObject pMgmt,
-    IN PBYTE pScanBSSID,
-    IN PWLAN_IE_SSID pSSID,
-    IN PWLAN_IE_SUPP_RATES pCurrRates
-    );
-*/
 
 
 
@@ -1780,7 +1759,6 @@ s_vMgrRxDisassociation(
 	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
      }
   #endif
-
     }
     /* else, ignore it */
 
@@ -1857,13 +1835,13 @@ s_vMgrRxDeauthentication(
                  pDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);
            };
 
-	   #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
+   #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
   // if(pDevice->bWPASuppWextEnabled == TRUE)
       {
 	union iwreq_data  wrqu;
 	memset(&wrqu, 0, sizeof (wrqu));
         wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	printk("wireless_send_event--->SIOCGIWAP(disauthen)\n");
+	PRINT_K("wireless_send_event--->SIOCGIWAP(disauthen)\n");
 	wireless_send_event(pDevice->dev, SIOCGIWAP, &wrqu, NULL);
      }
   #endif
@@ -3172,22 +3150,22 @@ s_vMgrSynchBSS (
                           pMgmt->eAuthenMode = WMAC_AUTH_WPAPSK;
 		    if(pCurr->abyPKType[0] == WPA_TKIP) {
      		        pDevice->eEncryptionStatus = Ndis802_11Encryption2Enabled;    //TKIP
-     		        printk("Encyption_Rebuild--->ssid reset config to [WPAPSK-TKIP]\n");
+     		        PRINT_K("Encyption_Rebuild--->ssid reset config to [WPAPSK-TKIP]\n");
 		      }
      		   else if(pCurr->abyPKType[0] == WPA_AESCCMP) {
 		        pDevice->eEncryptionStatus = Ndis802_11Encryption3Enabled;    //AES
-                          printk("Encyption_Rebuild--->ssid reset config to [WPAPSK-AES]\n");
+                          PRINT_K("Encyption_Rebuild--->ssid reset config to [WPAPSK-AES]\n");
      		     }
                	}
                else if(pCurr->bWPA2Valid == TRUE) {  //WPA2-PSK
                          pMgmt->eAuthenMode = WMAC_AUTH_WPA2PSK;
 		       if(pCurr->abyCSSPK[0] == WLAN_11i_CSS_TKIP) {
       		           pDevice->eEncryptionStatus = Ndis802_11Encryption2Enabled;     //TKIP
-                             printk("Encyption_Rebuild--->ssid reset config to [WPA2PSK-TKIP]\n");
+                             PRINT_K("Encyption_Rebuild--->ssid reset config to [WPA2PSK-TKIP]\n");
 		       	}
       		       else if(pCurr->abyCSSPK[0] == WLAN_11i_CSS_CCMP) {
 		           pDevice->eEncryptionStatus = Ndis802_11Encryption3Enabled;    //AES
-                            printk("Encyption_Rebuild--->ssid reset config to [WPA2PSK-AES]\n");
+                            PRINT_K("Encyption_Rebuild--->ssid reset config to [WPA2PSK-AES]\n");
       		       	}
                	}
               }
@@ -3832,6 +3810,7 @@ s_MgrMakeAssocRequest(
         *pbyRSN++=0x01;
         *pbyRSN++=0x00;
         *pbyRSN++=0x00;
+
         *pbyRSN++=0x50;
         *pbyRSN++=0xf2;
         if (pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) {
@@ -3843,12 +3822,15 @@ s_MgrMakeAssocRequest(
         else {
             *pbyRSN++=WPA_NONE;
         }
+
         sFrame.pRSNWPA->len +=6;
 
         // RSN Capabilites
+
         *pbyRSN++=0x00;
         *pbyRSN++=0x00;
         sFrame.pRSNWPA->len +=2;
+
         sFrame.len += sFrame.pRSNWPA->len + WLAN_IEHDR_LEN;
         // copy to AssocInfo. for OID_802_11_ASSOCIATION_INFORMATION
         pMgmt->sAssocInfo.AssocInfo.RequestIELength += sFrame.pRSNWPA->len + WLAN_IEHDR_LEN;
@@ -4087,6 +4069,7 @@ s_MgrMakeReAssocRequest(
         *pbyRSN++=0x01;
         *pbyRSN++=0x00;
         *pbyRSN++=0x00;
+
         *pbyRSN++=0x50;
         *pbyRSN++=0xf2;
         if (pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) {
@@ -4096,12 +4079,14 @@ s_MgrMakeReAssocRequest(
         } else {
             *pbyRSN++=WPA_NONE;
         }
+
         sFrame.pRSNWPA->len +=6;
 
         // RSN Capabilites
         *pbyRSN++=0x00;
         *pbyRSN++=0x00;
         sFrame.pRSNWPA->len +=2;
+
         sFrame.len += sFrame.pRSNWPA->len + WLAN_IEHDR_LEN;
         // copy to AssocInfo. for OID_802_11_ASSOCIATION_INFORMATION
         pMgmt->sAssocInfo.AssocInfo.RequestIELength += sFrame.pRSNWPA->len + WLAN_IEHDR_LEN;
@@ -4677,7 +4662,7 @@ vMgrRxManagePacket(
 
         case WLAN_FSTYPE_BEACON:
             // Frame Clase = 0
-            // DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "rx beacon\n");
+            //DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "rx beacon\n");
             if (pMgmt->eScanState != WMAC_NO_SCANNING) {
                 bInScan = TRUE;
             };
@@ -4953,7 +4938,6 @@ s_bCipherMatch (
         return FALSE;
 
     // check cap. of BSS
-
     if ((WLAN_GET_CAP_INFO_PRIVACY(pBSSNode->wCapInfo) != 0) &&
          (EncStatus == Ndis802_11Encryption1Enabled)) {
         // default is WEP only
@@ -4962,8 +4946,8 @@ s_bCipherMatch (
 
     if ((WLAN_GET_CAP_INFO_PRIVACY(pBSSNode->wCapInfo) != 0) &&
         (pBSSNode->bWPA2Valid == TRUE) &&
+          //20080123-01,<Add> by Einsn Liu
         ((EncStatus == Ndis802_11Encryption3Enabled)||(EncStatus == Ndis802_11Encryption2Enabled))) {
-
         //WPA2
         // check Group Key Cipher
         if ((pBSSNode->byCSSGK == WLAN_11i_CSS_WEP40) ||
@@ -4993,10 +4977,10 @@ s_bCipherMatch (
                 i = pBSSNode->wCSSPKCount;
             }
         }
+
     } else if ((WLAN_GET_CAP_INFO_PRIVACY(pBSSNode->wCapInfo) != 0) &&
                 (pBSSNode->bWPAValid == TRUE) &&
-                ((EncStatus == Ndis802_11Encryption3Enabled)||(EncStatus == Ndis802_11Encryption2Enabled))) {
-
+                ((EncStatus == Ndis802_11Encryption3Enabled) || (EncStatus == Ndis802_11Encryption2Enabled))) {
         //WPA
         // check Group Key Cipher
         if ((pBSSNode->byGKType == WPA_WEP40) ||
@@ -5029,6 +5013,7 @@ s_bCipherMatch (
 
     // mask our cap. with BSS
     if (EncStatus == Ndis802_11Encryption1Enabled) {
+
         // For supporting Cisco migration mode, don't care pairwise key cipher
         if ((byMulticastCipher == KEY_CTL_WEP) &&
             (byCipherMask == 0)) {
--- a/drivers/staging/vt6655/wpa2.h
+++ b/drivers/staging/vt6655/wpa2.h
@@ -44,13 +44,12 @@
 #if !defined(__BSSDB_H__)
 #include "bssdb.h"
 #endif
-#if !defined(__VNTWIFI_H__)
-#include "vntwifi.h"
-#endif
+
 
 
 
 /*---------------------  Export Definitions -------------------------*/
+#define MAX_PMKID_CACHE         16
 
 typedef struct tagsPMKIDInfo {
     BYTE    abyBSSID[6];
--- a/drivers/staging/vt6655/wpactl.c
+++ b/drivers/staging/vt6655/wpactl.c
@@ -16,6 +16,7 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
+ *
  * File: wpactl.c
  *
  * Purpose: handle wpa supplicant ioctl input/out functions
@@ -79,8 +80,6 @@ static int          msglevel            
 
 
 /*---------------------  Export Variables  --------------------------*/
-
-
 static void wpadev_setup(struct net_device *dev)
 {
 	dev->type               = ARPHRD_IEEE80211;
@@ -94,8 +93,6 @@ static void wpadev_setup(struct net_devi
 	dev->flags              = IFF_BROADCAST|IFF_MULTICAST;
 }
 
-
-
 /*
  * Description:
  *      register netdev for wpa supplicant deamon
@@ -122,7 +119,6 @@ static int wpa_init_wpadev(PSDevice pDev
 
     wpadev_priv = netdev_priv(pDevice->wpadev);
     *wpadev_priv = *pDevice;
-
 	memcpy(pDevice->wpadev->dev_addr, dev->dev_addr, U_ETHER_ADDR_LEN);
          pDevice->wpadev->base_addr = dev->base_addr;
 	pDevice->wpadev->irq = dev->irq;
@@ -164,7 +160,6 @@ static int wpa_init_wpadev(PSDevice pDev
 
 static int wpa_release_wpadev(PSDevice pDevice)
 {
-
     if (pDevice->skb) {
         dev_kfree_skb(pDevice->skb);
         pDevice->skb = NULL;
@@ -201,8 +196,6 @@ static int wpa_release_wpadev(PSDevice p
 
 int wpa_set_wpadev(PSDevice pDevice, int val)
 {
-
-
 	if (val)
 		return wpa_init_wpadev(pDevice);
 	else
@@ -224,9 +217,9 @@ int wpa_set_wpadev(PSDevice pDevice, int
  *
  */
 
-int wpa_set_keys(PSDevice pDevice, void *ctx, BOOL  fcpfkernel)
+ int wpa_set_keys(PSDevice pDevice, void *ctx, BOOL  fcpfkernel)
 {
- struct viawget_wpa_param *param=ctx;
+    struct viawget_wpa_param *param=ctx;
     PSMgmtObject pMgmt = pDevice->pMgmt;
     DWORD   dwKeyIndex = 0;
     BYTE    abyKey[MAX_KEY_LEN];
@@ -261,8 +254,8 @@ int wpa_set_keys(PSDevice pDevice, void 
     else {
 	spin_unlock_irq(&pDevice->lock);
 	if (param->u.wpa_key.key &&
-	    copy_from_user(&abyKey[0], param->u.wpa_key.key, param->u.wpa_key.key_len)){
-	        spin_lock_irq(&pDevice->lock);
+	    copy_from_user(&abyKey[0], param->u.wpa_key.key, param->u.wpa_key.key_len)) {
+	    spin_lock_irq(&pDevice->lock);
 	    return -EINVAL;
     	}
 spin_lock_irq(&pDevice->lock);
@@ -302,9 +295,8 @@ spin_lock_irq(&pDevice->lock);
        else {
 	   	spin_unlock_irq(&pDevice->lock);
 	if (param->u.wpa_key.seq &&
-	    copy_from_user(&abySeq[0], param->u.wpa_key.seq, param->u.wpa_key.seq_len)){
-
-	 spin_lock_irq(&pDevice->lock);
+	    copy_from_user(&abySeq[0], param->u.wpa_key.seq, param->u.wpa_key.seq_len)) {
+	    spin_lock_irq(&pDevice->lock);
 	    return -EINVAL;
        	}
 spin_lock_irq(&pDevice->lock);
@@ -337,6 +329,7 @@ spin_lock_irq(&pDevice->lock);
 	if (param->u.wpa_key.set_tx)
 		dwKeyIndex |= (1 << 31);
 
+
     if (pDevice->eEncryptionStatus == Ndis802_11Encryption3Enabled)
         byKeyDecMode = KEY_CTL_CCMP;
     else if (pDevice->eEncryptionStatus == Ndis802_11Encryption2Enabled)
@@ -359,7 +352,6 @@ spin_lock_irq(&pDevice->lock);
             byKeyDecMode = KEY_CTL_WEP;
     }
 
-
     // Check TKIP key length
     if ((byKeyDecMode == KEY_CTL_TKIP) &&
         (param->u.wpa_key.key_len != MAX_KEY_LEN)) {
--- a/drivers/staging/vt6655/wpactl.h
+++ b/drivers/staging/vt6655/wpactl.h
@@ -33,6 +33,7 @@
 #if !defined(__DEVICE_H__)
 #include "device.h"
 #endif
+
 #ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT
 #if !defined(__IOWPA_H__)
 #include "iowpa.h"
