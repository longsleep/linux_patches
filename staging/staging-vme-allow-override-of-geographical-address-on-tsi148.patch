From martyn.welch@gefanuc.com  Fri Dec 18 10:24:12 2009
From: Martyn Welch <martyn.welch@gefanuc.com>
Date: Tue, 15 Dec 2009 08:42:49 +0000
Subject: Staging: vme: Allow override of geographical address on tsi148
To: greg@kroah.com
Cc: devel@linuxdriverproject.org
Message-ID: <20091215084249.3930.79239.stgit@ES-J7S4D2J.amer.consind.ge.com>


Geographical addressing only works if the VME backplane supports it. There
are a large number of old backplanes which do not support geographical
addressing. These boards will generally report a slot ID of zero - which is
an invalid ID in the slot numbering scheme.

Allow the geographical address to be over-ridden on the tsi148 so that a
slot ID can be provided manually in these circumstances.

Signed-off-by: Markus Kraemer <mkraemer@e18.physik.tu-muenchen.de>
Signed-off-by: Martyn Welch <martyn.welch@gefanuc.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/vme/bridges/vme_tsi148.c |   25 ++++++++++++++++++++-----
 1 file changed, 20 insertions(+), 5 deletions(-)

--- a/drivers/staging/vme/bridges/vme_tsi148.c
+++ b/drivers/staging/vme/bridges/vme_tsi148.c
@@ -63,6 +63,7 @@ int tsi148_slot_get(void);
 
 /* Modue parameter */
 int err_chk = 0;
+static int geoid;
 
 /* XXX These should all be in a per device structure */
 struct vme_bridge *tsi148_bridge;
@@ -2145,8 +2146,12 @@ int tsi148_slot_get(void)
 {
         u32 slot = 0;
 
-	slot = ioread32be(tsi148_bridge->base + TSI148_LCSR_VSTAT);
-	slot = slot & TSI148_LCSR_VSTAT_GA_M;
+	if (!geoid) {
+		slot = ioread32be(tsi148_bridge->base + TSI148_LCSR_VSTAT);
+		slot = slot & TSI148_LCSR_VSTAT_GA_M;
+	} else
+		slot = geoid;
+
 	return (int)slot;
 }
 
@@ -2196,6 +2201,7 @@ static int tsi148_crcsr_init(struct pci_
 	vstat = tsi148_slot_get();
 
 	if (cbar != vstat) {
+		cbar = vstat;
 		dev_info(&pdev->dev, "Setting CR/CSR offset\n");
 		iowrite32be(cbar<<3, tsi148_bridge->base + TSI148_CBAR);
 	}
@@ -2458,8 +2464,13 @@ static int tsi148_probe(struct pci_dev *
 	data = ioread32be(tsi148_bridge->base + TSI148_LCSR_VSTAT);
 	dev_info(&pdev->dev, "Board is%s the VME system controller\n",
 		(data & TSI148_LCSR_VSTAT_SCONS)? "" : " not");
-	dev_info(&pdev->dev, "VME geographical address is %d\n",
-		data & TSI148_LCSR_VSTAT_GA_M);
+	if (!geoid) {
+		dev_info(&pdev->dev, "VME geographical address is %d\n",
+			data & TSI148_LCSR_VSTAT_GA_M);
+	} else {
+		dev_info(&pdev->dev, "VME geographical address is set to %d\n",
+			geoid);
+	}
 	dev_info(&pdev->dev, "VME Write and flush and error check is %s\n",
 		err_chk ? "enabled" : "disabled");
 
@@ -2608,7 +2619,8 @@ static void tsi148_remove(struct pci_dev
 
 	/* resources are stored in link list */
 	list_for_each(pos, &(tsi148_bridge->master_resources)) {
-		master_image = list_entry(pos, struct vme_master_resource,				list);
+		master_image = list_entry(pos, struct vme_master_resource,
+			list);
 		list_del(pos);
 		kfree(master_image);
 	}
@@ -2634,6 +2646,9 @@ static void __exit tsi148_exit(void)
 MODULE_PARM_DESC(err_chk, "Check for VME errors on reads and writes");
 module_param(err_chk, bool, 0);
 
+MODULE_PARM_DESC(geoid, "Override geographical addressing");
+module_param(geoid, int, 0);
+
 MODULE_DESCRIPTION("VME driver for the Tundra Tempe VME bridge");
 MODULE_LICENSE("GPL");
 
