From mchehab@infradead.org  Fri Nov  6 16:15:32 2009
From: Mauro Carvalho Chehab <mchehab@infradead.org>
Date: Tue, 3 Nov 2009 07:42:46 -0200
Subject: Staging: rtl8192u: remove bad whitespaces
To: <devel@driverdev.osuosl.org>
Message-ID: <20091103074246.59b4f4b2@pedra.chehab.org>



Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/rtl8192u/ieee80211.h                      |  714 +++++++-------
 drivers/staging/rtl8192u/ieee80211/aes.c                  |   34 
 drivers/staging/rtl8192u/ieee80211/arc4.c                 |    6 
 drivers/staging/rtl8192u/ieee80211/cipher.c               |  102 +-
 drivers/staging/rtl8192u/ieee80211/compress.c             |   16 
 drivers/staging/rtl8192u/ieee80211/crypto_compat.h        |   12 
 drivers/staging/rtl8192u/ieee80211/digest.c               |    6 
 drivers/staging/rtl8192u/ieee80211/ieee80211.h            |  700 ++++++-------
 drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_ccmp.c |    2 
 drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_tkip.c |   46 
 drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_wep.c  |   54 -
 drivers/staging/rtl8192u/ieee80211/ieee80211_module.c     |   10 
 drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c    |  100 -
 drivers/staging/rtl8192u/ieee80211/ieee80211_softmac_wx.c |    4 
 drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c         |  448 ++++----
 drivers/staging/rtl8192u/ieee80211/proc.c                 |    2 
 drivers/staging/rtl8192u/ieee80211/rtl819x_HT.h           |    2 
 drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c       |   20 
 drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h          |   12 
 drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c       |   38 
 drivers/staging/rtl8192u/r8180_pm.c                       |    8 
 drivers/staging/rtl8192u/r8192U_core.c                    |  714 +++++++-------
 drivers/staging/rtl8192u/r8192U_dm.c                      |   28 
 drivers/staging/rtl8192u/r8192U_dm.h                      |    2 
 drivers/staging/rtl8192u/r8192U_hw.h                      |    2 
 drivers/staging/rtl8192u/r8192U_wx.c                      |  318 +++---
 drivers/staging/rtl8192u/r819xU_cmdpkt.c                  |   12 
 drivers/staging/rtl8192u/r819xU_cmdpkt.h                  |    8 
 drivers/staging/rtl8192u/r819xU_firmware.c                |   18 
 drivers/staging/rtl8192u/r819xU_phy.c                     |   22 
 drivers/staging/rtl8192u/r819xU_phyreg.h                  |   50 
 31 files changed, 1755 insertions(+), 1755 deletions(-)

--- a/drivers/staging/rtl8192u/ieee80211/aes.c
+++ b/drivers/staging/rtl8192u/ieee80211/aes.c
@@ -126,15 +126,15 @@ f_mult (u8 a, u8 b)
 
 #define f_rn(bo, bi, n, k)					\
     bo[n] =  ft_tab[0][byte(bi[n],0)] ^				\
-             ft_tab[1][byte(bi[(n + 1) & 3],1)] ^		\
-             ft_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
-             ft_tab[3][byte(bi[(n + 3) & 3],3)] ^ *(k + n)
+	     ft_tab[1][byte(bi[(n + 1) & 3],1)] ^		\
+	     ft_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
+	     ft_tab[3][byte(bi[(n + 3) & 3],3)] ^ *(k + n)
 
 #define i_rn(bo, bi, n, k)					\
     bo[n] =  it_tab[0][byte(bi[n],0)] ^				\
-             it_tab[1][byte(bi[(n + 3) & 3],1)] ^		\
-             it_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
-             it_tab[3][byte(bi[(n + 1) & 3],3)] ^ *(k + n)
+	     it_tab[1][byte(bi[(n + 3) & 3],1)] ^		\
+	     it_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
+	     it_tab[3][byte(bi[(n + 1) & 3],3)] ^ *(k + n)
 
 #define ls_box(x)				\
     ( fl_tab[0][byte(x, 0)] ^			\
@@ -144,15 +144,15 @@ f_mult (u8 a, u8 b)
 
 #define f_rl(bo, bi, n, k)					\
     bo[n] =  fl_tab[0][byte(bi[n],0)] ^				\
-             fl_tab[1][byte(bi[(n + 1) & 3],1)] ^		\
-             fl_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
-             fl_tab[3][byte(bi[(n + 3) & 3],3)] ^ *(k + n)
+	     fl_tab[1][byte(bi[(n + 1) & 3],1)] ^		\
+	     fl_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
+	     fl_tab[3][byte(bi[(n + 3) & 3],3)] ^ *(k + n)
 
 #define i_rl(bo, bi, n, k)					\
     bo[n] =  il_tab[0][byte(bi[n],0)] ^				\
-             il_tab[1][byte(bi[(n + 3) & 3],1)] ^		\
-             il_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
-             il_tab[3][byte(bi[(n + 1) & 3],3)] ^ *(k + n)
+	     il_tab[1][byte(bi[(n + 3) & 3],1)] ^		\
+	     il_tab[2][byte(bi[(n + 2) & 3],2)] ^		\
+	     il_tab[3][byte(bi[(n + 1) & 3],3)] ^ *(k + n)
 
 static void __init
 gen_tabs (void)
@@ -234,8 +234,8 @@ gen_tabs (void)
     t   = w ^ (x);          \
    (y)  = u ^ v ^ w;        \
    (y) ^= rotr(u ^ t,  8) ^ \
-          rotr(v ^ t, 16) ^ \
-          rotr(t,24)
+	  rotr(v ^ t, 16) ^ \
+	  rotr(t,24)
 
 /* initialise the key schedule from the user supplied key */
 
@@ -443,9 +443,9 @@ static struct crypto_alg aes_alg = {
 		.cipher = {
 			.cia_min_keysize	=	AES_MIN_KEY_SIZE,
 			.cia_max_keysize	=	AES_MAX_KEY_SIZE,
-			.cia_setkey	   	= 	aes_set_key,
-			.cia_encrypt	 	=	aes_encrypt,
-			.cia_decrypt	  	=	aes_decrypt
+			.cia_setkey		= 	aes_set_key,
+			.cia_encrypt		=	aes_encrypt,
+			.cia_decrypt		=	aes_decrypt
 		}
 	}
 };
--- a/drivers/staging/rtl8192u/ieee80211/arc4.c
+++ b/drivers/staging/rtl8192u/ieee80211/arc4.c
@@ -79,9 +79,9 @@ static struct crypto_alg arc4_alg = {
 	.cra_u			=	{ .cipher = {
 	.cia_min_keysize	=	ARC4_MIN_KEY_SIZE,
 	.cia_max_keysize	=	ARC4_MAX_KEY_SIZE,
-	.cia_setkey	   	= 	arc4_set_key,
-	.cia_encrypt	 	=	arc4_crypt,
-	.cia_decrypt	  	=	arc4_crypt } }
+	.cia_setkey		= 	arc4_set_key,
+	.cia_encrypt		=	arc4_crypt,
+	.cia_decrypt		=	arc4_crypt } }
 };
 
 static int __init arc4_init(void)
--- a/drivers/staging/rtl8192u/ieee80211/cipher.c
+++ b/drivers/staging/rtl8192u/ieee80211/cipher.c
@@ -23,7 +23,7 @@
 
 typedef void (cryptfn_t)(void *, u8 *, const u8 *);
 typedef void (procfn_t)(struct crypto_tfm *, u8 *,
-                        u8*, cryptfn_t, int enc, void *, int);
+			u8*, cryptfn_t, int enc, void *, int);
 
 static inline void xor_64(u8 *a, const u8 *b)
 {
@@ -48,8 +48,8 @@ static inline void xor_128(u8 *a, const 
 static int crypt(struct crypto_tfm *tfm,
 		 struct scatterlist *dst,
 		 struct scatterlist *src,
-                 unsigned int nbytes, cryptfn_t crfn,
-                 procfn_t prfn, int enc, void *info)
+		 unsigned int nbytes, cryptfn_t crfn,
+		 procfn_t prfn, int enc, void *info)
 {
 	struct scatter_walk walk_in, walk_out;
 	const unsigned int bsize = crypto_tfm_alg_blocksize(tfm);
@@ -136,80 +136,80 @@ static int setkey(struct crypto_tfm *tfm
 		return -EINVAL;
 	} else
 		return cia->cia_setkey(crypto_tfm_ctx(tfm), key, keylen,
-		                       &tfm->crt_flags);
+				       &tfm->crt_flags);
 }
 
 static int ecb_encrypt(struct crypto_tfm *tfm,
 		       struct scatterlist *dst,
-                       struct scatterlist *src, unsigned int nbytes)
+		       struct scatterlist *src, unsigned int nbytes)
 {
 	return crypt(tfm, dst, src, nbytes,
-	             tfm->__crt_alg->cra_cipher.cia_encrypt,
-	             ecb_process, 1, NULL);
+		     tfm->__crt_alg->cra_cipher.cia_encrypt,
+		     ecb_process, 1, NULL);
 }
 
 static int ecb_decrypt(struct crypto_tfm *tfm,
-                       struct scatterlist *dst,
-                       struct scatterlist *src,
+		       struct scatterlist *dst,
+		       struct scatterlist *src,
 		       unsigned int nbytes)
 {
 	return crypt(tfm, dst, src, nbytes,
-	             tfm->__crt_alg->cra_cipher.cia_decrypt,
-	             ecb_process, 1, NULL);
+		     tfm->__crt_alg->cra_cipher.cia_decrypt,
+		     ecb_process, 1, NULL);
 }
 
 static int cbc_encrypt(struct crypto_tfm *tfm,
-                       struct scatterlist *dst,
-                       struct scatterlist *src,
+		       struct scatterlist *dst,
+		       struct scatterlist *src,
 		       unsigned int nbytes)
 {
 	return crypt(tfm, dst, src, nbytes,
-	             tfm->__crt_alg->cra_cipher.cia_encrypt,
-	             cbc_process, 1, tfm->crt_cipher.cit_iv);
+		     tfm->__crt_alg->cra_cipher.cia_encrypt,
+		     cbc_process, 1, tfm->crt_cipher.cit_iv);
 }
 
 static int cbc_encrypt_iv(struct crypto_tfm *tfm,
-                          struct scatterlist *dst,
-                          struct scatterlist *src,
-                          unsigned int nbytes, u8 *iv)
+			  struct scatterlist *dst,
+			  struct scatterlist *src,
+			  unsigned int nbytes, u8 *iv)
 {
 	return crypt(tfm, dst, src, nbytes,
-	             tfm->__crt_alg->cra_cipher.cia_encrypt,
-	             cbc_process, 1, iv);
+		     tfm->__crt_alg->cra_cipher.cia_encrypt,
+		     cbc_process, 1, iv);
 }
 
 static int cbc_decrypt(struct crypto_tfm *tfm,
-                       struct scatterlist *dst,
-                       struct scatterlist *src,
+		       struct scatterlist *dst,
+		       struct scatterlist *src,
 		       unsigned int nbytes)
 {
 	return crypt(tfm, dst, src, nbytes,
-	             tfm->__crt_alg->cra_cipher.cia_decrypt,
-	             cbc_process, 0, tfm->crt_cipher.cit_iv);
+		     tfm->__crt_alg->cra_cipher.cia_decrypt,
+		     cbc_process, 0, tfm->crt_cipher.cit_iv);
 }
 
 static int cbc_decrypt_iv(struct crypto_tfm *tfm,
-                          struct scatterlist *dst,
-                          struct scatterlist *src,
-                          unsigned int nbytes, u8 *iv)
+			  struct scatterlist *dst,
+			  struct scatterlist *src,
+			  unsigned int nbytes, u8 *iv)
 {
 	return crypt(tfm, dst, src, nbytes,
-	             tfm->__crt_alg->cra_cipher.cia_decrypt,
-	             cbc_process, 0, iv);
+		     tfm->__crt_alg->cra_cipher.cia_decrypt,
+		     cbc_process, 0, iv);
 }
 
 static int nocrypt(struct crypto_tfm *tfm,
-                   struct scatterlist *dst,
-                   struct scatterlist *src,
+		   struct scatterlist *dst,
+		   struct scatterlist *src,
 		   unsigned int nbytes)
 {
 	return -ENOSYS;
 }
 
 static int nocrypt_iv(struct crypto_tfm *tfm,
-                      struct scatterlist *dst,
-                      struct scatterlist *src,
-                      unsigned int nbytes, u8 *iv)
+		      struct scatterlist *dst,
+		      struct scatterlist *src,
+		      unsigned int nbytes, u8 *iv)
 {
 	return -ENOSYS;
 }
@@ -265,25 +265,25 @@ int crypto_init_cipher_ops(struct crypto
 
 	if (ops->cit_mode == CRYPTO_TFM_MODE_CBC) {
 
-	    	switch (crypto_tfm_alg_blocksize(tfm)) {
-	    	case 8:
-	    		ops->cit_xor_block = xor_64;
-	    		break;
-
-	    	case 16:
-	    		ops->cit_xor_block = xor_128;
-	    		break;
-
-	    	default:
-	    		printk(KERN_WARNING "%s: block size %u not supported\n",
-	    		       crypto_tfm_alg_name(tfm),
-	    		       crypto_tfm_alg_blocksize(tfm));
-	    		ret = -EINVAL;
-	    		goto out;
-	    	}
+		switch (crypto_tfm_alg_blocksize(tfm)) {
+		case 8:
+			ops->cit_xor_block = xor_64;
+			break;
+
+		case 16:
+			ops->cit_xor_block = xor_128;
+			break;
+
+		default:
+			printk(KERN_WARNING "%s: block size %u not supported\n",
+			       crypto_tfm_alg_name(tfm),
+			       crypto_tfm_alg_blocksize(tfm));
+			ret = -EINVAL;
+			goto out;
+		}
 
 		ops->cit_ivsize = crypto_tfm_alg_blocksize(tfm);
-	    	ops->cit_iv = kmalloc(ops->cit_ivsize, GFP_KERNEL);
+		ops->cit_iv = kmalloc(ops->cit_ivsize, GFP_KERNEL);
 		if (ops->cit_iv == NULL)
 			ret = -ENOMEM;
 	}
--- a/drivers/staging/rtl8192u/ieee80211/compress.c
+++ b/drivers/staging/rtl8192u/ieee80211/compress.c
@@ -20,21 +20,21 @@
 #include "internal.h"
 
 static int crypto_compress(struct crypto_tfm *tfm,
-                            const u8 *src, unsigned int slen,
-                            u8 *dst, unsigned int *dlen)
+			    const u8 *src, unsigned int slen,
+			    u8 *dst, unsigned int *dlen)
 {
 	return tfm->__crt_alg->cra_compress.coa_compress(crypto_tfm_ctx(tfm),
-	                                                 src, slen, dst,
-	                                                 dlen);
+							 src, slen, dst,
+							 dlen);
 }
 
 static int crypto_decompress(struct crypto_tfm *tfm,
-                             const u8 *src, unsigned int slen,
-                             u8 *dst, unsigned int *dlen)
+			     const u8 *src, unsigned int slen,
+			     u8 *dst, unsigned int *dlen)
 {
 	return tfm->__crt_alg->cra_compress.coa_decompress(crypto_tfm_ctx(tfm),
-	                                                   src, slen, dst,
-	                                                   dlen);
+							   src, slen, dst,
+							   dlen);
 }
 
 int crypto_init_compress_flags(struct crypto_tfm *tfm, u32 flags)
--- a/drivers/staging/rtl8192u/ieee80211/crypto_compat.h
+++ b/drivers/staging/rtl8192u/ieee80211/crypto_compat.h
@@ -12,9 +12,9 @@
 #include <linux/crypto.h>
 
 static inline int crypto_cipher_encrypt(struct crypto_tfm *tfm,
-                                        struct scatterlist *dst,
-                                        struct scatterlist *src,
-                                        unsigned int nbytes)
+					struct scatterlist *dst,
+					struct scatterlist *src,
+					unsigned int nbytes)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 	return tfm->crt_cipher.cit_encrypt(tfm, dst, src, nbytes);
@@ -22,9 +22,9 @@ static inline int crypto_cipher_encrypt(
 
 
 static inline int crypto_cipher_decrypt(struct crypto_tfm *tfm,
-                                        struct scatterlist *dst,
-                                        struct scatterlist *src,
-                                        unsigned int nbytes)
+					struct scatterlist *dst,
+					struct scatterlist *src,
+					unsigned int nbytes)
 {
 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 	return tfm->crt_cipher.cit_decrypt(tfm, dst, src, nbytes);
--- a/drivers/staging/rtl8192u/ieee80211/digest.c
+++ b/drivers/staging/rtl8192u/ieee80211/digest.c
@@ -25,7 +25,7 @@ static void init(struct crypto_tfm *tfm)
 }
 
 static void update(struct crypto_tfm *tfm,
-                   struct scatterlist *sg, unsigned int nsg)
+		   struct scatterlist *sg, unsigned int nsg)
 {
 	unsigned int i;
 
@@ -68,7 +68,7 @@ static int setkey(struct crypto_tfm *tfm
 }
 
 static void digest(struct crypto_tfm *tfm,
-                   struct scatterlist *sg, unsigned int nsg, u8 *out)
+		   struct scatterlist *sg, unsigned int nsg, u8 *out)
 {
 	unsigned int i;
 
@@ -77,7 +77,7 @@ static void digest(struct crypto_tfm *tf
 	for (i = 0; i < nsg; i++) {
 		char *p = crypto_kmap(sg[i].page, 0) + sg[i].offset;
 		tfm->__crt_alg->cra_digest.dia_update(crypto_tfm_ctx(tfm),
-		                                      p, sg[i].length);
+						      p, sg[i].length);
 		crypto_kunmap(p, 0);
 		crypto_yield(tfm);
 	}
--- a/drivers/staging/rtl8192u/ieee80211.h
+++ b/drivers/staging/rtl8192u/ieee80211.h
@@ -86,8 +86,8 @@ struct iw_spy_data{
  *
  */
 #define container_of(ptr, type, member) ({                      \
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
-        (type *)( (char *)__mptr - offsetof(type,member) );})
+	const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
+	(type *)( (char *)__mptr - offsetof(type,member) );})
 #endif
 
 #define KEY_TYPE_NA		0x0
@@ -125,61 +125,61 @@ struct iw_spy_data{
 /* defined for skb cb field */
 /* At most 28 byte */
 typedef struct cb_desc {
-        /* Tx Desc Related flags (8-9) */
+	/* Tx Desc Related flags (8-9) */
 	u8 bLastIniPkt:1;
 	u8 bCmdOrInit:1;
-        u8 bFirstSeg:1;
-        u8 bLastSeg:1;
-        u8 bEncrypt:1;
-        u8 bTxDisableRateFallBack:1;
-        u8 bTxUseDriverAssingedRate:1;
-        u8 bHwSec:1; //indicate whether use Hw security. WB
-
-        u8 reserved1;
-
-        /* Tx Firmware Relaged flags (10-11)*/
-        u8 bCTSEnable:1;
-        u8 bRTSEnable:1;
-        u8 bUseShortGI:1;
-        u8 bUseShortPreamble:1;
-        u8 bTxEnableFwCalcDur:1;
-        u8 bAMPDUEnable:1;
-        u8 bRTSSTBC:1;
-        u8 RTSSC:1;
+	u8 bFirstSeg:1;
+	u8 bLastSeg:1;
+	u8 bEncrypt:1;
+	u8 bTxDisableRateFallBack:1;
+	u8 bTxUseDriverAssingedRate:1;
+	u8 bHwSec:1; //indicate whether use Hw security. WB
+
+	u8 reserved1;
+
+	/* Tx Firmware Relaged flags (10-11)*/
+	u8 bCTSEnable:1;
+	u8 bRTSEnable:1;
+	u8 bUseShortGI:1;
+	u8 bUseShortPreamble:1;
+	u8 bTxEnableFwCalcDur:1;
+	u8 bAMPDUEnable:1;
+	u8 bRTSSTBC:1;
+	u8 RTSSC:1;
 
-        u8 bRTSBW:1;
-        u8 bPacketBW:1;
+	u8 bRTSBW:1;
+	u8 bPacketBW:1;
 	u8 bRTSUseShortPreamble:1;
 	u8 bRTSUseShortGI:1;
 	u8 bMulticast:1;
 	u8 bBroadcast:1;
-        //u8 reserved2:2;
-        u8 drv_agg_enable:1;
-        u8 reserved2:1;
-
-        /* Tx Desc related element(12-19) */
-        u8 rata_index;
-        u8 queue_index;
-        //u8 reserved3;
-        //u8 reserved4;
-        u16 txbuf_size;
-        //u8 reserved5;
+	//u8 reserved2:2;
+	u8 drv_agg_enable:1;
+	u8 reserved2:1;
+
+	/* Tx Desc related element(12-19) */
+	u8 rata_index;
+	u8 queue_index;
+	//u8 reserved3;
+	//u8 reserved4;
+	u16 txbuf_size;
+	//u8 reserved5;
 	u8 RATRIndex;
-        u8 reserved6;
-        u8 reserved7;
-        u8 reserved8;
-
-        /* Tx firmware related element(20-27) */
-        u8 data_rate;
-        u8 rts_rate;
-        u8 ampdu_factor;
-        u8 ampdu_density;
-        //u8 reserved9;
-        //u8 reserved10;
-        //u8 reserved11;
-        u8 DrvAggrNum;
+	u8 reserved6;
+	u8 reserved7;
+	u8 reserved8;
+
+	/* Tx firmware related element(20-27) */
+	u8 data_rate;
+	u8 rts_rate;
+	u8 ampdu_factor;
+	u8 ampdu_density;
+	//u8 reserved9;
+	//u8 reserved10;
+	//u8 reserved11;
+	u8 DrvAggrNum;
 	u16 pkt_size;
-        u8 reserved12;
+	u8 reserved12;
 }cb_desc, *pcb_desc;
 
 /*--------------------------Define -------------------------------------------*/
@@ -389,7 +389,7 @@ enum	_ReasonCode{
 typedef struct ieee_param {
 	u32 cmd;
 	u8 sta_addr[ETH_ALEN];
-        union {
+	union {
 		struct {
 			u8 name;
 			u32 value;
@@ -399,9 +399,9 @@ typedef struct ieee_param {
 			u8 reserved[32];
 			u8 data[0];
 		} wpa_ie;
-	        struct{
+		struct{
 			int command;
-    			int reason_code;
+			int reason_code;
 		} mlme;
 		struct {
 			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
@@ -442,23 +442,23 @@ static inline void tq_init(struct tq_str
 #define MSECS(t)	(HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
 static inline unsigned long msleep_interruptible_rsl(unsigned int msecs)
 {
-         unsigned long timeout = MSECS(msecs) + 1;
+	 unsigned long timeout = MSECS(msecs) + 1;
 
-         while (timeout) {
-                 set_current_state(TASK_INTERRUPTIBLE);
-                 timeout = schedule_timeout(timeout);
-         }
-         return timeout;
+	 while (timeout) {
+		 set_current_state(TASK_INTERRUPTIBLE);
+		 timeout = schedule_timeout(timeout);
+	 }
+	 return timeout;
 }
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,31))
 static inline void msleep(unsigned int msecs)
 {
-         unsigned long timeout = MSECS(msecs) + 1;
+	 unsigned long timeout = MSECS(msecs) + 1;
 
-         while (timeout) {
-                 set_current_state(TASK_UNINTERRUPTIBLE);
-                 timeout = schedule_timeout(timeout);
-         }
+	 while (timeout) {
+		 set_current_state(TASK_UNINTERRUPTIBLE);
+		 timeout = schedule_timeout(timeout);
+	 }
 }
 #endif
 #else
@@ -559,24 +559,24 @@ static inline void msleep(unsigned int m
 #define SN_EQUAL(a, b)	(a == b)
 #define MAX_DEV_ADDR_SIZE 8
 typedef enum _ACT_CATEGORY{
-        ACT_CAT_QOS = 1,
-        ACT_CAT_DLS = 2,
-        ACT_CAT_BA  = 3,
-        ACT_CAT_HT  = 7,
-        ACT_CAT_WMM = 17,
+	ACT_CAT_QOS = 1,
+	ACT_CAT_DLS = 2,
+	ACT_CAT_BA  = 3,
+	ACT_CAT_HT  = 7,
+	ACT_CAT_WMM = 17,
 } ACT_CATEGORY, *PACT_CATEGORY;
 
 typedef enum _TS_ACTION{
-        ACT_ADDTSREQ = 0,
-        ACT_ADDTSRSP = 1,
-        ACT_DELTS    = 2,
-        ACT_SCHEDULE = 3,
+	ACT_ADDTSREQ = 0,
+	ACT_ADDTSRSP = 1,
+	ACT_DELTS    = 2,
+	ACT_SCHEDULE = 3,
 } TS_ACTION, *PTS_ACTION;
 
 typedef enum _BA_ACTION{
-        ACT_ADDBAREQ = 0,
-        ACT_ADDBARSP = 1,
-        ACT_DELBA    = 2,
+	ACT_ADDBAREQ = 0,
+	ACT_ADDBARSP = 1,
+	ACT_DELBA    = 2,
 } BA_ACTION, *PBA_ACTION;
 
 typedef enum _InitialGainOpType{
@@ -687,22 +687,22 @@ do { if (ieee80211_debug_level & (level)
 /* I want to see ASCII 33 to 126 only. Otherwise, I print '?'. Annie, 2005-11-22.*/
 #define PRINTABLE(_ch)  (_ch>'!' && _ch<'~')
 #define IEEE80211_PRINT_STR(_Comp, _TitleString, _Ptr, _Len)                            	\
-                        if((_Comp) & level)   							\
-                        {                                                                       \
-                                int             __i;                                            \
-                                u8  buffer[MAX_STR_LEN];                                    	\
-                                int length = (_Len<MAX_STR_LEN)? _Len : (MAX_STR_LEN-1) ;  	\
-                                memset(buffer, 0, MAX_STR_LEN);                      		\
-                                memcpy(buffer, (u8 *)_Ptr, length );            		\
-                                for( __i=0; __i<MAX_STR_LEN; __i++ )                            \
-                                {                                                               \
-                                     if( !PRINTABLE(buffer[__i]) )   buffer[__i] = '?';     	\
-                                }                                                               \
-                                buffer[length] = '\0';                                          \
-                                printk("Rtl819x: ");                                         	\
-                                printk(_TitleString);                                         \
-                                printk(": %d, <%s>\n", _Len, buffer);                         \
-                        }
+			if((_Comp) & level)   							\
+			{                                                                       \
+				int             __i;                                            \
+				u8  buffer[MAX_STR_LEN];                                    	\
+				int length = (_Len<MAX_STR_LEN)? _Len : (MAX_STR_LEN-1) ;  	\
+				memset(buffer, 0, MAX_STR_LEN);                      		\
+				memcpy(buffer, (u8 *)_Ptr, length );            		\
+				for( __i=0; __i<MAX_STR_LEN; __i++ )                            \
+				{                                                               \
+				     if( !PRINTABLE(buffer[__i]) )   buffer[__i] = '?';     	\
+				}                                                               \
+				buffer[length] = '\0';                                          \
+				printk("Rtl819x: ");                                         	\
+				printk(_TitleString);                                         \
+				printk(": %d, <%s>\n", _Len, buffer);                         \
+			}
 #else
 #define IEEE80211_PRINT_STR(_Comp, _TitleString, _Ptr, _Len)  do {} while (0)
 #endif
@@ -731,10 +731,10 @@ do { if (ieee80211_debug_level & (level)
 
 struct ieee80211_snap_hdr {
 
-        u8    dsap;   /* always 0xAA */
-        u8    ssap;   /* always 0xAA */
-        u8    ctrl;   /* always 0x03 */
-        u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+	u8    dsap;   /* always 0xAA */
+	u8    ssap;   /* always 0xAA */
+	u8    ctrl;   /* always 0x03 */
+	u8    oui[P80211_OUI_LEN];    /* organizational universal id */
 
 } __attribute__ ((packed));
 
@@ -775,65 +775,65 @@ struct ieee80211_snap_hdr {
 
 /* Status codes */
 enum ieee80211_statuscode {
-        WLAN_STATUS_SUCCESS = 0,
-        WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
-        WLAN_STATUS_CAPS_UNSUPPORTED = 10,
-        WLAN_STATUS_REASSOC_NO_ASSOC = 11,
-        WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
-        WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
-        WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
-        WLAN_STATUS_CHALLENGE_FAIL = 15,
-        WLAN_STATUS_AUTH_TIMEOUT = 16,
-        WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
-        WLAN_STATUS_ASSOC_DENIED_RATES = 18,
-        /* 802.11b */
-        WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
-        WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
-        WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
-        /* 802.11h */
-        WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
-        WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
-        WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
-        /* 802.11g */
-        WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
-        WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
-        /* 802.11i */
-        WLAN_STATUS_INVALID_IE = 40,
-        WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
-        WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
-        WLAN_STATUS_INVALID_AKMP = 43,
-        WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
-        WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
-        WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
+	WLAN_STATUS_SUCCESS = 0,
+	WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
+	WLAN_STATUS_CAPS_UNSUPPORTED = 10,
+	WLAN_STATUS_REASSOC_NO_ASSOC = 11,
+	WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
+	WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
+	WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
+	WLAN_STATUS_CHALLENGE_FAIL = 15,
+	WLAN_STATUS_AUTH_TIMEOUT = 16,
+	WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
+	WLAN_STATUS_ASSOC_DENIED_RATES = 18,
+	/* 802.11b */
+	WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
+	WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
+	WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
+	/* 802.11h */
+	WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
+	WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
+	WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
+	/* 802.11g */
+	WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
+	WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
+	/* 802.11i */
+	WLAN_STATUS_INVALID_IE = 40,
+	WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
+	WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
+	WLAN_STATUS_INVALID_AKMP = 43,
+	WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
+	WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
+	WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
 };
 
 /* Reason codes */
 enum ieee80211_reasoncode {
-        WLAN_REASON_UNSPECIFIED = 1,
-        WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
-        WLAN_REASON_DEAUTH_LEAVING = 3,
-        WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
-        WLAN_REASON_DISASSOC_AP_BUSY = 5,
-        WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
-        WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
-        WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
-        WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
-        /* 802.11h */
-        WLAN_REASON_DISASSOC_BAD_POWER = 10,
-        WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
-        /* 802.11i */
-        WLAN_REASON_INVALID_IE = 13,
-        WLAN_REASON_MIC_FAILURE = 14,
-        WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
-        WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
-        WLAN_REASON_IE_DIFFERENT = 17,
-        WLAN_REASON_INVALID_GROUP_CIPHER = 18,
-        WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
-        WLAN_REASON_INVALID_AKMP = 20,
-        WLAN_REASON_UNSUPP_RSN_VERSION = 21,
-        WLAN_REASON_INVALID_RSN_IE_CAP = 22,
-        WLAN_REASON_IEEE8021X_FAILED = 23,
-        WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
+	WLAN_REASON_UNSPECIFIED = 1,
+	WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
+	WLAN_REASON_DEAUTH_LEAVING = 3,
+	WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
+	WLAN_REASON_DISASSOC_AP_BUSY = 5,
+	WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
+	WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
+	WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
+	WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
+	/* 802.11h */
+	WLAN_REASON_DISASSOC_BAD_POWER = 10,
+	WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
+	/* 802.11i */
+	WLAN_REASON_INVALID_IE = 13,
+	WLAN_REASON_MIC_FAILURE = 14,
+	WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
+	WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
+	WLAN_REASON_IE_DIFFERENT = 17,
+	WLAN_REASON_INVALID_GROUP_CIPHER = 18,
+	WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
+	WLAN_REASON_INVALID_AKMP = 20,
+	WLAN_REASON_UNSUPP_RSN_VERSION = 21,
+	WLAN_REASON_INVALID_RSN_IE_CAP = 22,
+	WLAN_REASON_IEEE8021X_FAILED = 23,
+	WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
 };
 
 #define IEEE80211_STATMASK_SIGNAL (1<<0)
@@ -849,13 +849,13 @@ enum ieee80211_reasoncode {
 #define IEEE80211_52GHZ_BAND     (1<<1)
 
 #define IEEE80211_CCK_RATE_LEN  		4
-#define IEEE80211_CCK_RATE_1MB		        0x02
-#define IEEE80211_CCK_RATE_2MB		        0x04
-#define IEEE80211_CCK_RATE_5MB		        0x0B
-#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_CCK_RATE_1MB			0x02
+#define IEEE80211_CCK_RATE_2MB			0x04
+#define IEEE80211_CCK_RATE_5MB			0x0B
+#define IEEE80211_CCK_RATE_11MB			0x16
 #define IEEE80211_OFDM_RATE_LEN 		8
-#define IEEE80211_OFDM_RATE_6MB		        0x0C
-#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_6MB			0x0C
+#define IEEE80211_OFDM_RATE_9MB			0x12
 #define IEEE80211_OFDM_RATE_12MB		0x18
 #define IEEE80211_OFDM_RATE_18MB		0x24
 #define IEEE80211_OFDM_RATE_24MB		0x30
@@ -877,12 +877,12 @@ enum ieee80211_reasoncode {
 #define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
 #define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
 
-#define IEEE80211_CCK_RATES_MASK	        0x0000000F
+#define IEEE80211_CCK_RATES_MASK		0x0000000F
 #define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
 	IEEE80211_CCK_RATE_2MB_MASK)
 #define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
-        IEEE80211_CCK_RATE_5MB_MASK | \
-        IEEE80211_CCK_RATE_11MB_MASK)
+	IEEE80211_CCK_RATE_5MB_MASK | \
+	IEEE80211_CCK_RATE_11MB_MASK)
 
 #define IEEE80211_OFDM_RATES_MASK		0x00000FF0
 #define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
@@ -895,10 +895,10 @@ enum ieee80211_reasoncode {
 	IEEE80211_OFDM_RATE_48MB_MASK | \
 	IEEE80211_OFDM_RATE_54MB_MASK)
 #define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
-                                IEEE80211_CCK_DEFAULT_RATES_MASK)
+				IEEE80211_CCK_DEFAULT_RATES_MASK)
 
 #define IEEE80211_NUM_OFDM_RATES	    8
-#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_NUM_CCK_RATES		    4
 #define IEEE80211_OFDM_SHIFT_MASK_A         4
 
 
@@ -1064,10 +1064,10 @@ struct ieee80211_device;
 
 struct ieee80211_security {
 	u16 active_key:2,
-            enabled:1,
+	    enabled:1,
 	    auth_mode:2,
-            auth_algo:4,
-            unicast_uses_group:1,
+	    auth_algo:4,
+	    unicast_uses_group:1,
 	    encrypt:1;
 	u8 key_sizes[WEP_KEYS];
 	u8 keys[WEP_KEYS][SCM_KEY_LEN];
@@ -1089,60 +1089,60 @@ Total: 28-2340 bytes
 
 /* Management Frame Information Element Types */
 enum ieee80211_mfie {
-        MFIE_TYPE_SSID = 0,
-        MFIE_TYPE_RATES = 1,
-        MFIE_TYPE_FH_SET = 2,
-        MFIE_TYPE_DS_SET = 3,
-        MFIE_TYPE_CF_SET = 4,
-        MFIE_TYPE_TIM = 5,
-        MFIE_TYPE_IBSS_SET = 6,
-        MFIE_TYPE_COUNTRY = 7,
-        MFIE_TYPE_HOP_PARAMS = 8,
-        MFIE_TYPE_HOP_TABLE = 9,
-        MFIE_TYPE_REQUEST = 10,
-        MFIE_TYPE_CHALLENGE = 16,
-        MFIE_TYPE_POWER_CONSTRAINT = 32,
-        MFIE_TYPE_POWER_CAPABILITY = 33,
-        MFIE_TYPE_TPC_REQUEST = 34,
-        MFIE_TYPE_TPC_REPORT = 35,
-        MFIE_TYPE_SUPP_CHANNELS = 36,
-        MFIE_TYPE_CSA = 37,
-        MFIE_TYPE_MEASURE_REQUEST = 38,
-        MFIE_TYPE_MEASURE_REPORT = 39,
-        MFIE_TYPE_QUIET = 40,
-        MFIE_TYPE_IBSS_DFS = 41,
-        MFIE_TYPE_ERP = 42,
-        MFIE_TYPE_RSN = 48,
-        MFIE_TYPE_RATES_EX = 50,
-        MFIE_TYPE_HT_CAP= 45,
+	MFIE_TYPE_SSID = 0,
+	MFIE_TYPE_RATES = 1,
+	MFIE_TYPE_FH_SET = 2,
+	MFIE_TYPE_DS_SET = 3,
+	MFIE_TYPE_CF_SET = 4,
+	MFIE_TYPE_TIM = 5,
+	MFIE_TYPE_IBSS_SET = 6,
+	MFIE_TYPE_COUNTRY = 7,
+	MFIE_TYPE_HOP_PARAMS = 8,
+	MFIE_TYPE_HOP_TABLE = 9,
+	MFIE_TYPE_REQUEST = 10,
+	MFIE_TYPE_CHALLENGE = 16,
+	MFIE_TYPE_POWER_CONSTRAINT = 32,
+	MFIE_TYPE_POWER_CAPABILITY = 33,
+	MFIE_TYPE_TPC_REQUEST = 34,
+	MFIE_TYPE_TPC_REPORT = 35,
+	MFIE_TYPE_SUPP_CHANNELS = 36,
+	MFIE_TYPE_CSA = 37,
+	MFIE_TYPE_MEASURE_REQUEST = 38,
+	MFIE_TYPE_MEASURE_REPORT = 39,
+	MFIE_TYPE_QUIET = 40,
+	MFIE_TYPE_IBSS_DFS = 41,
+	MFIE_TYPE_ERP = 42,
+	MFIE_TYPE_RSN = 48,
+	MFIE_TYPE_RATES_EX = 50,
+	MFIE_TYPE_HT_CAP= 45,
 	 MFIE_TYPE_HT_INFO= 61,
 	 MFIE_TYPE_AIRONET=133,
-        MFIE_TYPE_GENERIC = 221,
-        MFIE_TYPE_QOS_PARAMETER = 222,
+	MFIE_TYPE_GENERIC = 221,
+	MFIE_TYPE_QOS_PARAMETER = 222,
 };
 
 /* Minimal header; can be used for passing 802.11 frames with sufficient
  * information to determine what type of underlying data type is actually
  * stored in the data. */
 struct ieee80211_hdr {
-        __le16 frame_ctl;
-        __le16 duration_id;
-        u8 payload[0];
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 payload[0];
 } __attribute__ ((packed));
 
 struct ieee80211_hdr_1addr {
-        __le16 frame_ctl;
-        __le16 duration_id;
-        u8 addr1[ETH_ALEN];
-        u8 payload[0];
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 payload[0];
 } __attribute__ ((packed));
 
 struct ieee80211_hdr_2addr {
-        __le16 frame_ctl;
-        __le16 duration_id;
-        u8 addr1[ETH_ALEN];
-        u8 addr2[ETH_ALEN];
-        u8 payload[0];
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 payload[0];
 } __attribute__ ((packed));
 
 struct ieee80211_hdr_3addr {
@@ -1152,7 +1152,7 @@ struct ieee80211_hdr_3addr {
 	u8 addr2[ETH_ALEN];
 	u8 addr3[ETH_ALEN];
 	__le16 seq_ctl;
-        u8 payload[0];
+	u8 payload[0];
 } __attribute__ ((packed));
 
 struct ieee80211_hdr_4addr {
@@ -1163,7 +1163,7 @@ struct ieee80211_hdr_4addr {
 	u8 addr3[ETH_ALEN];
 	__le16 seq_ctl;
 	u8 addr4[ETH_ALEN];
-        u8 payload[0];
+	u8 payload[0];
 } __attribute__ ((packed));
 
 struct ieee80211_hdr_3addrqos {
@@ -1173,7 +1173,7 @@ struct ieee80211_hdr_3addrqos {
 	u8 addr2[ETH_ALEN];
 	u8 addr3[ETH_ALEN];
 	__le16 seq_ctl;
-        u8 payload[0];
+	u8 payload[0];
 	__le16 qos_ctl;
 } __attribute__ ((packed));
 
@@ -1185,7 +1185,7 @@ struct ieee80211_hdr_4addrqos {
 	u8 addr3[ETH_ALEN];
 	__le16 seq_ctl;
 	u8 addr4[ETH_ALEN];
-        u8 payload[0];
+	u8 payload[0];
 	__le16 qos_ctl;
 } __attribute__ ((packed));
 
@@ -1205,14 +1205,14 @@ struct ieee80211_authentication {
 } __attribute__ ((packed));
 
 struct ieee80211_disassoc {
-        struct ieee80211_hdr_3addr header;
-        __le16 reason;
+	struct ieee80211_hdr_3addr header;
+	__le16 reason;
 } __attribute__ ((packed));
 
 struct ieee80211_probe_request {
 	struct ieee80211_hdr_3addr header;
 	/* SSID, supported rates */
-        struct ieee80211_info_element info_element[0];
+	struct ieee80211_info_element info_element[0];
 } __attribute__ ((packed));
 
 struct ieee80211_probe_response {
@@ -1220,9 +1220,9 @@ struct ieee80211_probe_response {
 	u32 time_stamp[2];
 	__le16 beacon_interval;
 	__le16 capability;
-        /* SSID, supported rates, FH params, DS params,
-         * CF params, IBSS params, TIM (if beacon), RSN */
-        struct ieee80211_info_element info_element[0];
+	/* SSID, supported rates, FH params, DS params,
+	 * CF params, IBSS params, TIM (if beacon), RSN */
+	struct ieee80211_info_element info_element[0];
 } __attribute__ ((packed));
 
 /* Alias beacon for probe_response */
@@ -1233,7 +1233,7 @@ struct ieee80211_assoc_request_frame {
 	__le16 capability;
 	__le16 listen_interval;
 	/* SSID, supported rates, RSN */
-        struct ieee80211_info_element info_element[0];
+	struct ieee80211_info_element info_element[0];
 } __attribute__ ((packed));
 
 struct ieee80211_reassoc_request_frame {
@@ -1242,7 +1242,7 @@ struct ieee80211_reassoc_request_frame {
 	__le16 listen_interval;
 	u8 current_ap[ETH_ALEN];
 	/* SSID, supported rates, RSN */
-        struct ieee80211_info_element info_element[0];
+	struct ieee80211_info_element info_element[0];
 } __attribute__ ((packed));
 
 struct ieee80211_assoc_response_frame {
@@ -1318,7 +1318,7 @@ typedef union _frameqos {
 #define NETWORK_HAS_QOS_PARAMETERS      (1<<3)
 #define NETWORK_HAS_QOS_INFORMATION     (1<<4)
 #define NETWORK_HAS_QOS_MASK            (NETWORK_HAS_QOS_PARAMETERS | \
-                                         NETWORK_HAS_QOS_INFORMATION)
+					 NETWORK_HAS_QOS_INFORMATION)
 /* 802.11h */
 #define NETWORK_HAS_POWER_CONSTRAINT    (1<<5)
 #define NETWORK_HAS_CSA                 (1<<6)
@@ -1338,46 +1338,46 @@ typedef union _frameqos {
 #define QOS_AIFSN_MIN_VALUE             2
 #if 1
 struct ieee80211_qos_information_element {
-        u8 elementID;
-        u8 length;
-        u8 qui[QOS_OUI_LEN];
-        u8 qui_type;
-        u8 qui_subtype;
-        u8 version;
-        u8 ac_info;
+	u8 elementID;
+	u8 length;
+	u8 qui[QOS_OUI_LEN];
+	u8 qui_type;
+	u8 qui_subtype;
+	u8 version;
+	u8 ac_info;
 } __attribute__ ((packed));
 
 struct ieee80211_qos_ac_parameter {
-        u8 aci_aifsn;
-        u8 ecw_min_max;
-        __le16 tx_op_limit;
+	u8 aci_aifsn;
+	u8 ecw_min_max;
+	__le16 tx_op_limit;
 } __attribute__ ((packed));
 
 struct ieee80211_qos_parameter_info {
-        struct ieee80211_qos_information_element info_element;
-        u8 reserved;
-        struct ieee80211_qos_ac_parameter ac_params_record[QOS_QUEUE_NUM];
+	struct ieee80211_qos_information_element info_element;
+	u8 reserved;
+	struct ieee80211_qos_ac_parameter ac_params_record[QOS_QUEUE_NUM];
 } __attribute__ ((packed));
 
 struct ieee80211_qos_parameters {
-        __le16 cw_min[QOS_QUEUE_NUM];
-        __le16 cw_max[QOS_QUEUE_NUM];
-        u8 aifs[QOS_QUEUE_NUM];
-        u8 flag[QOS_QUEUE_NUM];
-        __le16 tx_op_limit[QOS_QUEUE_NUM];
+	__le16 cw_min[QOS_QUEUE_NUM];
+	__le16 cw_max[QOS_QUEUE_NUM];
+	u8 aifs[QOS_QUEUE_NUM];
+	u8 flag[QOS_QUEUE_NUM];
+	__le16 tx_op_limit[QOS_QUEUE_NUM];
 } __attribute__ ((packed));
 
 struct ieee80211_qos_data {
-        struct ieee80211_qos_parameters parameters;
-        int active;
-        int supported;
-        u8 param_count;
-        u8 old_param_count;
+	struct ieee80211_qos_parameters parameters;
+	int active;
+	int supported;
+	u8 param_count;
+	u8 old_param_count;
 };
 
 struct ieee80211_tim_parameters {
-        u8 tim_count;
-        u8 tim_period;
+	u8 tim_count;
+	u8 tim_period;
 } __attribute__ ((packed));
 
 //#else
@@ -1598,10 +1598,10 @@ struct ieee80211_network {
 	u8 ssid[IW_ESSID_MAX_SIZE + 1];
 	u8 ssid_len;
 #if 1
-        struct ieee80211_qos_data qos_data;
+	struct ieee80211_qos_data qos_data;
 #else
        // Qos related. Added by Annie, 2005-11-01.
-        BSS_QOS   BssQos;
+	BSS_QOS   BssQos;
 #endif
 	//added by amy for LEAP
 	bool	bWithAironetIE;
@@ -1636,15 +1636,15 @@ struct ieee80211_network {
 	u8  rsn_ie[MAX_WPA_IE_LEN];
 	size_t rsn_ie_len;
 
-        struct ieee80211_tim_parameters tim;
+	struct ieee80211_tim_parameters tim;
 	u8  dtim_period;
 	u8  dtim_data;
 	u32 last_dtim_sta_time[2];
 
-        //appeded for QoS
-        u8 wmm_info;
-        struct ieee80211_wmm_ac_param wmm_param[4];
-        u8 QoS_Enable;
+	//appeded for QoS
+	u8 wmm_info;
+	struct ieee80211_wmm_ac_param wmm_param[4];
+	u8 QoS_Enable;
 #ifdef THOMAS_TURBO
 	u8 Turbo_Enable;//enable turbo mode, added by thomas
 #endif
@@ -1652,7 +1652,7 @@ struct ieee80211_network {
 	u16 CountryIeLen;
 	u8 CountryIeBuf[MAX_IE_LEN];
 #endif
-        // HT Related, by amy, 2008.04.29
+	// HT Related, by amy, 2008.04.29
 	BSS_HT	bssht;
 	// Add to handle broadcom AP management frame CCK rate.
 	bool broadcom_cap_exist;
@@ -1708,13 +1708,13 @@ enum ieee80211_state {
 };
 #else
 enum ieee80211_state {
-        IEEE80211_UNINITIALIZED = 0,
-        IEEE80211_INITIALIZED,
-        IEEE80211_ASSOCIATING,
-        IEEE80211_ASSOCIATED,
-        IEEE80211_AUTHENTICATING,
-        IEEE80211_AUTHENTICATED,
-        IEEE80211_SHUTDOWN
+	IEEE80211_UNINITIALIZED = 0,
+	IEEE80211_INITIALIZED,
+	IEEE80211_ASSOCIATING,
+	IEEE80211_ASSOCIATED,
+	IEEE80211_AUTHENTICATING,
+	IEEE80211_AUTHENTICATED,
+	IEEE80211_SHUTDOWN
 };
 #endif
 
@@ -1728,17 +1728,17 @@ enum ieee80211_state {
 #define IEEE80211_24GHZ_MIN_CHANNEL 1
 #define IEEE80211_24GHZ_MAX_CHANNEL 14
 #define IEEE80211_24GHZ_CHANNELS (IEEE80211_24GHZ_MAX_CHANNEL - \
-                                  IEEE80211_24GHZ_MIN_CHANNEL + 1)
+				  IEEE80211_24GHZ_MIN_CHANNEL + 1)
 
 #define IEEE80211_52GHZ_MIN_CHANNEL 34
 #define IEEE80211_52GHZ_MAX_CHANNEL 165
 #define IEEE80211_52GHZ_CHANNELS (IEEE80211_52GHZ_MAX_CHANNEL - \
-                                  IEEE80211_52GHZ_MIN_CHANNEL + 1)
+				  IEEE80211_52GHZ_MIN_CHANNEL + 1)
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11))
 extern inline int is_multicast_ether_addr(const u8 *addr)
 {
-        return ((addr[0] != 0xff) && (0x01 & addr[0]));
+	return ((addr[0] != 0xff) && (0x01 & addr[0]));
 }
 #endif
 
@@ -1910,7 +1910,7 @@ typedef struct _RT_LINK_DETECT_T{
 
 struct ieee80211_device {
 	struct net_device *dev;
-        struct ieee80211_security sec;
+	struct ieee80211_security sec;
 
 	//hw security related
 //	u8 hwsec_support; //support?
@@ -2000,15 +2000,15 @@ struct ieee80211_device {
 	int host_encrypt;
 	int host_encrypt_msdu;
 	int host_decrypt;
-        /* host performs multicast decryption */
-        int host_mc_decrypt;
+	/* host performs multicast decryption */
+	int host_mc_decrypt;
 
-        /* host should strip IV and ICV from protected frames */
-        /* meaningful only when hardware decryption is being used */
-        int host_strip_iv_icv;
+	/* host should strip IV and ICV from protected frames */
+	/* meaningful only when hardware decryption is being used */
+	int host_strip_iv_icv;
 
-        int host_open_frag;
-        int host_build_iv;
+	int host_open_frag;
+	int host_build_iv;
 	int ieee802_1x; /* is IEEE 802.1X used */
 
 	/* WPA data */
@@ -2026,7 +2026,7 @@ struct ieee80211_device {
 	struct ieee80211_crypt_data *crypt[WEP_KEYS];
 	int tx_keyidx; /* default TX key index (crypt[tx_keyidx]) */
 	struct timer_list crypt_deinit_timer;
-        int crypt_quiesced;
+	int crypt_quiesced;
 
 	int bcrx_sta_key; /* use individual keys to override default keys even
 			   * with RX of broad/multicast frames */
@@ -2039,10 +2039,10 @@ struct ieee80211_device {
 #define DEFAULT_RTS_THRESHOLD 2346U
 #define MIN_RTS_THRESHOLD 1
 #define MAX_RTS_THRESHOLD 2346U
-        u16 rts; /* RTS threshold */
+	u16 rts; /* RTS threshold */
 
-        /* Association info */
-        u8 bssid[ETH_ALEN];
+	/* Association info */
+	u8 bssid[ETH_ALEN];
 
 	/* This stores infos for the current network.
 	 * Either the network we are associated in INFRASTRUCTURE
@@ -2068,10 +2068,10 @@ struct ieee80211_device {
 	 */
 	short sync_scan_hurryup;
 
-        int perfect_rssi;
-        int worst_rssi;
+	int perfect_rssi;
+	int worst_rssi;
 
-        u16 prev_seq_ctl;       /* used to drop duplicate frames */
+	u16 prev_seq_ctl;       /* used to drop duplicate frames */
 
 	/* map of allowed channels. 0 is dummy */
 	// FIXME: remeber to default to a basic channel plan depending of the PHY type
@@ -2184,7 +2184,7 @@ struct ieee80211_device {
 
 	//added by amy for AP roaming
 	RT_LINK_DETECT_T	LinkDetectInfo;
-        //added by amy for ps
+	//added by amy for ps
 	RT_POWER_SAVE_CONTROL	PowerSaveControl;
 //}
 	/* used if IEEE_SOFTMAC_TX_QUEUE is set */
@@ -2196,19 +2196,19 @@ struct ieee80211_device {
 	/* used if IEEE_SOFTMAC_BEACONS is set */
 	struct timer_list beacon_timer;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-        struct work_struct associate_complete_wq;
-        struct work_struct associate_procedure_wq;
+	struct work_struct associate_complete_wq;
+	struct work_struct associate_procedure_wq;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-        struct delayed_work softmac_scan_wq;
-        struct delayed_work associate_retry_wq;
+	struct delayed_work softmac_scan_wq;
+	struct delayed_work associate_retry_wq;
 	 struct delayed_work start_ibss_wq;
 #else
-        struct work_struct softmac_scan_wq;
-        struct work_struct associate_retry_wq;
+	struct work_struct softmac_scan_wq;
+	struct work_struct associate_retry_wq;
 	struct work_struct start_ibss_wq;
 #endif
-        struct work_struct wx_sync_scan_wq;
-        struct workqueue_struct *wq;
+	struct work_struct wx_sync_scan_wq;
+	struct workqueue_struct *wq;
 #else
 	/* used for periodly scan */
 	struct timer_list scan_timer;
@@ -2221,10 +2221,10 @@ struct ieee80211_device {
 	struct tq_struct wx_sync_scan_wq;
 
 #endif
-        // Qos related. Added by Annie, 2005-11-01.
-        //STA_QOS  StaQos;
+	// Qos related. Added by Annie, 2005-11-01.
+	//STA_QOS  StaQos;
 
-        //u32 STA_EDCA_PARAM[4];
+	//u32 STA_EDCA_PARAM[4];
 	//CHANNEL_ACCESS_SETTING ChannelAccessSetting;
 
 
@@ -2240,11 +2240,11 @@ struct ieee80211_device {
 			       struct net_device *dev);
 
 	int (*reset_port)(struct net_device *dev);
-        int (*is_queue_full) (struct net_device * dev, int pri);
+	int (*is_queue_full) (struct net_device * dev, int pri);
 
-        int (*handle_management) (struct net_device * dev,
-                                  struct ieee80211_network * network, u16 type);
-        int (*is_qos_active) (struct net_device *dev, struct sk_buff *skb);
+	int (*handle_management) (struct net_device * dev,
+				  struct ieee80211_network * network, u16 type);
+	int (*is_qos_active) (struct net_device *dev, struct sk_buff *skb);
 
 	/* Softmac-generated frames (mamagement) are TXed via this
 	 * callback if the flag IEEE_SOFTMAC_SINGLE_QUEUE is
@@ -2322,32 +2322,32 @@ struct ieee80211_device {
 	short (*ps_is_queue_empty) (struct net_device *dev);
 #if 0
 	/* Typical STA methods */
-        int (*handle_auth) (struct net_device * dev,
-                            struct ieee80211_auth * auth);
-        int (*handle_deauth) (struct net_device * dev,
-                              struct ieee80211_deauth * auth);
-        int (*handle_action) (struct net_device * dev,
-                              struct ieee80211_action * action,
-                              struct ieee80211_rx_stats * stats);
-        int (*handle_disassoc) (struct net_device * dev,
-                                struct ieee80211_disassoc * assoc);
+	int (*handle_auth) (struct net_device * dev,
+			    struct ieee80211_auth * auth);
+	int (*handle_deauth) (struct net_device * dev,
+			      struct ieee80211_deauth * auth);
+	int (*handle_action) (struct net_device * dev,
+			      struct ieee80211_action * action,
+			      struct ieee80211_rx_stats * stats);
+	int (*handle_disassoc) (struct net_device * dev,
+				struct ieee80211_disassoc * assoc);
 #endif
-        int (*handle_beacon) (struct net_device * dev, struct ieee80211_beacon * beacon, struct ieee80211_network * network);
+	int (*handle_beacon) (struct net_device * dev, struct ieee80211_beacon * beacon, struct ieee80211_network * network);
 #if 0
-        int (*handle_probe_response) (struct net_device * dev,
-                                      struct ieee80211_probe_response * resp,
-                                      struct ieee80211_network * network);
-        int (*handle_probe_request) (struct net_device * dev,
-                                     struct ieee80211_probe_request * req,
-                                     struct ieee80211_rx_stats * stats);
+	int (*handle_probe_response) (struct net_device * dev,
+				      struct ieee80211_probe_response * resp,
+				      struct ieee80211_network * network);
+	int (*handle_probe_request) (struct net_device * dev,
+				     struct ieee80211_probe_request * req,
+				     struct ieee80211_rx_stats * stats);
 #endif
-        int (*handle_assoc_response) (struct net_device * dev, struct ieee80211_assoc_response_frame * resp, struct ieee80211_network * network);
+	int (*handle_assoc_response) (struct net_device * dev, struct ieee80211_assoc_response_frame * resp, struct ieee80211_network * network);
 
 #if 0
-        /* Typical AP methods */
-        int (*handle_assoc_request) (struct net_device * dev);
-        int (*handle_reassoc_request) (struct net_device * dev,
-                                       struct ieee80211_reassoc_request * req);
+	/* Typical AP methods */
+	int (*handle_assoc_request) (struct net_device * dev);
+	int (*handle_reassoc_request) (struct net_device * dev,
+				       struct ieee80211_reassoc_request * req);
 #endif
 
 	/* check whether Tx hw resouce available */
@@ -2484,45 +2484,45 @@ extern inline int ieee80211_get_hdrlen(u
 
 static inline u8 *ieee80211_get_payload(struct ieee80211_hdr *hdr)
 {
-        switch (ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl))) {
-        case IEEE80211_1ADDR_LEN:
-                return ((struct ieee80211_hdr_1addr *)hdr)->payload;
-        case IEEE80211_2ADDR_LEN:
-                return ((struct ieee80211_hdr_2addr *)hdr)->payload;
-        case IEEE80211_3ADDR_LEN:
-                return ((struct ieee80211_hdr_3addr *)hdr)->payload;
-        case IEEE80211_4ADDR_LEN:
-                return ((struct ieee80211_hdr_4addr *)hdr)->payload;
-        }
-        return NULL;
+	switch (ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl))) {
+	case IEEE80211_1ADDR_LEN:
+		return ((struct ieee80211_hdr_1addr *)hdr)->payload;
+	case IEEE80211_2ADDR_LEN:
+		return ((struct ieee80211_hdr_2addr *)hdr)->payload;
+	case IEEE80211_3ADDR_LEN:
+		return ((struct ieee80211_hdr_3addr *)hdr)->payload;
+	case IEEE80211_4ADDR_LEN:
+		return ((struct ieee80211_hdr_4addr *)hdr)->payload;
+	}
+	return NULL;
 }
 
 static inline int ieee80211_is_ofdm_rate(u8 rate)
 {
-        switch (rate & ~IEEE80211_BASIC_RATE_MASK) {
-        case IEEE80211_OFDM_RATE_6MB:
-        case IEEE80211_OFDM_RATE_9MB:
-        case IEEE80211_OFDM_RATE_12MB:
-        case IEEE80211_OFDM_RATE_18MB:
-        case IEEE80211_OFDM_RATE_24MB:
-        case IEEE80211_OFDM_RATE_36MB:
-        case IEEE80211_OFDM_RATE_48MB:
-        case IEEE80211_OFDM_RATE_54MB:
-                return 1;
-        }
-        return 0;
+	switch (rate & ~IEEE80211_BASIC_RATE_MASK) {
+	case IEEE80211_OFDM_RATE_6MB:
+	case IEEE80211_OFDM_RATE_9MB:
+	case IEEE80211_OFDM_RATE_12MB:
+	case IEEE80211_OFDM_RATE_18MB:
+	case IEEE80211_OFDM_RATE_24MB:
+	case IEEE80211_OFDM_RATE_36MB:
+	case IEEE80211_OFDM_RATE_48MB:
+	case IEEE80211_OFDM_RATE_54MB:
+		return 1;
+	}
+	return 0;
 }
 
 static inline int ieee80211_is_cck_rate(u8 rate)
 {
-        switch (rate & ~IEEE80211_BASIC_RATE_MASK) {
-        case IEEE80211_CCK_RATE_1MB:
-        case IEEE80211_CCK_RATE_2MB:
-        case IEEE80211_CCK_RATE_5MB:
-        case IEEE80211_CCK_RATE_11MB:
-                return 1;
-        }
-        return 0;
+	switch (rate & ~IEEE80211_BASIC_RATE_MASK) {
+	case IEEE80211_CCK_RATE_1MB:
+	case IEEE80211_CCK_RATE_2MB:
+	case IEEE80211_CCK_RATE_5MB:
+	case IEEE80211_CCK_RATE_11MB:
+		return 1;
+	}
+	return 0;
 }
 
 
@@ -2563,17 +2563,17 @@ extern int ieee80211_wx_get_encode(struc
 				   union iwreq_data *wrqu, char *key);
 #if WIRELESS_EXT >= 18
 extern int ieee80211_wx_get_encode_ext(struct ieee80211_device *ieee,
-                            struct iw_request_info *info,
-                            union iwreq_data* wrqu, char *extra);
+			    struct iw_request_info *info,
+			    union iwreq_data* wrqu, char *extra);
 extern int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,
-                            struct iw_request_info *info,
-                            union iwreq_data* wrqu, char *extra);
+			    struct iw_request_info *info,
+			    union iwreq_data* wrqu, char *extra);
 extern int ieee80211_wx_set_auth(struct ieee80211_device *ieee,
-                               struct iw_request_info *info,
-                               struct iw_param *data, char *extra);
+			       struct iw_request_info *info,
+			       struct iw_param *data, char *extra);
 extern int ieee80211_wx_set_mlme(struct ieee80211_device *ieee,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra);
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra);
 #endif
 extern int ieee80211_wx_set_gen_ie(struct ieee80211_device *ieee, u8 *ie, size_t len);
 
@@ -2730,13 +2730,13 @@ extern void RxBaInactTimeout(unsigned lo
 extern void ResetBaEntry( PBA_RECORD pBA);
 //function in TS.c
 extern bool GetTs(
-        struct ieee80211_device*        ieee,
-        PTS_COMMON_INFO                 *ppTS,
-        u8*                             Addr,
-        u8                              TID,
-        TR_SELECT                       TxRxSelect,  //Rx:1, Tx:0
-        bool                            bAddNewTs
-        );
+	struct ieee80211_device*        ieee,
+	PTS_COMMON_INFO                 *ppTS,
+	u8*                             Addr,
+	u8                              TID,
+	TR_SELECT                       TxRxSelect,  //Rx:1, Tx:0
+	bool                            bAddNewTs
+	);
 extern void TSInitialize(struct ieee80211_device *ieee);
 extern  void TsStartAddBaProcess(struct ieee80211_device* ieee, PTX_TS_RECORD   pTxTS);
 extern void RemovePeerTS(struct ieee80211_device* ieee, u8* Addr);
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_ccmp.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_ccmp.c
@@ -131,7 +131,7 @@ static void ccmp_init_blocks(struct cryp
 	/*
 	qc_included = ((WLAN_FC_GET_TYPE(fc) == IEEE80211_FTYPE_DATA) &&
 		       (WLAN_FC_GET_STYPE(fc) & 0x08));
-        */
+	*/
 	// fixed by David :2006.9.6
 	qc_included = ((WLAN_FC_GET_TYPE(fc) == IEEE80211_FTYPE_DATA) &&
 		       (WLAN_FC_GET_STYPE(fc) & 0x80));
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_tkip.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_tkip.c
@@ -24,7 +24,7 @@
 #include "ieee80211.h"
 
 #include <linux/crypto.h>
-        #include <linux/scatterlist.h>
+	#include <linux/scatterlist.h>
 #include <linux/crc32.h>
 
 MODULE_AUTHOR("Jouni Malinen");
@@ -382,7 +382,7 @@ static int ieee80211_tkip_encrypt(struct
 	if (!tcb_desc->bHwSec)
 		return ret;
 	else
-        	return 0;
+		return 0;
 
 
 }
@@ -502,26 +502,26 @@ static int ieee80211_tkip_decrypt(struct
 }
 
 static int michael_mic(struct crypto_hash *tfm_michael, u8 * key, u8 * hdr,
-                       u8 * data, size_t data_len, u8 * mic)
+		       u8 * data, size_t data_len, u8 * mic)
 {
-        struct hash_desc desc;
-        struct scatterlist sg[2];
+	struct hash_desc desc;
+	struct scatterlist sg[2];
+
+	if (tfm_michael == NULL) {
+		printk(KERN_WARNING "michael_mic: tfm_michael == NULL\n");
+		return -1;
+	}
 
-        if (tfm_michael == NULL) {
-                printk(KERN_WARNING "michael_mic: tfm_michael == NULL\n");
-                return -1;
-        }
-
-        sg_init_table(sg, 2);
-        sg_set_buf(&sg[0], hdr, 16);
-        sg_set_buf(&sg[1], data, data_len);
-
-        if (crypto_hash_setkey(tfm_michael, key, 8))
-                return -1;
-
-        desc.tfm = tfm_michael;
-        desc.flags = 0;
-        return crypto_hash_digest(&desc, sg, data_len + 16, mic);
+	sg_init_table(sg, 2);
+	sg_set_buf(&sg[0], hdr, 16);
+	sg_set_buf(&sg[1], data, data_len);
+
+	if (crypto_hash_setkey(tfm_michael, key, 8))
+		return -1;
+
+	desc.tfm = tfm_michael;
+	desc.flags = 0;
+	return crypto_hash_digest(&desc, sg, data_len + 16, mic);
 }
 
 static void michael_mic_hdr(struct sk_buff *skb, u8 *hdr)
@@ -630,7 +630,7 @@ static int ieee80211_michael_mic_verify(
 
 	if (michael_mic(tkey->rx_tfm_michael, &tkey->key[24], tkey->rx_hdr,
 				skb->data + hdr_len, skb->len - 8 - hdr_len, mic))
-            	return -1;
+		return -1;
 	if (memcmp(mic, skb->data + skb->len - 8, 8) != 0) {
 		struct ieee80211_hdr_4addr *hdr;
 		hdr = (struct ieee80211_hdr_4addr *) skb->data;
@@ -760,7 +760,7 @@ static struct ieee80211_crypto_ops ieee8
 	.print_stats		= ieee80211_tkip_print_stats,
 	.extra_prefix_len	= 4 + 4, /* IV + ExtIV */
 	.extra_postfix_len	= 8 + 4, /* MIC + ICV */
-	.owner		        = THIS_MODULE,
+	.owner			= THIS_MODULE,
 };
 
 int __init ieee80211_crypto_tkip_init(void)
@@ -776,5 +776,5 @@ void __exit ieee80211_crypto_tkip_exit(v
 void ieee80211_tkip_null(void)
 {
 //    printk("============>%s()\n", __FUNCTION__);
-        return;
+	return;
 }
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_wep.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_wep.c
@@ -34,8 +34,8 @@ struct prism2_wep_data {
 	u8 key[WEP_KEY_LEN + 1];
 	u8 key_len;
 	u8 key_idx;
-        struct crypto_blkcipher *tx_tfm;
-        struct crypto_blkcipher *rx_tfm;
+	struct crypto_blkcipher *tx_tfm;
+	struct crypto_blkcipher *rx_tfm;
 };
 
 
@@ -50,19 +50,19 @@ static void * prism2_wep_init(int keyidx
 	priv->key_idx = keyidx;
 
 	priv->tx_tfm = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
-        if (IS_ERR(priv->tx_tfm)) {
-                printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
-                       "crypto API arc4\n");
-                priv->tx_tfm = NULL;
-                goto fail;
-        }
-        priv->rx_tfm = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
-        if (IS_ERR(priv->rx_tfm)) {
-                printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
-                       "crypto API arc4\n");
-                priv->rx_tfm = NULL;
-                goto fail;
-        }
+	if (IS_ERR(priv->tx_tfm)) {
+		printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
+		       "crypto API arc4\n");
+		priv->tx_tfm = NULL;
+		goto fail;
+	}
+	priv->rx_tfm = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv->rx_tfm)) {
+		printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
+		       "crypto API arc4\n");
+		priv->rx_tfm = NULL;
+		goto fail;
+	}
 
 	/* start WEP IV from a random value */
 	get_random_bytes(&priv->iv, 4);
@@ -71,12 +71,12 @@ static void * prism2_wep_init(int keyidx
 
 fail:
 	if (priv) {
-                if (priv->tx_tfm)
-                        crypto_free_blkcipher(priv->tx_tfm);
-                if (priv->rx_tfm)
-                        crypto_free_blkcipher(priv->rx_tfm);
-                kfree(priv);
-        }
+		if (priv->tx_tfm)
+			crypto_free_blkcipher(priv->tx_tfm);
+		if (priv->rx_tfm)
+			crypto_free_blkcipher(priv->rx_tfm);
+		kfree(priv);
+	}
 
 	return NULL;
 }
@@ -87,11 +87,11 @@ static void prism2_wep_deinit(void *priv
 	struct prism2_wep_data *_priv = priv;
 
 	if (_priv) {
-                if (_priv->tx_tfm)
-                        crypto_free_blkcipher(_priv->tx_tfm);
-                if (_priv->rx_tfm)
-                        crypto_free_blkcipher(_priv->rx_tfm);
-        }
+		if (_priv->tx_tfm)
+			crypto_free_blkcipher(_priv->tx_tfm);
+		if (_priv->rx_tfm)
+			crypto_free_blkcipher(_priv->rx_tfm);
+	}
 	kfree(priv);
 }
 
@@ -293,5 +293,5 @@ void __exit ieee80211_crypto_wep_exit(vo
 void ieee80211_wep_null(void)
 {
 //	printk("============>%s()\n", __FUNCTION__);
-        return;
+	return;
 }
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211.h
@@ -86,8 +86,8 @@ struct iw_spy_data{
  *
  */
 #define container_of(ptr, type, member) ({                      \
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
-        (type *)( (char *)__mptr - offsetof(type,member) );})
+	const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
+	(type *)( (char *)__mptr - offsetof(type,member) );})
 #endif
 
 #define KEY_TYPE_NA		0x0
@@ -125,61 +125,61 @@ struct iw_spy_data{
 /* defined for skb cb field */
 /* At most 28 byte */
 typedef struct cb_desc {
-        /* Tx Desc Related flags (8-9) */
+	/* Tx Desc Related flags (8-9) */
 	u8 bLastIniPkt:1;
 	u8 bCmdOrInit:1;
-        u8 bFirstSeg:1;
-        u8 bLastSeg:1;
-        u8 bEncrypt:1;
-        u8 bTxDisableRateFallBack:1;
-        u8 bTxUseDriverAssingedRate:1;
-        u8 bHwSec:1; //indicate whether use Hw security. WB
-
-        u8 reserved1;
-
-        /* Tx Firmware Relaged flags (10-11)*/
-        u8 bCTSEnable:1;
-        u8 bRTSEnable:1;
-        u8 bUseShortGI:1;
-        u8 bUseShortPreamble:1;
-        u8 bTxEnableFwCalcDur:1;
-        u8 bAMPDUEnable:1;
-        u8 bRTSSTBC:1;
-        u8 RTSSC:1;
+	u8 bFirstSeg:1;
+	u8 bLastSeg:1;
+	u8 bEncrypt:1;
+	u8 bTxDisableRateFallBack:1;
+	u8 bTxUseDriverAssingedRate:1;
+	u8 bHwSec:1; //indicate whether use Hw security. WB
+
+	u8 reserved1;
+
+	/* Tx Firmware Relaged flags (10-11)*/
+	u8 bCTSEnable:1;
+	u8 bRTSEnable:1;
+	u8 bUseShortGI:1;
+	u8 bUseShortPreamble:1;
+	u8 bTxEnableFwCalcDur:1;
+	u8 bAMPDUEnable:1;
+	u8 bRTSSTBC:1;
+	u8 RTSSC:1;
 
-        u8 bRTSBW:1;
-        u8 bPacketBW:1;
+	u8 bRTSBW:1;
+	u8 bPacketBW:1;
 	u8 bRTSUseShortPreamble:1;
 	u8 bRTSUseShortGI:1;
 	u8 bMulticast:1;
 	u8 bBroadcast:1;
-        //u8 reserved2:2;
-        u8 drv_agg_enable:1;
-        u8 reserved2:1;
-
-        /* Tx Desc related element(12-19) */
-        u8 rata_index;
-        u8 queue_index;
-        //u8 reserved3;
-        //u8 reserved4;
-        u16 txbuf_size;
-        //u8 reserved5;
+	//u8 reserved2:2;
+	u8 drv_agg_enable:1;
+	u8 reserved2:1;
+
+	/* Tx Desc related element(12-19) */
+	u8 rata_index;
+	u8 queue_index;
+	//u8 reserved3;
+	//u8 reserved4;
+	u16 txbuf_size;
+	//u8 reserved5;
 	u8 RATRIndex;
-        u8 reserved6;
-        u8 reserved7;
-        u8 reserved8;
-
-        /* Tx firmware related element(20-27) */
-        u8 data_rate;
-        u8 rts_rate;
-        u8 ampdu_factor;
-        u8 ampdu_density;
-        //u8 reserved9;
-        //u8 reserved10;
-        //u8 reserved11;
-        u8 DrvAggrNum;
+	u8 reserved6;
+	u8 reserved7;
+	u8 reserved8;
+
+	/* Tx firmware related element(20-27) */
+	u8 data_rate;
+	u8 rts_rate;
+	u8 ampdu_factor;
+	u8 ampdu_density;
+	//u8 reserved9;
+	//u8 reserved10;
+	//u8 reserved11;
+	u8 DrvAggrNum;
 	u16 pkt_size;
-        u8 reserved12;
+	u8 reserved12;
 }cb_desc, *pcb_desc;
 
 /*--------------------------Define -------------------------------------------*/
@@ -389,7 +389,7 @@ enum	_ReasonCode{
 typedef struct ieee_param {
 	u32 cmd;
 	u8 sta_addr[ETH_ALEN];
-        union {
+	union {
 		struct {
 			u8 name;
 			u32 value;
@@ -399,9 +399,9 @@ typedef struct ieee_param {
 			u8 reserved[32];
 			u8 data[0];
 		} wpa_ie;
-	        struct{
+		struct{
 			int command;
-    			int reason_code;
+			int reason_code;
 		} mlme;
 		struct {
 			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
@@ -442,23 +442,23 @@ static inline void tq_init(struct tq_str
 #define MSECS(t)	(HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
 static inline unsigned long msleep_interruptible_rsl(unsigned int msecs)
 {
-         unsigned long timeout = MSECS(msecs) + 1;
+	 unsigned long timeout = MSECS(msecs) + 1;
 
-         while (timeout) {
-                 set_current_state(TASK_INTERRUPTIBLE);
-                 timeout = schedule_timeout(timeout);
-         }
-         return timeout;
+	 while (timeout) {
+		 set_current_state(TASK_INTERRUPTIBLE);
+		 timeout = schedule_timeout(timeout);
+	 }
+	 return timeout;
 }
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,31))
 static inline void msleep(unsigned int msecs)
 {
-         unsigned long timeout = MSECS(msecs) + 1;
+	 unsigned long timeout = MSECS(msecs) + 1;
 
-         while (timeout) {
-                 set_current_state(TASK_UNINTERRUPTIBLE);
-                 timeout = schedule_timeout(timeout);
-         }
+	 while (timeout) {
+		 set_current_state(TASK_UNINTERRUPTIBLE);
+		 timeout = schedule_timeout(timeout);
+	 }
 }
 #endif
 #else
@@ -559,24 +559,24 @@ static inline void msleep(unsigned int m
 #define SN_EQUAL(a, b)	(a == b)
 #define MAX_DEV_ADDR_SIZE 8
 typedef enum _ACT_CATEGORY{
-        ACT_CAT_QOS = 1,
-        ACT_CAT_DLS = 2,
-        ACT_CAT_BA  = 3,
-        ACT_CAT_HT  = 7,
-        ACT_CAT_WMM = 17,
+	ACT_CAT_QOS = 1,
+	ACT_CAT_DLS = 2,
+	ACT_CAT_BA  = 3,
+	ACT_CAT_HT  = 7,
+	ACT_CAT_WMM = 17,
 } ACT_CATEGORY, *PACT_CATEGORY;
 
 typedef enum _TS_ACTION{
-        ACT_ADDTSREQ = 0,
-        ACT_ADDTSRSP = 1,
-        ACT_DELTS    = 2,
-        ACT_SCHEDULE = 3,
+	ACT_ADDTSREQ = 0,
+	ACT_ADDTSRSP = 1,
+	ACT_DELTS    = 2,
+	ACT_SCHEDULE = 3,
 } TS_ACTION, *PTS_ACTION;
 
 typedef enum _BA_ACTION{
-        ACT_ADDBAREQ = 0,
-        ACT_ADDBARSP = 1,
-        ACT_DELBA    = 2,
+	ACT_ADDBAREQ = 0,
+	ACT_ADDBARSP = 1,
+	ACT_DELBA    = 2,
 } BA_ACTION, *PBA_ACTION;
 
 typedef enum _InitialGainOpType{
@@ -687,22 +687,22 @@ do { if (ieee80211_debug_level & (level)
 /* I want to see ASCII 33 to 126 only. Otherwise, I print '?'. Annie, 2005-11-22.*/
 #define PRINTABLE(_ch)  (_ch>'!' && _ch<'~')
 #define IEEE80211_PRINT_STR(_Comp, _TitleString, _Ptr, _Len)                            	\
-                        if((_Comp) & level)   							\
-                        {                                                                       \
-                                int             __i;                                            \
-                                u8  buffer[MAX_STR_LEN];                                    	\
-                                int length = (_Len<MAX_STR_LEN)? _Len : (MAX_STR_LEN-1) ;  	\
-                                memset(buffer, 0, MAX_STR_LEN);                      		\
-                                memcpy(buffer, (u8 *)_Ptr, length );            		\
-                                for( __i=0; __i<MAX_STR_LEN; __i++ )                            \
-                                {                                                               \
-                                     if( !PRINTABLE(buffer[__i]) )   buffer[__i] = '?';     	\
-                                }                                                               \
-                                buffer[length] = '\0';                                          \
-                                printk("Rtl819x: ");                                         	\
-                                printk(_TitleString);                                         \
-                                printk(": %d, <%s>\n", _Len, buffer);                         \
-                        }
+			if((_Comp) & level)   							\
+			{                                                                       \
+				int             __i;                                            \
+				u8  buffer[MAX_STR_LEN];                                    	\
+				int length = (_Len<MAX_STR_LEN)? _Len : (MAX_STR_LEN-1) ;  	\
+				memset(buffer, 0, MAX_STR_LEN);                      		\
+				memcpy(buffer, (u8 *)_Ptr, length );            		\
+				for( __i=0; __i<MAX_STR_LEN; __i++ )                            \
+				{                                                               \
+				     if( !PRINTABLE(buffer[__i]) )   buffer[__i] = '?';     	\
+				}                                                               \
+				buffer[length] = '\0';                                          \
+				printk("Rtl819x: ");                                         	\
+				printk(_TitleString);                                         \
+				printk(": %d, <%s>\n", _Len, buffer);                         \
+			}
 #else
 #define IEEE80211_PRINT_STR(_Comp, _TitleString, _Ptr, _Len)  do {} while (0)
 #endif
@@ -731,10 +731,10 @@ do { if (ieee80211_debug_level & (level)
 
 struct ieee80211_snap_hdr {
 
-        u8    dsap;   /* always 0xAA */
-        u8    ssap;   /* always 0xAA */
-        u8    ctrl;   /* always 0x03 */
-        u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+	u8    dsap;   /* always 0xAA */
+	u8    ssap;   /* always 0xAA */
+	u8    ctrl;   /* always 0x03 */
+	u8    oui[P80211_OUI_LEN];    /* organizational universal id */
 
 } __attribute__ ((packed));
 
@@ -775,65 +775,65 @@ struct ieee80211_snap_hdr {
 
 /* Status codes */
 enum ieee80211_statuscode {
-        WLAN_STATUS_SUCCESS = 0,
-        WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
-        WLAN_STATUS_CAPS_UNSUPPORTED = 10,
-        WLAN_STATUS_REASSOC_NO_ASSOC = 11,
-        WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
-        WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
-        WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
-        WLAN_STATUS_CHALLENGE_FAIL = 15,
-        WLAN_STATUS_AUTH_TIMEOUT = 16,
-        WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
-        WLAN_STATUS_ASSOC_DENIED_RATES = 18,
-        /* 802.11b */
-        WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
-        WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
-        WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
-        /* 802.11h */
-        WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
-        WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
-        WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
-        /* 802.11g */
-        WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
-        WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
-        /* 802.11i */
-        WLAN_STATUS_INVALID_IE = 40,
-        WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
-        WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
-        WLAN_STATUS_INVALID_AKMP = 43,
-        WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
-        WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
-        WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
+	WLAN_STATUS_SUCCESS = 0,
+	WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
+	WLAN_STATUS_CAPS_UNSUPPORTED = 10,
+	WLAN_STATUS_REASSOC_NO_ASSOC = 11,
+	WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
+	WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
+	WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
+	WLAN_STATUS_CHALLENGE_FAIL = 15,
+	WLAN_STATUS_AUTH_TIMEOUT = 16,
+	WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
+	WLAN_STATUS_ASSOC_DENIED_RATES = 18,
+	/* 802.11b */
+	WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
+	WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
+	WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
+	/* 802.11h */
+	WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
+	WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
+	WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
+	/* 802.11g */
+	WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
+	WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
+	/* 802.11i */
+	WLAN_STATUS_INVALID_IE = 40,
+	WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
+	WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
+	WLAN_STATUS_INVALID_AKMP = 43,
+	WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
+	WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
+	WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
 };
 
 /* Reason codes */
 enum ieee80211_reasoncode {
-        WLAN_REASON_UNSPECIFIED = 1,
-        WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
-        WLAN_REASON_DEAUTH_LEAVING = 3,
-        WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
-        WLAN_REASON_DISASSOC_AP_BUSY = 5,
-        WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
-        WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
-        WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
-        WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
-        /* 802.11h */
-        WLAN_REASON_DISASSOC_BAD_POWER = 10,
-        WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
-        /* 802.11i */
-        WLAN_REASON_INVALID_IE = 13,
-        WLAN_REASON_MIC_FAILURE = 14,
-        WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
-        WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
-        WLAN_REASON_IE_DIFFERENT = 17,
-        WLAN_REASON_INVALID_GROUP_CIPHER = 18,
-        WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
-        WLAN_REASON_INVALID_AKMP = 20,
-        WLAN_REASON_UNSUPP_RSN_VERSION = 21,
-        WLAN_REASON_INVALID_RSN_IE_CAP = 22,
-        WLAN_REASON_IEEE8021X_FAILED = 23,
-        WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
+	WLAN_REASON_UNSPECIFIED = 1,
+	WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
+	WLAN_REASON_DEAUTH_LEAVING = 3,
+	WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
+	WLAN_REASON_DISASSOC_AP_BUSY = 5,
+	WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
+	WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
+	WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
+	WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
+	/* 802.11h */
+	WLAN_REASON_DISASSOC_BAD_POWER = 10,
+	WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
+	/* 802.11i */
+	WLAN_REASON_INVALID_IE = 13,
+	WLAN_REASON_MIC_FAILURE = 14,
+	WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
+	WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
+	WLAN_REASON_IE_DIFFERENT = 17,
+	WLAN_REASON_INVALID_GROUP_CIPHER = 18,
+	WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
+	WLAN_REASON_INVALID_AKMP = 20,
+	WLAN_REASON_UNSUPP_RSN_VERSION = 21,
+	WLAN_REASON_INVALID_RSN_IE_CAP = 22,
+	WLAN_REASON_IEEE8021X_FAILED = 23,
+	WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
 };
 
 #define IEEE80211_STATMASK_SIGNAL (1<<0)
@@ -849,13 +849,13 @@ enum ieee80211_reasoncode {
 #define IEEE80211_52GHZ_BAND     (1<<1)
 
 #define IEEE80211_CCK_RATE_LEN  		4
-#define IEEE80211_CCK_RATE_1MB		        0x02
-#define IEEE80211_CCK_RATE_2MB		        0x04
-#define IEEE80211_CCK_RATE_5MB		        0x0B
-#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_CCK_RATE_1MB			0x02
+#define IEEE80211_CCK_RATE_2MB			0x04
+#define IEEE80211_CCK_RATE_5MB			0x0B
+#define IEEE80211_CCK_RATE_11MB			0x16
 #define IEEE80211_OFDM_RATE_LEN 		8
-#define IEEE80211_OFDM_RATE_6MB		        0x0C
-#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_6MB			0x0C
+#define IEEE80211_OFDM_RATE_9MB			0x12
 #define IEEE80211_OFDM_RATE_12MB		0x18
 #define IEEE80211_OFDM_RATE_18MB		0x24
 #define IEEE80211_OFDM_RATE_24MB		0x30
@@ -877,12 +877,12 @@ enum ieee80211_reasoncode {
 #define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
 #define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
 
-#define IEEE80211_CCK_RATES_MASK	        0x0000000F
+#define IEEE80211_CCK_RATES_MASK		0x0000000F
 #define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
 	IEEE80211_CCK_RATE_2MB_MASK)
 #define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
-        IEEE80211_CCK_RATE_5MB_MASK | \
-        IEEE80211_CCK_RATE_11MB_MASK)
+	IEEE80211_CCK_RATE_5MB_MASK | \
+	IEEE80211_CCK_RATE_11MB_MASK)
 
 #define IEEE80211_OFDM_RATES_MASK		0x00000FF0
 #define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
@@ -895,10 +895,10 @@ enum ieee80211_reasoncode {
 	IEEE80211_OFDM_RATE_48MB_MASK | \
 	IEEE80211_OFDM_RATE_54MB_MASK)
 #define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
-                                IEEE80211_CCK_DEFAULT_RATES_MASK)
+				IEEE80211_CCK_DEFAULT_RATES_MASK)
 
 #define IEEE80211_NUM_OFDM_RATES	    8
-#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_NUM_CCK_RATES		    4
 #define IEEE80211_OFDM_SHIFT_MASK_A         4
 
 
@@ -1064,10 +1064,10 @@ struct ieee80211_device;
 
 struct ieee80211_security {
 	u16 active_key:2,
-            enabled:1,
+	    enabled:1,
 	    auth_mode:2,
-            auth_algo:4,
-            unicast_uses_group:1,
+	    auth_algo:4,
+	    unicast_uses_group:1,
 	    encrypt:1;
 	u8 key_sizes[WEP_KEYS];
 	u8 keys[WEP_KEYS][SCM_KEY_LEN];
@@ -1089,60 +1089,60 @@ Total: 28-2340 bytes
 
 /* Management Frame Information Element Types */
 enum ieee80211_mfie {
-        MFIE_TYPE_SSID = 0,
-        MFIE_TYPE_RATES = 1,
-        MFIE_TYPE_FH_SET = 2,
-        MFIE_TYPE_DS_SET = 3,
-        MFIE_TYPE_CF_SET = 4,
-        MFIE_TYPE_TIM = 5,
-        MFIE_TYPE_IBSS_SET = 6,
-        MFIE_TYPE_COUNTRY = 7,
-        MFIE_TYPE_HOP_PARAMS = 8,
-        MFIE_TYPE_HOP_TABLE = 9,
-        MFIE_TYPE_REQUEST = 10,
-        MFIE_TYPE_CHALLENGE = 16,
-        MFIE_TYPE_POWER_CONSTRAINT = 32,
-        MFIE_TYPE_POWER_CAPABILITY = 33,
-        MFIE_TYPE_TPC_REQUEST = 34,
-        MFIE_TYPE_TPC_REPORT = 35,
-        MFIE_TYPE_SUPP_CHANNELS = 36,
-        MFIE_TYPE_CSA = 37,
-        MFIE_TYPE_MEASURE_REQUEST = 38,
-        MFIE_TYPE_MEASURE_REPORT = 39,
-        MFIE_TYPE_QUIET = 40,
-        MFIE_TYPE_IBSS_DFS = 41,
-        MFIE_TYPE_ERP = 42,
-        MFIE_TYPE_RSN = 48,
-        MFIE_TYPE_RATES_EX = 50,
-        MFIE_TYPE_HT_CAP= 45,
+	MFIE_TYPE_SSID = 0,
+	MFIE_TYPE_RATES = 1,
+	MFIE_TYPE_FH_SET = 2,
+	MFIE_TYPE_DS_SET = 3,
+	MFIE_TYPE_CF_SET = 4,
+	MFIE_TYPE_TIM = 5,
+	MFIE_TYPE_IBSS_SET = 6,
+	MFIE_TYPE_COUNTRY = 7,
+	MFIE_TYPE_HOP_PARAMS = 8,
+	MFIE_TYPE_HOP_TABLE = 9,
+	MFIE_TYPE_REQUEST = 10,
+	MFIE_TYPE_CHALLENGE = 16,
+	MFIE_TYPE_POWER_CONSTRAINT = 32,
+	MFIE_TYPE_POWER_CAPABILITY = 33,
+	MFIE_TYPE_TPC_REQUEST = 34,
+	MFIE_TYPE_TPC_REPORT = 35,
+	MFIE_TYPE_SUPP_CHANNELS = 36,
+	MFIE_TYPE_CSA = 37,
+	MFIE_TYPE_MEASURE_REQUEST = 38,
+	MFIE_TYPE_MEASURE_REPORT = 39,
+	MFIE_TYPE_QUIET = 40,
+	MFIE_TYPE_IBSS_DFS = 41,
+	MFIE_TYPE_ERP = 42,
+	MFIE_TYPE_RSN = 48,
+	MFIE_TYPE_RATES_EX = 50,
+	MFIE_TYPE_HT_CAP= 45,
 	 MFIE_TYPE_HT_INFO= 61,
 	 MFIE_TYPE_AIRONET=133,
-        MFIE_TYPE_GENERIC = 221,
-        MFIE_TYPE_QOS_PARAMETER = 222,
+	MFIE_TYPE_GENERIC = 221,
+	MFIE_TYPE_QOS_PARAMETER = 222,
 };
 
 /* Minimal header; can be used for passing 802.11 frames with sufficient
  * information to determine what type of underlying data type is actually
  * stored in the data. */
 struct ieee80211_hdr {
-        __le16 frame_ctl;
-        __le16 duration_id;
-        u8 payload[0];
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 payload[0];
 } __attribute__ ((packed));
 
 struct ieee80211_hdr_1addr {
-        __le16 frame_ctl;
-        __le16 duration_id;
-        u8 addr1[ETH_ALEN];
-        u8 payload[0];
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 payload[0];
 } __attribute__ ((packed));
 
 struct ieee80211_hdr_2addr {
-        __le16 frame_ctl;
-        __le16 duration_id;
-        u8 addr1[ETH_ALEN];
-        u8 addr2[ETH_ALEN];
-        u8 payload[0];
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 payload[0];
 } __attribute__ ((packed));
 
 struct ieee80211_hdr_3addr {
@@ -1152,7 +1152,7 @@ struct ieee80211_hdr_3addr {
 	u8 addr2[ETH_ALEN];
 	u8 addr3[ETH_ALEN];
 	__le16 seq_ctl;
-        u8 payload[0];
+	u8 payload[0];
 } __attribute__ ((packed));
 
 struct ieee80211_hdr_4addr {
@@ -1163,7 +1163,7 @@ struct ieee80211_hdr_4addr {
 	u8 addr3[ETH_ALEN];
 	__le16 seq_ctl;
 	u8 addr4[ETH_ALEN];
-        u8 payload[0];
+	u8 payload[0];
 } __attribute__ ((packed));
 
 struct ieee80211_hdr_3addrqos {
@@ -1173,7 +1173,7 @@ struct ieee80211_hdr_3addrqos {
 	u8 addr2[ETH_ALEN];
 	u8 addr3[ETH_ALEN];
 	__le16 seq_ctl;
-        u8 payload[0];
+	u8 payload[0];
 	__le16 qos_ctl;
 } __attribute__ ((packed));
 
@@ -1185,7 +1185,7 @@ struct ieee80211_hdr_4addrqos {
 	u8 addr3[ETH_ALEN];
 	__le16 seq_ctl;
 	u8 addr4[ETH_ALEN];
-        u8 payload[0];
+	u8 payload[0];
 	__le16 qos_ctl;
 } __attribute__ ((packed));
 
@@ -1205,14 +1205,14 @@ struct ieee80211_authentication {
 } __attribute__ ((packed));
 
 struct ieee80211_disassoc {
-        struct ieee80211_hdr_3addr header;
-        __le16 reason;
+	struct ieee80211_hdr_3addr header;
+	__le16 reason;
 } __attribute__ ((packed));
 
 struct ieee80211_probe_request {
 	struct ieee80211_hdr_3addr header;
 	/* SSID, supported rates */
-        struct ieee80211_info_element info_element[0];
+	struct ieee80211_info_element info_element[0];
 } __attribute__ ((packed));
 
 struct ieee80211_probe_response {
@@ -1220,9 +1220,9 @@ struct ieee80211_probe_response {
 	u32 time_stamp[2];
 	__le16 beacon_interval;
 	__le16 capability;
-        /* SSID, supported rates, FH params, DS params,
-         * CF params, IBSS params, TIM (if beacon), RSN */
-        struct ieee80211_info_element info_element[0];
+	/* SSID, supported rates, FH params, DS params,
+	 * CF params, IBSS params, TIM (if beacon), RSN */
+	struct ieee80211_info_element info_element[0];
 } __attribute__ ((packed));
 
 /* Alias beacon for probe_response */
@@ -1233,7 +1233,7 @@ struct ieee80211_assoc_request_frame {
 	__le16 capability;
 	__le16 listen_interval;
 	/* SSID, supported rates, RSN */
-        struct ieee80211_info_element info_element[0];
+	struct ieee80211_info_element info_element[0];
 } __attribute__ ((packed));
 
 struct ieee80211_reassoc_request_frame {
@@ -1242,7 +1242,7 @@ struct ieee80211_reassoc_request_frame {
 	__le16 listen_interval;
 	u8 current_ap[ETH_ALEN];
 	/* SSID, supported rates, RSN */
-        struct ieee80211_info_element info_element[0];
+	struct ieee80211_info_element info_element[0];
 } __attribute__ ((packed));
 
 struct ieee80211_assoc_response_frame {
@@ -1318,7 +1318,7 @@ typedef union _frameqos {
 #define NETWORK_HAS_QOS_PARAMETERS      (1<<3)
 #define NETWORK_HAS_QOS_INFORMATION     (1<<4)
 #define NETWORK_HAS_QOS_MASK            (NETWORK_HAS_QOS_PARAMETERS | \
-                                         NETWORK_HAS_QOS_INFORMATION)
+					 NETWORK_HAS_QOS_INFORMATION)
 /* 802.11h */
 #define NETWORK_HAS_POWER_CONSTRAINT    (1<<5)
 #define NETWORK_HAS_CSA                 (1<<6)
@@ -1338,46 +1338,46 @@ typedef union _frameqos {
 #define QOS_AIFSN_MIN_VALUE             2
 #if 1
 struct ieee80211_qos_information_element {
-        u8 elementID;
-        u8 length;
-        u8 qui[QOS_OUI_LEN];
-        u8 qui_type;
-        u8 qui_subtype;
-        u8 version;
-        u8 ac_info;
+	u8 elementID;
+	u8 length;
+	u8 qui[QOS_OUI_LEN];
+	u8 qui_type;
+	u8 qui_subtype;
+	u8 version;
+	u8 ac_info;
 } __attribute__ ((packed));
 
 struct ieee80211_qos_ac_parameter {
-        u8 aci_aifsn;
-        u8 ecw_min_max;
-        __le16 tx_op_limit;
+	u8 aci_aifsn;
+	u8 ecw_min_max;
+	__le16 tx_op_limit;
 } __attribute__ ((packed));
 
 struct ieee80211_qos_parameter_info {
-        struct ieee80211_qos_information_element info_element;
-        u8 reserved;
-        struct ieee80211_qos_ac_parameter ac_params_record[QOS_QUEUE_NUM];
+	struct ieee80211_qos_information_element info_element;
+	u8 reserved;
+	struct ieee80211_qos_ac_parameter ac_params_record[QOS_QUEUE_NUM];
 } __attribute__ ((packed));
 
 struct ieee80211_qos_parameters {
-        __le16 cw_min[QOS_QUEUE_NUM];
-        __le16 cw_max[QOS_QUEUE_NUM];
-        u8 aifs[QOS_QUEUE_NUM];
-        u8 flag[QOS_QUEUE_NUM];
-        __le16 tx_op_limit[QOS_QUEUE_NUM];
+	__le16 cw_min[QOS_QUEUE_NUM];
+	__le16 cw_max[QOS_QUEUE_NUM];
+	u8 aifs[QOS_QUEUE_NUM];
+	u8 flag[QOS_QUEUE_NUM];
+	__le16 tx_op_limit[QOS_QUEUE_NUM];
 } __attribute__ ((packed));
 
 struct ieee80211_qos_data {
-        struct ieee80211_qos_parameters parameters;
-        int active;
-        int supported;
-        u8 param_count;
-        u8 old_param_count;
+	struct ieee80211_qos_parameters parameters;
+	int active;
+	int supported;
+	u8 param_count;
+	u8 old_param_count;
 };
 
 struct ieee80211_tim_parameters {
-        u8 tim_count;
-        u8 tim_period;
+	u8 tim_count;
+	u8 tim_period;
 } __attribute__ ((packed));
 
 //#else
@@ -1598,10 +1598,10 @@ struct ieee80211_network {
 	u8 ssid[IW_ESSID_MAX_SIZE + 1];
 	u8 ssid_len;
 #if 1
-        struct ieee80211_qos_data qos_data;
+	struct ieee80211_qos_data qos_data;
 #else
        // Qos related. Added by Annie, 2005-11-01.
-        BSS_QOS   BssQos;
+	BSS_QOS   BssQos;
 #endif
 
 	//added by amy for LEAP
@@ -1637,15 +1637,15 @@ struct ieee80211_network {
 	u8  rsn_ie[MAX_WPA_IE_LEN];
 	size_t rsn_ie_len;
 
-        struct ieee80211_tim_parameters tim;
+	struct ieee80211_tim_parameters tim;
 	u8  dtim_period;
 	u8  dtim_data;
 	u32 last_dtim_sta_time[2];
 
-        //appeded for QoS
-        u8 wmm_info;
-        struct ieee80211_wmm_ac_param wmm_param[4];
-        u8 QoS_Enable;
+	//appeded for QoS
+	u8 wmm_info;
+	struct ieee80211_wmm_ac_param wmm_param[4];
+	u8 QoS_Enable;
 #ifdef THOMAS_TURBO
 	u8 Turbo_Enable;//enable turbo mode, added by thomas
 #endif
@@ -1653,7 +1653,7 @@ struct ieee80211_network {
 	u16 CountryIeLen;
 	u8 CountryIeBuf[MAX_IE_LEN];
 #endif
-        // HT Related, by amy, 2008.04.29
+	// HT Related, by amy, 2008.04.29
 	BSS_HT	bssht;
 	// Add to handle broadcom AP management frame CCK rate.
 	bool broadcom_cap_exist;
@@ -1709,13 +1709,13 @@ enum ieee80211_state {
 };
 #else
 enum ieee80211_state {
-        IEEE80211_UNINITIALIZED = 0,
-        IEEE80211_INITIALIZED,
-        IEEE80211_ASSOCIATING,
-        IEEE80211_ASSOCIATED,
-        IEEE80211_AUTHENTICATING,
-        IEEE80211_AUTHENTICATED,
-        IEEE80211_SHUTDOWN
+	IEEE80211_UNINITIALIZED = 0,
+	IEEE80211_INITIALIZED,
+	IEEE80211_ASSOCIATING,
+	IEEE80211_ASSOCIATED,
+	IEEE80211_AUTHENTICATING,
+	IEEE80211_AUTHENTICATED,
+	IEEE80211_SHUTDOWN
 };
 #endif
 
@@ -1729,17 +1729,17 @@ enum ieee80211_state {
 #define IEEE80211_24GHZ_MIN_CHANNEL 1
 #define IEEE80211_24GHZ_MAX_CHANNEL 14
 #define IEEE80211_24GHZ_CHANNELS (IEEE80211_24GHZ_MAX_CHANNEL - \
-                                  IEEE80211_24GHZ_MIN_CHANNEL + 1)
+				  IEEE80211_24GHZ_MIN_CHANNEL + 1)
 
 #define IEEE80211_52GHZ_MIN_CHANNEL 34
 #define IEEE80211_52GHZ_MAX_CHANNEL 165
 #define IEEE80211_52GHZ_CHANNELS (IEEE80211_52GHZ_MAX_CHANNEL - \
-                                  IEEE80211_52GHZ_MIN_CHANNEL + 1)
+				  IEEE80211_52GHZ_MIN_CHANNEL + 1)
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11))
 extern inline int is_multicast_ether_addr(const u8 *addr)
 {
-        return ((addr[0] != 0xff) && (0x01 & addr[0]));
+	return ((addr[0] != 0xff) && (0x01 & addr[0]));
 }
 #endif
 
@@ -1911,7 +1911,7 @@ typedef struct _RT_LINK_DETECT_T{
 
 struct ieee80211_device {
 	struct net_device *dev;
-        struct ieee80211_security sec;
+	struct ieee80211_security sec;
 
 	//hw security related
 //	u8 hwsec_support; //support?
@@ -2001,15 +2001,15 @@ struct ieee80211_device {
 	int host_encrypt;
 	int host_encrypt_msdu;
 	int host_decrypt;
-        /* host performs multicast decryption */
-        int host_mc_decrypt;
+	/* host performs multicast decryption */
+	int host_mc_decrypt;
 
-        /* host should strip IV and ICV from protected frames */
-        /* meaningful only when hardware decryption is being used */
-        int host_strip_iv_icv;
+	/* host should strip IV and ICV from protected frames */
+	/* meaningful only when hardware decryption is being used */
+	int host_strip_iv_icv;
 
-        int host_open_frag;
-        int host_build_iv;
+	int host_open_frag;
+	int host_build_iv;
 	int ieee802_1x; /* is IEEE 802.1X used */
 
 	/* WPA data */
@@ -2027,7 +2027,7 @@ struct ieee80211_device {
 	struct ieee80211_crypt_data *crypt[WEP_KEYS];
 	int tx_keyidx; /* default TX key index (crypt[tx_keyidx]) */
 	struct timer_list crypt_deinit_timer;
-        int crypt_quiesced;
+	int crypt_quiesced;
 
 	int bcrx_sta_key; /* use individual keys to override default keys even
 			   * with RX of broad/multicast frames */
@@ -2040,10 +2040,10 @@ struct ieee80211_device {
 #define DEFAULT_RTS_THRESHOLD 2346U
 #define MIN_RTS_THRESHOLD 1
 #define MAX_RTS_THRESHOLD 2346U
-        u16 rts; /* RTS threshold */
+	u16 rts; /* RTS threshold */
 
-        /* Association info */
-        u8 bssid[ETH_ALEN];
+	/* Association info */
+	u8 bssid[ETH_ALEN];
 
 	/* This stores infos for the current network.
 	 * Either the network we are associated in INFRASTRUCTURE
@@ -2069,10 +2069,10 @@ struct ieee80211_device {
 	 */
 	short sync_scan_hurryup;
 
-        int perfect_rssi;
-        int worst_rssi;
+	int perfect_rssi;
+	int worst_rssi;
 
-        u16 prev_seq_ctl;       /* used to drop duplicate frames */
+	u16 prev_seq_ctl;       /* used to drop duplicate frames */
 
 	/* map of allowed channels. 0 is dummy */
 	// FIXME: remeber to default to a basic channel plan depending of the PHY type
@@ -2185,7 +2185,7 @@ struct ieee80211_device {
 
 	//added by amy for AP roaming
 	RT_LINK_DETECT_T	LinkDetectInfo;
-        //added by amy for ps
+	//added by amy for ps
 	RT_POWER_SAVE_CONTROL	PowerSaveControl;
 //}
 	/* used if IEEE_SOFTMAC_TX_QUEUE is set */
@@ -2197,19 +2197,19 @@ struct ieee80211_device {
 	/* used if IEEE_SOFTMAC_BEACONS is set */
 	struct timer_list beacon_timer;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-        struct work_struct associate_complete_wq;
-        struct work_struct associate_procedure_wq;
+	struct work_struct associate_complete_wq;
+	struct work_struct associate_procedure_wq;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-        struct delayed_work softmac_scan_wq;
-        struct delayed_work associate_retry_wq;
+	struct delayed_work softmac_scan_wq;
+	struct delayed_work associate_retry_wq;
 	 struct delayed_work start_ibss_wq;
 #else
-        struct work_struct softmac_scan_wq;
-        struct work_struct associate_retry_wq;
+	struct work_struct softmac_scan_wq;
+	struct work_struct associate_retry_wq;
 	struct work_struct start_ibss_wq;
 #endif
-        struct work_struct wx_sync_scan_wq;
-        struct workqueue_struct *wq;
+	struct work_struct wx_sync_scan_wq;
+	struct workqueue_struct *wq;
 #else
 	/* used for periodly scan */
 	struct timer_list scan_timer;
@@ -2323,32 +2323,32 @@ struct ieee80211_device {
 	short (*ps_is_queue_empty) (struct net_device *dev);
 #if 0
 	/* Typical STA methods */
-        int (*handle_auth) (struct net_device * dev,
-                            struct ieee80211_auth * auth);
-        int (*handle_deauth) (struct net_device * dev,
-                              struct ieee80211_deauth * auth);
-        int (*handle_action) (struct net_device * dev,
-                              struct ieee80211_action * action,
-                              struct ieee80211_rx_stats * stats);
-        int (*handle_disassoc) (struct net_device * dev,
-                                struct ieee80211_disassoc * assoc);
+	int (*handle_auth) (struct net_device * dev,
+			    struct ieee80211_auth * auth);
+	int (*handle_deauth) (struct net_device * dev,
+			      struct ieee80211_deauth * auth);
+	int (*handle_action) (struct net_device * dev,
+			      struct ieee80211_action * action,
+			      struct ieee80211_rx_stats * stats);
+	int (*handle_disassoc) (struct net_device * dev,
+				struct ieee80211_disassoc * assoc);
 #endif
-        int (*handle_beacon) (struct net_device * dev, struct ieee80211_beacon * beacon, struct ieee80211_network * network);
+	int (*handle_beacon) (struct net_device * dev, struct ieee80211_beacon * beacon, struct ieee80211_network * network);
 #if 0
-        int (*handle_probe_response) (struct net_device * dev,
-                                      struct ieee80211_probe_response * resp,
-                                      struct ieee80211_network * network);
-        int (*handle_probe_request) (struct net_device * dev,
-                                     struct ieee80211_probe_request * req,
-                                     struct ieee80211_rx_stats * stats);
+	int (*handle_probe_response) (struct net_device * dev,
+				      struct ieee80211_probe_response * resp,
+				      struct ieee80211_network * network);
+	int (*handle_probe_request) (struct net_device * dev,
+				     struct ieee80211_probe_request * req,
+				     struct ieee80211_rx_stats * stats);
 #endif
-        int (*handle_assoc_response) (struct net_device * dev, struct ieee80211_assoc_response_frame * resp, struct ieee80211_network * network);
+	int (*handle_assoc_response) (struct net_device * dev, struct ieee80211_assoc_response_frame * resp, struct ieee80211_network * network);
 
 #if 0
-        /* Typical AP methods */
-        int (*handle_assoc_request) (struct net_device * dev);
-        int (*handle_reassoc_request) (struct net_device * dev,
-                                       struct ieee80211_reassoc_request * req);
+	/* Typical AP methods */
+	int (*handle_assoc_request) (struct net_device * dev);
+	int (*handle_reassoc_request) (struct net_device * dev,
+				       struct ieee80211_reassoc_request * req);
 #endif
 
 	/* check whether Tx hw resouce available */
@@ -2485,45 +2485,45 @@ extern inline int ieee80211_get_hdrlen(u
 
 static inline u8 *ieee80211_get_payload(struct ieee80211_hdr *hdr)
 {
-        switch (ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl))) {
-        case IEEE80211_1ADDR_LEN:
-                return ((struct ieee80211_hdr_1addr *)hdr)->payload;
-        case IEEE80211_2ADDR_LEN:
-                return ((struct ieee80211_hdr_2addr *)hdr)->payload;
-        case IEEE80211_3ADDR_LEN:
-                return ((struct ieee80211_hdr_3addr *)hdr)->payload;
-        case IEEE80211_4ADDR_LEN:
-                return ((struct ieee80211_hdr_4addr *)hdr)->payload;
-        }
-        return NULL;
+	switch (ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl))) {
+	case IEEE80211_1ADDR_LEN:
+		return ((struct ieee80211_hdr_1addr *)hdr)->payload;
+	case IEEE80211_2ADDR_LEN:
+		return ((struct ieee80211_hdr_2addr *)hdr)->payload;
+	case IEEE80211_3ADDR_LEN:
+		return ((struct ieee80211_hdr_3addr *)hdr)->payload;
+	case IEEE80211_4ADDR_LEN:
+		return ((struct ieee80211_hdr_4addr *)hdr)->payload;
+	}
+	return NULL;
 }
 
 static inline int ieee80211_is_ofdm_rate(u8 rate)
 {
-        switch (rate & ~IEEE80211_BASIC_RATE_MASK) {
-        case IEEE80211_OFDM_RATE_6MB:
-        case IEEE80211_OFDM_RATE_9MB:
-        case IEEE80211_OFDM_RATE_12MB:
-        case IEEE80211_OFDM_RATE_18MB:
-        case IEEE80211_OFDM_RATE_24MB:
-        case IEEE80211_OFDM_RATE_36MB:
-        case IEEE80211_OFDM_RATE_48MB:
-        case IEEE80211_OFDM_RATE_54MB:
-                return 1;
-        }
-        return 0;
+	switch (rate & ~IEEE80211_BASIC_RATE_MASK) {
+	case IEEE80211_OFDM_RATE_6MB:
+	case IEEE80211_OFDM_RATE_9MB:
+	case IEEE80211_OFDM_RATE_12MB:
+	case IEEE80211_OFDM_RATE_18MB:
+	case IEEE80211_OFDM_RATE_24MB:
+	case IEEE80211_OFDM_RATE_36MB:
+	case IEEE80211_OFDM_RATE_48MB:
+	case IEEE80211_OFDM_RATE_54MB:
+		return 1;
+	}
+	return 0;
 }
 
 static inline int ieee80211_is_cck_rate(u8 rate)
 {
-        switch (rate & ~IEEE80211_BASIC_RATE_MASK) {
-        case IEEE80211_CCK_RATE_1MB:
-        case IEEE80211_CCK_RATE_2MB:
-        case IEEE80211_CCK_RATE_5MB:
-        case IEEE80211_CCK_RATE_11MB:
-                return 1;
-        }
-        return 0;
+	switch (rate & ~IEEE80211_BASIC_RATE_MASK) {
+	case IEEE80211_CCK_RATE_1MB:
+	case IEEE80211_CCK_RATE_2MB:
+	case IEEE80211_CCK_RATE_5MB:
+	case IEEE80211_CCK_RATE_11MB:
+		return 1;
+	}
+	return 0;
 }
 
 
@@ -2564,17 +2564,17 @@ extern int ieee80211_wx_get_encode(struc
 				   union iwreq_data *wrqu, char *key);
 #if WIRELESS_EXT >= 18
 extern int ieee80211_wx_get_encode_ext(struct ieee80211_device *ieee,
-                            struct iw_request_info *info,
-                            union iwreq_data* wrqu, char *extra);
+			    struct iw_request_info *info,
+			    union iwreq_data* wrqu, char *extra);
 extern int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,
-                            struct iw_request_info *info,
-                            union iwreq_data* wrqu, char *extra);
+			    struct iw_request_info *info,
+			    union iwreq_data* wrqu, char *extra);
 extern int ieee80211_wx_set_auth(struct ieee80211_device *ieee,
-                               struct iw_request_info *info,
-                               struct iw_param *data, char *extra);
+			       struct iw_request_info *info,
+			       struct iw_param *data, char *extra);
 extern int ieee80211_wx_set_mlme(struct ieee80211_device *ieee,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra);
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra);
 #endif
 extern int ieee80211_wx_set_gen_ie(struct ieee80211_device *ieee, u8 *ie, size_t len);
 
@@ -2731,13 +2731,13 @@ extern void RxBaInactTimeout(unsigned lo
 extern void ResetBaEntry( PBA_RECORD pBA);
 //function in TS.c
 extern bool GetTs(
-        struct ieee80211_device*        ieee,
-        PTS_COMMON_INFO                 *ppTS,
-        u8*                             Addr,
-        u8                              TID,
-        TR_SELECT                       TxRxSelect,  //Rx:1, Tx:0
-        bool                            bAddNewTs
-        );
+	struct ieee80211_device*        ieee,
+	PTS_COMMON_INFO                 *ppTS,
+	u8*                             Addr,
+	u8                              TID,
+	TR_SELECT                       TxRxSelect,  //Rx:1, Tx:0
+	bool                            bAddNewTs
+	);
 extern void TSInitialize(struct ieee80211_device *ieee);
 extern  void TsStartAddBaProcess(struct ieee80211_device* ieee, PTX_TS_RECORD   pTxTS);
 extern void RemovePeerTS(struct ieee80211_device* ieee, u8* Addr);
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_module.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_module.c
@@ -150,11 +150,11 @@ struct net_device *alloc_ieee80211(int s
 	atomic_set(&(ieee->atm_swbw), 0);
 
 	ieee->wpax_type_set = 0;
- 	ieee->wpa_enabled = 0;
- 	ieee->tkip_countermeasures = 0;
- 	ieee->drop_unencrypted = 0;
- 	ieee->privacy_invoked = 0;
- 	ieee->ieee802_1x = 1;
+	ieee->wpa_enabled = 0;
+	ieee->tkip_countermeasures = 0;
+	ieee->drop_unencrypted = 0;
+	ieee->privacy_invoked = 0;
+	ieee->ieee802_1x = 1;
 	ieee->raw_tx = 0;
 	//ieee->hwsec_support = 1; //defalt support hw security. //use module_param instead.
 	ieee->hwsec_active = 0; //disable hwsec, switch it on when necessary.
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
@@ -133,14 +133,14 @@ void ieee80211_WMM_Info(struct ieee80211
 void ieee80211_TURBO_Info(struct ieee80211_device *ieee, u8 **tag_p) {
 	u8 *tag = *tag_p;
 
-        *tag++ = MFIE_TYPE_GENERIC; //0
-        *tag++ = 7;
-        *tag++ = 0x00;
-        *tag++ = 0xe0;
-        *tag++ = 0x4c;
-        *tag++ = 0x01;//5
-        *tag++ = 0x02;
-        *tag++ = 0x11;
+	*tag++ = MFIE_TYPE_GENERIC; //0
+	*tag++ = 7;
+	*tag++ = 0x00;
+	*tag++ = 0xe0;
+	*tag++ = 0x4c;
+	*tag++ = 0x01;//5
+	*tag++ = 0x02;
+	*tag++ = 0x11;
 	*tag++ = 0x00;
 
 	*tag_p = tag;
@@ -238,9 +238,9 @@ inline void softmac_mgmt_xmit(struct sk_
 
 	tcb_desc->queue_index = MGNT_QUEUE;
 	tcb_desc->data_rate = MgntQuery_MgntFrameTxRate(ieee);
-        tcb_desc->RATRIndex = 7;
-        tcb_desc->bTxDisableRateFallBack = 1;
-        tcb_desc->bTxUseDriverAssingedRate = 1;
+	tcb_desc->RATRIndex = 7;
+	tcb_desc->bTxDisableRateFallBack = 1;
+	tcb_desc->bTxUseDriverAssingedRate = 1;
 
 	if(single){
 		if(ieee->queue_stop){
@@ -525,8 +525,8 @@ void ieee80211_softmac_scan(struct ieee8
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void ieee80211_softmac_scan_wq(struct work_struct *work)
 {
-        struct delayed_work *dwork = container_of(work, struct delayed_work, work);
-        struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, softmac_scan_wq);
+	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
+	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, softmac_scan_wq);
 #else
 void ieee80211_softmac_scan_wq(struct ieee80211_device *ieee)
 {
@@ -546,7 +546,7 @@ void ieee80211_softmac_scan_wq(struct ie
 		{
 		//if current channel is not in channel map, set to default channel.
 		#ifdef ENABLE_DOT11D
-      			if (!channel_map[ieee->current_network.channel]);
+			if (!channel_map[ieee->current_network.channel]);
 		#else
 			if (!ieee->channel_map[ieee->current_network.channel]);
 		#endif
@@ -554,7 +554,7 @@ void ieee80211_softmac_scan_wq(struct ie
 				goto out; /* no good chans */
 		}
 #ifdef ENABLE_DOT11D
-        }while(!channel_map[ieee->current_network.channel]);
+	}while(!channel_map[ieee->current_network.channel]);
 #else
 	}while(!ieee->channel_map[ieee->current_network.channel]);
 #endif
@@ -582,7 +582,7 @@ out:
 	if(IS_DOT11D_ENABLE(ieee))
 		DOT11D_ScanComplete(ieee);
 #endif
-        ieee->actscanning = false;
+	ieee->actscanning = false;
 	watchdog = 0;
 	ieee->scanning = 0;
 	up(&ieee->scan_sem);
@@ -619,7 +619,7 @@ void ieee80211_beacons_stop(struct ieee8
 	spin_lock_irqsave(&ieee->beacon_lock,flags);
 
 	ieee->beacon_txing = 0;
- 	del_timer_sync(&ieee->beacon_timer);
+	del_timer_sync(&ieee->beacon_timer);
 
 	spin_unlock_irqrestore(&ieee->beacon_lock,flags);
 
@@ -807,12 +807,12 @@ static struct sk_buff* ieee80211_probe_r
 		erp_len = 0;
 #else
       if((ieee->current_network.mode == IEEE_G)
-	  	||( ieee->current_network.mode == IEEE_N_24G && ieee->pHTInfo->bCurSuppCCK)) {
-	  	erp_len = 3;
+		||( ieee->current_network.mode == IEEE_N_24G && ieee->pHTInfo->bCurSuppCCK)) {
+		erp_len = 3;
 		erpinfo_content = 0;
 		if(ieee->current_network.buseprotection)
 			erpinfo_content |= ERP_UseProtection;
-      	}
+	}
 	else
 		erp_len = 0;
 #endif
@@ -833,12 +833,12 @@ static struct sk_buff* ieee80211_probe_r
 	HTConstructInfoElement(ieee,tmp_ht_info_buf,&tmp_ht_info_len, encrypt);
 
 
-        if(pHTInfo->bRegRT2RTAggregation)
-        {
-        	tmp_generic_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;
+	if(pHTInfo->bRegRT2RTAggregation)
+	{
+		tmp_generic_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;
 		tmp_generic_ie_len = sizeof(ieee->pHTInfo->szRT2RTAggBuffer);
 		HTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf, &tmp_generic_ie_len);
-        }
+	}
 //	printk("===============>tmp_ht_cap_len is %d,tmp_ht_info_len is %d, tmp_generic_ie_len is %d\n",tmp_ht_cap_len,tmp_ht_info_len,tmp_generic_ie_len);
 #endif
 	beacon_size = sizeof(struct ieee80211_probe_response)+2+
@@ -848,7 +848,7 @@ static struct sk_buff* ieee80211_probe_r
 		+rate_ex_len
 		+atim_len
 		+erp_len
-                +wpa_ie_len
+		+wpa_ie_len
 	//	+tmp_ht_cap_len
 	//	+tmp_ht_info_len
 	//	+tmp_generic_ie_len
@@ -1187,7 +1187,7 @@ inline struct sk_buff *ieee80211_associa
 		+ wpa_ie_len
 		+ wmm_info_len
 		+ turbo_info_len
-                + ht_cap_len
+		+ ht_cap_len
 		+ realtek_ie_len
 		+ ckip_ie_len
 		+ ccxrm_ie_len
@@ -1199,7 +1199,7 @@ inline struct sk_buff *ieee80211_associa
 		+ rate_len//rates tagged val
 		+ wpa_ie_len
 		+ wmm_info_len
-                + ht_cap_len
+		+ ht_cap_len
 		+ realtek_ie_len
 		+ ckip_ie_len
 		+ ccxrm_ie_len
@@ -1235,7 +1235,7 @@ inline struct sk_buff *ieee80211_associa
 
 	if(ieee->short_slot)
 		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);
- 	if (wmm_info_len) //QOS
+	if (wmm_info_len) //QOS
 	hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_QOS);
 
 	hdr->listen_interval = 0xa; //FIXME
@@ -1304,7 +1304,7 @@ inline struct sk_buff *ieee80211_associa
 		memcpy(tag,osCcxVerNum.Octet,osCcxVerNum.Length);
 		tag += osCcxVerNum.Length;
 	}
-        //HT cap element
+	//HT cap element
 	if(ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT){
 		if(ieee->pHTInfo->ePeerHTSpecVer != HT_SPEC_VER_EWC)
 		{
@@ -1329,9 +1329,9 @@ inline struct sk_buff *ieee80211_associa
 	}
 #ifdef THOMAS_TURBO
 	tag = skb_put(skb,turbo_info_len);
-        if(turbo_info_len) {
-                ieee80211_TURBO_Info(ieee, &tag);
-        }
+	if(turbo_info_len) {
+		ieee80211_TURBO_Info(ieee, &tag);
+	}
 #endif
 
 	if(ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT){
@@ -1382,7 +1382,7 @@ void ieee80211_associate_abort(struct ie
 
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	queue_delayed_work(ieee->wq, &ieee->associate_retry_wq, \
-                           IEEE80211_SOFTMAC_ASSOC_RETRY_TIME);
+			   IEEE80211_SOFTMAC_ASSOC_RETRY_TIME);
 #else
 	schedule_task(&ieee->associate_retry_wq);
 #endif
@@ -1482,7 +1482,7 @@ void ieee80211_associate_step2(struct ie
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void ieee80211_associate_complete_wq(struct work_struct *work)
 {
-        struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_complete_wq);
+	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_complete_wq);
 #else
 void ieee80211_associate_complete_wq(struct ieee80211_device *ieee)
 {
@@ -1567,7 +1567,7 @@ void ieee80211_associate_complete(struct
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void ieee80211_associate_procedure_wq(struct work_struct *work)
 {
-        struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_procedure_wq);
+	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_procedure_wq);
 #else
 void ieee80211_associate_procedure_wq(struct ieee80211_device *ieee)
 {
@@ -1623,7 +1623,7 @@ inline void ieee80211_softmac_new_net(st
 
 
 		if (	/* if the user set the AP check if match.
-		         * if the network does not broadcast essid we check the user supplyed ANY essid
+			 * if the network does not broadcast essid we check the user supplyed ANY essid
 			 * if the network does broadcast and the user does not set essid it is OK
 			 * if the network does broadcast and the user did set essid chech if essid match
 			 */
@@ -1837,8 +1837,8 @@ static inline u16 assoc_parse(struct iee
 	   status_code==WLAN_STATUS_CAPS_UNSUPPORTED)&&
 	   ((ieee->mode == IEEE_G) &&
 	    (ieee->current_network.mode == IEEE_N_24G) &&
-            (ieee->AsocRetryCount++ < (RT_ASOC_RETRY_LIMIT-1)))) {
-                 ieee->pHTInfo->IOTAction |= HT_IOT_ACT_PURE_N_MODE;
+	    (ieee->AsocRetryCount++ < (RT_ASOC_RETRY_LIMIT-1)))) {
+		 ieee->pHTInfo->IOTAction |= HT_IOT_ACT_PURE_N_MODE;
 	}else {
 		 ieee->AsocRetryCount = 0;
 	}
@@ -2535,8 +2535,8 @@ void ieee80211_start_monitor_mode(struct
 void ieee80211_start_ibss_wq(struct work_struct *work)
 {
 
-        struct delayed_work *dwork = container_of(work, struct delayed_work, work);
-        struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, start_ibss_wq);
+	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
+	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, start_ibss_wq);
 #else
 void ieee80211_start_ibss_wq(struct ieee80211_device *ieee)
 {
@@ -2843,7 +2843,7 @@ void ieee80211_softmac_start_protocol(st
 void ieee80211_start_protocol(struct ieee80211_device *ieee)
 {
 	short ch = 0;
- 	int i = 0;
+	int i = 0;
 	if (ieee->proto_started)
 		return;
 
@@ -2867,7 +2867,7 @@ void ieee80211_start_protocol(struct iee
 //	printk("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
 //	ieee->set_chan(ieee->dev,ieee->current_network.channel);
 
-       	for(i = 0; i < 17; i++) {
+	for(i = 0; i < 17; i++) {
 	  ieee->last_rxseq_num[i] = -1;
 	  ieee->last_rxfrag_num[i] = -1;
 	  ieee->last_packet_time[i] = 0;
@@ -2915,7 +2915,7 @@ void ieee80211_softmac_init(struct ieee8
 	//added for  AP roaming
 	ieee->LinkDetectInfo.SlotNum = 2;
 	ieee->LinkDetectInfo.NumRecvBcnInPeriod=0;
-        ieee->LinkDetectInfo.NumRecvDataInPeriod=0;
+	ieee->LinkDetectInfo.NumRecvDataInPeriod=0;
 
 	ieee->assoc_id = 0;
 	ieee->queue_stop = 0;
@@ -2968,12 +2968,12 @@ void ieee80211_softmac_init(struct ieee8
 
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-        INIT_DELAYED_WORK(&ieee->start_ibss_wq,ieee80211_start_ibss_wq);
-        INIT_WORK(&ieee->associate_complete_wq, ieee80211_associate_complete_wq);
-        INIT_WORK(&ieee->associate_procedure_wq, ieee80211_associate_procedure_wq);
-        INIT_DELAYED_WORK(&ieee->softmac_scan_wq,ieee80211_softmac_scan_wq);
-        INIT_DELAYED_WORK(&ieee->associate_retry_wq, ieee80211_associate_retry_wq);
-        INIT_WORK(&ieee->wx_sync_scan_wq,ieee80211_wx_sync_scan_wq);
+	INIT_DELAYED_WORK(&ieee->start_ibss_wq,ieee80211_start_ibss_wq);
+	INIT_WORK(&ieee->associate_complete_wq, ieee80211_associate_complete_wq);
+	INIT_WORK(&ieee->associate_procedure_wq, ieee80211_associate_procedure_wq);
+	INIT_DELAYED_WORK(&ieee->softmac_scan_wq,ieee80211_softmac_scan_wq);
+	INIT_DELAYED_WORK(&ieee->associate_retry_wq, ieee80211_associate_retry_wq);
+	INIT_WORK(&ieee->wx_sync_scan_wq,ieee80211_wx_sync_scan_wq);
 
 #else
 	INIT_WORK(&ieee->start_ibss_wq,(void(*)(void*)) ieee80211_start_ibss_wq,ieee);
@@ -3165,7 +3165,7 @@ static int ieee80211_wpa_set_param(struc
 			.flags = SEC_ENABLED,
 			.enabled = value,
 		};
- 		ieee->drop_unencrypted = value;
+		ieee->drop_unencrypted = value;
 		/* We only change SEC_LEVEL for open mode. Others
 		 * are set by ipw_wpa_set_encryption.
 		 */
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac_wx.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac_wx.c
@@ -316,7 +316,7 @@ out:
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 void ieee80211_wx_sync_scan_wq(struct work_struct *work)
 {
-        struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, wx_sync_scan_wq);
+	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, wx_sync_scan_wq);
 #else
 void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee)
 {
@@ -641,7 +641,7 @@ int ieee80211_wx_get_power(struct ieee80
 	}
 
        if ((ieee->ps & (IEEE80211_PS_MBCAST | IEEE80211_PS_UNICAST)) == (IEEE80211_PS_MBCAST | IEEE80211_PS_UNICAST))
-	   	wrqu->power.flags |= IW_POWER_ALL_R;
+		wrqu->power.flags |= IW_POWER_ALL_R;
 	else if (ieee->ps & IEEE80211_PS_MBCAST)
 		wrqu->power.flags |= IW_POWER_MULTICAST_R;
 	else
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c
@@ -56,18 +56,18 @@ struct modes_unit ieee80211_modes[] = {
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
 static inline char *
 iwe_stream_add_event_rsl(char *     stream,         /* Stream of events */
-                     char *     ends,           /* End of stream */
-                     struct iw_event *iwe,      /* Payload */
-                     int        event_len)      /* Real size of payload */
+		     char *     ends,           /* End of stream */
+		     struct iw_event *iwe,      /* Payload */
+		     int        event_len)      /* Real size of payload */
 {
-        /* Check if it's possible */
-        if((stream + event_len) < ends) {
-                iwe->len = event_len;
+	/* Check if it's possible */
+	if((stream + event_len) < ends) {
+		iwe->len = event_len;
 		ndelay(1);   //new
-                memcpy(stream, (char *) iwe, event_len);
-                stream += event_len;
-        }
-        return stream;
+		memcpy(stream, (char *) iwe, event_len);
+		stream += event_len;
+	}
+	return stream;
 }
 #else
 #define iwe_stream_add_event_rsl iwe_stream_add_event
@@ -75,9 +75,9 @@ iwe_stream_add_event_rsl(char *     stre
 
 #define MAX_CUSTOM_LEN 64
 static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
- 					   char *start, char *stop,
+					   char *start, char *stop,
 					   struct ieee80211_network *network,
-                                           struct iw_request_info *info)
+					   struct iw_request_info *info)
 {
 	char custom[MAX_CUSTOM_LEN];
 	char proto_name[IFNAMSIZ];
@@ -106,18 +106,18 @@ static inline char *rtl819x_translate_sc
 	if (network->ssid_len == 0) {
 		iwe.u.data.length = sizeof("<hidden>");
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-                start = iwe_stream_add_point(info, start, stop, &iwe, "<hidden>");
+		start = iwe_stream_add_point(info, start, stop, &iwe, "<hidden>");
 #else
-                start = iwe_stream_add_point(start, stop, &iwe, "<hidden>");
+		start = iwe_stream_add_point(start, stop, &iwe, "<hidden>");
 #endif
-        } else {
+	} else {
 		iwe.u.data.length = min(network->ssid_len, (u8)32);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-                start = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);
+		start = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);
 #else
-                start = iwe_stream_add_point(start, stop, &iwe, network->ssid);
+		start = iwe_stream_add_point(start, stop, &iwe, network->ssid);
 #endif
-        }
+	}
 	/* Add the protocol name */
 	iwe.cmd = SIOCGIWNAME;
 	for(i=0; i<(sizeof(ieee80211_modes)/sizeof(ieee80211_modes[0])); i++) {
@@ -129,26 +129,26 @@ static inline char *rtl819x_translate_sc
 	*pname = '\0';
 	snprintf(iwe.u.name, IFNAMSIZ, "IEEE802.11%s", proto_name);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-        start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_CHAR_LEN);
+	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_CHAR_LEN);
 #else
-        start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_CHAR_LEN);
+	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_CHAR_LEN);
 #endif
-        /* Add mode */
-        iwe.cmd = SIOCGIWMODE;
-        if (network->capability &
+	/* Add mode */
+	iwe.cmd = SIOCGIWMODE;
+	if (network->capability &
 	    (WLAN_CAPABILITY_BSS | WLAN_CAPABILITY_IBSS)) {
 		if (network->capability & WLAN_CAPABILITY_BSS)
 			iwe.u.mode = IW_MODE_MASTER;
 		else
 			iwe.u.mode = IW_MODE_ADHOC;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-                start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_UINT_LEN);
+		start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_UINT_LEN);
 #else
-                start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_UINT_LEN);
+		start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_UINT_LEN);
 #endif
-        }
+	}
 
-        /* Add frequency/channel */
+	/* Add frequency/channel */
 	iwe.cmd = SIOCGIWFREQ;
 /*	iwe.u.freq.m = ieee80211_frequency(network->channel, network->mode);
 	iwe.u.freq.e = 3; */
@@ -156,9 +156,9 @@ static inline char *rtl819x_translate_sc
 	iwe.u.freq.e = 0;
 	iwe.u.freq.i = 0;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-        start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_FREQ_LEN);
+	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_FREQ_LEN);
 #else
-        start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_FREQ_LEN);
+	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_FREQ_LEN);
 #endif
 	/* Add encryption capability */
 	iwe.cmd = SIOCGIWENCODE;
@@ -168,9 +168,9 @@ static inline char *rtl819x_translate_sc
 		iwe.u.data.flags = IW_ENCODE_DISABLED;
 	iwe.u.data.length = 0;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-        start = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);
+	start = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);
 #else
-        start = iwe_stream_add_point(start, stop, &iwe, network->ssid);
+	start = iwe_stream_add_point(start, stop, &iwe, network->ssid);
 #endif
 	/* Add basic and extended rates */
 	max_rate = 0;
@@ -228,19 +228,19 @@ static inline char *rtl819x_translate_sc
 	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
 	iwe.u.bitrate.value = max_rate * 500000;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-        start = iwe_stream_add_event_rsl(info, start, stop, &iwe,
+	start = iwe_stream_add_event_rsl(info, start, stop, &iwe,
 				     IW_EV_PARAM_LEN);
 #else
-        start = iwe_stream_add_event_rsl(start, stop, &iwe,
+	start = iwe_stream_add_event_rsl(start, stop, &iwe,
 				     IW_EV_PARAM_LEN);
 #endif
 	iwe.cmd = IWEVCUSTOM;
 	iwe.u.data.length = p - custom;
 	if (iwe.u.data.length)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-        start = iwe_stream_add_point(info, start, stop, &iwe, custom);
+	start = iwe_stream_add_point(info, start, stop, &iwe, custom);
 #else
-        start = iwe_stream_add_point(start, stop, &iwe, custom);
+	start = iwe_stream_add_point(start, stop, &iwe, custom);
 #endif
 	/* Add quality statistics */
 	/* TODO: Fix these values... */
@@ -257,9 +257,9 @@ static inline char *rtl819x_translate_sc
 		iwe.u.qual.updated |= IW_QUAL_QUAL_INVALID;
 	iwe.u.qual.updated = 7;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-        start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_QUAL_LEN);
 #else
-        start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_QUAL_LEN);
+	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_QUAL_LEN);
 #endif
 	iwe.cmd = IWEVCUSTOM;
 	p = custom;
@@ -267,9 +267,9 @@ static inline char *rtl819x_translate_sc
 	iwe.u.data.length = p - custom;
 	if (iwe.u.data.length)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-            start = iwe_stream_add_point(info, start, stop, &iwe, custom);
+	    start = iwe_stream_add_point(info, start, stop, &iwe, custom);
 #else
-            start = iwe_stream_add_point(start, stop, &iwe, custom);
+	    start = iwe_stream_add_point(start, stop, &iwe, custom);
 #endif
 #if (WIRELESS_EXT < 18)
 	if (ieee->wpa_enabled && network->wpa_ie_len){
@@ -285,11 +285,11 @@ static inline char *rtl819x_translate_sc
 		iwe.cmd = IWEVCUSTOM;
 		iwe.u.data.length = strlen(buf);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-                start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
 #else
-                start = iwe_stream_add_point(start, stop, &iwe, buf);
+		start = iwe_stream_add_point(start, stop, &iwe, buf);
 #endif
-        }
+	}
 
 	if (ieee->wpa_enabled && network->rsn_ie_len){
 		char buf[MAX_WPA_IE_LEN * 2 + 30];
@@ -304,11 +304,11 @@ static inline char *rtl819x_translate_sc
 		iwe.cmd = IWEVCUSTOM;
 		iwe.u.data.length = strlen(buf);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-                start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
 #else
-                start = iwe_stream_add_point(start, stop, &iwe, buf);
+		start = iwe_stream_add_point(start, stop, &iwe, buf);
 #endif
-        }
+	}
 #else
 	memset(&iwe, 0, sizeof(iwe));
 	if (network->wpa_ie_len)
@@ -318,11 +318,11 @@ static inline char *rtl819x_translate_sc
 		iwe.cmd = IWEVGENIE;
 		iwe.u.data.length = network->wpa_ie_len;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-                start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
 #else
-                start = iwe_stream_add_point(start, stop, &iwe, buf);
+		start = iwe_stream_add_point(start, stop, &iwe, buf);
 #endif
-        }
+	}
 	memset(&iwe, 0, sizeof(iwe));
 	if (network->rsn_ie_len)
 	{
@@ -331,11 +331,11 @@ static inline char *rtl819x_translate_sc
 		iwe.cmd = IWEVGENIE;
 		iwe.u.data.length = network->rsn_ie_len;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-                start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
 #else
-                start = iwe_stream_add_point(start, stop, &iwe, buf);
+		start = iwe_stream_add_point(start, stop, &iwe, buf);
 #endif
-        }
+	}
 #endif
 
 
@@ -348,9 +348,9 @@ static inline char *rtl819x_translate_sc
 	iwe.u.data.length = p - custom;
 	if (iwe.u.data.length)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-            start = iwe_stream_add_point(info, start, stop, &iwe, custom);
+	    start = iwe_stream_add_point(info, start, stop, &iwe, custom);
 #else
-            start = iwe_stream_add_point(start, stop, &iwe, custom);
+	    start = iwe_stream_add_point(start, stop, &iwe, custom);
 #endif
 
 	return start;
@@ -516,7 +516,7 @@ int ieee80211_wx_set_encode(struct ieee8
 				   key, escape_essid(sec.keys[key], len),
 				   erq->length, len);
 		sec.key_sizes[key] = len;
- 		(*crypt)->ops->set_key(sec.keys[key], len, NULL,
+		(*crypt)->ops->set_key(sec.keys[key], len, NULL,
 				       (*crypt)->priv);
 		sec.flags |= (1 << key);
 		/* This ensures a key will be activated if no key is
@@ -634,192 +634,192 @@ int ieee80211_wx_get_encode(struct ieee8
 }
 #if (WIRELESS_EXT >= 18)
 int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct net_device *dev = ieee->dev;
-        struct iw_point *encoding = &wrqu->encoding;
-        struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
-        int i, idx;
-        int group_key = 0;
-        const char *alg, *module;
-        struct ieee80211_crypto_ops *ops;
-        struct ieee80211_crypt_data **crypt;
-
-        struct ieee80211_security sec = {
-                .flags = 0,
-        };
+	struct iw_point *encoding = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	int i, idx;
+	int group_key = 0;
+	const char *alg, *module;
+	struct ieee80211_crypto_ops *ops;
+	struct ieee80211_crypt_data **crypt;
+
+	struct ieee80211_security sec = {
+		.flags = 0,
+	};
 	//printk("======>encoding flag:%x,ext flag:%x, ext alg:%d\n", encoding->flags,ext->ext_flags, ext->alg);
-        idx = encoding->flags & IW_ENCODE_INDEX;
-        if (idx) {
-                if (idx < 1 || idx > WEP_KEYS)
-                        return -EINVAL;
-                idx--;
-        } else
-                idx = ieee->tx_keyidx;
-
-        if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
-
-                crypt = &ieee->crypt[idx];
-
-                group_key = 1;
-        } else {
-                /* some Cisco APs use idx>0 for unicast in dynamic WEP */
+	idx = encoding->flags & IW_ENCODE_INDEX;
+	if (idx) {
+		if (idx < 1 || idx > WEP_KEYS)
+			return -EINVAL;
+		idx--;
+	} else
+		idx = ieee->tx_keyidx;
+
+	if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+
+		crypt = &ieee->crypt[idx];
+
+		group_key = 1;
+	} else {
+		/* some Cisco APs use idx>0 for unicast in dynamic WEP */
 		//printk("not group key, flags:%x, ext->alg:%d\n", ext->ext_flags, ext->alg);
-                if (idx != 0 && ext->alg != IW_ENCODE_ALG_WEP)
-                        return -EINVAL;
-                if (ieee->iw_mode == IW_MODE_INFRA)
-
-                        crypt = &ieee->crypt[idx];
-
-                else
-                        return -EINVAL;
-        }
-
-        sec.flags |= SEC_ENABLED;// | SEC_ENCRYPT;
-        if ((encoding->flags & IW_ENCODE_DISABLED) ||
-            ext->alg == IW_ENCODE_ALG_NONE) {
-                if (*crypt)
-                        ieee80211_crypt_delayed_deinit(ieee, crypt);
+		if (idx != 0 && ext->alg != IW_ENCODE_ALG_WEP)
+			return -EINVAL;
+		if (ieee->iw_mode == IW_MODE_INFRA)
 
-                for (i = 0; i < WEP_KEYS; i++)
+			crypt = &ieee->crypt[idx];
+
+		else
+			return -EINVAL;
+	}
+
+	sec.flags |= SEC_ENABLED;// | SEC_ENCRYPT;
+	if ((encoding->flags & IW_ENCODE_DISABLED) ||
+	    ext->alg == IW_ENCODE_ALG_NONE) {
+		if (*crypt)
+			ieee80211_crypt_delayed_deinit(ieee, crypt);
+
+		for (i = 0; i < WEP_KEYS; i++)
 
 			if (ieee->crypt[i] != NULL)
 
-                                break;
+				break;
 
-                if (i == WEP_KEYS) {
-                        sec.enabled = 0;
-                      //  sec.encrypt = 0;
-                        sec.level = SEC_LEVEL_0;
-                        sec.flags |= SEC_LEVEL;
-                }
+		if (i == WEP_KEYS) {
+			sec.enabled = 0;
+		      //  sec.encrypt = 0;
+			sec.level = SEC_LEVEL_0;
+			sec.flags |= SEC_LEVEL;
+		}
 		//printk("disabled: flag:%x\n", encoding->flags);
-                goto done;
-        }
+		goto done;
+	}
 
 	sec.enabled = 1;
     //    sec.encrypt = 1;
 #if 0
-        if (group_key ? !ieee->host_mc_decrypt :
-            !(ieee->host_encrypt || ieee->host_decrypt ||
-              ieee->host_encrypt_msdu))
-                goto skip_host_crypt;
-#endif
-        switch (ext->alg) {
-        case IW_ENCODE_ALG_WEP:
-                alg = "WEP";
-                module = "ieee80211_crypt_wep";
-                break;
-        case IW_ENCODE_ALG_TKIP:
-                alg = "TKIP";
-                module = "ieee80211_crypt_tkip";
-                break;
-        case IW_ENCODE_ALG_CCMP:
-                alg = "CCMP";
-                module = "ieee80211_crypt_ccmp";
-                break;
-        default:
-                IEEE80211_DEBUG_WX("%s: unknown crypto alg %d\n",
-                                   dev->name, ext->alg);
-                ret = -EINVAL;
-                goto done;
-        }
+	if (group_key ? !ieee->host_mc_decrypt :
+	    !(ieee->host_encrypt || ieee->host_decrypt ||
+	      ieee->host_encrypt_msdu))
+		goto skip_host_crypt;
+#endif
+	switch (ext->alg) {
+	case IW_ENCODE_ALG_WEP:
+		alg = "WEP";
+		module = "ieee80211_crypt_wep";
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		alg = "TKIP";
+		module = "ieee80211_crypt_tkip";
+		break;
+	case IW_ENCODE_ALG_CCMP:
+		alg = "CCMP";
+		module = "ieee80211_crypt_ccmp";
+		break;
+	default:
+		IEEE80211_DEBUG_WX("%s: unknown crypto alg %d\n",
+				   dev->name, ext->alg);
+		ret = -EINVAL;
+		goto done;
+	}
 	printk("alg name:%s\n",alg);
 
 	 ops = ieee80211_get_crypto_ops(alg);
-        if (ops == NULL) {
-                request_module(module);
-                ops = ieee80211_get_crypto_ops(alg);
-        }
-        if (ops == NULL) {
-                IEEE80211_DEBUG_WX("%s: unknown crypto alg %d\n",
-                                   dev->name, ext->alg);
+	if (ops == NULL) {
+		request_module(module);
+		ops = ieee80211_get_crypto_ops(alg);
+	}
+	if (ops == NULL) {
+		IEEE80211_DEBUG_WX("%s: unknown crypto alg %d\n",
+				   dev->name, ext->alg);
 		printk("========>unknown crypto alg %d\n", ext->alg);
-                ret = -EINVAL;
-                goto done;
-        }
+		ret = -EINVAL;
+		goto done;
+	}
 
-        if (*crypt == NULL || (*crypt)->ops != ops) {
-                struct ieee80211_crypt_data *new_crypt;
+	if (*crypt == NULL || (*crypt)->ops != ops) {
+		struct ieee80211_crypt_data *new_crypt;
 
-                ieee80211_crypt_delayed_deinit(ieee, crypt);
+		ieee80211_crypt_delayed_deinit(ieee, crypt);
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))
-                new_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);
+		new_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);
 #else
-                new_crypt = kmalloc(sizeof(*new_crypt), GFP_KERNEL);
+		new_crypt = kmalloc(sizeof(*new_crypt), GFP_KERNEL);
 		memset(new_crypt,0,sizeof(*new_crypt));
 #endif
-                if (new_crypt == NULL) {
-                        ret = -ENOMEM;
-                        goto done;
-                }
-                new_crypt->ops = ops;
-                if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
-                        new_crypt->priv = new_crypt->ops->init(idx);
-                if (new_crypt->priv == NULL) {
-                        kfree(new_crypt);
-                        ret = -EINVAL;
-                        goto done;
-                }
-                *crypt = new_crypt;
-
- 	}
-
-        if (ext->key_len > 0 && (*crypt)->ops->set_key &&
-            (*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,
-                                   (*crypt)->priv) < 0) {
-                IEEE80211_DEBUG_WX("%s: key setting failed\n", dev->name);
+		if (new_crypt == NULL) {
+			ret = -ENOMEM;
+			goto done;
+		}
+		new_crypt->ops = ops;
+		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
+			new_crypt->priv = new_crypt->ops->init(idx);
+		if (new_crypt->priv == NULL) {
+			kfree(new_crypt);
+			ret = -EINVAL;
+			goto done;
+		}
+		*crypt = new_crypt;
+
+	}
+
+	if (ext->key_len > 0 && (*crypt)->ops->set_key &&
+	    (*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,
+				   (*crypt)->priv) < 0) {
+		IEEE80211_DEBUG_WX("%s: key setting failed\n", dev->name);
 		printk("key setting failed\n");
-                ret = -EINVAL;
-                goto done;
-        }
+		ret = -EINVAL;
+		goto done;
+	}
 #if 1
  //skip_host_crypt:
 	//printk("skip_host_crypt:ext_flags:%x\n", ext->ext_flags);
-        if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
-                ieee->tx_keyidx = idx;
-                sec.active_key = idx;
-                sec.flags |= SEC_ACTIVE_KEY;
-        }
-
-        if (ext->alg != IW_ENCODE_ALG_NONE) {
-                //memcpy(sec.keys[idx], ext->key, ext->key_len);
-                sec.key_sizes[idx] = ext->key_len;
-                sec.flags |= (1 << idx);
-                if (ext->alg == IW_ENCODE_ALG_WEP) {
-                      //  sec.encode_alg[idx] = SEC_ALG_WEP;
-                        sec.flags |= SEC_LEVEL;
-                        sec.level = SEC_LEVEL_1;
-                } else if (ext->alg == IW_ENCODE_ALG_TKIP) {
-                      //  sec.encode_alg[idx] = SEC_ALG_TKIP;
-                        sec.flags |= SEC_LEVEL;
-                        sec.level = SEC_LEVEL_2;
-                } else if (ext->alg == IW_ENCODE_ALG_CCMP) {
-                       // sec.encode_alg[idx] = SEC_ALG_CCMP;
-                        sec.flags |= SEC_LEVEL;
-                        sec.level = SEC_LEVEL_3;
-                }
-                /* Don't set sec level for group keys. */
-                if (group_key)
-                        sec.flags &= ~SEC_LEVEL;
-        }
+	if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+		ieee->tx_keyidx = idx;
+		sec.active_key = idx;
+		sec.flags |= SEC_ACTIVE_KEY;
+	}
+
+	if (ext->alg != IW_ENCODE_ALG_NONE) {
+		//memcpy(sec.keys[idx], ext->key, ext->key_len);
+		sec.key_sizes[idx] = ext->key_len;
+		sec.flags |= (1 << idx);
+		if (ext->alg == IW_ENCODE_ALG_WEP) {
+		      //  sec.encode_alg[idx] = SEC_ALG_WEP;
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_1;
+		} else if (ext->alg == IW_ENCODE_ALG_TKIP) {
+		      //  sec.encode_alg[idx] = SEC_ALG_TKIP;
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_2;
+		} else if (ext->alg == IW_ENCODE_ALG_CCMP) {
+		       // sec.encode_alg[idx] = SEC_ALG_CCMP;
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_3;
+		}
+		/* Don't set sec level for group keys. */
+		if (group_key)
+			sec.flags &= ~SEC_LEVEL;
+	}
 #endif
 done:
-        if (ieee->set_security)
-                ieee->set_security(ieee->dev, &sec);
+	if (ieee->set_security)
+		ieee->set_security(ieee->dev, &sec);
 
 	 if (ieee->reset_on_keychange &&
-            ieee->iw_mode != IW_MODE_INFRA &&
-            ieee->reset_port && ieee->reset_port(dev)) {
-                IEEE80211_DEBUG_WX("%s: reset_port failed\n", dev->name);
-                return -EINVAL;
-        }
+	    ieee->iw_mode != IW_MODE_INFRA &&
+	    ieee->reset_port && ieee->reset_port(dev)) {
+		IEEE80211_DEBUG_WX("%s: reset_port failed\n", dev->name);
+		return -EINVAL;
+	}
 #endif
-        return ret;
+	return ret;
 }
 
 int ieee80211_wx_get_encode_ext(struct ieee80211_device *ieee,
@@ -878,46 +878,46 @@ int ieee80211_wx_get_encode_ext(struct i
 }
 
 int ieee80211_wx_set_mlme(struct ieee80211_device *ieee,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 {
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct iw_mlme *mlme = (struct iw_mlme *) extra;
 	switch (mlme->cmd) {
-        case IW_MLME_DEAUTH:
+	case IW_MLME_DEAUTH:
 	case IW_MLME_DISASSOC:
 		ieee80211_disassociate(ieee);
 		break;
 	 default:
-                return -EOPNOTSUPP;
-        }
+		return -EOPNOTSUPP;
+	}
 #endif
 	return 0;
 }
 
 int ieee80211_wx_set_auth(struct ieee80211_device *ieee,
-                               struct iw_request_info *info,
-                               struct iw_param *data, char *extra)
+			       struct iw_request_info *info,
+			       struct iw_param *data, char *extra)
 {
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	switch (data->flags & IW_AUTH_INDEX) {
-        case IW_AUTH_WPA_VERSION:
+	case IW_AUTH_WPA_VERSION:
 	     /*need to support wpa2 here*/
 		//printk("wpa version:%x\n", data->value);
 		break;
-        case IW_AUTH_CIPHER_PAIRWISE:
-        case IW_AUTH_CIPHER_GROUP:
-        case IW_AUTH_KEY_MGMT:
-                /*
+	case IW_AUTH_CIPHER_PAIRWISE:
+	case IW_AUTH_CIPHER_GROUP:
+	case IW_AUTH_KEY_MGMT:
+		/*
  *                  * Host AP driver does not use these parameters and allows
  *                                   * wpa_supplicant to control them internally.
  *                                                    */
-                break;
-        case IW_AUTH_TKIP_COUNTERMEASURES:
-                ieee->tkip_countermeasures = data->value;
-                break;
-        case IW_AUTH_DROP_UNENCRYPTED:
-                ieee->drop_unencrypted = data->value;
+		break;
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+		ieee->tkip_countermeasures = data->value;
+		break;
+	case IW_AUTH_DROP_UNENCRYPTED:
+		ieee->drop_unencrypted = data->value;
 		break;
 
 	case IW_AUTH_80211_AUTH_ALG:
@@ -949,13 +949,13 @@ int ieee80211_wx_set_auth(struct ieee802
 
 #endif
 	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
-                ieee->ieee802_1x = data->value;
+		ieee->ieee802_1x = data->value;
 		break;
 	case IW_AUTH_PRIVACY_INVOKED:
 		ieee->privacy_invoked = data->value;
 		break;
 	default:
-                return -EOPNOTSUPP;
+		return -EOPNOTSUPP;
 	}
 #endif
 	return 0;
--- a/drivers/staging/rtl8192u/ieee80211/proc.c
+++ b/drivers/staging/rtl8192u/ieee80211/proc.c
@@ -73,7 +73,7 @@ static int c_show(struct seq_file *m, vo
 		seq_printf(m, "type         : digest\n");
 		seq_printf(m, "blocksize    : %u\n", alg->cra_blocksize);
 		seq_printf(m, "digestsize   : %u\n",
-		           alg->cra_digest.dia_digestsize);
+			   alg->cra_digest.dia_digestsize);
 		break;
 	case CRYPTO_ALG_TYPE_COMPRESS:
 		seq_printf(m, "type         : compression\n");
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_HT.h
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_HT.h
@@ -437,7 +437,7 @@ extern u8 MCS_FILTER_1SS[16];
 
 // MCS Bw 40 {1~7, 12~15,32}
 #define	RATE_ADPT_1SS_MASK 		0xFF
-#define	RATE_ADPT_2SS_MASK	   	0xF0 //Skip MCS8~11 because mcs7 > mcs6, 9, 10, 11. 2007.01.16 by Emily
+#define	RATE_ADPT_2SS_MASK		0xF0 //Skip MCS8~11 because mcs7 > mcs6, 9, 10, 11. 2007.01.16 by Emily
 #define	RATE_ADPT_MCS32_MASK		0x01
 
 #define 	IS_11N_MCS_RATE(rate)		(rate&0x80)
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c
@@ -361,11 +361,11 @@ bool IsHTHalfNmodeAPs(struct ieee80211_d
 		     (net->ralink_cap_exist))
 		retValue = true;
 	else if((memcmp(net->bssid, UNKNOWN_BORADCOM, 3)==0) ||
-    		    (memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)||
-    		    (memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)==0)||
-    		    (memcmp(net->bssid, NETGEAR834Bv2_BROADCOM, 3)==0) ||
-    		    (net->broadcom_cap_exist))
-    		  retValue = true;
+		    (memcmp(net->bssid, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)||
+		    (memcmp(net->bssid, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)==0)||
+		    (memcmp(net->bssid, NETGEAR834Bv2_BROADCOM, 3)==0) ||
+		    (net->broadcom_cap_exist))
+		  retValue = true;
 	else if(net->bssht.bdRT2RTAggregation)
 		retValue = true;
 	else
@@ -425,7 +425,7 @@ u8 HTIOTActIsDisableMCS14(struct ieee802
 	// Apply for 819u only
 #if (HAL_CODE_BASE==RTL8192 && DEV_BUS_TYPE==USB_INTERFACE)
 	if((memcmp(PeerMacAddr, UNKNOWN_BORADCOM, 3)==0) ||
-    		(memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)
+		(memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)
 	    )
 	{
 		ret = 1;
@@ -569,8 +569,8 @@ u8 HTIOTActIsCCDFsync(u8* PeerMacAddr)
 {
 	u8	retValue = 0;
 	if(	(memcmp(PeerMacAddr, UNKNOWN_BORADCOM, 3)==0) ||
-	    	(memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0) ||
-	    	(memcmp(PeerMacAddr, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3) ==0))
+		(memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0) ||
+		(memcmp(PeerMacAddr, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3) ==0))
 	{
 		retValue = 1;
 	}
@@ -648,7 +648,7 @@ void HTConstructCapabilityElement(struct
 
 
 	//MAC HT parameters info
-        // TODO: Nedd to take care of this part
+	// TODO: Nedd to take care of this part
 	IEEE80211_DEBUG(IEEE80211_DL_HT, "TX HT cap/info ele BW=%d MaxAMSDUSize:%d DssCCk:%d\n", pCapELE->ChlWidth, pCapELE->MaxAMSDUSize, pCapELE->DssCCk);
 
 	if( IsEncrypt)
@@ -1662,7 +1662,7 @@ void HTSetConnectBwMode(struct ieee80211
 	//if in half N mode, set to 20M bandwidth please 09.08.2008 WB.
 	if(Bandwidth==HT_CHANNEL_WIDTH_20_40 && (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev)))
 	 {
-	 		// Handle Illegal extention channel offset!!
+			// Handle Illegal extention channel offset!!
 		if(ieee->current_network.channel<2 && Offset==HT_EXTCHNL_OFFSET_LOWER)
 			Offset = HT_EXTCHNL_OFFSET_NO_EXT;
 		if(Offset==HT_EXTCHNL_OFFSET_UPPER || Offset==HT_EXTCHNL_OFFSET_LOWER) {
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h
@@ -647,18 +647,18 @@ typedef struct _QOS_TSTREAM{
 //      802.11 Management frame Status Code field
 //----------------------------------------------------------------------------
 typedef struct _OCTET_STRING{
-        u8        	*Octet;
-        u16             Length;
+	u8        	*Octet;
+	u16             Length;
 }OCTET_STRING, *POCTET_STRING;
 #if 0
 #define FillOctetString(_os,_octet,_len)             \
-        (_os).Octet=(u8 *)(_octet);                  \
-        (_os).Length=(_len);
+	(_os).Octet=(u8 *)(_octet);                  \
+	(_os).Length=(_len);
 
 #define WMM_ELEM_HDR_LEN        		     6
 #define WMMElemSkipHdr(_osWMMElem)                   \
-        (_osWMMElem).Octet += WMM_ELEM_HDR_LEN;      \
-        (_osWMMElem).Length -= WMM_ELEM_HDR_LEN;
+	(_osWMMElem).Octet += WMM_ELEM_HDR_LEN;      \
+	(_osWMMElem).Length -= WMM_ELEM_HDR_LEN;
 #endif
 //
 // STA QoS data.
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
@@ -509,31 +509,31 @@ void RemoveTsEntry(
 		if(timer_pending(&pRxTS->RxPktPendingTimer))
 			del_timer_sync(&pRxTS->RxPktPendingTimer);
 
-                while(!list_empty(&pRxTS->RxPendingPktList))
-                {
-                //      PlatformAcquireSpinLock(Adapter, RT_RX_SPINLOCK);
-                        spin_lock_irqsave(&(ieee->reorder_spinlock), flags);
-                        //pRxReorderEntry = list_entry(&pRxTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
+		while(!list_empty(&pRxTS->RxPendingPktList))
+		{
+		//      PlatformAcquireSpinLock(Adapter, RT_RX_SPINLOCK);
+			spin_lock_irqsave(&(ieee->reorder_spinlock), flags);
+			//pRxReorderEntry = list_entry(&pRxTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
 			pRxReorderEntry = (PRX_REORDER_ENTRY)list_entry(pRxTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
-                        list_del_init(&pRxReorderEntry->List);
-                        {
-                                int i = 0;
-                                struct ieee80211_rxb * prxb = pRxReorderEntry->prxb;
+			list_del_init(&pRxReorderEntry->List);
+			{
+				int i = 0;
+				struct ieee80211_rxb * prxb = pRxReorderEntry->prxb;
 				if (unlikely(!prxb))
 				{
 					spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
 					return;
 				}
-                                for(i =0; i < prxb->nr_subframes; i++) {
-                                        dev_kfree_skb(prxb->subframes[i]);
-                                }
-                                kfree(prxb);
-                                prxb = NULL;
-                        }
-                        list_add_tail(&pRxReorderEntry->List,&ieee->RxReorder_Unused_List);
-                        //PlatformReleaseSpinLock(Adapter, RT_RX_SPINLOCK);
-                        spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
-                }
+				for(i =0; i < prxb->nr_subframes; i++) {
+					dev_kfree_skb(prxb->subframes[i]);
+				}
+				kfree(prxb);
+				prxb = NULL;
+			}
+			list_add_tail(&pRxReorderEntry->List,&ieee->RxReorder_Unused_List);
+			//PlatformReleaseSpinLock(Adapter, RT_RX_SPINLOCK);
+			spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
+		}
 
 //#endif
 	}
--- a/drivers/staging/rtl8192u/r8180_pm.c
+++ b/drivers/staging/rtl8192u/r8180_pm.c
@@ -17,28 +17,28 @@
 
 int rtl8180_save_state (struct pci_dev *dev, u32 state)
 {
-        printk(KERN_NOTICE "r8180 save state call (state %u).\n", state);
+	printk(KERN_NOTICE "r8180 save state call (state %u).\n", state);
 	return(-EAGAIN);
 }
 
 
 int rtl8180_suspend (struct pci_dev *dev, u32 state)
 {
-        printk(KERN_NOTICE "r8180 suspend call (state %u).\n", state);
+	printk(KERN_NOTICE "r8180 suspend call (state %u).\n", state);
 	return(-EAGAIN);
 }
 
 
 int rtl8180_resume (struct pci_dev *dev)
 {
-        printk(KERN_NOTICE "r8180 resume call.\n");
+	printk(KERN_NOTICE "r8180 resume call.\n");
 	return(-EAGAIN);
 }
 
 
 int rtl8180_enable_wake (struct pci_dev *dev, u32 state, int enable)
 {
-        printk(KERN_NOTICE "r8180 enable wake call (state %u, enable %d).\n",
+	printk(KERN_NOTICE "r8180 enable wake call (state %u, enable %d).\n",
 	       state, enable);
 	return(-EAGAIN);
 }
--- a/drivers/staging/rtl8192u/r8192U_core.c
+++ b/drivers/staging/rtl8192u/r8192U_core.c
@@ -97,7 +97,7 @@ u32 rt_global_debug_component = \
 		//		COMP_TRACE	|
 				COMP_DOWN	|
 		//		COMP_RECV	|
-                //              COMP_SWBW	|
+		//              COMP_SWBW	|
 				COMP_SEC	|
 	//			COMP_RESET	|
 		//		COMP_SEND	|
@@ -175,17 +175,17 @@ static struct usb_driver rtl8192_usb_dri
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15)
 	.owner		= THIS_MODULE,
 #endif
-	.name		= RTL819xU_MODULE_NAME,	          /* Driver name   */
-	.id_table	= rtl8192_usb_id_tbl,	          /* PCI_ID table  */
-	.probe		= rtl8192_usb_probe,	          /* probe fn      */
+	.name		= RTL819xU_MODULE_NAME,		  /* Driver name   */
+	.id_table	= rtl8192_usb_id_tbl,		  /* PCI_ID table  */
+	.probe		= rtl8192_usb_probe,		  /* probe fn      */
 	.disconnect	= rtl8192_usb_disconnect,	  /* remove fn     */
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
 #ifdef CONFIG_RTL8192_PM
-	.suspend	= rtl8192_suspend,	          /* PM suspend fn */
+	.suspend	= rtl8192_suspend,		  /* PM suspend fn */
 	.resume		= rtl8192_resume,                 /* PM resume fn  */
 #else
-	.suspend	= NULL,			          /* PM suspend fn */
-	.resume      	= NULL,			          /* PM resume fn  */
+	.suspend	= NULL,				  /* PM suspend fn */
+	.resume      	= NULL,				  /* PM resume fn  */
 #endif
 #endif
 };
@@ -282,22 +282,22 @@ void CamResetAllEntry(struct net_device 
 {
 #if 1
 	u32 ulcommand = 0;
-        //2004/02/11  In static WEP, OID_ADD_KEY or OID_ADD_WEP are set before STA associate to AP.
-        // However, ResetKey is called on OID_802_11_INFRASTRUCTURE_MODE and MlmeAssociateRequest
-        // In this condition, Cam can not be reset because upper layer will not set this static key again.
-        //if(Adapter->EncAlgorithm == WEP_Encryption)
-        //      return;
+	//2004/02/11  In static WEP, OID_ADD_KEY or OID_ADD_WEP are set before STA associate to AP.
+	// However, ResetKey is called on OID_802_11_INFRASTRUCTURE_MODE and MlmeAssociateRequest
+	// In this condition, Cam can not be reset because upper layer will not set this static key again.
+	//if(Adapter->EncAlgorithm == WEP_Encryption)
+	//      return;
 //debug
-        //DbgPrint("========================================\n");
-        //DbgPrint("                            Call ResetAllEntry                                              \n");
-        //DbgPrint("========================================\n\n");
+	//DbgPrint("========================================\n");
+	//DbgPrint("                            Call ResetAllEntry                                              \n");
+	//DbgPrint("========================================\n\n");
 	ulcommand |= BIT31|BIT30;
 	write_nic_dword(dev, RWCAM, ulcommand);
 #else
-        for(ucIndex=0;ucIndex<TOTAL_CAM_ENTRY;ucIndex++)
-                CAM_mark_invalid(dev, ucIndex);
-        for(ucIndex=0;ucIndex<TOTAL_CAM_ENTRY;ucIndex++)
-                CAM_empty_entry(dev, ucIndex);
+	for(ucIndex=0;ucIndex<TOTAL_CAM_ENTRY;ucIndex++)
+		CAM_mark_invalid(dev, ucIndex);
+	for(ucIndex=0;ucIndex<TOTAL_CAM_ENTRY;ucIndex++)
+		CAM_empty_entry(dev, ucIndex);
 #endif
 
 }
@@ -305,14 +305,14 @@ void CamResetAllEntry(struct net_device 
 
 void write_cam(struct net_device *dev, u8 addr, u32 data)
 {
-        write_nic_dword(dev, WCAMI, data);
-        write_nic_dword(dev, RWCAM, BIT31|BIT16|(addr&0xff) );
+	write_nic_dword(dev, WCAMI, data);
+	write_nic_dword(dev, RWCAM, BIT31|BIT16|(addr&0xff) );
 }
 
 u32 read_cam(struct net_device *dev, u8 addr)
 {
-        write_nic_dword(dev, RWCAM, 0x80000000|(addr&0xff) );
-        return read_nic_dword(dev, 0xa8);
+	write_nic_dword(dev, RWCAM, 0x80000000|(addr&0xff) );
+	return read_nic_dword(dev, 0xa8);
 }
 
 void write_nic_byte_E(struct net_device *dev, int indx, u8 data)
@@ -342,10 +342,10 @@ u8 read_nic_byte_E(struct net_device *de
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
 			       indx|0xfe00, 0, &data, 1, HZ / 2);
 
-        if (status < 0)
-        {
-                printk("read_nic_byte_E TimeOut! status:%d\n", status);
-        }
+	if (status < 0)
+	{
+		printk("read_nic_byte_E TimeOut! status:%d\n", status);
+	}
 
 	return data;
 }
@@ -361,10 +361,10 @@ void write_nic_byte(struct net_device *d
 			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
 			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 1, HZ / 2);
 
-        if (status < 0)
-        {
-                printk("write_nic_byte TimeOut! status:%d\n", status);
-        }
+	if (status < 0)
+	{
+		printk("write_nic_byte TimeOut! status:%d\n", status);
+	}
 
 
 }
@@ -382,10 +382,10 @@ void write_nic_word(struct net_device *d
 			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
 			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 2, HZ / 2);
 
-        if (status < 0)
-        {
-                printk("write_nic_word TimeOut! status:%d\n", status);
-        }
+	if (status < 0)
+	{
+		printk("write_nic_word TimeOut! status:%d\n", status);
+	}
 
 }
 
@@ -403,10 +403,10 @@ void write_nic_dword(struct net_device *
 			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 4, HZ / 2);
 
 
-        if (status < 0)
-        {
-                printk("write_nic_dword TimeOut! status:%d\n", status);
-        }
+	if (status < 0)
+	{
+		printk("write_nic_dword TimeOut! status:%d\n", status);
+	}
 
 }
 
@@ -423,10 +423,10 @@ u8 read_nic_byte(struct net_device *dev,
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
 			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 1, HZ / 2);
 
-        if (status < 0)
-        {
-                printk("read_nic_byte TimeOut! status:%d\n", status);
-        }
+	if (status < 0)
+	{
+		printk("read_nic_byte TimeOut! status:%d\n", status);
+	}
 
 	return data;
 }
@@ -444,10 +444,10 @@ u16 read_nic_word(struct net_device *dev
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
 			       (indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 2, HZ / 2);
 
-        if (status < 0)
-        {
-                printk("read_nic_word TimeOut! status:%d\n", status);
-        }
+	if (status < 0)
+	{
+		printk("read_nic_word TimeOut! status:%d\n", status);
+	}
 
 
 	return data;
@@ -464,10 +464,10 @@ u16 read_nic_word_E(struct net_device *d
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
 			       indx|0xfe00, 0, &data, 2, HZ / 2);
 
-        if (status < 0)
-        {
-                printk("read_nic_word TimeOut! status:%d\n", status);
-        }
+	if (status < 0)
+	{
+		printk("read_nic_word TimeOut! status:%d\n", status);
+	}
 
 
 	return data;
@@ -489,10 +489,10 @@ u32 read_nic_dword(struct net_device *de
 //	  printk(KERN_WARNING "read size of data = %d\, date = %d\n", result, data);
 //	}
 
-        if (status < 0)
-        {
-                printk("read_nic_dword TimeOut! status:%d\n", status);
-        }
+	if (status < 0)
+	{
+		printk("read_nic_dword TimeOut! status:%d\n", status);
+	}
 
 
 
@@ -542,21 +542,21 @@ static int proc_get_stats_ap(char *page,
 
 	int len = 0;
 
-        list_for_each_entry(target, &ieee->network_list, list) {
+	list_for_each_entry(target, &ieee->network_list, list) {
 
 		len += snprintf(page + len, count - len,
-                "%s ", target->ssid);
+		"%s ", target->ssid);
 
 		if(target->wpa_ie_len>0 || target->rsn_ie_len>0){
-	                len += snprintf(page + len, count - len,
-        	        "WPA\n");
+			len += snprintf(page + len, count - len,
+			"WPA\n");
 		}
 		else{
-                        len += snprintf(page + len, count - len,
-                        "non_WPA\n");
-                }
+			len += snprintf(page + len, count - len,
+			"non_WPA\n");
+		}
 
-        }
+	}
 
 	*eof = 1;
 	return len;
@@ -576,7 +576,7 @@ static int proc_get_registers(char *page
 
 	/* This dump the current register page */
 len += snprintf(page + len, count - len,
-                        "\n####################page 0##################\n ");
+			"\n####################page 0##################\n ");
 
 	for(n=0;n<=max;)
 	{
@@ -592,33 +592,33 @@ len += snprintf(page + len, count - len,
 	}
 #if 1
 len += snprintf(page + len, count - len,
-                        "\n####################page 1##################\n ");
-        for(n=0;n<=max;)
-        {
-                //printk( "\nD: %2x> ", n);
-                len += snprintf(page + len, count - len,
-                        "\nD:  %2x > ",n);
-
-                for(i=0;i<16 && n<=max;i++,n++)
-                len += snprintf(page + len, count - len,
-                        "%2x ",read_nic_byte(dev,0x100|n));
+			"\n####################page 1##################\n ");
+	for(n=0;n<=max;)
+	{
+		//printk( "\nD: %2x> ", n);
+		len += snprintf(page + len, count - len,
+			"\nD:  %2x > ",n);
 
-                //      printk("%2x ",read_nic_byte(dev,n));
-        }
+		for(i=0;i<16 && n<=max;i++,n++)
+		len += snprintf(page + len, count - len,
+			"%2x ",read_nic_byte(dev,0x100|n));
+
+		//      printk("%2x ",read_nic_byte(dev,n));
+	}
 len += snprintf(page + len, count - len,
-                        "\n####################page 3##################\n ");
-        for(n=0;n<=max;)
-        {
-                //printk( "\nD: %2x> ", n);
-                len += snprintf(page + len, count - len,
-                        "\nD:  %2x > ",n);
-
-                for(i=0;i<16 && n<=max;i++,n++)
-                len += snprintf(page + len, count - len,
-                        "%2x ",read_nic_byte(dev,0x300|n));
+			"\n####################page 3##################\n ");
+	for(n=0;n<=max;)
+	{
+		//printk( "\nD: %2x> ", n);
+		len += snprintf(page + len, count - len,
+			"\nD:  %2x > ",n);
 
-                //      printk("%2x ",read_nic_byte(dev,n));
-        }
+		for(i=0;i<16 && n<=max;i++,n++)
+		len += snprintf(page + len, count - len,
+			"%2x ",read_nic_byte(dev,0x300|n));
+
+		//      printk("%2x ",read_nic_byte(dev,n));
+	}
 
 #endif
 
@@ -1154,64 +1154,64 @@ u32 get_rxpacket_shiftbytes_819xusb(stru
 }
 static int rtl8192_rx_initiate(struct net_device*dev)
 {
-        struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-        struct urb *entry;
-        struct sk_buff *skb;
-        struct rtl8192_rx_info *info;
+	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
+	struct urb *entry;
+	struct sk_buff *skb;
+	struct rtl8192_rx_info *info;
 
 	/* nomal packet rx procedure */
-        while (skb_queue_len(&priv->rx_queue) < MAX_RX_URB) {
-                skb = __dev_alloc_skb(RX_URB_SIZE, GFP_KERNEL);
-                if (!skb)
-                        break;
+	while (skb_queue_len(&priv->rx_queue) < MAX_RX_URB) {
+		skb = __dev_alloc_skb(RX_URB_SIZE, GFP_KERNEL);
+		if (!skb)
+			break;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-	        entry = usb_alloc_urb(0, GFP_KERNEL);
+		entry = usb_alloc_urb(0, GFP_KERNEL);
 #else
-	        entry = usb_alloc_urb(0);
+		entry = usb_alloc_urb(0);
 #endif
-                if (!entry) {
-                        kfree_skb(skb);
-                        break;
-                }
+		if (!entry) {
+			kfree_skb(skb);
+			break;
+		}
 //		printk("nomal packet IN request!\n");
-                usb_fill_bulk_urb(entry, priv->udev,
-                                  usb_rcvbulkpipe(priv->udev, 3), skb_tail_pointer(skb),
-                                  RX_URB_SIZE, rtl8192_rx_isr, skb);
-                info = (struct rtl8192_rx_info *) skb->cb;
-                info->urb = entry;
-                info->dev = dev;
+		usb_fill_bulk_urb(entry, priv->udev,
+				  usb_rcvbulkpipe(priv->udev, 3), skb_tail_pointer(skb),
+				  RX_URB_SIZE, rtl8192_rx_isr, skb);
+		info = (struct rtl8192_rx_info *) skb->cb;
+		info->urb = entry;
+		info->dev = dev;
 		info->out_pipe = 3; //denote rx normal packet queue
-                skb_queue_tail(&priv->rx_queue, skb);
-                usb_submit_urb(entry, GFP_KERNEL);
-        }
+		skb_queue_tail(&priv->rx_queue, skb);
+		usb_submit_urb(entry, GFP_KERNEL);
+	}
 
 	/* command packet rx procedure */
-        while (skb_queue_len(&priv->rx_queue) < MAX_RX_URB + 3) {
+	while (skb_queue_len(&priv->rx_queue) < MAX_RX_URB + 3) {
 //		printk("command packet IN request!\n");
-                skb = __dev_alloc_skb(RX_URB_SIZE ,GFP_KERNEL);
-                if (!skb)
-                        break;
+		skb = __dev_alloc_skb(RX_URB_SIZE ,GFP_KERNEL);
+		if (!skb)
+			break;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-                entry = usb_alloc_urb(0, GFP_KERNEL);
+		entry = usb_alloc_urb(0, GFP_KERNEL);
 #else
-                entry = usb_alloc_urb(0);
+		entry = usb_alloc_urb(0);
 #endif
-                if (!entry) {
-                        kfree_skb(skb);
-                        break;
-                }
-                usb_fill_bulk_urb(entry, priv->udev,
-                                  usb_rcvbulkpipe(priv->udev, 9), skb_tail_pointer(skb),
-                                  RX_URB_SIZE, rtl8192_rx_isr, skb);
-                info = (struct rtl8192_rx_info *) skb->cb;
-                info->urb = entry;
-                info->dev = dev;
+		if (!entry) {
+			kfree_skb(skb);
+			break;
+		}
+		usb_fill_bulk_urb(entry, priv->udev,
+				  usb_rcvbulkpipe(priv->udev, 9), skb_tail_pointer(skb),
+				  RX_URB_SIZE, rtl8192_rx_isr, skb);
+		info = (struct rtl8192_rx_info *) skb->cb;
+		info->urb = entry;
+		info->dev = dev;
 		   info->out_pipe = 9; //denote rx cmd packet queue
-                skb_queue_tail(&priv->rx_queue, skb);
+		skb_queue_tail(&priv->rx_queue, skb);
 		usb_submit_urb(entry, GFP_KERNEL);
-        }
+	}
 
-        return 0;
+	return 0;
 }
 
 void rtl8192_set_rxconf(struct net_device *dev)
@@ -1543,53 +1543,53 @@ static void rtl8192_rx_isr(struct urb *u
 static void rtl8192_rx_isr(struct urb *urb)
 #endif
 {
-        struct sk_buff *skb = (struct sk_buff *) urb->context;
-        struct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
-        struct net_device *dev = info->dev;
+	struct sk_buff *skb = (struct sk_buff *) urb->context;
+	struct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
+	struct net_device *dev = info->dev;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	int out_pipe = info->out_pipe;
 	int err;
 	if(!priv->up)
 		return;
-        if (unlikely(urb->status)) {
-                info->urb = NULL;
-                priv->stats.rxstaterr++;
-                priv->ieee80211->stats.rx_errors++;
-                usb_free_urb(urb);
+	if (unlikely(urb->status)) {
+		info->urb = NULL;
+		priv->stats.rxstaterr++;
+		priv->ieee80211->stats.rx_errors++;
+		usb_free_urb(urb);
 	//	printk("%s():rx status err\n",__FUNCTION__);
-                return;
-        }
+		return;
+	}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
-        skb_unlink(skb, &priv->rx_queue);
+	skb_unlink(skb, &priv->rx_queue);
 #else
-        __skb_unlink(skb,&priv->rx_queue);
+	__skb_unlink(skb,&priv->rx_queue);
 #endif
-        skb_put(skb, urb->actual_length);
+	skb_put(skb, urb->actual_length);
 
 	skb_queue_tail(&priv->skb_queue, skb);
 	tasklet_schedule(&priv->irq_rx_tasklet);
 
-        skb = dev_alloc_skb(RX_URB_SIZE);
-        if (unlikely(!skb)) {
-                usb_free_urb(urb);
+	skb = dev_alloc_skb(RX_URB_SIZE);
+	if (unlikely(!skb)) {
+		usb_free_urb(urb);
 		printk("%s():can,t alloc skb\n",__FUNCTION__);
-                /* TODO check rx queue length and refill *somewhere* */
-                return;
-        }
+		/* TODO check rx queue length and refill *somewhere* */
+		return;
+	}
 
 	usb_fill_bulk_urb(urb, priv->udev,
 			usb_rcvbulkpipe(priv->udev, out_pipe), skb_tail_pointer(skb),
 			RX_URB_SIZE, rtl8192_rx_isr, skb);
 
-        info = (struct rtl8192_rx_info *) skb->cb;
-        info->urb = urb;
-        info->dev = dev;
+	info = (struct rtl8192_rx_info *) skb->cb;
+	info->urb = urb;
+	info->dev = dev;
 	info->out_pipe = out_pipe;
 
-        urb->transfer_buffer = skb_tail_pointer(skb);
-        urb->context = skb;
-        skb_queue_tail(&priv->rx_queue, skb);
-        err = usb_submit_urb(urb, GFP_ATOMIC);
+	urb->transfer_buffer = skb_tail_pointer(skb);
+	urb->context = skb;
+	skb_queue_tail(&priv->rx_queue, skb);
+	err = usb_submit_urb(urb, GFP_ATOMIC);
 	if(err && err != EPERM)
 		printk("can not submit rxurb, err is %x,URB status is %x\n",err,urb->status);
 }
@@ -1674,7 +1674,7 @@ void rtl8192_hard_data_xmit(struct sk_bu
 
 	spin_lock_irqsave(&priv->tx_lock,flags);
 
-        memcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));
+	memcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));
 //	tcb_desc->RATRIndex = 7;
 //	tcb_desc->bTxDisableRateFallBack = 1;
 //	tcb_desc->bTxUseDriverAssingedRate = 1;
@@ -1701,18 +1701,18 @@ int rtl8192_hard_start_xmit(struct sk_bu
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 	int ret;
 	unsigned long flags;
-        cb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
-        u8 queue_index = tcb_desc->queue_index;
+	cb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
+	u8 queue_index = tcb_desc->queue_index;
 
 
 	spin_lock_irqsave(&priv->tx_lock,flags);
 
-        memcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));
+	memcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));
 	if(queue_index == TXCMD_QUEUE) {
 		skb_push(skb, USB_HWDESC_HEADER_LEN);
 		rtl819xU_tx_cmd(dev, skb);
 		ret = 1;
-	        spin_unlock_irqrestore(&priv->tx_lock,flags);
+		spin_unlock_irqrestore(&priv->tx_lock,flags);
 		return ret;
 	} else {
 		skb_push(skb, priv->ieee80211->tx_headroom);
@@ -1780,7 +1780,7 @@ struct sk_buff *DrvAggr_Aggregation(stru
 	tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 	tcb_desc->drv_agg_enable = 1;
 	tcb_desc->pkt_size = skb->len;
- 	tcb_desc->DrvAggrNum = pSendList->nr_drv_agg_frames;
+	tcb_desc->DrvAggrNum = pSendList->nr_drv_agg_frames;
 	printk("DrvAggNum = %d\n", tcb_desc->DrvAggrNum);
 //	RT_DEBUG_DATA(COMP_SEND, skb->cb, sizeof(skb->cb));
 //	printk("========>skb->data ======> \n");
@@ -2061,7 +2061,7 @@ static void rtl8192_tx_isr(struct urb *t
 			}
 #ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
 			else if ((skb_queue_len(&priv->ieee80211->skb_drv_aggQ[queue_index])!= 0)&&\
- 				(!(priv->ieee80211->queue_stop))) {
+				(!(priv->ieee80211->queue_stop))) {
 				// Tx Driver Aggregation process
 				/* The driver will aggregation the packets according to the following stets
 				 * 1. check whether there's tx irq available, for it's a completion return
@@ -2083,7 +2083,7 @@ static void rtl8192_tx_isr(struct urb *t
 					u8* pHeader = skb->data;
 
 					if(IsMgntQosData(pHeader) ||
-				            IsMgntQData_Ack(pHeader) ||
+					    IsMgntQData_Ack(pHeader) ||
 					    IsMgntQData_Poll(pHeader) ||
 					    IsMgntQData_Poll_Ack(pHeader)
 					  )
@@ -2253,7 +2253,7 @@ void rtl8192_net_update(struct net_devic
 	write_nic_byte(dev, BCN_ERR_THRESH, 100);
 		BcnTimeCfg |= (BcnCW<<BCN_TCFG_CW_SHIFT);
 	// TODO: BcnIFS may required to be changed on ASIC
-	 	BcnTimeCfg |= BcnIFS<<BCN_TCFG_IFS;
+		BcnTimeCfg |= BcnIFS<<BCN_TCFG_IFS;
 
 	write_nic_word(dev, BCN_TCFG, BcnTimeCfg);
 	}
@@ -2641,7 +2641,7 @@ short rtl8192_tx(struct net_device *dev,
 //	RT_DEBUG_DATA(COMP_SEND, tcb_desc, sizeof(cb_desc));
 #if 0
 	/* Added by Annie for filling Len_Adjust field. 2005-12-14. */
-        RT_ENC_ALG  EncAlg = NO_Encryption;
+	RT_ENC_ALG  EncAlg = NO_Encryption;
 #endif
 //	printk("=============> %s\n", __FUNCTION__);
 	pend = atomic_read(&priv->tx_pending[tcb_desc->queue_index]);
@@ -2735,9 +2735,9 @@ short rtl8192_tx(struct net_device *dev,
 	/* Fill Tx descriptor */
 	memset(tx_desc, 0, sizeof(tx_desc_819x_usb));
 	/* DWORD 0 */
-        tx_desc->LINIP = 0;
-        tx_desc->CmdInit = 1;
-        tx_desc->Offset =  sizeof(tx_fwinfo_819x_usb) + 8;
+	tx_desc->LINIP = 0;
+	tx_desc->CmdInit = 1;
+	tx_desc->Offset =  sizeof(tx_fwinfo_819x_usb) + 8;
 
 #ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
 	if (tcb_desc->drv_agg_enable) {
@@ -2828,16 +2828,16 @@ short rtl8192_tx(struct net_device *dev,
 	tx_desc->DISFB = tcb_desc->bTxDisableRateFallBack;
 	tx_desc->USERATE = tcb_desc->bTxUseDriverAssingedRate;
 
-        /* Fill fields that are required to be initialized in all of the descriptors */
-        //DWORD 0
+	/* Fill fields that are required to be initialized in all of the descriptors */
+	//DWORD 0
 #if 0
-        tx_desc->FirstSeg = (tcb_desc->bFirstSeg)? 1:0;
-        tx_desc->LastSeg = (tcb_desc->bLastSeg)?1:0;
+	tx_desc->FirstSeg = (tcb_desc->bFirstSeg)? 1:0;
+	tx_desc->LastSeg = (tcb_desc->bLastSeg)?1:0;
 #else
-        tx_desc->FirstSeg = 1;
-        tx_desc->LastSeg = 1;
+	tx_desc->FirstSeg = 1;
+	tx_desc->LastSeg = 1;
 #endif
-        tx_desc->OWN = 1;
+	tx_desc->OWN = 1;
 
 #ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
 	if (tcb_desc->drv_agg_enable) {
@@ -2959,29 +2959,29 @@ short rtl8192_usb_initendpoints(struct n
 }
 #endif
 
-        memset(priv->rx_urb, 0, sizeof(struct urb*) * MAX_RX_URB);
-        priv->pp_rxskb = (struct sk_buff **)kmalloc(sizeof(struct sk_buff *) * MAX_RX_URB, GFP_KERNEL);
-        if (priv->pp_rxskb == NULL)
-                goto destroy;
+	memset(priv->rx_urb, 0, sizeof(struct urb*) * MAX_RX_URB);
+	priv->pp_rxskb = (struct sk_buff **)kmalloc(sizeof(struct sk_buff *) * MAX_RX_URB, GFP_KERNEL);
+	if (priv->pp_rxskb == NULL)
+		goto destroy;
 
-        memset(priv->pp_rxskb, 0, sizeof(struct sk_buff*) * MAX_RX_URB);
+	memset(priv->pp_rxskb, 0, sizeof(struct sk_buff*) * MAX_RX_URB);
 
-        goto _middle;
+	goto _middle;
 
 
 destroy:
-        if (priv->pp_rxskb) {
-                kfree(priv->pp_rxskb);
-        }
-        if (priv->rx_urb) {
-                kfree(priv->rx_urb);
-        }
+	if (priv->pp_rxskb) {
+		kfree(priv->pp_rxskb);
+	}
+	if (priv->rx_urb) {
+		kfree(priv->rx_urb);
+	}
 
-        priv->pp_rxskb = NULL;
+	priv->pp_rxskb = NULL;
 	priv->rx_urb = NULL;
 
-        DMESGE("Endpoint Alloc Failure");
-        return -ENOMEM;
+	DMESGE("Endpoint Alloc Failure");
+	return -ENOMEM;
 
 
 _middle:
@@ -3008,9 +3008,9 @@ void rtl8192_usb_deleteendpoints(struct 
 		kfree(priv->oldaddr);
 		priv->oldaddr = NULL;
 	}
-        if (priv->pp_rxskb) {
-                kfree(priv->pp_rxskb);
-                priv->pp_rxskb = 0;
+	if (priv->pp_rxskb) {
+		kfree(priv->pp_rxskb);
+		priv->pp_rxskb = 0;
 	}
 }
 #else
@@ -3033,18 +3033,18 @@ void rtl8192_usb_deleteendpoints(struct 
 	}
 #else
 	if(priv->rx_urb){
-                kfree(priv->rx_urb);
-                priv->rx_urb = NULL;
-        }
+		kfree(priv->rx_urb);
+		priv->rx_urb = NULL;
+	}
 	if(priv->oldaddr){
 		kfree(priv->oldaddr);
 		priv->oldaddr = NULL;
 	}
-        if (priv->pp_rxskb) {
-                kfree(priv->pp_rxskb);
-                priv->pp_rxskb = 0;
+	if (priv->pp_rxskb) {
+		kfree(priv->pp_rxskb);
+		priv->pp_rxskb = 0;
 
-        }
+	}
 
 #endif
 }
@@ -3157,29 +3157,29 @@ int WDCAPARA_ADD[] = {EDCAPARA_BE,EDCAPA
 #if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,20)
 void rtl8192_qos_activate(struct work_struct * work)
 {
-        struct r8192_priv *priv = container_of(work, struct r8192_priv, qos_activate);
-        struct net_device *dev = priv->ieee80211->dev;
+	struct r8192_priv *priv = container_of(work, struct r8192_priv, qos_activate);
+	struct net_device *dev = priv->ieee80211->dev;
 #else
 void rtl8192_qos_activate(struct net_device *dev)
 {
-        struct r8192_priv *priv = ieee80211_priv(dev);
+	struct r8192_priv *priv = ieee80211_priv(dev);
 #endif
-        struct ieee80211_qos_parameters *qos_parameters = &priv->ieee80211->current_network.qos_data.parameters;
-        u8 mode = priv->ieee80211->current_network.mode;
-        //u32 size = sizeof(struct ieee80211_qos_parameters);
+	struct ieee80211_qos_parameters *qos_parameters = &priv->ieee80211->current_network.qos_data.parameters;
+	u8 mode = priv->ieee80211->current_network.mode;
+	//u32 size = sizeof(struct ieee80211_qos_parameters);
 	u8  u1bAIFS;
 	u32 u4bAcParam;
-        int i;
+	int i;
 
-        if (priv == NULL)
-                return;
+	if (priv == NULL)
+		return;
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
 	down(&priv->mutex);
 #else
        mutex_lock(&priv->mutex);
 #endif
-        if(priv->ieee80211->state != IEEE80211_LINKED)
+	if(priv->ieee80211->state != IEEE80211_LINKED)
 		goto success;
 	RT_TRACE(COMP_QOS,"qos active process with associate response received\n");
 	/* It better set slot time at first */
@@ -3213,10 +3213,10 @@ static int rtl8192_qos_handle_probe_resp
 	u32 size = sizeof(struct ieee80211_qos_parameters);
 
 	if(priv->ieee80211->state !=IEEE80211_LINKED)
-                return ret;
+		return ret;
 
-        if ((priv->ieee80211->iw_mode != IW_MODE_INFRA))
-                return ret;
+	if ((priv->ieee80211->iw_mode != IW_MODE_INFRA))
+		return ret;
 
 	if (network->flags & NETWORK_HAS_QOS_MASK) {
 		if (active_network &&
@@ -3258,8 +3258,8 @@ static int rtl8192_qos_handle_probe_resp
 
 /* handle manage frame frame beacon and probe response */
 static int rtl8192_handle_beacon(struct net_device * dev,
-                              struct ieee80211_beacon * beacon,
-                              struct ieee80211_network * network)
+			      struct ieee80211_beacon * beacon,
+			      struct ieee80211_network * network)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -3284,23 +3284,23 @@ static int rtl8192_handle_beacon(struct 
 * setting
 */
 static int rtl8192_qos_association_resp(struct r8192_priv *priv,
-                                    struct ieee80211_network *network)
+				    struct ieee80211_network *network)
 {
-        int ret = 0;
-        unsigned long flags;
-        u32 size = sizeof(struct ieee80211_qos_parameters);
-        int set_qos_param = 0;
+	int ret = 0;
+	unsigned long flags;
+	u32 size = sizeof(struct ieee80211_qos_parameters);
+	int set_qos_param = 0;
 
-        if ((priv == NULL) || (network == NULL))
-                return ret;
+	if ((priv == NULL) || (network == NULL))
+		return ret;
 
 	if(priv->ieee80211->state !=IEEE80211_LINKED)
-                return ret;
+		return ret;
 
-        if ((priv->ieee80211->iw_mode != IW_MODE_INFRA))
-                return ret;
+	if ((priv->ieee80211->iw_mode != IW_MODE_INFRA))
+		return ret;
 
-        spin_lock_irqsave(&priv->ieee80211->lock, flags);
+	spin_lock_irqsave(&priv->ieee80211->lock, flags);
 	if(network->flags & NETWORK_HAS_QOS_PARAMETERS) {
 		memcpy(&priv->ieee80211->current_network.qos_data.parameters,\
 			 &network->qos_data.parameters,\
@@ -3311,22 +3311,22 @@ static int rtl8192_qos_association_resp(
 					network->qos_data.param_count))
 #endif
 		 {
-                        set_qos_param = 1;
+			set_qos_param = 1;
 			/* update qos parameter for current network */
 			priv->ieee80211->current_network.qos_data.old_param_count = \
 				 priv->ieee80211->current_network.qos_data.param_count;
 			priv->ieee80211->current_network.qos_data.param_count = \
-			     	 network->qos_data.param_count;
+				 network->qos_data.param_count;
 		}
-        } else {
+	} else {
 		memcpy(&priv->ieee80211->current_network.qos_data.parameters,\
 		       &def_qos_parameters, size);
 		priv->ieee80211->current_network.qos_data.active = 0;
 		priv->ieee80211->current_network.qos_data.supported = 0;
-                set_qos_param = 1;
-        }
+		set_qos_param = 1;
+	}
 
-        spin_unlock_irqrestore(&priv->ieee80211->lock, flags);
+	spin_unlock_irqrestore(&priv->ieee80211->lock, flags);
 
 	RT_TRACE(COMP_QOS, "%s: network->flags = %d,%d\n",__FUNCTION__,network->flags ,priv->ieee80211->current_network.qos_data.active);
 	if (set_qos_param == 1)
@@ -3337,17 +3337,17 @@ static int rtl8192_qos_association_resp(
 #endif
 
 
-        return ret;
+	return ret;
 }
 
 
 static int rtl8192_handle_assoc_response(struct net_device *dev,
-                                     struct ieee80211_assoc_response_frame *resp,
-                                     struct ieee80211_network *network)
+				     struct ieee80211_assoc_response_frame *resp,
+				     struct ieee80211_network *network)
 {
-        struct r8192_priv *priv = ieee80211_priv(dev);
-        rtl8192_qos_association_resp(priv, network);
-        return 0;
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	rtl8192_qos_association_resp(priv, network);
+	return 0;
 }
 
 
@@ -3408,13 +3408,13 @@ bool GetNmodeSupportBySecCfg8192(struct 
 	struct r8192_priv* priv = ieee80211_priv(dev);
 	struct ieee80211_device* ieee = priv->ieee80211;
 	struct ieee80211_network * network = &ieee->current_network;
-        int wpa_ie_len= ieee->wpa_ie_len;
-        struct ieee80211_crypt_data* crypt;
-        int encrypt;
+	int wpa_ie_len= ieee->wpa_ie_len;
+	struct ieee80211_crypt_data* crypt;
+	int encrypt;
 
-        crypt = ieee->crypt[ieee->tx_keyidx];
+	crypt = ieee->crypt[ieee->tx_keyidx];
 	//we use connecting AP's capability instead of only security config on our driver to distinguish whether it should use N mode or G mode
-        encrypt = (network->capability & WLAN_CAPABILITY_PRIVACY) || (ieee->host_encrypt && crypt && crypt->ops && (0 == strcmp(crypt->ops->name,"WEP")));
+	encrypt = (network->capability & WLAN_CAPABILITY_PRIVACY) || (ieee->host_encrypt && crypt && crypt->ops && (0 == strcmp(crypt->ops->name,"WEP")));
 
 	/* simply judge  */
 	if(encrypt && (wpa_ie_len == 0)) {
@@ -3433,16 +3433,16 @@ bool GetNmodeSupportBySecCfg8192(struct 
 	}
 
 #if 0
-        //In here we discuss with SD4 David. He think we still can send TKIP in broadcast group key in MCS rate.
-        //We can't force in G mode if Pairwie key is AES and group key is TKIP
-        if((pSecInfo->GroupEncAlgorithm == WEP104_Encryption) || (pSecInfo->GroupEncAlgorithm == WEP40_Encryption)  ||
-           (pSecInfo->PairwiseEncAlgorithm == WEP104_Encryption) ||
-           (pSecInfo->PairwiseEncAlgorithm == WEP40_Encryption) || (pSecInfo->PairwiseEncAlgorithm == TKIP_Encryption))
-        {
-                return  false;
-        }
-        else
-                return true;
+	//In here we discuss with SD4 David. He think we still can send TKIP in broadcast group key in MCS rate.
+	//We can't force in G mode if Pairwie key is AES and group key is TKIP
+	if((pSecInfo->GroupEncAlgorithm == WEP104_Encryption) || (pSecInfo->GroupEncAlgorithm == WEP40_Encryption)  ||
+	   (pSecInfo->PairwiseEncAlgorithm == WEP104_Encryption) ||
+	   (pSecInfo->PairwiseEncAlgorithm == WEP40_Encryption) || (pSecInfo->PairwiseEncAlgorithm == TKIP_Encryption))
+	{
+		return  false;
+	}
+	else
+		return true;
 #endif
 	return true;
 #endif
@@ -3608,10 +3608,10 @@ static void rtl8192_init_priv_variable(s
 	priv->card_type = USB;
 #ifdef TO_DO_LIST
 	if(Adapter->bInHctTest)
-  	{
+	{
 		pHalData->ShortRetryLimit = 7;
 		pHalData->LongRetryLimit = 7;
-  	}
+	}
 #endif
 	{
 		priv->ShortRetryLimit = 0x30;
@@ -3622,7 +3622,7 @@ static void rtl8192_init_priv_variable(s
 	priv->TransmitConfig =
 	//	TCR_DurProcMode |	//for RTL8185B, duration setting by HW
 	//?	TCR_DISReqQsize |
-                (TCR_MXDMA_2048<<TCR_MXDMA_OFFSET)|  // Max DMA Burst Size per Tx DMA Burst, 7: reservied.
+		(TCR_MXDMA_2048<<TCR_MXDMA_OFFSET)|  // Max DMA Burst Size per Tx DMA Burst, 7: reservied.
 		(priv->ShortRetryLimit<<TCR_SRL_OFFSET)|	// Short retry limit
 		(priv->LongRetryLimit<<TCR_LRL_OFFSET) |	// Long retry limit
 		(false ? TCR_SAT: 0);	// FALSE: HW provies PLCP length and LENGEXT, TURE: SW proiveds them
@@ -3655,7 +3655,7 @@ static void rtl8192_init_priv_variable(s
 	memset(priv->pFirmware, 0, sizeof(rt_firmware));
 
 	/* rx related queue */
-        skb_queue_head_init(&priv->rx_queue);
+	skb_queue_head_init(&priv->rx_queue);
 	skb_queue_head_init(&priv->skb_queue);
 
 	/* Tx related queue */
@@ -3984,7 +3984,7 @@ static void rtl8192_read_eeprom_info(str
 			priv->LedStrategy = SW_LED_MODE2;
 			break;
 
- 		case RT_CID_DLINK:
+		case RT_CID_DLINK:
 			priv->LedStrategy = SW_LED_MODE4;
 			break;
 
@@ -4655,7 +4655,7 @@ RxCheckStuck(struct net_device *dev)
 	//PlatformAcquireSpinLock(Adapter, RT_RX_SPINLOCK);
 
 	 if(priv->IrpPendingCount > 1)
-	 	bRxCheck = TRUE;
+		bRxCheck = TRUE;
        //PlatformReleaseSpinLock(Adapter, RT_RX_SPINLOCK);
 
 //       RT_TRACE(COMP_RESET,"bRxCheck is %d \n",bRxCheck);
@@ -5022,13 +5022,13 @@ void CAM_read_entry(
 			}
 		}
 #endif
-  		write_nic_dword(dev, RWCAM, target_command);
-   	 	RT_TRACE(COMP_SEC,"CAM_read_entry(): WRITE A0: %x \n",target_command);
-   	 //	printk("CAM_read_entry(): WRITE A0: %lx \n",target_command);
-  	 	target_content = read_nic_dword(dev, RCAMO);
-  	 	RT_TRACE(COMP_SEC, "CAM_read_entry(): WRITE A8: %x \n",target_content);
-  	 //	printk("CAM_read_entry(): WRITE A8: %lx \n",target_content);
- 	}
+		write_nic_dword(dev, RWCAM, target_command);
+		RT_TRACE(COMP_SEC,"CAM_read_entry(): WRITE A0: %x \n",target_command);
+	 //	printk("CAM_read_entry(): WRITE A0: %lx \n",target_command);
+		target_content = read_nic_dword(dev, RCAMO);
+		RT_TRACE(COMP_SEC, "CAM_read_entry(): WRITE A8: %x \n",target_content);
+	 //	printk("CAM_read_entry(): WRITE A8: %lx \n",target_content);
+	}
 	printk("\n");
 }
 
@@ -5067,7 +5067,7 @@ extern	void	rtl819x_watchdog_wqcallback(
 #endif
 	struct ieee80211_device* ieee = priv->ieee80211;
 	RESET_TYPE	ResetType = RESET_TYPE_NORESET;
-      	static u8	check_reset_cnt=0;
+	static u8	check_reset_cnt=0;
 	bool bBusyTraffic = false;
 
 	if(!priv->up)
@@ -5247,18 +5247,18 @@ int rtl8192_down(struct net_device *dev)
 	//rtl8192_irq_disable(dev);
 
  /* Tx related queue release */
-        for(i = 0; i < MAX_QUEUE_SIZE; i++) {
-                skb_queue_purge(&priv->ieee80211->skb_waitQ [i]);
-        }
-        for(i = 0; i < MAX_QUEUE_SIZE; i++) {
-                skb_queue_purge(&priv->ieee80211->skb_aggQ [i]);
-        }
+	for(i = 0; i < MAX_QUEUE_SIZE; i++) {
+		skb_queue_purge(&priv->ieee80211->skb_waitQ [i]);
+	}
+	for(i = 0; i < MAX_QUEUE_SIZE; i++) {
+		skb_queue_purge(&priv->ieee80211->skb_aggQ [i]);
+	}
 
-        for(i = 0; i < MAX_QUEUE_SIZE; i++) {
-                skb_queue_purge(&priv->ieee80211->skb_drv_aggQ [i]);
-        }
+	for(i = 0; i < MAX_QUEUE_SIZE; i++) {
+		skb_queue_purge(&priv->ieee80211->skb_drv_aggQ [i]);
+	}
 
-        //as cancel_delayed_work will del work->timer, so if work is not definedas struct delayed_work, it will corrupt
+	//as cancel_delayed_work will del work->timer, so if work is not definedas struct delayed_work, it will corrupt
 //	flush_scheduled_work();
 	rtl8192_cancel_deferred_work(priv);
 	deinit_hal_dm(dev);
@@ -5301,13 +5301,13 @@ void rtl8192_restart(struct net_device *
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8192_restart(struct work_struct *work)
 {
-        struct r8192_priv *priv = container_of(work, struct r8192_priv, reset_wq);
-        struct net_device *dev = priv->ieee80211->dev;
+	struct r8192_priv *priv = container_of(work, struct r8192_priv, reset_wq);
+	struct net_device *dev = priv->ieee80211->dev;
 #else
 void rtl8192_restart(struct net_device *dev)
 {
 
-        struct r8192_priv *priv = ieee80211_priv(dev);
+	struct r8192_priv *priv = ieee80211_priv(dev);
 #endif
 
 	down(&priv->wx_sem);
@@ -5373,19 +5373,19 @@ int rtl8192_ioctl(struct net_device *dev
 
 
      if (p->length < sizeof(struct ieee_param) || !p->pointer){
-             ret = -EINVAL;
-             goto out;
+	     ret = -EINVAL;
+	     goto out;
 	}
 
      ipw = (struct ieee_param *)kmalloc(p->length, GFP_KERNEL);
      if (ipw == NULL){
-             ret = -ENOMEM;
-             goto out;
+	     ret = -ENOMEM;
+	     goto out;
      }
      if (copy_from_user(ipw, p->pointer, p->length)) {
 		kfree(ipw);
-            ret = -EFAULT;
-            goto out;
+	    ret = -EFAULT;
+	    goto out;
 	}
 
 	switch (cmd) {
@@ -5466,7 +5466,7 @@ int rtl8192_ioctl(struct net_device *dev
 		break;
 	}
 	kfree(ipw);
-        ipw = NULL;
+	ipw = NULL;
 out:
 	up(&priv->wx_sem);
 	return ret;
@@ -5660,8 +5660,8 @@ void rtl8192_process_phyinfo(struct r819
 	{
 		for (rfpath = RF90_PATH_A; rfpath < priv->NumTotalRFPath; rfpath++)
 		{
-                     if (!rtl8192_phy_CheckIsLegalRFPath(priv->ieee80211->dev, rfpath))
-			         continue;
+		     if (!rtl8192_phy_CheckIsLegalRFPath(priv->ieee80211->dev, rfpath))
+				 continue;
 
 			//Fixed by Jacken 2008-03-20
 			if(priv->stats.rx_rssi_percentage[rfpath] == 0)
@@ -6117,7 +6117,7 @@ static void rtl8192_query_rxphystatus(
 		// (3)EVM of HT rate
 		//
 		if(pdrvinfo->RxHT && pdrvinfo->RxRate>=DESC90_RATEMCS8 &&
-		 	pdrvinfo->RxRate<=DESC90_RATEMCS15)
+			pdrvinfo->RxRate<=DESC90_RATEMCS15)
 			max_spatial_stream = 2; //both spatial stream make sense
 		else
 			max_spatial_stream = 1; //only spatial stream 1 makes sense
@@ -6184,7 +6184,7 @@ rtl8192_record_rxdesc_forlateruse(
 
 void TranslateRxSignalStuff819xUsb(struct sk_buff *skb,
 				   struct ieee80211_rx_stats * pstats,
-                                   rx_drvinfo_819x_usb  *pdrvinfo)
+				   rx_drvinfo_819x_usb  *pdrvinfo)
 {
 	// TODO: We must only check packet for current MAC address. Not finish
 	rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
@@ -6212,8 +6212,8 @@ void TranslateRxSignalStuff819xUsb(struc
 
 	/* Check if the received packet is acceptabe. */
 	bpacket_match_bssid = ((IEEE80211_FTYPE_CTL != type) &&
-                                			(eqMacAddr(priv->ieee80211->current_network.bssid,  (fc & IEEE80211_FCTL_TODS)? hdr->addr1 : (fc & IEEE80211_FCTL_FROMDS )? hdr->addr2 : hdr->addr3))
-                                				 && (!pstats->bHwError) && (!pstats->bCRC)&& (!pstats->bICV));
+							(eqMacAddr(priv->ieee80211->current_network.bssid,  (fc & IEEE80211_FCTL_TODS)? hdr->addr1 : (fc & IEEE80211_FCTL_FROMDS )? hdr->addr2 : hdr->addr3))
+								 && (!pstats->bHwError) && (!pstats->bCRC)&& (!pstats->bICV));
 	bpacket_toself =  bpacket_match_bssid & (eqMacAddr(praddr, priv->ieee80211->dev->dev_addr));
 
 #if 1//cosa
@@ -6271,20 +6271,20 @@ UpdateReceivedRateHistogramStatistics819
 	)
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-    	u32 rcvType=1;   //0: Total, 1:OK, 2:CRC, 3:ICV
-    	u32 rateIndex;
-    	u32 preamble_guardinterval;  //1: short preamble/GI, 0: long preamble/GI
+	u32 rcvType=1;   //0: Total, 1:OK, 2:CRC, 3:ICV
+	u32 rateIndex;
+	u32 preamble_guardinterval;  //1: short preamble/GI, 0: long preamble/GI
 
 
-    	if(stats->bCRC)
-       	rcvType = 2;
-   	else if(stats->bICV)
-       	rcvType = 3;
-
-   	if(stats->bShortPreamble)
-       	preamble_guardinterval = 1;// short
-    	else
-       	preamble_guardinterval = 0;// long
+	if(stats->bCRC)
+	rcvType = 2;
+	else if(stats->bICV)
+	rcvType = 3;
+
+	if(stats->bShortPreamble)
+	preamble_guardinterval = 1;// short
+	else
+	preamble_guardinterval = 0;// long
 
 	switch(stats->rate)
 	{
@@ -6784,12 +6784,12 @@ void rtl8192_rx_cmd(struct sk_buff *skb)
 
 void rtl8192_irq_rx_tasklet(struct r8192_priv *priv)
 {
-        struct sk_buff *skb;
+	struct sk_buff *skb;
 	struct rtl8192_rx_info *info;
 
-        while (NULL != (skb = skb_dequeue(&priv->skb_queue))) {
+	while (NULL != (skb = skb_dequeue(&priv->skb_queue))) {
 		info = (struct rtl8192_rx_info *)skb->cb;
-                switch (info->out_pipe) {
+		switch (info->out_pipe) {
 		/* Nomal packet pipe */
 			case 3:
 				//RT_TRACE(COMP_RECV, "normal in-pipe index(%d)\n",info->out_pipe);
@@ -6812,7 +6812,7 @@ void rtl8192_irq_rx_tasklet(struct r8192
 				break;
 
 		}
-        }
+	}
 }
 
 static const struct net_device_ops rtl8192_netdev_ops = {
@@ -6838,8 +6838,8 @@ static int __devinit rtl8192_usb_probe(s
 			 const struct usb_device_id *id)
 #else
 static void * __devinit rtl8192_usb_probe(struct usb_device *udev,
-			                unsigned int ifnum,
-			          const struct usb_device_id *id)
+					unsigned int ifnum,
+				  const struct usb_device_id *id)
 #endif
 {
 //	unsigned long ioaddr = 0;
@@ -6848,7 +6848,7 @@ static void * __devinit rtl8192_usb_prob
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct usb_device *udev = interface_to_usbdev(intf);
 #endif
-        RT_TRACE(COMP_INIT, "Oops: i'm coming\n");
+	RT_TRACE(COMP_INIT, "Oops: i'm coming\n");
 
 	dev = alloc_ieee80211(sizeof(struct r8192_priv));
 
@@ -6868,24 +6868,24 @@ static void * __devinit rtl8192_usb_prob
 #endif
 	priv->udev=udev;
 
-        dev->netdev_ops = &rtl8192_netdev_ops;
+	dev->netdev_ops = &rtl8192_netdev_ops;
 
-         //DMESG("Oops: i'm coming\n");
+	 //DMESG("Oops: i'm coming\n");
 #if WIRELESS_EXT >= 12
 #if WIRELESS_EXT < 17
-        dev->get_wireless_stats = r8192_get_wireless_stats;
+	dev->get_wireless_stats = r8192_get_wireless_stats;
 #endif
-        dev->wireless_handlers = (struct iw_handler_def *) &r8192_wx_handlers_def;
+	dev->wireless_handlers = (struct iw_handler_def *) &r8192_wx_handlers_def;
 #endif
 	dev->type=ARPHRD_ETHER;
 
 	dev->watchdog_timeo = HZ*3;	//modified by john, 0805
 
 	if (dev_alloc_name(dev, ifname) < 0){
-                RT_TRACE(COMP_INIT, "Oops: devname already taken! Trying wlan%%d...\n");
+		RT_TRACE(COMP_INIT, "Oops: devname already taken! Trying wlan%%d...\n");
 		ifname = "wlan%d";
 		dev_alloc_name(dev, ifname);
-        }
+	}
 
 	RT_TRACE(COMP_INIT, "Driver probe completed1\n");
 #if 1
@@ -6960,7 +6960,7 @@ static void __devexit rtl8192_usb_discon
 #endif
 
 	struct r8192_priv *priv = ieee80211_priv(dev);
- 	if(dev){
+	if(dev){
 
 		unregister_netdev(dev);
 
@@ -7002,40 +7002,40 @@ extern void ieee80211_crypto_wep_exit(vo
 
 static int __init rtl8192_usb_module_init(void)
 {
-        int ret;
+	int ret;
 
 #ifdef CONFIG_IEEE80211_DEBUG
-        ret = ieee80211_debug_init();
-        if (ret) {
-                printk(KERN_ERR "ieee80211_debug_init() failed %d\n", ret);
-                return ret;
-        }
+	ret = ieee80211_debug_init();
+	if (ret) {
+		printk(KERN_ERR "ieee80211_debug_init() failed %d\n", ret);
+		return ret;
+	}
 #endif
-        ret = ieee80211_crypto_init();
-        if (ret) {
-                printk(KERN_ERR "ieee80211_crypto_init() failed %d\n", ret);
-                return ret;
-        }
+	ret = ieee80211_crypto_init();
+	if (ret) {
+		printk(KERN_ERR "ieee80211_crypto_init() failed %d\n", ret);
+		return ret;
+	}
 
-        ret = ieee80211_crypto_tkip_init();
-        if (ret) {
-                printk(KERN_ERR "ieee80211_crypto_tkip_init() failed %d\n",
-                        ret);
-                return ret;
-        }
+	ret = ieee80211_crypto_tkip_init();
+	if (ret) {
+		printk(KERN_ERR "ieee80211_crypto_tkip_init() failed %d\n",
+			ret);
+		return ret;
+	}
 
-        ret = ieee80211_crypto_ccmp_init();
-        if (ret) {
-                printk(KERN_ERR "ieee80211_crypto_ccmp_init() failed %d\n",
-                        ret);
-                return ret;
-        }
+	ret = ieee80211_crypto_ccmp_init();
+	if (ret) {
+		printk(KERN_ERR "ieee80211_crypto_ccmp_init() failed %d\n",
+			ret);
+		return ret;
+	}
 
-        ret = ieee80211_crypto_wep_init();
-        if (ret) {
-                printk(KERN_ERR "ieee80211_crypto_wep_init() failed %d\n", ret);
-                return ret;
-        }
+	ret = ieee80211_crypto_wep_init();
+	if (ret) {
+		printk(KERN_ERR "ieee80211_crypto_wep_init() failed %d\n", ret);
+		return ret;
+	}
 
 	printk(KERN_INFO "\nLinux kernel driver for RTL8192 based WLAN cards\n");
 	printk(KERN_INFO "Copyright (c) 2007-2008, Realsil Wlan\n");
@@ -7063,7 +7063,7 @@ void rtl8192_try_wake_queue(struct net_d
 
 	spin_lock_irqsave(&priv->tx_lock,flags);
 	enough_desc = check_nic_enough_desc(dev,pri);
-        spin_unlock_irqrestore(&priv->tx_lock,flags);
+	spin_unlock_irqrestore(&priv->tx_lock,flags);
 
 	if(enough_desc)
 		ieee80211_wake_queue(priv->ieee80211);
@@ -7071,7 +7071,7 @@ void rtl8192_try_wake_queue(struct net_d
 
 void EnableHWSecurityConfig8192(struct net_device *dev)
 {
-        u8 SECR_value = 0x0;
+	u8 SECR_value = 0x0;
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 	 struct ieee80211_device* ieee = priv->ieee80211;
 	SECR_value = SCR_TxEncEnable | SCR_RxDecEnable;
@@ -7087,7 +7087,7 @@ void EnableHWSecurityConfig8192(struct n
 		SECR_value |= SCR_TxUseDK;
 	}
 #endif
-        //add HWSec active enable here.
+	//add HWSec active enable here.
 //default using hwsec. when peer AP is in N mode only and pairwise_key_type is none_aes(which HT_IOT_ACT_PURE_N_MODE indicates it), use software security. when peer AP is in b,g,n mode mixed and pairwise_key_type is none_aes, use g mode hw security. WB on 2008.7.4
 
 	ieee->hwsec_active = 1;
@@ -7100,8 +7100,8 @@ void EnableHWSecurityConfig8192(struct n
 	RT_TRACE(COMP_SEC,"%s:, hwsec:%d, pairwise_key:%d, SECR_value:%x\n", __FUNCTION__, \
 			ieee->hwsec_active, ieee->pairwise_key_type, SECR_value);
 	{
-                write_nic_byte(dev, SECR,  SECR_value);//SECR_value |  SCR_UseDK );
-        }
+		write_nic_byte(dev, SECR,  SECR_value);//SECR_value |  SCR_UseDK );
+	}
 }
 
 
@@ -7143,10 +7143,10 @@ void setKey(	struct net_device *dev,
 	//		printk("setkey cam =%8x\n", read_cam(dev, i+6*EntryNo));
 		}
 		else if(i==1){//MAC
-                        TargetContent = (u32)(*(MacAddr+2)) 	 |
-                                        (u32)(*(MacAddr+3)) <<  8|
-                                        (u32)(*(MacAddr+4)) << 16|
-                                        (u32)(*(MacAddr+5)) << 24;
+			TargetContent = (u32)(*(MacAddr+2)) 	 |
+					(u32)(*(MacAddr+3)) <<  8|
+					(u32)(*(MacAddr+4)) << 16|
+					(u32)(*(MacAddr+5)) << 24;
 			write_nic_dword(dev, WCAMI, TargetContent);
 			write_nic_dword(dev, RWCAM, TargetCommand);
 		}
--- a/drivers/staging/rtl8192u/r8192U_dm.c
+++ b/drivers/staging/rtl8192u/r8192U_dm.c
@@ -282,7 +282,7 @@ void dm_CheckRxAggregation(struct net_de
 
 extern  void    hal_dm_watchdog(struct net_device *dev)
 {
-        //struct r8192_priv *priv = ieee80211_priv(dev);
+	//struct r8192_priv *priv = ieee80211_priv(dev);
 
 	//static u8 	previous_bssid[6] ={0};
 
@@ -621,7 +621,7 @@ static void dm_TXPowerTrackingCallback_T
 	bool						bHighpowerstate, viviflag = FALSE;
 	DCMD_TXCMD_T			tx_cmd;
 	u8						powerlevelOFDM24G;
-	int	    					i =0, j = 0, k = 0;
+	int						i =0, j = 0, k = 0;
 	u8						RF_Type, tmp_report[5]={0, 0, 0, 0, 0};
 	u32						Value;
 	u8						Pwr_Flag;
@@ -1010,13 +1010,13 @@ static void dm_InitializeTXPowerTracking
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
 	//Initial the Tx BB index and mapping value
-	priv->txbbgain_table[0].txbb_iq_amplifygain = 	 		12;
+	priv->txbbgain_table[0].txbb_iq_amplifygain = 			12;
 	priv->txbbgain_table[0].txbbgain_value=0x7f8001fe;
-	priv->txbbgain_table[1].txbb_iq_amplifygain = 	 		11;
+	priv->txbbgain_table[1].txbb_iq_amplifygain = 			11;
 	priv->txbbgain_table[1].txbbgain_value=0x788001e2;
-	priv->txbbgain_table[2].txbb_iq_amplifygain = 	 		10;
+	priv->txbbgain_table[2].txbb_iq_amplifygain = 			10;
 	priv->txbbgain_table[2].txbbgain_value=0x71c001c7;
-	priv->txbbgain_table[3].txbb_iq_amplifygain = 	 		9;
+	priv->txbbgain_table[3].txbb_iq_amplifygain = 			9;
 	priv->txbbgain_table[3].txbbgain_value=0x6b8001ae;
 	priv->txbbgain_table[4].txbb_iq_amplifygain = 		       8;
 	priv->txbbgain_table[4].txbbgain_value=0x65400195;
@@ -1046,7 +1046,7 @@ static void dm_InitializeTXPowerTracking
 	priv->txbbgain_table[16].txbbgain_value=0x32c000cb;
 	priv->txbbgain_table[17].txbb_iq_amplifygain = 		     -5;
 	priv->txbbgain_table[17].txbbgain_value=0x300000c0;
-	priv->txbbgain_table[18].txbb_iq_amplifygain = 		 	    -6;
+	priv->txbbgain_table[18].txbb_iq_amplifygain = 			    -6;
 	priv->txbbgain_table[18].txbbgain_value=0x2d4000b5;
 	priv->txbbgain_table[19].txbb_iq_amplifygain = 		     -7;
 	priv->txbbgain_table[19].txbbgain_value=0x2ac000ab;
@@ -1548,9 +1548,9 @@ static void dm_CheckTXPowerTracking_TSSI
 		return;
 	else
 	{
-	 	if((tx_power_track_counter % 30 == 0)&&(tx_power_track_counter != 0))
-	 	{
-	 		#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+		if((tx_power_track_counter % 30 == 0)&&(tx_power_track_counter != 0))
+		{
+			#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 				queue_delayed_work(priv->priv_wq,&priv->txpower_tracking_wq,0);
 			#else
 				#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
@@ -1559,7 +1559,7 @@ static void dm_CheckTXPowerTracking_TSSI
 				queue_work(priv->priv_wq,&priv->txpower_tracking_wq);
 				#endif
 			#endif
-	 	}
+		}
 		tx_power_track_counter++;
 	}
 
@@ -3065,7 +3065,7 @@ static void dm_check_rfctrl_gpio(struct 
 	#else
 		#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 		schedule_task(&priv->gpio_change_rf_wq);
-             #else
+	     #else
 		queue_work(priv->priv_wq,&priv->gpio_change_rf_wq);
 		#endif
 	#endif
@@ -3602,7 +3602,7 @@ extern void dm_fsync_timer_callback(unsi
 		{
 			rate_bitmap  = 1 << rate_index;
 			if(priv->ieee80211->fsync_rate_bitmap &  rate_bitmap)
-		 		rate_count+= priv->stats.received_rate_histogram[1][rate_index];
+				rate_count+= priv->stats.received_rate_histogram[1][rate_index];
 		}
 
 		if(rate_count < priv->rate_record)
@@ -4036,7 +4036,7 @@ extern void dm_shadow_init(struct net_de
  * Function:	DM_DynamicTxPower()
  *
  * Overview:	Detect Signal strength to control TX Registry
- 			Tx Power Control For Near/Far Range
+			Tx Power Control For Near/Far Range
  *
  * Input:		NONE
  *
--- a/drivers/staging/rtl8192u/r8192U_dm.h
+++ b/drivers/staging/rtl8192u/r8192U_dm.h
@@ -283,7 +283,7 @@ extern  void    dm_txpower_trackingcallb
 extern  void    dm_restore_dynamic_mechanism_state(struct net_device *dev);
 extern  void    dm_backup_dynamic_mechanism_state(struct net_device *dev);
 extern  void    dm_change_dynamic_initgain_thresh(struct net_device *dev,
-                                                                u32 dm_type, u32 dm_value);
+								u32 dm_type, u32 dm_value);
 extern  void    dm_force_tx_fw_info(struct net_device *dev,u32 force_type, u32 force_value);
 extern  void    dm_init_edca_turbo(struct net_device *dev);
 extern  void    dm_rf_operation_test_callback(unsigned long data);
--- a/drivers/staging/rtl8192u/r8192U_hw.h
+++ b/drivers/staging/rtl8192u/r8192U_hw.h
@@ -226,7 +226,7 @@ enum _RTL8192Usb_HW {
 #define CPU_GEN_NO_LOOPBACK_SET	0x00080000 // Set BIT19 to 1
 	CPU_GEN			= 0x100, // CPU Reset Register
 	LED1Cfg			=		0x154,// LED1 Configuration Register
- 	LED0Cfg			=		0x155,// LED0 Configuration Register
+	LED0Cfg			=		0x155,// LED0 Configuration Register
 
 	AcmAvg			= 0x170, // ACM Average Period Register
 	AcmHwCtrl		= 0x171, // ACM Hardware Control Register
--- a/drivers/staging/rtl8192u/r8192U_wx.c
+++ b/drivers/staging/rtl8192u/r8192U_wx.c
@@ -193,15 +193,15 @@ static int r8192_wx_write_regs(struct ne
 			       struct iw_request_info *info,
 			       union iwreq_data *wrqu, char *extra)
 {
-        struct r8192_priv *priv = ieee80211_priv(dev);
-        u8 addr;
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u8 addr;
 
-        down(&priv->wx_sem);
+	down(&priv->wx_sem);
 
-        get_user(addr, (u8*)wrqu->data.pointer);
+	get_user(addr, (u8*)wrqu->data.pointer);
 	write_rtl8225(dev, addr, wrqu->data.length);
 
-        up(&priv->wx_sem);
+	up(&priv->wx_sem);
 	return 0;
 
 }
@@ -213,14 +213,14 @@ static int r8192_wx_read_bb(struct net_d
 			       struct iw_request_info *info,
 			       union iwreq_data *wrqu, char *extra)
 {
-        struct r8192_priv *priv = ieee80211_priv(dev);
+	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 databb;
 #if 0
 	int i;
 	for(i=0;i<12;i++) printk("%8x\n", read_cam(dev, i) );
 #endif
 
-        down(&priv->wx_sem);
+	down(&priv->wx_sem);
 
 	databb = rtl8187_read_phy(dev, (u8)wrqu->data.length, 0x00000000);
 	wrqu->data.length = databb;
@@ -231,74 +231,74 @@ static int r8192_wx_read_bb(struct net_d
 
 void rtl8187_write_phy(struct net_device *dev, u8 adr, u32 data);
 static int r8192_wx_write_bb(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 {
-        struct r8192_priv *priv = ieee80211_priv(dev);
-        u8 databb;
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u8 databb;
 
-        down(&priv->wx_sem);
+	down(&priv->wx_sem);
 
-        get_user(databb, (u8*)wrqu->data.pointer);
-        rtl8187_write_phy(dev, wrqu->data.length, databb);
+	get_user(databb, (u8*)wrqu->data.pointer);
+	rtl8187_write_phy(dev, wrqu->data.length, databb);
 
-        up(&priv->wx_sem);
-        return 0;
+	up(&priv->wx_sem);
+	return 0;
 
 }
 
 
 static int r8192_wx_write_nicb(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 {
-        struct r8192_priv *priv = ieee80211_priv(dev);
-        u32 addr;
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u32 addr;
 
-        down(&priv->wx_sem);
+	down(&priv->wx_sem);
 
-        get_user(addr, (u32*)wrqu->data.pointer);
-        write_nic_byte(dev, addr, wrqu->data.length);
+	get_user(addr, (u32*)wrqu->data.pointer);
+	write_nic_byte(dev, addr, wrqu->data.length);
 
-        up(&priv->wx_sem);
-        return 0;
+	up(&priv->wx_sem);
+	return 0;
 
 }
 static int r8192_wx_read_nicb(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 {
-        struct r8192_priv *priv = ieee80211_priv(dev);
-        u32 addr;
-        u16 data1;
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u32 addr;
+	u16 data1;
 
-        down(&priv->wx_sem);
+	down(&priv->wx_sem);
 
-        get_user(addr,(u32*)wrqu->data.pointer);
-        data1 = read_nic_byte(dev, addr);
-        wrqu->data.length = data1;
+	get_user(addr,(u32*)wrqu->data.pointer);
+	data1 = read_nic_byte(dev, addr);
+	wrqu->data.length = data1;
 
-        up(&priv->wx_sem);
-        return 0;
+	up(&priv->wx_sem);
+	return 0;
 }
 
 static int r8192_wx_get_ap_status(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 {
-        struct r8192_priv *priv = ieee80211_priv(dev);
-        struct ieee80211_device *ieee = priv->ieee80211;
-        struct ieee80211_network *target;
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	struct ieee80211_device *ieee = priv->ieee80211;
+	struct ieee80211_network *target;
 	int name_len;
 
-        down(&priv->wx_sem);
+	down(&priv->wx_sem);
 
 	//count the length of input ssid
 	for(name_len=0 ; ((char*)wrqu->data.pointer)[name_len]!='\0' ; name_len++);
 
 	//search for the correspoding info which is received
-        list_for_each_entry(target, &ieee->network_list, list) {
-                if ( (target->ssid_len == name_len) &&
+	list_for_each_entry(target, &ieee->network_list, list) {
+		if ( (target->ssid_len == name_len) &&
 		     (strncmp(target->ssid, (char*)wrqu->data.pointer, name_len)==0)){
 			if(target->wpa_ie_len>0 || target->rsn_ie_len>0 )
 				//set flags=1 to indicate this ap is WPA
@@ -307,11 +307,11 @@ static int r8192_wx_get_ap_status(struct
 
 
 		break;
-                }
-        }
+		}
+	}
 
-        up(&priv->wx_sem);
-        return 0;
+	up(&priv->wx_sem);
+	return 0;
 }
 
 
@@ -404,25 +404,25 @@ static int r8192_wx_set_mode(struct net_
 
 struct  iw_range_with_scan_capa
 {
-        /* Informative stuff (to choose between different interface) */
-        __u32           throughput;     /* To give an idea... */
-        /* In theory this value should be the maximum benchmarked
-         * TCP/IP throughput, because with most of these devices the
-         * bit rate is meaningless (overhead an co) to estimate how
-         * fast the connection will go and pick the fastest one.
-         * I suggest people to play with Netperf or any benchmark...
-         */
-
-        /* NWID (or domain id) */
-        __u32           min_nwid;       /* Minimal NWID we are able to set */
-        __u32           max_nwid;       /* Maximal NWID we are able to set */
-
-        /* Old Frequency (backward compat - moved lower ) */
-        __u16           old_num_channels;
-        __u8            old_num_frequency;
+	/* Informative stuff (to choose between different interface) */
+	__u32           throughput;     /* To give an idea... */
+	/* In theory this value should be the maximum benchmarked
+	 * TCP/IP throughput, because with most of these devices the
+	 * bit rate is meaningless (overhead an co) to estimate how
+	 * fast the connection will go and pick the fastest one.
+	 * I suggest people to play with Netperf or any benchmark...
+	 */
+
+	/* NWID (or domain id) */
+	__u32           min_nwid;       /* Minimal NWID we are able to set */
+	__u32           max_nwid;       /* Maximal NWID we are able to set */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	__u16           old_num_channels;
+	__u8            old_num_frequency;
 
-        /* Scan capabilities */
-        __u8            scan_capa;
+	/* Scan capabilities */
+	__u8            scan_capa;
 };
 static int rtl8180_wx_get_range(struct net_device *dev,
 				struct iw_request_info *info,
@@ -453,7 +453,7 @@ static int rtl8180_wx_get_range(struct n
 	// TODO: Not used in 802.11b?
 //	range->max_nwid;	/* Maximal NWID we are able to set */
 
-        /* Old Frequency (backward compat - moved lower ) */
+	/* Old Frequency (backward compat - moved lower ) */
 //	range->old_num_channels;
 //	range->old_num_frequency;
 //	range->old_freq[6]; /* Filler to keep "version" at the same offset */
@@ -509,7 +509,7 @@ static int rtl8180_wx_get_range(struct n
 #else
 		if ((priv->ieee80211->channel_map)[i+1]) {
 #endif
-		        range->freq[val].i = i + 1;
+			range->freq[val].i = i + 1;
 			range->freq[val].m = ieee80211_wlan_frequencies[i] * 100000;
 			range->freq[val].e = 1;
 			val++;
@@ -522,7 +522,7 @@ static int rtl8180_wx_get_range(struct n
 		break;
 	}
 	range->num_frequency = val;
-        range->num_channels = val;
+	range->num_channels = val;
 #if WIRELESS_EXT > 17
 	range->enc_capa = IW_ENC_CAPA_WPA|IW_ENC_CAPA_WPA2|
 			  IW_ENC_CAPA_CIPHER_TKIP|IW_ENC_CAPA_CIPHER_CCMP;
@@ -557,10 +557,10 @@ static int r8192_wx_set_scan(struct net_
 
 	down(&priv->wx_sem);
 	if(priv->ieee80211->state != IEEE80211_LINKED){
-                priv->ieee80211->scanning = 0;
-                ieee80211_softmac_scan_syncro(priv->ieee80211);
-                ret = 0;
-        }
+		priv->ieee80211->scanning = 0;
+		ieee80211_softmac_scan_syncro(priv->ieee80211);
+		ret = 0;
+	}
 	else
 	ret = ieee80211_wx_set_scan(priv->ieee80211,a,wrqu,b);
 	up(&priv->wx_sem);
@@ -809,7 +809,7 @@ static int r8192_wx_set_enc(struct net_d
 static int r8192_wx_set_scan_type(struct net_device *dev, struct iw_request_info *aa, union
  iwreq_data *wrqu, char *p){
 
- 	struct r8192_priv *priv = ieee80211_priv(dev);
+	struct r8192_priv *priv = ieee80211_priv(dev);
 	int *parms=(int*)p;
 	int mode=parms[0];
 
@@ -858,7 +858,7 @@ static int r8192_wx_set_retry(struct net
 	 * I'm unsure if whole reset is really needed
 	 */
 
- 	rtl8192_commit(dev);
+	rtl8192_commit(dev);
 	/*
 	if(priv->up){
 		rtl8180_rtx_disable(dev);
@@ -939,8 +939,8 @@ exit:
 #if (WIRELESS_EXT >= 18)
 #if 0
 static int r8192_wx_get_enc_ext(struct net_device *dev,
-                                        struct iw_request_info *info,
-                                        union iwreq_data *wrqu, char *extra)
+					struct iw_request_info *info,
+					union iwreq_data *wrqu, char *extra)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	int ret = 0;
@@ -950,8 +950,8 @@ static int r8192_wx_get_enc_ext(struct n
 #endif
 //hw security need to reorganized.
 static int r8192_wx_set_enc_ext(struct net_device *dev,
-                                        struct iw_request_info *info,
-                                        union iwreq_data *wrqu, char *extra)
+					struct iw_request_info *info,
+					union iwreq_data *wrqu, char *extra)
 {
 	int ret=0;
 	#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
@@ -1040,8 +1040,8 @@ end_hw_sec:
 
 }
 static int r8192_wx_set_auth(struct net_device *dev,
-                                        struct iw_request_info *info,
-                                        union iwreq_data *data, char *extra)
+					struct iw_request_info *info,
+					union iwreq_data *data, char *extra)
 {
 	int ret=0;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
@@ -1055,8 +1055,8 @@ static int r8192_wx_set_auth(struct net_
 }
 
 static int r8192_wx_set_mlme(struct net_device *dev,
-                                        struct iw_request_info *info,
-                                        union iwreq_data *wrqu, char *extra)
+					struct iw_request_info *info,
+					union iwreq_data *wrqu, char *extra)
 {
 	//printk("====>%s()\n", __FUNCTION__);
 
@@ -1072,21 +1072,21 @@ static int r8192_wx_set_mlme(struct net_
 }
 #endif
 static int r8192_wx_set_gen_ie(struct net_device *dev,
-                                        struct iw_request_info *info,
-                                        union iwreq_data *data, char *extra)
+					struct iw_request_info *info,
+					union iwreq_data *data, char *extra)
 {
 	   //printk("====>%s(), len:%d\n", __FUNCTION__, data->length);
 	int ret=0;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-        struct r8192_priv *priv = ieee80211_priv(dev);
-        down(&priv->wx_sem);
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	down(&priv->wx_sem);
 #if 1
-        ret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);
+	ret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);
 #endif
-        up(&priv->wx_sem);
+	up(&priv->wx_sem);
 	//printk("<======%s(), ret:%d\n", __FUNCTION__, ret);
 #endif
-        return ret;
+	return ret;
 
 
 }
@@ -1100,56 +1100,56 @@ static int dummy(struct net_device *dev,
 
 static iw_handler r8192_wx_handlers[] =
 {
-        NULL,                     /* SIOCSIWCOMMIT */
-        r8192_wx_get_name,   	  /* SIOCGIWNAME */
-        dummy,                    /* SIOCSIWNWID */
-        dummy,                    /* SIOCGIWNWID */
-        r8192_wx_set_freq,        /* SIOCSIWFREQ */
-        r8192_wx_get_freq,        /* SIOCGIWFREQ */
-        r8192_wx_set_mode,        /* SIOCSIWMODE */
-        r8192_wx_get_mode,        /* SIOCGIWMODE */
-        r8192_wx_set_sens,        /* SIOCSIWSENS */
-        r8192_wx_get_sens,        /* SIOCGIWSENS */
-        NULL,                     /* SIOCSIWRANGE */
-        rtl8180_wx_get_range,	  /* SIOCGIWRANGE */
-        NULL,                     /* SIOCSIWPRIV */
-        NULL,                     /* SIOCGIWPRIV */
-        NULL,                     /* SIOCSIWSTATS */
-        NULL,                     /* SIOCGIWSTATS */
-        dummy,                    /* SIOCSIWSPY */
-        dummy,                    /* SIOCGIWSPY */
-        NULL,                     /* SIOCGIWTHRSPY */
-        NULL,                     /* SIOCWIWTHRSPY */
-        r8192_wx_set_wap,      	  /* SIOCSIWAP */
-        r8192_wx_get_wap,         /* SIOCGIWAP */
+	NULL,                     /* SIOCSIWCOMMIT */
+	r8192_wx_get_name,   	  /* SIOCGIWNAME */
+	dummy,                    /* SIOCSIWNWID */
+	dummy,                    /* SIOCGIWNWID */
+	r8192_wx_set_freq,        /* SIOCSIWFREQ */
+	r8192_wx_get_freq,        /* SIOCGIWFREQ */
+	r8192_wx_set_mode,        /* SIOCSIWMODE */
+	r8192_wx_get_mode,        /* SIOCGIWMODE */
+	r8192_wx_set_sens,        /* SIOCSIWSENS */
+	r8192_wx_get_sens,        /* SIOCGIWSENS */
+	NULL,                     /* SIOCSIWRANGE */
+	rtl8180_wx_get_range,	  /* SIOCGIWRANGE */
+	NULL,                     /* SIOCSIWPRIV */
+	NULL,                     /* SIOCGIWPRIV */
+	NULL,                     /* SIOCSIWSTATS */
+	NULL,                     /* SIOCGIWSTATS */
+	dummy,                    /* SIOCSIWSPY */
+	dummy,                    /* SIOCGIWSPY */
+	NULL,                     /* SIOCGIWTHRSPY */
+	NULL,                     /* SIOCWIWTHRSPY */
+	r8192_wx_set_wap,      	  /* SIOCSIWAP */
+	r8192_wx_get_wap,         /* SIOCGIWAP */
 #if (WIRELESS_EXT >= 18)
-        r8192_wx_set_mlme,                     /* MLME-- */
+	r8192_wx_set_mlme,                     /* MLME-- */
 #else
 	 NULL,
 #endif
-        dummy,                     /* SIOCGIWAPLIST -- depricated */
-        r8192_wx_set_scan,        /* SIOCSIWSCAN */
-        r8192_wx_get_scan,        /* SIOCGIWSCAN */
-        r8192_wx_set_essid,       /* SIOCSIWESSID */
-        r8192_wx_get_essid,       /* SIOCGIWESSID */
-        dummy,                    /* SIOCSIWNICKN */
-        dummy,                    /* SIOCGIWNICKN */
-        NULL,                     /* -- hole -- */
-        NULL,                     /* -- hole -- */
-        r8192_wx_set_rate,        /* SIOCSIWRATE */
-        r8192_wx_get_rate,        /* SIOCGIWRATE */
-        r8192_wx_set_rts,                    /* SIOCSIWRTS */
-        r8192_wx_get_rts,                    /* SIOCGIWRTS */
-        r8192_wx_set_frag,        /* SIOCSIWFRAG */
-        r8192_wx_get_frag,        /* SIOCGIWFRAG */
-        dummy,                    /* SIOCSIWTXPOW */
-        dummy,                    /* SIOCGIWTXPOW */
-        r8192_wx_set_retry,       /* SIOCSIWRETRY */
-        r8192_wx_get_retry,       /* SIOCGIWRETRY */
-        r8192_wx_set_enc,         /* SIOCSIWENCODE */
-        r8192_wx_get_enc,         /* SIOCGIWENCODE */
-        r8192_wx_set_power,                    /* SIOCSIWPOWER */
-        r8192_wx_get_power,                    /* SIOCGIWPOWER */
+	dummy,                     /* SIOCGIWAPLIST -- depricated */
+	r8192_wx_set_scan,        /* SIOCSIWSCAN */
+	r8192_wx_get_scan,        /* SIOCGIWSCAN */
+	r8192_wx_set_essid,       /* SIOCSIWESSID */
+	r8192_wx_get_essid,       /* SIOCGIWESSID */
+	dummy,                    /* SIOCSIWNICKN */
+	dummy,                    /* SIOCGIWNICKN */
+	NULL,                     /* -- hole -- */
+	NULL,                     /* -- hole -- */
+	r8192_wx_set_rate,        /* SIOCSIWRATE */
+	r8192_wx_get_rate,        /* SIOCGIWRATE */
+	r8192_wx_set_rts,                    /* SIOCSIWRTS */
+	r8192_wx_get_rts,                    /* SIOCGIWRTS */
+	r8192_wx_set_frag,        /* SIOCSIWFRAG */
+	r8192_wx_get_frag,        /* SIOCGIWFRAG */
+	dummy,                    /* SIOCSIWTXPOW */
+	dummy,                    /* SIOCGIWTXPOW */
+	r8192_wx_set_retry,       /* SIOCSIWRETRY */
+	r8192_wx_get_retry,       /* SIOCGIWRETRY */
+	r8192_wx_set_enc,         /* SIOCSIWENCODE */
+	r8192_wx_get_enc,         /* SIOCGIWENCODE */
+	r8192_wx_set_power,                    /* SIOCSIWPOWER */
+	r8192_wx_get_power,                    /* SIOCGIWPOWER */
 	NULL,			/*---hole---*/
 	NULL, 			/*---hole---*/
 	r8192_wx_set_gen_ie,//NULL, 			/* SIOCSIWGENIE */
@@ -1192,38 +1192,38 @@ static const struct iw_priv_args r8192_p
 	,
 	{
 		SIOCIWFIRSTPRIV + 0x3,
-                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "readRF"
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "readRF"
 	}
 	,
 	{
 		SIOCIWFIRSTPRIV + 0x4,
-                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "writeRF"
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "writeRF"
 	}
 	,
 	{
 		SIOCIWFIRSTPRIV + 0x5,
-                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "readBB"
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "readBB"
 	}
 	,
 	{
 		SIOCIWFIRSTPRIV + 0x6,
-                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "writeBB"
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "writeBB"
+	}
+	,
+	{
+		SIOCIWFIRSTPRIV + 0x7,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "readnicb"
+	}
+	,
+	{
+		SIOCIWFIRSTPRIV + 0x8,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "writenicb"
+	}
+	,
+	{
+		SIOCIWFIRSTPRIV + 0x9,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apinfo"
 	}
-        ,
-        {
-                SIOCIWFIRSTPRIV + 0x7,
-                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "readnicb"
-        }
-        ,
-        {
-                SIOCIWFIRSTPRIV + 0x8,
-                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "writenicb"
-        }
-        ,
-        {
-                SIOCIWFIRSTPRIV + 0x9,
-                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apinfo"
-        }
 
 #endif
 	,
@@ -1249,8 +1249,8 @@ static iw_handler r8192_private_handler[
 	r8192_wx_write_regs,
 	r8192_wx_read_bb,
 	r8192_wx_write_bb,
-        r8192_wx_read_nicb,
-        r8192_wx_write_nicb,
+	r8192_wx_read_nicb,
+	r8192_wx_write_nicb,
 	r8192_wx_get_ap_status,
 #endif
 	//r8192_wx_null,
@@ -1290,7 +1290,7 @@ struct iw_statistics *r8192_get_wireless
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14))
 	wstats->qual.updated = IW_QUAL_ALL_UPDATED| IW_QUAL_DBM;
 #else
-        wstats->qual.updated = 0x0f;
+	wstats->qual.updated = 0x0f;
 #endif
 	return wstats;
 }
@@ -1302,7 +1302,7 @@ struct iw_handler_def  r8192_wx_handlers
 	.num_standard = sizeof(r8192_wx_handlers) / sizeof(iw_handler),
 	.private = r8192_private_handler,
 	.num_private = sizeof(r8192_private_handler) / sizeof(iw_handler),
- 	.num_private_args = sizeof(r8192_private_args) / sizeof(struct iw_priv_args),
+	.num_private_args = sizeof(r8192_private_args) / sizeof(struct iw_priv_args),
 #if WIRELESS_EXT >= 17
 	.get_wireless_stats = r8192_get_wireless_stats,
 #endif
--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.c
+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
@@ -5,9 +5,9 @@
  Module:	r819xusb_cmdpkt.c	(RTL8190 TX/RX command packet handler Source C File)
 
  Note:      The module is responsible for handling TX and RX command packet.
- 			1. TX : Send set and query configuration command packet.
- 			2. RX : Receive tx feedback, beacon state, query configuration
- 			        command packet.
+			1. TX : Send set and query configuration command packet.
+			2. RX : Receive tx feedback, beacon state, query configuration
+				command packet.
 
  Function:
 
@@ -158,7 +158,7 @@ SendTxCommandPacket(
 		seg_ptr = skb_put(skb, buffer_len);
 		/*
 		 * Transform from little endian to big endian
-                 * and pending  zero
+		 * and pending  zero
 		 */
 		memcpy(seg_ptr,codevirtualaddress,buffer_len);
 		tcb_desc->txbuf_size= (u16)buffer_len;
@@ -349,7 +349,7 @@ cmpk_handle_tx_feedback(
 		pMgntInfo->CurrentOperaRate = (rx_tx_fb.F_Rate & 0x7F);
 	}
 	else if (pAdapter->RegWirelessMode == WIRELESS_MODE_N_24G ||
-		 	 pAdapter->RegWirelessMode == WIRELESS_MODE_N_5G)
+			 pAdapter->RegWirelessMode == WIRELESS_MODE_N_5G)
 	{
 		pMgntInfo->HTCurrentOperaRate = (rx_tx_fb.F_Rate & 0x8F);
 	}
@@ -802,7 +802,7 @@ cmpk_message_handle_rx(
 
 			default:
 
-			        RT_TRACE(COMP_ERR, "---->cmpk_message_handle_rx():unknow CMD Element\n");
+				RT_TRACE(COMP_ERR, "---->cmpk_message_handle_rx():unknow CMD Element\n");
 				return 1;	/* This is a command packet. */
 		}
 		// 2007/01/22 MH Display received rx command packet info.
--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.h
+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.h
@@ -202,10 +202,10 @@ typedef enum tag_command_packet_director
 }cmpk_element_e;
 
 typedef enum _rt_status{
-        RT_STATUS_SUCCESS,
-        RT_STATUS_FAILURE,
-        RT_STATUS_PENDING,
-        RT_STATUS_RESOURCE
+	RT_STATUS_SUCCESS,
+	RT_STATUS_FAILURE,
+	RT_STATUS_PENDING,
+	RT_STATUS_RESOURCE
 }rt_status,*prt_status;
 
 extern rt_status cmpk_message_handle_tx(struct net_device *dev, u8* codevirtualaddress, u32 packettype, u32 buffer_len);
--- a/drivers/staging/rtl8192u/r819xU_firmware.c
+++ b/drivers/staging/rtl8192u/r819xU_firmware.c
@@ -80,7 +80,7 @@ bool fw_download_code(struct net_device 
 		seg_ptr = skb->data;
 		/*
 		 * Transform from little endian to big endian
-                 * and pending  zero
+		 * and pending  zero
 		 */
 		for(i=0 ; i < frag_length; i+=4) {
 			*seg_ptr++ = ((i+0)<frag_length)?code_virtual_address[i+3]:0;
@@ -218,7 +218,7 @@ bool CPUcheck_maincodeok_turnonCPU(struc
 {
 	bool		rt_status = true;
 	int		check_putcodeOK_time = 200000, check_bootOk_time = 200000;
-	u32	 	CPU_status = 0;
+	u32		CPU_status = 0;
 
 	/* Check whether put code OK */
 	do {
@@ -299,12 +299,12 @@ bool init_firmware(struct net_device *de
 	bool			rt_status = TRUE;
 
 	u8			*firmware_img_buf[3] = { &rtl8190_fwboot_array[0],
-						   	 &rtl8190_fwmain_array[0],
-						   	 &rtl8190_fwdata_array[0]};
+							 &rtl8190_fwmain_array[0],
+							 &rtl8190_fwdata_array[0]};
 
 	u32			firmware_img_len[3] = { sizeof(rtl8190_fwboot_array),
-						   	sizeof(rtl8190_fwmain_array),
-						   	sizeof(rtl8190_fwdata_array)};
+							sizeof(rtl8190_fwmain_array),
+							sizeof(rtl8190_fwdata_array)};
 	u32			file_length = 0;
 	u8			*mapped_file = NULL;
 	u32			init_step = 0;
@@ -314,7 +314,7 @@ bool init_firmware(struct net_device *de
 	rt_firmware		*pfirmware = priv->pFirmware;
 	const struct firmware 	*fw_entry;
 	const char *fw_name[3] = { "RTL8192U/boot.img",
-                           "RTL8192U/main.img",
+			   "RTL8192U/main.img",
 			   "RTL8192U/data.img"};
 	int rc;
 
@@ -490,8 +490,8 @@ download_firmware_fail:
 #if 0
 /*
  * Procedure:   (1)  Transform firmware code from little endian to big endian if required.
- *	        (2)  Number of bytes in Firmware downloading should be multiple
- *	   	     of 4 bytes. If length is not multiple of 4 bytes, appending of zeros is required
+ *		(2)  Number of bytes in Firmware downloading should be multiple
+ *		     of 4 bytes. If length is not multiple of 4 bytes, appending of zeros is required
  *
  */
 void CmdAppendZeroAndEndianTransform(
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -94,7 +94,7 @@ void rtl8192_setBBreg(struct net_device*
 	{//if not "double word" write
 		OriginalValue = read_nic_dword(dev, dwRegAddr);
 		BitShift = rtl8192_CalculateBitShift(dwBitMask);
-            	NewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));
+		NewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));
 		write_nic_dword(dev, dwRegAddr, NewValue);
 	}else
 		write_nic_dword(dev, dwRegAddr, dwData);
@@ -265,7 +265,7 @@ void rtl8192_phy_RFSerialWrite(struct ne
 		priv->RfReg0Value[eRFPath] = Data;
 
 	// Switch back to Reg_Mode0;
- 	if(priv->rf_chip == RF_8256)
+	if(priv->rf_chip == RF_8256)
 	{
 		if(Offset != 0)
 		{
@@ -320,13 +320,13 @@ void rtl8192_phy_SetRFReg(struct net_dev
 	else
 	{
 		if (BitMask != bMask12Bits) // RF data is 12 bits only
-   	        {
+		{
 			Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
-      			BitShift =  rtl8192_CalculateBitShift(BitMask);
-      			New_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
+			BitShift =  rtl8192_CalculateBitShift(BitMask);
+			New_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
 
 			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, New_Value);
-	        }else
+		}else
 			rtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, Data);
 	}
 	return;
@@ -360,8 +360,8 @@ u32 rtl8192_phy_QueryRFReg(struct net_de
 	else
 	{
 		Original_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);
-   		BitShift =  rtl8192_CalculateBitShift(BitMask);
-   		Readback_Value = (Original_Value & BitMask) >> BitShift;
+		BitShift =  rtl8192_CalculateBitShift(BitMask);
+		Readback_Value = (Original_Value & BitMask) >> BitShift;
 		return (Readback_Value);
 	}
 }
@@ -800,7 +800,7 @@ void rtl8192_BB_Config_ParaFile(struct n
 	dwRegValue = read_nic_dword(dev, CPU_GEN);
 	write_nic_dword(dev, CPU_GEN, (dwRegValue|CPU_GEN_BB_RST));
 
- 	/*----BB AGC table Initialization----*/
+	/*----BB AGC table Initialization----*/
 	//==m==>Set PHY REG From Header<==m==
 	rtl8192_phyConfigBB(dev, BaseBand_Config_AGC_TAB);
 
@@ -1563,7 +1563,7 @@ void rtl8192_SetBWModeWorkItem(struct ne
 
 		case HT_CHANNEL_WIDTH_20_40:
 			regBwOpMode &= ~BW_OPMODE_20MHZ;
-        		// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+			// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
 			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
 			break;
 
@@ -1615,7 +1615,7 @@ void rtl8192_SetBWModeWorkItem(struct ne
 			rtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);
 			rtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);
 			rtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand, (priv->nCur40MhzPrimeSC>>1));
-                   	rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
+			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
 			rtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00, priv->nCur40MhzPrimeSC);
 #if 0
 			// Correct the tx power for CCK rate in 40M. Suggest by YN, 20071207
--- a/drivers/staging/rtl8192u/r819xU_phyreg.h
+++ b/drivers/staging/rtl8192u/r819xU_phyreg.h
@@ -204,7 +204,7 @@
 #define rZebra1_AGC                   		0x4
 #define rZebra1_ChargePump            	0x5
 #define rZebra1_Channel               		0x7
-#define rZebra1_TxGain               	 	0x8
+#define rZebra1_TxGain               		0x8
 #define rZebra1_TxLPF                 		0x9
 #define rZebra1_RxLPF                 		0xb
 #define rZebra1_RxHPFCorner           	0xc
@@ -360,7 +360,7 @@
 #define bAFEWatchDogEnable        		0x20000000
 #define bXtalCap                			0x0f000000
 #define bIntDifClkEnable          		0x400
-#define bExtSigClkEnable         	 	0x800
+#define bExtSigClkEnable         		0x800
 #define bBandgapMbiasPowerUp      	0x10000
 #define bAD11SHGain               		0xc0000
 #define bAD11InputRange           		0x700000
@@ -401,8 +401,8 @@
 #define bOFDMTxOn                 		0x2
 #define bDebugPage                		0xfff  //reset debug page and also HWord, LWord
 #define bDebugItem                		0xff   //reset debug page and LWord
-#define bAntL              	       		0x10
-#define bAntNonHT           	      			0x100
+#define bAntL              			0x10
+#define bAntNonHT           				0x100
 #define bAntHT1               			0x1000
 #define bAntHT2                   			0x10000
 #define bAntHT1S1                 			0x100000
@@ -414,26 +414,26 @@
 #define bCCKRxPowerSaving         		0x40
 #define bCCKSideBand              		0x10
 #define bCCKScramble              		0x8
-#define bCCKAntDiversity    		      	0x8000
-#define bCCKCarrierRecovery   	    	0x4000
-#define bCCKTxRate           		     	0x3000
-#define bCCKDCCancel             	 	0x0800
+#define bCCKAntDiversity    			0x8000
+#define bCCKCarrierRecovery   		0x4000
+#define bCCKTxRate           			0x3000
+#define bCCKDCCancel             		0x0800
 #define bCCKISICancel             		0x0400
 #define bCCKMatchFilter           		0x0200
 #define bCCKEqualizer             		0x0100
-#define bCCKPreambleDetect       	 	0x800000
+#define bCCKPreambleDetect       		0x800000
 #define bCCKFastFalseCCA          		0x400000
 #define bCCKChEstStart            		0x300000
 #define bCCKCCACount              		0x080000
 #define bCCKcs_lim                			0x070000
 #define bCCKBistMode              		0x80000000
-#define bCCKCCAMask             	  	0x40000000
-#define bCCKTxDACPhase         	   	0x4
-#define bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
-#define bCCKr_cp_mode0         	   	0x0100
-#define bCCKTxDCOffset           	 	0xf0
-#define bCCKRxDCOffset           	 	0xf
-#define bCCKCCAMode              	 	0xc000
+#define bCCKCCAMask             		0x40000000
+#define bCCKTxDACPhase         		0x4
+#define bCCKRxADCPhase         		0x20000000   //r_rx_clk
+#define bCCKr_cp_mode0         		0x0100
+#define bCCKTxDCOffset           		0xf0
+#define bCCKRxDCOffset           		0xf
+#define bCCKCCAMode              		0xc000
 #define bCCKFalseCS_lim           		0x3f00
 #define bCCKCS_ratio              		0xc00000
 #define bCCKCorgBit_sel           		0x300000
@@ -444,18 +444,18 @@
 #define bCCKLNAPolarity           		0x800000
 #define bCCKRx1stGain             		0x7f0000
 #define bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
-#define bCCKRxAGCSatLevel        	 	0x1f000000
-#define bCCKRxAGCSatCount       	  	0xe0
+#define bCCKRxAGCSatLevel        		0x1f000000
+#define bCCKRxAGCSatCount       		0xe0
 #define bCCKRxRFSettle            		0x1f       //AGCsamp_dly
-#define bCCKFixedRxAGC           	 	0x8000
-//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
-#define bCCKAntennaPolarity      	 	0x2000
+#define bCCKFixedRxAGC           		0x8000
+//#define bCCKRxAGCFormat         		0x4000   //remove to HSSI register 0x824
+#define bCCKAntennaPolarity      		0x2000
 #define bCCKTxFilterType          		0x0c00
-#define bCCKRxAGCReportType   	   	0x0300
+#define bCCKRxAGCReportType   		0x0300
 #define bCCKRxDAGCEn              		0x80000000
-#define bCCKRxDAGCPeriod        	  	0x20000000
-#define bCCKRxDAGCSatLevel     	   	0x1f000000
-#define bCCKTimingRecovery       	 	0x800000
+#define bCCKRxDAGCPeriod        		0x20000000
+#define bCCKRxDAGCSatLevel     		0x1f000000
+#define bCCKTimingRecovery       		0x800000
 #define bCCKTxC0                  			0x3f0000
 #define bCCKTxC1                  			0x3f000000
 #define bCCKTxC2                  			0x3f
