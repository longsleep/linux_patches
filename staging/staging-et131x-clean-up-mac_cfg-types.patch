From alan@linux.intel.com  Mon Oct 26 15:00:09 2009
From: Alan Cox <alan@linux.intel.com>
Date: Tue, 06 Oct 2009 15:50:45 +0100
Subject: Staging: et131x: Clean up MAC_CFG types
To: greg@kroah.com
Message-ID: <20091006145044.8604.83177.stgit@localhost.localdomain>


Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/et131x/et1310_address_map.h |  112 +++++++++-------------------
 drivers/staging/et131x/et1310_mac.c         |   69 ++++++-----------
 drivers/staging/et131x/et131x_initpci.c     |    6 -
 3 files changed, 69 insertions(+), 118 deletions(-)

--- a/drivers/staging/et131x/et1310_address_map.h
+++ b/drivers/staging/et131x/et1310_address_map.h
@@ -1308,82 +1308,48 @@ typedef struct _RXMAC_t {				/* Location
 /*
  * structure for configuration #1 reg in mac address map.
  * located at address 0x5000
- */
-typedef union _MAC_CFG1_t {
-	u32 value;
-	struct {
-#ifdef _BIT_FIELDS_HTOL
-		u32 soft_reset:1;		/* bit 31 */
-		u32 sim_reset:1;		/* bit 30 */
-		u32 reserved3:10;		/* bits 20-29 */
-		u32 reset_rx_mc:1;		/* bit 19 */
-		u32 reset_tx_mc:1;		/* bit 18 */
-		u32 reset_rx_fun:1;	/* bit 17 */
-		u32 reset_tx_fun:1;	/* bit 16 */
-		u32 reserved2:7;		/* bits 9-15 */
-		u32 loop_back:1;		/* bit 8 */
-		u32 reserved1:2;		/* bits 6-7 */
-		u32 rx_flow:1;		/* bit 5 */
-		u32 tx_flow:1;		/* bit 4 */
-		u32 syncd_rx_en:1;		/* bit 3 */
-		u32 rx_enable:1;		/* bit 2 */
-		u32 syncd_tx_en:1;		/* bit 1 */
-		u32 tx_enable:1;		/* bit 0 */
-#else
-		u32 tx_enable:1;		/* bit 0 */
-		u32 syncd_tx_en:1;		/* bit 1 */
-		u32 rx_enable:1;		/* bit 2 */
-		u32 syncd_rx_en:1;		/* bit 3 */
-		u32 tx_flow:1;		/* bit 4 */
-		u32 rx_flow:1;		/* bit 5 */
-		u32 reserved1:2;		/* bits 6-7 */
-		u32 loop_back:1;		/* bit 8 */
-		u32 reserved2:7;		/* bits 9-15 */
-		u32 reset_tx_fun:1;	/* bit 16 */
-		u32 reset_rx_fun:1;	/* bit 17 */
-		u32 reset_tx_mc:1;		/* bit 18 */
-		u32 reset_rx_mc:1;		/* bit 19 */
-		u32 reserved3:10;		/* bits 20-29 */
-		u32 sim_reset:1;		/* bit 30 */
-		u32 soft_reset:1;		/* bit 31 */
-#endif
-	} bits;
-} MAC_CFG1_t, *PMAC_CFG1_t;
+ *
+ * 31: soft reset
+ * 30: sim reset
+ * 29-20: reserved
+ * 19: reset rx mc
+ * 18: reset tx mc
+ * 17: reset rx func
+ * 16: reset tx fnc
+ * 15-9: reserved
+ * 8: loopback
+ * 7-6: reserved
+ * 5: rx flow
+ * 4: tx flow
+ * 3: syncd rx en
+ * 2: rx enable
+ * 1: syncd tx en
+ * 0: tx enable
+ */
+
+#define CFG1_LOOPBACK	0x00000100
+#define CFG1_RX_FLOW	0x00000020
+#define CFG1_TX_FLOW	0x00000010
+#define CFG1_RX_ENABLE	0x00000004
+#define CFG1_TX_ENABLE	0x00000001
+#define CFG1_WAIT	0x0000000A	/* RX & TX syncd */
 
 /*
  * structure for configuration #2 reg in mac address map.
  * located at address 0x5004
+ * 31-16: reserved
+ * 15-12: preamble
+ * 11-10: reserved
+ * 9-8: if mode
+ * 7-6: reserved
+ * 5: huge frame
+ * 4: length check
+ * 3: undefined
+ * 2: pad crc
+ * 1: crc enable
+ * 0: full duplex
  */
-typedef union _MAC_CFG2_t {
-	u32 value;
-	struct {
-#ifdef _BIT_FIELDS_HTOL
-		u32 reserved3:16;		/* bits 16-31 */
-		u32 preamble_len:4;	/* bits 12-15 */
-		u32 reserved2:2;		/* bits 10-11 */
-		u32 if_mode:2;		/* bits 8-9 */
-		u32 reserved1:2;		/* bits 6-7 */
-		u32 huge_frame:1;		/* bit 5 */
-		u32 len_check:1;		/* bit 4 */
-		u32 undefined:1;		/* bit 3 */
-		u32 pad_crc:1;		/* bit 2 */
-		u32 crc_enable:1;		/* bit 1 */
-		u32 full_duplex:1;		/* bit 0 */
-#else
-		u32 full_duplex:1;		/* bit 0 */
-		u32 crc_enable:1;		/* bit 1 */
-		u32 pad_crc:1;		/* bit 2 */
-		u32 undefined:1;		/* bit 3 */
-		u32 len_check:1;		/* bit 4 */
-		u32 huge_frame:1;		/* bit 5 */
-		u32 reserved1:2;		/* bits 6-7 */
-		u32 if_mode:2;		/* bits 8-9 */
-		u32 reserved2:2;		/* bits 10-11 */
-		u32 preamble_len:4;	/* bits 12-15 */
-		u32 reserved3:16;		/* bits 16-31 */
-#endif
-	} bits;
-} MAC_CFG2_t, *PMAC_CFG2_t;
+
 
 /*
  * structure for Interpacket gap reg in mac address map.
@@ -1682,8 +1648,8 @@ typedef union _MAC_STATION_ADDR2_t {
  * MAC Module of JAGCore Address Mapping
  */
 typedef struct _MAC_t {					/* Location: */
-	MAC_CFG1_t cfg1;				/*  0x5000 */
-	MAC_CFG2_t cfg2;				/*  0x5004 */
+	u32 cfg1;					/*  0x5000 */
+	u32 cfg2;					/*  0x5004 */
 	u32 ipg;					/*  0x5008 */
 	u32 hfdp;					/*  0x500C */
 	MAC_MAX_FM_LEN_t max_fm_len;			/*  0x5010 */
--- a/drivers/staging/et131x/et1310_mac.c
+++ b/drivers/staging/et131x/et1310_mac.c
@@ -106,7 +106,7 @@ void ConfigMACRegs1(struct et131x_adapte
 	/* First we need to reset everything.  Write to MAC configuration
 	 * register 1 to perform reset.
 	 */
-	writel(0xC00F0000, &pMac->cfg1.value);
+	writel(0xC00F0000, &pMac->cfg1);
 
 	/* Next lets configure the MAC Inter-packet gap register */
 	ipg = 0x38005860;		/* IPG1 0x38 IPG2 0x58 B2B 0x60 */
@@ -149,7 +149,7 @@ void ConfigMACRegs1(struct et131x_adapte
 	writel(etdev->RegistryJumboPacket + 4, &pMac->max_fm_len.value);
 
 	/* clear out MAC config reset */
-	writel(0, &pMac->cfg1.value);
+	writel(0, &pMac->cfg1);
 }
 
 /**
@@ -160,74 +160,59 @@ void ConfigMACRegs2(struct et131x_adapte
 {
 	int32_t delay = 0;
 	struct _MAC_t __iomem *pMac = &etdev->regs->mac;
-	MAC_CFG1_t cfg1;
-	MAC_CFG2_t cfg2;
+	u32 cfg1;
+	u32 cfg2;
 	MAC_IF_CTRL_t ifctrl;
 	TXMAC_CTL_t ctl;
 
 	ctl.value = readl(&etdev->regs->txmac.ctl.value);
-	cfg1.value = readl(&pMac->cfg1.value);
-	cfg2.value = readl(&pMac->cfg2.value);
+	cfg1 = readl(&pMac->cfg1);
+	cfg2 = readl(&pMac->cfg2);
 	ifctrl.value = readl(&pMac->if_ctrl.value);
 
+	/* Set up the if mode bits */
+	cfg2 &= ~0x300;
 	if (etdev->linkspeed == TRUEPHY_SPEED_1000MBPS) {
-		cfg2.bits.if_mode = 0x2;
+		cfg2 |= 0x200;
 		ifctrl.bits.phy_mode = 0x0;
 	} else {
-		cfg2.bits.if_mode = 0x1;
+		cfg2 |= 0x100;
 		ifctrl.bits.phy_mode = 0x1;
 	}
 
 	/* We need to enable Rx/Tx */
-	cfg1.bits.rx_enable = 0x1;
-	cfg1.bits.tx_enable = 0x1;
-
-	/* Set up flow control */
-	cfg1.bits.tx_flow = 0x1;
-
-	if ((etdev->FlowControl == RxOnly) ||
-	    (etdev->FlowControl == Both)) {
-		cfg1.bits.rx_flow = 0x1;
-	} else {
-		cfg1.bits.rx_flow = 0x0;
-	}
-
+	cfg1 |= CFG1_RX_ENABLE|CFG1_TX_ENABLE|CFG1_TX_FLOW;
 	/* Initialize loop back to off */
-	cfg1.bits.loop_back = 0;
-
-	writel(cfg1.value, &pMac->cfg1.value);
+	cfg1 &= ~(CFG1_LOOPBACK|CFG1_RX_FLOW);
+	if (etdev->FlowControl == RxOnly || etdev->FlowControl == Both)
+		cfg1 |= CFG1_RX_FLOW;
+	writel(cfg1, &pMac->cfg1);
 
 	/* Now we need to initialize the MAC Configuration 2 register */
-	cfg2.bits.preamble_len = 0x7;
-	cfg2.bits.huge_frame = 0x0;
-	/* LENGTH FIELD CHECKING bit4: Set this bit to cause the MAC to check
-	 * the frame's length field to ensure it matches the actual data
-	 * field length. Clear this bit if no length field checking is
-	 * desired. Its default is 0.
-	 */
-	cfg2.bits.len_check = 0x1;
-
-	cfg2.bits.pad_crc = 0x1;
-	cfg2.bits.crc_enable = 0x1;
+	/* preamble 7, check length, huge frame off, pad crc, crc enable
+	   full duplex off */
+	cfg2 |= 0x7016;
+	cfg2 &= ~0x0021;
+
+	/* Turn on duplex if needed */
+	if (etdev->duplex_mode)
+		cfg2 |= 0x01;
 
-	/* 1 - full duplex, 0 - half-duplex */
-	cfg2.bits.full_duplex = etdev->duplex_mode;
 	ifctrl.bits.ghd_mode = !etdev->duplex_mode;
 
 	writel(ifctrl.value, &pMac->if_ctrl.value);
-	writel(cfg2.value, &pMac->cfg2.value);
+	writel(cfg2, &pMac->cfg2);
 
 	do {
 		udelay(10);
 		delay++;
-		cfg1.value = readl(&pMac->cfg1.value);
-	} while ((!cfg1.bits.syncd_rx_en || !cfg1.bits.syncd_tx_en) &&
-								 delay < 100);
+		cfg1 = readl(&pMac->cfg1);
+	} while ((cfg1 & CFG1_WAIT) != CFG1_WAIT && delay < 100);
 
 	if (delay == 100) {
 		dev_warn(&etdev->pdev->dev,
 		    "Syncd bits did not respond correctly cfg1 word 0x%08x\n",
-			cfg1.value);
+			cfg1);
 	}
 
 	/* Enable TXMAC */
--- a/drivers/staging/et131x/et131x_initpci.c
+++ b/drivers/staging/et131x/et131x_initpci.c
@@ -432,12 +432,12 @@ int et131x_adapter_setup(struct et131x_a
 void et131x_soft_reset(struct et131x_adapter *adapter)
 {
 	/* Disable MAC Core */
-	writel(0xc00f0000, &adapter->regs->mac.cfg1.value);
+	writel(0xc00f0000, &adapter->regs->mac.cfg1);
 
 	/* Set everything to a reset value */
 	writel(0x7F, &adapter->regs->global.sw_reset);
-	writel(0x000f0000, &adapter->regs->mac.cfg1.value);
-	writel(0x00000000, &adapter->regs->mac.cfg1.value);
+	writel(0x000f0000, &adapter->regs->mac.cfg1);
+	writel(0x00000000, &adapter->regs->mac.cfg1);
 }
 
 /**
