From alan@linux.intel.com  Thu Aug 27 14:27:23 2009
From: Alan Cox <alan@linux.intel.com>
Date: Thu, 27 Aug 2009 11:01:42 +0100
Subject: Staging: et131x: kill the Q_ADDR struct
To: greg@kroah.com
Message-ID: <20090827100137.23892.77489.stgit@localhost.localdomain>


Signed-off-by: Alan Cox <alan@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---

 drivers/staging/et131x/et1310_address_map.h |   48 +++++-----------------------
 drivers/staging/et131x/et1310_jagcore.c     |   41 +++++++++--------------
 drivers/staging/et131x/et131x_debug.c       |    4 +-
 3 files changed, 30 insertions(+), 63 deletions(-)


--- a/drivers/staging/et131x/et1310_address_map.h
+++ b/drivers/staging/et131x/et1310_address_map.h
@@ -61,41 +61,13 @@
 
 /* START OF GLOBAL REGISTER ADDRESS MAP */
 
-typedef union _Q_ADDR_t {
-	u32 value;
-	struct {
-#ifdef _BIT_FIELDS_HTOL
-		u32 unused:22;	/* bits 10-31 */
-		u32 addr:10;	/* bits 0-9 */
-#else
-		u32 addr:10;	/* bits 0-9 */
-		u32 unused:22;	/* bits 10-31 */
-#endif
-	} bits;
-} Q_ADDR_t, *PQ_ADDR_t;
-
-/*
- * structure for tx queue start address reg in global address map
- * located at address 0x0000
- * Defined earlier (Q_ADDR_t)
- */
-
-/*
- * structure for tx queue end address reg in global address map
- * located at address 0x0004
- * Defined earlier (Q_ADDR_t)
- */
-
-/*
- * structure for rx queue start address reg in global address map
- * located at address 0x0008
- * Defined earlier (Q_ADDR_t)
- */
-
 /*
- * structure for rx queue end address reg in global address map
- * located at address 0x000C
- * Defined earlier (Q_ADDR_t)
+ * 10bit registers
+ *
+ * Tx queue start address reg in global address map at address 0x0000
+ * tx queue end address reg in global address map at address 0x0004
+ * rx queue start address reg in global address map at address 0x0008
+ * rx queue end address reg in global address map at address 0x000C
  */
 
 /*
@@ -295,10 +267,10 @@ typedef union _LOOPBACK_t {
  * Located at address 0x0000
  */
 typedef struct _GLOBAL_t {			/* Location: */
-	Q_ADDR_t txq_start_addr;		/*  0x0000 */
-	Q_ADDR_t txq_end_addr;			/*  0x0004 */
-	Q_ADDR_t rxq_start_addr;		/*  0x0008 */
-	Q_ADDR_t rxq_end_addr;			/*  0x000C */
+	u32 txq_start_addr;			/*  0x0000 */
+	u32 txq_end_addr;			/*  0x0004 */
+	u32 rxq_start_addr;			/*  0x0008 */
+	u32 rxq_end_addr;			/*  0x000C */
 	PM_CSR_t pm_csr;			/*  0x0010 */
 	u32 unused;				/*  0x0014 */
 	INTERRUPT_t int_status;			/*  0x0018 */
--- a/drivers/staging/et131x/et1310_jagcore.c
+++ b/drivers/staging/et131x/et1310_jagcore.c
@@ -112,33 +112,26 @@ void ConfigGlobalRegs(struct et131x_adap
 			 * and Rx as it desires.  Our default is to split it
 			 * 50/50:
 			 */
-			writel(0, &pGbl->rxq_start_addr.value);
-			writel(PARM_RX_MEM_END_DEF,
-			       &pGbl->rxq_end_addr.value);
-			writel(PARM_RX_MEM_END_DEF + 1,
-			       &pGbl->txq_start_addr.value);
-			writel(INTERNAL_MEM_SIZE - 1,
-			       &pGbl->txq_end_addr.value);
+			writel(0, &pGbl->rxq_start_addr);
+			writel(PARM_RX_MEM_END_DEF, &pGbl->rxq_end_addr);
+			writel(PARM_RX_MEM_END_DEF + 1, &pGbl->txq_start_addr);
+			writel(INTERNAL_MEM_SIZE - 1, &pGbl->txq_end_addr);
 		} else if (etdev->RegistryJumboPacket < 8192) {
 			/* For jumbo packets > 2k but < 8k, split 50-50. */
-			writel(0, &pGbl->rxq_start_addr.value);
-			writel(INTERNAL_MEM_RX_OFFSET,
-			       &pGbl->rxq_end_addr.value);
-			writel(INTERNAL_MEM_RX_OFFSET + 1,
-			       &pGbl->txq_start_addr.value);
-			writel(INTERNAL_MEM_SIZE - 1,
-			       &pGbl->txq_end_addr.value);
+			writel(0, &pGbl->rxq_start_addr);
+			writel(INTERNAL_MEM_RX_OFFSET, &pGbl->rxq_end_addr);
+			writel(INTERNAL_MEM_RX_OFFSET + 1, &pGbl->txq_start_addr);
+			writel(INTERNAL_MEM_SIZE - 1, &pGbl->txq_end_addr);
 		} else {
 			/* 9216 is the only packet size greater than 8k that
 			 * is available. The Tx buffer has to be big enough
 			 * for one whole packet on the Tx side. We'll make
 			 * the Tx 9408, and give the rest to Rx
 			 */
-			writel(0x0000, &pGbl->rxq_start_addr.value);
-			writel(0x01b3, &pGbl->rxq_end_addr.value);
-			writel(0x01b4, &pGbl->txq_start_addr.value);
-			writel(INTERNAL_MEM_SIZE - 1,
-			       &pGbl->txq_end_addr.value);
+			writel(0x0000, &pGbl->rxq_start_addr);
+			writel(0x01b3, &pGbl->rxq_end_addr);
+			writel(0x01b4, &pGbl->txq_start_addr);
+			writel(INTERNAL_MEM_SIZE - 1,&pGbl->txq_end_addr);
 		}
 
 		/* Initialize the loopback register. Disable all loopbacks. */
@@ -149,13 +142,13 @@ void ConfigGlobalRegs(struct et131x_adap
 		 * RxMAC will write data into the space, and the TxMAC will
 		 * read it out.
 		 */
-		writel(0, &pGbl->rxq_start_addr.value);
-		writel(INTERNAL_MEM_SIZE - 1, &pGbl->rxq_end_addr.value);
-		writel(0, &pGbl->txq_start_addr.value);
-		writel(INTERNAL_MEM_SIZE - 1, &pGbl->txq_end_addr.value);
+		writel(0, &pGbl->rxq_start_addr);
+		writel(INTERNAL_MEM_SIZE - 1, &pGbl->rxq_end_addr);
+		writel(0, &pGbl->txq_start_addr);
+		writel(INTERNAL_MEM_SIZE - 1, &pGbl->txq_end_addr);
 
 		/* Initialize the loopback register (MAC loopback). */
-		writel(1, &pGbl->loopback.value);
+		writel(1, &pGbl->loopback);
 	}
 
 	/* MSI Register */
--- a/drivers/staging/et131x/et131x_debug.c
+++ b/drivers/staging/et131x/et131x_debug.c
@@ -1,3 +1,4 @@
+/*
  * Agere Systems Inc.
  * 10/100/1000 Base-T Ethernet Driver for the ET1301 and ET131x series MACs
  *
@@ -135,6 +136,8 @@ void DumpTxQueueContents(int debug, stru
 	}
 }
 
+#define NUM_BLOCKS 8
+
 static const char *BlockNames[NUM_BLOCKS] = {
 	"Global", "Tx DMA", "Rx DMA", "Tx MAC",
 	"Rx MAC", "MAC", "MAC Stat", "MMC"
@@ -148,7 +151,6 @@ static const char *BlockNames[NUM_BLOCKS
  * Dumps the first 64 regs of each block of the et-1310 (each block is
  * mapped to a new page, each page is 4096 bytes).
  */
-#define NUM_BLOCKS 8
 void DumpDeviceBlock(int debug, struct et131x_adapter *etdev,
 		     u32 block)
 {
